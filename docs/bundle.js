var _excluded = ["children", "heading", "tag"],
  _excluded2 = ["managedChildrenParameters"],
  _excluded3 = ["onClose", "open", "getWindow", "parentDepth"],
  _excluded4 = ["getElement"],
  _excluded5 = ["getElement"],
  _excluded6 = ["refElementPopupReturn", "refElementSourceReturn", "lostFocusDismiss"],
  _excluded7 = ["getElement"],
  _excluded8 = ["open", "onClose"],
  _excluded9 = ["getElement"],
  _excluded10 = ["backdropDismissParameters", "refElementPopupReturn"],
  _excluded11 = ["onElementChange"],
  _excluded12 = ["collator", "typeaheadTimeout", "noTypeahead", "isValid"],
  _excluded13 = ["getTabbableIndex", "setTabbableIndex"],
  _excluded14 = ["typeaheadNavigationParameters", "rovingTabIndexReturn"],
  _excluded15 = ["index"],
  _excluded16 = ["getText"],
  _excluded17 = ["sortedTypeaheadInfo", "insertingComparator"],
  _excluded18 = ["getElement"],
  _excluded19 = ["managedChildParameters", "textContentParameters", "typeaheadNavigationChildContext", "refElementReturn"],
  _excluded20 = ["managedChildrenReturn", "rovingTabIndexParameters"],
  _excluded21 = ["index"],
  _excluded22 = ["hidden"],
  _excluded23 = ["linearNavigationParameters", "typeaheadNavigationParameters", "rovingTabIndexParameters", "managedChildrenReturn"],
  _excluded24 = ["rovingTabIndexChildParameters", "rovingTabIndexChildContext", "typeaheadNavigationChildContext", "managedChildParameters", "refElementReturn", "textContentParameters"],
  _excluded25 = ["onTabbableColumnChange"],
  _excluded26 = ["onTabbableIndexChange"],
  _excluded27 = ["gridNavigationParameters", "linearNavigationParameters", "rovingTabIndexParameters", "managedChildrenReturn", "typeaheadNavigationParameters"],
  _excluded28 = ["linearNavigationReturn", "rovingTabIndexReturn", "typeaheadNavigationReturn", "managedChildrenParameters", "rovingTabIndexChildContext", "typeaheadNavigationChildContext"],
  _excluded29 = ["gridNavigationRowContext"],
  _excluded30 = ["untabbable"],
  _excluded31 = ["linearNavigationParameters", "rovingTabIndexParameters"],
  _excluded32 = ["rowAsChildOfGridParameters", "rowAsParentOfCellsParameters"],
  _excluded33 = ["rovingTabIndexChildContext", "typeaheadNavigationChildContext", "rovingTabIndexChildParameters", "managedChildParameters", "refElementReturn", "textContentParameters", "gridNavigationCellParameters", "gridNavigationCellContext"],
  _excluded34 = ["hasCurrentFocusParameters", "rovingTabIndexChildReturn", "textContentReturn"],
  _excluded35 = ["gridNavigationParameters", "linearNavigationParameters", "rovingTabIndexParameters", "managedChildrenReturn", "typeaheadNavigationParameters", "singleSelectionParameters"],
  _excluded36 = ["rowAsChildOfGridParameters", "rowAsParentOfCellsParameters"],
  _excluded37 = ["onCurrentFocusedInnerChanged"],
  _excluded38 = ["hasCurrentFocusParameters", "gridNavigationRowParameters", "rovingTabIndexChildReturn", "textContentReturn"],
  _excluded39 = ["onCurrentFocusedInnerChanged"],
  _excluded40 = ["rearrangeableChildrenParameters", "sortableChildrenParameters", "linearNavigationParameters"],
  _excluded41 = ["linearNavigationParameters", "rovingTabIndexParameters", "typeaheadNavigationParameters", "singleSelectionParameters", "managedChildrenReturn"],
  _excluded42 = ["index"],
  _excluded43 = ["hidden"],
  _excluded44 = ["managedChildParameters", "rovingTabIndexChildParameters", "singleSelectionChildParameters", "singleSelectionContext", "rovingTabIndexChildContext", "typeaheadNavigationChildContext", "refElementReturn", "textContentParameters"],
  _excluded45 = ["hasCurrentFocusParameters"],
  _excluded46 = ["onCurrentFocusedInnerChanged"],
  _excluded47 = ["hasCurrentFocusParameters"],
  _excluded48 = ["onCurrentFocusedInnerChanged"],
  _excluded49 = ["childrenHaveFocusParameters", "managedChildrenParameters", "rovingTabIndexChildContext", "singleSelectionContext", "typeaheadNavigationChildContext", "gridNavigationRowContext"],
  _excluded50 = ["managedChildParameters", "context", "completeGridNavigationRowParameters", "singleSelectionChildParameters", "rovingTabIndexChildParameters"],
  _excluded51 = ["linearNavigationParameters", "rovingTabIndexParameters", "typeaheadNavigationParameters"],
  _excluded52 = ["onPressSync"],
  _excluded53 = ["linearNavigationParameters", "rearrangeableChildrenParameters", "sortableChildrenParameters", "typeaheadNavigationParameters", "rovingTabIndexParameters", "singleSelectionParameters"],
  _excluded54 = ["onPressSync"],
  _excluded55 = ["completeListNavigationChildParameters", "singleSelectionChildParameters", "rovingTabIndexChildParameters", "managedChildParameters", "textContentParameters", "context", "pressParameters", "sortableChildParameters"],
  _excluded56 = ["onPressSync"],
  _excluded57 = ["trapActive"],
  _excluded58 = ["refElementReturn"],
  _excluded59 = ["refElementReturn"],
  _excluded60 = ["getElement", "propsStable"],
  _excluded61 = ["linearNavigationParameters", "toolbarParameters"],
  _excluded62 = ["context", "props"],
  _excluded63 = ["linearNavigationReturn", "childrenHaveFocusReturn", "context", "props", "rearrangeableChildrenReturn", "singleSelectionReturn", "sortableChildrenReturn", "managedChildrenReturn", "rovingTabIndexReturn", "toolbarReturn", "typeaheadNavigationReturn"],
  _excluded64 = ["sliderContext"],
  _excluded65 = ["tableCellParameters"],
  _excluded66 = ["setSelectedIndex"],
  _excluded67 = ["props", "context"],
  _excluded68 = ["selectionMode"],
  _excluded69 = ["props"],
  _excluded70 = ["context", "managedChildrenReturn"],
  _excluded71 = ["index"],
  _excluded72 = ["disableArrowKeys", "disableHomeEndKeys", "initialIndex", "navigationDirection", "onAfterChildLayoutEffect", "onChildrenMountChange", "navigatePastEnd", "navigatePastStart", "pageNavigationSize", "render"],
  _excluded73 = ["children"],
  _excluded74 = ["render", "collator", "disableArrowKeys", "disableHomeEndKeys", "navigationDirection", "noTypeahead", "typeaheadTimeout", "onTabbableIndexChange", "compare", "getIndex", "untabbable", "navigatePastEnd", "navigatePastStart", "pageNavigationSize", "children"],
  _excluded75 = ["render", "index", "focusSelf", "exclude", "hidden", "getText", "onPressSync", "getSortValue"],
  _excluded76 = ["index", "exclude", "onPressSync", "render", "checked", "onChangeFromParent", "getSortValue", "hidden", "getText", "focusSelf"],
  _excluded77 = ["listboxContext"],
  _excluded78 = ["children"];
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure " + obj); }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
(function () {
  'use strict';

  var n,
    l$1,
    u$1,
    t$1,
    o$2,
    r$2,
    f$1 = {},
    e$1 = [],
    c$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function s$1(n, l) {
    for (var u in l) {
      n[u] = l[u];
    }
    return n;
  }
  function a$1(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
  }
  function h$1(l, u, i) {
    var t,
      o,
      r,
      f = {};
    for (r in u) {
      "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
    }
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) {
      void 0 === f[r] && (f[r] = l.defaultProps[r]);
    }
    return v$1(l, f, t, o, null);
  }
  function v$1(n, i, t, o, r) {
    var f = {
      type: n,
      props: i,
      key: t,
      ref: o,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == r ? ++u$1 : r
    };
    return null == r && null != l$1.vnode && l$1.vnode(f), f;
  }
  function p$1(n) {
    return n.children;
  }
  function d$1(n, l) {
    this.props = n, this.context = l;
  }
  function _$2(n, l) {
    if (null == l) return n.__ ? _$2(n.__, n.__.__k.indexOf(n) + 1) : null;
    for (var u; l < n.__k.length; l++) {
      if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    }
    return "function" == typeof n.type ? _$2(n) : null;
  }
  function k$2(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
      for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {
        if (null != (u = n.__k[l]) && null != u.__e) {
          n.__e = n.__c.base = u.__e;
          break;
        }
      }
      return k$2(n);
    }
  }
  function b$1(n) {
    (!n.__d && (n.__d = !0) && t$1.push(n) && !g$2.__r++ || o$2 !== l$1.debounceRendering) && ((o$2 = l$1.debounceRendering) || setTimeout)(g$2);
  }
  function g$2() {
    for (var n; g$2.__r = t$1.length;) {
      n = t$1.sort(function (n, l) {
        return n.__v.__b - l.__v.__b;
      }), t$1 = [], n.some(function (n) {
        var l, u, i, t, o, r;
        n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = s$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? _$2(t) : o, t.__h), z$2(u, t), t.__e != o && k$2(t)));
      });
    }
  }
  function w$2(n, l, u, i, t, o, r, c, s, a) {
    var h,
      y,
      d,
      k,
      b,
      g,
      w,
      x = i && i.__k || e$1,
      C = x.length;
    for (u.__k = [], h = 0; h < l.length; h++) {
      if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? v$1(null, k, null, null, k) : Array.isArray(k) ? v$1(p$1, {
        children: k
      }, null, null, null) : k.__b > 0 ? v$1(k.type, k.props, k.key, k.ref ? k.ref : null, k.__v) : k)) {
        if (k.__ = u, k.__b = u.__b + 1, null === (d = x[h]) || d && k.key == d.key && k.type === d.type) x[h] = void 0;else for (y = 0; y < C; y++) {
          if ((d = x[y]) && k.key == d.key && k.type === d.type) {
            x[y] = void 0;
            break;
          }
          d = null;
        }
        j$2(n, k, d = d || f$1, t, o, r, c, s, a), b = k.__e, (y = k.ref) && d.ref != y && (w || (w = []), d.ref && w.push(d.ref, null, k), w.push(y, k.__c || b, k)), null != b ? (null == g && (g = b), "function" == typeof k.type && k.__k === d.__k ? k.__d = s = m$1(k, s, n) : s = A$1(n, k, d, x, b, s), "function" == typeof u.type && (u.__d = s)) : s && d.__e == s && s.parentNode != n && (s = _$2(d));
      }
    }
    for (u.__e = g, h = C; h--;) {
      null != x[h] && N$1(x[h], x[h]);
    }
    if (w) for (h = 0; h < w.length; h++) {
      M(w[h], w[++h], w[++h]);
    }
  }
  function m$1(n, l, u) {
    for (var i, t = n.__k, o = 0; t && o < t.length; o++) {
      (i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? m$1(i, l, u) : A$1(u, i, i, t, i.__e, l));
    }
    return l;
  }
  function x$1(n, l) {
    return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
      x$1(n, l);
    }) : l.push(n)), l;
  }
  function A$1(n, l, u, i, t, o) {
    var r, f, e;
    if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
      for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 1) {
        if (f == t) break n;
      }
      n.insertBefore(t, o), r = o;
    }
    return void 0 !== r ? r : t.nextSibling;
  }
  function C$1(n, l, u, i, t) {
    var o;
    for (o in u) {
      "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);
    }
    for (o in l) {
      t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
    }
  }
  function $$1(n, l, u) {
    "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || c$1.test(l) ? u : u + "px";
  }
  function H$1(n, l, u, i, t) {
    var o;
    n: if ("style" === l) {
      if ("string" == typeof u) n.style.cssText = u;else {
        if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) {
          u && l in u || $$1(n.style, l, "");
        }
        if (u) for (l in u) {
          i && u[l] === i[l] || $$1(n.style, l, u[l]);
        }
      }
    } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$2 : I$1, o) : n.removeEventListener(l, o ? T$2 : I$1, o);else if ("dangerouslySetInnerHTML" !== l) {
      if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
        n[l] = null == u ? "" : u;
        break n;
      } catch (n) {}
      "function" == typeof u || (null == u || !1 === u && -1 == l.indexOf("-") ? n.removeAttribute(l) : n.setAttribute(l, u));
    }
  }
  function I$1(n) {
    this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
  }
  function T$2(n) {
    this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
  }
  function j$2(n, u, i, t, o, r, f, e, c) {
    var a,
      h,
      v,
      y,
      _,
      k,
      b,
      g,
      m,
      x,
      A,
      C,
      $,
      H,
      I,
      T = u.type;
    if (void 0 !== u.constructor) return null;
    null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (a = l$1.__b) && a(u);
    try {
      n: if ("function" == typeof T) {
        if (g = u.props, m = (a = T.contextType) && t[a.__c], x = a ? m ? m.props.value : a.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in T && T.prototype.render ? u.__c = h = new T(g, x) : (u.__c = h = new d$1(g, x), h.constructor = T, h.render = O), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = [], h._sb = []), null == h.__s && (h.__s = h.state), null != T.getDerivedStateFromProps && (h.__s == h.state && (h.__s = s$1({}, h.__s)), s$1(h.__s, T.getDerivedStateFromProps(g, h.__s))), y = h.props, _ = h.state, v) null == T.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
          if (null == T.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
            for (h.props = g, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
              n && (n.__ = u);
            }), A = 0; A < h._sb.length; A++) {
              h.__h.push(h._sb[A]);
            }
            h._sb = [], h.__h.length && f.push(h);
            break n;
          }
          null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
            h.componentDidUpdate(y, _, k);
          });
        }
        if (h.context = x, h.props = g, h.__v = u, h.__P = n, C = l$1.__r, $ = 0, "prototype" in T && T.prototype.render) {
          for (h.state = h.__s, h.__d = !1, C && C(u), a = h.render(h.props, h.state, h.context), H = 0; H < h._sb.length; H++) {
            h.__h.push(h._sb[H]);
          }
          h._sb = [];
        } else do {
          h.__d = !1, C && C(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
        } while (h.__d && ++$ < 25);
        h.state = h.__s, null != h.getChildContext && (t = s$1(s$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, _)), I = null != a && a.type === p$1 && null == a.key ? a.props.children : a, w$2(n, Array.isArray(I) ? I : [I], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
      } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);
      (a = l$1.diffed) && a(u);
    } catch (n) {
      u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
    }
  }
  function z$2(n, u) {
    l$1.__c && l$1.__c(u, n), n.some(function (u) {
      try {
        n = u.__h, u.__h = [], n.some(function (n) {
          n.call(u);
        });
      } catch (n) {
        l$1.__e(n, u.__v);
      }
    });
  }
  function L$1(l, u, i, t, o, r, e, c) {
    var s,
      h,
      v,
      y = i.props,
      p = u.props,
      d = u.type,
      k = 0;
    if ("svg" === d && (o = !0), null != r) for (; k < r.length; k++) {
      if ((s = r[k]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
        l = s, r[k] = null;
        break;
      }
    }
    if (null == l) {
      if (null === d) return document.createTextNode(p);
      l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
    }
    if (null === d) y === p || c && l.data === p || (l.data = p);else {
      if (r = r && n.call(l.childNodes), h = (y = i.props || f$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
        if (null != r) for (y = {}, k = 0; k < l.attributes.length; k++) {
          y[l.attributes[k].name] = l.attributes[k].value;
        }
        (v || h) && (v && (h && v.__html == h.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
      }
      if (C$1(l, p, y, o, c), v) u.__k = [];else if (k = u.props.children, w$2(l, Array.isArray(k) ? k : [k], u, i, t, o && "foreignObject" !== d, r, e, r ? r[0] : i.__k && _$2(i, 0), c), null != r) for (k = r.length; k--;) {
        null != r[k] && a$1(r[k]);
      }
      c || ("value" in p && void 0 !== (k = p.value) && (k !== l.value || "progress" === d && !k || "option" === d && k !== y.value) && H$1(l, "value", k, y.value, !1), "checked" in p && void 0 !== (k = p.checked) && k !== l.checked && H$1(l, "checked", k, y.checked, !1));
    }
    return l;
  }
  function M(n, u, i) {
    try {
      "function" == typeof n ? n(u) : n.current = u;
    } catch (n) {
      l$1.__e(n, i);
    }
  }
  function N$1(n, u, i) {
    var t, o;
    if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M(t, null, u)), null != (t = n.__c)) {
      if (t.componentWillUnmount) try {
        t.componentWillUnmount();
      } catch (n) {
        l$1.__e(n, u);
      }
      t.base = t.__P = null, n.__c = void 0;
    }
    if (t = n.__k) for (o = 0; o < t.length; o++) {
      t[o] && N$1(t[o], u, i || "function" != typeof n.type);
    }
    i || null == n.__e || a$1(n.__e), n.__ = n.__e = n.__d = void 0;
  }
  function O(n, l, u) {
    return this.constructor(n, u);
  }
  function P$1(u, i, t) {
    var o, r, e;
    l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, e = [], j$2(i, u = (!o && t || i).__k = h$1(p$1, null, [u]), r || f$1, f$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, e, !o && t ? t : r ? r.__e : i.firstChild, o), z$2(e, u);
  }
  function B$2(n, l) {
    var u = {
      __c: l = "__cC" + r$2++,
      __: n,
      Consumer: function (n, l) {
        return n.children(l);
      },
      Provider: function (n) {
        var u, i;
        return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
          return i;
        }, this.shouldComponentUpdate = function (n) {
          this.props.value !== n.value && u.some(b$1);
        }, this.sub = function (n) {
          u.push(n);
          var l = n.componentWillUnmount;
          n.componentWillUnmount = function () {
            u.splice(u.indexOf(n), 1), l && l.call(n);
          };
        }), n.children;
      }
    };
    return u.Provider.__ = u.Consumer.contextType = u;
  }
  n = e$1.slice, l$1 = {
    __e: function (n, l, u, i) {
      for (var t, o, r; l = l.__;) {
        if ((t = l.__c) && !t.__) try {
          if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), r) return t.__E = t;
        } catch (l) {
          n = l;
        }
      }
      throw n;
    }
  }, u$1 = 0, d$1.prototype.setState = function (n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s$1({}, this.state), "function" == typeof n && (n = n(s$1({}, u), this.props)), n && s$1(u, n), null != n && this.__v && (l && this._sb.push(l), b$1(this));
  }, d$1.prototype.forceUpdate = function (n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), b$1(this));
  }, d$1.prototype.render = p$1, t$1 = [], g$2.__r = 0, r$2 = 0;
  var _$1 = 0;
  function o$1(o, e, n, t, f) {
    var l,
      s,
      u = {};
    for (s in e) {
      "ref" == s ? l = e[s] : u[s] = e[s];
    }
    var a = {
      type: o,
      props: u,
      key: n,
      ref: l,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: --_$1,
      __source: f,
      __self: t
    };
    if ("function" == typeof o && (l = o.defaultProps)) for (s in l) {
      void 0 === u[s] && (u[s] = l[s]);
    }
    return l$1.vnode && l$1.vnode(a), a;
  }
  var t,
    r$1,
    u,
    i,
    o = 0,
    f = [],
    c = [],
    e = l$1.__b,
    a = l$1.__r,
    v = l$1.diffed,
    l = l$1.__c,
    m = l$1.unmount;
  function d(t, u) {
    l$1.__h && l$1.__h(r$1, t, o || u), o = 0;
    var i = r$1.__H || (r$1.__H = {
      __: [],
      __h: []
    });
    return t >= i.__.length && i.__.push({
      __V: c
    }), i.__[t];
  }
  function p(n) {
    return o = 1, y(B$1, n);
  }
  function y(n, u, i) {
    var o = d(t++, 2);
    if (o.t = n, !o.__c && (o.__ = [i ? i(u) : B$1(void 0, u), function (n) {
      var t = o.__N ? o.__N[0] : o.__[0],
        r = o.t(t, n);
      t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
    }], o.__c = r$1, !r$1.u)) {
      r$1.u = !0;
      var f = r$1.shouldComponentUpdate;
      r$1.shouldComponentUpdate = function (n, t, r) {
        if (!o.__c.__H) return !0;
        var u = o.__c.__H.__.filter(function (n) {
          return n.__c;
        });
        if (u.every(function (n) {
          return !n.__N;
        })) return !f || f.call(this, n, t, r);
        var i = !1;
        return u.forEach(function (n) {
          if (n.__N) {
            var t = n.__[0];
            n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
          }
        }), !(!i && o.__c.props === n) && (!f || f.call(this, n, t, r));
      };
    }
    return o.__N || o.__;
  }
  function h(u, i) {
    var o = d(t++, 3);
    !l$1.__s && z$1(o.__H, i) && (o.__ = u, o.i = i, r$1.__H.__h.push(o));
  }
  function s(u, i) {
    var o = d(t++, 4);
    !l$1.__s && z$1(o.__H, i) && (o.__ = u, o.i = i, r$1.__h.push(o));
  }
  function _(n) {
    return o = 5, F$1(function () {
      return {
        current: n
      };
    }, []);
  }
  function A(n, t, r) {
    o = 6, s(function () {
      return "function" == typeof n ? (n(t()), function () {
        return n(null);
      }) : n ? (n.current = t(), function () {
        return n.current = null;
      }) : void 0;
    }, null == r ? r : r.concat(n));
  }
  function F$1(n, r) {
    var u = d(t++, 7);
    return z$1(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;
  }
  function T$1(n, t) {
    return o = 8, F$1(function () {
      return n;
    }, t);
  }
  function q(n) {
    var u = r$1.context[n.__c],
      i = d(t++, 9);
    return i.c = n, u ? (null == i.__ && (i.__ = !0, u.sub(r$1)), u.props.value) : n.__;
  }
  function V$1() {
    var n = d(t++, 11);
    if (!n.__) {
      for (var u = r$1.__v; null !== u && !u.__m && null !== u.__;) {
        u = u.__;
      }
      var i = u.__m || (u.__m = [0, 0]);
      n.__ = "P" + i[0] + "-" + i[1]++;
    }
    return n.__;
  }
  function b() {
    for (var t; t = f.shift();) {
      if (t.__P && t.__H) try {
        t.__H.__h.forEach(k$1), t.__H.__h.forEach(w$1), t.__H.__h = [];
      } catch (r) {
        t.__H.__h = [], l$1.__e(r, t.__v);
      }
    }
  }
  l$1.__b = function (n) {
    r$1 = null, e && e(n);
  }, l$1.__r = function (n) {
    a && a(n), t = 0;
    var i = (r$1 = n.__c).__H;
    i && (u === r$1 ? (i.__h = [], r$1.__h = [], i.__.forEach(function (n) {
      n.__N && (n.__ = n.__N), n.__V = c, n.__N = n.i = void 0;
    })) : (i.__h.forEach(k$1), i.__h.forEach(w$1), i.__h = [])), u = r$1;
  }, l$1.diffed = function (t) {
    v && v(t);
    var o = t.__c;
    o && o.__H && (o.__H.__h.length && (1 !== f.push(o) && i === l$1.requestAnimationFrame || ((i = l$1.requestAnimationFrame) || j$1)(b)), o.__H.__.forEach(function (n) {
      n.i && (n.__H = n.i), n.__V !== c && (n.__ = n.__V), n.i = void 0, n.__V = c;
    })), u = r$1 = null;
  }, l$1.__c = function (t, r) {
    r.some(function (t) {
      try {
        t.__h.forEach(k$1), t.__h = t.__h.filter(function (n) {
          return !n.__ || w$1(n);
        });
      } catch (u) {
        r.some(function (n) {
          n.__h && (n.__h = []);
        }), r = [], l$1.__e(u, t.__v);
      }
    }), l && l(t, r);
  }, l$1.unmount = function (t) {
    m && m(t);
    var r,
      u = t.__c;
    u && u.__H && (u.__H.__.forEach(function (n) {
      try {
        k$1(n);
      } catch (n) {
        r = n;
      }
    }), u.__H = void 0, r && l$1.__e(r, u.__v));
  };
  var g$1 = "function" == typeof requestAnimationFrame;
  function j$1(n) {
    var t,
      r = function () {
        clearTimeout(u), g$1 && cancelAnimationFrame(t), setTimeout(n);
      },
      u = setTimeout(r, 100);
    g$1 && (t = requestAnimationFrame(r));
  }
  function k$1(n) {
    var t = r$1,
      u = n.__c;
    "function" == typeof u && (n.__c = void 0, u()), r$1 = t;
  }
  function w$1(n) {
    var t = r$1;
    n.__c = n.__(), r$1 = t;
  }
  function z$1(n, t) {
    return !n || n.length !== t.length || t.some(function (t, r) {
      return t !== n[r];
    });
  }
  function B$1(n, t) {
    return "function" == typeof t ? t(n) : t;
  }
  function g(n, t) {
    for (var e in t) {
      n[e] = t[e];
    }
    return n;
  }
  function C(n, t) {
    for (var e in n) {
      if ("__source" !== e && !(e in t)) return !0;
    }
    for (var r in t) {
      if ("__source" !== r && n[r] !== t[r]) return !0;
    }
    return !1;
  }
  function w(n) {
    this.props = n;
  }
  function R(n, e) {
    function r(n) {
      var t = this.props.ref,
        r = t == n.ref;
      return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : C(this.props, n);
    }
    function u(e) {
      return this.shouldComponentUpdate = r, h$1(n, e);
    }
    return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = !0, u.__f = !0, u;
  }
  (w.prototype = new d$1()).isPureReactComponent = !0, w.prototype.shouldComponentUpdate = function (n, t) {
    return C(this.props, n) || C(this.state, t);
  };
  var x = l$1.__b;
  l$1.__b = function (n) {
    n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), x && x(n);
  };
  var N = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  function k(n) {
    function t(t) {
      var e = g({}, t);
      return delete e.ref, n(e, t.ref || null);
    }
    return t.$$typeof = N, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
  }
  var T = l$1.__e;
  l$1.__e = function (n, t, e, r) {
    if (n.then) for (var u, o = t; o = o.__;) {
      if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
    }
    T(n, t, e, r);
  };
  var I = l$1.unmount;
  function L(n, t, e) {
    return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
      "function" == typeof n.__c && n.__c();
    }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
      return L(n, t, e);
    })), n;
  }
  function U(n, t, e) {
    return n && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
      return U(n, t, e);
    }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
  }
  function D() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function F(n) {
    var t = n.__.__c;
    return t && t.__a && t.__a(n);
  }
  function V() {
    this.u = null, this.o = null;
  }
  l$1.unmount = function (n) {
    var t = n.__c;
    t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), I && I(n);
  }, (D.prototype = new d$1()).__c = function (n, t) {
    var e = t.__c,
      r = this;
    null == r.t && (r.t = []), r.t.push(e);
    var u = F(r.__v),
      o = !1,
      i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };
    e.__R = i;
    var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;
            r.__v.__k[0] = U(n, n.__c.__P, n.__c.__O);
          }
          var t;
          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) {
            t.forceUpdate();
          }
        }
      },
      c = !0 === t.__h;
    r.__u++ || c || r.setState({
      __a: r.__b = r.__v.__k[0]
    }), n.then(i, i);
  }, D.prototype.componentWillUnmount = function () {
    this.t = [];
  }, D.prototype.render = function (n, e) {
    if (this.__b) {
      if (this.__v.__k) {
        var r = document.createElement("div"),
          o = this.__v.__k[0].__c;
        this.__v.__k[0] = L(this.__b, r, o.__O = o.__P);
      }
      this.__b = null;
    }
    var i = e.__a && h$1(p$1, null, n.fallback);
    return i && (i.__h = null), [h$1(p$1, null, e.__a ? null : n.children), i];
  };
  var W = function (n, t, e) {
    if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
      for (; e.length > 3;) {
        e.pop()();
      }
      if (e[1] < e[0]) break;
      n.u = e = e[2];
    }
  };
  function P(n) {
    return this.getChildContext = function () {
      return n.context;
    }, n.children;
  }
  function $(n) {
    var e = this,
      r = n.i;
    e.componentWillUnmount = function () {
      P$1(null, e.l), e.l = null, e.i = null;
    }, e.i && e.i !== r && e.componentWillUnmount(), n.__v ? (e.l || (e.i = r, e.l = {
      nodeType: 1,
      parentNode: r,
      childNodes: [],
      appendChild: function (n) {
        this.childNodes.push(n), e.i.appendChild(n);
      },
      insertBefore: function (n, t) {
        this.childNodes.push(n), e.i.appendChild(n);
      },
      removeChild: function (n) {
        this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), e.i.removeChild(n);
      }
    }), P$1(h$1(P, {
      context: e.context
    }, n.__v), e.l)) : e.l && e.componentWillUnmount();
  }
  function j(n, e) {
    var r = h$1($, {
      __v: n,
      i: e
    });
    return r.containerInfo = e, r;
  }
  (V.prototype = new d$1()).__a = function (n) {
    var t = this,
      e = F(t.__v),
      r = t.o.get(n);
    return r[0]++, function (u) {
      var o = function () {
        t.props.revealOrder ? (r.push(u), W(t, n, r)) : u();
      };
      e ? e(o) : o();
    };
  }, V.prototype.render = function (n) {
    this.u = null, this.o = new Map();
    var t = x$1(n.children);
    n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
    for (var e = t.length; e--;) {
      this.o.set(t[e], this.u = [1, 0, this.u]);
    }
    return n.children;
  }, V.prototype.componentDidUpdate = V.prototype.componentDidMount = function () {
    var n = this;
    this.o.forEach(function (t, e) {
      W(n, e, t);
    });
  };
  var z = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
    B = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
    H = "undefined" != typeof document,
    Z = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };
  d$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
    Object.defineProperty(d$1.prototype, t, {
      configurable: !0,
      get: function () {
        return this["UNSAFE_" + t];
      },
      set: function (n) {
        Object.defineProperty(this, t, {
          configurable: !0,
          writable: !0,
          value: n
        });
      }
    });
  });
  var G = l$1.event;
  function J() {}
  function K() {
    return this.cancelBubble;
  }
  function Q() {
    return this.defaultPrevented;
  }
  l$1.event = function (n) {
    return G && (n = G(n)), n.persist = J, n.isPropagationStopped = K, n.isDefaultPrevented = Q, n.nativeEvent = n;
  };
  var nn = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
    tn = l$1.vnode;
  l$1.vnode = function (n) {
    var t = n.type,
      e = n.props,
      u = e;
    if ("string" == typeof t) {
      var o = -1 === t.indexOf("-");
      for (var i in u = {}, e) {
        var l = e[i];
        H && "children" === i && "noscript" === t || "value" === i && "defaultValue" in e && null == l || ("defaultValue" === i && "value" in e && null == e.value ? i = "value" : "download" === i && !0 === l ? l = "" : /ondoubleclick/i.test(i) ? i = "ondblclick" : /^onchange(textarea|input)/i.test(i + t) && !Z(e.type) ? i = "oninput" : /^onfocus$/i.test(i) ? i = "onfocusin" : /^onblur$/i.test(i) ? i = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && B.test(i) ? i = i.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = "oninputCapture")), u[i] = l);
      }
      "select" == t && u.multiple && Array.isArray(u.value) && (u.value = x$1(e.children).forEach(function (n) {
        n.props.selected = -1 != u.value.indexOf(n.props.value);
      })), "select" == t && null != u.defaultValue && (u.value = x$1(e.children).forEach(function (n) {
        n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
      })), n.props = u, e.class != e.className && (nn.enumerable = "className" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, "className", nn));
    }
    n.$$typeof = z, tn && tn(n);
  };
  var en = l$1.__r;
  l$1.__r = function (n) {
    en && en(n), n.__c;
  };
  var EventDetail = Symbol("event-detail");
  function enhanceEvent(e, detail) {
    var event = e;
    event[EventDetail] = detail;
    return event;
  }
  var alreadyWarned = new Set();
  function overwriteWithWarning(componentName, props, propName, newValue) {
    //const key = `${componentName};${propName}`;
    var oldValue = props[propName];
    if (oldValue != null) {
      if (!alreadyWarned.has(String(propName))) {
        alreadyWarned.add(String(propName));
        console.warn("The ".concat(String(propName), " attribute on ").concat(componentName, " was given a value of ").concat(oldValue, " but is being overwritten to ").concat(newValue, " for conformance. Consider removing it before passing those props to ").concat(componentName, "."));
      }
    }
    props[propName] = newValue;
  }
  var debug = false;
  function setDebugLogging(logging) {
    debug = logging;
  }
  function debugLog(who) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (debug) console.debug(who + ":", ...args);
  }
  function noop$2() {
    return;
  }
  // (These do not need to be unique)
  var Prefices = {
    accordionSectionHeaderButton: "ashb-",
    accordionSectionBody: "asb-",
    checkboxLikeInput: "cbli-",
    checkboxLikeLabel: "cbll-",
    dialog: "mdl-",
    dialogTitle: "mdlt-",
    drawer: "mdw-",
    drawerTitle: "mdwt-",
    gridlist: "gl-",
    gridlistLabel: "gll-",
    listbox: "lb-",
    listboxLabel: "lbl-",
    menu: "menu-",
    progressIndicator: "pi-",
    progressLabel: "pl-",
    radioGroup: "rg-",
    radioGroupLabel: "rgl-",
    radio: "rb-",
    radioLabel: "rbl-",
    sliderThumb: "st-",
    table: "tb-",
    tableLabel: "tbl-",
    tablist: "tl-",
    tablistLabel: "tll-",
    tooltip: "tt-"
  };
  var HeadingLevelContext = B$2(0);
  var Heading = R(function Heading(_ref2) {
    var {
        children,
        heading,
        tag
      } = _ref2,
      props = _objectWithoutProperties(_ref2, _excluded);
    var headingLevelBeforeUs = q(HeadingLevelContext);
    var newHeadingLevel = headingLevelBeforeUs + 1;
    if (tag == null) {
      if (newHeadingLevel <= 6) {
        tag = "h".concat(newHeadingLevel);
      } else {
        tag = 'div';
        overwriteWithWarning("Heading", props, "aria-level", "".concat(newHeadingLevel));
      }
    }
    return o$1(p$1, {
      children: o$1(HeadingReset, {
        newLevel: headingLevelBeforeUs + 1,
        children: [h$1(tag, props, heading), children]
      })
    });
  });
  var HeadingReset = R(function HeadingReset(_ref3) {
    var {
      newLevel,
      children
    } = _ref3;
    return o$1(HeadingLevelContext.Provider, {
      value: newLevel,
      children: children
    });
  });

  /**
   * Debug hook.
   *
   * Given a value or set of values, emits a console error if any of them change from one render to the next.
   *
   * Eventually, when useEvent lands, we hopefully won't need this.
   */
  function useEnsureStability(parentHookName) {
    for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      values[_key2 - 1] = arguments[_key2];
    }
    var helperToEnsureStability = _([]);
    var shownError = _([]);
    useHelper(values.length, -1);
    values.forEach(useHelper);
    return;
    function useHelper(value, i) {
      var index = i + 1;
      // Make sure that the provided functions are perfectly stable across renders
      if (helperToEnsureStability.current[index] === undefined) helperToEnsureStability.current[index] = value;
      if (helperToEnsureStability.current[index] != value) {
        if (!shownError.current[index]) {
          /* eslint-disable no-debugger */
          debugger;
          console.error("The hook ".concat(parentHookName, " requires some or all of its arguments remain stable across each render; please check the ").concat(i, "-indexed argument (").concat(i >= 0 ? JSON.stringify(values[i]) : "the number of supposedly stable elements", ")."));
          shownError.current[index] = true;
        }
      }
    }
  }
  function debounceRendering(f) {
    var _l$1$debounceRenderin;
    ((_l$1$debounceRenderin = l$1.debounceRendering) !== null && _l$1$debounceRenderin !== void 0 ? _l$1$debounceRenderin : setTimeout)(f);
  }
  /**
   * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
   *
   * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
   *
   * To summarize, it's like a `useState`-`useEffect` mashup:
   *
   * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
   * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
   * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
   * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
   *
   * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
   *
   * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
   * @returns
   */
  function usePassiveState(onChange, getInitialValue, customDebounceRendering) {
    var valueRef = _(Unset$1);
    var reasonRef = _(Unset$1);
    var warningRef = _(false);
    var dependencyToCompareAgainst = _(Unset$1);
    var cleanupCallbackRef = _(undefined);
    // Make sure that the provided functions are perfectly stable across renders
    useEnsureStability("usePassiveState", onChange, getInitialValue, customDebounceRendering);
    // Shared between "dependency changed" and "component unmounted".
    var onShouldCleanUp = T$1(() => {
      var cleanupCallback = cleanupCallbackRef.current;
      if (cleanupCallback) cleanupCallback();
    }, []);
    // There are a couple places where we'd like to use our initial
    // value in place of having no value at all yet.
    // This is the shared code for that, used on mount and whenever
    // getValue is called.
    var tryEnsureValue = T$1(() => {
      if (valueRef.current === Unset$1 && getInitialValue != undefined) {
        try {
          var _onChange;
          var initialValue = getInitialValue();
          valueRef.current = initialValue;
          cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
        } catch (ex) {
          // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
        }
      }
    }, [/* getInitialValue and onChange intentionally omitted */]);
    var getValue = T$1(() => {
      if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
      // The first time we call getValue, if we haven't been given a value yet,
      // (and we were given an initial value to use)
      // return the initial value instead of nothing.
      if (valueRef.current === Unset$1) tryEnsureValue();
      return valueRef.current === Unset$1 ? undefined : valueRef.current;
    }, []);
    s(() => {
      // Make sure we've run our effect at least once on mount.
      // (If we have an initial value, of course)
      tryEnsureValue();
    }, []);
    // The actual code the user calls to (possibly) run a new effect.
    var setValue = T$1((arg, reason) => {
      // Regardless of anything else, figure out what our next value is about to be.
      var nextValue = arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg;
      if (dependencyToCompareAgainst.current === Unset$1 && nextValue !== valueRef.current) {
        // This is the first request to change this value.
        // Evaluate the request immediately, then queue up the onChange function
        // Save our current value so that we can compare against it later
        // (if we flip back to this state, then we won't send the onChange function)
        dependencyToCompareAgainst.current = valueRef.current;
        // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
        valueRef.current = nextValue;
        reasonRef.current = reason;
        // Schedule the actual check and invocation of onChange later to let effects settle
        (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering)(() => {
          var nextReason = reasonRef.current;
          var nextDep = valueRef.current;
          var prevDep = dependencyToCompareAgainst.current;
          if (dependencyToCompareAgainst.current != valueRef.current) {
            warningRef.current = true;
            try {
              var _onChange2;
              // Call any registered cleanup function
              onShouldCleanUp();
              cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$1 ? undefined : prevDep, nextReason)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
              valueRef.current = nextDep;
            } finally {
              // Allow the user to normally call getValue again
              warningRef.current = false;
            }
          }
          // We've finished with everything, so mark us as being on a clean slate again.
          dependencyToCompareAgainst.current = Unset$1;
        });
      }
      // Update the value immediately.
      // This will be checked against prevDep to see if we should actually call onChange
      valueRef.current = nextValue;
    }, []);
    return [getValue, setValue];
  }
  var Unset$1 = Symbol();
  // Easy constants for getInitialValue
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function returnNull() {
    return null;
  }
  function returnZero() {
    return 0;
  }
  function identity$1(t) {
    return t;
  } // Kind of an extra, but it's useful in other places anyway
  /**
   * An alternative to use for `customDebounceRendering` that causes `usePassiveState` to run changes without waiting a tick.
   */
  function runImmediately(f) {
    f();
  }

  /*
  const activeElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node | null) => void)>>();
  const lastActiveElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node) => void)>>();
  const windowFocusedUpdaters = new Map<Window | null | undefined, Set<undefined | ((focused: boolean) => void)>>();
  const windowsFocusedUpdaters = new Map<Window | null | undefined, boolean>();*/
  var activeElementUpdaters = new Map();
  var lastActiveElementUpdaters = new Map();
  var windowFocusedUpdaters = new Map();
  var windowsFocusedUpdaters = new Map();
  //const microtasks = new Map<Set<any>, any>();
  // The focusin and focusout events often fire syncronously in the middle of running code.
  // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
  // For the purpose of improving stability, we debounce all focus events to the next microtask.
  function forEachUpdater(window, map, value, reason) {
    var updaters = map.get(window);
    if (updaters) {
      //if (!microtasks.has(updatersKey)) {
      //debounceRendering(() => {
      //const updatersKey = map.get(window)!;
      //const value = microtasks.get(updatersKey);
      //microtasks.delete(updatersKey);
      if (updaters) {
        for (var updater of updaters) {
          var {
            lastSent,
            send
          } = updater;
          if (value !== lastSent) {
            send(value, reason);
            updater.lastSent = value;
          }
        }
      }
      //});
      //}
      //microtasks.set(updatersKey, value);
    }
  }

  function focusout(e) {
    var window = e.target.ownerDocument.defaultView;
    if (e.relatedTarget == null) {
      forEachUpdater(window, activeElementUpdaters, null, e);
    }
  }
  function focusin(e) {
    var window = e.target.ownerDocument.defaultView;
    var currentlyFocusedElement = e.target;
    forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement, e);
    forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement, e);
  }
  function windowFocus(e) {
    var window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
    windowsFocusedUpdaters.set(window, true);
    forEachUpdater(window, windowFocusedUpdaters, true, e);
  }
  function windowBlur(e) {
    var window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
    windowsFocusedUpdaters.set(window, false);
    forEachUpdater(window, windowFocusedUpdaters, false, e);
  }
  /**
   * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
   * * `getActiveElement()`
   * * `getLastActiveElement()`
   * * `getWindowFocused()`
   *
   * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
   *
   * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
   *
   * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
   */
  function useActiveElement(_ref4) {
    var {
      activeElementParameters: {
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        getDocument,
        getWindow
      }
    } = _ref4;
    useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, getDocument, getWindow);
    h(() => {
      var _getWindow, _activeElementUpdater, _activeElementUpdater2, _activeElementUpdater3, _lastActiveElementUpd, _windowFocusedUpdater;
      var document = getDocument();
      var window = (_getWindow = getWindow === null || getWindow === void 0 ? void 0 : getWindow(document)) !== null && _getWindow !== void 0 ? _getWindow : document === null || document === void 0 ? void 0 : document.defaultView;
      if (((_activeElementUpdater = (_activeElementUpdater2 = activeElementUpdaters.get(window)) === null || _activeElementUpdater2 === void 0 ? void 0 : _activeElementUpdater2.size) !== null && _activeElementUpdater !== void 0 ? _activeElementUpdater : 0) === 0) {
        document === null || document === void 0 ? void 0 : document.addEventListener("focusin", focusin, {
          passive: true
        });
        document === null || document === void 0 ? void 0 : document.addEventListener("focusout", focusout, {
          passive: true
        });
        window === null || window === void 0 ? void 0 : window.addEventListener("focus", windowFocus, {
          passive: true
        });
        window === null || window === void 0 ? void 0 : window.addEventListener("blur", windowBlur, {
          passive: true
        });
      }
      // Add them even if they're undefined to more easily
      // manage the ">0 means don't add handlers" logic.
      var localActiveElementUpdaters = (_activeElementUpdater3 = activeElementUpdaters.get(window)) !== null && _activeElementUpdater3 !== void 0 ? _activeElementUpdater3 : new Set();
      var localLastActiveElementUpdaters = (_lastActiveElementUpd = lastActiveElementUpdaters.get(window)) !== null && _lastActiveElementUpd !== void 0 ? _lastActiveElementUpd : new Set();
      var localWindowFocusedUpdaters = (_windowFocusedUpdater = windowFocusedUpdaters.get(window)) !== null && _windowFocusedUpdater !== void 0 ? _windowFocusedUpdater : new Set();
      var laeu = {
        send: setActiveElement,
        lastSent: undefined
      };
      var llaeu = {
        send: setLastActiveElement,
        lastSent: undefined
      };
      var lwfu = {
        send: setWindowFocused,
        lastSent: undefined
      };
      localActiveElementUpdaters.add(laeu);
      localLastActiveElementUpdaters.add(llaeu);
      localWindowFocusedUpdaters.add(lwfu);
      activeElementUpdaters.set(window, localActiveElementUpdaters);
      lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
      windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
      return () => {
        activeElementUpdaters.get(window).delete(laeu);
        lastActiveElementUpdaters.get(window).delete(laeu);
        windowFocusedUpdaters.get(window).delete(lwfu);
        if (activeElementUpdaters.size === 0) {
          document === null || document === void 0 ? void 0 : document.removeEventListener("focusin", focusin);
          document === null || document === void 0 ? void 0 : document.removeEventListener("focusout", focusout);
          window === null || window === void 0 ? void 0 : window.removeEventListener("focus", windowFocus);
          window === null || window === void 0 ? void 0 : window.removeEventListener("blur", windowBlur);
        }
      };
    }, []);
    var [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
    var [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
    var [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
    return {
      activeElementReturn: {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      }
    };
  }
  var Table$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
  function base64(value) {
    return Table$1[value];
  }
  function random6Bits() {
    return Math.floor(Math.random() * 0b1000000);
  }
  function random64Bits() {
    return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
  }
  /**
   * Returns a randomly-generated ID with an optional prefix.
   * Note that if the prefix is *explicitly* set to "", then
   * IDs that are not valid under HTML4 may be generated. Oh no.
   *
   *
   * (This is here, in this particular file, to avoid circular dependencies
   * without also making a utilities file.
   * Once we can remove this hook, we can put this function back with useRandomId)
   */
  function generateRandomId(prefix) {
    return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits().map(n => base64(n)).join(""));
  }
  var previousInputs = new Map();
  var toRun = new Map();
  // TODO: Whether this goes in options.diffed or options._commit
  // is a post-suspense question.
  // Right now, using options._commit has the problem of running
  // *after* refs are applied, but we need to come before even that
  // so `ref={someStableFunction}` works.
  // 
  // Also it's private.
  //
  // ...
  // Well, useEvent or whatever is finally, finally 4 years later finally here
  // which is cool and means we won't need this at all soon.
  // So for now we'll stick with diff to prevent any weirdness with
  // commit being private and all.
  var commitName = "diffed";
  var originalCommit = l$1[commitName];
  var newCommit = function () {
    for (var [id, effectInfo] of toRun) {
      var oldInputs = previousInputs.get(id);
      if (argsChanged(oldInputs, effectInfo.inputs)) {
        var _effectInfo$cleanup;
        (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
        effectInfo.cleanup = effectInfo.effect();
        previousInputs.set(id, effectInfo.inputs);
      }
    }
    toRun.clear();
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
  };
  l$1[commitName] = newCommit;
  /**
   * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
   *
   * Every render, we send the arguments to be evaluated after diffing has completed,
   * which happens before.
   *
   * @param effect
   * @param inputs
   */
  function useBeforeLayoutEffect(effect, inputs) {
    /*(() => {
        const cleanup = useRef<void | (() => void) | null>(null);
        const prevArgsRef = useRef<Inputs>(null!);
        if (argsChanged(inputs, prevArgsRef.current)) {
            prevArgsRef.current = inputs!;
            if (cleanup.current)
                cleanup.current();
            cleanup.current = effect();
        }
    })();*/
    var [id] = p(() => generateRandomId());
    if (effect) toRun.set(id, {
      effect,
      inputs,
      cleanup: null
    });else toRun.delete(id);
    h(() => {
      return () => {
        toRun.delete(id);
        previousInputs.delete(id);
      };
    }, [id]);
  }
  function argsChanged(oldArgs, newArgs) {
    return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
  }
  var Unset = Symbol("unset");
  /**
   * Given an input value, returns a constant getter function that can be used
   * inside of `useEffect` and friends without including it in the dependency array.
   *
   * This uses `options.diffed` in order to run before everything, even
   * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
   *
   * @param value
   * @returns
   */
  function useStableGetter(value) {
    var ref = _(Unset);
    useBeforeLayoutEffect(() => {
      ref.current = value;
    }, [value]);
    return T$1(() => {
      if (ref.current === Unset) {
        throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
      }
      return ref.current;
    }, []);
  }
  /**
   * Like `useStableGetter`, but ***requires*** that everything in the object is also stable,
   * and in turn returns an object that itself is stable.
   * @param t
   * @returns
   */
  function useStableObject(t) {
    var e = Object.entries(t);
    useEnsureStability("useStableObject", e.length, ...e.map(_ref5 => {
      var [_k, v] = _ref5;
      return v;
    }));
    return _(t).current;
  }

  /**
   * We keep track of which callbacks are stable with a WeakMap instead of, say, a symbol because
   * `useCallback` will return a function that's stable across *all* renders, meaning
   * we can't use our funny "`if` only works here because it doesn't break the rules of hooks" trick then.
   */
  var map = new WeakMap();
  function isStableGetter(obj) {
    var _map$get;
    return (_map$get = map.get(obj)) !== null && _map$get !== void 0 ? _map$get : false;
  }
  function setIsStableGetter(obj) {
    map.set(obj, true);
    return obj;
  }
  /**
   * Alternate useCallback() which always returns the same (wrapped) function reference
   * so that it can be excluded from the dependency arrays of `useEffect` and friends.
   *
   * In general, just pass the function you want to be stable (but you can't use it during render,
   * so be careful!).  Alternatively, if you need a stable callback that **can** be used
   * during render, pass an empty dependency array and it'll act like `useCallback` with an
   * empty dependency array, but with the associated stable typing. In this case, you ***must*** ensure that it
   * truly has no dependencies/only stable dependencies!!
   */
  //export function useStableCallback<T extends (..._args: any[]) => any>(fn: T, noDeps: []): Stable<T>;
  //export function useStableCallback<T extends (..._args: any[]) => any>(fn: T): Stable<T>;
  function useStableCallback(fn, noDeps) {
    useEnsureStability("useStableCallback", noDeps == null, noDeps === null || noDeps === void 0 ? void 0 : noDeps.length, isStableGetter(fn));
    if (isStableGetter(fn)) return fn;
    if (noDeps == null) {
      var currentCallbackGetter = useStableGetter(fn);
      return setIsStableGetter(T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []));
    } else {
      console.assert(noDeps.length === 0);
      return setIsStableGetter(T$1(fn, []));
    }
  }

  /**
   * Allows a parent component to access information about certain
   * child components once they have rendered.
   *
   * This hook is designed to be lightweight, in that the parent keeps no state
   * and runs no effects.  Each child *does* run an effect, but with no state
   * changes unless you explicitly request them.
   *
   *
   */
  function useManagedChildren(parentParameters) {
    var {
        managedChildrenParameters: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters,
      rest = _objectWithoutProperties(parentParameters, _excluded2);
    useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
    var getHighestIndex = T$1(() => {
      return managedChildrenArray.current.highestIndex;
    }, []);
    // All the information we have about our children is stored in this **stable** array.
    // Any mutations to this array **DO NOT** trigger any sort of a re-render.
    var managedChildrenArray = _({
      arr: [],
      rec: {},
      highestIndex: 0,
      lowestIndex: 0
    });
    // For indirect access to each child
    // Compare getManagedChildInfo
    // TODO: The primary use for this is flaggable closest fits
    // which needs to search all children for that closest fit.
    // It would be nice if there was something better for that.
    var forEachChild = T$1(f => {
      for (var child of managedChildrenArray.current.arr) {
        if (child) f(child);
      }
      for (var field in managedChildrenArray.current.rec) {
        var _child = managedChildrenArray.current.rec[field];
        if (_child) f(_child);
      }
    }, []);
    // Retrieves the information associated with the child with the given index.
    // `undefined` if not child there, or it's unmounted.
    var getManagedChildInfo = T$1(index => {
      if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
    }, []);
    // tl;dr this is a way to have run useLayoutEffect once after all N children
    // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
    // ourselves because of having a `childCount` state or anything similar.
    //
    // When the child count ref updates, we want the parent to also run an effect
    // to maybe do something with all these children that just mounted.
    // The easiest way would be useEffect(..., [childCount]) but
    // that would require us having a childCount state, then calling
    // setChildCount and re-rendering every time children mount
    // (only one re-render at a time unless children are staggered, but still)
    // 
    // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
    // to emulate running ULE on the parent. Only the first child will actually queue
    // the microtask (by checking hasRemoteULE first) so that the "effect" only
    // runs once. When it's done, hasRemoteULE is reset so it can run again if
    // more children mount/unmount.
    var hasRemoteULEChildMounted = _(null);
    var remoteULEChildChangedCausers = _(new Set());
    var remoteULEChildChanged = T$1(index => {
      if (remoteULEChildChangedCausers.current.size == 0) {
        debounceRendering(() => {
          onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
          remoteULEChildChangedCausers.current.clear();
        });
      }
      remoteULEChildChangedCausers.current.add(index);
      return () => {};
    }, [/* Must remain stable */]);
    var remoteULEChildMounted = T$1((index, mounted) => {
      if (!hasRemoteULEChildMounted.current) {
        hasRemoteULEChildMounted.current = {
          mounts: new Set(),
          unmounts: new Set()
        };
        debounceRendering(() => {
          onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
          hasRemoteULEChildMounted.current = null;
        });
      }
      if (mounted) {
        if (typeof index == "number") managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
      } else {
        if (typeof index == "number") {
          delete managedChildrenArray.current.arr[index];
          var shave = 0;
          while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
            ++shave;
          }
          managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
        } else delete managedChildrenArray.current.rec[index];
        if (typeof index == "number") managedChildrenArray.current.highestIndex = managedChildrenArray.current.arr.length - 1;
      }
      hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
    }, [/* Must remain stable */]);
    var managedChildren = useStableObject(_objectSpread(_objectSpread({}, {
      _: managedChildrenArray.current
    }), {}, {
      forEach: forEachChild,
      getAt: getManagedChildInfo,
      getHighestIndex: getHighestIndex,
      arraySlice: T$1(() => {
        return managedChildrenArray.current.arr.slice();
      }, [])
    }));
    var getChildren = T$1(() => managedChildren, []);
    return {
      context: useStableObject({
        managedChildContext: useStableObject({
          managedChildrenArray: managedChildrenArray.current,
          remoteULEChildMounted,
          remoteULEChildChanged,
          getChildren
        })
      }),
      managedChildrenReturn: {
        getChildren
      }
    };
  }
  function useManagedChild(info, managedChildParameters) {
    var {
      context: {
        managedChildContext: {
          getChildren,
          managedChildrenArray,
          remoteULEChildMounted,
          remoteULEChildChanged
        }
      }
    } = info;
    var index = managedChildParameters.index;
    // Any time our child props change, make that information available
    // the parent if they need it.
    // The parent can listen for all updates and only act on the ones it cares about,
    // and multiple children updating in the same tick will all be sent at once.
    s(() => {
      // Insert this information in-place
      if (typeof index == "number") {
        managedChildrenArray.arr[index] = _objectSpread({}, managedChildParameters);
      } else {
        managedChildrenArray.rec[index] = _objectSpread({}, managedChildParameters);
      }
      return remoteULEChildChanged(index);
    }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
    // When we mount, notify the parent via queueMicrotask
    // (every child does this, so everything's coordinated to only queue a single microtask per tick)
    // Do the same on unmount.
    // Note: It's important that this comes AFTER remoteULEChildChanged
    // so that remoteULEChildMounted has access to all the info on mount.
    s(() => {
      remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, true);
      return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, false);
    }, [index]);
    return {
      managedChildReturn: {
        getChildren
      }
    };
  }
  /**
   * An extension to useManagedChildren that handles the following common case:
   * 1. You have a bunch of children
   * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
   * 3. The parent has control over who is "selected" via a numerical index.
   *
   * This hook allows for much easier control over selection management.
   *
   * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
   * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
   *
   * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
   *
   *
   * @param param0
   * @returns
   */
  function useChildrenFlag(_ref6) {
    var {
      getChildren,
      initialIndex,
      closestFit,
      onIndexChange,
      getAt,
      setAt,
      isValid
    } = _ref6;
    useEnsureStability("useChildrenFlag", onIndexChange, getAt, setAt, isValid);
    // TODO (maybe?): Even if there is an initial index, it's not set until mount. Is that fine?
    var [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange);
    var [getRequestedIndex, setRequestedIndex] = usePassiveState(null);
    //    const getFitNullToZero = useStableGetter(fitNullToZero);
    // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)
    var getClosestFit = T$1(requestedIndex => {
      var children = getChildren();
      var closestDistance = Infinity;
      var closestIndex = null;
      children.forEach(child => {
        if (isValid(child)) {
          var newDistance = Math.abs(child.index - requestedIndex);
          if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
            closestDistance = newDistance;
            closestIndex = child.index;
          }
        }
      });
      return closestIndex;
    }, [/* Must remain stable! */]);
    // Any time a child mounts/unmounts, we need to double-check to see if that affects 
    // the "currently selected" (or whatever) index.  The two cases we're looking for:
    // 1. The currently selected child unmounted
    // 2. A child mounted, and it mounts with the index we're looking for
    var reevaluateClosestFit = useStableCallback(() => {
      var children = getChildren();
      var requestedIndex = getRequestedIndex();
      var currentIndex = getCurrentIndex();
      var currentChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !isValid(currentChild))) {
        if (currentChild) setAt(currentChild, false);
        var closestFitIndex = getClosestFit(requestedIndex);
        setCurrentIndex(closestFitIndex, undefined);
        if (closestFitIndex != null) {
          var closestFitChild = children.getAt(closestFitIndex);
          console.assert(closestFitChild != null, "Internal logic???");
          setAt(closestFitChild, true);
        }
      }
    });
    var changeIndex = T$1((arg, reason) => {
      var children = getChildren();
      var requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
      //if (requestedIndex == null && getFitNullToZero())
      //    requestedIndex = 0;
      setRequestedIndex(requestedIndex, reason);
      var currentIndex = getCurrentIndex();
      if (currentIndex == requestedIndex) return requestedIndex;
      var newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
      var oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex == null) {
        // Easy case
        setCurrentIndex(null, reason);
        if (oldMatchingChild) setAt(oldMatchingChild, false);
        return null;
      } else {
        if (newMatchingChild && isValid(newMatchingChild)) {
          setCurrentIndex(requestedIndex, reason);
          if (oldMatchingChild) setAt(oldMatchingChild, false);
          setAt(newMatchingChild, true);
          return requestedIndex;
        } else {
          var closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex, reason);
          if (closestFitIndex != null) {
            newMatchingChild = children.getAt(closestFitIndex);
            console.assert(newMatchingChild != null, "Internal logic???");
            if (oldMatchingChild) setAt(oldMatchingChild, false);
            setAt(newMatchingChild, true);
            return closestFitIndex;
          } else {
            if (oldMatchingChild) setAt(oldMatchingChild, false);
            return null;
          }
        }
      }
    }, []);
    // Run once, on mount
    s(() => {
      changeIndex(initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, undefined);
    }, []);
    return {
      changeIndex,
      reevaluateClosestFit,
      getCurrentIndex
    };
  }
  function useMergedChildren(lhs, rhs) {
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return h$1(p$1, {}, lhs, rhs);
    }
  }
  function r(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) {
      e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for (t in e) {
      e[t] && (n && (n += " "), n += t);
    }
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = ""; f < arguments.length;) {
      (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
    }
    return n;
  }

  /**
   * Given two sets of props, merges their `class` and `className` properties.
   * Duplicate classes are removed (order doesn't matter anyway).
   *
   * @param lhs Classes of the first component
   * @param rhs Classes of the second component
   * @returns A string representing all combined classes from both arguments.
   */
  function useMergedClasses(lhsClass, lhsClassName, rhsClass, rhsClassName) {
    // Note: For the sake of forward compatibility, this function is labelled as
    // a hook, but as it uses no other hooks it technically isn't one.
    if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
      var lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
      var rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
      var allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
      return Array.from(allClasses).join(" ");
    } else {
      return undefined;
    }
  }
  function processRef(instance, ref) {
    if (typeof ref === "function") {
      ref(instance);
    } else if (ref != null) {
      ref.current = instance;
    } else {
      /* eslint-disable no-debugger */
      debugger;
      console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
    }
  }
  /**
   * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
   * @param lhs
   * @param rhs
   * @returns
   */
  function useMergedRefs(rhs, lhs) {
    var combined = T$1(current => {
      processRef(current, lhs);
      processRef(current, rhs);
    }, [lhs, rhs]);
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return combined;
    }
  }
  function styleStringToObject(style) {
    // TODO: This sucks D:
    return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
  }
  /**
   * Merges two style objects, returning the result.
   *
   * @param style The user-given style prop for this component
   * @param obj The CSS properties you want added to the user-given style
   * @returns A CSS object containing the properties of both objects.
   */
  function useMergedStyles(lhs, rhs) {
    // Easy case, when there are no styles to merge return nothing.
    if (!lhs && !rhs) return undefined;
    if (typeof lhs != typeof rhs) {
      // Easy cases, when one is null and the other isn't.
      if (lhs && !rhs) return lhs;
      if (!lhs && rhs) return rhs;
      // They're both non-null but different types.
      // Convert the string type to an object bag type and run it again.
      if (lhs && rhs) {
        // (useMergedStyles isn't a true hook -- this isn't a violation)
        if (typeof lhs == "string") return useMergedStyles(styleStringToObject(lhs), rhs);
        if (typeof rhs == "string") return useMergedStyles(lhs, styleStringToObject(rhs));
      }
      // Logic???
      return undefined;
    }
    // They're both strings, just concatenate them.
    if (typeof lhs == "string") {
      return "".concat(lhs, ";").concat(rhs !== null && rhs !== void 0 ? rhs : "");
    }
    // They're both objects, just merge them.
    return _objectSpread(_objectSpread({}, lhs !== null && lhs !== void 0 ? lhs : {}), rhs !== null && rhs !== void 0 ? rhs : {});
  }
  var log = console.warn;
  /**
   * Given two sets of props, merges them and returns the result.
   *
   * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
   * @param lhs2
   * @param rhs2
   * @returns
   */
  function useMergedProps() {
    for (var _len4 = arguments.length, allProps = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      allProps[_key4] = arguments[_key4];
    }
    useEnsureStability("useMergedProps", allProps.length);
    var ret = {};
    for (var nextProps of allProps) {
      ret = useMergedProps2(ret, nextProps);
    }
    return ret;
  }
  var knowns = new Set(["children", "ref", "className", "class", "style"]);
  function mergeUnknown(key, lhsValue, rhsValue) {
    if (typeof lhsValue === "function" || typeof rhsValue === "function") {
      // They're both functions that can be merged (or one's a function and the other's null).
      // Not an *easy* case, but a well-defined one.
      var merged = mergeFunctions(lhsValue, rhsValue);
      return merged;
    } else {
      // Uh...we're here because one of them's null, right?
      if (lhsValue == null && rhsValue == null) {
        if (rhsValue === null && lhsValue === undefined) return rhsValue;else return lhsValue;
      }
      if (lhsValue == null) return rhsValue;else if (rhsValue == null) return lhsValue;else if (rhsValue == lhsValue) ;else {
        // Ugh.
        // No good strategies here, just log it if requested
        log === null || log === void 0 ? void 0 : log("The prop \"".concat(key, "\" cannot simultaneously be the values ").concat(lhsValue, " and ").concat(rhsValue, ". One must be chosen outside of useMergedProps."));
        return rhsValue;
      }
    }
  }
  /**
   * Helper function.
   *
   * This is one of the most commonly called functions in this and consumer libraries,
   * so it trades a bit of readability for speed (i.e. we don't decompose objects and just do regular property access, iterate with `for...in`, instead of `Object.entries`, etc.)
   */
  function useMergedProps2(lhsAll, rhsAll) {
    var ret = {
      ref: useMergedRefs(lhsAll.ref, rhsAll.ref),
      style: useMergedStyles(lhsAll.style, rhsAll.style),
      className: useMergedClasses(lhsAll["class"], lhsAll.className, rhsAll["class"], rhsAll.className),
      children: useMergedChildren(lhsAll.children, rhsAll.children)
    };
    if (ret.ref === undefined) delete ret.ref;
    if (ret.style === undefined) delete ret.style;
    if (ret.className === undefined) delete ret.className;
    if (ret["class"] === undefined) delete ret["class"];
    if (ret.children === undefined) delete ret.children;
    for (var lhsKeyU in lhsAll) {
      var lhsKey = lhsKeyU;
      if (knowns.has(lhsKey)) continue;
      ret[lhsKey] = lhsAll[lhsKey];
    }
    for (var rhsKeyU in rhsAll) {
      var rhsKey = rhsKeyU;
      if (knowns.has(rhsKey)) continue;
      ret[rhsKey] = mergeUnknown(rhsKey, ret[rhsKey], rhsAll[rhsKey]);
    }
    return ret;
  }
  function mergeFunctions(lhs, rhs) {
    if (!lhs) return rhs;
    if (!rhs) return lhs;
    return function () {
      var lv = lhs(...arguments);
      var rv = rhs(...arguments);
      if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
    };
  }
  /*
  function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {
       const id0: GenericGet<{}, "id", string> = "";
      const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
      const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
      const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
      const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
      //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
      const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };
       type M1 = GenericGet<P, "style", string>;
      type M2 = GenericGet<{}, "style", string>;
      const m1: M1 = "";
      const m2: M1 = undefined;
      /// @ts-expect-error    Because number isn't assignable to string
      const m3: M1 = 0;
       const m4: M2 = "";
      const m5: M2 = undefined;
      /// @ts-expect-error    Because number isn't assignable to string
      const m6: M2 = 0;
       const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
      const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
      const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
      const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
      const p5 = useMergedProps<HTMLInputElement>()(props, {});
      const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
      const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });
        p1.id?.concat("");
      p2.id?.concat("");
      /// @ts-expect-error    id can't be anything but undefined
      p3.id?.concat("");
      /// @ts-expect-error    id can't be anything but undefined
      p4.id?.concat("");
        p5.id?.concat("");
      p6.id?.concat("");
      p7.id?.concat("");
       /// @ts-expect-error    id must contain undefined
      p5.id.concat("");
      /// @ts-expect-error    id must contain undefined
      p6.id.concat("");
      /// @ts-expect-error    id must contain undefined
      p7.id.concat("");
        if (p5.allowFullScreen === undefined) {}
      else if (p5.allowFullScreen === false) {}
      else if (p5.allowFullScreen === true) {}
      else {
          acceptsNever(p5.allowFullScreen);
      }
        if (p6.allowFullScreen === undefined) {}
      else if (p6.allowFullScreen === false) {}
      else if (p6.allowFullScreen === true) {}
      else {
          acceptsNever(p6.allowFullScreen);
      }
        if (p7.allowFullScreen === undefined) {}
      else if (p7.allowFullScreen === false) {}
      else if (p7.allowFullScreen === true) {}
      else {
          acceptsNever(p7.allowFullScreen);
      }
        // Make sure it works recursively
      const r1a = useMergedProps<HTMLInputElement>()({}, p1);
      const r1b = useMergedProps<HTMLInputElement>()(props, p1);
      const r2a = useMergedProps<HTMLInputElement>()({}, p2);
      const r2b = useMergedProps<HTMLInputElement>()(props, p2);
      const r3a = useMergedProps<HTMLInputElement>()({}, p3);
      const r3b = useMergedProps<HTMLInputElement>()(props, p3);
      const r4a = useMergedProps<HTMLInputElement>()({}, p4);
      const r4b = useMergedProps<HTMLInputElement>()(props, p4);
      const r5a = useMergedProps<HTMLInputElement>()({}, p5);
      const r5b = useMergedProps<HTMLInputElement>()(props, p5);
      const r6a = useMergedProps<HTMLInputElement>()({}, p6);
      const r6b = useMergedProps<HTMLInputElement>()(props, p6);
      const r7a = useMergedProps<HTMLInputElement>()({}, p7);
      const r7b = useMergedProps<HTMLInputElement>()(props, p7);
        r1a.id?.concat("");
      r1b.id?.concat("");
      r2a.id?.concat("");
      r2b.id?.concat("");
      // @ts-expect-error    id can't be anything but undefined
      r3a.id?.concat("");
      r3b.id?.concat("");
      /// @ts-expect-error    id can't be anything but undefined
      r4a.id?.concat("");
      r4b.id?.concat("");
        r5a.id?.concat("");
      r5b.id?.concat("");
      r6a.id?.concat("");
      r6b.id?.concat("");
      r7a.id?.concat("");
      r7b.id?.concat("");
       /// @ts-expect-error    id must contain undefined
      r5a.id.concat("");
      /// @ts-expect-error    id must contain undefined
      r5b.id.concat("");
      /// @ts-expect-error    id must contain undefined
      r6a.id.concat("");
      /// @ts-expect-error    id must contain undefined
      r6b.id.concat("");
      /// @ts-expect-error    id must contain undefined
      r7a.id.concat("");
      /// @ts-expect-error    id must contain undefined
      r7b.id.concat("");
        if (r5a.allowFullScreen === undefined) {}
      else if (r5a.allowFullScreen === false) {}
      else if (r5a.allowFullScreen === true) {}
      else {
          acceptsNever(r5a.allowFullScreen);
      }
        if (r5b.allowFullScreen === undefined) {}
      else if (r5b.allowFullScreen === false) {}
      else if (r5b.allowFullScreen === true) {}
      else {
          acceptsNever(r5b.allowFullScreen);
      }
        if (r6a.allowFullScreen === undefined) {}
      else if (r6a.allowFullScreen === false) {}
      else if (r6a.allowFullScreen === true) {}
      else {
          acceptsNever(r6a.allowFullScreen);
      }
        if (r6b.allowFullScreen === undefined) {}
      else if (r6b.allowFullScreen === false) {}
      else if (r6b.allowFullScreen === true) {}
      else {
          acceptsNever(r6b.allowFullScreen);
      }
        if (r7a.allowFullScreen === undefined) {}
      else if (r7a.allowFullScreen === false) {}
      else if (r7a.allowFullScreen === true) {}
      else {
          acceptsNever(r7a.allowFullScreen);
      }
        if (r7b.allowFullScreen === undefined) {}
      else if (r7b.allowFullScreen === false) {}
      else if (r7b.allowFullScreen === true) {}
      else {
          acceptsNever(r7b.allowFullScreen);
      }
   }
  function acceptsNever(n: never) {}
  */

  /**
   * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
   *
   * Due to typing limitations, this function must be called like this:
   *
   * `useEventHandler(element, "input")<InputEvent>(e => {})`
   *
   * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
   *
   * There is a separate version that attaches event handlers to a set of props.
   * It takes different event string types (onEvent vs onevent).
   *
   * @param target A *non-Preact* node to attach the event to.
   * @returns
   * *
   */
  function useGlobalHandler(target, type, handler, options) {
    // Note to self: The typing doesn't improve even if this is split up into a sub-function.
    // No matter what, it seems impossible to get the handler's event object typed perfectly.
    // It seems like it's guaranteed to always be a union of all available tupes.
    // Again, no matter what combination of sub- or sub-sub-functions used.
    var stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
    if (handler == null) stableHandler = null;
    h(() => {
      if (stableHandler) {
        target.addEventListener(type, stableHandler, options);
        return () => target.removeEventListener(type, stableHandler, options);
      }
    }, [target, type, stableHandler]);
  }

  /*
  export function useRefElementProps<E extends Element>(r: UseRefElementReturnType<E>, ...otherProps: h.JSX.HTMLAttributes<E>[]): h.JSX.HTMLAttributes<E>[] {
      return [r.refElementReturn.propsStable, ...otherProps];
  }*/
  /**
   * Allows accessing the element a ref references as soon as it does so.
   * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
   * adding a RefCallback and merging it with any existing ref that existed on the props.
   *
   * Don't forget to provide the Element as the type argument!
   *
   * @returns The element, and the sub-hook that makes it retrievable.
   */
  function useRefElement(args) {
    var {
      refElementParameters: {
        onElementChange,
        onMount,
        onUnmount
      }
    } = args;
    useEnsureStability("useRefElement", onElementChange, onMount, onUnmount);
    // Called (indirectly) by the ref that the element receives.
    var handler = T$1((e, prevValue) => {
      var cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
      if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
      if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
      return cleanup;
    }, []);
    // Let us store the actual (reference to) the element we capture
    var [getElement, setElement] = usePassiveState(handler, returnNull, runImmediately);
    var propsStable = _({
      ref: setElement
    });
    // Return both the element and the hook that modifies 
    // the props and allows us to actually find the element
    return {
      refElementReturn: {
        getElement,
        propsStable: propsStable.current
      }
    };
  }
  var MagicWindowKey = "__preact-prop-helpers-escape-key-dismiss__";
  function getElementDepth(element) {
    var depth = 0;
    var parent = element.parentElement;
    while (parent) {
      depth += 1;
      parent = parent.parentElement;
    }
    return depth;
  }
  /**
   * Adds event handlers for a modal-like soft-dismiss interaction.
   *
   * That is, any clicks or taps outside of the given component,
   * or any time the Escape key is pressed within the component,
   * (with various browser oddities regarding clicks on blank or inert areas handled)
   * the component will request to close itself.
   *
   * Of course, if you don't do anything in the `onClose` function,
   * it won't be a soft dismiss anymore.
   *
   * Handles events for pressing the `Escape` key to close the any currently open dialogs, tooltips, menus, popups, etc.
   *
   * One press of the `Escape` key is guaranteed to only call `onClose` for *only one* component, and it is called on the component deepest in the DOM tree, differentiated by passing context information between parent and child.
   *
   * @param param0
   * @returns
   */
  function useEscapeDismiss(_ref7) {
    var {
        escapeDismissParameters: {
          onClose,
          open,
          getWindow: unstableGetWindow,
          parentDepth
        },
        refElementPopupReturn: {
          getElement
        }
      } = _ref7,
      void1 = _objectWithoutProperties(_ref7.escapeDismissParameters, _excluded3),
      void2 = _objectWithoutProperties(_ref7.refElementPopupReturn, _excluded4);
    var stableOnClose = useStableCallback(onClose);
    var getWindow = useStableCallback(unstableGetWindow);
    var getDepth = useStableGetter(parentDepth + 1);
    // When this component opens, add an event listener that finds the deepest open soft dismiss element to actually dismiss.
    // Only opened components will add event handlers, and will remove them once closed.
    // The reason this is so complicated is because:
    // 1. We must only close one soft dismiss component at a time.  If there's a tooltip in a popup, the tooltip must be dismissed.
    // 2. `keydown` events don't just work on arbitrary elements, for our purposes they must be from the `window`. So we can't rely on normal capturing or bubbling behavior on the element itself.
    // 3. Event handlers added to the `window` via `addEventHandler` are called in the order of registration, which is completely at odds with #1.
    //
    // So all soft dismiss components listen for a keydown of Escape, 
    // then the first one to do so will wait for a microtask, 
    // then find the deepest element in the document tree to dismiss of all of those components currently open.
    h(() => {
      var _window$MagicWindowKe;
      var window = getWindow();
      (_window$MagicWindowKe = window[MagicWindowKey]) !== null && _window$MagicWindowKe !== void 0 ? _window$MagicWindowKe : window[MagicWindowKey] = {
        microtaskQueued: false,
        elementQueue: new Map()
      };
      var info = window[MagicWindowKey];
      if (open) {
        console.log("Adding handler for depth=".concat(getDepth()));
        window.addEventListener("keydown", handler, {
          capture: true
        });
        return () => {
          console.log("Removing handler for depth=".concat(getDepth()));
          var element = getElement();
          if (element && info.elementQueue) info.elementQueue.delete(element);
          window.removeEventListener("keydown", handler, {
            capture: true
          });
        };
      }
      function handler(e) {
        if (e.key == "Escape") {
          console.log("Escape key for depth=".concat(getDepth()));
          // We don't know which of the currently active soft dismisses will actually do something,
          // but ONE of them definitely will,
          // so we stop propagation to child nodes, but not to everyone on the window (stopImmediatePropagation).
          e.preventDefault();
          e.stopPropagation();
          // This is what at least one of the elements will call
          var onClose2 = () => {
            stableOnClose("escape");
          };
          var element = getElement();
          if (element) {
            var treeDepth = getElementDepth(element);
            var depth = getDepth();
            info.elementQueue.set(element, {
              depth,
              onClose: onClose2,
              treeDepth
            });
          }
          if (!info.microtaskQueued) {
            info.microtaskQueued = true;
            setTimeout(() => {
              var _deepestOnClose;
              var {
                elementQueue
              } = info;
              info.microtaskQueued = false;
              info.elementQueue = new Map();
              var deepestDepth = -Infinity;
              var deepestTreeDepth = -Infinity;
              var deepestOnClose = null;
              for (var [_element, {
                depth: _depth,
                onClose: _onClose,
                treeDepth: _treeDepth
              }] of elementQueue) {
                var tieBroken = false;
                if (_depth == deepestDepth) {
                  if (_treeDepth > deepestTreeDepth) {
                    tieBroken = true;
                  }
                }
                if (_depth > deepestDepth || _depth == deepestDepth && tieBroken) {
                  deepestDepth = _depth;
                  deepestTreeDepth = _treeDepth;
                  deepestOnClose = _onClose;
                }
              }
              (_deepestOnClose = deepestOnClose) === null || _deepestOnClose === void 0 ? void 0 : _deepestOnClose();
            }, 0);
          }
        }
      }
    }, [open]);
  }
  /**
   * Handles events for dismiss events for things like popup menus or transient dialogs -- things where moving focus to a new area of the page means this component should close itself.
   *
   * @param param0
   * @returns
   */
  function useLostFocusDismiss(_ref8) {
    var {
        refElementPopupReturn: {
          getElement: getPopupElement
        },
        refElementSourceReturn,
        lostFocusDismiss: {
          open,
          onClose
        }
      } = _ref8,
      void3 = _objectWithoutProperties(_ref8.refElementPopupReturn, _excluded5),
      void1 = _objectWithoutProperties(_ref8, _excluded6);
    var _ref9 = refElementSourceReturn !== null && refElementSourceReturn !== void 0 ? refElementSourceReturn : {},
      {
        getElement: getSourceElement
      } = _ref9,
      void2 = _objectWithoutProperties(_ref9, _excluded7);
    var stableOnClose = useStableCallback(onClose);
    var getOpen = useStableGetter(open);
    var onLastActiveElementChange = T$1((newElement, _prevElement, _e) => {
      var open = getOpen();
      var sourceElement = getSourceElement === null || getSourceElement === void 0 ? void 0 : getSourceElement();
      var popupElement = getPopupElement();
      if (!(sourceElement !== null && sourceElement !== void 0 && sourceElement.contains(newElement) || popupElement !== null && popupElement !== void 0 && popupElement.contains(newElement))) {
        if (open) stableOnClose();
      }
    }, [getSourceElement]);
    return {
      activeElementParameters: {
        onLastActiveElementChange
      }
    };
  }
  /**
   * Handles events for a backdrop on a modal dialog -- the kind where the user expects the modal to close when they click/tap outside of it.
   *
   * @param param0
   */
  function useBackdropDismiss(_ref10) {
    var {
        backdropDismissParameters: {
          open,
          onClose: onCloseUnstable
        },
        refElementPopupReturn: {
          getElement
        }
      } = _ref10,
      void1 = _objectWithoutProperties(_ref10.backdropDismissParameters, _excluded8),
      void3 = _objectWithoutProperties(_ref10.refElementPopupReturn, _excluded9),
      void2 = _objectWithoutProperties(_ref10, _excluded10);
    var getOpen = useStableGetter(open);
    var onClose = useStableCallback(onCloseUnstable);
    var onBackdropClick = T$1(function onBackdropClick(e) {
      if (!getOpen()) return;
      // Basically, "was this event fired on an element not contained by the modal?"
      // There are multiple ways browser react to "interacting with nothing", and this takes care of everything.
      var element = getElement();
      var foundInsideClick = false;
      if (e.target && element && element.contains(e.target)) {
        foundInsideClick = true;
      }
      if (!foundInsideClick) {
        onClose();
      }
    }, []);
    useGlobalHandler(window, "mousedown", open ? onBackdropClick : null, {
      capture: true
    });
    useGlobalHandler(window, "touchstart", open ? onBackdropClick : null, {
      capture: true
    });
  }
  /**
   * Combines all the methods of dismissing a modal-ish or popup-ish component into one combined hook.
   *
   * This is similar to the "complete" series of list/grid navigation, in that it's the "outermost" hook of its type.
   */
  function useDismiss(_ref11) {
    var {
      dismissParameters: {
        open: globalOpen,
        onClose: globalOnClose,
        closeOnBackdrop,
        closeOnEscape,
        closeOnLostFocus
      },
      escapeDismissParameters: {
        getWindow,
        parentDepth
      }
    } = _ref11;
    var {
      refElementReturn: refElementSourceReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      refElementReturn: refElementPopupReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var onCloseBackdrop = T$1(() => {
      return globalOnClose === null || globalOnClose === void 0 ? void 0 : globalOnClose("backdrop");
    }, [globalOnClose]);
    var onCloseEscape = T$1(() => {
      return globalOnClose === null || globalOnClose === void 0 ? void 0 : globalOnClose("escape");
    }, [globalOnClose]);
    var onCloseFocus = T$1(() => {
      return globalOnClose === null || globalOnClose === void 0 ? void 0 : globalOnClose("lost-focus");
    }, [globalOnClose]);
    useBackdropDismiss({
      backdropDismissParameters: {
        onClose: onCloseBackdrop,
        open: closeOnBackdrop && globalOpen
      },
      refElementPopupReturn
    });
    useEscapeDismiss({
      escapeDismissParameters: {
        getWindow,
        onClose: onCloseEscape,
        open: closeOnEscape && globalOpen,
        parentDepth
      },
      refElementPopupReturn
    });
    var {
      activeElementParameters
    } = useLostFocusDismiss({
      lostFocusDismiss: {
        onClose: onCloseFocus,
        open: closeOnLostFocus && globalOpen
      },
      refElementPopupReturn,
      refElementSourceReturn
    });
    var getDocument = T$1(() => {
      return getWindow().document;
    }, [getWindow]);
    useActiveElement({
      activeElementParameters: _objectSpread(_objectSpread({}, activeElementParameters), {}, {
        getWindow,
        getDocument
      })
    });
    return {
      refElementSourceReturn,
      refElementPopupReturn
    };
  }

  /*!
  * tabbable 6.0.1
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  */
  var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
  var NoElement = typeof Element === 'undefined';
  var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
    return element.getRootNode();
  } : function (element) {
    return element.ownerDocument;
  };
  var isInput = function isInput(node) {
    return node.tagName === 'INPUT';
  };
  var isHiddenInput = function isHiddenInput(node) {
    return isInput(node) && node.type === 'hidden';
  };
  var isDetailsWithSummary = function isDetailsWithSummary(node) {
    var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
      return child.tagName === 'SUMMARY';
    });
    return r;
  };

  // determines if a node is ultimately attached to the window's document
  var isNodeAttached = function isNodeAttached(node) {
    var _nodeRootHost;
    // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
    //  (but NOT _the_ document; see second 'If' comment below for more).
    // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
    //  is attached, and the one we need to check if it's in the document or not (because the
    //  shadow, and all nodes it contains, is never considered in the document since shadows
    //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
    //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
    //  visibility, including all the nodes it contains). The host could be any normal node,
    //  or a custom element (i.e. web component). Either way, that's the one that is considered
    //  part of the document, not the shadow root, nor any of its children (i.e. the node being
    //  tested).
    // To further complicate things, we have to look all the way up until we find a shadow HOST
    //  that is attached (or find none) because the node might be in nested shadows...
    // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
    //  document (per the docs) and while it's a Document-type object, that document does not
    //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
    //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
    //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
    //  node is actually detached.
    var nodeRootHost = getRootNode(node).host;
    var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRootHost2;
      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
      //  which means we need to get the host's host and check if that parent host is contained
      //  in (i.e. attached to) the document
      nodeRootHost = getRootNode(nodeRootHost).host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
    }
    return attached;
  };
  var isZeroArea = function isZeroArea(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(),
      width = _node$getBoundingClie.width,
      height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
  };
  var isHidden = function isHidden(node, _ref) {
    var displayCheck = _ref.displayCheck,
      getShadowRoot = _ref.getShadowRoot;
    // NOTE: visibility will be `undefined` if node is detached from the document
    //  (see notes about this further down), which means we will consider it visible
    //  (this is legacy behavior from a very long way back)
    // NOTE: we check this regardless of `displayCheck="none"` because this is a
    //  _visibility_ check, not a _display_ check
    if (getComputedStyle(node).visibility === 'hidden') {
      return true;
    }
    var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
      return true;
    }
    if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
      if (typeof getShadowRoot === 'function') {
        // figure out if we should consider the node to be in an undisclosed shadow and use the
        //  'non-zero-area' fallback
        var originalNode = node;
        while (node) {
          var parentElement = node.parentElement;
          var rootNode = getRootNode(node);
          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
          ) {
            // node has an undisclosed shadow which means we can only treat it as a black box, so we
            //  fall back to a non-zero-area test
            return isZeroArea(node);
          } else if (node.assignedSlot) {
            // iterate up slot
            node = node.assignedSlot;
          } else if (!parentElement && rootNode !== node.ownerDocument) {
            // cross shadow boundary
            node = rootNode.host;
          } else {
            // iterate up normal dom
            node = parentElement;
          }
        }
        node = originalNode;
      }
      // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
      //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
      //  it might be a falsy value, which means shadow DOM support is disabled

      // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
      //  now we can just test to see if it would normally be visible or not, provided it's
      //  attached to the main document.
      // NOTE: We must consider case where node is inside a shadow DOM and given directly to
      //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.

      if (isNodeAttached(node)) {
        // this works wherever the node is: if there's at least one client rect, it's
        //  somehow displayed; it also covers the CSS 'display: contents' case where the
        //  node itself is hidden in place of its contents; and there's no need to search
        //  up the hierarchy either
        return !node.getClientRects().length;
      }

      // Else, the node isn't attached to the document, which means the `getClientRects()`
      //  API will __always__ return zero rects (this can happen, for example, if React
      //  is used to render nodes onto a detached tree, as confirmed in this thread:
      //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
      //
      // It also means that even window.getComputedStyle(node).display will return `undefined`
      //  because styles are only computed for nodes that are in the document.
      //
      // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
      //  somehow. Though it was never stated officially, anyone who has ever used tabbable
      //  APIs on nodes in detached containers has actually implicitly used tabbable in what
      //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
      //  considering __everything__ to be visible because of the innability to determine styles.
      //
      // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
      //  nodes as visible with the 'none' fallback.__
      if (displayCheck !== 'legacy-full') {
        return true; // hidden
      }
      // else, fallback to 'none' mode and consider the node visible
    } else if (displayCheck === 'non-zero-area') {
      // NOTE: Even though this tests that the node's client rect is non-zero to determine
      //  whether it's displayed, and that a detached node will __always__ have a zero-area
      //  client rect, we don't special-case for whether the node is attached or not. In
      //  this mode, we do want to consider nodes that have a zero area to be hidden at all
      //  times, and that includes attached or not.
      return isZeroArea(node);
    }

    // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
    //  it's visible
    return false;
  };

  // form fields (nested) inside a disabled fieldset are not focusable/tabbable
  //  unless they are in the _first_ <legend> element of the top-most disabled
  //  fieldset
  var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
      var parentNode = node.parentElement;
      // check if `node` is contained in a disabled <fieldset>
      while (parentNode) {
        if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
          // look for the first <legend> among the children of the disabled <fieldset>
          for (var i = 0; i < parentNode.children.length; i++) {
            var child = parentNode.children.item(i);
            // when the first <legend> (in document order) is found
            if (child.tagName === 'LEGEND') {
              // if its parent <fieldset> is not nested in another disabled <fieldset>,
              // return whether `node` is a descendant of its first <legend>
              return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
            }
          }
          // the disabled <fieldset> containing `node` has no <legend>
          return true;
        }
        parentNode = parentNode.parentElement;
      }
    }

    // else, node's tabbable/focusable state should not be affected by a fieldset's
    //  enabled/disabled state
    return false;
  };
  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node, options) ||
    // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }
    return true;
  };
  var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');
  var isFocusable = function isFocusable(node, options) {
    options = options || {};
    if (!node) {
      throw new Error('No node provided');
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorFocusable(options, node);
  };
  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
  (function (module, exports) {
    (function (global, factory) {
      factory();
    })(commonjsGlobal, function () {
      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * This work is licensed under the W3C Software and Document License
       * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
       */

      (function () {
        // Return early if we're not running inside of the browser.
        if (typeof window === 'undefined') {
          return;
        }

        // Convenience function for converting NodeLists.
        /** @type {typeof Array.prototype.slice} */
        var slice = Array.prototype.slice;

        /**
         * IE has a non-standard name for "matches".
         * @type {typeof Element.prototype.matches}
         */
        var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

        /** @type {string} */
        var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

        /**
         * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
         * attribute.
         *
         * Its main functions are:
         *
         * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
         *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
         *   each focusable node in the subtree with the singleton `InertManager` which manages all known
         *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
         *   instance exists for each focusable node which has at least one inert root as an ancestor.
         *
         * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
         *   attribute is removed from the root node). This is handled in the destructor, which calls the
         *   `deregister` method on `InertManager` for each managed inert node.
         */

        var InertRoot = function () {
          /**
           * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
           * @param {!InertManager} inertManager The global singleton InertManager object.
           */
          function InertRoot(rootElement, inertManager) {
            _classCallCheck(this, InertRoot);

            /** @type {!InertManager} */
            this._inertManager = inertManager;

            /** @type {!HTMLElement} */
            this._rootElement = rootElement;

            /**
             * @type {!Set<!InertNode>}
             * All managed focusable nodes in this InertRoot's subtree.
             */
            this._managedNodes = new Set();

            // Make the subtree hidden from assistive technology
            if (this._rootElement.hasAttribute('aria-hidden')) {
              /** @type {?string} */
              this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
            } else {
              this._savedAriaHidden = null;
            }
            this._rootElement.setAttribute('aria-hidden', 'true');

            // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
            this._makeSubtreeUnfocusable(this._rootElement);

            // Watch for:
            // - any additions in the subtree: make them unfocusable too
            // - any removals from the subtree: remove them from this inert root's managed nodes
            // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
            //   element, make that node a managed node.
            this._observer = new MutationObserver(this._onMutation.bind(this));
            this._observer.observe(this._rootElement, {
              attributes: true,
              childList: true,
              subtree: true
            });
          }

          /**
           * Call this whenever this object is about to become obsolete.  This unwinds all of the state
           * stored in this object and updates the state of all of the managed nodes.
           */

          _createClass(InertRoot, [{
            key: 'destructor',
            value: function destructor() {
              this._observer.disconnect();
              if (this._rootElement) {
                if (this._savedAriaHidden !== null) {
                  this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                } else {
                  this._rootElement.removeAttribute('aria-hidden');
                }
              }
              this._managedNodes.forEach(function (inertNode) {
                this._unmanageNode(inertNode.node);
              }, this);

              // Note we cast the nulls to the ANY type here because:
              // 1) We want the class properties to be declared as non-null, or else we
              //    need even more casts throughout this code. All bets are off if an
              //    instance has been destroyed and a method is called.
              // 2) We don't want to cast "this", because we want type-aware optimizations
              //    to know which properties we're setting.
              this._observer = /** @type {?} */null;
              this._rootElement = /** @type {?} */null;
              this._managedNodes = /** @type {?} */null;
              this._inertManager = /** @type {?} */null;
            }

            /**
             * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
             */
          }, {
            key: '_makeSubtreeUnfocusable',
            /**
             * @param {!Node} startNode
             */
            value: function _makeSubtreeUnfocusable(startNode) {
              var _this2 = this;
              composedTreeWalk(startNode, function (node) {
                return _this2._visitNode(node);
              });
              var activeElement = document.activeElement;
              if (!document.body.contains(startNode)) {
                // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                var node = startNode;
                /** @type {!ShadowRoot|undefined} */
                var root = undefined;
                while (node) {
                  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                    root = /** @type {!ShadowRoot} */node;
                    break;
                  }
                  node = node.parentNode;
                }
                if (root) {
                  activeElement = root.activeElement;
                }
              }
              if (startNode.contains(activeElement)) {
                activeElement.blur();
                // In IE11, if an element is already focused, and then set to tabindex=-1
                // calling blur() will not actually move the focus.
                // To work around this we call focus() on the body instead.
                if (activeElement === document.activeElement) {
                  document.body.focus();
                }
              }
            }

            /**
             * @param {!Node} node
             */
          }, {
            key: '_visitNode',
            value: function _visitNode(node) {
              if (node.nodeType !== Node.ELEMENT_NODE) {
                return;
              }
              var element = /** @type {!HTMLElement} */node;

              // If a descendant inert root becomes un-inert, its descendants will still be inert because of
              // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
              if (element !== this._rootElement && element.hasAttribute('inert')) {
                this._adoptInertRoot(element);
              }
              if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                this._manageNode(element);
              }
            }

            /**
             * Register the given node with this InertRoot and with InertManager.
             * @param {!Node} node
             */
          }, {
            key: '_manageNode',
            value: function _manageNode(node) {
              var inertNode = this._inertManager.register(node, this);
              this._managedNodes.add(inertNode);
            }

            /**
             * Unregister the given node with this InertRoot and with InertManager.
             * @param {!Node} node
             */
          }, {
            key: '_unmanageNode',
            value: function _unmanageNode(node) {
              var inertNode = this._inertManager.deregister(node, this);
              if (inertNode) {
                this._managedNodes['delete'](inertNode);
              }
            }

            /**
             * Unregister the entire subtree starting at `startNode`.
             * @param {!Node} startNode
             */
          }, {
            key: '_unmanageSubtree',
            value: function _unmanageSubtree(startNode) {
              var _this3 = this;
              composedTreeWalk(startNode, function (node) {
                return _this3._unmanageNode(node);
              });
            }

            /**
             * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
             * @param {!HTMLElement} node
             */
          }, {
            key: '_adoptInertRoot',
            value: function _adoptInertRoot(node) {
              var inertSubroot = this._inertManager.getInertRoot(node);

              // During initialisation this inert root may not have been registered yet,
              // so register it now if need be.
              if (!inertSubroot) {
                this._inertManager.setInert(node, true);
                inertSubroot = this._inertManager.getInertRoot(node);
              }
              inertSubroot.managedNodes.forEach(function (savedInertNode) {
                this._manageNode(savedInertNode.node);
              }, this);
            }

            /**
             * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
             * @param {!Array<!MutationRecord>} records
             * @param {!MutationObserver} self
             */
          }, {
            key: '_onMutation',
            value: function _onMutation(records, self) {
              records.forEach(function (record) {
                var target = /** @type {!HTMLElement} */record.target;
                if (record.type === 'childList') {
                  // Manage added nodes
                  slice.call(record.addedNodes).forEach(function (node) {
                    this._makeSubtreeUnfocusable(node);
                  }, this);

                  // Un-manage removed nodes
                  slice.call(record.removedNodes).forEach(function (node) {
                    this._unmanageSubtree(node);
                  }, this);
                } else if (record.type === 'attributes') {
                  if (record.attributeName === 'tabindex') {
                    // Re-initialise inert node if tabindex changes
                    this._manageNode(target);
                  } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                    // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                    // already managed nodes from this inert subroot.
                    this._adoptInertRoot(target);
                    var inertSubroot = this._inertManager.getInertRoot(target);
                    this._managedNodes.forEach(function (managedNode) {
                      if (target.contains(managedNode.node)) {
                        inertSubroot._manageNode(managedNode.node);
                      }
                    });
                  }
                }
              }, this);
            }
          }, {
            key: 'managedNodes',
            get: function get() {
              return new Set(this._managedNodes);
            }

            /** @return {boolean} */
          }, {
            key: 'hasSavedAriaHidden',
            get: function get() {
              return this._savedAriaHidden !== null;
            }

            /** @param {?string} ariaHidden */
          }, {
            key: 'savedAriaHidden',
            set: function set(ariaHidden) {
              this._savedAriaHidden = ariaHidden;
            }

            /** @return {?string} */,

            get: function get() {
              return this._savedAriaHidden;
            }
          }]);
          return InertRoot;
        }();

        /**
         * `InertNode` initialises and manages a single inert node.
         * A node is inert if it is a descendant of one or more inert root elements.
         *
         * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
         * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
         * is intrinsically focusable or not.
         *
         * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
         * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
         * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
         * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
         * or removes the `tabindex` attribute if the element is intrinsically focusable.
         */

        var InertNode = function () {
          /**
           * @param {!Node} node A focusable element to be made inert.
           * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
           */
          function InertNode(node, inertRoot) {
            _classCallCheck(this, InertNode);

            /** @type {!Node} */
            this._node = node;

            /** @type {boolean} */
            this._overrodeFocusMethod = false;

            /**
             * @type {!Set<!InertRoot>} The set of descendant inert roots.
             *    If and only if this set becomes empty, this node is no longer inert.
             */
            this._inertRoots = new Set([inertRoot]);

            /** @type {?number} */
            this._savedTabIndex = null;

            /** @type {boolean} */
            this._destroyed = false;

            // Save any prior tabindex info and make this node untabbable
            this.ensureUntabbable();
          }

          /**
           * Call this whenever this object is about to become obsolete.
           * This makes the managed node focusable again and deletes all of the previously stored state.
           */

          _createClass(InertNode, [{
            key: 'destructor',
            value: function destructor() {
              this._throwIfDestroyed();
              if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                var element = /** @type {!HTMLElement} */this._node;
                if (this._savedTabIndex !== null) {
                  element.setAttribute('tabindex', this._savedTabIndex);
                } else {
                  element.removeAttribute('tabindex');
                }

                // Use `delete` to restore native focus method.
                if (this._overrodeFocusMethod) {
                  delete element.focus;
                }
              }

              // See note in InertRoot.destructor for why we cast these nulls to ANY.
              this._node = /** @type {?} */null;
              this._inertRoots = /** @type {?} */null;
              this._destroyed = true;
            }

            /**
             * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
             * If the object has been destroyed, any attempt to access it will cause an exception.
             */
          }, {
            key: '_throwIfDestroyed',
            /**
             * Throw if user tries to access destroyed InertNode.
             */
            value: function _throwIfDestroyed() {
              if (this.destroyed) {
                throw new Error('Trying to access destroyed InertNode');
              }
            }

            /** @return {boolean} */
          }, {
            key: 'ensureUntabbable',
            /** Save the existing tabindex value and make the node untabbable and unfocusable */
            value: function ensureUntabbable() {
              if (this.node.nodeType !== Node.ELEMENT_NODE) {
                return;
              }
              var element = /** @type {!HTMLElement} */this.node;
              if (matches.call(element, _focusableElementsString)) {
                if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
                  return;
                }
                if (element.hasAttribute('tabindex')) {
                  this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
                }
                element.setAttribute('tabindex', '-1');
                if (element.nodeType === Node.ELEMENT_NODE) {
                  element.focus = function () {};
                  this._overrodeFocusMethod = true;
                }
              } else if (element.hasAttribute('tabindex')) {
                this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
                element.removeAttribute('tabindex');
              }
            }

            /**
             * Add another inert root to this inert node's set of managing inert roots.
             * @param {!InertRoot} inertRoot
             */
          }, {
            key: 'addInertRoot',
            value: function addInertRoot(inertRoot) {
              this._throwIfDestroyed();
              this._inertRoots.add(inertRoot);
            }

            /**
             * Remove the given inert root from this inert node's set of managing inert roots.
             * If the set of managing inert roots becomes empty, this node is no longer inert,
             * so the object should be destroyed.
             * @param {!InertRoot} inertRoot
             */
          }, {
            key: 'removeInertRoot',
            value: function removeInertRoot(inertRoot) {
              this._throwIfDestroyed();
              this._inertRoots['delete'](inertRoot);
              if (this._inertRoots.size === 0) {
                this.destructor();
              }
            }
          }, {
            key: 'destroyed',
            get: function get() {
              return (/** @type {!InertNode} */this._destroyed
              );
            }
          }, {
            key: 'hasSavedTabIndex',
            get: function get() {
              return this._savedTabIndex !== null;
            }

            /** @return {!Node} */
          }, {
            key: 'node',
            get: function get() {
              this._throwIfDestroyed();
              return this._node;
            }

            /** @param {?number} tabIndex */
          }, {
            key: 'savedTabIndex',
            set: function set(tabIndex) {
              this._throwIfDestroyed();
              this._savedTabIndex = tabIndex;
            }

            /** @return {?number} */,

            get: function get() {
              this._throwIfDestroyed();
              return this._savedTabIndex;
            }
          }]);
          return InertNode;
        }();

        /**
         * InertManager is a per-document singleton object which manages all inert roots and nodes.
         *
         * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
         * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
         * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
         * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
         * is created for each such node, via the `_managedNodes` map.
         */

        var InertManager = function () {
          /**
           * @param {!Document} document
           */
          function InertManager(document) {
            _classCallCheck(this, InertManager);
            if (!document) {
              throw new Error('Missing required argument; InertManager needs to wrap a document.');
            }

            /** @type {!Document} */
            this._document = document;

            /**
             * All managed nodes known to this InertManager. In a map to allow looking up by Node.
             * @type {!Map<!Node, !InertNode>}
             */
            this._managedNodes = new Map();

            /**
             * All inert roots known to this InertManager. In a map to allow looking up by Node.
             * @type {!Map<!Node, !InertRoot>}
             */
            this._inertRoots = new Map();

            /**
             * Observer for mutations on `document.body`.
             * @type {!MutationObserver}
             */
            this._observer = new MutationObserver(this._watchForInert.bind(this));

            // Add inert style.
            addInertStyle(document.head || document.body || document.documentElement);

            // Wait for document to be loaded.
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
            } else {
              this._onDocumentLoaded();
            }
          }

          /**
           * Set whether the given element should be an inert root or not.
           * @param {!HTMLElement} root
           * @param {boolean} inert
           */

          _createClass(InertManager, [{
            key: 'setInert',
            value: function setInert(root, inert) {
              if (inert) {
                if (this._inertRoots.has(root)) {
                  // element is already inert
                  return;
                }
                var inertRoot = new InertRoot(root, this);
                root.setAttribute('inert', '');
                this._inertRoots.set(root, inertRoot);
                // If not contained in the document, it must be in a shadowRoot.
                // Ensure inert styles are added there.
                if (!this._document.body.contains(root)) {
                  var parent = root.parentNode;
                  while (parent) {
                    if (parent.nodeType === 11) {
                      addInertStyle(parent);
                    }
                    parent = parent.parentNode;
                  }
                }
              } else {
                if (!this._inertRoots.has(root)) {
                  // element is already non-inert
                  return;
                }
                var _inertRoot = this._inertRoots.get(root);
                _inertRoot.destructor();
                this._inertRoots['delete'](root);
                root.removeAttribute('inert');
              }
            }

            /**
             * Get the InertRoot object corresponding to the given inert root element, if any.
             * @param {!Node} element
             * @return {!InertRoot|undefined}
             */
          }, {
            key: 'getInertRoot',
            value: function getInertRoot(element) {
              return this._inertRoots.get(element);
            }

            /**
             * Register the given InertRoot as managing the given node.
             * In the case where the node has a previously existing inert root, this inert root will
             * be added to its set of inert roots.
             * @param {!Node} node
             * @param {!InertRoot} inertRoot
             * @return {!InertNode} inertNode
             */
          }, {
            key: 'register',
            value: function register(node, inertRoot) {
              var inertNode = this._managedNodes.get(node);
              if (inertNode !== undefined) {
                // node was already in an inert subtree
                inertNode.addInertRoot(inertRoot);
              } else {
                inertNode = new InertNode(node, inertRoot);
              }
              this._managedNodes.set(node, inertNode);
              return inertNode;
            }

            /**
             * De-register the given InertRoot as managing the given inert node.
             * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
             * node from the InertManager's set of managed nodes if it is destroyed.
             * If the node is not currently managed, this is essentially a no-op.
             * @param {!Node} node
             * @param {!InertRoot} inertRoot
             * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
             */
          }, {
            key: 'deregister',
            value: function deregister(node, inertRoot) {
              var inertNode = this._managedNodes.get(node);
              if (!inertNode) {
                return null;
              }
              inertNode.removeInertRoot(inertRoot);
              if (inertNode.destroyed) {
                this._managedNodes['delete'](node);
              }
              return inertNode;
            }

            /**
             * Callback used when document has finished loading.
             */
          }, {
            key: '_onDocumentLoaded',
            value: function _onDocumentLoaded() {
              // Find all inert roots in document and make them actually inert.
              var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
              inertElements.forEach(function (inertElement) {
                this.setInert(inertElement, true);
              }, this);

              // Comment this out to use programmatic API only.
              this._observer.observe(this._document.body || this._document.documentElement, {
                attributes: true,
                subtree: true,
                childList: true
              });
            }

            /**
             * Callback used when mutation observer detects attribute changes.
             * @param {!Array<!MutationRecord>} records
             * @param {!MutationObserver} self
             */
          }, {
            key: '_watchForInert',
            value: function _watchForInert(records, self) {
              var _this = this;
              records.forEach(function (record) {
                switch (record.type) {
                  case 'childList':
                    slice.call(record.addedNodes).forEach(function (node) {
                      if (node.nodeType !== Node.ELEMENT_NODE) {
                        return;
                      }
                      var inertElements = slice.call(node.querySelectorAll('[inert]'));
                      if (matches.call(node, '[inert]')) {
                        inertElements.unshift(node);
                      }
                      inertElements.forEach(function (inertElement) {
                        this.setInert(inertElement, true);
                      }, _this);
                    }, _this);
                    break;
                  case 'attributes':
                    if (record.attributeName !== 'inert') {
                      return;
                    }
                    var target = /** @type {!HTMLElement} */record.target;
                    var inert = target.hasAttribute('inert');
                    _this.setInert(target, inert);
                    break;
                }
              }, this);
            }
          }]);
          return InertManager;
        }();

        /**
         * Recursively walk the composed tree from |node|.
         * @param {!Node} node
         * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
         *     before descending into child nodes.
         * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
         */

        function composedTreeWalk(node, callback, shadowRootAncestor) {
          if (node.nodeType == Node.ELEMENT_NODE) {
            var element = /** @type {!HTMLElement} */node;
            if (callback) {
              callback(element);
            }

            // Descend into node:
            // If it has a ShadowRoot, ignore all child elements - these will be picked
            // up by the <content> or <shadow> elements. Descend straight into the
            // ShadowRoot.
            var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
            if (shadowRoot) {
              composedTreeWalk(shadowRoot, callback);
              return;
            }

            // If it is a <content> element, descend into distributed elements - these
            // are elements from outside the shadow root which are rendered inside the
            // shadow DOM.
            if (element.localName == 'content') {
              var content = /** @type {!HTMLContentElement} */element;
              // Verifies if ShadowDom v0 is supported.
              var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
              for (var i = 0; i < distributedNodes.length; i++) {
                composedTreeWalk(distributedNodes[i], callback);
              }
              return;
            }

            // If it is a <slot> element, descend into assigned nodes - these
            // are elements from outside the shadow root which are rendered inside the
            // shadow DOM.
            if (element.localName == 'slot') {
              var slot = /** @type {!HTMLSlotElement} */element;
              // Verify if ShadowDom v1 is supported.
              var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                flatten: true
              }) : [];
              for (var _i = 0; _i < _distributedNodes.length; _i++) {
                composedTreeWalk(_distributedNodes[_i], callback);
              }
              return;
            }
          }

          // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
          // element, nor a <shadow> element recurse normally.
          var child = node.firstChild;
          while (child != null) {
            composedTreeWalk(child, callback);
            child = child.nextSibling;
          }
        }

        /**
         * Adds a style element to the node containing the inert specific styles
         * @param {!Node} node
         */
        function addInertStyle(node) {
          if (node.querySelector('style#inert-style, link#inert-style')) {
            return;
          }
          var style = document.createElement('style');
          style.setAttribute('id', 'inert-style');
          style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
          node.appendChild(style);
        }
        if (!HTMLElement.prototype.hasOwnProperty('inert')) {
          /** @type {!InertManager} */
          var inertManager = new InertManager(document);
          Object.defineProperty(HTMLElement.prototype, 'inert', {
            enumerable: true,
            /** @this {!HTMLElement} */
            get: function get() {
              return this.hasAttribute('inert');
            },
            /** @this {!HTMLElement} */
            set: function set(inert) {
              inertManager.setInert(this, inert);
            }
          });
        }
      })();
    });
  })();

  /**
   * @license
   * Copyright 2016 Google Inc. All rights reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (() => {
    var _a, _b, _c;
    /* Symbols for private properties */
    var _blockingElements = Symbol();
    var _alreadyInertElements = Symbol();
    var _topElParents = Symbol();
    var _siblingsToRestore = Symbol();
    var _parentMO = Symbol();
    /* Symbols for private static methods */
    var _topChanged = Symbol();
    var _swapInertedSibling = Symbol();
    var _inertSiblings = Symbol();
    var _restoreInertedSiblings = Symbol();
    var _getParents = Symbol();
    var _getDistributedChildren = Symbol();
    var _isInertable = Symbol();
    var _handleMutations = Symbol();
    class BlockingElementsImpl {
      constructor() {
        /**
         * The blocking elements.
         */
        this[_a] = [];
        /**
         * Used to keep track of the parents of the top element, from the element
         * itself up to body. When top changes, the old top might have been removed
         * from the document, so we need to memoize the inerted parents' siblings
         * in order to restore their inerteness when top changes.
         */
        this[_b] = [];
        /**
         * Elements that are already inert before the first blocking element is
         * pushed.
         */
        this[_c] = new Set();
      }
      destructor() {
        // Restore original inertness.
        this[_restoreInertedSiblings](this[_topElParents]);
        // Note we don't want to make these properties nullable on the class,
        // since then we'd need non-null casts in many places. Calling a method on
        // a BlockingElements instance after calling destructor will result in an
        // exception.
        var nullable = this;
        nullable[_blockingElements] = null;
        nullable[_topElParents] = null;
        nullable[_alreadyInertElements] = null;
      }
      get top() {
        var elems = this[_blockingElements];
        return elems[elems.length - 1] || null;
      }
      push(element) {
        if (!element || element === this.top) {
          return;
        }
        // Remove it from the stack, we'll bring it to the top.
        this.remove(element);
        this[_topChanged](element);
        this[_blockingElements].push(element);
      }
      remove(element) {
        var i = this[_blockingElements].indexOf(element);
        if (i === -1) {
          return false;
        }
        this[_blockingElements].splice(i, 1);
        // Top changed only if the removed element was the top element.
        if (i === this[_blockingElements].length) {
          this[_topChanged](this.top);
        }
        return true;
      }
      pop() {
        var top = this.top;
        top && this.remove(top);
        return top;
      }
      has(element) {
        return this[_blockingElements].indexOf(element) !== -1;
      }
      /**
       * Sets `inert` to all document elements except the new top element, its
       * parents, and its distributed content.
       */
      [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
        var toKeepInert = this[_alreadyInertElements];
        var oldParents = this[_topElParents];
        // No new top, reset old top if any.
        if (!newTop) {
          this[_restoreInertedSiblings](oldParents);
          toKeepInert.clear();
          this[_topElParents] = [];
          return;
        }
        var newParents = this[_getParents](newTop);
        // New top is not contained in the main document!
        if (newParents[newParents.length - 1].parentNode !== document.body) {
          throw Error('Non-connected element cannot be a blocking element');
        }
        // Cast here because we know we'll call _inertSiblings on newParents
        // below.
        this[_topElParents] = newParents;
        var toSkip = this[_getDistributedChildren](newTop);
        // No previous top element.
        if (!oldParents.length) {
          this[_inertSiblings](newParents, toSkip, toKeepInert);
          return;
        }
        var i = oldParents.length - 1;
        var j = newParents.length - 1;
        // Find common parent. Index 0 is the element itself (so stop before it).
        while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
          i--;
          j--;
        }
        // If up the parents tree there are 2 elements that are siblings, swap
        // the inerted sibling.
        if (oldParents[i] !== newParents[j]) {
          this[_swapInertedSibling](oldParents[i], newParents[j]);
        }
        // Restore old parents siblings inertness.
        i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
        // Make new parents siblings inert.
        j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
      }
      /**
       * Swaps inertness between two sibling elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_swapInertedSibling](oldInert, newInert) {
        var siblingsToRestore = oldInert[_siblingsToRestore];
        // oldInert is not contained in siblings to restore, so we have to check
        // if it's inertable and if already inert.
        if (this[_isInertable](oldInert) && !oldInert.inert) {
          oldInert.inert = true;
          siblingsToRestore.add(oldInert);
        }
        // If newInert was already between the siblings to restore, it means it is
        // inertable and must be restored.
        if (siblingsToRestore.has(newInert)) {
          newInert.inert = false;
          siblingsToRestore.delete(newInert);
        }
        newInert[_parentMO] = oldInert[_parentMO];
        newInert[_siblingsToRestore] = siblingsToRestore;
        oldInert[_parentMO] = undefined;
        oldInert[_siblingsToRestore] = undefined;
      }
      /**
       * Restores original inertness to the siblings of the elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_restoreInertedSiblings](elements) {
        for (var element of elements) {
          var mo = element[_parentMO];
          mo.disconnect();
          element[_parentMO] = undefined;
          var siblings = element[_siblingsToRestore];
          for (var sibling of siblings) {
            sibling.inert = false;
          }
          element[_siblingsToRestore] = undefined;
        }
      }
      /**
       * Inerts the siblings of the elements except the elements to skip. Stores
       * the inerted siblings into the element's symbol `_siblingsToRestore`.
       * Pass `toKeepInert` to collect the already inert elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_inertSiblings](elements, toSkip, toKeepInert) {
        for (var element of elements) {
          // Assume element is not a Document, so it must have a parentNode.
          var parent = element.parentNode;
          var children = parent.children;
          var inertedSiblings = new Set();
          for (var _j = 0; _j < children.length; _j++) {
            var sibling = children[_j];
            // Skip the input element, if not inertable or to be skipped.
            if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
              continue;
            }
            // Should be collected since already inerted.
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
          // Store the siblings that were inerted.
          element[_siblingsToRestore] = inertedSiblings;
          // Observe only immediate children mutations on the parent.
          var mo = new MutationObserver(this[_handleMutations].bind(this));
          element[_parentMO] = mo;
          var parentToObserve = parent;
          // If we're using the ShadyDOM polyfill, then our parent could be a
          // shady root, which is an object that acts like a ShadowRoot, but isn't
          // actually a node in the real DOM. Observe the real DOM parent instead.
          var maybeShadyRoot = parentToObserve;
          if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
            parentToObserve = maybeShadyRoot.host;
          }
          mo.observe(parentToObserve, {
            childList: true
          });
        }
      }
      /**
       * Handles newly added/removed nodes by toggling their inertness.
       * It also checks if the current top Blocking Element has been removed,
       * notifying and removing it.
       */
      [_handleMutations](mutations) {
        var parents = this[_topElParents];
        var toKeepInert = this[_alreadyInertElements];
        for (var mutation of mutations) {
          // If the target is a shadowRoot, get its host as we skip shadowRoots when
          // computing _topElParents.
          var target = mutation.target.host || mutation.target;
          var idx = target === document.body ? parents.length : parents.indexOf(target);
          var inertedChild = parents[idx - 1];
          var inertedSiblings = inertedChild[_siblingsToRestore];
          // To restore.
          for (var _i2 = 0; _i2 < mutation.removedNodes.length; _i2++) {
            var sibling = mutation.removedNodes[_i2];
            if (sibling === inertedChild) {
              console.info('Detected removal of the top Blocking Element.');
              this.pop();
              return;
            }
            if (inertedSiblings.has(sibling)) {
              sibling.inert = false;
              inertedSiblings.delete(sibling);
            }
          }
          // To inert.
          for (var _i3 = 0; _i3 < mutation.addedNodes.length; _i3++) {
            var _sibling = mutation.addedNodes[_i3];
            if (!this[_isInertable](_sibling)) {
              continue;
            }
            if (toKeepInert && _sibling.inert) {
              toKeepInert.add(_sibling);
            } else {
              _sibling.inert = true;
              inertedSiblings.add(_sibling);
            }
          }
        }
      }
      /**
       * Returns if the element is inertable.
       */
      [_isInertable](element) {
        return false === /^(style|template|script)$/.test(element.localName);
      }
      /**
       * Returns the list of newParents of an element, starting from element
       * (included) up to `document.body` (excluded).
       */
      [_getParents](element) {
        var parents = [];
        var current = element;
        // Stop to body.
        while (current && current !== document.body) {
          // Skip shadow roots.
          if (current.nodeType === Node.ELEMENT_NODE) {
            parents.push(current);
          }
          // ShadowDom v1
          if (current.assignedSlot) {
            // Collect slots from deepest slot to top.
            while (current = current.assignedSlot) {
              parents.push(current);
            }
            // Continue the search on the top slot.
            current = parents.pop();
            continue;
          }
          current = current.parentNode || current.host;
        }
        return parents;
      }
      /**
       * Returns the distributed children of the element's shadow root.
       * Returns null if the element doesn't have a shadow root.
       */
      [_getDistributedChildren](element) {
        var shadowRoot = element.shadowRoot;
        if (!shadowRoot) {
          return null;
        }
        var result = new Set();
        var i;
        var j;
        var nodes;
        var slots = shadowRoot.querySelectorAll('slot');
        if (slots.length && slots[0].assignedNodes) {
          for (i = 0; i < slots.length; i++) {
            nodes = slots[i].assignedNodes({
              flatten: true
            });
            for (j = 0; j < nodes.length; j++) {
              if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                result.add(nodes[j]);
              }
            }
          }
          // No need to search for <content>.
        }

        return result;
      }
    }
    document.$blockingElements = new BlockingElementsImpl();
  })();
  function getDocument(element) {
    var _ref12, _ref13, _element$ownerDocumen;
    return (_ref12 = (_ref13 = (_element$ownerDocumen = element === null || element === void 0 ? void 0 : element.ownerDocument) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : document) !== null && _ref13 !== void 0 ? _ref13 : window.document) !== null && _ref12 !== void 0 ? _ref12 : globalThis.document;
  }
  function blockingElements() {
    return getDocument().$blockingElements;
  }
  /**
   * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
   *
   * Automatically handles consecutive calls with a loosely applied stack operation
   * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
   * it'll take to find its way into the spec, if ever)
   * @param target
   */
  function useBlockingElement(enabled, getTarget) {
    var stableGetTarget = useStableCallback(getTarget);
    var getDocument = useStableCallback(() => {
      var _getTarget$ownerDocum, _getTarget;
      return (_getTarget$ownerDocum = (_getTarget = getTarget()) === null || _getTarget === void 0 ? void 0 : _getTarget.ownerDocument) !== null && _getTarget$ownerDocum !== void 0 ? _getTarget$ownerDocum : globalThis.document;
    });
    useActiveElement({
      activeElementParameters: {
        getDocument,
        onLastActiveElementChange: useStableCallback(e => {
          if (e) {
            if (enabled) setLastActiveWhenOpen(e);else setLastActiveWhenClosed(e);
          }
        })
      }
    });
    var [getTop, setTop] = usePassiveState(null, returnNull);
    var [getLastActiveWhenClosed, setLastActiveWhenClosed] = usePassiveState(null, returnNull);
    var [getLastActiveWhenOpen, setLastActiveWhenOpen] = usePassiveState(null, returnNull);
    /**
     * Push/pop the element from the blockingElements stack.
     */
    s(() => {
      var target = stableGetTarget();
      if (enabled) {
        // Sometimes blockingElements will fail if, for example,
        // the target element isn't connected to document.body.
        // This is rare, but it's better to fail silently with weird tabbing behavior
        // than to crash the entire application.
        try {
          blockingElements().push(target);
          setTop(target);
          return () => {
            blockingElements().remove(target);
          };
        } catch (ex) {
          // Well, semi-silently.
          console.error(ex);
        }
      }
    }, [enabled]);
    return {
      getTop,
      getLastActiveWhenClosed,
      getLastActiveWhenOpen
    };
  }

  //const elementsToRestoreFocusTo = new Map<Element | null, (Node & HTMLOrSVGElement)>();
  function useFocusTrap(_ref14) {
    var {
        focusTrapParameters: {
          onlyMoveFocus,
          trapActive,
          focusPopup: focusSelfUnstable,
          focusOpener: focusOpenerUnstable
        },
        refElementParameters: {
          onElementChange
        }
      } = _ref14,
      refElementParameters = _objectWithoutProperties(_ref14.refElementParameters, _excluded11);
    var focusSelf = useStableCallback(focusSelfUnstable);
    var focusOpener = useStableCallback(focusOpenerUnstable);
    h(() => {
      if (trapActive) {
        var top = getTop();
        getLastActiveWhenOpen();
        {
          var _top;
          (_top = top) !== null && _top !== void 0 ? _top : top = refElementReturn.getElement();
          console.assert(!!top);
          if (top) focusSelf(top, () => findFirstFocusable(top));
        }
      } else {
        var lastActive = getLastActiveWhenClosed();
        if (lastActive) focusOpener(lastActive);
      }
    }, [trapActive]);
    var {
      refElementReturn
    } = useRefElement({
      refElementParameters: _objectSpread({
        onElementChange
      }, refElementParameters)
    });
    var {
      getElement
    } = refElementReturn;
    var {
      getTop,
      getLastActiveWhenClosed,
      getLastActiveWhenOpen
    } = useBlockingElement(trapActive && !onlyMoveFocus, getElement);
    return {
      refElementReturn,
      focusTrapReturn: {
        propsUnstable: {
          "aria-modal": trapActive ? "true" : undefined
        }
      }
    };
  }
  /**
   * Returns the first focusable element contained within the given node, or null if none are found.
   * @param element
   * @returns
   */
  function findFirstFocusable(element) {
    var _element2;
    console.assert(!!element);
    (_element2 = element) !== null && _element2 !== void 0 ? _element2 : element = document.body;
    var treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
      acceptNode: node => node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
    });
    var firstFocusable = treeWalker.firstChild();
    return firstFocusable;
  }
  function useTextContent(_ref15) {
    var {
      refElementReturn: {
        getElement
      },
      textContentParameters: {
        getText,
        onTextContentChange
      }
    } = _ref15;
    var [getTextContent, setTextContent] = usePassiveState(onTextContentChange, returnNull);
    h(() => {
      var element = getElement();
      if (element) {
        var textContent = getText(element);
        if (textContent) {
          setTextContent(textContent);
        }
      }
    });
    return {
      textContentReturn: {
        getTextContent
      }
    };
  }

  /**
   * Slightly enhanced version of `useState` that includes a getter that remains constant
   * (i.e. you can use it in `useEffect` and friends without it being a dependency).
   *
   * @param initialState
   * @returns
   */
  function useState(initialState) {
    // We keep both, but overrride the `setState` functionality
    var [state, setStateP] = p(initialState);
    var ref = _(state);
    // Hijack the normal setter function 
    // to also set our ref to the new value
    var setState = T$1(value => {
      if (typeof value === "function") {
        var callback = value;
        setStateP(prevValue => {
          var nextValue = callback(prevValue);
          ref.current = nextValue;
          return nextValue;
        });
      } else {
        ref.current = value;
        setStateP(value);
      }
    }, []);
    var getState = () => {
      return ref.current;
    };
    console.assert(ref.current === state || typeof state === "number" && isNaN(state));
    return [state, setState, getState];
  }

  /** Arguments passed to the child 'useLinearNavigationChild` */
  //export interface UseLinearNavigationChildInfo { }
  /**
   * When used in tandem with `useRovingTabIndex`, allows control of
   * the tabbable index with the arrow keys.
   *
   * @see useListNavigation, which packages everything up together.
   */
  function useLinearNavigation(_ref16) {
    var {
      rovingTabIndexReturn,
      linearNavigationParameters
    } = _ref16;
    var {
      getHighestIndex,
      indexDemangler,
      indexMangler,
      isValid,
      navigatePastEnd,
      navigatePastStart
    } = linearNavigationParameters;
    var {
      getTabbableIndex,
      setTabbableIndex
    } = rovingTabIndexReturn;
    var navigateAbsolute = T$1((i, e, fromUserInteraction) => {
      var target = indexDemangler(i);
      var {
        value
      } = tryNavigateToIndex({
        isValid,
        highestChildIndex: getHighestIndex(),
        indexDemangler,
        indexMangler,
        searchDirection: -1,
        target
      });
      setTabbableIndex(value, e, fromUserInteraction);
    }, []);
    var navigateToFirst = useStableCallback((e, fromUserInteraction) => {
      navigateAbsolute(0, e, fromUserInteraction);
    });
    var navigateToLast = useStableCallback((e, fromUserInteraction) => {
      navigateAbsolute(getHighestIndex(), e, fromUserInteraction);
    });
    var navigateRelative2 = useStableCallback((e, offset, fromUserInteraction, mode) => {
      var _getTabbableIndex;
      var original = (_getTabbableIndex = getTabbableIndex()) !== null && _getTabbableIndex !== void 0 ? _getTabbableIndex : 0;
      var {
        status,
        value
      } = tryNavigateToIndex({
        isValid,
        highestChildIndex: getHighestIndex(),
        indexDemangler,
        indexMangler,
        searchDirection: Math.sign(offset) || 1,
        target: indexDemangler(indexMangler(original) + offset)
      });
      if (status == "past-end") {
        if (navigatePastEnd == "wrap") {
          if (mode == "single") navigateToFirst(e, fromUserInteraction);else {
            /* eslint-disable no-constant-condition */
            // Uncomment to allow page up/down to wrap after hitting the top/bottom once.
            // It works fine, the problem isn't that -- the problem is it just feels wrong. 
            // Page Up/Down don't feel like they should wrap, even if normally requested. 
            // That's the arrow keys' domain.
            navigateToLast(e, fromUserInteraction);
          }
        } else {
          navigatePastEnd();
        }
      } else if (status == "past-start") {
        if (navigatePastStart == "wrap") {
          if (mode == "single") {
            navigateToLast(e, fromUserInteraction);
          } else {
            /* eslint-disable no-constant-condition */
            // See above. It works fine but just feels wrong to wrap on Page Up/Down.
            navigateToFirst(e, fromUserInteraction);
          }
        } else {
          navigatePastStart();
        }
      } else {
        setTabbableIndex(value, e, fromUserInteraction);
      }
    });
    var navigateToNext = useStableCallback((e, fromUserInteraction) => {
      navigateRelative2(e, 1, fromUserInteraction, "single");
      // setTabbableIndex(navigateRelative((getTabbableIndex() ?? 0), +1), fromUserInteraction)
    });

    var navigateToPrev = useStableCallback((e, fromUserInteraction) => {
      navigateRelative2(e, -1, fromUserInteraction, "single");
      // setTabbableIndex(navigateRelative((getTabbableIndex() ?? 0), +1), fromUserInteraction)
    });

    var getDisableArrowKeys = useStableGetter(linearNavigationParameters.disableArrowKeys);
    var getDisableHomeEndKeys = useStableGetter(linearNavigationParameters.disableHomeEndKeys);
    var getNavigationDirection = useStableGetter(linearNavigationParameters.navigationDirection);
    var getPageNavigationSize = useStableGetter(linearNavigationParameters.pageNavigationSize);
    var stableProps = _({
      onKeyDown: e => {
        // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
        if (e.ctrlKey || e.metaKey) return;
        //const info = getLogicalDirectionInfo();
        var navigationDirection = getNavigationDirection();
        var disableArrowKeys = getDisableArrowKeys();
        var disableHomeEndKeys = getDisableHomeEndKeys();
        var pageNavigationSize = getPageNavigationSize();
        var allowsVerticalNavigation = navigationDirection == "vertical" || navigationDirection == "either";
        var allowsHorizontalNavigation = navigationDirection == "horizontal" || navigationDirection == "either";
        var truePageNavigationSize = pageNavigationSize;
        if (truePageNavigationSize < 1) {
          truePageNavigationSize = Math.round(pageNavigationSize * Math.max(100, getHighestIndex() + 1));
        }
        switch (e.key) {
          case "ArrowUp":
            {
              //const propName = (info?.blockOrientation === "vertical" ? "blockDirection" : "inlineDirection");
              var directionAllowed = !disableArrowKeys && allowsVerticalNavigation;
              if (directionAllowed) {
                navigateToPrev(e, true);
                e.preventDefault();
                e.stopPropagation();
              }
              break;
            }
          case "ArrowDown":
            {
              var _directionAllowed = !disableArrowKeys && allowsVerticalNavigation;
              if (_directionAllowed) {
                navigateToNext(e, true);
                e.preventDefault();
                e.stopPropagation();
              }
              break;
            }
          case "ArrowLeft":
            {
              var _directionAllowed2 = !disableArrowKeys && allowsHorizontalNavigation;
              if (_directionAllowed2) {
                navigateToPrev(e, true);
                e.preventDefault();
                e.stopPropagation();
              }
              break;
            }
          case "ArrowRight":
            {
              var _directionAllowed3 = !disableArrowKeys && allowsHorizontalNavigation;
              if (_directionAllowed3) {
                navigateToNext(e, true);
                e.preventDefault();
                e.stopPropagation();
              }
              break;
            }
          case "PageUp":
            {
              if (truePageNavigationSize > 0) {
                navigateRelative2(e, -truePageNavigationSize, true, "page");
                e.preventDefault();
                e.stopPropagation();
              }
              break;
            }
          case "PageDown":
            {
              if (truePageNavigationSize > 0) {
                navigateRelative2(e, truePageNavigationSize, true, "page");
                e.preventDefault();
                e.stopPropagation();
              }
              break;
            }
          case "Home":
            if (!disableHomeEndKeys) {
              navigateToFirst(e, true);
              e.preventDefault();
              e.stopPropagation();
            }
            break;
          case "End":
            if (!disableHomeEndKeys) {
              navigateToLast(e, true);
              e.preventDefault();
              e.stopPropagation();
            }
            break;
        }
      }
    });
    return {
      linearNavigationReturn: {
        propsStable: stableProps.current
      }
    };
  }
  function tryNavigateToIndex(_ref17) {
    var {
      isValid,
      highestChildIndex: upper,
      searchDirection,
      indexDemangler,
      indexMangler,
      target
    } = _ref17;
    //const upper = children.getHighestIndex();
    var lower = 0;
    if (searchDirection === -1) {
      while (target >= lower && !isValid(target)) {
        target = indexDemangler(indexMangler(target) - 1);
      }
      return target < lower ? {
        value: indexDemangler(lower),
        status: "past-start"
      } : {
        value: target,
        status: "normal"
      };
    } else if (searchDirection === 1) {
      while (target <= upper && !isValid(target)) {
        target = indexDemangler(indexMangler(target) + 1);
      }
      return target > upper ? {
        value: indexDemangler(upper),
        status: "past-end"
      } : {
        value: target,
        status: "normal"
      };
    } else {
      return {
        value: lower,
        status: "normal"
      };
    }
  }
  /**
   * Allows for the selection of a managed child by typing the given text associated with it.
   *
   * @see useListNavigation, which packages everything up together.
   */
  function useTypeaheadNavigation(_ref18) {
    var {
        typeaheadNavigationParameters: {
          collator,
          typeaheadTimeout,
          noTypeahead,
          isValid
        },
        rovingTabIndexReturn: {
          getTabbableIndex: getIndex,
          setTabbableIndex: setIndex
        }
      } = _ref18,
      _void3 = _objectWithoutProperties(_ref18.typeaheadNavigationParameters, _excluded12),
      _void1 = _objectWithoutProperties(_ref18.rovingTabIndexReturn, _excluded13),
      _void2 = _objectWithoutProperties(_ref18, _excluded14);
    // For typeahead, keep track of what our current "search" string is (if we have one)
    // and also clear it every 1000 ms since the last time it changed.
    // Next, keep a mapping of typeahead values to indices for faster searching.
    // And, for the user's sake, let them know when their typeahead can't match anything anymore
    var [getCurrentTypeahead, setCurrentTypeahead] = usePassiveState(useStableCallback((currentTypeahead, prev, reason) => {
      var handle = setTimeout(() => {
        setCurrentTypeahead(null, undefined);
        setInvalidTypeahead(null);
      }, typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000);
      updateBasedOnTypeaheadChange(currentTypeahead, reason);
      return () => clearTimeout(handle);
    }));
    //useTimeout({ timeout: typeaheadTimeout ?? 1000, callback: () => { setCurrentTypeahead(null); setInvalidTypeahead(null); }, triggerIndex: currentTypeahead });
    var sortedTypeaheadInfo = _([]);
    var [invalidTypeahead, setInvalidTypeahead] = useState(false);
    // Handle typeahead for input method editors as well
    // Essentially, when active, ignore further keys 
    // because we're waiting for a CompositionEnd event
    var [, setImeActive, getImeActive] = useState(false);
    // Because composition events fire *after* keydown events 
    // (but within the same task, which, TODO, could be browser-dependent),
    // we can use this to keep track of which event we're listening for on the first keydown.
    var [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
    s(() => {
      if (nextTypeaheadChar !== null) {
        setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar, undefined);
        setNextTypeaheadChar(null);
      }
    }, [nextTypeaheadChar]);
    var comparatorShared = useStableCallback((safeLhs, safeRhs) => {
      var _safeRhs$toLowerCase;
      var compare;
      // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
      // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.
      safeLhs = safeLhs.normalize("NFD");
      safeRhs = safeRhs.normalize("NFD");
      if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
      return compare;
    });
    var insertingComparator = useStableCallback((lhs, rhs) => {
      if (typeof lhs === "string" && typeof rhs.text === "string") {
        return comparatorShared(lhs, rhs.text);
      }
      return lhs - rhs;
    });
    var typeaheadComparator = useStableCallback((lhs, rhs) => {
      if (typeof lhs === "string" && typeof rhs.text === "string") {
        // During typeahead, all strings longer than ours should be truncated
        // so that they're all considered equally by that point.
        return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
      }
      return lhs - rhs;
    });
    var isDisabled = useStableGetter(noTypeahead);
    var propsStable = _({
      onKeyDown: useStableCallback(e => {
        if (isDisabled()) return;
        var imeActive = getImeActive();
        var key = e.key;
        // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
        if (e.ctrlKey || e.metaKey) return;
        if (!imeActive && e.key === "Backspace") {
          // Remove the last character in a way that doesn't split UTF-16 surrogates.
          setCurrentTypeahead(t => t == null ? null : [...t].reverse().slice(1).reverse().join(""), e);
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        // The key property represents the typed character OR the "named key attribute" of the key pressed.
        // There's no definite way to tell the difference, but for all intents and purposes
        // there are no one-character names, and there are no non-ASCII-alpha names.
        // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.
        var isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);
        if (isCharacterKey) {
          var _getCurrentTypeahead;
          if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ;else {
            e.preventDefault();
            e.stopPropagation();
            // Note: Won't be true for the first keydown
            // but will be overwritten before useLayoutEffect is called
            // to actually apply the change
            if (!imeActive) setNextTypeaheadChar(key);
          }
        }
      }),
      onCompositionStart: useStableCallback(e => {
        setNextTypeaheadChar(e.data);
        setImeActive(false);
      }),
      onCompositionEnd: useStableCallback(_e => {
        setImeActive(true);
      })
    });
    // Handle changes in typeahead that cause changes to the tabbable index
    /* useEffect(() => {
         
     }, [currentTypeahead]);*/
    return {
      typeaheadNavigationChildContext: useStableObject({
        typeaheadNavigationChildParameters: useStableObject({
          insertingComparator,
          sortedTypeaheadInfo: sortedTypeaheadInfo.current
        })
      }),
      typeaheadNavigationReturn: {
        getCurrentTypeahead,
        invalidTypeahead,
        propsStable: propsStable.current
      }
    };
    function updateBasedOnTypeaheadChange(currentTypeahead, reason) {
      if (currentTypeahead && sortedTypeaheadInfo.current.length) {
        var sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);
        if (sortedTypeaheadIndex < 0) {
          // The user has typed an entry that doesn't exist in the list
          // (or more specifically "for which there is no entry that starts with that input")
          setInvalidTypeahead(true);
        } else {
          setInvalidTypeahead(false);
          /*
            We know roughly where, in the sorted array of strings, our next typeahead location is.
            But roughly isn't good enough if there are multiple matches.
            To convert our sorted index to the unsorted index we need, we have to find the first
            element that matches us *and* (if any such exist) is *after* our current selection.
                     In other words, the only way typeahead moves backwards relative to our current
            position is if the only other option is behind us.
                     It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
            Though there's also a case for just going upwards to the nearest to prevent jumpiness.
            But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
            I dunno. Going back to the start is the simplist though.
                     Basically what this does: Starting from where we found ourselves after our binary search,
            scan backwards and forwards through all adjacent entries that also compare equally so that
            we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
            (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
                     TODO: The binary search starts this off with a solid O(log n), but one-character
            searches are, thanks to pigeonhole principal, eventually guaranteed to become
            O(n*log n). This is annoying but probably not easily solvable? There could be an
            exception for one-character strings, but that's just kicking the can down
            the road. Maybe one or two characters would be good enough though.
          */
          // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.
          var lowestUnsortedIndexAll = null;
          var lowestSortedIndexAll = sortedTypeaheadIndex;
          // These two are only set for elements that are ahead of us, but the principle's the same otherwise
          var lowestUnsortedIndexNext = null;
          var lowestSortedIndexNext = sortedTypeaheadIndex;
          var updateBestFit = u => {
            var _getIndex;
            if (!isValid(u)) return;
            if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
              lowestUnsortedIndexAll = u;
              lowestSortedIndexAll = _i4;
            }
            if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > ((_getIndex = getIndex()) !== null && _getIndex !== void 0 ? _getIndex : -Infinity)) {
              lowestUnsortedIndexNext = u;
              lowestSortedIndexNext = _i4;
            }
          };
          var _i4 = sortedTypeaheadIndex;
          while (_i4 >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[_i4]) == 0) {
            updateBestFit(sortedTypeaheadInfo.current[_i4].unsortedIndex);
            --_i4;
          }
          _i4 = sortedTypeaheadIndex;
          while (_i4 < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[_i4]) == 0) {
            updateBestFit(sortedTypeaheadInfo.current[_i4].unsortedIndex);
            ++_i4;
          }
          if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex, reason, true);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex, reason, true);
        }
      }
    }
  }
  function useTypeaheadNavigationChild(_ref19) {
    var {
        managedChildParameters: {
          index
        },
        textContentParameters: {
          getText
        },
        typeaheadNavigationChildContext: {
          typeaheadNavigationChildParameters: {
            sortedTypeaheadInfo,
            insertingComparator
          }
        },
        refElementReturn: {
          getElement
        }
      } = _ref19,
      void1 = _objectWithoutProperties(_ref19.managedChildParameters, _excluded15),
      void5 = _objectWithoutProperties(_ref19.textContentParameters, _excluded16),
      void2 = _objectWithoutProperties(_ref19.typeaheadNavigationChildContext.typeaheadNavigationChildParameters, _excluded17),
      void3 = _objectWithoutProperties(_ref19.refElementReturn, _excluded18),
      void4 = _objectWithoutProperties(_ref19, _excluded19);
    var {
      textContentReturn
    } = useTextContent({
      refElementReturn: {
        getElement
      },
      textContentParameters: {
        getText,
        onTextContentChange: T$1(text => {
          if (text) {
            // Find where to insert this item.
            // Because all index values should be unique, the returned sortedIndex
            // should always refer to a new location (i.e. be negative)                
            var sortedIndex = binarySearch(sortedTypeaheadInfo, text, insertingComparator);
            console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo[sortedIndex].text, {
              unsortedIndex: index,
              text
            }) == 0);
            if (sortedIndex < 0) {
              sortedTypeaheadInfo.splice(-sortedIndex - 1, 0, {
                text,
                unsortedIndex: index
              });
            } else {
              sortedTypeaheadInfo.splice(sortedIndex, 0, {
                text,
                unsortedIndex: index
              });
            }
            return () => {
              // When unmounting, find where we were and remove ourselves.
              // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
              var sortedIndex = binarySearch(sortedTypeaheadInfo, text, insertingComparator);
              console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo[sortedIndex].text, {
                unsortedIndex: index,
                text
              }) == 0);
              if (sortedIndex >= 0) {
                sortedTypeaheadInfo.splice(sortedIndex, 1);
              }
            };
          }
        }, [])
      }
    });
    return {
      textContentReturn
    };
  }
  /**
   * Your usual binary search implementation.
   *
   * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
   * @param array The array to search through
   * @param wanted The value you'd like to find
   * @param comparator Compares `wanted` with the current value in `array`
   * @returns A non-negative value if `wanted` was found, and a negative number if not.
   * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
   */
  function binarySearch(array, wanted, comparator) {
    var firstIndex = 0;
    var lastIndex = array.length - 1;
    while (firstIndex <= lastIndex) {
      var testIndex = lastIndex + firstIndex >> 1;
      var comparisonResult = comparator(wanted, array[testIndex]);
      if (comparisonResult > 0) {
        firstIndex = testIndex + 1;
      } else if (comparisonResult < 0) {
        lastIndex = testIndex - 1;
      } else {
        return testIndex;
      }
    }
    return -firstIndex - 1;
  }

  /**
   * Implements a roving tabindex system where only one "focusable"
   * component in a set is able to receive a tab focus. *Which*
   * of those elements receives focus is determined by you, but it's
   * recommended to offload that logic then to another hook, like
   * `useLinearNavigation`, which lets you change the tabbable
   * element with the arrow keys, `useTypeaheadNavigation`, which
   * lets you change the tabbable index with typeahead, or
   * `useListNavigation` if you just want everything bundled together.
   *
   * Note that the child hook returned by this function must be used
   * by every child that uses this roving tabindex logic.  The
   * prop-modifying hook *that* hook returns should then be used
   * on the child's element, as well as any other elements you'd like
   * to be explicitly made untabbable too.
   *
   * `shouldFocusOnChange` should return true if focus is
   * contained within whatever element contains the roving tab index.
   * Generally as simple as the following:
   * ```
   * const [focusedInner, setFocusedInner] = useState(false);
   * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
   * const focusOnChange = (focusedInner != false);
   * ```
   * It's not included here because `useRovingTabIndex` doesn't know
   * anything about the container element, only children elements.
   * And just as well! Children should be allowed at the root,
   * regardless of if it's the whole app or just a given component.
   */
  function useRovingTabIndex(_ref20) {
    var {
        managedChildrenReturn: {
          getChildren
        },
        rovingTabIndexParameters: {
          untabbable,
          initiallyTabbedIndex,
          onTabbableIndexChange
        }
      } = _ref20,
      _void1 = _objectWithoutProperties(_ref20, _excluded20);
    //initiallyTabbedIndex ??= 0;
    // Override the actual setter to include some extra logic related to avoiding hidden children, 
    // what to do when we're untabbable, what to do when we're tabbable but given `null`, etc.
    var setTabbableIndex = useStableCallback((updater, reason, fromUserInteraction) => {
      var children = getChildren();
      // Notify the relevant children that they should become tabbable/untabbable,
      // but also handle focus management when we changed due to user interaction
      return setTabbableIndex3(f, reason);
      function f(prevIndex) {
        var nextIndex = typeof updater === "function" ? updater(prevIndex !== null && prevIndex !== void 0 ? prevIndex : null) : updater;
        if (untabbable) return null;
        if (prevIndex != nextIndex) {
          var nextChild = nextIndex == null ? null : children.getAt(nextIndex);
          if (nextChild !== null && nextChild !== void 0 && nextChild.hidden) {
            return prevIndex !== null && prevIndex !== void 0 ? prevIndex : untabbable ? null : 0;
          }
          if (nextChild != null && fromUserInteraction) {
            var element = nextChild.getElement();
            if (element) {
              if (document.activeElement == null || !element.contains(document.activeElement)) nextChild.focusSelf(element);
            }
          }
        }
        return nextIndex !== null && nextIndex !== void 0 ? nextIndex : untabbable ? null : 0;
      }
    }, []);
    var lastNonNullIndex = _(initiallyTabbedIndex);
    h(() => {
      var t = getTabbableIndex();
      if (t != null) lastNonNullIndex.current = t;
    });
    // Any time we switch to being untabbable, set the current tabbable index accordingly.
    h(() => {
      if (untabbable) setTabbableIndex3(null, undefined);else setTabbableIndex3(lastNonNullIndex.current, undefined);
    }, [untabbable]);
    // Boilerplate related to notifying individual children when they become tabbable/untabbable
    var getTabbableAt = T$1(m => {
      return m.getTabbable();
    }, []);
    var setTabbableAt = T$1((m, t) => {
      m.setTabbable(t);
    }, []);
    var isTabbableValid = T$1(m => {
      return !m.hidden;
    }, []);
    var {
      changeIndex: setTabbableIndex3,
      getCurrentIndex: getTabbableIndex,
      reevaluateClosestFit
    } = useChildrenFlag({
      initialIndex: initiallyTabbedIndex !== null && initiallyTabbedIndex !== void 0 ? initiallyTabbedIndex : untabbable ? null : 0,
      onIndexChange: onTabbableIndexChange,
      getChildren,
      closestFit: true,
      getAt: getTabbableAt,
      isValid: isTabbableValid,
      setAt: setTabbableAt
    });
    var focusSelf = T$1(reason => {
      var children = getChildren();
      var index = getTabbableIndex();
      if (index != null) {
        var _children$getAt, _children$getAt2, _children$getAt2$focu;
        var element = (_children$getAt = children.getAt(index)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.getElement();
        (_children$getAt2 = children.getAt(index)) === null || _children$getAt2 === void 0 ? void 0 : (_children$getAt2$focu = _children$getAt2.focusSelf) === null || _children$getAt2$focu === void 0 ? void 0 : _children$getAt2$focu.call(_children$getAt2, element);
      } else setTabbableIndex(null, reason, true);
    }, []);
    var rovingTabIndexChildContext = useStableObject({
      setTabbableIndex,
      reevaluateClosestFit
    });
    return {
      managedChildrenParameters: {
        onChildrenMountChange: reevaluateClosestFit
      },
      rovingTabIndexReturn: {
        setTabbableIndex,
        getTabbableIndex,
        focusSelf
      },
      rovingTabIndexChildContext
    };
  }
  function useRovingTabIndexChild(_ref21) {
    var {
        managedChildParameters: {
          index
        },
        rovingTabIndexChildContext: {
          reevaluateClosestFit,
          setTabbableIndex
        },
        rovingTabIndexChildParameters
      } = _ref21,
      _void2 = _objectWithoutProperties(_ref21.managedChildParameters, _excluded21);
    var {
        hidden
      } = rovingTabIndexChildParameters,
      _void1 = _objectWithoutProperties(rovingTabIndexChildParameters, _excluded22);
    var [tabbable, setTabbable, getTabbable] = useState(false);
    h(() => {
      reevaluateClosestFit();
    }, [!!hidden]);
    return {
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged: useStableCallback((focused, _prevFocused, e) => {
          if (focused) {
            setTabbableIndex(index, e, false);
          }
        })
      },
      rovingTabIndexChildReturn: {
        propsUnstable: {
          tabIndex: tabbable ? 0 : -1
        },
        tabbable,
        getTabbable,
        setTabbable
      }
    };
  }

  /**
   * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
   *
   * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
   * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any text for typeahead to focus the next item that matches.
   */
  function useListNavigation(_ref22) {
    var {
        linearNavigationParameters,
        typeaheadNavigationParameters,
        rovingTabIndexParameters,
        managedChildrenReturn
      } = _ref22,
      _void1 = _objectWithoutProperties(_ref22, _excluded23);
    var rtir = useRovingTabIndex({
      managedChildrenReturn,
      rovingTabIndexParameters
    });
    var {
      rovingTabIndexReturn
    } = rtir;
    var tnr = useTypeaheadNavigation({
      rovingTabIndexReturn,
      typeaheadNavigationParameters
    });
    var lnr = useLinearNavigation({
      rovingTabIndexReturn,
      linearNavigationParameters
    });
    return _objectSpread(_objectSpread(_objectSpread({}, lnr), tnr), rtir);
  }
  function useListNavigationChild(_ref23) {
    var {
        rovingTabIndexChildParameters,
        rovingTabIndexChildContext,
        typeaheadNavigationChildContext,
        //typeaheadNavigationChildParameters,
        managedChildParameters,
        refElementReturn,
        textContentParameters
      } = _ref23,
      _void2 = _objectWithoutProperties(_ref23, _excluded24);
    var rticr = useRovingTabIndexChild({
      rovingTabIndexChildContext,
      rovingTabIndexChildParameters,
      managedChildParameters
    });
    var {
      textContentReturn
    } = useTypeaheadNavigationChild({
      refElementReturn,
      typeaheadNavigationChildContext,
      managedChildParameters,
      textContentParameters
    });
    //    assertEmptyObject(_void5);
    return _objectSpread({
      textContentReturn
    }, rticr);
  }
  function useGridNavigation(_ref24) {
    var {
        gridNavigationParameters: {
          onTabbableColumnChange
        },
        linearNavigationParameters,
        rovingTabIndexParameters: {
          onTabbableIndexChange
        },
        managedChildrenReturn,
        typeaheadNavigationParameters
      } = _ref24,
      void3 = _objectWithoutProperties(_ref24.gridNavigationParameters, _excluded25),
      rovingTabIndexParameters = _objectWithoutProperties(_ref24.rovingTabIndexParameters, _excluded26),
      _void2 = _objectWithoutProperties(_ref24, _excluded27);
    var {
      getChildren
    } = managedChildrenReturn;
    var {
      initiallyTabbedIndex
    } = rovingTabIndexParameters;
    var [getCurrentTabbableColumn, setCurrentTabbableColumn] = usePassiveState(onTabbableColumnChange, useStableCallback(() => {
      return initiallyTabbedIndex !== null && initiallyTabbedIndex !== void 0 ? initiallyTabbedIndex : 0;
    }));
    var onTabbableIndexChangeOverride = useStableCallback((i, p, reason) => {
      var _children$getAt3, _children$getAt4;
      var children = getChildren();
      onTabbableIndexChange === null || onTabbableIndexChange === void 0 ? void 0 : onTabbableIndexChange(i, p, reason);
      if (p != null) (_children$getAt3 = children.getAt(p)) === null || _children$getAt3 === void 0 ? void 0 : _children$getAt3.setTabbableColumnIndex(null, reason, false);
      if (i != null) (_children$getAt4 = children.getAt(i)) === null || _children$getAt4 === void 0 ? void 0 : _children$getAt4.setTabbableColumnIndex(getCurrentTabbableColumn(), reason, false);
    });
    var _useListNavigation = useListNavigation({
        linearNavigationParameters: _objectSpread({
          navigationDirection: "vertical"
        }, linearNavigationParameters),
        rovingTabIndexParameters: _objectSpread({
          onTabbableIndexChange: onTabbableIndexChangeOverride
        }, rovingTabIndexParameters),
        managedChildrenReturn,
        typeaheadNavigationParameters
      }),
      {
        linearNavigationReturn,
        rovingTabIndexReturn,
        typeaheadNavigationReturn,
        managedChildrenParameters,
        rovingTabIndexChildContext,
        typeaheadNavigationChildContext
      } = _useListNavigation,
      void1 = _objectWithoutProperties(_useListNavigation, _excluded28);
    return {
      managedChildrenParameters,
      rovingTabIndexChildContext,
      typeaheadNavigationChildContext,
      linearNavigationReturn,
      rovingTabIndexReturn,
      typeaheadNavigationReturn,
      gridNavigationRowContext: useStableObject({
        gridNavigationRowParameters: useStableObject({
          setTabbableRow: rovingTabIndexReturn.setTabbableIndex,
          getCurrentTabbableColumn,
          setCurrentTabbableColumn
        })
      })
    };
  }
  function useGridNavigationRow(_ref25) {
    var {
        rowAsChildOfGridParameters: {
          gridNavigationRowContext: {
            gridNavigationRowParameters: {
              setTabbableRow,
              getCurrentTabbableColumn,
              setCurrentTabbableColumn
            }
          }
        },
        rowAsParentOfCellsParameters: {
          linearNavigationParameters,
          rovingTabIndexParameters: {
            untabbable
          }
        }
      } = _ref25,
      asChildRowOfTable = _objectWithoutProperties(_ref25.rowAsChildOfGridParameters, _excluded29),
      rovingTabIndexParameters = _objectWithoutProperties(_ref25.rowAsParentOfCellsParameters.rovingTabIndexParameters, _excluded30),
      asParentRowOfCellsP = _objectWithoutProperties(_ref25.rowAsParentOfCellsParameters, _excluded31),
      _void1 = _objectWithoutProperties(_ref25, _excluded32);
    var {
      managedChildrenReturn: {
        getChildren
      }
    } = asChildRowOfTable;
    var getIndex = useStableCallback(() => {
      return asChildRowOfTable.managedChildParameters.index;
    });
    var focusSelf = useStableCallback(e => {
      var _getCurrentTabbableCo;
      var index = (_getCurrentTabbableCo = getCurrentTabbableColumn()) !== null && _getCurrentTabbableCo !== void 0 ? _getCurrentTabbableCo : 0;
      var child = getChildren().getAt(index);
      while (!child && index > 0) {
        --index;
        child = getChildren().getAt(index);
      }
      if (child) {
        var _e2 = child.getElement();
        child.focusSelf(_e2);
      } else {
        var _e$focus;
        e === null || e === void 0 ? void 0 : (_e$focus = e.focus) === null || _e$focus === void 0 ? void 0 : _e$focus.call(e);
      }
    }, []);
    var lncr = useListNavigationChild(asChildRowOfTable);
    var lnr = useListNavigation(_objectSpread(_objectSpread({}, asParentRowOfCellsP), {}, {
      rovingTabIndexParameters: _objectSpread({
        untabbable: untabbable || !lncr.rovingTabIndexChildReturn.tabbable
      }, rovingTabIndexParameters),
      linearNavigationParameters: _objectSpread({
        navigationDirection: "horizontal"
      }, linearNavigationParameters)
    }));
    var {
      rovingTabIndexReturn: {
        setTabbableIndex
      },
      rovingTabIndexReturn,
      linearNavigationReturn,
      managedChildrenParameters,
      rovingTabIndexChildContext,
      typeaheadNavigationChildContext,
      typeaheadNavigationReturn
    } = lnr;
    return {
      rowAsChildOfGridReturn: _objectSpread({
        gridNavigationRowParameters: {
          focusSelf,
          setTabbableColumnIndex: setTabbableIndex
        }
      }, lncr),
      rowAsParentOfCellsReturn: _objectSpread(_objectSpread({}, lnr), {}, {
        gridNavigationCellContext: useStableObject({
          gridNavigationCellParameters: useStableObject({
            setTabbableRow,
            getRowIndex: getIndex,
            getCurrentTabbableColumn,
            setCurrentTabbableColumn,
            setTabbableCell: setTabbableIndex
          })
        }),
        linearNavigationReturn,
        managedChildrenParameters,
        rovingTabIndexChildContext,
        rovingTabIndexReturn,
        typeaheadNavigationChildContext,
        typeaheadNavigationReturn
      })
    };
  }
  function useGridNavigationCell(_ref26) {
    var {
        //    managedChildParameters: { hidden, index, ...void3 },
        rovingTabIndexChildContext,
        typeaheadNavigationChildContext,
        //typeaheadNavigationChildParameters,
        rovingTabIndexChildParameters,
        managedChildParameters,
        refElementReturn,
        textContentParameters,
        gridNavigationCellParameters: {
          colSpan
        },
        gridNavigationCellContext: {
          gridNavigationCellParameters: {
            getRowIndex,
            setTabbableRow,
            getCurrentTabbableColumn: _getCurrentColumn,
            setCurrentTabbableColumn,
            setTabbableCell
          }
        }
      } = _ref26,
      _void1 = _objectWithoutProperties(_ref26, _excluded33);
    var {
      index
    } = managedChildParameters;
    var _useListNavigationChi = useListNavigationChild({
        rovingTabIndexChildParameters,
        managedChildParameters,
        rovingTabIndexChildContext,
        typeaheadNavigationChildContext,
        textContentParameters,
        //typeaheadNavigationChildParameters,
        refElementReturn
      }),
      {
        hasCurrentFocusParameters: {
          onCurrentFocusedInnerChanged: ocfic1
        },
        rovingTabIndexChildReturn,
        textContentReturn
      } = _useListNavigationChi,
      void2 = _objectWithoutProperties(_useListNavigationChi, _excluded34);
    //    assertEmptyObject(void3);
    return {
      rovingTabIndexChildReturn,
      textContentReturn,
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged: useStableCallback((focused, prev, e) => {
          ocfic1 === null || ocfic1 === void 0 ? void 0 : ocfic1(focused, prev, e);
          if (focused) {
            setTabbableRow(getRowIndex(), e, false);
            setCurrentTabbableColumn(index, e);
            setTabbableCell(prev => {
              if (prev != null && (prev < index || prev > index + colSpan)) {
                return prev;
              }
              return index;
            }, e, false);
          }
        })
      }
    };
  }

  //export type UseSingleSelectionChild<E extends Element> = (a: UseSingleSelectionChildParameters<E>) => UseSingleSelectionChildReturnTypeWithHooks<E>;
  function useSingleSelection(_ref27) {
    var {
      managedChildrenReturn: {
        getChildren
      },
      rovingTabIndexReturn: {
        setTabbableIndex
      },
      singleSelectionParameters: {
        setSelectedIndex: setSelectedIndexExternal,
        initiallySelectedIndex
      }
    } = _ref27;
    useEnsureStability("useSingleSelection", setSelectedIndexExternal);
    var getSelectedAt = T$1(m => {
      return m.getSelected();
    }, []);
    var setSelectedAt = T$1((m, t) => {
      if (m.hidden) {
        console.assert(false);
      }
      m.setLocalSelected(t);
    }, []);
    var isSelectedValid = T$1(m => {
      return !m.hidden;
    }, []);
    var {
      changeIndex: setSelectedIndexInternal,
      getCurrentIndex: getSelectedIndex
    } = useChildrenFlag({
      getChildren,
      onIndexChange: null,
      initialIndex: initiallySelectedIndex,
      getAt: getSelectedAt,
      setAt: setSelectedAt,
      isValid: isSelectedValid,
      closestFit: false
    });
    return {
      singleSelectionReturn: useStableObject({
        getSelectedIndex,
        setSelectedIndex: setSelectedIndexInternal
      }),
      singleSelectionContext: useStableObject({
        getSelectedIndex,
        setSelectedIndex: setSelectedIndexExternal
      }),
      childrenHaveFocusParameters: {
        onCompositeFocusChange: useStableCallback((anyFocused, prev, reason) => {
          if (!anyFocused) {
            var selectedIndex = getSelectedIndex();
            if (selectedIndex != null) setTabbableIndex(selectedIndex, reason, false);
          }
        })
      }
    };
  }
  function useSingleSelectionChild(args) {
    var {
      singleSelectionContext: {
        getSelectedIndex,
        setSelectedIndex: setSelectedIndexExternal
      },
      singleSelectionChildParameters: {
        ariaPropName,
        selectionMode,
        disabled
      },
      managedChildParameters: {
        index
      }
    } = args;
    useEnsureStability("useSingleSelectionChild", getSelectedIndex, setSelectedIndexExternal);
    var getDisabled = useStableGetter(disabled);
    var [selected, setSelected, getSelected] = useState(getSelectedIndex() == index);
    // const getIndex = useStableGetter(index);
    var onCurrentFocusedInnerChanged = useStableCallback((focused, _prev, e) => {
      if (selectionMode == 'focus' && focused) {
        setSelectedIndexExternal === null || setSelectedIndexExternal === void 0 ? void 0 : setSelectedIndexExternal(index, e);
      }
    });
    var onPressSync = useStableCallback(e => {
      if (!disabled) setSelectedIndexExternal === null || setSelectedIndexExternal === void 0 ? void 0 : setSelectedIndexExternal(index, e);
    });
    return {
      //managedChildParameters: { selected, setSelected, getSelected, },
      managedChildParameters: {
        setLocalSelected: setSelected
      },
      singleSelectionChildReturn: {
        selected,
        setThisOneSelected: useStableCallback(event => {
          console.assert(!getDisabled());
          setSelectedIndexExternal === null || setSelectedIndexExternal === void 0 ? void 0 : setSelectedIndexExternal(index, event);
        }),
        getSelected,
        propsUnstable: ariaPropName == null ? {} : {
          [ariaPropName]: (selected !== null && selected !== void 0 ? selected : false).toString()
        }
      },
      pressParameters: {
        onPressSync
      },
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged
      }
    };
  }
  /**
   * Let's face it, declarative is nicer to use than imperative, so this is a shortcut.
   */
  function useSingleSelectionDeclarative(_ref28) {
    var {
      singleSelectionReturn: {
        setSelectedIndex: setSelectedIndexInternal
      },
      singleSelectionDeclarativeParameters: {
        selectedIndex
      }
    } = _ref28;
    h(() => {
      setSelectedIndexInternal(selectedIndex);
    }, [selectedIndex]);
  }
  function useGridNavigationSingleSelection(_ref29) {
    var {
        gridNavigationParameters,
        linearNavigationParameters,
        rovingTabIndexParameters,
        managedChildrenReturn,
        typeaheadNavigationParameters,
        singleSelectionParameters
      } = _ref29,
      _void2 = _objectWithoutProperties(_ref29, _excluded35);
    var gnr = useGridNavigation({
      gridNavigationParameters,
      linearNavigationParameters,
      managedChildrenReturn,
      rovingTabIndexParameters,
      typeaheadNavigationParameters
    });
    var {
      rovingTabIndexReturn
    } = gnr;
    var ssr = useSingleSelection({
      managedChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionParameters
    });
    return _objectSpread(_objectSpread({}, gnr), ssr);
  }
  function useGridNavigationSingleSelectionRow(_ref30) {
    var {
        rowAsChildOfGridParameters,
        rowAsParentOfCellsParameters
      } = _ref30,
      _void1 = _objectWithoutProperties(_ref30, _excluded36);
    var _useSingleSelectionCh = useSingleSelectionChild(rowAsChildOfGridParameters),
      {
        managedChildParameters,
        hasCurrentFocusParameters: {
          onCurrentFocusedInnerChanged: ocfic2
        },
        pressParameters,
        singleSelectionChildReturn
      } = _useSingleSelectionCh,
      _void3 = _objectWithoutProperties(_useSingleSelectionCh.hasCurrentFocusParameters, _excluded37);
    var _useGridNavigationRow = useGridNavigationRow({
        rowAsChildOfGridParameters,
        rowAsParentOfCellsParameters
      }),
      {
        rowAsChildOfGridReturn: {
          hasCurrentFocusParameters: {
            onCurrentFocusedInnerChanged: ocfic1
          },
          gridNavigationRowParameters,
          rovingTabIndexChildReturn,
          textContentReturn
        },
        rowAsParentOfCellsReturn
      } = _useGridNavigationRow,
      _void2 = _objectWithoutProperties(_useGridNavigationRow.rowAsChildOfGridReturn.hasCurrentFocusParameters, _excluded39),
      void4 = _objectWithoutProperties(_useGridNavigationRow.rowAsChildOfGridReturn, _excluded38);
    var onCurrentFocusedInnerChanged = useStableCallback((focused, prevFocused, e) => {
      ocfic1 === null || ocfic1 === void 0 ? void 0 : ocfic1(focused, prevFocused, e);
      ocfic2 === null || ocfic2 === void 0 ? void 0 : ocfic2(focused, prevFocused, e);
    });
    return {
      rowAsChildOfGridReturn: {
        textContentReturn,
        managedChildParameters,
        hasCurrentFocusParameters: {
          onCurrentFocusedInnerChanged
        },
        gridNavigationRowParameters,
        pressParameters,
        rovingTabIndexChildReturn,
        singleSelectionChildReturn
      },
      rowAsParentOfCellsReturn
    };
  }
  // EZ
  function useGridNavigationSingleSelectionCell(p) {
    return useGridNavigationCell(p);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
      length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeFloor = Math.floor,
    nativeRandom = Math.random;

  /**
   * The base implementation of `_.random` without support for returning
   * floating-point numbers.
   *
   * @private
   * @param {number} lower The lower bound.
   * @param {number} upper The upper bound.
   * @returns {number} Returns the random number.
   */
  function baseRandom(lower, upper) {
    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
  }

  /**
   * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
   *
   * @private
   * @param {Array} array The array to shuffle.
   * @param {number} [size=array.length] The size of `array`.
   * @returns {Array} Returns `array`.
   */
  function shuffleSelf(array, size) {
    var index = -1,
      length = array.length,
      lastIndex = length - 1;
    size = size === undefined ? length : size;
    while (++index < size) {
      var rand = baseRandom(index, lastIndex),
        value = array[rand];
      array[rand] = array[index];
      array[index] = value;
    }
    array.length = size;
    return array;
  }

  /**
   * A specialized version of `_.shuffle` for arrays.
   *
   * @private
   * @param {Array} array The array to shuffle.
   * @returns {Array} Returns the new shuffled array.
   */
  function arrayShuffle(array) {
    return shuffleSelf(copyArray(array));
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function (key) {
      return object[key];
    });
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
      result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Built-in value references. */
  var Symbol$1 = root.Symbol;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$5.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$4.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$1;
  }

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function () {
    return arguments;
  }()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /** Detect free variable `exports`. */
  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

  /** Built-in value references. */
  var Buffer = moduleExports$1 ? root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = function () {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;
      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && (
      // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' ||
      // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == 'offset' || key == 'parent') ||
      // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
      // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$1;
    return value === proto;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = overArg(Object.keys, Object);

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */
  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }

  /**
   * The base implementation of `_.shuffle`.
   *
   * @private
   * @param {Array|Object} collection The collection to shuffle.
   * @returns {Array} Returns the new shuffled array.
   */
  function baseShuffle(collection) {
    return shuffleSelf(values(collection));
  }

  /**
   * Creates an array of shuffled values, using a version of the
   * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to shuffle.
   * @returns {Array} Returns the new shuffled array.
   * @example
   *
   * _.shuffle([1, 2, 3, 4]);
   * // => [4, 1, 3, 2]
   */
  function shuffle(collection) {
    var func = isArray(collection) ? arrayShuffle : baseShuffle;
    return func(collection);
  }

  /**
   * Returns a function that will, when called, force the component
   * that uses this hook to re-render itself.
   *
   * It's a bit smelly, so best to use sparingly.
   */
  function useForceUpdate() {
    var [, set] = p(0);
    return _(() => set(i => ++i)).current;
  }

  /**
   * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
   *
   * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
   *
   * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
   * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
   * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
   *
   * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
   * sort all children according to their value from the `getValue` argument you pass in.
   *
   * If you want to perform some re-ordering operation that's *not* a sort, you can manually
   * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
   * sorted and unsorted index positions.
   *
   * Again, unlike some other hooks, **these children must be direct descendants**. This is because
   * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
   * Because keys are given special treatment and a child has no way of modifying its own key
   * there's no other time or place this can happen other than exactly within the parent component's render function.
   */
  function useRearrangeableChildren(_ref31) {
    var {
      rearrangeableChildrenParameters: {
        getIndex
      }
    } = _ref31;
    // These are used to keep track of a mapping between unsorted index <---> sorted index.
    // These are needed for navigation with the arrow keys.
    var mangleMap = _(new Map());
    var demangleMap = _(new Map());
    var indexMangler = T$1(n => {
      var _mangleMap$current$ge;
      return (_mangleMap$current$ge = mangleMap.current.get(n)) !== null && _mangleMap$current$ge !== void 0 ? _mangleMap$current$ge : n;
    }, []);
    var indexDemangler = T$1(n => {
      var _demangleMap$current$;
      return (_demangleMap$current$ = demangleMap.current.get(n)) !== null && _demangleMap$current$ !== void 0 ? _demangleMap$current$ : n;
    }, []);
    //const { setTabbableIndex } = rovingTabIndexReturn;
    var shuffle$1 = T$1(managedRows => {
      var shuffledRows = shuffle(managedRows.arraySlice());
      return rearrange(shuffledRows);
    }, [/* Must remain stable */]);
    // The sort function needs to be able to update whoever has all the sortable children.
    // Because that might not be the consumer of *this* hook directly (e.g. a table uses
    // this hook, but it's tbody that actually needs updating), we need to remotely
    // get and set a forceUpdate function.
    //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);
    var [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
    var rearrange = T$1(sortedRows => {
      var _getForceUpdate;
      mangleMap.current.clear();
      demangleMap.current.clear();
      // Update our sorted <--> unsorted indices map 
      // and rerender the whole table, basically
      for (var indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
        var indexAsUnsorted = sortedRows[indexAsSorted].index;
        mangleMap.current.set(indexAsUnsorted, indexAsSorted);
        demangleMap.current.set(indexAsSorted, indexAsUnsorted);
      }
      (_getForceUpdate = getForceUpdate()) === null || _getForceUpdate === void 0 ? void 0 : _getForceUpdate();
    }, []);
    var useRearrangedChildren = T$1(children => {
      console.assert(Array.isArray(children));
      var forceUpdate = useForceUpdate();
      s(() => {
        setForceUpdate(_prev => forceUpdate);
      }, [forceUpdate]);
      return children.slice().map(child => ({
        child,
        mangledIndex: indexMangler(getIndex(child)),
        demangledIndex: getIndex(child)
      })).sort((lhs, rhs) => {
        return lhs.mangledIndex - rhs.mangledIndex;
      }).map(_ref32 => {
        var {
          child,
          mangledIndex,
          demangledIndex
        } = _ref32;
        return h$1(child.type, _objectSpread(_objectSpread({}, child.props), {}, {
          key: demangledIndex,
          "data-mangled-index": mangledIndex,
          "data-unmangled-index": demangledIndex
        }));
      });
    }, []);
    return {
      //linearNavigationParameters: { navigateAbsolute, navigateRelative },
      rearrangeableChildrenReturn: {
        indexMangler,
        indexDemangler,
        mangleMap,
        demangleMap,
        rearrange,
        shuffle: shuffle$1,
        useRearrangedChildren
      }
    };
  }
  /**
   * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
   *
   * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
   *
   * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
   * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
   * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
   *
   * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
   * sort all children according to their value from the `getValue` argument you pass in.
   *
   * If you want to perform some re-ordering operation that's *not* a sort, you can manually
   * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
   * sorted and unsorted index positions.
   *
   * Again, unlike some other hooks, **these children must be direct descendants**. This is because
   * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
   * Because keys are given special treatment and a child has no way of modifying its own key
   * there's no other time or place this can happen other than exactly within the parent component's render function.
   */
  function useSortableChildren(_ref33) {
    var {
      rearrangeableChildrenParameters,
      sortableChildrenParameters: {
        compare: userCompare
      }
    } = _ref33;
    var getCompare = useStableGetter(userCompare !== null && userCompare !== void 0 ? userCompare : defaultCompare);
    var {
      rearrangeableChildrenReturn
    } = useRearrangeableChildren({
      rearrangeableChildrenParameters
    });
    var {
      rearrange
    } = rearrangeableChildrenReturn;
    // The actual sort function.
    var sort = T$1((managedRows, direction) => {
      var compare = getCompare();
      var sortedRows = compare ? managedRows.arraySlice().sort((lhsRow, rhsRow) => {
        var lhsValue = lhsRow;
        var rhsValue = rhsRow;
        var result = compare(lhsValue, rhsValue);
        if (direction[0] == "d") return -result;
        return result;
      }) : managedRows.arraySlice();
      return rearrange(sortedRows);
    }, [/* Must remain stable */]);
    return {
      sortableChildrenReturn: {
        sort
      },
      rearrangeableChildrenReturn
    };
  }
  /*export interface UseGroupedSortableChildrenParameters<M extends GroupedSortedChildInfo> {
      managedChildrenReturn: UseManagedChildrenReturnType<M>["managedChildrenReturn"]
  }
   export interface UseGroupedSortableChildren {
      linearNavigationParameters: Pick<UseLinearNavigationParameters["linearNavigationParameters"], "indexDemangler" | "indexMangler">
  }*/
  /**
   * It's common enough to have, e.g., a list with multiple sortable groups, a table where the body is sorted independently of the head, etc...
   *
   * A sortable group assumes that the parent (which also calls this hook) handles list navigation (or similar),
   * and that each group element (which can also be the list parent, if there are NO groups) handles sorting (or similar).
   */
  /*export function useGroupedSortableChildren<M extends GroupedSortedChildInfo>({ managedChildrenReturn: { getChildren } }: UseGroupedSortableChildrenParameters<M>): UseGroupedSortableChildren {
      const allIndexManglers = useRef<Map<number, (i: number) => number>>(new Map());
      const allIndexDemanglers = useRef<Map<number, (i: number) => number>>(new Map());
      const indexMangler = useCallback((i: number): number => {
          const child = getChildren().getAt(i);
          if (child) {
              let indexManglerForThisLocation = allIndexManglers.current.get(child.locationIndex);
              return (indexManglerForThisLocation ?? identity)(i);
          }
          return identity(i);
      }, []);
      const indexDemangler = useCallback((i: number): number => {
          const child = getChildren().getAt(i);
          if (child) {
              let indexDemanglerForThisLocation = allIndexDemanglers.current.get(child.locationIndex);
              return (indexDemanglerForThisLocation ?? identity)(i);
          }
          return identity(i);
      }, []);
        return {
          linearNavigationParameters: {
              indexMangler,
              indexDemangler
          }
      }
  }*/
  function defaultCompare(lhs, rhs) {
    return compare1(lhs === null || lhs === void 0 ? void 0 : lhs.getSortValue(), rhs === null || rhs === void 0 ? void 0 : rhs.getSortValue());
    function compare1(lhs, rhs) {
      if (lhs == null || rhs == null) {
        if (lhs == null) return -1;
        if (rhs == null) return 1;
      }
      return lhs - rhs;
    }
  }
  function useGridNavigationSingleSelectionSortable(_ref34) {
    var {
        rearrangeableChildrenParameters,
        sortableChildrenParameters,
        linearNavigationParameters
      } = _ref34,
      gridNavigationSingleSelectionParameters = _objectWithoutProperties(_ref34, _excluded40);
    var _useSortableChildren = useSortableChildren({
        rearrangeableChildrenParameters,
        sortableChildrenParameters
      }),
      scr = _extends({}, (_objectDestructuringEmpty(_useSortableChildren), _useSortableChildren));
    var {
      rearrangeableChildrenReturn: {
        indexDemangler,
        indexMangler
      }
    } = scr;
    var gnr = useGridNavigationSingleSelection(_objectSpread({
      linearNavigationParameters: _objectSpread({
        indexDemangler,
        indexMangler
      }, linearNavigationParameters)
    }, gridNavigationSingleSelectionParameters));
    return _objectSpread(_objectSpread({}, gnr), scr);
  }
  function useListNavigationSingleSelection(_ref35) {
    var {
        linearNavigationParameters,
        rovingTabIndexParameters,
        typeaheadNavigationParameters,
        singleSelectionParameters,
        managedChildrenReturn
      } = _ref35,
      _void3 = _objectWithoutProperties(_ref35, _excluded41);
    var lnr = useListNavigation({
      linearNavigationParameters,
      rovingTabIndexParameters,
      typeaheadNavigationParameters,
      managedChildrenReturn
    });
    var {
      rovingTabIndexReturn
    } = lnr;
    var ssr = useSingleSelection({
      rovingTabIndexReturn,
      managedChildrenReturn,
      singleSelectionParameters
    });
    return _objectSpread(_objectSpread({}, ssr), lnr);
  }
  function useListNavigationSingleSelectionChild(_ref36) {
    var {
        managedChildParameters: {
          index
        },
        rovingTabIndexChildParameters: {
          hidden
        },
        singleSelectionChildParameters,
        singleSelectionContext,
        rovingTabIndexChildContext,
        typeaheadNavigationChildContext,
        refElementReturn,
        textContentParameters
      } = _ref36,
      _void5 = _objectWithoutProperties(_ref36.managedChildParameters, _excluded42),
      void7 = _objectWithoutProperties(_ref36.rovingTabIndexChildParameters, _excluded43),
      _void1 = _objectWithoutProperties(_ref36, _excluded44);
    var _useSingleSelectionCh2 = useSingleSelectionChild({
        managedChildParameters: {
          index
        },
        singleSelectionChildParameters,
        singleSelectionContext
      }),
      {
        hasCurrentFocusParameters: {
          onCurrentFocusedInnerChanged: ocfic2
        }
      } = _useSingleSelectionCh2,
      _void3 = _objectWithoutProperties(_useSingleSelectionCh2.hasCurrentFocusParameters, _excluded46),
      sscr = _objectWithoutProperties(_useSingleSelectionCh2, _excluded45);
    var _useListNavigationChi2 = useListNavigationChild({
        managedChildParameters: {
          index
        },
        rovingTabIndexChildParameters: {
          hidden
        },
        rovingTabIndexChildContext,
        typeaheadNavigationChildContext,
        refElementReturn,
        textContentParameters
      }),
      {
        hasCurrentFocusParameters: {
          onCurrentFocusedInnerChanged: ocfic1
        }
      } = _useListNavigationChi2,
      _void6 = _objectWithoutProperties(_useListNavigationChi2.hasCurrentFocusParameters, _excluded48),
      lncr = _objectWithoutProperties(_useListNavigationChi2, _excluded47);
    return _objectSpread(_objectSpread({
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged: useStableCallback((focused, previouslyFocused, e) => {
          ocfic1 === null || ocfic1 === void 0 ? void 0 : ocfic1(focused, previouslyFocused, e);
          ocfic2 === null || ocfic2 === void 0 ? void 0 : ocfic2(focused, previouslyFocused, e);
        })
      }
    }, sscr), lncr);
  }

  /**
   * Allows a composite component (such as a radio group or listbox) to listen
   * for an "overall focusin/out" event; this hook lets you know when focus has
   * moved in/out of this grouping of children EVEN IF there is no actual parent DOM element.
   *
   * I.E. you can use this without needing a parent `<div>` to listen for a `focusout` event.
   */
  function useChildrenHaveFocus(args) {
    var {
      childrenHaveFocusParameters: {
        onCompositeFocusChange
      }
    } = args;
    var [getAnyFocused, setAnyFocused] = usePassiveState(onCompositeFocusChange, returnFalse, runImmediately);
    var [_getFocusCount, setFocusCount] = usePassiveState(useStableCallback((anyFocused, anyPreviouslyFocused, e) => {
      console.assert(anyFocused >= 0 && anyFocused <= 1);
      setAnyFocused(!!(anyFocused && !anyPreviouslyFocused), e);
    }));
    return {
      childrenHaveFocusReturn: {
        getAnyFocused
      },
      childrenHaveFocusChildContext: useStableObject({
        childrenHaveFocusChildParameters: useStableObject({
          setFocusCount
        })
      })
    };
  }
  function useChildrenHaveFocusChild(_ref37) {
    var {
      childrenHaveFocusChildContext: {
        childrenHaveFocusChildParameters: {
          setFocusCount
        }
      }
    } = _ref37;
    return {
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged: useStableCallback((focused, prev, e) => {
          if (focused) {
            setFocusCount(p => (p !== null && p !== void 0 ? p : 0) + 1, e);
          } else if (!focused && prev) {
            setFocusCount(p => (p !== null && p !== void 0 ? p : 0) - 1, e);
          }
        })
      }
    };
  }
  function useHasCurrentFocus(args) {
    var {
      hasCurrentFocusParameters: {
        onCurrentFocusedChanged: onFocusedChanged,
        onCurrentFocusedInnerChanged: onFocusedInnerChanged
      },
      refElementReturn: {
        getElement
      }
    } = args;
    useEnsureStability("useHasCurrentFocus", onFocusedChanged, onFocusedInnerChanged, getElement);
    var [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse);
    var [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse);
    var onFocusIn = T$1(e => {
      setFocusedInner(true, e);
      setFocused(e.target == getElement(), e);
    }, []);
    var onFocusOut = T$1(e => {
      if (e.target == getElement()) {
        setFocusedInner(false, e);
        setFocused(false, e);
      }
    }, []);
    var propsStable = _({
      onfocusin: onFocusIn,
      onfocusout: onFocusOut
    });
    h(() => {
      return () => {
        setFocused(false);
        setFocusedInner(false);
      };
    }, []);
    return {
      hasCurrentFocusReturn: {
        propsStable: propsStable.current,
        getCurrentFocused: getFocused,
        getCurrentFocusedInner: getFocusedInner
      }
    };
  }

  /**
   * Adds the necessary event handlers to create a "press"-like event for
   * any element, whether it's a native <BUTTON> or regular <DIV>.
   *
   * Notably, the following cases are covered:
   * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
   * * Double-clicks won't select text.
   * * Conversely, manually selecting text won't invoke a press.
   * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
   * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
   *
   * In addition, when the CSS `:active` pseudo-class would apply to a normal button
   * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
   * is added to the props.  You can either let it pass through and style it through new CSS,
   * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
   *
   * @param onClickSync
   * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
   */
  function usePress(args) {
    var {
      refElementReturn: {
        getElement
      },
      pressParameters: {
        exclude,
        focusSelf,
        onPressSync
      }
    } = args;
    //const stableOnPseudoActiveStart = useStableCallback(onPseudoActiveStart ?? (() => { }));
    //const stableOnPseudoActiveStop = useStableCallback(onPseudoActiveStop ?? (() => { }));
    // A button can be activated in multiple ways, so on the off chance
    // that multiple are triggered at once, we only *actually* register
    // a press once all of our "on" signals have turned back to "off".
    // We approximate this by just incrementing when active, and
    // decrementing when deactivated.
    //
    // As an emergency failsafe, when the element loses focus,
    // this is reset back to 0.
    var [activeDuringRender, setActive, getActive] = useState(0);
    var forceUpdate = useForceUpdate();
    //const { getElement } = refElementReturn;
    // If we the current text selection changes to include this element
    // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
    // because its only purpose was selecting text, not clicking buttons.
    //
    // To catch this, any time the text selection includes us while in the middle
    // of a click, this flag is set, which cancels the activation of a press.
    // The flag is reset any time the selection is empty or the button is
    // no longer active.
    var [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
    var pseudoActive = activeDuringRender && textSelectedDuringActivationStartTime == null;
    //useEffect(() => { if (pseudoActive) { stableOnPseudoActiveStart(); } else { stableOnPseudoActiveStop(); } return () => { if (pseudoActive) stableOnPseudoActiveStop(); } }, [pseudoActive])
    useGlobalHandler(document, "selectionchange", _ => {
      setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
    });
    h(() => {
      if (activeDuringRender == 0) setTextSelectedDuringActivationStartTime(null);
    }, [activeDuringRender == 0]);
    var onActiveStart = useStableCallback(_ => {
      setActive(a => ++a);
    });
    var onActiveStop = useStableCallback(e => {
      setActive(a => Math.max(0, --a));
      var currentTime = new Date();
      var timeDifference = textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime;
      var charactersSelected = nodeSelectedTextLength(getElement());
      // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
      // then this isn't a press event.
      // TODO: This should measure glyphs instead of characters.
      if (charactersSelected > 1 || (timeDifference !== null && timeDifference !== void 0 ? timeDifference : 0) > 250 && charactersSelected >= 1) {
        e.preventDefault();
        return;
      }
      var active = getActive(); // We query if we're active *after* calling setState because we count a press iff we're now at 0.
      if (active <= 0) {
        handlePress(e);
        forceUpdate(); // TODO: Remove when issue resolved https://github.com/preactjs/preact/issues/3731
      }
    });

    var handlePress = useStableCallback(e => {
      if (onPressSync) {
        // Note: The element is focused here because of iOS Safari.
        //
        // It's always iOS Safari.
        //
        // iOS Safari (tested on 12) downright refuses to allow 
        // elements to be manually focused UNLESS it happens within
        // an event handler like this.  It also doesn't focus
        // buttons by default when clicked, tapped, etc.
        //
        // If it becomes problematic that button-likes explicitly become
        // focused when they are pressed, then an alternative solution for
        // the question of "how do menu buttons keep their menus open"
        // and other focus-related nonsense needs to be figured out.
        //
        // For iOS Safari.
        //
        var element = getElement();
        if (element && "focus" in element) focusSelf(element);
        //(element as EventTarget as HTMLElement | null)?.focus();
        // Whatever the browser was going to do with this event,
        // forget it. We're turning it into a "press" event.
        e.preventDefault();
        // Also stop anyone else from listening to this event,
        // since we're explicitly handling it.
        // (Notably, this allows labels to wrap inputs, with them
        // both having press event handlers, without double-firing)
        e.stopPropagation();
        // Haptic feedback for this press event
        try {
          // The default implementation doesn't throw,
          // but we should guard against user implementations that could.
          pulse();
        } finally {
          // Actually call our handler.
          onPressSync(e);
        }
      }
    });
    var onMouseDown = useStableCallback(e => {
      if (onPressSync && !excludes("click", exclude)) {
        // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
        // but also don't prevent the user from selecting that text manually if they really want to
        // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
        if (e.detail > 1) {
          e.preventDefault();
        }
        if (e.button === 0) {
          onActiveStart(e);
        }
      }
    });
    var onMouseUp = useStableCallback(e => {
      if (onPressSync && !excludes("click", exclude)) {
        if (e.button === 0 && getActive() > 0) {
          onActiveStop(e);
        }
      }
    });
    var onMouseLeave = useStableCallback(() => {
      if (onPressSync && !excludes("click", exclude)) {
        setActive(0);
      }
    });
    var onKeyDown = useStableCallback(e => {
      if (onPressSync) {
        if (e.key == " " && !excludes("space", exclude)) {
          // We don't actually activate it on a space keydown
          // but we do preventDefault to stop the page from scrolling.
          onActiveStart(e);
          e.preventDefault();
        }
        if (e.key == "Enter" && !excludes("enter", exclude)) {
          e.preventDefault();
          onActiveStart(e);
          onActiveStop(e);
        }
      }
    });
    var onKeyUp = useStableCallback(e => {
      if (onPressSync && e.key == " " && !excludes("space", exclude)) onActiveStop(e);
    });
    var onClick = useStableCallback(e => {
      if (onPressSync) {
        e.preventDefault();
        if (e.detail > 1) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
      }
    });
    var onFocusOut = useStableCallback(_e => {
      setActive(0);
    });
    var propsStable2 = _({
      onKeyDown,
      onKeyUp,
      onMouseDown,
      onMouseUp,
      onMouseLeave,
      onClick,
      onfocusout: onFocusOut
    });
    return {
      pressReturn: {
        pseudoActive: pseudoActive || false,
        propsStable: propsStable2.current
        /*propsUnstable: {
            style: (textSelectedDuringActivationStartTime != null) ? { cursor: "text" } : undefined,
            ...{ "data-pseudo-active": pseudoActive ? "true" : undefined } as {}
        },*/
      }
    };
  }
  /**
   * selection.containsNode doesn't account for selection.isCollapsed,
   * so here's a workaround for that.
   *
   * We also only look for the selection end to only catch the
   * essense of a non-existant "selectionstop" event.
   *
   * @param element
   * @returns
   */
  function nodeSelectedTextLength(element) {
    if (element && element instanceof Node) {
      var selection = window.getSelection();
      for (var _i5 = 0; _i5 < ((_selection$rangeCount = selection === null || selection === void 0 ? void 0 : selection.rangeCount) !== null && _selection$rangeCount !== void 0 ? _selection$rangeCount : 0); ++_i5) {
        var _selection$rangeCount;
        var range = selection.getRangeAt(_i5);
        if (element.contains(range.endContainer) && !(selection !== null && selection !== void 0 && selection.isCollapsed)) {
          return selection.toString().length;
        }
      }
    }
    return 0;
  }
  var pulse = "vibrate" in navigator && navigator.vibrate instanceof Function ? () => navigator.vibrate(10) : () => {};
  function excludes(target, exclude) {
    if (exclude === false) return false;
    if (exclude === true || exclude !== null && exclude !== void 0 && exclude[target]) return true;
    return false;
  }
  function useCompleteGridNavigation(_ref38) {
    var {
      gridNavigationParameters,
      linearNavigationParameters,
      rovingTabIndexParameters,
      singleSelectionParameters,
      typeaheadNavigationParameters,
      sortableChildrenParameters,
      rearrangeableChildrenParameters
    } = _ref38;
    var getChildren = T$1(() => managedChildrenReturn.getChildren(), []);
    var getHighestChildIndex = T$1(() => getChildren().getHighestIndex(), []);
    var isValid = useStableCallback(index => {
      var _getChildren$getAt;
      return !((_getChildren$getAt = getChildren().getAt(index)) !== null && _getChildren$getAt !== void 0 && _getChildren$getAt.hidden);
    });
    var _useGridNavigationSin = useGridNavigationSingleSelectionSortable({
        gridNavigationParameters,
        linearNavigationParameters: _objectSpread({
          getHighestIndex: getHighestChildIndex,
          isValid
        }, linearNavigationParameters),
        managedChildrenReturn: {
          getChildren
        },
        rovingTabIndexParameters: _objectSpread({
          initiallyTabbedIndex: singleSelectionParameters.initiallySelectedIndex
        }, rovingTabIndexParameters),
        singleSelectionParameters,
        typeaheadNavigationParameters: _objectSpread({
          isValid
        }, typeaheadNavigationParameters),
        rearrangeableChildrenParameters,
        sortableChildrenParameters
      }),
      {
        childrenHaveFocusParameters,
        managedChildrenParameters,
        rovingTabIndexChildContext,
        singleSelectionContext,
        typeaheadNavigationChildContext,
        gridNavigationRowContext
      } = _useGridNavigationSin,
      gridNavigationSingleSelectionReturn = _objectWithoutProperties(_useGridNavigationSin, _excluded49);
    var {
      linearNavigationReturn,
      typeaheadNavigationReturn
    } = gridNavigationSingleSelectionReturn;
    var {
      childrenHaveFocusChildContext,
      childrenHaveFocusReturn
    } = useChildrenHaveFocus({
      childrenHaveFocusParameters
    });
    var {
      context: {
        managedChildContext
      },
      managedChildrenReturn
    } = useManagedChildren({
      managedChildrenParameters
    });
    var props = useMergedProps(linearNavigationReturn.propsStable, typeaheadNavigationReturn.propsStable);
    var context = useStableObject({
      singleSelectionContext,
      managedChildContext,
      rovingTabIndexChildContext,
      typeaheadNavigationChildContext,
      childrenHaveFocusChildContext,
      gridNavigationRowContext
    });
    return _objectSpread(_objectSpread({
      context,
      props,
      managedChildrenReturn
    }, gridNavigationSingleSelectionReturn), {}, {
      childrenHaveFocusReturn
      //rearrangeableChildrenParameters: { getHighestChildIndex: getHighestChildIndex, getValid },
    });
  }

  function useCompleteGridNavigationRow(_ref39) {
    var {
        rowAsChildOfGridParameters: {
          managedChildParameters,
          context: {
            childrenHaveFocusChildContext,
            gridNavigationRowContext,
            managedChildContext: mcc1,
            rovingTabIndexChildContext,
            singleSelectionContext,
            typeaheadNavigationChildContext
          },
          completeGridNavigationRowParameters,
          singleSelectionChildParameters,
          rovingTabIndexChildParameters
        },
        rowAsParentOfCellsParameters: {
          linearNavigationParameters,
          rovingTabIndexParameters,
          typeaheadNavigationParameters
        }
      } = _ref39,
      rowAsChildOfGridParameters = _objectWithoutProperties(_ref39.rowAsChildOfGridParameters, _excluded50),
      rowAsParentOfCellsParameters = _objectWithoutProperties(_ref39.rowAsParentOfCellsParameters, _excluded51);
    var {
      index
    } = managedChildParameters;
    var getChildren = T$1(() => managedChildrenReturn.getChildren(), []);
    var getHighestChildIndex = T$1(() => getChildren().getHighestIndex(), []);
    var isValid = T$1(i => {
      var child = getChildren().getAt(i);
      if (!child) return false;
      return !child.hidden;
    }, []);
    var {
      refElementReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var r = useGridNavigationSingleSelectionRow({
      rowAsParentOfCellsParameters: _objectSpread(_objectSpread({}, rowAsParentOfCellsParameters), {}, {
        rovingTabIndexParameters: _objectSpread({
          initiallyTabbedIndex: 0
        }, rovingTabIndexParameters),
        typeaheadNavigationParameters: _objectSpread({
          isValid
        }, typeaheadNavigationParameters),
        linearNavigationParameters: _objectSpread({
          isValid,
          getHighestIndex: getHighestChildIndex,
          pageNavigationSize: 0,
          indexDemangler: identity$1,
          indexMangler: identity$1
        }, linearNavigationParameters),
        managedChildrenReturn: {
          getChildren
        }
      }),
      rowAsChildOfGridParameters: _objectSpread(_objectSpread({}, rowAsChildOfGridParameters), {}, {
        refElementReturn,
        rovingTabIndexChildParameters,
        gridNavigationRowContext,
        rovingTabIndexChildContext,
        singleSelectionContext,
        typeaheadNavigationChildContext,
        singleSelectionChildParameters,
        managedChildParameters,
        managedChildrenReturn: {
          getChildren
        }
      })
    });
    var {
      rowAsChildOfGridReturn,
      rowAsParentOfCellsReturn
    } = r;
    var {
      context: {
        managedChildContext
      },
      managedChildrenReturn
    } = useManagedChildren({
      managedChildrenParameters: r.rowAsParentOfCellsReturn.managedChildrenParameters
    });
    var {
      getElement
    } = refElementReturn;
    var baseInfo = {
      getElement,
      setTabbable: r.rowAsChildOfGridReturn.rovingTabIndexChildReturn.setTabbable,
      getTabbable: r.rowAsChildOfGridReturn.rovingTabIndexChildReturn.getTabbable,
      tabbable: r.rowAsChildOfGridReturn.rovingTabIndexChildReturn.tabbable,
      index: managedChildParameters.index,
      hidden: rovingTabIndexChildParameters.hidden,
      selected: r.rowAsChildOfGridReturn.singleSelectionChildReturn.selected,
      focusSelf: r.rowAsChildOfGridReturn.gridNavigationRowParameters.focusSelf,
      getSelected: r.rowAsChildOfGridReturn.singleSelectionChildReturn.getSelected,
      setLocalSelected: r.rowAsChildOfGridReturn.managedChildParameters.setLocalSelected,
      disabled: singleSelectionChildParameters.disabled,
      setTabbableColumnIndex: r.rowAsChildOfGridReturn.gridNavigationRowParameters.setTabbableColumnIndex,
      getSortValue: rowAsChildOfGridParameters.sortableChildParameters.getSortValue
    };
    var {
      managedChildReturn
    } = useManagedChild({
      context: {
        managedChildContext: mcc1
      },
      managedChildParameters: {
        index
      }
    }, _objectSpread(_objectSpread({}, baseInfo), completeGridNavigationRowParameters));
    var context = useStableObject({
      managedChildContext,
      rovingTabIndexChildContext: r.rowAsParentOfCellsReturn.rovingTabIndexChildContext,
      typeaheadNavigationChildContext: r.rowAsParentOfCellsReturn.typeaheadNavigationChildContext,
      completeGridNavigationContext: useStableObject({
        onPressSync: r.rowAsChildOfGridReturn.pressParameters.onPressSync
      }),
      gridNavigationCellContext: r.rowAsParentOfCellsReturn.gridNavigationCellContext
    });
    var {
      hasCurrentFocusParameters
    } = useChildrenHaveFocusChild({
      childrenHaveFocusChildContext
    });
    //const { refElementReturn } = useRefElement<RowElement>({ refElementParameters: {} })
    var {
      hasCurrentFocusReturn
    } = useHasCurrentFocus({
      refElementReturn,
      hasCurrentFocusParameters: _objectSpread(_objectSpread({}, hasCurrentFocusParameters), {}, {
        onCurrentFocusedChanged: null
      })
    });
    var props = useMergedProps(refElementReturn.propsStable,
    // TODO: Rows don't use tabIndex, but just excluding props here is...weird.
    //r.rowAsChildOfGridReturn.rovingTabIndexChildReturn.propsUnstable,
    r.rowAsChildOfGridReturn.singleSelectionChildReturn.propsUnstable, r.rowAsParentOfCellsReturn.linearNavigationReturn.propsStable, r.rowAsParentOfCellsReturn.typeaheadNavigationReturn.propsStable, hasCurrentFocusReturn.propsStable);
    return {
      context,
      props,
      rowAsParentOfCellsReturn: _objectSpread(_objectSpread({}, rowAsParentOfCellsReturn), {}, {
        managedChildrenReturn
      }),
      rowAsChildOfGridReturn: _objectSpread(_objectSpread({}, rowAsChildOfGridReturn), {}, {
        managedChildReturn
      }),
      hasCurrentFocusReturn
      //managedChildrenReturn,
      //...gridNavigationSingleSelectionReturn
    };
  }

  function useCompleteGridNavigationCell(_ref40) {
    var {
        gridNavigationCellParameters,
        managedChildParameters,
        context: {
          completeGridNavigationContext,
          gridNavigationCellContext,
          managedChildContext,
          rovingTabIndexChildContext,
          typeaheadNavigationChildContext
        },
        rovingTabIndexChildParameters,
        textContentParameters,
        //managedChildContext,
        completeGridNavigationCellParameters,
        //sortableChildParameters: { getSortValue },
        pressParameters: {
          onPressSync
        }
      } = _ref40,
      pressParameters = _objectWithoutProperties(_ref40.pressParameters, _excluded52);
    var {
      index
    } = managedChildParameters;
    var {
      refElementReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      hasCurrentFocusParameters,
      rovingTabIndexChildReturn,
      textContentReturn
    } = useGridNavigationSingleSelectionCell({
      gridNavigationCellContext,
      gridNavigationCellParameters,
      managedChildParameters,
      rovingTabIndexChildContext,
      typeaheadNavigationChildContext,
      rovingTabIndexChildParameters,
      refElementReturn,
      textContentParameters
    });
    var {
      hasCurrentFocusReturn
    } = useHasCurrentFocus({
      hasCurrentFocusParameters: _objectSpread({
        onCurrentFocusedChanged: null
      }, hasCurrentFocusParameters),
      refElementReturn
    });
    var {
      pressReturn
    } = usePress({
      pressParameters: _objectSpread({
        onPressSync: useStableCallback(e => {
          var _completeGridNavigati;
          onPressSync === null || onPressSync === void 0 ? void 0 : onPressSync(e);
          (_completeGridNavigati = completeGridNavigationContext.onPressSync) === null || _completeGridNavigati === void 0 ? void 0 : _completeGridNavigati.call(completeGridNavigationContext, e);
        })
      }, pressParameters),
      refElementReturn
    });
    var baseInfo = {
      focusSelf: pressParameters.focusSelf,
      getElement: refElementReturn.getElement,
      hidden: rovingTabIndexChildParameters.hidden,
      index: managedChildParameters.index,
      getTabbable: rovingTabIndexChildReturn.getTabbable,
      setTabbable: rovingTabIndexChildReturn.setTabbable,
      tabbable: rovingTabIndexChildReturn.tabbable
      //getSortValue
    };

    var {
      managedChildReturn
    } = useManagedChild({
      context: {
        managedChildContext
      },
      managedChildParameters: {
        index
      }
    }, _objectSpread(_objectSpread({}, baseInfo), completeGridNavigationCellParameters));
    var props = useMergedProps(refElementReturn.propsStable, pressReturn.propsStable, rovingTabIndexChildReturn.propsUnstable, hasCurrentFocusReturn.propsStable);
    return {
      props,
      rovingTabIndexChildReturn,
      pressReturn,
      refElementReturn,
      hasCurrentFocusReturn,
      managedChildReturn,
      textContentReturn
    };
  }

  /**
   * All the list-related hooks combined into one giant hook that encapsulates everything.
   *
   * Unlike most others, this hook assume's it's the final one--the "outermost" hook in the component--so it uses `useManagedChildren` and wraps everything up nicely,
   * combining event handlers that are used in multiple sub-hooks, collecting all the necessary context-related data, and merging all known DOM props together.
   *
   *
   *
   * @returns
   */
  function useCompleteListNavigation(_ref41) {
    var {
        linearNavigationParameters,
        rearrangeableChildrenParameters,
        sortableChildrenParameters,
        typeaheadNavigationParameters,
        rovingTabIndexParameters,
        singleSelectionParameters
      } = _ref41,
      completeListNavigationParameters = _objectWithoutProperties(_ref41, _excluded53);
    //type M = UseListNavigationSingleSelectionChildInfo<ChildElement>;
    var {
      initiallySelectedIndex
    } = singleSelectionParameters;
    var getChildren = T$1(() => managedChildrenReturn.getChildren(), []);
    var getHighestChildIndex = T$1(() => getChildren().getHighestIndex(), []);
    var getValid = T$1(i => {
      var child = getChildren().getAt(i);
      if (!child) return false;
      return !child.hidden;
    }, []);
    var {
      rearrangeableChildrenReturn,
      sortableChildrenReturn
    } = useSortableChildren({
      rearrangeableChildrenParameters,
      sortableChildrenParameters
    });
    var {
      indexDemangler,
      indexMangler
    } = rearrangeableChildrenReturn;
    var {
      childrenHaveFocusParameters,
      managedChildrenParameters,
      rovingTabIndexChildContext,
      typeaheadNavigationChildContext,
      singleSelectionContext,
      linearNavigationReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      typeaheadNavigationReturn
    } = useListNavigationSingleSelection(_objectSpread({
      managedChildrenReturn: {
        getChildren
      },
      linearNavigationParameters: _objectSpread({
        getHighestIndex: getHighestChildIndex,
        isValid: getValid,
        indexDemangler,
        indexMangler
      }, linearNavigationParameters),
      typeaheadNavigationParameters: _objectSpread({
        isValid: getValid
      }, typeaheadNavigationParameters),
      rovingTabIndexParameters: _objectSpread({
        initiallyTabbedIndex: initiallySelectedIndex
      }, rovingTabIndexParameters),
      singleSelectionParameters
    }, completeListNavigationParameters));
    //const { linearNavigationReturn, typeaheadNavigationReturn } = listNavigationSingleSelectionSortableReturn;
    var {
      childrenHaveFocusChildContext,
      childrenHaveFocusReturn
    } = useChildrenHaveFocus({
      childrenHaveFocusParameters
    });
    var {
      context: {
        managedChildContext
      },
      managedChildrenReturn
    } = useManagedChildren({
      managedChildrenParameters
    });
    var props = useMergedProps(linearNavigationReturn.propsStable, typeaheadNavigationReturn.propsStable);
    var context = useStableObject({
      singleSelectionContext,
      managedChildContext,
      rovingTabIndexChildContext,
      typeaheadNavigationChildContext,
      childrenHaveFocusChildContext
    });
    return {
      context,
      props,
      managedChildrenReturn,
      rearrangeableChildrenReturn,
      sortableChildrenReturn,
      linearNavigationReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      typeaheadNavigationReturn,
      childrenHaveFocusReturn
    };
  }
  function useCompleteListNavigationChild(_ref42) {
    var {
        //managedChildParameters: { hidden, disabled, index, getSortValue },
        completeListNavigationChildParameters,
        singleSelectionChildParameters,
        rovingTabIndexChildParameters,
        managedChildParameters,
        textContentParameters,
        context: {
          childrenHaveFocusChildContext,
          managedChildContext,
          rovingTabIndexChildContext,
          singleSelectionContext,
          typeaheadNavigationChildContext
        },
        pressParameters: {
          onPressSync: ops1
        },
        sortableChildParameters: {
          getSortValue
        }
      } = _ref42,
      pressParameters = _objectWithoutProperties(_ref42.pressParameters, _excluded54),
      _void = _objectWithoutProperties(_ref42, _excluded55);
    var {
      hidden
    } = rovingTabIndexChildParameters;
    var {
      index
    } = managedChildParameters;
    var {
      disabled
    } = singleSelectionChildParameters;
    if (hidden) disabled = true;
    var {
      refElementReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      getElement
    } = refElementReturn;
    var {
      focusSelf
    } = pressParameters;
    var _useListNavigationSin = useListNavigationSingleSelectionChild({
        managedChildParameters: {
          index
        },
        rovingTabIndexChildParameters: {
          hidden
        },
        singleSelectionChildParameters: _objectSpread({}, singleSelectionChildParameters),
        rovingTabIndexChildContext,
        singleSelectionContext,
        typeaheadNavigationChildContext,
        refElementReturn,
        textContentParameters
      }),
      {
        hasCurrentFocusParameters: {
          onCurrentFocusedInnerChanged: ocfic1
        },
        pressParameters: {
          onPressSync: ops2
        },
        rovingTabIndexChildReturn,
        singleSelectionChildReturn,
        managedChildParameters: {
          setLocalSelected
        }
      } = _useListNavigationSin,
      p1 = _objectWithoutProperties(_useListNavigationSin.pressParameters, _excluded56);
    var {
      getTabbable,
      setTabbable,
      tabbable
    } = rovingTabIndexChildReturn;
    var {
      pressReturn
    } = usePress({
      pressParameters: _objectSpread(_objectSpread(_objectSpread({}, p1), pressParameters), {}, {
        onPressSync: disabled ? null : e => {
          ops2 === null || ops2 === void 0 ? void 0 : ops2(e);
          ops1 === null || ops1 === void 0 ? void 0 : ops1(e);
        }
      }),
      refElementReturn
    });
    var {
      getSelected,
      selected
    } = singleSelectionChildReturn;
    var mcp1 = {
      disabled,
      focusSelf,
      getElement,
      getSelected,
      getTabbable,
      hidden,
      index,
      selected,
      setLocalSelected,
      setTabbable,
      tabbable,
      getSortValue
    };
    var {
      managedChildReturn
    } = useManagedChild({
      context: {
        managedChildContext
      },
      managedChildParameters: {
        index
      }
    }, _objectSpread(_objectSpread({}, mcp1), completeListNavigationChildParameters));
    var {
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged: ocfic2
      }
    } = useChildrenHaveFocusChild({
      childrenHaveFocusChildContext
    });
    var onCurrentFocusedInnerChanged = useStableCallback((focused, prev, e) => {
      ocfic1 === null || ocfic1 === void 0 ? void 0 : ocfic1(focused, prev, e);
      ocfic2 === null || ocfic2 === void 0 ? void 0 : ocfic2(focused, prev, e);
    });
    var {
      hasCurrentFocusReturn
    } = useHasCurrentFocus({
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged,
        onCurrentFocusedChanged: null
      },
      refElementReturn
    });
    var props = useMergedProps(refElementReturn.propsStable, pressReturn.propsStable, hasCurrentFocusReturn.propsStable, rovingTabIndexChildReturn.propsUnstable, singleSelectionChildReturn.propsUnstable);
    return {
      props,
      pressReturn,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn,
      hasCurrentFocusReturn,
      managedChildReturn
    };
  }
  /*
  function foo<ParentElement extends Element, ChildElement extends Element, M extends UseListNavigationSingleSelectionSortableChildInfo<ChildElement>>(p: UseCompleteListNavigationParameters<ParentElement, ChildElement, M>) {
      const { singleSelectionReturn } = useCompleteListNavigation<ParentElement, ChildElement, M>(p);
      const selectedIndex = 0;
      useSingleSelectionDeclarative({ singleSelectionReturn, singleSelectionDeclarativeParameters: { selectedIndex } })
  }*/

  /**
   * Combines dismissal hooks and focus trap hooks into one.
   *
   * Another in the "complete" series, alongside list/grid navigation and dismissal itself.
   *
   * Use for dialogs, menus, etc.  Anything that can be dismissed and might trap focus, basically.
   *
   * @param param0
   * @returns
   */
  function useModal(_ref43) {
    var {
        dismissParameters,
        escapeDismissParameters,
        focusTrapParameters: {
          trapActive
        }
      } = _ref43,
      focusTrapParameters = _objectWithoutProperties(_ref43.focusTrapParameters, _excluded57);
    var {
      open
    } = dismissParameters;
    //const { getWindow } = escapeDismissParameters;
    //const getDocument = useCallback(() => { return getWindow().document; }, [getWindow]);
    var {
      refElementPopupReturn,
      refElementSourceReturn
    } = useDismiss({
      dismissParameters,
      escapeDismissParameters
    });
    var {
      focusTrapReturn,
      refElementReturn
    } = useFocusTrap({
      focusTrapParameters: _objectSpread({
        trapActive: open && trapActive
      }, focusTrapParameters),
      refElementParameters: {}
    });
    var {
      propsStable: pp1
    } = refElementPopupReturn;
    var {
      propsStable: ps2
    } = refElementSourceReturn;
    var {
      propsUnstable: pp3
    } = focusTrapReturn;
    var {
      propsStable: pp4
    } = refElementReturn;
    return {
      propsPopup: pp1,
      propsFocusContainer: useMergedProps(pp3, pp4),
      propsSource: ps2,
      refElementPopupReturn,
      refElementSourceReturn,
      focusTrapReturn
    };
  }
  function useRandomId(_ref44) {
    var {
      randomIdParameters: {
        prefix,
        otherReferencerProp
      }
    } = _ref44;
    var id = prefix + V$1();
    useEnsureStability("useRandomId", prefix, id);
    var referencerElementProps = _(otherReferencerProp == null ? {} : {
      [otherReferencerProp]: id
    });
    var sourceElementProps = _({
      id
    });
    useEnsureStability("useRandomIdReferencerElement", otherReferencerProp);
    return {
      propsReferencer: referencerElementProps.current,
      propsSource: sourceElementProps.current,
      randomIdReturn: {
        id: id
      }
    };
  }

  /**
   * While `useRandomId` allows the referencer to use the source's ID, sometimes you also want the reverse too (e.g. I `aria-label` you, you `aria-controls` me. That sort of thing).
   */
  function useRandomDualIds(_ref45) {
    var {
      randomIdInputParameters,
      randomIdLabelParameters
    } = _ref45;
    var {
      randomIdReturn: randomIdInputReturn,
      propsReferencer: propsLabelAsReferencer,
      propsSource: propsInputAsSource
    } = useRandomId({
      randomIdParameters: randomIdInputParameters
    });
    var {
      randomIdReturn: randomIdLabelReturn,
      propsReferencer: propsInputAsReferencer,
      propsSource: propsLabelAsSource
    } = useRandomId({
      randomIdParameters: randomIdLabelParameters
    });
    return {
      propsLabel: useMergedProps(propsLabelAsReferencer, propsLabelAsSource),
      propsInput: useMergedProps(propsInputAsReferencer, propsInputAsSource),
      randomIdInputReturn,
      randomIdLabelReturn
    };
  }
  B$2(null);
  function useTimeout(_ref46) {
    var {
      timeout,
      callback,
      triggerIndex
    } = _ref46;
    var stableCallback = useStableCallback(() => {
      startTimeRef.current = null;
      callback();
    });
    var getTimeout = useStableGetter(timeout);
    // Set any time we start timeout.
    // Unset any time the timeout completes
    var startTimeRef = _(null);
    var timeoutIsNull = timeout == null;
    // Any time the triggerIndex changes (including on mount)
    // restart the timeout.  The timeout does NOT reset
    // when the duration or callback changes, only triggerIndex.
    h(() => {
      if (!timeoutIsNull) {
        var _timeout = getTimeout();
        console.assert(timeoutIsNull == (_timeout == null));
        if (_timeout != null) {
          startTimeRef.current = +new Date();
          var handle = setTimeout(stableCallback, _timeout);
          return () => clearTimeout(handle);
        }
      }
    }, [triggerIndex, timeoutIsNull]);
    var getElapsedTime = T$1(() => {
      var _startTimeRef$current;
      return +new Date() - +((_startTimeRef$current = startTimeRef.current) !== null && _startTimeRef$current !== void 0 ? _startTimeRef$current : new Date());
    }, []);
    var getRemainingTime = T$1(() => {
      var timeout = getTimeout();
      return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
    }, []);
    return {
      getElapsedTime,
      getRemainingTime
    };
  }
  function useButton(_ref47) {
    var {
      buttonParameters: {
        tagButton,
        disabled,
        onPress,
        pressed,
        role
      },
      pressParameters,
      refElementParameters
    } = _ref47;
    debugLog("useButton");
    var refElementReturn = useRefElement({
      refElementParameters
    });
    var focusSelf = T$1(e => {
      var _e$focus2;
      return (_e$focus2 = e.focus) === null || _e$focus2 === void 0 ? void 0 : _e$focus2.call(e);
    }, []);
    var pressReturn = usePress(_objectSpread(_objectSpread({}, refElementReturn), {}, {
      pressParameters: _objectSpread({
        onPressSync: e => {
          var _ref48;
          return (_ref48 = disabled ? null : onPress) === null || _ref48 === void 0 ? void 0 : _ref48(enhanceEvent(e, {
            pressed: pressed == null ? null : !pressed
          }));
        },
        focusSelf
      }, pressParameters)
    }));
    var {
      pressReturn: {
        propsStable: pressProps
      }
    } = pressReturn;
    var {
      refElementReturn: {
        propsStable: refProps
      }
    } = refElementReturn;
    var baseProps = {
      "aria-pressed": pressed === true ? "true" : pressed === false ? "false" : undefined
    };
    var buttonProps = _objectSpread(_objectSpread({}, baseProps), {}, {
      disabled: disabled && disabled != "soft" ? true : false,
      "aria-disabled": disabled === 'soft' ? 'true' : undefined,
      role: role == "button" ? undefined : role
    });
    var divProps = _objectSpread(_objectSpread({}, baseProps), {}, {
      tabIndex: disabled === "hard" ? -1 : 0,
      role,
      "aria-disabled": disabled ? "true" : undefined
    });
    return _objectSpread(_objectSpread(_objectSpread({}, refElementReturn), pressReturn), {}, {
      props: useMergedProps(pressProps, refProps, tagButton == 'button' ? buttonProps : divProps)
    });
  }
  function useAccordion(_ref49) {
    var {
      accordionParameters: {
        initialIndex
      },
      linearNavigationParameters: {
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        navigatePastEnd,
        navigatePastStart,
        pageNavigationSize
      },
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange
      }
    } = _ref49;
    debugLog("useAccordian");
    //const [_currentFocusedIndex, setCurrentFocusedIndex, getCurrentFocusedIndex] = useState<number | null>(null);
    var mcReturnType = useManagedChildren({
      managedChildrenParameters: {
        onChildrenMountChange: useStableCallback((m, u) => {
          ocmc2();
          onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(m, u);
        }),
        onAfterChildLayoutEffect
      }
    });
    var {
      managedChildrenReturn: {
        getChildren
      },
      context
    } = mcReturnType;
    var isValid = T$1(c => !c.disabled && !c.hidden, []);
    var isValid2 = T$1(c => {
      var child = getChildren().getAt(c);
      if (child) {
        return isValid(child);
      }
      return false;
    }, []);
    var {
      changeIndex: changeExpandedIndex,
      getCurrentIndex: getCurrentExpandedIndex
    } = useChildrenFlag({
      initialIndex,
      getChildren,
      getAt: T$1(child => {
        var _child$getOpenFromPar;
        return (_child$getOpenFromPar = child.getOpenFromParent()) !== null && _child$getOpenFromPar !== void 0 ? _child$getOpenFromPar : false;
      }, []),
      setAt: T$1((child, open) => {
        return child.setOpenFromParent(open);
      }, []),
      isValid,
      onIndexChange: null,
      //key: "open",
      closestFit: false
    });
    var {
      changeIndex: changeTabbedIndex,
      getCurrentIndex: getTabbedIndex,
      reevaluateClosestFit: ocmc2
    } = useChildrenFlag({
      initialIndex,
      getChildren,
      getAt: T$1(child => {
        var _child$getMostRecentl;
        return (_child$getMostRecentl = child.getMostRecentlyTabbed()) !== null && _child$getMostRecentl !== void 0 ? _child$getMostRecentl : false;
      }, []),
      setAt: T$1((child, tabbed) => {
        return child.setMostRecentlyTabbed(tabbed);
      }, []),
      isValid,
      closestFit: true,
      onIndexChange: T$1(i => {
        if (i != null) {
          var _getChildren$getAt2;
          (_getChildren$getAt2 = getChildren().getAt(i)) === null || _getChildren$getAt2 === void 0 ? void 0 : _getChildren$getAt2.focusSelf();
        }
      }, [])
    });
    //const navigateAbsolute = useCallback((i: number) => { return changeTabbedIndex(i); }, []);
    //const navigateRelative = useCallback((s: number, o: number) => { return changeTabbedIndex(o + s); }, []);
    return {
      context: useStableObject(_objectSpread(_objectSpread({}, context), {}, {
        accordionSectionParameters: useStableObject({
          changeExpandedIndex,
          changeTabbedIndex,
          getExpandedIndex: getCurrentExpandedIndex,
          getTabbedIndex: getTabbedIndex
        }),
        linearNavigationParameters: useStableObject({
          disableArrowKeys,
          disableHomeEndKeys,
          getHighestIndex: T$1(() => getChildren().getHighestIndex(), []),
          indexMangler: identity,
          indexDemangler: identity,
          navigationDirection,
          isValid: isValid2,
          navigatePastEnd,
          navigatePastStart,
          pageNavigationSize
        }),
        rovingTabIndexReturn: useStableObject({
          getTabbableIndex: getTabbedIndex,
          setTabbableIndex: changeTabbedIndex
        })
      })),
      managedChildrenReturn: mcReturnType.managedChildrenReturn,
      accordionReturn: useStableObject({
        changeExpandedIndex
      })
    };
  }
  function identity(t) {
    return t;
  }
  function useAccordionSection(_ref50) {
    var _ref51;
    var {
      buttonParameters,
      pressParameters: {
        exclude
      },
      accordionSectionParameters: {
        open: openFromUser,
        bodyRole
      },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden
      },
      //managedChildContext,
      context,
      context: {
        accordionSectionParameters: {
          changeExpandedIndex,
          changeTabbedIndex: _setCurrentFocusedIndex,
          getTabbedIndex: getCurrentFocusedIndex
        },
        linearNavigationParameters,
        rovingTabIndexReturn
      },
      refElementParameters
    } = _ref50;
    var {
      disabled,
      onPress: userOnPress
    } = buttonParameters;
    debugLog("useAccordianSection");
    var [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
    var [mostRecentlyTabbed, setMostRecentlyTabbed, getMostRecentlyTabbed] = useState(null);
    var {
      randomIdReturn: _bodyIdReturn,
      propsSource: propsBodySource,
      propsReferencer: propsHeadReferencer
    } = useRandomId({
      randomIdParameters: {
        prefix: Prefices.accordionSectionHeaderButton,
        otherReferencerProp: "aria-controls"
      }
    });
    var {
      randomIdReturn: _headIdReturn,
      propsSource: propsHeadSource,
      propsReferencer: propsBodyReferencer
    } = useRandomId({
      randomIdParameters: {
        prefix: Prefices.accordionSectionBody,
        otherReferencerProp: "aria-labelledby"
      }
    });
    //const { randomIdSourceReturn: { propsStable: useBodyAsSourceIdProps } } = useBodyAsSourceId();
    //const { randomIdReferencerReturn: { propsStable: useBodyAsReferencerIdProps } } = useBodyAsReferencerId<BodyElement>({ randomIdReferencerParameters: { otherReferencerProp: "aria-controls" as never } });
    //const { randomIdSourceReturn: { propsStable: useHeaderAsSourceIdProps } } = useHeaderAsSourceId();
    //const { randomIdReferencerReturn: { propsStable: useHeaderAsReferencerIdProps } } = useHeaderAsReferencerId<HeaderElement>({ randomIdReferencerParameters: { otherReferencerProp: "aria-labelledby" as never } });
    var open = (_ref51 = openFromUser !== null && openFromUser !== void 0 ? openFromUser : openFromParent) !== null && _ref51 !== void 0 ? _ref51 : false;
    //const getOpen = useStableGetter(!!open);
    useStableGetter(index);
    var {
      refElementReturn: {
        getElement: getHeaderElement,
        propsStable: headerRefElementProps
      }
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      refElementReturn: {
        getElement: _getBodyElement,
        propsStable: bodyRefElementProps
      }
    } = useRefElement({
      refElementParameters: {}
    });
    var focusSelf = T$1(() => {
      var _getHeaderElement;
      //if (getCurrentFocusedIndex() != null)
      (_getHeaderElement = getHeaderElement()) === null || _getHeaderElement === void 0 ? void 0 : _getHeaderElement.focus();
    }, []);
    /*const openRef = useRef({
            get: () => !!getOpenFromParent(),
            set: (open: boolean) => {
                setOpenFromParent(open);
                 if (open) {
                    const bodyElement = getBodyElement();
                    setCurrentFocusedIndex(getIndex());
                    if (bodyElement) {
                        queueMicrotask(() => bodyElement.focus());
                }
            }
            },
            isValid: returnTrue
        });
        const tabbedRef = useRef({
            get: () => (getCurrentFocusedIndex() == getIndex()),
            set: (open: boolean) => {
                if (open)
                    setCurrentFocusedIndex(getIndex());
            },
            isValid: returnTrue
    });*/
    useManagedChild({
      context,
      managedChildParameters: {
        index: index
      }
    }, {
      index,
      disabled,
      focusSelf,
      getMostRecentlyTabbed,
      getOpenFromParent,
      hidden,
      setMostRecentlyTabbed,
      setOpenFromParent
    });
    //const onFocus = () => { changeTabbedIndex(index); }
    var onPress = e => {
      if (getOpenFromParent()) changeExpandedIndex(null);else changeExpandedIndex(index);
      userOnPress === null || userOnPress === void 0 ? void 0 : userOnPress(e);
    };
    var {
      pressReturn,
      props: buttonProps,
      refElementReturn
    } = useButton({
      buttonParameters: _objectSpread(_objectSpread({}, buttonParameters), {}, {
        pressed: null,
        onPress,
        role: "button"
      }),
      pressParameters: {
        exclude
      },
      refElementParameters
    });
    var linearReturnType = useLinearNavigation({
      linearNavigationParameters,
      rovingTabIndexReturn
    });
    var {
      linearNavigationReturn: {
        propsStable
      }
    } = linearReturnType;
    /*function useAccordionSectionHeaderProps({ ["aria-expanded"]: ariaExpanded, ["aria-disabled"]: ariaDisabled, ...props }: h.JSX.HTMLAttributes<HeaderElement>): h.JSX.HTMLAttributes<HeaderElement> {
             props.tabIndex = 0;
              return useMergedProps(useHeaderAsSourceIdProps, useHeaderAsReferencerIdProps, propsStable, {
                "aria-expanded": (ariaExpanded ?? open ?? false).toString(),
                "aria-disabled": (ariaDisabled ?? (open ? "true" : undefined)),
                ...useMergedProps(headerRefElementProps, useButtonProps(props))
            } as h.JSX.HTMLAttributes<HeaderElement>);
        }
          function useAccordionSectionBodyProps({ role, ...props }: h.JSX.HTMLAttributes<BodyElement>): h.JSX.HTMLAttributes<BodyElement> {
            const ret1 = useMergedProps(useBodyAsReferencerIdProps, { role: role ?? "region", ...props });
            const ret2 = useMergedProps(useBodyAsSourceIdProps, ret1);
            ret2.tabIndex ??= -1;
            return useMergedProps(bodyRefElementProps, ret2);
    }*/
    var headerButtonProps = useMergedProps(buttonProps, headerRefElementProps, propsHeadReferencer, propsHeadSource, propsStable, {
      "aria-expanded": (open !== null && open !== void 0 ? open : false).toString()
    });
    var bodyProps = useMergedProps(bodyRefElementProps, propsBodyReferencer, propsBodySource, {
      role: bodyRole,
      tabIndex: -1
    });
    return {
      pressReturn,
      refElementReturn,
      accordionSectionReturn: {
        mostRecentlyTabbed: !!mostRecentlyTabbed,
        expanded: open,
        focused: getCurrentFocusedIndex() == index
      },
      propsHeaderButton: headerButtonProps,
      propsHeader: {},
      propsBody: bodyProps
    };
  }
  function useLabel(_ref52) {
    var {
      randomIdInputParameters,
      randomIdLabelParameters,
      labelParameters: {
        tagInput,
        tagLabel,
        ariaLabel,
        labelPosition,
        onLabelClick
      }
    } = _ref52;
    var nativeHTMLBehavior = tagInput == "input" && tagLabel == "label" && labelPosition != "wrapping";
    var synthetic = !nativeHTMLBehavior;
    var {
      propsInput,
      propsLabel,
      randomIdInputReturn,
      randomIdLabelReturn
    } = useRandomDualIds({
      randomIdInputParameters: _objectSpread(_objectSpread({}, randomIdInputParameters), {}, {
        otherReferencerProp: !synthetic && labelPosition === "separate" ? "for" : null
      }),
      randomIdLabelParameters: _objectSpread(_objectSpread({}, randomIdLabelParameters), {}, {
        otherReferencerProp: synthetic ? "aria-labelledby" : null
      })
    });
    var {
      refElementReturn
    } = useRefElement({
      refElementParameters: {}
    });
    if (labelPosition == 'none') propsInput["aria-label"] = ariaLabel;
    var {
      pressReturn
    } = usePress({
      pressParameters: {
        exclude: {
          enter: "exclude",
          space: "exclude",
          click: undefined
        },
        onPressSync: onLabelClick,
        focusSelf: noop$2
      },
      refElementReturn
    });
    //propsLabel.onClick = onLabelClick ?? undefined;
    return {
      propsInput,
      propsLabel: useMergedProps(propsLabel, refElementReturn.propsStable, pressReturn.propsStable),
      randomIdInputReturn,
      randomIdLabelReturn
    };
  }
  /**
   * Shortcut for `useLabel` that assumes we're just never working with native HTML `input` and `label` elements. So for labelling guaranteably non-native elements.
   */
  function useLabelSynthetic(_ref53) {
    var {
      labelParameters: {
        ariaLabel,
        onLabelClick
      },
      randomIdInputParameters,
      randomIdLabelParameters
    } = _ref53;
    return useLabel({
      randomIdLabelParameters,
      randomIdInputParameters,
      labelParameters: {
        ariaLabel,
        labelPosition: ariaLabel == null ? "separate" : "none",
        tagInput: "div",
        tagLabel: "div",
        onLabelClick
      }
    });
  }
  function preventDefault(e) {
    e.preventDefault();
  }
  /**
   * Handles any component where there's:
   * 1. Some kind of an on/off binary/trinary input element that needs event handlers
   * 2. Some kind of label for that input element
   *
   * See also `useLabel` for when there's a label for a non-checkbox-like component.
   *
   * @param param0
   * @returns
   */
  function useCheckboxLike(_ref54) {
    var {
      labelParameters,
      randomIdInputParameters,
      randomIdLabelParameters,
      checkboxLikeParameters: {
        checked,
        disabled,
        onInput: onInputSync,
        role
      },
      refElementInputReturn,
      refElementLabelReturn
    } = _ref54;
    var {
      getElement: getInputElement
    } = refElementInputReturn;
    var {
      getElement: getLabelElement
    } = refElementLabelReturn;
    var {
      tagInput,
      tagLabel,
      labelPosition
    } = labelParameters;
    // onClick and onChange are a bit messy, so we need to
    // *always* make sure that the visible state is correct
    // after all the event dust settles.
    // See https://github.com/preactjs/preact/issues/2745,
    // and https://github.com/preactjs/preact/issues/1899#issuecomment-525690194
    h(() => {
      var element = getInputElement();
      if (element && tagInput == "input") {
        element.indeterminate = checked === "mixed";
        element.checked = checked === true;
      }
    }, [tagInput, checked !== null && checked !== void 0 ? checked : false]);
    var {
      randomIdInputReturn,
      randomIdLabelReturn,
      propsInput,
      propsLabel
    } = useLabel({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: useStableCallback(e => {
          if (!disabled && tagInput != "input" && tagLabel != "label" && labelPosition != "separate") {
            focusSelf();
            onInputSync(e);
          }
        })
      }),
      randomIdInputParameters,
      randomIdLabelParameters
    });
    var {
      getElement: getInput
    } = refElementInputReturn;
    var {
      getElement: getLabel
    } = refElementLabelReturn;
    T$1(() => {
      var _getInput;
      (_getInput = getInput()) === null || _getInput === void 0 ? void 0 : _getInput.focus();
    }, []);
    T$1(() => {
      var _getLabel;
      (_getLabel = getLabel()) === null || _getLabel === void 0 ? void 0 : _getLabel.focus();
    }, []);
    var onClickInputSync = labelPosition == "wrapping" ? undefined : onInputSync;
    var onClickLabelSync = onInputSync; //(labelPosition != "wrapping" ? undefined : onInputSync);
    var {
      pressReturn: pressInputReturn
    } = usePress({
      pressParameters: {
        exclude: {},
        focusSelf: useStableCallback(() => {
          debugger;
          focusSelf();
        }),
        onPressSync: disabled ? undefined : onClickInputSync
      },
      refElementReturn: refElementInputReturn
    });
    var {
      pressReturn: pressLabelReturn
    } = usePress({
      pressParameters: {
        exclude: {},
        focusSelf: useStableCallback(() => {
          debugger;
          focusSelf();
        }),
        onPressSync: disabled ? undefined : onClickLabelSync
      },
      refElementReturn: refElementLabelReturn
    });
    var propsUnstableInput = {};
    var propsUnstableLabel = {};
    //const propsUnstableLabel = useRef<h.JSX.HTMLAttributes<LabelType>>({});
    // Make sure that label clicks can't affect the visual state of the checkbox
    propsUnstableInput.onClick = preventDefault;
    propsUnstableLabel.onClick = preventDefault;
    propsUnstableInput.onInput = preventDefault;
    propsUnstableInput.onChange = preventDefault;
    propsUnstableInput.type = role == "radio" ? "radio" : "checkbox";
    switch (labelPosition) {
      case "separate":
        {
          if (tagInput == "input") {
            // Even in the most default input behavior, we still need to handle
            // special abstraction over checked="mixed" and disabled="soft"
            propsUnstableInput.checked = checked === true;
            if (disabled === true || disabled === 'hard') propsUnstableInput.disabled = true;else if (disabled == "soft") propsUnstableInput["aria-disabled"] = "true";
          } else {
            // div inputs need their various ARIA roles and properties
            propsUnstableInput.role = role;
            propsUnstableInput.tabIndex = 0;
            propsUnstableInput["aria-checked"] = (checked !== null && checked !== void 0 ? checked : false).toString();
            propsUnstableInput["aria-disabled"] = (!!disabled).toString();
          }
          break;
        }
      case "wrapping":
        {
          if (tagInput == "input") {
            // For form submission and styling
            propsUnstableInput.checked = checked === true;
            propsUnstableInput.disabled = disabled === true;
            // Because the wrapped label handles all interactions,
            // we need to make sure this element can't be interacted with
            // even if it's an input element.
            propsUnstableInput.inert = true;
            propsUnstableInput.tabIndex = -1;
            propsUnstableInput.role = "presentation";
            propsUnstableInput["aria-hidden"] = "true";
            propsUnstableInput.onFocus = _ => {
              var _getLabelElement, _getLabelElement$focu;
              return getLabelElement === null || getLabelElement === void 0 ? void 0 : (_getLabelElement = getLabelElement()) === null || _getLabelElement === void 0 ? void 0 : (_getLabelElement$focu = _getLabelElement.focus) === null || _getLabelElement$focu === void 0 ? void 0 : _getLabelElement$focu.call(_getLabelElement);
            };
          }
          // Wrapping labels are the actual inputs that are interacted with
          // And are very similar conceptually to div inputs when separated
          propsUnstableLabel.role = role;
          propsUnstableLabel.tabIndex = 0;
          propsUnstableLabel["aria-checked"] = (checked !== null && checked !== void 0 ? checked : false).toString();
          propsUnstableLabel["aria-disabled"] = (!!disabled).toString();
          break;
        }
    }
    var focusSelf = useStableCallback(() => {
      var _elementToFocus;
      var elementToFocus = null;
      if (labelPosition == "wrapping") elementToFocus = getLabelElement();else elementToFocus = getInputElement();
      (_elementToFocus = elementToFocus) === null || _elementToFocus === void 0 ? void 0 : _elementToFocus.focus();
    });
    return {
      randomIdInputReturn,
      randomIdLabelReturn,
      pressInputReturn,
      pressLabelReturn,
      checkboxLikeInputReturn: {
        propsUnstable: propsUnstableInput
      },
      checkboxLikeLabelReturn: {
        propsUnstable: propsUnstableLabel
      },
      propsInput: useMergedProps(propsInput, propsUnstableInput, pressInputReturn.propsStable, refElementInputReturn.propsStable),
      propsLabel: useMergedProps(propsLabel, propsUnstableLabel, pressLabelReturn.propsStable, refElementLabelReturn.propsStable),
      checkboxLikeReturn: {
        focusSelf
      }
    };
  }
  function useCheckbox(_ref55) {
    var {
      checkboxParameters: {
        onCheckedChange
      },
      checkboxLikeParameters,
      labelParameters,
      refElementInputReturn,
      refElementLabelReturn
    } = _ref55;
    debugLog("useCheckbox");
    var {
      tagInput,
      labelPosition
    } = labelParameters;
    var {
      checked
    } = checkboxLikeParameters;
    var onInputEnhanced = useStableCallback(e => onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(enhanceEvent(e, {
      checked: !checked
    })));
    var {
      pressInputReturn,
      pressLabelReturn,
      randomIdInputReturn,
      randomIdLabelReturn,
      propsInput,
      propsLabel,
      checkboxLikeReturn,
      checkboxLikeInputReturn,
      checkboxLikeLabelReturn
    } = useCheckboxLike({
      randomIdInputParameters: {
        prefix: Prefices.checkboxLikeInput
      },
      randomIdLabelParameters: {
        prefix: Prefices.checkboxLikeLabel
      },
      refElementInputReturn,
      refElementLabelReturn,
      checkboxLikeParameters: _objectSpread({
        role: "checkbox",
        onInput: onInputEnhanced
      }, checkboxLikeParameters),
      labelParameters
    });
    return {
      checkboxReturn: {
        propsUnstable: {
          type: tagInput == "input" && labelPosition != "wrapping" ? "checkbox" : undefined
        }
      },
      checkboxLikeReturn,
      pressInputReturn,
      pressLabelReturn,
      randomIdInputReturn,
      randomIdLabelReturn,
      propsInput,
      propsLabel,
      checkboxLikeInputReturn,
      checkboxLikeLabelReturn
    };
  }

  /**
   *
   *
   * @param param0
   * @returns
   */
  function useCheckboxGroup(_ref56) {
    var {
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      sortableChildrenParameters,
      rovingTabIndexParameters,
      typeaheadNavigationParameters
    } = _ref56;
    debugLog("useCheckboxGroup");
    //const onUpdateChildren = useStableCallback(onUpdateChildrenUnstable ?? (() => {}));
    var {
      childrenHaveFocusReturn,
      context,
      linearNavigationReturn,
      managedChildrenReturn,
      props,
      rearrangeableChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn
    } = useCompleteListNavigation({
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      singleSelectionParameters: {
        initiallySelectedIndex: null,
        setSelectedIndex: null
      },
      sortableChildrenParameters,
      typeaheadNavigationParameters
    });
    var {
      getChildren
    } = managedChildrenReturn;
    var children = getChildren();
    //const [uncheckedCount, setUnheckedCount] = useState(0);
    // Keep track of all child IDs, and any time any of them change, 
    // generate a new string with all of them concatenated together
    // (but only once per render);
    var allIds = _(new Set());
    var updateParentControlIds = useStableCallback(setter => {
      setter === null || setter === void 0 ? void 0 : setter(Array.from(allIds.current).join(" "));
    });
    var [getSetter, setSetter] = usePassiveState(updateParentControlIds, returnNull);
    var [_getUpdateIndex, setUpdateIndex] = usePassiveState(useStableCallback(() => {
      updateParentControlIds(getSetter());
    }), returnZero);
    // Lots of machenery to track what total percentage of all checkboxes are checked,
    // and notifying the parent checkbox of this information (while re-rendering as little as possible)
    var getSelfIsChecked = T$1(percentChecked => {
      return percentChecked <= 0 ? false : percentChecked >= 1 ? true : "mixed";
    }, []);
    var onAnyChildCheckedUpdate = useStableCallback((setter, percentChecked) => {
      setter === null || setter === void 0 ? void 0 : setter(getSelfIsChecked(percentChecked));
    });
    var [getTotalChildren, setTotalChildren] = usePassiveState(T$1(totalChildren => {
      onAnyChildCheckedUpdate(getSetParentCheckboxChecked(), getPercentChecked(getTotalChecked(), totalChildren));
    }, []), returnZero);
    var [getTotalChecked, setTotalChecked] = usePassiveState(T$1(totalChecked => {
      onAnyChildCheckedUpdate(getSetParentCheckboxChecked(), getPercentChecked(totalChecked, getTotalChildren()));
    }, []), returnZero);
    var getPercentChecked = T$1((totalChecked, totalChildren) => {
      if (totalChildren > 0) return totalChecked / totalChildren;else return totalChecked == 0 ? 0 : 1;
    }, []);
    var [getSetParentCheckboxChecked, setSetParentCheckboxChecked] = usePassiveState(useStableCallback(setter => {
      onAnyChildCheckedUpdate(setter, getPercentChecked(getTotalChecked(), getTotalChildren()));
    }));
    var onCheckboxGroupParentInput = T$1( /*#__PURE__*/function () {
      var _ref57 = _asyncToGenerator(function* (e) {
        e.preventDefault();
        var selfIsChecked = getSelfIsChecked(getPercentChecked(getTotalChecked(), getTotalChildren()));
        var nextChecked = selfIsChecked === false ? "mixed" : selfIsChecked === "mixed" ? true : false;
        var willChangeAny = false;
        var promises = [];
        children.forEach(child => {
          if (child.checkboxInfo.checkboxChildType == "child") willChangeAny || (willChangeAny = child.checkboxInfo.getChecked() != child.checkboxInfo.getLastUserChecked());
        });
        children.forEach(child => {
          if (child.checkboxInfo.checkboxChildType == "child") {
            var prevChecked = child.checkboxInfo.getChecked();
            var checked;
            if (nextChecked == "mixed") {
              if (willChangeAny) checked = child.checkboxInfo.getLastUserChecked();else checked = true;
            } else {
              checked = nextChecked;
            }
            if (checked != prevChecked) {
              var promise = child.checkboxInfo.setCheckedFromParentInput(checked, e);
              if (promise) {
                promises.push(promise);
              }
            }
          }
        });
        yield Promise.all(promises);
      });
      return function (_x) {
        return _ref57.apply(this, arguments);
      };
    }(), []);
    return {
      linearNavigationReturn,
      context: useStableObject(_objectSpread(_objectSpread({}, context), {}, {
        checkboxGroupChildrenContext: useStableObject({
          setUpdateIndex,
          allIds: allIds.current,
          setTotalChecked,
          setTotalChildren
        }),
        checkboxGroupParentContext: useStableObject({
          setSetter,
          setSetParentCheckboxChecked,
          getPercentChecked,
          getTotalChecked,
          getTotalChildren,
          onCheckboxGroupParentInput
        })
      })),
      childrenHaveFocusReturn,
      props,
      rearrangeableChildrenReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      managedChildrenReturn,
      rovingTabIndexReturn,
      typeaheadNavigationReturn
      /*checkboxGroup: {
          parentIsChecked: getSelfIsCheckedUnstable() as boolean | "mixed",
          parentPercentChecked: (checkedCount / (children.getHighestIndex() + 1)),
      }*/
    };
  }
  // If the user has changed the parent checkbox's value, then this ref holds a memory of what values were held before.
  // Otherwise, it's null when the last input was from a child checkbox. 
  //const savedCheckedValues = useRef<Map<number, boolean | "mixed"> | null>(null);
  function useCheckboxGroupParent(_ref58) {
    var {
      completeListNavigationChildParameters,
      context,
      managedChildParameters,
      pressParameters,
      rovingTabIndexChildParameters,
      textContentParameters,
      sortableChildParameters
    } = _ref58;
    var {
      checkboxGroupParentContext: {
        setSetter,
        setSetParentCheckboxChecked,
        getPercentChecked,
        getTotalChecked,
        getTotalChildren,
        onCheckboxGroupParentInput
      }
    } = context;
    //const focusSelf = useCallback((e: any) => (e as Element as HTMLElement).focus?.(), []);
    var {
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      props,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
    } = useCompleteListNavigationChild({
      completeListNavigationChildParameters,
      context,
      managedChildParameters,
      pressParameters,
      rovingTabIndexChildParameters,
      sortableChildParameters,
      textContentParameters,
      // single selection isn't used because checkboxes are multiselect; "disabled" refers only to that.
      singleSelectionChildParameters: {
        ariaPropName: null,
        selectionMode: "disabled",
        disabled: true
      }
    });
    var [ariaControls, setControls] = useState("");
    s(() => {
      setSetter(() => setControls);
    }, [setControls]);
    debugLog("useCheckboxGroupParent");
    var [checked, setChecked] = useState(false);
    h(() => {
      setSetParentCheckboxChecked(() => setChecked);
    }, []);
    var checkboxGroupParentReturn = {
      checked,
      onParentCheckedChange: onCheckboxGroupParentInput,
      getPercent: useStableCallback(() => {
        return getPercentChecked(getTotalChecked(), getTotalChildren());
      })
    };
    return {
      checkboxGroupParentReturn,
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      props: useMergedProps({
        "aria-controls": ariaControls
      }, props),
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
      /*checkboxGroupParentReturn,
      hasCurrentFocusParameters,
      rovingTabIndexChildReturn,
      useCheckboxGroupParentProps: function useCheckboxGroupParentInputProps(props: h.JSX.HTMLAttributes<InputElement>): h.JSX.HTMLAttributes<InputElement> {
          return useMergedProps({ "aria-controls": ariaControls } as h.JSX.HTMLAttributes<InputElement>, props);
      }*/
    };
  }

  function useCheckboxGroupChild(_ref59) {
    var {
      checkboxGroupChild,
      completeListNavigationChildParameters,
      context,
      managedChildParameters,
      pressParameters,
      textContentParameters,
      rovingTabIndexChildParameters,
      sortableChildParameters
    } = _ref59;
    var {
      checkboxGroupChildrenContext: {
        allIds,
        setUpdateIndex,
        setTotalChildren,
        setTotalChecked
      }
    } = context;
    debugLog("useCheckboxGroupChild", managedChildParameters.index);
    //const { checkbox: { onCheckedChange }, checkboxLike: { checked, disabled, labelPosition }, label: { tagInput, tagLabel }, hasFocusInput, hasFocusLabel } = asCheckbox;
    //const { subInfo, checkboxGroupChild: { checked, focusSelf, onChangeFromParent } } = asCheckboxGroupChild;
    var {
      checked,
      onChangeFromParent
    } = checkboxGroupChild;
    var getChecked = useStableGetter(checked);
    //labelPosition ??= "separate";
    var [getLastUserChecked, setLastUserChecked] = usePassiveState(null, returnFalse);
    var onChildCheckedChange = useStableCallback(checked => {
      setLastUserChecked(checked);
    });
    var onControlIdChanged = T$1((next, prev) => {
      if (prev) allIds.delete(prev);
      if (next) allIds.add(next);
      if (!!next || !!prev) {
        setUpdateIndex(i => (i !== null && i !== void 0 ? i : 0) + 1);
      }
    }, []);
    h(() => {
      setTotalChildren(c => (c !== null && c !== void 0 ? c : 0) + 1);
      return () => setTotalChildren(c => (c !== null && c !== void 0 ? c : 0) - 1);
    }, []);
    h(() => {
      if (checked) {
        setTotalChecked(c => (c !== null && c !== void 0 ? c : 0) + 1);
        return () => setTotalChecked(c => (c !== null && c !== void 0 ? c : 0) - 1);
      }
    }, [checked]);
    var {
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      props,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
    } = useCompleteListNavigationChild({
      completeListNavigationChildParameters: _objectSpread({
        checkboxInfo: {
          checkboxChildType: "child",
          getLastUserChecked,
          getChecked,
          setCheckedFromParentInput: onChangeFromParent
        }
      }, completeListNavigationChildParameters),
      context,
      managedChildParameters: _objectSpread({}, managedChildParameters),
      pressParameters,
      rovingTabIndexChildParameters,
      textContentParameters,
      sortableChildParameters,
      singleSelectionChildParameters: {
        ariaPropName: null,
        selectionMode: "disabled",
        disabled: true
      }
      //subInfo: { type: "child", getLastUserChecked, setCheckedFromParentInput: onChangeFromParent, getChecked, subInfo },
      /*listNavigationChildParameters: asCheckboxGroupChild.listNavigationChildParameters,
      managedChildParameters: asCheckboxGroupChild.managedChildParameters,
      refElementReturn: asCheckboxGroupChild.refElementReturn,
      rovingTabIndexChildParameters: { ...asCheckboxGroupChild.rovingTabIndexChildParameters, focusSelf }*/
    });

    return {
      checkboxGroupChild: {
        onChildCheckedChange,
        onControlIdChanged
      },
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      props,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
    };
  }
  function useDialog(_ref60) {
    var {
      dismissParameters,
      escapeDismissParameters,
      focusTrapParameters,
      labelParameters
    } = _ref60;
    var {
      focusTrapReturn,
      propsFocusContainer,
      propsPopup,
      propsSource,
      refElementPopupReturn,
      refElementSourceReturn
    } = useModal({
      dismissParameters: _objectSpread({
        closeOnLostFocus: false
      }, dismissParameters),
      escapeDismissParameters,
      focusTrapParameters: _objectSpread({
        trapActive: true,
        onlyMoveFocus: false
      }, focusTrapParameters)
    });
    var {
      propsInput,
      propsLabel
    } = useLabelSynthetic({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: useStableCallback(() => {
          var e = refElementPopupReturn.getElement();
          focusTrapParameters.focusPopup(e, () => findFirstFocusable(e));
        })
      }),
      randomIdInputParameters: {
        prefix: Prefices.dialog
      },
      randomIdLabelParameters: {
        prefix: Prefices.dialogTitle
      }
    });
    return {
      focusTrapReturn,
      propsFocusContainer,
      propsDialog: useMergedProps(propsPopup, propsInput),
      propsSource,
      propsTitle: propsLabel,
      refElementPopupReturn,
      refElementSourceReturn
    };
  }
  function useDrawer(_ref61) {
    var {
      dismissParameters,
      escapeDismissParameters,
      focusTrapParameters,
      labelParameters
    } = _ref61;
    var {
      focusTrapReturn,
      propsFocusContainer,
      propsPopup,
      propsSource,
      refElementPopupReturn,
      refElementSourceReturn
    } = useModal({
      dismissParameters,
      escapeDismissParameters,
      focusTrapParameters: _objectSpread({
        onlyMoveFocus: false
      }, focusTrapParameters)
    });
    var {
      propsInput,
      propsLabel
    } = useLabelSynthetic({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: useStableCallback(() => {
          var e = refElementPopupReturn.getElement();
          focusTrapParameters.focusPopup(e, () => findFirstFocusable(e));
        })
      }),
      randomIdInputParameters: {
        prefix: Prefices.drawer
      },
      randomIdLabelParameters: {
        prefix: Prefices.drawerTitle
      }
    });
    return {
      focusTrapReturn,
      propsFocusContainer,
      propsDrawer: useMergedProps(propsPopup, propsInput),
      propsTitle: propsLabel,
      propsSource,
      refElementPopupReturn,
      refElementSourceReturn
    };
  }
  function useGridlist(_ref62) {
    var {
      linearNavigationParameters,
      rovingTabIndexParameters,
      typeaheadNavigationParameters,
      labelParameters,
      gridlistParameters: {
        selectionLimit,
        groupingType,
        selectedIndex,
        setSelectedIndex
      },
      gridNavigationParameters,
      rearrangeableChildrenParameters,
      sortableChildrenParameters
    } = _ref62;
    var {
      propsInput: propsLabelList,
      propsLabel: propsLabelLabel,
      randomIdInputReturn: {
        id: _gridlistId
      },
      randomIdLabelReturn: {
        id: _labelId
      }
    } = useLabelSynthetic({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: useStableCallback(() => {
          rovingTabIndexReturn.focusSelf();
        })
      }),
      randomIdInputParameters: {
        prefix: Prefices.gridlist
      },
      randomIdLabelParameters: {
        prefix: Prefices.gridlistLabel
      }
    });
    var {
      childrenHaveFocusReturn,
      context,
      linearNavigationReturn,
      managedChildrenReturn,
      props,
      rovingTabIndexReturn,
      singleSelectionReturn,
      typeaheadNavigationReturn,
      rearrangeableChildrenReturn,
      sortableChildrenReturn
    } = useCompleteGridNavigation({
      linearNavigationParameters,
      rovingTabIndexParameters,
      singleSelectionParameters: {
        initiallySelectedIndex: selectedIndex,
        setSelectedIndex
      },
      sortableChildrenParameters,
      typeaheadNavigationParameters,
      gridNavigationParameters,
      rearrangeableChildrenParameters
    });
    useSingleSelectionDeclarative({
      singleSelectionReturn,
      singleSelectionDeclarativeParameters: {
        selectedIndex
      }
    });
    var propsGridlist = useMergedProps(props, propsLabelList, {
      "aria-multiselectable": selectionLimit == "multi" ? "true" : undefined
    });
    var fullContext = useStableObject(_objectSpread(_objectSpread({}, context), {}, {
      gridlistRowContext: useStableObject({
        selectionLimit
      })
    }));
    if (groupingType == "group") propsGridlist.role = "group";else if (groupingType == "with-groups") {
      // Intentionally clobbering all the list navigation stuff.
      propsGridlist = {
        role: "grid"
      };
      // ...actually, context too while we're at it.
      fullContext = null;
    } else {
      propsGridlist.role = "grid";
    }
    if (selectionLimit == "multi") console.assert(singleSelectionReturn.getSelectedIndex() == null);
    return {
      childrenHaveFocusReturn,
      context: fullContext,
      linearNavigationReturn,
      managedChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      rearrangeableChildrenReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn,
      propsGridlist,
      propsGridlistLabel: propsLabelLabel
    };
  }
  function useGridlistRow(_ref63) {
    var {
      rowAsChildOfGridParameters: {
        managedChildParameters,
        singleSelectionChildParameters,
        completeGridNavigationRowParameters,
        textContentParameters,
        rovingTabIndexChildParameters,
        sortableChildParameters,
        context: cx1,
        gridlistRowParameters: {
          selected
        }
      },
      rowAsParentOfCellsParameters: {
        linearNavigationParameters,
        rovingTabIndexParameters,
        typeaheadNavigationParameters
      }
    } = _ref63;
    var {
      gridlistRowContext: {
        selectionLimit
      }
    } = cx1;
    var {
      rowAsChildOfGridReturn,
      rowAsParentOfCellsReturn,
      context: cx2,
      hasCurrentFocusReturn,
      props
    } = useCompleteGridNavigationRow({
      rowAsChildOfGridParameters: {
        managedChildParameters,
        textContentParameters,
        singleSelectionChildParameters,
        completeGridNavigationRowParameters,
        rovingTabIndexChildParameters,
        sortableChildParameters,
        context: cx1
      },
      rowAsParentOfCellsParameters: {
        linearNavigationParameters: _objectSpread({}, linearNavigationParameters),
        rovingTabIndexParameters,
        typeaheadNavigationParameters: _objectSpread({}, typeaheadNavigationParameters)
      }
    });
    if (selectionLimit == "single") console.assert(selected == null);
    props.role = "option";
    return {
      rowAsChildOfGridReturn,
      rowAsParentOfCellsReturn,
      context: cx2,
      hasCurrentFocusReturn,
      props
    };
  }
  function useGridlistCell(p) {
    return useCompleteGridNavigationCell(p);
  }
  /*
  export const useGridlistSection = <BodySectionElement extends Element, RowElement extends Element>({ compareRows }: UseGridlistSectionParameters) => {
      //debugLog("useGridlistSection");
      //type CRFull = UseRovingTabIndexSubInfo<RowElement, UseListNavigationSubInfo<UseGridlistRowSubInfo<CellElement, CR, CC>>>;
      const getIndex = useCallback<GetIndex<any>>((i) => i.props.index, []);
        const {
          linearNavigationParameters,
          rearrangeableChildrenReturn,
          sortableChildrenReturn
      } = useSortableChildren<BodySectionElement, GridlistRowInfo<RowElement>>({
          rearrangeableChildrenParameters: {
              getIndex,
              getHighestChildIndex,
              getValid
          },
          sortableChildrenParameters: {
              compare: (lhs, rhs) => {
                  if (lhs.locationIndex === rhs.locationIndex)
                      return compareRows(lhs.index, rhs.index);
                  return lhs.locationIndex - rhs.locationIndex;
              }
          }
      });
       const useGridlistSectionProps = (props: h.JSX.HTMLAttributes<BodySectionElement>) => {
          console.assert(props.children != null);
          overwriteWithWarning("useGridlistSection", props, "role", "rowgroup");
          return useSortableProps(props as h.JSX.HTMLAttributes<BodySectionElement> & { children: any });
      }
       return {
          useGridlistSectionProps,
          ...sortableRet
      }
  }*/

  //export interface UseMenuButtonReturnTypeInfo extends UseListNavigationChildReturnTypeInfo<never> { }
  /*
  export interface UseMenuSurfaceReturnTypeWithHooks<MenuSurfaceElement extends Element, MenuParentElement extends Element, MenuButtonElement extends Element> extends UseMenuSurfaceReturnTypeInfo<MenuSurfaceElement, MenuButtonElement> {
      useMenuSurfaceSentinel: <E extends Element>() => { useMenuSentinelProps: (p: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; };
      useMenuSurfaceProps: (props: h.JSX.HTMLAttributes<MenuSurfaceElement>) => h.JSX.HTMLAttributes<MenuSurfaceElement>;
      useMenuSurfaceChildProps: (props: h.JSX.HTMLAttributes<MenuParentElement>) => h.JSX.HTMLAttributes<MenuParentElement>;  // NOT a menu item! This is the menu, dialog, popup, whatever actually gets the role, as opposed to the surface that listens to mouse and keyboard events
      useMenuSurfaceButtonProps: (props: h.JSX.HTMLAttributes<MenuButtonElement>) => h.JSX.HTMLAttributes<any>;
   }*/
  //export interface UseMenuButtonReturnTypeWithHooks extends UseMenuButtonReturnTypeInfo { }
  /**
   * A menu surface is what handles user interaction with an interactive but transient surface (like a menu or a popup).
   *
   * The keyboard (etc.) interactions are shared among a lot of widgets, and the opening button has some ARIA properties that need setting.
   *
   * Related to menus, which are a menu contained within a menu surface. Not related to menubars -- menus contain menubars, but not all menubars are contained within a menu or its surface.
   *
   */
  function useMenuSurface(_ref64) {
    var {
      //menuSurface: { sendFocusToMenu, role }, 
      dismissParameters,
      escapeDismissParameters,
      focusTrapParameters,
      menuSurfaceParameters: {
        role
      }
    } = _ref64;
    debugLog("useMenuSurface");
    var {
      propsReferencer: propsIdTrigger,
      propsSource: propsIdTarget
    } = useRandomId({
      randomIdParameters: {
        prefix: Prefices.menu,
        otherReferencerProp: "aria-controls"
      }
    });
    var _useRefElement = useRefElement({
        refElementParameters: {
          onElementChange: undefined
        }
      }),
      {
        refElementReturn: {
          getElement: getButtonElement,
          propsStable: propsRefTrigger
        }
      } = _useRefElement,
      void4 = _objectWithoutProperties(_useRefElement, _excluded58);
    var _useRefElement2 = useRefElement({
        refElementParameters: {
          onElementChange: undefined
        }
      }),
      {
        refElementReturn: {
          getElement: getMenuElement,
          propsStable: propsRefSurface
        }
      } = _useRefElement2,
      void5 = _objectWithoutProperties(_useRefElement2.refElementReturn, _excluded60),
      void6 = _objectWithoutProperties(_useRefElement2, _excluded59);
    var {
      focusTrapReturn,
      propsFocusContainer,
      propsPopup,
      propsSource: ps2,
      refElementPopupReturn,
      refElementSourceReturn
    } = useModal({
      dismissParameters,
      escapeDismissParameters,
      focusTrapParameters: _objectSpread(_objectSpread({}, focusTrapParameters), {}, {
        onlyMoveFocus: true,
        trapActive: true,
        focusOpener: useStableCallback(() => {
          var buttonElement = getButtonElement();
          buttonElement === null || buttonElement === void 0 ? void 0 : buttonElement.focus();
        })
      })
    });
    var propsSurface = useMergedProps(propsRefSurface, propsPopup, propsFocusContainer);
    var propsTarget = useMergedProps({
      role
    }, propsIdTarget);
    var propsTrigger = useMergedProps({
      "aria-expanded": dismissParameters.open.toString(),
      "aria-haspopup": role
    }, propsRefTrigger, ps2, propsIdTrigger);
    var propsSentinel = useFocusSentinel({
      focusSentinel: {
        sendFocusToMenu: T$1(() => {
          return focusTrapParameters.focusPopup(getMenuElement(), () => findFirstFocusable(getMenuElement()));
        }, []),
        onClose: T$1(() => {
          dismissParameters.onClose("lost-focus");
        }, [dismissParameters.onClose]),
        open: dismissParameters.open
      }
    });
    return {
      focusTrapReturn,
      propsSentinel,
      propsSurface,
      propsTarget,
      propsTrigger,
      refElementPopupReturn,
      refElementSourceReturn
    };
  }
  // A focus sentinal is a hidden but focusable element that comes at the start or end 
  // of the out-of-place-focusable component that, when activated or focused over, closes the component
  // (if focused within 100ms of the open prop changing, instead of
  // closing, focusing the sentinel immediately asks it to focus itself).
  // This exists for things like menus which can have focus but also need a way to return
  // to whatever out-of-place parent they came from when naturally tabbed out of (as opposed
  // to dialogs which loop back around when tabbed out of). While mouse users can click out of a menu
  // and keyboard users can escape to close a menu, screen readers and other input methods 
  // that don't use those two would become stuck.
  function useFocusSentinel(_ref65) {
    var {
      focusSentinel: {
        open,
        onClose,
        sendFocusToMenu
      }
    } = _ref65;
    debugLog("useFocusSentinel");
    var getSendFocusWithinMenu = useStableGetter(sendFocusToMenu);
    var stableOnClose = useStableCallback(onClose);
    var [firstSentinelIsActive, setFirstSentinelIsActive] = useState(false);
    useTimeout({
      callback: () => {
        setFirstSentinelIsActive(open);
      },
      timeout: 100,
      triggerIndex: "".concat(open, "-").concat(firstSentinelIsActive)
    });
    var onFocus = firstSentinelIsActive ? () => stableOnClose() : () => {
      var _getSendFocusWithinMe;
      return (_getSendFocusWithinMe = getSendFocusWithinMenu()) === null || _getSendFocusWithinMe === void 0 ? void 0 : _getSendFocusWithinMe();
    };
    var onClick = () => stableOnClose();
    return {
      tabIndex: firstSentinelIsActive ? 0 : -1,
      onFocus,
      onClick
    };
  }

  //export interface UseToolbarChildReturnTypeWithHooks<ChildElement extends Element, M extends UseToolbarSubInfo<ChildElement>> extends UseToolbarChildReturnTypeInfo<ChildElement, M> {
  //}
  /**
   * A toolbar is just a collection of widgets in an expected order and with the usual keyboard navigation stuff.
   *
   * The main difference between a toolbar and a menubar is that a menubar contains purely static menuitems,
   * but a toolbar is the more general case, being able to contain anything at all.
   * A menubar is implemented as a special case of a toolbar, and a menu is implemented as a specialized menubar
   *
   * Either way, be sure to specify the role and orientation this toolbar has (role=toolbar if you're using this as an actual toolbar).
   *
   * @param param0
   * @returns
   */
  function useToolbar(_ref66) {
    var {
        linearNavigationParameters,
        toolbarParameters: {
          orientation,
          role
        }
      } = _ref66,
      listNavParameters = _objectWithoutProperties(_ref66, _excluded61);
    var _useCompleteListNavig = useCompleteListNavigation(_objectSpread(_objectSpread({}, listNavParameters), {}, {
        linearNavigationParameters: _objectSpread(_objectSpread({}, linearNavigationParameters), {}, {
          navigationDirection: orientation
        })
      })),
      {
        context,
        props
      } = _useCompleteListNavig,
      listNavReturn = _objectWithoutProperties(_useCompleteListNavig, _excluded62);
    return _objectSpread({
      toolbarReturn: {
        propsUnstable: {
          role: role !== null && role !== void 0 ? role : undefined
        }
      },
      context,
      props
    }, listNavReturn);
  }
  function useToolbarChild(_ref67) {
    var listNavChildParameters = _extends({}, (_objectDestructuringEmpty(_ref67), _ref67));
    return useCompleteListNavigationChild(_objectSpread({}, listNavChildParameters));
  }

  //export type UseMenuItemProps<MenuItemElement extends Element> = (props: h.JSX.HTMLAttributes<MenuItemElement>) => h.JSX.HTMLAttributes<MenuItemElement>;
  //export type UseMenuItem<MenuItemElement extends Element, M extends UseMenubarSubInfo<MenuItemElement>> = (args: UseMenuItemParameters<MenuItemElement, M>) => UseMenuItemReturnType<MenuItemElement, M>;
  function useMenubar(_ref68) {
    var {
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      singleSelectionParameters,
      sortableChildrenParameters,
      rovingTabIndexParameters,
      typeaheadNavigationParameters,
      toolbarParameters,
      menubarParameters: {
        role
      }
    } = _ref68;
    debugLog("useMenubar");
    var _useToolbar = useToolbar({
        linearNavigationParameters,
        rovingTabIndexParameters,
        rearrangeableChildrenParameters,
        singleSelectionParameters,
        sortableChildrenParameters,
        typeaheadNavigationParameters,
        toolbarParameters: _objectSpread({
          role
        }, toolbarParameters)
      }),
      {
        linearNavigationReturn,
        childrenHaveFocusReturn,
        context,
        props,
        rearrangeableChildrenReturn,
        singleSelectionReturn,
        sortableChildrenReturn,
        managedChildrenReturn,
        rovingTabIndexReturn,
        toolbarReturn,
        typeaheadNavigationReturn
      } = _useToolbar,
      _rest = _objectWithoutProperties(_useToolbar, _excluded63);
    return {
      childrenHaveFocusReturn,
      context,
      props,
      rearrangeableChildrenReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      linearNavigationReturn,
      managedChildrenReturn,
      rovingTabIndexReturn,
      toolbarReturn,
      typeaheadNavigationReturn
    };
  }
  function useMenubarChild(_ref69) {
    var {
        managedChildParameters,
        singleSelectionChildParameters,
        completeListNavigationChildParameters,
        rovingTabIndexChildParameters,
        sortableChildParameters,
        context,
        textContentParameters,
        menuItemParameters: {
          onPress,
          role
        }
      } = _ref69,
      pressParameters = _extends({}, (_objectDestructuringEmpty(_ref69.pressParameters), _ref69.pressParameters));
    debugLog("useMenuItem", managedChildParameters.index);
    var disabled = singleSelectionChildParameters.disabled;
    var focusSelf = T$1(e => {
      var _e$focus3;
      return (_e$focus3 = e.focus) === null || _e$focus3 === void 0 ? void 0 : _e$focus3.call(e);
    }, []);
    var {
      hasCurrentFocusReturn,
      pressReturn,
      props,
      singleSelectionChildReturn,
      rovingTabIndexChildReturn,
      managedChildReturn
    } = useToolbarChild({
      completeListNavigationChildParameters,
      context,
      managedChildParameters,
      rovingTabIndexChildParameters,
      sortableChildParameters,
      textContentParameters,
      pressParameters: _objectSpread({
        focusSelf,
        onPressSync: e => {
          var _ref70;
          return (_ref70 = disabled ? null : onPress) === null || _ref70 === void 0 ? void 0 : _ref70(enhanceEvent(e, {
            index: managedChildParameters.index
          }));
        }
      }, pressParameters),
      singleSelectionChildParameters
      /*listNavigationChildParameters,
      pressParameters: {
          onClickSync: (e) => (disabled ? null : onPress)?.(enhanceEvent(e, { index: managedChildParameters.index })),
          exclude: undefined,
          focusSelf: rovingTabIndexChildParameters.focusSelf
      },
      singleSelectionChildParameters,
      typeaheadNavigationChildParameters,
      completeListNavigationChildParameters,
      managedChildParameters,
      rovingTabIndexChildParameters,
      refElementReturn,
      subInfo: { subInfo }*/
    });
    /*function useMenuItemProps(props: h.JSX.HTMLAttributes<MenuItemElement>) {
        overwriteWithWarning("useMenuItem", props, "role", role);
        return useMergedProps(pressReturn.propsStable, pressReturn.propsUnstable, props);
    }*/
    props.role = role;
    return {
      hasCurrentFocusReturn,
      pressReturn,
      props,
      singleSelectionChildReturn,
      rovingTabIndexChildReturn,
      managedChildReturn
    };
  }

  /*
  export interface UseMenuReturnTypeWithHooks<MenuSurfaceElement extends Element, MenuParentElement extends Element, MenuItemElement extends Element, MenuButtonElement extends Element, C, K extends string> extends UseMenuReturnTypeInfo<MenuSurfaceElement, MenuParentElement, MenuItemElement, MenuButtonElement, C, K> {
      useMenuSentinel: <E extends Element>() => { useMenuSentinelProps: (p: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; };
      useMenuProps: (props: h.JSX.HTMLAttributes<MenuParentElement>) => h.JSX.HTMLAttributes<MenuParentElement>;
      useMenuSurfaceProps: (props: h.JSX.HTMLAttributes<MenuSurfaceElement>) => h.JSX.HTMLAttributes<MenuSurfaceElement>;
      useMenuButtonProps: (props: h.JSX.HTMLAttributes<MenuButtonElement>) => h.JSX.HTMLAttributes<MenuButtonElement>;
      useMenuItem: UseMenuItem<MenuItemElement, C, K>;
  }*/
  function useMenu(_ref71) {
    var {
      dismissParameters,
      escapeDismissParameters,
      linearNavigationParameters,
      menuParameters: {
        openDirection,
        onOpen
      },
      menuSurfaceParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      singleSelectionParameters,
      sortableChildrenParameters,
      toolbarParameters,
      typeaheadNavigationParameters
    } = _ref71;
    debugLog("useMenu");
    var {
      childrenHaveFocusReturn,
      context,
      linearNavigationReturn,
      managedChildrenReturn,
      props: propsMenubar,
      rearrangeableChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      toolbarReturn,
      typeaheadNavigationReturn
    } = useMenubar({
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      singleSelectionParameters,
      sortableChildrenParameters,
      typeaheadNavigationParameters,
      toolbarParameters: _objectSpread({}, toolbarParameters),
      menubarParameters: {
        role: "menu"
      }
    });
    var onKeyDown = useStableCallback(e => {
      var isOpen = dismissParameters.open;
      if (!isOpen) {
        switch (e.key) {
          case "ArrowUp":
            {
              if (openDirection == 'up') {
                onOpen();
                e.preventDefault();
              }
              break;
            }
          case "ArrowDown":
            {
              if (openDirection == 'down') {
                onOpen();
                e.preventDefault();
              }
              break;
            }
          case "ArrowLeft":
            {
              if (openDirection == 'left') {
                onOpen();
                e.preventDefault();
              }
              break;
            }
          case "ArrowRight":
            {
              if (openDirection == 'right') {
                onOpen();
                e.preventDefault();
              }
              break;
            }
        }
      }
    });
    var {
      focusTrapReturn,
      propsSentinel,
      propsSurface,
      propsTarget,
      propsTrigger,
      refElementPopupReturn,
      refElementSourceReturn
    } = useMenuSurface({
      menuSurfaceParameters: _objectSpread(_objectSpread({}, menuSurfaceParameters), {}, {
        role: "menu"
      }),
      dismissParameters,
      escapeDismissParameters,
      focusTrapParameters: {
        focusPopup: () => {
          debugger;
          rovingTabIndexReturn.focusSelf();
        }
      }
    });
    return {
      childrenHaveFocusReturn,
      context,
      focusTrapReturn,
      linearNavigationReturn,
      managedChildrenReturn,
      propsSentinel,
      propsSurface,
      propsTarget: useMergedProps(propsTarget, propsMenubar),
      propsTrigger: useMergedProps({
        onKeyDown
      }, propsTrigger),
      rearrangeableChildrenReturn,
      refElementPopupReturn,
      refElementSourceReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      toolbarReturn,
      typeaheadNavigationReturn
      /*focusMenu,
       currentTypeahead,
      invalidTypeahead,
       managedChildren,*/
    };
  }

  function useMenuItem(p) {
    return useMenubarChild(p);
  }
  function useRadioGroup(_ref72) {
    var {
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      sortableChildrenParameters,
      typeaheadNavigationParameters,
      labelParameters,
      radioGroupParameters: {
        name,
        setSelectedValue: setSelectedValueExternal,
        selectedValue
      }
    } = _ref72;
    //debugLog("useRadioGroup", selectedValue);
    //const { refElementReturn: { getElement: _getGroupElement, propsStable } } = useRefElement<G>({ refElementParameters: {} });
    var [selectedIndex, setSelectedIndex] = useState(null);
    var byName = _(new Map());
    /*const setSelectedValue = useCallback((value: V | null) => {
        if (value == null) {
            setSelectedIndex(null);
            return;
        }
        const newIndex = byName.current.get(value);
        setSelectedIndex(newIndex ?? null);
    }, [])*/
    var {
      propsInput: propsGroup1,
      propsLabel
    } = useLabelSynthetic({
      labelParameters: _objectSpread({
        onLabelClick: useStableCallback(() => {
          rovingTabIndexReturn.focusSelf();
        })
      }, labelParameters),
      randomIdLabelParameters: {
        prefix: Prefices.radioGroupLabel
      },
      randomIdInputParameters: {
        prefix: Prefices.radioGroup
      }
    });
    /*const onSelectedIndexChange = useStableCallback((newIndex: number | null) => {
        if (newIndex != null) {
            const child = managedChildrenReturn.getChildren().getAt(newIndex);
            if (child) {
                onSelectedValueChange(child.getValue2() ?? null)
                return;
            }
        }
        onSelectedValueChange(null);
        //onSelectedValueChange(enhanceEvent<TCE, Event, { selectedValue: V | undefined }>(e, { selectedValue: managedChildrenReturn.getChildren().getAt(newIndex)?.getValue() }));
    });*/
    h(() => {
      var _byName$current$get;
      if (selectedValue != null) singleSelectionReturn.setSelectedIndex((_byName$current$get = byName.current.get(selectedValue)) !== null && _byName$current$get !== void 0 ? _byName$current$get : null);else singleSelectionReturn.setSelectedIndex(null);
    }, [selectedValue]);
    var {
      childrenHaveFocusReturn,
      context,
      props: propsGroup2,
      linearNavigationReturn,
      managedChildrenReturn,
      rearrangeableChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn
    } = useCompleteListNavigation({
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      singleSelectionParameters: {
        initiallySelectedIndex: selectedIndex,
        setSelectedIndex
      },
      sortableChildrenParameters,
      typeaheadNavigationParameters
    });
    useSingleSelectionDeclarative({
      singleSelectionReturn: {
        setSelectedIndex: useStableCallback(s => {
          var next = typeof s == "function" ? s(selectedIndex) : s;
          if (next != null) {
            var _managedChildrenRetur;
            var nextValue = (_managedChildrenRetur = managedChildrenReturn.getChildren().getAt(next)) === null || _managedChildrenRetur === void 0 ? void 0 : _managedChildrenRetur.getValue2();
            setSelectedValueExternal(nextValue);
          } else {
            setSelectedValueExternal(null);
          }
        })
      },
      singleSelectionDeclarativeParameters: {
        selectedIndex
      }
    });
    var propsRadioGroup = useMergedProps(propsGroup1, propsGroup2, {
      role: "radiogroup"
    });
    /*useEffect(() => {
        if (selectedValue == null) {
            setSelectedIndex(null)
        }
        else {
            const selectedIndex = byName.current.get(selectedValue);
            setSelectedIndex(selectedIndex ?? null);
        }
    }, [byName, selectedValue]);*/
    return {
      propsRadioGroup,
      propsRadioGroupLabel: propsLabel,
      childrenHaveFocusReturn,
      context: _objectSpread(_objectSpread({}, context), {}, {
        radioContext: {
          name,
          byName: byName.current
        }
      }),
      linearNavigationReturn,
      managedChildrenReturn,
      radioGroupReturn: {
        selectedIndex
      },
      rearrangeableChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn
    };
  }
  /*export interface UseRadioReturnTypeWithHooks<I extends Element, L extends Element> extends UseRadioReturnTypeInfo<I, L> {
      useRadioInput: UseRadioInput<I>;
      useRadioLabel: UseRadioLabel<L>;
  }*/
  //type UseRadioInput<I extends Element> = ({ tag }: TagSensitiveProps<I>) => { useRadioInputProps: (props: h.JSX.HTMLAttributes<I>) => h.JSX.HTMLAttributes<I>; }
  //type UseRadioLabel<L extends Element> = ({ tag }: TagSensitiveProps<L>) => { useRadioLabelProps: (props: h.JSX.HTMLAttributes<L>) => h.JSX.HTMLAttributes<L>; }
  //export type UseRadio<V extends string | number, I extends Element, L extends Element, C, K extends string> = (a: UseRadioParameters<V, I, L, C, K>) => UseRadioReturnTypeWithHooks<I, L>
  function useRadio(_ref73) {
    var {
      radioParameters: {
        value
      },
      checkboxLikeParameters: {
        disabled
      },
      completeListNavigationChildParameters,
      labelParameters,
      managedChildParameters,
      pressParameters,
      singleSelectionChildParameters,
      context,
      textContentParameters,
      rovingTabIndexChildParameters,
      sortableChildParameters
    } = _ref73;
    var index = managedChildParameters.index;
    debugLog("useRadio", index);
    var onInput = useStableCallback(e => {
      singleSelectionChildReturn.setThisOneSelected(e);
    });
    var {
      name,
      byName
    } = context.radioContext;
    var {
      tagInput,
      tagLabel,
      labelPosition
    } = labelParameters;
    var getValue = useStableGetter(value);
    var {
      props: listNavigationSingleSelectionChildProps,
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
    } = useCompleteListNavigationChild({
      completeListNavigationChildParameters: {
        getValue2: getValue
      },
      managedChildParameters,
      pressParameters,
      context,
      rovingTabIndexChildParameters,
      sortableChildParameters,
      textContentParameters,
      /*rovingTabIndex,
      managedChild: {
          index: managedChild.index,
          flags: managedChild.flags
      },
      hasFocus,
      subInfo: { getValue, subInfo },*/
      singleSelectionChildParameters: _objectSpread({
        selectionMode: "focus",
        ariaPropName: tagInput == "input" && labelPosition == "separate" ? null : "aria-selected"
      }, singleSelectionChildParameters)
    });
    var {
      selected: checked
    } = singleSelectionChildReturn;
    var {
      refElementReturn: refElementInputReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      refElementReturn: refElementLabelReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      checkboxLikeInputReturn,
      checkboxLikeLabelReturn,
      pressInputReturn,
      pressLabelReturn,
      propsInput,
      propsLabel,
      randomIdInputReturn,
      randomIdLabelReturn,
      checkboxLikeReturn
    } = useCheckboxLike({
      checkboxLikeParameters: {
        checked: checked !== null && checked !== void 0 ? checked : false,
        disabled,
        onInput: onInput,
        role: "radio"
      },
      labelParameters,
      randomIdInputParameters: {
        prefix: Prefices.radio
      },
      randomIdLabelParameters: {
        prefix: Prefices.radioLabel
      },
      refElementInputReturn,
      refElementLabelReturn
    });
    s(() => {
      byName.set(value, index);
      return () => {
        byName.delete(value);
      };
    }, [value, index]);
    //const useRadioInput = () => {
    if (tagInput == "input") {
      propsInput.name = name;
      propsInput.checked = checked !== null && checked !== void 0 ? checked : false;
      propsInput.type = "radio";
    } else {
      propsInput["aria-checked"] = (checked !== null && checked !== void 0 ? checked : false).toString();
    }
    var propsIfInputHandlesFocus = useMergedProps(listNavigationSingleSelectionChildProps, propsInput);
    var propsInput2 = labelPosition == "separate" ? propsIfInputHandlesFocus : propsInput;
    // };
    //const useRadioLabel: UseRadioLabel<IL> = useCallback(() => {
    //const tag = tagLabel;
    //const useRadioLabelProps = (propsLabel: h.JSX.HTMLAttributes<IL>): h.JSX.HTMLAttributes<IL> => {
    //const { useCheckboxLikeLabelElementProps } = useCheckboxLikeLabelElement();
    var propsIfLabelHandlesFocus = useMergedProps(listNavigationSingleSelectionChildProps, propsLabel);
    var propsLabel2 = labelPosition == "wrapping" ? propsIfLabelHandlesFocus : propsLabel;
    //};
    //return {
    //    useRadioLabelProps
    //}
    //}, [useCheckboxLikeLabelElement]);
    return {
      checkboxLikeInputReturn,
      checkboxLikeLabelReturn,
      managedChildReturn,
      pressInputReturn,
      pressLabelReturn,
      propsInput: propsInput2,
      propsLabel: propsLabel2,
      randomIdInputReturn,
      randomIdLabelReturn,
      hasCurrentFocusReturn,
      rovingTabIndexChildReturn,
      pressReturn,
      singleSelectionChildReturn,
      checkboxLikeReturn
    };
  }
  function useSlider(_ref74) {
    var {
      sliderParameters: {
        max,
        min
      },
      managedChildrenParameters
    } = _ref74;
    debugLog("useSlider");
    var {
      context,
      managedChildrenReturn
    } = useManagedChildren({
      managedChildrenParameters
    });
    var baseIdRef = _(null);
    if (baseIdRef.current === null) baseIdRef.current = generateRandomId(Prefices.sliderThumb);
    //const { propsReferencer, propsSource, randomIdReturn: { id: baseId } } = useRandomId<LabelElement, ThumbElement>({ randomIdParameters: { prefix: "aria-thumb-", otherReferencerProp: "aria-labelledby" } })
    /*const {
        propsInput,
        propsLabel,
        randomIdInputReturn,
        randomIdLabelReturn
    } = useLabel<ThumbElement, LabelElement>({ labelParameters: { ariaLabel: null }, randomIdInputParameters, randomIdLabelParameters });*/
    return {
      context: F$1(() => _objectSpread(_objectSpread({}, context), {}, {
        sliderContext: {
          min,
          max,
          baseId: baseIdRef.current
        }
      }), [min, max]),
      managedChildrenReturn
    };
  }
  function useSliderThumb(_ref75) {
    var {
        managedChildParameters,
        context: {
          sliderContext: {
            max: maxParent,
            min: minParent
          }
        },
        sliderThumbParameters
      } = _ref75,
      context = _objectWithoutProperties(_ref75.context, _excluded64);
    var {
      index
    } = managedChildParameters;
    debugLog("useSliderThumb", managedChildParameters.index);
    var {
      managedChildReturn
    } = useManagedChild({
      managedChildParameters,
      context
    }, {
      index
    });
    var {
      tag,
      value,
      max: maxOverride,
      min: minOverride,
      onValueChange,
      valueText,
      label
    } = sliderThumbParameters;
    var min = minOverride !== null && minOverride !== void 0 ? minOverride : minParent;
    var max = maxOverride !== null && maxOverride !== void 0 ? maxOverride : maxParent;
    var newProps = tag == "input" ? {
      min,
      max,
      value,
      type: "range"
    } : {
      "aria-valuemax": "".concat(max),
      "aria-valuemin": "".concat(min),
      "aria-valuenow": "".concat(value)
    };
    newProps = _objectSpread(_objectSpread({}, newProps), {}, {
      "aria-label": label,
      "aria-valuetext": valueText,
      style: {
        "--range-value": "".concat(value),
        "--range-value-text": "".concat(valueText)
      }
    });
    if (tag == "input") {
      newProps.onInput = e => {
        onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange({
          currentTarget: e.currentTarget,
          target: e.target,
          [EventDetail]: {
            value: e.currentTarget.valueAsNumber
          }
        });
      };
    } else {
      throw new Error("Unimplemented");
    }
    return {
      sliderThumbReturn: {
        min,
        max
      },
      managedChildReturn,
      propsSliderThumb: newProps
    };
  }
  function useTable(_ref76) {
    var {
      labelParameters,
      tableParameters: {
        selectionLimit,
        tagTable
      }
    } = _ref76;
    var [getSortBody, setSortBody] = usePassiveState(null, returnNull);
    var sortQueue = _([]);
    var [getSortColumn, setSortColumn] = usePassiveState(T$1(a => {
      sortQueue.current.push(a.column);
    }, []), T$1(() => {
      return {
        column: 0,
        direction: "ascending"
      };
    }, []));
    var updateSortDirection = T$1(column => {
      var {
        column: currentColumn,
        direction: currentDirection
      } = getSortColumn();
      var next = {
        column,
        direction: column != currentColumn ? "ascending" : currentDirection == "ascending" ? "descending" : "ascending"
      };
      setSortColumn(next);
      return next;
    }, []);
    var sortByColumn = T$1(column => {
      var _getSortBody;
      var next = updateSortDirection(column);
      (_getSortBody = getSortBody()) === null || _getSortBody === void 0 ? void 0 : _getSortBody();
      return next;
    }, []);
    //const { tagInput: tagTable } = labelParameters
    var {
      propsInput: propsLabelList,
      propsLabel: propsLabelLabel
    } = useLabelSynthetic({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: null
      }),
      randomIdInputParameters: {
        prefix: Prefices.table
      },
      randomIdLabelParameters: {
        prefix: Prefices.tableLabel
      }
    });
    return {
      propsTable: useMergedProps({
        role: tagTable == "table" ? undefined : "grid",
        "aria-multiselectable": selectionLimit == "multi" ? "true" : undefined
      }, propsLabelList),
      propsLabel: propsLabelLabel,
      context: {
        tableContext: {
          sortByColumn,
          setSortBodyFunction: setSortBody,
          getCurrentSortColumn: getSortColumn
        }
      }
    };
  }
  var naturalSectionTypes = new Set(["thead", "tbody", "tfoot"]);
  function useTableSection(_ref77) {
    var {
      linearNavigationParameters,
      rovingTabIndexParameters,
      singleSelectionParameters,
      gridNavigationParameters,
      rearrangeableChildrenParameters,
      tableSectionParameters: {
        tagTableSection,
        location
      },
      context: {
        tableContext
      }
    } = _ref77;
    var {
      childrenHaveFocusReturn,
      context,
      linearNavigationReturn,
      managedChildrenReturn,
      props,
      rovingTabIndexReturn,
      singleSelectionReturn,
      typeaheadNavigationReturn,
      rearrangeableChildrenReturn,
      sortableChildrenReturn
    } = useCompleteGridNavigation({
      linearNavigationParameters,
      rovingTabIndexParameters,
      singleSelectionParameters,
      sortableChildrenParameters: {
        compare: T$1((lhs, rhs) => {
          return +lhs.getSortValue() - +rhs.getSortValue();
        }, [])
      },
      typeaheadNavigationParameters: {
        noTypeahead: true,
        collator: null,
        typeaheadTimeout: Infinity
      },
      gridNavigationParameters,
      rearrangeableChildrenParameters
    });
    if (!naturalSectionTypes.has(tagTableSection)) {
      props.role = "rowgroup";
    }
    h(() => {
      if (location == "body") {
        tableContext.setSortBodyFunction(() => {
          var managedRows = managedChildrenReturn.getChildren();
          return () => sortableChildrenReturn.sort(managedRows, tableContext.getCurrentSortColumn().direction);
        });
      }
    });
    /*const sort = useCallback((column: number) => {
        const ret = tableContext.updateSortDirection(column)
        sortableChildrenReturn.sort(managedChildrenReturn.getChildren(), ret.direction);
        return ret;
    }, [])*/
    return {
      childrenHaveFocusReturn,
      context: _objectSpread(_objectSpread({}, context), {}, {
        tableContext
      }),
      linearNavigationReturn,
      managedChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      rearrangeableChildrenReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn,
      propsTableSection: props
    };
  }
  function useTableRow(_ref78) {
    var _singleSelectionChild;
    var {
      rowAsChildOfGridParameters: {
        managedChildParameters,
        singleSelectionChildParameters,
        completeGridNavigationRowParameters,
        rovingTabIndexChildParameters,
        textContentParameters,
        context: cx1
      },
      rowAsParentOfCellsParameters: {
        linearNavigationParameters,
        rovingTabIndexParameters
      },
      tableRowParameters: {
        selected
      }
    } = _ref78;
    var {
      context: cx2,
      hasCurrentFocusReturn,
      rowAsChildOfGridReturn,
      rowAsParentOfCellsReturn,
      props
    } = useCompleteGridNavigationRow({
      rowAsChildOfGridParameters: {
        textContentParameters,
        context: _objectSpread({}, cx1),
        managedChildParameters,
        singleSelectionChildParameters,
        completeGridNavigationRowParameters,
        rovingTabIndexChildParameters,
        sortableChildParameters: {
          getSortValue: T$1(() => {
            var currentColumn = cx1.tableContext.getCurrentSortColumn().column;
            var currentChild = rowAsParentOfCellsReturn.managedChildrenReturn.getChildren().getAt(currentColumn !== null && currentColumn !== void 0 ? currentColumn : 0);
            var sortValue = currentChild === null || currentChild === void 0 ? void 0 : currentChild.getSortValue();
            return sortValue;
          }, [])
        }
      },
      rowAsParentOfCellsParameters: {
        linearNavigationParameters,
        rovingTabIndexParameters,
        typeaheadNavigationParameters: {
          noTypeahead: true,
          collator: null,
          typeaheadTimeout: Infinity
        }
      }
    });
    props.role = "gridrow";
    if (selected) props[(_singleSelectionChild = singleSelectionChildParameters.ariaPropName) !== null && _singleSelectionChild !== void 0 ? _singleSelectionChild : "aria-selected"] = "true";
    return {
      rowAsChildOfGridReturn,
      rowAsParentOfCellsReturn,
      context: _objectSpread(_objectSpread({}, cx2), {}, {
        tableContext: cx1.tableContext
      }),
      hasCurrentFocusReturn,
      props
    };
  }
  function useTableCell(_ref79) {
    var {
        tableCellParameters: {
          tagTableCell
        }
      } = _ref79,
      p = _objectWithoutProperties(_ref79, _excluded65);
    var ret = useCompleteGridNavigationCell(p);
    if (!(tagTableCell == "th" || tagTableCell == "td")) {
      ret.props.role = "gridcell";
    }
    return _objectSpread(_objectSpread({}, ret), {}, {
      tableCellReturn: {
        sortByThisColumn: useStableCallback(() => {
          return p.context.tableContext.sortByColumn(p.managedChildParameters.index);
        }, [])
      }
    });
  }
  /*
  export interface UseTableSectionSectionParameters {
      gridlistSectionParameters: {
          compareRows: (lhsIndex: number, rhsIndex: number) => number;
      }
      gridlistSectionContext: {
       }
  }*/
  /*
  export const useTableSectionSection = <BodySectionElement extends Element, RowElement extends Element>({ compareRows }: UseTableSectionSectionParameters) => {
      //debugLog("useTableSectionSection");
      //type CRFull = UseRovingTabIndexSubInfo<RowElement, UseListNavigationSubInfo<UseTableRowSubInfo<CellElement, CR, CC>>>;
      const getIndex = useCallback<GetIndex<any>>((i) => i.props.index, []);
        const {
          linearNavigationParameters,
          rearrangeableChildrenReturn,
          sortableChildrenReturn
      } = useSortableChildren<BodySectionElement, TableRowInfo<RowElement>>({
          rearrangeableChildrenParameters: {
              getIndex,
              getHighestChildIndex,
              getValid
          },
          sortableChildrenParameters: {
              compare: (lhs, rhs) => {
                  if (lhs.locationIndex === rhs.locationIndex)
                      return compareRows(lhs.index, rhs.index);
                  return lhs.locationIndex - rhs.locationIndex;
              }
          }
      });
       const useTableSectionSectionProps = (props: h.JSX.HTMLAttributes<BodySectionElement>) => {
          console.assert(props.children != null);
          overwriteWithWarning("useTableSectionSection", props, "role", "rowgroup");
          return useSortableProps(props as h.JSX.HTMLAttributes<BodySectionElement> & { children: any });
      }
       return {
          useTableSectionSectionProps,
          ...sortableRet
      }
  }*/

  /*
  export function useTabs<TabListElement extends Element, TabElement extends Element, PanelElement extends Element, LabelElement extends Element>({ tabPanels: { managedChildren: { onChildrenMountChange: ocmc, ...tabPanelsManagedChildren } } }: UseTabsParameters): UseTabsReturnTypeWithHooks<TabListElement, TabElement, PanelElement, LabelElement> {
      const {
          useListNavigationSingleSelectionChild,
          useListNavigationSingleSelectionProps
      } = useListNavigationSingleSelection<TabListElement, TabElement, TabInfo, never>({
          childrenHaveFocus: {},
          linearNavigation: {},
          listNavigation: {},
          managedChildren: {},
          rovingTabIndex: {},
          singleSelection: {},
          typeaheadNavigation: {}
       });
       const useTab = useCallback(() => {}, []);
      const useTabPanel = useCallback(() => {});
      function useTabListProps(props: h.JSX.HTMLAttributes<TabListElement>) { return useListNavigationSingleSelectionProps(props); }
      function useTabLabelProps() {}
       return {
       }
      
  }*/
  function useTabs(_ref80) {
    var {
        labelParameters,
        linearNavigationParameters,
        rearrangeableChildrenParameters,
        rovingTabIndexParameters,
        singleSelectionParameters: {
          setSelectedIndex: ssi
        },
        sortableChildrenParameters,
        typeaheadNavigationParameters,
        tabsParameters: {
          orientation,
          role
        }
        // tabPanels: { managedChildren: { onChildrenMountChange: ocmc, ...tabPanelsManagedChildren } } 
      } = _ref80,
      singleSelectionParameters = _objectWithoutProperties(_ref80.singleSelectionParameters, _excluded66);
    debugLog("useTabs");
    var baseId = generateRandomId("aria-tabs-");
    //const getTabListId = useCallback(() => { return baseId + "-tab-list"; }, []);
    var getTabId = T$1(index => {
      return baseId + "-tab-" + index;
    }, []);
    var getPanelId = T$1(index => {
      return baseId + "-panel-" + index;
    }, []);
    // Used for the panels, not the tabs in the tablist.
    // Those are in useTabList itself.
    var {
      context: managedChildContext,
      managedChildrenReturn: panelChildrenReturn
    } = useManagedChildren({
      managedChildrenParameters: {
        onChildrenMountChange: useStableCallback((_m, _u) => {
          reevaluateClosestFit();
        })
      }
    });
    var {
      changeIndex: changeVisiblePanel,
      getCurrentIndex: getVisibleIndex,
      reevaluateClosestFit
    } = useChildrenFlag({
      getChildren: panelChildrenReturn.getChildren,
      closestFit: false,
      initialIndex: null,
      getAt: useStableCallback(i => {
        var _i$getVisible;
        return (_i$getVisible = i.getVisible()) !== null && _i$getVisible !== void 0 ? _i$getVisible : false; /*getPanels().getAt(i)?.getVisible() ?? false)*/
      }, []),
      setAt: useStableCallback((i, b) => {
        return i.setVisible(b); /*(getPanels().getAt(i)?.setVisible(b));*/
      }, []),
      isValid: returnTrue,
      onIndexChange: null
    });
    s(() => {
      changeVisiblePanel(singleSelectionParameters.initiallySelectedIndex);
    }, []);
    var {
      propsInput,
      propsLabel,
      randomIdInputReturn: {
        id: _inputId
      },
      randomIdLabelReturn: {
        id: _labelId
      }
    } = useLabelSynthetic({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: useStableCallback(() => listNavRet1.rovingTabIndexReturn.focusSelf())
      }),
      randomIdInputParameters: {
        prefix: Prefices.tablist
      },
      randomIdLabelParameters: {
        prefix: Prefices.tablistLabel
      }
    });
    var _useCompleteListNavig2 = useCompleteListNavigation({
        linearNavigationParameters: _objectSpread({
          navigationDirection: orientation
        }, linearNavigationParameters),
        rovingTabIndexParameters,
        singleSelectionParameters: _objectSpread({
          setSelectedIndex: useStableCallback((i, p) => {
            ssi === null || ssi === void 0 ? void 0 : ssi(i, p);
            changeVisiblePanel(i);
            listNavRet1.singleSelectionReturn.setSelectedIndex(i, p);
          })
        }, singleSelectionParameters),
        typeaheadNavigationParameters,
        rearrangeableChildrenParameters,
        sortableChildrenParameters
      }),
      {
        props: listNavigationSingleSelectionProps,
        context
      } = _useCompleteListNavig2,
      listNavRet1 = _objectWithoutProperties(_useCompleteListNavig2, _excluded67);
    var {
      singleSelectionReturn: {
        setSelectedIndex
      }
    } = listNavRet1;
    return {
      contextPanels: useStableObject(_objectSpread(_objectSpread({}, managedChildContext), {}, {
        tabPanelContext: useStableObject({
          getPanelId,
          getTabId,
          getVisibleIndex,
          setSelectedIndex
        })
      })),
      contextTabs: useStableObject(_objectSpread(_objectSpread({}, context), {}, {
        tabsContext: useStableObject({
          getTabId,
          getPanelId,
          getVisibleIndex,
          setSelectedIndex
        })
      })),
      propsContainer: useMergedProps(listNavigationSingleSelectionProps, propsInput, {
        role: role !== null && role !== void 0 ? role : "tablist",
        "aria-orientation": orientation !== null && orientation !== void 0 ? orientation : "horizontal"
      }),
      propsLabel
    };
  }
  function useTab(_ref81) {
    var {
        completeListNavigationChildParameters,
        managedChildParameters,
        pressParameters,
        textContentParameters,
        singleSelectionChildParameters: {
          selectionMode
        },
        rovingTabIndexChildParameters,
        sortableChildParameters,
        context
      } = _ref81,
      singleSelectionChildParameters = _objectWithoutProperties(_ref81.singleSelectionChildParameters, _excluded68);
    var _useCompleteListNavig3 = useCompleteListNavigationChild({
        completeListNavigationChildParameters,
        context,
        managedChildParameters,
        rovingTabIndexChildParameters,
        sortableChildParameters,
        textContentParameters,
        pressParameters,
        singleSelectionChildParameters: _objectSpread({
          ariaPropName: "aria-selected",
          selectionMode: selectionMode !== null && selectionMode !== void 0 ? selectionMode : "foucs"
        }, singleSelectionChildParameters)
      }),
      {
        props: listNavigationSingleSelectionChildProps
      } = _useCompleteListNavig3,
      listNavRet2 = _objectWithoutProperties(_useCompleteListNavig3, _excluded69);
    var {
      singleSelectionChildReturn: {
        selected
      },
      rovingTabIndexChildReturn: {
        tabbable
      }
    } = listNavRet2;
    var {
      getPanelId,
      getTabId,
      setSelectedIndex
    } = context.tabsContext;
    var panelId = getPanelId(managedChildParameters.index);
    var tabId = getTabId(managedChildParameters.index);
    debugLog("useTab", managedChildParameters.index, selected.toString());
    return _objectSpread({
      props: useMergedProps(listNavigationSingleSelectionChildProps, {
        "data-tabbable": tabbable.toString(),
        "data-selected": selected.toString(),
        role: "tab",
        "aria-controls": panelId,
        id: tabId
      })
    }, listNavRet2);
  }
  function useTabPanel(_ref82) {
    var {
      managedChildParameters,
      context
    } = _ref82;
    var {
      index
    } = managedChildParameters;
    debugLog("useTabPanel", index);
    var {
      tabPanelContext: {
        getVisibleIndex,
        getPanelId,
        getTabId
      }
    } = context;
    //const [correspondingTabId, setCorrespondingTabId] = useState<string | null>(null);
    var [isVisible, setIsVisible, getIsVisible] = useState(getVisibleIndex() == managedChildParameters.index);
    //const visibleRef = useRef<ChildFlagOperations>({ get: getIsVisible, set: setIsVisible, isValid: returnTrue });
    useManagedChild({
      context,
      managedChildParameters: {
        index
      }
    }, _objectSpread({
      getVisible: getIsVisible,
      setVisible: setIsVisible
    }, managedChildParameters));
    var panelId = getPanelId(managedChildParameters.index);
    var tabId = getTabId(managedChildParameters.index);
    return {
      props: useMergedProps({
        role: "tabpanel",
        "aria-labelledby": tabId,
        id: panelId,
        inert: !isVisible
      }),
      tabPanelReturn: {
        visible: isVisible,
        getVisible: getIsVisible
      }
    };
  }
  function useToasts(_ref83) {
    var {
      managedChildrenParameters: {
        onChildrenMountChange: ocmu,
        onAfterChildLayoutEffect
      },
      toastsParameters: {
        visibleCount
      }
    } = _ref83;
    debugLog("useToasts");
    // Normally, this does just look like [0, 1, 2, 3], etc
    // so it could be just an index to the current toast,
    // but if we dismiss toasts out of order, it's [0, 2, 3] or something.
    // So just keep track of it all in a big ol', there's only one of these on a page anyway,
    // and if you're pusing 10000 toasts at once an Array<number> isn't going to be your bottleneck.
    var currentIndexQueue = _([]);
    var [politeness, setPoliteness] = useState("polite");
    var getMaxVisibleCount = useStableGetter(visibleCount);
    var {
      refElementReturn: {
        getElement,
        propsStable
      }
    } = useRefElement({
      refElementParameters: {}
    });
    var _useManagedChildren = useManagedChildren({
        managedChildrenParameters: {
          onAfterChildLayoutEffect,
          onChildrenMountChange: ocmu
        }
      }),
      {
        context,
        managedChildrenReturn
      } = _useManagedChildren,
      _childInfo = _objectWithoutProperties(_useManagedChildren, _excluded70);
    var {
      getChildren: getToastQueue
    } = managedChildrenReturn;
    var toastQueue = getToastQueue();
    // When a toast is shown or hidden, always make sure that we're showing all the toasts that we should be.
    var showHighestPriorityToast = T$1(() => {
      var max = Math.min(getMaxVisibleCount(), currentIndexQueue.current.length);
      for (var _i6 = 0; _i6 < max; ++_i6) {
        var highestPriorityToast = toastQueue.getAt(currentIndexQueue.current[_i6]);
        console.assert(!!highestPriorityToast);
        highestPriorityToast === null || highestPriorityToast === void 0 ? void 0 : highestPriorityToast.show();
      }
    }, []);
    // Any time a new toast mounts, update our bottommostToastIndex to point to it if necessary
    // ("necessary" just meaning if it's the first toast ever or all prior toasts have been dismissed)
    var onAnyToastMounted = T$1(toastIndex => {
      var _toastQueue$getAt;
      currentIndexQueue.current.push(toastIndex);
      (_toastQueue$getAt = toastQueue.getAt(toastIndex)) === null || _toastQueue$getAt === void 0 ? void 0 : _toastQueue$getAt.setNumberAheadOfMe(currentIndexQueue.current.length - 1);
      showHighestPriorityToast();
    }, []);
    // Any time a toast is dismissed, update our bottommostToastIndex to point to the next toast in the queue, if one exists.
    var onAnyToastDismissed = T$1(_index => {
      var _toastQueue$getAt2;
      // When we dismiss a toast, remove it from the "to-display" queue by actually splicing it out of the array.
      // Then notify each toast of its change in position within that queue to keep the two in sync.
      var removalIndex = currentIndexQueue.current.findIndex(i => i == _index);
      // For all toasts that have already been dismissed, shift them even further back by one to "make space" 
      // (they're removed from the queue but this is the negative index they would have if we kept negatives in the queue)
      // for the newly-dismissed toast.
      toastQueue.forEach(c => {
        c.setNumberAheadOfMe(prev => {
          if (prev < 0) return prev - 1;else return prev;
        });
      });
      // Let this toast know that it's now the most recently dismissed toast
      (_toastQueue$getAt2 = toastQueue.getAt(_index)) === null || _toastQueue$getAt2 === void 0 ? void 0 : _toastQueue$getAt2.setNumberAheadOfMe(-1);
      // Notify all toasts waiting behind this one in the queue that they've moved up one slot
      toastQueue.forEach(c => {
        c.setNumberAheadOfMe(prev => {
          if (prev > removalIndex) return prev - 1;else return prev;
        });
      });
      // Actually modify the queue itself
      currentIndexQueue.current.splice(removalIndex, 1);
      // And after all that, make sure that we're showing any toasts that have been waiting in the queue
      showHighestPriorityToast();
    }, []);
    var [_mouseOver2, setMouseOver, _getMouseOver] = useState(false);
    useGlobalHandler(document, "pointermove", e => {
      var _getElement;
      var mouseOver = e.target != null && e.target instanceof Node && (((_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.contains(e.target)) || getElement() == e.target);
      setMouseOver(mouseOver);
    });
    // Any time the index pointing to the currently-showing toast changes,
    // update the relevant children and let them know that they're now either active or dismissed.
    /*const { changeIndex, reevaluateClosestFit } = useChildrenFlag<ToastInfo, "showing">({
        initialIndex: activeToastIndex,
        children: toastQueue,
        key: "showing",
        closestFit: false,
    });
    useEffect(() => {
        changeIndex(activeToastIndex);
    }, [activeToastIndex]);*/
    var toastContext = {
      onAnyToastDismissed,
      getMaxVisibleCount,
      setPoliteness,
      onAnyToastMounted
    };
    //function useToastContainerProps({ role, "aria-live": ariaLive, "aria-relevant": ariaRelevant, ...props }: h.JSX.HTMLAttributes<ContainerType>): h.JSX.HTMLAttributes<ContainerType> {
    var props = useMergedProps(useMergedProps(propsStable, {
      class: "toasts-container",
      role: "status",
      "aria-live": politeness !== null && politeness !== void 0 ? politeness : "polite",
      "aria-relevant": "additions"
    }));
    //}
    return {
      context: _objectSpread(_objectSpread({}, context), {}, {
        toastContext
      }),
      managedChildrenReturn,
      props
    };
  }
  function useToast(_ref84) {
    var {
        toastParameters: {
          politeness,
          timeout
        },
        managedChildParameters: {
          index
        },
        context
      } = _ref84,
      _managedChildParameters = _objectWithoutProperties(_ref84.managedChildParameters, _excluded71);
    var {
      getMaxVisibleCount,
      onAnyToastDismissed,
      setPoliteness,
      onAnyToastMounted
    } = context.toastContext;
    debugLog("useToast", index);
    var [numberOfToastsAheadOfUs, setNumberOfToastsAheadOfUs] = useState(Infinity);
    var getIndex = useStableGetter(index);
    var [dismissed2, setDismissed2, getDismissed2] = useState(false);
    var [showing2, setShowing2, getShowing2] = useState(false);
    //const [dismissed, setDismissed] = useState(false);
    //const [status, setStatus, getStatus] = useState<"pending" | "active" | "dismissed">("pending");
    //const dismissed = (status === "dismissed");
    var dismiss = T$1(() => {
      if (!getDismissed2()) onAnyToastDismissed(getIndex());
      setDismissed2(true);
      setShowing2(false);
    }, []);
    var show = T$1(() => {
      setShowing2(true);
    }, []);
    h(() => {
      if (!getDismissed2() && !getShowing2()) {
        if (numberOfToastsAheadOfUs >= 0 && numberOfToastsAheadOfUs < getMaxVisibleCount()) {
          show();
        }
      }
    }, [numberOfToastsAheadOfUs]);
    //const toastId = generateRandomId("toast-");
    s(() => {
      setPoliteness(politeness !== null && politeness !== void 0 ? politeness : "polite");
    }, [politeness]);
    var focus = T$1(() => {
      var element = getElement();
      if (element) {
        var _firstFocusable$focus;
        var firstFocusable = findFirstFocusable(element);
        firstFocusable === null || firstFocusable === void 0 ? void 0 : (_firstFocusable$focus = firstFocusable.focus) === null || _firstFocusable$focus === void 0 ? void 0 : _firstFocusable$focus.call(firstFocusable);
      }
    }, []);
    useManagedChild({
      managedChildParameters: {
        index
      },
      context
    }, {
      index,
      focus,
      setNumberAheadOfMe: setNumberOfToastsAheadOfUs,
      show
    });
    //const isActive = (status === "active");
    var [triggerIndex, setTriggerIndex] = useState(1);
    var resetDismissTimer = T$1(() => {
      setTriggerIndex(i => ++i);
    }, []);
    h(() => {
      onAnyToastMounted(index);
    }, []);
    /*useEffect(() => {
        if (!showing)
            onAnyToastDismissed(index)
    }, [showing]);*/
    var dismissTimeoutKey = timeout == null || numberOfToastsAheadOfUs != 0 ? null : isFinite(timeout) ? timeout : timeout > 0 ? null : 0;
    useTimeout({
      timeout: dismissTimeoutKey,
      callback: () => {
        if (showing2) dismiss();
      },
      triggerIndex: showing2 ? triggerIndex : false
    });
    var {
      refElementReturn: {
        getElement,
        propsStable
      }
    } = useRefElement({
      refElementParameters: {}
    });
    return {
      toastReturn: {
        dismissed: dismissed2,
        showing: showing2,
        numberOfToastsAheadOfUs,
        dismiss,
        resetDismissTimer
      },
      props: propsStable
    };
  }
  function useTooltip(_ref85) {
    var _mouseoverDelay, _mouseoutToleranceDel, _focusDelay;
    var {
      mouseoverDelay,
      mouseoutToleranceDelay,
      focusDelay
    } = _ref85;
    debugLog("useTooltip");
    (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
    (_mouseoutToleranceDel = mouseoutToleranceDelay) !== null && _mouseoutToleranceDel !== void 0 ? _mouseoutToleranceDel : mouseoutToleranceDelay = 500;
    (_focusDelay = focusDelay) !== null && _focusDelay !== void 0 ? _focusDelay : focusDelay = 1;
    // The escape key should close tooltips, but do nothing else.
    // (i.e. closing a tooltip in a dialog MUST NOT close the dialog too)
    // TODO: Tooltips are, effectively, always the topmost component,
    // so we can just have them listen to and swallow all "Escape"
    // key presses before anyone else. For a more general popup,
    // or a tooltip in a tooltip (!!) a different solution would be needed.
    useGlobalHandler(document, "keydown", e => {
      if (getOpen() && e.key === "Escape" && !e.defaultPrevented) {
        e.preventDefault();
        e.stopImmediatePropagation();
        setOpen(false);
        setHoverState("hidden");
        setTriggerFocusedDelayCorrected(false);
        setTooltipFocusedDelayCorrected(false);
      }
    }, {
      capture: true
    });
    var [open, setOpen, getOpen] = useState(false);
    var {
      propsReferencer: propsTrigger,
      propsSource: propsPopup
    } = useRandomId({
      randomIdParameters: {
        prefix: Prefices.tooltip,
        otherReferencerProp: "aria-describedby"
      }
    });
    var {
      refElementReturn: {
        getElement: getTriggerElement,
        propsStable: triggerRefProps
      }
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      refElementReturn: {
        getElement: getPopupElement,
        propsStable: popupRefProps
      }
    } = useRefElement({
      refElementParameters: {}
    });
    var [, setTriggerFocused] = usePassiveState(useStableCallback(focused => {
      var delay = focused ? focusDelay : 1;
      if (delay != null && isFinite(delay)) {
        var handle = setTimeout(() => setTriggerFocusedDelayCorrected(focused), focused ? focusDelay : 1);
        return () => clearTimeout(handle);
      }
    }), returnFalse);
    var [, setTooltipFocused] = usePassiveState(useStableCallback(focused => {
      var delay = focused ? focusDelay : 1;
      if (delay != null && isFinite(delay)) {
        var handle = setTimeout(() => setTooltipFocusedDelayCorrected(focused), delay);
        return () => clearTimeout(handle);
      }
    }), returnFalse);
    var onHoverChange = useStableCallback(function onHoverChange(hovering) {
      if (hovering) {
        switch (hoverState) {
          case "hiding":
            {
              // We're hoving over the tooltip right after hovering away from it.
              // In this case, we show it again immediately
              setHoverState("shown");
              break;
            }
          case "hidden":
            {
              // The tooltip isn't showing and hasn't for awhile (if ever)
              // Wait for our mouseover delay
              setHoverState("showing2");
              break;
              //const handle = setTimeout(() => { console.log("setHoverState(shown)");  setHoverState("shown") }, mouseoverDelay);
              //return () => clearTimeout(handle);
            }
        }
      } else {
        switch (hoverState) {
          case "shown":
            {
              // The mouse has left the trigger, but delay truly hiding it for a moment
              setHoverState("hiding");
              break;
              //const handle = setTimeout(() => { console.log("setHoverState(hidden)"); setHoverState("hidden");}, mouseoverDelay);
              //return () => clearTimeout(handle);
            }

          case "showing2":
            {
              // During a mouseover delay, when we mouseout,
              // just reset the timer
              setHoverState("hidden");
              break;
            }
        }
      }
    });
    var [, setTriggerHover] = usePassiveState(onHoverChange, returnFalse);
    var [, setTooltipHover] = usePassiveState(onHoverChange, returnFalse);
    var [triggerFocusedDelayCorrected, setTriggerFocusedDelayCorrected] = useState(false);
    var [hoverState, setHoverState] = useState("hidden");
    useTimeout({
      triggerIndex: hoverState,
      timeout: hoverState == "showing2" ? mouseoverDelay : null,
      callback: () => {
        if (hoverState == "showing2") {
          setHoverState("shown");
        }
      }
    });
    useTimeout({
      triggerIndex: hoverState,
      timeout: hoverState == "hiding" ? mouseoutToleranceDelay : null,
      callback: () => {
        if (hoverState == "hiding") {
          setHoverState("hidden");
        }
      }
    });
    //const [triggerHoverDelayCorrected, setTriggerHoverDelayCorrected] = useState(false);
    var [tooltipFocusedDelayCorrected, setTooltipFocusedDelayCorrected] = useState(false);
    //const [tooltipHoverDelayCorrected, setTooltipHoverDelayCorrected] = useState(false);
    var hoverDelayCorrected = hoverState == "shown";
    h(() => {
      setOpen(triggerFocusedDelayCorrected || hoverDelayCorrected || tooltipFocusedDelayCorrected);
    }, [triggerFocusedDelayCorrected || hoverDelayCorrected || tooltipFocusedDelayCorrected]);
    //const useTooltipTrigger: UseTooltipTrigger<TriggerType> = useCallback(function useTooltipTrigger({
    //    refElementReturn
    //}): ReturnType<UseTooltipTrigger<TriggerType>> {
    debugLog("useTooltipTrigger");
    //const { getElement } = refElementReturn;
    useGlobalHandler(document, "pointermove", e => {
      var _getTriggerElement;
      var target = e.target;
      setTriggerHover(target == getTriggerElement() || !!((_getTriggerElement = getTriggerElement()) !== null && _getTriggerElement !== void 0 && _getTriggerElement.contains(target)));
    }, {
      capture: true
    });
    function onTouchEnd(e) {
      var _e$target$focus, _e$target;
      (_e$target$focus = (_e$target = e.target).focus) === null || _e$target$focus === void 0 ? void 0 : _e$target$focus.call(_e$target);
    }
    //function useTooltipTriggerProps({ ...props }: h.JSX.HTMLAttributes<TriggerType>): h.JSX.HTMLAttributes<TriggerType> {
    //const { propsStable } = useRandomIdReferencerElement();
    // Note: Though it's important to make sure that focusing activates a tooltip,
    // it's perfectly reasonable that a child element will be the one that's focused,
    // not this one, so we don't set tabIndex=0
    //propsTrigger.tabIndex ??= -1;
    //}
    var {
      hasCurrentFocusReturn
    } = useHasCurrentFocus({
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged: setTriggerFocused,
        onCurrentFocusedChanged: null
      },
      refElementReturn: {
        getElement: getTriggerElement
      }
    });
    //return {
    //    useTooltipTriggerProps,
    //    hasCurrentFocusReturnType: { onCurrentFocusedInnerChanged: setTriggerFocused }
    //};
    //}, []);
    //const useTooltipPopup = useCallback(function useTooltip({ refElementReturn }: UseTooltipPopupParameters<PopupType>) {
    debugLog("useTooltipTooltip");
    //const { getElement } = refElementReturn;
    //const { propsStable } = useRandomIdSourceElement();
    var {
      hasCurrentFocusReturn: {
        propsStable: propsFocusPopup
      }
    } = useHasCurrentFocus({
      hasCurrentFocusParameters: {
        onCurrentFocusedChanged: null,
        onCurrentFocusedInnerChanged: useStableCallback(focused => {
          setTooltipFocused(focused);
        })
      },
      refElementReturn: {
        getElement: getPopupElement
      }
    });
    useGlobalHandler(document, "pointermove", e => {
      var _getPopupElement;
      var target = e.target;
      setTooltipHover(target == getPopupElement() || !!((_getPopupElement = getPopupElement()) !== null && _getPopupElement !== void 0 && _getPopupElement.contains(target)));
    }, {
      capture: true
    });
    //function useTooltipPopupProps(props: h.JSX.HTMLAttributes<PopupType>): h.JSX.HTMLAttributes<PopupType> {
    //    return useMergedProps(propsStable, props);
    // }
    //return { useTooltipPopupProps };
    //}, []);
    return {
      propsPopup: useMergedProps(popupRefProps, propsPopup, propsFocusPopup),
      propsTrigger: useMergedProps(triggerRefProps, propsTrigger, hasCurrentFocusReturn.propsStable, {
        onTouchEnd
      }),
      tooltipReturn: {
        isOpen: open,
        getIsOpen: getOpen
      }
    };
  }
  function memoForwardRef(fn) {
    return R(k(fn)); //(props: Parameters<T>[0]) => ReturnType<T>;
  }

  var ContextDefaults = {
    collator: B$2(null),
    pageNavigationSize: B$2(0.1),
    typeaheadTimeout: B$2(1000),
    noTypeahead: B$2(false),
    getIndex: B$2(v => v.props.index),
    disableArrowKeys: B$2(false),
    disableHomeEndKeys: B$2(false),
    getWindow: B$2(() => globalThis.window),
    focusOpener: B$2(e => {
      var _e$focus4;
      return e === null || e === void 0 ? void 0 : (_e$focus4 = e.focus) === null || _e$focus4 === void 0 ? void 0 : _e$focus4.call(e);
    }),
    getText: B$2(e => {
      var _e$textContent;
      return (_e$textContent = e === null || e === void 0 ? void 0 : e.textContent) !== null && _e$textContent !== void 0 ? _e$textContent : "";
    }),
    selectionMode: B$2("activation")
  };
  function useDefault(context, userValue) {
    var defaultValue = q(ContextDefaults[context]);
    return userValue !== null && userValue !== void 0 ? userValue : defaultValue;
  }
  var ParentDepthContext = B$2(0);
  var AccordionSectionContext = B$2(null);
  var Accordion = memoForwardRef(function Accordion(_ref86, ref) {
    var {
        disableArrowKeys,
        disableHomeEndKeys,
        initialIndex,
        navigationDirection,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        navigatePastEnd,
        navigatePastStart,
        pageNavigationSize,
        render
      } = _ref86,
      _rest = _objectWithoutProperties(_ref86, _excluded72);
    var info = useAccordion({
      accordionParameters: {
        initialIndex
      },
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        navigationDirection,
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange
      }
    });
    A(ref, () => info);
    return o$1(AccordionSectionContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  /*
  export function defaultRenderAccordionSection<HeaderContainerElement extends Element, HeaderButtonElement extends Element, BodyElement extends Element>({ makePropsHeadingContainer, makePropsHeadingButton, makePropsBody, tagBody, tagHeadingButton }: { tagHeadingButton: ElementToTag<HeaderButtonElement>; tagBody: ElementToTag<BodyElement>; makePropsHeadingContainer(info: UseAccordionSectionReturnType<HeaderButtonElement, BodyElement>): h.JSX.HTMLAttributes<HeaderContainerElement>, makePropsHeadingButton(info: UseAccordionSectionReturnType<HeaderButtonElement, BodyElement>): h.JSX.HTMLAttributes<HeaderButtonElement>, makePropsBody(info: UseAccordionSectionReturnType<HeaderButtonElement, BodyElement>): h.JSX.HTMLAttributes<BodyElement> }) {
      return function (info: UseAccordionSectionReturnType<HeaderButtonElement, BodyElement>): VNode<any> {
          return (
              <>
                  <Heading<HeaderContainerElement> {...makePropsHeadingContainer(info)} heading={createElement(tagHeadingButton as never, (makePropsHeadingButton(info)))}>
                      {createElement(tagBody as never, (makePropsBody(info)))}
                  </Heading>
              </>
          )
      }
  }*/
  var AccordionSection = memoForwardRef(function AccordionSection(_ref87, ref) {
    var {
      open,
      index,
      tagButton,
      disabled,
      bodyRole,
      onPress,
      exclude,
      hidden,
      render
    } = _ref87;
    var context = q(AccordionSectionContext);
    var info = useAccordionSection({
      buttonParameters: {
        disabled: disabled !== null && disabled !== void 0 ? disabled : false,
        tagButton,
        onPress: onPress !== null && onPress !== void 0 ? onPress : null
      },
      accordionSectionParameters: {
        open,
        bodyRole: bodyRole !== null && bodyRole !== void 0 ? bodyRole : "region"
      },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      pressParameters: {
        exclude
      },
      refElementParameters: {},
      context
    });
    A(ref, () => info);
    return render(info);
  });

  /*
  export function defaultRenderButton<E extends Element>({ tagButton, propsButton }: { tagButton: ElementToTag<E>, propsButton: (info: UseButtonReturnType<E>) => h.JSX.HTMLAttributes<E> }) {
      return function (info: UseButtonReturnType<E>) {
          return createElement(tagButton as any, propsButton(info));
      }
  }*/
  var Button = memoForwardRef(function Button(_ref88, ref) {
    var {
      tagButton,
      onPress,
      pressed,
      render,
      disabled,
      onElementChange,
      onMount,
      onUnmount,
      exclude
    } = _ref88;
    var info = useButton({
      buttonParameters: {
        role: "button",
        tagButton: tagButton,
        onPress: onPress !== null && onPress !== void 0 ? onPress : null,
        pressed,
        disabled: disabled !== null && disabled !== void 0 ? disabled : false
      },
      pressParameters: {
        exclude
      },
      refElementParameters: {
        onElementChange,
        onMount,
        onUnmount
      }
    });
    A(ref, () => info);
    return render(info);
  });
  function defaultRenderCheckboxLike(_ref89) {
    var {
      labelPosition,
      tagInput,
      tagLabel,
      makePropsInput,
      makePropsLabel
    } = _ref89;
    return function (info) {
      var inputProps = makePropsInput(info);
      var _makePropsLabel = makePropsLabel(info),
        {
          children
        } = _makePropsLabel,
        labelProps = _objectWithoutProperties(_makePropsLabel, _excluded73);
      if (labelPosition == "wrapping") {
        //const inputProps = modifyInputProps(makeInputProps(info));
        //const { children, ...labelProps } = modifyLabelProps(makeLabelProps(info));
        var input = h$1(tagInput, inputProps);
        var label = h$1(tagLabel, _objectSpread(_objectSpread({}, labelProps), {}, {
          children: o$1(p$1, {
            children: [input, children]
          })
        }));
        return o$1(p$1, {
          children: label
        });
      } else if (labelPosition == "separate") {
        var _input = h$1(tagInput, inputProps);
        var _label = h$1(tagLabel, _objectSpread({
          children
        }, labelProps));
        return o$1(p$1, {
          children: [_input, _label]
        });
      } else {
        console.assert(!!inputProps["aria-label"]);
        return h$1(tagInput, inputProps);
      }
    };
  }
  /*
  export interface DefaultRenderCheckboxParameters<I extends Element, L extends Element> extends DefaultRenderCheckboxLikeParameters<I, L, UseCheckboxReturnType<I, L>> { }
   export function defaultRenderCheckbox<I extends Element, L extends Element>({ labelPosition, tagInput, tagLabel, makePropsInput, makePropsLabel }: DefaultRenderCheckboxParameters<I, L>) {
      return defaultRenderCheckboxLike<I, L, UseCheckboxReturnType<I, L>>({ labelPosition, tagInput, tagLabel, makePropsInput, makePropsLabel });
  }*/
  var Checkbox = memoForwardRef(function Checkbox(_ref90, ref) {
    var {
      checked,
      disabled,
      tagLabel,
      labelPosition,
      tagInput,
      ariaLabel,
      onCheckedChange,
      render
    } = _ref90;
    var {
      refElementReturn: refElementInputReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      refElementReturn: refElementLabelReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var checkbox = useCheckbox({
      checkboxLikeParameters: {
        checked: checked !== null && checked !== void 0 ? checked : false,
        disabled: disabled !== null && disabled !== void 0 ? disabled : false
      },
      checkboxParameters: {
        onCheckedChange
      },
      labelParameters: {
        ariaLabel: ariaLabel,
        labelPosition,
        tagInput,
        tagLabel
      },
      refElementInputReturn,
      refElementLabelReturn
    });
    A(ref, () => checkbox);
    return render(checkbox);
  });

  /*
  export function defaultRenderCheckboxGroupParent<InputType extends Element, LabelType extends Element>({ render, disabled, getDocument, labelPosition, tagInput, tagLabel, getWindow, onActiveElementChange, onCheckedChangeStart, onCheckedChangeEnd, onElementChange, onFocusedChanged, onFocusedInnerChanged, onLastActiveElementChange, onLastFocusedChanged, onLastFocusedInnerChanged, onMount, onUnmount, onWindowFocusedChange }: Foo<InputType, LabelType>) {
      return function (parentInfo: UseCheckboxGroupParentReturnTypeInfo, modifyControlProps: PropModifier<any>) {
          const { checkboxGroupParent: { checked, onParentCheckedChange } } = parentInfo;
          return (
              <Checkbox<InputType, LabelType>
                  checked={checked}
                  disabled={disabled}
                  getDocument={getDocument}
                  labelPosition={labelPosition}
                  render={(info, modifyInputProps, modifyLabelProps) => {
                      if (labelPosition == "separate")
                          return render(info, (props) => modifyControlProps(modifyInputProps(props)), modifyLabelProps)
                      else
                          return render(info, modifyInputProps, (props) => modifyControlProps(modifyLabelProps(props) as any) as any)
                  }}
                  tagInput={tagInput}
                  tagLabel={tagLabel}
                  getWindow={getWindow}
                  onActiveElementChange={onActiveElementChange}
                  onCheckedChange={e => {
                      let exception: any;
                      onCheckedChangeStart();
                      (async () => {
                           try {
                              await onParentCheckedChange(e);
                          }
                          catch (ex) {
                              exception = ex;
                          }
                          finally {
                              onCheckedChangeEnd(exception);
                          }
                      }
                       )()
                   }}
                  onElementChange={onElementChange}
                  onFocusedChanged={onFocusedChanged}
                  onFocusedInnerChanged={onFocusedInnerChanged}
                  onLastActiveElementChange={onLastActiveElementChange}
                  onLastFocusedChanged={onLastFocusedChanged}
                  onLastFocusedInnerChanged={onLastFocusedInnerChanged}
                  onMount={onMount}
                  onUnmount={onUnmount}
                  onWindowFocusedChange={onWindowFocusedChange}
              />
          )
      }
  }
   export function defaultRenderCheckboxGroup<InputType extends HTMLElement, LabelType extends HTMLElement, C, K extends string>({ children, labelPosition, makeInputProps, makeLabelProps, tagInput, tagLabel }: DefaultRenderCheckboxGroupParameters<InputType, LabelType, C, K>) {
      return function (info: UseCheckboxGroupReturnTypeInfo<InputType, LabelType, C, K>, modifyInputProps: PropModifier<InputType>, modifyLabelProps: PropModifier<LabelType>): VNode<any> {
          return (
              <>
                  {defaultRenderCheckboxLike({ labelPosition, makeInputProps, makeLabelProps, tagInput, tagLabel })(info, modifyInputProps, modifyLabelProps)}
                  {children}
              </>
          )
      }
  }*/
  var UseCheckboxGroupChildContext = B$2(null);
  var CheckboxGroup = memoForwardRef(function CheckboxGroup(_ref91, ref) {
    var {
        render,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        onTabbableIndexChange,
        compare,
        getIndex,
        untabbable,
        navigatePastEnd,
        navigatePastStart,
        pageNavigationSize,
        children
      } = _ref91,
      _rest = _objectWithoutProperties(_ref91, _excluded74);
    var info = useCheckboxGroup({
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        navigationDirection,
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      }
    });
    A(ref, () => info);
    return o$1(UseCheckboxGroupChildContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  var CheckboxGroupParent = memoForwardRef(function CheckboxGroupParent(_ref92, ref) {
    var {
        render,
        index,
        focusSelf,
        exclude,
        hidden,
        getText,
        onPressSync,
        getSortValue
      } = _ref92,
      _rest = _objectWithoutProperties(_ref92, _excluded75);
    var context = q(UseCheckboxGroupChildContext);
    var info = useCheckboxGroupParent({
      completeListNavigationChildParameters: {
        checkboxInfo: {
          checkboxChildType: "parent"
        }
      },
      context,
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue
      },
      pressParameters: {
        exclude,
        onPressSync,
        focusSelf
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      }
    });
    A(ref, () => info);
    return render(info);
  });
  var CheckboxGroupChild = memoForwardRef(function CheckboxGroupChild(_ref93, ref) {
    var {
        index,
        exclude,
        onPressSync,
        render,
        checked,
        onChangeFromParent,
        getSortValue,
        hidden,
        getText,
        focusSelf
      } = _ref93,
      _rest = _objectWithoutProperties(_ref93, _excluded76);
    var context = q(UseCheckboxGroupChildContext);
    var info = useCheckboxGroupChild({
      checkboxGroupChild: {
        checked,
        onChangeFromParent
      },
      completeListNavigationChildParameters: {},
      textContentParameters: {
        getText: useDefault("getText", getText)
      },
      context,
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue
      },
      pressParameters: {
        exclude,
        onPressSync,
        focusSelf
      }
    });
    A(ref, () => info);
    return render(info);
  });
  function defaultRenderPortal(_ref94) {
    var _portalRef$current;
    var {
      portalId,
      children
    } = _ref94;
    var portalRef = _(null);
    (_portalRef$current = portalRef.current) !== null && _portalRef$current !== void 0 ? _portalRef$current : portalRef.current = document.getElementById(portalId);
    if (portalRef.current) return j(children, portalRef.current);else return children;
  }
  /*
  export function defaultRenderModal<FocusContainerElement extends HTMLElement, DialogElement extends HTMLElement, TitleElement extends HTMLElement, BodyElement extends HTMLElement, BackdropElement extends HTMLElement, InfoType>({ portalId, tagFocusContainer, tagBackdrop, tagBody, tagDialog, tagTitle, makePropsFocusContainer, makePropsBackdrop, makePropsBody, makePropsDialog, makePropsTitle }: { portalId: string, tagFocusContainer: ElementToTag<FocusContainerElement>, tagDialog: ElementToTag<DialogElement>; tagTitle: ElementToTag<TitleElement>; tagBody: ElementToTag<BodyElement>; tagBackdrop: ElementToTag<BackdropElement>, makePropsFocusContainer: (info: InfoType) => h.JSX.HTMLAttributes<FocusContainerElement>, makePropsDialog: (info: InfoType) => h.JSX.HTMLAttributes<DialogElement>, makePropsBody: (info: InfoType) => h.JSX.HTMLAttributes<BodyElement>, makePropsTitle: (info: InfoType) => h.JSX.HTMLAttributes<TitleElement>, makePropsBackdrop: (info: InfoType) => h.JSX.HTMLAttributes<BackdropElement> }) {
      return function (dialogInfo: InfoType): VNode<any> {
           const { children: titleChildren, ...titleProps } = (makePropsTitle(dialogInfo));
          const { children: bodyChildren, ...bodyProps } = (makePropsBody(dialogInfo));
          const { children: dialogChildren, ...dialogProps } = (makePropsDialog(dialogInfo));
          const { children: backdropChildren, ...backdropProps } = (makePropsBackdrop(dialogInfo));
          const { children: focusContainerChildren, ...focusContainerProps } = (makePropsFocusContainer(dialogInfo));
           const title = createElement(tagTitle as never, titleProps, titleChildren);
          const body = createElement(tagBody as never, bodyProps, bodyChildren);
          const dialog = createElement(tagDialog as never, dialogProps, dialogChildren, title, body);
           const backdrop = createElement(tagBackdrop as never, backdropProps, backdropChildren);
          const focusContainer = createElement(tagFocusContainer as never, focusContainerProps, <div>{focusContainerChildren}{dialog}{backdrop}</div>);
           return defaultRenderPortal({
              portalId,
              children: focusContainer
          });
      }
  }*/
  /*
  export function defaultRenderDialog<FocusContainerElement extends HTMLElement, DialogElement extends HTMLElement, TitleElement extends HTMLElement, BodyElement extends HTMLElement, BackdropElement extends HTMLElement>({ portalId, tagFocusContainer, tagBackdrop, tagBody, tagDialog, tagTitle, makePropsFocusContainer, makePropsBackdrop, makePropsBody, makePropsDialog, makePropsTitle }: { portalId: string, tagFocusContainer: ElementToTag<FocusContainerElement>, tagDialog: ElementToTag<DialogElement>; tagTitle: ElementToTag<TitleElement>; tagBody: ElementToTag<BodyElement>; tagBackdrop: ElementToTag<BackdropElement>, makePropsFocusContainer: (info: UseDialogReturnType<FocusContainerElement, DialogElement>) => h.JSX.HTMLAttributes<FocusContainerElement>, makePropsDialog: (info: UseDialogReturnType<FocusContainerElement, DialogElement>) => h.JSX.HTMLAttributes<DialogElement>, makePropsBody: (info: UseDialogReturnType<FocusContainerElement, DialogElement>) => h.JSX.HTMLAttributes<BodyElement>, makePropsTitle: (info: UseDialogReturnType<FocusContainerElement, DialogElement>) => h.JSX.HTMLAttributes<TitleElement>, makePropsBackdrop: (info: UseDialogReturnType<FocusContainerElement, DialogElement>) => h.JSX.HTMLAttributes<BackdropElement> }) {
      return defaultRenderModal<FocusContainerElement, DialogElement, TitleElement, BodyElement, BackdropElement, UseDialogReturnType<FocusContainerElement, DialogElement>>({ portalId, tagFocusContainer, tagBackdrop, tagBody, tagDialog, tagTitle, makePropsFocusContainer, makePropsBackdrop, makePropsBody, makePropsDialog, makePropsTitle });
  }*/
  var Dialog = memoForwardRef(function Dialog(_ref95, ref) {
    var {
      onClose,
      open,
      closeOnBackdrop,
      closeOnEscape,
      focusOpener,
      getWindow,
      parentDepth,
      focusPopup,
      ariaLabel,
      render
    } = _ref95;
    var defaultParentDepth = q(ParentDepthContext);
    var myDepth = (parentDepth !== null && parentDepth !== void 0 ? parentDepth : defaultParentDepth) + 1;
    var info = useDialog({
      dismissParameters: {
        closeOnBackdrop: closeOnBackdrop !== null && closeOnBackdrop !== void 0 ? closeOnBackdrop : true,
        closeOnEscape: closeOnEscape !== null && closeOnEscape !== void 0 ? closeOnEscape : true,
        onClose,
        open
      },
      escapeDismissParameters: {
        getWindow: useDefault("getWindow", getWindow),
        parentDepth: parentDepth !== null && parentDepth !== void 0 ? parentDepth : defaultParentDepth
      },
      focusTrapParameters: {
        focusOpener: useDefault("focusOpener", focusOpener),
        focusPopup
      },
      labelParameters: {
        ariaLabel
      }
    });
    A(ref, () => info);
    return o$1(ParentDepthContext.Provider, {
      value: myDepth,
      children: render(info)
    });
  });

  /*
  export function defaultRenderDrawer<FocusContainerElement extends HTMLElement, DrawerElement extends HTMLElement, TitleElement extends HTMLElement, BodyElement extends HTMLElement, BackdropElement extends HTMLElement>({ portalId, tagFocusContainer, tagBackdrop, tagBody, tagDialog, tagTitle, makePropsFocusContainer, makePropsBackdrop, makePropsBody, makePropsDialog, makePropsTitle }: { portalId: string, tagFocusContainer: ElementToTag<FocusContainerElement>, tagDialog: ElementToTag<DrawerElement>; tagTitle: ElementToTag<TitleElement>; tagBody: ElementToTag<BodyElement>; tagBackdrop: ElementToTag<BackdropElement>, makePropsFocusContainer: (info: UseDrawerReturnType<FocusContainerElement, DrawerElement>) => h.JSX.HTMLAttributes<FocusContainerElement>, makePropsDialog: (info: UseDrawerReturnType<FocusContainerElement, DrawerElement>) => h.JSX.HTMLAttributes<DrawerElement>, makePropsBody: (info: UseDrawerReturnType<FocusContainerElement, DrawerElement>) => h.JSX.HTMLAttributes<BodyElement>, makePropsTitle: (info: UseDrawerReturnType<FocusContainerElement, DrawerElement>) => h.JSX.HTMLAttributes<TitleElement>, makePropsBackdrop: (info: UseDrawerReturnType<FocusContainerElement, DrawerElement>) => h.JSX.HTMLAttributes<BackdropElement> }) {
      return defaultRenderModal<FocusContainerElement, DrawerElement, TitleElement, BodyElement, BackdropElement, UseDrawerReturnType<FocusContainerElement, DrawerElement>>({ portalId, makePropsFocusContainer, makePropsBackdrop, makePropsBody, makePropsDialog, makePropsTitle, tagFocusContainer, tagBackdrop, tagBody, tagDialog, tagTitle });
  }*/
  memoForwardRef(function Drawer(_ref96, ref) {
    var {
      closeOnBackdrop,
      closeOnEscape,
      closeOnLostFocus,
      focusOpener,
      focusPopup,
      getWindow,
      onClose,
      open,
      parentDepth,
      render,
      trapActive,
      ariaLabel
    } = _ref96;
    var defaultParentDepth = q(ParentDepthContext);
    var info = useDrawer({
      dismissParameters: {
        closeOnBackdrop: closeOnBackdrop !== null && closeOnBackdrop !== void 0 ? closeOnBackdrop : true,
        closeOnEscape: closeOnEscape !== null && closeOnEscape !== void 0 ? closeOnEscape : true,
        closeOnLostFocus: closeOnLostFocus !== null && closeOnLostFocus !== void 0 ? closeOnLostFocus : true,
        onClose,
        open
      },
      escapeDismissParameters: {
        getWindow: useDefault("getWindow", getWindow),
        parentDepth: parentDepth !== null && parentDepth !== void 0 ? parentDepth : defaultParentDepth
      },
      focusTrapParameters: {
        focusOpener: useDefault("focusOpener", focusOpener),
        focusPopup,
        trapActive: trapActive !== null && trapActive !== void 0 ? trapActive : false
      },
      labelParameters: {
        ariaLabel
      }
    });
    A(ref, () => info);
    return render(info);
  });

  //const LocationIndexContext = createContext(0);
  //const SetManglersContext = createContext<(m: (n: number) => number, d: (n: number) => number) => void>(null!);
  //const GridlistSectionContext = createContext<UseGridlistSection<any, any, any, any, any, any>>(null!);
  var GridlistContext = B$2(null);
  var GridlistRowContext = B$2(null);
  memoForwardRef(function GridlistU(_ref97, ref) {
    var {
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      noTypeahead,
      onTabbableIndexChange,
      groupingType,
      typeaheadTimeout,
      selectedIndex,
      navigatePastEnd,
      navigatePastStart,
      setSelectedIndex,
      pageNavigationSize,
      selectionLimit,
      untabbable,
      compare,
      getIndex,
      onTabbableColumnChange,
      ariaLabel,
      render
    } = _ref97;
    var info = useGridlist({
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      },
      /*singleSelectionParameters: {
          initiallySelectedIndex: initiallySelectedIndex ?? null,
          setSelectedIndex: setSelectedIndex ?? null
      },*/
      gridlistParameters: {
        selectionLimit,
        groupingType,
        selectedIndex,
        setSelectedIndex: setSelectedIndex !== null && setSelectedIndex !== void 0 ? setSelectedIndex : noop$1
      },
      gridNavigationParameters: {
        onTabbableColumnChange: onTabbableColumnChange !== null && onTabbableColumnChange !== void 0 ? onTabbableColumnChange : noop$1
      },
      labelParameters: {
        ariaLabel
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      }
    });
    A(ref, () => info);
    return o$1(GridlistContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  function noop$1() {}
  /*
  export const GridlistSection = memoForwardRef(function GridlistSectionU<SectionElement extends Element, RowElement extends Element, Cellement extends Element, CR = undefined, CC = undefined, KR extends string = never>({ render, compareRows, index }: GridlistSectionProps<SectionElement, RowElement, Cellement, CR, CC, KR>, ref?: Ref<any>) {
      const { useGridlistSectionProps, ...sectionInfo } = useContext(GridlistSectionContext)//({ compareRows });
      useImperativeHandle(ref!, () => sectionInfo);
      return <LocationIndexContext.Provider value={index}>{render(sectionInfo, useGridlistSectionProps)}</LocationIndexContext.Provider>
  })*/
  memoForwardRef(function GridlistRowU(_ref98, ref) {
    var {
      index,
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      ariaPropName,
      disabled,
      hidden,
      navigatePastEnd,
      navigatePastStart,
      noTypeahead,
      onTabbableIndexChange,
      selected,
      selectionMode,
      typeaheadTimeout,
      untabbable,
      getSortValue,
      getText,
      render
    } = _ref98;
    var context = q(GridlistContext);
    var info = useGridlistRow({
      rowAsChildOfGridParameters: {
        completeGridNavigationRowParameters: {},
        context,
        managedChildParameters: {
          index
        },
        gridlistRowParameters: {
          selected: selected !== null && selected !== void 0 ? selected : null
        },
        rovingTabIndexChildParameters: {
          hidden: hidden !== null && hidden !== void 0 ? hidden : false
        },
        sortableChildParameters: {
          getSortValue
        },
        singleSelectionChildParameters: {
          disabled: disabled !== null && disabled !== void 0 ? disabled : false,
          ariaPropName,
          selectionMode: useDefault("selectionMode", selectionMode)
        },
        textContentParameters: {
          getText: useDefault("getText", getText)
        }
      },
      rowAsParentOfCellsParameters: {
        linearNavigationParameters: {
          disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
          disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
          navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
          navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap"
        },
        rovingTabIndexParameters: {
          onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
          untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
        },
        typeaheadNavigationParameters: {
          collator: useDefault("collator", collator),
          noTypeahead: useDefault("noTypeahead", noTypeahead),
          typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
        }
      }
      // gridlistRowContext,
    });

    A(ref, () => info);
    return o$1(GridlistRowContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  memoForwardRef(function GridlistChild(_ref99, ref) {
    var {
      index,
      colSpan,
      exclude,
      focusSelf,
      hidden,
      onPressSync,
      getText,
      render
    } = _ref99;
    var context = q(GridlistRowContext);
    var info = useGridlistCell({
      completeGridNavigationCellParameters: {},
      context,
      gridNavigationCellParameters: {
        colSpan: colSpan !== null && colSpan !== void 0 ? colSpan : 1
      },
      pressParameters: {
        exclude,
        focusSelf,
        onPressSync
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      }
    });
    A(ref, () => info);
    return render(info);
  });
  function useListbox(_ref100) {
    var {
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      sortableChildrenParameters,
      typeaheadNavigationParameters,
      labelParameters,
      listboxParameters: {
        selectionLimit,
        groupingType,
        selectedIndex,
        setSelectedIndex
      }
    } = _ref100;
    useEnsureStability("useListbox", selectionLimit);
    var {
      propsInput: propsLabelList,
      propsLabel: propsLabelLabel,
      randomIdInputReturn: {
        id: _inputId
      },
      randomIdLabelReturn: {
        id: _labelId
      }
    } = useLabelSynthetic({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: useStableCallback(() => {
          rovingTabIndexReturn.focusSelf();
        })
      }),
      randomIdInputParameters: {
        prefix: Prefices.listbox
      },
      randomIdLabelParameters: {
        prefix: Prefices.listboxLabel
      }
    });
    var {
      childrenHaveFocusReturn,
      context,
      linearNavigationReturn,
      managedChildrenReturn,
      props,
      rearrangeableChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn
    } = useCompleteListNavigation({
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      singleSelectionParameters: {
        initiallySelectedIndex: selectedIndex,
        setSelectedIndex
      },
      sortableChildrenParameters,
      typeaheadNavigationParameters
    });
    useSingleSelectionDeclarative({
      singleSelectionDeclarativeParameters: {
        selectedIndex
      },
      singleSelectionReturn: {
        setSelectedIndex: singleSelectionReturn.setSelectedIndex
      }
    });
    if (groupingType == "group") props.role = "group";else if (groupingType == "with-groups") {
      // Intentionally clobbering all the list navigation stuff.
      props = {
        role: "listbox"
      };
      // ...actually, context too while we're at it.
      context = null;
    } else {
      props.role = "listbox";
    }
    if (selectionLimit == "multi") console.assert(singleSelectionReturn.getSelectedIndex() == null);
    return {
      childrenHaveFocusReturn,
      context: useStableObject(_objectSpread(_objectSpread({}, context), {}, {
        listboxContext: useStableObject({
          selectionLimit
        })
      })),
      linearNavigationReturn,
      managedChildrenReturn,
      rearrangeableChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn,
      propsListbox: useMergedProps(props, propsLabelList, {
        "aria-multiselectable": selectionLimit == "multi" ? "true" : undefined
      }),
      propsListboxLabel: propsLabelLabel
    };
  }
  function useListboxItem(_ref101) {
    var {
        completeListNavigationChildParameters,
        pressParameters,
        context: {
          listboxContext: {
            selectionLimit
          }
        },
        managedChildParameters,
        singleSelectionChildParameters,
        rovingTabIndexChildParameters,
        sortableChildParameters,
        textContentParameters,
        listboxParameters: {
          selected
        }
      } = _ref101,
      context = _objectWithoutProperties(_ref101.context, _excluded77);
    var {
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      props,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
    } = useCompleteListNavigationChild({
      completeListNavigationChildParameters,
      textContentParameters,
      managedChildParameters,
      pressParameters,
      singleSelectionChildParameters,
      rovingTabIndexChildParameters,
      sortableChildParameters,
      context
    });
    if (selectionLimit == "single") console.assert(selected == null);
    props.role = "option";
    return {
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      props,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
    };
  }
  /*
  export function useListboxGroup<ContainerElement extends Element, HeadingElement extends Element>() {
      const {
          propsReferencer,
          propsSource,
          randomIdReturn
      } = useRandomId<HeadingElement, ContainerElement>({ randomIdParameters: { prefix: "listbox-multi-group-", otherReferencerProp: "aria-labelledby" } });
       propsReferencer.role = "group";
       return {
          propsHeading: propsSource,
          propsContainer: propsReferencer
      }
  }*/

  var ListboxContext = B$2(null);
  function Listbox(_ref102) {
    var {
      ariaLabel,
      collator,
      compare,
      disableArrowKeys,
      disableHomeEndKeys,
      getIndex,
      selectedIndex,
      navigatePastEnd,
      navigatePastStart,
      navigationDirection,
      noTypeahead,
      setSelectedIndex,
      onTabbableIndexChange,
      pageNavigationSize,
      selectionLimit,
      groupingType,
      untabbable,
      typeaheadTimeout,
      render
    } = _ref102;
    var info = useListbox({
      labelParameters: {
        ariaLabel
      },
      linearNavigationParameters: {
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        navigationDirection,
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      listboxParameters: {
        selectionLimit,
        groupingType,
        selectedIndex,
        setSelectedIndex: setSelectedIndex !== null && setSelectedIndex !== void 0 ? setSelectedIndex : noop
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      //singleSelectionParameters: { initiallySelectedIndex: initiallySelectedIndex ?? null, setSelectedIndex: setSelectedIndex ?? null },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      }
    });
    return o$1(ListboxContext.Provider, {
      value: info.context,
      children: render(info)
    });
  }
  function noop() {}
  function ListboxItem(_ref103) {
    var {
      ariaPropName,
      disabled,
      exclude,
      focusSelf,
      getText,
      hidden,
      index,
      onPressSync,
      render,
      selected,
      selectionMode,
      getSortValue
    } = _ref103;
    var context = q(ListboxContext);
    var focusSelfDefault = T$1(e => {
      e === null || e === void 0 ? void 0 : e.focus();
    }, []);
    var info = useListboxItem({
      completeListNavigationChildParameters: {},
      context,
      listboxParameters: {
        selected: selected !== null && selected !== void 0 ? selected : null
      },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue: getSortValue
      },
      pressParameters: {
        exclude,
        focusSelf: focusSelf !== null && focusSelf !== void 0 ? focusSelf : focusSelfDefault,
        onPressSync
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      },
      singleSelectionChildParameters: {
        disabled: disabled !== null && disabled !== void 0 ? disabled : false,
        ariaPropName,
        selectionMode: useDefault("selectionMode", selectionMode)
      }
    });
    return render(info);
  }
  var MenuItemContext = B$2(null);
  memoForwardRef(function MenubarU(_ref104, ref) {
    var {
      render,
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      navigatePastEnd,
      navigatePastStart,
      pageNavigationSize,
      orientation,
      noTypeahead,
      onTabbableIndexChange,
      compare,
      getIndex,
      untabbable,
      initiallySelectedIndex,
      setSelectedIndex,
      typeaheadTimeout,
      role
    } = _ref104;
    var info = useMenubar({
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      toolbarParameters: {
        orientation
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      singleSelectionParameters: {
        initiallySelectedIndex: initiallySelectedIndex !== null && initiallySelectedIndex !== void 0 ? initiallySelectedIndex : null,
        setSelectedIndex: setSelectedIndex !== null && setSelectedIndex !== void 0 ? setSelectedIndex : null
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      menubarParameters: {
        role: role !== null && role !== void 0 ? role : "menubar"
      }
    });
    A(ref, () => info);
    return o$1(MenuItemContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  var MenuItem = memoForwardRef(function MenuItemU(_ref105, ref) {
    var {
      index,
      render,
      ariaPropName,
      exclude,
      selectionMode,
      hidden,
      getText,
      disabled,
      onPress,
      getSortValue,
      role
    } = _ref105;
    var context = q(MenuItemContext); /*<MenuItemElement, C, K>)({
                                      managedChild: { index, flags },
                                      rovingTabIndex: { focusSelf, hidden, noModifyTabIndex },
                                      listNavigation: { text },
                                      hasFocus: { getDocument, getWindow, onActiveElementChange, onElementChange, onFocusedChanged, onFocusedInnerChanged, onLastActiveElementChange, onLastFocusedChanged, onLastFocusedInnerChanged, onMount, onUnmount, onWindowFocusedChange },
                                      menuItem: { disabled, onPress, role },
                                      subInfo
                                      });*/
    var info = useMenuItem({
      completeListNavigationChildParameters: {},
      context,
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      },
      menuItemParameters: {
        onPress: onPress !== null && onPress !== void 0 ? onPress : null,
        role: role !== null && role !== void 0 ? role : "menuitem"
      },
      pressParameters: {
        exclude
      },
      singleSelectionChildParameters: {
        ariaPropName,
        selectionMode,
        disabled: disabled !== null && disabled !== void 0 ? disabled : false
      }
    });
    A(ref, () => info);
    return o$1(p$1, {
      children: render(info)
    });
  });

  //const MenuItemContext = createContext<UseMenuItem<any, any, any>>(null!);
  var Menu = memoForwardRef(function Menu(_ref106, ref) {
    var {
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      noTypeahead,
      typeaheadTimeout,
      orientation,
      onClose,
      open,
      openDirection,
      onTabbableIndexChange,
      closeOnBackdrop,
      closeOnEscape,
      closeOnLostFocus,
      compare,
      getIndex,
      initiallySelectedIndex,
      navigatePastEnd,
      navigatePastStart,
      setSelectedIndex,
      pageNavigationSize,
      parentDepth,
      untabbable,
      onOpen,
      getWindow,
      render
    } = _ref106;
    var defaultParentDepth = q(ParentDepthContext);
    var myDepth = (parentDepth !== null && parentDepth !== void 0 ? parentDepth : defaultParentDepth) + 1;
    var info = useMenu({
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize),
        navigatePastEnd: "wrap",
        navigatePastStart: "wrap"
      },
      dismissParameters: {
        closeOnBackdrop: closeOnBackdrop !== null && closeOnBackdrop !== void 0 ? closeOnBackdrop : true,
        closeOnEscape: closeOnEscape !== null && closeOnEscape !== void 0 ? closeOnEscape : true,
        closeOnLostFocus: closeOnLostFocus !== null && closeOnLostFocus !== void 0 ? closeOnLostFocus : true,
        onClose,
        open
      },
      escapeDismissParameters: {
        getWindow: useDefault("getWindow", getWindow),
        parentDepth: parentDepth !== null && parentDepth !== void 0 ? parentDepth : defaultParentDepth
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      singleSelectionParameters: {
        initiallySelectedIndex: initiallySelectedIndex !== null && initiallySelectedIndex !== void 0 ? initiallySelectedIndex : null,
        setSelectedIndex: setSelectedIndex !== null && setSelectedIndex !== void 0 ? setSelectedIndex : null
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      menuParameters: {
        openDirection,
        onOpen
      },
      menuSurfaceParameters: {},
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      },
      toolbarParameters: {
        orientation
      },
      menubarParameters: {}
    });
    A(ref, () => info);
    //const { useMenuSentinelProps: useFirstSentinelProps } = useMenuSentinel<SentinelElement>();
    //const { useMenuSentinelProps: useLastSentinelProps } = useMenuSentinel<SentinelElement>();
    return o$1(ParentDepthContext.Provider, {
      value: myDepth,
      children: o$1(MenuItemContext.Provider, {
        value: info.context,
        children: render(info)
      })
    });
  });
  var RadioContext = B$2(null);
  var RadioGroup = memoForwardRef(function RadioGroup(_ref107, ref) {
    var {
      render,
      name,
      setSelectedValue,
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      navigationDirection,
      noTypeahead,
      typeaheadTimeout,
      ariaLabel,
      compare,
      getIndex,
      navigatePastEnd,
      navigatePastStart,
      selectedValue,
      untabbable,
      onTabbableIndexChange,
      pageNavigationSize
    } = _ref107;
    var info = useRadioGroup({
      linearNavigationParameters: {
        navigationDirection,
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      labelParameters: {
        ariaLabel
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      radioGroupParameters: {
        name,
        setSelectedValue,
        selectedValue
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      }
      // childrenHaveFocusParameters: {  },
      //        singleSelectionParameters: {  }
    });

    A(ref, () => info);
    return o$1(RadioContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  /*export interface DefaultRenderRadioParameters<LP extends LabelPosition, V extends string | number, I extends Element, IL extends Element, TCE extends Element> extends DefaultRenderCheckboxLikeParameters<I, IL, UseRadioReturnType<LP, V, I, IL, TCE, RadioSubInfo<TCE, V>>> {
   }*/
  /*
  export function defaultRenderRadio<V extends string | number, I extends HTMLElement, IL extends HTMLElement, TCE extends I | IL>({ tagInput, tagLabel, makePropsInput, makePropsLabel, labelPosition }: DefaultRenderRadioParameters<V, I, IL, TCE>) {
      return defaultRenderCheckboxLike<I, IL, UseRadioReturnType<V, I, IL, TCE, RadioSubInfo<TCE, V>>>({ labelPosition, tagInput, tagLabel, makePropsInput, makePropsLabel });
  }
  */
  var Radio = memoForwardRef(function Radio(_ref108, ref) {
    var {
      disabled,
      index,
      render,
      value,
      ariaLabel,
      exclude,
      focusSelf,
      labelPosition,
      onPressSync,
      hidden,
      tagInput,
      tagLabel,
      getText
    } = _ref108;
    var context = q(RadioContext);
    var getValue = useStableGetter(value);
    var defaultFocusSelf = () => info.checkboxLikeReturn.focusSelf();
    var info = useRadio({
      //listNavigationParameters: { text },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue: getValue
      },
      radioParameters: {
        value
      },
      checkboxLikeParameters: {
        disabled: disabled !== null && disabled !== void 0 ? disabled : false
      },
      completeListNavigationChildParameters: {
        getValue
      },
      context,
      labelParameters: {
        ariaLabel,
        labelPosition,
        tagInput,
        tagLabel
      },
      pressParameters: {
        exclude,
        focusSelf: focusSelf !== null && focusSelf !== void 0 ? focusSelf : defaultFocusSelf,
        onPressSync
      },
      singleSelectionChildParameters: {
        disabled: !!disabled
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      }
      //rovingTabIndexParameters: { hidden, focusSelf, noModifyTabIndex },
      //hasFocusParameters: { getDocument, getWindow, onActiveElementChange, onElementChange, onFocusedChanged, onFocusedInnerChanged, onLastActiveElementChange, onLastFocusedChanged, onLastFocusedInnerChanged, onMount, onUnmount, onWindowFocusedChange },
      //subInfoParameters: {  },
      //singleSelectionParameters: { unselectable, focusSelf }
    });

    A(ref, () => info);
    //    const { useRadioInputProps } = useRadioInput({ tag: tagInput });
    //    const { useRadioLabelProps } = useRadioLabel({ tag: tagLabel });
    return render(info);
  });
  var SliderThumbContext = B$2(null);
  var Slider = memoForwardRef(function Slider(_ref109, ref) {
    var {
      max,
      min,
      onAfterChildLayoutEffect,
      onChildrenMountChange,
      children
    } = _ref109;
    var info = useSlider({
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange
      },
      sliderParameters: {
        max,
        min
      }
    });
    A(ref, () => info);
    return o$1(SliderThumbContext.Provider, {
      value: info.context,
      children: children
    });
  });
  var SliderThumb = memoForwardRef(function SliderThumbU(_ref110, ref) {
    var {
      label,
      tag,
      value,
      max,
      min,
      onValueChange,
      index,
      render,
      valueText
    } = _ref110;
    var context = q(SliderThumbContext);
    var info = useSliderThumb({
      context,
      managedChildParameters: {
        index
      },
      sliderThumbParameters: {
        label,
        tag,
        value,
        max,
        min,
        onValueChange,
        valueText
      }
      //subInfo
    });

    A(ref, () => info);
    return render(info);
  });

  //const LocationContext = createContext<"head" | "body" | "foot">(null!);
  var TableContext = B$2(null);
  var TableSectionContext = B$2(null);
  var TableRowContext = B$2(null);
  var Table = memoForwardRef(function TableU(_ref111, ref) {
    var {
      ariaLabel,
      selectionLimit,
      tagTable,
      render
    } = _ref111;
    var info = useTable({
      labelParameters: {
        ariaLabel
      },
      tableParameters: {
        selectionLimit,
        tagTable
      }
    });
    A(ref, () => info);
    return o$1(TableContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  var TableSection = memoForwardRef(function TableSection(_ref112) {
    var {
      disableArrowKeys,
      disableHomeEndKeys,
      getIndex,
      initiallySelectedIndex,
      untabbable,
      navigatePastEnd,
      navigatePastStart,
      setSelectedIndex,
      onTabbableColumnChange,
      onTabbableIndexChange,
      pageNavigationSize,
      render,
      location,
      tagTableSection
    } = _ref112;
    var info = useTableSection({
      gridNavigationParameters: {
        onTabbableColumnChange: onTabbableColumnChange !== null && onTabbableColumnChange !== void 0 ? onTabbableColumnChange : null
      },
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      singleSelectionParameters: {
        initiallySelectedIndex: initiallySelectedIndex !== null && initiallySelectedIndex !== void 0 ? initiallySelectedIndex : null,
        setSelectedIndex: setSelectedIndex !== null && setSelectedIndex !== void 0 ? setSelectedIndex : null
      },
      context: q(TableContext),
      tableSectionParameters: {
        tagTableSection,
        location
      }
    });
    return o$1(TableSectionContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  /*
  export const TableBody = memoForwardRef(function TableBodyU<SectionElement extends Element, RowElement extends Element, Cellement extends Element, CR = undefined, CC = undefined, KR extends string = never>({ render }: TableBodyProps<SectionElement, RowElement, Cellement, CR, CC, KR>, ref?: Ref<any>) {
      const { useTableBodyProps, ...sectionInfo } = useContext(TableBodyContext)({});
       useImperativeHandle(ref!, () => sectionInfo);
       return <LocationContext.Provider value="body">{render(sectionInfo, useTableBodyProps)}</LocationContext.Provider>
  })
   export const TableHead = memoForwardRef(function TableHeadU<T extends Element>({ render, tagTableHead }: TableHeadProps<T>) {
      const useTableSectionPropsBase = useContext(TableSectionContext);
      const useTableSectionProps: PropModifier<T> = (props) => useTableSectionPropsBase(tagTableHead, "head", props);
      return <LocationContext.Provider value="head">{(render(useTableSectionProps))}</LocationContext.Provider>
  })
   export const TableFoot = memoForwardRef(function TableFootU<T extends Element>({ render, tagTableFoot }: TableFootProps<T>) {
      const useTableSectionPropsBase = useContext(TableSectionContext);
      const useTableSectionProps: PropModifier<T> = (props) => useTableSectionPropsBase(tagTableFoot, "foot", props);
      return <LocationContext.Provider value="foot">{(render(useTableSectionProps))}</LocationContext.Provider>
  })*/
  var TableRow = memoForwardRef(function TableRowU(_ref113, ref) {
    var {
      index,
      getText,
      tagTableRow,
      disableArrowKeys,
      disableHomeEndKeys,
      onTabbableIndexChange,
      ariaPropName,
      disabled,
      untabbable,
      navigatePastEnd,
      navigatePastStart,
      selected,
      selectionMode,
      hidden,
      render
    } = _ref113;
    var cx1 = q(TableSectionContext);
    var info = useTableRow({
      rowAsChildOfGridParameters: {
        completeGridNavigationRowParameters: {},
        context: cx1,
        managedChildParameters: {
          index
        },
        rovingTabIndexChildParameters: {
          hidden: hidden !== null && hidden !== void 0 ? hidden : false
        },
        singleSelectionChildParameters: {
          ariaPropName,
          selectionMode: useDefault("selectionMode", selectionMode),
          disabled: disabled !== null && disabled !== void 0 ? disabled : false
        },
        textContentParameters: {
          getText: useDefault("getText", getText)
        }
      },
      rowAsParentOfCellsParameters: {
        linearNavigationParameters: {
          disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
          disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
          navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
          navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap"
        },
        rovingTabIndexParameters: {
          onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
          untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
        }
      },
      tableRowParameters: {
        selected: selected !== null && selected !== void 0 ? selected : null,
        tagTableRow
      }
    });
    A(ref, () => info);
    return o$1(TableRowContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  var TableCell = memoForwardRef(function TableCell(_ref114, ref) {
    var {
      index,
      getText,
      focusSelf,
      hidden,
      tagTableCell,
      render,
      colSpan,
      exclude,
      onPressSync,
      getSortValue
    } = _ref114;
    var context = q(TableRowContext);
    var focusSelfDefault = T$1(e => {
      e === null || e === void 0 ? void 0 : e.focus();
    }, []);
    var info = useTableCell({
      completeGridNavigationCellParameters: {
        getSortValue
      },
      context,
      gridNavigationCellParameters: {
        colSpan: colSpan !== null && colSpan !== void 0 ? colSpan : 1
      },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      pressParameters: {
        exclude,
        focusSelf: focusSelf !== null && focusSelf !== void 0 ? focusSelf : focusSelfDefault,
        onPressSync
      },
      tableCellParameters: {
        tagTableCell
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      }
      /* listNavigation: { text },
       managedChild: { index, flags },
       rovingTabIndex: { focusSelf, hidden, noModifyTabIndex },
       hasFocus: { getDocument, getWindow, onActiveElementChange, onElementChange, onFocusedChanged, onFocusedInnerChanged, onLastActiveElementChange, onLastFocusedChanged, onLastFocusedInnerChanged, onMount, onUnmount, onWindowFocusedChange },
       subInfo,
       tableCell: {
           value,
           headerType,
           tagTableCell,
           location: useContext(LocationContext)
       }*/
    });

    A(ref, () => info);
    return render(info);
  });
  var TabsContext = B$2(null);
  var TabPanelsContext = B$2(null);
  function Tabs(_ref115) {
    var {
      ariaLabel,
      collator,
      compare,
      disableArrowKeys,
      disableHomeEndKeys,
      getIndex,
      initiallySelectedIndex,
      navigatePastEnd,
      navigatePastStart,
      noTypeahead,
      setSelectedIndex,
      onTabbableIndexChange,
      orientation,
      pageNavigationSize,
      groupingType,
      untabbable,
      typeaheadTimeout,
      role,
      render
    } = _ref115;
    var info = useTabs({
      labelParameters: {
        ariaLabel
      },
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      singleSelectionParameters: {
        initiallySelectedIndex: initiallySelectedIndex !== null && initiallySelectedIndex !== void 0 ? initiallySelectedIndex : 0,
        setSelectedIndex: setSelectedIndex !== null && setSelectedIndex !== void 0 ? setSelectedIndex : null
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      tabsParameters: {
        orientation,
        groupingType,
        role
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      }
    });
    var {
      contextPanels,
      contextTabs
    } = info;
    return o$1(TabsContext.Provider, {
      value: contextTabs,
      children: o$1(TabPanelsContext.Provider, {
        value: contextPanels,
        children: render(info)
      })
    });
  }
  function Tab(_ref116) {
    var {
      disabled,
      exclude,
      focusSelf,
      hidden,
      index,
      onPressSync,
      selectionMode,
      getText,
      getSortValue,
      render
    } = _ref116;
    var context = q(TabsContext);
    var focusSelfDefault = T$1(e => {
      e === null || e === void 0 ? void 0 : e.focus();
    }, []);
    var info = useTab({
      completeListNavigationChildParameters: {},
      context,
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue
      },
      managedChildParameters: {
        index
      },
      pressParameters: {
        exclude,
        focusSelf: focusSelf !== null && focusSelf !== void 0 ? focusSelf : focusSelfDefault,
        onPressSync
      },
      singleSelectionChildParameters: {
        disabled: disabled !== null && disabled !== void 0 ? disabled : false,
        selectionMode: "focus"
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      }
    });
    return render(info);
  }
  function TabPanel(_ref117) {
    var {
      index,
      render
    } = _ref117;
    var context = q(TabPanelsContext);
    var info = useTabPanel({
      context,
      managedChildParameters: {
        index
      }
    });
    return render(info);
  }

  /*export function defaultRenderToasts({}: {}) {
      return function (args: UseToastsReturnTypeInfo, props: h.JSX.HTMLAttributes<ContainerType>) {
          return (
          <div>
           </div>
          )
      }
  }*/
  var ToastContext = B$2(null);
  var Toasts = memoForwardRef(function Toasts(_ref118, ref) {
    var {
      onAfterChildLayoutEffect,
      onChildrenMountChange,
      render,
      visibleCount
    } = _ref118;
    var info = useToasts({
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange
      },
      toastsParameters: {
        visibleCount
      }
    });
    A(ref, () => info);
    return o$1(ToastContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  var Toast = memoForwardRef(function Toast(_ref119, ref) {
    var {
      render,
      index,
      timeout,
      politeness
    } = _ref119;
    var context = q(ToastContext);
    var info = useToast({
      managedChildParameters: {
        index
      },
      toastParameters: {
        timeout,
        politeness
      },
      context
    });
    A(ref, () => info);
    return render(info);
  });
  var ToolbarContext = B$2(null);
  var Toolbar = memoForwardRef(function ToolbarU(_ref120, ref) {
    var {
      render,
      role,
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      untabbable,
      compare,
      getIndex,
      navigatePastEnd,
      navigatePastStart,
      pageNavigationSize,
      initiallySelectedIndex,
      setSelectedIndex,
      orientation,
      noTypeahead,
      onTabbableIndexChange,
      typeaheadTimeout
    } = _ref120;
    var listboxReturnType = useToolbar({
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      singleSelectionParameters: {
        initiallySelectedIndex: initiallySelectedIndex !== null && initiallySelectedIndex !== void 0 ? initiallySelectedIndex : null,
        setSelectedIndex: setSelectedIndex !== null && setSelectedIndex !== void 0 ? setSelectedIndex : null
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      toolbarParameters: {
        orientation,
        role: role !== null && role !== void 0 ? role : "toolbar"
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      }
    });
    A(ref, () => listboxReturnType);
    return o$1(ToolbarContext.Provider, {
      value: listboxReturnType.context,
      children: render(listboxReturnType)
    });
  });
  var ToolbarChild = memoForwardRef(function ToolbarChildU(_ref121, ref) {
    var {
      index,
      render,
      ariaPropName,
      disabled,
      exclude,
      onPressSync,
      selectionMode,
      focusSelf,
      getSortValue,
      hidden,
      getText
    } = _ref121;
    var context = q(ToolbarContext);
    var focusSelfDefault = T$1(e => {
      e === null || e === void 0 ? void 0 : e.focus();
    }, []);
    var info = useToolbarChild({
      context,
      //completeListNavigationChildParameters: subInfo,
      completeListNavigationChildParameters: {},
      pressParameters: {
        exclude,
        focusSelf: focusSelf !== null && focusSelf !== void 0 ? focusSelf : focusSelfDefault,
        onPressSync
      },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue
      },
      singleSelectionChildParameters: {
        ariaPropName,
        selectionMode,
        disabled: disabled !== null && disabled !== void 0 ? disabled : false
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      }
    });
    A(ref, () => info);
    return o$1(p$1, {
      children: render(info)
    });
  });
  var Tooltip = memoForwardRef(function TooltipU(_ref122, ref) {
    var {
      focusDelay,
      mouseoutToleranceDelay,
      mouseoverDelay,
      render
    } = _ref122;
    var info = useTooltip({
      focusDelay,
      mouseoutToleranceDelay,
      mouseoverDelay
    });
    A(ref, () => info);
    return render(info);
  });
  function DemoAccordion(_ref123) {
    var {
        children
      } = _ref123,
      props = _objectWithoutProperties(_ref123, _excluded78);
    return o$1(Accordion, {
      navigationDirection: "vertical",
      render: _info => {
        return o$1("div", {
          id: "accordion-demo",
          children: children
        });
      }
    });
  }
  var DemoAccordionSection = R(function DemoAccordionSection(_ref124) {
    var {
      index,
      body,
      heading,
      disabled,
      open
    } = _ref124;
    return o$1(AccordionSection, {
      index: index,
      tagButton: "button",
      open: open,
      disabled: disabled,
      render: info => o$1(Heading, _objectSpread(_objectSpread({}, info.propsHeader), {}, {
        tag: "div",
        heading: o$1(p$1, {
          children: [o$1("span", {
            children: heading
          }), o$1("button", _objectSpread(_objectSpread({}, info.propsHeaderButton), {}, {
            children: "Toggle open"
          }))]
        }),
        children: o$1("p", _objectSpread(_objectSpread({}, info.propsBody), {}, {
          hidden: !info.accordionSectionReturn.expanded,
          children: body
        }))
      }))
    });
  });
  function Blurb$e() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/accordion/",
          children: "In accordance with the ARIA guidelines for Accordion patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["Each section's header and body are linked via ID; the body is ", o$1("code", {
            children: "labelled-by"
          }), " the header and the header ", o$1("code", {
            children: "control"
          }), "s the body."]
        }), o$1("li", {
          children: "The header is a button and responds to keyboard, mouse, touch, etc. events, regardless of the element used."
        }), o$1("li", {
          children: ["If the header element is not a ", o$1("code", {
            children: "<button>"
          }), " element, it is given that ", o$1("code", {
            children: "role"
          }), "."]
        }), o$1("li", {
          children: "Up/down & Home/End keys navigate through the list, as does Tab and Shift+Tab"
        }), o$1("li", {})]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: ["The ", o$1("code", {
            children: "render"
          }), " prop each ", o$1("code", {
            children: "AccordionSection"
          }), " takes must wrap the header button with a ", o$1("a", {
            href: "https://w3c.github.io/aria/#heading",
            children: "heading"
          }), " (e.g. ", o$1("code", {
            children: "h3"
          }), ", or ", o$1("code", {
            children: "<Heading>"
          }), "). See the default implementation for an example."]
        })
      })]
    });
  }
  function Code$e() {
    return o$1("code", {
      children: "<Accordion render={...}>\n    <AccordionSection index={0} render={...} />\n    <AccordionSection index={1} render={...} />\n    <AccordionSection index={2} render={...} />\n</Accordion>"
    });
  }
  function Demo$e() {
    var [count, setCount] = p(5);
    return o$1(p$1, {
      children: [o$1(Blurb$e, {}), o$1(Code$e, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of accordion sections"]
      }), o$1(DemoAccordion, {
        children: o$1(p$1, {
          children: Array.from(function* () {
            yield o$1(DemoAccordionSection, {
              index: 0,
              heading: "Accordion section #0",
              body: "Body content #0",
              disabled: false
            });
            yield o$1(DemoAccordionSection, {
              index: 1,
              heading: "Accordion section #1",
              body: "Body content #1",
              disabled: false
            });
            yield o$1(DemoAccordionSection, {
              index: 2,
              heading: "Accordion section #2 (disabled)",
              body: "Body content #2",
              disabled: true
            });
            yield o$1(DemoAccordionSection, {
              index: 3,
              heading: "Accordion section #3 (forced open)",
              body: "Body content #3",
              disabled: false,
              open: true
            });
            yield o$1(DemoAccordionSection, {
              index: 4,
              heading: "Accordion section #4 (forced closed)",
              body: "Body content #4",
              disabled: false,
              open: false
            });
            for (var _i7 = 5; _i7 < count; ++_i7) {
              yield o$1(DemoAccordionSection, {
                index: _i7,
                heading: "Accordion section #".concat(_i7),
                body: "BodyContent #".concat(_i7),
                disabled: false
              });
            }
          }()).slice(0, count)
        })
      })]
    });
  }
  function Blurb$d() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/button/",
          children: "In accordance with the ARIA guidelines for Button patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["Whether using an actual ", o$1("code", {
            children: "<button>"
          }), ", or something else like a ", o$1("code", {
            children: "<div>"
          }), ", the proper roles and event handlers will be applied."]
        }), o$1("li", {
          children: "Buttons can be toggled (pressed or unpressed)."
        }), o$1("li", {
          children: ["The button responds to keyboard, mouse, touch, etc. events, regardless of the element used.", o$1("ul", {
            children: [o$1("li", {
              children: "Double-clicks do not select text, but text is still selectable without it counting as a press/click"
            }), o$1("li", {
              children: "When Enter is pressed, the button is immediately activated"
            }), o$1("li", {
              children: "When Space is pressed, the button is activated once released"
            }), o$1("li", {
              children: "iOS Safari properly focuses the button"
            })]
          })]
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: ["If your button contains only an icon (or other non-descriptive content, etc.), you must provide an ", o$1("code", {
            children: "aria-label"
          }), " manually stating what happens when the button is pressed."]
        })
      })]
    });
  }
  function Code$d() {
    return o$1("code", {
      children: "<Button tag=\"button\">Button</Button>\n    <Button tag=\"div\">Div</Button>"
    });
  }
  function Demo$d() {
    var [pressed, setPressed] = useState(false);
    return o$1(p$1, {
      children: [o$1(Blurb$d, {}), o$1(Code$d, {}), o$1(DemoButton, {
        disabled: false,
        tag: "button"
      }), o$1(DemoButton, {
        disabled: "soft",
        tag: "button"
      }), o$1(DemoButton, {
        disabled: "hard",
        tag: "button"
      }), o$1(DemoButton, {
        disabled: false,
        tag: "div"
      }), o$1(DemoButton, {
        disabled: "soft",
        tag: "div"
      }), o$1(DemoButton, {
        disabled: "hard",
        tag: "div"
      }), o$1(Button, {
        exclude: undefined,
        tagButton: "button",
        pressed: pressed,
        onPress: e => {
          var _e$EventDetail$presse;
          return setPressed((_e$EventDetail$presse = e[EventDetail].pressed) !== null && _e$EventDetail$presse !== void 0 ? _e$EventDetail$presse : false);
        },
        render: info => o$1("button", _objectSpread(_objectSpread({}, info.props), {}, {
          children: "Toggle button (".concat(pressed ? "pressed" : "unpressed", ")")
        }))
      })]
    });
  }
  function DemoButton(_ref125) {
    var {
      tag,
      disabled
    } = _ref125;
    var onPress = () => {
      alert("Button clicked");
    };
    return o$1(Button, {
      disabled: disabled,
      tagButton: tag,
      onPress: onPress,
      render: info => o$1("button", _objectSpread(_objectSpread({}, info.props), {}, {
        children: "".concat(tag, " ").concat(disabled ? " disabled (".concat(disabled == "soft" ? "soft" : "hard", ")") : "")
      }))
    });
  }

  /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
      return <Button disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
  }*/
  function Blurb$c() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/checkbox/",
          children: "In accordance with the ARIA guidelines for Checkbox patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: "Toggles between checked and unchecked when pressed (clicked, Enter pressed, Space released, etc.)"
        }), o$1("li", {
          children: ["Can be ", o$1("code", {
            children: "mixed"
          }), " instead, though ", o$1("code", {
            children: "onInput"
          }), " will only ever be called with ", o$1("code", {
            children: "true"
          }), " or ", o$1("code", {
            children: "false"
          })]
        }), o$1("li", {
          children: ["Supports using ", o$1("code", {
            children: "<input>"
          }), "s and ", o$1("code", {
            children: "<label>"
          }), "s, as well as just plain ol' ", o$1("code", {
            children: "<div>"
          }), "s on either/both"]
        }), o$1("li", {
          children: "The checkbox and label can be sibling elements, like normal, or the label can wrap the input for a larger hit area. In all cases, the appropriate roles/event handlers will be applied to each element."
        }), o$1("li", {
          children: "When selecting the text of a checkbox's label, this does not change the checkbox's state"
        }), o$1("li", {
          children: "Double-clicking the label checks & un-checks the checkbox instead of selecting the label's text"
        }), o$1("li", {
          children: "Checkbox groups (with a tri-state parent) are a separate component/hook"
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", {
            children: "render"
          }), " prop and setting ", o$1("code", {
            children: "labelPosition"
          }), " to be \"separate\"), you must pass ", o$1("code", {
            children: "aria-label"
          }), " as a prop to the checkbox manually. Not providing one will print an error to the console, but it it not required by the type system."]
        })
      })]
    });
  }
  function Code$c() {
    return o$1("code", {
      children: "<Checkbox checked={true} labelPosition=\"separate\" tagInput=\"input\" tagLabel=\"label\">Label text</Checkbox>"
    });
  }
  function Demo$c() {
    var [checked, setChecked] = useState(false);
    var [disabled, setDisabled] = useState(false);
    return o$1(p$1, {
      children: [o$1(Blurb$c, {}), o$1(Code$c, {}), o$1(Checkbox, {
        checked: disabled,
        onCheckedChange: e => setDisabled(e[EventDetail].checked),
        ariaLabel: null,
        labelPosition: "separate",
        tagInput: "input",
        tagLabel: "label",
        render: info => o$1(p$1, {
          children: [o$1("input", _objectSpread({}, info.propsInput)), o$1("label", _objectSpread(_objectSpread({}, info.propsLabel), {}, {
            children: "Disabled"
          }))]
        })
      }), o$1(Button, {
        tagButton: "button",
        onPress: () => {
          setChecked("mixed");
        },
        render: info => o$1("button", _objectSpread(_objectSpread({}, info.props), {}, {
          children: "Change to mixed"
        }))
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "separate",
        disabled: disabled,
        tagInput: "input",
        tagLabel: "label"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "wrapping",
        disabled: disabled,
        tagInput: "input",
        tagLabel: "label"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "separate",
        disabled: disabled,
        tagInput: "div",
        tagLabel: "label"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "wrapping",
        disabled: disabled,
        tagInput: "div",
        tagLabel: "label"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "separate",
        disabled: disabled,
        tagInput: "input",
        tagLabel: "div"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "wrapping",
        disabled: disabled,
        tagInput: "input",
        tagLabel: "div"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "separate",
        disabled: disabled,
        tagInput: "div",
        tagLabel: "div"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "wrapping",
        disabled: disabled,
        tagInput: "div",
        tagLabel: "div"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "hidden",
        disabled: disabled,
        tagInput: "input",
        tagLabel: "label"
      })]
    });
  }
  function DemoCheckbox$1(_ref126) {
    var {
      labelPosition,
      tagInput,
      tagLabel,
      disabled,
      checked,
      setChecked
    } = _ref126;
    //const [checked, setChecked] = useState(false);
    return o$1("div", {
      style: {
        border: "1px solid black"
      },
      children: [o$1(Checkbox, {
        ariaLabel: null,
        disabled: disabled,
        checked: checked,
        onCheckedChange: e => setChecked(e[EventDetail].checked),
        labelPosition: labelPosition == "hidden" ? "separate" : labelPosition,
        tagInput: tagInput,
        tagLabel: tagLabel,
        render: defaultRenderCheckboxLike({
          labelPosition,
          tagInput: tagInput,
          tagLabel: tagLabel,
          makePropsInput: info => useMergedProps(info.propsInput, {
            "aria-label": labelPosition == "hidden" ? "Hidden label (technically separate), ".concat(tagInput, " and ").concat(tagLabel, " ").concat(checked ? "checked" : "not checked") : undefined
          }),
          makePropsLabel: info => useMergedProps(info.propsLabel, {
            children: "".concat(labelPosition, ", ").concat(tagInput, " and ").concat(tagLabel, ", ").concat(checked ? "checked" : "not checked")
          })
        })
      }), labelPosition == "hidden" && o$1("div", {
        children: ["(This is not a label -- the actual label is via the ", o$1("code", {
          children: "aria-label"
        }), " prop)"]
      })]
    });
  }
  function DemoCheckbox(_ref127) {
    var {
      index
    } = _ref127;
    var [checked, setChecked] = useState(false);
    var ref = _(null);
    return o$1(CheckboxGroupChild, {
      checked: checked,
      index: index,
      focusSelf: () => {
        var _ref$current;
        return (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.checkboxLikeReturn.focusSelf();
      },
      onChangeFromParent: function () {
        var _ref128 = _asyncToGenerator(function* (checked) {
          yield new Promise(resolve => setTimeout(resolve, Math.random() * 2000));
          setChecked(checked);
        });
        return function onChangeFromParent(_x2) {
          return _ref128.apply(this, arguments);
        };
      }(),
      getSortValue: returnNull,
      //focusSelf={useStableCallback((e) => e.focus())}
      render: info => {
        return o$1("div", {
          children: o$1(Checkbox, {
            ref: ref,
            checked: checked,
            disabled: false,
            ariaLabel: null,
            onCheckedChange: e => {
              setChecked(e[EventDetail].checked);
              info.checkboxGroupChild.onChildCheckedChange(e[EventDetail].checked);
            },
            labelPosition: "separate",
            tagInput: "input",
            tagLabel: "label",
            render: defaultRenderCheckboxLike({
              labelPosition: "separate",
              tagInput: "input",
              tagLabel: "label",
              makePropsInput: info2 => useMergedProps(info.props, info2.propsInput),
              makePropsLabel: info2 => _objectSpread({
                children: "Checkbox #".concat(index)
              }, info2.propsLabel)
            })
          })
        });
      }
    });
  }
  function Blurb$b() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: ["Checkbox groups are an alternative to multi-select lists. There is no role of ", o$1("code", {
          children: "checkboxgroup"
        }), ", but this aims to be an ARIA-compliant implementation of a checkbox group."]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["All normal ", o$1("code", {
            children: "Checkbox"
          }), " functionality is supported on each individual checkbox."]
        }), o$1("li", {
          children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"."
        }), o$1("li", {
          children: ["The parent's \"mixed\" state changes all children back to whatever state the user had most recently created; the distinction is drawn when a child calls ", o$1("code", {
            children: "onChildCheckedChange"
          }), " during its event handler. This call is what notifies the parent checkbox what to use when switching to that \"mixed\" state."]
        }), o$1("li", {
          children: ["The children are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        }), o$1("li", {
          children: [o$1("code", {
            children: "aria-controls"
          }), " is set on the parent Checkbox to contain the IDs of all child checkboxes. This has no effect on any technology that I am aware of, but it's there just in case."]
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: [o$1("li", {
          children: [o$1("code", {
            children: "CheckboxGroupParent"
          }), " has supports child checkboxes being asyncronous (e.g. if each child's ", o$1("code", {
            children: "onChangeFromParent"
          }), " is async, then the parent's ", o$1("code", {
            children: "onParentCheckedChange"
          }), " will asyncronously wait for all of them), but you must apply any relevant labelling of this circumstance yourself."]
        }), o$1("li", {
          children: ["As mentioned, ", o$1("code", {
            children: "aria-controls"
          }), " basically does nothing. Please ensure you're using good labelling here; it is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", {
            children: "role=group"
          }), " that references that label by overriding ", o$1("code", {
            children: "render"
          }), "."]
        })]
      })]
    });
  }
  function Code$b() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$b() {
    var [count, setCount] = useState(5);
    var [pending, setPending] = useState(false);
    return o$1(p$1, {
      children: [o$1(Blurb$b, {}), o$1(Code$b, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of checkboxes"]
      }), o$1("div", {
        children: [o$1("p", {
          children: [o$1("strong", {
            children: "Note:"
          }), " Each checkbox takes a random amount of time to update when modified via the parent checkbox to test async handling."]
        }), o$1(CheckboxGroup, {
          navigationDirection: "vertical",
          render: info2 => {
            var ref = _(null);
            return o$1("div", _objectSpread(_objectSpread({}, info2.props), {
              children: o$1(p$1, {
                children: [o$1(CheckboxGroupParent, {
                  index: 0,
                  focusSelf: () => {
                    var _ref$current2;
                    return (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.checkboxLikeReturn.focusSelf();
                  },
                  getSortValue: returnNull,
                  render: info3 => o$1(Checkbox, {
                    ref: ref,
                    disabled: pending,
                    checked: info3.checkboxGroupParentReturn.checked,
                    onCheckedChange: useStableCallback(e => {
                      setPending(true);
                      info3.checkboxGroupParentReturn.onParentCheckedChange(e).finally(() => setPending(false));
                    }),
                    ariaLabel: "Parent checkbox",
                    labelPosition: "separate",
                    tagInput: "input",
                    tagLabel: "label",
                    render: defaultRenderCheckboxLike({
                      labelPosition: "separate",
                      makePropsInput: info4 => useMergedProps(info4.propsInput, info3.props),
                      makePropsLabel: info4 => _objectSpread({
                        children: "Parent checkbox"
                      }, info4.propsLabel),
                      tagInput: "input",
                      tagLabel: "label"
                    })
                  })
                }), o$1("div", {
                  style: {
                    display: "flex",
                    flexDirection: "column"
                  },
                  children: o$1(p$1, {
                    children: Array.from(function* () {
                      for (var _i8 = 0; _i8 < count; ++_i8) {
                        yield o$1(DemoCheckbox, {
                          index: _i8 + 1
                        }, _i8);
                      }
                    }())
                  })
                })]
              })
            }));
          }
        })]
      })]
    });
  }
  var DemoListItem$3 = R(function DemoListItem(_ref129) {
    var {
      index
    } = _ref129;
    var [selected, setSelected] = useState(false);
    var labelText = "List item #".concat(index).concat(selected ? " (selected)" : "");
    return o$1(ListboxItem, {
      selected: selected,
      index: index,
      disabled: false,
      ariaPropName: "aria-selected",
      getSortValue: returnZero,
      onPressSync: e => {
        setSelected(p => !p);
      },
      render: info => {
        return o$1("li", _objectSpread(_objectSpread({}, info.props), {}, {
          children: labelText
        }));
      }
    });
  });
  function Blurb$a() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/",
          children: "In accordance with the ARIA guidelines for Listbox patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["The children are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        }), o$1("li", {
          children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"."
        }), o$1("li", {
          children: ["The parent checkbox reacts to each child's ", o$1("code", {
            children: "checked"
          }), " prop and updates its own internal ", o$1("code", {
            children: "checked"
          }), " attribute (be aware of this if they're asyncronous, as you'll want to ensure they all resolve on the same tick with ", o$1("code", {
            children: "Promise.all"
          }), " to not clobber the user's inputs)."]
        }), o$1("li", {
          children: ["The children are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        }), o$1("li", {
          children: "Grouping is supported"
        }), o$1("li", {
          children: "Sorting/reordering is supported, though not provided by default, as it's mutually exclusive with grouping."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["It is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", {
            children: "role=group"
          }), " that references that label by overriding ", o$1("code", {
            children: "render"
          }), "."]
        }), o$1("li", {
          children: ["See the caveat above for when each child's ", o$1("code", {
            children: "onInput"
          }), " takes a variable amount of time to actually update the ", o$1("code", {
            children: "checked"
          }), " prop, as it can clobber the user's last input when clicking on the parent"]
        })]
      })]
    });
  }
  function Code$a() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$a() {
    var [count, setCount] = useState(5);
    return o$1(p$1, {
      children: [o$1(Blurb$a, {}), o$1(Code$a, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of list items"]
      }), o$1("div", {
        children: o$1(Listbox, {
          selectedIndex: null,
          ariaLabel: null,
          groupingType: "without-groups",
          navigationDirection: "vertical",
          selectionLimit: "multi",
          render: info => {
            return o$1(p$1, {
              children: [o$1("label", _objectSpread({}, info.propsListboxLabel)), o$1("ul", _objectSpread(_objectSpread({}, info.propsListbox), {}, {
                children: Array.from(function* () {
                  for (var _i9 = 0; _i9 < count; ++_i9) {
                    yield o$1(DemoListItem$3, {
                      index: _i9
                    }, _i9);
                  }
                }())
              }))]
            });
          }
        })
      })]
    });
  }
  var DemoListItem$2 = R(function DemoListItem(_ref130) {
    var {
      index
    } = _ref130;
    return o$1(ListboxItem, {
      index: index,
      focusSelf: e => e.focus(),
      ariaPropName: "aria-selected",
      getSortValue: returnZero,
      disabled: false,
      selected: null,
      render: info => {
        var selected = info.singleSelectionChildReturn.selected;
        // defaultRenderListboxSingleItem({ tagListItem: "li", makePropsListItem: ({ singleSelection: { selected } }) => ({ children: `List item #${index}${selected ? " (selected)" : ""}` }) })
        return o$1("li", _objectSpread(_objectSpread({}, info.props), {}, {
          children: "List item #".concat(index).concat(selected ? " (selected)" : "")
        }));
      }
    });
  });
  function Blurb$9() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/",
          children: "In accordance with the ARIA guidelines for Listbox patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["In terms of keyboard navigation and tabbing through elements, a Listbox is considered a ", o$1("strong", {
            children: "single"
          }), " tab stop; in other words, no matter how many list items there are in a Listbox, it only takes one press of the Tab button to go through it.", o$1("ul", {
            children: [o$1("li", {
              children: "When a Listbox is tabbed into, the most recently selected item is given focus"
            }), o$1("li", {
              children: "Pressing Tab again navigates out of the listbox; no other list items are tabbable other than the one currently designated."
            }), o$1("li", {
              children: "Pressing the arrow keys navigates through the Listbox one item at a time"
            }), o$1("li", {
              children: "Pressing the Home/End keys move focus to the first/last items respectively"
            }), o$1("li", {
              children: "Typing any sequence of text starts typeahead that navigates to the next item that matches what's being typed"
            }), o$1("li", {
              children: "Focus & selection management is as optimized as possible; only two children re-render at a time when focus or selection changes"
            }), o$1("li", {
              children: "These apply generally to all composite components with a variable number of children (Tab Lists, Radio Groups, Multi-Select Listboxes etc.)"
            })]
          })]
        }), o$1("li", {
          children: ["Rather than each individual list item knowing whether it is selected or not (as with multi-select lists), here the parent knows the ", o$1("code", {
            children: "selectedIndex"
          }), " and simply notifies the (max two) relevant children any time it changes."]
        }), o$1("li", {
          children: "Grouping is supported"
        }), o$1("li", {
          children: "Sorting/reordering is supported, though not provided by default, as it's mutually exclusive with grouping."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: "Listboxes do not support interactive content within them (e.g. a dropdown menu), as ARIA specifies that this is a different pattern."
        })
      })]
    });
  }
  function Code$9() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$9() {
    var [selectedIndex, setSelectedIndex] = useState(null);
    var [count, setCount] = useState(5);
    return o$1(p$1, {
      children: [o$1(Blurb$9, {}), o$1(Code$9, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of list items"]
      }), o$1("div", {
        children: o$1(Listbox, {
          selectedIndex: selectedIndex,
          setSelectedIndex: setSelectedIndex,
          render: info => {
            /*
            defaultRenderListboxSingle({
            tagLabel: "label", tagList: "ol", makePropsLabel: () => ({}), makePropsList: () => ({
                children: <>{Array.from((function* () {
                    for (let i = 0; i < count; ++i) {
                        yield <DemoListItem index={i} key={i} />
                    }
                })())}</>
            })
            })
            */
            return o$1(p$1, {
              children: [o$1("label", _objectSpread(_objectSpread({}, info.propsListboxLabel), {}, {
                children: "Single-select listbox demo"
              })), o$1("ol", _objectSpread(_objectSpread({}, info.propsListbox), {}, {
                children: Array.from(function* () {
                  for (var _i10 = 0; _i10 < count; ++_i10) {
                    yield o$1(DemoListItem$2, {
                      index: _i10
                    }, _i10);
                  }
                }())
              }))]
            });
          },
          ariaLabel: null,
          groupingType: "without-groups",
          navigationDirection: "vertical",
          selectionLimit: "single"
        })
      })]
    });
  }
  function DemoListItem$1(_ref131) {
    var {
      index
    } = _ref131;
    return o$1(MenuItem, {
      index: index,
      ariaPropName: null,
      getSortValue: returnZero,
      selectionMode: "disabled",
      role: "menuitem",
      onPress: e => alert("Menu item #".concat(e[EventDetail].index, " pressed")),
      disabled: false,
      render: info => o$1("li", _objectSpread(_objectSpread({}, info.props), {}, {
        children: "Menu item #".concat(index)
      }))
    });
  }
  function Blurb$8() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/",
          children: "In accordance with the ARIA guidelines for Listbox patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["The children are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        }), o$1("li", {
          children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it."
        }), o$1("li", {
          children: "When the menu is closed because another element on the page was focused instead, focus will not be modified."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: "TODO"
        })
      })]
    });
  }
  function Code$8() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$8() {
    var [count, setCount] = useState(5);
    var [open, setOpen] = useState(false);
    return o$1(p$1, {
      children: [o$1(Blurb$8, {}), o$1(Code$8, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of menu items"]
      }), o$1("div", {
        children: o$1(Menu, {
          orientation: "vertical",
          onOpen: () => setOpen(true),
          onClose: () => setOpen(false),
          open: open,
          openDirection: "down",
          render: info => {
            return o$1(p$1, {
              children: [o$1("button", _objectSpread(_objectSpread({}, info.propsTrigger), {}, {
                onClick: () => setOpen(o => !o),
                children: "Menu trigger"
              })), defaultRenderPortal({
                portalId: "portal",
                children: o$1("div", _objectSpread(_objectSpread({}, info.propsSurface), {}, {
                  hidden: !open,
                  children: o$1("ul", _objectSpread(_objectSpread({}, info.propsTarget), {}, {
                    children: Array.from(function* () {
                      for (var _i11 = 0; _i11 < count; ++_i11) {
                        yield o$1("div", {
                          children: o$1(DemoListItem$1, {
                            index: _i11
                          }, _i11)
                        });
                      }
                    }())
                  }))
                }))
              })]
            });
          } /*defaultRenderMenu({
              tagButton: "button",
              tagMenu: "ul",
              tagSentinel: "div",
              tagSurface: "div",
              portalId: "portal",
              makePropsButton: () => ({ children: "Open menu" + (open ? " (open)" : " (closed)") }),
              makePropsMenu: () => ({
                  children: <>{Array.from((function* () {
                      for (let i = 0; i < count; ++i) {
                          yield <div><DemoListItem index={i} key={i} /></div>
                      }
                  })())}</>
              }),
              makePropsSurface: () => ({ style: { display: !open ? "none" : undefined } }),
              makePropsSentinel: () => ({}),
            })*/
        })
      })]
    });
  }

  var DemoRadioButton = R(function DemoRadioButton(_ref132) {
    var {
      index
    } = _ref132;
    return o$1("div", {
      children: o$1(Radio, {
        index: index,
        focusSelf: e => e.focus(),
        disabled: false,
        labelPosition: "separate",
        value: index,
        tagInput: "input",
        tagLabel: "label",
        ariaLabel: null,
        render: info => {
          return o$1(p$1, {
            children: [o$1("input", _objectSpread(_objectSpread({}, info.propsInput), {}, {
              name: "radio-demo"
            })), o$1("label", _objectSpread(_objectSpread({}, info.propsLabel), {}, {
              children: ["Radio #", index]
            }))]
          });
        }
      })
    });
  });
  function Blurb$7() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/radiobutton/",
          children: "In accordance with the ARIA guidelines for Radio Button patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["The children are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        }), o$1("li", {
          children: "The input & label support the same text-selection affordances as Checkboxes (labels can be selected, but double-clicking doesn't select the text and selecting text doesn't count as an input)"
        }), o$1("li", {
          children: "Selection state is handled by the parent; instead of specifying whether any given radio button is checked or not, the parent notifies each child of the necessary changes."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", {
            children: "render"
          }), " prop and setting ", o$1("code", {
            children: "labelPosition"
          }), " to be \"separate\"), you must pass ", o$1("code", {
            children: "aria-label"
          }), " as a prop to the checkbox manually. Not providing one will print an error to the console, but it it not required by the type system."]
        }), o$1("li", {
          children: ["The above also applies to the radio group as a whole; ARIA requires that all Radio Buttons be contained within an element with a specific role which is labelled either by an element (handled for you) or ", o$1("code", {
            children: "aria-label"
          }), " (specified by you manually on the input)."]
        })]
      })]
    });
  }
  function Code$7() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$7() {
    var [selectedIndex, setSelectedIndex] = useState(null);
    var [count, setCount] = useState(5);
    return o$1(p$1, {
      children: [o$1(Blurb$7, {}), o$1(Code$7, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of radio buttons"]
      }), o$1("div", {
        children: o$1(RadioGroup, {
          name: "radio-demo",
          ariaLabel: null,
          selectedValue: selectedIndex,
          navigationDirection: "vertical",
          setSelectedValue: setSelectedIndex,
          render: info => {
            return o$1(p$1, {
              children: [o$1("label", _objectSpread(_objectSpread({}, info.propsRadioGroupLabel), {}, {
                children: "Radio group demo"
              })), o$1("div", _objectSpread(_objectSpread({}, info.propsRadioGroup), {}, {
                children: Array.from(function* () {
                  for (var _i12 = 0; _i12 < count; ++_i12) {
                    yield o$1(DemoRadioButton, {
                      index: _i12
                    }, _i12);
                  }
                }())
              }))]
            });
          }
        })
      })]
    });
  }
  function DemoSliderThumb(_ref133) {
    var {
      index
    } = _ref133;
    var [value, setValue] = useState(0);
    return o$1(SliderThumb, {
      index: index,
      tag: "input",
      label: "Slider thumb #".concat(index),
      value: value,
      onValueChange: e => setValue(e[EventDetail].value),
      min: 0,
      max: 10,
      render: info => {
        return o$1("input", _objectSpread({}, info.propsSliderThumb));
      }
    });
  }
  function Blurb$6() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/",
          children: "In accordance with the ARIA guidelines for Listbox patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["The children are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        }), o$1("li", {
          children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it."
        }), o$1("li", {
          children: "When the menu is closed because another element on the page was focused instead, focus will not be modified."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: "TODO"
        })
      })]
    });
  }
  function Code$6() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$6() {
    var [count, setCount] = useState(5);
    return o$1(p$1, {
      children: [o$1(Blurb$6, {}), o$1(Code$6, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of slider thumbs"]
      }), o$1("div", {
        children: o$1(Slider, {
          min: 0,
          max: 10,
          children: o$1(p$1, {
            children: Array.from(function* () {
              for (var _i13 = 0; _i13 < count; ++_i13) {
                yield o$1("div", {
                  children: o$1(DemoSliderThumb, {
                    index: _i13
                  }, _i13)
                });
              }
            }())
          })
        })
      })]
    });
  }
  function Blurb$5() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/dialogmodal/",
          children: "In accordance with the ARIA guidelines for Modal Dialog patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: "Dialogs block all other elements on the page from receiving focus/interaction and being perceivable to screen readers."
        }), o$1("li", {
          children: "Dialogs can be dismissed by pressing Escape or clicking the element designated as the backdrop, both of which can be cancelled/ignored if you need"
        }), o$1("li", {
          children: "When opened, the dialog will focus its title or body content as appropriate, however read below under Things Not Handled for caveats."
        }), o$1("li", {
          children: "When closed for any reason, the element that was responsible for opening the dialog will be focused."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["By default, when opened, a dialog will focus its body content or title content depending on ", o$1("code", {
            children: "bodyIsOnlySemantic"
          }), ", which indicates that the dialog's body contains no interactive elements. This may not be suitable for all situations."]
        }), o$1("li", {
          children: ["It is ", o$1("em", {
            children: "hightly"
          }), " recommended to override ", o$1("code", {
            children: "focusSelf"
          }), " for all dialogs you create, and have it focus whatever element makes the most sense for your particular dialog.", o$1("ul", {
            children: [o$1("li", {
              children: "Dialogs that act like a form should focus the first interactive element"
            }), o$1("li", {
              children: "Dialogs that perform destructive actions should focus the \"Cancel\" button"
            }), o$1("li", {
              children: "In some cases, it's best to focus the first paragraph of the body."
            })]
          }), "In all cases, consider that the first focused element will both be how keyboard users interact with the dialog, but also the first thing a screen reader will read aloud."]
        })]
      })]
    });
  }
  function Code$5() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$5() {
    var [open, setOpen] = useState(false);
    //const r = useCallback((...args: any[]) => { console.log(...args); }, []);
    return o$1(p$1, {
      children: [o$1(Blurb$5, {}), o$1(Code$5, {}), o$1("div", {
        children: o$1(Dialog, {
          open: open,
          onClose: () => setOpen(false),
          closeOnBackdrop: true,
          closeOnEscape: true,
          focusOpener: e => {
            e.focus();
          },
          parentDepth: 0,
          focusPopup: (e, f) => {
            var _f;
            (_f = f()) === null || _f === void 0 ? void 0 : _f.focus();
          },
          ariaLabel: null,
          render: info => {
            return o$1(p$1, {
              children: [o$1("button", _objectSpread(_objectSpread({}, info.propsSource), {}, {
                onClick: () => setOpen(o => !o),
                children: "Open dialog"
              })), defaultRenderPortal({
                portalId: "portal",
                children: o$1("div", _objectSpread(_objectSpread({}, info.propsFocusContainer), {}, {
                  hidden: !open,
                  children: o$1("div", _objectSpread(_objectSpread({}, info.propsDialog), {}, {
                    children: [o$1("div", _objectSpread(_objectSpread({}, info.propsTitle), {}, {
                      children: "Dialog title"
                    })), o$1("div", {
                      children: "Dialog body"
                    }), o$1("button", {
                      onClick: () => setOpen(false),
                      children: "Close dialog"
                    })]
                  }))
                }))
              })]
            });
          }
        })
      })]
    });
  }
  function Blurb$4() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/tabpanel/",
          children: "In accordance with the ARIA guidelines for Tab and Tab Panel patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: o$1("li", {
          children: ["The tabs are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        })
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: "TODO"
        })
      })]
    });
  }
  function Code$4() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$4() {
    var [count, setCount] = useState(5);
    //const [selectedIndex, setSelectedIndex] = useState(0 as number | null);
    return o$1(p$1, {
      children: [o$1(Blurb$4, {}), o$1(Code$4, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of tabs"]
      }), o$1("div", {
        children: o$1(Tabs, {
          ariaLabel: null,
          groupingType: "without-groups",
          orientation: "horizontal",
          render: info => {
            /*
            defaultRenderTabs({
            panels: Array.from((function* () {
                for (let i = 0; i < count; ++i) {
                    yield <DemoTabPanel i={i} />
                }
            })()),
            tagLabel: "label",
            tagList: "ul",
            makePropsLabel: () => ({ children: "Tabs example" }),
            makePropsList: () => ({
                children: <>
                    {Array.from((function* () {
                        for (let i = 0; i < count; ++i) {
                            yield <DemoTab i={i} />
                        }
                    })())}
                </>
            })
            })
            
            */
            return o$1(p$1, {
              children: [o$1("label", _objectSpread(_objectSpread({}, info.propsLabel), {}, {
                children: "Tabs example"
              })), o$1("ul", _objectSpread(_objectSpread({}, info.propsContainer), {}, {
                style: {
                  display: "flex"
                },
                children: Array.from(function* () {
                  for (var _i14 = 0; _i14 < count; ++_i14) {
                    yield o$1(DemoTab, {
                      i: _i14
                    });
                  }
                }())
              })), o$1("div", {
                children: Array.from(function* () {
                  for (var _i15 = 0; _i15 < count; ++_i15) {
                    yield o$1(DemoTabPanel, {
                      i: _i15
                    });
                  }
                }())
              })]
            });
          }
        })
      })]
    });
  }
  var DemoTab = R(function DemoTab(_ref134) {
    var {
      i
    } = _ref134;
    return o$1(Tab, {
      focusSelf: e => e.focus(),
      index: i,
      render: info => o$1("li", _objectSpread(_objectSpread({}, info.props), {}, {
        style: {
          marginLeft: "2em"
        },
        children: ["Tab #", i, " ", info.singleSelectionChildReturn.selected && "(visible)"]
      })),
      getSortValue: returnZero
    }, i);
  });
  var DemoTabPanel = R(function DemoTabPanel(_ref135) {
    var {
      i
    } = _ref135;
    return o$1(TabPanel, {
      index: i,
      render: info => o$1("div", _objectSpread(_objectSpread({}, info.props), {}, {
        hidden: !info.tabPanelReturn.visible,
        children: ["Tab panel #", i]
      }))
    }, i);
  });
  function Blurb$3() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/tooltip/",
          children: "Tooltips have yet to be well defined in many areas"
        }), ", but this implementation aims to support common use cases:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: "Hovering or focusing the trigger element shows the tooltip"
        }), o$1("li", {
          children: "The tooltip stays shown when it itself is hovered/focused as well, so that the text inside can be selected"
        }), o$1("li", {
          children: "Moving the mouse between the trigger and the tooltip has some tolerance associated with immediately hiding the tooltip."
        }), o$1("li", {
          children: "Hovering, focusing, and re-hovering can each have a custom delay associated with it"
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["You must ensure that either the tooltip contains a focusable element (a button, link, ", o$1("code", {
            children: "<div tabIndex=\"-1\" />"
          }), ", etc.)"]
        }), o$1("li", {
          children: "Long presses on mobile devices are not yet handled (e.g. a long press on a button triggers a tooltip but does not activate the button)"
        })]
      })]
    });
  }
  function Code$3() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$3() {
    return o$1(p$1, {
      children: [o$1(Blurb$3, {}), o$1(Code$3, {}), o$1("div", {
        children: ["The following text triggers a tooltip: ", o$1(Tooltip, {
          render: info => {
            return o$1(p$1, {
              children: [o$1("span", _objectSpread(_objectSpread({
                tabIndex: 0
              }, info.propsTrigger), {}, {
                children: "Tooltip-triggering text that is hoverable and focusable: "
              })), defaultRenderPortal({
                portalId: "portal",
                children: o$1("div", _objectSpread(_objectSpread({}, info.propsPopup), {}, {
                  hidden: !info.tooltipReturn.isOpen,
                  children: "This text describes the triggering text in more detail."
                }))
              })]
            });
          }
        })]
      })]
    });
  }
  function Blurb$2() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/alert/",
          children: "Toasts (aka snackbars) are implemented using the Alert pattern."
        })
      }), o$1("ul", {
        children: [o$1("li", {
          children: "Pushing a toasts causes its contents to be shown visibly (and audibly with a screen reader)"
        }), o$1("li", {
          children: "Only new toasts are announced"
        }), o$1("li", {
          children: "Toasts are shown as soon as they are pushed, but you can control the maximum number shown at once with"
        }), o$1("li", {
          children: "Toasts can be dismissed in any order"
        }), o$1("li", {
          children: "Toasts can be set to auto-dismiss."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: [o$1("li", {
          children: "Auto-dismiss behavior is very situational. An auto-dismissed toast should only refer to information that can be viewed elsewhere; \"X files deleted\" can be double-checked in the Recycle Bin, \"X has logged in\" which you can along with everyone else in a tab somewhere, etc. This obviously cannot be checked programmatically."
        }), o$1("li", {
          children: "TODO: Focus management related to toasts that have interactive content"
        }), o$1("li", {
          children: "TODO: Toasts are still announced even when the current browser tab is hidden instead of saving them for when the user returns"
        }), o$1("li", {
          children: "TODO: Toasts still auto-dismiss when they have focus/are being interacted with"
        })]
      })]
    });
  }
  function Code$2() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$2() {
    var currentIndex = _(0);
    var [toasts, setToasts] = useState([]);
    var pushToast = T$1(() => {
      var index = currentIndex.current;
      currentIndex.current += 1;
      setToasts(t => [...t, o$1(Toast, {
        index: index,
        render: _ref136 => {
          var {
            toastReturn: {
              dismiss,
              showing,
              dismissed,
              numberOfToastsAheadOfUs
            }
          } = _ref136;
          return o$1("div", {
            style: showing ? {} : {
              opacity: 0.5
            },
            children: ["This the toast with an index of ", index, ". (#", numberOfToastsAheadOfUs, " in the queue to be shown). ", o$1("button", {
              disabled: dismissed,
              onClick: dismiss,
              children: "Click to dismiss"
            })]
          });
        },
        timeout: null
      }, index)]);
    }, []);
    return o$1(p$1, {
      children: [o$1(Blurb$2, {}), o$1(Code$2, {}), o$1("button", {
        onClick: pushToast,
        children: "Push a toast"
      }), o$1("div", {
        children: o$1(Toasts, {
          visibleCount: 3,
          render: info => {
            return o$1("div", _objectSpread(_objectSpread({}, info.props), {}, {
              children: toasts
            }));
          }
        })
      })]
    });
  }
  function Blurb$1() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: ["This is an implementation of an interactive data table that complies with ", o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/table/",
          children: "the ARIA guidelines for Table patterns"
        }), "."]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["In terms of keyboard navigation and tabbing through elements, a Table is considered a ", o$1("strong", {
            children: "single"
          }), " tab stop; in other words, no matter how many cells there are in a table (including if the cells contain interactive elements), it only takes one press of the Tab button to go through it.", o$1("ul", {
            children: [o$1("li", {
              children: ["Pressing the arrow keys navigates through the cells of the Table. You can override each cell's ", o$1("code", {
                children: "focusSelf"
              }), " prop to handle child elements."]
            }), o$1("li", {
              children: "Most other rules of list navigation apply (as in Listboxes), but in two dimensions."
            })]
          })]
        }), o$1("li", {
          children: ["The body rows are sortable via each cell's ", o$1("code", {
            children: "value"
          }), " prop. As a result of this, each row must be a ", o$1("em", {
            children: "direct"
          }), " child of the body, like as a normal array of children with no intervening JSX."]
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["If you don't need all the sorting and focus management and such, there's no reason not to just use the good old ", o$1("code", {
            children: "<table>"
          }), " element."]
        }), o$1("li", {
          children: ["It's up to you to make sure that any interactive elements within a table cell respond to focus management properly with the aforementioned ", o$1("code", {
            children: "focusSelf"
          }), " prop and a properly placed ", o$1("code", {
            children: ["tabIndex=", "{", "info.rovingTabIndex.tabbable? 0 : -1", "}"]
          }), " in the ", o$1("code", {
            children: "render"
          }), " prop."]
        })]
      })]
    });
  }
  function Code$1() {
    return o$1("code", {
      children: ""
    });
  }
  function DemoInput(_ref137) {
    var {
      index
    } = _ref137;
    var [v, setV] = useState("");
    return o$1(TableCell, {
      getSortValue: () => v,
      focusSelf: e => e.focus(),
      tagTableCell: "td",
      index: index,
      render: info => {
        return o$1("td", _objectSpread(_objectSpread({}, info.props), {}, {
          children: o$1("input", {
            type: "text",
            tabIndex: info.rovingTabIndexChildReturn.tabbable ? 0 : -1,
            onInput: T$1(e => {
              debugger;
              setV(e.currentTarget.value);
              e.preventDefault();
            }, []),
            value: v
          })
        }));
        /*
         tagTableCell: "td", makePropsTableCell: (info) => ({
            children: <DemoInput tabbable={info.rovingTabIndex.tabbable} />
         })
         */
      }
    });
    /*
    return (
        <input {...props} type="text" tabIndex={tabbable ? 0 : -1} onInput={useCallback((e: h.JSX.TargetedEvent<HTMLInputElement>) => {
            debugger;
            setV(e.currentTarget.value);
            e.preventDefault();
        }, [])} value={v} />
    )*/
  }

  function DemoTableCell(_ref138) {
    var {
      index,
      header
    } = _ref138;
    var r = _(Math.random());
    if (header) {
      var text = "Header #".concat(index);
      return o$1(TableCell, {
        getSortValue: returnZero,
        focusSelf: e => e.focus(),
        tagTableCell: "th",
        index: index,
        render: info => o$1("th", _objectSpread(_objectSpread({}, info.props), {}, {
          children: [text, o$1("button", {
            tabIndex: info.rovingTabIndexChildReturn.tabbable ? 0 : -1,
            onClick: () => info.tableCellReturn.sortByThisColumn(),
            children: "Sort"
          })]
        }))
      });
    } else {
      //const text = `Cell in column #${index}`;
      switch (index) {
        case 0:
          return o$1(DemoInput, {
            index: index
          });
        default:
          return o$1(TableCell, {
            getSortValue: () => r.current,
            focusSelf: e => e.focus(),
            tagTableCell: "td",
            index: index,
            render: info => {
              return o$1("td", _objectSpread(_objectSpread({}, info.props), {}, {
                children: r.current.toString()
              }));
            }
          });
      }
    }
  }
  function Demo$1() {
    var [count, setCount] = useState(5);
    return o$1(p$1, {
      children: [o$1(Blurb$1, {}), o$1(Code$1, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of table rows"]
      }), o$1("div", {
        children: o$1(Table, {
          ariaLabel: null,
          selectionLimit: "multi",
          tagTable: "table",
          render: infoTable => {
            return o$1(p$1, {
              children: [o$1("label", _objectSpread(_objectSpread({}, infoTable.propsLabel), {}, {
                children: "Table demo"
              })), o$1("table", _objectSpread(_objectSpread({}, infoTable.propsTable), {}, {
                children: [o$1(TableSection, {
                  tagTableSection: "thead",
                  location: "head",
                  render: infoSection => {
                    return o$1("thead", _objectSpread(_objectSpread({}, infoSection.propsTableSection), {}, {
                      children: o$1(TableRow, {
                        index: 0,
                        ariaPropName: "aria-selected",
                        tagTableRow: "tr",
                        render: info => {
                          return o$1("tr", _objectSpread(_objectSpread({}, info.props), {}, {
                            children: [o$1(DemoTableCell, {
                              header: true,
                              index: 0
                            }, 0), o$1(DemoTableCell, {
                              header: true,
                              index: 1
                            }, 1), o$1(DemoTableCell, {
                              header: true,
                              index: 2
                            }, 2)]
                          }));
                        }
                      })
                    }));
                  }
                }), o$1(TableSection, {
                  tagTableSection: "tbody",
                  location: "body",
                  render: infoSection => {
                    return o$1("tbody", _objectSpread(_objectSpread({}, infoSection.propsTableSection), {}, {
                      children: infoSection.rearrangeableChildrenReturn.useRearrangedChildren(Array.from(function* () {
                        for (var _i16 = 0; _i16 < count; ++_i16) {
                          yield o$1(TableRow, {
                            ariaPropName: "aria-selected",
                            tagTableRow: "tr",
                            index: _i16,
                            render: infoRow => {
                              return o$1("tr", _objectSpread(_objectSpread({}, infoRow.props), {}, {
                                children: [o$1(DemoTableCell, {
                                  index: 0
                                }, 0), o$1(DemoTableCell, {
                                  index: 1
                                }, 1), o$1(DemoTableCell, {
                                  index: 2
                                }, 2)]
                              }));
                              /*
                                                tagTableRow: "tr",
                              makePropsTableRow: () => ({
                                  children: <>
                                      <DemoTableCell key={0} index={0} />
                                      <DemoTableCell key={1} index={1} />
                                      <DemoTableCell key={2} index={2} />
                                  </>
                              })
                              })
                                       */
                            }
                          }, _i16);
                        }
                      }()))
                    }));
                  }
                })]
              }))]
            });
          }
        })
      })]
    });
  }
  var DemoListItem = R(function DemoListItem(_ref139) {
    var {
      index
    } = _ref139;
    return o$1(ToolbarChild, {
      index: index,
      focusSelf: e => e.focus(),
      ariaPropName: "aria-pressed",
      selectionMode: "activation",
      getSortValue: returnZero,
      render: info2 => {
        return o$1(Button, {
          tagButton: "button",
          pressed: false,
          render: info3 => o$1("button", _objectSpread(_objectSpread({}, useMergedProps(info2.props, info3.props)), {}, {
            children: ["Toolbar child #", index]
          }))
        });
      }
    });
  });
  function Blurb() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/toolbar/",
          children: "In accordance with the ARIA guidelines for Toolbar patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: "A Toolbar is a single widget for the purposes of keyboard navigation, like a Listbox."
        }), o$1("li", {
          children: "Toolbars are well-suited for \"button group\" patterns as well. Multiple groups can be contained within a single Toolbar, even multiple different types of components."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: ["You must label the Toolbar with ", o$1("code", {
            children: "aria-label"
          }), "."]
        })
      })]
    });
  }
  function Code() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo() {
    var [count, setCount] = useState(5);
    return o$1(p$1, {
      children: [o$1(Blurb, {}), o$1(Code, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of list items"]
      }), o$1("div", {
        children: o$1(Toolbar, {
          orientation: "horizontal",
          role: "toolbar",
          render: info => o$1("div", _objectSpread(_objectSpread({}, info.props), {}, {
            children: Array.from(function* () {
              for (var _i17 = 0; _i17 < count; ++_i17) {
                yield o$1(DemoListItem, {
                  index: _i17
                }, _i17);
              }
            }())
          }))
        })
      })]
    });
  }

  //import { options } from "preact";
  //options.debounceRendering = queueMicrotask;
  //const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
  setDebugLogging(true);
  var Component = () => {
    return o$1(Heading, {
      heading: "Demos",
      children: [o$1(Heading, {
        heading: "Accordion",
        children: o$1(Demo$e, {})
      }), o$1(Heading, {
        heading: "Button",
        children: o$1(Demo$d, {})
      }), o$1(Heading, {
        heading: "Checkbox",
        children: o$1(Demo$c, {})
      }), o$1(Heading, {
        heading: "Checkbox Group",
        children: o$1(Demo$b, {})
      }), o$1(Heading, {
        heading: "Dialog",
        children: o$1(Demo$5, {})
      }), o$1(Heading, {
        heading: "Single-select Listbox",
        children: o$1(Demo$9, {})
      }), o$1(Heading, {
        heading: "Multi-select Listbox",
        children: o$1(Demo$a, {})
      }), o$1(Heading, {
        heading: "Menu",
        children: o$1(Demo$8, {})
      }), o$1(Heading, {
        heading: "Radio",
        children: o$1(Demo$7, {})
      }), o$1(Heading, {
        heading: "Slider",
        children: o$1(Demo$6, {})
      }), o$1(Heading, {
        heading: "Toolbar",
        children: o$1(Demo, {})
      }), o$1(Heading, {
        heading: "Toast",
        children: o$1(Demo$2, {})
      }), o$1(Heading, {
        heading: "Tooltip",
        children: o$1(Demo$3, {})
      }), o$1(Heading, {
        heading: "Tabs",
        children: o$1(Demo$4, {})
      }), o$1(Heading, {
        heading: "Table",
        children: o$1(Demo$1, {})
      })]
    });
  };
  requestAnimationFrame(() => {
    P$1(o$1(Component, {}), document.getElementById("root"));
  });
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2RpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9yZW5kZXIuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NhdGNoLWVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9qc3gtcnVudGltZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL1B1cmVDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvbWVtby5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9mb3J3YXJkUmVmLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL0NoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLWxpc3QuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcG9ydGFscy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9yZW5kZXIuanMiLCIuLi9zcmMvcHJvcHMudHMiLCIuLi9zcmMvY29tcG9uZW50L2hlYWRpbmcudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9vYnNlcnZlcnMvdXNlLWFjdGl2ZS1lbGVtZW50LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtZ2V0dGVyLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtY2hpbGQtbWFuYWdlci50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1jaGlsZHJlbi50c3giLCIuLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLWNsYXNzZXMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtcmVmcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1zdHlsZXMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1ldmVudC1oYW5kbGVyLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC1kZXRhaWwvdXNlLWRpc21pc3MudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3RhYmJhYmxlL3NyYy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy93aWNnLWluZXJ0L2Rpc3QvaW5lcnQuanMiLCIuLi9ub2RlX21vZHVsZXMvYmxvY2tpbmctZWxlbWVudHMvc3JjL2Jsb2NraW5nLWVsZW1lbnRzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1kb2N1bWVudC1jbGFzcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLWJsb2NraW5nLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC1kZXRhaWwvdXNlLWZvY3VzLXRyYXAudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS10ZXh0LWNvbnRlbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvY29tcG9uZW50LWRldGFpbC91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvY29tcG9uZW50LWRldGFpbC91c2Utcm92aW5nLXRhYmluZGV4LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9jb21wb25lbnQtZGV0YWlsL3VzZS1saXN0LW5hdmlnYXRpb24tcGFydGlhbC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvY29tcG9uZW50LWRldGFpbC91c2UtZ3JpZC1uYXZpZ2F0aW9uLXBhcnRpYWwudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC1kZXRhaWwvdXNlLXNpbmdsZS1zZWxlY3Rpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC1kZXRhaWwvdXNlLWdyaWQtbmF2aWdhdGlvbi1zaW5nbGUtc2VsZWN0aW9uLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSYW5kb20uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaHVmZmxlU2VsZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5U2h1ZmZsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVZhbHVlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3NodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWZvcmNlLXVwZGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvY29tcG9uZW50LWRldGFpbC91c2Utc29ydGFibGUtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC1kZXRhaWwvdXNlLWdyaWQtbmF2aWdhdGlvbi1zaW5nbGUtc2VsZWN0aW9uLXNvcnRhYmxlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9jb21wb25lbnQtZGV0YWlsL3VzZS1saXN0LW5hdmlnYXRpb24tc2luZ2xlLXNlbGVjdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvb2JzZXJ2ZXJzL3VzZS1jaGlsZHJlbi1oYXZlLWZvY3VzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9vYnNlcnZlcnMvdXNlLWhhcy1jdXJyZW50LWZvY3VzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9jb21wb25lbnQtdXNlL3VzZS1wcmVzcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvY29tcG9uZW50LXVzZS91c2UtZ3JpZC1uYXZpZ2F0aW9uLWNvbXBsZXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9jb21wb25lbnQtdXNlL3VzZS1saXN0LW5hdmlnYXRpb24tY29tcGxldGUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC11c2UvdXNlLW1vZGFsLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9jb21wb25lbnQtdXNlL3VzZS1yYW5kb20taWQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC11c2UvdXNlLXJhbmRvbS1kdWFsLWlkcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdGltaW5nL3VzZS1hbmltYXRpb24tZnJhbWUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3RpbWluZy91c2UtdGltZW91dC50c3giLCIuLi9zcmMvdXNlLWJ1dHRvbi50cyIsIi4uL3NyYy91c2UtYWNjb3JkaW9uLnRzeCIsIi4uL3NyYy91c2UtbGFiZWwudHMiLCIuLi9zcmMvdXNlLWNoZWNrYm94LnRzIiwiLi4vc3JjL3VzZS1jaGVja2JveC1ncm91cC50cyIsIi4uL3NyYy91c2UtZGlhbG9nLnRzIiwiLi4vc3JjL3VzZS1kcmF3ZXIudHMiLCIuLi9zcmMvdXNlLWdyaWRsaXN0LnRzIiwiLi4vc3JjL3VzZS1tZW51LXN1cmZhY2UudHMiLCIuLi9zcmMvdXNlLXRvb2xiYXIudHN4IiwiLi4vc3JjL3VzZS1tZW51YmFyLnRzIiwiLi4vc3JjL3VzZS1tZW51LnRzIiwiLi4vc3JjL3VzZS1yYWRpby1ncm91cC50c3giLCIuLi9zcmMvdXNlLXNsaWRlci50c3giLCIuLi9zcmMvdXNlLXRhYmxlLnRzIiwiLi4vc3JjL3VzZS10YWJzLnRzIiwiLi4vc3JjL3VzZS10b2FzdHMudHN4IiwiLi4vc3JjL3VzZS10b29sdGlwLnRzIiwiLi4vc3JjL2NvbXBvbmVudC91dGlsLnRzIiwiLi4vc3JjL2NvbXBvbmVudC9hY2NvcmRpb24udHN4IiwiLi4vc3JjL2NvbXBvbmVudC9idXR0b24udHN4IiwiLi4vc3JjL2NvbXBvbmVudC9jaGVja2JveC50c3giLCIuLi9zcmMvY29tcG9uZW50L2NoZWNrYm94LWdyb3VwLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvZGlhbG9nLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvZHJhd2VyLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvZ3JpZGxpc3QudHN4IiwiLi4vc3JjL3VzZS1saXN0Ym94LnRzIiwiLi4vc3JjL2NvbXBvbmVudC9saXN0Ym94LnRzeCIsIi4uL3NyYy9jb21wb25lbnQvbWVudWJhci50c3giLCIuLi9zcmMvY29tcG9uZW50L21lbnUudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9yYWRpby1ncm91cC50c3giLCIuLi9zcmMvY29tcG9uZW50L3NsaWRlci50c3giLCIuLi9zcmMvY29tcG9uZW50L3RhYmxlLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvdGFicy50c3giLCIuLi9zcmMvY29tcG9uZW50L3RvYXN0cy50c3giLCIuLi9zcmMvY29tcG9uZW50L3Rvb2xiYXIudHN4IiwiLi4vc3JjL2NvbXBvbmVudC90b29sdGlwLnRzeCIsImRlbW9zL2FjY29yZGlvbi50c3giLCJkZW1vcy9idXR0b24udHN4IiwiZGVtb3MvY2hlY2tib3gudHN4IiwiZGVtb3MvY2hlY2tib3gtZ3JvdXAudHN4IiwiZGVtb3MvbGlzdGJveC1tdWx0aS50c3giLCJkZW1vcy9saXN0Ym94LXNpbmdsZS50c3giLCJkZW1vcy9tZW51LnRzeCIsImRlbW9zL3JhZGlvLnRzeCIsImRlbW9zL3NsaWRlci50c3giLCJkZW1vcy9kaWFsb2cudHN4IiwiZGVtb3MvdGFicy50c3giLCJkZW1vcy90b29sdGlwLnRzeCIsImRlbW9zL3RvYXN0LnRzeCIsImRlbW9zL3RhYmxlLnRzeCIsImRlbW9zL3Rvb2xiYXIudHN4IiwiaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVNUFRZX0FSUiB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG4vKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdC8vIEB0cy1pZ25vcmUgV2UgY2hhbmdlIHRoZSB0eXBlIG9mIGBvYmpgIHRvIGJlIGBPICYgUGBcblx0Zm9yIChsZXQgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG5cdHJldHVybiAvKiogQHR5cGUge08gJiBQfSAqLyAob2JqKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBjaGlsZCBub2RlIGZyb20gaXRzIHBhcmVudCBpZiBhdHRhY2hlZC4gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yXG4gKiBJRTExIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlKClgLiBVc2luZyB0aGlzIGZ1bmN0aW9uXG4gKiBpcyBzbWFsbGVyIHRoYW4gaW5jbHVkaW5nIGEgZGVkaWNhdGVkIHBvbHlmaWxsLlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG5cdGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cblxuZXhwb3J0IGNvbnN0IHNsaWNlID0gRU1QVFlfQVJSLnNsaWNlO1xuIiwiaW1wb3J0IHsgX2NhdGNoRXJyb3IgfSBmcm9tICcuL2RpZmYvY2F0Y2gtZXJyb3InO1xuXG4vKipcbiAqIFRoZSBgb3B0aW9uYCBvYmplY3QgY2FuIHBvdGVudGlhbGx5IGNvbnRhaW4gY2FsbGJhY2sgZnVuY3Rpb25zXG4gKiB0aGF0IGFyZSBjYWxsZWQgZHVyaW5nIHZhcmlvdXMgc3RhZ2VzIG9mIG91ciByZW5kZXJlci4gVGhpcyBpcyB0aGVcbiAqIGZvdW5kYXRpb24gb24gd2hpY2ggYWxsIG91ciBhZGRvbnMgbGlrZSBgcHJlYWN0L2RlYnVnYCwgYHByZWFjdC9jb21wYXRgLFxuICogYW5kIGBwcmVhY3QvaG9va3NgIGFyZSBiYXNlZCBvbi4gU2VlIHRoZSBgT3B0aW9uc2AgdHlwZSBpbiBgaW50ZXJuYWwuZC50c2BcbiAqIGZvciBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgb3B0aW9uIGhvb2tzIChtb3N0IGVkaXRvcnMvSURFcyBhbGxvdyB5b3UgdG9cbiAqIGN0cmwrY2xpY2sgb3IgY21kK2NsaWNrIG9uIG1hYyB0aGUgdHlwZSBkZWZpbml0aW9uIGJlbG93KS5cbiAqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5PcHRpb25zfVxuICovXG5jb25zdCBvcHRpb25zID0ge1xuXHRfY2F0Y2hFcnJvclxufTtcblxuZXhwb3J0IGRlZmF1bHQgb3B0aW9ucztcbiIsImltcG9ydCB7IHNsaWNlIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5cbmxldCB2bm9kZUlkID0gMDtcblxuLyoqXG4gKiBDcmVhdGUgYW4gdmlydHVhbCBub2RlICh1c2VkIGZvciBKU1gpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudFxuICogY29uc3RydWN0b3IgZm9yIHRoaXMgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGwgfCB1bmRlZmluZWR9IFtwcm9wc10gVGhlIHByb3BlcnRpZXMgb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4nKS5Db21wb25lbnRDaGlsZHJlbj59IFtjaGlsZHJlbl0gVGhlIGNoaWxkcmVuIG9mIHRoZSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSB7fSxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdrZXknKSBrZXkgPSBwcm9wc1tpXTtcblx0XHRlbHNlIGlmIChpID09ICdyZWYnKSByZWYgPSBwcm9wc1tpXTtcblx0XHRlbHNlIG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHByb3BzW2ldO1xuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0bm9ybWFsaXplZFByb3BzLmNoaWxkcmVuID1cblx0XHRcdGFyZ3VtZW50cy5sZW5ndGggPiAzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogY2hpbGRyZW47XG5cdH1cblxuXHQvLyBJZiBhIENvbXBvbmVudCBWTm9kZSwgY2hlY2sgZm9yIGFuZCBhcHBseSBkZWZhdWx0UHJvcHNcblx0Ly8gTm90ZTogdHlwZSBtYXkgYmUgdW5kZWZpbmVkIGluIGRldmVsb3BtZW50LCBtdXN0IG5ldmVyIGVycm9yIGhlcmUuXG5cdGlmICh0eXBlb2YgdHlwZSA9PSAnZnVuY3Rpb24nICYmIHR5cGUuZGVmYXVsdFByb3BzICE9IG51bGwpIHtcblx0XHRmb3IgKGkgaW4gdHlwZS5kZWZhdWx0UHJvcHMpIHtcblx0XHRcdGlmIChub3JtYWxpemVkUHJvcHNbaV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSB0eXBlLmRlZmF1bHRQcm9wc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbm9ybWFsaXplZFByb3BzLCBrZXksIHJlZiwgbnVsbCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgVk5vZGUgKHVzZWQgaW50ZXJuYWxseSBieSBQcmVhY3QpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudFxuICogQ29uc3RydWN0b3IgZm9yIHRoaXMgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdCB8IHN0cmluZyB8IG51bWJlciB8IG51bGx9IHByb3BzIFRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdmlydHVhbCBub2RlLlxuICogSWYgdGhpcyB2aXJ0dWFsIG5vZGUgcmVwcmVzZW50cyBhIHRleHQgbm9kZSwgdGhpcyBpcyB0aGUgdGV4dCBvZiB0aGUgbm9kZSAoc3RyaW5nIG9yIG51bWJlcikuXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IG51bGx9IGtleSBUaGUga2V5IGZvciB0aGlzIHZpcnR1YWwgbm9kZSwgdXNlZCB3aGVuXG4gKiBkaWZmaW5nIGl0IGFnYWluc3QgaXRzIGNoaWxkcmVuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1wicmVmXCJdfSByZWYgVGhlIHJlZiBwcm9wZXJ0eSB0aGF0IHdpbGxcbiAqIHJlY2VpdmUgYSByZWZlcmVuY2UgdG8gaXRzIGNyZWF0ZWQgY2hpbGRcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzLCBrZXksIHJlZiwgb3JpZ2luYWwpIHtcblx0Ly8gVjggc2VlbXMgdG8gYmUgYmV0dGVyIGF0IGRldGVjdGluZyB0eXBlIHNoYXBlcyBpZiB0aGUgb2JqZWN0IGlzIGFsbG9jYXRlZCBmcm9tIHRoZSBzYW1lIGNhbGwgc2l0ZVxuXHQvLyBEbyBub3QgaW5saW5lIGludG8gY3JlYXRlRWxlbWVudCBhbmQgY29lcmNlVG9WTm9kZSFcblx0Y29uc3Qgdm5vZGUgPSB7XG5cdFx0dHlwZSxcblx0XHRwcm9wcyxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdF9jaGlsZHJlbjogbnVsbCxcblx0XHRfcGFyZW50OiBudWxsLFxuXHRcdF9kZXB0aDogMCxcblx0XHRfZG9tOiBudWxsLFxuXHRcdC8vIF9uZXh0RG9tIG11c3QgYmUgaW5pdGlhbGl6ZWQgdG8gdW5kZWZpbmVkIGIvYyBpdCB3aWxsIGV2ZW50dWFsbHlcblx0XHQvLyBiZSBzZXQgdG8gZG9tLm5leHRTaWJsaW5nIHdoaWNoIGNhbiByZXR1cm4gYG51bGxgIGFuZCBpdCBpcyBpbXBvcnRhbnRcblx0XHQvLyB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gYW4gdW5pbml0aWFsaXplZCBfbmV4dERvbSBhbmRcblx0XHQvLyBhIF9uZXh0RG9tIHRoYXQgaGFzIGJlZW4gc2V0IHRvIGBudWxsYFxuXHRcdF9uZXh0RG9tOiB1bmRlZmluZWQsXG5cdFx0X2NvbXBvbmVudDogbnVsbCxcblx0XHRfaHlkcmF0aW5nOiBudWxsLFxuXHRcdGNvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG5cdFx0X29yaWdpbmFsOiBvcmlnaW5hbCA9PSBudWxsID8gKyt2bm9kZUlkIDogb3JpZ2luYWxcblx0fTtcblxuXHQvLyBPbmx5IGludm9rZSB0aGUgdm5vZGUgaG9vayBpZiB0aGlzIHdhcyAqbm90KiBhIGRpcmVjdCBjb3B5OlxuXHRpZiAob3JpZ2luYWwgPT0gbnVsbCAmJiBvcHRpb25zLnZub2RlICE9IG51bGwpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcblx0cmV0dXJuIHsgY3VycmVudDogbnVsbCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRnJhZ21lbnQocHJvcHMpIHtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQgUHJlYWN0IFZOb2RlLlxuICogQHBhcmFtIHsqfSB2bm9kZVxuICogQHJldHVybnMge3Zub2RlIGlzIGltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZEVsZW1lbnQgPSB2bm9kZSA9PlxuXHR2bm9kZSAhPSBudWxsICYmIHZub2RlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQ7XG4iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZGlmZiwgY29tbWl0Um9vdCB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcblxuLyoqXG4gKiBCYXNlIENvbXBvbmVudCBjbGFzcy4gUHJvdmlkZXMgYHNldFN0YXRlKClgIGFuZCBgZm9yY2VVcGRhdGUoKWAsIHdoaWNoXG4gKiB0cmlnZ2VyIHJlbmRlcmluZ1xuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFRoZSBpbml0aWFsIGNvbXBvbmVudCBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgVGhlIGluaXRpYWwgY29udGV4dCBmcm9tIHBhcmVudCBjb21wb25lbnRzJ1xuICogZ2V0Q2hpbGRDb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG4vKipcbiAqIFVwZGF0ZSBjb21wb25lbnQgc3RhdGUgYW5kIHNjaGVkdWxlIGEgcmUtcmVuZGVyLlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7b2JqZWN0IHwgKChzOiBvYmplY3QsIHA6IG9iamVjdCkgPT4gb2JqZWN0KX0gdXBkYXRlIEEgaGFzaCBvZiBzdGF0ZVxuICogcHJvcGVydGllcyB0byB1cGRhdGUgd2l0aCBuZXcgdmFsdWVzIG9yIGEgZnVuY3Rpb24gdGhhdCBnaXZlbiB0aGUgY3VycmVudFxuICogc3RhdGUgYW5kIHByb3BzIHJldHVybnMgYSBuZXcgcGFydGlhbCBzdGF0ZVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgY29tcG9uZW50IHN0YXRlIGlzXG4gKiB1cGRhdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbih1cGRhdGUsIGNhbGxiYWNrKSB7XG5cdC8vIG9ubHkgY2xvbmUgc3RhdGUgd2hlbiBjb3B5aW5nIHRvIG5leHRTdGF0ZSB0aGUgZmlyc3QgdGltZS5cblx0bGV0IHM7XG5cdGlmICh0aGlzLl9uZXh0U3RhdGUgIT0gbnVsbCAmJiB0aGlzLl9uZXh0U3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcblx0XHRzID0gdGhpcy5fbmV4dFN0YXRlO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGUgPSBhc3NpZ24oe30sIHRoaXMuc3RhdGUpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiB1cGRhdGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vIFNvbWUgbGlicmFyaWVzIGxpa2UgYGltbWVyYCBtYXJrIHRoZSBjdXJyZW50IHN0YXRlIGFzIHJlYWRvbmx5LFxuXHRcdC8vIHByZXZlbnRpbmcgdXMgZnJvbSBtdXRhdGluZyBpdCwgc28gd2UgbmVlZCB0byBjbG9uZSBpdC4gU2VlICMyNzE2XG5cdFx0dXBkYXRlID0gdXBkYXRlKGFzc2lnbih7fSwgcyksIHRoaXMucHJvcHMpO1xuXHR9XG5cblx0aWYgKHVwZGF0ZSkge1xuXHRcdGFzc2lnbihzLCB1cGRhdGUpO1xuXHR9XG5cblx0Ly8gU2tpcCB1cGRhdGUgaWYgdXBkYXRlciBmdW5jdGlvbiByZXR1cm5lZCBudWxsXG5cdGlmICh1cGRhdGUgPT0gbnVsbCkgcmV0dXJuO1xuXG5cdGlmICh0aGlzLl92bm9kZSkge1xuXHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5fc3RhdGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0fVxuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogSW1tZWRpYXRlbHkgcGVyZm9ybSBhIHN5bmNocm9ub3VzIHJlLXJlbmRlciBvZiB0aGUgY29tcG9uZW50XG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpc1xuICogcmUtcmVuZGVyZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdGlmICh0aGlzLl92bm9kZSkge1xuXHRcdC8vIFNldCByZW5kZXIgbW9kZSBzbyB0aGF0IHdlIGNhbiBkaWZmZXJlbnRpYXRlIHdoZXJlIHRoZSByZW5kZXIgcmVxdWVzdFxuXHRcdC8vIGlzIGNvbWluZyBmcm9tLiBXZSBuZWVkIHRoaXMgYmVjYXVzZSBmb3JjZVVwZGF0ZSBzaG91bGQgbmV2ZXIgY2FsbFxuXHRcdC8vIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuXHRcdHRoaXMuX2ZvcmNlID0gdHJ1ZTtcblx0XHRpZiAoY2FsbGJhY2spIHRoaXMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9XG59O1xuXG4vKipcbiAqIEFjY2VwdHMgYHByb3BzYCBhbmQgYHN0YXRlYCwgYW5kIHJldHVybnMgYSBuZXcgVmlydHVhbCBET00gdHJlZSB0byBidWlsZC5cbiAqIFZpcnR1YWwgRE9NIGlzIGdlbmVyYWxseSBjb25zdHJ1Y3RlZCB2aWEgW0pTWF0oaHR0cDovL2phc29uZm9ybWF0LmNvbS93dGYtaXMtanN4KS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBQcm9wcyAoZWc6IEpTWCBhdHRyaWJ1dGVzKSByZWNlaXZlZCBmcm9tIHBhcmVudFxuICogZWxlbWVudC9jb21wb25lbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSBUaGUgY29tcG9uZW50J3MgY3VycmVudCBzdGF0ZVxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgQ29udGV4dCBvYmplY3QsIGFzIHJldHVybmVkIGJ5IHRoZSBuZWFyZXN0XG4gKiBhbmNlc3RvcidzIGBnZXRDaGlsZENvbnRleHQoKWBcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW5kZXgnKS5Db21wb25lbnRDaGlsZHJlbiB8IHZvaWR9XG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gRnJhZ21lbnQ7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gW2NoaWxkSW5kZXhdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREb21TaWJsaW5nKHZub2RlLCBjaGlsZEluZGV4KSB7XG5cdGlmIChjaGlsZEluZGV4ID09IG51bGwpIHtcblx0XHQvLyBVc2UgY2hpbGRJbmRleD09bnVsbCBhcyBhIHNpZ25hbCB0byByZXN1bWUgdGhlIHNlYXJjaCBmcm9tIHRoZSB2bm9kZSdzIHNpYmxpbmdcblx0XHRyZXR1cm4gdm5vZGUuX3BhcmVudFxuXHRcdFx0PyBnZXREb21TaWJsaW5nKHZub2RlLl9wYXJlbnQsIHZub2RlLl9wYXJlbnQuX2NoaWxkcmVuLmluZGV4T2Yodm5vZGUpICsgMSlcblx0XHRcdDogbnVsbDtcblx0fVxuXG5cdGxldCBzaWJsaW5nO1xuXHRmb3IgKDsgY2hpbGRJbmRleCA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGNoaWxkSW5kZXgrKykge1xuXHRcdHNpYmxpbmcgPSB2bm9kZS5fY2hpbGRyZW5bY2hpbGRJbmRleF07XG5cblx0XHRpZiAoc2libGluZyAhPSBudWxsICYmIHNpYmxpbmcuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHQvLyBTaW5jZSB1cGRhdGVQYXJlbnREb21Qb2ludGVycyBrZWVwcyBfZG9tIHBvaW50ZXIgY29ycmVjdCxcblx0XHRcdC8vIHdlIGNhbiByZWx5IG9uIF9kb20gdG8gdGVsbCB1cyBpZiB0aGlzIHN1YnRyZWUgY29udGFpbnMgYVxuXHRcdFx0Ly8gcmVuZGVyZWQgRE9NIG5vZGUsIGFuZCB3aGF0IHRoZSBmaXJzdCByZW5kZXJlZCBET00gbm9kZSBpc1xuXHRcdFx0cmV0dXJuIHNpYmxpbmcuX2RvbTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiB3ZSBnZXQgaGVyZSwgd2UgaGF2ZSBub3QgZm91bmQgYSBET00gbm9kZSBpbiB0aGlzIHZub2RlJ3MgY2hpbGRyZW4uXG5cdC8vIFdlIG11c3QgcmVzdW1lIGZyb20gdGhpcyB2bm9kZSdzIHNpYmxpbmcgKGluIGl0J3MgcGFyZW50IF9jaGlsZHJlbiBhcnJheSlcblx0Ly8gT25seSBjbGltYiB1cCBhbmQgc2VhcmNoIHRoZSBwYXJlbnQgaWYgd2UgYXJlbid0IHNlYXJjaGluZyB0aHJvdWdoIGEgRE9NXG5cdC8vIFZOb2RlIChtZWFuaW5nIHdlIHJlYWNoZWQgdGhlIERPTSBwYXJlbnQgb2YgdGhlIG9yaWdpbmFsIHZub2RlIHRoYXQgYmVnYW5cblx0Ly8gdGhlIHNlYXJjaClcblx0cmV0dXJuIHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicgPyBnZXREb21TaWJsaW5nKHZub2RlKSA6IG51bGw7XG59XG5cbi8qKlxuICogVHJpZ2dlciBpbi1wbGFjZSByZS1yZW5kZXJpbmcgb2YgYSBjb21wb25lbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudCkge1xuXHRsZXQgdm5vZGUgPSBjb21wb25lbnQuX3Zub2RlLFxuXHRcdG9sZERvbSA9IHZub2RlLl9kb20sXG5cdFx0cGFyZW50RG9tID0gY29tcG9uZW50Ll9wYXJlbnREb207XG5cblx0aWYgKHBhcmVudERvbSkge1xuXHRcdGxldCBjb21taXRRdWV1ZSA9IFtdO1xuXHRcdGNvbnN0IG9sZFZOb2RlID0gYXNzaWduKHt9LCB2bm9kZSk7XG5cdFx0b2xkVk5vZGUuX29yaWdpbmFsID0gdm5vZGUuX29yaWdpbmFsICsgMTtcblxuXHRcdGRpZmYoXG5cdFx0XHRwYXJlbnREb20sXG5cdFx0XHR2bm9kZSxcblx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0Y29tcG9uZW50Ll9nbG9iYWxDb250ZXh0LFxuXHRcdFx0cGFyZW50RG9tLm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuXHRcdFx0dm5vZGUuX2h5ZHJhdGluZyAhPSBudWxsID8gW29sZERvbV0gOiBudWxsLFxuXHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRvbGREb20gPT0gbnVsbCA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogb2xkRG9tLFxuXHRcdFx0dm5vZGUuX2h5ZHJhdGluZ1xuXHRcdCk7XG5cdFx0Y29tbWl0Um9vdChjb21taXRRdWV1ZSwgdm5vZGUpO1xuXG5cdFx0aWYgKHZub2RlLl9kb20gIT0gb2xkRG9tKSB7XG5cdFx0XHR1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpIHtcblx0aWYgKCh2bm9kZSA9IHZub2RlLl9wYXJlbnQpICE9IG51bGwgJiYgdm5vZGUuX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0dm5vZGUuX2RvbSA9IHZub2RlLl9jb21wb25lbnQuYmFzZSA9IG51bGw7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBjaGlsZCA9IHZub2RlLl9jaGlsZHJlbltpXTtcblx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLl9kb20gIT0gbnVsbCkge1xuXHRcdFx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gY2hpbGQuX2RvbTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSByZW5kZXIgcXVldWVcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fVxuICovXG5sZXQgcmVyZW5kZXJRdWV1ZSA9IFtdO1xuXG4vKlxuICogVGhlIHZhbHVlIG9mIGBDb21wb25lbnQuZGVib3VuY2VgIG11c3QgYXN5bmNocm9ub3VzbHkgaW52b2tlIHRoZSBwYXNzZWQgaW4gY2FsbGJhY2suIEl0IGlzXG4gKiBpbXBvcnRhbnQgdGhhdCBjb250cmlidXRvcnMgdG8gUHJlYWN0IGNhbiBjb25zaXN0ZW50bHkgcmVhc29uIGFib3V0IHdoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCwgZXRjLlxuICogZG8sIGFuZCB3aGVuIHRoZWlyIGVmZmVjdHMgd2lsbCBiZSBhcHBsaWVkLiBTZWUgdGhlIGxpbmtzIGJlbG93IGZvciBzb21lIGZ1cnRoZXIgcmVhZGluZyBvbiBkZXNpZ25pbmdcbiAqIGFzeW5jaHJvbm91cyBBUElzLlxuICogKiBbRGVzaWduaW5nIEFQSXMgZm9yIEFzeW5jaHJvbnldKGh0dHBzOi8vYmxvZy5penMubWUvMjAxMy8wOC9kZXNpZ25pbmctYXBpcy1mb3ItYXN5bmNocm9ueSlcbiAqICogW0NhbGxiYWNrcyBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzXShodHRwczovL2Jsb2cub21ldGVyLmNvbS8yMDExLzA3LzI0L2NhbGxiYWNrcy1zeW5jaHJvbm91cy1hbmQtYXN5bmNocm9ub3VzLylcbiAqL1xuXG5sZXQgcHJldkRlYm91bmNlO1xuXG4vKipcbiAqIEVucXVldWUgYSByZXJlbmRlciBvZiBhIGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9IGMgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5xdWV1ZVJlbmRlcihjKSB7XG5cdGlmIChcblx0XHQoIWMuX2RpcnR5ICYmXG5cdFx0XHQoYy5fZGlydHkgPSB0cnVlKSAmJlxuXHRcdFx0cmVyZW5kZXJRdWV1ZS5wdXNoKGMpICYmXG5cdFx0XHQhcHJvY2Vzcy5fcmVyZW5kZXJDb3VudCsrKSB8fFxuXHRcdHByZXZEZWJvdW5jZSAhPT0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZ1xuXHQpIHtcblx0XHRwcmV2RGVib3VuY2UgPSBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nO1xuXHRcdChwcmV2RGVib3VuY2UgfHwgc2V0VGltZW91dCkocHJvY2Vzcyk7XG5cdH1cbn1cblxuLyoqIEZsdXNoIHRoZSByZW5kZXIgcXVldWUgYnkgcmVyZW5kZXJpbmcgYWxsIHF1ZXVlZCBjb21wb25lbnRzICovXG5mdW5jdGlvbiBwcm9jZXNzKCkge1xuXHRsZXQgcXVldWU7XG5cdHdoaWxlICgocHJvY2Vzcy5fcmVyZW5kZXJDb3VudCA9IHJlcmVuZGVyUXVldWUubGVuZ3RoKSkge1xuXHRcdHF1ZXVlID0gcmVyZW5kZXJRdWV1ZS5zb3J0KChhLCBiKSA9PiBhLl92bm9kZS5fZGVwdGggLSBiLl92bm9kZS5fZGVwdGgpO1xuXHRcdHJlcmVuZGVyUXVldWUgPSBbXTtcblx0XHQvLyBEb24ndCB1cGRhdGUgYHJlbmRlckNvdW50YCB5ZXQuIEtlZXAgaXRzIHZhbHVlIG5vbi16ZXJvIHRvIHByZXZlbnQgdW5uZWNlc3Nhcnlcblx0XHQvLyBwcm9jZXNzKCkgY2FsbHMgZnJvbSBnZXR0aW5nIHNjaGVkdWxlZCB3aGlsZSBgcXVldWVgIGlzIHN0aWxsIGJlaW5nIGNvbnN1bWVkLlxuXHRcdHF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0XHRpZiAoYy5fZGlydHkpIHJlbmRlckNvbXBvbmVudChjKTtcblx0XHR9KTtcblx0fVxufVxuXG5wcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gMDtcbiIsImltcG9ydCB7IGVucXVldWVSZW5kZXIgfSBmcm9tICcuL2NvbXBvbmVudCc7XG5cbmV4cG9ydCBsZXQgaSA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY29udGV4dElkKSB7XG5cdGNvbnRleHRJZCA9ICdfX2NDJyArIGkrKztcblxuXHRjb25zdCBjb250ZXh0ID0ge1xuXHRcdF9pZDogY29udGV4dElkLFxuXHRcdF9kZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSAqL1xuXHRcdENvbnN1bWVyKHByb3BzLCBjb250ZXh0VmFsdWUpIHtcblx0XHRcdC8vIHJldHVybiBwcm9wcy5jaGlsZHJlbihcblx0XHRcdC8vIFx0Y29udGV4dFtjb250ZXh0SWRdID8gY29udGV4dFtjb250ZXh0SWRdLnByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlXG5cdFx0XHQvLyApO1xuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuKGNvbnRleHRWYWx1ZSk7XG5cdFx0fSxcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSAqL1xuXHRcdFByb3ZpZGVyKHByb3BzKSB7XG5cdFx0XHRpZiAoIXRoaXMuZ2V0Q2hpbGRDb250ZXh0KSB7XG5cdFx0XHRcdGxldCBzdWJzID0gW107XG5cdFx0XHRcdGxldCBjdHggPSB7fTtcblx0XHRcdFx0Y3R4W2NvbnRleHRJZF0gPSB0aGlzO1xuXG5cdFx0XHRcdHRoaXMuZ2V0Q2hpbGRDb250ZXh0ID0gKCkgPT4gY3R4O1xuXG5cdFx0XHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24oX3Byb3BzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuXHRcdFx0XHRcdFx0Ly8gSSB0aGluayB0aGUgZm9yY2VkIHZhbHVlIHByb3BhZ2F0aW9uIGhlcmUgd2FzIG9ubHkgbmVlZGVkIHdoZW4gYG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdgIHdhcyBiZWluZyBieXBhc3NlZDpcblx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvY29tbWl0LzRkMzM5ZmI4MDNiZWEwOWU5ZjE5OGFiZjM4Y2ExYmY4ZWE0Yjc3NzEjZGlmZi01NDY4MmNlMzgwOTM1YTcxN2U0MWI4YmZjNTQ3MzdmNlIzNThcblx0XHRcdFx0XHRcdC8vIEluIHRob3NlIGNhc2VzIHRob3VnaCwgZXZlbiB3aXRoIHRoZSB2YWx1ZSBjb3JyZWN0ZWQsIHdlJ3JlIGRvdWJsZS1yZW5kZXJpbmcgYWxsIG5vZGVzLlxuXHRcdFx0XHRcdFx0Ly8gSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGp1c3QgdGVsbCBmb2xrcyBub3QgdG8gdXNlIGZvcmNlLXN5bmMgbW9kZS5cblx0XHRcdFx0XHRcdC8vIEN1cnJlbnRseSwgdXNpbmcgYHVzZUNvbnRleHQoKWAgaW4gYSBjbGFzcyBjb21wb25lbnQgd2lsbCBvdmVyd3JpdGUgaXRzIGB0aGlzLmNvbnRleHRgIHZhbHVlLlxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHQgPSBfcHJvcHMudmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHQvLyB9KTtcblxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHRbY29udGV4dElkXSA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXHRcdFx0XHRcdFx0c3Vicy5zb21lKGVucXVldWVSZW5kZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnN1YiA9IGMgPT4ge1xuXHRcdFx0XHRcdHN1YnMucHVzaChjKTtcblx0XHRcdFx0XHRsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcblx0XHRcdFx0XHRcdGlmIChvbGQpIG9sZC5jYWxsKGMpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcblx0XHR9XG5cdH07XG5cblx0Ly8gRGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB3aGVuIGl0XG5cdC8vIGVuY291bnRlcnMgYSBQcm92aWRlci4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gc3VwcG9ydFxuXHQvLyBzZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gdGhlIGNvbnRleHQgb2JqZWN0IGluc3RlYWRcblx0Ly8gb2Ygb24gdGhlIGNvbXBvbmVudCBpdHNlbGYuIFNlZTpcblx0Ly8gaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2NvbnRleHQuaHRtbCNjb250ZXh0ZGlzcGxheW5hbWVcblxuXHRyZXR1cm4gKGNvbnRleHQuUHJvdmlkZXIuX2NvbnRleHRSZWYgPSBjb250ZXh0LkNvbnN1bWVyLmNvbnRleHRUeXBlID0gY29udGV4dCk7XG59XG4iLCJleHBvcnQgY29uc3QgRU1QVFlfT0JKID0ge307XG5leHBvcnQgY29uc3QgRU1QVFlfQVJSID0gW107XG5leHBvcnQgY29uc3QgSVNfTk9OX0RJTUVOU0lPTkFMID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmR8aXRlcmEvaTtcbiIsImltcG9ydCB7IGRpZmYsIHVubW91bnQsIGFwcGx5UmVmIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSwgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBFTVBUWV9PQkosIEVNUFRZX0FSUiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWZmIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB3aG9zZVxuICogY2hpbGRyZW4gYXJlIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW5bXX0gcmVuZGVyUmVzdWx0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3UGFyZW50Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsXG4gKiBub2RlIHdob3NlIGNoaWxkcmVuIHNob3VsZCBiZSBkaWZmJ2VkIGFnYWluc3Qgb2xkUGFyZW50Vk5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRQYXJlbnRWTm9kZSBUaGUgb2xkIHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBuZXdQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QgLSBtb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoaWxkcmVuKFxuXHRwYXJlbnREb20sXG5cdHJlbmRlclJlc3VsdCxcblx0bmV3UGFyZW50Vk5vZGUsXG5cdG9sZFBhcmVudFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IGksIGosIG9sZFZOb2RlLCBjaGlsZFZOb2RlLCBuZXdEb20sIGZpcnN0Q2hpbGREb20sIHJlZnM7XG5cblx0Ly8gVGhpcyBpcyBhIGNvbXByZXNzaW9uIG9mIG9sZFBhcmVudFZOb2RlIT1udWxsICYmIG9sZFBhcmVudFZOb2RlICE9IEVNUFRZX09CSiAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4gfHwgRU1QVFlfQVJSXG5cdC8vIGFzIEVNUFRZX09CSi5fY2hpbGRyZW4gc2hvdWxkIGJlIGB1bmRlZmluZWRgLlxuXHRsZXQgb2xkQ2hpbGRyZW4gPSAob2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuX2NoaWxkcmVuKSB8fCBFTVBUWV9BUlI7XG5cblx0bGV0IG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkQ2hpbGRyZW4ubGVuZ3RoO1xuXG5cdG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgcmVuZGVyUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRWTm9kZSA9IHJlbmRlclJlc3VsdFtpXTtcblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwgfHwgdHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gbnVsbDtcblx0XHR9XG5cdFx0Ly8gSWYgdGhpcyBuZXdWTm9kZSBpcyBiZWluZyByZXVzZWQgKGUuZy4gPGRpdj57cmV1c2V9e3JldXNlfTwvZGl2PikgaW4gdGhlIHNhbWUgZGlmZixcblx0XHQvLyBvciB3ZSBhcmUgcmVuZGVyaW5nIGEgY29tcG9uZW50IChlLmcuIHNldFN0YXRlKSBjb3B5IHRoZSBvbGRWTm9kZXMgc28gaXQgY2FuIGhhdmVcblx0XHQvLyBpdCdzIG93biBET00gJiBldGMuIHBvaW50ZXJzXG5cdFx0ZWxzZSBpZiAoXG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnc3RyaW5nJyB8fFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ251bWJlcicgfHxcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2Zcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdiaWdpbnQnXG5cdFx0KSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkVk5vZGUpKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdEZyYWdtZW50LFxuXHRcdFx0XHR7IGNoaWxkcmVuOiBjaGlsZFZOb2RlIH0sXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChjaGlsZFZOb2RlLl9kZXB0aCA+IDApIHtcblx0XHRcdC8vIFZOb2RlIGlzIGFscmVhZHkgaW4gdXNlLCBjbG9uZSBpdC4gVGhpcyBjYW4gaGFwcGVuIGluIHRoZSBmb2xsb3dpbmdcblx0XHRcdC8vIHNjZW5hcmlvOlxuXHRcdFx0Ly8gICBjb25zdCByZXVzZSA9IDxkaXYgLz5cblx0XHRcdC8vICAgPGRpdj57cmV1c2V9PHNwYW4gLz57cmV1c2V9PC9kaXY+XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5wcm9wcyxcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXksXG5cdFx0XHRcdGNoaWxkVk5vZGUucmVmID8gY2hpbGRWTm9kZS5yZWYgOiBudWxsLFxuXHRcdFx0XHRjaGlsZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IGNoaWxkVk5vZGU7XG5cdFx0fVxuXG5cdFx0Ly8gVGVyc2VyIHJlbW92ZXMgdGhlIGBjb250aW51ZWAgaGVyZSBhbmQgd3JhcHMgdGhlIGxvb3AgYm9keVxuXHRcdC8vIGluIGEgYGlmIChjaGlsZFZOb2RlKSB7IC4uLiB9IGNvbmRpdGlvblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNoaWxkVk5vZGUuX3BhcmVudCA9IG5ld1BhcmVudFZOb2RlO1xuXHRcdGNoaWxkVk5vZGUuX2RlcHRoID0gbmV3UGFyZW50Vk5vZGUuX2RlcHRoICsgMTtcblxuXHRcdC8vIENoZWNrIGlmIHdlIGZpbmQgYSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgaW4gb2xkQ2hpbGRyZW4uXG5cdFx0Ly8gSWYgZm91bmQsIGRlbGV0ZSB0aGUgYXJyYXkgaXRlbSBieSBzZXR0aW5nIHRvIGB1bmRlZmluZWRgLlxuXHRcdC8vIFdlIHVzZSBgdW5kZWZpbmVkYCwgYXMgYG51bGxgIGlzIHJlc2VydmVkIGZvciBlbXB0eSBwbGFjZWhvbGRlcnNcblx0XHQvLyAoaG9sZXMpLlxuXHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG5cblx0XHRpZiAoXG5cdFx0XHRvbGRWTm9kZSA9PT0gbnVsbCB8fFxuXHRcdFx0KG9sZFZOb2RlICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUua2V5ID09IG9sZFZOb2RlLmtleSAmJlxuXHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGUpXG5cdFx0KSB7XG5cdFx0XHRvbGRDaGlsZHJlbltpXSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRWl0aGVyIG9sZFZOb2RlID09PSB1bmRlZmluZWQgb3Igb2xkQ2hpbGRyZW5MZW5ndGggPiAwLFxuXHRcdFx0Ly8gc28gYWZ0ZXIgdGhpcyBsb29wIG9sZFZOb2RlID09IG51bGwgb3Igb2xkVk5vZGUgaXMgYSB2YWxpZCB2YWx1ZS5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBvbGRDaGlsZHJlbkxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5bal07XG5cdFx0XHRcdC8vIElmIGNoaWxkVk5vZGUgaXMgdW5rZXllZCwgd2Ugb25seSBtYXRjaCBzaW1pbGFybHkgdW5rZXllZCBub2Rlcywgb3RoZXJ3aXNlIHdlIG1hdGNoIGJ5IGtleS5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIG1hdGNoIGJ5IHR5cGUgKGluIGVpdGhlciBjYXNlKS5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG9sZFZOb2RlICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlID09PSBvbGRWTm9kZS50eXBlXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdG9sZENoaWxkcmVuW2pdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9sZFZOb2RlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvbGRWTm9kZSA9IG9sZFZOb2RlIHx8IEVNUFRZX09CSjtcblxuXHRcdC8vIE1vcnBoIHRoZSBvbGQgZWxlbWVudCBpbnRvIHRoZSBuZXcgb25lLCBidXQgZG9uJ3QgYXBwZW5kIGl0IHRvIHRoZSBkb20geWV0XG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRpc1N2Zyxcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRvbGREb20sXG5cdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdCk7XG5cblx0XHRuZXdEb20gPSBjaGlsZFZOb2RlLl9kb207XG5cblx0XHRpZiAoKGogPSBjaGlsZFZOb2RlLnJlZikgJiYgb2xkVk5vZGUucmVmICE9IGopIHtcblx0XHRcdGlmICghcmVmcykgcmVmcyA9IFtdO1xuXHRcdFx0aWYgKG9sZFZOb2RlLnJlZikgcmVmcy5wdXNoKG9sZFZOb2RlLnJlZiwgbnVsbCwgY2hpbGRWTm9kZSk7XG5cdFx0XHRyZWZzLnB1c2goaiwgY2hpbGRWTm9kZS5fY29tcG9uZW50IHx8IG5ld0RvbSwgY2hpbGRWTm9kZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG5ld0RvbSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoZmlyc3RDaGlsZERvbSA9PSBudWxsKSB7XG5cdFx0XHRcdGZpcnN0Q2hpbGREb20gPSBuZXdEb207XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUuX2NoaWxkcmVuID09PSBvbGRWTm9kZS5fY2hpbGRyZW5cblx0XHRcdCkge1xuXHRcdFx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKFxuXHRcdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRcdHBhcmVudERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChcblx0XHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRDaGlsZHJlbixcblx0XHRcdFx0XHRuZXdEb20sXG5cdFx0XHRcdFx0b2xkRG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8vIEJlY2F1c2UgdGhlIG5ld1BhcmVudFZOb2RlIGlzIEZyYWdtZW50LWxpa2UsIHdlIG5lZWQgdG8gc2V0IGl0J3Ncblx0XHRcdFx0Ly8gX25leHREb20gcHJvcGVydHkgdG8gdGhlIG5leHRTaWJsaW5nIG9mIGl0cyBsYXN0IGNoaWxkIERPTSBub2RlLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBgb2xkRG9tYCBjb250YWlucyB0aGUgY29ycmVjdCB2YWx1ZSBoZXJlIGJlY2F1c2UgaWYgdGhlIGxhc3QgY2hpbGRcblx0XHRcdFx0Ly8gaXMgYSBGcmFnbWVudC1saWtlLCB0aGVuIG9sZERvbSBoYXMgYWxyZWFkeSBiZWVuIHNldCB0byB0aGF0IGNoaWxkJ3MgX25leHREb20uXG5cdFx0XHRcdC8vIElmIHRoZSBsYXN0IGNoaWxkIGlzIGEgRE9NIFZOb2RlLCB0aGVuIG9sZERvbSB3aWxsIGJlIHNldCB0byB0aGF0IERPTVxuXHRcdFx0XHQvLyBub2RlJ3MgbmV4dFNpYmxpbmcuXG5cdFx0XHRcdG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRvbGREb20gJiZcblx0XHRcdG9sZFZOb2RlLl9kb20gPT0gb2xkRG9tICYmXG5cdFx0XHRvbGREb20ucGFyZW50Tm9kZSAhPSBwYXJlbnREb21cblx0XHQpIHtcblx0XHRcdC8vIFRoZSBhYm92ZSBjb25kaXRpb24gaXMgdG8gaGFuZGxlIG51bGwgcGxhY2Vob2xkZXJzLiBTZWUgdGVzdCBpbiBwbGFjZWhvbGRlci50ZXN0LmpzOlxuXHRcdFx0Ly8gYGVmZmljaWVudGx5IHJlcGxhY2UgbnVsbCBwbGFjZWhvbGRlcnMgaW4gcGFyZW50IHJlcmVuZGVyc2Bcblx0XHRcdG9sZERvbSA9IGdldERvbVNpYmxpbmcob2xkVk5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdG5ld1BhcmVudFZOb2RlLl9kb20gPSBmaXJzdENoaWxkRG9tO1xuXG5cdC8vIFJlbW92ZSByZW1haW5pbmcgb2xkQ2hpbGRyZW4gaWYgdGhlcmUgYXJlIGFueS5cblx0Zm9yIChpID0gb2xkQ2hpbGRyZW5MZW5ndGg7IGktLTsgKSB7XG5cdFx0aWYgKG9sZENoaWxkcmVuW2ldICE9IG51bGwpIHtcblx0XHRcdHVubW91bnQob2xkQ2hpbGRyZW5baV0sIG9sZENoaWxkcmVuW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgcmVmcyBvbmx5IGFmdGVyIHVubW91bnRcblx0aWYgKHJlZnMpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXBwbHlSZWYocmVmc1tpXSwgcmVmc1srK2ldLCByZWZzWysraV0pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW9yZGVyQ2hpbGRyZW4oY2hpbGRWTm9kZSwgb2xkRG9tLCBwYXJlbnREb20pIHtcblx0Ly8gTm90ZTogVk5vZGVzIGluIG5lc3RlZCBzdXNwZW5kZWQgdHJlZXMgbWF5IGJlIG1pc3NpbmcgX2NoaWxkcmVuLlxuXHRsZXQgYyA9IGNoaWxkVk5vZGUuX2NoaWxkcmVuO1xuXHRsZXQgdG1wID0gMDtcblx0Zm9yICg7IGMgJiYgdG1wIDwgYy5sZW5ndGg7IHRtcCsrKSB7XG5cdFx0bGV0IHZub2RlID0gY1t0bXBdO1xuXHRcdGlmICh2bm9kZSkge1xuXHRcdFx0Ly8gV2UgdHlwaWNhbGx5IGVudGVyIHRoaXMgY29kZSBwYXRoIG9uIHNDVSBiYWlsb3V0LCB3aGVyZSB3ZSBjb3B5XG5cdFx0XHQvLyBvbGRWTm9kZS5fY2hpbGRyZW4gdG8gbmV3Vk5vZGUuX2NoaWxkcmVuLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCB3ZSBuZWVkXG5cdFx0XHQvLyB0byB1cGRhdGUgdGhlIG9sZCBjaGlsZHJlbidzIF9wYXJlbnQgcG9pbnRlciB0byBwb2ludCB0byB0aGUgbmV3Vk5vZGVcblx0XHRcdC8vIChjaGlsZFZOb2RlIGhlcmUpLlxuXHRcdFx0dm5vZGUuX3BhcmVudCA9IGNoaWxkVk5vZGU7XG5cblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdG9sZERvbSA9IHJlb3JkZXJDaGlsZHJlbih2bm9kZSwgb2xkRG9tLCBwYXJlbnREb20pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChwYXJlbnREb20sIHZub2RlLCB2bm9kZSwgYywgdm5vZGUuX2RvbSwgb2xkRG9tKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYW5kIGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVufSBjaGlsZHJlbiBUaGUgdW5mbGF0dGVuZWRcbiAqIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0NoaWxkQXJyYXkoY2hpbGRyZW4sIG91dCkge1xuXHRvdXQgPSBvdXQgfHwgW107XG5cdGlmIChjaGlsZHJlbiA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZHJlbiA9PSAnYm9vbGVhbicpIHtcblx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdGNoaWxkcmVuLnNvbWUoY2hpbGQgPT4ge1xuXHRcdFx0dG9DaGlsZEFycmF5KGNoaWxkLCBvdXQpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG91dC5wdXNoKGNoaWxkcmVuKTtcblx0fVxuXHRyZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwbGFjZUNoaWxkKFxuXHRwYXJlbnREb20sXG5cdGNoaWxkVk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRvbGRDaGlsZHJlbixcblx0bmV3RG9tLFxuXHRvbGREb21cbikge1xuXHRsZXQgbmV4dERvbTtcblx0aWYgKGNoaWxkVk5vZGUuX25leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIE9ubHkgRnJhZ21lbnRzIG9yIGNvbXBvbmVudHMgdGhhdCByZXR1cm4gRnJhZ21lbnQgbGlrZSBWTm9kZXMgd2lsbFxuXHRcdC8vIGhhdmUgYSBub24tdW5kZWZpbmVkIF9uZXh0RG9tLiBDb250aW51ZSB0aGUgZGlmZiBmcm9tIHRoZSBzaWJsaW5nXG5cdFx0Ly8gb2YgbGFzdCBET00gY2hpbGQgb2YgdGhpcyBjaGlsZCBWTm9kZVxuXHRcdG5leHREb20gPSBjaGlsZFZOb2RlLl9uZXh0RG9tO1xuXG5cdFx0Ly8gRWFnZXJseSBjbGVhbnVwIF9uZXh0RG9tLiBXZSBkb24ndCBuZWVkIHRvIHBlcnNpc3QgdGhlIHZhbHVlIGJlY2F1c2Vcblx0XHQvLyBpdCBpcyBvbmx5IHVzZWQgYnkgYGRpZmZDaGlsZHJlbmAgdG8gZGV0ZXJtaW5lIHdoZXJlIHRvIHJlc3VtZSB0aGUgZGlmZiBhZnRlclxuXHRcdC8vIGRpZmZpbmcgQ29tcG9uZW50cyBhbmQgRnJhZ21lbnRzLiBPbmNlIHdlIHN0b3JlIGl0IHRoZSBuZXh0RE9NIGxvY2FsIHZhciwgd2Vcblx0XHQvLyBjYW4gY2xlYW4gdXAgdGhlIHByb3BlcnR5XG5cdFx0Y2hpbGRWTm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChcblx0XHRvbGRWTm9kZSA9PSBudWxsIHx8XG5cdFx0bmV3RG9tICE9IG9sZERvbSB8fFxuXHRcdG5ld0RvbS5wYXJlbnROb2RlID09IG51bGxcblx0KSB7XG5cdFx0b3V0ZXI6IGlmIChvbGREb20gPT0gbnVsbCB8fCBvbGREb20ucGFyZW50Tm9kZSAhPT0gcGFyZW50RG9tKSB7XG5cdFx0XHRwYXJlbnREb20uYXBwZW5kQ2hpbGQobmV3RG9tKTtcblx0XHRcdG5leHREb20gPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBgajxvbGRDaGlsZHJlbkxlbmd0aDsgais9MmAgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gYGorKzxvbGRDaGlsZHJlbkxlbmd0aC8yYFxuXHRcdFx0Zm9yIChcblx0XHRcdFx0bGV0IHNpYkRvbSA9IG9sZERvbSwgaiA9IDA7XG5cdFx0XHRcdChzaWJEb20gPSBzaWJEb20ubmV4dFNpYmxpbmcpICYmIGogPCBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cdFx0XHRcdGogKz0gMVxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChzaWJEb20gPT0gbmV3RG9tKSB7XG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHBhcmVudERvbS5pbnNlcnRCZWZvcmUobmV3RG9tLCBvbGREb20pO1xuXHRcdFx0bmV4dERvbSA9IG9sZERvbTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIHByZS1jYWxjdWxhdGVkIHRoZSBuZXh0RE9NIG5vZGUsIHVzZSBpdC4gRWxzZSBjYWxjdWxhdGUgaXQgbm93XG5cdC8vIFN0cmljdGx5IGNoZWNrIGZvciBgdW5kZWZpbmVkYCBoZXJlIGN1eiBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZSBvZiBgbmV4dERvbWAuXG5cdC8vIFNlZSBtb3JlIGRldGFpbCBpbiBjcmVhdGUtZWxlbWVudC5qczpjcmVhdGVWTm9kZVxuXHRpZiAobmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0b2xkRG9tID0gbmV4dERvbTtcblx0fSBlbHNlIHtcblx0XHRvbGREb20gPSBuZXdEb20ubmV4dFNpYmxpbmc7XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuIiwiaW1wb3J0IHsgSVNfTk9OX0RJTUVOU0lPTkFMIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdGhlIG9sZCBhbmQgbmV3IHByb3BlcnRpZXMgb2YgYSBWTm9kZSBhbmQgYXBwbHkgY2hhbmdlcyB0byB0aGUgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gYXBwbHlcbiAqIGNoYW5nZXMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBUaGUgbmV3IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gb2xkUHJvcHMgVGhlIG9sZCBwcm9wc1xuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaHlkcmF0ZSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uIG1vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGh5ZHJhdGUpIHtcblx0bGV0IGk7XG5cblx0Zm9yIChpIGluIG9sZFByb3BzKSB7XG5cdFx0aWYgKGkgIT09ICdjaGlsZHJlbicgJiYgaSAhPT0gJ2tleScgJiYgIShpIGluIG5ld1Byb3BzKSkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBudWxsLCBvbGRQcm9wc1tpXSwgaXNTdmcpO1xuXHRcdH1cblx0fVxuXG5cdGZvciAoaSBpbiBuZXdQcm9wcykge1xuXHRcdGlmIChcblx0XHRcdCghaHlkcmF0ZSB8fCB0eXBlb2YgbmV3UHJvcHNbaV0gPT0gJ2Z1bmN0aW9uJykgJiZcblx0XHRcdGkgIT09ICdjaGlsZHJlbicgJiZcblx0XHRcdGkgIT09ICdrZXknICYmXG5cdFx0XHRpICE9PSAndmFsdWUnICYmXG5cdFx0XHRpICE9PSAnY2hlY2tlZCcgJiZcblx0XHRcdG9sZFByb3BzW2ldICE9PSBuZXdQcm9wc1tpXVxuXHRcdCkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBuZXdQcm9wc1tpXSwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIGtleSwgdmFsdWUpIHtcblx0aWYgKGtleVswXSA9PT0gJy0nKSB7XG5cdFx0c3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG5cdH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdHN0eWxlW2tleV0gPSAnJztcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT0gJ251bWJlcicgfHwgSVNfTk9OX0RJTUVOU0lPTkFMLnRlc3Qoa2V5KSkge1xuXHRcdHN0eWxlW2tleV0gPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWUgKyAncHgnO1xuXHR9XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgdmFsdWUgb24gYSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBtb2RpZnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgcHJvcGVydHkgdG9cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSB0aGUgcHJvcGVydHkgaGFkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGUgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eShkb20sIG5hbWUsIHZhbHVlLCBvbGRWYWx1ZSwgaXNTdmcpIHtcblx0bGV0IHVzZUNhcHR1cmU7XG5cblx0bzogaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZFZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkVmFsdWUgPSAnJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9sZFZhbHVlKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiBvbGRWYWx1ZSkge1xuXHRcdFx0XHRcdGlmICghKHZhbHVlICYmIG5hbWUgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShkb20uc3R5bGUsIG5hbWUsICcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICghb2xkVmFsdWUgfHwgdmFsdWVbbmFtZV0gIT09IG9sZFZhbHVlW25hbWVdKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShkb20uc3R5bGUsIG5hbWUsIHZhbHVlW25hbWVdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gQmVuY2htYXJrIGZvciBjb21wYXJpc29uOiBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzU3NGM5NTRiZGI5NjViOWEwMDk2NWFjNlxuXHRlbHNlIGlmIChuYW1lWzBdID09PSAnbycgJiYgbmFtZVsxXSA9PT0gJ24nKSB7XG5cdFx0dXNlQ2FwdHVyZSA9IG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9DYXB0dXJlJC8sICcnKSk7XG5cblx0XHQvLyBJbmZlciBjb3JyZWN0IGNhc2luZyBmb3IgRE9NIGJ1aWx0LWluIGV2ZW50czpcblx0XHRpZiAobmFtZS50b0xvd2VyQ2FzZSgpIGluIGRvbSkgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgyKTtcblx0XHRlbHNlIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuXG5cdFx0aWYgKCFkb20uX2xpc3RlbmVycykgZG9tLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRkb20uX2xpc3RlbmVyc1tuYW1lICsgdXNlQ2FwdHVyZV0gPSB2YWx1ZTtcblxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCFvbGRWYWx1ZSkge1xuXHRcdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGhhbmRsZXIgPSB1c2VDYXB0dXJlID8gZXZlbnRQcm94eUNhcHR1cmUgOiBldmVudFByb3h5O1xuXHRcdFx0ZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgIT09ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcpIHtcblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdC8vIE5vcm1hbGl6ZSBpbmNvcnJlY3QgcHJvcCB1c2FnZSBmb3IgU1ZHOlxuXHRcdFx0Ly8gLSB4bGluazpocmVmIC8geGxpbmtIcmVmIC0tPiBocmVmICh4bGluazpocmVmIHdhcyByZW1vdmVkIGZyb20gU1ZHIGFuZCBpc24ndCBuZWVkZWQpXG5cdFx0XHQvLyAtIGNsYXNzTmFtZSAtLT4gY2xhc3Ncblx0XHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoL3hsaW5rKEh8OmgpLywgJ2gnKS5yZXBsYWNlKC9zTmFtZSQvLCAncycpO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRuYW1lICE9PSAnaHJlZicgJiZcblx0XHRcdG5hbWUgIT09ICdsaXN0JyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2Zvcm0nICYmXG5cdFx0XHQvLyBEZWZhdWx0IHZhbHVlIGluIGJyb3dzZXJzIGlzIGAtMWAgYW5kIGFuIGVtcHR5IHN0cmluZyBpc1xuXHRcdFx0Ly8gY2FzdCB0byBgMGAgaW5zdGVhZFxuXHRcdFx0bmFtZSAhPT0gJ3RhYkluZGV4JyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2Rvd25sb2FkJyAmJlxuXHRcdFx0bmFtZSBpbiBkb21cblx0XHQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRvbVtuYW1lXSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuXHRcdFx0XHQvLyBsYWJlbGxlZCBicmVhayBpcyAxYiBzbWFsbGVyIGhlcmUgdGhhbiBhIHJldHVybiBzdGF0ZW1lbnQgKHNvcnJ5KVxuXHRcdFx0XHRicmVhayBvO1xuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cblx0XHQvLyBBUklBLWF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBub3Rpb24gb2YgYm9vbGVhbiB2YWx1ZXMuXG5cdFx0Ly8gVGhlIHZhbHVlIGBmYWxzZWAgaXMgZGlmZmVyZW50IGZyb20gdGhlIGF0dHJpYnV0ZSBub3Rcblx0XHQvLyBleGlzdGluZyBvbiB0aGUgRE9NLCBzbyB3ZSBjYW4ndCByZW1vdmUgaXQuIEZvciBub24tYm9vbGVhblxuXHRcdC8vIEFSSUEtYXR0cmlidXRlcyB3ZSBjb3VsZCB0cmVhdCBmYWxzZSBhcyBhIHJlbW92YWwsIGJ1dCB0aGVcblx0XHQvLyBhbW91bnQgb2YgZXhjZXB0aW9ucyB3b3VsZCBjb3N0IHVzIHRvbyBtYW55IGJ5dGVzLiBPbiB0b3Agb2Zcblx0XHQvLyB0aGF0IG90aGVyIFZET00gZnJhbWV3b3JrcyBhbHNvIGFsd2F5cyBzdHJpbmdpZnkgYGZhbHNlYC5cblxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdC8vIG5ldmVyIHNlcmlhbGl6ZSBmdW5jdGlvbnMgYXMgYXR0cmlidXRlIHZhbHVlc1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiAodmFsdWUgIT09IGZhbHNlIHx8IG5hbWUuaW5kZXhPZignLScpICE9IC0xKSkge1xuXHRcdFx0ZG9tLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUHJveHkgYW4gZXZlbnQgdG8gaG9va2VkIGV2ZW50IGhhbmRsZXJzXG4gKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBldmVudCBvYmplY3QgZnJvbSB0aGUgYnJvd3NlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRQcm94eShlKSB7XG5cdHRoaXMuX2xpc3RlbmVyc1tlLnR5cGUgKyBmYWxzZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRQcm94eUNhcHR1cmUoZSkge1xuXHR0aGlzLl9saXN0ZW5lcnNbZS50eXBlICsgdHJ1ZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cbiIsImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBkaWZmQ2hpbGRyZW4gfSBmcm9tICcuL2NoaWxkcmVuJztcbmltcG9ydCB7IGRpZmZQcm9wcywgc2V0UHJvcGVydHkgfSBmcm9tICcuL3Byb3BzJztcbmltcG9ydCB7IGFzc2lnbiwgcmVtb3ZlTm9kZSwgc2xpY2UgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgYW5kIGFwcGx5IHByb3BlciBjaGFuZ2VzIHRvIHRoZSBET01cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgcGFyZW50IG9mIHRoZSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0LiBNb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBlbGVtZW50IGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNIeWRyYXRpbmddIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmYoXG5cdHBhcmVudERvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IHRtcCxcblx0XHRuZXdUeXBlID0gbmV3Vk5vZGUudHlwZTtcblxuXHQvLyBXaGVuIHBhc3NpbmcgdGhyb3VnaCBjcmVhdGVFbGVtZW50IGl0IGFzc2lnbnMgdGhlIG9iamVjdFxuXHQvLyBjb25zdHJ1Y3RvciBhcyB1bmRlZmluZWQuIFRoaXMgdG8gcHJldmVudCBKU09OLWluamVjdGlvbi5cblx0aWYgKG5ld1ZOb2RlLmNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG5cdC8vIElmIHRoZSBwcmV2aW91cyBkaWZmIGJhaWxlZCBvdXQsIHJlc3VtZSBjcmVhdGluZy9oeWRyYXRpbmcuXG5cdGlmIChvbGRWTm9kZS5faHlkcmF0aW5nICE9IG51bGwpIHtcblx0XHRpc0h5ZHJhdGluZyA9IG9sZFZOb2RlLl9oeWRyYXRpbmc7XG5cdFx0b2xkRG9tID0gbmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0Ly8gaWYgd2UgcmVzdW1lLCB3ZSB3YW50IHRoZSB0cmVlIHRvIGJlIFwidW5sb2NrZWRcIlxuXHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSBudWxsO1xuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gW29sZERvbV07XG5cdH1cblxuXHRpZiAoKHRtcCA9IG9wdGlvbnMuX2RpZmYpKSB0bXAobmV3Vk5vZGUpO1xuXG5cdHRyeSB7XG5cdFx0b3V0ZXI6IGlmICh0eXBlb2YgbmV3VHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRsZXQgYywgaXNOZXcsIG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QsIGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbjtcblx0XHRcdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXG5cdFx0XHQvLyBOZWNlc3NhcnkgZm9yIGNyZWF0ZUNvbnRleHQgYXBpLiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgd2lsbCBwYXNzXG5cdFx0XHQvLyB0aGUgY29udGV4dCB2YWx1ZSBhcyBgdGhpcy5jb250ZXh0YCBqdXN0IGZvciB0aGlzIGNvbXBvbmVudC5cblx0XHRcdHRtcCA9IG5ld1R5cGUuY29udGV4dFR5cGU7XG5cdFx0XHRsZXQgcHJvdmlkZXIgPSB0bXAgJiYgZ2xvYmFsQ29udGV4dFt0bXAuX2lkXTtcblx0XHRcdGxldCBjb21wb25lbnRDb250ZXh0ID0gdG1wXG5cdFx0XHRcdD8gcHJvdmlkZXJcblx0XHRcdFx0XHQ/IHByb3ZpZGVyLnByb3BzLnZhbHVlXG5cdFx0XHRcdFx0OiB0bXAuX2RlZmF1bHRWYWx1ZVxuXHRcdFx0XHQ6IGdsb2JhbENvbnRleHQ7XG5cblx0XHRcdC8vIEdldCBjb21wb25lbnQgYW5kIHNldCBpdCB0byBgY2Bcblx0XHRcdGlmIChvbGRWTm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRcdGMgPSBuZXdWTm9kZS5fY29tcG9uZW50ID0gb2xkVk5vZGUuX2NvbXBvbmVudDtcblx0XHRcdFx0Y2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3BlbmRpbmdFcnJvcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEluc3RhbnRpYXRlIHRoZSBuZXcgY29tcG9uZW50XG5cdFx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVGhlIGNoZWNrIGFib3ZlIHZlcmlmaWVzIHRoYXQgbmV3VHlwZSBpcyBzdXBwb3NlIHRvIGJlIGNvbnN0cnVjdGVkXG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgbmV3VHlwZShuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVHJ1c3QgbWUsIENvbXBvbmVudCBpbXBsZW1lbnRzIHRoZSBpbnRlcmZhY2Ugd2Ugd2FudFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IENvbXBvbmVudChuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdFx0Yy5jb25zdHJ1Y3RvciA9IG5ld1R5cGU7XG5cdFx0XHRcdFx0Yy5yZW5kZXIgPSBkb1JlbmRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvdmlkZXIpIHByb3ZpZGVyLnN1YihjKTtcblxuXHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdGlmICghYy5zdGF0ZSkgYy5zdGF0ZSA9IHt9O1xuXHRcdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0XHRjLl9nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcblx0XHRcdFx0aXNOZXcgPSBjLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnZva2UgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG5cdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IG51bGwpIHtcblx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYy5zdGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKGMuX25leHRTdGF0ZSA9PSBjLnN0YXRlKSB7XG5cdFx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYXNzaWduKHt9LCBjLl9uZXh0U3RhdGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXNzaWduKFxuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSxcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXdQcm9wcywgYy5fbmV4dFN0YXRlKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRvbGRQcm9wcyA9IGMucHJvcHM7XG5cdFx0XHRvbGRTdGF0ZSA9IGMuc3RhdGU7XG5cblx0XHRcdC8vIEludm9rZSBwcmUtcmVuZGVyIGxpZmVjeWNsZSBtZXRob2RzXG5cdFx0XHRpZiAoaXNOZXcpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09IG51bGwgJiZcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbE1vdW50KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnREaWRNb3VudCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5jb21wb25lbnREaWRNb3VudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0bmV3UHJvcHMgIT09IG9sZFByb3BzICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQoIWMuX2ZvcmNlICYmXG5cdFx0XHRcdFx0XHRjLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPSBudWxsICYmXG5cdFx0XHRcdFx0XHRjLnNob3VsZENvbXBvbmVudFVwZGF0ZShcblx0XHRcdFx0XHRcdFx0bmV3UHJvcHMsXG5cdFx0XHRcdFx0XHRcdGMuX25leHRTdGF0ZSxcblx0XHRcdFx0XHRcdFx0Y29tcG9uZW50Q29udGV4dFxuXHRcdFx0XHRcdFx0KSA9PT0gZmFsc2UpIHx8XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX29yaWdpbmFsID09PSBvbGRWTm9kZS5fb3JpZ2luYWxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdFx0Ly8gTW9yZSBpbmZvIGFib3V0IHRoaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vSm92aURlQ3Jvb2NrL2JlYzVmMmNlOTM1NDRkMmU2MDcwZWY4ZTAwMzZlNGU4XG5cdFx0XHRcdFx0aWYgKG5ld1ZOb2RlLl9vcmlnaW5hbCAhPT0gb2xkVk5vZGUuX29yaWdpbmFsKSBjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdGMuX3Zub2RlID0gbmV3Vk5vZGU7XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbi5mb3JFYWNoKHZub2RlID0+IHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZSkgdm5vZGUuX3BhcmVudCA9IG5ld1ZOb2RlO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjLl9zdGF0ZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5fc3RhdGVDYWxsYmFja3NbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXG5cdFx0XHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnRXaWxsVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIGMuX25leHRTdGF0ZSwgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnREaWRVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKCgpID0+IHtcblx0XHRcdFx0XHRcdGMuY29tcG9uZW50RGlkVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGMuY29udGV4dCA9IGNvbXBvbmVudENvbnRleHQ7XG5cdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRjLl92bm9kZSA9IG5ld1ZOb2RlO1xuXHRcdFx0Yy5fcGFyZW50RG9tID0gcGFyZW50RG9tO1xuXG5cdFx0XHRsZXQgcmVuZGVySG9vayA9IG9wdGlvbnMuX3JlbmRlcixcblx0XHRcdFx0Y291bnQgPSAwO1xuXHRcdFx0aWYgKCdwcm90b3R5cGUnIGluIG5ld1R5cGUgJiYgbmV3VHlwZS5wcm90b3R5cGUucmVuZGVyKSB7XG5cdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdGMuX2RpcnR5ID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKHJlbmRlckhvb2spIHJlbmRlckhvb2sobmV3Vk5vZGUpO1xuXG5cdFx0XHRcdHRtcCA9IGMucmVuZGVyKGMucHJvcHMsIGMuc3RhdGUsIGMuY29udGV4dCk7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjLl9zdGF0ZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuX3N0YXRlQ2FsbGJhY2tzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKHJlbmRlckhvb2spIHJlbmRlckhvb2sobmV3Vk5vZGUpO1xuXG5cdFx0XHRcdFx0dG1wID0gYy5yZW5kZXIoYy5wcm9wcywgYy5zdGF0ZSwgYy5jb250ZXh0KTtcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBzZXRTdGF0ZSBjYWxsZWQgaW4gcmVuZGVyLCBzZWUgIzI1NTNcblx0XHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHR9IHdoaWxlIChjLl9kaXJ0eSAmJiArK2NvdW50IDwgMjUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgc2V0U3RhdGUgY2FsbGVkIGluIHJlbmRlciwgc2VlICMyNTUzXG5cdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXG5cdFx0XHRpZiAoYy5nZXRDaGlsZENvbnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRnbG9iYWxDb250ZXh0ID0gYXNzaWduKGFzc2lnbih7fSwgZ2xvYmFsQ29udGV4dCksIGMuZ2V0Q2hpbGRDb250ZXh0KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWlzTmV3ICYmIGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRzbmFwc2hvdCA9IGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlKTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGlzVG9wTGV2ZWxGcmFnbWVudCA9XG5cdFx0XHRcdHRtcCAhPSBudWxsICYmIHRtcC50eXBlID09PSBGcmFnbWVudCAmJiB0bXAua2V5ID09IG51bGw7XG5cdFx0XHRsZXQgcmVuZGVyUmVzdWx0ID0gaXNUb3BMZXZlbEZyYWdtZW50ID8gdG1wLnByb3BzLmNoaWxkcmVuIDogdG1wO1xuXG5cdFx0XHRkaWZmQ2hpbGRyZW4oXG5cdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0QXJyYXkuaXNBcnJheShyZW5kZXJSZXN1bHQpID8gcmVuZGVyUmVzdWx0IDogW3JlbmRlclJlc3VsdF0sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Yy5iYXNlID0gbmV3Vk5vZGUuX2RvbTtcblxuXHRcdFx0Ly8gV2Ugc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHRoaXMgVk5vZGUsIHVuc2V0IGFueSBzdG9yZWQgaHlkcmF0aW9uL2JhaWxvdXQgc3RhdGU6XG5cdFx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gbnVsbDtcblxuXHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbikge1xuXHRcdFx0XHRjLl9wZW5kaW5nRXJyb3IgPSBjLl9wcm9jZXNzaW5nRXhjZXB0aW9uID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Yy5fZm9yY2UgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPT0gbnVsbCAmJlxuXHRcdFx0bmV3Vk5vZGUuX29yaWdpbmFsID09PSBvbGRWTm9kZS5fb3JpZ2luYWxcblx0XHQpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gZGlmZkVsZW1lbnROb2Rlcyhcblx0XHRcdFx0b2xkVk5vZGUuX2RvbSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoKHRtcCA9IG9wdGlvbnMuZGlmZmVkKSkgdG1wKG5ld1ZOb2RlKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9IG51bGw7XG5cdFx0Ly8gaWYgaHlkcmF0aW5nIG9yIGNyZWF0aW5nIGluaXRpYWwgdHJlZSwgYmFpbG91dCBwcmVzZXJ2ZXMgRE9NOlxuXHRcdGlmIChpc0h5ZHJhdGluZyB8fCBleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkRG9tO1xuXHRcdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9ICEhaXNIeWRyYXRpbmc7XG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbltleGNlc3NEb21DaGlsZHJlbi5pbmRleE9mKG9sZERvbSldID0gbnVsbDtcblx0XHRcdC8vIF4gY291bGQgcG9zc2libHkgYmUgc2ltcGxpZmllZCB0bzpcblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aCA9IDA7XG5cdFx0fVxuXHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgbmV3Vk5vZGUsIG9sZFZOb2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSByb290XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRSb290KGNvbW1pdFF1ZXVlLCByb290KSB7XG5cdGlmIChvcHRpb25zLl9jb21taXQpIG9wdGlvbnMuX2NvbW1pdChyb290LCBjb21taXRRdWV1ZSk7XG5cblx0Y29tbWl0UXVldWUuc29tZShjID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSBSZXVzZSB0aGUgY29tbWl0UXVldWUgdmFyaWFibGUgaGVyZSBzbyB0aGUgdHlwZSBjaGFuZ2VzXG5cdFx0XHRjb21taXRRdWV1ZSA9IGMuX3JlbmRlckNhbGxiYWNrcztcblx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0Y29tbWl0UXVldWUuc29tZShjYiA9PiB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgU2VlIGFib3ZlIHRzLWlnbm9yZSBvbiBjb21taXRRdWV1ZVxuXHRcdFx0XHRjYi5jYWxsKGMpO1xuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjLl92bm9kZSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBEaWZmIHR3byB2aXJ0dWFsIG5vZGVzIHJlcHJlc2VudGluZyBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gZWxlbWVudCByZXByZXNlbnRpbmdcbiAqIHRoZSB2aXJ0dWFsIG5vZGVzIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Kn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fVxuICovXG5mdW5jdGlvbiBkaWZmRWxlbWVudE5vZGVzKFxuXHRkb20sXG5cdG5ld1ZOb2RlLFxuXHRvbGRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgb2xkUHJvcHMgPSBvbGRWTm9kZS5wcm9wcztcblx0bGV0IG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHM7XG5cdGxldCBub2RlVHlwZSA9IG5ld1ZOb2RlLnR5cGU7XG5cdGxldCBpID0gMDtcblxuXHQvLyBUcmFja3MgZW50ZXJpbmcgYW5kIGV4aXRpbmcgU1ZHIG5hbWVzcGFjZSB3aGVuIGRlc2NlbmRpbmcgdGhyb3VnaCB0aGUgdHJlZS5cblx0aWYgKG5vZGVUeXBlID09PSAnc3ZnJykgaXNTdmcgPSB0cnVlO1xuXG5cdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0Zm9yICg7IGkgPCBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgY2hpbGQgPSBleGNlc3NEb21DaGlsZHJlbltpXTtcblxuXHRcdFx0Ly8gaWYgbmV3Vk5vZGUgbWF0Y2hlcyBhbiBlbGVtZW50IGluIGV4Y2Vzc0RvbUNoaWxkcmVuIG9yIHRoZSBgZG9tYFxuXHRcdFx0Ly8gYXJndW1lbnQgbWF0Y2hlcyBhbiBlbGVtZW50IGluIGV4Y2Vzc0RvbUNoaWxkcmVuLCByZW1vdmUgaXQgZnJvbVxuXHRcdFx0Ly8gZXhjZXNzRG9tQ2hpbGRyZW4gc28gaXQgaXNuJ3QgbGF0ZXIgcmVtb3ZlZCBpbiBkaWZmQ2hpbGRyZW5cblx0XHRcdGlmIChcblx0XHRcdFx0Y2hpbGQgJiZcblx0XHRcdFx0J3NldEF0dHJpYnV0ZScgaW4gY2hpbGQgPT09ICEhbm9kZVR5cGUgJiZcblx0XHRcdFx0KG5vZGVUeXBlID8gY2hpbGQubG9jYWxOYW1lID09PSBub2RlVHlwZSA6IGNoaWxkLm5vZGVUeXBlID09PSAzKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGRvbSA9IGNoaWxkO1xuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbltpXSA9IG51bGw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChkb20gPT0gbnVsbCkge1xuXHRcdGlmIChub2RlVHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSBjcmVhdGVUZXh0Tm9kZSByZXR1cm5zIFRleHQsIHdlIGV4cGVjdCBQcmVhY3RFbGVtZW50XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmV3UHJvcHMpO1xuXHRcdH1cblxuXHRcdGlmIChpc1N2Zykge1xuXHRcdFx0ZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFxuXHRcdFx0XHQnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFdlIGtub3cgYG5ld1ZOb2RlLnR5cGVgIGlzIGEgc3RyaW5nXG5cdFx0XHRcdG5vZGVUeXBlXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFdlIGtub3cgYG5ld1ZOb2RlLnR5cGVgIGlzIGEgc3RyaW5nXG5cdFx0XHRcdG5vZGVUeXBlLFxuXHRcdFx0XHRuZXdQcm9wcy5pcyAmJiBuZXdQcm9wc1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyB3ZSBjcmVhdGVkIGEgbmV3IHBhcmVudCwgc28gbm9uZSBvZiB0aGUgcHJldmlvdXNseSBhdHRhY2hlZCBjaGlsZHJlbiBjYW4gYmUgcmV1c2VkOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gbnVsbDtcblx0XHQvLyB3ZSBhcmUgY3JlYXRpbmcgYSBuZXcgbm9kZSwgc28gd2UgY2FuIGFzc3VtZSB0aGlzIGlzIGEgbmV3IHN1YnRyZWUgKGluIGNhc2Ugd2UgYXJlIGh5ZHJhdGluZyksIHRoaXMgZGVvcHRzIHRoZSBoeWRyYXRlXG5cdFx0aXNIeWRyYXRpbmcgPSBmYWxzZTtcblx0fVxuXG5cdGlmIChub2RlVHlwZSA9PT0gbnVsbCkge1xuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHdlIHN0aWxsIGhhdmUgdG8gc3BsaXQgbWVyZ2VkIHRleHQgZnJvbSBTU1InZCBIVE1MLlxuXHRcdGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgKCFpc0h5ZHJhdGluZyB8fCBkb20uZGF0YSAhPT0gbmV3UHJvcHMpKSB7XG5cdFx0XHRkb20uZGF0YSA9IG5ld1Byb3BzO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBJZiBleGNlc3NEb21DaGlsZHJlbiB3YXMgbm90IG51bGwsIHJlcG9wdWxhdGUgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50J3MgY2hpbGRyZW46XG5cdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPSBleGNlc3NEb21DaGlsZHJlbiAmJiBzbGljZS5jYWxsKGRvbS5jaGlsZE5vZGVzKTtcblxuXHRcdG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuXG5cdFx0bGV0IG9sZEh0bWwgPSBvbGRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblx0XHRsZXQgbmV3SHRtbCA9IG5ld1Byb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXG5cdFx0Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgcHJvcHMgYXJlIG5vdCBkaWZmZWQgYXQgYWxsIChpbmNsdWRpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpXG5cdFx0Ly8gQFRPRE8gd2Ugc2hvdWxkIHdhcm4gaW4gZGVidWcgbW9kZSB3aGVuIHByb3BzIGRvbid0IG1hdGNoIGhlcmUuXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0Ly8gQnV0LCBpZiB3ZSBhcmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgd2UgYXJlIHVzaW5nIGV4aXN0aW5nIERPTSAoZS5nLiByZXBsYWNlTm9kZSlcblx0XHRcdC8vIHdlIHNob3VsZCByZWFkIHRoZSBleGlzdGluZyBET00gYXR0cmlidXRlcyB0byBkaWZmIHRoZW1cblx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdG9sZFByb3BzID0ge307XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkb20uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG9sZFByb3BzW2RvbS5hdHRyaWJ1dGVzW2ldLm5hbWVdID0gZG9tLmF0dHJpYnV0ZXNbaV0udmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld0h0bWwgfHwgb2xkSHRtbCkge1xuXHRcdFx0XHQvLyBBdm9pZCByZS1hcHBseWluZyB0aGUgc2FtZSAnX19odG1sJyBpZiBpdCBkaWQgbm90IGNoYW5nZWQgYmV0d2VlbiByZS1yZW5kZXJcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCFuZXdIdG1sIHx8XG5cdFx0XHRcdFx0KCghb2xkSHRtbCB8fCBuZXdIdG1sLl9faHRtbCAhPSBvbGRIdG1sLl9faHRtbCkgJiZcblx0XHRcdFx0XHRcdG5ld0h0bWwuX19odG1sICE9PSBkb20uaW5uZXJIVE1MKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkb20uaW5uZXJIVE1MID0gKG5ld0h0bWwgJiYgbmV3SHRtbC5fX2h0bWwpIHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGlmZlByb3BzKGRvbSwgbmV3UHJvcHMsIG9sZFByb3BzLCBpc1N2ZywgaXNIeWRyYXRpbmcpO1xuXG5cdFx0Ly8gSWYgdGhlIG5ldyB2bm9kZSBkaWRuJ3QgaGF2ZSBkYW5nZXJvdXNseVNldElubmVySFRNTCwgZGlmZiBpdHMgY2hpbGRyZW5cblx0XHRpZiAobmV3SHRtbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdFx0fSBlbHNlIHtcblx0XHRcdGkgPSBuZXdWTm9kZS5wcm9wcy5jaGlsZHJlbjtcblx0XHRcdGRpZmZDaGlsZHJlbihcblx0XHRcdFx0ZG9tLFxuXHRcdFx0XHRBcnJheS5pc0FycmF5KGkpID8gaSA6IFtpXSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2ZyAmJiBub2RlVHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuXG5cdFx0XHRcdFx0PyBleGNlc3NEb21DaGlsZHJlblswXVxuXHRcdFx0XHRcdDogb2xkVk5vZGUuX2NoaWxkcmVuICYmIGdldERvbVNpYmxpbmcob2xkVk5vZGUsIDApLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIGFueSB2bm9kZS5cblx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAoaSA9IGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW5baV0gIT0gbnVsbCkgcmVtb3ZlTm9kZShleGNlc3NEb21DaGlsZHJlbltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAoYXMgYWJvdmUsIGRvbid0IGRpZmYgcHJvcHMgZHVyaW5nIGh5ZHJhdGlvbilcblx0XHRpZiAoIWlzSHlkcmF0aW5nKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCd2YWx1ZScgaW4gbmV3UHJvcHMgJiZcblx0XHRcdFx0KGkgPSBuZXdQcm9wcy52YWx1ZSkgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHQvLyAjMjc1NiBGb3IgdGhlIDxwcm9ncmVzcz4tZWxlbWVudCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyAwLFxuXHRcdFx0XHQvLyBkZXNwaXRlIHRoZSBhdHRyaWJ1dGUgbm90IGJlaW5nIHByZXNlbnQuIFdoZW4gdGhlIGF0dHJpYnV0ZVxuXHRcdFx0XHQvLyBpcyBtaXNzaW5nIHRoZSBwcm9ncmVzcyBiYXIgaXMgdHJlYXRlZCBhcyBpbmRldGVybWluYXRlLlxuXHRcdFx0XHQvLyBUbyBmaXggdGhhdCB3ZSdsbCBhbHdheXMgdXBkYXRlIGl0IHdoZW4gaXQgaXMgMCBmb3IgcHJvZ3Jlc3MgZWxlbWVudHNcblx0XHRcdFx0KGkgIT09IGRvbS52YWx1ZSB8fFxuXHRcdFx0XHRcdChub2RlVHlwZSA9PT0gJ3Byb2dyZXNzJyAmJiAhaSkgfHxcblx0XHRcdFx0XHQvLyBUaGlzIGlzIG9ubHkgZm9yIElFIDExIHRvIGZpeCA8c2VsZWN0PiB2YWx1ZSBub3QgYmVpbmcgdXBkYXRlZC5cblx0XHRcdFx0XHQvLyBUbyBhdm9pZCBhIHN0YWxlIHNlbGVjdCB2YWx1ZSB3ZSBuZWVkIHRvIHNldCB0aGUgb3B0aW9uLnZhbHVlXG5cdFx0XHRcdFx0Ly8gYWdhaW4sIHdoaWNoIHRyaWdnZXJzIElFMTEgdG8gcmUtZXZhbHVhdGUgdGhlIHNlbGVjdCB2YWx1ZVxuXHRcdFx0XHRcdChub2RlVHlwZSA9PT0gJ29wdGlvbicgJiYgaSAhPT0gb2xkUHJvcHMudmFsdWUpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldFByb3BlcnR5KGRvbSwgJ3ZhbHVlJywgaSwgb2xkUHJvcHMudmFsdWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmIChcblx0XHRcdFx0J2NoZWNrZWQnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMuY2hlY2tlZCkgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRpICE9PSBkb20uY2hlY2tlZFxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldFByb3BlcnR5KGRvbSwgJ2NoZWNrZWQnLCBpLCBvbGRQcm9wcy5jaGVja2VkLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRvbTtcbn1cblxuLyoqXG4gKiBJbnZva2Ugb3IgdXBkYXRlIGEgcmVmLCBkZXBlbmRpbmcgb24gd2hldGhlciBpdCBpcyBhIGZ1bmN0aW9uIG9yIG9iamVjdCByZWYuXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcmVmXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlSZWYocmVmLCB2YWx1ZSwgdm5vZGUpIHtcblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIHJlZiA9PSAnZnVuY3Rpb24nKSByZWYodmFsdWUpO1xuXHRcdGVsc2UgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgdm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVW5tb3VudCBhIHZpcnR1YWwgbm9kZSBmcm9tIHRoZSB0cmVlIGFuZCBhcHBseSBET00gY2hhbmdlc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gdW5tb3VudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHBhcmVudFZOb2RlIFRoZSBwYXJlbnQgb2YgdGhlIFZOb2RlIHRoYXRcbiAqIGluaXRpYXRlZCB0aGUgdW5tb3VudFxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcFJlbW92ZV0gRmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IGEgcGFyZW50IG5vZGUgb2YgdGhlXG4gKiBjdXJyZW50IGVsZW1lbnQgaXMgYWxyZWFkeSBkZXRhY2hlZCBmcm9tIHRoZSBET00uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bm1vdW50KHZub2RlLCBwYXJlbnRWTm9kZSwgc2tpcFJlbW92ZSkge1xuXHRsZXQgcjtcblx0aWYgKG9wdGlvbnMudW5tb3VudCkgb3B0aW9ucy51bm1vdW50KHZub2RlKTtcblxuXHRpZiAoKHIgPSB2bm9kZS5yZWYpKSB7XG5cdFx0aWYgKCFyLmN1cnJlbnQgfHwgci5jdXJyZW50ID09PSB2bm9kZS5fZG9tKSB7XG5cdFx0XHRhcHBseVJlZihyLCBudWxsLCBwYXJlbnRWTm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKChyID0gdm5vZGUuX2NvbXBvbmVudCkgIT0gbnVsbCkge1xuXHRcdGlmIChyLmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgcGFyZW50Vk5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHIuYmFzZSA9IHIuX3BhcmVudERvbSA9IG51bGw7XG5cdFx0dm5vZGUuX2NvbXBvbmVudCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICgociA9IHZub2RlLl9jaGlsZHJlbikpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChyW2ldKSB7XG5cdFx0XHRcdHVubW91bnQoXG5cdFx0XHRcdFx0cltpXSxcblx0XHRcdFx0XHRwYXJlbnRWTm9kZSxcblx0XHRcdFx0XHRza2lwUmVtb3ZlIHx8IHR5cGVvZiB2bm9kZS50eXBlICE9PSAnZnVuY3Rpb24nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFza2lwUmVtb3ZlICYmIHZub2RlLl9kb20gIT0gbnVsbCkge1xuXHRcdHJlbW92ZU5vZGUodm5vZGUuX2RvbSk7XG5cdH1cblxuXHQvLyBNdXN0IGJlIHNldCB0byBgdW5kZWZpbmVkYCB0byBwcm9wZXJseSBjbGVhbiB1cCBgX25leHREb21gXG5cdC8vIGZvciB3aGljaCBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZS4gU2VlIGNvbW1lbnQgaW4gYGNyZWF0ZS1lbGVtZW50LmpzYFxuXHR2bm9kZS5fcGFyZW50ID0gdm5vZGUuX2RvbSA9IHZub2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xufVxuXG4vKiogVGhlIGAucmVuZGVyKClgIG1ldGhvZCBmb3IgYSBQRkMgYmFja2luZyBpbnN0YW5jZS4gKi9cbmZ1bmN0aW9uIGRvUmVuZGVyKHByb3BzLCBzdGF0ZSwgY29udGV4dCkge1xuXHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCk7XG59XG4iLCJpbXBvcnQgeyBFTVBUWV9PQkogfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjb21taXRSb290LCBkaWZmIH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIFJlbmRlciBhIFByZWFjdCB2aXJ0dWFsIG5vZGUgaW50byBhIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHRvXG4gKiByZW5kZXIgaW50b1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50IHwgb2JqZWN0fSBbcmVwbGFjZU5vZGVdIE9wdGlvbmFsOiBBdHRlbXB0IHRvIHJlLXVzZSBhblxuICogZXhpc3RpbmcgRE9NIHRyZWUgcm9vdGVkIGF0IGByZXBsYWNlTm9kZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCByZXBsYWNlTm9kZSkge1xuXHRpZiAob3B0aW9ucy5fcm9vdCkgb3B0aW9ucy5fcm9vdCh2bm9kZSwgcGFyZW50RG9tKTtcblxuXHQvLyBXZSBhYnVzZSB0aGUgYHJlcGxhY2VOb2RlYCBwYXJhbWV0ZXIgaW4gYGh5ZHJhdGUoKWAgdG8gc2lnbmFsIGlmIHdlIGFyZSBpblxuXHQvLyBoeWRyYXRpb24gbW9kZSBvciBub3QgYnkgcGFzc2luZyB0aGUgYGh5ZHJhdGVgIGZ1bmN0aW9uIGluc3RlYWQgb2YgYSBET01cblx0Ly8gZWxlbWVudC4uXG5cdGxldCBpc0h5ZHJhdGluZyA9IHR5cGVvZiByZXBsYWNlTm9kZSA9PT0gJ2Z1bmN0aW9uJztcblxuXHQvLyBUbyBiZSBhYmxlIHRvIHN1cHBvcnQgY2FsbGluZyBgcmVuZGVyKClgIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lXG5cdC8vIERPTSBub2RlLCB3ZSBuZWVkIHRvIG9idGFpbiBhIHJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXMgdHJlZS4gV2UgZG9cblx0Ly8gdGhpcyBieSBhc3NpZ25pbmcgYSBuZXcgYF9jaGlsZHJlbmAgcHJvcGVydHkgdG8gRE9NIG5vZGVzIHdoaWNoIHBvaW50c1xuXHQvLyB0byB0aGUgbGFzdCByZW5kZXJlZCB0cmVlLiBCeSBkZWZhdWx0IHRoaXMgcHJvcGVydHkgaXMgbm90IHByZXNlbnQsIHdoaWNoXG5cdC8vIG1lYW5zIHRoYXQgd2UgYXJlIG1vdW50aW5nIGEgbmV3IHRyZWUgZm9yIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgb2xkVk5vZGUgPSBpc0h5ZHJhdGluZ1xuXHRcdD8gbnVsbFxuXHRcdDogKHJlcGxhY2VOb2RlICYmIHJlcGxhY2VOb2RlLl9jaGlsZHJlbikgfHwgcGFyZW50RG9tLl9jaGlsZHJlbjtcblxuXHR2bm9kZSA9IChcblx0XHQoIWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlKSB8fFxuXHRcdHBhcmVudERvbVxuXHQpLl9jaGlsZHJlbiA9IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFt2bm9kZV0pO1xuXG5cdC8vIExpc3Qgb2YgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyIGRpZmZpbmcuXG5cdGxldCBjb21taXRRdWV1ZSA9IFtdO1xuXHRkaWZmKFxuXHRcdHBhcmVudERvbSxcblx0XHQvLyBEZXRlcm1pbmUgdGhlIG5ldyB2bm9kZSB0cmVlIGFuZCBzdG9yZSBpdCBvbiB0aGUgRE9NIGVsZW1lbnQgb25cblx0XHQvLyBvdXIgY3VzdG9tIGBfY2hpbGRyZW5gIHByb3BlcnR5LlxuXHRcdHZub2RlLFxuXHRcdG9sZFZOb2RlIHx8IEVNUFRZX09CSixcblx0XHRFTVBUWV9PQkosXG5cdFx0cGFyZW50RG9tLm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuXHRcdCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZVxuXHRcdFx0PyBbcmVwbGFjZU5vZGVdXG5cdFx0XHQ6IG9sZFZOb2RlXG5cdFx0XHQ/IG51bGxcblx0XHRcdDogcGFyZW50RG9tLmZpcnN0Q2hpbGRcblx0XHRcdD8gc2xpY2UuY2FsbChwYXJlbnREb20uY2hpbGROb2Rlcylcblx0XHRcdDogbnVsbCxcblx0XHRjb21taXRRdWV1ZSxcblx0XHQhaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGVcblx0XHRcdD8gcmVwbGFjZU5vZGVcblx0XHRcdDogb2xkVk5vZGVcblx0XHRcdD8gb2xkVk5vZGUuX2RvbVxuXHRcdFx0OiBwYXJlbnREb20uZmlyc3RDaGlsZCxcblx0XHRpc0h5ZHJhdGluZ1xuXHQpO1xuXG5cdC8vIEZsdXNoIGFsbCBxdWV1ZWQgZWZmZWN0c1xuXHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGFuIGV4aXN0aW5nIERPTSBlbGVtZW50IHdpdGggZGF0YSBmcm9tIGEgUHJlYWN0IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogdXBkYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKHZub2RlLCBwYXJlbnREb20pIHtcblx0cmVuZGVyKHZub2RlLCBwYXJlbnREb20sIGh5ZHJhdGUpO1xufVxuIiwiLyoqXG4gKiBGaW5kIHRoZSBjbG9zZXN0IGVycm9yIGJvdW5kYXJ5IHRvIGEgdGhyb3duIGVycm9yIGFuZCBjYWxsIGl0XG4gKiBAcGFyYW0ge29iamVjdH0gZXJyb3IgVGhlIHRocm93biB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2bm9kZSB0aGF0IHRocmV3XG4gKiB0aGUgZXJyb3IgdGhhdCB3YXMgY2F1Z2h0IChleGNlcHQgZm9yIHVubW91bnRpbmcgd2hlbiB0aGlzIHBhcmFtZXRlclxuICogaXMgdGhlIGhpZ2hlc3QgcGFyZW50IHRoYXQgd2FzIGJlaW5nIHVubW91bnRlZClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBbb2xkVk5vZGVdXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5FcnJvckluZm99IFtlcnJvckluZm9dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2F0Y2hFcnJvcihlcnJvciwgdm5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRsZXQgY29tcG9uZW50LCBjdG9yLCBoYW5kbGVkO1xuXG5cdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0aWYgKChjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50KSAmJiAhY29tcG9uZW50Ll9wcm9jZXNzaW5nRXhjZXB0aW9uKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjdG9yID0gY29tcG9uZW50LmNvbnN0cnVjdG9yO1xuXG5cdFx0XHRcdGlmIChjdG9yICYmIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9IG51bGwpIHtcblx0XHRcdFx0XHRjb21wb25lbnQuc2V0U3RhdGUoY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpKTtcblx0XHRcdFx0XHRoYW5kbGVkID0gY29tcG9uZW50Ll9kaXJ0eTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2ggIT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvIHx8IHt9KTtcblx0XHRcdFx0XHRoYW5kbGVkID0gY29tcG9uZW50Ll9kaXJ0eTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRoaXMgaXMgYW4gZXJyb3IgYm91bmRhcnkuIE1hcmsgaXQgYXMgaGF2aW5nIGJhaWxlZCBvdXQsIGFuZCB3aGV0aGVyIGl0IHdhcyBtaWQtaHlkcmF0aW9uLlxuXHRcdFx0XHRpZiAoaGFuZGxlZCkge1xuXHRcdFx0XHRcdHJldHVybiAoY29tcG9uZW50Ll9wZW5kaW5nRXJyb3IgPSBjb21wb25lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGVycm9yID0gZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR0aHJvdyBlcnJvcjtcbn1cbiIsImltcG9ydCB7IG9wdGlvbnMsIEZyYWdtZW50IH0gZnJvbSAncHJlYWN0JztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ3ByZWFjdCcpLlZOb2RlfSBWTm9kZSAqL1xuXG5sZXQgdm5vZGVJZCA9IDA7XG5cbi8qKlxuICogQGZpbGVvdmVydmlld1xuICogVGhpcyBmaWxlIGV4cG9ydHMgdmFyaW91cyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IEJhYmVsJ3MgXCJhdXRvbWF0aWNcIiBKU1ggcnVudGltZSBBUEk6XG4gKiAtIGpzeCh0eXBlLCBwcm9wcywga2V5KVxuICogLSBqc3hzKHR5cGUsIHByb3BzLCBrZXkpXG4gKiAtIGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBfX3NvdXJjZSwgX19zZWxmKVxuICpcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBjcmVhdGVWTm9kZSBoZXJlIGlzIG9wdGltaXplZCBmb3IgcGVyZm9ybWFuY2UuXG4gKiBCZW5jaG1hcmtzOiBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzVmNmI1NGEwYjQ2MzIxMDBhN2RjZDJiM1xuICovXG5cbi8qKlxuICogSlNYLkVsZW1lbnQgZmFjdG9yeSB1c2VkIGJ5IEJhYmVsJ3Mge3J1bnRpbWU6XCJhdXRvbWF0aWNcIn0gSlNYIHRyYW5zZm9ybVxuICogQHBhcmFtIHtWTm9kZVsndHlwZSddfSB0eXBlXG4gKiBAcGFyYW0ge1ZOb2RlWydwcm9wcyddfSBwcm9wc1xuICogQHBhcmFtIHtWTm9kZVsna2V5J119IFtrZXldXG4gKiBAcGFyYW0ge3N0cmluZ30gW19fc2VsZl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbX19zb3VyY2VdXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzLCBrZXksIF9fc2VsZiwgX19zb3VyY2UpIHtcblx0Ly8gV2UnbGwgd2FudCB0byBwcmVzZXJ2ZSBgcmVmYCBpbiBwcm9wcyB0byBnZXQgcmlkIG9mIHRoZSBuZWVkIGZvclxuXHQvLyBmb3J3YXJkUmVmIGNvbXBvbmVudHMgaW4gdGhlIGZ1dHVyZSwgYnV0IHRoYXQgc2hvdWxkIGhhcHBlbiB2aWFcblx0Ly8gYSBzZXBhcmF0ZSBQUi5cblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHt9LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAncmVmJykge1xuXHRcdFx0cmVmID0gcHJvcHNbaV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHByb3BzW2ldO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IHZub2RlID0ge1xuXHRcdHR5cGUsXG5cdFx0cHJvcHM6IG5vcm1hbGl6ZWRQcm9wcyxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdF9jaGlsZHJlbjogbnVsbCxcblx0XHRfcGFyZW50OiBudWxsLFxuXHRcdF9kZXB0aDogMCxcblx0XHRfZG9tOiBudWxsLFxuXHRcdF9uZXh0RG9tOiB1bmRlZmluZWQsXG5cdFx0X2NvbXBvbmVudDogbnVsbCxcblx0XHRfaHlkcmF0aW5nOiBudWxsLFxuXHRcdGNvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG5cdFx0X29yaWdpbmFsOiAtLXZub2RlSWQsXG5cdFx0X19zb3VyY2UsXG5cdFx0X19zZWxmXG5cdH07XG5cblx0Ly8gSWYgYSBDb21wb25lbnQgVk5vZGUsIGNoZWNrIGZvciBhbmQgYXBwbHkgZGVmYXVsdFByb3BzLlxuXHQvLyBOb3RlOiBgdHlwZWAgaXMgb2Z0ZW4gYSBTdHJpbmcsIGFuZCBjYW4gYmUgYHVuZGVmaW5lZGAgaW4gZGV2ZWxvcG1lbnQuXG5cdGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAocmVmID0gdHlwZS5kZWZhdWx0UHJvcHMpKSB7XG5cdFx0Zm9yIChpIGluIHJlZilcblx0XHRcdGlmICh0eXBlb2Ygbm9ybWFsaXplZFByb3BzW2ldID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSByZWZbaV07XG5cdFx0XHR9XG5cdH1cblxuXHRpZiAob3B0aW9ucy52bm9kZSkgb3B0aW9ucy52bm9kZSh2bm9kZSk7XG5cdHJldHVybiB2bm9kZTtcbn1cblxuZXhwb3J0IHtcblx0Y3JlYXRlVk5vZGUgYXMganN4LFxuXHRjcmVhdGVWTm9kZSBhcyBqc3hzLFxuXHRjcmVhdGVWTm9kZSBhcyBqc3hERVYsXG5cdEZyYWdtZW50XG59O1xuIiwiaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xubGV0IGN1cnJlbnRJbmRleDtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5sZXQgY3VycmVudENvbXBvbmVudDtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5sZXQgcHJldmlvdXNDb21wb25lbnQ7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xubGV0IGN1cnJlbnRIb29rID0gMDtcblxuLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSAqL1xubGV0IGFmdGVyUGFpbnRFZmZlY3RzID0gW107XG5cbmxldCBFTVBUWSA9IFtdO1xuXG5sZXQgb2xkQmVmb3JlRGlmZiA9IG9wdGlvbnMuX2RpZmY7XG5sZXQgb2xkQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5fcmVuZGVyO1xubGV0IG9sZEFmdGVyRGlmZiA9IG9wdGlvbnMuZGlmZmVkO1xubGV0IG9sZENvbW1pdCA9IG9wdGlvbnMuX2NvbW1pdDtcbmxldCBvbGRCZWZvcmVVbm1vdW50ID0gb3B0aW9ucy51bm1vdW50O1xuXG5jb25zdCBSQUZfVElNRU9VVCA9IDEwMDtcbmxldCBwcmV2UmFmO1xuXG5vcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRjdXJyZW50Q29tcG9uZW50ID0gbnVsbDtcblx0aWYgKG9sZEJlZm9yZURpZmYpIG9sZEJlZm9yZURpZmYodm5vZGUpO1xufTtcblxub3B0aW9ucy5fcmVuZGVyID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQmVmb3JlUmVuZGVyKSBvbGRCZWZvcmVSZW5kZXIodm5vZGUpO1xuXG5cdGN1cnJlbnRDb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRjdXJyZW50SW5kZXggPSAwO1xuXG5cdGNvbnN0IGhvb2tzID0gY3VycmVudENvbXBvbmVudC5fX2hvb2tzO1xuXHRpZiAoaG9va3MpIHtcblx0XHRpZiAocHJldmlvdXNDb21wb25lbnQgPT09IGN1cnJlbnRDb21wb25lbnQpIHtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdFx0Y3VycmVudENvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzID0gW107XG5cdFx0XHRob29rcy5fbGlzdC5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdFx0aWYgKGhvb2tJdGVtLl9uZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRob29rSXRlbS5fdmFsdWUgPSBob29rSXRlbS5fbmV4dFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgPSBFTVBUWTtcblx0XHRcdFx0aG9va0l0ZW0uX25leHRWYWx1ZSA9IGhvb2tJdGVtLl9wZW5kaW5nQXJncyA9IHVuZGVmaW5lZDtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUVmZmVjdCk7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHR9XG5cdH1cblx0cHJldmlvdXNDb21wb25lbnQgPSBjdXJyZW50Q29tcG9uZW50O1xufTtcblxub3B0aW9ucy5kaWZmZWQgPSB2bm9kZSA9PiB7XG5cdGlmIChvbGRBZnRlckRpZmYpIG9sZEFmdGVyRGlmZih2bm9kZSk7XG5cblx0Y29uc3QgYyA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjICYmIGMuX19ob29rcykge1xuXHRcdGlmIChjLl9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmxlbmd0aCkgYWZ0ZXJQYWludChhZnRlclBhaW50RWZmZWN0cy5wdXNoKGMpKTtcblx0XHRjLl9faG9va3MuX2xpc3QuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRpZiAoaG9va0l0ZW0uX3BlbmRpbmdBcmdzKSB7XG5cdFx0XHRcdGhvb2tJdGVtLl9hcmdzID0gaG9va0l0ZW0uX3BlbmRpbmdBcmdzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgIT09IEVNUFRZKSB7XG5cdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9wZW5kaW5nVmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRob29rSXRlbS5fcGVuZGluZ0FyZ3MgPSB1bmRlZmluZWQ7XG5cdFx0XHRob29rSXRlbS5fcGVuZGluZ1ZhbHVlID0gRU1QVFk7XG5cdFx0fSk7XG5cdH1cblx0cHJldmlvdXNDb21wb25lbnQgPSBjdXJyZW50Q29tcG9uZW50ID0gbnVsbDtcbn07XG5cbm9wdGlvbnMuX2NvbW1pdCA9ICh2bm9kZSwgY29tbWl0UXVldWUpID0+IHtcblx0Y29tbWl0UXVldWUuc29tZShjb21wb25lbnQgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0Y29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MgPSBjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcy5maWx0ZXIoY2IgPT5cblx0XHRcdFx0Y2IuX3ZhbHVlID8gaW52b2tlRWZmZWN0KGNiKSA6IHRydWVcblx0XHRcdCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Y29tbWl0UXVldWUuc29tZShjID0+IHtcblx0XHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcykgYy5fcmVuZGVyQ2FsbGJhY2tzID0gW107XG5cdFx0XHR9KTtcblx0XHRcdGNvbW1pdFF1ZXVlID0gW107XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGNvbXBvbmVudC5fdm5vZGUpO1xuXHRcdH1cblx0fSk7XG5cblx0aWYgKG9sZENvbW1pdCkgb2xkQ29tbWl0KHZub2RlLCBjb21taXRRdWV1ZSk7XG59O1xuXG5vcHRpb25zLnVubW91bnQgPSB2bm9kZSA9PiB7XG5cdGlmIChvbGRCZWZvcmVVbm1vdW50KSBvbGRCZWZvcmVVbm1vdW50KHZub2RlKTtcblxuXHRjb25zdCBjID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGMgJiYgYy5fX2hvb2tzKSB7XG5cdFx0bGV0IGhhc0Vycm9yZWQ7XG5cdFx0Yy5fX2hvb2tzLl9saXN0LmZvckVhY2gocyA9PiB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpbnZva2VDbGVhbnVwKHMpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRoYXNFcnJvcmVkID0gZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRjLl9faG9va3MgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKGhhc0Vycm9yZWQpIG9wdGlvbnMuX2NhdGNoRXJyb3IoaGFzRXJyb3JlZCwgYy5fdm5vZGUpO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldCBhIGhvb2sncyBzdGF0ZSBmcm9tIHRoZSBjdXJyZW50Q29tcG9uZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBob29rIHRvIGdldFxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGhlIGluZGV4IG9mIHRoZSBob29rIHRvIGdldFxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZ2V0SG9va1N0YXRlKGluZGV4LCB0eXBlKSB7XG5cdGlmIChvcHRpb25zLl9ob29rKSB7XG5cdFx0b3B0aW9ucy5faG9vayhjdXJyZW50Q29tcG9uZW50LCBpbmRleCwgY3VycmVudEhvb2sgfHwgdHlwZSk7XG5cdH1cblx0Y3VycmVudEhvb2sgPSAwO1xuXG5cdC8vIExhcmdlbHkgaW5zcGlyZWQgYnk6XG5cdC8vICogaHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWwta2xlaW4vZnVuY3kuanMvYmxvYi9mNmJlNzM0NjhlNmVjNDZiMGZmNWFhM2NjNGM5YmFmNzJhMjkwMjVhL3NyYy9ob29rcy9jb3JlX2hvb2tzLm1qc1xuXHQvLyAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWVsLWtsZWluL2Z1bmN5LmpzL2Jsb2IvNjUwYmVhYTU4YzQzYzMzYTc0ODIwYTNjOThiM2M3MDc5Y2YyZTMzMy9zcmMvcmVuZGVyZXIubWpzXG5cdC8vIE90aGVyIGltcGxlbWVudGF0aW9ucyB0byBsb29rIGF0OlxuXHQvLyAqIGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9tbm94MDVxcDhcblx0Y29uc3QgaG9va3MgPVxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcyB8fFxuXHRcdChjdXJyZW50Q29tcG9uZW50Ll9faG9va3MgPSB7XG5cdFx0XHRfbGlzdDogW10sXG5cdFx0XHRfcGVuZGluZ0VmZmVjdHM6IFtdXG5cdFx0fSk7XG5cblx0aWYgKGluZGV4ID49IGhvb2tzLl9saXN0Lmxlbmd0aCkge1xuXHRcdGhvb2tzLl9saXN0LnB1c2goeyBfcGVuZGluZ1ZhbHVlOiBFTVBUWSB9KTtcblx0fVxuXHRyZXR1cm4gaG9va3MuX2xpc3RbaW5kZXhdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuU3RhdGVVcGRhdGVyPGFueT59IFtpbml0aWFsU3RhdGVdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcblx0Y3VycmVudEhvb2sgPSAxO1xuXHRyZXR1cm4gdXNlUmVkdWNlcihpbnZva2VPclJldHVybiwgaW5pdGlhbFN0YXRlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlJlZHVjZXI8YW55LCBhbnk+fSByZWR1Y2VyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlN0YXRlVXBkYXRlcjxhbnk+fSBpbml0aWFsU3RhdGVcbiAqIEBwYXJhbSB7KGluaXRpYWxTdGF0ZTogYW55KSA9PiB2b2lkfSBbaW5pdF1cbiAqIEByZXR1cm5zIHtbIGFueSwgKHN0YXRlOiBhbnkpID0+IHZvaWQgXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBpbml0KSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuUmVkdWNlckhvb2tTdGF0ZX0gKi9cblx0Y29uc3QgaG9va1N0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAyKTtcblx0aG9va1N0YXRlLl9yZWR1Y2VyID0gcmVkdWNlcjtcblx0aWYgKCFob29rU3RhdGUuX2NvbXBvbmVudCkge1xuXHRcdGhvb2tTdGF0ZS5fdmFsdWUgPSBbXG5cdFx0XHQhaW5pdCA/IGludm9rZU9yUmV0dXJuKHVuZGVmaW5lZCwgaW5pdGlhbFN0YXRlKSA6IGluaXQoaW5pdGlhbFN0YXRlKSxcblxuXHRcdFx0YWN0aW9uID0+IHtcblx0XHRcdFx0Y29uc3QgY3VycmVudFZhbHVlID0gaG9va1N0YXRlLl9uZXh0VmFsdWVcblx0XHRcdFx0XHQ/IGhvb2tTdGF0ZS5fbmV4dFZhbHVlWzBdXG5cdFx0XHRcdFx0OiBob29rU3RhdGUuX3ZhbHVlWzBdO1xuXHRcdFx0XHRjb25zdCBuZXh0VmFsdWUgPSBob29rU3RhdGUuX3JlZHVjZXIoY3VycmVudFZhbHVlLCBhY3Rpb24pO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgIT09IG5leHRWYWx1ZSkge1xuXHRcdFx0XHRcdGhvb2tTdGF0ZS5fbmV4dFZhbHVlID0gW25leHRWYWx1ZSwgaG9va1N0YXRlLl92YWx1ZVsxXV07XG5cdFx0XHRcdFx0aG9va1N0YXRlLl9jb21wb25lbnQuc2V0U3RhdGUoe30pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XTtcblxuXHRcdGhvb2tTdGF0ZS5fY29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudDtcblxuXHRcdGlmICghY3VycmVudENvbXBvbmVudC5faGFzU2N1RnJvbUhvb2tzKSB7XG5cdFx0XHRjdXJyZW50Q29tcG9uZW50Ll9oYXNTY3VGcm9tSG9va3MgPSB0cnVlO1xuXHRcdFx0Y29uc3QgcHJldlNjdSA9IGN1cnJlbnRDb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlO1xuXG5cdFx0XHQvLyBUaGlzIFNDVSBoYXMgdGhlIHB1cnBvc2Ugb2YgYmFpbGluZyBvdXQgYWZ0ZXIgcmVwZWF0ZWQgdXBkYXRlc1xuXHRcdFx0Ly8gdG8gc3RhdGVmdWwgaG9va3MuXG5cdFx0XHQvLyB3ZSBzdG9yZSB0aGUgbmV4dCB2YWx1ZSBpbiBfbmV4dFZhbHVlWzBdIGFuZCBrZWVwIGRvaW5nIHRoYXQgZm9yIGFsbFxuXHRcdFx0Ly8gc3RhdGUgc2V0dGVycywgaWYgd2UgaGF2ZSBuZXh0IHN0YXRlcyBhbmRcblx0XHRcdC8vIGFsbCBuZXh0IHN0YXRlcyB3aXRoaW4gYSBjb21wb25lbnQgZW5kIHVwIGJlaW5nIGVxdWFsIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlXG5cdFx0XHQvLyB3ZSBhcmUgc2FmZSB0byBiYWlsIG91dCBmb3IgdGhpcyBzcGVjaWZpYyBjb21wb25lbnQuXG5cdFx0XHRjdXJyZW50Q29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uKHAsIHMsIGMpIHtcblx0XHRcdFx0aWYgKCFob29rU3RhdGUuX2NvbXBvbmVudC5fX2hvb2tzKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRjb25zdCBzdGF0ZUhvb2tzID0gaG9va1N0YXRlLl9jb21wb25lbnQuX19ob29rcy5fbGlzdC5maWx0ZXIoXG5cdFx0XHRcdFx0eCA9PiB4Ll9jb21wb25lbnRcblx0XHRcdFx0KTtcblx0XHRcdFx0Y29uc3QgYWxsSG9va3NFbXB0eSA9IHN0YXRlSG9va3MuZXZlcnkoeCA9PiAheC5fbmV4dFZhbHVlKTtcblx0XHRcdFx0Ly8gV2hlbiB3ZSBoYXZlIG5vIHVwZGF0ZWQgaG9va3MgaW4gdGhlIGNvbXBvbmVudCB3ZSBpbnZva2UgdGhlIHByZXZpb3VzIFNDVSBvclxuXHRcdFx0XHQvLyB0cmF2ZXJzZSB0aGUgVkRPTSB0cmVlIGZ1cnRoZXIuXG5cdFx0XHRcdGlmIChhbGxIb29rc0VtcHR5KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByZXZTY3UgPyBwcmV2U2N1LmNhbGwodGhpcywgcCwgcywgYykgOiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgY2hlY2sgd2hldGhlciB3ZSBoYXZlIGNvbXBvbmVudHMgd2l0aCBhIG5leHRWYWx1ZSBzZXQgdGhhdFxuXHRcdFx0XHQvLyBoYXZlIHZhbHVlcyB0aGF0IGFyZW4ndCBlcXVhbCB0byBvbmUgYW5vdGhlciB0aGlzIHB1c2hlc1xuXHRcdFx0XHQvLyB1cyB0byB1cGRhdGUgZnVydGhlciBkb3duIHRoZSB0cmVlXG5cdFx0XHRcdGxldCBzaG91bGRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdFx0c3RhdGVIb29rcy5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdFx0XHRpZiAoaG9va0l0ZW0uX25leHRWYWx1ZSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgY3VycmVudFZhbHVlID0gaG9va0l0ZW0uX3ZhbHVlWzBdO1xuXHRcdFx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX25leHRWYWx1ZTtcblx0XHRcdFx0XHRcdGhvb2tJdGVtLl9uZXh0VmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudFZhbHVlICE9PSBob29rSXRlbS5fdmFsdWVbMF0pIHNob3VsZFVwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gc2hvdWxkVXBkYXRlIHx8IGhvb2tTdGF0ZS5fY29tcG9uZW50LnByb3BzICE9PSBwXG5cdFx0XHRcdFx0PyBwcmV2U2N1XG5cdFx0XHRcdFx0XHQ/IHByZXZTY3UuY2FsbCh0aGlzLCBwLCBzLCBjKVxuXHRcdFx0XHRcdFx0OiB0cnVlXG5cdFx0XHRcdFx0OiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGhvb2tTdGF0ZS5fbmV4dFZhbHVlIHx8IGhvb2tTdGF0ZS5fdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3R9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFZmZlY3QoY2FsbGJhY2ssIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAzKTtcblx0aWYgKCFvcHRpb25zLl9za2lwRWZmZWN0cyAmJiBhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSBjYWxsYmFjaztcblx0XHRzdGF0ZS5fcGVuZGluZ0FyZ3MgPSBhcmdzO1xuXG5cdFx0Y3VycmVudENvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5wdXNoKHN0YXRlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0fSBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNhbGxiYWNrLCBhcmdzKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgNCk7XG5cdGlmICghb3B0aW9ucy5fc2tpcEVmZmVjdHMgJiYgYXJnc0NoYW5nZWQoc3RhdGUuX2FyZ3MsIGFyZ3MpKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gY2FsbGJhY2s7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcy5wdXNoKHN0YXRlKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuXHRjdXJyZW50SG9vayA9IDU7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+ICh7IGN1cnJlbnQ6IGluaXRpYWxWYWx1ZSB9KSwgW10pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7KCkgPT4gb2JqZWN0fSBjcmVhdGVIYW5kbGVcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGVIYW5kbGUsIGFyZ3MpIHtcblx0Y3VycmVudEhvb2sgPSA2O1xuXHR1c2VMYXlvdXRFZmZlY3QoXG5cdFx0KCkgPT4ge1xuXHRcdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZWYoY3JlYXRlSGFuZGxlKCkpO1xuXHRcdFx0XHRyZXR1cm4gKCkgPT4gcmVmKG51bGwpO1xuXHRcdFx0fSBlbHNlIGlmIChyZWYpIHtcblx0XHRcdFx0cmVmLmN1cnJlbnQgPSBjcmVhdGVIYW5kbGUoKTtcblx0XHRcdFx0cmV0dXJuICgpID0+IChyZWYuY3VycmVudCA9IG51bGwpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXJncyA9PSBudWxsID8gYXJncyA6IGFyZ3MuY29uY2F0KHJlZilcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IGFueX0gZmFjdG9yeVxuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVtbyhmYWN0b3J5LCBhcmdzKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuTWVtb0hvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDcpO1xuXHRpZiAoYXJnc0NoYW5nZWQoc3RhdGUuX2FyZ3MsIGFyZ3MpKSB7XG5cdFx0c3RhdGUuX3BlbmRpbmdWYWx1ZSA9IGZhY3RvcnkoKTtcblx0XHRzdGF0ZS5fcGVuZGluZ0FyZ3MgPSBhcmdzO1xuXHRcdHN0YXRlLl9mYWN0b3J5ID0gZmFjdG9yeTtcblx0XHRyZXR1cm4gc3RhdGUuX3BlbmRpbmdWYWx1ZTtcblx0fVxuXG5cdHJldHVybiBzdGF0ZS5fdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGFyZ3MpIHtcblx0Y3VycmVudEhvb2sgPSA4O1xuXHRyZXR1cm4gdXNlTWVtbygoKSA9PiBjYWxsYmFjaywgYXJncyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RDb250ZXh0fSBjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb250ZXh0KGNvbnRleHQpIHtcblx0Y29uc3QgcHJvdmlkZXIgPSBjdXJyZW50Q29tcG9uZW50LmNvbnRleHRbY29udGV4dC5faWRdO1xuXHQvLyBXZSBjb3VsZCBza2lwIHRoaXMgY2FsbCBoZXJlLCBidXQgdGhhbiB3ZSdkIG5vdCBjYWxsXG5cdC8vIGBvcHRpb25zLl9ob29rYC4gV2UgbmVlZCB0byBkbyB0aGF0IGluIG9yZGVyIHRvIG1ha2Vcblx0Ly8gdGhlIGRldnRvb2xzIGF3YXJlIG9mIHRoaXMgaG9vay5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db250ZXh0SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgOSk7XG5cdC8vIFRoZSBkZXZ0b29scyBuZWVkcyBhY2Nlc3MgdG8gdGhlIGNvbnRleHQgb2JqZWN0IHRvXG5cdC8vIGJlIGFibGUgdG8gcHVsbCBvZiB0aGUgZGVmYXVsdCB2YWx1ZSB3aGVuIG5vIHByb3ZpZGVyXG5cdC8vIGlzIHByZXNlbnQgaW4gdGhlIHRyZWUuXG5cdHN0YXRlLl9jb250ZXh0ID0gY29udGV4dDtcblx0aWYgKCFwcm92aWRlcikgcmV0dXJuIGNvbnRleHQuX2RlZmF1bHRWYWx1ZTtcblx0Ly8gVGhpcyBpcyBwcm9iYWJseSBub3Qgc2FmZSB0byBjb252ZXJ0IHRvIFwiIVwiXG5cdGlmIChzdGF0ZS5fdmFsdWUgPT0gbnVsbCkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IHRydWU7XG5cdFx0cHJvdmlkZXIuc3ViKGN1cnJlbnRDb21wb25lbnQpO1xuXHR9XG5cdHJldHVybiBwcm92aWRlci5wcm9wcy52YWx1ZTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IGEgY3VzdG9tIGxhYmVsIGZvciBhIGN1c3RvbSBob29rIGZvciB0aGUgZGV2dG9vbHMgcGFuZWxcbiAqIEB0eXBlIHs8VD4odmFsdWU6IFQsIGNiPzogKHZhbHVlOiBUKSA9PiBzdHJpbmcgfCBudW1iZXIpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXIpIHtcblx0aWYgKG9wdGlvbnMudXNlRGVidWdWYWx1ZSkge1xuXHRcdG9wdGlvbnMudXNlRGVidWdWYWx1ZShmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIodmFsdWUpIDogdmFsdWUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHsoZXJyb3I6IGFueSwgZXJyb3JJbmZvOiBpbXBvcnQoJ3ByZWFjdCcpLkVycm9ySW5mbykgPT4gdm9pZH0gY2JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVycm9yQm91bmRhcnkoY2IpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FcnJvckJvdW5kYXJ5SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMTApO1xuXHRjb25zdCBlcnJTdGF0ZSA9IHVzZVN0YXRlKCk7XG5cdHN0YXRlLl92YWx1ZSA9IGNiO1xuXHRpZiAoIWN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2gpIHtcblx0XHRjdXJyZW50Q29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoID0gKGVyciwgZXJyb3JJbmZvKSA9PiB7XG5cdFx0XHRpZiAoc3RhdGUuX3ZhbHVlKSBzdGF0ZS5fdmFsdWUoZXJyLCBlcnJvckluZm8pO1xuXHRcdFx0ZXJyU3RhdGVbMV0oZXJyKTtcblx0XHR9O1xuXHR9XG5cdHJldHVybiBbXG5cdFx0ZXJyU3RhdGVbMF0sXG5cdFx0KCkgPT4ge1xuXHRcdFx0ZXJyU3RhdGVbMV0odW5kZWZpbmVkKTtcblx0XHR9XG5cdF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJZCgpIHtcblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDExKTtcblx0aWYgKCFzdGF0ZS5fdmFsdWUpIHtcblx0XHQvLyBHcmFiIGVpdGhlciB0aGUgcm9vdCBub2RlIG9yIHRoZSBuZWFyZXN0IGFzeW5jIGJvdW5kYXJ5IG5vZGUuXG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwuZCcpLlZOb2RlfSAqL1xuXHRcdGxldCByb290ID0gY3VycmVudENvbXBvbmVudC5fdm5vZGU7XG5cdFx0d2hpbGUgKHJvb3QgIT09IG51bGwgJiYgIXJvb3QuX21hc2sgJiYgcm9vdC5fcGFyZW50ICE9PSBudWxsKSB7XG5cdFx0XHRyb290ID0gcm9vdC5fcGFyZW50O1xuXHRcdH1cblxuXHRcdGxldCBtYXNrID0gcm9vdC5fbWFzayB8fCAocm9vdC5fbWFzayA9IFswLCAwXSk7XG5cdFx0c3RhdGUuX3ZhbHVlID0gJ1AnICsgbWFza1swXSArICctJyArIG1hc2tbMV0rKztcblx0fVxuXG5cdHJldHVybiBzdGF0ZS5fdmFsdWU7XG59XG4vKipcbiAqIEFmdGVyIHBhaW50IGVmZmVjdHMgY29uc3VtZXIuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoQWZ0ZXJQYWludEVmZmVjdHMoKSB7XG5cdGxldCBjb21wb25lbnQ7XG5cdHdoaWxlICgoY29tcG9uZW50ID0gYWZ0ZXJQYWludEVmZmVjdHMuc2hpZnQoKSkpIHtcblx0XHRpZiAoIWNvbXBvbmVudC5fcGFyZW50RG9tIHx8ICFjb21wb25lbnQuX19ob29rcykgY29udGludWU7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjb21wb25lbnQuX3Zub2RlKTtcblx0XHR9XG5cdH1cbn1cblxubGV0IEhBU19SQUYgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09ICdmdW5jdGlvbic7XG5cbi8qKlxuICogU2NoZWR1bGUgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBicm93c2VyIGhhcyBhIGNoYW5jZSB0byBwYWludCBhIG5ldyBmcmFtZS5cbiAqIERvIHRoaXMgYnkgY29tYmluaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZSAockFGKSArIHNldFRpbWVvdXQgdG8gaW52b2tlIGEgY2FsbGJhY2sgYWZ0ZXJcbiAqIHRoZSBuZXh0IGJyb3dzZXIgZnJhbWUuXG4gKlxuICogQWxzbywgc2NoZWR1bGUgYSB0aW1lb3V0IGluIHBhcmFsbGVsIHRvIHRoZSB0aGUgckFGIHRvIGVuc3VyZSB0aGUgY2FsbGJhY2sgaXMgaW52b2tlZFxuICogZXZlbiBpZiBSQUYgZG9lc24ndCBmaXJlIChmb3IgZXhhbXBsZSBpZiB0aGUgYnJvd3NlciB0YWIgaXMgbm90IHZpc2libGUpXG4gKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBhZnRlck5leHRGcmFtZShjYWxsYmFjaykge1xuXHRjb25zdCBkb25lID0gKCkgPT4ge1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRpZiAoSEFTX1JBRikgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcblx0XHRzZXRUaW1lb3V0KGNhbGxiYWNrKTtcblx0fTtcblx0Y29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoZG9uZSwgUkFGX1RJTUVPVVQpO1xuXG5cdGxldCByYWY7XG5cdGlmIChIQVNfUkFGKSB7XG5cdFx0cmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRvbmUpO1xuXHR9XG59XG5cbi8vIE5vdGU6IGlmIHNvbWVvbmUgdXNlZCBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuLy8gdGhlbiBlZmZlY3RzIHdpbGwgQUxXQVlTIHJ1biBvbiB0aGUgTkVYVCBmcmFtZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IG9uZSwgaW5jdXJyaW5nIGEgfjE2bXMgZGVsYXkuXG4vLyBQZXJoYXBzIHRoaXMgaXMgbm90IHN1Y2ggYSBiaWcgZGVhbC5cbi8qKlxuICogU2NoZWR1bGUgYWZ0ZXJQYWludEVmZmVjdHMgZmx1c2ggYWZ0ZXIgdGhlIGJyb3dzZXIgcGFpbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3UXVldWVMZW5ndGhcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJQYWludChuZXdRdWV1ZUxlbmd0aCkge1xuXHRpZiAobmV3UXVldWVMZW5ndGggPT09IDEgfHwgcHJldlJhZiAhPT0gb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRwcmV2UmFmID0gb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0KHByZXZSYWYgfHwgYWZ0ZXJOZXh0RnJhbWUpKGZsdXNoQWZ0ZXJQYWludEVmZmVjdHMpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9IGhvb2tcbiAqL1xuZnVuY3Rpb24gaW52b2tlQ2xlYW51cChob29rKSB7XG5cdC8vIEEgaG9vayBjbGVhbnVwIGNhbiBpbnRyb2R1Y2UgYSBjYWxsIHRvIHJlbmRlciB3aGljaCBjcmVhdGVzIGEgbmV3IHJvb3QsIHRoaXMgd2lsbCBjYWxsIG9wdGlvbnMudm5vZGVcblx0Ly8gYW5kIG1vdmUgdGhlIGN1cnJlbnRDb21wb25lbnQgYXdheS5cblx0Y29uc3QgY29tcCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cdGxldCBjbGVhbnVwID0gaG9vay5fY2xlYW51cDtcblx0aWYgKHR5cGVvZiBjbGVhbnVwID09ICdmdW5jdGlvbicpIHtcblx0XHRob29rLl9jbGVhbnVwID0gdW5kZWZpbmVkO1xuXHRcdGNsZWFudXAoKTtcblx0fVxuXG5cdGN1cnJlbnRDb21wb25lbnQgPSBjb21wO1xufVxuXG4vKipcbiAqIEludm9rZSBhIEhvb2sncyBlZmZlY3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSBob29rXG4gKi9cbmZ1bmN0aW9uIGludm9rZUVmZmVjdChob29rKSB7XG5cdC8vIEEgaG9vayBjYWxsIGNhbiBpbnRyb2R1Y2UgYSBjYWxsIHRvIHJlbmRlciB3aGljaCBjcmVhdGVzIGEgbmV3IHJvb3QsIHRoaXMgd2lsbCBjYWxsIG9wdGlvbnMudm5vZGVcblx0Ly8gYW5kIG1vdmUgdGhlIGN1cnJlbnRDb21wb25lbnQgYXdheS5cblx0Y29uc3QgY29tcCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cdGhvb2suX2NsZWFudXAgPSBob29rLl92YWx1ZSgpO1xuXHRjdXJyZW50Q29tcG9uZW50ID0gY29tcDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueVtdfSBvbGRBcmdzXG4gKiBAcGFyYW0ge2FueVtdfSBuZXdBcmdzXG4gKi9cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3MsIG5ld0FyZ3MpIHtcblx0cmV0dXJuIChcblx0XHQhb2xkQXJncyB8fFxuXHRcdG9sZEFyZ3MubGVuZ3RoICE9PSBuZXdBcmdzLmxlbmd0aCB8fFxuXHRcdG5ld0FyZ3Muc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSlcblx0KTtcbn1cblxuZnVuY3Rpb24gaW52b2tlT3JSZXR1cm4oYXJnLCBmKSB7XG5cdHJldHVybiB0eXBlb2YgZiA9PSAnZnVuY3Rpb24nID8gZihhcmcpIDogZjtcbn1cbiIsIi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Zm9yIChsZXQgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG5cdHJldHVybiAvKiogQHR5cGUge08gJiBQfSAqLyAob2JqKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gb2JqZWN0cyBoYXZlIGEgZGlmZmVyZW50IHNoYXBlXG4gKiBAcGFyYW0ge29iamVjdH0gYVxuICogQHBhcmFtIHtvYmplY3R9IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0RpZmZlcnMoYSwgYikge1xuXHRmb3IgKGxldCBpIGluIGEpIGlmIChpICE9PSAnX19zb3VyY2UnICYmICEoaSBpbiBiKSkgcmV0dXJuIHRydWU7XG5cdGZvciAobGV0IGkgaW4gYikgaWYgKGkgIT09ICdfX3NvdXJjZScgJiYgYVtpXSAhPT0gYltpXSkgcmV0dXJuIHRydWU7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuXHRsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0aWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgdGhlIHNhbWUgdmFsdWVcbiAqIEBwYXJhbSB7Kn0geFxuICogQHBhcmFtIHsqfSB5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzKHgsIHkpIHtcblx0cmV0dXJuICh4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBDb21wb25lbnQgY2xhc3Mgd2l0aCBhIHByZWRlZmluZWQgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAgaW1wbGVtZW50YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFB1cmVDb21wb25lbnQocCkge1xuXHR0aGlzLnByb3BzID0gcDtcbn1cblB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuLy8gU29tZSB0aGlyZC1wYXJ0eSBsaWJyYXJpZXMgY2hlY2sgaWYgdGhpcyBwcm9wZXJ0eSBpcyBwcmVzZW50XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwcm9wcywgc3RhdGUpIHtcblx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIHByb3BzKSB8fCBzaGFsbG93RGlmZmVycyh0aGlzLnN0YXRlLCBzdGF0ZSk7XG59O1xuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzaGFsbG93RGlmZmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogTWVtb2l6ZSBhIGNvbXBvbmVudCwgc28gdGhhdCBpdCBvbmx5IHVwZGF0ZXMgd2hlbiB0aGUgcHJvcHMgYWN0dWFsbHkgaGF2ZVxuICogY2hhbmdlZC4gVGhpcyB3YXMgcHJldmlvdXNseSBrbm93biBhcyBgUmVhY3QucHVyZWAuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSBjIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gKiBAcGFyYW0geyhwcmV2OiBvYmplY3QsIG5leHQ6IG9iamVjdCkgPT4gYm9vbGVhbn0gW2NvbXBhcmVyXSBDdXN0b20gZXF1YWxpdHkgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW8oYywgY29tcGFyZXIpIHtcblx0ZnVuY3Rpb24gc2hvdWxkVXBkYXRlKG5leHRQcm9wcykge1xuXHRcdGxldCByZWYgPSB0aGlzLnByb3BzLnJlZjtcblx0XHRsZXQgdXBkYXRlUmVmID0gcmVmID09IG5leHRQcm9wcy5yZWY7XG5cdFx0aWYgKCF1cGRhdGVSZWYgJiYgcmVmKSB7XG5cdFx0XHRyZWYuY2FsbCA/IHJlZihudWxsKSA6IChyZWYuY3VycmVudCA9IG51bGwpO1xuXHRcdH1cblxuXHRcdGlmICghY29tcGFyZXIpIHtcblx0XHRcdHJldHVybiBzaGFsbG93RGlmZmVycyh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiAhY29tcGFyZXIodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fCAhdXBkYXRlUmVmO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWVtb2VkKHByb3BzKSB7XG5cdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBzaG91bGRVcGRhdGU7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoYywgcHJvcHMpO1xuXHR9XG5cdE1lbW9lZC5kaXNwbGF5TmFtZSA9ICdNZW1vKCcgKyAoYy5kaXNwbGF5TmFtZSB8fCBjLm5hbWUpICsgJyknO1xuXHRNZW1vZWQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXHRNZW1vZWQuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBNZW1vZWQ7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmxldCBvbGREaWZmSG9vayA9IG9wdGlvbnMuX2RpZmY7XG5vcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRpZiAodm5vZGUudHlwZSAmJiB2bm9kZS50eXBlLl9mb3J3YXJkZWQgJiYgdm5vZGUucmVmKSB7XG5cdFx0dm5vZGUucHJvcHMucmVmID0gdm5vZGUucmVmO1xuXHRcdHZub2RlLnJlZiA9IG51bGw7XG5cdH1cblx0aWYgKG9sZERpZmZIb29rKSBvbGREaWZmSG9vayh2bm9kZSk7XG59O1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRk9SV0FSRF9TWU1CT0wgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJlxuXHRcdFN5bWJvbC5mb3IgJiZcblx0XHRTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpKSB8fFxuXHQweGY0NztcblxuLyoqXG4gKiBQYXNzIHJlZiBkb3duIHRvIGEgY2hpbGQuIFRoaXMgaXMgbWFpbmx5IHVzZWQgaW4gbGlicmFyaWVzIHdpdGggSE9DcyB0aGF0XG4gKiB3cmFwIGNvbXBvbmVudHMuIFVzaW5nIGBmb3J3YXJkUmVmYCB0aGVyZSBpcyBhbiBlYXN5IHdheSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudCBpbnN0ZWFkIG9mIG9uZSBvZiB0aGUgd3JhcHBlciBpdHNlbGYuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLkZvcndhcmRGbn0gZm5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRSZWYoZm4pIHtcblx0ZnVuY3Rpb24gRm9yd2FyZGVkKHByb3BzKSB7XG5cdFx0bGV0IGNsb25lID0gYXNzaWduKHt9LCBwcm9wcyk7XG5cdFx0ZGVsZXRlIGNsb25lLnJlZjtcblx0XHRyZXR1cm4gZm4oY2xvbmUsIHByb3BzLnJlZiB8fCBudWxsKTtcblx0fVxuXG5cdC8vIG1vYngtcmVhY3QgY2hlY2tzIGZvciB0aGlzIGJlaW5nIHByZXNlbnRcblx0Rm9yd2FyZGVkLiQkdHlwZW9mID0gUkVBQ1RfRk9SV0FSRF9TWU1CT0w7XG5cdC8vIG1vYngtcmVhY3QgaGVhdmlseSByZWxpZXMgb24gaW1wbGVtZW50YXRpb24gZGV0YWlscy5cblx0Ly8gSXQgZXhwZWN0cyBhbiBvYmplY3QgaGVyZSB3aXRoIGEgYHJlbmRlcmAgcHJvcGVydHksXG5cdC8vIGFuZCBwcm90b3R5cGUucmVuZGVyIHdpbGwgZmFpbC4gV2l0aG91dCB0aGlzXG5cdC8vIG1vYngtcmVhY3QgdGhyb3dzLlxuXHRGb3J3YXJkZWQucmVuZGVyID0gRm9yd2FyZGVkO1xuXG5cdEZvcndhcmRlZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IEZvcndhcmRlZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0Rm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gJ0ZvcndhcmRSZWYoJyArIChmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lKSArICcpJztcblx0cmV0dXJuIEZvcndhcmRlZDtcbn1cbiIsImltcG9ydCB7IHRvQ2hpbGRBcnJheSB9IGZyb20gJ3ByZWFjdCc7XG5cbmNvbnN0IG1hcEZuID0gKGNoaWxkcmVuLCBmbikgPT4ge1xuXHRpZiAoY2hpbGRyZW4gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cdHJldHVybiB0b0NoaWxkQXJyYXkodG9DaGlsZEFycmF5KGNoaWxkcmVuKS5tYXAoZm4pKTtcbn07XG5cbi8vIFRoaXMgQVBJIGlzIGNvbXBsZXRlbHkgdW5uZWNlc3NhcnkgZm9yIFByZWFjdCwgc28gaXQncyBiYXNpY2FsbHkgcGFzc3Rocm91Z2guXG5leHBvcnQgY29uc3QgQ2hpbGRyZW4gPSB7XG5cdG1hcDogbWFwRm4sXG5cdGZvckVhY2g6IG1hcEZuLFxuXHRjb3VudChjaGlsZHJlbikge1xuXHRcdHJldHVybiBjaGlsZHJlbiA/IHRvQ2hpbGRBcnJheShjaGlsZHJlbikubGVuZ3RoIDogMDtcblx0fSxcblx0b25seShjaGlsZHJlbikge1xuXHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSB0b0NoaWxkQXJyYXkoY2hpbGRyZW4pO1xuXHRcdGlmIChub3JtYWxpemVkLmxlbmd0aCAhPT0gMSkgdGhyb3cgJ0NoaWxkcmVuLm9ubHknO1xuXHRcdHJldHVybiBub3JtYWxpemVkWzBdO1xuXHR9LFxuXHR0b0FycmF5OiB0b0NoaWxkQXJyYXlcbn07XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQsIG9wdGlvbnMsIEZyYWdtZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IG9sZENhdGNoRXJyb3IgPSBvcHRpb25zLl9jYXRjaEVycm9yO1xub3B0aW9ucy5fY2F0Y2hFcnJvciA9IGZ1bmN0aW9uKGVycm9yLCBuZXdWTm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbykge1xuXHRpZiAoZXJyb3IudGhlbikge1xuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRcdGxldCBjb21wb25lbnQ7XG5cdFx0bGV0IHZub2RlID0gbmV3Vk5vZGU7XG5cblx0XHRmb3IgKDsgKHZub2RlID0gdm5vZGUuX3BhcmVudCk7ICkge1xuXHRcdFx0aWYgKChjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50KSAmJiBjb21wb25lbnQuX2NoaWxkRGlkU3VzcGVuZCkge1xuXHRcdFx0XHRpZiAobmV3Vk5vZGUuX2RvbSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIERvbid0IGNhbGwgb2xkQ2F0Y2hFcnJvciBpZiB3ZSBmb3VuZCBhIFN1c3BlbnNlXG5cdFx0XHRcdHJldHVybiBjb21wb25lbnQuX2NoaWxkRGlkU3VzcGVuZChlcnJvciwgbmV3Vk5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRvbGRDYXRjaEVycm9yKGVycm9yLCBuZXdWTm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbyk7XG59O1xuXG5jb25zdCBvbGRVbm1vdW50ID0gb3B0aW9ucy51bm1vdW50O1xub3B0aW9ucy51bm1vdW50ID0gZnVuY3Rpb24odm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGNvbnN0IGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50Ll9vblJlc29sdmUpIHtcblx0XHRjb21wb25lbnQuX29uUmVzb2x2ZSgpO1xuXHR9XG5cblx0Ly8gaWYgdGhlIGNvbXBvbmVudCBpcyBzdGlsbCBoeWRyYXRpbmdcblx0Ly8gbW9zdCBsaWtlbHkgaXQgaXMgYmVjYXVzZSB0aGUgY29tcG9uZW50IGlzIHN1c3BlbmRlZFxuXHQvLyB3ZSBzZXQgdGhlIHZub2RlLnR5cGUgYXMgYG51bGxgIHNvIHRoYXQgaXQgaXMgbm90IGEgdHlwZW9mIGZ1bmN0aW9uXG5cdC8vIHNvIHRoZSB1bm1vdW50IHdpbGwgcmVtb3ZlIHRoZSB2bm9kZS5fZG9tXG5cdGlmIChjb21wb25lbnQgJiYgdm5vZGUuX2h5ZHJhdGluZyA9PT0gdHJ1ZSkge1xuXHRcdHZub2RlLnR5cGUgPSBudWxsO1xuXHR9XG5cblx0aWYgKG9sZFVubW91bnQpIG9sZFVubW91bnQodm5vZGUpO1xufTtcblxuZnVuY3Rpb24gZGV0YWNoZWRDbG9uZSh2bm9kZSwgZGV0YWNoZWRQYXJlbnQsIHBhcmVudERvbSkge1xuXHRpZiAodm5vZGUpIHtcblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCAmJiB2bm9kZS5fY29tcG9uZW50Ll9faG9va3MpIHtcblx0XHRcdHZub2RlLl9jb21wb25lbnQuX19ob29rcy5fbGlzdC5mb3JFYWNoKGVmZmVjdCA9PiB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZWZmZWN0Ll9jbGVhbnVwID09ICdmdW5jdGlvbicpIGVmZmVjdC5fY2xlYW51cCgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHZub2RlLl9jb21wb25lbnQuX19ob29rcyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dm5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0XHRpZiAodm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID09PSBwYXJlbnREb20pIHtcblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID0gZGV0YWNoZWRQYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHR2bm9kZS5fY29tcG9uZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHR2bm9kZS5fY2hpbGRyZW4gPVxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuICYmXG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4ubWFwKGNoaWxkID0+XG5cdFx0XHRcdGRldGFjaGVkQ2xvbmUoY2hpbGQsIGRldGFjaGVkUGFyZW50LCBwYXJlbnREb20pXG5cdFx0XHQpO1xuXHR9XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVPcmlnaW5hbCh2bm9kZSwgZGV0YWNoZWRQYXJlbnQsIG9yaWdpbmFsUGFyZW50KSB7XG5cdGlmICh2bm9kZSkge1xuXHRcdHZub2RlLl9vcmlnaW5hbCA9IG51bGw7XG5cdFx0dm5vZGUuX2NoaWxkcmVuID1cblx0XHRcdHZub2RlLl9jaGlsZHJlbiAmJlxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuLm1hcChjaGlsZCA9PlxuXHRcdFx0XHRyZW1vdmVPcmlnaW5hbChjaGlsZCwgZGV0YWNoZWRQYXJlbnQsIG9yaWdpbmFsUGFyZW50KVxuXHRcdFx0KTtcblxuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRpZiAodm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID09PSBkZXRhY2hlZFBhcmVudCkge1xuXHRcdFx0XHRpZiAodm5vZGUuX2RvbSkge1xuXHRcdFx0XHRcdG9yaWdpbmFsUGFyZW50Lmluc2VydEJlZm9yZSh2bm9kZS5fZG9tLCB2bm9kZS5fbmV4dERvbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fZm9yY2UgPSB0cnVlO1xuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPSBvcmlnaW5hbFBhcmVudDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbi8vIGhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXNcbmV4cG9ydCBmdW5jdGlvbiBTdXNwZW5zZSgpIHtcblx0Ly8gd2UgZG8gbm90IGNhbGwgc3VwZXIgaGVyZSB0byBnb2xmIHNvbWUgYnl0ZXMuLi5cblx0dGhpcy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCA9IDA7XG5cdHRoaXMuX3N1c3BlbmRlcnMgPSBudWxsO1xuXHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsO1xufVxuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8qKlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fVxuICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlIFRoZSB0aHJvd24gcHJvbWlzZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZTxhbnksIGFueT59IHN1c3BlbmRpbmdWTm9kZSBUaGUgc3VzcGVuZGluZyBjb21wb25lbnRcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLl9jaGlsZERpZFN1c3BlbmQgPSBmdW5jdGlvbihwcm9taXNlLCBzdXNwZW5kaW5nVk5vZGUpIHtcblx0Y29uc3Qgc3VzcGVuZGluZ0NvbXBvbmVudCA9IHN1c3BlbmRpbmdWTm9kZS5fY29tcG9uZW50O1xuXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9ICovXG5cdGNvbnN0IGMgPSB0aGlzO1xuXG5cdGlmIChjLl9zdXNwZW5kZXJzID09IG51bGwpIHtcblx0XHRjLl9zdXNwZW5kZXJzID0gW107XG5cdH1cblx0Yy5fc3VzcGVuZGVycy5wdXNoKHN1c3BlbmRpbmdDb21wb25lbnQpO1xuXG5cdGNvbnN0IHJlc29sdmUgPSBzdXNwZW5kZWQoYy5fdm5vZGUpO1xuXG5cdGxldCByZXNvbHZlZCA9IGZhbHNlO1xuXHRjb25zdCBvblJlc29sdmVkID0gKCkgPT4ge1xuXHRcdGlmIChyZXNvbHZlZCkgcmV0dXJuO1xuXG5cdFx0cmVzb2x2ZWQgPSB0cnVlO1xuXHRcdHN1c3BlbmRpbmdDb21wb25lbnQuX29uUmVzb2x2ZSA9IG51bGw7XG5cblx0XHRpZiAocmVzb2x2ZSkge1xuXHRcdFx0cmVzb2x2ZShvblN1c3BlbnNpb25Db21wbGV0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9uU3VzcGVuc2lvbkNvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdHN1c3BlbmRpbmdDb21wb25lbnQuX29uUmVzb2x2ZSA9IG9uUmVzb2x2ZWQ7XG5cblx0Y29uc3Qgb25TdXNwZW5zaW9uQ29tcGxldGUgPSAoKSA9PiB7XG5cdFx0aWYgKCEtLWMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQpIHtcblx0XHRcdC8vIElmIHRoZSBzdXNwZW5zaW9uIHdhcyBkdXJpbmcgaHlkcmF0aW9uIHdlIGRvbid0IG5lZWQgdG8gcmVzdG9yZSB0aGVcblx0XHRcdC8vIHN1c3BlbmRlZCBjaGlsZHJlbiBpbnRvIHRoZSBfY2hpbGRyZW4gYXJyYXlcblx0XHRcdGlmIChjLnN0YXRlLl9zdXNwZW5kZWQpIHtcblx0XHRcdFx0Y29uc3Qgc3VzcGVuZGVkVk5vZGUgPSBjLnN0YXRlLl9zdXNwZW5kZWQ7XG5cdFx0XHRcdGMuX3Zub2RlLl9jaGlsZHJlblswXSA9IHJlbW92ZU9yaWdpbmFsKFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLl9jb21wb25lbnQuX3BhcmVudERvbSxcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZS5fY29tcG9uZW50Ll9vcmlnaW5hbFBhcmVudERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRjLnNldFN0YXRlKHsgX3N1c3BlbmRlZDogKGMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGwpIH0pO1xuXG5cdFx0XHRsZXQgc3VzcGVuZGVkO1xuXHRcdFx0d2hpbGUgKChzdXNwZW5kZWQgPSBjLl9zdXNwZW5kZXJzLnBvcCgpKSkge1xuXHRcdFx0XHRzdXNwZW5kZWQuZm9yY2VVcGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFdlIGRvIG5vdCBzZXQgYHN1c3BlbmRlZDogdHJ1ZWAgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHdlIHdhbnQgdGhlIGFjdHVhbCBtYXJrdXBcblx0ICogdG8gcmVtYWluIG9uIHNjcmVlbiBhbmQgaHlkcmF0ZSBpdCB3aGVuIHRoZSBzdXNwZW5zZSBhY3R1YWxseSBnZXRzIHJlc29sdmVkLlxuXHQgKiBXaGlsZSBpbiBub24taHlkcmF0aW9uIGNhc2VzIHRoZSB1c3VhbCBmYWxsYmFjayAtPiBjb21wb25lbnQgZmxvdyB3b3VsZCBvY2NvdXIuXG5cdCAqL1xuXHRjb25zdCB3YXNIeWRyYXRpbmcgPSBzdXNwZW5kaW5nVk5vZGUuX2h5ZHJhdGluZyA9PT0gdHJ1ZTtcblx0aWYgKCFjLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50KysgJiYgIXdhc0h5ZHJhdGluZykge1xuXHRcdGMuc2V0U3RhdGUoeyBfc3VzcGVuZGVkOiAoYy5fZGV0YWNoT25OZXh0UmVuZGVyID0gYy5fdm5vZGUuX2NoaWxkcmVuWzBdKSB9KTtcblx0fVxuXHRwcm9taXNlLnRoZW4ob25SZXNvbHZlZCwgb25SZXNvbHZlZCk7XG59O1xuXG5TdXNwZW5zZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fc3VzcGVuZGVycyA9IFtdO1xufTtcblxuLyoqXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50W1wicHJvcHNcIl19IHByb3BzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlU3RhdGV9IHN0YXRlXG4gKi9cblN1c3BlbnNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwcm9wcywgc3RhdGUpIHtcblx0aWYgKHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlcikge1xuXHRcdC8vIFdoZW4gdGhlIFN1c3BlbnNlJ3MgX3Zub2RlIHdhcyBjcmVhdGVkIGJ5IGEgY2FsbCB0byBjcmVhdGVWTm9kZVxuXHRcdC8vIChpLmUuIGR1ZSB0byBhIHNldFN0YXRlIGZ1cnRoZXIgdXAgaW4gdGhlIHRyZWUpXG5cdFx0Ly8gaXQncyBfY2hpbGRyZW4gcHJvcCBpcyBudWxsLCBpbiB0aGlzIGNhc2Ugd2UgXCJmb3JnZXRcIiBhYm91dCB0aGUgcGFya2VkIHZub2RlcyB0byBkZXRhY2hcblx0XHRpZiAodGhpcy5fdm5vZGUuX2NoaWxkcmVuKSB7XG5cdFx0XHRjb25zdCBkZXRhY2hlZFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0Y29uc3QgZGV0YWNoZWRDb21wb25lbnQgPSB0aGlzLl92bm9kZS5fY2hpbGRyZW5bMF0uX2NvbXBvbmVudDtcblx0XHRcdHRoaXMuX3Zub2RlLl9jaGlsZHJlblswXSA9IGRldGFjaGVkQ2xvbmUoXG5cdFx0XHRcdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlcixcblx0XHRcdFx0ZGV0YWNoZWRQYXJlbnQsXG5cdFx0XHRcdChkZXRhY2hlZENvbXBvbmVudC5fb3JpZ2luYWxQYXJlbnREb20gPSBkZXRhY2hlZENvbXBvbmVudC5fcGFyZW50RG9tKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsO1xuXHR9XG5cblx0Ly8gV3JhcCBmYWxsYmFjayB0cmVlIGluIGEgVk5vZGUgdGhhdCBwcmV2ZW50cyBpdHNlbGYgZnJvbSBiZWluZyBtYXJrZWQgYXMgYWJvcnRpbmcgbWlkLWh5ZHJhdGlvbjpcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gKi9cblx0Y29uc3QgZmFsbGJhY2sgPVxuXHRcdHN0YXRlLl9zdXNwZW5kZWQgJiYgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgcHJvcHMuZmFsbGJhY2spO1xuXHRpZiAoZmFsbGJhY2spIGZhbGxiYWNrLl9oeWRyYXRpbmcgPSBudWxsO1xuXG5cdHJldHVybiBbXG5cdFx0Y3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgc3RhdGUuX3N1c3BlbmRlZCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbiksXG5cdFx0ZmFsbGJhY2tcblx0XTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGFuZCBjYWxscyB0aGUgcGFyZW50IGNvbXBvbmVudCdzIF9zdXNwZW5kZWQgbWV0aG9kLCBwYXNzaW5nIGluIHRoZVxuICogc3VzcGVuZGVkIHZub2RlLiBUaGlzIGlzIGEgd2F5IGZvciBhIHBhcmVudCAoZS5nLiBTdXNwZW5zZUxpc3QpIHRvIGdldCBub3RpZmllZFxuICogdGhhdCBvbmUgb2YgaXRzIGNoaWxkcmVuL2Rlc2NlbmRhbnRzIHN1c3BlbmRlZC5cbiAqXG4gKiBUaGUgcGFyZW50IE1BWSByZXR1cm4gYSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIHdpbGwgZ2V0IGNhbGxlZCB3aGVuIHRoZVxuICogc3VzcGVuc2lvbiByZXNvbHZlcywgbm90aWZ5aW5nIHRoZSBwYXJlbnQgb2YgdGhlIGZhY3QuXG4gKiBNb3Jlb3ZlciwgdGhlIGNhbGxiYWNrIGdldHMgZnVuY3Rpb24gYHVuc3VzcGVuZGAgYXMgYSBwYXJhbWV0ZXIuIFRoZSByZXNvbHZlZFxuICogY2hpbGQgZGVzY2VuZGFudCB3aWxsIG5vdCBhY3R1YWxseSBnZXQgdW5zdXNwZW5kZWQgdW50aWwgYHVuc3VzcGVuZGAgZ2V0cyBjYWxsZWQuXG4gKiBUaGlzIGlzIGEgd2F5IGZvciB0aGUgcGFyZW50IHRvIGRlbGF5IHVuc3VzcGVuZGluZy5cbiAqXG4gKiBJZiB0aGUgcGFyZW50IGRvZXMgbm90IHJldHVybiBhIGNhbGxiYWNrIHRoZW4gdGhlIHJlc29sdmVkIHZub2RlXG4gKiBnZXRzIHVuc3VzcGVuZGVkIGltbWVkaWF0ZWx5IHdoZW4gaXQgcmVzb2x2ZXMuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEByZXR1cm5zIHsoKHVuc3VzcGVuZDogKCkgPT4gdm9pZCkgPT4gdm9pZCk/fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VzcGVuZGVkKHZub2RlKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRsZXQgY29tcG9uZW50ID0gdm5vZGUuX3BhcmVudC5fY29tcG9uZW50O1xuXHRyZXR1cm4gY29tcG9uZW50ICYmIGNvbXBvbmVudC5fc3VzcGVuZGVkICYmIGNvbXBvbmVudC5fc3VzcGVuZGVkKHZub2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhenkobG9hZGVyKSB7XG5cdGxldCBwcm9tO1xuXHRsZXQgY29tcG9uZW50O1xuXHRsZXQgZXJyb3I7XG5cblx0ZnVuY3Rpb24gTGF6eShwcm9wcykge1xuXHRcdGlmICghcHJvbSkge1xuXHRcdFx0cHJvbSA9IGxvYWRlcigpO1xuXHRcdFx0cHJvbS50aGVuKFxuXHRcdFx0XHRleHBvcnRzID0+IHtcblx0XHRcdFx0XHRjb21wb25lbnQgPSBleHBvcnRzLmRlZmF1bHQgfHwgZXhwb3J0cztcblx0XHRcdFx0fSxcblx0XHRcdFx0ZSA9PiB7XG5cdFx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChlcnJvcikge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXG5cdFx0aWYgKCFjb21wb25lbnQpIHtcblx0XHRcdHRocm93IHByb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcyk7XG5cdH1cblxuXHRMYXp5LmRpc3BsYXlOYW1lID0gJ0xhenknO1xuXHRMYXp5Ll9mb3J3YXJkZWQgPSB0cnVlO1xuXHRyZXR1cm4gTGF6eTtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgdG9DaGlsZEFycmF5IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHN1c3BlbmRlZCB9IGZyb20gJy4vc3VzcGVuc2UuanMnO1xuXG4vLyBJbmRleGVzIHRvIGxpbmtlZCBsaXN0IG5vZGVzIChub2RlcyBhcmUgc3RvcmVkIGFzIGFycmF5cyB0byBzYXZlIGJ5dGVzKS5cbmNvbnN0IFNVU1BFTkRFRF9DT1VOVCA9IDA7XG5jb25zdCBSRVNPTFZFRF9DT1VOVCA9IDE7XG5jb25zdCBORVhUX05PREUgPSAyO1xuXG4vLyBIYXZpbmcgY3VzdG9tIGluaGVyaXRhbmNlIGluc3RlYWQgb2YgYSBjbGFzcyBoZXJlIHNhdmVzIGEgbG90IG9mIGJ5dGVzLlxuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlTGlzdCgpIHtcblx0dGhpcy5fbmV4dCA9IG51bGw7XG5cdHRoaXMuX21hcCA9IG51bGw7XG59XG5cbi8vIE1hcmsgb25lIG9mIGNoaWxkJ3MgZWFybGllciBzdXNwZW5zaW9ucyBhcyByZXNvbHZlZC5cbi8vIFNvbWUgcGVuZGluZyBjYWxsYmFja3MgbWF5IGJlY29tZSBjYWxsYWJsZSBkdWUgdG8gdGhpc1xuLy8gKGUuZy4gdGhlIGxhc3Qgc3VzcGVuZGVkIGRlc2NlbmRhbnQgZ2V0cyByZXNvbHZlZCB3aGVuXG4vLyByZXZlYWxPcmRlciA9PT0gJ3RvZ2V0aGVyJykuIFByb2Nlc3MgdGhvc2UgY2FsbGJhY2tzIGFzIHdlbGwuXG5jb25zdCByZXNvbHZlID0gKGxpc3QsIGNoaWxkLCBub2RlKSA9PiB7XG5cdGlmICgrK25vZGVbUkVTT0xWRURfQ09VTlRdID09PSBub2RlW1NVU1BFTkRFRF9DT1VOVF0pIHtcblx0XHQvLyBUaGUgbnVtYmVyIGEgY2hpbGQgKG9yIGFueSBvZiBpdHMgZGVzY2VuZGFudHMpIGhhcyBiZWVuIHN1c3BlbmRlZFxuXHRcdC8vIG1hdGNoZXMgdGhlIG51bWJlciBvZiB0aW1lcyBpdCdzIGJlZW4gcmVzb2x2ZWQuIFRoZXJlZm9yZSB3ZVxuXHRcdC8vIG1hcmsgdGhlIGNoaWxkIGFzIGNvbXBsZXRlbHkgcmVzb2x2ZWQgYnkgZGVsZXRpbmcgaXQgZnJvbSAuX21hcC5cblx0XHQvLyBUaGlzIGlzIHVzZWQgdG8gZmlndXJlIG91dCB3aGVuICphbGwqIGNoaWxkcmVuIGhhdmUgYmVlbiBjb21wbGV0ZWx5XG5cdFx0Ly8gcmVzb2x2ZWQgd2hlbiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInLlxuXHRcdGxpc3QuX21hcC5kZWxldGUoY2hpbGQpO1xuXHR9XG5cblx0Ly8gSWYgcmV2ZWFsT3JkZXIgaXMgZmFsc3kgdGhlbiB3ZSBjYW4gZG8gYW4gZWFybHkgZXhpdCwgYXMgdGhlXG5cdC8vIGNhbGxiYWNrcyB3b24ndCBnZXQgcXVldWVkIGluIHRoZSBub2RlIGFueXdheS5cblx0Ly8gSWYgcmV2ZWFsT3JkZXIgaXMgJ3RvZ2V0aGVyJyB0aGVuIGFsc28gZG8gYW4gZWFybHkgZXhpdFxuXHQvLyBpZiBhbGwgc3VzcGVuZGVkIGRlc2NlbmRhbnRzIGhhdmUgbm90IHlldCBiZWVuIHJlc29sdmVkLlxuXHRpZiAoXG5cdFx0IWxpc3QucHJvcHMucmV2ZWFsT3JkZXIgfHxcblx0XHQobGlzdC5wcm9wcy5yZXZlYWxPcmRlclswXSA9PT0gJ3QnICYmIGxpc3QuX21hcC5zaXplKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBXYWxrIHRoZSBjdXJyZW50bHkgc3VzcGVuZGVkIGNoaWxkcmVuIGluIG9yZGVyLCBjYWxsaW5nIHRoZWlyXG5cdC8vIHN0b3JlZCBjYWxsYmFja3Mgb24gdGhlIHdheS4gU3RvcCBpZiB3ZSBlbmNvdW50ZXIgYSBjaGlsZCB0aGF0XG5cdC8vIGhhcyBub3QgYmVlbiBjb21wbGV0ZWx5IHJlc29sdmVkIHlldC5cblx0bm9kZSA9IGxpc3QuX25leHQ7XG5cdHdoaWxlIChub2RlKSB7XG5cdFx0d2hpbGUgKG5vZGUubGVuZ3RoID4gMykge1xuXHRcdFx0bm9kZS5wb3AoKSgpO1xuXHRcdH1cblx0XHRpZiAobm9kZVtSRVNPTFZFRF9DT1VOVF0gPCBub2RlW1NVU1BFTkRFRF9DT1VOVF0pIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRsaXN0Ll9uZXh0ID0gbm9kZSA9IG5vZGVbTkVYVF9OT0RFXTtcblx0fVxufTtcblxuLy8gVGhpbmdzIHdlIGRvIGhlcmUgdG8gc2F2ZSBzb21lIGJ5dGVzIGJ1dCBhcmUgbm90IHByb3BlciBKUyBpbmhlcml0YW5jZTpcbi8vIC0gY2FsbCBgbmV3IENvbXBvbmVudCgpYCBhcyB0aGUgcHJvdG90eXBlXG4vLyAtIGRvIG5vdCBzZXQgYFN1c3BlbnNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgdG8gYFN1c3BlbnNlYFxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5fc3VzcGVuZGVkID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0Y29uc3QgbGlzdCA9IHRoaXM7XG5cdGNvbnN0IGRlbGVnYXRlZCA9IHN1c3BlbmRlZChsaXN0Ll92bm9kZSk7XG5cblx0bGV0IG5vZGUgPSBsaXN0Ll9tYXAuZ2V0KGNoaWxkKTtcblx0bm9kZVtTVVNQRU5ERURfQ09VTlRdKys7XG5cblx0cmV0dXJuIHVuc3VzcGVuZCA9PiB7XG5cdFx0Y29uc3Qgd3JhcHBlZFVuc3VzcGVuZCA9ICgpID0+IHtcblx0XHRcdGlmICghbGlzdC5wcm9wcy5yZXZlYWxPcmRlcikge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgdGhlIHVuZGVmaW5lZCAoZmFsc3kpIHJldmVhbE9yZGVyLCBhcyB0aGVyZVxuXHRcdFx0XHQvLyBpcyBubyBuZWVkIHRvIGNvb3JkaW5hdGUgYSBzcGVjaWZpYyBvcmRlciBvciB1bnN1c3BlbmRzLlxuXHRcdFx0XHR1bnN1c3BlbmQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUucHVzaCh1bnN1c3BlbmQpO1xuXHRcdFx0XHRyZXNvbHZlKGxpc3QsIGNoaWxkLCBub2RlKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGlmIChkZWxlZ2F0ZWQpIHtcblx0XHRcdGRlbGVnYXRlZCh3cmFwcGVkVW5zdXNwZW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d3JhcHBlZFVuc3VzcGVuZCgpO1xuXHRcdH1cblx0fTtcbn07XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0dGhpcy5fbmV4dCA9IG51bGw7XG5cdHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcblxuXHRjb25zdCBjaGlsZHJlbiA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbik7XG5cdGlmIChwcm9wcy5yZXZlYWxPcmRlciAmJiBwcm9wcy5yZXZlYWxPcmRlclswXSA9PT0gJ2InKSB7XG5cdFx0Ly8gSWYgb3JkZXIgPT09ICdiYWNrd2FyZHMnIChvciwgd2VsbCwgYW55dGhpbmcgc3RhcnRpbmcgd2l0aCBhICdiJylcblx0XHQvLyB0aGVuIGZsaXAgdGhlIGNoaWxkIGxpc3QgYXJvdW5kIHNvIHRoYXQgdGhlIGxhc3QgY2hpbGQgd2lsbCBiZVxuXHRcdC8vIHRoZSBmaXJzdCBpbiB0aGUgbGlua2VkIGxpc3QuXG5cdFx0Y2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHR9XG5cdC8vIEJ1aWxkIHRoZSBsaW5rZWQgbGlzdC4gSXRlcmF0ZSB0aHJvdWdoIHRoZSBjaGlsZHJlbiBpbiByZXZlcnNlIG9yZGVyXG5cdC8vIHNvIHRoYXQgYF9uZXh0YCBwb2ludHMgdG8gdGhlIGZpcnN0IGxpbmtlZCBsaXN0IG5vZGUgdG8gYmUgcmVzb2x2ZWQuXG5cdGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGg7IGktLTsgKSB7XG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IGxpbmtlZCBsaXN0IG5vZGUgYXMgYW4gYXJyYXkgb2YgZm9ybTpcblx0XHQvLyBcdFtzdXNwZW5kZWRfY291bnQsIHJlc29sdmVkX2NvdW50LCBuZXh0X25vZGVdXG5cdFx0Ly8gd2hlcmUgc3VzcGVuZGVkX2NvdW50IGFuZCByZXNvbHZlZF9jb3VudCBhcmUgbnVtZXJpYyBjb3VudGVycyBmb3Jcblx0XHQvLyBrZWVwaW5nIHRyYWNrIGhvdyBtYW55IHRpbWVzIGEgbm9kZSBoYXMgYmVlbiBzdXNwZW5kZWQgYW5kIHJlc29sdmVkLlxuXHRcdC8vXG5cdFx0Ly8gTm90ZSB0aGF0IHN1c3BlbmRlZF9jb3VudCBzdGFydHMgZnJvbSAxIGluc3RlYWQgb2YgMCwgc28gd2UgY2FuIGJsb2NrXG5cdFx0Ly8gcHJvY2Vzc2luZyBjYWxsYmFja3MgdW50aWwgY29tcG9uZW50RGlkTW91bnQgaGFzIGJlZW4gY2FsbGVkLiBJbiBhIHNlbnNlXG5cdFx0Ly8gbm9kZSBpcyBzdXNwZW5kZWQgYXQgbGVhc3QgdW50aWwgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQhXG5cdFx0Ly9cblx0XHQvLyBQZW5kaW5nIGNhbGxiYWNrcyBhcmUgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgbm9kZTpcblx0XHQvLyBcdFtzdXNwZW5kZWRfY291bnQsIHJlc29sdmVkX2NvdW50LCBuZXh0X25vZGUsIGNhbGxiYWNrXzAsIGNhbGxiYWNrXzEsIC4uLl1cblx0XHR0aGlzLl9tYXAuc2V0KGNoaWxkcmVuW2ldLCAodGhpcy5fbmV4dCA9IFsxLCAwLCB0aGlzLl9uZXh0XSkpO1xuXHR9XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn07XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuXHQvLyBJdGVyYXRlIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFmdGVyIG1vdW50aW5nIGZvciB0d28gcmVhc29uczpcblx0Ly8gMS4gQXMgZWFjaCBub2RlW1NVU1BFTkRFRF9DT1VOVF0gc3RhcnRzIGZyb20gMSwgdGhpcyBpdGVyYXRpb24gaW5jcmVhc2VzXG5cdC8vICAgIGVhY2ggbm9kZVtSRUxFQVNFRF9DT1VOVF0gYnkgMSwgdGhlcmVmb3JlIGJhbGFuY2luZyB0aGUgY291bnRlcnMuXG5cdC8vICAgIFRoZSBub2RlcyBjYW4gbm93IGJlIGNvbXBsZXRlbHkgY29uc3VtZWQgZnJvbSB0aGUgbGlua2VkIGxpc3QuXG5cdC8vIDIuIEhhbmRsZSBub2RlcyB0aGF0IG1pZ2h0IGhhdmUgZ290dGVuIHJlc29sdmVkIGJldHdlZW4gcmVuZGVyIGFuZFxuXHQvLyAgICBjb21wb25lbnREaWRNb3VudC5cblx0dGhpcy5fbWFwLmZvckVhY2goKG5vZGUsIGNoaWxkKSA9PiB7XG5cdFx0cmVzb2x2ZSh0aGlzLCBjaGlsZCwgbm9kZSk7XG5cdH0pO1xufTtcbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIHJlbmRlciB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3NyYy9pbmRleCcpLlJlbmRlcmFibGVQcm9wczx7IGNvbnRleHQ6IGFueSB9Pn0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gQ29udGV4dFByb3ZpZGVyKHByb3BzKSB7XG5cdHRoaXMuZ2V0Q2hpbGRDb250ZXh0ID0gKCkgPT4gcHJvcHMuY29udGV4dDtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIFBvcnRhbCBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGwgfCB1bmRlZmluZWR9IHByb3BzXG4gKlxuICogVE9ETzogdXNlIGNyZWF0ZVJvb3QoKSBpbnN0ZWFkIG9mIGZha2Ugcm9vdFxuICovXG5mdW5jdGlvbiBQb3J0YWwocHJvcHMpIHtcblx0Y29uc3QgX3RoaXMgPSB0aGlzO1xuXHRsZXQgY29udGFpbmVyID0gcHJvcHMuX2NvbnRhaW5lcjtcblxuXHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlbmRlcihudWxsLCBfdGhpcy5fdGVtcCk7XG5cdFx0X3RoaXMuX3RlbXAgPSBudWxsO1xuXHRcdF90aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHR9O1xuXG5cdC8vIFdoZW4gd2UgY2hhbmdlIGNvbnRhaW5lciB3ZSBzaG91bGQgY2xlYXIgb3VyIG9sZCBjb250YWluZXIgYW5kXG5cdC8vIGluZGljYXRlIGEgbmV3IG1vdW50LlxuXHRpZiAoX3RoaXMuX2NvbnRhaW5lciAmJiBfdGhpcy5fY29udGFpbmVyICE9PSBjb250YWluZXIpIHtcblx0XHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHR9XG5cblx0Ly8gV2hlbiBwcm9wcy52bm9kZSBpcyB1bmRlZmluZWQvZmFsc2UvbnVsbCB3ZSBhcmUgZGVhbGluZyB3aXRoIHNvbWUga2luZCBvZlxuXHQvLyBjb25kaXRpb25hbCB2bm9kZS4gVGhpcyBzaG91bGQgbm90IHRyaWdnZXIgYSByZW5kZXIuXG5cdGlmIChwcm9wcy5fdm5vZGUpIHtcblx0XHRpZiAoIV90aGlzLl90ZW1wKSB7XG5cdFx0XHRfdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBmYWtlIERPTSBwYXJlbnQgbm9kZSB0aGF0IG1hbmFnZXMgYSBzdWJzZXQgb2YgYGNvbnRhaW5lcmAncyBjaGlsZHJlbjpcblx0XHRcdF90aGlzLl90ZW1wID0ge1xuXHRcdFx0XHRub2RlVHlwZTogMSxcblx0XHRcdFx0cGFyZW50Tm9kZTogY29udGFpbmVyLFxuXHRcdFx0XHRjaGlsZE5vZGVzOiBbXSxcblx0XHRcdFx0YXBwZW5kQ2hpbGQoY2hpbGQpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZW1vdmVDaGlsZChjaGlsZCkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5zcGxpY2UodGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoY2hpbGQpID4+PiAxLCAxKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBSZW5kZXIgb3VyIHdyYXBwaW5nIGVsZW1lbnQgaW50byB0ZW1wLlxuXHRcdHJlbmRlcihcblx0XHRcdGNyZWF0ZUVsZW1lbnQoQ29udGV4dFByb3ZpZGVyLCB7IGNvbnRleHQ6IF90aGlzLmNvbnRleHQgfSwgcHJvcHMuX3Zub2RlKSxcblx0XHRcdF90aGlzLl90ZW1wXG5cdFx0KTtcblx0fVxuXHQvLyBXaGVuIHdlIGNvbWUgZnJvbSBhIGNvbmRpdGlvbmFsIHJlbmRlciwgb24gYSBtb3VudGVkXG5cdC8vIHBvcnRhbCB3ZSBzaG91bGQgY2xlYXIgdGhlIERPTS5cblx0ZWxzZSBpZiAoX3RoaXMuX3RlbXApIHtcblx0XHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHR9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFBvcnRhbGAgdG8gY29udGludWUgcmVuZGVyaW5nIHRoZSB2bm9kZSB0cmVlIGF0IGEgZGlmZmVyZW50IERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgRE9NIG5vZGUgdG8gY29udGludWUgcmVuZGVyaW5nIGluIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUG9ydGFsKHZub2RlLCBjb250YWluZXIpIHtcblx0Y29uc3QgZWwgPSBjcmVhdGVFbGVtZW50KFBvcnRhbCwgeyBfdm5vZGU6IHZub2RlLCBfY29udGFpbmVyOiBjb250YWluZXIgfSk7XG5cdGVsLmNvbnRhaW5lckluZm8gPSBjb250YWluZXI7XG5cdHJldHVybiBlbDtcbn1cbiIsImltcG9ydCB7XG5cdHJlbmRlciBhcyBwcmVhY3RSZW5kZXIsXG5cdGh5ZHJhdGUgYXMgcHJlYWN0SHlkcmF0ZSxcblx0b3B0aW9ucyxcblx0dG9DaGlsZEFycmF5LFxuXHRDb21wb25lbnRcbn0gZnJvbSAncHJlYWN0JztcblxuZXhwb3J0IGNvbnN0IFJFQUNUX0VMRU1FTlRfVFlQRSA9XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmIFN5bWJvbC5mb3IgJiYgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuXHQweGVhYzc7XG5cbmNvbnN0IENBTUVMX1BST1BTID0gL14oPzphY2NlbnR8YWxpZ25tZW50fGFyYWJpY3xiYXNlbGluZXxjYXB8Y2xpcCg/IVBhdGhVKXxjb2xvcnxkb21pbmFudHxmaWxsfGZsb29kfGZvbnR8Z2x5cGgoPyFSKXxob3JpenxpbWFnZXxsZXR0ZXJ8bGlnaHRpbmd8bWFya2VyKD8hSHxXfFUpfG92ZXJsaW5lfHBhaW50fHBvaW50ZXJ8c2hhcGV8c3RvcHxzdHJpa2V0aHJvdWdofHN0cm9rZXx0ZXh0KD8hTCl8dHJhbnNmb3JtfHVuZGVybGluZXx1bmljb2RlfHVuaXRzfHZ8dmVjdG9yfHZlcnR8d29yZHx3cml0aW5nfHgoPyFDKSlbQS1aXS87XG5cbmNvbnN0IElTX0RPTSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIElucHV0IHR5cGVzIGZvciB3aGljaCBvbmNoYW5nZSBzaG91bGQgbm90IGJlIGNvbnZlcnRlZCB0byBvbmlucHV0LlxuLy8gdHlwZT1cImZpbGV8Y2hlY2tib3h8cmFkaW9cIiwgcGx1cyBcInJhbmdlXCIgaW4gSUUxMS5cbi8vIChJRTExIGRvZXNuJ3Qgc3VwcG9ydCBTeW1ib2wsIHdoaWNoIHdlIHVzZSBoZXJlIHRvIHR1cm4gYHJhZGAgaW50byBgcmFgIHdoaWNoIG1hdGNoZXMgXCJyYW5nZVwiKVxuY29uc3Qgb25DaGFuZ2VJbnB1dFR5cGUgPSB0eXBlID0+XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBTeW1ib2woKSA9PSAnc3ltYm9sJ1xuXHRcdD8gL2ZpbHxjaGV8cmFkL2lcblx0XHQ6IC9maWx8Y2hlfHJhL2lcblx0KS50ZXN0KHR5cGUpO1xuXG4vLyBTb21lIGxpYnJhcmllcyBsaWtlIGByZWFjdC12aXJ0dWFsaXplZGAgZXhwbGljaXRseSBjaGVjayBmb3IgdGhpcy5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vLyBgVU5TQUZFXypgIGxpZmVjeWNsZSBob29rc1xuLy8gUHJlYWN0IG9ubHkgZXZlciBpbnZva2VzIHRoZSB1bnByZWZpeGVkIG1ldGhvZHMuXG4vLyBIZXJlIHdlIHByb3ZpZGUgYSBiYXNlIFwiZmFsbGJhY2tcIiBpbXBsZW1lbnRhdGlvbiB0aGF0IGNhbGxzIGFueSBkZWZpbmVkIFVOU0FGRV8gcHJlZml4ZWQgbWV0aG9kLlxuLy8gLSBJZiBhIGNvbXBvbmVudCBkZWZpbmVzIGl0cyBvd24gYGNvbXBvbmVudERpZE1vdW50KClgIChpbmNsdWRpbmcgdmlhIGRlZmluZVByb3BlcnR5KSwgdXNlIHRoYXQuXG4vLyAtIElmIGEgY29tcG9uZW50IGRlZmluZXMgYFVOU0FGRV9jb21wb25lbnREaWRNb3VudCgpYCwgYGNvbXBvbmVudERpZE1vdW50YCBpcyB0aGUgYWxpYXMgZ2V0dGVyL3NldHRlci5cbi8vIC0gSWYgYW55dGhpbmcgYXNzaWducyB0byBhbiBgVU5TQUZFXypgIHByb3BlcnR5LCB0aGUgYXNzaWdubWVudCBpcyBmb3J3YXJkZWQgdG8gdGhlIHVucHJlZml4ZWQgcHJvcGVydHkuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMTk0MVxuW1xuXHQnY29tcG9uZW50V2lsbE1vdW50Jyxcblx0J2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuXHQnY29tcG9uZW50V2lsbFVwZGF0ZSdcbl0uZm9yRWFjaChrZXkgPT4ge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwga2V5LCB7XG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzWydVTlNBRkVfJyArIGtleV07XG5cdFx0fSxcblx0XHRzZXQodikge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdlxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuXG4vKipcbiAqIFByb3h5IHJlbmRlcigpIHNpbmNlIFJlYWN0IHJldHVybnMgYSBDb21wb25lbnQgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVk5vZGUgdHJlZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50IERPTSBub2RlIHRvIHJlbmRlciB2bm9kZSB0cmVlIGludG9cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBPcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIHJlbmRlcmluZ1xuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudCB8IG51bGx9IFRoZSByb290IGNvbXBvbmVudCByZWZlcmVuY2Ugb3IgbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnQsIGNhbGxiYWNrKSB7XG5cdC8vIFJlYWN0IGRlc3Ryb3lzIGFueSBleGlzdGluZyBET00gbm9kZXMsIHNlZSAjMTcyN1xuXHQvLyAuLi5idXQgb25seSBvbiB0aGUgZmlyc3QgcmVuZGVyLCBzZWUgIzE4Mjhcblx0aWYgKHBhcmVudC5fY2hpbGRyZW4gPT0gbnVsbCkge1xuXHRcdHBhcmVudC50ZXh0Q29udGVudCA9ICcnO1xuXHR9XG5cblx0cHJlYWN0UmVuZGVyKHZub2RlLCBwYXJlbnQpO1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG5cblx0cmV0dXJuIHZub2RlID8gdm5vZGUuX2NvbXBvbmVudCA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKHZub2RlLCBwYXJlbnQsIGNhbGxiYWNrKSB7XG5cdHByZWFjdEh5ZHJhdGUodm5vZGUsIHBhcmVudCk7XG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblxuXHRyZXR1cm4gdm5vZGUgPyB2bm9kZS5fY29tcG9uZW50IDogbnVsbDtcbn1cblxubGV0IG9sZEV2ZW50SG9vayA9IG9wdGlvbnMuZXZlbnQ7XG5vcHRpb25zLmV2ZW50ID0gZSA9PiB7XG5cdGlmIChvbGRFdmVudEhvb2spIGUgPSBvbGRFdmVudEhvb2soZSk7XG5cdGUucGVyc2lzdCA9IGVtcHR5O1xuXHRlLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gaXNQcm9wYWdhdGlvblN0b3BwZWQ7XG5cdGUuaXNEZWZhdWx0UHJldmVudGVkID0gaXNEZWZhdWx0UHJldmVudGVkO1xuXHRyZXR1cm4gKGUubmF0aXZlRXZlbnQgPSBlKTtcbn07XG5cbmZ1bmN0aW9uIGVtcHR5KCkge31cblxuZnVuY3Rpb24gaXNQcm9wYWdhdGlvblN0b3BwZWQoKSB7XG5cdHJldHVybiB0aGlzLmNhbmNlbEJ1YmJsZTtcbn1cblxuZnVuY3Rpb24gaXNEZWZhdWx0UHJldmVudGVkKCkge1xuXHRyZXR1cm4gdGhpcy5kZWZhdWx0UHJldmVudGVkO1xufVxuXG5sZXQgY2xhc3NOYW1lRGVzY3JpcHRvciA9IHtcblx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRnZXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3M7XG5cdH1cbn07XG5cbmxldCBvbGRWTm9kZUhvb2sgPSBvcHRpb25zLnZub2RlO1xub3B0aW9ucy52bm9kZSA9IHZub2RlID0+IHtcblx0bGV0IHR5cGUgPSB2bm9kZS50eXBlO1xuXHRsZXQgcHJvcHMgPSB2bm9kZS5wcm9wcztcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzO1xuXG5cdC8vIG9ubHkgbm9ybWFsaXplIHByb3BzIG9uIEVsZW1lbnQgbm9kZXNcblx0aWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdGNvbnN0IG5vbkN1c3RvbUVsZW1lbnQgPSB0eXBlLmluZGV4T2YoJy0nKSA9PT0gLTE7XG5cdFx0bm9ybWFsaXplZFByb3BzID0ge307XG5cblx0XHRmb3IgKGxldCBpIGluIHByb3BzKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSBwcm9wc1tpXTtcblxuXHRcdFx0aWYgKElTX0RPTSAmJiBpID09PSAnY2hpbGRyZW4nICYmIHR5cGUgPT09ICdub3NjcmlwdCcpIHtcblx0XHRcdFx0Ly8gRW11bGF0ZSBSZWFjdCdzIGJlaGF2aW9yIG9mIG5vdCByZW5kZXJpbmcgdGhlIGNvbnRlbnRzIG9mIG5vc2NyaXB0IHRhZ3Mgb24gdGhlIGNsaWVudC5cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKGkgPT09ICd2YWx1ZScgJiYgJ2RlZmF1bHRWYWx1ZScgaW4gcHJvcHMgJiYgdmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBTa2lwIGFwcGx5aW5nIHZhbHVlIGlmIGl0IGlzIG51bGwvdW5kZWZpbmVkIGFuZCB3ZSBhbHJlYWR5IHNldFxuXHRcdFx0XHQvLyBhIGRlZmF1bHQgdmFsdWVcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRpID09PSAnZGVmYXVsdFZhbHVlJyAmJlxuXHRcdFx0XHQndmFsdWUnIGluIHByb3BzICYmXG5cdFx0XHRcdHByb3BzLnZhbHVlID09IG51bGxcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBpcyB0cmVhdGVkIGFzIGEgZmFsbGJhY2sgYHZhbHVlYCB3aGVuIGEgdmFsdWUgcHJvcCBpcyBwcmVzZW50IGJ1dCBudWxsL3VuZGVmaW5lZC5cblx0XHRcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgZm9yIEVsZW1lbnRzIHdpdGggbm8gdmFsdWUgcHJvcCBpcyB0aGUgc2FtZSBhcyB0aGUgRE9NIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eS5cblx0XHRcdFx0aSA9ICd2YWx1ZSc7XG5cdFx0XHR9IGVsc2UgaWYgKGkgPT09ICdkb3dubG9hZCcgJiYgdmFsdWUgPT09IHRydWUpIHtcblx0XHRcdFx0Ly8gQ2FsbGluZyBgc2V0QXR0cmlidXRlYCB3aXRoIGEgdHJ1dGh5IHZhbHVlIHdpbGwgbGVhZCB0byBpdCBiZWluZ1xuXHRcdFx0XHQvLyBwYXNzZWQgYXMgYSBzdHJpbmdpZmllZCB2YWx1ZSwgZS5nLiBgZG93bmxvYWQ9XCJ0cnVlXCJgLiBSZWFjdFxuXHRcdFx0XHQvLyBjb252ZXJ0cyBpdCB0byBhbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCwgb3RoZXJ3aXNlIHRoZSBhdHRyaWJ1dGVcblx0XHRcdFx0Ly8gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBmaWxlIG5hbWUgYW5kIHRoZSBmaWxlIHdpbGwgYmUgY2FsbGVkXG5cdFx0XHRcdC8vIFwidHJ1ZVwiIHVwb24gZG93bmxvYWRpbmcgaXQuXG5cdFx0XHRcdHZhbHVlID0gJyc7XG5cdFx0XHR9IGVsc2UgaWYgKC9vbmRvdWJsZWNsaWNrL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gJ29uZGJsY2xpY2snO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0L15vbmNoYW5nZSh0ZXh0YXJlYXxpbnB1dCkvaS50ZXN0KGkgKyB0eXBlKSAmJlxuXHRcdFx0XHQhb25DaGFuZ2VJbnB1dFR5cGUocHJvcHMudHlwZSlcblx0XHRcdCkge1xuXHRcdFx0XHRpID0gJ29uaW5wdXQnO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uZm9jdXMkL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gJ29uZm9jdXNpbic7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb25ibHVyJC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmZvY3Vzb3V0Jztcblx0XHRcdH0gZWxzZSBpZiAoL15vbihBbml8VHJhfFRvdXxCZWZvcmVJbnB8Q29tcG8pLy50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKG5vbkN1c3RvbUVsZW1lbnQgJiYgQ0FNRUxfUFJPUFMudGVzdChpKSkge1xuXHRcdFx0XHRpID0gaS5yZXBsYWNlKC9bQS1aMC05XS9nLCAnLSQmJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0dmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBzdXBwb3J0IGZvciBvbklucHV0IGFuZCBvbkNoYW5nZSwgc2VlICMzNTYxXG5cdFx0XHQvLyBpZiB3ZSBoYXZlIGFuIG9uaW5wdXQgcHJvcCBhbHJlYWR5IGNoYW5nZSBpdCB0byBvbmlucHV0Q2FwdHVyZVxuXHRcdFx0aWYgKC9eb25pbnB1dCQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGlmIChub3JtYWxpemVkUHJvcHNbaV0pIHtcblx0XHRcdFx0XHRpID0gJ29uaW5wdXRDYXB0dXJlJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgc3VwcG9ydCBmb3IgYXJyYXkgc2VsZWN0IHZhbHVlczogPHNlbGVjdCBtdWx0aXBsZSB2YWx1ZT17W119IC8+XG5cdFx0aWYgKFxuXHRcdFx0dHlwZSA9PSAnc2VsZWN0JyAmJlxuXHRcdFx0bm9ybWFsaXplZFByb3BzLm11bHRpcGxlICYmXG5cdFx0XHRBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSlcblx0XHQpIHtcblx0XHRcdC8vIGZvckVhY2goKSBhbHdheXMgcmV0dXJucyB1bmRlZmluZWQsIHdoaWNoIHdlIGFidXNlIGhlcmUgdG8gdW5zZXQgdGhlIHZhbHVlIHByb3AuXG5cdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUgPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkaW5nIHN1cHBvcnQgZm9yIGRlZmF1bHRWYWx1ZSBpbiBzZWxlY3QgdGFnXG5cdFx0aWYgKHR5cGUgPT0gJ3NlbGVjdCcgJiYgbm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUgPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRpZiAobm9ybWFsaXplZFByb3BzLm11bHRpcGxlKSB7XG5cdFx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZS5pbmRleE9mKGNoaWxkLnByb3BzLnZhbHVlKSAhPSAtMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlID09IGNoaWxkLnByb3BzLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2bm9kZS5wcm9wcyA9IG5vcm1hbGl6ZWRQcm9wcztcblxuXHRcdGlmIChwcm9wcy5jbGFzcyAhPSBwcm9wcy5jbGFzc05hbWUpIHtcblx0XHRcdGNsYXNzTmFtZURlc2NyaXB0b3IuZW51bWVyYWJsZSA9ICdjbGFzc05hbWUnIGluIHByb3BzO1xuXHRcdFx0aWYgKHByb3BzLmNsYXNzTmFtZSAhPSBudWxsKSBub3JtYWxpemVkUHJvcHMuY2xhc3MgPSBwcm9wcy5jbGFzc05hbWU7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsaXplZFByb3BzLCAnY2xhc3NOYW1lJywgY2xhc3NOYW1lRGVzY3JpcHRvcik7XG5cdFx0fVxuXHR9XG5cblx0dm5vZGUuJCR0eXBlb2YgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cblx0aWYgKG9sZFZOb2RlSG9vaykgb2xkVk5vZGVIb29rKHZub2RlKTtcbn07XG5cbi8vIE9ubHkgbmVlZGVkIGZvciByZWFjdC1yZWxheVxubGV0IGN1cnJlbnRDb21wb25lbnQ7XG5jb25zdCBvbGRCZWZvcmVSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5vcHRpb25zLl9yZW5kZXIgPSBmdW5jdGlvbih2bm9kZSkge1xuXHRpZiAob2xkQmVmb3JlUmVuZGVyKSB7XG5cdFx0b2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblx0fVxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcbn07XG5cbi8vIFRoaXMgaXMgYSB2ZXJ5IHZlcnkgcHJpdmF0ZSBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgUmVhY3QgaXRcbi8vIGlzIHVzZWQgdG8gc29ydC1vZiBkbyBydW50aW1lIGRlcGVuZGVuY3kgaW5qZWN0aW9uLiBTbyBmYXJcbi8vIG9ubHkgYHJlYWN0LXJlbGF5YCBtYWtlcyB1c2Ugb2YgaXQuIEl0IHVzZXMgaXQgdG8gcmVhZCB0aGVcbi8vIGNvbnRleHQgdmFsdWUuXG5leHBvcnQgY29uc3QgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSB7XG5cdFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IHtcblx0XHRjdXJyZW50OiB7XG5cdFx0XHRyZWFkQ29udGV4dChjb250ZXh0KSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50Q29tcG9uZW50Ll9nbG9iYWxDb250ZXh0W2NvbnRleHQuX2lkXS5wcm9wcy52YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG4iLCJpbXBvcnQgeyBDb21wb25lbnRUeXBlLCBoLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XG5cbmV4cG9ydCB0eXBlIFJlZkZyb21UYWc8VCBleHRlbmRzIGtleW9mIGguSlNYLkludHJpbnNpY0VsZW1lbnRzPiA9IE5vbk51bGxhYmxlPGguSlNYLkludHJpbnNpY0VsZW1lbnRzW1RdW1wicmVmXCJdPiAmIFJlZjxhbnk+O1xuZXhwb3J0IHR5cGUgRWxlbWVudEZyb21SZWY8UiBleHRlbmRzIFJlZjxhbnk+PiA9IFIgZXh0ZW5kcyBSZWY8aW5mZXIgRT4gPyBFIDogRXZlbnRUYXJnZXQ7XG5leHBvcnQgdHlwZSBFbGVtZW50RnJvbVRhZzxUIGV4dGVuZHMga2V5b2YgaC5KU1guSW50cmluc2ljRWxlbWVudHM+ID0gRWxlbWVudEZyb21SZWY8UmVmRnJvbVRhZzxUPj47XG5cbmV4cG9ydCB0eXBlIEVsZW1lbnRUb1RhZzxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gKGtleW9mIFN1YlR5cGU8SFRNTEVsZW1lbnRUYWdOYW1lTWFwLCBFPik7Ly8gJiAoa2V5b2YgaC5KU1guSW50cmluc2ljRWxlbWVudHMpO1xudHlwZSBTdWJUeXBlPEJhc2UsIENvbmRpdGlvbj4gPSBQaWNrPEJhc2UsIHtcbiAgICBbS2V5IGluIGtleW9mIEJhc2VdOiBCYXNlW0tleV0gZXh0ZW5kcyBDb25kaXRpb24gPyBLZXkgOiBuZXZlclxufVtrZXlvZiBCYXNlXT47XG5cbmV4cG9ydCB0eXBlIERpc2FibGVkVHlwZSA9IGJvb2xlYW4gfCBcInNvZnRcIiB8IFwiaGFyZFwiO1xuXG5leHBvcnQgdHlwZSBQcm9wc09mVHlwZTxUPiA9XG4gICAgVCBleHRlbmRzIGtleW9mIGguSlNYLkludHJpbnNpY0VsZW1lbnRzID8gaC5KU1guSW50cmluc2ljRWxlbWVudHNbVF0gOiBcbiAgICBUIGV4dGVuZHMgQ29tcG9uZW50VHlwZTxpbmZlciBQPj8gUCA6IG5ldmVyO1xuXG4vKipcbiAqIEZvciB0aW1lcyB3aGVuIG1vcmUgdGhhbiBqdXN0IHRoZSBhYnN0cmFjdCBlbGVtZW50IHR5cGUgaXMgbmVlZGVkLFxuICogYnV0IHRoZSBhY3R1YWwsIGNvbmNyZXRlLCBpbXBsZW1lbnRhdGlvbi1hZmZlY3RpbmcgXCJkaXZcIiBzdHJpbmcgdHlwZS5cbiAqIFxuICogVE9ETzogU2hvdWxkIHRoaXMgYmUgdGhlIHN0YW5kYXJkIGZvciBhbGwgdGhlIG5vbi1BUklBIGhvb2tzP1xuICogVGhleSAqbmV2ZXIqIGNhcmUgYWJvdXQgdGhlIHNwZWNpZmljIHR5cGUgZm9yIHRoZSBpbXBsZW1lbnRhdGlvbixcbiAqIGp1c3QgZm9yIHR5cGluZywgc28gaXQgd291bGRuJ3QgYmUgbmVjZXNzYXJ5LCBcbiAqIGJ1dCBpdCB3b3VsZCBiZSBjb25zaXN0ZW50IHdpdGggdGhlc2UgQVJJQSBob29rcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUYWdTZW5zaXRpdmVQcm9wczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcbiAgICB0YWc6IEVsZW1lbnRUb1RhZzxFPjtcbn1cblxuZXhwb3J0IGNvbnN0IEV2ZW50RGV0YWlsID0gU3ltYm9sKFwiZXZlbnQtZGV0YWlsXCIpO1xuZXhwb3J0IHR5cGUgRXZlbnREZXRhaWwgPSB0eXBlb2YgRXZlbnREZXRhaWw7XG5leHBvcnQgdHlwZSBFbmhhbmNlZEV2ZW50PFRhcmdldCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUeXBlZEV2ZW50IGV4dGVuZHMgRXZlbnQsIERldGFpbD4gPSBoLkpTWC5UYXJnZXRlZEV2ZW50PFRhcmdldCwgVHlwZWRFdmVudD4gJiB7XG4gICAgW0V2ZW50RGV0YWlsXTogRGV0YWlsO1xufTtcblxuXG5leHBvcnQgZnVuY3Rpb24gZW5oYW5jZUV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVHlwZWRFdmVudCBleHRlbmRzIEV2ZW50LCBEZXRhaWwgZXh0ZW5kcyBvYmplY3Q+KGU6IFR5cGVkRXZlbnQgfCBoLkpTWC5UYXJnZXRlZEV2ZW50PEUsIFR5cGVkRXZlbnQ+LCBkZXRhaWw6IERldGFpbCk6IEVuaGFuY2VkRXZlbnQ8RSwgVHlwZWRFdmVudCwgRGV0YWlsPiB7XG4gICAgY29uc3QgZXZlbnQgPSBlIGFzIHVua25vd24gYXMgRW5oYW5jZWRFdmVudDxFLCBUeXBlZEV2ZW50LCBEZXRhaWw+O1xuICAgIGV2ZW50W0V2ZW50RGV0YWlsXSA9IGRldGFpbDtcbiAgICByZXR1cm4gZXZlbnQ7XG59XG5cblxuY29uc3QgYWxyZWFkeVdhcm5lZCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcndyaXRlV2l0aFdhcm5pbmc8UCBleHRlbmRzIHt9LCBLIGV4dGVuZHMga2V5b2YgUD4oY29tcG9uZW50TmFtZTogc3RyaW5nLCBwcm9wczogUCwgcHJvcE5hbWU6IEssIG5ld1ZhbHVlOiBQW0tdKTogdm9pZCB7XG4gICAgLy9jb25zdCBrZXkgPSBgJHtjb21wb25lbnROYW1lfTske3Byb3BOYW1lfWA7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKG9sZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCFhbHJlYWR5V2FybmVkLmhhcyhTdHJpbmcocHJvcE5hbWUpKSkge1xuICAgICAgICAgICAgYWxyZWFkeVdhcm5lZC5hZGQoU3RyaW5nKHByb3BOYW1lKSk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSAke1N0cmluZyhwcm9wTmFtZSl9IGF0dHJpYnV0ZSBvbiAke2NvbXBvbmVudE5hbWV9IHdhcyBnaXZlbiBhIHZhbHVlIG9mICR7b2xkVmFsdWV9IGJ1dCBpcyBiZWluZyBvdmVyd3JpdHRlbiB0byAke25ld1ZhbHVlfSBmb3IgY29uZm9ybWFuY2UuIENvbnNpZGVyIHJlbW92aW5nIGl0IGJlZm9yZSBwYXNzaW5nIHRob3NlIHByb3BzIHRvICR7Y29tcG9uZW50TmFtZX0uYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wc1twcm9wTmFtZV0gPSBuZXdWYWx1ZTtcbn1cblxubGV0IGRlYnVnID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gc2V0RGVidWdMb2dnaW5nKGxvZ2dpbmc6IGJvb2xlYW4pIHtcbiAgICBkZWJ1ZyA9IGxvZ2dpbmc7XG59XG5cbmV4cG9ydCB0eXBlIERlYnVnTG9nVHlwZXMgPVxuICAgIFwidXNlQWNjb3JkaWFuXCIgfCBcInVzZUFjY29yZGlhblNlY3Rpb25cIiB8XG4gICAgXCJ1c2VCdXR0b25cIiB8XG4gICAgXCJ1c2VDaGVja2JveFwiIHxcbiAgICBcInVzZUNoZWNrYm94R3JvdXBcIiB8IFwidXNlQ2hlY2tib3hHcm91cFBhcmVudFwiIHwgXCJ1c2VDaGVja2JveEdyb3VwQ2hpbGRcIiB8XG4gICAgXCJ1c2VEaWFsb2dcIiB8IFwidXNlRHJhd2VyXCIgfFxuICAgIFwidXNlTGlzdGJveE11bHRpXCIgfCBcInVzZUxpc3Rib3hNdWx0aUl0ZW1cIiB8XG4gICAgXCJ1c2VMaXN0Ym94U2luZ2xlXCIgfCBcInVzZUxpc3Rib3hTaW5nbGVJdGVtXCIgfFxuICAgIFwidXNlTWVudWJhclwiIHwgXCJ1c2VNZW51XCIgfCBcInVzZU1lbnVTdXJmYWNlXCIgfCBcInVzZU1lbnVJdGVtXCIgfCBcInVzZUZvY3VzU2VudGluZWxcIiB8IFwidXNlTWVudVN1cmZhY2VTZW50aW5lbFwiIHxcbiAgICBcInVzZVJhZGlvR3JvdXBcIiB8IFwidXNlUmFkaW9cIiB8XG4gICAgXCJ1c2VTbGlkZXJcIiB8IFwidXNlU2xpZGVyVGh1bWJcIiB8XG4gICAgXCJ1c2VUYWJsZVwiIHwgXCJ1c2VUYWJsZVJvd1wiIHwgXCJ1c2VUYWJsZUNlbGxcIiB8IFwidXNlVGFibGVCb2R5XCIgfFxuICAgIFwidXNlR3JpZGxpc3RcIiB8IFwidXNlR3JpZGxpc3RSb3dcIiB8IFwidXNlR3JpZGxpc3RDaGlsZFwiIHwgXCJ1c2VHcmlkbGlzdFNlY3Rpb25cIiB8XG4gICAgXCJ1c2VUYWJzXCIgfCBcInVzZVRhYkxpc3RcIiB8IFwidXNlVGFiXCIgfCBcInVzZVRhYlBhbmVsXCIgfFxuICAgIFwidXNlVG9hc3RzXCIgfCBcInVzZVRvYXN0XCIgfFxuICAgIFwidXNlVG9vbHRpcFwiIHwgXCJ1c2VUb29sdGlwVG9vbHRpcFwiIHwgXCJ1c2VUb29sdGlwVHJpZ2dlclwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVidWdMb2cod2hvOiBEZWJ1Z0xvZ1R5cGVzLCAuLi5hcmdzOiBQYXJhbWV0ZXJzPCh0eXBlb2YgY29uc29sZSlbXCJsb2dcIl0+KSB7XG4gICAgaWYgKGRlYnVnKVxuICAgICAgICBjb25zb2xlLmRlYnVnKHdobyArIFwiOlwiLCAuLi5hcmdzKTtcbn1cblxuZXhwb3J0IHR5cGUgUHJvcE1vZGlmaWVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcbmV4cG9ydCB0eXBlIFByb3BNb2RpZmllcjI8UD4gPSAocHJvcHM6IFApID0+IFA7XG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpOiB2b2lkIHsgcmV0dXJuOyB9XG5cbi8vIChUaGVzZSBkbyBub3QgbmVlZCB0byBiZSB1bmlxdWUpXG5leHBvcnQgY29uc3QgUHJlZmljZXMgPSB7XG4gICAgYWNjb3JkaW9uU2VjdGlvbkhlYWRlckJ1dHRvbjogXCJhc2hiLVwiLFxuICAgIGFjY29yZGlvblNlY3Rpb25Cb2R5OiBcImFzYi1cIixcbiAgICBjaGVja2JveExpa2VJbnB1dDogXCJjYmxpLVwiLFxuICAgIGNoZWNrYm94TGlrZUxhYmVsOiBcImNibGwtXCIsXG4gICAgZGlhbG9nOiBcIm1kbC1cIixcbiAgICBkaWFsb2dUaXRsZTogXCJtZGx0LVwiLFxuICAgIGRyYXdlcjogXCJtZHctXCIsXG4gICAgZHJhd2VyVGl0bGU6IFwibWR3dC1cIixcbiAgICBncmlkbGlzdDogXCJnbC1cIixcbiAgICBncmlkbGlzdExhYmVsOiBcImdsbC1cIixcbiAgICBsaXN0Ym94OiBcImxiLVwiLFxuICAgIGxpc3Rib3hMYWJlbDogXCJsYmwtXCIsXG4gICAgbWVudTogXCJtZW51LVwiLFxuICAgIHByb2dyZXNzSW5kaWNhdG9yOiBcInBpLVwiLFxuICAgIHByb2dyZXNzTGFiZWw6IFwicGwtXCIsXG4gICAgcmFkaW9Hcm91cDogXCJyZy1cIixcbiAgICByYWRpb0dyb3VwTGFiZWw6IFwicmdsLVwiLFxuICAgIHJhZGlvOiBcInJiLVwiLFxuICAgIHJhZGlvTGFiZWw6IFwicmJsLVwiLFxuICAgIHNsaWRlclRodW1iOiBcInN0LVwiLFxuICAgIHRhYmxlOiBcInRiLVwiLFxuICAgIHRhYmxlTGFiZWw6IFwidGJsLVwiLFxuICAgIHRhYmxpc3Q6IFwidGwtXCIsXG4gICAgdGFibGlzdExhYmVsOiBcInRsbC1cIixcbiAgICB0b29sdGlwOiBcInR0LVwiXG59IGFzIGNvbnN0XG4iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgUmVuZGVyYWJsZVByb3BzIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBvdmVyd3JpdGVXaXRoV2FybmluZyB9IGZyb20gXCIuLi9wcm9wc1wiO1xuXG5jb25zdCBIZWFkaW5nTGV2ZWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgwKTtcblxuZXhwb3J0IGludGVyZmFjZSBIZWFkaW5nUHJvcHM8VCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgUmVuZGVyYWJsZVByb3BzPGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+PiB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnRlbnRzIG9mIHRoZSBoZWFkaW5nLlxuICAgICAqIFxuICAgICAqIFNlcGFyYXRlIGZyb20gdGhlIGNoaWxkcmVuLCB3aGljaCBiZWNvbWUgdGhlIGNvbnRlbnQgZGVzY3JpYmVkIGJ5IHRoaXMgaGVhZGluZy5cbiAgICAgKi9cbiAgICBoZWFkaW5nOiBDb21wb25lbnRDaGlsZHJlbjtcblxuICAgIHRhZz86IEVsZW1lbnRUb1RhZzxUPjtcbn1cblxuZXhwb3J0IGNvbnN0IEhlYWRpbmcgPSBtZW1vKGZ1bmN0aW9uIEhlYWRpbmc8VCBleHRlbmRzIEVsZW1lbnQ+KHsgY2hpbGRyZW4sIGhlYWRpbmcsIHRhZywgLi4ucHJvcHMgfTogSGVhZGluZ1Byb3BzPFQ+KSB7XG4gICAgY29uc3QgaGVhZGluZ0xldmVsQmVmb3JlVXMgPSB1c2VDb250ZXh0KEhlYWRpbmdMZXZlbENvbnRleHQpO1xuICAgIGNvbnN0IG5ld0hlYWRpbmdMZXZlbCA9IGhlYWRpbmdMZXZlbEJlZm9yZVVzICsgMTtcblxuICAgIGlmICh0YWcgPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV3SGVhZGluZ0xldmVsIDw9IDYpIHtcbiAgICAgICAgICAgIHRhZyA9IGBoJHtuZXdIZWFkaW5nTGV2ZWx9YCBhcyBuZXZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhZyA9ICdkaXYnIGFzIG5ldmVyO1xuICAgICAgICAgICAgb3ZlcndyaXRlV2l0aFdhcm5pbmcoXCJIZWFkaW5nXCIsIHByb3BzLCBcImFyaWEtbGV2ZWxcIiwgYCR7bmV3SGVhZGluZ0xldmVsfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxIZWFkaW5nUmVzZXQgbmV3TGV2ZWw9e2hlYWRpbmdMZXZlbEJlZm9yZVVzICsgMX0+XG4gICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnIGFzIGFueSwgcHJvcHMsIGhlYWRpbmcpfVxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgIDwvSGVhZGluZ1Jlc2V0PlxuICAgICAgICA8Lz5cbiAgICApXG59KVxuXG5leHBvcnQgY29uc3QgSGVhZGluZ1Jlc2V0ID0gbWVtbyhmdW5jdGlvbiBIZWFkaW5nUmVzZXQoeyBuZXdMZXZlbCwgY2hpbGRyZW4gfTogeyBuZXdMZXZlbDogbnVtYmVyLCBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4gfSkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxIZWFkaW5nTGV2ZWxDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtuZXdMZXZlbH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvSGVhZGluZ0xldmVsQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59KVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gXCJwcmVhY3RcIlxuXG4vKiogVGFrZXMgYSBuZXcgdmFsdWUgb3IgYSBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgYSB2YWx1ZSwgdW5saWtlIGBPblBhc3NpdmVTdGF0ZUNoYW5nZWAgd2hpY2ggcmVhY3RzIHRvIHRob3NlIHVwZGF0ZXMgKi9cbmV4cG9ydCB0eXBlIFBhc3NpdmVTdGF0ZVVwZGF0ZXI8UywgUj4gPSAoKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpLCByZWFzb24/OiBSKSA9PiB2b2lkKTsvL1tSXSBleHRlbmRzIFtuZXZlcl0/ICgodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUyksIHJlYXNvbj86IFIpID0+IHZvaWQpIDogKCh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSwgcmVhc29uOiBSKSA9PiB2b2lkKTtcbi8qKiBSZXNwb25kcyB0byBhIGNoYW5nZSBpbiBhIHZhbHVlLCB1bmxpa2UgYFBhc3NpdmVTdGF0ZVVwZGF0ZXJgIHdoaWNoIGNhdXNlcyB0aGUgdXBkYXRlcyAqL1xuZXhwb3J0IHR5cGUgT25QYXNzaXZlU3RhdGVDaGFuZ2U8UywgUj4gPSAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbj86IFIpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSk7Ly9bUl0gZXh0ZW5kcyBbbmV2ZXJdPyAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbj86IFIpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSkgOiAoKHZhbHVlOiBTLCBwcmV2VmFsdWU6IFMgfCB1bmRlZmluZWQsIHJlYXNvbjogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTtcblxuXG5cbi8qKlxuICogRGVidWcgaG9vay5cbiAqIFxuICogR2l2ZW4gYSB2YWx1ZSBvciBzZXQgb2YgdmFsdWVzLCBlbWl0cyBhIGNvbnNvbGUgZXJyb3IgaWYgYW55IG9mIHRoZW0gY2hhbmdlIGZyb20gb25lIHJlbmRlciB0byB0aGUgbmV4dC5cbiAqIFxuICogRXZlbnR1YWxseSwgd2hlbiB1c2VFdmVudCBsYW5kcywgd2UgaG9wZWZ1bGx5IHdvbid0IG5lZWQgdGhpcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVuc3VyZVN0YWJpbGl0eTxUIGV4dGVuZHMgYW55W10+KHBhcmVudEhvb2tOYW1lOiBzdHJpbmcsIC4uLnZhbHVlczogVCkge1xuICAgIGNvbnN0IGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5ID0gdXNlUmVmPEFycmF5PFQ+PihbXSk7XG4gICAgY29uc3Qgc2hvd25FcnJvciA9IHVzZVJlZjxBcnJheTxib29sZWFuPj4oW10pO1xuICAgIHVzZUhlbHBlcih2YWx1ZXMubGVuZ3RoIGFzIGFueSwgLTEpO1xuICAgIHZhbHVlcy5mb3JFYWNoKHVzZUhlbHBlcik7XG4gICAgcmV0dXJuO1xuXG5cbiAgICBmdW5jdGlvbiB1c2VIZWxwZXI8VSBleHRlbmRzIFQ+KHZhbHVlOiBVLCBpOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpICsgMTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgICAgIGlmIChoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50W2luZGV4XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgICBpZiAoaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudFtpbmRleF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghc2hvd25FcnJvci5jdXJyZW50W2luZGV4XSkge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVGhlIGhvb2sgJHtwYXJlbnRIb29rTmFtZX0gcmVxdWlyZXMgc29tZSBvciBhbGwgb2YgaXRzIGFyZ3VtZW50cyByZW1haW4gc3RhYmxlIGFjcm9zcyBlYWNoIHJlbmRlcjsgcGxlYXNlIGNoZWNrIHRoZSAke2l9LWluZGV4ZWQgYXJndW1lbnQgKCR7aSA+PSAwPyBKU09OLnN0cmluZ2lmeSh2YWx1ZXNbaV0pIDogXCJ0aGUgbnVtYmVyIG9mIHN1cHBvc2VkbHkgc3RhYmxlIGVsZW1lbnRzXCJ9KS5gKTtcbiAgICAgICAgICAgICAgICBzaG93bkVycm9yLmN1cnJlbnRbaW5kZXhdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlUmVuZGVyaW5nKGY6ICgpID0+IHZvaWQpIHtcbiAgICAob3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA/PyBzZXRUaW1lb3V0KShmKTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGB1c2VTdGF0ZWAsIGJ1dCBmb3IgdmFsdWVzIHRoYXQgYXJlbid0IFwicmVuZGVyLWltcG9ydGFudFwiICZuZGFzaDsgdXBkYXRlcyBkb24ndCBjYXVzZSBhIHJlLXJlbmRlciBhbmQgc28gdGhlIHZhbHVlIHNob3VsZG4ndCBiZSB1c2VkIGR1cmluZyByZW5kZXIgKHRob3VnaCBpdCBjZXJ0YWlubHkgY2FuLCBhdCBsZWFzdCBieSByZS1yZW5kZXJpbmcgYWdhaW4pLlxuICogXG4gKiBUbyBjb21wZW5zYXRlIGZvciB0aGlzLCB5b3Ugc2hvdWxkIHBhc3MgYSBgdXNlRWZmZWN0YC1lc3F1ZSBjYWxsYmFjayB0aGF0IGlzIHJ1biB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcy4gIEp1c3QgbGlrZSBgdXNlRWZmZWN0YCwgdGhpcyBjYWxsYmFjayBjYW4gcmV0dXJuIGEgY2xlYW51cCBmdW5jdGlvbiB0aGF0J3MgcnVuIGJlZm9yZSB0aGUgdmFsdWUgY2hhbmdlcy4gIElmIHlvdSB3b3VsZCBsaWtlIHRvIHJlLXJlbmRlciB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIChvciwgc2F5LCB3aGVuIHRoZSB2YWx1ZSBtZWV0cyBzb21lIGNyaXRlcmlhKSwgdGhpcyBpcyB3aGVyZSB5b3UnbGwgd2FudCB0byBwdXQgaW4gYSBjYWxsIHRvIGEgYHNldFN0YXRlYCBmdW5jdGlvbi5cbiAqIFxuICogVG8gc3VtbWFyaXplLCBpdCdzIGxpa2UgYSBgdXNlU3RhdGVgLWB1c2VFZmZlY3RgIG1hc2h1cDpcbiAqIFxuICogMS4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB0aGlzIHZlcnNpb24gb2YgYHNldFN0YXRlYCBkb2Vzbid0IHJlLXJlbmRlciB0aGUgd2hvbGUgY29tcG9uZW50XG4gKiAyLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHlvdSBjYW4gcnVuIGEgZnVuY3Rpb24gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyB0aGF0IG9wdGlvbmFsbHkgcmV0dXJucyBhIGNsZWFudXAgZnVuY3Rpb25cbiAqIDMuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHlvdSB0cmlnZ2VyIHRoZSBlZmZlY3QgZnVuY3Rpb24gXCJyZW1vdGVseVwiIGluc3RlYWQgb2YgaXQgcnVubmluZyBhZnRlciByZW5kZXJpbmdcbiAqIDQuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHRoZSBzaW5nbGUgXCJkZXBlbmRlbmN5XCIgaXMgYmFzZWQgb24geW91ciBjYWxscyB0byBgc2V0U3RhdGVgXG4gKiBcbiAqIE5vdGUgdGhhdCB3aGlsZSBjYWxsaW5nIGBzZXRTdGF0ZWAgZG9lc24ndCBjYXVzZSBhbnkgcmUtcmVuZGVycywgeW91IGNhbiBkbyB0aGF0IHdpdGhpbiB5b3VyIGBvbkNoYW5nZWAgZnVuY3Rpb24sIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcyB2aWEgdGhhdCBgc2V0U3RhdGVgLlxuICogXG4gKiBAcGFyYW0gb25DaGFuZ2UgVGhlIFwiZWZmZWN0XCIgZnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuIEVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIGB1c2VFZmZlY3RgJ3MgXCJlZmZlY3RcIiBmdW5jdGlvbi4gIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXG4gKiBAcGFyYW0gZ2V0SW5pdGlhbFZhbHVlIElmIHByb3ZpZGVkLCB0aGUgZWZmZWN0IHdpbGwgYmUgaW52b2tlZCBvbmNlIHdpdGggdGhpcyB2YWx1ZSBvbiBtb3VudC4gTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyBCeSBkZWZhdWx0LCBjaGFuZ2VzIHRvIHBhc3NpdmUgc3RhdGUgYXJlIGRlbGF5ZWQgYnkgb25lIHRpY2sgc28gdGhhdCB3ZSBvbmx5IGNoZWNrIGZvciBjaGFuZ2VzIGluIGEgc2ltaWxhciB3YXkgdG8gUHJlYWN0LiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgdG8sIGZvciBleGFtcGxlLCBhbHdheXMgcnVuIGltbWVkaWF0ZWx5IGluc3RlYWQuXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhc3NpdmVTdGF0ZTxULCBSPihvbkNoYW5nZTogdW5kZWZpbmVkIHwgbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQsIFI+LCBnZXRJbml0aWFsVmFsdWU/OiAoKSA9PiBULCBjdXN0b21EZWJvdW5jZVJlbmRlcmluZz86IHR5cGVvZiBkZWJvdW5jZVJlbmRlcmluZyk6IHJlYWRvbmx5IFtnZXRTdGF0ZVN0YWJsZTogKCkgPT4gVCwgc2V0U3RhdGVTdGFibGU6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj5dIHtcblxuICAgIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmPFQgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcbiAgICBjb25zdCByZWFzb25SZWYgPSB1c2VSZWY8UiB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0ID0gdXNlUmVmPFQgfCAodHlwZW9mIFVuc2V0KT4oVW5zZXQpO1xuICAgIGNvbnN0IGNsZWFudXBDYWxsYmFja1JlZiA9IHVzZVJlZjx1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk+KHVuZGVmaW5lZCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUGFzc2l2ZVN0YXRlXCIsIG9uQ2hhbmdlLCBnZXRJbml0aWFsVmFsdWUsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIFwiZGVwZW5kZW5jeSBjaGFuZ2VkXCIgYW5kIFwiY29tcG9uZW50IHVubW91bnRlZFwiLlxuICAgIGNvbnN0IG9uU2hvdWxkQ2xlYW5VcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cENhbGxiYWNrID0gY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChjbGVhbnVwQ2FsbGJhY2spXG4gICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2soKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGVyZSBhcmUgYSBjb3VwbGUgcGxhY2VzIHdoZXJlIHdlJ2QgbGlrZSB0byB1c2Ugb3VyIGluaXRpYWxcbiAgICAvLyB2YWx1ZSBpbiBwbGFjZSBvZiBoYXZpbmcgbm8gdmFsdWUgYXQgYWxsIHlldC5cbiAgICAvLyBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZSBmb3IgdGhhdCwgdXNlZCBvbiBtb3VudCBhbmQgd2hlbmV2ZXJcbiAgICAvLyBnZXRWYWx1ZSBpcyBjYWxsZWQuXG4gICAgY29uc3QgdHJ5RW5zdXJlVmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCAmJiBnZXRJbml0aWFsVmFsdWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldEluaXRpYWxWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/Lihpbml0aWFsVmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkISkgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbnMgYXJlIGludGVudGlvbmFsIHRvIGFsbG93IGJhaWxvdXQgKHdpdGhvdXQgZXhwb3NpbmcgdGhlIFVuc2V0IHN5bWJvbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFsvKiBnZXRJbml0aWFsVmFsdWUgYW5kIG9uQ2hhbmdlIGludGVudGlvbmFsbHkgb21pdHRlZCAqL10pO1xuXG5cbiAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHdhcm5pbmdSZWYuY3VycmVudClcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkR1cmluZyBvbkNoYW5nZSwgcHJlZmVyIHVzaW5nIHRoZSAodmFsdWUsIHByZXZWYWx1ZSkgYXJndW1lbnRzIGluc3RlYWQgb2YgZ2V0VmFsdWUgLS0gaXQncyBhbWJpZ3VvdXMgYXMgdG8gaWYgeW91J3JlIGFza2luZyBmb3IgdGhlIG9sZCBvciBuZXcgdmFsdWUgYXQgdGhpcyBwb2ludCBpbiB0aW1lIGZvciB0aGlzIGNvbXBvbmVudC5cIik7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2UgY2FsbCBnZXRWYWx1ZSwgaWYgd2UgaGF2ZW4ndCBiZWVuIGdpdmVuIGEgdmFsdWUgeWV0LFxuICAgICAgICAvLyAoYW5kIHdlIHdlcmUgZ2l2ZW4gYW4gaW5pdGlhbCB2YWx1ZSB0byB1c2UpXG4gICAgICAgIC8vIHJldHVybiB0aGUgaW5pdGlhbCB2YWx1ZSBpbnN0ZWFkIG9mIG5vdGhpbmcuXG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldClcbiAgICAgICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCEgOiB2YWx1ZVJlZi5jdXJyZW50ISkgYXMgVDtcbiAgICB9LCBbXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UndmUgcnVuIG91ciBlZmZlY3QgYXQgbGVhc3Qgb25jZSBvbiBtb3VudC5cbiAgICAgICAgLy8gKElmIHdlIGhhdmUgYW4gaW5pdGlhbCB2YWx1ZSwgb2YgY291cnNlKVxuICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuXG5cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGUgYWN0dWFsIGNvZGUgdGhlIHVzZXIgY2FsbHMgdG8gKHBvc3NpYmx5KSBydW4gYSBuZXcgZWZmZWN0LlxuICAgIGNvbnN0IHNldFZhbHVlID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj4+WzFdKSA9PiB7XG5cbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiBhbnl0aGluZyBlbHNlLCBmaWd1cmUgb3V0IHdoYXQgb3VyIG5leHQgdmFsdWUgaXMgYWJvdXQgdG8gYmUuXG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IChhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCA6IHZhbHVlUmVmLmN1cnJlbnQpIDogYXJnKTtcblxuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ID09PSBVbnNldCAmJiBuZXh0VmFsdWUgIT09IHZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlcXVlc3QgdG8gY2hhbmdlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgcmVxdWVzdCBpbW1lZGlhdGVseSwgdGhlbiBxdWV1ZSB1cCB0aGUgb25DaGFuZ2UgZnVuY3Rpb25cblxuICAgICAgICAgICAgLy8gU2F2ZSBvdXIgY3VycmVudCB2YWx1ZSBzbyB0aGF0IHdlIGNhbiBjb21wYXJlIGFnYWluc3QgaXQgbGF0ZXJcbiAgICAgICAgICAgIC8vIChpZiB3ZSBmbGlwIGJhY2sgdG8gdGhpcyBzdGF0ZSwgdGhlbiB3ZSB3b24ndCBzZW5kIHRoZSBvbkNoYW5nZSBmdW5jdGlvbilcbiAgICAgICAgICAgIGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPSB2YWx1ZVJlZi5jdXJyZW50O1xuXG4gICAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byB1cGRhdGUgdGhpcyBoZXJlIChhcyB3ZWxsIGFzIGJlbG93KSBpbiBjYXNlIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIGludm9rZXMgdGhpcyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIHJlYXNvblJlZi5jdXJyZW50ID0gcmVhc29uIGFzIFI7XG5cbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBhY3R1YWwgY2hlY2sgYW5kIGludm9jYXRpb24gb2Ygb25DaGFuZ2UgbGF0ZXIgdG8gbGV0IGVmZmVjdHMgc2V0dGxlXG4gICAgICAgICAgICAoY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgPz8gZGVib3VuY2VSZW5kZXJpbmcpKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UmVhc29uID0gcmVhc29uUmVmLmN1cnJlbnQhIGFzIFI7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dERlcCA9IHZhbHVlUmVmLmN1cnJlbnQhIGFzIFQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkRlcCA9IGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgIT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGFueSByZWdpc3RlcmVkIGNsZWFudXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvdWxkQ2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/LihuZXh0RGVwLCBwcmV2RGVwID09PSBVbnNldCA/IHVuZGVmaW5lZCA6IHByZXZEZXAsIG5leHRSZWFzb24pID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dERlcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIG5vcm1hbGx5IGNhbGwgZ2V0VmFsdWUgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSd2ZSBmaW5pc2hlZCB3aXRoIGV2ZXJ5dGhpbmcsIHNvIG1hcmsgdXMgYXMgYmVpbmcgb24gYSBjbGVhbiBzbGF0ZSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdC5jdXJyZW50ID0gVW5zZXQ7XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2YWx1ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNoZWNrZWQgYWdhaW5zdCBwcmV2RGVwIHRvIHNlZSBpZiB3ZSBzaG91bGQgYWN0dWFsbHkgY2FsbCBvbkNoYW5nZVxuICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtnZXRWYWx1ZSwgc2V0VmFsdWVdIGFzIGNvbnN0O1xufVxuXG5jb25zdCBVbnNldCA9IFN5bWJvbCgpO1xuXG4vLyBFYXN5IGNvbnN0YW50cyBmb3IgZ2V0SW5pdGlhbFZhbHVlXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHsgcmV0dXJuIHRydWU7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuTnVsbCgpIHsgcmV0dXJuIG51bGw7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5VbmRlZmluZWQoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5aZXJvKCkgeyByZXR1cm4gMDsgfVxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5PFQ+KHQ6IFQpIHsgcmV0dXJuIHQ7IH0gLy8gS2luZCBvZiBhbiBleHRyYSwgYnV0IGl0J3MgdXNlZnVsIGluIG90aGVyIHBsYWNlcyBhbnl3YXlcblxuLyoqIFxuICogQW4gYWx0ZXJuYXRpdmUgdG8gdXNlIGZvciBgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmdgIHRoYXQgY2F1c2VzIGB1c2VQYXNzaXZlU3RhdGVgIHRvIHJ1biBjaGFuZ2VzIHdpdGhvdXQgd2FpdGluZyBhIHRpY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydW5JbW1lZGlhdGVseShmOiAoKSA9PiB2b2lkKSB7IGYoKTsgfSIsIlxuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgcmV0dXJuVHJ1ZSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcblxuXG4vKipcbiAqIFxuICogVGhlcmUgYXJlIHNldmVyYWwgZGlmZmVyZW50IHdheXMgdGhhdCBhIGZvY3VzIGV2ZW50IGNhbiBoYXBwZW4uICBBc3N1bWVcbiAqIHRoZSBmb2xsb3dpbmcgc3RlcHMgaGFwcGVuIGluIG9yZGVyOlxuICogXG4gKiAxLiBUaGUgcGFnZSBsb2Fkcy5cbiAqICAgICogTm90aGluZyBpcyBmb2N1c2VkLCBidXQgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGBib2R5YC4gXG4gKiAgICAqIE5vIGZvY3VzIGV2ZW50cyBhcmUgZmlyZWQuXG4gKiAyLiBUaGUgd2luZG93IGlzIGZvY3VzZWQsIGFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIHJlbWFpbnMgYXMgYGJvZHlgLlxuICogICAgKiBBIGBmb2N1c2AvYGZvY3VzaW5gIGV2ZW50ICpNSUdIVCogYmUgZmlyZWQgZm9yIGBib2R5YC4gRGVwZW5kaW5nIG9uXG4gKiAgICAgIHRoZSBicm93c2VyLCB0aGlzIGRlcGVuZHMgb24gd2hldGhlciB0aGUgaGFuZGxlciB3YXMgYXR0YWNoZWQgdG8gYHdpbmRvd2Agb3IgYGRvY3VtZW50YC5cbiAqICAgICAgUHJvYmFibHkganVzdCBiZXN0IHRvIG5vdCByZWx5IG9uIGl0LCBvciBsaXN0ZW4gdG8gYHdpbmRvd2AgZm9jdXMgZXZlbnRzIGRpcmVjdGx5LlxuICogMy4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBuZXcgZWxlbWVudCBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXG4gKiAgICAqIGBmb2N1c291dGAgYW5kIGBibHVyYCBhcmUgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxuICogICAgKiBgZm9jdXNgIGFuZCBgZm9jdXNpbmAgYXJlIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwuXG4gKiA0LiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cbiAqICAgICogKipUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgYGJvZHlgKiogYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxuICogICAgKiBgYmx1cmAgYW5kIGBmb2N1c291dGAgYXJlIGZpcmVkIG9uIHRoZSBvbGQgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBuZXcgZWxlbWVudC5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBub3cgc2V0IHRvIHRoZSBuZXcgZWxlbWVudC5cbiAqICAgICogYGZvY3VzaW5gIGlzIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBvbGQgZWxlbWVudC5cbiAqIDUuIEFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byBgYm9keWAuXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cbiAqICAgICogYGZvY3VzaW5gIGlzICpub3QqIGZpcmVkIG9uIGBib2R5YC5cbiAqIFxuICogXG4gKiBJbiBzdW1tYXJ5OlxuICogMS4gRm9jdXMgZXZlbnRzICpkbyogbm90aWZ5IHVzIG9mIGFsbCBjaGFuZ2VzIGluIGZvY3VzLCBidXQgdGhlcmUgaXMgbm8gb25lIHNpbmdsZSBjb21wcmVoZW5zaXZlIGV2ZW50IHRoYXQgcHJvdmlkZXMgdXMgd2l0aCBhbGwgYXZhaWxhYmxlIGluZm9ybWF0aW9uLlxuICogMi4gYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgICppcyBub3QqIGFsd2F5cyB0aGUgc2FtZSBhcyB3aGF0J3MgYmVpbmcgcmVmZXJlbmNlZCBieSBhIGZvY3VzIGV2ZW50LiBJbiBwYXJ0aWN1bGFyLCBpdCBtYXkgYmVjb21lIGBib2R5YCBhdCBhbnkgYXJiaXRyYXJ5IHRpbWUuXG4gKiAzLiBBIGBibHVyYCB3aXRob3V0IGEgYGZvY3VzYCBjYW4gYW5kIHdpbGwgb2NjdXIuIFRoaXMgbWVhbnMgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHNvbGVseSB1c2UgYGZvY3VzYCB0byBkZXRlY3QgYWxsIGNoYW5nZXMuXG4gKiA0LiBBIGBibHVyYCBldmVudCB3aG9zZSBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIGZvbGxvd2luZyBgZm9jdXNgIGV2ZW50LlxuICogXG4gKi9cbmNvbnN0IF9kdW1teSA9IDA7XG5cbmludGVyZmFjZSBGb288VD4ge1xuICAgIGxhc3RTZW50OiBUIHwgdW5kZWZpbmVkO1xuICAgIHNlbmQ6IChlOiBULCByOiBGb2N1c0V2ZW50KSA9PiB2b2lkO1xufVxuLypcbmNvbnN0IGFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogTm9kZSB8IG51bGwpID0+IHZvaWQpPj4oKTtcbmNvbnN0IGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGU6IE5vZGUpID0+IHZvaWQpPj4oKTtcbmNvbnN0IHdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZm9jdXNlZDogYm9vbGVhbikgPT4gdm9pZCk+PigpO1xuY29uc3Qgd2luZG93c0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgYm9vbGVhbj4oKTsqL1xuY29uc3QgYWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPE5vZGUgfCBudWxsPj4+KCk7XG5jb25zdCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPE5vZGU+Pj4oKTtcbmNvbnN0IHdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxib29sZWFuPj4+KCk7XG5jb25zdCB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBib29sZWFuPigpO1xuXG4vL2NvbnN0IG1pY3JvdGFza3MgPSBuZXcgTWFwPFNldDxhbnk+LCBhbnk+KCk7XG5cbi8vIFRoZSBmb2N1c2luIGFuZCBmb2N1c291dCBldmVudHMgb2Z0ZW4gZmlyZSBzeW5jcm9ub3VzbHkgaW4gdGhlIG1pZGRsZSBvZiBydW5uaW5nIGNvZGUuXG4vLyBFLkcuIGNhbGxpbmcgZWxlbWVudC5mb2N1cygpIGNhbiBjYXVzZSBhIGZvY3VzaW4gZXZlbnQgaGFuZGxlciB0byBpbW1lZGlhdGVseSBpbnRlcnJ1cHQgdGhhdCBjb2RlLlxuLy8gRm9yIHRoZSBwdXJwb3NlIG9mIGltcHJvdmluZyBzdGFiaWxpdHksIHdlIGRlYm91bmNlIGFsbCBmb2N1cyBldmVudHMgdG8gdGhlIG5leHQgbWljcm90YXNrLlxuZnVuY3Rpb24gZm9yRWFjaFVwZGF0ZXI8VD4od2luZG93OiBXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBtYXA6IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPFQ+Pj4sIHZhbHVlOiBULCByZWFzb246IGFueSkge1xuICAgIGNvbnN0IHVwZGF0ZXJzID0gbWFwLmdldCh3aW5kb3cpO1xuICAgIGlmICh1cGRhdGVycykge1xuICAgICAgICAvL2lmICghbWljcm90YXNrcy5oYXModXBkYXRlcnNLZXkpKSB7XG4gICAgICAgIC8vZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAvL2NvbnN0IHVwZGF0ZXJzS2V5ID0gbWFwLmdldCh3aW5kb3cpITtcbiAgICAgICAgLy9jb25zdCB2YWx1ZSA9IG1pY3JvdGFza3MuZ2V0KHVwZGF0ZXJzS2V5KTtcbiAgICAgICAgLy9taWNyb3Rhc2tzLmRlbGV0ZSh1cGRhdGVyc0tleSk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZXIgb2YgdXBkYXRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxhc3RTZW50LCBzZW5kIH0gPSB1cGRhdGVyO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbGFzdFNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZCh2YWx1ZSwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlci5sYXN0U2VudCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vfSk7XG4gICAgICAgIC8vfVxuXG4gICAgICAgIC8vbWljcm90YXNrcy5zZXQodXBkYXRlcnNLZXksIHZhbHVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvY3Vzb3V0KGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGFjdGl2ZUVsZW1lbnRVcGRhdGVycywgbnVsbCwgZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBKdXN0IHdhaXQgZm9yIHRoZSBmb2N1c2luIGV2ZW50LlxuICAgIH1cblxufVxuXG5mdW5jdGlvbiBmb2N1c2luKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICBjb25zdCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCA9IGUudGFyZ2V0IGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50LCBlKTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50LCBlKTtcbn1cblxuZnVuY3Rpb24gd2luZG93Rm9jdXMoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUudGFyZ2V0IDogZS5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS5jdXJyZW50VGFyZ2V0IDogKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgdHJ1ZSk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMsIHRydWUsIGUpO1xufVxuXG5mdW5jdGlvbiB3aW5kb3dCbHVyKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGZhbHNlKTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIHdpbmRvd0ZvY3VzZWRVcGRhdGVycywgZmFsc2UsIGUpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIHtcblxuICAgIGFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzOiB7IFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnQgfCBudWxsLCBGb2N1c0V2ZW50PjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzIGFuZCBpcyBub3QgbnVsbC4gXG4gICAgICAgICAqIE11c3QgYmUgc3RhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnQsIEZvY3VzRXZlbnQ+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIHdpbmRvdyBnYWlucy9sb3NlcyBmb2N1cy4gTXVzdCBiZSBzdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxib29sZWFuLCBGb2N1c0V2ZW50PjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkb2N1bWVudCBhc3NvY2lhdGVkIHdpdGggd2hhdGV2ZXIgZWxlbWVudHMgd2UncmUgbGlzdGVuaW5nIHRvLlxuICAgICAgICAgKiBcbiAgICAgICAgICogRS5HLiBzb21lRGl2RWxlbWVudC5vd25lckRvY3VtZW50XG4gICAgICAgICAqIFxuICAgICAgICAgKiAqKk1VU1QqKiBiZSBzdGFibGVcbiAgICAgICAgICovXG4gICAgICAgIGdldERvY3VtZW50KCk6IERvY3VtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCBldmVudCBoYW5kbGVycyBhcmUgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50J3MgZGVmYXVsdFZpZXcgV2luZG93LlxuICAgICAgICAgKiBJZiB5b3UgbmVlZCBzb21ldGhpbmcgZGlmZmVyZW50LCBvdmVycmlkZSBpdCBoZXJlLlxuICAgICAgICAgKiBcbiAgICAgICAgICogKipNVVNUKiogYmUgc3RhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaW5kb3c/KGRvY3VtZW50OiBEb2N1bWVudCk6IFdpbmRvdztcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUge1xuICAgIGFjdGl2ZUVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBSZXR1cm5zIHdoYXRldmVyIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWQsIG9yIGBudWxsYCBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAgKiAqKlNUQUJMRSoqXG4gICAgICAgICAqL1xuICAgICAgICBnZXRBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBSZXR1cm5zIHdoYXRldmVyIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWQsIG9yIHdoYXRldmVyIGVsZW1lbnQgd2FzIG1vc3QgcmVjZW50bHkgZm9jdXNlZCBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAgKiAqKlNUQUJMRSoqXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudDogKCkgPT4gRWxlbWVudDtcbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBSZXR1cm5zIGlmIHRoZSB3aW5kb3cgaXRzZWxmIGhhcyBmb2N1cyBvciBub3RcbiAgICAgICAgICogKipTVEFCTEUqKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2luZG93Rm9jdXNlZDogKCkgPT4gYm9vbGVhbjtcbiAgICB9XG59XG5cbi8qKlxuICogQWxsb3dzIHlvdSB0byBpbnNwZWN0IHdoaWNoIGVsZW1lbnQgaW4gdGhlIGBkb2N1bWVudGAgY3VycmVudGx5IGhhcyBmb2N1cywgd2hpY2ggd2FzIG1vc3QgcmVjZW50bHkgZm9jdXNlZCBpZiBub25lIGFyZSBjdXJyZW50bHksIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgd2luZG93IGhhcyBmb2N1cyBieSByZXR1cm5pbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnM6XG4gKiAqIGBnZXRBY3RpdmVFbGVtZW50KClgXG4gKiAqIGBnZXRMYXN0QWN0aXZlRWxlbWVudCgpYFxuICogKiBgZ2V0V2luZG93Rm9jdXNlZCgpYFxuICogXG4gKiAoVGhlIGRvY3VtZW50J3MgYm9keSByZWNlaXZpbmcgZm9jdXMsIGxpa2UgaXQgZG9lcyB3aGVuIHlvdSBjbGljayBvbiBhbiBlbXB0eSBhcmVhLCBpcyBjb3VudGVkIGFzIG5vIGVsZW1lbnQgaGF2aW5nIGZvY3VzIGZvciBhbGwgaW50ZW50cyBhbmQgcHVycG9zZXMpXG4gKiBcbiAqIFRoaXMgaXMgYSBwYXNzaXZlIGhvb2ssIHNvIGJ5IGRlZmF1bHQgaXQgcmV0dXJucyBnZXR0ZXIgZnVuY3Rpb25zIHRoYXQgcmVwb3J0IHRoaXMgaW5mb3JtYXRpb24gYnV0IHRoZSBjb21wb25lbnQgd2lsbCBub3QgcmUtcmVuZGVyIGJ5IGRlZmF1bHQgd2hlbiB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcy5cbiAqIFxuICogSWYgeW91IG5lZWQgdGhlIGNvbXBvbmVudCB0byByZS1yZW5kZXIgd2hlbiB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcywgdXNlIHRoZSBgb24qQ2hhbmdlYCBhcmd1bWVudHMgdG8gc2V0IHNvbWUgc3RhdGUgb24geW91ciBlbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3RpdmVFbGVtZW50KHsgYWN0aXZlRWxlbWVudFBhcmFtZXRlcnM6IHsgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIGdldERvY3VtZW50LCBnZXRXaW5kb3cgfSB9OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycyk6IFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUFjdGl2ZUVsZW1lbnRcIiwgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIGdldERvY3VtZW50LCBnZXRXaW5kb3cpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICBjb25zdCB3aW5kb3cgPSAoZ2V0V2luZG93Py4oZG9jdW1lbnQpID8/IGRvY3VtZW50Py5kZWZhdWx0Vmlldyk7XG5cbiAgICAgICAgaWYgKChhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdyk/LnNpemUgPz8gMCkgPT09IDApIHtcbiAgICAgICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhlbSBldmVuIGlmIHRoZXkncmUgdW5kZWZpbmVkIHRvIG1vcmUgZWFzaWx5XG4gICAgICAgIC8vIG1hbmFnZSB0aGUgXCI+MCBtZWFucyBkb24ndCBhZGQgaGFuZGxlcnNcIiBsb2dpYy5cbiAgICAgICAgY29uc3QgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMgPSB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuXG4gICAgICAgIGNvbnN0IGxhZXUgPSB7IHNlbmQ6IHNldEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGUgfCBudWxsPiwgbGFzdFNlbnQ6IHVuZGVmaW5lZCB9XG4gICAgICAgIGNvbnN0IGxsYWV1ID0geyBzZW5kOiBzZXRMYXN0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZT4sIGxhc3RTZW50OiB1bmRlZmluZWQgfTtcbiAgICAgICAgY29uc3QgbHdmdSA9IHsgc2VuZDogc2V0V2luZG93Rm9jdXNlZCwgbGFzdFNlbnQ6IHVuZGVmaW5lZCB9O1xuXG4gICAgICAgIGxvY2FsQWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChsYWV1KTtcbiAgICAgICAgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChsbGFldSk7XG4gICAgICAgIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzLmFkZChsd2Z1KTtcblxuICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xuICAgICAgICBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLnNldCh3aW5kb3csIGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyk7XG4gICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKGxhZXUpO1xuICAgICAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKGxhZXUpO1xuICAgICAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUobHdmdSk7XG5cbiAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0KTtcbiAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cyk7XG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgW2dldEFjdGl2ZUVsZW1lbnQsIHNldEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnQgfCBudWxsLCBGb2N1c0V2ZW50PihvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwpO1xuICAgIGNvbnN0IFtnZXRMYXN0QWN0aXZlRWxlbWVudCwgc2V0TGFzdEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnQsIEZvY3VzRXZlbnQ+KG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwgYXMgKCkgPT4gbmV2ZXIpO1xuICAgIGNvbnN0IFtnZXRXaW5kb3dGb2N1c2VkLCBzZXRXaW5kb3dGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuLCBGb2N1c0V2ZW50PihvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIHJldHVyblRydWUpO1xuXG4gICAgcmV0dXJuIHsgYWN0aXZlRWxlbWVudFJldHVybjogeyBnZXRBY3RpdmVFbGVtZW50LCBnZXRMYXN0QWN0aXZlRWxlbWVudCwgZ2V0V2luZG93Rm9jdXNlZCB9IH07XG59XG4iLCJcbmltcG9ydCB7IENvbXBvbmVudCwgb3B0aW9ucywgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBFZmZlY3RDYWxsYmFjaywgSW5wdXRzLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG5cblxuY29uc3QgVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Xy1cIjtcblxuZnVuY3Rpb24gYmFzZTY0KHZhbHVlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gVGFibGVbdmFsdWVdO1xufVxuXG5mdW5jdGlvbiByYW5kb202Qml0cygpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMGIxMDAwMDAwKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tNjRCaXRzKCkge1xuICAgIHJldHVybiBbcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKV0gYXMgY29uc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbWx5LWdlbmVyYXRlZCBJRCB3aXRoIGFuIG9wdGlvbmFsIHByZWZpeC5cbiAqIE5vdGUgdGhhdCBpZiB0aGUgcHJlZml4IGlzICpleHBsaWNpdGx5KiBzZXQgdG8gXCJcIiwgdGhlblxuICogSURzIHRoYXQgYXJlIG5vdCB2YWxpZCB1bmRlciBIVE1MNCBtYXkgYmUgZ2VuZXJhdGVkLiBPaCBuby5cbiAqIFxuICogXG4gKiAoVGhpcyBpcyBoZXJlLCBpbiB0aGlzIHBhcnRpY3VsYXIgZmlsZSwgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gKiB3aXRob3V0IGFsc28gbWFraW5nIGEgdXRpbGl0aWVzIGZpbGUuXG4gKiBPbmNlIHdlIGNhbiByZW1vdmUgdGhpcyBob29rLCB3ZSBjYW4gcHV0IHRoaXMgZnVuY3Rpb24gYmFjayB3aXRoIHVzZVJhbmRvbUlkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JZChwcmVmaXg/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7cHJlZml4ID8/IFwiaWQtXCJ9JHtyYW5kb202NEJpdHMoKS5tYXAobiA9PiBiYXNlNjQobikpLmpvaW4oXCJcIil9YDtcbn1cblxuY29uc3QgcHJldmlvdXNJbnB1dHMgPSBuZXcgTWFwPHN0cmluZywgSW5wdXRzIHwgdW5kZWZpbmVkPigpO1xuY29uc3QgdG9SdW4gPSBuZXcgTWFwPHN0cmluZywgeyBlZmZlY3Q6IEVmZmVjdENhbGxiYWNrLCBpbnB1dHM/OiBJbnB1dHMsIGNsZWFudXA6IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkIHwgKCgpID0+IHZvaWQpIH0+KCk7XG5cblxuLy8gVE9ETzogV2hldGhlciB0aGlzIGdvZXMgaW4gb3B0aW9ucy5kaWZmZWQgb3Igb3B0aW9ucy5fY29tbWl0XG4vLyBpcyBhIHBvc3Qtc3VzcGVuc2UgcXVlc3Rpb24uXG4vLyBSaWdodCBub3csIHVzaW5nIG9wdGlvbnMuX2NvbW1pdCBoYXMgdGhlIHByb2JsZW0gb2YgcnVubmluZ1xuLy8gKmFmdGVyKiByZWZzIGFyZSBhcHBsaWVkLCBidXQgd2UgbmVlZCB0byBjb21lIGJlZm9yZSBldmVuIHRoYXRcbi8vIHNvIGByZWY9e3NvbWVTdGFibGVGdW5jdGlvbn1gIHdvcmtzLlxuLy8gXG4vLyBBbHNvIGl0J3MgcHJpdmF0ZS5cbi8vXG4vLyAuLi5cbi8vIFdlbGwsIHVzZUV2ZW50IG9yIHdoYXRldmVyIGlzIGZpbmFsbHksIGZpbmFsbHkgNCB5ZWFycyBsYXRlciBmaW5hbGx5IGhlcmVcbi8vIHdoaWNoIGlzIGNvb2wgYW5kIG1lYW5zIHdlIHdvbid0IG5lZWQgdGhpcyBhdCBhbGwgc29vbi5cbi8vIFNvIGZvciBub3cgd2UnbGwgc3RpY2sgd2l0aCBkaWZmIHRvIHByZXZlbnQgYW55IHdlaXJkbmVzcyB3aXRoXG4vLyBjb21taXQgYmVpbmcgcHJpdmF0ZSBhbmQgYWxsLlxuY29uc3QgY29tbWl0TmFtZSA9IFwiZGlmZmVkXCI7XG5cbmNvbnN0IG9yaWdpbmFsQ29tbWl0ID0gb3B0aW9uc1tjb21taXROYW1lXSBhcyAodm5vZGU6IFZOb2RlLCBjb21taXRRdWV1ZTogQ29tcG9uZW50W10pID0+IHZvaWQ7XG5jb25zdCBuZXdDb21taXQ6IHR5cGVvZiBvcmlnaW5hbENvbW1pdCA9ICguLi5hcmdzKSA9PiB7XG4gICAgZm9yIChjb25zdCBbaWQsIGVmZmVjdEluZm9dIG9mIHRvUnVuKSB7XG4gICAgICAgIGNvbnN0IG9sZElucHV0cyA9IHByZXZpb3VzSW5wdXRzLmdldChpZCk7XG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChvbGRJbnB1dHMsIGVmZmVjdEluZm8uaW5wdXRzKSkge1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwPy4oKTtcbiAgICAgICAgICAgIGVmZmVjdEluZm8uY2xlYW51cCA9IGVmZmVjdEluZm8uZWZmZWN0KCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5zZXQoaWQsIGVmZmVjdEluZm8uaW5wdXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1J1bi5jbGVhcigpO1xuICAgIG9yaWdpbmFsQ29tbWl0Py4oLi4uYXJncyk7XG59XG5vcHRpb25zW2NvbW1pdE5hbWVdID0gbmV3Q29tbWl0IGFzIG5ldmVyXG5cbi8qKlxuICogU2VtaS1wcml2YXRlIGZ1bmN0aW9uIHRvIGFsbG93IHN0YWJsZSBjYWxsYmFja3MgZXZlbiB3aXRoaW4gYHVzZUxheW91dEVmZmVjdGAgYW5kIHJlZiBhc3NpZ25tZW50LlxuICogXG4gKiBFdmVyeSByZW5kZXIsIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyB0byBiZSBldmFsdWF0ZWQgYWZ0ZXIgZGlmZmluZyBoYXMgY29tcGxldGVkLFxuICogd2hpY2ggaGFwcGVucyBiZWZvcmUuXG4gKiBcbiAqIEBwYXJhbSBlZmZlY3QgXG4gKiBAcGFyYW0gaW5wdXRzIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmVmb3JlTGF5b3V0RWZmZWN0KGVmZmVjdDogRWZmZWN0Q2FsbGJhY2sgfCBudWxsLCBpbnB1dHM/OiBJbnB1dHMpIHtcblxuICAgIC8qKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IHVzZVJlZjx2b2lkIHwgKCgpID0+IHZvaWQpIHwgbnVsbD4obnVsbCk7XG4gICAgICAgIGNvbnN0IHByZXZBcmdzUmVmID0gdXNlUmVmPElucHV0cz4obnVsbCEpO1xuICAgICAgICBpZiAoYXJnc0NoYW5nZWQoaW5wdXRzLCBwcmV2QXJnc1JlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgcHJldkFyZ3NSZWYuY3VycmVudCA9IGlucHV0cyE7XG4gICAgICAgICAgICBpZiAoY2xlYW51cC5jdXJyZW50KVxuICAgICAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCgpO1xuICAgICAgICAgICAgY2xlYW51cC5jdXJyZW50ID0gZWZmZWN0KCk7XG4gICAgICAgIH1cbiAgICB9KSgpOyovXG5cbiAgICBjb25zdCBbaWRdID0gdXNlU3RhdGUoKCkgPT4gZ2VuZXJhdGVSYW5kb21JZCgpKTtcbiAgICBpZiAoZWZmZWN0KVxuICAgICAgICB0b1J1bi5zZXQoaWQsIHsgZWZmZWN0LCBpbnB1dHMsIGNsZWFudXA6IG51bGwgfSk7XG4gICAgZWxzZVxuICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfSwgW2lkXSlcbn1cblxuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncz86IElucHV0cywgbmV3QXJncz86IElucHV0cyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIShcbiAgICAgICAgIW9sZEFyZ3MgfHxcbiAgICAgICAgb2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3M/Lmxlbmd0aCB8fFxuICAgICAgICBuZXdBcmdzPy5zb21lKChhcmcsIGluZGV4KSA9PiBhcmcgIT09IG9sZEFyZ3NbaW5kZXhdKVxuICAgICk7XG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VCZWZvcmVMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtYmVmb3JlLWxheW91dC1lZmZlY3RcIjtcblxuY29uc3QgVW5zZXQgPSBTeW1ib2woXCJ1bnNldFwiKTtcblxuXG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IHZhbHVlLCByZXR1cm5zIGEgY29uc3RhbnQgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gKiBcbiAqIFRoaXMgdXNlcyBgb3B0aW9ucy5kaWZmZWRgIGluIG9yZGVyIHRvIHJ1biBiZWZvcmUgZXZlcnl0aGluZywgZXZlblxuICogcmVmIGFzc2lnbm1lbnQuIFRoaXMgbWVhbnMgdGhpcyBnZXR0ZXIgaXMgc2FmZSB0byB1c2UgYW55d2hlcmUgKioqZXhjZXB0IHRoZSByZW5kZXIgcGhhc2UqKiouXG4gKiBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlR2V0dGVyPFQ+KHZhbHVlOiBUKSB7XG5cbiAgICBjb25zdCByZWYgPSB1c2VSZWY8VD4oVW5zZXQgYXMgdW5rbm93biBhcyBUKTtcbiAgICB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoKCgpID0+IHsgcmVmLmN1cnJlbnQgPSB2YWx1ZTsgfSksIFt2YWx1ZV0pO1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50IGFzIHVua25vd24gPT09IFVuc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUdldHRlcigpIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlci4nKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgICB9LCBbXSk7XG59XG5cblxuLyoqXG4gKiBMaWtlIGB1c2VTdGFibGVHZXR0ZXJgLCBidXQgKioqcmVxdWlyZXMqKiogdGhhdCBldmVyeXRoaW5nIGluIHRoZSBvYmplY3QgaXMgYWxzbyBzdGFibGUsXG4gKiBhbmQgaW4gdHVybiByZXR1cm5zIGFuIG9iamVjdCB0aGF0IGl0c2VsZiBpcyBzdGFibGUuXG4gKiBAcGFyYW0gdCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlT2JqZWN0PFQgZXh0ZW5kcyB7fT4odDogVCk6IFQge1xuICAgIGNvbnN0IGUgPSBPYmplY3QuZW50cmllcyh0KTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VTdGFibGVPYmplY3RcIiwgZS5sZW5ndGgsIC4uLmUubWFwKChbX2ssIHZdKSA9PiB2KSk7XG4gICAgcmV0dXJuIHVzZVJlZih0KS5jdXJyZW50O1xufVxuXG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFja05hdGl2ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5cbi8vY29uc3QgX0lTX1NUQUJMRV9HRVRURVIgPSBTeW1ib2woXCJTVEFCTEVcIik7XG5leHBvcnQgdHlwZSBTdGFibGU8VD4gPSBUOy8vICYgeyBbX1NUQUJMRV06IHRydWUgfTtcblxuLyoqXG4gKiBXZSBrZWVwIHRyYWNrIG9mIHdoaWNoIGNhbGxiYWNrcyBhcmUgc3RhYmxlIHdpdGggYSBXZWFrTWFwIGluc3RlYWQgb2YsIHNheSwgYSBzeW1ib2wgYmVjYXVzZVxuICogYHVzZUNhbGxiYWNrYCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQncyBzdGFibGUgYWNyb3NzICphbGwqIHJlbmRlcnMsIG1lYW5pbmdcbiAqIHdlIGNhbid0IHVzZSBvdXIgZnVubnkgXCJgaWZgIG9ubHkgd29ya3MgaGVyZSBiZWNhdXNlIGl0IGRvZXNuJ3QgYnJlYWsgdGhlIHJ1bGVzIG9mIGhvb2tzXCIgdHJpY2sgdGhlbi5cbiAqL1xuY29uc3QgbWFwID0gbmV3IFdlYWtNYXA8RnVuY3Rpb24sIGJvb2xlYW4+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0YWJsZUdldHRlcjxUIGV4dGVuZHMgRnVuY3Rpb24+KG9iajogVCk6IG9iaiBpcyBTdGFibGU8VD4ge1xuICAgIHJldHVybiAobWFwLmdldChvYmopID8/IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNldElzU3RhYmxlR2V0dGVyPFQgZXh0ZW5kcyAoLi4uX2FyZ3M6IGFueVtdKSA9PiBhbnk+KG9iajogVCk6IFN0YWJsZTxUPiB7XG4gICAgbWFwLnNldChvYmosIHRydWUpO1xuICAgIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXG4gKiBzbyB0aGF0IGl0IGNhbiBiZSBleGNsdWRlZCBmcm9tIHRoZSBkZXBlbmRlbmN5IGFycmF5cyBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcy5cbiAqIFxuICogSW4gZ2VuZXJhbCwganVzdCBwYXNzIHRoZSBmdW5jdGlvbiB5b3Ugd2FudCB0byBiZSBzdGFibGUgKGJ1dCB5b3UgY2FuJ3QgdXNlIGl0IGR1cmluZyByZW5kZXIsXG4gKiBzbyBiZSBjYXJlZnVsISkuICBBbHRlcm5hdGl2ZWx5LCBpZiB5b3UgbmVlZCBhIHN0YWJsZSBjYWxsYmFjayB0aGF0ICoqY2FuKiogYmUgdXNlZFxuICogZHVyaW5nIHJlbmRlciwgcGFzcyBhbiBlbXB0eSBkZXBlbmRlbmN5IGFycmF5IGFuZCBpdCdsbCBhY3QgbGlrZSBgdXNlQ2FsbGJhY2tgIHdpdGggYW5cbiAqIGVtcHR5IGRlcGVuZGVuY3kgYXJyYXksIGJ1dCB3aXRoIHRoZSBhc3NvY2lhdGVkIHN0YWJsZSB0eXBpbmcuIEluIHRoaXMgY2FzZSwgeW91ICoqKm11c3QqKiogZW5zdXJlIHRoYXQgaXRcbiAqIHRydWx5IGhhcyBubyBkZXBlbmRlbmNpZXMvb25seSBzdGFibGUgZGVwZW5kZW5jaWVzISFcbiAqL1xuLy9leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlQ2FsbGJhY2s8VCBleHRlbmRzICguLi5fYXJnczogYW55W10pID0+IGFueT4oZm46IFQsIG5vRGVwczogW10pOiBTdGFibGU8VD47XG4vL2V4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjazxUIGV4dGVuZHMgKC4uLl9hcmdzOiBhbnlbXSkgPT4gYW55PihmbjogVCk6IFN0YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjazxUIGV4dGVuZHMgRnVuY3Rpb24gfCBudWxsIHwgdW5kZWZpbmVkPihmbjogTm9uTnVsbGFibGU8VD4sIG5vRGVwcz86IFtdIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFN0YWJsZTxOb25OdWxsYWJsZTxUPj4ge1xuICAgIHR5cGUgVSA9IChOb25OdWxsYWJsZTxUPiAmICgoLi4uYXJnczogYW55KSA9PiBhbnkpKTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VTdGFibGVDYWxsYmFja1wiLCBub0RlcHMgPT0gbnVsbCwgbm9EZXBzPy5sZW5ndGgsIGlzU3RhYmxlR2V0dGVyPFU+KGZuIGFzIFUpKTtcbiAgICBpZiAoaXNTdGFibGVHZXR0ZXIoZm4pKVxuICAgICAgICByZXR1cm4gZm47XG5cbiAgICBpZiAobm9EZXBzID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENhbGxiYWNrR2V0dGVyID0gdXNlU3RhYmxlR2V0dGVyPFU+KGZuKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KCgoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDYWxsYmFja0dldHRlcigpKC4uLmFyZ3MpO1xuICAgICAgICB9KSBhcyBVLCBbXSkpO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLmFzc2VydChub0RlcHMubGVuZ3RoID09PSAwKTtcbiAgICAgICAgcmV0dXJuIHNldElzU3RhYmxlR2V0dGVyKHVzZUNhbGxiYWNrTmF0aXZlPFU+KGZuLCBbXSkpO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVib3VuY2VSZW5kZXJpbmcsIE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCBQYXNzaXZlU3RhdGVVcGRhdGVyLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZU9iamVjdCB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cbi8qKlxuICogUmVtaW5kZXIgb2Ygb3JkZXIgb2YgZXhlY3V0aW9uOlxuICogXG4gKiAqICh0cmVlIG1vdW50cylcbiAqICogUGFyZW50IHJlbmRlcnNcbiAqICogQ2hpbGRyZW4gcmVuZGVyXG4gKiAqIENoaWxkcmVuIHJlY2VpdmUgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBQYXJlbnQgcmVjZWl2ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZHJlbiBydW4gZWZmZWN0c1xuICogKiBQYXJlbnQgcnVucyBlZmZlY3RzXG4gKiBcbiAqICogKHRyZWUgdW5tb3VudHMpXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIFBhcmVudCBkZWxldGVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogQ2hpbGQgcnVucyBlZmZlY3QtY2xlYW51cFxuICogKiBDaGlsZCBkZWxldGVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqIFxuICogVHdvIHRoaW5ncyB0byBub3RlIGhlcmU6XG4gKiAqIFJlbmRlcmluZyBzdGFydHMgYXQgdGhlIHJvb3QsICBidXQgZWZmZWN0cyBhbmQgcmVmcyBzdGFydCBhdCB0aGUgbGVhdmVzLlxuICogKiByZWZzIGFyZSAqdXN1YWxseSogY2FsbGVkIGJlZm9yZSBlZmZlY3RzLCBidXQgb25seSB3aGVuIHRoYXQgSFRNTEVsZW1lbnQgcmVuZGVycy4gQmFzaWNhbGx5IGp1c3QgYSByZW1pbmRlciB0aGF0IGEgY29tcG9uZW50IGNhbiBiZSBtb3VudGVkIHdpdGhvdXQgaXQgZXhpc3RpbmcgaW4gdGhlIERPTS5cbiAqL1xuY29uc3QgX2NvbW1lbnRzID0gdm9pZCAoMCk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgLy9tYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8TT5bXCJtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5cIl1cblxuICAgIG1hbmFnZWRDaGlsZENvbnRleHQ6IHtcbiAgICAgICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheTogSW50ZXJuYWxDaGlsZEluZm88TT47XG4gICAgICAgIHJlbW90ZVVMRUNoaWxkTW91bnRlZDogKGluZGV4OiBNW1wiaW5kZXhcIl0sIG1vdW50ZWQ6IGJvb2xlYW4pID0+IHZvaWQ7XG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZDogKGluZGV4OiBNW1wiaW5kZXhcIl0pID0+ICgoKSA9PiB2b2lkKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBEb2VzIG5vdGhpbmcgYXQgcnVudGltZSAtLSB0eXBlIGNoZWNraW5nIG9ubHkuXG4gKiBcbiAqIFRocm93cyBhIChUeXBlc2NyaXB0IGNvbXBpbGVyKSBlcnJvciBpZiB0aGUgcGFzc2VkIG9iamVjdCBpcyBhbnl0aGluZyBidXQgdGhlIGVtcHR5IG9iamVjdCB7fS5cbiAqIFxuICogVXNlIHRoaXMgdG8gZW5zdXJlIHRoYXQgeW91ciBzcHJlYWQgb3BlcmF0b3JzIHdvcmsgY29ycmVjdGx5IGFuZCBjb3ZlciBhbGwgY2FzZXMuXG4gKiBcbiAqIEBwYXJhbSBfYSBUaGUgcmVtYWluaW5nIHNwcmVhZCBwYXJhbWV0ZXJzIG9mIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgeW91IGV4cGVjdCB0byBiZSBlbXB0eSAoYmVjYXVzZSB5b3UgcHJvcGVybHkgYWNjb3VudGVkIGZvciBhbGwgdGhlIHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBpdCwgYW5kIHdhbnQgdG8gZW5zdXJlIGl0IHN0YXlzIHRoYXQgd2F5KVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RW1wdHlPYmplY3Q8VCBleHRlbmRzIHt9PihfYTogW2tleW9mIFRdIGV4dGVuZHMgW25ldmVyXSA/IFQgOiBgVW5oYW5kbGVkIGtleXMgaW4gdGhpcyByZXN0IHNwcmVhZCBvYmplY3QhYCk6IHZvaWQgeyB9XG5cblxuXG4vKipcbiAqIEluZm9ybWF0aW9uIHRoYXQgY2hpbGRyZW4gYW5kIHBhcmVudHMgdXNlIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cbiAqIFxuICogKiBgaW5kZXhgIHJlZmVycyB0byB3aGljaCBjaGlsZCB0aGlzIGlzLlxuICogKiBgZmxhZ3NgIGFyZSBxdWljay1hbmQtZWFzeSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgeW91IGNhbiBvcHRpb25hbGx5IHVzZVxuICogKiBgc3ViSW5mb2AgaXMgYW55dGhpbmcgdXNlZCBieSBhIGRlcml2ZWQgaG9vay4gYHVzZVJvdmluZ1RhYkluZGV4YCwgZm9yIGV4YW1wbGUsIG5lZWRzIHRvIGtub3cgaG93IHRvIGZvY3VzIGFuIGFyYml0cmFyeSBjaGlsZCwgc28gdGhlIGNoaWxkIHBvcHVsYXRlcyBgaW5mb2Agd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyBhIG1ldGhvZCBjYWxsZWQgYGZvY3VzU2VsZmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkSW5mbzxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiB7XG4gICAgaW5kZXg6IFQ7XG4gICAgLy9mbGFnczogUGFydGlhbDxSZWNvcmQ8SywgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+O1xuICAgIC8vc3ViSW5mbzogTUNTdWJJbmZvO1xufVxuXG5cblxuZXhwb3J0IHR5cGUgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChtb3VudGVkOiBTZXQ8VD4sIHVubW91bnRlZDogU2V0PFQ+KSA9PiB2b2lkKTtcbmV4cG9ydCB0eXBlIE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgoY2F1c2VyczogSXRlcmFibGU8VD4pID0+IHZvaWQpO1xuXG5pbnRlcmZhY2UgTUNQPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmc+IHtcbiAgICAvKipcbiAgICAgKiBSdW5zIGFmdGVyIG9uZSBvciBtb3JlIGNoaWxkcmVuIGhhdmUgdXBkYXRlZCB0aGVpciBpbmZvcm1hdGlvbiAoaW5kZXgsIGV0Yy4pLlxuICAgICAqIFxuICAgICAqIE9ubHkgb25lIHdpbGwgcnVuIHBlciB0aWNrLCBqdXN0IGxpa2UgbGF5b3V0RWZmZWN0LCBidXQgaXQgaXNuJ3RcbiAgICAgKiAqZ3VhcmFudGVlZCogdG8gaGF2ZSBhY3R1YWxseSBiZWVuIGEgY2hhbmdlLlxuICAgICAqL1xuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdD86IG51bGwgfCB1bmRlZmluZWQgfCBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8VD47XG5cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIHRoZSBhYm92ZSwgYnV0IG9ubHkgZm9yIG1vdW50L3VubW91bnQgKG9yIHdoZW4gYSBjaGlsZCBjaGFuZ2VzIGl0cyBpbmRleClcbiAgICAgKi9cbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IE1DUDxNW1wiaW5kZXhcIl0+O1xufVxuXG4vLyBNQ1N1YkluZm8gY29udGFpbnMgdGhlIGVudGlyZXR5IG9mIHRoZSBzYXZlZCBkYXRhIGZvciB0aGlzIGNoaWxkLiAgQWxsIG9mIGl0LiBFdmVuIHR5cGVzIHRoZSB1c2VyIHdpbGwgbmV2ZXIgYmUgYWJsZSB0byBwYXNzIGluIGJlY2F1c2UgdGhleSdyZSBpbnRlcm5hbGx5IGRlcml2ZWQuXG4vLyBTdWJiZXN0SW5mbyByZWZlcnMgdG8gdGhlIGFjdHVhbCBwYXJhbWV0ZXJzIHRoZSB1c2VyIHBhc3NlcyBpbiB0aGF0IGNvdWxkIGJlIHRvdGFsbHkgdW5yZWxhdGVkLiBcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSBwcm9wZXJ0eSBzaGFyZWQgYW1vbmcgYWxsIG1hbmFnZWQgY2hpbGRyZW4uXG4gICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBpcyByZWR1bmRhbnQgd2l0aCB0aGUgc2Vjb25kIGFyZ3VtZW50LCB3aGljaCBpcy4uLmVoLiBCdXQgdGhlIHR5cGVzIGFyZSBjbGVhci5cbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBQaWNrPE0sIFwiaW5kZXhcIj47XG4gICAgY29udGV4dDogVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNPjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNoaWxkIHRoYXQgcmVuZGVyZWQgaXRzZWxmIHdpdGggdGhlIHJlcXVlc3RlZCBrZXkuXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKiAoZXZlbiB0aG91Z2ggaXQncyBub3QgYSBmdW5jdGlvbiwgdGhlIGlkZW50aXR5IG9mIHRoaXMgb2JqZWN0IG5ldmVyIGNoYW5nZXMpXG4gICAgICovXG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7XG4gICAgICAgIC8qKiBcbiAgICAgICAgICogKioqU1RBQkxFKioqXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCAqKmJvdGgqKiBgZ2V0Q2hpbGRyZW5gIGFuZCB0aGUgYE1hbmFnZWRDaGlsZHJlbmAgb2JqZWN0IGl0IHJldHVybnMgYXJlIHN0YWJsZSFcbiAgICAgICAgICogXG4gICAgICAgICAqIFRoaXMgaXMgYSBnZXR0ZXIgaW5zdGVhZCBvZiBhbiBvYmplY3QgYmVjYXVzZSB3aGVuIGZ1bmN0aW9uIGNhbGxzIGhhcHBlbiBvdXQgb2Ygb3JkZXIgaXQncyBlYXNpZXIgdG8ganVzdCBoYXZlIGFsd2F5cyBiZWVuIHBhc3NpbmcgYW5kIHJldHVybiBnZXR0ZXJzIGV2ZXJ5d2hlcmUgXG4gICAgICAgICAqL1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG5cbiAgICB9O1xuXG4gICAgY29udGV4dDogVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICBtYW5hZ2VkQ2hpbGRSZXR1cm46IHtcbiAgICAgICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuICAgIH1cbn1cblxuLy9leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGQ8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4gPSAoYTogVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxNPikgPT4gVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxNPjtcblxuXG5cblxuXG5cbi8qKlxuICogQWJzdHJhY3Rpb24gb3ZlciB0aGUgbWFuYWdlZCBjaGlsZHJlblxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZHJlbjxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGdldEF0KGluZGV4OiBNW1wiaW5kZXhcIl0pOiBNIHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRIaWdoZXN0SW5kZXgoKTogbnVtYmVyO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBmb3JFYWNoOiAoZjogKGNoaWxkOiBNKSA9PiB2b2lkKSA9PiB2b2lkO1xuXG4gICAgLyoqICoqVU5TVEFCTEUqKiwgYWxzbyBpbnRlcm5hbC11c2Ugb25seSwgYWxzbyBUT0RPIG5lZWQgYSB3b3JrYXJvdW5kIGZvciB0aGlzIGZvciBzb3J0YWJsZSBjaGlsZHJlbiAqL1xuICAgIGFycmF5U2xpY2U6ICgpID0+IE1bXTtcbn1cblxuaW50ZXJmYWNlIEludGVybmFsQ2hpbGRJbmZvPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPHN0cmluZyB8IG51bWJlcj4+IHtcbiAgICBhcnI6IEFycmF5PE0+O1xuICAgIHJlYzogUGFydGlhbDxSZWNvcmQ8TVtcImluZGV4XCJdLCBNPj47XG4gICAgaGlnaGVzdEluZGV4OiBudW1iZXI7XG4gICAgbG93ZXN0SW5kZXg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgYSBwYXJlbnQgY29tcG9uZW50IHRvIGFjY2VzcyBpbmZvcm1hdGlvbiBhYm91dCBjZXJ0YWluXG4gKiBjaGlsZCBjb21wb25lbnRzIG9uY2UgdGhleSBoYXZlIHJlbmRlcmVkLlxuICogXG4gKiBUaGlzIGhvb2sgaXMgZGVzaWduZWQgdG8gYmUgbGlnaHR3ZWlnaHQsIGluIHRoYXQgdGhlIHBhcmVudCBrZWVwcyBubyBzdGF0ZVxuICogYW5kIHJ1bnMgbm8gZWZmZWN0cy4gIEVhY2ggY2hpbGQgKmRvZXMqIHJ1biBhbiBlZmZlY3QsIGJ1dCB3aXRoIG5vIHN0YXRlXG4gKiBjaGFuZ2VzIHVubGVzcyB5b3UgZXhwbGljaXRseSByZXF1ZXN0IHRoZW0uXG4gKiBcbiAqIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkcmVuPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPHN0cmluZyB8IG51bWJlcj4+KHBhcmVudFBhcmFtZXRlcnM6IFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8TT4pOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0+IHtcbiAgICB0eXBlIEluZGV4VHlwZSA9IE1bXCJpbmRleFwiXTtcbiAgICB0eXBlIEluZm8gPSBNO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sIC4uLnJlc3QgfSA9IHBhcmVudFBhcmFtZXRlcnM7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QocmVzdCk7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UpO1xuXG4gICAgY29uc3QgZ2V0SGlnaGVzdEluZGV4ID0gdXNlQ2FsbGJhY2soKCk6IG51bWJlciA9PiB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleDtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBBbGwgdGhlIGluZm9ybWF0aW9uIHdlIGhhdmUgYWJvdXQgb3VyIGNoaWxkcmVuIGlzIHN0b3JlZCBpbiB0aGlzICoqc3RhYmxlKiogYXJyYXkuXG4gICAgLy8gQW55IG11dGF0aW9ucyB0byB0aGlzIGFycmF5ICoqRE8gTk9UKiogdHJpZ2dlciBhbnkgc29ydCBvZiBhIHJlLXJlbmRlci5cbiAgICBjb25zdCBtYW5hZ2VkQ2hpbGRyZW5BcnJheSA9IHVzZVJlZjxJbnRlcm5hbENoaWxkSW5mbzxNPj4oeyBhcnI6IFtdLCByZWM6IHt9LCBoaWdoZXN0SW5kZXg6IDAsIGxvd2VzdEluZGV4OiAwIH0pO1xuXG4gICAgLy8gRm9yIGluZGlyZWN0IGFjY2VzcyB0byBlYWNoIGNoaWxkXG4gICAgLy8gQ29tcGFyZSBnZXRNYW5hZ2VkQ2hpbGRJbmZvXG4gICAgLy8gVE9ETzogVGhlIHByaW1hcnkgdXNlIGZvciB0aGlzIGlzIGZsYWdnYWJsZSBjbG9zZXN0IGZpdHNcbiAgICAvLyB3aGljaCBuZWVkcyB0byBzZWFyY2ggYWxsIGNoaWxkcmVuIGZvciB0aGF0IGNsb3Nlc3QgZml0LlxuICAgIC8vIEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlcmUgd2FzIHNvbWV0aGluZyBiZXR0ZXIgZm9yIHRoYXQuXG4gICAgY29uc3QgZm9yRWFjaENoaWxkID0gdXNlQ2FsbGJhY2soKGY6IChjaGlsZDogSW5mbykgPT4gdm9pZCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQpXG4gICAgICAgICAgICAgICAgZihjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlYykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQ6IEluZm8gfCB1bmRlZmluZWQgPSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tmaWVsZCBhcyBrZXlvZiBSZWNvcmQ8SW5kZXhUeXBlLCBJbmZvPl07XG4gICAgICAgICAgICBpZiAoY2hpbGQpXG4gICAgICAgICAgICAgICAgZihjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIC8vIFJldHJpZXZlcyB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cbiAgICAvLyBgdW5kZWZpbmVkYCBpZiBub3QgY2hpbGQgdGhlcmUsIG9yIGl0J3MgdW5tb3VudGVkLlxuICAgIGNvbnN0IGdldE1hbmFnZWRDaGlsZEluZm8gPSB1c2VDYWxsYmFjazxNYW5hZ2VkQ2hpbGRyZW48TT5bXCJnZXRBdFwiXT4oKGluZGV4OiBJbmRleFR5cGUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl0hO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXSE7XG4gICAgfSwgW10pXG5cbiAgICAvLyB0bDtkciB0aGlzIGlzIGEgd2F5IHRvIGhhdmUgcnVuIHVzZUxheW91dEVmZmVjdCBvbmNlIGFmdGVyIGFsbCBOIGNoaWxkcmVuXG4gICAgLy8gaGF2ZSBtb3VudGVkIGFuZCBydW4gKnRoZWlyKiB1c2VMYXlvdXRFZmZlY3QsIGJ1dCBhbHNvICp3aXRob3V0KiByZS1yZW5kZXJpbmdcbiAgICAvLyBvdXJzZWx2ZXMgYmVjYXVzZSBvZiBoYXZpbmcgYSBgY2hpbGRDb3VudGAgc3RhdGUgb3IgYW55dGhpbmcgc2ltaWxhci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIGNoaWxkIGNvdW50IHJlZiB1cGRhdGVzLCB3ZSB3YW50IHRoZSBwYXJlbnQgdG8gYWxzbyBydW4gYW4gZWZmZWN0XG4gICAgLy8gdG8gbWF5YmUgZG8gc29tZXRoaW5nIHdpdGggYWxsIHRoZXNlIGNoaWxkcmVuIHRoYXQganVzdCBtb3VudGVkLlxuICAgIC8vIFRoZSBlYXNpZXN0IHdheSB3b3VsZCBiZSB1c2VFZmZlY3QoLi4uLCBbY2hpbGRDb3VudF0pIGJ1dFxuICAgIC8vIHRoYXQgd291bGQgcmVxdWlyZSB1cyBoYXZpbmcgYSBjaGlsZENvdW50IHN0YXRlLCB0aGVuIGNhbGxpbmdcbiAgICAvLyBzZXRDaGlsZENvdW50IGFuZCByZS1yZW5kZXJpbmcgZXZlcnkgdGltZSBjaGlsZHJlbiBtb3VudFxuICAgIC8vIChvbmx5IG9uZSByZS1yZW5kZXIgYXQgYSB0aW1lIHVubGVzcyBjaGlsZHJlbiBhcmUgc3RhZ2dlcmVkLCBidXQgc3RpbGwpXG4gICAgLy8gXG4gICAgLy8gQXMgYW4gYWx0ZXJuYXRlIHNvbHV0aW9uLCBhbnkgdGltZSBhIGNoaWxkIHVzZXMgVUxFIG9uIG1vdW50LCBpdCBxdWV1ZXMgYSBtaWNyb3Rhc2tcbiAgICAvLyB0byBlbXVsYXRlIHJ1bm5pbmcgVUxFIG9uIHRoZSBwYXJlbnQuIE9ubHkgdGhlIGZpcnN0IGNoaWxkIHdpbGwgYWN0dWFsbHkgcXVldWVcbiAgICAvLyB0aGUgbWljcm90YXNrIChieSBjaGVja2luZyBoYXNSZW1vdGVVTEUgZmlyc3QpIHNvIHRoYXQgdGhlIFwiZWZmZWN0XCIgb25seVxuICAgIC8vIHJ1bnMgb25jZS4gV2hlbiBpdCdzIGRvbmUsIGhhc1JlbW90ZVVMRSBpcyByZXNldCBzbyBpdCBjYW4gcnVuIGFnYWluIGlmXG4gICAgLy8gbW9yZSBjaGlsZHJlbiBtb3VudC91bm1vdW50LlxuICAgIGNvbnN0IGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZCA9IHVzZVJlZjx7IG1vdW50czogU2V0PEluZGV4VHlwZT4sIHVubW91bnRzOiBTZXQ8SW5kZXhUeXBlPiB9IHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyA9IHVzZVJlZihuZXcgU2V0PEluZGV4VHlwZT4oKSk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBJbmRleFR5cGUpID0+IHtcblxuICAgICAgICBpZiAocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LnNpemUgPT0gMCkge1xuICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdD8uKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5hZGQoaW5kZXgpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG5cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IEluZGV4VHlwZSwgbW91bnRlZDogYm9vbGVhbik6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIWhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICBtb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICB1bm1vdW50czogbmV3IFNldCgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEubW91bnRzLCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEudW5tb3VudHMpXG4gICAgICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gTWF0aC5tYXgobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXgsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdO1xuICAgICAgICAgICAgICAgIGxldCBzaGF2ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNoYXZlIDw9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAmJiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyclttYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKytzaGF2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc3BsaWNlKG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIHNoYXZlLCBzaGF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudFttb3VudGVkID8gXCJtb3VudHNcIiA6IFwidW5tb3VudHNcIl0uYWRkKGluZGV4KTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbiA9IHVzZVN0YWJsZU9iamVjdDxNYW5hZ2VkQ2hpbGRyZW48TT4+KHtcbiAgICAgICAgLi4ueyBfOiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50IH0gYXMge30sXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZCxcbiAgICAgICAgZ2V0QXQ6IGdldE1hbmFnZWRDaGlsZEluZm8sXG4gICAgICAgIGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdEluZGV4LFxuICAgICAgICBhcnJheVNsaWNlOiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc2xpY2UoKTtcbiAgICAgICAgfSwgW10pXG4gICAgfSk7XG5cbiAgICBjb25zdCBnZXRDaGlsZHJlbiA9IHVzZUNhbGxiYWNrKCgpID0+IG1hbmFnZWRDaGlsZHJlbiwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZENvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXk6IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkLFxuICAgICAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCxcbiAgICAgICAgICAgICAgICBnZXRDaGlsZHJlblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogeyBnZXRDaGlsZHJlbiB9XG4gICAgfVxufVxuXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciB8IHN0cmluZz4+KGluZm86IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT4sIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IE0pOiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0+IHtcbiAgICB0eXBlIEluZGV4VHlwZSA9IE1bXCJpbmRleFwiXTtcblxuICAgIGNvbnN0IHsgY29udGV4dDogeyBtYW5hZ2VkQ2hpbGRDb250ZXh0OiB7IGdldENoaWxkcmVuLCBtYW5hZ2VkQ2hpbGRyZW5BcnJheSwgcmVtb3RlVUxFQ2hpbGRNb3VudGVkLCByZW1vdGVVTEVDaGlsZENoYW5nZWQgfSB9IH0gPSBpbmZvO1xuICAgIGNvbnN0IGluZGV4ID0gbWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleDtcbiAgICAvLyBBbnkgdGltZSBvdXIgY2hpbGQgcHJvcHMgY2hhbmdlLCBtYWtlIHRoYXQgaW5mb3JtYXRpb24gYXZhaWxhYmxlXG4gICAgLy8gdGhlIHBhcmVudCBpZiB0aGV5IG5lZWQgaXQuXG4gICAgLy8gVGhlIHBhcmVudCBjYW4gbGlzdGVuIGZvciBhbGwgdXBkYXRlcyBhbmQgb25seSBhY3Qgb24gdGhlIG9uZXMgaXQgY2FyZXMgYWJvdXQsXG4gICAgLy8gYW5kIG11bHRpcGxlIGNoaWxkcmVuIHVwZGF0aW5nIGluIHRoZSBzYW1lIHRpY2sgd2lsbCBhbGwgYmUgc2VudCBhdCBvbmNlLlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEluc2VydCB0aGlzIGluZm9ybWF0aW9uIGluLXBsYWNlXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuYXJyW2luZGV4IGFzIG51bWJlcl0gPSB7IC4uLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LnJlY1tpbmRleCBhcyBJbmRleFR5cGVdID0geyAuLi5tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZChpbmRleCBhcyBJbmRleFR5cGUpO1xuICAgIH0sIFsuLi5PYmplY3QuZW50cmllcyhpbmZvKS5mbGF0KDkpXSk7ICAvLyA5IGlzIGluZmluaXR5LCByaWdodD8gU3VyZS4gVW5yZWxhdGVkOiBUT0RPLlxuXG4gICAgLy8gV2hlbiB3ZSBtb3VudCwgbm90aWZ5IHRoZSBwYXJlbnQgdmlhIHF1ZXVlTWljcm90YXNrXG4gICAgLy8gKGV2ZXJ5IGNoaWxkIGRvZXMgdGhpcywgc28gZXZlcnl0aGluZydzIGNvb3JkaW5hdGVkIHRvIG9ubHkgcXVldWUgYSBzaW5nbGUgbWljcm90YXNrIHBlciB0aWNrKVxuICAgIC8vIERvIHRoZSBzYW1lIG9uIHVubW91bnQuXG4gICAgLy8gTm90ZTogSXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIGNvbWVzIEFGVEVSIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZFxuICAgIC8vIHNvIHRoYXQgcmVtb3RlVUxFQ2hpbGRNb3VudGVkIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSBpbmZvIG9uIG1vdW50LlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZGV4IGFzIEluZGV4VHlwZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmRleCBhcyBJbmRleFR5cGUsIGZhbHNlKTtcbiAgICB9LCBbaW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybjogeyBnZXRDaGlsZHJlbiB9XG4gICAgfVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+LCBSPiB7XG5cbiAgICAvKipcbiAgICAgKiBXaGljaCBjaGlsZCBpcyBjb25zaWRlcmVkIGFjdGl2ZSBvbiBtb3VudC5cbiAgICAgKiBcbiAgICAgKiBBZnRlciBtb3VudCwgY2hhbmdlIHRoZSBjdXJyZW50IGFjdGl2ZSBjaGlsZCB3aXRoIGBjaGFuZ2VJbmRleGAuXG4gICAgICovXG4gICAgaW5pdGlhbEluZGV4OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBwcm92aWRlZCwgaWYgdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4IGRvZXNuJ3QgbWFwIG9udG8gYW55XG4gICAgICogcHJvdmlkZWQgY2hpbGQgKGVpdGhlciBiZWNhdXNlIGl0J3MgdG9vIGxhcmdlIG9yIHRoYXQgY2hpbGRcbiAgICAgKiBkb2Vzbid0IGV4aXN0KSwgdGhlIGNsb3Nlc3QgY2hpbGQgdG8gdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4XG4gICAgICogd2lsbCBoYXZlIGl0cyBmbGFnIHNldCBpbnN0ZWFkLlxuICAgICAqIFxuICAgICAqIFVzZSB3aXRoIGNhdXRpb24sIGFuZCBjb25zaWRlciBob3cgYSBjaGlsZCBoYXZpbmcgaXRzIGZsYWcgc2V0XG4gICAgICogd2hpbGUgdGhlIHBhcmVudCB0aGlua3MgaXQgc2hvdWxkbid0IGJlIGNvdWxkIGNhdXNlIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBjbG9zZXN0Rml0OiBib29sZWFuO1xuXG4gICAgZ2V0Q2hpbGRyZW4oKTogTWFuYWdlZENoaWxkcmVuPE0+O1xuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBuZXcgaW5kZXggaXMgc2VsZWN0ZWQuXG4gICAgICogXG4gICAgICogTm90YWJseSwgdGhlIHZhbHVlIGNhbiBiZSBkaWZmZXJlbnQgdGhhbiB3aGF0IHdhcyBjYWxsZWQgd2l0aCBjaGFuZ2VJbmRleCgpXG4gICAgICogaWYgdGhlIHJlcXVlc3RlZCBpbmRleCBkaWRuJ3QgZXhpc3Qgb3Igd2FzIGhpZGRlbi5cbiAgICAgKi9cbiAgICBvbkluZGV4Q2hhbmdlOiBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8bnVtYmVyIHwgbnVsbCwgUj47XG5cbiAgICBzZXRBdChpbmRleDogTSwgdmFsdWU6IGJvb2xlYW4pOiB2b2lkO1xuICAgIGdldEF0KGluZGV4OiBNKTogYm9vbGVhbjtcbiAgICBpc1ZhbGlkKGluZGV4OiBNKTogYm9vbGVhbjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkRmxhZ09wZXJhdGlvbnMge1xuXG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4gd2hldGhlciB0aGUgY3VycmVudCBjaGlsZCBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBnZXQ6ICgpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGNoaWxkIG11c3Qgc2V0IGl0c2VsZiBhcyBhY3RpdmUvaW5hY3RpdmUsIHdoYXRldmVyIHRoYXQgZW50YWlscy5cbiAgICAgKiBUaGlzIGNvdWxkIGJlIGFzIHNpbXBsZSBhcyBhIHNldFN0YXRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHNldDogKGFjdGl2ZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB0cnVlIGlmIHRoaXMgY2hpbGQgaXMgYSB2YWxpZCBjYW5kaWRhdGUgdG8gYmUgZmxhZ2dlZCwgYW5kIGZhbHNlIGlmIG5vdC5cbiAgICAgKiBNb3N0IGNoaWxkcmVuIHNob3VsZCByZXR1cm4gdHJ1ZS4gUmV0dXJuaW5nIGZhbHNlIGlzIG9ubHkgdXNlZnVsIHRvIG1hcmsgYSBjaGlsZCBhcyBcImludmFsaWRcIiBpbiBzb21lIHdheS5cbiAgICAgKiBSZW1vdmluZyBhIGNoaWxkIGZyb20gdGhlIGxpc3QgZG9lcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZywgYnV0IHRoaXMgbGV0cyB5b3Uga2VlcCB0aGUgY2hpbGQgYXJvdW5kLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKTogYm9vbGVhbjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZTxSPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBjaGFuZ2VJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsLCBSPjsgLy8oYXJnOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0pID0+IG51bWJlciB8IG51bGw7XG4gICAgLyoqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgYSBjaGlsZCBtb3VudHMvdW5tb3VudHMsIG9yIHdoZW5ldmVyIGNhbGxpbmcgYSBjaGlsZCdzIGlzVmFsaWQoKSB3b3VsZCBjaGFuZ2VcbiAgICAgKiAgKi9cbiAgICByZWV2YWx1YXRlQ2xvc2VzdEZpdDogKCkgPT4gdm9pZDtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldEN1cnJlbnRJbmRleDogKCkgPT4gbnVtYmVyIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBBbiBleHRlbnNpb24gdG8gdXNlTWFuYWdlZENoaWxkcmVuIHRoYXQgaGFuZGxlcyB0aGUgZm9sbG93aW5nIGNvbW1vbiBjYXNlOlxuICogMS4gWW91IGhhdmUgYSBidW5jaCBvZiBjaGlsZHJlblxuICogMi4gQXQgYW55IGdpdmVuIHRpbWUsIG9ubHkgMSBvZiB0aGVtIGlzIFwic2VsZWN0ZWRcIiwgXCJhY3RpdmF0ZWRcIiwgXCJmb2N1c2FibGVcIiwgd2hhdGV2ZXIgKG9yIDAgb2YgdGhlbSwgdGhhdCdzIGNvb2wgdG9vLCBqdXN0IDAgb3IgMSB0aG91Z2gpLlxuICogMy4gVGhlIHBhcmVudCBoYXMgY29udHJvbCBvdmVyIHdobyBpcyBcInNlbGVjdGVkXCIgdmlhIGEgbnVtZXJpY2FsIGluZGV4LlxuICogXG4gKiBUaGlzIGhvb2sgYWxsb3dzIGZvciBtdWNoIGVhc2llciBjb250cm9sIG92ZXIgc2VsZWN0aW9uIG1hbmFnZW1lbnQuXG4gKiBcbiAqIE5vdGUgdGhhdCBiZWNhdXNlIHlvdSBtYXkgd2FudCB0byB1c2UgbXVsdGlwbGUgZmxhZ3Mgd2l0aCB0aGUgc2FtZSBjaGlsZHJlbiwgdGhpcyBob29rICpkb2VzIG5vdCogdXNlIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIVxuICogWW91IG5lZWQgdG8gcGFzcyBpdCB0aGUgZXhpc3RpbmcgY2hpbGRyZW4sIGFuZCB5b3UgbXVzdCBwYXNzIHlvdXIgaW52b2NhdGlvbiBvZiBgdXNlTWFuYWdlZENoaWxkcmVuYCB0aGUgcmV0dXJuZWQgYG9uQ2hpbGRyZW5Nb3VudENoYW5nZWAgaGFuZGxlciFcbiAqIFxuICogQWxzbyBiZWNhdXNlIG9mIHRoYXQsIHRoZSB0eXBlcyBvZiB0aGlzIGZ1bmN0aW9uIGFyZSByYXRoZXIgb2RkLiAgSXQncyBiZXR0ZXIgdG8gc3RhcnQgb2ZmIHVzaW5nIGEgaG9vayB0aGF0IGFscmVhZHkgdXNlcyBhIGZsYWcsIHN1Y2ggYXMgYHVzZVJvdmluZ1RhYkluZGV4YCwgYXMgYW4gZXhhbXBsZS5cbiAqIFxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGlsZHJlbkZsYWc8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyPiwgUj4oeyBnZXRDaGlsZHJlbiwgaW5pdGlhbEluZGV4LCBjbG9zZXN0Rml0LCBvbkluZGV4Q2hhbmdlLCBnZXRBdCwgc2V0QXQsIGlzVmFsaWQsIH06IFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8TSwgUj4pOiBVc2VDaGlsZHJlbkZsYWdSZXR1cm5UeXBlPFI+IHtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VDaGlsZHJlbkZsYWdcIiwgb25JbmRleENoYW5nZSwgZ2V0QXQsIHNldEF0LCBpc1ZhbGlkKTtcblxuICAgIC8vIFRPRE8gKG1heWJlPyk6IEV2ZW4gaWYgdGhlcmUgaXMgYW4gaW5pdGlhbCBpbmRleCwgaXQncyBub3Qgc2V0IHVudGlsIG1vdW50LiBJcyB0aGF0IGZpbmU/XG4gICAgY29uc3QgW2dldEN1cnJlbnRJbmRleCwgc2V0Q3VycmVudEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgbnVtYmVyLCBSPihvbkluZGV4Q2hhbmdlKTtcblxuICAgIGNvbnN0IFtnZXRSZXF1ZXN0ZWRJbmRleCwgc2V0UmVxdWVzdGVkSW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBudW1iZXIsIFI+KG51bGwpO1xuXG4gICAgLy8gICAgY29uc3QgZ2V0Rml0TnVsbFRvWmVybyA9IHVzZVN0YWJsZUdldHRlcihmaXROdWxsVG9aZXJvKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSBhbmQgY2hhbmdlSW5kZXgsIG5vdCBwdWJsaWMgKGJ1dCBjb3VsZCBiZSBJIGd1ZXNzKVxuICAgIGNvbnN0IGdldENsb3Nlc3RGaXQgPSB1c2VDYWxsYmFjaygocmVxdWVzdGVkSW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IGNsb3Nlc3RJbmRleDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuXG4gICAgICAgICAgICBpZiAoaXNWYWxpZChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKGNoaWxkLmluZGV4IC0gcmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIGNoaWxkLmluZGV4IDwgcmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBjaGlsZC5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAxLiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGNoaWxkIHVubW91bnRlZFxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxuICAgIGNvbnN0IHJlZXZhbHVhdGVDbG9zZXN0Rml0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gZ2V0UmVxdWVzdGVkSW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ICE9IG51bGwgJiYgY2xvc2VzdEZpdCAmJiAocmVxdWVzdGVkSW5kZXggIT0gY3VycmVudEluZGV4IHx8IGN1cnJlbnRDaGlsZCA9PSBudWxsIHx8ICFpc1ZhbGlkKGN1cnJlbnRDaGlsZCkpKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudENoaWxkKVxuICAgICAgICAgICAgICAgIHNldEF0KGN1cnJlbnRDaGlsZCwgZmFsc2UpO1xuXG4gICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChjbG9zZXN0Rml0SW5kZXgsIHVuZGVmaW5lZCEpO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdENoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY2xvc2VzdEZpdENoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XG4gICAgICAgICAgICAgICAgc2V0QXQoY2xvc2VzdEZpdENoaWxkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbiAgICBjb25zdCBjaGFuZ2VJbmRleCA9IHVzZUNhbGxiYWNrPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbCwgUj4+KChhcmc6IFBhcmFtZXRlcnM8UGFzc2l2ZVN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsLCBSPj5bMF0sIHJlYXNvbjogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGwsIFI+PlsxXSkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gKGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKGdldFJlcXVlc3RlZEluZGV4KCkpIDogYXJnKSBhcyBNW1wiaW5kZXhcIl07XG4gICAgICAgIC8vaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwgJiYgZ2V0Rml0TnVsbFRvWmVybygpKVxuICAgICAgICAvLyAgICByZXF1ZXN0ZWRJbmRleCA9IDA7XG5cbiAgICAgICAgc2V0UmVxdWVzdGVkSW5kZXgocmVxdWVzdGVkSW5kZXgsIHJlYXNvbiBhcyBSKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT0gcmVxdWVzdGVkSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkSW5kZXg7XG5cbiAgICAgICAgbGV0IG5ld01hdGNoaW5nQ2hpbGQgPSAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChyZXF1ZXN0ZWRJbmRleCkpO1xuICAgICAgICBjb25zdCBvbGRNYXRjaGluZ0NoaWxkID0gKGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCkpO1xuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRWFzeSBjYXNlXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgobnVsbCwgcmVhc29uIGFzIFIpO1xuICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgc2V0QXQob2xkTWF0Y2hpbmdDaGlsZCwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobmV3TWF0Y2hpbmdDaGlsZCAmJiBpc1ZhbGlkKG5ld01hdGNoaW5nQ2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KHJlcXVlc3RlZEluZGV4LCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICAgICAgaWYgKG9sZE1hdGNoaW5nQ2hpbGQpXG4gICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzZXRBdChuZXdNYXRjaGluZ0NoaWxkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4LCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQobmV3TWF0Y2hpbmdDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0QXQobmV3TWF0Y2hpbmdDaGlsZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0Rml0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0KG9sZE1hdGNoaW5nQ2hpbGQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gUnVuIG9uY2UsIG9uIG1vdW50XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2hhbmdlSW5kZXgoaW5pdGlhbEluZGV4ID8/IG51bGwsIHVuZGVmaW5lZCk7XG4gICAgfSwgW10pXG5cbiAgICByZXR1cm4geyBjaGFuZ2VJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQsIGdldEN1cnJlbnRJbmRleCB9O1xufVxuXG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENoaWxkcmVuKGxoczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0sIHJoczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJjaGlsZHJlblwiXSB7XG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByaHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwge30sIGxocywgcmhzKTtcbiAgICB9XG59XG4iLCJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSlmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtlbHNlIGZvcih0IGluIGUpZVt0XSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiO2Y8YXJndW1lbnRzLmxlbmd0aDspKGU9YXJndW1lbnRzW2YrK10pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiLCJpbXBvcnQgeyBkZWZhdWx0IGFzIGNsc3ggfSBmcm9tIFwiY2xzeFwiO1xuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbnR5cGUgQyA9IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcImNsYXNzTmFtZVwiXTtcbi8qKlxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVpciBgY2xhc3NgIGFuZCBgY2xhc3NOYW1lYCBwcm9wZXJ0aWVzLlxuICogRHVwbGljYXRlIGNsYXNzZXMgYXJlIHJlbW92ZWQgKG9yZGVyIGRvZXNuJ3QgbWF0dGVyIGFueXdheSkuXG4gKiBcbiAqIEBwYXJhbSBsaHMgQ2xhc3NlcyBvZiB0aGUgZmlyc3QgY29tcG9uZW50XG4gKiBAcGFyYW0gcmhzIENsYXNzZXMgb2YgdGhlIHNlY29uZCBjb21wb25lbnRcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgY29tYmluZWQgY2xhc3NlcyBmcm9tIGJvdGggYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkQ2xhc3NlcyhsaHNDbGFzczogQywgbGhzQ2xhc3NOYW1lOiBDLCByaHNDbGFzczogQywgcmhzQ2xhc3NOYW1lOiBDKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcblxuICAgIC8vIE5vdGU6IEZvciB0aGUgc2FrZSBvZiBmb3J3YXJkIGNvbXBhdGliaWxpdHksIHRoaXMgZnVuY3Rpb24gaXMgbGFiZWxsZWQgYXNcbiAgICAvLyBhIGhvb2ssIGJ1dCBhcyBpdCB1c2VzIG5vIG90aGVyIGhvb2tzIGl0IHRlY2huaWNhbGx5IGlzbid0IG9uZS5cblxuICAgIGlmIChsaHNDbGFzcyB8fCByaHNDbGFzcyB8fCBsaHNDbGFzc05hbWUgfHwgcmhzQ2xhc3NOYW1lKSB7XG4gICAgICAgIGNvbnN0IGxoc0NsYXNzZXMgPSBjbHN4KGxoc0NsYXNzLCBsaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgY29uc3QgcmhzQ2xhc3NlcyA9IGNsc3gocmhzQ2xhc3MsIHJoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xuICAgICAgICBjb25zdCBhbGxDbGFzc2VzID0gbmV3IFNldChbLi4uQXJyYXkuZnJvbShsaHNDbGFzc2VzKSwgLi4uQXJyYXkuZnJvbShyaHNDbGFzc2VzKV0pXG5cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYWxsQ2xhc3Nlcykuam9pbihcIiBcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGgsIFJlZiwgUmVmQ2FsbGJhY2ssIFJlZk9iamVjdCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWY8VD4oaW5zdGFuY2U6IFQgfCBudWxsLCByZWY6IFJlZjxUPiB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgIChyZWYgYXMgUmVmT2JqZWN0PFQgfCBudWxsPikuY3VycmVudCA9IGluc3RhbmNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZhbHNlLCBcIlVua25vd24gcmVmIHR5cGUgZm91bmQgdGhhdCB3YXMgbmVpdGhlciBhIFJlZkNhbGxiYWNrIG5vciBhIFJlZk9iamVjdFwiKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBDb21iaW5lcyB0d28gcmVmcyBpbnRvIG9uZS4gVGhpcyBhbGxvd3MgYSBjb21wb25lbnQgdG8gYm90aCB1c2UgaXRzIG93biByZWYgKmFuZCogZm9yd2FyZCBhIHJlZiB0aGF0IHdhcyBnaXZlbiB0byBpdC5cbiAqIEBwYXJhbSBsaHMgXG4gKiBAcGFyYW0gcmhzIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRSZWZzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4ocmhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltcInJlZlwiXSwgbGhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltcInJlZlwiXSkge1xuICAgIGNvbnN0IGNvbWJpbmVkOiBSZWZDYWxsYmFjazxFPiA9IHVzZUNhbGxiYWNrKChjdXJyZW50OiBFIHwgbnVsbCkgPT4ge1xuICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIGxocyk7XG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcbiAgICB9LCBbbGhzLCByaHNdKTtcblxuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkITtcbiAgICB9XG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJocyE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaHMhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5cbmZ1bmN0aW9uIHN0eWxlU3RyaW5nVG9PYmplY3Qoc3R5bGU6IHN0cmluZyk6IGguSlNYLkNTU1Byb3BlcnRpZXMge1xuICAgIC8vIFRPRE86IFRoaXMgc3Vja3MgRDpcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHN0eWxlLnNwbGl0KFwiO1wiKS5tYXAoc3RhdGVtZW50ID0+IHN0YXRlbWVudC5zcGxpdChcIjpcIikpKSBhcyB1bmtub3duIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XG59XG5cbi8qKlxuICogTWVyZ2VzIHR3byBzdHlsZSBvYmplY3RzLCByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAqIFxuICogQHBhcmFtIHN0eWxlIFRoZSB1c2VyLWdpdmVuIHN0eWxlIHByb3AgZm9yIHRoaXMgY29tcG9uZW50XG4gKiBAcGFyYW0gb2JqIFRoZSBDU1MgcHJvcGVydGllcyB5b3Ugd2FudCBhZGRlZCB0byB0aGUgdXNlci1naXZlbiBzdHlsZVxuICogQHJldHVybnMgQSBDU1Mgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgb2YgYm90aCBvYmplY3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkU3R5bGVzKGxoczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wic3R5bGVcIl0sIHJoczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wic3R5bGVcIl0pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSB7XG5cbiAgICAvLyBFYXN5IGNhc2UsIHdoZW4gdGhlcmUgYXJlIG5vIHN0eWxlcyB0byBtZXJnZSByZXR1cm4gbm90aGluZy5cbiAgICBpZiAoIWxocyAmJiAhcmhzKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR5cGVvZiBsaHMgIT0gdHlwZW9mIHJocykge1xuICAgICAgICAvLyBFYXN5IGNhc2VzLCB3aGVuIG9uZSBpcyBudWxsIGFuZCB0aGUgb3RoZXIgaXNuJ3QuXG4gICAgICAgIGlmIChsaHMgJiYgIXJocylcbiAgICAgICAgICAgIHJldHVybiBsaHM7XG4gICAgICAgIGlmICghbGhzICYmIHJocylcbiAgICAgICAgICAgIHJldHVybiByaHM7XG5cbiAgICAgICAgLy8gVGhleSdyZSBib3RoIG5vbi1udWxsIGJ1dCBkaWZmZXJlbnQgdHlwZXMuXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZyB0eXBlIHRvIGFuIG9iamVjdCBiYWcgdHlwZSBhbmQgcnVuIGl0IGFnYWluLlxuICAgICAgICBpZiAobGhzICYmIHJocykge1xuICAgICAgICAgICAgLy8gKHVzZU1lcmdlZFN0eWxlcyBpc24ndCBhIHRydWUgaG9vayAtLSB0aGlzIGlzbid0IGEgdmlvbGF0aW9uKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKHN0eWxlU3RyaW5nVG9PYmplY3QobGhzIGFzIHN0cmluZyksIHJocykgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmhzID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyhsaHMsIHN0eWxlU3RyaW5nVG9PYmplY3QocmhzIGFzIHN0cmluZykpIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2dpYz8/P1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFRoZXkncmUgYm90aCBzdHJpbmdzLCBqdXN0IGNvbmNhdGVuYXRlIHRoZW0uXG4gICAgaWYgKHR5cGVvZiBsaHMgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gYCR7bGhzfTske3JocyA/PyBcIlwifWAgYXMgdW5rbm93biBhcyBzdHJpbmc7XG4gICAgfVxuXG4gICAgLy8gVGhleSdyZSBib3RoIG9iamVjdHMsIGp1c3QgbWVyZ2UgdGhlbS5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4obGhzID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxuICAgICAgICAuLi4ocmhzID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXG4gICAgfSBhcyB1bmtub3duIGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcbn1cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkQ2hpbGRyZW4gfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNoaWxkcmVuXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRDbGFzc2VzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1jbGFzc2VzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1yZWZzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRTdHlsZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXN0eWxlc1wiO1xuXG5sZXQgbG9nID0gY29uc29sZS53YXJuO1xuXG4vKlxudHlwZSBJc0VtcHR5T2JqZWN0PFQ+ID0gW2tleW9mIFRdIGV4dGVuZHMgW25ldmVyXT8gdHJ1ZSA6IGZhbHNlO1xuXG5leHBvcnQgdHlwZSBFeHRyYWN0ZWRQcm9wczxPIGV4dGVuZHMge30+ID0geyBbSyBpbiBrZXlvZiBPXTogUGljazxPW0tdLCAoXCJwcm9wc1N0YWJsZVwiIHwgXCJwcm9wc1Vuc3RhYmxlXCIpICYga2V5b2YgT1tLXT4gfTtcblxuY29uc3QgbzogRXh0cmFjdGVkUHJvcHM8VXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlPGFueSwgYW55Pj4gPSB7XG4gICAgYXNDaGlsZFJvd09mVGFibGU6IHtcblxuICAgIH0sXG4gICAgYXNQYXJlbnRSb3dPZkNlbGxzOiB7fVxufSovXG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVMb2dnaW5nUHJvcENvbmZsaWN0cyhsb2cyOiB0eXBlb2YgY29uc29sZVtcImxvZ1wiXSkge1xuICAgIGxvZyA9IGxvZzJcbn1cblxuXG4vKipcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlbSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxuICogXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxuICogQHBhcmFtIGxoczIgXG4gKiBAcGFyYW0gcmhzMiBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiguLi5hbGxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSkge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1lcmdlZFByb3BzXCIsIGFsbFByb3BzLmxlbmd0aCk7XG4gICAgbGV0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7fTtcbiAgICBmb3IgKGxldCBuZXh0UHJvcHMgb2YgYWxsUHJvcHMpIHtcbiAgICAgICAgcmV0ID0gdXNlTWVyZ2VkUHJvcHMyPEU+KHJldCwgbmV4dFByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG5jb25zdCBrbm93bnMgPSBuZXcgU2V0PHN0cmluZz4oW1wiY2hpbGRyZW5cIiwgXCJyZWZcIiwgXCJjbGFzc05hbWVcIiwgXCJjbGFzc1wiLCBcInN0eWxlXCJdKVxuXG5mdW5jdGlvbiBtZXJnZVVua25vd24oa2V5OiBzdHJpbmcsIGxoc1ZhbHVlOiB1bmtub3duLCByaHNWYWx1ZTogdW5rbm93bikge1xuXG4gICAgaWYgKHR5cGVvZiBsaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cbiAgICAgICAgLy8gVGhleSdyZSBib3RoIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBtZXJnZWQgKG9yIG9uZSdzIGEgZnVuY3Rpb24gYW5kIHRoZSBvdGhlcidzIG51bGwpLlxuICAgICAgICAvLyBOb3QgYW4gKmVhc3kqIGNhc2UsIGJ1dCBhIHdlbGwtZGVmaW5lZCBvbmUuXG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlRnVuY3Rpb25zKGxoc1ZhbHVlIGFzIG5ldmVyLCByaHNWYWx1ZSBhcyBuZXZlcik7XG4gICAgICAgIHJldHVybiBtZXJnZWQgYXMgbmV2ZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBVaC4uLndlJ3JlIGhlcmUgYmVjYXVzZSBvbmUgb2YgdGhlbSdzIG51bGwsIHJpZ2h0P1xuICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbCAmJiByaHNWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmhzVmFsdWUgPT09IG51bGwgJiYgbGhzVmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICBlbHNlIGlmIChyaHNWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGxoc1ZhbHVlIGFzIG5ldmVyO1xuICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XG4gICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVZ2guXG4gICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke2tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xuICAgICAgICAgICAgcmV0dXJuIHJoc1ZhbHVlIGFzIG5ldmVyXG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uLlxuICogXG4gKiBUaGlzIGlzIG9uZSBvZiB0aGUgbW9zdCBjb21tb25seSBjYWxsZWQgZnVuY3Rpb25zIGluIHRoaXMgYW5kIGNvbnN1bWVyIGxpYnJhcmllcyxcbiAqIHNvIGl0IHRyYWRlcyBhIGJpdCBvZiByZWFkYWJpbGl0eSBmb3Igc3BlZWQgKGkuZS4gd2UgZG9uJ3QgZGVjb21wb3NlIG9iamVjdHMgYW5kIGp1c3QgZG8gcmVndWxhciBwcm9wZXJ0eSBhY2Nlc3MsIGl0ZXJhdGUgd2l0aCBgZm9yLi4uaW5gLCBpbnN0ZWFkIG9mIGBPYmplY3QuZW50cmllc2AsIGV0Yy4pXG4gKi9cbmZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzMjxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGxoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIHJoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XG5cbiAgICBcbiAgICBjb25zdCByZXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+ID0ge1xuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLnJlZiwgcmhzQWxsLnJlZiksXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLnN0eWxlLCByaHNBbGwuc3R5bGUpLFxuICAgICAgICBjbGFzc05hbWU6IHVzZU1lcmdlZENsYXNzZXMobGhzQWxsW1wiY2xhc3NcIl0sIGxoc0FsbC5jbGFzc05hbWUsIHJoc0FsbFtcImNsYXNzXCJdLCByaHNBbGwuY2xhc3NOYW1lKSxcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbC5jaGlsZHJlbiwgcmhzQWxsLmNoaWxkcmVuKSxcbiAgICB9IGFzIGFueTtcblxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xuICAgIGlmIChyZXQuc3R5bGUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5zdHlsZTtcbiAgICBpZiAocmV0LmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNsYXNzTmFtZTtcbiAgICBpZiAocmV0W1wiY2xhc3NcIl0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldFtcImNsYXNzXCJdO1xuICAgIGlmIChyZXQuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jaGlsZHJlbjtcblxuICAgIGZvciAoY29uc3QgbGhzS2V5VSBpbiBsaHNBbGwpIHtcbiAgICAgICAgY29uc3QgbGhzS2V5ID0gbGhzS2V5VSBhcyBrZXlvZiB0eXBlb2YgbGhzQWxsO1xuICAgICAgICBpZiAoa25vd25zLmhhcyhsaHNLZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldFtsaHNLZXldID0gbGhzQWxsW2xoc0tleV07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCByaHNLZXlVIGluIHJoc0FsbCkge1xuICAgICAgICBjb25zdCByaHNLZXkgPSByaHNLZXlVIGFzIGtleW9mIHR5cGVvZiByaHNBbGw7XG4gICAgICAgIGlmIChrbm93bnMuaGFzKHJoc0tleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmV0W3Joc0tleV0gPSBtZXJnZVVua25vd24ocmhzS2V5LCByZXRbcmhzS2V5XSwgcmhzQWxsW3Joc0tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG5cbn1cblxuZnVuY3Rpb24gbWVyZ2VGdW5jdGlvbnM8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55LCBVIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KGxoczogVCB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogVSB8IG51bGwgfCB1bmRlZmluZWQpIHtcblxuICAgIGlmICghbGhzKVxuICAgICAgICByZXR1cm4gcmhzO1xuICAgIGlmICghcmhzKVxuICAgICAgICByZXR1cm4gbGhzO1xuXG4gICAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCBydiA9IHJocyguLi5hcmdzKTtcblxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbHYsIHJ2XSk7XG4gICAgfTtcbn1cblxuLypcbmZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+Pihwcm9wczogUCkge1xuXG4gICAgY29uc3QgaWQwOiBHZW5lcmljR2V0PHt9LCBcImlkXCIsIHN0cmluZz4gPSBcIlwiO1xuICAgIGNvbnN0IGlkMzogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGlkNDogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGlkNTogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGlkNjogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xuICAgIC8vY29uc3QgaWQyOiBaaXBTaW5nbGU8c3RyaW5nIHwgdW5kZWZpbmVkLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGlkMTogWmlwT2JqZWN0PHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB7IGlkOiB1bmRlZmluZWQgfTtcblxuICAgIHR5cGUgTTEgPSBHZW5lcmljR2V0PFAsIFwic3R5bGVcIiwgc3RyaW5nPjtcbiAgICB0eXBlIE0yID0gR2VuZXJpY0dldDx7fSwgXCJzdHlsZVwiLCBzdHJpbmc+O1xuICAgIGNvbnN0IG0xOiBNMSA9IFwiXCI7XG4gICAgY29uc3QgbTI6IE0xID0gdW5kZWZpbmVkO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIEJlY2F1c2UgbnVtYmVyIGlzbid0IGFzc2lnbmFibGUgdG8gc3RyaW5nXG4gICAgY29uc3QgbTM6IE0xID0gMDtcblxuICAgIGNvbnN0IG00OiBNMiA9IFwiXCI7XG4gICAgY29uc3QgbTU6IE0yID0gdW5kZWZpbmVkO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIEJlY2F1c2UgbnVtYmVyIGlzbid0IGFzc2lnbmFibGUgdG8gc3RyaW5nXG4gICAgY29uc3QgbTY6IE0yID0gMDtcblxuICAgIGNvbnN0IHAxOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7fSwgeyBpZDogc3RyaW5nIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgeyBpZDogXCJzdHJpbmdcIiB9KTtcbiAgICBjb25zdCBwMjogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwgeyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IHN0cmluZyB9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoeyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IFwic3RyaW5nXCIgfSk7XG4gICAgY29uc3QgcDM6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfSk7XG4gICAgY29uc3QgcDQ6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7fT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7fSk7XG4gICAgY29uc3QgcDUgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7fSk7XG4gICAgY29uc3QgcDYgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiB1bmRlZmluZWQgfSk7XG4gICAgY29uc3QgcDcgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiBcInN0cmluZ1wiIH0pO1xuXG5cbiAgICBwMS5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHAyLmlkPy5jb25jYXQoXCJcIik7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxuICAgIHAzLmlkPy5jb25jYXQoXCJcIik7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxuICAgIHA0LmlkPy5jb25jYXQoXCJcIik7XG5cblxuICAgIHA1LmlkPy5jb25jYXQoXCJcIik7XG4gICAgcDYuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICBwNy5pZD8uY29uY2F0KFwiXCIpO1xuXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxuICAgIHA1LmlkLmNvbmNhdChcIlwiKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXG4gICAgcDYuaWQuY29uY2F0KFwiXCIpO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcbiAgICBwNy5pZC5jb25jYXQoXCJcIik7XG5cblxuICAgIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjZXB0c05ldmVyKHA1LmFsbG93RnVsbFNjcmVlbik7XG4gICAgfVxuXG5cbiAgICBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cbiAgICBlbHNlIGlmIChwNi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjY2VwdHNOZXZlcihwNi5hbGxvd0Z1bGxTY3JlZW4pO1xuICAgIH1cblxuXG4gICAgaWYgKHA3LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxuICAgIGVsc2UgaWYgKHA3LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxuICAgIGVsc2Uge1xuICAgICAgICBhY2NlcHRzTmV2ZXIocDcuYWxsb3dGdWxsU2NyZWVuKTtcbiAgICB9XG5cblxuICAgIC8vIE1ha2Ugc3VyZSBpdCB3b3JrcyByZWN1cnNpdmVseVxuICAgIGNvbnN0IHIxYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAxKTtcbiAgICBjb25zdCByMWIgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwMSk7XG4gICAgY29uc3QgcjJhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDIpO1xuICAgIGNvbnN0IHIyYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAyKTtcbiAgICBjb25zdCByM2EgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwMyk7XG4gICAgY29uc3QgcjNiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDMpO1xuICAgIGNvbnN0IHI0YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA0KTtcbiAgICBjb25zdCByNGIgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwNCk7XG4gICAgY29uc3QgcjVhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDUpO1xuICAgIGNvbnN0IHI1YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA1KTtcbiAgICBjb25zdCByNmEgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwNik7XG4gICAgY29uc3QgcjZiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDYpO1xuICAgIGNvbnN0IHI3YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA3KTtcbiAgICBjb25zdCByN2IgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwNyk7XG5cblxuICAgIHIxYS5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHIxYi5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHIyYS5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHIyYi5pZD8uY29uY2F0KFwiXCIpO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxuICAgIHIzYS5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHIzYi5pZD8uY29uY2F0KFwiXCIpO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcbiAgICByNGEuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICByNGIuaWQ/LmNvbmNhdChcIlwiKTtcblxuXG4gICAgcjVhLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcjViLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcjZhLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcjZiLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcjdhLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcjdiLmlkPy5jb25jYXQoXCJcIik7XG5cbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXG4gICAgcjVhLmlkLmNvbmNhdChcIlwiKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXG4gICAgcjViLmlkLmNvbmNhdChcIlwiKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXG4gICAgcjZhLmlkLmNvbmNhdChcIlwiKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXG4gICAgcjZiLmlkLmNvbmNhdChcIlwiKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXG4gICAgcjdhLmlkLmNvbmNhdChcIlwiKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXG4gICAgcjdiLmlkLmNvbmNhdChcIlwiKTtcblxuXG4gICAgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxuICAgIGVsc2Uge1xuICAgICAgICBhY2NlcHRzTmV2ZXIocjVhLmFsbG93RnVsbFNjcmVlbik7XG4gICAgfVxuXG5cbiAgICBpZiAocjViLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjY2VwdHNOZXZlcihyNWIuYWxsb3dGdWxsU2NyZWVuKTtcbiAgICB9XG5cblxuICAgIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XG4gICAgZWxzZSBpZiAocjZhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XG4gICAgZWxzZSBpZiAocjZhLmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjZXB0c05ldmVyKHI2YS5hbGxvd0Z1bGxTY3JlZW4pO1xuICAgIH1cblxuXG4gICAgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxuICAgIGVsc2Uge1xuICAgICAgICBhY2NlcHRzTmV2ZXIocjZiLmFsbG93RnVsbFNjcmVlbik7XG4gICAgfVxuXG5cbiAgICBpZiAocjdhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjY2VwdHNOZXZlcihyN2EuYWxsb3dGdWxsU2NyZWVuKTtcbiAgICB9XG5cblxuICAgIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XG4gICAgZWxzZSBpZiAocjdiLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XG4gICAgZWxzZSBpZiAocjdiLmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjZXB0c05ldmVyKHI3Yi5hbGxvd0Z1bGxTY3JlZW4pO1xuICAgIH1cblxufVxuZnVuY3Rpb24gYWNjZXB0c05ldmVyKG46IG5ldmVyKSB7fVxuKi8iLCJpbXBvcnQgeyBoLCBQcmVhY3RET01BdHRyaWJ1dGVzIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG4vKipcbiAqIFRoaXMgaXMgdXNlZCB0byBzZWxlY3QgKmp1c3QqIHRoZSB0eXBlZCBhZGRFdmVudExpc3RlbmVyIFxuICogYW5kIG5vdCB0aGUgZ2VuZXJpYyBcIkknbGwgYWNjZXB0IGFueSBzdHJpbmcgYW5kIGFueSBoYW5kbGVyXCIgb25lLlxuICogXG4gKiBUT0RPOiBUaGlzIFwiXCJcIndvcmtzXCJcIlwiIGJ1dCBpdCdzIG5vdCBncmVhdCBhbmQgaW1wbGljaXRseSByZWxpZXMgb25cbiAqIGxpYi5kb20udHMgYWx3YXlzIGdpdmVpbmcgdGhlIHR3byBvdmVybG9hZHMgaW4gdGhlIHNhbWUgb3JkZXIsIHdpdGggdGhlXG4gKiB0eXBlZCBvbmUgZmlyc3QuICpUaGF0KiBwcm9iYWJseSB3b24ndCBjaGFuZ2UsIGJ1dCBpZiBtb3JlIG92ZXJsb2Fkc1xuICogYXJlIGV2ZXIgYWRkZWQgdGhpcyB3aWxsIG5lZWQgYWRqdXN0bWVudC5cbiAqIFxuICogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mjc2MTE1NiBmb3IgaG93IHNlbGVjdGluZyB0aGUgY29ycmVjdCBvdmVybG9hZCB3b3Jrcy5cbiAqL1xudHlwZSBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczxUPiA9XG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBpbmZlciBSIH0gPyBSIDpcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUikgPT4gYW55ID8gUiA6IFtdO1xuXG4vLyBHZXQganVzdCB0aGUgdHlwZWQgdmVyc2lvbiBvZiBhZGRFdmVudExpc3RlbmVyLCBpZiBpdCBleGlzdHNcbnR5cGUgVHlwZWRBZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSAoLi4uYXJnczogRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8KFRbXCJhZGRFdmVudExpc3RlbmVyXCJdKT4pID0+IHZvaWQ7XG5cbi8vIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIFwiYWRkRXZlbnRMaXN0ZW5lclwiICh0aGUgZXZlbnQgdHlwZSBhcyBhIHN0cmluZylcbnR5cGUgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPiBleHRlbmRzICgodHlwZTogaW5mZXIgSzIsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSzIgOiBzdHJpbmc7XG5cblxuLy8gVE9ETzogVGhpcyBpc24ndCBxdWl0ZSBhYmxlIHRvIG5hcnJvdyBkb3duIHRoZSBleGFjdCBldmVudCB0eXBlIGZvciB1bmtub3duIHJlYXNvbnMuXG4vLyBJbnN0ZWFkIGl0IHJldHVybnMgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIGV2ZW50IHR5cGVzLCB3aGljaCBpcy4uLmZpbmUsIEkgZ3Vlc3MuXG4vLyBJIGRvbid0IGtub3cgd2h5IGBpbmZlciBIYCBpcyBkb2luZyB0aGF0IHdoZW4gdGhlIHR5cGUgc2hvdWxkIGJlIG5hcnJvd2VkIGJ5IGBUYCB0aG91Z2guLi5cbi8vIE5vdGUgdGhhdCB0aGUgdHlwZSBwYXJhbWV0ZXIgaXMgc3RpbGwgdXNlZCwgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBuYXJyb3cgZG93biB0aGUgdHlwZSxcbi8vIGJlY2F1c2Ugb3RoZXJ3aXNlLCBpbnN0ZWFkIG9mIGJlaW5nIGEgdW5pb24gb2YgYWxsIHR5cGVzLCBpdCdzIGp1c3QgYGFueWBcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXI8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+IGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiBpbmZlciBILCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IE5vbk51bGxhYmxlPEg+IDogbmV2ZXI7XG4vLygoVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+ICYgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWQsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpKSBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogKGU6IGluZmVyIEgpID0+IGFueSwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBIIDogRnVuY3Rpb24pIC8qJiAoVCBleHRlbmRzIGtleW9mIEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcD8gR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwW1RdIDogKGU6IEV2ZW50KSA9PiB2b2lkKSovO1xuXG50eXBlIFBhcmFtZXRlcnMyPFQgZXh0ZW5kcyAoRXZlbnRMaXN0ZW5lck9iamVjdCB8ICgoLi4uYXJnczogYW55KSA9PiBhbnkpKT4gPVxuICAgIFQgZXh0ZW5kcyBFdmVudExpc3RlbmVyT2JqZWN0ID8gUGFyYW1ldGVyczxUW1wiaGFuZGxlRXZlbnRcIl0+IDpcbiAgICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcjtcblxuXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gUGFyYW1ldGVyczI8VHlwZWRFdmVudEhhbmRsZXI8RSwgVD4+WzBdO1xuXG5cbi8qKlxuICogQWxsb3dzIGF0dGFjaGluZyBhbiBldmVudCBoYW5kbGVyIHRvIGFueSAqbm9uLVByZWFjdCogZWxlbWVudCwgYW5kIHJlbW92aW5nIGl0IHdoZW4gdGhlIGNvbXBvbmVudCB1c2luZyB0aGUgaG9vayB1bm1vdW50cy4gVGhlIGNhbGxiYWNrIGRvZXMgbm90IG5lZWQgdG8gYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxuICogXG4gKiBEdWUgdG8gdHlwaW5nIGxpbWl0YXRpb25zLCB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGxpa2UgdGhpczpcbiAqIFxuICogYHVzZUV2ZW50SGFuZGxlcihlbGVtZW50LCBcImlucHV0XCIpPElucHV0RXZlbnQ+KGUgPT4ge30pYFxuICogXG4gKiBUaGUgdHlwZSBhcmd1bWVudCBpcyBvcHRpb25hbCwgYnV0IG5hcnJvd3MgZG93biB0aGUgdHlwZSBmcm9tIFwiYSB1bmlvbiBvZiBhbGwgZXZlbnRzXCIgdG8gd2hhdGV2ZXIgeW91IHNwZWNpZnksIGFuZCBlcnJvcnMgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAqIFxuICogVGhlcmUgaXMgYSBzZXBhcmF0ZSB2ZXJzaW9uIHRoYXQgYXR0YWNoZXMgZXZlbnQgaGFuZGxlcnMgdG8gYSBzZXQgb2YgcHJvcHMuIFxuICogSXQgdGFrZXMgZGlmZmVyZW50IGV2ZW50IHN0cmluZyB0eXBlcyAob25FdmVudCB2cyBvbmV2ZW50KS5cbiAqIFxuICogQHBhcmFtIHRhcmdldCBBICpub24tUHJlYWN0KiBub2RlIHRvIGF0dGFjaCB0aGUgZXZlbnQgdG8uXG4gKiBAcmV0dXJuc1xuICogKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlcjxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcblxuICAgIC8vIE5vdGUgdG8gc2VsZjogVGhlIHR5cGluZyBkb2Vzbid0IGltcHJvdmUgZXZlbiBpZiB0aGlzIGlzIHNwbGl0IHVwIGludG8gYSBzdWItZnVuY3Rpb24uXG4gICAgLy8gTm8gbWF0dGVyIHdoYXQsIGl0IHNlZW1zIGltcG9zc2libGUgdG8gZ2V0IHRoZSBoYW5kbGVyJ3MgZXZlbnQgb2JqZWN0IHR5cGVkIHBlcmZlY3RseS5cbiAgICAvLyBJdCBzZWVtcyBsaWtlIGl0J3MgZ3VhcmFudGVlZCB0byBhbHdheXMgYmUgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIHR1cGVzLlxuICAgIC8vIEFnYWluLCBubyBtYXR0ZXIgd2hhdCBjb21iaW5hdGlvbiBvZiBzdWItIG9yIHN1Yi1zdWItZnVuY3Rpb25zIHVzZWQuXG5cbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjazxFdmVudExpc3RlbmVyPigoaGFuZGxlciBhcyBhbnkpID8/ICgoKSA9PiB7IH0pKSBhcyAoRXZlbnRMaXN0ZW5lciB8IG51bGwpO1xuICAgIGlmIChoYW5kbGVyID09IG51bGwpXG4gICAgICAgIHN0YWJsZUhhbmRsZXIgPSBudWxsO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbdGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyXSk7XG59XG5cbi8qKlxuICogQW4gYWx0ZXJuYXRpdmUgd2F5IHRvIGFkZCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIGVsZW1lbnQuIFVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpbnRlZ3JhdGluZyAzcmQgcGFydHkgbGlicmFyaWVzIHRoYXQgZXhwZWN0IGEgZ2VuZXJpYyBcImFkZCBldmVudCBoYW5kbGVyXCIgZnVuY3Rpb24uXG4gKiBcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB5b3UgdG8gbW9kaWZ5IGEgc2V0IG9mIHByb3BzIHRvIGFwcGx5IHRoaXMgaGFuZGxlci5cbiAqIFxuICogRm9yIHR5cGluZyByZWFzb25zLCB0aGlzIGZ1bmN0aW9uIGlzIHNwbGl0IGludG8gdHdvLiAgVXNhZ2UgaXMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICogXG4gKiBgYGBcbiAqIGNvbnN0IHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9ID0gdXNlTG9jYWxFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+KCkoXCJvbk1vdXNlRG93blwiLCBlID0+IHsgIH0pO1xuICogY29uc3QgZGl2UHJvcHMgPSB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzKHByb3BzKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYWxIYW5kbGVyPEVsZW1lbnRUeXBlIGV4dGVuZHMgKEhUTUxFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXBdIHwgU1ZHRWxlbWVudFRhZ05hbWVNYXBba2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXBdKT4oKSB7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKDxFdmVudFR5cGUgZXh0ZW5kcyBFeGNsdWRlPGtleW9mIGguSlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+LCBrZXlvZiBQcmVhY3RET01BdHRyaWJ1dGVzPj4odHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBOb25OdWxsYWJsZTxoLkpTWC5ET01BdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPltFdmVudFR5cGVdPikgPT4ge1xuXG4gICAgICAgIGNvbnN0IHN0YWJsZUhhbmRsZXIgPSB1c2VTdGFibGVDYWxsYmFjayhoYW5kbGVyKTtcblxuICAgICAgICBjb25zdCB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFbGVtZW50VHlwZT4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFbGVtZW50VHlwZT4oeyBbdHlwZV06IHN0YWJsZUhhbmRsZXIgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFbGVtZW50VHlwZT4sIHByb3BzKSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFbGVtZW50VHlwZT47XG4gICAgICAgIH0sIFt0eXBlXSk7XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9O1xuXG4gICAgfSwgW10pO1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgcnVuSW1tZWRpYXRlbHksIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFJldHVyblR5cGU8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XG4gICAgcmVmRWxlbWVudFJldHVybjoge1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRFbGVtZW50KCk6IFQgfCBudWxsO1xuICAgICAgICBwcm9wc1N0YWJsZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcbiAgICByZWZFbGVtZW50UGFyYW1ldGVyczoge1xuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbCwgbmV2ZXI+O1xuICAgICAgICBvbk1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XG4gICAgICAgIG9uVW5tb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xuICAgIH1cbn1cblxuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnRQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4ocjogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT4sIC4uLm90aGVyUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W10pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltdIHtcbiAgICByZXR1cm4gW3IucmVmRWxlbWVudFJldHVybi5wcm9wc1N0YWJsZSwgLi4ub3RoZXJQcm9wc107XG59Ki9cblxuLyoqXG4gKiBBbGxvd3MgYWNjZXNzaW5nIHRoZSBlbGVtZW50IGEgcmVmIHJlZmVyZW5jZXMgYXMgc29vbiBhcyBpdCBkb2VzIHNvLlxuICogKlRoaXMgaG9vayBpdHNlbGYgcmV0dXJucyBhIGhvb2sqLS11c2VSZWZFbGVtZW50UHJvcHMgbW9kaWZpZXMgdGhlIHByb3BzIHRoYXQgeW91IHdlcmUgZ29pbmcgdG8gcGFzcyB0byBhbiBIVE1MRWxlbWVudCwgXG4gKiBhZGRpbmcgYSBSZWZDYWxsYmFjayBhbmQgbWVyZ2luZyBpdCB3aXRoIGFueSBleGlzdGluZyByZWYgdGhhdCBleGlzdGVkIG9uIHRoZSBwcm9wcy5cbiAqIFxuICogRG9uJ3QgZm9yZ2V0IHRvIHByb3ZpZGUgdGhlIEVsZW1lbnQgYXMgdGhlIHR5cGUgYXJndW1lbnQhXG4gKiBcbiAqIEByZXR1cm5zIFRoZSBlbGVtZW50LCBhbmQgdGhlIHN1Yi1ob29rIHRoYXQgbWFrZXMgaXQgcmV0cmlldmFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWZFbGVtZW50PFQgZXh0ZW5kcyBFdmVudFRhcmdldD4oYXJnczogVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4pOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiB7XG4gICAgY29uc3QgeyByZWZFbGVtZW50UGFyYW1ldGVyczogeyBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9IH0gPSBhcmdzO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVJlZkVsZW1lbnRcIiwgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQpO1xuXG4gICAgLy8gQ2FsbGVkIChpbmRpcmVjdGx5KSBieSB0aGUgcmVmIHRoYXQgdGhlIGVsZW1lbnQgcmVjZWl2ZXMuXG4gICAgY29uc3QgaGFuZGxlciA9IHVzZUNhbGxiYWNrPE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsLCBuZXZlcj4+KChlLCBwcmV2VmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IG9uRWxlbWVudENoYW5nZT8uKGUsIHByZXZWYWx1ZSk7XG4gICAgICAgIGlmIChwcmV2VmFsdWUpXG4gICAgICAgICAgICBvblVubW91bnQ/LihwcmV2VmFsdWUhKTtcblxuICAgICAgICBpZiAoZSlcbiAgICAgICAgICAgIG9uTW91bnQ/LihlKTtcblxuICAgICAgICByZXR1cm4gY2xlYW51cDtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBMZXQgdXMgc3RvcmUgdGhlIGFjdHVhbCAocmVmZXJlbmNlIHRvKSB0aGUgZWxlbWVudCB3ZSBjYXB0dXJlXG4gICAgY29uc3QgW2dldEVsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPFQgfCBudWxsLCBuZXZlcj4oaGFuZGxlciwgcmV0dXJuTnVsbCwgcnVuSW1tZWRpYXRlbHkpO1xuICAgIGNvbnN0IHByb3BzU3RhYmxlID0gdXNlUmVmPGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+Pih7IHJlZjogc2V0RWxlbWVudCB9KTtcblxuICAgIC8vIFJldHVybiBib3RoIHRoZSBlbGVtZW50IGFuZCB0aGUgaG9vayB0aGF0IG1vZGlmaWVzIFxuICAgIC8vIHRoZSBwcm9wcyBhbmQgYWxsb3dzIHVzIHRvIGFjdHVhbGx5IGZpbmQgdGhlIGVsZW1lbnRcbiAgICByZXR1cm4ge1xuICAgICAgICByZWZFbGVtZW50UmV0dXJuOiB7XG4gICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICAgICAgcHJvcHNTdGFibGU6IHByb3BzU3RhYmxlLmN1cnJlbnRcbiAgICAgICAgfVxuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50LCBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycyB9IGZyb20gXCIuLi9vYnNlcnZlcnMvdXNlLWFjdGl2ZS1lbGVtZW50XCI7XG5pbXBvcnQgeyBhc3NlcnRFbXB0eU9iamVjdCB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlR2xvYmFsSGFuZGxlciB9IGZyb20gXCIuLi9kb20taGVscGVycy91c2UtZXZlbnQtaGFuZGxlclwiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL2RvbS1oZWxwZXJzL3VzZS1yZWYtZWxlbWVudFwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cbi8qKlxuICogSW4gZ2VuZXJhbCwgZWFjaCBzb2Z0IGRpc21pc3MgaG9vayB0YWtlcyBhbiBgb3BlbmAgYW5kIGFuIGBvbkNsb3NlYCBwcm9wLlxuICogXG4gKiBgb3BlbmAgaW4gYWxsIGNhc2VzIHJlZmVyZXMgdG8gYm90aCB3aGV0aGVyIG9yIG5vdCB0aGUgY29udHJvbGxlZCBzdXJmYWNlIGlzIGN1cnJlbnRseSBiZWluZyBzaG93bixcbiAqIGJ1dCBhbHNvIHdoZXRoZXIgdGhhdCBwYXJ0aWN1bGFyIG1ldGhvZCBvZiBzb2Z0IGRpc21pc3MgaXMgZW5hYmxlZCBvciBub3QuXG4gKiBcbiAqIEUuRy4gSWYgYGVzY2FwZWAga2V5IGRpc21pc3NpbmcgaXMgZGlzYWJsZWQsIGp1c3QgaGF2ZSBgb3BlbmAgZmFsc2UgYXQgYWxsIHRpbWVzIGZvciBgZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnNgLlxuICovXG5jb25zdCBfZHVtbXkgPSAwO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUVzY2FwZURpc21pc3NQYXJhbWV0ZXJzPFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICByZWZFbGVtZW50UG9wdXBSZXR1cm46IFBpY2s8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8UG9wdXBFbGVtZW50PltcInJlZkVsZW1lbnRSZXR1cm5cIl0sIFwiZ2V0RWxlbWVudFwiPjtcbiAgICBlc2NhcGVEaXNtaXNzUGFyYW1ldGVyczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRpc21pc3NlZC5cbiAgICAgICAgICogXG4gICAgICAgICAqIFByZXN1bWFibHkgeW91J2xsIHNldCBzb21lIHN0YXRlIHRoYXQgY2hhbmdlcyBgb3BlbmAgdG8gZmFsc2UgZHVyaW5nIHRoaXMsIG90aGVyd2lzZSBpdCdzIG5vdCBhIHNvZnQgZGlzbWlzcywgYnV0IHlvdSBjYW4gZG8gd2hhdGV2ZXIgeW91IHdhbnQgSSBndWVzcy5cbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xvc2UocmVhc29uOiBcImVzY2FwZVwiIHwgXCJsb3N0LWZvY3VzXCIpOiB2b2lkO1xuXG4gICAgICAgIC8qKiBcbiAgICAgICAgICogV2hldGhlciB0aGUgc3VyZmFjZSBjb250cm9sbGVkIGJ5IHRoZSBgRXNjYXBlYCBrZXkgaXMgY3VycmVudGx5IG9wZW4uIFxuICAgICAgICAgKiBDYW4gYWxzbyBiZSBgZmFsc2VgIHRvIGZvcmNlIHRoZSBgRXNjYXBlYCBrZXkgdG8gZG8gbm90aGluZy5cbiAgICAgICAgICovXG4gICAgICAgIG9wZW46IGJvb2xlYW47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBlc2NhcGUga2V5IGV2ZW50IGhhbmRsZXIgaXMgYXR0YWNoZWQgb250byB0aGUgd2luZG93LCBzbyB3ZSBuZWVkIHRvIGtub3cgd2hpY2ggd2luZG93LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2luZG93KCk6IFdpbmRvdztcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoaXMgZnJvbSBjb250ZXh0IHNvbWV3aGVyZSwgYW5kIGluY3JlbWVudCBpdCBpbiB0aGF0IGNvbnRleHQuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBJZiBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgUHJlYWN0IGFyZSBvbiB0aGUgcGFnZSwgdHJlZSBkZXB0aCBpcyB1c2VkIGFzIGEgdGllYnJlYWtlclxuICAgICAgICAgKi9cbiAgICAgICAgcGFyZW50RGVwdGg6IG51bWJlcjtcbiAgICB9XG59XG5cblxuY29uc3QgTWFnaWNXaW5kb3dLZXkgPSAoXCJfX3ByZWFjdC1wcm9wLWhlbHBlcnMtZXNjYXBlLWtleS1kaXNtaXNzX19cIikgYXMga2V5b2YgV2luZG93O1xuaW50ZXJmYWNlIFdpbmRvd0VzY2FwZUtleUluZm8ge1xuICAgIG1pY3JvdGFza1F1ZXVlZDogYm9vbGVhbjtcbiAgICBlbGVtZW50UXVldWU6IE1hcDxFbGVtZW50LCB7IG9uQ2xvc2U6ICgpID0+IHZvaWQsIGRlcHRoOiBudW1iZXIsIHRyZWVEZXB0aDogbnVtYmVyIH0+Oy8vKEVsZW1lbnQgfCBudWxsKVtdO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50RGVwdGgoZWxlbWVudDogRWxlbWVudCkge1xuICAgIGxldCBkZXB0aCA9IDA7XG4gICAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBkZXB0aDtcbn1cblxuLyoqXG4gKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBhIG1vZGFsLWxpa2Ugc29mdC1kaXNtaXNzIGludGVyYWN0aW9uLlxuICogXG4gKiBUaGF0IGlzLCBhbnkgY2xpY2tzIG9yIHRhcHMgb3V0c2lkZSBvZiB0aGUgZ2l2ZW4gY29tcG9uZW50LCBcbiAqIG9yIGFueSB0aW1lIHRoZSBFc2NhcGUga2V5IGlzIHByZXNzZWQgd2l0aGluIHRoZSBjb21wb25lbnQsXG4gKiAod2l0aCB2YXJpb3VzIGJyb3dzZXIgb2RkaXRpZXMgcmVnYXJkaW5nIGNsaWNrcyBvbiBibGFuayBvciBpbmVydCBhcmVhcyBoYW5kbGVkKVxuICogdGhlIGNvbXBvbmVudCB3aWxsIHJlcXVlc3QgdG8gY2xvc2UgaXRzZWxmLlxuICogXG4gKiBPZiBjb3Vyc2UsIGlmIHlvdSBkb24ndCBkbyBhbnl0aGluZyBpbiB0aGUgYG9uQ2xvc2VgIGZ1bmN0aW9uLFxuICogaXQgd29uJ3QgYmUgYSBzb2Z0IGRpc21pc3MgYW55bW9yZS5cbiAqIFxuICogSGFuZGxlcyBldmVudHMgZm9yIHByZXNzaW5nIHRoZSBgRXNjYXBlYCBrZXkgdG8gY2xvc2UgdGhlIGFueSBjdXJyZW50bHkgb3BlbiBkaWFsb2dzLCB0b29sdGlwcywgbWVudXMsIHBvcHVwcywgZXRjLlxuICogXG4gKiBPbmUgcHJlc3Mgb2YgdGhlIGBFc2NhcGVgIGtleSBpcyBndWFyYW50ZWVkIHRvIG9ubHkgY2FsbCBgb25DbG9zZWAgZm9yICpvbmx5IG9uZSogY29tcG9uZW50LCBhbmQgaXQgaXMgY2FsbGVkIG9uIHRoZSBjb21wb25lbnQgZGVlcGVzdCBpbiB0aGUgRE9NIHRyZWUsIGRpZmZlcmVudGlhdGVkIGJ5IHBhc3NpbmcgY29udGV4dCBpbmZvcm1hdGlvbiBiZXR3ZWVuIHBhcmVudCBhbmQgY2hpbGQuXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVzY2FwZURpc21pc3M8UG9wdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBlc2NhcGVEaXNtaXNzUGFyYW1ldGVyczogeyBvbkNsb3NlLCBvcGVuLCBnZXRXaW5kb3c6IHVuc3RhYmxlR2V0V2luZG93LCBwYXJlbnREZXB0aCwgLi4udm9pZDEgfSwgcmVmRWxlbWVudFBvcHVwUmV0dXJuOiB7IGdldEVsZW1lbnQsIC4uLnZvaWQyIH0gfTogVXNlRXNjYXBlRGlzbWlzc1BhcmFtZXRlcnM8UG9wdXBFbGVtZW50Pik6IHZvaWQge1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQxKTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkMik7XG5cbiAgICBjb25zdCBzdGFibGVPbkNsb3NlID0gdXNlU3RhYmxlQ2FsbGJhY2sob25DbG9zZSk7XG4gICAgY29uc3QgZ2V0V2luZG93ID0gdXNlU3RhYmxlQ2FsbGJhY2sodW5zdGFibGVHZXRXaW5kb3cpO1xuICAgIGNvbnN0IGdldERlcHRoID0gdXNlU3RhYmxlR2V0dGVyKHBhcmVudERlcHRoICsgMSk7XG5cblxuICAgIC8vIFdoZW4gdGhpcyBjb21wb25lbnQgb3BlbnMsIGFkZCBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGZpbmRzIHRoZSBkZWVwZXN0IG9wZW4gc29mdCBkaXNtaXNzIGVsZW1lbnQgdG8gYWN0dWFsbHkgZGlzbWlzcy5cbiAgICAvLyBPbmx5IG9wZW5lZCBjb21wb25lbnRzIHdpbGwgYWRkIGV2ZW50IGhhbmRsZXJzLCBhbmQgd2lsbCByZW1vdmUgdGhlbSBvbmNlIGNsb3NlZC5cbiAgICAvLyBUaGUgcmVhc29uIHRoaXMgaXMgc28gY29tcGxpY2F0ZWQgaXMgYmVjYXVzZTpcbiAgICAvLyAxLiBXZSBtdXN0IG9ubHkgY2xvc2Ugb25lIHNvZnQgZGlzbWlzcyBjb21wb25lbnQgYXQgYSB0aW1lLiAgSWYgdGhlcmUncyBhIHRvb2x0aXAgaW4gYSBwb3B1cCwgdGhlIHRvb2x0aXAgbXVzdCBiZSBkaXNtaXNzZWQuXG4gICAgLy8gMi4gYGtleWRvd25gIGV2ZW50cyBkb24ndCBqdXN0IHdvcmsgb24gYXJiaXRyYXJ5IGVsZW1lbnRzLCBmb3Igb3VyIHB1cnBvc2VzIHRoZXkgbXVzdCBiZSBmcm9tIHRoZSBgd2luZG93YC4gU28gd2UgY2FuJ3QgcmVseSBvbiBub3JtYWwgY2FwdHVyaW5nIG9yIGJ1YmJsaW5nIGJlaGF2aW9yIG9uIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAvLyAzLiBFdmVudCBoYW5kbGVycyBhZGRlZCB0byB0aGUgYHdpbmRvd2AgdmlhIGBhZGRFdmVudEhhbmRsZXJgIGFyZSBjYWxsZWQgaW4gdGhlIG9yZGVyIG9mIHJlZ2lzdHJhdGlvbiwgd2hpY2ggaXMgY29tcGxldGVseSBhdCBvZGRzIHdpdGggIzEuXG4gICAgLy9cbiAgICAvLyBTbyBhbGwgc29mdCBkaXNtaXNzIGNvbXBvbmVudHMgbGlzdGVuIGZvciBhIGtleWRvd24gb2YgRXNjYXBlLCBcbiAgICAvLyB0aGVuIHRoZSBmaXJzdCBvbmUgdG8gZG8gc28gd2lsbCB3YWl0IGZvciBhIG1pY3JvdGFzaywgXG4gICAgLy8gdGhlbiBmaW5kIHRoZSBkZWVwZXN0IGVsZW1lbnQgaW4gdGhlIGRvY3VtZW50IHRyZWUgdG8gZGlzbWlzcyBvZiBhbGwgb2YgdGhvc2UgY29tcG9uZW50cyBjdXJyZW50bHkgb3Blbi5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3cgPSBnZXRXaW5kb3coKTtcbiAgICAgICAgKHdpbmRvdyBhcyBhbnkpW01hZ2ljV2luZG93S2V5XSA/Pz0gKHsgbWljcm90YXNrUXVldWVkOiBmYWxzZSwgZWxlbWVudFF1ZXVlOiBuZXcgTWFwKCkgfSBhcyBXaW5kb3dFc2NhcGVLZXlJbmZvKVxuICAgICAgICBjb25zdCBpbmZvID0gd2luZG93W01hZ2ljV2luZG93S2V5XSBhcyBXaW5kb3dFc2NhcGVLZXlJbmZvO1xuXG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQWRkaW5nIGhhbmRsZXIgZm9yIGRlcHRoPSR7Z2V0RGVwdGgoKX1gKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVyLCB7IGNhcHR1cmU6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFJlbW92aW5nIGhhbmRsZXIgZm9yIGRlcHRoPSR7Z2V0RGVwdGgoKX1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGluZm8uZWxlbWVudFF1ZXVlKVxuICAgICAgICAgICAgICAgICAgICBpbmZvLmVsZW1lbnRRdWV1ZS5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuXG5cblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKGU6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChlLmtleSA9PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVzY2FwZSBrZXkgZm9yIGRlcHRoPSR7Z2V0RGVwdGgoKX1gKTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGtub3cgd2hpY2ggb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgc29mdCBkaXNtaXNzZXMgd2lsbCBhY3R1YWxseSBkbyBzb21ldGhpbmcsXG4gICAgICAgICAgICAgICAgLy8gYnV0IE9ORSBvZiB0aGVtIGRlZmluaXRlbHkgd2lsbCxcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBzdG9wIHByb3BhZ2F0aW9uIHRvIGNoaWxkIG5vZGVzLCBidXQgbm90IHRvIGV2ZXJ5b25lIG9uIHRoZSB3aW5kb3cgKHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikuXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblxuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB3aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGUgZWxlbWVudHMgd2lsbCBjYWxsXG4gICAgICAgICAgICAgICAgY29uc3Qgb25DbG9zZTIgPSAoKSA9PiB7IHN0YWJsZU9uQ2xvc2UoXCJlc2NhcGVcIik7IH07XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmVlRGVwdGggPSBnZXRFbGVtZW50RGVwdGgoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcHRoID0gZ2V0RGVwdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5lbGVtZW50UXVldWUuc2V0KGVsZW1lbnQsIHsgZGVwdGgsIG9uQ2xvc2U6IG9uQ2xvc2UyLCB0cmVlRGVwdGggfSk7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICBpZiAoIWluZm8ubWljcm90YXNrUXVldWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8ubWljcm90YXNrUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZWxlbWVudFF1ZXVlIH0gPSBpbmZvO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5taWNyb3Rhc2tRdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uZWxlbWVudFF1ZXVlID0gbmV3IE1hcCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVlcGVzdERlcHRoID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlZXBlc3RUcmVlRGVwdGggPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgX2RlZXBlc3RFbGVtZW50OiBFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVlcGVzdE9uQ2xvc2U6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtlbGVtZW50LCB7IGRlcHRoLCBvbkNsb3NlLCB0cmVlRGVwdGggfV0gb2YgZWxlbWVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpZUJyb2tlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA9PSBkZWVwZXN0RGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVEZXB0aCA+IGRlZXBlc3RUcmVlRGVwdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpZUJyb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPiBkZWVwZXN0RGVwdGggfHwgKGRlcHRoID09IGRlZXBlc3REZXB0aCAmJiB0aWVCcm9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBlc3REZXB0aCA9IGRlcHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVlcGVzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWVwZXN0VHJlZURlcHRoID0gdHJlZURlcHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWVwZXN0T25DbG9zZSA9IG9uQ2xvc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVlcGVzdE9uQ2xvc2U/LigpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbb3Blbl0pO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxvc3RGb2N1c0Rpc21pc3NQYXJhbWV0ZXJzPFNvdXJjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHwgbnVsbCwgUG9wdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGxvc3RGb2N1c0Rpc21pc3M6IHsgb3BlbjogYm9vbGVhbiwgb25DbG9zZSgpOiB2b2lkOyB9O1xuICAgIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm46IG51bGwgfCBQaWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPE5vbk51bGxhYmxlPFNvdXJjZUVsZW1lbnQ+PltcInJlZkVsZW1lbnRSZXR1cm5cIl0sIFwiZ2V0RWxlbWVudFwiPjtcbiAgICByZWZFbGVtZW50UG9wdXBSZXR1cm46IFBpY2s8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8UG9wdXBFbGVtZW50PltcInJlZkVsZW1lbnRSZXR1cm5cIl0sIFwiZ2V0RWxlbWVudFwiPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMb3N0Rm9jdXNEaXNtaXNzUmV0dXJuVHlwZTxfU291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQgfCBudWxsLCBfUG9wdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzOiBQaWNrPFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzW1wiYWN0aXZlRWxlbWVudFBhcmFtZXRlcnNcIl0sIFwib25MYXN0QWN0aXZlRWxlbWVudENoYW5nZVwiPlxufVxuXG4vKipcbiAqIEhhbmRsZXMgZXZlbnRzIGZvciBkaXNtaXNzIGV2ZW50cyBmb3IgdGhpbmdzIGxpa2UgcG9wdXAgbWVudXMgb3IgdHJhbnNpZW50IGRpYWxvZ3MgLS0gdGhpbmdzIHdoZXJlIG1vdmluZyBmb2N1cyB0byBhIG5ldyBhcmVhIG9mIHRoZSBwYWdlIG1lYW5zIHRoaXMgY29tcG9uZW50IHNob3VsZCBjbG9zZSBpdHNlbGYuXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvc3RGb2N1c0Rpc21pc3M8U291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQgfCBudWxsLCBQb3B1cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHJlZkVsZW1lbnRQb3B1cFJldHVybjogeyBnZXRFbGVtZW50OiBnZXRQb3B1cEVsZW1lbnQsIC4uLnZvaWQzIH0sIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm4sIGxvc3RGb2N1c0Rpc21pc3M6IHsgb3Blbiwgb25DbG9zZSB9LCAuLi52b2lkMSB9OiBVc2VMb3N0Rm9jdXNEaXNtaXNzUGFyYW1ldGVyczxTb3VyY2VFbGVtZW50LCBQb3B1cEVsZW1lbnQ+KTogVXNlTG9zdEZvY3VzRGlzbWlzc1JldHVyblR5cGU8U291cmNlRWxlbWVudCwgUG9wdXBFbGVtZW50PiB7XG5cbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldFNvdXJjZUVsZW1lbnQsIC4uLnZvaWQyIH0gPSAocmVmRWxlbWVudFNvdXJjZVJldHVybiA/PyB7fSk7XG5cbiAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkMSk7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDIpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQzKTtcblxuXG4gICAgY29uc3Qgc3RhYmxlT25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UpO1xuICAgIGNvbnN0IGdldE9wZW4gPSB1c2VTdGFibGVHZXR0ZXIob3Blbik7XG4gICAgY29uc3Qgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSA9IHVzZUNhbGxiYWNrPE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnQgfCBudWxsLCBoLkpTWC5UYXJnZXRlZEZvY3VzRXZlbnQ8YW55Pj4+KChuZXdFbGVtZW50LCBfcHJldkVsZW1lbnQsIF9lKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wZW4gPSBnZXRPcGVuKCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZUVsZW1lbnQgPSBnZXRTb3VyY2VFbGVtZW50Py4oKTtcbiAgICAgICAgY29uc3QgcG9wdXBFbGVtZW50ID0gZ2V0UG9wdXBFbGVtZW50KCk7XG4gICAgICAgIGlmICghKHNvdXJjZUVsZW1lbnQ/LmNvbnRhaW5zKG5ld0VsZW1lbnQpIHx8IHBvcHVwRWxlbWVudD8uY29udGFpbnMobmV3RWxlbWVudCkpKSB7XG4gICAgICAgICAgICBpZiAob3BlbilcbiAgICAgICAgICAgICAgICBzdGFibGVPbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9LCBbZ2V0U291cmNlRWxlbWVudF0pO1xuXG4gICAgcmV0dXJuIHsgYWN0aXZlRWxlbWVudFBhcmFtZXRlcnM6IHsgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSB9IH1cbn1cblxuLypcbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzPFNvdXJjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQb3B1cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxvc3RGb2N1c0Rpc21pc3NQYXJhbWV0ZXJzPFNvdXJjZUVsZW1lbnQsIFBvcHVwRWxlbWVudD4sIFVzZUVzY2FwZURpc21pc3NQYXJhbWV0ZXJzPFNvdXJjZUVsZW1lbnQ+IHsgfVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU29mdERpc21pc3M8U291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnMsIGxvc3RGb2N1c0Rpc21pc3MsIHJlZkVsZW1lbnRQb3B1cFJldHVybiwgcmVmRWxlbWVudFJldHVybiwgcmVmRWxlbWVudFNvdXJjZVJldHVybiwgLi4uX3ZvaWQzIH06IFVzZVNvZnREaXNtaXNzUGFyYW1ldGVyczxTb3VyY2VFbGVtZW50LCBQb3B1cEVsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyBhY3RpdmVFbGVtZW50UGFyYW1ldGVycywgLi4udm9pZDIgfSA9IHVzZUxvc3RGb2N1c0Rpc21pc3MoeyBsb3N0Rm9jdXNEaXNtaXNzLCByZWZFbGVtZW50UG9wdXBSZXR1cm4sIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm4gfSk7XG4gICAgY29uc3QgX3ZvaWQxOiB2b2lkID0gdXNlRXNjYXBlRGlzbWlzcyh7IGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzLCByZWZFbGVtZW50UmV0dXJuIH0pO1xufSovXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQmFja2Ryb3BEaXNtaXNzUGFyYW1ldGVyczxQb3B1cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgYmFja2Ryb3BEaXNtaXNzUGFyYW1ldGVyczogeyBvcGVuOiBib29sZWFuLCBvbkNsb3NlKCk6IHZvaWQ7IH07XG4gICAgcmVmRWxlbWVudFBvcHVwUmV0dXJuOiBQaWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFBvcHVwRWxlbWVudD5bXCJyZWZFbGVtZW50UmV0dXJuXCJdLCBcImdldEVsZW1lbnRcIj47XG59XG5cbi8qKlxuICogSGFuZGxlcyBldmVudHMgZm9yIGEgYmFja2Ryb3Agb24gYSBtb2RhbCBkaWFsb2cgLS0gdGhlIGtpbmQgd2hlcmUgdGhlIHVzZXIgZXhwZWN0cyB0aGUgbW9kYWwgdG8gY2xvc2Ugd2hlbiB0aGV5IGNsaWNrL3RhcCBvdXRzaWRlIG9mIGl0LlxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmFja2Ryb3BEaXNtaXNzPFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgYmFja2Ryb3BEaXNtaXNzUGFyYW1ldGVyczogeyBvcGVuLCBvbkNsb3NlOiBvbkNsb3NlVW5zdGFibGUsIC4uLnZvaWQxIH0sIHJlZkVsZW1lbnRQb3B1cFJldHVybjogeyBnZXRFbGVtZW50LCAuLi52b2lkMyB9LCAuLi52b2lkMiB9OiBVc2VCYWNrZHJvcERpc21pc3NQYXJhbWV0ZXJzPFBvcHVwRWxlbWVudD4pOiB2b2lkIHtcbiAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkMSk7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDIpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQzKTtcbiAgICBjb25zdCBnZXRPcGVuID0gdXNlU3RhYmxlR2V0dGVyKG9wZW4pO1xuICAgIGNvbnN0IG9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjayhvbkNsb3NlVW5zdGFibGUpO1xuXG4gICAgY29uc3Qgb25CYWNrZHJvcENsaWNrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gb25CYWNrZHJvcENsaWNrKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8YW55Pikge1xuICAgICAgICBpZiAoIWdldE9wZW4oKSlcbiAgICAgICAgICAgIHJldHVybjtcblxuXG4gICAgICAgIC8vIEJhc2ljYWxseSwgXCJ3YXMgdGhpcyBldmVudCBmaXJlZCBvbiBhbiBlbGVtZW50IG5vdCBjb250YWluZWQgYnkgdGhlIG1vZGFsP1wiXG4gICAgICAgIC8vIFRoZXJlIGFyZSBtdWx0aXBsZSB3YXlzIGJyb3dzZXIgcmVhY3QgdG8gXCJpbnRlcmFjdGluZyB3aXRoIG5vdGhpbmdcIiwgYW5kIHRoaXMgdGFrZXMgY2FyZSBvZiBldmVyeXRoaW5nLlxuXG4gICAgICAgIGxldCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuXG4gICAgICAgIGxldCBmb3VuZEluc2lkZUNsaWNrID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGUudGFyZ2V0ICYmIGVsZW1lbnQgJiYgZWxlbWVudC5jb250YWlucyhlLnRhcmdldCBhcyBOb2RlKSkge1xuICAgICAgICAgICAgZm91bmRJbnNpZGVDbGljayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZvdW5kSW5zaWRlQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcIm1vdXNlZG93blwiLCBvcGVuID8gb25CYWNrZHJvcENsaWNrIDogbnVsbCwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgIHVzZUdsb2JhbEhhbmRsZXIod2luZG93LCBcInRvdWNoc3RhcnRcIiwgb3BlbiA/IG9uQmFja2Ryb3BDbGljayA6IG51bGwsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbn1cblxuZXhwb3J0IHR5cGUgRGlzbWlzc0xpc3RlbmVyVHlwZXMgPSBcImJhY2tkcm9wXCIgfCBcImxvc3QtZm9jdXNcIiB8IFwiZXNjYXBlXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRGlzbWlzc1BhcmFtZXRlcnM8TGlzdGVuZXJzIGV4dGVuZHMgRGlzbWlzc0xpc3RlbmVyVHlwZXM+IHtcbiAgICBkaXNtaXNzUGFyYW1ldGVyczoge1xuXG4gICAgICAgIC8qKiBcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyBjb21wb25lbnQgaXMgY3VycmVudGx5IG9wZW4vc2hvd2luZyBpdHNlbGYsIGFzIG9wcG9zZWQgdG8gaGlkZGVuL2Nsb3NlZC5cbiAgICAgICAgICogRXZlbnQgaGFuZGxlcnMgYXJlIG9ubHkgYXR0YWNoZWQgd2hlbiB0aGlzIGlzIGB0cnVlYC5cbiAgICAgICAgICovXG4gICAgICAgIG9wZW46IGJvb2xlYW47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgdXNlciBoYXMgcmVxdWVzdGVkIHRoZSBjb21wb25lbnQgYmUgZGlzbWlzc2VkIGZvciB0aGUgZ2l2ZW4gcmVhc29uLlxuICAgICAgICAgKiBcbiAgICAgICAgICogWW91IGNhbiBjaG9vc2UgdG8gaWdub3JlIGEgcmVhc29uIGlmIHlvdSB3YW50LCBidXQgaXQncyBiZXR0ZXIgdG8gc2V0IGBjbG9zZU9uJHtyZWFzb259YCB0byBgZmFsc2VgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBvbkNsb3NlOiAocmVhc29uOiBMaXN0ZW5lcnMpID0+IHZvaWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGB0cnVlYCwgdGhlbiB0aGlzIGNvbXBvbmVudCBjbG9zZXMgd2hlbiBhIGNsaWNrIGlzIGRldGVjdGVkIGFueXdoZXJlIG5vdCB3aXRoaW4gdGhlIGNvbXBvbmVudFxuICAgICAgICAgKiAoZGV0ZXJtaW5lZCBieSBiZWluZyBpbiBhIGRpZmZlcmVudCBicmFuY2ggb2YgdGhlIERPTSlcbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlT25CYWNrZHJvcDogTGlzdGVuZXJzIGV4dGVuZHMgXCJiYWNrZHJvcFwiID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBgdHJ1ZWAsIHRoZW4gdGhpcyBjb21wb25lbnQgY2xvc2VzIHdoZW4gdGhlIEVzY2FwZSBrZXkgaXMgcHJlc3NlZCwgYW5kIG5vIGRlZXBlciBjb21wb25lbnRcbiAgICAgICAgICogaXMgbGlzdGVuaW5nIGZvciB0aGF0IHNhbWUgRXNjYXBlIHByZXNzIChpLmUuIG9ubHkgb25lIEVzY2FwZSBkaXNtaXNzIGhhcHBlbnMgcGVyIGtleSBwcmVzcylcbiAgICAgICAgICovXG4gICAgICAgIGNsb3NlT25Fc2NhcGU6IExpc3RlbmVycyBleHRlbmRzIFwiZXNjYXBlXCIgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGB0cnVlYCwgdGhlbiB0aGlzIGNvbXBvbmVudCBjbG9zZXMgd2hlbmV2ZXIgZm9jdXMgaXMgc2VudCB0byBhbiBlbGVtZW50IG5vdCBjb250YWluZWQgYnkgdGhpcyBvbmVcbiAgICAgICAgICogKHVzaW5nIHRoZSBzYW1lIHJ1bGVzIGFzIGBjbG9zZU9uQmFja2Ryb3BgKVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2VPbkxvc3RGb2N1czogTGlzdGVuZXJzIGV4dGVuZHMgXCJsb3N0LWZvY3VzXCIgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzOiBQaWNrPFVzZUVzY2FwZURpc21pc3NQYXJhbWV0ZXJzPGFueT5bXCJlc2NhcGVEaXNtaXNzUGFyYW1ldGVyc1wiXSwgXCJnZXRXaW5kb3dcIiB8IFwicGFyZW50RGVwdGhcIj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRGlzbWlzc1JldHVyblR5cGU8U291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQgfCBudWxsLCBQb3B1cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBkaXNtaXNzYWJsZSBjb21wb25lbnQgaGFzIGEgc3BlY2lmaWMgZWxlbWVudCB0aGF0IGNhdXNlZCBpdCB0byBhcHBlYXIgKGEgYnV0dG9uLCBmb3IgZXhhbXBsZSksXG4gICAgICogcHJvdmlkZSBpdCB3aXRoIHRoZXNlIHByb3BzLlxuICAgICAqIFxuICAgICAqICogUkVRVUlSRUQgZm9yIHRoaW5ncyBsaWtlIG1lbnVzIHRoYXQgcG9wIHVwIGZyb20gYSBidXR0b24gYW5kIGZvciB3aG9tIGxvc2luZyBmb2N1cyBjb3VudHMgYXMgcmVxdWVzdGluZyBjbG9zdXJlLiBcbiAgICAgKiAqIE9QVElPTkFMIGZvciB0aGluZ3MgbGlrZSBkaWFsb2dzIHRoYXQgY2FuIGFwcGVhciBvdXQgb2Ygbm93aGVyZSBhbmQgZm9yIHdob20gbG9zaW5nIGZvY3VzIGlzIGFjdGl2ZWx5IGltcG9zc2libGUgKGR1ZSB0byBmb2N1cyB0cmFwcykuXG4gICAgICovXG4gICAgcmVmRWxlbWVudFNvdXJjZVJldHVybjogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8Tm9uTnVsbGFibGU8U291cmNlRWxlbWVudD4+W1wicmVmRWxlbWVudFJldHVyblwiXTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgb25lJ3MgYWx3YXlzIHJlcXVpcmVkIHRob3VnaFxuICAgICAqL1xuICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybjogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8UG9wdXBFbGVtZW50PltcInJlZkVsZW1lbnRSZXR1cm5cIl07XG5cbn1cblxuLyoqXG4gKiBDb21iaW5lcyBhbGwgdGhlIG1ldGhvZHMgb2YgZGlzbWlzc2luZyBhIG1vZGFsLWlzaCBvciBwb3B1cC1pc2ggY29tcG9uZW50IGludG8gb25lIGNvbWJpbmVkIGhvb2suXG4gKiBcbiAqIFRoaXMgaXMgc2ltaWxhciB0byB0aGUgXCJjb21wbGV0ZVwiIHNlcmllcyBvZiBsaXN0L2dyaWQgbmF2aWdhdGlvbiwgaW4gdGhhdCBpdCdzIHRoZSBcIm91dGVybW9zdFwiIGhvb2sgb2YgaXRzIHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VEaXNtaXNzPExpc3RlbmVycyBleHRlbmRzIERpc21pc3NMaXN0ZW5lclR5cGVzLCBTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB8IG51bGwsIFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgZGlzbWlzc1BhcmFtZXRlcnM6IHsgb3BlbjogZ2xvYmFsT3Blbiwgb25DbG9zZTogZ2xvYmFsT25DbG9zZSwgY2xvc2VPbkJhY2tkcm9wLCBjbG9zZU9uRXNjYXBlLCBjbG9zZU9uTG9zdEZvY3VzIH0sIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzOiB7IGdldFdpbmRvdywgcGFyZW50RGVwdGggfSB9OiBVc2VEaXNtaXNzUGFyYW1ldGVyczxMaXN0ZW5lcnM+KTogVXNlRGlzbWlzc1JldHVyblR5cGU8U291cmNlRWxlbWVudCwgUG9wdXBFbGVtZW50PiB7XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHJlZkVsZW1lbnRTb3VyY2VSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8Tm9uTnVsbGFibGU8U291cmNlRWxlbWVudD4+KHsgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9IH0pO1xuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybjogcmVmRWxlbWVudFBvcHVwUmV0dXJuIH0gPSB1c2VSZWZFbGVtZW50PFBvcHVwRWxlbWVudD4oeyByZWZFbGVtZW50UGFyYW1ldGVyczoge30gfSk7XG5cbiAgICBjb25zdCBvbkNsb3NlQmFja2Ryb3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiBnbG9iYWxPbkNsb3NlPy4oXCJiYWNrZHJvcFwiIGFzIExpc3RlbmVycyk7IH0sIFtnbG9iYWxPbkNsb3NlXSk7XG4gICAgY29uc3Qgb25DbG9zZUVzY2FwZSA9IHVzZUNhbGxiYWNrKCgpID0+IHsgcmV0dXJuIGdsb2JhbE9uQ2xvc2U/LihcImVzY2FwZVwiIGFzIExpc3RlbmVycyk7IH0sIFtnbG9iYWxPbkNsb3NlXSk7XG4gICAgY29uc3Qgb25DbG9zZUZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gZ2xvYmFsT25DbG9zZT8uKFwibG9zdC1mb2N1c1wiIGFzIExpc3RlbmVycyk7IH0sIFtnbG9iYWxPbkNsb3NlXSk7XG4gICAgY29uc3QgX3YxOiB2b2lkID0gdXNlQmFja2Ryb3BEaXNtaXNzPFBvcHVwRWxlbWVudD4oeyBiYWNrZHJvcERpc21pc3NQYXJhbWV0ZXJzOiB7IG9uQ2xvc2U6IG9uQ2xvc2VCYWNrZHJvcCwgb3BlbjogKGNsb3NlT25CYWNrZHJvcCAmJiBnbG9iYWxPcGVuKSB9LCByZWZFbGVtZW50UG9wdXBSZXR1cm4gfSk7XG4gICAgY29uc3QgX3YyOiB2b2lkID0gdXNlRXNjYXBlRGlzbWlzczxQb3B1cEVsZW1lbnQ+KHsgZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnM6IHsgZ2V0V2luZG93LCBvbkNsb3NlOiBvbkNsb3NlRXNjYXBlLCBvcGVuOiAoY2xvc2VPbkVzY2FwZSAmJiBnbG9iYWxPcGVuKSwgcGFyZW50RGVwdGggfSwgcmVmRWxlbWVudFBvcHVwUmV0dXJuIH0pO1xuICAgIGNvbnN0IHsgYWN0aXZlRWxlbWVudFBhcmFtZXRlcnMgfSA9IHVzZUxvc3RGb2N1c0Rpc21pc3M8U291cmNlRWxlbWVudCwgUG9wdXBFbGVtZW50Pih7IGxvc3RGb2N1c0Rpc21pc3M6IHsgb25DbG9zZTogb25DbG9zZUZvY3VzLCBvcGVuOiAoY2xvc2VPbkxvc3RGb2N1cyAmJiBnbG9iYWxPcGVuKSB9LCByZWZFbGVtZW50UG9wdXBSZXR1cm4sIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm4gfSk7XG5cbiAgICBjb25zdCBnZXREb2N1bWVudCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGdldFdpbmRvdygpLmRvY3VtZW50O1xuICAgIH0sIFtnZXRXaW5kb3ddKVxuXG4gICAgY29uc3Qge1xuICAgICAgICBhY3RpdmVFbGVtZW50UmV0dXJuOiB7XG4gICAgICAgICAgICBnZXRBY3RpdmVFbGVtZW50OiBfZ2V0QWN0aXZlRWxlbWVudCxcbiAgICAgICAgICAgIGdldExhc3RBY3RpdmVFbGVtZW50OiBfZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICBnZXRXaW5kb3dGb2N1c2VkOiBfZ2V0V2luZG93Rm9jdXNlZFxuICAgICAgICB9XG4gICAgfSA9IHVzZUFjdGl2ZUVsZW1lbnQoeyBhY3RpdmVFbGVtZW50UGFyYW1ldGVyczogeyAuLi5hY3RpdmVFbGVtZW50UGFyYW1ldGVycywgZ2V0V2luZG93LCBnZXREb2N1bWVudCB9IH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVmRWxlbWVudFNvdXJjZVJldHVybixcbiAgICAgICAgcmVmRWxlbWVudFBvcHVwUmV0dXJuXG4gICAgfVxufVxuIiwiY29uc3QgY2FuZGlkYXRlU2VsZWN0b3JzID0gW1xuICAnaW5wdXQnLFxuICAnc2VsZWN0JyxcbiAgJ3RleHRhcmVhJyxcbiAgJ2FbaHJlZl0nLFxuICAnYnV0dG9uJyxcbiAgJ1t0YWJpbmRleF06bm90KHNsb3QpJyxcbiAgJ2F1ZGlvW2NvbnRyb2xzXScsXG4gICd2aWRlb1tjb250cm9sc10nLFxuICAnW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSknLFxuICAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnLFxuICAnZGV0YWlscycsXG5dO1xuY29uc3QgY2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi8gY2FuZGlkYXRlU2VsZWN0b3JzLmpvaW4oJywnKTtcblxuY29uc3QgTm9FbGVtZW50ID0gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnO1xuXG5jb25zdCBtYXRjaGVzID0gTm9FbGVtZW50XG4gID8gZnVuY3Rpb24gKCkge31cbiAgOiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cbmNvbnN0IGdldFJvb3ROb2RlID1cbiAgIU5vRWxlbWVudCAmJiBFbGVtZW50LnByb3RvdHlwZS5nZXRSb290Tm9kZVxuICAgID8gKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKVxuICAgIDogKGVsZW1lbnQpID0+IGVsZW1lbnQub3duZXJEb2N1bWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIGNvbnRhaW5lciB0byBjaGVjayBpblxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgdG8gY2hlY2tcbiAqIEBwYXJhbSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xuICogQHJldHVybnMge0VsZW1lbnRbXX1cbiAqL1xuY29uc3QgZ2V0Q2FuZGlkYXRlcyA9IGZ1bmN0aW9uIChlbCwgaW5jbHVkZUNvbnRhaW5lciwgZmlsdGVyKSB7XG4gIGxldCBjYW5kaWRhdGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KFxuICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2FuZGlkYXRlU2VsZWN0b3IpXG4gICk7XG4gIGlmIChpbmNsdWRlQ29udGFpbmVyICYmIG1hdGNoZXMuY2FsbChlbCwgY2FuZGlkYXRlU2VsZWN0b3IpKSB7XG4gICAgY2FuZGlkYXRlcy51bnNoaWZ0KGVsKTtcbiAgfVxuICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5maWx0ZXIoZmlsdGVyKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBHZXRTaGFkb3dSb290XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdG8gY2hlY2sgZm9yIHNoYWRvdyByb290XG4gKiBAcmV0dXJucyB7U2hhZG93Um9vdHxib29sZWFufSBTaGFkb3dSb290IGlmIGF2YWlsYWJsZSBvciBib29sZWFuIGluZGljYXRpbmcgaWYgYSBzaGFkb3dSb290IGlzIGF0dGFjaGVkIGJ1dCBub3QgYXZhaWxhYmxlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFNoYWRvd1Jvb3RGaWx0ZXJcbiAqIEBwYXJhbSB7RWxlbWVudH0gc2hhZG93SG9zdE5vZGUgdGhlIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgc2hhZG93IGNvbnRlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGEgc2hhZG93IHJvb3QgY291bGQgcG90ZW50aWFsbHkgY29udGFpbiB2YWxpZCBjYW5kaWRhdGVzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2FuZGlkYXRlU2NvcGVcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gc2NvcGVQYXJlbnQgY29udGFpbnMgaW5uZXIgY2FuZGlkYXRlc1xuICogQHByb3BlcnR5IHtFbGVtZW50W119IGNhbmRpZGF0ZXMgbGlzdCBvZiBjYW5kaWRhdGVzIGZvdW5kIGluIHRoZSBzY29wZSBwYXJlbnRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEl0ZXJhdGl2ZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7R2V0U2hhZG93Um9vdHxib29sZWFufSBnZXRTaGFkb3dSb290IHRydWUgaWYgc2hhZG93IHN1cHBvcnQgaXMgZW5hYmxlZDsgZmFsc3kgaWYgbm90O1xuICogIGlmIGEgZnVuY3Rpb24sIGltcGxpZXMgc2hhZG93IHN1cHBvcnQgaXMgZW5hYmxlZCBhbmQgZWl0aGVyIHJldHVybnMgdGhlIHNoYWRvdyByb290IG9mIGFuIGVsZW1lbnRcbiAqICBvciBhIGJvb2xlYW4gc3RhdGluZyBpZiBpdCBoYXMgYW4gdW5kaXNjbG9zZWQgc2hhZG93IHJvb3RcbiAqIEBwcm9wZXJ0eSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xuICogQHByb3BlcnR5IHtib29sZWFufSBmbGF0dGVuIGlmIHRydWUgdGhlbiByZXN1bHQgd2lsbCBmbGF0dGVuIGFueSBDYW5kaWRhdGVTY29wZSBpbnRvIHRoZSByZXR1cm5lZCBsaXN0XG4gKiBAcHJvcGVydHkge1NoYWRvd1Jvb3RGaWx0ZXJ9IHNoYWRvd1Jvb3RGaWx0ZXIgZmlsdGVyIHNoYWRvdyByb290cztcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50cyBsaXN0IG9mIGVsZW1lbnQgY29udGFpbmVycyB0byBtYXRjaCBjYW5kaWRhdGVzIGZyb21cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIGxpc3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7SXRlcmF0aXZlT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZVNjb3BlPn1cbiAqL1xuY29uc3QgZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5ID0gZnVuY3Rpb24gKFxuICBlbGVtZW50cyxcbiAgaW5jbHVkZUNvbnRhaW5lcixcbiAgb3B0aW9uc1xuKSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbXTtcbiAgY29uc3QgZWxlbWVudHNUb0NoZWNrID0gQXJyYXkuZnJvbShlbGVtZW50cyk7XG4gIHdoaWxlIChlbGVtZW50c1RvQ2hlY2subGVuZ3RoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzVG9DaGVjay5zaGlmdCgpO1xuICAgIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdTTE9UJykge1xuICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2xvdCBzY29wZSAoc2xvdCBpdHNlbGYgY2Fubm90IGJlIGZvY3VzYWJsZSlcbiAgICAgIGNvbnN0IGFzc2lnbmVkID0gZWxlbWVudC5hc3NpZ25lZEVsZW1lbnRzKCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gYXNzaWduZWQubGVuZ3RoID8gYXNzaWduZWQgOiBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgY29uc3QgbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShjb250ZW50LCB0cnVlLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKC4uLm5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBzY29wZVBhcmVudDogZWxlbWVudCxcbiAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2hlY2sgY2FuZGlkYXRlIGVsZW1lbnRcbiAgICAgIGNvbnN0IHZhbGlkQ2FuZGlkYXRlID0gbWF0Y2hlcy5jYWxsKGVsZW1lbnQsIGNhbmRpZGF0ZVNlbGVjdG9yKTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsaWRDYW5kaWRhdGUgJiZcbiAgICAgICAgb3B0aW9ucy5maWx0ZXIoZWxlbWVudCkgJiZcbiAgICAgICAgKGluY2x1ZGVDb250YWluZXIgfHwgIWVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKVxuICAgICAgKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gaXRlcmF0ZSBvdmVyIHNoYWRvdyBjb250ZW50IGlmIHBvc3NpYmxlXG4gICAgICBjb25zdCBzaGFkb3dSb290ID1cbiAgICAgICAgZWxlbWVudC5zaGFkb3dSb290IHx8XG4gICAgICAgIC8vIGNoZWNrIGZvciBhbiB1bmRpc2Nsb3NlZCBzaGFkb3dcbiAgICAgICAgKHR5cGVvZiBvcHRpb25zLmdldFNoYWRvd1Jvb3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICBvcHRpb25zLmdldFNoYWRvd1Jvb3QoZWxlbWVudCkpO1xuXG4gICAgICBjb25zdCB2YWxpZFNoYWRvd1Jvb3QgPVxuICAgICAgICAhb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyIHx8IG9wdGlvbnMuc2hhZG93Um9vdEZpbHRlcihlbGVtZW50KTtcblxuICAgICAgaWYgKHNoYWRvd1Jvb3QgJiYgdmFsaWRTaGFkb3dSb290KSB7XG4gICAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNjb3BlIElJRiBhIHNoYWRvdyByb290IG5vZGUgd2FzIGdpdmVuOyBvdGhlcndpc2UsIGFuIHVuZGlzY2xvc2VkXG4gICAgICAgIC8vICBzaGFkb3cgZXhpc3RzLCBzbyBsb29rIGF0IGxpZ2h0IGRvbSBjaGlsZHJlbiBhcyBmYWxsYmFjayBCVVQgY3JlYXRlIGEgc2NvcGUgZm9yIGFueVxuICAgICAgICAvLyAgY2hpbGQgY2FuZGlkYXRlcyBmb3VuZCBiZWNhdXNlIHRoZXkncmUgbGlrZWx5IHNsb3R0ZWQgZWxlbWVudHMgKGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgICAgIC8vICBjaGlsZHJlbiBvZiB0aGUgd2ViIGNvbXBvbmVudCBlbGVtZW50ICh3aGljaCBoYXMgdGhlIHNoYWRvdyksIGluIHRoZSBsaWdodCBkb20sIGJ1dFxuICAgICAgICAvLyAgc2xvdHRlZCBzb21ld2hlcmUgX2luc2lkZV8gdGhlIHVuZGlzY2xvc2VkIHNoYWRvdykgLS0gdGhlIHNjb3BlIGlzIGNyZWF0ZWQgYmVsb3csXG4gICAgICAgIC8vICBfYWZ0ZXJfIHdlIHJldHVybiBmcm9tIHRoaXMgcmVjdXJzaXZlIGNhbGxcbiAgICAgICAgY29uc3QgbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShcbiAgICAgICAgICBzaGFkb3dSb290ID09PSB0cnVlID8gZWxlbWVudC5jaGlsZHJlbiA6IHNoYWRvd1Jvb3QuY2hpbGRyZW4sXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5uZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgICAgc2NvcGVQYXJlbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVyZSdzIG5vdCBzaGFkb3cgc28ganVzdCBkaWcgaW50byB0aGUgZWxlbWVudCdzIChsaWdodCBkb20pIGNoaWxkcmVuXG4gICAgICAgIC8vICBfX3dpdGhvdXRfXyBnaXZpbmcgdGhlIGVsZW1lbnQgc3BlY2lhbCBzY29wZSB0cmVhdG1lbnRcbiAgICAgICAgZWxlbWVudHNUb0NoZWNrLnVuc2hpZnQoLi4uZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuY29uc3QgZ2V0VGFiaW5kZXggPSBmdW5jdGlvbiAobm9kZSwgaXNTY29wZSkge1xuICBpZiAobm9kZS50YWJJbmRleCA8IDApIHtcbiAgICAvLyBpbiBDaHJvbWUsIDxkZXRhaWxzLz4sIDxhdWRpbyBjb250cm9scy8+IGFuZCA8dmlkZW8gY29udHJvbHMvPiBlbGVtZW50cyBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAtMSB3aGVuIHRoZSAndGFiaW5kZXgnIGF0dHJpYnV0ZSBpc24ndCBzcGVjaWZpZWQgaW4gdGhlIERPTSxcbiAgICAvLyB5ZXQgdGhleSBhcmUgc3RpbGwgcGFydCBvZiB0aGUgcmVndWxhciB0YWIgb3JkZXI7IGluIEZGLCB0aGV5IGdldCBhIGRlZmF1bHRcbiAgICAvLyBgdGFiSW5kZXhgIG9mIDA7IHNpbmNlIENocm9tZSBzdGlsbCBwdXRzIHRob3NlIGVsZW1lbnRzIGluIHRoZSByZWd1bGFyIHRhYlxuICAgIC8vIG9yZGVyLCBjb25zaWRlciB0aGVpciB0YWIgaW5kZXggdG8gYmUgMC5cbiAgICAvLyBBbHNvIGJyb3dzZXJzIGRvIG5vdCByZXR1cm4gYHRhYkluZGV4YCBjb3JyZWN0bHkgZm9yIGNvbnRlbnRFZGl0YWJsZSBub2RlcztcbiAgICAvLyBzbyBpZiB0aGV5IGRvbid0IGhhdmUgYSB0YWJpbmRleCBhdHRyaWJ1dGUgc3BlY2lmaWNhbGx5IHNldCwgYXNzdW1lIGl0J3MgMC5cbiAgICAvL1xuICAgIC8vIGlzU2NvcGUgaXMgcG9zaXRpdmUgZm9yIGN1c3RvbSBlbGVtZW50IHdpdGggc2hhZG93IHJvb3Qgb3Igc2xvdCB0aGF0IGJ5IGRlZmF1bHRcbiAgICAvLyBoYXZlIHRhYkluZGV4IC0xLCBidXQgbmVlZCB0byBiZSBzb3J0ZWQgYnkgZG9jdW1lbnQgb3JkZXIgaW4gb3JkZXIgZm9yIHRoZWlyXG4gICAgLy8gY29udGVudCB0byBiZSBpbnNlcnRlZCBpbiB0aGUgY29ycmVjdCBwb3NpdGlvblxuICAgIGlmIChcbiAgICAgIChpc1Njb3BlIHx8XG4gICAgICAgIC9eKEFVRElPfFZJREVPfERFVEFJTFMpJC8udGVzdChub2RlLnRhZ05hbWUpIHx8XG4gICAgICAgIG5vZGUuaXNDb250ZW50RWRpdGFibGUpICYmXG4gICAgICBpc05hTihwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApKVxuICAgICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGUudGFiSW5kZXg7XG59O1xuXG5jb25zdCBzb3J0T3JkZXJlZFRhYmJhYmxlcyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBhLnRhYkluZGV4ID09PSBiLnRhYkluZGV4XG4gICAgPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXJcbiAgICA6IGEudGFiSW5kZXggLSBiLnRhYkluZGV4O1xufTtcblxuY29uc3QgaXNJbnB1dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdJTlBVVCc7XG59O1xuXG5jb25zdCBpc0hpZGRlbklucHV0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAnaGlkZGVuJztcbn07XG5cbmNvbnN0IGlzRGV0YWlsc1dpdGhTdW1tYXJ5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgY29uc3QgciA9XG4gICAgbm9kZS50YWdOYW1lID09PSAnREVUQUlMUycgJiZcbiAgICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgIC5hcHBseShub2RlLmNoaWxkcmVuKVxuICAgICAgLnNvbWUoKGNoaWxkKSA9PiBjaGlsZC50YWdOYW1lID09PSAnU1VNTUFSWScpO1xuICByZXR1cm4gcjtcbn07XG5cbmNvbnN0IGdldENoZWNrZWRSYWRpbyA9IGZ1bmN0aW9uIChub2RlcywgZm9ybSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldLmNoZWNrZWQgJiYgbm9kZXNbaV0uZm9ybSA9PT0gZm9ybSkge1xuICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgaXNUYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKCFub2RlLm5hbWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCByYWRpb1Njb3BlID0gbm9kZS5mb3JtIHx8IGdldFJvb3ROb2RlKG5vZGUpO1xuICBjb25zdCBxdWVyeVJhZGlvcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHJhZGlvU2NvcGUucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBuYW1lICsgJ1wiXSdcbiAgICApO1xuICB9O1xuXG4gIGxldCByYWRpb1NldDtcbiAgaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5DU1MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJhZGlvU2V0ID0gcXVlcnlSYWRpb3Mod2luZG93LkNTUy5lc2NhcGUobm9kZS5uYW1lKSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHJhZGlvU2V0ID0gcXVlcnlSYWRpb3Mobm9kZS5uYW1lKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnTG9va3MgbGlrZSB5b3UgaGF2ZSBhIHJhZGlvIGJ1dHRvbiB3aXRoIGEgbmFtZSBhdHRyaWJ1dGUgY29udGFpbmluZyBpbnZhbGlkIENTUyBzZWxlY3RvciBjaGFyYWN0ZXJzIGFuZCBuZWVkIHRoZSBDU1MuZXNjYXBlIHBvbHlmaWxsOiAlcycsXG4gICAgICAgIGVyci5tZXNzYWdlXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNoZWNrZWQgPSBnZXRDaGVja2VkUmFkaW8ocmFkaW9TZXQsIG5vZGUuZm9ybSk7XG4gIHJldHVybiAhY2hlY2tlZCB8fCBjaGVja2VkID09PSBub2RlO1xufTtcblxuY29uc3QgaXNSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ3JhZGlvJztcbn07XG5cbmNvbnN0IGlzTm9uVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc1JhZGlvKG5vZGUpICYmICFpc1RhYmJhYmxlUmFkaW8obm9kZSk7XG59O1xuXG4vLyBkZXRlcm1pbmVzIGlmIGEgbm9kZSBpcyB1bHRpbWF0ZWx5IGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cncyBkb2N1bWVudFxuY29uc3QgaXNOb2RlQXR0YWNoZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAvLyBUaGUgcm9vdCBub2RlIGlzIHRoZSBzaGFkb3cgcm9vdCBpZiB0aGUgbm9kZSBpcyBpbiBhIHNoYWRvdyBET007IHNvbWUgZG9jdW1lbnQgb3RoZXJ3aXNlXG4gIC8vICAoYnV0IE5PVCBfdGhlXyBkb2N1bWVudDsgc2VlIHNlY29uZCAnSWYnIGNvbW1lbnQgYmVsb3cgZm9yIG1vcmUpLlxuICAvLyBJZiByb290Tm9kZSBpcyBzaGFkb3cgcm9vdCwgaXQnbGwgaGF2ZSBhIGhvc3QsIHdoaWNoIGlzIHRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBzaGFkb3dcbiAgLy8gIGlzIGF0dGFjaGVkLCBhbmQgdGhlIG9uZSB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgaW4gdGhlIGRvY3VtZW50IG9yIG5vdCAoYmVjYXVzZSB0aGVcbiAgLy8gIHNoYWRvdywgYW5kIGFsbCBub2RlcyBpdCBjb250YWlucywgaXMgbmV2ZXIgY29uc2lkZXJlZCBpbiB0aGUgZG9jdW1lbnQgc2luY2Ugc2hhZG93c1xuICAvLyAgYmVoYXZlIGxpa2Ugc2VsZi1jb250YWluZWQgRE9NczsgYnV0IGlmIHRoZSBzaGFkb3cncyBIT1NULCB3aGljaCBpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudCxcbiAgLy8gIGlzIGhpZGRlbiwgb3IgaXMgbm90IGluIHRoZSBkb2N1bWVudCBpdHNlbGYgYnV0IGlzIGRldGFjaGVkLCBpdCB3aWxsIGFmZmVjdCB0aGUgc2hhZG93J3NcbiAgLy8gIHZpc2liaWxpdHksIGluY2x1ZGluZyBhbGwgdGhlIG5vZGVzIGl0IGNvbnRhaW5zKS4gVGhlIGhvc3QgY291bGQgYmUgYW55IG5vcm1hbCBub2RlLFxuICAvLyAgb3IgYSBjdXN0b20gZWxlbWVudCAoaS5lLiB3ZWIgY29tcG9uZW50KS4gRWl0aGVyIHdheSwgdGhhdCdzIHRoZSBvbmUgdGhhdCBpcyBjb25zaWRlcmVkXG4gIC8vICBwYXJ0IG9mIHRoZSBkb2N1bWVudCwgbm90IHRoZSBzaGFkb3cgcm9vdCwgbm9yIGFueSBvZiBpdHMgY2hpbGRyZW4gKGkuZS4gdGhlIG5vZGUgYmVpbmdcbiAgLy8gIHRlc3RlZCkuXG4gIC8vIFRvIGZ1cnRoZXIgY29tcGxpY2F0ZSB0aGluZ3MsIHdlIGhhdmUgdG8gbG9vayBhbGwgdGhlIHdheSB1cCB1bnRpbCB3ZSBmaW5kIGEgc2hhZG93IEhPU1RcbiAgLy8gIHRoYXQgaXMgYXR0YWNoZWQgKG9yIGZpbmQgbm9uZSkgYmVjYXVzZSB0aGUgbm9kZSBtaWdodCBiZSBpbiBuZXN0ZWQgc2hhZG93cy4uLlxuICAvLyBJZiByb290Tm9kZSBpcyBub3QgYSBzaGFkb3cgcm9vdCwgaXQgd29uJ3QgaGF2ZSBhIGhvc3QsIGFuZCBzbyByb290Tm9kZSBzaG91bGQgYmUgdGhlXG4gIC8vICBkb2N1bWVudCAocGVyIHRoZSBkb2NzKSBhbmQgd2hpbGUgaXQncyBhIERvY3VtZW50LXR5cGUgb2JqZWN0LCB0aGF0IGRvY3VtZW50IGRvZXMgbm90XG4gIC8vICBhcHBlYXIgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG5vZGUncyBgb3duZXJEb2N1bWVudGAgZm9yIHNvbWUgcmVhc29uLCBzbyBpdCdzIHNhZmVyXG4gIC8vICB0byBpZ25vcmUgdGhlIHJvb3ROb2RlIGF0IHRoaXMgcG9pbnQsIGFuZCB1c2UgYG5vZGUub3duZXJEb2N1bWVudGAuIE90aGVyd2lzZSxcbiAgLy8gIHVzaW5nIGByb290Tm9kZS5jb250YWlucyhub2RlKWAgd2lsbCBfYWx3YXlzXyBiZSB0cnVlIHdlJ2xsIGdldCBmYWxzZS1wb3NpdGl2ZXMgd2hlblxuICAvLyAgbm9kZSBpcyBhY3R1YWxseSBkZXRhY2hlZC5cbiAgbGV0IG5vZGVSb290SG9zdCA9IGdldFJvb3ROb2RlKG5vZGUpLmhvc3Q7XG4gIGxldCBhdHRhY2hlZCA9ICEhKFxuICAgIG5vZGVSb290SG9zdD8ub3duZXJEb2N1bWVudC5jb250YWlucyhub2RlUm9vdEhvc3QpIHx8XG4gICAgbm9kZS5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGUpXG4gICk7XG5cbiAgd2hpbGUgKCFhdHRhY2hlZCAmJiBub2RlUm9vdEhvc3QpIHtcbiAgICAvLyBzaW5jZSBpdCdzIG5vdCBhdHRhY2hlZCBhbmQgd2UgaGF2ZSBhIHJvb3QgaG9zdCwgdGhlIG5vZGUgTVVTVCBiZSBpbiBhIG5lc3RlZCBzaGFkb3cgRE9NLFxuICAgIC8vICB3aGljaCBtZWFucyB3ZSBuZWVkIHRvIGdldCB0aGUgaG9zdCdzIGhvc3QgYW5kIGNoZWNrIGlmIHRoYXQgcGFyZW50IGhvc3QgaXMgY29udGFpbmVkXG4gICAgLy8gIGluIChpLmUuIGF0dGFjaGVkIHRvKSB0aGUgZG9jdW1lbnRcbiAgICBub2RlUm9vdEhvc3QgPSBnZXRSb290Tm9kZShub2RlUm9vdEhvc3QpLmhvc3Q7XG4gICAgYXR0YWNoZWQgPSAhIW5vZGVSb290SG9zdD8ub3duZXJEb2N1bWVudC5jb250YWlucyhub2RlUm9vdEhvc3QpO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaGVkO1xufTtcblxuY29uc3QgaXNaZXJvQXJlYSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMDtcbn07XG5jb25zdCBpc0hpZGRlbiA9IGZ1bmN0aW9uIChub2RlLCB7IGRpc3BsYXlDaGVjaywgZ2V0U2hhZG93Um9vdCB9KSB7XG4gIC8vIE5PVEU6IHZpc2liaWxpdHkgd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBub2RlIGlzIGRldGFjaGVkIGZyb20gdGhlIGRvY3VtZW50XG4gIC8vICAoc2VlIG5vdGVzIGFib3V0IHRoaXMgZnVydGhlciBkb3duKSwgd2hpY2ggbWVhbnMgd2Ugd2lsbCBjb25zaWRlciBpdCB2aXNpYmxlXG4gIC8vICAodGhpcyBpcyBsZWdhY3kgYmVoYXZpb3IgZnJvbSBhIHZlcnkgbG9uZyB3YXkgYmFjaylcbiAgLy8gTk9URTogd2UgY2hlY2sgdGhpcyByZWdhcmRsZXNzIG9mIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIGJlY2F1c2UgdGhpcyBpcyBhXG4gIC8vICBfdmlzaWJpbGl0eV8gY2hlY2ssIG5vdCBhIF9kaXNwbGF5XyBjaGVja1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgaXNEaXJlY3RTdW1tYXJ5ID0gbWF0Y2hlcy5jYWxsKG5vZGUsICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScpO1xuICBjb25zdCBub2RlVW5kZXJEZXRhaWxzID0gaXNEaXJlY3RTdW1tYXJ5ID8gbm9kZS5wYXJlbnRFbGVtZW50IDogbm9kZTtcbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlVW5kZXJEZXRhaWxzLCAnZGV0YWlsczpub3QoW29wZW5dKSAqJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChcbiAgICAhZGlzcGxheUNoZWNrIHx8XG4gICAgZGlzcGxheUNoZWNrID09PSAnZnVsbCcgfHxcbiAgICBkaXNwbGF5Q2hlY2sgPT09ICdsZWdhY3ktZnVsbCdcbiAgKSB7XG4gICAgaWYgKHR5cGVvZiBnZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBmaWd1cmUgb3V0IGlmIHdlIHNob3VsZCBjb25zaWRlciB0aGUgbm9kZSB0byBiZSBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgYW5kIHVzZSB0aGVcbiAgICAgIC8vICAnbm9uLXplcm8tYXJlYScgZmFsbGJhY2tcbiAgICAgIGNvbnN0IG9yaWdpbmFsTm9kZSA9IG5vZGU7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICBjb25zdCByb290Tm9kZSA9IGdldFJvb3ROb2RlKG5vZGUpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcGFyZW50RWxlbWVudCAmJlxuICAgICAgICAgICFwYXJlbnRFbGVtZW50LnNoYWRvd1Jvb3QgJiZcbiAgICAgICAgICBnZXRTaGFkb3dSb290KHBhcmVudEVsZW1lbnQpID09PSB0cnVlIC8vIGNoZWNrIGlmIHRoZXJlJ3MgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5vZGUgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyB3aGljaCBtZWFucyB3ZSBjYW4gb25seSB0cmVhdCBpdCBhcyBhIGJsYWNrIGJveCwgc28gd2VcbiAgICAgICAgICAvLyAgZmFsbCBiYWNrIHRvIGEgbm9uLXplcm8tYXJlYSB0ZXN0XG4gICAgICAgICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIHNsb3RcbiAgICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmVudEVsZW1lbnQgJiYgcm9vdE5vZGUgIT09IG5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgIC8vIGNyb3NzIHNoYWRvdyBib3VuZGFyeVxuICAgICAgICAgIG5vZGUgPSByb290Tm9kZS5ob3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgbm9ybWFsIGRvbVxuICAgICAgICAgIG5vZGUgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBvcmlnaW5hbE5vZGU7XG4gICAgfVxuICAgIC8vIGVsc2UsIGBnZXRTaGFkb3dSb290YCBtaWdodCBiZSB0cnVlLCBidXQgYWxsIHRoYXQgZG9lcyBpcyBlbmFibGUgc2hhZG93IERPTSBzdXBwb3J0XG4gICAgLy8gIChpLmUuIGl0IGRvZXMgbm90IGFsc28gcHJlc3VtZSB0aGF0IGFsbCBub2RlcyBtaWdodCBoYXZlIHVuZGlzY2xvc2VkIHNoYWRvd3MpOyBvclxuICAgIC8vICBpdCBtaWdodCBiZSBhIGZhbHN5IHZhbHVlLCB3aGljaCBtZWFucyBzaGFkb3cgRE9NIHN1cHBvcnQgaXMgZGlzYWJsZWRcblxuICAgIC8vIFNpbmNlIHdlIGRpZG4ndCBmaW5kIGl0IHNpdHRpbmcgaW4gYW4gdW5kaXNjbG9zZWQgc2hhZG93IChvciBzaGFkb3dzIGFyZSBkaXNhYmxlZClcbiAgICAvLyAgbm93IHdlIGNhbiBqdXN0IHRlc3QgdG8gc2VlIGlmIGl0IHdvdWxkIG5vcm1hbGx5IGJlIHZpc2libGUgb3Igbm90LCBwcm92aWRlZCBpdCdzXG4gICAgLy8gIGF0dGFjaGVkIHRvIHRoZSBtYWluIGRvY3VtZW50LlxuICAgIC8vIE5PVEU6IFdlIG11c3QgY29uc2lkZXIgY2FzZSB3aGVyZSBub2RlIGlzIGluc2lkZSBhIHNoYWRvdyBET00gYW5kIGdpdmVuIGRpcmVjdGx5IHRvXG4gICAgLy8gIGBpc1RhYmJhYmxlKClgIG9yIGBpc0ZvY3VzYWJsZSgpYCAtLSByZWdhcmRsZXNzIG9mIGBnZXRTaGFkb3dSb290YCBvcHRpb24gc2V0dGluZy5cblxuICAgIGlmIChpc05vZGVBdHRhY2hlZChub2RlKSkge1xuICAgICAgLy8gdGhpcyB3b3JrcyB3aGVyZXZlciB0aGUgbm9kZSBpczogaWYgdGhlcmUncyBhdCBsZWFzdCBvbmUgY2xpZW50IHJlY3QsIGl0J3NcbiAgICAgIC8vICBzb21laG93IGRpc3BsYXllZDsgaXQgYWxzbyBjb3ZlcnMgdGhlIENTUyAnZGlzcGxheTogY29udGVudHMnIGNhc2Ugd2hlcmUgdGhlXG4gICAgICAvLyAgbm9kZSBpdHNlbGYgaXMgaGlkZGVuIGluIHBsYWNlIG9mIGl0cyBjb250ZW50czsgYW5kIHRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2hcbiAgICAgIC8vICB1cCB0aGUgaGllcmFyY2h5IGVpdGhlclxuICAgICAgcmV0dXJuICFub2RlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIEVsc2UsIHRoZSBub2RlIGlzbid0IGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhlIGBnZXRDbGllbnRSZWN0cygpYFxuICAgIC8vICBBUEkgd2lsbCBfX2Fsd2F5c19fIHJldHVybiB6ZXJvIHJlY3RzICh0aGlzIGNhbiBoYXBwZW4sIGZvciBleGFtcGxlLCBpZiBSZWFjdFxuICAgIC8vICBpcyB1c2VkIHRvIHJlbmRlciBub2RlcyBvbnRvIGEgZGV0YWNoZWQgdHJlZSwgYXMgY29uZmlybWVkIGluIHRoaXMgdGhyZWFkOlxuICAgIC8vICBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzkxMTcjaXNzdWVjb21tZW50LTI4NDIyODg3MClcbiAgICAvL1xuICAgIC8vIEl0IGFsc28gbWVhbnMgdGhhdCBldmVuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLmRpc3BsYXkgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAvLyAgYmVjYXVzZSBzdHlsZXMgYXJlIG9ubHkgY29tcHV0ZWQgZm9yIG5vZGVzIHRoYXQgYXJlIGluIHRoZSBkb2N1bWVudC5cbiAgICAvL1xuICAgIC8vIE5PVEU6IFRISVMgSEFTIEJFRU4gVEhFIENBU0UgRk9SIFlFQVJTLiBJdCBpcyBub3QgbmV3LCBub3IgaXMgaXQgY2F1c2VkIGJ5IHRhYmJhYmxlXG4gICAgLy8gIHNvbWVob3cuIFRob3VnaCBpdCB3YXMgbmV2ZXIgc3RhdGVkIG9mZmljaWFsbHksIGFueW9uZSB3aG8gaGFzIGV2ZXIgdXNlZCB0YWJiYWJsZVxuICAgIC8vICBBUElzIG9uIG5vZGVzIGluIGRldGFjaGVkIGNvbnRhaW5lcnMgaGFzIGFjdHVhbGx5IGltcGxpY2l0bHkgdXNlZCB0YWJiYWJsZSBpbiB3aGF0XG4gICAgLy8gIHdhcyBsYXRlciAoYXMgb2YgdjUuMi4wIG9uIEFwciA5LCAyMDIxKSBjYWxsZWQgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgbW9kZSAtLSBlc3NlbnRpYWxseVxuICAgIC8vICBjb25zaWRlcmluZyBfX2V2ZXJ5dGhpbmdfXyB0byBiZSB2aXNpYmxlIGJlY2F1c2Ugb2YgdGhlIGlubmFiaWxpdHkgdG8gZGV0ZXJtaW5lIHN0eWxlcy5cbiAgICAvL1xuICAgIC8vIHY2LjAuMDogQXMgb2YgdGhpcyBtYWpvciByZWxlYXNlLCB0aGUgZGVmYXVsdCAnZnVsbCcgb3B0aW9uIF9fbm8gbG9uZ2VyIHRyZWF0cyBkZXRhY2hlZFxuICAgIC8vICBub2RlcyBhcyB2aXNpYmxlIHdpdGggdGhlICdub25lJyBmYWxsYmFjay5fX1xuICAgIGlmIChkaXNwbGF5Q2hlY2sgIT09ICdsZWdhY3ktZnVsbCcpIHtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBoaWRkZW5cbiAgICB9XG4gICAgLy8gZWxzZSwgZmFsbGJhY2sgdG8gJ25vbmUnIG1vZGUgYW5kIGNvbnNpZGVyIHRoZSBub2RlIHZpc2libGVcbiAgfSBlbHNlIGlmIChkaXNwbGF5Q2hlY2sgPT09ICdub24temVyby1hcmVhJykge1xuICAgIC8vIE5PVEU6IEV2ZW4gdGhvdWdoIHRoaXMgdGVzdHMgdGhhdCB0aGUgbm9kZSdzIGNsaWVudCByZWN0IGlzIG5vbi16ZXJvIHRvIGRldGVybWluZVxuICAgIC8vICB3aGV0aGVyIGl0J3MgZGlzcGxheWVkLCBhbmQgdGhhdCBhIGRldGFjaGVkIG5vZGUgd2lsbCBfX2Fsd2F5c19fIGhhdmUgYSB6ZXJvLWFyZWFcbiAgICAvLyAgY2xpZW50IHJlY3QsIHdlIGRvbid0IHNwZWNpYWwtY2FzZSBmb3Igd2hldGhlciB0aGUgbm9kZSBpcyBhdHRhY2hlZCBvciBub3QuIEluXG4gICAgLy8gIHRoaXMgbW9kZSwgd2UgZG8gd2FudCB0byBjb25zaWRlciBub2RlcyB0aGF0IGhhdmUgYSB6ZXJvIGFyZWEgdG8gYmUgaGlkZGVuIGF0IGFsbFxuICAgIC8vICB0aW1lcywgYW5kIHRoYXQgaW5jbHVkZXMgYXR0YWNoZWQgb3Igbm90LlxuICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xuICB9XG5cbiAgLy8gdmlzaWJsZSwgYXMgZmFyIGFzIHdlIGNhbiB0ZWxsLCBvciBwZXIgY3VycmVudCBgZGlzcGxheUNoZWNrPW5vbmVgIG1vZGUsIHdlIGFzc3VtZVxuICAvLyAgaXQncyB2aXNpYmxlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIGZvcm0gZmllbGRzIChuZXN0ZWQpIGluc2lkZSBhIGRpc2FibGVkIGZpZWxkc2V0IGFyZSBub3QgZm9jdXNhYmxlL3RhYmJhYmxlXG4vLyAgdW5sZXNzIHRoZXkgYXJlIGluIHRoZSBfZmlyc3RfIDxsZWdlbmQ+IGVsZW1lbnQgb2YgdGhlIHRvcC1tb3N0IGRpc2FibGVkXG4vLyAgZmllbGRzZXRcbmNvbnN0IGlzRGlzYWJsZWRGcm9tRmllbGRzZXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoL14oSU5QVVR8QlVUVE9OfFNFTEVDVHxURVhUQVJFQSkkLy50ZXN0KG5vZGUudGFnTmFtZSkpIHtcbiAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAvLyBjaGVjayBpZiBgbm9kZWAgaXMgY29udGFpbmVkIGluIGEgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS50YWdOYW1lID09PSAnRklFTERTRVQnICYmIHBhcmVudE5vZGUuZGlzYWJsZWQpIHtcbiAgICAgICAgLy8gbG9vayBmb3IgdGhlIGZpcnN0IDxsZWdlbmQ+IGFtb25nIHRoZSBjaGlsZHJlbiBvZiB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHBhcmVudE5vZGUuY2hpbGRyZW4uaXRlbShpKTtcbiAgICAgICAgICAvLyB3aGVuIHRoZSBmaXJzdCA8bGVnZW5kPiAoaW4gZG9jdW1lbnQgb3JkZXIpIGlzIGZvdW5kXG4gICAgICAgICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09ICdMRUdFTkQnKSB7XG4gICAgICAgICAgICAvLyBpZiBpdHMgcGFyZW50IDxmaWVsZHNldD4gaXMgbm90IG5lc3RlZCBpbiBhbm90aGVyIGRpc2FibGVkIDxmaWVsZHNldD4sXG4gICAgICAgICAgICAvLyByZXR1cm4gd2hldGhlciBgbm9kZWAgaXMgYSBkZXNjZW5kYW50IG9mIGl0cyBmaXJzdCA8bGVnZW5kPlxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChwYXJlbnROb2RlLCAnZmllbGRzZXRbZGlzYWJsZWRdIConKVxuICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgOiAhY2hpbGQuY29udGFpbnMobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkaXNhYmxlZCA8ZmllbGRzZXQ+IGNvbnRhaW5pbmcgYG5vZGVgIGhhcyBubyA8bGVnZW5kPlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gZWxzZSwgbm9kZSdzIHRhYmJhYmxlL2ZvY3VzYWJsZSBzdGF0ZSBzaG91bGQgbm90IGJlIGFmZmVjdGVkIGJ5IGEgZmllbGRzZXQnc1xuICAvLyAgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIG5vZGUpIHtcbiAgaWYgKFxuICAgIG5vZGUuZGlzYWJsZWQgfHxcbiAgICBpc0hpZGRlbklucHV0KG5vZGUpIHx8XG4gICAgaXNIaWRkZW4obm9kZSwgb3B0aW9ucykgfHxcbiAgICAvLyBGb3IgYSBkZXRhaWxzIGVsZW1lbnQgd2l0aCBhIHN1bW1hcnksIHRoZSBzdW1tYXJ5IGVsZW1lbnQgZ2V0cyB0aGUgZm9jdXNcbiAgICBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB8fFxuICAgIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQobm9kZSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIG5vZGUpIHtcbiAgaWYgKFxuICAgIGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB8fFxuICAgIGdldFRhYmluZGV4KG5vZGUpIDwgMCB8fFxuICAgICFpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUgPSBmdW5jdGlvbiAoc2hhZG93SG9zdE5vZGUpIHtcbiAgY29uc3QgdGFiSW5kZXggPSBwYXJzZUludChzaGFkb3dIb3N0Tm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKTtcbiAgaWYgKGlzTmFOKHRhYkluZGV4KSB8fCB0YWJJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSWYgYSBjdXN0b20gZWxlbWVudCBoYXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgdGFiaW5kZXgsXG4gIC8vIGJyb3dzZXJzIHdpbGwgbm90IGFsbG93IHRhYiB0YXJnZXRpbmcgc2FpZCBlbGVtZW50J3MgY2hpbGRyZW4uXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48RWxlbWVudHxDYW5kaWRhdGVTY29wZT59IGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIEVsZW1lbnRbXVxuICovXG5jb25zdCBzb3J0QnlPcmRlciA9IGZ1bmN0aW9uIChjYW5kaWRhdGVzKSB7XG4gIGNvbnN0IHJlZ3VsYXJUYWJiYWJsZXMgPSBbXTtcbiAgY29uc3Qgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuICBjYW5kaWRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICBjb25zdCBpc1Njb3BlID0gISFpdGVtLnNjb3BlUGFyZW50O1xuICAgIGNvbnN0IGVsZW1lbnQgPSBpc1Njb3BlID8gaXRlbS5zY29wZVBhcmVudCA6IGl0ZW07XG4gICAgY29uc3QgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRUYWJpbmRleChlbGVtZW50LCBpc1Njb3BlKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IGlzU2NvcGUgPyBzb3J0QnlPcmRlcihpdGVtLmNhbmRpZGF0ZXMpIDogZWxlbWVudDtcbiAgICBpZiAoY2FuZGlkYXRlVGFiaW5kZXggPT09IDApIHtcbiAgICAgIGlzU2NvcGVcbiAgICAgICAgPyByZWd1bGFyVGFiYmFibGVzLnB1c2goLi4uZWxlbWVudHMpXG4gICAgICAgIDogcmVndWxhclRhYmJhYmxlcy5wdXNoKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxuICAgICAgICB0YWJJbmRleDogY2FuZGlkYXRlVGFiaW5kZXgsXG4gICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgIGlzU2NvcGU6IGlzU2NvcGUsXG4gICAgICAgIGNvbnRlbnQ6IGVsZW1lbnRzLFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3JkZXJlZFRhYmJhYmxlc1xuICAgIC5zb3J0KHNvcnRPcmRlcmVkVGFiYmFibGVzKVxuICAgIC5yZWR1Y2UoKGFjYywgc29ydGFibGUpID0+IHtcbiAgICAgIHNvcnRhYmxlLmlzU2NvcGVcbiAgICAgICAgPyBhY2MucHVzaCguLi5zb3J0YWJsZS5jb250ZW50KVxuICAgICAgICA6IGFjYy5wdXNoKHNvcnRhYmxlLmNvbnRlbnQpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSlcbiAgICAuY29uY2F0KHJlZ3VsYXJUYWJiYWJsZXMpO1xufTtcblxuY29uc3QgdGFiYmFibGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgbGV0IGNhbmRpZGF0ZXM7XG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtlbF0sIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwge1xuICAgICAgZmlsdGVyOiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICAgIGZsYXR0ZW46IGZhbHNlLFxuICAgICAgZ2V0U2hhZG93Um9vdDogb3B0aW9ucy5nZXRTaGFkb3dSb290LFxuICAgICAgc2hhZG93Um9vdEZpbHRlcjogaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhcbiAgICAgIGVsLFxuICAgICAgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLFxuICAgICAgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIHJldHVybiBzb3J0QnlPcmRlcihjYW5kaWRhdGVzKTtcbn07XG5cbmNvbnN0IGZvY3VzYWJsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBsZXQgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoXG4gICAgICBlbCxcbiAgICAgIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lcixcbiAgICAgIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbmNvbnN0IGlzVGFiYmFibGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBjYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5jb25zdCBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqLyBjYW5kaWRhdGVTZWxlY3RvcnNcbiAgLmNvbmNhdCgnaWZyYW1lJylcbiAgLmpvaW4oJywnKTtcblxuY29uc3QgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpO1xufTtcblxuZXhwb3J0IHsgdGFiYmFibGUsIGZvY3VzYWJsZSwgaXNUYWJiYWJsZSwgaXNGb2N1c2FibGUgfTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnaW5lcnQnLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIC8qKlxuICAgKiBUaGlzIHdvcmsgaXMgbGljZW5zZWQgdW5kZXIgdGhlIFczQyBTb2Z0d2FyZSBhbmQgRG9jdW1lbnQgTGljZW5zZVxuICAgKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICAgKi9cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgTm9kZUxpc3RzLlxuICAgIC8qKiBAdHlwZSB7dHlwZW9mIEFycmF5LnByb3RvdHlwZS5zbGljZX0gKi9cbiAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICAvKipcbiAgICAgKiBJRSBoYXMgYSBub24tc3RhbmRhcmQgbmFtZSBmb3IgXCJtYXRjaGVzXCIuXG4gICAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgICAqL1xuICAgIHZhciBtYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvcjtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHZhciBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcgPSBbJ2FbaHJlZl0nLCAnYXJlYVtocmVmXScsICdpbnB1dDpub3QoW2Rpc2FibGVkXSknLCAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKScsICd0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSknLCAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKScsICdkZXRhaWxzJywgJ3N1bW1hcnknLCAnaWZyYW1lJywgJ29iamVjdCcsICdlbWJlZCcsICdbY29udGVudGVkaXRhYmxlXSddLmpvaW4oJywnKTtcblxuICAgIC8qKlxuICAgICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgICAqIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtIHRvIGNyZWF0ZSBhbmQgbWFpbnRhaW4gYSBzZXQgb2YgbWFuYWdlZCBgSW5lcnROb2RlYHMsIGluY2x1ZGluZyB3aGVuIG11dGF0aW9ucyBvY2N1ciBpbiB0aGVcbiAgICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICAgKiAgIGVhY2ggZm9jdXNhYmxlIG5vZGUgaW4gdGhlIHN1YnRyZWUgd2l0aCB0aGUgc2luZ2xldG9uIGBJbmVydE1hbmFnZXJgIHdoaWNoIG1hbmFnZXMgYWxsIGtub3duXG4gICAgICogICBmb2N1c2FibGUgbm9kZXMgd2l0aGluIGluZXJ0IHN1YnRyZWVzLiBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWBcbiAgICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAgICpcbiAgICAgKiAtIHRvIG5vdGlmeSBhbGwgbWFuYWdlZCBgSW5lcnROb2RlYHMgd2hlbiB0aGlzIHN1YnRyZWUgc3RvcHMgYmVpbmcgaW5lcnQgKGkuZS4gd2hlbiB0aGUgYGluZXJ0YFxuICAgICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICAgKiAgIGBkZXJlZ2lzdGVyYCBtZXRob2Qgb24gYEluZXJ0TWFuYWdlcmAgZm9yIGVhY2ggbWFuYWdlZCBpbmVydCBub2RlLlxuICAgICAqL1xuXG4gICAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IHJvb3RFbGVtZW50IFRoZSBIVE1MRWxlbWVudCBhdCB0aGUgcm9vdCBvZiB0aGUgaW5lcnQgc3VidHJlZS5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0Um9vdChyb290RWxlbWVudCwgaW5lcnRNYW5hZ2VyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gaW5lcnRNYW5hZ2VyO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IHJvb3RFbGVtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAgICogQWxsIG1hbmFnZWQgZm9jdXNhYmxlIG5vZGVzIGluIHRoaXMgSW5lcnRSb290J3Mgc3VidHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAvLyBNYWtlIHRoZSBzdWJ0cmVlIGhpZGRlbiBmcm9tIGFzc2lzdGl2ZSB0ZWNobm9sb2d5XG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpIHtcbiAgICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gdGhpcy5fcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUodGhpcy5fcm9vdEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhdGNoIGZvcjpcbiAgICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAgIC8vIC0gYW55IHJlbW92YWxzIGZyb20gdGhlIHN1YnRyZWU6IHJlbW92ZSB0aGVtIGZyb20gdGhpcyBpbmVydCByb290J3MgbWFuYWdlZCBub2Rlc1xuICAgICAgICAvLyAtIGF0dHJpYnV0ZSBjaGFuZ2VzOiBpZiBgdGFiaW5kZXhgIGlzIGFkZGVkLCBvciByZW1vdmVkIGZyb20gYW4gaW50cmluc2ljYWxseSBmb2N1c2FibGVcbiAgICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9vbk11dGF0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX3Jvb3RFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiAgVGhpcyB1bndpbmRzIGFsbCBvZiB0aGUgc3RhdGVcbiAgICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Um9vdCwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1hbmFnZU5vZGUoaW5lcnROb2RlLm5vZGUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gTm90ZSB3ZSBjYXN0IHRoZSBudWxscyB0byB0aGUgQU5ZIHR5cGUgaGVyZSBiZWNhdXNlOlxuICAgICAgICAgIC8vIDEpIFdlIHdhbnQgdGhlIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZGVjbGFyZWQgYXMgbm9uLW51bGwsIG9yIGVsc2Ugd2VcbiAgICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAgIC8vICAgIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCBhbmQgYSBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAgICAgIC8vIDIpIFdlIGRvbid0IHdhbnQgdG8gY2FzdCBcInRoaXNcIiwgYmVjYXVzZSB3ZSB3YW50IHR5cGUtYXdhcmUgb3B0aW1pemF0aW9uc1xuICAgICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHshU2V0PCFJbmVydE5vZGU+fSBBIGNvcHkgb2YgdGhpcyBJbmVydFJvb3QncyBtYW5hZ2VkIG5vZGVzIHNldC5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHN0YXJ0Tm9kZSkge1xuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl92aXNpdE5vZGUobm9kZSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoc3RhcnROb2RlKSkge1xuICAgICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGU7XG4gICAgICAgICAgICAvKiogQHR5cGUgeyFTaGFkb3dSb290fHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgICAgLy8gSW4gSUUxMSwgaWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IGZvY3VzZWQsIGFuZCB0aGVuIHNldCB0byB0YWJpbmRleD0tMVxuICAgICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzIHdlIGNhbGwgZm9jdXMoKSBvbiB0aGUgYm9keSBpbnN0ZWFkLlxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ192aXNpdE5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovbm9kZTtcblxuICAgICAgICAgIC8vIElmIGEgZGVzY2VuZGFudCBpbmVydCByb290IGJlY29tZXMgdW4taW5lcnQsIGl0cyBkZXNjZW5kYW50cyB3aWxsIHN0aWxsIGJlIGluZXJ0IGJlY2F1c2Ugb2ZcbiAgICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdChlbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19tYW5hZ2VOb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5hZGQoaW5lcnROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlciB0aGUgZW50aXJlIHN1YnRyZWUgc3RhcnRpbmcgYXQgYHN0YXJ0Tm9kZWAuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdW5tYW5hZ2VTdWJ0cmVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhIGRlc2NlbmRhbnQgbm9kZSBpcyBmb3VuZCB3aXRoIGFuIGBpbmVydGAgYXR0cmlidXRlLCBhZG9wdCBpdHMgbWFuYWdlZCBub2Rlcy5cbiAgICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2Fkb3B0SW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG5cbiAgICAgICAgICAvLyBEdXJpbmcgaW5pdGlhbGlzYXRpb24gdGhpcyBpbmVydCByb290IG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgeWV0LFxuICAgICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICAgIGlmICghaW5lcnRTdWJyb290KSB7XG4gICAgICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIuc2V0SW5lcnQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0U3Vicm9vdC5tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoc2F2ZWRJbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgc3VidHJlZSBhZGRpdGlvbnMsIHJlbW92YWxzLCBvciBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gcmVjb3Jkc1xuICAgICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk11dGF0aW9uKHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgIC8vIE1hbmFnZSBhZGRlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShub2RlKTtcbiAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQucmVtb3ZlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5tYW5hZ2VTdWJ0cmVlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICd0YWJpbmRleCcpIHtcbiAgICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAnaW5lcnQnICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgbWFuYWdlZCBub2RlcyBmcm9tIHRoaXMgaW5lcnQgc3Vicm9vdC5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNvbnRhaW5zKG1hbmFnZWROb2RlLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ21hbmFnZWROb2RlcycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuX21hbmFnZWROb2Rlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdoYXNTYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBhcmlhSGlkZGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRSb290O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAgICogQSBub2RlIGlzIGluZXJ0IGlmIGl0IGlzIGEgZGVzY2VuZGFudCBvZiBvbmUgb3IgbW9yZSBpbmVydCByb290IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAgICogZWl0aGVyIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIG9yIHNldHMgaXQgdG8gYC0xYCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGVsZW1lbnRcbiAgICAgKiBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZSBvciBub3QuXG4gICAgICpcbiAgICAgKiBgSW5lcnROb2RlYCBtYWludGFpbnMgYSBzZXQgb2YgYEluZXJ0Um9vdGBzIHdoaWNoIGFyZSBkZXNjZW5kYW50cyBvZiB0aGlzIGBJbmVydE5vZGVgLiBXaGVuIGFuXG4gICAgICogYEluZXJ0Um9vdGAgaXMgZGVzdHJveWVkLCBhbmQgY2FsbHMgYEluZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKClgLCB0aGUgYEluZXJ0TWFuYWdlcmAgbm90aWZpZXMgdGhlXG4gICAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgICAqIHJlbWFpbiBpbiB0aGUgc2V0LiBPbiBkZXN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgcmVpbnN0YXRlcyB0aGUgc3RvcmVkIGB0YWJpbmRleGAgaWYgb25lIGV4aXN0cyxcbiAgICAgKiBvciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBpZiB0aGUgZWxlbWVudCBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZS5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdCBUaGUgaW5lcnQgcm9vdCBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluZXJ0IG5vZGUuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Tm9kZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi9cbiAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydFJvb3Q+fSBUaGUgc2V0IG9mIGRlc2NlbmRhbnQgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqICAgIElmIGFuZCBvbmx5IGlmIHRoaXMgc2V0IGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IFNldChbaW5lcnRSb290XSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgICAgdGhpcy5lbnN1cmVVbnRhYmJhYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS5cbiAgICAgICAqIFRoaXMgbWFrZXMgdGhlIG1hbmFnZWQgbm9kZSBmb2N1c2FibGUgYWdhaW4gYW5kIGRlbGV0ZXMgYWxsIG9mIHRoZSBwcmV2aW91c2x5IHN0b3JlZCBzdGF0ZS5cbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydE5vZGUsIFt7XG4gICAgICAgIGtleTogJ2Rlc3RydWN0b3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fbm9kZSAmJiB0aGlzLl9ub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGhpcy5fc2F2ZWRUYWJJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50LmZvY3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNlZSBub3RlIGluIEluZXJ0Um9vdC5kZXN0cnVjdG9yIGZvciB3aHkgd2UgY2FzdCB0aGVzZSBudWxscyB0byBBTlkuXG4gICAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9ic29sZXRlIGJlY2F1c2UgdGhlIG1hbmFnZWQgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaHJvdyBpZiB1c2VyIHRyaWVzIHRvIGFjY2VzcyBkZXN0cm95ZWQgSW5lcnROb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90aHJvd0lmRGVzdHJveWVkKCkge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdlbnN1cmVVbnRhYmJhYmxlJyxcblxuXG4gICAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlVW50YWJiYWJsZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5ub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMubm9kZTtcbiAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICAgIGlmICggLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleCA9PT0gLTEgJiYgdGhpcy5oYXNTYXZlZFRhYkluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkSW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cy5hZGQoaW5lcnRSb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGluZXJ0IHJvb3QgZnJvbSB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIElmIHRoZSBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydCxcbiAgICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmVJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShpbmVydFJvb3QpO1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXN0cm95ZWQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHshTm9kZX0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdub2RlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzYXZlZFRhYkluZGV4JyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IHRhYkluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4gez9udW1iZXJ9ICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4O1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydE5vZGU7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogSW5lcnRNYW5hZ2VyIGlzIGEgcGVyLWRvY3VtZW50IHNpbmdsZXRvbiBvYmplY3Qgd2hpY2ggbWFuYWdlcyBhbGwgaW5lcnQgcm9vdHMgYW5kIG5vZGVzLlxuICAgICAqXG4gICAgICogV2hlbiBhbiBlbGVtZW50IGJlY29tZXMgYW4gaW5lcnQgcm9vdCBieSBoYXZpbmcgYW4gYGluZXJ0YCBhdHRyaWJ1dGUgc2V0IGFuZC9vciBpdHMgYGluZXJ0YFxuICAgICAqIHByb3BlcnR5IHNldCB0byBgdHJ1ZWAsIHRoZSBgc2V0SW5lcnRgIG1ldGhvZCBjcmVhdGVzIGFuIGBJbmVydFJvb3RgIG9iamVjdCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgICAqIG5vZGVzIHZpYSB0aGUgYHJlZ2lzdGVyKClgIG1ldGhvZC4gVGhlIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYCBpbnN0YW5jZVxuICAgICAqIGlzIGNyZWF0ZWQgZm9yIGVhY2ggc3VjaCBub2RlLCB2aWEgdGhlIGBfbWFuYWdlZE5vZGVzYCBtYXAuXG4gICAgICovXG5cblxuICAgIHZhciBJbmVydE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydE1hbmFnZXIoZG9jdW1lbnQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudDsgSW5lcnRNYW5hZ2VyIG5lZWRzIHRvIHdyYXAgYSBkb2N1bWVudC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAdHlwZSB7IURvY3VtZW50fSAqL1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBub2RlcyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Tm9kZT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Um9vdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnNlcnZlciBmb3IgbXV0YXRpb25zIG9uIGBkb2N1bWVudC5ib2R5YC5cbiAgICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl93YXRjaEZvckluZXJ0LmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgICAgYWRkSW5lcnRTdHlsZShkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcblxuICAgICAgICAvLyBXYWl0IGZvciBkb2N1bWVudCB0byBiZSBsb2FkZWQuXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25Eb2N1bWVudExvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBzaG91bGQgYmUgYW4gaW5lcnQgcm9vdCBvciBub3QuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdFxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0TWFuYWdlciwgW3tcbiAgICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5lcnQocm9vdCwgaW5lcnQpIHtcbiAgICAgICAgICBpZiAoaW5lcnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgaW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5lcnRSb290ID0gbmV3IEluZXJ0Um9vdChyb290LCB0aGlzKTtcbiAgICAgICAgICAgIHJvb3Quc2V0QXR0cmlidXRlKCdpbmVydCcsICcnKTtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgICAvLyBJZiBub3QgY29udGFpbmVkIGluIHRoZSBkb2N1bWVudCwgaXQgbXVzdCBiZSBpbiBhIHNoYWRvd1Jvb3QuXG4gICAgICAgICAgICAvLyBFbnN1cmUgaW5lcnQgc3R5bGVzIGFyZSBhZGRlZCB0aGVyZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcm9vdC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICAgIGFkZEluZXJ0U3R5bGUocGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgbm9uLWluZXJ0XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9pbmVydFJvb3QgPSB0aGlzLl9pbmVydFJvb3RzLmdldChyb290KTtcbiAgICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10ocm9vdCk7XG4gICAgICAgICAgICByb290LnJlbW92ZUF0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBlbGVtZW50XG4gICAgICAgICAqIEByZXR1cm4geyFJbmVydFJvb3R8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW5lcnRSb290cy5nZXQoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgICAgICogSW4gdGhlIGNhc2Ugd2hlcmUgdGhlIG5vZGUgaGFzIGEgcHJldmlvdXNseSBleGlzdGluZyBpbmVydCByb290LCB0aGlzIGluZXJ0IHJvb3Qgd2lsbFxuICAgICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5fbWFuYWdlZE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIGFscmVhZHkgaW4gYW4gaW5lcnQgc3VidHJlZVxuICAgICAgICAgICAgaW5lcnROb2RlLmFkZEluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmVydE5vZGUgPSBuZXcgSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZS1yZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBpbmVydCBub2RlLlxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBpbmVydCByb290IGZyb20gdGhlIEluZXJ0Tm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cywgYW5kIHJlbW92ZSB0aGUgaW5lcnRcbiAgICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgICAqIElmIHRoZSBub2RlIGlzIG5vdCBjdXJyZW50bHkgbWFuYWdlZCwgdGhpcyBpcyBlc3NlbnRpYWxseSBhIG5vLW9wLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqIEByZXR1cm4gez9JbmVydE5vZGV9IFRoZSBwb3RlbnRpYWxseSBkZXN0cm95ZWQgSW5lcnROb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIGlmIGFueS5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVyZWdpc3RlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmICghaW5lcnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmVydE5vZGUucmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gZG9jdW1lbnQgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19vbkRvY3VtZW50TG9hZGVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAgIC8vIEZpbmQgYWxsIGluZXJ0IHJvb3RzIGluIGRvY3VtZW50IGFuZCBtYWtlIHRoZW0gYWN0dWFsbHkgaW5lcnQuXG4gICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RvY3VtZW50LmJvZHkgfHwgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIHN1YnRyZWU6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gcmVjb3Jkc1xuICAgICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YXRjaEZvckluZXJ0KHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NoaWxkTGlzdCc6XG4gICAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsICdbaW5lcnRdJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXR0cmlidXRlcyc6XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lICE9PSAnaW5lcnQnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9yZWNvcmQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0SW5lcnQodGFyZ2V0LCBpbmVydCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0TWFuYWdlcjtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSB3YWxrIHRoZSBjb21wb3NlZCB0cmVlIGZyb20gfG5vZGV8LlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUhUTUxFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAgICogICAgIGJlZm9yZSBkZXNjZW5kaW5nIGludG8gY2hpbGQgbm9kZXMuXG4gICAgICogQHBhcmFtIHs/U2hhZG93Um9vdD19IHNoYWRvd1Jvb3RBbmNlc3RvciBUaGUgbmVhcmVzdCBTaGFkb3dSb290IGFuY2VzdG9yLCBpZiBhbnkuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNvbXBvc2VkVHJlZVdhbGsobm9kZSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcikge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlc2NlbmQgaW50byBub2RlOlxuICAgICAgICAvLyBJZiBpdCBoYXMgYSBTaGFkb3dSb290LCBpZ25vcmUgYWxsIGNoaWxkIGVsZW1lbnRzIC0gdGhlc2Ugd2lsbCBiZSBwaWNrZWRcbiAgICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgICAvLyBTaGFkb3dSb290LlxuICAgICAgICB2YXIgc2hhZG93Um9vdCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHNoYWRvd1Jvb3QsIGNhbGxiYWNrLCBzaGFkb3dSb290KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyBhIDxjb250ZW50PiBlbGVtZW50LCBkZXNjZW5kIGludG8gZGlzdHJpYnV0ZWQgZWxlbWVudHMgLSB0aGVzZVxuICAgICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSAvKiogQHR5cGUgeyFIVE1MQ29udGVudEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgIHZhciBkaXN0cmlidXRlZE5vZGVzID0gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzID8gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzKCkgOiBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPHNsb3Q+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBhc3NpZ25lZCBub2RlcyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnc2xvdCcpIHtcbiAgICAgICAgICB2YXIgc2xvdCA9IC8qKiBAdHlwZSB7IUhUTUxTbG90RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgIHZhciBfZGlzdHJpYnV0ZWROb2RlcyA9IHNsb3QuYXNzaWduZWROb2RlcyA/IHNsb3QuYXNzaWduZWROb2Rlcyh7IGZsYXR0ZW46IHRydWUgfSkgOiBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2Rpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBuZWl0aGVyIHRoZSBwYXJlbnQgb2YgYSBTaGFkb3dSb290LCBhIDxjb250ZW50PiBlbGVtZW50LCBhIDxzbG90PlxuICAgICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgICAgdmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0eWxlIGVsZW1lbnQgdG8gdGhlIG5vZGUgY29udGFpbmluZyB0aGUgaW5lcnQgc3BlY2lmaWMgc3R5bGVzXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZEluZXJ0U3R5bGUobm9kZSkge1xuICAgICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdpZCcsICdpbmVydC1zdHlsZScpO1xuICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSAnXFxuJyArICdbaW5lcnRdIHtcXG4nICsgJyAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuJyArICcgIGN1cnNvcjogZGVmYXVsdDtcXG4nICsgJ31cXG4nICsgJ1xcbicgKyAnW2luZXJ0XSwgW2luZXJ0XSAqIHtcXG4nICsgJyAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICB1c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJ31cXG4nO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuXG4gICAgaWYgKCFIVE1MRWxlbWVudC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2luZXJ0JykpIHtcbiAgICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICAgIHZhciBpbmVydE1hbmFnZXIgPSBuZXcgSW5lcnRNYW5hZ2VyKGRvY3VtZW50KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2luZXJ0Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9LFxuICAgICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgICBpbmVydE1hbmFnZXIuc2V0SW5lcnQodGhpcywgaW5lcnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pKCk7XG5cbn0pKSk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBCbG9ja2luZ0VsZW1lbnRzYCBtYW5hZ2VzIGEgc3RhY2sgb2YgZWxlbWVudHMgdGhhdCBpbmVydCB0aGUgaW50ZXJhY3Rpb25cbiAqIG91dHNpZGUgdGhlbS4gVGhlIHRvcCBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGl2ZSBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAqIFRoZSBzdGFjayBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBtZXRob2RzIGBwdXNoLCByZW1vdmUsIHBvcGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tpbmdFbGVtZW50cyB7XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiBUaGlzIGVtcHRpZXNcbiAgICogdGhlIGJsb2NraW5nIGVsZW1lbnRzXG4gICAqL1xuICBkZXN0cnVjdG9yKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIHRvcDogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudCB0byB0aGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZyBlbGVtZW50cy4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgKiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudCBhbmQgcmV0dXJucyBpdC5cbiAgICovXG4gIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGEgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyBleHRlbmRzIERvY3VtZW50IHtcbiAgJGJsb2NraW5nRWxlbWVudHM6IEJsb2NraW5nRWxlbWVudHM7XG59XG5cbigoKSA9PiB7XG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgcHJvcGVydGllcyAqL1xuICBjb25zdCBfYmxvY2tpbmdFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfYWxyZWFkeUluZXJ0RWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3RvcEVsUGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfc2libGluZ3NUb1Jlc3RvcmUgPSBTeW1ib2woKTtcbiAgY29uc3QgX3BhcmVudE1PID0gU3ltYm9sKCk7XG5cbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBzdGF0aWMgbWV0aG9kcyAqL1xuICBjb25zdCBfdG9wQ2hhbmdlZCA9IFN5bWJvbCgpO1xuICBjb25zdCBfc3dhcEluZXJ0ZWRTaWJsaW5nID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pbmVydFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXRQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXREaXN0cmlidXRlZENoaWxkcmVuID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pc0luZXJ0YWJsZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfaGFuZGxlTXV0YXRpb25zID0gU3ltYm9sKCk7XG5cbiAgaW50ZXJmYWNlIEluZXJ0YWJsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBpbmVydD86IGJvb2xlYW47XG4gIH1cblxuICBpbnRlcmZhY2UgSW50ZXJuYWxTdGF0ZSB7XG4gICAgW19zaWJsaW5nc1RvUmVzdG9yZV06IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+O1xuICAgIFtfcGFyZW50TU9dOiBNdXRhdGlvbk9ic2VydmVyO1xuICB9XG4gIGludGVyZmFjZSBIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBJbnRlcm5hbFN0YXRlIHt9XG4gIGludGVyZmFjZSBNYXliZUhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIFBhcnRpYWw8SW50ZXJuYWxTdGF0ZT4ge31cblxuICAvKipcbiAgICogU2hhZHlET00gc2hhZHkgcm9vdHMgbG9vayBhIGxvdCBsaWtlIHJlYWwgU2hhZG93Um9vdHMuIFRoZSBfX3NoYWR5IHByb3BlcnR5XG4gICAqIGdpdmVzIHRoZW0gYXdheSwgdGhvdWdoLlxuICAgKi9cbiAgaW50ZXJmYWNlIE1heWJlU2hhZHlSb290IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgX19zaGFkeTogdW5rbm93bjtcbiAgICBob3N0OiBFbGVtZW50O1xuICB9XG5cbiAgY2xhc3MgQmxvY2tpbmdFbGVtZW50c0ltcGwgaW1wbGVtZW50cyBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYmxvY2tpbmdFbGVtZW50c106IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHBhcmVudHMgb2YgdGhlIHRvcCBlbGVtZW50LCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogaXRzZWxmIHVwIHRvIGJvZHkuIFdoZW4gdG9wIGNoYW5nZXMsIHRoZSBvbGQgdG9wIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICogZnJvbSB0aGUgZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gbWVtb2l6ZSB0aGUgaW5lcnRlZCBwYXJlbnRzJyBzaWJsaW5nc1xuICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlaXIgaW5lcnRlbmVzcyB3aGVuIHRvcCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcEVsUGFyZW50c106IEhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbmVydCBiZWZvcmUgdGhlIGZpcnN0IGJsb2NraW5nIGVsZW1lbnQgaXNcbiAgICAgKiBwdXNoZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbmV3IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+KCk7XG5cbiAgICBkZXN0cnVjdG9yKCk6IHZvaWQge1xuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBpbmVydG5lc3MuXG4gICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXSh0aGlzW190b3BFbFBhcmVudHNdKTtcbiAgICAgIC8vIE5vdGUgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZXNlIHByb3BlcnRpZXMgbnVsbGFibGUgb24gdGhlIGNsYXNzLFxuICAgICAgLy8gc2luY2UgdGhlbiB3ZSdkIG5lZWQgbm9uLW51bGwgY2FzdHMgaW4gbWFueSBwbGFjZXMuIENhbGxpbmcgYSBtZXRob2Qgb25cbiAgICAgIC8vIGEgQmxvY2tpbmdFbGVtZW50cyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRlc3RydWN0b3Igd2lsbCByZXN1bHQgaW4gYW5cbiAgICAgIC8vIGV4Y2VwdGlvbi5cbiAgICAgIGNvbnN0IG51bGxhYmxlID0gdGhpcyBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgW19ibG9ja2luZ0VsZW1lbnRzXTogbnVsbDtcbiAgICAgICAgW190b3BFbFBhcmVudHNdOiBudWxsO1xuICAgICAgICBbX2FscmVhZHlJbmVydEVsZW1lbnRzXTogbnVsbDtcbiAgICAgIH07XG4gICAgICBudWxsYWJsZVtfYmxvY2tpbmdFbGVtZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX3RvcEVsUGFyZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c107XG4gICAgICByZXR1cm4gZWxlbXNbZWxlbXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy50b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCB3ZSdsbCBicmluZyBpdCB0byB0aGUgdG9wLlxuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB0aGlzW190b3BDaGFuZ2VkXShlbGVtZW50KTtcbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICBjb25zdCBpID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5zcGxpY2UoaSwgMSk7XG4gICAgICAvLyBUb3AgY2hhbmdlZCBvbmx5IGlmIHRoZSByZW1vdmVkIGVsZW1lbnQgd2FzIHRoZSB0b3AgZWxlbWVudC5cbiAgICAgIGlmIChpID09PSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0odGhpcy50b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AgJiYgdGhpcy5yZW1vdmUodG9wKTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgaW5lcnRgIHRvIGFsbCBkb2N1bWVudCBlbGVtZW50cyBleGNlcHQgdGhlIG5ldyB0b3AgZWxlbWVudCwgaXRzXG4gICAgICogcGFyZW50cywgYW5kIGl0cyBkaXN0cmlidXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcENoYW5nZWRdKG5ld1RvcDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlfG51bGwpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgY29uc3Qgb2xkUGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAvLyBObyBuZXcgdG9wLCByZXNldCBvbGQgdG9wIGlmIGFueS5cbiAgICAgIGlmICghbmV3VG9wKSB7XG4gICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMpO1xuICAgICAgICB0b0tlZXBJbmVydC5jbGVhcigpO1xuICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UGFyZW50cyA9IHRoaXNbX2dldFBhcmVudHNdKG5ld1RvcCk7XG4gICAgICAvLyBOZXcgdG9wIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIG1haW4gZG9jdW1lbnQhXG4gICAgICBpZiAobmV3UGFyZW50c1tuZXdQYXJlbnRzLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vbi1jb25uZWN0ZWQgZWxlbWVudCBjYW5ub3QgYmUgYSBibG9ja2luZyBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDYXN0IGhlcmUgYmVjYXVzZSB3ZSBrbm93IHdlJ2xsIGNhbGwgX2luZXJ0U2libGluZ3Mgb24gbmV3UGFyZW50c1xuICAgICAgLy8gYmVsb3cuXG4gICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gbmV3UGFyZW50cyBhcyBBcnJheTxIYXNJbnRlcm5hbFN0YXRlPjtcblxuICAgICAgY29uc3QgdG9Ta2lwID0gdGhpc1tfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0obmV3VG9wKTtcblxuICAgICAgLy8gTm8gcHJldmlvdXMgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoIW9sZFBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBpID0gb2xkUGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGogPSBuZXdQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAvLyBGaW5kIGNvbW1vbiBwYXJlbnQuIEluZGV4IDAgaXMgdGhlIGVsZW1lbnQgaXRzZWxmIChzbyBzdG9wIGJlZm9yZSBpdCkuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgaiA+IDAgJiYgb2xkUGFyZW50c1tpXSA9PT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHVwIHRoZSBwYXJlbnRzIHRyZWUgdGhlcmUgYXJlIDIgZWxlbWVudHMgdGhhdCBhcmUgc2libGluZ3MsIHN3YXBcbiAgICAgIC8vIHRoZSBpbmVydGVkIHNpYmxpbmcuXG4gICAgICBpZiAob2xkUGFyZW50c1tpXSAhPT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICB0aGlzW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZFBhcmVudHNbaV0sIG5ld1BhcmVudHNbal0pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSBvbGQgcGFyZW50cyBzaWJsaW5ncyBpbmVydG5lc3MuXG4gICAgICBpID4gMCAmJiB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzLnNsaWNlKDAsIGkpKTtcbiAgICAgIC8vIE1ha2UgbmV3IHBhcmVudHMgc2libGluZ3MgaW5lcnQuXG4gICAgICBqID4gMCAmJiB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLnNsaWNlKDAsIGopLCB0b1NraXAsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGluZXJ0bmVzcyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3N3YXBJbmVydGVkU2libGluZ10oXG4gICAgICAgIG9sZEluZXJ0OiBIYXNJbnRlcm5hbFN0YXRlLCBuZXdJbmVydDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlKTogdm9pZCB7XG4gICAgICBjb25zdCBzaWJsaW5nc1RvUmVzdG9yZSA9IG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAvLyBvbGRJbmVydCBpcyBub3QgY29udGFpbmVkIGluIHNpYmxpbmdzIHRvIHJlc3RvcmUsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICAgIC8vIGlmIGl0J3MgaW5lcnRhYmxlIGFuZCBpZiBhbHJlYWR5IGluZXJ0LlxuICAgICAgaWYgKHRoaXNbX2lzSW5lcnRhYmxlXShvbGRJbmVydCkgJiYgIW9sZEluZXJ0LmluZXJ0KSB7XG4gICAgICAgIG9sZEluZXJ0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuYWRkKG9sZEluZXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5ld0luZXJ0IHdhcyBhbHJlYWR5IGJldHdlZW4gdGhlIHNpYmxpbmdzIHRvIHJlc3RvcmUsIGl0IG1lYW5zIGl0IGlzXG4gICAgICAvLyBpbmVydGFibGUgYW5kIG11c3QgYmUgcmVzdG9yZWQuXG4gICAgICBpZiAoc2libGluZ3NUb1Jlc3RvcmUuaGFzKG5ld0luZXJ0KSkge1xuICAgICAgICBuZXdJbmVydC5pbmVydCA9IGZhbHNlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5kZWxldGUobmV3SW5lcnQpO1xuICAgICAgfVxuICAgICAgbmV3SW5lcnRbX3BhcmVudE1PXSA9IG9sZEluZXJ0W19wYXJlbnRNT107XG4gICAgICBuZXdJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gc2libGluZ3NUb1Jlc3RvcmU7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBpbmVydG5lc3MgdG8gdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShlbGVtZW50czogSGFzSW50ZXJuYWxTdGF0ZVtdKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbW8gPSBlbGVtZW50W19wYXJlbnRNT107XG4gICAgICAgIG1vLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nIG9mIHNpYmxpbmdzKSB7XG4gICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmVydHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgdGhlIGVsZW1lbnRzIHRvIHNraXAuIFN0b3Jlc1xuICAgICAqIHRoZSBpbmVydGVkIHNpYmxpbmdzIGludG8gdGhlIGVsZW1lbnQncyBzeW1ib2wgYF9zaWJsaW5nc1RvUmVzdG9yZWAuXG4gICAgICogUGFzcyBgdG9LZWVwSW5lcnRgIHRvIGNvbGxlY3QgdGhlIGFscmVhZHkgaW5lcnQgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfaW5lcnRTaWJsaW5nc10oXG4gICAgICAgIGVsZW1lbnRzOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSwgdG9Ta2lwOiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwsXG4gICAgICAgIHRvS2VlcEluZXJ0OiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAvLyBBc3N1bWUgZWxlbWVudCBpcyBub3QgYSBEb2N1bWVudCwgc28gaXQgbXVzdCBoYXZlIGEgcGFyZW50Tm9kZS5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlITtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bal0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIC8vIFNraXAgdGhlIGlucHV0IGVsZW1lbnQsIGlmIG5vdCBpbmVydGFibGUgb3IgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gZWxlbWVudCB8fCAhdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICh0b1NraXAgJiYgdG9Ta2lwLmhhcyhzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaG91bGQgYmUgY29sbGVjdGVkIHNpbmNlIGFscmVhZHkgaW5lcnRlZC5cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBzaWJsaW5ncyB0aGF0IHdlcmUgaW5lcnRlZC5cbiAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gaW5lcnRlZFNpYmxpbmdzO1xuICAgICAgICAvLyBPYnNlcnZlIG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIG11dGF0aW9ucyBvbiB0aGUgcGFyZW50LlxuICAgICAgICBjb25zdCBtbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXNbX2hhbmRsZU11dGF0aW9uc10uYmluZCh0aGlzKSk7XG4gICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IG1vO1xuICAgICAgICBsZXQgcGFyZW50VG9PYnNlcnZlID0gcGFyZW50O1xuICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgU2hhZHlET00gcG9seWZpbGwsIHRoZW4gb3VyIHBhcmVudCBjb3VsZCBiZSBhXG4gICAgICAgIC8vIHNoYWR5IHJvb3QsIHdoaWNoIGlzIGFuIG9iamVjdCB0aGF0IGFjdHMgbGlrZSBhIFNoYWRvd1Jvb3QsIGJ1dCBpc24ndFxuICAgICAgICAvLyBhY3R1YWxseSBhIG5vZGUgaW4gdGhlIHJlYWwgRE9NLiBPYnNlcnZlIHRoZSByZWFsIERPTSBwYXJlbnQgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgbWF5YmVTaGFkeVJvb3QgPSBwYXJlbnRUb09ic2VydmUgYXMgTWF5YmVTaGFkeVJvb3Q7XG4gICAgICAgIGlmIChtYXliZVNoYWR5Um9vdC5fX3NoYWR5ICYmIG1heWJlU2hhZHlSb290Lmhvc3QpIHtcbiAgICAgICAgICBwYXJlbnRUb09ic2VydmUgPSBtYXliZVNoYWR5Um9vdC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG1vLm9ic2VydmUocGFyZW50VG9PYnNlcnZlLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5ld2x5IGFkZGVkL3JlbW92ZWQgbm9kZXMgYnkgdG9nZ2xpbmcgdGhlaXIgaW5lcnRuZXNzLlxuICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBjdXJyZW50IHRvcCBCbG9ja2luZyBFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICogbm90aWZ5aW5nIGFuZCByZW1vdmluZyBpdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19oYW5kbGVNdXRhdGlvbnNdKG11dGF0aW9uczogTXV0YXRpb25SZWNvcmRbXSk6IHZvaWQge1xuICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBzaGFkb3dSb290LCBnZXQgaXRzIGhvc3QgYXMgd2Ugc2tpcCBzaGFkb3dSb290cyB3aGVuXG4gICAgICAgIC8vIGNvbXB1dGluZyBfdG9wRWxQYXJlbnRzLlxuICAgICAgICBjb25zdCB0YXJnZXQgPSAobXV0YXRpb24udGFyZ2V0IGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgP1xuICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggOlxuICAgICAgICAgICAgcGFyZW50cy5pbmRleE9mKHRhcmdldCBhcyBIYXNJbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgY29uc3QgaW5lcnRlZENoaWxkID0gcGFyZW50c1tpZHggLSAxXTtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gaW5lcnRlZENoaWxkW19zaWJsaW5nc1RvUmVzdG9yZV07XG5cbiAgICAgICAgLy8gVG8gcmVzdG9yZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gaW5lcnRlZENoaWxkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RldGVjdGVkIHJlbW92YWwgb2YgdGhlIHRvcCBCbG9ja2luZyBFbGVtZW50LicpO1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZXJ0ZWRTaWJsaW5ncy5oYXMoc2libGluZykpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5kZWxldGUoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gaW5lcnQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGluZXJ0YWJsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19pc0luZXJ0YWJsZV0oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBmYWxzZSA9PT0gL14oc3R5bGV8dGVtcGxhdGV8c2NyaXB0KSQvLnRlc3QoZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmV3UGFyZW50cyBvZiBhbiBlbGVtZW50LCBzdGFydGluZyBmcm9tIGVsZW1lbnRcbiAgICAgKiAoaW5jbHVkZWQpIHVwIHRvIGBkb2N1bWVudC5ib2R5YCAoZXhjbHVkZWQpLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldFBhcmVudHNdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQXJyYXk8SFRNTEVsZW1lbnQ+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50OiBIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZCA9IGVsZW1lbnQ7XG4gICAgICAvLyBTdG9wIHRvIGJvZHkuXG4gICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIC8vIFNraXAgc2hhZG93IHJvb3RzLlxuICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hhZG93RG9tIHYxXG4gICAgICAgIGlmIChjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc2xvdHMgZnJvbSBkZWVwZXN0IHNsb3QgdG8gdG9wLlxuICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udGludWUgdGhlIHNlYXJjaCBvbiB0aGUgdG9wIHNsb3QuXG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgYXMgTm9kZSBhcyBTaGFkb3dSb290KS5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgc2hhZG93IHJvb3QuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0oZWxlbWVudDogSFRNTEVsZW1lbnQpOlxuICAgICAgICBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwge1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuICAgICAgbGV0IG5vZGVzO1xuICAgICAgY29uc3Qgc2xvdHMgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgIGlmIChzbG90cy5sZW5ndGggJiYgc2xvdHNbMF0uYXNzaWduZWROb2Rlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlcyA9IHNsb3RzW2ldLmFzc2lnbmVkTm9kZXMoe1xuICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tqXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmFkZChub2Rlc1tqXSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VhcmNoIGZvciA8Y29udGVudD4uXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIChkb2N1bWVudCBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyA9XG4gICAgICBuZXcgQmxvY2tpbmdFbGVtZW50c0ltcGwoKTtcbn0pKCk7XG4iLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9jdW1lbnQoZWxlbWVudD86IE5vZGUpIHsgcmV0dXJuIChlbGVtZW50Py5vd25lckRvY3VtZW50ID8/IGRvY3VtZW50ID8/IHdpbmRvdy5kb2N1bWVudCA/PyBnbG9iYWxUaGlzLmRvY3VtZW50KTsgfVxuXG50eXBlIFAgPSBQYXJhbWV0ZXJzPHR5cGVvZiBjbHN4PjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURvY3VtZW50Q2xhc3MoY2xhc3NOYW1lOiBQWzBdLCBhY3RpdmU/OiBib29sZWFuLCBlbGVtZW50PzogSFRNTEVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID8/PSBnZXREb2N1bWVudCgpLmRvY3VtZW50RWxlbWVudDtcbiAgICBjbGFzc05hbWUgPSBjbHN4KGNsYXNzTmFtZSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lIGFzIHN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGVsZW1lbnQhLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lIGFzIHN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sIFtjbGFzc05hbWUsIGFjdGl2ZSwgZWxlbWVudF0pO1xuXG59XG4iLCJpbXBvcnQgXCJ3aWNnLWluZXJ0XCI7XG5pbXBvcnQgXCJibG9ja2luZy1lbGVtZW50c1wiO1xuaW1wb3J0IHsgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyB9IGZyb20gXCJibG9ja2luZy1lbGVtZW50c1wiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tIFwiLi91c2UtZG9jdW1lbnQtY2xhc3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHJldHVybk51bGwsIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCB9IGZyb20gXCIuLi9vYnNlcnZlcnMvdXNlLWFjdGl2ZS1lbGVtZW50XCI7XG5cbmZ1bmN0aW9uIGJsb2NraW5nRWxlbWVudHMoKSB7IHJldHVybiAoZ2V0RG9jdW1lbnQoKSBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyB9XG4vKipcbiAqIEFsbG93cyBhbiBlbGVtZW50IHRvIHRyYXAgZm9jdXMgYnkgYXBwbHlpbmcgdGhlIFwiaW5lcnRcIiBhdHRyaWJ1dGUgdG8gYWxsIHNpYmxpbmcsIGF1bnQsIGFuZCB1bmNsZSBub2Rlcy5cbiAqIFxuICogQXV0b21hdGljYWxseSBoYW5kbGVzIGNvbnNlY3V0aXZlIGNhbGxzIHdpdGggYSBsb29zZWx5IGFwcGxpZWQgc3RhY2sgb3BlcmF0aW9uIFxuICogKHNwZWNpZmljYWxseSB2aWEgYGJsb2NraW5nRWxlbWVudHNgLCB3aXRoIGEgc21hbGwgcG9seWZpbGwgYmVjYXVzZSBJJ20gbm90IHN1cmUgaG93IGxvbmdcbiAqIGl0J2xsIHRha2UgdG8gZmluZCBpdHMgd2F5IGludG8gdGhlIHNwZWMsIGlmIGV2ZXIpXG4gKiBAcGFyYW0gdGFyZ2V0IFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmxvY2tpbmdFbGVtZW50PEUgZXh0ZW5kcyBFbGVtZW50PihlbmFibGVkOiBib29sZWFuLCBnZXRUYXJnZXQ6ICgpID0+IChFIHwgbnVsbCkpIHtcblxuICAgIGNvbnN0IHN0YWJsZUdldFRhcmdldCA9IHVzZVN0YWJsZUNhbGxiYWNrKGdldFRhcmdldCk7XG5cbiAgICBjb25zdCBnZXREb2N1bWVudCA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IChnZXRUYXJnZXQoKT8ub3duZXJEb2N1bWVudCA/PyBnbG9iYWxUaGlzLmRvY3VtZW50KSk7XG4gICAgdXNlQWN0aXZlRWxlbWVudCh7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBnZXREb2N1bWVudCxcbiAgICAgICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRMYXN0QWN0aXZlV2hlbk9wZW4oZSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldExhc3RBY3RpdmVXaGVuQ2xvc2VkKGUgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgW2dldFRvcCwgc2V0VG9wXSA9IHVzZVBhc3NpdmVTdGF0ZTxIVE1MRWxlbWVudCB8IG51bGwsIG5ldmVyPihudWxsLCByZXR1cm5OdWxsKTtcbiAgICBjb25zdCBbZ2V0TGFzdEFjdGl2ZVdoZW5DbG9zZWQsIHNldExhc3RBY3RpdmVXaGVuQ2xvc2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxIVE1MRWxlbWVudCB8IG51bGwsIG5ldmVyPihudWxsLCByZXR1cm5OdWxsKTtcbiAgICBjb25zdCBbZ2V0TGFzdEFjdGl2ZVdoZW5PcGVuLCBzZXRMYXN0QWN0aXZlV2hlbk9wZW5dID0gdXNlUGFzc2l2ZVN0YXRlPEhUTUxFbGVtZW50IHwgbnVsbCwgbmV2ZXI+KG51bGwsIHJldHVybk51bGwpO1xuXG4gICAgLyoqXG4gICAgICogUHVzaC9wb3AgdGhlIGVsZW1lbnQgZnJvbSB0aGUgYmxvY2tpbmdFbGVtZW50cyBzdGFjay5cbiAgICAgKi9cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBzdGFibGVHZXRUYXJnZXQoKTtcblxuICAgICAgICBpZiAoZW5hYmxlZCkge1xuXG4gICAgICAgICAgICAvLyBTb21ldGltZXMgYmxvY2tpbmdFbGVtZW50cyB3aWxsIGZhaWwgaWYsIGZvciBleGFtcGxlLFxuICAgICAgICAgICAgLy8gdGhlIHRhcmdldCBlbGVtZW50IGlzbid0IGNvbm5lY3RlZCB0byBkb2N1bWVudC5ib2R5LlxuICAgICAgICAgICAgLy8gVGhpcyBpcyByYXJlLCBidXQgaXQncyBiZXR0ZXIgdG8gZmFpbCBzaWxlbnRseSB3aXRoIHdlaXJkIHRhYmJpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIHRoYW4gdG8gY3Jhc2ggdGhlIGVudGlyZSBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYmxvY2tpbmdFbGVtZW50cygpLnB1c2godGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgc2V0VG9wKHRhcmdldCBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBibG9ja2luZ0VsZW1lbnRzKCkucmVtb3ZlKHRhcmdldCBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gV2VsbCwgc2VtaS1zaWxlbnRseS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtlbmFibGVkXSk7XG5cbiAgICByZXR1cm4geyBnZXRUb3AsIGdldExhc3RBY3RpdmVXaGVuQ2xvc2VkLCBnZXRMYXN0QWN0aXZlV2hlbk9wZW4gfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wRWxlbWVudCgpIHtcbiAgICByZXR1cm4gYmxvY2tpbmdFbGVtZW50cygpLnRvcDtcbn1cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgaXNGb2N1c2FibGUgfSBmcm9tIFwidGFiYmFibGVcIjtcbmltcG9ydCB7IHVzZUJsb2NraW5nRWxlbWVudCB9IGZyb20gXCIuLi9kb20taGVscGVycy91c2UtYmxvY2tpbmctZWxlbWVudFwiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnMsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL2RvbS1oZWxwZXJzL3VzZS1yZWYtZWxlbWVudFwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUZvY3VzVHJhcFBhcmFtZXRlcnM8U291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQgfCBudWxsLCBQb3B1cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFBvcHVwRWxlbWVudD4ge1xuICAgIGZvY3VzVHJhcFBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBmb2N1cyB0cmFwIGlzIGN1cnJlbnRseSBhY3RpdmUgKG9yLCB3aGVuIHVzZWQgYXMgcGFydCBvZiBhIGxhcmdlciBjb21wb25lbnQsIHdoZXRoZXIgaXQgaXMgYWN0aXZhdGFibGUpXG4gICAgICAgICAqL1xuICAgICAgICB0cmFwQWN0aXZlOiBib29sZWFuO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCBmb2N1cyBpcyBub3QgdHJhcHBlZCBidXQgb25seSBtb3ZlZCB0byB0aGUgbmV3IGVsZW1lbnQuIFxuICAgICAgICAgKi9cbiAgICAgICAgb25seU1vdmVGb2N1czogYm9vbGVhbjtcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGEgbW9kYWwgcG9wdXAgb3BlbnMsIGZvY3VzIG11c3QgYmUgc2VudCB0byB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IG1ha2VzIHNlbnNlLlxuICAgICAgICAgKiBcbiAgICAgICAgICogRm9yIGV4YW1wbGUsIGlmIGl0J3MgYSBjb25maXJtYXRpb24gZGlhbG9nIGFib3V0IGRlbGV0aW5nIHNvbWV0aGluZywgaXQncyBiZXN0IHRvIHNlbmQgZm9jdXMgdG8gdGhlIFwiY2FuY2VsXCIgYnV0dG9uLlxuICAgICAgICAgKiBcbiAgICAgICAgICogSW4gb3RoZXIgY2FzZXMsIGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gZm9jdXMgdGhlIGRpYWxvZydzIHRpdGxlLCBmaXJzdCBpbnRlcmFjdGl2ZSBlbGVtZW50LCBldGMuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGlzIGlzIGhpZ2hseSBzdWJqZWN0aXZlIGFuZCAqYWxtb3N0IEFMV0FZUyogbW9yZSBjb21wbGljYXRlZCB0aGFuIGp1c3QgXCJmb2N1cyB0aGUgd2hvbGUgZGlhbG9nIGVsZW1lbnQgaXRzZWxmXCIsXG4gICAgICAgICAqIGJlY2F1c2UgdGhhdCBvbmx5IHdvcmtzIGlmIHRoZSBkaWFsb2cgKioqb25seSBjb250YWlucyB0ZXh0KioqLCB3aGljaCBpcyB1bmNvbW1vbi5cbiAgICAgICAgICogXG4gICAgICAgICAqIElmIHlvdSByZWFsbHksIHJlYWxseSwgKioqZ2VudWluZWx5KioqIGNhbm5vdCBkZXRlcm1pbmUgd2hhdCBzaG91bGQgYmUgZG9uZSBpbiB5b3VyIHVzZSBjYXNlLFxuICAgICAgICAgKiBmaXJzdCBvZiBhbGwsIGtlZXAgdHJ5aW5nLCByZWFsbHksXG4gICAgICAgICAqIHRoZW4gYXMgYSB2ZXJ5IGxhc3QgcmVzb3J0LCB1c2UgYGZpbmRGaXJzdEZvY3VzYWJsZWAsIGFuZCB0aGVuIGlmIG5vdGhpbmcncyBmb3VuZCBmb2N1cyB0aGUgYm9keS4gIFxuICAgICAgICAgKiBKdXN0IHBsZWFzZSwgcGxlYXNlIG1ha2Ugc3VyZSB0aGF0IHdoYXRldmVyIHRoYXQgZmlyc3QgZm9jdXNhYmxlIGlzICoqaXNuJ3QqKiBhIGRlc3RydWN0aXZlIGFjdGlvbiwgYXQgdGhlIHZlcnkgbGVhc3QuIFxuICAgICAgICAgKi9cbiAgICAgICAgZm9jdXNQb3B1cChlOiBQb3B1cEVsZW1lbnQsIGZpbmRGaXJzdEZvY3VzYWJsZTogKCkgPT4gSFRNTE9yU1ZHRWxlbWVudCB8IG51bGwpOiB2b2lkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRoZSBmb2N1cyB0cmFwIGhhcyBkZWFjdGl2YXRlZCwgZm9jdXMgbXVzdCBiZSBzZW50IGJhY2sgdG8gdGhlIGVsZW1lbnQgdGhhdCBvcGVuZWQgaXQuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGlzIGlzIHRyYWNrZWQgZm9yIHlvdTsgYnkgZGVmYXVsdCwganVzdCBjYWxsIGBsYXN0Rm9jdXNlZD8uZm9jdXMoKWAsIGJ1dCB5b3UgY2FuIGFsc28gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvclxuICAgICAgICAgKiBhbmQganVzdCBkbyB3aGF0ZXZlciB5b3Ugd2FudCB3aXRoIGFueSBlbGVtZW50LiAgXG4gICAgICAgICAqIEBwYXJhbSBsYXN0Rm9jdXNlZCBcbiAgICAgICAgICovXG4gICAgICAgIGZvY3VzT3BlbmVyKGxhc3RGb2N1c2VkOiBTb3VyY2VFbGVtZW50IHwgbnVsbCk6IHZvaWQ7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUZvY3VzVHJhcFJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT4ge1xuICAgIGZvY3VzVHJhcFJldHVybjogeyBwcm9wc1Vuc3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB9XG59XG5cbi8vY29uc3QgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvID0gbmV3IE1hcDxFbGVtZW50IHwgbnVsbCwgKE5vZGUgJiBIVE1MT3JTVkdFbGVtZW50KT4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvY3VzVHJhcDxTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB8IG51bGwsIFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBmb2N1c1RyYXBQYXJhbWV0ZXJzOiB7IG9ubHlNb3ZlRm9jdXMsIHRyYXBBY3RpdmUsIGZvY3VzUG9wdXA6IGZvY3VzU2VsZlVuc3RhYmxlLCBmb2N1c09wZW5lcjogZm9jdXNPcGVuZXJVbnN0YWJsZSB9LFxuICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7IG9uRWxlbWVudENoYW5nZSwgLi4ucmVmRWxlbWVudFBhcmFtZXRlcnMgfVxufTogVXNlRm9jdXNUcmFwUGFyYW1ldGVyczxTb3VyY2VFbGVtZW50LCBQb3B1cEVsZW1lbnQ+KTogVXNlRm9jdXNUcmFwUmV0dXJuVHlwZTxQb3B1cEVsZW1lbnQ+IHtcblxuICAgIHR5cGUgRSA9IFBvcHVwRWxlbWVudDtcblxuICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKGZvY3VzU2VsZlVuc3RhYmxlKTtcbiAgICBjb25zdCBmb2N1c09wZW5lciA9IHVzZVN0YWJsZUNhbGxiYWNrKGZvY3VzT3BlbmVyVW5zdGFibGUpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHRyYXBBY3RpdmUpIHtcbiAgICAgICAgICAgIGxldCB0b3AgPSBnZXRUb3AoKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RGb2N1c2VkSW5UaGlzQ29tcG9uZW50ID0gZ2V0TGFzdEFjdGl2ZVdoZW5PcGVuKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChmYWxzZSAmJiBsYXN0Rm9jdXNlZEluVGhpc0NvbXBvbmVudCAmJiBsYXN0Rm9jdXNlZEluVGhpc0NvbXBvbmVudD8uaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBmb2N1c1NlbGYobGFzdEZvY3VzZWRJblRoaXNDb21wb25lbnQgYXMgYW55IGFzIFBvcHVwRWxlbWVudCwgKCkgPT4gbGFzdEZvY3VzZWRJblRoaXNDb21wb25lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9wID8/PSByZWZFbGVtZW50UmV0dXJuLmdldEVsZW1lbnQoKSBhcyB1bmtub3duIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCEhdG9wKTtcbiAgICAgICAgICAgICAgICBpZiAodG9wKVxuICAgICAgICAgICAgICAgICAgICBmb2N1c1NlbGYodG9wIGFzIGFueSBhcyBQb3B1cEVsZW1lbnQsICgpID0+IGZpbmRGaXJzdEZvY3VzYWJsZSh0b3AhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0QWN0aXZlID0gZ2V0TGFzdEFjdGl2ZVdoZW5DbG9zZWQoKTtcbiAgICAgICAgICAgIGlmIChsYXN0QWN0aXZlKVxuICAgICAgICAgICAgICAgIGZvY3VzT3BlbmVyKGxhc3RBY3RpdmUgYXMgYW55IGFzIFNvdXJjZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfSwgW3RyYXBBY3RpdmVdKVxuXG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuIH0gPSB1c2VSZWZFbGVtZW50PEU+KHtcbiAgICAgICAgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHsgb25FbGVtZW50Q2hhbmdlLCAuLi5yZWZFbGVtZW50UGFyYW1ldGVycyB9XG4gICAgfSlcbiAgICBjb25zdCB7IGdldEVsZW1lbnQgfSA9IHJlZkVsZW1lbnRSZXR1cm47XG5cbiAgICBjb25zdCB7IGdldFRvcCwgZ2V0TGFzdEFjdGl2ZVdoZW5DbG9zZWQsIGdldExhc3RBY3RpdmVXaGVuT3BlbiB9ID0gdXNlQmxvY2tpbmdFbGVtZW50KHRyYXBBY3RpdmUgJiYgIW9ubHlNb3ZlRm9jdXMsIGdldEVsZW1lbnQpO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICBmb2N1c1RyYXBSZXR1cm46IHsgcHJvcHNVbnN0YWJsZTogeyBcImFyaWEtbW9kYWxcIjogdHJhcEFjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gfVxuICAgIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgY29udGFpbmVkIHdpdGhpbiB0aGUgZ2l2ZW4gbm9kZSwgb3IgbnVsbCBpZiBub25lIGFyZSBmb3VuZC5cbiAqIEBwYXJhbSBlbGVtZW50IFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRmlyc3RGb2N1c2FibGUoZWxlbWVudDogTm9kZSkge1xuICAgIGNvbnNvbGUuYXNzZXJ0KCEhZWxlbWVudCk7XG4gICAgZWxlbWVudCA/Pz0gZG9jdW1lbnQuYm9keTtcbiAgICBjb25zdCB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgeyBhY2NlcHROb2RlOiAobm9kZSkgPT4gKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGlzRm9jdXNhYmxlKG5vZGUpID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUIDogTm9kZUZpbHRlci5GSUxURVJfU0tJUCkgfSlcbiAgICBjb25zdCBmaXJzdEZvY3VzYWJsZSA9IHRyZWVXYWxrZXIuZmlyc3RDaGlsZCgpIGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCkgfCBudWxsO1xuICAgIHJldHVybiBmaXJzdEZvY3VzYWJsZTtcbn1cblxuIiwiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUZXh0Q29udGVudFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICByZWZFbGVtZW50UmV0dXJuOiBQaWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+W1wicmVmRWxlbWVudFJldHVyblwiXSwgXCJnZXRFbGVtZW50XCI+O1xuICAgIHRleHRDb250ZW50UGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhpcyBjb21wb25lbnQuIEJ5IGRlZmF1bHQsIGBlID0+IGUudGV4dENvbnRlbnRgIGlzIHByb2JhYmx5IHdoYXQgeW91IHdhbnQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRUZXh0KGU6IEUgfCBudWxsKTogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgb25UZXh0Q29udGVudENoYW5nZTogT25QYXNzaXZlU3RhdGVDaGFuZ2U8c3RyaW5nIHwgbnVsbCwgbmV2ZXI+O1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRleHRDb250ZW50PEUgZXh0ZW5kcyBFbGVtZW50Pih7IHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudCB9LCB0ZXh0Q29udGVudFBhcmFtZXRlcnM6IHsgZ2V0VGV4dCwgb25UZXh0Q29udGVudENoYW5nZSB9IH06IFVzZVRleHRDb250ZW50UGFyYW1ldGVyczxFPikge1xuICAgIGNvbnN0IFtnZXRUZXh0Q29udGVudCwgc2V0VGV4dENvbnRlbnRdID0gdXNlUGFzc2l2ZVN0YXRlPHN0cmluZyB8IG51bGwsIG5ldmVyPihvblRleHRDb250ZW50Q2hhbmdlLCByZXR1cm5OdWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBnZXRUZXh0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0VGV4dENvbnRlbnQodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgdGV4dENvbnRlbnRSZXR1cm46IHsgZ2V0VGV4dENvbnRlbnQgfSB9XG59XG4iLCJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlU3RhdGUgYXMgdXNlU3RhdGVQIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG4vKipcbiAqIFNsaWdodGx5IGVuaGFuY2VkIHZlcnNpb24gb2YgYHVzZVN0YXRlYCB0aGF0IGluY2x1ZGVzIGEgZ2V0dGVyIHRoYXQgcmVtYWlucyBjb25zdGFudFxuICogKGkuZS4geW91IGNhbiB1c2UgaXQgaW4gYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpdCBiZWluZyBhIGRlcGVuZGVuY3kpLlxuICogXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZTxUPihpbml0aWFsU3RhdGU6IFQgfCAoKCkgPT4gVCkpOiByZWFkb25seSBbdmFsdWU6IFQsIHNldFZhbHVlOiBTdGF0ZVVwZGF0ZXI8VD4sIGdldFZhbHVlOiAoKSA9PiBUXSB7XG5cbiAgICAvLyBXZSBrZWVwIGJvdGgsIGJ1dCBvdmVycnJpZGUgdGhlIGBzZXRTdGF0ZWAgZnVuY3Rpb25hbGl0eVxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVQXSA9IHVzZVN0YXRlUChpbml0aWFsU3RhdGUpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihzdGF0ZSk7XG5cbiAgICAvLyBIaWphY2sgdGhlIG5vcm1hbCBzZXR0ZXIgZnVuY3Rpb24gXG4gICAgLy8gdG8gYWxzbyBzZXQgb3VyIHJlZiB0byB0aGUgbmV3IHZhbHVlXG4gICAgY29uc3Qgc2V0U3RhdGUgPSB1c2VDYWxsYmFjazxTdGF0ZVVwZGF0ZXI8VD4+KHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHZhbHVlIGFzICgoX3ByZXZWYWx1ZTogVCkgPT4gVCk7XG4gICAgICAgICAgICBzZXRTdGF0ZVAocHJldlZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBjYWxsYmFjayhwcmV2VmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgICAgICBzZXRTdGF0ZVAodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiB7IHJldHVybiByZWYuY3VycmVudDsgfTtcblxuXG4gICAgY29uc29sZS5hc3NlcnQocmVmLmN1cnJlbnQgPT09IHN0YXRlIHx8ICh0eXBlb2Ygc3RhdGUgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4oc3RhdGUpKSk7XG4gICAgcmV0dXJuIFtzdGF0ZSwgc2V0U3RhdGUsIGdldFN0YXRlXSBhcyBjb25zdDtcbn0iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi4vZG9tLWhlbHBlcnMvdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VUZXh0Q29udGVudCwgVXNlVGV4dENvbnRlbnRQYXJhbWV0ZXJzIH0gZnJvbSBcIi4uL2RvbS1oZWxwZXJzL3VzZS10ZXh0LWNvbnRlbnRcIjtcbmltcG9ydCB7IGFzc2VydEVtcHR5T2JqZWN0IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YWJsZU9iamVjdCB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YXRlXCI7XG5pbXBvcnQgeyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycywgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJvdmluZy10YWJpbmRleFwiO1xuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wczxFIGV4dGVuZHMgRWxlbWVudD4ocjogVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPEU+LCAuLi5vdGhlclByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltdKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSB7XG4gICAgcmV0dXJuIFtyLmxpbmVhck5hdmlnYXRpb25SZXR1cm4ucHJvcHNTdGFibGUsIC4uLm90aGVyUHJvcHNdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxFIGV4dGVuZHMgRWxlbWVudD4ocjogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPEU+LCAuLi5vdGhlclByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltdKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSB7XG4gICAgcmV0dXJuIFtyLnR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4ucHJvcHNTdGFibGUsIC4uLm90aGVyUHJvcHNdO1xufSovXG5cbi8qZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ29udGV4dDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD5bXCJ0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzXCJdO1xufSovXG5cbmV4cG9ydCBpbnRlcmZhY2UgTGluZWFyTmF2aWdhdGlvblJlc3VsdCB7XG4gICAgdmFsdWU6IG51bWJlciB8IG51bGw7XG4gICAgc3RhdHVzOiBcIm5vcm1hbFwiIHwgXCJwYXN0LXN0YXJ0XCIgfCBcInBhc3QtZW5kXCJcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuOiB7XG4gICAgICAgIHByb3BzU3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcbn1cblxuLyoqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gd2l0aCBubyBzb3J0aW5nICovXG4vL2V4cG9ydCBmdW5jdGlvbiBuYXZpZ2F0ZVJlbGF0aXZlKG9yaWdpbmFsOiBudW1iZXIsIG9mZnNldDogbnVtYmVyKTogbnVtYmVyIHwgbnVsbCB7IHJldHVybiBvcmlnaW5hbCArIG9mZnNldDsgfVxuXG4vKiogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aXRoIG5vIHNvcnRpbmcgKi9cbi8vZXhwb3J0IGZ1bmN0aW9uIG5hdmlnYXRlQWJzb2x1dGUoaW5kZXg6IG51bWJlcik6IG51bWJlciB8IG51bGwgeyByZXR1cm4gaW5kZXg7IH1cblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHBhcmVudCBgdXNlTGluZWFyTmF2aWdhdGlvbmAgKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8X1BhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuXG4gICAgcm92aW5nVGFiSW5kZXhSZXR1cm46IFBpY2s8VXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlPENoaWxkRWxlbWVudD5bXCJyb3ZpbmdUYWJJbmRleFJldHVyblwiXSwgXCJnZXRUYWJiYWJsZUluZGV4XCIgfCBcInNldFRhYmJhYmxlSW5kZXhcIj5cbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdXN0IHJldHVybiB0cnVlIGlmIHRoZSBnaXZlbiBjaGlsZCBjYW4gYmUgbmF2aWdhdGVkIHRvLlxuICAgICAgICAgKiBcbiAgICAgICAgICogR2VuZXJhbGx5IGNvcnJlc3BvbmRzIHRvIGEgYGhpZGRlbmAgb3IgYGRpc2FibGVkYCBwcm9wLlxuICAgICAgICAgKiBAcGFyYW0gaSBcbiAgICAgICAgICovXG4gICAgICAgIGlzVmFsaWQoaTogbnVtYmVyKTogYm9vbGVhbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbHMgaG93IG1hbnkgZWxlbWVudHMgYXJlIHNraXBwZWQgb3ZlciB3aGVuIHBhZ2UgdXAvZG93biBhcmUgcHJlc3NlZC5cbiAgICAgICAgICogXG4gICAgICAgICAqICogV2hlbiAwOiBQYWdlIFVwL0Rvd24gYXJlIGRpc2FibGVkXG4gICAgICAgICAqICogV2hlbiA+PSAxOiBQYWdlIFVwL0Rvd24gbW92ZXMgdGhhdCBudW1iZXIgb2YgZWxlbWVudHMgdXAgb3IgZG93blxuICAgICAgICAgKiAqIFdoZW4gMCA8IHggPCAxLCBQYWdlIFVwL0Rvd24gbW92ZXMgYnkgdGhhdCBwZXJjZW50YWdlIG9mIGFsbCBlbGVtZW50cywgb3Igb2YgMTAwIGVsZW1lbnRzLCB3aGljaGV2ZXIgaXMgaGlnaGVyLiBJbiBvdGhlciB3b3JkcywgMC4xIGp1bXBzIGJ5IDEwIGVsZW1lbnRzIHdoZW4gdGhlcmUgYXJlIGZld2VyIHRoZW4gMTAwIGVsZW1lbnRzLCBhbmQgMjAgZWxlbWVudHMgd2hlbiB0aGVyZSBhcmUgMjAwIGVsZW1lbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplOiBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoYXQgaGFwcGVucyB3aGVuIGB1cGAgaXMgcHJlc3NlZCBvbiB0aGUgZmlyc3QgdmFsaWQgY2hpbGQ/XG4gICAgICAgICAqL1xuICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydDogXCJ3cmFwXCIgfCAoKCkgPT4gdm9pZCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGF0IGhhcHBlbnMgd2hlbiBgZG93bmAgaXMgcHJlc3NlZCBvbiB0aGUgbGFzdCB2YWxpZCBjaGlsZD9cbiAgICAgICAgICovXG4gICAgICAgIG5hdmlnYXRlUGFzdEVuZDogXCJ3cmFwXCIgfCAoKCkgPT4gdm9pZCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR1cm4gYSBzb3J0ZWQgYGluZGV4YCBpbnRvIGl0cyBvcmlnaW5hbCwgdW5zb3J0ZWQgYGluZGV4YC4gVXNlIGBpZGVudGl0eWAgaWYgeW91IGRvbid0IGNhcmUuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGlzIGlzIHdoYXQgYWxsb3dzIG91ciBsaW5lYXIga2V5Ym9hcmQgbmF2aWdhdGlvbiB0byBzdGlsbCB3b3JrIGlmIHRoZSBjaGlsZHJlbiBhcmUgcmUtb3JkZXJlZFxuICAgICAgICAgKiAoaS5lLiBob3cgd2hlbiByZXZlcnNlLXNvcnRlZCwgcHJlc3NpbmcgYGRvd25gIG1vdmVzIGZyb20gaXRlbSAjOSB0byBpdGVtICM4KS5cbiAgICAgICAgICovXG4gICAgICAgIGluZGV4TWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHVybiBhbiB1bnNvcnRlZCBgaW5kZXhgIGludG8gaXRzIHZpc3VhbCBkaXNwbGF5IGBpbmRleGAuIFVzZSBgaWRlbnRpdHlgIGlmIHlvdSBkb24ndCBjYXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcblxuICAgICAgICBnZXRIaWdoZXN0SW5kZXgoKTogbnVtYmVyOyAgLy8gWzAsIG5dLCBub3QgWzAsIG4pXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRyb2xzIHdoaWNoIGFycm93IGtleXMgYXJlIHVzZWQgdG8gbmF2aWdhdGUgdGhyb3VnaCB0aGUgY29tcG9uZW50LlxuICAgICAgICAgKiBOb3QgcmVsYXRpdmUgdG8gdGhlIHdyaXRpbmcgbW9kZSAtLSB0aGVzZSBhcmUgdGhlIGxpdGVyYWwga2V5cyB0aGF0IG5lZWQgdG8gYmUgcHJlc3NlZC5cbiAgICAgICAgICogXG4gICAgICAgICAqIFVzZSBcImVpdGhlclwiIHRvIGFsbG93IG5hdmlnYXRpb24gaW4gZWl0aGVyIGRpcmVjdGlvbi5cbiAgICAgICAgICogXG4gICAgICAgICAqIFVzZSBcIm5vbmVcIiB0byBkaXNhbGxvdyBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgaW4gYW55IGRpcmVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIG5hdmlnYXRpb25EaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiIHwgXCJlaXRoZXJcIiB8IFwibm9uZVwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIHdpbGwgYmUgXG4gICAgICAgICAqIGRpc2FibGVkLCBidXQgbmF2aWdhdGlvbiB3aXRoIHRoZSBob21lICYgZW5kIGtleXMgd2lsbFxuICAgICAgICAgKiBiZSB1bmFmZmVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZUFycm93S2V5czogYm9vbGVhbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIG5hdmlnYXRpb24gd2l0aCB0aGUgaG9tZSAmIGVuZCBrZXlzIHdpbGxcbiAgICAgICAgICogYmUgZGlzYWJsZWQsIGJ1dCBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgd2lsbCBiZVxuICAgICAgICAgKiB1bmFmZmVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzOiBib29sZWFuO1xuICAgIH1cbn1cblxuXG4vKiogQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgY2hpbGQgJ3VzZUxpbmVhck5hdmlnYXRpb25DaGlsZGAgKi9cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRJbmZvIHsgfVxuXG4vKipcbiAqIFdoZW4gdXNlZCBpbiB0YW5kZW0gd2l0aCBgdXNlUm92aW5nVGFiSW5kZXhgLCBhbGxvd3MgY29udHJvbCBvZlxuICogdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdGhlIGFycm93IGtleXMuXG4gKiBcbiAqIEBzZWUgdXNlTGlzdE5hdmlnYXRpb24sIHdoaWNoIHBhY2thZ2VzIGV2ZXJ5dGhpbmcgdXAgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaW5lYXJOYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXG59OiBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50Pik6IFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XG4gICAgdHlwZSBSID0gRXZlbnQ7Ly9oLkpTWC5UYXJnZXRlZEV2ZW50PFBhcmVudE9yQ2hpbGRFbGVtZW50PjtcbiAgICBjb25zdCB7IGdldEhpZ2hlc3RJbmRleCwgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgaXNWYWxpZCwgbmF2aWdhdGVQYXN0RW5kLCBuYXZpZ2F0ZVBhc3RTdGFydCB9ID0gbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM7XG4gICAgY29uc3QgeyBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4IH0gPSByb3ZpbmdUYWJJbmRleFJldHVybjtcblxuICAgIGNvbnN0IG5hdmlnYXRlQWJzb2x1dGUgPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyLCBlOiBSLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGluZGV4RGVtYW5nbGVyKGkpO1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSB0cnlOYXZpZ2F0ZVRvSW5kZXgoeyBpc1ZhbGlkLCBoaWdoZXN0Q2hpbGRJbmRleDogZ2V0SGlnaGVzdEluZGV4KCksIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIHNlYXJjaERpcmVjdGlvbjogLTEsIHRhcmdldCB9KTtcbiAgICAgICAgc2V0VGFiYmFibGVJbmRleCh2YWx1ZSwgZSwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9GaXJzdCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBSLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7IG5hdmlnYXRlQWJzb2x1dGUoMCwgZSwgZnJvbVVzZXJJbnRlcmFjdGlvbik7IH0pO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9MYXN0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IFIsIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHsgbmF2aWdhdGVBYnNvbHV0ZShnZXRIaWdoZXN0SW5kZXgoKSwgZSwgZnJvbVVzZXJJbnRlcmFjdGlvbik7IH0pO1xuICAgIGNvbnN0IG5hdmlnYXRlUmVsYXRpdmUyID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IFIsIG9mZnNldDogbnVtYmVyLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuLCBtb2RlOiBcInBhZ2VcIiB8IFwic2luZ2xlXCIpID0+IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSAoZ2V0VGFiYmFibGVJbmRleCgpID8/IDApO1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgdmFsdWUgfSA9IHRyeU5hdmlnYXRlVG9JbmRleCh7IGlzVmFsaWQsIGhpZ2hlc3RDaGlsZEluZGV4OiBnZXRIaWdoZXN0SW5kZXgoKSwgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgc2VhcmNoRGlyZWN0aW9uOiAoTWF0aC5zaWduKG9mZnNldCkgfHwgMSkgYXMgMSB8IC0xLCB0YXJnZXQ6IGluZGV4RGVtYW5nbGVyKGluZGV4TWFuZ2xlcihvcmlnaW5hbCkgKyBvZmZzZXQpIH0pO1xuICAgICAgICBpZiAoc3RhdHVzID09IFwicGFzdC1lbmRcIikge1xuICAgICAgICAgICAgaWYgKG5hdmlnYXRlUGFzdEVuZCA9PSBcIndyYXBcIikge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlID09IFwic2luZ2xlXCIpXG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdChlLCBmcm9tVXNlckludGVyYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zdGFudC1jb25kaXRpb24gKi9cbiAgICAgICAgICAgICAgICAgICAgLy8gVW5jb21tZW50IHRvIGFsbG93IHBhZ2UgdXAvZG93biB0byB3cmFwIGFmdGVyIGhpdHRpbmcgdGhlIHRvcC9ib3R0b20gb25jZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gSXQgd29ya3MgZmluZSwgdGhlIHByb2JsZW0gaXNuJ3QgdGhhdCAtLSB0aGUgcHJvYmxlbSBpcyBpdCBqdXN0IGZlZWxzIHdyb25nLiBcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFnZSBVcC9Eb3duIGRvbid0IGZlZWwgbGlrZSB0aGV5IHNob3VsZCB3cmFwLCBldmVuIGlmIG5vcm1hbGx5IHJlcXVlc3RlZC4gXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoYXQncyB0aGUgYXJyb3cga2V5cycgZG9tYWluLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZmFsc2UgJiYgKHZhbHVlID09IGdldFRhYmJhYmxlSW5kZXgoKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvRmlyc3QoZSwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9MYXN0KGUsIGZyb21Vc2VySW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cyA9PSBcInBhc3Qtc3RhcnRcIikge1xuICAgICAgICAgICAgaWYgKG5hdmlnYXRlUGFzdFN0YXJ0ID09IFwid3JhcFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGUgPT0gXCJzaW5nbGVcIikge1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdChlLCBmcm9tVXNlckludGVyYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnN0YW50LWNvbmRpdGlvbiAqL1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgYWJvdmUuIEl0IHdvcmtzIGZpbmUgYnV0IGp1c3QgZmVlbHMgd3JvbmcgdG8gd3JhcCBvbiBQYWdlIFVwL0Rvd24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSAmJiB2YWx1ZSA9PSBnZXRUYWJiYWJsZUluZGV4KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdChlLCBmcm9tVXNlckludGVyYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0ZpcnN0KGUsIGZyb21Vc2VySW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlUGFzdFN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KHZhbHVlLCBlLCBmcm9tVXNlckludGVyYWN0aW9uKTtcblxuICAgICAgICB9XG4gICAgfSlcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTmV4dCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBSLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7XG4gICAgICAgIG5hdmlnYXRlUmVsYXRpdmUyKGUsIDEsIGZyb21Vc2VySW50ZXJhY3Rpb24sIFwic2luZ2xlXCIpO1xuICAgICAgICAvLyBzZXRUYWJiYWJsZUluZGV4KG5hdmlnYXRlUmVsYXRpdmUoKGdldFRhYmJhYmxlSW5kZXgoKSA/PyAwKSwgKzEpLCBmcm9tVXNlckludGVyYWN0aW9uKVxuICAgIH0pO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9QcmV2ID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IFIsIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHtcbiAgICAgICAgbmF2aWdhdGVSZWxhdGl2ZTIoZSwgLTEsIGZyb21Vc2VySW50ZXJhY3Rpb24sIFwic2luZ2xlXCIpO1xuICAgICAgICAvLyBzZXRUYWJiYWJsZUluZGV4KG5hdmlnYXRlUmVsYXRpdmUoKGdldFRhYmJhYmxlSW5kZXgoKSA/PyAwKSwgKzEpLCBmcm9tVXNlckludGVyYWN0aW9uKVxuICAgIH0pO1xuICAgIGNvbnN0IGdldERpc2FibGVBcnJvd0tleXMgPSB1c2VTdGFibGVHZXR0ZXIobGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMuZGlzYWJsZUFycm93S2V5cyk7XG4gICAgY29uc3QgZ2V0RGlzYWJsZUhvbWVFbmRLZXlzID0gdXNlU3RhYmxlR2V0dGVyKGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLmRpc2FibGVIb21lRW5kS2V5cyk7XG4gICAgY29uc3QgZ2V0TmF2aWdhdGlvbkRpcmVjdGlvbiA9IHVzZVN0YWJsZUdldHRlcihsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycy5uYXZpZ2F0aW9uRGlyZWN0aW9uKTtcbiAgICBjb25zdCBnZXRQYWdlTmF2aWdhdGlvblNpemUgPSB1c2VTdGFibGVHZXR0ZXIobGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMucGFnZU5hdmlnYXRpb25TaXplKTtcblxuXG4gICAgY29uc3Qgc3RhYmxlUHJvcHMgPSB1c2VSZWY8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+Pih7XG4gICAgICAgIG9uS2V5RG93bjogKGU6IGguSlNYLlRhcmdldGVkS2V5Ym9hcmRFdmVudDxQYXJlbnRPckNoaWxkRWxlbWVudD4pID0+IHtcbiAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxuICAgICAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAvL2NvbnN0IGluZm8gPSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICAgICAgY29uc3QgbmF2aWdhdGlvbkRpcmVjdGlvbiA9IGdldE5hdmlnYXRpb25EaXJlY3Rpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc2FibGVBcnJvd0tleXMgPSBnZXREaXNhYmxlQXJyb3dLZXlzKCk7XG4gICAgICAgICAgICBjb25zdCBkaXNhYmxlSG9tZUVuZEtleXMgPSBnZXREaXNhYmxlSG9tZUVuZEtleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VOYXZpZ2F0aW9uU2l6ZSA9IGdldFBhZ2VOYXZpZ2F0aW9uU2l6ZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBhbGxvd3NWZXJ0aWNhbE5hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcInZlcnRpY2FsXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93c0hvcml6b250YWxOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcblxuICAgICAgICAgICAgbGV0IHRydWVQYWdlTmF2aWdhdGlvblNpemUgPSBwYWdlTmF2aWdhdGlvblNpemU7XG4gICAgICAgICAgICBpZiAodHJ1ZVBhZ2VOYXZpZ2F0aW9uU2l6ZSA8IDEpIHtcbiAgICAgICAgICAgICAgICB0cnVlUGFnZU5hdmlnYXRpb25TaXplID0gTWF0aC5yb3VuZChwYWdlTmF2aWdhdGlvblNpemUgKiBNYXRoLm1heCgxMDAsIGdldEhpZ2hlc3RJbmRleCgpICsgMSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjoge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IHByb3BOYW1lID0gKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IFwiYmxvY2tEaXJlY3Rpb25cIiA6IFwiaW5saW5lRGlyZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIGFsbG93c1ZlcnRpY2FsTmF2aWdhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldihlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIGFsbG93c1ZlcnRpY2FsTmF2aWdhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dChlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgYWxsb3dzSG9yaXpvbnRhbE5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgYWxsb3dzSG9yaXpvbnRhbE5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiUGFnZVVwXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRydWVQYWdlTmF2aWdhdGlvblNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVJlbGF0aXZlMihlLCAtdHJ1ZVBhZ2VOYXZpZ2F0aW9uU2l6ZSwgdHJ1ZSwgXCJwYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIlBhZ2VEb3duXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRydWVQYWdlTmF2aWdhdGlvblNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVJlbGF0aXZlMihlLCB0cnVlUGFnZU5hdmlnYXRpb25TaXplLCB0cnVlLCBcInBhZ2VcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVIb21lRW5kS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0ZpcnN0KGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJFbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlSG9tZUVuZEtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9MYXN0KGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm46IHtcbiAgICAgICAgICAgIHByb3BzU3RhYmxlOiBzdGFibGVQcm9wcy5jdXJyZW50XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBUcnlOYXZpZ2F0ZVRvSW5kZXhQYXJhbWV0ZXJzIHtcbiAgICAvL2NoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCB1bmtub3duLCBLPjtcbiAgICBoaWdoZXN0Q2hpbGRJbmRleDogbnVtYmVyOyAvLyBbMCwgbl0sIG5vdCBbMCwgbilcbiAgICBpc1ZhbGlkKGluZGV4OiBudW1iZXIpOiBib29sZWFuO1xuXG4gICAgLy9kZWZhdWx0OiBudW1iZXI7XG4gICAgdGFyZ2V0OiBudW1iZXI7XG4gICAgc2VhcmNoRGlyZWN0aW9uOiAxIHwgLTE7XG4gICAgaW5kZXhNYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG4gICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJ5TmF2aWdhdGVUb0luZGV4KHsgaXNWYWxpZCwgaGlnaGVzdENoaWxkSW5kZXg6IHVwcGVyLCBzZWFyY2hEaXJlY3Rpb24sIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIHRhcmdldCB9OiBUcnlOYXZpZ2F0ZVRvSW5kZXhQYXJhbWV0ZXJzKTogTGluZWFyTmF2aWdhdGlvblJlc3VsdCB7XG4gICAgLy9jb25zdCB1cHBlciA9IGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpO1xuICAgIGNvbnN0IGxvd2VyID0gMDtcblxuICAgIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgIHdoaWxlICh0YXJnZXQgPj0gbG93ZXIgJiYgIWlzVmFsaWQodGFyZ2V0KSlcbiAgICAgICAgICAgIHRhcmdldCA9IGluZGV4RGVtYW5nbGVyKGluZGV4TWFuZ2xlcih0YXJnZXQpIC0gMSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldCA8IGxvd2VyID8geyB2YWx1ZTogaW5kZXhEZW1hbmdsZXIobG93ZXIpLCBzdGF0dXM6IFwicGFzdC1zdGFydFwiIH0gOiB7IHZhbHVlOiB0YXJnZXQsIHN0YXR1czogXCJub3JtYWxcIiB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgd2hpbGUgKHRhcmdldCA8PSB1cHBlciAmJiAhaXNWYWxpZCh0YXJnZXQpKVxuICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXhEZW1hbmdsZXIoaW5kZXhNYW5nbGVyKHRhcmdldCkgKyAxKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0ID4gdXBwZXIgPyB7IHZhbHVlOiBpbmRleERlbWFuZ2xlcih1cHBlciksIHN0YXR1czogXCJwYXN0LWVuZFwiIH0gOiB7IHZhbHVlOiB0YXJnZXQsIHN0YXR1czogXCJub3JtYWxcIiB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGxvd2VyLCBzdGF0dXM6IFwibm9ybWFsXCIgfTtcbiAgICB9XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm46IHtcbiAgICAgICAgZ2V0Q3VycmVudFR5cGVhaGVhZCgpOiBzdHJpbmcgfCBudWxsO1xuICAgICAgICBpbnZhbGlkVHlwZWFoZWFkOiBib29sZWFuIHwgbnVsbDtcbiAgICAgICAgcHJvcHNTdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PjtcbiAgICB9XG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dDogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxQYXJlbnRPckNoaWxkRWxlbWVudD5bXCJ0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0XCJdO1xufVxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFRhYmJhYmxlQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogTXVzdCByZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gY2hpbGQgY2FuIGJlIG5hdmlnYXRlZCB0by5cbiAgICAgICAgICogXG4gICAgICAgICAqIEdlbmVyYWxseSBjb3JyZXNwb25kcyB0byBhIGBoaWRkZW5gIG9yIGBkaXNhYmxlZGAgcHJvcC5cbiAgICAgICAgICogQHBhcmFtIGkgXG4gICAgICAgICAqL1xuICAgICAgICBpc1ZhbGlkKGk6IG51bWJlcik6IGJvb2xlYW47XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBjb2xsYXRvciB0byB1c2Ugd2hlbiBjb21wYXJpbmcuIElmIG5vdCBwcm92aWRlZCwgc2ltcGx5IHVzZXMgYGxvY2FsZUNvbXBhcmVgIGFmdGVyIHRyYW5zZm9ybWluZyBlYWNoIHRvIGxvd2VyY2FzZSwgd2hpY2ggd2lsbCwgYXQgYmVzdCwgd29yayBva2F5IGluIEVuZ2xpc2guXG4gICAgICAgICAqL1xuICAgICAgICBjb2xsYXRvcjogbnVsbCB8IEludGwuQ29sbGF0b3I7XG5cbiAgICAgICAgbm9UeXBlYWhlYWQ6IGJvb2xlYW47XG5cbiAgICAgICAgdHlwZWFoZWFkVGltZW91dDogbnVtYmVyO1xuICAgIH07XG5cbiAgICByb3ZpbmdUYWJJbmRleFJldHVybjogUGljazxVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGU8VGFiYmFibGVDaGlsZEVsZW1lbnQ+W1wicm92aW5nVGFiSW5kZXhSZXR1cm5cIl0sIFwiZ2V0VGFiYmFibGVJbmRleFwiIHwgXCJzZXRUYWJiYWJsZUluZGV4XCI+XG59XG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjaGlsZCAndXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkYCAqL1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogUGljazxVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1wibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiXSwgXCJpbmRleFwiPjtcblxuICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogUGljazxVc2VUZXh0Q29udGVudFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcInRleHRDb250ZW50UGFyYW1ldGVyc1wiXSwgXCJnZXRUZXh0XCI+O1xuXG4gICAgLy90eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7XG5cbiAgICAvL2dldFRleHQoZWxlbWVudDogRWxlbWVudCB8IG51bGwpOiBzdHJpbmc7XG5cbiAgICAvL2hpZGRlbjogYm9vbGVhbjtcbiAgICAvL31cblxuICAgIHJlZkVsZW1lbnRSZXR1cm46IFBpY2s8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8Q2hpbGRFbGVtZW50PltcInJlZkVsZW1lbnRSZXR1cm5cIl0sIFwiZ2V0RWxlbWVudFwiPjtcblxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQ6IHtcblxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvOiBBcnJheTxUeXBlYWhlYWRJbmZvPjtcbiAgICAgICAgICAgIGluc2VydGluZ0NvbXBhcmF0b3I6IChsaHM6IHN0cmluZyB8IG51bGwsIHJoczogVHlwZWFoZWFkSW5mbykgPT4gbnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGUge1xuICAgIHRleHRDb250ZW50UmV0dXJuOiB7IGdldFRleHRDb250ZW50KCk6IHN0cmluZyB8IG51bGwgfVxufVxuXG5pbnRlcmZhY2UgVHlwZWFoZWFkSW5mbyB7IHRleHQ6IHN0cmluZyB8IG51bGw7IHVuc29ydGVkSW5kZXg6IG51bWJlcjsgfVxuXG4vKiogVHlwZSBvZiB0aGUgY2hpbGQncyBzdWItaG9vayAqL1xuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PikgPT4gVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTtcblxuXG4vKipcbiAqIEFsbG93cyBmb3IgdGhlIHNlbGVjdGlvbiBvZiBhIG1hbmFnZWQgY2hpbGQgYnkgdHlwaW5nIHRoZSBnaXZlbiB0ZXh0IGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAqIFxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVR5cGVhaGVhZE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgY29sbGF0b3IsIHR5cGVhaGVhZFRpbWVvdXQsIG5vVHlwZWFoZWFkLCBpc1ZhbGlkLCAuLi5fdm9pZDMgfSxcbiAgICByb3ZpbmdUYWJJbmRleFJldHVybjogeyBnZXRUYWJiYWJsZUluZGV4OiBnZXRJbmRleCwgc2V0VGFiYmFibGVJbmRleDogc2V0SW5kZXgsIC4uLl92b2lkMSB9LFxuICAgIC4uLl92b2lkMlxufTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50Pik6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XG5cbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDEpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMik7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QoX3ZvaWQzKTtcblxuICAgIC8vIEZvciB0eXBlYWhlYWQsIGtlZXAgdHJhY2sgb2Ygd2hhdCBvdXIgY3VycmVudCBcInNlYXJjaFwiIHN0cmluZyBpcyAoaWYgd2UgaGF2ZSBvbmUpXG4gICAgLy8gYW5kIGFsc28gY2xlYXIgaXQgZXZlcnkgMTAwMCBtcyBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IGNoYW5nZWQuXG4gICAgLy8gTmV4dCwga2VlcCBhIG1hcHBpbmcgb2YgdHlwZWFoZWFkIHZhbHVlcyB0byBpbmRpY2VzIGZvciBmYXN0ZXIgc2VhcmNoaW5nLlxuICAgIC8vIEFuZCwgZm9yIHRoZSB1c2VyJ3Mgc2FrZSwgbGV0IHRoZW0ga25vdyB3aGVuIHRoZWlyIHR5cGVhaGVhZCBjYW4ndCBtYXRjaCBhbnl0aGluZyBhbnltb3JlXG4gICAgY29uc3QgW2dldEN1cnJlbnRUeXBlYWhlYWQsIHNldEN1cnJlbnRUeXBlYWhlYWRdID0gdXNlUGFzc2l2ZVN0YXRlPHN0cmluZyB8IG51bGwsIEV2ZW50Pih1c2VTdGFibGVDYWxsYmFjaygoY3VycmVudFR5cGVhaGVhZCwgcHJldiwgcmVhc29uKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4geyBzZXRDdXJyZW50VHlwZWFoZWFkKG51bGwsIHVuZGVmaW5lZCEpOyBzZXRJbnZhbGlkVHlwZWFoZWFkKG51bGwpOyB9LCB0eXBlYWhlYWRUaW1lb3V0ID8/IDEwMDApO1xuICAgICAgICB1cGRhdGVCYXNlZE9uVHlwZWFoZWFkQ2hhbmdlKGN1cnJlbnRUeXBlYWhlYWQsIHJlYXNvbiEpO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgfSkpO1xuICAgIC8vdXNlVGltZW91dCh7IHRpbWVvdXQ6IHR5cGVhaGVhZFRpbWVvdXQgPz8gMTAwMCwgY2FsbGJhY2s6ICgpID0+IHsgc2V0Q3VycmVudFR5cGVhaGVhZChudWxsKTsgc2V0SW52YWxpZFR5cGVhaGVhZChudWxsKTsgfSwgdHJpZ2dlckluZGV4OiBjdXJyZW50VHlwZWFoZWFkIH0pO1xuICAgIGNvbnN0IHNvcnRlZFR5cGVhaGVhZEluZm8gPSB1c2VSZWY8VHlwZWFoZWFkSW5mb1tdPihbXSk7XG4gICAgY29uc3QgW2ludmFsaWRUeXBlYWhlYWQsIHNldEludmFsaWRUeXBlYWhlYWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KGZhbHNlKTtcblxuICAgIC8vIEhhbmRsZSB0eXBlYWhlYWQgZm9yIGlucHV0IG1ldGhvZCBlZGl0b3JzIGFzIHdlbGxcbiAgICAvLyBFc3NlbnRpYWxseSwgd2hlbiBhY3RpdmUsIGlnbm9yZSBmdXJ0aGVyIGtleXMgXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSB3YWl0aW5nIGZvciBhIENvbXBvc2l0aW9uRW5kIGV2ZW50XG4gICAgY29uc3QgWywgc2V0SW1lQWN0aXZlLCBnZXRJbWVBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy8gQmVjYXVzZSBjb21wb3NpdGlvbiBldmVudHMgZmlyZSAqYWZ0ZXIqIGtleWRvd24gZXZlbnRzIFxuICAgIC8vIChidXQgd2l0aGluIHRoZSBzYW1lIHRhc2ssIHdoaWNoLCBUT0RPLCBjb3VsZCBiZSBicm93c2VyLWRlcGVuZGVudCksXG4gICAgLy8gd2UgY2FuIHVzZSB0aGlzIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnQgd2UncmUgbGlzdGVuaW5nIGZvciBvbiB0aGUgZmlyc3Qga2V5ZG93bi5cbiAgICBjb25zdCBbbmV4dFR5cGVhaGVhZENoYXIsIHNldE5leHRUeXBlYWhlYWRDaGFyXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChuZXh0VHlwZWFoZWFkQ2hhciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0Q3VycmVudFR5cGVhaGVhZCh0eXBlYWhlYWQgPT4gKCh0eXBlYWhlYWQgPz8gXCJcIikgKyBuZXh0VHlwZWFoZWFkQ2hhciksIHVuZGVmaW5lZCEpO1xuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIobnVsbCk7XG4gICAgICAgIH1cbiAgICB9LCBbbmV4dFR5cGVhaGVhZENoYXJdKTtcblxuXG4gICAgY29uc3QgY29tcGFyYXRvclNoYXJlZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChzYWZlTGhzOiBzdHJpbmcsIHNhZmVSaHM6IHN0cmluZykgPT4ge1xuICAgICAgICBsZXQgY29tcGFyZTogbnVtYmVyO1xuICAgICAgICAvLyBGb3IgdGhlIHB1cnBvc2VzIG9mIHR5cGVhaGVhZCwgb25seSBjb21wYXJlIGEgc3RyaW5nIG9mIHRoZSBzYW1lIHNpemUgYXMgb3VyIGN1cnJlbnRseSB0eXBlZCBzdHJpbmcuXG4gICAgICAgIC8vIEJ5IG5vcm1hbGl6aW5nIHRoZW0gZmlyc3QsIHdlIGVuc3VyZSB0aGlzIGJ5dGUtYnktYnl0ZSBoYW5kbGluZyBvZiByYXcgY2hhcmFjdGVyIGRhdGEgd29ya3Mgb3V0IG9rYXkuXG4gICAgICAgIHNhZmVMaHMgPSBzYWZlTGhzLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgc2FmZVJocyA9IHNhZmVSaHMubm9ybWFsaXplKFwiTkZEXCIpXG5cbiAgICAgICAgaWYgKGNvbGxhdG9yKVxuICAgICAgICAgICAgY29tcGFyZSA9IGNvbGxhdG9yLmNvbXBhcmUoc2FmZUxocywgc2FmZVJocylcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGFyZSA9IHNhZmVMaHMudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKHNhZmVSaHMudG9Mb3dlckNhc2UoKSA/PyBcIlwiKTtcblxuICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGluc2VydGluZ0NvbXBhcmF0b3IgPSB1c2VTdGFibGVDYWxsYmFjaygobGhzOiBzdHJpbmcgfCBudWxsLCByaHM6IFR5cGVhaGVhZEluZm8pID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmhzLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yU2hhcmVkKGxocywgcmhzLnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChsaHMgYXMgdW5rbm93biBhcyBudW1iZXIpIC0gKHJocyBhcyB1bmtub3duIGFzIG51bWJlcik7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0eXBlYWhlYWRDb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxoczogc3RyaW5nLCByaHM6IFR5cGVhaGVhZEluZm8pID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmhzLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIER1cmluZyB0eXBlYWhlYWQsIGFsbCBzdHJpbmdzIGxvbmdlciB0aGFuIG91cnMgc2hvdWxkIGJlIHRydW5jYXRlZFxuICAgICAgICAgICAgLy8gc28gdGhhdCB0aGV5J3JlIGFsbCBjb25zaWRlcmVkIGVxdWFsbHkgYnkgdGhhdCBwb2ludC5cbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yU2hhcmVkKGxocywgcmhzLnRleHQuc3Vic3RyaW5nKDAsIGxocy5sZW5ndGgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobGhzIGFzIHVua25vd24gYXMgbnVtYmVyKSAtIChyaHMgYXMgdW5rbm93biBhcyBudW1iZXIpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IHVzZVN0YWJsZUdldHRlcihub1R5cGVhaGVhZCk7XG5cblxuICAgIGNvbnN0IHByb3BzU3RhYmxlID0gdXNlUmVmPGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pj4oe1xuICAgICAgICBvbktleURvd246IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZEtleWJvYXJkRXZlbnQ8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3QgaW1lQWN0aXZlID0gZ2V0SW1lQWN0aXZlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGUua2V5O1xuXG4gICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCBieSB0eXBlYWhlYWQgKGkuZS4gYXNzdW1lIHRoaXMgaXMgYSBrZXlib2FyZCBzaG9ydGN1dClcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUgJiYgZS5rZXkgPT09IFwiQmFja3NwYWNlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgY2hhcmFjdGVyIGluIGEgd2F5IHRoYXQgZG9lc24ndCBzcGxpdCBVVEYtMTYgc3Vycm9nYXRlcy5cbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHQgPT4gdCA9PSBudWxsID8gbnVsbCA6IFsuLi50XS5yZXZlcnNlKCkuc2xpY2UoMSkucmV2ZXJzZSgpLmpvaW4oXCJcIiksIGUgYXMgaC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PGFueT4pO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGtleSBwcm9wZXJ0eSByZXByZXNlbnRzIHRoZSB0eXBlZCBjaGFyYWN0ZXIgT1IgdGhlIFwibmFtZWQga2V5IGF0dHJpYnV0ZVwiIG9mIHRoZSBrZXkgcHJlc3NlZC5cbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gZGVmaW5pdGUgd2F5IHRvIHRlbGwgdGhlIGRpZmZlcmVuY2UsIGJ1dCBmb3IgYWxsIGludGVudHMgYW5kIHB1cnBvc2VzXG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gb25lLWNoYXJhY3RlciBuYW1lcywgYW5kIHRoZXJlIGFyZSBubyBub24tQVNDSUktYWxwaGEgbmFtZXMuXG4gICAgICAgICAgICAvLyBUaHVzLCBhbnkgb25lLWNoYXJhY3RlciBvciBub24tQVNDSUkgdmFsdWUgZm9yIGBrZXlgIGlzICphbG1vc3QgY2VydGFpbmx5KiBhIHR5cGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGNvbnN0IGlzQ2hhcmFjdGVyS2V5ID0gKGtleS5sZW5ndGggPT09IDEgfHwgIS9eW0EtWmEtel0vLnRlc3Qoa2V5KSk7XG4gICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXJLZXkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gXCIgXCIgJiYgKGdldEN1cnJlbnRUeXBlYWhlYWQoKSA/PyBcIlwiKS50cmltKCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgYmVjYXVzZSBhIHNwYWNlYmFyIGNhbid0IGV2ZXIgXG4gICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIGEgdHlwZWFoZWFkLCBvbmx5IGNvbnRpbnVlIG9uZS5cblxuICAgICAgICAgICAgICAgICAgICAvLyAoU3BlY2lmaWNhbGx5LCBsZXQgdGhlIGV2ZW50IGNvbnRpbnVlIHByb3BhZ2F0aW9uIGluIHRoaXMgY2FzZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdvbid0IGJlIHRydWUgZm9yIHRoZSBmaXJzdCBrZXlkb3duXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJlZm9yZSB1c2VMYXlvdXRFZmZlY3QgaXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGFjdHVhbGx5IGFwcGx5IHRoZSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KSxcbiAgICAgICAgb25Db21wb3NpdGlvblN0YXJ0OiB1c2VTdGFibGVDYWxsYmFjaygoZTogQ29tcG9zaXRpb25FdmVudCkgPT4ge1xuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoZS5kYXRhKTtcbiAgICAgICAgICAgIHNldEltZUFjdGl2ZShmYWxzZSk7XG4gICAgICAgIH0pLFxuICAgICAgICBvbkNvbXBvc2l0aW9uRW5kOiB1c2VTdGFibGVDYWxsYmFjaygoX2U6IENvbXBvc2l0aW9uRXZlbnQpID0+IHsgc2V0SW1lQWN0aXZlKHRydWUpIH0pLFxuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIGNoYW5nZXMgaW4gdHlwZWFoZWFkIHRoYXQgY2F1c2UgY2hhbmdlcyB0byB0aGUgdGFiYmFibGUgaW5kZXhcbiAgICAvKiB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgXG4gICAgIH0sIFtjdXJyZW50VHlwZWFoZWFkXSk7Ki9cblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgaW5zZXJ0aW5nQ29tcGFyYXRvcixcbiAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvOiBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgIH0pLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuOiB7XG4gICAgICAgICAgICBnZXRDdXJyZW50VHlwZWFoZWFkLFxuICAgICAgICAgICAgaW52YWxpZFR5cGVhaGVhZCxcbiAgICAgICAgICAgIHByb3BzU3RhYmxlOiBwcm9wc1N0YWJsZS5jdXJyZW50XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG5cblxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQmFzZWRPblR5cGVhaGVhZENoYW5nZShjdXJyZW50VHlwZWFoZWFkOiBzdHJpbmcgfCBudWxsLCByZWFzb246IEV2ZW50KSB7XG4gICAgICAgIGlmIChjdXJyZW50VHlwZWFoZWFkICYmIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGgpIHtcblxuXG5cbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZFR5cGVhaGVhZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgdHlwZWFoZWFkQ29tcGFyYXRvcik7XG5cbiAgICAgICAgICAgIGlmIChzb3J0ZWRUeXBlYWhlYWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBoYXMgdHlwZWQgYW4gZW50cnkgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgLy8gKG9yIG1vcmUgc3BlY2lmaWNhbGx5IFwiZm9yIHdoaWNoIHRoZXJlIGlzIG5vIGVudHJ5IHRoYXQgc3RhcnRzIHdpdGggdGhhdCBpbnB1dFwiKVxuICAgICAgICAgICAgICAgIHNldEludmFsaWRUeXBlYWhlYWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICBXZSBrbm93IHJvdWdobHkgd2hlcmUsIGluIHRoZSBzb3J0ZWQgYXJyYXkgb2Ygc3RyaW5ncywgb3VyIG5leHQgdHlwZWFoZWFkIGxvY2F0aW9uIGlzLlxuICAgICAgICAgICAgICAgICAgQnV0IHJvdWdobHkgaXNuJ3QgZ29vZCBlbm91Z2ggaWYgdGhlcmUgYXJlIG11bHRpcGxlIG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgICBUbyBjb252ZXJ0IG91ciBzb3J0ZWQgaW5kZXggdG8gdGhlIHVuc29ydGVkIGluZGV4IHdlIG5lZWQsIHdlIGhhdmUgdG8gZmluZCB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHVzICphbmQqIChpZiBhbnkgc3VjaCBleGlzdCkgaXMgKmFmdGVyKiBvdXIgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgXG4gICAgICAgICAgICAgICAgICBJbiBvdGhlciB3b3JkcywgdGhlIG9ubHkgd2F5IHR5cGVhaGVhZCBtb3ZlcyBiYWNrd2FyZHMgcmVsYXRpdmUgdG8gb3VyIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIGlzIGlmIHRoZSBvbmx5IG90aGVyIG9wdGlvbiBpcyBiZWhpbmQgdXMuXG4gICAgXG4gICAgICAgICAgICAgICAgICBJdCdzIG5vdCBzcGVjaWZpZWQgaW4gV0FJLUFSSUEgd2hhdCB0byBkbyBpbiB0aGF0IGNhc2UuICBJIHN1cHBvc2Ugd3JhcCBiYWNrIHRvIHRoZSBzdGFydD9cbiAgICAgICAgICAgICAgICAgIFRob3VnaCB0aGVyZSdzIGFsc28gYSBjYXNlIGZvciBqdXN0IGdvaW5nIHVwd2FyZHMgdG8gdGhlIG5lYXJlc3QgdG8gcHJldmVudCBqdW1waW5lc3MuXG4gICAgICAgICAgICAgICAgICBCdXQgaWYgeW91J3JlIGFscmVhZHkgZG9pbmcgdHlwZWFoZWFkIG9uIGFuIHVuc29ydGVkIGxpc3QsIGxpa2UsIGp1bXBpbmVzcyBjYW4ndCBiZSBhdm9pZGVkLlxuICAgICAgICAgICAgICAgICAgSSBkdW5uby4gR29pbmcgYmFjayB0byB0aGUgc3RhcnQgaXMgdGhlIHNpbXBsaXN0IHRob3VnaC5cbiAgICBcbiAgICAgICAgICAgICAgICAgIEJhc2ljYWxseSB3aGF0IHRoaXMgZG9lczogU3RhcnRpbmcgZnJvbSB3aGVyZSB3ZSBmb3VuZCBvdXJzZWx2ZXMgYWZ0ZXIgb3VyIGJpbmFyeSBzZWFyY2gsXG4gICAgICAgICAgICAgICAgICBzY2FuIGJhY2t3YXJkcyBhbmQgZm9yd2FyZHMgdGhyb3VnaCBhbGwgYWRqYWNlbnQgZW50cmllcyB0aGF0IGFsc28gY29tcGFyZSBlcXVhbGx5IHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgIHdlIGNhbiBmaW5kIHRoZSBvbmUgd2hvc2UgYHVuc29ydGVkSW5kZXhgIGlzIHRoZSBsb3dlc3QgYW1vbmdzdCBhbGwgb3RoZXIgZXF1YWwgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgKGFuZCBhbHNvIHRoZSBsb3dlc3QgYHVuc29ydGVkSW5kZXhgIHlhZGRhIHlhZGRhIGV4Y2VwdCB0aGF0IGl0IGNvbWVzIGFmdGVyIHVzKS5cbiAgICBcbiAgICAgICAgICAgICAgICAgIFRPRE86IFRoZSBiaW5hcnkgc2VhcmNoIHN0YXJ0cyB0aGlzIG9mZiB3aXRoIGEgc29saWQgTyhsb2cgbiksIGJ1dCBvbmUtY2hhcmFjdGVyIFxuICAgICAgICAgICAgICAgICAgc2VhcmNoZXMgYXJlLCB0aGFua3MgdG8gcGlnZW9uaG9sZSBwcmluY2lwYWwsIGV2ZW50dWFsbHkgZ3VhcmFudGVlZCB0byBiZWNvbWUgXG4gICAgICAgICAgICAgICAgICBPKG4qbG9nIG4pLiBUaGlzIGlzIGFubm95aW5nIGJ1dCBwcm9iYWJseSBub3QgZWFzaWx5IHNvbHZhYmxlPyBUaGVyZSBjb3VsZCBiZSBhbiBcbiAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiBmb3Igb25lLWNoYXJhY3RlciBzdHJpbmdzLCBidXQgdGhhdCdzIGp1c3Qga2lja2luZyB0aGUgY2FuIGRvd24gXG4gICAgICAgICAgICAgICAgICB0aGUgcm9hZC4gTWF5YmUgb25lIG9yIHR3byBjaGFyYWN0ZXJzIHdvdWxkIGJlIGdvb2QgZW5vdWdoIHRob3VnaC5cbiAgICAgICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjYW5kaWRhdGVzJyBwb3NpdGlvbnMgaW4gYm90aCBvdXIgc29ydGVkIGFycmF5IGFuZCB0aGUgdW5zb3J0ZWQgRE9NLlxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4QWxsOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0U29ydGVkSW5kZXhBbGwgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIHR3byBhcmUgb25seSBzZXQgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIGFoZWFkIG9mIHVzLCBidXQgdGhlIHByaW5jaXBsZSdzIHRoZSBzYW1lIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4TmV4dCA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlQmVzdEZpdCA9ICh1OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U29ydGVkSW5kZXhBbGwgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPT0gbnVsbCB8fCB1IDwgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQpICYmIHUgPiAoZ2V0SW5kZXgoKSA/PyAtSW5maW5pdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9IHU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGkgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIHR5cGVhaGVhZENvbXBhcmF0b3IoY3VycmVudFR5cGVhaGVhZCwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50Lmxlbmd0aCAmJiB0eXBlYWhlYWRDb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5kZXgoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2xvd2VzdFNvcnRlZEluZGV4TmV4dF0udW5zb3J0ZWRJbmRleCwgcmVhc29uLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBzZXRJbmRleChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbbG93ZXN0U29ydGVkSW5kZXhBbGxdLnVuc29ydGVkSW5kZXgscmVhc29uLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4LCAuLi52b2lkMSB9LFxuICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogeyBnZXRUZXh0LCAuLi52b2lkNSB9LFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQ6IHsgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczogeyBzb3J0ZWRUeXBlYWhlYWRJbmZvLCBpbnNlcnRpbmdDb21wYXJhdG9yLCAuLi52b2lkMiB9IH0sXG4gICAgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50LCAuLi52b2lkMyB9LFxuICAgIC8vdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczogeyAuLi52b2lkNSB9LFxuICAgIC4uLnZvaWQ0XG59OiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD4pOiBSZXR1cm5UeXBlPFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQ+PiB7XG5cbiAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkMSk7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDIpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQzKTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkNCk7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDUpO1xuXG4gICAgY29uc3QgeyB0ZXh0Q29udGVudFJldHVybiB9ID0gdXNlVGV4dENvbnRlbnQoe1xuICAgICAgICByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQgfSxcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBnZXRUZXh0LFxuICAgICAgICAgICAgb25UZXh0Q29udGVudENoYW5nZTogdXNlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8c3RyaW5nIHwgbnVsbCwgbmV2ZXI+PigodGV4dDogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgd2hlcmUgdG8gaW5zZXJ0IHRoaXMgaXRlbS5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBhbGwgaW5kZXggdmFsdWVzIHNob3VsZCBiZSB1bmlxdWUsIHRoZSByZXR1cm5lZCBzb3J0ZWRJbmRleFxuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYWx3YXlzIHJlZmVyIHRvIGEgbmV3IGxvY2F0aW9uIChpLmUuIGJlIG5lZ2F0aXZlKSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mbywgdGV4dCwgaW5zZXJ0aW5nQ29tcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBpbnNlcnRpbmdDb21wYXJhdG9yKHNvcnRlZFR5cGVhaGVhZEluZm9bc29ydGVkSW5kZXhdLnRleHQsIHsgdW5zb3J0ZWRJbmRleDogaW5kZXgsIHRleHQgfSkgPT0gMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uc3BsaWNlKC1zb3J0ZWRJbmRleCAtIDEsIDAsIHsgdGV4dCwgdW5zb3J0ZWRJbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLnNwbGljZShzb3J0ZWRJbmRleCwgMCwgeyB0ZXh0LCB1bnNvcnRlZEluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVubW91bnRpbmcsIGZpbmQgd2hlcmUgd2Ugd2VyZSBhbmQgcmVtb3ZlIG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFnYWluLCB3ZSBzaG91bGQgYWx3YXlzIGZpbmQgb3Vyc2VsdmVzIGJlY2F1c2UgdGhlcmUgc2hvdWxkIGJlIG5vIGR1cGxpY2F0ZSB2YWx1ZXMgaWYgZWFjaCBpbmRleCBpcyB1bmlxdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLCB0ZXh0LCBpbnNlcnRpbmdDb21wYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBpbnNlcnRpbmdDb21wYXJhdG9yKHNvcnRlZFR5cGVhaGVhZEluZm9bc29ydGVkSW5kZXhdLnRleHQsIHsgdW5zb3J0ZWRJbmRleDogaW5kZXgsIHRleHQgfSkgPT0gMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5zcGxpY2Uoc29ydGVkSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4geyB0ZXh0Q29udGVudFJldHVybiB9XG5cbn1cblxuLyoqXG4gKiBZb3VyIHVzdWFsIGJpbmFyeSBzZWFyY2ggaW1wbGVtZW50YXRpb24uXG4gKiBcbiAqIEl0J3MgdXNlZCBoZXJlIHRvIHF1aWNrbHkgZmluZCBhIGdvb2Qgc3BvdCB0byBzdGFydCBzZWFyY2hpbmcgZm9yIG91ciBuZXh0IHR5cGVhaGVhZCBjYW5kaWRhdGUuXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaCB0aHJvdWdoXG4gKiBAcGFyYW0gd2FudGVkIFRoZSB2YWx1ZSB5b3UnZCBsaWtlIHRvIGZpbmRcbiAqIEBwYXJhbSBjb21wYXJhdG9yIENvbXBhcmVzIGB3YW50ZWRgIHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgaW4gYGFycmF5YFxuICogQHJldHVybnMgQSBub24tbmVnYXRpdmUgdmFsdWUgaWYgYHdhbnRlZGAgd2FzIGZvdW5kLCBhbmQgYSBuZWdhdGl2ZSBudW1iZXIgaWYgbm90LiBcbiAqIFRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIG51bWJlciwgbWludXMgb25lLCBpcyB3aGVyZSBgd2FudGVkYCAqd291bGQqIGJlIGZvdW5kIGlmIGl0ICp3YXMqIGluIGBhcnJheWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaDxULCBVLCBGIGV4dGVuZHMgKGxoczogVSwgcmhzOiBUKSA9PiBudW1iZXI+KGFycmF5OiBUW10sIHdhbnRlZDogVSwgY29tcGFyYXRvcjogRik6IG51bWJlciB7XG4gICAgbGV0IGZpcnN0SW5kZXggPSAwO1xuICAgIGxldCBsYXN0SW5kZXggPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChmaXJzdEluZGV4IDw9IGxhc3RJbmRleCkge1xuICAgICAgICBjb25zdCB0ZXN0SW5kZXggPSAobGFzdEluZGV4ICsgZmlyc3RJbmRleCkgPj4gMTtcbiAgICAgICAgY29uc3QgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmF0b3Iod2FudGVkLCBhcnJheVt0ZXN0SW5kZXhdKTtcblxuICAgICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSB0ZXN0SW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSB0ZXN0SW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRlc3RJbmRleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtZmlyc3RJbmRleCAtIDE7XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBhc3NlcnRFbXB0eU9iamVjdCwgTWFuYWdlZENoaWxkSW5mbywgdXNlQ2hpbGRyZW5GbGFnLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyBVc2VIYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4uL29ic2VydmVycy91c2UtaGFzLWN1cnJlbnQtZm9jdXNcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCBQYXNzaXZlU3RhdGVVcGRhdGVyIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVPYmplY3QgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGF0ZVwiO1xuXG5cblxuZXhwb3J0IHR5cGUgT25UYWJiYWJsZUluZGV4Q2hhbmdlID0gKHRhYmJhYmxlSW5kZXg6IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyPiB7XG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSBuYXZpZ2F0ZSB0byBhIGNoaWxkIGFuZCBmb2N1cyBpdCwgd2UgbmVlZCB0byBrbm93IGhvdyB0aGF0IGNoaWxkIHdhbnRzIHRvIGJlIGZvY3VzZWQuXG4gICAgICogR2VuZXJhbGx5LCB0aGlzIGlzIGp1c3QgZ2V0RWxlbWVudCgpLmZvY3VzKCksIGJ1dCB5b3UncmUgYWxsb3dlZCB0byBzdXBwbHkgYW55dGhpbmcgeW91IHdhbnQgaGVyZS5cbiAgICAgKiBHcmlkIHJvd3MsIGZvciBleGFtcGxlLCBkb24ndCBkaXJlY3RseSBmb2N1cyB0aGVtc2VsdmVzIGJ1dCBpbnN0ZWFkIGNhbGwgb25lIG9mIHRoZWlyIGNlbGwncyBgZm9jdXNTZWxmYC5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGlzIHVzZWQgd2hlbiB0aGUgdGFiYmFibGUgaW5kZXggY2hhbmdlcyAod2UgYXV0by1mb2N1cyB0aGUgbmV3bHkgdGFiYmFibGUgZWxlbWVudCBpZiBhcHBsaWNhYmxlKSxcbiAgICAgKiBhbmQgYWxzbyBieSB0aGUgYGZvY3VzU2VsZmAgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIHBhcmVudCAoaS5lLiBgcGFyZW50LmZvY3VzU2VsZmAgY2FsbHMgb25lIGNoaWxkJ3MgYGZvY3VzU2VsZmApXG4gICAgICovXG4gICAgZm9jdXNTZWxmKGU6IFRhYmJhYmxlQ2hpbGRFbGVtZW50KTogdm9pZDtcblxuICAgIGdldEVsZW1lbnQoKTogVGFiYmFibGVDaGlsZEVsZW1lbnQgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhpcyBjaGlsZCBjYW5ub3QgYmUgZ2l2ZW4gZm9jdXMgYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCwgaXMgbm90IHZpc2libGUsIGlzIGRpc2FibGVkLCBldGMuIEFueSBhdHRlbXB0IHRvIGZvY3VzIHRoaXMgZWxlbWVudCB3aWxsIGZvY3VzIGl0cyBjbG9zZXN0IG5laWdoYm9yIGluc3RlYWQuXG4gICAgICogXG4gICAgICogVGhpcyAqKipNVVNUKioqIGJlIHRydWUgaWYgdGhlIGNoaWxkIGlzIGBkaXNwbGF5OiBub25lYCwgYHZpc2liaWxpdHk6IGhpZGRlbmAsIGFuZCBvdGhlciBjYXNlcyB3aGVyZSB0aGUgZWxlbWVudCdzIGZvY3VzYWJpbGl0eSBpcyByZW1vdmVkIGluIGEgd2F5IHRoYXQncyBub3QgZGV0ZWN0aWJsZS5cbiAgICAgKi9cbiAgICBoaWRkZW46IGJvb2xlYW47XG5cbiAgICBzZXRUYWJiYWJsZTogU3RhdGVVcGRhdGVyPGJvb2xlYW4+O1xuICAgIGdldFRhYmJhYmxlOiAoKSA9PiBib29sZWFuO1xuICAgIHRhYmJhYmxlOiBib29sZWFuO1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPFRhYmJhYmxlQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50Pj4ge1xuICAgIC8qKiBXaGVuIGNoaWxkcmVuIG1vdW50L3VubW91bnQsIFJUSSBuZWVkcyBhY2Nlc3MgdG8gYWxsIGtub3duIGNoaWxkcmVuIGluIGNhc2Ugd2UgdW5tb3VudGVkIHRoZSBjdXJyZW50bHkgdGFiYmFibGUgY2hpbGQgKi9cbiAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IFBpY2s8VXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPltcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiXSwgXCJnZXRDaGlsZHJlblwiPjtcblxuICAgIC8qKiBUaGUgb25seSBwYXJhbWV0ZXJzIFJUSSBuZWVkcyBkaXJlY3RseSBpcyB0aGUgaW5pdGlhbCBpbmRleCB0byBiZSB0YWJiYWJsZSAqL1xuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyBpbXBlcmF0aXZlLCBub3QgZGVjbGFyYXRpdmU7IFxuICAgICAgICAgKiBpdCBpcyBiZXR0ZXIgaWYgd2UgY2FuIGtlZXAgcmUtcmVuZGVycyBvbiB0aGUgcGFyZW50IHRvIGEgbWluaW11bSBhbnl3YXkuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBZb3UgY2FuIG1hbnVhbGx5IGNvbnRyb2wgdGhpcyB3aXRoIGBvblRhYmJhYmxlSW5kZXhDaGFuZ2VgIGFuZCBgc2V0VGFiYmFibGVJbmRleGAgaWYgeW91IG5lZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsbHlUYWJiZWRJbmRleDogbnVtYmVyIHwgbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0cnVlLCBub25lIG9mIHRoZSBjaGlsZHJlbiB3aWxsIGJlIHRhYmJhYmxlLCBhcyBpZiB0aGUgZW50aXJlIGNvbXBvbmVudCBpcyBoaWRkZW4uXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGlzIGRvZXMgbm90IGFjdHVhbGx5IGNoYW5nZSB0aGUgY3VycmVudGx5IHRhYmJhYmxlIGluZGV4OyBpZiB0aGlzIGlzIHNldCB0byBgZmFsc2VgLCB0aGUgbGFzdCB0YWJiYWJsZSBjaGlsZCBpcyByZW1lbWJlcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdW50YWJiYWJsZTogYm9vbGVhbjtcblxuICAgICAgICAvKiogXG4gICAgICAgICAqIElmIHlvdSB3b3VsZCBsaWtlIHRvIGhhdmUgYW4gZXZlbnQgcnVuIHdoZW5ldmVyIGEgbmV3IGluZGV4IGJlY29tZXMgdGFiYmFibGVcbiAgICAgICAgICogKGUuZy4gdG8gY2FsbCBgc2V0U3RhdGVgIHRvIHJlbmRlciB0aGF0IHRhYmJhYmxlIGluZGV4Li4uZm9yIHNvbWUgcmVhc29uLi4uKVxuICAgICAgICAgKiB5b3UgY2FuIGRvIHRoYXQgaGVyZS5cbiAgICAgICAgICogXG4gICAgICAgICAqICoqTVVTVCoqIGJlIHN0YWJsZSFcbiAgICAgICAgICovXG4gICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZTogbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPG51bWJlciB8IG51bGwsIEV2ZW50PjtcbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZTxUYWJiYWJsZUNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICAvKiogUlRJIHJ1bnMgbG9naWMgd2hlbiBpdHMgY2hpbGRyZW4gbW91bnQvdW5tb3VudCB0aGVtc2VsdmVzICovXG4gICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogUGljazxVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50Pj5bXCJtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzXCJdLCBcIm9uQ2hpbGRyZW5Nb3VudENoYW5nZVwiPjtcblxuICAgIC8qKlxuICAgICAqIFNUQUJMRVxuICAgICAqL1xuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0OiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxUYWJiYWJsZUNoaWxkRWxlbWVudD5bXCJyb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dFwiXTtcblxuICAgIC8qKiBcbiAgICAgKiBSZXR1cm4gaW5mb3JtYXRpb24gdGhhdCBsZXRzIHRoZSB1c2VyIHVwZGF0ZS9xdWVyeS9mb2N1cyB0aGUgY3VycmVudGx5IHRhYmJhYmxlIGNoaWxkXG4gICAgICpcbiAgICAgKiAgXG4gICAgICovXG4gICAgcm92aW5nVGFiSW5kZXhSZXR1cm46IHtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgc2V0VGFiYmFibGVJbmRleDogU2V0VGFiYmFibGVJbmRleDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0VGFiYmFibGVJbmRleDogKCkgPT4gbnVtYmVyIHwgbnVsbDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZm9jdXNTZWxmOiAocmVhc29uPzogYW55KSA9PiB2b2lkO1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgU2V0VGFiYmFibGVJbmRleCA9ICh1cGRhdGVyOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbCwgRXZlbnQ+PlswXSwgcmVhc29uOiBFdmVudCB8IHVuZGVmaW5lZCwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4gdm9pZDtcblxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZVdpdGhIb29rczxUYWJiYWJsZUNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudD4geyB9XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxUYWJiYWJsZUNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBQaWNrPFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50PiwgXCJpbmRleFwiPjtcblxuICAgIC8qKiBcbiAgICAgKiBUaGUgaW5mb3JtYXRpb24gc3BlY2lmaWMgdG8gUlRJIGZvciB0aGlzIGNoaWxkIHRoYXQgeW91IHByb3ZpZGVcbiAgICAgKi9cbiAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczogUGljazxVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudD4sIFwiaGlkZGVuXCI+O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGluZm9ybWF0aW9uIHByb3ZpZGVkIGJ5IHRoZSBwYXJlbnQgaG9va1xuICAgICAqL1xuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0OiBSb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dDxUYWJiYWJsZUNoaWxkRWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQ8VGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgX2U/OiBUYWJiYWJsZUNoaWxkRWxlbWVudDtcblxuICAgIHNldFRhYmJhYmxlSW5kZXg6IFNldFRhYmJhYmxlSW5kZXg7IC8vVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlPFRhYmJhYmxlQ2hpbGRFbGVtZW50PltcInJvdmluZ1RhYkluZGV4UmV0dXJuXCJdW1wic2V0VGFiYmFibGVJbmRleFwiXTtcblxuICAgIC8qKlxuICAgICAqIChUaGlzIGlzIHRlY2huaWNhbGx5IHRoZSBzYW1lIGFzIHdoYXQncyBwYXNzZWQgdG8gb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxuICAgICAqIGJ1dCBpdCBzZXJ2ZXMgYSBzbGlnaHRseSBkaWZmZXJlbnQgcHVycG9zZSBhbmQgaXMgc2VwYXJhdGUgZm9yIGNsYXJpdHkpXG4gICAgICovXG4gICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXQ6ICgpID0+IHZvaWQ7XG59XG5cbi8vZXhwb3J0IHR5cGUgVXNlUm92aW5nVGFiSW5kZXhDaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhOiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIFI+KSA9PiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcblxuICAgIC8qKiBcbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGEgdXNlciBjbGlja3Mgb24gYW4gZWxlbWVudCBvciBtYW51YWxseSBmb2N1c2VzIGl0IGluIHNvbWUgb3RoZXIgd2F5LlxuICAgICAqIFxuICAgICAqIFdlIG5lZWQgdG8ga25vdyBpZiB3ZSdyZSBjdXJyZW50bHkgZm9jdXNlZCBzbyB0aGF0IHdlIGNhbiB0ZWxsIHRoZSBwYXJlbnQgdG8gbWFyayB0aGlzIGNoaWxkIGFzIHRoZSBjdXJyZW50bHkgdGFiYmFibGUgY2hpbGQuXG4gICAgICovXG4gICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczogUmVxdWlyZWQ8UGljazxVc2VIYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD5bXCJoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzXCJdLCBcIm9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWRcIj4+O1xuXG4gICAgLyoqIFJldHVybiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFiYmFibGUgc3RhdGUgb2YgdGhpcyBjaGlsZCAqL1xuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm46IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICpVbnN0YWJsZSpcbiAgICAgICAgICogXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBjaGlsZCwgaW5kaXZpZHVhbGx5LCBpcyAqdGhlKiBjdXJyZW50bHkgdGFiYmFibGUgY2hpbGQuXG4gICAgICAgICAqL1xuICAgICAgICB0YWJiYWJsZTogYm9vbGVhbjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0VGFiYmFibGUoKTogYm9vbGVhbjtcbiAgICAgICAgLyoqICoqU1RBQkxFKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEludGVybmFsIHVzZSBvbmx5LCBwYXNzIHRvIGB1c2VNYW5hZ2VkQ2hpbGRgXG4gICAgICAgICAqL1xuICAgICAgICBzZXRUYWJiYWJsZTogU3RhdGVVcGRhdGVyPGJvb2xlYW4+O1xuXG4gICAgICAgIC8qKiBcbiAgICAgICAgICogKlVuc3RhYmxlKlxuICAgICAgICAgKiBcbiAgICAgICAgICogVGhlIHByb3BzIHRoYXQgbXVzdCBiZSBhcHBsaWVkIHRvIHRoaXMgY2hpbGQgaW4gb3JkZXIgZm9yIHRoaXMgaG9vayB0byB3b3JrLlxuICAgICAgICAgKiBcbiAgICAgICAgICogVGhlIG9iamVjdCBpdHNlbGYsIGFzIHdlbGwgYXMgdGhlIHByb3BlcnRpZXMgd2l0aGluIGl0LCBhcmUgdW5zdGFibGUgYW5kIHNob3VsZCBiZSByZW5kZXJlZCBieSB0aGUgc2FtZSBjb21wb25lbnQgdGhhdCB1c2VzIHRoaXMgaG9vay5cbiAgICAgICAgICovXG4gICAgICAgIHByb3BzVW5zdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD47XG4gICAgfVxufVxuXG5cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgcm92aW5nIHRhYmluZGV4IHN5c3RlbSB3aGVyZSBvbmx5IG9uZSBcImZvY3VzYWJsZVwiXG4gKiBjb21wb25lbnQgaW4gYSBzZXQgaXMgYWJsZSB0byByZWNlaXZlIGEgdGFiIGZvY3VzLiAqV2hpY2gqXG4gKiBvZiB0aG9zZSBlbGVtZW50cyByZWNlaXZlcyBmb2N1cyBpcyBkZXRlcm1pbmVkIGJ5IHlvdSwgYnV0IGl0J3NcbiAqIHJlY29tbWVuZGVkIHRvIG9mZmxvYWQgdGhhdCBsb2dpYyB0aGVuIHRvIGFub3RoZXIgaG9vaywgbGlrZVxuICogYHVzZUxpbmVhck5hdmlnYXRpb25gLCB3aGljaCBsZXRzIHlvdSBjaGFuZ2UgdGhlIHRhYmJhYmxlXG4gKiBlbGVtZW50IHdpdGggdGhlIGFycm93IGtleXMsIGB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uYCwgd2hpY2hcbiAqIGxldHMgeW91IGNoYW5nZSB0aGUgdGFiYmFibGUgaW5kZXggd2l0aCB0eXBlYWhlYWQsIG9yXG4gKiBgdXNlTGlzdE5hdmlnYXRpb25gIGlmIHlvdSBqdXN0IHdhbnQgZXZlcnl0aGluZyBidW5kbGVkIHRvZ2V0aGVyLlxuICogXG4gKiBOb3RlIHRoYXQgdGhlIGNoaWxkIGhvb2sgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWRcbiAqIGJ5IGV2ZXJ5IGNoaWxkIHRoYXQgdXNlcyB0aGlzIHJvdmluZyB0YWJpbmRleCBsb2dpYy4gIFRoZVxuICogcHJvcC1tb2RpZnlpbmcgaG9vayAqdGhhdCogaG9vayByZXR1cm5zIHNob3VsZCB0aGVuIGJlIHVzZWRcbiAqIG9uIHRoZSBjaGlsZCdzIGVsZW1lbnQsIGFzIHdlbGwgYXMgYW55IG90aGVyIGVsZW1lbnRzIHlvdSdkIGxpa2VcbiAqIHRvIGJlIGV4cGxpY2l0bHkgbWFkZSB1bnRhYmJhYmxlIHRvby5cbiAqIFxuICogYHNob3VsZEZvY3VzT25DaGFuZ2VgIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiBmb2N1cyBpcyBcbiAqIGNvbnRhaW5lZCB3aXRoaW4gd2hhdGV2ZXIgZWxlbWVudCBjb250YWlucyB0aGUgcm92aW5nIHRhYiBpbmRleC5cbiAqIEdlbmVyYWxseSBhcyBzaW1wbGUgYXMgdGhlIGZvbGxvd2luZzpcbiAqIGBgYFxuICogY29uc3QgW2ZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAqIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8UGFyZW50RWxlbWVudD4oeyBzZXRGb2N1c2VkSW5uZXIgfSk7XG4gKiBjb25zdCBmb2N1c09uQ2hhbmdlID0gKGZvY3VzZWRJbm5lciAhPSBmYWxzZSk7XG4gKiBgYGBcbiAqIEl0J3Mgbm90IGluY2x1ZGVkIGhlcmUgYmVjYXVzZSBgdXNlUm92aW5nVGFiSW5kZXhgIGRvZXNuJ3Qga25vdyBcbiAqIGFueXRoaW5nIGFib3V0IHRoZSBjb250YWluZXIgZWxlbWVudCwgb25seSBjaGlsZHJlbiBlbGVtZW50cy5cbiAqIEFuZCBqdXN0IGFzIHdlbGwhIENoaWxkcmVuIHNob3VsZCBiZSBhbGxvd2VkIGF0IHRoZSByb290LCBcbiAqIHJlZ2FyZGxlc3Mgb2YgaWYgaXQncyB0aGUgd2hvbGUgYXBwIG9yIGp1c3QgYSBnaXZlbiBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm88Q2hpbGRFbGVtZW50Pj4oe1xuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogeyBnZXRDaGlsZHJlbiB9LFxuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogeyB1bnRhYmJhYmxlLCBpbml0aWFsbHlUYWJiZWRJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlIH0sXG4gICAgLi4uX3ZvaWQxXG59OiBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBNPik6IFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+IHtcbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDEpO1xuXG4gICAgLy9pbml0aWFsbHlUYWJiZWRJbmRleCA/Pz0gMDtcblxuICAgIC8vIE92ZXJyaWRlIHRoZSBhY3R1YWwgc2V0dGVyIHRvIGluY2x1ZGUgc29tZSBleHRyYSBsb2dpYyByZWxhdGVkIHRvIGF2b2lkaW5nIGhpZGRlbiBjaGlsZHJlbiwgXG4gICAgLy8gd2hhdCB0byBkbyB3aGVuIHdlJ3JlIHVudGFiYmFibGUsIHdoYXQgdG8gZG8gd2hlbiB3ZSdyZSB0YWJiYWJsZSBidXQgZ2l2ZW4gYG51bGxgLCBldGMuXG4gICAgY29uc3Qgc2V0VGFiYmFibGVJbmRleCA9IHVzZVN0YWJsZUNhbGxiYWNrPFNldFRhYmJhYmxlSW5kZXg+KCh1cGRhdGVyLCByZWFzb24sIGZyb21Vc2VySW50ZXJhY3Rpb24pID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuXG4gICAgICAgIC8vIE5vdGlmeSB0aGUgcmVsZXZhbnQgY2hpbGRyZW4gdGhhdCB0aGV5IHNob3VsZCBiZWNvbWUgdGFiYmFibGUvdW50YWJiYWJsZSxcbiAgICAgICAgLy8gYnV0IGFsc28gaGFuZGxlIGZvY3VzIG1hbmFnZW1lbnQgd2hlbiB3ZSBjaGFuZ2VkIGR1ZSB0byB1c2VyIGludGVyYWN0aW9uXG4gICAgICAgIHJldHVybiBzZXRUYWJiYWJsZUluZGV4MyhmLCByZWFzb24pO1xuXG5cbiAgICAgICAgZnVuY3Rpb24gZihwcmV2SW5kZXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIgfCBudWxsIHtcbiAgICAgICAgICAgIGxldCBuZXh0SW5kZXggPSAoKHR5cGVvZiB1cGRhdGVyID09PSBcImZ1bmN0aW9uXCIpID8gdXBkYXRlcihwcmV2SW5kZXggPz8gbnVsbCkgOiB1cGRhdGVyKSBhcyBNW1wiaW5kZXhcIl07XG5cbiAgICAgICAgICAgIGlmICh1bnRhYmJhYmxlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICBpZiAocHJldkluZGV4ICE9IG5leHRJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IG5leHRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KG5leHRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZD8uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2SW5kZXggPz8gKHVudGFiYmFibGUgPyBudWxsIDogMCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZCAhPSBudWxsICYmIGZyb21Vc2VySW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IG5leHRDaGlsZC5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8ICFlbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDaGlsZC5mb2N1c1NlbGYoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5leHRJbmRleCA/PyAodW50YWJiYWJsZSA/IG51bGwgOiAwKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGxhc3ROb25OdWxsSW5kZXggPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4oaW5pdGlhbGx5VGFiYmVkSW5kZXgpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdCA9IGdldFRhYmJhYmxlSW5kZXgoKTtcbiAgICAgICAgaWYgKHQgIT0gbnVsbClcbiAgICAgICAgICAgIGxhc3ROb25OdWxsSW5kZXguY3VycmVudCA9IHQ7XG4gICAgfSk7XG5cbiAgICAvLyBBbnkgdGltZSB3ZSBzd2l0Y2ggdG8gYmVpbmcgdW50YWJiYWJsZSwgc2V0IHRoZSBjdXJyZW50IHRhYmJhYmxlIGluZGV4IGFjY29yZGluZ2x5LlxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh1bnRhYmJhYmxlKVxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleDMobnVsbCwgdW5kZWZpbmVkISk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgzKGxhc3ROb25OdWxsSW5kZXguY3VycmVudCwgdW5kZWZpbmVkISk7XG4gICAgfSwgW3VudGFiYmFibGVdKTtcblxuICAgIC8vIEJvaWxlcnBsYXRlIHJlbGF0ZWQgdG8gbm90aWZ5aW5nIGluZGl2aWR1YWwgY2hpbGRyZW4gd2hlbiB0aGV5IGJlY29tZSB0YWJiYWJsZS91bnRhYmJhYmxlXG4gICAgY29uc3QgZ2V0VGFiYmFibGVBdCA9IHVzZUNhbGxiYWNrKChtOiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+KSA9PiB7IHJldHVybiBtLmdldFRhYmJhYmxlKCkgfSwgW10pO1xuICAgIGNvbnN0IHNldFRhYmJhYmxlQXQgPSB1c2VDYWxsYmFjaygobTogVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm88Q2hpbGRFbGVtZW50PiwgdDogYm9vbGVhbikgPT4geyBtLnNldFRhYmJhYmxlKHQpOyB9LCBbXSk7XG4gICAgY29uc3QgaXNUYWJiYWJsZVZhbGlkID0gdXNlQ2FsbGJhY2soKG06IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPENoaWxkRWxlbWVudD4pID0+IHsgcmV0dXJuICFtLmhpZGRlbiB9LCBbXSk7XG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleDogc2V0VGFiYmFibGVJbmRleDMsIGdldEN1cnJlbnRJbmRleDogZ2V0VGFiYmFibGVJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgfSA9IHVzZUNoaWxkcmVuRmxhZzxVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+LCBFdmVudD4oe1xuICAgICAgICBpbml0aWFsSW5kZXg6IGluaXRpYWxseVRhYmJlZEluZGV4ID8/ICh1bnRhYmJhYmxlPyBudWxsIDogMCksXG4gICAgICAgIG9uSW5kZXhDaGFuZ2U6IG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICAgICAgZ2V0Q2hpbGRyZW4sXG4gICAgICAgIGNsb3Nlc3RGaXQ6IHRydWUsXG4gICAgICAgIGdldEF0OiBnZXRUYWJiYWJsZUF0LFxuICAgICAgICBpc1ZhbGlkOiBpc1RhYmJhYmxlVmFsaWQsXG4gICAgICAgIHNldEF0OiBzZXRUYWJiYWJsZUF0LFxuICAgIH0pO1xuXG4gICAgY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKHJlYXNvbj86IHVua25vd24pID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldFRhYmJhYmxlSW5kZXgoKTtcbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjaGlsZHJlbi5nZXRBdChpbmRleCk/LmdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KGluZGV4KT8uZm9jdXNTZWxmPy4oZWxlbWVudCEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobnVsbCwgcmVhc29uIGFzIGFueSwgdHJ1ZSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQgPSB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICBzZXRUYWJiYWJsZUluZGV4LFxuICAgICAgICByZWV2YWx1YXRlQ2xvc2VzdEZpdFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHJlZXZhbHVhdGVDbG9zZXN0Rml0LCB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybjogeyBzZXRUYWJiYWJsZUluZGV4LCBnZXRUYWJiYWJsZUluZGV4LCBmb2N1c1NlbGYgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHRcbiAgICB9O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4LCAuLi5fdm9pZDIgfSxcbiAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dDogeyByZWV2YWx1YXRlQ2xvc2VzdEZpdCwgc2V0VGFiYmFibGVJbmRleCB9LFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxufTogVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50Pik6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudD4ge1xuICAgIGNvbnN0IHsgaGlkZGVuLCAuLi5fdm9pZDEgfSA9IHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzO1xuICAgIGNvbnN0IFt0YWJiYWJsZSwgc2V0VGFiYmFibGUsIGdldFRhYmJhYmxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7XG4gICAgfSwgWyEhaGlkZGVuXSk7XG5cbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDEpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbiwgX3ByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkLCBlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpbmRleCwgZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm46IHtcbiAgICAgICAgICAgIHByb3BzVW5zdGFibGU6IHsgdGFiSW5kZXg6ICh0YWJiYWJsZSA/IDAgOiAtMSkgfSxcbiAgICAgICAgICAgIHRhYmJhYmxlLFxuICAgICAgICAgICAgZ2V0VGFiYmFibGUsXG4gICAgICAgICAgICBzZXRUYWJiYWJsZVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IGFzc2VydEVtcHR5T2JqZWN0IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGUsIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyB1c2VSb3ZpbmdUYWJJbmRleCwgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm8sIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZSwgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLCBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XG5cblxuLyoqXG4gKiBcbiAqIFRPRE86IFRoaXMgdGFibGUgd2FzIHNjcmFwcGVkIHdoZW4gdGhpcyB3YXMgY2hhbmdlZCB0byBqdXN0IGFjY2VwdCBhIGNvbGxhdG9yIGRpcmVjdGx5LFxuICogYnV0IGl0J3Mgbm90IGJhZCBmb3IgYSBjb2xsYXRpb24gY3Jhc2ggY291cnNlIGFuZCBJIG1pZ2h0IHVzZSBpdCBhZ2Fpbi5cbiAqIEV2ZW4ganVzdCBhcyBhIFwidGhpcyBpcyB3aHkgaXQncyBpbXBvcnRhbnQgYW5kIGdvb2QgdG8gdXNlIHRoZXNlIHRoaW5nc1wiIHRoaW5nLlxuICogXG4gKiB8TGFuZy58VGFyZ2V0fFVzZXIgaW5wdXR8YGJhc2VgfGBhY2NlbnRgfGBjYXNlYHxgdmFyaWFudGB8XG4gKiB8LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXxcbiAqIHxFTnxIaXxCeWV84p2MfOKdjHzinYx84p2MfFxuICogfEVOfEhpfEhpfOKchXzinIV84pyFfOKchXxcbiAqIHxFTnxIaXzvvKjvvYl84pyFfOKchXzinIV84p2MfFxuICogfEVOfEhpfGhpfOKchXzinIV84p2MfOKdjHxcbiAqIHxFTnxIaXxIw6984pyFfOKdjHzinYx84p2MfFxuICogfEVOfMOlfGFhfOKdjHzinYx84p2MfOKdjHxcbiAqIHxEQXzDpXxhYXzinIV84pyFfOKchXzinYx8XG4gKiB8REF8w6V8QUF84pyFfOKchXzinYx84p2MfFxuICogfERBfMOlfEFhfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxhQXzinYx84p2MfOKdjHzinYx8XG4gKiB8RU58w6V8YXzinIV84pyFfOKdjHzinYx8XG4gKiB8REF8w6V8YXzinIV84pyFfOKdjHzinYx8XG4gKiB8SlB876qqfOedgHzinIV84pyFfOKchXzinIV8XG4gKiB8SlB844KrfO+9tnzinIV84pyFfOKchXzinIV8XG4gKiB8SlB844KrfOOBi3zinIV84pyFfOKchXzinYx8XG4gKiB8SlB844KrfOODtXzinIV84pyFfOKchXzinYx8XG4gKiB8SlB844KrfOOLlXzinIV84pyFfOKdjHzinYx8XG4gKiB8SlB844KrfOOCrHzinIV84p2MfOKdjHzinYx8XG4gKiB8SlB844KrfOWKm3zinYx84p2MfOKdjHzinYx8XG4gKiB8Wkh857SFfOe6onzinYx84p2MfOKdjHzinYx8XG4gKiBcbiAqIFxuICogKE5vdGUgdG8gc2VsZjogQXQgc29tZSBwb2ludCwgdGhpcyBmaWxlIHdpbGwgcHJvYmFibHkgYmUgbm9ybWFsaXplZFxuICogYnkgc29tZWJvZHkgYW5kIO+qqiB3aWxsIHR1cm4gYmFjayBpbnRvIOedgC4pXG4gKiBcbiAqIFVucmVsYXRlZCwgYnV0IGhleSwgdGhpcyBpcyBmdW46IHRyeSBoaWdobGlnaHRpbmcgdGhlIHNwYWNlIGJldHdlZW4gdGhlIHR3byBjaGFyYWN0ZXJzIGluIFZTIENvZGUsXG4gKiBvciBqdXN0IHR5cGluZyBhIGNoYXJhY3RlciBpbiBiZXR3ZWVuIHRoZW0uIFdoYXQncyB1cCB3aXRoIHRoaXM/XG4gKiDvqqog552AXG4gKi9cbmNvbnN0IF9kdW1teTogYW55ID0gbnVsbDtcblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQ+IHtcbiAgICBfZT86IFRhYmJhYmxlQ2hpbGRFbGVtZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSBmcm9tVXNlckludGVyYWN0aW9uIFdoZXRoZXIgdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoaXMgY2hpbGQgYXMgYSBtZWFucyBvZiBuYXZpZ2F0aW5nIHRvIGl0LiAgSW4gdGhhdCB3YXMgdGhlIGNhc2UsIHRoZSBjaGlsZCBpcyBhbHNvIGZvY3VzZWQuIE90aGVyd2lzZSwgZm9jdXMgbW92ZXMgYXMgdGhlIGJyb3dzZXIgZGV0ZXJtaW5lcy5cbiAqL1xuZXhwb3J0IHR5cGUgTmF2aWdhdGVUb0luZGV4ID0gKGk6IG51bWJlciB8IG51bGwsIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHZvaWQ7XG5cblxuXG5cblxuLy8gKioqIFBhcmFtZXRlcnMgKGxpc3QsIGxpc3Qtc2luZ2xlLCBsaXN0LWNoaWxkLCBsaXN0LXNpbmdsZS1jaGlsZClcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4+IGV4dGVuZHNcbiAgICBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBNPixcbiAgICBPbWl0PFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzPENoaWxkRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhSZXR1cm5cIj4sXG4gICAgT21pdDxVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFJldHVyblwiPiB7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+LCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD4ge1xuICAgIC8vbWFuYWdlZENoaWxkUGFyYW1ldGVyczogVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIl0gJiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD5bXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCJdO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGU8Q2hpbGRFbGVtZW50PiwgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPFBhcmVudE9yQ2hpbGRFbGVtZW50PiwgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudD4sIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGUgeyB9XG5leHBvcnQgdHlwZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGE6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudD47XG5cblxuXG4vKipcbiAqIEltcGxlbWVudHMgcHJvcGVyIGtleWJvYXJkIG5hdmlnYXRpb24gZm9yIGNvbXBvbmVudHMgbGlrZSBsaXN0Ym94ZXMsIGJ1dHRvbiBncm91cHMsIG1lbnVzLCBldGMuXG4gKiBcbiAqIEluIHRoZSBkb2N1bWVudCBvcmRlciwgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSBcImZvY3VzZWRcIiBvciBcInRhYmJhYmxlXCIgZWxlbWVudCwgbWFraW5nIGl0IGFjdCBtb3JlIGxpa2Ugb25lIGNvbXBsZXRlIHVuaXQgaW4gY29tcGFyaXNvbiB0byBldmVyeXRoaW5nIGFyb3VuZCBpdC5cbiAqIE5hdmlnYXRpbmcgZm9yd2FyZHMvYmFja3dhcmRzIGNhbiBiZSBkb25lIHdpdGggdGhlIGFycm93IGtleXMsIEhvbWUvRW5kIGtleXMsIG9yIGFueSB0ZXh0IGZvciB0eXBlYWhlYWQgdG8gZm9jdXMgdGhlIG5leHQgaXRlbSB0aGF0IG1hdGNoZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+Pih7XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAuLi5fdm9pZDFcbn06IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPik6IFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50PiB7XG5cbiAgICBjb25zdCBydGlyID0gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50LCBNPih7IG1hbmFnZWRDaGlsZHJlblJldHVybiwgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzIH0pO1xuICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXhSZXR1cm4gfSA9IHJ0aXI7XG4gICAgY29uc3QgdG5yID0gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50Pih7IHJvdmluZ1RhYkluZGV4UmV0dXJuLCB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycywgfSk7XG4gICAgY29uc3QgbG5yID0gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50Pih7IHJvdmluZ1RhYkluZGV4UmV0dXJuLCBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgfSk7XG5cbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubG5yLFxuICAgICAgICAuLi50bnIsXG4gICAgICAgIC4uLnJ0aXJcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0LFxuICAgIC8vdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgIC4uLl92b2lkMlxufTogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50Pik6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudD4ge1xuXG4gICAgY29uc3QgcnRpY3IgPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudD4oeyByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCwgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfSk7XG4gICAgY29uc3QgeyB0ZXh0Q29udGVudFJldHVybiB9ID0gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudD4oeyByZWZFbGVtZW50UmV0dXJuLCB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0LCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB0ZXh0Q29udGVudFBhcmFtZXRlcnMgfSk7XG5cbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDIpO1xuLy8gICAgYXNzZXJ0RW1wdHlPYmplY3QoX3ZvaWQ1KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRleHRDb250ZW50UmV0dXJuLFxuICAgICAgICAuLi5ydGljclxuICAgIH1cbn0iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgYXNzZXJ0RW1wdHlPYmplY3QsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCBQYXNzaXZlU3RhdGVVcGRhdGVyLCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZU9iamVjdCB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlTGlzdE5hdmlnYXRpb24sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGUsIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWxpc3QtbmF2aWdhdGlvbi1wYXJ0aWFsXCI7XG5pbXBvcnQgeyBTZXRUYWJiYWJsZUluZGV4IH0gZnJvbSBcIi4vdXNlLXJvdmluZy10YWJpbmRleFwiO1xuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHM8UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHI6IFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQ+LCAuLi5vdGhlclByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPclJvd0VsZW1lbnQ+W10pIHtcbiAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25Qcm9wczxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQ+KHIsIC4uLm90aGVyUHJvcHMpXG59XG5leHBvcnQgZnVuY3Rpb24gdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wczxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PihyOiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCAuLi5vdGhlclByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PltdKSB7XG4gICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+KHIuYXNQYXJlbnRSb3dPZkNlbGxzLCAuLi51c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHM8Um93RWxlbWVudD4oci5hc0NoaWxkUm93T2ZUYWJsZSwgLi4ub3RoZXJQcm9wcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ocjogVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZTxDZWxsRWxlbWVudD4sIC4uLm90aGVyUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGxFbGVtZW50PltdKSB7XG4gICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wczxDZWxsRWxlbWVudD4ociwgLi4ub3RoZXJQcm9wcyk7XG59Ki9cblxuXG5leHBvcnQgaW50ZXJmYWNlIEdyaWRDaGlsZFJvd0luZm88Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIF9DZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZEluZm88Um93RWxlbWVudD4geyBzZXRUYWJiYWJsZUNvbHVtbkluZGV4OiBTZXRUYWJiYWJsZUluZGV4IH1cbmV4cG9ydCBpbnRlcmZhY2UgR3JpZENoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvPENlbGxFbGVtZW50PiB7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIEdyaWRDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+PiBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBSb3dFbGVtZW50LCBNPiwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPiB7XG4gICAgZ3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgIG9uVGFiYmFibGVDb2x1bW5DaGFuZ2U6IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPG51bWJlciB8IG51bGwsIEV2ZW50PiB8IG51bGw7XG4gICAgfTtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogT21pdDxVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50T3JDaGlsZEVsZW1lbnQsIFJvd0VsZW1lbnQsIE0+W1wibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIl0sIFwibmF2aWdhdGlvbkRpcmVjdGlvblwiPlxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgIFJNIGV4dGVuZHMgR3JpZENoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZENoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQ+IHtcbiAgICBncmlkTmF2aWdhdGlvblJvd0NvbnRleHQ6IFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPltcInJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzXCJdW1wiZ3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0XCJdXG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfUk0gZXh0ZW5kcyBHcmlkQ2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkQ2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+IHtcbiAgICByb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyczogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Um93RWxlbWVudD4gJiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogUGljazxVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPENNPltcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiXSwgXCJnZXRDaGlsZHJlblwiPjtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0OiB7XG4gICAgICAgICAgICBfcj86IFJvd0VsZW1lbnQ7XG4gICAgICAgICAgICBfYz86IENlbGxFbGVtZW50O1xuICAgICAgICAgXG4gICAgICAgICAgICBncmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZVJvdzogU2V0VGFiYmFibGVJbmRleDsgLy8gKHVwZGF0ZXI6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAgICAgICAgICAgICBnZXRDdXJyZW50VGFiYmFibGVDb2x1bW46ICgpID0+IChudW1iZXIgfCBudWxsKTtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VGFiYmFibGVDb2x1bW46IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbCwgRXZlbnQ+O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByb3dBc1BhcmVudE9mQ2VsbHNQYXJhbWV0ZXJzOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgQ00+LCBcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+ICYge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogT21pdDxVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIENNPltcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCJdLCBcIm5hdmlnYXRpb25EaXJlY3Rpb25cIj5cbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGU8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHJvd0FzQ2hpbGRPZkdyaWRSZXR1cm46IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPFJvd0VsZW1lbnQ+ICYge1xuICAgICAgICBncmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM6IFBpY2s8R3JpZENoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFwiZm9jdXNTZWxmXCIgfCBcInNldFRhYmJhYmxlQ29sdW1uSW5kZXhcIj47XG4gICAgfTtcbiAgICByb3dBc1BhcmVudE9mQ2VsbHNSZXR1cm46IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFJldHVyblwiPiAmIHtcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm46IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PltcInJvdmluZ1RhYkluZGV4UmV0dXJuXCJdLCBcImZvY3VzU2VsZlwiPjtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dDogVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD5bXCJncmlkTmF2aWdhdGlvbkNlbGxDb250ZXh0XCJdO1xuICAgIH07XG59XG5cblxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzPF9Sb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiB7XG4gICAgZ3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczoge1xuICAgICAgICBjb2xTcGFuOiBudW1iZXI7XG4gICAgfVxuICAgIGdyaWROYXZpZ2F0aW9uQ2VsbENvbnRleHQ6IHtcbiAgICAgICAgX2M/OiBDZWxsRWxlbWVudDtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZ2V0Um93SW5kZXg6ICgpID0+IG51bWJlcjtcbiAgICAgICAgICAgIHNldFRhYmJhYmxlUm93OiAgU2V0VGFiYmFibGVJbmRleDsgLy8odTogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xuICAgICAgICAgICAgZ2V0Q3VycmVudFRhYmJhYmxlQ29sdW1uOiAoKSA9PiAobnVtYmVyIHwgbnVsbCk7XG4gICAgICAgICAgICBzZXRDdXJyZW50VGFiYmFibGVDb2x1bW46IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbCwgRXZlbnQ+O1xuICAgICAgICAgICAgc2V0VGFiYmFibGVDZWxsOiBTZXRUYWJiYWJsZUluZGV4OyAvLyh1cGRhdGVyOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0sIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHZvaWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPENlbGxFbGVtZW50PiB7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgR3JpZENoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZENoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pih7XG4gICAgZ3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IG9uVGFiYmFibGVDb2x1bW5DaGFuZ2UsIC4uLnZvaWQzIH0sXG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IG9uVGFiYmFibGVJbmRleENoYW5nZSwgLi4ucm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzIH0sXG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIC4uLl92b2lkMlxufTogVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPik6IFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+IHtcbiAgICBjb25zdCB7IGdldENoaWxkcmVuIH0gPSBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm47XG4gICAgY29uc3QgeyBpbml0aWFsbHlUYWJiZWRJbmRleCB9ID0gcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzXG5cbiAgICBjb25zdCBbZ2V0Q3VycmVudFRhYmJhYmxlQ29sdW1uLCBzZXRDdXJyZW50VGFiYmFibGVDb2x1bW5dID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGwsIEV2ZW50PihvblRhYmJhYmxlQ29sdW1uQ2hhbmdlLCB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7IHJldHVybiAoaW5pdGlhbGx5VGFiYmVkSW5kZXggPz8gMCkgfSkpO1xuXG4gICAgY29uc3Qgb25UYWJiYWJsZUluZGV4Q2hhbmdlT3ZlcnJpZGUgPSB1c2VTdGFibGVDYWxsYmFjaygoaTogbnVtYmVyIHwgbnVsbCwgcDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmVhc29uOiBFdmVudCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG4gICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZT8uKGksIHAsIHJlYXNvbik7XG4gICAgICAgIGlmIChwICE9IG51bGwpXG4gICAgICAgICAgICBjaGlsZHJlbi5nZXRBdChwKT8uc2V0VGFiYmFibGVDb2x1bW5JbmRleChudWxsLCByZWFzb24sIGZhbHNlKTtcbiAgICAgICAgaWYgKGkgIT0gbnVsbClcbiAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KGkpPy5zZXRUYWJiYWJsZUNvbHVtbkluZGV4KGdldEN1cnJlbnRUYWJiYWJsZUNvbHVtbigpLCByZWFzb24sIGZhbHNlKTtcblxuICAgIH0pXG5cbiAgICBjb25zdCB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCxcbiAgICAgICAgLi4udm9pZDFcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBSTT4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsIC4uLmxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IG9uVGFiYmFibGVJbmRleENoYW5nZU92ZXJyaWRlLCAuLi5yb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1xuICAgIH0pO1xuXG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDEpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMik7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDMpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBncmlkTmF2aWdhdGlvblJvd0NvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICBncmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVSb3c6IHJvdmluZ1RhYkluZGV4UmV0dXJuLnNldFRhYmJhYmxlSW5kZXgsXG4gICAgICAgICAgICAgICAgZ2V0Q3VycmVudFRhYmJhYmxlQ29sdW1uLFxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUYWJiYWJsZUNvbHVtblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkTmF2aWdhdGlvblJvdzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50Pj4oe1xuICAgIHJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzOiB7IGdyaWROYXZpZ2F0aW9uUm93Q29udGV4dDogeyBncmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM6IHsgc2V0VGFiYmFibGVSb3csIGdldEN1cnJlbnRUYWJiYWJsZUNvbHVtbiwgc2V0Q3VycmVudFRhYmJhYmxlQ29sdW1uIH0gfSwgLi4uYXNDaGlsZFJvd09mVGFibGUgfSxcbiAgICByb3dBc1BhcmVudE9mQ2VsbHNQYXJhbWV0ZXJzOiB7IGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLCByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHsgdW50YWJiYWJsZSwgLi4ucm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzIH0sIC4uLmFzUGFyZW50Um93T2ZDZWxsc1AgfSxcbiAgICAuLi5fdm9pZDFcbn06IFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPik6IFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4ge1xuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH0gfSA9IGFzQ2hpbGRSb3dPZlRhYmxlO1xuICAgIGNvbnN0IGdldEluZGV4ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gYXNDaGlsZFJvd09mVGFibGUubWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleCB9KVxuICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBSb3dFbGVtZW50KSA9PiB7XG4gICAgICAgIGxldCBpbmRleCA9IChnZXRDdXJyZW50VGFiYmFibGVDb2x1bW4oKSA/PyAwKTtcbiAgICAgICAgbGV0IGNoaWxkID0gZ2V0Q2hpbGRyZW4oKS5nZXRBdChpbmRleCk7XG4gICAgICAgIHdoaWxlICgoIWNoaWxkKSAmJiBpbmRleCA+IDApIHtcbiAgICAgICAgICAgIC0taW5kZXg7XG4gICAgICAgICAgICBjaGlsZCA9IGdldENoaWxkcmVuKCkuZ2V0QXQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgY29uc3QgZSA9IGNoaWxkLmdldEVsZW1lbnQoKSE7XG4gICAgICAgICAgICBjaGlsZC5mb2N1c1NlbGYoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoZSBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50KT8uZm9jdXM/LigpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgbG5jciA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Um93RWxlbWVudD4oYXNDaGlsZFJvd09mVGFibGUpO1xuICAgIGNvbnN0IGxuciA9IHVzZUxpc3ROYXZpZ2F0aW9uPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDTT4oeyAuLi5hc1BhcmVudFJvd09mQ2VsbHNQLCByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHsgdW50YWJiYWJsZTogdW50YWJiYWJsZSB8fCAhbG5jci5yb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLnRhYmJhYmxlLCAuLi5yb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMgfSwgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgbmF2aWdhdGlvbkRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIsIC4uLmxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzIH0gfSk7XG5cblxuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMSk7XG5cbiAgICBjb25zdCB7IHJvdmluZ1RhYkluZGV4UmV0dXJuOiB7IHNldFRhYmJhYmxlSW5kZXggfSxyb3ZpbmdUYWJJbmRleFJldHVybiwgbGluZWFyTmF2aWdhdGlvblJldHVybiwgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4gfSA9IGxucjtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm93QXNDaGlsZE9mR3JpZFJldHVybjogeyBncmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM6IHsgZm9jdXNTZWxmLCBzZXRUYWJiYWJsZUNvbHVtbkluZGV4OiBzZXRUYWJiYWJsZUluZGV4IH0sIC4uLmxuY3IsIH0sXG4gICAgICAgIHJvd0FzUGFyZW50T2ZDZWxsc1JldHVybjoge1xuICAgICAgICAgICAgLi4ubG5yICxcbiAgICAgICAgICAgIGdyaWROYXZpZ2F0aW9uQ2VsbENvbnRleHQ6dXNlU3RhYmxlT2JqZWN0ICh7XG4gICAgICAgICAgICAgICAgZ3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVSb3csXG4gICAgICAgICAgICAgICAgICAgIGdldFJvd0luZGV4OiBnZXRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q3VycmVudFRhYmJhYmxlQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50VGFiYmFibGVDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlQ2VsbDogc2V0VGFiYmFibGVJbmRleFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuLFxuXG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlR3JpZE5hdmlnYXRpb25DZWxsPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuLy8gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBoaWRkZW4sIGluZGV4LCAuLi52b2lkMyB9LFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0LFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgLy90eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgcmVmRWxlbWVudFJldHVybixcbiAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnMsXG4gICAgZ3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczoge1xuICAgICAgICBjb2xTcGFuXG4gICAgfSxcbiAgICBncmlkTmF2aWdhdGlvbkNlbGxDb250ZXh0OiB7XG4gICAgICAgIGdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGdldFJvd0luZGV4LFxuICAgICAgICAgICAgc2V0VGFiYmFibGVSb3csXG4gICAgICAgICAgICBnZXRDdXJyZW50VGFiYmFibGVDb2x1bW46IF9nZXRDdXJyZW50Q29sdW1uLFxuICAgICAgICAgICAgc2V0Q3VycmVudFRhYmJhYmxlQ29sdW1uLFxuICAgICAgICAgICAgc2V0VGFiYmFibGVDZWxsXG4gICAgICAgIH1cbiAgICB9LFxuICAgIC4uLl92b2lkMVxufTogVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxhbnksIENlbGxFbGVtZW50Pik6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQ+IHtcbiAgICBjb25zdCB7IGluZGV4IH0gPSBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzO1xuICAgIGNvbnN0IHtcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczogeyBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkOiBvY2ZpYzEgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybixcbiAgICAgICAgdGV4dENvbnRlbnRSZXR1cm4sXG4gICAgICAgIC4uLnZvaWQyXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2VsbEVsZW1lbnQ+KHtcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0LFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnMsXG4gICAgICAgIC8vdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgcmVmRWxlbWVudFJldHVyblxuICAgIH0pO1xuXG4gICAgYXNzZXJ0RW1wdHlPYmplY3QoX3ZvaWQxKTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkMik7XG4vLyAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkMyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLFxuICAgICAgICB0ZXh0Q29udGVudFJldHVybixcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQsIHByZXYsIGUpID0+IHtcbiAgICAgICAgICAgICAgICBvY2ZpYzE/Lihmb2N1c2VkLCBwcmV2LCBlKTtcblxuICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlUm93KGdldFJvd0luZGV4KCksIGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFRhYmJhYmxlQ29sdW1uKGluZGV4LCBlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVDZWxsKChwcmV2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldiAhPSBudWxsICYmIChwcmV2IDwgaW5kZXggfHwgcHJldiA+IGluZGV4ICsgY29sU3BhbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfSwgZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgfVxufSIsIlxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBVc2VQcmVzc1BhcmFtZXRlcnMgfSBmcm9tIFwiLi4vY29tcG9uZW50LXVzZS91c2UtcHJlc3NcIjtcbmltcG9ydCB7IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlLCBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwiLi4vb2JzZXJ2ZXJzL3VzZS1jaGlsZHJlbi1oYXZlLWZvY3VzXCI7XG5pbXBvcnQgeyB1c2VDaGlsZHJlbkZsYWcsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCBQYXNzaXZlU3RhdGVVcGRhdGVyLCB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvLCBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XG4vL2ltcG9ydCB7IHVzZVByZXNzLCBVc2VQcmVzc1JldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcHJlc3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciwgdXNlU3RhYmxlT2JqZWN0IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhdGVcIjtcblxuLypcbmV4cG9ydCBmdW5jdGlvbiB1c2VTaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PihyOiBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPEU+LCAuLi5vdGhlclByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltdKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSB7XG4gICAgcmV0dXJuIFtyLnNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuLnByb3BzVW5zdGFibGUsIC4uLm90aGVyUHJvcHNdO1xufSovXG5cbi8qXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNpbmdsZVNlbGVjdGlvbkNvbnRleHQge1xuICAgIHNpbmdsZVNlbGVjdGlvblJldHVybjogVXNlU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm9bXCJzaW5nbGVTZWxlY3Rpb25SZXR1cm5cIl07XG59Ki9cblxuLyoqIEFueXRoaW5nIHRoYXQncyBzZWxlY3RhYmxlIG11c3QgYmUgdGFiYmFibGUsIHNvIHdlIERPIHVzZSByb3Zpbmd0YWJpbmRleCBpbnN0ZWFkIG9mIGp1c3QgbWFuYWdlZGNoaWxkcmVuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGFibGVDaGlsZEluZm88RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm88RT4ge1xuICAgIHNlbGVjdGVkOiBib29sZWFuO1xuICAgIGdldFNlbGVjdGVkKCk6IGJvb2xlYW47XG4gICAgc2V0TG9jYWxTZWxlY3RlZChzZWxlY3RlZDogYm9vbGVhbik6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHNpbWlsYXIgdG8gYGhpZGRlbmAgZm9yIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGJ1dCBmb3Igc2VsZWN0aW9uLlxuICAgICAqIFxuICAgICAqIERpc2FibGVzIHNlbGVjdGluZyB0aGlzIGNoaWxkLiBCZWluZyBgaGlkZGVuYCBtdXN0IGltcGx5IGJlaW5nIGBkaXNhYmxlZGAsIGJ1dCB5b3UgY2FuIG9mIGNvdXJzZSBoYXZlIHNvbWV0aGluZyB0aGF0J3MgZGlzYWJsZWQgKHVuc2VsZWN0YWJsZSkgYnV0IG5vdCBoaWRkZW4gKHVudGFiYmFibGUpLlxuICAgICAqL1xuICAgIGRpc2FibGVkOiBib29sZWFuO1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IFBpY2s8VXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxTZWxlY3RhYmxlQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdLCBcImdldENoaWxkcmVuXCI+O1xuICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuOiBQaWNrPFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+W1wicm92aW5nVGFiSW5kZXhSZXR1cm5cIl0sIFwic2V0VGFiYmFibGVJbmRleFwiPlxuICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgaW1wZXJhdGl2ZSwgYXMgb3Bwb3NlZCB0byBkZWNsYXJhdGl2ZSwgXG4gICAgICAgICAqIHRvIHNhdmUgb24gcmUtcmVuZGVyaW5nIHRoZSBwYXJlbnQgd2hlbmV2ZXIgdGhlIHNlbGVjdGVkIGluZGV4IGNoYW5nZXMuXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsbHlTZWxlY3RlZEluZGV4OiBudW1iZXIgfCBudWxsO1xuICAgICAgICAvL3NlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiBhIGNoaWxkIGlzIHNlbGVjdGVkICh2aWEgYSBwcmVzcyBvciBvdGhlciBtZXRob2QpLlxuICAgICAgICAgKiBcbiAgICAgICAgICogYHNpbmdsZVNlbGVjdGlvblJldHVybmAgcmV0dXJucyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbmFtZSB0aGF0IGNhbiBiZSBwbHVnZ2VkIGluIGhlcmVcbiAgICAgICAgICogdG8gbWFrZSB0aGlzIGNvbXBvbmVudCBpbXBlcmF0aXZlLCBvciB5b3UgY2FuIHVzZSBgdXNlRWZmZWN0YCB0byBzZXQgc29tZSBzdGF0ZVxuICAgICAgICAgKiBvbiB5b3VyIGVuZCB0aGF0IGRvZXMgc29tZXRoaW5nIGVsc2UuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBJbiBnZW5lcmFsLCB0aGlzIHNob3VsZCBvbmx5IGJlIGBudWxsYCB3aGVuIHNpbmdsZSBzZWxlY3Rpb24gaXMgZW50aXJlbHkgZGlzYWJsZWQuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBJbiBhbnkgY2FzZSwgKipNVVNUKiogYmUgc3RhYmxlISFcbiAgICAgICAgICovXG4gICAgICAgIHNldFNlbGVjdGVkSW5kZXg6IG51bGwgfCBQYXNzaXZlU3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGwsIEV2ZW50PjtcblxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICAvL21hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IFBpY2s8VXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxTZWxlY3RhYmxlQ2hpbGRJbmZvPEU+LCBuZXZlcj5bXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCJdLCBcImluZGV4XCIgfCBcImRpc2FibGVkXCI+O1xuICAgIHNpbmdsZVNlbGVjdGlvbkNvbnRleHQ6IFVzZVNpbmdsZVNlbGVjdGlvblJldHVyblR5cGU8RT5bXCJzaW5nbGVTZWxlY3Rpb25Db250ZXh0XCJdO1xuICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczoge1xuICAgICAgICBzZWxlY3Rpb25Nb2RlOiBcImZvY3VzXCIgfCBcImFjdGl2YXRpb25cIiB8IFwiZGlzYWJsZWRcIjtcbiAgICAgICAgYXJpYVByb3BOYW1lOiBgYXJpYS0ke1wicHJlc3NlZFwiIHwgXCJzZWxlY3RlZFwiIHwgXCJjaGVja2VkXCJ9YCB8IG51bGw7XG4gICAgfSAmIFBpY2s8U2VsZWN0YWJsZUNoaWxkSW5mbzxFPiwgXCJkaXNhYmxlZFwiPjtcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBQaWNrPFNlbGVjdGFibGVDaGlsZEluZm88RT4sIFwiaW5kZXhcIj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlPEU+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVybjoge1xuICAgICAgICAvLyBUaGVzZSB0d28gYXJlIGFscmVhZHkgYXZhaWxhYmxlIGFzIG1hbmFnZWRDaGlsZCBpbmZvLFxuICAgICAgICAvLyBidXQgd2UncmUga2VlcGluZyB0aGVtIGJlY2F1c2UgUlRJIGRvZXMgdGhlIHNhbWUgdGhpbmcsIGFuZCBpdCdzIGNvbnZlbmllbnQuXG4gICAgICAgIHNlbGVjdGVkOiBib29sZWFuLFxuICAgICAgICBnZXRTZWxlY3RlZCgpOiBib29sZWFuO1xuICAgICAgICAvLyBVc2VkIHRvIHByb2dyYW1tYXRpY2FsbHkgc2V0IHRoaXMgYXMgdGhlIHNlbGVjdGVkIGVsZW1lbnQ7XG4gICAgICAgIC8vIGl0IHJlcXVlc3RzIHRoZSBwYXJlbnQgdG8gYWN0dWFsbHkgY2hhbmdlIHRoZSBudW1lcmljIGluZGV4IHRvIHRoaXMgb25lJ3MuXG4gICAgICAgIHNldFRoaXNPbmVTZWxlY3RlZDogKGV2ZW50OiBFdmVudCkgPT4gdm9pZDtcbiAgICAgICAgcHJvcHNVbnN0YWJsZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG4gICAgfVxuICAgIC8vcmVmRWxlbWVudFBhcmFtZXRlcnM6IFJlcXVpcmVkPFBpY2s8VXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8RT5bXCJyZWZFbGVtZW50UGFyYW1ldGVyc1wiXSwgXCJvbkVsZW1lbnRDaGFuZ2VcIj4+O1xuICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IFBpY2s8U2VsZWN0YWJsZUNoaWxkSW5mbzxFPiwgXCJzZXRMb2NhbFNlbGVjdGVkXCI+O1xuICAgIC8vbWFuYWdlZENoaWxkUGFyYW1ldGVyczogUGljazxVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPFNlbGVjdGFibGVDaGlsZEluZm88RT4sIG5ldmVyPltcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIl0sIFwic2VsZWN0ZWRcIiB8IFwic2V0U2VsZWN0ZWRcIiB8IFwiZ2V0U2VsZWN0ZWRcIj47XG4gICAgcHJlc3NQYXJhbWV0ZXJzOiBQaWNrPFVzZVByZXNzUGFyYW1ldGVyczxFPltcInByZXNzUGFyYW1ldGVyc1wiXSwgXCJvblByZXNzU3luY1wiPjtcbn1cblxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPEU+IHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnRlcm5hbGx5IHVwZGF0ZXMgdGhlIHNlbGVjdGVkIGluZGV4IHRvIHRoZSBvbmUgeW91IHByb3ZpZGUsXG4gICAgICAgICAqIGFuZCB0ZWxscyB0aGUgcmVsZXZhbnQgY2hpbGRyZW4gdGhhdCB0aGV5IGFyZS9hcmUgbm90IHNlbGVjdGVkLlxuICAgICAgICAgKiBcbiAgICAgICAgICogSWYgeW91IGFyZSBjcmVhdGluZyBhbiBpbXBlcmF0aXZlIGNvbXBvbmVudCwgdGhpcyBpcyB3aGF0IGhvdyB5b3UgY2FuIGZvcmNlIHRoZSB2YWx1ZSB0byBjaGFuZ2UgaW4gcmVzcG9uc2UgdG8gc29tZXRoaW5nLlxuICAgICAgICAgKiBcbiAgICAgICAgICogSWYgeW91IGFyZSBjcmVhdGluZyBhIGRlY2xhcmF0aXZlIGNvbXBvbmVudCwgdGhpcyBpcyB3aGF0IHlvdSBjYWxsIGluIGB1c2VFZmZlY3RgIHdoZW4geW91ciBgc2VsZWN0ZWRJbmRleGAgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHNldFNlbGVjdGVkSW5kZXg6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbCwgRXZlbnQ+O1xuICAgICAgICBnZXRTZWxlY3RlZEluZGV4KCk6IG51bWJlciB8IG51bGw7XG4gICAgfVxuICAgIHNpbmdsZVNlbGVjdGlvbkNvbnRleHQ6IHsgc2V0U2VsZWN0ZWRJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsLCBFdmVudD4gfCBudWxsOyBnZXRTZWxlY3RlZEluZGV4KCk6IG51bWJlciB8IG51bGw7IH1cbiAgICBjaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnM6IFBpY2s8VXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD5bXCJjaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnNcIl0sIFwib25Db21wb3NpdGVGb2N1c0NoYW5nZVwiPlxufVxuXG5cblxuLy9leHBvcnQgdHlwZSBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZDxFIGV4dGVuZHMgRWxlbWVudD4gPSAoYTogVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEU+KSA9PiBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8RT47XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTaW5nbGVTZWxlY3Rpb248Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogeyBnZXRDaGlsZHJlbiB9LFxuICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuOiB7IHNldFRhYmJhYmxlSW5kZXggfSxcbiAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzOiB7IHNldFNlbGVjdGVkSW5kZXg6IHNldFNlbGVjdGVkSW5kZXhFeHRlcm5hbCwgaW5pdGlhbGx5U2VsZWN0ZWRJbmRleCB9XG59OiBVc2VTaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPENoaWxkRWxlbWVudD4pOiBVc2VTaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlPENoaWxkRWxlbWVudD4ge1xuICAgIHR5cGUgUiA9IEV2ZW50Oy8vaC5KU1guVGFyZ2V0ZWRFdmVudDxDaGlsZEVsZW1lbnQ+O1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVNpbmdsZVNlbGVjdGlvblwiLCBzZXRTZWxlY3RlZEluZGV4RXh0ZXJuYWwpO1xuXG4gICAgY29uc3QgZ2V0U2VsZWN0ZWRBdCA9IHVzZUNhbGxiYWNrKChtOiBTZWxlY3RhYmxlQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4pID0+IHsgcmV0dXJuIG0uZ2V0U2VsZWN0ZWQoKTsgfSwgW10pO1xuICAgIGNvbnN0IHNldFNlbGVjdGVkQXQgPSB1c2VDYWxsYmFjaygobTogU2VsZWN0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+LCB0OiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmIChtLmhpZGRlbikge1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIG0uc2V0TG9jYWxTZWxlY3RlZCh0KTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgaXNTZWxlY3RlZFZhbGlkID0gdXNlQ2FsbGJhY2soKG06IFNlbGVjdGFibGVDaGlsZEluZm88Q2hpbGRFbGVtZW50PikgPT4geyByZXR1cm4gIW0uaGlkZGVuOyB9LCBbXSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGNoYW5nZUluZGV4OiBzZXRTZWxlY3RlZEluZGV4SW50ZXJuYWwsXG4gICAgICAgIGdldEN1cnJlbnRJbmRleDogZ2V0U2VsZWN0ZWRJbmRleFxuICAgIH0gPSB1c2VDaGlsZHJlbkZsYWc8U2VsZWN0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+LCBSPih7XG4gICAgICAgIGdldENoaWxkcmVuLFxuICAgICAgICBvbkluZGV4Q2hhbmdlOiBudWxsLFxuICAgICAgICBpbml0aWFsSW5kZXg6IGluaXRpYWxseVNlbGVjdGVkSW5kZXgsXG4gICAgICAgIGdldEF0OiBnZXRTZWxlY3RlZEF0LFxuICAgICAgICBzZXRBdDogc2V0U2VsZWN0ZWRBdCxcbiAgICAgICAgaXNWYWxpZDogaXNTZWxlY3RlZFZhbGlkLFxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybjogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIGdldFNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4OiBzZXRTZWxlY3RlZEluZGV4SW50ZXJuYWxcbiAgICAgICAgfSksXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICBnZXRTZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgc2V0U2VsZWN0ZWRJbmRleDogc2V0U2VsZWN0ZWRJbmRleEV4dGVybmFsXG4gICAgICAgIH0pLFxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIG9uQ29tcG9zaXRlRm9jdXNDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrKChhbnlGb2N1c2VkLCBwcmV2LCByZWFzb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWFueUZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IGdldFNlbGVjdGVkSW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoc2VsZWN0ZWRJbmRleCwgcmVhc29uLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oYXJnczogVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD4pOiBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50PiB7XG4gICAgdHlwZSBSID0gRXZlbnQ7Ly9oLkpTWC5UYXJnZXRlZEV2ZW50PENoaWxkRWxlbWVudD47XG4gICAgY29uc3Qge1xuXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNvbnRleHQ6IHsgZ2V0U2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleDogc2V0U2VsZWN0ZWRJbmRleEV4dGVybmFsIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczogeyBhcmlhUHJvcE5hbWUsIHNlbGVjdGlvbk1vZGUsIGRpc2FibGVkIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfVxuICAgIH0gPSBhcmdzO1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRcIiwgZ2V0U2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleEV4dGVybmFsKTtcbiAgICBjb25zdCBnZXREaXNhYmxlZCA9IHVzZVN0YWJsZUdldHRlcihkaXNhYmxlZCk7XG5cbiAgICBjb25zdCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkLCBnZXRTZWxlY3RlZF0gPSB1c2VTdGF0ZShnZXRTZWxlY3RlZEluZGV4KCkgPT0gaW5kZXgpO1xuXG4gICAvLyBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUdldHRlcihpbmRleCk7XG5cbiAgICBjb25zdCBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkID0gdXNlU3RhYmxlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8Ym9vbGVhbiwgUj4+KChmb2N1c2VkLCBfcHJldiwgZSkgPT4ge1xuICAgICAgICBpZiAoc2VsZWN0aW9uTW9kZSA9PSAnZm9jdXMnICYmIGZvY3VzZWQpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXhFeHRlcm5hbD8uKGluZGV4LCBlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25QcmVzc1N5bmMgPSB1c2VTdGFibGVDYWxsYmFjaygoKGU6IEV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghZGlzYWJsZWQpXG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4RXh0ZXJuYWw/LihpbmRleCwgZSBhcyBSKTtcbiAgICB9KSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvL21hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgc2VsZWN0ZWQsIHNldFNlbGVjdGVkLCBnZXRTZWxlY3RlZCwgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBzZXRMb2NhbFNlbGVjdGVkOiBzZXRTZWxlY3RlZCB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVybjoge1xuICAgICAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgICAgICBzZXRUaGlzT25lU2VsZWN0ZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCFnZXREaXNhYmxlZCgpKTtcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4RXh0ZXJuYWw/LihpbmRleCwgZXZlbnQgYXMgUik7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdldFNlbGVjdGVkLFxuICAgICAgICAgICAgcHJvcHNVbnN0YWJsZTogYXJpYVByb3BOYW1lID09IG51bGwgPyB7fSA6IHsgW2FyaWFQcm9wTmFtZSBhcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+XTogKHNlbGVjdGVkID8/IGZhbHNlKS50b1N0cmluZygpIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJlc3NQYXJhbWV0ZXJzOiB7IG9uUHJlc3NTeW5jIH0sXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZCB9XG4gICAgfVxufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTaW5nbGVTZWxlY3Rpb25EZWNsYXJhdGl2ZVBhcmFtZXRlcnMge1xuICAgIHNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlUGFyYW1ldGVyczogeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfCBudWxsIH1cbiAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm46IFBpY2s8VXNlU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZTxhbnk+W1wic2luZ2xlU2VsZWN0aW9uUmV0dXJuXCJdLCBcInNldFNlbGVjdGVkSW5kZXhcIj47XG59XG5cbmV4cG9ydCB0eXBlIE1ha2VTaW5nbGVTZWxlY3Rpb25EZWNsYXJhdGl2ZVBhcmFtZXRlcnM8UD4gPSBPbWl0PFAsIFwic2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyc1wiPiAmIFVzZVNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlUGFyYW1ldGVycztcbmV4cG9ydCB0eXBlIE1ha2VTaW5nbGVTZWxlY3Rpb25EZWNsYXJhdGl2ZVJldHVyblR5cGU8Uj4gPSBPbWl0PFIsIFwic2luZ2xlU2VsZWN0aW9uUmV0dXJuXCI+O1xuXG4vKipcbiAqIExldCdzIGZhY2UgaXQsIGRlY2xhcmF0aXZlIGlzIG5pY2VyIHRvIHVzZSB0aGFuIGltcGVyYXRpdmUsIHNvIHRoaXMgaXMgYSBzaG9ydGN1dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlKHsgc2luZ2xlU2VsZWN0aW9uUmV0dXJuOiB7IHNldFNlbGVjdGVkSW5kZXg6IHNldFNlbGVjdGVkSW5kZXhJbnRlcm5hbCB9LCBzaW5nbGVTZWxlY3Rpb25EZWNsYXJhdGl2ZVBhcmFtZXRlcnM6IHsgc2VsZWN0ZWRJbmRleCB9IH06IFVzZVNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlUGFyYW1ldGVycykge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldFNlbGVjdGVkSW5kZXhJbnRlcm5hbChzZWxlY3RlZEluZGV4KTtcbiAgICB9LCBbc2VsZWN0ZWRJbmRleF0pO1xufVxuXG5cbiIsImltcG9ydCB7IEdyaWRDaGlsZENlbGxJbmZvIGFzIGdjY2ksIEdyaWRDaGlsZFJvd0luZm8gYXMgZ2NyaSwgdXNlR3JpZE5hdmlnYXRpb24sIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCwgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZSwgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGUsIHVzZUdyaWROYXZpZ2F0aW9uUm93LCBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1ncmlkLW5hdmlnYXRpb24tcGFydGlhbFwiO1xuaW1wb3J0IHsgU2VsZWN0YWJsZUNoaWxkSW5mbywgdXNlU2luZ2xlU2VsZWN0aW9uLCB1c2VTaW5nbGVTZWxlY3Rpb25DaGlsZCwgVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGUsIFVzZVNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsIFVzZVNpbmdsZVNlbGVjdGlvblJldHVyblR5cGUgfSBmcm9tIFwiLi91c2Utc2luZ2xlLXNlbGVjdGlvblwiO1xuaW1wb3J0IHsgYXNzZXJ0RW1wdHlPYmplY3QgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuLyoqXG4gKiBMaXN0IG5hdmlnYXRpb24gZ2V0cyBzaW5nbGUgc2VsZWN0aW9uLCBzbyBncmlkIG5hdmlnYXRpb24gZG9lcyB0b28uXG4gKiBcbiAqIEFueSBnaXZlbiByb3cgb2YgdGhlIGdyaWQgY2FuIGJlIHNlbGVjdGVkLCBha2luIHRvIGl0IGJlaW5nIGEgc2luZ2xlIHNlbGVjdCBsaXN0IGJ1dCB3aXRoIG9wdGlvbnMgdGhhdCBjYW4gYmUgbGVmdC9yaWdodCBhcnJvd2VkIHRvLlxuICogXG4gKiBIaWdobHkgcmVjb21tZW5kZWQgdG8gbWFrZSB0aGUgYHNlbGVjdGlvbk1vZGVgICpub3QqIGJlIGBcImZvY3VzXCJgLCBidXQgaXQncyB1cCB0byB5b3UsIHVsdGltYXRlbHkuXG4gKi9cbmNvbnN0IF9kdW1teSA9IDA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JpZFNpbmdsZVNlbGVjdENoaWxkUm93SW5mbzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIGdjcmk8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBTZWxlY3RhYmxlQ2hpbGRJbmZvPFJvd0VsZW1lbnQ+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgZ2NjaTxDZWxsRWxlbWVudD4ge1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdENoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIE0+LCBPbWl0PFVzZVNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8Um93RWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhSZXR1cm5cIj4ge1xuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIE0+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdICYgVXNlU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxSb3dFbGVtZW50PltcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiXTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdENoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdENoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+LCBVc2VTaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlPFJvd0VsZW1lbnQ+IHtcbiAgICAvLyBncmlkTmF2aWdhdGlvblJvd0NvbnRleHQ6IFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBhbnksIGFueSwgYW55PltcInJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzXCJdW1wiZ3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0XCJdXG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUm93UGFyYW1ldGVyczxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+IHtcbiAgICByb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyczogVXNlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBfUk0sIENNPltcInJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzXCJdICYgVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPFJvd0VsZW1lbnQ+O1xuICAgIHJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnM6IFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgX1JNLCBDTT5bXCJyb3dBc1BhcmVudE9mQ2VsbHNQYXJhbWV0ZXJzXCJdO1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Sb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICByb3dBc0NoaWxkT2ZHcmlkUmV0dXJuOiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+W1wicm93QXNDaGlsZE9mR3JpZFJldHVyblwiXSAmIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZTxSb3dFbGVtZW50PjtcbiAgICByb3dBc1BhcmVudE9mQ2VsbHNSZXR1cm46IFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD5bXCJyb3dBc1BhcmVudE9mQ2VsbHNSZXR1cm5cIl1cbn1cblxuXG5cblxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2VsbFBhcmFtZXRlcnM8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DZWxsUmV0dXJuVHlwZTxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZTxDZWxsRWxlbWVudD4geyB9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50Pj4oe1xuICAgIGdyaWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsXG4gICAgLi4uX3ZvaWQyXG59OiBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0+KTogVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4ge1xuICAgIGNvbnN0IGduciA9IHVzZUdyaWROYXZpZ2F0aW9uPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4oe1xuICAgICAgICBncmlkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXhSZXR1cm4gfSA9IGducjtcblxuICAgIGNvbnN0IHNzciA9IHVzZVNpbmdsZVNlbGVjdGlvbjxSb3dFbGVtZW50Pih7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNcbiAgICB9KTtcblxuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5nbnIsXG4gICAgICAgIC4uLnNzcixcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJvdzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50Pj4oe1xuICAgIHJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzLFxuICAgIHJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnMsXG4gICAgLi4uX3ZvaWQxXG59OiBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4pOiBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHtcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogb2NmaWMyLCAuLi5fdm9pZDMgfSwgcHJlc3NQYXJhbWV0ZXJzLCBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVybiB9ID0gdXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Um93RWxlbWVudD4ocm93QXNDaGlsZE9mR3JpZFBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IHsgcm93QXNDaGlsZE9mR3JpZFJldHVybjogeyBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7IG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IG9jZmljMSwgLi4uX3ZvaWQyIH0sIGdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycywgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybiwgdGV4dENvbnRlbnRSZXR1cm4sIC4uLnZvaWQ0IH0sIHJvd0FzUGFyZW50T2ZDZWxsc1JldHVybiB9ID0gdXNlR3JpZE5hdmlnYXRpb25Sb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4oeyByb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVycywgcm93QXNQYXJlbnRPZkNlbGxzUGFyYW1ldGVycyB9KTtcbiAgICBjb25zdCBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9jZmljMj4+KChmb2N1c2VkLCBwcmV2Rm9jdXNlZCwgZSkgPT4geyBvY2ZpYzE/Lihmb2N1c2VkLCBwcmV2Rm9jdXNlZCwgZSk7IG9jZmljMj8uKGZvY3VzZWQsIHByZXZGb2N1c2VkLCBlKTsgfSlcblxuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMSk7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QoX3ZvaWQyKTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDMpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQ0KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHJvd0FzQ2hpbGRPZkdyaWRSZXR1cm46IHsgXG4gICAgICAgICAgICB0ZXh0Q29udGVudFJldHVybixcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIFxuICAgICAgICAgICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczogeyBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkIH0sIFxuICAgICAgICAgICAgZ3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzLCBcbiAgICAgICAgICAgIHByZXNzUGFyYW1ldGVycywgXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLCBcbiAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuXG4gICAgICAgICB9LFxuICAgICAgICByb3dBc1BhcmVudE9mQ2VsbHNSZXR1cm5cbiAgICB9XG5cbn1cblxuLy8gRVpcbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNlbGw8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PihwOiBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNlbGxQYXJhbWV0ZXJzPGFueSwgQ2VsbEVsZW1lbnQ+KTogVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DZWxsUmV0dXJuVHlwZTxDZWxsRWxlbWVudD4ge1xuICAgIHJldHVybiB1c2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbEVsZW1lbnQ+KHApO1xufSIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5QXJyYXk7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVJhbmRvbTtcbiIsImltcG9ydCBiYXNlUmFuZG9tIGZyb20gJy4vX2Jhc2VSYW5kb20uanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICB9XG4gIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2h1ZmZsZVNlbGY7XG4iLCJpbXBvcnQgY29weUFycmF5IGZyb20gJy4vX2NvcHlBcnJheS5qcyc7XG5pbXBvcnQgc2h1ZmZsZVNlbGYgZnJvbSAnLi9fc2h1ZmZsZVNlbGYuanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVNodWZmbGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVmFsdWVzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRpbWVzO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdExpa2U7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNBcmd1bWVudHM7XG4iLCJpbXBvcnQgYmFzZUlzQXJndW1lbnRzIGZyb20gJy4vX2Jhc2VJc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuaW1wb3J0IHN0dWJGYWxzZSBmcm9tICcuL3N0dWJGYWxzZS5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCdWZmZXI7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSW5kZXg7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5hcnk7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcbiIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcbiIsImltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlcztcbiIsImltcG9ydCBzaHVmZmxlU2VsZiBmcm9tICcuL19zaHVmZmxlU2VsZi5qcyc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJy4vdmFsdWVzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2h1ZmZsZTtcbiIsImltcG9ydCBhcnJheVNodWZmbGUgZnJvbSAnLi9fYXJyYXlTaHVmZmxlLmpzJztcbmltcG9ydCBiYXNlU2h1ZmZsZSBmcm9tICcuL19iYXNlU2h1ZmZsZS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICovXG5mdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaHVmZmxlO1xuIiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsLCB3aGVuIGNhbGxlZCwgZm9yY2UgdGhlIGNvbXBvbmVudFxuICogdGhhdCB1c2VzIHRoaXMgaG9vayB0byByZS1yZW5kZXIgaXRzZWxmLlxuICogXG4gKiBJdCdzIGEgYml0IHNtZWxseSwgc28gYmVzdCB0byB1c2Ugc3BhcmluZ2x5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gICAgY29uc3QgWywgc2V0XSA9IHVzZVN0YXRlKDApO1xuICAgIHJldHVybiB1c2VSZWYoKCkgPT4gc2V0KGkgPT4gKytpKSkuY3VycmVudDtcbn0iLCJpbXBvcnQgbG9kYXNoU2h1ZmZsZSBmcm9tIFwibG9kYXNoLWVzL3NodWZmbGVcIjtcbmltcG9ydCB7IGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgTXV0YWJsZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi4vZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkSW5mbywgTWFuYWdlZENoaWxkcmVuIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VGb3JjZVVwZGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtZm9yY2UtdXBkYXRlXCI7XG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5leHBvcnQgdHlwZSBHZXRJbmRleDxQPiA9IChyb3c6IFZOb2RlPFA+KSA9PiAobnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCk7XG5leHBvcnQgdHlwZSBHZXRWYWxpZCA9IChpbmRleDogbnVtYmVyKSA9PiBib29sZWFuO1xuZXhwb3J0IHR5cGUgR2V0SGlnaGVzdENoaWxkSW5kZXggPSAoKSA9PiBudW1iZXI7XG5leHBvcnQgdHlwZSBDb21wYXJlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlcj4+ID0gKGxoczogTSwgcmhzOiBNKSA9PiBudW1iZXI7XG5cbi8qKlxuICogQWxsIG9mIHRoZXNlIGZ1bmN0aW9ucyAqKk1VU1QqKiBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyB7XG5cbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiwgZS5nLiwgdGhlIHJvdyBpbmRleCBvZiB0aGlzIGNoaWxkXG4gICAgICogKFVzdWFsbHkganVzdCBhbiBgaW5kZXhgIHByb3ApXG4gICAgICovXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtdXN0IHJldHVybiB0aGUgaW5kZXggb2YgdGhpcyBjaGlsZCByZWxhdGl2ZSB0byBhbGwgaXRzIHNvcnRhYmxlIHNpYmxpbmdzLlxuICAgICAgICAgKiBcbiAgICAgICAgICogSW4gZ2VuZXJhbCwgdGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYGluZGV4YCBwcm9wLCBzbyBzb21ldGhpbmcgbGlrZSBgdm5vZGUgPT4gdm5vZGUucHJvcHMuaW5kZXhgIGlzIHdoYXQgeW91J3JlIHVzdWFsbHkgbG9va2luZyBmb3IuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRJbmRleDogR2V0SW5kZXg8YW55PjtcblxuICAgICAgICAvKiogXG4gICAgICAgICAqIFVzaW5nIHJlYXJyYW5nZWFibGUgY2hpbGRyZW4gbWVhbnMgd2UgbmVlZCB0byBiZSBhYmxlIHRvIG92ZXJyaWRlIGFycm93IGtleSBuYXZpZ2F0aW9uLFxuICAgICAgICAgKiB3aGljaCBhbHNvIG1lYW5zIHRoYXQsIHNvbWV3aGVyZSBkb3duIHRoZSByb2FkLCB3ZSBuZWVkIHRvIGtub3cgd2hpY2ggY2hpbGRyZW4gYXJlIGFycm93LWtleS1hYmxlLFxuICAgICAgICAgKiBqdXN0IGxpa2UgaW4gbm9ybWFsIGxpbmVhciBuYXZpZ2F0aW9uLlxuICAgICAgICAgKiBcbiAgICAgICAgICogXG4gICAgICAgICAqIFBTWUNIRSEhIExpbmVhck5hdmlnYXRpb24gc2hvdWxkIGJlIHRoZSBvbmUgdG8gZGVhbCB3aXRoIGluZGV4IG1hbmdsZXJzIGFuZCBkZW1hbmdsZXJzLCBhbmQgbm93IGl0IGRvZXMuXG4gICAgICAgICAqL1xuICAgICAgICAvL2dldFZhbGlkOiBHZXRWYWxpZDtcbiAgICAgICAgLy8gZ2V0SGlnaGVzdENoaWxkSW5kZXg6IEdldEhpZ2hlc3RDaGlsZEluZGV4O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBbGwgb2YgdGhlc2UgZnVuY3Rpb25zICoqTVVTVCoqIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXI+PiBleHRlbmRzIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnMge1xuICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyBob3cgdmFsdWVzIGNvbXBhcmUgYWdhaW5zdCBlYWNoIG90aGVyIHdoZW4gYHNvcnRgIGlzIGNhbGxlZC5cbiAgICAgICAgICogXG4gICAgICAgICAqIElmIG51bGwsIGEgZGVmYXVsdCBzb3J0IGlzIHVzZWQgdGhhdCBhc3N1bWVzIGBnZXRTb3J0VmFsdWVgIHJldHVybnMgYSB2YWx1ZSB0aGF0IHdvcmtzIHdlbGwgd2l0aCB0aGUgYC1gIG9wZXJhdG9yIChzbywgbGlrZSwgYSBudW1iZXIsIHN0cmluZywgYERhdGVgLCBgbnVsbGAsIGV0Yy4pXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0gbGhzIFxuICAgICAgICAgKiBAcGFyYW0gcmhzIFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcGFyZTogbnVsbCB8IENvbXBhcmU8TT47XG4gICAgfVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyPj4ge1xuICAgIC8vbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IFBpY2s8VXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNbXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJuYXZpZ2F0ZVJlbGF0aXZlXCIgfCBcIm5hdmlnYXRlQWJzb2x1dGVcIj47XG5cbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm46IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFzcyBhbiBhcnJheSBvZiBub3Qtc29ydGVkIGNoaWxkIGluZm9ybWF0aW9uIHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICogYW5kIHRoZSBjaGlsZHJlbiB3aWxsIHJlLWFycmFuZ2UgdGhlbXNlbHZlcyB0byBtYXRjaC5cbiAgICAgICAgICogIFxuICAgICAgICAgKiAqKlNUQUJMRSoqXG4gICAgICAgICAqICBcbiAgICAgICAgICogXG4gICAgICAgICAqL1xuICAgICAgICByZWFycmFuZ2U6IChyb3dzSW5PcmRlcjogTVtdKSA9PiB2b2lkO1xuXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNodWZmbGU6IChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPE0+KSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcblxuICAgICAgICAvKiogXG4gICAgICAgICAqICoqU1RBQkxFKipcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGNvbXBvbmVudCdzIG9yaWdpbmFsIGBpbmRleGAgcHJvcCBhbmQgb3V0cHV0cyBhIG5ldyBpbmRleCB0aGF0IHJlcHJlc2VudHMgaXRzIHJlLWFycmFuZ2VkIHBvc2l0aW9uLlxuICAgICAgICAgKiBJbiBjb25qdW5jdGlvbiB3aXRoIGBpbmRleERlbWFuZ2xlcmAsIHRoaXMgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBtYXRoIG9uIGluZGljZXMgKGluY3JlbWVudGluZywgZGVjcmVtZW50aW5nLCBldGMuKVxuICAgICAgICAgKiAgXG4gICAgICAgICAqIEUuRy4gdG8gZGVjcmVtZW50IGEgY29tcG9uZW50J3MgaW5kZXggXCJjXCI6IGluZGV4RGVtYW5nbGVyKGluZGV4TWFuZ2xlcihjKSAtIDEpXG4gICAgICAgICAqL1xuICAgICAgICBpbmRleE1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgbWFuZ2xlTWFwOiBNdXRhYmxlUmVmPE1hcDxudW1iZXIsIG51bWJlcj4+O1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBkZW1hbmdsZU1hcDogTXV0YWJsZVJlZjxNYXA8bnVtYmVyLCBudW1iZXI+PjtcblxuICAgICAgICAvKiogXG4gICAgICAgICAqICoqU1RBQkxFKipcbiAgICAgICAgICogXG4gICAgICAgICAqIENhbGwgdGhpcyBvbiB5b3VyIHByb3BzICh0aGF0IGNvbnRhaW4gdGhlIGNoaWxkcmVuIHRvIHNvcnQhISkgdG8gYWxsb3cgdGhlbSB0byBiZSBzb3J0YWJsZS5cbiAgICAgICAgICogXG4gICAgICAgICAqL1xuICAgICAgICB1c2VSZWFycmFuZ2VkQ2hpbGRyZW46IChjaGlsZHJlbjogVk5vZGVbXSkgPT4gVk5vZGVbXTtcbiAgICB9XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyPj4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQsIE0+IHtcbiAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuOiB7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNvcnQ6IChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPE0+LCBkaXJlY3Rpb246IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIikgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlQ2hpbGRJbmZvIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXI+IHtcbiAgICBnZXRTb3J0VmFsdWUoKTogdW5rbm93bjtcbn1cblxuXG4vKipcbiAqIEhvb2sgdGhhdCBhbGxvd3MgZm9yIHRoZSAqKmRpcmVjdCBkZXNjZW5kYW50KiogY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgdG8gYmUgcmUtb3JkZXJlZCBhbmQgc29ydGVkLlxuICogXG4gKiAqVGhpcyBpcyAqKnNlcGFyYXRlKiogZnJvbSBcIm1hbmFnZWRcIiBjaGlsZHJlbiwgd2hpY2ggY2FuIGJlIGFueSBsZXZlbCBvZiBjaGlsZCBuZWVkZWQhIFNvcnRhYmxlL3JlYXJyYW5nZWFibGUgY2hpbGRyZW4gbXVzdCBiZSAqKmRpcmVjdCBkZXNjZW5kYW50cyoqIG9mIHRoZSBwYXJlbnQgdGhhdCB1c2VzIHRoaXMgaG9vayEqXG4gKiBcbiAqIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoaXMgaW4gY29uanVuY3Rpb24gd2l0aCBgdXNlTGlzdE5hdmlnYXRpb25gOyBpdCB0YWtlcyB0aGUgc2FtZSBgaW5kZXhNYW5nbGVyYCBhbmQgYGluZGV4RGVtYW5nbGVyYCBcbiAqIGZ1bmN0aW9ucyB0aGF0IHRoaXMgaG9vayByZXR1cm5zLiBgdXNlTGlzdE5hdmlnYXRpb25gIGRvZXMgbm90IGRpcmVjdGx5IHVzZSB0aGlzIGhvb2sgYmVjYXVzZSwgYXMgbWVudGlvbmVkLCBcbiAqIHRoaXMgaG9vayBpbXBvc2VzIHNlcmlvdXMgcmVzdHJpY3Rpb25zIG9uIGNoaWxkIHN0cnVjdHVyZSwgd2hpbGUgYHVzZUxpc3ROYXZpZ2F0aW9uYCBhbGxvd3MgYW55dGhpbmcuXG4gKiBcbiAqIEJlc2lkZXMgdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgdGhhdCdzIHJldHVybmVkLCB0aGUgYHNvcnRgIGZ1bmN0aW9uIHRoYXQncyByZXR1cm5lZCB3aWxsXG4gKiBzb3J0IGFsbCBjaGlsZHJlbiBhY2NvcmRpbmcgdG8gdGhlaXIgdmFsdWUgZnJvbSB0aGUgYGdldFZhbHVlYCBhcmd1bWVudCB5b3UgcGFzcyBpbi5cbiAqIFxuICogSWYgeW91IHdhbnQgdG8gcGVyZm9ybSBzb21lIHJlLW9yZGVyaW5nIG9wZXJhdGlvbiB0aGF0J3MgKm5vdCogYSBzb3J0LCB5b3UgY2FuIG1hbnVhbGx5XG4gKiByZS1tYXAgZWFjaCBjaGlsZCdzIHBvc2l0aW9uIHVzaW5nIGBtYW5nbGVNYXBgIGFuZCBgZGVtYW5nbGVNYXBgLCB3aGljaCBjb252ZXJ0IGJldHdlZW5cbiAqIHNvcnRlZCBhbmQgdW5zb3J0ZWQgaW5kZXggcG9zaXRpb25zLlxuICogXG4gKiBBZ2FpbiwgdW5saWtlIHNvbWUgb3RoZXIgaG9va3MsICoqdGhlc2UgY2hpbGRyZW4gbXVzdCBiZSBkaXJlY3QgZGVzY2VuZGFudHMqKi4gVGhpcyBpcyBiZWNhdXNlXG4gKiB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayBpbnNwZWN0cyB0aGUgZ2l2ZW4gY2hpbGRyZW4sIHRoZW4gcmUtY3JlYXRlcyB0aGVtIHdpdGggbmV3IGBrZXlgcy5cbiAqIEJlY2F1c2Uga2V5cyBhcmUgZ2l2ZW4gc3BlY2lhbCB0cmVhdG1lbnQgYW5kIGEgY2hpbGQgaGFzIG5vIHdheSBvZiBtb2RpZnlpbmcgaXRzIG93biBrZXlcbiAqIHRoZXJlJ3Mgbm8gb3RoZXIgdGltZSBvciBwbGFjZSB0aGlzIGNhbiBoYXBwZW4gb3RoZXIgdGhhbiBleGFjdGx5IHdpdGhpbiB0aGUgcGFyZW50IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlYXJyYW5nZWFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZVNvcnRhYmxlQ2hpbGRJbmZvPih7XG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBnZXRJbmRleCB9XG59OiBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzKTogVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBNPiB7XG5cbiAgICAvLyBUaGVzZSBhcmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIGEgbWFwcGluZyBiZXR3ZWVuIHVuc29ydGVkIGluZGV4IDwtLS0+IHNvcnRlZCBpbmRleC5cbiAgICAvLyBUaGVzZSBhcmUgbmVlZGVkIGZvciBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMuXG4gICAgY29uc3QgbWFuZ2xlTWFwID0gdXNlUmVmKG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCkpO1xuICAgIGNvbnN0IGRlbWFuZ2xlTWFwID0gdXNlUmVmKG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCkpO1xuICAgIGNvbnN0IGluZGV4TWFuZ2xlciA9IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IChtYW5nbGVNYXAuY3VycmVudC5nZXQobikgPz8gbiksIFtdKTtcbiAgICBjb25zdCBpbmRleERlbWFuZ2xlciA9IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IChkZW1hbmdsZU1hcC5jdXJyZW50LmdldChuKSA/PyBuKSwgW10pO1xuICAgIC8vY29uc3QgeyBzZXRUYWJiYWJsZUluZGV4IH0gPSByb3ZpbmdUYWJJbmRleFJldHVybjtcblxuXG5cbiAgICBjb25zdCBzaHVmZmxlID0gdXNlQ2FsbGJhY2soKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48TT4pOiBQcm9taXNlPHZvaWQ+IHwgdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IHNodWZmbGVkUm93cyA9IGxvZGFzaFNodWZmbGUobWFuYWdlZFJvd3MuYXJyYXlTbGljZSgpKVxuICAgICAgICByZXR1cm4gcmVhcnJhbmdlKHNodWZmbGVkUm93cyk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG5cbiAgICAvLyBUaGUgc29ydCBmdW5jdGlvbiBuZWVkcyB0byBiZSBhYmxlIHRvIHVwZGF0ZSB3aG9ldmVyIGhhcyBhbGwgdGhlIHNvcnRhYmxlIGNoaWxkcmVuLlxuICAgIC8vIEJlY2F1c2UgdGhhdCBtaWdodCBub3QgYmUgdGhlIGNvbnN1bWVyIG9mICp0aGlzKiBob29rIGRpcmVjdGx5IChlLmcuIGEgdGFibGUgdXNlc1xuICAgIC8vIHRoaXMgaG9vaywgYnV0IGl0J3MgdGJvZHkgdGhhdCBhY3R1YWxseSBuZWVkcyB1cGRhdGluZyksIHdlIG5lZWQgdG8gcmVtb3RlbHlcbiAgICAvLyBnZXQgYW5kIHNldCBhIGZvcmNlVXBkYXRlIGZ1bmN0aW9uLlxuICAgIC8vY29uc3QgW2dldEZvcmNlVXBkYXRlLCBzZXRGb3JjZVVwZGF0ZV0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCwgcmV0dXJuTnVsbCk7XG4gICAgY29uc3QgW2dldEZvcmNlVXBkYXRlLCBzZXRGb3JjZVVwZGF0ZV0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8ICgoKSA9PiB2b2lkKSwgbmV2ZXI+KG51bGwsIHJldHVybk51bGwpO1xuXG4gICAgY29uc3QgcmVhcnJhbmdlID0gdXNlQ2FsbGJhY2soKHNvcnRlZFJvd3M6IE1bXSkgPT4ge1xuXG4gICAgICAgIG1hbmdsZU1hcC5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgIGRlbWFuZ2xlTWFwLmN1cnJlbnQuY2xlYXIoKTtcblxuICAgICAgICAvLyBVcGRhdGUgb3VyIHNvcnRlZCA8LS0+IHVuc29ydGVkIGluZGljZXMgbWFwIFxuICAgICAgICAvLyBhbmQgcmVyZW5kZXIgdGhlIHdob2xlIHRhYmxlLCBiYXNpY2FsbHlcbiAgICAgICAgZm9yIChsZXQgaW5kZXhBc1NvcnRlZCA9IDA7IGluZGV4QXNTb3J0ZWQgPCBzb3J0ZWRSb3dzLmxlbmd0aDsgKytpbmRleEFzU29ydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleEFzVW5zb3J0ZWQgPSBzb3J0ZWRSb3dzW2luZGV4QXNTb3J0ZWRdLmluZGV4O1xuXG4gICAgICAgICAgICBtYW5nbGVNYXAuY3VycmVudC5zZXQoaW5kZXhBc1Vuc29ydGVkLCBpbmRleEFzU29ydGVkKTtcbiAgICAgICAgICAgIGRlbWFuZ2xlTWFwLmN1cnJlbnQuc2V0KGluZGV4QXNTb3J0ZWQsIGluZGV4QXNVbnNvcnRlZCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGdldEZvcmNlVXBkYXRlKCk/LigpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHVzZVJlYXJyYW5nZWRDaGlsZHJlbiA9IHVzZUNhbGxiYWNrKChjaGlsZHJlbjogVk5vZGVbXSkgPT4ge1xuICAgICAgICBjb25zb2xlLmFzc2VydChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSk7XG5cbiAgICAgICAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBzZXRGb3JjZVVwZGF0ZShfcHJldiA9PiBmb3JjZVVwZGF0ZSk7IH0sIFtmb3JjZVVwZGF0ZV0pXG5cbiAgICAgICAgcmV0dXJuIChjaGlsZHJlbiBhcyBWTm9kZTxhbnk+W10pXG4gICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgLm1hcChjaGlsZCA9PiAoeyBjaGlsZCwgbWFuZ2xlZEluZGV4OiBpbmRleE1hbmdsZXIoZ2V0SW5kZXgoY2hpbGQpISksIGRlbWFuZ2xlZEluZGV4OiBnZXRJbmRleChjaGlsZCkgfSkpXG4gICAgICAgICAgICAuc29ydCgobGhzLCByaHMpID0+IHsgcmV0dXJuIGxocy5tYW5nbGVkSW5kZXggLSByaHMubWFuZ2xlZEluZGV4IH0pXG4gICAgICAgICAgICAubWFwKCh7IGNoaWxkLCBtYW5nbGVkSW5kZXgsIGRlbWFuZ2xlZEluZGV4IH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaChjaGlsZC50eXBlIGFzIGFueSwgeyAuLi5jaGlsZC5wcm9wcywga2V5OiBkZW1hbmdsZWRJbmRleCwgXCJkYXRhLW1hbmdsZWQtaW5kZXhcIjogbWFuZ2xlZEluZGV4LCBcImRhdGEtdW5tYW5nbGVkLWluZGV4XCI6IGRlbWFuZ2xlZEluZGV4IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy9saW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBuYXZpZ2F0ZUFic29sdXRlLCBuYXZpZ2F0ZVJlbGF0aXZlIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybjogeyBpbmRleE1hbmdsZXIsIGluZGV4RGVtYW5nbGVyLCBtYW5nbGVNYXAsIGRlbWFuZ2xlTWFwLCByZWFycmFuZ2UsIHNodWZmbGUsIHVzZVJlYXJyYW5nZWRDaGlsZHJlbiwgfVxuICAgIH07XG59XG5cblxuLyoqXG4gKiBIb29rIHRoYXQgYWxsb3dzIGZvciB0aGUgKipkaXJlY3QgZGVzY2VuZGFudCoqIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IHRvIGJlIHJlLW9yZGVyZWQgYW5kIHNvcnRlZC5cbiAqIFxuICogKlRoaXMgaXMgKipzZXBhcmF0ZSoqIGZyb20gXCJtYW5hZ2VkXCIgY2hpbGRyZW4sIHdoaWNoIGNhbiBiZSBhbnkgbGV2ZWwgb2YgY2hpbGQgbmVlZGVkISBTb3J0YWJsZS9yZWFycmFuZ2VhYmxlIGNoaWxkcmVuIG11c3QgYmUgKipkaXJlY3QgZGVzY2VuZGFudHMqKiBvZiB0aGUgcGFyZW50IHRoYXQgdXNlcyB0aGlzIGhvb2shKiBcbiAqIFxuICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBpbiBjb25qdW5jdGlvbiB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbmA7IGl0IHRha2VzIHRoZSBzYW1lIGBpbmRleE1hbmdsZXJgIGFuZCBgaW5kZXhEZW1hbmdsZXJgIFxuICogZnVuY3Rpb25zIHRoYXQgdGhpcyBob29rIHJldHVybnMuIGB1c2VMaXN0TmF2aWdhdGlvbmAgZG9lcyBub3QgZGlyZWN0bHkgdXNlIHRoaXMgaG9vayBiZWNhdXNlLCBhcyBtZW50aW9uZWQsIFxuICogdGhpcyBob29rIGltcG9zZXMgc2VyaW91cyByZXN0cmljdGlvbnMgb24gY2hpbGQgc3RydWN0dXJlLCB3aGlsZSBgdXNlTGlzdE5hdmlnYXRpb25gIGFsbG93cyBhbnl0aGluZy5cbiAqIFxuICogQmVzaWRlcyB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayB0aGF0J3MgcmV0dXJuZWQsIHRoZSBgc29ydGAgZnVuY3Rpb24gdGhhdCdzIHJldHVybmVkIHdpbGxcbiAqIHNvcnQgYWxsIGNoaWxkcmVuIGFjY29yZGluZyB0byB0aGVpciB2YWx1ZSBmcm9tIHRoZSBgZ2V0VmFsdWVgIGFyZ3VtZW50IHlvdSBwYXNzIGluLlxuICogXG4gKiBJZiB5b3Ugd2FudCB0byBwZXJmb3JtIHNvbWUgcmUtb3JkZXJpbmcgb3BlcmF0aW9uIHRoYXQncyAqbm90KiBhIHNvcnQsIHlvdSBjYW4gbWFudWFsbHlcbiAqIHJlLW1hcCBlYWNoIGNoaWxkJ3MgcG9zaXRpb24gdXNpbmcgYG1hbmdsZU1hcGAgYW5kIGBkZW1hbmdsZU1hcGAsIHdoaWNoIGNvbnZlcnQgYmV0d2VlblxuICogc29ydGVkIGFuZCB1bnNvcnRlZCBpbmRleCBwb3NpdGlvbnMuXG4gKiBcbiAqIEFnYWluLCB1bmxpa2Ugc29tZSBvdGhlciBob29rcywgKip0aGVzZSBjaGlsZHJlbiBtdXN0IGJlIGRpcmVjdCBkZXNjZW5kYW50cyoqLiBUaGlzIGlzIGJlY2F1c2VcbiAqIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIGluc3BlY3RzIHRoZSBnaXZlbiBjaGlsZHJlbiwgdGhlbiByZS1jcmVhdGVzIHRoZW0gd2l0aCBuZXcgYGtleWBzLlxuICogQmVjYXVzZSBrZXlzIGFyZSBnaXZlbiBzcGVjaWFsIHRyZWF0bWVudCBhbmQgYSBjaGlsZCBoYXMgbm8gd2F5IG9mIG1vZGlmeWluZyBpdHMgb3duIGtleVxuICogdGhlcmUncyBubyBvdGhlciB0aW1lIG9yIHBsYWNlIHRoaXMgY2FuIGhhcHBlbiBvdGhlciB0aGFuIGV4YWN0bHkgd2l0aGluIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZVNvcnRhYmxlQ2hpbGRJbmZvPih7XG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBjb21wYXJlOiB1c2VyQ29tcGFyZSB9XG59OiBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczxNPik6IFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQsIE0+IHtcblxuICAgIGNvbnN0IGdldENvbXBhcmUgPSB1c2VTdGFibGVHZXR0ZXI8Q29tcGFyZTxNPj4odXNlckNvbXBhcmUgPz8gZGVmYXVsdENvbXBhcmUpO1xuXG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4gfSA9IHVzZVJlYXJyYW5nZWFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50LCBNPih7IHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnMgfSk7XG4gICAgY29uc3QgeyByZWFycmFuZ2UgfSA9IHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybjtcbiAgICAvLyBUaGUgYWN0dWFsIHNvcnQgZnVuY3Rpb24uXG4gICAgY29uc3Qgc29ydCA9IHVzZUNhbGxiYWNrKChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPE0+LCBkaXJlY3Rpb246IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIik6IFByb21pc2U8dm9pZD4gfCB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgY29tcGFyZSA9IGdldENvbXBhcmUoKTtcblxuICAgICAgICBjb25zdCBzb3J0ZWRSb3dzID0gY29tcGFyZSA/IG1hbmFnZWRSb3dzLmFycmF5U2xpY2UoKS5zb3J0KChsaHNSb3csIHJoc1JvdykgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBsaHNWYWx1ZSA9IGxoc1JvdztcbiAgICAgICAgICAgIGNvbnN0IHJoc1ZhbHVlID0gcmhzUm93O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZShsaHNWYWx1ZSwgcmhzVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvblswXSA9PSBcImRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gLXJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfSkgOiBtYW5hZ2VkUm93cy5hcnJheVNsaWNlKCk7XG5cbiAgICAgICAgcmV0dXJuIHJlYXJyYW5nZShzb3J0ZWRSb3dzKTtcblxuICAgIH0sIFsgLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuOiB7IHNvcnQgfSxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuXG4gICAgfTtcbn1cblxuLypleHBvcnQgaW50ZXJmYWNlIFVzZUdyb3VwZWRTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczxNIGV4dGVuZHMgR3JvdXBlZFNvcnRlZENoaWxkSW5mbz4ge1xuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPltcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyb3VwZWRTb3J0YWJsZUNoaWxkcmVuIHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogUGljazxVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1tcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCJdLCBcImluZGV4RGVtYW5nbGVyXCIgfCBcImluZGV4TWFuZ2xlclwiPlxufSovXG5cbi8qKlxuICogSXQncyBjb21tb24gZW5vdWdoIHRvIGhhdmUsIGUuZy4sIGEgbGlzdCB3aXRoIG11bHRpcGxlIHNvcnRhYmxlIGdyb3VwcywgYSB0YWJsZSB3aGVyZSB0aGUgYm9keSBpcyBzb3J0ZWQgaW5kZXBlbmRlbnRseSBvZiB0aGUgaGVhZCwgZXRjLi4uXG4gKiBcbiAqIEEgc29ydGFibGUgZ3JvdXAgYXNzdW1lcyB0aGF0IHRoZSBwYXJlbnQgKHdoaWNoIGFsc28gY2FsbHMgdGhpcyBob29rKSBoYW5kbGVzIGxpc3QgbmF2aWdhdGlvbiAob3Igc2ltaWxhciksXG4gKiBhbmQgdGhhdCBlYWNoIGdyb3VwIGVsZW1lbnQgKHdoaWNoIGNhbiBhbHNvIGJlIHRoZSBsaXN0IHBhcmVudCwgaWYgdGhlcmUgYXJlIE5PIGdyb3VwcykgaGFuZGxlcyBzb3J0aW5nIChvciBzaW1pbGFyKS5cbiAqL1xuLypleHBvcnQgZnVuY3Rpb24gdXNlR3JvdXBlZFNvcnRhYmxlQ2hpbGRyZW48TSBleHRlbmRzIEdyb3VwZWRTb3J0ZWRDaGlsZEluZm8+KHsgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH0gfTogVXNlR3JvdXBlZFNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPE0+KTogVXNlR3JvdXBlZFNvcnRhYmxlQ2hpbGRyZW4ge1xuICAgIGNvbnN0IGFsbEluZGV4TWFuZ2xlcnMgPSB1c2VSZWY8TWFwPG51bWJlciwgKGk6IG51bWJlcikgPT4gbnVtYmVyPj4obmV3IE1hcCgpKTtcbiAgICBjb25zdCBhbGxJbmRleERlbWFuZ2xlcnMgPSB1c2VSZWY8TWFwPG51bWJlciwgKGk6IG51bWJlcikgPT4gbnVtYmVyPj4obmV3IE1hcCgpKTtcbiAgICBjb25zdCBpbmRleE1hbmdsZXIgPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBnZXRDaGlsZHJlbigpLmdldEF0KGkpO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGxldCBpbmRleE1hbmdsZXJGb3JUaGlzTG9jYXRpb24gPSBhbGxJbmRleE1hbmdsZXJzLmN1cnJlbnQuZ2V0KGNoaWxkLmxvY2F0aW9uSW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIChpbmRleE1hbmdsZXJGb3JUaGlzTG9jYXRpb24gPz8gaWRlbnRpdHkpKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZGVudGl0eShpKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgaW5kZXhEZW1hbmdsZXIgPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBnZXRDaGlsZHJlbigpLmdldEF0KGkpO1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGxldCBpbmRleERlbWFuZ2xlckZvclRoaXNMb2NhdGlvbiA9IGFsbEluZGV4RGVtYW5nbGVycy5jdXJyZW50LmdldChjaGlsZC5sb2NhdGlvbkluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiAoaW5kZXhEZW1hbmdsZXJGb3JUaGlzTG9jYXRpb24gPz8gaWRlbnRpdHkpKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZGVudGl0eShpKTtcbiAgICB9LCBbXSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBpbmRleE1hbmdsZXIsXG4gICAgICAgICAgICBpbmRleERlbWFuZ2xlclxuICAgICAgICB9XG4gICAgfVxufSovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShsaHM6IFVzZVNvcnRhYmxlQ2hpbGRJbmZvIHwgdW5kZWZpbmVkLCByaHM6IFVzZVNvcnRhYmxlQ2hpbGRJbmZvIHwgdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUxKGxocz8uZ2V0U29ydFZhbHVlKCksIHJocz8uZ2V0U29ydFZhbHVlKCkpO1xuXG4gICAgZnVuY3Rpb24gY29tcGFyZTEobGhzOiB1bmtub3duIHwgdW5kZWZpbmVkLCByaHM6IHVua25vd24gfCB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGxocyA9PSBudWxsIHx8IHJocyA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGhzID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKHJocyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChsaHMgYXMgYW55KSAtIChyaHMgYXMgYW55KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyB1c2VHcmlkTmF2aWdhdGlvbkNlbGwsIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtZ3JpZC1uYXZpZ2F0aW9uLXBhcnRpYWxcIjtcbmltcG9ydCB7IEdyaWRTaW5nbGVTZWxlY3RDaGlsZENlbGxJbmZvLCBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRSb3dJbmZvLCB1c2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiwgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLCBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGUsIHVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUm93LCBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJvd1BhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUm93UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1ncmlkLW5hdmlnYXRpb24tc2luZ2xlLXNlbGVjdGlvblwiO1xuLy9pbXBvcnQgeyBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZVNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsIFVzZVNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLXNpbmdsZS1zZWxlY3Rpb25cIjtcbmltcG9ydCB7IFVzZVNvcnRhYmxlQ2hpbGRJbmZvLCB1c2VTb3J0YWJsZUNoaWxkcmVuLCBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycywgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGUgfSBmcm9tIFwiLi91c2Utc29ydGFibGUtY2hpbGRyZW5cIjtcblxuLyoqXG4gKiBMaWtlIGxpc3QgbmF2aWdhdGlvbiBzaW5nbGUgc2VsZWN0aW9uIHNvcnRhYmxlIGV0Yy4gZXRjLiBldGMuXG4gKiBcbiAqIFRoZSBjb21iaW5hdGlvbnMgYXJlIGdldHRpbmcgYSBiaXQgc2lsbHkgYnV0IEkgc3dlYXIgdGhpcyBpcyB0aGUgbGFzdCBvbmUuXG4gKi9cbmNvbnN0IF9kdW1teSA9IDA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdENoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFVzZVNvcnRhYmxlQ2hpbGRJbmZvIHsgfVxuZXhwb3J0IGludGVyZmFjZSBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4ge1xuICAgIC8vZ2V0U29ydFZhbHVlOiBVc2VTb3J0YWJsZUNoaWxkSW5mb1tcImdldFNvcnRWYWx1ZVwiXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUGFyYW1ldGVyczxQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdENoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4+IGV4dGVuZHMgT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgTT4sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPE0+IHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgTT5bXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIj5cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVJldHVyblR5cGU8UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZTxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+LCBPbWl0PFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlPFBhcmVudE9yUm93RWxlbWVudCwgUk0+LCBcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Sb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBfUk0sIENNPiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVJvd1JldHVyblR5cGU8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2VsbFBhcmFtZXRlcnM8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50PiB7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGU8UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pih7XG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAuLi5ncmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNcbn06IFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVQYXJhbWV0ZXJzPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPik6IFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSZXR1cm5UeXBlPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4ge1xuICAgIGNvbnN0IHsgLi4uc2NyIH0gPSB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudE9yUm93RWxlbWVudCwgUk0+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycywgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMgfSk7XG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm46IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9IH0gPSBzY3I7XG4gICAgY29uc3QgZ25yID0gdXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIC4uLmxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzIH0sXG4gICAgICAgIC4uLmdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgLi4uZ25yLCAuLi5zY3IsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSb3c8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PihwOiBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPik6IFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7XG4gICAgcmV0dXJuIHVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+KHApO1xufVxuXG4vLyBFWlxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDZWxsPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ocDogVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNlbGxQYXJhbWV0ZXJzPGFueSwgQ2VsbEVsZW1lbnQ+KTogVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50PiB7XG4gICAgcmV0dXJuIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbDxDZWxsRWxlbWVudD4ocCk7XG59IiwiaW1wb3J0IHsgYXNzZXJ0RW1wdHlPYmplY3QgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZUxpc3ROYXZpZ2F0aW9uLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1saXN0LW5hdmlnYXRpb24tcGFydGlhbFwiO1xuaW1wb3J0IHsgU2VsZWN0YWJsZUNoaWxkSW5mbywgdXNlU2luZ2xlU2VsZWN0aW9uLCB1c2VTaW5nbGVTZWxlY3Rpb25DaGlsZCwgVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGUsIFVzZVNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsIFVzZVNpbmdsZVNlbGVjdGlvblJldHVyblR5cGUgfSBmcm9tIFwiLi91c2Utc2luZ2xlLXNlbGVjdGlvblwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuLyoqXG4gKiBXZSdyZSBqdXN0IGdsdWluZyB0b2dldGhlciB0aGUgbGlzdCBuYXZpZ2F0aW9uIGFuZCBzaW5nbGUgc2VsZWN0aW9uIGhvb2tzLFxuICogc2luY2UgdGhleSdyZSBzbyBjb21tb25seSBwYWlyZWQgdG9nZXRoZXIuIEFsc28gc2VlIHRoZSBvbmUgdGhhdCBpbmNsdWRlcyBzb3J0aW5nLlxuICovXG5jb25zdCBfZHVtbXkgPSAwO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudD4sIFNlbGVjdGFibGVDaGlsZEluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQ+IHsgfVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4+IGV4dGVuZHNcbiAgICBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4sXG4gICAgT21pdDxVc2VTaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPENoaWxkRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhSZXR1cm5cIj4ge1xuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdICYgVXNlU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQ+LCBVc2VTaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlPENoaWxkRWxlbWVudD4geyB9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+Pih7XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsXG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgIC4uLl92b2lkM1xufTogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+KTogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQ+IHtcbiAgICBjb25zdCBsbnIgPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPih7IGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLCByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4gfSk7XG4gICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleFJldHVybiB9ID0gbG5yO1xuICAgIGNvbnN0IHNzciA9IHVzZVNpbmdsZVNlbGVjdGlvbjxDaGlsZEVsZW1lbnQ+KHsgcm92aW5nVGFiSW5kZXhSZXR1cm4sIG1hbmFnZWRDaGlsZHJlblJldHVybiwgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyB9KTtcblxuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zc3IsXG4gICAgICAgIC4uLmxucixcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+LCBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PiB7XG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIl0gJiBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIl07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+LCBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50PiB7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXgsIC4uLl92b2lkNSB9LFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbiwgLi4udm9pZDcgfSxcbiAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgc2luZ2xlU2VsZWN0aW9uQ29udGV4dCxcbiAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0LFxuICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgIC4uLl92b2lkMVxufTogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50Pik6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudD4ge1xuXG4gICAgY29uc3Qge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7IG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IG9jZmljMiwgLi4uX3ZvaWQzIH0sXG4gICAgICAgIC4uLnNzY3JcbiAgICB9ID0gdXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50Pih7XG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25Db250ZXh0XG4gICAgfSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogb2NmaWMxLCAuLi5fdm9pZDYgfSxcbiAgICAgICAgLi4ubG5jclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudD4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbiB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCxcbiAgICAgICAgcmVmRWxlbWVudFJldHVybixcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzXG4gICAgfSk7XG5cbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDEpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMyk7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QoX3ZvaWQ1KTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDYpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQ3KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkLCBwcmV2aW91c2x5Rm9jdXNlZCwgZSkgPT4ge1xuICAgICAgICAgICAgICAgIG9jZmljMT8uKGZvY3VzZWQsIHByZXZpb3VzbHlGb2N1c2VkLCBlKTtcbiAgICAgICAgICAgICAgICBvY2ZpYzI/Lihmb2N1c2VkLCBwcmV2aW91c2x5Rm9jdXNlZCwgZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAuLi5zc2NyLFxuICAgICAgICAuLi5sbmNyXG4gICAgfVxufVxuIiwiXG5pbXBvcnQgeyB1c2VTdGFibGVPYmplY3QgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IFVzZUhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtaGFzLWN1cnJlbnQtZm9jdXNcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCBQYXNzaXZlU3RhdGVVcGRhdGVyLCByZXR1cm5GYWxzZSwgcnVuSW1tZWRpYXRlbHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyczxUIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyczoge1xuICAgICAgICAvKiogKi9cbiAgICAgICAgb25Db21wb3NpdGVGb2N1c0NoYW5nZTogbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPGJvb2xlYW4sIGguSlNYLlRhcmdldGVkRXZlbnQ8VD4+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IFJlcXVpcmVkPFBpY2s8VXNlSGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczxFPltcImhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnNcIl0sIFwib25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZFwiPj47XG4gICAgLy9yZWZFbGVtZW50UGFyYW1ldGVyczogUmVxdWlyZWQ8UGljazxVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxFPltcInJlZkVsZW1lbnRQYXJhbWV0ZXJzXCJdLCBcIm9uRWxlbWVudENoYW5nZVwiPj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5UeXBlPFQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm46IHsgZ2V0QW55Rm9jdXNlZCgpOiBib29sZWFuOyB9XG4gICAgY2hpbGRyZW5IYXZlRm9jdXNDaGlsZENvbnRleHQ6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQYXJhbWV0ZXJzPFQ+W1wiY2hpbGRyZW5IYXZlRm9jdXNDaGlsZENvbnRleHRcIl07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnM8VCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dDoge1xuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgICAgIHNldEZvY3VzQ291bnQ6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyLCBoLkpTWC5UYXJnZXRlZEV2ZW50PFQ+PjtcblxuICAgICAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgICAgIC8vYWxsRWxlbWVudHM6IFNldDxOb2RlPlxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuXG4vKipcbiAqIEFsbG93cyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgKHN1Y2ggYXMgYSByYWRpbyBncm91cCBvciBsaXN0Ym94KSB0byBsaXN0ZW5cbiAqIGZvciBhbiBcIm92ZXJhbGwgZm9jdXNpbi9vdXRcIiBldmVudDsgdGhpcyBob29rIGxldHMgeW91IGtub3cgd2hlbiBmb2N1cyBoYXMgXG4gKiBtb3ZlZCBpbi9vdXQgb2YgdGhpcyBncm91cGluZyBvZiBjaGlsZHJlbiBFVkVOIElGIHRoZXJlIGlzIG5vIGFjdHVhbCBwYXJlbnQgRE9NIGVsZW1lbnQuXG4gKiBcbiAqIEkuRS4geW91IGNhbiB1c2UgdGhpcyB3aXRob3V0IG5lZWRpbmcgYSBwYXJlbnQgYDxkaXY+YCB0byBsaXN0ZW4gZm9yIGEgYGZvY3Vzb3V0YCBldmVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuSGF2ZUZvY3VzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KGFyZ3M6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+KTogVXNlQ2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5UeXBlPENoaWxkRWxlbWVudD4ge1xuICAgIHR5cGUgUiA9IGguSlNYLlRhcmdldGVkRXZlbnQ8Q2hpbGRFbGVtZW50PjtcbiAgICBjb25zdCB7IGNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyczogeyBvbkNvbXBvc2l0ZUZvY3VzQ2hhbmdlIH0gfSA9IGFyZ3M7XG5cbiAgICBjb25zdCBbZ2V0QW55Rm9jdXNlZCwgc2V0QW55Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbiwgUj4ob25Db21wb3NpdGVGb2N1c0NoYW5nZSwgcmV0dXJuRmFsc2UsIHJ1bkltbWVkaWF0ZWx5KTtcbiAgICBjb25zdCBbX2dldEZvY3VzQ291bnQsIHNldEZvY3VzQ291bnRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciwgUj4odXNlU3RhYmxlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8bnVtYmVyLCBSPj4oKGFueUZvY3VzZWQsIGFueVByZXZpb3VzbHlGb2N1c2VkLCBlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGFueUZvY3VzZWQgPj0gMCAmJiBhbnlGb2N1c2VkIDw9IDEpO1xuICAgICAgICBzZXRBbnlGb2N1c2VkKCEhKGFueUZvY3VzZWQgJiYgIWFueVByZXZpb3VzbHlGb2N1c2VkKSwgZSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm46IHsgZ2V0QW55Rm9jdXNlZCB9LFxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHsgY2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnM6IHVzZVN0YWJsZU9iamVjdCh7IHNldEZvY3VzQ291bnQgfSkgfSksXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZDxFIGV4dGVuZHMgRWxlbWVudD4oeyBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dDogeyBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczogeyBzZXRGb2N1c0NvdW50IH0gfSB9OiBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczxFPik6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlPEU+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZCwgcHJldiwgZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEZvY3VzQ291bnQocCA9PiAocCA/PyAwKSArIDEsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZm9jdXNlZCAmJiBwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEZvY3VzQ291bnQocCA9PiAocCA/PyAwKSAtIDEsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9XG4gICAgfTtcbn0iLCJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG4vL2ltcG9ydCB7IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi4vZG9tLWhlbHBlcnMvdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuRmFsc2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5cbi8qXG5leHBvcnQgZnVuY3Rpb24gdXNlSGFzQ3VycmVudEZvY3VzUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+KHI6IFVzZUhhc0N1cnJlbnRGb2N1c1JldHVyblR5cGU8RT4sIC4uLm90aGVyUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W10pIHtcbiAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oci5oYXNDdXJyZW50Rm9jdXNSZXR1cm4ucHJvcHNTdGFibGUsIC4uLm90aGVyUHJvcHMpO1xufSovXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlSGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczxUIGV4dGVuZHMgTm9kZT4ge1xuICAgIHJlZkVsZW1lbnRSZXR1cm46IFJlcXVpcmVkPFBpY2s8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD5bXCJyZWZFbGVtZW50UmV0dXJuXCJdLCBcImdldEVsZW1lbnRcIj4+O1xuXG4gICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczoge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBlbGVtZW50IGl0c2VsZiBjdXJyZW50bHkgaGFzIGZvY3VzLlxuICAgICAgICAgKiBcbiAgICAgICAgICogYHByZXZGb2N1c2VkYCBpcyBnZW5lcmFsbHkgdGhlIG9wcG9zaXRlIG9mIGBmb2N1c2VkYCwgYnV0IG9uIG1vdW50IGl0J3MgYHVuZGVmaW5lZGAgd2hpbGUgYGZvY3VzZWRgIGlzIHByb2JhYmx5IGZhbHNlIChib3RoIGZhbHN5KVxuICAgICAgICAgKi9cbiAgICAgICAgb25DdXJyZW50Rm9jdXNlZENoYW5nZWQ6IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxib29sZWFuLCBoLkpTWC5UYXJnZXRlZEV2ZW50PFQ+PjsgLy8oKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB2b2lkKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGlrZSBgb25Gb2N1c2VkQ2hhbmdlZGAsIGJ1dCBhbHNvICphZGRpdGlvbmFsbHkqIGlmIGFueSBjaGlsZCBlbGVtZW50cyBhcmUgZm9jdXNlZC5cbiAgICAgICAgICogXG4gICAgICAgICAqIEBzZWUgdGhpcy5vbkZvY3VzZWRDaGFuZ2VkXG4gICAgICAgICAqL1xuICAgICAgICBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkOiBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8Ym9vbGVhbiwgaC5KU1guVGFyZ2V0ZWRFdmVudDxUPj47IC8vKChmb2N1c2VkOiBib29sZWFuLCBwcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4gdm9pZCk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUhhc0N1cnJlbnRGb2N1c1JldHVyblR5cGU8RSBleHRlbmRzIE5vZGU+IHtcbiAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm46IHtcbiAgICAgICAgcHJvcHNTdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RpZmllcyB0aGUgZWxlbWVudCB0byBiZSBhYmxlIHRvIHRyYWNrIGl0cyBvd24gZm9jdXMgc3RhdGVcbiAgICAgICAgICovXG4gICAgICAgIC8vcHJvcHNTdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xuXG4gICAgICAgIC8qKiBTVEFCTEUgKi9cbiAgICAgICAgZ2V0Q3VycmVudEZvY3VzZWQoKTogYm9vbGVhbjtcbiAgICAgICAgLyoqIFNUQUJMRSAqL1xuICAgICAgICBnZXRDdXJyZW50Rm9jdXNlZElubmVyKCk6IGJvb2xlYW47XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSGFzQ3VycmVudEZvY3VzPFQgZXh0ZW5kcyBOb2RlPihhcmdzOiBVc2VIYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzPFQ+KTogVXNlSGFzQ3VycmVudEZvY3VzUmV0dXJuVHlwZTxUPiB7XG4gICAgdHlwZSBSID0gaC5KU1guVGFyZ2V0ZWRGb2N1c0V2ZW50PFQ+O1xuICAgIGNvbnN0IHtcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczogeyBvbkN1cnJlbnRGb2N1c2VkQ2hhbmdlZDogb25Gb2N1c2VkQ2hhbmdlZCwgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogb25Gb2N1c2VkSW5uZXJDaGFuZ2VkIH0sXG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudCB9XG4gICAgfSA9IGFyZ3M7XG5cblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUhhc0N1cnJlbnRGb2N1c1wiLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIGdldEVsZW1lbnQpO1xuXG4gICAgY29uc3QgW2dldEZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4sICBSPihvbkZvY3VzZWRDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XG4gICAgY29uc3QgW2dldEZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuLCAgUj4ob25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XG5cbiAgICBjb25zdCBvbkZvY3VzSW4gPSB1c2VDYWxsYmFjazxoLkpTWC5FdmVudEhhbmRsZXI8aC5KU1guVGFyZ2V0ZWRGb2N1c0V2ZW50PFQ+Pj4oKGUpID0+IHtcbiAgICAgICAgc2V0Rm9jdXNlZElubmVyKHRydWUsIGUgYXMgUik7XG4gICAgICAgIHNldEZvY3VzZWQoZS50YXJnZXQgPT0gZ2V0RWxlbWVudCgpLCBlIGFzIFIpXG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgb25Gb2N1c091dCA9IHVzZUNhbGxiYWNrPGguSlNYLkV2ZW50SGFuZGxlcjxoLkpTWC5UYXJnZXRlZEZvY3VzRXZlbnQ8VD4+PigoZSkgPT4ge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT0gZ2V0RWxlbWVudCgpKSB7XG4gICAgICAgICAgICBzZXRGb2N1c2VkSW5uZXIoZmFsc2UsIGUgYXMgUik7XG4gICAgICAgICAgICBzZXRGb2N1c2VkKGZhbHNlLCBlIGFzIFIpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgcHJvcHNTdGFibGUgPSB1c2VSZWY8aC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4+KHtcbiAgICAgICAgb25mb2N1c2luOiBvbkZvY3VzSW4sXG4gICAgICAgIG9uZm9jdXNvdXQ6IG9uRm9jdXNPdXRcbiAgICB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzZXRGb2N1c2VkKGZhbHNlKTtcbiAgICAgICAgICAgIHNldEZvY3VzZWRJbm5lcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm46IHtcbiAgICAgICAgICAgIHByb3BzU3RhYmxlOiBwcm9wc1N0YWJsZS5jdXJyZW50LFxuICAgICAgICAgICAgZ2V0Q3VycmVudEZvY3VzZWQ6IGdldEZvY3VzZWQsXG4gICAgICAgICAgICBnZXRDdXJyZW50Rm9jdXNlZElubmVyOiBnZXRGb2N1c2VkSW5uZXIsXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuLi9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZUdsb2JhbEhhbmRsZXIgfSBmcm9tIFwiLi4vZG9tLWhlbHBlcnMvdXNlLWV2ZW50LWhhbmRsZXJcIjtcbmltcG9ydCB7IHVzZUZvcmNlVXBkYXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1mb3JjZS11cGRhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGF0ZVwiO1xuLypcbmV4cG9ydCBmdW5jdGlvbiB1c2VQcmVzc1Byb3BzPEUgZXh0ZW5kcyBFbGVtZW50PihyOiBVc2VQcmVzc1JldHVyblR5cGU8RT4sIC4uLm90aGVyUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W10pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltdIHtcbiAgICByZXR1cm4gW3IucHJlc3NSZXR1cm4ucHJvcHNTdGFibGUsIC4uLm90aGVyUHJvcHNdO1xufSovXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUHJlc3NQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBOb2RlPiB7XG4gICAgcmVmRWxlbWVudFJldHVybjogUmVxdWlyZWQ8UGljazxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPltcInJlZkVsZW1lbnRSZXR1cm5cIl0sIFwiZ2V0RWxlbWVudFwiPj47XG4gICAgcHJlc3NQYXJhbWV0ZXJzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGF0IHNob3VsZCBoYXBwZW4gd2hlbiB0aGlzIHdpZGdldCBoYXMgYmVlbiBcInByZXNzZWRcIi5cbiAgICAgICAgICogXG4gICAgICAgICAqIFRoaXMgbXVzdCBiZSBhIHN5bmMgZXZlbnQgaGFuZGxlcjsgYXN5bmMgaGFuZGxlcnMgbXVzdCBiZSB0YWtlbiBjYXJlIG9mIGV4dGVybmFsbHkuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBTZXR0aW5nIHRvIGBudWxsYCBvciBgdW5kZWZpbmVkYCBlZmZlY3RpdmVseSBkaXNhYmxlcyB0aGUgcHJlc3MgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgICovXG4gICAgICAgIG9uUHJlc3NTeW5jOiAoKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8RT4pID0+IHZvaWQpIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBjZXJ0YWluIG1ldGhvZHMgb2YgcHJlc3NpbmcgdGhpcyBjb21wb25lbnQgc2hvdWxkIGJlIGRlYWN0aXZhdGVkLlxuICAgICAgICAgKiBcbiAgICAgICAgICogRm9yIGV4YW1wbGUsIGR1cmluZyB0eXBlYWhlYWQsIHRoZSBzcGFjZSBrZXkgc2hvdWxkbid0IGNvdW50IGFzIGEgcHJlc3MsIGl0IHNob3VsZCBqdXN0IGNvdW50IGZvciB0aGUgc2VhcmNoLlxuICAgICAgICAgKiBcbiAgICAgICAgICogSWYgdHJ1ZSwgdGhlbiBhbGwgcHJlc3NlcyBhcmUgZGlzYWJsZWQuICBJZiBmYWxzZS91bmRlZmluZWQvbnVsbCwgbm8gcHJlc3NlcyBhcmUgZGlzYWJsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBleGNsdWRlOiB1bmRlZmluZWQgfCBib29sZWFuIHwgeyBjbGljaz86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBzcGFjZT86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBlbnRlcj86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkIH07XG4gICAgICAgIGZvY3VzU2VsZihlbGVtZW50OiBFKTogdm9pZDtcbiAgICAgICAgLy9vblBzZXVkb0FjdGl2ZVN0YXJ0OiBudWxsIHwgdW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpO1xuICAgICAgICAvL29uUHNldWRvQWN0aXZlU3RvcDogbnVsbCB8IHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUHJlc3NSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcHJlc3NSZXR1cm46IHtcbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBTb3J0IG9mIGxpa2Ugd2hlbiB0aGUgQ1NTIGA6YWN0aXZlYCBwc2V1ZG8tZWxlbWVudCB3b3VsZCBhcHBseSxcbiAgICAgICAgICogYnV0IHNwZWNpZmljYWxseSBmb3IgcHJlc3NlcyBvbmx5LiBVc2VmdWwgZm9yIHN0eWxpbmcgbW9zdGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgcHNldWRvQWN0aXZlOiBib29sZWFuO1xuICAgICAgICBwcm9wc1N0YWJsZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyB0byBjcmVhdGUgYSBcInByZXNzXCItbGlrZSBldmVudCBmb3JcbiAqIGFueSBlbGVtZW50LCB3aGV0aGVyIGl0J3MgYSBuYXRpdmUgPEJVVFRPTj4gb3IgcmVndWxhciA8RElWPi5cbiAqIFxuICogTm90YWJseSwgdGhlIGZvbGxvd2luZyBjYXNlcyBhcmUgY292ZXJlZDpcbiAqICogVGhlIHRhcmdldCBlbGVtZW50IGlzIHByb3Blcmx5IGZvY3VzZWQsIGV2ZW4gb24gaU9TIFNhZmFyaSAoKmVzcGVjaWFsbHkqIG9uIGlPUyBTYWZhcmkpXG4gKiAqIERvdWJsZS1jbGlja3Mgd29uJ3Qgc2VsZWN0IHRleHQuIFxuICogKiBDb252ZXJzZWx5LCBtYW51YWxseSBzZWxlY3RpbmcgdGV4dCB3b24ndCBpbnZva2UgYSBwcmVzcy5cbiAqICogS2V5Ym9hcmQgZXZlbnRzICZtZGFzaDsgYGVudGVyYCBpbW1lZGlhdGVseSBpbnZva2VzIHRoZSBoYW5kbGVyLCB3aGlsZSBgc3BhY2VgIGludm9rZXMgaXQgb24ga2V5dXAuXG4gKiAqIEhhcHRpYyBmZWVkYmFjayAob24sIGxpa2UsIHRoZSBvbmUgYnJvd3NlciBjb21iaW5hdGlvbiB0aGF0IHN1cHBvcnRzIGl0ICZtZGFzaDsgdGhpcyBjYW4gYmUgZGlzYWJsZWQgYXBwLXdpZGUgd2l0aCBgc2V0QnV0dG9uVmlicmF0ZWApXG4gKiBcbiAqIEluIGFkZGl0aW9uLCB3aGVuIHRoZSBDU1MgYDphY3RpdmVgIHBzZXVkby1jbGFzcyB3b3VsZCBhcHBseSB0byBhIG5vcm1hbCBidXR0b25cbiAqIChpLmUuIHdoZW4gaG9sZGluZyB0aGUgc3BhY2ViYXIgb3IgZHVyaW5nIG1vdXNlZG93biksIGB7IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IFwidHJ1ZVwiIH1gXG4gKiBpcyBhZGRlZCB0byB0aGUgcHJvcHMuICBZb3UgY2FuIGVpdGhlciBsZXQgaXQgcGFzcyB0aHJvdWdoIGFuZCBzdHlsZSBpdCB0aHJvdWdoIG5ldyBDU1MsXG4gKiBvciBpbnNwZWN0IHRoZSByZXR1cm5lZCBwcm9wcyBmb3IgaXQgYW5kIGFkZCBlLmcuIGFuIGAuYWN0aXZlYCBjbGFzcyBmb3IgZXhpc3RpbmcgQ1NTXG4gKiBcbiAqIEBwYXJhbSBvbkNsaWNrU3luYyBcbiAqIEBwYXJhbSBleGNsdWRlIFdoZXRoZXIgdGhlIHBvbHlmaWxsIHNob3VsZG4ndCBhcHBseSAoY2FuIHNwZWNpZnkgZm9yIHNwZWNpZmljIGludGVyYWN0aW9ucylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVByZXNzPEUgZXh0ZW5kcyBFbGVtZW50PihhcmdzOiBVc2VQcmVzc1BhcmFtZXRlcnM8RT4pOiBVc2VQcmVzc1JldHVyblR5cGU8RT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50IH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczogeyBleGNsdWRlLCBmb2N1c1NlbGYsIG9uUHJlc3NTeW5jIH1cbiAgICB9ID0gYXJncztcblxuICAgIC8vY29uc3Qgc3RhYmxlT25Qc2V1ZG9BY3RpdmVTdGFydCA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uUHNldWRvQWN0aXZlU3RhcnQgPz8gKCgpID0+IHsgfSkpO1xuICAgIC8vY29uc3Qgc3RhYmxlT25Qc2V1ZG9BY3RpdmVTdG9wID0gdXNlU3RhYmxlQ2FsbGJhY2sob25Qc2V1ZG9BY3RpdmVTdG9wID8/ICgoKSA9PiB7IH0pKTtcblxuICAgIC8vIEEgYnV0dG9uIGNhbiBiZSBhY3RpdmF0ZWQgaW4gbXVsdGlwbGUgd2F5cywgc28gb24gdGhlIG9mZiBjaGFuY2VcbiAgICAvLyB0aGF0IG11bHRpcGxlIGFyZSB0cmlnZ2VyZWQgYXQgb25jZSwgd2Ugb25seSAqYWN0dWFsbHkqIHJlZ2lzdGVyXG4gICAgLy8gYSBwcmVzcyBvbmNlIGFsbCBvZiBvdXIgXCJvblwiIHNpZ25hbHMgaGF2ZSB0dXJuZWQgYmFjayB0byBcIm9mZlwiLlxuICAgIC8vIFdlIGFwcHJveGltYXRlIHRoaXMgYnkganVzdCBpbmNyZW1lbnRpbmcgd2hlbiBhY3RpdmUsIGFuZFxuICAgIC8vIGRlY3JlbWVudGluZyB3aGVuIGRlYWN0aXZhdGVkLlxuICAgIC8vXG4gICAgLy8gQXMgYW4gZW1lcmdlbmN5IGZhaWxzYWZlLCB3aGVuIHRoZSBlbGVtZW50IGxvc2VzIGZvY3VzLFxuICAgIC8vIHRoaXMgaXMgcmVzZXQgYmFjayB0byAwLlxuICAgIGNvbnN0IFthY3RpdmVEdXJpbmdSZW5kZXIsIHNldEFjdGl2ZSwgZ2V0QWN0aXZlXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcblxuICAgIC8vY29uc3QgeyBnZXRFbGVtZW50IH0gPSByZWZFbGVtZW50UmV0dXJuO1xuXG4gICAgLy8gSWYgd2UgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gY2hhbmdlcyB0byBpbmNsdWRlIHRoaXMgZWxlbWVudFxuICAgIC8vIERVUklORyBlLmcuIGEgbW91c2Vkb3duLCB0aGVuIHdlIGRvbid0IHdhbnQgdGhlIG1vdXNldXAgdG8gXCJjb3VudFwiLCBhcyBpdCB3ZXJlLFxuICAgIC8vIGJlY2F1c2UgaXRzIG9ubHkgcHVycG9zZSB3YXMgc2VsZWN0aW5nIHRleHQsIG5vdCBjbGlja2luZyBidXR0b25zLlxuICAgIC8vXG4gICAgLy8gVG8gY2F0Y2ggdGhpcywgYW55IHRpbWUgdGhlIHRleHQgc2VsZWN0aW9uIGluY2x1ZGVzIHVzIHdoaWxlIGluIHRoZSBtaWRkbGVcbiAgICAvLyBvZiBhIGNsaWNrLCB0aGlzIGZsYWcgaXMgc2V0LCB3aGljaCBjYW5jZWxzIHRoZSBhY3RpdmF0aW9uIG9mIGEgcHJlc3MuXG4gICAgLy8gVGhlIGZsYWcgaXMgcmVzZXQgYW55IHRpbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBvciB0aGUgYnV0dG9uIGlzXG4gICAgLy8gbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICBjb25zdCBbdGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSwgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxEYXRlIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgcHNldWRvQWN0aXZlID0gKGFjdGl2ZUR1cmluZ1JlbmRlciAmJiAodGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSA9PSBudWxsKSk7XG4gICAgLy91c2VFZmZlY3QoKCkgPT4geyBpZiAocHNldWRvQWN0aXZlKSB7IHN0YWJsZU9uUHNldWRvQWN0aXZlU3RhcnQoKTsgfSBlbHNlIHsgc3RhYmxlT25Qc2V1ZG9BY3RpdmVTdG9wKCk7IH0gcmV0dXJuICgpID0+IHsgaWYgKHBzZXVkb0FjdGl2ZSkgc3RhYmxlT25Qc2V1ZG9BY3RpdmVTdG9wKCk7IH0gfSwgW3BzZXVkb0FjdGl2ZV0pXG5cbiAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInNlbGVjdGlvbmNoYW5nZVwiLCBfID0+IHtcbiAgICAgICAgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZShwcmV2ID0+IG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZ2V0RWxlbWVudCgpKSA9PSAwID8gbnVsbCA6IHByZXYgIT0gbnVsbCA/IHByZXYgOiBuZXcgRGF0ZSgpKTtcbiAgICB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmVEdXJpbmdSZW5kZXIgPT0gMClcbiAgICAgICAgICAgIHNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUobnVsbCk7XG5cbiAgICB9LCBbYWN0aXZlRHVyaW5nUmVuZGVyID09IDBdKTtcblxuICAgIGNvbnN0IG9uQWN0aXZlU3RhcnQgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25QcmVzc1N5bmM+PigoXykgPT4ge1xuICAgICAgICBzZXRBY3RpdmUoYSA9PiArK2EpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb25BY3RpdmVTdG9wID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uUHJlc3NTeW5jPj4oKGUpID0+IHtcbiAgICAgICAgc2V0QWN0aXZlKGEgPT4gTWF0aC5tYXgoMCwgLS1hKSk7XG5cbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB0aW1lRGlmZmVyZW5jZSA9ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lID09IG51bGwgPyBudWxsIDogK2N1cnJlbnRUaW1lIC0gK3RleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUpO1xuICAgICAgICBjb25zdCBjaGFyYWN0ZXJzU2VsZWN0ZWQgPSBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGdldEVsZW1lbnQoKSlcblxuICAgICAgICAvLyBJZiB3ZSdyZSBzZWxlY3RpbmcgdGV4dCAoaGV1cmlzdGljYWxseSBkZXRlcm1pbmVkIGJ5IHNlbGVjdGluZyBmb3IgbG9uZ2VyIHRoYW4gMS80IGEgc2Vjb25kLCBvciBtb3JlIHRoYW4gMiBjaGFyYWN0ZXJzKVxuICAgICAgICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBwcmVzcyBldmVudC5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbWVhc3VyZSBnbHlwaHMgaW5zdGVhZCBvZiBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY2hhcmFjdGVyc1NlbGVjdGVkID4gMSB8fCAoKHRpbWVEaWZmZXJlbmNlID8/IDApID4gMjUwICYmIGNoYXJhY3RlcnNTZWxlY3RlZCA+PSAxKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFjdGl2ZSA9IGdldEFjdGl2ZSgpOyAgIC8vIFdlIHF1ZXJ5IGlmIHdlJ3JlIGFjdGl2ZSAqYWZ0ZXIqIGNhbGxpbmcgc2V0U3RhdGUgYmVjYXVzZSB3ZSBjb3VudCBhIHByZXNzIGlmZiB3ZSdyZSBub3cgYXQgMC5cbiAgICAgICAgaWYgKGFjdGl2ZSA8PSAwKSB7XG4gICAgICAgICAgICBoYW5kbGVQcmVzcyhlKTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7ICAvLyBUT0RPOiBSZW1vdmUgd2hlbiBpc3N1ZSByZXNvbHZlZCBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8zNzMxXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGhhbmRsZVByZXNzID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uUHJlc3NTeW5jPj4oKGUpID0+IHtcbiAgICAgICAgaWYgKG9uUHJlc3NTeW5jKSB7XG5cbiAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBlbGVtZW50IGlzIGZvY3VzZWQgaGVyZSBiZWNhdXNlIG9mIGlPUyBTYWZhcmkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSXQncyBhbHdheXMgaU9TIFNhZmFyaS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpT1MgU2FmYXJpICh0ZXN0ZWQgb24gMTIpIGRvd25yaWdodCByZWZ1c2VzIHRvIGFsbG93IFxuICAgICAgICAgICAgLy8gZWxlbWVudHMgdG8gYmUgbWFudWFsbHkgZm9jdXNlZCBVTkxFU1MgaXQgaGFwcGVucyB3aXRoaW5cbiAgICAgICAgICAgIC8vIGFuIGV2ZW50IGhhbmRsZXIgbGlrZSB0aGlzLiAgSXQgYWxzbyBkb2Vzbid0IGZvY3VzXG4gICAgICAgICAgICAvLyBidXR0b25zIGJ5IGRlZmF1bHQgd2hlbiBjbGlja2VkLCB0YXBwZWQsIGV0Yy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJZiBpdCBiZWNvbWVzIHByb2JsZW1hdGljIHRoYXQgYnV0dG9uLWxpa2VzIGV4cGxpY2l0bHkgYmVjb21lXG4gICAgICAgICAgICAvLyBmb2N1c2VkIHdoZW4gdGhleSBhcmUgcHJlc3NlZCwgdGhlbiBhbiBhbHRlcm5hdGl2ZSBzb2x1dGlvbiBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBxdWVzdGlvbiBvZiBcImhvdyBkbyBtZW51IGJ1dHRvbnMga2VlcCB0aGVpciBtZW51cyBvcGVuXCJcbiAgICAgICAgICAgIC8vIGFuZCBvdGhlciBmb2N1cy1yZWxhdGVkIG5vbnNlbnNlIG5lZWRzIHRvIGJlIGZpZ3VyZWQgb3V0LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZvciBpT1MgU2FmYXJpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBcImZvY3VzXCIgaW4gKGVsZW1lbnQgYXMgRXZlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQpKVxuICAgICAgICAgICAgICAgIGZvY3VzU2VsZihlbGVtZW50IGFzIEV2ZW50VGFyZ2V0IGFzIEUpO1xuICAgICAgICAgICAgLy8oZWxlbWVudCBhcyBFdmVudFRhcmdldCBhcyBIVE1MRWxlbWVudCB8IG51bGwpPy5mb2N1cygpO1xuXG4gICAgICAgICAgICAvLyBXaGF0ZXZlciB0aGUgYnJvd3NlciB3YXMgZ29pbmcgdG8gZG8gd2l0aCB0aGlzIGV2ZW50LFxuICAgICAgICAgICAgLy8gZm9yZ2V0IGl0LiBXZSdyZSB0dXJuaW5nIGl0IGludG8gYSBcInByZXNzXCIgZXZlbnQuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIC8vIEFsc28gc3RvcCBhbnlvbmUgZWxzZSBmcm9tIGxpc3RlbmluZyB0byB0aGlzIGV2ZW50LFxuICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgZXhwbGljaXRseSBoYW5kbGluZyBpdC5cbiAgICAgICAgICAgIC8vIChOb3RhYmx5LCB0aGlzIGFsbG93cyBsYWJlbHMgdG8gd3JhcCBpbnB1dHMsIHdpdGggdGhlbVxuICAgICAgICAgICAgLy8gYm90aCBoYXZpbmcgcHJlc3MgZXZlbnQgaGFuZGxlcnMsIHdpdGhvdXQgZG91YmxlLWZpcmluZylcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIEhhcHRpYyBmZWVkYmFjayBmb3IgdGhpcyBwcmVzcyBldmVudFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHRocm93LFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBzaG91bGQgZ3VhcmQgYWdhaW5zdCB1c2VyIGltcGxlbWVudGF0aW9ucyB0aGF0IGNvdWxkLlxuICAgICAgICAgICAgICAgIHB1bHNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSBjYWxsIG91ciBoYW5kbGVyLlxuICAgICAgICAgICAgICAgIG9uUHJlc3NTeW5jKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG9uTW91c2VEb3duID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xuICAgICAgICBpZiAob25QcmVzc1N5bmMgJiYgIWV4Y2x1ZGVzKFwiY2xpY2tcIiwgZXhjbHVkZSkpIHtcbiAgICAgICAgICAgIC8vIFN0b3AgZG91YmxlIGNsaWNrcyBmcm9tIHNlbGVjdGluZyB0ZXh0IGluIGFuIGNvbXBvbmVudCB0aGF0J3MgKnN1cHBvc2VkKiB0byBiZSBhY3RpbmcgbGlrZSBhIGJ1dHRvbixcbiAgICAgICAgICAgIC8vIGJ1dCBhbHNvIGRvbid0IHByZXZlbnQgdGhlIHVzZXIgZnJvbSBzZWxlY3RpbmcgdGhhdCB0ZXh0IG1hbnVhbGx5IGlmIHRoZXkgcmVhbGx5IHdhbnQgdG9cbiAgICAgICAgICAgIC8vICh3aGljaCB1c2VyLXNlbGVjdDogbm9uZSB3b3VsZCBkbywgYnV0IGNhbmNlbGxpbmcgYSBkb3VibGUgY2xpY2sgb24gbW91c2VEb3duIGRvZXNuJ3QpXG4gICAgICAgICAgICBpZiAoZS5kZXRhaWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuICAgIGNvbnN0IG9uTW91c2VVcCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKG9uUHJlc3NTeW5jICYmICFleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpKSB7XG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDAgJiYgZ2V0QWN0aXZlKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgb25BY3RpdmVTdG9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKG9uUHJlc3NTeW5jICYmICFleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpKSB7XG4gICAgICAgICAgICBzZXRBY3RpdmUoMCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG9uS2V5RG93biA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZEtleWJvYXJkRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKG9uUHJlc3NTeW5jKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT0gXCIgXCIgJiYgIWV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBhY3RpdmF0ZSBpdCBvbiBhIHNwYWNlIGtleWRvd25cbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgZG8gcHJldmVudERlZmF1bHQgdG8gc3RvcCB0aGUgcGFnZSBmcm9tIHNjcm9sbGluZy5cbiAgICAgICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGUua2V5ID09IFwiRW50ZXJcIiAmJiAhZXhjbHVkZXMoXCJlbnRlclwiLCBleGNsdWRlKSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xuICAgICAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBvbktleVVwID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkS2V5Ym9hcmRFdmVudDxFPikgPT4ge1xuICAgICAgICBpZiAob25QcmVzc1N5bmMgJiYgZS5rZXkgPT0gXCIgXCIgJiYgIWV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkpXG4gICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XG4gICAgfSlcblxuICAgIGNvbnN0IG9uQ2xpY2sgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGlmIChvblByZXNzU3luYykge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGUuZGV0YWlsID4gMSkge1xuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25Gb2N1c091dCA9IHVzZVN0YWJsZUNhbGxiYWNrKChfZTogaC5KU1guVGFyZ2V0ZWRGb2N1c0V2ZW50PEU+KSA9PiB7XG4gICAgICAgIHNldEFjdGl2ZSgwKTtcbiAgICB9KVxuXG5cbiAgICBjb25zdCBwcm9wc1N0YWJsZTIgPSB1c2VSZWY8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHtcbiAgICAgICAgb25LZXlEb3duLFxuICAgICAgICBvbktleVVwLFxuICAgICAgICBvbk1vdXNlRG93bixcbiAgICAgICAgb25Nb3VzZVVwLFxuICAgICAgICBvbk1vdXNlTGVhdmUsXG4gICAgICAgIG9uQ2xpY2ssXG4gICAgICAgIG9uZm9jdXNvdXQ6IG9uRm9jdXNPdXRcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHByZXNzUmV0dXJuOiB7XG4gICAgICAgICAgICBwc2V1ZG9BY3RpdmU6IChwc2V1ZG9BY3RpdmUgfHwgZmFsc2UpLFxuICAgICAgICAgICAgcHJvcHNTdGFibGU6IHByb3BzU3RhYmxlMi5jdXJyZW50LFxuICAgICAgICAgICAgLypwcm9wc1Vuc3RhYmxlOiB7XG4gICAgICAgICAgICAgICAgc3R5bGU6ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lICE9IG51bGwpID8geyBjdXJzb3I6IFwidGV4dFwiIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgLi4ueyBcImRhdGEtcHNldWRvLWFjdGl2ZVwiOiBwc2V1ZG9BY3RpdmUgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9IGFzIHt9XG4gICAgICAgICAgICB9LCovXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cblxuXG4vKipcbiAqIHNlbGVjdGlvbi5jb250YWluc05vZGUgZG9lc24ndCBhY2NvdW50IGZvciBzZWxlY3Rpb24uaXNDb2xsYXBzZWQsXG4gKiBzbyBoZXJlJ3MgYSB3b3JrYXJvdW5kIGZvciB0aGF0LlxuICogXG4gKiBXZSBhbHNvIG9ubHkgbG9vayBmb3IgdGhlIHNlbGVjdGlvbiBlbmQgdG8gb25seSBjYXRjaCB0aGUgXG4gKiBlc3NlbnNlIG9mIGEgbm9uLWV4aXN0YW50IFwic2VsZWN0aW9uc3RvcFwiIGV2ZW50LlxuICogXG4gKiBAcGFyYW0gZWxlbWVudCBcbiAqIEByZXR1cm5zIFxuICovXG5mdW5jdGlvbiBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGVsZW1lbnQ6IEV2ZW50VGFyZ2V0IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChzZWxlY3Rpb24/LnJhbmdlQ291bnQgPz8gMCk7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24hLmdldFJhbmdlQXQoaSkhO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY29udGFpbnMocmFuZ2UuZW5kQ29udGFpbmVyKSAmJiAhc2VsZWN0aW9uPy5pc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24hLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59XG5cblxubGV0IHB1bHNlID0gKChcInZpYnJhdGVcIiBpbiBuYXZpZ2F0b3IpICYmIChuYXZpZ2F0b3IudmlicmF0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkgPyAoKCkgPT4gbmF2aWdhdG9yLnZpYnJhdGUoMTApKSA6ICgoKSA9PiB7IH0pO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZW5hYmxlL2Rpc2FibGUgYnV0dG9uIHZpYnJhdGlvbiBwdWxzZXMgb24gYW4gYXBwLXdpZGUgc2NhbGUuXG4gKiBcbiAqIFxuICogQHBhcmFtIGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGEgYnV0dG9uIGlzIHRhcHBlZC5cbiAqIChEZWZhdWx0IGlzIGAoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMClgIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdCwgYSBub29wIG90aGVyd2lzZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFByZXNzVmlicmF0ZShmdW5jOiAoKSA9PiB2b2lkKSB7XG4gICAgcHVsc2UgPSBmdW5jO1xufVxuXG5cblxuZnVuY3Rpb24gZXhjbHVkZXModGFyZ2V0OiBcImNsaWNrXCIgfCBcInNwYWNlXCIgfCBcImVudGVyXCIsIGV4Y2x1ZGU6IHVuZGVmaW5lZCB8IGJvb2xlYW4gfCB7IGNsaWNrPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIHNwYWNlPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIGVudGVyPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQgfSkge1xuICAgIGlmIChleGNsdWRlID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGV4Y2x1ZGUgPT09IHRydWUgfHwgZXhjbHVkZT8uW3RhcmdldF0pXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgVXNlU29ydGFibGVDaGlsZEluZm8gfSBmcm9tIFwiLi4vY29tcG9uZW50LWRldGFpbC91c2Utc29ydGFibGUtY2hpbGRyZW5cIjtcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZSB9IGZyb20gXCIuLi9jb21wb25lbnQtZGV0YWlsL3VzZS1ncmlkLW5hdmlnYXRpb24tcGFydGlhbFwiO1xuaW1wb3J0IHsgdXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DZWxsLCBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNlbGxQYXJhbWV0ZXJzLCBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZSwgdXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Sb3csIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUm93UmV0dXJuVHlwZSB9IGZyb20gXCIuLi9jb21wb25lbnQtZGV0YWlsL3VzZS1ncmlkLW5hdmlnYXRpb24tc2luZ2xlLXNlbGVjdGlvblwiO1xuaW1wb3J0IHsgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRDZWxsSW5mbywgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRSb3dJbmZvLCB1c2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlLCBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2VsbFJldHVyblR5cGUsIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVQYXJhbWV0ZXJzLCBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUmV0dXJuVHlwZSwgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVJvd1BhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSb3dSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL2NvbXBvbmVudC1kZXRhaWwvdXNlLWdyaWQtbmF2aWdhdGlvbi1zaW5nbGUtc2VsZWN0aW9uLXNvcnRhYmxlXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuLi9kb20taGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuLi9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZUNoaWxkcmVuSGF2ZUZvY3VzLCB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkLCBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGUgfSBmcm9tIFwiLi4vb2JzZXJ2ZXJzL3VzZS1jaGlsZHJlbi1oYXZlLWZvY3VzXCI7XG5pbXBvcnQgeyB1c2VIYXNDdXJyZW50Rm9jdXMsIFVzZUhhc0N1cnJlbnRGb2N1c1JldHVyblR5cGUgfSBmcm9tIFwiLi4vb2JzZXJ2ZXJzL3VzZS1oYXMtY3VycmVudC1mb2N1c1wiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkcmVuLCB1c2VNYW5hZ2VkQ2hpbGQsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dCwgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSwgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZU9iamVjdCB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlUHJlc3MsIFVzZVByZXNzUGFyYW1ldGVycywgVXNlUHJlc3NSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXByZXNzXCI7XG5cbi8qZXhwb3J0IGludGVyZmFjZSBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2hpbGRJbmZvPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7XG4gICAgXG59Ki9cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+PiBleHRlbmRzXG4gICAgT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUGFyYW1ldGVyczxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBNPiwgXCJtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5cIiB8IFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIiB8IFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIiB8IFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiIHwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4ge1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBNPltcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCJdLCBcImdldEhpZ2hlc3RJbmRleFwiIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiB8IFwiaXNWYWxpZFwiPjtcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczogT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgTT5bXCJ0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJnZXRIaWdoZXN0SW5kZXhcIiB8IFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIgfCBcImlzVmFsaWRcIj47XG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUGFyYW1ldGVyczxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBNPltcInJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnNcIl0sIFwiZ2V0SGlnaGVzdENoaWxkSW5kZXhcIiB8IFwiaXNWYWxpZFwiPjtcbiAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IE9taXQ8VXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVBhcmFtZXRlcnM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgTT5bXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIl0sIFwiaW5pdGlhbGx5VGFiYmVkSW5kZXhcIj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiB7XG4gICAgcm93QXNDaGlsZE9mR3JpZFBhcmFtZXRlcnM6IE9taXQ8VXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT5bXCJyb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyc1wiXSwgXCJtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5cIiB8IFwic2luZ2xlU2VsZWN0aW9uQ29udGV4dFwiIHwgXCJncmlkTmF2aWdhdGlvblJvd0NvbnRleHRcIiB8IFwicm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHRcIiB8IFwidHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dFwiIHwgXCJyZWZFbGVtZW50UmV0dXJuXCI+ICYge1xuICAgICAgICBjb250ZXh0OiBDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ29udGV4dDxhbnksIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+OyAvL1VzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8Uk0+W1wiY29udGV4dFwiXTtcbiAgICAgICAgLy9tYW5hZ2VkQ2hpbGRSZXR1cm46IFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU8Uk0+W1wibWFuYWdlZENoaWxkUmV0dXJuXCJdO1xuICAgICAgICBjb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczogT21pdDxSTSwga2V5b2YgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50Pj47XG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiBQaWNrPFVzZVNvcnRhYmxlQ2hpbGRJbmZvLCBcImdldFNvcnRWYWx1ZVwiPjtcbiAgICB9O1xuICAgIHJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnM6IE9taXQ8VXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT5bXCJyb3dBc1BhcmVudE9mQ2VsbHNQYXJhbWV0ZXJzXCJdLCBcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiIHwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIiB8IFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIiB8IFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4gJiB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+W1wicm93QXNQYXJlbnRPZkNlbGxzUGFyYW1ldGVyc1wiXVtcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCJdLCBcImdldEhpZ2hlc3RJbmRleFwiIHwgXCJwYWdlTmF2aWdhdGlvblNpemVcIiB8IFwiaXNWYWxpZFwiIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIj47XG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+W1wicm93QXNQYXJlbnRPZkNlbGxzUGFyYW1ldGVyc1wiXVtcInR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXCJdLCBcImlzVmFsaWRcIj47XG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPltcInJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnNcIl1bXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIl0sIFwiaW5pdGlhbGx5VGFiYmVkSW5kZXhcIj47XG4gICAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+IGV4dGVuZHNcbiAgICBPbWl0PFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2VsbFBhcmFtZXRlcnM8YW55LCBDZWxsRWxlbWVudD4sIFwidHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dFwiIHwgXCJyb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dFwiIHwgXCJncmlkTmF2aWdhdGlvbkNlbGxDb250ZXh0XCIgfCBcInJlZkVsZW1lbnRSZXR1cm5cIj4ge1xuICAgIHByZXNzUGFyYW1ldGVyczogVXNlUHJlc3NQYXJhbWV0ZXJzPENlbGxFbGVtZW50PltcInByZXNzUGFyYW1ldGVyc1wiXTtcbiAgICAvL3NvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiB7IGdldFNvcnRWYWx1ZTogVXNlU29ydGFibGVDaGlsZEluZm9bXCJnZXRTb3J0VmFsdWVcIl0gfTtcbiAgICAvL21hbmFnZWRDaGlsZENvbnRleHQ6IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT5bXCJtYW5hZ2VkQ2hpbGRDb250ZXh0XCJdO1xuICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczogT21pdDxNLCBrZXlvZiBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50Pj47XG4gICAgY29udGV4dDogQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd0NvbnRleHQ8YW55LCBDZWxsRWxlbWVudCwgTT47XG4gICAgLy9tYW5hZ2VkQ2hpbGRSZXR1cm46IFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU8TT5bXCJtYW5hZ2VkQ2hpbGRSZXR1cm5cIl07XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ29udGV4dDxQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxSTT4sXG4gICAgUGljazxVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGU8Um93RWxlbWVudD4sIFwiY2hpbGRyZW5IYXZlRm9jdXNDaGlsZENvbnRleHRcIj4sXG4gICAgUGljazxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGU8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJzaW5nbGVTZWxlY3Rpb25Db250ZXh0XCIgfCBcInJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0XCIgfCBcInR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHRcIiB8IFwiZ3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0XCI+IHtcblxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd0NvbnRleHQ8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZENlbGxJbmZvPENoaWxkRWxlbWVudD4+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNPixcbiAgICBQaWNrPFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQ+W1wicm93QXNQYXJlbnRPZkNlbGxzUmV0dXJuXCJdLCBcInJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0XCIgfCBcInR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHRcIiB8IFwiZ3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dFwiPiB7XG4gICAgY29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQ6IHtcbiAgICAgICAgb25QcmVzc1N5bmM6IFVzZVByZXNzUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1wicHJlc3NQYXJhbWV0ZXJzXCJdW1wib25QcmVzc1N5bmNcIl1cbiAgICB9XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+XG4gICAgZXh0ZW5kcyBPbWl0PFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSZXR1cm5UeXBlPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwidHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dFwiIHwgXCJzaW5nbGVTZWxlY3Rpb25Db250ZXh0XCIgfCBcInJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0XCIgfCBcImdyaWROYXZpZ2F0aW9uUm93Q29udGV4dFwiIHwgXCJjaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnNcIiB8IFwibWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyc1wiPiB7XG4gICAgcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yUm93RWxlbWVudD47XG4gICAgY29udGV4dDogQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQ8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPjtcblxuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxSTT5bXCJtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5cIl07XG4gICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm46IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZTxSb3dFbGVtZW50PltcImNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuXCJdO1xuICAgIC8vcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogUGljazxVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzW1wicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiXSwgXCJnZXRIaWdoZXN0Q2hpbGRJbmRleFwiIHwgXCJnZXRWYWxpZFwiPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZTxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+IHtcbiAgICBjb250ZXh0OiBDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93Q29udGV4dDxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgQ00+O1xuICAgIHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PjtcbiAgICByb3dBc1BhcmVudE9mQ2VsbHNSZXR1cm46IFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PltcInJvd0FzUGFyZW50T2ZDZWxsc1JldHVyblwiXSAmIHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPENNPltcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiXTtcbiAgICB9O1xuICAgIHJvd0FzQ2hpbGRPZkdyaWRSZXR1cm46IFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PltcInJvd0FzQ2hpbGRPZkdyaWRSZXR1cm5cIl0gJiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybjogVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxSTT5bXCJtYW5hZ2VkQ2hpbGRSZXR1cm5cIl07XG4gICAgfTtcbiAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm46IFVzZUhhc0N1cnJlbnRGb2N1c1JldHVyblR5cGU8Um93RWxlbWVudD5bXCJoYXNDdXJyZW50Rm9jdXNSZXR1cm5cIl07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ00gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50Pj4gZXh0ZW5kc1xuICAgIE9taXQ8VXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50PiwgXCJoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzXCI+LFxuICAgIFVzZVByZXNzUmV0dXJuVHlwZTxDZWxsRWxlbWVudD4sIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPENlbGxFbGVtZW50PiwgVXNlSGFzQ3VycmVudEZvY3VzUmV0dXJuVHlwZTxDZWxsRWxlbWVudD4sIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU8Q00+IHtcbiAgICBwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+O1xuXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb248UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pih7XG4gICAgZ3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnNcbn06IFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPik6IFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4ge1xuXG4gICAgY29uc3QgZ2V0Q2hpbGRyZW46ICgpID0+IE1hbmFnZWRDaGlsZHJlbjxSTT4gPSB1c2VDYWxsYmFjazwoKSA9PiBNYW5hZ2VkQ2hpbGRyZW48Uk0+PigoKSA9PiBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4uZ2V0Q2hpbGRyZW4oKSwgW10pO1xuICAgIGNvbnN0IGdldEhpZ2hlc3RDaGlsZEluZGV4OiAoKCkgPT4gbnVtYmVyKSA9IHVzZUNhbGxiYWNrPCgpID0+IG51bWJlcj4oKCkgPT4gZ2V0Q2hpbGRyZW4oKS5nZXRIaWdoZXN0SW5kZXgoKSwgW10pO1xuXG4gICAgY29uc3QgaXNWYWxpZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChpbmRleDogbnVtYmVyKTogYm9vbGVhbiA9PiB7IHJldHVybiAhKGdldENoaWxkcmVuKCkuZ2V0QXQoaW5kZXgpPy5oaWRkZW4pIH0pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnMsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25Db250ZXh0LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0LFxuICAgICAgICBncmlkTmF2aWdhdGlvblJvd0NvbnRleHQsXG4gICAgICAgIC4uLmdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuXG4gICAgfSA9IHVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGU8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPih7XG4gICAgICAgIGdyaWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0Q2hpbGRJbmRleCwgaXNWYWxpZCwgLi4ubGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogeyBpbml0aWFsbHlUYWJiZWRJbmRleDogc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycy5pbml0aWFsbHlTZWxlY3RlZEluZGV4LCAuLi5yb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgaXNWYWxpZCwgLi4udHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMgfSxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnNcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgbGluZWFyTmF2aWdhdGlvblJldHVybiwgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybiB9ID0gZ3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm47XG5cbiAgICBjb25zdCB7IGNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRDb250ZXh0LCBjaGlsZHJlbkhhdmVGb2N1c1JldHVybiB9ID0gdXNlQ2hpbGRyZW5IYXZlRm9jdXM8Um93RWxlbWVudD4oeyBjaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnMgfSk7XG4gICAgY29uc3QgeyBjb250ZXh0OiB7IG1hbmFnZWRDaGlsZENvbnRleHQgfSwgbWFuYWdlZENoaWxkcmVuUmV0dXJuIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48Uk0+KHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyB9KTtcbiAgICBjb25zdCBwcm9wcyA9IHVzZU1lcmdlZFByb3BzKGxpbmVhck5hdmlnYXRpb25SZXR1cm4ucHJvcHNTdGFibGUsIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4ucHJvcHNTdGFibGUpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VTdGFibGVPYmplY3Q8Q29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQ8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPj4oe1xuICAgICAgICBzaW5nbGVTZWxlY3Rpb25Db250ZXh0LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRDb250ZXh0LFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCxcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNDaGlsZENvbnRleHQsXG4gICAgICAgIGdyaWROYXZpZ2F0aW9uUm93Q29udGV4dCxcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHByb3BzLFxuXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgLi4uZ3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuLFxuICAgICAgICAvL3JlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgZ2V0SGlnaGVzdENoaWxkSW5kZXg6IGdldEhpZ2hlc3RDaGlsZEluZGV4LCBnZXRWYWxpZCB9LFxuICAgIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvdzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+KHtcbiAgICByb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyczoge1xuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBjb250ZXh0OiB7IGNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRDb250ZXh0LCBncmlkTmF2aWdhdGlvblJvd0NvbnRleHQsIG1hbmFnZWRDaGlsZENvbnRleHQ6IG1jYzEsIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0LCBzaW5nbGVTZWxlY3Rpb25Db250ZXh0LCB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0IH0sXG4gICAgICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICAuLi5yb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyc1xuICAgIH0sXG4gICAgcm93QXNQYXJlbnRPZkNlbGxzUGFyYW1ldGVyczoge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgLi4ucm93QXNQYXJlbnRPZkNlbGxzUGFyYW1ldGVyc1xuICAgIH1cbn06IFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+KTogVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4ge1xuXG4gICAgY29uc3QgeyBpbmRleCB9ID0gbWFuYWdlZENoaWxkUGFyYW1ldGVycztcblxuICAgIGNvbnN0IGdldENoaWxkcmVuID0gdXNlQ2FsbGJhY2soKCkgPT4gbWFuYWdlZENoaWxkcmVuUmV0dXJuLmdldENoaWxkcmVuKCksIFtdKTtcbiAgICBjb25zdCBnZXRIaWdoZXN0Q2hpbGRJbmRleDogKCgpID0+IG51bWJlcikgPSB1c2VDYWxsYmFjazwoKSA9PiBudW1iZXI+KCgpID0+IGdldENoaWxkcmVuKCkuZ2V0SGlnaGVzdEluZGV4KCksIFtdKTtcbiAgICBjb25zdCBpc1ZhbGlkID0gdXNlQ2FsbGJhY2soKGk6IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGdldENoaWxkcmVuKCkuZ2V0QXQoaSk7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAhY2hpbGQuaGlkZGVuO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxSb3dFbGVtZW50Pih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcblxuICAgIGNvbnN0IHI6IFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUm93UmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4gPSB1c2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJvdzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPih7XG4gICAgICAgIHJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIC4uLnJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHsgaW5pdGlhbGx5VGFiYmVkSW5kZXg6IDAsIC4uLnJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyB9LFxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgaXNWYWxpZCwgLi4udHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMgfSxcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IGlzVmFsaWQsIGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdENoaWxkSW5kZXgsIHBhZ2VOYXZpZ2F0aW9uU2l6ZTogMCwgaW5kZXhEZW1hbmdsZXI6IGlkZW50aXR5LCBpbmRleE1hbmdsZXI6IGlkZW50aXR5LCAuLi5saW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyB9LFxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAuLi5yb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGdyaWROYXZpZ2F0aW9uUm93Q29udGV4dCxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0LFxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ29udGV4dCxcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH0sXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgcm93QXNDaGlsZE9mR3JpZFJldHVybiwgcm93QXNQYXJlbnRPZkNlbGxzUmV0dXJuIH0gPSByO1xuXG5cbiAgICBjb25zdCB7IGNvbnRleHQ6IHsgbWFuYWdlZENoaWxkQ29udGV4dCB9LCBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxDTT4oeyBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiByLnJvd0FzUGFyZW50T2ZDZWxsc1JldHVybi5tYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzIH0pO1xuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCB9ID0gcmVmRWxlbWVudFJldHVybjtcblxuICAgIGNvbnN0IGJhc2VJbmZvOiBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+ID0ge1xuICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICBzZXRUYWJiYWJsZTogci5yb3dBc0NoaWxkT2ZHcmlkUmV0dXJuLnJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4uc2V0VGFiYmFibGUsXG4gICAgICAgIGdldFRhYmJhYmxlOiByLnJvd0FzQ2hpbGRPZkdyaWRSZXR1cm4ucm92aW5nVGFiSW5kZXhDaGlsZFJldHVybi5nZXRUYWJiYWJsZSxcbiAgICAgICAgdGFiYmFibGU6IHIucm93QXNDaGlsZE9mR3JpZFJldHVybi5yb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLnRhYmJhYmxlLFxuICAgICAgICBpbmRleDogbWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleCxcbiAgICAgICAgaGlkZGVuOiByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycy5oaWRkZW4sXG4gICAgICAgIHNlbGVjdGVkOiByLnJvd0FzQ2hpbGRPZkdyaWRSZXR1cm4uc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm4uc2VsZWN0ZWQsXG4gICAgICAgIGZvY3VzU2VsZjogci5yb3dBc0NoaWxkT2ZHcmlkUmV0dXJuLmdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycy5mb2N1c1NlbGYsXG4gICAgICAgIGdldFNlbGVjdGVkOiByLnJvd0FzQ2hpbGRPZkdyaWRSZXR1cm4uc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm4uZ2V0U2VsZWN0ZWQsXG4gICAgICAgIHNldExvY2FsU2VsZWN0ZWQ6IHIucm93QXNDaGlsZE9mR3JpZFJldHVybi5tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLnNldExvY2FsU2VsZWN0ZWQsXG4gICAgICAgIGRpc2FibGVkOiBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMuZGlzYWJsZWQsXG4gICAgICAgIHNldFRhYmJhYmxlQ29sdW1uSW5kZXg6IHIucm93QXNDaGlsZE9mR3JpZFJldHVybi5ncmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMuc2V0VGFiYmFibGVDb2x1bW5JbmRleCxcbiAgICAgICAgZ2V0U29ydFZhbHVlOiByb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVycy5zb3J0YWJsZUNoaWxkUGFyYW1ldGVycy5nZXRTb3J0VmFsdWVcbiAgICB9XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZFJldHVybiB9ID0gdXNlTWFuYWdlZENoaWxkPFJNPih7IGNvbnRleHQ6IHsgbWFuYWdlZENoaWxkQ29udGV4dDogbWNjMSB9LCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0gfSwgeyAuLi5iYXNlSW5mbywgLi4uY29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMgfSBhcyBSTSlcblxuXG4gICAgY29uc3QgY29udGV4dCA9IHVzZVN0YWJsZU9iamVjdDxDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93Q29udGV4dDxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgQ00+Pih7XG4gICAgICAgIG1hbmFnZWRDaGlsZENvbnRleHQsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0OiByLnJvd0FzUGFyZW50T2ZDZWxsc1JldHVybi5yb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dDogci5yb3dBc1BhcmVudE9mQ2VsbHNSZXR1cm4udHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCxcbiAgICAgICAgY29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7IG9uUHJlc3NTeW5jOiByLnJvd0FzQ2hpbGRPZkdyaWRSZXR1cm4ucHJlc3NQYXJhbWV0ZXJzLm9uUHJlc3NTeW5jIGFzIGFueSB9KSxcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dDogci5yb3dBc1BhcmVudE9mQ2VsbHNSZXR1cm4uZ3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dCxcbiAgICB9KTtcbiAgICBjb25zdCB7IGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMgfSA9IHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGQoeyBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dCB9KTtcbiAgICAvL2NvbnN0IHsgcmVmRWxlbWVudFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxSb3dFbGVtZW50Pih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KVxuICAgIGNvbnN0IHsgaGFzQ3VycmVudEZvY3VzUmV0dXJuIH0gPSB1c2VIYXNDdXJyZW50Rm9jdXMoeyByZWZFbGVtZW50UmV0dXJuLCBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7IC4uLmhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMsIG9uQ3VycmVudEZvY3VzZWRDaGFuZ2VkOiBudWxsIH0gfSk7XG4gICAgY29uc3QgcHJvcHMgPSB1c2VNZXJnZWRQcm9wcyhcbiAgICAgICAgcmVmRWxlbWVudFJldHVybi5wcm9wc1N0YWJsZSxcbiAgICAgICAgLy8gVE9ETzogUm93cyBkb24ndCB1c2UgdGFiSW5kZXgsIGJ1dCBqdXN0IGV4Y2x1ZGluZyBwcm9wcyBoZXJlIGlzLi4ud2VpcmQuXG4gICAgICAgIC8vci5yb3dBc0NoaWxkT2ZHcmlkUmV0dXJuLnJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4ucHJvcHNVbnN0YWJsZSxcbiAgICAgICAgci5yb3dBc0NoaWxkT2ZHcmlkUmV0dXJuLnNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuLnByb3BzVW5zdGFibGUsXG4gICAgICAgIHIucm93QXNQYXJlbnRPZkNlbGxzUmV0dXJuLmxpbmVhck5hdmlnYXRpb25SZXR1cm4ucHJvcHNTdGFibGUsXG4gICAgICAgIHIucm93QXNQYXJlbnRPZkNlbGxzUmV0dXJuLnR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4ucHJvcHNTdGFibGUsXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybi5wcm9wc1N0YWJsZVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJvd0FzUGFyZW50T2ZDZWxsc1JldHVybjoge1xuICAgICAgICAgICAgLi4ucm93QXNQYXJlbnRPZkNlbGxzUmV0dXJuLFxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuXG4gICAgICAgIH0sXG4gICAgICAgIHJvd0FzQ2hpbGRPZkdyaWRSZXR1cm46IHtcbiAgICAgICAgICAgIC4uLnJvd0FzQ2hpbGRPZkdyaWRSZXR1cm4sXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm5cbiAgICAgICAgfSxcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuXG5cbiAgICAgICAgLy9tYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIC8vLi4uZ3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbDxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50Pj4oe1xuICAgIGdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnMsXG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICBjb250ZXh0OiB7IGNvbXBsZXRlR3JpZE5hdmlnYXRpb25Db250ZXh0LCBncmlkTmF2aWdhdGlvbkNlbGxDb250ZXh0LCBtYW5hZ2VkQ2hpbGRDb250ZXh0LCByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCwgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCB9LFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICAvL21hbmFnZWRDaGlsZENvbnRleHQsXG4gICAgY29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzLFxuICAgIC8vc29ydGFibGVDaGlsZFBhcmFtZXRlcnM6IHsgZ2V0U29ydFZhbHVlIH0sXG4gICAgcHJlc3NQYXJhbWV0ZXJzOiB7IG9uUHJlc3NTeW5jLCAuLi5wcmVzc1BhcmFtZXRlcnMgfSxcbn06IFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgTT4pOiBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQsIE0+IHtcblxuICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM7XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8Q2VsbEVsZW1lbnQ+KHsgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9IH0pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLFxuICAgICAgICB0ZXh0Q29udGVudFJldHVyblxuICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNlbGw8Q2VsbEVsZW1lbnQ+KHtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dCxcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVycyxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnNcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgaGFzQ3VycmVudEZvY3VzUmV0dXJuIH0gPSB1c2VIYXNDdXJyZW50Rm9jdXM8Q2VsbEVsZW1lbnQ+KHsgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczogeyBvbkN1cnJlbnRGb2N1c2VkQ2hhbmdlZDogbnVsbCwgLi4uaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVycyB9LCByZWZFbGVtZW50UmV0dXJuIH0pO1xuXG5cblxuICAgIGNvbnN0IHsgcHJlc3NSZXR1cm4gfSA9IHVzZVByZXNzPENlbGxFbGVtZW50Pih7XG4gICAgICAgIHByZXNzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25QcmVzc1N5bmM6IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvblByZXNzU3luYz4+KGUgPT4ge1xuICAgICAgICAgICAgICAgIG9uUHJlc3NTeW5jPy4oZSk7XG4gICAgICAgICAgICAgICAgY29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQub25QcmVzc1N5bmM/LihlKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLi4ucHJlc3NQYXJhbWV0ZXJzXG4gICAgICAgIH0sXG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm5cbiAgICB9KTtcblxuXG5cbiAgICBjb25zdCBiYXNlSW5mbzogR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4gPSB7XG4gICAgICAgIGZvY3VzU2VsZjogcHJlc3NQYXJhbWV0ZXJzLmZvY3VzU2VsZixcbiAgICAgICAgZ2V0RWxlbWVudDogcmVmRWxlbWVudFJldHVybi5nZXRFbGVtZW50LFxuICAgICAgICBoaWRkZW46IHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLmhpZGRlbixcbiAgICAgICAgaW5kZXg6IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMuaW5kZXgsXG4gICAgICAgIGdldFRhYmJhYmxlOiByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLmdldFRhYmJhYmxlLFxuICAgICAgICBzZXRUYWJiYWJsZTogcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybi5zZXRUYWJiYWJsZSxcbiAgICAgICAgdGFiYmFibGU6IHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4udGFiYmFibGUsXG4gICAgICAgIC8vZ2V0U29ydFZhbHVlXG4gICAgfVxuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRSZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZDxNPih7XG4gICAgICAgIGNvbnRleHQ6IHsgbWFuYWdlZENoaWxkQ29udGV4dCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH1cbiAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAuLi5iYXNlSW5mbyxcbiAgICAgICAgICAgIC4uLmNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyc1xuICAgICAgICB9IGFzIE0pXG5cbiAgICBjb25zdCBwcm9wcyA9IHVzZU1lcmdlZFByb3BzKFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuLnByb3BzU3RhYmxlLFxuICAgICAgICBwcmVzc1JldHVybi5wcm9wc1N0YWJsZSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybi5wcm9wc1Vuc3RhYmxlLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4ucHJvcHNTdGFibGVcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4sXG4gICAgICAgIHByZXNzUmV0dXJuLFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgdGV4dENvbnRlbnRSZXR1cm5cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiwgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCB9IGZyb20gXCIuLi9jb21wb25lbnQtZGV0YWlsL3VzZS1saXN0LW5hdmlnYXRpb24tc2luZ2xlLXNlbGVjdGlvblwiO1xuaW1wb3J0IHsgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkUmV0dXJuVHlwZSwgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL2NvbXBvbmVudC1kZXRhaWwvdXNlLWxpc3QtbmF2aWdhdGlvbi1zaW5nbGUtc2VsZWN0aW9uLXNvcnRhYmxlXCI7XG5pbXBvcnQgeyBVc2VTb3J0YWJsZUNoaWxkSW5mbywgdXNlU29ydGFibGVDaGlsZHJlbiB9IGZyb20gXCIuLi9jb21wb25lbnQtZGV0YWlsL3VzZS1zb3J0YWJsZS1jaGlsZHJlblwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi4vZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCIuLi9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZUNoaWxkcmVuSGF2ZUZvY3VzLCB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkLCBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVycywgVXNlQ2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL29ic2VydmVycy91c2UtY2hpbGRyZW4taGF2ZS1mb2N1c1wiO1xuaW1wb3J0IHsgdXNlSGFzQ3VycmVudEZvY3VzLCBVc2VIYXNDdXJyZW50Rm9jdXNSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL29ic2VydmVycy91c2UtaGFzLWN1cnJlbnQtZm9jdXNcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZHJlbiwgdXNlTWFuYWdlZENoaWxkLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUsIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZU9iamVjdCB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlUHJlc3MsIFVzZVByZXNzUGFyYW1ldGVycywgVXNlUHJlc3NSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXByZXNzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4+IGV4dGVuZHMgUGljazxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUGFyYW1ldGVyczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+LCBcInNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNcIj4ge1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVQYXJhbWV0ZXJzPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT5bXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJnZXRIaWdoZXN0SW5kZXhcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiB8IFwiaW5kZXhNYW5nbGVyXCIgfCBcImlzVmFsaWRcIj47XG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPltcInR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXCJdLCBcImlzVmFsaWRcIj47XG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogT21pdDxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUGFyYW1ldGVyczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+W1wicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiXSwgXCJnZXRIaWdoZXN0Q2hpbGRJbmRleFwiIHwgXCJnZXRWYWxpZFwiPjtcbiAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPltcInNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXCJdO1xuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogT21pdDxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUGFyYW1ldGVyczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+W1wicm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzXCJdLCBcImluaXRpYWxseVRhYmJlZEluZGV4XCI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+PlxuICAgIGV4dGVuZHMgUGljazxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+LCBcInJvdmluZ1RhYkluZGV4UmV0dXJuXCIgfCBcInNpbmdsZVNlbGVjdGlvblJldHVyblwiIHwgXCJsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuXCIgfCBcInR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5cIiB8IFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuXCIgfCBcInNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5cIj4ge1xuICAgIHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PjtcbiAgICBjb250ZXh0OiBDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ29udGV4dDxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+O1xuXG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdO1xuICAgIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuOiBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGU8Q2hpbGRFbGVtZW50PltcImNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuXCJdO1xuICAgIC8vcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogUGljazxVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzW1wicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiXSwgXCJnZXRIaWdoZXN0Q2hpbGRJbmRleFwiIHwgXCJnZXRWYWxpZFwiPjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0PFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+PiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TT4sXG4gICAgUGljazxVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGU8Q2hpbGRFbGVtZW50PiwgXCJjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dFwiPixcbiAgICBQaWNrPFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4sIFwic2luZ2xlU2VsZWN0aW9uQ29udGV4dFwiIHwgXCJyb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dFwiIHwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0XCI+IHtcbiAgICBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dDogVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcImNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRDb250ZXh0XCJdO1xufVxuXG4vKipcbiAqIEFsbCB0aGUgbGlzdC1yZWxhdGVkIGhvb2tzIGNvbWJpbmVkIGludG8gb25lIGdpYW50IGhvb2sgdGhhdCBlbmNhcHN1bGF0ZXMgZXZlcnl0aGluZy5cbiAqIFxuICogVW5saWtlIG1vc3Qgb3RoZXJzLCB0aGlzIGhvb2sgYXNzdW1lJ3MgaXQncyB0aGUgZmluYWwgb25lLS10aGUgXCJvdXRlcm1vc3RcIiBob29rIGluIHRoZSBjb21wb25lbnQtLXNvIGl0IHVzZXMgYHVzZU1hbmFnZWRDaGlsZHJlbmAgYW5kIHdyYXBzIGV2ZXJ5dGhpbmcgdXAgbmljZWx5LFxuICogY29tYmluaW5nIGV2ZW50IGhhbmRsZXJzIHRoYXQgYXJlIHVzZWQgaW4gbXVsdGlwbGUgc3ViLWhvb2tzLCBjb2xsZWN0aW5nIGFsbCB0aGUgbmVjZXNzYXJ5IGNvbnRleHQtcmVsYXRlZCBkYXRhLCBhbmQgbWVyZ2luZyBhbGwga25vd24gRE9NIHByb3BzIHRvZ2V0aGVyLlxuICogXG4gKiBcbiAqIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+Pih7XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyxcbiAgICAuLi5jb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc1xufTogVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPik6IFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4ge1xuICAgIC8vdHlwZSBNID0gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZEluZm88Q2hpbGRFbGVtZW50PjtcbiAgICBjb25zdCB7IGluaXRpYWxseVNlbGVjdGVkSW5kZXggfSA9IHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM7XG4gICAgY29uc3QgZ2V0Q2hpbGRyZW46ICgpID0+IE1hbmFnZWRDaGlsZHJlbjxNPiA9IHVzZUNhbGxiYWNrKCgpID0+IG1hbmFnZWRDaGlsZHJlblJldHVybi5nZXRDaGlsZHJlbigpLCBbXSk7XG4gICAgY29uc3QgZ2V0SGlnaGVzdENoaWxkSW5kZXg6ICgoKSA9PiBudW1iZXIpID0gdXNlQ2FsbGJhY2s8KCkgPT4gbnVtYmVyPigoKSA9PiBnZXRDaGlsZHJlbigpLmdldEhpZ2hlc3RJbmRleCgpLCBbXSk7XG4gICAgY29uc3QgZ2V0VmFsaWQgPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gZ2V0Q2hpbGRyZW4oKS5nZXRBdChpKTtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICFjaGlsZC5oaWRkZW47XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm4gfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgTT4oe1xuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9ID0gcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ29udGV4dCxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdENoaWxkSW5kZXgsIGlzVmFsaWQ6IGdldFZhbGlkLCBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCAuLi5saW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBpc1ZhbGlkOiBnZXRWYWxpZCwgLi4udHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IGluaXRpYWxseVRhYmJlZEluZGV4OiBpbml0aWFsbHlTZWxlY3RlZEluZGV4LCAuLi5yb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgLi4uY29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgfSk7XG5cbiAgICAvL2NvbnN0IHsgbGluZWFyTmF2aWdhdGlvblJldHVybiwgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybiB9ID0gbGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVJldHVybjtcblxuICAgIGNvbnN0IHsgY2hpbGRyZW5IYXZlRm9jdXNDaGlsZENvbnRleHQsIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuIH0gPSB1c2VDaGlsZHJlbkhhdmVGb2N1cyh7IGNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyB9KTtcbiAgICBjb25zdCB7IGNvbnRleHQ6IHsgbWFuYWdlZENoaWxkQ29udGV4dCB9LCBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxNPih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMgfSk7XG4gICAgY29uc3QgcHJvcHMgPSB1c2VNZXJnZWRQcm9wczxQYXJlbnRFbGVtZW50PihsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLnByb3BzU3RhYmxlLCB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuLnByb3BzU3RhYmxlKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlU3RhYmxlT2JqZWN0PENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0PFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4+KHtcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ29udGV4dCxcbiAgICAgICAgbWFuYWdlZENoaWxkQ29udGV4dCxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRDb250ZXh0XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBwcm9wcyxcblxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+LCBFeHRyYU9taXRzIGV4dGVuZHMga2V5b2YgTT4ge1xuICAgIGNvbnRleHQ6IENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0PGFueSwgQ2hpbGRFbGVtZW50LCBNPjtcbiAgICBwcmVzc1BhcmFtZXRlcnM6IFVzZVByZXNzUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1wicHJlc3NQYXJhbWV0ZXJzXCJdO1xuICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1wic2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzXCJdO1xuICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1widGV4dENvbnRlbnRQYXJhbWV0ZXJzXCJdO1xuICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IE9taXQ8TSwga2V5b2YgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+IHwgRXh0cmFPbWl0cz47XG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcInJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzXCJdO1xuICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIl07XG4gICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnM6IFBpY2s8VXNlU29ydGFibGVDaGlsZEluZm8sIFwiZ2V0U29ydFZhbHVlXCI+O1xuICAgIC8vc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiBQaWNrPFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiXSwgXCJkaXNhYmxlZFwiPjtcbiAgICAvL21hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+LCBcImdldEVsZW1lbnRcIiB8IFwiZ2V0U2VsZWN0ZWRcIiB8IFwic2V0U2VsZWN0ZWRcIiB8IFwiZ2V0VGFiYmFibGVcIiB8IFwic2V0VGFiYmFibGVcIiB8IFwidGFiYmFibGVcIiB8IFwic2VsZWN0ZWRcIiB8IFwiZm9jdXNTZWxmXCI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm88Q2hpbGRFbGVtZW50Pj5cbiAgICBleHRlbmRzIFBpY2s8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+LCBcInNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuXCIgfCBcInJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5cIj4ge1xuICAgIHByZXNzUmV0dXJuOiBVc2VQcmVzc1JldHVyblR5cGU8Q2hpbGRFbGVtZW50PltcInByZXNzUmV0dXJuXCJdO1xuICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybjogVXNlSGFzQ3VycmVudEZvY3VzUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+W1wiaGFzQ3VycmVudEZvY3VzUmV0dXJuXCJdO1xuICAgIG1hbmFnZWRDaGlsZFJldHVybjogVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxNPltcIm1hbmFnZWRDaGlsZFJldHVyblwiXTtcbiAgICBwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+LCBFeHRyYU9taXRzIGV4dGVuZHMgRXhjbHVkZTxrZXlvZiBNLCBrZXlvZiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4+Pih7XG4gICAgLy9tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbiwgZGlzYWJsZWQsIGluZGV4LCBnZXRTb3J0VmFsdWUgfSxcbiAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICBjb250ZXh0OiB7IGNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRDb250ZXh0LCBtYW5hZ2VkQ2hpbGRDb250ZXh0LCByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCwgc2luZ2xlU2VsZWN0aW9uQ29udGV4dCwgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCB9LFxuICAgIHByZXNzUGFyYW1ldGVyczogeyBvblByZXNzU3luYzogb3BzMSwgLi4ucHJlc3NQYXJhbWV0ZXJzIH0sXG4gICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnM6IHsgZ2V0U29ydFZhbHVlIH0sXG4gICAgLi4uX3ZvaWRcbn06IFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBNLCBFeHRyYU9taXRzPik6IFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50LCBNPiB7XG4gICAgY29uc3QgeyBoaWRkZW4gfSA9IHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzO1xuICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM7XG4gICAgbGV0IHsgZGlzYWJsZWQgfSA9IHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycztcbiAgICBpZiAoaGlkZGVuKVxuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8Q2hpbGRFbGVtZW50Pih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcbiAgICBjb25zdCB7IGdldEVsZW1lbnQgfSA9IHJlZkVsZW1lbnRSZXR1cm47XG4gICAgY29uc3QgeyBmb2N1c1NlbGYgfSA9IHByZXNzUGFyYW1ldGVycztcbiAgICBjb25zdCB7XG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogb2NmaWMxIH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczogeyBvblByZXNzU3luYzogb3BzMiwgLi4ucDEgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgc2V0TG9jYWxTZWxlY3RlZCB9XG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50Pih7XG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IHsgaGlkZGVuIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczogeyAuLi5zaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNvbnRleHQsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHsgZ2V0VGFiYmFibGUsIHNldFRhYmJhYmxlLCB0YWJiYWJsZSB9ID0gcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybjtcblxuICAgIGNvbnN0IHsgcHJlc3NSZXR1cm4gfSA9IHVzZVByZXNzPENoaWxkRWxlbWVudD4oe1xuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIC4uLnAxLFxuICAgICAgICAgICAgLi4ucHJlc3NQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgb25QcmVzc1N5bmM6IGRpc2FibGVkID8gbnVsbCA6ICgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIG9wczI/LihlKTtcbiAgICAgICAgICAgICAgICBvcHMxPy4oZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCByZWZFbGVtZW50UmV0dXJuXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IGdldFNlbGVjdGVkLCBzZWxlY3RlZCB9ID0gc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm47XG5cbiAgICBjb25zdCBtY3AxOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4gPSB7XG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICBmb2N1c1NlbGYsXG4gICAgICAgIGdldEVsZW1lbnQsXG4gICAgICAgIGdldFNlbGVjdGVkLFxuICAgICAgICBnZXRUYWJiYWJsZSxcbiAgICAgICAgaGlkZGVuLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgIHNldExvY2FsU2VsZWN0ZWQsXG4gICAgICAgIHNldFRhYmJhYmxlLFxuICAgICAgICB0YWJiYWJsZSxcbiAgICAgICAgZ2V0U29ydFZhbHVlXG4gICAgfVxuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRSZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZDxNPih7IGNvbnRleHQ6IHsgbWFuYWdlZENoaWxkQ29udGV4dCB9LCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0gfSwgeyAuLi5tY3AxLCAuLi5jb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzIH0gYXMgTSk7XG5cbiAgICBjb25zdCB7IGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogb2NmaWMyIH0gfSA9IHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGQoeyBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dCB9KTtcbiAgICBjb25zdCBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9jZmljMT4+KChmb2N1c2VkLCBwcmV2LCBlKSA9PiB7XG4gICAgICAgIG9jZmljMT8uKGZvY3VzZWQsIHByZXYsIGUpO1xuICAgICAgICBvY2ZpYzI/Lihmb2N1c2VkLCBwcmV2LCBlKTtcbiAgICB9KVxuICAgIGNvbnN0IHsgaGFzQ3VycmVudEZvY3VzUmV0dXJuIH0gPSB1c2VIYXNDdXJyZW50Rm9jdXM8Q2hpbGRFbGVtZW50Pih7IGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25DdXJyZW50Rm9jdXNlZENoYW5nZWQ6IG51bGwgfSwgcmVmRWxlbWVudFJldHVybiB9KTtcblxuXG4gICAgY29uc3QgcHJvcHMgPSB1c2VNZXJnZWRQcm9wczxDaGlsZEVsZW1lbnQ+KFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuLnByb3BzU3RhYmxlLFxuICAgICAgICBwcmVzc1JldHVybi5wcm9wc1N0YWJsZSxcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuLnByb3BzU3RhYmxlLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLnByb3BzVW5zdGFibGUsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuLnByb3BzVW5zdGFibGVcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHByZXNzUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVybixcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm5cbiAgICB9XG5cbn1cblxuLypcbmZ1bmN0aW9uIGZvbzxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm88Q2hpbGRFbGVtZW50Pj4ocDogVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPikge1xuICAgIGNvbnN0IHsgc2luZ2xlU2VsZWN0aW9uUmV0dXJuIH0gPSB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4ocCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgdXNlU2luZ2xlU2VsZWN0aW9uRGVjbGFyYXRpdmUoeyBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sIHNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlUGFyYW1ldGVyczogeyBzZWxlY3RlZEluZGV4IH0gfSlcbn0qL1xuIiwiaW1wb3J0IHsgRGlzbWlzc0xpc3RlbmVyVHlwZXMsIHVzZURpc21pc3MsIFVzZURpc21pc3NQYXJhbWV0ZXJzLCBVc2VEaXNtaXNzUmV0dXJuVHlwZSB9IGZyb20gXCIuLi9jb21wb25lbnQtZGV0YWlsL3VzZS1kaXNtaXNzXCI7XG5pbXBvcnQgeyB1c2VGb2N1c1RyYXAsIFVzZUZvY3VzVHJhcFBhcmFtZXRlcnMsIFVzZUZvY3VzVHJhcFJldHVyblR5cGUgfSBmcm9tIFwiLi4vY29tcG9uZW50LWRldGFpbC91c2UtZm9jdXMtdHJhcFwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi4vZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VNb2RhbFBhcmFtZXRlcnM8TGlzdGVuZXJzIGV4dGVuZHMgRGlzbWlzc0xpc3RlbmVyVHlwZXM+IGV4dGVuZHMgVXNlRGlzbWlzc1BhcmFtZXRlcnM8TGlzdGVuZXJzPiB7XG4gICAgZm9jdXNUcmFwUGFyYW1ldGVyczogVXNlRm9jdXNUcmFwUGFyYW1ldGVyczxhbnksIGFueT5bXCJmb2N1c1RyYXBQYXJhbWV0ZXJzXCJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1vZGFsUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHwgbnVsbCwgU291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQgfCBudWxsLCBQb3B1cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZURpc21pc3NSZXR1cm5UeXBlPFNvdXJjZUVsZW1lbnQsIFBvcHVwRWxlbWVudD4ge1xuICAgIHByb3BzRm9jdXNDb250YWluZXI6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE5vbk51bGxhYmxlPEZvY3VzQ29udGFpbmVyRWxlbWVudD4+O1xuICAgIHByb3BzUG9wdXA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwRWxlbWVudD47XG4gICAgcHJvcHNTb3VyY2U6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE5vbk51bGxhYmxlPFNvdXJjZUVsZW1lbnQ+PjtcbiAgICBmb2N1c1RyYXBSZXR1cm46IE9taXQ8VXNlRm9jdXNUcmFwUmV0dXJuVHlwZTxOb25OdWxsYWJsZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+PltcImZvY3VzVHJhcFJldHVyblwiXSwgXCJwcm9wc1Vuc3RhYmxlXCI+O1xufVxuXG4vKipcbiAqIENvbWJpbmVzIGRpc21pc3NhbCBob29rcyBhbmQgZm9jdXMgdHJhcCBob29rcyBpbnRvIG9uZS5cbiAqIFxuICogQW5vdGhlciBpbiB0aGUgXCJjb21wbGV0ZVwiIHNlcmllcywgYWxvbmdzaWRlIGxpc3QvZ3JpZCBuYXZpZ2F0aW9uIGFuZCBkaXNtaXNzYWwgaXRzZWxmLlxuICogXG4gKiBVc2UgZm9yIGRpYWxvZ3MsIG1lbnVzLCBldGMuICBBbnl0aGluZyB0aGF0IGNhbiBiZSBkaXNtaXNzZWQgYW5kIG1pZ2h0IHRyYXAgZm9jdXMsIGJhc2ljYWxseS5cbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTW9kYWw8TGlzdGVuZXJzIGV4dGVuZHMgRGlzbWlzc0xpc3RlbmVyVHlwZXMsIEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQgfCBudWxsLCBTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB8IG51bGwsIFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBkaXNtaXNzUGFyYW1ldGVycyxcbiAgICBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycyxcbiAgICBmb2N1c1RyYXBQYXJhbWV0ZXJzOiB7IHRyYXBBY3RpdmUsIC4uLmZvY3VzVHJhcFBhcmFtZXRlcnMgfVxufTogVXNlTW9kYWxQYXJhbWV0ZXJzPExpc3RlbmVycz4pOiBVc2VNb2RhbFJldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBQb3B1cEVsZW1lbnQ+IHtcbiAgICBjb25zdCB7IG9wZW4gfSA9IGRpc21pc3NQYXJhbWV0ZXJzO1xuICAgIC8vY29uc3QgeyBnZXRXaW5kb3cgfSA9IGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzO1xuICAgIC8vY29uc3QgZ2V0RG9jdW1lbnQgPSB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiBnZXRXaW5kb3coKS5kb2N1bWVudDsgfSwgW2dldFdpbmRvd10pO1xuICAgIGNvbnN0IHsgcmVmRWxlbWVudFBvcHVwUmV0dXJuLCByZWZFbGVtZW50U291cmNlUmV0dXJuIH0gPSB1c2VEaXNtaXNzPExpc3RlbmVycywgU291cmNlRWxlbWVudCwgUG9wdXBFbGVtZW50Pih7IGRpc21pc3NQYXJhbWV0ZXJzLCBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycyB9KTtcbiAgICBjb25zdCB7IGZvY3VzVHJhcFJldHVybiwgcmVmRWxlbWVudFJldHVybiB9ID0gdXNlRm9jdXNUcmFwPFNvdXJjZUVsZW1lbnQsIE5vbk51bGxhYmxlPEZvY3VzQ29udGFpbmVyRWxlbWVudD4+KHtcbiAgICAgICAgZm9jdXNUcmFwUGFyYW1ldGVyczogeyB0cmFwQWN0aXZlOiBvcGVuICYmIHRyYXBBY3RpdmUsIC4uLmZvY3VzVHJhcFBhcmFtZXRlcnMgfSxcbiAgICAgICAgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHByb3BzU3RhYmxlOiBwcDEgfSA9IHJlZkVsZW1lbnRQb3B1cFJldHVybjtcbiAgICBjb25zdCB7IHByb3BzU3RhYmxlOiBwczIgfSA9IHJlZkVsZW1lbnRTb3VyY2VSZXR1cm47XG4gICAgY29uc3QgeyBwcm9wc1Vuc3RhYmxlOiBwcDMgfSA9IGZvY3VzVHJhcFJldHVybjtcbiAgICBjb25zdCB7IHByb3BzU3RhYmxlOiBwcDQgfSA9IHJlZkVsZW1lbnRSZXR1cm5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzUG9wdXA6IHBwMSxcbiAgICAgICAgcHJvcHNGb2N1c0NvbnRhaW5lcjogdXNlTWVyZ2VkUHJvcHMocHAzLCBwcDQpLFxuICAgICAgICBwcm9wc1NvdXJjZTogcHMyLFxuICAgICAgICByZWZFbGVtZW50UG9wdXBSZXR1cm4sXG4gICAgICAgIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm4sXG4gICAgICAgIGZvY3VzVHJhcFJldHVybixcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlSWQsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGdlbmVyYXRlUmFuZG9tSWQgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmV4cG9ydCB7IGdlbmVyYXRlUmFuZG9tSWQgfTtcblxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkUmV0dXJuVHlwZTxTIGV4dGVuZHMgRWxlbWVudCwgVCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBwcm9wc1NvdXJjZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uz47XG4gICAgcHJvcHNSZWZlcmVuY2VyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcblxuICAgIC8qKlxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBUaGUgZWxlbWVudCB0aGF0IG5lZWRzIGEgY3VzdG9tIGBpZGAgcHJvcCBtdXN0IHVzZSB0aGlzIGhvb2suXG4gICAgICovXG4gICAgLy91c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTPjtcblxuICAgIC8qKlxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBBbnkgZWxlbWVudCB0aGF0IHJlZmVyZW5jZXMgdGhlIGlkIHZpYSBgZm9yYCBvciBgYXJpYS1sYWJlbGxlZGJ5YCwgZXRjLiBtdXN0IHVzZSB0aGlzIGhvb2suXG4gICAgICogXG4gICAgICogVGhpcyBob29rIGNhbiBiZSB1c2VkIG11bHRpcGxlIHRpbWVzIG9uIGRpZmZlcmVudCBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIC8vdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDtcbiAgICByYW5kb21JZFJldHVybjogeyBpZDogc3RyaW5nOyB9O1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFBhcmFtZXRlcnMge1xuICAgIHJhbmRvbUlkUGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hpbGUgYWxsIElEcyBhcmUgdW5pcXVlLCB0aGlzIGNhbiBiZSB1c2VkIHRvIG1vcmUgZWFzaWx5IGRpZmZlcmVudGlhdGUgdGhlbS5cbiAgICAgICAgICogXG4gICAgICAgICAqIElmIHRoaXMgaXMgc3RhYmxlLCB0aGVuIHlvdXIgcHJvcHMgYXJlIHN0YWJsZS4gU2ltcGxlIGFzIHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBwcmVmaXg6IHN0cmluZztcbiAgICBcbiAgICAgICAgLyoqIFRoaXMgaXMgdGhlIHByb3Agb24gdGhlICoqT1RIRVIqKiBlbGVtZW50IHRoYXQgd2lsbCB1c2Ugb3VyIElELiAgRS5HLiBUaGUgYGlucHV0YCBjYWxscyBgdXNlUmFuZG9tSWRgIGFuZCBwYXNzZXMgYGZvcmAgYXMgYHJlZmVyZW5jZXJQcm9wYC4gKi9cbiAgICAgICAgb3RoZXJSZWZlcmVuY2VyUHJvcDoga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiB8IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUmFuZG9tSWQ8UyBleHRlbmRzIEVsZW1lbnQsIFQgZXh0ZW5kcyBFbGVtZW50Pih7IHJhbmRvbUlkUGFyYW1ldGVyczogeyBwcmVmaXgsIG90aGVyUmVmZXJlbmNlclByb3AgfSB9OiBVc2VSYW5kb21JZFBhcmFtZXRlcnMpOiBVc2VSYW5kb21JZFJldHVyblR5cGU8UywgVD4ge1xuICAgIGNvbnN0IGlkID0gKHByZWZpeCArIHVzZUlkKCkpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVJhbmRvbUlkXCIsIHByZWZpeCwgaWQpO1xuXG4gICAgY29uc3QgcmVmZXJlbmNlckVsZW1lbnRQcm9wcyA9IHVzZVJlZjxoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+PihvdGhlclJlZmVyZW5jZXJQcm9wID09IG51bGwgPyB7fSA6IHsgW290aGVyUmVmZXJlbmNlclByb3BdOiBpZCB9KTtcbiAgICBjb25zdCBzb3VyY2VFbGVtZW50UHJvcHMgPSB1c2VSZWY8aC5KU1guSFRNTEF0dHJpYnV0ZXM8Uz4+KHsgaWQgfSk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFwiLCBvdGhlclJlZmVyZW5jZXJQcm9wKTtcbiAgICBcblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzUmVmZXJlbmNlcjogcmVmZXJlbmNlckVsZW1lbnRQcm9wcy5jdXJyZW50LFxuICAgICAgICBwcm9wc1NvdXJjZTogc291cmNlRWxlbWVudFByb3BzLmN1cnJlbnQsXG4gICAgICAgIHJhbmRvbUlkUmV0dXJuOiB7XG4gICAgICAgICAgICBpZDogaWRcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4uL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VSYW5kb21JZCwgVXNlUmFuZG9tSWRQYXJhbWV0ZXJzLCBVc2VSYW5kb21JZFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmFuZG9tLWlkXCI7XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21EdWFsSWRzUGFyYW1ldGVycyB7XG4gICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IFVzZVJhbmRvbUlkUGFyYW1ldGVyc1tcInJhbmRvbUlkUGFyYW1ldGVyc1wiXTtcbiAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogVXNlUmFuZG9tSWRQYXJhbWV0ZXJzW1wicmFuZG9tSWRQYXJhbWV0ZXJzXCJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUR1YWxJZHNSZXR1cm5UeXBlPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBwcm9wc0lucHV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+O1xuICAgIHByb3BzTGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XG4gICAgcmFuZG9tSWRJbnB1dFJldHVybjogVXNlUmFuZG9tSWRSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcInJhbmRvbUlkUmV0dXJuXCJdO1xuICAgIHJhbmRvbUlkTGFiZWxSZXR1cm46IFVzZVJhbmRvbUlkUmV0dXJuVHlwZTxMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudD5bXCJyYW5kb21JZFJldHVyblwiXTtcbn1cblxuLyoqXG4gKiBXaGlsZSBgdXNlUmFuZG9tSWRgIGFsbG93cyB0aGUgcmVmZXJlbmNlciB0byB1c2UgdGhlIHNvdXJjZSdzIElELCBzb21ldGltZXMgeW91IGFsc28gd2FudCB0aGUgcmV2ZXJzZSB0b28gKGUuZy4gSSBgYXJpYS1sYWJlbGAgeW91LCB5b3UgYGFyaWEtY29udHJvbHNgIG1lLiBUaGF0IHNvcnQgb2YgdGhpbmcpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmFuZG9tRHVhbElkczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMsXG4gICAgcmFuZG9tSWRMYWJlbFBhcmFtZXRlcnMsXG59OiBVc2VSYW5kb21EdWFsSWRzUGFyYW1ldGVycyk6IFVzZVJhbmRvbUR1YWxJZHNSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XG5cbiAgICBjb25zdCB7IHJhbmRvbUlkUmV0dXJuOiByYW5kb21JZElucHV0UmV0dXJuLCBwcm9wc1JlZmVyZW5jZXI6IHByb3BzTGFiZWxBc1JlZmVyZW5jZXIsIHByb3BzU291cmNlOiBwcm9wc0lucHV0QXNTb3VyY2UgfSA9IHVzZVJhbmRvbUlkPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pih7IHJhbmRvbUlkUGFyYW1ldGVyczogcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMgfSk7XG4gICAgY29uc3QgeyByYW5kb21JZFJldHVybjogcmFuZG9tSWRMYWJlbFJldHVybiwgcHJvcHNSZWZlcmVuY2VyOiBwcm9wc0lucHV0QXNSZWZlcmVuY2VyLCBwcm9wc1NvdXJjZTogcHJvcHNMYWJlbEFzU291cmNlIH0gPSB1c2VSYW5kb21JZDxMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudD4oeyByYW5kb21JZFBhcmFtZXRlcnM6IHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHNMYWJlbDogdXNlTWVyZ2VkUHJvcHM8TGFiZWxFbGVtZW50Pihwcm9wc0xhYmVsQXNSZWZlcmVuY2VyLCBwcm9wc0xhYmVsQXNTb3VyY2UpLFxuICAgICAgICBwcm9wc0lucHV0OiB1c2VNZXJnZWRQcm9wczxJbnB1dEVsZW1lbnQ+KHByb3BzSW5wdXRBc1JlZmVyZW5jZXIsIHByb3BzSW5wdXRBc1NvdXJjZSksXG4gICAgICAgIHJhbmRvbUlkSW5wdXRSZXR1cm4sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxSZXR1cm5cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxudHlwZSBSYWZDYWxsYmFja1R5cGUgPSAobXNTaW5jZUxhc3Q6IG51bWJlciwgdGFnPzogYW55KSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgQ29udGV4dFR5cGUge1xuICAgIGFkZENhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSwgdGFnPzogYW55KSA9PiB2b2lkO1xuICAgIHJlbW92ZUNhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxudWxsIHwgQ29udGV4dFR5cGU+KG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gUHJvdmlkZUJhdGNoZWRBbmltYXRpb25GcmFtZXMoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbiB9KSB7XG5cbiAgICBjb25zdCBhZGRDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wiYWRkQ2FsbGJhY2tcIl0+KChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuc2V0KGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZyk7IH0sIFtdKTtcbiAgICBjb25zdCByZW1vdmVDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wicmVtb3ZlQ2FsbGJhY2tcIl0+KChjYWxsYmFjaykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5kZWxldGUoY2FsbGJhY2spOyB9LCBbXSk7XG5cbiAgICBjb25zdCBjb250ZXh0SW5mbyA9IHVzZVJlZjxDb250ZXh0VHlwZT4obnVsbCEpO1xuICAgIGlmIChjb250ZXh0SW5mby5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGNvbnRleHRJbmZvLmN1cnJlbnQgPSB7IGFkZENhbGxiYWNrLCByZW1vdmVDYWxsYmFjayB9O1xuICAgIGNvbnN0IGFsbENhbGxiYWNrcyA9IHVzZVJlZjxNYXA8UmFmQ2FsbGJhY2tUeXBlLCBhbnk+PihudWxsISk7XG4gICAgaWYgKGFsbENhbGxiYWNrcy5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGFsbENhbGxiYWNrcy5jdXJyZW50ID0gbmV3IE1hcCgpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZSA9IC0xO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKG1zU2luY2VMYXN0OiBudW1iZXIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2JhdGNoZWRSYWZDYWxsYmFjaywgdGFnXSBvZiBhbGxDYWxsYmFja3MuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGJhdGNoZWRSYWZDYWxsYmFjayhtc1NpbmNlTGFzdCwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRJbmZvLmN1cnJlbnR9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L1NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlcj4pXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB3aXRoIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHJ1bGVzIGFzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXG4gICAgICogXG4gICAgICogRG9lc24ndCBuZWVkIHRvIGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBjYWxsYmFjazogbnVsbCB8ICgobXNTaW5jZUxhc3Q6IG51bWJlcikgPT4gdm9pZCk7XG59XG5cbi8qKlxuICogVGhlIChvcHRpb25hbGx5IG5vbi1zdGFibGUpIGBjYWxsYmFja2AgeW91IHByb3ZpZGUgd2lsbCBzdGFydCBydW5uaW5nIGV2ZXJ5IGZyYW1lIGFmdGVyIHRoZSBjb21wb25lbnQgbW91bnRzLlxuICogXG4gKiBQYXNzaW5nIGBudWxsYCBpcyBmaW5lIGFuZCBzaW1wbHkgc3RvcHMgdGhlIGVmZmVjdCB1bnRpbCB5b3UgcmVzdGFydCBpdCBieSBwcm92aWRpbmcgYSBub24tbnVsbCBjYWxsYmFjay5cbiAqIFxuICogKipUaGlzIGhvb2sgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGF0IGFsbCwgaW5jbHVkaW5nIG5vIHByb3AtbW9kaWZ5aW5nIGhvb2tzKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFuaW1hdGlvbkZyYW1lKHsgY2FsbGJhY2sgfTogVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIGdpdmVuIGNhbGxiYWNrIHRoYXQncyBzdGFibGVcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKGNhbGxiYWNrID8/IG5vb3ApO1xuICAgIGNvbnN0IGhhc0NhbGxiYWNrID0gKGNhbGxiYWNrICE9IG51bGwpO1xuXG4gICAgY29uc3Qgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gdXNlQ29udGV4dChTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LmFkZENhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5yZW1vdmVDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgd3JhcHBlciBhcm91bmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbHNvIGNhbGxzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFnYWluLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZkNhbGxiYWNrID0gKG1zOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlQ2FsbGJhY2sobXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQsIGhhc0NhbGxiYWNrXSlcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHsgfVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGltZW91dFBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbXMgdG8gd2FpdCBiZWZvcmUgaW52b2tpbmcgYGNhbGxiYWNrYC4gIFxuICAgICAqIElmIGBudWxsYCwgY2FuY2VscyB0aGUgdGltZW91dCBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICB0aW1lb3V0OiBudW1iZXIgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0byB0aGlzIHByb3AgYmV0d2VlbiByZW5kZXJzIGNhbiBiZSB1c2VkIHRvIGNsZWFyIHRoZSBjdXJyZW50IHRpbWVvdXQgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICovXG4gICAgdHJpZ2dlckluZGV4PzogdW5rbm93bjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBgdGltZW91dGAgbXMgYWZ0ZXIgbW91bnQsIG9yIHRoZSBsYXN0IGNoYW5nZSB0byBgdHJpZ2dlckluZGV4YC5cbiAgICAgKiBcbiAgICAgKiBEb2VzICpub3QqIG5lZWQgdG8gYmUgc3RhYmxlLiBHbyBhaGVhZCBhbmQgcGFzcyBhbiBhbm9ueW1vdXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUaW1lb3V0KHsgdGltZW91dCwgY2FsbGJhY2ssIHRyaWdnZXJJbmRleCB9OiBVc2VUaW1lb3V0UGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBzdGFydFRpbWVSZWYuY3VycmVudCA9IG51bGw7IGNhbGxiYWNrKCk7IH0pO1xuICAgIGNvbnN0IGdldFRpbWVvdXQgPSB1c2VTdGFibGVHZXR0ZXIodGltZW91dCk7XG5cbiAgICAvLyBTZXQgYW55IHRpbWUgd2Ugc3RhcnQgdGltZW91dC5cbiAgICAvLyBVbnNldCBhbnkgdGltZSB0aGUgdGltZW91dCBjb21wbGV0ZXNcbiAgICBjb25zdCBzdGFydFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCB0aW1lb3V0SXNOdWxsID0gKHRpbWVvdXQgPT0gbnVsbCk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgdHJpZ2dlckluZGV4IGNoYW5nZXMgKGluY2x1ZGluZyBvbiBtb3VudClcbiAgICAvLyByZXN0YXJ0IHRoZSB0aW1lb3V0LiAgVGhlIHRpbWVvdXQgZG9lcyBOT1QgcmVzZXRcbiAgICAvLyB3aGVuIHRoZSBkdXJhdGlvbiBvciBjYWxsYmFjayBjaGFuZ2VzLCBvbmx5IHRyaWdnZXJJbmRleC5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRpbWVvdXRJc051bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aW1lb3V0SXNOdWxsID09ICh0aW1lb3V0ID09IG51bGwpKTtcbiAgICBcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVSZWYuY3VycmVudCA9ICsobmV3IERhdGUoKSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChzdGFibGVDYWxsYmFjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sIFt0cmlnZ2VySW5kZXgsIHRpbWVvdXRJc051bGxdKVxuXG4gICAgY29uc3QgZ2V0RWxhcHNlZFRpbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKyhuZXcgRGF0ZSgpKSkgLSAoKyhzdGFydFRpbWVSZWYuY3VycmVudCA/PyBuZXcgRGF0ZSgpKSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0UmVtYWluaW5nVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgcmV0dXJuIHRpbWVvdXQgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1heCgwLCB0aW1lb3V0IC0gZ2V0RWxhcHNlZFRpbWUoKSlcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyBnZXRFbGFwc2VkVGltZSwgZ2V0UmVtYWluaW5nVGltZSB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzLCB1c2VQcmVzcywgVXNlUHJlc3NQYXJhbWV0ZXJzLCBVc2VQcmVzc1JldHVyblR5cGUsIHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBEaXNhYmxlZFR5cGUsIEVsZW1lbnRUb1RhZywgRW5oYW5jZWRFdmVudCwgZW5oYW5jZUV2ZW50IH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuXG5leHBvcnQgdHlwZSBCdXR0b25QcmVzc0V2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSBFbmhhbmNlZEV2ZW50PEUsIEV2ZW50IHwgRXZlbnQsIHsgcHJlc3NlZDogYm9vbGVhbiB8IG51bGwgfT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQnV0dG9uUGFyYW1ldGVyczxFIGV4dGVuZHMgTm9kZT4gZXh0ZW5kcyBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxFPiB7XG4gICAgYnV0dG9uUGFyYW1ldGVyczoge1xuICAgICAgICB0YWdCdXR0b246IEVsZW1lbnRUb1RhZzxFPjtcbiAgICAgICAgZGlzYWJsZWQ6IERpc2FibGVkVHlwZTtcbiAgICAgICAgcHJlc3NlZDogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgICAgIG9uUHJlc3M6IG51bGwgfCAoKGV2ZW50OiBCdXR0b25QcmVzc0V2ZW50PEU+KSA9PiB2b2lkKTtcbiAgICAgICAgcm9sZTogc3RyaW5nO1xuICAgIH1cbiAgICBwcmVzc1BhcmFtZXRlcnM6IE9taXQ8VXNlUHJlc3NQYXJhbWV0ZXJzPEU+W1wicHJlc3NQYXJhbWV0ZXJzXCJdLCBcIm9uUHJlc3NTeW5jXCIgfCBcImZvY3VzU2VsZlwiPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJ1dHRvblJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUHJlc3NSZXR1cm5UeXBlPEU+LCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiB7XG4gICAgcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJ1dHRvbjxFIGV4dGVuZHMgRWxlbWVudD4oeyBidXR0b25QYXJhbWV0ZXJzOiB7IHRhZ0J1dHRvbiwgZGlzYWJsZWQsIG9uUHJlc3MsIHByZXNzZWQsIHJvbGUgfSwgcHJlc3NQYXJhbWV0ZXJzLCByZWZFbGVtZW50UGFyYW1ldGVycyB9OiBVc2VCdXR0b25QYXJhbWV0ZXJzPEU+KTogVXNlQnV0dG9uUmV0dXJuVHlwZTxFPiB7XG4gICAgZGVidWdMb2coXCJ1c2VCdXR0b25cIik7XG5cbiAgICBjb25zdCByZWZFbGVtZW50UmV0dXJuID0gdXNlUmVmRWxlbWVudDxFPih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzIH0pO1xuICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKChlOiBhbnkpID0+IChlIGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmZvY3VzPy4oKSwgW10pXG4gICAgY29uc3QgcHJlc3NSZXR1cm4gPSB1c2VQcmVzczxFPih7XG4gICAgICAgIC4uLnJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25QcmVzc1N5bmM6IChlKSA9PiAoZGlzYWJsZWQgPyBudWxsIDogb25QcmVzcyk/LihlbmhhbmNlRXZlbnQoZSwgeyBwcmVzc2VkOiBwcmVzc2VkID09IG51bGwgPyBudWxsIDogIXByZXNzZWQgfSkpLFxuICAgICAgICAgICAgZm9jdXNTZWxmLFxuICAgICAgICAgICAgLi4ucHJlc3NQYXJhbWV0ZXJzXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHByZXNzUmV0dXJuOiB7IHByb3BzU3RhYmxlOiBwcmVzc1Byb3BzIH0gfSA9IHByZXNzUmV0dXJuO1xuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybjogeyBwcm9wc1N0YWJsZTogcmVmUHJvcHMgfSB9ID0gcmVmRWxlbWVudFJldHVybjtcblxuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHsgXCJhcmlhLXByZXNzZWRcIjogKHByZXNzZWQgPT09IHRydWUgPyBcInRydWVcIiA6IHByZXNzZWQgPT09IGZhbHNlID8gXCJmYWxzZVwiIDogdW5kZWZpbmVkKSB9O1xuICAgIGNvbnN0IGJ1dHRvblByb3BzID0geyAuLi5iYXNlUHJvcHMsIGRpc2FibGVkOiAoZGlzYWJsZWQgJiYgZGlzYWJsZWQgIT0gXCJzb2Z0XCIpID8gdHJ1ZSA6IGZhbHNlLCBcImFyaWEtZGlzYWJsZWRcIjogKGRpc2FibGVkID09PSAnc29mdCcgPyAndHJ1ZScgOiB1bmRlZmluZWQpLCByb2xlOiByb2xlID09IFwiYnV0dG9uXCIgPyB1bmRlZmluZWQgOiByb2xlIH07XG4gICAgY29uc3QgZGl2UHJvcHMgPSB7IC4uLmJhc2VQcm9wcywgdGFiSW5kZXg6IChkaXNhYmxlZCA9PT0gXCJoYXJkXCIgPyAtMSA6IDApLCByb2xlLCBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9O1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICAuLi5wcmVzc1JldHVybixcbiAgICAgICAgcHJvcHM6IHVzZU1lcmdlZFByb3BzPEU+KHByZXNzUHJvcHMsIHJlZlByb3BzLCAodGFnQnV0dG9uID09ICdidXR0b24nID8gYnV0dG9uUHJvcHMgOiBkaXZQcm9wcykpLFxuICAgIH1cbn1cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkSW5mbywgT25DaGlsZHJlbk1vdW50Q2hhbmdlLCBQYXNzaXZlU3RhdGVVcGRhdGVyLCB1c2VDaGlsZHJlbkZsYWcsIHVzZUxpbmVhck5hdmlnYXRpb24sIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGQsIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dCwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSwgdXNlTWVyZ2VkUHJvcHMsIFVzZVByZXNzUmV0dXJuVHlwZSwgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSwgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YWJsZU9iamVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBEaXNhYmxlZFR5cGUsIFByZWZpY2VzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IEJ1dHRvblByZXNzRXZlbnQsIHVzZUJ1dHRvbiwgVXNlQnV0dG9uUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcblxuLy9leHBvcnQgdHlwZSBVc2VBY2NvcmRpb248TSBleHRlbmRzIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvPiA9IChhcmdzOiBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzPE0+KSA9PiBVc2VBY2NvcmRpb25SZXR1cm5UeXBlPE0+O1xuLy9leHBvcnQgdHlwZSBVc2VBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4gPSAoYXJnczogVXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyRWxlbWVudCwgTT4pID0+IFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxNPiB7XG4gICAgYWNjb3JkaW9uUGFyYW1ldGVyczogeyBpbml0aWFsSW5kZXg/OiBudW1iZXIgfCBudWxsOyB9XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IE9taXQ8VXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudD5bXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJuYXZpZ2F0ZVJlbGF0aXZlXCIgfCBcIm5hdmlnYXRlQWJzb2x1dGVcIiB8IFwiZ2V0SGlnaGVzdEluZGV4XCIgfCBcImlzVmFsaWRcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiB8IFwiaW5kZXhNYW5nbGVyXCI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblJldHVyblR5cGU8SGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGFjY29yZGlvblJldHVybjogeyBjaGFuZ2VFeHBhbmRlZEluZGV4OiBQYXNzaXZlU3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGwsIEV2ZW50PiB9XG4gICAgY29udGV4dDogVXNlQWNjb3JkaW9uQ29udGV4dDxIZWFkZXJCdXR0b25FbGVtZW50LCBNPjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXI+IHtcbiAgICBzZXRPcGVuRnJvbVBhcmVudChvcGVuOiBib29sZWFuKTogdm9pZDtcbiAgICBnZXRPcGVuRnJvbVBhcmVudCgpOiBib29sZWFuIHwgbnVsbDtcbiAgICBzZXRNb3N0UmVjZW50bHlUYWJiZWQodGFiYmVkOiBib29sZWFuKTogdm9pZDtcbiAgICBnZXRNb3N0UmVjZW50bHlUYWJiZWQoKTogYm9vbGVhbiB8IG51bGw7XG4gICAgZm9jdXNTZWxmKCk6IHZvaWQ7XG4gICAgZGlzYWJsZWQ6IERpc2FibGVkVHlwZTtcbiAgICBoaWRkZW46IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4gZXh0ZW5kc1xuICAgIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQ+IHtcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBPbWl0PFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT5bXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCJdLCBcInNldE9wZW5Gcm9tUGFyZW50XCIgfCBcImdldE9wZW5Gcm9tUGFyZW50XCIgfCBcInNldE1vc3RSZWNlbnRseVRhYmJlZFwiIHwgXCJnZXRNb3N0UmVjZW50bHlUYWJiZWRcIiB8IFwiZm9jdXNTZWxmXCIgfCBcImRpc2FibGVkXCI+O1xuICAgIGNvbnRleHQ6IFVzZUFjY29yZGlvbkNvbnRleHQ8SGVhZGVyQnV0dG9uRWxlbWVudCwgTT47XG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IFBpY2s8VXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8YW55PltcInJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzXCJdLCBcImhpZGRlblwiPjtcbiAgICBhY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAvKiogXG4gICAgICAgICAqIElmIHRoaXMgcHJvcCBpcyBgdHJ1ZWAgb3IgYGZhbHNlYCBpc24ndCBudWxsLCB0aGVuIHRoaXMgc2VjdGlvblxuICAgICAgICAgKiB3aWxsIGJlIG9wZW4vY2xvc2VkIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgcGFyZW50J3Mgc2luZ3VsYXIgb3BlbiBpbmRleCBpcy5cbiAgICAgICAgICogXG4gICAgICAgICAqIEluIG90aGVyIHdvcmRzLCBsZWF2ZSBudWxsIHRvIG9ubHkgYWxsb3cgb25lIHNlY3Rpb24gdG8gYmUgb3BlbiBhdCBhIHRpbWUsXG4gICAgICAgICAqIG9yIHRvIGFsbG93IG11bHRpcGxlIHNlY3Rpb25zIHRvIGJlIG9wZW4gYXQgb25jZSwgXG4gICAgICAgICAqIHNldCB0aGUgcGFyZW50J3MgaW5kZXggdG8gbnVsbCBhbmQgdG9nZ2xlIHRoaXMgYHRydWVgL2BmYWxzZWAgd2hlbiB0aGUgYnV0dG9uJ3MgcHJlc3NlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3BlbjogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqIEdlbmVyYWxseSBgXCJyZWdpb25cImAgKi9cbiAgICAgICAgYm9keVJvbGU6IHN0cmluZztcbiAgICB9XG4gICAgYnV0dG9uUGFyYW1ldGVyczogT21pdDxVc2VCdXR0b25QYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQ+W1wiYnV0dG9uUGFyYW1ldGVyc1wiXSwgXCJwcmVzc2VkXCIgfCBcInJvbGVcIj47XG4gICAgcHJlc3NQYXJhbWV0ZXJzOiBPbWl0PFVzZUJ1dHRvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudD5bXCJwcmVzc1BhcmFtZXRlcnNcIl0sIFwib25QcmVzc1N5bmNcIj47XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZTxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VQcmVzc1JldHVyblR5cGU8SGVhZGVyQnV0dG9uRWxlbWVudD4sIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEhlYWRlckJ1dHRvbkVsZW1lbnQ+IHtcbiAgICBhY2NvcmRpb25TZWN0aW9uUmV0dXJuOiB7XG4gICAgICAgIGV4cGFuZGVkOiBib29sZWFuO1xuICAgICAgICBmb2N1c2VkOiBib29sZWFuO1xuICAgICAgICBtb3N0UmVjZW50bHlUYWJiZWQ6IGJvb2xlYW47XG4gICAgfVxuXG4gICAgcHJvcHNIZWFkZXJCdXR0b246IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckJ1dHRvbkVsZW1lbnQ+O1xuICAgIHByb3BzSGVhZGVyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PjtcbiAgICBwcm9wc0JvZHk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvbkNvbnRleHQ8SGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+IHtcbiAgICBhY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICBjaGFuZ2VUYWJiZWRJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsLCBFdmVudD47XG4gICAgICAgIGNoYW5nZUV4cGFuZGVkSW5kZXg6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbCwgRXZlbnQ+O1xuICAgICAgICBnZXRFeHBhbmRlZEluZGV4OiAoKSA9PiAobnVtYmVyIHwgbnVsbCk7XG4gICAgICAgIGdldFRhYmJlZEluZGV4OiAoKSA9PiAobnVtYmVyIHwgbnVsbCk7XG4gICAgfVxuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxIZWFkZXJCdXR0b25FbGVtZW50LCBIZWFkZXJCdXR0b25FbGVtZW50PltcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCJdO1xuICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuOiBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxIZWFkZXJCdXR0b25FbGVtZW50LCBIZWFkZXJCdXR0b25FbGVtZW50PltcInJvdmluZ1RhYkluZGV4UmV0dXJuXCJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQWNjb3JkaW9uPEhlYWRlckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+KHtcbiAgICBhY2NvcmRpb25QYXJhbWV0ZXJzOiB7IGluaXRpYWxJbmRleCB9LFxuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiwgbmF2aWdhdGVQYXN0RW5kLCBuYXZpZ2F0ZVBhc3RTdGFydCwgcGFnZU5hdmlnYXRpb25TaXplIH0sXG4gICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9XG59OiBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQsIE0+KTogVXNlQWNjb3JkaW9uUmV0dXJuVHlwZTxIZWFkZXJCdXR0b25FbGVtZW50LCBNPiB7XG4gICAgZGVidWdMb2coXCJ1c2VBY2NvcmRpYW5cIik7XG4gICAgLy9jb25zdCBbX2N1cnJlbnRGb2N1c2VkSW5kZXgsIHNldEN1cnJlbnRGb2N1c2VkSW5kZXgsIGdldEN1cnJlbnRGb2N1c2VkSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBtY1JldHVyblR5cGUgPSB1c2VNYW5hZ2VkQ2hpbGRyZW48TT4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobSwgdSkgPT4geyBvY21jMigpOyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihtLCB1KTsgfSksXG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3RcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHsgZ2V0Q2hpbGRyZW4gfSwgY29udGV4dCB9ID0gbWNSZXR1cm5UeXBlO1xuXG4gICAgY29uc3QgaXNWYWxpZCA9IHVzZUNhbGxiYWNrKChjOiBNKSA9PiAoIWMuZGlzYWJsZWQgJiYgIWMuaGlkZGVuKSwgW10pO1xuICAgIGNvbnN0IGlzVmFsaWQyID0gdXNlQ2FsbGJhY2soKGM6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGdldENoaWxkcmVuKCkuZ2V0QXQoYyk7XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBbXSk7XG5cblxuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXg6IGNoYW5nZUV4cGFuZGVkSW5kZXgsIGdldEN1cnJlbnRJbmRleDogZ2V0Q3VycmVudEV4cGFuZGVkSW5kZXggfSA9IHVzZUNoaWxkcmVuRmxhZzxNLCBFdmVudD4oe1xuICAgICAgICBpbml0aWFsSW5kZXgsXG4gICAgICAgIGdldENoaWxkcmVuLFxuICAgICAgICBnZXRBdDogdXNlQ2FsbGJhY2soKGNoaWxkKSA9PiB7IHJldHVybiBjaGlsZC5nZXRPcGVuRnJvbVBhcmVudCgpID8/IGZhbHNlOyB9LCBbXSksXG4gICAgICAgIHNldEF0OiB1c2VDYWxsYmFjaygoY2hpbGQsIG9wZW4pID0+IHsgcmV0dXJuIGNoaWxkLnNldE9wZW5Gcm9tUGFyZW50KG9wZW4pOyB9LCBbXSksXG4gICAgICAgIGlzVmFsaWQsXG4gICAgICAgIG9uSW5kZXhDaGFuZ2U6IG51bGwsXG4gICAgICAgIC8va2V5OiBcIm9wZW5cIixcbiAgICAgICAgY2xvc2VzdEZpdDogZmFsc2VcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXg6IGNoYW5nZVRhYmJlZEluZGV4LCBnZXRDdXJyZW50SW5kZXg6IGdldFRhYmJlZEluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdDogb2NtYzIgfSA9IHVzZUNoaWxkcmVuRmxhZzxNLCBFdmVudD4oe1xuICAgICAgICBpbml0aWFsSW5kZXgsXG4gICAgICAgIGdldENoaWxkcmVuLFxuICAgICAgICBnZXRBdDogdXNlQ2FsbGJhY2soKGNoaWxkKSA9PiB7IHJldHVybiBjaGlsZC5nZXRNb3N0UmVjZW50bHlUYWJiZWQoKSA/PyBmYWxzZTsgfSwgW10pLFxuICAgICAgICBzZXRBdDogdXNlQ2FsbGJhY2soKGNoaWxkLCB0YWJiZWQpID0+IHsgcmV0dXJuIGNoaWxkLnNldE1vc3RSZWNlbnRseVRhYmJlZCh0YWJiZWQpOyB9LCBbXSksXG4gICAgICAgIGlzVmFsaWQsXG4gICAgICAgIGNsb3Nlc3RGaXQ6IHRydWUsXG4gICAgICAgIG9uSW5kZXhDaGFuZ2U6IHVzZUNhbGxiYWNrKChpOiBudW1iZXIgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ2V0Q2hpbGRyZW4oKS5nZXRBdChpKT8uZm9jdXNTZWxmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKVxuICAgIH0pXG5cbiAgICAvL2NvbnN0IG5hdmlnYXRlQWJzb2x1dGUgPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyKSA9PiB7IHJldHVybiBjaGFuZ2VUYWJiZWRJbmRleChpKTsgfSwgW10pO1xuICAgIC8vY29uc3QgbmF2aWdhdGVSZWxhdGl2ZSA9IHVzZUNhbGxiYWNrKChzOiBudW1iZXIsIG86IG51bWJlcikgPT4geyByZXR1cm4gY2hhbmdlVGFiYmVkSW5kZXgobyArIHMpOyB9LCBbXSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdDxVc2VBY2NvcmRpb25Db250ZXh0PEhlYWRlckJ1dHRvbkVsZW1lbnQsIE0+Pih7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgYWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgY2hhbmdlRXhwYW5kZWRJbmRleCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VUYWJiZWRJbmRleCxcbiAgICAgICAgICAgICAgICBnZXRFeHBhbmRlZEluZGV4OiBnZXRDdXJyZW50RXhwYW5kZWRJbmRleCxcbiAgICAgICAgICAgICAgICBnZXRUYWJiZWRJbmRleDogZ2V0VGFiYmVkSW5kZXhcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgICAgICAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiB1c2VDYWxsYmFjaygoKSA9PiBnZXRDaGlsZHJlbigpLmdldEhpZ2hlc3RJbmRleCgpLCBbXSksXG4gICAgICAgICAgICAgICAgaW5kZXhNYW5nbGVyOiBpZGVudGl0eSxcbiAgICAgICAgICAgICAgICBpbmRleERlbWFuZ2xlcjogaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICBpc1ZhbGlkOiBpc1ZhbGlkMixcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVBhc3RFbmQsXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQsXG4gICAgICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuOiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlSW5kZXg6IGdldFRhYmJlZEluZGV4LFxuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXg6IGNoYW5nZVRhYmJlZEluZGV4XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBtY1JldHVyblR5cGUubWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICBhY2NvcmRpb25SZXR1cm46IHVzZVN0YWJsZU9iamVjdCh7IGNoYW5nZUV4cGFuZGVkSW5kZXggfSlcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eTxUPih0OiBUKSB7IHJldHVybiB0OyB9XG5cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY2NvcmRpb25TZWN0aW9uPF9IZWFkZXJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGJ1dHRvblBhcmFtZXRlcnMsXG4gICAgcHJlc3NQYXJhbWV0ZXJzOiB7IGV4Y2x1ZGUgfSxcbiAgICBhY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczogeyBvcGVuOiBvcGVuRnJvbVVzZXIsIGJvZHlSb2xlIH0sXG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbiB9LFxuICAgIC8vbWFuYWdlZENoaWxkQ29udGV4dCxcbiAgICBjb250ZXh0LFxuICAgIGNvbnRleHQ6IHtcbiAgICAgICAgYWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM6IHsgY2hhbmdlRXhwYW5kZWRJbmRleCwgY2hhbmdlVGFiYmVkSW5kZXg6IF9zZXRDdXJyZW50Rm9jdXNlZEluZGV4LCBnZXRUYWJiZWRJbmRleDogZ2V0Q3VycmVudEZvY3VzZWRJbmRleCB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm5cbiAgICB9LFxuICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzLFxufTogVXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudCwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+KTogVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGU8X0hlYWRlckNvbnRhaW5lckVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQsIEJvZHlFbGVtZW50PiB7XG5cbiAgICBjb25zdCB7IGRpc2FibGVkLCBvblByZXNzOiB1c2VyT25QcmVzcyB9ID0gYnV0dG9uUGFyYW1ldGVycztcblxuICAgIGRlYnVnTG9nKFwidXNlQWNjb3JkaWFuU2VjdGlvblwiKTtcbiAgICBjb25zdCBbb3BlbkZyb21QYXJlbnQsIHNldE9wZW5Gcm9tUGFyZW50LCBnZXRPcGVuRnJvbVBhcmVudF0gPSB1c2VTdGF0ZTxib29sZWFuIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW21vc3RSZWNlbnRseVRhYmJlZCwgc2V0TW9zdFJlY2VudGx5VGFiYmVkLCBnZXRNb3N0UmVjZW50bHlUYWJiZWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KG51bGwpO1xuXG4gICAgdHlwZSBNID0gVXNlQWNjb3JkaW9uU2VjdGlvbkluZm87XG5cblxuICAgIGNvbnN0IHsgcmFuZG9tSWRSZXR1cm46IF9ib2R5SWRSZXR1cm4sIHByb3BzU291cmNlOiBwcm9wc0JvZHlTb3VyY2UsIHByb3BzUmVmZXJlbmNlcjogcHJvcHNIZWFkUmVmZXJlbmNlciB9ID0gdXNlUmFuZG9tSWQ8Qm9keUVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQ+KHsgcmFuZG9tSWRQYXJhbWV0ZXJzOiB7IHByZWZpeDogUHJlZmljZXMuYWNjb3JkaW9uU2VjdGlvbkhlYWRlckJ1dHRvbiwgb3RoZXJSZWZlcmVuY2VyUHJvcDogXCJhcmlhLWNvbnRyb2xzXCIgfSB9KTtcbiAgICBjb25zdCB7IHJhbmRvbUlkUmV0dXJuOiBfaGVhZElkUmV0dXJuLCBwcm9wc1NvdXJjZTogcHJvcHNIZWFkU291cmNlLCBwcm9wc1JlZmVyZW5jZXI6IHByb3BzQm9keVJlZmVyZW5jZXIgfSA9IHVzZVJhbmRvbUlkPEhlYWRlckJ1dHRvbkVsZW1lbnQsIEJvZHlFbGVtZW50Pih7IHJhbmRvbUlkUGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLmFjY29yZGlvblNlY3Rpb25Cb2R5LCBvdGhlclJlZmVyZW5jZXJQcm9wOiBcImFyaWEtbGFiZWxsZWRieVwiIH0gfSk7XG4gICAgLy9jb25zdCB7IHJhbmRvbUlkU291cmNlUmV0dXJuOiB7IHByb3BzU3RhYmxlOiB1c2VCb2R5QXNTb3VyY2VJZFByb3BzIH0gfSA9IHVzZUJvZHlBc1NvdXJjZUlkKCk7XG4gICAgLy9jb25zdCB7IHJhbmRvbUlkUmVmZXJlbmNlclJldHVybjogeyBwcm9wc1N0YWJsZTogdXNlQm9keUFzUmVmZXJlbmNlcklkUHJvcHMgfSB9ID0gdXNlQm9keUFzUmVmZXJlbmNlcklkPEJvZHlFbGVtZW50Pih7IHJhbmRvbUlkUmVmZXJlbmNlclBhcmFtZXRlcnM6IHsgb3RoZXJSZWZlcmVuY2VyUHJvcDogXCJhcmlhLWNvbnRyb2xzXCIgYXMgbmV2ZXIgfSB9KTtcbiAgICAvL2NvbnN0IHsgcmFuZG9tSWRTb3VyY2VSZXR1cm46IHsgcHJvcHNTdGFibGU6IHVzZUhlYWRlckFzU291cmNlSWRQcm9wcyB9IH0gPSB1c2VIZWFkZXJBc1NvdXJjZUlkKCk7XG4gICAgLy9jb25zdCB7IHJhbmRvbUlkUmVmZXJlbmNlclJldHVybjogeyBwcm9wc1N0YWJsZTogdXNlSGVhZGVyQXNSZWZlcmVuY2VySWRQcm9wcyB9IH0gPSB1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZDxIZWFkZXJFbGVtZW50Pih7IHJhbmRvbUlkUmVmZXJlbmNlclBhcmFtZXRlcnM6IHsgb3RoZXJSZWZlcmVuY2VyUHJvcDogXCJhcmlhLWxhYmVsbGVkYnlcIiBhcyBuZXZlciB9IH0pO1xuXG4gICAgY29uc3Qgb3BlbiA9ICgob3BlbkZyb21Vc2VyID8/IG9wZW5Gcm9tUGFyZW50KSA/PyBmYWxzZSk7XG4gICAgLy9jb25zdCBnZXRPcGVuID0gdXNlU3RhYmxlR2V0dGVyKCEhb3Blbik7XG4gICAgY29uc3QgX2dldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZGV4KTtcblxuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50OiBnZXRIZWFkZXJFbGVtZW50LCBwcm9wc1N0YWJsZTogaGVhZGVyUmVmRWxlbWVudFByb3BzIH0gfSA9IHVzZVJlZkVsZW1lbnQ8SGVhZGVyQnV0dG9uRWxlbWVudD4oeyByZWZFbGVtZW50UGFyYW1ldGVyczoge30gfSk7XG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQ6IF9nZXRCb2R5RWxlbWVudCwgcHJvcHNTdGFibGU6IGJvZHlSZWZFbGVtZW50UHJvcHMgfSB9ID0gdXNlUmVmRWxlbWVudDxCb2R5RWxlbWVudD4oeyByZWZFbGVtZW50UGFyYW1ldGVyczoge30gfSk7XG4gICAgY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAvL2lmIChnZXRDdXJyZW50Rm9jdXNlZEluZGV4KCkgIT0gbnVsbClcbiAgICAgICAgICAgIChnZXRIZWFkZXJFbGVtZW50KCkgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCk/LmZvY3VzKCk7XG4gICAgfSwgW10pO1xuICAgIC8qY29uc3Qgb3BlblJlZiA9IHVzZVJlZih7XG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0T3BlbkZyb21QYXJlbnQoKSxcbiAgICAgICAgICAgIHNldDogKG9wZW46IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgICAgICBzZXRPcGVuRnJvbVBhcmVudChvcGVuKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlFbGVtZW50ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudEZvY3VzZWRJbmRleChnZXRJbmRleCgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBib2R5RWxlbWVudC5mb2N1cygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNWYWxpZDogcmV0dXJuVHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdGFiYmVkUmVmID0gdXNlUmVmKHtcbiAgICAgICAgICAgIGdldDogKCkgPT4gKGdldEN1cnJlbnRGb2N1c2VkSW5kZXgoKSA9PSBnZXRJbmRleCgpKSxcbiAgICAgICAgICAgIHNldDogKG9wZW46IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3BlbilcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudEZvY3VzZWRJbmRleChnZXRJbmRleCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1ZhbGlkOiByZXR1cm5UcnVlXG4gICAgfSk7Ki9cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZFJldHVybjogeyBnZXRDaGlsZHJlbjogX2dldFNlY3Rpb25zIH0gfSA9IHVzZU1hbmFnZWRDaGlsZDxNPih7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICBmb2N1c1NlbGYsXG4gICAgICAgIGdldE1vc3RSZWNlbnRseVRhYmJlZCxcbiAgICAgICAgZ2V0T3BlbkZyb21QYXJlbnQsXG4gICAgICAgIGhpZGRlbixcbiAgICAgICAgc2V0TW9zdFJlY2VudGx5VGFiYmVkLFxuICAgICAgICBzZXRPcGVuRnJvbVBhcmVudCxcbiAgICB9KTtcblxuICAgIC8vY29uc3Qgb25Gb2N1cyA9ICgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoaW5kZXgpOyB9XG4gICAgY29uc3Qgb25QcmVzcyA9IChlOiBCdXR0b25QcmVzc0V2ZW50PEhlYWRlckJ1dHRvbkVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIGlmIChnZXRPcGVuRnJvbVBhcmVudCgpKVxuICAgICAgICAgICAgY2hhbmdlRXhwYW5kZWRJbmRleChudWxsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2hhbmdlRXhwYW5kZWRJbmRleChpbmRleCk7XG5cbiAgICAgICAgdXNlck9uUHJlc3M/LihlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgeyBwcmVzc1JldHVybiwgcHJvcHM6IGJ1dHRvblByb3BzLCByZWZFbGVtZW50UmV0dXJuIH0gPSB1c2VCdXR0b248SGVhZGVyQnV0dG9uRWxlbWVudD4oe1xuICAgICAgICBidXR0b25QYXJhbWV0ZXJzOiB7IC4uLmJ1dHRvblBhcmFtZXRlcnMsIHByZXNzZWQ6IG51bGwsIG9uUHJlc3MsIHJvbGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgcHJlc3NQYXJhbWV0ZXJzOiB7IGV4Y2x1ZGUgfSxcbiAgICAgICAgcmVmRWxlbWVudFBhcmFtZXRlcnNcbiAgICB9KTtcblxuXG4gICAgY29uc3QgbGluZWFyUmV0dXJuVHlwZSA9IHVzZUxpbmVhck5hdmlnYXRpb248SGVhZGVyQnV0dG9uRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudD4oeyBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgcm92aW5nVGFiSW5kZXhSZXR1cm4gfSk7XG5cbiAgICBjb25zdCB7IGxpbmVhck5hdmlnYXRpb25SZXR1cm46IHsgcHJvcHNTdGFibGUgfSB9ID0gbGluZWFyUmV0dXJuVHlwZTtcblxuICAgIC8qZnVuY3Rpb24gdXNlQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzKHsgW1wiYXJpYS1leHBhbmRlZFwiXTogYXJpYUV4cGFuZGVkLCBbXCJhcmlhLWRpc2FibGVkXCJdOiBhcmlhRGlzYWJsZWQsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4ge1xuXG4gICAgICAgICAgICBwcm9wcy50YWJJbmRleCA9IDA7XG5cblxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKHVzZUhlYWRlckFzU291cmNlSWRQcm9wcywgdXNlSGVhZGVyQXNSZWZlcmVuY2VySWRQcm9wcywgcHJvcHNTdGFibGUsIHtcbiAgICAgICAgICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogKGFyaWFFeHBhbmRlZCA/PyBvcGVuID8/IGZhbHNlKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiAoYXJpYURpc2FibGVkID8/IChvcGVuID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQpKSxcbiAgICAgICAgICAgICAgICAuLi51c2VNZXJnZWRQcm9wcyhoZWFkZXJSZWZFbGVtZW50UHJvcHMsIHVzZUJ1dHRvblByb3BzKHByb3BzKSlcbiAgICAgICAgICAgIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4pO1xuICAgICAgICB9XG5cblxuICAgICAgICBmdW5jdGlvbiB1c2VBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzKHsgcm9sZSwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+IHtcbiAgICAgICAgICAgIGNvbnN0IHJldDEgPSB1c2VNZXJnZWRQcm9wcyh1c2VCb2R5QXNSZWZlcmVuY2VySWRQcm9wcywgeyByb2xlOiByb2xlID8/IFwicmVnaW9uXCIsIC4uLnByb3BzIH0pO1xuICAgICAgICAgICAgY29uc3QgcmV0MiA9IHVzZU1lcmdlZFByb3BzKHVzZUJvZHlBc1NvdXJjZUlkUHJvcHMsIHJldDEpO1xuICAgICAgICAgICAgcmV0Mi50YWJJbmRleCA/Pz0gLTE7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoYm9keVJlZkVsZW1lbnRQcm9wcywgcmV0Mik7XG4gICAgfSovXG5cbiAgICBjb25zdCBoZWFkZXJCdXR0b25Qcm9wcyA9IHVzZU1lcmdlZFByb3BzPEhlYWRlckJ1dHRvbkVsZW1lbnQ+KFxuICAgICAgICBidXR0b25Qcm9wcyxcbiAgICAgICAgaGVhZGVyUmVmRWxlbWVudFByb3BzLFxuICAgICAgICBwcm9wc0hlYWRSZWZlcmVuY2VyLFxuICAgICAgICBwcm9wc0hlYWRTb3VyY2UsXG4gICAgICAgIHByb3BzU3RhYmxlLFxuICAgICAgICB7IFwiYXJpYS1leHBhbmRlZFwiOiAob3BlbiA/PyBmYWxzZSkudG9TdHJpbmcoKSwgfVxuICAgICk7XG5cbiAgICBjb25zdCBib2R5UHJvcHMgPSB1c2VNZXJnZWRQcm9wczxCb2R5RWxlbWVudD4oXG4gICAgICAgIGJvZHlSZWZFbGVtZW50UHJvcHMsXG4gICAgICAgIHByb3BzQm9keVJlZmVyZW5jZXIsXG4gICAgICAgIHByb3BzQm9keVNvdXJjZSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogYm9keVJvbGUsXG4gICAgICAgICAgICB0YWJJbmRleDogLTFcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVzc1JldHVybixcbiAgICAgICAgcmVmRWxlbWVudFJldHVybixcbiAgICAgICAgYWNjb3JkaW9uU2VjdGlvblJldHVybjoge1xuICAgICAgICAgICAgbW9zdFJlY2VudGx5VGFiYmVkOiAhIW1vc3RSZWNlbnRseVRhYmJlZCxcbiAgICAgICAgICAgIGV4cGFuZGVkOiBvcGVuLFxuICAgICAgICAgICAgZm9jdXNlZDogKGdldEN1cnJlbnRGb2N1c2VkSW5kZXgoKSA9PSBpbmRleClcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHNIZWFkZXJCdXR0b246IGhlYWRlckJ1dHRvblByb3BzLFxuICAgICAgICBwcm9wc0hlYWRlcjoge30sICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBlbXB0eSwgaXQncyBqdXN0IGEgcmVtaW5kZXIgdGhhdCB0aGVyZSAqZG9lcyogbmVlZCB0byBiZSBhIGhlYWRlciB0aGF0IGNvbnRhaW5zIHRoZSBidXR0b24uXG4gICAgICAgIHByb3BzQm9keTogYm9keVByb3BzXG4gICAgfTtcbn0iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMsIHVzZVByZXNzLCBVc2VQcmVzc1JldHVyblR5cGUsIHVzZVJhbmRvbUR1YWxJZHMsIFVzZVJhbmRvbUR1YWxJZHNQYXJhbWV0ZXJzLCBVc2VSYW5kb21EdWFsSWRzUmV0dXJuVHlwZSwgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFJldHVyblR5cGUsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBEaXNhYmxlZFR5cGUsIEVsZW1lbnRUb1RhZywgbm9vcCB9IGZyb20gXCIuL3Byb3BzXCI7XG5cbmV4cG9ydCB0eXBlIExhYmVsUG9zaXRpb24gPSBcInNlcGFyYXRlXCIgfCBcIndyYXBwaW5nXCIgfCBcIm5vbmVcIjtcbmV4cG9ydCB0eXBlIEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCBleHRlbmRzIExhYmVsUG9zaXRpb24sIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gTFAgZXh0ZW5kcyBcIndyYXBwaW5nXCIgPyBMYWJlbEVsZW1lbnQgOiBJbnB1dEVsZW1lbnQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGFiZWxQYXJhbWV0ZXJzPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHJhbmRvbUlkSW5wdXRQYXJhbWV0ZXJzOiBPbWl0PFVzZVJhbmRvbUR1YWxJZHNQYXJhbWV0ZXJzW1wicmFuZG9tSWRJbnB1dFBhcmFtZXRlcnNcIl0sIFwib3RoZXJSZWZlcmVuY2VyUHJvcFwiPjtcbiAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogT21pdDxVc2VSYW5kb21EdWFsSWRzUGFyYW1ldGVyc1tcInJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzXCJdLCBcIm90aGVyUmVmZXJlbmNlclByb3BcIj47XG5cbiAgICBsYWJlbFBhcmFtZXRlcnM6IHtcbiAgICAgICAgb25MYWJlbENsaWNrOiBudWxsIHwgKChlOiBFdmVudCkgPT4gdm9pZCk7XG4gICAgICAgIHRhZ0lucHV0OiBFbGVtZW50VG9UYWc8SW5wdXRFbGVtZW50PjtcbiAgICAgICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlcmUgaXMgdGhpcyBjb21wb25lbnQncyBsYWJlbCByZWxhdGl2ZSB0byB0aGUgY29tcG9uZW50IGl0c2VsZj9cbiAgICAgICAgICogXG4gICAgICAgICAqICogYFwic2VwYXJhdGVcImA6IGA8bGFiZWwgLz48aW5wdXQgLz5gXG4gICAgICAgICAqICogYFwid3JhcHBpbmdcImA6IGA8bGFiZWw+PGlucHV0IC8+PC9sYWJlbD5gXG4gICAgICAgICAqICogYFwibm9uZVwiYDogYDxpbnB1dCBhcmlhLWxhYmVsPVwiLi4uXCIgLz5gXG4gICAgICAgICAqIFxuICAgICAgICAgKiBJbiBjYXNlcyB3aGVyZSB5b3UncmUgdXNpbmcgbm9uLWBpbnB1dGAgYW5kIGBsYWJlbGAgZWxlbWVudHMsIGBcInNlcGFyYXRlXCJgIGFuZCBgXCJ3cmFwcGluZ1wiYCBhcmUgaWRlbnRpY2FsOyBcbiAgICAgICAgICogdGhpcyBpcyBtb3N0IGltcG9ydGFudCBmb3IgbmF0aXZlIGBsYWJlbGAgYW5kIGBpbnB1dGAgZWxlbWVudHMsIGFzIHRoZXkgb25seSBuZWVkIGEgYGZvcmAgcHJvcCB3aGVuIHRoZSBsYWJlbCBkb2Vzbid0IHdyYXAgdGhlIGlucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxQb3NpdGlvbjogTFA7XG5cbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBXaGVuIGBudWxsYCwgdGhpcyBjb3JyZXNwb25kcyB0byBoYXZpbmcgYSB2aXNpYmxlIGxhYmVsICh3aXRoIGBsYWJlbFBvc2l0aW9uYCA9PSBgXCJzZXBhcmF0ZVwiYCBvciBgXCJ3cmFwcGluZ1wiYCkuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBXaGVuIGEgc3RyaW5nLCB0aGlzIGNvcnJlc3BvbmRzIHRvIGBsYWJlbFBvc2l0aW9uYCA9PSBgXCJub25lXCJgOyB0aGlzIGxhYmVsIGlzIG9ubHkgdmlzaWJsZSB0byBhc3Npc3RpdmUgdGVjaG5vbG9naWVzIGFuZCAqbm90KiB2aXNpYmxlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIGFyaWFMYWJlbDogTFAgZXh0ZW5kcyBcIm5vbmVcIiA/IHN0cmluZyA6IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxhYmVsUmV0dXJuVHlwZTxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJhbmRvbUR1YWxJZHNSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiB7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxhYmVsPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIHJhbmRvbUlkSW5wdXRQYXJhbWV0ZXJzLFxuICAgIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzLFxuICAgIGxhYmVsUGFyYW1ldGVyczogeyB0YWdJbnB1dCwgdGFnTGFiZWwsIGFyaWFMYWJlbCwgbGFiZWxQb3NpdGlvbiwgb25MYWJlbENsaWNrIH1cbn06IFVzZUxhYmVsUGFyYW1ldGVyczxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KTogVXNlTGFiZWxSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XG4gICAgY29uc3QgbmF0aXZlSFRNTEJlaGF2aW9yID0gKHRhZ0lucHV0ID09IFwiaW5wdXRcIiAmJiB0YWdMYWJlbCA9PSBcImxhYmVsXCIgJiYgbGFiZWxQb3NpdGlvbiAhPSBcIndyYXBwaW5nXCIpO1xuICAgIGNvbnN0IHN5bnRoZXRpYyA9ICFuYXRpdmVIVE1MQmVoYXZpb3I7XG5cbiAgICAvKipcbiAgICAgKiB8U3ludGhldGljP3xQb3NpdGlvbiAgICB8SW5wdXQgUHJvcCAgIHxMYWJlbCBQcm9wfFxuICAgICAqIHwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS18XG4gICAgICogfE4gICAgICAgICB8YFwic2VwYXJhdGVcImB8LSAgICAgICAgICAgIHxgZm9yYCAgICAgfFxuICAgICAqIHxOICAgICAgICAgfGBcIndyYXBwaW5nXCJgfC0gICAgICAgICAgICB8LSAgICAgICAgIHxcbiAgICAgKiB8WSAgICAgICAgIHxgXCJzZXBhcmF0ZVwiYHxgbGFiZWxsZWQtYnlgfC0gICAgICAgICB8XG4gICAgICogfFkgICAgICAgICB8YFwid3JhcHBpbmdcImB8YGxhYmVsbGVkLWJ5YHwtICAgICAgICAgfFxuICAgICAqIFxuICAgICAqL1xuICAgIGxldCBfY29tbWVudDogYW55O1xuXG4gICAgY29uc3Qge1xuICAgICAgICBwcm9wc0lucHV0LFxuICAgICAgICBwcm9wc0xhYmVsLFxuICAgICAgICByYW5kb21JZElucHV0UmV0dXJuLFxuICAgICAgICByYW5kb21JZExhYmVsUmV0dXJuXG4gICAgfSA9IHVzZVJhbmRvbUR1YWxJZHM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IHsgLi4ucmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMsIG90aGVyUmVmZXJlbmNlclByb3A6ICFzeW50aGV0aWMgJiYgbGFiZWxQb3NpdGlvbiA9PT0gXCJzZXBhcmF0ZVwiID8gXCJmb3JcIiA6IG51bGwgfSxcbiAgICAgICAgcmFuZG9tSWRMYWJlbFBhcmFtZXRlcnM6IHsgLi4ucmFuZG9tSWRMYWJlbFBhcmFtZXRlcnMsIG90aGVyUmVmZXJlbmNlclByb3A6IHN5bnRoZXRpYyA/IFwiYXJpYS1sYWJlbGxlZGJ5XCIgOiBudWxsIH0sXG4gICAgfSk7XG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuIH0gPSB1c2VSZWZFbGVtZW50PExhYmVsRWxlbWVudD4oeyByZWZFbGVtZW50UGFyYW1ldGVyczogeyAgfSB9KTtcblxuICAgIGlmIChsYWJlbFBvc2l0aW9uID09ICdub25lJylcbiAgICAgICAgcHJvcHNJbnB1dFtcImFyaWEtbGFiZWxcIl0gPSAoYXJpYUxhYmVsISk7XG5cbiAgICAgICBjb25zdCB7IHByZXNzUmV0dXJuIH0gPSB1c2VQcmVzcyh7IHByZXNzUGFyYW1ldGVyczogeyBleGNsdWRlOiB7IGVudGVyOiBcImV4Y2x1ZGVcIiwgc3BhY2U6IFwiZXhjbHVkZVwiLCBjbGljazogdW5kZWZpbmVkIH0sIG9uUHJlc3NTeW5jOiBvbkxhYmVsQ2xpY2ssIGZvY3VzU2VsZjogbm9vcCB9LCByZWZFbGVtZW50UmV0dXJuIH0pXG4gICAgLy9wcm9wc0xhYmVsLm9uQ2xpY2sgPSBvbkxhYmVsQ2xpY2sgPz8gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHNJbnB1dCxcbiAgICAgICAgcHJvcHNMYWJlbDogdXNlTWVyZ2VkUHJvcHMocHJvcHNMYWJlbCwgcmVmRWxlbWVudFJldHVybi5wcm9wc1N0YWJsZSwgcHJlc3NSZXR1cm4ucHJvcHNTdGFibGUpLFxuICAgICAgICByYW5kb21JZElucHV0UmV0dXJuLFxuICAgICAgICByYW5kb21JZExhYmVsUmV0dXJuLFxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnMge1xuICAgIHJhbmRvbUlkSW5wdXRQYXJhbWV0ZXJzOiBPbWl0PFVzZVJhbmRvbUR1YWxJZHNQYXJhbWV0ZXJzW1wicmFuZG9tSWRJbnB1dFBhcmFtZXRlcnNcIl0sIFwib3RoZXJSZWZlcmVuY2VyUHJvcFwiPjtcbiAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogT21pdDxVc2VSYW5kb21EdWFsSWRzUGFyYW1ldGVyc1tcInJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzXCJdLCBcIm90aGVyUmVmZXJlbmNlclByb3BcIj47XG4gICAgbGFiZWxQYXJhbWV0ZXJzOiBQaWNrPFVzZUxhYmVsUGFyYW1ldGVyczxMYWJlbFBvc2l0aW9uLCBhbnksIGFueT5bXCJsYWJlbFBhcmFtZXRlcnNcIl0sIFwiYXJpYUxhYmVsXCIgfCBcIm9uTGFiZWxDbGlja1wiPlxufVxuXG4vKipcbiAqIFNob3J0Y3V0IGZvciBgdXNlTGFiZWxgIHRoYXQgYXNzdW1lcyB3ZSdyZSBqdXN0IG5ldmVyIHdvcmtpbmcgd2l0aCBuYXRpdmUgSFRNTCBgaW5wdXRgIGFuZCBgbGFiZWxgIGVsZW1lbnRzLiBTbyBmb3IgbGFiZWxsaW5nIGd1YXJhbnRlYWJseSBub24tbmF0aXZlIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGFiZWxTeW50aGV0aWM8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGxhYmVsUGFyYW1ldGVyczogeyBhcmlhTGFiZWwsIG9uTGFiZWxDbGljayB9LFxuICAgIHJhbmRvbUlkSW5wdXRQYXJhbWV0ZXJzLFxuICAgIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzXG59OiBVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gdXNlTGFiZWw8TGFiZWxQb3NpdGlvbiwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgcmFuZG9tSWRMYWJlbFBhcmFtZXRlcnMsXG4gICAgICAgIHJhbmRvbUlkSW5wdXRQYXJhbWV0ZXJzLFxuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGFyaWFMYWJlbCxcbiAgICAgICAgICAgIGxhYmVsUG9zaXRpb246IGFyaWFMYWJlbCA9PSBudWxsID8gXCJzZXBhcmF0ZVwiIDogXCJub25lXCIsXG4gICAgICAgICAgICB0YWdJbnB1dDogXCJkaXZcIiBhcyBuZXZlcixcbiAgICAgICAgICAgIHRhZ0xhYmVsOiBcImRpdlwiIGFzIG5ldmVyLFxuICAgICAgICAgICAgb25MYWJlbENsaWNrXG4gICAgICAgIH1cbiAgICB9KVxuXG59XG5cblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZTogRXZlbnQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5cblxuZXhwb3J0IHR5cGUgQ2hlY2tib3hDaGVja2VkVHlwZSA9IGJvb2xlYW4gfCBcIm1peGVkXCI7XG4vL2V4cG9ydCB0eXBlIExhYmVsUG9zaXRpb24gPSBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCIgfCBcImR1YWxcIiB8IFwibm9uZVwiO1xuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgSW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUxhYmVsUGFyYW1ldGVyczxMUCwgSW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBcImxhYmVsUGFyYW1ldGVyc1wiPiB7XG4gICAgY2hlY2tib3hMaWtlUGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlcmUgdGhlIGxhYmVsIGVsZW1lbnQgaXMgcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgICAgICogKiBgd3JhcHBpbmdgOiBUaGUgbGFiZWwgd3JhcHMgdGhlIGlucHV0IGFuZCBubyBgaWRgIG9yIGBmb3JgIHByb3BzIGFyZSBuZWVkZWQsIGFzIGluIGA8bGFiZWw+PGlucHV0IC8+IGxhYmVsIGNvbnRlbnQ8L2xhYmVsPmBcbiAgICAgICAgICogKiBgc2VwYXJhdGVgOiBUaGUgbGFiZWwgYW5kIGlucHV0IGFyZSBpbiBzZXBhcmF0ZSBicmFuY2hlcywgYXMgaW4gYDxpbnB1dCAvPjxsYWJlbD5sYWJlbCBjb250ZW50PC9sYWJlbD5gXG4gICAgICAgICAqICogYGR1YWxgOiBPbmUgZWxlbWVudCBzZXJ2ZXMgaW4gYm90aCByb2xlcyBhdCBvbmNlLCBhcyBpbiBgPGRpdiByb2xlPVwiY2hlY2tib3hcIj5sYWJlbCBjb250ZW50PC9kaXY+IGBcbiAgICAgICAgICogKiBgbm9uZWA6IFRoZXJlIGlzIG5vIHZpc2libGUgbGFiZWwgZWxlbWVudCwgYXMgaW4gYDxpbnB1dCBhcmlhLWxhYmVsPVwibGFiZWwgY29udGVudFwiIC8+YFxuICAgICAgICAgKiBcbiAgICAgICAgICogSW4gY29tYmluYXRpb24gd2l0aCBgdGFnSW5wdXRgIGFuZCBgdGFnTGFiZWxgLCBgbGFiZWxQb3NpdGlvbmAgZGV0ZXJtaW5lcyB3aGljaCBlbGVtZW50IHJlY2VpdmVzIHdoaWNoIHByb3BzIGFuZCBldmVudCBoYW5kbGVycy5cbiAgICAgICAgICovXG4gICAgICAgIC8vbGFiZWxQb3NpdGlvbjogTGFiZWxQb3NpdGlvbjtcbiAgICAgICAgLyoqIFRoZSByb2xlIGF0dHJpYnV0ZSB0byB1c2UsIHdoZW4gYXBwbGljYWJsZSAqL1xuICAgICAgICByb2xlOiBzdHJpbmc7XG4gICAgICAgIGRpc2FibGVkOiBEaXNhYmxlZFR5cGU7XG4gICAgICAgIGNoZWNrZWQ6IENoZWNrYm94Q2hlY2tlZFR5cGU7XG4gICAgICAgIG9uSW5wdXQoZXZlbnQ6IEV2ZW50KTogdm9pZDtcbiAgICAgICAgLy90eXBlOiBcImNoZWNrYm94XCIgfCBcInJhZGlvXCI7XG4gICAgfTtcblxuICAgIGxhYmVsUGFyYW1ldGVyczogT21pdDxVc2VMYWJlbFBhcmFtZXRlcnM8TFAsIElucHV0VHlwZSwgTGFiZWxUeXBlPltcImxhYmVsUGFyYW1ldGVyc1wiXSwgXCJvbkxhYmVsQ2xpY2tcIj47XG5cbiAgICByZWZFbGVtZW50TGFiZWxSZXR1cm46IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPExhYmVsVHlwZT5bXCJyZWZFbGVtZW50UmV0dXJuXCJdO1xuICAgIHJlZkVsZW1lbnRJbnB1dFJldHVybjogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8SW5wdXRUeXBlPltcInJlZkVsZW1lbnRSZXR1cm5cIl07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZTxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxhYmVsUmV0dXJuVHlwZTxJbnB1dFR5cGUsIExhYmVsVHlwZT4ge1xuICAgIHByZXNzTGFiZWxSZXR1cm46IFVzZVByZXNzUmV0dXJuVHlwZTxMYWJlbFR5cGU+W1wicHJlc3NSZXR1cm5cIl07XG4gICAgcHJlc3NJbnB1dFJldHVybjogVXNlUHJlc3NSZXR1cm5UeXBlPElucHV0VHlwZT5bXCJwcmVzc1JldHVyblwiXTtcbiAgICBjaGVja2JveExpa2VJbnB1dFJldHVybjogeyBwcm9wc1Vuc3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+IH1cbiAgICBjaGVja2JveExpa2VMYWJlbFJldHVybjogeyBwcm9wc1Vuc3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+IH1cbiAgICBjaGVja2JveExpa2VSZXR1cm46IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGwgdGhpcyB0byBmb2N1cyB3aGljaGV2ZXIgZWxlbWVudCBoYW5kbGVzIHRoZSBmb2N1cyBiYXNlZCBvbiBgbGFiZWxQb3NpdGlvbmAuXG4gICAgICAgICAqL1xuICAgICAgICBmb2N1c1NlbGYoKTogdm9pZDtcbiAgICB9XG59XG5cbi8qKlxuICogSGFuZGxlcyBhbnkgY29tcG9uZW50IHdoZXJlIHRoZXJlJ3M6XG4gKiAxLiBTb21lIGtpbmQgb2YgYW4gb24vb2ZmIGJpbmFyeS90cmluYXJ5IGlucHV0IGVsZW1lbnQgdGhhdCBuZWVkcyBldmVudCBoYW5kbGVyc1xuICogMi4gU29tZSBraW5kIG9mIGxhYmVsIGZvciB0aGF0IGlucHV0IGVsZW1lbnRcbiAqIFxuICogU2VlIGFsc28gYHVzZUxhYmVsYCBmb3Igd2hlbiB0aGVyZSdzIGEgbGFiZWwgZm9yIGEgbm9uLWNoZWNrYm94LWxpa2UgY29tcG9uZW50LlxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGVja2JveExpa2U8TFAgZXh0ZW5kcyBMYWJlbFBvc2l0aW9uLCBJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbGFiZWxQYXJhbWV0ZXJzLFxuICAgIHJhbmRvbUlkSW5wdXRQYXJhbWV0ZXJzLFxuICAgIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzLFxuICAgIGNoZWNrYm94TGlrZVBhcmFtZXRlcnM6IHsgY2hlY2tlZCwgZGlzYWJsZWQsIG9uSW5wdXQ6IG9uSW5wdXRTeW5jLCByb2xlIH0sXG4gICAgcmVmRWxlbWVudElucHV0UmV0dXJuLFxuICAgIHJlZkVsZW1lbnRMYWJlbFJldHVybixcbn06IFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8TFAsIElucHV0VHlwZSwgTGFiZWxUeXBlPik6IFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGU8SW5wdXRUeXBlLCBMYWJlbFR5cGU+IHtcblxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0SW5wdXRFbGVtZW50IH0gPSByZWZFbGVtZW50SW5wdXRSZXR1cm47XG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRMYWJlbEVsZW1lbnQgfSA9IHJlZkVsZW1lbnRMYWJlbFJldHVybjtcbiAgICBjb25zdCB7IHRhZ0lucHV0LCB0YWdMYWJlbCwgbGFiZWxQb3NpdGlvbiB9ID0gbGFiZWxQYXJhbWV0ZXJzO1xuXG4gICAgLy8gb25DbGljayBhbmQgb25DaGFuZ2UgYXJlIGEgYml0IG1lc3N5LCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gKmFsd2F5cyogbWFrZSBzdXJlIHRoYXQgdGhlIHZpc2libGUgc3RhdGUgaXMgY29ycmVjdFxuICAgIC8vIGFmdGVyIGFsbCB0aGUgZXZlbnQgZHVzdCBzZXR0bGVzLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8yNzQ1LFxuICAgIC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8xODk5I2lzc3VlY29tbWVudC01MjU2OTAxOTRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0SW5wdXRFbGVtZW50ISgpO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiB0YWdJbnB1dCA9PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgIChlbGVtZW50IGFzIEVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkuaW5kZXRlcm1pbmF0ZSA9IChjaGVja2VkID09PSBcIm1peGVkXCIpO1xuICAgICAgICAgICAgKGVsZW1lbnQgYXMgRWxlbWVudCBhcyBIVE1MSW5wdXRFbGVtZW50KS5jaGVja2VkID0gKGNoZWNrZWQgPT09IHRydWUpXG4gICAgICAgIH1cbiAgICB9LCBbdGFnSW5wdXQsIChjaGVja2VkID8/IGZhbHNlKV0pXG5cbiAgICBjb25zdCB7XG4gICAgICAgIHJhbmRvbUlkSW5wdXRSZXR1cm4sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxSZXR1cm4sXG4gICAgICAgIHByb3BzSW5wdXQsXG4gICAgICAgIHByb3BzTGFiZWxcbiAgICB9ID0gdXNlTGFiZWw8TFAsIElucHV0VHlwZSwgTGFiZWxUeXBlPih7XG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgLi4ubGFiZWxQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgb25MYWJlbENsaWNrOiB1c2VTdGFibGVDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZWQgJiYgdGFnSW5wdXQgIT0gXCJpbnB1dFwiICYmIHRhZ0xhYmVsICE9IFwibGFiZWxcIiAmJiBsYWJlbFBvc2l0aW9uICE9IFwic2VwYXJhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICBmb2N1c1NlbGYoKTtcbiAgICAgICAgICAgICAgICAgICAgb25JbnB1dFN5bmMoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMsXG4gICAgICAgIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0SW5wdXQgfSA9IHJlZkVsZW1lbnRJbnB1dFJldHVybjtcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldExhYmVsIH0gPSByZWZFbGVtZW50TGFiZWxSZXR1cm47XG4gICAgY29uc3QgZm9jdXNJbnB1dCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgKGdldElucHV0KCkgYXMgKEhUTUxFbGVtZW50IHwgbnVsbCkpPy5mb2N1cygpOyB9LCBbXSk7XG4gICAgY29uc3QgZm9jdXNMYWJlbCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgKGdldExhYmVsKCkgYXMgKEhUTUxFbGVtZW50IHwgbnVsbCkpPy5mb2N1cygpOyB9LCBbXSk7XG4gICAgY29uc3Qgb25DbGlja0lucHV0U3luYyA9IChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIiA/IHVuZGVmaW5lZCA6IG9uSW5wdXRTeW5jKTtcbiAgICBjb25zdCBvbkNsaWNrTGFiZWxTeW5jID0gb25JbnB1dFN5bmM7Ly8obGFiZWxQb3NpdGlvbiAhPSBcIndyYXBwaW5nXCIgPyB1bmRlZmluZWQgOiBvbklucHV0U3luYyk7XG4gICAgY29uc3QgeyBwcmVzc1JldHVybjogcHJlc3NJbnB1dFJldHVybiB9ID0gdXNlUHJlc3M8SW5wdXRUeXBlPih7IHByZXNzUGFyYW1ldGVyczogeyBleGNsdWRlOiB7fSwgZm9jdXNTZWxmOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7ZGVidWdnZXI7Zm9jdXNTZWxmKCl9KSwgb25QcmVzc1N5bmM6IChkaXNhYmxlZCkgPyB1bmRlZmluZWQgOiBvbkNsaWNrSW5wdXRTeW5jIH0sIHJlZkVsZW1lbnRSZXR1cm46IHJlZkVsZW1lbnRJbnB1dFJldHVybiB9KTtcbiAgICBjb25zdCB7IHByZXNzUmV0dXJuOiBwcmVzc0xhYmVsUmV0dXJuIH0gPSB1c2VQcmVzczxMYWJlbFR5cGU+KHsgcHJlc3NQYXJhbWV0ZXJzOiB7IGV4Y2x1ZGU6IHt9LCBmb2N1c1NlbGY6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtkZWJ1Z2dlcjtmb2N1c1NlbGYoKX0pLCBvblByZXNzU3luYzogKGRpc2FibGVkKSA/IHVuZGVmaW5lZCA6IG9uQ2xpY2tMYWJlbFN5bmMgfSwgcmVmRWxlbWVudFJldHVybjogcmVmRWxlbWVudExhYmVsUmV0dXJuIH0pO1xuICAgIGNvbnN0IHByb3BzVW5zdGFibGVJbnB1dDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPiA9IHt9O1xuICAgIGNvbnN0IHByb3BzVW5zdGFibGVMYWJlbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPiA9IHt9O1xuICAgIC8vY29uc3QgcHJvcHNVbnN0YWJsZUxhYmVsID0gdXNlUmVmPGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT4+KHt9KTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGxhYmVsIGNsaWNrcyBjYW4ndCBhZmZlY3QgdGhlIHZpc3VhbCBzdGF0ZSBvZiB0aGUgY2hlY2tib3hcbiAgICBwcm9wc1Vuc3RhYmxlSW5wdXQub25DbGljayA9IHByZXZlbnREZWZhdWx0O1xuICAgIHByb3BzVW5zdGFibGVMYWJlbC5vbkNsaWNrID0gcHJldmVudERlZmF1bHQ7XG5cbiAgICBwcm9wc1Vuc3RhYmxlSW5wdXQub25JbnB1dCA9IHByZXZlbnREZWZhdWx0O1xuICAgIHByb3BzVW5zdGFibGVJbnB1dC5vbkNoYW5nZSA9IHByZXZlbnREZWZhdWx0O1xuXG4gICAgcHJvcHNVbnN0YWJsZUlucHV0LnR5cGUgPSByb2xlID09IFwicmFkaW9cIiA/IFwicmFkaW9cIiA6IFwiY2hlY2tib3hcIjtcblxuICAgIHN3aXRjaCAobGFiZWxQb3NpdGlvbikge1xuICAgICAgICBjYXNlIFwic2VwYXJhdGVcIjoge1xuICAgICAgICAgICAgaWYgKHRhZ0lucHV0ID09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgICAgIC8vIEV2ZW4gaW4gdGhlIG1vc3QgZGVmYXVsdCBpbnB1dCBiZWhhdmlvciwgd2Ugc3RpbGwgbmVlZCB0byBoYW5kbGVcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGFic3RyYWN0aW9uIG92ZXIgY2hlY2tlZD1cIm1peGVkXCIgYW5kIGRpc2FibGVkPVwic29mdFwiXG4gICAgICAgICAgICAgICAgcHJvcHNVbnN0YWJsZUlucHV0LmNoZWNrZWQgPSAoY2hlY2tlZCA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkID09PSB0cnVlIHx8IGRpc2FibGVkID09PSAnaGFyZCcpXG4gICAgICAgICAgICAgICAgICAgIHByb3BzVW5zdGFibGVJbnB1dC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlzYWJsZWQgPT0gXCJzb2Z0XCIpXG4gICAgICAgICAgICAgICAgICAgIHByb3BzVW5zdGFibGVJbnB1dFtcImFyaWEtZGlzYWJsZWRcIl0gPSBcInRydWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRpdiBpbnB1dHMgbmVlZCB0aGVpciB2YXJpb3VzIEFSSUEgcm9sZXMgYW5kIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBwcm9wc1Vuc3RhYmxlSW5wdXQucm9sZSA9IHJvbGU7XG4gICAgICAgICAgICAgICAgcHJvcHNVbnN0YWJsZUlucHV0LnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBwcm9wc1Vuc3RhYmxlSW5wdXRbXCJhcmlhLWNoZWNrZWRcIl0gPSAoY2hlY2tlZCA/PyBmYWxzZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBwcm9wc1Vuc3RhYmxlSW5wdXRbXCJhcmlhLWRpc2FibGVkXCJdID0gKCEhZGlzYWJsZWQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YWdMYWJlbCAhPSBcImxhYmVsXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIHNwZWNpYWwgZm9yIHJlZ3VsYXIgbGFiZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgc3BlY2lhbCBoYW5kbGluZyBmb3IgZGl2IGxhYmVscyBpcyBhbHJlYWR5IGNvdmVyZWQgYnkgdXNlTGFiZWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ3cmFwcGluZ1wiOiB7XG4gICAgICAgICAgICBpZiAodGFnSW5wdXQgPT0gXCJpbnB1dFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGZvcm0gc3VibWlzc2lvbiBhbmQgc3R5bGluZ1xuICAgICAgICAgICAgICAgIHByb3BzVW5zdGFibGVJbnB1dC5jaGVja2VkID0gKGNoZWNrZWQgPT09IHRydWUpO1xuICAgICAgICAgICAgICAgIHByb3BzVW5zdGFibGVJbnB1dC5kaXNhYmxlZCA9IChkaXNhYmxlZCA9PT0gdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSB3cmFwcGVkIGxhYmVsIGhhbmRsZXMgYWxsIGludGVyYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGlzIGVsZW1lbnQgY2FuJ3QgYmUgaW50ZXJhY3RlZCB3aXRoXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpZiBpdCdzIGFuIGlucHV0IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgcHJvcHNVbnN0YWJsZUlucHV0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9wc1Vuc3RhYmxlSW5wdXQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBwcm9wc1Vuc3RhYmxlSW5wdXQucm9sZSA9IFwicHJlc2VudGF0aW9uXCI7XG4gICAgICAgICAgICAgICAgcHJvcHNVbnN0YWJsZUlucHV0W1wiYXJpYS1oaWRkZW5cIl0gPSBcInRydWVcIjtcbiAgICAgICAgICAgICAgICBwcm9wc1Vuc3RhYmxlSW5wdXQub25Gb2N1cyA9IF8gPT4gKGdldExhYmVsRWxlbWVudD8uKCkgYXMgSFRNTEVsZW1lbnQgfCBudWxsKT8uZm9jdXM/LigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2l0aCBhIHdyYXBwaW5nIGxhYmVsLCB3ZSdyZSBqdXN0IHVzaW5nIHRoZSBpbnB1dCBmb3IgdmlzdWFsIHN0eWxpbmcgYW5kIGlnbm9yaW5nIGFsbCBpbnRlcmFjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBXaXRoIGEgZGl2LCB3ZSBnZXQgdGhhdCBmb3IgZnJlZSBhbmQgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBoZXJlLlxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIFdyYXBwaW5nIGxhYmVscyBhcmUgdGhlIGFjdHVhbCBpbnB1dHMgdGhhdCBhcmUgaW50ZXJhY3RlZCB3aXRoXG4gICAgICAgICAgICAvLyBBbmQgYXJlIHZlcnkgc2ltaWxhciBjb25jZXB0dWFsbHkgdG8gZGl2IGlucHV0cyB3aGVuIHNlcGFyYXRlZFxuICAgICAgICAgICAgcHJvcHNVbnN0YWJsZUxhYmVsLnJvbGUgPSByb2xlO1xuICAgICAgICAgICAgcHJvcHNVbnN0YWJsZUxhYmVsLnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgIHByb3BzVW5zdGFibGVMYWJlbFtcImFyaWEtY2hlY2tlZFwiXSA9IChjaGVja2VkID8/IGZhbHNlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgcHJvcHNVbnN0YWJsZUxhYmVsW1wiYXJpYS1kaXNhYmxlZFwiXSA9ICghIWRpc2FibGVkKS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgbGV0IGVsZW1lbnRUb0ZvY3VzOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICAgICAgICBpZiAobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIpXG4gICAgICAgICAgICBlbGVtZW50VG9Gb2N1cyA9IGdldExhYmVsRWxlbWVudCgpIGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGVsZW1lbnRUb0ZvY3VzID0gZ2V0SW5wdXRFbGVtZW50KCkgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudDtcblxuICAgICAgICBlbGVtZW50VG9Gb2N1cz8uZm9jdXMoKTtcbiAgICB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZG9tSWRJbnB1dFJldHVybixcbiAgICAgICAgcmFuZG9tSWRMYWJlbFJldHVybixcbiAgICAgICAgcHJlc3NJbnB1dFJldHVybixcbiAgICAgICAgcHJlc3NMYWJlbFJldHVybixcbiAgICAgICAgY2hlY2tib3hMaWtlSW5wdXRSZXR1cm46IHsgcHJvcHNVbnN0YWJsZTogcHJvcHNVbnN0YWJsZUlucHV0IH0sXG4gICAgICAgIGNoZWNrYm94TGlrZUxhYmVsUmV0dXJuOiB7IHByb3BzVW5zdGFibGU6IHByb3BzVW5zdGFibGVMYWJlbCB9LFxuICAgICAgICBwcm9wc0lucHV0OiB1c2VNZXJnZWRQcm9wcyhwcm9wc0lucHV0LCBwcm9wc1Vuc3RhYmxlSW5wdXQsIHByZXNzSW5wdXRSZXR1cm4ucHJvcHNTdGFibGUsIHJlZkVsZW1lbnRJbnB1dFJldHVybi5wcm9wc1N0YWJsZSksXG4gICAgICAgIHByb3BzTGFiZWw6IHVzZU1lcmdlZFByb3BzKHByb3BzTGFiZWwsIHByb3BzVW5zdGFibGVMYWJlbCwgcHJlc3NMYWJlbFJldHVybi5wcm9wc1N0YWJsZSwgcmVmRWxlbWVudExhYmVsUmV0dXJuLnByb3BzU3RhYmxlKSxcbiAgICAgICAgY2hlY2tib3hMaWtlUmV0dXJuOiB7IGZvY3VzU2VsZiB9XG4gICAgfVxufVxuXG5cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBFbmhhbmNlZEV2ZW50LCBlbmhhbmNlRXZlbnQsIFByZWZpY2VzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IExhYmVsUG9zaXRpb24sIHVzZUNoZWNrYm94TGlrZSwgVXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVycywgVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xuXG5cblxuZXhwb3J0IHR5cGUgQ2hlY2tib3hDaGFuZ2VFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gRW5oYW5jZWRFdmVudDxFLCBFdmVudCwgeyBjaGVja2VkOiBib29sZWFuIH0+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94UGFyYW1ldGVyczxMUCBleHRlbmRzIExhYmVsUG9zaXRpb24sIEkgZXh0ZW5kcyBFbGVtZW50LCBMIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8TFAsIEksIEw+LCBcImNoZWNrYm94TGlrZVBhcmFtZXRlcnNcIiB8IFwicmFuZG9tSWRJbnB1dFBhcmFtZXRlcnNcIiB8IFwicmFuZG9tSWRMYWJlbFBhcmFtZXRlcnNcIj4ge1xuICAgIGNoZWNrYm94TGlrZVBhcmFtZXRlcnM6IE9taXQ8VXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxMUCwgSSwgTD5bXCJjaGVja2JveExpa2VQYXJhbWV0ZXJzXCJdLCBcIm9uSW5wdXRcIiB8IFwicm9sZVwiIHwgXCJwcmVmaXhcIj47XG4gICAgY2hlY2tib3hQYXJhbWV0ZXJzOiB7XG4gICAgICAgIG9uQ2hlY2tlZENoYW5nZShldmVudDogQ2hlY2tib3hDaGFuZ2VFdmVudDxJPik6IHZvaWQ7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94UmV0dXJuVHlwZTxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGU8SW5wdXRUeXBlLCBMYWJlbFR5cGU+IHtcbiAgICBjaGVja2JveFJldHVybjogeyBwcm9wc1Vuc3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoZWNrYm94PExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgSW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGNoZWNrYm94UGFyYW1ldGVyczogeyBvbkNoZWNrZWRDaGFuZ2UgfSxcbiAgICBjaGVja2JveExpa2VQYXJhbWV0ZXJzLFxuICAgIGxhYmVsUGFyYW1ldGVycyxcbiAgICByZWZFbGVtZW50SW5wdXRSZXR1cm4sXG4gICAgcmVmRWxlbWVudExhYmVsUmV0dXJuXG59OiBVc2VDaGVja2JveFBhcmFtZXRlcnM8TFAsIElucHV0VHlwZSwgTGFiZWxUeXBlPik6IFVzZUNoZWNrYm94UmV0dXJuVHlwZTxJbnB1dFR5cGUsIExhYmVsVHlwZT4ge1xuICAgIGRlYnVnTG9nKFwidXNlQ2hlY2tib3hcIik7XG5cbiAgICBjb25zdCB7IHRhZ0lucHV0LCBsYWJlbFBvc2l0aW9uIH0gPSBsYWJlbFBhcmFtZXRlcnM7XG4gICAgY29uc3QgeyBjaGVja2VkIH0gPSBjaGVja2JveExpa2VQYXJhbWV0ZXJzO1xuXG4gICAgY29uc3Qgb25JbnB1dEVuaGFuY2VkID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IEV2ZW50KSA9PiBvbkNoZWNrZWRDaGFuZ2U/LihlbmhhbmNlRXZlbnQ8SW5wdXRUeXBlLCBFdmVudCwgeyBjaGVja2VkOiBib29sZWFuIH0+KGUsIHsgY2hlY2tlZDogIWNoZWNrZWQgfSkpKTtcbiAgICBjb25zdCB7XG4gICAgICAgIHByZXNzSW5wdXRSZXR1cm4sXG4gICAgICAgIHByZXNzTGFiZWxSZXR1cm4sXG4gICAgICAgIHJhbmRvbUlkSW5wdXRSZXR1cm4sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxSZXR1cm4sXG4gICAgICAgIHByb3BzSW5wdXQsXG4gICAgICAgIHByb3BzTGFiZWwsXG4gICAgICAgIGNoZWNrYm94TGlrZVJldHVybixcbiAgICAgICAgY2hlY2tib3hMaWtlSW5wdXRSZXR1cm4sXG4gICAgICAgIGNoZWNrYm94TGlrZUxhYmVsUmV0dXJuXG4gICAgfSA9IHVzZUNoZWNrYm94TGlrZTxMUCwgSW5wdXRUeXBlLCBMYWJlbFR5cGU+KHtcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5jaGVja2JveExpa2VJbnB1dCB9LFxuICAgICAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLmNoZWNrYm94TGlrZUxhYmVsIH0sXG4gICAgICAgIHJlZkVsZW1lbnRJbnB1dFJldHVybixcbiAgICAgICAgcmVmRWxlbWVudExhYmVsUmV0dXJuLFxuICAgICAgICBjaGVja2JveExpa2VQYXJhbWV0ZXJzOiB7IHJvbGU6IFwiY2hlY2tib3hcIiwgb25JbnB1dDogb25JbnB1dEVuaGFuY2VkLCAgLi4uY2hlY2tib3hMaWtlUGFyYW1ldGVycyB9LFxuICAgICAgICBsYWJlbFBhcmFtZXRlcnNcbiAgICB9KTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hlY2tib3hSZXR1cm46IHsgcHJvcHNVbnN0YWJsZTogeyB0eXBlOiAodGFnSW5wdXQgPT0gXCJpbnB1dFwiICYmIGxhYmVsUG9zaXRpb24gIT0gXCJ3cmFwcGluZ1wiID8gXCJjaGVja2JveFwiIDogdW5kZWZpbmVkKSB9IH0sXG4gICAgICAgIGNoZWNrYm94TGlrZVJldHVybixcbiAgICAgICAgcHJlc3NJbnB1dFJldHVybixcbiAgICAgICAgcHJlc3NMYWJlbFJldHVybixcbiAgICAgICAgcmFuZG9tSWRJbnB1dFJldHVybixcbiAgICAgICAgcmFuZG9tSWRMYWJlbFJldHVybixcbiAgICAgICAgcHJvcHNJbnB1dCxcbiAgICAgICAgcHJvcHNMYWJlbCxcbiAgICAgICAgY2hlY2tib3hMaWtlSW5wdXRSZXR1cm4sXG4gICAgICAgIGNoZWNrYm94TGlrZUxhYmVsUmV0dXJuXG4gICAgfTtcblxufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0LCBQYXNzaXZlU3RhdGVVcGRhdGVyLCByZXR1cm5GYWxzZSwgcmV0dXJuTnVsbCwgcmV0dXJuWmVybywgdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbiwgdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGUsIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm8sIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YWJsZU9iamVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBFbmhhbmNlZEV2ZW50LCBub29wIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IENoZWNrYm94Q2hlY2tlZFR5cGUgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcblxuZXhwb3J0IHR5cGUgQ2hlY2tib3hHcm91cENoYW5nZUV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSBFbmhhbmNlZEV2ZW50PEUsIEV2ZW50LCB7IGNoaWxkcmVuQ2hlY2tlZDogYm9vbGVhbiB8IE1hcDxudW1iZXIsIGJvb2xlYW4gfCBcIm1peGVkXCI+IH0+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBDaGVja2JveEdyb3VwSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudD4+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgTT4sIFwic2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyc1wiPiB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHBhcmVudCBjaGVja2JveCBpcyBjaGFuZ2VkIGFuZCBhbiB1cGRhdGUgb2ZcbiAgICAgKiBhbGwgdGhlIGNoaWxkcmVuIG5lZWRzIHRvIG9jY3VyLlxuICAgICAqIFxuICAgICAqIGBldmVudFtFdmVudERldGFpbF0uY2hpbGRyZW5DaGVja2VkYCB3aWxsIGJlIFxuICAgICAqICogdHJ1ZSB3aGVuIGFsbCBjaGlsZHJlbiBuZWVkIHRvIGJlY29tZSBjaGVja2VkXG4gICAgICogKiBmYWxzZSB3aGVuIGFsbCBjaGlsZHJlbiBuZWVkIHRvIGJlY29tZSB1bmNoZWNrZWRcbiAgICAgKiAqIEEgYE1hcDxpbmRleCxjaGVja2VkPmAgb2YgZWFjaCBjaGlsZCdzIHN0YXR1cyB3aGVuIHJldmVydGluZyB0byBcIm1peGVkXCIuXG4gICAgICogXG4gICAgICogQmVjYXVzZSB3ZSdyZSBkZWFsaW5nIHdpdGggY29udHJvbGxlZCBjb21wb25lbnRzIGhlcmUsIGFuZCB0aGUgZGF0YSBmb3JcbiAgICAgKiB3aGF0IGNoZWNrYm94ZXMgYXJlIGNoZWNrZWQgbGl2ZSAqb3V0c2lkZSogb2YgYW55IG9mIHRoZXNlIGhvb2tzLFxuICAgICAqIGl0J3MgeW91IHdobydzIHJlc3BvbnNpYmxlIGZvciBsaXN0ZW5pbmcgZm9yIHRoaXMgZXZlbnQsIG1vZGlmeWluZyB0aGVcbiAgICAgKiBkYXRhLCBhbmQgcmUtcmVuZGVyaW5nIGFwcHJvcHJpYXRlbHkuXG4gICAgICogXG4gICAgICogSGlnaGx5IHJlY29tbWVuZGVkIHRvLCBmb3IgZXhhbXBsZSwgYWRkIGVhY2ggY2hpbGQncyBgb25JbnB1dGAgZXZlbnQgaGFuZGxlclxuICAgICAqIGF2YWlsYWJsZSBpbiB0aGUgY2hpbGQgaW5mbyB0aGUgcGFyZW50IGdldHMgc28gaXQgY2FuIGNhbGwgdGhlIGhhbmRsZXJcbiAgICAgKiByZW1vdGVseSBmcm9tIGBtYW5hZ2VkQ2hlY2tib3hlc2AuXG4gICAgICogQHBhcmFtIGV2ZW50IFxuICAgICAqL1xuICAgIC8vY2hlY2tib3hHcm91cDoge31cbiAgICAvL29uVXBkYXRlQ2hpbGRyZW4oZXZlbnQ6IENoZWNrYm94R3JvdXBDaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+Pik6IHZvaWQ7XG59XG5cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRJbmZvQmFzZTxLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPiB7XG4vKipcbiAqIFRoZSBpZCBhdHRyaWJ1dGUgdXNlZCBmb3IgdGhlIGNoaWxkLlxuICovXG4vL2lkOiBzdHJpbmc7XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgY2hlY2tlZCBzdGF0ZSBvZiB0aGlzIGNoaWxkLlxuICogXG4gKiBUaGlzIGlzIHVzZWQgYnkgdGhlIHBhcmVudCB3aGVuZXZlciBpdCdzIGludGVyYWN0ZWQgd2l0aCBcbiAqIGFuZCBhYm91dCB0byBmb3JjZSBldmVyeSBvbmUgdG8gYmUgc29tZXRoaW5nIGRpZmZlcmVudCAtLSBcbiAqIGl0IHdpbGwgc2F2ZSB0aGUgc3RhdGUgb2YgYWxsIGNoaWxkIGNoZWNrYm94ZXMgZm9yIGxhdGVyXG4gKiBieSBhc2tpbmcgZWFjaCBvbmUgd2hhdCBpdHMgY3VycmVudCBzdGF0ZSBpcyBpbmRpdmlkdWFsbHlcbiAqIGF0IHRoYXQgbW9tZW50LlxuICogXG4gKiBBbGwgdGhlIGNoZWNrYm94J3Mgc3RhdGVzIGFyZSBjYXB0dXJlZCB3aGVuIHRoZSBwYXJlbnRcbiAqIGlzIGluIHRoZSBcIm1peGVkXCIgc3RhdGUgYW5kIGlzIGNsaWNrZWQuIEl0IGtlZXBzIHRoZW1cbiAqIHRoYXQgd2F5IHVudGlsIHRoZSBzYW1lIGNvbmRpdGlvbnMgYXJpc2UgYWdhaW4uXG4gKi9cbi8vICAgIGdldExhc3RVc2VyQ2hlY2tlZCgpOiBib29sZWFuIHwgXCJtaXhlZFwiO1xuLy8gICAgb25JbnB1dDogVXNlQ2hlY2tib3hQYXJhbWV0ZXJzPGFueSwgYW55PltcIm9uSW5wdXRcIl07XG4vL31cblxuaW50ZXJmYWNlIENoZWNrYm94R3JvdXBJbmZvQmFzZUJhc2U8VENFIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIF9lPzogVENFO1xufVxuXG5pbnRlcmZhY2UgQ2hlY2tib3hHcm91cEluZm9CYXNlMTxUQ0UgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIENoZWNrYm94R3JvdXBJbmZvQmFzZUJhc2U8VENFPiB7XG4gICAgY2hlY2tib3hDaGlsZFR5cGU6IFwicGFyZW50XCI7XG59XG5cbmludGVyZmFjZSBDaGVja2JveEdyb3VwSW5mb0Jhc2UyPFRDRSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgQ2hlY2tib3hHcm91cEluZm9CYXNlQmFzZTxUQ0U+IHtcbiAgICBjaGVja2JveENoaWxkVHlwZTogXCJjaGlsZFwiO1xuICAgIGdldENoZWNrZWQoKTogYm9vbGVhbiB8IFwibWl4ZWRcIjtcbiAgICBnZXRMYXN0VXNlckNoZWNrZWQoKTogYm9vbGVhbiB8IFwibWl4ZWRcIjtcbiAgICBzZXRDaGVja2VkRnJvbVBhcmVudElucHV0KG5ld0NoZWNrZWQ6IENoZWNrYm94Q2hlY2tlZFR5cGUsIGU6IEV2ZW50KTogdm9pZCB8IFByb21pc2U8dm9pZD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tib3hHcm91cEluZm88VENFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2hpbGRJbmZvPFRDRT4ge1xuICAgIGNoZWNrYm94SW5mbzogKENoZWNrYm94R3JvdXBJbmZvQmFzZTE8VENFPiB8IENoZWNrYm94R3JvdXBJbmZvQmFzZTI8VENFPik7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPFRDRSBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBDaGVja2JveEdyb3VwSW5mbzxUQ0U+PiBleHRlbmRzIE9taXQ8VXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxUQ0UsIE0sIFwiY2hlY2tib3hJbmZvXCI+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIiB8IFwicHJlc3NQYXJhbWV0ZXJzXCIgfCBcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiPiB7XG4gICAgY29udGV4dDogQ2hlY2tib3hHcm91cENvbnRleHQ8YW55LCBUQ0UsIE0+O1xuICAgIGNoZWNrYm94R3JvdXBDaGlsZDoge1xuICAgICAgICAvL2ZvY3VzU2VsZihlOiBUQ0UpOiB2b2lkO1xuICAgICAgICBjaGVja2VkOiBDaGVja2JveENoZWNrZWRUeXBlO1xuICAgICAgICBvbkNoYW5nZUZyb21QYXJlbnQoY2hlY2tlZDogQ2hlY2tib3hDaGVja2VkVHlwZSwgZTogRXZlbnQpOiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgICB9XG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgTSwgbmV2ZXI+W1wibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiXSwgXCJjaGVja2JveENoaWxkVHlwZVwiPlxuICAgIHByZXNzUGFyYW1ldGVyczogVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxUQ0UsIE0sIG5ldmVyPltcInByZXNzUGFyYW1ldGVyc1wiXTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZTxUQ0UgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgQ2hlY2tib3hHcm91cEluZm88VENFPj4gZXh0ZW5kcyBPbWl0PFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU8VENFLCBNPiwgXCJzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnNcIj4ge1xuICAgIGNoZWNrYm94R3JvdXBDaGlsZDoge1xuICAgICAgICBvbkNvbnRyb2xJZENoYW5nZWQ6IChuZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQsIHByZXY6IHN0cmluZyB8IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgICAgICAgb25DaGlsZENoZWNrZWRDaGFuZ2U6IChjaGVja2VkOiBDaGVja2JveENoZWNrZWRUeXBlKSA9PiB2b2lkO1xuICAgIH1cbn1cblxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4ge1xuLy8gVGhpcyBpcyBqdXN0IHdoaWNoZXZlciBvZiB0aGUgdHdvIHNob3VsZCByZWNlaXZlIGxpc3QtbmF2LXJlbGF0ZWQgcHJvcHMgKHNvIGJhc2VkIG9uIGBsYWJlbFBvc2l0aW9uYCBmb3IgY2hlY2tib3hlcykuXG4vLyBBbHRlcm5hdGl2ZWx5LCBkb24ndCB1c2UgdGhpcyBpZiB5b3UgZXhwbGljaXRseSBkb24ndCB3YW50IHRoaXMgZ3JvdXAncyBsaXN0IG5hdmlnYXRpb25cbi8vbGlzdE5hdmlnYXRpb25DaGlsZFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+IHwgaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pjtcbi8vfVxuXG5cbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUQ0UgZXh0ZW5kcyBJbnB1dEVsZW1lbnQgfCBMYWJlbEVsZW1lbnQsIE0gZXh0ZW5kcyBDaGVja2JveEdyb3VwSW5mbzxUQ0U+PiA9IChhcmdzOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgTT4pID0+IFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGU8VENFLCBNPiAvKntcbiAgICAvL3RhYmJhYmxlOiBib29sZWFuIHwgbnVsbDtcbiAgICBjaGVja2JveExpa2U6IFVzZUNoZWNrYm94UmV0dXJuVHlwZTxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD5bXCJjaGVja2JveExpa2VcIl07XG4gICAgbGFiZWw6IFVzZUNoZWNrYm94UmV0dXJuVHlwZTxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD5bXCJsYWJlbFwiXTtcbiAgICByb3ZpbmdUYWJJbmRleDogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU8SW5wdXRFbGVtZW50PltcInJvdmluZ1RhYkluZGV4XCJdO1xuICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHM6ICh7IHRhYkluZGV4LCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+O1xuICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZExhYmVsUHJvcHM6ICh7IHRhYkluZGV4LCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xufSovXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlPEdyb3VwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRDRSBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBDaGVja2JveEdyb3VwSW5mbzxUQ0U+PiBleHRlbmRzIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPEdyb3VwRWxlbWVudCwgVENFLCBNPiB7XG4gICAgY29udGV4dDogQ2hlY2tib3hHcm91cENvbnRleHQ8R3JvdXBFbGVtZW50LCBUQ0UsIE0+O1xufVxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVXaXRoSG9va3M8R3JvdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ0JHU3ViSW5mbywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZUluZm88R3JvdXBFbGVtZW50LCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgQ0JHU3ViSW5mbywgSz4ge1xuLyoqICoqU1RBQkxFICoqICovXG4vL2NoZWNrYm94ZXM6IE1hbmFnZWRDaGlsZHJlbjxJPjtcbi8qKlxuICogRWFjaCBjaGlsZCBjaGVja2JveCBtdXN0IGNhbGwgdGhpcyBob29rLCAqaW4gYWRkaXRpb24gdG8qIGB1c2VDaGVja2JveGBcbiAqL1xuLy8gICAgdXNlQ2hlY2tib3hHcm91cENoaWxkOiBVc2VDaGVja2JveEdyb3VwQ2hpbGQ8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIENCR1N1YkluZm8sIEs+O1xuLyoqXG4gKiAqKlNUQUJMRSoqXG4gKiBcbiAqIFRoZSBwYXJlbnQgY2hlY2tib3ggbXVzdCB1c2UgdGhpcyBob29rXG4gKi9cbi8vICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnQ6IFVzZUNoZWNrYm94R3JvdXBQYXJlbnQ8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIENCR1N1YkluZm8sIEs+O1xuXG4vLyBVc2Ugb24gZWl0aGVyIGUuZy4gdGhlIGRpdiBjb250YWluaW5nIHRoZSBjaGlsZHJlbiwgb3IgZWFjaCBpbmRpdmlkdWFsIGNoaWxkXG4vL2xpc3ROYXZpZ2F0aW9uUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT47XG4vL31cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWludGVyZmFjZSAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0UgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgQ2hlY2tib3hHcm91cEluZm88VENFPj4gZXh0ZW5kcyBPbWl0PFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8VENFLCBNLCBuZXZlcj4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiIHwgXCJwcmVzc1BhcmFtZXRlcnNcIiB8IFwic2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzXCI+IHtcbiAgICBjb250ZXh0OiBDaGVja2JveEdyb3VwQ29udGV4dDxhbnksIFRDRSwgTT47XG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPiwgbmV2ZXI+W1wibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiXSwgXCJnZXRDaGVja2VkXCIgfCBcImdldExhc3RVc2VyQ2hlY2tlZFwiIHwgXCJzZXRDaGVja2VkRnJvbVBhcmVudElucHV0XCIgfCBcImNoZWNrYm94Q2hpbGRUeXBlXCI+XG4gICAgcHJlc3NQYXJhbWV0ZXJzOiBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPiwgbmV2ZXI+W1wicHJlc3NQYXJhbWV0ZXJzXCJdO1xufVxuXG4vL2V4cG9ydCB0eXBlIFVzZUNoZWNrYm94R3JvdXBQYXJlbnQ8VENFIGV4dGVuZHMgRWxlbWVudD4gPSAoYTogVXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8VENFPikgPT4gVXNlQ2hlY2tib3hHcm91cFBhcmVudFJldHVyblR5cGU8VENFPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwUGFyZW50UmV0dXJuVHlwZTxUQ0UgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgQ2hlY2tib3hHcm91cEluZm88VENFPj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPFRDRSwgTT4ge1xuICAgIGNoZWNrYm94R3JvdXBQYXJlbnRSZXR1cm46IHtcbiAgICAgICAgY2hlY2tlZDogQ2hlY2tib3hDaGVja2VkVHlwZTtcbiAgICAgICAgZ2V0UGVyY2VudCgpOiBudW1iZXI7XG4gICAgICAgIG9uUGFyZW50Q2hlY2tlZENoYW5nZTogKGU6IEV2ZW50KSA9PiBQcm9taXNlPHZvaWQ+O1xuICAgIH1cbn1cblxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBQYXJlbnRSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIF9MYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoZWNrYm94R3JvdXBQYXJlbnRSZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQ+IHtcbi8vICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+O1xuLy99XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tib3hHcm91cENvbnRleHQ8R3JvdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVENFIGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+IGV4dGVuZHMgQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNvbnRleHQ8R3JvdXBFbGVtZW50LCBUQ0UsIE0+IHtcbiAgICAvLyBwYXJlbnRcbiAgICBjaGVja2JveEdyb3VwUGFyZW50Q29udGV4dDoge1xuXG4gICAgICAgIC8vIFdoYXQgYSBob3JyaWZ5aW5nIHR5cGUuICBOYW1lIHRoaXMgYmV0dGVyIHBsZWFzZS5cbiAgICAgICAgc2V0U2V0dGVyOiBQYXNzaXZlU3RhdGVVcGRhdGVyPFN0YXRlVXBkYXRlcjxzdHJpbmc+IHwgbnVsbCwgRXZlbnQ+O1xuXG4gICAgICAgIC8vIHdoeXl5eXlcbiAgICAgICAgc2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkOiBQYXNzaXZlU3RhdGVVcGRhdGVyPFN0YXRlVXBkYXRlcjxDaGVja2JveENoZWNrZWRUeXBlPiB8IG51bGwsIEV2ZW50PjtcblxuICAgICAgICBnZXRQZXJjZW50Q2hlY2tlZDogKHRvdGFsQ2hlY2tlZDogbnVtYmVyLCB0b3RhbENoaWxkcmVuOiBudW1iZXIpID0+IG51bWJlcjtcblxuICAgICAgICBnZXRUb3RhbENoZWNrZWQ6ICgpID0+IG51bWJlcjtcbiAgICAgICAgZ2V0VG90YWxDaGlsZHJlbjogKCkgPT4gbnVtYmVyO1xuXG4gICAgICAgIG9uQ2hlY2tib3hHcm91cFBhcmVudElucHV0OiAoZTogRXZlbnQpID0+IFByb21pc2U8dm9pZD47XG4gICAgfVxuICAgIGNoZWNrYm94R3JvdXBDaGlsZHJlbkNvbnRleHQ6IHtcblxuICAgICAgICAvLyBjaGlsZHJlblxuICAgICAgICBzZXRVcGRhdGVJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxudW1iZXIsIEV2ZW50PjtcbiAgICAgICAgYWxsSWRzOiBTZXQ8c3RyaW5nPjtcbiAgICAgICAgc2V0VG90YWxDaGlsZHJlbjogUGFzc2l2ZVN0YXRlVXBkYXRlcjxudW1iZXIsIEV2ZW50PjtcbiAgICAgICAgc2V0VG90YWxDaGVja2VkOiBQYXNzaXZlU3RhdGVVcGRhdGVyPG51bWJlciwgRXZlbnQ+O1xuICAgIH1cblxufVxuXG4vKipcbiAqIFxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGVja2JveEdyb3VwPEdyb3VwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRDRSBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1xufTogVXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnM8R3JvdXBFbGVtZW50LCBUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+KTogVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGU8R3JvdXBFbGVtZW50LCBUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZUNoZWNrYm94R3JvdXBcIik7XG4gICAgLy9jb25zdCBvblVwZGF0ZUNoaWxkcmVuID0gdXNlU3RhYmxlQ2FsbGJhY2sob25VcGRhdGVDaGlsZHJlblVuc3RhYmxlID8/ICgoKSA9PiB7fSkpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblxuICAgIH0gPSB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uPEdyb3VwRWxlbWVudCwgVENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+Pih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IHsgaW5pdGlhbGx5U2VsZWN0ZWRJbmRleDogbnVsbCwgc2V0U2VsZWN0ZWRJbmRleDogbnVsbCB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgZ2V0Q2hpbGRyZW4gfSA9IG1hbmFnZWRDaGlsZHJlblJldHVybjtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGdldENoaWxkcmVuKCk7XG5cbiAgICAvL2NvbnN0IFt1bmNoZWNrZWRDb3VudCwgc2V0VW5oZWNrZWRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcblxuXG4gICAgLy8gS2VlcCB0cmFjayBvZiBhbGwgY2hpbGQgSURzLCBhbmQgYW55IHRpbWUgYW55IG9mIHRoZW0gY2hhbmdlLCBcbiAgICAvLyBnZW5lcmF0ZSBhIG5ldyBzdHJpbmcgd2l0aCBhbGwgb2YgdGhlbSBjb25jYXRlbmF0ZWQgdG9nZXRoZXJcbiAgICAvLyAoYnV0IG9ubHkgb25jZSBwZXIgcmVuZGVyKTtcbiAgICBjb25zdCBhbGxJZHMgPSB1c2VSZWYobmV3IFNldDxzdHJpbmc+KCkpO1xuICAgIGNvbnN0IHVwZGF0ZVBhcmVudENvbnRyb2xJZHMgPSB1c2VTdGFibGVDYWxsYmFjaygoc2V0dGVyOiBTdGF0ZVVwZGF0ZXI8c3RyaW5nPiB8IG51bGwpID0+IHsgc2V0dGVyPy4oQXJyYXkuZnJvbShhbGxJZHMuY3VycmVudCkuam9pbihcIiBcIikpIH0pO1xuICAgIGNvbnN0IFtnZXRTZXR0ZXIsIHNldFNldHRlcl0gPSB1c2VQYXNzaXZlU3RhdGU8U3RhdGVVcGRhdGVyPHN0cmluZz4gfCBudWxsLCBFdmVudD4odXBkYXRlUGFyZW50Q29udHJvbElkcywgcmV0dXJuTnVsbCk7XG4gICAgY29uc3QgW19nZXRVcGRhdGVJbmRleCwgc2V0VXBkYXRlSW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciwgRXZlbnQ+KHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHsgdXBkYXRlUGFyZW50Q29udHJvbElkcyhnZXRTZXR0ZXIoKSkgfSksIHJldHVyblplcm8pO1xuXG4gICAgLy8gTG90cyBvZiBtYWNoZW5lcnkgdG8gdHJhY2sgd2hhdCB0b3RhbCBwZXJjZW50YWdlIG9mIGFsbCBjaGVja2JveGVzIGFyZSBjaGVja2VkLFxuICAgIC8vIGFuZCBub3RpZnlpbmcgdGhlIHBhcmVudCBjaGVja2JveCBvZiB0aGlzIGluZm9ybWF0aW9uICh3aGlsZSByZS1yZW5kZXJpbmcgYXMgbGl0dGxlIGFzIHBvc3NpYmxlKVxuICAgIGNvbnN0IGdldFNlbGZJc0NoZWNrZWQgPSB1c2VDYWxsYmFjaygocGVyY2VudENoZWNrZWQ6IG51bWJlcik6IENoZWNrYm94Q2hlY2tlZFR5cGUgPT4geyByZXR1cm4gcGVyY2VudENoZWNrZWQgPD0gMCA/IGZhbHNlIDogcGVyY2VudENoZWNrZWQgPj0gMSA/IHRydWUgOiBcIm1peGVkXCI7IH0sIFtdKTtcbiAgICBjb25zdCBvbkFueUNoaWxkQ2hlY2tlZFVwZGF0ZSA9IHVzZVN0YWJsZUNhbGxiYWNrKChzZXR0ZXI6IFN0YXRlVXBkYXRlcjxDaGVja2JveENoZWNrZWRUeXBlPiB8IG51bGwsIHBlcmNlbnRDaGVja2VkOiBudW1iZXIpID0+IHsgc2V0dGVyPy4oZ2V0U2VsZklzQ2hlY2tlZChwZXJjZW50Q2hlY2tlZCkpOyB9KVxuICAgIGNvbnN0IFtnZXRUb3RhbENoaWxkcmVuLCBzZXRUb3RhbENoaWxkcmVuXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VDYWxsYmFjaygodG90YWxDaGlsZHJlbjogbnVtYmVyKSA9PiB7IG9uQW55Q2hpbGRDaGVja2VkVXBkYXRlKGdldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZCgpLCBnZXRQZXJjZW50Q2hlY2tlZChnZXRUb3RhbENoZWNrZWQoKSwgdG90YWxDaGlsZHJlbikpIH0sIFtdKSwgcmV0dXJuWmVybyk7XG4gICAgY29uc3QgW2dldFRvdGFsQ2hlY2tlZCwgc2V0VG90YWxDaGVja2VkXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VDYWxsYmFjaygodG90YWxDaGVja2VkOiBudW1iZXIpID0+IHsgb25BbnlDaGlsZENoZWNrZWRVcGRhdGUoZ2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkKCksIGdldFBlcmNlbnRDaGVja2VkKHRvdGFsQ2hlY2tlZCwgZ2V0VG90YWxDaGlsZHJlbigpKSkgfSwgW10pLCByZXR1cm5aZXJvKTtcbiAgICBjb25zdCBnZXRQZXJjZW50Q2hlY2tlZCA9IHVzZUNhbGxiYWNrKCh0b3RhbENoZWNrZWQ6IG51bWJlciwgdG90YWxDaGlsZHJlbjogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICAgICAgaWYgKHRvdGFsQ2hpbGRyZW4gPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsQ2hlY2tlZCAvIHRvdGFsQ2hpbGRyZW47XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAodG90YWxDaGVja2VkID09IDAgPyAwIDogMSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgW2dldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZCwgc2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxTdGF0ZVVwZGF0ZXI8Q2hlY2tib3hDaGVja2VkVHlwZT4gfCBudWxsLCBFdmVudD4odXNlU3RhYmxlQ2FsbGJhY2soKHNldHRlcjogU3RhdGVVcGRhdGVyPENoZWNrYm94Q2hlY2tlZFR5cGU+IHwgbnVsbCkgPT4ge1xuICAgICAgICBvbkFueUNoaWxkQ2hlY2tlZFVwZGF0ZShzZXR0ZXIsIGdldFBlcmNlbnRDaGVja2VkKGdldFRvdGFsQ2hlY2tlZCgpLCBnZXRUb3RhbENoaWxkcmVuKCkpKVxuICAgIH0pKTtcblxuXG4gICAgY29uc3Qgb25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQgPSB1c2VDYWxsYmFjayhhc3luYyAoZTogRXZlbnQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGNvbnN0IHNlbGZJc0NoZWNrZWQgPSBnZXRTZWxmSXNDaGVja2VkKGdldFBlcmNlbnRDaGVja2VkKGdldFRvdGFsQ2hlY2tlZCgpLCBnZXRUb3RhbENoaWxkcmVuKCkpKTtcbiAgICAgICAgY29uc3QgbmV4dENoZWNrZWQgPSAoc2VsZklzQ2hlY2tlZCA9PT0gZmFsc2UgPyBcIm1peGVkXCIgOiBzZWxmSXNDaGVja2VkID09PSBcIm1peGVkXCIgPyB0cnVlIDogZmFsc2UpO1xuICAgICAgICBsZXQgd2lsbENoYW5nZUFueSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwcm9taXNlczogUHJvbWlzZTxhbnk+W10gPSBbXTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuY2hlY2tib3hJbmZvLmNoZWNrYm94Q2hpbGRUeXBlID09IFwiY2hpbGRcIilcbiAgICAgICAgICAgICAgICB3aWxsQ2hhbmdlQW55IHx8PSAoY2hpbGQuY2hlY2tib3hJbmZvLmdldENoZWNrZWQoKSAhPSBjaGlsZC5jaGVja2JveEluZm8uZ2V0TGFzdFVzZXJDaGVja2VkKCkpXG4gICAgICAgIH0pO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5jaGVja2JveEluZm8uY2hlY2tib3hDaGlsZFR5cGUgPT0gXCJjaGlsZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNoZWNrZWQgPSBjaGlsZC5jaGVja2JveEluZm8uZ2V0Q2hlY2tlZCgpO1xuICAgICAgICAgICAgICAgIGxldCBjaGVja2VkOiBDaGVja2JveENoZWNrZWRUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hlY2tlZCA9PSBcIm1peGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbGxDaGFuZ2VBbnkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gKGNoaWxkLmNoZWNrYm94SW5mby5nZXRMYXN0VXNlckNoZWNrZWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZCA9IG5leHRDaGVja2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tlZCAhPSBwcmV2Q2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gY2hpbGQuY2hlY2tib3hJbmZvLnNldENoZWNrZWRGcm9tUGFyZW50SW5wdXQoY2hlY2tlZCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSwgW10pO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBjb250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICAgIGNoZWNrYm94R3JvdXBDaGlsZHJlbkNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgc2V0VXBkYXRlSW5kZXgsXG4gICAgICAgICAgICAgICAgYWxsSWRzOiBhbGxJZHMuY3VycmVudCxcbiAgICAgICAgICAgICAgICBzZXRUb3RhbENoZWNrZWQsXG4gICAgICAgICAgICAgICAgc2V0VG90YWxDaGlsZHJlblxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjaGVja2JveEdyb3VwUGFyZW50Q29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBzZXRTZXR0ZXIsXG4gICAgICAgICAgICAgICAgc2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkLFxuICAgICAgICAgICAgICAgIGdldFBlcmNlbnRDaGVja2VkLFxuICAgICAgICAgICAgICAgIGdldFRvdGFsQ2hlY2tlZCxcbiAgICAgICAgICAgICAgICBnZXRUb3RhbENoaWxkcmVuLFxuICAgICAgICAgICAgICAgIG9uQ2hlY2tib3hHcm91cFBhcmVudElucHV0LFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5cbiAgICAgICAgLypjaGVja2JveEdyb3VwOiB7XG4gICAgICAgICAgICBwYXJlbnRJc0NoZWNrZWQ6IGdldFNlbGZJc0NoZWNrZWRVbnN0YWJsZSgpIGFzIGJvb2xlYW4gfCBcIm1peGVkXCIsXG4gICAgICAgICAgICBwYXJlbnRQZXJjZW50Q2hlY2tlZDogKGNoZWNrZWRDb3VudCAvIChjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSArIDEpKSxcbiAgICAgICAgfSovXG4gICAgfTtcbn1cblxuXG4vLyBJZiB0aGUgdXNlciBoYXMgY2hhbmdlZCB0aGUgcGFyZW50IGNoZWNrYm94J3MgdmFsdWUsIHRoZW4gdGhpcyByZWYgaG9sZHMgYSBtZW1vcnkgb2Ygd2hhdCB2YWx1ZXMgd2VyZSBoZWxkIGJlZm9yZS5cbi8vIE90aGVyd2lzZSwgaXQncyBudWxsIHdoZW4gdGhlIGxhc3QgaW5wdXQgd2FzIGZyb20gYSBjaGlsZCBjaGVja2JveC4gXG4vL2NvbnN0IHNhdmVkQ2hlY2tlZFZhbHVlcyA9IHVzZVJlZjxNYXA8bnVtYmVyLCBib29sZWFuIHwgXCJtaXhlZFwiPiB8IG51bGw+KG51bGwpO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoZWNrYm94R3JvdXBQYXJlbnQ8VENFIGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgY29udGV4dCxcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHByZXNzUGFyYW1ldGVycyxcbiAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnMsXG4gICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnMsXG59OiBVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+KTogVXNlQ2hlY2tib3hHcm91cFBhcmVudFJldHVyblR5cGU8VENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+PiB7XG4gICAgY29uc3QgeyBjaGVja2JveEdyb3VwUGFyZW50Q29udGV4dDogeyBzZXRTZXR0ZXIsIHNldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZCwgZ2V0UGVyY2VudENoZWNrZWQsIGdldFRvdGFsQ2hlY2tlZCwgZ2V0VG90YWxDaGlsZHJlbiwgb25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQgfSB9ID0gY29udGV4dDtcbiAgICAvL2NvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKChlOiBhbnkpID0+IChlIGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmZvY3VzPy4oKSwgW10pO1xuICAgIGNvbnN0IHtcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm4sXG4gICAgICAgIHByZXNzUmV0dXJuLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm4sXG4gICAgfSA9IHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZDxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4sIG5ldmVyPih7XG4gICAgICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHByZXNzUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnMsXG4gICAgICAgIC8vIHNpbmdsZSBzZWxlY3Rpb24gaXNuJ3QgdXNlZCBiZWNhdXNlIGNoZWNrYm94ZXMgYXJlIG11bHRpc2VsZWN0OyBcImRpc2FibGVkXCIgcmVmZXJzIG9ubHkgdG8gdGhhdC5cbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IGFyaWFQcm9wTmFtZTogbnVsbCwgc2VsZWN0aW9uTW9kZTogXCJkaXNhYmxlZFwiLCBkaXNhYmxlZDogdHJ1ZSB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgW2FyaWFDb250cm9scywgc2V0Q29udHJvbHNdID0gdXNlU3RhdGUoXCJcIik7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0U2V0dGVyKCgpID0+IHNldENvbnRyb2xzKTtcbiAgICB9LCBbc2V0Q29udHJvbHNdKTtcbiAgICBkZWJ1Z0xvZyhcInVzZUNoZWNrYm94R3JvdXBQYXJlbnRcIik7XG5cbiAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZTxDaGVja2JveENoZWNrZWRUeXBlPihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkKCgpID0+IHNldENoZWNrZWQpO1xuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgY2hlY2tib3hHcm91cFBhcmVudFJldHVybiA9IHsgY2hlY2tlZCwgb25QYXJlbnRDaGVja2VkQ2hhbmdlOiBvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dCwgZ2V0UGVyY2VudDogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gZ2V0UGVyY2VudENoZWNrZWQoZ2V0VG90YWxDaGVja2VkKCksIGdldFRvdGFsQ2hpbGRyZW4oKSkgfSkgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGVja2JveEdyb3VwUGFyZW50UmV0dXJuLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgcHJlc3NSZXR1cm4sXG4gICAgICAgIHByb3BzOiB1c2VNZXJnZWRQcm9wcyh7IFwiYXJpYS1jb250cm9sc1wiOiBhcmlhQ29udHJvbHMgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxUQ0U+LCBwcm9wcyksXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuLFxuICAgICAgICAvKmNoZWNrYm94R3JvdXBQYXJlbnRSZXR1cm4sXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4sXG4gICAgICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRQcm9wczogZnVuY3Rpb24gdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0UHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+IHtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcyh7IFwiYXJpYS1jb250cm9sc1wiOiBhcmlhQ29udHJvbHMgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+LCBwcm9wcyk7XG4gICAgICAgIH0qL1xuICAgIH1cbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGVja2JveEdyb3VwQ2hpbGQ8VENFIGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGNoZWNrYm94R3JvdXBDaGlsZCxcbiAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIGNvbnRleHQsXG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICBwcmVzc1BhcmFtZXRlcnMsXG4gICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzLFxufTogVXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+KTogVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZTxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+IHtcbiAgICBjb25zdCB7IGNoZWNrYm94R3JvdXBDaGlsZHJlbkNvbnRleHQ6IHsgYWxsSWRzLCBzZXRVcGRhdGVJbmRleCwgc2V0VG90YWxDaGlsZHJlbiwgc2V0VG90YWxDaGVja2VkLCB9IH0gPSBjb250ZXh0O1xuXG4gICAgZGVidWdMb2coXCJ1c2VDaGVja2JveEdyb3VwQ2hpbGRcIiwgbWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleCk7XG4gICAgLy9jb25zdCB7IGNoZWNrYm94OiB7IG9uQ2hlY2tlZENoYW5nZSB9LCBjaGVja2JveExpa2U6IHsgY2hlY2tlZCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24gfSwgbGFiZWw6IHsgdGFnSW5wdXQsIHRhZ0xhYmVsIH0sIGhhc0ZvY3VzSW5wdXQsIGhhc0ZvY3VzTGFiZWwgfSA9IGFzQ2hlY2tib3g7XG4gICAgLy9jb25zdCB7IHN1YkluZm8sIGNoZWNrYm94R3JvdXBDaGlsZDogeyBjaGVja2VkLCBmb2N1c1NlbGYsIG9uQ2hhbmdlRnJvbVBhcmVudCB9IH0gPSBhc0NoZWNrYm94R3JvdXBDaGlsZDtcblxuICAgIGNvbnN0IHsgY2hlY2tlZCwgb25DaGFuZ2VGcm9tUGFyZW50IH0gPSBjaGVja2JveEdyb3VwQ2hpbGQ7XG4gICAgY29uc3QgZ2V0Q2hlY2tlZCA9IHVzZVN0YWJsZUdldHRlcihjaGVja2VkKTtcbiAgICAvL2xhYmVsUG9zaXRpb24gPz89IFwic2VwYXJhdGVcIjtcbiAgICBjb25zdCBbZ2V0TGFzdFVzZXJDaGVja2VkLCBzZXRMYXN0VXNlckNoZWNrZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4gfCBcIm1peGVkXCIsIEV2ZW50PihudWxsLCByZXR1cm5GYWxzZSk7XG4gICAgY29uc3Qgb25DaGlsZENoZWNrZWRDaGFuZ2UgPSB1c2VTdGFibGVDYWxsYmFjaygoY2hlY2tlZDogQ2hlY2tib3hDaGVja2VkVHlwZSkgPT4ge1xuICAgICAgICBzZXRMYXN0VXNlckNoZWNrZWQoY2hlY2tlZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvbkNvbnRyb2xJZENoYW5nZWQgPSB1c2VDYWxsYmFjaygobmV4dDogc3RyaW5nIHwgdW5kZWZpbmVkLCBwcmV2OiBzdHJpbmcgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKHByZXYpXG4gICAgICAgICAgICBhbGxJZHMuZGVsZXRlKHByZXYpO1xuXG4gICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgYWxsSWRzLmFkZChuZXh0KTtcblxuICAgICAgICBpZiAoISFuZXh0IHx8ICEhcHJldikge1xuICAgICAgICAgICAgc2V0VXBkYXRlSW5kZXgoaSA9PiAoKGkgPz8gMCkgKyAxKSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRUb3RhbENoaWxkcmVuKGMgPT4gKChjID8/IDApICsgMSkpO1xuICAgICAgICByZXR1cm4gKCkgPT4gc2V0VG90YWxDaGlsZHJlbihjID0+ICgoYyA/PyAwKSAtIDEpKTtcbiAgICB9LCBbXSlcblxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgIHNldFRvdGFsQ2hlY2tlZChjID0+ICgoYyA/PyAwKSArIDEpKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBzZXRUb3RhbENoZWNrZWQoYyA9PiAoKGMgPz8gMCkgLSAxKSk7XG4gICAgICAgIH1cbiAgICB9LCBbY2hlY2tlZF0pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgcHJlc3NSZXR1cm4sXG4gICAgICAgIHByb3BzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblxuICAgIH0gPSB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8VENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+LCBuZXZlcj4oe1xuICAgICAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IGNoZWNrYm94SW5mbzogeyBjaGVja2JveENoaWxkVHlwZTogXCJjaGlsZFwiLCBnZXRMYXN0VXNlckNoZWNrZWQsIGdldENoZWNrZWQsIHNldENoZWNrZWRGcm9tUGFyZW50SW5wdXQ6IG9uQ2hhbmdlRnJvbVBhcmVudCB9LCAuLi5jb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzIH0sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgLi4ubWFuYWdlZENoaWxkUGFyYW1ldGVycyB9LFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnMsXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IHsgYXJpYVByb3BOYW1lOiBudWxsLCBzZWxlY3Rpb25Nb2RlOiBcImRpc2FibGVkXCIsIGRpc2FibGVkOiB0cnVlIH0sXG4gICAgICAgIC8vc3ViSW5mbzogeyB0eXBlOiBcImNoaWxkXCIsIGdldExhc3RVc2VyQ2hlY2tlZCwgc2V0Q2hlY2tlZEZyb21QYXJlbnRJbnB1dDogb25DaGFuZ2VGcm9tUGFyZW50LCBnZXRDaGVja2VkLCBzdWJJbmZvIH0sXG4gICAgICAgIC8qbGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IGFzQ2hlY2tib3hHcm91cENoaWxkLmxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBhc0NoZWNrYm94R3JvdXBDaGlsZC5tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuOiBhc0NoZWNrYm94R3JvdXBDaGlsZC5yZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczogeyAuLi5hc0NoZWNrYm94R3JvdXBDaGlsZC5yb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycywgZm9jdXNTZWxmIH0qL1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hlY2tib3hHcm91cENoaWxkOiB7XG4gICAgICAgICAgICBvbkNoaWxkQ2hlY2tlZENoYW5nZSxcbiAgICAgICAgICAgIG9uQ29udHJvbElkQ2hhbmdlZFxuICAgICAgICB9LFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgcHJlc3NSZXR1cm4sXG4gICAgICAgIHByb3BzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblxuXG4gICAgfVxuXG5cblxufVxuXG4iLCJcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgZmluZEZpcnN0Rm9jdXNhYmxlLCB1c2VNZXJnZWRQcm9wcywgdXNlTW9kYWwsIFVzZU1vZGFsUGFyYW1ldGVycywgVXNlTW9kYWxSZXR1cm5UeXBlLCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IFByZWZpY2VzIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlTGFiZWxTeW50aGV0aWMsIFVzZUxhYmVsU3ludGhldGljUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xyXG5cclxuLypcclxuZXhwb3J0IGludGVyZmFjZSBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbyBleHRlbmRzIFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZUluZm8ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlRGlhbG9nVGl0bGU8VGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZURpYWxvZ1RpdGxlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50PjsgfTtcclxuZXhwb3J0IHR5cGUgVXNlRGlhbG9nQm9keTxCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VEaWFsb2dCb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD47IH07XHJcbmV4cG9ydCB0eXBlIFVzZURpYWxvZ0JhY2tkcm9wPEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VEaWFsb2dCYWNrZHJvcFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD47IH07XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VEaWFsb2dSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBEaWFsb2dFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBVc2VNb2RhbFJldHVyblR5cGUge1xyXG4gICAgdXNlRGlhbG9nUHJvcHM6IFVzZU1vZGFsUmV0dXJuVHlwZVdpdGhIb29rczxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudD5bXCJ1c2VNb2RhbFByb3BzXCJdO1xyXG4gICAgdXNlRGlhbG9nVGl0bGU6IFVzZURpYWxvZ1RpdGxlPFRpdGxlRWxlbWVudD47XHJcbiAgICB1c2VEaWFsb2dCb2R5OiBVc2VEaWFsb2dCb2R5PEJvZHlFbGVtZW50PjtcclxuICAgIHVzZURpYWxvZ0JhY2tkcm9wOiBVc2VEaWFsb2dCYWNrZHJvcDxCYWNrZHJvcEVsZW1lbnQ+O1xyXG4gICAgdXNlRGlhbG9nRm9jdXNDb250YWluZXJQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rm9jdXNDb250YWluZXJFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlRGlhbG9nUGFyYW1ldGVycyBleHRlbmRzIFVzZU1vZGFsUGFyYW1ldGVyczxcImJhY2tkcm9wXCIgfCBcImVzY2FwZVwiPiB7XHJcbiAgICAvL2RpYWxvZzogeyBvbkNsb3NlOiAocmVhc29uOiBcImVzY2FwZVwiIHwgXCJiYWNrZHJvcFwiKSA9PiB2b2lkOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7XHJcbiAgICBkaXNtaXNzUGFyYW1ldGVycyxcclxuICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzLFxyXG4gICAgZm9jdXNUcmFwUGFyYW1ldGVyc1xyXG59OiBVc2VEaWFsb2dQYXJhbWV0ZXJzKTogVXNlRGlhbG9nUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudD4ge1xyXG5cclxuICAgIGRlYnVnTG9nKFwidXNlRGlhbG9nXCIpO1xyXG5cclxuICAgIC8vIFRPRE86IERpZmZlcmVuY2VzIGJldHdlZW4gZGlhbG9nIGFuZCBtb2RhbCBnbyBoZXJlLCBwcmVzdW1hYmx5LlxyXG4gICAgLy8gTm9uLW1vZGFsIGRpYWxvZ3MgbmVlZCB0byBiZSBhYmxlIHRvIGJlIHJlcG9zaXRpb25lZCwgZXRjLlxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIGZvY3VzVHJhcFJldHVybixcclxuICAgICAgICBwcm9wc1BvcHVwLFxyXG4gICAgICAgIHByb3BzU291cmNlLFxyXG4gICAgICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybixcclxuICAgICAgICByZWZFbGVtZW50U291cmNlUmV0dXJuXHJcbiAgICB9ID0gdXNlTW9kYWw8XCJiYWNrZHJvcFwiIHwgXCJlc2NhcGVcIiwgRm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50Pih7XHJcbiAgICAgICAgZGlzbWlzc1BhcmFtZXRlcnMsXHJcbiAgICAgICAgZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnMsXHJcbiAgICAgICAgZm9jdXNUcmFwUGFyYW1ldGVyc1xyXG4gICAgfSk7XHJcbiAgICB0eXBlIFIgPSBVc2VEaWFsb2dSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50PjtcclxuICAgIGNvbnN0IHVzZURpYWxvZ0JhY2tkcm9wID0gdXNlQ2FsbGJhY2s8UltcInVzZURpYWxvZ0JhY2tkcm9wXCJdPigoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VNb2RhbEJhY2tkcm9wUHJvcHMgfSA9IHVzZU1vZGFsQmFja2Ryb3AoKTtcclxuICAgICAgICByZXR1cm4geyB1c2VEaWFsb2dCYWNrZHJvcFByb3BzOiB1c2VNb2RhbEJhY2tkcm9wUHJvcHMgfTtcclxuICAgIH0sIFt1c2VNb2RhbEJhY2tkcm9wXSk7XHJcblxyXG4gICAgY29uc3QgdXNlRGlhbG9nQm9keSA9IHVzZUNhbGxiYWNrPFJbXCJ1c2VEaWFsb2dCb2R5XCJdPigoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VNb2RhbEJvZHlQcm9wcyB9ID0gdXNlTW9kYWxCb2R5KCk7XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlRGlhbG9nQm9keVByb3BzOiB1c2VNb2RhbEJvZHlQcm9wcyB9O1xyXG4gICAgfSwgW3VzZU1vZGFsQmFja2Ryb3BdKTtcclxuICAgIGNvbnN0IHVzZURpYWxvZ1Byb3BzID0gdXNlTW9kYWxQcm9wcztcclxuXHJcbiAgICBjb25zdCB1c2VEaWFsb2dUaXRsZSA9IHVzZUNhbGxiYWNrPFJbXCJ1c2VEaWFsb2dUaXRsZVwiXT4oKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxUaXRsZVByb3BzIH0gPSB1c2VNb2RhbFRpdGxlKCk7XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlRGlhbG9nVGl0bGVQcm9wczogdXNlTW9kYWxUaXRsZVByb3BzIH07XHJcbiAgICB9LCBbdXNlTW9kYWxUaXRsZV0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlRGlhbG9nUHJvcHMsXHJcbiAgICAgICAgdXNlRGlhbG9nVGl0bGUsXHJcbiAgICAgICAgdXNlRGlhbG9nQm9keSxcclxuICAgICAgICB1c2VEaWFsb2dCYWNrZHJvcCxcclxuICAgICAgICB1c2VEaWFsb2dGb2N1c0NvbnRhaW5lclByb3BzOiB1c2VNb2RhbEZvY3VzQ29udGFpbmVyUHJvcHMsXHJcbiAgICAgICAgc29mdERpc21pc3M6IHsgb25CYWNrZHJvcENsaWNrIH0sXHJcbiAgICB9XHJcbn0qL1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VEaWFsb2dQYXJhbWV0ZXJzPF9EaWFsb2dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgX1RpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VNb2RhbFBhcmFtZXRlcnM8XCJlc2NhcGVcIiB8IFwiYmFja2Ryb3BcIj4sIFwiZm9jdXNUcmFwUGFyYW1ldGVyc1wiIHwgXCJkaXNtaXNzUGFyYW1ldGVyc1wiPiB7XHJcbiAgICBmb2N1c1RyYXBQYXJhbWV0ZXJzOiBPbWl0PFVzZU1vZGFsUGFyYW1ldGVyczxcImVzY2FwZVwiIHwgXCJiYWNrZHJvcFwiPltcImZvY3VzVHJhcFBhcmFtZXRlcnNcIl0sIFwidHJhcEFjdGl2ZVwiIHwgXCJvbmx5TW92ZUZvY3VzXCI+O1xyXG4gICAgZGlzbWlzc1BhcmFtZXRlcnM6IE9taXQ8VXNlTW9kYWxQYXJhbWV0ZXJzPFwiZXNjYXBlXCIgfCBcImJhY2tkcm9wXCI+W1wiZGlzbWlzc1BhcmFtZXRlcnNcIl0sIFwiY2xvc2VPbkxvc3RGb2N1c1wiPjtcclxuICAgIGxhYmVsUGFyYW1ldGVyczogT21pdDxVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnNbXCJsYWJlbFBhcmFtZXRlcnNcIl0sIFwib25MYWJlbENsaWNrXCI+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZURpYWxvZ1JldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgU291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VNb2RhbFJldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBQb3B1cEVsZW1lbnQ+LCBcInByb3BzUG9wdXBcIj4ge1xyXG4gICAgcHJvcHNEaWFsb2c6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwRWxlbWVudD47XHJcbiAgICBwcm9wc1RpdGxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRGlhbG9nPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNvdXJjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBEaWFsb2dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBkaXNtaXNzUGFyYW1ldGVycywgZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnMsIGZvY3VzVHJhcFBhcmFtZXRlcnMsIGxhYmVsUGFyYW1ldGVycyB9OiBVc2VEaWFsb2dQYXJhbWV0ZXJzPERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudD4pOiBVc2VEaWFsb2dSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgU291cmNlRWxlbWVudCwgRGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgZm9jdXNUcmFwUmV0dXJuLFxyXG4gICAgICAgIHByb3BzRm9jdXNDb250YWluZXIsXHJcbiAgICAgICAgcHJvcHNQb3B1cCxcclxuICAgICAgICBwcm9wc1NvdXJjZSxcclxuICAgICAgICByZWZFbGVtZW50UG9wdXBSZXR1cm4sXHJcbiAgICAgICAgcmVmRWxlbWVudFNvdXJjZVJldHVyblxyXG4gICAgfSA9IHVzZU1vZGFsPFwiZXNjYXBlXCIgfCBcImJhY2tkcm9wXCIsIEZvY3VzQ29udGFpbmVyRWxlbWVudCwgU291cmNlRWxlbWVudCwgRGlhbG9nRWxlbWVudD4oe1xyXG4gICAgICAgIGRpc21pc3NQYXJhbWV0ZXJzOiB7IGNsb3NlT25Mb3N0Rm9jdXM6IGZhbHNlLCAuLi5kaXNtaXNzUGFyYW1ldGVycyB9LFxyXG4gICAgICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzLFxyXG4gICAgICAgIGZvY3VzVHJhcFBhcmFtZXRlcnM6IHsgdHJhcEFjdGl2ZTogdHJ1ZSwgb25seU1vdmVGb2N1czogZmFsc2UsIC4uLmZvY3VzVHJhcFBhcmFtZXRlcnMgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHByb3BzSW5wdXQsXHJcbiAgICAgICAgcHJvcHNMYWJlbFxyXG4gICAgfSA9IHVzZUxhYmVsU3ludGhldGljPERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudD4oe1xyXG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICAuLi5sYWJlbFBhcmFtZXRlcnMsIG9uTGFiZWxDbGljazogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHJlZkVsZW1lbnRQb3B1cFJldHVybi5nZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICBmb2N1c1RyYXBQYXJhbWV0ZXJzLmZvY3VzUG9wdXAoZSwgKCkgPT4gZmluZEZpcnN0Rm9jdXNhYmxlKGUhKSk7XHJcblxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5kaWFsb2cgfSxcclxuICAgICAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLmRpYWxvZ1RpdGxlIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZm9jdXNUcmFwUmV0dXJuLFxyXG4gICAgICAgIHByb3BzRm9jdXNDb250YWluZXIsXHJcbiAgICAgICAgcHJvcHNEaWFsb2c6IHVzZU1lcmdlZFByb3BzPERpYWxvZ0VsZW1lbnQ+KHByb3BzUG9wdXAsIHByb3BzSW5wdXQpLFxyXG4gICAgICAgIHByb3BzU291cmNlLFxyXG4gICAgICAgIHByb3BzVGl0bGU6IHByb3BzTGFiZWwsXHJcbiAgICAgICAgcmVmRWxlbWVudFBvcHVwUmV0dXJuLFxyXG4gICAgICAgIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm5cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgZmluZEZpcnN0Rm9jdXNhYmxlLCB1c2VNZXJnZWRQcm9wcywgdXNlTW9kYWwsIFVzZU1vZGFsUGFyYW1ldGVycywgVXNlTW9kYWxSZXR1cm5UeXBlLCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBQcmVmaWNlcyB9IGZyb20gXCIuL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VMYWJlbFN5bnRoZXRpYywgVXNlTGFiZWxTeW50aGV0aWNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XG4vKmltcG9ydCB7IHVzZU1vZGFsLCBVc2VNb2RhbFBhcmFtZXRlcnMsIFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtbW9kYWxcIjtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyYXdlclJldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VEcmF3ZXJSZXR1cm5UeXBlV2l0aEhvb2tzPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1vZGFsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VEcmF3ZXJSZXR1cm5UeXBlSW5mbyB7XG4gICAgdXNlRHJhd2VyUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TW9kYWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TW9kYWxFbGVtZW50PjtcbiAgICB1c2VEcmF3ZXJUaXRsZTogVXNlRHJhd2VyVGl0bGU8VGl0bGVFbGVtZW50PjtcbiAgICB1c2VEcmF3ZXJCb2R5OiBVc2VEcmF3ZXJCb2R5PEJvZHlFbGVtZW50PlxuICAgIHVzZURyYXdlckJhY2tkcm9wOiBVc2VEcmF3ZXJCYWNrZHJvcDxCYWNrZHJvcEVsZW1lbnQ+O1xuICAgIHVzZURyYXdlckZvY3VzQ29udGFpbmVyUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VEcmF3ZXJUaXRsZTxUaXRsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlRHJhd2VyVGl0bGVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+OyB9O1xuZXhwb3J0IHR5cGUgVXNlRHJhd2VyQm9keTxCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VEcmF3ZXJCb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD47IH07XG5leHBvcnQgdHlwZSBVc2VEcmF3ZXJCYWNrZHJvcDxCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlRHJhd2VyQmFja2Ryb3BQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+OyB9O1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRHJhd2VyUGFyYW1ldGVycyBleHRlbmRzIFVzZU1vZGFsUGFyYW1ldGVyczxuZXZlciwgbmV2ZXI+IHtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURyYXdlcjxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgRHJhd2VyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgc29mdERpc21pc3M6IHsgb3Blbiwgb25DbG9zZSB9LCBhY3RpdmVFbGVtZW50LCBtb2RhbDogeyBib2R5SXNPbmx5U2VtYW50aWMsIGZvY3VzU2VsZiB9IH06IFVzZURyYXdlclBhcmFtZXRlcnMpOiBVc2VEcmF3ZXJSZXR1cm5UeXBlV2l0aEhvb2tzPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50PiB7XG5cbiAgICBkZWJ1Z0xvZyhcInVzZURyYXdlclwiKTtcblxuICAgIC8vIFRPRE86IERyYXdlcnMgYXJlIG5vdCBhbHdheXMgbW9kYWwuXG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZU1vZGFsQmFja2Ryb3AsXG4gICAgICAgIHVzZU1vZGFsQm9keSxcbiAgICAgICAgdXNlTW9kYWxQcm9wcyxcbiAgICAgICAgdXNlTW9kYWxUaXRsZSxcbiAgICAgICAgdXNlTW9kYWxGb2N1c0NvbnRhaW5lclByb3BzLFxuICAgICAgICBzb2Z0RGlzbWlzczogeyBvbkJhY2tkcm9wQ2xpY2sgfVxuICAgIH0gPSB1c2VNb2RhbDxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERyYXdlckVsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudD4oeyBtb2RhbDogeyBib2R5SXNPbmx5U2VtYW50aWM6IChib2R5SXNPbmx5U2VtYW50aWMgPz8gZmFsc2UpLCBmb2N1c1NlbGYgfSwgc29mdERpc21pc3M6IHsgb25DbG9zZSwgb3BlbiB9LCBhY3RpdmVFbGVtZW50IH0pO1xuXG4gICAgY29uc3QgdXNlRHJhd2VyQmFja2Ryb3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxCYWNrZHJvcFByb3BzIH0gPSB1c2VNb2RhbEJhY2tkcm9wKCk7XG4gICAgICAgIHJldHVybiB7IHVzZURyYXdlckJhY2tkcm9wUHJvcHM6IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9O1xuICAgIH0sIFt1c2VNb2RhbEJhY2tkcm9wXSk7XG5cbiAgICBjb25zdCB1c2VEcmF3ZXJCb2R5ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHVzZU1vZGFsQm9keVByb3BzIH0gPSB1c2VNb2RhbEJvZHkoKTtcbiAgICAgICAgcmV0dXJuIHsgdXNlRHJhd2VyQm9keVByb3BzOiB1c2VNb2RhbEJvZHlQcm9wcyB9O1xuICAgIH0sIFt1c2VNb2RhbEJhY2tkcm9wXSk7XG4gICAgY29uc3QgdXNlRHJhd2VyUHJvcHMgPSB1c2VNb2RhbFByb3BzO1xuXG4gICAgY29uc3QgdXNlRHJhd2VyVGl0bGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxUaXRsZVByb3BzIH0gPSB1c2VNb2RhbFRpdGxlKCk7XG4gICAgICAgIHJldHVybiB7IHVzZURyYXdlclRpdGxlUHJvcHM6IHVzZU1vZGFsVGl0bGVQcm9wcyB9O1xuICAgIH0sIFt1c2VNb2RhbFRpdGxlXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VEcmF3ZXJQcm9wcyxcbiAgICAgICAgdXNlRHJhd2VyVGl0bGUsXG4gICAgICAgIHVzZURyYXdlckJvZHksXG4gICAgICAgIHVzZURyYXdlckJhY2tkcm9wLFxuICAgICAgICB1c2VEcmF3ZXJGb2N1c0NvbnRhaW5lclByb3BzOiB1c2VNb2RhbEZvY3VzQ29udGFpbmVyUHJvcHMsXG4gICAgICAgIHNvZnREaXNtaXNzOiB7IG9uQmFja2Ryb3BDbGljayB9XG4gICAgfVxufSovXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyYXdlclBhcmFtZXRlcnM8X0RpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZU1vZGFsUGFyYW1ldGVyczxcImVzY2FwZVwiIHwgXCJiYWNrZHJvcFwiIHwgXCJsb3N0LWZvY3VzXCI+LCBcImZvY3VzVHJhcFBhcmFtZXRlcnNcIj4ge1xuICAgIGxhYmVsUGFyYW1ldGVyczogT21pdDxVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnNbXCJsYWJlbFBhcmFtZXRlcnNcIl0sIFwib25MYWJlbENsaWNrXCI+O1xuICAgIGZvY3VzVHJhcFBhcmFtZXRlcnM6IE9taXQ8VXNlTW9kYWxQYXJhbWV0ZXJzPFwiZXNjYXBlXCIgfCBcImJhY2tkcm9wXCIgfCBcImxvc3QtZm9jdXNcIj5bXCJmb2N1c1RyYXBQYXJhbWV0ZXJzXCJdLCBcIm9ubHlNb3ZlRm9jdXNcIj5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VEcmF3ZXJSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNvdXJjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBEcmF3ZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZU1vZGFsUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIERyYXdlckVsZW1lbnQ+LCBcInByb3BzUG9wdXBcIj4ge1xuICAgIHByb3BzRHJhd2VyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxEcmF3ZXJFbGVtZW50PjtcbiAgICBwcm9wc1RpdGxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRHJhd2VyPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNvdXJjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQb3B1cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGRpc21pc3NQYXJhbWV0ZXJzLCBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycywgZm9jdXNUcmFwUGFyYW1ldGVycywgbGFiZWxQYXJhbWV0ZXJzIH06IFVzZURyYXdlclBhcmFtZXRlcnM8UG9wdXBFbGVtZW50LCBUaXRsZUVsZW1lbnQ+KTogVXNlRHJhd2VyUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIFBvcHVwRWxlbWVudCwgVGl0bGVFbGVtZW50PiB7XG4gICAgY29uc3Qge1xuICAgICAgICBmb2N1c1RyYXBSZXR1cm4sXG4gICAgICAgIHByb3BzRm9jdXNDb250YWluZXIsXG4gICAgICAgIHByb3BzUG9wdXAsXG4gICAgICAgIHByb3BzU291cmNlLFxuICAgICAgICByZWZFbGVtZW50UG9wdXBSZXR1cm4sXG4gICAgICAgIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm5cbiAgICB9ID0gdXNlTW9kYWw8XCJlc2NhcGVcIiB8IFwiYmFja2Ryb3BcIiB8IFwibG9zdC1mb2N1c1wiLCBGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIFBvcHVwRWxlbWVudD4oe1xuICAgICAgICBkaXNtaXNzUGFyYW1ldGVycyxcbiAgICAgICAgZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnMsXG4gICAgICAgIGZvY3VzVHJhcFBhcmFtZXRlcnM6IHsgb25seU1vdmVGb2N1czogZmFsc2UsICAuLi5mb2N1c1RyYXBQYXJhbWV0ZXJzIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgcHJvcHNJbnB1dCxcbiAgICAgICAgcHJvcHNMYWJlbCxcbiAgICB9ID0gdXNlTGFiZWxTeW50aGV0aWM8UG9wdXBFbGVtZW50LCBUaXRsZUVsZW1lbnQ+KHtcbiAgICAgICAgbGFiZWxQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAuLi5sYWJlbFBhcmFtZXRlcnMsIG9uTGFiZWxDbGljazogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGUgPSByZWZFbGVtZW50UG9wdXBSZXR1cm4uZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGZvY3VzVHJhcFBhcmFtZXRlcnMuZm9jdXNQb3B1cChlLCAoKSA9PiBmaW5kRmlyc3RGb2N1c2FibGUoZSEpKTtcblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5kcmF3ZXIgfSxcbiAgICAgICAgcmFuZG9tSWRMYWJlbFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5kcmF3ZXJUaXRsZSB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBmb2N1c1RyYXBSZXR1cm4sXG4gICAgICAgIHByb3BzRm9jdXNDb250YWluZXIsXG4gICAgICAgIHByb3BzRHJhd2VyOiB1c2VNZXJnZWRQcm9wczxQb3B1cEVsZW1lbnQ+KHByb3BzUG9wdXAsIHByb3BzSW5wdXQpLFxuICAgICAgICBwcm9wc1RpdGxlOiBwcm9wc0xhYmVsLFxuICAgICAgICBwcm9wc1NvdXJjZSxcbiAgICAgICAgcmVmRWxlbWVudFBvcHVwUmV0dXJuLFxuICAgICAgICByZWZFbGVtZW50U291cmNlUmV0dXJuXG4gICAgfVxufVxuXG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQge1xuICAgIENvbXBsZXRlR3JpZE5hdmlnYXRpb25Db250ZXh0LFxuICAgIENvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0LFxuICAgIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm8sXG4gICAgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRSb3dJbmZvLFxuICAgIHVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb24sXG4gICAgdXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGwsXG4gICAgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzLFxuICAgIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZSxcbiAgICBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZSxcbiAgICB1c2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93LFxuICAgIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzLFxuICAgIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlLFxuICAgIHVzZU1lcmdlZFByb3BzLFxuICAgIHVzZVNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlLFxuICAgIHVzZVN0YWJsZUNhbGxiYWNrLFxuICAgIHVzZVN0YWJsZU9iamVjdFxufSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgUHJlZmljZXMgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlTGFiZWxTeW50aGV0aWMsIFVzZUxhYmVsU3ludGhldGljUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xuaW1wb3J0IHsgVXNlTGlzdGJveFBhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtbGlzdGJveFwiO1xuXG4vL3R5cGUgTGlzdGJveFNpbmdsZVNlbGVjdEV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSB7IFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogbnVtYmVyIH0gfSAmIFBpY2s8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPiwgXCJ0YXJnZXRcIiB8IFwiY3VycmVudFRhcmdldFwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdENvbnRleHQ8R3JpZGxpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgR3JpZGxpc3RSb3dJbmZvPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZGxpc3RDZWxsSW5mbzxHcmlkbGlzdENlbGxFbGVtZW50Pj4gZXh0ZW5kcyBDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ29udGV4dDxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPiB7XG4gICAgZ3JpZGxpc3RSb3dDb250ZXh0OiB7IHNlbGVjdGlvbkxpbWl0OiBcInNpbmdsZVwiIHwgXCJtdWx0aVwiIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdFJvd0NvbnRleHQ8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPENoaWxkRWxlbWVudD4+IGV4dGVuZHMgQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd0NvbnRleHQ8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdFBhcmFtZXRlcnM8R3JpZGxpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgR3JpZGxpc3RSb3dJbmZvPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudD4+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0+LCBcInNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNcIj4ge1xuICAgIGxhYmVsUGFyYW1ldGVyczogT21pdDxVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnNbXCJsYWJlbFBhcmFtZXRlcnNcIl0sIFwib25MYWJlbENsaWNrXCI+O1xuICAgIGdyaWRsaXN0UGFyYW1ldGVyczogVXNlTGlzdGJveFBhcmFtZXRlcnM8R3JpZGxpc3RFbGVtZW50LCBHcmlkbGlzdFJvd0VsZW1lbnQsIExhYmVsRWxlbWVudCwgUk0+W1wibGlzdGJveFBhcmFtZXRlcnNcIl07XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0UmV0dXJuVHlwZTxHcmlkbGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcmlkbGlzdFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkbGlzdFJvd0luZm88R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPEdyaWRsaXN0Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIE9taXQ8VXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJldHVyblR5cGU8R3JpZGxpc3RFbGVtZW50LCBHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwicHJvcHNcIj4ge1xuICAgIHByb3BzR3JpZGxpc3Q6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyaWRsaXN0RWxlbWVudD47XG4gICAgcHJvcHNHcmlkbGlzdExhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xuICAgIGNvbnRleHQ6IFVzZUdyaWRsaXN0Q29udGV4dDxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RSb3dSZXR1cm5UeXBlPEdyaWRsaXN0Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRsaXN0Um93SW5mbzxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88R3JpZGxpc3RDZWxsRWxlbWVudD4+IGV4dGVuZHMgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGU8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgR3JpZGxpc3RSb3dJbmZvPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZGxpc3RDZWxsSW5mbzxHcmlkbGlzdENlbGxFbGVtZW50Pj4gey8vIGV4dGVuZHMgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+IHtcblxuICAgIHJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzOiBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT5bXCJyb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyc1wiXSAmIHtcbiAgICAgICAgY29udGV4dDogVXNlR3JpZGxpc3RDb250ZXh0PGFueSwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+O1xuICAgICAgICBncmlkbGlzdFJvd1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgYHNlbGVjdGlvbkxpbWl0YCBpcyBgXCJzaW5nbGVcImAsIHRoaXMgbXVzdCBiZSBgbnVsbGAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlbGVjdGVkOiBib29sZWFuIHwgbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByb3dBc1BhcmVudE9mQ2VsbHNQYXJhbWV0ZXJzOiBPbWl0PFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPltcInJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnNcIl0sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4gJiB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPltcInJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnNcIl1bXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiB8IFwiaXNWYWxpZFwiPlxuICAgICAgICAvL3R5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPltcInJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnNcIl1bXCJ0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJpc1ZhbGlkXCI+XG4gICAgICAgIC8vcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiBPbWl0PFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPltcInJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnNcIl1bXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIl0sIFwiaW5pdGlhbGx5VGFiYmVkSW5kZXhcIj47XG4gICAgfVxuICAgIC8vY29udGV4dDogIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPltcIlwiXVxuICAgIC8vY29udGV4dDogVXNlR3JpZGxpc3RDb250ZXh0PGFueSwgR3JpZGxpc3RSb3dFbGVtZW50LCBSTT47XG4gICAgLy9ncmlkbGlzdFJvd0NvbnRleHQ6IFVzZUdyaWRsaXN0Q29udGV4dDxhbnksIEdyaWRsaXN0Um93RWxlbWVudCwgUk0+W1wiZ3JpZGxpc3RSb3dDb250ZXh0XCJdO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RDZWxsUmV0dXJuVHlwZTxHcmlkbGlzdENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ00gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPEdyaWRsaXN0Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZTxHcmlkbGlzdENlbGxFbGVtZW50LCBDTT4geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnM8R3JpZGxpc3RDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENNIGV4dGVuZHMgR3JpZGxpc3RDZWxsSW5mbzxHcmlkbGlzdENlbGxFbGVtZW50Pj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8R3JpZGxpc3RDZWxsRWxlbWVudCwgQ00+IHsgfVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyaWRsaXN0Um93SW5mbzxHcmlkbGlzdFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50PiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgR3JpZGxpc3RDZWxsSW5mbzxHcmlkbGlzdENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZENlbGxJbmZvPEdyaWRsaXN0Q2VsbEVsZW1lbnQ+IHsgfVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlR3JpZGxpc3Q8R3JpZGxpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgR3JpZGxpc3RSb3dJbmZvPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZGxpc3RDZWxsSW5mbzxHcmlkbGlzdENlbGxFbGVtZW50Pj4oe1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICBsYWJlbFBhcmFtZXRlcnMsXG4gICAgZ3JpZGxpc3RQYXJhbWV0ZXJzOiB7IHNlbGVjdGlvbkxpbWl0LCBncm91cGluZ1R5cGUsIHNlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXggfSxcbiAgICBncmlkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1xufTogVXNlR3JpZGxpc3RQYXJhbWV0ZXJzPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJNPik6IFVzZUdyaWRsaXN0UmV0dXJuVHlwZTxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTSwgQ00+IHtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgcHJvcHNJbnB1dDogcHJvcHNMYWJlbExpc3QsXG4gICAgICAgIHByb3BzTGFiZWw6IHByb3BzTGFiZWxMYWJlbCxcbiAgICAgICAgcmFuZG9tSWRJbnB1dFJldHVybjogeyBpZDogX2dyaWRsaXN0SWQgfSxcbiAgICAgICAgcmFuZG9tSWRMYWJlbFJldHVybjogeyBpZDogX2xhYmVsSWQgfVxuICAgIH0gPSB1c2VMYWJlbFN5bnRoZXRpYzxHcmlkbGlzdEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIC4uLmxhYmVsUGFyYW1ldGVycyxcbiAgICAgICAgICAgIG9uTGFiZWxDbGljazogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLmZvY3VzU2VsZigpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5ncmlkbGlzdCB9LFxuICAgICAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLmdyaWRsaXN0TGFiZWwgfVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVyblxuICAgIH0gPSB1c2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogeyBpbml0aWFsbHlTZWxlY3RlZEluZGV4OiBzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4IH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXG4gICAgfSk7XG5cbiAgICBjb25zdCBfdjogdm9pZCA9IHVzZVNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlKHsgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLCBzaW5nbGVTZWxlY3Rpb25EZWNsYXJhdGl2ZVBhcmFtZXRlcnM6IHsgc2VsZWN0ZWRJbmRleCB9IH0pO1xuXG4gICAgbGV0IHByb3BzR3JpZGxpc3QgPSB1c2VNZXJnZWRQcm9wcyhwcm9wcywgcHJvcHNMYWJlbExpc3QsIHsgXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiOiAoc2VsZWN0aW9uTGltaXQgPT0gXCJtdWx0aVwiID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQpIH0pO1xuXG5cbiAgICBsZXQgZnVsbENvbnRleHQgPSB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICBncmlkbGlzdFJvd0NvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICBzZWxlY3Rpb25MaW1pdFxuICAgICAgICB9KVxuICAgIH0pO1xuICAgIGlmIChncm91cGluZ1R5cGUgPT0gXCJncm91cFwiKVxuICAgICAgICBwcm9wc0dyaWRsaXN0LnJvbGUgPSBcImdyb3VwXCI7XG4gICAgZWxzZSBpZiAoZ3JvdXBpbmdUeXBlID09IFwid2l0aC1ncm91cHNcIikge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGNsb2JiZXJpbmcgYWxsIHRoZSBsaXN0IG5hdmlnYXRpb24gc3R1ZmYuXG4gICAgICAgIHByb3BzR3JpZGxpc3QgPSB7IHJvbGU6IFwiZ3JpZFwiIH07XG4gICAgICAgIC8vIC4uLmFjdHVhbGx5LCBjb250ZXh0IHRvbyB3aGlsZSB3ZSdyZSBhdCBpdC5cbiAgICAgICAgZnVsbENvbnRleHQgPSBudWxsIVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvcHNHcmlkbGlzdC5yb2xlID0gXCJncmlkXCI7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGlvbkxpbWl0ID09IFwibXVsdGlcIilcbiAgICAgICAgY29uc29sZS5hc3NlcnQoc2luZ2xlU2VsZWN0aW9uUmV0dXJuLmdldFNlbGVjdGVkSW5kZXgoKSA9PSBudWxsKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQ6IGZ1bGxDb250ZXh0LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgcHJvcHNHcmlkbGlzdCxcbiAgICAgICAgcHJvcHNHcmlkbGlzdExhYmVsOiBwcm9wc0xhYmVsTGFiZWxcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkbGlzdFJvdzxHcmlkbGlzdFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkbGlzdFJvd0luZm88R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPEdyaWRsaXN0Q2VsbEVsZW1lbnQ+Pih7XG4gICAgcm93QXNDaGlsZE9mR3JpZFBhcmFtZXRlcnM6IHtcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBjb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycyxcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIGNvbnRleHQ6IGN4MSxcbiAgICAgICAgZ3JpZGxpc3RSb3dQYXJhbWV0ZXJzOiB7IHNlbGVjdGVkIH1cbiAgICB9LFxuICAgIHJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcbiAgICB9XG59OiBVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+KTogVXNlR3JpZGxpc3RSb3dSZXR1cm5UeXBlPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPiB7XG4gICAgY29uc3QgeyBncmlkbGlzdFJvd0NvbnRleHQ6IHsgc2VsZWN0aW9uTGltaXQgfSB9ID0gY3gxO1xuICAgIGNvbnN0IHtcbiAgICAgICAgcm93QXNDaGlsZE9mR3JpZFJldHVybixcbiAgICAgICAgcm93QXNQYXJlbnRPZkNlbGxzUmV0dXJuLFxuICAgICAgICBjb250ZXh0OiBjeDIsXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybixcbiAgICAgICAgcHJvcHNcbiAgICB9ID0gdXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvdzxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4oe1xuICAgICAgICByb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvbnRleHQ6IGN4MVxuICAgICAgICB9LFxuICAgICAgICByb3dBc1BhcmVudE9mQ2VsbHNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogeyAuLi5saW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgLi4udHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoc2VsZWN0aW9uTGltaXQgPT0gXCJzaW5nbGVcIilcbiAgICAgICAgY29uc29sZS5hc3NlcnQoc2VsZWN0ZWQgPT0gbnVsbCk7XG5cbiAgICBwcm9wcy5yb2xlID0gXCJvcHRpb25cIjtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHJvd0FzQ2hpbGRPZkdyaWRSZXR1cm4sXG4gICAgICAgIHJvd0FzUGFyZW50T2ZDZWxsc1JldHVybixcbiAgICAgICAgY29udGV4dDogY3gyLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIHByb3BzXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlR3JpZGxpc3RDZWxsPEdyaWRsaXN0Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88R3JpZGxpc3RDZWxsRWxlbWVudD4+KHA6IFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnM8R3JpZGxpc3RDZWxsRWxlbWVudCwgQ00+KTogVXNlR3JpZGxpc3RDZWxsUmV0dXJuVHlwZTxHcmlkbGlzdENlbGxFbGVtZW50LCBDTT4ge1xuICAgIHJldHVybiB1c2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbDxHcmlkbGlzdENlbGxFbGVtZW50LCBDTT4ocCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RTZWN0aW9uUGFyYW1ldGVycyB7XG4gICAgZ3JpZGxpc3RTZWN0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICBjb21wYXJlUm93czogKGxoc0luZGV4OiBudW1iZXIsIHJoc0luZGV4OiBudW1iZXIpID0+IG51bWJlcjtcbiAgICB9XG4gICAgZ3JpZGxpc3RTZWN0aW9uQ29udGV4dDoge1xuXG4gICAgfVxufVxuLypcbmV4cG9ydCBjb25zdCB1c2VHcmlkbGlzdFNlY3Rpb24gPSA8Qm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgY29tcGFyZVJvd3MgfTogVXNlR3JpZGxpc3RTZWN0aW9uUGFyYW1ldGVycykgPT4ge1xuICAgIC8vZGVidWdMb2coXCJ1c2VHcmlkbGlzdFNlY3Rpb25cIik7XG4gICAgLy90eXBlIENSRnVsbCA9IFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxSb3dFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlR3JpZGxpc3RSb3dTdWJJbmZvPENlbGxFbGVtZW50LCBDUiwgQ0M+Pj47XG4gICAgY29uc3QgZ2V0SW5kZXggPSB1c2VDYWxsYmFjazxHZXRJbmRleDxhbnk+PigoaSkgPT4gaS5wcm9wcy5pbmRleCwgW10pO1xuXG5cbiAgICBjb25zdCB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5cbiAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxCb2R5U2VjdGlvbkVsZW1lbnQsIEdyaWRsaXN0Um93SW5mbzxSb3dFbGVtZW50Pj4oe1xuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBnZXRJbmRleCxcbiAgICAgICAgICAgIGdldEhpZ2hlc3RDaGlsZEluZGV4LFxuICAgICAgICAgICAgZ2V0VmFsaWRcbiAgICAgICAgfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGNvbXBhcmU6IChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsaHMubG9jYXRpb25JbmRleCA9PT0gcmhzLmxvY2F0aW9uSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlUm93cyhsaHMuaW5kZXgsIHJocy5pbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocy5sb2NhdGlvbkluZGV4IC0gcmhzLmxvY2F0aW9uSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZUdyaWRsaXN0U2VjdGlvblByb3BzID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHByb3BzLmNoaWxkcmVuICE9IG51bGwpO1xuICAgICAgICBvdmVyd3JpdGVXaXRoV2FybmluZyhcInVzZUdyaWRsaXN0U2VjdGlvblwiLCBwcm9wcywgXCJyb2xlXCIsIFwicm93Z3JvdXBcIik7XG4gICAgICAgIHJldHVybiB1c2VTb3J0YWJsZVByb3BzKHByb3BzIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4gJiB7IGNoaWxkcmVuOiBhbnkgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlR3JpZGxpc3RTZWN0aW9uUHJvcHMsXG4gICAgICAgIC4uLnNvcnRhYmxlUmV0XG4gICAgfVxufSovXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgYXNzZXJ0RW1wdHlPYmplY3QsIGZpbmRGaXJzdEZvY3VzYWJsZSwgdXNlTWVyZ2VkUHJvcHMsIHVzZU1vZGFsLCBVc2VNb2RhbFBhcmFtZXRlcnMsIFVzZU1vZGFsUmV0dXJuVHlwZSwgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIFByZWZpY2VzIH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuaW50ZXJmYWNlIE1TUCB7XG4gICAgLyoqXG4gICAgICogV2hhdCByb2xlIHRoZSBzdXJmYWNlIGZ1bGZpbGxzLlxuICAgICAqIFxuICAgICAqIEdlbmVyYWwgbWVudXMgc2hvdWxkIHVzZSBcIm1lbnVcIi4gXCJkaWFsb2dcIiBjYW4gYmUgdXNlZCBmb3IgZ2VuZXJpYyBwb3AtdXAgdGhpbmdzLlxuICAgICAqL1xuICAgIHJvbGU6IFwiZGlhbG9nXCIgfCBcIm1lbnVcIiB8IFwidHJlZVwiIHwgXCJncmlkXCIgfCBcImxpc3Rib3hcIjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhpcyBtZW51IHN1cmZhY2UgaXMgb3BlbmVkLCBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiBpdCBtdXN0IGJlIGZvY3VzZWQuXG4gICAgICogXG4gICAgICogVGhpcyBjb250cm9scyB3aGF0IGlzIGZvY3VzZWQgKGUuZy4gdGhlIGZpcnN0IG1lbnUgaXRlbSwgdGhlIHdob2xlIHN1cmZhY2UgaXRzZWxmLCBldGMuKVxuICAgICAqL1xuICAgIC8vc2VuZEZvY3VzVG9NZW51KCk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIE1lbnVTdXJmYWNlT21pdHMgPSBrZXlvZiBNU1A7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVN1cmZhY2VQYXJhbWV0ZXJzPF9TIGV4dGVuZHMgRWxlbWVudCwgX0IgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTW9kYWxQYXJhbWV0ZXJzPFwiZXNjYXBlXCIgfCBcImxvc3QtZm9jdXNcIiB8IFwiYmFja2Ryb3BcIj4sIFwiZm9jdXNUcmFwUGFyYW1ldGVyc1wiPiB7XG4gICAgZm9jdXNUcmFwUGFyYW1ldGVyczogT21pdDxVc2VNb2RhbFBhcmFtZXRlcnM8XCJlc2NhcGVcIiB8IFwibG9zdC1mb2N1c1wiIHwgXCJiYWNrZHJvcFwiPltcImZvY3VzVHJhcFBhcmFtZXRlcnNcIl0sIFwidHJhcEFjdGl2ZVwiIHwgXCJmb2N1c09wZW5lclwiIHwgXCJvbmx5TW92ZUZvY3VzXCI+XG4gICAgbWVudVN1cmZhY2VQYXJhbWV0ZXJzOiBNU1A7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51U3VyZmFjZVJldHVyblR5cGU8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVRhcmdldEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51VHJpZ2dlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcHJvcHNTdXJmYWNlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51U3VyZmFjZUVsZW1lbnQ+O1xuICAgIHByb3BzVGFyZ2V0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51VGFyZ2V0RWxlbWVudD47XG4gICAgcHJvcHNUcmlnZ2VyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51VHJpZ2dlckVsZW1lbnQ+O1xuICAgIHByb3BzU2VudGluZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT47XG4gICAgZm9jdXNUcmFwUmV0dXJuOiBVc2VNb2RhbFJldHVyblR5cGU8bnVsbCwgTWVudVRyaWdnZXJFbGVtZW50LCBNZW51U3VyZmFjZUVsZW1lbnQ+W1wiZm9jdXNUcmFwUmV0dXJuXCJdO1xuICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybjogVXNlTW9kYWxSZXR1cm5UeXBlPG51bGwsIE1lbnVUcmlnZ2VyRWxlbWVudCwgTWVudVN1cmZhY2VFbGVtZW50PltcInJlZkVsZW1lbnRQb3B1cFJldHVyblwiXTtcbiAgICByZWZFbGVtZW50U291cmNlUmV0dXJuOiBVc2VNb2RhbFJldHVyblR5cGU8bnVsbCwgTWVudVRyaWdnZXJFbGVtZW50LCBNZW51U3VyZmFjZUVsZW1lbnQ+W1wicmVmRWxlbWVudFNvdXJjZVJldHVyblwiXTtcbn1cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VNZW51QnV0dG9uUmV0dXJuVHlwZUluZm8gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88bmV2ZXI+IHsgfVxuLypcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVN1cmZhY2VSZXR1cm5UeXBlV2l0aEhvb2tzPE1lbnVTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZU1lbnVTdXJmYWNlUmV0dXJuVHlwZUluZm88TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudD4ge1xuICAgIHVzZU1lbnVTdXJmYWNlU2VudGluZWw6IDxFIGV4dGVuZHMgRWxlbWVudD4oKSA9PiB7IHVzZU1lbnVTZW50aW5lbFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+OyB9O1xuICAgIHVzZU1lbnVTdXJmYWNlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVN1cmZhY2VFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVN1cmZhY2VFbGVtZW50PjtcbiAgICB1c2VNZW51U3VyZmFjZUNoaWxkUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVBhcmVudEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD47ICAvLyBOT1QgYSBtZW51IGl0ZW0hIFRoaXMgaXMgdGhlIG1lbnUsIGRpYWxvZywgcG9wdXAsIHdoYXRldmVyIGFjdHVhbGx5IGdldHMgdGhlIHJvbGUsIGFzIG9wcG9zZWQgdG8gdGhlIHN1cmZhY2UgdGhhdCBsaXN0ZW5zIHRvIG1vdXNlIGFuZCBrZXlib2FyZCBldmVudHNcbiAgICB1c2VNZW51U3VyZmFjZUJ1dHRvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PjtcblxufSovXG5cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VNZW51QnV0dG9uUmV0dXJuVHlwZVdpdGhIb29rcyBleHRlbmRzIFVzZU1lbnVCdXR0b25SZXR1cm5UeXBlSW5mbyB7IH1cblxuXG4vKipcbiAqIEEgbWVudSBzdXJmYWNlIGlzIHdoYXQgaGFuZGxlcyB1c2VyIGludGVyYWN0aW9uIHdpdGggYW4gaW50ZXJhY3RpdmUgYnV0IHRyYW5zaWVudCBzdXJmYWNlIChsaWtlIGEgbWVudSBvciBhIHBvcHVwKS5cbiAqIFxuICogVGhlIGtleWJvYXJkIChldGMuKSBpbnRlcmFjdGlvbnMgYXJlIHNoYXJlZCBhbW9uZyBhIGxvdCBvZiB3aWRnZXRzLCBhbmQgdGhlIG9wZW5pbmcgYnV0dG9uIGhhcyBzb21lIEFSSUEgcHJvcGVydGllcyB0aGF0IG5lZWQgc2V0dGluZy5cbiAqIFxuICogUmVsYXRlZCB0byBtZW51cywgd2hpY2ggYXJlIGEgbWVudSBjb250YWluZWQgd2l0aGluIGEgbWVudSBzdXJmYWNlLiBOb3QgcmVsYXRlZCB0byBtZW51YmFycyAtLSBtZW51cyBjb250YWluIG1lbnViYXJzLCBidXQgbm90IGFsbCBtZW51YmFycyBhcmUgY29udGFpbmVkIHdpdGhpbiBhIG1lbnUgb3IgaXRzIHN1cmZhY2UuXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbnVTdXJmYWNlPE1lbnVTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVUYXJnZXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVRyaWdnZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIC8vbWVudVN1cmZhY2U6IHsgc2VuZEZvY3VzVG9NZW51LCByb2xlIH0sIFxuICAgIGRpc21pc3NQYXJhbWV0ZXJzLFxuICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzLFxuICAgIGZvY3VzVHJhcFBhcmFtZXRlcnMsXG4gICAgbWVudVN1cmZhY2VQYXJhbWV0ZXJzOiB7IHJvbGUgfVxufTogVXNlTWVudVN1cmZhY2VQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVRyaWdnZXJFbGVtZW50Pik6IFVzZU1lbnVTdXJmYWNlUmV0dXJuVHlwZTxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVUYXJnZXRFbGVtZW50LCBNZW51VHJpZ2dlckVsZW1lbnQ+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZU1lbnVTdXJmYWNlXCIpO1xuXG4gICAgY29uc3QgeyBwcm9wc1JlZmVyZW5jZXI6IHByb3BzSWRUcmlnZ2VyLCBwcm9wc1NvdXJjZTogcHJvcHNJZFRhcmdldCB9ID0gdXNlUmFuZG9tSWQ8TWVudVRhcmdldEVsZW1lbnQsIE1lbnVUcmlnZ2VyRWxlbWVudD4oeyByYW5kb21JZFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5tZW51LCBvdGhlclJlZmVyZW5jZXJQcm9wOiBcImFyaWEtY29udHJvbHNcIiB9IH0pO1xuXG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQ6IGdldEJ1dHRvbkVsZW1lbnQsIHByb3BzU3RhYmxlOiBwcm9wc1JlZlRyaWdnZXIgfSwgLi4udm9pZDQgfSA9IHVzZVJlZkVsZW1lbnQ8TWVudVRyaWdnZXJFbGVtZW50Pih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7IG9uRWxlbWVudENoYW5nZTogdW5kZWZpbmVkIH0gfSk7XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudDogZ2V0TWVudUVsZW1lbnQsIHByb3BzU3RhYmxlOiBwcm9wc1JlZlN1cmZhY2UsIC4uLnZvaWQ1IH0sIC4uLnZvaWQ2IH0gPSB1c2VSZWZFbGVtZW50PE1lbnVTdXJmYWNlRWxlbWVudD4oeyByZWZFbGVtZW50UGFyYW1ldGVyczogeyBvbkVsZW1lbnRDaGFuZ2U6IHVuZGVmaW5lZCB9IH0pO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZm9jdXNUcmFwUmV0dXJuLFxuICAgICAgICBwcm9wc0ZvY3VzQ29udGFpbmVyLFxuICAgICAgICBwcm9wc1BvcHVwLFxuICAgICAgICBwcm9wc1NvdXJjZTogcHMyLFxuICAgICAgICByZWZFbGVtZW50UG9wdXBSZXR1cm4sXG4gICAgICAgIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm5cbiAgICB9ID0gdXNlTW9kYWw8XCJlc2NhcGVcIiB8IFwibG9zdC1mb2N1c1wiIHwgXCJiYWNrZHJvcFwiLCBNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVUcmlnZ2VyRWxlbWVudCwgTWVudVN1cmZhY2VFbGVtZW50Pih7XG4gICAgICAgIGRpc21pc3NQYXJhbWV0ZXJzLFxuICAgICAgICBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycyxcbiAgICAgICAgZm9jdXNUcmFwUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgLi4uZm9jdXNUcmFwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIG9ubHlNb3ZlRm9jdXM6IHRydWUsXG4gICAgICAgICAgICB0cmFwQWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgZm9jdXNPcGVuZXI6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBidXR0b25FbGVtZW50ID0gZ2V0QnV0dG9uRWxlbWVudCgpIGFzIEhUTUxFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgICAgICAgICBidXR0b25FbGVtZW50Py5mb2N1cygpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDQpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQ1KTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkNik7XG5cbiAgICBjb25zdCBwcm9wc1N1cmZhY2U6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD4gPSB1c2VNZXJnZWRQcm9wcyhwcm9wc1JlZlN1cmZhY2UsIHByb3BzUG9wdXAsIHByb3BzRm9jdXNDb250YWluZXIpO1xuXG4gICAgY29uc3QgcHJvcHNUYXJnZXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVUYXJnZXRFbGVtZW50PiA9IHVzZU1lcmdlZFByb3BzKHtcbiAgICAgICAgcm9sZVxuICAgIH0sIHByb3BzSWRUYXJnZXQpO1xuXG4gICAgY29uc3QgcHJvcHNUcmlnZ2VyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51VHJpZ2dlckVsZW1lbnQ+ID0gdXNlTWVyZ2VkUHJvcHMoe1xuICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogKGRpc21pc3NQYXJhbWV0ZXJzLm9wZW4pLnRvU3RyaW5nKCksXG4gICAgICAgIFwiYXJpYS1oYXNwb3B1cFwiOiByb2xlLFxuICAgIH0sIHByb3BzUmVmVHJpZ2dlciwgcHMyLCBwcm9wc0lkVHJpZ2dlcik7XG5cbiAgICBjb25zdCBwcm9wc1NlbnRpbmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+ID0gdXNlRm9jdXNTZW50aW5lbCh7XG4gICAgICAgIGZvY3VzU2VudGluZWw6IHtcbiAgICAgICAgICAgIHNlbmRGb2N1c1RvTWVudTogdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gZm9jdXNUcmFwUGFyYW1ldGVycy5mb2N1c1BvcHVwKGdldE1lbnVFbGVtZW50KCksICgpID0+IGZpbmRGaXJzdEZvY3VzYWJsZShnZXRNZW51RWxlbWVudCgpISkpIH0sIFtdKSxcbiAgICAgICAgICAgIG9uQ2xvc2U6IHVzZUNhbGxiYWNrKCgpID0+IHsgZGlzbWlzc1BhcmFtZXRlcnMub25DbG9zZShcImxvc3QtZm9jdXNcIikgfSwgW2Rpc21pc3NQYXJhbWV0ZXJzLm9uQ2xvc2VdKSxcbiAgICAgICAgICAgIG9wZW46IGRpc21pc3NQYXJhbWV0ZXJzLm9wZW5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9jdXNUcmFwUmV0dXJuLFxuICAgICAgICBwcm9wc1NlbnRpbmVsLFxuICAgICAgICBwcm9wc1N1cmZhY2UsXG4gICAgICAgIHByb3BzVGFyZ2V0LFxuICAgICAgICBwcm9wc1RyaWdnZXIsXG4gICAgICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybixcbiAgICAgICAgcmVmRWxlbWVudFNvdXJjZVJldHVyblxuICAgIH1cbn1cblxuaW50ZXJmYWNlIEZTUCBleHRlbmRzIE1TUCB7XG4gICAgb3BlbjogYm9vbGVhbjtcbiAgICBvbkNsb3NlKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIEZvY3VzU2VudGluZWxPbWl0cyA9IGtleW9mIEZTUDtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1NlbnRpbmVsUGFyYW1ldGVycyB7XG4gICAgZm9jdXNTZW50aW5lbDogeyBzZW5kRm9jdXNUb01lbnU6ICgpID0+IHZvaWQ7IG9wZW46IGJvb2xlYW47IG9uQ2xvc2UoKTogdm9pZDsgfTtcbn1cblxuXG4vLyBBIGZvY3VzIHNlbnRpbmFsIGlzIGEgaGlkZGVuIGJ1dCBmb2N1c2FibGUgZWxlbWVudCB0aGF0IGNvbWVzIGF0IHRoZSBzdGFydCBvciBlbmQgXG4vLyBvZiB0aGUgb3V0LW9mLXBsYWNlLWZvY3VzYWJsZSBjb21wb25lbnQgdGhhdCwgd2hlbiBhY3RpdmF0ZWQgb3IgZm9jdXNlZCBvdmVyLCBjbG9zZXMgdGhlIGNvbXBvbmVudFxuLy8gKGlmIGZvY3VzZWQgd2l0aGluIDEwMG1zIG9mIHRoZSBvcGVuIHByb3AgY2hhbmdpbmcsIGluc3RlYWQgb2Zcbi8vIGNsb3NpbmcsIGZvY3VzaW5nIHRoZSBzZW50aW5lbCBpbW1lZGlhdGVseSBhc2tzIGl0IHRvIGZvY3VzIGl0c2VsZikuXG4vLyBUaGlzIGV4aXN0cyBmb3IgdGhpbmdzIGxpa2UgbWVudXMgd2hpY2ggY2FuIGhhdmUgZm9jdXMgYnV0IGFsc28gbmVlZCBhIHdheSB0byByZXR1cm5cbi8vIHRvIHdoYXRldmVyIG91dC1vZi1wbGFjZSBwYXJlbnQgdGhleSBjYW1lIGZyb20gd2hlbiBuYXR1cmFsbHkgdGFiYmVkIG91dCBvZiAoYXMgb3Bwb3NlZFxuLy8gdG8gZGlhbG9ncyB3aGljaCBsb29wIGJhY2sgYXJvdW5kIHdoZW4gdGFiYmVkIG91dCBvZikuIFdoaWxlIG1vdXNlIHVzZXJzIGNhbiBjbGljayBvdXQgb2YgYSBtZW51XG4vLyBhbmQga2V5Ym9hcmQgdXNlcnMgY2FuIGVzY2FwZSB0byBjbG9zZSBhIG1lbnUsIHNjcmVlbiByZWFkZXJzIGFuZCBvdGhlciBpbnB1dCBtZXRob2RzIFxuLy8gdGhhdCBkb24ndCB1c2UgdGhvc2UgdHdvIHdvdWxkIGJlY29tZSBzdHVjay5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGb2N1c1NlbnRpbmVsPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGZvY3VzU2VudGluZWw6IHsgb3Blbiwgb25DbG9zZSwgc2VuZEZvY3VzVG9NZW51IH0gfTogVXNlRm9jdXNTZW50aW5lbFBhcmFtZXRlcnMpOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XG4gICAgZGVidWdMb2coXCJ1c2VGb2N1c1NlbnRpbmVsXCIpO1xuICAgIGNvbnN0IGdldFNlbmRGb2N1c1dpdGhpbk1lbnUgPSB1c2VTdGFibGVHZXR0ZXIoc2VuZEZvY3VzVG9NZW51KTtcbiAgICBjb25zdCBzdGFibGVPbkNsb3NlID0gdXNlU3RhYmxlQ2FsbGJhY2sob25DbG9zZSk7XG5cbiAgICBjb25zdCBbZmlyc3RTZW50aW5lbElzQWN0aXZlLCBzZXRGaXJzdFNlbnRpbmVsSXNBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHVzZVRpbWVvdXQoeyBjYWxsYmFjazogKCkgPT4geyBzZXRGaXJzdFNlbnRpbmVsSXNBY3RpdmUob3Blbik7IH0sIHRpbWVvdXQ6IDEwMCwgdHJpZ2dlckluZGV4OiBgJHtvcGVufS0ke2ZpcnN0U2VudGluZWxJc0FjdGl2ZX1gIH0pO1xuXG5cbiAgICBjb25zdCBvbkZvY3VzID0gZmlyc3RTZW50aW5lbElzQWN0aXZlID8gKCgpID0+IHN0YWJsZU9uQ2xvc2UoKSkgOiAoKCkgPT4gZ2V0U2VuZEZvY3VzV2l0aGluTWVudSgpPy4oKSk7XG4gICAgY29uc3Qgb25DbGljayA9ICgpID0+IHN0YWJsZU9uQ2xvc2UoKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiBmaXJzdFNlbnRpbmVsSXNBY3RpdmUgPyAwIDogLTEsXG4gICAgICAgIG9uRm9jdXMsXG4gICAgICAgIG9uQ2xpY2tcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb24sIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZSwgdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkLCBDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ29udGV4dCwgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZSwgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbGJhclBhcmFtZXRlcnM8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PiBleHRlbmRzIE9taXQ8VXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8Q29udGFpbmVyRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPiwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPiB7XG4gICAgdG9vbGJhclBhcmFtZXRlcnM6IHtcbiAgICAgICAgb3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiO1xuXG4gICAgICAgIC8vIFNob3VsZCBiZSBcInRvb2xiYXJcIiBmb3IgdG9vbGJhcnMsIG51bGwgaWYgc29tZW9uZSBlbHNlIHRha2VzIGNhcmUgb2YgdGhlIHJvbGUsIGFuZCB3aGF0ZXZlciBzdHJpbmcgaXMgYXBwbGljYWJsZSBvdGhlcndpc2VcbiAgICAgICAgcm9sZTogc3RyaW5nIHwgbnVsbDtcbiAgICB9O1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT5bXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCI+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbGJhclJldHVyblR5cGU8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PiBleHRlbmRzIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4ge1xuICAgIHRvb2xiYXJSZXR1cm46IHsgcHJvcHNVbnN0YWJsZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyRWxlbWVudD4gfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm88Q2hpbGRFbGVtZW50PiB7XG5cbn1cblxuZXhwb3J0IHR5cGUgVXNlVG9vbGJhckNvbnRleHQ8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PiA9IENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0PENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT47XG5cblxuLy9leHBvcnQgdHlwZSBVc2VUb29sYmFyQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAoaTogVXNlVG9vbGJhckNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIEM+KSA9PiBVc2VUb29sYmFyQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxFPj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEUsIE0sIG5ldmVyPiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbGJhckNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlVG9vbGJhclN1YkluZm88Q2hpbGRFbGVtZW50Pj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudCwgTT4geyB9XG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbGJhckNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlVG9vbGJhclN1YkluZm88Q2hpbGRFbGVtZW50Pj4gZXh0ZW5kcyBVc2VUb29sYmFyQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIE0+IHtcbi8vfVxuXG4vKipcbiAqIEEgdG9vbGJhciBpcyBqdXN0IGEgY29sbGVjdGlvbiBvZiB3aWRnZXRzIGluIGFuIGV4cGVjdGVkIG9yZGVyIGFuZCB3aXRoIHRoZSB1c3VhbCBrZXlib2FyZCBuYXZpZ2F0aW9uIHN0dWZmLlxuICogXG4gKiBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYSB0b29sYmFyIGFuZCBhIG1lbnViYXIgaXMgdGhhdCBhIG1lbnViYXIgY29udGFpbnMgcHVyZWx5IHN0YXRpYyBtZW51aXRlbXMsIFxuICogYnV0IGEgdG9vbGJhciBpcyB0aGUgbW9yZSBnZW5lcmFsIGNhc2UsIGJlaW5nIGFibGUgdG8gY29udGFpbiBhbnl0aGluZyBhdCBhbGwuIFxuICogQSBtZW51YmFyIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIG9mIGEgdG9vbGJhciwgYW5kIGEgbWVudSBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWxpemVkIG1lbnViYXJcbiAqIFxuICogRWl0aGVyIHdheSwgYmUgc3VyZSB0byBzcGVjaWZ5IHRoZSByb2xlIGFuZCBvcmllbnRhdGlvbiB0aGlzIHRvb2xiYXIgaGFzIChyb2xlPXRvb2xiYXIgaWYgeW91J3JlIHVzaW5nIHRoaXMgYXMgYW4gYWN0dWFsIHRvb2xiYXIpLlxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VUb29sYmFyPENvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgdG9vbGJhclBhcmFtZXRlcnM6IHsgb3JpZW50YXRpb24sIHJvbGUgfSxcbiAgICAuLi5saXN0TmF2UGFyYW1ldGVyc1xufTogVXNlVG9vbGJhclBhcmFtZXRlcnM8Q29udGFpbmVyRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+Pik6IFVzZVRvb2xiYXJSZXR1cm5UeXBlPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgVXNlVG9vbGJhclN1YkluZm88Q2hpbGRFbGVtZW50Pj4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIFxuICAgICAgICAuLi5saXN0TmF2UmV0dXJuXG4gICAgfSA9IHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb248Q29udGFpbmVyRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+Pih7XG4gICAgICAgIC4uLmxpc3ROYXZQYXJhbWV0ZXJzLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogeyAuLi5saW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgbmF2aWdhdGlvbkRpcmVjdGlvbjogb3JpZW50YXRpb24gfSxcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvb2xiYXJSZXR1cm46IHsgcHJvcHNVbnN0YWJsZTogeyByb2xlOiByb2xlID8/IHVuZGVmaW5lZCB9IH0sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHByb3BzLFxuICAgICAgICAuLi5saXN0TmF2UmV0dXJuXG4gICAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUb29sYmFyQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIC4uLmxpc3ROYXZDaGlsZFBhcmFtZXRlcnNcbn06IFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+Pik6IFVzZVRvb2xiYXJDaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50LCBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PiB7XG4gICAgcmV0dXJuIHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIFVzZVRvb2xiYXJTdWJJbmZvPENoaWxkRWxlbWVudD4sIG5ldmVyPih7XG4gICAgICAgIC4uLmxpc3ROYXZDaGlsZFBhcmFtZXRlcnNcbiAgICB9KTtcbn0iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZywgRW5oYW5jZWRFdmVudCwgZW5oYW5jZUV2ZW50IH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZVRvb2xiYXIsIHVzZVRvb2xiYXJDaGlsZCwgVXNlVG9vbGJhckNoaWxkUGFyYW1ldGVycywgVXNlVG9vbGJhckNoaWxkUmV0dXJuVHlwZSwgVXNlVG9vbGJhclBhcmFtZXRlcnMsIFVzZVRvb2xiYXJSZXR1cm5UeXBlLCBVc2VUb29sYmFyU3ViSW5mbyB9IGZyb20gXCIuL3VzZS10b29sYmFyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudWJhclN1YkluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+IHtcblxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudWJhclBhcmFtZXRlcnM8TWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBPbWl0PFVzZVRvb2xiYXJQYXJhbWV0ZXJzPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+LCBcInRvb2xiYXJQYXJhbWV0ZXJzXCI+IHtcbiAgICB0b29sYmFyUGFyYW1ldGVyczogT21pdDxVc2VUb29sYmFyUGFyYW1ldGVyczxNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPltcInRvb2xiYXJQYXJhbWV0ZXJzXCJdLCBcInJvbGVcIj47XG4gICAgbWVudWJhclBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYWxseSBcIm1lbnVcIi4gQ2FuIGJlIG51bGwgaWYgdGhlIHJvbGUgaXMgcHJvdmlkZWQgZWxzZXdoZXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgcm9sZTogc3RyaW5nIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudWJhckl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiBleHRlbmRzIE9taXQ8VXNlVG9vbGJhckNoaWxkUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQsIE0+LCBcInByZXNzUGFyYW1ldGVyc1wiPiB7XG4gICAgLy9oYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudD47XG4gICAgcHJlc3NQYXJhbWV0ZXJzOiBPbWl0PFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50LCBNPltcInByZXNzUGFyYW1ldGVyc1wiXSwgXCJvblByZXNzU3luY1wiIHwgXCJmb2N1c1NlbGZcIj47XG4gICAgbWVudUl0ZW1QYXJhbWV0ZXJzOiB7XG4gICAgICAgIHJvbGU6IFwibWVudWl0ZW1cIiB8IFwibWVudWl0ZW1jaGVja2JveFwiIHwgXCJtZW51aXRlbXJhZGlvXCI7XG4gICAgICAgIC8vZGlzYWJsZWQ6IERpc2FibGVkVHlwZTtcbiAgICAgICAgb25QcmVzczogbnVsbCB8ICgoZTogRW5oYW5jZWRFdmVudDxNZW51SXRlbUVsZW1lbnQsIGguSlNYLlRhcmdldGVkRXZlbnQ8TWVudUl0ZW1FbGVtZW50PiwgeyBpbmRleDogbnVtYmVyIH0+KSA9PiB2b2lkKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudWJhclJldHVyblR5cGU8TWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBVc2VUb29sYmFyUmV0dXJuVHlwZTxNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudWJhckl0ZW1SZXR1cm5UeXBlPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiBleHRlbmRzIFVzZVRvb2xiYXJDaGlsZFJldHVyblR5cGU8TWVudUl0ZW1FbGVtZW50LCBNPiB7IH1cblxuXG5cblxuLy9leHBvcnQgdHlwZSBVc2VNZW51SXRlbVByb3BzPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51SXRlbUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51SXRlbUVsZW1lbnQ+O1xuLy9leHBvcnQgdHlwZSBVc2VNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gPSAoYXJnczogVXNlTWVudUl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCwgTT4pID0+IFVzZU1lbnVJdGVtUmV0dXJuVHlwZTxNZW51SXRlbUVsZW1lbnQsIE0+O1xuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbnViYXI8TWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICB0b29sYmFyUGFyYW1ldGVycyxcbiAgICBtZW51YmFyUGFyYW1ldGVyczogeyByb2xlIH1cbn06IFVzZU1lbnViYXJQYXJhbWV0ZXJzPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+KTogVXNlTWVudWJhclJldHVyblR5cGU8TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4ge1xuXG4gICAgZGVidWdMb2coXCJ1c2VNZW51YmFyXCIpO1xuXG4gICAgY29uc3Qge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c1JldHVybixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICB0b29sYmFyUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICAuLi5fcmVzdFxuICAgIH0gPSB1c2VUb29sYmFyPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQ+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICB0b29sYmFyUGFyYW1ldGVyczogeyByb2xlLCAuLi50b29sYmFyUGFyYW1ldGVycyB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c1JldHVybixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICB0b29sYmFyUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuXG4gICAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW51YmFyQ2hpbGQ8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIHByZXNzUGFyYW1ldGVyczogeyAuLi5wcmVzc1BhcmFtZXRlcnMgfSxcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIGNvbnRleHQsXG4gICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgIG1lbnVJdGVtUGFyYW1ldGVyczogeyBvblByZXNzLCByb2xlIH1cbn06IFVzZU1lbnViYXJJdGVtUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+KTogVXNlTWVudWJhckl0ZW1SZXR1cm5UeXBlPE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4ge1xuICAgIGRlYnVnTG9nKFwidXNlTWVudUl0ZW1cIiwgbWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleCk7XG4gICAgY29uc3QgZGlzYWJsZWQgPSBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMuZGlzYWJsZWQ7XG5cbiAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoZTogYW55KSA9PiAoZSBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50KS5mb2N1cz8uKCksIFtdKVxuXG4gICAgY29uc3Qge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIHByZXNzUmV0dXJuLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVyblxuICAgIH0gPSB1c2VUb29sYmFyQ2hpbGQ8TWVudUl0ZW1FbGVtZW50Pih7XG4gICAgICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGZvY3VzU2VsZixcbiAgICAgICAgICAgIG9uUHJlc3NTeW5jOiAoZSkgPT4gKGRpc2FibGVkID8gbnVsbCA6IG9uUHJlc3MpPy4oZW5oYW5jZUV2ZW50KGUsIHsgaW5kZXg6IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMuaW5kZXggfSkpLFxuICAgICAgICAgICAgLi4ucHJlc3NQYXJhbWV0ZXJzXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgLypsaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgcHJlc3NQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkNsaWNrU3luYzogKGUpID0+IChkaXNhYmxlZCA/IG51bGwgOiBvblByZXNzKT8uKGVuaGFuY2VFdmVudChlLCB7IGluZGV4OiBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLmluZGV4IH0pKSxcbiAgICAgICAgICAgIGV4Y2x1ZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZvY3VzU2VsZjogcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMuZm9jdXNTZWxmXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgIHN1YkluZm86IHsgc3ViSW5mbyB9Ki9cbiAgICB9KTtcblxuICAgIC8qZnVuY3Rpb24gdXNlTWVudUl0ZW1Qcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUl0ZW1FbGVtZW50Pikge1xuICAgICAgICBvdmVyd3JpdGVXaXRoV2FybmluZyhcInVzZU1lbnVJdGVtXCIsIHByb3BzLCBcInJvbGVcIiwgcm9sZSk7XG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcyhwcmVzc1JldHVybi5wcm9wc1N0YWJsZSwgcHJlc3NSZXR1cm4ucHJvcHNVbnN0YWJsZSwgcHJvcHMpO1xuICAgIH0qL1xuXG4gICAgcHJvcHMucm9sZSA9IHJvbGU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIHByZXNzUmV0dXJuLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVyblxuICAgIH07XG59XG4iLCJpbXBvcnQgeyB1c2VNZXJnZWRQcm9wcywgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgVXNlVG9vbGJhckNvbnRleHQgfSBmcm9tIFwiLi91c2UtdG9vbGJhclwiO1xuaW1wb3J0IHsgZGVidWdMb2cgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlTWVudVN1cmZhY2UsIFVzZU1lbnVTdXJmYWNlUGFyYW1ldGVycywgVXNlTWVudVN1cmZhY2VSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLW1lbnUtc3VyZmFjZVwiO1xuaW1wb3J0IHsgdXNlTWVudWJhciwgdXNlTWVudWJhckNoaWxkLCBVc2VNZW51YmFySXRlbVBhcmFtZXRlcnMsIFVzZU1lbnViYXJJdGVtUmV0dXJuVHlwZSwgVXNlTWVudWJhclBhcmFtZXRlcnMsIFVzZU1lbnViYXJSZXR1cm5UeXBlLCBVc2VNZW51YmFyU3ViSW5mbyB9IGZyb20gXCIuL3VzZS1tZW51YmFyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUNvbnRleHQ8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VNZW51YmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PiBleHRlbmRzIFVzZVRvb2xiYXJDb250ZXh0PENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBPbWl0PFVzZU1lbnViYXJQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPiwgXCJ0b29sYmFyUGFyYW1ldGVyc1wiIHwgXCJtZW51YmFyUGFyYW1ldGVyc1wiPiB7XG4gICAgZGlzbWlzc1BhcmFtZXRlcnM6IFVzZU1lbnVTdXJmYWNlUGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50PltcImRpc21pc3NQYXJhbWV0ZXJzXCJdO1xuICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzOiBVc2VNZW51U3VyZmFjZVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudD5bXCJlc2NhcGVEaXNtaXNzUGFyYW1ldGVyc1wiXTtcbiAgICBtZW51U3VyZmFjZVBhcmFtZXRlcnM6IE9taXQ8VXNlTWVudVN1cmZhY2VQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+W1wibWVudVN1cmZhY2VQYXJhbWV0ZXJzXCJdLCBcInJvbGVcIj47XG4gICAgdG9vbGJhclBhcmFtZXRlcnM6IE9taXQ8VXNlTWVudWJhclBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+W1widG9vbGJhclBhcmFtZXRlcnNcIl0sIFwicm9sZVwiPlxuICAgIG1lbnViYXJQYXJhbWV0ZXJzOiBPbWl0PFVzZU1lbnViYXJQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPltcIm1lbnViYXJQYXJhbWV0ZXJzXCJdLCBcInJvbGVcIj5cblxuICAgIG1lbnVQYXJhbWV0ZXJzOiB7XG4gICAgICAgIC8qKiBUaGlzIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgY29ycmVzcG9uZGluZyBhcnJvdyBrZXkgaXMgcHJlc3NlZCBvbiB0aGUgdHJpZ2dlcmluZyBidXR0b24uICovXG4gICAgICAgIG9uT3BlbigpOiB2b2lkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSAqKnBoeXNpY2FsKiogZGlyZWN0aW9uIHRoYXQgaXMgcHJlc3NlZFxuICAgICAgICAgKiB1c2luZyB0aGUgKiphcnJvdyBrZXlzKiogb24geW91ciBrZXlib2FyZC5cbiAgICAgICAgICogXG4gICAgICAgICAqIEl0IGhhcyBubyBlZmZlY3Qgb24gZGlzcGxheSwgbGlzdCBuYXZpZ2F0aW9uIGRpcmVjdGlvbiwgZXRjLlxuICAgICAgICAgKiBJdCBzb2xlbHkgY29udHJvbHMgdGhlIGFycm93IGtleSB0aGF0J3MgbGlzdGVuZWQgZm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgb3BlbkRpcmVjdGlvbjogXCJkb3duXCIgfCBcInVwXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiB8IG51bGw7XG4gICAgfVxuICAgIC8vbWVudUJ1dHRvbkhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8TWVudUJ1dHRvbkVsZW1lbnQ+O1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51SXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+IGV4dGVuZHMgVXNlTWVudWJhckl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCwgTT4ge1xuICAgIC8vaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQ+O1xuICAgIC8vbWVudUl0ZW06IHsgZGlzYWJsZWQ6IERpc2FibGVkVHlwZTsgb25QcmVzczogKGU6IEVuaGFuY2VkRXZlbnQ8TWVudUl0ZW1FbGVtZW50LCBoLkpTWC5UYXJnZXRlZEV2ZW50PE1lbnVJdGVtRWxlbWVudD4sIHsgaW5kZXg6IG51bWJlciB9PikgPT4gdm9pZDsgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVSZXR1cm5UeXBlPE1lbnVTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBVc2VNZW51U3VyZmFjZVJldHVyblR5cGU8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+LCBPbWl0PFVzZU1lbnViYXJSZXR1cm5UeXBlPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+LCBcInByb3BzXCI+IHtcblxufVxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUJ1dHRvblJldHVyblR5cGVJbmZvIGV4dGVuZHMgeyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtUmV0dXJuVHlwZTxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBVc2VNZW51YmFySXRlbVJldHVyblR5cGU8TWVudUl0ZW1FbGVtZW50LCBNPiB7IH1cblxuLypcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVJldHVyblR5cGVXaXRoSG9va3M8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlTWVudVJldHVyblR5cGVJbmZvPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIEMsIEs+IHtcbiAgICB1c2VNZW51U2VudGluZWw6IDxFIGV4dGVuZHMgRWxlbWVudD4oKSA9PiB7IHVzZU1lbnVTZW50aW5lbFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+OyB9O1xuICAgIHVzZU1lbnVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVQYXJlbnRFbGVtZW50PjtcbiAgICB1c2VNZW51U3VyZmFjZVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD47XG4gICAgdXNlTWVudUJ1dHRvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUJ1dHRvbkVsZW1lbnQ+O1xuICAgIHVzZU1lbnVJdGVtOiBVc2VNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQsIEMsIEs+O1xufSovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbnU8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBkaXNtaXNzUGFyYW1ldGVycyxcbiAgICBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycyxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICBtZW51UGFyYW1ldGVyczogeyBvcGVuRGlyZWN0aW9uLCBvbk9wZW4gfSxcbiAgICBtZW51U3VyZmFjZVBhcmFtZXRlcnMsXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyxcbiAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICB0b29sYmFyUGFyYW1ldGVycyxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1xufTogVXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+Pik6IFVzZU1lbnVSZXR1cm5UeXBlPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+IHtcblxuICAgIGRlYnVnTG9nKFwidXNlTWVudVwiKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgcHJvcHM6IHByb3BzTWVudWJhcixcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICB0b29sYmFyUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuXG4gICAgfSA9IHVzZU1lbnViYXI8TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIHRvb2xiYXJQYXJhbWV0ZXJzOiB7IC4uLnRvb2xiYXJQYXJhbWV0ZXJzIH0sXG4gICAgICAgIG1lbnViYXJQYXJhbWV0ZXJzOiB7IHJvbGU6IFwibWVudVwiIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG9uS2V5RG93biA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGlzT3BlbiA9IGRpc21pc3NQYXJhbWV0ZXJzLm9wZW47XG4gICAgICAgIGlmICghaXNPcGVuKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjoge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbkRpcmVjdGlvbiA9PSAndXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuRGlyZWN0aW9uID09ICdkb3duJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25PcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjoge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbkRpcmVjdGlvbiA9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uT3BlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuRGlyZWN0aW9uID09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uT3BlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBjb25zdCB7XG4gICAgICAgIGZvY3VzVHJhcFJldHVybixcbiAgICAgICAgcHJvcHNTZW50aW5lbCxcbiAgICAgICAgcHJvcHNTdXJmYWNlLFxuICAgICAgICBwcm9wc1RhcmdldCxcbiAgICAgICAgcHJvcHNUcmlnZ2VyLFxuICAgICAgICByZWZFbGVtZW50UG9wdXBSZXR1cm4sXG4gICAgICAgIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm5cbiAgICB9ID0gdXNlTWVudVN1cmZhY2U8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+KHtcbiAgICAgICAgbWVudVN1cmZhY2VQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAuLi5tZW51U3VyZmFjZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICByb2xlOiBcIm1lbnVcIixcbiAgICAgICAgfSxcbiAgICAgICAgZGlzbWlzc1BhcmFtZXRlcnMsXG4gICAgICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzLFxuICAgICAgICBmb2N1c1RyYXBQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBmb2N1c1BvcHVwOiAoKSA9PiB7IGRlYnVnZ2VyOyByb3ZpbmdUYWJJbmRleFJldHVybi5mb2N1c1NlbGYoKSB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGZvY3VzVHJhcFJldHVybixcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICBwcm9wc1NlbnRpbmVsLFxuICAgICAgICBwcm9wc1N1cmZhY2UsXG4gICAgICAgIHByb3BzVGFyZ2V0OiB1c2VNZXJnZWRQcm9wcyhwcm9wc1RhcmdldCwgcHJvcHNNZW51YmFyKSxcbiAgICAgICAgcHJvcHNUcmlnZ2VyOiB1c2VNZXJnZWRQcm9wcyh7IG9uS2V5RG93biB9LCBwcm9wc1RyaWdnZXIpLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybixcbiAgICAgICAgcmVmRWxlbWVudFNvdXJjZVJldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgdG9vbGJhclJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblxuXG4gICAgICAgIC8qZm9jdXNNZW51LFxuXG4gICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQsXG5cbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLCovXG5cblxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51SXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+IGV4dGVuZHMgVXNlTWVudWJhckl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCwgTT4ge1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PihwOiBVc2VNZW51SXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+Pikge1xuICAgIHJldHVybiB1c2VNZW51YmFyQ2hpbGQ8TWVudUl0ZW1FbGVtZW50PihwKTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ29udGV4dCwgdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbiwgdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGUsIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm8sIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTaW5nbGVTZWxlY3Rpb25EZWNsYXJhdGl2ZSwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZywgRW5oYW5jZWRFdmVudCwgUHJlZmljZXMgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgRm9jdXNhYmxlTGFiZWxFbGVtZW50LCBMYWJlbFBvc2l0aW9uLCB1c2VDaGVja2JveExpa2UsIFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnMsIFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGUsIHVzZUxhYmVsU3ludGhldGljLCBVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcblxuLy90eXBlIE9taXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gUGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+PjtcbmV4cG9ydCB0eXBlIFJhZGlvQ2hhbmdlRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBWIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nPiA9IEVuaGFuY2VkRXZlbnQ8RSwgRXZlbnQsIHsgc2VsZWN0ZWRWYWx1ZTogViB8IHVuZGVmaW5lZCB9PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHcm91cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfR3JvdXBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxHcm91cEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50LCBSYWRpb1N1YkluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQsIFY+PiwgXCJwcm9wc1wiIHwgXCJzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzXCI+IHtcbiAgICByYWRpb0dyb3VwUGFyYW1ldGVyczoge1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG5cbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogViB8IG51bGw7XG4gICAgICAgIHNldFNlbGVjdGVkVmFsdWUodmFsdWU6IFYgfCBudWxsIC8qZXZlbnQ6IFJhZGlvQ2hhbmdlRXZlbnQ8VGFiYmFibGVDaGlsZEVsZW1lbnQsIFY+Ki8pOiB2b2lkO1xuICAgICAgICAvL3RhZ0dyb3VwOiBFbGVtZW50VG9UYWc8R3JvdXBFbGVtZW50PjtcbiAgICAgICAgLy90YWdHcm91cExhYmVsOiBFbGVtZW50VG9UYWc8R3JvdXBMYWJlbEVsZW1lbnQ+O1xuICAgIH1cbiAgICBsYWJlbFBhcmFtZXRlcnM6IE9taXQ8VXNlTGFiZWxTeW50aGV0aWNQYXJhbWV0ZXJzW1wibGFiZWxQYXJhbWV0ZXJzXCJdLCBcIm9uTGFiZWxDbGlja1wiPjtcbiAgICAvL3NpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IFBpY2s8VXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8R3JvdXBFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgUmFkaW9TdWJJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50LCBWPj5bXCJzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzXCJdLCBcIm9uU2VsZWN0ZWRJbmRleENoYW5nZVwiPjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFkaW9QYXJhbWV0ZXJzPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFJhZGlvU3ViSW5mbzxGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgVj4+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBNLCBcImdldFZhbHVlMlwiPiwgXCJzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnNcIj4ge1xuICAgIHJhZGlvUGFyYW1ldGVyczoge1xuICAgICAgICB2YWx1ZTogVjtcbiAgICB9XG4gICAgY29udGV4dDogUmFkaW9Db250ZXh0PFYsIGFueSwgRm9jdXNhYmxlTGFiZWxFbGVtZW50PExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIE0+O1xuICAgIGNoZWNrYm94TGlrZVBhcmFtZXRlcnM6IE9taXQ8VXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+W1wiY2hlY2tib3hMaWtlUGFyYW1ldGVyc1wiXSwgXCJjaGVja2VkXCIgfCBcIm9uSW5wdXRcIiB8IFwicm9sZVwiPjtcbiAgICBsYWJlbFBhcmFtZXRlcnM6IE9taXQ8VXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+W1wibGFiZWxQYXJhbWV0ZXJzXCJdLCBcIm9uTGFiZWxDbGlja1wiPjtcbiAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IE9taXQ8VXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgTSwgbmV2ZXI+W1wic2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzXCJdLCBcImFyaWFQcm9wTmFtZVwiIHwgXCJzZWxlY3Rpb25Nb2RlXCI+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmFkaW9Db250ZXh0PFYgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgUmFkaW9TdWJJbmZvPENoaWxkRWxlbWVudCwgVj4+IGV4dGVuZHMgQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNvbnRleHQ8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPiB7XG4gICAgcmFkaW9Db250ZXh0OiB7XG4gICAgICAgIC8vIG9uU2VsZWN0ZWRJbmRleENoYW5nZTogKGU6IEV2ZW50LCBuZXdJbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIGJ5TmFtZTogTWFwPFYsIG51bWJlcj47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhZGlvR3JvdXBSZXR1cm5UeXBlPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGU8R3JvdXBFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgUmFkaW9TdWJJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50LCBWPj4sIFwicHJvcHNcIj4ge1xuICAgIHJhZGlvR3JvdXBSZXR1cm46IHtcbiAgICAgICAgc2VsZWN0ZWRJbmRleDogbnVtYmVyIHwgbnVsbDtcbiAgICAgICAgLy9zZWxlY3RlZFZhbHVlOiBWIHwgbnVsbDtcbiAgICAgICAgLy9zZXRTZWxlY3RlZFZhbHVlKHZhbHVlOiBWIHwgbnVsbCk6IHZvaWQ7XG4gICAgICAgIC8vc2V0U2VsZWN0ZWRJbmRleChpbmRleDogbnVtYmVyIHwgbnVsbCk6IHZvaWQ7XG4gICAgfVxuICAgIHByb3BzUmFkaW9Hcm91cDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JvdXBFbGVtZW50PjtcbiAgICBwcm9wc1JhZGlvR3JvdXBMYWJlbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JvdXBMYWJlbEVsZW1lbnQ+O1xuXG4gICAgLy8gb3ZlcnJpZGVcbiAgICBjb250ZXh0OiBSYWRpb0NvbnRleHQ8ViwgR3JvdXBFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgUmFkaW9TdWJJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50LCBWPj47XG59XG4vKlxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZVdpdGhIb29rczxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHIGV4dGVuZHMgRWxlbWVudCwgR0wgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgRWxlbWVudCwgSUwgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88ViwgSSwgQywgSz4ge1xuICAgIHVzZVJhZGlvR3JvdXBMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdMPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R0w+O1xuICAgIHVzZVJhZGlvR3JvdXBQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxHPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rz47XG4gICAgdXNlUmFkaW86IFVzZVJhZGlvPFYsIEksIElMLCBDLCBLPjtcbn0qL1xuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvU3ViSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudD4ge1xuICAgIGdldFZhbHVlMigpOiBWO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUmFkaW9Hcm91cDxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHIGV4dGVuZHMgRWxlbWVudCwgR0wgZXh0ZW5kcyBFbGVtZW50LCBUQ0UgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgbGFiZWxQYXJhbWV0ZXJzLFxuICAgIHJhZGlvR3JvdXBQYXJhbWV0ZXJzOiB7IG5hbWUsIHNldFNlbGVjdGVkVmFsdWU6IHNldFNlbGVjdGVkVmFsdWVFeHRlcm5hbCwgc2VsZWN0ZWRWYWx1ZSB9LFxufTogVXNlUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgRywgR0wsIFRDRT4pOiBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZTxWLCBHLCBHTCwgVENFPiB7XG5cbiAgICAvL2RlYnVnTG9nKFwidXNlUmFkaW9Hcm91cFwiLCBzZWxlY3RlZFZhbHVlKTtcbiAgICAvL2NvbnN0IHsgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50OiBfZ2V0R3JvdXBFbGVtZW50LCBwcm9wc1N0YWJsZSB9IH0gPSB1c2VSZWZFbGVtZW50PEc+KHsgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9IH0pO1xuXG4gICAgY29uc3QgW3NlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgYnlOYW1lID0gdXNlUmVmKG5ldyBNYXA8ViwgbnVtYmVyPigpKTtcbiAgICAvKmNvbnN0IHNldFNlbGVjdGVkVmFsdWUgPSB1c2VDYWxsYmFjaygodmFsdWU6IFYgfCBudWxsKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4KG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gYnlOYW1lLmN1cnJlbnQuZ2V0KHZhbHVlKTtcbiAgICAgICAgc2V0U2VsZWN0ZWRJbmRleChuZXdJbmRleCA/PyBudWxsKTtcbiAgICB9LCBbXSkqL1xuXG4gICAgY29uc3QgeyBwcm9wc0lucHV0OiBwcm9wc0dyb3VwMSwgcHJvcHNMYWJlbCB9ID0gdXNlTGFiZWxTeW50aGV0aWM8RywgR0w+KHtcbiAgICAgICAgbGFiZWxQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkxhYmVsQ2xpY2s6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybi5mb2N1c1NlbGYoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLi4ubGFiZWxQYXJhbWV0ZXJzXG4gICAgICAgIH0sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzOiB7IHByZWZpeDogUHJlZmljZXMucmFkaW9Hcm91cExhYmVsLCB9LFxuICAgICAgICByYW5kb21JZElucHV0UGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLnJhZGlvR3JvdXAgfVxuICAgIH0pXG5cblxuICAgIC8qY29uc3Qgb25TZWxlY3RlZEluZGV4Q2hhbmdlID0gdXNlU3RhYmxlQ2FsbGJhY2soKG5ld0luZGV4OiBudW1iZXIgfCBudWxsKSA9PiB7XG4gICAgICAgIGlmIChuZXdJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG1hbmFnZWRDaGlsZHJlblJldHVybi5nZXRDaGlsZHJlbigpLmdldEF0KG5ld0luZGV4KTtcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIG9uU2VsZWN0ZWRWYWx1ZUNoYW5nZShjaGlsZC5nZXRWYWx1ZTIoKSA/PyBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvblNlbGVjdGVkVmFsdWVDaGFuZ2UobnVsbCk7XG4gICAgICAgIC8vb25TZWxlY3RlZFZhbHVlQ2hhbmdlKGVuaGFuY2VFdmVudDxUQ0UsIEV2ZW50LCB7IHNlbGVjdGVkVmFsdWU6IFYgfCB1bmRlZmluZWQgfT4oZSwgeyBzZWxlY3RlZFZhbHVlOiBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4uZ2V0Q2hpbGRyZW4oKS5nZXRBdChuZXdJbmRleCk/LmdldFZhbHVlKCkgfSkpO1xuICAgIH0pOyovXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2VsZWN0ZWRWYWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLnNldFNlbGVjdGVkSW5kZXgoYnlOYW1lLmN1cnJlbnQuZ2V0KHNlbGVjdGVkVmFsdWUpID8/IG51bGwpO1xuICAgICAgICBlbHNlXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybi5zZXRTZWxlY3RlZEluZGV4KG51bGwpO1xuICAgIH0sIFtzZWxlY3RlZFZhbHVlXSlcblxuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHByb3BzOiBwcm9wc0dyb3VwMixcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5cbiAgICB9ID0gdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbjxHLCBUQ0UsIFJhZGlvU3ViSW5mbzxUQ0UsIFY+Pih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IHsgaW5pdGlhbGx5U2VsZWN0ZWRJbmRleDogc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleCB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcbiAgICB9KTtcblxuICAgIGNvbnN0IF92OiB2b2lkID0gdXNlU2luZ2xlU2VsZWN0aW9uRGVjbGFyYXRpdmUoe1xuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm46IHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXg6IHVzZVN0YWJsZUNhbGxiYWNrKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgPyBzKHNlbGVjdGVkSW5kZXgpIDogcztcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IG1hbmFnZWRDaGlsZHJlblJldHVybi5nZXRDaGlsZHJlbigpLmdldEF0KG5leHQpPy5nZXRWYWx1ZTIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRWYWx1ZUV4dGVybmFsKG5leHRWYWx1ZSBhcyBWKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkVmFsdWVFeHRlcm5hbChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCBzaW5nbGVTZWxlY3Rpb25EZWNsYXJhdGl2ZVBhcmFtZXRlcnM6IHsgc2VsZWN0ZWRJbmRleCB9XG4gICAgfSlcblxuXG4gICAgY29uc3QgcHJvcHNSYWRpb0dyb3VwID0gdXNlTWVyZ2VkUHJvcHMocHJvcHNHcm91cDEsIHByb3BzR3JvdXAyLCB7IHJvbGU6IFwicmFkaW9ncm91cFwiIH0pO1xuXG4gICAgLyp1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2VsZWN0ZWRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4KG51bGwpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gYnlOYW1lLmN1cnJlbnQuZ2V0KHNlbGVjdGVkVmFsdWUpO1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRJbmRleChzZWxlY3RlZEluZGV4ID8/IG51bGwpO1xuICAgICAgICB9XG4gICAgfSwgW2J5TmFtZSwgc2VsZWN0ZWRWYWx1ZV0pOyovXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wc1JhZGlvR3JvdXAsXG4gICAgICAgIHByb3BzUmFkaW9Hcm91cExhYmVsOiBwcm9wc0xhYmVsLFxuXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuLFxuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgcmFkaW9Db250ZXh0OiB7IG5hbWUsIGJ5TmFtZTogYnlOYW1lLmN1cnJlbnQgfVxuICAgICAgICB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJhZGlvR3JvdXBSZXR1cm46IHsgc2VsZWN0ZWRJbmRleCB9LFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFkaW9SZXR1cm5UeXBlPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSSBleHRlbmRzIEVsZW1lbnQsIElMIGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFJhZGlvU3ViSW5mbzxGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIEksIElMPiwgVj4+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCwgSSwgSUw+LCBNPiwgXCJwcm9wc1wiPiwgVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZTxJLCBJTD4ge1xuICAgIHByb3BzSW5wdXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+O1xuICAgIHByb3BzTGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElMPjtcbn1cblxuLypleHBvcnQgaW50ZXJmYWNlIFVzZVJhZGlvUmV0dXJuVHlwZVdpdGhIb29rczxJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUmFkaW9SZXR1cm5UeXBlSW5mbzxJLCBMPiB7XG4gICAgdXNlUmFkaW9JbnB1dDogVXNlUmFkaW9JbnB1dDxJPjtcbiAgICB1c2VSYWRpb0xhYmVsOiBVc2VSYWRpb0xhYmVsPEw+O1xufSovXG5cbi8vdHlwZSBVc2VSYWRpb0lucHV0PEkgZXh0ZW5kcyBFbGVtZW50PiA9ICh7IHRhZyB9OiBUYWdTZW5zaXRpdmVQcm9wczxJPikgPT4geyB1c2VSYWRpb0lucHV0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+OyB9XG4vL3R5cGUgVXNlUmFkaW9MYWJlbDxMIGV4dGVuZHMgRWxlbWVudD4gPSAoeyB0YWcgfTogVGFnU2Vuc2l0aXZlUHJvcHM8TD4pID0+IHsgdXNlUmFkaW9MYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEw+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMPjsgfVxuXG4vL2V4cG9ydCB0eXBlIFVzZVJhZGlvPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEkgZXh0ZW5kcyBFbGVtZW50LCBMIGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlUmFkaW9QYXJhbWV0ZXJzPFYsIEksIEwsIEMsIEs+KSA9PiBVc2VSYWRpb1JldHVyblR5cGVXaXRoSG9va3M8SSwgTD5cblxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJhZGlvPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgViBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4oe1xuICAgIHJhZGlvUGFyYW1ldGVyczogeyB2YWx1ZSB9LFxuICAgIGNoZWNrYm94TGlrZVBhcmFtZXRlcnM6IHsgZGlzYWJsZWQgfSxcbiAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIGxhYmVsUGFyYW1ldGVycyxcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHByZXNzUGFyYW1ldGVycyxcbiAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgY29udGV4dCxcbiAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnNcblxufTogVXNlUmFkaW9QYXJhbWV0ZXJzPExQLCBWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgUmFkaW9TdWJJbmZvPEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBWPj4pOiBVc2VSYWRpb1JldHVyblR5cGU8TFAsIFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBSYWRpb1N1YkluZm88Rm9jdXNhYmxlTGFiZWxFbGVtZW50PExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFY+PiB7XG4gICAgdHlwZSBUYWJiYWJsZUNoaWxkRWxlbWVudCA9IEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+O1xuICAgIGNvbnN0IGluZGV4ID0gbWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleDtcbiAgICBkZWJ1Z0xvZyhcInVzZVJhZGlvXCIsIGluZGV4KTtcbiAgICBjb25zdCBvbklucHV0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRFbGVtZW50PikgPT4ge1xuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVybi5zZXRUaGlzT25lU2VsZWN0ZWQoZSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IG5hbWUsIGJ5TmFtZSB9ID0gY29udGV4dC5yYWRpb0NvbnRleHRcblxuICAgIGNvbnN0IHsgdGFnSW5wdXQsIHRhZ0xhYmVsLCBsYWJlbFBvc2l0aW9uIH0gPSBsYWJlbFBhcmFtZXRlcnM7XG5cbiAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZVN0YWJsZUdldHRlcih2YWx1ZSk7XG4gICAgY29uc3Qge1xuICAgICAgICBwcm9wczogbGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgcHJlc3NSZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuXG4gICAgfSA9IHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZDxUYWJiYWJsZUNoaWxkRWxlbWVudCwgUmFkaW9TdWJJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50LCBWPiwgbmV2ZXI+KHtcbiAgICAgICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczogeyBnZXRWYWx1ZTI6IGdldFZhbHVlIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHByZXNzUGFyYW1ldGVycyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnMsXG4gICAgICAgIC8qcm92aW5nVGFiSW5kZXgsXG4gICAgICAgIG1hbmFnZWRDaGlsZDoge1xuICAgICAgICAgICAgaW5kZXg6IG1hbmFnZWRDaGlsZC5pbmRleCxcbiAgICAgICAgICAgIGZsYWdzOiBtYW5hZ2VkQ2hpbGQuZmxhZ3NcbiAgICAgICAgfSxcbiAgICAgICAgaGFzRm9jdXMsXG4gICAgICAgIHN1YkluZm86IHsgZ2V0VmFsdWUsIHN1YkluZm8gfSwqL1xuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IHsgc2VsZWN0aW9uTW9kZTogXCJmb2N1c1wiLCBhcmlhUHJvcE5hbWU6IHRhZ0lucHV0ID09IFwiaW5wdXRcIiAmJiBsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIiA/IG51bGwgOiBcImFyaWEtc2VsZWN0ZWRcIiwgLi4uc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgc2VsZWN0ZWQ6IGNoZWNrZWQgfSA9IHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuO1xuXG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuOiByZWZFbGVtZW50SW5wdXRSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8SW5wdXRFbGVtZW50Pih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHJlZkVsZW1lbnRMYWJlbFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxMYWJlbEVsZW1lbnQ+KHsgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9IH0pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICBjaGVja2JveExpa2VJbnB1dFJldHVybixcbiAgICAgICAgY2hlY2tib3hMaWtlTGFiZWxSZXR1cm4sXG4gICAgICAgIHByZXNzSW5wdXRSZXR1cm4sXG4gICAgICAgIHByZXNzTGFiZWxSZXR1cm4sXG4gICAgICAgIHByb3BzSW5wdXQsXG4gICAgICAgIHByb3BzTGFiZWwsXG4gICAgICAgIHJhbmRvbUlkSW5wdXRSZXR1cm4sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxSZXR1cm4sXG4gICAgICAgIGNoZWNrYm94TGlrZVJldHVyblxuICAgIH0gPSB1c2VDaGVja2JveExpa2U8TGFiZWxQb3NpdGlvbiwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgY2hlY2tib3hMaWtlUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY2hlY2tlZDogKGNoZWNrZWQgPz8gZmFsc2UpLFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICBvbklucHV0OiBvbklucHV0LFxuICAgICAgICAgICAgcm9sZTogXCJyYWRpb1wiXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsUGFyYW1ldGVycyxcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5yYWRpbyB9LFxuICAgICAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLnJhZGlvTGFiZWwgfSxcbiAgICAgICAgcmVmRWxlbWVudElucHV0UmV0dXJuLFxuICAgICAgICByZWZFbGVtZW50TGFiZWxSZXR1cm5cbiAgICB9KTtcblxuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgYnlOYW1lLnNldCh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gKCkgPT4geyBieU5hbWUuZGVsZXRlKHZhbHVlKTsgfVxuICAgIH0sIFt2YWx1ZSwgaW5kZXhdKTtcblxuICAgIC8vY29uc3QgdXNlUmFkaW9JbnB1dCA9ICgpID0+IHtcbiAgICBpZiAodGFnSW5wdXQgPT0gXCJpbnB1dFwiKSB7XG4gICAgICAgIHByb3BzSW5wdXQubmFtZSA9IG5hbWU7XG4gICAgICAgIHByb3BzSW5wdXQuY2hlY2tlZCA9IChjaGVja2VkID8/IGZhbHNlKTtcbiAgICAgICAgcHJvcHNJbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvcHNJbnB1dFtcImFyaWEtY2hlY2tlZFwiXSA9IChjaGVja2VkID8/IGZhbHNlKS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3BzSWZJbnB1dEhhbmRsZXNGb2N1cyA9IHVzZU1lcmdlZFByb3BzPElucHV0RWxlbWVudD4obGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIHByb3BzSW5wdXQpO1xuICAgIGNvbnN0IHByb3BzSW5wdXQyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+ID0gbGFiZWxQb3NpdGlvbiA9PSBcInNlcGFyYXRlXCIgPyBwcm9wc0lmSW5wdXRIYW5kbGVzRm9jdXMgOiBwcm9wc0lucHV0O1xuXG4gICAgLy8gfTtcblxuICAgIC8vY29uc3QgdXNlUmFkaW9MYWJlbDogVXNlUmFkaW9MYWJlbDxJTD4gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy9jb25zdCB0YWcgPSB0YWdMYWJlbDtcbiAgICAvL2NvbnN0IHVzZVJhZGlvTGFiZWxQcm9wcyA9IChwcm9wc0xhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJTD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJTD4gPT4ge1xuICAgIC8vY29uc3QgeyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50KCk7XG4gICAgY29uc3QgcHJvcHNJZkxhYmVsSGFuZGxlc0ZvY3VzID0gdXNlTWVyZ2VkUHJvcHM8TGFiZWxFbGVtZW50PihsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgcHJvcHNMYWJlbCk7XG4gICAgY29uc3QgcHJvcHNMYWJlbDI6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4gPSBsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIiA/IHByb3BzSWZMYWJlbEhhbmRsZXNGb2N1cyBhcyBhbnkgOiBwcm9wc0xhYmVsIGFzIGFueVxuICAgIC8vfTtcblxuICAgIC8vcmV0dXJuIHtcbiAgICAvLyAgICB1c2VSYWRpb0xhYmVsUHJvcHNcbiAgICAvL31cbiAgICAvL30sIFt1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNoZWNrYm94TGlrZUlucHV0UmV0dXJuLFxuICAgICAgICBjaGVja2JveExpa2VMYWJlbFJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuLFxuICAgICAgICBwcmVzc0lucHV0UmV0dXJuLFxuICAgICAgICBwcmVzc0xhYmVsUmV0dXJuLFxuICAgICAgICBwcm9wc0lucHV0OiBwcm9wc0lucHV0MixcbiAgICAgICAgcHJvcHNMYWJlbDogcHJvcHNMYWJlbDIsXG4gICAgICAgIHJhbmRvbUlkSW5wdXRSZXR1cm4sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxSZXR1cm4sXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybixcbiAgICAgICAgcHJlc3NSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuLFxuICAgICAgICBjaGVja2JveExpa2VSZXR1cm5cbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCwgTWFuYWdlZENoaWxkSW5mbywgdXNlTWFuYWdlZENoaWxkLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQsIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUsIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIEV2ZW50RGV0YWlsLCBQcmVmaWNlcywgVGFnU2Vuc2l0aXZlUHJvcHMgfSBmcm9tIFwiLi9wcm9wc1wiO1xuXG5cblxuXG5leHBvcnQgdHlwZSBSYW5nZUNoYW5nZUV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSB7IFtFdmVudERldGFpbF06IHsgdmFsdWU6IG51bWJlciB9IH0gJiBQaWNrPGguSlNYLlRhcmdldGVkRXZlbnQ8RT4sIFwidGFyZ2V0XCIgfCBcImN1cnJlbnRUYXJnZXRcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGh1bWJJbmZvIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXI+IHtcbiAgICAvL3NldE1pbjogU3RhdGVVcGRhdGVyPG51bWJlcj47XG4gICAgLy9zZXRNYXg6IFN0YXRlVXBkYXRlcjxudW1iZXI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNsaWRlclRodW1iUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFNsaWRlclRodW1iSW5mbz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPE0+IHtcbiAgICBzbGlkZXJUaHVtYlBhcmFtZXRlcnM6IFRhZ1NlbnNpdGl2ZVByb3BzPEU+ICYge1xuICAgICAgICB2YWx1ZTogbnVtYmVyO1xuICAgICAgICB2YWx1ZVRleHQ/OiBzdHJpbmc7XG4gICAgICAgIG9uVmFsdWVDaGFuZ2U/OiAoZTogUmFuZ2VDaGFuZ2VFdmVudDxFPikgPT4gdm9pZDtcbiAgICAgICAgbWluPzogbnVtYmVyO1xuICAgICAgICBtYXg/OiBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZXJlJ3Mgbm8sIGxpa2UsIFwic2xpZGVyIGNvbnRhaW5lclwiIGZvciBtdWx0aS10aHVtYiBzbGlkZXJzIGRlZmluZWQsXG4gICAgICAgICAqIHNvIGVhY2ggaW5kaXZpZHVhbCBzbGlkZXIgbmVlZHMgaXRzIG93biBsYWJlbC5cbiAgICAgICAgICogVE9ETzogVGhpcyBpcyBsaWtlIGEgdGFiL3RhYnBhbmVsIGxpbmtpbmcgdGhpbmcgd2hlcmUgZWFjaCBsYWJlbCBpcyBvdXRzaWRlXG4gICAgICAgICAqIG9mIHRoZSBjb250YWluZXIuIEZvciBub3csIGl0J3MgZWFzaWVyIHRvIGp1c3QgXG4gICAgICAgICAqIGFzc3VtZSBhIHN0cmluZy1iYXNlZCBsYWJlbCBpbnN0ZWFkIG9mIGFuIGVsZW1lbnQtYmFzZWQgb25lLlxuICAgICAgICAgKiBcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgfVxuICAgIGNvbnRleHQ6IFNsaWRlckNvbnRleHQ8TT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU2xpZGVyVGh1bWJQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTbGlkZXJQYXJhbWV0ZXJzPE0gZXh0ZW5kcyBTbGlkZXJUaHVtYkluZm8+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxNPiB7XG4gICAgc2xpZGVyUGFyYW1ldGVyczoge1xuICAgICAgICBtaW46IG51bWJlcjtcbiAgICAgICAgbWF4OiBudW1iZXI7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNsaWRlclRodW1iUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFNsaWRlclRodW1iSW5mbz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0+IHtcbiAgICBzbGlkZXJUaHVtYlJldHVybjoge1xuICAgICAgICBtaW46IG51bWJlcjtcbiAgICAgICAgbWF4OiBudW1iZXI7XG4gICAgfVxuICAgIHByb3BzU2xpZGVyVGh1bWI6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xufVxuXG5cbmV4cG9ydCB0eXBlIFVzZVNsaWRlclRodW1iPFRodW1iRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBTbGlkZXJUaHVtYkluZm8+ID0gKHByb3BzOiBVc2VTbGlkZXJUaHVtYlBhcmFtZXRlcnM8VGh1bWJFbGVtZW50LCBNPikgPT4gVXNlU2xpZGVyVGh1bWJSZXR1cm5UeXBlPFRodW1iRWxlbWVudCwgTT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU2xpZGVyUmV0dXJuVHlwZTxNIGV4dGVuZHMgU2xpZGVyVGh1bWJJbmZvPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8TT4ge1xuICAgIGNvbnRleHQ6IFNsaWRlckNvbnRleHQ8TT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyQ29udGV4dDxNIGV4dGVuZHMgU2xpZGVyVGh1bWJJbmZvPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TT4ge1xuICAgIHNsaWRlckNvbnRleHQ6IHtcbiAgICAgICAgbWluOiBudW1iZXI7XG4gICAgICAgIG1heDogbnVtYmVyO1xuICAgICAgICBiYXNlSWQ6IHN0cmluZztcbiAgICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNsaWRlcih7IHNsaWRlclBhcmFtZXRlcnM6IHsgbWF4LCBtaW4gfSwgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyB9OiBVc2VTbGlkZXJQYXJhbWV0ZXJzPFNsaWRlclRodW1iSW5mbz4pOiBVc2VTbGlkZXJSZXR1cm5UeXBlPFNsaWRlclRodW1iSW5mbz4ge1xuICAgIGRlYnVnTG9nKFwidXNlU2xpZGVyXCIpO1xuICAgIGNvbnN0IHsgY29udGV4dCwgbWFuYWdlZENoaWxkcmVuUmV0dXJuIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48U2xpZGVyVGh1bWJJbmZvPih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMgfSk7XG5cbiAgICBjb25zdCBiYXNlSWRSZWYgPSB1c2VSZWY8c3RyaW5nPihudWxsISBhcyBcIlwiKTtcbiAgICBpZiAoYmFzZUlkUmVmLmN1cnJlbnQgPT09IG51bGwpXG4gICAgICAgIGJhc2VJZFJlZi5jdXJyZW50ID0gZ2VuZXJhdGVSYW5kb21JZChQcmVmaWNlcy5zbGlkZXJUaHVtYik7XG4gICAgLy9jb25zdCB7IHByb3BzUmVmZXJlbmNlciwgcHJvcHNTb3VyY2UsIHJhbmRvbUlkUmV0dXJuOiB7IGlkOiBiYXNlSWQgfSB9ID0gdXNlUmFuZG9tSWQ8TGFiZWxFbGVtZW50LCBUaHVtYkVsZW1lbnQ+KHsgcmFuZG9tSWRQYXJhbWV0ZXJzOiB7IHByZWZpeDogXCJhcmlhLXRodW1iLVwiLCBvdGhlclJlZmVyZW5jZXJQcm9wOiBcImFyaWEtbGFiZWxsZWRieVwiIH0gfSlcblxuICAgIC8qY29uc3Qge1xuICAgICAgICBwcm9wc0lucHV0LFxuICAgICAgICBwcm9wc0xhYmVsLFxuICAgICAgICByYW5kb21JZElucHV0UmV0dXJuLFxuICAgICAgICByYW5kb21JZExhYmVsUmV0dXJuXG4gICAgfSA9IHVzZUxhYmVsPFRodW1iRWxlbWVudCwgTGFiZWxFbGVtZW50Pih7IGxhYmVsUGFyYW1ldGVyczogeyBhcmlhTGFiZWw6IG51bGwgfSwgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMsIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzIH0pOyovXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgc2xpZGVyQ29udGV4dDoge1xuICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICAgICAgYmFzZUlkOiBiYXNlSWRSZWYuY3VycmVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgW21pbiwgbWF4XSksXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVyblxuICAgIH07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNsaWRlclRodW1iPFRodW1iRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBTbGlkZXJUaHVtYkluZm8+KHtcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIGNvbnRleHQ6IHsgc2xpZGVyQ29udGV4dDogeyBtYXg6IG1heFBhcmVudCwgbWluOiBtaW5QYXJlbnQgfSwgLi4uY29udGV4dCB9LFxuICAgIHNsaWRlclRodW1iUGFyYW1ldGVyc1xufTogVXNlU2xpZGVyVGh1bWJQYXJhbWV0ZXJzPFRodW1iRWxlbWVudCwgTT4pOiBVc2VTbGlkZXJUaHVtYlJldHVyblR5cGU8VGh1bWJFbGVtZW50LCBTbGlkZXJUaHVtYkluZm8+IHtcbiAgICBjb25zdCB7IGluZGV4IH0gPSBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzO1xuICAgIGRlYnVnTG9nKFwidXNlU2xpZGVyVGh1bWJcIiwgbWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleCk7XG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRSZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZDxTbGlkZXJUaHVtYkluZm8+KHsgbWFuYWdlZENoaWxkUGFyYW1ldGVycywgY29udGV4dCB9LCB7IGluZGV4IH0pO1xuICAgIGNvbnN0IHsgZ2V0Q2hpbGRyZW46IF9nZXRUaHVtYnMgfSA9IG1hbmFnZWRDaGlsZFJldHVybjtcblxuICAgIGNvbnN0IHsgdGFnLCB2YWx1ZSwgbWF4OiBtYXhPdmVycmlkZSwgbWluOiBtaW5PdmVycmlkZSwgb25WYWx1ZUNoYW5nZSwgdmFsdWVUZXh0LCBsYWJlbCB9ID0gc2xpZGVyVGh1bWJQYXJhbWV0ZXJzO1xuXG4gICAgY29uc3QgbWluID0gKG1pbk92ZXJyaWRlID8/IG1pblBhcmVudCk7XG4gICAgY29uc3QgbWF4ID0gKG1heE92ZXJyaWRlID8/IG1heFBhcmVudCk7XG5cbiAgICBsZXQgbmV3UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRodW1iRWxlbWVudD4gPSAoXG4gICAgICAgIHRhZyA9PSBcImlucHV0XCIgP1xuICAgICAgICAgICAgeyBtaW4sIG1heCwgdmFsdWUsIHR5cGU6IFwicmFuZ2VcIiB9IDpcbiAgICAgICAgICAgIHsgXCJhcmlhLXZhbHVlbWF4XCI6IGAke21heH1gLCBcImFyaWEtdmFsdWVtaW5cIjogYCR7bWlufWAsIFwiYXJpYS12YWx1ZW5vd1wiOiBgJHt2YWx1ZX1gIH1cbiAgICApO1xuICAgIG5ld1Byb3BzID0geyAuLi5uZXdQcm9wcywgXCJhcmlhLWxhYmVsXCI6IGxhYmVsLCBcImFyaWEtdmFsdWV0ZXh0XCI6IHZhbHVlVGV4dCwgc3R5bGU6IHsgXCItLXJhbmdlLXZhbHVlXCI6IGAke3ZhbHVlfWAsIFwiLS1yYW5nZS12YWx1ZS10ZXh0XCI6IGAke3ZhbHVlVGV4dH1gIH0gfTtcbiAgICBpZiAodGFnID09IFwiaW5wdXRcIikge1xuICAgICAgICBuZXdQcm9wcy5vbklucHV0ID0gZSA9PiB7XG4gICAgICAgICAgICBvblZhbHVlQ2hhbmdlPy4oeyBjdXJyZW50VGFyZ2V0OiBlLmN1cnJlbnRUYXJnZXQsIHRhcmdldDogZS50YXJnZXQsIFtFdmVudERldGFpbF06IHsgdmFsdWU6IChlLmN1cnJlbnRUYXJnZXQgYXMgRWxlbWVudCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZUFzTnVtYmVyIH0gfSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzbGlkZXJUaHVtYlJldHVybjoge1xuICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgbWF4XG4gICAgICAgIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgcHJvcHNTbGlkZXJUaHVtYjogbmV3UHJvcHNcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHtcbiAgICBDb21wYXJlLFxuICAgIENvbXBsZXRlR3JpZE5hdmlnYXRpb25Db250ZXh0LFxuICAgIENvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0LCBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZENlbGxJbmZvLCBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm8sIFBhc3NpdmVTdGF0ZVVwZGF0ZXIsIHJldHVybk51bGwsIHVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb24sXG4gICAgdXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGwsIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVycywgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlLCBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZSwgdXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvdywgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMsIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlLCB1c2VNZXJnZWRQcm9wcywgdXNlUGFzc2l2ZVN0YXRlLCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlT2JqZWN0XG59IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByZWZpY2VzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUxhYmVsU3ludGhldGljLCBVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcbmltcG9ydCB7IFVzZUxpc3Rib3hQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWxpc3Rib3hcIjtcblxuLy9leHBvcnQgdHlwZSBMaXN0Ym94U2luZ2xlU2VsZWN0RXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IHsgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfSB9ICYgUGljazxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+LCBcInRhcmdldFwiIHwgXCJjdXJyZW50VGFyZ2V0XCI+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlQ29udGV4dCB7XG4gICAgdGFibGVDb250ZXh0OiB7XG4gICAgICAgIHNldFNvcnRCb2R5RnVuY3Rpb246IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8KCkgPT4gdm9pZCwgbmV2ZXI+O1xuICAgICAgICBzb3J0QnlDb2x1bW4oY29sdW1uOiBudW1iZXIpOiBTb3J0SW5mbztcbiAgICAgICAgZ2V0Q3VycmVudFNvcnRDb2x1bW4oKTogU29ydEluZm87XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlU2VjdGlvbkNvbnRleHQ8VGFibGVTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIFRhYmxlUm93SW5mbzxUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88VGFibGVDZWxsRWxlbWVudD4+IGV4dGVuZHMgQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQ8VGFibGVTZWN0aW9uRWxlbWVudCwgVGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50LCBSTSwgQ00+LCBVc2VUYWJsZUNvbnRleHQge1xuXG4gICAgLy90YWJsZVNlY3Rpb25Db250ZXh0OiB7IHNvcnQ6IChjb2x1bW46IG51bWJlcikgPT4gU29ydEluZm87IH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVNlY3Rpb25QYXJhbWV0ZXJzPFRhYmxlU2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJsZVJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBUYWJsZVJvd0luZm88VGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50Pj4gZXh0ZW5kcyBPbWl0PFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFRhYmxlU2VjdGlvbkVsZW1lbnQsIFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCwgUk0+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXCIgfCBcInNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXCI+IHtcbiAgICB0YWJsZVNlY3Rpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgIGxvY2F0aW9uOiBcImhlYWRcIiB8IFwiYm9keVwiIHwgXCJmb290XCI7XG4gICAgICAgIHRhZ1RhYmxlU2VjdGlvbjogRWxlbWVudFRvVGFnPFRhYmxlU2VjdGlvbkVsZW1lbnQ+O1xuICAgIH1cbiAgICBjb250ZXh0OiBVc2VUYWJsZUNvbnRleHQ7XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlU2VjdGlvblJldHVyblR5cGU8VGFibGVTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIFRhYmxlUm93SW5mbzxUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88VGFibGVDZWxsRWxlbWVudD4+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxUYWJsZVNlY3Rpb25FbGVtZW50LCBUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwicHJvcHNcIj4ge1xuICAgIHByb3BzVGFibGVTZWN0aW9uOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZVNlY3Rpb25FbGVtZW50PjtcbiAgICBjb250ZXh0OiBVc2VUYWJsZVNlY3Rpb25Db250ZXh0PFRhYmxlU2VjdGlvbkVsZW1lbnQsIFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCwgUk0sIENNPjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVSb3dSZXR1cm5UeXBlPFRhYmxlUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIFRhYmxlUm93SW5mbzxUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88VGFibGVDZWxsRWxlbWVudD4+IGV4dGVuZHMgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGU8VGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50LCBSTSwgQ00+IHtcblxuICAgIGNvbnRleHQ6IFVzZVRhYmxlUm93Q29udGV4dDxhbnksIFRhYmxlQ2VsbEVsZW1lbnQsIENNPjtcblxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVJvd1BhcmFtZXRlcnM8VGFibGVSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgVGFibGVSb3dJbmZvPFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxUYWJsZUNlbGxFbGVtZW50Pj4ge1xuICAgIHJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzOiBPbWl0PFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCwgUk0sIENNPltcInJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzXCJdLCBcInNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzXCIgfCBcImNvbnRleHRcIj4gJiB7XG4gICAgICAgIGNvbnRleHQ6IFVzZVRhYmxlU2VjdGlvbkNvbnRleHQ8YW55LCBUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQsIFJNLCBDTT47XG4gICAgfTtcbiAgICByb3dBc1BhcmVudE9mQ2VsbHNQYXJhbWV0ZXJzOiBPbWl0PFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCwgUk0sIENNPltcInJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnNcIl0sIFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj47XG4gICAgdGFibGVSb3dQYXJhbWV0ZXJzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRoZSBgc2VsZWN0aW9uTGltaXRgIGlzIGBcInNpbmdsZVwiYCwgdGhpcyBtdXN0IGJlIGBudWxsYC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkOiBib29sZWFuIHwgbnVsbDtcbiAgICAgICAgdGFnVGFibGVSb3c6IEVsZW1lbnRUb1RhZzxUYWJsZVJvd0VsZW1lbnQ+O1xuICAgIH1cbn1cblxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlUm93Q29udGV4dDxUYWJsZVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFibGVSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFRhYmxlUm93SW5mbzxUYWJsZVJvd0VsZW1lbnQ+PiBleHRlbmRzIENvbXBsZXRlR3JpZE5hdmlnYXRpb25Db250ZXh0PFRhYmxlU2VjdGlvbkVsZW1lbnQsIFRhYmxlUm93RWxlbWVudCwgTT4ge31cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVSb3dDb250ZXh0PFRhYmxlUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxUYWJsZUNlbGxFbGVtZW50Pj4gZXh0ZW5kcyBDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93Q29udGV4dDxUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQsIE0+IHtcbiAgICB0YWJsZUNvbnRleHQ6IFVzZVRhYmxlQ29udGV4dFtcInRhYmxlQ29udGV4dFwiXTtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlQ2VsbFJldHVyblR5cGU8VGFibGVDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxUYWJsZUNlbGxFbGVtZW50Pj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGU8VGFibGVDZWxsRWxlbWVudCwgQ00+IHtcbiAgICB0YWJsZUNlbGxSZXR1cm46IHtcbiAgICAgICAgc29ydEJ5VGhpc0NvbHVtbigpOiBTb3J0SW5mbztcbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8VGFibGVDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxUYWJsZUNlbGxFbGVtZW50Pj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8VGFibGVDZWxsRWxlbWVudCwgQ00+IHtcbiAgICB0YWJsZUNlbGxQYXJhbWV0ZXJzOiB7XG4gICAgICAgIHRhZ1RhYmxlQ2VsbDogRWxlbWVudFRvVGFnPFRhYmxlQ2VsbEVsZW1lbnQ+O1xuICAgIH1cbiAgICBjb250ZXh0OiBVc2VUYWJsZVJvd0NvbnRleHQ8YW55LCBUYWJsZUNlbGxFbGVtZW50LCBDTT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVSb3dJbmZvPFRhYmxlUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkUm93SW5mbzxUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQ+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUNlbGxJbmZvPFRhYmxlQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm88VGFibGVDZWxsRWxlbWVudD4ge1xuICAgIGdldFNvcnRWYWx1ZSgpOiB1bmtub3duO1xuIH1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVBhcmFtZXRlcnM8VGFibGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGxhYmVsUGFyYW1ldGVyczogT21pdDxVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnNbXCJsYWJlbFBhcmFtZXRlcnNcIl0sIFwib25MYWJlbENsaWNrXCI+O1xuICAgIHRhYmxlUGFyYW1ldGVyczogUGljazxVc2VMaXN0Ym94UGFyYW1ldGVyczxUYWJsZUVsZW1lbnQsIGFueSwgTGFiZWxFbGVtZW50LCBhbnk+W1wibGlzdGJveFBhcmFtZXRlcnNcIl0sIFwic2VsZWN0aW9uTGltaXRcIj4gJiB7XG4gICAgICAgIHRhZ1RhYmxlOiBFbGVtZW50VG9UYWc8VGFibGVFbGVtZW50PjtcbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlUmV0dXJuVHlwZTxUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcHJvcHNUYWJsZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVFbGVtZW50PjtcbiAgICBwcm9wc0xhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xuICAgIGNvbnRleHQ6IFVzZVRhYmxlQ29udGV4dDtcbn1cblxuLy8gZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVNlY3Rpb25Db250ZXh0PFRhYmxlU2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJsZVJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVGFibGVSb3dJbmZvPFRhYmxlUm93RWxlbWVudD4+IGV4dGVuZHMgQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQ8VGFibGVTZWN0aW9uRWxlbWVudCwgVGFibGVSb3dFbGVtZW50LCBNPiB7IH1cblxuaW50ZXJmYWNlIFNvcnRJbmZvIHsgY29sdW1uOiBudW1iZXIsIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiIH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRhYmxlPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBsYWJlbFBhcmFtZXRlcnMsXG4gICAgdGFibGVQYXJhbWV0ZXJzOiB7IHNlbGVjdGlvbkxpbWl0LCB0YWdUYWJsZSB9LFxufTogVXNlVGFibGVQYXJhbWV0ZXJzPFRhYmxlRWxlbWVudCwgTGFiZWxFbGVtZW50Pik6IFVzZVRhYmxlUmV0dXJuVHlwZTxUYWJsZUVsZW1lbnQsIExhYmVsRWxlbWVudD4ge1xuICAgIGNvbnN0IFtnZXRTb3J0Qm9keSwgc2V0U29ydEJvZHldID0gdXNlUGFzc2l2ZVN0YXRlPCgpID0+IHZvaWQsIG5ldmVyPihudWxsLCByZXR1cm5OdWxsIGFzICgoKSA9PiBuZXZlcikpO1xuICAgIGNvbnN0IHNvcnRRdWV1ZSA9IHVzZVJlZjxudW1iZXJbXT4oW10pO1xuICAgIGNvbnN0IFtnZXRTb3J0Q29sdW1uLCBzZXRTb3J0Q29sdW1uXSA9IHVzZVBhc3NpdmVTdGF0ZTxTb3J0SW5mbywgRXZlbnQ+KHVzZUNhbGxiYWNrKChhOiBTb3J0SW5mbykgPT4geyBzb3J0UXVldWUuY3VycmVudC5wdXNoKGEuY29sdW1uKTsgfSwgW10pLCB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiB7IGNvbHVtbjogMCwgZGlyZWN0aW9uOiBcImFzY2VuZGluZ1wiIH0gYXMgY29uc3QgfSwgW10pKVxuICAgIGNvbnN0IHVwZGF0ZVNvcnREaXJlY3Rpb24gPSB1c2VDYWxsYmFjaygoY29sdW1uOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb2x1bW46IGN1cnJlbnRDb2x1bW4sIGRpcmVjdGlvbjogY3VycmVudERpcmVjdGlvbiB9ID0gZ2V0U29ydENvbHVtbigpO1xuICAgICAgICBjb25zdCBuZXh0ID0geyBjb2x1bW4sIGRpcmVjdGlvbjogY29sdW1uICE9IGN1cnJlbnRDb2x1bW4gPyBcImFzY2VuZGluZ1wiIDogKGN1cnJlbnREaXJlY3Rpb24gPT0gXCJhc2NlbmRpbmdcIiA/IFwiZGVzY2VuZGluZ1wiIDogXCJhc2NlbmRpbmdcIikgfSBhcyBjb25zdDtcbiAgICAgICAgc2V0U29ydENvbHVtbihuZXh0KTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHNvcnRCeUNvbHVtbiA9IHVzZUNhbGxiYWNrKChjb2x1bW46IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBuZXh0ID0gdXBkYXRlU29ydERpcmVjdGlvbihjb2x1bW4pO1xuICAgICAgICBnZXRTb3J0Qm9keSgpPy4oKTtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSwgW10pXG4gICAgLy9jb25zdCB7IHRhZ0lucHV0OiB0YWdUYWJsZSB9ID0gbGFiZWxQYXJhbWV0ZXJzXG4gICAgY29uc3Qge1xuICAgICAgICBwcm9wc0lucHV0OiBwcm9wc0xhYmVsTGlzdCxcbiAgICAgICAgcHJvcHNMYWJlbDogcHJvcHNMYWJlbExhYmVsXG4gICAgfSA9IHVzZUxhYmVsU3ludGhldGljPFRhYmxlRWxlbWVudCwgTGFiZWxFbGVtZW50Pih7XG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczogeyAuLi5sYWJlbFBhcmFtZXRlcnMsIG9uTGFiZWxDbGljazogbnVsbCB9LFxuICAgICAgICByYW5kb21JZElucHV0UGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLnRhYmxlIH0sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzOiB7IHByZWZpeDogUHJlZmljZXMudGFibGVMYWJlbCB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wc1RhYmxlOiB1c2VNZXJnZWRQcm9wcyh7IHJvbGU6IHRhZ1RhYmxlID09IFwidGFibGVcIiA/IHVuZGVmaW5lZCA6IFwiZ3JpZFwiLCBcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCI6IChzZWxlY3Rpb25MaW1pdCA9PSBcIm11bHRpXCIgPyBcInRydWVcIiA6IHVuZGVmaW5lZCkgfSwgcHJvcHNMYWJlbExpc3QpLFxuICAgICAgICBwcm9wc0xhYmVsOiBwcm9wc0xhYmVsTGFiZWwsXG4gICAgICAgIGNvbnRleHQ6ICh7IHRhYmxlQ29udGV4dDogKHsgc29ydEJ5Q29sdW1uLCBzZXRTb3J0Qm9keUZ1bmN0aW9uOiBzZXRTb3J0Qm9keSwgZ2V0Q3VycmVudFNvcnRDb2x1bW46IGdldFNvcnRDb2x1bW4gfSkgfSlcbiAgICB9XG59XG5jb25zdCBuYXR1cmFsU2VjdGlvblR5cGVzID0gbmV3IFNldDxrZXlvZiBoLkpTWC5JbnRyaW5zaWNFbGVtZW50cz4oW1widGhlYWRcIiwgXCJ0Ym9keVwiLCBcInRmb290XCJdKTtcbmV4cG9ydCBmdW5jdGlvbiB1c2VUYWJsZVNlY3Rpb248VGFibGVTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIFRhYmxlUm93SW5mbzxUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88VGFibGVDZWxsRWxlbWVudD4+KHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyxcbiAgICBncmlkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICB0YWJsZVNlY3Rpb25QYXJhbWV0ZXJzOiB7IHRhZ1RhYmxlU2VjdGlvbiwgbG9jYXRpb24gfSxcbiAgICBjb250ZXh0OiB7IHRhYmxlQ29udGV4dCB9XG59OiBVc2VUYWJsZVNlY3Rpb25QYXJhbWV0ZXJzPFRhYmxlU2VjdGlvbkVsZW1lbnQsIFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCwgUk0+KTogVXNlVGFibGVTZWN0aW9uUmV0dXJuVHlwZTxUYWJsZVNlY3Rpb25FbGVtZW50LCBUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQsIFJNLCBDTT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVyblxuICAgIH0gPSB1c2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uPFRhYmxlU2VjdGlvbkVsZW1lbnQsIFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCwgUk0sIENNPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBjb21wYXJlOiB1c2VDYWxsYmFjazxDb21wYXJlPFJNPj4oKGxocywgcmhzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICsobGhzLmdldFNvcnRWYWx1ZSgpIGFzIG51bWJlcikgLSArKHJocy5nZXRTb3J0VmFsdWUoKSBhcyBudW1iZXIpO1xuICAgICAgICAgICAgfSwgW10pXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IG5vVHlwZWFoZWFkOiB0cnVlLCBjb2xsYXRvcjogbnVsbCwgdHlwZWFoZWFkVGltZW91dDogSW5maW5pdHkgfSxcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXG4gICAgfSk7XG5cbiAgICBpZiAoIW5hdHVyYWxTZWN0aW9uVHlwZXMuaGFzKHRhZ1RhYmxlU2VjdGlvbiBhcyBhbnkpKSB7XG4gICAgICAgIHByb3BzLnJvbGUgPSBcInJvd2dyb3VwXCI7XG4gICAgfVxuXG5cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PSBcImJvZHlcIikge1xuICAgICAgICAgICAgdGFibGVDb250ZXh0LnNldFNvcnRCb2R5RnVuY3Rpb24oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hbmFnZWRSb3dzID0gbWFuYWdlZENoaWxkcmVuUmV0dXJuLmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm4uc29ydChtYW5hZ2VkUm93cywgdGFibGVDb250ZXh0LmdldEN1cnJlbnRTb3J0Q29sdW1uKCkuZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLypjb25zdCBzb3J0ID0gdXNlQ2FsbGJhY2soKGNvbHVtbjogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHJldCA9IHRhYmxlQ29udGV4dC51cGRhdGVTb3J0RGlyZWN0aW9uKGNvbHVtbilcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVybi5zb3J0KG1hbmFnZWRDaGlsZHJlblJldHVybi5nZXRDaGlsZHJlbigpLCByZXQuZGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LCBbXSkqL1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgICAgICB0YWJsZUNvbnRleHRcbiAgICAgICAgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIHByb3BzVGFibGVTZWN0aW9uOiBwcm9wc1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRhYmxlUm93PFRhYmxlUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIFRhYmxlUm93SW5mbzxUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88VGFibGVDZWxsRWxlbWVudD4+KHtcbiAgICByb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyczoge1xuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgICAgICBjb250ZXh0OiBjeDFcbiAgICB9LFxuICAgIHJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc1xuICAgIH0sXG4gICAgdGFibGVSb3dQYXJhbWV0ZXJzOiB7IHNlbGVjdGVkIH1cbn06IFVzZVRhYmxlUm93UGFyYW1ldGVyczxUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQsIFJNLCBDTT4pOiBVc2VUYWJsZVJvd1JldHVyblR5cGU8VGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50LCBSTSwgQ00+IHtcbiAgICBjb25zdCB7XG4gICAgICAgIGNvbnRleHQ6IGN4MixcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuLFxuICAgICAgICByb3dBc0NoaWxkT2ZHcmlkUmV0dXJuLFxuICAgICAgICByb3dBc1BhcmVudE9mQ2VsbHNSZXR1cm4sXG4gICAgICAgIHByb3BzXG4gICAgfSA9IHVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3c8VGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50LCBSTSwgQ00+KHtcbiAgICAgICAgcm93QXNDaGlsZE9mR3JpZFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvbnRleHQ6IHsgLi4uY3gxIH0sXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgZ2V0U29ydFZhbHVlOiB1c2VDYWxsYmFjaygoKTogdW5rbm93biA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb2x1bW4gPSBjeDEudGFibGVDb250ZXh0LmdldEN1cnJlbnRTb3J0Q29sdW1uKCkuY29sdW1uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2hpbGQgPSByb3dBc1BhcmVudE9mQ2VsbHNSZXR1cm4ubWFuYWdlZENoaWxkcmVuUmV0dXJuLmdldENoaWxkcmVuKCkuZ2V0QXQoY3VycmVudENvbHVtbiA/PyAwKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0VmFsdWUgPSBjdXJyZW50Q2hpbGQ/LmdldFNvcnRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ydFZhbHVlO1xuICAgICAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByb3dBc1BhcmVudE9mQ2VsbHNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IG5vVHlwZWFoZWFkOiB0cnVlLCBjb2xsYXRvcjogbnVsbCwgdHlwZWFoZWFkVGltZW91dDogSW5maW5pdHkgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcm9wcy5yb2xlID0gXCJncmlkcm93XCI7XG4gICAgaWYgKHNlbGVjdGVkKVxuICAgICAgICBwcm9wc1tzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMuYXJpYVByb3BOYW1lID8/IFwiYXJpYS1zZWxlY3RlZFwiXSA9IFwidHJ1ZVwiO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm93QXNDaGlsZE9mR3JpZFJldHVybixcbiAgICAgICAgcm93QXNQYXJlbnRPZkNlbGxzUmV0dXJuLFxuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAuLi5jeDIsXG4gICAgICAgICAgICB0YWJsZUNvbnRleHQ6IGN4MS50YWJsZUNvbnRleHRcbiAgICAgICAgfSxcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuLFxuICAgICAgICBwcm9wc1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRhYmxlQ2VsbDxUYWJsZUNlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ00gZXh0ZW5kcyBUYWJsZUNlbGxJbmZvPFRhYmxlQ2VsbEVsZW1lbnQ+Pih7IHRhYmxlQ2VsbFBhcmFtZXRlcnM6IHsgdGFnVGFibGVDZWxsIH0sIC4uLnAgfTogVXNlVGFibGVDZWxsUGFyYW1ldGVyczxUYWJsZUNlbGxFbGVtZW50LCBDTT4pOiBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlPFRhYmxlQ2VsbEVsZW1lbnQsIENNPiB7XG4gICAgY29uc3QgcmV0ID0gdXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGw8VGFibGVDZWxsRWxlbWVudCwgQ00+KHApO1xuICAgIGlmICghKHRhZ1RhYmxlQ2VsbCA9PSBcInRoXCIgfHwgdGFnVGFibGVDZWxsID09IFwidGRcIikpIHtcbiAgICAgICAgcmV0LnByb3BzLnJvbGUgPSBcImdyaWRjZWxsXCJcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmV0LFxuICAgICAgICB0YWJsZUNlbGxSZXR1cm46IHtcbiAgICAgICAgICAgIHNvcnRCeVRoaXNDb2x1bW46IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5jb250ZXh0LnRhYmxlQ29udGV4dC5zb3J0QnlDb2x1bW4ocC5tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLmluZGV4KTtcbiAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8qXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlU2VjdGlvblNlY3Rpb25QYXJhbWV0ZXJzIHtcbiAgICBncmlkbGlzdFNlY3Rpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgIGNvbXBhcmVSb3dzOiAobGhzSW5kZXg6IG51bWJlciwgcmhzSW5kZXg6IG51bWJlcikgPT4gbnVtYmVyO1xuICAgIH1cbiAgICBncmlkbGlzdFNlY3Rpb25Db250ZXh0OiB7XG5cbiAgICB9XG59Ki9cbi8qXG5leHBvcnQgY29uc3QgdXNlVGFibGVTZWN0aW9uU2VjdGlvbiA9IDxCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBjb21wYXJlUm93cyB9OiBVc2VUYWJsZVNlY3Rpb25TZWN0aW9uUGFyYW1ldGVycykgPT4ge1xuICAgIC8vZGVidWdMb2coXCJ1c2VUYWJsZVNlY3Rpb25TZWN0aW9uXCIpO1xuICAgIC8vdHlwZSBDUkZ1bGwgPSBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Um93RWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPFVzZVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudCwgQ1IsIENDPj4+O1xuICAgIGNvbnN0IGdldEluZGV4ID0gdXNlQ2FsbGJhY2s8R2V0SW5kZXg8YW55Pj4oKGkpID0+IGkucHJvcHMuaW5kZXgsIFtdKTtcblxuXG4gICAgY29uc3Qge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuXG4gICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48Qm9keVNlY3Rpb25FbGVtZW50LCBUYWJsZVJvd0luZm88Um93RWxlbWVudD4+KHtcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZ2V0SW5kZXgsXG4gICAgICAgICAgICBnZXRIaWdoZXN0Q2hpbGRJbmRleCxcbiAgICAgICAgICAgIGdldFZhbGlkXG4gICAgICAgIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBjb21wYXJlOiAobGhzLCByaHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobGhzLmxvY2F0aW9uSW5kZXggPT09IHJocy5sb2NhdGlvbkluZGV4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZVJvd3MobGhzLmluZGV4LCByaHMuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaHMubG9jYXRpb25JbmRleCAtIHJocy5sb2NhdGlvbkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VUYWJsZVNlY3Rpb25TZWN0aW9uUHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4pID0+IHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQocHJvcHMuY2hpbGRyZW4gIT0gbnVsbCk7XG4gICAgICAgIG92ZXJ3cml0ZVdpdGhXYXJuaW5nKFwidXNlVGFibGVTZWN0aW9uU2VjdGlvblwiLCBwcm9wcywgXCJyb2xlXCIsIFwicm93Z3JvdXBcIik7XG4gICAgICAgIHJldHVybiB1c2VTb3J0YWJsZVByb3BzKHByb3BzIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4gJiB7IGNoaWxkcmVuOiBhbnkgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlVGFibGVTZWN0aW9uU2VjdGlvblByb3BzLFxuICAgICAgICAuLi5zb3J0YWJsZVJldFxuICAgIH1cbn0qL1xuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNvbnRleHQsIGdlbmVyYXRlUmFuZG9tSWQsIE1hbmFnZWRDaGlsZEluZm8sIE9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIFBhc3NpdmVTdGF0ZVVwZGF0ZXIsIHJldHVyblRydWUsIHVzZUNoaWxkcmVuRmxhZywgdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbiwgdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGUsIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm8sIHVzZU1hbmFnZWRDaGlsZCwgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0LCB1c2VNZXJnZWRQcm9wcywgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZU9iamVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZGVidWdMb2csIEV2ZW50RGV0YWlsLCBQcmVmaWNlcyB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZUxhYmVsU3ludGhldGljLCBVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcclxuaW1wb3J0IHsgVXNlTGlzdGJveFBhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtbGlzdGJveFwiO1xyXG5cclxuXHJcbmludGVyZmFjZSBUYWJQYW5lbEluZm8gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlcj4ge1xyXG4gICAgZ2V0VmlzaWJsZSgpOiBib29sZWFuO1xyXG4gICAgc2V0VmlzaWJsZTogU3RhdGVVcGRhdGVyPGJvb2xlYW4+O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVGFiSW5mbzxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2hpbGRJbmZvPEU+IHsgfVxyXG5cclxuXHJcbmV4cG9ydCB0eXBlIFRhYnNDaGFuZ2VFdmVudDxFIGV4dGVuZHMgRWxlbWVudD4gPSB7IFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogbnVtYmVyIH0gfSAmIFBpY2s8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPiwgXCJ0YXJnZXRcIiB8IFwiY3VycmVudFRhcmdldFwiPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFic1BhcmFtZXRlcnM8VGFiQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQ+IHtcclxuICAgIC8vdGFiUGFuZWxzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFRhYlBhbmVsSW5mbz47XHJcbiAgICBsYWJlbFBhcmFtZXRlcnM6IE9taXQ8VXNlTGFiZWxTeW50aGV0aWNQYXJhbWV0ZXJzW1wibGFiZWxQYXJhbWV0ZXJzXCJdLCBcIm9uTGFiZWxDbGlja1wiPjtcclxuICAgIHRhYnNQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgb3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiO1xyXG4gICAgICAgIHJvbGU/OiBcInRhYmxpc3RcIiB8IHN0cmluZztcclxuICAgICAgICBncm91cGluZ1R5cGU6IFBpY2s8VXNlTGlzdGJveFBhcmFtZXRlcnM8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudCwgVGFiTGFiZWxFbGVtZW50LCBUYWJJbmZvPFRhYkVsZW1lbnQ+PltcImxpc3Rib3hQYXJhbWV0ZXJzXCJdLCBcImdyb3VwaW5nVHlwZVwiPltcImdyb3VwaW5nVHlwZVwiXVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8VGFiRWxlbWVudCwgVGFiSW5mbzxUYWJFbGVtZW50PiwgbmV2ZXI+LCBcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiPiB7XHJcbiAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IE9taXQ8VXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxUYWJFbGVtZW50LCBUYWJJbmZvPFRhYkVsZW1lbnQ+LCBuZXZlcj5bXCJzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnNcIl0sIFwiYXJpYVByb3BOYW1lXCI+O1xyXG4gICAgY29udGV4dDogVGFic0NvbnRleHQ8YW55LCBUYWJFbGVtZW50LCBUYWJJbmZvPFRhYkVsZW1lbnQ+PjtcclxuICAgIC8vIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiUGFuZWxQYXJhbWV0ZXJzIGV4dGVuZHMgT21pdDxVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPFRhYlBhbmVsSW5mbz4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPiB7XHJcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBPbWl0PFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8VGFiUGFuZWxJbmZvPltcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIl0sIFwiZ2V0VmlzaWJsZVwiIHwgXCJzZXRWaXNpYmxlXCI+XHJcbiAgICBjb250ZXh0OiBUYWJQYW5lbHNDb250ZXh0PFRhYlBhbmVsSW5mbz47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFic0NvbnRleHQ8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBUYWJJbmZvPENoaWxkRWxlbWVudD4+IGV4dGVuZHMgQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNvbnRleHQ8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPiB7XHJcbiAgICB0YWJzQ29udGV4dDogVEM7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFiUGFuZWxzQ29udGV4dDxNIGV4dGVuZHMgVGFiUGFuZWxJbmZvPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TT4ge1xyXG4gICAgdGFiUGFuZWxDb250ZXh0OiBUQztcclxufVxyXG5cclxuaW50ZXJmYWNlIFRDIHtcclxuICAgIGdldFZpc2libGVJbmRleDogKCkgPT4gbnVtYmVyIHwgbnVsbDtcclxuICAgIGdldFBhbmVsSWQ6IChpbmRleDogbnVtYmVyKSA9PiBzdHJpbmc7XHJcbiAgICBnZXRUYWJJZDogKGluZGV4OiBudW1iZXIpID0+IHN0cmluZztcclxuICAgIHNldFNlbGVjdGVkSW5kZXg6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbCwgRXZlbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlJldHVyblR5cGU8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxUYWJFbGVtZW50LCBUYWJJbmZvPFRhYkVsZW1lbnQ+PiB7IH1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYkxhYmVsUGFyYW1ldGVycyB7IH1cclxuaW50ZXJmYWNlIFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkNvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkluZm88VGFiRWxlbWVudD4+LCBcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+IHtcclxuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkluZm88VGFiRWxlbWVudD4+W1wibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIl0sIFwibmF2aWdhdGlvbkRpcmVjdGlvblwiPjtcclxuICAgIC8vdGFiczogeyBvblNlbGVjdGVkSW5kZXhDaGFuZ2UoZTogRW5oYW5jZWRFdmVudDxUYWJFbGVtZW50LCBFdmVudCwgeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfT4pOiB2b2lkOyB9O1xyXG4gICAgLy9jaGlsZHJlbkhhdmVGb2N1czogVXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzW1wiY2hpbGRyZW5IYXZlRm9jdXNcIl07XHJcbiAgICAvL3RhYnNDb250ZXh0OiBUYWJzQ29udGV4dDtcclxuXHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJMaXN0UmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIFRhYkluZm88Q2hpbGRFbGVtZW50Pj4ge1xyXG59XHJcblxyXG4vKlxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYkxpc3RSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYkNvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVEMsIFRLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZVRhYkxpc3RSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50LCBUQz4ge1xyXG4gICAgdXNlVGFiTGlzdFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkNvbnRhaW5lckVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJDb250YWluZXJFbGVtZW50PjtcclxuICAgIHVzZVRhYjogKHsgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXggfTogVXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50LCBUQywgVEssIFRDPikgPT4gVXNlVGFiUmV0dXJuVHlwZVdpdGhIb29rczxUYWJFbGVtZW50PlxyXG59Ki9cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlBhbmVsUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xyXG4gICAgdGFiUGFuZWxSZXR1cm46IHsgdmlzaWJsZTogYm9vbGVhbjsgZ2V0VmlzaWJsZTogKCkgPT4gYm9vbGVhbjsgfTtcclxufVxyXG4vKmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiUGFuZWxSZXR1cm5UeXBlV2l0aEhvb2tzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB1c2VUYWJQYW5lbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XHJcbn0qL1xyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiTGlzdExhYmVsUmV0dXJuVHlwZUluZm8geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiTGFiZWxSZXR1cm5UeXBlV2l0aEhvb2tzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFiTGlzdExhYmVsUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlVGFiTGlzdExhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJzUmV0dXJuVHlwZTxUYWJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcclxuICAgIHByb3BzQ29udGFpbmVyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJDb250YWluZXJFbGVtZW50PjtcclxuICAgIHByb3BzTGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XHJcbiAgICBjb250ZXh0UGFuZWxzOiBUYWJQYW5lbHNDb250ZXh0PFRhYlBhbmVsSW5mbz47IC8veyB0YWJQYW5lbENvbnRleHQ6IFRhYlBhbmVsc0NvbnRleHQ8VGFiUGFuZWxJbmZvPiB9ICYgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxUYWJQYW5lbEluZm8+O1xyXG4gICAgY29udGV4dFRhYnM6IFRhYnNDb250ZXh0PFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkluZm88VGFiRWxlbWVudD4+OyAvL3sgdGFiQ29udGV4dDogVGFic0NvbnRleHQ8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudCwgVGFiSW5mbzxUYWJFbGVtZW50Pj4gfSAmIENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0PFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkluZm88VGFiRWxlbWVudD4+O1xyXG4gICAgLy9jb250ZXh0UGFuZWxzOiBUYWJQYW5lbENvbnRleHQ7XHJcbiAgICAvL2NvbnRleHRUYWI6IFRhYkNvbnRleHQ7XHJcbiAgICAvLyBtYW5hZ2VkQ2hpbGRyZW5Db250ZXh0UGFuZWxzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPFRhYlBhbmVsSW5mbz5bXCJtYW5hZ2VkQ2hpbGRDb250ZXh0XCJdO1xyXG59XHJcblxyXG4vKmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFic1JldHVyblR5cGVXaXRoSG9va3M8VGFiQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUQywgUEMsIFRLIGV4dGVuZHMgc3RyaW5nLCBQSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VUYWJzUmV0dXJuVHlwZUluZm88UEM+IHtcclxuICAgIHVzZVRhYkxpc3Q6IFVzZVRhYkxpc3Q8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudCwgVEMsIFRLPjtcclxuICAgIHVzZVRhYlBhbmVsOiBVc2VUYWJQYW5lbDxQYW5lbEVsZW1lbnQsIFBDLCBQSz47XHJcbiAgICB1c2VUYWJMaXN0TGFiZWw6IFVzZVRhYkxpc3RMYWJlbDxMYWJlbEVsZW1lbnQ+O1xyXG59Ki9cclxuXHJcbmV4cG9ydCB0eXBlIFVzZVRhYjxfVGFiQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+KSA9PiBVc2VUYWJSZXR1cm5UeXBlPFRhYkVsZW1lbnQ+O1xyXG5leHBvcnQgdHlwZSBVc2VUYWJMaXN0PFRhYkNvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudD4pID0+IFVzZVRhYkxpc3RSZXR1cm5UeXBlPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQ+O1xyXG5leHBvcnQgdHlwZSBVc2VUYWJQYW5lbDxQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VUYWJQYW5lbFBhcmFtZXRlcnMpID0+IFVzZVRhYlBhbmVsUmV0dXJuVHlwZTxQYW5lbEVsZW1lbnQ+O1xyXG5leHBvcnQgdHlwZSBVc2VUYWJMaXN0TGFiZWw8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlVGFiTGFiZWxQYXJhbWV0ZXJzKSA9PiBVc2VUYWJMYWJlbFJldHVyblR5cGVXaXRoSG9va3M8TGFiZWxFbGVtZW50PjtcclxuLypcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRhYnM8VGFiTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWJQYW5lbHM6IHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogb2NtYywgLi4udGFiUGFuZWxzTWFuYWdlZENoaWxkcmVuIH0gfSB9OiBVc2VUYWJzUGFyYW1ldGVycyk6IFVzZVRhYnNSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYkxpc3RFbGVtZW50LCBUYWJFbGVtZW50LCBQYW5lbEVsZW1lbnQsIExhYmVsRWxlbWVudD4ge1xyXG4gICAgY29uc3QgeyBcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLCBcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzIFxyXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFRhYkxpc3RFbGVtZW50LCBUYWJFbGVtZW50LCBUYWJJbmZvLCBuZXZlcj4oeyBcclxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1czoge30sIFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LCBcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjoge30sIFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjoge30sIFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7fSwgXHJcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7fSwgXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge31cclxuICAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VUYWIgPSB1c2VDYWxsYmFjaygoKSA9PiB7fSwgW10pO1xyXG4gICAgY29uc3QgdXNlVGFiUGFuZWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7fSk7XHJcbiAgICBmdW5jdGlvbiB1c2VUYWJMaXN0UHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkxpc3RFbGVtZW50PikgeyByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyhwcm9wcyk7IH1cclxuICAgIGZ1bmN0aW9uIHVzZVRhYkxhYmVsUHJvcHMoKSB7fVxyXG5cclxuICAgIHJldHVybiB7XHJcblxyXG4gICAgfVxyXG4gICAgXHJcbn0qL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRhYnM8VGFiTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgbGFiZWxQYXJhbWV0ZXJzLFxyXG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXHJcbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxyXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxyXG4gICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogeyBzZXRTZWxlY3RlZEluZGV4OiBzc2ksIC4uLnNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMgfSxcclxuICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMsXHJcbiAgICB0YWJzUGFyYW1ldGVyczogeyBvcmllbnRhdGlvbiwgcm9sZSB9XHJcbiAgICAvLyB0YWJQYW5lbHM6IHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogb2NtYywgLi4udGFiUGFuZWxzTWFuYWdlZENoaWxkcmVuIH0gfSBcclxufTogVXNlVGFic1BhcmFtZXRlcnM8VGFiTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIExhYmVsRWxlbWVudD4pOiBVc2VUYWJzUmV0dXJuVHlwZTxUYWJMaXN0RWxlbWVudCwgVGFiRWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XHJcblxyXG4gICAgZGVidWdMb2coXCJ1c2VUYWJzXCIpO1xyXG5cclxuXHJcbiAgICBjb25zdCBiYXNlSWQgPSBnZW5lcmF0ZVJhbmRvbUlkKFwiYXJpYS10YWJzLVwiKTtcclxuICAgIC8vY29uc3QgZ2V0VGFiTGlzdElkID0gdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gYmFzZUlkICsgXCItdGFiLWxpc3RcIjsgfSwgW10pO1xyXG4gICAgY29uc3QgZ2V0VGFiSWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4geyByZXR1cm4gYmFzZUlkICsgXCItdGFiLVwiICsgaW5kZXg7IH0sIFtdKTtcclxuICAgIGNvbnN0IGdldFBhbmVsSWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4geyByZXR1cm4gYmFzZUlkICsgXCItcGFuZWwtXCIgKyBpbmRleDsgfSwgW10pO1xyXG5cclxuICAgIC8vIFVzZWQgZm9yIHRoZSBwYW5lbHMsIG5vdCB0aGUgdGFicyBpbiB0aGUgdGFibGlzdC5cclxuICAgIC8vIFRob3NlIGFyZSBpbiB1c2VUYWJMaXN0IGl0c2VsZi5cclxuICAgIGNvbnN0IHsgY29udGV4dDogbWFuYWdlZENoaWxkQ29udGV4dCwgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBwYW5lbENoaWxkcmVuUmV0dXJuIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48VGFiUGFuZWxJbmZvPih7XHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczoge1xyXG5cclxuICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPbkNoaWxkcmVuTW91bnRDaGFuZ2U8bnVtYmVyPj4oKF9tLCBfdSkgPT4geyByZWV2YWx1YXRlQ2xvc2VzdEZpdCgpOyB9KVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXg6IGNoYW5nZVZpc2libGVQYW5lbCwgZ2V0Q3VycmVudEluZGV4OiBnZXRWaXNpYmxlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0IH0gPSB1c2VDaGlsZHJlbkZsYWc8VGFiUGFuZWxJbmZvLCBFdmVudD4oe1xyXG4gICAgICAgIGdldENoaWxkcmVuOiBwYW5lbENoaWxkcmVuUmV0dXJuLmdldENoaWxkcmVuLFxyXG4gICAgICAgIGNsb3Nlc3RGaXQ6IGZhbHNlLFxyXG4gICAgICAgIGluaXRpYWxJbmRleDogbnVsbCxcclxuICAgICAgICBnZXRBdDogdXNlU3RhYmxlQ2FsbGJhY2soKGkpID0+IHsgcmV0dXJuIGkuZ2V0VmlzaWJsZSgpID8/IGZhbHNlOyAvKmdldFBhbmVscygpLmdldEF0KGkpPy5nZXRWaXNpYmxlKCkgPz8gZmFsc2UpKi8gfSwgW10pLFxyXG4gICAgICAgIHNldEF0OiB1c2VTdGFibGVDYWxsYmFjaygoaSwgYikgPT4geyByZXR1cm4gaS5zZXRWaXNpYmxlKGIpOyAvKihnZXRQYW5lbHMoKS5nZXRBdChpKT8uc2V0VmlzaWJsZShiKSk7Ki8gfSwgW10pLFxyXG4gICAgICAgIGlzVmFsaWQ6IHJldHVyblRydWUsXHJcbiAgICAgICAgb25JbmRleENoYW5nZTogbnVsbFxyXG4gICAgfSk7XHJcblxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjaGFuZ2VWaXNpYmxlUGFuZWwoc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycy5pbml0aWFsbHlTZWxlY3RlZEluZGV4KTtcclxuICAgIH0sIFtdKVxyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICBwcm9wc0lucHV0LFxyXG4gICAgICAgIHByb3BzTGFiZWwsXHJcbiAgICAgICAgcmFuZG9tSWRJbnB1dFJldHVybjogeyBpZDogX2lucHV0SWQgfSxcclxuICAgICAgICByYW5kb21JZExhYmVsUmV0dXJuOiB7IGlkOiBfbGFiZWxJZCB9LFxyXG4gICAgfSA9IHVzZUxhYmVsU3ludGhldGljPFRhYkxpc3RFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcclxuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHsgLi4ubGFiZWxQYXJhbWV0ZXJzLCBvbkxhYmVsQ2xpY2s6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IGxpc3ROYXZSZXQxLnJvdmluZ1RhYkluZGV4UmV0dXJuLmZvY3VzU2VsZigpKSB9LFxyXG4gICAgICAgIHJhbmRvbUlkSW5wdXRQYXJhbWV0ZXJzOiB7IHByZWZpeDogUHJlZmljZXMudGFibGlzdCB9LFxyXG4gICAgICAgIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzOiB7IHByZWZpeDogUHJlZmljZXMudGFibGlzdExhYmVsIH0sXHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHByb3BzOiBsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzLFxyXG4gICAgICAgIGNvbnRleHQsXHJcbiAgICAgICAgLi4ubGlzdE5hdlJldDFcclxuICAgIH0gPSB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uPFRhYkxpc3RFbGVtZW50LCBUYWJFbGVtZW50LCBUYWJJbmZvPFRhYkVsZW1lbnQ+Pih7XHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgbmF2aWdhdGlvbkRpcmVjdGlvbjogb3JpZW50YXRpb24sIC4uLmxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxyXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IHtcclxuICAgICAgICAgICAgc2V0U2VsZWN0ZWRJbmRleDogdXNlU3RhYmxlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsLCBFdmVudD4+KChpLCBwKSA9PiB7IHNzaT8uKGksIHApOyBjaGFuZ2VWaXNpYmxlUGFuZWwoaSk7IGxpc3ROYXZSZXQxLnNpbmdsZVNlbGVjdGlvblJldHVybi5zZXRTZWxlY3RlZEluZGV4KGksIHApOyB9KSxcclxuICAgICAgICAgICAgLi4uc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyc1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMsXHJcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcclxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1xyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHsgc2luZ2xlU2VsZWN0aW9uUmV0dXJuOiB7IHNldFNlbGVjdGVkSW5kZXggfSB9ID0gbGlzdE5hdlJldDE7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjb250ZXh0UGFuZWxzOiB1c2VTdGFibGVPYmplY3Qoe1xyXG4gICAgICAgICAgICAuLi5tYW5hZ2VkQ2hpbGRDb250ZXh0LFxyXG4gICAgICAgICAgICB0YWJQYW5lbENvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XHJcbiAgICAgICAgICAgICAgICBnZXRQYW5lbElkLFxyXG4gICAgICAgICAgICAgICAgZ2V0VGFiSWQsXHJcbiAgICAgICAgICAgICAgICBnZXRWaXNpYmxlSW5kZXgsXHJcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgY29udGV4dFRhYnM6IHVzZVN0YWJsZU9iamVjdCh7XHJcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXHJcbiAgICAgICAgICAgIHRhYnNDb250ZXh0OiB1c2VTdGFibGVPYmplY3QoeyBnZXRUYWJJZCwgZ2V0UGFuZWxJZCwgZ2V0VmlzaWJsZUluZGV4LCBzZXRTZWxlY3RlZEluZGV4IH0pXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgcHJvcHNDb250YWluZXI6IHVzZU1lcmdlZFByb3BzKFxyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzLFxyXG4gICAgICAgICAgICBwcm9wc0lucHV0LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICByb2xlOiAocm9sZSA/PyBcInRhYmxpc3RcIiksXHJcbiAgICAgICAgICAgICAgICBcImFyaWEtb3JpZW50YXRpb25cIjogb3JpZW50YXRpb24gPz8gXCJob3Jpem9udGFsXCIsXHJcbiAgICAgICAgICAgIH0gYXMge30pLFxyXG4gICAgICAgIHByb3BzTGFiZWxcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VUYWI8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgbWFuYWdlZENoaWxkUGFyYW1ldGVycywgcHJlc3NQYXJhbWV0ZXJzLCB0ZXh0Q29udGVudFBhcmFtZXRlcnMsIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczogeyBzZWxlY3Rpb25Nb2RlLCAuLi5zaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMgfSwgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzLCBjb250ZXh0IH06IFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4pIHtcclxuXHJcbiAgICBjb25zdCB7IHByb3BzOiBsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMsIC4uLmxpc3ROYXZSZXQyIH0gPSB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoe1xyXG4gICAgICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsXHJcbiAgICAgICAgY29udGV4dCxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxyXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzLFxyXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcclxuICAgICAgICBwcmVzc1BhcmFtZXRlcnMsXHJcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IGFyaWFQcm9wTmFtZTogXCJhcmlhLXNlbGVjdGVkXCIsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUgPz8gXCJmb3Vjc1wiLCAuLi5zaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMgfSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgeyBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVybjogeyBzZWxlY3RlZCB9LCByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuOiB7IHRhYmJhYmxlIH0gfSA9IGxpc3ROYXZSZXQyO1xyXG4gICAgY29uc3QgeyBnZXRQYW5lbElkLCBnZXRUYWJJZCwgc2V0U2VsZWN0ZWRJbmRleCB9ID0gY29udGV4dC50YWJzQ29udGV4dDtcclxuXHJcbiAgICBjb25zdCBwYW5lbElkID0gZ2V0UGFuZWxJZChtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLmluZGV4KTtcclxuICAgIGNvbnN0IHRhYklkID0gZ2V0VGFiSWQobWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleCk7XHJcblxyXG4gICAgZGVidWdMb2coXCJ1c2VUYWJcIiwgbWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleCwgc2VsZWN0ZWQudG9TdHJpbmcoKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByb3BzOiB1c2VNZXJnZWRQcm9wcyhsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMsIHtcclxuICAgICAgICAgICAgXCJkYXRhLXRhYmJhYmxlXCI6IHRhYmJhYmxlLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIFwiZGF0YS1zZWxlY3RlZFwiOiBzZWxlY3RlZC50b1N0cmluZygpLFxyXG4gICAgICAgICAgICByb2xlOiBcInRhYlwiLFxyXG4gICAgICAgICAgICBcImFyaWEtY29udHJvbHNcIjogcGFuZWxJZCxcclxuICAgICAgICAgICAgaWQ6IHRhYklkXHJcbiAgICAgICAgfSBhcyB7fSksXHJcbiAgICAgICAgLi4ubGlzdE5hdlJldDJcclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VUYWJQYW5lbDxQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIGNvbnRleHQgfTogVXNlVGFiUGFuZWxQYXJhbWV0ZXJzKTogVXNlVGFiUGFuZWxSZXR1cm5UeXBlPFBhbmVsRWxlbWVudD4ge1xyXG4gICAgY29uc3QgeyBpbmRleCB9ID0gbWFuYWdlZENoaWxkUGFyYW1ldGVycztcclxuICAgIGRlYnVnTG9nKFwidXNlVGFiUGFuZWxcIiwgaW5kZXgpO1xyXG4gICAgY29uc3QgeyB0YWJQYW5lbENvbnRleHQ6IHsgZ2V0VmlzaWJsZUluZGV4LCBnZXRQYW5lbElkLCBnZXRUYWJJZCB9IH0gPSBjb250ZXh0O1xyXG4gICAgLy9jb25zdCBbY29ycmVzcG9uZGluZ1RhYklkLCBzZXRDb3JyZXNwb25kaW5nVGFiSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgICBjb25zdCBbaXNWaXNpYmxlLCBzZXRJc1Zpc2libGUsIGdldElzVmlzaWJsZV0gPSB1c2VTdGF0ZShnZXRWaXNpYmxlSW5kZXgoKSA9PSBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLmluZGV4KTtcclxuICAgIC8vY29uc3QgdmlzaWJsZVJlZiA9IHVzZVJlZjxDaGlsZEZsYWdPcGVyYXRpb25zPih7IGdldDogZ2V0SXNWaXNpYmxlLCBzZXQ6IHNldElzVmlzaWJsZSwgaXNWYWxpZDogcmV0dXJuVHJ1ZSB9KTtcclxuICAgIHVzZU1hbmFnZWRDaGlsZDxUYWJQYW5lbEluZm8+KHsgY29udGV4dCwgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9IH0sIHsgZ2V0VmlzaWJsZTogZ2V0SXNWaXNpYmxlLCBzZXRWaXNpYmxlOiBzZXRJc1Zpc2libGUsIC4uLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfSk7XHJcbiAgICBjb25zdCBwYW5lbElkID0gZ2V0UGFuZWxJZChtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLmluZGV4KTtcclxuICAgIGNvbnN0IHRhYklkID0gZ2V0VGFiSWQobWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleCk7XHJcblxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJvcHM6IHVzZU1lcmdlZFByb3BzPFBhbmVsRWxlbWVudD4oe1xyXG4gICAgICAgICAgICByb2xlOiBcInRhYnBhbmVsXCIsXHJcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHRhYklkLFxyXG4gICAgICAgICAgICBpZDogcGFuZWxJZCxcclxuICAgICAgICAgICAgaW5lcnQ6ICFpc1Zpc2libGVcclxuICAgICAgICB9IGFzIHt9KSxcclxuICAgICAgICB0YWJQYW5lbFJldHVybjoge1xyXG4gICAgICAgICAgICB2aXNpYmxlOiBpc1Zpc2libGUsXHJcbiAgICAgICAgICAgIGdldFZpc2libGU6IGdldElzVmlzaWJsZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBmaW5kRmlyc3RGb2N1c2FibGUsIE1hbmFnZWRDaGlsZEluZm8sIHVzZUdsb2JhbEhhbmRsZXIsIHVzZU1hbmFnZWRDaGlsZCwgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0LCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlR2V0dGVyLCB1c2VTdGF0ZSwgdXNlVGltZW91dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZyB9IGZyb20gXCIuL3Byb3BzXCI7XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvYXN0c1BhcmFtZXRlcnMgZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFRvYXN0SW5mbz4ge1xuICAgIHRvYXN0c1BhcmFtZXRlcnM6IHtcbiAgICAgICAgdmlzaWJsZUNvdW50OiBudW1iZXI7ICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRvYXN0cyB0aGF0IGFyZSBzaG93biBhdCBvbmUgdGltZSAodXNlZCBmb3IgYXV0b21hdGljIG1hbmFnZW1lbnQgb2Ygd2hlbiB0byBzaG93IHRvYXN0cywgaS5lLiBkb24ndCBzaG93IHRoaXMgdG9hc3QgaWYgMiBhcmUgYWxyZWFkeSBvbi1zY3JlZW4gLS0gMSBpcyBhIGdvb2QgZGVmYXVsdClcbiAgICB9XG59XG5cbi8vIFwiZm9jdXNcIiB8IFwic2V0TnVtYmVyQWhlYWRPZk1lXCIgfCBcInNob3dcIlxuZXhwb3J0IGludGVyZmFjZSBVc2VUb2FzdFBhcmFtZXRlcnM8TSBleHRlbmRzIFRvYXN0SW5mbz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPE0+IHtcbiAgICB0b2FzdFBhcmFtZXRlcnM6IHtcbiAgICAgICAgcG9saXRlbmVzcz86IFwicG9saXRlXCIgfCBcImFzc2VydGl2ZVwiO1xuICAgICAgICB0aW1lb3V0OiBudW1iZXIgfCBudWxsO1xuICAgIH1cbiAgICBjb250ZXh0OiBUb2FzdHNDb250ZXh0PE0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRvYXN0SW5mbyBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyPiB7XG4gICAgc2V0TnVtYmVyQWhlYWRPZk1lOiBTdGF0ZVVwZGF0ZXI8bnVtYmVyPjtcbiAgICBmb2N1cygpOiB2b2lkO1xuICAgIHNob3coKTogdm9pZDtcbn1cblxuLy9leHBvcnQgdHlwZSBVc2VUb2FzdDxFIGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlVG9hc3RQYXJhbWV0ZXJzKSA9PiBVc2VUb2FzdFJldHVyblR5cGU8RT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9hc3RSZXR1cm5UeXBlPFRvYXN0VHlwZSBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICB0b2FzdFJldHVybjoge1xuICAgICAgICBudW1iZXJPZlRvYXN0c0FoZWFkT2ZVczogbnVtYmVyO1xuICAgICAgICBkaXNtaXNzOiAoKSA9PiB2b2lkO1xuICAgICAgICBkaXNtaXNzZWQ6IGJvb2xlYW47XG4gICAgICAgIHNob3dpbmc6IGJvb2xlYW47XG4gICAgICAgIHJlc2V0RGlzbWlzc1RpbWVyOiAoKSA9PiB2b2lkO1xuICAgIH1cbiAgICBwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VG9hc3RUeXBlPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUb2FzdHNSZXR1cm5UeXBlPENvbnRhaW5lclR5cGUgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVG9hc3RJbmZvPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8VG9hc3RJbmZvPiB7XG4gICAgY29udGV4dDogVG9hc3RzQ29udGV4dDxNPlxuICAgIHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJUeXBlPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb2FzdHNDb250ZXh0PE0gZXh0ZW5kcyBUb2FzdEluZm8+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dDxNPiB7XG4gICAgdG9hc3RDb250ZXh0OiB7XG4gICAgICAgIG9uQW55VG9hc3REaXNtaXNzZWQ6IChfaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbiAgICAgICAgZ2V0TWF4VmlzaWJsZUNvdW50OiAoKSA9PiBudW1iZXI7XG4gICAgICAgIHNldFBvbGl0ZW5lc3M6IFN0YXRlVXBkYXRlcjxcInBvbGl0ZVwiIHwgXCJhc3NlcnRpdmVcIj47XG4gICAgICAgIG9uQW55VG9hc3RNb3VudGVkOiAodG9hc3RJbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuICAgIH07XG59XG5cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVG9hc3RzPENvbnRhaW5lclR5cGUgZXh0ZW5kcyBFbGVtZW50Pih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY211LCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QgfSwgdG9hc3RzUGFyYW1ldGVyczogeyB2aXNpYmxlQ291bnQgfSB9OiBVc2VUb2FzdHNQYXJhbWV0ZXJzKTogVXNlVG9hc3RzUmV0dXJuVHlwZTxDb250YWluZXJUeXBlLCBUb2FzdEluZm8+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZVRvYXN0c1wiKTtcblxuICAgIC8vIE5vcm1hbGx5LCB0aGlzIGRvZXMganVzdCBsb29rIGxpa2UgWzAsIDEsIDIsIDNdLCBldGNcbiAgICAvLyBzbyBpdCBjb3VsZCBiZSBqdXN0IGFuIGluZGV4IHRvIHRoZSBjdXJyZW50IHRvYXN0LFxuICAgIC8vIGJ1dCBpZiB3ZSBkaXNtaXNzIHRvYXN0cyBvdXQgb2Ygb3JkZXIsIGl0J3MgWzAsIDIsIDNdIG9yIHNvbWV0aGluZy5cbiAgICAvLyBTbyBqdXN0IGtlZXAgdHJhY2sgb2YgaXQgYWxsIGluIGEgYmlnIG9sJywgdGhlcmUncyBvbmx5IG9uZSBvZiB0aGVzZSBvbiBhIHBhZ2UgYW55d2F5LFxuICAgIC8vIGFuZCBpZiB5b3UncmUgcHVzaW5nIDEwMDAwIHRvYXN0cyBhdCBvbmNlIGFuIEFycmF5PG51bWJlcj4gaXNuJ3QgZ29pbmcgdG8gYmUgeW91ciBib3R0bGVuZWNrLlxuICAgIGNvbnN0IGN1cnJlbnRJbmRleFF1ZXVlID0gdXNlUmVmPG51bWJlcltdPihbXSk7XG5cbiAgICBjb25zdCBbcG9saXRlbmVzcywgc2V0UG9saXRlbmVzc10gPSB1c2VTdGF0ZTxcInBvbGl0ZVwiIHwgXCJhc3NlcnRpdmVcIj4oXCJwb2xpdGVcIik7XG5cbiAgICBjb25zdCBnZXRNYXhWaXNpYmxlQ291bnQgPSB1c2VTdGFibGVHZXR0ZXIodmlzaWJsZUNvdW50KTtcblxuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50LCBwcm9wc1N0YWJsZSB9IH0gPSB1c2VSZWZFbGVtZW50PENvbnRhaW5lclR5cGU+KHsgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9IH0pO1xuICAgIGNvbnN0IHsgY29udGV4dCwgbWFuYWdlZENoaWxkcmVuUmV0dXJuLCAuLi5fY2hpbGRJbmZvIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48VG9hc3RJbmZvPih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG9jbXUgfSB9KTtcblxuICAgIGNvbnN0IHsgZ2V0Q2hpbGRyZW46IGdldFRvYXN0UXVldWUgfSA9IG1hbmFnZWRDaGlsZHJlblJldHVybjtcbiAgICBjb25zdCB0b2FzdFF1ZXVlID0gZ2V0VG9hc3RRdWV1ZSgpO1xuXG4gICAgLy8gV2hlbiBhIHRvYXN0IGlzIHNob3duIG9yIGhpZGRlbiwgYWx3YXlzIG1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHNob3dpbmcgYWxsIHRoZSB0b2FzdHMgdGhhdCB3ZSBzaG91bGQgYmUuXG4gICAgY29uc3Qgc2hvd0hpZ2hlc3RQcmlvcml0eVRvYXN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1pbihnZXRNYXhWaXNpYmxlQ291bnQoKSwgY3VycmVudEluZGV4UXVldWUuY3VycmVudC5sZW5ndGgpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4OyArK2kpIHtcblxuICAgICAgICAgICAgY29uc3QgaGlnaGVzdFByaW9yaXR5VG9hc3QgPSB0b2FzdFF1ZXVlLmdldEF0KGN1cnJlbnRJbmRleFF1ZXVlLmN1cnJlbnRbaV0pO1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoISFoaWdoZXN0UHJpb3JpdHlUb2FzdCk7XG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlUb2FzdD8uc2hvdygpO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICAvLyBBbnkgdGltZSBhIG5ldyB0b2FzdCBtb3VudHMsIHVwZGF0ZSBvdXIgYm90dG9tbW9zdFRvYXN0SW5kZXggdG8gcG9pbnQgdG8gaXQgaWYgbmVjZXNzYXJ5XG4gICAgLy8gKFwibmVjZXNzYXJ5XCIganVzdCBtZWFuaW5nIGlmIGl0J3MgdGhlIGZpcnN0IHRvYXN0IGV2ZXIgb3IgYWxsIHByaW9yIHRvYXN0cyBoYXZlIGJlZW4gZGlzbWlzc2VkKVxuICAgIGNvbnN0IG9uQW55VG9hc3RNb3VudGVkID0gdXNlQ2FsbGJhY2soKHRvYXN0SW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBjdXJyZW50SW5kZXhRdWV1ZS5jdXJyZW50LnB1c2godG9hc3RJbmRleCk7XG4gICAgICAgIHRvYXN0UXVldWUuZ2V0QXQodG9hc3RJbmRleCk/LnNldE51bWJlckFoZWFkT2ZNZShjdXJyZW50SW5kZXhRdWV1ZS5jdXJyZW50Lmxlbmd0aCAtIDEpO1xuICAgICAgICBzaG93SGlnaGVzdFByaW9yaXR5VG9hc3QoKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIHRvYXN0IGlzIGRpc21pc3NlZCwgdXBkYXRlIG91ciBib3R0b21tb3N0VG9hc3RJbmRleCB0byBwb2ludCB0byB0aGUgbmV4dCB0b2FzdCBpbiB0aGUgcXVldWUsIGlmIG9uZSBleGlzdHMuXG4gICAgY29uc3Qgb25BbnlUb2FzdERpc21pc3NlZCA9IHVzZUNhbGxiYWNrKChfaW5kZXg6IG51bWJlcikgPT4ge1xuXG4gICAgICAgIC8vIFdoZW4gd2UgZGlzbWlzcyBhIHRvYXN0LCByZW1vdmUgaXQgZnJvbSB0aGUgXCJ0by1kaXNwbGF5XCIgcXVldWUgYnkgYWN0dWFsbHkgc3BsaWNpbmcgaXQgb3V0IG9mIHRoZSBhcnJheS5cbiAgICAgICAgLy8gVGhlbiBub3RpZnkgZWFjaCB0b2FzdCBvZiBpdHMgY2hhbmdlIGluIHBvc2l0aW9uIHdpdGhpbiB0aGF0IHF1ZXVlIHRvIGtlZXAgdGhlIHR3byBpbiBzeW5jLlxuICAgICAgICBjb25zdCByZW1vdmFsSW5kZXggPSBjdXJyZW50SW5kZXhRdWV1ZS5jdXJyZW50LmZpbmRJbmRleChpID0+IGkgPT0gX2luZGV4KTtcblxuXG4gICAgICAgIC8vIEZvciBhbGwgdG9hc3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGlzbWlzc2VkLCBzaGlmdCB0aGVtIGV2ZW4gZnVydGhlciBiYWNrIGJ5IG9uZSB0byBcIm1ha2Ugc3BhY2VcIiBcbiAgICAgICAgLy8gKHRoZXkncmUgcmVtb3ZlZCBmcm9tIHRoZSBxdWV1ZSBidXQgdGhpcyBpcyB0aGUgbmVnYXRpdmUgaW5kZXggdGhleSB3b3VsZCBoYXZlIGlmIHdlIGtlcHQgbmVnYXRpdmVzIGluIHRoZSBxdWV1ZSlcbiAgICAgICAgLy8gZm9yIHRoZSBuZXdseS1kaXNtaXNzZWQgdG9hc3QuXG4gICAgICAgIHRvYXN0UXVldWUuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIGMuc2V0TnVtYmVyQWhlYWRPZk1lKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2IDwgMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXYgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIExldCB0aGlzIHRvYXN0IGtub3cgdGhhdCBpdCdzIG5vdyB0aGUgbW9zdCByZWNlbnRseSBkaXNtaXNzZWQgdG9hc3RcbiAgICAgICAgdG9hc3RRdWV1ZS5nZXRBdChfaW5kZXgpPy5zZXROdW1iZXJBaGVhZE9mTWUoLTEpO1xuXG4gICAgICAgIC8vIE5vdGlmeSBhbGwgdG9hc3RzIHdhaXRpbmcgYmVoaW5kIHRoaXMgb25lIGluIHRoZSBxdWV1ZSB0aGF0IHRoZXkndmUgbW92ZWQgdXAgb25lIHNsb3RcbiAgICAgICAgdG9hc3RRdWV1ZS5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgYy5zZXROdW1iZXJBaGVhZE9mTWUocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPiByZW1vdmFsSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2IC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFjdHVhbGx5IG1vZGlmeSB0aGUgcXVldWUgaXRzZWxmXG4gICAgICAgIGN1cnJlbnRJbmRleFF1ZXVlLmN1cnJlbnQuc3BsaWNlKHJlbW92YWxJbmRleCwgMSk7XG5cbiAgICAgICAgLy8gQW5kIGFmdGVyIGFsbCB0aGF0LCBtYWtlIHN1cmUgdGhhdCB3ZSdyZSBzaG93aW5nIGFueSB0b2FzdHMgdGhhdCBoYXZlIGJlZW4gd2FpdGluZyBpbiB0aGUgcXVldWVcbiAgICAgICAgc2hvd0hpZ2hlc3RQcmlvcml0eVRvYXN0KCk7XG4gICAgfSwgW10pO1xuXG5cblxuICAgIGNvbnN0IFtfbW91c2VPdmVyMiwgc2V0TW91c2VPdmVyLCBfZ2V0TW91c2VPdmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwicG9pbnRlcm1vdmVcIiwgZSA9PiB7XG4gICAgICAgIGNvbnN0IG1vdXNlT3ZlciA9IChlLnRhcmdldCAhPSBudWxsICYmIGUudGFyZ2V0IGluc3RhbmNlb2YgTm9kZSAmJiAoZ2V0RWxlbWVudCgpPy5jb250YWlucyhlLnRhcmdldCkgfHwgZ2V0RWxlbWVudCgpID09IGUudGFyZ2V0KSk7XG4gICAgICAgIHNldE1vdXNlT3Zlcihtb3VzZU92ZXIpO1xuICAgIH0pO1xuXG4gICAgLy8gQW55IHRpbWUgdGhlIGluZGV4IHBvaW50aW5nIHRvIHRoZSBjdXJyZW50bHktc2hvd2luZyB0b2FzdCBjaGFuZ2VzLFxuICAgIC8vIHVwZGF0ZSB0aGUgcmVsZXZhbnQgY2hpbGRyZW4gYW5kIGxldCB0aGVtIGtub3cgdGhhdCB0aGV5J3JlIG5vdyBlaXRoZXIgYWN0aXZlIG9yIGRpc21pc3NlZC5cbiAgICAvKmNvbnN0IHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0IH0gPSB1c2VDaGlsZHJlbkZsYWc8VG9hc3RJbmZvLCBcInNob3dpbmdcIj4oe1xuICAgICAgICBpbml0aWFsSW5kZXg6IGFjdGl2ZVRvYXN0SW5kZXgsXG4gICAgICAgIGNoaWxkcmVuOiB0b2FzdFF1ZXVlLFxuICAgICAgICBrZXk6IFwic2hvd2luZ1wiLFxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZSxcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjaGFuZ2VJbmRleChhY3RpdmVUb2FzdEluZGV4KTtcbiAgICB9LCBbYWN0aXZlVG9hc3RJbmRleF0pOyovXG5cbiAgICBjb25zdCB0b2FzdENvbnRleHQgPSB7XG4gICAgICAgIG9uQW55VG9hc3REaXNtaXNzZWQsXG4gICAgICAgIGdldE1heFZpc2libGVDb3VudCxcbiAgICAgICAgc2V0UG9saXRlbmVzcyxcbiAgICAgICAgb25BbnlUb2FzdE1vdW50ZWRcbiAgICB9XG4gICAgXG4gICAgLy9mdW5jdGlvbiB1c2VUb2FzdENvbnRhaW5lclByb3BzKHsgcm9sZSwgXCJhcmlhLWxpdmVcIjogYXJpYUxpdmUsIFwiYXJpYS1yZWxldmFudFwiOiBhcmlhUmVsZXZhbnQsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENvbnRhaW5lclR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyVHlwZT4ge1xuICAgIGNvbnN0IHByb3BzID0gdXNlTWVyZ2VkUHJvcHM8Q29udGFpbmVyVHlwZT4odXNlTWVyZ2VkUHJvcHMocHJvcHNTdGFibGUsIHsgY2xhc3M6IFwidG9hc3RzLWNvbnRhaW5lclwiLCByb2xlOiBcInN0YXR1c1wiLCBcImFyaWEtbGl2ZVwiOiBwb2xpdGVuZXNzID8/IFwicG9saXRlXCIsIFwiYXJpYS1yZWxldmFudFwiOiBcImFkZGl0aW9uc1wiIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyVHlwZT4pKTtcbiAgICAvL31cblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICAgIHRvYXN0Q29udGV4dFxuICAgICAgICB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHByb3BzXG5cbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVG9hc3Q8RSBleHRlbmRzIEVsZW1lbnQ+KHsgdG9hc3RQYXJhbWV0ZXJzOiB7IHBvbGl0ZW5lc3MsIHRpbWVvdXQgfSwgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCwgLi4uX21hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfSwgY29udGV4dCB9OiBVc2VUb2FzdFBhcmFtZXRlcnM8VG9hc3RJbmZvPik6IFVzZVRvYXN0UmV0dXJuVHlwZTxFPiB7XG4gICAgY29uc3QgeyBnZXRNYXhWaXNpYmxlQ291bnQsIG9uQW55VG9hc3REaXNtaXNzZWQsIHNldFBvbGl0ZW5lc3MsIG9uQW55VG9hc3RNb3VudGVkIH0gPSBjb250ZXh0LnRvYXN0Q29udGV4dDtcbiAgICBkZWJ1Z0xvZyhcInVzZVRvYXN0XCIsIGluZGV4KTtcbiAgICBjb25zdCBbbnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMsIHNldE51bWJlck9mVG9hc3RzQWhlYWRPZlVzXSA9IHVzZVN0YXRlKEluZmluaXR5KTtcbiAgICBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUdldHRlcihpbmRleCk7XG4gICAgY29uc3QgW2Rpc21pc3NlZDIsIHNldERpc21pc3NlZDIsIGdldERpc21pc3NlZDJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtzaG93aW5nMiwgc2V0U2hvd2luZzIsIGdldFNob3dpbmcyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvL2NvbnN0IFtkaXNtaXNzZWQsIHNldERpc21pc3NlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgLy9jb25zdCBbc3RhdHVzLCBzZXRTdGF0dXMsIGdldFN0YXR1c10gPSB1c2VTdGF0ZTxcInBlbmRpbmdcIiB8IFwiYWN0aXZlXCIgfCBcImRpc21pc3NlZFwiPihcInBlbmRpbmdcIik7XG4gICAgLy9jb25zdCBkaXNtaXNzZWQgPSAoc3RhdHVzID09PSBcImRpc21pc3NlZFwiKTtcbiAgICBjb25zdCBkaXNtaXNzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAoIWdldERpc21pc3NlZDIoKSlcbiAgICAgICAgICAgIG9uQW55VG9hc3REaXNtaXNzZWQoZ2V0SW5kZXgoKSk7XG5cbiAgICAgICAgc2V0RGlzbWlzc2VkMih0cnVlKTtcbiAgICAgICAgc2V0U2hvd2luZzIoZmFsc2UpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHNob3cgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldFNob3dpbmcyKHRydWUpO1xuICAgIH0sIFtdKVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFnZXREaXNtaXNzZWQyKCkgJiYgIWdldFNob3dpbmcyKCkpIHtcbiAgICAgICAgICAgIGlmIChudW1iZXJPZlRvYXN0c0FoZWFkT2ZVcyA+PSAwICYmIG51bWJlck9mVG9hc3RzQWhlYWRPZlVzIDwgZ2V0TWF4VmlzaWJsZUNvdW50KCkpIHtcbiAgICAgICAgICAgICAgICBzaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbbnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXNdKVxuXG4gICAgLy9jb25zdCB0b2FzdElkID0gZ2VuZXJhdGVSYW5kb21JZChcInRvYXN0LVwiKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBzZXRQb2xpdGVuZXNzKHBvbGl0ZW5lc3MgPz8gXCJwb2xpdGVcIik7IH0sIFtwb2xpdGVuZXNzXSk7XG5cblxuICAgIGNvbnN0IGZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RGb2N1c2FibGUgPSBmaW5kRmlyc3RGb2N1c2FibGUoZWxlbWVudCk7XG4gICAgICAgICAgICBmaXJzdEZvY3VzYWJsZT8uZm9jdXM/LigpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRSZXR1cm46IHsgZ2V0Q2hpbGRyZW46IF9nZXRUb2FzdHMgfSB9ID0gdXNlTWFuYWdlZENoaWxkPFRvYXN0SW5mbz4oeyBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sIGNvbnRleHQgfSwgeyBpbmRleCwgZm9jdXMsIHNldE51bWJlckFoZWFkT2ZNZTogc2V0TnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMsIHNob3cgfSk7XG5cbiAgICAvL2NvbnN0IGlzQWN0aXZlID0gKHN0YXR1cyA9PT0gXCJhY3RpdmVcIik7XG4gICAgY29uc3QgW3RyaWdnZXJJbmRleCwgc2V0VHJpZ2dlckluZGV4XSA9IHVzZVN0YXRlKDEpO1xuXG4gICAgY29uc3QgcmVzZXREaXNtaXNzVGltZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldFRyaWdnZXJJbmRleChpID0+ICsraSk7XG4gICAgfSwgW10pXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBvbkFueVRvYXN0TW91bnRlZChpbmRleCk7XG4gICAgfSwgW10pO1xuXG4gICAgLyp1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXNob3dpbmcpXG4gICAgICAgICAgICBvbkFueVRvYXN0RGlzbWlzc2VkKGluZGV4KVxuICAgIH0sIFtzaG93aW5nXSk7Ki9cblxuICAgIGNvbnN0IGRpc21pc3NUaW1lb3V0S2V5ID0gKHRpbWVvdXQgPT0gbnVsbCB8fCBudW1iZXJPZlRvYXN0c0FoZWFkT2ZVcyAhPSAwKSA/IG51bGwgOiBpc0Zpbml0ZSh0aW1lb3V0KSA/IHRpbWVvdXQgOiB0aW1lb3V0ID4gMCA/IG51bGwgOiAwO1xuXG4gICAgdXNlVGltZW91dCh7XG4gICAgICAgIHRpbWVvdXQ6IGRpc21pc3NUaW1lb3V0S2V5LFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNob3dpbmcyKVxuICAgICAgICAgICAgICAgIGRpc21pc3MoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlckluZGV4OiBzaG93aW5nMiA/IHRyaWdnZXJJbmRleCA6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudCwgcHJvcHNTdGFibGUgfSB9ID0gdXNlUmVmRWxlbWVudDxFPih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9hc3RSZXR1cm46IHtcbiAgICAgICAgICAgIGRpc21pc3NlZDogZGlzbWlzc2VkMixcbiAgICAgICAgICAgIHNob3dpbmc6IHNob3dpbmcyLFxuICAgICAgICAgICAgbnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMsXG4gICAgICAgICAgICBkaXNtaXNzLFxuICAgICAgICAgICAgcmVzZXREaXNtaXNzVGltZXJcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHM6IHByb3BzU3RhYmxlXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHJldHVybkZhbHNlLCB1c2VHbG9iYWxIYW5kbGVyLCB1c2VIYXNDdXJyZW50Rm9jdXMsIFVzZUhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMsIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVJhbmRvbUlkLCB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBQcmVmaWNlcyB9IGZyb20gXCIuL3Byb3BzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbHRpcFRyaWdnZXJQYXJhbWV0ZXJzPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHJlZkVsZW1lbnRSZXR1cm46IFJlcXVpcmVkPFBpY2s8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8VHJpZ2dlclR5cGU+W1wicmVmRWxlbWVudFJldHVyblwiXSwgXCJnZXRFbGVtZW50XCI+PlxufVxuZXhwb3J0IHR5cGUgVXNlVG9vbHRpcFRyaWdnZXI8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VUb29sdGlwVHJpZ2dlclBhcmFtZXRlcnM8VHJpZ2dlclR5cGU+KSA9PiB7XG4gICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuVHlwZTogUmVxdWlyZWQ8UGljazxVc2VIYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzPFRyaWdnZXJUeXBlPltcImhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnNcIl0sIFwib25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZFwiPj5cblxuICAgIHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHM6ICh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+XG59O1xuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sdGlwUGFyYW1ldGVycyB7IG1vdXNlb3ZlckRlbGF5PzogbnVtYmVyLCBtb3VzZW91dFRvbGVyYW5jZURlbGF5PzogbnVtYmVyLCBmb2N1c0RlbGF5PzogbnVtYmVyIH1cbmV4cG9ydCB0eXBlIFVzZVRvb2x0aXA8VHJpZ2dlclR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIFRvb2x0aXBUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlVG9vbHRpcFBhcmFtZXRlcnMpID0+IFVzZVRvb2x0aXBSZXR1cm5UeXBlPFRyaWdnZXJUeXBlLCBUb29sdGlwVHlwZT47XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvb2x0aXBSZXR1cm5UeXBlPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudCwgUG9wdXBUeXBlIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHRvb2x0aXBSZXR1cm46IHtcbiAgICAgICAgaXNPcGVuOiBib29sZWFuO1xuICAgICAgICBnZXRJc09wZW46ICgpID0+IGJvb2xlYW47XG4gICAgfVxuICAgIHByb3BzUG9wdXA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwVHlwZT47XG4gICAgcHJvcHNUcmlnZ2VyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT47XG59XG5cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVG9vbHRpcDxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQsIFBvcHVwVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgbW91c2VvdmVyRGVsYXksIG1vdXNlb3V0VG9sZXJhbmNlRGVsYXksIGZvY3VzRGVsYXkgfTogVXNlVG9vbHRpcFBhcmFtZXRlcnMpOiBVc2VUb29sdGlwUmV0dXJuVHlwZTxUcmlnZ2VyVHlwZSwgUG9wdXBUeXBlPiB7XG4gICAgZGVidWdMb2coXCJ1c2VUb29sdGlwXCIpO1xuXG4gICAgbW91c2VvdmVyRGVsYXkgPz89IDQwMDtcbiAgICBtb3VzZW91dFRvbGVyYW5jZURlbGF5ID8/PSA1MDA7XG4gICAgZm9jdXNEZWxheSA/Pz0gMTtcblxuICAgIC8vIFRoZSBlc2NhcGUga2V5IHNob3VsZCBjbG9zZSB0b29sdGlwcywgYnV0IGRvIG5vdGhpbmcgZWxzZS5cbiAgICAvLyAoaS5lLiBjbG9zaW5nIGEgdG9vbHRpcCBpbiBhIGRpYWxvZyBNVVNUIE5PVCBjbG9zZSB0aGUgZGlhbG9nIHRvbylcbiAgICAvLyBUT0RPOiBUb29sdGlwcyBhcmUsIGVmZmVjdGl2ZWx5LCBhbHdheXMgdGhlIHRvcG1vc3QgY29tcG9uZW50LFxuICAgIC8vIHNvIHdlIGNhbiBqdXN0IGhhdmUgdGhlbSBsaXN0ZW4gdG8gYW5kIHN3YWxsb3cgYWxsIFwiRXNjYXBlXCJcbiAgICAvLyBrZXkgcHJlc3NlcyBiZWZvcmUgYW55b25lIGVsc2UuIEZvciBhIG1vcmUgZ2VuZXJhbCBwb3B1cCxcbiAgICAvLyBvciBhIHRvb2x0aXAgaW4gYSB0b29sdGlwICghISkgYSBkaWZmZXJlbnQgc29sdXRpb24gd291bGQgYmUgbmVlZGVkLlxuICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwia2V5ZG93blwiLCAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZ2V0T3BlbigpICYmIGUua2V5ID09PSBcIkVzY2FwZVwiICYmICFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBzZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgIHNldEhvdmVyU3RhdGUoXCJoaWRkZW5cIik7XG4gICAgICAgICAgICBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuXG4gICAgY29uc3QgW29wZW4sIHNldE9wZW4sIGdldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgbGV0IHtcbiAgICAgICAgcHJvcHNSZWZlcmVuY2VyOiBwcm9wc1RyaWdnZXIsXG4gICAgICAgIHByb3BzU291cmNlOiBwcm9wc1BvcHVwXG4gICAgfSA9IHVzZVJhbmRvbUlkPFBvcHVwVHlwZSwgVHJpZ2dlclR5cGU+KHsgcmFuZG9tSWRQYXJhbWV0ZXJzOiB7IHByZWZpeDogUHJlZmljZXMudG9vbHRpcCwgb3RoZXJSZWZlcmVuY2VyUHJvcDogXCJhcmlhLWRlc2NyaWJlZGJ5XCIgYXMgbmV2ZXIgfSB9KTtcblxuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50OiBnZXRUcmlnZ2VyRWxlbWVudCwgcHJvcHNTdGFibGU6IHRyaWdnZXJSZWZQcm9wcyB9IH0gPSB1c2VSZWZFbGVtZW50PFRyaWdnZXJUeXBlPih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudDogZ2V0UG9wdXBFbGVtZW50LCBwcm9wc1N0YWJsZTogcG9wdXBSZWZQcm9wcyB9IH0gPSB1c2VSZWZFbGVtZW50PFBvcHVwVHlwZT4oeyByZWZFbGVtZW50UGFyYW1ldGVyczoge30gfSk7XG5cbiAgICBjb25zdCBbLCBzZXRUcmlnZ2VyRm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDE7XG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZvY3VzZWQpLCBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDEpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgfSksIHJldHVybkZhbHNlKTtcbiAgICBjb25zdCBbLCBzZXRUb29sdGlwRm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDE7XG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUb29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZvY3VzZWQpLCBkZWxheSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9KSwgcmV0dXJuRmFsc2UpO1xuICAgIGNvbnN0IG9uSG92ZXJDaGFuZ2UgPSB1c2VTdGFibGVDYWxsYmFjayhmdW5jdGlvbiBvbkhvdmVyQ2hhbmdlKGhvdmVyaW5nOiBib29sZWFuKSB7XG4gICAgICAgIGlmIChob3ZlcmluZykge1xuICAgICAgICAgICAgc3dpdGNoIChob3ZlclN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImhpZGluZ1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGhvdmluZyBvdmVyIHRoZSB0b29sdGlwIHJpZ2h0IGFmdGVyIGhvdmVyaW5nIGF3YXkgZnJvbSBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBzaG93IGl0IGFnYWluIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIHNldEhvdmVyU3RhdGUoXCJzaG93blwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJoaWRkZW5cIjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdG9vbHRpcCBpc24ndCBzaG93aW5nIGFuZCBoYXNuJ3QgZm9yIGF3aGlsZSAoaWYgZXZlcilcbiAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCBmb3Igb3VyIG1vdXNlb3ZlciBkZWxheVxuICAgICAgICAgICAgICAgICAgICBzZXRIb3ZlclN0YXRlKFwic2hvd2luZzJcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4geyBjb25zb2xlLmxvZyhcInNldEhvdmVyU3RhdGUoc2hvd24pXCIpOyAgc2V0SG92ZXJTdGF0ZShcInNob3duXCIpIH0sIG1vdXNlb3ZlckRlbGF5KTtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChob3ZlclN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNob3duXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vdXNlIGhhcyBsZWZ0IHRoZSB0cmlnZ2VyLCBidXQgZGVsYXkgdHJ1bHkgaGlkaW5nIGl0IGZvciBhIG1vbWVudFxuICAgICAgICAgICAgICAgICAgICBzZXRIb3ZlclN0YXRlKFwiaGlkaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHsgY29uc29sZS5sb2coXCJzZXRIb3ZlclN0YXRlKGhpZGRlbilcIik7IHNldEhvdmVyU3RhdGUoXCJoaWRkZW5cIik7fSwgbW91c2VvdmVyRGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInNob3dpbmcyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRHVyaW5nIGEgbW91c2VvdmVyIGRlbGF5LCB3aGVuIHdlIG1vdXNlb3V0LFxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHJlc2V0IHRoZSB0aW1lclxuICAgICAgICAgICAgICAgICAgICBzZXRIb3ZlclN0YXRlKFwiaGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgWywgc2V0VHJpZ2dlckhvdmVyXSA9IHVzZVBhc3NpdmVTdGF0ZShvbkhvdmVyQ2hhbmdlLCByZXR1cm5GYWxzZSk7XG4gICAgY29uc3QgWywgc2V0VG9vbHRpcEhvdmVyXSA9IHVzZVBhc3NpdmVTdGF0ZShvbkhvdmVyQ2hhbmdlLCByZXR1cm5GYWxzZSk7XG4gICAgY29uc3QgW3RyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQsIHNldFRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtob3ZlclN0YXRlLCBzZXRIb3ZlclN0YXRlXSA9IHVzZVN0YXRlPFwiaGlkZGVuXCIgfCBcInNob3dpbmcyXCIgfCBcInNob3duXCIgfCBcImhpZGluZ1wiPihcImhpZGRlblwiKTtcblxuXG5cbiAgICB1c2VUaW1lb3V0KHtcbiAgICAgICAgdHJpZ2dlckluZGV4OiBob3ZlclN0YXRlLFxuICAgICAgICB0aW1lb3V0OiAoaG92ZXJTdGF0ZSA9PSBcInNob3dpbmcyXCIpID8gbW91c2VvdmVyRGVsYXkgOiBudWxsLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhvdmVyU3RhdGUgPT0gXCJzaG93aW5nMlwiKSB7XG4gICAgICAgICAgICAgICAgc2V0SG92ZXJTdGF0ZShcInNob3duXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuXG5cbiAgICB1c2VUaW1lb3V0KHtcbiAgICAgICAgdHJpZ2dlckluZGV4OiBob3ZlclN0YXRlLFxuICAgICAgICB0aW1lb3V0OiAoaG92ZXJTdGF0ZSA9PSBcImhpZGluZ1wiKSA/IG1vdXNlb3V0VG9sZXJhbmNlRGVsYXkgOiBudWxsLFxuICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhvdmVyU3RhdGUgPT0gXCJoaWRpbmdcIikge1xuICAgICAgICAgICAgICAgIHNldEhvdmVyU3RhdGUoXCJoaWRkZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgLy9jb25zdCBbdHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQsIHNldFRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbdG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCwgc2V0VG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgLy9jb25zdCBbdG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQsIHNldFRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIGNvbnN0IGhvdmVyRGVsYXlDb3JyZWN0ZWQgPSAoaG92ZXJTdGF0ZSA9PSBcInNob3duXCIpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldE9wZW4odHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCB8fCBob3ZlckRlbGF5Q29ycmVjdGVkIHx8IHRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQpO1xuICAgIH0sIFt0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIHx8IGhvdmVyRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZF0pO1xuXG5cblxuICAgIC8vY29uc3QgdXNlVG9vbHRpcFRyaWdnZXI6IFVzZVRvb2x0aXBUcmlnZ2VyPFRyaWdnZXJUeXBlPiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVRvb2x0aXBUcmlnZ2VyKHtcbiAgICAvLyAgICByZWZFbGVtZW50UmV0dXJuXG4gICAgLy99KTogUmV0dXJuVHlwZTxVc2VUb29sdGlwVHJpZ2dlcjxUcmlnZ2VyVHlwZT4+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZVRvb2x0aXBUcmlnZ2VyXCIpO1xuICAgIC8vY29uc3QgeyBnZXRFbGVtZW50IH0gPSByZWZFbGVtZW50UmV0dXJuO1xuXG4gICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJwb2ludGVybW92ZVwiLCBlID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgc2V0VHJpZ2dlckhvdmVyKHRhcmdldCA9PSBnZXRUcmlnZ2VyRWxlbWVudCgpIGFzIE5vZGUgfHwgISFnZXRUcmlnZ2VyRWxlbWVudCgpPy5jb250YWlucyh0YXJnZXQpKTtcbiAgICB9LCB7IGNhcHR1cmU6IHRydWUgfSk7XG5cbiAgICBmdW5jdGlvbiBvblRvdWNoRW5kKGU6IFRvdWNoRXZlbnQpIHtcbiAgICAgICAgKGUudGFyZ2V0IGFzIGFueSkuZm9jdXM/LigpO1xuICAgIH1cblxuICAgIC8vZnVuY3Rpb24gdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPiB7XG4gICAgLy9jb25zdCB7IHByb3BzU3RhYmxlIH0gPSB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50KCk7XG4gICAgLy8gTm90ZTogVGhvdWdoIGl0J3MgaW1wb3J0YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGZvY3VzaW5nIGFjdGl2YXRlcyBhIHRvb2x0aXAsXG4gICAgLy8gaXQncyBwZXJmZWN0bHkgcmVhc29uYWJsZSB0aGF0IGEgY2hpbGQgZWxlbWVudCB3aWxsIGJlIHRoZSBvbmUgdGhhdCdzIGZvY3VzZWQsXG4gICAgLy8gbm90IHRoaXMgb25lLCBzbyB3ZSBkb24ndCBzZXQgdGFiSW5kZXg9MFxuICAgIC8vcHJvcHNUcmlnZ2VyLnRhYkluZGV4ID8/PSAtMTtcbiAgICBcbiAgICAvL31cblxuICAgIGNvbnN0IHsgaGFzQ3VycmVudEZvY3VzUmV0dXJuIH0gPSB1c2VIYXNDdXJyZW50Rm9jdXM8VHJpZ2dlclR5cGU+KHsgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczogeyBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkOiBzZXRUcmlnZ2VyRm9jdXNlZCwgb25DdXJyZW50Rm9jdXNlZENoYW5nZWQ6IG51bGwgfSwgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50OiBnZXRUcmlnZ2VyRWxlbWVudCB9IH0pXG5cbiAgICAvL3JldHVybiB7XG4gICAgLy8gICAgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyxcbiAgICAvLyAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm5UeXBlOiB7IG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IHNldFRyaWdnZXJGb2N1c2VkIH1cbiAgICAvL307XG5cbiAgICAvL30sIFtdKTtcblxuICAgIC8vY29uc3QgdXNlVG9vbHRpcFBvcHVwID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVG9vbHRpcCh7IHJlZkVsZW1lbnRSZXR1cm4gfTogVXNlVG9vbHRpcFBvcHVwUGFyYW1ldGVyczxQb3B1cFR5cGU+KSB7XG4gICAgZGVidWdMb2coXCJ1c2VUb29sdGlwVG9vbHRpcFwiKTtcbiAgICAvL2NvbnN0IHsgZ2V0RWxlbWVudCB9ID0gcmVmRWxlbWVudFJldHVybjtcbiAgICAvL2NvbnN0IHsgcHJvcHNTdGFibGUgfSA9IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCgpO1xuICAgIGNvbnN0IHsgaGFzQ3VycmVudEZvY3VzUmV0dXJuOiB7IHByb3BzU3RhYmxlOiBwcm9wc0ZvY3VzUG9wdXAgfSB9ID0gdXNlSGFzQ3VycmVudEZvY3VzPFBvcHVwVHlwZT4oe1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7IG9uQ3VycmVudEZvY3VzZWRDaGFuZ2VkOiBudWxsLCBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZCkgPT4geyBzZXRUb29sdGlwRm9jdXNlZChmb2N1c2VkKTsgfSkgfSxcbiAgICAgICAgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50OiBnZXRQb3B1cEVsZW1lbnQgfVxuICAgIH0pXG5cbiAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInBvaW50ZXJtb3ZlXCIsIGUgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSAoZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICBzZXRUb29sdGlwSG92ZXIodGFyZ2V0ID09IGdldFBvcHVwRWxlbWVudCgpIGFzIE5vZGUgfHwgISFnZXRQb3B1cEVsZW1lbnQoKT8uY29udGFpbnModGFyZ2V0KSk7XG4gICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuXG4gICAgLy9mdW5jdGlvbiB1c2VUb29sdGlwUG9wdXBQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UG9wdXBUeXBlPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwVHlwZT4ge1xuICAgIC8vICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcyhwcm9wc1N0YWJsZSwgcHJvcHMpO1xuICAgIC8vIH1cblxuICAgIC8vcmV0dXJuIHsgdXNlVG9vbHRpcFBvcHVwUHJvcHMgfTtcbiAgICAvL30sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzUG9wdXA6IHVzZU1lcmdlZFByb3BzKHBvcHVwUmVmUHJvcHMsIHByb3BzUG9wdXAsIHByb3BzRm9jdXNQb3B1cCksXG4gICAgICAgIHByb3BzVHJpZ2dlcjogdXNlTWVyZ2VkUHJvcHModHJpZ2dlclJlZlByb3BzLCBwcm9wc1RyaWdnZXIsIGhhc0N1cnJlbnRGb2N1c1JldHVybi5wcm9wc1N0YWJsZSwgeyBvblRvdWNoRW5kIH0pLFxuICAgICAgICB0b29sdGlwUmV0dXJuOiB7XG4gICAgICAgICAgICBpc09wZW46IG9wZW4sXG4gICAgICAgICAgICBnZXRJc09wZW46IGdldE9wZW5cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sdGlwUG9wdXBQYXJhbWV0ZXJzPFBvcHVwVHlwZSBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICByZWZFbGVtZW50UmV0dXJuOiBSZXF1aXJlZDxQaWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFBvcHVwVHlwZT5bXCJyZWZFbGVtZW50UmV0dXJuXCJdLCBcImdldEVsZW1lbnRcIj4+XG59XG4iLCJpbXBvcnQgeyBDb250ZXh0LCBjcmVhdGVDb250ZXh0LCBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgR2V0SW5kZXgsIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBGb3J3YXJkRm4sIGZvcndhcmRSZWYsIG1lbW8sIHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbWVtb0ZvcndhcmRSZWY8VCBleHRlbmRzIEZvcndhcmRGbjxhbnksIGFueT4+KGZuOiBUKTogVCB7XG4gICAgcmV0dXJuIG1lbW8oZm9yd2FyZFJlZihmbikpIGFzIFQ7Ly8ocHJvcHM6IFBhcmFtZXRlcnM8VD5bMF0pID0+IFJldHVyblR5cGU8VD47XG59XG5cbmV4cG9ydCBjb25zdCBDb250ZXh0RGVmYXVsdHMgPSB7XG4gICAgY29sbGF0b3I6IGNyZWF0ZUNvbnRleHQ8SW50bC5Db2xsYXRvciB8IG51bGw+KG51bGwpLFxuICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZTogY3JlYXRlQ29udGV4dDxudW1iZXI+KDAuMSksXG4gICAgdHlwZWFoZWFkVGltZW91dDogY3JlYXRlQ29udGV4dCgxMDAwKSxcbiAgICBub1R5cGVhaGVhZDogY3JlYXRlQ29udGV4dChmYWxzZSksXG4gICAgZ2V0SW5kZXg6IGNyZWF0ZUNvbnRleHQ8R2V0SW5kZXg8YW55Pj4odiA9PiB2LnByb3BzLmluZGV4KSxcbiAgICBkaXNhYmxlQXJyb3dLZXlzOiBjcmVhdGVDb250ZXh0KGZhbHNlKSxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXM6IGNyZWF0ZUNvbnRleHQoZmFsc2UpLFxuICAgIGdldFdpbmRvdzogY3JlYXRlQ29udGV4dCgoKSA9PiBnbG9iYWxUaGlzLndpbmRvdyBhcyBXaW5kb3cpLFxuICAgIGZvY3VzT3BlbmVyOiBjcmVhdGVDb250ZXh0KChlOiBhbnkpID0+IGU/LmZvY3VzPy4oKSksXG4gICAgZ2V0VGV4dDogY3JlYXRlQ29udGV4dCgoZTogYW55KSA9PiAoZT8udGV4dENvbnRlbnQgPz8gXCJcIikgYXMgc3RyaW5nIHwgbnVsbCksXG4gICAgc2VsZWN0aW9uTW9kZTogY3JlYXRlQ29udGV4dDxVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8YW55PltcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiXVtcInNlbGVjdGlvbk1vZGVcIl0+KFwiYWN0aXZhdGlvblwiKSxcbn1cblxudHlwZSBEZWZhdWx0RXhjZXB0cyA9IGtleW9mIHR5cGVvZiBDb250ZXh0RGVmYXVsdHM7XG5cbnR5cGUgQ29udGV4dFR5cGU8VCBleHRlbmRzIENvbnRleHQ8YW55Pj4gPSBUIGV4dGVuZHMgQ29udGV4dDxpbmZlciBDPj8gQyA6IHVua25vd247XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEZWZhdWx0PEsgZXh0ZW5kcyBEZWZhdWx0RXhjZXB0cz4oY29udGV4dDogSywgdXNlclZhbHVlOiB1bmRlZmluZWQgfCBDb250ZXh0VHlwZTwodHlwZW9mIENvbnRleHREZWZhdWx0cylbS10+KTogQ29udGV4dFR5cGU8KHR5cGVvZiBDb250ZXh0RGVmYXVsdHMpW0tdPiB7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdXNlQ29udGV4dDxDb250ZXh0VHlwZTwodHlwZW9mIENvbnRleHREZWZhdWx0cylbS10+PihDb250ZXh0RGVmYXVsdHNbY29udGV4dF0gYXMgQ29udGV4dDxhbnk+KTtcbiAgICByZXR1cm4gdXNlclZhbHVlID8/IGRlZmF1bHRWYWx1ZTtcbn1cblxuZXhwb3J0IGNvbnN0IFBhcmVudERlcHRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoMCk7XG5cbnR5cGUgUGFydGlhbEV4Y2VwdEQ8VCwgS2VlcFJlcXVpcmVkIGV4dGVuZHMga2V5b2YgVD4gPSBQYXJ0aWFsPFBpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLZWVwUmVxdWlyZWQ+Pj4gJiBQaWNrPFQsIEtlZXBSZXF1aXJlZD47XG5leHBvcnQgdHlwZSBQYXJ0aWFsRXhjZXB0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFBhcnRpYWxFeGNlcHREPFQsIEs+OyIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlQWNjb3JkaW9uLCBVc2VBY2NvcmRpb25Db250ZXh0LCBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzLCBVc2VBY2NvcmRpb25SZXR1cm5UeXBlLCB1c2VBY2NvcmRpb25TZWN0aW9uLCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbywgVXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnMsIFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlIH0gZnJvbSBcIi4uL3VzZS1hY2NvcmRpb25cIjtcbmltcG9ydCB7IEhlYWRpbmcgfSBmcm9tIFwiLi9oZWFkaW5nXCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiwgUGFydGlhbEV4Y2VwdCwgdXNlRGVmYXVsdCB9IGZyb20gXCIuL3V0aWxcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuaW50ZXJmYWNlIEFjY29yZGlvblByb3BzQmFzZTxIZWFkZXJCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VBY2NvcmRpb25QYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQsIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvPiwgXCJhY2NvcmRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VBY2NvcmRpb25QYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQsIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvPiwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlQWNjb3JkaW9uUGFyYW1ldGVyczxIZWFkZXJCdXR0b25FbGVtZW50LCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4sIFwibWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZUFjY29yZGlvblJldHVyblR5cGU8SGVhZGVyQnV0dG9uRWxlbWVudCwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+Pjtcbn1cblxuaW50ZXJmYWNlIEFjY29yZGlvblNlY3Rpb25Qcm9wc0Jhc2U8SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudCwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+LCBcImFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJCdXR0b25FbGVtZW50LCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudCwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+LCBcImJ1dHRvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQsIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvPiwgXCJyb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudCwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+LCBcInByZXNzUGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlPEhlYWRlckVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQsIEJvZHlFbGVtZW50Pj47XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBBY2NvcmRpb25Qcm9wczxIZWFkZXJCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PEFjY29yZGlvblByb3BzQmFzZTxIZWFkZXJCdXR0b25FbGVtZW50PiwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlQWNjb3JkaW9uUmV0dXJuVHlwZTxIZWFkZXJCdXR0b25FbGVtZW50LCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFjY29yZGlvblNlY3Rpb25Qcm9wczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PEFjY29yZGlvblNlY3Rpb25Qcm9wc0Jhc2U8SGVhZGVyRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCwgQm9keUVsZW1lbnQ+LCBcImluZGV4XCIgfCBcInRhZ0J1dHRvblwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlPEhlYWRlckVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQsIEJvZHlFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cblxuY29uc3QgQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUFjY29yZGlvbkNvbnRleHQ8YW55LCBhbnk+PihudWxsISk7XG5leHBvcnQgY29uc3QgQWNjb3JkaW9uID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gQWNjb3JkaW9uPEhlYWRlckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBuYXZpZ2F0ZVBhc3RFbmQsXG4gICAgbmF2aWdhdGVQYXN0U3RhcnQsXG4gICAgcGFnZU5hdmlnYXRpb25TaXplLFxuICAgIHJlbmRlcixcbiAgICAuLi5fcmVzdFxufTogQWNjb3JkaW9uUHJvcHM8SGVhZGVyQnV0dG9uRWxlbWVudD4sIHJlZj86IFJlZjxhbnk+KSB7XG5cbiAgICBjb25zdCBpbmZvID0gdXNlQWNjb3JkaW9uPEhlYWRlckJ1dHRvbkVsZW1lbnQsIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvPih7XG4gICAgICAgIGFjY29yZGlvblBhcmFtZXRlcnM6IHsgaW5pdGlhbEluZGV4IH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUFycm93S2V5c1wiLCBkaXNhYmxlQXJyb3dLZXlzKSxcbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5czogdXNlRGVmYXVsdChcImRpc2FibGVIb21lRW5kS2V5c1wiLCBkaXNhYmxlSG9tZUVuZEtleXMpLFxuICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZDogbmF2aWdhdGVQYXN0RW5kID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IG5hdmlnYXRlUGFzdFN0YXJ0ID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplOiB1c2VEZWZhdWx0KFwicGFnZU5hdmlnYXRpb25TaXplXCIsIHBhZ2VOYXZpZ2F0aW9uU2l6ZSlcbiAgICAgICAgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9XG4gICAgfSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxBY2NvcmRpb25TZWN0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17aW5mby5jb250ZXh0fT57cmVuZGVyKGluZm8pfTwvQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufSlcbi8qXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckFjY29yZGlvblNlY3Rpb248SGVhZGVyQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbWFrZVByb3BzSGVhZGluZ0NvbnRhaW5lciwgbWFrZVByb3BzSGVhZGluZ0J1dHRvbiwgbWFrZVByb3BzQm9keSwgdGFnQm9keSwgdGFnSGVhZGluZ0J1dHRvbiB9OiB7IHRhZ0hlYWRpbmdCdXR0b246IEVsZW1lbnRUb1RhZzxIZWFkZXJCdXR0b25FbGVtZW50PjsgdGFnQm9keTogRWxlbWVudFRvVGFnPEJvZHlFbGVtZW50PjsgbWFrZVByb3BzSGVhZGluZ0NvbnRhaW5lcihpbmZvOiBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZTxIZWFkZXJCdXR0b25FbGVtZW50LCBCb2R5RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJDb250YWluZXJFbGVtZW50PiwgbWFrZVByb3BzSGVhZGluZ0J1dHRvbihpbmZvOiBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZTxIZWFkZXJCdXR0b25FbGVtZW50LCBCb2R5RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJCdXR0b25FbGVtZW50PiwgbWFrZVByb3BzQm9keShpbmZvOiBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZTxIZWFkZXJCdXR0b25FbGVtZW50LCBCb2R5RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGU8SGVhZGVyQnV0dG9uRWxlbWVudCwgQm9keUVsZW1lbnQ+KTogVk5vZGU8YW55PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIDxIZWFkaW5nPEhlYWRlckNvbnRhaW5lckVsZW1lbnQ+IHsuLi5tYWtlUHJvcHNIZWFkaW5nQ29udGFpbmVyKGluZm8pfSBoZWFkaW5nPXtjcmVhdGVFbGVtZW50KHRhZ0hlYWRpbmdCdXR0b24gYXMgbmV2ZXIsIChtYWtlUHJvcHNIZWFkaW5nQnV0dG9uKGluZm8pKSl9PlxuICAgICAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdCb2R5IGFzIG5ldmVyLCAobWFrZVByb3BzQm9keShpbmZvKSkpfVxuICAgICAgICAgICAgICAgIDwvSGVhZGluZz5cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufSovXG5cbmV4cG9ydCBjb25zdCBBY2NvcmRpb25TZWN0aW9uID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gQWNjb3JkaW9uU2VjdGlvbjxIZWFkZXJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIG9wZW4sXG4gICAgaW5kZXgsXG4gICAgdGFnQnV0dG9uLFxuICAgIGRpc2FibGVkLFxuICAgIGJvZHlSb2xlLFxuICAgIG9uUHJlc3MsXG4gICAgZXhjbHVkZSxcbiAgICBoaWRkZW4sXG4gICAgcmVuZGVyLFxufTogQWNjb3JkaW9uU2VjdGlvblByb3BzPEhlYWRlckNvbnRhaW5lckVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQsIEJvZHlFbGVtZW50PiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBY2NvcmRpb25TZWN0aW9uQ29udGV4dCkgYXMgVXNlQWNjb3JkaW9uQ29udGV4dDxIZWFkZXJCdXR0b25FbGVtZW50LCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz47XG4gICAgY29uc3QgaW5mbyA9IHVzZUFjY29yZGlvblNlY3Rpb248SGVhZGVyQ29udGFpbmVyRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCwgQm9keUVsZW1lbnQ+KHtcbiAgICAgICAgYnV0dG9uUGFyYW1ldGVyczogeyBkaXNhYmxlZDogZGlzYWJsZWQgPz8gZmFsc2UsIHRhZ0J1dHRvbiwgb25QcmVzczogb25QcmVzcyA/PyBudWxsIH0sXG4gICAgICAgIGFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzOiB7IG9wZW4sIGJvZHlSb2xlOiBib2R5Um9sZSA/PyBcInJlZ2lvblwiIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXgsIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczogeyBleGNsdWRlIH0sXG4gICAgICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgY29udGV4dFxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiByZW5kZXIoaW5mbyk7XG59KVxuXG5leHBvcnQgZnVuY3Rpb24gQWNjb3JkaW9uRGVtbygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8QWNjb3JkaW9uXG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzPXtmYWxzZX1cbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5cz17ZmFsc2V9XG4gICAgICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uPVwidmVydGljYWxcIlxuICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplPXswLjF9XG4gICAgICAgICAgICByZW5kZXI9e2luZm8gPT5cbiAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxBY2NvcmRpb25TZWN0aW9uRGVtbyBpbmRleD17MH0gLz47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kPVwid3JhcFwiXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydD1cIndyYXBcIiAvPlxuICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBBY2NvcmRpb25TZWN0aW9uRGVtbyh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPEFjY29yZGlvblNlY3Rpb248YW55LCBIVE1MQnV0dG9uRWxlbWVudCwgSFRNTFBhcmFncmFwaEVsZW1lbnQ+XG4gICAgICAgICAgICBib2R5Um9sZT1cInJlZ2lvblwiXG4gICAgICAgICAgICBkaXNhYmxlZD17ZmFsc2V9XG4gICAgICAgICAgICBleGNsdWRlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBoaWRkZW49e2ZhbHNlfVxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgb25QcmVzcz17bnVsbH1cbiAgICAgICAgICAgIG9wZW49e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHJlbmRlcj17aW5mbyA9PiAoXG4gICAgICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz17PD48c3Bhbj5BY2NvcmRpb24gc2VjdGlvbiAke2luZGV4fTwvc3Bhbj48YnV0dG9uIHsuLi5pbmZvLnByb3BzSGVhZGVyQnV0dG9ufT5Ub2dnbGUgb3BlbjwvYnV0dG9uPjwvPn0+XG4gICAgICAgICAgICAgICAgICAgIDxwIHsuLi5pbmZvLnByb3BzQm9keX0gaGlkZGVuPXtpbmZvLmFjY29yZGlvblNlY3Rpb25SZXR1cm4uZXhwYW5kZWR9PlxuICAgICAgICAgICAgICAgICAgICAgICAgQWNjb3JkaW9uIGJvZHkgY29udGVudFxuICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPC9IZWFkaW5nPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHRhZ0J1dHRvbj1cImJ1dHRvblwiXG4gICAgICAgIC8+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VCdXR0b24sIFVzZUJ1dHRvblBhcmFtZXRlcnMsIFVzZUJ1dHRvblJldHVyblR5cGUgfSBmcm9tIFwiLi4vdXNlLWJ1dHRvblwiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcnRpYWxFeGNlcHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmludGVyZmFjZSBCdXR0b25Qcm9wc0Jhc2U8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBPbWl0PEdldDxVc2VCdXR0b25QYXJhbWV0ZXJzPEU+LCBcImJ1dHRvblBhcmFtZXRlcnNcIj4sIFwicm9sZVwiPixcbiAgICBHZXQ8VXNlQnV0dG9uUGFyYW1ldGVyczxFPiwgXCJwcmVzc1BhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUJ1dHRvblBhcmFtZXRlcnM8RT4sIFwicmVmRWxlbWVudFBhcmFtZXRlcnNcIj4ge1xuICAgIHJlZj86IFJlZjxVc2VCdXR0b25SZXR1cm5UeXBlPEU+Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCdXR0b25Qcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PEJ1dHRvblByb3BzQmFzZTxFPiwgXCJ0YWdCdXR0b25cIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VCdXR0b25SZXR1cm5UeXBlPEU+KTogVk5vZGU8YW55Pjtcbn1cbi8qXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckJ1dHRvbjxFIGV4dGVuZHMgRWxlbWVudD4oeyB0YWdCdXR0b24sIHByb3BzQnV0dG9uIH06IHsgdGFnQnV0dG9uOiBFbGVtZW50VG9UYWc8RT4sIHByb3BzQnV0dG9uOiAoaW5mbzogVXNlQnV0dG9uUmV0dXJuVHlwZTxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlQnV0dG9uUmV0dXJuVHlwZTxFPikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdCdXR0b24gYXMgYW55LCBwcm9wc0J1dHRvbihpbmZvKSk7XG4gICAgfVxufSovXG5cbmV4cG9ydCBjb25zdCBCdXR0b24gPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBCdXR0b248RSBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnQnV0dG9uLCBvblByZXNzLCBwcmVzc2VkLCByZW5kZXIsIGRpc2FibGVkLCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCwgZXhjbHVkZSB9OiBCdXR0b25Qcm9wczxFPiwgcmVmOiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGluZm8gPSB1c2VCdXR0b248RT4oe1xuICAgICAgICBidXR0b25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgdGFnQnV0dG9uOiB0YWdCdXR0b24sXG4gICAgICAgICAgICBvblByZXNzOiBvblByZXNzID8/IG51bGwsXG4gICAgICAgICAgICBwcmVzc2VkLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlXG4gICAgICAgIH0sIFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZSB9LCBcbiAgICAgICAgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfVxuICAgIH0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vQnV0dG9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxCdXR0b248SFRNTEJ1dHRvbkVsZW1lbnQ+IGRpc2FibGVkPXtmYWxzZX0gZXhjbHVkZT17dW5kZWZpbmVkfSBwcmVzc2VkPXtudWxsfSB0YWdCdXR0b249XCJidXR0b25cIiBvblByZXNzPXtudWxsfSByZW5kZXI9e2luZm8gPT4gKDxidXR0b24gey4uLmluZm8ucHJvcHN9PkJ1dHRvbjwvYnV0dG9uPil9IC8+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VDaGVja2JveCwgVXNlQ2hlY2tib3hQYXJhbWV0ZXJzLCBVc2VDaGVja2JveFJldHVyblR5cGUgfSBmcm9tIFwiLi4vdXNlLWNoZWNrYm94XCI7XG5pbXBvcnQgeyBMYWJlbFBvc2l0aW9uIH0gZnJvbSBcIi4uL3VzZS1sYWJlbFwiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcnRpYWxFeGNlcHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmludGVyZmFjZSBDaGVja2JveFByb3BzQmFzZTxJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlQ2hlY2tib3hQYXJhbWV0ZXJzPExhYmVsUG9zaXRpb24sIEksIEw+LCBcImNoZWNrYm94TGlrZVBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94UGFyYW1ldGVyczxMYWJlbFBvc2l0aW9uLCBJLCBMPiwgXCJjaGVja2JveFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94UGFyYW1ldGVyczxMYWJlbFBvc2l0aW9uLCBJLCBMPiwgXCJsYWJlbFBhcmFtZXRlcnNcIj4ge1xuICAgIHJlZj86IFJlZjxVc2VDaGVja2JveFJldHVyblR5cGU8SSwgTD4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94UHJvcHM8SSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFBhcnRpYWxFeGNlcHQ8Q2hlY2tib3hQcm9wc0Jhc2U8SSwgTD4sIFwidGFnSW5wdXRcIiB8IFwidGFnTGFiZWxcIiB8IFwibGFiZWxQb3NpdGlvblwiIHwgXCJhcmlhTGFiZWxcIiB8IFwiY2hlY2tlZFwiIHwgXCJvbkNoZWNrZWRDaGFuZ2VcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VDaGVja2JveFJldHVyblR5cGU8SSwgTD4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZTxJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQsIEluZm9UeXBlPih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZVByb3BzSW5wdXQsIG1ha2VQcm9wc0xhYmVsIH06IERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIEwsIEluZm9UeXBlPikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogSW5mb1R5cGUpOiBWTm9kZTxhbnk+IHtcblxuICAgICAgICBjb25zdCBpbnB1dFByb3BzID0gKG1ha2VQcm9wc0lucHV0KGluZm8pKVxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5sYWJlbFByb3BzIH0gPSAobWFrZVByb3BzTGFiZWwoaW5mbykpXG4gICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIikge1xuXG4gICAgICAgICAgICAvL2NvbnN0IGlucHV0UHJvcHMgPSBtb2RpZnlJbnB1dFByb3BzKG1ha2VJbnB1dFByb3BzKGluZm8pKTtcbiAgICAgICAgICAgIC8vY29uc3QgeyBjaGlsZHJlbiwgLi4ubGFiZWxQcm9wcyB9ID0gbW9kaWZ5TGFiZWxQcm9wcyhtYWtlTGFiZWxQcm9wcyhpbmZvKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gY3JlYXRlRWxlbWVudCh0YWdJbnB1dCBhcyBuZXZlciwgaW5wdXRQcm9wcyk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwgYXMgbmV2ZXIsIHsgLi4ubGFiZWxQcm9wcywgY2hpbGRyZW46IDw+e2lucHV0fXtjaGlsZHJlbn08Lz4gfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gY3JlYXRlRWxlbWVudCh0YWdJbnB1dCBhcyBuZXZlciwgaW5wdXRQcm9wcyk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwgYXMgbmV2ZXIsIHsgY2hpbGRyZW4sIC4uLmxhYmVsUHJvcHMgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAge2lucHV0fVxuICAgICAgICAgICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCghIWlucHV0UHJvcHNbXCJhcmlhLWxhYmVsXCJdKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0lucHV0IGFzIG5ldmVyLCBpbnB1dFByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQsIEluZm9UeXBlPiB7XG4gICAgbGFiZWxQb3NpdGlvbjogXCJ3cmFwcGluZ1wiIHwgXCJzZXBhcmF0ZVwiIHwgXCJoaWRkZW5cIixcbiAgICB0YWdJbnB1dDogRWxlbWVudFRvVGFnPEk+LFxuICAgIHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TD4sXG4gICAgbWFrZVByb3BzSW5wdXQ6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST4sXG4gICAgbWFrZVByb3BzTGFiZWw6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TD5cbn1cbi8qXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRSZW5kZXJDaGVja2JveFBhcmFtZXRlcnM8SSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIEwsIFVzZUNoZWNrYm94UmV0dXJuVHlwZTxJLCBMPj4geyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyQ2hlY2tib3g8SSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50Pih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZVByb3BzSW5wdXQsIG1ha2VQcm9wc0xhYmVsIH06IERlZmF1bHRSZW5kZXJDaGVja2JveFBhcmFtZXRlcnM8SSwgTD4pIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZTxJLCBMLCBVc2VDaGVja2JveFJldHVyblR5cGU8SSwgTD4+KHsgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsLCBtYWtlUHJvcHNJbnB1dCwgbWFrZVByb3BzTGFiZWwgfSk7XG59Ki9cblxuZXhwb3J0IGNvbnN0IENoZWNrYm94ID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gQ2hlY2tib3g8SSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgY2hlY2tlZCxcbiAgICBkaXNhYmxlZCxcbiAgICB0YWdMYWJlbCxcbiAgICBsYWJlbFBvc2l0aW9uLFxuICAgIHRhZ0lucHV0LFxuICAgIGFyaWFMYWJlbCxcbiAgICBvbkNoZWNrZWRDaGFuZ2UsXG4gICAgcmVuZGVyXG59OiBDaGVja2JveFByb3BzPEksIEw+LCByZWY6IFJlZjxhbnk+KSB7XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHJlZkVsZW1lbnRJbnB1dFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxJPih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHJlZkVsZW1lbnRMYWJlbFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxMPih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcblxuICAgIGNvbnN0IGNoZWNrYm94ID0gdXNlQ2hlY2tib3g8TGFiZWxQb3NpdGlvbiwgSSwgTD4oe1xuICAgICAgICBjaGVja2JveExpa2VQYXJhbWV0ZXJzOiB7IGNoZWNrZWQ6IGNoZWNrZWQgPz8gZmFsc2UsIGRpc2FibGVkOiBkaXNhYmxlZCA/PyBmYWxzZSB9LFxuICAgICAgICBjaGVja2JveFBhcmFtZXRlcnM6IHsgb25DaGVja2VkQ2hhbmdlIH0sXG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczogeyBhcmlhTGFiZWw6IGFyaWFMYWJlbCwgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsIH0sXG4gICAgICAgIHJlZkVsZW1lbnRJbnB1dFJldHVybixcbiAgICAgICAgcmVmRWxlbWVudExhYmVsUmV0dXJuXG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGNoZWNrYm94KTtcblxuXG4gICAgcmV0dXJuIHJlbmRlcihjaGVja2JveCk7XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIERlbW9DaGVja2JveCgpIHtcbiAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPENoZWNrYm94PEhUTUxJbnB1dEVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQ+IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIGNoZWNrZWQ9e2NoZWNrZWR9IGRpc2FibGVkPXtmYWxzZX0gb25DaGVja2VkQ2hhbmdlPXsoZSkgPT4gc2V0Q2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKX0gcmVuZGVyPXtcbiAgICAgICAgICAgIGluZm8gPT4gKFxuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB7Li4uaW5mby5wcm9wc0lucHV0fSAvPjxsYWJlbCB7Li4uaW5mby5wcm9wc0xhYmVsfSAvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHRhZ0lucHV0PVwiaW5wdXRcIlxuICAgICAgICAgICAgdGFnTGFiZWw9XCJsYWJlbFwiXG4gICAgICAgICAgICBhcmlhTGFiZWw9e251bGx9XG4gICAgICAgIC8+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgUmVmLCBSZW5kZXJhYmxlUHJvcHMsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFVzZUNoZWNrYm94UmV0dXJuVHlwZSB9IGZyb20gXCIuLi91c2UtY2hlY2tib3hcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwQ29udGV4dCwgQ2hlY2tib3hHcm91cEluZm8sIHVzZUNoZWNrYm94R3JvdXAsIHVzZUNoZWNrYm94R3JvdXBDaGlsZCwgVXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVycywgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZSwgVXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIHVzZUNoZWNrYm94R3JvdXBQYXJlbnQsIFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzLCBVc2VDaGVja2JveEdyb3VwUGFyZW50UmV0dXJuVHlwZSwgVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGUgfSBmcm9tIFwiLi4vdXNlLWNoZWNrYm94LWdyb3VwXCI7XG5pbXBvcnQgeyBDaGVja2JveCwgQ2hlY2tib3hQcm9wcywgZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSB9IGZyb20gXCIuL2NoZWNrYm94XCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiwgUGFydGlhbEV4Y2VwdCwgdXNlRGVmYXVsdCB9IGZyb20gXCIuL3V0aWxcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcbi8vdHlwZSBHZXQyPFQsIEsgZXh0ZW5kcyBrZXlvZiBULCBLMiBleHRlbmRzIGtleW9mIFRbS10+ID0gVFtLXVtLMl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tib3hHcm91cFByb3BzQmFzZTxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgQ2hlY2tib3hHcm91cEluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQ+PiBleHRlbmRzXG4gICAgUmVuZGVyYWJsZVByb3BzPHt9PixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQsIE0+LCBcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVyczxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgTT4sIFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQsIE0+LCBcInNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVyczxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgTT4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzPFBhcmVudEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50LCBNPiwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4ge1xuICAgIHJlZj86IFJlZjxVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgTT4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94R3JvdXBQYXJlbnRQcm9wc0Jhc2U8VENFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4sIFwicHJlc3NQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+LCBcInJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+LCBcInNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+LCBcInRleHRDb250ZW50UGFyYW1ldGVyc1wiPixcbiAgICBPbWl0PEdldDxVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+LCBcImNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnNcIj4sIFwiY2hlY2tib3hJbmZvXCI+IHtcbiAgICAvL3N1YkluZm86IEdldDxVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIEMsIEssIEM+LCBcInN1YkluZm9cIj47XG4gICAgcmVmPzogUmVmPFVzZUNoZWNrYm94R3JvdXBQYXJlbnRSZXR1cm5UeXBlPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94R3JvdXBDaGlsZFByb3BzQmFzZTxUQ0UgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgLy8gR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPENCR1N1YkluZm8sIEssIENCR1N1YkluZm8+LCBcImFzQ2hlY2tib3hcIiwgXCJjaGVja2JveFwiPixcbiAgICAvLyBHZXQyPFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8Q0JHU3ViSW5mbywgSywgQ0JHU3ViSW5mbz4sIFwiYXNDaGVja2JveFwiLCBcImxhYmVsXCI+LFxuICAgIC8vIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxDQkdTdWJJbmZvLCBLLCBDQkdTdWJJbmZvPiwgXCJhc0NoZWNrYm94XCIsIFwiY2hlY2tib3hMaWtlXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4sIFwiY2hlY2tib3hHcm91cENoaWxkXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+LCBcInJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4sIFwic29ydGFibGVDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8VENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+PiwgXCJ0ZXh0Q29udGVudFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8VENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+PiwgXCJwcmVzc1BhcmFtZXRlcnNcIj4ge1xuICAgIC8vc3ViSW5mbzogR2V0PFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBDQkdTdWJJbmZvLCBLLCBDQkdTdWJJbmZvPiwgXCJzdWJJbmZvXCI+O1xuICAgIHJlZj86IFJlZjxVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4+O1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwUHJvcHM8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIENoZWNrYm94R3JvdXBJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50Pj4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PENoZWNrYm94R3JvdXBQcm9wc0Jhc2U8UGFyZW50RWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQsIE0+LCBcIm5hdmlnYXRpb25EaXJlY3Rpb25cIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgTT4pOiBWTm9kZTxhbnk+O1xufVxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwUGFyZW50UHJvcHM8VENFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PENoZWNrYm94R3JvdXBQYXJlbnRQcm9wc0Jhc2U8VENFPiwgXCJpbmRleFwiIHwgXCJnZXRTb3J0VmFsdWVcIiB8IFwiZm9jdXNTZWxmXCI+IHtcbiAgICByZW5kZXIocGFyZW50Q2hlY2tib3hJbmZvOiBVc2VDaGVja2JveEdyb3VwUGFyZW50UmV0dXJuVHlwZTxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+KTogVk5vZGU8YW55Pjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tib3hHcm91cENoaWxkUHJvcHM8VENFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PENoZWNrYm94R3JvdXBDaGlsZFByb3BzQmFzZTxUQ0U+LCBcImluZGV4XCIgfCBcImNoZWNrZWRcIiB8IFwib25DaGFuZ2VGcm9tUGFyZW50XCIgfCBcImdldFNvcnRWYWx1ZVwiIHwgXCJmb2N1c1NlbGZcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4pOiBWTm9kZTxhbnk+O1xufVxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVENFIGV4dGVuZHMgSW5wdXRFbGVtZW50IHwgTGFiZWxFbGVtZW50PiBleHRlbmRzIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4+IHsgfVxuLy9leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwUGFyYW1ldGVyczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBUQ0UgZXh0ZW5kcyBJbnB1dFR5cGUgfCBMYWJlbFR5cGU+IGV4dGVuZHMgRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGUsIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlPGFueSwgVENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+Pj4ge1xuLy8gICAgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuO1xuLy99XG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGQ8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudCwgVENFIGV4dGVuZHMgSW5wdXRUeXBlIHwgTGFiZWxUeXBlPih7IHRhZ0lucHV0LCB0YWdMYWJlbCwgbGFiZWxQb3NpdGlvbiwgbWFrZVByb3BzSW5wdXQsIG1ha2VQcm9wc0xhYmVsIH06IERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlLCBUQ0U+KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChncm91cEluZm86IFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGU8VENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+Pik6IFZOb2RlPGFueT4ge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZTxJbnB1dFR5cGUsIExhYmVsVHlwZSwgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZTxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+Pih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZVByb3BzSW5wdXQsIG1ha2VQcm9wc0xhYmVsIH0pKGdyb3VwSW5mbyk7XG4gICAgfVxufSovXG5cbmludGVyZmFjZSBGb288SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PENoZWNrYm94UHJvcHM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBcImNoZWNrZWRcIiB8IFwib25DaGVja2VkQ2hhbmdlXCI+IHtcbiAgICBvbkNoZWNrZWRDaGFuZ2VTdGFydCgpOiB2b2lkO1xuICAgIG9uQ2hlY2tlZENoYW5nZUVuZChleD86IGFueSk6IHZvaWQ7XG59XG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwUGFyZW50PElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgcmVuZGVyLCBkaXNhYmxlZCwgZ2V0RG9jdW1lbnQsIGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQ2hlY2tlZENoYW5nZVN0YXJ0LCBvbkNoZWNrZWRDaGFuZ2VFbmQsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UgfTogRm9vPElucHV0VHlwZSwgTGFiZWxUeXBlPikge1xuICAgIHJldHVybiBmdW5jdGlvbiAocGFyZW50SW5mbzogVXNlQ2hlY2tib3hHcm91cFBhcmVudFJldHVyblR5cGVJbmZvLCBtb2RpZnlDb250cm9sUHJvcHM6IFByb3BNb2RpZmllcjxhbnk+KSB7XG4gICAgICAgIGNvbnN0IHsgY2hlY2tib3hHcm91cFBhcmVudDogeyBjaGVja2VkLCBvblBhcmVudENoZWNrZWRDaGFuZ2UgfSB9ID0gcGFyZW50SW5mbztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxDaGVja2JveDxJbnB1dFR5cGUsIExhYmVsVHlwZT5cbiAgICAgICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9XG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbj17bGFiZWxQb3NpdGlvbn1cbiAgICAgICAgICAgICAgICByZW5kZXI9eyhpbmZvLCBtb2RpZnlJbnB1dFByb3BzLCBtb2RpZnlMYWJlbFByb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXIoaW5mbywgKHByb3BzKSA9PiBtb2RpZnlDb250cm9sUHJvcHMobW9kaWZ5SW5wdXRQcm9wcyhwcm9wcykpLCBtb2RpZnlMYWJlbFByb3BzKVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyKGluZm8sIG1vZGlmeUlucHV0UHJvcHMsIChwcm9wcykgPT4gbW9kaWZ5Q29udHJvbFByb3BzKG1vZGlmeUxhYmVsUHJvcHMocHJvcHMpIGFzIGFueSkgYXMgYW55KVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgdGFnSW5wdXQ9e3RhZ0lucHV0fVxuICAgICAgICAgICAgICAgIHRhZ0xhYmVsPXt0YWdMYWJlbH1cbiAgICAgICAgICAgICAgICBnZXRXaW5kb3c9e2dldFdpbmRvd31cbiAgICAgICAgICAgICAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U9e29uQWN0aXZlRWxlbWVudENoYW5nZX1cbiAgICAgICAgICAgICAgICBvbkNoZWNrZWRDaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhjZXB0aW9uOiBhbnk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hlY2tlZENoYW5nZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgb25QYXJlbnRDaGVja2VkQ2hhbmdlKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uID0gZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoZWNrZWRDaGFuZ2VFbmQoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICkoKVxuXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBvbkVsZW1lbnRDaGFuZ2U9e29uRWxlbWVudENoYW5nZX1cbiAgICAgICAgICAgICAgICBvbkZvY3VzZWRDaGFuZ2VkPXtvbkZvY3VzZWRDaGFuZ2VkfVxuICAgICAgICAgICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZD17b25Gb2N1c2VkSW5uZXJDaGFuZ2VkfVxuICAgICAgICAgICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U9e29uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZENoYW5nZWQ9e29uTGFzdEZvY3VzZWRDaGFuZ2VkfVxuICAgICAgICAgICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ9e29uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWR9XG4gICAgICAgICAgICAgICAgb25Nb3VudD17b25Nb3VudH1cbiAgICAgICAgICAgICAgICBvblVubW91bnQ9e29uVW5tb3VudH1cbiAgICAgICAgICAgICAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2U9e29uV2luZG93Rm9jdXNlZENoYW5nZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cDxJbnB1dFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgY2hpbGRyZW4sIGxhYmVsUG9zaXRpb24sIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcywgdGFnSW5wdXQsIHRhZ0xhYmVsIH06IERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZSwgQywgSz4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUsIExhYmVsVHlwZSwgQywgSz4sIG1vZGlmeUlucHV0UHJvcHM6IFByb3BNb2RpZmllcjxJbnB1dFR5cGU+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxUeXBlPik6IFZOb2RlPGFueT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7ZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSh7IGxhYmVsUG9zaXRpb24sIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcywgdGFnSW5wdXQsIHRhZ0xhYmVsIH0pKGluZm8sIG1vZGlmeUlucHV0UHJvcHMsIG1vZGlmeUxhYmVsUHJvcHMpfVxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufSovXG5cbmNvbnN0IFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQgPSBjcmVhdGVDb250ZXh0PENoZWNrYm94R3JvdXBDb250ZXh0PGFueSwgYW55LCBhbnk+PihudWxsISk7XG5cbmV4cG9ydCBjb25zdCBDaGVja2JveEdyb3VwID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gQ2hlY2tib3hHcm91cDxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgcmVuZGVyLFxuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgY29tcGFyZSxcbiAgICBnZXRJbmRleCxcbiAgICB1bnRhYmJhYmxlLFxuICAgIG5hdmlnYXRlUGFzdEVuZCxcbiAgICBuYXZpZ2F0ZVBhc3RTdGFydCxcbiAgICBwYWdlTmF2aWdhdGlvblNpemUsXG4gICAgY2hpbGRyZW4sXG4gICAgLi4uX3Jlc3Rcbn06IENoZWNrYm94R3JvdXBQcm9wczxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgQ2hlY2tib3hHcm91cEluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQ+PiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBpbmZvID0gdXNlQ2hlY2tib3hHcm91cDxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5czogdXNlRGVmYXVsdChcImRpc2FibGVBcnJvd0tleXNcIiwgZGlzYWJsZUFycm93S2V5cyksXG4gICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlSG9tZUVuZEtleXNcIiwgZGlzYWJsZUhvbWVFbmRLZXlzKSxcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZDogbmF2aWdhdGVQYXN0RW5kID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IG5hdmlnYXRlUGFzdFN0YXJ0ID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICAgICAgICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZTogdXNlRGVmYXVsdChcInBhZ2VOYXZpZ2F0aW9uU2l6ZVwiLCBwYWdlTmF2aWdhdGlvblNpemUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgZ2V0SW5kZXg6IHVzZURlZmF1bHQoXCJnZXRJbmRleFwiLCBnZXRJbmRleCkgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IG9uVGFiYmFibGVJbmRleENoYW5nZTogb25UYWJiYWJsZUluZGV4Q2hhbmdlID8/IG51bGwsIHVudGFiYmFibGU6IHVudGFiYmFibGUgPz8gZmFsc2UgfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgY29tcGFyZTogY29tcGFyZSA/PyBudWxsIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBjb2xsYXRvcjogdXNlRGVmYXVsdChcImNvbGxhdG9yXCIsIGNvbGxhdG9yKSxcbiAgICAgICAgICAgIG5vVHlwZWFoZWFkOiB1c2VEZWZhdWx0KFwibm9UeXBlYWhlYWRcIiwgbm9UeXBlYWhlYWQpLFxuICAgICAgICAgICAgdHlwZWFoZWFkVGltZW91dDogdXNlRGVmYXVsdChcInR5cGVhaGVhZFRpbWVvdXRcIiwgdHlwZWFoZWFkVGltZW91dClcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxVc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PlxuICAgICAgICAgICAge3JlbmRlcihpbmZvKX1cbiAgICAgICAgPC9Vc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn0pO1xuXG5leHBvcnQgY29uc3QgQ2hlY2tib3hHcm91cFBhcmVudCA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIENoZWNrYm94R3JvdXBQYXJlbnQ8VENFIGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIsICBpbmRleCwgZm9jdXNTZWxmLCBleGNsdWRlLCBoaWRkZW4sIGdldFRleHQsIG9uUHJlc3NTeW5jLCBnZXRTb3J0VmFsdWUsIC4uLl9yZXN0IH06IENoZWNrYm94R3JvdXBQYXJlbnRQcm9wczxUQ0U+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGNvbnRleHQgPSAodXNlQ29udGV4dChVc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0KSBhcyBDaGVja2JveEdyb3VwQ29udGV4dDxhbnksIFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4pO1xuXG4gICAgY29uc3QgaW5mbyA9IHVzZUNoZWNrYm94R3JvdXBQYXJlbnQ8VENFPih7XG5cbiAgICAgICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczogeyBjaGVja2JveEluZm86IHsgY2hlY2tib3hDaGlsZFR5cGU6IFwicGFyZW50XCIgfSB9LFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiB7IGdldFNvcnRWYWx1ZSB9LFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZSwgb25QcmVzc1N5bmMsIGZvY3VzU2VsZiB9LFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnM6IHsgZ2V0VGV4dDogdXNlRGVmYXVsdChcImdldFRleHRcIiwgZ2V0VGV4dCkgfVxuICAgIH0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcbn0pXG5cbmV4cG9ydCBjb25zdCBDaGVja2JveEdyb3VwQ2hpbGQgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBDaGVja2JveEdyb3VwQ2hpbGQ8VENFIGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluZGV4LFxuICAgIGV4Y2x1ZGUsXG4gICAgb25QcmVzc1N5bmMsXG4gICAgcmVuZGVyLFxuICAgIGNoZWNrZWQsXG4gICAgb25DaGFuZ2VGcm9tUGFyZW50LFxuICAgIGdldFNvcnRWYWx1ZSxcbiAgICBoaWRkZW4sXG4gICAgZ2V0VGV4dCxcbiAgICBmb2N1c1NlbGYsXG4gICAgLi4uX3Jlc3Rcbn06IENoZWNrYm94R3JvdXBDaGlsZFByb3BzPFRDRT4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgY29udGV4dCA9ICh1c2VDb250ZXh0KFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQpIGFzIENoZWNrYm94R3JvdXBDb250ZXh0PGFueSwgVENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+Pik7XG4gICAgY29uc3QgaW5mbyA9IHVzZUNoZWNrYm94R3JvdXBDaGlsZCh7XG4gICAgICAgIGNoZWNrYm94R3JvdXBDaGlsZDogeyBjaGVja2VkLCBvbkNoYW5nZUZyb21QYXJlbnQgfSxcbiAgICAgICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczoge30sXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogeyBnZXRUZXh0OiB1c2VEZWZhdWx0KFwiZ2V0VGV4dFwiLCBnZXRUZXh0KSB9LFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiB7IGdldFNvcnRWYWx1ZSB9LFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZSwgb25QcmVzc1N5bmMsIGZvY3VzU2VsZiB9XG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2hlY2tib3hHcm91cERlbW8oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPENoZWNrYm94R3JvdXA8SFRNTERpdkVsZW1lbnQsIEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICAgICAgICBjb2xsYXRvcj17bnVsbH1cbiAgICAgICAgICAgIGRpc2FibGVBcnJvd0tleXM9e2ZhbHNlfVxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzPXtmYWxzZX1cbiAgICAgICAgICAgIHVudGFiYmFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kPVwid3JhcFwiXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydD1cIndyYXBcIlxuICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbj1cInZlcnRpY2FsXCJcbiAgICAgICAgICAgIG5vVHlwZWFoZWFkPXtmYWxzZX1cbiAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZT17bnVsbH1cbiAgICAgICAgICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZT17MC4xfVxuICAgICAgICAgICAgdHlwZWFoZWFkVGltZW91dD17MTAwMH1cbiAgICAgICAgICAgIGNvbXBhcmU9eyhsaHMsIHJocykgPT4geyByZXR1cm4gbGhzLmluZGV4IC0gcmhzLmluZGV4OyB9fVxuICAgICAgICAgICAgZ2V0SW5kZXg9e3Zub2RlID0+IHZub2RlLnByb3BzLmluZGV4fVxuICAgICAgICAgICAgcmVuZGVyPXtpbmZvID0+XG4gICAgICAgICAgICAgICAgPGRpdiB7Li4uaW5mby5wcm9wc30+XG5cbiAgICAgICAgICAgICAgICA8L2Rpdj59XG4gICAgICAgIC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2hlY2tib3hHcm91cFBhcmVudERlbW8oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZjxVc2VDaGVja2JveFJldHVyblR5cGU8YW55LCBhbnk+PihudWxsKTtcbiAgICByZXR1cm4gKFxuICAgICAgICA8Q2hlY2tib3hHcm91cFBhcmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgaGlkZGVuPXtmYWxzZX1cbiAgICAgICAgICAgIGV4Y2x1ZGU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uUHJlc3NTeW5jPXtudWxsfVxuICAgICAgICAgICAgZm9jdXNTZWxmPXtlID0+IHJlZi5jdXJyZW50Py5jaGVja2JveExpa2VSZXR1cm4uZm9jdXNTZWxmKCl9XG4gICAgICAgICAgICBnZXRTb3J0VmFsdWU9e3JldHVybk51bGx9XG4gICAgICAgICAgICByZW5kZXI9e2kgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDxDaGVja2JveDxIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50PlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYUxhYmVsPXtudWxsfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17aS5jaGVja2JveEdyb3VwUGFyZW50UmV0dXJuLmNoZWNrZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoZWNrZWRDaGFuZ2U9e2kuY2hlY2tib3hHcm91cFBhcmVudFJldHVybi5vblBhcmVudENoZWNrZWRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXI9e2kgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgey4uLmkucHJvcHNJbnB1dH0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCB7Li4uaS5wcm9wc0xhYmVsfT5QYXJlbnQ8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTGFiZWw9XCJsYWJlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdJbnB1dD1cImlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENoZWNrYm94R3JvdXBDaGlsZERlbW8oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xuICAgIGNvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkXSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBcIm1peGVkXCI+KGZhbHNlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWY8VXNlQ2hlY2tib3hSZXR1cm5UeXBlPGFueSwgYW55Pj4obnVsbCk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPENoZWNrYm94R3JvdXBDaGlsZDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgaGlkZGVuPXtmYWxzZX1cbiAgICAgICAgICAgIG9uQ2hhbmdlRnJvbVBhcmVudD17c2V0Q2hlY2tlZH1cbiAgICAgICAgICAgIGV4Y2x1ZGU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uUHJlc3NTeW5jPXtudWxsfVxuICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgIGZvY3VzU2VsZj17ZSA9PiByZWYuY3VycmVudD8uY2hlY2tib3hMaWtlUmV0dXJuLmZvY3VzU2VsZigpfVxuICAgICAgICAgICAgZ2V0U29ydFZhbHVlPXtyZXR1cm5OdWxsfVxuICAgICAgICAgICAgcmVuZGVyPXtpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3g8SFRNTElucHV0RWxlbWVudCwgSFRNTExhYmVsRWxlbWVudD5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWFMYWJlbD17bnVsbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17cmVmfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoZWNrZWRDaGFuZ2U9e2UgPT4gc2V0Q2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcj17ZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0lucHV0OiBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTGFiZWw6IFwibGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNJbnB1dDogaW5mbyA9PiB1c2VNZXJnZWRQcm9wcyhpbmZvLnByb3BzSW5wdXQsIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNMYWJlbDogaW5mbyA9PiB1c2VNZXJnZWRQcm9wcyhpbmZvLnByb3BzTGFiZWwsIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdMYWJlbD1cImxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0lucHV0PVwiaW5wdXRcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VEaWFsb2csIFVzZURpYWxvZ1BhcmFtZXRlcnMsIFVzZURpYWxvZ1JldHVyblR5cGUgfSBmcm9tIFwiLi4vdXNlLWRpYWxvZ1wiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcmVudERlcHRoQ29udGV4dCwgUGFydGlhbEV4Y2VwdCwgdXNlRGVmYXVsdCB9IGZyb20gXCIuL3V0aWxcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuaW50ZXJmYWNlIERpYWxvZ1Byb3BzQmFzZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlRGlhbG9nUGFyYW1ldGVyczxEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQ+LCBcImRpc21pc3NQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VEaWFsb2dQYXJhbWV0ZXJzPERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudD4sIFwiZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZURpYWxvZ1BhcmFtZXRlcnM8RGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50PiwgXCJsYWJlbFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZURpYWxvZ1BhcmFtZXRlcnM8RGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50PiwgXCJmb2N1c1RyYXBQYXJhbWV0ZXJzXCI+IHtcbiAgICByZWY/OiBSZWY8VXNlRGlhbG9nUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudD4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERpYWxvZ1Byb3BzPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNvdXJjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBEaWFsb2dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PERpYWxvZ1Byb3BzQmFzZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudD4sIFwiYXJpYUxhYmVsXCIgfCBcIm9uQ2xvc2VcIiB8IFwib3BlblwiIHwgXCJmb2N1c1BvcHVwXCI+IHtcblxuICAgIHJlbmRlcihkaWFsb2dJbmZvOiBVc2VEaWFsb2dSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgU291cmNlRWxlbWVudCwgRGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyUG9ydGFsKHsgcG9ydGFsSWQsIGNoaWxkcmVuIH06IHsgcG9ydGFsSWQ6IHN0cmluZywgY2hpbGRyZW46IFZOb2RlIH0pOiBWTm9kZSB7XG4gICAgY29uc3QgcG9ydGFsUmVmID0gdXNlUmVmPEhUTUxFbGVtZW50PihudWxsISk7XG4gICAgcG9ydGFsUmVmLmN1cnJlbnQgPz89IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBvcnRhbElkKSE7XG4gICAgaWYgKHBvcnRhbFJlZi5jdXJyZW50KVxuICAgICAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBwb3J0YWxSZWYuY3VycmVudCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG59XG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJNb2RhbDxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEluZm9UeXBlPih7IHBvcnRhbElkLCB0YWdGb2N1c0NvbnRhaW5lciwgdGFnQmFja2Ryb3AsIHRhZ0JvZHksIHRhZ0RpYWxvZywgdGFnVGl0bGUsIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyLCBtYWtlUHJvcHNCYWNrZHJvcCwgbWFrZVByb3BzQm9keSwgbWFrZVByb3BzRGlhbG9nLCBtYWtlUHJvcHNUaXRsZSB9OiB7IHBvcnRhbElkOiBzdHJpbmcsIHRhZ0ZvY3VzQ29udGFpbmVyOiBFbGVtZW50VG9UYWc8Rm9jdXNDb250YWluZXJFbGVtZW50PiwgdGFnRGlhbG9nOiBFbGVtZW50VG9UYWc8RGlhbG9nRWxlbWVudD47IHRhZ1RpdGxlOiBFbGVtZW50VG9UYWc8VGl0bGVFbGVtZW50PjsgdGFnQm9keTogRWxlbWVudFRvVGFnPEJvZHlFbGVtZW50PjsgdGFnQmFja2Ryb3A6IEVsZW1lbnRUb1RhZzxCYWNrZHJvcEVsZW1lbnQ+LCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lcjogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCBtYWtlUHJvcHNEaWFsb2c6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RGlhbG9nRWxlbWVudD4sIG1ha2VQcm9wc0JvZHk6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+LCBtYWtlUHJvcHNUaXRsZTogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+LCBtYWtlUHJvcHNCYWNrZHJvcDogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRpYWxvZ0luZm86IEluZm9UeXBlKTogVk5vZGU8YW55PiB7XG5cbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogdGl0bGVDaGlsZHJlbiwgLi4udGl0bGVQcm9wcyB9ID0gKG1ha2VQcm9wc1RpdGxlKGRpYWxvZ0luZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogYm9keUNoaWxkcmVuLCAuLi5ib2R5UHJvcHMgfSA9IChtYWtlUHJvcHNCb2R5KGRpYWxvZ0luZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogZGlhbG9nQ2hpbGRyZW4sIC4uLmRpYWxvZ1Byb3BzIH0gPSAobWFrZVByb3BzRGlhbG9nKGRpYWxvZ0luZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogYmFja2Ryb3BDaGlsZHJlbiwgLi4uYmFja2Ryb3BQcm9wcyB9ID0gKG1ha2VQcm9wc0JhY2tkcm9wKGRpYWxvZ0luZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogZm9jdXNDb250YWluZXJDaGlsZHJlbiwgLi4uZm9jdXNDb250YWluZXJQcm9wcyB9ID0gKG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyKGRpYWxvZ0luZm8pKTtcblxuICAgICAgICBjb25zdCB0aXRsZSA9IGNyZWF0ZUVsZW1lbnQodGFnVGl0bGUgYXMgbmV2ZXIsIHRpdGxlUHJvcHMsIHRpdGxlQ2hpbGRyZW4pO1xuICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRWxlbWVudCh0YWdCb2R5IGFzIG5ldmVyLCBib2R5UHJvcHMsIGJvZHlDaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IGRpYWxvZyA9IGNyZWF0ZUVsZW1lbnQodGFnRGlhbG9nIGFzIG5ldmVyLCBkaWFsb2dQcm9wcywgZGlhbG9nQ2hpbGRyZW4sIHRpdGxlLCBib2R5KTtcblxuICAgICAgICBjb25zdCBiYWNrZHJvcCA9IGNyZWF0ZUVsZW1lbnQodGFnQmFja2Ryb3AgYXMgbmV2ZXIsIGJhY2tkcm9wUHJvcHMsIGJhY2tkcm9wQ2hpbGRyZW4pO1xuICAgICAgICBjb25zdCBmb2N1c0NvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQodGFnRm9jdXNDb250YWluZXIgYXMgbmV2ZXIsIGZvY3VzQ29udGFpbmVyUHJvcHMsIDxkaXY+e2ZvY3VzQ29udGFpbmVyQ2hpbGRyZW59e2RpYWxvZ317YmFja2Ryb3B9PC9kaXY+KTtcblxuICAgICAgICByZXR1cm4gZGVmYXVsdFJlbmRlclBvcnRhbCh7XG4gICAgICAgICAgICBwb3J0YWxJZCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBmb2N1c0NvbnRhaW5lclxuICAgICAgICB9KTtcbiAgICB9XG59Ki9cblxuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHBvcnRhbElkLCB0YWdGb2N1c0NvbnRhaW5lciwgdGFnQmFja2Ryb3AsIHRhZ0JvZHksIHRhZ0RpYWxvZywgdGFnVGl0bGUsIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyLCBtYWtlUHJvcHNCYWNrZHJvcCwgbWFrZVByb3BzQm9keSwgbWFrZVByb3BzRGlhbG9nLCBtYWtlUHJvcHNUaXRsZSB9OiB7IHBvcnRhbElkOiBzdHJpbmcsIHRhZ0ZvY3VzQ29udGFpbmVyOiBFbGVtZW50VG9UYWc8Rm9jdXNDb250YWluZXJFbGVtZW50PiwgdGFnRGlhbG9nOiBFbGVtZW50VG9UYWc8RGlhbG9nRWxlbWVudD47IHRhZ1RpdGxlOiBFbGVtZW50VG9UYWc8VGl0bGVFbGVtZW50PjsgdGFnQm9keTogRWxlbWVudFRvVGFnPEJvZHlFbGVtZW50PjsgdGFnQmFja2Ryb3A6IEVsZW1lbnRUb1RhZzxCYWNrZHJvcEVsZW1lbnQ+LCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lcjogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rm9jdXNDb250YWluZXJFbGVtZW50PiwgbWFrZVByb3BzRGlhbG9nOiAoaW5mbzogVXNlRGlhbG9nUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERpYWxvZ0VsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxEaWFsb2dFbGVtZW50PiwgbWFrZVByb3BzQm9keTogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+LCBtYWtlUHJvcHNUaXRsZTogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50PiwgbWFrZVByb3BzQmFja2Ryb3A6IChpbmZvOiBVc2VEaWFsb2dSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRGlhbG9nRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBkZWZhdWx0UmVuZGVyTW9kYWw8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQsIEJvZHlFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQsIFVzZURpYWxvZ1JldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50Pj4oeyBwb3J0YWxJZCwgdGFnRm9jdXNDb250YWluZXIsIHRhZ0JhY2tkcm9wLCB0YWdCb2R5LCB0YWdEaWFsb2csIHRhZ1RpdGxlLCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lciwgbWFrZVByb3BzQmFja2Ryb3AsIG1ha2VQcm9wc0JvZHksIG1ha2VQcm9wc0RpYWxvZywgbWFrZVByb3BzVGl0bGUgfSk7XG59Ki9cblxuZXhwb3J0IGNvbnN0IERpYWxvZyA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIERpYWxvZzxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBvbkNsb3NlLFxuICAgIG9wZW4sXG4gICAgY2xvc2VPbkJhY2tkcm9wLFxuICAgIGNsb3NlT25Fc2NhcGUsXG4gICAgZm9jdXNPcGVuZXIsXG4gICAgZ2V0V2luZG93LFxuICAgIHBhcmVudERlcHRoLFxuICAgIGZvY3VzUG9wdXAsXG4gICAgYXJpYUxhYmVsLFxuICAgIHJlbmRlclxufTogRGlhbG9nUHJvcHM8Rm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQ+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGRlZmF1bHRQYXJlbnREZXB0aCA9IHVzZUNvbnRleHQoUGFyZW50RGVwdGhDb250ZXh0KTtcbiAgICBsZXQgbXlEZXB0aCA9IChwYXJlbnREZXB0aCA/PyBkZWZhdWx0UGFyZW50RGVwdGgpICsgMTtcblxuICAgIGNvbnN0IGluZm8gPSB1c2VEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQ+KHtcbiAgICAgICAgZGlzbWlzc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGNsb3NlT25CYWNrZHJvcDogY2xvc2VPbkJhY2tkcm9wID8/IHRydWUsXG4gICAgICAgICAgICBjbG9zZU9uRXNjYXBlOiBjbG9zZU9uRXNjYXBlID8/IHRydWUsXG4gICAgICAgICAgICBvbkNsb3NlLFxuICAgICAgICAgICAgb3BlblxuICAgICAgICB9LFxuICAgICAgICBlc2NhcGVEaXNtaXNzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZ2V0V2luZG93OiB1c2VEZWZhdWx0KFwiZ2V0V2luZG93XCIsIGdldFdpbmRvdyksXG4gICAgICAgICAgICBwYXJlbnREZXB0aDogcGFyZW50RGVwdGggPz8gZGVmYXVsdFBhcmVudERlcHRoXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzVHJhcFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGZvY3VzT3BlbmVyOiB1c2VEZWZhdWx0KFwiZm9jdXNPcGVuZXJcIiwgZm9jdXNPcGVuZXIpLFxuICAgICAgICAgICAgZm9jdXNQb3B1cFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHsgYXJpYUxhYmVsIH1cbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8UGFyZW50RGVwdGhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtteURlcHRofT5cbiAgICAgICAgICAgIHtyZW5kZXIoaW5mbyl9XG4gICAgICAgIDwvUGFyZW50RGVwdGhDb250ZXh0LlByb3ZpZGVyPilcblxufSk7XG5cbmZ1bmN0aW9uIGdldFdpbmRvdygpIHsgcmV0dXJuIGdsb2JhbFRoaXMud2luZG93IH1cbmV4cG9ydCBmdW5jdGlvbiBEaWFsb2dEZW1vKCkge1xuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxEaWFsb2c8SFRNTERpdkVsZW1lbnQsIEhUTUxCdXR0b25FbGVtZW50LCBIVE1MRGl2RWxlbWVudCwgSFRNTERpdkVsZW1lbnQ+XG4gICAgICAgICAgICBvcGVuPXtvcGVufVxuICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0T3BlbihmYWxzZSl9XG4gICAgICAgICAgICBjbG9zZU9uQmFja2Ryb3A9e3RydWV9XG4gICAgICAgICAgICBjbG9zZU9uRXNjYXBlPXt0cnVlfVxuICAgICAgICAgICAgZm9jdXNPcGVuZXI9e2UgPT4gZS5mb2N1cygpfVxuICAgICAgICAgICAgcGFyZW50RGVwdGg9ezB9XG4gICAgICAgICAgICBmb2N1c1BvcHVwPXsoZSwgZikgPT4ge2YoKT8uZm9jdXMoKX19XG4gICAgICAgICAgICBhcmlhTGFiZWw9e251bGx9XG4gICAgICAgICAgICByZW5kZXI9e2luZm8gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHsuLi5pbmZvLnByb3BzU291cmNlfT5PcGVuIGRpYWxvZzwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAge2RlZmF1bHRSZW5kZXJQb3J0YWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbElkOiBcInBvcnRhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiA8ZGl2IHsuLi5pbmZvLnByb3BzRm9jdXNDb250YWluZXJ9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHsuLi5pbmZvLnByb3BzRGlhbG9nfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgey4uLmluZm8ucHJvcHNUaXRsZX0+RGlhbG9nIHRpdGxlPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PkRpYWxvZyBib2R5PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldE9wZW4oZmFsc2UpfT5DbG9zZSBkaWFsb2c8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICApXG59XG4iLCJpbXBvcnQgeyBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZURyYXdlciwgVXNlRHJhd2VyUGFyYW1ldGVycywgVXNlRHJhd2VyUmV0dXJuVHlwZSB9IGZyb20gXCIuLi91c2UtZHJhd2VyXCI7XG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyUG9ydGFsIH0gZnJvbSBcIi4vZGlhbG9nXCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiwgUGFyZW50RGVwdGhDb250ZXh0LCBQYXJ0aWFsRXhjZXB0LCB1c2VEZWZhdWx0IH0gZnJvbSBcIi4vdXRpbFwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5pbnRlcmZhY2UgRHJhd2VyUHJvcHNCYXNlPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNvdXJjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBEcmF3ZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VEcmF3ZXJQYXJhbWV0ZXJzPERyYXdlckVsZW1lbnQsIFRpdGxlRWxlbWVudD4sIFwiZGlzbWlzc1BhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZURyYXdlclBhcmFtZXRlcnM8RHJhd2VyRWxlbWVudCwgVGl0bGVFbGVtZW50PiwgXCJlc2NhcGVEaXNtaXNzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlRHJhd2VyUGFyYW1ldGVyczxEcmF3ZXJFbGVtZW50LCBUaXRsZUVsZW1lbnQ+LCBcImxhYmVsUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlRHJhd2VyUGFyYW1ldGVyczxEcmF3ZXJFbGVtZW50LCBUaXRsZUVsZW1lbnQ+LCBcImZvY3VzVHJhcFBhcmFtZXRlcnNcIj4ge1xuICAgIHJlZj86IFJlZjxVc2VEcmF3ZXJSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgU291cmNlRWxlbWVudCwgRHJhd2VyRWxlbWVudCwgVGl0bGVFbGVtZW50Pj47XG4gICAgcmVuZGVyKGRyYXdlckluZm86IFVzZURyYXdlclJldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBEcmF3ZXJFbGVtZW50LCBUaXRsZUVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEcmF3ZXJQcm9wczxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxEcmF3ZXJQcm9wc0Jhc2U8Rm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQ+LCBcImFyaWFMYWJlbFwiIHwgXCJvbkNsb3NlXCIgfCBcIm9wZW5cIiB8IFwiZm9jdXNQb3B1cFwiPiB7XG5cbiAgICByZW5kZXIoZGlhbG9nSW5mbzogVXNlRHJhd2VyUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuLypcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyRHJhd2VyPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBEcmF3ZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBwb3J0YWxJZCwgdGFnRm9jdXNDb250YWluZXIsIHRhZ0JhY2tkcm9wLCB0YWdCb2R5LCB0YWdEaWFsb2csIHRhZ1RpdGxlLCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lciwgbWFrZVByb3BzQmFja2Ryb3AsIG1ha2VQcm9wc0JvZHksIG1ha2VQcm9wc0RpYWxvZywgbWFrZVByb3BzVGl0bGUgfTogeyBwb3J0YWxJZDogc3RyaW5nLCB0YWdGb2N1c0NvbnRhaW5lcjogRWxlbWVudFRvVGFnPEZvY3VzQ29udGFpbmVyRWxlbWVudD4sIHRhZ0RpYWxvZzogRWxlbWVudFRvVGFnPERyYXdlckVsZW1lbnQ+OyB0YWdUaXRsZTogRWxlbWVudFRvVGFnPFRpdGxlRWxlbWVudD47IHRhZ0JvZHk6IEVsZW1lbnRUb1RhZzxCb2R5RWxlbWVudD47IHRhZ0JhY2tkcm9wOiBFbGVtZW50VG9UYWc8QmFja2Ryb3BFbGVtZW50PiwgbWFrZVByb3BzRm9jdXNDb250YWluZXI6IChpbmZvOiBVc2VEcmF3ZXJSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD4sIG1ha2VQcm9wc0RpYWxvZzogKGluZm86IFVzZURyYXdlclJldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEcmF3ZXJFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RHJhd2VyRWxlbWVudD4sIG1ha2VQcm9wc0JvZHk6IChpbmZvOiBVc2VEcmF3ZXJSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PiwgbWFrZVByb3BzVGl0bGU6IChpbmZvOiBVc2VEcmF3ZXJSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD4sIG1ha2VQcm9wc0JhY2tkcm9wOiAoaW5mbzogVXNlRHJhd2VyUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERyYXdlckVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlck1vZGFsPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50LCBVc2VEcmF3ZXJSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudD4+KHsgcG9ydGFsSWQsIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyLCBtYWtlUHJvcHNCYWNrZHJvcCwgbWFrZVByb3BzQm9keSwgbWFrZVByb3BzRGlhbG9nLCBtYWtlUHJvcHNUaXRsZSwgdGFnRm9jdXNDb250YWluZXIsIHRhZ0JhY2tkcm9wLCB0YWdCb2R5LCB0YWdEaWFsb2csIHRhZ1RpdGxlIH0pO1xufSovXG5cbmV4cG9ydCBjb25zdCBEcmF3ZXIgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBEcmF3ZXI8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgU291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIERyYXdlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG5cbiAgICBjbG9zZU9uQmFja2Ryb3AsXG4gICAgY2xvc2VPbkVzY2FwZSxcbiAgICBjbG9zZU9uTG9zdEZvY3VzLFxuICAgIGZvY3VzT3BlbmVyLFxuICAgIGZvY3VzUG9wdXAsXG4gICAgZ2V0V2luZG93LFxuICAgIG9uQ2xvc2UsXG4gICAgb3BlbixcbiAgICBwYXJlbnREZXB0aCxcbiAgICByZW5kZXIsXG4gICAgdHJhcEFjdGl2ZSxcbiAgICBhcmlhTGFiZWwsXG59OiBEcmF3ZXJQcm9wczxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIERyYXdlckVsZW1lbnQsIFRpdGxlRWxlbWVudD4sIHJlZjogUmVmPGFueT4pIHtcbiAgICBjb25zdCBkZWZhdWx0UGFyZW50RGVwdGggPSB1c2VDb250ZXh0KFBhcmVudERlcHRoQ29udGV4dCk7XG4gICAgbGV0IG15RGVwdGggPSAocGFyZW50RGVwdGggPz8gZGVmYXVsdFBhcmVudERlcHRoKSArIDE7XG4gICAgXG4gICAgY29uc3QgaW5mbyA9IHVzZURyYXdlcjxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIERyYXdlckVsZW1lbnQsIFRpdGxlRWxlbWVudD4oe1xuICAgICAgICBkaXNtaXNzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY2xvc2VPbkJhY2tkcm9wOiBjbG9zZU9uQmFja2Ryb3AgPz8gdHJ1ZSxcbiAgICAgICAgICAgIGNsb3NlT25Fc2NhcGU6IGNsb3NlT25Fc2NhcGUgPz8gdHJ1ZSxcbiAgICAgICAgICAgIGNsb3NlT25Mb3N0Rm9jdXM6IGNsb3NlT25Mb3N0Rm9jdXMgPz8gdHJ1ZSxcbiAgICAgICAgICAgIG9uQ2xvc2UsXG4gICAgICAgICAgICBvcGVuXG4gICAgICAgIH0sXG4gICAgICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBnZXRXaW5kb3c6IHVzZURlZmF1bHQoXCJnZXRXaW5kb3dcIiwgZ2V0V2luZG93KSxcbiAgICAgICAgICAgIHBhcmVudERlcHRoOiBwYXJlbnREZXB0aCA/PyBkZWZhdWx0UGFyZW50RGVwdGhcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNUcmFwUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZm9jdXNPcGVuZXI6IHVzZURlZmF1bHQoXCJmb2N1c09wZW5lclwiLCBmb2N1c09wZW5lciksXG4gICAgICAgICAgICBmb2N1c1BvcHVwLFxuICAgICAgICAgICAgdHJhcEFjdGl2ZTogdHJhcEFjdGl2ZSA/PyBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHsgYXJpYUxhYmVsIH1cbiAgICB9KTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcblxufSlcblxuZXhwb3J0IGZ1bmN0aW9uIERyYXdlckRlbW8oKSB7XG4gICAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPERyYXdlcjxIVE1MRGl2RWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnQsIEhUTUxEaXZFbGVtZW50LCBIVE1MRGl2RWxlbWVudD5cbiAgICAgICAgICAgIG9wZW49e29wZW59XG4gICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRPcGVuKGZhbHNlKX1cbiAgICAgICAgICAgIGNsb3NlT25CYWNrZHJvcD17dHJ1ZX1cbiAgICAgICAgICAgIGNsb3NlT25Fc2NhcGU9e3RydWV9XG4gICAgICAgICAgICBmb2N1c09wZW5lcj17ZSA9PiBlLmZvY3VzKCl9XG4gICAgICAgICAgICBwYXJlbnREZXB0aD17MH1cbiAgICAgICAgICAgIGNsb3NlT25Mb3N0Rm9jdXM9e3RydWV9XG4gICAgICAgICAgICB0cmFwQWN0aXZlPXt0cnVlfVxuICAgICAgICAgICAgZm9jdXNQb3B1cD17KGUsIGYpID0+IGYoKT8uZm9jdXMoKX1cbiAgICAgICAgICAgIGFyaWFMYWJlbD17bnVsbH1cbiAgICAgICAgICAgIHJlbmRlcj17aW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB7Li4uaW5mby5wcm9wc1NvdXJjZX0+T3BlbiBkcmF3ZXI8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtkZWZhdWx0UmVuZGVyUG9ydGFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxJZDogXCJwb3J0YWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogPGRpdiB7Li4uaW5mby5wcm9wc0ZvY3VzQ29udGFpbmVyfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB7Li4uaW5mby5wcm9wc0RyYXdlcn0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHsuLi5pbmZvLnByb3BzVGl0bGV9PkRyYXdlciB0aXRsZTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5EcmF3ZXIgYm9keTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRPcGVuKGZhbHNlKX0+Q2xvc2UgZHJhd2VyPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEdyaWRDaGlsZENlbGxJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBUYWJsZUNlbGxJbmZvIH0gZnJvbSBcIi4uL3VzZS10YWJsZVwiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyBHcmlkbGlzdENlbGxJbmZvLCBHcmlkbGlzdFJvd0luZm8sIHVzZUdyaWRsaXN0LCB1c2VHcmlkbGlzdENlbGwsIFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnMsIFVzZUdyaWRsaXN0Q2VsbFJldHVyblR5cGUsIFVzZUdyaWRsaXN0Q29udGV4dCwgVXNlR3JpZGxpc3RQYXJhbWV0ZXJzLCBVc2VHcmlkbGlzdFJldHVyblR5cGUsIHVzZUdyaWRsaXN0Um93LCBVc2VHcmlkbGlzdFJvd0NvbnRleHQsIFVzZUdyaWRsaXN0Um93UGFyYW1ldGVycywgVXNlR3JpZGxpc3RSb3dSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL3VzZS1ncmlkbGlzdFwiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcnRpYWxFeGNlcHQsIHVzZURlZmF1bHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcblxuaW50ZXJmYWNlIEdyaWRsaXN0UHJvcHNCYXNlPEdyaWRsaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRsaXN0Um93SW5mbzxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88R3JpZGxpc3RDZWxsRWxlbWVudD4+IGV4dGVuZHNcbiAgICBHZXQ8VXNlR3JpZGxpc3RQYXJhbWV0ZXJzPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJNPiwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlR3JpZGxpc3RQYXJhbWV0ZXJzPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJNPiwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVyczxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTT4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVyczxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTT4sIFwiZ3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VHcmlkbGlzdFBhcmFtZXRlcnM8R3JpZGxpc3RFbGVtZW50LCBHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIExhYmVsRWxlbWVudCwgUk0+LCBcInJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVyczxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTT4sIFwic29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVyczxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTT4sIFwibGFiZWxQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VHcmlkbGlzdFBhcmFtZXRlcnM8R3JpZGxpc3RFbGVtZW50LCBHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIExhYmVsRWxlbWVudCwgUk0+LCBcImdyaWRsaXN0UGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZUdyaWRsaXN0UmV0dXJuVHlwZTxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTSwgQ00+Pjtcbn1cblxuaW50ZXJmYWNlIEdyaWRsaXN0Um93UHJvcHNCYXNlPEdyaWRsaXN0Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRsaXN0Um93SW5mbzxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88R3JpZGxpc3RDZWxsRWxlbWVudD4+IGV4dGVuZHNcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwicm93QXNDaGlsZE9mR3JpZFBhcmFtZXRlcnNcIiwgXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDI8VXNlR3JpZGxpc3RSb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJyb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyc1wiLCBcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwicm93QXNDaGlsZE9mR3JpZFBhcmFtZXRlcnNcIiwgXCJ0ZXh0Q29udGVudFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+LCBcInJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzXCIsIFwicm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+LCBcInJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzXCIsIFwic29ydGFibGVDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+LCBcInJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnNcIiwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwicm93QXNQYXJlbnRPZkNlbGxzUGFyYW1ldGVyc1wiLCBcInJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc1wiPixcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwicm93QXNQYXJlbnRPZkNlbGxzUGFyYW1ldGVyc1wiLCBcInR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDI8VXNlR3JpZGxpc3RSb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJyb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyc1wiLCBcImdyaWRsaXN0Um93UGFyYW1ldGVyc1wiPiB7XG4gICAgLy8gICAgc3ViSW5mbzogR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+LCBcInJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzXCIsIFwiY29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnNcIj47XG4gICAgcmVmPzogUmVmPFVzZUdyaWRsaXN0Um93UmV0dXJuVHlwZTxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4+O1xufVxuXG5pbnRlcmZhY2UgR3JpZGxpc3RDaGlsZFByb3BzQmFzZTxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPENlbGxFbGVtZW50Pj4gZXh0ZW5kc1xuICAgIEdldDxVc2VHcmlkbGlzdENlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50LCBNPiwgXCJncmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VHcmlkbGlzdENlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50LCBNPiwgXCJ0ZXh0Q29udGVudFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIE0+LCBcInByZXNzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlR3JpZGxpc3RDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgTT4sIFwicm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIE0+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4ge1xuICAgIHJlZj86IFJlZjxVc2VHcmlkbGlzdENlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50LCBNPj47XG4gICAgLy8gICAgc3ViSW5mbzogR2V0PFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIE0+LCBcImNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyc1wiPjtcbn1cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBHcmlkbGlzdFByb3BzPEdyaWRsaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRsaXN0Um93SW5mbzxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88R3JpZGxpc3RDZWxsRWxlbWVudD4+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxHcmlkbGlzdFByb3BzQmFzZTxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTSwgQ00+LCBcInNlbGVjdGlvbkxpbWl0XCIgfCBcImdyb3VwaW5nVHlwZVwiIHwgXCJhcmlhTGFiZWxcIiB8IFwic2VsZWN0ZWRJbmRleFwiPiB7XG4gICAgLy9yZWY/OiBSZWY8VXNlR3JpZGxpc3RSZXR1cm5UeXBlPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBMYWJlbEVsZW1lbnQsIE0+PjtcbiAgICByZW5kZXIoaW5mbzogVXNlR3JpZGxpc3RSZXR1cm5UeXBlPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJNLCBDTT4pOiBWTm9kZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcmlkbGlzdFJvd1Byb3BzPEdyaWRsaXN0Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRsaXN0Um93SW5mbzxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88R3JpZGxpc3RDZWxsRWxlbWVudD4+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxHcmlkbGlzdFJvd1Byb3BzQmFzZTxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwiaW5kZXhcIiB8IFwiYXJpYVByb3BOYW1lXCIgfCBcImdldFNvcnRWYWx1ZVwiPiB7XG4gICAgLy9zdWJJbmZvOiBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwicm93QXNDaGlsZE9mR3JpZFBhcmFtZXRlcnNcIiwgXCJjb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyc1wiPjtcbiAgICAvL3JlZj86IFJlZjxVc2VHcmlkbGlzdFJvd1JldHVyblR5cGU8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+PjtcbiAgICByZW5kZXIoaW5mbzogVXNlR3JpZGxpc3RSb3dSZXR1cm5UeXBlPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPik6IFZOb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyaWRsaXN0Q2hpbGRQcm9wczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPENlbGxFbGVtZW50Pj4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PEdyaWRsaXN0Q2hpbGRQcm9wc0Jhc2U8Q2VsbEVsZW1lbnQsIE0+LCAgXCJpbmRleFwiIHwgXCJmb2N1c1NlbGZcIj4ge1xuICAgIC8vcmVmPzogUmVmPFVzZUdyaWRsaXN0Q2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQsIE0+PjtcbiAgICAvL3N1YkluZm86IEdldDxVc2VHcmlkbGlzdENlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50LCBNPiwgXCJjb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnNcIj47XG4gICAgcmVuZGVyKGluZm86IFVzZUdyaWRsaXN0Q2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQsIE0+KTogVk5vZGU7XG59XG5cbi8vY29uc3QgTG9jYXRpb25JbmRleENvbnRleHQgPSBjcmVhdGVDb250ZXh0KDApO1xuXG4vL2NvbnN0IFNldE1hbmdsZXJzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8KG06IChuOiBudW1iZXIpID0+IG51bWJlciwgZDogKG46IG51bWJlcikgPT4gbnVtYmVyKSA9PiB2b2lkPihudWxsISk7XG4vL2NvbnN0IEdyaWRsaXN0U2VjdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUdyaWRsaXN0U2VjdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4obnVsbCEpO1xuY29uc3QgR3JpZGxpc3RDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VHcmlkbGlzdENvbnRleHQ8YW55LCBhbnksIGFueSwgYW55LCBhbnk+PihudWxsISk7XG5jb25zdCBHcmlkbGlzdFJvd0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUdyaWRsaXN0Um93Q29udGV4dDxhbnksIGFueSwgYW55Pj4obnVsbCEpO1xuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJHcmlkbGlzdDxHcmlkbGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRsaXN0Um93SW5mbzxSb3dFbGVtZW50Pj4oeyB0YWdHcmlkbGlzdCwgbWFrZVByb3BzR3JpZGxpc3QgfTogeyB0YWdHcmlkbGlzdDogRWxlbWVudFRvVGFnPEdyaWRsaXN0RWxlbWVudD4sIG1ha2VQcm9wc0dyaWRsaXN0OiAoaW5mbzogVXNlR3JpZGxpc3RSZXR1cm5UeXBlPEdyaWRsaXN0RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JpZGxpc3RFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VHcmlkbGlzdFJldHVyblR5cGU8R3JpZGxpc3RFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0dyaWRsaXN0IGFzIG5ldmVyLCAobWFrZVByb3BzR3JpZGxpc3QoaW5mbykpKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckdyaWRsaXN0U2VjdGlvbjxHcmlkbGlzdFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ1IsIENDLCBLUiBleHRlbmRzIHN0cmluZz4oeyB0YWdHcmlkbGlzdFNlY3Rpb24sIG1ha2VQcm9wc0dyaWRsaXN0U2VjdGlvbiB9OiB7IHRhZ0dyaWRsaXN0U2VjdGlvbjogRWxlbWVudFRvVGFnPEdyaWRsaXN0U2VjdGlvbkVsZW1lbnQ+LCBtYWtlUHJvcHNHcmlkbGlzdFNlY3Rpb246IChpbmZvOiBVc2VHcmlkbGlzdFNlY3Rpb25SZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDUiwgQ0MsIEtSPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JpZGxpc3RTZWN0aW9uRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlR3JpZGxpc3RTZWN0aW9uUmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgQ1IsIENDLCBLUj4sIG1vZGlmeVByb3BzR3JpZGxpc3RTZWN0aW9uOiBQcm9wTW9kaWZpZXI8R3JpZGxpc3RTZWN0aW9uRWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnR3JpZGxpc3RTZWN0aW9uIGFzIG5ldmVyLCBtb2RpZnlQcm9wc0dyaWRsaXN0U2VjdGlvbihtYWtlUHJvcHNHcmlkbGlzdFNlY3Rpb24oaW5mbykpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyR3JpZGxpc3RIZWFkPEdyaWRsaXN0SGVhZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ0dyaWRsaXN0SGVhZCwgbWFrZVByb3BzR3JpZGxpc3RIZWFkIH06IHsgdGFnR3JpZGxpc3RIZWFkOiBFbGVtZW50VG9UYWc8R3JpZGxpc3RIZWFkRWxlbWVudD4sIG1ha2VQcm9wc0dyaWRsaXN0SGVhZDogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JpZGxpc3RIZWFkRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0dyaWRsaXN0SGVhZCBhcyBuZXZlciwgKG1ha2VQcm9wc0dyaWRsaXN0SGVhZCgpKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckdyaWRsaXN0Rm9vdDxHcmlkbGlzdEZvb3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdHcmlkbGlzdEZvb3QsIG1ha2VQcm9wc0dyaWRsaXN0Rm9vdCB9OiB7IHRhZ0dyaWRsaXN0Rm9vdDogRWxlbWVudFRvVGFnPEdyaWRsaXN0Rm9vdEVsZW1lbnQ+LCBtYWtlUHJvcHNHcmlkbGlzdEZvb3Q6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyaWRsaXN0Rm9vdEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdHcmlkbGlzdEZvb3QgYXMgbmV2ZXIsIChtYWtlUHJvcHNHcmlkbGlzdEZvb3QoKSkpO1xuICAgIH1cbn0qL1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckdyaWRsaXN0Um93PFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgR3JpZGxpc3RSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPENlbGxFbGVtZW50Pj4oeyB0YWdHcmlkbGlzdFJvdywgbWFrZVByb3BzR3JpZGxpc3RSb3cgfTogeyB0YWdHcmlkbGlzdFJvdzogRWxlbWVudFRvVGFnPFJvd0VsZW1lbnQ+LCBtYWtlUHJvcHNHcmlkbGlzdFJvdzogKGluZm86IFVzZUdyaWRsaXN0Um93UmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlR3JpZGxpc3RSb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0dyaWRsaXN0Um93IGFzIG5ldmVyLCAobWFrZVByb3BzR3JpZGxpc3RSb3coaW5mbykpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyR3JpZGxpc3RDaGlsZDxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENNIGV4dGVuZHMgR3JpZGxpc3RDZWxsSW5mbzxDZWxsRWxlbWVudD4+KHsgdGFnR3JpZGxpc3RDaGlsZCwgbWFrZVByb3BzR3JpZGxpc3RDaGlsZCB9OiB7IHRhZ0dyaWRsaXN0Q2hpbGQ6IEVsZW1lbnRUb1RhZzxDZWxsRWxlbWVudD4sIG1ha2VQcm9wc0dyaWRsaXN0Q2hpbGQ6IChpbmZvOiBVc2VHcmlkbGlzdENlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50LCBDTT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGxFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VHcmlkbGlzdENlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50LCBDTT4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnR3JpZGxpc3RDaGlsZCBhcyBuZXZlciwgKG1ha2VQcm9wc0dyaWRsaXN0Q2hpbGQoaW5mbykpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBHcmlkbGlzdCA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIEdyaWRsaXN0VTxHcmlkbGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBncm91cGluZ1R5cGUsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICBzZWxlY3RlZEluZGV4LFxuICAgIG5hdmlnYXRlUGFzdEVuZCxcbiAgICBuYXZpZ2F0ZVBhc3RTdGFydCxcbiAgICBzZXRTZWxlY3RlZEluZGV4LFxuICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZSxcbiAgICBzZWxlY3Rpb25MaW1pdCxcbiAgICB1bnRhYmJhYmxlLFxuICAgIGNvbXBhcmUsXG4gICAgZ2V0SW5kZXgsXG4gICAgb25UYWJiYWJsZUNvbHVtbkNoYW5nZSxcbiAgICBhcmlhTGFiZWwsXG4gICAgcmVuZGVyXG59OiBHcmlkbGlzdFByb3BzPEdyaWRsaXN0RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbGVtZW50LCBMYWJlbEVsZW1lbnQsIEdyaWRsaXN0Um93SW5mbzxSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCBHcmlkbGlzdENlbGxJbmZvPENlbGxlbWVudD4+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGluZm8gPSB1c2VHcmlkbGlzdDxHcmlkbGlzdEVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudCwgTGFiZWxFbGVtZW50LCBHcmlkbGlzdFJvd0luZm88Um93RWxlbWVudCwgQ2VsbGVtZW50PiwgR3JpZGxpc3RDZWxsSW5mbzxDZWxsZW1lbnQ+Pih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUFycm93S2V5c1wiLCBkaXNhYmxlQXJyb3dLZXlzKSxcbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5czogdXNlRGVmYXVsdChcImRpc2FibGVIb21lRW5kS2V5c1wiLCBkaXNhYmxlSG9tZUVuZEtleXMpLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kOiAobmF2aWdhdGVQYXN0RW5kID8/IFwid3JhcFwiKSxcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdFN0YXJ0OiAobmF2aWdhdGVQYXN0U3RhcnQgPz8gXCJ3cmFwXCIpLFxuICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplOiB1c2VEZWZhdWx0KFwicGFnZU5hdmlnYXRpb25TaXplXCIsIHBhZ2VOYXZpZ2F0aW9uU2l6ZSksXG4gICAgICAgIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiBvblRhYmJhYmxlSW5kZXhDaGFuZ2UgPz8gbnVsbCxcbiAgICAgICAgICAgIHVudGFiYmFibGU6IHVudGFiYmFibGUgPz8gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGNvbGxhdG9yOiB1c2VEZWZhdWx0KFwiY29sbGF0b3JcIiwgY29sbGF0b3IpLFxuICAgICAgICAgICAgbm9UeXBlYWhlYWQ6IHVzZURlZmF1bHQoXCJub1R5cGVhaGVhZFwiLCBub1R5cGVhaGVhZCksXG4gICAgICAgICAgICB0eXBlYWhlYWRUaW1lb3V0OiB1c2VEZWZhdWx0KFwidHlwZWFoZWFkVGltZW91dFwiLCB0eXBlYWhlYWRUaW1lb3V0KSxcbiAgICAgICAgfSxcbiAgICAgICAgLypzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBpbml0aWFsbHlTZWxlY3RlZEluZGV4OiBpbml0aWFsbHlTZWxlY3RlZEluZGV4ID8/IG51bGwsXG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4OiBzZXRTZWxlY3RlZEluZGV4ID8/IG51bGxcbiAgICAgICAgfSwqL1xuICAgICAgICBncmlkbGlzdFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIHNlbGVjdGlvbkxpbWl0LFxuICAgICAgICAgICAgZ3JvdXBpbmdUeXBlLFxuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXg6IHNldFNlbGVjdGVkSW5kZXggPz8gbm9vcFxuICAgICAgICB9LFxuICAgICAgICBncmlkTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIG9uVGFiYmFibGVDb2x1bW5DaGFuZ2U6IG9uVGFiYmFibGVDb2x1bW5DaGFuZ2UgPz8gbm9vcFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGFyaWFMYWJlbFxuICAgICAgICB9LFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBnZXRJbmRleDogdXNlRGVmYXVsdChcImdldEluZGV4XCIsIGdldEluZGV4KVxuICAgICAgICB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY29tcGFyZTogY29tcGFyZSA/PyBudWxsXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8R3JpZGxpc3RDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PlxuICAgICAgICAgICAge3JlbmRlcihpbmZvKX1cbiAgICAgICAgPC9HcmlkbGlzdENvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufSlcblxuZnVuY3Rpb24gbm9vcCgpIHsgfVxuXG4vKlxuZXhwb3J0IGNvbnN0IEdyaWRsaXN0U2VjdGlvbiA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIEdyaWRsaXN0U2VjdGlvblU8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ1IgPSB1bmRlZmluZWQsIENDID0gdW5kZWZpbmVkLCBLUiBleHRlbmRzIHN0cmluZyA9IG5ldmVyPih7IHJlbmRlciwgY29tcGFyZVJvd3MsIGluZGV4IH06IEdyaWRsaXN0U2VjdGlvblByb3BzPFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsZW1lbnQsIENSLCBDQywgS1I+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IHsgdXNlR3JpZGxpc3RTZWN0aW9uUHJvcHMsIC4uLnNlY3Rpb25JbmZvIH0gPSB1c2VDb250ZXh0KEdyaWRsaXN0U2VjdGlvbkNvbnRleHQpLy8oeyBjb21wYXJlUm93cyB9KTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IHNlY3Rpb25JbmZvKTtcbiAgICByZXR1cm4gPExvY2F0aW9uSW5kZXhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmRleH0+e3JlbmRlcihzZWN0aW9uSW5mbywgdXNlR3JpZGxpc3RTZWN0aW9uUHJvcHMpfTwvTG9jYXRpb25JbmRleENvbnRleHQuUHJvdmlkZXI+XG59KSovXG5cbmV4cG9ydCBjb25zdCBHcmlkbGlzdFJvdyA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIEdyaWRsaXN0Um93VTxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluZGV4LFxuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIGFyaWFQcm9wTmFtZSxcbiAgICBkaXNhYmxlZCxcbiAgICBoaWRkZW4sXG4gICAgbmF2aWdhdGVQYXN0RW5kLFxuICAgIG5hdmlnYXRlUGFzdFN0YXJ0LFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBzZWxlY3RlZCxcbiAgICBzZWxlY3Rpb25Nb2RlLFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgdW50YWJiYWJsZSxcbiAgICBnZXRTb3J0VmFsdWUsXG4gICAgZ2V0VGV4dCxcbiAgICByZW5kZXJcbn06IEdyaWRsaXN0Um93UHJvcHM8Um93RWxlbWVudCwgQ2VsbGVtZW50LCBHcmlkbGlzdFJvd0luZm88Um93RWxlbWVudCwgQ2VsbGVtZW50PiwgR3JpZGxpc3RDZWxsSW5mbzxDZWxsZW1lbnQ+PiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKHVzZUNvbnRleHQoR3JpZGxpc3RDb250ZXh0KSBhcyBVc2VHcmlkbGlzdENvbnRleHQ8YW55LCBSb3dFbGVtZW50LCBDZWxsZW1lbnQsIEdyaWRsaXN0Um93SW5mbzxSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCBHcmlkbGlzdENlbGxJbmZvPENlbGxlbWVudD4+KTtcbiAgICBjb25zdCBpbmZvID0gdXNlR3JpZGxpc3RSb3c8Um93RWxlbWVudCwgQ2VsbGVtZW50LCBHcmlkbGlzdFJvd0luZm88Um93RWxlbWVudCwgQ2VsbGVtZW50PiwgR3JpZGxpc3RDZWxsSW5mbzxDZWxsZW1lbnQ+Pih7XG4gICAgICAgIHJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBjb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczoge30sXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LFxuICAgICAgICAgICAgZ3JpZGxpc3RSb3dQYXJhbWV0ZXJzOiB7IHNlbGVjdGVkOiBzZWxlY3RlZCA/PyBudWxsIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczogeyBoaWRkZW46IGhpZGRlbiA/PyBmYWxzZSB9LFxuICAgICAgICAgICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnM6IHsgZ2V0U29ydFZhbHVlIH0sXG4gICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IHsgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlLCBhcmlhUHJvcE5hbWUsIHNlbGVjdGlvbk1vZGU6IHVzZURlZmF1bHQoXCJzZWxlY3Rpb25Nb2RlXCIsIHNlbGVjdGlvbk1vZGUpIH0sXG4gICAgICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnM6IHsgZ2V0VGV4dDogdXNlRGVmYXVsdChcImdldFRleHRcIiwgZ2V0VGV4dCkgfVxuICAgICAgICB9LFxuICAgICAgICByb3dBc1BhcmVudE9mQ2VsbHNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIGRpc2FibGVBcnJvd0tleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlQXJyb3dLZXlzXCIsIGRpc2FibGVBcnJvd0tleXMpLFxuICAgICAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5czogdXNlRGVmYXVsdChcImRpc2FibGVIb21lRW5kS2V5c1wiLCBkaXNhYmxlSG9tZUVuZEtleXMpLFxuXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kOiBuYXZpZ2F0ZVBhc3RFbmQgPz8gXCJ3cmFwXCIsXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IG5hdmlnYXRlUGFzdFN0YXJ0ID8/IFwid3JhcFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiBvblRhYmJhYmxlSW5kZXhDaGFuZ2UgPz8gbnVsbCxcbiAgICAgICAgICAgICAgICB1bnRhYmJhYmxlOiB1bnRhYmJhYmxlID8/IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgY29sbGF0b3I6IHVzZURlZmF1bHQoXCJjb2xsYXRvclwiLCBjb2xsYXRvciksXG4gICAgICAgICAgICAgICAgbm9UeXBlYWhlYWQ6IHVzZURlZmF1bHQoXCJub1R5cGVhaGVhZFwiLCBub1R5cGVhaGVhZCksXG4gICAgICAgICAgICAgICAgdHlwZWFoZWFkVGltZW91dDogdXNlRGVmYXVsdChcInR5cGVhaGVhZFRpbWVvdXRcIiwgdHlwZWFoZWFkVGltZW91dClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gZ3JpZGxpc3RSb3dDb250ZXh0LFxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiA8R3JpZGxpc3RSb3dDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PntyZW5kZXIoaW5mbyl9PC9HcmlkbGlzdFJvd0NvbnRleHQuUHJvdmlkZXI+XG59KVxuXG5leHBvcnQgY29uc3QgR3JpZGxpc3RDaGlsZCA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIEdyaWRsaXN0Q2hpbGQ8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgaW5kZXgsXG4gICAgY29sU3BhbixcbiAgICBleGNsdWRlLFxuICAgIGZvY3VzU2VsZixcbiAgICBoaWRkZW4sXG4gICAgb25QcmVzc1N5bmMsXG4gICAgZ2V0VGV4dCxcbiAgICByZW5kZXIsXG59OiBHcmlkbGlzdENoaWxkUHJvcHM8Q2VsbEVsZW1lbnQsIEdyaWRsaXN0Q2VsbEluZm88Q2VsbEVsZW1lbnQ+PiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKHVzZUNvbnRleHQoR3JpZGxpc3RSb3dDb250ZXh0KSBhcyBVc2VHcmlkbGlzdFJvd0NvbnRleHQ8YW55LCBDZWxsRWxlbWVudCwgR3JpZGxpc3RDZWxsSW5mbzxDZWxsRWxlbWVudD4+KTtcbiAgICBjb25zdCBpbmZvID0gdXNlR3JpZGxpc3RDZWxsPENlbGxFbGVtZW50LCBHcmlkbGlzdENlbGxJbmZvPENlbGxFbGVtZW50Pj4oe1xuICAgICAgICBjb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM6IHt9LFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBncmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzOiB7IGNvbFNwYW46IGNvbFNwYW4gPz8gMSB9LFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZSwgZm9jdXNTZWxmLCBvblByZXNzU3luYyB9LFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnM6IHsgZ2V0VGV4dDogdXNlRGVmYXVsdChcImdldFRleHRcIiwgZ2V0VGV4dCkgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczogeyBoaWRkZW46IGhpZGRlbiA/PyBmYWxzZSB9XG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcbn0pO1xuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHtcbiAgICBDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ29udGV4dCwgUGFzc2l2ZVN0YXRlVXBkYXRlciwgdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbixcbiAgICB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlLFxuICAgIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlLCB1c2VFbnN1cmVTdGFiaWxpdHksIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm8sIHVzZU1lcmdlZFByb3BzLCB1c2VTaW5nbGVTZWxlY3Rpb25EZWNsYXJhdGl2ZSwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZU9iamVjdFxufSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgRXZlbnREZXRhaWwsIFByZWZpY2VzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUxhYmVsU3ludGhldGljLCBVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcblxuZXhwb3J0IHR5cGUgTGlzdGJveFNpbmdsZVNlbGVjdEV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSB7IFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogbnVtYmVyIH0gfSAmIFBpY2s8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPiwgXCJ0YXJnZXRcIiB8IFwiY3VycmVudFRhcmdldFwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94Q29udGV4dDxMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQ+PiBleHRlbmRzIENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0PExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIE0+IHtcbiAgICBsaXN0Ym94Q29udGV4dDogeyBzZWxlY3Rpb25MaW1pdDogXCJzaW5nbGVcIiB8IFwibXVsdGlcIiB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFBhcmFtZXRlcnM8TGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBNPiwgXCJzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzXCI+IHtcbiAgICBsYWJlbFBhcmFtZXRlcnM6IE9taXQ8VXNlTGFiZWxTeW50aGV0aWNQYXJhbWV0ZXJzW1wibGFiZWxQYXJhbWV0ZXJzXCJdLCBcIm9uTGFiZWxDbGlja1wiPjtcbiAgICBsaXN0Ym94UGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgXCJzaW5nbGVcImAsIHRoZSBzZWxlY3RlZCBpdGVtIGlzIGNvbnRyb2xsZWRcbiAgICAgICAgICogdmlhIGBzZWxlY3RlZEluZGV4YC4gV2hlbiBgXCJtdWx0aVwiYCwgdGhlIHNlbGVjdGVkXG4gICAgICAgICAqIGl0ZW1zIGFyZSBjb250cm9sbGVkIGJ5IHRoZWlyIGluZGl2aWR1YWwgYHNlbGVjdGVkYCBwcm9wcy5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGlvbkxpbWl0OiBcInNpbmdsZVwiIHwgXCJtdWx0aVwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IHVzZWQgd2hlbiBgZ3JvdXBpbmdUeXBlYCBpcyBgXCJ3aXRob3V0LWdyb3Vwc1wiYCBvciBgXCJncm91cFwiYFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRJbmRleDogbnVtYmVyIHwgbnVsbDtcbiAgICAgICAgc2V0U2VsZWN0ZWRJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsLCBFdmVudD47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICogYFwid2l0aG91dC1ncm91cHNcImA6IFRoaXMgaXMgYSBsaXN0Ym94IHdpdGggbm8gZ3JvdXBzXG4gICAgICAgICAqICogYFwid2l0aC1ncm91cHNcImA6IFRoaXMgaXMgYSBsaXN0Ym94IHRoYXQgaXMgZ3JvdXBlZCBpbnRvIDIgb3IgbW9yZSBsYWJlbGxlZCBzZWN0aW9ucy4gSW4gdGhpcyBjYXNlLCAqKmFsbCBuYXZpZ2F0aW9uIGFuZCBzZWxlY3Rpb24gaXMgZGlzYWJsZWQqKiAobWVhbmluZyB5b3UgY2FuIHBhc3Mgd2hhdGV2ZXIgeW91J2QgbGlrZSB0byB0aGVtLCBpdCdzIGFsbCBpZ25vcmVkKSBhbmQgZGVsZWdhdGVkIHRvIHRoZSBjaGlsZCBgZ3JvdXBgcy5cbiAgICAgICAgICogKiBgXCJncm91cFwiYDogVGhpcyBpcyBhIGdyb3VwLCBjb250YWluZWQgd2l0aGluIGEgbGlzdGJveCB3aXRoIGB0eXBlPT1cIndpdGgtZ3JvdXBzXCJgXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gc3VwcG9ydCBmb3IgYSBtaXggb2YgZ3JvdXBlZCBhbmQgdW5ncm91cGVkIG9wdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBncm91cGluZ1R5cGU6IFwid2l0aC1ncm91cHNcIiB8IFwid2l0aG91dC1ncm91cHNcIiB8IFwiZ3JvdXBcIjtcbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hSZXR1cm5UeXBlPExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBNPiwgXCJwcm9wc1wiPiB7XG4gICAgcHJvcHNMaXN0Ym94OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD47XG4gICAgcHJvcHNMaXN0Ym94TGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XG4gICAgY29udGV4dDogVXNlTGlzdGJveENvbnRleHQ8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgTT47XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hJdGVtUmV0dXJuVHlwZTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPExpc3RJdGVtRWxlbWVudCwgTT4geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hJdGVtUGFyYW1ldGVyczxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPExpc3RJdGVtRWxlbWVudCwgTSwgbmV2ZXI+IHtcbiAgICBsaXN0Ym94UGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0aGUgYHNlbGVjdGlvbkxpbWl0YCBpcyBgXCJzaW5nbGVcImAsIHRoaXMgbXVzdCBiZSBgbnVsbGAuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RlZDogYm9vbGVhbiB8IG51bGw7XG4gICAgfVxuICAgIGNvbnRleHQ6IFVzZUxpc3Rib3hDb250ZXh0PGFueSwgTGlzdEl0ZW1FbGVtZW50LCBNPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm88TGlzdEl0ZW1FbGVtZW50PiB7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3Rib3g8TGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4oe1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIGxhYmVsUGFyYW1ldGVycyxcbiAgICBsaXN0Ym94UGFyYW1ldGVyczogeyBzZWxlY3Rpb25MaW1pdCwgZ3JvdXBpbmdUeXBlLCBzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4IH1cbn06IFVzZUxpc3Rib3hQYXJhbWV0ZXJzPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIExhYmVsRWxlbWVudCwgTT4pOiBVc2VMaXN0Ym94UmV0dXJuVHlwZTxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBMYWJlbEVsZW1lbnQsIE0+IHtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VMaXN0Ym94XCIsIHNlbGVjdGlvbkxpbWl0KTtcbiAgICBjb25zdCB7XG4gICAgICAgIHByb3BzSW5wdXQ6IHByb3BzTGFiZWxMaXN0LFxuICAgICAgICBwcm9wc0xhYmVsOiBwcm9wc0xhYmVsTGFiZWwsXG4gICAgICAgIHJhbmRvbUlkSW5wdXRSZXR1cm46IHsgaWQ6IF9pbnB1dElkIH0sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxSZXR1cm46IHsgaWQ6IF9sYWJlbElkIH1cbiAgICB9ID0gdXNlTGFiZWxTeW50aGV0aWM8TGlzdEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIC4uLmxhYmVsUGFyYW1ldGVycyxcbiAgICAgICAgICAgIG9uTGFiZWxDbGljazogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLmZvY3VzU2VsZigpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5saXN0Ym94IH0sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzOiB7IHByZWZpeDogUHJlZmljZXMubGlzdGJveExhYmVsIH1cbiAgICB9KTtcbiAgICBsZXQge1xuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c1JldHVybixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuXG4gICAgfSA9IHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb248TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgTT4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzOiB7IGluaXRpYWxseVNlbGVjdGVkSW5kZXg6IHNlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXggfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXG4gICAgfSk7XG5cbiAgICBjb25zdCBfdjogdm9pZCA9IHVzZVNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlKHsgXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlUGFyYW1ldGVyczogeyBzZWxlY3RlZEluZGV4IH0sIFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm46IHsgc2V0U2VsZWN0ZWRJbmRleDogc2luZ2xlU2VsZWN0aW9uUmV0dXJuLnNldFNlbGVjdGVkSW5kZXggfVxuICAgICB9KVxuXG4gICAgaWYgKGdyb3VwaW5nVHlwZSA9PSBcImdyb3VwXCIpXG4gICAgICAgIHByb3BzLnJvbGUgPSBcImdyb3VwXCI7XG4gICAgZWxzZSBpZiAoZ3JvdXBpbmdUeXBlID09IFwid2l0aC1ncm91cHNcIikge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGNsb2JiZXJpbmcgYWxsIHRoZSBsaXN0IG5hdmlnYXRpb24gc3R1ZmYuXG4gICAgICAgIHByb3BzID0geyByb2xlOiBcImxpc3Rib3hcIiB9O1xuICAgICAgICAvLyAuLi5hY3R1YWxseSwgY29udGV4dCB0b28gd2hpbGUgd2UncmUgYXQgaXQuXG4gICAgICAgIGNvbnRleHQgPSBudWxsIVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvcHMucm9sZSA9IFwibGlzdGJveFwiO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3Rpb25MaW1pdCA9PSBcIm11bHRpXCIpXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNpbmdsZVNlbGVjdGlvblJldHVybi5nZXRTZWxlY3RlZEluZGV4KCkgPT0gbnVsbClcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuLFxuICAgICAgICBjb250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICAgIGxpc3Rib3hDb250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbkxpbWl0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIHByb3BzTGlzdGJveDogdXNlTWVyZ2VkUHJvcHMocHJvcHMsIHByb3BzTGFiZWxMaXN0LCB7IFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIjogKHNlbGVjdGlvbkxpbWl0ID09IFwibXVsdGlcIiA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkKSB9KSxcbiAgICAgICAgcHJvcHNMaXN0Ym94TGFiZWw6IHByb3BzTGFiZWxMYWJlbFxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3Rib3hJdGVtPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQ+Pih7XG4gICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICBwcmVzc1BhcmFtZXRlcnMsXG4gICAgY29udGV4dDogeyBsaXN0Ym94Q29udGV4dDogeyBzZWxlY3Rpb25MaW1pdCB9LCAuLi5jb250ZXh0IH0sXG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnMsXG4gICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgIGxpc3Rib3hQYXJhbWV0ZXJzOiB7IHNlbGVjdGVkIH1cbn06IFVzZUxpc3Rib3hJdGVtUGFyYW1ldGVyczxMaXN0SXRlbUVsZW1lbnQsIE0+KTogVXNlTGlzdGJveEl0ZW1SZXR1cm5UeXBlPExpc3RJdGVtRWxlbWVudCwgTT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm4sXG4gICAgICAgIHByZXNzUmV0dXJuLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5cbiAgICB9ID0gdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkPExpc3RJdGVtRWxlbWVudCwgTSwgbmV2ZXI+KHtcbiAgICAgICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnMsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBjb250ZXh0XG4gICAgfSk7XG5cblxuICAgIGlmIChzZWxlY3Rpb25MaW1pdCA9PSBcInNpbmdsZVwiKVxuICAgICAgICBjb25zb2xlLmFzc2VydChzZWxlY3RlZCA9PSBudWxsKTtcblxuICAgIHByb3BzLnJvbGUgPSBcIm9wdGlvblwiO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm4sXG4gICAgICAgIHByZXNzUmV0dXJuLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5cbiAgICB9XG59XG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3Rib3hHcm91cDxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSGVhZGluZ0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PigpIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHByb3BzUmVmZXJlbmNlcixcbiAgICAgICAgcHJvcHNTb3VyY2UsXG4gICAgICAgIHJhbmRvbUlkUmV0dXJuXG4gICAgfSA9IHVzZVJhbmRvbUlkPEhlYWRpbmdFbGVtZW50LCBDb250YWluZXJFbGVtZW50Pih7IHJhbmRvbUlkUGFyYW1ldGVyczogeyBwcmVmaXg6IFwibGlzdGJveC1tdWx0aS1ncm91cC1cIiwgb3RoZXJSZWZlcmVuY2VyUHJvcDogXCJhcmlhLWxhYmVsbGVkYnlcIiB9IH0pO1xuXG4gICAgcHJvcHNSZWZlcmVuY2VyLnJvbGUgPSBcImdyb3VwXCI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wc0hlYWRpbmc6IHByb3BzU291cmNlLFxuICAgICAgICBwcm9wc0NvbnRhaW5lcjogcHJvcHNSZWZlcmVuY2VyXG4gICAgfVxufSovXG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFdmVudERldGFpbCB9IGZyb20gXCIuLi9wcm9wc1wiO1xuaW1wb3J0IHsgTGlzdGJveEluZm8sIHVzZUxpc3Rib3gsIFVzZUxpc3Rib3hQYXJhbWV0ZXJzLCBVc2VMaXN0Ym94Q29udGV4dCwgVXNlTGlzdGJveFJldHVyblR5cGUsIFVzZUxpc3Rib3hJdGVtUGFyYW1ldGVycywgTGlzdGJveFNpbmdsZVNlbGVjdEV2ZW50LCBVc2VMaXN0Ym94SXRlbVJldHVyblR5cGUsIHVzZUxpc3Rib3hJdGVtIH0gZnJvbSBcIi4uL3VzZS1saXN0Ym94XCI7XG5pbXBvcnQgeyBQYXJ0aWFsRXhjZXB0LCB1c2VEZWZhdWx0IH0gZnJvbSBcIi4vdXRpbFwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xudHlwZSBHZXQyPFQsIEsgZXh0ZW5kcyBrZXlvZiBULCBLMiBleHRlbmRzIGtleW9mIFRbS10+ID0gVFtLXVtLMl07XG5cbmludGVyZmFjZSBMaXN0Ym94UHJvcHNCYXNlPExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+IGV4dGVuZHNcbiAgICBHZXQ8VXNlTGlzdGJveFBhcmFtZXRlcnM8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgTGFiZWxFbGVtZW50LCBNPiwgXCJsYWJlbFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hQYXJhbWV0ZXJzPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIExhYmVsRWxlbWVudCwgTT4sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hQYXJhbWV0ZXJzPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIExhYmVsRWxlbWVudCwgTT4sIFwibGlzdGJveFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hQYXJhbWV0ZXJzPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIExhYmVsRWxlbWVudCwgTT4sIFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTGlzdGJveFBhcmFtZXRlcnM8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgTGFiZWxFbGVtZW50LCBNPiwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hQYXJhbWV0ZXJzPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIExhYmVsRWxlbWVudCwgTT4sIFwic29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hQYXJhbWV0ZXJzPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIExhYmVsRWxlbWVudCwgTT4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4ge1xuICAgIHJlZj86IFJlZjxVc2VMaXN0Ym94UmV0dXJuVHlwZTxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBMYWJlbEVsZW1lbnQsIE0+Pjtcbn1cblxuaW50ZXJmYWNlIExpc3Rib3hJdGVtUHJvcHNCYXNlPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQ+PiBleHRlbmRzXG4gICAgR2V0PFVzZUxpc3Rib3hJdGVtUGFyYW1ldGVyczxMaXN0SXRlbUVsZW1lbnQsIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+LCBcImxpc3Rib3hQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94SXRlbVBhcmFtZXRlcnM8TGlzdEl0ZW1FbGVtZW50LCBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQ+PiwgXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94SXRlbVBhcmFtZXRlcnM8TGlzdEl0ZW1FbGVtZW50LCBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQ+PiwgXCJwcmVzc1BhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hJdGVtUGFyYW1ldGVyczxMaXN0SXRlbUVsZW1lbnQsIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+LCBcInNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94SXRlbVBhcmFtZXRlcnM8TGlzdEl0ZW1FbGVtZW50LCBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQ+PiwgXCJyb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTGlzdGJveEl0ZW1QYXJhbWV0ZXJzPExpc3RJdGVtRWxlbWVudCwgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4sIFwic2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94SXRlbVBhcmFtZXRlcnM8TGlzdEl0ZW1FbGVtZW50LCBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQ+PiwgXCJ0ZXh0Q29udGVudFBhcmFtZXRlcnNcIj4ge1xuICAgIHJlZj86IFJlZjxVc2VMaXN0Ym94SXRlbVJldHVyblR5cGU8TGlzdEl0ZW1FbGVtZW50LCBNPj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGJveFByb3BzPExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxMaXN0Ym94UHJvcHNCYXNlPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIExhYmVsRWxlbWVudCwgTT4sIFwiYXJpYUxhYmVsXCIgfCBcImdyb3VwaW5nVHlwZVwiIHwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCIgfCBcInNlbGVjdGlvbkxpbWl0XCIgfCBcInNlbGVjdGVkSW5kZXhcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VMaXN0Ym94UmV0dXJuVHlwZTxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBMYWJlbEVsZW1lbnQsIE0+KTogVk5vZGU7XG59XG5leHBvcnQgaW50ZXJmYWNlIExpc3Rib3hJdGVtUHJvcHM8TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxMaXN0Ym94SXRlbVByb3BzQmFzZTxMaXN0SXRlbUVsZW1lbnQsIE0+LCBcImFyaWFQcm9wTmFtZVwiIHwgXCJpbmRleFwiIHwgXCJnZXRTb3J0VmFsdWVcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VMaXN0Ym94SXRlbVJldHVyblR5cGU8TGlzdEl0ZW1FbGVtZW50LCBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQ+Pik6IFZOb2RlO1xufVxuXG5jb25zdCBMaXN0Ym94Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTGlzdGJveENvbnRleHQ8YW55LCBhbnksIGFueT4+KG51bGwhKTtcblxuZXhwb3J0IGZ1bmN0aW9uIExpc3Rib3g8TGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgYXJpYUxhYmVsLFxuICAgIGNvbGxhdG9yLFxuICAgIGNvbXBhcmUsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgZ2V0SW5kZXgsXG4gICAgc2VsZWN0ZWRJbmRleCxcbiAgICBuYXZpZ2F0ZVBhc3RFbmQsXG4gICAgbmF2aWdhdGVQYXN0U3RhcnQsXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICBub1R5cGVhaGVhZCxcbiAgICBzZXRTZWxlY3RlZEluZGV4LFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBwYWdlTmF2aWdhdGlvblNpemUsXG4gICAgc2VsZWN0aW9uTGltaXQsXG4gICAgZ3JvdXBpbmdUeXBlLFxuICAgIHVudGFiYmFibGUsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICByZW5kZXJcbn06IExpc3Rib3hQcm9wczxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBMYWJlbEVsZW1lbnQsIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+KSB7XG4gICAgY29uc3QgaW5mbyA9IHVzZUxpc3Rib3g8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgTGFiZWxFbGVtZW50LCBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQ+Pih7XG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczogeyBhcmlhTGFiZWwgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZDogbmF2aWdhdGVQYXN0RW5kID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IG5hdmlnYXRlUGFzdFN0YXJ0ID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcblxuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5czogdXNlRGVmYXVsdChcImRpc2FibGVBcnJvd0tleXNcIiwgZGlzYWJsZUFycm93S2V5cyksXG4gICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlSG9tZUVuZEtleXNcIiwgZGlzYWJsZUhvbWVFbmRLZXlzKSxcbiAgICAgICAgICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZTogdXNlRGVmYXVsdChcInBhZ2VOYXZpZ2F0aW9uU2l6ZVwiLCBwYWdlTmF2aWdhdGlvblNpemUpXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3Rib3hQYXJhbWV0ZXJzOiB7IHNlbGVjdGlvbkxpbWl0LCBncm91cGluZ1R5cGUsIHNlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXg6IHNldFNlbGVjdGVkSW5kZXggPz8gbm9vcCB9LFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IGdldEluZGV4OiB1c2VEZWZhdWx0KFwiZ2V0SW5kZXhcIiwgZ2V0SW5kZXgpIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IG9uVGFiYmFibGVJbmRleENoYW5nZSA/PyBudWxsLCB1bnRhYmJhYmxlOiB1bnRhYmJhYmxlID8/IGZhbHNlIH0sXG4gICAgICAgIC8vc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogeyBpbml0aWFsbHlTZWxlY3RlZEluZGV4OiBpbml0aWFsbHlTZWxlY3RlZEluZGV4ID8/IG51bGwsIHNldFNlbGVjdGVkSW5kZXg6IHNldFNlbGVjdGVkSW5kZXggPz8gbnVsbCB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBjb21wYXJlOiBjb21wYXJlID8/IG51bGwgfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGNvbGxhdG9yOiB1c2VEZWZhdWx0KFwiY29sbGF0b3JcIiwgY29sbGF0b3IpLFxuICAgICAgICAgICAgbm9UeXBlYWhlYWQ6IHVzZURlZmF1bHQoXCJub1R5cGVhaGVhZFwiLCBub1R5cGVhaGVhZCksXG4gICAgICAgICAgICB0eXBlYWhlYWRUaW1lb3V0OiB1c2VEZWZhdWx0KFwidHlwZWFoZWFkVGltZW91dFwiLCB0eXBlYWhlYWRUaW1lb3V0KVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8TGlzdGJveENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2luZm8uY29udGV4dH0+e3JlbmRlcihpbmZvKX08L0xpc3Rib3hDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIExpc3Rib3hJdGVtPExpc3Rib3hJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgYXJpYVByb3BOYW1lLCBkaXNhYmxlZCwgZXhjbHVkZSwgZm9jdXNTZWxmLCBnZXRUZXh0LCBoaWRkZW4sIGluZGV4LCBvblByZXNzU3luYywgcmVuZGVyLCBzZWxlY3RlZCwgc2VsZWN0aW9uTW9kZSwgZ2V0U29ydFZhbHVlIH06IExpc3Rib3hJdGVtUHJvcHM8TGlzdGJveEl0ZW1FbGVtZW50LCBMaXN0Ym94SW5mbzxMaXN0Ym94SXRlbUVsZW1lbnQ+Pikge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KExpc3Rib3hDb250ZXh0KSBhcyBVc2VMaXN0Ym94Q29udGV4dDxhbnksIExpc3Rib3hJdGVtRWxlbWVudCwgTGlzdGJveEluZm88TGlzdGJveEl0ZW1FbGVtZW50Pj47XG4gICAgY29uc3QgZm9jdXNTZWxmRGVmYXVsdCA9IHVzZUNhbGxiYWNrKChlOiBhbnkpID0+IHsgZT8uZm9jdXMoKTsgfSwgW10pO1xuICAgIGNvbnN0IGluZm8gPSB1c2VMaXN0Ym94SXRlbSh7XG4gICAgICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHt9LFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBsaXN0Ym94UGFyYW1ldGVyczogeyBzZWxlY3RlZDogc2VsZWN0ZWQgPz8gbnVsbCwgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczogeyBoaWRkZW46IGhpZGRlbiA/PyBmYWxzZSB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVyczogeyBnZXRTb3J0VmFsdWU6IGdldFNvcnRWYWx1ZSB9LFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZSwgZm9jdXNTZWxmOiBmb2N1c1NlbGYgPz8gZm9jdXNTZWxmRGVmYXVsdCwgb25QcmVzc1N5bmMgfSxcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzOiB7IGdldFRleHQ6IHVzZURlZmF1bHQoXCJnZXRUZXh0XCIsIGdldFRleHQpIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlLFxuICAgICAgICAgICAgYXJpYVByb3BOYW1lLFxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZTogdXNlRGVmYXVsdChcInNlbGVjdGlvbk1vZGVcIiwgc2VsZWN0aW9uTW9kZSlcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW9MaXN0Ym94KCkge1xuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPExpc3Rib3g8SFRNTE9MaXN0RWxlbWVudCwgSFRNTExJRWxlbWVudCwgSFRNTExhYmVsRWxlbWVudD5cbiAgICAgICAgICAgIGFyaWFMYWJlbD17bnVsbH1cbiAgICAgICAgICAgIGNvbGxhdG9yPXtudWxsfVxuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5cz17ZmFsc2V9XG4gICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXM9e2ZhbHNlfVxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kPVwid3JhcFwiXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydD1cIndyYXBcIlxuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleD17c2VsZWN0ZWRJbmRleH1cbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXg9e2UgPT4gc2V0U2VsZWN0ZWRJbmRleChlKX1cbiAgICAgICAgICAgIGdldEluZGV4PXt2ID0+IHYucHJvcHMuaW5kZXh9XG4gICAgICAgICAgICBub1R5cGVhaGVhZD17ZmFsc2V9XG4gICAgICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uPVwidmVydGljYWxcIlxuICAgICAgICAgICAgc2VsZWN0aW9uTGltaXQ9XCJzaW5nbGVcIlxuICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPXtudWxsfVxuICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplPXswLjF9XG4gICAgICAgICAgICBncm91cGluZ1R5cGU9XCJ3aXRob3V0LWdyb3Vwc1wiXG4gICAgICAgICAgICB0eXBlYWhlYWRUaW1lb3V0PXsxMDAwfVxuICAgICAgICAgICAgY29tcGFyZT17KChsaHMsIHJocykgPT4gbGhzLmluZGV4IC0gcmhzLmluZGV4KX1cbiAgICAgICAgICAgIHJlbmRlcj17aW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCB7Li4uaW5mby5wcm9wc0xpc3Rib3hMYWJlbH0+TGlzdGJveDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8b2wgey4uLmluZm8ucHJvcHNMaXN0Ym94fT48L29sPlxuICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW9MaXN0Ym94SXRlbSh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPExpc3Rib3hJdGVtPEhUTUxMSUVsZW1lbnQ+XG4gICAgICAgICAgICBhcmlhUHJvcE5hbWU9XCJhcmlhLXNlbGVjdGVkXCJcbiAgICAgICAgICAgIGRpc2FibGVkPXtmYWxzZX1cbiAgICAgICAgICAgIGV4Y2x1ZGU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGdldFNvcnRWYWx1ZT17cmV0dXJuTnVsbH1cbiAgICAgICAgICAgIGZvY3VzU2VsZj17ZSA9PiBlLmZvY3VzKCl9XG4gICAgICAgICAgICBoaWRkZW49e2ZhbHNlfVxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgb25QcmVzc1N5bmM9e251bGx9XG4gICAgICAgICAgICBzZWxlY3RlZD17bnVsbH1cbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU9XCJhY3RpdmF0aW9uXCJcbiAgICAgICAgICAgIHJlbmRlcj17aW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPGxpIHsuLi5pbmZvLnByb3BzfT5MaXN0IGl0ZW0gKGluZGV4ICN7aW5kZXh9KTwvbGk+XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICApXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgVXNlTWVudUNvbnRleHQsIHVzZU1lbnVJdGVtLCBVc2VNZW51SXRlbVJldHVyblR5cGUgfSBmcm9tIFwiLi4vdXNlLW1lbnVcIjtcbmltcG9ydCB7IFVzZVRvb2xiYXJDb250ZXh0IH0gZnJvbSBcIi4uL3VzZS10b29sYmFyXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCIuLi9wcm9wc1wiO1xuLy9pbXBvcnQgeyBFbGVtZW50VG9UYWcgfSBmcm9tIFwiLi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZU1lbnViYXIsIFVzZU1lbnViYXJQYXJhbWV0ZXJzLCBVc2VNZW51YmFySXRlbVBhcmFtZXRlcnMsIFVzZU1lbnViYXJTdWJJbmZvLCBVc2VNZW51YmFyUmV0dXJuVHlwZSB9IGZyb20gXCIuLi91c2UtbWVudWJhclwiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlclBvcnRhbCB9IGZyb20gXCIuL2RpYWxvZ1wiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcnRpYWxFeGNlcHQsIHVzZURlZmF1bHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmludGVyZmFjZSBNZW51YmFyUHJvcHNCYXNlPE1lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+IGV4dGVuZHNcbiAgICBHZXQ8VXNlTWVudWJhclBhcmFtZXRlcnM8TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTT4sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnViYXJQYXJhbWV0ZXJzPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+LCBcInJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudWJhclBhcmFtZXRlcnM8TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTT4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnViYXJQYXJhbWV0ZXJzPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+LCBcInNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnViYXJQYXJhbWV0ZXJzPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+LCBcInJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnViYXJQYXJhbWV0ZXJzPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+LCBcInNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51YmFyUGFyYW1ldGVyczxNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPiwgXCJtZW51YmFyUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudWJhclBhcmFtZXRlcnM8TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTT4sIFwidG9vbGJhclBhcmFtZXRlcnNcIj4ge1xuICAgIC8vdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xuICAgIHJlZj86IFJlZjxVc2VNZW51YmFyUmV0dXJuVHlwZTxNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPj47XG59XG5cblxuXG5cblxuaW50ZXJmYWNlIE1lbnVJdGVtUHJvcHNCYXNlPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICAvL0dldDxVc2VNZW51YmFySXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50LCBNPiwgXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51YmFySXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJtZW51SXRlbVBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnViYXJJdGVtUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcInByZXNzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudWJhckl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4sIFwicm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnViYXJJdGVtUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcInNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51YmFySXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51YmFySXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnViYXJJdGVtUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcInRleHRDb250ZW50UGFyYW1ldGVyc1wiPiB7XG4gICAgLy90YWdMaXN0SXRlbTogRWxlbWVudFRvVGFnPExpc3Rib3hJdGVtRWxlbWVudD47XG4gICAgLy9zdWJJbmZvOiBHZXQ8VXNlTWVudWJhckl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4sIFwiY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyc1wiPjtcbiAgICByZWY/OiBSZWY8VXNlTWVudUl0ZW1SZXR1cm5UeXBlPE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lbnViYXJQcm9wczxNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiBleHRlbmRzIFBhcnRpYWxFeGNlcHQ8TWVudWJhclByb3BzQmFzZTxNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPiwgXCJvcmllbnRhdGlvblwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZU1lbnViYXJSZXR1cm5UeXBlPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+KTogVk5vZGU8YW55Pjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTWVudUl0ZW1Qcm9wczxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFBhcnRpYWxFeGNlcHQ8TWVudUl0ZW1Qcm9wc0Jhc2U8TWVudUl0ZW1FbGVtZW50PiwgXCJhcmlhUHJvcE5hbWVcIiB8IFwiaW5kZXhcIiB8IFwic2VsZWN0aW9uTW9kZVwiIHwgXCJnZXRTb3J0VmFsdWVcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VNZW51SXRlbVJldHVyblR5cGU8TWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+Pik6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBjb25zdCBNZW51SXRlbUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZU1lbnVDb250ZXh0PGFueSwgYW55LCBhbnk+PihudWxsISk7XG5cbmV4cG9ydCBjb25zdCBNZW51YmFyID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gTWVudWJhclU8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICByZW5kZXIsXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgbmF2aWdhdGVQYXN0RW5kLFxuICAgIG5hdmlnYXRlUGFzdFN0YXJ0LFxuICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZSxcbiAgICBvcmllbnRhdGlvbixcbiAgICBub1R5cGVhaGVhZCxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgY29tcGFyZSxcbiAgICBnZXRJbmRleCxcbiAgICB1bnRhYmJhYmxlLFxuICAgIGluaXRpYWxseVNlbGVjdGVkSW5kZXgsXG4gICAgc2V0U2VsZWN0ZWRJbmRleCxcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIHJvbGVcbn06IE1lbnViYXJQcm9wczxDb250YWluZXJFbGVtZW50LCBDaGlsZEVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPENoaWxkRWxlbWVudD4+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGluZm8gPSB1c2VNZW51YmFyPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBcbiAgICAgICAgICAgIGRpc2FibGVBcnJvd0tleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlQXJyb3dLZXlzXCIsIGRpc2FibGVBcnJvd0tleXMpLCBcbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5czogdXNlRGVmYXVsdChcImRpc2FibGVIb21lRW5kS2V5c1wiLCBkaXNhYmxlSG9tZUVuZEtleXMpLCBcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZDogbmF2aWdhdGVQYXN0RW5kID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IG5hdmlnYXRlUGFzdFN0YXJ0ID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplOiB1c2VEZWZhdWx0KFwicGFnZU5hdmlnYXRpb25TaXplXCIsIHBhZ2VOYXZpZ2F0aW9uU2l6ZSlcbiAgICAgICAgIH0sXG4gICAgICAgIHRvb2xiYXJQYXJhbWV0ZXJzOiB7IG9yaWVudGF0aW9uIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IG9uVGFiYmFibGVJbmRleENoYW5nZSA/PyBudWxsLCB1bnRhYmJhYmxlOiB1bnRhYmJhYmxlID8/IGZhbHNlIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IFxuICAgICAgICAgICAgY29sbGF0b3I6IHVzZURlZmF1bHQoXCJjb2xsYXRvclwiLCBjb2xsYXRvciksIFxuICAgICAgICAgICAgbm9UeXBlYWhlYWQ6IHVzZURlZmF1bHQoXCJub1R5cGVhaGVhZFwiLCBub1R5cGVhaGVhZCksIFxuICAgICAgICAgICAgdHlwZWFoZWFkVGltZW91dDogdXNlRGVmYXVsdChcInR5cGVhaGVhZFRpbWVvdXRcIiwgdHlwZWFoZWFkVGltZW91dClcbiAgICAgICAgIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgZ2V0SW5kZXg6IHVzZURlZmF1bHQoXCJnZXRJbmRleFwiLCBnZXRJbmRleCkgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogeyBpbml0aWFsbHlTZWxlY3RlZEluZGV4OiBpbml0aWFsbHlTZWxlY3RlZEluZGV4ID8/IG51bGwsIHNldFNlbGVjdGVkSW5kZXg6IHNldFNlbGVjdGVkSW5kZXggPz8gbnVsbCB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBjb21wYXJlOiBjb21wYXJlID8/IG51bGwgfSxcbiAgICAgICAgbWVudWJhclBhcmFtZXRlcnM6IHsgcm9sZTogcm9sZSA/PyBcIm1lbnViYXJcIiB9XG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8TWVudUl0ZW1Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PlxuICAgICAgICAgICAge3JlbmRlcihpbmZvKX1cbiAgICAgICAgPC9NZW51SXRlbUNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufSlcblxuXG5leHBvcnQgY29uc3QgTWVudUl0ZW0gPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBNZW51SXRlbVU8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluZGV4LFxuICAgIHJlbmRlcixcbiAgICBhcmlhUHJvcE5hbWUsXG4gICAgZXhjbHVkZSxcbiAgICBzZWxlY3Rpb25Nb2RlLFxuICAgIGhpZGRlbixcbiAgICBnZXRUZXh0LFxuICAgIGRpc2FibGVkLFxuICAgIG9uUHJlc3MsXG4gICAgZ2V0U29ydFZhbHVlLFxuICAgIHJvbGUsXG59OiBNZW51SXRlbVByb3BzPE1lbnVJdGVtRWxlbWVudD4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgY29udGV4dCA9ICh1c2VDb250ZXh0KE1lbnVJdGVtQ29udGV4dCkpOyAvKjxNZW51SXRlbUVsZW1lbnQsIEMsIEs+KSh7XG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmLCBoaWRkZW4sIG5vTW9kaWZ5VGFiSW5kZXggfSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxuICAgICAgICBoYXNGb2N1czogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UgfSxcbiAgICAgICAgbWVudUl0ZW06IHsgZGlzYWJsZWQsIG9uUHJlc3MsIHJvbGUgfSxcbiAgICAgICAgc3ViSW5mb1xuICAgIH0pOyovXG5cbiAgICBjb25zdCBpbmZvID0gdXNlTWVudUl0ZW0oe1xuICAgICAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczogeyBoaWRkZW46IGhpZGRlbiA/PyBmYWxzZSB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVyczogeyBnZXRTb3J0VmFsdWUgfSxcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzOiB7IGdldFRleHQ6IHVzZURlZmF1bHQoXCJnZXRUZXh0XCIsIGdldFRleHQpIH0sXG4gICAgICAgIG1lbnVJdGVtUGFyYW1ldGVyczogeyBvblByZXNzOiBvblByZXNzID8/IG51bGwsIHJvbGU6IHJvbGUgPz8gXCJtZW51aXRlbVwiIH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczogeyBleGNsdWRlIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczogeyBhcmlhUHJvcE5hbWUsIHNlbGVjdGlvbk1vZGUsIGRpc2FibGVkOiBkaXNhYmxlZCA/PyBmYWxzZSB9XG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD57cmVuZGVyKGluZm8pfTwvPlxuICAgIClcbn0pXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gRGVtb01lbnViYXIoKSB7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8TWVudWJhcjxIVE1MVUxpc3RFbGVtZW50LCBIVE1MTElFbGVtZW50PlxuICAgICAgICAgICAgY29sbGF0b3I9e251bGx9XG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzPXtmYWxzZX1cbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5cz17ZmFsc2V9XG4gICAgICAgICAgICBnZXRJbmRleD17diA9PiB2LnByb3BzLmluZGV4fVxuICAgICAgICAgICAgY29tcGFyZT17KGxocywgcmhzKSA9PiBsaHMuaW5kZXggLSByaHMuaW5kZXh9XG4gICAgICAgICAgICBpbml0aWFsbHlTZWxlY3RlZEluZGV4PXtudWxsfVxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kPVwid3JhcFwiXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydD1cIndyYXBcIlxuICAgICAgICAgICAgbm9UeXBlYWhlYWQ9e2ZhbHNlfVxuICAgICAgICAgICAgc2V0U2VsZWN0ZWRJbmRleD17bnVsbH1cbiAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZT17bnVsbH1cbiAgICAgICAgICAgIG9yaWVudGF0aW9uPVwidmVydGljYWxcIlxuICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplPXswLjF9XG4gICAgICAgICAgICB0eXBlYWhlYWRUaW1lb3V0PXsxMDAwfVxuICAgICAgICAgICAgcm9sZT17XCJtZW51XCJ9XG4gICAgICAgICAgICByZW5kZXI9e2luZm8gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dWwgey4uLmluZm8ucHJvcHN9PlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW9NZW51YmFySXRlbSh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPE1lbnVJdGVtPEhUTUxMSUVsZW1lbnQ+XG4gICAgICAgICAgICBleGNsdWRlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBoaWRkZW49e2ZhbHNlfVxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIG9uUHJlc3M9e25vb3B9XG4gICAgICAgICAgICBnZXRTb3J0VmFsdWU9e3JldHVybk51bGx9XG4gICAgICAgICAgICByZW5kZXI9e2luZm8gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGkgey4uLmluZm8ucHJvcHN9Pkxpc3QgaXRlbSAoaW5kZXggI3tpbmRleH0pPC9saT5cbiAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgICAgICAgICBhcmlhUHJvcE5hbWU9XCJhcmlhLXNlbGVjdGVkXCJcbiAgICAgICAgICAgIGRpc2FibGVkPXtmYWxzZX1cblxuICAgICAgICAvPlxuICAgIClcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHsgfVxuXG5cbi8qXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlck1lbnViYXI8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbWFrZVByb3BzQ29udGFpbmVyLCB0YWdDb250YWluZXIgfTogeyB0YWdDb250YWluZXI6IEVsZW1lbnRUb1RhZzxDb250YWluZXJFbGVtZW50PiwgbWFrZVByb3BzQ29udGFpbmVyOiAoaW5mbzogVXNlTWVudWJhclJldHVyblR5cGU8Q29udGFpbmVyRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlTWVudWJhclJldHVyblR5cGU8Q29udGFpbmVyRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+Pik6IFZOb2RlPGFueT4ge1xuICAgICAgICBjb25zdCBsaXN0ID0gY3JlYXRlRWxlbWVudCh0YWdDb250YWluZXIgYXMgbmV2ZXIsIG1ha2VQcm9wc0NvbnRhaW5lcihpbmZvKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIHtsaXN0fVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyTWVudUl0ZW08Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNDaGlsZCwgdGFnQ2hpbGQgfTogeyB0YWdDaGlsZDogRWxlbWVudFRvVGFnPENoaWxkRWxlbWVudD4sIG1ha2VQcm9wc0NoaWxkOiAoaW5mbzogVXNlTWVudUl0ZW1SZXR1cm5UeXBlPENoaWxkRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88Q2hpbGRFbGVtZW50Pj4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlTWVudUl0ZW1SZXR1cm5UeXBlPENoaWxkRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88Q2hpbGRFbGVtZW50Pj4sIG1vZGlmeVByb3BzTGlzdEl0ZW06IFByb3BNb2RpZmllcjxDaGlsZEVsZW1lbnQ+KTogVk5vZGU8YW55PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0NoaWxkIGFzIG5ldmVyLCBtb2RpZnlQcm9wc0xpc3RJdGVtKG1ha2VQcm9wc0NoaWxkKGluZm8pKSk7XG4gICAgfVxufSovXG5cbiIsImltcG9ydCB7IFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTWVudSwgdXNlTWVudUl0ZW0sIFVzZU1lbnVQYXJhbWV0ZXJzLCBVc2VNZW51UmV0dXJuVHlwZSB9IGZyb20gXCIuLi91c2UtbWVudVwiO1xuaW1wb3J0IHsgVXNlTWVudWJhclN1YkluZm8gfSBmcm9tIFwiLi4vdXNlLW1lbnViYXJcIjtcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJQb3J0YWwgfSBmcm9tIFwiLi9kaWFsb2dcIjtcbmltcG9ydCB7IE1lbnVJdGVtLCBNZW51SXRlbUNvbnRleHQgfSBmcm9tIFwiLi9tZW51YmFyXCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiwgUGFyZW50RGVwdGhDb250ZXh0LCBQYXJ0aWFsRXhjZXB0LCB1c2VEZWZhdWx0IH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cblxuaW50ZXJmYWNlIE1lbnVQcm9wc0Jhc2U8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgLy9PbWl0PFVzZU1lbnVQYXJhbWV0ZXJzPEUsIEssIEk+LCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiIHwgXCJvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3RcIiB8IFwib25DaGlsZHJlbk1vdW50Q2hhbmdlXCIgfCBcIm9uVGFiYmFibGVJbmRleENoYW5nZVwiIHwgXCJvblRhYmJhYmxlUmVuZGVyXCIgfCBcIm9uVGFiYmVkSW5Ub1wiIHwgXCJvblRhYmJlZE91dE9mXCI+ICYge1xuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcIm1lbnVQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcIm1lbnVTdXJmYWNlUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4sIFwiZGlzbWlzc1BhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4sIFwiZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4sIFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcInRvb2xiYXJQYXJhbWV0ZXJzXCI+IHtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZW51UHJvcHM8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxNZW51UHJvcHNCYXNlPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+LCBcIm9wZW5cIiB8IFwib25DbG9zZVwiIHwgXCJvbk9wZW5cIiB8IFwib3BlbkRpcmVjdGlvblwiIHwgXCJvcmllbnRhdGlvblwiPiB7XG4gICAgcmVuZGVyKG1lbnVJbmZvOiBVc2VNZW51UmV0dXJuVHlwZTxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+Pik6IFZOb2RlO1xufVxuXG4vL2NvbnN0IE1lbnVJdGVtQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTWVudUl0ZW08YW55LCBhbnksIGFueT4+KG51bGwhKTtcblxuZXhwb3J0IGNvbnN0IE1lbnUgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBNZW51PFN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNlbnRpbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDID0gdW5kZWZpbmVkLCBLIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KHtcblxuXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICBvcmllbnRhdGlvbixcblxuICAgIG9uQ2xvc2UsXG4gICAgb3BlbixcblxuICAgIG9wZW5EaXJlY3Rpb24sXG5cbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgY2xvc2VPbkJhY2tkcm9wLFxuICAgIGNsb3NlT25Fc2NhcGUsXG4gICAgY2xvc2VPbkxvc3RGb2N1cyxcbiAgICBjb21wYXJlLFxuICAgIGdldEluZGV4LFxuICAgIGluaXRpYWxseVNlbGVjdGVkSW5kZXgsXG4gICAgbmF2aWdhdGVQYXN0RW5kLFxuICAgIG5hdmlnYXRlUGFzdFN0YXJ0LFxuICAgIHNldFNlbGVjdGVkSW5kZXgsXG4gICAgcGFnZU5hdmlnYXRpb25TaXplLFxuICAgIHBhcmVudERlcHRoLFxuICAgIHVudGFiYmFibGUsXG4gICAgb25PcGVuLFxuXG4gICAgZ2V0V2luZG93LFxuXG4gICAgcmVuZGVyXG5cbn06IE1lbnVQcm9wczxTdXJmYWNlRWxlbWVudCwgUGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBCdXR0b25FbGVtZW50PiwgcmVmPzogUmVmPGFueT4pIHtcblxuICAgIGNvbnN0IGRlZmF1bHRQYXJlbnREZXB0aCA9IHVzZUNvbnRleHQoUGFyZW50RGVwdGhDb250ZXh0KTtcbiAgICBsZXQgbXlEZXB0aCA9IChwYXJlbnREZXB0aCA/PyBkZWZhdWx0UGFyZW50RGVwdGgpICsgMTtcblxuICAgIGNvbnN0IGluZm8gPSB1c2VNZW51PFN1cmZhY2VFbGVtZW50LCBQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQ+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGRpc2FibGVBcnJvd0tleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlQXJyb3dLZXlzXCIsIGRpc2FibGVBcnJvd0tleXMpLFxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUhvbWVFbmRLZXlzXCIsIGRpc2FibGVIb21lRW5kS2V5cyksXG4gICAgICAgICAgICBwYWdlTmF2aWdhdGlvblNpemU6IHVzZURlZmF1bHQoXCJwYWdlTmF2aWdhdGlvblNpemVcIiwgcGFnZU5hdmlnYXRpb25TaXplKSxcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZDogXCJ3cmFwXCIsXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydDogXCJ3cmFwXCJcbiAgICAgICAgfSxcbiAgICAgICAgZGlzbWlzc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGNsb3NlT25CYWNrZHJvcDogY2xvc2VPbkJhY2tkcm9wID8/IHRydWUsXG4gICAgICAgICAgICBjbG9zZU9uRXNjYXBlOiBjbG9zZU9uRXNjYXBlID8/IHRydWUsXG4gICAgICAgICAgICBjbG9zZU9uTG9zdEZvY3VzOiBjbG9zZU9uTG9zdEZvY3VzID8/IHRydWUsXG4gICAgICAgICAgICBvbkNsb3NlLFxuICAgICAgICAgICAgb3BlblxuICAgICAgICB9LFxuICAgICAgICBlc2NhcGVEaXNtaXNzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZ2V0V2luZG93OiB1c2VEZWZhdWx0KFwiZ2V0V2luZG93XCIsIGdldFdpbmRvdyksXG4gICAgICAgICAgICBwYXJlbnREZXB0aDogcGFyZW50RGVwdGggPz8gZGVmYXVsdFBhcmVudERlcHRoXG4gICAgICAgIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgZ2V0SW5kZXg6IHVzZURlZmF1bHQoXCJnZXRJbmRleFwiLCBnZXRJbmRleCkgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogeyBpbml0aWFsbHlTZWxlY3RlZEluZGV4OiBpbml0aWFsbHlTZWxlY3RlZEluZGV4ID8/IG51bGwsIHNldFNlbGVjdGVkSW5kZXg6IHNldFNlbGVjdGVkSW5kZXggPz8gbnVsbCB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBjb21wYXJlOiBjb21wYXJlID8/IG51bGwgfSxcbiAgICAgICAgbWVudVBhcmFtZXRlcnM6IHsgb3BlbkRpcmVjdGlvbiwgb25PcGVuIH0sXG4gICAgICAgIG1lbnVTdXJmYWNlUGFyYW1ldGVyczoge30sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiBvblRhYmJhYmxlSW5kZXhDaGFuZ2UgPz8gbnVsbCxcbiAgICAgICAgICAgIHVudGFiYmFibGU6IHVudGFiYmFibGUgPz8gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGNvbGxhdG9yOiB1c2VEZWZhdWx0KFwiY29sbGF0b3JcIiwgY29sbGF0b3IpLFxuICAgICAgICAgICAgbm9UeXBlYWhlYWQ6IHVzZURlZmF1bHQoXCJub1R5cGVhaGVhZFwiLCBub1R5cGVhaGVhZCksXG4gICAgICAgICAgICB0eXBlYWhlYWRUaW1lb3V0OiB1c2VEZWZhdWx0KFwidHlwZWFoZWFkVGltZW91dFwiLCB0eXBlYWhlYWRUaW1lb3V0KVxuICAgICAgICB9LFxuICAgICAgICB0b29sYmFyUGFyYW1ldGVyczogeyBvcmllbnRhdGlvbiB9LFxuICAgICAgICBtZW51YmFyUGFyYW1ldGVyczoge31cbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG5cbiAgICAvL2NvbnN0IHsgdXNlTWVudVNlbnRpbmVsUHJvcHM6IHVzZUZpcnN0U2VudGluZWxQcm9wcyB9ID0gdXNlTWVudVNlbnRpbmVsPFNlbnRpbmVsRWxlbWVudD4oKTtcbiAgICAvL2NvbnN0IHsgdXNlTWVudVNlbnRpbmVsUHJvcHM6IHVzZUxhc3RTZW50aW5lbFByb3BzIH0gPSB1c2VNZW51U2VudGluZWw8U2VudGluZWxFbGVtZW50PigpO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxQYXJlbnREZXB0aENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e215RGVwdGh9PlxuICAgICAgICAgICAgPE1lbnVJdGVtQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17aW5mby5jb250ZXh0fT5cbiAgICAgICAgICAgICAgICB7cmVuZGVyKGluZm8pfVxuICAgICAgICAgICAgPC9NZW51SXRlbUNvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgIDwvUGFyZW50RGVwdGhDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn0pXG5cbi8qXG5leHBvcnQgZnVuY3Rpb24gTWVudUl0ZW08TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe306IE1lbnVJdGVtUHJvcHMpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChNZW51SXRlbUNvbnRleHQpO1xuXG4gICAgY29uc3QgaW5mbyA9IHVzZU1lbnVJdGVtPE1lbnVJdGVtRWxlbWVudD4oe1xuICAgICAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBkaXNhYmxlZCwgaGlkZGVuLCBpbmRleCB9LFxuICAgICAgICBtZW51SXRlbVBhcmFtZXRlcnM6IHsgZGlzYWJsZWQsIG9uUHJlc3MsIHJvbGUgfSxcbiAgICAgICAgcHJlc3NQYXJhbWV0ZXJzOiB7IGV4Y2x1ZGUsIGZvY3VzU2VsZiB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IHsgYXJpYVByb3BOYW1lLCBzZWxlY3Rpb25Nb2RlIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHsgdGV4dCB9LFxuICAgIH0pXG59Ki9cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW9NZW51KCkge1xuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxNZW51PEhUTUxEaXZFbGVtZW50LCBIVE1MVUxpc3RFbGVtZW50LCBIVE1MTElFbGVtZW50LCBIVE1MTElFbGVtZW50LCBIVE1MQnV0dG9uRWxlbWVudD5cbiAgICAgICAgICAgIGNsb3NlT25CYWNrZHJvcD17dHJ1ZX1cbiAgICAgICAgICAgIGNsb3NlT25Fc2NhcGU9e3RydWV9XG4gICAgICAgICAgICBjbG9zZU9uTG9zdEZvY3VzPXt0cnVlfVxuICAgICAgICAgICAgY29sbGF0b3I9e251bGx9XG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzPXtmYWxzZX1cbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5cz17ZmFsc2V9XG4gICAgICAgICAgICBnZXRJbmRleD17diA9PiB2LnByb3BzLmluZGV4fVxuICAgICAgICAgICAgY29tcGFyZT17KGxocywgcmhzKSA9PiBsaHMuaW5kZXggLSByaHMuaW5kZXh9XG4gICAgICAgICAgICBpbml0aWFsbHlTZWxlY3RlZEluZGV4PXtudWxsfVxuICAgICAgICAgICAgdW50YWJiYWJsZT17ZmFsc2V9XG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RFbmQ9XCJ3cmFwXCJcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdFN0YXJ0PVwid3JhcFwiXG4gICAgICAgICAgICBub1R5cGVhaGVhZD17ZmFsc2V9XG4gICAgICAgICAgICBvcGVuPXtvcGVufVxuICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0T3BlbihmYWxzZSl9XG4gICAgICAgICAgICBvbk9wZW49eygpID0+IHNldE9wZW4odHJ1ZSl9XG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4PXtudWxsfVxuICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPXtudWxsfVxuICAgICAgICAgICAgb3BlbkRpcmVjdGlvbj1cImRvd25cIlxuICAgICAgICAgICAgb3JpZW50YXRpb249XCJ2ZXJ0aWNhbFwiXG4gICAgICAgICAgICBwYWdlTmF2aWdhdGlvblNpemU9ezAuMX1cbiAgICAgICAgICAgIHBhcmVudERlcHRoPXswfVxuICAgICAgICAgICAgdHlwZWFoZWFkVGltZW91dD17MTAwMH1cbiAgICAgICAgICAgIHJlbmRlcj17aW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gey4uLmluZm8ucHJvcHNUcmlnZ2VyfT5PcGVuIG1lbnU8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtkZWZhdWx0UmVuZGVyUG9ydGFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxJZDogXCJwb3J0YWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIHsuLi5pbmZvLnByb3BzVGFyZ2V0fT5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtb01lbnVJdGVtKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8TWVudUl0ZW08SFRNTExJRWxlbWVudD5cbiAgICAgICAgICAgIGV4Y2x1ZGU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGhpZGRlbj17ZmFsc2V9XG4gICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgb25QcmVzcz17bm9vcH1cbiAgICAgICAgICAgIGdldFNvcnRWYWx1ZT17cmV0dXJuTnVsbH1cbiAgICAgICAgICAgIHJlbmRlcj17aW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSB7Li4uaW5mby5wcm9wc30+TGlzdCBpdGVtIChpbmRleCAje2luZGV4fSk8L2xpPlxuICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgICAgIGFyaWFQcm9wTmFtZT1cImFyaWEtc2VsZWN0ZWRcIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZhbHNlfVxuXG4gICAgICAgIC8+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBub29wKCkgeyB9XG5cbi8qXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlck1lbnU8U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNlbnRpbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHBvcnRhbElkLCB0YWdCdXR0b24sIHRhZ01lbnUsIHRhZ1N1cmZhY2UsIHRhZ1NlbnRpbmVsLCBtYWtlUHJvcHNCdXR0b24sIG1ha2VQcm9wc01lbnUsIG1ha2VQcm9wc1N1cmZhY2UsIG1ha2VQcm9wc1NlbnRpbmVsIH06IHsgcG9ydGFsSWQ6IHN0cmluZywgdGFnU3VyZmFjZTogRWxlbWVudFRvVGFnPFN1cmZhY2VFbGVtZW50PiwgdGFnTWVudTogRWxlbWVudFRvVGFnPE1lbnVFbGVtZW50PiwgdGFnQnV0dG9uOiBFbGVtZW50VG9UYWc8QnV0dG9uRWxlbWVudD4sIHRhZ1NlbnRpbmVsOiBFbGVtZW50VG9UYWc8U2VudGluZWxFbGVtZW50PiwgbWFrZVByb3BzU3VyZmFjZTogKGluZm86IFVzZU1lbnVSZXR1cm5UeXBlPFN1cmZhY2VFbGVtZW50LCBNZW51RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBCdXR0b25FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8U3VyZmFjZUVsZW1lbnQ+LCBtYWtlUHJvcHNNZW51OiAoaW5mbzogVXNlTWVudVJldHVyblR5cGU8U3VyZmFjZUVsZW1lbnQsIE1lbnVFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51RWxlbWVudD4sIG1ha2VQcm9wc0J1dHRvbjogKGluZm86IFVzZU1lbnVSZXR1cm5UeXBlPFN1cmZhY2VFbGVtZW50LCBNZW51RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBCdXR0b25FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8QnV0dG9uRWxlbWVudD4sIG1ha2VQcm9wc1NlbnRpbmVsOiAoaW5mbzogVXNlTWVudVJldHVyblR5cGU8U3VyZmFjZUVsZW1lbnQsIE1lbnVFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxTZW50aW5lbEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lbnVJbmZvOiBVc2VNZW51UmV0dXJuVHlwZTxTdXJmYWNlRWxlbWVudCwgTWVudUVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4pIHtcblxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBzdXJmYWNlQ2hpbGRyZW4sIC4uLnN1cmZhY2VQcm9wcyB9ID0gKG1ha2VQcm9wc1N1cmZhY2UobWVudUluZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogbWVudUNoaWxkcmVuLCAuLi5tZW51UHJvcHMgfSA9IChtYWtlUHJvcHNNZW51KG1lbnVJbmZvKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ0J1dHRvbiBhcyBuZXZlciwgKG1ha2VQcm9wc0J1dHRvbihtZW51SW5mbykpKX1cbiAgICAgICAgICAgICAgICB7ZGVmYXVsdFJlbmRlclBvcnRhbCh7XG4gICAgICAgICAgICAgICAgICAgIHBvcnRhbElkLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogY3JlYXRlRWxlbWVudCh0YWdTdXJmYWNlIGFzIG5ldmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdXJmYWNlUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogKDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnU2VudGluZWwgYXMgbmV2ZXIsIChtYWtlUHJvcHNTZW50aW5lbChtZW51SW5mbykpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3VyZmFjZUNoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ01lbnUgYXMgbmV2ZXIsIHsgLi4ubWVudVByb3BzLCBjaGlsZHJlbjogPD57bWVudUNoaWxkcmVufTwvPiB9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdTZW50aW5lbCBhcyBuZXZlciwgKG1ha2VQcm9wc1NlbnRpbmVsKG1lbnVJbmZvKSkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC8+KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcblxuICAgIH1cbn0qL1xuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEZvY3VzYWJsZUxhYmVsRWxlbWVudCwgTGFiZWxQb3NpdGlvbiB9IGZyb20gXCJ1c2UtbGFiZWxcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZyB9IGZyb20gXCIuLi9wcm9wc1wiO1xuaW1wb3J0IHsgUmFkaW9Db250ZXh0LCBSYWRpb1N1YkluZm8sIHVzZVJhZGlvLCB1c2VSYWRpb0dyb3VwLCBVc2VSYWRpb0dyb3VwUGFyYW1ldGVycywgVXNlUmFkaW9Hcm91cFJldHVyblR5cGUsIFVzZVJhZGlvUGFyYW1ldGVycywgVXNlUmFkaW9SZXR1cm5UeXBlIH0gZnJvbSBcIi4uL3VzZS1yYWRpby1ncm91cFwiO1xuaW1wb3J0IHsgRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9jaGVja2JveFwiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcnRpYWxFeGNlcHQsIHVzZURlZmF1bHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmludGVyZmFjZSBSYWRpb0dyb3VwUHJvcHNCYXNlPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50PiwgXCJyYWRpb0dyb3VwUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQ+LCBcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudD4sIFwibGFiZWxQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudD4sIFwicmFkaW9Hcm91cFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50PiwgXCJyZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudD4sIFwic29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50PiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZVJhZGlvR3JvdXBSZXR1cm5UeXBlPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50Pj47XG59XG5cbmludGVyZmFjZSBSYWRpb1Byb3BzQmFzZTxMUCBleHRlbmRzIExhYmVsUG9zaXRpb24sIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+IGV4dGVuZHNcbiAgICBHZXQ8VXNlUmFkaW9QYXJhbWV0ZXJzPExQLCBWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgUmFkaW9TdWJJbmZvPEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBWPj4sIFwicmFkaW9QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8TFAsIFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBSYWRpb1N1YkluZm88Rm9jdXNhYmxlTGFiZWxFbGVtZW50PExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFY+PiwgXCJjaGVja2JveExpa2VQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8TFAsIFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBSYWRpb1N1YkluZm88Rm9jdXNhYmxlTGFiZWxFbGVtZW50PExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFY+PiwgXCJsYWJlbFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVJhZGlvUGFyYW1ldGVyczxMUCwgViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJhZGlvU3ViSW5mbzxGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgVj4+LCBcInJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8TFAsIFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBSYWRpb1N1YkluZm88Rm9jdXNhYmxlTGFiZWxFbGVtZW50PExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFY+PiwgXCJwcmVzc1BhcmFtZXRlcnNcIj4sXG4gICAgT21pdDxHZXQ8VXNlUmFkaW9QYXJhbWV0ZXJzPExQLCBWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgUmFkaW9TdWJJbmZvPEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBWPj4sIFwic2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzXCI+LCBcImRpc2FibGVkXCI+LFxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8TFAsIFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBSYWRpb1N1YkluZm88Rm9jdXNhYmxlTGFiZWxFbGVtZW50PExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFY+PiwgXCJ0ZXh0Q29udGVudFBhcmFtZXRlcnNcIj4sXG4gICAgT21pdDxHZXQ8VXNlUmFkaW9QYXJhbWV0ZXJzPExQLCBWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgUmFkaW9TdWJJbmZvPEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBWPj4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPiwgXCJkaXNhYmxlZFwiIHwgXCJnZXRTb3J0VmFsdWVcIj4ge1xuICAgIC8vcmVmPzogUmVmPFVzZVJhZGlvUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+PjtcbiAgICAvL3N1YkluZm86IEM7XG5cbn1cblxuaW50ZXJmYWNlIFJhZGlvR3JvdXBQcm9wczxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHcm91cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PFJhZGlvR3JvdXBQcm9wc0Jhc2U8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQ+LCBcIm5hdmlnYXRpb25EaXJlY3Rpb25cIiB8IFwiYXJpYUxhYmVsXCIgfCBcIm5hbWVcIiB8IFwic2VsZWN0ZWRWYWx1ZVwiIHwgXCJzZXRTZWxlY3RlZFZhbHVlXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlUmFkaW9Hcm91cFJldHVyblR5cGU8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cbmludGVyZmFjZSBSYWRpb1Byb3BzPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgViBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PFJhZGlvUHJvcHNCYXNlPExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgVj4sIFwiaW5kZXhcIiB8IFwidmFsdWVcIiB8IFwiYXJpYUxhYmVsXCIgfCBcImxhYmVsUG9zaXRpb25cIiB8IFwidGFnSW5wdXRcIiB8IFwidGFnTGFiZWxcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VSYWRpb1JldHVyblR5cGU8TFAsIFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBSYWRpb1N1YkluZm88Rm9jdXNhYmxlTGFiZWxFbGVtZW50PExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFY+Pik6IFZOb2RlPGFueT47XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJSYWRpb0dyb3VwPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ0dyb3VwLCB0YWdMYWJlbCwgbWFrZVByb3BzR3JvdXAsIG1ha2VQcm9wc0xhYmVsIH06IHsgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxHcm91cExhYmVsRWxlbWVudD4sIHRhZ0dyb3VwOiBFbGVtZW50VG9UYWc8R3JvdXBFbGVtZW50PiwgbWFrZVByb3BzTGFiZWw6IChpbmZvOiBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZTxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyb3VwTGFiZWxFbGVtZW50PiwgbWFrZVByb3BzR3JvdXA6IChpbmZvOiBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZTxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyb3VwRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlUmFkaW9Hcm91cFJldHVyblR5cGU8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ0xhYmVsIGFzIG5ldmVyLCAobWFrZVByb3BzTGFiZWwoaW5mbykpKX1cbiAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdHcm91cCBhcyBuZXZlciwgKG1ha2VQcm9wc0dyb3VwKGluZm8pKSl9XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgKVxuICAgIH1cbn1cblxuY29uc3QgUmFkaW9Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxSYWRpb0NvbnRleHQ8YW55LCBhbnksIGFueSwgYW55Pj4obnVsbCEpO1xuZXhwb3J0IGNvbnN0IFJhZGlvR3JvdXAgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBSYWRpb0dyb3VwPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7XG4gICAgcmVuZGVyLFxuICAgIG5hbWUsXG4gICAgc2V0U2VsZWN0ZWRWYWx1ZSxcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgYXJpYUxhYmVsLFxuICAgIGNvbXBhcmUsXG4gICAgZ2V0SW5kZXgsXG4gICAgbmF2aWdhdGVQYXN0RW5kLFxuICAgIG5hdmlnYXRlUGFzdFN0YXJ0LFxuICAgIHNlbGVjdGVkVmFsdWUsXG4gICAgdW50YWJiYWJsZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgcGFnZU5hdmlnYXRpb25TaXplLFxufTogUmFkaW9Hcm91cFByb3BzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50PiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBpbmZvID0gdXNlUmFkaW9Hcm91cDxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZDogbmF2aWdhdGVQYXN0RW5kID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IG5hdmlnYXRlUGFzdFN0YXJ0ID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5czogdXNlRGVmYXVsdChcImRpc2FibGVBcnJvd0tleXNcIiwgZGlzYWJsZUFycm93S2V5cyksXG4gICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlSG9tZUVuZEtleXNcIiwgZGlzYWJsZUhvbWVFbmRLZXlzKSxcbiAgICAgICAgICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZTogdXNlRGVmYXVsdChcInBhZ2VOYXZpZ2F0aW9uU2l6ZVwiLCBwYWdlTmF2aWdhdGlvblNpemUpXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczogeyBhcmlhTGFiZWwgfSxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBnZXRJbmRleDogdXNlRGVmYXVsdChcImdldEluZGV4XCIsIGdldEluZGV4KSB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBjb21wYXJlOiBjb21wYXJlID8/IG51bGwgfSxcbiAgICAgICAgcmFkaW9Hcm91cFBhcmFtZXRlcnM6IHsgbmFtZSwgc2V0U2VsZWN0ZWRWYWx1ZSwgc2VsZWN0ZWRWYWx1ZSB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZTogb25UYWJiYWJsZUluZGV4Q2hhbmdlID8/IG51bGwsXG4gICAgICAgICAgICB1bnRhYmJhYmxlOiB1bnRhYmJhYmxlID8/IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBjb2xsYXRvcjogdXNlRGVmYXVsdChcImNvbGxhdG9yXCIsIGNvbGxhdG9yKSxcbiAgICAgICAgICAgIG5vVHlwZWFoZWFkOiB1c2VEZWZhdWx0KFwibm9UeXBlYWhlYWRcIiwgbm9UeXBlYWhlYWQpLFxuICAgICAgICAgICAgdHlwZWFoZWFkVGltZW91dDogdXNlRGVmYXVsdChcInR5cGVhaGVhZFRpbWVvdXRcIiwgdHlwZWFoZWFkVGltZW91dClcbiAgICAgICAgfSxcbiAgICAgICAgLy8gY2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzOiB7ICB9LFxuICAgICAgICAvLyAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogeyAgfVxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxSYWRpb0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2luZm8uY29udGV4dH0+XG4gICAgICAgICAgICB7cmVuZGVyKGluZm8pfVxuICAgICAgICA8L1JhZGlvQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59KVxuXG4vKmV4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdFJlbmRlclJhZGlvUGFyYW1ldGVyczxMUCBleHRlbmRzIExhYmVsUG9zaXRpb24sIFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEkgZXh0ZW5kcyBFbGVtZW50LCBJTCBleHRlbmRzIEVsZW1lbnQsIFRDRSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgSUwsIFVzZVJhZGlvUmV0dXJuVHlwZTxMUCwgViwgSSwgSUwsIFRDRSwgUmFkaW9TdWJJbmZvPFRDRSwgVj4+PiB7XG5cbn0qL1xuLypcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyUmFkaW88ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSSBleHRlbmRzIEhUTUxFbGVtZW50LCBJTCBleHRlbmRzIEhUTUxFbGVtZW50LCBUQ0UgZXh0ZW5kcyBJIHwgSUw+KHsgdGFnSW5wdXQsIHRhZ0xhYmVsLCBtYWtlUHJvcHNJbnB1dCwgbWFrZVByb3BzTGFiZWwsIGxhYmVsUG9zaXRpb24gfTogRGVmYXVsdFJlbmRlclJhZGlvUGFyYW1ldGVyczxWLCBJLCBJTCwgVENFPikge1xuICAgIHJldHVybiBkZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlPEksIElMLCBVc2VSYWRpb1JldHVyblR5cGU8ViwgSSwgSUwsIFRDRSwgUmFkaW9TdWJJbmZvPFRDRSwgVj4+Pih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZVByb3BzSW5wdXQsIG1ha2VQcm9wc0xhYmVsIH0pO1xufVxuKi9cblxuZXhwb3J0IGNvbnN0IFJhZGlvID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gUmFkaW88TFAgZXh0ZW5kcyBMYWJlbFBvc2l0aW9uLCBWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgZGlzYWJsZWQsXG4gICAgaW5kZXgsXG4gICAgcmVuZGVyLFxuICAgIHZhbHVlLFxuICAgIGFyaWFMYWJlbCxcbiAgICBleGNsdWRlLFxuICAgIGZvY3VzU2VsZixcbiAgICBsYWJlbFBvc2l0aW9uLFxuICAgIG9uUHJlc3NTeW5jLFxuICAgIGhpZGRlbixcbiAgICB0YWdJbnB1dCxcbiAgICB0YWdMYWJlbCxcbiAgICBnZXRUZXh0XG59OiBSYWRpb1Byb3BzPExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgVj4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoUmFkaW9Db250ZXh0KTtcbiAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZVN0YWJsZUdldHRlcih2YWx1ZSk7XG4gICAgY29uc3QgZGVmYXVsdEZvY3VzU2VsZiA9ICgpID0+IGluZm8uY2hlY2tib3hMaWtlUmV0dXJuLmZvY3VzU2VsZigpO1xuICAgIGNvbnN0IGluZm8gPSB1c2VSYWRpbzxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFY+KHtcbiAgICAgICAgLy9saXN0TmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgdGV4dCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiB7IGdldFNvcnRWYWx1ZTogZ2V0VmFsdWUgfSxcbiAgICAgICAgcmFkaW9QYXJhbWV0ZXJzOiB7IHZhbHVlIH0sXG4gICAgICAgIGNoZWNrYm94TGlrZVBhcmFtZXRlcnM6IHsgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlIH0sXG4gICAgICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHsgZ2V0VmFsdWUgfSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbGFiZWxQYXJhbWV0ZXJzOiB7IGFyaWFMYWJlbCwgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsIH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczogeyBleGNsdWRlLCBmb2N1c1NlbGY6IGZvY3VzU2VsZiA/PyBkZWZhdWx0Rm9jdXNTZWxmLCBvblByZXNzU3luYyB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IHsgZGlzYWJsZWQ6ICEhZGlzYWJsZWQgfSxcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzOiB7IGdldFRleHQ6IHVzZURlZmF1bHQoXCJnZXRUZXh0XCIsIGdldFRleHQpIH1cbiAgICAgICAgLy9yb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHsgaGlkZGVuLCBmb2N1c1NlbGYsIG5vTW9kaWZ5VGFiSW5kZXggfSxcbiAgICAgICAgLy9oYXNGb2N1c1BhcmFtZXRlcnM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH0sXG4gICAgICAgIC8vc3ViSW5mb1BhcmFtZXRlcnM6IHsgIH0sXG4gICAgICAgIC8vc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogeyB1bnNlbGVjdGFibGUsIGZvY3VzU2VsZiB9XG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pO1xuXG4gICAgLy8gICAgY29uc3QgeyB1c2VSYWRpb0lucHV0UHJvcHMgfSA9IHVzZVJhZGlvSW5wdXQoeyB0YWc6IHRhZ0lucHV0IH0pO1xuICAgIC8vICAgIGNvbnN0IHsgdXNlUmFkaW9MYWJlbFByb3BzIH0gPSB1c2VSYWRpb0xhYmVsKHsgdGFnOiB0YWdMYWJlbCB9KTtcblxuICAgIHJldHVybiByZW5kZXIoaW5mbyk7XG59KVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtb1JhZGlvR3JvdXAoeyBuYW1lIH06IHsgbmFtZTogc3RyaW5nIH0pIHtcbiAgICBjb25zdCBbc2VsZWN0ZWRWYWx1ZSwgc2V0U2VsZWN0ZWRWYWx1ZV0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKVxuICAgIHJldHVybiAoXG4gICAgICAgIDxSYWRpb0dyb3VwPHN0cmluZywgSFRNTERpdkVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQsIEhUTUxJbnB1dEVsZW1lbnQ+XG5cbiAgICAgICAgICAgIGFyaWFMYWJlbD17bnVsbH1cbiAgICAgICAgICAgIGNvbGxhdG9yPXtudWxsfVxuICAgICAgICAgICAgY29tcGFyZT17KChsaHMsIHJocykgPT4gbGhzLmluZGV4IC0gcmhzLmluZGV4KX1cbiAgICAgICAgICAgIGdldEluZGV4PXt2ID0+IHYucHJvcHMuaW5kZXh9XG4gICAgICAgICAgICBuYW1lPXtuYW1lfVxuICAgICAgICAgICAgbm9UeXBlYWhlYWQ9e2ZhbHNlfVxuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5cz17ZmFsc2V9XG4gICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXM9e2ZhbHNlfVxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kPVwid3JhcFwiXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydD1cIndyYXBcIlxuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZT1cImFcIlxuICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbj1cInZlcnRpY2FsXCJcbiAgICAgICAgICAgIHNldFNlbGVjdGVkVmFsdWU9e2UgPT4gc2V0U2VsZWN0ZWRWYWx1ZShlKX1cbiAgICAgICAgICAgIHJlbmRlcj17aW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIHsuLi5pbmZvLnByb3BzUmFkaW9Hcm91cExhYmVsfT5SYWRpbyBncm91cDwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB7Li4uaW5mby5wcm9wc1JhZGlvR3JvdXB9PlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfX1cblxuXG4gICAgICAgIC8+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwiLi4vcHJvcHNcIjtcbmltcG9ydCB7IFNsaWRlckNvbnRleHQsIFNsaWRlclRodW1iSW5mbywgdXNlU2xpZGVyLCBVc2VTbGlkZXJQYXJhbWV0ZXJzLCBVc2VTbGlkZXJSZXR1cm5UeXBlLCB1c2VTbGlkZXJUaHVtYiwgVXNlU2xpZGVyVGh1bWIsIFVzZVNsaWRlclRodW1iUGFyYW1ldGVycywgVXNlU2xpZGVyVGh1bWJSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL3VzZS1zbGlkZXJcIjtcbmltcG9ydCB7IG1lbW9Gb3J3YXJkUmVmIH0gZnJvbSBcIi4vdXRpbFwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclByb3BzIGV4dGVuZHMgR2V0PFVzZVNsaWRlclBhcmFtZXRlcnM8U2xpZGVyVGh1bWJJbmZvPiwgXCJtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzXCI+LCBHZXQ8VXNlU2xpZGVyUGFyYW1ldGVyczxTbGlkZXJUaHVtYkluZm8+LCBcInNsaWRlclBhcmFtZXRlcnNcIj4ge1xuICAgIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbjtcbiAgICByZWY/OiBSZWY8VXNlU2xpZGVyUmV0dXJuVHlwZTxTbGlkZXJUaHVtYkluZm8+Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJUaHVtYlByb3BzPFRodW1iRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgR2V0PFVzZVNsaWRlclRodW1iUGFyYW1ldGVyczxUaHVtYkVsZW1lbnQsIFNsaWRlclRodW1iSW5mbz4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPiwgR2V0PFVzZVNsaWRlclRodW1iUGFyYW1ldGVyczxUaHVtYkVsZW1lbnQsIFNsaWRlclRodW1iSW5mbz4sIFwic2xpZGVyVGh1bWJQYXJhbWV0ZXJzXCI+IHtcbiAgICAvL3N1YkluZm86IEdldDxVc2VTbGlkZXJUaHVtYlBhcmFtZXRlcnM8VGh1bWJFbGVtZW50LCBTbGlkZXJUaHVtYkluZm8+LCBcInN1YkluZm9cIj47XG4gICAgLy9yZWY/OiBSZWY8VXNlU2xpZGVyVGh1bWJSZXR1cm5UeXBlPFRodW1iRWxlbWVudCwgU2xpZGVyVGh1bWJJbmZvPj47XG4gICAgcmVuZGVyKGluZm86IFVzZVNsaWRlclRodW1iUmV0dXJuVHlwZTxUaHVtYkVsZW1lbnQsIFNsaWRlclRodW1iSW5mbz4pOiBWTm9kZTtcbn1cblxuY29uc3QgU2xpZGVyVGh1bWJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxTbGlkZXJDb250ZXh0PGFueT4+KG51bGwhKTtcblxuZXhwb3J0IGNvbnN0IFNsaWRlciA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIFNsaWRlcjxTbGlkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYXgsIG1pbiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIGNoaWxkcmVuIH06IFNsaWRlclByb3BzLCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGluZm8gPSB1c2VTbGlkZXIoe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXG4gICAgICAgIHNsaWRlclBhcmFtZXRlcnM6IHsgbWF4LCBtaW4gfVxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxTbGlkZXJUaHVtYkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2luZm8uY29udGV4dH0+e2NoaWxkcmVufTwvU2xpZGVyVGh1bWJDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG59KVxuXG5leHBvcnQgY29uc3QgU2xpZGVyVGh1bWIgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBTbGlkZXJUaHVtYlU8VGh1bWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBsYWJlbCwgdGFnLCB2YWx1ZSwgbWF4LCBtaW4sIG9uVmFsdWVDaGFuZ2UsIGluZGV4LCByZW5kZXIsIHZhbHVlVGV4dCB9OiBTbGlkZXJUaHVtYlByb3BzPFRodW1iRWxlbWVudD4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgY29udGV4dCA9ICh1c2VDb250ZXh0KFNsaWRlclRodW1iQ29udGV4dCkgYXMgU2xpZGVyQ29udGV4dDxTbGlkZXJUaHVtYkluZm8+KVxuICAgIFxuICAgIGNvbnN0IGluZm8gPSB1c2VTbGlkZXJUaHVtYih7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfSxcbiAgICAgICAgc2xpZGVyVGh1bWJQYXJhbWV0ZXJzOiB7IGxhYmVsLCB0YWcsIHZhbHVlLCBtYXgsIG1pbiwgb25WYWx1ZUNoYW5nZSwgdmFsdWVUZXh0IH0sXG4gICAgICAgIC8vc3ViSW5mb1xuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiByZW5kZXIoaW5mbyk7XG59KVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyU2xpZGVyVGh1bWI8RSBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnVGh1bWIsIG1ha2VQcm9wc1RodW1iIH06IHsgdGFnVGh1bWI6IEVsZW1lbnRUb1RhZzxFPiwgbWFrZVByb3BzVGh1bWI6IChpbmZvOiBVc2VTbGlkZXJUaHVtYlJldHVyblR5cGU8RSwgU2xpZGVyVGh1bWJJbmZvPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlU2xpZGVyVGh1bWJSZXR1cm5UeXBlPEUsIFNsaWRlclRodW1iSW5mbz4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGh1bWIgYXMgbmV2ZXIsIChtYWtlUHJvcHNUaHVtYihpbmZvKSkpXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCIuLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlVGFibGUsIFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnMsIFVzZVRhYmxlUm93UGFyYW1ldGVycywgVXNlVGFibGVTZWN0aW9uQ29udGV4dCwgdXNlVGFibGVDZWxsLCB1c2VUYWJsZVJvdywgdXNlVGFibGVTZWN0aW9uLCBVc2VUYWJsZVNlY3Rpb25QYXJhbWV0ZXJzLCBVc2VUYWJsZVBhcmFtZXRlcnMsIFRhYmxlUm93SW5mbywgVXNlVGFibGVSb3dSZXR1cm5UeXBlLCBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlLCBVc2VUYWJsZVNlY3Rpb25SZXR1cm5UeXBlLCBVc2VUYWJsZVJldHVyblR5cGUsIFRhYmxlQ2VsbEluZm8sIFVzZVRhYmxlUm93Q29udGV4dCwgVXNlVGFibGVDb250ZXh0IH0gZnJvbSBcIi4uL3VzZS10YWJsZVwiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcnRpYWxFeGNlcHQsIHVzZURlZmF1bHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcblxuaW50ZXJmYWNlIFRhYmxlUHJvcHNCYXNlPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlVGFibGVQYXJhbWV0ZXJzPFRhYmxlRWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJsYWJlbFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYmxlUGFyYW1ldGVyczxUYWJsZUVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwidGFibGVQYXJhbWV0ZXJzXCI+IHtcbiAgICByZWY/OiBSZWY8VXNlVGFibGVSZXR1cm5UeXBlPFRhYmxlRWxlbWVudCwgTGFiZWxFbGVtZW50Pj47XG59XG5cbmludGVyZmFjZSBUYWJsZVNlY3Rpb25Qcm9wc0Jhc2U8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIFRhYmxlUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxDZWxsRWxlbWVudD4+IGV4dGVuZHNcbiAgICBHZXQ8VXNlVGFibGVTZWN0aW9uUGFyYW1ldGVyczxTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPiwgXCJncmlkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYmxlU2VjdGlvblBhcmFtZXRlcnM8U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTT4sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYmxlU2VjdGlvblBhcmFtZXRlcnM8U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTT4sIFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFibGVTZWN0aW9uUGFyYW1ldGVyczxTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPiwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYmxlU2VjdGlvblBhcmFtZXRlcnM8U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTT4sIFwic2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFibGVTZWN0aW9uUGFyYW1ldGVyczxTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPiwgXCJ0YWJsZVNlY3Rpb25QYXJhbWV0ZXJzXCI+IHtcbiAgICByZWY/OiBSZWY8VXNlVGFibGVTZWN0aW9uUmV0dXJuVHlwZTxTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4+O1xufVxuXG5pbnRlcmZhY2UgVGFibGVSb3dQcm9wc0Jhc2U8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBUYWJsZVJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzXG4gICAgT21pdDxHZXQ8VXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+LCBcInRhYmxlUm93UGFyYW1ldGVyc1wiPiwgXCJsb2NhdGlvblwiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJyb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyc1wiLCBcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJyb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyc1wiLCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0MjxVc2VUYWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwicm93QXNDaGlsZE9mR3JpZFBhcmFtZXRlcnNcIiwgXCJyb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJyb3dBc0NoaWxkT2ZHcmlkUGFyYW1ldGVyc1wiLCBcInRleHRDb250ZW50UGFyYW1ldGVyc1wiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJyb3dBc1BhcmVudE9mQ2VsbHNQYXJhbWV0ZXJzXCIsIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0MjxVc2VUYWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwicm93QXNQYXJlbnRPZkNlbGxzUGFyYW1ldGVyc1wiLCBcInJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZVRhYmxlUm93UmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPj47XG59XG5cbmludGVyZmFjZSBUYWJsZUNlbGxQcm9wc0Jhc2U8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzXG4gICAgR2V0PFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIENNPiwgXCJ0YWJsZUNlbGxQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUYWJsZUNlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50LCBDTT4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgQ00+LCBcImdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIENNPiwgXCJyb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgQ00+LCBcInByZXNzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgQ00+LCBcInRleHRDb250ZW50UGFyYW1ldGVyc1wiPiB7XG4gICAgZ2V0U29ydFZhbHVlOiBDTVtcImdldFNvcnRWYWx1ZVwiXTtcbiAgICByZWY/OiBSZWY8VXNlVGFibGVDZWxsUmV0dXJuVHlwZTxDZWxsRWxlbWVudCwgQ00+Pjtcbn1cblxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlUHJvcHM8VGFibGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PFRhYmxlUHJvcHNCYXNlPFRhYmxlRWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJ0YWdUYWJsZVwiIHwgXCJzZWxlY3Rpb25MaW1pdFwiIHwgXCJhcmlhTGFiZWxcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VUYWJsZVJldHVyblR5cGU8VGFibGVFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KTogVk5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVTZWN0aW9uUHJvcHM8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIFRhYmxlUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxDZWxsRWxlbWVudD4+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxUYWJsZVNlY3Rpb25Qcm9wc0Jhc2U8U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+LCBcInRhZ1RhYmxlU2VjdGlvblwiIHwgXCJsb2NhdGlvblwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZVRhYmxlU2VjdGlvblJldHVyblR5cGU8U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+KTogVk5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVSb3dQcm9wczxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIFRhYmxlUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxDZWxsRWxlbWVudD4+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxUYWJsZVJvd1Byb3BzQmFzZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJpbmRleFwiIHwgXCJ0YWdUYWJsZVJvd1wiIHwgXCJhcmlhUHJvcE5hbWVcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VUYWJsZVJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4pOiBWTm9kZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUNlbGxQcm9wczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxDZWxsRWxlbWVudD4+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxUYWJsZUNlbGxQcm9wc0Jhc2U8Q2VsbEVsZW1lbnQsIENNPiwgXCJ0YWdUYWJsZUNlbGxcIiB8IFwiaW5kZXhcIiB8IFwiZ2V0U29ydFZhbHVlXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlVGFibGVDZWxsUmV0dXJuVHlwZTxDZWxsRWxlbWVudCwgQ00+KTogVk5vZGU7XG59XG5cbi8vY29uc3QgTG9jYXRpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxcImhlYWRcIiB8IFwiYm9keVwiIHwgXCJmb290XCI+KG51bGwhKTtcblxuY29uc3QgVGFibGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWJsZUNvbnRleHQ+KG51bGwhKTtcbmNvbnN0IFRhYmxlU2VjdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRhYmxlU2VjdGlvbkNvbnRleHQ8YW55LCBhbnksIGFueSwgVGFibGVSb3dJbmZvPGFueSwgYW55PiwgVGFibGVDZWxsSW5mbzxhbnk+Pj4obnVsbCEpO1xuY29uc3QgVGFibGVSb3dDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWJsZVJvd0NvbnRleHQ8YW55LCBhbnksIFRhYmxlQ2VsbEluZm88YW55Pj4+KG51bGwhKTtcbi8vY29uc3QgVGFibGVSb3dDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWJsZVJvdzxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55Pj4obnVsbCEpO1xuLy9jb25zdCBUYWJsZUNlbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWJsZUNlbGw8YW55LCBhbnksIGFueT4+KG51bGwhKTtcblxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnVGFibGUsIG1ha2VQcm9wc1RhYmxlIH06IHsgdGFnVGFibGU6IEVsZW1lbnRUb1RhZzxUYWJsZUVsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZTogKGluZm86IFVzZVRhYmxlUmV0dXJuVHlwZTxUYWJsZUVsZW1lbnQsIExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlVGFibGVSZXR1cm5UeXBlPFRhYmxlRWxlbWVudCwgTGFiZWxFbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJsZSBhcyBuZXZlciwgKG1ha2VQcm9wc1RhYmxlKGluZm8pKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGVTZWN0aW9uPFRhYmxlQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIFRhYmxlUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxDZWxsRWxlbWVudD4+KHsgdGFnVGFibGVCb2R5LCBtYWtlUHJvcHNUYWJsZUJvZHkgfTogeyB0YWdUYWJsZUJvZHk6IEVsZW1lbnRUb1RhZzxUYWJsZUJvZHlFbGVtZW50PiwgbWFrZVByb3BzVGFibGVCb2R5OiAoaW5mbzogVXNlVGFibGVTZWN0aW9uUmV0dXJuVHlwZTxUYWJsZUJvZHlFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVCb2R5RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlVGFibGVTZWN0aW9uUmV0dXJuVHlwZTxUYWJsZUJvZHlFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiwgbW9kaWZ5UHJvcHNUYWJsZUJvZHk6IFByb3BNb2RpZmllcjxUYWJsZUJvZHlFbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJsZUJvZHkgYXMgbmV2ZXIsIG1vZGlmeVByb3BzVGFibGVCb2R5KG1ha2VQcm9wc1RhYmxlQm9keShpbmZvKSkpO1xuICAgIH1cbn1cbi8qXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlSGVhZDxUYWJsZUhlYWRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUYWJsZUhlYWQsIG1ha2VQcm9wc1RhYmxlSGVhZCB9OiB7IHRhZ1RhYmxlSGVhZDogRWxlbWVudFRvVGFnPFRhYmxlSGVhZEVsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZUhlYWQ6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlSGVhZEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZGlmeVByb3BzVGFibGVIZWFkOiBQcm9wTW9kaWZpZXI8VGFibGVIZWFkRWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFibGVIZWFkIGFzIG5ldmVyLCBtb2RpZnlQcm9wc1RhYmxlSGVhZChtYWtlUHJvcHNUYWJsZUhlYWQoKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZUZvb3Q8VGFibGVGb290RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnVGFibGVGb290LCBtYWtlUHJvcHNUYWJsZUZvb3QgfTogeyB0YWdUYWJsZUZvb3Q6IEVsZW1lbnRUb1RhZzxUYWJsZUZvb3RFbGVtZW50PiwgbWFrZVByb3BzVGFibGVGb290OiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUZvb3RFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RpZnlQcm9wc1RhYmxlRm9vdDogUHJvcE1vZGlmaWVyPFRhYmxlRm9vdEVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlRm9vdCBhcyBuZXZlciwgbW9kaWZ5UHJvcHNUYWJsZUZvb3QobWFrZVByb3BzVGFibGVGb290KCkpKTtcbiAgICB9XG59Ki9cblxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlUm93PFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgVGFibGVSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBUYWJsZUNlbGxJbmZvPENlbGxFbGVtZW50Pj4oeyB0YWdUYWJsZVJvdywgbWFrZVByb3BzVGFibGVSb3cgfTogeyB0YWdUYWJsZVJvdzogRWxlbWVudFRvVGFnPFJvd0VsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZVJvdzogKGluZm86IFVzZVRhYmxlUm93UmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlVGFibGVSb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+LCBtb2RpZnlQcm9wc1RhYmxlUm93OiBQcm9wTW9kaWZpZXI8Um93RWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFibGVSb3cgYXMgbmV2ZXIsIG1vZGlmeVByb3BzVGFibGVSb3cobWFrZVByb3BzVGFibGVSb3coaW5mbykpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZUNlbGw8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pih7IHRhZ1RhYmxlQ2VsbCwgbWFrZVByb3BzVGFibGVDZWxsIH06IHsgdGFnVGFibGVDZWxsOiBFbGVtZW50VG9UYWc8Q2VsbEVsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZUNlbGw6IChpbmZvOiBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50LCBDTT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGxFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50LCBDTT4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFibGVDZWxsIGFzIG5ldmVyLCAobWFrZVByb3BzVGFibGVDZWxsKGluZm8pKSk7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgVGFibGUgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBUYWJsZVU8VGFibGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGFyaWFMYWJlbCxcbiAgICBzZWxlY3Rpb25MaW1pdCxcbiAgICB0YWdUYWJsZSxcbiAgICByZW5kZXJcbn06IFRhYmxlUHJvcHM8VGFibGVFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGluZm8gPSB1c2VUYWJsZTxUYWJsZUVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHsgYXJpYUxhYmVsIH0sXG4gICAgICAgIHRhYmxlUGFyYW1ldGVyczogeyBzZWxlY3Rpb25MaW1pdCwgdGFnVGFibGUgfVxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiA8VGFibGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PntyZW5kZXIoaW5mbyl9PC9UYWJsZUNvbnRleHQuUHJvdmlkZXI+XG59KVxuXG5leHBvcnQgY29uc3QgVGFibGVTZWN0aW9uID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gVGFibGVTZWN0aW9uPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIGdldEluZGV4LFxuICAgIGluaXRpYWxseVNlbGVjdGVkSW5kZXgsXG4gICAgdW50YWJiYWJsZSxcbiAgICBuYXZpZ2F0ZVBhc3RFbmQsXG4gICAgbmF2aWdhdGVQYXN0U3RhcnQsXG4gICAgc2V0U2VsZWN0ZWRJbmRleCxcbiAgICBvblRhYmJhYmxlQ29sdW1uQ2hhbmdlLFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBwYWdlTmF2aWdhdGlvblNpemUsXG4gICAgcmVuZGVyLFxuICAgIGxvY2F0aW9uLFxuICAgIHRhZ1RhYmxlU2VjdGlvblxufTogVGFibGVTZWN0aW9uUHJvcHM8U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBUYWJsZVJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBUYWJsZUNlbGxJbmZvPENlbGxFbGVtZW50Pj4pIHtcbiAgICBjb25zdCBpbmZvID0gdXNlVGFibGVTZWN0aW9uPFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgVGFibGVSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgVGFibGVDZWxsSW5mbzxDZWxsRWxlbWVudD4+KHtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IG9uVGFiYmFibGVDb2x1bW5DaGFuZ2U6IG9uVGFiYmFibGVDb2x1bW5DaGFuZ2UgPz8gbnVsbCB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5czogdXNlRGVmYXVsdChcImRpc2FibGVBcnJvd0tleXNcIiwgZGlzYWJsZUFycm93S2V5cyksXG4gICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlSG9tZUVuZEtleXNcIiwgZGlzYWJsZUhvbWVFbmRLZXlzKSxcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZDogbmF2aWdhdGVQYXN0RW5kID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IG5hdmlnYXRlUGFzdFN0YXJ0ID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplOiB1c2VEZWZhdWx0KFwicGFnZU5hdmlnYXRpb25TaXplXCIsIHBhZ2VOYXZpZ2F0aW9uU2l6ZSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBnZXRJbmRleDogdXNlRGVmYXVsdChcImdldEluZGV4XCIsIGdldEluZGV4KSB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHsgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiBvblRhYmJhYmxlSW5kZXhDaGFuZ2UgPz8gbnVsbCwgdW50YWJiYWJsZTogdW50YWJiYWJsZSA/PyBmYWxzZSB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzOiB7IGluaXRpYWxseVNlbGVjdGVkSW5kZXg6IGluaXRpYWxseVNlbGVjdGVkSW5kZXggPz8gbnVsbCwgc2V0U2VsZWN0ZWRJbmRleDogc2V0U2VsZWN0ZWRJbmRleCA/PyBudWxsIH0sXG4gICAgICAgIGNvbnRleHQ6IHVzZUNvbnRleHQoVGFibGVDb250ZXh0KSxcbiAgICAgICAgdGFibGVTZWN0aW9uUGFyYW1ldGVyczogeyB0YWdUYWJsZVNlY3Rpb24sIGxvY2F0aW9uIH0sXG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxUYWJsZVNlY3Rpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PlxuICAgICAgICAgICAge3JlbmRlcihpbmZvKX1cbiAgICAgICAgPC9UYWJsZVNlY3Rpb25Db250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn0pO1xuLypcbmV4cG9ydCBjb25zdCBUYWJsZUJvZHkgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBUYWJsZUJvZHlVPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENSID0gdW5kZWZpbmVkLCBDQyA9IHVuZGVmaW5lZCwgS1IgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oeyByZW5kZXIgfTogVGFibGVCb2R5UHJvcHM8U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudCwgQ1IsIENDLCBLUj4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgeyB1c2VUYWJsZUJvZHlQcm9wcywgLi4uc2VjdGlvbkluZm8gfSA9IHVzZUNvbnRleHQoVGFibGVCb2R5Q29udGV4dCkoe30pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBzZWN0aW9uSW5mbyk7XG5cbiAgICByZXR1cm4gPExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT1cImJvZHlcIj57cmVuZGVyKHNlY3Rpb25JbmZvLCB1c2VUYWJsZUJvZHlQcm9wcyl9PC9Mb2NhdGlvbkNvbnRleHQuUHJvdmlkZXI+XG59KVxuXG5leHBvcnQgY29uc3QgVGFibGVIZWFkID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gVGFibGVIZWFkVTxUIGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIsIHRhZ1RhYmxlSGVhZCB9OiBUYWJsZUhlYWRQcm9wczxUPikge1xuICAgIGNvbnN0IHVzZVRhYmxlU2VjdGlvblByb3BzQmFzZSA9IHVzZUNvbnRleHQoVGFibGVTZWN0aW9uQ29udGV4dCk7XG4gICAgY29uc3QgdXNlVGFibGVTZWN0aW9uUHJvcHM6IFByb3BNb2RpZmllcjxUPiA9IChwcm9wcykgPT4gdXNlVGFibGVTZWN0aW9uUHJvcHNCYXNlKHRhZ1RhYmxlSGVhZCwgXCJoZWFkXCIsIHByb3BzKTtcbiAgICByZXR1cm4gPExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT1cImhlYWRcIj57KHJlbmRlcih1c2VUYWJsZVNlY3Rpb25Qcm9wcykpfTwvTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyPlxufSlcblxuZXhwb3J0IGNvbnN0IFRhYmxlRm9vdCA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIFRhYmxlRm9vdFU8VCBleHRlbmRzIEVsZW1lbnQ+KHsgcmVuZGVyLCB0YWdUYWJsZUZvb3QgfTogVGFibGVGb290UHJvcHM8VD4pIHtcbiAgICBjb25zdCB1c2VUYWJsZVNlY3Rpb25Qcm9wc0Jhc2UgPSB1c2VDb250ZXh0KFRhYmxlU2VjdGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IHVzZVRhYmxlU2VjdGlvblByb3BzOiBQcm9wTW9kaWZpZXI8VD4gPSAocHJvcHMpID0+IHVzZVRhYmxlU2VjdGlvblByb3BzQmFzZSh0YWdUYWJsZUZvb3QsIFwiZm9vdFwiLCBwcm9wcyk7XG4gICAgcmV0dXJuIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9XCJmb290XCI+eyhyZW5kZXIodXNlVGFibGVTZWN0aW9uUHJvcHMpKX08L0xvY2F0aW9uQ29udGV4dC5Qcm92aWRlcj5cbn0pKi9cblxuZXhwb3J0IGNvbnN0IFRhYmxlUm93ID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gVGFibGVSb3dVPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgaW5kZXgsXG4gICAgZ2V0VGV4dCxcbiAgICB0YWdUYWJsZVJvdyxcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgYXJpYVByb3BOYW1lLFxuICAgIGRpc2FibGVkLFxuICAgIHVudGFiYmFibGUsXG4gICAgbmF2aWdhdGVQYXN0RW5kLFxuICAgIG5hdmlnYXRlUGFzdFN0YXJ0LFxuICAgIHNlbGVjdGVkLFxuICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgaGlkZGVuLFxuXG4gICAgcmVuZGVyXG59OiBUYWJsZVJvd1Byb3BzPFJvd0VsZW1lbnQsIENlbGxlbWVudCwgVGFibGVSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxlbWVudD4sIFRhYmxlQ2VsbEluZm88Q2VsbGVtZW50Pj4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgY3gxID0gdXNlQ29udGV4dChUYWJsZVNlY3Rpb25Db250ZXh0KTtcbiAgICBjb25zdCBpbmZvID0gdXNlVGFibGVSb3c8Um93RWxlbWVudCwgQ2VsbGVtZW50LCBUYWJsZVJvd0luZm88Um93RWxlbWVudCwgQ2VsbGVtZW50PiwgVGFibGVDZWxsSW5mbzxDZWxsZW1lbnQ+Pih7XG4gICAgICAgIHJvd0FzQ2hpbGRPZkdyaWRQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBjb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczoge30sXG4gICAgICAgICAgICBjb250ZXh0OiBjeDEsXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczogeyBoaWRkZW46IGhpZGRlbiA/PyBmYWxzZSB9LFxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgYXJpYVByb3BOYW1lLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU6IHVzZURlZmF1bHQoXCJzZWxlY3Rpb25Nb2RlXCIsIHNlbGVjdGlvbk1vZGUpLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCA/PyBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIGdldFRleHQ6IHVzZURlZmF1bHQoXCJnZXRUZXh0XCIsIGdldFRleHQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJvd0FzUGFyZW50T2ZDZWxsc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5czogdXNlRGVmYXVsdChcImRpc2FibGVBcnJvd0tleXNcIiwgZGlzYWJsZUFycm93S2V5cyksXG4gICAgICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUhvbWVFbmRLZXlzXCIsIGRpc2FibGVIb21lRW5kS2V5cyksXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kOiBuYXZpZ2F0ZVBhc3RFbmQgPz8gXCJ3cmFwXCIsXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IG5hdmlnYXRlUGFzdFN0YXJ0ID8/IFwid3JhcFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IG9uVGFiYmFibGVJbmRleENoYW5nZTogb25UYWJiYWJsZUluZGV4Q2hhbmdlID8/IG51bGwsIHVudGFiYmFibGU6IHVudGFiYmFibGUgPz8gZmFsc2UgfVxuICAgICAgICB9LFxuICAgICAgICB0YWJsZVJvd1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCA/PyBudWxsLFxuICAgICAgICAgICAgdGFnVGFibGVSb3dcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiA8VGFibGVSb3dDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PntyZW5kZXIoaW5mbyl9PC9UYWJsZVJvd0NvbnRleHQuUHJvdmlkZXI+XG59KVxuXG5leHBvcnQgY29uc3QgVGFibGVDZWxsID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gVGFibGVDZWxsPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluZGV4LFxuICAgIGdldFRleHQsXG4gICAgZm9jdXNTZWxmLFxuICAgIGhpZGRlbixcbiAgICB0YWdUYWJsZUNlbGwsXG4gICAgcmVuZGVyLFxuICAgIGNvbFNwYW4sXG4gICAgZXhjbHVkZSxcbiAgICBvblByZXNzU3luYyxcbiAgICBnZXRTb3J0VmFsdWVcbn06IFRhYmxlQ2VsbFByb3BzPENlbGxFbGVtZW50LCBUYWJsZUNlbGxJbmZvPENlbGxFbGVtZW50Pj4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgY29udGV4dCA9ICh1c2VDb250ZXh0KFRhYmxlUm93Q29udGV4dCkgYXMgVXNlVGFibGVSb3dDb250ZXh0PGFueSwgQ2VsbEVsZW1lbnQsIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pik7XG4gICAgY29uc3QgZm9jdXNTZWxmRGVmYXVsdCA9IHVzZUNhbGxiYWNrKChlOiBhbnkpID0+IHsgZT8uZm9jdXMoKTsgfSwgW10pO1xuICAgIGNvbnN0IGluZm8gPSB1c2VUYWJsZUNlbGw8Q2VsbEVsZW1lbnQsIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pih7XG4gICAgICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczogeyBnZXRTb3J0VmFsdWUgfSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczogeyBjb2xTcGFuOiBjb2xTcGFuID8/IDEgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczogeyBoaWRkZW46IGhpZGRlbiA/PyBmYWxzZSB9LFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZSwgZm9jdXNTZWxmOiBmb2N1c1NlbGYgPz8gZm9jdXNTZWxmRGVmYXVsdCwgb25QcmVzc1N5bmMgfSxcbiAgICAgICAgdGFibGVDZWxsUGFyYW1ldGVyczogeyB0YWdUYWJsZUNlbGwgfSxcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzOiB7IGdldFRleHQ6IHVzZURlZmF1bHQoXCJnZXRUZXh0XCIsIGdldFRleHQpIH1cbiAgICAgICAgLyogbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxuICAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmLCBoaWRkZW4sIG5vTW9kaWZ5VGFiSW5kZXggfSxcbiAgICAgICAgIGhhc0ZvY3VzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9LFxuICAgICAgICAgc3ViSW5mbyxcbiAgICAgICAgIHRhYmxlQ2VsbDoge1xuICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgIGhlYWRlclR5cGUsXG4gICAgICAgICAgICAgdGFnVGFibGVDZWxsLFxuICAgICAgICAgICAgIGxvY2F0aW9uOiB1c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dClcbiAgICAgICAgIH0qL1xuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiByZW5kZXIoaW5mbyk7XG59KVxuXG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBSZWYsIHJlbmRlciwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyBUYWJzQ29udGV4dCwgVXNlVGFiLCBVc2VUYWJQYW5lbCwgVXNlVGFiUGFuZWxQYXJhbWV0ZXJzLCBVc2VUYWJQYXJhbWV0ZXJzLCB1c2VUYWJzLCBVc2VUYWJzUGFyYW1ldGVycywgVGFiUGFuZWxzQ29udGV4dCwgVXNlVGFic1JldHVyblR5cGUsIHVzZVRhYiwgVXNlVGFiUmV0dXJuVHlwZSwgVXNlVGFiUGFuZWxSZXR1cm5UeXBlLCB1c2VUYWJQYW5lbCB9IGZyb20gXCIuLi91c2UtdGFic1wiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcnRpYWxFeGNlcHQsIHVzZURlZmF1bHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcblxuaW50ZXJmYWNlIFRhYnNQcm9wc0Jhc2U8VGFiQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZVRhYnNQYXJhbWV0ZXJzPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudD4sIFwibGFiZWxQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUYWJzUGFyYW1ldGVyczxUYWJDb250YWluZXJFbGVtZW50LCBUYWJFbGVtZW50LCBUYWJMYWJlbEVsZW1lbnQ+LCBcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUYWJzUGFyYW1ldGVyczxUYWJDb250YWluZXJFbGVtZW50LCBUYWJFbGVtZW50LCBUYWJMYWJlbEVsZW1lbnQ+LCBcInJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYnNQYXJhbWV0ZXJzPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUYWJzUGFyYW1ldGVyczxUYWJDb250YWluZXJFbGVtZW50LCBUYWJFbGVtZW50LCBUYWJMYWJlbEVsZW1lbnQ+LCBcInNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYnNQYXJhbWV0ZXJzPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudD4sIFwic29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYnNQYXJhbWV0ZXJzPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudD4sIFwidGFic1BhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYnNQYXJhbWV0ZXJzPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudD4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4ge1xufVxuXG5pbnRlcmZhY2UgVGFiUHJvcHNCYXNlPFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJwcmVzc1BhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwic2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcInNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcInRleHRDb250ZW50UGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzXCI+IHtcbn1cblxuaW50ZXJmYWNlIFRhYlBhbmVsUHJvcHNCYXNlPFBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlVGFiUGFuZWxQYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4ge1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYnNQcm9wczxUYWJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxUYWJzUHJvcHNCYXNlPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudD4sIFwib3JpZW50YXRpb25cIiB8IFwiZ3JvdXBpbmdUeXBlXCIgfCBcImFyaWFMYWJlbFwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZVRhYnNSZXR1cm5UeXBlPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYlByb3BzPFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFBhcnRpYWxFeGNlcHQ8VGFiUHJvcHNCYXNlPFRhYkVsZW1lbnQ+LCBcImluZGV4XCIgfCBcImdldFNvcnRWYWx1ZVwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZVRhYlJldHVyblR5cGU8VGFiRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYlBhbmVsUHJvcHM8UGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PFRhYlBhbmVsUHJvcHNCYXNlPFBhbmVsRWxlbWVudD4sIFwiaW5kZXhcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VUYWJQYW5lbFJldHVyblR5cGU8UGFuZWxFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cbmNvbnN0IFRhYnNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxUYWJzQ29udGV4dDxhbnksIGFueSwgYW55Pj4obnVsbCEpO1xuY29uc3QgVGFiUGFuZWxzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VGFiUGFuZWxzQ29udGV4dDxhbnk+PihudWxsISk7XG5cbmV4cG9ydCBmdW5jdGlvbiBUYWJzPFRhYkNvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGFyaWFMYWJlbCxcbiAgICBjb2xsYXRvcixcbiAgICBjb21wYXJlLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIGdldEluZGV4LFxuICAgIGluaXRpYWxseVNlbGVjdGVkSW5kZXgsXG4gICAgbmF2aWdhdGVQYXN0RW5kLFxuICAgIG5hdmlnYXRlUGFzdFN0YXJ0LFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIHNldFNlbGVjdGVkSW5kZXgsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIG9yaWVudGF0aW9uLFxuICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZSxcbiAgICBncm91cGluZ1R5cGUsXG4gICAgdW50YWJiYWJsZSxcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIHJvbGUsXG4gICAgcmVuZGVyXG59OiBUYWJzUHJvcHM8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudCwgVGFiTGFiZWxFbGVtZW50Pikge1xuICAgIGNvbnN0IGluZm8gPSB1c2VUYWJzPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudD4oe1xuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHsgYXJpYUxhYmVsIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUFycm93S2V5c1wiLCBkaXNhYmxlQXJyb3dLZXlzKSxcbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5czogdXNlRGVmYXVsdChcImRpc2FibGVIb21lRW5kS2V5c1wiLCBkaXNhYmxlSG9tZUVuZEtleXMpLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kOiBuYXZpZ2F0ZVBhc3RFbmQgPz8gXCJ3cmFwXCIsXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydDogbmF2aWdhdGVQYXN0U3RhcnQgPz8gXCJ3cmFwXCIsXG4gICAgICAgICAgICBwYWdlTmF2aWdhdGlvblNpemU6IHVzZURlZmF1bHQoXCJwYWdlTmF2aWdhdGlvblNpemVcIiwgcGFnZU5hdmlnYXRpb25TaXplKVxuICAgICAgICB9LFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IGdldEluZGV4OiB1c2VEZWZhdWx0KFwiZ2V0SW5kZXhcIiwgZ2V0SW5kZXgpIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiBvblRhYmJhYmxlSW5kZXhDaGFuZ2UgPz8gbnVsbCxcbiAgICAgICAgICAgIHVudGFiYmFibGU6IHVudGFiYmFibGUgPz8gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogeyBpbml0aWFsbHlTZWxlY3RlZEluZGV4OiBpbml0aWFsbHlTZWxlY3RlZEluZGV4ID8/IDAsIHNldFNlbGVjdGVkSW5kZXg6IHNldFNlbGVjdGVkSW5kZXggPz8gbnVsbCB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBjb21wYXJlOiBjb21wYXJlID8/IG51bGwgfSxcbiAgICAgICAgdGFic1BhcmFtZXRlcnM6IHsgb3JpZW50YXRpb24sIGdyb3VwaW5nVHlwZSwgcm9sZSB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY29sbGF0b3I6IHVzZURlZmF1bHQoXCJjb2xsYXRvclwiLCBjb2xsYXRvciksXG4gICAgICAgICAgICBub1R5cGVhaGVhZDogdXNlRGVmYXVsdChcIm5vVHlwZWFoZWFkXCIsIG5vVHlwZWFoZWFkKSxcbiAgICAgICAgICAgIHR5cGVhaGVhZFRpbWVvdXQ6IHVzZURlZmF1bHQoXCJ0eXBlYWhlYWRUaW1lb3V0XCIsIHR5cGVhaGVhZFRpbWVvdXQpXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgY29udGV4dFBhbmVscywgY29udGV4dFRhYnMgfSA9IGluZm87XG5cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxUYWJzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFRhYnN9PlxuICAgICAgICAgICAgPFRhYlBhbmVsc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRQYW5lbHN9PlxuICAgICAgICAgICAgICAgIHtyZW5kZXIoaW5mbyl9XG4gICAgICAgICAgICA8L1RhYlBhbmVsc0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgIDwvVGFic0NvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gVGFiPEUgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgZGlzYWJsZWQsXG4gICAgZXhjbHVkZSxcbiAgICBmb2N1c1NlbGYsXG4gICAgaGlkZGVuLFxuICAgIGluZGV4LFxuICAgIG9uUHJlc3NTeW5jLFxuICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgZ2V0VGV4dCxcbiAgICBnZXRTb3J0VmFsdWUsXG4gICAgcmVuZGVyXG59OiBUYWJQcm9wczxFPikge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFRhYnNDb250ZXh0KTtcbiAgICBjb25zdCBmb2N1c1NlbGZEZWZhdWx0ID0gdXNlQ2FsbGJhY2soKGU6IGFueSkgPT4geyBlPy5mb2N1cygpOyB9LCBbXSk7XG4gICAgY29uc3QgaW5mbyA9IHVzZVRhYjxFPih7XG4gICAgICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHt9LFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczogeyBoaWRkZW46IGhpZGRlbiA/PyBmYWxzZSB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVyczogeyBnZXRTb3J0VmFsdWUgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZSwgZm9jdXNTZWxmOiBmb2N1c1NlbGYgPz8gZm9jdXNTZWxmRGVmYXVsdCwgb25QcmVzc1N5bmMgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IGRpc2FibGVkOiBkaXNhYmxlZCA/PyBmYWxzZSwgc2VsZWN0aW9uTW9kZTogXCJmb2N1c1wiIH0sXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogeyBnZXRUZXh0OiB1c2VEZWZhdWx0KFwiZ2V0VGV4dFwiLCBnZXRUZXh0KSB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFRhYlBhbmVsPEUgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgaW5kZXgsXG4gICAgcmVuZGVyXG59OiBUYWJQYW5lbFByb3BzPEU+KSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoVGFiUGFuZWxzQ29udGV4dCk7XG4gICAgY29uc3QgaW5mbyA9IHVzZVRhYlBhbmVsPEU+KHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcbn1cblxuXG4vKlxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYnNQcm9wczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUQywgUEMsIFRLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIFRDLCBUSz4sIFwibGluZWFyTmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudCwgVEMsIFRLPiwgXCJsaXN0TmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudCwgVEMsIFRLPiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIFRDLCBUSz4sIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIFRDLCBUSz4sIFwic2luZ2xlU2VsZWN0aW9uXCI+LFxuICAgIEdldDxVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50LCBUQywgVEs+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIFRDLCBUSz4sIFwiY2hpbGRyZW5IYXZlRm9jdXNcIj4sXG4gICAgLy9HZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudCwgVEMsIFRLPiwgPixcbiAgICBHZXQyPFVzZVRhYnNQYXJhbWV0ZXJzLCBcInRhYlBhbmVsc1wiLCBcIm1hbmFnZWRDaGlsZHJlblwiPiB7XG4gICAgcmVmPzogUmVmPFVzZVRhYnNSZXR1cm5UeXBlSW5mbzxQQz4+O1xuICAgIHJlbmRlcih0YWJMaXN0SW5mbzogVXNlVGFiTGlzdFJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQsIFRDPiwgdGFic0luZm86IFVzZVRhYnNSZXR1cm5UeXBlSW5mbzxQQz4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxMYWJlbEVsZW1lbnQ+LCBtb2RpZnlUYWJMaXN0UHJvcHM6IFByb3BNb2RpZmllcjxMaXN0RWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYlByb3BzPFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUQywgVEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgR2V0PFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudCwgVEMsIFRLLCBUQz4sIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudCwgVEMsIFRLLCBUQz4sIFwibWFuYWdlZENoaWxkXCI+LFxuICAgIFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxUYWJFbGVtZW50PixcbiAgICBHZXQ8VXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50LCBUQywgVEssIFRDPiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQ8VXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50LCBUQywgVEssIFRDPiwgXCJzaW5nbGVTZWxlY3Rpb25cIj4ge1xuICAgIHN1YkluZm86IEdldDxVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIFRDLCBUSywgVEM+LCBcInN1YkluZm9cIj47XG4gICAgcmVmPzogUmVmPFVzZVRhYlJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+PjtcbiAgICByZW5kZXIoaW5mbzogVXNlVGFiUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudD4sIG1vZGlmeUxpc3RJdGVtOiBQcm9wTW9kaWZpZXI8VGFiRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYlBhbmVsUHJvcHM8VGFiUGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUEMsIFBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIEdldDxVc2VUYWJQYW5lbFBhcmFtZXRlcnM8UEMsIFBLLCBQQz4sIFwibWFuYWdlZENoaWxkXCI+IHtcbiAgICBzdWJJbmZvOiBHZXQ8VXNlVGFiUGFuZWxQYXJhbWV0ZXJzPFBDLCBQSywgUEM+LCBcInN1YkluZm9cIj47XG4gICAgcmVmPzogUmVmPFVzZVRhYlBhbmVsUmV0dXJuVHlwZUluZm8+O1xuICAgIHJlbmRlcihpbmZvOiBVc2VUYWJQYW5lbFJldHVyblR5cGVJbmZvLCBtb2RpZnlUYWJQYW5lbFByb3BzOiBQcm9wTW9kaWZpZXI8VGFiUGFuZWxFbGVtZW50Pik6IFZOb2RlO1xufVxuXG5jb25zdCBUYWJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWI8YW55LCBhbnksIGFueT4+KG51bGwhKTtcbmNvbnN0IFRhYlBhbmVsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVGFiUGFuZWw8YW55LCBhbnksIGFueT4+KG51bGwhKTtcblxuZXhwb3J0IGNvbnN0IFRhYnMgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBUYWJzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRDID0gdW5kZWZpbmVkLCBQQyA9IHVuZGVmaW5lZCwgVEsgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlciwgUEsgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oe1xuICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgc2VsZWN0aW9uTW9kZSxcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBpbmRleERlbWFuZ2xlcixcbiAgICBpbmRleE1hbmdsZXIsXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICBub1R5cGVhaGVhZCxcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgb25BbGxMb3N0Rm9jdXMsXG4gICAgb25BbnlHYWluZWRGb2N1cyxcbiAgICBzZXRTZWxlY3RlZEluZGV4LFxuICAgIHJlbmRlclxufTogVGFic1Byb3BzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFRDLCBQQywgVEs+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlVGFiTGlzdCxcbiAgICAgICAgdXNlVGFiTGlzdExhYmVsLFxuICAgICAgICB1c2VUYWJQYW5lbCxcbiAgICAgICAgLi4udGFic0luZm9cbiAgICB9ID0gdXNlVGFiczxMaXN0RWxlbWVudCwgVGFiRWxlbWVudCwgVGFiUGFuZWxFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFRDLCBQQywgVEssIFBLPih7XG4gICAgICAgIHRhYlBhbmVsczoge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiB0YWJzSW5mbyk7XG5cbiAgICBjb25zdCB7IHVzZVRhYiwgdXNlVGFiTGlzdFByb3BzLCAuLi50YWJsaXN0SW5mbyB9ID0gdXNlVGFiTGlzdCh7XG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWRJbmRleCwgc2VsZWN0aW9uTW9kZSwgc2V0U2VsZWN0ZWRJbmRleCB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XG4gICAgfSk7XG4gICAgY29uc3QgeyB1c2VUYWJMaXN0TGFiZWxQcm9wcyB9ID0gdXNlVGFiTGlzdExhYmVsKHt9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxUYWJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJ9PlxuICAgICAgICAgICAgPFRhYlBhbmVsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFiUGFuZWx9PlxuICAgICAgICAgICAgICAgIHtyZW5kZXIodGFibGlzdEluZm8sIHRhYnNJbmZvLCB1c2VUYWJMaXN0TGFiZWxQcm9wcywgdXNlVGFiTGlzdFByb3BzKX1cbiAgICAgICAgICAgIDwvVGFiUGFuZWxDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICA8L1RhYkNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufSlcblxuZXhwb3J0IGNvbnN0IFRhYiA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIFRhYjxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVEMgPSB1bmRlZmluZWQsIFRLIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KHsgaW5kZXgsIHRleHQsIGZsYWdzLCBmb2N1c1NlbGYsIGhpZGRlbiwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCByZW5kZXIsIHN1YkluZm8sIG5vTW9kaWZ5VGFiSW5kZXgsIHVuc2VsZWN0YWJsZSB9OiBUYWJQcm9wczxUYWJFbGVtZW50LCBUQywgVEs+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IHsgdXNlVGFiUHJvcHMsIC4uLnRhYkluZm8gfSA9IHVzZUNvbnRleHQoVGFiQ29udGV4dCkoe1xuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyB1bnNlbGVjdGFibGUsIGZvY3VzU2VsZiB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZiwgaGlkZGVuLCBub01vZGlmeVRhYkluZGV4IH0sXG4gICAgICAgIGhhc0ZvY3VzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9LFxuICAgICAgICBzdWJJbmZvXG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IHRhYkluZm8pO1xuXG4gICAgcmV0dXJuIHJlbmRlcih0YWJJbmZvLCB1c2VUYWJQcm9wcylcbn0pXG5cbmV4cG9ydCBjb25zdCBUYWJQYW5lbCA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIFRhYlBhbmVsPFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFBDID0gdW5kZWZpbmVkLCBQSyBleHRlbmRzIHN0cmluZyA9IG5ldmVyPih7IGluZGV4LCBmbGFncywgcmVuZGVyLCBzdWJJbmZvIH06IFRhYlBhbmVsUHJvcHM8VGFiUGFuZWxFbGVtZW50LCBQQywgUEs+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IHsgdXNlVGFiUGFuZWxQcm9wcywgLi4udGFiUGFuZWxJbmZvIH0gPSAodXNlQ29udGV4dChUYWJQYW5lbENvbnRleHQpIGFzIFVzZVRhYlBhbmVsPFRhYlBhbmVsRWxlbWVudCwgUEMsIFBLPikoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHN1YkluZm8gfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IHRhYlBhbmVsSW5mbyk7XG5cbiAgICByZXR1cm4gcmVuZGVyKHRhYlBhbmVsSW5mbywgdXNlVGFiUGFuZWxQcm9wcylcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFiczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUQywgUEM+KHsgdGFnTGFiZWwsIHRhZ0xpc3QsIG1ha2VQcm9wc0xhYmVsLCBtYWtlUHJvcHNMaXN0LCBwYW5lbHMgfTogeyBwYW5lbHM6IFZOb2RlW10sIHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PiwgdGFnTGlzdDogRWxlbWVudFRvVGFnPExpc3RFbGVtZW50PiwgbWFrZVByb3BzTGFiZWw6IChpbmZvVGFiczogVXNlVGFic1JldHVyblR5cGVJbmZvPFBDPiwgaW5mb0xpc3Q6IFVzZVRhYkxpc3RSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50LCBUQz4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4sIG1ha2VQcm9wc0xpc3Q6IChpbmZvVGFiczogVXNlVGFic1JldHVyblR5cGVJbmZvPFBDPiwgaW5mb0xpc3Q6IFVzZVRhYkxpc3RSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50LCBUQz4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YWJsaXN0SW5mbzogVXNlVGFiTGlzdFJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQsIFRDPiwgdGFic0luZm86IFVzZVRhYnNSZXR1cm5UeXBlSW5mbzxQQz4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxMYWJlbEVsZW1lbnQ+LCBtb2RpZnlMaXN0UHJvcHM6IFByb3BNb2RpZmllcjxMaXN0RWxlbWVudD4pIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KHRhZ0xhYmVsIGFzIG5ldmVyLCBtb2RpZnlMYWJlbFByb3BzKG1ha2VQcm9wc0xhYmVsKHRhYnNJbmZvLCB0YWJsaXN0SW5mbykpKVxuICAgICAgICBjb25zdCBsaXN0ID0gY3JlYXRlRWxlbWVudCh0YWdMaXN0IGFzIG5ldmVyLCBtb2RpZnlMaXN0UHJvcHMobWFrZVByb3BzTGlzdCh0YWJzSW5mbywgdGFibGlzdEluZm8pKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgICAgICB7bGlzdH1cbiAgICAgICAgICAgICAgICB7cGFuZWxzfVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFiPFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IG1ha2VQcm9wc1RhYiwgdGFnVGFiIH06IHsgdGFnVGFiOiBFbGVtZW50VG9UYWc8VGFiRWxlbWVudD4sIG1ha2VQcm9wc1RhYjogKGluZm86IFVzZVRhYlJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YWJJbmZvOiBVc2VUYWJSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PiwgbW9kaWZ5VGFiUHJvcHM6IFByb3BNb2RpZmllcjxUYWJFbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWIgYXMgbmV2ZXIsIG1vZGlmeVRhYlByb3BzKG1ha2VQcm9wc1RhYih0YWJJbmZvKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJQYW5lbDxUYWJQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IG1ha2VQcm9wc1RhYlBhbmVsLCB0YWdUYWJQYW5lbCB9OiB7IHRhZ1RhYlBhbmVsOiBFbGVtZW50VG9UYWc8VGFiUGFuZWxFbGVtZW50PiwgbWFrZVByb3BzVGFiUGFuZWw6IChpbmZvOiBVc2VUYWJQYW5lbFJldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJQYW5lbEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhYlBhbmVsSW5mbzogVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbywgbW9kaWZ5VGFiUGFuZWxQcm9wczogUHJvcE1vZGlmaWVyPFRhYlBhbmVsRWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFiUGFuZWwgYXMgbmV2ZXIsIG1vZGlmeVRhYlBhbmVsUHJvcHMobWFrZVByb3BzVGFiUGFuZWwodGFiUGFuZWxJbmZvKSkpO1xuICAgIH1cbn1cbiovIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBUb2FzdEluZm8sIFRvYXN0c0NvbnRleHQsIHVzZVRvYXN0LCBVc2VUb2FzdFBhcmFtZXRlcnMsIFVzZVRvYXN0UmV0dXJuVHlwZSwgdXNlVG9hc3RzLCBVc2VUb2FzdHNQYXJhbWV0ZXJzLCBVc2VUb2FzdHNSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL3VzZS10b2FzdHNcIjtcbmltcG9ydCB7IG1lbW9Gb3J3YXJkUmVmIH0gZnJvbSBcIi4vdXRpbFwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRvYXN0c1Byb3BzPENvbnRhaW5lclR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIEdldDxVc2VUb2FzdHNQYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnNcIj4sIEdldDxVc2VUb2FzdHNQYXJhbWV0ZXJzLCBcInRvYXN0c1BhcmFtZXRlcnNcIj4ge1xuICAgIC8vdGFnQ29udGFpbmVyOiBFbGVtZW50VG9UYWc8Q29udGFpbmVyRWxlbWVudD47XG4gICAgLy9jaGlsZHJlbjogVk5vZGVbXTtcbiAgICByZWY/OiBSZWY8VXNlVG9hc3RzUmV0dXJuVHlwZTxDb250YWluZXJUeXBlLCBUb2FzdEluZm8+PjtcbiAgICByZW5kZXIoaW5mbzogVXNlVG9hc3RzUmV0dXJuVHlwZTxDb250YWluZXJUeXBlLCBUb2FzdEluZm8+KTogVk5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9hc3RQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHZXQ8VXNlVG9hc3RQYXJhbWV0ZXJzPFRvYXN0SW5mbz4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPiwgR2V0PFVzZVRvYXN0UGFyYW1ldGVyczxUb2FzdEluZm8+LCBcInRvYXN0UGFyYW1ldGVyc1wiPiB7XG4gICAgLy9zdWJJbmZvOiBHZXQ8VXNlVG9hc3RQYXJhbWV0ZXIsIFwic3ViSW5mb1wiPjtcbiAgICByZWY/OiBSZWY8VXNlVG9hc3RSZXR1cm5UeXBlPEU+PjtcbiAgICByZW5kZXIoYXJnczogVXNlVG9hc3RSZXR1cm5UeXBlPEU+KTogVk5vZGU7XG59XG5cbi8qZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUb2FzdHMoe306IHt9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmdzOiBVc2VUb2FzdHNSZXR1cm5UeXBlSW5mbywgcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENvbnRhaW5lclR5cGU+KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgIDxkaXY+XG5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIClcbiAgICB9XG59Ki9cblxuY29uc3QgVG9hc3RDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxUb2FzdHNDb250ZXh0PFRvYXN0SW5mbz4+KG51bGwhKTtcblxuZXhwb3J0IGNvbnN0IFRvYXN0cyA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIFRvYXN0czxDb250YWluZXJUeXBlIGV4dGVuZHMgRWxlbWVudD4oeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgcmVuZGVyLCB2aXNpYmxlQ291bnQgfTogVG9hc3RzUHJvcHM8Q29udGFpbmVyVHlwZT4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgaW5mbyA9IHVzZVRvYXN0czxDb250YWluZXJUeXBlPih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSwgdG9hc3RzUGFyYW1ldGVyczogeyB2aXNpYmxlQ291bnQgfSB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8VG9hc3RDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PlxuICAgICAgICAgICAge3JlbmRlcihpbmZvKX1cbiAgICAgICAgPC9Ub2FzdENvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbn0pXG5cbmV4cG9ydCBjb25zdCBUb2FzdCA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIFRvYXN0PEUgZXh0ZW5kcyBFbGVtZW50Pih7IHJlbmRlciwgaW5kZXgsIHRpbWVvdXQsIHBvbGl0ZW5lc3MgfTogVG9hc3RQcm9wczxFPiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKHVzZUNvbnRleHQoVG9hc3RDb250ZXh0KSBhcyBUb2FzdHNDb250ZXh0PFRvYXN0SW5mbz4pXG4gICAgY29uc3QgaW5mbyA9IHVzZVRvYXN0PEU+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LFxuICAgICAgICB0b2FzdFBhcmFtZXRlcnM6IHsgdGltZW91dCwgcG9saXRlbmVzcyB9LFxuICAgICAgICBjb250ZXh0XG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcbn0pXG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCIuLi9wcm9wc1wiO1xuLy9pbXBvcnQgeyBFbGVtZW50VG9UYWcgfSBmcm9tIFwiLi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZVRvb2xiYXIsIHVzZVRvb2xiYXJDaGlsZCwgVXNlVG9vbGJhclJldHVyblR5cGUsIFVzZVRvb2xiYXJDaGlsZFJldHVyblR5cGUsIFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnMsIFVzZVRvb2xiYXJQYXJhbWV0ZXJzLCBVc2VUb29sYmFyU3ViSW5mbywgVXNlVG9vbGJhckNvbnRleHQgfSBmcm9tIFwiLi4vdXNlLXRvb2xiYXJcIjtcbmltcG9ydCB7IG1lbW9Gb3J3YXJkUmVmLCBQYXJ0aWFsRXhjZXB0LCB1c2VEZWZhdWx0IH0gZnJvbSBcIi4vdXRpbFwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xiYXJQcm9wc0Jhc2U8VG9vbGJhckNvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUb29sYmFyQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZVRvb2xiYXJTdWJJbmZvPFRvb2xiYXJDaGlsZEVsZW1lbnQ+PiBleHRlbmRzXG4gICAgR2V0PFVzZVRvb2xiYXJQYXJhbWV0ZXJzPFRvb2xiYXJDb250YWluZXJFbGVtZW50LCBUb29sYmFyQ2hpbGRFbGVtZW50LCBNPiwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVG9vbGJhclBhcmFtZXRlcnM8VG9vbGJhckNvbnRhaW5lckVsZW1lbnQsIFRvb2xiYXJDaGlsZEVsZW1lbnQsIE0+LCBcInNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRvb2xiYXJQYXJhbWV0ZXJzPFRvb2xiYXJDb250YWluZXJFbGVtZW50LCBUb29sYmFyQ2hpbGRFbGVtZW50LCBNPiwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRvb2xiYXJQYXJhbWV0ZXJzPFRvb2xiYXJDb250YWluZXJFbGVtZW50LCBUb29sYmFyQ2hpbGRFbGVtZW50LCBNPiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVG9vbGJhclBhcmFtZXRlcnM8VG9vbGJhckNvbnRhaW5lckVsZW1lbnQsIFRvb2xiYXJDaGlsZEVsZW1lbnQsIE0+LCBcInNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUb29sYmFyUGFyYW1ldGVyczxUb29sYmFyQ29udGFpbmVyRWxlbWVudCwgVG9vbGJhckNoaWxkRWxlbWVudCwgTT4sIFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVG9vbGJhclBhcmFtZXRlcnM8VG9vbGJhckNvbnRhaW5lckVsZW1lbnQsIFRvb2xiYXJDaGlsZEVsZW1lbnQsIE0+LCBcInRvb2xiYXJQYXJhbWV0ZXJzXCI+IHtcbiAgICByZWY/OiBSZWY8VXNlVG9vbGJhclJldHVyblR5cGU8VG9vbGJhckNvbnRhaW5lckVsZW1lbnQsIFRvb2xiYXJDaGlsZEVsZW1lbnQsIE0+Pjtcbn1cblxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xiYXJDaGlsZFByb3BzQmFzZTxUb29sYmFyQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZVRvb2xiYXJTdWJJbmZvPFRvb2xiYXJDaGlsZEVsZW1lbnQ+PiBleHRlbmRzXG4gICAgR2V0PFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnM8VG9vbGJhckNoaWxkRWxlbWVudCwgTT4sIFwicHJlc3NQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUb29sYmFyQ2hpbGRQYXJhbWV0ZXJzPFRvb2xiYXJDaGlsZEVsZW1lbnQsIE0+LCBcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVG9vbGJhckNoaWxkUGFyYW1ldGVyczxUb29sYmFyQ2hpbGRFbGVtZW50LCBNPiwgXCJyb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVG9vbGJhckNoaWxkUGFyYW1ldGVyczxUb29sYmFyQ2hpbGRFbGVtZW50LCBNPiwgXCJzb3J0YWJsZUNoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVG9vbGJhckNoaWxkUGFyYW1ldGVyczxUb29sYmFyQ2hpbGRFbGVtZW50LCBNPiwgXCJ0ZXh0Q29udGVudFBhcmFtZXRlcnNcIj4sXG4gICAgUGljazxHZXQ8VXNlVG9vbGJhckNoaWxkUGFyYW1ldGVyczxhbnksIGFueT4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPiwgXCJpbmRleFwiPiB7XG4vLyAgICBzdWJJbmZvOiBVc2VUb29sYmFyQ2hpbGRQYXJhbWV0ZXJzPFRvb2xiYXJDaGlsZEVsZW1lbnQsIE0+W1wiY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyc1wiXTtcbiAgICByZWY/OiBSZWY8VXNlVG9vbGJhckNoaWxkUmV0dXJuVHlwZTxUb29sYmFyQ2hpbGRFbGVtZW50LCBNPj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbGJhclByb3BzPFRvb2xiYXJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVG9vbGJhckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxUb29sYmFyQ2hpbGRFbGVtZW50Pj4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PFRvb2xiYXJQcm9wc0Jhc2U8VG9vbGJhckNvbnRhaW5lckVsZW1lbnQsIFRvb2xiYXJDaGlsZEVsZW1lbnQsIE0+LCBcIm9yaWVudGF0aW9uXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlVG9vbGJhclJldHVyblR5cGU8VG9vbGJhckNvbnRhaW5lckVsZW1lbnQsIFRvb2xiYXJDaGlsZEVsZW1lbnQsIE0+KTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb29sYmFyQ2hpbGRQcm9wczxUb29sYmFyQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZVRvb2xiYXJTdWJJbmZvPFRvb2xiYXJDaGlsZEVsZW1lbnQ+PiBleHRlbmRzIFBhcnRpYWxFeGNlcHQ8VG9vbGJhckNoaWxkUHJvcHNCYXNlPFRvb2xiYXJDaGlsZEVsZW1lbnQsIE0+LCBcImdldFNvcnRWYWx1ZVwiIHwgXCJhcmlhUHJvcE5hbWVcIiB8IFwiaW5kZXhcIiB8IFwic2VsZWN0aW9uTW9kZVwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZVRvb2xiYXJDaGlsZFJldHVyblR5cGU8VG9vbGJhckNoaWxkRWxlbWVudCwgTT4pOiBWTm9kZTxhbnk+O1xufVxuXG5jb25zdCBUb29sYmFyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVG9vbGJhckNvbnRleHQ8YW55LCBhbnksIGFueT4+KG51bGwhKTtcblxuZXhwb3J0IGNvbnN0IFRvb2xiYXIgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBUb29sYmFyVTxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIHJlbmRlcixcbiAgICByb2xlLFxuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIHVudGFiYmFibGUsXG4gICAgY29tcGFyZSxcbiAgICBnZXRJbmRleCxcbiAgICBuYXZpZ2F0ZVBhc3RFbmQsXG4gICAgbmF2aWdhdGVQYXN0U3RhcnQsXG4gICAgcGFnZU5hdmlnYXRpb25TaXplLFxuICAgIGluaXRpYWxseVNlbGVjdGVkSW5kZXgsXG4gICAgc2V0U2VsZWN0ZWRJbmRleCxcbiAgICBvcmllbnRhdGlvbixcbiAgICBub1R5cGVhaGVhZCxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgdHlwZWFoZWFkVGltZW91dFxufTogVG9vbGJhclByb3BzPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgVXNlVG9vbGJhclN1YkluZm88Q2hpbGRFbGVtZW50Pj4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgbGlzdGJveFJldHVyblR5cGUgPSB1c2VUb29sYmFyPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudD4oe1xuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IGdldEluZGV4OiB1c2VEZWZhdWx0KFwiZ2V0SW5kZXhcIiwgZ2V0SW5kZXgpIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IHsgaW5pdGlhbGx5U2VsZWN0ZWRJbmRleDogaW5pdGlhbGx5U2VsZWN0ZWRJbmRleCA/PyBudWxsLCBzZXRTZWxlY3RlZEluZGV4OiBzZXRTZWxlY3RlZEluZGV4ID8/IG51bGwgfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgY29tcGFyZTogY29tcGFyZSA/PyBudWxsIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUFycm93S2V5c1wiLCBkaXNhYmxlQXJyb3dLZXlzKSxcbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5czogdXNlRGVmYXVsdChcImRpc2FibGVIb21lRW5kS2V5c1wiLCBkaXNhYmxlSG9tZUVuZEtleXMpLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kOiBuYXZpZ2F0ZVBhc3RFbmQgPz8gXCJ3cmFwXCIsXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydDogbmF2aWdhdGVQYXN0U3RhcnQgPz8gXCJ3cmFwXCIsXG4gICAgICAgICAgICBwYWdlTmF2aWdhdGlvblNpemU6IHVzZURlZmF1bHQoXCJwYWdlTmF2aWdhdGlvblNpemVcIiwgcGFnZU5hdmlnYXRpb25TaXplKVxuICAgICAgICB9LFxuICAgICAgICB0b29sYmFyUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb3JpZW50YXRpb24sXG4gICAgICAgICAgICByb2xlOiByb2xlID8/IFwidG9vbGJhclwiXG4gICAgICAgIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IG9uVGFiYmFibGVJbmRleENoYW5nZSA/PyBudWxsLCB1bnRhYmJhYmxlOiB1bnRhYmJhYmxlID8/IGZhbHNlIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IFxuICAgICAgICAgICAgY29sbGF0b3I6IHVzZURlZmF1bHQoXCJjb2xsYXRvclwiLCBjb2xsYXRvciksIFxuICAgICAgICAgICAgbm9UeXBlYWhlYWQ6IHVzZURlZmF1bHQoXCJub1R5cGVhaGVhZFwiLCBub1R5cGVhaGVhZCksIFxuICAgICAgICAgICAgdHlwZWFoZWFkVGltZW91dDogdXNlRGVmYXVsdChcInR5cGVhaGVhZFRpbWVvdXRcIiwgdHlwZWFoZWFkVGltZW91dClcbiAgICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGxpc3Rib3hSZXR1cm5UeXBlKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxUb29sYmFyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bGlzdGJveFJldHVyblR5cGUuY29udGV4dH0+XG4gICAgICAgICAgICB7cmVuZGVyKGxpc3Rib3hSZXR1cm5UeXBlKX1cbiAgICAgICAgPC9Ub29sYmFyQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59KVxuXG5cbmV4cG9ydCBjb25zdCBUb29sYmFyQ2hpbGQgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBUb29sYmFyQ2hpbGRVPFRvb2xiYXJDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgaW5kZXgsXG4gICAgcmVuZGVyLFxuICAgIGFyaWFQcm9wTmFtZSxcbiAgICBkaXNhYmxlZCxcbiAgICBleGNsdWRlLFxuICAgIG9uUHJlc3NTeW5jLFxuICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgZm9jdXNTZWxmLFxuICAgIGdldFNvcnRWYWx1ZSxcbiAgICBoaWRkZW4sXG4gICAgZ2V0VGV4dFxufTogVG9vbGJhckNoaWxkUHJvcHM8VG9vbGJhckNoaWxkRWxlbWVudCwgVXNlVG9vbGJhclN1YkluZm88VG9vbGJhckNoaWxkRWxlbWVudD4+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGNvbnRleHQgPSAodXNlQ29udGV4dChUb29sYmFyQ29udGV4dCkgYXMgVXNlVG9vbGJhckNvbnRleHQ8YW55LCBUb29sYmFyQ2hpbGRFbGVtZW50LCBVc2VUb29sYmFyU3ViSW5mbzxUb29sYmFyQ2hpbGRFbGVtZW50Pj4pO1xuICAgIGNvbnN0IGZvY3VzU2VsZkRlZmF1bHQgPSB1c2VDYWxsYmFjaygoZTogYW55KSA9PiB7IGU/LmZvY3VzKCk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGluZm8gPSB1c2VUb29sYmFyQ2hpbGQ8VG9vbGJhckNoaWxkRWxlbWVudD4oe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICAvL2NvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHN1YkluZm8sXG4gICAgICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHt9LFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZSwgZm9jdXNTZWxmOiBmb2N1c1NlbGYgPz8gZm9jdXNTZWxmRGVmYXVsdCwgb25QcmVzc1N5bmMgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczogeyBoaWRkZW46IGhpZGRlbiA/PyBmYWxzZSB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVyczogeyBnZXRTb3J0VmFsdWUgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IGFyaWFQcm9wTmFtZSwgc2VsZWN0aW9uTW9kZSwgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlIH0sXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogeyBnZXRUZXh0OiB1c2VEZWZhdWx0KFwiZ2V0VGV4dFwiLCBnZXRUZXh0KSB9LFxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+e3JlbmRlcihpbmZvKX08Lz5cbiAgICApXG59KVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyVG9vbGJhcjxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZVRvb2xiYXJTdWJJbmZvPENoaWxkRWxlbWVudD4+KHsgbWFrZVByb3BzQ29udGFpbmVyLCB0YWdDb250YWluZXIgfTogeyB0YWdDb250YWluZXI6IEVsZW1lbnRUb1RhZzxDb250YWluZXJFbGVtZW50PiwgbWFrZVByb3BzQ29udGFpbmVyOiAoaW5mbzogVXNlVG9vbGJhclJldHVyblR5cGU8Q29udGFpbmVyRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlVG9vbGJhclJldHVyblR5cGU8Q29udGFpbmVyRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPik6IFZOb2RlPGFueT4ge1xuICAgICAgICBjb25zdCBsaXN0ID0gY3JlYXRlRWxlbWVudCh0YWdDb250YWluZXIgYXMgbmV2ZXIsIG1ha2VQcm9wc0NvbnRhaW5lcihpbmZvKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIHtsaXN0fVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUb29sYmFyQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZVRvb2xiYXJTdWJJbmZvPENoaWxkRWxlbWVudD4+KHsgbWFrZVByb3BzQ2hpbGQsIHRhZ0NoaWxkIH06IHsgdGFnQ2hpbGQ6IEVsZW1lbnRUb1RhZzxDaGlsZEVsZW1lbnQ+LCBtYWtlUHJvcHNDaGlsZDogKGluZm86IFVzZVRvb2xiYXJDaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50LCBNPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUb29sYmFyQ2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudCwgTT4pOiBWTm9kZTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnQ2hpbGQgYXMgbmV2ZXIsIG1ha2VQcm9wc0NoaWxkKGluZm8pKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwiLi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZVRvb2x0aXAsIFVzZVRvb2x0aXBQYXJhbWV0ZXJzLCBVc2VUb29sdGlwUmV0dXJuVHlwZSB9IGZyb20gXCIuLi91c2UtdG9vbHRpcFwiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlclBvcnRhbCB9IGZyb20gXCIuL2RpYWxvZ1wiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYgfSBmcm9tIFwiLi91dGlsXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbHRpcFByb3BzPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudCwgUG9wdXBUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUb29sdGlwUGFyYW1ldGVycyB7XG4gICAgcmVuZGVyKGluZm86IFVzZVRvb2x0aXBSZXR1cm5UeXBlPFRyaWdnZXJUeXBlLCBQb3B1cFR5cGU+KTogVk5vZGU7XG4gICAgcmVmPzogUmVmPFVzZVRvb2x0aXBSZXR1cm5UeXBlPFRyaWdnZXJUeXBlLCBQb3B1cFR5cGU+Pjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUb29sdGlwPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudCwgUG9wdXBUeXBlIGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUb29sdGlwLCB0YWdUcmlnZ2VyLCBtYWtlVG9vbHRpcFByb3BzLCBtYWtlVHJpZ2dlclByb3BzLCBwb3J0YWxJZCB9OiB7IHBvcnRhbElkOiBzdHJpbmcsIHRhZ1RyaWdnZXI6IEVsZW1lbnRUb1RhZzxUcmlnZ2VyVHlwZT4sIHRhZ1Rvb2x0aXA6IEVsZW1lbnRUb1RhZzxQb3B1cFR5cGU+LCBtYWtlVHJpZ2dlclByb3BzOiAoaW5mbzogVXNlVG9vbHRpcFJldHVyblR5cGU8VHJpZ2dlclR5cGUsIFBvcHVwVHlwZT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPiwgbWFrZVRvb2x0aXBQcm9wczogKGluZm86IFVzZVRvb2x0aXBSZXR1cm5UeXBlPFRyaWdnZXJUeXBlLCBQb3B1cFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQb3B1cFR5cGU+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVRvb2x0aXBSZXR1cm5UeXBlPFRyaWdnZXJUeXBlLCBQb3B1cFR5cGU+KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ1RyaWdnZXIgYXMgbmV2ZXIsIG1ha2VUcmlnZ2VyUHJvcHMoaW5mbykpfVxuICAgICAgICAgICAgICAgIHtkZWZhdWx0UmVuZGVyUG9ydGFsKHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydGFsSWQsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjcmVhdGVFbGVtZW50KHRhZ1Rvb2x0aXAgYXMgbmV2ZXIsIG1ha2VUb29sdGlwUHJvcHMoaW5mbykpXG4gICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFRvb2x0aXAgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBUb29sdGlwVTxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQsIFBvcHVwVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgZm9jdXNEZWxheSwgbW91c2VvdXRUb2xlcmFuY2VEZWxheSwgbW91c2VvdmVyRGVsYXksIHJlbmRlciB9OiBUb29sdGlwUHJvcHM8VHJpZ2dlclR5cGUsIFBvcHVwVHlwZT4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgaW5mbyA9IHVzZVRvb2x0aXA8VHJpZ2dlclR5cGUsIFBvcHVwVHlwZT4oeyBmb2N1c0RlbGF5LCBtb3VzZW91dFRvbGVyYW5jZURlbGF5LCBtb3VzZW92ZXJEZWxheSB9KTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pO1xuICAgIHJldHVybiByZW5kZXIoaW5mbyk7XG59KVxuXG4iLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGxdLCJuYW1lcyI6WyJzbGljZSIsIm9wdGlvbnMiLCJ2bm9kZUlkIiwicmVyZW5kZXJRdWV1ZSIsInByZXZEZWJvdW5jZSIsImkiLCJFTVBUWV9PQkoiLCJFTVBUWV9BUlIiLCJJU19OT05fRElNRU5TSU9OQUwiLCJhc3NpZ24iLCJvYmoiLCJwcm9wcyIsInJlbW92ZU5vZGUiLCJub2RlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY3JlYXRlRWxlbWVudCIsInR5cGUiLCJjaGlsZHJlbiIsImtleSIsInJlZiIsIm5vcm1hbGl6ZWRQcm9wcyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNhbGwiLCJkZWZhdWx0UHJvcHMiLCJ1bmRlZmluZWQiLCJjcmVhdGVWTm9kZSIsIm9yaWdpbmFsIiwidm5vZGUiLCJfX2siLCJfXyIsIl9fYiIsIl9fZSIsIl9fZCIsIl9fYyIsIl9faCIsImNvbnN0cnVjdG9yIiwiX192IiwiRnJhZ21lbnQiLCJDb21wb25lbnQiLCJjb250ZXh0IiwidGhpcyIsImdldERvbVNpYmxpbmciLCJjaGlsZEluZGV4IiwiaW5kZXhPZiIsInNpYmxpbmciLCJ1cGRhdGVQYXJlbnREb21Qb2ludGVycyIsImNoaWxkIiwiYmFzZSIsImVucXVldWVSZW5kZXIiLCJjIiwicHVzaCIsInByb2Nlc3MiLCJkZWJvdW5jZVJlbmRlcmluZyIsInNldFRpbWVvdXQiLCJxdWV1ZSIsIl9fciIsInNvcnQiLCJhIiwiYiIsInNvbWUiLCJjb21wb25lbnQiLCJjb21taXRRdWV1ZSIsIm9sZFZOb2RlIiwib2xkRG9tIiwicGFyZW50RG9tIiwiX19QIiwiZGlmZiIsIm93bmVyU1ZHRWxlbWVudCIsImNvbW1pdFJvb3QiLCJkaWZmQ2hpbGRyZW4iLCJyZW5kZXJSZXN1bHQiLCJuZXdQYXJlbnRWTm9kZSIsIm9sZFBhcmVudFZOb2RlIiwiZ2xvYmFsQ29udGV4dCIsImlzU3ZnIiwiZXhjZXNzRG9tQ2hpbGRyZW4iLCJpc0h5ZHJhdGluZyIsImoiLCJjaGlsZFZOb2RlIiwibmV3RG9tIiwiZmlyc3RDaGlsZERvbSIsInJlZnMiLCJvbGRDaGlsZHJlbiIsIm9sZENoaWxkcmVuTGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwicmVvcmRlckNoaWxkcmVuIiwicGxhY2VDaGlsZCIsInVubW91bnQiLCJhcHBseVJlZiIsInRtcCIsInRvQ2hpbGRBcnJheSIsIm91dCIsIm5leHREb20iLCJzaWJEb20iLCJvdXRlciIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJpbnNlcnRCZWZvcmUiLCJkaWZmUHJvcHMiLCJkb20iLCJuZXdQcm9wcyIsIm9sZFByb3BzIiwiaHlkcmF0ZSIsInNldFByb3BlcnR5Iiwic2V0U3R5bGUiLCJzdHlsZSIsInZhbHVlIiwidGVzdCIsIm5hbWUiLCJvbGRWYWx1ZSIsInVzZUNhcHR1cmUiLCJvIiwiY3NzVGV4dCIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsImwiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnRQcm94eUNhcHR1cmUiLCJldmVudFByb3h5IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJldmVudCIsIm5ld1ZOb2RlIiwiaXNOZXciLCJvbGRTdGF0ZSIsInNuYXBzaG90IiwiY2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uIiwicHJvdmlkZXIiLCJjb21wb25lbnRDb250ZXh0IiwicmVuZGVySG9vayIsImNvdW50IiwibmV3VHlwZSIsImNvbnRleHRUeXBlIiwiX19FIiwicHJvdG90eXBlIiwicmVuZGVyIiwiZG9SZW5kZXIiLCJzdWIiLCJzdGF0ZSIsIl9zYiIsIl9fcyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImNvbXBvbmVudFdpbGxNb3VudCIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImZvckVhY2giLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiZ2V0Q2hpbGRDb250ZXh0IiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJkaWZmRWxlbWVudE5vZGVzIiwiZGlmZmVkIiwicm9vdCIsImNiIiwib2xkSHRtbCIsIm5ld0h0bWwiLCJub2RlVHlwZSIsImxvY2FsTmFtZSIsImRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJjcmVhdGVFbGVtZW50TlMiLCJpcyIsImRhdGEiLCJjaGlsZE5vZGVzIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJhdHRyaWJ1dGVzIiwiX19odG1sIiwiaW5uZXJIVE1MIiwiY2hlY2tlZCIsImN1cnJlbnQiLCJwYXJlbnRWTm9kZSIsInNraXBSZW1vdmUiLCJyIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZXBsYWNlTm9kZSIsImZpcnN0Q2hpbGQiLCJjcmVhdGVDb250ZXh0IiwiZGVmYXVsdFZhbHVlIiwiY29udGV4dElkIiwiQ29uc3VtZXIiLCJjb250ZXh0VmFsdWUiLCJQcm92aWRlciIsInN1YnMiLCJjdHgiLCJfcHJvcHMiLCJvbGQiLCJzcGxpY2UiLCJlcnJvciIsImVycm9ySW5mbyIsImN0b3IiLCJoYW5kbGVkIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwic2V0U3RhdGUiLCJjb21wb25lbnREaWRDYXRjaCIsInVwZGF0ZSIsImNhbGxiYWNrIiwicyIsImZvcmNlVXBkYXRlIiwiX19zZWxmIiwiX19zb3VyY2UiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50Q29tcG9uZW50IiwicHJldmlvdXNDb21wb25lbnQiLCJwcmV2UmFmIiwiY3VycmVudEhvb2siLCJhZnRlclBhaW50RWZmZWN0cyIsIkVNUFRZIiwib2xkQmVmb3JlRGlmZiIsIm9sZEJlZm9yZVJlbmRlciIsIm9sZEFmdGVyRGlmZiIsIm9sZENvbW1pdCIsIm9sZEJlZm9yZVVubW91bnQiLCJnZXRIb29rU3RhdGUiLCJpbmRleCIsImhvb2tzIiwiX19IIiwiX19WIiwidXNlU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJ1c2VSZWR1Y2VyIiwiaW52b2tlT3JSZXR1cm4iLCJyZWR1Y2VyIiwiaW5pdCIsImhvb2tTdGF0ZSIsIl9yZWR1Y2VyIiwiYWN0aW9uIiwiY3VycmVudFZhbHVlIiwiX19OIiwibmV4dFZhbHVlIiwiX2hhc1NjdUZyb21Ib29rcyIsInByZXZTY3UiLCJwIiwic3RhdGVIb29rcyIsImZpbHRlciIsIngiLCJldmVyeSIsInNob3VsZFVwZGF0ZSIsImhvb2tJdGVtIiwidXNlRWZmZWN0IiwiYXJncyIsImFyZ3NDaGFuZ2VkIiwiX3BlbmRpbmdBcmdzIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlUmVmIiwiaW5pdGlhbFZhbHVlIiwidXNlTWVtbyIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJjcmVhdGVIYW5kbGUiLCJjb25jYXQiLCJmYWN0b3J5IiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlSWQiLCJfX20iLCJtYXNrIiwiZmx1c2hBZnRlclBhaW50RWZmZWN0cyIsInNoaWZ0IiwiaW52b2tlQ2xlYW51cCIsImludm9rZUVmZmVjdCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFmdGVyTmV4dEZyYW1lIiwiaGFzRXJyb3JlZCIsIkhBU19SQUYiLCJyYWYiLCJkb25lIiwiY2xlYXJUaW1lb3V0IiwidGltZW91dCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaG9vayIsImNvbXAiLCJjbGVhbnVwIiwib2xkQXJncyIsIm5ld0FyZ3MiLCJhcmciLCJmIiwic2hhbGxvd0RpZmZlcnMiLCJQdXJlQ29tcG9uZW50IiwibWVtbyIsImNvbXBhcmVyIiwibmV4dFByb3BzIiwidXBkYXRlUmVmIiwiTWVtb2VkIiwiZGlzcGxheU5hbWUiLCJpc1JlYWN0Q29tcG9uZW50IiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJvbGREaWZmSG9vayIsIl9fZiIsIlJFQUNUX0ZPUldBUkRfU1lNQk9MIiwiU3ltYm9sIiwiZm9yIiwiZm9yd2FyZFJlZiIsImZuIiwiRm9yd2FyZGVkIiwiY2xvbmUiLCIkJHR5cGVvZiIsIm9sZENhdGNoRXJyb3IiLCJ0aGVuIiwib2xkVW5tb3VudCIsImRldGFjaGVkQ2xvbmUiLCJkZXRhY2hlZFBhcmVudCIsImVmZmVjdCIsIm1hcCIsInJlbW92ZU9yaWdpbmFsIiwib3JpZ2luYWxQYXJlbnQiLCJTdXNwZW5zZSIsIl9fdSIsIl9zdXNwZW5kZXJzIiwic3VzcGVuZGVkIiwiX19hIiwiU3VzcGVuc2VMaXN0IiwiX25leHQiLCJfbWFwIiwiX19SIiwicHJvbWlzZSIsInN1c3BlbmRpbmdWTm9kZSIsInN1c3BlbmRpbmdDb21wb25lbnQiLCJyZXNvbHZlIiwicmVzb2x2ZWQiLCJvblJlc29sdmVkIiwib25TdXNwZW5zaW9uQ29tcGxldGUiLCJzdXNwZW5kZWRWTm9kZSIsInBvcCIsIndhc0h5ZHJhdGluZyIsImRldGFjaGVkQ29tcG9uZW50IiwiX19PIiwiZmFsbGJhY2siLCJsaXN0IiwiZGVsZXRlIiwicmV2ZWFsT3JkZXIiLCJzaXplIiwiQ29udGV4dFByb3ZpZGVyIiwiUG9ydGFsIiwiX3RoaXMiLCJjb250YWluZXIiLCJfY29udGFpbmVyIiwiX3RlbXAiLCJiZWZvcmUiLCJjcmVhdGVQb3J0YWwiLCJlbCIsImNvbnRhaW5lckluZm8iLCJkZWxlZ2F0ZWQiLCJnZXQiLCJ1bnN1c3BlbmQiLCJ3cmFwcGVkVW5zdXNwZW5kIiwiTWFwIiwicmV2ZXJzZSIsInNldCIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIkNBTUVMX1BST1BTIiwiSVNfRE9NIiwib25DaGFuZ2VJbnB1dFR5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsInYiLCJ3cml0YWJsZSIsIm9sZEV2ZW50SG9vayIsImVtcHR5IiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJjYW5jZWxCdWJibGUiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJkZWZhdWx0UHJldmVudGVkIiwicGVyc2lzdCIsIm5hdGl2ZUV2ZW50IiwiY2xhc3NOYW1lRGVzY3JpcHRvciIsImNsYXNzIiwib2xkVk5vZGVIb29rIiwibm9uQ3VzdG9tRWxlbWVudCIsIm11bHRpcGxlIiwic2VsZWN0ZWQiLCJjbGFzc05hbWUiLCJlbnVtZXJhYmxlIiwiX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJFdmVudERldGFpbCIsImVuaGFuY2VFdmVudCIsImRldGFpbCIsImFscmVhZHlXYXJuZWQiLCJTZXQiLCJvdmVyd3JpdGVXaXRoV2FybmluZyIsImNvbXBvbmVudE5hbWUiLCJwcm9wTmFtZSIsIm5ld1ZhbHVlIiwiaGFzIiwiU3RyaW5nIiwiYWRkIiwiY29uc29sZSIsIndhcm4iLCJkZWJ1ZyIsInNldERlYnVnTG9nZ2luZyIsImxvZ2dpbmciLCJkZWJ1Z0xvZyIsIndobyIsIm5vb3AiLCJQcmVmaWNlcyIsImFjY29yZGlvblNlY3Rpb25IZWFkZXJCdXR0b24iLCJhY2NvcmRpb25TZWN0aW9uQm9keSIsImNoZWNrYm94TGlrZUlucHV0IiwiY2hlY2tib3hMaWtlTGFiZWwiLCJkaWFsb2ciLCJkaWFsb2dUaXRsZSIsImRyYXdlciIsImRyYXdlclRpdGxlIiwiZ3JpZGxpc3QiLCJncmlkbGlzdExhYmVsIiwibGlzdGJveCIsImxpc3Rib3hMYWJlbCIsIm1lbnUiLCJwcm9ncmVzc0luZGljYXRvciIsInByb2dyZXNzTGFiZWwiLCJyYWRpb0dyb3VwIiwicmFkaW9Hcm91cExhYmVsIiwicmFkaW8iLCJyYWRpb0xhYmVsIiwic2xpZGVyVGh1bWIiLCJ0YWJsZSIsInRhYmxlTGFiZWwiLCJ0YWJsaXN0IiwidGFibGlzdExhYmVsIiwidG9vbHRpcCIsIkhlYWRpbmdMZXZlbENvbnRleHQiLCJIZWFkaW5nIiwiaGVhZGluZyIsInRhZyIsImhlYWRpbmdMZXZlbEJlZm9yZVVzIiwibmV3SGVhZGluZ0xldmVsIiwiX2pzeCIsIl9GcmFnbWVudCIsIl9qc3hzIiwiSGVhZGluZ1Jlc2V0IiwibmV3TGV2ZWwiLCJ1c2VFbnN1cmVTdGFiaWxpdHkiLCJwYXJlbnRIb29rTmFtZSIsInZhbHVlcyIsImhlbHBlclRvRW5zdXJlU3RhYmlsaXR5Iiwic2hvd25FcnJvciIsInVzZUhlbHBlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1c2VQYXNzaXZlU3RhdGUiLCJvbkNoYW5nZSIsImdldEluaXRpYWxWYWx1ZSIsImN1c3RvbURlYm91bmNlUmVuZGVyaW5nIiwidmFsdWVSZWYiLCJVbnNldCIsInJlYXNvblJlZiIsIndhcm5pbmdSZWYiLCJkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdCIsImNsZWFudXBDYWxsYmFja1JlZiIsIm9uU2hvdWxkQ2xlYW5VcCIsImNsZWFudXBDYWxsYmFjayIsInRyeUVuc3VyZVZhbHVlIiwiZXgiLCJnZXRWYWx1ZSIsInNldFZhbHVlIiwicmVhc29uIiwiRnVuY3Rpb24iLCJuZXh0UmVhc29uIiwibmV4dERlcCIsInByZXZEZXAiLCJyZXR1cm5UcnVlIiwicmV0dXJuRmFsc2UiLCJyZXR1cm5OdWxsIiwicmV0dXJuWmVybyIsImlkZW50aXR5IiwidCIsInJ1bkltbWVkaWF0ZWx5IiwiYWN0aXZlRWxlbWVudFVwZGF0ZXJzIiwibGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyIsIndpbmRvd0ZvY3VzZWRVcGRhdGVycyIsIndpbmRvd3NGb2N1c2VkVXBkYXRlcnMiLCJmb3JFYWNoVXBkYXRlciIsIndpbmRvdyIsInVwZGF0ZXJzIiwidXBkYXRlciIsImxhc3RTZW50Iiwic2VuZCIsImZvY3Vzb3V0IiwidGFyZ2V0Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwicmVsYXRlZFRhcmdldCIsImZvY3VzaW4iLCJjdXJyZW50bHlGb2N1c2VkRWxlbWVudCIsIndpbmRvd0ZvY3VzIiwiV2luZG93IiwiY3VycmVudFRhcmdldCIsIndpbmRvd0JsdXIiLCJ1c2VBY3RpdmVFbGVtZW50IiwiYWN0aXZlRWxlbWVudFBhcmFtZXRlcnMiLCJvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UiLCJvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlIiwib25XaW5kb3dGb2N1c2VkQ2hhbmdlIiwiZ2V0RG9jdW1lbnQiLCJnZXRXaW5kb3ciLCJwYXNzaXZlIiwibG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMiLCJsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMiLCJsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyIsImxhZXUiLCJzZXRBY3RpdmVFbGVtZW50IiwibGxhZXUiLCJzZXRMYXN0QWN0aXZlRWxlbWVudCIsImx3ZnUiLCJzZXRXaW5kb3dGb2N1c2VkIiwiZ2V0QWN0aXZlRWxlbWVudCIsImdldExhc3RBY3RpdmVFbGVtZW50IiwiZ2V0V2luZG93Rm9jdXNlZCIsImFjdGl2ZUVsZW1lbnRSZXR1cm4iLCJUYWJsZSIsImJhc2U2NCIsInJhbmRvbTZCaXRzIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicmFuZG9tNjRCaXRzIiwiZ2VuZXJhdGVSYW5kb21JZCIsInByZWZpeCIsIm4iLCJqb2luIiwicHJldmlvdXNJbnB1dHMiLCJ0b1J1biIsImNvbW1pdE5hbWUiLCJvcmlnaW5hbENvbW1pdCIsIm5ld0NvbW1pdCIsImlkIiwiZWZmZWN0SW5mbyIsIm9sZElucHV0cyIsImlucHV0cyIsImNsZWFyIiwidXNlQmVmb3JlTGF5b3V0RWZmZWN0IiwidXNlU3RhYmxlR2V0dGVyIiwiRXJyb3IiLCJ1c2VTdGFibGVPYmplY3QiLCJlbnRyaWVzIiwiX2siLCJXZWFrTWFwIiwiaXNTdGFibGVHZXR0ZXIiLCJzZXRJc1N0YWJsZUdldHRlciIsInVzZVN0YWJsZUNhbGxiYWNrIiwibm9EZXBzIiwiY3VycmVudENhbGxiYWNrR2V0dGVyIiwidXNlQ2FsbGJhY2tOYXRpdmUiLCJhc3NlcnQiLCJ1c2VNYW5hZ2VkQ2hpbGRyZW4iLCJwYXJlbnRQYXJhbWV0ZXJzIiwibWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyIsIm9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCIsIm9uQ2hpbGRyZW5Nb3VudENoYW5nZSIsInJlc3QiLCJnZXRIaWdoZXN0SW5kZXgiLCJtYW5hZ2VkQ2hpbGRyZW5BcnJheSIsImhpZ2hlc3RJbmRleCIsImFyciIsInJlYyIsImxvd2VzdEluZGV4IiwiZm9yRWFjaENoaWxkIiwiZmllbGQiLCJnZXRNYW5hZ2VkQ2hpbGRJbmZvIiwiaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkIiwicmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyIsInJlbW90ZVVMRUNoaWxkQ2hhbmdlZCIsInJlbW90ZVVMRUNoaWxkTW91bnRlZCIsIm1vdW50ZWQiLCJtb3VudHMiLCJ1bm1vdW50cyIsIm1heCIsInNoYXZlIiwibWFuYWdlZENoaWxkcmVuIiwiXyIsImdldEF0IiwiYXJyYXlTbGljZSIsImdldENoaWxkcmVuIiwibWFuYWdlZENoaWxkQ29udGV4dCIsIm1hbmFnZWRDaGlsZHJlblJldHVybiIsInVzZU1hbmFnZWRDaGlsZCIsImluZm8iLCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIiwiZmxhdCIsIm1hbmFnZWRDaGlsZFJldHVybiIsInVzZUNoaWxkcmVuRmxhZyIsImluaXRpYWxJbmRleCIsImNsb3Nlc3RGaXQiLCJvbkluZGV4Q2hhbmdlIiwic2V0QXQiLCJpc1ZhbGlkIiwiZ2V0Q3VycmVudEluZGV4Iiwic2V0Q3VycmVudEluZGV4IiwiZ2V0UmVxdWVzdGVkSW5kZXgiLCJzZXRSZXF1ZXN0ZWRJbmRleCIsImdldENsb3Nlc3RGaXQiLCJyZXF1ZXN0ZWRJbmRleCIsImNsb3Nlc3REaXN0YW5jZSIsIkluZmluaXR5IiwiY2xvc2VzdEluZGV4IiwibmV3RGlzdGFuY2UiLCJhYnMiLCJyZWV2YWx1YXRlQ2xvc2VzdEZpdCIsImN1cnJlbnRDaGlsZCIsImNsb3Nlc3RGaXRJbmRleCIsImNsb3Nlc3RGaXRDaGlsZCIsImNoYW5nZUluZGV4IiwibmV3TWF0Y2hpbmdDaGlsZCIsIm9sZE1hdGNoaW5nQ2hpbGQiLCJ1c2VNZXJnZWRDaGlsZHJlbiIsImxocyIsInJocyIsImNsc3giLCJ1c2VNZXJnZWRDbGFzc2VzIiwibGhzQ2xhc3MiLCJsaHNDbGFzc05hbWUiLCJyaHNDbGFzcyIsInJoc0NsYXNzTmFtZSIsImxoc0NsYXNzZXMiLCJzcGxpdCIsInJoc0NsYXNzZXMiLCJhbGxDbGFzc2VzIiwiZnJvbSIsInByb2Nlc3NSZWYiLCJpbnN0YW5jZSIsInVzZU1lcmdlZFJlZnMiLCJjb21iaW5lZCIsInN0eWxlU3RyaW5nVG9PYmplY3QiLCJmcm9tRW50cmllcyIsInN0YXRlbWVudCIsInVzZU1lcmdlZFN0eWxlcyIsImxvZyIsInVzZU1lcmdlZFByb3BzIiwiYWxsUHJvcHMiLCJyZXQiLCJ1c2VNZXJnZWRQcm9wczIiLCJrbm93bnMiLCJtZXJnZVVua25vd24iLCJsaHNWYWx1ZSIsInJoc1ZhbHVlIiwibWVyZ2VkIiwibWVyZ2VGdW5jdGlvbnMiLCJsaHNBbGwiLCJyaHNBbGwiLCJsaHNLZXlVIiwibGhzS2V5IiwicmhzS2V5VSIsInJoc0tleSIsImx2IiwicnYiLCJQcm9taXNlIiwiYWxsIiwidXNlR2xvYmFsSGFuZGxlciIsImhhbmRsZXIiLCJzdGFibGVIYW5kbGVyIiwidXNlUmVmRWxlbWVudCIsInJlZkVsZW1lbnRQYXJhbWV0ZXJzIiwib25FbGVtZW50Q2hhbmdlIiwib25Nb3VudCIsIm9uVW5tb3VudCIsInByZXZWYWx1ZSIsImdldEVsZW1lbnQiLCJzZXRFbGVtZW50IiwicHJvcHNTdGFibGUiLCJyZWZFbGVtZW50UmV0dXJuIiwiTWFnaWNXaW5kb3dLZXkiLCJnZXRFbGVtZW50RGVwdGgiLCJlbGVtZW50IiwiZGVwdGgiLCJwYXJlbnQiLCJwYXJlbnRFbGVtZW50IiwidXNlRXNjYXBlRGlzbWlzcyIsImVzY2FwZURpc21pc3NQYXJhbWV0ZXJzIiwib25DbG9zZSIsIm9wZW4iLCJ1bnN0YWJsZUdldFdpbmRvdyIsInBhcmVudERlcHRoIiwicmVmRWxlbWVudFBvcHVwUmV0dXJuIiwidm9pZDEiLCJ2b2lkMiIsInN0YWJsZU9uQ2xvc2UiLCJnZXREZXB0aCIsIm1pY3JvdGFza1F1ZXVlZCIsImVsZW1lbnRRdWV1ZSIsImNhcHR1cmUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIm9uQ2xvc2UyIiwidHJlZURlcHRoIiwiZGVlcGVzdERlcHRoIiwiZGVlcGVzdFRyZWVEZXB0aCIsImRlZXBlc3RPbkNsb3NlIiwidGllQnJva2VuIiwidXNlTG9zdEZvY3VzRGlzbWlzcyIsImdldFBvcHVwRWxlbWVudCIsInJlZkVsZW1lbnRTb3VyY2VSZXR1cm4iLCJsb3N0Rm9jdXNEaXNtaXNzIiwidm9pZDMiLCJnZXRTb3VyY2VFbGVtZW50IiwiZ2V0T3BlbiIsIm5ld0VsZW1lbnQiLCJfcHJldkVsZW1lbnQiLCJfZSIsInNvdXJjZUVsZW1lbnQiLCJwb3B1cEVsZW1lbnQiLCJjb250YWlucyIsInVzZUJhY2tkcm9wRGlzbWlzcyIsImJhY2tkcm9wRGlzbWlzc1BhcmFtZXRlcnMiLCJvbkNsb3NlVW5zdGFibGUiLCJvbkJhY2tkcm9wQ2xpY2siLCJmb3VuZEluc2lkZUNsaWNrIiwidXNlRGlzbWlzcyIsImRpc21pc3NQYXJhbWV0ZXJzIiwiZ2xvYmFsT3BlbiIsImdsb2JhbE9uQ2xvc2UiLCJjbG9zZU9uQmFja2Ryb3AiLCJjbG9zZU9uRXNjYXBlIiwiY2xvc2VPbkxvc3RGb2N1cyIsIm9uQ2xvc2VCYWNrZHJvcCIsIm9uQ2xvc2VFc2NhcGUiLCJvbkNsb3NlRm9jdXMiLCJjYW5kaWRhdGVTZWxlY3RvcnMiLCJOb0VsZW1lbnQiLCJFbGVtZW50IiwibWF0Y2hlcyIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiZ2V0Um9vdE5vZGUiLCJpc0lucHV0IiwidGFnTmFtZSIsImlzSGlkZGVuSW5wdXQiLCJpc0RldGFpbHNXaXRoU3VtbWFyeSIsImFwcGx5IiwiaXNOb2RlQXR0YWNoZWQiLCJfbm9kZVJvb3RIb3N0Iiwibm9kZVJvb3RIb3N0IiwiaG9zdCIsImF0dGFjaGVkIiwiX25vZGVSb290SG9zdDIiLCJpc1plcm9BcmVhIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJpc0hpZGRlbiIsIl9yZWYiLCJkaXNwbGF5Q2hlY2siLCJnZXRTaGFkb3dSb290IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInZpc2liaWxpdHkiLCJpc0RpcmVjdFN1bW1hcnkiLCJub2RlVW5kZXJEZXRhaWxzIiwib3JpZ2luYWxOb2RlIiwicm9vdE5vZGUiLCJzaGFkb3dSb290IiwiYXNzaWduZWRTbG90IiwiZ2V0Q2xpZW50UmVjdHMiLCJpc0Rpc2FibGVkRnJvbUZpZWxkc2V0IiwiZGlzYWJsZWQiLCJpdGVtIiwiaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSIsImZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yIiwiaXNGb2N1c2FibGUiLCJnbG9iYWwiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsYXNzQ2FsbENoZWNrIiwiVHlwZUVycm9yIiwiX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nIiwiSW5lcnRSb290Iiwicm9vdEVsZW1lbnQiLCJpbmVydE1hbmFnZXIiLCJfaW5lcnRNYW5hZ2VyIiwiX3Jvb3RFbGVtZW50IiwiX21hbmFnZWROb2RlcyIsImhhc0F0dHJpYnV0ZSIsIl9zYXZlZEFyaWFIaWRkZW4iLCJnZXRBdHRyaWJ1dGUiLCJfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSIsIl9vYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJfb25NdXRhdGlvbiIsImJpbmQiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImRlc3RydWN0b3IiLCJkaXNjb25uZWN0IiwiaW5lcnROb2RlIiwiX3VubWFuYWdlTm9kZSIsInN0YXJ0Tm9kZSIsIl90aGlzMiIsImNvbXBvc2VkVHJlZVdhbGsiLCJfdmlzaXROb2RlIiwiYWN0aXZlRWxlbWVudCIsImJvZHkiLCJOb2RlIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImJsdXIiLCJmb2N1cyIsIkVMRU1FTlRfTk9ERSIsIl9hZG9wdEluZXJ0Um9vdCIsIl9tYW5hZ2VOb2RlIiwicmVnaXN0ZXIiLCJkZXJlZ2lzdGVyIiwiX3VubWFuYWdlU3VidHJlZSIsIl90aGlzMyIsImluZXJ0U3Vicm9vdCIsImdldEluZXJ0Um9vdCIsInNldEluZXJ0IiwibWFuYWdlZE5vZGVzIiwic2F2ZWRJbmVydE5vZGUiLCJyZWNvcmRzIiwic2VsZiIsInJlY29yZCIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJhdHRyaWJ1dGVOYW1lIiwibWFuYWdlZE5vZGUiLCJhcmlhSGlkZGVuIiwiSW5lcnROb2RlIiwiaW5lcnRSb290IiwiX25vZGUiLCJfb3ZlcnJvZGVGb2N1c01ldGhvZCIsIl9pbmVydFJvb3RzIiwiX3NhdmVkVGFiSW5kZXgiLCJfZGVzdHJveWVkIiwiZW5zdXJlVW50YWJiYWJsZSIsIl90aHJvd0lmRGVzdHJveWVkIiwiZGVzdHJveWVkIiwidGFiSW5kZXgiLCJoYXNTYXZlZFRhYkluZGV4IiwiYWRkSW5lcnRSb290IiwicmVtb3ZlSW5lcnRSb290IiwiSW5lcnRNYW5hZ2VyIiwiX2RvY3VtZW50IiwiX3dhdGNoRm9ySW5lcnQiLCJhZGRJbmVydFN0eWxlIiwiaGVhZCIsImRvY3VtZW50RWxlbWVudCIsInJlYWR5U3RhdGUiLCJfb25Eb2N1bWVudExvYWRlZCIsImluZXJ0IiwiX2luZXJ0Um9vdCIsImluZXJ0RWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5lcnRFbGVtZW50IiwidW5zaGlmdCIsInNoYWRvd1Jvb3RBbmNlc3RvciIsImNvbnRlbnQiLCJkaXN0cmlidXRlZE5vZGVzIiwiZ2V0RGlzdHJpYnV0ZWROb2RlcyIsInNsb3QiLCJfZGlzdHJpYnV0ZWROb2RlcyIsImFzc2lnbmVkTm9kZXMiLCJmbGF0dGVuIiwiX2kiLCJxdWVyeVNlbGVjdG9yIiwidGV4dENvbnRlbnQiLCJIVE1MRWxlbWVudCIsImhhc093blByb3BlcnR5IiwiX2Jsb2NraW5nRWxlbWVudHMiLCJfYWxyZWFkeUluZXJ0RWxlbWVudHMiLCJfdG9wRWxQYXJlbnRzIiwiX3NpYmxpbmdzVG9SZXN0b3JlIiwiX3BhcmVudE1PIiwiX3RvcENoYW5nZWQiLCJfc3dhcEluZXJ0ZWRTaWJsaW5nIiwiX2luZXJ0U2libGluZ3MiLCJfcmVzdG9yZUluZXJ0ZWRTaWJsaW5ncyIsIl9nZXRQYXJlbnRzIiwiX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4iLCJfaXNJbmVydGFibGUiLCJfaGFuZGxlTXV0YXRpb25zIiwiQmxvY2tpbmdFbGVtZW50c0ltcGwiLCJfYSIsIl9iIiwiX2MiLCJudWxsYWJsZSIsInRvcCIsImVsZW1zIiwicmVtb3ZlIiwibmV3VG9wIiwidG9LZWVwSW5lcnQiLCJvbGRQYXJlbnRzIiwibmV3UGFyZW50cyIsInRvU2tpcCIsIm9sZEluZXJ0IiwibmV3SW5lcnQiLCJzaWJsaW5nc1RvUmVzdG9yZSIsImVsZW1lbnRzIiwibW8iLCJzaWJsaW5ncyIsImluZXJ0ZWRTaWJsaW5ncyIsInBhcmVudFRvT2JzZXJ2ZSIsIm1heWJlU2hhZHlSb290IiwiX19zaGFkeSIsIm11dGF0aW9ucyIsInBhcmVudHMiLCJtdXRhdGlvbiIsImlkeCIsImluZXJ0ZWRDaGlsZCIsInJlc3VsdCIsIm5vZGVzIiwic2xvdHMiLCIkYmxvY2tpbmdFbGVtZW50cyIsImdsb2JhbFRoaXMiLCJibG9ja2luZ0VsZW1lbnRzIiwidXNlQmxvY2tpbmdFbGVtZW50IiwiZW5hYmxlZCIsImdldFRhcmdldCIsInN0YWJsZUdldFRhcmdldCIsInNldExhc3RBY3RpdmVXaGVuT3BlbiIsInNldExhc3RBY3RpdmVXaGVuQ2xvc2VkIiwiZ2V0VG9wIiwic2V0VG9wIiwiZ2V0TGFzdEFjdGl2ZVdoZW5DbG9zZWQiLCJnZXRMYXN0QWN0aXZlV2hlbk9wZW4iLCJ1c2VGb2N1c1RyYXAiLCJmb2N1c1RyYXBQYXJhbWV0ZXJzIiwib25seU1vdmVGb2N1cyIsInRyYXBBY3RpdmUiLCJmb2N1c1BvcHVwIiwiZm9jdXNTZWxmVW5zdGFibGUiLCJmb2N1c09wZW5lciIsImZvY3VzT3BlbmVyVW5zdGFibGUiLCJmb2N1c1NlbGYiLCJmaW5kRmlyc3RGb2N1c2FibGUiLCJsYXN0QWN0aXZlIiwiZm9jdXNUcmFwUmV0dXJuIiwicHJvcHNVbnN0YWJsZSIsInRyZWVXYWxrZXIiLCJjcmVhdGVUcmVlV2Fsa2VyIiwiTm9kZUZpbHRlciIsIlNIT1dfRUxFTUVOVCIsImFjY2VwdE5vZGUiLCJGSUxURVJfQUNDRVBUIiwiRklMVEVSX1NLSVAiLCJmaXJzdEZvY3VzYWJsZSIsInVzZVRleHRDb250ZW50IiwidGV4dENvbnRlbnRQYXJhbWV0ZXJzIiwiZ2V0VGV4dCIsIm9uVGV4dENvbnRlbnRDaGFuZ2UiLCJnZXRUZXh0Q29udGVudCIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnRSZXR1cm4iLCJzZXRTdGF0ZVAiLCJ1c2VTdGF0ZVAiLCJnZXRTdGF0ZSIsImlzTmFOIiwidXNlTGluZWFyTmF2aWdhdGlvbiIsInJvdmluZ1RhYkluZGV4UmV0dXJuIiwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMiLCJpbmRleERlbWFuZ2xlciIsImluZGV4TWFuZ2xlciIsIm5hdmlnYXRlUGFzdEVuZCIsIm5hdmlnYXRlUGFzdFN0YXJ0IiwiZ2V0VGFiYmFibGVJbmRleCIsInNldFRhYmJhYmxlSW5kZXgiLCJuYXZpZ2F0ZUFic29sdXRlIiwiZnJvbVVzZXJJbnRlcmFjdGlvbiIsInRyeU5hdmlnYXRlVG9JbmRleCIsImhpZ2hlc3RDaGlsZEluZGV4Iiwic2VhcmNoRGlyZWN0aW9uIiwibmF2aWdhdGVUb0ZpcnN0IiwibmF2aWdhdGVUb0xhc3QiLCJuYXZpZ2F0ZVJlbGF0aXZlMiIsIm9mZnNldCIsIm1vZGUiLCJzdGF0dXMiLCJzaWduIiwibmF2aWdhdGVUb05leHQiLCJuYXZpZ2F0ZVRvUHJldiIsImdldERpc2FibGVBcnJvd0tleXMiLCJkaXNhYmxlQXJyb3dLZXlzIiwiZ2V0RGlzYWJsZUhvbWVFbmRLZXlzIiwiZGlzYWJsZUhvbWVFbmRLZXlzIiwiZ2V0TmF2aWdhdGlvbkRpcmVjdGlvbiIsIm5hdmlnYXRpb25EaXJlY3Rpb24iLCJnZXRQYWdlTmF2aWdhdGlvblNpemUiLCJwYWdlTmF2aWdhdGlvblNpemUiLCJzdGFibGVQcm9wcyIsIm9uS2V5RG93biIsImN0cmxLZXkiLCJtZXRhS2V5IiwiYWxsb3dzVmVydGljYWxOYXZpZ2F0aW9uIiwiYWxsb3dzSG9yaXpvbnRhbE5hdmlnYXRpb24iLCJ0cnVlUGFnZU5hdmlnYXRpb25TaXplIiwicm91bmQiLCJkaXJlY3Rpb25BbGxvd2VkIiwibGluZWFyTmF2aWdhdGlvblJldHVybiIsInVwcGVyIiwibG93ZXIiLCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uIiwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMiLCJjb2xsYXRvciIsInR5cGVhaGVhZFRpbWVvdXQiLCJub1R5cGVhaGVhZCIsImdldEluZGV4Iiwic2V0SW5kZXgiLCJfdm9pZDMiLCJfdm9pZDEiLCJfdm9pZDIiLCJnZXRDdXJyZW50VHlwZWFoZWFkIiwic2V0Q3VycmVudFR5cGVhaGVhZCIsImN1cnJlbnRUeXBlYWhlYWQiLCJwcmV2IiwiaGFuZGxlIiwic2V0SW52YWxpZFR5cGVhaGVhZCIsInVwZGF0ZUJhc2VkT25UeXBlYWhlYWRDaGFuZ2UiLCJzb3J0ZWRUeXBlYWhlYWRJbmZvIiwiaW52YWxpZFR5cGVhaGVhZCIsInNldEltZUFjdGl2ZSIsImdldEltZUFjdGl2ZSIsIm5leHRUeXBlYWhlYWRDaGFyIiwic2V0TmV4dFR5cGVhaGVhZENoYXIiLCJ0eXBlYWhlYWQiLCJjb21wYXJhdG9yU2hhcmVkIiwic2FmZUxocyIsInNhZmVSaHMiLCJjb21wYXJlIiwibm9ybWFsaXplIiwibG9jYWxlQ29tcGFyZSIsImluc2VydGluZ0NvbXBhcmF0b3IiLCJ0ZXh0IiwidHlwZWFoZWFkQ29tcGFyYXRvciIsInN1YnN0cmluZyIsImlzRGlzYWJsZWQiLCJpbWVBY3RpdmUiLCJpc0NoYXJhY3RlcktleSIsInRyaW0iLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwidHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCIsInR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMiLCJ0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuIiwic29ydGVkVHlwZWFoZWFkSW5kZXgiLCJiaW5hcnlTZWFyY2giLCJsb3dlc3RVbnNvcnRlZEluZGV4QWxsIiwibG93ZXN0U29ydGVkSW5kZXhBbGwiLCJsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCIsImxvd2VzdFNvcnRlZEluZGV4TmV4dCIsInVwZGF0ZUJlc3RGaXQiLCJ1IiwidW5zb3J0ZWRJbmRleCIsInVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCIsInZvaWQ1Iiwidm9pZDQiLCJzb3J0ZWRJbmRleCIsImFycmF5Iiwid2FudGVkIiwiY29tcGFyYXRvciIsImZpcnN0SW5kZXgiLCJsYXN0SW5kZXgiLCJ0ZXN0SW5kZXgiLCJjb21wYXJpc29uUmVzdWx0IiwidXNlUm92aW5nVGFiSW5kZXgiLCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMiLCJ1bnRhYmJhYmxlIiwiaW5pdGlhbGx5VGFiYmVkSW5kZXgiLCJvblRhYmJhYmxlSW5kZXhDaGFuZ2UiLCJzZXRUYWJiYWJsZUluZGV4MyIsInByZXZJbmRleCIsIm5leHRJbmRleCIsIm5leHRDaGlsZCIsImhpZGRlbiIsImxhc3ROb25OdWxsSW5kZXgiLCJnZXRUYWJiYWJsZUF0IiwibSIsImdldFRhYmJhYmxlIiwic2V0VGFiYmFibGVBdCIsInNldFRhYmJhYmxlIiwiaXNUYWJiYWJsZVZhbGlkIiwicm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQiLCJ1c2VSb3ZpbmdUYWJJbmRleENoaWxkIiwicm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMiLCJ0YWJiYWJsZSIsImhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMiLCJvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkIiwiZm9jdXNlZCIsIl9wcmV2Rm9jdXNlZCIsInJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4iLCJ1c2VMaXN0TmF2aWdhdGlvbiIsInJ0aXIiLCJ0bnIiLCJsbnIiLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkIiwicnRpY3IiLCJ1c2VHcmlkTmF2aWdhdGlvbiIsImdyaWROYXZpZ2F0aW9uUGFyYW1ldGVycyIsIm9uVGFiYmFibGVDb2x1bW5DaGFuZ2UiLCJnZXRDdXJyZW50VGFiYmFibGVDb2x1bW4iLCJzZXRDdXJyZW50VGFiYmFibGVDb2x1bW4iLCJvblRhYmJhYmxlSW5kZXhDaGFuZ2VPdmVycmlkZSIsInNldFRhYmJhYmxlQ29sdW1uSW5kZXgiLCJncmlkTmF2aWdhdGlvblJvd0NvbnRleHQiLCJncmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMiLCJzZXRUYWJiYWJsZVJvdyIsInVzZUdyaWROYXZpZ2F0aW9uUm93Iiwicm93QXNDaGlsZE9mR3JpZFBhcmFtZXRlcnMiLCJyb3dBc1BhcmVudE9mQ2VsbHNQYXJhbWV0ZXJzIiwiYXNDaGlsZFJvd09mVGFibGUiLCJhc1BhcmVudFJvd09mQ2VsbHNQIiwibG5jciIsInJvd0FzQ2hpbGRPZkdyaWRSZXR1cm4iLCJyb3dBc1BhcmVudE9mQ2VsbHNSZXR1cm4iLCJncmlkTmF2aWdhdGlvbkNlbGxDb250ZXh0IiwiZ3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVycyIsImdldFJvd0luZGV4Iiwic2V0VGFiYmFibGVDZWxsIiwidXNlR3JpZE5hdmlnYXRpb25DZWxsIiwiY29sU3BhbiIsIl9nZXRDdXJyZW50Q29sdW1uIiwib2NmaWMxIiwidXNlU2luZ2xlU2VsZWN0aW9uIiwic2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyIsInNldFNlbGVjdGVkSW5kZXgiLCJzZXRTZWxlY3RlZEluZGV4RXh0ZXJuYWwiLCJpbml0aWFsbHlTZWxlY3RlZEluZGV4IiwiZ2V0U2VsZWN0ZWRBdCIsImdldFNlbGVjdGVkIiwic2V0U2VsZWN0ZWRBdCIsInNldExvY2FsU2VsZWN0ZWQiLCJpc1NlbGVjdGVkVmFsaWQiLCJzZXRTZWxlY3RlZEluZGV4SW50ZXJuYWwiLCJnZXRTZWxlY3RlZEluZGV4Iiwic2luZ2xlU2VsZWN0aW9uUmV0dXJuIiwic2luZ2xlU2VsZWN0aW9uQ29udGV4dCIsImNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyIsIm9uQ29tcG9zaXRlRm9jdXNDaGFuZ2UiLCJhbnlGb2N1c2VkIiwic2VsZWN0ZWRJbmRleCIsInVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkIiwic2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzIiwiYXJpYVByb3BOYW1lIiwic2VsZWN0aW9uTW9kZSIsImdldERpc2FibGVkIiwic2V0U2VsZWN0ZWQiLCJfcHJldiIsIm9uUHJlc3NTeW5jIiwic2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm4iLCJzZXRUaGlzT25lU2VsZWN0ZWQiLCJ0b1N0cmluZyIsInByZXNzUGFyYW1ldGVycyIsInVzZVNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlIiwic2luZ2xlU2VsZWN0aW9uRGVjbGFyYXRpdmVQYXJhbWV0ZXJzIiwidXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb24iLCJnbnIiLCJzc3IiLCJ1c2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJvdyIsIm9jZmljMiIsInByZXZGb2N1c2VkIiwidXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DZWxsIiwiY29weUFycmF5Iiwic291cmNlIiwibmF0aXZlRmxvb3IiLCJuYXRpdmVSYW5kb20iLCJiYXNlUmFuZG9tIiwic2h1ZmZsZVNlbGYiLCJyYW5kIiwiYXJyYXlTaHVmZmxlIiwiYXJyYXlNYXAiLCJpdGVyYXRlZSIsImJhc2VWYWx1ZXMiLCJvYmplY3QiLCJiYXNlVGltZXMiLCJmcmVlR2xvYmFsIiwiZnJlZVNlbGYiLCJvYmplY3RQcm90byIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImdldFJhd1RhZyIsImlzT3duIiwidW5tYXNrZWQiLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJiYXNlR2V0VGFnIiwiaXNPYmplY3RMaWtlIiwiYXJnc1RhZyIsImJhc2VJc0FyZ3VtZW50cyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMiLCJzdHViRmFsc2UiLCJmcmVlRXhwb3J0cyIsImV4cG9ydHMiLCJmcmVlTW9kdWxlIiwibW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJpc0luZGV4IiwiaXNMZW5ndGgiLCJhcnJheVRhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJmdW5jVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwib2JqZWN0VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJ0eXBlZEFycmF5VGFncyIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkiLCJmdW5jIiwiZnJlZVByb2Nlc3MiLCJub2RlVXRpbCIsInR5cGVzIiwicmVxdWlyZSIsImJpbmRpbmciLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5IiwiYXJyYXlMaWtlS2V5cyIsImluaGVyaXRlZCIsImlzQXJyIiwiaXNBcmciLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsImlzUHJvdG90eXBlIiwiQ3RvciIsInByb3RvIiwib3ZlckFyZyIsInRyYW5zZm9ybSIsIm5hdGl2ZUtleXMiLCJrZXlzIiwiYmFzZUtleXMiLCJpc09iamVjdCIsImFzeW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwiaXNBcnJheUxpa2UiLCJiYXNlU2h1ZmZsZSIsImNvbGxlY3Rpb24iLCJzaHVmZmxlIiwidXNlRm9yY2VVcGRhdGUiLCJ1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW4iLCJyZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzIiwibWFuZ2xlTWFwIiwiZGVtYW5nbGVNYXAiLCJtYW5hZ2VkUm93cyIsInNodWZmbGVkUm93cyIsImxvZGFzaFNodWZmbGUiLCJyZWFycmFuZ2UiLCJnZXRGb3JjZVVwZGF0ZSIsInNldEZvcmNlVXBkYXRlIiwic29ydGVkUm93cyIsImluZGV4QXNTb3J0ZWQiLCJpbmRleEFzVW5zb3J0ZWQiLCJ1c2VSZWFycmFuZ2VkQ2hpbGRyZW4iLCJtYW5nbGVkSW5kZXgiLCJkZW1hbmdsZWRJbmRleCIsImgiLCJyZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4iLCJ1c2VTb3J0YWJsZUNoaWxkcmVuIiwic29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMiLCJ1c2VyQ29tcGFyZSIsImdldENvbXBhcmUiLCJkZWZhdWx0Q29tcGFyZSIsImRpcmVjdGlvbiIsImxoc1JvdyIsInJoc1JvdyIsInNvcnRhYmxlQ2hpbGRyZW5SZXR1cm4iLCJjb21wYXJlMSIsImdldFNvcnRWYWx1ZSIsInVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGUiLCJncmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMiLCJzY3IiLCJ1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiIsInVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQiLCJfdm9pZDUiLCJ2b2lkNyIsInNzY3IiLCJfdm9pZDYiLCJwcmV2aW91c2x5Rm9jdXNlZCIsInVzZUNoaWxkcmVuSGF2ZUZvY3VzIiwiZ2V0QW55Rm9jdXNlZCIsInNldEFueUZvY3VzZWQiLCJfZ2V0Rm9jdXNDb3VudCIsInNldEZvY3VzQ291bnQiLCJhbnlQcmV2aW91c2x5Rm9jdXNlZCIsImNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuIiwiY2hpbGRyZW5IYXZlRm9jdXNDaGlsZENvbnRleHQiLCJjaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVycyIsInVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGQiLCJ1c2VIYXNDdXJyZW50Rm9jdXMiLCJvbkN1cnJlbnRGb2N1c2VkQ2hhbmdlZCIsIm9uRm9jdXNlZENoYW5nZWQiLCJvbkZvY3VzZWRJbm5lckNoYW5nZWQiLCJnZXRGb2N1c2VkIiwic2V0Rm9jdXNlZCIsImdldEZvY3VzZWRJbm5lciIsInNldEZvY3VzZWRJbm5lciIsIm9uRm9jdXNJbiIsIm9uRm9jdXNPdXQiLCJvbmZvY3VzaW4iLCJvbmZvY3Vzb3V0IiwiaGFzQ3VycmVudEZvY3VzUmV0dXJuIiwiZ2V0Q3VycmVudEZvY3VzZWQiLCJnZXRDdXJyZW50Rm9jdXNlZElubmVyIiwidXNlUHJlc3MiLCJleGNsdWRlIiwiYWN0aXZlRHVyaW5nUmVuZGVyIiwic2V0QWN0aXZlIiwiZ2V0QWN0aXZlIiwidGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSIsInNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUiLCJwc2V1ZG9BY3RpdmUiLCJub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoIiwiRGF0ZSIsIm9uQWN0aXZlU3RhcnQiLCJvbkFjdGl2ZVN0b3AiLCJjdXJyZW50VGltZSIsInRpbWVEaWZmZXJlbmNlIiwiY2hhcmFjdGVyc1NlbGVjdGVkIiwiYWN0aXZlIiwiaGFuZGxlUHJlc3MiLCJwdWxzZSIsIm9uTW91c2VEb3duIiwiZXhjbHVkZXMiLCJidXR0b24iLCJvbk1vdXNlVXAiLCJvbk1vdXNlTGVhdmUiLCJvbktleVVwIiwib25DbGljayIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInByb3BzU3RhYmxlMiIsInByZXNzUmV0dXJuIiwic2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9uIiwicmFuZ2VDb3VudCIsInJhbmdlIiwiZ2V0UmFuZ2VBdCIsImVuZENvbnRhaW5lciIsImlzQ29sbGFwc2VkIiwibmF2aWdhdG9yIiwidmlicmF0ZSIsInVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb24iLCJnZXRIaWdoZXN0Q2hpbGRJbmRleCIsImdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuIiwidXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvdyIsIm1jYzEiLCJjb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycyIsImJhc2VJbmZvIiwic29ydGFibGVDaGlsZFBhcmFtZXRlcnMiLCJjb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ29udGV4dCIsInVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsIiwiY29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzIiwidXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbiIsImNvbXBsZXRlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzIiwiZ2V0VmFsaWQiLCJ1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGQiLCJjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzIiwib3BzMSIsIl92b2lkIiwib3BzMiIsInAxIiwibWNwMSIsInVzZU1vZGFsIiwicHAxIiwicHMyIiwicHAzIiwicHA0IiwicHJvcHNQb3B1cCIsInByb3BzRm9jdXNDb250YWluZXIiLCJwcm9wc1NvdXJjZSIsInVzZVJhbmRvbUlkIiwicmFuZG9tSWRQYXJhbWV0ZXJzIiwib3RoZXJSZWZlcmVuY2VyUHJvcCIsInJlZmVyZW5jZXJFbGVtZW50UHJvcHMiLCJzb3VyY2VFbGVtZW50UHJvcHMiLCJwcm9wc1JlZmVyZW5jZXIiLCJyYW5kb21JZFJldHVybiIsInVzZVJhbmRvbUR1YWxJZHMiLCJyYW5kb21JZElucHV0UGFyYW1ldGVycyIsInJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzIiwicmFuZG9tSWRJbnB1dFJldHVybiIsInByb3BzTGFiZWxBc1JlZmVyZW5jZXIiLCJwcm9wc0lucHV0QXNTb3VyY2UiLCJyYW5kb21JZExhYmVsUmV0dXJuIiwicHJvcHNJbnB1dEFzUmVmZXJlbmNlciIsInByb3BzTGFiZWxBc1NvdXJjZSIsInByb3BzTGFiZWwiLCJwcm9wc0lucHV0IiwidXNlVGltZW91dCIsInRyaWdnZXJJbmRleCIsInN0YWJsZUNhbGxiYWNrIiwic3RhcnRUaW1lUmVmIiwiZ2V0VGltZW91dCIsInRpbWVvdXRJc051bGwiLCJnZXRFbGFwc2VkVGltZSIsImdldFJlbWFpbmluZ1RpbWUiLCJ1c2VCdXR0b24iLCJidXR0b25QYXJhbWV0ZXJzIiwidGFnQnV0dG9uIiwib25QcmVzcyIsInByZXNzZWQiLCJyb2xlIiwicHJlc3NQcm9wcyIsInJlZlByb3BzIiwiYmFzZVByb3BzIiwiYnV0dG9uUHJvcHMiLCJkaXZQcm9wcyIsInVzZUFjY29yZGlvbiIsImFjY29yZGlvblBhcmFtZXRlcnMiLCJtY1JldHVyblR5cGUiLCJvY21jMiIsImlzVmFsaWQyIiwiY2hhbmdlRXhwYW5kZWRJbmRleCIsImdldEN1cnJlbnRFeHBhbmRlZEluZGV4IiwiZ2V0T3BlbkZyb21QYXJlbnQiLCJzZXRPcGVuRnJvbVBhcmVudCIsImNoYW5nZVRhYmJlZEluZGV4IiwiZ2V0VGFiYmVkSW5kZXgiLCJnZXRNb3N0UmVjZW50bHlUYWJiZWQiLCJ0YWJiZWQiLCJzZXRNb3N0UmVjZW50bHlUYWJiZWQiLCJhY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVycyIsImdldEV4cGFuZGVkSW5kZXgiLCJhY2NvcmRpb25SZXR1cm4iLCJ1c2VBY2NvcmRpb25TZWN0aW9uIiwib3BlbkZyb21Vc2VyIiwiYm9keVJvbGUiLCJfc2V0Q3VycmVudEZvY3VzZWRJbmRleCIsImdldEN1cnJlbnRGb2N1c2VkSW5kZXgiLCJ1c2VyT25QcmVzcyIsIm9wZW5Gcm9tUGFyZW50IiwibW9zdFJlY2VudGx5VGFiYmVkIiwiX2JvZHlJZFJldHVybiIsInByb3BzQm9keVNvdXJjZSIsInByb3BzSGVhZFJlZmVyZW5jZXIiLCJfaGVhZElkUmV0dXJuIiwicHJvcHNIZWFkU291cmNlIiwicHJvcHNCb2R5UmVmZXJlbmNlciIsImdldEhlYWRlckVsZW1lbnQiLCJoZWFkZXJSZWZFbGVtZW50UHJvcHMiLCJfZ2V0Qm9keUVsZW1lbnQiLCJib2R5UmVmRWxlbWVudFByb3BzIiwibGluZWFyUmV0dXJuVHlwZSIsImhlYWRlckJ1dHRvblByb3BzIiwiYm9keVByb3BzIiwiYWNjb3JkaW9uU2VjdGlvblJldHVybiIsImV4cGFuZGVkIiwicHJvcHNIZWFkZXJCdXR0b24iLCJwcm9wc0hlYWRlciIsInByb3BzQm9keSIsInVzZUxhYmVsIiwibGFiZWxQYXJhbWV0ZXJzIiwidGFnSW5wdXQiLCJ0YWdMYWJlbCIsImFyaWFMYWJlbCIsImxhYmVsUG9zaXRpb24iLCJvbkxhYmVsQ2xpY2siLCJuYXRpdmVIVE1MQmVoYXZpb3IiLCJzeW50aGV0aWMiLCJlbnRlciIsInNwYWNlIiwiY2xpY2siLCJ1c2VMYWJlbFN5bnRoZXRpYyIsInVzZUNoZWNrYm94TGlrZSIsImNoZWNrYm94TGlrZVBhcmFtZXRlcnMiLCJvbklucHV0Iiwib25JbnB1dFN5bmMiLCJyZWZFbGVtZW50SW5wdXRSZXR1cm4iLCJyZWZFbGVtZW50TGFiZWxSZXR1cm4iLCJnZXRJbnB1dEVsZW1lbnQiLCJnZXRMYWJlbEVsZW1lbnQiLCJpbmRldGVybWluYXRlIiwiZ2V0SW5wdXQiLCJnZXRMYWJlbCIsIm9uQ2xpY2tJbnB1dFN5bmMiLCJvbkNsaWNrTGFiZWxTeW5jIiwicHJlc3NJbnB1dFJldHVybiIsInByZXNzTGFiZWxSZXR1cm4iLCJwcm9wc1Vuc3RhYmxlSW5wdXQiLCJwcm9wc1Vuc3RhYmxlTGFiZWwiLCJvbkZvY3VzIiwiZWxlbWVudFRvRm9jdXMiLCJjaGVja2JveExpa2VJbnB1dFJldHVybiIsImNoZWNrYm94TGlrZUxhYmVsUmV0dXJuIiwiY2hlY2tib3hMaWtlUmV0dXJuIiwidXNlQ2hlY2tib3giLCJjaGVja2JveFBhcmFtZXRlcnMiLCJvbkNoZWNrZWRDaGFuZ2UiLCJvbklucHV0RW5oYW5jZWQiLCJjaGVja2JveFJldHVybiIsInVzZUNoZWNrYm94R3JvdXAiLCJhbGxJZHMiLCJ1cGRhdGVQYXJlbnRDb250cm9sSWRzIiwic2V0dGVyIiwiZ2V0U2V0dGVyIiwic2V0U2V0dGVyIiwiX2dldFVwZGF0ZUluZGV4Iiwic2V0VXBkYXRlSW5kZXgiLCJnZXRTZWxmSXNDaGVja2VkIiwicGVyY2VudENoZWNrZWQiLCJvbkFueUNoaWxkQ2hlY2tlZFVwZGF0ZSIsImdldFRvdGFsQ2hpbGRyZW4iLCJzZXRUb3RhbENoaWxkcmVuIiwidG90YWxDaGlsZHJlbiIsImdldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZCIsImdldFBlcmNlbnRDaGVja2VkIiwiZ2V0VG90YWxDaGVja2VkIiwic2V0VG90YWxDaGVja2VkIiwidG90YWxDaGVja2VkIiwic2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkIiwib25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQiLCJzZWxmSXNDaGVja2VkIiwibmV4dENoZWNrZWQiLCJ3aWxsQ2hhbmdlQW55IiwicHJvbWlzZXMiLCJjaGVja2JveEluZm8iLCJjaGVja2JveENoaWxkVHlwZSIsImdldENoZWNrZWQiLCJnZXRMYXN0VXNlckNoZWNrZWQiLCJwcmV2Q2hlY2tlZCIsInNldENoZWNrZWRGcm9tUGFyZW50SW5wdXQiLCJjaGVja2JveEdyb3VwQ2hpbGRyZW5Db250ZXh0IiwiY2hlY2tib3hHcm91cFBhcmVudENvbnRleHQiLCJ1c2VDaGVja2JveEdyb3VwUGFyZW50IiwiYXJpYUNvbnRyb2xzIiwic2V0Q29udHJvbHMiLCJzZXRDaGVja2VkIiwiY2hlY2tib3hHcm91cFBhcmVudFJldHVybiIsIm9uUGFyZW50Q2hlY2tlZENoYW5nZSIsImdldFBlcmNlbnQiLCJ1c2VDaGVja2JveEdyb3VwQ2hpbGQiLCJjaGVja2JveEdyb3VwQ2hpbGQiLCJvbkNoYW5nZUZyb21QYXJlbnQiLCJzZXRMYXN0VXNlckNoZWNrZWQiLCJvbkNoaWxkQ2hlY2tlZENoYW5nZSIsIm9uQ29udHJvbElkQ2hhbmdlZCIsIm5leHQiLCJ1c2VEaWFsb2ciLCJwcm9wc0RpYWxvZyIsInByb3BzVGl0bGUiLCJ1c2VEcmF3ZXIiLCJwcm9wc0RyYXdlciIsInVzZUdyaWRsaXN0IiwiZ3JpZGxpc3RQYXJhbWV0ZXJzIiwic2VsZWN0aW9uTGltaXQiLCJncm91cGluZ1R5cGUiLCJwcm9wc0xhYmVsTGlzdCIsInByb3BzTGFiZWxMYWJlbCIsIl9ncmlkbGlzdElkIiwiX2xhYmVsSWQiLCJwcm9wc0dyaWRsaXN0IiwiZnVsbENvbnRleHQiLCJncmlkbGlzdFJvd0NvbnRleHQiLCJwcm9wc0dyaWRsaXN0TGFiZWwiLCJ1c2VHcmlkbGlzdFJvdyIsImN4MSIsImdyaWRsaXN0Um93UGFyYW1ldGVycyIsImN4MiIsInVzZUdyaWRsaXN0Q2VsbCIsInVzZU1lbnVTdXJmYWNlIiwibWVudVN1cmZhY2VQYXJhbWV0ZXJzIiwicHJvcHNJZFRyaWdnZXIiLCJwcm9wc0lkVGFyZ2V0IiwiZ2V0QnV0dG9uRWxlbWVudCIsInByb3BzUmVmVHJpZ2dlciIsImdldE1lbnVFbGVtZW50IiwicHJvcHNSZWZTdXJmYWNlIiwidm9pZDYiLCJidXR0b25FbGVtZW50IiwicHJvcHNTdXJmYWNlIiwicHJvcHNUYXJnZXQiLCJwcm9wc1RyaWdnZXIiLCJwcm9wc1NlbnRpbmVsIiwidXNlRm9jdXNTZW50aW5lbCIsImZvY3VzU2VudGluZWwiLCJzZW5kRm9jdXNUb01lbnUiLCJnZXRTZW5kRm9jdXNXaXRoaW5NZW51IiwiZmlyc3RTZW50aW5lbElzQWN0aXZlIiwic2V0Rmlyc3RTZW50aW5lbElzQWN0aXZlIiwidXNlVG9vbGJhciIsInRvb2xiYXJQYXJhbWV0ZXJzIiwib3JpZW50YXRpb24iLCJsaXN0TmF2UGFyYW1ldGVycyIsImxpc3ROYXZSZXR1cm4iLCJ0b29sYmFyUmV0dXJuIiwidXNlVG9vbGJhckNoaWxkIiwibGlzdE5hdkNoaWxkUGFyYW1ldGVycyIsInVzZU1lbnViYXIiLCJtZW51YmFyUGFyYW1ldGVycyIsIl9yZXN0IiwidXNlTWVudWJhckNoaWxkIiwibWVudUl0ZW1QYXJhbWV0ZXJzIiwidXNlTWVudSIsIm1lbnVQYXJhbWV0ZXJzIiwib3BlbkRpcmVjdGlvbiIsIm9uT3BlbiIsInByb3BzTWVudWJhciIsImlzT3BlbiIsInVzZU1lbnVJdGVtIiwidXNlUmFkaW9Hcm91cCIsInJhZGlvR3JvdXBQYXJhbWV0ZXJzIiwic2V0U2VsZWN0ZWRWYWx1ZSIsInNldFNlbGVjdGVkVmFsdWVFeHRlcm5hbCIsInNlbGVjdGVkVmFsdWUiLCJieU5hbWUiLCJwcm9wc0dyb3VwMSIsInByb3BzR3JvdXAyIiwiZ2V0VmFsdWUyIiwicHJvcHNSYWRpb0dyb3VwIiwicHJvcHNSYWRpb0dyb3VwTGFiZWwiLCJyYWRpb0NvbnRleHQiLCJyYWRpb0dyb3VwUmV0dXJuIiwidXNlUmFkaW8iLCJyYWRpb1BhcmFtZXRlcnMiLCJsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMiLCJwcm9wc0lmSW5wdXRIYW5kbGVzRm9jdXMiLCJwcm9wc0lucHV0MiIsInByb3BzSWZMYWJlbEhhbmRsZXNGb2N1cyIsInByb3BzTGFiZWwyIiwidXNlU2xpZGVyIiwic2xpZGVyUGFyYW1ldGVycyIsIm1pbiIsImJhc2VJZFJlZiIsInNsaWRlckNvbnRleHQiLCJiYXNlSWQiLCJ1c2VTbGlkZXJUaHVtYiIsIm1heFBhcmVudCIsIm1pblBhcmVudCIsInNsaWRlclRodW1iUGFyYW1ldGVycyIsIm1heE92ZXJyaWRlIiwibWluT3ZlcnJpZGUiLCJvblZhbHVlQ2hhbmdlIiwidmFsdWVUZXh0IiwibGFiZWwiLCJ2YWx1ZUFzTnVtYmVyIiwic2xpZGVyVGh1bWJSZXR1cm4iLCJwcm9wc1NsaWRlclRodW1iIiwidXNlVGFibGUiLCJ0YWJsZVBhcmFtZXRlcnMiLCJ0YWdUYWJsZSIsImdldFNvcnRCb2R5Iiwic2V0U29ydEJvZHkiLCJzb3J0UXVldWUiLCJnZXRTb3J0Q29sdW1uIiwic2V0U29ydENvbHVtbiIsImNvbHVtbiIsInVwZGF0ZVNvcnREaXJlY3Rpb24iLCJjdXJyZW50Q29sdW1uIiwiY3VycmVudERpcmVjdGlvbiIsInNvcnRCeUNvbHVtbiIsInByb3BzVGFibGUiLCJ0YWJsZUNvbnRleHQiLCJzZXRTb3J0Qm9keUZ1bmN0aW9uIiwiZ2V0Q3VycmVudFNvcnRDb2x1bW4iLCJuYXR1cmFsU2VjdGlvblR5cGVzIiwidXNlVGFibGVTZWN0aW9uIiwidGFibGVTZWN0aW9uUGFyYW1ldGVycyIsInRhZ1RhYmxlU2VjdGlvbiIsImxvY2F0aW9uIiwicHJvcHNUYWJsZVNlY3Rpb24iLCJ1c2VUYWJsZVJvdyIsInRhYmxlUm93UGFyYW1ldGVycyIsInNvcnRWYWx1ZSIsInVzZVRhYmxlQ2VsbCIsInRhYmxlQ2VsbFBhcmFtZXRlcnMiLCJ0YWdUYWJsZUNlbGwiLCJ0YWJsZUNlbGxSZXR1cm4iLCJzb3J0QnlUaGlzQ29sdW1uIiwidXNlVGFicyIsInNzaSIsInRhYnNQYXJhbWV0ZXJzIiwiZ2V0VGFiSWQiLCJnZXRQYW5lbElkIiwicGFuZWxDaGlsZHJlblJldHVybiIsIl9tIiwiX3UiLCJjaGFuZ2VWaXNpYmxlUGFuZWwiLCJnZXRWaXNpYmxlSW5kZXgiLCJnZXRWaXNpYmxlIiwic2V0VmlzaWJsZSIsIl9pbnB1dElkIiwibGlzdE5hdlJldDEiLCJsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzIiwiY29udGV4dFBhbmVscyIsInRhYlBhbmVsQ29udGV4dCIsImNvbnRleHRUYWJzIiwidGFic0NvbnRleHQiLCJwcm9wc0NvbnRhaW5lciIsInVzZVRhYiIsImxpc3ROYXZSZXQyIiwicGFuZWxJZCIsInRhYklkIiwidXNlVGFiUGFuZWwiLCJpc1Zpc2libGUiLCJzZXRJc1Zpc2libGUiLCJnZXRJc1Zpc2libGUiLCJ0YWJQYW5lbFJldHVybiIsInZpc2libGUiLCJ1c2VUb2FzdHMiLCJvY211IiwidG9hc3RzUGFyYW1ldGVycyIsInZpc2libGVDb3VudCIsImN1cnJlbnRJbmRleFF1ZXVlIiwicG9saXRlbmVzcyIsInNldFBvbGl0ZW5lc3MiLCJnZXRNYXhWaXNpYmxlQ291bnQiLCJfY2hpbGRJbmZvIiwiZ2V0VG9hc3RRdWV1ZSIsInRvYXN0UXVldWUiLCJzaG93SGlnaGVzdFByaW9yaXR5VG9hc3QiLCJoaWdoZXN0UHJpb3JpdHlUb2FzdCIsInNob3ciLCJvbkFueVRvYXN0TW91bnRlZCIsInRvYXN0SW5kZXgiLCJzZXROdW1iZXJBaGVhZE9mTWUiLCJvbkFueVRvYXN0RGlzbWlzc2VkIiwiX2luZGV4IiwicmVtb3ZhbEluZGV4IiwiZmluZEluZGV4IiwiX21vdXNlT3ZlcjIiLCJzZXRNb3VzZU92ZXIiLCJfZ2V0TW91c2VPdmVyIiwibW91c2VPdmVyIiwidG9hc3RDb250ZXh0IiwidXNlVG9hc3QiLCJ0b2FzdFBhcmFtZXRlcnMiLCJfbWFuYWdlZENoaWxkUGFyYW1ldGVycyIsIm51bWJlck9mVG9hc3RzQWhlYWRPZlVzIiwic2V0TnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMiLCJkaXNtaXNzZWQyIiwic2V0RGlzbWlzc2VkMiIsImdldERpc21pc3NlZDIiLCJzaG93aW5nMiIsInNldFNob3dpbmcyIiwiZ2V0U2hvd2luZzIiLCJkaXNtaXNzIiwic2V0VHJpZ2dlckluZGV4IiwicmVzZXREaXNtaXNzVGltZXIiLCJkaXNtaXNzVGltZW91dEtleSIsImlzRmluaXRlIiwidG9hc3RSZXR1cm4iLCJkaXNtaXNzZWQiLCJzaG93aW5nIiwidXNlVG9vbHRpcCIsIm1vdXNlb3ZlckRlbGF5IiwibW91c2VvdXRUb2xlcmFuY2VEZWxheSIsImZvY3VzRGVsYXkiLCJzZXRPcGVuIiwic2V0SG92ZXJTdGF0ZSIsInNldFRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJzZXRUb29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkIiwiZ2V0VHJpZ2dlckVsZW1lbnQiLCJ0cmlnZ2VyUmVmUHJvcHMiLCJwb3B1cFJlZlByb3BzIiwic2V0VHJpZ2dlckZvY3VzZWQiLCJkZWxheSIsInNldFRvb2x0aXBGb2N1c2VkIiwib25Ib3ZlckNoYW5nZSIsImhvdmVyaW5nIiwiaG92ZXJTdGF0ZSIsInNldFRyaWdnZXJIb3ZlciIsInNldFRvb2x0aXBIb3ZlciIsInRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJ0b29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkIiwiaG92ZXJEZWxheUNvcnJlY3RlZCIsIm9uVG91Y2hFbmQiLCJwcm9wc0ZvY3VzUG9wdXAiLCJ0b29sdGlwUmV0dXJuIiwiZ2V0SXNPcGVuIiwibWVtb0ZvcndhcmRSZWYiLCJDb250ZXh0RGVmYXVsdHMiLCJ1c2VEZWZhdWx0IiwidXNlclZhbHVlIiwiUGFyZW50RGVwdGhDb250ZXh0IiwiQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQiLCJBY2NvcmRpb24iLCJBY2NvcmRpb25TZWN0aW9uIiwiQnV0dG9uIiwiZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSIsIm1ha2VQcm9wc0lucHV0IiwibWFrZVByb3BzTGFiZWwiLCJpbnB1dFByb3BzIiwibGFiZWxQcm9wcyIsImlucHV0IiwiQ2hlY2tib3giLCJjaGVja2JveCIsIlVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQiLCJDaGVja2JveEdyb3VwIiwiQ2hlY2tib3hHcm91cFBhcmVudCIsIkNoZWNrYm94R3JvdXBDaGlsZCIsImRlZmF1bHRSZW5kZXJQb3J0YWwiLCJwb3J0YWxJZCIsInBvcnRhbFJlZiIsImdldEVsZW1lbnRCeUlkIiwiRGlhbG9nIiwiZGVmYXVsdFBhcmVudERlcHRoIiwibXlEZXB0aCIsIkRyYXdlciIsIkdyaWRsaXN0Q29udGV4dCIsIkdyaWRsaXN0Um93Q29udGV4dCIsIkdyaWRsaXN0VSIsIkdyaWRsaXN0Um93VSIsIkdyaWRsaXN0Q2hpbGQiLCJ1c2VMaXN0Ym94IiwibGlzdGJveFBhcmFtZXRlcnMiLCJsaXN0Ym94Q29udGV4dCIsInByb3BzTGlzdGJveCIsInByb3BzTGlzdGJveExhYmVsIiwidXNlTGlzdGJveEl0ZW0iLCJMaXN0Ym94Q29udGV4dCIsIkxpc3Rib3giLCJMaXN0Ym94SXRlbSIsImZvY3VzU2VsZkRlZmF1bHQiLCJNZW51SXRlbUNvbnRleHQiLCJNZW51YmFyVSIsIk1lbnVJdGVtIiwiTWVudUl0ZW1VIiwiTWVudSIsIlJhZGlvQ29udGV4dCIsIlJhZGlvR3JvdXAiLCJSYWRpbyIsImRlZmF1bHRGb2N1c1NlbGYiLCJTbGlkZXJUaHVtYkNvbnRleHQiLCJTbGlkZXIiLCJTbGlkZXJUaHVtYiIsIlNsaWRlclRodW1iVSIsIlRhYmxlQ29udGV4dCIsIlRhYmxlU2VjdGlvbkNvbnRleHQiLCJUYWJsZVJvd0NvbnRleHQiLCJUYWJsZVUiLCJUYWJsZVNlY3Rpb24iLCJUYWJsZVJvdyIsIlRhYmxlUm93VSIsInRhZ1RhYmxlUm93IiwiVGFibGVDZWxsIiwiVGFic0NvbnRleHQiLCJUYWJQYW5lbHNDb250ZXh0IiwiVGFicyIsIlRhYiIsIlRhYlBhbmVsIiwiVG9hc3RDb250ZXh0IiwiVG9hc3RzIiwiVG9hc3QiLCJUb29sYmFyQ29udGV4dCIsIlRvb2xiYXIiLCJUb29sYmFyVSIsImxpc3Rib3hSZXR1cm5UeXBlIiwiVG9vbGJhckNoaWxkIiwiVG9vbGJhckNoaWxkVSIsIlRvb2x0aXAiLCJUb29sdGlwVSIsIkRlbW9BY2NvcmRpb24iLCJfaW5mbyIsIkRlbW9BY2NvcmRpb25TZWN0aW9uIiwiQmx1cmIiLCJocmVmIiwiQ29kZSIsIkRlbW8iLCJzZXRDb3VudCIsInNldFByZXNzZWQiLCJEZW1vQnV0dG9uIiwiYWxlcnQiLCJzZXREaXNhYmxlZCIsIkRlbW9DaGVja2JveCIsImJvcmRlciIsImluZm8yIiwicGVuZGluZyIsInNldFBlbmRpbmciLCJpbmZvMyIsImZpbmFsbHkiLCJpbmZvNCIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiRGVtb0xpc3RJdGVtIiwibGFiZWxUZXh0IiwiRGVtb1JhZGlvQnV0dG9uIiwiRGVtb1NsaWRlclRodW1iIiwiRGVtb1RhYiIsIkRlbW9UYWJQYW5lbCIsIm1hcmdpbkxlZnQiLCJ0b2FzdHMiLCJzZXRUb2FzdHMiLCJwdXNoVG9hc3QiLCJvcGFjaXR5IiwiRGVtb0lucHV0Iiwic2V0ViIsIkRlbW9UYWJsZUNlbGwiLCJoZWFkZXIiLCJpbmZvVGFibGUiLCJpbmZvU2VjdGlvbiIsImluZm9Sb3ciLCJBY2NvcmRpb24uRGVtbyIsIkJ1dHRvbi5EZW1vIiwiQ2hlY2tib3guRGVtbyIsIkNoZWNrYm94R3JvdXAuRGVtbyIsIkRpYWxvZy5EZW1vIiwiTGlzdGJveFNpbmdsZS5EZW1vIiwiTGlzdGJveE11bHRpLkRlbW8iLCJNZW51LkRlbW8iLCJSYWRpby5EZW1vIiwiU2xpZGVyLkRlbW8iLCJUb29sYmFyLkRlbW8iLCJUb2FzdC5EZW1vIiwiVG9vbHRpcC5EZW1vIiwiVGFicy5EZW1vIiwiVGFibGUuRGVtbyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUEwQmFBLElBQUFBLENBQUFBO0lDZlBDLEdDUkZDO0lBQUFBLEdBQUFBO0lDeUtBQyxHQUFBQTtJQVdBQztJQ3JMT0MsR0NGRUM7SUFBQUEsR0FBQUEs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
