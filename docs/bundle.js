(function () {
    'use strict';

    var n,
        l$1,
        u$1,
        t$1,
        o$2,
        r$2,
        f$1 = {},
        e$2 = [],
        c$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function s$1(n, l) {
      for (var u in l) n[u] = l[u];

      return n;
    }

    function a$1(n) {
      var l = n.parentNode;
      l && l.removeChild(n);
    }

    function h$1(l, u, i) {
      var t,
          o,
          r,
          f = {};

      for (r in u) "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];

      if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) void 0 === f[r] && (f[r] = l.defaultProps[r]);
      return v$1(l, f, t, o, null);
    }

    function v$1(n, i, t, o, r) {
      var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u$1 : r
      };
      return null == r && null != l$1.vnode && l$1.vnode(f), f;
    }

    function p$1(n) {
      return n.children;
    }

    function d$1(n, l) {
      this.props = n, this.context = l;
    }

    function _$1(n, l) {
      if (null == l) return n.__ ? _$1(n.__, n.__.__k.indexOf(n) + 1) : null;

      for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;

      return "function" == typeof n.type ? _$1(n) : null;
    }

    function k$1(n) {
      var l, u;

      if (null != (n = n.__) && null != n.__c) {
        for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
          n.__e = n.__c.base = u.__e;
          break;
        }

        return k$1(n);
      }
    }

    function b$1(n) {
      (!n.__d && (n.__d = !0) && t$1.push(n) && !g$2.__r++ || o$2 !== l$1.debounceRendering) && ((o$2 = l$1.debounceRendering) || setTimeout)(g$2);
    }

    function g$2() {
      for (var n; g$2.__r = t$1.length;) n = t$1.sort(function (n, l) {
        return n.__v.__b - l.__v.__b;
      }), t$1 = [], n.some(function (n) {
        var l, u, i, t, o, r;
        n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = s$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? _$1(t) : o, t.__h), z$2(u, t), t.__e != o && k$1(t)));
      });
    }

    function w$2(n, l, u, i, t, o, r, c, s, a) {
      var h,
          y,
          d,
          k,
          b,
          g,
          w,
          x = i && i.__k || e$2,
          C = x.length;

      for (u.__k = [], h = 0; h < l.length; h++) if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? v$1(null, k, null, null, k) : Array.isArray(k) ? v$1(p$1, {
        children: k
      }, null, null, null) : k.__b > 0 ? v$1(k.type, k.props, k.key, null, k.__v) : k)) {
        if (k.__ = u, k.__b = u.__b + 1, null === (d = x[h]) || d && k.key == d.key && k.type === d.type) x[h] = void 0;else for (y = 0; y < C; y++) {
          if ((d = x[y]) && k.key == d.key && k.type === d.type) {
            x[y] = void 0;
            break;
          }

          d = null;
        }
        j$2(n, k, d = d || f$1, t, o, r, c, s, a), b = k.__e, (y = k.ref) && d.ref != y && (w || (w = []), d.ref && w.push(d.ref, null, k), w.push(y, k.__c || b, k)), null != b ? (null == g && (g = b), "function" == typeof k.type && k.__k === d.__k ? k.__d = s = m$1(k, s, n) : s = A$1(n, k, d, x, b, s), "function" == typeof u.type && (u.__d = s)) : s && d.__e == s && s.parentNode != n && (s = _$1(d));
      }

      for (u.__e = g, h = C; h--;) null != x[h] && ("function" == typeof u.type && null != x[h].__e && x[h].__e == u.__d && (u.__d = _$1(i, h + 1)), N(x[h], x[h]));

      if (w) for (h = 0; h < w.length; h++) M$1(w[h], w[++h], w[++h]);
    }

    function m$1(n, l, u) {
      for (var i, t = n.__k, o = 0; t && o < t.length; o++) (i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? m$1(i, l, u) : A$1(u, i, i, t, i.__e, l));

      return l;
    }

    function x(n, l) {
      return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
        x(n, l);
      }) : l.push(n)), l;
    }

    function A$1(n, l, u, i, t, o) {
      var r, f, e;
      if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
        for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) if (f == t) break n;

        n.insertBefore(t, o), r = o;
      }
      return void 0 !== r ? r : t.nextSibling;
    }

    function C$1(n, l, u, i, t) {
      var o;

      for (o in u) "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);

      for (o in l) t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
    }

    function $$1(n, l, u) {
      "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || c$1.test(l) ? u : u + "px";
    }

    function H$1(n, l, u, i, t) {
      var o;

      n: if ("style" === l) {
        if ("string" == typeof u) n.style.cssText = u;else {
          if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || $$1(n.style, l, "");
          if (u) for (l in u) i && u[l] === i[l] || $$1(n.style, l, u[l]);
        }
      } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$2 : I, o) : n.removeEventListener(l, o ? T$2 : I, o);else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
          n[l] = null == u ? "" : u;
          break n;
        } catch (n) {}
        "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
      }
    }

    function I(n) {
      this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
    }

    function T$2(n) {
      this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
    }

    function j$2(n, u, i, t, o, r, f, e, c) {
      var a,
          h,
          v,
          y,
          _,
          k,
          b,
          g,
          m,
          x,
          A,
          C,
          $,
          H = u.type;

      if (void 0 !== u.constructor) return null;
      null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (a = l$1.__b) && a(u);

      try {
        n: if ("function" == typeof H) {
          if (g = u.props, m = (a = H.contextType) && t[a.__c], x = a ? m ? m.props.value : a.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in H && H.prototype.render ? u.__c = h = new H(g, x) : (u.__c = h = new d$1(g, x), h.constructor = H, h.render = O$1), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != H.getDerivedStateFromProps && (h.__s == h.state && (h.__s = s$1({}, h.__s)), s$1(h.__s, H.getDerivedStateFromProps(g, h.__s))), y = h.props, _ = h.state, v) null == H.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
            if (null == H.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
              h.props = g, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
                n && (n.__ = u);
              }), h.__h.length && f.push(h);
              break n;
            }

            null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
              h.componentDidUpdate(y, _, k);
            });
          }
          if (h.context = x, h.props = g, h.__v = u, h.__P = n, A = l$1.__r, C = 0, "prototype" in H && H.prototype.render) h.state = h.__s, h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context);else do {
            h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
          } while (h.__d && ++C < 25);
          h.state = h.__s, null != h.getChildContext && (t = s$1(s$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, _)), $ = null != a && a.type === p$1 && null == a.key ? a.props.children : a, w$2(n, Array.isArray($) ? $ : [$], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);

        (a = l$1.diffed) && a(u);
      } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
      }
    }

    function z$2(n, u) {
      l$1.__c && l$1.__c(u, n), n.some(function (u) {
        try {
          n = u.__h, u.__h = [], n.some(function (n) {
            n.call(u);
          });
        } catch (n) {
          l$1.__e(n, u.__v);
        }
      });
    }

    function L$1(l, u, i, t, o, r, e, c) {
      var s,
          h,
          v,
          y = i.props,
          p = u.props,
          d = u.type,
          k = 0;
      if ("svg" === d && (o = !0), null != r) for (; k < r.length; k++) if ((s = r[k]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
        l = s, r[k] = null;
        break;
      }

      if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
      }

      if (null === d) y === p || c && l.data === p || (l.data = p);else {
        if (r = r && n.call(l.childNodes), h = (y = i.props || f$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
          if (null != r) for (y = {}, k = 0; k < l.attributes.length; k++) y[l.attributes[k].name] = l.attributes[k].value;
          (v || h) && (v && (h && v.__html == h.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }

        if (C$1(l, p, y, o, c), v) u.__k = [];else if (k = u.props.children, w$2(l, Array.isArray(k) ? k : [k], u, i, t, o && "foreignObject" !== d, r, e, r ? r[0] : i.__k && _$1(i, 0), c), null != r) for (k = r.length; k--;) null != r[k] && a$1(r[k]);
        c || ("value" in p && void 0 !== (k = p.value) && (k !== l.value || "progress" === d && !k || "option" === d && k !== y.value) && H$1(l, "value", k, y.value, !1), "checked" in p && void 0 !== (k = p.checked) && k !== l.checked && H$1(l, "checked", k, y.checked, !1));
      }
      return l;
    }

    function M$1(n, u, i) {
      try {
        "function" == typeof n ? n(u) : n.current = u;
      } catch (n) {
        l$1.__e(n, i);
      }
    }

    function N(n, u, i) {
      var t, o;

      if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$1(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
          t.componentWillUnmount();
        } catch (n) {
          l$1.__e(n, u);
        }
        t.base = t.__P = null;
      }

      if (t = n.__k) for (o = 0; o < t.length; o++) t[o] && N(t[o], u, "function" != typeof n.type);
      i || null == n.__e || a$1(n.__e), n.__e = n.__d = void 0;
    }

    function O$1(n, l, u) {
      return this.constructor(n, u);
    }

    function P$1(u, i, t) {
      var o, r, e;
      l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, e = [], j$2(i, u = (!o && t || i).__k = h$1(p$1, null, [u]), r || f$1, f$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, e, !o && t ? t : r ? r.__e : i.firstChild, o), z$2(e, u);
    }

    function B(n, l) {
      var u = {
        __c: l = "__cC" + r$2++,
        __: n,
        Consumer: function (n, l) {
          return n.children(l);
        },
        Provider: function (n) {
          var u, i;
          return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
            return i;
          }, this.shouldComponentUpdate = function (n) {
            this.props.value !== n.value && u.some(b$1);
          }, this.sub = function (n) {
            u.push(n);
            var l = n.componentWillUnmount;

            n.componentWillUnmount = function () {
              u.splice(u.indexOf(n), 1), l && l.call(n);
            };
          }), n.children;
        }
      };
      return u.Provider.__ = u.Consumer.contextType = u;
    }

    n = e$2.slice, l$1 = {
      __e: function (n, l, u, i) {
        for (var t, o, r; l = l.__;) if ((t = l.__c) && !t.__) try {
          if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), r) return t.__E = t;
        } catch (l) {
          n = l;
        }

        throw n;
      }
    }, u$1 = 0, d$1.prototype.setState = function (n, l) {
      var u;
      u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s$1({}, this.state), "function" == typeof n && (n = n(s$1({}, u), this.props)), n && s$1(u, n), null != n && this.__v && (l && this.__h.push(l), b$1(this));
    }, d$1.prototype.forceUpdate = function (n) {
      this.__v && (this.__e = !0, n && this.__h.push(n), b$1(this));
    }, d$1.prototype.render = p$1, t$1 = [], g$2.__r = 0, r$2 = 0;

    var o$1 = 0;

    function e$1(_, e, n, t, f) {
      var l,
          s,
          u = {};

      for (s in e) "ref" == s ? l = e[s] : u[s] = e[s];

      var a = {
        type: _,
        props: u,
        key: n,
        ref: l,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: --o$1,
        __source: f,
        __self: t
      };
      if ("function" == typeof _ && (l = _.defaultProps)) for (s in l) void 0 === u[s] && (u[s] = l[s]);
      return l$1.vnode && l$1.vnode(a), a;
    }

    var t,
        r$1,
        u,
        i,
        o = 0,
        c = [],
        f = [],
        e = l$1.__b,
        a = l$1.__r,
        v = l$1.diffed,
        l = l$1.__c,
        m = l$1.unmount;

    function d(t, u) {
      l$1.__h && l$1.__h(r$1, t, o || u), o = 0;
      var i = r$1.__H || (r$1.__H = {
        __: [],
        __h: []
      });
      return t >= i.__.length && i.__.push({
        __V: f
      }), i.__[t];
    }

    function p(n) {
      return o = 1, y(z$1, n);
    }

    function y(n, u, i) {
      var o = d(t++, 2);

      if (o.t = n, !o.__c && (o.__ = [i ? i(u) : z$1(void 0, u), function (n) {
        var t = o.__N ? o.__N[0] : o.__[0],
            r = o.t(t, n);
        t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
      }], o.__c = r$1, !r$1.u)) {
        r$1.u = !0;
        var c = r$1.shouldComponentUpdate;

        r$1.shouldComponentUpdate = function (n, t, r) {
          if (!o.__c.__H) return !0;

          var u = o.__c.__H.__.filter(function (n) {
            return n.__c;
          });

          if (u.every(function (n) {
            return !n.__N;
          })) return !c || c.call(this, n, t, r);
          var i = !1;
          return u.forEach(function (n) {
            if (n.__N) {
              var t = n.__[0];
              n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
            }
          }), !!i && (!c || c.call(this, n, t, r));
        };
      }

      return o.__N || o.__;
    }

    function h(u, i) {
      var o = d(t++, 3);
      !l$1.__s && w$1(o.__H, i) && (o.__ = u, o.i = i, r$1.__H.__h.push(o));
    }

    function s(u, i) {
      var o = d(t++, 4);
      !l$1.__s && w$1(o.__H, i) && (o.__ = u, o.i = i, r$1.__h.push(o));
    }

    function _(n) {
      return o = 5, F$1(function () {
        return {
          current: n
        };
      }, []);
    }

    function F$1(n, r) {
      var u = d(t++, 7);
      return w$1(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;
    }

    function T$1(n, t) {
      return o = 8, F$1(function () {
        return n;
      }, t);
    }

    function q$1(n) {
      var u = r$1.context[n.__c],
          i = d(t++, 9);
      return i.c = n, u ? (null == i.__ && (i.__ = !0, u.sub(r$1)), u.props.value) : n.__;
    }

    function b() {
      for (var t; t = c.shift();) if (t.__P && t.__H) try {
        t.__H.__h.forEach(j$1), t.__H.__h.forEach(k), t.__H.__h = [];
      } catch (r) {
        t.__H.__h = [], l$1.__e(r, t.__v);
      }
    }

    l$1.__b = function (n) {
      r$1 = null, e && e(n);
    }, l$1.__r = function (n) {
      a && a(n), t = 0;
      var i = (r$1 = n.__c).__H;
      i && (u === r$1 ? (i.__h = [], r$1.__h = [], i.__.forEach(function (n) {
        n.__N && (n.__ = n.__N), n.__V = f, n.__N = n.i = void 0;
      })) : (i.__h.forEach(j$1), i.__h.forEach(k), i.__h = [])), u = r$1;
    }, l$1.diffed = function (t) {
      v && v(t);
      var o = t.__c;
      o && o.__H && (o.__H.__h.length && (1 !== c.push(o) && i === l$1.requestAnimationFrame || ((i = l$1.requestAnimationFrame) || function (n) {
        var t,
            r = function () {
          clearTimeout(u), g$1 && cancelAnimationFrame(t), setTimeout(n);
        },
            u = setTimeout(r, 100);

        g$1 && (t = requestAnimationFrame(r));
      })(b)), o.__H.__.forEach(function (n) {
        n.i && (n.__H = n.i), n.__V !== f && (n.__ = n.__V), n.i = void 0, n.__V = f;
      })), u = r$1 = null;
    }, l$1.__c = function (t, r) {
      r.some(function (t) {
        try {
          t.__h.forEach(j$1), t.__h = t.__h.filter(function (n) {
            return !n.__ || k(n);
          });
        } catch (u) {
          r.some(function (n) {
            n.__h && (n.__h = []);
          }), r = [], l$1.__e(u, t.__v);
        }
      }), l && l(t, r);
    }, l$1.unmount = function (t) {
      m && m(t);
      var r,
          u = t.__c;
      u && u.__H && (u.__H.__.forEach(function (n) {
        try {
          j$1(n);
        } catch (n) {
          r = n;
        }
      }), r && l$1.__e(r, u.__v));
    };
    var g$1 = "function" == typeof requestAnimationFrame;

    function j$1(n) {
      var t = r$1,
          u = n.__c;
      "function" == typeof u && (n.__c = void 0, u()), r$1 = t;
    }

    function k(n) {
      var t = r$1;
      n.__c = n.__(), r$1 = t;
    }

    function w$1(n, t) {
      return !n || n.length !== t.length || t.some(function (t, r) {
        return t !== n[r];
      });
    }

    function z$1(n, t) {
      return "function" == typeof t ? t(n) : t;
    }

    function S(n, t) {
      for (var e in t) n[e] = t[e];

      return n;
    }

    function g(n, t) {
      for (var e in n) if ("__source" !== e && !(e in t)) return !0;

      for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;

      return !1;
    }

    function C(n) {
      this.props = n;
    }

    function E(n, t) {
      function e(n) {
        var e = this.props.ref,
            r = e == n.ref;
        return !r && e && (e.call ? e(null) : e.current = null), t ? !t(this.props, n) || !r : g(this.props, n);
      }

      function r(t) {
        return this.shouldComponentUpdate = e, h$1(n, t);
      }

      return r.displayName = "Memo(" + (n.displayName || n.name) + ")", r.prototype.isReactComponent = !0, r.__f = !0, r;
    }

    (C.prototype = new d$1()).isPureReactComponent = !0, C.prototype.shouldComponentUpdate = function (n, t) {
      return g(this.props, n) || g(this.state, t);
    };
    var w = l$1.__b;

    l$1.__b = function (n) {
      n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), w && w(n);
    };

    var A = l$1.__e;

    l$1.__e = function (n, t, e, r) {
      if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
      A(n, t, e, r);
    };

    var O = l$1.unmount;

    function T() {
      this.__u = 0, this.t = null, this.__b = null;
    }

    function L(n) {
      var t = n.__.__c;
      return t && t.__a && t.__a(n);
    }

    function D() {
      this.u = null, this.o = null;
    }

    l$1.unmount = function (n) {
      var t = n.__c;
      t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), O && O(n);
    }, (T.prototype = new d$1()).__c = function (n, t) {
      var e = t.__c,
          r = this;
      null == r.t && (r.t = []), r.t.push(e);

      var u = L(r.__v),
          o = !1,
          i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };

      e.__R = i;

      var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;

            r.__v.__k[0] = function n(t, e, r) {
              return t && (t.__v = null, t.__k = t.__k && t.__k.map(function (t) {
                return n(t, e, r);
              }), t.__c && t.__c.__P === e && (t.__e && r.insertBefore(t.__e, t.__d), t.__c.__e = !0, t.__c.__P = r)), t;
            }(n, n.__c.__P, n.__c.__O);
          }

          var t;

          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
          c = !0 === t.__h;

      r.__u++ || c || r.setState({
        __a: r.__b = r.__v.__k[0]
      }), n.then(i, i);
    }, T.prototype.componentWillUnmount = function () {
      this.t = [];
    }, T.prototype.render = function (n, t) {
      if (this.__b) {
        if (this.__v.__k) {
          var e = document.createElement("div"),
              r = this.__v.__k[0].__c;

          this.__v.__k[0] = function n(t, e, r) {
            return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach(function (n) {
              "function" == typeof n.__c && n.__c();
            }), t.__c.__H = null), null != (t = S({}, t)).__c && (t.__c.__P === r && (t.__c.__P = e), t.__c = null), t.__k = t.__k && t.__k.map(function (t) {
              return n(t, e, r);
            })), t;
          }(this.__b, e, r.__O = r.__P);
        }

        this.__b = null;
      }

      var u = t.__a && h$1(p$1, null, n.fallback);
      return u && (u.__h = null), [h$1(p$1, null, t.__a ? null : n.children), u];
    };

    var F = function (n, t, e) {
      if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
        for (; e.length > 3;) e.pop()();

        if (e[1] < e[0]) break;
        n.u = e = e[2];
      }
    };

    (D.prototype = new d$1()).__a = function (n) {
      var t = this,
          e = L(t.__v),
          r = t.o.get(n);
      return r[0]++, function (u) {
        var o = function () {
          t.props.revealOrder ? (r.push(u), F(t, n, r)) : u();
        };

        e ? e(o) : o();
      };
    }, D.prototype.render = function (n) {
      this.u = null, this.o = new Map();
      var t = x(n.children);
      n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

      for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);

      return n.children;
    }, D.prototype.componentDidUpdate = D.prototype.componentDidMount = function () {
      var n = this;
      this.o.forEach(function (t, e) {
        F(n, e, t);
      });
    };

    var W = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        P = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        $ = "undefined" != typeof document,
        j = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };

    function z(n, t, e) {
      return null == t.__k && (t.textContent = ""), P$1(n, t), "function" == typeof e && e(), n ? n.__c : null;
    }

    d$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (n) {
      Object.defineProperty(d$1.prototype, n, {
        configurable: !0,
        get: function () {
          return this["UNSAFE_" + n];
        },
        set: function (t) {
          Object.defineProperty(this, n, {
            configurable: !0,
            writable: !0,
            value: t
          });
        }
      });
    });
    var H = l$1.event;

    function Z() {}

    function Y() {
      return this.cancelBubble;
    }

    function q() {
      return this.defaultPrevented;
    }

    l$1.event = function (n) {
      return H && (n = H(n)), n.persist = Z, n.isPropagationStopped = Y, n.isDefaultPrevented = q, n.nativeEvent = n;
    };

    var J = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
        K = l$1.vnode;

    l$1.vnode = function (n) {
      var t = n.type,
          e = n.props,
          r = e;

      if ("string" == typeof t) {
        var u = -1 === t.indexOf("-");

        for (var o in r = {}, e) {
          var i = e[o];
          $ && "children" === o && "noscript" === t || "value" === o && "defaultValue" in e && null == i || ("defaultValue" === o && "value" in e && null == e.value ? o = "value" : "download" === o && !0 === i ? i = "" : /ondoubleclick/i.test(o) ? o = "ondblclick" : /^onchange(textarea|input)/i.test(o + t) && !j(e.type) ? o = "oninput" : /^onfocus$/i.test(o) ? o = "onfocusin" : /^onblur$/i.test(o) ? o = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(o) ? o = o.toLowerCase() : u && P.test(o) ? o = o.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === i && (i = void 0), /^oninput$/i.test(o) && (o = o.toLowerCase(), r[o] && (o = "oninputCapture")), r[o] = i);
        }

        "select" == t && r.multiple && Array.isArray(r.value) && (r.value = x(e.children).forEach(function (n) {
          n.props.selected = -1 != r.value.indexOf(n.props.value);
        })), "select" == t && null != r.defaultValue && (r.value = x(e.children).forEach(function (n) {
          n.props.selected = r.multiple ? -1 != r.defaultValue.indexOf(n.props.value) : r.defaultValue == n.props.value;
        })), n.props = r, e.class != e.className && (J.enumerable = "className" in e, null != e.className && (r.class = e.className), Object.defineProperty(r, "className", J));
      }

      n.$$typeof = W, K && K(n);
    };

    var Q = l$1.__r;

    l$1.__r = function (n) {
      Q && Q(n), n.__c;
    };

    /**
     * Debug hook.
     *
     * Given a value or set of values, emits a console error if any of them change from one render to the next.
     *
     * Eventually, when useEvent lands, we hopefully won't need this.
     */

    function useEnsureStability(parentHookName) {
      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }

      useHelper(values.length, 0);
      values.forEach(useHelper);
      return;

      function useHelper(value, index) {
        // Make sure that the provided functions are perfectly stable across renders
        const helperToEnsureStability = _(value);
        const shownError = _(false);

        if (helperToEnsureStability.current != value) {
          if (!shownError.current) {
            /* eslint-disable no-debugger */
            debugger;
            console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
            shownError.current = true;
          }
        }
      }
    }
    /**
     * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
     *
     * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
     *
     * To summarize, it's like a `useState`-`useEffect` mashup:
     *
     * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
     * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
     * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
     * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
     *
     * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
     *
     * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @returns
     */


    function usePassiveState(onChange, getInitialValue) {
      const valueRef = _(Unset$1);
      const warningRef = _(false);
      const cleanupCallbackRef = _(undefined); // Make sure that the provided functions are perfectly stable across renders

      useEnsureStability("usePassiveState", onChange, getInitialValue); // Shared between "dependency changed" and "component unmounted".

      const onShouldCleanUp = T$1(() => {
        const cleanupCallback = cleanupCallbackRef.current;
        if (cleanupCallback) cleanupCallback();
      }, []); // There are a couple places where we'd like to use our initial
      // value in place of having no value at all yet.
      // This is the shared code for that, used on mount and whenever
      // getValue is called.

      const tryEnsureValue = T$1(() => {
        if (valueRef.current === Unset$1 && getInitialValue != undefined) {
          try {
            var _onChange;

            const initialValue = getInitialValue();
            valueRef.current = initialValue;
            cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
          } catch (ex) {// Exceptions are intentional to allow bailout (without exposing the Unset symbol)
          }
        }
      }, [
        /* getInitialValue and onChange intentionally omitted */
      ]);
      const getValue = T$1(() => {
        if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component."); // The first time we call getValue, if we haven't been given a value yet,
        // (and we were given an initial value to use)
        // return the initial value instead of nothing.

        if (valueRef.current === Unset$1) tryEnsureValue();
        return valueRef.current === Unset$1 ? undefined : valueRef.current;
      }, []);
      s(() => {
        // Make sure we've run our effect at least once on mount.
        // (If we have an initial value, of course)
        tryEnsureValue();
      }, []); // The actual code the user calls to (possibly) run a new effect.

      const r = _({
        microtaskQueued: false,
        arg: undefined,
        prevDep: undefined
      });
      const setValue = T$1(arg => {
        r.current.prevDep = valueRef.current === Unset$1 ? undefined : getValue();
        r.current.arg = arg;

        if (!r.current.microtaskQueued) {
          r.current.microtaskQueued = true;
          setTimeout(() => {
            r.current.microtaskQueued = false;
            const prevDep = r.current.prevDep;
            const arg = r.current.arg;
            const dep = arg instanceof Function ? arg(prevDep) : arg;

            if (dep !== valueRef.current) {
              // Indicate to the user that they shouldn't call getValue during onChange
              warningRef.current = true;

              try {
                var _onChange2;

                // Call any registered cleanup function
                onShouldCleanUp();
                cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(dep, prevDep)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
                valueRef.current = dep;
              } catch (ex) {
                throw ex;
              } finally {
                // Allow the user to normally call getValue again
                warningRef.current = false;
              }
            }
          }, 0);
        }
      }, []);
      return [getValue, setValue];
    }
    const Unset$1 = Symbol(); // Easy constants for getInitialValue

    function returnTrue() {
      return true;
    }
    function returnFalse$1() {
      return false;
    }
    function returnNull() {
      return null;
    }
    function returnZero() {
      return 0;
    }

    function useMergedChildren(_ref, _ref2) {
      let {
        children: lhs
      } = _ref;
      let {
        children: rhs
      } = _ref2;

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return h$1(p$1, {}, lhs, rhs);
      }
    }

    function r(e) {
      var t,
          f,
          n = "";
      if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
      return n;
    }

    function clsx() {
      for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);

      return n;
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */

    function useMergedClasses(_ref, _ref2) {
      let {
        class: lhsClass,
        className: lhsClassName
      } = _ref;
      let {
        class: rhsClass,
        className: rhsClassName
      } = _ref2;

      // Note: For the sake of forward compatibility, this function is labelled as
      // a hook, but as it uses no other hooks it technically isn't one.
      if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
        const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
        const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
        const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
        return Array.from(allClasses).join(" ");
      } else {
        return undefined;
      }
    }

    function processRef(instance, ref) {
      if (typeof ref === "function") {
        ref(instance);
      } else if (ref != null) {
        ref.current = instance;
      } else {
        /* eslint-disable no-debugger */
        debugger;
        console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
      }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */


    function useMergedRefs(_ref, _ref2) {
      let {
        ref: rhs
      } = _ref;
      let {
        ref: lhs
      } = _ref2;
      const combined = T$1(current => {
        processRef(current, lhs);
        processRef(current, rhs);
      }, [lhs, rhs]);

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return combined;
      }
    }

    function styleStringToObject(style) {
      // TODO: This sucks D:
      return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
    }
    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */


    function useMergedStyles(lhs, rhs) {
      var _lhs$style, _rhs$style2;

      // Easy case, when there are no styles to merge return nothing.
      if (!(lhs !== null && lhs !== void 0 && lhs.style) && !(rhs !== null && rhs !== void 0 && rhs.style)) return undefined;

      if (typeof lhs != typeof rhs) {
        // Easy cases, when one is null and the other isn't.
        if (lhs !== null && lhs !== void 0 && lhs.style && !(rhs !== null && rhs !== void 0 && rhs.style)) return lhs.style;
        if (!(lhs !== null && lhs !== void 0 && lhs.style) && rhs !== null && rhs !== void 0 && rhs.style) return rhs.style; // They're both non-null but different types.
        // Convert the string type to an object bag type and run it again.

        if (lhs !== null && lhs !== void 0 && lhs.style && rhs !== null && rhs !== void 0 && rhs.style) {
          // (useMergedStyles isn't a true hook -- this isn't a violation)
          if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") return useMergedStyles({
            style: styleStringToObject(lhs === null || lhs === void 0 ? void 0 : lhs.style)
          }, rhs);
          if (typeof (rhs === null || rhs === void 0 ? void 0 : rhs.style) == "string") return useMergedStyles(lhs, {
            style: styleStringToObject(rhs === null || rhs === void 0 ? void 0 : rhs.style)
          });
        } // Logic???


        return undefined;
      } // They're both strings, just concatenate them.


      if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") {
        var _rhs$style;

        return `${lhs.style};${(_rhs$style = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style !== void 0 ? _rhs$style : ""}`;
      } // They're both objects, just merge them.


      return { ...((_lhs$style = lhs === null || lhs === void 0 ? void 0 : lhs.style) !== null && _lhs$style !== void 0 ? _lhs$style : {}),
        ...((_rhs$style2 = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style2 !== void 0 ? _rhs$style2 : {})
      };
    }

    let log = console.warn;
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */

    function useMergedProps(lhsAll, rhsAll) {
      // First, separate the props we were given into two groups:
      // lhsAll and rhsAll contain all the props we were given, and
      // lhsMisc and rhsMisc contain all props *except* for the easy ones
      // like className and style that we already know how to merge.
      const {
        children: _lhsChildren,
        class: _lhsClass,
        className: _lhsClassName,
        style: _lhsStyle,
        ref: _lhsRef,
        ...lhsMisc
      } = lhsAll;
      const {
        children: _rhsChildren,
        class: _rhsClass,
        className: _rhsClassName,
        style: _rhsStyle,
        ref: _rhsRef,
        ...rhsMisc
      } = rhsAll;
      const ret = { ...lhsMisc,
        ref: useMergedRefs(lhsAll, rhsAll),
        style: useMergedStyles(lhsAll, rhsAll),
        className: useMergedClasses(lhsAll, rhsAll),
        children: useMergedChildren(lhsAll, rhsAll)
      };
      if (ret.ref === undefined) delete ret.ref;
      if (ret.style === undefined) delete ret.style;
      if (ret.className === undefined) delete ret.className;
      if (ret.children === undefined) delete ret.children; // Now, do *everything* else
      // Merge every remaining existing entry in lhs with what we've already put in ret.
      //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];

      const rhsEntries = Object.entries(rhsMisc);

      for (const [rhsKeyU, rhsValue] of rhsEntries) {
        const rhsKey = rhsKeyU;
        const lhsValue = lhsMisc[rhsKey];

        if (typeof lhsValue === "function" || typeof rhsValue === "function") {
          // They're both functions that can be merged (or one's a function and the other's null).
          // Not an *easy* case, but a well-defined one.
          const merged = mergeFunctions(lhsValue, rhsValue);
          ret[rhsKey] = merged;
        } else {
          // Uh...we're here because one of them's null, right?
          if (lhsValue == null && rhsValue == null) {
            if (rhsValue === null && lhsValue === undefined) ret[rhsKey] = rhsValue;else ret[rhsKey] = lhsValue;
          }

          if (lhsValue == null) ret[rhsKey] = rhsValue;else if (rhsValue == null) ret[rhsKey] = lhsValue;else if (rhsValue == lhsValue) ; else {
            var _log;

            // Ugh.
            // No good strategies here, just log it if requested
            (_log = log) === null || _log === void 0 ? void 0 : _log(`The prop "${rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
            ret[rhsKey] = rhsValue;
          }
        }
      }

      return ret;
    }

    function mergeFunctions(lhs, rhs) {
      if (!lhs) return rhs;
      if (!rhs) return lhs;
      return function () {
        const lv = lhs(...arguments);
        const rv = rhs(...arguments);
        if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
      };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */

    function useRefElement(args) {
      const {
        onElementChange,
        onMount,
        onUnmount
      } = args !== null && args !== void 0 ? args : {};
      useEnsureStability("useRefElement", onElementChange, onMount, onUnmount); // Called (indirectly) by the ref that the element receives.

      const handler = T$1((e, prevValue) => {
        let cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
        if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
        if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
        return cleanup;
      }, []); // Let us store the actual (reference to) the element we capture

      const [getElement, setElement] = usePassiveState(handler, returnNull);
      const useRefElementProps = T$1(props => useMergedProps({
        ref: setElement
      }, props), []); // Return both the element and the hook that modifies 
      // the props and allows us to actually find the element

      return {
        useRefElementProps,
        getElement
      };
    }

    const activeElementUpdaters = new Map();
    const lastActiveElementUpdaters = new Map();
    const windowFocusedUpdaters = new Map();
    const windowsFocusedUpdaters = new Map();
    const microtasks = new Set(); // The focusin and focusout events often fire syncronously in the middle of running code.
    // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
    // For the purpose of improving stability, we debounce all focus events to the next microtask.

    function forEachUpdater(window, map, value) {
      if (!microtasks.has(map)) {
        microtasks.add(map);
        queueMicrotask(() => {
          microtasks.delete(map);
          const updaters = map.get(window);

          if (updaters) {
            for (const updater of updaters) {
              updater === null || updater === void 0 ? void 0 : updater(value);
            }
          }
        });
      }
    }

    function focusout(e) {
      const window = e.target.ownerDocument.defaultView;

      if (e.relatedTarget == null) {
        forEachUpdater(window, activeElementUpdaters, null);
      }
    }

    function focusin(e) {
      const window = e.target.ownerDocument.defaultView;
      const currentlyFocusedElement = e.target;
      forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
      forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
    }

    function windowFocus(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, true);
      forEachUpdater(window, windowFocusedUpdaters, true);
    }

    function windowBlur(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, false);
      forEachUpdater(window, windowFocusedUpdaters, false);
    }
    /**
     * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
     * * `getActiveElement()`
     * * `getLastActiveElement()`
     * * `getWindowFocused()`
     *
     * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
     *
     * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
     *
     * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
     */


    function useActiveElement(_ref) {
      let {
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        onMount,
        onUnmount,
        onMountChange
      } = _ref;
      useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, onMountChange, onMount, onUnmount);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onMount,
        onUnmount,
        onElementChange: T$1((element, prevValue) => {
          onMountChange === null || onMountChange === void 0 ? void 0 : onMountChange(element, prevValue);

          if (element) {
            var _activeElementUpdater, _activeElementUpdater2, _activeElementUpdater3, _lastActiveElementUpd, _windowFocusedUpdater;

            const document = element.ownerDocument;
            const window = document === null || document === void 0 ? void 0 : document.defaultView;

            if (((_activeElementUpdater = (_activeElementUpdater2 = activeElementUpdaters.get(window)) === null || _activeElementUpdater2 === void 0 ? void 0 : _activeElementUpdater2.size) !== null && _activeElementUpdater !== void 0 ? _activeElementUpdater : 0) === 0) {
              document === null || document === void 0 ? void 0 : document.addEventListener("focusin", focusin, {
                passive: true
              });
              document === null || document === void 0 ? void 0 : document.addEventListener("focusout", focusout, {
                passive: true
              });
              window === null || window === void 0 ? void 0 : window.addEventListener("focus", windowFocus, {
                passive: true
              });
              window === null || window === void 0 ? void 0 : window.addEventListener("blur", windowBlur, {
                passive: true
              });
            } // Add them even if they're undefined to more easily
            // manage the ">0 means don't add handlers" logic.


            const localActiveElementUpdaters = (_activeElementUpdater3 = activeElementUpdaters.get(window)) !== null && _activeElementUpdater3 !== void 0 ? _activeElementUpdater3 : new Set();
            const localLastActiveElementUpdaters = (_lastActiveElementUpd = lastActiveElementUpdaters.get(window)) !== null && _lastActiveElementUpd !== void 0 ? _lastActiveElementUpd : new Set();
            const localWindowFocusedUpdaters = (_windowFocusedUpdater = windowFocusedUpdaters.get(window)) !== null && _windowFocusedUpdater !== void 0 ? _windowFocusedUpdater : new Set();
            localActiveElementUpdaters.add(setActiveElement);
            localLastActiveElementUpdaters.add(setLastActiveElement);
            localWindowFocusedUpdaters.add(setWindowFocused);
            activeElementUpdaters.set(window, localActiveElementUpdaters);
            lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
            windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
            return () => {
              activeElementUpdaters.get(window).delete(setActiveElement);
              lastActiveElementUpdaters.get(window).delete(setLastActiveElement);
              windowFocusedUpdaters.get(window).delete(setWindowFocused);

              if (activeElementUpdaters.size === 0) {
                document === null || document === void 0 ? void 0 : document.removeEventListener("focusin", focusin);
                document === null || document === void 0 ? void 0 : document.removeEventListener("focusout", focusout);
                window === null || window === void 0 ? void 0 : window.removeEventListener("focus", windowFocus);
                window === null || window === void 0 ? void 0 : window.removeEventListener("blur", windowBlur);
              }
            };
          }
        }, [])
      });
      const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
      const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
      const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
      return {
        getElement,
        useActiveElementProps: useRefElementProps,
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }

    const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";

    function base64(value) {
      return Table[value];
    }

    function random6Bits() {
      return Math.floor(Math.random() * 0b1000000);
    }

    function random64Bits() {
      return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     *
     *
     * (This is here, in this particular file, to avoid circular dependencies
     * without also making a utilities file.
     * Once we can remove this hook, we can put this function back with useRandomId)
     */


    function generateRandomId(prefix) {
      return `${prefix !== null && prefix !== void 0 ? prefix : "id-"}${random64Bits().map(n => base64(n)).join("")}`;
    }
    const previousInputs = new Map();
    const toRun = new Map(); // TODO: Whether this goes in options.diffed or options._commit
    // is a post-suspense question.
    // Right now, using options._commit has the problem of running
    // *after* refs are applied, but we need to come before even that
    // so `ref={someStableFunction}` works.
    // 
    // Also it's private.
    //
    // ...
    // Well, useEvent or whatever is finally, finally 4 years later finally here
    // which is cool and means we won't need this at all soon.
    // So for now we'll stick with diff to prevent any weirdness with
    // commit being private and all.

    const commitName = "diffed";
    const originalCommit = l$1[commitName];

    const newCommit = function () {
      for (const [id, effectInfo] of toRun) {
        const oldInputs = previousInputs.get(id);

        if (argsChanged(oldInputs, effectInfo.inputs)) {
          var _effectInfo$cleanup;

          (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
          effectInfo.cleanup = effectInfo.effect();
          previousInputs.set(id, effectInfo.inputs);
        }
      }

      toRun.clear();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
    };

    l$1[commitName] = newCommit;
    /**
     * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
     *
     * Every render, we send the arguments to be evaluated after diffing has completed,
     * which happens before.
     *
     * @param effect
     * @param inputs
     */

    function useBeforeLayoutEffect(effect, inputs) {
      /*(() => {
          const cleanup = useRef<void | (() => void) | null>(null);
          const prevArgsRef = useRef<Inputs>(null!);
          if (argsChanged(inputs, prevArgsRef.current)) {
              prevArgsRef.current = inputs!;
              if (cleanup.current)
                  cleanup.current();
              cleanup.current = effect();
          }
      })();*/
      const [id] = p(() => generateRandomId());
      toRun.set(id, {
        effect,
        inputs,
        cleanup: null
      });
      h(() => {
        return () => {
          toRun.delete(id);
          previousInputs.delete(id);
        };
      }, [id]);
    }

    function argsChanged(oldArgs, newArgs) {
      return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
    }

    const Unset = Symbol("unset");
    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * This uses `options.diffed` in order to run before everything, even
     * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
     *
     * @param value
     * @returns
     */

    function useStableGetter(value) {
      const ref = _(Unset);
      useBeforeLayoutEffect(() => {
        ref.current = value;
      }, [value]);
      return T$1(() => {
        if (ref.current === Unset) {
          throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
        }

        return ref.current;
      }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * Do not use during the render phase!  `useLayoutEffect` is fine though.
     */

    function useStableCallback(fn) {
      const currentCallbackGetter = useStableGetter(fn);
      return T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []);
    }

    B(null);

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */

    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();

    /** Built-in value references. */

    var Symbol$1 = root.Symbol;

    /** Built-in value references. */

    Symbol$1 ? Symbol$1.toStringTag : undefined;

    /** Built-in value references. */

    Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */

    function useState(initialState) {
      // We keep both, but overrride the `setState` functionality
      const [state, setStateP] = p(initialState);
      const ref = _(state); // Hijack the normal setter function 
      // to also set our ref to the new value

      const setState = T$1(value => {
        if (typeof value === "function") {
          const callback = value;
          setStateP(prevValue => {
            const nextValue = callback(prevValue);
            ref.current = nextValue;
            return nextValue;
          });
        } else {
          ref.current = value;
          setStateP(value);
        }
      }, []);

      const getState = () => {
        return ref.current;
      };

      console.assert(ref.current === state || typeof state === "number" && isNaN(state));
      return [state, setState, getState];
    }

    /**
     * Wrap the native `useEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     * @param impl You can choose whether to use `useEffect` or `useLayoutEffect` by
     * passing one of them as this argument. By default, it's `useEffect`.
     */

    function useEffect(effect, inputs) {
      let impl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : h;
      const prevInputs = _(undefined);

      const effect2 = () => {
        const changes = [];

        if (inputs && prevInputs.current) {
          for (let i = 0; i < Math.max(prevInputs.current.length, inputs.length); ++i) {
            if (prevInputs.current[i] != inputs[i]) changes[i] = {
              from: prevInputs.current[i],
              to: inputs[i]
            };
          }
        }

        const ret = effect(prevInputs.current, changes);
        prevInputs.current = inputs;
        return ret;
      };

      impl(effect2, inputs);
    }

    /**
     * Wrap the native `useLayoutEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     */

    function useLayoutEffect(effect, inputs) {
      return useEffect(effect, inputs, s);
    }

    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is designed to be lightweight, in that the parent keeps no state
     * and runs no effects.  Each child *does* run an effect, but with no state
     * changes unless you explicitly request them.
     *
     *
     */


    function useManagedChildren(_ref) {
      let {
        onAfterChildLayoutEffect,
        onChildrenMountChange
      } = _ref;
      useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
      const getHighestIndex = T$1(() => {
        return managedChildrenArray.current.arr.length - 1;
      }, []); // All the information we have about our children is stored in this **stable** array.
      // Any mutations to this array **DO NOT** trigger any sort of a re-render.

      const managedChildrenArray = _({
        arr: [],
        rec: {}
      }); // For indirect access to each child
      // Compare getManagedChildInfo
      // TODO: The primary use for this is flaggable closest fits
      // which need to search all children for that closest fit.
      // It would be nice if there was something better for that.

      const forEachChild = T$1(f => {
        for (const child of managedChildrenArray.current.arr) {
          f(child);
        }

        for (const field in managedChildrenArray.current.rec) {
          const child = managedChildrenArray.current.rec[field];
          if (child) f(child);
        }
      }, []); // Retrieves the information associated with the child with the given index.
      // `undefined` if not child there, or it's unmounted.

      const getManagedChildInfo = T$1(index => {
        if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
      }, []); // tl;dr this is a way to have run useLayoutEffect once after all N children
      // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
      // ourselves because of having a `childCount` state or anything similar.
      //
      // When the child count ref updates, we want the parent to also run an effect
      // to maybe do something with all these children that just mounted.
      // The easiest way would be useEffect(..., [childCount]) but
      // that would require us having a childCount state, then calling
      // setChildCount and re-rendering every time children mount
      // (only one re-render at a time unless children are staggered, but still)
      // 
      // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
      // to emulate running ULE on the parent. Only the first child will actually queue
      // the microtask (by checking hasRemoteULE first) so that the "effect" only
      // runs once. When it's done, hasRemoteULE is reset so it can run again if
      // more children mount/unmount.

      const hasRemoteULEChildMounted = _(null);
      const remoteULEChildChangedCausers = _(new Set());
      const remoteULEChildChanged = T$1(index => {
        if (remoteULEChildChangedCausers.current.size == 0) {
          queueMicrotask(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }

        remoteULEChildChangedCausers.current.add(index);
        return () => {};
      }, [
        /* Must remain stable */
      ]);
      const remoteULEChildMounted = T$1((index, mounted) => {
        if (!hasRemoteULEChildMounted.current) {
          hasRemoteULEChildMounted.current = {
            mounts: new Set(),
            unmounts: new Set()
          };
          queueMicrotask(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            hasRemoteULEChildMounted.current = null;
          });
        }

        if (!mounted) {
          if (typeof index == "number") delete managedChildrenArray.current.arr[index];else delete managedChildrenArray.current.rec[index];
        }

        hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
      }, [
        /* Must remain stable */
      ]);
      const useManagedChild = T$1(_ref2 => {
        let {
          info
        } = _ref2;
        // Any time our child props change, make that information available
        // the parent if they need it.
        // The parent can listen for all updates and only act on the ones it cares about,
        // and multiple children updating in the same tick will all be sent at once.
        useLayoutEffect(() => {
          // Insert this information in-place
          if (typeof info.index == "number") managedChildrenArray.current.arr[info.index] = { ...info
          };else managedChildrenArray.current.rec[info.index] = { ...info
          };
          return remoteULEChildChanged(info.index);
        }, [...Object.entries(info).flat()]); // When we mount, notify the parent via queueMicrotask
        // (every child does this, so everything's coordinated to only queue a single microtask per tick)
        // Do the same on unmount.
        // Note: It's important that this comes AFTER remoteULEChildChanged
        // so that remoteULEChildMounted has access to all the info on mount.

        useLayoutEffect(() => {
          return remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, true);
        }, [info.index]);
      }, [
        /* Must remain stable */
      ]);
      const managedChildren = _({ ...{
          _: managedChildrenArray.current
        },
        forEach: forEachChild,
        getAt: getManagedChildInfo,
        getHighestIndex: getHighestIndex,
        sliceSort: compare => {
          return managedChildrenArray.current.arr.slice().sort(compare);
        }
      });
      return {
        useManagedChild,
        children: managedChildren.current
      };
    }
    /**
     * An extension to useManagedChildren that handles the following common case:
     * 1. You have a bunch of children
     * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
     * 3. The parent has control over who is "selected" via a numerical index.
     *
     * This hook allows for much easier control over selection management.
     *
     *
     * @param param0
     * @returns
     */

    function useChildrenFlag(_ref3) {
      let {
        children,
        initialIndex,
        closestFit,
        onIndexChange,
        key,
        fitNullToZero
      } = _ref3;
      useEnsureStability("useChildrenFlag", closestFit, onIndexChange, key);
      const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange, T$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : fitNullToZero ? 0 : null, []));
      const [getRequestedIndex, setRequestedIndex] = usePassiveState(null, T$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : fitNullToZero ? 0 : null, []));
      const getFitNullToZero = useStableGetter(fitNullToZero); // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)

      const getClosestFit = T$1(requestedIndex => {
        let closestDistance = Infinity;
        let closestIndex = null;
        children.forEach(child => {
          if (child.flags[key].isValid()) {
            const newDistance = Math.abs(child.index - requestedIndex);

            if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
              closestDistance = newDistance;
              closestIndex = child.index;
            }
          }
        });
        return closestIndex;
      }, [
        /* Must remain stable! */
      ]); // Any time a child mounts/unmounts, we need to double-check to see if that affects 
      // the "currently selected" (or whatever) index.  The two cases we're looking for:
      // 1. The currently selected child unmounted
      // 2. A child mounted, and it mounts with the index we're looking for

      const onChildrenMountChange = useStableCallback((mounted, unmounted) => {
        const requestedIndex = getRequestedIndex();
        const currentIndex = getCurrentIndex();
        const currentChild = currentIndex == null ? null : children.getAt(currentIndex); // We've not actually selected our requested selection.
        // Maybe one of the children that just mounted has it?

        if (currentIndex != requestedIndex && requestedIndex != null) {
          if (mounted.has(requestedIndex)) {
            var _children$getAt;

            currentChild === null || currentChild === void 0 ? void 0 : currentChild.flags[key].set(false);
            (_children$getAt = children.getAt(requestedIndex)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.flags[key].set(true);
          }
        } else if (currentIndex != null && unmounted.has(currentIndex)) {
          // Whatever's currently selected has must unmounted.
          currentChild === null || currentChild === void 0 ? void 0 : currentChild.flags[key].set(false);

          if (!closestFit || requestedIndex == null) ; else {
            // If we're in best-fit mode, then try to find another
            // child to select.
            const closestFitIndex = getClosestFit(requestedIndex);

            if (closestFitIndex != null) {
              const closestFitChild = children.getAt(closestFitIndex);
              console.assert(closestFitChild != null, "Internal logic???");
              closestFitChild.flags[key].set(true);
            }
          }
        }
      });
      const changeIndex = T$1(arg => {
        console.log(`${key}: changeIndex(${arg})`);
        let requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
        if (requestedIndex == null && getFitNullToZero()) requestedIndex = 0;
        setRequestedIndex(requestedIndex);
        const currentIndex = getCurrentIndex();
        if (currentIndex == requestedIndex) return requestedIndex;
        let newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
        const oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex == null) {
          // Easy case
          console.log(`${key}: Setting #${currentIndex} to false (null)`);
          setCurrentIndex(null);
          oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : oldMatchingChild.flags[key].set(false);
          return null;
        } else {
          if (newMatchingChild && newMatchingChild.flags[key].isValid()) {
            console.log(`${key}: Setting #${currentIndex} to false and #${requestedIndex} to true`);
            setCurrentIndex(requestedIndex);
            oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : oldMatchingChild.flags[key].set(false);
            newMatchingChild.flags[key].set(true);
            return requestedIndex;
          } else {
            const closestFitIndex = getClosestFit(requestedIndex);
            setCurrentIndex(closestFitIndex);

            if (closestFitIndex != null) {
              newMatchingChild = children.getAt(closestFitIndex);
              console.assert(newMatchingChild != null, "Internal logic???");
              console.log(`${key}: Setting #${currentIndex} to false and #${closestFitIndex} to true (closest fit)`);
              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : oldMatchingChild.flags[key].set(false);
              newMatchingChild.flags[key].set(true);
              return closestFitIndex;
            } else {
              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : oldMatchingChild.flags[key].set(false);
              return null;
            }
          }
        }
      }, []);
      useLayoutEffect(() => {
        var _children$getAt2, _children$getAt2$flag;

        if (initialIndex != null) (_children$getAt2 = children.getAt(initialIndex)) === null || _children$getAt2 === void 0 ? void 0 : (_children$getAt2$flag = _children$getAt2.flags[key]) === null || _children$getAt2$flag === void 0 ? void 0 : _children$getAt2$flag.set(true);
      }, []);
      return {
        changeIndex,
        onChildrenMountChange,
        getCurrentIndex
      };
    }

    function getDocument(element) {
      var _ref, _ref2, _element$ownerDocumen;

      return (_ref = (_ref2 = (_element$ownerDocumen = element === null || element === void 0 ? void 0 : element.ownerDocument) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : document) !== null && _ref2 !== void 0 ? _ref2 : window.document) !== null && _ref !== void 0 ? _ref : globalThis.document;
    }

    function useElementSize(_ref) {
      let {
        getObserveBox,
        onSizeChange
      } = _ref;
      useEnsureStability("useElementSize", getObserveBox, onSizeChange);
      const [getSize, setSize] = usePassiveState(onSizeChange, returnNull);
      const currentObserveBox = _(undefined);
      const needANewObserver = T$1((element, observeBox) => {
        if (element) {
          const document = getDocument(element);
          const window = document.defaultView;

          const handleUpdate = () => {
            if (element.isConnected) {
              const {
                clientWidth,
                scrollWidth,
                offsetWidth,
                clientHeight,
                scrollHeight,
                offsetHeight,
                clientLeft,
                scrollLeft,
                offsetLeft,
                clientTop,
                scrollTop,
                offsetTop
              } = element;
              setSize({
                clientWidth,
                scrollWidth,
                offsetWidth,
                clientHeight,
                scrollHeight,
                offsetHeight,
                clientLeft,
                scrollLeft,
                offsetLeft,
                clientTop,
                scrollTop,
                offsetTop
              });
            }
          };

          if (window && "ResizeObserver" in window) {
            const observer = new ResizeObserver(_entries => {
              handleUpdate();
            });
            observer.observe(element, {
              box: observeBox
            });
            return () => observer.disconnect();
          } else {
            document.addEventListener("resize", handleUpdate, {
              passive: true
            });
            return () => document.removeEventListener("resize", handleUpdate);
          }
        }
      }, []);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: T$1(e => needANewObserver(e, getObserveBox === null || getObserveBox === void 0 ? void 0 : getObserveBox()), [])
      });
      h(() => {
        if (getObserveBox) {
          if (currentObserveBox.current !== getObserveBox()) needANewObserver(getElement(), getObserveBox());
        }
      });
      return {
        getElement,
        getSize,
        useElementSizeProps: useRefElementProps
      };
    }

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */

    function useGlobalHandler(target, type, handler, options) {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      let stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
      if (handler == null) stableHandler = null;
      h(() => {
        if (stableHandler) {
          target.addEventListener(type, stableHandler, options);
          return () => target.removeEventListener(type, stableHandler, options);
        }
      }, [target, type, stableHandler]);
    }

    /*!
    * tabbable 5.3.3
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var NoElement = typeof Element === 'undefined';
    var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
      return element.getRootNode();
    } : function (element) {
      return element.ownerDocument;
    };

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };

    var isZeroArea = function isZeroArea(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(),
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      return width === 0 && height === 0;
    };

    var isHidden = function isHidden(node, _ref) {
      var displayCheck = _ref.displayCheck,
          getShadowRoot = _ref.getShadowRoot; // NOTE: visibility will be `undefined` if node is detached from the document
      //  (see notes about this further down), which means we will consider it visible
      //  (this is legacy behavior from a very long way back)
      // NOTE: we check this regardless of `displayCheck="none"` because this is a
      //  _visibility_ check, not a _display_ check

      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      } // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
      //  (but NOT _the_ document; see second 'If' comment below for more).
      // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
      //  is attached, and the one we need to check if it's in the document or not (because the
      //  shadow, and all nodes it contains, is never considered in the document since shadows
      //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
      //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
      //  visibility, including all the nodes it contains). The host could be any normal node,
      //  or a custom element (i.e. web component). Either way, that's the one that is considered
      //  part of the document, not the shadow root, nor any of its children (i.e. the node being
      //  tested).
      // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
      //  document (per the docs) and while it's a Document-type object, that document does not
      //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
      //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
      //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
      //  node is actually detached.


      var nodeRootHost = getRootNode(node).host;
      var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);

      if (!displayCheck || displayCheck === 'full') {
        if (typeof getShadowRoot === 'function') {
          // figure out if we should consider the node to be in an undisclosed shadow and use the
          //  'non-zero-area' fallback
          var originalNode = node;

          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);

            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
            ) {
              // node has an undisclosed shadow which means we can only treat it as a black box, so we
              //  fall back to a non-zero-area test
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              // iterate up slot
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              // cross shadow boundary
              node = rootNode.host;
            } else {
              // iterate up normal dom
              node = parentElement;
            }
          }

          node = originalNode;
        } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.


        if (nodeIsAttached) {
          // this works wherever the node is: if there's at least one client rect, it's
          //  somehow displayed; it also covers the CSS 'display: contents' case where the
          //  node itself is hidden in place of its contents; and there's no need to search
          //  up the hierarchy either
          return !node.getClientRects().length;
        } // Else, the node isn't attached to the document, which means the `getClientRects()`
        //  API will __always__ return zero rects (this can happen, for example, if React
        //  is used to render nodes onto a detached tree, as confirmed in this thread:
        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
        //
        // It also means that even window.getComputedStyle(node).display will return `undefined`
        //  because styles are only computed for nodes that are in the document.
        //
        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
        //  somehow. Though it was never stated officially, anyone who has ever used tabbable
        //  APIs on nodes in detached containers has actually implicitly used tabbable in what
        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
        //  considering __everything__ to be visible because of the innability to determine styles.

      } else if (displayCheck === 'non-zero-area') {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
      } // visible, as far as we can tell, or per current `displayCheck` mode


      return false;
    }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset


    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>

        while (parentNode) {
          if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
            // look for the first <legend> among the children of the disabled <fieldset>
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i); // when the first <legend> (in document order) is found

              if (child.tagName === 'LEGEND') {
                // if its parent <fieldset> is not nested in another disabled <fieldset>,
                // return whether `node` is a descendant of its first <legend>
                return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
              }
            } // the disabled <fieldset> containing `node` has no <legend>


            return true;
          }

          parentNode = parentNode.parentElement;
        }
      } // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state


      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    (function (module, exports) {
      (function (global, factory) {
        factory() ;
      })(commonjsGlobal, function () {

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        /**
         * This work is licensed under the W3C Software and Document License
         * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
         */


        (function () {
          // Return early if we're not running inside of the browser.
          if (typeof window === 'undefined') {
            return;
          } // Convenience function for converting NodeLists.

          /** @type {typeof Array.prototype.slice} */


          var slice = Array.prototype.slice;
          /**
           * IE has a non-standard name for "matches".
           * @type {typeof Element.prototype.matches}
           */

          var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
          /** @type {string} */

          var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
          /**
           * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
           * attribute.
           *
           * Its main functions are:
           *
           * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
           *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
           *   each focusable node in the subtree with the singleton `InertManager` which manages all known
           *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
           *   instance exists for each focusable node which has at least one inert root as an ancestor.
           *
           * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
           *   attribute is removed from the root node). This is handled in the destructor, which calls the
           *   `deregister` method on `InertManager` for each managed inert node.
           */


          var InertRoot = function () {
            /**
             * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
             * @param {!InertManager} inertManager The global singleton InertManager object.
             */
            function InertRoot(rootElement, inertManager) {
              _classCallCheck(this, InertRoot);
              /** @type {!InertManager} */


              this._inertManager = inertManager;
              /** @type {!HTMLElement} */

              this._rootElement = rootElement;
              /**
               * @type {!Set<!InertNode>}
               * All managed focusable nodes in this InertRoot's subtree.
               */

              this._managedNodes = new Set(); // Make the subtree hidden from assistive technology

              if (this._rootElement.hasAttribute('aria-hidden')) {
                /** @type {?string} */
                this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
              } else {
                this._savedAriaHidden = null;
              }

              this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes


              this._makeSubtreeUnfocusable(this._rootElement); // Watch for:
              // - any additions in the subtree: make them unfocusable too
              // - any removals from the subtree: remove them from this inert root's managed nodes
              // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
              //   element, make that node a managed node.


              this._observer = new MutationObserver(this._onMutation.bind(this));

              this._observer.observe(this._rootElement, {
                attributes: true,
                childList: true,
                subtree: true
              });
            }
            /**
             * Call this whenever this object is about to become obsolete.  This unwinds all of the state
             * stored in this object and updates the state of all of the managed nodes.
             */


            _createClass(InertRoot, [{
              key: 'destructor',
              value: function destructor() {
                this._observer.disconnect();

                if (this._rootElement) {
                  if (this._savedAriaHidden !== null) {
                    this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                  } else {
                    this._rootElement.removeAttribute('aria-hidden');
                  }
                }

                this._managedNodes.forEach(function (inertNode) {
                  this._unmanageNode(inertNode.node);
                }, this); // Note we cast the nulls to the ANY type here because:
                // 1) We want the class properties to be declared as non-null, or else we
                //    need even more casts throughout this code. All bets are off if an
                //    instance has been destroyed and a method is called.
                // 2) We don't want to cast "this", because we want type-aware optimizations
                //    to know which properties we're setting.


                this._observer =
                /** @type {?} */
                null;
                this._rootElement =
                /** @type {?} */
                null;
                this._managedNodes =
                /** @type {?} */
                null;
                this._inertManager =
                /** @type {?} */
                null;
              }
              /**
               * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
               */

            }, {
              key: '_makeSubtreeUnfocusable',

              /**
               * @param {!Node} startNode
               */
              value: function _makeSubtreeUnfocusable(startNode) {
                var _this2 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this2._visitNode(node);
                });
                var activeElement = document.activeElement;

                if (!document.body.contains(startNode)) {
                  // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                  var node = startNode;
                  /** @type {!ShadowRoot|undefined} */

                  var root = undefined;

                  while (node) {
                    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      root =
                      /** @type {!ShadowRoot} */
                      node;
                      break;
                    }

                    node = node.parentNode;
                  }

                  if (root) {
                    activeElement = root.activeElement;
                  }
                }

                if (startNode.contains(activeElement)) {
                  activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1
                  // calling blur() will not actually move the focus.
                  // To work around this we call focus() on the body instead.

                  if (activeElement === document.activeElement) {
                    document.body.focus();
                  }
                }
              }
              /**
               * @param {!Node} node
               */

            }, {
              key: '_visitNode',
              value: function _visitNode(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of
                // this inert root, so all of its managed nodes need to be adopted by this InertRoot.

                if (element !== this._rootElement && element.hasAttribute('inert')) {
                  this._adoptInertRoot(element);
                }

                if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                  this._manageNode(element);
                }
              }
              /**
               * Register the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_manageNode',
              value: function _manageNode(node) {
                var inertNode = this._inertManager.register(node, this);

                this._managedNodes.add(inertNode);
              }
              /**
               * Unregister the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_unmanageNode',
              value: function _unmanageNode(node) {
                var inertNode = this._inertManager.deregister(node, this);

                if (inertNode) {
                  this._managedNodes['delete'](inertNode);
                }
              }
              /**
               * Unregister the entire subtree starting at `startNode`.
               * @param {!Node} startNode
               */

            }, {
              key: '_unmanageSubtree',
              value: function _unmanageSubtree(startNode) {
                var _this3 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this3._unmanageNode(node);
                });
              }
              /**
               * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
               * @param {!HTMLElement} node
               */

            }, {
              key: '_adoptInertRoot',
              value: function _adoptInertRoot(node) {
                var inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,
                // so register it now if need be.


                if (!inertSubroot) {
                  this._inertManager.setInert(node, true);

                  inertSubroot = this._inertManager.getInertRoot(node);
                }

                inertSubroot.managedNodes.forEach(function (savedInertNode) {
                  this._manageNode(savedInertNode.node);
                }, this);
              }
              /**
               * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_onMutation',
              value: function _onMutation(records, self) {
                records.forEach(function (record) {
                  var target =
                  /** @type {!HTMLElement} */
                  record.target;

                  if (record.type === 'childList') {
                    // Manage added nodes
                    slice.call(record.addedNodes).forEach(function (node) {
                      this._makeSubtreeUnfocusable(node);
                    }, this); // Un-manage removed nodes

                    slice.call(record.removedNodes).forEach(function (node) {
                      this._unmanageSubtree(node);
                    }, this);
                  } else if (record.type === 'attributes') {
                    if (record.attributeName === 'tabindex') {
                      // Re-initialise inert node if tabindex changes
                      this._manageNode(target);
                    } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                      // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                      // already managed nodes from this inert subroot.
                      this._adoptInertRoot(target);

                      var inertSubroot = this._inertManager.getInertRoot(target);

                      this._managedNodes.forEach(function (managedNode) {
                        if (target.contains(managedNode.node)) {
                          inertSubroot._manageNode(managedNode.node);
                        }
                      });
                    }
                  }
                }, this);
              }
            }, {
              key: 'managedNodes',
              get: function get() {
                return new Set(this._managedNodes);
              }
              /** @return {boolean} */

            }, {
              key: 'hasSavedAriaHidden',
              get: function get() {
                return this._savedAriaHidden !== null;
              }
              /** @param {?string} ariaHidden */

            }, {
              key: 'savedAriaHidden',
              set: function set(ariaHidden) {
                this._savedAriaHidden = ariaHidden;
              }
              /** @return {?string} */
              ,
              get: function get() {
                return this._savedAriaHidden;
              }
            }]);

            return InertRoot;
          }();
          /**
           * `InertNode` initialises and manages a single inert node.
           * A node is inert if it is a descendant of one or more inert root elements.
           *
           * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
           * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
           * is intrinsically focusable or not.
           *
           * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
           * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
           * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
           * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
           * or removes the `tabindex` attribute if the element is intrinsically focusable.
           */


          var InertNode = function () {
            /**
             * @param {!Node} node A focusable element to be made inert.
             * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
             */
            function InertNode(node, inertRoot) {
              _classCallCheck(this, InertNode);
              /** @type {!Node} */


              this._node = node;
              /** @type {boolean} */

              this._overrodeFocusMethod = false;
              /**
               * @type {!Set<!InertRoot>} The set of descendant inert roots.
               *    If and only if this set becomes empty, this node is no longer inert.
               */

              this._inertRoots = new Set([inertRoot]);
              /** @type {?number} */

              this._savedTabIndex = null;
              /** @type {boolean} */

              this._destroyed = false; // Save any prior tabindex info and make this node untabbable

              this.ensureUntabbable();
            }
            /**
             * Call this whenever this object is about to become obsolete.
             * This makes the managed node focusable again and deletes all of the previously stored state.
             */


            _createClass(InertNode, [{
              key: 'destructor',
              value: function destructor() {
                this._throwIfDestroyed();

                if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                  var element =
                  /** @type {!HTMLElement} */
                  this._node;

                  if (this._savedTabIndex !== null) {
                    element.setAttribute('tabindex', this._savedTabIndex);
                  } else {
                    element.removeAttribute('tabindex');
                  } // Use `delete` to restore native focus method.


                  if (this._overrodeFocusMethod) {
                    delete element.focus;
                  }
                } // See note in InertRoot.destructor for why we cast these nulls to ANY.


                this._node =
                /** @type {?} */
                null;
                this._inertRoots =
                /** @type {?} */
                null;
                this._destroyed = true;
              }
              /**
               * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
               * If the object has been destroyed, any attempt to access it will cause an exception.
               */

            }, {
              key: '_throwIfDestroyed',

              /**
               * Throw if user tries to access destroyed InertNode.
               */
              value: function _throwIfDestroyed() {
                if (this.destroyed) {
                  throw new Error('Trying to access destroyed InertNode');
                }
              }
              /** @return {boolean} */

            }, {
              key: 'ensureUntabbable',

              /** Save the existing tabindex value and make the node untabbable and unfocusable */
              value: function ensureUntabbable() {
                if (this.node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                this.node;

                if (matches.call(element, _focusableElementsString)) {
                  if (
                  /** @type {!HTMLElement} */
                  element.tabIndex === -1 && this.hasSavedTabIndex) {
                    return;
                  }

                  if (element.hasAttribute('tabindex')) {
                    this._savedTabIndex =
                    /** @type {!HTMLElement} */
                    element.tabIndex;
                  }

                  element.setAttribute('tabindex', '-1');

                  if (element.nodeType === Node.ELEMENT_NODE) {
                    element.focus = function () {};

                    this._overrodeFocusMethod = true;
                  }
                } else if (element.hasAttribute('tabindex')) {
                  this._savedTabIndex =
                  /** @type {!HTMLElement} */
                  element.tabIndex;
                  element.removeAttribute('tabindex');
                }
              }
              /**
               * Add another inert root to this inert node's set of managing inert roots.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'addInertRoot',
              value: function addInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots.add(inertRoot);
              }
              /**
               * Remove the given inert root from this inert node's set of managing inert roots.
               * If the set of managing inert roots becomes empty, this node is no longer inert,
               * so the object should be destroyed.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'removeInertRoot',
              value: function removeInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots['delete'](inertRoot);

                if (this._inertRoots.size === 0) {
                  this.destructor();
                }
              }
            }, {
              key: 'destroyed',
              get: function get() {
                return (
                  /** @type {!InertNode} */
                  this._destroyed
                );
              }
            }, {
              key: 'hasSavedTabIndex',
              get: function get() {
                return this._savedTabIndex !== null;
              }
              /** @return {!Node} */

            }, {
              key: 'node',
              get: function get() {
                this._throwIfDestroyed();

                return this._node;
              }
              /** @param {?number} tabIndex */

            }, {
              key: 'savedTabIndex',
              set: function set(tabIndex) {
                this._throwIfDestroyed();

                this._savedTabIndex = tabIndex;
              }
              /** @return {?number} */
              ,
              get: function get() {
                this._throwIfDestroyed();

                return this._savedTabIndex;
              }
            }]);

            return InertNode;
          }();
          /**
           * InertManager is a per-document singleton object which manages all inert roots and nodes.
           *
           * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
           * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
           * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
           * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
           * is created for each such node, via the `_managedNodes` map.
           */


          var InertManager = function () {
            /**
             * @param {!Document} document
             */
            function InertManager(document) {
              _classCallCheck(this, InertManager);

              if (!document) {
                throw new Error('Missing required argument; InertManager needs to wrap a document.');
              }
              /** @type {!Document} */


              this._document = document;
              /**
               * All managed nodes known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertNode>}
               */

              this._managedNodes = new Map();
              /**
               * All inert roots known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertRoot>}
               */

              this._inertRoots = new Map();
              /**
               * Observer for mutations on `document.body`.
               * @type {!MutationObserver}
               */

              this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.

              addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.

              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
              } else {
                this._onDocumentLoaded();
              }
            }
            /**
             * Set whether the given element should be an inert root or not.
             * @param {!HTMLElement} root
             * @param {boolean} inert
             */


            _createClass(InertManager, [{
              key: 'setInert',
              value: function setInert(root, inert) {
                if (inert) {
                  if (this._inertRoots.has(root)) {
                    // element is already inert
                    return;
                  }

                  var inertRoot = new InertRoot(root, this);
                  root.setAttribute('inert', '');

                  this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.
                  // Ensure inert styles are added there.


                  if (!this._document.body.contains(root)) {
                    var parent = root.parentNode;

                    while (parent) {
                      if (parent.nodeType === 11) {
                        addInertStyle(parent);
                      }

                      parent = parent.parentNode;
                    }
                  }
                } else {
                  if (!this._inertRoots.has(root)) {
                    // element is already non-inert
                    return;
                  }

                  var _inertRoot = this._inertRoots.get(root);

                  _inertRoot.destructor();

                  this._inertRoots['delete'](root);

                  root.removeAttribute('inert');
                }
              }
              /**
               * Get the InertRoot object corresponding to the given inert root element, if any.
               * @param {!Node} element
               * @return {!InertRoot|undefined}
               */

            }, {
              key: 'getInertRoot',
              value: function getInertRoot(element) {
                return this._inertRoots.get(element);
              }
              /**
               * Register the given InertRoot as managing the given node.
               * In the case where the node has a previously existing inert root, this inert root will
               * be added to its set of inert roots.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {!InertNode} inertNode
               */

            }, {
              key: 'register',
              value: function register(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (inertNode !== undefined) {
                  // node was already in an inert subtree
                  inertNode.addInertRoot(inertRoot);
                } else {
                  inertNode = new InertNode(node, inertRoot);
                }

                this._managedNodes.set(node, inertNode);

                return inertNode;
              }
              /**
               * De-register the given InertRoot as managing the given inert node.
               * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
               * node from the InertManager's set of managed nodes if it is destroyed.
               * If the node is not currently managed, this is essentially a no-op.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
               */

            }, {
              key: 'deregister',
              value: function deregister(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (!inertNode) {
                  return null;
                }

                inertNode.removeInertRoot(inertRoot);

                if (inertNode.destroyed) {
                  this._managedNodes['delete'](node);
                }

                return inertNode;
              }
              /**
               * Callback used when document has finished loading.
               */

            }, {
              key: '_onDocumentLoaded',
              value: function _onDocumentLoaded() {
                // Find all inert roots in document and make them actually inert.
                var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
                inertElements.forEach(function (inertElement) {
                  this.setInert(inertElement, true);
                }, this); // Comment this out to use programmatic API only.

                this._observer.observe(this._document.body || this._document.documentElement, {
                  attributes: true,
                  subtree: true,
                  childList: true
                });
              }
              /**
               * Callback used when mutation observer detects attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_watchForInert',
              value: function _watchForInert(records, self) {
                var _this = this;

                records.forEach(function (record) {
                  switch (record.type) {
                    case 'childList':
                      slice.call(record.addedNodes).forEach(function (node) {
                        if (node.nodeType !== Node.ELEMENT_NODE) {
                          return;
                        }

                        var inertElements = slice.call(node.querySelectorAll('[inert]'));

                        if (matches.call(node, '[inert]')) {
                          inertElements.unshift(node);
                        }

                        inertElements.forEach(function (inertElement) {
                          this.setInert(inertElement, true);
                        }, _this);
                      }, _this);
                      break;

                    case 'attributes':
                      if (record.attributeName !== 'inert') {
                        return;
                      }

                      var target =
                      /** @type {!HTMLElement} */
                      record.target;
                      var inert = target.hasAttribute('inert');

                      _this.setInert(target, inert);

                      break;
                  }
                }, this);
              }
            }]);

            return InertManager;
          }();
          /**
           * Recursively walk the composed tree from |node|.
           * @param {!Node} node
           * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
           *     before descending into child nodes.
           * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
           */


          function composedTreeWalk(node, callback, shadowRootAncestor) {
            if (node.nodeType == Node.ELEMENT_NODE) {
              var element =
              /** @type {!HTMLElement} */
              node;

              if (callback) {
                callback(element);
              } // Descend into node:
              // If it has a ShadowRoot, ignore all child elements - these will be picked
              // up by the <content> or <shadow> elements. Descend straight into the
              // ShadowRoot.


              var shadowRoot =
              /** @type {!HTMLElement} */
              element.shadowRoot;

              if (shadowRoot) {
                composedTreeWalk(shadowRoot, callback);
                return;
              } // If it is a <content> element, descend into distributed elements - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'content') {
                var content =
                /** @type {!HTMLContentElement} */
                element; // Verifies if ShadowDom v0 is supported.

                var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];

                for (var i = 0; i < distributedNodes.length; i++) {
                  composedTreeWalk(distributedNodes[i], callback);
                }

                return;
              } // If it is a <slot> element, descend into assigned nodes - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'slot') {
                var slot =
                /** @type {!HTMLSlotElement} */
                element; // Verify if ShadowDom v1 is supported.

                var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                  flatten: true
                }) : [];

                for (var _i = 0; _i < _distributedNodes.length; _i++) {
                  composedTreeWalk(_distributedNodes[_i], callback);
                }

                return;
              }
            } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
            // element, nor a <shadow> element recurse normally.


            var child = node.firstChild;

            while (child != null) {
              composedTreeWalk(child, callback);
              child = child.nextSibling;
            }
          }
          /**
           * Adds a style element to the node containing the inert specific styles
           * @param {!Node} node
           */


          function addInertStyle(node) {
            if (node.querySelector('style#inert-style, link#inert-style')) {
              return;
            }

            var style = document.createElement('style');
            style.setAttribute('id', 'inert-style');
            style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
            node.appendChild(style);
          }

          if (!HTMLElement.prototype.hasOwnProperty('inert')) {
            /** @type {!InertManager} */
            var inertManager = new InertManager(document);
            Object.defineProperty(HTMLElement.prototype, 'inert', {
              enumerable: true,

              /** @this {!HTMLElement} */
              get: function get() {
                return this.hasAttribute('inert');
              },

              /** @this {!HTMLElement} */
              set: function set(inert) {
                inertManager.setInert(this, inert);
              }
            });
          }
        })();
      });
    })();

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
      var _a, _b, _c;
      /* Symbols for private properties */


      const _blockingElements = Symbol();

      const _alreadyInertElements = Symbol();

      const _topElParents = Symbol();

      const _siblingsToRestore = Symbol();

      const _parentMO = Symbol();
      /* Symbols for private static methods */


      const _topChanged = Symbol();

      const _swapInertedSibling = Symbol();

      const _inertSiblings = Symbol();

      const _restoreInertedSiblings = Symbol();

      const _getParents = Symbol();

      const _getDistributedChildren = Symbol();

      const _isInertable = Symbol();

      const _handleMutations = Symbol();

      class BlockingElementsImpl {
        constructor() {
          /**
           * The blocking elements.
           */
          this[_a] = [];
          /**
           * Used to keep track of the parents of the top element, from the element
           * itself up to body. When top changes, the old top might have been removed
           * from the document, so we need to memoize the inerted parents' siblings
           * in order to restore their inerteness when top changes.
           */

          this[_b] = [];
          /**
           * Elements that are already inert before the first blocking element is
           * pushed.
           */

          this[_c] = new Set();
        }

        destructor() {
          // Restore original inertness.
          this[_restoreInertedSiblings](this[_topElParents]); // Note we don't want to make these properties nullable on the class,
          // since then we'd need non-null casts in many places. Calling a method on
          // a BlockingElements instance after calling destructor will result in an
          // exception.


          const nullable = this;
          nullable[_blockingElements] = null;
          nullable[_topElParents] = null;
          nullable[_alreadyInertElements] = null;
        }

        get top() {
          const elems = this[_blockingElements];
          return elems[elems.length - 1] || null;
        }

        push(element) {
          if (!element || element === this.top) {
            return;
          } // Remove it from the stack, we'll bring it to the top.


          this.remove(element);

          this[_topChanged](element);

          this[_blockingElements].push(element);
        }

        remove(element) {
          const i = this[_blockingElements].indexOf(element);

          if (i === -1) {
            return false;
          }

          this[_blockingElements].splice(i, 1); // Top changed only if the removed element was the top element.


          if (i === this[_blockingElements].length) {
            this[_topChanged](this.top);
          }

          return true;
        }

        pop() {
          const top = this.top;
          top && this.remove(top);
          return top;
        }

        has(element) {
          return this[_blockingElements].indexOf(element) !== -1;
        }
        /**
         * Sets `inert` to all document elements except the new top element, its
         * parents, and its distributed content.
         */


        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
          const toKeepInert = this[_alreadyInertElements];
          const oldParents = this[_topElParents]; // No new top, reset old top if any.

          if (!newTop) {
            this[_restoreInertedSiblings](oldParents);

            toKeepInert.clear();
            this[_topElParents] = [];
            return;
          }

          const newParents = this[_getParents](newTop); // New top is not contained in the main document!


          if (newParents[newParents.length - 1].parentNode !== document.body) {
            throw Error('Non-connected element cannot be a blocking element');
          } // Cast here because we know we'll call _inertSiblings on newParents
          // below.


          this[_topElParents] = newParents;

          const toSkip = this[_getDistributedChildren](newTop); // No previous top element.


          if (!oldParents.length) {
            this[_inertSiblings](newParents, toSkip, toKeepInert);

            return;
          }

          let i = oldParents.length - 1;
          let j = newParents.length - 1; // Find common parent. Index 0 is the element itself (so stop before it).

          while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
            i--;
            j--;
          } // If up the parents tree there are 2 elements that are siblings, swap
          // the inerted sibling.


          if (oldParents[i] !== newParents[j]) {
            this[_swapInertedSibling](oldParents[i], newParents[j]);
          } // Restore old parents siblings inertness.


          i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i)); // Make new parents siblings inert.

          j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
        }
        /**
         * Swaps inertness between two sibling elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_swapInertedSibling](oldInert, newInert) {
          const siblingsToRestore = oldInert[_siblingsToRestore]; // oldInert is not contained in siblings to restore, so we have to check
          // if it's inertable and if already inert.

          if (this[_isInertable](oldInert) && !oldInert.inert) {
            oldInert.inert = true;
            siblingsToRestore.add(oldInert);
          } // If newInert was already between the siblings to restore, it means it is
          // inertable and must be restored.


          if (siblingsToRestore.has(newInert)) {
            newInert.inert = false;
            siblingsToRestore.delete(newInert);
          }

          newInert[_parentMO] = oldInert[_parentMO];
          newInert[_siblingsToRestore] = siblingsToRestore;
          oldInert[_parentMO] = undefined;
          oldInert[_siblingsToRestore] = undefined;
        }
        /**
         * Restores original inertness to the siblings of the elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_restoreInertedSiblings](elements) {
          for (const element of elements) {
            const mo = element[_parentMO];
            mo.disconnect();
            element[_parentMO] = undefined;
            const siblings = element[_siblingsToRestore];

            for (const sibling of siblings) {
              sibling.inert = false;
            }

            element[_siblingsToRestore] = undefined;
          }
        }
        /**
         * Inerts the siblings of the elements except the elements to skip. Stores
         * the inerted siblings into the element's symbol `_siblingsToRestore`.
         * Pass `toKeepInert` to collect the already inert elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_inertSiblings](elements, toSkip, toKeepInert) {
          for (const element of elements) {
            // Assume element is not a Document, so it must have a parentNode.
            const parent = element.parentNode;
            const children = parent.children;
            const inertedSiblings = new Set();

            for (let j = 0; j < children.length; j++) {
              const sibling = children[j]; // Skip the input element, if not inertable or to be skipped.

              if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
                continue;
              } // Should be collected since already inerted.


              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            } // Store the siblings that were inerted.


            element[_siblingsToRestore] = inertedSiblings; // Observe only immediate children mutations on the parent.

            const mo = new MutationObserver(this[_handleMutations].bind(this));
            element[_parentMO] = mo;
            let parentToObserve = parent; // If we're using the ShadyDOM polyfill, then our parent could be a
            // shady root, which is an object that acts like a ShadowRoot, but isn't
            // actually a node in the real DOM. Observe the real DOM parent instead.

            const maybeShadyRoot = parentToObserve;

            if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
              parentToObserve = maybeShadyRoot.host;
            }

            mo.observe(parentToObserve, {
              childList: true
            });
          }
        }
        /**
         * Handles newly added/removed nodes by toggling their inertness.
         * It also checks if the current top Blocking Element has been removed,
         * notifying and removing it.
         */


        [_handleMutations](mutations) {
          const parents = this[_topElParents];
          const toKeepInert = this[_alreadyInertElements];

          for (const mutation of mutations) {
            // If the target is a shadowRoot, get its host as we skip shadowRoots when
            // computing _topElParents.
            const target = mutation.target.host || mutation.target;
            const idx = target === document.body ? parents.length : parents.indexOf(target);
            const inertedChild = parents[idx - 1];
            const inertedSiblings = inertedChild[_siblingsToRestore]; // To restore.

            for (let i = 0; i < mutation.removedNodes.length; i++) {
              const sibling = mutation.removedNodes[i];

              if (sibling === inertedChild) {
                console.info('Detected removal of the top Blocking Element.');
                this.pop();
                return;
              }

              if (inertedSiblings.has(sibling)) {
                sibling.inert = false;
                inertedSiblings.delete(sibling);
              }
            } // To inert.


            for (let i = 0; i < mutation.addedNodes.length; i++) {
              const sibling = mutation.addedNodes[i];

              if (!this[_isInertable](sibling)) {
                continue;
              }

              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            }
          }
        }
        /**
         * Returns if the element is inertable.
         */


        [_isInertable](element) {
          return false === /^(style|template|script)$/.test(element.localName);
        }
        /**
         * Returns the list of newParents of an element, starting from element
         * (included) up to `document.body` (excluded).
         */


        [_getParents](element) {
          const parents = [];
          let current = element; // Stop to body.

          while (current && current !== document.body) {
            // Skip shadow roots.
            if (current.nodeType === Node.ELEMENT_NODE) {
              parents.push(current);
            } // ShadowDom v1


            if (current.assignedSlot) {
              // Collect slots from deepest slot to top.
              while (current = current.assignedSlot) {
                parents.push(current);
              } // Continue the search on the top slot.


              current = parents.pop();
              continue;
            }

            current = current.parentNode || current.host;
          }

          return parents;
        }
        /**
         * Returns the distributed children of the element's shadow root.
         * Returns null if the element doesn't have a shadow root.
         */


        [_getDistributedChildren](element) {
          const shadowRoot = element.shadowRoot;

          if (!shadowRoot) {
            return null;
          }

          const result = new Set();
          let i;
          let j;
          let nodes;
          const slots = shadowRoot.querySelectorAll('slot');

          if (slots.length && slots[0].assignedNodes) {
            for (i = 0; i < slots.length; i++) {
              nodes = slots[i].assignedNodes({
                flatten: true
              });

              for (j = 0; j < nodes.length; j++) {
                if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                  result.add(nodes[j]);
                }
              }
            } // No need to search for <content>.

          }

          return result;
        }

      }

      document.$blockingElements = new BlockingElementsImpl();
    })();

    function blockingElements() {
      return getDocument().$blockingElements;
    }
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */


    function useBlockingElement(enabled, getTarget) {
      const stableGetTarget = useStableCallback(getTarget);
      /**
       * Push/pop the element from the blockingElements stack.
       */

      s(() => {
        const target = stableGetTarget();

        if (enabled) {
          // Sometimes blockingElements will fail if, for example,
          // the target element isn't connected to document.body.
          // This is rare, but it's better to fail silently with weird tabbing behavior
          // than to crash the entire application.
          try {
            blockingElements().push(target);
            return () => {
              blockingElements().remove(target);
            };
          } catch (ex) {
            // Well, semi-silently.
            console.error(ex);
          }
        }
      }, [enabled]);
    }
    function getTopElement() {
      return blockingElements().top;
    }

    const elementsToRestoreFocusTo = new Map();
    function useFocusTrap(_ref) {
      let {
        trapActive
      } = _ref;
      const handleActiveChange = T$1((trapActive, element) => {
        if (trapActive && element) {
          let rafHandle = requestAnimationFrame(() => {
            // TODO: This extra queueMicrotask is needed for
            // ...reasons?
            queueMicrotask(() => {
              var _findFirstFocusable;

              (_findFirstFocusable = findFirstFocusable(element)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        } else if (element) {
          // Restore the focus to the element
          // that has returned to the top of the stack
          let rafHandle = requestAnimationFrame(() => {
            queueMicrotask(() => {
              var _elementsToRestoreFoc;

              (_elementsToRestoreFoc = elementsToRestoreFocusTo.get(getTopElement())) === null || _elementsToRestoreFoc === void 0 ? void 0 : _elementsToRestoreFoc.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        }
      }, []);
      const {
        getLastActiveElement,
        useActiveElementProps,
        getElement
      } = useActiveElement({
        onMountChange: useStableCallback(element => handleActiveChange(trapActive, element))
      }); // When the trap becomes active, before we let the blockingElements hook run,
      // keep track of whatever's currently focused and save it.

      s(() => {
        const element = getElement();

        if (trapActive && element) {
          var _getLastActiveElement;

          const document = getDocument(element); // Save the currently focused element
          // to whatever's currently at the top of the stack

          elementsToRestoreFocusTo.set(getTopElement(), (_getLastActiveElement = getLastActiveElement()) !== null && _getLastActiveElement !== void 0 ? _getLastActiveElement : document.body);
        }
      }, [trapActive]);
      useBlockingElement(trapActive, getElement);
      /**
       * Any time we activate or deactivate the trap,
       * change focus to something else (something in
       * the trap if it's active, or whatever we've
       * tracked in elementsToRestoreFocusTo if not)
       */

      s(() => {
        handleActiveChange(trapActive, getElement());
      }, [trapActive]);

      const useFocusTrapProps = props => {
        const p1 = useActiveElementProps(props);
        const p2 = {
          "aria-modal": trapActive ? "true" : undefined
        };
        return useMergedProps(p1, p2);
      };

      return {
        useFocusTrapProps,
        getElement
      };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */

    function findFirstFocusable(element) {
      const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: node => node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      });
      const firstFocusable = treeWalker.firstChild();
      return firstFocusable;
    }

    function capitalize(str) {
      return str[0].toUpperCase() + str.substring(1);
    }
    /**
     * Inspects the element's style and determines the logical direction that text flows.
     *
     * Certain CSS properties, like `block-size`, respect the current writing mode and text direction.
     * But `transform`, `clip`, etc. don't.
     *
     * This is provided so that CSS properties can consistently use those logical properties.
     *
     * See https://drafts.csswg.org/css-writing-modes/#logical-to-physical
     *
     * @returns An object containing the following functions:
     * * `getLogicalDirection`: retrieves a `LogicalDirectionInfo` representing the current state of the element. (Function is constant between renders)
     * * `convertElementSize`: When used in conjunction with `useElementSize`, allows you to retrieve the logical size of an element instead of the physical size.
     * * `convertToLogicalOrientation`: Based on the current direction, converts "horizontal" or "vertical" to "inline" or "block".
     * * `convertToPhysicalOrientation`:  Based on the current direction, converts "inline" or "block" to "horizontal" or "vertical".
     */


    function useLogicalDirection(_ref) {
      let {
        onLogicalDirectionChange
      } = _ref;
      useEnsureStability("useLogicalDirection", onLogicalDirectionChange);
      const [getComputedStyles, setComputedStyles] = usePassiveState(null, returnNull);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: T$1(element => {
          if (element) {
            setComputedStyles(window.getComputedStyle(element));
          }
        }, [])
      }); // TODO: There's no way to refresh which writing mode we have once mounted.
      //   A. There's no way to watch for CSS style changes
      //   B. Calling getComputedStyle after every render for every element gets expensive fast and
      //   C. Is not necessary for most use cases that will never switch writing-mode within a single component
      //      (Those that do will need to mount and unmount the component that uses it)
      //
      // As a solution, here's a cheap workaround that checks when the element's size has changed,
      // and if so, tests if the writing mode has changed too.
      //
      // This will work for at least some number of cases, but a better solution is still needed.

      const {
        useElementSizeProps
      } = useElementSize({
        onSizeChange: T$1(_ => onLogicalDirectionChange === null || onLogicalDirectionChange === void 0 ? void 0 : onLogicalDirectionChange(getLogicalDirectionInfo()), [])
      });
      const getLogicalDirectionInfo = T$1(() => {
        const computedStyles = getComputedStyles();

        if (computedStyles) {
          const w = computedStyles.writingMode;
          let d = computedStyles.direction;
          const t = computedStyles.textOrientation;
          if (t == "upright") d = "ltr";
          return { ...WritingModes[w || "horizontal-tb"][d || "ltr"]
          };
        }

        return null;
      }, []); //const [getLogicalDirectionInfo, setLogicalDirectionInfo] = usePassiveState<LogicalDirectionInfo>(onLogicalDirectionChange);

      const convertToLogicalOrientation = T$1((elementOrientation, direction) => {
        var _direction, _direction2;

        (_direction = direction) !== null && _direction !== void 0 ? _direction : direction = getLogicalDirectionInfo();
        if (((_direction2 = direction) === null || _direction2 === void 0 ? void 0 : _direction2.inlineOrientation) === elementOrientation) return "inline";
        return "block";
      }, []);
      const convertToPhysicalSide = T$1((side, direction) => {
        var _direction3, _direction$blockDirec, _direction4, _direction$blockDirec2, _direction5, _direction$inlineDire, _direction6, _direction$inlineDire2, _direction7;

        (_direction3 = direction) !== null && _direction3 !== void 0 ? _direction3 : direction = getLogicalDirectionInfo();

        switch (side) {
          case "block-start":
            return M[((_direction$blockDirec = (_direction4 = direction) === null || _direction4 === void 0 ? void 0 : _direction4.blockDirection) !== null && _direction$blockDirec !== void 0 ? _direction$blockDirec : "ttb")[0]];

          case "block-end":
            return M[((_direction$blockDirec2 = (_direction5 = direction) === null || _direction5 === void 0 ? void 0 : _direction5.blockDirection) !== null && _direction$blockDirec2 !== void 0 ? _direction$blockDirec2 : "ttb")[2]];

          case "inline-start":
            return M[((_direction$inlineDire = (_direction6 = direction) === null || _direction6 === void 0 ? void 0 : _direction6.inlineDirection) !== null && _direction$inlineDire !== void 0 ? _direction$inlineDire : "ltr")[0]];

          case "inline-end":
            return M[((_direction$inlineDire2 = (_direction7 = direction) === null || _direction7 === void 0 ? void 0 : _direction7.inlineDirection) !== null && _direction$inlineDire2 !== void 0 ? _direction$inlineDire2 : "ltr")[2]];
        }
      }, []);
      const convertToLogicalSide = T$1((side, direction) => {
        var _direction8, _direction9, _direction10;

        (_direction8 = direction) !== null && _direction8 !== void 0 ? _direction8 : direction = getLogicalDirectionInfo();

        if (((_direction9 = direction) === null || _direction9 === void 0 ? void 0 : _direction9.inlineOrientation) === "vertical") {
          switch (side) {
            case "top":
              return direction.inlineDirection === "ttb" ? "inline-start" : "inline-end";

            case "bottom":
              return direction.inlineDirection === "btt" ? "inline-start" : "inline-end";

            case "left":
              return direction.blockDirection === "ltr" ? "block-start" : "block-end";

            case "right":
              return direction.blockDirection === "rtl" ? "block-start" : "block-end";
          }
        } else if (((_direction10 = direction) === null || _direction10 === void 0 ? void 0 : _direction10.inlineOrientation) === "horizontal") {
          switch (side) {
            case "top":
              return direction.blockDirection === "ttb" ? "block-start" : "block-end";

            case "bottom":
              return direction.blockDirection === "btt" ? "block-start" : "block-end";

            case "left":
              return direction.inlineDirection === "ltr" ? "inline-start" : "inline-end";

            case "right":
              return direction.inlineDirection === "rtl" ? "inline-start" : "inline-end";
          }
        }
        /* eslint-disable no-debugger */


        debugger;
        console.assert(false);
        return "inline-start";
      }, []);
      const convertToPhysicalOrientation = T$1((elementOrientation, direction) => {
        var _direction11;

        (_direction11 = direction) !== null && _direction11 !== void 0 ? _direction11 : direction = getLogicalDirectionInfo();

        if (elementOrientation == "inline") {
          var _direction12;

          if (((_direction12 = direction) === null || _direction12 === void 0 ? void 0 : _direction12.inlineOrientation) == "horizontal") return "horizontal";
          return "vertical";
        } else {
          var _direction13;

          if (((_direction13 = direction) === null || _direction13 === void 0 ? void 0 : _direction13.blockOrientation) == "vertical") return "vertical";
          return "horizontal";
        }
      }, []);
      const convertElementSize = T$1((elementSize, direction) => {
        var _direction14;

        (_direction14 = direction) !== null && _direction14 !== void 0 ? _direction14 : direction = getLogicalDirectionInfo();

        if (direction) {
          const {
            inlineSize,
            blockSize,
            inlineDirection,
            blockDirection
          } = direction; // Size is relatively simple

          const clientInlineSize = elementSize[`client${capitalize(inlineSize)}`];
          const clientBlockSize = elementSize[`client${capitalize(blockSize)}`];
          const offsetInlineSize = elementSize[`offset${capitalize(inlineSize)}`];
          const offsetBlockSize = elementSize[`offset${capitalize(blockSize)}`];
          const scrollInlineSize = elementSize[`scroll${capitalize(inlineSize)}`];
          const scrollBlockSize = elementSize[`scroll${capitalize(blockSize)}`];
          const f1 = getPhysicalLeftTop(inlineDirection);
          const f2 = getPhysicalRightBottom(inlineDirection);
          const f3 = getPhysicalLeftTop(blockDirection);
          const f4 = getPhysicalRightBottom(blockDirection);
          const clientInlineInset = elementSize[`client${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`client${capitalize(f2)}`]);
          const scrollInlineInset = elementSize[`scroll${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`scroll${capitalize(f2)}`]);
          const offsetInlineInset = elementSize[`offset${capitalize(f1)}`] == undefined ? undefined : elementSize[`offset${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`offset${capitalize(f2)}`]);
          const clientBlockInset = elementSize[`client${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`client${capitalize(f4)}`]);
          const scrollBlockInset = elementSize[`scroll${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`scroll${capitalize(f4)}`]);
          const offsetBlockInset = elementSize[`offset${capitalize(f3)}`] == undefined ? undefined : elementSize[`offset${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`offset${capitalize(f4)}`]);
          return {
            clientInlineSize,
            scrollInlineSize,
            offsetInlineSize,
            clientBlockSize,
            scrollBlockSize,
            offsetBlockSize,
            clientInlineInset,
            scrollInlineInset,
            offsetInlineInset,
            clientBlockInset,
            scrollBlockInset,
            offsetBlockInset
          };
        }

        return null;
      }, []);
      return {
        useLogicalDirectionProps: T$1(props => useRefElementProps(useElementSizeProps(props)), []),
        getElement,
        getLogicalDirectionInfo,
        convertToLogicalSize: convertElementSize,
        convertToLogicalOrientation,
        convertToPhysicalOrientation,
        convertToLogicalSide,
        convertToPhysicalSide
      };
    } // Position requires us to sometimes use one property (like `left`)
    // or sometimes two (like `left` + `width`)

    function getPhysicalLeftTop(dir) {
      if (dir === "ltr" || dir == "rtl") return "left";
      return "top";
    }

    function getPhysicalRightBottom(dir) {
      if (dir === "rtl") return "width";
      if (dir === "btt") return "height";
      return null;
    } // Helper for extracting info from "ltr", "ttb", etc.


    const M = {
      t: "top",
      b: "bottom",
      l: "left",
      r: "right"
    };
    const HorizontalTbLtr = {
      inlineDirection: "ltr",
      blockDirection: "ttb",
      inlineOrientation: "horizontal",
      blockOrientation: "vertical",
      inlineSize: "width",
      blockSize: "height",
      leftRightDirection: "ltr",
      overUnderDirection: "ttb"
    };
    const HorizontalTbRtl = { ...HorizontalTbLtr,
      inlineDirection: "rtl"
    };
    const VerticalRlLtr = {
      inlineDirection: "ttb",
      blockDirection: "rtl",
      inlineOrientation: "vertical",
      blockOrientation: "horizontal",
      inlineSize: "height",
      blockSize: "width",
      leftRightDirection: "ttb",
      overUnderDirection: "rtl"
    };
    const VerticalRlRtl = { ...VerticalRlLtr,
      inlineDirection: "btt"
    };
    const SidewaysRlLtr = { ...VerticalRlLtr
    };
    const SidewaysRlRtl = { ...VerticalRlRtl
    };
    const VerticalLrLtr = { ...VerticalRlLtr,
      blockDirection: "ltr"
    };
    const VerticalLrRtl = { ...VerticalRlRtl,
      blockDirection: "ltr"
    };
    const SidewaysLtLtr = { ...VerticalLrLtr,
      inlineDirection: "btt",
      leftRightDirection: "btt",
      overUnderDirection: "ltr"
    };
    const SidewaysLtRtl = { ...SidewaysLtLtr,
      inlineDirection: "ttb"
    };
    const HorizontalTb = {
      ltr: HorizontalTbLtr,
      rtl: HorizontalTbRtl
    };
    const VerticalRl = {
      ltr: VerticalRlLtr,
      rtl: VerticalRlRtl
    };
    const VerticalLr = {
      ltr: VerticalLrLtr,
      rtl: VerticalLrRtl
    };
    const SidewaysRl = {
      ltr: SidewaysRlLtr,
      rtl: SidewaysRlRtl
    };
    const SidewaysLr = {
      ltr: SidewaysLtLtr,
      rtl: SidewaysLtRtl
    };
    const WritingModes = {
      "horizontal-tb": HorizontalTb,
      "vertical-lr": VerticalLr,
      "vertical-rl": VerticalRl,
      "sideways-lr": SidewaysLr,
      "sideways-rl": SidewaysRl
    };

    function useTimeout(_ref) {
      let {
        timeout,
        callback,
        triggerIndex
      } = _ref;
      const stableCallback = useStableCallback(() => {
        startTimeRef.current = null;
        callback();
      });
      const getTimeout = useStableGetter(timeout); // Set any time we start timeout.
      // Unset any time the timeout completes

      const startTimeRef = _(null);
      const timeoutIsNull = timeout == null; // Any time the triggerIndex changes (including on mount)
      // restart the timeout.  The timeout does NOT reset
      // when the duration or callback changes, only triggerIndex.

      h(() => {
        if (!timeoutIsNull) {
          const timeout = getTimeout();
          console.assert(timeoutIsNull == (timeout == null));

          if (timeout != null) {
            startTimeRef.current = +new Date();
            const handle = setTimeout(stableCallback, timeout);
            return () => clearTimeout(handle);
          }
        }
      }, [triggerIndex, timeoutIsNull]);
      const getElapsedTime = T$1(() => {
        var _startTimeRef$current;

        return +new Date() - +((_startTimeRef$current = startTimeRef.current) !== null && _startTimeRef$current !== void 0 ? _startTimeRef$current : new Date());
      }, []);
      const getRemainingTime = T$1(() => {
        const timeout = getTimeout();
        return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
      }, []);
      return {
        getElapsedTime,
        getRemainingTime
      };
    }

    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useLinearNavigation(_ref) {
      var _nd;

      let {
        navigateToFirst: ntf,
        navigateToLast: ntl,
        navigateToNext: ntn,
        navigateToPrev: ntp,
        navigationDirection: nd,
        disableArrowKeys: dak,
        disableHomeEndKeys: dhek
      } = _ref;
      (_nd = nd) !== null && _nd !== void 0 ? _nd : nd = "either";
      const {
        getLogicalDirectionInfo,
        useLogicalDirectionProps
      } = useLogicalDirection({});
      const navigateToFirst = useStableCallback(ntf);
      const navigateToLast = useStableCallback(ntl);
      const navigateToNext = useStableCallback(ntn);
      const navigateToPrev = useStableCallback(ntp);
      const getDisableArrowKeys = useStableGetter(dak);
      const getDisableHomeEndKeys = useStableGetter(dhek);
      const getNavigationDirection = useStableGetter(nd);
      return {
        useLinearNavigationProps: T$1(props => {
          const onKeyDown = e => {
            // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
            if (e.ctrlKey || e.metaKey) return;
            const info = getLogicalDirectionInfo();
            const navigationDirection = getNavigationDirection();
            const disableArrowKeys = getDisableArrowKeys();
            const disableHomeEndKeys = getDisableHomeEndKeys();
            const allowsBlockNavigation = navigationDirection == "block" || navigationDirection == "either";
            const allowsInlineNavigation = navigationDirection == "inline" || navigationDirection == "either";

            switch (e.key) {
              case "ArrowUp":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowDown":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowLeft":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "rtl") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowRight":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "rtl") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  e.preventDefault();
                  e.stopPropagation();
                  break;
                }

              case "Home":
                if (!disableHomeEndKeys) {
                  navigateToFirst();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;

              case "End":
                if (!disableHomeEndKeys) {
                  navigateToLast();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;
            }
          };

          return useLogicalDirectionProps(useMergedProps({
            onKeyDown
          }, props));
        }, [])
      };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useTypeaheadNavigation(_ref2) {
      let {
        collator,
        getIndex,
        typeaheadTimeout,
        setIndex,
        noTypeahead
      } = _ref2;
      // For typeahead, keep track of what our current "search" string is (if we have one)
      // and also clear it every 1000 ms since the last time it changed.
      // Next, keep a mapping of typeahead values to indices for faster searching.
      // And, for the user's sake, let them know when their typeahead can't match anything anymore
      const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
      useTimeout({
        timeout: typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000,
        callback: () => {
          setCurrentTypeahead(null);
          setInvalidTypeahead(null);
        },
        triggerIndex: currentTypeahead
      });
      const sortedTypeaheadInfo = _([]);
      const [invalidTypeahead, setInvalidTypeahead] = useState(false); // Handle typeahead for input method editors as well
      // Essentially, when active, ignore further keys 
      // because we're waiting for a CompositionEnd event

      const [, setImeActive, getImeActive] = useState(false); // Because composition events fire *after* keydown events 
      // (but within the same task, which, TODO, could be browser-dependent),
      // we can use this to keep track of which event we're listening for on the first keydown.

      const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
      useLayoutEffect(() => {
        if (nextTypeaheadChar !== null) {
          setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar);
          setNextTypeaheadChar(null);
        }
      }, [nextTypeaheadChar]);
      const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
        var _safeRhs$toLowerCase;

        let compare; // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
        // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.

        safeLhs = safeLhs.normalize("NFD");
        safeRhs = safeRhs.normalize("NFD");
        if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
        return compare;
      });
      const insertingComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          return comparatorShared(lhs, rhs.text);
        }

        return lhs - rhs;
      });
      const typeaheadComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          // During typeahead, all strings longer than ours should be truncated
          // so that they're all considered equally by that point.
          return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
        }

        return lhs - rhs;
      });
      const isDisabled = useStableGetter(noTypeahead);
      const useTypeaheadNavigationProps = T$1(function (_ref3) {
        let { ...props
        } = _ref3;

        const onCompositionStart = _e => {
          setImeActive(true);
        };

        const onCompositionEnd = e => {
          setNextTypeaheadChar(e.data);
          setImeActive(false);
        };

        const onKeyDown = e => {
          if (isDisabled()) return;
          const imeActive = getImeActive();
          const key = e.key; // Not handled by typeahead (i.e. assume this is a keyboard shortcut)

          if (e.ctrlKey || e.metaKey) return;

          if (!imeActive && e.key === "Backspace") {
            // Remove the last character in a way that doesn't split UTF-16 surrogates.
            setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
            e.preventDefault();
            e.stopPropagation();
            return;
          } // The key property represents the typed character OR the "named key attribute" of the key pressed.
          // There's no definite way to tell the difference, but for all intents and purposes
          // there are no one-character names, and there are no non-ASCII-alpha names.
          // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.


          const isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);

          if (isCharacterKey) {
            var _getCurrentTypeahead;

            if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ; else {
              e.preventDefault();
              e.stopPropagation(); // Note: Won't be true for the first keydown
              // but will be overwritten before useLayoutEffect is called
              // to actually apply the change

              if (!imeActive) setNextTypeaheadChar(key);
            }
          }
        };

        return useMergedProps({
          onKeyDown,
          onCompositionStart,
          onCompositionEnd
        }, props);
      }, []); // Handle changes in typeahead that cause changes to the tabbable index

      h(() => {
        if (currentTypeahead && sortedTypeaheadInfo.current.length) {
          const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);

          if (sortedTypeaheadIndex < 0) {
            // The user has typed an entry that doesn't exist in the list
            // (or more specifically "for which there is no entry that starts with that input")
            setInvalidTypeahead(true);
          } else {
            setInvalidTypeahead(false);
            /*
              We know roughly where, in the sorted array of strings, our next typeahead location is.
              But roughly isn't good enough if there are multiple matches.
              To convert our sorted index to the unsorted index we need, we have to find the first
              element that matches us *and* (if any such exist) is *after* our current selection.
                In other words, the only way typeahead moves backwards relative to our current
              position is if the only other option is behind us.
                It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
              Though there's also a case for just going upwards to the nearest to prevent jumpiness.
              But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
              I dunno. Going back to the start is the simplist though.
                Basically what this does: Starting from where we found ourselves after our binary search,
              scan backwards and forwards through all adjacent entries that also compare equally so that
              we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
              (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
                TODO: The binary search starts this off with a solid O(log n), but one-character
              searches are, thanks to pigeonhole principal, eventually guaranteed to become
              O(n*log n). This is annoying but probably not easily solvable? There could be an
              exception for one-character strings, but that's just kicking the can down
              the road. Maybe one or two characters would be good enough though.
            */
            // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.

            let lowestUnsortedIndexAll = null;
            let lowestSortedIndexAll = sortedTypeaheadIndex; // These two are only set for elements that are ahead of us, but the principle's the same otherwise

            let lowestUnsortedIndexNext = null;
            let lowestSortedIndexNext = sortedTypeaheadIndex;

            const updateBestFit = u => {
              var _getIndex;

              if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                lowestUnsortedIndexAll = u;
                lowestSortedIndexAll = i;
              }

              if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > ((_getIndex = getIndex()) !== null && _getIndex !== void 0 ? _getIndex : -Infinity)) {
                lowestUnsortedIndexNext = u;
                lowestSortedIndexNext = i;
              }
            };

            let i = sortedTypeaheadIndex;

            while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              --i;
            }

            i = sortedTypeaheadIndex;

            while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              ++i;
            }

            if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
          }
        }
      }, [currentTypeahead]);
      const useTypeaheadNavigationChild = T$1(_ref4 => {
        let {
          text,
          ...i
        } = _ref4;
        h(() => {
          if (text) {
            // Find where to insert this item.
            // Because all index values should be unique, the returned sortedIndex
            // should always refer to a new location (i.e. be negative)                
            const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
            console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
              unsortedIndex: i.index,
              text
            }) == 0);

            if (sortedIndex < 0) {
              sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, {
                text,
                unsortedIndex: i.index
              });
            } else {
              sortedTypeaheadInfo.current.splice(sortedIndex, 0, {
                text,
                unsortedIndex: i.index
              });
            }

            return () => {
              // When unmounting, find where we were and remove ourselves.
              // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
              const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
              console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
                unsortedIndex: i.index,
                text
              }) == 0);

              if (sortedIndex >= 0) {
                sortedTypeaheadInfo.current.splice(sortedIndex, 1);
              }
            };
          }
        }, [text]);
        return;
      }, []);
      return {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        currentTypeahead,
        invalidTypeahead
      };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */

    function binarySearch(array, wanted, comparator) {
      let firstIndex = 0;
      let lastIndex = array.length - 1;

      while (firstIndex <= lastIndex) {
        const testIndex = lastIndex + firstIndex >> 1;
        const comparisonResult = comparator(wanted, array[testIndex]);

        if (comparisonResult > 0) {
          firstIndex = testIndex + 1;
        } else if (comparisonResult < 0) {
          lastIndex = testIndex - 1;
        } else {
          return testIndex;
        }
      }

      return -firstIndex - 1;
    }

    function useHasFocus(_ref) {
      let {
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onLastActiveElementChange,
        onActiveElementChange,
        onWindowFocusedChange
      } = _ref;
      useEnsureStability("useHasFocus", onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange);
      const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse$1);
      const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse$1);
      const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse$1);
      const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse$1);
      const {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused,
        useActiveElementProps,
        getElement
      } = useActiveElement({
        onActiveElementChange: T$1((activeElement, prevActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == activeElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(activeElement));
          setFocused(focused);
          setFocusedInner(focusedInner);
          onActiveElementChange === null || onActiveElementChange === void 0 ? void 0 : onActiveElementChange(activeElement, prevActiveElement);
        }, []),
        onLastActiveElementChange: T$1((lastActiveElement, prevLastActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == lastActiveElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(lastActiveElement));
          setLastFocused(focused);
          setLastFocusedInner(focusedInner);
          onLastActiveElementChange === null || onLastActiveElementChange === void 0 ? void 0 : onLastActiveElementChange(lastActiveElement, prevLastActiveElement);
        }, []),
        onWindowFocusedChange
      });
      const useHasFocusProps = T$1(props => {
        return useActiveElementProps(props);
      }, [useActiveElementProps]);
      return {
        useHasFocusProps,
        getElement,
        getFocused,
        getFocusedInner,
        getLastFocused,
        getLastFocusedInner,
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }

    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `shouldFocusOnChange` should return true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const [focusedInner, setFocusedInner] = useState(false);
     * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */

    function useRovingTabIndex(_ref) {
      var _initialIndex;

      let {
        initialIndex,
        onChildrenMountChange: onChildrenMountChangeUser,
        onAfterChildLayoutEffect,
        onTabbableRender,
        onTabbableIndexChange,
        onTabbedInTo: onAnyFocusIn,
        onTabbedOutOf: onAnyFocusOut
      } = _ref;
      (_initialIndex = initialIndex) !== null && _initialIndex !== void 0 ? _initialIndex : initialIndex = 0;
      const stableOnTabbableRender = useStableCallback(onTabbableRender !== null && onTabbableRender !== void 0 ? onTabbableRender : () => {});
      const [getAnyFocused, setAnyFocused] = usePassiveState(useStableCallback((newCount, oldCount) => {
        if (oldCount == 0 && newCount > 0) {
          onAnyFocusIn === null || onAnyFocusIn === void 0 ? void 0 : onAnyFocusIn();
        }

        if (newCount == 0 && (oldCount !== null && oldCount !== void 0 ? oldCount : 0) > 0) {
          debugger;
          onAnyFocusOut === null || onAnyFocusOut === void 0 ? void 0 : onAnyFocusOut();
        }
      }), returnZero); // Keep track of three things related to the currently tabbable element's index:
      // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.

      const [getTabbableIndex, setTabbableIndex2] = usePassiveState(onTabbableIndexChange, T$1(() => {
        return initialIndex;
      }, []));
      const setTabbableIndex = T$1((updater, fromUserInteraction) => {
        setTabbableIndex2(prevIndex => {
          var _nextIndex;

          let nextIndex = prevIndex;
          if (typeof updater === "function") nextIndex = updater(prevIndex !== null && prevIndex !== void 0 ? prevIndex : null);else nextIndex = updater;
          (_nextIndex = nextIndex) !== null && _nextIndex !== void 0 ? _nextIndex : nextIndex = 0;
          nextIndex = changeIndex(nextIndex);

          if (prevIndex != nextIndex) {
            const nextChild = nextIndex == null ? null : children.getAt(nextIndex);
            const prevChild = prevIndex == null ? null : children.getAt(prevIndex);
            if (nextChild != null && fromUserInteraction) nextChild.focusSelf();
            if (prevChild != null) prevChild.blurSelf();
          }

          return nextIndex;
        });
      }, []); // Any time the tabbable index changes,
      // notify the previous child that it's no longer tabbable,
      // and notify the next child that is allowed to be tabbed to.

      const {
        children,
        useManagedChild
      } = useManagedChildren({
        onAfterChildLayoutEffect,
        onChildrenMountChange: useStableCallback((mounted, unmounted) => {
          onChildrenMountChangeUser === null || onChildrenMountChangeUser === void 0 ? void 0 : onChildrenMountChangeUser(mounted, unmounted);
          onChildrenMountChange(mounted, unmounted);
        })
      });
      const {
        changeIndex,
        onChildrenMountChange
      } = useChildrenFlag({
        initialIndex,
        children,
        closestFit: true,
        key: "tabbable",
        fitNullToZero: true
      });
      const useRovingTabIndexChild = T$1(_ref2 => {
        let {
          info: {
            index,
            flags,
            blurSelf: bs,
            focusSelf: fs,
            ...restInfo
          }
        } = _ref2;
        const focusSelf = T$1(() => {
          if (fs) {
            fs();
          } else {
            const element = getElement();
            if (element) element.focus();
          }
        }, []);
        const blurSelf = T$1(() => {
          if (bs) {
            bs();
          } else {
            const element = getElement();
            if (element) element.blur();
          }
        }, []);
        const onFocusedInnerChanged = useStableCallback(focused => {
          setAnyFocused(prev => focused ? (prev !== null && prev !== void 0 ? prev : 0) + 1 : (prev !== null && prev !== void 0 ? prev : 0) - 1);
          if (focused) setTabbableIndex(index, true);
        });
        const {
          getElement,
          useHasFocusProps
        } = useHasFocus({
          onFocusedInnerChanged
        });
        const [tabbable, setTabbable, getTabbable] = useState(false);
        const tabbableFlags = _({
          get: getTabbable,
          set: setTabbable,
          isValid: returnTrue
        });

        useManagedChild({
          info: { ...restInfo,
            index,
            flags: {
              tabbable: tabbableFlags.current,
              ...flags
            },
            blurSelf,
            focusSelf,
            getElement
          }
        });

        h(() => {
          if (tabbable) stableOnTabbableRender(index);
        }, [tabbable, index]);

        function useRovingTabIndexChildProps(props) {
          console.assert(props.tabIndex == null);
          return useMergedProps(useHasFocusProps({
            tabIndex: tabbable ? 0 : -1
          }), props);
        }

        return {
          useRovingTabIndexChildProps,
          getElement,
          tabbable
        };
      }, [
        /* Must remain stable */
      ]);
      const focusSelf = T$1(() => {
        var _children$getAt, _children$getAt$focus;

        const index = getTabbableIndex();
        if (index != null) (_children$getAt = children.getAt(index)) === null || _children$getAt === void 0 ? void 0 : (_children$getAt$focus = _children$getAt.focusSelf) === null || _children$getAt$focus === void 0 ? void 0 : _children$getAt$focus.call(_children$getAt);else setTabbableIndex(0, true);
      }, []);
      return {
        useRovingTabIndexChild,
        setTabbableIndex,
        getTabbableIndex,
        focusSelf,
        children
      };
    }

    /** Type of the child's sub-hook */
    //export type UseListNavigationChild<ChildElement extends Element, I extends UseListNavigationChildInfo> = ({ text, index, ...i }: UseListNavigationChildParameters<I>) => UseListNavigationChildReturnType<ChildElement>;

    function identity(t) {
      return t;
    }
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */


    function useListNavigation(_ref) {
      var _indexMangler, _indexDemangler, _navigationDirection, _initialIndex;

      let {
        initialIndex,
        onChildrenMountChange,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        onTabbableIndexChange,
        indexMangler,
        indexDemangler,
        onAfterChildLayoutEffect,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf
      } = _ref;
      (_indexMangler = indexMangler) !== null && _indexMangler !== void 0 ? _indexMangler : indexMangler = identity;
      (_indexDemangler = indexDemangler) !== null && _indexDemangler !== void 0 ? _indexDemangler : indexDemangler = identity;
      (_navigationDirection = navigationDirection) !== null && _navigationDirection !== void 0 ? _navigationDirection : navigationDirection = "either";
      (_initialIndex = initialIndex) !== null && _initialIndex !== void 0 ? _initialIndex : initialIndex = 0;
      useEnsureStability("useListNavigation", indexMangler, indexDemangler);
      const {
        getTabbableIndex,
        setTabbableIndex,
        useRovingTabIndexChild,
        children,
        ...rest1
      } = useRovingTabIndex({
        initialIndex,
        onTabbableIndexChange,
        onChildrenMountChange,
        onAfterChildLayoutEffect,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf
      });
      const navigateToIndex = T$1((i, fromUserInteraction) => {
        var _indexMangler2, _indexDemangler2;

        setTabbableIndex(i == null ? null : tryNavigateToIndex(children, 0, i, 1, (_indexMangler2 = indexMangler) !== null && _indexMangler2 !== void 0 ? _indexMangler2 : identity, (_indexDemangler2 = indexDemangler) !== null && _indexDemangler2 !== void 0 ? _indexDemangler2 : identity), fromUserInteraction);
      }, []);
      const navigateToFirst = T$1(() => {
        var _indexMangler3, _indexDemangler3;

        setTabbableIndex(tryNavigateToIndex(children, 0, 0, 1, (_indexMangler3 = indexMangler) !== null && _indexMangler3 !== void 0 ? _indexMangler3 : identity, (_indexDemangler3 = indexDemangler) !== null && _indexDemangler3 !== void 0 ? _indexDemangler3 : identity), true);
      }, []);
      const navigateToLast = T$1(() => {
        var _indexMangler4, _indexDemangler4;

        setTabbableIndex(tryNavigateToIndex(children, children.getHighestIndex() + 1, children.getHighestIndex(), -1, (_indexMangler4 = indexMangler) !== null && _indexMangler4 !== void 0 ? _indexMangler4 : identity, (_indexDemangler4 = indexDemangler) !== null && _indexDemangler4 !== void 0 ? _indexDemangler4 : identity), true);
      }, []);
      const navigateToPrev = T$1(() => {
        setTabbableIndex(c => {
          var _indexMangler5, _indexDemangler5;

          return tryNavigateToIndex(children, c !== null && c !== void 0 ? c : 0, (c !== null && c !== void 0 ? c : 0) - 1, -1, (_indexMangler5 = indexMangler) !== null && _indexMangler5 !== void 0 ? _indexMangler5 : identity, (_indexDemangler5 = indexDemangler) !== null && _indexDemangler5 !== void 0 ? _indexDemangler5 : identity);
        }, true);
      }, []);
      const navigateToNext = T$1(() => {
        setTabbableIndex(c => {
          var _indexMangler6, _indexDemangler6;

          return tryNavigateToIndex(children, c !== null && c !== void 0 ? c : 0, (c !== null && c !== void 0 ? c : 0) + 1, 1, (_indexMangler6 = indexMangler) !== null && _indexMangler6 !== void 0 ? _indexMangler6 : identity, (_indexDemangler6 = indexDemangler) !== null && _indexDemangler6 !== void 0 ? _indexDemangler6 : identity);
        }, true);
      }, []);
      const setIndex = T$1(index => {
        setTabbableIndex(index, true);
      }, []);
      const {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        ...rest2
      } = useTypeaheadNavigation({
        collator,
        getIndex: getTabbableIndex,
        setIndex,
        typeaheadTimeout,
        noTypeahead
      });
      const {
        useLinearNavigationProps,
        ...rest3
      } = useLinearNavigation({
        navigationDirection,
        navigateToPrev,
        navigateToNext,
        navigateToFirst,
        navigateToLast,
        disableArrowKeys,
        disableHomeEndKeys
      });
      const useListNavigationProps = T$1(props => {
        return useLinearNavigationProps(useTypeaheadNavigationProps(props));
      }, [useLinearNavigationProps, useTypeaheadNavigationProps]);
      const useListNavigationChild = T$1(_ref2 => {
        let {
          info: {
            flags,
            index,
            text,
            blurSelf,
            focusSelf,
            hidden,
            ...restInfo
          }
        } = _ref2;

        useTypeaheadNavigationChild({
          index,
          text
        });

        const {
          useRovingTabIndexChildProps,
          tabbable,
          getElement
        } = useRovingTabIndexChild({
          info: { ...restInfo,
            flags,
            index,
            text,
            blurSelf,
            focusSelf,
            hidden
          }
        });

        const useListNavigationChildProps = function (_ref3) {
          let { ...props
          } = _ref3;
          return useMergedProps(useRovingTabIndexChildProps({
            inert: hidden
          }), props);
        };

        return {
          useListNavigationChildProps,
          tabbable,
          getElement
        };
      }, [useTypeaheadNavigationChild, useRovingTabIndexChild, navigateToIndex]);
      return {
        useListNavigationChild,
        useListNavigationProps,
        getTabbableIndex,
        setTabbableIndex,
        children,
        ...rest1,
        ...rest2,
        ...rest3
      };
    }
    /**
     * It's very common to combine a tabbable list of things and "selection" of one of those things.
     *
     * Lists, radio buttons, tabs, etc. etc.
     *
     * This is a shortcut that combines the two with the correct typing.
     * @param param0
     * @returns
     */

    function useListNavigationSingleSelection(_ref4) {
      let {
        selectedIndex,
        onChildrenMountChange: ocmc,
        ...args
      } = _ref4;
      const list = useListNavigation({
        initialIndex: selectedIndex !== null && selectedIndex !== void 0 ? selectedIndex : 0,
        onTabbedOutOf: useStableCallback(() => {
          if (selectedIndex != null) list.setTabbableIndex(selectedIndex, false);
        }),
        ...args,
        onChildrenMountChange: useStableCallback((m, u) => {
          ocmc === null || ocmc === void 0 ? void 0 : ocmc(m, u);
          onChildrenMountChange(m, u);
        })
      });
      const {
        children,
        useListNavigationChild,
        useListNavigationProps,
        ...listRest
      } = list;
      const {
        changeIndex: changeSelectedIndex,
        getCurrentIndex: getSelectedIndex,
        onChildrenMountChange
      } = useChildrenFlag({
        children: list.children,
        initialIndex: selectedIndex,
        key: "selected",
        closestFit: false
      });
      s(() => {
        console.log(`useEffect(${selectedIndex})`);
        changeSelectedIndex(selectedIndex);
      }, [selectedIndex]);
      return {
        children,
        useListNavigationSingleSelectionChild: T$1(_ref5 => {
          let {
            info: {
              flags: {
                selected,
                ...flags
              },
              ...info
            }
          } = _ref5;
          const [isSelected, setIsSelected, getIsSelected] = useState(getSelectedIndex() == info.index);
          const selectedRef = _({
            get: getIsSelected,
            set: a => {
              setIsSelected(a);
              console.log(`Child ${info.index} had set(${a.toString()}) called`);
            },
            isValid: useStableCallback(() => !info.hidden)
          });
          const ret = useListNavigationChild({
            info: { ...info,
              flags: { ...flags,
                selected: selectedRef.current
              }
            }
          });
          console.log(`Child ${info.index} rendering with selected: ${isSelected} and tabbable: ${ret.tabbable.toString()}`);
          return { ...ret,
            selected: isSelected,
            getSelected: getIsSelected
          };
        }, [useListNavigationChild]),
        useListNavigationSingleSelectionProps: T$1(function () {
          return useListNavigationProps(...arguments);
        }, [useListNavigationProps]),
        ...listRest
      };
    }
    function tryNavigateToIndex(children, initial, target, searchDirection, indexMangler, indexDemangler) {
      function helper() {
        if (searchDirection === -1) {
          while (target >= 0 && (children.getAt(target) == null || !!((_children$getAt = children.getAt(target)) !== null && _children$getAt !== void 0 && _children$getAt.hidden))) {
            var _children$getAt;

            target = indexMangler(indexDemangler(target) - 1);
          }

          return target < 0 ? initial : target;
        } else if (searchDirection === 1) {
          while (target <= children.getHighestIndex() && children.getAt(target) == null || !!((_children$getAt2 = children.getAt(target)) !== null && _children$getAt2 !== void 0 && _children$getAt2.hidden)) {
            var _children$getAt2;

            target = indexMangler(indexDemangler(target) + 1);
          }

          return target > children.getHighestIndex() ? initial : target;
        } else {
          return initial;
        }
      }

      return helper();
    }

    /**
     * Returns a hook that modifies a set of props to provide a randomly-generated ID if one was not provided.
     *
     * If you'd like to use the ID in a property that's *not* named `id` (like `for` or `aria-labelledby` or whatnot), `useReferencedIdProps` is also provided.
     *
     * And the randomly-generated id itself is also provided in case you want to handle the logic yourself without `useMergedProps`.
     *
     * Unlike most other `use*Props` hooks, these are mostly stable.
     */

    function useRandomId(_ref) {
      let {
        prefix,
        onAfterChildLayoutEffect,
        onChildrenMountChange
      } = _ref;
      const [backupRandomId,, getBackupRandomId] = useState(() => generateRandomId(prefix));
      const [usedId, setUsedId, getUsedId] = useState(() => getBackupRandomId());
      const mismatchErrorRef = _(false);
      useEnsureStability("useRandomId", prefix);
      const {
        useManagedChild,
        children
      } = useManagedChildren({
        onAfterChildLayoutEffect,
        onChildrenMountChange
      });
      const useRandomIdSourceElement = T$1(() => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId());
        const {
          useRefElementProps,
          getElement
        } = useRefElement(); // Every time the source element renders, inspect the ID it actually used
        // (whether it was ours or not isn't up to us, it's up to the component)
        // so this is how we notify the referencer component of changes

        h(() => {
          const element = getElement();

          if (element) {
            children.getAt("referencer").setUsedId(element.id);
            setUsedId(element.id);
          }
        });

        useManagedChild({
          info: {
            index: "source",
            setUsedId: setUsedIdLocal
          }
        });

        const useRandomIdSourceElementProps = T$1(function (p) {
          p.id || (p.id = backupRandomId);
          return useRefElementProps(p);
        }, []);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdSourceElementProps
        };
      }, []);
      const useRandomIdReferencerElement = T$1(idPropName => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId()); // Whatever ID was most recently used by the actual "id" prop of the source element

        useEnsureStability(idPropName);

        useManagedChild({
          info: {
            index: "referencer",
            setUsedId: setUsedIdLocal
          }
        });

        const useRandomIdReferencerElementProps = T$1(function (_ref2) {
          let {
            [idPropName]: givenId,
            ...p
          } = _ref2;

          if (givenId && usedId) {
            if (givenId != usedId) {
              if (!mismatchErrorRef.current) {
                mismatchErrorRef.current = true;
                console.error(`Multiple mis-matched IDs were provided for the ${idPropName} prop: the child explicitly specified ${givenId} in its  ${idPropName} prop, but the parent told this child to use ${usedId} (the parent's ID).`);
              }
            }
          }

          return useMergedProps(p, {
            [idPropName]: usedId
          });
        }, [usedId]);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdReferencerElementProps
        };
      }, []);
      return {
        usedId,
        getUsedId,
        useRandomIdSourceElement,
        useRandomIdReferencerElement
      };
    }

    const EventDetail = Symbol("event-detail");
    function enhanceEvent(e, detail) {
      const event = e;
      event[EventDetail] = detail;
      return event;
    }

    let pulse = "vibrate" in navigator ? () => navigator.vibrate(10) : () => {};

    function excludes(target, exclude) {
      if (exclude !== null && exclude !== void 0 && exclude[target]) return true;
      return false;
    }
    /**
     * selection.containsNode doesn't account for selection.isCollapsed,
     * so here's a workaround for that.
     *
     * We also only look for the selection end to only catch the
     * essense of a non-existant "selectionstop" event.
     *
     * @param element
     * @returns
     */


    function nodeSelectedTextLength(element) {
      if (element && element instanceof Node) {
        const selection = window.getSelection();

        for (let i = 0; i < ((_selection$rangeCount = selection === null || selection === void 0 ? void 0 : selection.rangeCount) !== null && _selection$rangeCount !== void 0 ? _selection$rangeCount : 0); ++i) {
          var _selection$rangeCount;

          const range = selection.getRangeAt(i);

          if (element.contains(range.endContainer) && !(selection !== null && selection !== void 0 && selection.isCollapsed)) {
            return selection.toString().length;
          }
        }
      }

      return 0;
    }
    /**
     * Adds the necessary event handlers to create a "press"-like event for
     * buttons and anything else that's "click/tap/press/touch"-able.
     *
     * Notably, the following cases are covered:
     * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
     * * Double-clicks won't select text.
     * * Conversely, manually selecting text won't invoke a press.
     * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
     * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClickSync
     * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
     */


    function usePressEventHandlers(onClickSync, exclude) {
      const {
        useRefElementProps,
        getElement
      } = useRefElement({}); // A button can be activated in multiple ways, so on the off chance
      // that multiple are triggered at once, we only *actually* register
      // a press once all of our "on" signals have turned back to "off".
      // We approximate this by just incrementing when active, and
      // decrementing when deactivated.
      //
      // As an emergency failsafe, when the element looses focus,
      // this is reset back to 0.

      const [active, setActive, getActive] = useState(0); // If we the current text selection changes to include this element
      // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
      // because its only purpose was selecting text, not clicking buttons.
      //
      // To catch this, any time the text selection includes us while in the middle
      // of a click, this flag is set, which cancels the activation of a press.
      // The flag is reset any time the selection is empty or the button is
      // no longer active.

      const [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
      useGlobalHandler(document, "selectionchange", _ => {
        setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
      });
      useEffect(() => {
        if (active == 0) setTextSelectedDuringActivationStartTime(null);
      }, [active == 0]);
      const onActiveStart = useStableCallback(_ => {
        setActive(a => ++a);
      });
      const onActiveStop = useStableCallback(e => {
        setActive(a => Math.max(0, --a));
        const currentTime = new Date();
        const timeDifference = textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime; // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
        // then this isn't a press event.
        // TODO: This should measure glyphs instead of characters.

        if (timeDifference && timeDifference > 250 || nodeSelectedTextLength(getElement()) >= 2) {
          e.preventDefault();
          return;
        }

        if (getActive() <= 0) {
          handlePress(e);
        }
      });
      const handlePress = useStableCallback(e => {
        if (onClickSync) {
          // Note: The element is focused here because of iOS Safari.
          //
          // It's always iOS Safari.
          //
          // iOS Safari (tested on 12) downright refuses to allow 
          // elements to be manually focused UNLESS it happens within
          // an event handler like this.  It also doesn't focus
          // buttons by default when clicked, tapped, etc.
          //
          // If it becomes problematic that button-likes explicitly become
          // focused when they are pressed, then an alternative solution for
          // the question of "how do menu buttons keep their menus open"
          // and other focus-related nonsense needs to be figured out.
          //
          // For iOS Safari.
          //
          const element = getElement();
          if (element && "focus" in element) element === null || element === void 0 ? void 0 : element.focus(); // Whatever the browser was going to do with this event,
          // forget it. We're turning it into a "press" event.

          e.preventDefault(); // Also stop anyone else from listening to this event,
          // since we're explicitly handling it.
          // (Notably, this allows labels to wrap inputs, with them
          // both having press event handlers, without double-firing)

          e.stopPropagation(); // Haptic feedback for this press event

          pulse(); // Actually call our handler.

          onClickSync(e);
        }
      });
      const onMouseDown = excludes("click", exclude) ? undefined : e => {
        // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
        // but also don't prevent the user from selecting that text manually if they really want to
        // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
        if (e.detail > 1) e.preventDefault();
        if (e.button === 0) onActiveStart(e);
      };
      const onMouseUp = excludes("click", exclude) ? undefined : e => {
        if (e.button === 0 && active > 0) onActiveStop(e);
      };

      const onBlur = _ => {
        setActive(0);
      };

      const onMouseLeave = excludes("click", exclude) ? undefined : onBlur;
      const onKeyDown = excludes("space", exclude) && excludes("enter", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync && !excludes("space", exclude)) {
          // We don't actually activate it on a space keydown
          // but we do preventDefault to stop the page from scrolling.
          onActiveStart(e);
          e.preventDefault();
        }

        if (e.key == "Enter" && !excludes("enter", exclude)) {
          e.preventDefault();
          onActiveStart(e);
          onActiveStop(e);
        }
      };
      const onKeyUp = excludes("space", exclude) ? undefined : e => {
        if (e.key == " " && !excludes("space", exclude)) onActiveStop(e);
      };

      const onClick = e => {
        e.preventDefault();

        if (e.detail > 1) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
      };

      return useRefElementProps({
        onKeyDown,
        onKeyUp,
        onBlur,
        onMouseDown,
        onMouseUp,
        onMouseLeave,
        onClick,
        style: textSelectedDuringActivationStartTime != null ? {
          cursor: "text"
        } : undefined,
        ...{
          "data-pseudo-active": active && textSelectedDuringActivationStartTime == null ? "true" : undefined
        }
      });
    }

    function useAriaAccordion(_ref) {
      let {
        initialIndex
      } = _ref;
      //const [lastFocusedIndex, setLastFocusedIndex, _getLastFocusedIndex] = useState<number | null>(null);
      const [_currentFocusedIndex, setCurrentFocusedIndex, getCurrentFocusedIndex] = useState(null);
      const {
        useManagedChild: useManagedChildSection,
        children
      } = useManagedChildren({
        onChildrenMountChange: useStableCallback((m, u) => {
          ocmc1(m, u);
          ocmc2(m, u);
        }),
        onAfterChildLayoutEffect: null
      });
      const navigateToFirst = T$1(() => {
        changeTabbedIndex(0);
      }, []);
      const navigateToLast = T$1(() => {
        changeTabbedIndex(children.getHighestIndex());
      }, []);
      const navigateToPrev = T$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) - 1);
      }, []);
      const navigateToNext = T$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) + 1);
      }, []);
      const {
        useLinearNavigationProps
      } = useLinearNavigation({
        navigationDirection: "block",
        navigateToFirst,
        navigateToLast,
        navigateToPrev,
        navigateToNext
      });
      const {
        changeIndex: changeExpandedIndex,
        getCurrentIndex: getCurrentExpandedIndex,
        onChildrenMountChange: ocmc1
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "open",
        closestFit: false
      });
      const {
        changeIndex: changeTabbedIndex,
        getCurrentIndex: getTabbedIndex,
        onChildrenMountChange: ocmc2
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "tabbed",
        closestFit: false,
        onIndexChange: T$1(i => {
          if (i != null) {
            var _children$getAt;

            (_children$getAt = children.getAt(i)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.focus();
          }
        }, [])
      });
      const useAriaAccordionSection = T$1(_ref2 => {
        var _ref3;

        let {
          open: openFromUser,
          info: args
        } = _ref2;
        const index = args.index;
        const [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
        const {
          useRandomIdSourceElement: useBodyAsSourceId,
          useRandomIdReferencerElement: useHeaderAsReferencerId
        } = useRandomId({
          prefix: "aria-accordion-section-body-",
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        });
        const {
          useRandomIdSourceElement: useHeaderAsSourceId,
          useRandomIdReferencerElement: useBodyAsReferencerId
        } = useRandomId({
          prefix: "aria-accordion-section-header-",
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        });
        const {
          useRandomIdSourceElementProps: useBodyAsSourceIdProps
        } = useBodyAsSourceId();
        const {
          useRandomIdReferencerElementProps: useBodyAsReferencerIdProps
        } = useBodyAsReferencerId("aria-labelledby");
        const {
          useRandomIdSourceElementProps: useHeaderAsSourceIdProps
        } = useHeaderAsSourceId();
        const {
          useRandomIdReferencerElementProps: useHeaderAsReferencerIdProps
        } = useHeaderAsReferencerId("aria-controls");
        const open = (_ref3 = openFromUser !== null && openFromUser !== void 0 ? openFromUser : openFromParent) !== null && _ref3 !== void 0 ? _ref3 : false; //const getOpen = useStableGetter(!!open);

        const getIndex = useStableGetter(index); // TODO: Convert to use useManagedChild so that this hook 
        // is stable without (directly) depending on the open state.

        const {
          getElement: getHeaderElement,
          useRefElementProps: useHeaderRefElementProps
        } = useRefElement({});
        const {
          getElement: getBodyElement,
          useRefElementProps: useBodyRefElementProps
        } = useRefElement({});
        const focus = T$1(() => {
          var _getHeaderElement;

          if (getCurrentFocusedIndex() != null) (_getHeaderElement = getHeaderElement()) === null || _getHeaderElement === void 0 ? void 0 : _getHeaderElement.focus();
        }, []);
        const openRef = _({
          get: () => !!getOpenFromParent(),
          set: open => {
            setOpenFromParent(open);

            if (open) {
              const bodyElement = getBodyElement();
              changeExpandedIndex(getIndex());

              if (bodyElement) {
                queueMicrotask(() => bodyElement.focus());
              }
            }
          },
          isValid: returnTrue
        });
        const tabbedRef = _({
          get: () => getCurrentFocusedIndex() == getIndex(),
          set: open => {
            if (open) setCurrentFocusedIndex(getIndex());
          },
          isValid: returnTrue
        });

        useManagedChildSection({
          info: {
            index,
            setOpenFromParent,
            getOpenFromParent,
            focus,
            flags: {
              open: openRef.current,
              tabbed: tabbedRef.current
            }
          }
        });

        function useAriaAccordionSectionHeaderProps(_ref4) {
          let {
            ["aria-expanded"]: ariaExpanded,
            ["aria-disabled"]: ariaDisabled,
            ...props
          } = _ref4;

          const onFocus = () => {
            changeTabbedIndex(args.index);
          };

          const onClick = () => {
            if (getOpenFromParent()) changeExpandedIndex(null);else changeExpandedIndex(args.index);
          };

          props.tabIndex = 0;
          const retB = useMergedProps(usePressEventHandlers(onClick, undefined), props);
          const retC = useHeaderAsReferencerIdProps({
            "aria-expanded": ariaExpanded !== null && ariaExpanded !== void 0 ? ariaExpanded : open.toString(),
            "aria-disabled": ariaDisabled !== null && ariaDisabled !== void 0 ? ariaDisabled : open ? "true" : undefined,
            ...useHeaderRefElementProps(retB)
          });
          const retD = useHeaderAsSourceIdProps(retC);
          const ret3 = useMergedProps(retD, {
            onFocus
          });
          return useLinearNavigationProps(ret3);
        }

        function useAriaAccordionSectionBodyProps(_ref5) {
          var _ret2$tabIndex;

          let {
            role,
            ...props
          } = _ref5;
          const ret1 = useBodyAsReferencerIdProps({
            role: role !== null && role !== void 0 ? role : "region",
            ...props
          });
          const ret2 = useBodyAsSourceIdProps(ret1);
          (_ret2$tabIndex = ret2.tabIndex) !== null && _ret2$tabIndex !== void 0 ? _ret2$tabIndex : ret2.tabIndex = -1;
          return useBodyRefElementProps(ret2);
        }

        return {
          expanded: open,
          useAriaAccordionSectionHeaderProps,
          useAriaAccordionSectionBodyProps
        };
      }, [useLinearNavigationProps]);
      return {
        changeExpandedIndex,
        useAriaAccordionSection,
        accordionSections: children
      };
    }

    /**
     * Adds an ID and "aria-labelledby" for two elements, an "input" element and a "label" element.
     *
     * Returns the `useReferencedIdProps` hooks if you need to also add other ID-referencer attributes, like `for`
     *
     * @see useInputLabel
     */

    function useLabel() {
      let {
        labelPrefix,
        inputPrefix,
        tagInput,
        tagLabel
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        labelPrefix: "label-",
        inputPrefix: "input-",
        tagInput: "input",
        tagLabel: "label"
      };
      const {
        useRandomIdSourceElement: useLabelAsSourceId,
        useRandomIdReferencerElement: useLabelAsReferencerId,
        usedId: labelId
      } = useRandomId({
        prefix: labelPrefix,
        onAfterChildLayoutEffect: null,
        onChildrenMountChange: null
      });
      const {
        useRandomIdSourceElement: useInputAsSourceId,
        useRandomIdReferencerElement: useInputAsReferencerId,
        usedId: inputId
      } = useRandomId({
        prefix: inputPrefix,
        onAfterChildLayoutEffect: null,
        onChildrenMountChange: null
      });
      const {
        useRandomIdSourceElementProps: useLabelAsSourceIdProps
      } = useLabelAsSourceId();
      const {
        useRandomIdSourceElementProps: useInputAsSourceIdProps
      } = useInputAsSourceId();
      const {
        useRandomIdReferencerElementProps: useLabelAsReferencerIdProps
      } = useLabelAsReferencerId("aria-labelledby");
      const {
        useRandomIdReferencerElementProps: useInputAsReferencerIdProps
      } = useInputAsReferencerId("for");
      let isSyntheticLabel = tagInput != "input" || tagLabel != "label";
      const useLabelLabel = T$1(function useLabelLabel() {
        return {
          useLabelLabelProps: props => {
            let propsWithoutFor = useLabelAsSourceIdProps(props);
            let propsWithFor = useInputAsReferencerIdProps(propsWithoutFor);
            if (tagLabel == "label" && tagInput == "input") return propsWithFor;else return propsWithoutFor;
          }
        };
      }, [isSyntheticLabel]);
      const useLabelInput = T$1(function useLabelInput() {
        return {
          useLabelInputProps: _ref => {
            let {
              "aria-labelledby": ariaLabelledby,
              ...props
            } = _ref;
            console.assert(!ariaLabelledby);
            const propsWithoutAriaLabelledBy = useInputAsSourceIdProps(props);
            const propsWithAriaLabelledBy = useLabelAsReferencerIdProps(propsWithoutAriaLabelledBy);
            if (isSyntheticLabel) return propsWithAriaLabelledBy;else return propsWithoutAriaLabelledBy;
          }
        };
      }, []);
      return {
        useLabelInput,
        useLabelLabel,
        labelId,
        inputId
      };
    }

    const handlesInput = (tag, labelPosition, which) => {
      if (labelPosition === "separate") {
        if (which === "input-element") return true;else if (which === "label-element") return tag != "input";
      } else if (labelPosition === "wrapping") {
        if (which === "input-element") return false;
        if (which == "label-element") return true;
      }
    };
    /**
     * Handles label type (wrapping or separate) for checkboxes, radios, switches, etc.
     * @param param0
     * @returns
     */


    function useCheckboxLike(_ref2) {
      let {
        checked,
        disabled,
        labelPosition,
        onInput,
        role,
        tagInput,
        tagLabel
      } = _ref2;
      const stableOnInput = useStableCallback(e => {
        e.preventDefault();
        onInput === null || onInput === void 0 ? void 0 : onInput(e);
      });
      const {
        useLabelInput: useILInput,
        useLabelLabel: useILLabel,
        inputId,
        labelId
      } = useLabel({
        labelPrefix: "aria-checkbox-label-",
        inputPrefix: "aria-checkbox-input-",
        tagInput: tagInput,
        tagLabel: tagLabel
      });
      const {
        getElement: getLabelElement,
        useRefElementProps: useLabelRefElementProps
      } = useRefElement();
      const {
        getElement: getInputElement,
        useRefElementProps: useInputRefElementProps
      } = useRefElement();
      const useCheckboxLikeInputElement = T$1(function useCheckboxInputElement() {
        const tag = tagInput;
        const {
          useLabelInputProps: useILInputProps
        } = useILInput();
        const {
          useRefElementProps,
          getElement
        } = useRefElement({}); // onClick and onChange are a bit messy, so we need to
        // *always* make sure that the visible state is correct
        // after all the event dust settles.
        // See https://github.com/preactjs/preact/issues/2745,
        // and https://github.com/preactjs/preact/issues/1899#issuecomment-525690194

        h(() => {
          const element = getElement();

          if (element && tag == "input") {
            element.checked = checked;
          }
        }, [tag, checked]);
        return {
          getInputElement: getElement,
          useCheckboxLikeInputElementProps
        };

        function useCheckboxLikeInputElementProps(_ref3) {
          let { ...p0
          } = _ref3;
          // For some reason, Chrome won't fire onInput events for radio buttons that are tabIndex=-1??
          // Needs investigating, but onInput works fine in Firefox
          // TODO
          let props = usePressEventHandlers(disabled || !handlesInput(tag, labelPosition, "input-element") ? undefined : stableOnInput, undefined);
          if (tag == "input") props.onInput = e => e.preventDefault();
          props = useRefElementProps(useILInputProps(props));

          if (labelPosition == "wrapping") {
            // Because the wrapped label handles all interactions,
            // we need to make sure this element can't be interacted with
            // even if it's an input element.
            props.inert = true;
            props.tabIndex = -1;

            props.onFocus = _ => {
              var _getLabelElement;

              return (_getLabelElement = getLabelElement()) === null || _getLabelElement === void 0 ? void 0 : _getLabelElement.focus();
            };
          } else {
            if (tag === "input") {
              props.checked = checked;
            } else {
              props.role = role;
              props.tabIndex = 0;
              props["aria-checked"] = checked ? "true" : undefined;
            }

            props["aria-disabled"] = disabled.toString();
          } // Make sure that label clicks can't affect the checkbox while it's disabled


          props.onClick = disabled ? e => {
            e.preventDefault();
          } : props.onClick;
          return useInputRefElementProps(useMergedProps(p0, props));
        }
      }, [useILInput, role, labelPosition, disabled, checked, tagInput]);
      const useCheckboxLikeLabelElement = T$1(function useCheckboxLabelElement() {
        const tag = tagLabel;
        const {
          useLabelLabelProps: useILLabelProps
        } = useILLabel();

        function useCheckboxLikeLabelElementProps(_ref4) {
          let { ...p0
          } = _ref4;
          const newProps = usePressEventHandlers(disabled || !handlesInput(tag, labelPosition, "label-element") ? undefined : stableOnInput, undefined);

          if (labelPosition == "wrapping") {
            if (p0.tabIndex == null) newProps.tabIndex = 0;
            if (p0.role == null) newProps.role = role;
            newProps["aria-disabled"] = disabled.toString();
            newProps["aria-checked"] = checked.toString();
          } // Just make sure that label clicks can't affect the checkbox while it's disabled


          newProps.onClick = disabled ? e => {
            e.preventDefault();
          } : newProps.onClick;
          return useLabelRefElementProps(useMergedProps(newProps, useILLabelProps(p0)));
        }

        return {
          useCheckboxLikeLabelElementProps
        };
      }, [useILLabel, disabled, checked, role, labelPosition, tagLabel]);
      return {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        getLabelElement,
        getInputElement,
        inputId,
        labelId
      };
    }

    function useAriaCheckbox(_ref) {
      let {
        labelPosition,
        checked,
        onInput,
        disabled,
        tagInput,
        tagLabel
      } = _ref;

      const onInputEnhanced = e => onInput === null || onInput === void 0 ? void 0 : onInput(enhanceEvent(e, {
        checked: !checked
      }));

      const {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        inputId,
        labelId
      } = useCheckboxLike({
        checked: !!checked,
        labelPosition,
        role: "checkbox",
        disabled,
        onInput: onInputEnhanced,
        tagInput: tagInput,
        tagLabel: tagLabel
      });
      const useCheckboxInputElement = T$1(function useCheckboxInputElement() {
        const tag = tagInput;
        const {
          getInputElement,
          useCheckboxLikeInputElementProps
        } = useCheckboxLikeInputElement();
        const isMixed = checked == "mixed";
        h(() => {
          const inputElement = getInputElement();

          if (inputElement && tag === "input") {
            inputElement.indeterminate = isMixed;
          }
        }, [isMixed, tag]);
        return {
          useCheckboxInputElementProps
        };

        function useCheckboxInputElementProps(_ref2) {
          var _props$checked;

          let { ...p0
          } = _ref2;
          const props = useCheckboxLikeInputElementProps(p0);
          (_props$checked = props.checked) !== null && _props$checked !== void 0 ? _props$checked : props.checked = !!checked;
          if (tag == "input") props.type = "checkbox";
          return props;
        }
      }, [useCheckboxLikeInputElement, checked, labelPosition, disabled, tagInput]);
      const useCheckboxLabelElement = T$1(function useCheckboxLabelElement() {
        const {
          useCheckboxLikeLabelElementProps
        } = useCheckboxLikeLabelElement();

        function useCheckboxLabelElementProps(_ref3) {
          let { ...props
          } = _ref3;
          return useCheckboxLikeLabelElementProps(props);
        }

        return {
          useCheckboxLabelElementProps
        };
      }, [useCheckboxLikeLabelElement, disabled, labelPosition, tagLabel]);
      return {
        useCheckboxInputElement,
        useCheckboxLabelElement,
        inputId,
        labelId
      };
    }

    /**
     *
     *
     * @param param0
     * @returns
     */

    function useCheckboxGroup(_ref) {
      let {
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onTabbableIndexChange,
        typeaheadTimeout,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf
      } = _ref;
      //const onUpdateChildren = useStableCallback(onUpdateChildrenUnstable ?? (() => {}));
      const {
        children,
        useListNavigationChild,
        useListNavigationProps,
        currentTypeahead,
        invalidTypeahead,
        getTabbableIndex,
        setTabbableIndex
      } = useListNavigation({
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onTabbableIndexChange,
        typeaheadTimeout,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf
      }); //const [uncheckedCount, setUnheckedCount] = useState(0);
      // Keep track of all child IDs, and any time any of them change, 
      // generate a new string with all of them concatenated together
      // (but only once per render);

      const allIds = _(new Set());
      const [ariaControls, setAriaControls] = useState("");
      const [updateIndex, setIdUpdateIndex] = useState(0);
      const [checkedCount, setCheckedCount] = useState(0);
      const checkedIndices = _(new Set()); //const [selfIsChecked, setSelfIsChecked, getSelfIsChecked] = useState<boolean | "mixed">(false);

      const getSelfIsCheckedUnstable = T$1(() => {
        const percentage = checkedCount / (children.getHighestIndex() + 1);
        return percentage <= 0 ? false : percentage >= 1 ? true : "mixed";
      }, [checkedCount]);
      const getSelfIsCheckedStable = useStableCallback(getSelfIsCheckedUnstable);
      const [setParentCheckboxChecked, setSetParentCheckboxChecked] = useState(null);
      useEffect(() => {
        setParentCheckboxChecked === null || setParentCheckboxChecked === void 0 ? void 0 : setParentCheckboxChecked(checkedCount == 0 ? false : checkedCount == children.getHighestIndex() + 1 ? true : "mixed");
      }, [setParentCheckboxChecked, checkedCount]); // If the user has changed the parent checkbox's value, then this ref holds a memory of what values were held before.
      // Otherwise, it's null when the last input was from a child checkbox. 
      //const savedCheckedValues = useRef<Map<number, boolean | "mixed"> | null>(null);

      const useCheckboxGroupParentInput = T$1(_ref2 => {
        let {
          disabled,
          tagInput,
          labelPosition,
          tagLabel
        } = _ref2;
        const [checked, setChecked] = useState(false);
        useEffect(() => {
          setSetParentCheckboxChecked(() => setChecked);
        }, []);
        const {
          useCheckboxInputElement,
          useCheckboxLabelElement
        } = useAriaCheckbox({
          labelPosition,
          checked,
          onInput: onCheckboxGroupParentInput2,
          disabled,
          tagInput,
          tagLabel
        });
        const {
          useCheckboxInputElementProps
        } = useCheckboxInputElement();
        const {
          useCheckboxLabelElementProps
        } = useCheckboxLabelElement();
        return {
          useCheckboxGroupParentInputProps: function useCheckboxGroupParentInputProps(props) {
            let ret = useMergedProps(useMergedProps({}, {
              "aria-controls": ariaControls,
              onInput: tagInput == "input" ? e => e.preventDefault() : undefined
            }), props);
            return useCheckboxInputElementProps(labelPosition == "separate" ? ret : props);
          },
          useCheckboxGroupParentLabelProps: function useCheckboxGroupParentLabelProps(props) {
            let ret = useMergedProps(useMergedProps({}, {
              "aria-controls": ariaControls
            }), props);
            return useCheckboxLabelElementProps(labelPosition == "wrapping" ? ret : props);
          }
        };
      }, [ariaControls]);
      const onCheckboxGroupParentInput2 = T$1(e => {
        e.preventDefault();
        debugger;
        const selfIsChecked = getSelfIsCheckedStable();
        let nextChecked = selfIsChecked === false ? "mixed" : selfIsChecked === "mixed" ? true : false;
        children.forEach(child => {
          var _child$onInput;

          (_child$onInput = child.onInput) === null || _child$onInput === void 0 ? void 0 : _child$onInput.call(child, enhanceEvent(e, {
            checked: nextChecked == "mixed" ? child.getLastUserChecked() : nextChecked
          }));
        });
        /*if (selfIsChecked === true || (selfIsChecked === false && savedCheckedValues.current == null)) {
            return onUpdateChildren(enhanceEvent(e, { childrenChecked: false }));
        }
        else if (selfIsChecked === "mixed") {
              savedCheckedValues.current = new Map();
            children.forEach(child => {
                savedCheckedValues.current!.set(child.index, child.getLastUserChecked());
            })
              return onUpdateChildren(enhanceEvent(e, { childrenChecked: true }));
        }
        else {
            return onUpdateChildren(enhanceEvent(e, { childrenChecked: savedCheckedValues.current ?? true }));
        }*/
      }, []);
      const notifyChecked = T$1((index, checked) => {
        if (checked === true) {
          if (!checkedIndices.current.has(index)) {
            setCheckedCount(c => c + 1);
            checkedIndices.current.add(index);
          }
        } else {
          if (checkedIndices.current.has(index)) {
            setCheckedCount(c => c - 1);
            checkedIndices.current.delete(index);
          }
        }
      }, []);
      /*useEffect(() => {
          let percentage = checkedCount / managedChildren.length;
          setSelfIsChecked(percentage <= 0 ? false : percentage >= 1 ? true : "mixed")
      }, [setSelfIsChecked, managedChildren.length, checkedCount]);*/

      /*const useCheckboxGroupParentProps = useCallback((props: h.JSX.HTMLAttributes<InputElement>) => {
          return
      }, [ariaControls]);*/

      useEffect(() => {
        setAriaControls(Array.from(allIds.current).join(" "));
      }, [updateIndex]);
      const useCheckboxGroupChild = T$1(function (_ref3) {
        var _labelPosition;

        let {
          info: {
            index,
            text,
            blurSelf,
            flags,
            focusSelf,
            hidden,
            ...restInfo
          },
          checked,
          labelPosition,
          tagLabel,
          onInput,
          disabled,
          tagInput,
          ...restArgs
        } = _ref3;
        (_labelPosition = labelPosition) !== null && _labelPosition !== void 0 ? _labelPosition : labelPosition = "separate";
        const [getLastUserChecked, setLastUserChecked] = usePassiveState(null, returnFalse$1);
        const {
          useCheckboxInputElement,
          useCheckboxLabelElement,
          inputId,
          labelId
        } = useAriaCheckbox({
          labelPosition,
          checked,
          onInput: useStableCallback(e => {
            setLastUserChecked(e[EventDetail].checked);
            onInput === null || onInput === void 0 ? void 0 : onInput(e);
          }),
          disabled,
          tagInput,
          tagLabel
        });
        useStableGetter(checked);
        let controlsId = labelPosition == "separate" ? inputId : labelId;
        useEffect(() => {
          allIds.current.add(controlsId);
          setIdUpdateIndex(i => ++i);
          return () => {
            allIds.current.delete(controlsId);
            setIdUpdateIndex(i => ++i);
          };
        }, [controlsId]);
        useEffect(() => {
          notifyChecked(index, checked);
        }, [index, checked]);
        const {
          tabbable,
          useListNavigationChildProps
        } = useListNavigationChild({
          info: {
            index,
            text,
            getLastUserChecked,
            onInput,
            blurSelf,
            flags,
            focusSelf,
            hidden,
            ...restInfo
          }
        });
        return {
          tabbable,
          useCheckboxGroupChildInputProps: props => {
            const {
              useCheckboxInputElementProps
            } = useCheckboxInputElement();
            let ret = useCheckboxInputElementProps(props);
            let ret2 = useListNavigationChildProps(useListNavigationProps(ret));
            return labelPosition == "separate" ? ret2 : ret;
          },
          useCheckboxGroupChildLabelProps: props => {
            const {
              useCheckboxLabelElementProps
            } = useCheckboxLabelElement();
            let ret = useCheckboxLabelElementProps(props);
            let ret2 = useListNavigationChildProps(useListNavigationProps(ret));
            return labelPosition == "wrapping" ? ret2 : ret;
          }
        };
      }, []);
      return {
        checkboxes: children,
        useCheckboxGroupChild,
        useCheckboxGroupParentInput,
        parentIsChecked: getSelfIsCheckedUnstable(),
        parentPercentChecked: checkedCount / (children.getHighestIndex() + 1),
        currentTypeahead,
        invalidTypeahead
      };
    }

    /**
     * Adds event handlers for a modal-like soft-dismiss interaction.
     *
     * That is, any clicks or taps outside of the given component,
     * or any time the Escape key is pressed within the component,
     * (with various browser oddities regarding clicks on blank or inert areas handled)
     * the component will request to close itself.
     *
     * Of course, if you don't do anything in the `onClose` function,
     * it won't be a soft dismiss anymore.
     *
     * @param param0
     * @returns
     */

    function useSoftDismiss(_ref) {
      let {
        onClose,
        getElements,
        open
      } = _ref;
      const stableOnClose = useStableCallback(onClose);
      const stableGetElements = useStableCallback(getElements);
      const getOpen = useStableGetter(open);
      const onBackdropClick = T$1(function onBackdropClick(e) {
        var _getElement;

        if (!getOpen()) return;
        const document = (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.ownerDocument; // Basically, "was this event fired on the root-most element, or at least an element not contained by the modal?"
        // Either could be how the browser handles these sorts of "interacting with nothing" events.

        if (e.target == (document === null || document === void 0 ? void 0 : document.documentElement)) {
          stableOnClose("backdrop");
        }

        let elements = stableGetElements();

        if (elements && e.target instanceof Element) {
          if (!Array.isArray(elements)) elements = [elements];
          let foundInsideClick = false;

          for (const element of elements) {
            if (element.contains(e.target)) {
              foundInsideClick = true;
              break;
            }
          }

          if (!foundInsideClick) {
            onClose("backdrop");
          }
        }
      }, []);
      const {
        useActiveElementProps,
        getElement
      } = useActiveElement({
        onLastActiveElementChange: T$1(newElement => {
          let validFocusableElements = stableGetElements();

          if (validFocusableElements) {
            if (!Array.isArray(validFocusableElements)) validFocusableElements = [validFocusableElements];

            for (const focusable of validFocusableElements) {
              if (focusable !== null && focusable !== void 0 && focusable.contains(newElement)) return;
            }
          }

          onClose("lost-focus");
        }, [])
      });
      const {
        useRefElementProps
      } = useRefElement({
        onElementChange: T$1(e => {
          const document = e === null || e === void 0 ? void 0 : e.ownerDocument;
          const window = document === null || document === void 0 ? void 0 : document.defaultView; // Since everything else is inert, we listen for captured clicks on the window
          // (we don't use onClick since that doesn't fire when clicked on empty/inert areas)
          // Note: We need a *separate* touch event on mobile Safari, because
          // it doesn't let click events bubble or be captured from traditionally non-interactive elements,
          // but touch events work as expected.

          const mouseDown = e => {
            if (getOpen()) onBackdropClick(e);
          };

          const touchStart = e => {
            if (getOpen()) onBackdropClick(e);
          };

          const keyDown = e => {
            if (e.key === "Escape") {
              stableOnClose("escape");
            }
          };

          window === null || window === void 0 ? void 0 : window.addEventListener("mousedown", mouseDown, {
            capture: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("touchstart", touchStart, {
            capture: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("keydown", keyDown);
          return () => {
            window === null || window === void 0 ? void 0 : window.removeEventListener("mousedown", mouseDown);
            window === null || window === void 0 ? void 0 : window.removeEventListener("touchstart", touchStart);
            window === null || window === void 0 ? void 0 : window.removeEventListener("keydown", keyDown);
          };
        }, [])
      });
      return {
        onBackdropClick,
        useSoftDismissProps: T$1(props => useActiveElementProps(useRefElementProps(props)), [useActiveElementProps, useRefElementProps])
      };
    }
    /**
     * A generic modal hook, used by modal dialogs, but can also
     * be used by anything that's modal with a backdrop.
     * @param param0
     * @returns
     */

    function useModal(_ref2) {
      let {
        open,
        onClose
      } = _ref2;
      const stableOnClose = useStableCallback(onClose);
      const [modalDescribedByBody, setModalDescribedByBody] = useState(false);
      useHideScroll(open);
      const {
        useRandomIdSourceElement: useModalIdAsSource,
        useRandomIdReferencerElement: useModalIdAsReferencerElement
      } = useRandomId({
        prefix: "aria-modal-",
        onAfterChildLayoutEffect: null,
        onChildrenMountChange: null
      });
      const {
        useRandomIdSourceElement: useBodyIdAsSource,
        useRandomIdReferencerElement: useBodyIdReferencerElement
      } = useRandomId({
        prefix: "aria-modal-body-",
        onAfterChildLayoutEffect: null,
        onChildrenMountChange: null
      });
      const {
        useRandomIdSourceElement: useTitleIdAsSource,
        useRandomIdReferencerElement: useTitleIdReferencerElement
      } = useRandomId({
        prefix: "aria-modal-title-",
        onAfterChildLayoutEffect: null,
        onChildrenMountChange: null
      });
      const {
        useRandomIdSourceElementProps: useModalIdAsSourceProps
      } = useModalIdAsSource();
      const {
        useRandomIdSourceElementProps: useBodyIdAsSourceProps
      } = useBodyIdAsSource();
      const {
        useRandomIdSourceElementProps: useTitleIdAsSourceProps
      } = useTitleIdAsSource();
      const {
        useRandomIdReferencerElementProps: useModalIdAsReferencerElementProps
      } = useModalIdAsReferencerElement("data-modal-id");
      const {
        useRandomIdReferencerElementProps: useBodyIdReferencerElementProps
      } = useBodyIdReferencerElement("aria-describedby");
      const {
        useRandomIdReferencerElementProps: useTitleIdReferencerElementProps
      } = useTitleIdReferencerElement("aria-labelledby");
      const {
        useRefElementProps: useModalRefElement,
        getElement: getModalElement
      } = useRefElement({});
      const {
        useSoftDismissProps,
        onBackdropClick
      } = useSoftDismiss({
        onClose: stableOnClose,
        getElements: getModalElement,
        open: !!open
      });
      const useModalBackdrop = T$1(function useModalBackdrop() {
        function useModalBackdropProps(props) {
          return useMergedProps({
            onPointerUp: onBackdropClick
          }, props);
        }

        return {
          useModalBackdropProps
        };
      }, []);

      const useModalProps = function (_ref3) {
        let {
          "aria-modal": ariaModal,
          role,
          ...p0
        } = _ref3;
        console.assert(!ariaModal);
        const {
          useFocusTrapProps
        } = useFocusTrap({
          trapActive: open
        });
        const p1 = useBodyIdReferencerElementProps(p0);
        const p2 = useModalIdAsSourceProps(p1);
        const pFinal = useTitleIdReferencerElementProps(p2);
        return useFocusTrapProps(useSoftDismissProps(useMergedProps(useModalRefElement({
          role: role || "dialog"
        }), modalDescribedByBody ? pFinal : p2)));
      };

      const useModalTitle = T$1(function useModalTitle() {
        const useModalTitleProps = function (props) {
          return useTitleIdAsSourceProps(props);
        };

        return {
          useModalTitleProps
        };
      }, []);
      const useModalBody = T$1(function useModalBody(_ref4) {
        let {
          descriptive
        } = _ref4;
        setModalDescribedByBody(descriptive);

        const useModalBodyProps = function (props) {
          return useBodyIdAsSourceProps(useModalIdAsReferencerElementProps(props));
        };

        return {
          useModalBodyProps
        };
      }, []);
      return {
        useModalProps,
        useModalTitle,
        useModalBody,
        useModalBackdrop
      };
    }
    /**
     * Allows for hiding the scroll bar of the root HTML element
     * without shifting the layout of the page more than adding a fow pixels
     * of padding to the root element if necessary.
     * @param hideScroll
     */

    function useHideScroll(hideScroll) {
      const [getScrollbarWidth, setScrollbarWidth] = usePassiveState(null);
      const [getScrollbarHeight, setScrollbarHeight] = usePassiveState(null);
      h(() => {
        if (hideScroll) {
          // When scrolling is resumed, we'll need to restore the original scroll positions
          // so we need to keep this information around
          const originalScrollTop = document.documentElement.scrollTop;
          const originalScrollLeft = document.documentElement.scrollLeft; // Measure the width of the page (minus the scrollbar)

          const widthWithScrollBar = document.documentElement.scrollWidth;
          const heightWithScrollBar = document.documentElement.scrollHeight; // Apply a class that hides the scrollbar.

          document.documentElement.classList.add("document-scroll-hidden"); // In case multiple things are locking scroll, keep track of how many are doing that
          // (just add 1 on enable, subtract 1 on disable)

          document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") + 1).toString(); // Measure the new width without a scrollbar 
          // so we can take the difference as the scrollbar width.

          const widthWithoutScrollBar = document.documentElement.scrollWidth;
          const heightWithoutScrollBar = document.documentElement.scrollHeight;
          let scrollbarWidth = widthWithoutScrollBar - widthWithScrollBar;
          let scrollbarHeight = heightWithoutScrollBar - heightWithScrollBar; // Failsafe -- if this measuring trick does something unexpected, just ignore it

          if (scrollbarWidth > 80) scrollbarWidth = 0;
          if (scrollbarHeight > 80) scrollbarHeight = 0; // Make our measurements available as CSS properties for general use

          document.documentElement.style.setProperty("--root-scrollbar-width", `${scrollbarWidth}px`);
          document.documentElement.style.setProperty("--root-scrollbar-height", `${scrollbarHeight}px`);
          document.documentElement.style.setProperty("--root-scrollstop-top", `${originalScrollTop}px`);
          document.documentElement.style.setProperty("--root-scrollstop-left", `${originalScrollLeft}px`);
          setScrollbarWidth(scrollbarWidth);
          setScrollbarHeight(scrollbarHeight);
          return () => {
            // Undo all the things we just did
            document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") - 1).toString();

            if (document.documentElement.dataset["scrollHiders"] == "0") {
              // If we were the last scroll-locking thing to stop, then remove the class that stops scrolling.
              document.documentElement.removeAttribute("data-scroll-hiders");
              document.documentElement.classList.remove("document-scroll-hidden"); // Also, restore the original scroll position
              // We do this by forcing the scroll behavior to not be smooth
              // (it's instant if nothing is set to smooth, https://www.w3.org/TR/cssom-view/#scrolling),
              // scrolling, then restoring the original scroll behavior 
              // (which was probably already auto anyway, but just to be safe)

              const originalScrollBehavior = document.documentElement.style.scrollBehavior;
              document.documentElement.style.scrollBehavior = "auto";
              document.documentElement.scrollTo({
                top: originalScrollTop,
                left: originalScrollLeft,
                behavior: "auto"
              });
              document.documentElement.style.scrollBehavior = originalScrollBehavior;
            }
          };
        }
      }, [hideScroll]);
      return {
        getScrollbarWidth,
        getScrollbarHeight
      };
    }

    function useAriaDialog(_ref) {
      let {
        open,
        onClose
      } = _ref;
      // TODO: Differences between dialog and modal go here, presumably.
      // Non-modal dialogs need to be able to be repositioned, etc.
      const {
        useModalBackdrop,
        useModalBody,
        useModalProps,
        useModalTitle
      } = useModal({
        open,
        onClose
      });
      const useDialogBackdrop = T$1(() => {
        const {
          useModalBackdropProps
        } = useModalBackdrop();
        return {
          useDialogBackdropProps: useModalBackdropProps
        };
      }, [useModalBackdrop]);
      const useDialogBody = T$1(_ref2 => {
        let {
          descriptive
        } = _ref2;
        const {
          useModalBodyProps
        } = useModalBody({
          descriptive
        });
        return {
          useDialogBodyProps: useModalBodyProps
        };
      }, [useModalBackdrop]);
      const useDialogProps = useModalProps;
      const useDialogTitle = T$1(() => {
        const {
          useModalTitleProps
        } = useModalTitle();
        return {
          useDialogTitleProps: useModalTitleProps
        };
      }, [useModalTitle]);
      return {
        useDialogProps,
        useDialogTitle,
        useDialogBody,
        useDialogBackdrop
      };
    }

    function useAriaListboxMulti(_ref) {
      let {
        tagLabel,
        tagList,
        ...args
      } = _ref;
      //const { useHasFocusProps, getFocusedInner } = useHasFocus<ListElement>({});
      const {
        useLabelInput,
        useLabelLabel
      } = useLabel({
        labelPrefix: "aria-listbox-label-",
        inputPrefix: "aria-listbox-",
        tagLabel: tagLabel,
        tagInput: tagList
      });
      const {
        useListNavigationChild,
        useListNavigationProps,
        setTabbableIndex,
        currentTypeahead,
        invalidTypeahead,
        children
      } = useListNavigation({ ...args
      });
      const {
        useLabelInputProps
      } = useLabelInput();
      const [, setShiftHeld, getShiftHeld] = useState(false);
      const typeaheadInProgress = !!currentTypeahead;
      h(() => {
        children.forEach(child => child.setTypeaheadInProgress(typeaheadInProgress));
      }, [typeaheadInProgress]);
      const useListboxMultiItem = T$1(_ref2 => {
        let {
          info: {
            index,
            selected,
            tag,
            text,
            hidden,
            onSelect,
            ...restInfo
          },
          disabled
        } = _ref2;
        const [typeaheadInProgress, setTypeaheadInProgress] = useState(false);
        const getSelected = useStableGetter(selected);
        const {
          useRefElementProps,
          getElement
        } = useRefElement({});
        const stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
        const {
          tabbable,
          useListNavigationChildProps
        } = useListNavigationChild({
          info: {
            index,
            selected,
            tag,
            text,
            hidden,
            onSelect,
            setTypeaheadInProgress,
            flags: {},
            ...restInfo
          }
        });
        useLayoutEffect(() => {
          const element = getElement();

          if (element && getShiftHeld()) {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selected: true
              }
            });
          }
        }, [tabbable]);
        return {
          useListboxMultiItemProps,
          tabbable
        };

        function useListboxMultiItemProps(props) {
          const newProps = usePressEventHandlers(disabled ? null : e => {
            console.log(`Multi ${index} is ${getSelected().toString()} and changing to ${(!getSelected()).toString()}`);
            setTabbableIndex(index, false);
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({ ...e,
              [EventDetail]: {
                selected: !getSelected()
              }
            });
            e.preventDefault();
          }, {
            space: typeaheadInProgress ? "exclude" : undefined
          });
          props.role = "option"; //props["aria-setsize"] = (childCount).toString();
          //props["aria-posinset"] = (info.index + 1).toString();

          props["aria-selected"] = (tabbable !== null && tabbable !== void 0 ? tabbable : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useRefElementProps(useListNavigationChildProps(useMergedProps(newProps, props)));
        }
      }, [useListNavigationChild, typeaheadInProgress]);
      const useListboxMultiLabel = T$1(function useListboxMultiLabel() {
        function useListboxMultiLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxMultiLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxMultiItem,
        useListboxMultiProps,
        useListboxMultiLabel,
        currentTypeahead,
        invalidTypeahead
      };

      function useListboxMultiProps(props) {
        props.role = "listbox";
        props["aria-multiselectable"] = "true";
        return useListNavigationProps(useLabelInputProps(useMergedProps({
          onKeyDown,
          onKeyUp,
          onfocusout: onFocusOut
        }, props)));
      }

      function onKeyDown(e) {
        if (e.key == "Shift") setShiftHeld(true);
      }

      function onKeyUp(e) {
        if (e.key == "Shift") setShiftHeld(false);
      }

      function onFocusOut(_) {
        setShiftHeld(false);
      }
    }

    function useAriaListboxSingle(_ref) {
      let {
        selectedIndex,
        onSelect,
        onTabbableIndexChange: otic,
        selectionMode,
        tagList,
        tagLabel,
        ...args
      } = _ref;
      console.log(`Rendering listbox with selectedIndex==${selectedIndex}`);
      const {
        useLabelInput,
        useLabelLabel
      } = useLabel({
        labelPrefix: "aria-listbox-label-",
        inputPrefix: "aria-listbox-",
        tagInput: tagList,
        tagLabel: tagLabel
      });
      const {
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps,
        currentTypeahead,
        invalidTypeahead,
        children,
        getTabbableIndex,
        setTabbableIndex
      } = useListNavigationSingleSelection({
        selectedIndex,
        onTabbableIndexChange: useStableCallback(i => {
          otic === null || otic === void 0 ? void 0 : otic(i);

          if (selectionMode == "focus") {
            var _children$getAt;

            const target = (_children$getAt = children.getAt(i)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.getElement();
            onSelect === null || onSelect === void 0 ? void 0 : onSelect({
              target,
              currentTarget: target,
              [EventDetail]: {
                selectedIndex: i
              }
            });
          }
        }),
        ...args
      });
      const {
        useLabelInputProps
      } = useLabelInput();
      const stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
      const useListboxSingleItem = T$1(_ref2 => {
        let {
          info: { ...info
          },
          disabled
        } = _ref2;
        const {
          tabbable,
          selected,
          getSelected,
          useListNavigationChildProps,
          getElement
        } = useListNavigationSingleSelectionChild({
          info: { ...info,
            getElement: useStableCallback(() => getElement())
          }
        });
        const index = info.index;
        console.log(`Rendering listboxitem #${info.index} with selected==${selected.toString()}`);
        h(() => {
          const element = getElement();

          if (element && tabbable && selectionMode == "focus") {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
          }
        }, [tabbable, selectionMode, index]);
        return {
          useListboxSingleItemProps,
          tabbable,
          selected,
          getSelected
        };

        function useListboxSingleItemProps(props) {
          const newProps = usePressEventHandlers(disabled ? null : e => {
            const element = getElement();
            if (element) stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
            e.preventDefault();
          }, undefined);
          props.role = "option"; //props["aria-setsize"] = (children.getHighestIndex() + 1).toString();
          //props["aria-posinset"] = (info.index + 1).toString();

          props["aria-selected"] = (selected !== null && selected !== void 0 ? selected : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useListNavigationChildProps(useMergedProps(newProps, props));
        }
      }, [useListNavigationSingleSelectionChild, selectionMode]);
      const useListboxSingleLabel = T$1(function useListboxSingleLabel() {
        function useListboxSingleLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          useLabelLabelProps(props);
        }

        return {
          useListboxSingleLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxSingleItem,
        useListboxSingleProps,
        useListboxSingleLabel,
        currentTypeahead,
        invalidTypeahead,
        children
      };

      function useListboxSingleProps(props) {
        props.role = "listbox";
        return useListNavigationSingleSelectionProps(useLabelInputProps(props));
      }
    }

    /**
     * A menu is a popup control that contains a list of menu items, and that's it.
     * It has very well-defined logic for managing those items as the menu's state changes.
     *
     * A MenuBase is just the "popup" part without the "list of menu items" part. It can
     * (really, must) have interactive controls, but these controls are allowed to be more
     * free-form. This means that, like a dialog, you must tell this hook
     * where within the popup to send focus when opened (for a menu it's just the first
     * menu item, but with custom content you'll need to provide this).
     *
     */

    function useMenuBase(_ref) {
      let {
        sendFocusWithinMenu,
        ...args
      } = _ref;
      const getSendFocusWithinMenu = useStableGetter(sendFocusWithinMenu);
      const [focusTrapActive, setFocusTrapActive] = useState(null);
      const onClose = args.onClose;
      const onOpen = args.onOpen; //const menubar = (args as Partial<UseMenuParameters2<E, K, I>>).menubar;

      const open = args.open;
      const stableOnClose = useStableCallback(onClose !== null && onClose !== void 0 ? onClose : () => {});
      const getOpen = useStableGetter(open); // TODO: It's awkward that the button focus props are out here where we don't have its type,
      // but focus management is super sensitive, and even waiting for a useLayoutEffect to sync state here
      // would be too late, so it would look like there's a moment between menu focus lost and button focus gained
      // where nothing is focused. 

      const {
        useHasFocusProps: useMenuBaseHasFocusProps,
        getLastFocusedInner: getMenuBaseLastFocusedInner
      } = useHasFocus({
        /*onLastFocusedInnerChanged: onMenuOrButtonLostLastFocus*/
      });
      const {
        useHasFocusProps: useButtonHasFocusProps,
        getLastFocusedInner: getMenuBaseButtonLastFocusedInner
      } = useHasFocus({
        /*onLastFocusedInnerChanged: onMenuOrButtonLostLastFocus*/
      });
      const [, setOpenerElement, getOpenerElement] = useState(null);
      const {
        useRandomIdSourceElement,
        useRandomIdReferencerElement
      } = useRandomId({
        prefix: "aria-menu-"
      });
      const {
        useRandomIdSourceElementProps
      } = useRandomIdSourceElement();
      const {
        useRandomIdReferencerElementProps
      } = useRandomIdReferencerElement("aria-controls");
      const {
        getElement: getButtonElement,
        useRefElementProps: useButtonRefElementProps
      } = useRefElement({
        onElementChange: setOpenerElement
      });
      const {
        getElement: getMenuElement,
        useRefElementProps: useMenuBaseRefElementProps
      } = useRefElement({});
      const {
        useSoftDismissProps
      } = useSoftDismiss({
        onClose: stableOnClose,
        getElements: () => [getButtonElement(), getMenuElement()],
        open: !!open
      });
      h(() => {
        setFocusTrapActive(open === true);
      }, [open]);
      const useMenuBaseProps = T$1(props => {
        function onKeyDown(e) {
          if (e.key == "Escape" && getOpen()) {
            stableOnClose();
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.preventDefault();
          }
        }

        return useSoftDismissProps(useMenuBaseHasFocusProps(useMenuBaseRefElementProps(useRandomIdSourceElementProps(useMergedProps({
          onKeyDown
        }, props)))));
      }, [useSoftDismissProps, useMenuBaseHasFocusProps, useMenuBaseRefElementProps, useRandomIdSourceElementProps]);
      const useMenuBaseButtonProps = T$1(props => {
        return useButtonRefElementProps(useButtonHasFocusProps(useRandomIdReferencerElementProps(props)));
      }, [useButtonHasFocusProps, useButtonRefElementProps, useRandomIdReferencerElementProps]);
      h(() => {
        const sendFocusWithinMenu = getSendFocusWithinMenu();

        if (focusTrapActive) {
          sendFocusWithinMenu === null || sendFocusWithinMenu === void 0 ? void 0 : sendFocusWithinMenu();
        } else if (focusTrapActive === false) {
          var _getOpenerElement;

          if (getMenuBaseLastFocusedInner()) (_getOpenerElement = getOpenerElement()) === null || _getOpenerElement === void 0 ? void 0 : _getOpenerElement.focus({
            preventScroll: true
          });
        } else ;
      }, [focusTrapActive]);
      return {
        useMenuSentinel: T$1(() => {
          const {
            useSentinelProps: useMenuSentinelProps,
            ...rest
          } = useFocusSentinel({
            open: open === true,
            onClose: onClose !== null && onClose !== void 0 ? onClose : () => {},
            sendFocusWithinMenu
          });
          return {
            useMenuSentinelProps,
            ...rest
          };
        }, [open, onClose, sendFocusWithinMenu]),
        focusTrapActive,
        useMenuBaseProps,
        useMenuBaseButtonProps,
        getMenuBaseLastFocusedInner,
        getMenuBaseButtonLastFocusedInner,
        open,
        onOpen,
        onClose
      };
    } // A focus sentinal is a hidden but focusable element that comes at the start or end 
    // of the out-of-place-focusable component that, when activated or focused over, closes the component
    // (if focused within 100ms of the open prop changing, instead of
    // closing, focusing the sentinel immediately asks it to focus itself).
    // This exists for things like menus which can have focus but also need a way to return
    // to whatever out-of-place parent they came from when naturally tabbed out of (as opposed
    // to dialogs which loop back around when tabbed out of). While mouse users can click out of a menu
    // and keyboard users can escape to close a menu, screen readers and other input methods 
    // that don't use those two would become stuck.

    function useFocusSentinel(_ref2) {
      let {
        open,
        onClose,
        sendFocusWithinMenu
      } = _ref2;
      const getSendFocusWithinMenu = useStableGetter(sendFocusWithinMenu);
      const stableOnClose = useStableCallback(onClose);
      const [firstSentinelIsActive, setFirstSentinelIsActive] = useState(false);
      useTimeout({
        callback: () => {
          setFirstSentinelIsActive(open);
        },
        timeout: 100,
        triggerIndex: `${open}-${firstSentinelIsActive}`
      });
      const onFocus = firstSentinelIsActive ? () => stableOnClose() : () => {
        var _getSendFocusWithinMe;

        return (_getSendFocusWithinMe = getSendFocusWithinMenu()) === null || _getSendFocusWithinMe === void 0 ? void 0 : _getSendFocusWithinMe();
      };

      const onClick = () => stableOnClose();

      return {
        useSentinelProps: function (p) {
          return useMergedProps({
            onFocus,
            onClick
          }, p);
        }
      };
    }
    function useAriaMenu(_ref3) {
      let {
        collator,
        noTypeahead,
        typeaheadTimeout,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        onChildrenMountChange,
        onTabbableIndexChange,
        ...args
      } = _ref3;
      const {
        children: managedChildren,
        useListNavigationChild,
        useListNavigationProps,
        currentTypeahead,
        invalidTypeahead,
        focusSelf: focusMenu
      } = useListNavigation({
        collator,
        noTypeahead,
        typeaheadTimeout,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        onChildrenMountChange,
        onTabbableIndexChange
      });
      const {
        useMenuSentinel,
        useMenuBaseButtonProps,
        useMenuBaseProps,
        getMenuBaseButtonLastFocusedInner,
        getMenuBaseLastFocusedInner,
        open,
        onOpen,
        onClose
      } = useMenuBase({ ...args,
        sendFocusWithinMenu: focusMenu !== null && focusMenu !== void 0 ? focusMenu : () => {}
      });

      const useMenuButtonProps = p => {
        const props = useMenuBaseButtonProps(p);
        props["aria-haspopup"] = "menu";
        props["aria-expanded"] = open ? "true" : undefined;
        return props;
      };

      const useMenuItem = T$1(args => {
        const {
          useListNavigationChildProps
        } = useListNavigationChild(args);

        function useMenuItemProps(_ref4) {
          let { ...props
          } = _ref4;
          props.role = "menuitem";
          return useMergedProps({}, useListNavigationChildProps(props));
        }

        return {
          useMenuItemProps
        };
      }, []);

      function useMenuProps(_ref5) {
        let { ...props
        } = _ref5;
        props.role = "menu";
        return useMenuBaseProps(useListNavigationProps(props));
      }

      return {
        useMenuProps,
        useMenuButtonProps,
        useMenuItem,
        useMenuSentinel,
        //useMenuSubmenuItem,
        focusMenu,
        currentTypeahead,
        invalidTypeahead,
        managedChildren
      };
    }

    function useAriaRadioGroup(_ref) {
      let {
        name,
        selectedValue,
        onInput,
        tagGroup,
        tagGroupLabel,
        initialIndex,
        onAfterChildLayoutEffect,
        onChildrenMountChange: ocmc,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        navigationDirection,
        noTypeahead,
        onTabbableIndexChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf,
        typeaheadTimeout
      } = _ref;
      const {
        getElement: getRadioGroupParentElement,
        useRefElementProps
      } = useRefElement({}); //const getSelectedIndex = useCallback((selectedValue: V) => { return byName.current.get(selectedValue) ?? 0 }, [])

      const [selectedIndex, setSelectedIndex] = useState(0);
      const byName = _(new Map());
      const stableOnInput = useStableCallback(onInput); //const [anyRadiosFocused, setAnyRadiosFocused, getAnyRadiosFocused] = useState(false);

      const {
        useLabelInput: useGroupLabelInput,
        useLabelLabel: useGroupLabelLabel
      } = useLabel({
        labelPrefix: "aria-radio-group-label-",
        tagInput: tagGroup,
        tagLabel: tagGroupLabel,
        inputPrefix: "aria-radio-group-"
      });
      const {
        useLabelInputProps: useGroupLabelInputProps
      } = useGroupLabelInput();
      const {
        useLabelLabelProps: useGroupLabelLabelProps
      } = useGroupLabelLabel();
      const {
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps,
        currentTypeahead,
        invalidTypeahead,
        children,
        getTabbableIndex,
        setTabbableIndex
      } = useListNavigationSingleSelection({
        selectedIndex,
        onAfterChildLayoutEffect,
        onChildrenMountChange: useStableCallback((m, u) => {
          ocmc === null || ocmc === void 0 ? void 0 : ocmc(m, u);
        }),
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        navigationDirection,
        noTypeahead,
        onTabbableIndexChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf,
        typeaheadTimeout
      }); // Track whether the currently focused element is a child of the radio group parent element.
      // When it's not, we reset the tabbable index back to the currently selected element.
      //const { useActiveElementProps } = useActiveElement<G>({ onActiveElementChange: useCallback((activeElement: Node | null) => setAnyRadiosFocused(!!(getRadioGroupParentElement()?.contains(activeElement))), []) });

      /*useEffect(() => {
          if (!anyRadiosFocused)
              navigateToIndex(selectedIndex ?? 0);
      }, [anyRadiosFocused, selectedIndex, navigateToIndex]);*/

      const useRadioGroupProps = T$1(_ref2 => {
        let { ...props
        } = _ref2;
        props.role = "radiogroup";
        return useGroupLabelInputProps(useListNavigationSingleSelectionProps(useRefElementProps(props)));
      }, [useRefElementProps]);
      const useRadioGroupLabelProps = T$1(props => {
        return useGroupLabelLabelProps(props);
      }, [useGroupLabelLabelProps]); //const correctedIndex = (selectedIndex == null || selectedIndex < 0 || selectedIndex >= managedChildren.length) ? null : selectedIndex;

      /*const { onChildrenMountChange } = useChildrenFlag({
          initialIndex: 0,
          children,
          key: "selected"
          //setChildFlag: (i, checked) => managedChildren[i]?.setChecked(checked),
          //getChildFlag: ((i) => managedChildren[i]?.getChecked() ?? false)
      });*/

      h(() => {
        const selectedIndex = byName.current.get(selectedValue);
        setSelectedIndex(selectedIndex !== null && selectedIndex !== void 0 ? selectedIndex : null);
      }, [byName, selectedValue]);
      const useRadio = T$1(function useAriaRadio(_ref3) {
        let {
          info: {
            index,
            text
          },
          disabled,
          labelPosition,
          value,
          tagInput,
          tagLabel,
          ...rest
        } = _ref3;
        const [checked, setChecked, getChecked] = useState(null);
        const onInput = T$1(e => {
          stableOnInput(enhanceEvent(e, {
            selectedValue: value
          }));
        }, [stableOnInput, value, index]);
        const {
          useCheckboxLikeInputElement,
          useCheckboxLikeLabelElement
        } = useCheckboxLike({
          checked: checked !== null && checked !== void 0 ? checked : false,
          disabled,
          labelPosition,
          onInput,
          role: "radio",
          tagInput: tagInput,
          tagLabel: tagLabel
        });
        s(() => {
          byName.current.set(value, index);
          return () => {
            byName.current.delete(value);
          };
        }, [byName, value, index]);
        const {
          tabbable,
          useListNavigationChildProps
        } = useListNavigationSingleSelectionChild({
          info: {
            index,
            setChecked,
            getChecked,
            text,
            ...rest
          }
        });

        const useRadioInput = () => {
          const tag = tagInput;

          const useRadioInputProps = props => {
            if (tag == "input") {
              props.name = name;
              props.checked = checked !== null && checked !== void 0 ? checked : false;
              props.type = "radio";
            } else {
              props["aria-checked"] = (checked !== null && checked !== void 0 ? checked : false).toString();
            }

            const propsIfInputHandlesFocus = useListNavigationChildProps(props);
            const {
              useCheckboxLikeInputElementProps
            } = useCheckboxLikeInputElement();
            return useMergedProps(useCheckboxLikeInputElementProps({}), labelPosition == "separate" ? propsIfInputHandlesFocus : props);
          };

          return {
            useRadioInputProps
          };
        };

        const useRadioLabel = T$1(() => {

          const useRadioLabelProps = props => {
            const {
              useCheckboxLikeLabelElementProps
            } = useCheckboxLikeLabelElement();
            const propsIfLabelHandlesFocus = useListNavigationChildProps(props);
            return useCheckboxLikeLabelElementProps(useMergedProps({}, labelPosition == "wrapping" ? propsIfLabelHandlesFocus : props));
          };

          return {
            useRadioLabelProps
          };
        }, [useCheckboxLikeLabelElement]);
        return {
          useRadioInput,
          useRadioLabel,
          checked: checked !== null && checked !== void 0 ? checked : false,
          tabbable: tabbable !== null && tabbable !== void 0 ? tabbable : false
        };
      }, [byName, useListNavigationSingleSelectionChild]);
      return {
        useRadio,
        useRadioGroupProps,
        useRadioGroupLabelProps,
        selectedIndex,
        currentTypeahead,
        invalidTypeahead
      };
    }

    function useAriaTabs(_ref) {
      var _selectionMode;

      let {
        selectionMode,
        selectedIndex,
        onSelect,
        orientation: logicalOrientation,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onChildrenMountChange,
        onTabbableIndexChange: otic,
        typeaheadTimeout,
        ...args
      } = _ref;
      (_selectionMode = selectionMode) !== null && _selectionMode !== void 0 ? _selectionMode : selectionMode = "focus";
      const {
        children: tabs,
        currentTypeahead,
        focusSelf,
        getTabbableIndex,
        setTabbableIndex,
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps
      } = useListNavigationSingleSelection({
        selectedIndex,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        navigationDirection,
        noTypeahead,
        onChildrenMountChange,
        onTabbableIndexChange: useStableCallback(i => {
          otic === null || otic === void 0 ? void 0 : otic(i);

          if (selectionMode == "focus") {
            var _tabs$getAt;

            const target = (_tabs$getAt = tabs.getAt(i)) === null || _tabs$getAt === void 0 ? void 0 : _tabs$getAt.getElement();
            onSelect === null || onSelect === void 0 ? void 0 : onSelect({
              target,
              currentTarget: target,
              [EventDetail]: {
                selectedIndex: i
              }
            });
          }
        }),
        typeaheadTimeout,
        ...args
      });
      const {
        children: panels,
        useManagedChild: useManagedPanel
      } = useManagedChildren({
        onAfterChildLayoutEffect: null,
        onChildrenMountChange: null
      });
      const {
        useRandomIdSourceElement: useLabelIdSourceElement,
        useRandomIdReferencerElement: useLabelIdReferencerElement
      } = useRandomId({
        prefix: "tabs-label-",
        onAfterChildLayoutEffect: null,
        onChildrenMountChange: null
      }); //const { useRandomIdSourceElement: useListIdSourceElement, useRandomIdReferencerElement: useListIdReferencerElement } = useRandomId({ prefix: "tabs-list-" });

      const {
        useRandomIdSourceElementProps: useLabelIdSourceElementProps
      } = useLabelIdSourceElement();
      const {
        useRandomIdReferencerElementProps: useLabelIdReferencerElementProps
      } = useLabelIdReferencerElement("labelled-by"); //const { useRandomIdSourceElementProps: useListIdSourceElementProps } = useListIdSourceElement();
      //const { useRandomIdReferencerElementProps: useListIdReferencerElementProps } = useListIdReferencerElement("labelled-by" as never);

      const useTabsLabelProps = T$1(props => {
        return useLabelIdSourceElementProps(useMergedProps({}, props));
      }, []);
      const useTabsListProps = T$1(props => {
        return useLabelIdReferencerElementProps(useListNavigationSingleSelectionProps(useMergedProps({
          role: "tablist"
        }, props)));
      }, []);
      /*const useTabSet: UseTabSet<TabElement, TabPanelElement, I> = useCallback((info: I) => {
          const { useRandomIdSourceElement: useTabIdSourceElement, useRandomIdReferencerElement: useTabIdReferencerElement } = useRandomId<TabElement>({ prefix: "tab-" });
          const { useRandomIdSourceElement: useTabPanelIdSourceElement, useRandomIdReferencerElement: useTabPanelIdReferencerElement } = useRandomId<TabPanelElement>({ prefix: "tab-panel-" });
          const { useRandomIdSourceElementProps: useTabIdSourceElementProps } = useTabIdSourceElement();
          const { useRandomIdReferencerElementProps: useTabIdReferencerElementProps } = useTabIdReferencerElement<TabPanelElement>("labelled-by" as never);
          const { useRandomIdSourceElementProps: useTabPanelIdSourceElementProps } = useTabPanelIdSourceElement();
          const { useRandomIdReferencerElementProps: useTabPanelIdReferencerElementProps } = useTabPanelIdReferencerElement<TabElement>("aria-controls" as never);
          const { getElement, getSelected, selected, tabbable, useListNavigationChildProps } = useListNavigationSingleSelectionChild(info);
          const useTabProps = useCallback((props: h.JSX.HTMLAttributes<TabElement>): h.JSX.HTMLAttributes<TabElement> => { return useTabIdSourceElementProps(useTabPanelIdReferencerElementProps(useListNavigationChildProps(useMergedProps<TabElement>({ role: "tab" }, props)))) }, []);
          const usePanelProps = useCallback((props: h.JSX.HTMLAttributes<TabPanelElement>): h.JSX.HTMLAttributes<TabPanelElement> => { return useTabPanelIdSourceElementProps(useTabIdReferencerElementProps(useMergedProps<TabPanelElement>({ role: "tabpanel" }, props))) }, []);
            return {
              useTabProps,
              usePanelProps,
              selected,
              tabbable,
              getSelected
          }
      }, []);*/

      const useTab = T$1(_ref2 => {
        let { ...info
        } = _ref2;
        const [correspondingPanelId, setCorrespondingPanelId] = useState(null);
        const [randomTabId] = useState(() => generateRandomId("tab-"));
        const {
          getElement,
          getSelected,
          selected,
          tabbable,
          useListNavigationChildProps
        } = useListNavigationSingleSelectionChild({
          info: { ...info,
            setCorrespondingPanelId
          }
        });
        const pressProps = usePressEventHandlers(e => {
          onSelect({ ...e,
            [EventDetail]: {
              selectedIndex: info.index
            }
          });
        }, {});
        useLayoutEffect(() => {
          var _panels$getAt;

          (_panels$getAt = panels.getAt(info.index)) === null || _panels$getAt === void 0 ? void 0 : _panels$getAt.setVisible(selected);
        }, [info.index, selected]);
        return {
          getElement,
          getSelected,
          selected,
          tabbable,
          useTabProps: function useTabProps(props) {
            return useListNavigationChildProps(useMergedProps({
              "aria-controls": correspondingPanelId,
              id: randomTabId,
              ...pressProps
            }, props));
          }
        };
      }, []);
      const useTabPanel = T$1(_ref3 => {
        let { ...info
        } = _ref3;
        const [correspondingTabId, setCorrespondingTabId] = useState(null);
        const [visible, setVisible] = useState(false);

        useManagedPanel({
          info: { ...info,
            setCorrespondingTabId,
            setVisible
          }
        });

        const [randomPanelId] = useState(() => generateRandomId("tab-panel-"));
        return {
          visible,
          useTabPanelProps: function useTabPanelProps(props) {
            return useMergedProps({
              "aria-labelledby": correspondingTabId,
              id: randomPanelId
            }, props);
          }
        };
      }, []);
      return {
        useTabsLabelProps,
        useTabsListProps,
        useTab,
        useTabPanel,
        currentTypeahead,
        focusSelf,
        getTabbableIndex
      };
      /* const { useHasFocusProps: useTabListHasFocusProps, getFocusedInner: getTabListFocusedInner } = useHasFocus<ListElement>({});
       const [physicalOrientation, setPhysicalOrientation] = useState<"horizontal" | "vertical">("horizontal");
       const { convertToPhysicalOrientation, useLogicalDirectionProps } = useLogicalDirection<ListElement>({ onLogicalDirectionChange: useCallback((logicalDirectionInfo: LogicalDirectionInfo | null) => setPhysicalOrientation(convertToPhysicalOrientation(logicalOrientation, logicalDirectionInfo)), []) });
          //const { useRandomIdProps: useTabListIdProps, useReferencedIdProps: useReferencedTabListId } = useRandomId({ prefix: "aria-tab-list-" });
          const { useRandomIdSourceElement: useTabListId, useRandomIdReferencerElement: useTabListIdReferencer } = useRandomId<ListElement>({ prefix: "aria-tabs-label-" });
       const { useRandomIdSourceElementProps: useTabListIdProps } = useTabListId();
       const { useRandomIdReferencerElementProps: useTabListIdReferencerProps } = useTabListIdReferencer("aria-labelledby");
          const { managedChildren: managedTabs, navigateToIndex, useListNavigationChild, useListNavigationProps, tabbableIndex, invalidTypeahead, currentTypeahead, focusCurrent } = useListNavigation<TabElement, UseTabInfo>({ ...args, shouldFocusOnChange: getTabListFocusedInner, keyNavigation: logicalOrientation });
       const { managedChildren: managedPanels, useManagedChild: useManagedTabPanel } = useChildManager<UseTabPanelInfo2>()
          const childCount = managedTabs.length;
      
       useLayoutEffect(() => {
           for (const child of managedTabs)
               child.setSelectionMode(selectionMode);
       }, [selectionMode])
      
       useChildFlag({ activatedIndex: selectedIndex, managedChildren: managedTabs, setChildFlag: (i, selected) => managedTabs[i]?.setSelected(selected), getChildFlag: i => (managedTabs[i]?.getSelected()) });
       useChildFlag({ activatedIndex: selectedIndex, managedChildren: managedPanels, setChildFlag: (i, visible) => managedPanels[i]?.setVisible(visible), getChildFlag: i => (managedPanels[i]?.getVisible()) });
          useLayoutEffect((_prev) => {
           if (selectedIndex != null && selectionMode == "activate") {
               // TODO: We need to wait a moment so that the tab panel we want to focus
               // is actually visible (i.e. we need to wait for the child to re-render itself).
               // We could, alternatively, signal to the child that it should focus itself
               // the next time it renders itself as visible,
               // which might be better?
               queueMicrotask(() => {
                   managedPanels[selectedIndex]?.focus();
               });
           }
       }, [childCount, selectedIndex, selectionMode]);
          const { useRandomIdSourceElement: useLabelIdElement, useRandomIdReferencerElement: useLabelIdReferencer } = useRandomId<LabelElement>({ prefix: "aria-tabs-label" });
       const { useRandomIdReferencerElementProps: useLabelIdReferencerProps } = useLabelIdReferencer<ListElement>("aria-labelledby");
          const useTabSet = useCallback((info: UseTabSetParameters<TabElement, I>) => {
              const [selectionModeL, setSelectionModeL] = useState<"focus" | "activate">(selectionMode);
           const { useRefElementProps, getElement } = useRefElement<TabElement>({})
           const { useRandomIdSourceElement: useTabIdElement, useRandomIdReferencerElement: useTabIdReferencer } = useRandomId<TabElement>({ prefix: "aria-tab-" });
           const { useRandomIdSourceElement: useTabPanelIdElement, useRandomIdReferencerElement: useTabPanelIdReferencer } = useRandomId<TabPanelElement>({ prefix: "aria-tab-panel" });
           const [selected, setSelected, getSelected] = useState<boolean | null>(null);
           const { tabbable, useListNavigationChildProps } = useListNavigationChild({ setSelected, getSelected, setSelectionMode: setSelectionModeL, ...info });
           const getIndex = useStableGetter(info.index);
              const useTabProps = (props: h.JSX.HTMLAttributes<TabElement>) => {
               const { useRandomIdReferencerElementProps: useTabPanelIdReferencerProps } = useTabIdReferencer<TabElement>("aria-labelledby");
               const { useRandomIdSourceElementProps: useTabIdProps } = useTabIdElement();
               const newProps: h.JSX.HTMLAttributes<TabElement> = usePressEventHandlers<TabElement>((e) => {
                   navigateToIndex(info.index);
                   onSelect?.(enhanceEvent(e, { selectedIndex: getIndex() }));
                   e.preventDefault();
               }, undefined)(props);
                  newProps.role = "tab";
               newProps["aria-selected"] = (selected ?? false).toString();
                  return useTabPanelIdReferencerProps(useTabIdProps(useListNavigationChildProps(useRefElementProps(newProps))));
           };
           const useTabPanelProps = (props: h.JSX.HTMLAttributes<TabPanelElement>) => {
               const { useRandomIdReferencerElementProps: useTabIdReferencerProps } = useTabIdReferencer<TabPanelElement>("aria-controls");
               const { useRandomIdSourceElementProps: useTabPanelIdProps } = useTabPanelIdElement();
               props.role = "tabpanel";
               props.tabIndex ??= -1;      // Make sure the tab panel is tabbable.
               return useMergedProps<TabPanelElement>({}, useTabIdReferencerProps(useTabPanelIdProps(props)));
           };
              return { useTabProps, useTabPanelProps }
       }, []);
      
       const useTabListProps = (props: h.JSX.HTMLAttributes<ListElement>) => {
           return useMergedProps({ role: "tablist" }, useLabelIdReferencerProps(props));
       };
      
       return { useTabSet, useTabListProps, tabbableIndex, focusTabList: focusCurrent, currentTypeahead, invalidTypeahead, managedPanels, managedTabs };*/
    }

    function returnFalse() {
      return false;
    }

    function useAriaTooltip(_ref) {
      var _mouseoverDelay, _mouseoutDelay, _focusDelay;

      let {
        mouseoverDelay,
        mouseoutDelay,
        focusDelay
      } = _ref;
      (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
      (_mouseoutDelay = mouseoutDelay) !== null && _mouseoutDelay !== void 0 ? _mouseoutDelay : mouseoutDelay = 40;
      (_focusDelay = focusDelay) !== null && _focusDelay !== void 0 ? _focusDelay : focusDelay = 1; // The escape key should close tooltips, but do nothing else.
      // (i.e. closing a tooltip in a dialog MUST NOT close the dialog too)
      // TODO: Tooltips are, effectively, always the topmost component,
      // so we can just have them listen to and swallow all "Escape"
      // key presses before anyone else. For a more general popup,
      // or a tooltip in a tooltip (!!) a different solution would be needed.

      useGlobalHandler(document, "keydown", e => {
        if (getOpen() && e.key === "Escape" && !e.defaultPrevented) {
          e.preventDefault();
          e.stopImmediatePropagation();
          setOpen(false);
          setTriggerHoverDelayCorrected(false);
          setTooltipHoverDelayCorrected(false);
          setTriggerFocusedDelayCorrected(false);
          setTooltipFocusedDelayCorrected(false);
        }
      }, {
        capture: true
      });
      const [open, setOpen, getOpen] = useState(false);
      const {
        useRandomIdSourceElement,
        //: useTooltipIdProps, 
        useRandomIdReferencerElement //: useTooltipIdReferencingProps 

      } = useRandomId({
        prefix: "aria-tooltip-",
        onAfterChildLayoutEffect: null,
        onChildrenMountChange: null
      });
      const [, setTriggerFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTriggerFocusedDelayCorrected(focused), focused ? focusDelay : 1);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTooltipFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTooltipFocusedDelayCorrected(focused), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTriggerHover] = usePassiveState(useStableCallback(hovering => {
        const delay = hovering ? mouseoverDelay : mouseoutDelay;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTriggerHoverDelayCorrected(hovering), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTooltipHover] = usePassiveState(useStableCallback(hovering => {
        const delay = hovering ? mouseoverDelay : mouseoutDelay;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTooltipHoverDelayCorrected(hovering), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [triggerFocusedDelayCorrected, setTriggerFocusedDelayCorrected] = useState(false);
      const [triggerHoverDelayCorrected, setTriggerHoverDelayCorrected] = useState(false);
      const [tooltipFocusedDelayCorrected, setTooltipFocusedDelayCorrected] = useState(false);
      const [tooltipHoverDelayCorrected, setTooltipHoverDelayCorrected] = useState(false);
      h(() => {
        setOpen(triggerFocusedDelayCorrected || triggerHoverDelayCorrected || tooltipFocusedDelayCorrected || tooltipHoverDelayCorrected);
      }, [triggerFocusedDelayCorrected || triggerHoverDelayCorrected || tooltipFocusedDelayCorrected || tooltipHoverDelayCorrected]);
      const useTooltipTrigger = T$1(function useTooltipTrigger() {
        useGlobalHandler(document, "pointermove", e => {
          var _getElement;

          const target = e.target;
          setTriggerHover(target == getElement() || !!((_getElement = getElement()) !== null && _getElement !== void 0 && _getElement.contains(target)));
        }, {
          capture: true
        });

        function onTouchEnd(e) {
          e.target.focus();
        }

        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({
          onFocusedInnerChanged: setTriggerFocused
        });

        function useTooltipTriggerProps(_ref2) {
          var _props$tabIndex;

          let { ...props
          } = _ref2;
          const {
            useRandomIdReferencerElementProps
          } = useRandomIdReferencerElement("aria-describedby"); // Note: Though it's important to make sure that focusing activates a tooltip,
          // it's perfectly reasonable that a child element will be the one that's focused,
          // not this one, so we don't set tabIndex=0

          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1;
          return useRandomIdReferencerElementProps(useHasFocusProps(useMergedProps({
            onTouchEnd
          }, props)));
        }

        return {
          useTooltipTriggerProps
        };
      }, []);
      const useTooltip = T$1(function useTooltip() {
        const {
          useRandomIdSourceElementProps
        } = useRandomIdSourceElement();
        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({
          onFocusedInnerChanged: setTooltipFocused
        });
        useGlobalHandler(document, "pointermove", e => {
          var _getElement2;

          const target = e.target;
          setTooltipHover(target == getElement() || !!((_getElement2 = getElement()) !== null && _getElement2 !== void 0 && _getElement2.contains(target)));
        }, {
          capture: true
        });

        function useTooltipProps(_ref3) {
          let { ...props
          } = _ref3;
          return useRandomIdSourceElementProps(useHasFocusProps(useMergedProps({}, props)));
        }

        return {
          useTooltipProps
        };
      }, []);
      return {
        useTooltip,
        useTooltipTrigger,
        isOpen: open,
        getIsOpen: getOpen
      };
    }

    const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    E(({ depth }) => {
        const [active, setActive] = useState(false);
        const { useFocusTrapProps } = useFocusTrap({ trapActive: active });
        const divProps = useFocusTrapProps({ ref: undefined, className: "focus-trap-demo" });
        if (depth == 2)
            return e$1("div", {});
        return (e$1("div", { className: "demo", children: [e$1("label", { children: ["Active: ", e$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] }), e$1("div", { ...divProps, children: e$1(DemoUseFocusTrapChild, { active: active, setActive: setActive, depth: depth ?? 0 }) })] }));
    });
    const DemoUseFocusTrapChild = E(({ setActive, active, depth }) => {
        return (e$1(p$1, { children: [e$1("button", { children: "Button 1" }), e$1("button", { children: "Button 2" }), e$1("button", { children: "Button 3" }), e$1("label", { children: ["Active: ", e$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] })] }));
    });
    const UseAccordionSectionContext = B(null);
    const DemoUseAccordion = E(() => {
        const { useAriaAccordionSection } = useAriaAccordion({ initialIndex: 0 });
        return (e$1(UseAccordionSectionContext.Provider, { value: useAriaAccordionSection, children: e$1("div", { className: "demo", children: e$1("div", { children: [e$1(DemoAccordionSection, { index: 0 }), e$1(DemoAccordionSection, { index: 1 }), e$1(DemoAccordionSection, { index: 2 })] }) }) }));
    });
    const DemoAccordionSection = E(({ index }) => {
        const useAccordionSection = q$1(UseAccordionSectionContext);
        const { expanded, useAriaAccordionSectionBodyProps, useAriaAccordionSectionHeaderProps } = useAccordionSection({ info: { index, flags: {} } });
        const p = useAriaAccordionSectionBodyProps({ className: "accordion-section-body", hidden: !expanded });
        p.id;
        return (e$1("div", { className: "accordion-section", children: [e$1("button", { ...useAriaAccordionSectionHeaderProps({ className: "accordion-section-header" }), children: ["Header #", index + 1] }), e$1("div", { ...p, children: [e$1("p", { children: ["Body content #", index + 1] }), e$1("p", { children: RandomWords.join(" ") })] })] }));
    });
    const DemoUseCheckbox = E(() => {
        return (e$1(p$1, { children: [e$1("div", { className: "demo", children: [e$1(Checkbox1, {}), e$1(Checkbox2, {})] }), e$1(DemoUseCheckboxGroup, {})] }));
    });
    const Checkbox1 = E(() => {
        const [checked, setChecked] = useState(false);
        const { useCheckboxInputElement, useCheckboxLabelElement } = useAriaCheckbox({ disabled: false, checked, labelPosition: "separate", onInput: e => setChecked(e[EventDetail].checked), inputTag: "input", labelTag: "label" });
        const { useCheckboxInputElementProps } = useCheckboxInputElement();
        const { useCheckboxLabelElementProps } = useCheckboxLabelElement();
        return (e$1("div", { children: [e$1("input", { ...useCheckboxInputElementProps({ type: "checkbox", }) }), e$1("label", { ...useCheckboxLabelElementProps({}), children: "Label" })] }));
    });
    const Checkbox2 = E(() => {
        const [checked, setChecked] = useState(false);
        const { useCheckboxLabelElement, useCheckboxInputElement } = useAriaCheckbox({ disabled: false, labelPosition: "wrapping", onInput: e => setChecked(e[EventDetail].checked), checked, inputTag: "input", labelTag: "label" });
        const { useCheckboxInputElementProps } = useCheckboxInputElement();
        const { useCheckboxLabelElementProps } = useCheckboxLabelElement();
        return (e$1("div", { children: e$1("label", { ...useCheckboxLabelElementProps({}), children: [e$1("input", { ...useCheckboxInputElementProps({ type: "checkbox" }) }), " Label"] }) }));
    });
    const CheckboxGroupContext = B(null);
    const DemoUseCheckboxGroup = E(() => {
        const { useHasFocusProps, getFocusedInner } = useHasFocus({});
        const { useCheckboxGroupChild, parentIsChecked: selfIsChecked, parentPercentChecked: percentChecked, checkboxes, currentTypeahead, invalidTypeahead, useCheckboxGroupParentInput } = useCheckboxGroup({ initialIndex: 0 });
        //const { useCheckboxInputElement, useCheckboxLabelElement } = useAriaCheckbox<HTMLInputElement, HTMLLabelElement>({ checked: selfIsChecked, disabled: false, labelPosition: "separate", onInput: onCheckboxGroupInput as any, inputTag: "input", labelTag: "label" });
        const { useCheckboxGroupParentInputProps, useCheckboxGroupParentLabelProps } = useCheckboxGroupParentInput({ inputTag: "input", labelTag: "label", disabled: false, labelPosition: "separate" });
        return e$1("div", { class: "demo", children: e$1(CheckboxGroupContext.Provider, { value: useCheckboxGroupChild, children: [e$1("div", { children: [e$1("input", { ...useCheckboxGroupParentInputProps({}) }), e$1("label", { ...useCheckboxGroupParentLabelProps({}), children: "All checked?" })] }), e$1("div", { ...useHasFocusProps({ style: { "display": "flex", "flexDirection": "column" } }), children: Array.from((function* () {
                            for (let i = 0; i < 10; ++i) {
                                yield e$1(DemoUseCheckboxGroupChild, { index: i }, i);
                            }
                        })()) })] }) });
    });
    const DemoUseCheckboxGroupChild = E(({ index }) => {
        const [checked, setChecked, getChecked] = useState(false);
        const useCheckboxGroupChild = q$1(CheckboxGroupContext);
        let text = `Number ${index + 1} checkbox ${checked ? "(checked)" : ""}`;
        const { tabbable, useCheckboxGroupChildInputProps, useCheckboxGroupChildLabelProps } = useCheckboxGroupChild({
            onInput: e => setChecked(e[EventDetail].checked),
            info: {
                index,
                text,
                flags: {},
            },
            checked,
            disabled: false,
            inputTag: "input",
            labelTag: "label",
            labelPosition: "separate"
        });
        text = `Number ${index + 1} checkbox ${checked ? "(checked)" : ""} ${tabbable ? "(tabbble)" : ""}`;
        //const { useCheckboxInputElement, useCheckboxLabelElement } = useAriaCheckbox<HTMLInputElement, HTMLLabelElement>({ checked, disabled: false, labelPosition: "separate", onInput: e => { setChecked(e[EventDetail].checked); }, inputTag: "input", labelTag: "label" });
        return (e$1("div", { children: [e$1("input", { ...useCheckboxGroupChildInputProps({}) }), e$1("label", { ...useCheckboxGroupChildLabelProps({}), children: text })] }));
    });
    const DemoUseDialog = E(() => {
        const onClose = (() => setOpen(false));
        const [open, setOpen] = useState(false);
        const { useDialogBackdrop, useDialogBody, useDialogProps, useDialogTitle } = useAriaDialog({ open, onClose: () => { onClose(); } });
        const { useDialogBackdropProps } = useDialogBackdrop();
        const { useDialogBodyProps } = useDialogBody({ descriptive: true });
        const { useDialogTitleProps } = useDialogTitle();
        return (e$1("div", { class: "demo", children: [e$1("label", { children: e$1("input", { type: "checkbox", checked: open, onInput: e => { e.preventDefault(); setOpen(e.currentTarget.checked); } }) }), e$1("div", { ...useDialogBackdropProps({ hidden: !open }), children: e$1("div", { ...useDialogProps({}), children: [e$1("div", { ...useDialogTitleProps({}), children: "Dialog Title" }), e$1("div", { ...useDialogBodyProps({}), children: [e$1("p", { tabIndex: -1, children: "Dialog body content" }), e$1("p", { children: RandomWords.join(" ") }), e$1("p", { children: RandomWords.join(" ") }), e$1("p", { children: RandomWords.join(" ") }), e$1("p", { children: e$1("button", { onClick: onClose, children: "Close" }) })] })] }) })] }));
    });
    const RadioWrapContext = B(false);
    const RadioContext = B(null);
    const DemoUseRadioGroup = E(() => {
        const [selectedIndex, setSelectedIndex] = useState(0);
        const [wrap, setWrap] = useState(q$1(RadioWrapContext));
        const { useRadio, useRadioGroupProps } = useAriaRadioGroup({
            name: "radio-demo-1",
            onInput: (e) => setSelectedIndex(+e[EventDetail].selectedValue),
            selectedValue: selectedIndex,
            groupLabelTag: "label",
            groupTag: "div",
        });
        return e$1("div", { class: "demo", children: [e$1("label", { children: [e$1("input", { type: "checkbox", checked: wrap, onInput: e => setWrap(w => !w) }), " Wrapper label"] }), e$1(RadioWrapContext.Provider, { value: wrap, children: e$1(RadioContext.Provider, { value: useRadio, children: e$1("div", { ...useRadioGroupProps({}), children: Array.from((function* () {
                                for (let i = 0; i < 10; ++i) {
                                    yield e$1(DemoRadio, { index: i }, i);
                                }
                            })()) }) }) }, wrap)] });
    });
    const DemoRadio = E(({ index }) => {
        const wrap = q$1(RadioWrapContext);
        const { useRadioInput, useRadioLabel, checked, tabbable } = q$1(RadioContext)({ info: { index, text: "", flags: {} }, value: index, disabled: false, labelPosition: wrap ? "wrapping" : "separate", inputTag: "input", labelTag: "label" });
        const { useRadioInputProps } = useRadioInput({ tag: "input" });
        const { useRadioLabelProps } = useRadioLabel({ tag: "label" });
        if (wrap)
            return e$1("label", { ...useRadioLabelProps({}), children: [e$1("input", { ...useRadioInputProps({}) }), "Number ", index + 1, " radio", checked ? " (checked)" : "", tabbable ? " (tabbable)" : ""] });
        else
            return e$1("div", { children: [e$1("input", { ...useRadioInputProps({}) }), "Number ", index + 1, " radio", checked ? " (checked)" : "", tabbable ? " (tabbable)" : "", e$1("label", { ...useRadioLabelProps({}) })] });
    });
    const ListBoxSingleItemContext = B(null);
    const DemoUseListboxSingle = E(() => {
        const [selectedIndex, setSelectedIndex] = useState(0);
        const { useListboxSingleItem, useListboxSingleLabel, useListboxSingleProps } = useAriaListboxSingle({
            selectedIndex,
            onSelect: e => setSelectedIndex(e[EventDetail].selectedIndex), selectionMode: "activate", labelTag: "label", listTag: "ul"
        });
        return e$1("div", { class: "demo", children: e$1(ListBoxSingleItemContext.Provider, { value: useListboxSingleItem, children: e$1("ul", { ...useListboxSingleProps({}), children: Array.from((function* () {
                        for (let i = 0; i < 10; ++i) {
                            yield e$1(DemoListboxSingleOption, { index: i }, i);
                        }
                    })()) }) }) });
    });
    const DemoListboxSingleOption = E(({ index }) => {
        const { getSelected, selected, tabbable, useListboxSingleItemProps } = q$1(ListBoxSingleItemContext)({ index, text: `Number ${index + 1} option`, flags: {} });
        return e$1("li", { ...useListboxSingleItemProps({}), children: ["Number ", index + 1, " option", selected ? " (selected)" : "", tabbable ? " (tabbable)" : ""] });
    });
    const ListBoxMultiItemContext = B(null);
    const DemoUseListboxMulti = E(() => {
        const { useListboxMultiItem, useListboxMultiLabel, useListboxMultiProps, currentTypeahead } = useAriaListboxMulti({ initialIndex: 0, labelTag: "label", listTag: "ul" });
        return e$1("div", { class: "demo", children: e$1(ListBoxMultiItemContext.Provider, { value: useListboxMultiItem, children: [e$1("ul", { ...useListboxMultiProps({}), children: Array.from((function* () {
                            for (let i = 0; i < 10; ++i) {
                                yield e$1(DemoListboxMultiOption, { index: i }, i);
                            }
                        })()) }), currentTypeahead != null && e$1("p", { children: currentTypeahead })] }) });
    });
    const MenuItemContext = B(null);
    const DemoListboxMultiOption = E(({ index }) => {
        const [selected, setSelected] = useState(false);
        let text = `Number ${index + 1} option${selected ? " (selected)" : ""}`;
        const { tabbable, useListboxMultiItemProps } = q$1(ListBoxMultiItemContext)({ tag: "li", index, text, onSelect: e => setSelected(e[EventDetail].selected), selected, flags: {} });
        text = `Number ${index + 1} option${selected ? " (selected)" : ""}${tabbable ? " (tabbable)" : ""}`;
        return e$1("li", { ...useListboxMultiItemProps({}), children: text });
    });
    const DemoMenu = E(() => {
        const [open, setOpen] = useState(false);
        const onClose = () => setOpen(false);
        const onOpen = () => setOpen(true);
        const { useHasFocusProps, getFocusedInner: getMenuFocusedInner } = useHasFocus({});
        const { useMenuButton, useMenuItem, useMenuProps } = useAriaMenu({ open, onClose, onOpen, initialIndex: 0 });
        const { useMenuButtonProps } = useMenuButton({ tag: "button" });
        return (e$1("div", { class: "demo", children: e$1(MenuItemContext.Provider, { value: useMenuItem, children: [e$1("button", { ...useMenuButtonProps({ onClick: e => setOpen(open => !open) }), children: "Open menu" }), e$1("ul", { ...useMenuProps(useHasFocusProps({})), hidden: !open, children: [e$1(DemoMenuItem, { index: 0 }), e$1(DemoMenuItem, { index: 1 }), e$1(DemoMenuItem, { index: 2 })] })] }) }));
    });
    const DemoMenuItem = E(({ index }) => {
        const useAriaMenuItem = q$1(MenuItemContext);
        const { useMenuItemProps } = useAriaMenuItem({ index, text: `Item ${index + 1}`, flags: {} });
        return e$1("li", { ...useMenuItemProps({}), children: ["Item ", index + 1] });
    });
    const TabContext = B(null);
    const TabPanelContext = B(null);
    const DemoTabs = E(() => {
        const [selectedIndex, setSelectedIndex] = useState(0);
        const [selectionMode, setSelectionMode] = useState("focus");
        const { useTab, useTabPanel, useTabsLabelProps, useTabsListProps } = useAriaTabs({
            onSelect: e => setSelectedIndex(e[EventDetail].selectedIndex),
            selectedIndex,
            selectionMode,
            orientation: "block",
            initialIndex: 0
        });
        return (e$1(TabContext.Provider, { value: useTab, children: e$1(TabPanelContext.Provider, { value: useTabPanel, children: e$1("div", { class: "demo", children: [e$1("label", { children: [e$1("input", { type: "checkbox", checked: selectionMode == "focus", onInput: (e) => { e.preventDefault(); setSelectionMode(e.currentTarget.checked ? "focus" : "activate"); } }), " Activate on focus?"] }), e$1("label", { ...useTabsLabelProps({}), children: "Tabs" }), e$1("ul", { ...useTabsListProps({}), children: [e$1(DemoTab, { index: 0 }), e$1(DemoTab, { index: 1 }), e$1(DemoTab, { index: 2 }), e$1(DemoTab, { index: 3 }), e$1(DemoTab, { index: 4 })] }), e$1("div", { children: [e$1(DemoTabPanel, { index: 0 }), e$1(DemoTabPanel, { index: 1 }), e$1(DemoTabPanel, { index: 2 }), e$1(DemoTabPanel, { index: 3 }), e$1(DemoTabPanel, { index: 4 })] })] }) }) }));
    });
    const DemoTab = E(({ index }) => {
        const useTabSet = q$1(TabContext);
        const { useTabProps, selected, getSelected, tabbable, getElement } = useTabSet({ index, text: "", flags: {} });
        return (e$1(p$1, { children: e$1("li", { ...useTabProps({}), children: ["Tab #", index + 1, " (", `Selected: ${selected}`, ")"] }) }));
    });
    const DemoTabPanel = E(({ index }) => {
        const useTabPanel = q$1(TabPanelContext);
        const { useTabPanelProps, visible } = useTabPanel({ index });
        return (e$1("div", { ...useTabPanelProps({ hidden: !visible }), children: [e$1("p", { children: ["Tab panel content #", index + 1, " (", `Selected: ${visible}`, ")."] }), e$1("p", { children: RandomWords.slice(0, Math.floor(RandomWords.length / (index + 1))).join(" ") })] }));
    });
    const DemoTooltip = E(() => {
        const { useTooltip, useTooltipTrigger, isOpen } = useAriaTooltip({});
        const { useTooltipProps } = useTooltip();
        const { useTooltipTriggerProps } = useTooltipTrigger();
        return (e$1("div", { class: "demo", children: e$1("p", { children: ["This is a paragraph with a ", e$1("span", { ...useTooltipTriggerProps({}), children: "tooltip right here." }), e$1("span", { ...useTooltipProps({ hidden: !isOpen }), children: "This is the tooltip content." })] }) }));
    });
    /*
    const DemoTable = memo(() => {

        const { useTableBody, useTableFoot, useTableHead, useTableProps, useTableRow } = useTable<
            HTMLTableElement, HTMLTableSectionElement, HTMLTableSectionElement, HTMLTableSectionElement, HTMLTableRowElement, HTMLTableCellElement, HTMLTableCellElement>({});

        const { useTableHeadProps } = useTableHead({});
        const { useTableBodyProps } = useTableBody({});

        const rows: VNode<any>[] = Array.from(function* () {
            for (let i = 0; i < 10; ++i) {
                yield <TableRow rowIndex={i + 1} />;
            }
        }());


        return (
            <TableRowContext.Provider value={useTableRow}>
                <table {...useTableProps({})}>
                    <thead {...useTableHeadProps({ children: [<TableHeaderRow rowIndex={0} />] })} />
                    <tbody {...useTableBodyProps({ children: rows })} />
                </table>
            </TableRowContext.Provider>
        )

    });

    const TableRowContext = createContext<UseTableRow<HTMLTableRowElement, HTMLTableCellElement, HTMLTableCellElement>>(null!);


    const TableRow = memo(function TableRow({ rowIndex }: { rowIndex: number }) {
        const i = rowIndex - 1;
        const useTableRow = useContext(TableRowContext);
        const { rowIndexAsSorted, rowIndexAsUnsorted, useTableCell, useTableRowProps } = useTableRow({ rowIndex, location: "body" });
        const date = new Date(new Date().getFullYear(), new Date().getMonth(), (i * 7) ** 2);

        const { useTableCellProps: useTableCellProps1, useTableCellDelegateProps: useTableCellDelegateProps1 } = useTableCell({ columnIndex: 0, value: i });
        const { useTableCellProps: useTableCellProps2, useTableCellDelegateProps: useTableCellDelegateProps2 } = useTableCell({ columnIndex: 1, value: RandomWords[i] });
        const { useTableCellProps: useTableCellProps3, useTableCellDelegateProps: useTableCellDelegateProps3 } = useTableCell({ columnIndex: 2, value: date });
        return (
            <tr {...useTableRowProps({ "data-index": rowIndex } as {})}>
                <td {...useTableCellProps1(useTableCellDelegateProps1({}))}>{i}</td>
                <td {...useTableCellProps2(useTableCellDelegateProps2({}))}>{RandomWords[i]}</td>
                <td {...useTableCellProps3(useTableCellDelegateProps3({}))}>{date.toLocaleDateString()}</td>
            </tr>
        )
    })


    const TableHeaderRow = memo(function TableHeaderRow({ rowIndex }: { rowIndex: number }) {
        const useTableRow = useContext(TableRowContext);
        const { useTableHeadCell, useTableRowProps: useTableHeadRowProps } = useTableRow({ rowIndex, location: "head" });
        const { useTableHeadCellProps: useTableHeadCellProps1, useTableHeadCellDelegateProps: useTableHeadCellDelegateProps1, sortDirection: sortDirection1 } = useTableHeadCell({ tag: "th", columnIndex: 0 });
        const { useTableHeadCellProps: useTableHeadCellProps2, useTableHeadCellDelegateProps: useTableHeadCellDelegateProps2, sortDirection: sortDirection2 } = useTableHeadCell({ tag: "th", columnIndex: 1 });
        const { useTableHeadCellProps: useTableHeadCellProps3, useTableHeadCellDelegateProps: useTableHeadCellDelegateProps3, sortDirection: sortDirection3 } = useTableHeadCell({ tag: "th", columnIndex: 2 });


        return (<tr {...useTableHeadRowProps({ "data-index": rowIndex } as {})}>
            <th {...useTableHeadCellProps1(useTableHeadCellDelegateProps1({}))}>Number {sortDirection1}</th>
            <th {...useTableHeadCellProps2(useTableHeadCellDelegateProps2({}))}>String {sortDirection2}</th>
            <th {...useTableHeadCellProps3(useTableHeadCellDelegateProps3({}))}>Date {sortDirection3}</th>
        </tr>)
    })*/
    const Component = () => {
        return e$1("div", { class: "flex", style: { flexWrap: "wrap" }, children: [e$1(DemoUseAccordion, {}), e$1(DemoUseListboxSingle, {}), e$1(DemoUseListboxMulti, {}), e$1(DemoTooltip, {}), e$1(DemoTabs, {}), e$1(DemoUseCheckbox, {}), e$1(DemoUseRadioGroup, {}), e$1(DemoUseDialog, {}), e$1(DemoMenu, {})] });
    };
    requestAnimationFrame(() => {
        z(e$1(Component, {}), document.getElementById("root"));
    });

})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jcmVhdGUtZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtcGFzc2l2ZS1zdGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1jaGlsZHJlbi50c3giLCIuLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbWVyZ2VkLWNsYXNzZXMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtcmVmcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1zdHlsZXMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtcHJvcHMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1yZWYtZWxlbWVudC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWFjdGl2ZS1lbGVtZW50LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1zdGFibGUtZ2V0dGVyLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Utc3RhYmxlLWNhbGxiYWNrLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtYW5pbWF0aW9uLWZyYW1lLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Utc3RhdGUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1lZmZlY3QudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1sYXlvdXQtZWZmZWN0LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtY2hpbGQtbWFuYWdlci50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWRvY3VtZW50LWNsYXNzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZXZlbnQtaGFuZGxlci50c3giLCIuLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvc3JjL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3dpY2ctaW5lcnQvZGlzdC9pbmVydC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ibG9ja2luZy1lbGVtZW50cy9zcmMvYmxvY2tpbmctZWxlbWVudHMudHMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWJsb2NraW5nLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1mb2N1cy10cmFwLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbG9naWNhbC1kaXJlY3Rpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS10aW1lb3V0LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXJvdmluZy10YWJpbmRleC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWxpc3QtbmF2aWdhdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXJhbmRvbS1pZC50c3giLCIuLi9zcmMvdXNlLWJ1dHRvbi50cyIsIi4uL3NyYy91c2UtYWNjb3JkaW9uLnRzeCIsIi4uL3NyYy91c2UtbGFiZWwudHMiLCIuLi9zcmMvdXNlLWNoZWNrYm94LnRzIiwiLi4vc3JjL3VzZS1jaGVja2JveC1ncm91cC50cyIsIi4uL3NyYy91c2UtbW9kYWwudHMiLCIuLi9zcmMvdXNlLWRpYWxvZy50cyIsIi4uL3NyYy91c2UtbGlzdGJveC1tdWx0aS50cyIsIi4uL3NyYy91c2UtbGlzdGJveC1zaW5nbGUudHMiLCIuLi9zcmMvdXNlLW1lbnUudHMiLCIuLi9zcmMvdXNlLXJhZGlvLWdyb3VwLnRzeCIsIi4uL3NyYy91c2UtdGFicy50cyIsIi4uL3NyYy91c2UtdG9vbHRpcC50cyIsImluZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuXG5sZXQgdm5vZGVJZCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlIGFuIHZpcnR1YWwgbm9kZSAodXNlZCBmb3IgSlNYKVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIGNvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJvcHNdIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuJykuQ29tcG9uZW50Q2hpbGRyZW4+fSBbY2hpbGRyZW5dIFRoZSBjaGlsZHJlbiBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge30sXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAna2V5Jykga2V5ID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBpZiAoaSA9PSAncmVmJykgcmVmID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jaGlsZHJlbiA9XG5cdFx0XHRhcmd1bWVudHMubGVuZ3RoID4gMyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGNoaWxkcmVuO1xuXHR9XG5cblx0Ly8gSWYgYSBDb21wb25lbnQgVk5vZGUsIGNoZWNrIGZvciBhbmQgYXBwbHkgZGVmYXVsdFByb3BzXG5cdC8vIE5vdGU6IHR5cGUgbWF5IGJlIHVuZGVmaW5lZCBpbiBkZXZlbG9wbWVudCwgbXVzdCBuZXZlciBlcnJvciBoZXJlLlxuXHRpZiAodHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLmRlZmF1bHRQcm9wcyAhPSBudWxsKSB7XG5cdFx0Zm9yIChpIGluIHR5cGUuZGVmYXVsdFByb3BzKSB7XG5cdFx0XHRpZiAobm9ybWFsaXplZFByb3BzW2ldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gdHlwZS5kZWZhdWx0UHJvcHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG5vcm1hbGl6ZWRQcm9wcywga2V5LCByZWYsIG51bGwpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFZOb2RlICh1c2VkIGludGVybmFsbHkgYnkgUHJlYWN0KVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIENvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBwcm9wcyBUaGUgcHJvcGVydGllcyBvZiB0aGlzIHZpcnR1YWwgbm9kZS5cbiAqIElmIHRoaXMgdmlydHVhbCBub2RlIHJlcHJlc2VudHMgYSB0ZXh0IG5vZGUsIHRoaXMgaXMgdGhlIHRleHQgb2YgdGhlIG5vZGUgKHN0cmluZyBvciBudW1iZXIpLlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBrZXkgVGhlIGtleSBmb3IgdGhpcyB2aXJ0dWFsIG5vZGUsIHVzZWQgd2hlblxuICogZGlmZmluZyBpdCBhZ2FpbnN0IGl0cyBjaGlsZHJlblxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInJlZlwiXX0gcmVmIFRoZSByZWYgcHJvcGVydHkgdGhhdCB3aWxsXG4gKiByZWNlaXZlIGEgcmVmZXJlbmNlIHRvIGl0cyBjcmVhdGVkIGNoaWxkXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywga2V5LCByZWYsIG9yaWdpbmFsKSB7XG5cdC8vIFY4IHNlZW1zIHRvIGJlIGJldHRlciBhdCBkZXRlY3RpbmcgdHlwZSBzaGFwZXMgaWYgdGhlIG9iamVjdCBpcyBhbGxvY2F0ZWQgZnJvbSB0aGUgc2FtZSBjYWxsIHNpdGVcblx0Ly8gRG8gbm90IGlubGluZSBpbnRvIGNyZWF0ZUVsZW1lbnQgYW5kIGNvZXJjZVRvVk5vZGUhXG5cdGNvbnN0IHZub2RlID0ge1xuXHRcdHR5cGUsXG5cdFx0cHJvcHMsXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRfY2hpbGRyZW46IG51bGwsXG5cdFx0X3BhcmVudDogbnVsbCxcblx0XHRfZGVwdGg6IDAsXG5cdFx0X2RvbTogbnVsbCxcblx0XHQvLyBfbmV4dERvbSBtdXN0IGJlIGluaXRpYWxpemVkIHRvIHVuZGVmaW5lZCBiL2MgaXQgd2lsbCBldmVudHVhbGx5XG5cdFx0Ly8gYmUgc2V0IHRvIGRvbS5uZXh0U2libGluZyB3aGljaCBjYW4gcmV0dXJuIGBudWxsYCBhbmQgaXQgaXMgaW1wb3J0YW50XG5cdFx0Ly8gdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuIHVuaW5pdGlhbGl6ZWQgX25leHREb20gYW5kXG5cdFx0Ly8gYSBfbmV4dERvbSB0aGF0IGhhcyBiZWVuIHNldCB0byBgbnVsbGBcblx0XHRfbmV4dERvbTogdW5kZWZpbmVkLFxuXHRcdF9jb21wb25lbnQ6IG51bGwsXG5cdFx0X2h5ZHJhdGluZzogbnVsbCxcblx0XHRjb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuXHRcdF9vcmlnaW5hbDogb3JpZ2luYWwgPT0gbnVsbCA/ICsrdm5vZGVJZCA6IG9yaWdpbmFsXG5cdH07XG5cblx0Ly8gT25seSBpbnZva2UgdGhlIHZub2RlIGhvb2sgaWYgdGhpcyB3YXMgKm5vdCogYSBkaXJlY3QgY29weTpcblx0aWYgKG9yaWdpbmFsID09IG51bGwgJiYgb3B0aW9ucy52bm9kZSAhPSBudWxsKSBvcHRpb25zLnZub2RlKHZub2RlKTtcblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG5cdHJldHVybiB7IGN1cnJlbnQ6IG51bGwgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEZyYWdtZW50KHByb3BzKSB7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIFByZWFjdCBWTm9kZS5cbiAqIEBwYXJhbSB7Kn0gdm5vZGVcbiAqIEByZXR1cm5zIHt2bm9kZSBpcyBpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRFbGVtZW50ID0gdm5vZGUgPT5cblx0dm5vZGUgIT0gbnVsbCAmJiB2bm9kZS5jb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkO1xuIiwiaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGRpZmYsIGNvbW1pdFJvb3QgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5cbi8qKlxuICogQmFzZSBDb21wb25lbnQgY2xhc3MuIFByb3ZpZGVzIGBzZXRTdGF0ZSgpYCBhbmQgYGZvcmNlVXBkYXRlKClgLCB3aGljaFxuICogdHJpZ2dlciByZW5kZXJpbmdcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBUaGUgaW5pdGlhbCBjb21wb25lbnQgcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IFRoZSBpbml0aWFsIGNvbnRleHQgZnJvbSBwYXJlbnQgY29tcG9uZW50cydcbiAqIGdldENoaWxkQ29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KSB7XG5cdHRoaXMucHJvcHMgPSBwcm9wcztcblx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuLyoqXG4gKiBVcGRhdGUgY29tcG9uZW50IHN0YXRlIGFuZCBzY2hlZHVsZSBhIHJlLXJlbmRlci5cbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0ge29iamVjdCB8ICgoczogb2JqZWN0LCBwOiBvYmplY3QpID0+IG9iamVjdCl9IHVwZGF0ZSBBIGhhc2ggb2Ygc3RhdGVcbiAqIHByb3BlcnRpZXMgdG8gdXBkYXRlIHdpdGggbmV3IHZhbHVlcyBvciBhIGZ1bmN0aW9uIHRoYXQgZ2l2ZW4gdGhlIGN1cnJlbnRcbiAqIHN0YXRlIGFuZCBwcm9wcyByZXR1cm5zIGEgbmV3IHBhcnRpYWwgc3RhdGVcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIGNvbXBvbmVudCBzdGF0ZSBpc1xuICogdXBkYXRlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24odXBkYXRlLCBjYWxsYmFjaykge1xuXHQvLyBvbmx5IGNsb25lIHN0YXRlIHdoZW4gY29weWluZyB0byBuZXh0U3RhdGUgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBzO1xuXHRpZiAodGhpcy5fbmV4dFN0YXRlICE9IG51bGwgJiYgdGhpcy5fbmV4dFN0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZTtcblx0fSBlbHNlIHtcblx0XHRzID0gdGhpcy5fbmV4dFN0YXRlID0gYXNzaWduKHt9LCB0aGlzLnN0YXRlKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgdXBkYXRlID09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBTb21lIGxpYnJhcmllcyBsaWtlIGBpbW1lcmAgbWFyayB0aGUgY3VycmVudCBzdGF0ZSBhcyByZWFkb25seSxcblx0XHQvLyBwcmV2ZW50aW5nIHVzIGZyb20gbXV0YXRpbmcgaXQsIHNvIHdlIG5lZWQgdG8gY2xvbmUgaXQuIFNlZSAjMjcxNlxuXHRcdHVwZGF0ZSA9IHVwZGF0ZShhc3NpZ24oe30sIHMpLCB0aGlzLnByb3BzKTtcblx0fVxuXG5cdGlmICh1cGRhdGUpIHtcblx0XHRhc3NpZ24ocywgdXBkYXRlKTtcblx0fVxuXG5cdC8vIFNraXAgdXBkYXRlIGlmIHVwZGF0ZXIgZnVuY3Rpb24gcmV0dXJuZWQgbnVsbFxuXHRpZiAodXBkYXRlID09IG51bGwpIHJldHVybjtcblxuXHRpZiAodGhpcy5fdm5vZGUpIHtcblx0XHRpZiAoY2FsbGJhY2spIHRoaXMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9XG59O1xuXG4vKipcbiAqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudFxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciBjb21wb25lbnQgaXNcbiAqIHJlLXJlbmRlcmVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRpZiAodGhpcy5fdm5vZGUpIHtcblx0XHQvLyBTZXQgcmVuZGVyIG1vZGUgc28gdGhhdCB3ZSBjYW4gZGlmZmVyZW50aWF0ZSB3aGVyZSB0aGUgcmVuZGVyIHJlcXVlc3Rcblx0XHQvLyBpcyBjb21pbmcgZnJvbS4gV2UgbmVlZCB0aGlzIGJlY2F1c2UgZm9yY2VVcGRhdGUgc2hvdWxkIG5ldmVyIGNhbGxcblx0XHQvLyBzaG91bGRDb21wb25lbnRVcGRhdGVcblx0XHR0aGlzLl9mb3JjZSA9IHRydWU7XG5cdFx0aWYgKGNhbGxiYWNrKSB0aGlzLl9yZW5kZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBBY2NlcHRzIGBwcm9wc2AgYW5kIGBzdGF0ZWAsIGFuZCByZXR1cm5zIGEgbmV3IFZpcnR1YWwgRE9NIHRyZWUgdG8gYnVpbGQuXG4gKiBWaXJ0dWFsIERPTSBpcyBnZW5lcmFsbHkgY29uc3RydWN0ZWQgdmlhIFtKU1hdKGh0dHA6Ly9qYXNvbmZvcm1hdC5jb20vd3RmLWlzLWpzeCkuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgUHJvcHMgKGVnOiBKU1ggYXR0cmlidXRlcykgcmVjZWl2ZWQgZnJvbSBwYXJlbnRcbiAqIGVsZW1lbnQvY29tcG9uZW50XG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgVGhlIGNvbXBvbmVudCdzIGN1cnJlbnQgc3RhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IENvbnRleHQgb2JqZWN0LCBhcyByZXR1cm5lZCBieSB0aGUgbmVhcmVzdFxuICogYW5jZXN0b3IncyBgZ2V0Q2hpbGRDb250ZXh0KClgXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW4gfCB2b2lkfVxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IEZyYWdtZW50O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcGFyYW0ge251bWJlciB8IG51bGx9IFtjaGlsZEluZGV4XVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9tU2libGluZyh2bm9kZSwgY2hpbGRJbmRleCkge1xuXHRpZiAoY2hpbGRJbmRleCA9PSBudWxsKSB7XG5cdFx0Ly8gVXNlIGNoaWxkSW5kZXg9PW51bGwgYXMgYSBzaWduYWwgdG8gcmVzdW1lIHRoZSBzZWFyY2ggZnJvbSB0aGUgdm5vZGUncyBzaWJsaW5nXG5cdFx0cmV0dXJuIHZub2RlLl9wYXJlbnRcblx0XHRcdD8gZ2V0RG9tU2libGluZyh2bm9kZS5fcGFyZW50LCB2bm9kZS5fcGFyZW50Ll9jaGlsZHJlbi5pbmRleE9mKHZub2RlKSArIDEpXG5cdFx0XHQ6IG51bGw7XG5cdH1cblxuXHRsZXQgc2libGluZztcblx0Zm9yICg7IGNoaWxkSW5kZXggPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBjaGlsZEluZGV4KyspIHtcblx0XHRzaWJsaW5nID0gdm5vZGUuX2NoaWxkcmVuW2NoaWxkSW5kZXhdO1xuXG5cdFx0aWYgKHNpYmxpbmcgIT0gbnVsbCAmJiBzaWJsaW5nLl9kb20gIT0gbnVsbCkge1xuXHRcdFx0Ly8gU2luY2UgdXBkYXRlUGFyZW50RG9tUG9pbnRlcnMga2VlcHMgX2RvbSBwb2ludGVyIGNvcnJlY3QsXG5cdFx0XHQvLyB3ZSBjYW4gcmVseSBvbiBfZG9tIHRvIHRlbGwgdXMgaWYgdGhpcyBzdWJ0cmVlIGNvbnRhaW5zIGFcblx0XHRcdC8vIHJlbmRlcmVkIERPTSBub2RlLCBhbmQgd2hhdCB0aGUgZmlyc3QgcmVuZGVyZWQgRE9NIG5vZGUgaXNcblx0XHRcdHJldHVybiBzaWJsaW5nLl9kb207XG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgd2UgZ2V0IGhlcmUsIHdlIGhhdmUgbm90IGZvdW5kIGEgRE9NIG5vZGUgaW4gdGhpcyB2bm9kZSdzIGNoaWxkcmVuLlxuXHQvLyBXZSBtdXN0IHJlc3VtZSBmcm9tIHRoaXMgdm5vZGUncyBzaWJsaW5nIChpbiBpdCdzIHBhcmVudCBfY2hpbGRyZW4gYXJyYXkpXG5cdC8vIE9ubHkgY2xpbWIgdXAgYW5kIHNlYXJjaCB0aGUgcGFyZW50IGlmIHdlIGFyZW4ndCBzZWFyY2hpbmcgdGhyb3VnaCBhIERPTVxuXHQvLyBWTm9kZSAobWVhbmluZyB3ZSByZWFjaGVkIHRoZSBET00gcGFyZW50IG9mIHRoZSBvcmlnaW5hbCB2bm9kZSB0aGF0IGJlZ2FuXG5cdC8vIHRoZSBzZWFyY2gpXG5cdHJldHVybiB0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBudWxsO1xufVxuXG4vKipcbiAqIFRyaWdnZXIgaW4tcGxhY2UgcmUtcmVuZGVyaW5nIG9mIGEgY29tcG9uZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIHJlcmVuZGVyXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudChjb21wb25lbnQpIHtcblx0bGV0IHZub2RlID0gY29tcG9uZW50Ll92bm9kZSxcblx0XHRvbGREb20gPSB2bm9kZS5fZG9tLFxuXHRcdHBhcmVudERvbSA9IGNvbXBvbmVudC5fcGFyZW50RG9tO1xuXG5cdGlmIChwYXJlbnREb20pIHtcblx0XHRsZXQgY29tbWl0UXVldWUgPSBbXTtcblx0XHRjb25zdCBvbGRWTm9kZSA9IGFzc2lnbih7fSwgdm5vZGUpO1xuXHRcdG9sZFZOb2RlLl9vcmlnaW5hbCA9IHZub2RlLl9vcmlnaW5hbCArIDE7XG5cblx0XHRkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0dm5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGNvbXBvbmVudC5fZ2xvYmFsQ29udGV4dCxcblx0XHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHRcdHZub2RlLl9oeWRyYXRpbmcgIT0gbnVsbCA/IFtvbGREb21dIDogbnVsbCxcblx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0b2xkRG9tID09IG51bGwgPyBnZXREb21TaWJsaW5nKHZub2RlKSA6IG9sZERvbSxcblx0XHRcdHZub2RlLl9oeWRyYXRpbmdcblx0XHQpO1xuXHRcdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcblxuXHRcdGlmICh2bm9kZS5fZG9tICE9IG9sZERvbSkge1xuXHRcdFx0dXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKSB7XG5cdGlmICgodm5vZGUgPSB2bm9kZS5fcGFyZW50KSAhPSBudWxsICYmIHZub2RlLl9jb21wb25lbnQgIT0gbnVsbCkge1xuXHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBudWxsO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgY2hpbGQgPSB2bm9kZS5fY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5fZG9tICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuX2RvbSA9IHZub2RlLl9jb21wb25lbnQuYmFzZSA9IGNoaWxkLl9kb207XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgcmVuZGVyIHF1ZXVlXG4gKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn1cbiAqL1xubGV0IHJlcmVuZGVyUXVldWUgPSBbXTtcblxuLypcbiAqIFRoZSB2YWx1ZSBvZiBgQ29tcG9uZW50LmRlYm91bmNlYCBtdXN0IGFzeW5jaHJvbm91c2x5IGludm9rZSB0aGUgcGFzc2VkIGluIGNhbGxiYWNrLiBJdCBpc1xuICogaW1wb3J0YW50IHRoYXQgY29udHJpYnV0b3JzIHRvIFByZWFjdCBjYW4gY29uc2lzdGVudGx5IHJlYXNvbiBhYm91dCB3aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAsIGV0Yy5cbiAqIGRvLCBhbmQgd2hlbiB0aGVpciBlZmZlY3RzIHdpbGwgYmUgYXBwbGllZC4gU2VlIHRoZSBsaW5rcyBiZWxvdyBmb3Igc29tZSBmdXJ0aGVyIHJlYWRpbmcgb24gZGVzaWduaW5nXG4gKiBhc3luY2hyb25vdXMgQVBJcy5cbiAqICogW0Rlc2lnbmluZyBBUElzIGZvciBBc3luY2hyb255XShodHRwczovL2Jsb2cuaXpzLm1lLzIwMTMvMDgvZGVzaWduaW5nLWFwaXMtZm9yLWFzeW5jaHJvbnkpXG4gKiAqIFtDYWxsYmFja3Mgc3luY2hyb25vdXMgYW5kIGFzeW5jaHJvbm91c10oaHR0cHM6Ly9ibG9nLm9tZXRlci5jb20vMjAxMS8wNy8yNC9jYWxsYmFja3Mtc3luY2hyb25vdXMtYW5kLWFzeW5jaHJvbm91cy8pXG4gKi9cblxubGV0IHByZXZEZWJvdW5jZTtcblxuLyoqXG4gKiBFbnF1ZXVlIGEgcmVyZW5kZXIgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjIFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoYykge1xuXHRpZiAoXG5cdFx0KCFjLl9kaXJ0eSAmJlxuXHRcdFx0KGMuX2RpcnR5ID0gdHJ1ZSkgJiZcblx0XHRcdHJlcmVuZGVyUXVldWUucHVzaChjKSAmJlxuXHRcdFx0IXByb2Nlc3MuX3JlcmVuZGVyQ291bnQrKykgfHxcblx0XHRwcmV2RGVib3VuY2UgIT09IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdcblx0KSB7XG5cdFx0cHJldkRlYm91bmNlID0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZztcblx0XHQocHJldkRlYm91bmNlIHx8IHNldFRpbWVvdXQpKHByb2Nlc3MpO1xuXHR9XG59XG5cbi8qKiBGbHVzaCB0aGUgcmVuZGVyIHF1ZXVlIGJ5IHJlcmVuZGVyaW5nIGFsbCBxdWV1ZWQgY29tcG9uZW50cyAqL1xuZnVuY3Rpb24gcHJvY2VzcygpIHtcblx0bGV0IHF1ZXVlO1xuXHR3aGlsZSAoKHByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSByZXJlbmRlclF1ZXVlLmxlbmd0aCkpIHtcblx0XHRxdWV1ZSA9IHJlcmVuZGVyUXVldWUuc29ydCgoYSwgYikgPT4gYS5fdm5vZGUuX2RlcHRoIC0gYi5fdm5vZGUuX2RlcHRoKTtcblx0XHRyZXJlbmRlclF1ZXVlID0gW107XG5cdFx0Ly8gRG9uJ3QgdXBkYXRlIGByZW5kZXJDb3VudGAgeWV0LiBLZWVwIGl0cyB2YWx1ZSBub24temVybyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5XG5cdFx0Ly8gcHJvY2VzcygpIGNhbGxzIGZyb20gZ2V0dGluZyBzY2hlZHVsZWQgd2hpbGUgYHF1ZXVlYCBpcyBzdGlsbCBiZWluZyBjb25zdW1lZC5cblx0XHRxdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0aWYgKGMuX2RpcnR5KSByZW5kZXJDb21wb25lbnQoYyk7XG5cdFx0fSk7XG5cdH1cbn1cbnByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSAwO1xuIiwiZXhwb3J0IGNvbnN0IEVNUFRZX09CSiA9IHt9O1xuZXhwb3J0IGNvbnN0IEVNUFRZX0FSUiA9IFtdO1xuZXhwb3J0IGNvbnN0IElTX05PTl9ESU1FTlNJT05BTCA9IC9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkfGl0ZXJhL2k7XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWR1Y2VyLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cblxuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTPiA9ICh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQ+ID0gKCh2YWx1ZTogVCwgcHJldlZhbHVlOiBUIHwgdW5kZWZpbmVkKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpO1xuXG4vKipcbiAqIERlYnVnIGhvb2suXG4gKiBcbiAqIEdpdmVuIGEgdmFsdWUgb3Igc2V0IG9mIHZhbHVlcywgZW1pdHMgYSBjb25zb2xlIGVycm9yIGlmIGFueSBvZiB0aGVtIGNoYW5nZSBmcm9tIG9uZSByZW5kZXIgdG8gdGhlIG5leHQuXG4gKiBcbiAqIEV2ZW50dWFsbHksIHdoZW4gdXNlRXZlbnQgbGFuZHMsIHdlIGhvcGVmdWxseSB3b24ndCBuZWVkIHRoaXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFbnN1cmVTdGFiaWxpdHk8VCBleHRlbmRzIGFueVtdPihwYXJlbnRIb29rTmFtZTogc3RyaW5nLCAuLi52YWx1ZXM6IFQpIHtcbiAgICB1c2VIZWxwZXIodmFsdWVzLmxlbmd0aCwgMCk7XG4gICAgdmFsdWVzLmZvckVhY2godXNlSGVscGVyKTtcbiAgICByZXR1cm47XG5cblxuICAgIGZ1bmN0aW9uIHVzZUhlbHBlcjxVPih2YWx1ZTogVSwgaW5kZXg6IG51bWJlcikge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICAgICAgY29uc3QgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkgPSB1c2VSZWYodmFsdWUpO1xuICAgICAgICBjb25zdCBzaG93bkVycm9yID0gdXNlUmVmKGZhbHNlKTtcbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnQgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghc2hvd25FcnJvci5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBUaGUgaG9vayAke3BhcmVudEhvb2tOYW1lfSByZXF1aXJlcyBzb21lIG9yIGFsbCBvZiBpdHMgYXJndW1lbnRzIHJlbWFpbiBzdGFibGUgYWNyb3NzIGVhY2ggcmVuZGVyOyBwbGVhc2UgY2hlY2sgdGhlICR7aW5kZXh9LWluZGV4ZWQgYXJndW1lbnQuYCk7XG4gICAgICAgICAgICAgICAgc2hvd25FcnJvci5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5mdW5jdGlvbiB1c2VQYXNzaXZlU3RhdGUyPFQ+KG9uQ2hhbmdlOiB1bmRlZmluZWQgfCBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VD4sIGdldEluaXRpYWw6ICgpID0+IFQpOiBbKCkgPT4gVCwgUGFzc2l2ZVN0YXRlVXBkYXRlcjxUPl0ge1xuICAgIHR5cGUgU3RhdGVUeXBlID0geyB2YWx1ZTogVCB8IHR5cGVvZiBVbnNldCB9XG5cbiAgICBjb25zdCB3YXJuaW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2tSZWYgPSB1c2VSZWY8dm9pZCB8IHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKT4odW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IFtzdG9yZWQsIHNldFN0b3JlZF0gPSB1c2VSZWR1Y2VyPFN0YXRlVHlwZSwgVD4oKHByZXYsIGFjdGlvbikgPT4ge1xuICAgICAgICBpZiAocHJldi52YWx1ZSAhPT0gYWN0aW9uKSB7XG4gICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50KCk7XG5cbiAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gb25DaGFuZ2U/LihhY3Rpb24sIHByZXYudmFsdWUgPT09IFVuc2V0ID8gZ2V0SW5pdGlhbCgpIDogcHJldi52YWx1ZSk7XG4gICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2LnZhbHVlID0gYWN0aW9uO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9LCB7IHZhbHVlOiBVbnNldCB9KTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gdXNlQ2FsbGJhY2soKCk6IFQgPT4ge1xuICAgICAgICBpZiAod2FybmluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVyaW5nIG9uQ2hhbmdlLCBwcmVmZXIgdXNpbmcgdGhlICh2YWx1ZSwgcHJldlZhbHVlKSBhcmd1bWVudHMgaW5zdGVhZCBvZiBnZXRWYWx1ZSAtLSBpdCdzIGFtYmlndW91cyBhcyB0byBpZiB5b3UncmUgYXNraW5nIGZvciB0aGUgb2xkIG9yIG5ldyB2YWx1ZSBhdCB0aGlzIHBvaW50IGluIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50LlwiKTtcblxuICAgICAgICByZXR1cm4gc3RvcmVkLnZhbHVlID09PSBVbnNldCA/IGdldEluaXRpYWwoKSA6IHN0b3JlZC52YWx1ZTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBzZXRTdGF0ZSA9IHVzZUNhbGxiYWNrPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD4+KChuZXh0VmFsdWVHZXR0ZXIpID0+IHtcbiAgICAgICAgbGV0IG5leHRWYWx1ZTogVDtcbiAgICAgICAgaWYgKG5leHRWYWx1ZUdldHRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgbmV4dFZhbHVlR2V0dGVyKGdldFN0YXRlKCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXh0VmFsdWUgPSBuZXh0VmFsdWVHZXR0ZXI7XG5cbiAgICAgICAgc2V0U3RvcmVkKG5leHRWYWx1ZSEpO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtnZXRTdGF0ZSwgc2V0U3RhdGVdO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYHVzZVN0YXRlYCwgYnV0IGZvciB2YWx1ZXMgdGhhdCBhcmVuJ3QgXCJyZW5kZXItaW1wb3J0YW50XCIgJm5kYXNoOyB1cGRhdGVzIGRvbid0IGNhdXNlIGEgcmUtcmVuZGVyIGFuZCBzbyB0aGUgdmFsdWUgc2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHJlbmRlciAodGhvdWdoIGl0IGNlcnRhaW5seSBjYW4sIGF0IGxlYXN0IGJ5IHJlLXJlbmRlcmluZyBhZ2FpbikuXG4gKiBcbiAqIFRvIGNvbXBlbnNhdGUgZm9yIHRoaXMsIHlvdSBzaG91bGQgcGFzcyBhIGB1c2VFZmZlY3RgLWVzcXVlIGNhbGxiYWNrIHRoYXQgaXMgcnVuIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSnVzdCBsaWtlIGB1c2VFZmZlY3RgLCB0aGlzIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQncyBydW4gYmVmb3JlIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgKG9yLCBzYXksIHdoZW4gdGhlIHZhbHVlIG1lZXRzIHNvbWUgY3JpdGVyaWEpLCB0aGlzIGlzIHdoZXJlIHlvdSdsbCB3YW50IHRvIHB1dCBpbiBhIGNhbGwgdG8gYSBgc2V0U3RhdGVgIGZ1bmN0aW9uLlxuICogXG4gKiBUbyBzdW1tYXJpemUsIGl0J3MgbGlrZSBhIGB1c2VTdGF0ZWAtYHVzZUVmZmVjdGAgbWFzaHVwOlxuICogXG4gKiAxLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHRoaXMgdmVyc2lvbiBvZiBgc2V0U3RhdGVgIGRvZXNuJ3QgcmUtcmVuZGVyIHRoZSB3aG9sZSBjb21wb25lbnRcbiAqIDIuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgeW91IGNhbiBydW4gYSBmdW5jdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIHRoYXQgb3B0aW9uYWxseSByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvblxuICogMy4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgeW91IHRyaWdnZXIgdGhlIGVmZmVjdCBmdW5jdGlvbiBcInJlbW90ZWx5XCIgaW5zdGVhZCBvZiBpdCBydW5uaW5nIGFmdGVyIHJlbmRlcmluZ1xuICogNC4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgdGhlIHNpbmdsZSBcImRlcGVuZGVuY3lcIiBpcyBiYXNlZCBvbiB5b3VyIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAqIFxuICogTm90ZSB0aGF0IHdoaWxlIGNhbGxpbmcgYHNldFN0YXRlYCBkb2Vzbid0IGNhdXNlIGFueSByZS1yZW5kZXJzLCB5b3UgY2FuIGRvIHRoYXQgd2l0aGluIHlvdXIgYG9uQ2hhbmdlYCBmdW5jdGlvbiwgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzIHZpYSB0aGF0IGBzZXRTdGF0ZWAuXG4gKiBcbiAqIEBwYXJhbSBvbkNoYW5nZSBUaGUgXCJlZmZlY3RcIiBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYHVzZUVmZmVjdGAncyBcImVmZmVjdFwiIGZ1bmN0aW9uLiAgTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBnZXRJbml0aWFsVmFsdWUgSWYgcHJvdmlkZWQsIHRoZSBlZmZlY3Qgd2lsbCBiZSBpbnZva2VkIG9uY2Ugd2l0aCB0aGlzIHZhbHVlIG9uIG1vdW50LiBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXNzaXZlU3RhdGU8VD4ob25DaGFuZ2U6IHVuZGVmaW5lZCB8IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUPiwgZ2V0SW5pdGlhbFZhbHVlPzogKCkgPT4gVCk6IHJlYWRvbmx5IFsoKSA9PiBULCBQYXNzaXZlU3RhdGVVcGRhdGVyPFQ+XSB7XG5cbiAgICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZjxUIHwgdHlwZW9mIFVuc2V0PihVbnNldCk7XG4gICAgY29uc3Qgd2FybmluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgY2xlYW51cENhbGxiYWNrUmVmID0gdXNlUmVmPHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKT4odW5kZWZpbmVkKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VQYXNzaXZlU3RhdGVcIiwgb25DaGFuZ2UsIGdldEluaXRpYWxWYWx1ZSk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBcImRlcGVuZGVuY3kgY2hhbmdlZFwiIGFuZCBcImNvbXBvbmVudCB1bm1vdW50ZWRcIi5cbiAgICBjb25zdCBvblNob3VsZENsZWFuVXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXBDYWxsYmFjayA9IGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50O1xuICAgICAgICBpZiAoY2xlYW51cENhbGxiYWNrKVxuICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrKCk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlcmUgYXJlIGEgY291cGxlIHBsYWNlcyB3aGVyZSB3ZSdkIGxpa2UgdG8gdXNlIG91ciBpbml0aWFsXG4gICAgLy8gdmFsdWUgaW4gcGxhY2Ugb2YgaGF2aW5nIG5vIHZhbHVlIGF0IGFsbCB5ZXQuXG4gICAgLy8gVGhpcyBpcyB0aGUgc2hhcmVkIGNvZGUgZm9yIHRoYXQsIHVzZWQgb24gbW91bnQgYW5kIHdoZW5ldmVyXG4gICAgLy8gZ2V0VmFsdWUgaXMgY2FsbGVkLlxuICAgIGNvbnN0IHRyeUVuc3VyZVZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgJiYgZ2V0SW5pdGlhbFZhbHVlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsVmFsdWUgPSBnZXRJbml0aWFsVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4oaW5pdGlhbFZhbHVlLCB1bmRlZmluZWQpID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHRpb25zIGFyZSBpbnRlbnRpb25hbCB0byBhbGxvdyBiYWlsb3V0ICh3aXRob3V0IGV4cG9zaW5nIHRoZSBVbnNldCBzeW1ib2wpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbLyogZ2V0SW5pdGlhbFZhbHVlIGFuZCBvbkNoYW5nZSBpbnRlbnRpb25hbGx5IG9taXR0ZWQgKi9dKTtcblxuXG4gICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh3YXJuaW5nUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEdXJpbmcgb25DaGFuZ2UsIHByZWZlciB1c2luZyB0aGUgKHZhbHVlLCBwcmV2VmFsdWUpIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIGdldFZhbHVlIC0tIGl0J3MgYW1iaWd1b3VzIGFzIHRvIGlmIHlvdSdyZSBhc2tpbmcgZm9yIHRoZSBvbGQgb3IgbmV3IHZhbHVlIGF0IHRoaXMgcG9pbnQgaW4gdGltZSBmb3IgdGhpcyBjb21wb25lbnQuXCIpO1xuXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIGNhbGwgZ2V0VmFsdWUsIGlmIHdlIGhhdmVuJ3QgYmVlbiBnaXZlbiBhIHZhbHVlIHlldCxcbiAgICAgICAgLy8gKGFuZCB3ZSB3ZXJlIGdpdmVuIGFuIGluaXRpYWwgdmFsdWUgdG8gdXNlKVxuICAgICAgICAvLyByZXR1cm4gdGhlIGluaXRpYWwgdmFsdWUgaW5zdGVhZCBvZiBub3RoaW5nLlxuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQpXG4gICAgICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuXG4gICAgICAgIHJldHVybiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQhIDogdmFsdWVSZWYuY3VycmVudCEpIGFzIFQ7XG4gICAgfSwgW10pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3ZlIHJ1biBvdXIgZWZmZWN0IGF0IGxlYXN0IG9uY2Ugb24gbW91bnQuXG4gICAgICAgIC8vIChJZiB3ZSBoYXZlIGFuIGluaXRpYWwgdmFsdWUsIG9mIGNvdXJzZSlcbiAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcblxuXG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlIGFjdHVhbCBjb2RlIHRoZSB1c2VyIGNhbGxzIHRvIChwb3NzaWJseSkgcnVuIGEgbmV3IGVmZmVjdC5cbiAgICBjb25zdCByID0gdXNlUmVmKHsgbWljcm90YXNrUXVldWVkOiBmYWxzZSwgYXJnOiB1bmRlZmluZWQgYXMgdW5kZWZpbmVkIHwgUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPFQ+PlswXSwgcHJldkRlcDogdW5kZWZpbmVkIGFzIFQgfCB1bmRlZmluZWQgfSk7XG4gICAgY29uc3Qgc2V0VmFsdWUgPSB1c2VDYWxsYmFjazxQYXNzaXZlU3RhdGVVcGRhdGVyPFQ+PigoYXJnKSA9PiB7XG4gICAgICAgIHIuY3VycmVudC5wcmV2RGVwID0gdmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQgOiBnZXRWYWx1ZSgpO1xuICAgICAgICByLmN1cnJlbnQuYXJnID0gYXJnO1xuICAgICAgICBpZiAoIXIuY3VycmVudC5taWNyb3Rhc2tRdWV1ZWQpIHtcbiAgICAgICAgICAgIHIuY3VycmVudC5taWNyb3Rhc2tRdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgci5jdXJyZW50Lm1pY3JvdGFza1F1ZXVlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZEZXAgPSByLmN1cnJlbnQucHJldkRlcDtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSByLmN1cnJlbnQuYXJnITtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXAgPSBhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyhwcmV2RGVwISkgOiBhcmc7XG4gICAgICAgICAgICAgICAgaWYgKGRlcCAhPT0gdmFsdWVSZWYuY3VycmVudCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluZGljYXRlIHRvIHRoZSB1c2VyIHRoYXQgdGhleSBzaG91bGRuJ3QgY2FsbCBnZXRWYWx1ZSBkdXJpbmcgb25DaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGFueSByZWdpc3RlcmVkIGNsZWFudXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvdWxkQ2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/LihkZXAsIHByZXZEZXApID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gZGVwO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIG5vcm1hbGx5IGNhbGwgZ2V0VmFsdWUgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuXG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gW2dldFZhbHVlLCBzZXRWYWx1ZV0gYXMgY29uc3Q7XG59XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKCk7XG5cbi8vIEVhc3kgY29uc3RhbnRzIGZvciBnZXRJbml0aWFsVmFsdWVcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5UcnVlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5OdWxsKCkgeyByZXR1cm4gbnVsbDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblVuZGVmaW5lZCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblplcm8oKSB7IHJldHVybiAwOyB9IiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbih7IGNoaWxkcmVuOiBsaHMgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwiY2hpbGRyZW5cIj4sIHsgY2hpbGRyZW46IHJoc306IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcImNoaWxkcmVuXCI+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0ge1xuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCBsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwiaW1wb3J0IHsgZGVmYXVsdCBhcyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXHJcbiAqIER1cGxpY2F0ZSBjbGFzc2VzIGFyZSByZW1vdmVkIChvcmRlciBkb2Vzbid0IG1hdHRlciBhbnl3YXkpLlxyXG4gKiBcclxuICogQHBhcmFtIGxocyBDbGFzc2VzIG9mIHRoZSBmaXJzdCBjb21wb25lbnRcclxuICogQHBhcmFtIHJocyBDbGFzc2VzIG9mIHRoZSBzZWNvbmQgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgY29tYmluZWQgY2xhc3NlcyBmcm9tIGJvdGggYXJndW1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENsYXNzZXM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0Pih7IGNsYXNzOiBsaHNDbGFzcywgY2xhc3NOYW1lOiBsaHNDbGFzc05hbWUgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgXCJjbGFzc1wiIHwgXCJjbGFzc05hbWVcIj4sIHsgY2xhc3M6IHJoc0NsYXNzLCBjbGFzc05hbWU6IHJoc0NsYXNzTmFtZX06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHJcbiAgICAvLyBOb3RlOiBGb3IgdGhlIHNha2Ugb2YgZm9yd2FyZCBjb21wYXRpYmlsaXR5LCB0aGlzIGZ1bmN0aW9uIGlzIGxhYmVsbGVkIGFzXHJcbiAgICAvLyBhIGhvb2ssIGJ1dCBhcyBpdCB1c2VzIG5vIG90aGVyIGhvb2tzIGl0IHRlY2huaWNhbGx5IGlzbid0IG9uZS5cclxuXHJcbiAgICBpZiAobGhzQ2xhc3MgfHwgcmhzQ2xhc3MgfHwgbGhzQ2xhc3NOYW1lIHx8IHJoc0NsYXNzTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGxoc0NsYXNzZXMgPSBjbHN4KGxoc0NsYXNzLCBsaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgY29uc3QgYWxsQ2xhc3NlcyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20obGhzQ2xhc3NlcyksIC4uLkFycmF5LmZyb20ocmhzQ2xhc3NlcyldKVxyXG5cclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCwgUmVmLCBSZWZDYWxsYmFjaywgUmVmT2JqZWN0IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUmVmPFQ+KGluc3RhbmNlOiBUIHwgbnVsbCwgcmVmOiBSZWY8VD4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgKHJlZiBhcyBSZWZPYmplY3Q8VCB8IG51bGw+KS5jdXJyZW50ID0gaW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZhbHNlLCBcIlVua25vd24gcmVmIHR5cGUgZm91bmQgdGhhdCB3YXMgbmVpdGhlciBhIFJlZkNhbGxiYWNrIG5vciBhIFJlZk9iamVjdFwiKTtcclxuICAgIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFI8RT4ge1xyXG4gICAgcmVmPzogUmVmPEU+O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxyXG4gKiBAcGFyYW0gbGhzIFxyXG4gKiBAcGFyYW0gcmhzIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRSZWZzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyByZWY6IHJocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgeyByZWY6IGxocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikge1xyXG4gICAgY29uc3QgY29tYmluZWQ6IFJlZkNhbGxiYWNrPEU+ID0gdXNlQ2FsbGJhY2soKGN1cnJlbnQ6IEUgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCBsaHMpO1xyXG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcclxuICAgIH0sIFtsaHMsIHJoc10pO1xyXG5cclxuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQhO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmhzITtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxocyE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbmZ1bmN0aW9uIHN0eWxlU3RyaW5nVG9PYmplY3Qoc3R5bGU6IHN0cmluZyk6IGguSlNYLkNTU1Byb3BlcnRpZXMge1xyXG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhzdHlsZS5zcGxpdChcIjtcIikubWFwKHN0YXRlbWVudCA9PiBzdGF0ZW1lbnQuc3BsaXQoXCI6XCIpKSkgYXMgdW5rbm93biBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2VzIHR3byBzdHlsZSBvYmplY3RzLCByZXR1cm5pbmcgdGhlIHJlc3VsdC5cclxuICogXHJcbiAqIEBwYXJhbSBzdHlsZSBUaGUgdXNlci1naXZlbiBzdHlsZSBwcm9wIGZvciB0aGlzIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gb2JqIFRoZSBDU1MgcHJvcGVydGllcyB5b3Ugd2FudCBhZGRlZCB0byB0aGUgdXNlci1naXZlbiBzdHlsZVxyXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkU3R5bGVzKGxoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4sIHJoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSB7XHJcblxyXG4gICAgLy8gRWFzeSBjYXNlLCB3aGVuIHRoZXJlIGFyZSBubyBzdHlsZXMgdG8gbWVyZ2UgcmV0dXJuIG5vdGhpbmcuXHJcbiAgICBpZiAoIWxocz8uc3R5bGUgJiYgIXJocz8uc3R5bGUpXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XHJcbiAgICAgICAgLy8gRWFzeSBjYXNlcywgd2hlbiBvbmUgaXMgbnVsbCBhbmQgdGhlIG90aGVyIGlzbid0LlxyXG4gICAgICAgIGlmIChsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gbGhzLnN0eWxlO1xyXG4gICAgICAgIGlmICghbGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzLnN0eWxlO1xyXG5cclxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgdHlwZSB0byBhbiBvYmplY3QgYmFnIHR5cGUgYW5kIHJ1biBpdCBhZ2Fpbi5cclxuICAgICAgICBpZiAobGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKSB7XHJcbiAgICAgICAgICAgIC8vICh1c2VNZXJnZWRTdHlsZXMgaXNuJ3QgYSB0cnVlIGhvb2sgLS0gdGhpcyBpc24ndCBhIHZpb2xhdGlvbilcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKHsgc3R5bGU6IHN0eWxlU3RyaW5nVG9PYmplY3QobGhzPy5zdHlsZSBhcyBzdHJpbmcpIH0sIHJocykgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgeyBzdHlsZTogc3R5bGVTdHJpbmdUb09iamVjdChyaHM/LnN0eWxlIGFzIHN0cmluZykgfSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvZ2ljPz8/XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGV5J3JlIGJvdGggc3RyaW5ncywganVzdCBjb25jYXRlbmF0ZSB0aGVtLlxyXG4gICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gYCR7bGhzLnN0eWxlfTske3Jocz8uc3R5bGUgPz8gXCJcIn1gIGFzIHVua25vd24gYXMgc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZXkncmUgYm90aCBvYmplY3RzLCBqdXN0IG1lcmdlIHRoZW0uXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLihsaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgICAgIC4uLihyaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXHJcbiAgICB9IGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW5cIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2xhc3NlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2xhc3Nlc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1yZWZzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzXCI7XHJcblxyXG5sZXQgbG9nID0gY29uc29sZS53YXJuO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdQcm9wQ29uZmxpY3RzKGxvZzI6IHR5cGVvZiBjb25zb2xlW1wibG9nXCJdKSB7XHJcbiAgICBsb2cgPSBsb2cyXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAqIFxyXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxyXG4gKiBAcGFyYW0gbGhzMiBcclxuICogQHBhcmFtIHJoczIgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4obGhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgcmhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcclxuICAgIC8vIEZpcnN0LCBzZXBhcmF0ZSB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiBpbnRvIHR3byBncm91cHM6XHJcbiAgICAvLyBsaHNBbGwgYW5kIHJoc0FsbCBjb250YWluIGFsbCB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiwgYW5kXHJcbiAgICAvLyBsaHNNaXNjIGFuZCByaHNNaXNjIGNvbnRhaW4gYWxsIHByb3BzICpleGNlcHQqIGZvciB0aGUgZWFzeSBvbmVzXHJcbiAgICAvLyBsaWtlIGNsYXNzTmFtZSBhbmQgc3R5bGUgdGhhdCB3ZSBhbHJlYWR5IGtub3cgaG93IHRvIG1lcmdlLlxyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX2xoc0NoaWxkcmVuLCBjbGFzczogX2xoc0NsYXNzLCBjbGFzc05hbWU6IF9saHNDbGFzc05hbWUsIHN0eWxlOiBfbGhzU3R5bGUsIHJlZjogX2xoc1JlZiwgLi4ubGhzTWlzYyB9ID0gbGhzQWxsO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX3Joc0NoaWxkcmVuLCBjbGFzczogX3Joc0NsYXNzLCBjbGFzc05hbWU6IF9yaHNDbGFzc05hbWUsIHN0eWxlOiBfcmhzU3R5bGUsIHJlZjogX3Joc1JlZiwgLi4ucmhzTWlzYyB9ID0gcmhzQWxsO1xyXG5cclxuICAgIGNvbnN0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7XHJcbiAgICAgICAgLi4ubGhzTWlzYyxcclxuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIGNsYXNzTmFtZTogdXNlTWVyZ2VkQ2xhc3NlcyhsaHNBbGwsIHJoc0FsbCksXHJcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbCwgcmhzQWxsKSxcclxuICAgIH0gYXMgYW55O1xyXG5cclxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xyXG4gICAgaWYgKHJldC5zdHlsZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnN0eWxlO1xyXG4gICAgaWYgKHJldC5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jbGFzc05hbWU7XHJcbiAgICBpZiAocmV0LmNoaWxkcmVuID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2hpbGRyZW47XHJcblxyXG4gICAgLy8gTm93LCBkbyAqZXZlcnl0aGluZyogZWxzZVxyXG4gICAgLy8gTWVyZ2UgZXZlcnkgcmVtYWluaW5nIGV4aXN0aW5nIGVudHJ5IGluIGxocyB3aXRoIHdoYXQgd2UndmUgYWxyZWFkeSBwdXQgaW4gcmV0LlxyXG4gICAgLy9jb25zdCBsaHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMobGhzKSBhcyBba2V5b2YgVCwgVFtrZXlvZiBUXV1bXTtcclxuICAgIGNvbnN0IHJoc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhyaHNNaXNjKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtyaHNLZXlVLCByaHNWYWx1ZV0gb2YgcmhzRW50cmllcykge1xyXG4gICAgICAgIGNvbnN0IHJoc0tleSA9IHJoc0tleVUgYXMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcblxyXG4gICAgICAgIGNvbnN0IGxoc1ZhbHVlID0gbGhzTWlzY1tyaHNLZXkgYXMga2V5b2YgdHlwZW9mIGxoc01pc2NdO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGxoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgbWVyZ2VkIChvciBvbmUncyBhIGZ1bmN0aW9uIGFuZCB0aGUgb3RoZXIncyBudWxsKS5cclxuICAgICAgICAgICAgLy8gTm90IGFuICplYXN5KiBjYXNlLCBidXQgYSB3ZWxsLWRlZmluZWQgb25lLlxyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZUZ1bmN0aW9ucyhsaHNWYWx1ZSBhcyBuZXZlciwgcmhzVmFsdWUgYXMgbmV2ZXIpO1xyXG4gICAgICAgICAgICByZXRbcmhzS2V5IGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+XSA9IG1lcmdlZCBhcyBuZXZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XHJcbiAgICAgICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsICYmIHJoc1ZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IGxoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke3Joc0tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZSBhcyBuZXZlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUZ1bmN0aW9uczxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4obGhzOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBVIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG5cclxuICAgIGlmICghbGhzKVxyXG4gICAgICAgIHJldHVybiByaHM7XHJcbiAgICBpZiAoIXJocylcclxuICAgICAgICByZXR1cm4gbGhzO1xyXG5cclxuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHJ2ID0gcmhzKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qXHJcbmZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG5cclxuICAgIGNvbnN0IGlkMDogR2VuZXJpY0dldDx7fSwgXCJpZFwiLCBzdHJpbmc+ID0gXCJcIjtcclxuICAgIGNvbnN0IGlkMzogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ0OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDU6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNjogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgLy9jb25zdCBpZDI6IFppcFNpbmdsZTxzdHJpbmcgfCB1bmRlZmluZWQsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDE6IFppcE9iamVjdDx7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0geyBpZDogdW5kZWZpbmVkIH07XHJcblxyXG4gICAgdHlwZSBNMSA9IEdlbmVyaWNHZXQ8UCwgXCJzdHlsZVwiLCBzdHJpbmc+O1xyXG4gICAgdHlwZSBNMiA9IEdlbmVyaWNHZXQ8e30sIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIGNvbnN0IG0xOiBNMSA9IFwiXCI7XHJcbiAgICBjb25zdCBtMjogTTEgPSB1bmRlZmluZWQ7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xyXG4gICAgY29uc3QgbTM6IE0xID0gMDtcclxuXHJcbiAgICBjb25zdCBtNDogTTIgPSBcIlwiO1xyXG4gICAgY29uc3QgbTU6IE0yID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG02OiBNMiA9IDA7XHJcblxyXG4gICAgY29uc3QgcDE6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDI6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDM6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNDogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHt9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHt9KTtcclxuICAgIGNvbnN0IHA1ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywge30pO1xyXG4gICAgY29uc3QgcDYgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNyA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IFwic3RyaW5nXCIgfSk7XHJcblxyXG5cclxuICAgIHAxLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwMi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcDMuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHA0LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHA1LmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDcuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNy5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDUuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA3LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBpdCB3b3JrcyByZWN1cnNpdmVseVxyXG4gICAgY29uc3QgcjFhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDEpO1xyXG4gICAgY29uc3QgcjFiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDEpO1xyXG4gICAgY29uc3QgcjJhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDIpO1xyXG4gICAgY29uc3QgcjJiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDIpO1xyXG4gICAgY29uc3QgcjNhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDMpO1xyXG4gICAgY29uc3QgcjNiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDMpO1xyXG4gICAgY29uc3QgcjRhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDQpO1xyXG4gICAgY29uc3QgcjRiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDQpO1xyXG4gICAgY29uc3QgcjVhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDUpO1xyXG4gICAgY29uc3QgcjViID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDUpO1xyXG4gICAgY29uc3QgcjZhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDYpO1xyXG4gICAgY29uc3QgcjZiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDYpO1xyXG4gICAgY29uc3QgcjdhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDcpO1xyXG4gICAgY29uc3QgcjdiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDcpO1xyXG5cclxuXHJcbiAgICByMWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIxYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcjNhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByM2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHI0YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjRiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHI1YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjViLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI2Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByN2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNWEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjViLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI2YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmIuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjdhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3Yi5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjVhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjViLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG59XHJcbmZ1bmN0aW9uIGFjY2VwdHNOZXZlcihuOiBuZXZlcikge31cclxuKi8iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xyXG4gICAgZ2V0RWxlbWVudCgpOiBUIHwgbnVsbDtcclxuICAgIHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPiB7XHJcbiAgICBvbkVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbD47XHJcbiAgICBvbk1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XHJcbiAgICBvblVubW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBhY2Nlc3NpbmcgdGhlIGVsZW1lbnQgYSByZWYgcmVmZXJlbmNlcyBhcyBzb29uIGFzIGl0IGRvZXMgc28uXHJcbiAqICpUaGlzIGhvb2sgaXRzZWxmIHJldHVybnMgYSBob29rKi0tdXNlUmVmRWxlbWVudFByb3BzIG1vZGlmaWVzIHRoZSBwcm9wcyB0aGF0IHlvdSB3ZXJlIGdvaW5nIHRvIHBhc3MgdG8gYW4gSFRNTEVsZW1lbnQsIFxyXG4gKiBhZGRpbmcgYSBSZWZDYWxsYmFjayBhbmQgbWVyZ2luZyBpdCB3aXRoIGFueSBleGlzdGluZyByZWYgdGhhdCBleGlzdGVkIG9uIHRoZSBwcm9wcy5cclxuICogXHJcbiAqIERvbid0IGZvcmdldCB0byBwcm92aWRlIHRoZSBFbGVtZW50IGFzIHRoZSB0eXBlIGFyZ3VtZW50IVxyXG4gKiBcclxuICogQHJldHVybnMgVGhlIGVsZW1lbnQsIGFuZCB0aGUgc3ViLWhvb2sgdGhhdCBtYWtlcyBpdCByZXRyaWV2YWJsZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWZFbGVtZW50PFQgZXh0ZW5kcyBFdmVudFRhcmdldD4oYXJncz86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+KTogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD4ge1xyXG4gICAgY29uc3QgeyBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9ID0gKGFyZ3MgPz8ge30pO1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVJlZkVsZW1lbnRcIiwgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQpO1xyXG5cclxuICAgIC8vIENhbGxlZCAoaW5kaXJlY3RseSkgYnkgdGhlIHJlZiB0aGF0IHRoZSBlbGVtZW50IHJlY2VpdmVzLlxyXG4gICAgY29uc3QgaGFuZGxlciA9IHVzZUNhbGxiYWNrPE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsPj4oKGUsIHByZXZWYWx1ZSkgPT4ge1xyXG4gICAgICAgIGxldCBjbGVhbnVwID0gb25FbGVtZW50Q2hhbmdlPy4oZSwgcHJldlZhbHVlKTtcclxuICAgICAgICBpZiAocHJldlZhbHVlKVxyXG4gICAgICAgICAgICBvblVubW91bnQ/LihwcmV2VmFsdWUhKTtcclxuXHJcbiAgICAgICAgaWYgKGUpXHJcbiAgICAgICAgICAgIG9uTW91bnQ/LihlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNsZWFudXA7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gTGV0IHVzIHN0b3JlIHRoZSBhY3R1YWwgKHJlZmVyZW5jZSB0bykgdGhlIGVsZW1lbnQgd2UgY2FwdHVyZVxyXG4gICAgY29uc3QgW2dldEVsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPFQgfCBudWxsPihoYW5kbGVyLCByZXR1cm5OdWxsKTtcclxuICAgIGNvbnN0IHVzZVJlZkVsZW1lbnRQcm9wcyA9IHVzZUNhbGxiYWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+W1widXNlUmVmRWxlbWVudFByb3BzXCJdPigocHJvcHMpID0+IHVzZU1lcmdlZFByb3BzPFQ+KHsgcmVmOiBzZXRFbGVtZW50IH0sIHByb3BzKSwgW10pO1xyXG5cclxuICAgIC8vIFJldHVybiBib3RoIHRoZSBlbGVtZW50IGFuZCB0aGUgaG9vayB0aGF0IG1vZGlmaWVzIFxyXG4gICAgLy8gdGhlIHByb3BzIGFuZCBhbGxvd3MgdXMgdG8gYWN0dWFsbHkgZmluZCB0aGUgZWxlbWVudFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VSZWZFbGVtZW50UHJvcHMsXHJcbiAgICAgICAgZ2V0RWxlbWVudFxyXG4gICAgfVxyXG59XHJcbiIsIlxuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCByZXR1cm5UcnVlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UGFyYW1ldGVycywgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcblxuXG4vKipcbiAqIFxuICogVGhlcmUgYXJlIHNldmVyYWwgZGlmZmVyZW50IHdheXMgdGhhdCBhIGZvY3VzIGV2ZW50IGNhbiBoYXBwZW4uICBBc3N1bWVcbiAqIHRoZSBmb2xsb3dpbmcgc3RlcHMgaGFwcGVuIGluIG9yZGVyOlxuICogXG4gKiAxLiBUaGUgcGFnZSBsb2Fkcy5cbiAqICAgICogTm90aGluZyBpcyBmb2N1c2VkLCBidXQgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGBib2R5YC4gXG4gKiAgICAqIE5vIGZvY3VzIGV2ZW50cyBhcmUgZmlyZWQuXG4gKiAyLiBUaGUgd2luZG93IGlzIGZvY3VzZWQsIGFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIHJlbWFpbnMgYXMgYGJvZHlgLlxuICogICAgKiBBIGBmb2N1c2AvYGZvY3VzaW5gIGV2ZW50ICpNSUdIVCogYmUgZmlyZWQgZm9yIGBib2R5YC4gRGVwZW5kaW5nIG9uXG4gKiAgICAgIHRoZSBicm93c2VyLCB0aGlzIGRlcGVuZHMgb24gd2hldGhlciB0aGUgaGFuZGxlciB3YXMgYXR0YWNoZWQgdG8gYHdpbmRvd2Agb3IgYGRvY3VtZW50YC5cbiAqICAgICAgUHJvYmFibHkganVzdCBiZXN0IHRvIG5vdCByZWx5IG9uIGl0LCBvciBsaXN0ZW4gdG8gYHdpbmRvd2AgZm9jdXMgZXZlbnRzIGRpcmVjdGx5LlxuICogMy4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBuZXcgZWxlbWVudCBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXG4gKiAgICAqIGBmb2N1c291dGAgYW5kIGBibHVyYCBhcmUgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxuICogICAgKiBgZm9jdXNgIGFuZCBgZm9jdXNpbmAgYXJlIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwuXG4gKiA0LiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cbiAqICAgICogKipUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgYGJvZHlgKiogYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxuICogICAgKiBgYmx1cmAgYW5kIGBmb2N1c291dGAgYXJlIGZpcmVkIG9uIHRoZSBvbGQgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBuZXcgZWxlbWVudC5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBub3cgc2V0IHRvIHRoZSBuZXcgZWxlbWVudC5cbiAqICAgICogYGZvY3VzaW5gIGlzIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBvbGQgZWxlbWVudC5cbiAqIDUuIEFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byBgYm9keWAuXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cbiAqICAgICogYGZvY3VzaW5gIGlzICpub3QqIGZpcmVkIG9uIGBib2R5YC5cbiAqIFxuICogXG4gKiBJbiBzdW1tYXJ5OlxuICogMS4gRm9jdXMgZXZlbnRzICpkbyogbm90aWZ5IHVzIG9mIGFsbCBjaGFuZ2VzIGluIGZvY3VzLCBidXQgdGhlcmUgaXMgbm8gb25lIHNpbmdsZSBjb21wcmVoZW5zaXZlIGV2ZW50IHRoYXQgcHJvdmlkZXMgdXMgd2l0aCBhbGwgYXZhaWxhYmxlIGluZm9ybWF0aW9uLlxuICogMi4gYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgICppcyBub3QqIGFsd2F5cyB0aGUgc2FtZSBhcyB3aGF0J3MgYmVpbmcgcmVmZXJlbmNlZCBieSBhIGZvY3VzIGV2ZW50LiBJbiBwYXJ0aWN1bGFyLCBpdCBtYXkgYmVjb21lIGBib2R5YCBhdCBhbnkgYXJiaXRyYXJ5IHRpbWUuXG4gKiAzLiBBIGBibHVyYCB3aXRob3V0IGEgYGZvY3VzYCBjYW4gYW5kIHdpbGwgb2NjdXIuIFRoaXMgbWVhbnMgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHNvbGVseSB1c2UgYGZvY3VzYCB0byBkZXRlY3QgYWxsIGNoYW5nZXMuXG4gKiA0LiBBIGBibHVyYCBldmVudCB3aG9zZSBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIGZvbGxvd2luZyBgZm9jdXNgIGV2ZW50LlxuICogXG4gKiBcbiAqIEBwYXJhbSBjYWxsYmFjayBcbiAqIEByZXR1cm5zIFxuICovXG5jb25zdCBfZHVtbXkgPSAwO1xuXG5jb25zdCBhY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGU6IE5vZGUgfCBudWxsKSA9PiB2b2lkKT4+KCk7XG5jb25zdCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBOb2RlKSA9PiB2b2lkKT4+KCk7XG5jb25zdCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHZvaWQpPj4oKTtcbmNvbnN0IHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIGJvb2xlYW4+KCk7XG5cbmNvbnN0IG1pY3JvdGFza3MgPSBuZXcgU2V0PE1hcDxhbnksIGFueT4+KCk7XG5cbi8vIFRoZSBmb2N1c2luIGFuZCBmb2N1c291dCBldmVudHMgb2Z0ZW4gZmlyZSBzeW5jcm9ub3VzbHkgaW4gdGhlIG1pZGRsZSBvZiBydW5uaW5nIGNvZGUuXG4vLyBFLkcuIGNhbGxpbmcgZWxlbWVudC5mb2N1cygpIGNhbiBjYXVzZSBhIGZvY3VzaW4gZXZlbnQgaGFuZGxlciB0byBpbW1lZGlhdGVseSBpbnRlcnJ1cHQgdGhhdCBjb2RlLlxuLy8gRm9yIHRoZSBwdXJwb3NlIG9mIGltcHJvdmluZyBzdGFiaWxpdHksIHdlIGRlYm91bmNlIGFsbCBmb2N1cyBldmVudHMgdG8gdGhlIG5leHQgbWljcm90YXNrLlxuZnVuY3Rpb24gZm9yRWFjaFVwZGF0ZXI8VD4od2luZG93OiBXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBtYXA6IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBUKSA9PiB2b2lkKT4+LCB2YWx1ZTogVCkge1xuICAgIGlmICghbWljcm90YXNrcy5oYXMobWFwKSkge1xuICAgICAgICBtaWNyb3Rhc2tzLmFkZChtYXApO1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICBtaWNyb3Rhc2tzLmRlbGV0ZShtYXApO1xuXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVycyA9IG1hcC5nZXQod2luZG93KTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVycykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlciBvZiB1cGRhdGVycykge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVyPy4odmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb2N1c291dChlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cbiAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIG51bGwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSnVzdCB3YWl0IGZvciB0aGUgZm9jdXNpbiBldmVudC5cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gZm9jdXNpbihlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgY29uc3QgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQgPSBlLnRhcmdldCBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHdpbmRvd0ZvY3VzKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIHRydWUpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gd2luZG93Qmx1cihlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS50YXJnZXQgOiBlLmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLmN1cnJlbnRUYXJnZXQgOiAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyk7XG4gICAgd2luZG93c0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCBmYWxzZSk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMsIGZhbHNlKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyczxUIGV4dGVuZHMgTm9kZT4ge1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbD47XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMgYW5kIGlzIG5vdCBudWxsLiBcbiAgICAgKiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8VD47XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIHdpbmRvdyBnYWlucy9sb3NlcyBmb2N1cy4gTXVzdCBiZSBzdGFibGUuXG4gICAgICovXG4gICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8Ym9vbGVhbj47XG5cbiAgICBvbk1vdW50PzogVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD5bXCJvbk1vdW50XCJdO1xuICAgIG9uVW5tb3VudD86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+W1wib25Vbm1vdW50XCJdO1xuICAgIG9uTW91bnRDaGFuZ2U/OiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPltcIm9uRWxlbWVudENoYW5nZVwiXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY3RpdmVFbGVtZW50UmV0dXJuVHlwZTxUIGV4dGVuZHMgTm9kZT4gZXh0ZW5kcyBPbWl0PFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+LCBcInVzZVJlZkVsZW1lbnRQcm9wc1wiPiB7XG4gICAgLyoqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3IgYG51bGxgIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50ICovXG4gICAgZ2V0QWN0aXZlRWxlbWVudDogKCkgPT4gVCB8IG51bGw7XG4gICAgLyoqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3Igd2hhdGV2ZXIgZWxlbWVudCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50ICovXG4gICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQ6ICgpID0+IFQ7XG4gICAgLyoqIFJldHVybnMgaWYgdGhlIHdpbmRvdyBpdHNlbGYgaGFzIGZvY3VzIG9yIG5vdCAqL1xuICAgIGdldFdpbmRvd0ZvY3VzZWQ6ICgpID0+IGJvb2xlYW47XG5cbiAgICB1c2VBY3RpdmVFbGVtZW50UHJvcHM6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+W1widXNlUmVmRWxlbWVudFByb3BzXCJdO1xufVxuXG4vKipcbiAqIEFsbG93cyB5b3UgdG8gaW5zcGVjdCB3aGljaCBlbGVtZW50IGluIHRoZSBgZG9jdW1lbnRgIGN1cnJlbnRseSBoYXMgZm9jdXMsIHdoaWNoIHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgbm9uZSBhcmUgY3VycmVudGx5LCBhbmQgd2hldGhlciBvciBub3QgdGhlIHdpbmRvdyBoYXMgZm9jdXMgYnkgcmV0dXJuaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICogKiBgZ2V0QWN0aXZlRWxlbWVudCgpYFxuICogKiBgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQoKWBcbiAqICogYGdldFdpbmRvd0ZvY3VzZWQoKWBcbiAqIFxuICogKFRoZSBkb2N1bWVudCdzIGJvZHkgcmVjZWl2aW5nIGZvY3VzLCBsaWtlIGl0IGRvZXMgd2hlbiB5b3UgY2xpY2sgb24gYW4gZW1wdHkgYXJlYSwgaXMgY291bnRlZCBhcyBubyBlbGVtZW50IGhhdmluZyBmb2N1cyBmb3IgYWxsIGludGVudHMgYW5kIHB1cnBvc2VzKVxuICogXG4gKiBUaGlzIGlzIGEgcGFzc2l2ZSBob29rLCBzbyBieSBkZWZhdWx0IGl0IHJldHVybnMgZ2V0dGVyIGZ1bmN0aW9ucyB0aGF0IHJlcG9ydCB0aGlzIGluZm9ybWF0aW9uIGJ1dCB0aGUgY29tcG9uZW50IHdpbGwgbm90IHJlLXJlbmRlciBieSBkZWZhdWx0IHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMuXG4gKiBcbiAqIElmIHlvdSBuZWVkIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMsIHVzZSB0aGUgYG9uKkNoYW5nZWAgYXJndW1lbnRzIHRvIHNldCBzb21lIHN0YXRlIG9uIHlvdXIgZW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aXZlRWxlbWVudDxUIGV4dGVuZHMgTm9kZT4oeyBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50LCBvbk1vdW50Q2hhbmdlIH06IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzPFQ+KTogVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGU8VD4ge1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlQWN0aXZlRWxlbWVudFwiLCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgb25Nb3VudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50KTtcblxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHtcbiAgICAgICAgb25Nb3VudCxcbiAgICAgICAgb25Vbm1vdW50LFxuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlbGVtZW50OiBUIHwgbnVsbCwgcHJldlZhbHVlOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VudENoYW5nZT8uKGVsZW1lbnQsIHByZXZWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpbmRvdyA9IGRvY3VtZW50Py5kZWZhdWx0VmlldztcblxuICAgICAgICAgICAgICAgIGlmICgoYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpPy5zaXplID8/IDApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZm9jdXNvdXQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgd2luZG93Rm9jdXMsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZW0gZXZlbiBpZiB0aGV5J3JlIHVuZGVmaW5lZCB0byBtb3JlIGVhc2lseVxuICAgICAgICAgICAgICAgIC8vIG1hbmFnZSB0aGUgXCI+MCBtZWFucyBkb24ndCBhZGQgaGFuZGxlcnNcIiBsb2dpYy5cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMgPSB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuXG4gICAgICAgICAgICAgICAgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMuYWRkKHNldEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGUgfCBudWxsPik7XG4gICAgICAgICAgICAgICAgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChzZXRMYXN0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZT4pO1xuICAgICAgICAgICAgICAgIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzLmFkZChzZXRXaW5kb3dGb2N1c2VkKTtcblxuICAgICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyk7XG4gICAgICAgICAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xuICAgICAgICAgICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykhLmRlbGV0ZShzZXRBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlIHwgbnVsbD4pO1xuICAgICAgICAgICAgICAgICAgICBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUoc2V0TGFzdEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGU+KTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUoc2V0V2luZG93Rm9jdXNlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1cik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKVxuICAgIH0pXG5cbiAgICBjb25zdCBbZ2V0QWN0aXZlRWxlbWVudCwgc2V0QWN0aXZlRWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8VCB8IG51bGw+KG9uQWN0aXZlRWxlbWVudENoYW5nZSwgcmV0dXJuTnVsbCk7XG4gICAgY29uc3QgW2dldExhc3RBY3RpdmVFbGVtZW50LCBzZXRMYXN0QWN0aXZlRWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8VD4ob25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgcmV0dXJuTnVsbCBhcyAoKSA9PiBuZXZlcik7XG4gICAgY29uc3QgW2dldFdpbmRvd0ZvY3VzZWQsIHNldFdpbmRvd0ZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmV0dXJuVHJ1ZSk7XG5cbiAgICByZXR1cm4geyBnZXRFbGVtZW50LCB1c2VBY3RpdmVFbGVtZW50UHJvcHM6IHVzZVJlZkVsZW1lbnRQcm9wcywgZ2V0QWN0aXZlRWxlbWVudCwgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsIGdldFdpbmRvd0ZvY3VzZWQgfTtcbn1cbiIsIlxuaW1wb3J0IHsgQ29tcG9uZW50LCBvcHRpb25zLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEVmZmVjdENhbGxiYWNrLCBJbnB1dHMsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cblxuXG5jb25zdCBUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLVwiO1xuXG5mdW5jdGlvbiBiYXNlNjQodmFsdWU6IG51bWJlcikge1xuICAgIHJldHVybiBUYWJsZVt2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTZCaXRzKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAwYjEwMDAwMDApO1xufVxuXG5mdW5jdGlvbiByYW5kb202NEJpdHMoKSB7XG4gICAgcmV0dXJuIFtyYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpXSBhcyBjb25zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIHdpdGggYW4gb3B0aW9uYWwgcHJlZml4LlxuICogTm90ZSB0aGF0IGlmIHRoZSBwcmVmaXggaXMgKmV4cGxpY2l0bHkqIHNldCB0byBcIlwiLCB0aGVuXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxuICogXG4gKiBcbiAqIChUaGlzIGlzIGhlcmUsIGluIHRoaXMgcGFydGljdWxhciBmaWxlLCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbiAqIHdpdGhvdXQgYWxzbyBtYWtpbmcgYSB1dGlsaXRpZXMgZmlsZS5cbiAqIE9uY2Ugd2UgY2FuIHJlbW92ZSB0aGlzIGhvb2ssIHdlIGNhbiBwdXQgdGhpcyBmdW5jdGlvbiBiYWNrIHdpdGggdXNlUmFuZG9tSWQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeD86IHN0cmluZykge1xuICAgIHJldHVybiBgJHtwcmVmaXggPz8gXCJpZC1cIn0ke3JhbmRvbTY0Qml0cygpLm1hcChuID0+IGJhc2U2NChuKSkuam9pbihcIlwiKX1gO1xufVxuXG5jb25zdCBwcmV2aW91c0lucHV0cyA9IG5ldyBNYXA8c3RyaW5nLCBJbnB1dHMgfCB1bmRlZmluZWQ+KCk7XG5jb25zdCB0b1J1biA9IG5ldyBNYXA8c3RyaW5nLCB7IGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cywgY2xlYW51cDogbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWQgfCAoKCkgPT4gdm9pZCkgfT4oKTtcblxuXG4vLyBUT0RPOiBXaGV0aGVyIHRoaXMgZ29lcyBpbiBvcHRpb25zLmRpZmZlZCBvciBvcHRpb25zLl9jb21taXRcbi8vIGlzIGEgcG9zdC1zdXNwZW5zZSBxdWVzdGlvbi5cbi8vIFJpZ2h0IG5vdywgdXNpbmcgb3B0aW9ucy5fY29tbWl0IGhhcyB0aGUgcHJvYmxlbSBvZiBydW5uaW5nXG4vLyAqYWZ0ZXIqIHJlZnMgYXJlIGFwcGxpZWQsIGJ1dCB3ZSBuZWVkIHRvIGNvbWUgYmVmb3JlIGV2ZW4gdGhhdFxuLy8gc28gYHJlZj17c29tZVN0YWJsZUZ1bmN0aW9ufWAgd29ya3MuXG4vLyBcbi8vIEFsc28gaXQncyBwcml2YXRlLlxuLy9cbi8vIC4uLlxuLy8gV2VsbCwgdXNlRXZlbnQgb3Igd2hhdGV2ZXIgaXMgZmluYWxseSwgZmluYWxseSA0IHllYXJzIGxhdGVyIGZpbmFsbHkgaGVyZVxuLy8gd2hpY2ggaXMgY29vbCBhbmQgbWVhbnMgd2Ugd29uJ3QgbmVlZCB0aGlzIGF0IGFsbCBzb29uLlxuLy8gU28gZm9yIG5vdyB3ZSdsbCBzdGljayB3aXRoIGRpZmYgdG8gcHJldmVudCBhbnkgd2VpcmRuZXNzIHdpdGhcbi8vIGNvbW1pdCBiZWluZyBwcml2YXRlIGFuZCBhbGwuXG5jb25zdCBjb21taXROYW1lID0gXCJkaWZmZWRcIjtcblxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdIGFzICh2bm9kZTogVk5vZGUsIGNvbW1pdFF1ZXVlOiBDb21wb25lbnRbXSkgPT4gdm9pZDtcbmNvbnN0IG5ld0NvbW1pdDogdHlwZW9mIG9yaWdpbmFsQ29tbWl0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZWZmZWN0SW5mb10gb2YgdG9SdW4pIHtcbiAgICAgICAgY29uc3Qgb2xkSW5wdXRzID0gcHJldmlvdXNJbnB1dHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKG9sZElucHV0cywgZWZmZWN0SW5mby5pbnB1dHMpKSB7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXA/LigpO1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLnNldChpZCwgZWZmZWN0SW5mby5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUnVuLmNsZWFyKCk7XG4gICAgb3JpZ2luYWxDb21taXQ/LiguLi5hcmdzKTtcbn1cbm9wdGlvbnNbY29tbWl0TmFtZV0gPSBuZXdDb21taXQgYXMgbmV2ZXJcblxuLyoqXG4gKiBTZW1pLXByaXZhdGUgZnVuY3Rpb24gdG8gYWxsb3cgc3RhYmxlIGNhbGxiYWNrcyBldmVuIHdpdGhpbiBgdXNlTGF5b3V0RWZmZWN0YCBhbmQgcmVmIGFzc2lnbm1lbnQuXG4gKiBcbiAqIEV2ZXJ5IHJlbmRlciwgd2Ugc2VuZCB0aGUgYXJndW1lbnRzIHRvIGJlIGV2YWx1YXRlZCBhZnRlciBkaWZmaW5nIGhhcyBjb21wbGV0ZWQsXG4gKiB3aGljaCBoYXBwZW5zIGJlZm9yZS5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgaW5wdXRzPzogSW5wdXRzKSB7XG5cbiAgICAvKigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSB1c2VSZWY8dm9pZCB8ICgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpO1xuICAgICAgICBjb25zdCBwcmV2QXJnc1JlZiA9IHVzZVJlZjxJbnB1dHM+KG51bGwhKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKGlucHV0cywgcHJldkFyZ3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIHByZXZBcmdzUmVmLmN1cnJlbnQgPSBpbnB1dHMhO1xuICAgICAgICAgICAgaWYgKGNsZWFudXAuY3VycmVudClcbiAgICAgICAgICAgICAgICBjbGVhbnVwLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCA9IGVmZmVjdCgpO1xuICAgICAgICB9XG4gICAgfSkoKTsqL1xuXG4gICAgY29uc3QgW2lkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoKSk7XG4gICAgdG9SdW4uc2V0KGlkLCB7IGVmZmVjdCwgaW5wdXRzLCBjbGVhbnVwOiBudWxsIH0pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfSwgW2lkXSlcbn1cblxuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncz86IElucHV0cywgbmV3QXJncz86IElucHV0cyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIShcbiAgICAgICAgIW9sZEFyZ3MgfHxcbiAgICAgICAgb2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3M/Lmxlbmd0aCB8fFxuICAgICAgICBuZXdBcmdzPy5zb21lKChhcmcsIGluZGV4KSA9PiBhcmcgIT09IG9sZEFyZ3NbaW5kZXhdKVxuICAgICk7XG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUJlZm9yZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdFwiO1xuXG5jb25zdCBVbnNldCA9IFN5bWJvbChcInVuc2V0XCIpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IHZhbHVlLCByZXR1cm5zIGEgY29uc3RhbnQgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gKiBcbiAqIFRoaXMgdXNlcyBgb3B0aW9ucy5kaWZmZWRgIGluIG9yZGVyIHRvIHJ1biBiZWZvcmUgZXZlcnl0aGluZywgZXZlblxuICogcmVmIGFzc2lnbm1lbnQuIFRoaXMgbWVhbnMgdGhpcyBnZXR0ZXIgaXMgc2FmZSB0byB1c2UgYW55d2hlcmUgKioqZXhjZXB0IHRoZSByZW5kZXIgcGhhc2UqKiouXG4gKiBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlR2V0dGVyPFQ+KHZhbHVlOiBUKTogKCkgPT4gVCB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KFVuc2V0IGFzIHVua25vd24gYXMgVCk7XG4gICAgdXNlQmVmb3JlTGF5b3V0RWZmZWN0KCgpID0+IHsgcmVmLmN1cnJlbnQgPSB2YWx1ZTsgfSwgW3ZhbHVlXSk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50IGFzIHVua25vd24gPT09IFVuc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUdldHRlcigpIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlci4nKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgICB9LCBbXSlcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cblxuLyoqXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXG4gKiBzbyB0aGF0IGl0IGNhbiBiZSBleGNsdWRlZCBmcm9tIHRoZSBkZXBlbmRlbmN5IGFycmF5cyBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcy5cbiAqIFxuICogRG8gbm90IHVzZSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSEgIGB1c2VMYXlvdXRFZmZlY3RgIGlzIGZpbmUgdGhvdWdoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlQ2FsbGJhY2s8VCBleHRlbmRzICguLi5fYXJnczogYW55W10pID0+IGFueT4oZm46IFQpOiBUIHtcbiAgICBjb25zdCBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIgPSB1c2VTdGFibGVHZXR0ZXI8VD4oZm4pO1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KTogUmV0dXJuVHlwZTxUPiA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIoKSguLi5hcmdzKTtcbiAgICB9LCBbXSkgYXMgVDtcbn0iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlQmF0Y2hlZEFuaW1hdGlvbkZyYW1lcyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcblxuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJhZGRDYWxsYmFja1wiXT4oKGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5zZXQoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKTsgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJyZW1vdmVDYWxsYmFja1wiXT4oKGNhbGxiYWNrKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LmRlbGV0ZShjYWxsYmFjayk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnRleHRJbmZvID0gdXNlUmVmPENvbnRleHRUeXBlPihudWxsISk7XG4gICAgaWYgKGNvbnRleHRJbmZvLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgY29udGV4dEluZm8uY3VycmVudCA9IHsgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrIH07XG4gICAgY29uc3QgYWxsQ2FsbGJhY2tzID0gdXNlUmVmPE1hcDxSYWZDYWxsYmFja1R5cGUsIGFueT4+KG51bGwhKTtcbiAgICBpZiAoYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gLTE7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFmV2l0aEJhdGNoZWRDYWxsYmFja3MobXNTaW5jZUxhc3Q6IG51bWJlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hlZFJhZkNhbGxiYWNrLCB0YWddIG9mIGFsbENhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlZFJhZkNhbGxiYWNrKG1zU2luY2VMYXN0LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEluZm8uY3VycmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyPilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdpdGggZWZmZWN0aXZlbHkgdGhlIHNhbWUgcnVsZXMgYXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKi9cbiAgICBjYWxsYmFjazogbnVsbCB8ICgobXNTaW5jZUxhc3Q6IG51bWJlcikgPT4gdm9pZCk7XG59XG5cbi8qKlxuICogVGhlIChvcHRpb25hbGx5IG5vbi1zdGFibGUpIGBjYWxsYmFja2AgeW91IHByb3ZpZGUgd2lsbCBzdGFydCBydW5uaW5nIGV2ZXJ5IGZyYW1lIGFmdGVyIHRoZSBjb21wb25lbnQgbW91bnRzLlxuICogXG4gKiBQYXNzaW5nIGBudWxsYCBpcyBmaW5lIGFuZCBzaW1wbHkgc3RvcHMgdGhlIGVmZmVjdCB1bnRpbCB5b3UgcmVzdGFydCBpdCBieSBwcm92aWRpbmcgYSBub24tbnVsbCBjYWxsYmFjay5cbiAqIFxuICogKipUaGlzIGhvb2sgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGF0IGFsbCwgaW5jbHVkaW5nIG5vIHByb3AtbW9kaWZ5aW5nIGhvb2tzKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFuaW1hdGlvbkZyYW1lKHsgY2FsbGJhY2sgfTogVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIGdpdmVuIGNhbGxiYWNrIHRoYXQncyBzdGFibGVcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKGNhbGxiYWNrID8/IG5vb3ApO1xuICAgIGNvbnN0IGhhc0NhbGxiYWNrID0gKGNhbGxiYWNrICE9IG51bGwpO1xuXG4gICAgY29uc3Qgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gdXNlQ29udGV4dChTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LmFkZENhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5yZW1vdmVDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgd3JhcHBlciBhcm91bmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbHNvIGNhbGxzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFnYWluLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZkNhbGxiYWNrID0gKG1zOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlQ2FsbGJhY2sobXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQsIGhhc0NhbGxiYWNrXSlcbn1cblxuLy8gZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5mdW5jdGlvbiBub29wKCkgeyB9XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH07XG5cblxuICAgIGNvbnNvbGUuYXNzZXJ0KHJlZi5jdXJyZW50ID09PSBzdGF0ZSB8fCAodHlwZW9mIHN0YXRlID09PSBcIm51bWJlclwiICYmIGlzTmFOKHN0YXRlKSkpO1xuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiaW1wb3J0IHsgSW5wdXRzLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0TmF0aXZlLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG4vKipcclxuICogV3JhcCB0aGUgbmF0aXZlIGB1c2VFZmZlY3RgIHRvIGFkZCBhcmd1bWVudHMgXHJcbiAqIHRoYXQgYWxsb3cgYWNjZXNzaW5nIHRoZSBwcmV2aW91cyB2YWx1ZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXHJcbiAqIGFzIHdlbGwgYXMgdGhlIGNoYW5nZXMgdGhhdCBjYXVzZWQgdGhlIGhvb2sgdG8gYmUgY2FsbGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXHJcbiAqIFxyXG4gKiBAcGFyYW0gZWZmZWN0IFxyXG4gKiBAcGFyYW0gaW5wdXRzIFxyXG4gKiBAcGFyYW0gaW1wbCBZb3UgY2FuIGNob29zZSB3aGV0aGVyIHRvIHVzZSBgdXNlRWZmZWN0YCBvciBgdXNlTGF5b3V0RWZmZWN0YCBieVxyXG4gKiBwYXNzaW5nIG9uZSBvZiB0aGVtIGFzIHRoaXMgYXJndW1lbnQuIEJ5IGRlZmF1bHQsIGl0J3MgYHVzZUVmZmVjdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlRWZmZWN0PEkgZXh0ZW5kcyBJbnB1dHM+KGVmZmVjdDogKHByZXY6IEkgfCB1bmRlZmluZWQsIGNoYW5nZXM6IEVmZmVjdENoYW5nZTxJLCBudW1iZXI+W10pID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSwgaW5wdXRzPzogSSwgaW1wbCA9IHVzZUVmZmVjdE5hdGl2ZSkge1xyXG5cclxuICAgIGNvbnN0IHByZXZJbnB1dHMgPSB1c2VSZWY8dW5kZWZpbmVkIHwgST4odW5kZWZpbmVkKTtcclxuICAgIGNvbnN0IGVmZmVjdDIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlczogeyBmcm9tOiBhbnksIHRvOiBhbnkgfVtdID0gW107XHJcbiAgICAgICAgaWYgKGlucHV0cyAmJiBwcmV2SW5wdXRzLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heChwcmV2SW5wdXRzLmN1cnJlbnQubGVuZ3RoLCBpbnB1dHMubGVuZ3RoKTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldklucHV0cy5jdXJyZW50W2ldICE9IGlucHV0c1tpXSlcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzW2ldID0geyBmcm9tOiBwcmV2SW5wdXRzLmN1cnJlbnRbaV0sIHRvOiBpbnB1dHNbaV0gfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJldCA9IGVmZmVjdChwcmV2SW5wdXRzLmN1cnJlbnQsIGNoYW5nZXMpO1xyXG4gICAgICAgIHByZXZJbnB1dHMuY3VycmVudCA9IGlucHV0cztcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfTtcclxuXHJcbiAgICBpbXBsKGVmZmVjdDIsIGlucHV0cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRWZmZWN0Q2hhbmdlPEkgZXh0ZW5kcyBJbnB1dHMsIE4gZXh0ZW5kcyBudW1iZXI+IHsgZnJvbTogSVtOXSwgdG86IElbTl0gfVxyXG4iLCJpbXBvcnQgeyBJbnB1dHMsIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3ROYXRpdmUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFZmZlY3RDaGFuZ2UsIHVzZUVmZmVjdCB9IGZyb20gXCIuL3VzZS1lZmZlY3RcIjtcblxuLyoqXG4gKiBXcmFwIHRoZSBuYXRpdmUgYHVzZUxheW91dEVmZmVjdGAgdG8gYWRkIGFyZ3VtZW50cyBcbiAqIHRoYXQgYWxsb3cgYWNjZXNzaW5nIHRoZSBwcmV2aW91cyB2YWx1ZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhcyB3ZWxsIGFzIHRoZSBjaGFuZ2VzIHRoYXQgY2F1c2VkIHRoZSBob29rIHRvIGJlIGNhbGxlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICogXG4gKiBAcGFyYW0gZWZmZWN0IFxuICogQHBhcmFtIGlucHV0cyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdDxJIGV4dGVuZHMgSW5wdXRzPihlZmZlY3Q6IChwcmV2OiBJIHwgdW5kZWZpbmVkLCBjaGFuZ2VzOiBFZmZlY3RDaGFuZ2U8SSwgbnVtYmVyPltdKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSksIGlucHV0cz86IEkpIHtcbiAgICByZXR1cm4gdXNlRWZmZWN0KGVmZmVjdCwgaW5wdXRzLCB1c2VMYXlvdXRFZmZlY3ROYXRpdmUpO1xufVxuIiwiaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5GYWxzZSwgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcblxuLyoqXG4gKiBSZW1pbmRlciBvZiBvcmRlciBvZiBleGVjdXRpb246XG4gKiBcbiAqICogKHRyZWUgbW91bnRzKVxuICogKiBQYXJlbnQgcmVuZGVyc1xuICogKiBDaGlsZHJlbiByZW5kZXJcbiAqICogQ2hpbGRyZW4gcmVjZWl2ZSByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIFBhcmVudCByZWNlaXZlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdHNcbiAqIFxuICogKiAodHJlZSB1bm1vdW50cylcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogUGFyZW50IGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIENoaWxkIGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcbiAqICogUmVuZGVyaW5nIHN0YXJ0cyBhdCB0aGUgcm9vdCwgIGJ1dCBlZmZlY3RzIGFuZCByZWZzIHN0YXJ0IGF0IHRoZSBsZWF2ZXMuXG4gKiAqIHJlZnMgYXJlICp1c3VhbGx5KiBjYWxsZWQgYmVmb3JlIGVmZmVjdHMsIGJ1dCBvbmx5IHdoZW4gdGhhdCBIVE1MRWxlbWVudCByZW5kZXJzLiBCYXNpY2FsbHkganVzdCBhIHJlbWluZGVyIHRoYXQgYSBjb21wb25lbnQgY2FuIGJlIG1vdW50ZWQgd2l0aG91dCBpdCBleGlzdGluZyBpbiB0aGUgRE9NLlxuICovXG5jb25zdCBfY29tbWVudHMgPSB2b2lkICgwKTtcblxuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRJbmZvQmFzZTxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiB7XG4gICAgaW5kZXg6IFRcbn1cblxuZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkPEkgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvQmFzZTxzdHJpbmcgfCBudW1iZXI+PiA9IChhOiB7IGluZm86IE1hbmFnZWRDaGlsZEluZm9OZWVkZWQ8ST4gfSkgPT4gdm9pZDtcblxuZXhwb3J0IHR5cGUgTWFuYWdlZENoaWxkSW5mb05lZWRlZDxJIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mb0Jhc2U8c3RyaW5nIHwgbnVtYmVyPj4gPSBJICYge31cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8SSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm9CYXNlPHN0cmluZyB8IG51bWJlcj4+IHtcbiAgICAvKipcbiAgICAgKiBBIGhvb2sgdGhhdCBtdXN0IGJlIGNhbGxlZCBieSBldmVyeSBjaGlsZCBjb21wb25lbnQgdGhhdFxuICAgICAqIGlzIHRvIGJlIG1hbmFnZWQgYnkgdGhpcyBvbmUuIFRoZSBhcmd1bWVudCB0byB0aGUgaG9va1xuICAgICAqIGlzIGp1c3QgdGhlIGJhZyBvZiBwcm9wZXJ0aWVzIHRvIHBhc3MgdG8gdGhlIHBhcmVudCxcbiAgICAgKiBpbmNsdWRpbmcgdGhlIGNoaWxkJ3MgaW5kZXguXG4gICAgICovXG4gICAgdXNlTWFuYWdlZENoaWxkOiBVc2VNYW5hZ2VkQ2hpbGQ8ST47XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hpbGQgdGhhdCByZW5kZXJlZCBpdHNlbGYgd2l0aCB0aGUgcmVxdWVzdGVkIGtleS5cbiAgICAgKiBcbiAgICAgKiAqKlN0YWJsZSwgYnV0IGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlciEqKlxuICAgICAqL1xuICAgIGNoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48ST47XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZHJlbjxJIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mb0Jhc2U8c3RyaW5nIHwgbnVtYmVyPj4ge1xuICAgIGdldEF0KGluZGV4OiBJW1wiaW5kZXhcIl0pOiBJIHwgdW5kZWZpbmVkO1xuICAgIC8vZ2V0U2l6ZSgpOiBudW1iZXI7XG4gICAgZ2V0SGlnaGVzdEluZGV4KCk6IG51bWJlcjtcbiAgICBmb3JFYWNoOiAoZjogKGNoaWxkOiBJKSA9PiB2b2lkKSA9PiB2b2lkO1xuICAgIHNsaWNlU29ydDogKGNvbXBhcmU6IChsaHM6IEksIHJoczogSSkgPT4gbnVtYmVyKSA9PiBJW107XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPEkgZXh0ZW5kcyB7IGluZGV4PzogYW55IH0+IHtcbiAgICAvKipcbiAgICAgKiBSdW5zIGFmdGVyIG9uZSBvciBtb3JlIGNoaWxkcmVuIGhhdmUgdXBkYXRlZCB0aGVpciBpbmZvcm1hdGlvbiAoaW5kZXgsIGV0Yy4pLlxuICAgICAqIFxuICAgICAqIE9ubHkgb25lIHdpbGwgcnVuIHBlciB0aWNrLCBqdXN0IGxpa2UgbGF5b3V0RWZmZWN0LCBidXQgaXQgaXNuJ3RcbiAgICAgKiAqZ3VhcmFudGVlZCogdG8gaGF2ZSBhY3R1YWxseSBiZWVuIGEgY2hhbmdlLlxuICAgICAqL1xuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdD86IG51bGwgfCB1bmRlZmluZWQgfCAoKGNhdXNlcnM6IEl0ZXJhYmxlPElbXCJpbmRleFwiXT4pID0+IHZvaWQpO1xuXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyB0aGUgYWJvdmUsIGJ1dCBvbmx5IGZvciBtb3VudC91bm1vdW50IChvciB3aGVuIGEgY2hpbGQgY2hhbmdlcyBpdHMgaW5kZXgpXG4gICAgICovXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPzogbnVsbCB8IHVuZGVmaW5lZCB8ICgobW91bnRlZDogU2V0PElbXCJpbmRleFwiXT4sIHVubW91bnRlZDogU2V0PElbXCJpbmRleFwiXT4pID0+IHZvaWQpO1xufVxuXG4vL2V4cG9ydCB0eXBlIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8SSBleHRlbmRzIHt9PiA9IHsgaW5mbzogSSB9O1xuXG4vKipcbiAqIEFsbG93cyBhIHBhcmVudCBjb21wb25lbnQgdG8gYWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IGNlcnRhaW5cbiAqIGNoaWxkIGNvbXBvbmVudHMgb25jZSB0aGV5IGhhdmUgcmVuZGVyZWQuXG4gKiBcbiAqIFRoaXMgaG9vayBpcyBkZXNpZ25lZCB0byBiZSBsaWdodHdlaWdodCwgaW4gdGhhdCB0aGUgcGFyZW50IGtlZXBzIG5vIHN0YXRlXG4gKiBhbmQgcnVucyBubyBlZmZlY3RzLiAgRWFjaCBjaGlsZCAqZG9lcyogcnVuIGFuIGVmZmVjdCwgYnV0IHdpdGggbm8gc3RhdGVcbiAqIGNoYW5nZXMgdW5sZXNzIHlvdSBleHBsaWNpdGx5IHJlcXVlc3QgdGhlbS5cbiAqIFxuICogXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYW5hZ2VkQ2hpbGRyZW48STMgZXh0ZW5kcyB7fT4oeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9OiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPEkzICYgTWFuYWdlZENoaWxkSW5mb0Jhc2U8c3RyaW5nIHwgbnVtYmVyPj4pOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPEkzICYgTWFuYWdlZENoaWxkSW5mb0Jhc2U8c3RyaW5nIHwgbnVtYmVyPj4ge1xuICAgIHR5cGUgSSA9IEkzICYgTWFuYWdlZENoaWxkSW5mb0Jhc2U8c3RyaW5nIHwgbnVtYmVyPjtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1hbmFnZWRDaGlsZHJlblwiLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSk7XG5cbiAgICBjb25zdCBnZXRIaWdoZXN0SW5kZXggPSB1c2VDYWxsYmFjaygoKTogbnVtYmVyID0+IHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDE7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gQWxsIHRoZSBpbmZvcm1hdGlvbiB3ZSBoYXZlIGFib3V0IG91ciBjaGlsZHJlbiBpcyBzdG9yZWQgaW4gdGhpcyAqKnN0YWJsZSoqIGFycmF5LlxuICAgIC8vIEFueSBtdXRhdGlvbnMgdG8gdGhpcyBhcnJheSAqKkRPIE5PVCoqIHRyaWdnZXIgYW55IHNvcnQgb2YgYSByZS1yZW5kZXIuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuQXJyYXkgPSB1c2VSZWY8eyBhcnI6IEFycmF5PEk+OyByZWM6IFBhcnRpYWw8UmVjb3JkPElbXCJpbmRleFwiXSwgST4+OyB9Pih7IGFycjogW10sIHJlYzoge30gfSk7XG5cbiAgICAvLyBGb3IgaW5kaXJlY3QgYWNjZXNzIHRvIGVhY2ggY2hpbGRcbiAgICAvLyBDb21wYXJlIGdldE1hbmFnZWRDaGlsZEluZm9cbiAgICAvLyBUT0RPOiBUaGUgcHJpbWFyeSB1c2UgZm9yIHRoaXMgaXMgZmxhZ2dhYmxlIGNsb3Nlc3QgZml0c1xuICAgIC8vIHdoaWNoIG5lZWQgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgYmV0dGVyIGZvciB0aGF0LlxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEkpID0+IHZvaWQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikgeyBmKGNoaWxkKTsgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIGluIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZDogSSB8IHVuZGVmaW5lZCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2ZpZWxkIGFzIGtleW9mIFJlY29yZDxJW1wiaW5kZXhcIl0sIEk+XTtcbiAgICAgICAgICAgIGlmIChjaGlsZClcbiAgICAgICAgICAgICAgICBmKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgLy8gUmV0cmlldmVzIHRoZSBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIGNoaWxkIHdpdGggdGhlIGdpdmVuIGluZGV4LlxuICAgIC8vIGB1bmRlZmluZWRgIGlmIG5vdCBjaGlsZCB0aGVyZSwgb3IgaXQncyB1bm1vdW50ZWQuXG4gICAgY29uc3QgZ2V0TWFuYWdlZENoaWxkSW5mbyA9IHVzZUNhbGxiYWNrPFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8ST5bXCJjaGlsZHJlblwiXVtcImdldEF0XCJdPigoaW5kZXg6IElbXCJpbmRleFwiXSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5kZXggYXMgbnVtYmVyXSE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tpbmRleCBhcyBJW1wiaW5kZXhcIl1dITtcbiAgICB9LCBbXSlcblxuICAgIC8vIHRsO2RyIHRoaXMgaXMgYSB3YXkgdG8gaGF2ZSBydW4gdXNlTGF5b3V0RWZmZWN0IG9uY2UgYWZ0ZXIgYWxsIE4gY2hpbGRyZW5cbiAgICAvLyBoYXZlIG1vdW50ZWQgYW5kIHJ1biAqdGhlaXIqIHVzZUxheW91dEVmZmVjdCwgYnV0IGFsc28gKndpdGhvdXQqIHJlLXJlbmRlcmluZ1xuICAgIC8vIG91cnNlbHZlcyBiZWNhdXNlIG9mIGhhdmluZyBhIGBjaGlsZENvdW50YCBzdGF0ZSBvciBhbnl0aGluZyBzaW1pbGFyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgY2hpbGQgY291bnQgcmVmIHVwZGF0ZXMsIHdlIHdhbnQgdGhlIHBhcmVudCB0byBhbHNvIHJ1biBhbiBlZmZlY3RcbiAgICAvLyB0byBtYXliZSBkbyBzb21ldGhpbmcgd2l0aCBhbGwgdGhlc2UgY2hpbGRyZW4gdGhhdCBqdXN0IG1vdW50ZWQuXG4gICAgLy8gVGhlIGVhc2llc3Qgd2F5IHdvdWxkIGJlIHVzZUVmZmVjdCguLi4sIFtjaGlsZENvdW50XSkgYnV0XG4gICAgLy8gdGhhdCB3b3VsZCByZXF1aXJlIHVzIGhhdmluZyBhIGNoaWxkQ291bnQgc3RhdGUsIHRoZW4gY2FsbGluZ1xuICAgIC8vIHNldENoaWxkQ291bnQgYW5kIHJlLXJlbmRlcmluZyBldmVyeSB0aW1lIGNoaWxkcmVuIG1vdW50XG4gICAgLy8gKG9ubHkgb25lIHJlLXJlbmRlciBhdCBhIHRpbWUgdW5sZXNzIGNoaWxkcmVuIGFyZSBzdGFnZ2VyZWQsIGJ1dCBzdGlsbClcbiAgICAvLyBcbiAgICAvLyBBcyBhbiBhbHRlcm5hdGUgc29sdXRpb24sIGFueSB0aW1lIGEgY2hpbGQgdXNlcyBVTEUgb24gbW91bnQsIGl0IHF1ZXVlcyBhIG1pY3JvdGFza1xuICAgIC8vIHRvIGVtdWxhdGUgcnVubmluZyBVTEUgb24gdGhlIHBhcmVudC4gT25seSB0aGUgZmlyc3QgY2hpbGQgd2lsbCBhY3R1YWxseSBxdWV1ZVxuICAgIC8vIHRoZSBtaWNyb3Rhc2sgKGJ5IGNoZWNraW5nIGhhc1JlbW90ZVVMRSBmaXJzdCkgc28gdGhhdCB0aGUgXCJlZmZlY3RcIiBvbmx5XG4gICAgLy8gcnVucyBvbmNlLiBXaGVuIGl0J3MgZG9uZSwgaGFzUmVtb3RlVUxFIGlzIHJlc2V0IHNvIGl0IGNhbiBydW4gYWdhaW4gaWZcbiAgICAvLyBtb3JlIGNoaWxkcmVuIG1vdW50L3VubW91bnQuXG4gICAgY29uc3QgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlUmVmPHsgbW91bnRzOiBTZXQ8SVtcImluZGV4XCJdPiwgdW5tb3VudHM6IFNldDxJW1wiaW5kZXhcIl0+IH0gfCBudWxsPihudWxsKTtcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzID0gdXNlUmVmKG5ldyBTZXQ8SVtcImluZGV4XCJdPigpKTtcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IElbXCJpbmRleFwiXSkgPT4ge1xuXG4gICAgICAgIGlmIChyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuc2l6ZSA9PSAwKSB7XG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Py4ocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmFkZChpbmRleCk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcblxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkTW91bnRlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogSVtcImluZGV4XCJdLCBtb3VudGVkOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmICghaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIG1vdW50czogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIHVubW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50IS5tb3VudHMsIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50IS51bm1vdW50cylcbiAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbW91bnRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tpbmRleCBhcyBJW1wiaW5kZXhcIl1dO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnRbbW91bnRlZCA/IFwibW91bnRzXCIgOiBcInVubW91bnRzXCJdLmFkZChpbmRleCk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG5cbiAgICBjb25zdCB1c2VNYW5hZ2VkQ2hpbGQ6IFVzZU1hbmFnZWRDaGlsZDxJPiA9IHVzZUNhbGxiYWNrKCh7IGluZm8gfTogeyBpbmZvOiBNYW5hZ2VkQ2hpbGRJbmZvTmVlZGVkPEk+IH0pID0+IHtcbiAgICAgICAgLy8gQW55IHRpbWUgb3VyIGNoaWxkIHByb3BzIGNoYW5nZSwgbWFrZSB0aGF0IGluZm9ybWF0aW9uIGF2YWlsYWJsZVxuICAgICAgICAvLyB0aGUgcGFyZW50IGlmIHRoZXkgbmVlZCBpdC5cbiAgICAgICAgLy8gVGhlIHBhcmVudCBjYW4gbGlzdGVuIGZvciBhbGwgdXBkYXRlcyBhbmQgb25seSBhY3Qgb24gdGhlIG9uZXMgaXQgY2FyZXMgYWJvdXQsXG4gICAgICAgIC8vIGFuZCBtdWx0aXBsZSBjaGlsZHJlbiB1cGRhdGluZyBpbiB0aGUgc2FtZSB0aWNrIHdpbGwgYWxsIGJlIHNlbnQgYXQgb25jZS5cbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGlzIGluZm9ybWF0aW9uIGluLXBsYWNlXG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZm8uaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmZvLmluZGV4IGFzIG51bWJlcl0gPSB7IC4uLmluZm8gfSBhcyB1bmtub3duIGFzIEk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5mby5pbmRleCBhcyBJW1wiaW5kZXhcIl1dID0geyAuLi5pbmZvIH0gYXMgdW5rbm93biBhcyBJO1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZChpbmZvLmluZGV4IGFzIElbXCJpbmRleFwiXSk7XG4gICAgICAgIH0sIFsuLi5PYmplY3QuZW50cmllcyhpbmZvKS5mbGF0KCldKTtcblxuICAgICAgICAvLyBXaGVuIHdlIG1vdW50LCBub3RpZnkgdGhlIHBhcmVudCB2aWEgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgLy8gKGV2ZXJ5IGNoaWxkIGRvZXMgdGhpcywgc28gZXZlcnl0aGluZydzIGNvb3JkaW5hdGVkIHRvIG9ubHkgcXVldWUgYSBzaW5nbGUgbWljcm90YXNrIHBlciB0aWNrKVxuICAgICAgICAvLyBEbyB0aGUgc2FtZSBvbiB1bm1vdW50LlxuICAgICAgICAvLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgY29tZXMgQUZURVIgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkXG4gICAgICAgIC8vIHNvIHRoYXQgcmVtb3RlVUxFQ2hpbGRNb3VudGVkIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSBpbmZvIG9uIG1vdW50LlxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZm8uaW5kZXggYXMgSVtcImluZGV4XCJdLCB0cnVlKTtcbiAgICAgICAgfSwgW2luZm8uaW5kZXhdKTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbiA9IHVzZVJlZjxNYW5hZ2VkQ2hpbGRyZW48ST4+KHtcbiAgICAgICAgLi4ueyBfOiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50IH0gYXMge30sIGZvckVhY2g6IGZvckVhY2hDaGlsZCwgZ2V0QXQ6IGdldE1hbmFnZWRDaGlsZEluZm8sIGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdEluZGV4LCBzbGljZVNvcnQ6IChjb21wYXJlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc2xpY2UoKS5zb3J0KGNvbXBhcmUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VNYW5hZ2VkQ2hpbGQsXG4gICAgICAgIGNoaWxkcmVuOiBtYW5hZ2VkQ2hpbGRyZW4uY3VycmVudFxuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8SyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIEZsYWdnYWJsZUNoaWxkSW5mb0Jhc2U8Sz4+IHtcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIGNoaWxkIGlzIGNvbnNpZGVyZWQgYWN0aXZlIG9uIG1vdW50LlxuICAgICAqIFxuICAgICAqIEFmdGVyIG1vdW50LCBjaGFuZ2UgdGhlIGN1cnJlbnQgYWN0aXZlIGNoaWxkIHdpdGggYGNoYW5nZUluZGV4YC5cbiAgICAgKi9cbiAgICBpbml0aWFsSW5kZXg6IElbXCJpbmRleFwiXSB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHByb3ZpZGVkLCBpZiB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXggZG9lc24ndCBtYXAgb250byBhbnlcbiAgICAgKiBwcm92aWRlZCBjaGlsZCAoZWl0aGVyIGJlY2F1c2UgaXQncyB0b28gbGFyZ2Ugb3IgdGhhdCBjaGlsZFxuICAgICAqIGRvZXNuJ3QgZXhpc3QpLCB0aGUgY2xvc2VzdCBjaGlsZCB0byB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXhcbiAgICAgKiB3aWxsIGhhdmUgaXRzIGZsYWcgc2V0IGluc3RlYWQuXG4gICAgICogXG4gICAgICogVXNlIHdpdGggY2F1dGlvbiwgYW5kIGNvbnNpZGVyIGhvdyBhIGNoaWxkIGhhdmluZyBpdHMgZmxhZyBzZXRcbiAgICAgKiB3aGlsZSB0aGUgcGFyZW50IHRoaW5rcyBpdCBzaG91bGRuJ3QgYmUgY291bGQgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICAgIGNsb3Nlc3RGaXQ/OiBib29sZWFuO1xuXG4gICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxJPjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmRleCBpcyBzZWxlY3RlZC5cbiAgICAgKiBcbiAgICAgKiBOb3RhYmx5LCB0aGUgdmFsdWUgY2FuIGJlIGRpZmZlcmVudCB0aGFuIHdoYXQgd2FzIGNhbGxlZCB3aXRoIGNoYW5nZUluZGV4KClcbiAgICAgKiBpZiB0aGUgcmVxdWVzdGVkIGluZGV4IGRpZG4ndCBleGlzdCBvciB3YXMgaGlkZGVuLlxuICAgICAqL1xuICAgIG9uSW5kZXhDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxJW1wiaW5kZXhcIl0gfCBudWxsPjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2hpbGRyZW4gaGF2ZSBtdWx0aXBsZSBmbGFncywgdGhlIGBrZXlgIHBhcmFtZXRlciBjb250cm9scyB3aGljaCBmbGFnIHdlJ3JlIGNoZWNraW5nLlxuICAgICAqIFxuICAgICAqIFRoaXMgY2FuIGJlIGFueXRoaW5nIHlvdSB3YW50LCBidXQgbXVzdCBub3QgY2hhbmdlLlxuICAgICAqL1xuICAgIGtleTogSztcblxuICAgIGZpdE51bGxUb1plcm8/OiBib29sZWFuO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hpbGRGbGFnT3BlcmF0aW9ucyB7XG5cbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB3aGV0aGVyIHRoZSBjdXJyZW50IGNoaWxkIGlzIGFjdGl2ZVxuICAgICAqL1xuICAgIGdldDogKCkgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hpbGQgbXVzdCBzZXQgaXRzZWxmIGFzIGFjdGl2ZS9pbmFjdGl2ZSwgd2hhdGV2ZXIgdGhhdCBlbnRhaWxzLlxuICAgICAqIFRoaXMgY291bGQgYmUgYXMgc2ltcGxlIGFzIGEgc2V0U3RhdGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc2V0OiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuIHRydWUgaWYgdGhpcyBjaGlsZCBpcyBhIHZhbGlkIGNhbmRpZGF0ZSB0byBiZSBmbGFnZ2VkLCBhbmQgZmFsc2UgaWYgbm90LlxuICAgICAqIE1vc3QgY2hpbGRyZW4gc2hvdWxkIHJldHVybiB0cnVlLiBSZXR1cm5pbmcgZmFsc2UgaXMgb25seSB1c2VmdWwgdG8gbWFyayBhIGNoaWxkIGFzIFwiaW52YWxpZFwiIGluIHNvbWUgd2F5LlxuICAgICAqIFJlbW92aW5nIGEgY2hpbGQgZnJvbSB0aGUgbGlzdCBkb2VzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nLCBidXQgdGhpcyBsZXRzIHlvdSBrZWVwIHRoZSBjaGlsZCBhcm91bmQuXG4gICAgICovXG4gICAgaXNWYWxpZCgpOiBib29sZWFuO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgRmxhZ2dhYmxlQ2hpbGRJbmZvQmFzZTxLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm9CYXNlPG51bWJlcj4ge1xuICAgIGZsYWdzOiBQYXJ0aWFsPFJlY29yZDxLLCBDaGlsZEZsYWdPcGVyYXRpb25zPj5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdSZXR1cm5UeXBlPEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBGbGFnZ2FibGVDaGlsZEluZm9CYXNlPEs+PiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBjaGFuZ2VJbmRleDogKGFyZzogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdKSA9PiBudW1iZXIgfCBudWxsO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiAobW91bnRlZDogU2V0PElbXCJpbmRleFwiXT4sIHVubW91bnRlZDogU2V0PElbXCJpbmRleFwiXT4pID0+IHZvaWQ7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRDdXJyZW50SW5kZXg6ICgpID0+IG51bWJlciB8IG51bGw7XG59XG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIHRvIHVzZU1hbmFnZWRDaGlsZHJlbiB0aGF0IGhhbmRsZXMgdGhlIGZvbGxvd2luZyBjb21tb24gY2FzZTpcbiAqIDEuIFlvdSBoYXZlIGEgYnVuY2ggb2YgY2hpbGRyZW5cbiAqIDIuIEF0IGFueSBnaXZlbiB0aW1lLCBvbmx5IDEgb2YgdGhlbSBpcyBcInNlbGVjdGVkXCIsIFwiYWN0aXZhdGVkXCIsIFwiZm9jdXNhYmxlXCIsIHdoYXRldmVyIChvciAwIG9mIHRoZW0sIHRoYXQncyBjb29sIHRvbywganVzdCAwIG9yIDEgdGhvdWdoKS5cbiAqIDMuIFRoZSBwYXJlbnQgaGFzIGNvbnRyb2wgb3ZlciB3aG8gaXMgXCJzZWxlY3RlZFwiIHZpYSBhIG51bWVyaWNhbCBpbmRleC5cbiAqIFxuICogVGhpcyBob29rIGFsbG93cyBmb3IgbXVjaCBlYXNpZXIgY29udHJvbCBvdmVyIHNlbGVjdGlvbiBtYW5hZ2VtZW50LlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxLIGV4dGVuZHMgc3RyaW5nLCBJIGV4dGVuZHMgRmxhZ2dhYmxlQ2hpbGRJbmZvQmFzZTxLPj4oeyBjaGlsZHJlbiwgaW5pdGlhbEluZGV4LCBjbG9zZXN0Rml0LCBvbkluZGV4Q2hhbmdlLCBrZXksIGZpdE51bGxUb1plcm8gfTogVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxLLCBJPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGU8SywgST4ge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUNoaWxkcmVuRmxhZ1wiLCBjbG9zZXN0Rml0LCBvbkluZGV4Q2hhbmdlLCBrZXkpO1xuXG4gICAgY29uc3QgW2dldEN1cnJlbnRJbmRleCwgc2V0Q3VycmVudEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgbnVtYmVyPihvbkluZGV4Q2hhbmdlLCB1c2VDYWxsYmFjaygoKSA9PiAoaW5pdGlhbEluZGV4ID8/IChmaXROdWxsVG9aZXJvID8gMCA6IG51bGwpKSwgW10pKTtcblxuICAgIGNvbnN0IFtnZXRSZXF1ZXN0ZWRJbmRleCwgc2V0UmVxdWVzdGVkSW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBudW1iZXI+KG51bGwsIHVzZUNhbGxiYWNrKCgpID0+IChpbml0aWFsSW5kZXggPz8gKGZpdE51bGxUb1plcm8gPyAwIDogbnVsbCkpLCBbXSkpO1xuXG4gICAgY29uc3QgZ2V0Rml0TnVsbFRvWmVybyA9IHVzZVN0YWJsZUdldHRlcihmaXROdWxsVG9aZXJvKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSBhbmQgY2hhbmdlSW5kZXgsIG5vdCBwdWJsaWMgKGJ1dCBjb3VsZCBiZSBJIGd1ZXNzKVxuICAgIGNvbnN0IGdldENsb3Nlc3RGaXQgPSB1c2VDYWxsYmFjaygocmVxdWVzdGVkSW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBjbG9zZXN0SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5mbGFnc1trZXldIS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKGNoaWxkLmluZGV4IC0gcmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIGNoaWxkLmluZGV4IDwgcmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBjaGlsZC5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAxLiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGNoaWxkIHVubW91bnRlZFxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxuICAgIGNvbnN0IG9uQ2hpbGRyZW5Nb3VudENoYW5nZSA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8ST5bXCJvbkNoaWxkcmVuTW91bnRDaGFuZ2VcIl0+PigobW91bnRlZCwgdW5tb3VudGVkKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gZ2V0UmVxdWVzdGVkSW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgLy8gV2UndmUgbm90IGFjdHVhbGx5IHNlbGVjdGVkIG91ciByZXF1ZXN0ZWQgc2VsZWN0aW9uLlxuICAgICAgICAvLyBNYXliZSBvbmUgb2YgdGhlIGNoaWxkcmVuIHRoYXQganVzdCBtb3VudGVkIGhhcyBpdD9cbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCAhPSByZXF1ZXN0ZWRJbmRleCAmJiByZXF1ZXN0ZWRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobW91bnRlZC5oYXMocmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENoaWxkPy5mbGFnc1trZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KHJlcXVlc3RlZEluZGV4KT8uZmxhZ3Nba2V5XSEuc2V0KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRJbmRleCAhPSBudWxsICYmIHVubW91bnRlZC5oYXMoY3VycmVudEluZGV4KSkge1xuICAgICAgICAgICAgLy8gV2hhdGV2ZXIncyBjdXJyZW50bHkgc2VsZWN0ZWQgaGFzIG11c3QgdW5tb3VudGVkLlxuICAgICAgICAgICAgY3VycmVudENoaWxkPy5mbGFnc1trZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCFjbG9zZXN0Rml0IHx8IHJlcXVlc3RlZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgaW4gYmVzdC1maXQgbW9kZSwgb3IgdGhlcmUncyBubyBpbmRleCBiZWluZyBhY3RpdmVseSByZXF1ZXN0ZWQsXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBvdXIgY3VycmVudGx5IGFjdGl2YXRlZCBjaGlsZCB1bm1vdW50aW5nIGp1c3QgbWVhbnMgd2UsIHRvIGJlIHNhZmUsXG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBpdCB0byBkZS1zZWxlY3QgaXRzZWxmLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgaW4gYmVzdC1maXQgbW9kZSwgdGhlbiB0cnkgdG8gZmluZCBhbm90aGVyXG4gICAgICAgICAgICAgICAgLy8gY2hpbGQgdG8gc2VsZWN0LlxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0Q2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY2xvc2VzdEZpdENoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RGaXRDaGlsZC5mbGFnc1trZXldIS5zZXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuXG4gICAgY29uc3QgY2hhbmdlSW5kZXggPSB1c2VDYWxsYmFjaygoYXJnOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0pID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYCR7a2V5fTogY2hhbmdlSW5kZXgoJHthcmd9KWApO1xuICAgICAgICBsZXQgcmVxdWVzdGVkSW5kZXggPSBhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyhnZXRSZXF1ZXN0ZWRJbmRleCgpKSA6IGFyZztcbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwgJiYgZ2V0Rml0TnVsbFRvWmVybygpKVxuICAgICAgICAgICAgcmVxdWVzdGVkSW5kZXggPSAwO1xuXG4gICAgICAgIHNldFJlcXVlc3RlZEluZGV4KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT0gcmVxdWVzdGVkSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkSW5kZXg7XG5cbiAgICAgICAgbGV0IG5ld01hdGNoaW5nQ2hpbGQgPSAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChyZXF1ZXN0ZWRJbmRleCkpO1xuICAgICAgICBjb25zdCBvbGRNYXRjaGluZ0NoaWxkID0gKGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCkpO1xuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRWFzeSBjYXNlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtrZXl9OiBTZXR0aW5nICMke2N1cnJlbnRJbmRleH0gdG8gZmFsc2UgKG51bGwpYCk7XG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgobnVsbCk7XG4gICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFnc1trZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobmV3TWF0Y2hpbmdDaGlsZCAmJiBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzW2tleV0hLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke2tleX06IFNldHRpbmcgIyR7Y3VycmVudEluZGV4fSB0byBmYWxzZSBhbmQgIyR7cmVxdWVzdGVkSW5kZXh9IHRvIHRydWVgKTtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgbmV3TWF0Y2hpbmdDaGlsZC5mbGFnc1trZXldIS5zZXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQobmV3TWF0Y2hpbmdDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtrZXl9OiBTZXR0aW5nICMke2N1cnJlbnRJbmRleH0gdG8gZmFsc2UgYW5kICMke2Nsb3Nlc3RGaXRJbmRleH0gdG8gdHJ1ZSAoY2xvc2VzdCBmaXQpYCk7XG4gICAgICAgICAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3Nba2V5XSEuc2V0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VzdEZpdEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3Nba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGluaXRpYWxJbmRleCAhPSBudWxsKVxuICAgICAgICAgICAgY2hpbGRyZW4uZ2V0QXQoaW5pdGlhbEluZGV4KT8uZmxhZ3Nba2V5XT8uc2V0KHRydWUpO1xuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIHsgY2hhbmdlSW5kZXgsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgZ2V0Q3VycmVudEluZGV4IH07XG59XG4iLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9jdW1lbnQoZWxlbWVudD86IE5vZGUpIHsgcmV0dXJuIChlbGVtZW50Py5vd25lckRvY3VtZW50ID8/IGRvY3VtZW50ID8/IHdpbmRvdy5kb2N1bWVudCA/PyBnbG9iYWxUaGlzLmRvY3VtZW50KTsgfVxuXG50eXBlIFAgPSBQYXJhbWV0ZXJzPHR5cGVvZiBjbHN4PjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURvY3VtZW50Q2xhc3MoY2xhc3NOYW1lOiBQWzBdLCBhY3RpdmU/OiBib29sZWFuLCBlbGVtZW50PzogSFRNTEVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID8/PSBnZXREb2N1bWVudCgpLmRvY3VtZW50RWxlbWVudDtcbiAgICBjbGFzc05hbWUgPSBjbHN4KGNsYXNzTmFtZSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lIGFzIHN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGVsZW1lbnQhLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lIGFzIHN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sIFtjbGFzc05hbWUsIGFjdGl2ZSwgZWxlbWVudF0pO1xuXG59XG4iLCJpbXBvcnQgeyBoLCBQcmVhY3RET01BdHRyaWJ1dGVzIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB1c2VkIHRvIHNlbGVjdCAqanVzdCogdGhlIHR5cGVkIGFkZEV2ZW50TGlzdGVuZXIgXHJcbiAqIGFuZCBub3QgdGhlIGdlbmVyaWMgXCJJJ2xsIGFjY2VwdCBhbnkgc3RyaW5nIGFuZCBhbnkgaGFuZGxlclwiIG9uZS5cclxuICogXHJcbiAqIFRPRE86IFRoaXMgXCJcIlwid29ya3NcIlwiXCIgYnV0IGl0J3Mgbm90IGdyZWF0IGFuZCBpbXBsaWNpdGx5IHJlbGllcyBvblxyXG4gKiBsaWIuZG9tLnRzIGFsd2F5cyBnaXZlaW5nIHRoZSB0d28gb3ZlcmxvYWRzIGluIHRoZSBzYW1lIG9yZGVyLCB3aXRoIHRoZVxyXG4gKiB0eXBlZCBvbmUgZmlyc3QuICpUaGF0KiBwcm9iYWJseSB3b24ndCBjaGFuZ2UsIGJ1dCBpZiBtb3JlIG92ZXJsb2Fkc1xyXG4gKiBhcmUgZXZlciBhZGRlZCB0aGlzIHdpbGwgbmVlZCBhZGp1c3RtZW50LlxyXG4gKiBcclxuICogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mjc2MTE1NiBmb3IgaG93IHNlbGVjdGluZyB0aGUgY29ycmVjdCBvdmVybG9hZCB3b3Jrcy5cclxuICovXHJcbnR5cGUgRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8VD4gPVxyXG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBpbmZlciBSIH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueSB9ID8gUiA6XHJcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55IH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUikgPT4gYW55ID8gUiA6IFtdO1xyXG5cclxuLy8gR2V0IGp1c3QgdGhlIHR5cGVkIHZlcnNpb24gb2YgYWRkRXZlbnRMaXN0ZW5lciwgaWYgaXQgZXhpc3RzXHJcbnR5cGUgVHlwZWRBZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSAoLi4uYXJnczogRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8KFRbXCJhZGRFdmVudExpc3RlbmVyXCJdKT4pID0+IHZvaWQ7XHJcblxyXG4vLyBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBcImFkZEV2ZW50TGlzdGVuZXJcIiAodGhlIGV2ZW50IHR5cGUgYXMgYSBzdHJpbmcpXHJcbnR5cGUgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPiBleHRlbmRzICgodHlwZTogaW5mZXIgSzIsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSzIgOiBzdHJpbmc7XHJcblxyXG5cclxuLy8gVE9ETzogVGhpcyBpc24ndCBxdWl0ZSBhYmxlIHRvIG5hcnJvdyBkb3duIHRoZSBleGFjdCBldmVudCB0eXBlIGZvciB1bmtub3duIHJlYXNvbnMuXHJcbi8vIEluc3RlYWQgaXQgcmV0dXJucyBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgZXZlbnQgdHlwZXMsIHdoaWNoIGlzLi4uZmluZSwgSSBndWVzcy5cclxuLy8gSSBkb24ndCBrbm93IHdoeSBgaW5mZXIgSGAgaXMgZG9pbmcgdGhhdCB3aGVuIHRoZSB0eXBlIHNob3VsZCBiZSBuYXJyb3dlZCBieSBgVGAgdGhvdWdoLi4uXHJcbi8vIE5vdGUgdGhhdCB0aGUgdHlwZSBwYXJhbWV0ZXIgaXMgc3RpbGwgdXNlZCwgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBuYXJyb3cgZG93biB0aGUgdHlwZSxcclxuLy8gYmVjYXVzZSBvdGhlcndpc2UsIGluc3RlYWQgb2YgYmVpbmcgYSB1bmlvbiBvZiBhbGwgdHlwZXMsIGl0J3MganVzdCBgYW55YFxyXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyPEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVCBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPEU+PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxFPiBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogaW5mZXIgSCwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBOb25OdWxsYWJsZTxIPiA6IG5ldmVyO1xyXG4vLygoVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+ICYgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWQsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpKSBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogKGU6IGluZmVyIEgpID0+IGFueSwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBIIDogRnVuY3Rpb24pIC8qJiAoVCBleHRlbmRzIGtleW9mIEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcD8gR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwW1RdIDogKGU6IEV2ZW50KSA9PiB2b2lkKSovO1xyXG5cclxudHlwZSBQYXJhbWV0ZXJzMjxUIGV4dGVuZHMgKEV2ZW50TGlzdGVuZXJPYmplY3QgfCAoKC4uLmFyZ3M6IGFueSkgPT4gYW55KSk+ID1cclxuICAgIFQgZXh0ZW5kcyBFdmVudExpc3RlbmVyT2JqZWN0ID8gUGFyYW1ldGVyczxUW1wiaGFuZGxlRXZlbnRcIl0+IDpcclxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUCkgPT4gYW55ID8gUCA6IG5ldmVyO1xyXG5cclxuXHJcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFQgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFPj4gPSBQYXJhbWV0ZXJzMjxUeXBlZEV2ZW50SGFuZGxlcjxFLCBUPj5bMF07XHJcblxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBhdHRhY2hpbmcgYW4gZXZlbnQgaGFuZGxlciB0byBhbnkgKm5vbi1QcmVhY3QqIGVsZW1lbnQsIGFuZCByZW1vdmluZyBpdCB3aGVuIHRoZSBjb21wb25lbnQgdXNpbmcgdGhlIGhvb2sgdW5tb3VudHMuIFRoZSBjYWxsYmFjayBkb2VzIG5vdCBuZWVkIHRvIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cclxuICogXHJcbiAqIER1ZSB0byB0eXBpbmcgbGltaXRhdGlvbnMsIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgbGlrZSB0aGlzOlxyXG4gKiBcclxuICogYHVzZUV2ZW50SGFuZGxlcihlbGVtZW50LCBcImlucHV0XCIpPElucHV0RXZlbnQ+KGUgPT4ge30pYFxyXG4gKiBcclxuICogVGhlIHR5cGUgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGJ1dCBuYXJyb3dzIGRvd24gdGhlIHR5cGUgZnJvbSBcImEgdW5pb24gb2YgYWxsIGV2ZW50c1wiIHRvIHdoYXRldmVyIHlvdSBzcGVjaWZ5LCBhbmQgZXJyb3JzIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXHJcbiAqIFxyXG4gKiBUaGVyZSBpcyBhIHNlcGFyYXRlIHZlcnNpb24gdGhhdCBhdHRhY2hlcyBldmVudCBoYW5kbGVycyB0byBhIHNldCBvZiBwcm9wcy4gXHJcbiAqIEl0IHRha2VzIGRpZmZlcmVudCBldmVudCBzdHJpbmcgdHlwZXMgKG9uRXZlbnQgdnMgb25ldmVudCkuXHJcbiAqIFxyXG4gKiBAcGFyYW0gdGFyZ2V0IEEgKm5vbi1QcmVhY3QqIG5vZGUgdG8gYXR0YWNoIHRoZSBldmVudCB0by5cclxuICogQHJldHVybnNcclxuICogKlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdsb2JhbEhhbmRsZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPiwgSCBleHRlbmRzIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8VCwgRXZlbnRUeXBlPj4odGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCAoKGU6IEgpID0+IHZvaWQpLCBvcHRpb25zPzogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdKTogdm9pZCB7XHJcblxyXG4gICAgLy8gTm90ZSB0byBzZWxmOiBUaGUgdHlwaW5nIGRvZXNuJ3QgaW1wcm92ZSBldmVuIGlmIHRoaXMgaXMgc3BsaXQgdXAgaW50byBhIHN1Yi1mdW5jdGlvbi5cclxuICAgIC8vIE5vIG1hdHRlciB3aGF0LCBpdCBzZWVtcyBpbXBvc3NpYmxlIHRvIGdldCB0aGUgaGFuZGxlcidzIGV2ZW50IG9iamVjdCB0eXBlZCBwZXJmZWN0bHkuXHJcbiAgICAvLyBJdCBzZWVtcyBsaWtlIGl0J3MgZ3VhcmFudGVlZCB0byBhbHdheXMgYmUgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIHR1cGVzLlxyXG4gICAgLy8gQWdhaW4sIG5vIG1hdHRlciB3aGF0IGNvbWJpbmF0aW9uIG9mIHN1Yi0gb3Igc3ViLXN1Yi1mdW5jdGlvbnMgdXNlZC5cclxuXHJcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjayhoYW5kbGVyID8/ICgoKSA9PiB7IH0pKSBhcyBFdmVudExpc3RlbmVyO1xyXG4gICAgaWYgKGhhbmRsZXIgPT0gbnVsbClcclxuICAgICAgICBzdGFibGVIYW5kbGVyID0gbnVsbDtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChzdGFibGVIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGFsdGVybmF0aXZlIHdheSB0byBhZGQgYW4gZXZlbnQgaGFuZGxlciB0byBhbiBlbGVtZW50LiBVc2VmdWwgcHJpbWFyaWx5IHdoZW4gaW50ZWdyYXRpbmcgM3JkIHBhcnR5IGxpYnJhcmllcyB0aGF0IGV4cGVjdCBhIGdlbmVyaWMgXCJhZGQgZXZlbnQgaGFuZGxlclwiIGZ1bmN0aW9uLlxyXG4gKiBcclxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHlvdSB0byBtb2RpZnkgYSBzZXQgb2YgcHJvcHMgdG8gYXBwbHkgdGhpcyBoYW5kbGVyLlxyXG4gKiBcclxuICogRm9yIHR5cGluZyByZWFzb25zLCB0aGlzIGZ1bmN0aW9uIGlzIHNwbGl0IGludG8gdHdvLiAgVXNhZ2UgaXMgbGlrZSB0aGUgZm9sbG93aW5nOlxyXG4gKiBcclxuICogYGBgXHJcbiAqIGNvbnN0IHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9ID0gdXNlTG9jYWxFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+KCkoXCJvbk1vdXNlRG93blwiLCBlID0+IHsgIH0pO1xyXG4gKiBjb25zdCBkaXZQcm9wcyA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMocHJvcHMpO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbEhhbmRsZXI8RWxlbWVudFR5cGUgZXh0ZW5kcyAoSFRNTEVsZW1lbnRUYWdOYW1lTWFwW2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcF0gfCBTVkdFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcF0pPigpIHtcclxuICAgIHJldHVybiB1c2VDYWxsYmFjayg8RXZlbnRUeXBlIGV4dGVuZHMgRXhjbHVkZTxrZXlvZiBoLkpTWC5ET01BdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPiwga2V5b2YgUHJlYWN0RE9NQXR0cmlidXRlcz4+KHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogTm9uTnVsbGFibGU8aC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT5bRXZlbnRUeXBlXT4pID0+IHtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhYmxlSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIpO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFbGVtZW50VHlwZT4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEVsZW1lbnRUeXBlPih7IFt0eXBlXTogc3RhYmxlSGFuZGxlciB9IGFzIHsgW0sgaW4gRXZlbnRUeXBlXTogdHlwZW9mIGhhbmRsZXIgfSwgcHJvcHMpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPjtcclxuICAgICAgICB9LCBbdHlwZV0pO1xyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH07XHJcblxyXG4gICAgfSwgW10pO1xyXG59XHJcbiIsImNvbnN0IGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFtcbiAgJ2lucHV0JyxcbiAgJ3NlbGVjdCcsXG4gICd0ZXh0YXJlYScsXG4gICdhW2hyZWZdJyxcbiAgJ2J1dHRvbicsXG4gICdbdGFiaW5kZXhdOm5vdChzbG90KScsXG4gICdhdWRpb1tjb250cm9sc10nLFxuICAndmlkZW9bY29udHJvbHNdJyxcbiAgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0pJyxcbiAgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyxcbiAgJ2RldGFpbHMnLFxuXTtcbmNvbnN0IGNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovIGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJyk7XG5cbmNvbnN0IE5vRWxlbWVudCA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJztcblxuY29uc3QgbWF0Y2hlcyA9IE5vRWxlbWVudFxuICA/IGZ1bmN0aW9uICgpIHt9XG4gIDogRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG5jb25zdCBnZXRSb290Tm9kZSA9XG4gICFOb0VsZW1lbnQgJiYgRWxlbWVudC5wcm90b3R5cGUuZ2V0Um9vdE5vZGVcbiAgICA/IChlbGVtZW50KSA9PiBlbGVtZW50LmdldFJvb3ROb2RlKClcbiAgICA6IChlbGVtZW50KSA9PiBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBjb250YWluZXIgdG8gY2hlY2sgaW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIHRvIGNoZWNrXG4gKiBAcGFyYW0geyhub2RlOiBFbGVtZW50KSA9PiBib29sZWFufSBmaWx0ZXIgZmlsdGVyIGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50W119XG4gKi9cbmNvbnN0IGdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoZWwsIGluY2x1ZGVDb250YWluZXIsIGZpbHRlcikge1xuICBsZXQgY2FuZGlkYXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShcbiAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9yKVxuICApO1xuICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gIH1cbiAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgR2V0U2hhZG93Um9vdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrIGZvciBzaGFkb3cgcm9vdFxuICogQHJldHVybnMge1NoYWRvd1Jvb3R8Ym9vbGVhbn0gU2hhZG93Um9vdCBpZiBhdmFpbGFibGUgb3IgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgc2hhZG93Um9vdCBpcyBhdHRhY2hlZCBidXQgbm90IGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTaGFkb3dSb290RmlsdGVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHNoYWRvd0hvc3ROb2RlIHRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHNoYWRvdyBjb250ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIHNoYWRvdyByb290IGNvdWxkIHBvdGVudGlhbGx5IGNvbnRhaW4gdmFsaWQgY2FuZGlkYXRlcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbmRpZGF0ZXNTY29wZVxuICogQHByb3BlcnR5IHtFbGVtZW50fSBzY29wZSBjb250YWlucyBpbm5lciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge0VsZW1lbnRbXX0gY2FuZGlkYXRlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSXRlcmF0aXZlT3B0aW9uc1xuICogQHByb3BlcnR5IHtHZXRTaGFkb3dSb290fGJvb2xlYW59IGdldFNoYWRvd1Jvb3QgdHJ1ZSBpZiBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkOyBmYWxzeSBpZiBub3Q7XG4gKiAgaWYgYSBmdW5jdGlvbiwgaW1wbGllcyBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkIGFuZCBlaXRoZXIgcmV0dXJucyB0aGUgc2hhZG93IHJvb3Qgb2YgYW4gZWxlbWVudFxuICogIG9yIGEgYm9vbGVhbiBzdGF0aW5nIGlmIGl0IGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgcm9vdFxuICogQHByb3BlcnR5IHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZsYXR0ZW4gaWYgdHJ1ZSB0aGVuIHJlc3VsdCB3aWxsIGZsYXR0ZW4gYW55IENhbmRpZGF0ZXNTY29wZSBpbnRvIHRoZSByZXR1cm5lZCBsaXN0XG4gKiBAcHJvcGVydHkge1NoYWRvd1Jvb3RGaWx0ZXJ9IHNoYWRvd1Jvb3RGaWx0ZXIgZmlsdGVyIHNoYWRvdyByb290cztcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50cyBsaXN0IG9mIGVsZW1lbnQgY29udGFpbmVycyB0byBtYXRjaCBjYW5kaWRhdGVzIGZyb21cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIGxpc3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7SXRlcmF0aXZlT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZXNTY29wZT59XG4gKi9cbmNvbnN0IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseSA9IGZ1bmN0aW9uIChcbiAgZWxlbWVudHMsXG4gIGluY2x1ZGVDb250YWluZXIsXG4gIG9wdGlvbnNcbikge1xuICBjb25zdCBjYW5kaWRhdGVzID0gW107XG4gIGNvbnN0IGVsZW1lbnRzVG9DaGVjayA9IEFycmF5LmZyb20oZWxlbWVudHMpO1xuICB3aGlsZSAoZWxlbWVudHNUb0NoZWNrLmxlbmd0aCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1RvQ2hlY2suc2hpZnQoKTtcbiAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnU0xPVCcpIHtcbiAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNsb3Qgc2NvcGUgKHNsb3QgaXRzZWxmIGNhbm5vdCBiZSBmb2N1c2FibGUpXG4gICAgICBjb25zdCBhc3NpZ25lZCA9IGVsZW1lbnQuYXNzaWduZWRFbGVtZW50cygpO1xuICAgICAgY29uc3QgY29udGVudCA9IGFzc2lnbmVkLmxlbmd0aCA/IGFzc2lnbmVkIDogZWxlbWVudC5jaGlsZHJlbjtcbiAgICAgIGNvbnN0IG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoY29udGVudCwgdHJ1ZSwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5uZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgc2NvcGU6IGVsZW1lbnQsXG4gICAgICAgICAgY2FuZGlkYXRlczogbmVzdGVkQ2FuZGlkYXRlcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNoZWNrIGNhbmRpZGF0ZSBlbGVtZW50XG4gICAgICBjb25zdCB2YWxpZENhbmRpZGF0ZSA9IG1hdGNoZXMuY2FsbChlbGVtZW50LCBjYW5kaWRhdGVTZWxlY3Rvcik7XG4gICAgICBpZiAoXG4gICAgICAgIHZhbGlkQ2FuZGlkYXRlICYmXG4gICAgICAgIG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQpICYmXG4gICAgICAgIChpbmNsdWRlQ29udGFpbmVyIHx8ICFlbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSlcbiAgICAgICkge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBzaGFkb3cgY29udGVudCBpZiBwb3NzaWJsZVxuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9XG4gICAgICAgIGVsZW1lbnQuc2hhZG93Um9vdCB8fFxuICAgICAgICAvLyBjaGVjayBmb3IgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICh0eXBlb2Ygb3B0aW9ucy5nZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgb3B0aW9ucy5nZXRTaGFkb3dSb290KGVsZW1lbnQpKTtcblxuICAgICAgY29uc3QgdmFsaWRTaGFkb3dSb290ID1cbiAgICAgICAgIW9wdGlvbnMuc2hhZG93Um9vdEZpbHRlciB8fCBvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIoZWxlbWVudCk7XG5cbiAgICAgIGlmIChzaGFkb3dSb290ICYmIHZhbGlkU2hhZG93Um9vdCkge1xuICAgICAgICAvLyBhZGQgc2hhZG93IGRvbSBzY29wZSBJSUYgYSBzaGFkb3cgcm9vdCBub2RlIHdhcyBnaXZlbjsgb3RoZXJ3aXNlLCBhbiB1bmRpc2Nsb3NlZFxuICAgICAgICAvLyAgc2hhZG93IGV4aXN0cywgc28gbG9vayBhdCBsaWdodCBkb20gY2hpbGRyZW4gYXMgZmFsbGJhY2sgQlVUIGNyZWF0ZSBhIHNjb3BlIGZvciBhbnlcbiAgICAgICAgLy8gIGNoaWxkIGNhbmRpZGF0ZXMgZm91bmQgYmVjYXVzZSB0aGV5J3JlIGxpa2VseSBzbG90dGVkIGVsZW1lbnRzIChlbGVtZW50cyB0aGF0IGFyZVxuICAgICAgICAvLyAgY2hpbGRyZW4gb2YgdGhlIHdlYiBjb21wb25lbnQgZWxlbWVudCAod2hpY2ggaGFzIHRoZSBzaGFkb3cpLCBpbiB0aGUgbGlnaHQgZG9tLCBidXRcbiAgICAgICAgLy8gIHNsb3R0ZWQgc29tZXdoZXJlIF9pbnNpZGVfIHRoZSB1bmRpc2Nsb3NlZCBzaGFkb3cpIC0tIHRoZSBzY29wZSBpcyBjcmVhdGVkIGJlbG93LFxuICAgICAgICAvLyAgX2FmdGVyXyB3ZSByZXR1cm4gZnJvbSB0aGlzIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgIGNvbnN0IG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoXG4gICAgICAgICAgc2hhZG93Um9vdCA9PT0gdHJ1ZSA/IGVsZW1lbnQuY2hpbGRyZW4gOiBzaGFkb3dSb290LmNoaWxkcmVuLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goLi4ubmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3BlOiBlbGVtZW50LFxuICAgICAgICAgICAgY2FuZGlkYXRlczogbmVzdGVkQ2FuZGlkYXRlcyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlcmUncyBub3Qgc2hhZG93IHNvIGp1c3QgZGlnIGludG8gdGhlIGVsZW1lbnQncyAobGlnaHQgZG9tKSBjaGlsZHJlblxuICAgICAgICAvLyAgX193aXRob3V0X18gZ2l2aW5nIHRoZSBlbGVtZW50IHNwZWNpYWwgc2NvcGUgdHJlYXRtZW50XG4gICAgICAgIGVsZW1lbnRzVG9DaGVjay51bnNoaWZ0KC4uLmVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbmNvbnN0IGdldFRhYmluZGV4ID0gZnVuY3Rpb24gKG5vZGUsIGlzU2NvcGUpIHtcbiAgaWYgKG5vZGUudGFiSW5kZXggPCAwKSB7XG4gICAgLy8gaW4gQ2hyb21lLCA8ZGV0YWlscy8+LCA8YXVkaW8gY29udHJvbHMvPiBhbmQgPHZpZGVvIGNvbnRyb2xzLz4gZWxlbWVudHMgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgLTEgd2hlbiB0aGUgJ3RhYmluZGV4JyBhdHRyaWJ1dGUgaXNuJ3Qgc3BlY2lmaWVkIGluIHRoZSBET00sXG4gICAgLy8geWV0IHRoZXkgYXJlIHN0aWxsIHBhcnQgb2YgdGhlIHJlZ3VsYXIgdGFiIG9yZGVyOyBpbiBGRiwgdGhleSBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAwOyBzaW5jZSBDaHJvbWUgc3RpbGwgcHV0cyB0aG9zZSBlbGVtZW50cyBpbiB0aGUgcmVndWxhciB0YWJcbiAgICAvLyBvcmRlciwgY29uc2lkZXIgdGhlaXIgdGFiIGluZGV4IHRvIGJlIDAuXG4gICAgLy8gQWxzbyBicm93c2VycyBkbyBub3QgcmV0dXJuIGB0YWJJbmRleGAgY29ycmVjdGx5IGZvciBjb250ZW50RWRpdGFibGUgbm9kZXM7XG4gICAgLy8gc28gaWYgdGhleSBkb24ndCBoYXZlIGEgdGFiaW5kZXggYXR0cmlidXRlIHNwZWNpZmljYWxseSBzZXQsIGFzc3VtZSBpdCdzIDAuXG4gICAgLy9cbiAgICAvLyBpc1Njb3BlIGlzIHBvc2l0aXZlIGZvciBjdXN0b20gZWxlbWVudCB3aXRoIHNoYWRvdyByb290IG9yIHNsb3QgdGhhdCBieSBkZWZhdWx0XG4gICAgLy8gaGF2ZSB0YWJJbmRleCAtMSwgYnV0IG5lZWQgdG8gYmUgc29ydGVkIGJ5IGRvY3VtZW50IG9yZGVyIGluIG9yZGVyIGZvciB0aGVpclxuICAgIC8vIGNvbnRlbnQgdG8gYmUgaW5zZXJ0ZWQgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb25cbiAgICBpZiAoXG4gICAgICAoaXNTY29wZSB8fFxuICAgICAgICAvXihBVURJT3xWSURFT3xERVRBSUxTKSQvLnRlc3Qobm9kZS50YWdOYW1lKSB8fFxuICAgICAgICBub2RlLmlzQ29udGVudEVkaXRhYmxlKSAmJlxuICAgICAgaXNOYU4ocGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKSlcbiAgICApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlLnRhYkluZGV4O1xufTtcblxuY29uc3Qgc29ydE9yZGVyZWRUYWJiYWJsZXMgPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gYS50YWJJbmRleCA9PT0gYi50YWJJbmRleFxuICAgID8gYS5kb2N1bWVudE9yZGVyIC0gYi5kb2N1bWVudE9yZGVyXG4gICAgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn07XG5cbmNvbnN0IGlzSW5wdXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU5QVVQnO1xufTtcblxuY29uc3QgaXNIaWRkZW5JbnB1dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ2hpZGRlbic7XG59O1xuXG5jb25zdCBpc0RldGFpbHNXaXRoU3VtbWFyeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGNvbnN0IHIgPVxuICAgIG5vZGUudGFnTmFtZSA9PT0gJ0RFVEFJTFMnICYmXG4gICAgQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAuYXBwbHkobm9kZS5jaGlsZHJlbilcbiAgICAgIC5zb21lKChjaGlsZCkgPT4gY2hpbGQudGFnTmFtZSA9PT0gJ1NVTU1BUlknKTtcbiAgcmV0dXJuIHI7XG59O1xuXG5jb25zdCBnZXRDaGVja2VkUmFkaW8gPSBmdW5jdGlvbiAobm9kZXMsIGZvcm0pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkICYmIG5vZGVzW2ldLmZvcm0gPT09IGZvcm0pIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGlzVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghbm9kZS5uYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcmFkaW9TY29wZSA9IG5vZGUuZm9ybSB8fCBnZXRSb290Tm9kZShub2RlKTtcbiAgY29uc3QgcXVlcnlSYWRpb3MgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiByYWRpb1Njb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAnaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCInICsgbmFtZSArICdcIl0nXG4gICAgKTtcbiAgfTtcblxuICBsZXQgcmFkaW9TZXQ7XG4gIGlmIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuQ1NTICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuQ1NTLmVzY2FwZSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKHdpbmRvdy5DU1MuZXNjYXBlKG5vZGUubmFtZSkpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKG5vZGUubmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLFxuICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjaGVja2VkID0gZ2V0Q2hlY2tlZFJhZGlvKHJhZGlvU2V0LCBub2RlLmZvcm0pO1xuICByZXR1cm4gIWNoZWNrZWQgfHwgY2hlY2tlZCA9PT0gbm9kZTtcbn07XG5cbmNvbnN0IGlzUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdyYWRpbyc7XG59O1xuXG5jb25zdCBpc05vblRhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNSYWRpbyhub2RlKSAmJiAhaXNUYWJiYWJsZVJhZGlvKG5vZGUpO1xufTtcblxuY29uc3QgaXNaZXJvQXJlYSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMDtcbn07XG5jb25zdCBpc0hpZGRlbiA9IGZ1bmN0aW9uIChub2RlLCB7IGRpc3BsYXlDaGVjaywgZ2V0U2hhZG93Um9vdCB9KSB7XG4gIC8vIE5PVEU6IHZpc2liaWxpdHkgd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBub2RlIGlzIGRldGFjaGVkIGZyb20gdGhlIGRvY3VtZW50XG4gIC8vICAoc2VlIG5vdGVzIGFib3V0IHRoaXMgZnVydGhlciBkb3duKSwgd2hpY2ggbWVhbnMgd2Ugd2lsbCBjb25zaWRlciBpdCB2aXNpYmxlXG4gIC8vICAodGhpcyBpcyBsZWdhY3kgYmVoYXZpb3IgZnJvbSBhIHZlcnkgbG9uZyB3YXkgYmFjaylcbiAgLy8gTk9URTogd2UgY2hlY2sgdGhpcyByZWdhcmRsZXNzIG9mIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIGJlY2F1c2UgdGhpcyBpcyBhXG4gIC8vICBfdmlzaWJpbGl0eV8gY2hlY2ssIG5vdCBhIF9kaXNwbGF5XyBjaGVja1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgaXNEaXJlY3RTdW1tYXJ5ID0gbWF0Y2hlcy5jYWxsKG5vZGUsICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScpO1xuICBjb25zdCBub2RlVW5kZXJEZXRhaWxzID0gaXNEaXJlY3RTdW1tYXJ5ID8gbm9kZS5wYXJlbnRFbGVtZW50IDogbm9kZTtcbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlVW5kZXJEZXRhaWxzLCAnZGV0YWlsczpub3QoW29wZW5dKSAqJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRoZSByb290IG5vZGUgaXMgdGhlIHNoYWRvdyByb290IGlmIHRoZSBub2RlIGlzIGluIGEgc2hhZG93IERPTTsgc29tZSBkb2N1bWVudCBvdGhlcndpc2VcbiAgLy8gIChidXQgTk9UIF90aGVfIGRvY3VtZW50OyBzZWUgc2Vjb25kICdJZicgY29tbWVudCBiZWxvdyBmb3IgbW9yZSkuXG4gIC8vIElmIHJvb3ROb2RlIGlzIHNoYWRvdyByb290LCBpdCdsbCBoYXZlIGEgaG9zdCwgd2hpY2ggaXMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHNoYWRvd1xuICAvLyAgaXMgYXR0YWNoZWQsIGFuZCB0aGUgb25lIHdlIG5lZWQgdG8gY2hlY2sgaWYgaXQncyBpbiB0aGUgZG9jdW1lbnQgb3Igbm90IChiZWNhdXNlIHRoZVxuICAvLyAgc2hhZG93LCBhbmQgYWxsIG5vZGVzIGl0IGNvbnRhaW5zLCBpcyBuZXZlciBjb25zaWRlcmVkIGluIHRoZSBkb2N1bWVudCBzaW5jZSBzaGFkb3dzXG4gIC8vICBiZWhhdmUgbGlrZSBzZWxmLWNvbnRhaW5lZCBET01zOyBidXQgaWYgdGhlIHNoYWRvdydzIEhPU1QsIHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50LFxuICAvLyAgaXMgaGlkZGVuLCBvciBpcyBub3QgaW4gdGhlIGRvY3VtZW50IGl0c2VsZiBidXQgaXMgZGV0YWNoZWQsIGl0IHdpbGwgYWZmZWN0IHRoZSBzaGFkb3cnc1xuICAvLyAgdmlzaWJpbGl0eSwgaW5jbHVkaW5nIGFsbCB0aGUgbm9kZXMgaXQgY29udGFpbnMpLiBUaGUgaG9zdCBjb3VsZCBiZSBhbnkgbm9ybWFsIG5vZGUsXG4gIC8vICBvciBhIGN1c3RvbSBlbGVtZW50IChpLmUuIHdlYiBjb21wb25lbnQpLiBFaXRoZXIgd2F5LCB0aGF0J3MgdGhlIG9uZSB0aGF0IGlzIGNvbnNpZGVyZWRcbiAgLy8gIHBhcnQgb2YgdGhlIGRvY3VtZW50LCBub3QgdGhlIHNoYWRvdyByb290LCBub3IgYW55IG9mIGl0cyBjaGlsZHJlbiAoaS5lLiB0aGUgbm9kZSBiZWluZ1xuICAvLyAgdGVzdGVkKS5cbiAgLy8gSWYgcm9vdE5vZGUgaXMgbm90IGEgc2hhZG93IHJvb3QsIGl0IHdvbid0IGhhdmUgYSBob3N0LCBhbmQgc28gcm9vdE5vZGUgc2hvdWxkIGJlIHRoZVxuICAvLyAgZG9jdW1lbnQgKHBlciB0aGUgZG9jcykgYW5kIHdoaWxlIGl0J3MgYSBEb2N1bWVudC10eXBlIG9iamVjdCwgdGhhdCBkb2N1bWVudCBkb2VzIG5vdFxuICAvLyAgYXBwZWFyIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBub2RlJ3MgYG93bmVyRG9jdW1lbnRgIGZvciBzb21lIHJlYXNvbiwgc28gaXQncyBzYWZlclxuICAvLyAgdG8gaWdub3JlIHRoZSByb290Tm9kZSBhdCB0aGlzIHBvaW50LCBhbmQgdXNlIGBub2RlLm93bmVyRG9jdW1lbnRgLiBPdGhlcndpc2UsXG4gIC8vICB1c2luZyBgcm9vdE5vZGUuY29udGFpbnMobm9kZSlgIHdpbGwgX2Fsd2F5c18gYmUgdHJ1ZSB3ZSdsbCBnZXQgZmFsc2UtcG9zaXRpdmVzIHdoZW5cbiAgLy8gIG5vZGUgaXMgYWN0dWFsbHkgZGV0YWNoZWQuXG4gIGNvbnN0IG5vZGVSb290SG9zdCA9IGdldFJvb3ROb2RlKG5vZGUpLmhvc3Q7XG4gIGNvbnN0IG5vZGVJc0F0dGFjaGVkID1cbiAgICBub2RlUm9vdEhvc3Q/Lm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZVJvb3RIb3N0KSB8fFxuICAgIG5vZGUub3duZXJEb2N1bWVudC5jb250YWlucyhub2RlKTtcblxuICBpZiAoIWRpc3BsYXlDaGVjayB8fCBkaXNwbGF5Q2hlY2sgPT09ICdmdWxsJykge1xuICAgIGlmICh0eXBlb2YgZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gZmlndXJlIG91dCBpZiB3ZSBzaG91bGQgY29uc2lkZXIgdGhlIG5vZGUgdG8gYmUgaW4gYW4gdW5kaXNjbG9zZWQgc2hhZG93IGFuZCB1c2UgdGhlXG4gICAgICAvLyAgJ25vbi16ZXJvLWFyZWEnIGZhbGxiYWNrXG4gICAgICBjb25zdCBvcmlnaW5hbE5vZGUgPSBub2RlO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBnZXRSb290Tm9kZShub2RlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBhcmVudEVsZW1lbnQgJiZcbiAgICAgICAgICAhcGFyZW50RWxlbWVudC5zaGFkb3dSb290ICYmXG4gICAgICAgICAgZ2V0U2hhZG93Um9vdChwYXJlbnRFbGVtZW50KSA9PT0gdHJ1ZSAvLyBjaGVjayBpZiB0aGVyZSdzIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xuICAgICAgICApIHtcbiAgICAgICAgICAvLyBub2RlIGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgd2hpY2ggbWVhbnMgd2UgY2FuIG9ubHkgdHJlYXQgaXQgYXMgYSBibGFjayBib3gsIHNvIHdlXG4gICAgICAgICAgLy8gIGZhbGwgYmFjayB0byBhIG5vbi16ZXJvLWFyZWEgdGVzdFxuICAgICAgICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gaXRlcmF0ZSB1cCBzbG90XG4gICAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90O1xuICAgICAgICB9IGVsc2UgaWYgKCFwYXJlbnRFbGVtZW50ICYmIHJvb3ROb2RlICE9PSBub2RlLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAvLyBjcm9zcyBzaGFkb3cgYm91bmRhcnlcbiAgICAgICAgICBub2RlID0gcm9vdE5vZGUuaG9zdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIG5vcm1hbCBkb21cbiAgICAgICAgICBub2RlID0gcGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlID0gb3JpZ2luYWxOb2RlO1xuICAgIH1cbiAgICAvLyBlbHNlLCBgZ2V0U2hhZG93Um9vdGAgbWlnaHQgYmUgdHJ1ZSwgYnV0IGFsbCB0aGF0IGRvZXMgaXMgZW5hYmxlIHNoYWRvdyBET00gc3VwcG9ydFxuICAgIC8vICAoaS5lLiBpdCBkb2VzIG5vdCBhbHNvIHByZXN1bWUgdGhhdCBhbGwgbm9kZXMgbWlnaHQgaGF2ZSB1bmRpc2Nsb3NlZCBzaGFkb3dzKTsgb3JcbiAgICAvLyAgaXQgbWlnaHQgYmUgYSBmYWxzeSB2YWx1ZSwgd2hpY2ggbWVhbnMgc2hhZG93IERPTSBzdXBwb3J0IGlzIGRpc2FibGVkXG5cbiAgICAvLyBTaW5jZSB3ZSBkaWRuJ3QgZmluZCBpdCBzaXR0aW5nIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyAob3Igc2hhZG93cyBhcmUgZGlzYWJsZWQpXG4gICAgLy8gIG5vdyB3ZSBjYW4ganVzdCB0ZXN0IHRvIHNlZSBpZiBpdCB3b3VsZCBub3JtYWxseSBiZSB2aXNpYmxlIG9yIG5vdCwgcHJvdmlkZWQgaXQnc1xuICAgIC8vICBhdHRhY2hlZCB0byB0aGUgbWFpbiBkb2N1bWVudC5cbiAgICAvLyBOT1RFOiBXZSBtdXN0IGNvbnNpZGVyIGNhc2Ugd2hlcmUgbm9kZSBpcyBpbnNpZGUgYSBzaGFkb3cgRE9NIGFuZCBnaXZlbiBkaXJlY3RseSB0b1xuICAgIC8vICBgaXNUYWJiYWJsZSgpYCBvciBgaXNGb2N1c2FibGUoKWAgLS0gcmVnYXJkbGVzcyBvZiBgZ2V0U2hhZG93Um9vdGAgb3B0aW9uIHNldHRpbmcuXG5cbiAgICBpZiAobm9kZUlzQXR0YWNoZWQpIHtcbiAgICAgIC8vIHRoaXMgd29ya3Mgd2hlcmV2ZXIgdGhlIG5vZGUgaXM6IGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGNsaWVudCByZWN0LCBpdCdzXG4gICAgICAvLyAgc29tZWhvdyBkaXNwbGF5ZWQ7IGl0IGFsc28gY292ZXJzIHRoZSBDU1MgJ2Rpc3BsYXk6IGNvbnRlbnRzJyBjYXNlIHdoZXJlIHRoZVxuICAgICAgLy8gIG5vZGUgaXRzZWxmIGlzIGhpZGRlbiBpbiBwbGFjZSBvZiBpdHMgY29udGVudHM7IGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoXG4gICAgICAvLyAgdXAgdGhlIGhpZXJhcmNoeSBlaXRoZXJcbiAgICAgIHJldHVybiAhbm9kZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBFbHNlLCB0aGUgbm9kZSBpc24ndCBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoZSBgZ2V0Q2xpZW50UmVjdHMoKWBcbiAgICAvLyAgQVBJIHdpbGwgX19hbHdheXNfXyByZXR1cm4gemVybyByZWN0cyAodGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgUmVhY3RcbiAgICAvLyAgaXMgdXNlZCB0byByZW5kZXIgbm9kZXMgb250byBhIGRldGFjaGVkIHRyZWUsIGFzIGNvbmZpcm1lZCBpbiB0aGlzIHRocmVhZDpcbiAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy85MTE3I2lzc3VlY29tbWVudC0yODQyMjg4NzApXG4gICAgLy9cbiAgICAvLyBJdCBhbHNvIG1lYW5zIHRoYXQgZXZlbiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgLy8gIGJlY2F1c2Ugc3R5bGVzIGFyZSBvbmx5IGNvbXB1dGVkIGZvciBub2RlcyB0aGF0IGFyZSBpbiB0aGUgZG9jdW1lbnQuXG4gICAgLy9cbiAgICAvLyBOT1RFOiBUSElTIEhBUyBCRUVOIFRIRSBDQVNFIEZPUiBZRUFSUy4gSXQgaXMgbm90IG5ldywgbm9yIGlzIGl0IGNhdXNlZCBieSB0YWJiYWJsZVxuICAgIC8vICBzb21laG93LiBUaG91Z2ggaXQgd2FzIG5ldmVyIHN0YXRlZCBvZmZpY2lhbGx5LCBhbnlvbmUgd2hvIGhhcyBldmVyIHVzZWQgdGFiYmFibGVcbiAgICAvLyAgQVBJcyBvbiBub2RlcyBpbiBkZXRhY2hlZCBjb250YWluZXJzIGhhcyBhY3R1YWxseSBpbXBsaWNpdGx5IHVzZWQgdGFiYmFibGUgaW4gd2hhdFxuICAgIC8vICB3YXMgbGF0ZXIgKGFzIG9mIHY1LjIuMCBvbiBBcHIgOSwgMjAyMSkgY2FsbGVkIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIG1vZGUgLS0gZXNzZW50aWFsbHlcbiAgICAvLyAgY29uc2lkZXJpbmcgX19ldmVyeXRoaW5nX18gdG8gYmUgdmlzaWJsZSBiZWNhdXNlIG9mIHRoZSBpbm5hYmlsaXR5IHRvIGRldGVybWluZSBzdHlsZXMuXG4gIH0gZWxzZSBpZiAoZGlzcGxheUNoZWNrID09PSAnbm9uLXplcm8tYXJlYScpIHtcbiAgICAvLyBOT1RFOiBFdmVuIHRob3VnaCB0aGlzIHRlc3RzIHRoYXQgdGhlIG5vZGUncyBjbGllbnQgcmVjdCBpcyBub24temVybyB0byBkZXRlcm1pbmVcbiAgICAvLyAgd2hldGhlciBpdCdzIGRpc3BsYXllZCwgYW5kIHRoYXQgYSBkZXRhY2hlZCBub2RlIHdpbGwgX19hbHdheXNfXyBoYXZlIGEgemVyby1hcmVhXG4gICAgLy8gIGNsaWVudCByZWN0LCB3ZSBkb24ndCBzcGVjaWFsLWNhc2UgZm9yIHdoZXRoZXIgdGhlIG5vZGUgaXMgYXR0YWNoZWQgb3Igbm90LiBJblxuICAgIC8vICB0aGlzIG1vZGUsIHdlIGRvIHdhbnQgdG8gY29uc2lkZXIgbm9kZXMgdGhhdCBoYXZlIGEgemVybyBhcmVhIHRvIGJlIGhpZGRlbiBhdCBhbGxcbiAgICAvLyAgdGltZXMsIGFuZCB0aGF0IGluY2x1ZGVzIGF0dGFjaGVkIG9yIG5vdC5cbiAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgfVxuXG4gIC8vIHZpc2libGUsIGFzIGZhciBhcyB3ZSBjYW4gdGVsbCwgb3IgcGVyIGN1cnJlbnQgYGRpc3BsYXlDaGVja2AgbW9kZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBmb3JtIGZpZWxkcyAobmVzdGVkKSBpbnNpZGUgYSBkaXNhYmxlZCBmaWVsZHNldCBhcmUgbm90IGZvY3VzYWJsZS90YWJiYWJsZVxuLy8gIHVubGVzcyB0aGV5IGFyZSBpbiB0aGUgX2ZpcnN0XyA8bGVnZW5kPiBlbGVtZW50IG9mIHRoZSB0b3AtbW9zdCBkaXNhYmxlZFxuLy8gIGZpZWxkc2V0XG5jb25zdCBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKC9eKElOUFVUfEJVVFRPTnxTRUxFQ1R8VEVYVEFSRUEpJC8udGVzdChub2RlLnRhZ05hbWUpKSB7XG4gICAgbGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgLy8gY2hlY2sgaWYgYG5vZGVgIGlzIGNvbnRhaW5lZCBpbiBhIGRpc2FibGVkIDxmaWVsZHNldD5cbiAgICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgICAgaWYgKHBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ0ZJRUxEU0VUJyAmJiBwYXJlbnROb2RlLmRpc2FibGVkKSB7XG4gICAgICAgIC8vIGxvb2sgZm9yIHRoZSBmaXJzdCA8bGVnZW5kPiBhbW9uZyB0aGUgY2hpbGRyZW4gb2YgdGhlIGRpc2FibGVkIDxmaWVsZHNldD5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnROb2RlLmNoaWxkcmVuLml0ZW0oaSk7XG4gICAgICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgPGxlZ2VuZD4gKGluIGRvY3VtZW50IG9yZGVyKSBpcyBmb3VuZFxuICAgICAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnTEVHRU5EJykge1xuICAgICAgICAgICAgLy8gaWYgaXRzIHBhcmVudCA8ZmllbGRzZXQ+IGlzIG5vdCBuZXN0ZWQgaW4gYW5vdGhlciBkaXNhYmxlZCA8ZmllbGRzZXQ+LFxuICAgICAgICAgICAgLy8gcmV0dXJuIHdoZXRoZXIgYG5vZGVgIGlzIGEgZGVzY2VuZGFudCBvZiBpdHMgZmlyc3QgPGxlZ2VuZD5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwocGFyZW50Tm9kZSwgJ2ZpZWxkc2V0W2Rpc2FibGVkXSAqJylcbiAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgIDogIWNoaWxkLmNvbnRhaW5zKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PiBjb250YWluaW5nIGBub2RlYCBoYXMgbm8gPGxlZ2VuZD5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIGVsc2UsIG5vZGUncyB0YWJiYWJsZS9mb2N1c2FibGUgc3RhdGUgc2hvdWxkIG5vdCBiZSBhZmZlY3RlZCBieSBhIGZpZWxkc2V0J3NcbiAgLy8gIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGVcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBub2RlKSB7XG4gIGlmIChcbiAgICBub2RlLmRpc2FibGVkIHx8XG4gICAgaXNIaWRkZW5JbnB1dChub2RlKSB8fFxuICAgIGlzSGlkZGVuKG5vZGUsIG9wdGlvbnMpIHx8XG4gICAgLy8gRm9yIGEgZGV0YWlscyBlbGVtZW50IHdpdGggYSBzdW1tYXJ5LCB0aGUgc3VtbWFyeSBlbGVtZW50IGdldHMgdGhlIGZvY3VzXG4gICAgaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkgfHxcbiAgICBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBub2RlKSB7XG4gIGlmIChcbiAgICBpc05vblRhYmJhYmxlUmFkaW8obm9kZSkgfHxcbiAgICBnZXRUYWJpbmRleChub2RlKSA8IDAgfHxcbiAgICAhaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlID0gZnVuY3Rpb24gKHNoYWRvd0hvc3ROb2RlKSB7XG4gIGNvbnN0IHRhYkluZGV4ID0gcGFyc2VJbnQoc2hhZG93SG9zdE5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG4gIGlmIChpc05hTih0YWJJbmRleCkgfHwgdGFiSW5kZXggPj0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElmIGEgY3VzdG9tIGVsZW1lbnQgaGFzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIHRhYmluZGV4LFxuICAvLyBicm93c2VycyB3aWxsIG5vdCBhbGxvdyB0YWIgdGFyZ2V0aW5nIHNhaWQgZWxlbWVudCdzIGNoaWxkcmVuLlxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlc1Njb3BlPn0gY2FuZGlkYXRlc1xuICogQHJldHVybnMgRWxlbWVudFtdXG4gKi9cbmNvbnN0IHNvcnRCeU9yZGVyID0gZnVuY3Rpb24gKGNhbmRpZGF0ZXMpIHtcbiAgY29uc3QgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICBjb25zdCBvcmRlcmVkVGFiYmFibGVzID0gW107XG4gIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIGNvbnN0IGlzU2NvcGUgPSAhIWl0ZW0uc2NvcGU7XG4gICAgY29uc3QgZWxlbWVudCA9IGlzU2NvcGUgPyBpdGVtLnNjb3BlIDogaXRlbTtcbiAgICBjb25zdCBjYW5kaWRhdGVUYWJpbmRleCA9IGdldFRhYmluZGV4KGVsZW1lbnQsIGlzU2NvcGUpO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gaXNTY29wZSA/IHNvcnRCeU9yZGVyKGl0ZW0uY2FuZGlkYXRlcykgOiBlbGVtZW50O1xuICAgIGlmIChjYW5kaWRhdGVUYWJpbmRleCA9PT0gMCkge1xuICAgICAgaXNTY29wZVxuICAgICAgICA/IHJlZ3VsYXJUYWJiYWJsZXMucHVzaCguLi5lbGVtZW50cylcbiAgICAgICAgOiByZWd1bGFyVGFiYmFibGVzLnB1c2goZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yZGVyZWRUYWJiYWJsZXMucHVzaCh7XG4gICAgICAgIGRvY3VtZW50T3JkZXI6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVUYWJpbmRleCxcbiAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgaXNTY29wZTogaXNTY29wZSxcbiAgICAgICAgY29udGVudDogZWxlbWVudHMsXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvcmRlcmVkVGFiYmFibGVzXG4gICAgLnNvcnQoc29ydE9yZGVyZWRUYWJiYWJsZXMpXG4gICAgLnJlZHVjZSgoYWNjLCBzb3J0YWJsZSkgPT4ge1xuICAgICAgc29ydGFibGUuaXNTY29wZVxuICAgICAgICA/IGFjYy5wdXNoKC4uLnNvcnRhYmxlLmNvbnRlbnQpXG4gICAgICAgIDogYWNjLnB1c2goc29ydGFibGUuY29udGVudCk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKVxuICAgIC5jb25jYXQocmVndWxhclRhYmJhYmxlcyk7XG59O1xuXG5jb25zdCB0YWJiYWJsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBsZXQgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogZmFsc2UsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgICBzaGFkb3dSb290RmlsdGVyOiBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKFxuICAgICAgZWwsXG4gICAgICBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsXG4gICAgICBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNvcnRCeU9yZGVyKGNhbmRpZGF0ZXMpO1xufTtcblxuY29uc3QgZm9jdXNhYmxlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCBjYW5kaWRhdGVzO1xuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShbZWxdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhcbiAgICAgIGVsLFxuICAgICAgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLFxuICAgICAgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuY29uc3QgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmNvbnN0IGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovIGNhbmRpZGF0ZVNlbGVjdG9yc1xuICAuY29uY2F0KCdpZnJhbWUnKVxuICAuam9pbignLCcpO1xuXG5jb25zdCBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5leHBvcnQgeyB0YWJiYWJsZSwgZm9jdXNhYmxlLCBpc1RhYmJhYmxlLCBpc0ZvY3VzYWJsZSB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdpbmVydCcsIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gICAqIChodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsLzIwMTUvY29weXJpZ2h0LXNvZnR3YXJlLWFuZC1kb2N1bWVudCkuXG4gICAqL1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIHdlJ3JlIG5vdCBydW5uaW5nIGluc2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBOb2RlTGlzdHMuXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICAgKiBAdHlwZSB7dHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXN9XG4gICAgICovXG4gICAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdmFyIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZyA9IFsnYVtocmVmXScsICdhcmVhW2hyZWZdJywgJ2lucHV0Om5vdChbZGlzYWJsZWRdKScsICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJywgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKScsICdidXR0b246bm90KFtkaXNhYmxlZF0pJywgJ2RldGFpbHMnLCAnc3VtbWFyeScsICdpZnJhbWUnLCAnb2JqZWN0JywgJ2VtYmVkJywgJ1tjb250ZW50ZWRpdGFibGVdJ10uam9pbignLCcpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Um9vdGAgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBzdWJ0cmVlLCBpLmUuIGEgRE9NIHN1YnRyZWUgd2hvc2Ugcm9vdCBlbGVtZW50IGhhcyBhbiBgaW5lcnRgXG4gICAgICogYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogSXRzIG1haW4gZnVuY3Rpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgICAqICAgc3VidHJlZS4gVGhlIGBtYWtlU3VidHJlZVVuZm9jdXNhYmxlKClgIG1ldGhvZCBoYW5kbGVzIGNvbGxlY3RpbmcgYEluZXJ0Tm9kZWBzIHZpYSByZWdpc3RlcmluZ1xuICAgICAqICAgZWFjaCBmb2N1c2FibGUgbm9kZSBpbiB0aGUgc3VidHJlZSB3aXRoIHRoZSBzaW5nbGV0b24gYEluZXJ0TWFuYWdlcmAgd2hpY2ggbWFuYWdlcyBhbGwga25vd25cbiAgICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgICAqICAgaW5zdGFuY2UgZXhpc3RzIGZvciBlYWNoIGZvY3VzYWJsZSBub2RlIHdoaWNoIGhhcyBhdCBsZWFzdCBvbmUgaW5lcnQgcm9vdCBhcyBhbiBhbmNlc3Rvci5cbiAgICAgKlxuICAgICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAgICogICBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSByb290IG5vZGUpLiBUaGlzIGlzIGhhbmRsZWQgaW4gdGhlIGRlc3RydWN0b3IsIHdoaWNoIGNhbGxzIHRoZVxuICAgICAqICAgYGRlcmVnaXN0ZXJgIG1ldGhvZCBvbiBgSW5lcnRNYW5hZ2VyYCBmb3IgZWFjaCBtYW5hZ2VkIGluZXJ0IG5vZGUuXG4gICAgICovXG5cbiAgICB2YXIgSW5lcnRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRNYW5hZ2VyfSBpbmVydE1hbmFnZXIgVGhlIGdsb2JhbCBzaW5nbGV0b24gSW5lcnRNYW5hZ2VyIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Um9vdCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydE5vZGU+fVxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBmb2N1c2FibGUgbm9kZXMgaW4gdGhpcyBJbmVydFJvb3QncyBzdWJ0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIE1ha2UgdGhlIHN1YnRyZWUgaGlkZGVuIGZyb20gYXNzaXN0aXZlIHRlY2hub2xvZ3lcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSB0aGlzLl9yb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICAvLyBNYWtlIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIHN1YnRyZWUgdW5mb2N1c2FibGUgYW5kIGFkZCB0aGVtIHRvIF9tYW5hZ2VkTm9kZXNcbiAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSh0aGlzLl9yb290RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgICAvLyAtIGFueSBhZGRpdGlvbnMgaW4gdGhlIHN1YnRyZWU6IG1ha2UgdGhlbSB1bmZvY3VzYWJsZSB0b29cbiAgICAgICAgLy8gLSBhbnkgcmVtb3ZhbHMgZnJvbSB0aGUgc3VidHJlZTogcmVtb3ZlIHRoZW0gZnJvbSB0aGlzIGluZXJ0IHJvb3QncyBtYW5hZ2VkIG5vZGVzXG4gICAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgICAvLyAgIGVsZW1lbnQsIG1ha2UgdGhhdCBub2RlIGEgbWFuYWdlZCBub2RlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29uTXV0YXRpb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAgICogc3RvcmVkIGluIHRoaXMgb2JqZWN0IGFuZCB1cGRhdGVzIHRoZSBzdGF0ZSBvZiBhbGwgb2YgdGhlIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBOb3RlIHdlIGNhc3QgdGhlIG51bGxzIHRvIHRoZSBBTlkgdHlwZSBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAgIC8vICAgIG5lZWQgZXZlbiBtb3JlIGNhc3RzIHRocm91Z2hvdXQgdGhpcyBjb2RlLiBBbGwgYmV0cyBhcmUgb2ZmIGlmIGFuXG4gICAgICAgICAgLy8gICAgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkIGFuZCBhIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgICAgLy8gICAgdG8ga25vdyB3aGljaCBwcm9wZXJ0aWVzIHdlJ3JlIHNldHRpbmcuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4geyFTZXQ8IUluZXJ0Tm9kZT59IEEgY29weSBvZiB0aGlzIEluZXJ0Um9vdCdzIG1hbmFnZWQgbm9kZXMgc2V0LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBzdGFydE5vZGUgbWF5IGJlIGluIHNoYWRvdyBET00sIHNvIGZpbmQgaXRzIG5lYXJlc3Qgc2hhZG93Um9vdCB0byBnZXQgdGhlIGFjdGl2ZUVsZW1lbnQuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R9ICovbm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0Tm9kZS5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgICAvLyBjYWxsaW5nIGJsdXIoKSB3aWxsIG5vdCBhY3R1YWxseSBtb3ZlIHRoZSBmb2N1cy5cbiAgICAgICAgICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMgd2UgY2FsbCBmb2N1cygpIG9uIHRoZSBib2R5IGluc3RlYWQuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmlzaXROb2RlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuXG4gICAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAgIC8vIHRoaXMgaW5lcnQgcm9vdCwgc28gYWxsIG9mIGl0cyBtYW5hZ2VkIG5vZGVzIG5lZWQgdG8gYmUgYWRvcHRlZCBieSB0aGlzIEluZXJ0Um9vdC5cbiAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIucmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmFkZChpbmVydE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShpbmVydE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBlbnRpcmUgc3VidHJlZSBzdGFydGluZyBhdCBgc3RhcnROb2RlYC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlU3VidHJlZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fdW5tYW5hZ2VOb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgZGVzY2VuZGFudCBub2RlIGlzIGZvdW5kIHdpdGggYW4gYGluZXJ0YCBhdHRyaWJ1dGUsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fkb3B0SW5lcnRSb290KG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcblxuICAgICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgICAgLy8gc28gcmVnaXN0ZXIgaXQgbm93IGlmIG5lZWQgYmUuXG4gICAgICAgICAgaWYgKCFpbmVydFN1YnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShzYXZlZEluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBzdWJ0cmVlIGFkZGl0aW9ucywgcmVtb3ZhbHMsIG9yIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uTXV0YXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uTXV0YXRpb24ocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAvLyBVbi1tYW5hZ2UgcmVtb3ZlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5yZW1vdmVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlLWluaXRpYWxpc2UgaW5lcnQgbm9kZSBpZiB0YWJpbmRleCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZSh0YXJnZXQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbmV3IGluZXJ0IHJvb3QgaXMgYWRkZWQsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzIGFuZCBtYWtlIHN1cmUgaXQga25vd3MgYWJvdXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBtYW5hZ2VkIG5vZGVzIGZyb20gdGhpcyBpbmVydCBzdWJyb290LlxuICAgICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRTdWJyb290Ll9tYW5hZ2VOb2RlKG1hbmFnZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5fbWFuYWdlZE5vZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/c3RyaW5nfSBhcmlhSGlkZGVuICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXJpYUhpZGRlbikge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IGFyaWFIaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydFJvb3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Tm9kZWAgaW5pdGlhbGlzZXMgYW5kIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgbm9kZS5cbiAgICAgKiBBIG5vZGUgaXMgaW5lcnQgaWYgaXQgaXMgYSBkZXNjZW5kYW50IG9mIG9uZSBvciBtb3JlIGluZXJ0IHJvb3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBPbiBjb25zdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHNhdmVzIHRoZSBleGlzdGluZyBgdGFiaW5kZXhgIHZhbHVlIGZvciB0aGUgbm9kZSwgaWYgYW55LCBhbmRcbiAgICAgKiBlaXRoZXIgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgb3Igc2V0cyBpdCB0byBgLTFgLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZWxlbWVudFxuICAgICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIGBJbmVydE5vZGVgIG1haW50YWlucyBhIHNldCBvZiBgSW5lcnRSb290YHMgd2hpY2ggYXJlIGRlc2NlbmRhbnRzIG9mIHRoaXMgYEluZXJ0Tm9kZWAuIFdoZW4gYW5cbiAgICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICAgKiBgSW5lcnROb2RlYCB2aWEgYHJlbW92ZUluZXJ0Um9vdCgpYCwgd2hpY2ggaW4gdHVybiBkZXN0cm95cyB0aGUgYEluZXJ0Tm9kZWAgaWYgbm8gYEluZXJ0Um9vdGBzXG4gICAgICogcmVtYWluIGluIHRoZSBzZXQuIE9uIGRlc3RydWN0aW9uLCBgSW5lcnROb2RlYCByZWluc3RhdGVzIHRoZSBzdG9yZWQgYHRhYmluZGV4YCBpZiBvbmUgZXhpc3RzLFxuICAgICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIEEgZm9jdXNhYmxlIGVsZW1lbnQgdG8gYmUgbWFkZSBpbmVydC5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290IFRoZSBpbmVydCByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5lcnQgbm9kZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnROb2RlKTtcblxuICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Um9vdD59IFRoZSBzZXQgb2YgZGVzY2VuZGFudCBpbmVydCByb290cy5cbiAgICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgU2V0KFtpbmVydFJvb3RdKTtcblxuICAgICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2F2ZSBhbnkgcHJpb3IgdGFiaW5kZXggaW5mbyBhbmQgbWFrZSB0aGlzIG5vZGUgdW50YWJiYWJsZVxuICAgICAgICB0aGlzLmVuc3VyZVVudGFiYmFibGUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLlxuICAgICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Tm9kZSwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMuX25vZGU7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYGRlbGV0ZWAgdG8gcmVzdG9yZSBuYXRpdmUgZm9jdXMgbWV0aG9kLlxuICAgICAgICAgICAgaWYgKHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgICB0aGlzLl9ub2RlID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQsIGFueSBhdHRlbXB0IHRvIGFjY2VzcyBpdCB3aWxsIGNhdXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Rocm93SWZEZXN0cm95ZWQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Rocm93SWZEZXN0cm95ZWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgICAgLyoqIFNhdmUgdGhlIGV4aXN0aW5nIHRhYmluZGV4IHZhbHVlIGFuZCBtYWtlIHRoZSBub2RlIHVudGFiYmFibGUgYW5kIHVuZm9jdXNhYmxlICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmVVbnRhYmJhYmxlKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSkge1xuICAgICAgICAgICAgaWYgKCAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4ID09PSAtMSAmJiB0aGlzLmhhc1NhdmVkVGFiSW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbm90aGVyIGluZXJ0IHJvb3QgdG8gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdhZGRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLmFkZChpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBmcm9tIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICAgKiBzbyB0aGUgb2JqZWN0IHNob3VsZCBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3llZCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHshSW5lcnROb2RlfSAqL3RoaXMuX2Rlc3Ryb3llZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ25vZGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/bnVtYmVyfSB0YWJJbmRleCAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YWJJbmRleCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P251bWJlcn0gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBXaGVuIGFuIGVsZW1lbnQgYmVjb21lcyBhbiBpbmVydCByb290IGJ5IGhhdmluZyBhbiBgaW5lcnRgIGF0dHJpYnV0ZSBzZXQgYW5kL29yIGl0cyBgaW5lcnRgXG4gICAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICAgKiBUaGUgYEluZXJ0Um9vdGAgaW4gdHVybiByZWdpc3RlcnMgaXRzZWxmIGFzIG1hbmFnaW5nIGFsbCBvZiB0aGUgZWxlbWVudCdzIGZvY3VzYWJsZSBkZXNjZW5kYW50XG4gICAgICogbm9kZXMgdmlhIHRoZSBgcmVnaXN0ZXIoKWAgbWV0aG9kLiBUaGUgYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgIGluc3RhbmNlXG4gICAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshRG9jdW1lbnR9IGRvY3VtZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRNYW5hZ2VyKTtcblxuICAgICAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHshRG9jdW1lbnR9ICovXG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIG5vZGVzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIGluZXJ0IHJvb3RzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnRSb290Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICAgKiBAdHlwZSB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gQWRkIGluZXJ0IHN0eWxlLlxuICAgICAgICBhZGRJbmVydFN0eWxlKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRvY3VtZW50TG9hZGVkLmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZCBiZSBhbiBpbmVydCByb290IG9yIG5vdC5cbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluZXJ0XG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAgICBrZXk6ICdzZXRJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbmVydChyb290LCBpbmVydCkge1xuICAgICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBpbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmVydFJvb3QgPSBuZXcgSW5lcnRSb290KHJvb3QsIHRoaXMpO1xuICAgICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290cy5zZXQocm9vdCwgaW5lcnRSb290KTtcbiAgICAgICAgICAgIC8vIElmIG5vdCBjb250YWluZWQgaW4gdGhlIGRvY3VtZW50LCBpdCBtdXN0IGJlIGluIGEgc2hhZG93Um9vdC5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHJvb3QpKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgYWRkSW5lcnRTdHlsZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgICAgX2luZXJ0Um9vdC5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShyb290KTtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIEluZXJ0Um9vdCBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBlbGVtZW50LCBpZiBhbnkuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmVydFJvb3QoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbmVydFJvb3RzLmdldChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBub2RlLlxuICAgICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgICAqIGJlIGFkZGVkIHRvIGl0cyBzZXQgb2YgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Tm9kZX0gaW5lcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbm9kZSB3YXMgYWxyZWFkeSBpbiBhbiBpbmVydCBzdWJ0cmVlXG4gICAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZXJ0Tm9kZSA9IG5ldyBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuc2V0KG5vZGUsIGluZXJ0Tm9kZSk7XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlLXJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIGluZXJ0IG5vZGUuXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICAgKiBub2RlIGZyb20gdGhlIEluZXJ0TWFuYWdlcidzIHNldCBvZiBtYW5hZ2VkIG5vZGVzIGlmIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICogSWYgdGhlIG5vZGUgaXMgbm90IGN1cnJlbnRseSBtYW5hZ2VkLCB0aGlzIGlzIGVzc2VudGlhbGx5IGEgbm8tb3AuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7P0luZXJ0Tm9kZX0gVGhlIHBvdGVudGlhbGx5IGRlc3Ryb3llZCBJbmVydE5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgaWYgYW55LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXJlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKCFpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0Tm9kZS5yZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9jdW1lbnRMb2FkZWQoKSB7XG4gICAgICAgICAgLy8gRmluZCBhbGwgaW5lcnQgcm9vdHMgaW4gZG9jdW1lbnQgYW5kIG1ha2UgdGhlbSBhY3R1YWxseSBpbmVydC5cbiAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gQ29tbWVudCB0aGlzIG91dCB0byB1c2UgcHJvZ3JhbW1hdGljIEFQSSBvbmx5LlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZG9jdW1lbnQuYm9keSB8fCB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgc3VidHJlZTogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3dhdGNoRm9ySW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhdGNoRm9ySW5lcnQocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0ID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRJbmVydCh0YXJnZXQsIGluZXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRNYW5hZ2VyO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHdhbGsgdGhlIGNvbXBvc2VkIHRyZWUgZnJvbSB8bm9kZXwuXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uICghSFRNTEVsZW1lbnQpKT19IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50IHRyYXZlcnNlZCxcbiAgICAgKiAgICAgYmVmb3JlIGRlc2NlbmRpbmcgaW50byBjaGlsZCBub2Rlcy5cbiAgICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY29tcG9zZWRUcmVlV2Fsayhub2RlLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVzY2VuZCBpbnRvIG5vZGU6XG4gICAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgICAvLyB1cCBieSB0aGUgPGNvbnRlbnQ+IG9yIDxzaGFkb3c+IGVsZW1lbnRzLiBEZXNjZW5kIHN0cmFpZ2h0IGludG8gdGhlXG4gICAgICAgIC8vIFNoYWRvd1Jvb3QuXG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc2hhZG93Um9vdCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBkaXN0cmlidXRlZCBlbGVtZW50cyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnY29udGVudCcpIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmaWVzIGlmIFNoYWRvd0RvbSB2MCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIGRpc3RyaWJ1dGVkTm9kZXMgPSBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMgPyBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhkaXN0cmlidXRlZE5vZGVzW2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8c2xvdD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGFzc2lnbmVkIG5vZGVzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdzbG90Jykge1xuICAgICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZ5IGlmIFNoYWRvd0RvbSB2MSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIF9kaXN0cmlidXRlZE5vZGVzID0gc2xvdC5hc3NpZ25lZE5vZGVzID8gc2xvdC5hc3NpZ25lZE5vZGVzKHsgZmxhdHRlbjogdHJ1ZSB9KSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoX2Rpc3RyaWJ1dGVkTm9kZXNbX2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgICAvLyBlbGVtZW50LCBub3IgYSA8c2hhZG93PiBlbGVtZW50IHJlY3Vyc2Ugbm9ybWFsbHkuXG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGNoaWxkLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgICBpZiAobm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZSNpbmVydC1zdHlsZSwgbGluayNpbmVydC1zdHlsZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2luZXJ0LXN0eWxlJyk7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG5cbiAgICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgdmFyIGluZXJ0TWFuYWdlciA9IG5ldyBJbmVydE1hbmFnZXIoZG9jdW1lbnQpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmVydCkge1xuICAgICAgICAgIGluZXJ0TWFuYWdlci5zZXRJbmVydCh0aGlzLCBpbmVydCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSkoKTtcblxufSkpKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogYEJsb2NraW5nRWxlbWVudHNgIG1hbmFnZXMgYSBzdGFjayBvZiBlbGVtZW50cyB0aGF0IGluZXJ0IHRoZSBpbnRlcmFjdGlvblxuICogb3V0c2lkZSB0aGVtLiBUaGUgdG9wIGVsZW1lbnQgaXMgdGhlIGludGVyYWN0aXZlIHBhcnQgb2YgdGhlIGRvY3VtZW50LlxuICogVGhlIHN0YWNrIGNhbiBiZSB1cGRhdGVkIHdpdGggdGhlIG1ldGhvZHMgYHB1c2gsIHJlbW92ZSwgcG9wYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgLyoqXG4gICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuIFRoaXMgZW1wdGllc1xuICAgKiB0aGUgYmxvY2tpbmcgZWxlbWVudHNcbiAgICovXG4gIGRlc3RydWN0b3IoKTogdm9pZDtcblxuICAvKipcbiAgICogVGhlIHRvcCBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgdG9wOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBlbGVtZW50IHRvIHRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICovXG4gIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nIGVsZW1lbnRzLiBSZXR1cm5zIHRydWUgaWYgdGhlXG4gICAqIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHRvcCBibG9ja2luZyBlbGVtZW50IGFuZCByZXR1cm5zIGl0LlxuICAgKi9cbiAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgYSBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIGV4dGVuZHMgRG9jdW1lbnQge1xuICAkYmxvY2tpbmdFbGVtZW50czogQmxvY2tpbmdFbGVtZW50cztcbn1cblxuKCgpID0+IHtcbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBwcm9wZXJ0aWVzICovXG4gIGNvbnN0IF9ibG9ja2luZ0VsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9hbHJlYWR5SW5lcnRFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfdG9wRWxQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zaWJsaW5nc1RvUmVzdG9yZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfcGFyZW50TU8gPSBTeW1ib2woKTtcblxuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHN0YXRpYyBtZXRob2RzICovXG4gIGNvbnN0IF90b3BDaGFuZ2VkID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zd2FwSW5lcnRlZFNpYmxpbmcgPSBTeW1ib2woKTtcbiAgY29uc3QgX2luZXJ0U2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX3Jlc3RvcmVJbmVydGVkU2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4gPSBTeW1ib2woKTtcbiAgY29uc3QgX2lzSW5lcnRhYmxlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9oYW5kbGVNdXRhdGlvbnMgPSBTeW1ib2woKTtcblxuICBpbnRlcmZhY2UgSW5lcnRhYmxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGluZXJ0PzogYm9vbGVhbjtcbiAgfVxuXG4gIGludGVyZmFjZSBJbnRlcm5hbFN0YXRlIHtcbiAgICBbX3NpYmxpbmdzVG9SZXN0b3JlXTogU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT47XG4gICAgW19wYXJlbnRNT106IE11dGF0aW9uT2JzZXJ2ZXI7XG4gIH1cbiAgaW50ZXJmYWNlIEhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIEludGVybmFsU3RhdGUge31cbiAgaW50ZXJmYWNlIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgUGFydGlhbDxJbnRlcm5hbFN0YXRlPiB7fVxuXG4gIC8qKlxuICAgKiBTaGFkeURPTSBzaGFkeSByb290cyBsb29rIGEgbG90IGxpa2UgcmVhbCBTaGFkb3dSb290cy4gVGhlIF9fc2hhZHkgcHJvcGVydHlcbiAgICogZ2l2ZXMgdGhlbSBhd2F5LCB0aG91Z2guXG4gICAqL1xuICBpbnRlcmZhY2UgTWF5YmVTaGFkeVJvb3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBfX3NoYWR5OiB1bmtub3duO1xuICAgIGhvc3Q6IEVsZW1lbnQ7XG4gIH1cblxuICBjbGFzcyBCbG9ja2luZ0VsZW1lbnRzSW1wbCBpbXBsZW1lbnRzIEJsb2NraW5nRWxlbWVudHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBwcml2YXRlW19ibG9ja2luZ0VsZW1lbnRzXTogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcGFyZW50cyBvZiB0aGUgdG9wIGVsZW1lbnQsIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgKiBpdHNlbGYgdXAgdG8gYm9keS4gV2hlbiB0b3AgY2hhbmdlcywgdGhlIG9sZCB0b3AgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgKiBmcm9tIHRoZSBkb2N1bWVudCwgc28gd2UgbmVlZCB0byBtZW1vaXplIHRoZSBpbmVydGVkIHBhcmVudHMnIHNpYmxpbmdzXG4gICAgICogaW4gb3JkZXIgdG8gcmVzdG9yZSB0aGVpciBpbmVydGVuZXNzIHdoZW4gdG9wIGNoYW5nZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wRWxQYXJlbnRzXTogSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBFbGVtZW50cyB0aGF0IGFyZSBhbHJlYWR5IGluZXJ0IGJlZm9yZSB0aGUgZmlyc3QgYmxvY2tpbmcgZWxlbWVudCBpc1xuICAgICAqIHB1c2hlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBuZXcgU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT4oKTtcblxuICAgIGRlc3RydWN0b3IoKTogdm9pZCB7XG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGluZXJ0bmVzcy5cbiAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKHRoaXNbX3RvcEVsUGFyZW50c10pO1xuICAgICAgLy8gTm90ZSB3ZSBkb24ndCB3YW50IHRvIG1ha2UgdGhlc2UgcHJvcGVydGllcyBudWxsYWJsZSBvbiB0aGUgY2xhc3MsXG4gICAgICAvLyBzaW5jZSB0aGVuIHdlJ2QgbmVlZCBub24tbnVsbCBjYXN0cyBpbiBtYW55IHBsYWNlcy4gQ2FsbGluZyBhIG1ldGhvZCBvblxuICAgICAgLy8gYSBCbG9ja2luZ0VsZW1lbnRzIGluc3RhbmNlIGFmdGVyIGNhbGxpbmcgZGVzdHJ1Y3RvciB3aWxsIHJlc3VsdCBpbiBhblxuICAgICAgLy8gZXhjZXB0aW9uLlxuICAgICAgY29uc3QgbnVsbGFibGUgPSB0aGlzIGFzIHVua25vd24gYXMge1xuICAgICAgICBbX2Jsb2NraW5nRWxlbWVudHNdOiBudWxsO1xuICAgICAgICBbX3RvcEVsUGFyZW50c106IG51bGw7XG4gICAgICAgIFtfYWxyZWFkeUluZXJ0RWxlbWVudHNdOiBudWxsO1xuICAgICAgfTtcbiAgICAgIG51bGxhYmxlW19ibG9ja2luZ0VsZW1lbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfdG9wRWxQYXJlbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgdG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgZWxlbXMgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXTtcbiAgICAgIHJldHVybiBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH1cblxuICAgIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50ID09PSB0aGlzLnRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIHdlJ2xsIGJyaW5nIGl0IHRvIHRoZSB0b3AuXG4gICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICAgIHRoaXNbX3RvcENoYW5nZWRdKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnNwbGljZShpLCAxKTtcbiAgICAgIC8vIFRvcCBjaGFuZ2VkIG9ubHkgaWYgdGhlIHJlbW92ZWQgZWxlbWVudCB3YXMgdGhlIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKGkgPT09IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmxlbmd0aCkge1xuICAgICAgICB0aGlzW190b3BDaGFuZ2VkXSh0aGlzLnRvcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRvcCAmJiB0aGlzLnJlbW92ZSh0b3ApO1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGBpbmVydGAgdG8gYWxsIGRvY3VtZW50IGVsZW1lbnRzIGV4Y2VwdCB0aGUgbmV3IHRvcCBlbGVtZW50LCBpdHNcbiAgICAgKiBwYXJlbnRzLCBhbmQgaXRzIGRpc3RyaWJ1dGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wQ2hhbmdlZF0obmV3VG9wOiBNYXliZUhhc0ludGVybmFsU3RhdGV8bnVsbCk6IHZvaWQge1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBjb25zdCBvbGRQYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIC8vIE5vIG5ldyB0b3AsIHJlc2V0IG9sZCB0b3AgaWYgYW55LlxuICAgICAgaWYgKCFuZXdUb3ApIHtcbiAgICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cyk7XG4gICAgICAgIHRvS2VlcEluZXJ0LmNsZWFyKCk7XG4gICAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBbXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdQYXJlbnRzID0gdGhpc1tfZ2V0UGFyZW50c10obmV3VG9wKTtcbiAgICAgIC8vIE5ldyB0b3AgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgbWFpbiBkb2N1bWVudCFcbiAgICAgIGlmIChuZXdQYXJlbnRzW25ld1BhcmVudHMubGVuZ3RoIC0gMV0ucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm9uLWNvbm5lY3RlZCBlbGVtZW50IGNhbm5vdCBiZSBhIGJsb2NraW5nIGVsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIC8vIENhc3QgaGVyZSBiZWNhdXNlIHdlIGtub3cgd2UnbGwgY2FsbCBfaW5lcnRTaWJsaW5ncyBvbiBuZXdQYXJlbnRzXG4gICAgICAvLyBiZWxvdy5cbiAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBuZXdQYXJlbnRzIGFzIEFycmF5PEhhc0ludGVybmFsU3RhdGU+O1xuXG4gICAgICBjb25zdCB0b1NraXAgPSB0aGlzW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShuZXdUb3ApO1xuXG4gICAgICAvLyBObyBwcmV2aW91cyB0b3AgZWxlbWVudC5cbiAgICAgIGlmICghb2xkUGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cywgdG9Ta2lwLCB0b0tlZXBJbmVydCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSBvbGRQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgaiA9IG5ld1BhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIC8vIEZpbmQgY29tbW9uIHBhcmVudC4gSW5kZXggMCBpcyB0aGUgZWxlbWVudCBpdHNlbGYgKHNvIHN0b3AgYmVmb3JlIGl0KS5cbiAgICAgIHdoaWxlIChpID4gMCAmJiBqID4gMCAmJiBvbGRQYXJlbnRzW2ldID09PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgICAgLy8gSWYgdXAgdGhlIHBhcmVudHMgdHJlZSB0aGVyZSBhcmUgMiBlbGVtZW50cyB0aGF0IGFyZSBzaWJsaW5ncywgc3dhcFxuICAgICAgLy8gdGhlIGluZXJ0ZWQgc2libGluZy5cbiAgICAgIGlmIChvbGRQYXJlbnRzW2ldICE9PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIHRoaXNbX3N3YXBJbmVydGVkU2libGluZ10ob2xkUGFyZW50c1tpXSwgbmV3UGFyZW50c1tqXSk7XG4gICAgICB9XG4gICAgICAvLyBSZXN0b3JlIG9sZCBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0bmVzcy5cbiAgICAgIGkgPiAwICYmIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMuc2xpY2UoMCwgaSkpO1xuICAgICAgLy8gTWFrZSBuZXcgcGFyZW50cyBzaWJsaW5ncyBpbmVydC5cbiAgICAgIGogPiAwICYmIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMuc2xpY2UoMCwgaiksIHRvU2tpcCwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgaW5lcnRuZXNzIGJldHdlZW4gdHdvIHNpYmxpbmcgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfc3dhcEluZXJ0ZWRTaWJsaW5nXShcbiAgICAgICAgb2xkSW5lcnQ6IEhhc0ludGVybmFsU3RhdGUsIG5ld0luZXJ0OiBNYXliZUhhc0ludGVybmFsU3RhdGUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNpYmxpbmdzVG9SZXN0b3JlID0gb2xkSW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgIC8vIG9sZEluZXJ0IGlzIG5vdCBjb250YWluZWQgaW4gc2libGluZ3MgdG8gcmVzdG9yZSwgc28gd2UgaGF2ZSB0byBjaGVja1xuICAgICAgLy8gaWYgaXQncyBpbmVydGFibGUgYW5kIGlmIGFscmVhZHkgaW5lcnQuXG4gICAgICBpZiAodGhpc1tfaXNJbmVydGFibGVdKG9sZEluZXJ0KSAmJiAhb2xkSW5lcnQuaW5lcnQpIHtcbiAgICAgICAgb2xkSW5lcnQuaW5lcnQgPSB0cnVlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5hZGQob2xkSW5lcnQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbmV3SW5lcnQgd2FzIGFscmVhZHkgYmV0d2VlbiB0aGUgc2libGluZ3MgdG8gcmVzdG9yZSwgaXQgbWVhbnMgaXQgaXNcbiAgICAgIC8vIGluZXJ0YWJsZSBhbmQgbXVzdCBiZSByZXN0b3JlZC5cbiAgICAgIGlmIChzaWJsaW5nc1RvUmVzdG9yZS5oYXMobmV3SW5lcnQpKSB7XG4gICAgICAgIG5ld0luZXJ0LmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmRlbGV0ZShuZXdJbmVydCk7XG4gICAgICB9XG4gICAgICBuZXdJbmVydFtfcGFyZW50TU9dID0gb2xkSW5lcnRbX3BhcmVudE1PXTtcbiAgICAgIG5ld0luZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBzaWJsaW5nc1RvUmVzdG9yZTtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIGluZXJ0bmVzcyB0byB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKGVsZW1lbnRzOiBIYXNJbnRlcm5hbFN0YXRlW10pIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBtbyA9IGVsZW1lbnRbX3BhcmVudE1PXTtcbiAgICAgICAgbW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgICBmb3IgKGNvbnN0IHNpYmxpbmcgb2Ygc2libGluZ3MpIHtcbiAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZXJ0cyB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzIGV4Y2VwdCB0aGUgZWxlbWVudHMgdG8gc2tpcC4gU3RvcmVzXG4gICAgICogdGhlIGluZXJ0ZWQgc2libGluZ3MgaW50byB0aGUgZWxlbWVudCdzIHN5bWJvbCBgX3NpYmxpbmdzVG9SZXN0b3JlYC5cbiAgICAgKiBQYXNzIGB0b0tlZXBJbmVydGAgdG8gY29sbGVjdCB0aGUgYWxyZWFkeSBpbmVydCBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19pbmVydFNpYmxpbmdzXShcbiAgICAgICAgZWxlbWVudHM6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdLCB0b1NraXA6IFNldDxIVE1MRWxlbWVudD58bnVsbCxcbiAgICAgICAgdG9LZWVwSW5lcnQ6IFNldDxIVE1MRWxlbWVudD58bnVsbCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIC8vIEFzc3VtZSBlbGVtZW50IGlzIG5vdCBhIERvY3VtZW50LCBzbyBpdCBtdXN0IGhhdmUgYSBwYXJlbnROb2RlLlxuICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUhO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBjaGlsZHJlbltqXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgLy8gU2tpcCB0aGUgaW5wdXQgZWxlbWVudCwgaWYgbm90IGluZXJ0YWJsZSBvciB0byBiZSBza2lwcGVkLlxuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBlbGVtZW50IHx8ICF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykgfHxcbiAgICAgICAgICAgICAgKHRvU2tpcCAmJiB0b1NraXAuaGFzKHNpYmxpbmcpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNob3VsZCBiZSBjb2xsZWN0ZWQgc2luY2UgYWxyZWFkeSBpbmVydGVkLlxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIHNpYmxpbmdzIHRoYXQgd2VyZSBpbmVydGVkLlxuICAgICAgICBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBpbmVydGVkU2libGluZ3M7XG4gICAgICAgIC8vIE9ic2VydmUgb25seSBpbW1lZGlhdGUgY2hpbGRyZW4gbXV0YXRpb25zIG9uIHRoZSBwYXJlbnQuXG4gICAgICAgIGNvbnN0IG1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpc1tfaGFuZGxlTXV0YXRpb25zXS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZWxlbWVudFtfcGFyZW50TU9dID0gbW87XG4gICAgICAgIGxldCBwYXJlbnRUb09ic2VydmUgPSBwYXJlbnQ7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHRoZSBTaGFkeURPTSBwb2x5ZmlsbCwgdGhlbiBvdXIgcGFyZW50IGNvdWxkIGJlIGFcbiAgICAgICAgLy8gc2hhZHkgcm9vdCwgd2hpY2ggaXMgYW4gb2JqZWN0IHRoYXQgYWN0cyBsaWtlIGEgU2hhZG93Um9vdCwgYnV0IGlzbid0XG4gICAgICAgIC8vIGFjdHVhbGx5IGEgbm9kZSBpbiB0aGUgcmVhbCBET00uIE9ic2VydmUgdGhlIHJlYWwgRE9NIHBhcmVudCBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBtYXliZVNoYWR5Um9vdCA9IHBhcmVudFRvT2JzZXJ2ZSBhcyBNYXliZVNoYWR5Um9vdDtcbiAgICAgICAgaWYgKG1heWJlU2hhZHlSb290Ll9fc2hhZHkgJiYgbWF5YmVTaGFkeVJvb3QuaG9zdCkge1xuICAgICAgICAgIHBhcmVudFRvT2JzZXJ2ZSA9IG1heWJlU2hhZHlSb290Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbW8ub2JzZXJ2ZShwYXJlbnRUb09ic2VydmUsIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbmV3bHkgYWRkZWQvcmVtb3ZlZCBub2RlcyBieSB0b2dnbGluZyB0aGVpciBpbmVydG5lc3MuXG4gICAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIGN1cnJlbnQgdG9wIEJsb2NraW5nIEVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgKiBub3RpZnlpbmcgYW5kIHJlbW92aW5nIGl0LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2hhbmRsZU11dGF0aW9uc10obXV0YXRpb25zOiBNdXRhdGlvblJlY29yZFtdKTogdm9pZCB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHNoYWRvd1Jvb3QsIGdldCBpdHMgaG9zdCBhcyB3ZSBza2lwIHNoYWRvd1Jvb3RzIHdoZW5cbiAgICAgICAgLy8gY29tcHV0aW5nIF90b3BFbFBhcmVudHMuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IChtdXRhdGlvbi50YXJnZXQgYXMgU2hhZG93Um9vdCkuaG9zdCB8fCBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSA/XG4gICAgICAgICAgICBwYXJlbnRzLmxlbmd0aCA6XG4gICAgICAgICAgICBwYXJlbnRzLmluZGV4T2YodGFyZ2V0IGFzIEhhc0ludGVybmFsU3RhdGUpO1xuICAgICAgICBjb25zdCBpbmVydGVkQ2hpbGQgPSBwYXJlbnRzW2lkeCAtIDFdO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBpbmVydGVkQ2hpbGRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcblxuICAgICAgICAvLyBUbyByZXN0b3JlLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBpbmVydGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnRGV0ZWN0ZWQgcmVtb3ZhbCBvZiB0aGUgdG9wIEJsb2NraW5nIEVsZW1lbnQuJyk7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5lcnRlZFNpYmxpbmdzLmhhcyhzaWJsaW5nKSkge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmRlbGV0ZShzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBpbmVydC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLmFkZGVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmICghdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgaW5lcnRhYmxlLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2lzSW5lcnRhYmxlXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGZhbHNlID09PSAvXihzdHlsZXx0ZW1wbGF0ZXxzY3JpcHQpJC8udGVzdChlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBuZXdQYXJlbnRzIG9mIGFuIGVsZW1lbnQsIHN0YXJ0aW5nIGZyb20gZWxlbWVudFxuICAgICAqIChpbmNsdWRlZCkgdXAgdG8gYGRvY3VtZW50LmJvZHlgIChleGNsdWRlZCkuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0UGFyZW50c10oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBBcnJheTxIVE1MRWxlbWVudD4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnQ6IEhUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkID0gZWxlbWVudDtcbiAgICAgIC8vIFN0b3AgdG8gYm9keS5cbiAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgLy8gU2tpcCBzaGFkb3cgcm9vdHMuXG4gICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGFkb3dEb20gdjFcbiAgICAgICAgaWYgKGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gQ29sbGVjdCBzbG90cyBmcm9tIGRlZXBlc3Qgc2xvdCB0byB0b3AuXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPSBjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb250aW51ZSB0aGUgc2VhcmNoIG9uIHRoZSB0b3Agc2xvdC5cbiAgICAgICAgICBjdXJyZW50ID0gcGFyZW50cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICAgICAoY3VycmVudCBhcyBOb2RlIGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0cmlidXRlZCBjaGlsZHJlbiBvZiB0aGUgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBzaGFkb3cgcm9vdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShlbGVtZW50OiBIVE1MRWxlbWVudCk6XG4gICAgICAgIFNldDxIVE1MRWxlbWVudD58bnVsbCB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgIGxldCBpO1xuICAgICAgbGV0IGo7XG4gICAgICBsZXQgbm9kZXM7XG4gICAgICBjb25zdCBzbG90cyA9IHNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgICAgaWYgKHNsb3RzLmxlbmd0aCAmJiBzbG90c1swXS5hc3NpZ25lZE5vZGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzID0gc2xvdHNbaV0uYXNzaWduZWROb2Rlcyh7XG4gICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICByZXN1bHQuYWRkKG5vZGVzW2pdIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZWFyY2ggZm9yIDxjb250ZW50Pi5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgKGRvY3VtZW50IGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzID1cbiAgICAgIG5ldyBCbG9ja2luZ0VsZW1lbnRzSW1wbCgpO1xufSkoKTtcbiIsImltcG9ydCBcIndpY2ctaW5lcnRcIjtcbmltcG9ydCBcImJsb2NraW5nLWVsZW1lbnRzXCI7XG5pbXBvcnQgeyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIH0gZnJvbSBcImJsb2NraW5nLWVsZW1lbnRzXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZXREb2N1bWVudCB9IGZyb20gXCIuL3VzZS1kb2N1bWVudC1jbGFzc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5cbmZ1bmN0aW9uIGJsb2NraW5nRWxlbWVudHMoKSB7IHJldHVybiAoZ2V0RG9jdW1lbnQoKSBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyB9XG4vKipcbiAqIEFsbG93cyBhbiBlbGVtZW50IHRvIHRyYXAgZm9jdXMgYnkgYXBwbHlpbmcgdGhlIFwiaW5lcnRcIiBhdHRyaWJ1dGUgdG8gYWxsIHNpYmxpbmcsIGF1bnQsIGFuZCB1bmNsZSBub2Rlcy5cbiAqIFxuICogQXV0b21hdGljYWxseSBoYW5kbGVzIGNvbnNlY3V0aXZlIGNhbGxzIHdpdGggYSBsb29zZWx5IGFwcGxpZWQgc3RhY2sgb3BlcmF0aW9uIFxuICogKHNwZWNpZmljYWxseSB2aWEgYGJsb2NraW5nRWxlbWVudHNgLCB3aXRoIGEgc21hbGwgcG9seWZpbGwgYmVjYXVzZSBJJ20gbm90IHN1cmUgaG93IGxvbmdcbiAqIGl0J2xsIHRha2UgdG8gZmluZCBpdHMgd2F5IGludG8gdGhlIHNwZWMsIGlmIGV2ZXIpXG4gKiBAcGFyYW0gdGFyZ2V0IFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmxvY2tpbmdFbGVtZW50PEUgZXh0ZW5kcyBFbGVtZW50PihlbmFibGVkOiBib29sZWFuLCBnZXRUYXJnZXQ6ICgpID0+IChFIHwgbnVsbCkpIHtcblxuICAgIGNvbnN0IHN0YWJsZUdldFRhcmdldCA9IHVzZVN0YWJsZUNhbGxiYWNrKGdldFRhcmdldCk7XG5cbiAgICAvKipcbiAgICAgKiBQdXNoL3BvcCB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZ0VsZW1lbnRzIHN0YWNrLlxuICAgICAqL1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHN0YWJsZUdldFRhcmdldCgpO1xuXG4gICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgYmxvY2tpbmdFbGVtZW50cyB3aWxsIGZhaWwgaWYsIGZvciBleGFtcGxlLFxuICAgICAgICAgICAgLy8gdGhlIHRhcmdldCBlbGVtZW50IGlzbid0IGNvbm5lY3RlZCB0byBkb2N1bWVudC5ib2R5LlxuICAgICAgICAgICAgLy8gVGhpcyBpcyByYXJlLCBidXQgaXQncyBiZXR0ZXIgdG8gZmFpbCBzaWxlbnRseSB3aXRoIHdlaXJkIHRhYmJpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIHRoYW4gdG8gY3Jhc2ggdGhlIGVudGlyZSBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYmxvY2tpbmdFbGVtZW50cygpLnB1c2godGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NraW5nRWxlbWVudHMoKS5yZW1vdmUodGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBXZWxsLCBzZW1pLXNpbGVudGx5LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2VuYWJsZWRdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGJsb2NraW5nRWxlbWVudHMoKS50b3A7XG59XG5cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBpc0ZvY3VzYWJsZSB9IGZyb20gXCJ0YWJiYWJsZVwiO1xuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCB9IGZyb20gXCIuL3VzZS1hY3RpdmUtZWxlbWVudFwiO1xuaW1wb3J0IHsgZ2V0VG9wRWxlbWVudCwgdXNlQmxvY2tpbmdFbGVtZW50IH0gZnJvbSBcIi4vdXNlLWJsb2NraW5nLWVsZW1lbnRcIjtcbmltcG9ydCB7IGdldERvY3VtZW50IH0gZnJvbSBcIi4vdXNlLWRvY3VtZW50LWNsYXNzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1RyYXBQYXJhbWV0ZXJzIHsgdHJhcEFjdGl2ZTogYm9vbGVhbjsgfVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUZvY3VzVHJhcFJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiwgXCJ1c2VSZWZFbGVtZW50UHJvcHNcIj4ge1xuICAgIHVzZUZvY3VzVHJhcFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbn1cblxuY29uc3QgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvID0gbmV3IE1hcDxFbGVtZW50IHwgbnVsbCwgKE5vZGUgJiBIVE1MT3JTVkdFbGVtZW50KT4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvY3VzVHJhcDxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgdHJhcEFjdGl2ZSB9OiBVc2VGb2N1c1RyYXBQYXJhbWV0ZXJzKTogVXNlRm9jdXNUcmFwUmV0dXJuVHlwZTxFPiB7XG4gICAgXG4gICAgY29uc3QgaGFuZGxlQWN0aXZlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHRyYXBBY3RpdmU6IGJvb2xlYW4sIGVsZW1lbnQ6IEUgfCBudWxsKSA9PiB7XG4gICAgICAgIGlmICh0cmFwQWN0aXZlICYmIGVsZW1lbnQpIHtcblxuICAgICAgICAgICAgbGV0IHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBleHRyYSBxdWV1ZU1pY3JvdGFzayBpcyBuZWVkZWQgZm9yXG4gICAgICAgICAgICAgICAgLy8gLi4ucmVhc29ucz9cbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50KT8uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFmSGFuZGxlID0gMDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGZvY3VzIHRvIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAvLyB0aGF0IGhhcyByZXR1cm5lZCB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAgICAgICAgbGV0IHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8uZ2V0KGdldFRvcEVsZW1lbnQoKSk/LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBcbiAgICBjb25zdCB7IGdldExhc3RBY3RpdmVFbGVtZW50LCB1c2VBY3RpdmVFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUFjdGl2ZUVsZW1lbnQ8RT4oeyBvbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjaygoZWxlbWVudDogRSB8IG51bGwpID0+IGhhbmRsZUFjdGl2ZUNoYW5nZSh0cmFwQWN0aXZlLCBlbGVtZW50KSkgfSk7XG5cblxuICAgIC8vIFdoZW4gdGhlIHRyYXAgYmVjb21lcyBhY3RpdmUsIGJlZm9yZSB3ZSBsZXQgdGhlIGJsb2NraW5nRWxlbWVudHMgaG9vayBydW4sXG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGF0ZXZlcidzIGN1cnJlbnRseSBmb2N1c2VkIGFuZCBzYXZlIGl0LlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgIGlmICh0cmFwQWN0aXZlICYmIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHRvIHdoYXRldmVyJ3MgY3VycmVudGx5IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICAgICAgICBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8uc2V0KGdldFRvcEVsZW1lbnQoKSwgKGdldExhc3RBY3RpdmVFbGVtZW50KCkgYXMgKE5vZGUgJiBIVE1MT3JTVkdFbGVtZW50KSkgPz8gZG9jdW1lbnQuYm9keSk7XG4gICAgICAgIH1cbiAgICB9LCBbdHJhcEFjdGl2ZV0pO1xuXG4gICAgdXNlQmxvY2tpbmdFbGVtZW50KHRyYXBBY3RpdmUsIGdldEVsZW1lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQW55IHRpbWUgd2UgYWN0aXZhdGUgb3IgZGVhY3RpdmF0ZSB0aGUgdHJhcCxcbiAgICAgKiBjaGFuZ2UgZm9jdXMgdG8gc29tZXRoaW5nIGVsc2UgKHNvbWV0aGluZyBpblxuICAgICAqIHRoZSB0cmFwIGlmIGl0J3MgYWN0aXZlLCBvciB3aGF0ZXZlciB3ZSd2ZVxuICAgICAqIHRyYWNrZWQgaW4gZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvIGlmIG5vdClcbiAgICAgKi9cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBoYW5kbGVBY3RpdmVDaGFuZ2UodHJhcEFjdGl2ZSwgZ2V0RWxlbWVudCgpKTtcbiAgICB9LCBbdHJhcEFjdGl2ZV0pO1xuXG4gICAgY29uc3QgdXNlRm9jdXNUcmFwUHJvcHMgPSAoKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4ge1xuICAgICAgICBjb25zdCBwMSA9IHVzZUFjdGl2ZUVsZW1lbnRQcm9wcyhwcm9wcyk7XG4gICAgICAgIGNvbnN0IHAyID0geyBcImFyaWEtbW9kYWxcIjogdHJhcEFjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPihwMSwgcDIpO1xuICAgIH0pO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VGb2N1c1RyYXBQcm9wcyxcbiAgICAgICAgZ2V0RWxlbWVudFxuICAgIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgY29udGFpbmVkIHdpdGhpbiB0aGUgZ2l2ZW4gbm9kZSwgb3IgbnVsbCBpZiBub25lIGFyZSBmb3VuZC5cbiAqIEBwYXJhbSBlbGVtZW50IFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRmlyc3RGb2N1c2FibGUoZWxlbWVudDogTm9kZSkge1xuICAgIGNvbnN0IHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsZW1lbnQsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7IGFjY2VwdE5vZGU6IChub2RlKSA9PiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgaXNGb2N1c2FibGUobm9kZSkgPyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQKSB9KVxuICAgIGNvbnN0IGZpcnN0Rm9jdXNhYmxlID0gdHJlZVdhbGtlci5maXJzdENoaWxkKCkgYXMgKEVsZW1lbnQgJiBIVE1MT3JTVkdFbGVtZW50KSB8IG51bGw7XG4gICAgcmV0dXJuIGZpcnN0Rm9jdXNhYmxlO1xufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50U2l6ZSwgdXNlRWxlbWVudFNpemUgfSBmcm9tIFwiLi91c2UtZWxlbWVudC1zaXplXCI7XG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5cbi8vZXhwb3J0IHR5cGUgQmxvY2tGbG93RGlyZWN0aW9uID0gXCJkb3dud2FyZHNcIiB8IFwibGVmdHdhcmRzXCIgfCBcInJpZ2h0d2FyZHNcIjtcbmV4cG9ydCB0eXBlIFBoeXNpY2FsRGlyZWN0aW9uID0gXCJsdHJcIiB8IFwicnRsXCIgfCBcInR0YlwiIHwgXCJidHRcIjtcbmV4cG9ydCB0eXBlIFBoeXNpY2FsT3JpZW50YXRpb24gPSBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIjtcbmV4cG9ydCB0eXBlIFBoeXNpY2FsU2l6ZSA9IFwid2lkdGhcIiB8IFwiaGVpZ2h0XCI7XG5cbmV4cG9ydCB0eXBlIExvZ2ljYWxPcmllbnRhdGlvbiA9IFwiaW5saW5lXCIgfCBcImJsb2NrXCI7XG5cbi8vZXhwb3J0IHR5cGUgTGluZU9yaWVudGF0aW9uID0gXCJ1cHJpZ2h0XCIgfCBcImxlZnRyaWdodFwiIHwgXCJkb3ducmlnaHRcIiB8IFwicmlnaHRyaWdodFwiO1xuXG50eXBlIFdyaXRpbmdNb2RlID0gXCJob3Jpem9udGFsLXRiXCIgfCBcInZlcnRpY2FsLWxyXCIgfCBcInNpZGV3YXlzLXJsXCIgfCBcInZlcnRpY2FsLXJsXCIgfCBcInNpZGV3YXlzLWxyXCI7XG50eXBlIERpcmVjdGlvbiA9IFwibHRyXCIgfCBcInJ0bFwiO1xudHlwZSBUZXh0T3JpZW50YXRpb24gPSBcIm1peGVkXCIgfCBcInVwcmlnaHRcIiB8IFwic2lkZXdheXNcIjtcblxuZnVuY3Rpb24gY2FwaXRhbGl6ZTxUIGV4dGVuZHMgc3RyaW5nPihzdHI6IFQpOiBDYXBpdGFsaXplPFQ+IHtcbiAgICByZXR1cm4gKHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKSkgYXMgQ2FwaXRhbGl6ZTxUPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMb2dpY2FsRGlyZWN0aW9uUGFyYW1ldGVycyB7XG4gICAgb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlPyhpbmZvOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2ljYWxFbGVtZW50U2l6ZSB7XG4gICAgY2xpZW50SW5saW5lU2l6ZTogbnVtYmVyO1xuICAgIHNjcm9sbElubGluZVNpemU6IG51bWJlcjtcbiAgICBvZmZzZXRJbmxpbmVTaXplOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50QmxvY2tTaXplOiBudW1iZXI7XG4gICAgc2Nyb2xsQmxvY2tTaXplOiBudW1iZXI7XG4gICAgb2Zmc2V0QmxvY2tTaXplOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50SW5saW5lSW5zZXQ6IG51bWJlcjtcbiAgICBzY3JvbGxJbmxpbmVJbnNldDogbnVtYmVyO1xuICAgIG9mZnNldElubGluZUluc2V0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50QmxvY2tJbnNldDogbnVtYmVyO1xuICAgIHNjcm9sbEJsb2NrSW5zZXQ6IG51bWJlcjtcbiAgICBvZmZzZXRCbG9ja0luc2V0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSW5zcGVjdHMgdGhlIGVsZW1lbnQncyBzdHlsZSBhbmQgZGV0ZXJtaW5lcyB0aGUgbG9naWNhbCBkaXJlY3Rpb24gdGhhdCB0ZXh0IGZsb3dzLlxuICogXG4gKiBDZXJ0YWluIENTUyBwcm9wZXJ0aWVzLCBsaWtlIGBibG9jay1zaXplYCwgcmVzcGVjdCB0aGUgY3VycmVudCB3cml0aW5nIG1vZGUgYW5kIHRleHQgZGlyZWN0aW9uLlxuICogQnV0IGB0cmFuc2Zvcm1gLCBgY2xpcGAsIGV0Yy4gZG9uJ3QuXG4gKiBcbiAqIFRoaXMgaXMgcHJvdmlkZWQgc28gdGhhdCBDU1MgcHJvcGVydGllcyBjYW4gY29uc2lzdGVudGx5IHVzZSB0aG9zZSBsb2dpY2FsIHByb3BlcnRpZXMuXG4gKiBcbiAqIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXdyaXRpbmctbW9kZXMvI2xvZ2ljYWwtdG8tcGh5c2ljYWxcbiAqIFxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnM6XG4gKiAqIGBnZXRMb2dpY2FsRGlyZWN0aW9uYDogcmV0cmlldmVzIGEgYExvZ2ljYWxEaXJlY3Rpb25JbmZvYCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuIChGdW5jdGlvbiBpcyBjb25zdGFudCBiZXR3ZWVuIHJlbmRlcnMpXG4gKiAqIGBjb252ZXJ0RWxlbWVudFNpemVgOiBXaGVuIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgdXNlRWxlbWVudFNpemVgLCBhbGxvd3MgeW91IHRvIHJldHJpZXZlIHRoZSBsb2dpY2FsIHNpemUgb2YgYW4gZWxlbWVudCBpbnN0ZWFkIG9mIHRoZSBwaHlzaWNhbCBzaXplLiBcbiAqICogYGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbmA6IEJhc2VkIG9uIHRoZSBjdXJyZW50IGRpcmVjdGlvbiwgY29udmVydHMgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiIHRvIFwiaW5saW5lXCIgb3IgXCJibG9ja1wiLlxuICogKiBgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbmA6ICBCYXNlZCBvbiB0aGUgY3VycmVudCBkaXJlY3Rpb24sIGNvbnZlcnRzIFwiaW5saW5lXCIgb3IgXCJibG9ja1wiIHRvIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvZ2ljYWxEaXJlY3Rpb248VCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudD4oeyBvbkxvZ2ljYWxEaXJlY3Rpb25DaGFuZ2UgfTogVXNlTG9naWNhbERpcmVjdGlvblBhcmFtZXRlcnMpOiBVc2VMb2dpY2FsRGlyZWN0aW9uUmV0dXJuVHlwZTxUPiB7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VMb2dpY2FsRGlyZWN0aW9uXCIsIG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZSk7XG5cbiAgICBjb25zdCBbZ2V0Q29tcHV0ZWRTdHlsZXMsIHNldENvbXB1dGVkU3R5bGVzXSA9IHVzZVBhc3NpdmVTdGF0ZTxDU1NTdHlsZURlY2xhcmF0aW9uIHwgbnVsbD4obnVsbCwgcmV0dXJuTnVsbCk7XG5cblxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHtcbiAgICAgICAgb25FbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoZWxlbWVudDogVCB8IG51bGwpID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0Q29tcHV0ZWRTdHlsZXMod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSlcbiAgICB9KTtcblxuICAgIC8vIFRPRE86IFRoZXJlJ3Mgbm8gd2F5IHRvIHJlZnJlc2ggd2hpY2ggd3JpdGluZyBtb2RlIHdlIGhhdmUgb25jZSBtb3VudGVkLlxuICAgIC8vICAgQS4gVGhlcmUncyBubyB3YXkgdG8gd2F0Y2ggZm9yIENTUyBzdHlsZSBjaGFuZ2VzXG4gICAgLy8gICBCLiBDYWxsaW5nIGdldENvbXB1dGVkU3R5bGUgYWZ0ZXIgZXZlcnkgcmVuZGVyIGZvciBldmVyeSBlbGVtZW50IGdldHMgZXhwZW5zaXZlIGZhc3QgYW5kXG4gICAgLy8gICBDLiBJcyBub3QgbmVjZXNzYXJ5IGZvciBtb3N0IHVzZSBjYXNlcyB0aGF0IHdpbGwgbmV2ZXIgc3dpdGNoIHdyaXRpbmctbW9kZSB3aXRoaW4gYSBzaW5nbGUgY29tcG9uZW50XG4gICAgLy8gICAgICAoVGhvc2UgdGhhdCBkbyB3aWxsIG5lZWQgdG8gbW91bnQgYW5kIHVubW91bnQgdGhlIGNvbXBvbmVudCB0aGF0IHVzZXMgaXQpXG4gICAgLy9cbiAgICAvLyBBcyBhIHNvbHV0aW9uLCBoZXJlJ3MgYSBjaGVhcCB3b3JrYXJvdW5kIHRoYXQgY2hlY2tzIHdoZW4gdGhlIGVsZW1lbnQncyBzaXplIGhhcyBjaGFuZ2VkLFxuICAgIC8vIGFuZCBpZiBzbywgdGVzdHMgaWYgdGhlIHdyaXRpbmcgbW9kZSBoYXMgY2hhbmdlZCB0b28uXG4gICAgLy9cbiAgICAvLyBUaGlzIHdpbGwgd29yayBmb3IgYXQgbGVhc3Qgc29tZSBudW1iZXIgb2YgY2FzZXMsIGJ1dCBhIGJldHRlciBzb2x1dGlvbiBpcyBzdGlsbCBuZWVkZWQuXG4gICAgY29uc3QgeyB1c2VFbGVtZW50U2l6ZVByb3BzIH0gPSB1c2VFbGVtZW50U2l6ZTxUPih7IG9uU2l6ZUNoYW5nZTogdXNlQ2FsbGJhY2soXyA9PiBvbkxvZ2ljYWxEaXJlY3Rpb25DaGFuZ2U/LihnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpKSwgW10pIH0pXG5cbiAgICBjb25zdCBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlcygpO1xuICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBjb21wdXRlZFN0eWxlcy53cml0aW5nTW9kZSBhcyBXcml0aW5nTW9kZTtcbiAgICAgICAgICAgIGxldCBkID0gY29tcHV0ZWRTdHlsZXMuZGlyZWN0aW9uIGFzIERpcmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBjb21wdXRlZFN0eWxlcy50ZXh0T3JpZW50YXRpb24gYXMgVGV4dE9yaWVudGF0aW9uO1xuXG4gICAgICAgICAgICBpZiAodCA9PSBcInVwcmlnaHRcIilcbiAgICAgICAgICAgICAgICBkID0gXCJsdHJcIjtcblxuICAgICAgICAgICAgcmV0dXJuICh7IC4uLldyaXRpbmdNb2Rlc1t3IHx8IFwiaG9yaXpvbnRhbC10YlwiXVtkIHx8IFwibHRyXCJdIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgW10pXG5cbiAgICAvL2NvbnN0IFtnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbywgc2V0TG9naWNhbERpcmVjdGlvbkluZm9dID0gdXNlUGFzc2l2ZVN0YXRlPExvZ2ljYWxEaXJlY3Rpb25JbmZvPihvbkxvZ2ljYWxEaXJlY3Rpb25DaGFuZ2UpO1xuXG4gICAgY29uc3QgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uID0gdXNlQ2FsbGJhY2soKGVsZW1lbnRPcmllbnRhdGlvbjogUGh5c2ljYWxPcmllbnRhdGlvbiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT09IGVsZW1lbnRPcmllbnRhdGlvbilcbiAgICAgICAgICAgIHJldHVybiBcImlubGluZVwiO1xuICAgICAgICByZXR1cm4gXCJibG9ja1wiO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnZlcnRUb1BoeXNpY2FsU2lkZSA9IHVzZUNhbGxiYWNrKChzaWRlOiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpOiBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiID0+IHtcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuXG4gICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrLXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uYmxvY2tEaXJlY3Rpb24gPz8gXCJ0dGJcIilbMF0gYXMgXCJ0XCIgfCBcImJcIiB8IFwibFwiIHwgXCJyXCJdO1xuICAgICAgICAgICAgY2FzZSBcImJsb2NrLWVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBNWyhkaXJlY3Rpb24/LmJsb2NrRGlyZWN0aW9uID8/IFwidHRiXCIpWzJdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcblxuICAgICAgICAgICAgY2FzZSBcImlubGluZS1zdGFydFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBNWyhkaXJlY3Rpb24/LmlubGluZURpcmVjdGlvbiA/PyBcImx0clwiKVswXSBhcyBcInRcIiB8IFwiYlwiIHwgXCJsXCIgfCBcInJcIl07XG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLWVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBNWyhkaXJlY3Rpb24/LmlubGluZURpcmVjdGlvbiA/PyBcImx0clwiKVsyXSBhcyBcInRcIiB8IFwiYlwiIHwgXCJsXCIgfCBcInJcIl07XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IGNvbnZlcnRUb0xvZ2ljYWxTaWRlID0gdXNlQ2FsbGJhY2soKHNpZGU6IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcIiB8IFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIgPT4ge1xuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XG4gICAgICAgIGlmIChkaXJlY3Rpb24/LmlubGluZU9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5pbmxpbmVEaXJlY3Rpb24gPT09IFwidHRiXCIgPyBcImlubGluZS1zdGFydFwiIDogXCJpbmxpbmUtZW5kXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJidHRcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uYmxvY2tEaXJlY3Rpb24gPT09IFwibHRyXCIgPyBcImJsb2NrLXN0YXJ0XCIgOiBcImJsb2NrLWVuZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmJsb2NrRGlyZWN0aW9uID09PSBcInJ0bFwiID8gXCJibG9jay1zdGFydFwiIDogXCJibG9jay1lbmRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmJsb2NrRGlyZWN0aW9uID09PSBcInR0YlwiID8gXCJibG9jay1zdGFydFwiIDogXCJibG9jay1lbmRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uYmxvY2tEaXJlY3Rpb24gPT09IFwiYnR0XCIgPyBcImJsb2NrLXN0YXJ0XCIgOiBcImJsb2NrLWVuZFwiO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5pbmxpbmVEaXJlY3Rpb24gPT09IFwibHRyXCIgPyBcImlubGluZS1zdGFydFwiIDogXCJpbmxpbmUtZW5kXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uaW5saW5lRGlyZWN0aW9uID09PSBcInJ0bFwiID8gXCJpbmxpbmUtc3RhcnRcIiA6IFwiaW5saW5lLWVuZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIFwiaW5saW5lLXN0YXJ0XCI7XG5cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb24gPSB1c2VDYWxsYmFjaygoZWxlbWVudE9yaWVudGF0aW9uOiBMb2dpY2FsT3JpZW50YXRpb24sIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XG4gICAgICAgIGlmIChlbGVtZW50T3JpZW50YXRpb24gPT0gXCJpbmxpbmVcIikge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT0gXCJob3Jpem9udGFsXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xuICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24/LmJsb2NrT3JpZW50YXRpb24gPT0gXCJ2ZXJ0aWNhbFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInZlcnRpY2FsXCI7XG5cbiAgICAgICAgICAgIHJldHVybiBcImhvcml6b250YWxcIjtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnZlcnRFbGVtZW50U2l6ZSA9IHVzZUNhbGxiYWNrKChlbGVtZW50U2l6ZTogRWxlbWVudFNpemUsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCk6IExvZ2ljYWxFbGVtZW50U2l6ZSB8IG51bGwgPT4ge1xuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5saW5lU2l6ZSwgYmxvY2tTaXplLCBpbmxpbmVEaXJlY3Rpb24sIGJsb2NrRGlyZWN0aW9uIH0gPSBkaXJlY3Rpb247XG5cbiAgICAgICAgICAgIC8vIFNpemUgaXMgcmVsYXRpdmVseSBzaW1wbGVcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudElubGluZVNpemUgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGlubGluZVNpemUpfWBdO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50QmxvY2tTaXplID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShibG9ja1NpemUpfWBdO1xuXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRJbmxpbmVTaXplID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShpbmxpbmVTaXplKX1gXTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldEJsb2NrU2l6ZSA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoYmxvY2tTaXplKX1gXTtcblxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsSW5saW5lU2l6ZSA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoaW5saW5lU2l6ZSl9YF07XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxCbG9ja1NpemUgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGJsb2NrU2l6ZSl9YF07XG5cblxuXG5cbiAgICAgICAgICAgIGNvbnN0IGYxID0gZ2V0UGh5c2ljYWxMZWZ0VG9wKGlubGluZURpcmVjdGlvbik7XG4gICAgICAgICAgICBjb25zdCBmMiA9IGdldFBoeXNpY2FsUmlnaHRCb3R0b20oaW5saW5lRGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgY29uc3QgZjMgPSBnZXRQaHlzaWNhbExlZnRUb3AoYmxvY2tEaXJlY3Rpb24pO1xuICAgICAgICAgICAgY29uc3QgZjQgPSBnZXRQaHlzaWNhbFJpZ2h0Qm90dG9tKGJsb2NrRGlyZWN0aW9uKTtcblxuXG4gICAgICAgICAgIGNvbnN0IGNsaWVudElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmMSl9YF0gKyAoIWYyID8gMCA6IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjIpfWBdKTtcbiAgICAgICAgICAgY29uc3Qgc2Nyb2xsSW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGYxKX1gXSArICghZjIgPyAwIDogZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMil9YF0pO1xuICAgICAgICAgICBjb25zdCBvZmZzZXRJbmxpbmVJbnNldCA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjEpfWBdID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IChlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYxKX1gXSEgKyAoIWYyID8gMCA6IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjIpfWBdISkpO1xuXG5cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudEJsb2NrSW5zZXQgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGYzKX1gXSArICghZjQgPyAwIDogZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmNCl9YF0pO1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQmxvY2tJbnNldCA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjMpfWBdICsgKCFmNCA/IDAgOiBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGY0KX1gXSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMyl9YF0gPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogKGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjMpfWBdISArICghZjQgPyAwIDogZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmNCl9YF0hKSk7XG5cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjbGllbnRJbmxpbmVTaXplLFxuICAgICAgICAgICAgICAgIHNjcm9sbElubGluZVNpemUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0SW5saW5lU2l6ZSxcbiAgICAgICAgICAgICAgICBjbGllbnRCbG9ja1NpemUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsQmxvY2tTaXplLFxuICAgICAgICAgICAgICAgIG9mZnNldEJsb2NrU2l6ZSxcbiAgICAgICAgICAgICAgICBjbGllbnRJbmxpbmVJbnNldCxcbiAgICAgICAgICAgICAgICBzY3JvbGxJbmxpbmVJbnNldCxcbiAgICAgICAgICAgICAgICBvZmZzZXRJbmxpbmVJbnNldCxcbiAgICAgICAgICAgICAgICBjbGllbnRCbG9ja0luc2V0LFxuICAgICAgICAgICAgICAgIHNjcm9sbEJsb2NrSW5zZXQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0QmxvY2tJbnNldCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTG9naWNhbERpcmVjdGlvblByb3BzOiB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KSA9PiB1c2VSZWZFbGVtZW50UHJvcHModXNlRWxlbWVudFNpemVQcm9wcyhwcm9wcykpLCBbXSksXG4gICAgICAgIGdldEVsZW1lbnQsXG4gICAgICAgIGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvLFxuICAgICAgICBjb252ZXJ0VG9Mb2dpY2FsU2l6ZTogY29udmVydEVsZW1lbnRTaXplLFxuICAgICAgICBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb24sXG4gICAgICAgIGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb24sXG4gICAgICAgIGNvbnZlcnRUb0xvZ2ljYWxTaWRlLFxuICAgICAgICBjb252ZXJ0VG9QaHlzaWNhbFNpZGVcbiAgICB9O1xufVxuXG4vLyBQb3NpdGlvbiByZXF1aXJlcyB1cyB0byBzb21ldGltZXMgdXNlIG9uZSBwcm9wZXJ0eSAobGlrZSBgbGVmdGApXG4vLyBvciBzb21ldGltZXMgdHdvIChsaWtlIGBsZWZ0YCArIGB3aWR0aGApXG5mdW5jdGlvbiBnZXRQaHlzaWNhbExlZnRUb3AoZGlyOiBQaHlzaWNhbERpcmVjdGlvbikgeyBpZiAoZGlyID09PSBcImx0clwiIHx8IGRpciA9PSBcInJ0bFwiKSByZXR1cm4gXCJsZWZ0XCI7IHJldHVybiBcInRvcFwiOyB9XG5mdW5jdGlvbiBnZXRQaHlzaWNhbFJpZ2h0Qm90dG9tKGRpcjogUGh5c2ljYWxEaXJlY3Rpb24pIHsgaWYgKGRpciA9PT0gXCJydGxcIikgcmV0dXJuIFwid2lkdGhcIjsgaWYgKGRpciA9PT0gXCJidHRcIikgcmV0dXJuIFwiaGVpZ2h0XCI7IHJldHVybiBudWxsOyB9XG5cbi8vIEhlbHBlciBmb3IgZXh0cmFjdGluZyBpbmZvIGZyb20gXCJsdHJcIiwgXCJ0dGJcIiwgZXRjLlxuY29uc3QgTSA9IHtcbiAgICB0OiBcInRvcFwiLFxuICAgIGI6IFwiYm90dG9tXCIsXG4gICAgbDogXCJsZWZ0XCIsXG4gICAgcjogXCJyaWdodFwiXG59IGFzIGNvbnN0O1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTG9naWNhbERpcmVjdGlvblJldHVyblR5cGU8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xuICAgIGdldEVsZW1lbnQ6ICgpID0+IFQgfCBudWxsO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0TG9naWNhbERpcmVjdGlvbkluZm86ICgpID0+IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoZSBFbGVtZW50U2l6ZSBpbmZvIGZyb20gdXNlRWxlbWVudFNpemUsIGNvbnZlcnRzIGFsbCB0aG9zZSBwaHlzaWNhbCBwcm9wZXJ0aWVzIHRvIHRoZWlyIGxvZ2ljYWwgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGNvbnZlcnRUb0xvZ2ljYWxTaXplOiAoZWxlbWVudFNpemU6IEVsZW1lbnRTaXplLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IExvZ2ljYWxFbGVtZW50U2l6ZSB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBgXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCJgIGludG8gYFwiaW5saW5lXCIgfCBcImJsb2NrXCJgXG4gICAgICovXG4gICAgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uOiAoZWxlbWVudE9yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaW5saW5lXCIgfCBcImJsb2NrXCI7XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBgXCJpbmxpbmVcIiB8IFwiYmxvY2tcImAgaW50byBgXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCJgXG4gICAgICovXG4gICAgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbjogKGVsZW1lbnRPcmllbnRhdGlvbjogTG9naWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiO1xuXG4gICAgLyoqXG4gICAgICogVHVybnMgYFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCJgIGludG8gYFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIgfCBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCJgXG4gICAgICovXG4gICAgY29udmVydFRvTG9naWNhbFNpZGU6IChzaWRlOiBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcIiB8IFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCI7XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIiB8IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcImAgaW50byBgXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcImBcbiAgICAgKi9cbiAgICBjb252ZXJ0VG9QaHlzaWNhbFNpZGU6IChzaWRlOiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCI7XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2ljYWxEaXJlY3Rpb25JbmZvIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBkaXJlY3Rpb24gdGV4dCBmbG93cywgZ2x5cGggYnkgZ2x5cGguICBCeSBmYXIgdGhlIG1vc3QgY29tcGxleCBwcm9wZXJ0eS5cbiAgICAgKiBcbiAgICAgKiB8YHdyaXRpbmctbW9kZWB8YGRpcmVjdGlvbmB8UmVzdWx0fFxuICAgICAqIHwtLS0tLXwtLS0tLXwtLS0tLXxcbiAgICAgKiB8YGhvcml6b250YWwtdGJgfGBsdHJgfGBsdHJgfFxuICAgICAqIHxgaG9yaXpvbnRhbC10YmB8YHJ0bGB8YHJ0bGB8XG4gICAgICogfGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgfGBsdHJgfGB0dGJgfFxuICAgICAqIHxgdmVydGljYWwtcmxgICYgYHNpZGV3YXlzLXJsYHxgcnRsYHxgYnR0YHxcbiAgICAgKiB8YHZlcnRpY2FsLWxyYHxgbHRyYHxgdHRiYHxcbiAgICAgKiB8YHZlcnRpY2FsLWxyYHxgcnRsYHxgYnR0YHxcbiAgICAgKiB8YHNpZGV3YXlzLWxyYHxgbHRyYHxgYnR0YHxcbiAgICAgKiB8YHNpZGV3YXlzLWxyYHxgcnRsYHxgdHRiYHxcbiAgICAgKi9cbiAgICBpbmxpbmVEaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU2ltcGxpZmllZCB2ZXJzaW9uIG9mIGBpbmxpbmVEaXJlY3Rpb25gOlxuICAgICAqIFxuICAgICAqICogYGhvcml6b250YWxgIGZvciBgaG9yaXpvbnRhbC10YmBcbiAgICAgKiAqIGB2ZXJ0aWNhbGAgZm9yIGFsbCBvdGhlcnNcbiAgICAgKi9cbiAgICBpbmxpbmVPcmllbnRhdGlvbjogUGh5c2ljYWxPcmllbnRhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGRpcmVjdGlvbiB0ZXh0IGZsb3dzLCBsaW5lIGJ5IGxpbmUuXG4gICAgICogXG4gICAgICogKiBgdHRiYCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYHJ0bGAgZm9yIGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYGx0cmAgZm9yIGB2ZXJ0aWNhbC1scmAgJiBgc2lkZXdheXMtbHJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqL1xuICAgIGJsb2NrRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFNpbXBsaWZpZWQgdmVyc2lvbiBvZiBgYmxvY2tEaXJlY3Rpb25gOlxuICAgICAqIFxuICAgICAqICogYHZlcnRpY2FsYCBmb3IgYGhvcml6b250YWwtdGJgXG4gICAgICogKiBgaG9yaXpvbnRhbGAgZm9yIGFsbCBvdGhlcnNcbiAgICAgKi9cbiAgICBibG9ja09yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBob3cgeW91IGNhbiAqcGh5c2ljYWxseSogcmVmZXIgdG8gdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgaW4gdGhlICppbmxpbmUqIHNpemUuXG4gICAgICogXG4gICAgICogKiBgd2lkdGhgIGZvciBgaG9yaXpvbnRhbC10YmAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXG4gICAgICogKiBgaGVpZ2h0YCBmb3IgYWxsIG90aGVyc1xuICAgICAqL1xuICAgIGlubGluZVNpemU6IFBoeXNpY2FsU2l6ZTtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgaG93IHlvdSBjYW4gKnBoeXNpY2FsbHkqIHJlZmVyIHRvIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IGluIHRoZSAqYmxvY2sqIHNpemUuXG4gICAgICogXG4gICAgICogKiBgaGVpZ2h0YCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYHdpZHRoYCBmb3IgYWxsIG90aGVyc1xuICAgICAqL1xuICAgIGJsb2NrU2l6ZTogUGh5c2ljYWxTaXplO1xuXG4gICAgLyoqXG4gICAgICogRm9yIGVhY2ggZ2x5cGgsIGFzY2VuZGVycyB0byBkZXNjZW5kZXJzICpwaHlzaWNhbGx5KiBnbzpcbiAgICAgKiBcbiAgICAgKiAqIGB0dGJgIGZvciBgaG9yaXpvbnRhbC10YmBcbiAgICAgKiAqIGBydGxgIGZvciBgdmVydGljYWwtcmxgLCBgdmVydGljYWwtbHJgLCAmIGBzaWRld2F5cy1ybGBcbiAgICAgKiAqIGBsdHJgIGZvciBgc2lkZXdheXMtbHJgXG4gICAgICovXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEZvciBlYWNoIGdseXBoLCBpdHMgXCJsZWZ0XCIgc2lkZSAodGhpbmsgb2YgdGhpcyByZWxhdGl2ZSB0byBgd3JpdGluZy1tb2RlYCBidXQgKm5vdCogcmVsYXRpdmUgdG8gYGRpcmVjdGlvbmAsIG9yIGFsdGVybmF0aXZlbHkgd2hhdCBgdGV4dC1hbGlnbjogbGVmdGAgbWVhbnMpIHRvIGl0cyBcInJpZ2h0XCIgc2lkZSAqcGh5c2ljYWxseSogZ29lcyBmcm9tOlxuICAgICAqIFxuICAgICAqICogYGx0cmAgZm9yIGBob3Jpem9udGFsLXRiYFxuICAgICAqICogYHR0YmAgZm9yIGB2ZXJ0aWNhbC1ybGAsIGB2ZXJ0aWNhbC1scmAsICYgYHNpZGV3YXlzLXJsYFxuICAgICAqICogYGJ0dGAgZm9yIGBzaWRld2F5cy1scmBcbiAgICAgKi9cbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xufVxuXG5jb25zdCBIb3Jpem9udGFsVGJMdHI6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIGlubGluZURpcmVjdGlvbjogXCJsdHJcIixcbiAgICBibG9ja0RpcmVjdGlvbjogXCJ0dGJcIixcblxuICAgIGlubGluZU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICBibG9ja09yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXG5cbiAgICBpbmxpbmVTaXplOiBcIndpZHRoXCIsXG4gICAgYmxvY2tTaXplOiBcImhlaWdodFwiLFxuXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcImx0clwiLFxuICAgIG92ZXJVbmRlckRpcmVjdGlvbjogXCJ0dGJcIlxufTtcblxuY29uc3QgSG9yaXpvbnRhbFRiUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5Ib3Jpem9udGFsVGJMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInJ0bFwiLFxufTtcblxuY29uc3QgVmVydGljYWxSbEx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiLFxuICAgIGJsb2NrRGlyZWN0aW9uOiBcInJ0bFwiLFxuXG4gICAgaW5saW5lT3JpZW50YXRpb246IFwidmVydGljYWxcIixcbiAgICBibG9ja09yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcblxuICAgIGlubGluZVNpemU6IFwiaGVpZ2h0XCIsXG4gICAgYmxvY2tTaXplOiBcIndpZHRoXCIsXG5cbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwidHRiXCIsXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcInJ0bFwiXG59O1xuXG5jb25zdCBWZXJ0aWNhbFJsUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5WZXJ0aWNhbFJsTHRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIlxufTtcblxuXG5jb25zdCBTaWRld2F5c1JsTHRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHsgLi4uVmVydGljYWxSbEx0ciB9O1xuY29uc3QgU2lkZXdheXNSbFJ0bDogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7IC4uLlZlcnRpY2FsUmxSdGwgfTtcblxuY29uc3QgVmVydGljYWxMckx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgLi4uVmVydGljYWxSbEx0cixcbiAgICBibG9ja0RpcmVjdGlvbjogXCJsdHJcIixcbn07XG5cbmNvbnN0IFZlcnRpY2FsTHJSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLlZlcnRpY2FsUmxSdGwsXG4gICAgYmxvY2tEaXJlY3Rpb246IFwibHRyXCIsXG59O1xuXG5jb25zdCBTaWRld2F5c0x0THRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5WZXJ0aWNhbExyTHRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIixcblxuICAgIGxlZnRSaWdodERpcmVjdGlvbjogXCJidHRcIixcbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFwibHRyXCJcbn07XG5cbmNvbnN0IFNpZGV3YXlzTHRSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLlNpZGV3YXlzTHRMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiXG59O1xuXG5cblxuY29uc3QgSG9yaXpvbnRhbFRiID0ge1xuICAgIGx0cjogSG9yaXpvbnRhbFRiTHRyLFxuICAgIHJ0bDogSG9yaXpvbnRhbFRiUnRsXG59IGFzIGNvbnN0O1xuXG5jb25zdCBWZXJ0aWNhbFJsID0ge1xuICAgIGx0cjogVmVydGljYWxSbEx0cixcbiAgICBydGw6IFZlcnRpY2FsUmxSdGxcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IFZlcnRpY2FsTHIgPSB7XG4gICAgbHRyOiBWZXJ0aWNhbExyTHRyLFxuICAgIHJ0bDogVmVydGljYWxMclJ0bFxufSBhcyBjb25zdDtcblxuY29uc3QgU2lkZXdheXNSbCA9IHtcbiAgICBsdHI6IFNpZGV3YXlzUmxMdHIsXG4gICAgcnRsOiBTaWRld2F5c1JsUnRsXG59IGFzIGNvbnN0O1xuXG5jb25zdCBTaWRld2F5c0xyID0ge1xuICAgIGx0cjogU2lkZXdheXNMdEx0cixcbiAgICBydGw6IFNpZGV3YXlzTHRSdGxcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IFdyaXRpbmdNb2RlcyA9IHtcbiAgICBcImhvcml6b250YWwtdGJcIjogSG9yaXpvbnRhbFRiLFxuICAgIFwidmVydGljYWwtbHJcIjogVmVydGljYWxMcixcbiAgICBcInZlcnRpY2FsLXJsXCI6IFZlcnRpY2FsUmwsXG4gICAgXCJzaWRld2F5cy1sclwiOiBTaWRld2F5c0xyLFxuICAgIFwic2lkZXdheXMtcmxcIjogU2lkZXdheXNSbFxufSBhcyBjb25zdDtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUaW1lb3V0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2AuICBcbiAgICAgKiBJZiBgbnVsbGAsIGNhbmNlbHMgdGhlIHRpbWVvdXQgaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgdGltZW91dDogbnVtYmVyIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdG8gdGhpcyBwcm9wIGJldHdlZW4gcmVuZGVycyBjYW4gYmUgdXNlZCB0byBjbGVhciB0aGUgY3VycmVudCB0aW1lb3V0IGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqL1xuICAgIHRyaWdnZXJJbmRleD86IHVua25vd247XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYHRpbWVvdXRgIG1zIGFmdGVyIG1vdW50LCBvciB0aGUgbGFzdCBjaGFuZ2UgdG8gYHRyaWdnZXJJbmRleGAuXG4gICAgICogXG4gICAgICogRG9lcyAqbm90KiBuZWVkIHRvIGJlIHN0YWJsZS4gR28gYWhlYWQgYW5kIHBhc3MgYW4gYW5vbnltb3VzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVGltZW91dCh7IHRpbWVvdXQsIGNhbGxiYWNrLCB0cmlnZ2VySW5kZXggfTogVXNlVGltZW91dCkge1xuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBzdGFydFRpbWVSZWYuY3VycmVudCA9IG51bGw7IGNhbGxiYWNrKCk7IH0pO1xuICAgIGNvbnN0IGdldFRpbWVvdXQgPSB1c2VTdGFibGVHZXR0ZXIodGltZW91dCk7XG5cbiAgICAvLyBTZXQgYW55IHRpbWUgd2Ugc3RhcnQgdGltZW91dC5cbiAgICAvLyBVbnNldCBhbnkgdGltZSB0aGUgdGltZW91dCBjb21wbGV0ZXNcbiAgICBjb25zdCBzdGFydFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCB0aW1lb3V0SXNOdWxsID0gKHRpbWVvdXQgPT0gbnVsbCk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgdHJpZ2dlckluZGV4IGNoYW5nZXMgKGluY2x1ZGluZyBvbiBtb3VudClcbiAgICAvLyByZXN0YXJ0IHRoZSB0aW1lb3V0LiAgVGhlIHRpbWVvdXQgZG9lcyBOT1QgcmVzZXRcbiAgICAvLyB3aGVuIHRoZSBkdXJhdGlvbiBvciBjYWxsYmFjayBjaGFuZ2VzLCBvbmx5IHRyaWdnZXJJbmRleC5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRpbWVvdXRJc051bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aW1lb3V0SXNOdWxsID09ICh0aW1lb3V0ID09IG51bGwpKTtcbiAgICBcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVSZWYuY3VycmVudCA9ICsobmV3IERhdGUoKSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChzdGFibGVDYWxsYmFjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sIFt0cmlnZ2VySW5kZXgsIHRpbWVvdXRJc051bGxdKVxuXG4gICAgY29uc3QgZ2V0RWxhcHNlZFRpbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKyhuZXcgRGF0ZSgpKSkgLSAoKyhzdGFydFRpbWVSZWYuY3VycmVudCA/PyBuZXcgRGF0ZSgpKSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0UmVtYWluaW5nVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgcmV0dXJuIHRpbWVvdXQgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1heCgwLCB0aW1lb3V0IC0gZ2V0RWxhcHNlZFRpbWUoKSlcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyBnZXRFbGFwc2VkVGltZSwgZ2V0UmVtYWluaW5nVGltZSB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5pbXBvcnQgeyBNYW5hZ2VkQ2hpbGRJbmZvQmFzZSB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtbGF5b3V0LWVmZmVjdFwiO1xuaW1wb3J0IHsgdXNlTG9naWNhbERpcmVjdGlvbiB9IGZyb20gXCIuL3VzZS1sb2dpY2FsLWRpcmVjdGlvblwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VUaW1lb3V0IH0gZnJvbSBcIi4vdXNlLXRpbWVvdXRcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCJ1c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIC8qKiBcbiAgICAgKiBUaGVzZSBwcm9wcyBjYW4gYmUgYXR0YXRjaGVkIGVpdGhlciB0byB0aGUgcGFyZW50IG9yIHRvIGVhY2ggaW5kaXZpZHVhbCBjaGlsZC5cbiAgICAgKiBXaGljaGV2ZXIgd29ya3MgYmV0dGVyIGZvciB5b3VyIHNjZW5hcmlvLlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKiogXG4gICAgICogKi9cbiAgICB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD47XG59XG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwYXJlbnQgYHVzZUxpbmVhck5hdmlnYXRpb25gICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzIHtcbiAgICBuYXZpZ2F0ZVRvTmV4dCgpOiB2b2lkO1xuICAgIG5hdmlnYXRlVG9QcmV2KCk6IHZvaWQ7XG4gICAgbmF2aWdhdGVUb0ZpcnN0KCk6IHZvaWQ7XG4gICAgbmF2aWdhdGVUb0xhc3QoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDb250cm9scyB3aGljaCBhcnJvdyBrZXlzIGFyZSB1c2VkIHRvIG5hdmlnYXRlIHRocm91Z2ggdGhlIGNvbXBvbmVudC5cbiAgICAgKiBSZWxhdGl2ZSB0byB0aGUgd3JpdGluZyBtb2RlLCBzbyBpbiBFbmdsaXNoLCBcImlubGluZVwiIGNvcnJlc3BvbmRzXG4gICAgICogdG8gdGhlIGxlZnQgJiByaWdodCBhcnJvdyBrZXlzLCBhbmQgXCJibG9ja1wiIHRvIHRoZSB1cCAmIGRvd24gYXJyb3cga2V5cy5cbiAgICAgKiBcbiAgICAgKiBVc2UgXCJlaXRoZXJcIiB0byBhbGxvdyBuYXZpZ2F0aW9uIGluIGVpdGhlciBkaXJlY3Rpb24uXG4gICAgICogXG4gICAgICogVXNlIFwibm9uZVwiIHRvIGRpc2FsbG93IG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyBpbiBhbnkgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24/OiBcImlubGluZVwiIHwgXCJibG9ja1wiIHwgXCJlaXRoZXJcIiB8IFwibm9uZVwiO1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlIFxuICAgICAqIGRpc2FibGVkLCBidXQgbmF2aWdhdGlvbiB3aXRoIHRoZSBob21lICYgZW5kIGtleXMgd2lsbFxuICAgICAqIGJlIHVuYWZmZWN0ZWQuXG4gICAgICovXG4gICAgZGlzYWJsZUFycm93S2V5cz86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgbmF2aWdhdGlvbiB3aXRoIHRoZSBob21lICYgZW5kIGtleXMgd2lsbFxuICAgICAqIGJlIGRpc2FibGVkLCBidXQgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIHdpbGwgYmVcbiAgICAgKiB1bmFmZmVjdGVkLlxuICAgICAqL1xuICAgIGRpc2FibGVIb21lRW5kS2V5cz86IGJvb2xlYW47XG5cbn1cblxuXG4vKiogQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgY2hpbGQgJ3VzZUxpbmVhck5hdmlnYXRpb25DaGlsZGAgKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkSW5mbyBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm9CYXNlPG51bWJlcj4geyB9XG5cbi8qKlxuICogV2hlbiB1c2VkIGluIHRhbmRlbSB3aXRoIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGFsbG93cyBjb250cm9sIG9mXG4gKiB0aGUgdGFiYmFibGUgaW5kZXggd2l0aCB0aGUgYXJyb3cga2V5cy5cbiAqIFxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmVhck5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQ+KHsgbmF2aWdhdGVUb0ZpcnN0OiBudGYsIG5hdmlnYXRlVG9MYXN0OiBudGwsIG5hdmlnYXRlVG9OZXh0OiBudG4sIG5hdmlnYXRlVG9QcmV2OiBudHAsIG5hdmlnYXRpb25EaXJlY3Rpb246IG5kLCBkaXNhYmxlQXJyb3dLZXlzOiBkYWssIGRpc2FibGVIb21lRW5kS2V5czogZGhlayB9OiBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyk6IFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XG5cbiAgICBuZCA/Pz0gXCJlaXRoZXJcIjtcblxuICAgIGNvbnN0IHsgZ2V0TG9naWNhbERpcmVjdGlvbkluZm8sIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wcyB9ID0gdXNlTG9naWNhbERpcmVjdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe30pO1xuXG4gICAgY29uc3QgbmF2aWdhdGVUb0ZpcnN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRmKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTGFzdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG50bCk7XG4gICAgY29uc3QgbmF2aWdhdGVUb05leHQgPSB1c2VTdGFibGVDYWxsYmFjayhudG4pO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9QcmV2ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRwKTtcbiAgICBjb25zdCBnZXREaXNhYmxlQXJyb3dLZXlzID0gdXNlU3RhYmxlR2V0dGVyKGRhayk7XG4gICAgY29uc3QgZ2V0RGlzYWJsZUhvbWVFbmRLZXlzID0gdXNlU3RhYmxlR2V0dGVyKGRoZWspO1xuICAgIGNvbnN0IGdldE5hdmlnYXRpb25EaXJlY3Rpb24gPSB1c2VTdGFibGVHZXR0ZXIobmQpO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHM6IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+ID0+IHtcblxuICAgICAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCBieSB0eXBlYWhlYWQgKGkuZS4gYXNzdW1lIHRoaXMgaXMgYSBrZXlib2FyZCBzaG9ydGN1dClcbiAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmF2aWdhdGlvbkRpcmVjdGlvbiA9IGdldE5hdmlnYXRpb25EaXJlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNhYmxlQXJyb3dLZXlzID0gZ2V0RGlzYWJsZUFycm93S2V5cygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FibGVIb21lRW5kS2V5cyA9IGdldERpc2FibGVIb21lRW5kS2V5cygpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsb3dzQmxvY2tOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJibG9ja1wiIHx8IG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJlaXRoZXJcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsb3dzSW5saW5lTmF2aWdhdGlvbiA9IChuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiaW5saW5lXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBhbGxvd3NCbG9ja05hdmlnYXRpb24gOiBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcImJ0dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBhbGxvd3NCbG9ja05hdmlnYXRpb24gOiBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcImJ0dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImlubGluZURpcmVjdGlvblwiIDogXCJibG9ja0RpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IGFsbG93c0lubGluZU5hdmlnYXRpb24gOiBhbGxvd3NCbG9ja05hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwicnRsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJpbmxpbmVEaXJlY3Rpb25cIiA6IFwiYmxvY2tEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uIDogYWxsb3dzQmxvY2tOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcInJ0bFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlSG9tZUVuZEtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvRmlyc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJFbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZUhvbWVFbmRLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdXNlTG9naWNhbERpcmVjdGlvblByb3BzKHVzZU1lcmdlZFByb3BzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7IG9uS2V5RG93biB9LCBwcm9wcykpXG4gICAgICAgIH0sIFtdKSxcbiAgICB9XG5cblxufVxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEkgZXh0ZW5kcyBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRJbmZvPiB7XG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHVzZWQgb24gZWl0aGVyIHRoZSBwYXJlbnQgb3IgZWFjaCBjaGlsZCBlbGVtZW50LlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD47XG5cbiAgICAvLyBNdXN0IGJlIHVzZWQgb24gZWFjaCBjaGlsZCBlbGVtZW50LlxuICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkPEk+O1xuXG5cbiAgICBjdXJyZW50VHlwZWFoZWFkOiBzdHJpbmcgfCBudWxsO1xuICAgIGludmFsaWRUeXBlYWhlYWQ6IGJvb2xlYW4gfCBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+ID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlID0gdm9pZDtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzIHtcblxuICAgIC8qKlxuICAgICAqIEEgY29sbGF0b3IgdG8gdXNlIHdoZW4gY29tcGFyaW5nLiBJZiBub3QgcHJvdmlkZWQsIHNpbXBseSB1c2VzIGBsb2NhbGVDb21wYXJlYCBhZnRlciB0cmFuc2Zvcm1pbmcgZWFjaCB0byBsb3dlcmNhc2UsIHdoaWNoIHdpbGwsIGF0IGJlc3QsIHdvcmsgb2theSBpbiBFbmdsaXNoLlxuICAgICAqL1xuICAgIGNvbGxhdG9yPzogSW50bC5Db2xsYXRvcjtcblxuICAgIG5vVHlwZWFoZWFkPzogYm9vbGVhbjtcblxuICAgIHR5cGVhaGVhZFRpbWVvdXQ/OiBudW1iZXI7XG4gICAgZ2V0SW5kZXgoKTogbnVtYmVyIHwgbnVsbDtcbiAgICBzZXRJbmRleCh2YWx1ZTogbnVtYmVyIHwgbnVsbCB8ICgocHJldmlvdXNWYWx1ZTogbnVtYmVyIHwgbnVsbCkgPT4gKG51bWJlciB8IG51bGwpKSk6IHZvaWQ7XG59XG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjaGlsZCAndXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkYCAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRJbmZvIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mb0Jhc2U8bnVtYmVyPiB7XG4gICAgLyoqXG4gICAgICogSWYgcHJvdmlkZWQsIGFsbG93cyB0aGlzIGNvbXBvbmVudCB0byBiZSBuYXZpZ2F0ZWQgdG8gYnkgdHlwaW5nIHRoaXMgc3RyaW5nLiBcbiAgICAgKiBJdCBzaG91bGQgYmUgdGhlIHNhbWUgdGV4dCBjb250ZW50IGFzIHdoYXRldmVyJ3MgZGlzcGxheWVkLCBpZGVhbGx5LlxuICAgICAqL1xuICAgIHRleHQ6IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyBleHRlbmRzIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZEluZm8geyB9XG5cbi8qKiBUeXBlIG9mIHRoZSBjaGlsZCdzIHN1Yi1ob29rICovXG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ8SSBleHRlbmRzIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZEluZm8+ID0gKHsgdGV4dCwgaW5kZXgsIC4uLmkgfTogUGljazxJLCBcInRleHRcIiB8IFwiaW5kZXhcIj4pID0+IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU7XG5cblxuLyoqXG4gKiBBbGxvd3MgZm9yIHRoZSBzZWxlY3Rpb24gb2YgYSBtYW5hZ2VkIGNoaWxkIGJ5IHR5cGluZyB0aGUgZ2l2ZW4gdGV4dCBhc3NvY2lhdGVkIHdpdGggaXQuXG4gKiBcbiAqIEBzZWUgdXNlTGlzdE5hdmlnYXRpb24sIHdoaWNoIHBhY2thZ2VzIGV2ZXJ5dGhpbmcgdXAgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSSBleHRlbmRzIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZEluZm8+KHsgY29sbGF0b3IsIGdldEluZGV4LCB0eXBlYWhlYWRUaW1lb3V0LCBzZXRJbmRleCwgbm9UeXBlYWhlYWQgfTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMpOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCwgST4ge1xuXG5cbiAgICAvLyBGb3IgdHlwZWFoZWFkLCBrZWVwIHRyYWNrIG9mIHdoYXQgb3VyIGN1cnJlbnQgXCJzZWFyY2hcIiBzdHJpbmcgaXMgKGlmIHdlIGhhdmUgb25lKVxuICAgIC8vIGFuZCBhbHNvIGNsZWFyIGl0IGV2ZXJ5IDEwMDAgbXMgc2luY2UgdGhlIGxhc3QgdGltZSBpdCBjaGFuZ2VkLlxuICAgIC8vIE5leHQsIGtlZXAgYSBtYXBwaW5nIG9mIHR5cGVhaGVhZCB2YWx1ZXMgdG8gaW5kaWNlcyBmb3IgZmFzdGVyIHNlYXJjaGluZy5cbiAgICAvLyBBbmQsIGZvciB0aGUgdXNlcidzIHNha2UsIGxldCB0aGVtIGtub3cgd2hlbiB0aGVpciB0eXBlYWhlYWQgY2FuJ3QgbWF0Y2ggYW55dGhpbmcgYW55bW9yZVxuICAgIGNvbnN0IFtjdXJyZW50VHlwZWFoZWFkLCBzZXRDdXJyZW50VHlwZWFoZWFkLCBnZXRDdXJyZW50VHlwZWFoZWFkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIHVzZVRpbWVvdXQoeyB0aW1lb3V0OiB0eXBlYWhlYWRUaW1lb3V0ID8/IDEwMDAsIGNhbGxiYWNrOiAoKSA9PiB7IHNldEN1cnJlbnRUeXBlYWhlYWQobnVsbCk7IHNldEludmFsaWRUeXBlYWhlYWQobnVsbCk7IH0sIHRyaWdnZXJJbmRleDogY3VycmVudFR5cGVhaGVhZCB9KTtcbiAgICBjb25zdCBzb3J0ZWRUeXBlYWhlYWRJbmZvID0gdXNlUmVmPHsgdGV4dDogc3RyaW5nLCB1bnNvcnRlZEluZGV4OiBudW1iZXIgfVtdPihbXSk7XG4gICAgY29uc3QgW2ludmFsaWRUeXBlYWhlYWQsIHNldEludmFsaWRUeXBlYWhlYWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KGZhbHNlKTtcblxuICAgIC8vIEhhbmRsZSB0eXBlYWhlYWQgZm9yIGlucHV0IG1ldGhvZCBlZGl0b3JzIGFzIHdlbGxcbiAgICAvLyBFc3NlbnRpYWxseSwgd2hlbiBhY3RpdmUsIGlnbm9yZSBmdXJ0aGVyIGtleXMgXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSB3YWl0aW5nIGZvciBhIENvbXBvc2l0aW9uRW5kIGV2ZW50XG4gICAgY29uc3QgWywgc2V0SW1lQWN0aXZlLCBnZXRJbWVBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy8gQmVjYXVzZSBjb21wb3NpdGlvbiBldmVudHMgZmlyZSAqYWZ0ZXIqIGtleWRvd24gZXZlbnRzIFxuICAgIC8vIChidXQgd2l0aGluIHRoZSBzYW1lIHRhc2ssIHdoaWNoLCBUT0RPLCBjb3VsZCBiZSBicm93c2VyLWRlcGVuZGVudCksXG4gICAgLy8gd2UgY2FuIHVzZSB0aGlzIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnQgd2UncmUgbGlzdGVuaW5nIGZvciBvbiB0aGUgZmlyc3Qga2V5ZG93bi5cbiAgICBjb25zdCBbbmV4dFR5cGVhaGVhZENoYXIsIHNldE5leHRUeXBlYWhlYWRDaGFyXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChuZXh0VHlwZWFoZWFkQ2hhciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0Q3VycmVudFR5cGVhaGVhZCh0eXBlYWhlYWQgPT4gKCh0eXBlYWhlYWQgPz8gXCJcIikgKyBuZXh0VHlwZWFoZWFkQ2hhcikpO1xuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIobnVsbCk7XG4gICAgICAgIH1cbiAgICB9LCBbbmV4dFR5cGVhaGVhZENoYXJdKTtcblxuXG4gICAgY29uc3QgY29tcGFyYXRvclNoYXJlZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChzYWZlTGhzOiBzdHJpbmcsIHNhZmVSaHM6IHN0cmluZykgPT4ge1xuICAgICAgICBsZXQgY29tcGFyZTogbnVtYmVyO1xuICAgICAgICAvLyBGb3IgdGhlIHB1cnBvc2VzIG9mIHR5cGVhaGVhZCwgb25seSBjb21wYXJlIGEgc3RyaW5nIG9mIHRoZSBzYW1lIHNpemUgYXMgb3VyIGN1cnJlbnRseSB0eXBlZCBzdHJpbmcuXG4gICAgICAgIC8vIEJ5IG5vcm1hbGl6aW5nIHRoZW0gZmlyc3QsIHdlIGVuc3VyZSB0aGlzIGJ5dGUtYnktYnl0ZSBoYW5kbGluZyBvZiByYXcgY2hhcmFjdGVyIGRhdGEgd29ya3Mgb3V0IG9rYXkuXG4gICAgICAgIHNhZmVMaHMgPSBzYWZlTGhzLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgc2FmZVJocyA9IHNhZmVSaHMubm9ybWFsaXplKFwiTkZEXCIpXG5cbiAgICAgICAgaWYgKGNvbGxhdG9yKVxuICAgICAgICAgICAgY29tcGFyZSA9IGNvbGxhdG9yLmNvbXBhcmUoc2FmZUxocywgc2FmZVJocylcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGFyZSA9IHNhZmVMaHMudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKHNhZmVSaHMudG9Mb3dlckNhc2UoKSA/PyBcIlwiKTtcblxuICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGluc2VydGluZ0NvbXBhcmF0b3IgPSB1c2VTdGFibGVDYWxsYmFjaygobGhzOiBJW1widGV4dFwiXSwgcmhzOiB7IHRleHQ6IElbXCJ0ZXh0XCJdOyB1bnNvcnRlZEluZGV4OiBudW1iZXI7IH0pID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmhzLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yU2hhcmVkKGxocywgcmhzLnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChsaHMgYXMgdW5rbm93biBhcyBudW1iZXIpIC0gKHJocyBhcyB1bmtub3duIGFzIG51bWJlcik7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0eXBlYWhlYWRDb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxoczogSVtcInRleHRcIl0sIHJoczogeyB0ZXh0OiBJW1widGV4dFwiXTsgdW5zb3J0ZWRJbmRleDogbnVtYmVyOyB9KSA9PiB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJocy50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBEdXJpbmcgdHlwZWFoZWFkLCBhbGwgc3RyaW5ncyBsb25nZXIgdGhhbiBvdXJzIHNob3VsZCBiZSB0cnVuY2F0ZWRcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhleSdyZSBhbGwgY29uc2lkZXJlZCBlcXVhbGx5IGJ5IHRoYXQgcG9pbnQuXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvclNoYXJlZChsaHMsIHJocy50ZXh0LnN1YnN0cmluZygwLCBsaHMubGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGxocyBhcyB1bmtub3duIGFzIG51bWJlcikgLSAocmhzIGFzIHVua25vd24gYXMgbnVtYmVyKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSB1c2VTdGFibGVHZXR0ZXIobm9UeXBlYWhlYWQpO1xuXG5cbiAgICBjb25zdCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD4gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xuXG4gICAgICAgIGNvbnN0IG9uQ29tcG9zaXRpb25TdGFydCA9IChfZTogQ29tcG9zaXRpb25FdmVudCkgPT4geyBzZXRJbWVBY3RpdmUodHJ1ZSkgfTtcbiAgICAgICAgY29uc3Qgb25Db21wb3NpdGlvbkVuZCA9IChlOiBDb21wb3NpdGlvbkV2ZW50KSA9PiB7XG4gICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihlLmRhdGEpO1xuICAgICAgICAgICAgc2V0SW1lQWN0aXZlKGZhbHNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBvbktleURvd24gPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGNvbnN0IGltZUFjdGl2ZSA9IGdldEltZUFjdGl2ZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBlLmtleTtcblxuICAgICAgICAgICAgLy8gTm90IGhhbmRsZWQgYnkgdHlwZWFoZWFkIChpLmUuIGFzc3VtZSB0aGlzIGlzIGEga2V5Ym9hcmQgc2hvcnRjdXQpXG4gICAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmICghaW1lQWN0aXZlICYmIGUua2V5ID09PSBcIkJhY2tzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsYXN0IGNoYXJhY3RlciBpbiBhIHdheSB0aGF0IGRvZXNuJ3Qgc3BsaXQgVVRGLTE2IHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGVhaGVhZCh0ID0+IHQgPT09IG51bGwgPyBudWxsIDogWy4uLnRdLnJldmVyc2UoKS5zbGljZSgxKS5yZXZlcnNlKCkuam9pbihcIlwiKSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUga2V5IHByb3BlcnR5IHJlcHJlc2VudHMgdGhlIHR5cGVkIGNoYXJhY3RlciBPUiB0aGUgXCJuYW1lZCBrZXkgYXR0cmlidXRlXCIgb2YgdGhlIGtleSBwcmVzc2VkLlxuICAgICAgICAgICAgLy8gVGhlcmUncyBubyBkZWZpbml0ZSB3YXkgdG8gdGVsbCB0aGUgZGlmZmVyZW5jZSwgYnV0IGZvciBhbGwgaW50ZW50cyBhbmQgcHVycG9zZXNcbiAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBvbmUtY2hhcmFjdGVyIG5hbWVzLCBhbmQgdGhlcmUgYXJlIG5vIG5vbi1BU0NJSS1hbHBoYSBuYW1lcy5cbiAgICAgICAgICAgIC8vIFRodXMsIGFueSBvbmUtY2hhcmFjdGVyIG9yIG5vbi1BU0NJSSB2YWx1ZSBmb3IgYGtleWAgaXMgKmFsbW9zdCBjZXJ0YWlubHkqIGEgdHlwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgY29uc3QgaXNDaGFyYWN0ZXJLZXkgPSAoa2V5Lmxlbmd0aCA9PT0gMSB8fCAhL15bQS1aYS16XS8udGVzdChrZXkpKTtcbiAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlcktleSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PSBcIiBcIiAmJiAoZ2V0Q3VycmVudFR5cGVhaGVhZCgpID8/IFwiXCIpLnRyaW0oKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBiZWNhdXNlIGEgc3BhY2ViYXIgY2FuJ3QgZXZlciBcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhdGUgYSB0eXBlYWhlYWQsIG9ubHkgY29udGludWUgb25lLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIChTcGVjaWZpY2FsbHksIGxldCB0aGUgZXZlbnQgY29udGludWUgcHJvcGFnYXRpb24gaW4gdGhpcyBjYXNlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogV29uJ3QgYmUgdHJ1ZSBmb3IgdGhlIGZpcnN0IGtleWRvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYmVmb3JlIHVzZUxheW91dEVmZmVjdCBpcyBjYWxsZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYWN0dWFsbHkgYXBwbHkgdGhlIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWltZUFjdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7IG9uS2V5RG93biwgb25Db21wb3NpdGlvblN0YXJ0LCBvbkNvbXBvc2l0aW9uRW5kLCB9LCBwcm9wcyk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gSGFuZGxlIGNoYW5nZXMgaW4gdHlwZWFoZWFkIHRoYXQgY2F1c2UgY2hhbmdlcyB0byB0aGUgdGFiYmFibGUgaW5kZXhcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY3VycmVudFR5cGVhaGVhZCAmJiBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoKSB7XG5cblxuXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRUeXBlYWhlYWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIGN1cnJlbnRUeXBlYWhlYWQsIHR5cGVhaGVhZENvbXBhcmF0b3IpO1xuXG4gICAgICAgICAgICBpZiAoc29ydGVkVHlwZWFoZWFkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgaGFzIHR5cGVkIGFuIGVudHJ5IHRoYXQgZG9lc24ndCBleGlzdCBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIC8vIChvciBtb3JlIHNwZWNpZmljYWxseSBcImZvciB3aGljaCB0aGVyZSBpcyBubyBlbnRyeSB0aGF0IHN0YXJ0cyB3aXRoIHRoYXQgaW5wdXRcIilcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0SW52YWxpZFR5cGVhaGVhZChmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgV2Uga25vdyByb3VnaGx5IHdoZXJlLCBpbiB0aGUgc29ydGVkIGFycmF5IG9mIHN0cmluZ3MsIG91ciBuZXh0IHR5cGVhaGVhZCBsb2NhdGlvbiBpcy5cbiAgICAgICAgICAgICAgICAgIEJ1dCByb3VnaGx5IGlzbid0IGdvb2QgZW5vdWdoIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzLlxuICAgICAgICAgICAgICAgICAgVG8gY29udmVydCBvdXIgc29ydGVkIGluZGV4IHRvIHRoZSB1bnNvcnRlZCBpbmRleCB3ZSBuZWVkLCB3ZSBoYXZlIHRvIGZpbmQgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICBlbGVtZW50IHRoYXQgbWF0Y2hlcyB1cyAqYW5kKiAoaWYgYW55IHN1Y2ggZXhpc3QpIGlzICphZnRlciogb3VyIGN1cnJlbnQgc2VsZWN0aW9uLlxuXG4gICAgICAgICAgICAgICAgICBJbiBvdGhlciB3b3JkcywgdGhlIG9ubHkgd2F5IHR5cGVhaGVhZCBtb3ZlcyBiYWNrd2FyZHMgcmVsYXRpdmUgdG8gb3VyIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIGlzIGlmIHRoZSBvbmx5IG90aGVyIG9wdGlvbiBpcyBiZWhpbmQgdXMuXG5cbiAgICAgICAgICAgICAgICAgIEl0J3Mgbm90IHNwZWNpZmllZCBpbiBXQUktQVJJQSB3aGF0IHRvIGRvIGluIHRoYXQgY2FzZS4gIEkgc3VwcG9zZSB3cmFwIGJhY2sgdG8gdGhlIHN0YXJ0P1xuICAgICAgICAgICAgICAgICAgVGhvdWdoIHRoZXJlJ3MgYWxzbyBhIGNhc2UgZm9yIGp1c3QgZ29pbmcgdXB3YXJkcyB0byB0aGUgbmVhcmVzdCB0byBwcmV2ZW50IGp1bXBpbmVzcy5cbiAgICAgICAgICAgICAgICAgIEJ1dCBpZiB5b3UncmUgYWxyZWFkeSBkb2luZyB0eXBlYWhlYWQgb24gYW4gdW5zb3J0ZWQgbGlzdCwgbGlrZSwganVtcGluZXNzIGNhbid0IGJlIGF2b2lkZWQuXG4gICAgICAgICAgICAgICAgICBJIGR1bm5vLiBHb2luZyBiYWNrIHRvIHRoZSBzdGFydCBpcyB0aGUgc2ltcGxpc3QgdGhvdWdoLlxuXG4gICAgICAgICAgICAgICAgICBCYXNpY2FsbHkgd2hhdCB0aGlzIGRvZXM6IFN0YXJ0aW5nIGZyb20gd2hlcmUgd2UgZm91bmQgb3Vyc2VsdmVzIGFmdGVyIG91ciBiaW5hcnkgc2VhcmNoLFxuICAgICAgICAgICAgICAgICAgc2NhbiBiYWNrd2FyZHMgYW5kIGZvcndhcmRzIHRocm91Z2ggYWxsIGFkamFjZW50IGVudHJpZXMgdGhhdCBhbHNvIGNvbXBhcmUgZXF1YWxseSBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICB3ZSBjYW4gZmluZCB0aGUgb25lIHdob3NlIGB1bnNvcnRlZEluZGV4YCBpcyB0aGUgbG93ZXN0IGFtb25nc3QgYWxsIG90aGVyIGVxdWFsIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgIChhbmQgYWxzbyB0aGUgbG93ZXN0IGB1bnNvcnRlZEluZGV4YCB5YWRkYSB5YWRkYSBleGNlcHQgdGhhdCBpdCBjb21lcyBhZnRlciB1cykuXG5cbiAgICAgICAgICAgICAgICAgIFRPRE86IFRoZSBiaW5hcnkgc2VhcmNoIHN0YXJ0cyB0aGlzIG9mZiB3aXRoIGEgc29saWQgTyhsb2cgbiksIGJ1dCBvbmUtY2hhcmFjdGVyIFxuICAgICAgICAgICAgICAgICAgc2VhcmNoZXMgYXJlLCB0aGFua3MgdG8gcGlnZW9uaG9sZSBwcmluY2lwYWwsIGV2ZW50dWFsbHkgZ3VhcmFudGVlZCB0byBiZWNvbWUgXG4gICAgICAgICAgICAgICAgICBPKG4qbG9nIG4pLiBUaGlzIGlzIGFubm95aW5nIGJ1dCBwcm9iYWJseSBub3QgZWFzaWx5IHNvbHZhYmxlPyBUaGVyZSBjb3VsZCBiZSBhbiBcbiAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiBmb3Igb25lLWNoYXJhY3RlciBzdHJpbmdzLCBidXQgdGhhdCdzIGp1c3Qga2lja2luZyB0aGUgY2FuIGRvd24gXG4gICAgICAgICAgICAgICAgICB0aGUgcm9hZC4gTWF5YmUgb25lIG9yIHR3byBjaGFyYWN0ZXJzIHdvdWxkIGJlIGdvb2QgZW5vdWdoIHRob3VnaC5cbiAgICAgICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjYW5kaWRhdGVzJyBwb3NpdGlvbnMgaW4gYm90aCBvdXIgc29ydGVkIGFycmF5IGFuZCB0aGUgdW5zb3J0ZWQgRE9NLlxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4QWxsOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0U29ydGVkSW5kZXhBbGwgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIHR3byBhcmUgb25seSBzZXQgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIGFoZWFkIG9mIHVzLCBidXQgdGhlIHByaW5jaXBsZSdzIHRoZSBzYW1lIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4TmV4dCA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlQmVzdEZpdCA9ICh1OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgPT0gbnVsbCB8fCB1IDwgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9IHU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleEFsbCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9PSBudWxsIHx8IHUgPCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCkgJiYgdSA+IChnZXRJbmRleCgpID8/IC1JbmZpbml0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ID0gdTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNvcnRlZEluZGV4TmV4dCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgdHlwZWFoZWFkQ29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQmVzdEZpdChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoICYmIHR5cGVhaGVhZENvbXBhcmF0b3IoY3VycmVudFR5cGVhaGVhZCwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBzZXRJbmRleChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbbG93ZXN0U29ydGVkSW5kZXhOZXh0XS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBzZXRJbmRleChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbbG93ZXN0U29ydGVkSW5kZXhBbGxdLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2N1cnJlbnRUeXBlYWhlYWRdKTtcblxuICAgIGNvbnN0IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCA9IHVzZUNhbGxiYWNrPFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDxJPj4oKHsgdGV4dCwgLi4uaSB9OiBQaWNrPEksIFwidGV4dFwiIHwgXCJpbmRleFwiPikgPT4ge1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGV4dCkge1xuXG4gICAgICAgICAgICAgICAgLy8gRmluZCB3aGVyZSB0byBpbnNlcnQgdGhpcyBpdGVtLlxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgYWxsIGluZGV4IHZhbHVlcyBzaG91bGQgYmUgdW5pcXVlLCB0aGUgcmV0dXJuZWQgc29ydGVkSW5kZXhcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYWx3YXlzIHJlZmVyIHRvIGEgbmV3IGxvY2F0aW9uIChpLmUuIGJlIG5lZ2F0aXZlKSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIHRleHQsIGluc2VydGluZ0NvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBpbnNlcnRpbmdDb21wYXJhdG9yKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtzb3J0ZWRJbmRleF0udGV4dCwgeyB1bnNvcnRlZEluZGV4OiBpLmluZGV4LCB0ZXh0IH0pID09IDApO1xuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZSgtc29ydGVkSW5kZXggLSAxLCAwLCB7IHRleHQsIHVuc29ydGVkSW5kZXg6IGkuaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKHNvcnRlZEluZGV4LCAwLCB7IHRleHQsIHVuc29ydGVkSW5kZXg6IGkuaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1bm1vdW50aW5nLCBmaW5kIHdoZXJlIHdlIHdlcmUgYW5kIHJlbW92ZSBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFnYWluLCB3ZSBzaG91bGQgYWx3YXlzIGZpbmQgb3Vyc2VsdmVzIGJlY2F1c2UgdGhlcmUgc2hvdWxkIGJlIG5vIGR1cGxpY2F0ZSB2YWx1ZXMgaWYgZWFjaCBpbmRleCBpcyB1bmlxdWUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgdGV4dCwgaW5zZXJ0aW5nQ29tcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBpbnNlcnRpbmdDb21wYXJhdG9yKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtzb3J0ZWRJbmRleF0udGV4dCwgeyB1bnNvcnRlZEluZGV4OiBpLmluZGV4LCB0ZXh0IH0pID09IDApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKHNvcnRlZEluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3RleHRdKTtcblxuICAgICAgICByZXR1cm47XG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyxcblxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxuICAgICAgICBpbnZhbGlkVHlwZWFoZWFkLFxuICAgIH1cbn1cblxuXG4vKipcbiAqIFlvdXIgdXN1YWwgYmluYXJ5IHNlYXJjaCBpbXBsZW1lbnRhdGlvbi5cbiAqIFxuICogSXQncyB1c2VkIGhlcmUgdG8gcXVpY2tseSBmaW5kIGEgZ29vZCBzcG90IHRvIHN0YXJ0IHNlYXJjaGluZyBmb3Igb3VyIG5leHQgdHlwZWFoZWFkIGNhbmRpZGF0ZS5cbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoIHRocm91Z2hcbiAqIEBwYXJhbSB3YW50ZWQgVGhlIHZhbHVlIHlvdSdkIGxpa2UgdG8gZmluZFxuICogQHBhcmFtIGNvbXBhcmF0b3IgQ29tcGFyZXMgYHdhbnRlZGAgd2l0aCB0aGUgY3VycmVudCB2YWx1ZSBpbiBgYXJyYXlgXG4gKiBAcmV0dXJucyBBIG5vbi1uZWdhdGl2ZSB2YWx1ZSBpZiBgd2FudGVkYCB3YXMgZm91bmQsIGFuZCBhIG5lZ2F0aXZlIG51bWJlciBpZiBub3QuIFxuICogVGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgbnVtYmVyLCBtaW51cyBvbmUsIGlzIHdoZXJlIGB3YW50ZWRgICp3b3VsZCogYmUgZm91bmQgaWYgaXQgKndhcyogaW4gYGFycmF5YFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoPFQsIFUsIEYgZXh0ZW5kcyAobGhzOiBVLCByaHM6IFQpID0+IG51bWJlcj4oYXJyYXk6IFRbXSwgd2FudGVkOiBVLCBjb21wYXJhdG9yOiBGKTogbnVtYmVyIHtcbiAgICBsZXQgZmlyc3RJbmRleCA9IDA7XG4gICAgbGV0IGxhc3RJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGZpcnN0SW5kZXggPD0gbGFzdEluZGV4KSB7XG4gICAgICAgIGNvbnN0IHRlc3RJbmRleCA9IChsYXN0SW5kZXggKyBmaXJzdEluZGV4KSA+PiAxO1xuICAgICAgICBjb25zdCBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyYXRvcih3YW50ZWQsIGFycmF5W3Rlc3RJbmRleF0pO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICAgICAgZmlyc3RJbmRleCA9IHRlc3RJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IHRlc3RJbmRleCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC1maXJzdEluZGV4IC0gMTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgQ2hpbGRGbGFnT3BlcmF0aW9ucywgRmxhZ2dhYmxlQ2hpbGRJbmZvQmFzZSwgTWFuYWdlZENoaWxkSW5mb0Jhc2UsIE1hbmFnZWRDaGlsZEluZm9OZWVkZWQsIE1hbmFnZWRDaGlsZHJlbiwgdXNlQ2hpbGRyZW5GbGFnLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VIYXNGb2N1cyB9IGZyb20gXCIuL3VzZS1oYXMtZm9jdXNcIjtcbmltcG9ydCB7IHJldHVybkZhbHNlLCByZXR1cm5UcnVlLCByZXR1cm5aZXJvLCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcblxuLy9leHBvcnQgdHlwZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbzxLIGV4dGVuZHMgc3RyaW5nLCBJIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZEluZm9CYXNlPEs+PiA9IFJlcXVpcmVkPEk+ICYgRmxhZ2dhYmxlQ2hpbGRJbmZvPFwidGFiYmFibGVcIj4gJiB7XG4vL307XG5cbmV4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczxLIGV4dGVuZHMgc3RyaW5nLCBJIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mb0Jhc2U8bnVtYmVyPj4gPSBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPEk+ICYge1xuICAgIGluaXRpYWxJbmRleD86IG51bWJlcjtcblxuICAgIC8vIENhbGxlZCBkdXJpbmcgYW4gZWZmZWN0IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIHJlbmRlcmVkIGl0c2VsZiBpbiBhIHRhYmJhYmxlIHN0YXRlXG4gICAgb25UYWJiYWJsZVJlbmRlcj86IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPzogKHRhYmJhYmxlSW5kZXg6IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XG5cbiAgICBvblRhYmJlZEluVG8/OiAoKSA9PiB2b2lkO1xuICAgIG9uVGFiYmVkT3V0T2Y/OiAoKSA9PiB2b2lkO1xufVxuXG4vL2V4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzQmFzZTxLIGV4dGVuZHMgc3RyaW5nLCBJMiBleHRlbmRzIFBhcnRpYWw8UGljazxSb3ZpbmdUYWJJbmRleENoaWxkSW5mb0Jhc2U8Sz4sIFwiZm9jdXNTZWxmXCIgfCBcImJsdXJTZWxmXCI+Pj4gPSBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPE9taXQ8STIsIFwiZm9jdXNTZWxmXCIgfCBcImJsdXJTZWxmXCIgfCBcImdldEVsZW1lbnRcIj4gJiBQYXJ0aWFsPFBpY2s8STIsIFwiZm9jdXNTZWxmXCIgfCBcImJsdXJTZWxmXCI+Pj47XG5leHBvcnQgdHlwZSBSb3ZpbmdUYWJJbmRleENoaWxkSW5mb05lZWRlZDxLIGV4dGVuZHMgc3RyaW5nLCBJIGV4dGVuZHMgUGljazxSb3ZpbmdUYWJJbmRleENoaWxkSW5mb0Jhc2U8Sz4sIFwiaW5kZXhcIiB8IFwiZm9jdXNTZWxmXCIgfCBcImJsdXJTZWxmXCI+PiA9IE1hbmFnZWRDaGlsZEluZm9OZWVkZWQ8T21pdDxJLCBcImdldEVsZW1lbnRcIiB8IFwiZm9jdXNTZWxmXCIgfCBcImJsdXJTZWxmXCI+ICYgUGFydGlhbDxQaWNrPEksIFwiZm9jdXNTZWxmXCIgfCBcImJsdXJTZWxmXCI+Pj47XG5leHBvcnQgdHlwZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgSyBleHRlbmRzIHN0cmluZywgSTIgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkSW5mb0Jhc2U8Sz4+ID0gKGE6IHsgaW5mbzogUm92aW5nVGFiSW5kZXhDaGlsZEluZm9OZWVkZWQ8SywgSTI+IH0pID0+IHtcbiAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PjtcbiAgICB0YWJiYWJsZTogYm9vbGVhbjtcbiAgICBnZXRFbGVtZW50KCk6IENoaWxkRWxlbWVudCB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlPENoaWxkRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgSyBleHRlbmRzIHN0cmluZywgSTIgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkSW5mb0Jhc2U8Sz4+IHtcbiAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkOiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCwgSywgSTI+O1xuICAgIHNldFRhYmJhYmxlSW5kZXg6ICh1cGRhdGVyOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0sIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHZvaWQ7XG4gICAgZ2V0VGFiYmFibGVJbmRleDogKCkgPT4gbnVtYmVyIHwgbnVsbDtcbiAgICBjaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPEkyPjtcbiAgICBmb2N1c1NlbGY6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm92aW5nVGFiSW5kZXhDaGlsZEluZm9CYXNlPEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgRmxhZ2dhYmxlQ2hpbGRJbmZvQmFzZTxLIHwgXCJ0YWJiYWJsZVwiPiB7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGFiYmluZyB0aHJvdWdoIHRoaXMgY29tcG9uZW50IHdpbGwgY2F1c2UgdGhlIHJlZmVyZW5jZWQgZWxlbWVudCB0byBiZSBmb2N1c2VkLlxuICAgICAqIFxuICAgICAqIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvciB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50IGlmIHlvdSdkIGxpa2UuXG4gICAgICovXG4gICAgZm9jdXNTZWxmPygpOiB2b2lkO1xuXG4gICAgYmx1clNlbGY/KCk6IHZvaWQ7XG5cbiAgICBnZXRFbGVtZW50KCk6IHZvaWQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIHJvdmluZyB0YWJpbmRleCBzeXN0ZW0gd2hlcmUgb25seSBvbmUgXCJmb2N1c2FibGVcIlxuICogY29tcG9uZW50IGluIGEgc2V0IGlzIGFibGUgdG8gcmVjZWl2ZSBhIHRhYiBmb2N1cy4gKldoaWNoKlxuICogb2YgdGhvc2UgZWxlbWVudHMgcmVjZWl2ZXMgZm9jdXMgaXMgZGV0ZXJtaW5lZCBieSB5b3UsIGJ1dCBpdCdzXG4gKiByZWNvbW1lbmRlZCB0byBvZmZsb2FkIHRoYXQgbG9naWMgdGhlbiB0byBhbm90aGVyIGhvb2ssIGxpa2VcbiAqIGB1c2VMaW5lYXJOYXZpZ2F0aW9uYCwgd2hpY2ggbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZVxuICogZWxlbWVudCB3aXRoIHRoZSBhcnJvdyBrZXlzLCBgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbmAsIHdoaWNoXG4gKiBsZXRzIHlvdSBjaGFuZ2UgdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdHlwZWFoZWFkLCBvclxuICogYHVzZUxpc3ROYXZpZ2F0aW9uYCBpZiB5b3UganVzdCB3YW50IGV2ZXJ5dGhpbmcgYnVuZGxlZCB0b2dldGhlci5cbiAqIFxuICogTm90ZSB0aGF0IHRoZSBjaGlsZCBob29rIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkXG4gKiBieSBldmVyeSBjaGlsZCB0aGF0IHVzZXMgdGhpcyByb3ZpbmcgdGFiaW5kZXggbG9naWMuICBUaGVcbiAqIHByb3AtbW9kaWZ5aW5nIGhvb2sgKnRoYXQqIGhvb2sgcmV0dXJucyBzaG91bGQgdGhlbiBiZSB1c2VkXG4gKiBvbiB0aGUgY2hpbGQncyBlbGVtZW50LCBhcyB3ZWxsIGFzIGFueSBvdGhlciBlbGVtZW50cyB5b3UnZCBsaWtlXG4gKiB0byBiZSBleHBsaWNpdGx5IG1hZGUgdW50YWJiYWJsZSB0b28uXG4gKiBcbiAqIGBzaG91bGRGb2N1c09uQ2hhbmdlYCBzaG91bGQgcmV0dXJuIHRydWUgaWYgZm9jdXMgaXMgXG4gKiBjb250YWluZWQgd2l0aGluIHdoYXRldmVyIGVsZW1lbnQgY29udGFpbnMgdGhlIHJvdmluZyB0YWIgaW5kZXguXG4gKiBHZW5lcmFsbHkgYXMgc2ltcGxlIGFzIHRoZSBmb2xsb3dpbmc6XG4gKiBgYGBcbiAqIGNvbnN0IFtmb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gKiBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPFBhcmVudEVsZW1lbnQ+KHsgc2V0Rm9jdXNlZElubmVyIH0pO1xuICogY29uc3QgZm9jdXNPbkNoYW5nZSA9IChmb2N1c2VkSW5uZXIgIT0gZmFsc2UpO1xuICogYGBgXG4gKiBJdCdzIG5vdCBpbmNsdWRlZCBoZXJlIGJlY2F1c2UgYHVzZVJvdmluZ1RhYkluZGV4YCBkb2Vzbid0IGtub3cgXG4gKiBhbnl0aGluZyBhYm91dCB0aGUgY29udGFpbmVyIGVsZW1lbnQsIG9ubHkgY2hpbGRyZW4gZWxlbWVudHMuXG4gKiBBbmQganVzdCBhcyB3ZWxsISBDaGlsZHJlbiBzaG91bGQgYmUgYWxsb3dlZCBhdCB0aGUgcm9vdCwgXG4gKiByZWdhcmRsZXNzIG9mIGlmIGl0J3MgdGhlIHdob2xlIGFwcCBvciBqdXN0IGEgZ2l2ZW4gY29tcG9uZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBLIGV4dGVuZHMgc3RyaW5nLCBJMiBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvQmFzZTxLPj4oeyBpbml0aWFsSW5kZXgsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogb25DaGlsZHJlbk1vdW50Q2hhbmdlVXNlciwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvblRhYmJhYmxlUmVuZGVyLCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmVkSW5Ubzogb25BbnlGb2N1c0luLCBvblRhYmJlZE91dE9mOiBvbkFueUZvY3VzT3V0IH06IFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczxLLCBJMj4pOiBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGU8Q2hpbGRFbGVtZW50LCBLLCBJMj4ge1xuICAgIGluaXRpYWxJbmRleCA/Pz0gMDtcbiAgICBjb25zdCBzdGFibGVPblRhYmJhYmxlUmVuZGVyID0gdXNlU3RhYmxlQ2FsbGJhY2sob25UYWJiYWJsZVJlbmRlciA/PyAoKCkgPT4geyB9KSk7XG4gICAgY29uc3QgW2dldEFueUZvY3VzZWQsIHNldEFueUZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlcj4odXNlU3RhYmxlQ2FsbGJhY2soKG5ld0NvdW50OiBudW1iZXIsIG9sZENvdW50OiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKG9sZENvdW50ID09IDAgJiYgbmV3Q291bnQgPiAwKSB7XG4gICAgICAgICAgICBvbkFueUZvY3VzSW4/LigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0NvdW50ID09IDAgJiYgKG9sZENvdW50ID8/IDApID4gMCkge1xuICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICBvbkFueUZvY3VzT3V0Py4oKTtcbiAgICAgICAgfVxuICAgIH0pLCByZXR1cm5aZXJvKTtcblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhyZWUgdGhpbmdzIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnRseSB0YWJiYWJsZSBlbGVtZW50J3MgaW5kZXg6XG4gICAgLy8gV2hhdCBpdCBpcywgYW5kIHdoZXRoZXIsIHdoZW4gd2UgcmVuZGVyIHRoaXMgY29tcG9uZW50IGFuZCBpdCdzIGNoYW5nZWQsIHRvIGFsc28gZm9jdXMgdGhlIGVsZW1lbnQgdGhhdCB3YXMgbWFkZSB0YWJiYWJsZS5cbiAgICBjb25zdCBbZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleDJdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGw+KG9uVGFiYmFibGVJbmRleENoYW5nZSwgdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gaW5pdGlhbEluZGV4ISB9LCBbXSkpO1xuICAgIGNvbnN0IHNldFRhYmJhYmxlSW5kZXggPSB1c2VDYWxsYmFjaygodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7XG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXgyKChwcmV2SW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXBkYXRlciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IHVwZGF0ZXIocHJldkluZGV4ID8/IG51bGwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IHVwZGF0ZXI7XG5cbiAgICAgICAgICAgIG5leHRJbmRleCA/Pz0gMDtcbiAgICAgICAgICAgIG5leHRJbmRleCA9IGNoYW5nZUluZGV4KG5leHRJbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2SW5kZXggIT0gbmV4dEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQobmV4dEluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBwcmV2SW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChwcmV2SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQgIT0gbnVsbCAmJiBmcm9tVXNlckludGVyYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hpbGQuZm9jdXNTZWxmISgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZDaGlsZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBwcmV2Q2hpbGQuYmx1clNlbGYhKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5leHRJbmRleDtcbiAgICAgICAgfSk7XG5cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgdGFiYmFibGUgaW5kZXggY2hhbmdlcyxcbiAgICAvLyBub3RpZnkgdGhlIHByZXZpb3VzIGNoaWxkIHRoYXQgaXQncyBubyBsb25nZXIgdGFiYmFibGUsXG4gICAgLy8gYW5kIG5vdGlmeSB0aGUgbmV4dCBjaGlsZCB0aGF0IGlzIGFsbG93ZWQgdG8gYmUgdGFiYmVkIHRvLlxuICAgIGNvbnN0IHsgY2hpbGRyZW4sIHVzZU1hbmFnZWRDaGlsZCB9ID0gdXNlTWFuYWdlZENoaWxkcmVuPEkyPih7XG4gICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcbiAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25DaGlsZHJlbk1vdW50Q2hhbmdlVXNlcj4+KChtb3VudGVkLCB1bm1vdW50ZWQpID0+IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlVXNlcj8uKG1vdW50ZWQsIHVubW91bnRlZCk7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZShtb3VudGVkLCB1bm1vdW50ZWQpOyB9KSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXgsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9ID0gdXNlQ2hpbGRyZW5GbGFnPFwidGFiYmFibGVcIiwgSTI+KHsgaW5pdGlhbEluZGV4LCBjaGlsZHJlbiwgY2xvc2VzdEZpdDogdHJ1ZSwga2V5OiBcInRhYmJhYmxlXCIsIGZpdE51bGxUb1plcm86IHRydWUgfSk7XG5cbiAgICBjb25zdCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkID0gdXNlQ2FsbGJhY2s8VXNlUm92aW5nVGFiSW5kZXhDaGlsZDxDaGlsZEVsZW1lbnQsIEssIEkyPj4oKHsgaW5mbzogeyBpbmRleCwgZmxhZ3MsIGJsdXJTZWxmOiBicywgZm9jdXNTZWxmOiBmcywgLi4ucmVzdEluZm8gfSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChmcykge1xuICAgICAgICAgICAgICAgIGZzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgY29uc3QgYmx1clNlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnMpIHtcbiAgICAgICAgICAgICAgICBicygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBjb25zdCBvbkZvY3VzZWRJbm5lckNoYW5nZWQgPSB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgc2V0QW55Rm9jdXNlZChwcmV2ID0+IChmb2N1c2VkID8gKChwcmV2ID8/IDApICsgMSkgOiAoKHByZXYgPz8gMCkgLSAxKSkpO1xuICAgICAgICAgICAgaWYgKGZvY3VzZWQpXG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpbmRleCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQsIHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPENoaWxkRWxlbWVudD4oeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQgfSk7XG5cbiAgICAgICAgY29uc3QgW3RhYmJhYmxlLCBzZXRUYWJiYWJsZSwgZ2V0VGFiYmFibGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgICAgICBjb25zdCB0YWJiYWJsZUZsYWdzID0gdXNlUmVmPENoaWxkRmxhZ09wZXJhdGlvbnM+KHsgZ2V0OiBnZXRUYWJiYWJsZSwgc2V0OiBzZXRUYWJiYWJsZSwgaXNWYWxpZDogcmV0dXJuVHJ1ZSB9KTs7XG4gICAgICAgIGNvbnN0IF86IHZvaWQgPSB1c2VNYW5hZ2VkQ2hpbGQoe1xuICAgICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgICAgIC4uLihyZXN0SW5mbyBhcyBJMiksXG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHtcbiAgICAgICAgICAgICAgICAgICAgdGFiYmFibGU6IHRhYmJhYmxlRmxhZ3MuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgLi4uZmxhZ3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJsdXJTZWxmLFxuICAgICAgICAgICAgICAgIGZvY3VzU2VsZixcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRhYmJhYmxlKVxuICAgICAgICAgICAgICAgIHN0YWJsZU9uVGFiYmFibGVSZW5kZXIoaW5kZXgpO1xuICAgICAgICB9LCBbdGFiYmFibGUsIGluZGV4XSlcbiAgICAgICAgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PiB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChwcm9wcy50YWJJbmRleCA9PSBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxDaGlsZEVsZW1lbnQ+KHVzZUhhc0ZvY3VzUHJvcHMoeyB0YWJJbmRleDogdGFiYmFibGUgPyAwIDogLTEgfSksIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMsXG4gICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICAgICAgdGFiYmFibGVcbiAgICAgICAgfVxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRUYWJiYWJsZUluZGV4KCk7XG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKVxuICAgICAgICAgICAgY2hpbGRyZW4uZ2V0QXQoaW5kZXgpPy5mb2N1c1NlbGY/LigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KDAsIHRydWUpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsXG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXgsXG4gICAgICAgIGdldFRhYmJhYmxlSW5kZXgsXG4gICAgICAgIGZvY3VzU2VsZixcbiAgICAgICAgY2hpbGRyZW5cbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZEluZm9CYXNlLCBNYW5hZ2VkQ2hpbGRJbmZvTmVlZGVkLCBNYW5hZ2VkQ2hpbGRyZW4sIHVzZUNoaWxkcmVuRmxhZywgVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uLCBVc2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRJbmZvLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGUsIHVzZVR5cGVhaGVhZE5hdmlnYXRpb24sIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZEluZm8sIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyBSb3ZpbmdUYWJJbmRleENoaWxkSW5mb0Jhc2UsIFJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvTmVlZGVkLCB1c2VSb3ZpbmdUYWJJbmRleCwgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLCBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tIFwiLi91c2UtZm9yY2UtdXBkYXRlXCI7XG5cblxuLyoqXG4gKiBcbiAqIFRPRE86IFRoaXMgdGFibGUgd2FzIHNjcmFwcGVkIHdoZW4gdGhpcyB3YXMgY2hhbmdlZCB0byBqdXN0IGFjY2VwdCBhIGNvbGxhdG9yIGRpcmVjdGx5LFxuICogYnV0IGl0J3Mgbm90IGJhZCBmb3IgYSBjb2xsYXRpb24gY3Jhc2ggY291cnNlIGFuZCBJIG1pZ2h0IHVzZSBpdCBhZ2Fpbi5cbiAqIEV2ZW4ganVzdCBhcyBhIFwidGhpcyBpcyB3aHkgaXQncyBpbXBvcnRhbnQgYW5kIGdvb2QgdG8gdXNlIHRoZXNlIHRoaW5nc1wiIHRoaW5nLlxuICogXG4gKiB8TGFuZy58VGFyZ2V0fFVzZXIgaW5wdXR8YGJhc2VgfGBhY2NlbnRgfGBjYXNlYHxgdmFyaWFudGB8XG4gKiB8LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXxcbiAqIHxFTnxIaXxCeWV84p2MfOKdjHzinYx84p2MfFxuICogfEVOfEhpfEhpfOKchXzinIV84pyFfOKchXxcbiAqIHxFTnxIaXzvvKjvvYl84pyFfOKchXzinIV84p2MfFxuICogfEVOfEhpfGhpfOKchXzinIV84p2MfOKdjHxcbiAqIHxFTnxIaXxIw6984pyFfOKdjHzinYx84p2MfFxuICogfEVOfMOlfGFhfOKdjHzinYx84p2MfOKdjHxcbiAqIHxEQXzDpXxhYXzinIV84pyFfOKchXzinYx8XG4gKiB8REF8w6V8QUF84pyFfOKchXzinYx84p2MfFxuICogfERBfMOlfEFhfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxhQXzinYx84p2MfOKdjHzinYx8XG4gKiB8RU58w6V8YXzinIV84pyFfOKdjHzinYx8XG4gKiB8REF8w6V8YXzinIV84pyFfOKdjHzinYx8XG4gKiB8SlB876qqfOedgHzinIV84pyFfOKchXzinIV8XG4gKiB8SlB844KrfO+9tnzinIV84pyFfOKchXzinIV8XG4gKiB8SlB844KrfOOBi3zinIV84pyFfOKchXzinYx8XG4gKiB8SlB844KrfOODtXzinIV84pyFfOKchXzinYx8XG4gKiB8SlB844KrfOOLlXzinIV84pyFfOKdjHzinYx8XG4gKiB8SlB844KrfOOCrHzinIV84p2MfOKdjHzinYx8XG4gKiB8SlB844KrfOWKm3zinYx84p2MfOKdjHzinYx8XG4gKiB8Wkh857SFfOe6onzinYx84p2MfOKdjHzinYx8XG4gKiBcbiAqIFxuICogKE5vdGUgdG8gc2VsZjogQXQgc29tZSBwb2ludCwgdGhpcyBmaWxlIHdpbGwgcHJvYmFibHkgYmUgbm9ybWFsaXplZFxuICogYnkgc29tZWJvZHkgYW5kIO+qqiB3aWxsIHR1cm4gYmFjayBpbnRvIOedgC4pXG4gKiBcbiAqL1xuY29uc3QgX2R1bW15OiBhbnkgPSBudWxsO1xuXG5cbi8qXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXI+PiB7XG5cbiAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzOiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+KHByb3BzOiBQKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+O1xuXG4gICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogVXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEk+O1xuXG4gICAgY3VycmVudFR5cGVhaGVhZDogc3RyaW5nIHwgbnVsbDtcblxuICAgIGludmFsaWRUeXBlYWhlYWQ6IGJvb2xlYW4gfCBudWxsO1xuXG4gICAgdGFiYmFibGVJbmRleDogbnVtYmVyIHwgbnVsbDtcblxuICAgIG5hdmlnYXRlVG9JbmRleDogKGluZGV4OiBudW1iZXIgfCBudWxsKSA9PiB2b2lkO1xuICAgIG5hdmlnYXRlVG9OZXh0OiAoKSA9PiB2b2lkO1xuICAgIG5hdmlnYXRlVG9QcmV2OiAoKSA9PiB2b2lkO1xuICAgIG5hdmlnYXRlVG9GaXJzdDogKCkgPT4gdm9pZDtcbiAgICBuYXZpZ2F0ZVRvTGFzdDogKCkgPT4gdm9pZDtcblxuICAgIGZvY3VzQ3VycmVudDogbnVsbCB8ICgoKSA9PiB2b2lkKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzOiAoeyB0YWJJbmRleCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PjtcbiAgICB1c2VMaXN0TmF2aWdhdGlvblNpYmxpbmdQcm9wczogVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50PltcInVzZVJvdmluZ1RhYkluZGV4U2libGluZ1Byb3BzXCJdO1xuICAgIHRhYmJhYmxlOiBib29sZWFuIHwgbnVsbDtcbn0qL1xuXG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwYXJlbnQgYHVzZUxpc3ROYXZpZ2F0aW9uYCAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8SyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPj4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8SywgST4sIE9taXQ8VXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMsIFwiZ2V0SW5kZXhcIiB8IFwic2V0SW5kZXhcIj4sIE9taXQ8VXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsIChgbmF2aWdhdGVUbyR7c3RyaW5nfWAgJiBrZXlvZiBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyk+IHtcblxuICAgIC8qKlxuICAgICAqIE1hcHMgdG8gSW50bC5Db2xsYXRvcidzIGlnbm9yZVB1bmN0dWF0aW9uIHBhcmFtZXRlci4gIFdoZXRoZXIgcHVuY3R1YXRpb24gKHdoaWNoIGlzIGNvbnRleHQgYW5kIGxvY2FsZSBkZXBlbmRlbnQpIHNob3VsZCBiZSBpZ25vcmVkIHdoZW4gc2VhcmNoaW5nLlxuICAgICAqIFxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgLy9pZ25vcmVQdW5jdHVhdGlvbj86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBBIGNvbGxhdG9yIHRvIHVzZSB3aGVuIGNvbXBhcmluZy4gSWYgbm90IHByb3ZpZGVkLCBzaW1wbHkgdXNlcyBgbG9jYWxlQ29tcGFyZWAgYWZ0ZXIgdHJhbnNmb3JtaW5nIGVhY2ggdG8gbG93ZXJjYXNlLCB3aGljaCB3aWxsLCBhdCBiZXN0LCB3b3JrIG9rYXkgaW4gRW5nbGlzaC5cbiAgICAgKi9cbiAgICAvL2NvbGxhdG9yPzogSW50bC5Db2xsYXRvcjtcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHByZXNzaW5nIGRvd24gYXQgdGhlIGVuZCBmb2N1c2VzIHRoZSBmaXJzdCBlbGVtZW50LCBhbmQgdmljZS12ZXJzYS5cbiAgICAgKiBcbiAgICAgKiBUaGlzIHByb3AgY2FuIGJlIHVzZWQgdG8gZGlzYWJsZSB0aGF0IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIC8vbm9XcmFwPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIGFueSB0eXBlZCBjaGFyYWN0ZXJzIHdpbGwgZm9jdXMgdGhlIG5leHQgaXRlbSB0aGF0IHN0YXJ0cyB3aXRoIHRoZSB0eXBlZCBzdHJpbmcuXG4gICAgICogXG4gICAgICogVGhpcyBwcm9wIGNhbiBiZSB1c2VkIHRvIGRpc2FibGUgdGhhdCBiZWhhdmlvci5cbiAgICAgKi9cbiAgICAvL25vVHlwZWFoZWFkPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgYW5kIGluZGV4RGVtYW5nbGVyIGFyZSB1c2VkIHRvIGFsbG93IGNoaWxkcmVuIHRvIGJlIG5hdmlnYXRlZCBpbiBhbiBvcmRlclxuICAgICAqIHRoYXQgZG9lc24ndCBuZWNlc3NhcmlseSBtYXRjaCB0aGVpciBjaGlsZCBvcmRlciwgbGlrZSBpZiBhIGxpc3QgaXMgc29ydGVkLlxuICAgICAqIFxuICAgICAqIFVzZWQgdG8gdHVybiBhbiBcImFic29sdXRlXCIgaW5kZXggaW50byBhIFwic29ydGVkL2ZpbHRlcmVkL21hbmdsZWRcIiBvbmUuXG4gICAgICogXG4gICAgICogRm9yIGV4YW1wbGUsIG5hdmlnYXRlVG9GaXJzdCBtYW5nbGVzIDAgYW5kIG5hdmlnYXRlcyB0byB0aGF0IHJlc3VsdGluZyByb3cuXG4gICAgICogQHBhcmFtIHJhd0luZGV4IFxuICAgICAqL1xuICAgIGluZGV4TWFuZ2xlcj8ocmF3SW5kZXg6IG51bWJlcik6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gdHVybiBhIFwibWFuZ2xlZFwiIGluZGV4IGludG8gaXQncyBcInVuc29ydGVkXCIgb3IgXCJ1bm1hbmdsZWRcIiBpbmRleC5cbiAgICAgKiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2hlbiBpbmNyZW1lbnRpbmcgb3IgZGVjcmVtZW50aW5nIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaW5kZXgsXG4gICAgICogaXQgbmVlZHMgdG8gYmUgZGVtYW5nbGVkIHRvIGRvIFwibm9ybWFsXCIgbWF0aCBvbiBpdCwgYW5kIHRoZW4gcmUtbWFuZ2xlZFxuICAgICAqIHRvIHR1cm4gdGhhdCBhYnNvbHV0ZSByb3cgaW5kZXggYmFjayBpbnRvIGEgbWFuZ2xlZCBvbmUuXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybWVkSW5kZXggXG4gICAgICovXG4gICAgaW5kZXhEZW1hbmdsZXI/KHRyYW5zZm9ybWVkSW5kZXg6IG51bWJlcik6IG51bWJlcjtcblxuICAgIC8vaW5pdGlhbEluZGV4OiBudW1iZXI7XG5cbiAgICAvL29uVGFiYmFibGVJbmRleENoYW5nZT86IFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczxhbnksIGFueT5bXCJvblRhYmJhYmxlSW5kZXhDaGFuZ2VcIl07XG5cblxuXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyB0aGUgYWJvdmUsIGJ1dCBvbmx5IGZvciBtb3VudC91bm1vdW50IChvciB3aGVuIGEgY2hpbGQgY2hhbmdlcyBpdHMgaW5kZXgpXG4gICAgICovXG4gICAgLy9vbkNoaWxkcmVuTW91bnRDaGFuZ2U/OiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxzdHJpbmc+Pjtcbn1cbnR5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+O1xuXG5cblxuLy9leHBvcnQgdHlwZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxJIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZEluZm8+ID0gT21pdDxJLCBcInJlcmVuZGVyQW5kRm9jdXNcIiB8IFwic2V0VGFiYmFibGVcIiB8IFwiZ2V0VGFiYmFibGVcIj47XG5cbi8qKiBUeXBlIG9mIHRoZSBjaGlsZCdzIHN1Yi1ob29rICovXG4vL2V4cG9ydCB0eXBlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSSBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvPiA9ICh7IHRleHQsIGluZGV4LCAuLi5pIH06IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEk+KSA9PiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+O1xuXG5mdW5jdGlvbiBpZGVudGl0eTxUPih0OiBUKSB7IHJldHVybiB0OyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdE5hdmlnYXRpb25DaGlsZEluZm9CYXNlPEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZEluZm9CYXNlPEs+LCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRJbmZvLCBVc2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRJbmZvIHtcbiAgICB0ZXh0OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogSWYgYSBjaGlsZCBpcyBoaWRkZW4sIHRoZW4gaXQgd2lsbCBiZSBza2lwcGVkIG92ZXJcbiAgICAgKiBkdXJpbmcga2V5Ym9hcmQgbmF2aWdhdGlvbiwgYW5kIHRoZSBIVE1MIGBoaWRkZW5gXG4gICAgICogYXR0cmlidXRlIHdpbGwgYmUgYXBwbGllZC5cbiAgICAgKi9cbiAgICBoaWRkZW4/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mb05lZWRlZDxLIGV4dGVuZHMgc3RyaW5nLCBJIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZEluZm9CYXNlPEs+PiA9IFJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvTmVlZGVkPEssIEk+O1xuXG5leHBvcnQgdHlwZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSyBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgSSBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPiA9IExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPj4gPSAoYToge2luZm86IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvTmVlZGVkPEssIEk+fSkgPT4ge1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+O1xuICAgIHRhYmJhYmxlOiBib29sZWFuO1xuICAgIGdldEVsZW1lbnQ6ICgpID0+IFBhcmVudE9yQ2hpbGRFbGVtZW50IHwgbnVsbDtcbn07XG4vKipcbiAqIEltcGxlbWVudHMgcHJvcGVyIGtleWJvYXJkIG5hdmlnYXRpb24gZm9yIGNvbXBvbmVudHMgbGlrZSBsaXN0Ym94ZXMsIGJ1dHRvbiBncm91cHMsIG1lbnVzLCBldGMuXG4gKiBcbiAqIEluIHRoZSBkb2N1bWVudCBvcmRlciwgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSBcImZvY3VzZWRcIiBvciBcInRhYmJhYmxlXCIgZWxlbWVudCwgbWFraW5nIGl0IGFjdCBtb3JlIGxpa2Ugb25lIGNvbXBsZXRlIHVuaXQgaW4gY29tcGFyaXNvbiB0byBldmVyeXRoaW5nIGFyb3VuZCBpdC5cbiAqIE5hdmlnYXRpbmcgZm9yd2FyZHMvYmFja3dhcmRzIGNhbiBiZSBkb25lIHdpdGggdGhlIGFycm93IGtleXMsIEhvbWUvRW5kIGtleXMsIG9yIGFueSBhbnkgdGV4dCBmb3IgdHlwZWFoZWFkIHRvIGZvY3VzIHRoZSBuZXh0IGl0ZW0gdGhhdCBtYXRjaGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgSyBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgSSBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPiA9IExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPj4oeyBpbml0aWFsSW5kZXgsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgY29sbGF0b3IsIGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgaW5kZXhNYW5nbGVyLCBpbmRleERlbWFuZ2xlciwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvblRhYmJhYmxlUmVuZGVyLCBvblRhYmJlZEluVG8sIG9uVGFiYmVkT3V0T2YgfTogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPEssIEk+KTogVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEssIEk+IHtcblxuICAgIGluZGV4TWFuZ2xlciA/Pz0gaWRlbnRpdHk7XG4gICAgaW5kZXhEZW1hbmdsZXIgPz89IGlkZW50aXR5O1xuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24gPz89IFwiZWl0aGVyXCI7XG4gICAgaW5pdGlhbEluZGV4ID8/PSAwO1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTGlzdE5hdmlnYXRpb25cIiwgaW5kZXhNYW5nbGVyLCBpbmRleERlbWFuZ2xlcik7XG5cblxuICAgIGNvbnN0IHtcbiAgICAgICAgZ2V0VGFiYmFibGVJbmRleCxcbiAgICAgICAgc2V0VGFiYmFibGVJbmRleCxcbiAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIC4uLnJlc3QxXG4gICAgfSA9IHVzZVJvdmluZ1RhYkluZGV4PENoaWxkRWxlbWVudCwgSywgST4oe1xuICAgICAgICBpbml0aWFsSW5kZXgsXG4gICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxuICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgICAgIG9uVGFiYmFibGVSZW5kZXIsXG4gICAgICAgIG9uVGFiYmVkSW5UbyxcbiAgICAgICAgb25UYWJiZWRPdXRPZlxuICAgIH0pXG5cblxuICAgIGNvbnN0IG5hdmlnYXRlVG9JbmRleCA9IHVzZUNhbGxiYWNrKChpOiBudW1iZXIgfCBudWxsLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7XG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaSA9PSBudWxsID8gbnVsbCA6IHRyeU5hdmlnYXRlVG9JbmRleChjaGlsZHJlbiwgMCwgaSwgMSwgaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LCBpbmRleERlbWFuZ2xlciA/PyBpZGVudGl0eSksIGZyb21Vc2VySW50ZXJhY3Rpb24pO1xuICAgIH0sIFtdKVxuICAgIGNvbnN0IG5hdmlnYXRlVG9GaXJzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0VGFiYmFibGVJbmRleCh0cnlOYXZpZ2F0ZVRvSW5kZXgoY2hpbGRyZW4sIDAsIDAsIDEsIGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSwgaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHkpLCB0cnVlKTtcbiAgICB9LCBbXSlcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTGFzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0VGFiYmFibGVJbmRleCh0cnlOYXZpZ2F0ZVRvSW5kZXgoY2hpbGRyZW4sIGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpICsgMSwgY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCksIC0xLCBpbmRleE1hbmdsZXIgPz8gaWRlbnRpdHksIGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5KSwgdHJ1ZSk7XG4gICAgfSwgW10pXG4gICAgY29uc3QgbmF2aWdhdGVUb1ByZXYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ5TmF2aWdhdGVUb0luZGV4KGNoaWxkcmVuLCBjID8/IDAsIChjID8/IDApIC0gMSwgLTEsIGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSwgaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHkpXG4gICAgICAgIH0sIHRydWUpXG4gICAgfSwgW10pXG4gICAgY29uc3QgbmF2aWdhdGVUb05leHQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdHJ5TmF2aWdhdGVUb0luZGV4KGNoaWxkcmVuLCBjID8/IDAsIChjID8/IDApICsgMSwgMSwgaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LCBpbmRleERlbWFuZ2xlciA/PyBpZGVudGl0eSk7XG4gICAgICAgIH0sIHRydWUpXG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBzZXRJbmRleCA9IHVzZUNhbGxiYWNrKChpbmRleDogKG51bWJlciB8IG51bGwpIHwgKChwcmV2OiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKSA9PiB7XG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaW5kZXgsIHRydWUpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHsgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMsIC4uLnJlc3QyIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBJPih7IGNvbGxhdG9yLCBnZXRJbmRleDogZ2V0VGFiYmFibGVJbmRleCwgc2V0SW5kZXgsIHR5cGVhaGVhZFRpbWVvdXQsIG5vVHlwZWFoZWFkIH0pO1xuICAgIGNvbnN0IHsgdXNlTGluZWFyTmF2aWdhdGlvblByb3BzLCAuLi5yZXN0MyB9ID0gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oeyBuYXZpZ2F0aW9uRGlyZWN0aW9uLCBuYXZpZ2F0ZVRvUHJldiwgbmF2aWdhdGVUb05leHQsIG5hdmlnYXRlVG9GaXJzdCwgbmF2aWdhdGVUb0xhc3QsIGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cyB9KTtcblxuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiA9PiB7XG4gICAgICAgIHJldHVybiB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHModXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzKHByb3BzKSk7XG4gICAgfSwgW3VzZUxpbmVhck5hdmlnYXRpb25Qcm9wcywgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzXSk7XG5cblxuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgSywgST4+KCh7IGluZm86IHsgZmxhZ3MsIGluZGV4LCB0ZXh0LCBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW4sIC4uLnJlc3RJbmZvIH0gfSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IF92OiB2b2lkID0gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkKHsgaW5kZXgsIHRleHQgfSk7XG5cbiAgICAgICAgY29uc3QgeyB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMsIHRhYmJhYmxlLCBnZXRFbGVtZW50IH0gPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkKHsgaW5mbzogeyAgLi4uKHJlc3RJbmZvIGFzIEkpLCBmbGFncywgaW5kZXgsIHRleHQsIGJsdXJTZWxmLCBmb2N1c1NlbGYsIGhpZGRlbiB9IH0pO1xuXG4gICAgICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4gPSBmdW5jdGlvbiAoeyAuLi5wcm9wcyB9KSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50Pih1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMoKCh7IGluZXJ0OiBoaWRkZW4gfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSkpLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLFxuICAgICAgICAgICAgdGFiYmFibGUsXG4gICAgICAgICAgICBnZXRFbGVtZW50XG4gICAgICAgIH1cbiAgICB9LCBbdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCBuYXZpZ2F0ZVRvSW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXG5cbiAgICAgICAgZ2V0VGFiYmFibGVJbmRleCxcbiAgICAgICAgc2V0VGFiYmFibGVJbmRleCxcblxuICAgICAgICBjaGlsZHJlbixcblxuICAgICAgICAuLi5yZXN0MSxcbiAgICAgICAgLi4ucmVzdDIsXG4gICAgICAgIC4uLnJlc3QzXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBLIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLCBJIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZEluZm9CYXNlPEs+ID0gTGlzdE5hdmlnYXRpb25DaGlsZEluZm9CYXNlPEs+PiBleHRlbmRzXG4gICAgT21pdDxVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGU8Q2hpbGRFbGVtZW50LCBLLCBJPiwgXCJ1c2VSb3ZpbmdUYWJJbmRleENoaWxkXCI+LFxuICAgIE9taXQ8VXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JDaGlsZEVsZW1lbnQsIEk+LCBcInVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wc1wiIHwgXCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRcIj4sXG4gICAgT21pdDxVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudD4sIFwidXNlTGluZWFyTmF2aWdhdGlvblByb3BzXCI+IHtcbiAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgSywgST47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+O1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25JbmZvQmFzZTxLIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxcInNlbGVjdGVkXCIgfCBLPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8SyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPj4gZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxLLCBJPiwgXCJpbml0aWFsSW5kZXhcIj4ge1xuICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkluZm9CYXNlPEs+PiBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEssIEk+LCBcInVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRcIiB8IFwidXNlTGlzdE5hdmlnYXRpb25Qcm9wc1wiPiB7XG4gICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBLLCBJPjtcbiAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgSywgST5bXCJ1c2VMaXN0TmF2aWdhdGlvblByb3BzXCJdO1xufVxuXG5leHBvcnQgdHlwZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIEsgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsIEkgZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkluZm9CYXNlPEs+ID0gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25JbmZvQmFzZTxLPj4gPSAoLi4ucDogUGFyYW1ldGVyczxVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgSywgST5bXCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkXCJdPikgPT4gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGU8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgSywgST47XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIEsgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsIEkgZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkluZm9CYXNlPEs+ID0gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25JbmZvQmFzZTxLPj4gZXh0ZW5kcyBSZXR1cm5UeXBlPFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBLLCBJPltcInVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRcIl0+IHtcbiAgICBzZWxlY3RlZDogYm9vbGVhbjtcbiAgICBnZXRTZWxlY3RlZCgpOiBib29sZWFuO1xufTtcblxuLyoqXG4gKiBJdCdzIHZlcnkgY29tbW9uIHRvIGNvbWJpbmUgYSB0YWJiYWJsZSBsaXN0IG9mIHRoaW5ncyBhbmQgXCJzZWxlY3Rpb25cIiBvZiBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICogXG4gKiBMaXN0cywgcmFkaW8gYnV0dG9ucywgdGFicywgZXRjLiBldGMuXG4gKiBcbiAqIFRoaXMgaXMgYSBzaG9ydGN1dCB0aGF0IGNvbWJpbmVzIHRoZSB0d28gd2l0aCB0aGUgY29ycmVjdCB0eXBpbmcuXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBLIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLCBJIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25JbmZvQmFzZTxLPiA9IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uSW5mb0Jhc2U8Sz4+KHsgc2VsZWN0ZWRJbmRleCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY21jLCAuLi5hcmdzIH06IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxLLCBJPik6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBLLCBJPiB7XG5cbiAgICBjb25zdCBsaXN0OiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgSywgST4gPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBLLCBJPih7XG4gICAgICAgIGluaXRpYWxJbmRleDogKHNlbGVjdGVkSW5kZXggPz8gMCksXG4gICAgICAgIG9uVGFiYmVkT3V0T2Y6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHsgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCkgbGlzdC5zZXRUYWJiYWJsZUluZGV4KHNlbGVjdGVkSW5kZXgsIGZhbHNlKSB9KSxcbiAgICAgICAgLi4uYXJncyxcbiAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTxVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxzdHJpbmc+PltcIm9uQ2hpbGRyZW5Nb3VudENoYW5nZVwiXT4+KChtLCB1KSA9PiB7IG9jbWM/LihtLCB1KTsgb25DaGlsZHJlbk1vdW50Q2hhbmdlKG0sIHUpIH0pXG4gICAgfSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxuICAgICAgICAuLi5saXN0UmVzdFxuICAgIH0gPSBsaXN0O1xuXG4gICAgY29uc3Qge1xuICAgICAgICBjaGFuZ2VJbmRleDogY2hhbmdlU2VsZWN0ZWRJbmRleCxcbiAgICAgICAgZ2V0Q3VycmVudEluZGV4OiBnZXRTZWxlY3RlZEluZGV4LFxuICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2VcbiAgICB9ID0gdXNlQ2hpbGRyZW5GbGFnPFwic2VsZWN0ZWRcIiwgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25JbmZvQmFzZT4oe1xuICAgICAgICBjaGlsZHJlbjogbGlzdC5jaGlsZHJlbixcbiAgICAgICAgaW5pdGlhbEluZGV4OiBzZWxlY3RlZEluZGV4LFxuICAgICAgICBrZXk6IFwic2VsZWN0ZWRcIixcbiAgICAgICAgY2xvc2VzdEZpdDogZmFsc2VcbiAgICB9KTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGB1c2VFZmZlY3QoJHtzZWxlY3RlZEluZGV4fSlgKVxuICAgICAgICBjaGFuZ2VTZWxlY3RlZEluZGV4KHNlbGVjdGVkSW5kZXgpO1xuICAgIH0sIFtzZWxlY3RlZEluZGV4XSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogdXNlQ2FsbGJhY2soKHsgaW5mbzogeyBmbGFnczogeyBzZWxlY3RlZCwgLi4uZmxhZ3MgfSwgLi4uaW5mbyB9IH06IFBhcmFtZXRlcnM8dHlwZW9mIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ+WzBdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbaXNTZWxlY3RlZCwgc2V0SXNTZWxlY3RlZCwgZ2V0SXNTZWxlY3RlZF0gPSB1c2VTdGF0ZShnZXRTZWxlY3RlZEluZGV4KCkgPT0gaW5mby5pbmRleCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFJlZiA9IHVzZVJlZih7IGdldDogZ2V0SXNTZWxlY3RlZCwgc2V0OiAoYTogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8Ym9vbGVhbj4+WzBdKSA9PiB7IHNldElzU2VsZWN0ZWQoYSk7IGNvbnNvbGUubG9nKGBDaGlsZCAke2luZm8uaW5kZXh9IGhhZCBzZXQoJHthLnRvU3RyaW5nKCl9KSBjYWxsZWRgKTsgfSwgaXNWYWxpZDogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4gIWluZm8uaGlkZGVuKSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoeyBpbmZvOiB7IC4uLihpbmZvIGFzIEkpLCBmbGFnczogeyAuLi5mbGFncywgc2VsZWN0ZWQ6IHNlbGVjdGVkUmVmLmN1cnJlbnQgfSB9IH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYENoaWxkICR7aW5mby5pbmRleH0gcmVuZGVyaW5nIHdpdGggc2VsZWN0ZWQ6ICR7aXNTZWxlY3RlZH0gYW5kIHRhYmJhYmxlOiAke3JldC50YWJiYWJsZS50b1N0cmluZygpfWApO1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmV0LCBzZWxlY3RlZDogaXNTZWxlY3RlZCwgZ2V0U2VsZWN0ZWQ6IGdldElzU2VsZWN0ZWQgfVxuICAgICAgICB9LCBbdXNlTGlzdE5hdmlnYXRpb25DaGlsZF0pLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiB1c2VDYWxsYmFjaygoLi4ucDogUGFyYW1ldGVyczx0eXBlb2YgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcz4pID0+IHsgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMoLi4ucCkgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uUHJvcHNdKSxcbiAgICAgICAgLi4ubGlzdFJlc3RcbiAgICB9XG59XG5cblxuXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gdHJ5TmF2aWdhdGVUb0luZGV4PEkgZXh0ZW5kcyB7IGhpZGRlbj86IGJvb2xlYW4sIGluZGV4OiBudW1iZXIgfT4oY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxJPiwgaW5pdGlhbDogbnVtYmVyLCB0YXJnZXQ6IG51bWJlciwgc2VhcmNoRGlyZWN0aW9uOiAxIHwgLTEsIGluZGV4TWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyLCBpbmRleERlbWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyKSB7XG4gICAgZnVuY3Rpb24gaGVscGVyKCkge1xuICAgICAgICBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgd2hpbGUgKHRhcmdldCA+PSAwICYmIChjaGlsZHJlbi5nZXRBdCh0YXJnZXQpID09IG51bGwgfHwgISFjaGlsZHJlbi5nZXRBdCh0YXJnZXQpPy5oaWRkZW4pKVxuICAgICAgICAgICAgICAgIHRhcmdldCA9IGluZGV4TWFuZ2xlcihpbmRleERlbWFuZ2xlcih0YXJnZXQpIC0gMSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQgPCAwID8gaW5pdGlhbCA6IHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXQgPD0gY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkgJiYgY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KSA9PSBudWxsIHx8ICEhY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KT8uaGlkZGVuKVxuICAgICAgICAgICAgICAgIHRhcmdldCA9IGluZGV4TWFuZ2xlcihpbmRleERlbWFuZ2xlcih0YXJnZXQpICsgMSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQgPiBjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSA/IGluaXRpYWwgOiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdGlhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKGhlbHBlcigpKVxufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdFwiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkSW5mb0Jhc2UsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuZXhwb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9O1xuXG5leHBvcnQgdHlwZSBVc2VSYW5kb21JZFByb3BzUGFyYW1ldGVycyA9IFVzZVJlZmVyZW5jZWRJZFByb3BzUGFyYW1ldGVyczxcImlkXCI+O1xuZXhwb3J0IHR5cGUgVXNlUmFuZG9tSWRQcm9wc1JldHVyblR5cGU8UCBleHRlbmRzIFVzZVJhbmRvbUlkUHJvcHNQYXJhbWV0ZXJzPiA9IFVzZVJlZmVyZW5jZWRJZFByb3BzUmV0dXJuVHlwZTxQLCBcImlkXCI+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkUGFyYW1ldGVyczxJIGV4dGVuZHMgUmFuZG9tSWRDaGlsZEluZm9CYXNlPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8ST4geyBwcmVmaXg/OiBzdHJpbmc7IH1cblxuXG5leHBvcnQgdHlwZSBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8SyBleHRlbmRzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+ID0gUGFydGlhbDxSZWNvcmQ8SywgYW55Pj47Ly88RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4geyB9O1xuXG5cbmV4cG9ydCB0eXBlIFVzZVJlZmVyZW5jZWRJZFByb3BzUmV0dXJuVHlwZTxQIGV4dGVuZHMgVXNlUmVmZXJlbmNlZElkUHJvcHNQYXJhbWV0ZXJzPGFueT4sIEsgZXh0ZW5kcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+PiA9IE9taXQ8UCwgSz4gJiBSZWNvcmQ8Sywgc3RyaW5nPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFJldHVyblR5cGU8UyBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTPjtcbiAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiBVc2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50O1xuICAgIHVzZWRJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGdldFVzZWRJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59XG5cbmludGVyZmFjZSBSYW5kb21JZENoaWxkSW5mb0Jhc2UgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvQmFzZTxcInJlZmVyZW5jZXJcIiB8IFwic291cmNlXCI+IHtcbiAgICBzZXRVc2VkSWQoaWQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgLy9zZW5kU291cmNlSWRUb1JlZmVyZW5jZXJFbGVtZW50KHNvdXJjZUlkOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ8UyBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4gVXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UmV0dXJuVHlwZTxTPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnRSZXR1cm5UeXBlPFMgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdXNlZElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZ2V0VXNlZElkKCk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFM+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxTPjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCA9IDxSIGV4dGVuZHMgRWxlbWVudD4oaWRQcm9wTmFtZToga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+KSA9PiBVc2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UmV0dXJuVHlwZTxSPjtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFJldHVyblR5cGU8UiBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICB1c2VkSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBnZXRVc2VkSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFI+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxSPjtcbn1cblxuXG5cbi8qKlxuICogUmV0dXJucyBhIGhvb2sgdGhhdCBtb2RpZmllcyBhIHNldCBvZiBwcm9wcyB0byBwcm92aWRlIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLlxuICogXG4gKiBJZiB5b3UnZCBsaWtlIHRvIHVzZSB0aGUgSUQgaW4gYSBwcm9wZXJ0eSB0aGF0J3MgKm5vdCogbmFtZWQgYGlkYCAobGlrZSBgZm9yYCBvciBgYXJpYS1sYWJlbGxlZGJ5YCBvciB3aGF0bm90KSwgYHVzZVJlZmVyZW5jZWRJZFByb3BzYCBpcyBhbHNvIHByb3ZpZGVkLlxuICogXG4gKiBBbmQgdGhlIHJhbmRvbWx5LWdlbmVyYXRlZCBpZCBpdHNlbGYgaXMgYWxzbyBwcm92aWRlZCBpbiBjYXNlIHlvdSB3YW50IHRvIGhhbmRsZSB0aGUgbG9naWMgeW91cnNlbGYgd2l0aG91dCBgdXNlTWVyZ2VkUHJvcHNgLlxuICogXG4gKiBVbmxpa2UgbW9zdCBvdGhlciBgdXNlKlByb3BzYCBob29rcywgdGhlc2UgYXJlIG1vc3RseSBzdGFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSYW5kb21JZDxTIGV4dGVuZHMgRWxlbWVudD4oeyBwcmVmaXgsIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH06IFVzZVJhbmRvbUlkUGFyYW1ldGVyczxSYW5kb21JZENoaWxkSW5mb0Jhc2U+KTogVXNlUmFuZG9tSWRSZXR1cm5UeXBlPFM+IHtcbiAgICBjb25zdCBbYmFja3VwUmFuZG9tSWQsICwgZ2V0QmFja3VwUmFuZG9tSWRdID0gdXNlU3RhdGU8c3RyaW5nPigoKSA9PiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeCkpO1xuICAgIGNvbnN0IFt1c2VkSWQsIHNldFVzZWRJZCwgZ2V0VXNlZElkXSA9IHVzZVN0YXRlPHN0cmluZyB8IHVuZGVmaW5lZD4oKCkgPT4gZ2V0QmFja3VwUmFuZG9tSWQoKSk7XG4gICAgY29uc3QgbWlzbWF0Y2hFcnJvclJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUmFuZG9tSWRcIiwgcHJlZml4KTtcblxuICAgIGNvbnN0IHsgdXNlTWFuYWdlZENoaWxkLCBjaGlsZHJlbiB9ID0gdXNlTWFuYWdlZENoaWxkcmVuPFJhbmRvbUlkQ2hpbGRJbmZvQmFzZT4oeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9KTtcblxuICAgIGNvbnN0IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCA9IHVzZUNhbGxiYWNrPFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTPj4oKCkgPT4ge1xuICAgICAgICBjb25zdCBbdXNlZElkTG9jYWwsIHNldFVzZWRJZExvY2FsLCBnZXRVc2VkSWRMb2NhbF0gPSB1c2VTdGF0ZShnZXRVc2VkSWQoKSk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PFM+KCk7XG4gICAgICAgIC8vIEV2ZXJ5IHRpbWUgdGhlIHNvdXJjZSBlbGVtZW50IHJlbmRlcnMsIGluc3BlY3QgdGhlIElEIGl0IGFjdHVhbGx5IHVzZWRcbiAgICAgICAgLy8gKHdoZXRoZXIgaXQgd2FzIG91cnMgb3Igbm90IGlzbid0IHVwIHRvIHVzLCBpdCdzIHVwIHRvIHRoZSBjb21wb25lbnQpXG4gICAgICAgIC8vIHNvIHRoaXMgaXMgaG93IHdlIG5vdGlmeSB0aGUgcmVmZXJlbmNlciBjb21wb25lbnQgb2YgY2hhbmdlc1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5nZXRBdChcInJlZmVyZW5jZXJcIikhLnNldFVzZWRJZChlbGVtZW50LmlkKTtcbiAgICAgICAgICAgICAgICBzZXRVc2VkSWQoZWxlbWVudC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IF86IHZvaWQgPSB1c2VNYW5hZ2VkQ2hpbGQoeyBpbmZvOiB7IGluZGV4OiBcInNvdXJjZVwiLCBzZXRVc2VkSWQ6IHNldFVzZWRJZExvY2FsIH0gfSk7XG5cbiAgICAgICAgY29uc3QgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHMgPSB1c2VDYWxsYmFjazxVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnRSZXR1cm5UeXBlPFM+W1widXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHNcIl0+KGZ1bmN0aW9uIChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxTPikge1xuICAgICAgICAgICAgcC5pZCB8fD0gYmFja3VwUmFuZG9tSWQ7XG4gICAgICAgICAgICByZXR1cm4gdXNlUmVmRWxlbWVudFByb3BzKHApO1xuICAgICAgICB9LCBbXSlcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlZElkOiB1c2VkSWRMb2NhbCxcbiAgICAgICAgICAgIGdldFVzZWRJZDogZ2V0VXNlZElkTG9jYWwsXG4gICAgICAgICAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wc1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQgPSB1c2VDYWxsYmFjazxVc2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50Pig8UiBleHRlbmRzIEVsZW1lbnQ+KGlkUHJvcE5hbWU6IGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFI+KSA9PiB7XG4gICAgICAgIGNvbnN0IFt1c2VkSWRMb2NhbCwgc2V0VXNlZElkTG9jYWwsIGdldFVzZWRJZExvY2FsXSA9IHVzZVN0YXRlKGdldFVzZWRJZCgpKTtcbiAgICAgICAgLy8gV2hhdGV2ZXIgSUQgd2FzIG1vc3QgcmVjZW50bHkgdXNlZCBieSB0aGUgYWN0dWFsIFwiaWRcIiBwcm9wIG9mIHRoZSBzb3VyY2UgZWxlbWVudFxuICAgICAgICB1c2VFbnN1cmVTdGFiaWxpdHkoaWRQcm9wTmFtZSk7XG5cbiAgICAgICAgY29uc3QgX3Y6IHZvaWQgPSB1c2VNYW5hZ2VkQ2hpbGQoeyBpbmZvOiB7IGluZGV4OiBcInJlZmVyZW5jZXJcIiwgc2V0VXNlZElkOiBzZXRVc2VkSWRMb2NhbCB9IH0pO1xuXG4gICAgICAgIGNvbnN0IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyA9IHVzZUNhbGxiYWNrPFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRSZXR1cm5UeXBlPFI+W1widXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzXCJdPihmdW5jdGlvbiA8UiBleHRlbmRzIEVsZW1lbnQ+KHsgW2lkUHJvcE5hbWVdOiBnaXZlbklkLCAuLi5wIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFI+KSB7XG4gICAgICAgICAgICBpZiAoZ2l2ZW5JZCAmJiB1c2VkSWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2l2ZW5JZCAhPSB1c2VkSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtaXNtYXRjaEVycm9yUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc21hdGNoRXJyb3JSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBNdWx0aXBsZSBtaXMtbWF0Y2hlZCBJRHMgd2VyZSBwcm92aWRlZCBmb3IgdGhlICR7aWRQcm9wTmFtZX0gcHJvcDogdGhlIGNoaWxkIGV4cGxpY2l0bHkgc3BlY2lmaWVkICR7Z2l2ZW5JZH0gaW4gaXRzICAke2lkUHJvcE5hbWV9IHByb3AsIGJ1dCB0aGUgcGFyZW50IHRvbGQgdGhpcyBjaGlsZCB0byB1c2UgJHt1c2VkSWR9ICh0aGUgcGFyZW50J3MgSUQpLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPFI+KHAsIHsgW2lkUHJvcE5hbWVdOiB1c2VkSWQgfSk7XG4gICAgICAgIH0sIFt1c2VkSWRdKTtcblxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VkSWQ6IHVzZWRJZExvY2FsLFxuICAgICAgICAgICAgZ2V0VXNlZElkOiBnZXRVc2VkSWRMb2NhbCxcbiAgICAgICAgICAgIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wc1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlZElkLFxuICAgICAgICBnZXRVc2VkSWQsXG4gICAgICAgIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCxcbiAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFxuICAgIH07XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUdsb2JhbEhhbmRsZXIsIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsLCBUYWdTZW5zaXRpdmVQcm9wcyB9IGZyb20gXCIuL3Byb3BzXCI7XHJcblxyXG5sZXQgcHVsc2UgPSAoXCJ2aWJyYXRlXCIgaW4gbmF2aWdhdG9yKSA/ICgoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMCkpIDogKCgpID0+IHsgfSk7XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBlbmFibGUvZGlzYWJsZSBidXR0b24gdmlicmF0aW9uIHB1bHNlcyBvbiBhbiBhcHAtd2lkZSBzY2FsZS5cclxuICogXHJcbiAqIFxyXG4gKiBAcGFyYW0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcnVuIHdoZW4gYSBidXR0b24gaXMgdGFwcGVkLlxyXG4gKiAoRGVmYXVsdCBpcyBgKCkgPT4gbmF2aWdhdG9yLnZpYnJhdGUoMTApYCBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQsIGEgbm9vcCBvdGhlcndpc2UpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0QnV0dG9uVmlicmF0ZShmdW5jOiAoKSA9PiB2b2lkKSB7XHJcbiAgICBwdWxzZSA9IGZ1bmM7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEJ1dHRvblByZXNzRXZlbnQ8RXZlbnRUeXBlIGV4dGVuZHMgRXZlbnQ+ID0gRXZlbnRUeXBlICYgeyBbRXZlbnREZXRhaWxdOiB7IHByZXNzZWQ6IGJvb2xlYW4gfCBudWxsIH0gfTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUJ1dHRvblBhcmFtZXRlcnM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiBleHRlbmRzIFRhZ1NlbnNpdGl2ZVByb3BzPEU+IHtcclxuICAgIHByZXNzZWQ/OiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIG9uUHJlc3M/KGV2ZW50OiBCdXR0b25QcmVzc0V2ZW50PGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPj4gfCBCdXR0b25QcmVzc0V2ZW50PGguSlNYLlRhcmdldGVkS2V5Ym9hcmRFdmVudDxFPiB8IEJ1dHRvblByZXNzRXZlbnQ8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPj4+KTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQnV0dG9uUmV0dXJuVHlwZTxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcclxuICAgIHVzZUFyaWFCdXR0b25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBleGNsdWRlcyh0YXJnZXQ6IFwiY2xpY2tcIiB8IFwic3BhY2VcIiB8IFwiZW50ZXJcIiwgZXhjbHVkZTogdW5kZWZpbmVkIHwgeyBjbGljaz86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBzcGFjZT86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBlbnRlcj86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkIH0pIHtcclxuICAgIGlmIChleGNsdWRlPy5bdGFyZ2V0XSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBzZWxlY3Rpb24uY29udGFpbnNOb2RlIGRvZXNuJ3QgYWNjb3VudCBmb3Igc2VsZWN0aW9uLmlzQ29sbGFwc2VkLFxyXG4gKiBzbyBoZXJlJ3MgYSB3b3JrYXJvdW5kIGZvciB0aGF0LlxyXG4gKiBcclxuICogV2UgYWxzbyBvbmx5IGxvb2sgZm9yIHRoZSBzZWxlY3Rpb24gZW5kIHRvIG9ubHkgY2F0Y2ggdGhlIFxyXG4gKiBlc3NlbnNlIG9mIGEgbm9uLWV4aXN0YW50IFwic2VsZWN0aW9uc3RvcFwiIGV2ZW50LlxyXG4gKiBcclxuICogQHBhcmFtIGVsZW1lbnQgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZnVuY3Rpb24gbm9kZVNlbGVjdGVkVGV4dExlbmd0aChlbGVtZW50OiBFdmVudFRhcmdldCB8IG51bGwgfCB1bmRlZmluZWQpIHtcclxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBOb2RlKSB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChzZWxlY3Rpb24/LnJhbmdlQ291bnQgPz8gMCk7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbiEuZ2V0UmFuZ2VBdChpKSE7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNvbnRhaW5zKHJhbmdlLmVuZENvbnRhaW5lcikgJiYgIXNlbGVjdGlvbj8uaXNDb2xsYXBzZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24hLnRvU3RyaW5nKCkubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAwO1xyXG59XHJcblxyXG4vKipcclxuICogQWRkcyB0aGUgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIHRvIGNyZWF0ZSBhIFwicHJlc3NcIi1saWtlIGV2ZW50IGZvclxyXG4gKiBidXR0b25zIGFuZCBhbnl0aGluZyBlbHNlIHRoYXQncyBcImNsaWNrL3RhcC9wcmVzcy90b3VjaFwiLWFibGUuXHJcbiAqIFxyXG4gKiBOb3RhYmx5LCB0aGUgZm9sbG93aW5nIGNhc2VzIGFyZSBjb3ZlcmVkOlxyXG4gKiAqIFRoZSB0YXJnZXQgZWxlbWVudCBpcyBwcm9wZXJseSBmb2N1c2VkLCBldmVuIG9uIGlPUyBTYWZhcmkgKCplc3BlY2lhbGx5KiBvbiBpT1MgU2FmYXJpKVxyXG4gKiAqIERvdWJsZS1jbGlja3Mgd29uJ3Qgc2VsZWN0IHRleHQuIFxyXG4gKiAqIENvbnZlcnNlbHksIG1hbnVhbGx5IHNlbGVjdGluZyB0ZXh0IHdvbid0IGludm9rZSBhIHByZXNzLlxyXG4gKiAqIEtleWJvYXJkIGV2ZW50cyAmbWRhc2g7IGBlbnRlcmAgaW1tZWRpYXRlbHkgaW52b2tlcyB0aGUgaGFuZGxlciwgd2hpbGUgYHNwYWNlYCBpbnZva2VzIGl0IG9uIGtleXVwLlxyXG4gKiAqIEhhcHRpYyBmZWVkYmFjayAob24sIGxpa2UsIHRoZSBvbmUgYnJvd3NlciBjb21iaW5hdGlvbiB0aGF0IHN1cHBvcnRzIGl0ICZtZGFzaDsgdGhpcyBjYW4gYmUgZGlzYWJsZWQgYXBwLXdpZGUgd2l0aCBgc2V0QnV0dG9uVmlicmF0ZWApXHJcbiAqIFxyXG4gKiBJbiBhZGRpdGlvbiwgd2hlbiB0aGUgQ1NTIGA6YWN0aXZlYCBwc2V1ZG8tY2xhc3Mgd291bGQgYXBwbHkgdG8gYSBub3JtYWwgYnV0dG9uXHJcbiAqIChpLmUuIHdoZW4gaG9sZGluZyB0aGUgc3BhY2ViYXIgb3IgZHVyaW5nIG1vdXNlZG93biksIGB7IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IFwidHJ1ZVwiIH1gXHJcbiAqIGlzIGFkZGVkIHRvIHRoZSBwcm9wcy4gIFlvdSBjYW4gZWl0aGVyIGxldCBpdCBwYXNzIHRocm91Z2ggYW5kIHN0eWxlIGl0IHRocm91Z2ggbmV3IENTUyxcclxuICogb3IgaW5zcGVjdCB0aGUgcmV0dXJuZWQgcHJvcHMgZm9yIGl0IGFuZCBhZGQgZS5nLiBhbiBgLmFjdGl2ZWAgY2xhc3MgZm9yIGV4aXN0aW5nIENTU1xyXG4gKiBcclxuICogQHBhcmFtIG9uQ2xpY2tTeW5jIFxyXG4gKiBAcGFyYW0gZXhjbHVkZSBXaGV0aGVyIHRoZSBwb2x5ZmlsbCBzaG91bGRuJ3QgYXBwbHkgKGNhbiBzcGVjaWZ5IGZvciBzcGVjaWZpYyBpbnRlcmFjdGlvbnMpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlc3NFdmVudEhhbmRsZXJzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4ob25DbGlja1N5bmM6ICgoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxFPikgPT4gdm9pZCkgfCBudWxsIHwgdW5kZWZpbmVkLCBleGNsdWRlOiB1bmRlZmluZWQgfCB7IGNsaWNrPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIHNwYWNlPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIGVudGVyPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQgfSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcclxuXHJcbiAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudDxFPih7fSk7XHJcblxyXG4gICAgLy8gQSBidXR0b24gY2FuIGJlIGFjdGl2YXRlZCBpbiBtdWx0aXBsZSB3YXlzLCBzbyBvbiB0aGUgb2ZmIGNoYW5jZVxyXG4gICAgLy8gdGhhdCBtdWx0aXBsZSBhcmUgdHJpZ2dlcmVkIGF0IG9uY2UsIHdlIG9ubHkgKmFjdHVhbGx5KiByZWdpc3RlclxyXG4gICAgLy8gYSBwcmVzcyBvbmNlIGFsbCBvZiBvdXIgXCJvblwiIHNpZ25hbHMgaGF2ZSB0dXJuZWQgYmFjayB0byBcIm9mZlwiLlxyXG4gICAgLy8gV2UgYXBwcm94aW1hdGUgdGhpcyBieSBqdXN0IGluY3JlbWVudGluZyB3aGVuIGFjdGl2ZSwgYW5kXHJcbiAgICAvLyBkZWNyZW1lbnRpbmcgd2hlbiBkZWFjdGl2YXRlZC5cclxuICAgIC8vXHJcbiAgICAvLyBBcyBhbiBlbWVyZ2VuY3kgZmFpbHNhZmUsIHdoZW4gdGhlIGVsZW1lbnQgbG9vc2VzIGZvY3VzLFxyXG4gICAgLy8gdGhpcyBpcyByZXNldCBiYWNrIHRvIDAuXHJcbiAgICBjb25zdCBbYWN0aXZlLCBzZXRBY3RpdmUsIGdldEFjdGl2ZV0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgICAvLyBJZiB3ZSB0aGUgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiBjaGFuZ2VzIHRvIGluY2x1ZGUgdGhpcyBlbGVtZW50XHJcbiAgICAvLyBEVVJJTkcgZS5nLiBhIG1vdXNlZG93biwgdGhlbiB3ZSBkb24ndCB3YW50IHRoZSBtb3VzZXVwIHRvIFwiY291bnRcIiwgYXMgaXQgd2VyZSxcclxuICAgIC8vIGJlY2F1c2UgaXRzIG9ubHkgcHVycG9zZSB3YXMgc2VsZWN0aW5nIHRleHQsIG5vdCBjbGlja2luZyBidXR0b25zLlxyXG4gICAgLy9cclxuICAgIC8vIFRvIGNhdGNoIHRoaXMsIGFueSB0aW1lIHRoZSB0ZXh0IHNlbGVjdGlvbiBpbmNsdWRlcyB1cyB3aGlsZSBpbiB0aGUgbWlkZGxlXHJcbiAgICAvLyBvZiBhIGNsaWNrLCB0aGlzIGZsYWcgaXMgc2V0LCB3aGljaCBjYW5jZWxzIHRoZSBhY3RpdmF0aW9uIG9mIGEgcHJlc3MuXHJcbiAgICAvLyBUaGUgZmxhZyBpcyByZXNldCBhbnkgdGltZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IG9yIHRoZSBidXR0b24gaXNcclxuICAgIC8vIG5vIGxvbmdlciBhY3RpdmUuXHJcbiAgICBjb25zdCBbdGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSwgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxEYXRlIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJzZWxlY3Rpb25jaGFuZ2VcIiwgXyA9PiB7XHJcbiAgICAgICAgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZShwcmV2ID0+IG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZ2V0RWxlbWVudCgpKSA9PSAwID8gbnVsbCA6IHByZXYgIT0gbnVsbCA/IHByZXYgOiBuZXcgRGF0ZSgpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGFjdGl2ZSA9PSAwKVxyXG4gICAgICAgICAgICBzZXRUZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lKG51bGwpO1xyXG4gICAgfSwgW2FjdGl2ZSA9PSAwXSk7XHJcblxyXG4gICAgY29uc3Qgb25BY3RpdmVTdGFydCA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvbkNsaWNrU3luYz4+KChfKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKGEgPT4gKythKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG9uQWN0aXZlU3RvcCA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvbkNsaWNrU3luYz4+KChlKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKGEgPT4gTWF0aC5tYXgoMCwgLS1hKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICBjb25zdCB0aW1lRGlmZmVyZW5jZSA9ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lID09IG51bGwgPyBudWxsIDogK2N1cnJlbnRUaW1lIC0gK3RleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUpO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZSdyZSBzZWxlY3RpbmcgdGV4dCAoaGV1cmlzdGljYWxseSBkZXRlcm1pbmVkIGJ5IHNlbGVjdGluZyBmb3IgbG9uZ2VyIHRoYW4gMS80IGEgc2Vjb25kLCBvciBtb3JlIHRoYW4gMiBjaGFyYWN0ZXJzKVxyXG4gICAgICAgIC8vIHRoZW4gdGhpcyBpc24ndCBhIHByZXNzIGV2ZW50LlxyXG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG1lYXN1cmUgZ2x5cGhzIGluc3RlYWQgb2YgY2hhcmFjdGVycy5cclxuICAgICAgICBpZiAoKHRpbWVEaWZmZXJlbmNlICYmIHRpbWVEaWZmZXJlbmNlID4gMjUwKSB8fCBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGdldEVsZW1lbnQoKSkgPj0gMikge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChnZXRBY3RpdmUoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVByZXNzKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVByZXNzID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2xpY2tTeW5jPj4oKGUpID0+IHtcclxuICAgICAgICBpZiAob25DbGlja1N5bmMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBlbGVtZW50IGlzIGZvY3VzZWQgaGVyZSBiZWNhdXNlIG9mIGlPUyBTYWZhcmkuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIEl0J3MgYWx3YXlzIGlPUyBTYWZhcmkuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIGlPUyBTYWZhcmkgKHRlc3RlZCBvbiAxMikgZG93bnJpZ2h0IHJlZnVzZXMgdG8gYWxsb3cgXHJcbiAgICAgICAgICAgIC8vIGVsZW1lbnRzIHRvIGJlIG1hbnVhbGx5IGZvY3VzZWQgVU5MRVNTIGl0IGhhcHBlbnMgd2l0aGluXHJcbiAgICAgICAgICAgIC8vIGFuIGV2ZW50IGhhbmRsZXIgbGlrZSB0aGlzLiAgSXQgYWxzbyBkb2Vzbid0IGZvY3VzXHJcbiAgICAgICAgICAgIC8vIGJ1dHRvbnMgYnkgZGVmYXVsdCB3aGVuIGNsaWNrZWQsIHRhcHBlZCwgZXRjLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBJZiBpdCBiZWNvbWVzIHByb2JsZW1hdGljIHRoYXQgYnV0dG9uLWxpa2VzIGV4cGxpY2l0bHkgYmVjb21lXHJcbiAgICAgICAgICAgIC8vIGZvY3VzZWQgd2hlbiB0aGV5IGFyZSBwcmVzc2VkLCB0aGVuIGFuIGFsdGVybmF0aXZlIHNvbHV0aW9uIGZvclxyXG4gICAgICAgICAgICAvLyB0aGUgcXVlc3Rpb24gb2YgXCJob3cgZG8gbWVudSBidXR0b25zIGtlZXAgdGhlaXIgbWVudXMgb3BlblwiXHJcbiAgICAgICAgICAgIC8vIGFuZCBvdGhlciBmb2N1cy1yZWxhdGVkIG5vbnNlbnNlIG5lZWRzIHRvIGJlIGZpZ3VyZWQgb3V0LlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBGb3IgaU9TIFNhZmFyaS5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgXCJmb2N1c1wiIGluIChlbGVtZW50IGFzIEV2ZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50KSlcclxuICAgICAgICAgICAgICAgIChlbGVtZW50IGFzIEV2ZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50IHwgbnVsbCk/LmZvY3VzKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBXaGF0ZXZlciB0aGUgYnJvd3NlciB3YXMgZ29pbmcgdG8gZG8gd2l0aCB0aGlzIGV2ZW50LFxyXG4gICAgICAgICAgICAvLyBmb3JnZXQgaXQuIFdlJ3JlIHR1cm5pbmcgaXQgaW50byBhIFwicHJlc3NcIiBldmVudC5cclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWxzbyBzdG9wIGFueW9uZSBlbHNlIGZyb20gbGlzdGVuaW5nIHRvIHRoaXMgZXZlbnQsXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGV4cGxpY2l0bHkgaGFuZGxpbmcgaXQuXHJcbiAgICAgICAgICAgIC8vIChOb3RhYmx5LCB0aGlzIGFsbG93cyBsYWJlbHMgdG8gd3JhcCBpbnB1dHMsIHdpdGggdGhlbVxyXG4gICAgICAgICAgICAvLyBib3RoIGhhdmluZyBwcmVzcyBldmVudCBoYW5kbGVycywgd2l0aG91dCBkb3VibGUtZmlyaW5nKVxyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFwdGljIGZlZWRiYWNrIGZvciB0aGlzIHByZXNzIGV2ZW50XHJcbiAgICAgICAgICAgIHB1bHNlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBBY3R1YWxseSBjYWxsIG91ciBoYW5kbGVyLlxyXG4gICAgICAgICAgICBvbkNsaWNrU3luYyhlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBvbk1vdXNlRG93biA9IGV4Y2x1ZGVzKFwiY2xpY2tcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+KSA9PiB7XHJcbiAgICAgICAgLy8gU3RvcCBkb3VibGUgY2xpY2tzIGZyb20gc2VsZWN0aW5nIHRleHQgaW4gYW4gY29tcG9uZW50IHRoYXQncyAqc3VwcG9zZWQqIHRvIGJlIGFjdGluZyBsaWtlIGEgYnV0dG9uLFxyXG4gICAgICAgIC8vIGJ1dCBhbHNvIGRvbid0IHByZXZlbnQgdGhlIHVzZXIgZnJvbSBzZWxlY3RpbmcgdGhhdCB0ZXh0IG1hbnVhbGx5IGlmIHRoZXkgcmVhbGx5IHdhbnQgdG9cclxuICAgICAgICAvLyAod2hpY2ggdXNlci1zZWxlY3Q6IG5vbmUgd291bGQgZG8sIGJ1dCBjYW5jZWxsaW5nIGEgZG91YmxlIGNsaWNrIG9uIG1vdXNlRG93biBkb2Vzbid0KVxyXG4gICAgICAgIGlmIChlLmRldGFpbCA+IDEpXHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcblxyXG4gICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMClcclxuICAgICAgICAgICAgb25BY3RpdmVTdGFydChlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9uTW91c2VVcCA9IGV4Y2x1ZGVzKFwiY2xpY2tcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+KSA9PiB7XHJcbiAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwICYmIGFjdGl2ZSA+IDApXHJcbiAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3Qgb25CbHVyID0gKF86IGguSlNYLlRhcmdldGVkRXZlbnQ8RT4pID0+IHtcclxuICAgICAgICBzZXRBY3RpdmUoMCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9IGV4Y2x1ZGVzKFwiY2xpY2tcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiBvbkJsdXI7XHJcblxyXG4gICAgY29uc3Qgb25LZXlEb3duID0gZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSAmJiBleGNsdWRlcyhcImVudGVyXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGU6IGguSlNYLlRhcmdldGVkS2V5Ym9hcmRFdmVudDxFPikgPT4ge1xyXG4gICAgICAgIGlmIChlLmtleSA9PSBcIiBcIiAmJiBvbkNsaWNrU3luYyAmJiAhZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSkge1xyXG4gICAgICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBhY3RpdmF0ZSBpdCBvbiBhIHNwYWNlIGtleWRvd25cclxuICAgICAgICAgICAgLy8gYnV0IHdlIGRvIHByZXZlbnREZWZhdWx0IHRvIHN0b3AgdGhlIHBhZ2UgZnJvbSBzY3JvbGxpbmcuXHJcbiAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlLmtleSA9PSBcIkVudGVyXCIgJiYgIWV4Y2x1ZGVzKFwiZW50ZXJcIiwgZXhjbHVkZSkpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xyXG4gICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9uS2V5VXAgPSBleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGU6IGguSlNYLlRhcmdldGVkS2V5Ym9hcmRFdmVudDxFPikgPT4ge1xyXG4gICAgICAgIGlmIChlLmtleSA9PSBcIiBcIiAmJiAhZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSlcclxuICAgICAgICAgICAgb25BY3RpdmVTdG9wKGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZTogaC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+KSA9PiB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGlmIChlLmRldGFpbCA+IDEpIHtcclxuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHVzZVJlZkVsZW1lbnRQcm9wcygoeyBvbktleURvd24sIG9uS2V5VXAsIG9uQmx1ciwgb25Nb3VzZURvd24sIG9uTW91c2VVcCwgb25Nb3VzZUxlYXZlLCBvbkNsaWNrLCBzdHlsZTogKHRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUgIT0gbnVsbCkgPyB7IGN1cnNvcjogXCJ0ZXh0XCIgfSA6IHVuZGVmaW5lZCwgLi4ueyBcImRhdGEtcHNldWRvLWFjdGl2ZVwiOiBhY3RpdmUgJiYgKHRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUgPT0gbnVsbCkgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9IGFzIHt9IH0pKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFCdXR0b248RSBleHRlbmRzIEV2ZW50VGFyZ2V0Pih7IHRhZywgcHJlc3NlZCwgb25QcmVzcyB9OiBVc2VBcmlhQnV0dG9uUGFyYW1ldGVyczxFPik6IFVzZUFyaWFCdXR0b25SZXR1cm5UeXBlPEU+IHtcclxuXHJcbiAgICBmdW5jdGlvbiB1c2VBcmlhQnV0dG9uUHJvcHMoeyBcImFyaWEtcHJlc3NlZFwiOiBhcmlhUHJlc3NlZCwgdGFiSW5kZXgsIHJvbGUsIC4uLnAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb3BzID0gdXNlTWVyZ2VkUHJvcHM8RT4odXNlUHJlc3NFdmVudEhhbmRsZXJzPEU+KChlKSA9PiBvblByZXNzPy4oZW5oYW5jZUV2ZW50KGUsIHsgcHJlc3NlZDogcHJlc3NlZCA9PSBudWxsID8gbnVsbCA6ICFwcmVzc2VkIH0pKSwgdW5kZWZpbmVkKSwgcCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJ1dHRvblByb3BzID0geyByb2xlLCB0YWJJbmRleCwgXCJhcmlhLXByZXNzZWRcIjogYXJpYVByZXNzZWQgPz8gKHByZXNzZWQgPT09IHRydWUgPyBcInRydWVcIiA6IHByZXNzZWQgPT09IGZhbHNlID8gXCJmYWxzZVwiIDogdW5kZWZpbmVkKSB9O1xyXG4gICAgICAgIGNvbnN0IGRpdlByb3BzID0geyAuLi5idXR0b25Qcm9wcywgdGFiSW5kZXg6IHRhYkluZGV4ID8/IDAsIHJvbGU6IHJvbGUgPz8gXCJidXR0b25cIiB9O1xyXG4gICAgICAgIGNvbnN0IGFuY2hvclByb3BzID0geyAuLi5kaXZQcm9wcyB9O1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHRhZykge1xyXG4gICAgICAgICAgICBjYXNlIFwiYnV0dG9uXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oYnV0dG9uUHJvcHMsIHByb3BzKTtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgXCJhXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oYW5jaG9yUHJvcHMsIHByb3BzKTtcclxuXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oZGl2UHJvcHMsIHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VBcmlhQnV0dG9uUHJvcHNcclxuICAgIH1cclxufVxyXG5cclxuXHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHJldHVyblRydWUsIHVzZUNoaWxkcmVuRmxhZywgdXNlRWZmZWN0LCB1c2VIYXNGb2N1cywgdXNlTGluZWFyTmF2aWdhdGlvbiwgdXNlTWFuYWdlZENoaWxkcmVuLCB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgRmxhZ2dhYmxlQ2hpbGRJbmZvQmFzZSwgTWFuYWdlZENoaWxkcmVuIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgVGFnU2Vuc2l0aXZlUHJvcHMgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VQcmVzc0V2ZW50SGFuZGxlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcblxyXG5leHBvcnQgdHlwZSBVc2VBcmlhQWNjb3JkaW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUFyaWFBY2NvcmRpb25QYXJhbWV0ZXJzKSA9PiBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZTxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVycykgPT4gVXNlQXJpYUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMge1xyXG4gICAgaW5pdGlhbEluZGV4PzogbnVtYmVyIHwgbnVsbDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZTxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbjogVXNlQXJpYUFjY29yZGlvblNlY3Rpb248SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+O1xyXG4gICAgYWNjb3JkaW9uU2VjdGlvbnM6IE1hbmFnZWRDaGlsZHJlbjxVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlPjtcclxuICAgIGNoYW5nZUV4cGFuZGVkSW5kZXg6IChhcmc6IG51bWJlciB8ICgocHJldlN0YXRlOiBudW1iZXIgfCBudWxsKSA9PiBudW1iZXIgfCBudWxsKSB8IG51bGwpID0+IG51bWJlciB8IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25JbmZvQmFzZSBleHRlbmRzIEZsYWdnYWJsZUNoaWxkSW5mb0Jhc2U8XCJ0YWJiZWRcIiB8IFwib3BlblwiPiB7XHJcbiAgICAvL29wZW4/OiBib29sZWFuIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuICAgIHNldE9wZW5Gcm9tUGFyZW50KG9wZW46IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgZ2V0T3BlbkZyb21QYXJlbnQoKTogYm9vbGVhbiB8IG51bGw7XHJcbiAgICBmb2N1cygpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVycyB7XHJcbiAgICBpbmZvOiBPbWl0PFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSW5mb0Jhc2UsIFwic2V0T3BlbkZyb21QYXJlbnRcIiB8IFwiZ2V0T3BlbkZyb21QYXJlbnRcIiB8IFwiZm9jdXNcIiB8IFwiZmxhZ3NcIj47XHJcbiAgICBvcGVuPzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGU8SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgZXhwYW5kZWQ6IGJvb2xlYW47XHJcbiAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PjtcclxuICAgIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+O1xyXG59XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXI8RSBleHRlbmRzIEVsZW1lbnQ+ID0gKHsgdGFnIH06IFRhZ1NlbnNpdGl2ZVByb3BzPEU+KSA9PiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclJldHVyblR5cGU8RT47XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+OyB9XHJcbmV4cG9ydCB0eXBlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keTxFIGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlSZXR1cm5UeXBlPEU+O1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IHsgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+OyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvbjxIZWFkZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50Pih7IGluaXRpYWxJbmRleCB9OiBVc2VBcmlhQWNjb3JkaW9uUGFyYW1ldGVycyk6IFVzZUFyaWFBY2NvcmRpb25SZXR1cm5UeXBlPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PiB7XHJcblxyXG4gICAgLy9jb25zdCBbbGFzdEZvY3VzZWRJbmRleCwgc2V0TGFzdEZvY3VzZWRJbmRleCwgX2dldExhc3RGb2N1c2VkSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcbiAgICBjb25zdCBbX2N1cnJlbnRGb2N1c2VkSW5kZXgsIHNldEN1cnJlbnRGb2N1c2VkSW5kZXgsIGdldEN1cnJlbnRGb2N1c2VkSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGQ6IHVzZU1hbmFnZWRDaGlsZFNlY3Rpb24sIGNoaWxkcmVuIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48VXNlQXJpYUFjY29yZGlvblNlY3Rpb25JbmZvQmFzZT4oeyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrKChtLCB1KSA9PiB7IG9jbWMxKG0sIHUpOyBvY21jMihtLCB1KSB9KSwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsIH0pO1xyXG5cclxuICAgIGNvbnN0IG5hdmlnYXRlVG9GaXJzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoMCk7IH0sIFtdKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9MYXN0ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBjaGFuZ2VUYWJiZWRJbmRleChjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSk7IH0sIFtdKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9QcmV2ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBjaGFuZ2VUYWJiZWRJbmRleChpID0+ICgoaSA/PyAwKSAtIDEpKSB9LCBbXSk7XHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTmV4dCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoaSA9PiAoKGkgPz8gMCkgKyAxKSkgfSwgW10pO1xyXG4gICAgY29uc3QgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHMgfSA9IHVzZUxpbmVhck5hdmlnYXRpb248SGVhZGVyRWxlbWVudD4oeyBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcImJsb2NrXCIsIG5hdmlnYXRlVG9GaXJzdCwgbmF2aWdhdGVUb0xhc3QsIG5hdmlnYXRlVG9QcmV2LCBuYXZpZ2F0ZVRvTmV4dCB9KTtcclxuXHJcblxyXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleDogY2hhbmdlRXhwYW5kZWRJbmRleCwgZ2V0Q3VycmVudEluZGV4OiBnZXRDdXJyZW50RXhwYW5kZWRJbmRleCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY21jMSB9ID0gdXNlQ2hpbGRyZW5GbGFnKHtcclxuICAgICAgICBpbml0aWFsSW5kZXgsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAga2V5OiBcIm9wZW5cIixcclxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleDogY2hhbmdlVGFiYmVkSW5kZXgsIGdldEN1cnJlbnRJbmRleDogZ2V0VGFiYmVkSW5kZXgsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogb2NtYzIgfSA9IHVzZUNoaWxkcmVuRmxhZyh7XHJcbiAgICAgICAgaW5pdGlhbEluZGV4LFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGtleTogXCJ0YWJiZWRcIixcclxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZSxcclxuICAgICAgICBvbkluZGV4Q2hhbmdlOiB1c2VDYWxsYmFjaygoaTogbnVtYmVyIHwgbnVsbCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5nZXRBdChpKT8uZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtdKVxyXG4gICAgfSlcclxuXHJcbiAgICBjb25zdCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbjogVXNlQXJpYUFjY29yZGlvblNlY3Rpb248SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+ID0gdXNlQ2FsbGJhY2s8VXNlQXJpYUFjY29yZGlvblNlY3Rpb248SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+PigoeyBvcGVuOiBvcGVuRnJvbVVzZXIsIGluZm86IGFyZ3MgfTogVXNlQXJpYUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzKSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gYXJncy5pbmRleDtcclxuXHJcbiAgICAgICAgY29uc3QgW29wZW5Gcm9tUGFyZW50LCBzZXRPcGVuRnJvbVBhcmVudCwgZ2V0T3BlbkZyb21QYXJlbnRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KG51bGwpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VCb2R5QXNTb3VyY2VJZCwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlSGVhZGVyQXNSZWZlcmVuY2VySWQgfSA9IHVzZVJhbmRvbUlkPEJvZHlFbGVtZW50Pih7IHByZWZpeDogXCJhcmlhLWFjY29yZGlvbi1zZWN0aW9uLWJvZHktXCIsIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0pO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VIZWFkZXJBc1NvdXJjZUlkLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VCb2R5QXNSZWZlcmVuY2VySWQgfSA9IHVzZVJhbmRvbUlkPEhlYWRlckVsZW1lbnQ+KHsgcHJlZml4OiBcImFyaWEtYWNjb3JkaW9uLXNlY3Rpb24taGVhZGVyLVwiLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9KTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VCb2R5QXNTb3VyY2VJZFByb3BzIH0gPSB1c2VCb2R5QXNTb3VyY2VJZCgpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VCb2R5QXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlQm9keUFzUmVmZXJlbmNlcklkPEJvZHlFbGVtZW50PihcImFyaWEtbGFiZWxsZWRieVwiIGFzIG5ldmVyKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VIZWFkZXJBc1NvdXJjZUlkUHJvcHMgfSA9IHVzZUhlYWRlckFzU291cmNlSWQoKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlSGVhZGVyQXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlSGVhZGVyQXNSZWZlcmVuY2VySWQ8SGVhZGVyRWxlbWVudD4oXCJhcmlhLWNvbnRyb2xzXCIgYXMgbmV2ZXIpO1xyXG5cclxuICAgICAgICBjb25zdCBvcGVuID0gKChvcGVuRnJvbVVzZXIgPz8gb3BlbkZyb21QYXJlbnQpID8/IGZhbHNlKTtcclxuICAgICAgICAvL2NvbnN0IGdldE9wZW4gPSB1c2VTdGFibGVHZXR0ZXIoISFvcGVuKTtcclxuICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUdldHRlcihpbmRleCk7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IENvbnZlcnQgdG8gdXNlIHVzZU1hbmFnZWRDaGlsZCBzbyB0aGF0IHRoaXMgaG9vayBcclxuICAgICAgICAvLyBpcyBzdGFibGUgd2l0aG91dCAoZGlyZWN0bHkpIGRlcGVuZGluZyBvbiB0aGUgb3BlbiBzdGF0ZS5cclxuXHJcbiAgICAgICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRIZWFkZXJFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUhlYWRlclJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxIZWFkZXJFbGVtZW50Pih7fSk7XHJcbiAgICAgICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRCb2R5RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VCb2R5UmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PEJvZHlFbGVtZW50Pih7fSk7XHJcbiAgICAgICAgY29uc3QgZm9jdXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChnZXRDdXJyZW50Rm9jdXNlZEluZGV4KCkgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIChnZXRIZWFkZXJFbGVtZW50KCkgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCk/LmZvY3VzKCk7XHJcbiAgICAgICAgfSwgW10pO1xyXG4gICAgICAgIGNvbnN0IG9wZW5SZWYgPSB1c2VSZWYoe1xyXG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0T3BlbkZyb21QYXJlbnQoKSxcclxuICAgICAgICAgICAgc2V0OiAob3BlbjogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0T3BlbkZyb21QYXJlbnQob3Blbik7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9wZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5RWxlbWVudCA9IGdldEJvZHlFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRXhwYW5kZWRJbmRleChnZXRJbmRleCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gYm9keUVsZW1lbnQuZm9jdXMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpc1ZhbGlkOiByZXR1cm5UcnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgdGFiYmVkUmVmID0gdXNlUmVmKHtcclxuICAgICAgICAgICAgZ2V0OiAoKSA9PiAoZ2V0Q3VycmVudEZvY3VzZWRJbmRleCgpID09IGdldEluZGV4KCkpLFxyXG4gICAgICAgICAgICBzZXQ6IChvcGVuOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3BlbilcclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50Rm9jdXNlZEluZGV4KGdldEluZGV4KCkpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpc1ZhbGlkOiByZXR1cm5UcnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgX186IHZvaWQgPSB1c2VNYW5hZ2VkQ2hpbGRTZWN0aW9uKHsgaW5mbzogeyBpbmRleCwgc2V0T3BlbkZyb21QYXJlbnQsIGdldE9wZW5Gcm9tUGFyZW50LCBmb2N1cywgZmxhZ3M6IHsgb3Blbjogb3BlblJlZi5jdXJyZW50LCB0YWJiZWQ6IHRhYmJlZFJlZi5jdXJyZW50IH0gfSB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcyh7IFtcImFyaWEtZXhwYW5kZWRcIl06IGFyaWFFeHBhbmRlZCwgW1wiYXJpYS1kaXNhYmxlZFwiXTogYXJpYURpc2FibGVkLCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+IHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG9uRm9jdXMgPSAoKSA9PiB7IGNoYW5nZVRhYmJlZEluZGV4KGFyZ3MuaW5kZXgpOyB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9uQ2xpY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2V0T3BlbkZyb21QYXJlbnQoKSlcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VFeHBhbmRlZEluZGV4KG51bGwpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUV4cGFuZGVkSW5kZXgoYXJncy5pbmRleCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBwcm9wcy50YWJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldEIgPSB1c2VNZXJnZWRQcm9wczxIZWFkZXJFbGVtZW50Pih1c2VQcmVzc0V2ZW50SGFuZGxlcnM8SGVhZGVyRWxlbWVudD4ob25DbGljaywgdW5kZWZpbmVkKSwgcHJvcHMpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmV0QyA9IHVzZUhlYWRlckFzUmVmZXJlbmNlcklkUHJvcHMoe1xyXG4gICAgICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IChhcmlhRXhwYW5kZWQgPz8gKG9wZW4pLnRvU3RyaW5nKCkpLFxyXG4gICAgICAgICAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IChhcmlhRGlzYWJsZWQgPz8gKG9wZW4gPyBcInRydWVcIiA6IHVuZGVmaW5lZCkpLFxyXG4gICAgICAgICAgICAgICAgLi4udXNlSGVhZGVyUmVmRWxlbWVudFByb3BzKHJldEIpXHJcbiAgICAgICAgICAgIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmV0RCA9IHVzZUhlYWRlckFzU291cmNlSWRQcm9wcyhyZXRDKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJldDM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+XHJcbiAgICAgICAgICAgICAgICA9IHVzZU1lcmdlZFByb3BzPEhlYWRlckVsZW1lbnQ+KHJldEQsIHsgb25Gb2N1cyB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXNlTGluZWFyTmF2aWdhdGlvblByb3BzKHJldDMpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+O1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzKHsgcm9sZSwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+IHtcclxuICAgICAgICAgICAgY29uc3QgcmV0MSA9IHVzZUJvZHlBc1JlZmVyZW5jZXJJZFByb3BzKHsgcm9sZTogcm9sZSA/PyBcInJlZ2lvblwiLCAuLi5wcm9wcyB9KTtcclxuICAgICAgICAgICAgY29uc3QgcmV0MiA9IHVzZUJvZHlBc1NvdXJjZUlkUHJvcHMocmV0MSk7XHJcbiAgICAgICAgICAgIHJldDIudGFiSW5kZXggPz89IC0xO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlQm9keVJlZkVsZW1lbnRQcm9wcyhyZXQyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGV4cGFuZGVkOiBvcGVuLFxyXG4gICAgICAgICAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzLFxyXG4gICAgICAgICAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyxcclxuICAgICAgICB9XHJcbiAgICB9LCBbdXNlTGluZWFyTmF2aWdhdGlvblByb3BzXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjaGFuZ2VFeHBhbmRlZEluZGV4LFxyXG4gICAgICAgIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uLFxyXG4gICAgICAgIGFjY29yZGlvblNlY3Rpb25zOiBjaGlsZHJlblxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBUYWdTZW5zaXRpdmVQcm9wcyB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZVByZXNzRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGFiZWxQYXJhbWV0ZXJzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcclxuICAgIGxhYmVsUHJlZml4OiBzdHJpbmc7XHJcbiAgICBpbnB1dFByZWZpeDogc3RyaW5nO1xyXG4gICAgdGFnSW5wdXQ6IEVsZW1lbnRUb1RhZzxJbnB1dEVsZW1lbnQ+O1xyXG4gICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xyXG59XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBJRCBhbmQgXCJhcmlhLWxhYmVsbGVkYnlcIiBmb3IgdHdvIGVsZW1lbnRzLCBhbiBcImlucHV0XCIgZWxlbWVudCBhbmQgYSBcImxhYmVsXCIgZWxlbWVudC5cclxuICogXHJcbiAqIFJldHVybnMgdGhlIGB1c2VSZWZlcmVuY2VkSWRQcm9wc2AgaG9va3MgaWYgeW91IG5lZWQgdG8gYWxzbyBhZGQgb3RoZXIgSUQtcmVmZXJlbmNlciBhdHRyaWJ1dGVzLCBsaWtlIGBmb3JgXHJcbiAqIFxyXG4gKiBAc2VlIHVzZUlucHV0TGFiZWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMYWJlbDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxhYmVsUHJlZml4LCBpbnB1dFByZWZpeCwgdGFnSW5wdXQsIHRhZ0xhYmVsIH06IFVzZUxhYmVsUGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4gPSB7IGxhYmVsUHJlZml4OiBcImxhYmVsLVwiLCBpbnB1dFByZWZpeDogXCJpbnB1dC1cIiwgdGFnSW5wdXQ6IFwiaW5wdXRcIiBhcyBuZXZlciwgdGFnTGFiZWw6IFwibGFiZWxcIiBhcyBuZXZlciB9KSB7XHJcblxyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZUxhYmVsQXNTb3VyY2VJZCwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlTGFiZWxBc1JlZmVyZW5jZXJJZCwgdXNlZElkOiBsYWJlbElkIH0gPSB1c2VSYW5kb21JZDxMYWJlbEVsZW1lbnQ+KHsgcHJlZml4OiBsYWJlbFByZWZpeCwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlSW5wdXRBc1NvdXJjZUlkLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VJbnB1dEFzUmVmZXJlbmNlcklkLCB1c2VkSWQ6IGlucHV0SWQgfSA9IHVzZVJhbmRvbUlkPElucHV0RWxlbWVudD4oeyBwcmVmaXg6IGlucHV0UHJlZml4LCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9KTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZUxhYmVsQXNTb3VyY2VJZFByb3BzIH0gPSB1c2VMYWJlbEFzU291cmNlSWQoKTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZUlucHV0QXNTb3VyY2VJZFByb3BzIH0gPSB1c2VJbnB1dEFzU291cmNlSWQoKTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VMYWJlbEFzUmVmZXJlbmNlcklkUHJvcHMgfSA9IHVzZUxhYmVsQXNSZWZlcmVuY2VySWQ8SW5wdXRFbGVtZW50PihcImFyaWEtbGFiZWxsZWRieVwiIGFzIG5ldmVyKTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VJbnB1dEFzUmVmZXJlbmNlcklkUHJvcHMgfSA9IHVzZUlucHV0QXNSZWZlcmVuY2VySWQ8TGFiZWxFbGVtZW50PihcImZvclwiKTtcclxuXHJcbiAgICBsZXQgaXNTeW50aGV0aWNMYWJlbCA9ICh0YWdJbnB1dCAhPSBcImlucHV0XCIgfHwgdGFnTGFiZWwgIT0gXCJsYWJlbFwiKTtcclxuXHJcbiAgICBjb25zdCB1c2VMYWJlbExhYmVsOiAoKCkgPT4ge3VzZUxhYmVsTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O30pID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTGFiZWxMYWJlbCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VMYWJlbExhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4gPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHByb3BzV2l0aG91dEZvciA9IHVzZUxhYmVsQXNTb3VyY2VJZFByb3BzKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIGxldCBwcm9wc1dpdGhGb3IgPSB1c2VJbnB1dEFzUmVmZXJlbmNlcklkUHJvcHMocHJvcHNXaXRob3V0Rm9yKTtcclxuICAgICAgICAgICAgICAgIGlmICh0YWdMYWJlbCA9PSBcImxhYmVsXCIgJiYgdGFnSW5wdXQgPT0gXCJpbnB1dFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1dpdGhGb3I7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzV2l0aG91dEZvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtpc1N5bnRoZXRpY0xhYmVsXSk7XHJcblxyXG4gICAgY29uc3QgdXNlTGFiZWxJbnB1dCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUxhYmVsSW5wdXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlTGFiZWxJbnB1dFByb3BzOiAoeyBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRieSwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoIWFyaWFMYWJlbGxlZGJ5KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeSA9IHVzZUlucHV0QXNTb3VyY2VJZFByb3BzKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzV2l0aEFyaWFMYWJlbGxlZEJ5ID0gdXNlTGFiZWxBc1JlZmVyZW5jZXJJZFByb3BzKHByb3BzV2l0aG91dEFyaWFMYWJlbGxlZEJ5KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N5bnRoZXRpY0xhYmVsKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1dpdGhBcmlhTGFiZWxsZWRCeTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNXaXRob3V0QXJpYUxhYmVsbGVkQnk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VMYWJlbElucHV0LFxyXG4gICAgICAgIHVzZUxhYmVsTGFiZWwsXHJcbiAgICAgICAgbGFiZWxJZCxcclxuICAgICAgICBpbnB1dElkXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCI7XHJcbiAgICByb2xlOiBzdHJpbmc7XHJcbiAgICBkaXNhYmxlZDogYm9vbGVhbjtcclxuICAgIGNoZWNrZWQ6IGJvb2xlYW47XHJcbiAgICB0YWdJbnB1dDogRWxlbWVudFRvVGFnPElucHV0VHlwZT47XHJcbiAgICB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsVHlwZT47XHJcbiAgICBvbklucHV0PyhldmVudDogaC5KU1guVGFyZ2V0ZWRFdmVudDxJbnB1dFR5cGU+KTogdm9pZDtcclxuICAgIG9uSW5wdXQ/KGV2ZW50OiBoLkpTWC5UYXJnZXRlZEV2ZW50PExhYmVsVHlwZT4pOiB2b2lkO1xyXG59XHJcblxyXG5jb25zdCBoYW5kbGVzSW5wdXQgPSA8RSBleHRlbmRzIEVsZW1lbnQ+KHRhZzogRWxlbWVudFRvVGFnPEU+LCBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCIsIHdoaWNoOiBcImlucHV0LWVsZW1lbnRcIiB8IFwibGFiZWwtZWxlbWVudFwiKSA9PiB7XHJcbiAgICBpZiAobGFiZWxQb3NpdGlvbiA9PT0gXCJzZXBhcmF0ZVwiKSB7XHJcbiAgICAgICAgaWYgKHdoaWNoID09PSBcImlucHV0LWVsZW1lbnRcIilcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZWxzZSBpZiAod2hpY2ggPT09IFwibGFiZWwtZWxlbWVudFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gdGFnICE9IFwiaW5wdXRcIjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT09IFwid3JhcHBpbmdcIikge1xyXG4gICAgICAgIGlmICh3aGljaCA9PT0gXCJpbnB1dC1lbGVtZW50XCIpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAod2hpY2ggPT0gXCJsYWJlbC1lbGVtZW50XCIpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50PElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4ge1xyXG4gICAgZ2V0SW5wdXRFbGVtZW50OiAoKSA9PiBJbnB1dFR5cGUgfCBudWxsO1xyXG4gICAgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHM6ICh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudDxMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHtcclxuICAgIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzOiAoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+O1xyXG59XHJcblxyXG4vKipcclxuICogSGFuZGxlcyBsYWJlbCB0eXBlICh3cmFwcGluZyBvciBzZXBhcmF0ZSkgZm9yIGNoZWNrYm94ZXMsIHJhZGlvcywgc3dpdGNoZXMsIGV0Yy5cclxuICogQHBhcmFtIHBhcmFtMCBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlPElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudD4oeyBjaGVja2VkLCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgb25JbnB1dCwgcm9sZSwgdGFnSW5wdXQsIHRhZ0xhYmVsIH06IFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KSB7XHJcblxyXG4gICAgY29uc3Qgc3RhYmxlT25JbnB1dCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0VHlwZT4gfCBoLkpTWC5UYXJnZXRlZEV2ZW50PExhYmVsVHlwZT4pID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBvbklucHV0Py4oZSBhcyBoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0VHlwZT4pOyB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXQ6IHVzZUlMSW5wdXQsIHVzZUxhYmVsTGFiZWw6IHVzZUlMTGFiZWwsIGlucHV0SWQsIGxhYmVsSWQgfSA9IHVzZUxhYmVsPElucHV0VHlwZSwgTGFiZWxUeXBlPih7IGxhYmVsUHJlZml4OiBcImFyaWEtY2hlY2tib3gtbGFiZWwtXCIsIGlucHV0UHJlZml4OiBcImFyaWEtY2hlY2tib3gtaW5wdXQtXCIsIHRhZ0lucHV0OiB0YWdJbnB1dCBhcyBuZXZlciwgdGFnTGFiZWw6IHRhZ0xhYmVsIGFzIG5ldmVyIH0pO1xyXG5cclxuXHJcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldExhYmVsRWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VMYWJlbFJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxMYWJlbFR5cGU+KCk7XHJcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldElucHV0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VJbnB1dFJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxJbnB1dFR5cGU+KCk7XHJcblxyXG4gICAgY29uc3QgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50OiBVc2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQ8SW5wdXRUeXBlPiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCkge1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ0lucHV0O1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dFByb3BzOiB1c2VJTElucHV0UHJvcHMgfSA9IHVzZUlMSW5wdXQoKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudDxJbnB1dFR5cGU+KHt9KTtcclxuXHJcbiAgICAgICAgLy8gb25DbGljayBhbmQgb25DaGFuZ2UgYXJlIGEgYml0IG1lc3N5LCBzbyB3ZSBuZWVkIHRvXHJcbiAgICAgICAgLy8gKmFsd2F5cyogbWFrZSBzdXJlIHRoYXQgdGhlIHZpc2libGUgc3RhdGUgaXMgY29ycmVjdFxyXG4gICAgICAgIC8vIGFmdGVyIGFsbCB0aGUgZXZlbnQgZHVzdCBzZXR0bGVzLlxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8yNzQ1LFxyXG4gICAgICAgIC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8xODk5I2lzc3VlY29tbWVudC01MjU2OTAxOTRcclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiB0YWcgPT0gXCJpbnB1dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAoZWxlbWVudCBhcyBFbGVtZW50IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSBjaGVja2VkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbdGFnLCBjaGVja2VkXSlcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgZ2V0SW5wdXRFbGVtZW50OiBnZXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyB9O1xyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPiB7XHJcblxyXG4gICAgICAgICAgICAvLyBGb3Igc29tZSByZWFzb24sIENocm9tZSB3b24ndCBmaXJlIG9uSW5wdXQgZXZlbnRzIGZvciByYWRpbyBidXR0b25zIHRoYXQgYXJlIHRhYkluZGV4PS0xPz9cclxuICAgICAgICAgICAgLy8gTmVlZHMgaW52ZXN0aWdhdGluZywgYnV0IG9uSW5wdXQgd29ya3MgZmluZSBpbiBGaXJlZm94XHJcbiAgICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICAgICAgbGV0IHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+ID0gdXNlUHJlc3NFdmVudEhhbmRsZXJzPElucHV0VHlwZT4oZGlzYWJsZWQgfHwgIWhhbmRsZXNJbnB1dCh0YWcsIGxhYmVsUG9zaXRpb24sIFwiaW5wdXQtZWxlbWVudFwiKSA/IHVuZGVmaW5lZCA6IHN0YWJsZU9uSW5wdXQsIHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGFnID09IFwiaW5wdXRcIilcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uSW5wdXQgPSAoZTogRXZlbnQpID0+IGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIHByb3BzID0gdXNlUmVmRWxlbWVudFByb3BzKHVzZUlMSW5wdXRQcm9wcyhwcm9wcykpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgd3JhcHBlZCBsYWJlbCBoYW5kbGVzIGFsbCBpbnRlcmFjdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGlzIGVsZW1lbnQgY2FuJ3QgYmUgaW50ZXJhY3RlZCB3aXRoXHJcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGl0J3MgYW4gaW5wdXQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgIHByb3BzLmluZXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5vbkZvY3VzID0gXyA9PiBnZXRMYWJlbEVsZW1lbnQoKT8uZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YWcgPT09IFwiaW5wdXRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNoZWNrZWQgPSBjaGVja2VkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMucm9sZSA9IHJvbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1jaGVja2VkXCJdID0gY2hlY2tlZCA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWRpc2FibGVkXCJdID0gZGlzYWJsZWQudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGxhYmVsIGNsaWNrcyBjYW4ndCBhZmZlY3QgdGhlIGNoZWNrYm94IHdoaWxlIGl0J3MgZGlzYWJsZWRcclxuICAgICAgICAgICAgcHJvcHMub25DbGljayA9IGRpc2FibGVkID8gKChlKSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9KSA6IHByb3BzLm9uQ2xpY2s7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXNlSW5wdXRSZWZFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHM8SW5wdXRUeXBlPihwMCwgcHJvcHMpKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbdXNlSUxJbnB1dCwgcm9sZSwgbGFiZWxQb3NpdGlvbiwgZGlzYWJsZWQsIGNoZWNrZWQsIHRhZ0lucHV0XSk7XHJcblxyXG4gICAgY29uc3QgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoKSB7XHJcbiAgICAgICAgY29uc3QgdGFnID0gdGFnTGFiZWw7XHJcbiAgICAgICAgY29uc3QgeyB1c2VMYWJlbExhYmVsUHJvcHM6IHVzZUlMTGFiZWxQcm9wcyB9ID0gdXNlSUxMYWJlbCgpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+IHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+ID0gdXNlUHJlc3NFdmVudEhhbmRsZXJzPExhYmVsVHlwZT4oZGlzYWJsZWQgfHwgIWhhbmRsZXNJbnB1dCh0YWcsIGxhYmVsUG9zaXRpb24sIFwibGFiZWwtZWxlbWVudFwiKSA/IHVuZGVmaW5lZCA6IHN0YWJsZU9uSW5wdXQsIHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwMC50YWJJbmRleCA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLnRhYkluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChwMC5yb2xlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMucm9sZSA9IHJvbGU7XHJcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBkaXNhYmxlZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbXCJhcmlhLWNoZWNrZWRcIl0gPSBjaGVja2VkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgb25lIGNhc2Ugd2hlcmUgdGhlcmUncyBhbG1vc3Qgbm90aGluZyB0byBkb1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1vc3Qgbm9ybWFsIGNhc2Ugd2hlcmUgZXZlcnl0aGluZyBhY3RzIGFjY29yZGluZyBub3JtYWwgSFRNTCBtZWNoYW5pY3MuXHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBKdXN0IG1ha2Ugc3VyZSB0aGF0IGxhYmVsIGNsaWNrcyBjYW4ndCBhZmZlY3QgdGhlIGNoZWNrYm94IHdoaWxlIGl0J3MgZGlzYWJsZWRcclxuICAgICAgICAgICAgbmV3UHJvcHMub25DbGljayA9IGRpc2FibGVkID8gKChlKSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9KSA6IG5ld1Byb3BzLm9uQ2xpY2s7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXNlTGFiZWxSZWZFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHM8TGFiZWxUeXBlPihuZXdQcm9wcywgdXNlSUxMYWJlbFByb3BzKHAwKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMgfTtcclxuXHJcbiAgICB9LCBbdXNlSUxMYWJlbCwgZGlzYWJsZWQsIGNoZWNrZWQsIHJvbGUsIGxhYmVsUG9zaXRpb24sIHRhZ0xhYmVsXSk7XHJcblxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LFxyXG4gICAgICAgIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCxcclxuICAgICAgICBnZXRMYWJlbEVsZW1lbnQsXHJcbiAgICAgICAgZ2V0SW5wdXRFbGVtZW50LFxyXG4gICAgICAgIGlucHV0SWQsXHJcbiAgICAgICAgbGFiZWxJZFxyXG4gICAgfTtcclxuXHJcblxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCwgVGFnU2Vuc2l0aXZlUHJvcHMgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VDaGVja2JveExpa2UsIFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IHR5cGUgQ2hlY2tib3hDaGFuZ2VFdmVudDxFdmVudFR5cGUgZXh0ZW5kcyBFdmVudD4gPSBFdmVudFR5cGUgJiB7IFtFdmVudERldGFpbF06IHsgY2hlY2tlZDogYm9vbGVhbiB9IH07XHJcblxyXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveElucHV0RWxlbWVudDxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wczogKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPjsgfVxyXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveExhYmVsRWxlbWVudDxMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wczogKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPjsgfVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIEw+LCBcIm9uSW5wdXRcIiB8IFwicm9sZVwiIHwgXCJjaGVja2VkXCI+IHtcclxuICAgIGNoZWNrZWQ6IGJvb2xlYW4gfCBcIm1peGVkXCI7XHJcbiAgICBvbklucHV0PyhldmVudDogQ2hlY2tib3hDaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PEk+Pik6IHZvaWQ7XHJcbiAgICBvbklucHV0PyhldmVudDogQ2hlY2tib3hDaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PEw+Pik6IHZvaWQ7XHJcbiAgICB0YWdJbnB1dDogRWxlbWVudFRvVGFnPEk+O1xyXG4gICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMPjtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhQ2hlY2tib3g8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50Pih7IGxhYmVsUG9zaXRpb24sIGNoZWNrZWQsIG9uSW5wdXQsIGRpc2FibGVkLCB0YWdJbnB1dCwgdGFnTGFiZWwgfTogVXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4pIHtcclxuXHJcbiAgICBjb25zdCBvbklucHV0RW5oYW5jZWQgPSAoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxJbnB1dFR5cGUgfCBMYWJlbFR5cGUsIEV2ZW50PikgPT4gb25JbnB1dD8uKGVuaGFuY2VFdmVudChlIGFzIGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlLCBFdmVudD4sIHsgY2hlY2tlZDogIWNoZWNrZWQgfSkpO1xyXG4gICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCwgaW5wdXRJZCwgbGFiZWxJZCB9ID0gdXNlQ2hlY2tib3hMaWtlPElucHV0VHlwZSwgTGFiZWxUeXBlPih7IGNoZWNrZWQ6ICEhY2hlY2tlZCwgbGFiZWxQb3NpdGlvbiwgcm9sZTogXCJjaGVja2JveFwiLCBkaXNhYmxlZCwgb25JbnB1dDogb25JbnB1dEVuaGFuY2VkLCB0YWdJbnB1dDogdGFnSW5wdXQgYXMgbmV2ZXIsIHRhZ0xhYmVsOiB0YWdMYWJlbCBhcyBuZXZlciB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VDaGVja2JveElucHV0RWxlbWVudDogVXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQ8SW5wdXRUeXBlPiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCkge1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ0lucHV0O1xyXG4gICAgICAgIGNvbnN0IHsgZ2V0SW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50KClcclxuICAgICAgICBjb25zdCBpc01peGVkID0gKGNoZWNrZWQgPT0gXCJtaXhlZFwiKTtcclxuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW5wdXRFbGVtZW50ID0gZ2V0SW5wdXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dEVsZW1lbnQgJiYgdGFnID09PSBcImlucHV0XCIpIHtcclxuICAgICAgICAgICAgICAgIChpbnB1dEVsZW1lbnQgYXMgYW55KS5pbmRldGVybWluYXRlID0gaXNNaXhlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtpc01peGVkLCB0YWddKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPikge1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4gPSB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyhwMCk7XHJcbiAgICAgICAgICAgIHByb3BzLmNoZWNrZWQgPz89ICEhY2hlY2tlZDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0YWcgPT0gXCJpbnB1dFwiKVxyXG4gICAgICAgICAgICAgICAgcHJvcHMudHlwZSA9IFwiY2hlY2tib3hcIjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wcztcclxuICAgICAgICB9XHJcbiAgICB9LCBbdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LCBjaGVja2VkLCBsYWJlbFBvc2l0aW9uLCBkaXNhYmxlZCwgdGFnSW5wdXRdKTtcclxuXHJcbiAgICBjb25zdCB1c2VDaGVja2JveExhYmVsRWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KCkge1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ0xhYmVsO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCgpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPikge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMocHJvcHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9O1xyXG4gICAgfSwgW3VzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24sIHRhZ0xhYmVsXSk7XHJcblxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQsXHJcbiAgICAgICAgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQsXHJcbiAgICAgICAgaW5wdXRJZCxcclxuICAgICAgICBsYWJlbElkXHJcbiAgICB9O1xyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBMaXN0TmF2aWdhdGlvbkNoaWxkSW5mb0Jhc2UsIHJldHVybkZhbHNlLCB1c2VFZmZlY3QsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgTWFuYWdlZENoaWxkcmVuIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcclxuaW1wb3J0IHsgVXNlTGlzdE5hdmlnYXRpb25DaGlsZEluZm9OZWVkZWQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbGlzdC1uYXZpZ2F0aW9uXCI7XHJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCwgVGFnU2Vuc2l0aXZlUHJvcHMgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VQcmVzc0V2ZW50SGFuZGxlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcbmltcG9ydCB7IENoZWNrYm94Q2hhbmdlRXZlbnQsIHVzZUFyaWFDaGVja2JveCwgVXNlQXJpYUNoZWNrYm94UGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1jaGVja2JveFwiO1xyXG5cclxuXHJcbmV4cG9ydCB0eXBlIENoZWNrYm94R3JvdXBDaGFuZ2VFdmVudDxFdmVudFR5cGUgZXh0ZW5kcyBFdmVudD4gPSBFdmVudFR5cGUgJiB7IFtFdmVudERldGFpbF06IHsgY2hpbGRyZW5DaGVja2VkOiBib29sZWFuIHwgTWFwPG51bWJlciwgYm9vbGVhbiB8IFwibWl4ZWRcIj4gfSB9O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVyczxLIGV4dGVuZHMgc3RyaW5nLCBJIGV4dGVuZHMgVXNlQ2hlY2tib3hHcm91cENoaWxkSW5mb0Jhc2U8Sz4+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPEssIEk+IHtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHBhcmVudCBjaGVja2JveCBpcyBjaGFuZ2VkIGFuZCBhbiB1cGRhdGUgb2ZcclxuICAgICAqIGFsbCB0aGUgY2hpbGRyZW4gbmVlZHMgdG8gb2NjdXIuXHJcbiAgICAgKiBcclxuICAgICAqIGBldmVudFtFdmVudERldGFpbF0uY2hpbGRyZW5DaGVja2VkYCB3aWxsIGJlIFxyXG4gICAgICogKiB0cnVlIHdoZW4gYWxsIGNoaWxkcmVuIG5lZWQgdG8gYmVjb21lIGNoZWNrZWRcclxuICAgICAqICogZmFsc2Ugd2hlbiBhbGwgY2hpbGRyZW4gbmVlZCB0byBiZWNvbWUgdW5jaGVja2VkXHJcbiAgICAgKiAqIEEgYE1hcDxpbmRleCxjaGVja2VkPmAgb2YgZWFjaCBjaGlsZCdzIHN0YXR1cyB3aGVuIHJldmVydGluZyB0byBcIm1peGVkXCIuXHJcbiAgICAgKiBcclxuICAgICAqIEJlY2F1c2Ugd2UncmUgZGVhbGluZyB3aXRoIGNvbnRyb2xsZWQgY29tcG9uZW50cyBoZXJlLCBhbmQgdGhlIGRhdGEgZm9yXHJcbiAgICAgKiB3aGF0IGNoZWNrYm94ZXMgYXJlIGNoZWNrZWQgbGl2ZSAqb3V0c2lkZSogb2YgYW55IG9mIHRoZXNlIGhvb2tzLFxyXG4gICAgICogaXQncyB5b3Ugd2hvJ3MgcmVzcG9uc2libGUgZm9yIGxpc3RlbmluZyBmb3IgdGhpcyBldmVudCwgbW9kaWZ5aW5nIHRoZVxyXG4gICAgICogZGF0YSwgYW5kIHJlLXJlbmRlcmluZyBhcHByb3ByaWF0ZWx5LlxyXG4gICAgICogXHJcbiAgICAgKiBIaWdobHkgcmVjb21tZW5kZWQgdG8sIGZvciBleGFtcGxlLCBhZGQgZWFjaCBjaGlsZCdzIGBvbklucHV0YCBldmVudCBoYW5kbGVyXHJcbiAgICAgKiBhdmFpbGFibGUgaW4gdGhlIGNoaWxkIGluZm8gdGhlIHBhcmVudCBnZXRzIHNvIGl0IGNhbiBjYWxsIHRoZSBoYW5kbGVyXHJcbiAgICAgKiByZW1vdGVseSBmcm9tIGBtYW5hZ2VkQ2hlY2tib3hlc2AuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgXHJcbiAgICAgKi9cclxuICAgIC8vb25VcGRhdGVDaGlsZHJlbihldmVudDogQ2hlY2tib3hHcm91cENoYW5nZUV2ZW50PGguSlNYLlRhcmdldGVkRXZlbnQ8RT4+KTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRJbmZvQmFzZTxLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPiB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpZCBhdHRyaWJ1dGUgdXNlZCBmb3IgdGhlIGNoaWxkLlxyXG4gICAgICovXHJcbiAgICAvL2lkOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBjaGVja2VkIHN0YXRlIG9mIHRoaXMgY2hpbGQuXHJcbiAgICAgKiBcclxuICAgICAqIFRoaXMgaXMgdXNlZCBieSB0aGUgcGFyZW50IHdoZW5ldmVyIGl0J3MgaW50ZXJhY3RlZCB3aXRoIFxyXG4gICAgICogYW5kIGFib3V0IHRvIGZvcmNlIGV2ZXJ5IG9uZSB0byBiZSBzb21ldGhpbmcgZGlmZmVyZW50IC0tIFxyXG4gICAgICogaXQgd2lsbCBzYXZlIHRoZSBzdGF0ZSBvZiBhbGwgY2hpbGQgY2hlY2tib3hlcyBmb3IgbGF0ZXJcclxuICAgICAqIGJ5IGFza2luZyBlYWNoIG9uZSB3aGF0IGl0cyBjdXJyZW50IHN0YXRlIGlzIGluZGl2aWR1YWxseVxyXG4gICAgICogYXQgdGhhdCBtb21lbnQuXHJcbiAgICAgKiBcclxuICAgICAqIEFsbCB0aGUgY2hlY2tib3gncyBzdGF0ZXMgYXJlIGNhcHR1cmVkIHdoZW4gdGhlIHBhcmVudFxyXG4gICAgICogaXMgaW4gdGhlIFwibWl4ZWRcIiBzdGF0ZSBhbmQgaXMgY2xpY2tlZC4gSXQga2VlcHMgdGhlbVxyXG4gICAgICogdGhhdCB3YXkgdW50aWwgdGhlIHNhbWUgY29uZGl0aW9ucyBhcmlzZSBhZ2Fpbi5cclxuICAgICAqL1xyXG4gICAgZ2V0TGFzdFVzZXJDaGVja2VkKCk6IGJvb2xlYW4gfCBcIm1peGVkXCI7XHJcbiAgICBvbklucHV0OiBVc2VBcmlhQ2hlY2tib3hQYXJhbWV0ZXJzPGFueSwgYW55PltcIm9uSW5wdXRcIl07XHJcbn1cclxuXHJcblxyXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEsgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsIEkgZXh0ZW5kcyBVc2VDaGVja2JveEdyb3VwQ2hpbGRJbmZvQmFzZTxLPiA9IFVzZUNoZWNrYm94R3JvdXBDaGlsZEluZm9CYXNlPEs+PiA9IFVzZUFyaWFDaGVja2JveFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+ICYgeyBpbmZvOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvTmVlZGVkPEssIEk+LCBcImdldExhc3RVc2VyQ2hlY2tlZFwiIHwgXCJvbklucHV0XCI+IH07XHJcblxyXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveEdyb3VwQ2hpbGQ8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIFVzZUNoZWNrYm94R3JvdXBDaGlsZEluZm9CYXNlPEs+PiA9IChhcmdzOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBLLCBJPikgPT4ge1xyXG4gICAgdGFiYmFibGU6IGJvb2xlYW4gfCBudWxsO1xyXG4gICAgdXNlQ2hlY2tib3hHcm91cENoaWxkSW5wdXRQcm9wczogKHsgdGFiSW5kZXgsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47XHJcbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzOiAoeyB0YWJJbmRleCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjtcclxufVxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFxyXG4gKiBcclxuICogQHBhcmFtIHBhcmFtMCBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hlY2tib3hHcm91cDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgSyBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgSSBleHRlbmRzIFVzZUNoZWNrYm94R3JvdXBDaGlsZEluZm9CYXNlPEs+ID0gVXNlQ2hlY2tib3hHcm91cENoaWxkSW5mb0Jhc2U8Sz4+KHsgY29sbGF0b3IsIGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgaW5pdGlhbEluZGV4LCBuYXZpZ2F0aW9uRGlyZWN0aW9uLCBub1R5cGVhaGVhZCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCB0eXBlYWhlYWRUaW1lb3V0LCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciwgb25UYWJiZWRJblRvLCBvblRhYmJlZE91dE9mIH06IFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzPEssIEk+KTogVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGU8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIEssIEk+IHtcclxuXHJcbiAgICAvL2NvbnN0IG9uVXBkYXRlQ2hpbGRyZW4gPSB1c2VTdGFibGVDYWxsYmFjayhvblVwZGF0ZUNoaWxkcmVuVW5zdGFibGUgPz8gKCgpID0+IHt9KSk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXHJcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZCxcclxuICAgICAgICBnZXRUYWJiYWJsZUluZGV4LFxyXG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXhcclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxJbnB1dEVsZW1lbnQsIElucHV0RWxlbWVudCB8IExhYmVsRWxlbWVudCwgc3RyaW5nLCBJPih7XHJcbiAgICAgICAgY29sbGF0b3IsXHJcbiAgICAgICAgZGlzYWJsZUFycm93S2V5cyxcclxuICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICAgICAgaW5kZXhEZW1hbmdsZXIsXHJcbiAgICAgICAgaW5kZXhNYW5nbGVyLFxyXG4gICAgICAgIGluaXRpYWxJbmRleCxcclxuICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxyXG4gICAgICAgIG5vVHlwZWFoZWFkLFxyXG4gICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcclxuICAgICAgICB0eXBlYWhlYWRUaW1lb3V0LFxyXG4gICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcclxuICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXHJcbiAgICAgICAgb25UYWJiYWJsZVJlbmRlcixcclxuICAgICAgICBvblRhYmJlZEluVG8sXHJcbiAgICAgICAgb25UYWJiZWRPdXRPZixcclxuICAgIH0pO1xyXG5cclxuICAgIC8vY29uc3QgW3VuY2hlY2tlZENvdW50LCBzZXRVbmhlY2tlZENvdW50XSA9IHVzZVN0YXRlKDApO1xyXG5cclxuXHJcbiAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCBjaGlsZCBJRHMsIGFuZCBhbnkgdGltZSBhbnkgb2YgdGhlbSBjaGFuZ2UsIFxyXG4gICAgLy8gZ2VuZXJhdGUgYSBuZXcgc3RyaW5nIHdpdGggYWxsIG9mIHRoZW0gY29uY2F0ZW5hdGVkIHRvZ2V0aGVyXHJcbiAgICAvLyAoYnV0IG9ubHkgb25jZSBwZXIgcmVuZGVyKTtcclxuICAgIGNvbnN0IGFsbElkcyA9IHVzZVJlZihuZXcgU2V0PHN0cmluZz4oKSk7XHJcbiAgICBjb25zdCBbYXJpYUNvbnRyb2xzLCBzZXRBcmlhQ29udHJvbHNdID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgICBjb25zdCBbdXBkYXRlSW5kZXgsIHNldElkVXBkYXRlSW5kZXhdID0gdXNlU3RhdGUoMCk7XHJcblxyXG5cclxuICAgIGNvbnN0IFtjaGVja2VkQ291bnQsIHNldENoZWNrZWRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IGNoZWNrZWRJbmRpY2VzID0gdXNlUmVmKG5ldyBTZXQ8bnVtYmVyPigpKTtcclxuICAgIC8vY29uc3QgW3NlbGZJc0NoZWNrZWQsIHNldFNlbGZJc0NoZWNrZWQsIGdldFNlbGZJc0NoZWNrZWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IFwibWl4ZWRcIj4oZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IGdldFNlbGZJc0NoZWNrZWRVbnN0YWJsZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gY2hlY2tlZENvdW50IC8gKGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIHBlcmNlbnRhZ2UgPD0gMCA/IGZhbHNlIDogcGVyY2VudGFnZSA+PSAxID8gdHJ1ZSA6IFwibWl4ZWRcIjtcclxuICAgIH0sIFtjaGVja2VkQ291bnRdKTtcclxuXHJcbiAgICBjb25zdCBnZXRTZWxmSXNDaGVja2VkU3RhYmxlID0gdXNlU3RhYmxlQ2FsbGJhY2soZ2V0U2VsZklzQ2hlY2tlZFVuc3RhYmxlKTtcclxuICAgIGNvbnN0IFtzZXRQYXJlbnRDaGVja2JveENoZWNrZWQsIHNldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZF0gPSB1c2VTdGF0ZTxTdGF0ZVVwZGF0ZXI8VXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxhbnksIGFueT5bXCJjaGVja2VkXCJdPiB8IG51bGw+KG51bGwpO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRQYXJlbnRDaGVja2JveENoZWNrZWQ/LihjaGVja2VkQ291bnQgPT0gMCA/IGZhbHNlIDogY2hlY2tlZENvdW50ID09IChjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSArIDEpID8gdHJ1ZSA6IFwibWl4ZWRcIik7XHJcbiAgICB9LCBbc2V0UGFyZW50Q2hlY2tib3hDaGVja2VkLCBjaGVja2VkQ291bnRdKVxyXG5cclxuICAgIC8vIElmIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSBwYXJlbnQgY2hlY2tib3gncyB2YWx1ZSwgdGhlbiB0aGlzIHJlZiBob2xkcyBhIG1lbW9yeSBvZiB3aGF0IHZhbHVlcyB3ZXJlIGhlbGQgYmVmb3JlLlxyXG4gICAgLy8gT3RoZXJ3aXNlLCBpdCdzIG51bGwgd2hlbiB0aGUgbGFzdCBpbnB1dCB3YXMgZnJvbSBhIGNoaWxkIGNoZWNrYm94LiBcclxuICAgIC8vY29uc3Qgc2F2ZWRDaGVja2VkVmFsdWVzID0gdXNlUmVmPE1hcDxudW1iZXIsIGJvb2xlYW4gfCBcIm1peGVkXCI+IHwgbnVsbD4obnVsbCk7XHJcbiAgICBjb25zdCB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXQgPSB1c2VDYWxsYmFjazxVc2VDaGVja2JveEdyb3VwUGFyZW50PElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pj4oKHsgZGlzYWJsZWQsIHRhZ0lucHV0LCBsYWJlbFBvc2l0aW9uLCB0YWdMYWJlbCB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWRdID0gdXNlU3RhdGU8VXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxhbnksIGFueT5bXCJjaGVja2VkXCJdPihmYWxzZSk7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgc2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkKCgpID0+IHNldENoZWNrZWQpO1xyXG4gICAgICAgIH0sIFtdKVxyXG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50IH0gPSB1c2VBcmlhQ2hlY2tib3g8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHsgbGFiZWxQb3NpdGlvbiwgY2hlY2tlZCwgb25JbnB1dDogb25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQyIGFzIGFueSwgZGlzYWJsZWQsIHRhZ0lucHV0LCB0YWdMYWJlbCB9KTtcclxuICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExhYmVsRWxlbWVudCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzOiBmdW5jdGlvbiB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJldCA9ICh1c2VNZXJnZWRQcm9wczxJbnB1dEVsZW1lbnQ+KHVzZU1lcmdlZFByb3BzPElucHV0RWxlbWVudD4oe30sIHsgXCJhcmlhLWNvbnRyb2xzXCI6IGFyaWFDb250cm9scywgb25JbnB1dDogdGFnSW5wdXQgPT0gXCJpbnB1dFwiID8gKGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKSA6IHVuZGVmaW5lZCB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pLCBwcm9wcykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMobGFiZWxQb3NpdGlvbiA9PSBcInNlcGFyYXRlXCIgPyByZXQgOiBwcm9wcyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRMYWJlbFByb3BzOiBmdW5jdGlvbiB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJldCA9ICh1c2VNZXJnZWRQcm9wczxMYWJlbEVsZW1lbnQ+KHVzZU1lcmdlZFByb3BzPExhYmVsRWxlbWVudD4oe30sIHsgXCJhcmlhLWNvbnRyb2xzXCI6IGFyaWFDb250cm9scyB9IGFzIGFueSkgYXMgYW55LCBwcm9wcykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIgPyByZXQgOiBwcm9wcylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFthcmlhQ29udHJvbHNdKTtcclxuXHJcbiAgICBjb25zdCBvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dDIgPSB1c2VDYWxsYmFjaygoZTogQ2hlY2tib3hDaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0RWxlbWVudCwgRXZlbnQ+PikgPT4ge1xyXG5cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZGVidWdnZXI7XHJcblxyXG4gICAgICAgIGNvbnN0IHNlbGZJc0NoZWNrZWQgPSBnZXRTZWxmSXNDaGVja2VkU3RhYmxlKCk7XHJcbiAgICAgICAgbGV0IG5leHRDaGVja2VkID0gKHNlbGZJc0NoZWNrZWQgPT09IGZhbHNlID8gXCJtaXhlZFwiIDogc2VsZklzQ2hlY2tlZCA9PT0gXCJtaXhlZFwiID8gdHJ1ZSA6IGZhbHNlKTtcclxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcclxuICAgICAgICAgICAgY2hpbGQub25JbnB1dD8uKGVuaGFuY2VFdmVudChlLCB7IGNoZWNrZWQ6IG5leHRDaGVja2VkID09IFwibWl4ZWRcIiA/IGNoaWxkLmdldExhc3RVc2VyQ2hlY2tlZCgpIDogbmV4dENoZWNrZWQgfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qaWYgKHNlbGZJc0NoZWNrZWQgPT09IHRydWUgfHwgKHNlbGZJc0NoZWNrZWQgPT09IGZhbHNlICYmIHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50ID09IG51bGwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvblVwZGF0ZUNoaWxkcmVuKGVuaGFuY2VFdmVudChlLCB7IGNoaWxkcmVuQ2hlY2tlZDogZmFsc2UgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZWxmSXNDaGVja2VkID09PSBcIm1peGVkXCIpIHtcclxuXHJcbiAgICAgICAgICAgIHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcclxuICAgICAgICAgICAgICAgIHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50IS5zZXQoY2hpbGQuaW5kZXgsIGNoaWxkLmdldExhc3RVc2VyQ2hlY2tlZCgpKTtcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvblVwZGF0ZUNoaWxkcmVuKGVuaGFuY2VFdmVudChlLCB7IGNoaWxkcmVuQ2hlY2tlZDogdHJ1ZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gb25VcGRhdGVDaGlsZHJlbihlbmhhbmNlRXZlbnQoZSwgeyBjaGlsZHJlbkNoZWNrZWQ6IHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50ID8/IHRydWUgfSkpO1xyXG4gICAgICAgIH0qL1xyXG4gICAgfSwgW10pXHJcblxyXG4gICAgY29uc3Qgbm90aWZ5Q2hlY2tlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyLCBjaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiKSA9PiB7XHJcbiAgICAgICAgaWYgKGNoZWNrZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKCFjaGVja2VkSW5kaWNlcy5jdXJyZW50LmhhcyhpbmRleCkpIHtcclxuICAgICAgICAgICAgICAgIHNldENoZWNrZWRDb3VudChjID0+IChjICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgY2hlY2tlZEluZGljZXMuY3VycmVudC5hZGQoaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tlZEluZGljZXMuY3VycmVudC5oYXMoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDaGVja2VkQ291bnQoYyA9PiAoYyAtIDEpKTtcclxuICAgICAgICAgICAgICAgIGNoZWNrZWRJbmRpY2VzLmN1cnJlbnQuZGVsZXRlKGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvKnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgbGV0IHBlcmNlbnRhZ2UgPSBjaGVja2VkQ291bnQgLyBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgIHNldFNlbGZJc0NoZWNrZWQocGVyY2VudGFnZSA8PSAwID8gZmFsc2UgOiBwZXJjZW50YWdlID49IDEgPyB0cnVlIDogXCJtaXhlZFwiKVxyXG4gICAgfSwgW3NldFNlbGZJc0NoZWNrZWQsIG1hbmFnZWRDaGlsZHJlbi5sZW5ndGgsIGNoZWNrZWRDb3VudF0pOyovXHJcblxyXG4gICAgLypjb25zdCB1c2VDaGVja2JveEdyb3VwUGFyZW50UHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IHtcclxuICAgICAgICByZXR1cm4gXHJcbiAgICB9LCBbYXJpYUNvbnRyb2xzXSk7Ki9cclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldEFyaWFDb250cm9scyhBcnJheS5mcm9tKGFsbElkcy5jdXJyZW50KS5qb2luKFwiIFwiKSk7XHJcbiAgICB9LCBbdXBkYXRlSW5kZXhdKVxyXG5cclxuICAgIGNvbnN0IHVzZUNoZWNrYm94R3JvdXBDaGlsZCA9IHVzZUNhbGxiYWNrPFVzZUNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgSywgST4+KGZ1bmN0aW9uICh7IGluZm86IHsgaW5kZXgsIHRleHQsIGJsdXJTZWxmLCBmbGFncywgZm9jdXNTZWxmLCBoaWRkZW4sIC4uLnJlc3RJbmZvIH0sIGNoZWNrZWQsIGxhYmVsUG9zaXRpb24sIHRhZ0xhYmVsLCBvbklucHV0LCBkaXNhYmxlZCwgdGFnSW5wdXQsIC4uLnJlc3RBcmdzIH06IFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIEssIEk+KSB7XHJcbiAgICAgICAgbGFiZWxQb3NpdGlvbiA/Pz0gXCJzZXBhcmF0ZVwiO1xyXG4gICAgICAgIGNvbnN0IFtnZXRMYXN0VXNlckNoZWNrZWQsIHNldExhc3RVc2VyQ2hlY2tlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbiB8IFwibWl4ZWRcIj4obnVsbCwgcmV0dXJuRmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50LCBpbnB1dElkLCBsYWJlbElkIH0gPSB1c2VBcmlhQ2hlY2tib3g8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHsgbGFiZWxQb3NpdGlvbiwgY2hlY2tlZCwgb25JbnB1dDogdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uSW5wdXQ+PihlID0+IHsgc2V0TGFzdFVzZXJDaGVja2VkKGVbRXZlbnREZXRhaWxdLmNoZWNrZWQpOyBvbklucHV0Py4oZSBhcyBhbnkpOyB9KSwgZGlzYWJsZWQsIHRhZ0lucHV0LCB0YWdMYWJlbCB9KTtcclxuICAgICAgICBjb25zdCBnZXRDaGVja2VkID0gdXNlU3RhYmxlR2V0dGVyKGNoZWNrZWQpO1xyXG5cclxuICAgICAgICBsZXQgY29udHJvbHNJZCA9IChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIiA/IGlucHV0SWQgOiBsYWJlbElkKSE7XHJcblxyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGFsbElkcy5jdXJyZW50LmFkZChjb250cm9sc0lkKTtcclxuICAgICAgICAgICAgc2V0SWRVcGRhdGVJbmRleChpID0+ICsraSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWxsSWRzLmN1cnJlbnQuZGVsZXRlKGNvbnRyb2xzSWQpO1xyXG4gICAgICAgICAgICAgICAgc2V0SWRVcGRhdGVJbmRleChpID0+ICsraSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbY29udHJvbHNJZF0pO1xyXG5cclxuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgbm90aWZ5Q2hlY2tlZChpbmRleCwgY2hlY2tlZCk7XHJcbiAgICAgICAgfSwgW2luZGV4LCBjaGVja2VkXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7IGluZm86IHsgaW5kZXgsIHRleHQsIGdldExhc3RVc2VyQ2hlY2tlZCwgb25JbnB1dCwgYmx1clNlbGYsIGZsYWdzLCBmb2N1c1NlbGYsIGhpZGRlbiwgLi4ucmVzdEluZm8gfSBhcyB1bmtub3duIGFzIEkgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRhYmJhYmxlLFxyXG4gICAgICAgICAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgIGxldCByZXQgPSB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIGxldCByZXQyID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMocmV0KSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQgfCBMYWJlbEVsZW1lbnQ+KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAobGFiZWxQb3NpdGlvbiA9PSBcInNlcGFyYXRlXCIgPyByZXQyIDogcmV0KSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgIGxldCByZXQgPSB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIGxldCByZXQyID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMocmV0IGFzIHt9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudCB8IExhYmVsRWxlbWVudD4pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIiA/IHJldDIgOiByZXQpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNoZWNrYm94ZXM6IGNoaWxkcmVuLFxyXG4gICAgICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZCxcclxuICAgICAgICB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXQsXHJcbiAgICAgICAgcGFyZW50SXNDaGVja2VkOiBnZXRTZWxmSXNDaGVja2VkVW5zdGFibGUoKSBhcyBib29sZWFuIHwgXCJtaXhlZFwiLFxyXG4gICAgICAgIHBhcmVudFBlcmNlbnRDaGVja2VkOiAoY2hlY2tlZENvdW50IC8gKGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpICsgMSkpLFxyXG4gICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXHJcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZTxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgSyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIFVzZUNoZWNrYm94R3JvdXBDaGlsZEluZm9CYXNlPEs+PiB7XHJcbiAgICBjaGVja2JveGVzOiBNYW5hZ2VkQ2hpbGRyZW48ST47XHJcbiAgICAvKipcclxuICAgICAqIEVhY2ggY2hpbGQgY2hlY2tib3ggbXVzdCBjYWxsIHRoaXMgaG9vaywgKmluIGFkZGl0aW9uIHRvKiBgdXNlQXJpYUNoZWNrYm94YFxyXG4gICAgICovXHJcbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGQ6IFVzZUNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgSywgST47XHJcbiAgICBwYXJlbnRJc0NoZWNrZWQ6IGJvb2xlYW4gfCBcIm1peGVkXCI7XHJcbiAgICBwYXJlbnRQZXJjZW50Q2hlY2tlZDogbnVtYmVyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGFyZW50IGNoZWNrYm94IG11c3QgdXNlIHRoaXMgaG9va1xyXG4gICAgICovXHJcbiAgICB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXQ6IFVzZUNoZWNrYm94R3JvdXBQYXJlbnQ8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+O1xyXG4gICAgY3VycmVudFR5cGVhaGVhZDogc3RyaW5nIHwgbnVsbDtcclxuICAgIGludmFsaWRUeXBlYWhlYWQ6IGJvb2xlYW4gfCBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveEdyb3VwUGFyZW50PElucHV0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50PiA9IChhOiBPbWl0PFVzZUFyaWFDaGVja2JveFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcIm9uSW5wdXRcIiB8IFwiY2hlY2tlZFwiPikgPT4ge1xyXG4gICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjtcclxuICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XHJcbn07XHJcbiIsIlxyXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50LCB1c2VGb2N1c1RyYXAsIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVJhbmRvbUlkLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlR2V0dGVyLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvZnREaXNtaXNzUGFyYW1ldGVycyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGNvdW50IGFzIFwid2l0aGluXCIgdGhpcyBjb21wb25lbnQuXHJcbiAgICAgKiBcclxuICAgICAqIFVzdWFsbHkganVzdCBhIHNpbmdsZSBlbGVtZW50LCBidXQgZS5nLiBhIE1lbnUgKyBNZW51QnV0dG9uIGNvdWxkIGhhdmUgdHdvLlxyXG4gICAgICovXHJcbiAgICBnZXRFbGVtZW50czogKCkgPT4gRWxlbWVudCB8IEVsZW1lbnRbXSB8IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRpc21pc3NlZFxyXG4gICAgICovXHJcbiAgICBvbkNsb3NlKHJlYXNvbjogXCJiYWNrZHJvcFwiIHwgXCJlc2NhcGVcIiB8IFwibG9zdC1mb2N1c1wiKTogdm9pZDtcclxuXHJcbiAgICBvcGVuOiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1vZGFsUGFyYW1ldGVycyBleHRlbmRzIE9taXQ8VXNlU29mdERpc21pc3NQYXJhbWV0ZXJzLCBcImdldEVsZW1lbnRzXCI+IHtcclxuICAgIG9wZW46IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIHRydWUsIHRoZSBib2R5IGVsZW1lbnQgcHJvdmlkZWQgY29udGFpbnMgcHVyZWx5IHNlbWFudGljIGNvbnRlbnRcclxuICAgICAqIHRoYXQgY2FuIGJlIHJlYWQgb3V0IGJ5IGEgc2NyZWVuIHJlYWRlciBpbiBvbmUgbG9uZywgdW5pbnRlcnJ1cHRlZCBzdHJldGNoLlxyXG4gICAgICogXHJcbiAgICAgKiBUaGlzIHNob3VsZCBiZSBmYWxzZSBpZiB0aGUgbW9kYWwgY29udGFpbnMsIGZvciBleGFtcGxlLCBhIGxpc3Qgb3Igb3RoZXJcclxuICAgICAqIGludGVyYWN0aXZlIHdpZGdldHMsIGFuZCB0cnVlIGlmIGl0J3MgbW9zdGx5IHNob3J0LWZvcm0gdGV4dCBjb250ZW50LlxyXG4gICAgICogXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBmYWxzZSB0byBiZSBvbiB0aGUgc2FmZSBzaWRlLCBidXQgdGhpcyBzaG91bGQgYmUgdHJ1ZSB3aGVuZXZlciByZWFzb25hYmxlLlxyXG4gICAgICovXHJcbiAgICBib2R5SXNPbmx5U2VtYW50aWM/OiBib29sZWFuO1xyXG59XHJcblxyXG4vKipcclxuICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgYSBtb2RhbC1saWtlIHNvZnQtZGlzbWlzcyBpbnRlcmFjdGlvbi5cclxuICogXHJcbiAqIFRoYXQgaXMsIGFueSBjbGlja3Mgb3IgdGFwcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBjb21wb25lbnQsIFxyXG4gKiBvciBhbnkgdGltZSB0aGUgRXNjYXBlIGtleSBpcyBwcmVzc2VkIHdpdGhpbiB0aGUgY29tcG9uZW50LFxyXG4gKiAod2l0aCB2YXJpb3VzIGJyb3dzZXIgb2RkaXRpZXMgcmVnYXJkaW5nIGNsaWNrcyBvbiBibGFuayBvciBpbmVydCBhcmVhcyBoYW5kbGVkKVxyXG4gKiB0aGUgY29tcG9uZW50IHdpbGwgcmVxdWVzdCB0byBjbG9zZSBpdHNlbGYuXHJcbiAqIFxyXG4gKiBPZiBjb3Vyc2UsIGlmIHlvdSBkb24ndCBkbyBhbnl0aGluZyBpbiB0aGUgYG9uQ2xvc2VgIGZ1bmN0aW9uLFxyXG4gKiBpdCB3b24ndCBiZSBhIHNvZnQgZGlzbWlzcyBhbnltb3JlLlxyXG4gKiBcclxuICogQHBhcmFtIHBhcmFtMCBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlU29mdERpc21pc3M8VCBleHRlbmRzIE5vZGU+KHsgb25DbG9zZSwgZ2V0RWxlbWVudHMsIG9wZW4gfTogVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgY29uc3Qgc3RhYmxlT25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UpO1xyXG4gICAgY29uc3Qgc3RhYmxlR2V0RWxlbWVudHMgPSB1c2VTdGFibGVDYWxsYmFjayhnZXRFbGVtZW50cyk7XHJcbiAgICBjb25zdCBnZXRPcGVuID0gdXNlU3RhYmxlR2V0dGVyKG9wZW4pO1xyXG5cclxuICAgIGNvbnN0IG9uQmFja2Ryb3BDbGljayA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIG9uQmFja2Ryb3BDbGljayhlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PGFueT4pIHtcclxuICAgICAgICBpZiAoIWdldE9wZW4oKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldEVsZW1lbnQoKT8ub3duZXJEb2N1bWVudDtcclxuXHJcbiAgICAgICAgLy8gQmFzaWNhbGx5LCBcIndhcyB0aGlzIGV2ZW50IGZpcmVkIG9uIHRoZSByb290LW1vc3QgZWxlbWVudCwgb3IgYXQgbGVhc3QgYW4gZWxlbWVudCBub3QgY29udGFpbmVkIGJ5IHRoZSBtb2RhbD9cIlxyXG4gICAgICAgIC8vIEVpdGhlciBjb3VsZCBiZSBob3cgdGhlIGJyb3dzZXIgaGFuZGxlcyB0aGVzZSBzb3J0cyBvZiBcImludGVyYWN0aW5nIHdpdGggbm90aGluZ1wiIGV2ZW50cy5cclxuICAgICAgICBpZiAoZS50YXJnZXQgPT0gZG9jdW1lbnQ/LmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICBzdGFibGVPbkNsb3NlKFwiYmFja2Ryb3BcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZWxlbWVudHMgPSBzdGFibGVHZXRFbGVtZW50cygpO1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudHMgJiYgZS50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbGVtZW50cykpXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XHJcblxyXG4gICAgICAgICAgICBsZXQgZm91bmRJbnNpZGVDbGljayA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZEluc2lkZUNsaWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFmb3VuZEluc2lkZUNsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICBvbkNsb3NlKFwiYmFja2Ryb3BcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICBjb25zdCB7IHVzZUFjdGl2ZUVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlQWN0aXZlRWxlbWVudDxUPih7XHJcbiAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKG5ld0VsZW1lbnQ6IFQgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB2YWxpZEZvY3VzYWJsZUVsZW1lbnRzID0gc3RhYmxlR2V0RWxlbWVudHMoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2YWxpZEZvY3VzYWJsZUVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsaWRGb2N1c2FibGVFbGVtZW50cykpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRGb2N1c2FibGVFbGVtZW50cyA9IFt2YWxpZEZvY3VzYWJsZUVsZW1lbnRzXTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZvY3VzYWJsZSBvZiB2YWxpZEZvY3VzYWJsZUVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzYWJsZT8uY29udGFpbnMobmV3RWxlbWVudCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgb25DbG9zZShcImxvc3QtZm9jdXNcIik7XHJcbiAgICAgICAgfSwgW10pXHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8VD4oe1xyXG4gICAgICAgIG9uRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKGU6IFQgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZT8ub3duZXJEb2N1bWVudDtcclxuICAgICAgICAgICAgY29uc3Qgd2luZG93ID0gZG9jdW1lbnQ/LmRlZmF1bHRWaWV3O1xyXG5cclxuICAgICAgICAgICAgLy8gU2luY2UgZXZlcnl0aGluZyBlbHNlIGlzIGluZXJ0LCB3ZSBsaXN0ZW4gZm9yIGNhcHR1cmVkIGNsaWNrcyBvbiB0aGUgd2luZG93XHJcbiAgICAgICAgICAgIC8vICh3ZSBkb24ndCB1c2Ugb25DbGljayBzaW5jZSB0aGF0IGRvZXNuJ3QgZmlyZSB3aGVuIGNsaWNrZWQgb24gZW1wdHkvaW5lcnQgYXJlYXMpXHJcbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIG5lZWQgYSAqc2VwYXJhdGUqIHRvdWNoIGV2ZW50IG9uIG1vYmlsZSBTYWZhcmksIGJlY2F1c2VcclxuICAgICAgICAgICAgLy8gaXQgZG9lc24ndCBsZXQgY2xpY2sgZXZlbnRzIGJ1YmJsZSBvciBiZSBjYXB0dXJlZCBmcm9tIHRyYWRpdGlvbmFsbHkgbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLFxyXG4gICAgICAgICAgICAvLyBidXQgdG91Y2ggZXZlbnRzIHdvcmsgYXMgZXhwZWN0ZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IG1vdXNlRG93biA9IChlOiBNb3VzZUV2ZW50KSA9PiB7IGlmIChnZXRPcGVuKCkpIG9uQmFja2Ryb3BDbGljayhlKTsgfTtcclxuICAgICAgICAgICAgY29uc3QgdG91Y2hTdGFydCA9IChlOiBUb3VjaEV2ZW50KSA9PiB7IGlmIChnZXRPcGVuKCkpIG9uQmFja2Ryb3BDbGljayhlKTsgfTtcclxuICAgICAgICAgICAgY29uc3Qga2V5RG93biA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7IGlmIChlLmtleSA9PT0gXCJFc2NhcGVcIikgeyBzdGFibGVPbkNsb3NlKFwiZXNjYXBlXCIpOyB9IH07XHJcblxyXG4gICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VEb3duLCB7IGNhcHR1cmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdG91Y2hTdGFydCwgeyBjYXB0dXJlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtleURvd24pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBtb3VzZURvd24pO1xyXG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0b3VjaFN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5RG93bik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbXSlcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgb25CYWNrZHJvcENsaWNrLFxyXG4gICAgICAgIHVzZVNvZnREaXNtaXNzUHJvcHM6IHVzZUNhbGxiYWNrKDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4+KHByb3BzOiBQKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4gPT4gdXNlQWN0aXZlRWxlbWVudFByb3BzKHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wcykpLCBbdXNlQWN0aXZlRWxlbWVudFByb3BzLCB1c2VSZWZFbGVtZW50UHJvcHNdKVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1vZGFsUmV0dXJuVHlwZTxNb2RhbEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50PiB7XHJcbiAgICB1c2VNb2RhbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1vZGFsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1vZGFsRWxlbWVudD47XHJcbiAgICB1c2VNb2RhbFRpdGxlOiAoKSA9PiB7XHJcbiAgICAgICAgdXNlTW9kYWxUaXRsZVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD47XHJcbiAgICB9O1xyXG4gICAgdXNlTW9kYWxCb2R5OiAoeyBkZXNjcmlwdGl2ZSB9OiB7XHJcbiAgICAgICAgZGVzY3JpcHRpdmU6IGJvb2xlYW47XHJcbiAgICB9KSA9PiB7XHJcbiAgICAgICAgdXNlTW9kYWxCb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD47XHJcbiAgICB9O1xyXG4gICAgdXNlTW9kYWxCYWNrZHJvcDogKCkgPT4ge1xyXG4gICAgICAgIHVzZU1vZGFsQmFja2Ryb3BQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+O1xyXG4gICAgfTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIGdlbmVyaWMgbW9kYWwgaG9vaywgdXNlZCBieSBtb2RhbCBkaWFsb2dzLCBidXQgY2FuIGFsc29cclxuICogYmUgdXNlZCBieSBhbnl0aGluZyB0aGF0J3MgbW9kYWwgd2l0aCBhIGJhY2tkcm9wLlxyXG4gKiBAcGFyYW0gcGFyYW0wIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNb2RhbDxNb2RhbEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IG9wZW4sIG9uQ2xvc2UgfTogVXNlTW9kYWxQYXJhbWV0ZXJzKTogVXNlTW9kYWxSZXR1cm5UeXBlPE1vZGFsRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50PiB7XHJcblxyXG4gICAgY29uc3Qgc3RhYmxlT25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UpO1xyXG5cclxuICAgIGNvbnN0IFttb2RhbERlc2NyaWJlZEJ5Qm9keSwgc2V0TW9kYWxEZXNjcmliZWRCeUJvZHldID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgdXNlSGlkZVNjcm9sbChvcGVuKTtcclxuXHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlTW9kYWxJZEFzU291cmNlLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudCB9ID0gdXNlUmFuZG9tSWQ8TW9kYWxFbGVtZW50Pih7IHByZWZpeDogXCJhcmlhLW1vZGFsLVwiLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9KTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VCb2R5SWRBc1NvdXJjZSwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlQm9keUlkUmVmZXJlbmNlckVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkPEJvZHlFbGVtZW50Pih7IHByZWZpeDogXCJhcmlhLW1vZGFsLWJvZHktXCIsIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZVRpdGxlSWRBc1NvdXJjZSwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlVGl0bGVJZFJlZmVyZW5jZXJFbGVtZW50IH0gPSB1c2VSYW5kb21JZDxUaXRsZUVsZW1lbnQ+KHsgcHJlZml4OiBcImFyaWEtbW9kYWwtdGl0bGUtXCIsIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlTW9kYWxJZEFzU291cmNlUHJvcHMgfSA9IHVzZU1vZGFsSWRBc1NvdXJjZSgpO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlQm9keUlkQXNTb3VyY2VQcm9wcyB9ID0gdXNlQm9keUlkQXNTb3VyY2UoKTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZVRpdGxlSWRBc1NvdXJjZVByb3BzIH0gPSB1c2VUaXRsZUlkQXNTb3VyY2UoKTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudFByb3BzIH0gPSB1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudDxCb2R5RWxlbWVudD4oXCJkYXRhLW1vZGFsLWlkXCIgYXMgbmV2ZXIpXHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlQm9keUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlQm9keUlkUmVmZXJlbmNlckVsZW1lbnQ8TW9kYWxFbGVtZW50PihcImFyaWEtZGVzY3JpYmVkYnlcIiBhcyBuZXZlcik7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlVGl0bGVJZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgfSA9IHVzZVRpdGxlSWRSZWZlcmVuY2VyRWxlbWVudDxNb2RhbEVsZW1lbnQ+KFwiYXJpYS1sYWJlbGxlZGJ5XCIgYXMgbmV2ZXIpO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VNb2RhbFJlZkVsZW1lbnQsIGdldEVsZW1lbnQ6IGdldE1vZGFsRWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudDxNb2RhbEVsZW1lbnQ+KHt9KVxyXG4gICAgY29uc3QgeyB1c2VTb2Z0RGlzbWlzc1Byb3BzLCBvbkJhY2tkcm9wQ2xpY2sgfSA9IHVzZVNvZnREaXNtaXNzPE1vZGFsRWxlbWVudD4oeyBvbkNsb3NlOiBzdGFibGVPbkNsb3NlLCBnZXRFbGVtZW50czogZ2V0TW9kYWxFbGVtZW50LCBvcGVuOiAhIW9wZW4gfSk7XHJcblxyXG4gICAgY29uc3QgdXNlTW9kYWxCYWNrZHJvcCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZU1vZGFsQmFja2Ryb3AoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlTW9kYWxCYWNrZHJvcFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8QmFja2Ryb3BFbGVtZW50PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxCYWNrZHJvcEVsZW1lbnQ+KHsgb25Qb2ludGVyVXA6IG9uQmFja2Ryb3BDbGljayB9LCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VNb2RhbEJhY2tkcm9wUHJvcHMgfVxyXG4gICAgfSwgW10pXHJcblxyXG4gICAgY29uc3QgdXNlTW9kYWxQcm9wcyA9IGZ1bmN0aW9uICh7IFwiYXJpYS1tb2RhbFwiOiBhcmlhTW9kYWwsIHJvbGUsIC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1vZGFsRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNb2RhbEVsZW1lbnQ+IHtcclxuICAgICAgICBjb25zb2xlLmFzc2VydCghYXJpYU1vZGFsKTtcclxuICAgICAgICBjb25zdCB7IHVzZUZvY3VzVHJhcFByb3BzIH0gPSB1c2VGb2N1c1RyYXA8TW9kYWxFbGVtZW50Pih7IHRyYXBBY3RpdmU6IG9wZW4gfSk7XHJcbiAgICAgICAgY29uc3QgcDEgPSB1c2VCb2R5SWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKHAwKTtcclxuICAgICAgICBjb25zdCBwMiA9IHVzZU1vZGFsSWRBc1NvdXJjZVByb3BzKHAxKTtcclxuICAgICAgICBjb25zdCBwRmluYWwgPSB1c2VUaXRsZUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyhwMik7XHJcbiAgICAgICAgcmV0dXJuIHVzZUZvY3VzVHJhcFByb3BzKHVzZVNvZnREaXNtaXNzUHJvcHModXNlTWVyZ2VkUHJvcHM8TW9kYWxFbGVtZW50Pih1c2VNb2RhbFJlZkVsZW1lbnQoeyByb2xlOiByb2xlIHx8IFwiZGlhbG9nXCIgfSksIG1vZGFsRGVzY3JpYmVkQnlCb2R5ID8gcEZpbmFsIDogcDIpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdXNlTW9kYWxUaXRsZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZU1vZGFsVGl0bGUoKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZU1vZGFsVGl0bGVQcm9wcyA9IGZ1bmN0aW9uIChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlVGl0bGVJZEFzU291cmNlUHJvcHMocHJvcHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTW9kYWxUaXRsZVByb3BzIH07XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICBjb25zdCB1c2VNb2RhbEJvZHkgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VNb2RhbEJvZHkoeyBkZXNjcmlwdGl2ZSB9OiB7IGRlc2NyaXB0aXZlOiBib29sZWFuIH0pIHtcclxuICAgICAgICBzZXRNb2RhbERlc2NyaWJlZEJ5Qm9keShkZXNjcmlwdGl2ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZU1vZGFsQm9keVByb3BzID0gZnVuY3Rpb24gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlQm9keUlkQXNTb3VyY2VQcm9wcyh1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudFByb3BzKHByb3BzKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VNb2RhbEJvZHlQcm9wcyB9O1xyXG4gICAgfSwgW10pXHJcblxyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZU1vZGFsUHJvcHMsXHJcbiAgICAgICAgdXNlTW9kYWxUaXRsZSxcclxuICAgICAgICB1c2VNb2RhbEJvZHksXHJcbiAgICAgICAgdXNlTW9kYWxCYWNrZHJvcFxyXG4gICAgfTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgZm9yIGhpZGluZyB0aGUgc2Nyb2xsIGJhciBvZiB0aGUgcm9vdCBIVE1MIGVsZW1lbnRcclxuICogd2l0aG91dCBzaGlmdGluZyB0aGUgbGF5b3V0IG9mIHRoZSBwYWdlIG1vcmUgdGhhbiBhZGRpbmcgYSBmb3cgcGl4ZWxzXHJcbiAqIG9mIHBhZGRpbmcgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBuZWNlc3NhcnkuXHJcbiAqIEBwYXJhbSBoaWRlU2Nyb2xsIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhpZGVTY3JvbGwoaGlkZVNjcm9sbDogYm9vbGVhbikge1xyXG4gICAgY29uc3QgW2dldFNjcm9sbGJhcldpZHRoLCBzZXRTY3JvbGxiYXJXaWR0aF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcbiAgICBjb25zdCBbZ2V0U2Nyb2xsYmFySGVpZ2h0LCBzZXRTY3JvbGxiYXJIZWlnaHRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGhpZGVTY3JvbGwpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIGlzIHJlc3VtZWQsIHdlJ2xsIG5lZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgc2Nyb2xsIHBvc2l0aW9uc1xyXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGtlZXAgdGhpcyBpbmZvcm1hdGlvbiBhcm91bmRcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTY3JvbGxUb3AgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNjcm9sbExlZnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcclxuXHJcbiAgICAgICAgICAgIC8vIE1lYXN1cmUgdGhlIHdpZHRoIG9mIHRoZSBwYWdlIChtaW51cyB0aGUgc2Nyb2xsYmFyKVxyXG4gICAgICAgICAgICBjb25zdCB3aWR0aFdpdGhTY3JvbGxCYXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodFdpdGhTY3JvbGxCYXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwbHkgYSBjbGFzcyB0aGF0IGhpZGVzIHRoZSBzY3JvbGxiYXIuXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZG9jdW1lbnQtc2Nyb2xsLWhpZGRlblwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluIGNhc2UgbXVsdGlwbGUgdGhpbmdzIGFyZSBsb2NraW5nIHNjcm9sbCwga2VlcCB0cmFjayBvZiBob3cgbWFueSBhcmUgZG9pbmcgdGhhdFxyXG4gICAgICAgICAgICAvLyAoanVzdCBhZGQgMSBvbiBlbmFibGUsIHN1YnRyYWN0IDEgb24gZGlzYWJsZSlcclxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gPSAoKyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSB8fCBcIjBcIikgKyAxKS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgLy8gTWVhc3VyZSB0aGUgbmV3IHdpZHRoIHdpdGhvdXQgYSBzY3JvbGxiYXIgXHJcbiAgICAgICAgICAgIC8vIHNvIHdlIGNhbiB0YWtlIHRoZSBkaWZmZXJlbmNlIGFzIHRoZSBzY3JvbGxiYXIgd2lkdGguXHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoV2l0aG91dFNjcm9sbEJhciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0V2l0aG91dFNjcm9sbEJhciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgICAgIGxldCBzY3JvbGxiYXJXaWR0aCA9ICh3aWR0aFdpdGhvdXRTY3JvbGxCYXIgLSB3aWR0aFdpdGhTY3JvbGxCYXIpO1xyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsYmFySGVpZ2h0ID0gKGhlaWdodFdpdGhvdXRTY3JvbGxCYXIgLSBoZWlnaHRXaXRoU2Nyb2xsQmFyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZhaWxzYWZlIC0tIGlmIHRoaXMgbWVhc3VyaW5nIHRyaWNrIGRvZXMgc29tZXRoaW5nIHVuZXhwZWN0ZWQsIGp1c3QgaWdub3JlIGl0XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxiYXJXaWR0aCA+IDgwKVxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFyV2lkdGggPSAwO1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFySGVpZ2h0ID4gODApXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxiYXJIZWlnaHQgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBvdXIgbWVhc3VyZW1lbnRzIGF2YWlsYWJsZSBhcyBDU1MgcHJvcGVydGllcyBmb3IgZ2VuZXJhbCB1c2VcclxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1yb290LXNjcm9sbGJhci13aWR0aFwiLCBgJHtzY3JvbGxiYXJXaWR0aH1weGApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXJvb3Qtc2Nyb2xsYmFyLWhlaWdodFwiLCBgJHtzY3JvbGxiYXJIZWlnaHR9cHhgKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1yb290LXNjcm9sbHN0b3AtdG9wXCIsIGAke29yaWdpbmFsU2Nyb2xsVG9wfXB4YCk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcm9vdC1zY3JvbGxzdG9wLWxlZnRcIiwgYCR7b3JpZ2luYWxTY3JvbGxMZWZ0fXB4YCk7XHJcblxyXG4gICAgICAgICAgICBzZXRTY3JvbGxiYXJXaWR0aChzY3JvbGxiYXJXaWR0aCk7XHJcbiAgICAgICAgICAgIHNldFNjcm9sbGJhckhlaWdodChzY3JvbGxiYXJIZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFVuZG8gYWxsIHRoZSB0aGluZ3Mgd2UganVzdCBkaWRcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdID0gKCsoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gfHwgXCIwXCIpIC0gMSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSA9PSBcIjBcIikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIHRoZSBsYXN0IHNjcm9sbC1sb2NraW5nIHRoaW5nIHRvIHN0b3AsIHRoZW4gcmVtb3ZlIHRoZSBjbGFzcyB0aGF0IHN0b3BzIHNjcm9sbGluZy5cclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zY3JvbGwtaGlkZXJzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZG9jdW1lbnQtc2Nyb2xsLWhpZGRlblwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxzbywgcmVzdG9yZSB0aGUgb3JpZ2luYWwgc2Nyb2xsIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBieSBmb3JjaW5nIHRoZSBzY3JvbGwgYmVoYXZpb3IgdG8gbm90IGJlIHNtb290aFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIChpdCdzIGluc3RhbnQgaWYgbm90aGluZyBpcyBzZXQgdG8gc21vb3RoLCBodHRwczovL3d3dy53My5vcmcvVFIvY3Nzb20tdmlldy8jc2Nyb2xsaW5nKSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGxpbmcsIHRoZW4gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBzY3JvbGwgYmVoYXZpb3IgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKHdoaWNoIHdhcyBwcm9iYWJseSBhbHJlYWR5IGF1dG8gYW55d2F5LCBidXQganVzdCB0byBiZSBzYWZlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2Nyb2xsQmVoYXZpb3IgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gXCJhdXRvXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvKHsgdG9wOiBvcmlnaW5hbFNjcm9sbFRvcCwgbGVmdDogb3JpZ2luYWxTY3JvbGxMZWZ0LCBiZWhhdmlvcjogXCJhdXRvXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gb3JpZ2luYWxTY3JvbGxCZWhhdmlvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9LCBbaGlkZVNjcm9sbF0pO1xyXG5cclxuICAgIHJldHVybiB7IGdldFNjcm9sbGJhcldpZHRoLCBnZXRTY3JvbGxiYXJIZWlnaHQgfTtcclxufVxyXG5cclxuIiwiXHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNb2RhbCwgVXNlTW9kYWxSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLW1vZGFsXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFEaWFsb2dSZXR1cm5UeXBlPERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50PiB7XHJcbiAgICB1c2VEaWFsb2dQcm9wczogVXNlTW9kYWxSZXR1cm5UeXBlPERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudD5bXCJ1c2VNb2RhbFByb3BzXCJdO1xyXG4gICAgdXNlRGlhbG9nVGl0bGU6ICgpID0+IHsgdXNlRGlhbG9nVGl0bGVQcm9wczogUmV0dXJuVHlwZTxVc2VNb2RhbFJldHVyblR5cGU8RGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50PltcInVzZU1vZGFsVGl0bGVcIl0+W1widXNlTW9kYWxUaXRsZVByb3BzXCJdIH07XHJcbiAgICB1c2VEaWFsb2dCb2R5OiAoYTogeyBkZXNjcmlwdGl2ZTogYm9vbGVhbiB9KSA9PiB7IHVzZURpYWxvZ0JvZHlQcm9wczogUmV0dXJuVHlwZTxVc2VNb2RhbFJldHVyblR5cGU8RGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50PltcInVzZU1vZGFsQm9keVwiXT5bXCJ1c2VNb2RhbEJvZHlQcm9wc1wiXSB9O1xyXG4gICAgdXNlRGlhbG9nQmFja2Ryb3A6ICgpID0+IHsgdXNlRGlhbG9nQmFja2Ryb3BQcm9wczogUmV0dXJuVHlwZTxVc2VNb2RhbFJldHVyblR5cGU8RGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50PltcInVzZU1vZGFsQmFja2Ryb3BcIl0+W1widXNlTW9kYWxCYWNrZHJvcFByb3BzXCJdIH07XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZUFyaWFEaWFsb2dQYXJhbWV0ZXJzID0geyBvcGVuOiBib29sZWFuLCBvbkNsb3NlOiAocmVhc29uOiBcImVzY2FwZVwiIHwgXCJiYWNrZHJvcFwiKSA9PiB2b2lkIH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYURpYWxvZzxEaWFsb2dFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBvcGVuLCBvbkNsb3NlIH06IFVzZUFyaWFEaWFsb2dQYXJhbWV0ZXJzKTogVXNlQXJpYURpYWxvZ1JldHVyblR5cGU8RGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50PiB7XHJcbiAgICAvLyBUT0RPOiBEaWZmZXJlbmNlcyBiZXR3ZWVuIGRpYWxvZyBhbmQgbW9kYWwgZ28gaGVyZSwgcHJlc3VtYWJseS5cclxuICAgIC8vIE5vbi1tb2RhbCBkaWFsb2dzIG5lZWQgdG8gYmUgYWJsZSB0byBiZSByZXBvc2l0aW9uZWQsIGV0Yy5cclxuICAgIGNvbnN0IHsgdXNlTW9kYWxCYWNrZHJvcCwgdXNlTW9kYWxCb2R5LCB1c2VNb2RhbFByb3BzLCB1c2VNb2RhbFRpdGxlIH0gPSB1c2VNb2RhbDxEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQsIEJvZHlFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQ+KHsgb3Blbiwgb25DbG9zZSB9KTtcclxuICAgIHR5cGUgUiA9IFVzZUFyaWFEaWFsb2dSZXR1cm5UeXBlPERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudD47XHJcbiAgICBjb25zdCB1c2VEaWFsb2dCYWNrZHJvcCA9IHVzZUNhbGxiYWNrPFJbXCJ1c2VEaWFsb2dCYWNrZHJvcFwiXT4oKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxCYWNrZHJvcFByb3BzIH0gPSB1c2VNb2RhbEJhY2tkcm9wKCk7XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlRGlhbG9nQmFja2Ryb3BQcm9wczogdXNlTW9kYWxCYWNrZHJvcFByb3BzIH07XHJcbiAgICB9LCBbdXNlTW9kYWxCYWNrZHJvcF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZURpYWxvZ0JvZHkgPSB1c2VDYWxsYmFjazxSW1widXNlRGlhbG9nQm9keVwiXT4oKHsgZGVzY3JpcHRpdmUgfTogeyBkZXNjcmlwdGl2ZTogYm9vbGVhbiB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VNb2RhbEJvZHlQcm9wcyB9ID0gdXNlTW9kYWxCb2R5KHsgZGVzY3JpcHRpdmUgfSk7XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlRGlhbG9nQm9keVByb3BzOiB1c2VNb2RhbEJvZHlQcm9wcyB9O1xyXG4gICAgfSwgW3VzZU1vZGFsQmFja2Ryb3BdKTtcclxuICAgIGNvbnN0IHVzZURpYWxvZ1Byb3BzID0gdXNlTW9kYWxQcm9wcztcclxuXHJcbiAgICBjb25zdCB1c2VEaWFsb2dUaXRsZSA9IHVzZUNhbGxiYWNrPFJbXCJ1c2VEaWFsb2dUaXRsZVwiXT4oKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxUaXRsZVByb3BzIH0gPSB1c2VNb2RhbFRpdGxlKCk7XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlRGlhbG9nVGl0bGVQcm9wczogdXNlTW9kYWxUaXRsZVByb3BzIH07XHJcbiAgICB9LCBbdXNlTW9kYWxUaXRsZV0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlRGlhbG9nUHJvcHMsXHJcbiAgICAgICAgdXNlRGlhbG9nVGl0bGUsXHJcbiAgICAgICAgdXNlRGlhbG9nQm9keSxcclxuICAgICAgICB1c2VEaWFsb2dCYWNrZHJvcFxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZSwgdXNlSGFzRm9jdXMsIHVzZUxheW91dEVmZmVjdCwgdXNlTGlzdE5hdmlnYXRpb24sIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgdXNlTWVyZ2VkUHJvcHMsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBFdmVudERldGFpbCwgVGFnU2Vuc2l0aXZlUHJvcHMgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VQcmVzc0V2ZW50SGFuZGxlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcbmltcG9ydCB7IHVzZUxhYmVsIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XHJcblxyXG5leHBvcnQgdHlwZSBMaXN0Ym94TXVsdGlTZWxlY3RFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0geyBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiBib29sZWFuIH0gfSAmIFBpY2s8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPiwgXCJ0YXJnZXRcIiB8IFwiY3VycmVudFRhcmdldFwiPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBVc2VMaXN0Ym94TXVsdGlJdGVtSW5mb0Jhc2U8TGlzdEl0ZW1FbGVtZW50LCBLPj4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8SywgST4ge1xyXG4gICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xyXG4gICAgdGFnTGlzdDogRWxlbWVudFRvVGFnPExpc3RFbGVtZW50PlxyXG59XHJcblxyXG5cclxuXHJcbnR5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+O1xyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpSXRlbUluZm9CYXNlPEUgZXh0ZW5kcyBFbGVtZW50LCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPiwgVGFnU2Vuc2l0aXZlUHJvcHM8RT4ge1xyXG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW47XHJcbiAgICBvblNlbGVjdD8oZXZlbnQ6IChMaXN0Ym94TXVsdGlTZWxlY3RFdmVudDxFbGVtZW50PikpOiB2b2lkO1xyXG4gICAgc2V0VHlwZWFoZWFkSW5Qcm9ncmVzcyhpblByb2dyZXNzOiBib29sZWFuKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlTGlzdGJveE11bHRpSXRlbVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQsIEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBVc2VMaXN0Ym94TXVsdGlJdGVtSW5mb0Jhc2U8RSwgSz4+ID0ge1xyXG4gICAgaW5mbzogIE9taXQ8SSwgXCJzZXRUeXBlYWhlYWRJblByb2dyZXNzXCIgfCBcImdldEVsZW1lbnRcIiB8IFwiZmxhZ3NcIiB8IFwiYmx1clNlbGZcIiB8IFwiZm9jdXNTZWxmXCI+O1xyXG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgVXNlTGlzdGJveE11bHRpSXRlbTxFIGV4dGVuZHMgRWxlbWVudCwgSyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIFVzZUxpc3Rib3hNdWx0aUl0ZW1JbmZvQmFzZTxFLCBLPj4gPSAoaW5mbzogVXNlTGlzdGJveE11bHRpSXRlbVBhcmFtZXRlcnM8RSwgSywgST4pID0+IHtcclxuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbiAgICB0YWJiYWJsZTogYm9vbGVhbjtcclxufVxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFMaXN0Ym94TXVsdGk8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgSyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIFVzZUxpc3Rib3hNdWx0aUl0ZW1JbmZvQmFzZTxMaXN0SXRlbUVsZW1lbnQsIEs+Pih7IHRhZ0xhYmVsLCB0YWdMaXN0LCAuLi5hcmdzIH06IFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBLLCBJPikge1xyXG5cclxuXHJcbiAgICAvL2NvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0Rm9jdXNlZElubmVyIH0gPSB1c2VIYXNGb2N1czxMaXN0RWxlbWVudD4oe30pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dCwgdXNlTGFiZWxMYWJlbCB9ID0gdXNlTGFiZWw8TGlzdEVsZW1lbnQsIExhYmVsRWxlbWVudD4oeyBsYWJlbFByZWZpeDogXCJhcmlhLWxpc3Rib3gtbGFiZWwtXCIsIGlucHV0UHJlZml4OiBcImFyaWEtbGlzdGJveC1cIiwgdGFnTGFiZWw6IHRhZ0xhYmVsIGFzIG5ldmVyLCB0YWdJbnB1dDogdGFnTGlzdCBhcyBuZXZlciB9KVxyXG4gICAgY29uc3QgeyB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCB1c2VMaXN0TmF2aWdhdGlvblByb3BzLCBzZXRUYWJiYWJsZUluZGV4LCBjdXJyZW50VHlwZWFoZWFkLCBpbnZhbGlkVHlwZWFoZWFkLCBjaGlsZHJlbiB9ID0gdXNlTGlzdE5hdmlnYXRpb248TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgc3RyaW5nLCBVc2VMaXN0Ym94TXVsdGlJdGVtSW5mb0Jhc2U8TGlzdEl0ZW1FbGVtZW50LCBLPj4oeyAuLi5hcmdzIH0pO1xyXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHMgfSA9IHVzZUxhYmVsSW5wdXQoKTtcclxuXHJcbiAgICBjb25zdCBbLCBzZXRTaGlmdEhlbGQsIGdldFNoaWZ0SGVsZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgY29uc3QgdHlwZWFoZWFkSW5Qcm9ncmVzcyA9ICghIWN1cnJlbnRUeXBlYWhlYWQpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5zZXRUeXBlYWhlYWRJblByb2dyZXNzKHR5cGVhaGVhZEluUHJvZ3Jlc3MpKTtcclxuICAgIH0sIFt0eXBlYWhlYWRJblByb2dyZXNzXSk7XHJcblxyXG4gICAgY29uc3QgdXNlTGlzdGJveE11bHRpSXRlbTogVXNlTGlzdGJveE11bHRpSXRlbTxMaXN0SXRlbUVsZW1lbnQsIEssIEk+ID0gdXNlQ2FsbGJhY2soKHtpbmZvOiB7IGluZGV4LCBzZWxlY3RlZCwgdGFnLCB0ZXh0LCBoaWRkZW4sIG9uU2VsZWN0LCAuLi5yZXN0SW5mbyB9LCBkaXNhYmxlZH06IFVzZUxpc3Rib3hNdWx0aUl0ZW1QYXJhbWV0ZXJzPExpc3RJdGVtRWxlbWVudCwgSywgST4pID0+IHtcclxuICAgICAgICB0eXBlIEUgPSBMaXN0SXRlbUVsZW1lbnQ7XHJcbiAgICAgICAgY29uc3QgW3R5cGVhaGVhZEluUHJvZ3Jlc3MsIHNldFR5cGVhaGVhZEluUHJvZ3Jlc3NdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGdldFNlbGVjdGVkID0gdXNlU3RhYmxlR2V0dGVyKHNlbGVjdGVkKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudDxFPih7fSk7XHJcbiAgICAgICAgY29uc3Qgc3RhYmxlT25TZWxlY3QgPSB1c2VTdGFibGVDYWxsYmFjayhvblNlbGVjdCA/PyAoKCkgPT4geyB9KSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7IGluZm86IHsgaW5kZXgsIHNlbGVjdGVkLCB0YWcsIHRleHQsIGhpZGRlbiwgb25TZWxlY3QsIHNldFR5cGVhaGVhZEluUHJvZ3Jlc3MsIGZsYWdzOiB7fSwgLi4ucmVzdEluZm8gfSB9KTtcclxuXHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZ2V0U2hpZnRIZWxkKCkpIHtcclxuICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyB0YXJnZXQ6IGVsZW1lbnQsIGN1cnJlbnRUYXJnZXQ6IGVsZW1lbnQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWQ6IHRydWUgfSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFt0YWJiYWJsZV0pO1xyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VMaXN0Ym94TXVsdGlJdGVtUHJvcHMsIHRhYmJhYmxlIH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiA9IHVzZVByZXNzRXZlbnRIYW5kbGVyczxFPihkaXNhYmxlZCA/IG51bGwgOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE11bHRpICR7aW5kZXh9IGlzICR7Z2V0U2VsZWN0ZWQoKS50b1N0cmluZygpfSBhbmQgY2hhbmdpbmcgdG8gJHsoIWdldFNlbGVjdGVkKCkpLnRvU3RyaW5nKCl9YClcclxuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaW5kZXgsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyAuLi5lLCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiAhZ2V0U2VsZWN0ZWQoKSB9IH0pO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9LCB7IHNwYWNlOiB0eXBlYWhlYWRJblByb2dyZXNzID8gXCJleGNsdWRlXCIgOiB1bmRlZmluZWQgfSk7XHJcblxyXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJvcHRpb25cIjtcclxuICAgICAgICAgICAgLy9wcm9wc1tcImFyaWEtc2V0c2l6ZVwiXSA9IChjaGlsZENvdW50KS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAvL3Byb3BzW1wiYXJpYS1wb3NpbnNldFwiXSA9IChpbmZvLmluZGV4ICsgMSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXNlbGVjdGVkXCJdID0gKHRhYmJhYmxlID8/IGZhbHNlKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpXHJcbiAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBcInRydWVcIjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHModXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHVzZU1lcmdlZFByb3BzPEU+KG5ld1Byb3BzLCBwcm9wcykpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsIHR5cGVhaGVhZEluUHJvZ3Jlc3NdKTtcclxuXHJcbiAgICBjb25zdCB1c2VMaXN0Ym94TXVsdGlMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUxhYmVsKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+IHtcclxuICAgICAgICAgICAgY29uc3QgeyB1c2VMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUxhYmVsTGFiZWwoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZUxhYmVsTGFiZWxQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VMaXN0Ym94TXVsdGlMYWJlbFByb3BzIH07XHJcbiAgICB9LCBbdXNlTGFiZWxMYWJlbF0pO1xyXG5cclxuICAgIHJldHVybiB7IHVzZUxpc3Rib3hNdWx0aUl0ZW0sIHVzZUxpc3Rib3hNdWx0aVByb3BzLCB1c2VMaXN0Ym94TXVsdGlMYWJlbCwgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9O1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB1c2VMaXN0Ym94TXVsdGlQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IHtcclxuICAgICAgICBwcm9wcy5yb2xlID0gXCJsaXN0Ym94XCI7XHJcbiAgICAgICAgcHJvcHNbXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiXSA9IFwidHJ1ZVwiO1xyXG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzKHVzZUxhYmVsSW5wdXRQcm9wcyh1c2VNZXJnZWRQcm9wczxMaXN0RWxlbWVudD4oeyBvbktleURvd24sIG9uS2V5VXAsIG9uZm9jdXNvdXQ6IG9uRm9jdXNPdXQgfSwgcHJvcHMpKSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBvbktleURvd24oZTogS2V5Ym9hcmRFdmVudCkgeyBpZiAoZS5rZXkgPT0gXCJTaGlmdFwiKSBzZXRTaGlmdEhlbGQodHJ1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIG9uS2V5VXAoZTogS2V5Ym9hcmRFdmVudCkgeyBpZiAoZS5rZXkgPT0gXCJTaGlmdFwiKSBzZXRTaGlmdEhlbGQoZmFsc2UpOyB9XHJcbiAgICBmdW5jdGlvbiBvbkZvY3VzT3V0KF86IEZvY3VzRXZlbnQpIHsgc2V0U2hpZnRIZWxkKGZhbHNlKTsgfVxyXG5cclxufSIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IE1hbmFnZWRDaGlsZHJlbiB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZSwgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb24sIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgUm92aW5nVGFiSW5kZXhDaGlsZEluZm9CYXNlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXJvdmluZy10YWJpbmRleFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlUHJlc3NFdmVudEhhbmRsZXJzIH0gZnJvbSBcIi4vdXNlLWJ1dHRvblwiO1xyXG5pbXBvcnQgeyB1c2VMYWJlbCB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xyXG5cclxudHlwZSBPbWl0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFBpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj47XHJcbmV4cG9ydCB0eXBlIExpc3Rib3hTaW5nbGVTZWxlY3RFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0geyBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IG51bWJlciB9IH0gJiBQaWNrPGguSlNYLlRhcmdldGVkRXZlbnQ8RT4sIFwidGFyZ2V0XCIgfCBcImN1cnJlbnRUYXJnZXRcIj47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIFVzZUxpc3Rib3hTaW5nbGVJdGVtSW5mbzxMaXN0SXRlbUVsZW1lbnQsIEs+PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxLLCBJPiB7XHJcbiAgICBzZWxlY3Rpb25Nb2RlOiBcImZvY3VzXCIgfCBcImFjdGl2YXRlXCI7XHJcbiAgICBzZWxlY3RlZEluZGV4OiBudW1iZXIgfCBudWxsO1xyXG4gICAgb25TZWxlY3Q/KGV2ZW50OiBMaXN0Ym94U2luZ2xlU2VsZWN0RXZlbnQ8RWxlbWVudD4pOiB2b2lkO1xyXG4gICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xyXG4gICAgdGFnTGlzdDogRWxlbWVudFRvVGFnPExpc3RFbGVtZW50PjtcclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgdHlwZSBVc2VMaXN0Ym94U2luZ2xlSXRlbTxFIGV4dGVuZHMgRWxlbWVudCwgSyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIFVzZUxpc3Rib3hTaW5nbGVJdGVtSW5mbzxFLCBLPj4gPSAoaW5mbzogVXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzPEUsIEssIEk+KSA9PiBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGU8RT47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbiAgICB0YWJiYWJsZTogYm9vbGVhbjtcclxuICAgIHNlbGVjdGVkOiBib29sZWFuO1xyXG4gICAgZ2V0U2VsZWN0ZWQ6ICgpID0+IGJvb2xlYW4gfCBudWxsO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVSZXR1cm5UeXBlPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBVc2VMaXN0Ym94U2luZ2xlSXRlbUluZm88TGlzdEl0ZW1FbGVtZW50LCBLPj4ge1xyXG4gICAgdXNlTGlzdGJveFNpbmdsZUl0ZW06IFVzZUxpc3Rib3hTaW5nbGVJdGVtPExpc3RJdGVtRWxlbWVudCwgSywgST47XHJcbiAgICB1c2VMaXN0Ym94U2luZ2xlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD47XHJcbiAgICB1c2VMaXN0Ym94U2luZ2xlTGFiZWw6ICgpID0+IHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gdm9pZDsgfVxyXG4gICAgY3VycmVudFR5cGVhaGVhZDogc3RyaW5nIHwgbnVsbDtcclxuICAgIGludmFsaWRUeXBlYWhlYWQ6IGJvb2xlYW4gfCBudWxsO1xyXG4gICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxJPjtcclxufVxyXG5cclxuXHJcbmV4cG9ydCB0eXBlIFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudCwgSyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIFVzZUxpc3Rib3hTaW5nbGVJdGVtSW5mbzxFLCBLPj4gPSB7XHJcbiAgICBpbmZvOiBPbWl0PEksIFwiZ2V0RWxlbWVudFwiPjtcclxuICAgIGRpc2FibGVkPzogYm9vbGVhbjtcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZUl0ZW1JbmZvPEUgZXh0ZW5kcyBFbGVtZW50LCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPiB7XHJcbiAgICBnZXRFbGVtZW50KCk6IEU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhTGlzdGJveFNpbmdsZTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBLIGV4dGVuZHMgc3RyaW5nLCBJIGV4dGVuZHMgVXNlTGlzdGJveFNpbmdsZUl0ZW1JbmZvPExpc3RJdGVtRWxlbWVudCwgSz4+KHsgc2VsZWN0ZWRJbmRleCwgb25TZWxlY3QsIG9uVGFiYmFibGVJbmRleENoYW5nZTogb3RpYywgc2VsZWN0aW9uTW9kZSwgdGFnTGlzdCwgdGFnTGFiZWwsIC4uLmFyZ3MgfTogVXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBLLCBJPik6IFVzZUxpc3Rib3hTaW5nbGVSZXR1cm5UeXBlPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgSywgST4ge1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGBSZW5kZXJpbmcgbGlzdGJveCB3aXRoIHNlbGVjdGVkSW5kZXg9PSR7c2VsZWN0ZWRJbmRleH1gKTtcclxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dCwgdXNlTGFiZWxMYWJlbCB9ID0gdXNlTGFiZWw8TGlzdEVsZW1lbnQsIExhYmVsRWxlbWVudD4oeyBsYWJlbFByZWZpeDogXCJhcmlhLWxpc3Rib3gtbGFiZWwtXCIsIGlucHV0UHJlZml4OiBcImFyaWEtbGlzdGJveC1cIiwgdGFnSW5wdXQ6IHRhZ0xpc3QgYXMgbmV2ZXIsIHRhZ0xhYmVsOiB0YWdMYWJlbCBhcyBuZXZlciB9KVxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcclxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxyXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgZ2V0VGFiYmFibGVJbmRleCxcclxuICAgICAgICBzZXRUYWJiYWJsZUluZGV4XHJcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgXCJ0YWJiYWJsZVwiIHwgXCJzZWxlY3RlZFwiLCBJPih7XHJcbiAgICAgICAgc2VsZWN0ZWRJbmRleCxcclxuICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvdGljPj4oKGkpID0+IHtcclxuICAgICAgICAgICAgb3RpYz8uKGkpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uTW9kZSA9PSBcImZvY3VzXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGNoaWxkcmVuLmdldEF0KGkhKT8uZ2V0RWxlbWVudCgpITtcclxuICAgICAgICAgICAgICAgIG9uU2VsZWN0Py4oeyB0YXJnZXQsIGN1cnJlbnRUYXJnZXQ6IHRhcmdldCwgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBpISB9IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgLi4uYXJnc1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXRQcm9wcyB9ID0gdXNlTGFiZWxJbnB1dCgpO1xyXG4gICAgY29uc3Qgc3RhYmxlT25TZWxlY3QgPSB1c2VTdGFibGVDYWxsYmFjayhvblNlbGVjdCA/PyAoKCkgPT4geyB9KSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZUxpc3Rib3hTaW5nbGVJdGVtID0gdXNlQ2FsbGJhY2s8VXNlTGlzdGJveFNpbmdsZUl0ZW08TGlzdEl0ZW1FbGVtZW50LCBLLCBJPj4oKHsgaW5mbzogeyAuLi5pbmZvIH0sIGRpc2FibGVkIH0pOiBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGU8TGlzdEl0ZW1FbGVtZW50PiA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB0YWJiYWJsZSwgc2VsZWN0ZWQsIGdldFNlbGVjdGVkLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQoeyBpbmZvOiB7IC4uLmluZm8sIGdldEVsZW1lbnQ6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IGdldEVsZW1lbnQoKSkgfSBhcyBJIH0pO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5mby5pbmRleDtcclxuICAgICAgICBjb25zb2xlLmxvZyhgUmVuZGVyaW5nIGxpc3Rib3hpdGVtICMke2luZm8uaW5kZXh9IHdpdGggc2VsZWN0ZWQ9PSR7c2VsZWN0ZWQudG9TdHJpbmcoKX1gKTtcclxuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgdGFiYmFibGUgJiYgc2VsZWN0aW9uTW9kZSA9PSBcImZvY3VzXCIpIHtcclxuICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyB0YXJnZXQ6IGVsZW1lbnQsIGN1cnJlbnRUYXJnZXQ6IGVsZW1lbnQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogaW5kZXggfSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFt0YWJiYWJsZSwgc2VsZWN0aW9uTW9kZSwgaW5kZXhdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcywgdGFiYmFibGUsIHNlbGVjdGVkLCBnZXRTZWxlY3RlZCB9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0SXRlbUVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEl0ZW1FbGVtZW50PiA9IHVzZVByZXNzRXZlbnRIYW5kbGVyczxMaXN0SXRlbUVsZW1lbnQ+KGRpc2FibGVkID8gbnVsbCA6IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlT25TZWxlY3Q/Lih7IHRhcmdldDogZWxlbWVudCwgY3VycmVudFRhcmdldDogZWxlbWVudCwgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBpbmRleCB9IH0pO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQpO1xyXG5cclxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwib3B0aW9uXCI7XHJcbiAgICAgICAgICAgIC8vcHJvcHNbXCJhcmlhLXNldHNpemVcIl0gPSAoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkgKyAxKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAvL3Byb3BzW1wiYXJpYS1wb3NpbnNldFwiXSA9IChpbmZvLmluZGV4ICsgMSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXNlbGVjdGVkXCJdID0gKHNlbGVjdGVkID8/IGZhbHNlKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpXHJcbiAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBcInRydWVcIlxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VNZXJnZWRQcm9wczxMaXN0SXRlbUVsZW1lbnQ+KG5ld1Byb3BzLCBwcm9wcykpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLCBzZWxlY3Rpb25Nb2RlXSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZUxpc3Rib3hTaW5nbGVMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCgpIHtcclxuICAgICAgICBmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pikge1xyXG4gICAgICAgICAgICBjb25zdCB7IHVzZUxhYmVsTGFiZWxQcm9wcyB9ID0gdXNlTGFiZWxMYWJlbCgpO1xyXG4gICAgICAgICAgICB1c2VMYWJlbExhYmVsUHJvcHMocHJvcHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHMgfTtcclxuICAgIH0sIFt1c2VMYWJlbExhYmVsXSk7XHJcblxyXG5cclxuICAgIHJldHVybiB7IHVzZUxpc3Rib3hTaW5nbGVJdGVtLCB1c2VMaXN0Ym94U2luZ2xlUHJvcHMsIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCwgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCwgY2hpbGRyZW4gfTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZVByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pIHtcclxuICAgICAgICBwcm9wcy5yb2xlID0gXCJsaXN0Ym94XCI7XHJcbiAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHModXNlTGFiZWxJbnB1dFByb3BzKHByb3BzKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlSGFzRm9jdXMsIHVzZUxpc3ROYXZpZ2F0aW9uLCBMaXN0TmF2aWdhdGlvbkNoaWxkSW5mb0Jhc2UsIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgdXNlTWVyZ2VkUHJvcHMsIHVzZVJhbmRvbUlkLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlR2V0dGVyLCB1c2VTdGF0ZSwgdXNlVGltZW91dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvTmVlZGVkIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxpc3QtbmF2aWdhdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFdmVudERldGFpbCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZVNvZnREaXNtaXNzIH0gZnJvbSBcIi4vdXNlLW1vZGFsXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVCYXNlUGFyYW1ldGVycyB7XHJcbiAgICBvcGVuOiBib29sZWFuIHwgXCJtZW51YmFyXCI7XHJcbiAgICBvbkNsb3NlKCk6IHZvaWQ7XHJcbiAgICBvbk9wZW4oKTogdm9pZDtcclxuICAgIHNlbmRGb2N1c1dpdGhpbk1lbnUoKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhTWVudVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQsIEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBVc2VNZW51SXRlbURlZmF1bHRJbmZvPEU+PiBleHRlbmRzIE9taXQ8VXNlTWVudUJhc2VQYXJhbWV0ZXJzLCBcInNlbmRGb2N1c1dpdGhpbk1lbnVcIj4sIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxLLCBJPiB7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZU1lbnVTdWJtZW51SXRlbVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQsIEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBVc2VNZW51SXRlbURlZmF1bHRJbmZvPEU+PiA9IFVzZUFyaWFNZW51UGFyYW1ldGVyczxFLCBLLCBJPiAmIHt9XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktaW50ZXJmYWNlICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUJ1dHRvblBhcmFtZXRlcnMgeyB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtQ2hlY2tib3hJbmZvPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkSW5mb0Jhc2U8c3RyaW5nPiB7XHJcbiAgICB0eXBlOiBcImNoZWNrYm94XCI7XHJcbiAgICBjaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiO1xyXG4gICAgb25DaGFuZ2UoZTogeyBbRXZlbnREZXRhaWxdOiB7IGNoZWNrZWQ6IGJvb2xlYW4gfSB9ICYgaC5KU1guVGFyZ2V0ZWRFdmVudDxFLCBFdmVudD4pOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtUmFkaW9JbmZvPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkSW5mb0Jhc2U8c3RyaW5nPiB7XHJcbiAgICB0eXBlOiBcInJhZGlvXCI7XHJcbiAgICBjaGVja2VkOiBib29sZWFuO1xyXG4gICAgb25DaGFuZ2UoZTogeyBbRXZlbnREZXRhaWxdOiB7IGNoZWNrZWQ6IGJvb2xlYW4gfSB9ICYgaC5KU1guVGFyZ2V0ZWRFdmVudDxFLCBFdmVudD4pOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtRGVmYXVsdEluZm88RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxzdHJpbmc+IHtcclxuICAgIHR5cGU/OiBcImRlZmF1bHRcIjtcclxuICAgIG9uQ2xpY2s/KGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8RT4pOiB2b2lkO1xyXG59XHJcblxyXG4vL2V4cG9ydCB0eXBlIFVzZU1lbnVJdGVtQ2hlY2tib3hQYXJhbWV0ZXJzPEkgZXh0ZW5kcyBVc2VNZW51Q2hpbGRJbmZvPiA9IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEk+O1xyXG4vL2V4cG9ydCB0eXBlIFVzZU1lbnVJdGVtUmFkaW9QYXJhbWV0ZXJzPEkgZXh0ZW5kcyBVc2VNZW51Q2hpbGRJbmZvPiA9IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEk+O1xyXG5leHBvcnQgdHlwZSBVc2VNZW51SXRlbURlZmF1bHRQYXJhbWV0ZXJzPEkgZXh0ZW5kcyBVc2VNZW51Q2hpbGRJbmZvPiA9IHsgaW5mbzogVXNlTGlzdE5hdmlnYXRpb25DaGlsZEluZm9OZWVkZWQ8c3RyaW5nLCBJPiB9O1xyXG5cclxuXHJcbmV4cG9ydCB0eXBlIFVzZU1lbnVJdGVtPEUgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgVXNlTWVudUNoaWxkSW5mbz4gPSAoYXJnczogVXNlTWVudUl0ZW1EZWZhdWx0UGFyYW1ldGVyczxJPikgPT4ge1xyXG4gICAgdXNlTWVudUl0ZW1Qcm9wczogKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVDaGlsZEluZm8gZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkSW5mb0Jhc2U8c3RyaW5nPiB7XHJcblxyXG59XHJcbi8vZXhwb3J0IHR5cGUgVXNlTWVudUNoaWxkUGFyYW1ldGVyczxJIGV4dGVuZHMgVXNlTWVudUNoaWxkSW5mbz4gPSBJO1xyXG5cclxuLyoqXHJcbiAqIEEgbWVudSBpcyBhIHBvcHVwIGNvbnRyb2wgdGhhdCBjb250YWlucyBhIGxpc3Qgb2YgbWVudSBpdGVtcywgYW5kIHRoYXQncyBpdC5cclxuICogSXQgaGFzIHZlcnkgd2VsbC1kZWZpbmVkIGxvZ2ljIGZvciBtYW5hZ2luZyB0aG9zZSBpdGVtcyBhcyB0aGUgbWVudSdzIHN0YXRlIGNoYW5nZXMuXHJcbiAqIFxyXG4gKiBBIE1lbnVCYXNlIGlzIGp1c3QgdGhlIFwicG9wdXBcIiBwYXJ0IHdpdGhvdXQgdGhlIFwibGlzdCBvZiBtZW51IGl0ZW1zXCIgcGFydC4gSXQgY2FuXHJcbiAqIChyZWFsbHksIG11c3QpIGhhdmUgaW50ZXJhY3RpdmUgY29udHJvbHMsIGJ1dCB0aGVzZSBjb250cm9scyBhcmUgYWxsb3dlZCB0byBiZSBtb3JlXHJcbiAqIGZyZWUtZm9ybS4gVGhpcyBtZWFucyB0aGF0LCBsaWtlIGEgZGlhbG9nLCB5b3UgbXVzdCB0ZWxsIHRoaXMgaG9va1xyXG4gKiB3aGVyZSB3aXRoaW4gdGhlIHBvcHVwIHRvIHNlbmQgZm9jdXMgd2hlbiBvcGVuZWQgKGZvciBhIG1lbnUgaXQncyBqdXN0IHRoZSBmaXJzdFxyXG4gKiBtZW51IGl0ZW0sIGJ1dCB3aXRoIGN1c3RvbSBjb250ZW50IHlvdSdsbCBuZWVkIHRvIHByb3ZpZGUgdGhpcykuXHJcbiAqIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbnVCYXNlPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBLIGV4dGVuZHMgc3RyaW5nLCBJIGV4dGVuZHMgVXNlTWVudUl0ZW1EZWZhdWx0SW5mbzxQYXJlbnRFbGVtZW50Pj4oeyBzZW5kRm9jdXNXaXRoaW5NZW51LCAuLi5hcmdzIH06IFVzZU1lbnVCYXNlUGFyYW1ldGVycykge1xyXG4gICAgdHlwZSBFID0gUGFyZW50RWxlbWVudDtcclxuXHJcbiAgICBjb25zdCBnZXRTZW5kRm9jdXNXaXRoaW5NZW51ID0gdXNlU3RhYmxlR2V0dGVyKHNlbmRGb2N1c1dpdGhpbk1lbnUpO1xyXG4gICAgY29uc3QgW2ZvY3VzVHJhcEFjdGl2ZSwgc2V0Rm9jdXNUcmFwQWN0aXZlXSA9IHVzZVN0YXRlPG51bGwgfCBib29sZWFuPihudWxsKTtcclxuXHJcbiAgICBjb25zdCBvbkNsb3NlID0gKGFyZ3MgYXMgUGFydGlhbDxVc2VBcmlhTWVudVBhcmFtZXRlcnM8RSwgSywgST4+KS5vbkNsb3NlO1xyXG4gICAgY29uc3Qgb25PcGVuID0gKGFyZ3MgYXMgUGFydGlhbDxVc2VBcmlhTWVudVBhcmFtZXRlcnM8RSwgSywgST4+KS5vbk9wZW47XHJcbiAgICAvL2NvbnN0IG1lbnViYXIgPSAoYXJncyBhcyBQYXJ0aWFsPFVzZU1lbnVQYXJhbWV0ZXJzMjxFLCBLLCBJPj4pLm1lbnViYXI7XHJcbiAgICBjb25zdCBvcGVuID0gKGFyZ3MgYXMgVXNlQXJpYU1lbnVQYXJhbWV0ZXJzPEUsIEssIEk+KS5vcGVuO1xyXG4gICAgY29uc3Qgc3RhYmxlT25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UgPz8gKCgpID0+IHsgfSkpO1xyXG4gICAgY29uc3QgZ2V0T3BlbiA9IHVzZVN0YWJsZUdldHRlcihvcGVuKTtcclxuXHJcbiAgICAvLyBUT0RPOiBJdCdzIGF3a3dhcmQgdGhhdCB0aGUgYnV0dG9uIGZvY3VzIHByb3BzIGFyZSBvdXQgaGVyZSB3aGVyZSB3ZSBkb24ndCBoYXZlIGl0cyB0eXBlLFxyXG4gICAgLy8gYnV0IGZvY3VzIG1hbmFnZW1lbnQgaXMgc3VwZXIgc2Vuc2l0aXZlLCBhbmQgZXZlbiB3YWl0aW5nIGZvciBhIHVzZUxheW91dEVmZmVjdCB0byBzeW5jIHN0YXRlIGhlcmVcclxuICAgIC8vIHdvdWxkIGJlIHRvbyBsYXRlLCBzbyBpdCB3b3VsZCBsb29rIGxpa2UgdGhlcmUncyBhIG1vbWVudCBiZXR3ZWVuIG1lbnUgZm9jdXMgbG9zdCBhbmQgYnV0dG9uIGZvY3VzIGdhaW5lZFxyXG4gICAgLy8gd2hlcmUgbm90aGluZyBpcyBmb2N1c2VkLiBcclxuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wczogdXNlTWVudUJhc2VIYXNGb2N1c1Byb3BzLCBnZXRMYXN0Rm9jdXNlZElubmVyOiBnZXRNZW51QmFzZUxhc3RGb2N1c2VkSW5uZXIgfSA9IHVzZUhhc0ZvY3VzPEU+KHsgLypvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkOiBvbk1lbnVPckJ1dHRvbkxvc3RMYXN0Rm9jdXMqLyB9KTtcclxuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wczogdXNlQnV0dG9uSGFzRm9jdXNQcm9wcywgZ2V0TGFzdEZvY3VzZWRJbm5lcjogZ2V0TWVudUJhc2VCdXR0b25MYXN0Rm9jdXNlZElubmVyIH0gPSB1c2VIYXNGb2N1czxhbnk+KHsgLypvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkOiBvbk1lbnVPckJ1dHRvbkxvc3RMYXN0Rm9jdXMqLyB9KTtcclxuXHJcbiAgICBjb25zdCBbLCBzZXRPcGVuZXJFbGVtZW50LCBnZXRPcGVuZXJFbGVtZW50XSA9IHVzZVN0YXRlPChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCkgfCBudWxsPihudWxsKTtcclxuXHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCB9ID0gdXNlUmFuZG9tSWQ8UGFyZW50RWxlbWVudD4oeyBwcmVmaXg6IFwiYXJpYS1tZW51LVwiIH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50KCk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudChcImFyaWEtY29udHJvbHNcIiBhcyBuZXZlcik7XHJcblxyXG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRCdXR0b25FbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUJ1dHRvblJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxhbnk+KHsgb25FbGVtZW50Q2hhbmdlOiBzZXRPcGVuZXJFbGVtZW50IH0pO1xyXG5cclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0TWVudUVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlTWVudUJhc2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8YW55Pih7fSk7XHJcbiAgICBjb25zdCB7IHVzZVNvZnREaXNtaXNzUHJvcHMgfSA9IHVzZVNvZnREaXNtaXNzPGFueT4oeyBvbkNsb3NlOiBzdGFibGVPbkNsb3NlLCBnZXRFbGVtZW50czogKCkgPT4gKFtnZXRCdXR0b25FbGVtZW50KCksIGdldE1lbnVFbGVtZW50KCldKSwgb3BlbjogISFvcGVuIH0pO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0Rm9jdXNUcmFwQWN0aXZlKG9wZW4gPT09IHRydWUpO1xyXG4gICAgfSwgW29wZW5dKTtcclxuXHJcblxyXG5cclxuICAgIGNvbnN0IHVzZU1lbnVCYXNlUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4gPT4ge1xyXG4gICAgICAgIGZ1bmN0aW9uIG9uS2V5RG93bihlOiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChlLmtleSA9PSBcIkVzY2FwZVwiICYmIGdldE9wZW4oKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhYmxlT25DbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB1c2VTb2Z0RGlzbWlzc1Byb3BzKHVzZU1lbnVCYXNlSGFzRm9jdXNQcm9wcyh1c2VNZW51QmFzZVJlZkVsZW1lbnRQcm9wcyh1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyh1c2VNZXJnZWRQcm9wczxQYXJlbnRFbGVtZW50Pih7IG9uS2V5RG93biB9LCAocHJvcHMpKSkpKSk7XHJcbiAgICB9LCBbdXNlU29mdERpc21pc3NQcm9wcywgdXNlTWVudUJhc2VIYXNGb2N1c1Byb3BzLCB1c2VNZW51QmFzZVJlZkVsZW1lbnRQcm9wcywgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHNdKTtcclxuXHJcbiAgICBjb25zdCB1c2VNZW51QmFzZUJ1dHRvblByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHVzZUJ1dHRvblJlZkVsZW1lbnRQcm9wcyh1c2VCdXR0b25IYXNGb2N1c1Byb3BzKHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyhwcm9wcykpKTtcclxuICAgIH0sIFt1c2VCdXR0b25IYXNGb2N1c1Byb3BzLCB1c2VCdXR0b25SZWZFbGVtZW50UHJvcHMsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wc10pO1xyXG5cclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNlbmRGb2N1c1dpdGhpbk1lbnUgPSBnZXRTZW5kRm9jdXNXaXRoaW5NZW51KCk7XHJcblxyXG4gICAgICAgIGlmIChmb2N1c1RyYXBBY3RpdmUpIHtcclxuICAgICAgICAgICAgc2VuZEZvY3VzV2l0aGluTWVudT8uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZvY3VzVHJhcEFjdGl2ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKGdldE1lbnVCYXNlTGFzdEZvY3VzZWRJbm5lcigpKVxyXG4gICAgICAgICAgICAgICAgZ2V0T3BlbmVyRWxlbWVudCgpPy5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBudWxsLCBzbyB3ZSd2ZSBvbmx5IGp1c3QgbW91bnRlZCBhbmQgc2hvdWxkbid0IGZvY3VzIG91cnNlbHZlcy5cclxuICAgICAgICB9XHJcbiAgICB9LCBbZm9jdXNUcmFwQWN0aXZlXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VNZW51U2VudGluZWw6IHVzZUNhbGxiYWNrKDxFIGV4dGVuZHMgRWxlbWVudD4oKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlU2VudGluZWxQcm9wczogdXNlTWVudVNlbnRpbmVsUHJvcHMsIC4uLnJlc3QgfSA9IHVzZUZvY3VzU2VudGluZWw8RT4oeyBvcGVuOiBvcGVuID09PSB0cnVlLCBvbkNsb3NlOiAob25DbG9zZSA/PyAoKCkgPT4geyB9KSksIHNlbmRGb2N1c1dpdGhpbk1lbnUgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHVzZU1lbnVTZW50aW5lbFByb3BzLCAuLi5yZXN0IH07XHJcbiAgICAgICAgfSwgW29wZW4sIG9uQ2xvc2UsIHNlbmRGb2N1c1dpdGhpbk1lbnVdKSxcclxuICAgICAgICBmb2N1c1RyYXBBY3RpdmUsXHJcbiAgICAgICAgdXNlTWVudUJhc2VQcm9wcyxcclxuICAgICAgICB1c2VNZW51QmFzZUJ1dHRvblByb3BzLFxyXG4gICAgICAgIGdldE1lbnVCYXNlTGFzdEZvY3VzZWRJbm5lcixcclxuICAgICAgICBnZXRNZW51QmFzZUJ1dHRvbkxhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgb3BlbixcclxuICAgICAgICBvbk9wZW4sXHJcbiAgICAgICAgb25DbG9zZVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLy8gQSBmb2N1cyBzZW50aW5hbCBpcyBhIGhpZGRlbiBidXQgZm9jdXNhYmxlIGVsZW1lbnQgdGhhdCBjb21lcyBhdCB0aGUgc3RhcnQgb3IgZW5kIFxyXG4vLyBvZiB0aGUgb3V0LW9mLXBsYWNlLWZvY3VzYWJsZSBjb21wb25lbnQgdGhhdCwgd2hlbiBhY3RpdmF0ZWQgb3IgZm9jdXNlZCBvdmVyLCBjbG9zZXMgdGhlIGNvbXBvbmVudFxyXG4vLyAoaWYgZm9jdXNlZCB3aXRoaW4gMTAwbXMgb2YgdGhlIG9wZW4gcHJvcCBjaGFuZ2luZywgaW5zdGVhZCBvZlxyXG4vLyBjbG9zaW5nLCBmb2N1c2luZyB0aGUgc2VudGluZWwgaW1tZWRpYXRlbHkgYXNrcyBpdCB0byBmb2N1cyBpdHNlbGYpLlxyXG4vLyBUaGlzIGV4aXN0cyBmb3IgdGhpbmdzIGxpa2UgbWVudXMgd2hpY2ggY2FuIGhhdmUgZm9jdXMgYnV0IGFsc28gbmVlZCBhIHdheSB0byByZXR1cm5cclxuLy8gdG8gd2hhdGV2ZXIgb3V0LW9mLXBsYWNlIHBhcmVudCB0aGV5IGNhbWUgZnJvbSB3aGVuIG5hdHVyYWxseSB0YWJiZWQgb3V0IG9mIChhcyBvcHBvc2VkXHJcbi8vIHRvIGRpYWxvZ3Mgd2hpY2ggbG9vcCBiYWNrIGFyb3VuZCB3aGVuIHRhYmJlZCBvdXQgb2YpLiBXaGlsZSBtb3VzZSB1c2VycyBjYW4gY2xpY2sgb3V0IG9mIGEgbWVudVxyXG4vLyBhbmQga2V5Ym9hcmQgdXNlcnMgY2FuIGVzY2FwZSB0byBjbG9zZSBhIG1lbnUsIHNjcmVlbiByZWFkZXJzIGFuZCBvdGhlciBpbnB1dCBtZXRob2RzIFxyXG4vLyB0aGF0IGRvbid0IHVzZSB0aG9zZSB0d28gd291bGQgYmVjb21lIHN0dWNrLlxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9jdXNTZW50aW5lbDxFIGV4dGVuZHMgRWxlbWVudD4oeyBvcGVuLCBvbkNsb3NlLCBzZW5kRm9jdXNXaXRoaW5NZW51IH06IHsgb3BlbjogYm9vbGVhbiwgb25DbG9zZTogKCkgPT4gdm9pZDsgc2VuZEZvY3VzV2l0aGluTWVudTogKCkgPT4gdm9pZDsgfSkge1xyXG4gICAgY29uc3QgZ2V0U2VuZEZvY3VzV2l0aGluTWVudSA9IHVzZVN0YWJsZUdldHRlcihzZW5kRm9jdXNXaXRoaW5NZW51KTtcclxuICAgIGNvbnN0IHN0YWJsZU9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjayhvbkNsb3NlKTtcclxuXHJcbiAgICBjb25zdCBbZmlyc3RTZW50aW5lbElzQWN0aXZlLCBzZXRGaXJzdFNlbnRpbmVsSXNBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgdXNlVGltZW91dCh7IGNhbGxiYWNrOiAoKSA9PiB7IHNldEZpcnN0U2VudGluZWxJc0FjdGl2ZShvcGVuKTsgfSwgdGltZW91dDogMTAwLCB0cmlnZ2VySW5kZXg6IGAke29wZW59LSR7Zmlyc3RTZW50aW5lbElzQWN0aXZlfWAgfSk7XHJcblxyXG5cclxuICAgIGNvbnN0IG9uRm9jdXMgPSBmaXJzdFNlbnRpbmVsSXNBY3RpdmUgPyAoKCkgPT4gc3RhYmxlT25DbG9zZSgpKSA6ICgoKSA9PiBnZXRTZW5kRm9jdXNXaXRoaW5NZW51KCk/LigpKTtcclxuICAgIGNvbnN0IG9uQ2xpY2sgPSAoKSA9PiBzdGFibGVPbkNsb3NlKCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VTZW50aW5lbFByb3BzOiBmdW5jdGlvbiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPih7IG9uRm9jdXMsIG9uQ2xpY2sgfSwgcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYU1lbnU8UGFyZW50RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBLIGV4dGVuZHMgc3RyaW5nLCBJIGV4dGVuZHMgVXNlTWVudUNoaWxkSW5mbz4oeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQsIGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgaW5pdGlhbEluZGV4LCBuYXZpZ2F0aW9uRGlyZWN0aW9uLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgLi4uYXJncyB9OiBVc2VBcmlhTWVudVBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgSywgST4pIHtcclxuXHJcblxyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICBjaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcclxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxyXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQsXHJcbiAgICAgICAgZm9jdXNTZWxmOiBmb2N1c01lbnVcclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIHN0cmluZywgST4oe1xyXG4gICAgICAgIGNvbGxhdG9yLFxyXG4gICAgICAgIG5vVHlwZWFoZWFkLFxyXG4gICAgICAgIHR5cGVhaGVhZFRpbWVvdXQsXHJcbiAgICAgICAgZGlzYWJsZUFycm93S2V5cyxcclxuICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICAgICAgaW5kZXhEZW1hbmdsZXIsXHJcbiAgICAgICAgaW5kZXhNYW5nbGVyLFxyXG4gICAgICAgIGluaXRpYWxJbmRleCxcclxuICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxyXG4gICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcclxuICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2VcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTWVudVNlbnRpbmVsLFxyXG4gICAgICAgIHVzZU1lbnVCYXNlQnV0dG9uUHJvcHMsXHJcbiAgICAgICAgdXNlTWVudUJhc2VQcm9wcyxcclxuICAgICAgICBnZXRNZW51QmFzZUJ1dHRvbkxhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgZ2V0TWVudUJhc2VMYXN0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgIG9wZW4sXHJcbiAgICAgICAgb25PcGVuLFxyXG4gICAgICAgIG9uQ2xvc2VcclxuICAgIH0gPSB1c2VNZW51QmFzZTxQYXJlbnRFbGVtZW50LCBLLCBJPih7XHJcbiAgICAgICAgLi4uYXJncyxcclxuICAgICAgICBzZW5kRm9jdXNXaXRoaW5NZW51OiBmb2N1c01lbnUgPz8gKCgpID0+IHsgfSlcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZU1lbnVCdXR0b25Qcm9wcyA9ICg8RSBleHRlbmRzIEVsZW1lbnQ+KHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcHJvcHMgPSB1c2VNZW51QmFzZUJ1dHRvblByb3BzKHApO1xyXG4gICAgICAgIHByb3BzW1wiYXJpYS1oYXNwb3B1cFwiXSA9IFwibWVudVwiO1xyXG4gICAgICAgIHByb3BzW1wiYXJpYS1leHBhbmRlZFwiXSA9IG9wZW4gPyBcInRydWVcIiA6IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VNZW51SXRlbTogVXNlTWVudUl0ZW08Q2hpbGRFbGVtZW50LCBJPiA9IHVzZUNhbGxiYWNrKChhcmdzOiBVc2VNZW51SXRlbURlZmF1bHRQYXJhbWV0ZXJzPEk+KSA9PiB7XHJcbiAgICAgICAgdHlwZSBFID0gQ2hpbGRFbGVtZW50O1xyXG5cclxuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZChhcmdzKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlTWVudUl0ZW1Qcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHsgLi4ucHJvcHMgfTogUCkge1xyXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJtZW51aXRlbVwiO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oe30sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcykpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTWVudUl0ZW1Qcm9wcyB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB1c2VNZW51UHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+Pih7IC4uLnByb3BzIH06IFApIHtcclxuICAgICAgICBwcm9wcy5yb2xlID0gXCJtZW51XCI7XHJcbiAgICAgICAgcmV0dXJuIHVzZU1lbnVCYXNlUHJvcHModXNlTGlzdE5hdmlnYXRpb25Qcm9wcyhwcm9wcykpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZU1lbnVQcm9wcyxcclxuICAgICAgICB1c2VNZW51QnV0dG9uUHJvcHMsXHJcblxyXG4gICAgICAgIHVzZU1lbnVJdGVtLFxyXG4gICAgICAgIHVzZU1lbnVTZW50aW5lbCxcclxuICAgICAgICAvL3VzZU1lbnVTdWJtZW51SXRlbSxcclxuXHJcbiAgICAgICAgZm9jdXNNZW51LFxyXG5cclxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxyXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQsXHJcblxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblxyXG5cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBMaXN0TmF2aWdhdGlvbkNoaWxkSW5mb0Jhc2UsIHVzZUFjdGl2ZUVsZW1lbnQsIHVzZUNoaWxkcmVuRmxhZywgdXNlTGlzdE5hdmlnYXRpb24sIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb24sIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsLCBUYWdTZW5zaXRpdmVQcm9wcyB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZUNoZWNrYm94TGlrZSwgVXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVycywgdXNlTGFiZWwgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcclxuXHJcbmV4cG9ydCB0eXBlIFJhZGlvQ2hhbmdlRXZlbnQ8RXZlbnRUeXBlIGV4dGVuZHMgRXZlbnQ+ID0gRXZlbnRUeXBlICYgeyBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkVmFsdWU6IHN0cmluZyB9IH07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFSYWRpb0dyb3VwUGFyYW1ldGVyczxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHcm91cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkSW5mb0Jhc2U8Sz4+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPEssIEk+IHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuXHJcbiAgICBzZWxlY3RlZFZhbHVlOiBWO1xyXG4gICAgb25JbnB1dChldmVudDogUmFkaW9DaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0RWxlbWVudD4+KTogdm9pZDtcclxuICAgIG9uSW5wdXQoZXZlbnQ6IFJhZGlvQ2hhbmdlRXZlbnQ8aC5KU1guVGFyZ2V0ZWRFdmVudDxMYWJlbEVsZW1lbnQ+Pik6IHZvaWQ7XHJcbiAgICB0YWdHcm91cDogRWxlbWVudFRvVGFnPEdyb3VwRWxlbWVudD47XHJcbiAgICB0YWdHcm91cExhYmVsOiBFbGVtZW50VG9UYWc8R3JvdXBMYWJlbEVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFSYWRpb0luZm9CYXNlIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZEluZm9CYXNlPFwidGFiYmFibGVcIiB8IFwic2VsZWN0ZWRcIj4ge1xyXG4gICAgc2V0Q2hlY2tlZChjaGVja2VkOiBib29sZWFuKTogdm9pZDtcclxuICAgIGdldENoZWNrZWQoKTogYm9vbGVhbiB8IG51bGw7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCB0eXBlIFVzZUFyaWFSYWRpb1BhcmFtZXRlcnM8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSSBleHRlbmRzIEVsZW1lbnQsIElMIGV4dGVuZHMgRWxlbWVudCwgSW5mbyBleHRlbmRzIFVzZUFyaWFSYWRpb0luZm9CYXNlPiA9XHJcbiAgICBPbWl0PFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgSUw+LCBcIm9uSW5wdXRcIiB8IFwicm9sZVwiIHwgXCJjaGVja2VkXCIgPiAmIHtcclxuICAgICAgICBpbmZvOiBPbWl0PEluZm8sIFwic2V0Q2hlY2tlZFwiIHwgXCJnZXRDaGVja2VkXCJ8IFwiYmx1clNlbGZcIiB8IFwiZ2V0RWxlbWVudFwiIHwgXCJmb2N1c1NlbGZcIj47XHJcbiAgICAgICAgbGFiZWxQb3NpdGlvbjogXCJ3cmFwcGluZ1wiIHwgXCJzZXBhcmF0ZVwiO1xyXG4gICAgICAgIHZhbHVlOiBWO1xyXG4gICAgICAgIGRpc2FibGVkOiBib29sZWFuO1xyXG4gICAgICAgIHRhZ0lucHV0OiBFbGVtZW50VG9UYWc8ST47XHJcbiAgICAgICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxJTD47XHJcbiAgICB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYVJhZGlvR3JvdXA8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgRyBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgR0wgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBJTCBleHRlbmRzIEhUTUxFbGVtZW50LCBJbmZvIGV4dGVuZHMgVXNlQXJpYVJhZGlvSW5mb0Jhc2U+KHsgbmFtZSwgc2VsZWN0ZWRWYWx1ZSwgb25JbnB1dCwgdGFnR3JvdXAsIHRhZ0dyb3VwTGFiZWwsIGluaXRpYWxJbmRleCwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG9jbWMsIGNvbGxhdG9yLCBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIG5hdmlnYXRpb25EaXJlY3Rpb24sIG5vVHlwZWFoZWFkLCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIsIG9uVGFiYmVkSW5Ubywgb25UYWJiZWRPdXRPZiwgdHlwZWFoZWFkVGltZW91dCB9OiBVc2VBcmlhUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgRywgR0wsIEksIElMLCBzdHJpbmcsIEluZm8+KSB7XHJcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldFJhZGlvR3JvdXBQYXJlbnRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8Rz4oe30pO1xyXG5cclxuICAgIC8vY29uc3QgZ2V0U2VsZWN0ZWRJbmRleCA9IHVzZUNhbGxiYWNrKChzZWxlY3RlZFZhbHVlOiBWKSA9PiB7IHJldHVybiBieU5hbWUuY3VycmVudC5nZXQoc2VsZWN0ZWRWYWx1ZSkgPz8gMCB9LCBbXSlcclxuXHJcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPigwKTtcclxuICAgIGNvbnN0IGJ5TmFtZSA9IHVzZVJlZihuZXcgTWFwPFYsIGFueT4oKSk7XHJcbiAgICBjb25zdCBzdGFibGVPbklucHV0ID0gdXNlU3RhYmxlQ2FsbGJhY2sob25JbnB1dCk7XHJcblxyXG4gICAgLy9jb25zdCBbYW55UmFkaW9zRm9jdXNlZCwgc2V0QW55UmFkaW9zRm9jdXNlZCwgZ2V0QW55UmFkaW9zRm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0OiB1c2VHcm91cExhYmVsSW5wdXQsIHVzZUxhYmVsTGFiZWw6IHVzZUdyb3VwTGFiZWxMYWJlbCB9ID0gdXNlTGFiZWw8RywgR0w+KHsgbGFiZWxQcmVmaXg6IFwiYXJpYS1yYWRpby1ncm91cC1sYWJlbC1cIiwgdGFnSW5wdXQ6IHRhZ0dyb3VwIGFzIG5ldmVyLCB0YWdMYWJlbDogdGFnR3JvdXBMYWJlbCBhcyBuZXZlciwgaW5wdXRQcmVmaXg6IFwiYXJpYS1yYWRpby1ncm91cC1cIiB9KVxyXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHM6IHVzZUdyb3VwTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VHcm91cExhYmVsSW5wdXQoKTtcclxuICAgIGNvbnN0IHsgdXNlTGFiZWxMYWJlbFByb3BzOiB1c2VHcm91cExhYmVsTGFiZWxQcm9wcyB9ID0gdXNlR3JvdXBMYWJlbExhYmVsKCk7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcclxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxyXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgZ2V0VGFiYmFibGVJbmRleCxcclxuICAgICAgICBzZXRUYWJiYWJsZUluZGV4XHJcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248RywgSSwgc3RyaW5nLCBJbmZvPih7XHJcbiAgICAgICAgc2VsZWN0ZWRJbmRleCxcclxuICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXHJcbiAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb2NtYz4+KChtLCB1KSA9PiB7IG9jbWM/LihtLCB1KTsgfSksXHJcbiAgICAgICAgY29sbGF0b3IsXHJcbiAgICAgICAgZGlzYWJsZUFycm93S2V5cyxcclxuICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICAgICAgaW5kZXhEZW1hbmdsZXIsXHJcbiAgICAgICAgaW5kZXhNYW5nbGVyLFxyXG4gICAgICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXHJcbiAgICAgICAgbm9UeXBlYWhlYWQsXHJcbiAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxyXG4gICAgICAgIG9uVGFiYmFibGVSZW5kZXIsXHJcbiAgICAgICAgb25UYWJiZWRJblRvLFxyXG4gICAgICAgIG9uVGFiYmVkT3V0T2YsXHJcbiAgICAgICAgdHlwZWFoZWFkVGltZW91dFxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVHJhY2sgd2hldGhlciB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHRoZSByYWRpbyBncm91cCBwYXJlbnQgZWxlbWVudC5cclxuICAgIC8vIFdoZW4gaXQncyBub3QsIHdlIHJlc2V0IHRoZSB0YWJiYWJsZSBpbmRleCBiYWNrIHRvIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZWxlbWVudC5cclxuICAgIC8vY29uc3QgeyB1c2VBY3RpdmVFbGVtZW50UHJvcHMgfSA9IHVzZUFjdGl2ZUVsZW1lbnQ8Rz4oeyBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChhY3RpdmVFbGVtZW50OiBOb2RlIHwgbnVsbCkgPT4gc2V0QW55UmFkaW9zRm9jdXNlZCghIShnZXRSYWRpb0dyb3VwUGFyZW50RWxlbWVudCgpPy5jb250YWlucyhhY3RpdmVFbGVtZW50KSkpLCBbXSkgfSk7XHJcbiAgICAvKnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFhbnlSYWRpb3NGb2N1c2VkKVxyXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoc2VsZWN0ZWRJbmRleCA/PyAwKTtcclxuICAgIH0sIFthbnlSYWRpb3NGb2N1c2VkLCBzZWxlY3RlZEluZGV4LCBuYXZpZ2F0ZVRvSW5kZXhdKTsqL1xyXG5cclxuXHJcbiAgICBjb25zdCB1c2VSYWRpb0dyb3VwUHJvcHMgPSB1c2VDYWxsYmFjaygoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxHPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEc+ID0+IHtcclxuICAgICAgICBwcm9wcy5yb2xlID0gXCJyYWRpb2dyb3VwXCI7XHJcbiAgICAgICAgcmV0dXJuIHVzZUdyb3VwTGFiZWxJbnB1dFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHModXNlUmVmRWxlbWVudFByb3BzKHByb3BzKSkpO1xyXG4gICAgfSwgW3VzZVJlZkVsZW1lbnRQcm9wc10pXHJcblxyXG4gICAgY29uc3QgdXNlUmFkaW9Hcm91cExhYmVsUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdMPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdMPiA9PiB7IHJldHVybiB1c2VHcm91cExhYmVsTGFiZWxQcm9wcyhwcm9wcyk7IH0sIFt1c2VHcm91cExhYmVsTGFiZWxQcm9wc10pO1xyXG5cclxuICAgIC8vY29uc3QgY29ycmVjdGVkSW5kZXggPSAoc2VsZWN0ZWRJbmRleCA9PSBudWxsIHx8IHNlbGVjdGVkSW5kZXggPCAwIHx8IHNlbGVjdGVkSW5kZXggPj0gbWFuYWdlZENoaWxkcmVuLmxlbmd0aCkgPyBudWxsIDogc2VsZWN0ZWRJbmRleDtcclxuICAgIC8qY29uc3QgeyBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSA9IHVzZUNoaWxkcmVuRmxhZyh7XHJcbiAgICAgICAgaW5pdGlhbEluZGV4OiAwLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGtleTogXCJzZWxlY3RlZFwiXHJcbiAgICAgICAgLy9zZXRDaGlsZEZsYWc6IChpLCBjaGVja2VkKSA9PiBtYW5hZ2VkQ2hpbGRyZW5baV0/LnNldENoZWNrZWQoY2hlY2tlZCksXHJcbiAgICAgICAgLy9nZXRDaGlsZEZsYWc6ICgoaSkgPT4gbWFuYWdlZENoaWxkcmVuW2ldPy5nZXRDaGVja2VkKCkgPz8gZmFsc2UpXHJcbiAgICB9KTsqL1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IGJ5TmFtZS5jdXJyZW50LmdldChzZWxlY3RlZFZhbHVlKTtcclxuICAgICAgICBzZXRTZWxlY3RlZEluZGV4KHNlbGVjdGVkSW5kZXggPz8gbnVsbCk7XHJcbiAgICB9LCBbYnlOYW1lLCBzZWxlY3RlZFZhbHVlXSk7XHJcblxyXG5cclxuXHJcbiAgICBjb25zdCB1c2VSYWRpbzogVXNlUmFkaW88ViwgSSwgSUwsIEluZm8+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQXJpYVJhZGlvKHsgaW5mbzogeyBpbmRleCwgdGV4dCB9LCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgdmFsdWUsIHRhZ0lucHV0LCB0YWdMYWJlbCwgLi4ucmVzdCB9OiBVc2VBcmlhUmFkaW9QYXJhbWV0ZXJzPFYsIEksIElMLCBJbmZvPikge1xyXG5cclxuICAgICAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZCwgZ2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZTxib29sZWFuIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9uSW5wdXQgPSB1c2VDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxJPiB8IGguSlNYLlRhcmdldGVkRXZlbnQ8SUw+KSA9PiB7XHJcbiAgICAgICAgICAgIHN0YWJsZU9uSW5wdXQoZW5oYW5jZUV2ZW50KGUgYXMgYW55LCB7IHNlbGVjdGVkVmFsdWU6IHZhbHVlIH0pKTtcclxuICAgICAgICB9LCBbc3RhYmxlT25JbnB1dCwgdmFsdWUsIGluZGV4XSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQgfSA9IHVzZUNoZWNrYm94TGlrZTxJLCBJTD4oeyBjaGVja2VkOiAoY2hlY2tlZCA/PyBmYWxzZSksIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCBvbklucHV0LCByb2xlOiBcInJhZGlvXCIsIHRhZ0lucHV0OiB0YWdJbnB1dCBhcyBuZXZlciwgdGFnTGFiZWw6IHRhZ0xhYmVsIGFzIG5ldmVyIH0pO1xyXG5cclxuXHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgYnlOYW1lLmN1cnJlbnQuc2V0KHZhbHVlLCBpbmRleCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7IGJ5TmFtZS5jdXJyZW50LmRlbGV0ZSh2YWx1ZSk7IH1cclxuICAgICAgICB9LCBbYnlOYW1lLCB2YWx1ZSwgaW5kZXhdKTtcclxuXHJcbiAgICAgICAgY29uc3QgeyB0YWJiYWJsZSwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzIH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkKHsgaW5mbzogeyBpbmRleCwgc2V0Q2hlY2tlZCwgZ2V0Q2hlY2tlZCwgdGV4dCwgLi4ucmVzdCB9IGFzIGFueSBhcyBJbmZvIH0pO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VSYWRpb0lucHV0OiBVc2VSYWRpb0lucHV0PEk+ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YWcgPSB0YWdJbnB1dDtcclxuICAgICAgICAgICAgY29uc3QgdXNlUmFkaW9JbnB1dFByb3BzID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0YWcgPT0gXCJpbnB1dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCA9IChjaGVja2VkID8/IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy50eXBlID0gXCJyYWRpb1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWNoZWNrZWRcIl0gPSAoY2hlY2tlZCA/PyBmYWxzZSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc0lmSW5wdXRIYW5kbGVzRm9jdXMgPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMocHJvcHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh1c2VNZXJnZWRQcm9wczxJPigodXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMoe30pKSwgbGFiZWxQb3NpdGlvbiA9PSBcInNlcGFyYXRlXCIgPyBwcm9wc0lmSW5wdXRIYW5kbGVzRm9jdXMgOiBwcm9wcykpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVzZVJhZGlvSW5wdXRQcm9wc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlUmFkaW9MYWJlbDogVXNlUmFkaW9MYWJlbDxJTD4gPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRhZ0xhYmVsO1xyXG4gICAgICAgICAgICBjb25zdCB1c2VSYWRpb0xhYmVsUHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElMPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElMPiA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzSWZMYWJlbEhhbmRsZXNGb2N1cyA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcyBhcyBhbnkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzPElMPih7fSBhcyBhbnksIGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiID8gcHJvcHNJZkxhYmVsSGFuZGxlc0ZvY3VzIGFzIGFueSA6IHByb3BzIGFzIGFueSkpXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdXNlUmFkaW9MYWJlbFByb3BzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50XSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZVJhZGlvSW5wdXQsXHJcbiAgICAgICAgICAgIHVzZVJhZGlvTGFiZWwsXHJcbiAgICAgICAgICAgIGNoZWNrZWQ6IGNoZWNrZWQgPz8gZmFsc2UsXHJcbiAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSA/PyBmYWxzZVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LCBbYnlOYW1lLCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VSYWRpbyxcclxuICAgICAgICB1c2VSYWRpb0dyb3VwUHJvcHMsXHJcbiAgICAgICAgdXNlUmFkaW9Hcm91cExhYmVsUHJvcHMsXHJcbiAgICAgICAgc2VsZWN0ZWRJbmRleCxcclxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxyXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQsXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFkaW9SZXR1cm5UeXBlPEkgZXh0ZW5kcyBFbGVtZW50LCBMIGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgdXNlUmFkaW9JbnB1dDogVXNlUmFkaW9JbnB1dDxJPjtcclxuICAgIHVzZVJhZGlvTGFiZWw6IFVzZVJhZGlvTGFiZWw8TD47XHJcbiAgICBjaGVja2VkOiBib29sZWFuO1xyXG4gICAgdGFiYmFibGU6IGJvb2xlYW47XHJcbn1cclxuXHJcbnR5cGUgVXNlUmFkaW9JbnB1dDxJIGV4dGVuZHMgRWxlbWVudD4gPSAoeyB0YWcgfTogVGFnU2Vuc2l0aXZlUHJvcHM8ST4pID0+IHsgdXNlUmFkaW9JbnB1dFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJPjsgfVxyXG50eXBlIFVzZVJhZGlvTGFiZWw8TCBleHRlbmRzIEVsZW1lbnQ+ID0gKHsgdGFnIH06IFRhZ1NlbnNpdGl2ZVByb3BzPEw+KSA9PiB7IHVzZVJhZGlvTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TD47IH1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZVJhZGlvPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEkgZXh0ZW5kcyBFbGVtZW50LCBMIGV4dGVuZHMgRWxlbWVudCwgSW5mbyBleHRlbmRzIFVzZUFyaWFSYWRpb0luZm9CYXNlPiA9IChhOiBVc2VBcmlhUmFkaW9QYXJhbWV0ZXJzPFYsIEksIEwsIEluZm8+KSA9PiBVc2VSYWRpb1JldHVyblR5cGU8SSwgTD5cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCwgdXNlTGF5b3V0RWZmZWN0LCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgTWFuYWdlZENoaWxkSW5mb0Jhc2UgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtY2hpbGQtbWFuYWdlclwiO1xyXG5pbXBvcnQgeyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkluZm9CYXNlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxpc3QtbmF2aWdhdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VQcmVzc0V2ZW50SGFuZGxlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgVGFic0NoYW5nZUV2ZW50PEUgZXh0ZW5kcyBFbGVtZW50PiA9IHsgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfSB9ICYgUGljazxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+LCBcInRhcmdldFwiIHwgXCJjdXJyZW50VGFyZ2V0XCI+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFic1BhcmFtZXRlcnM8SyBleHRlbmRzIHN0cmluZyA9IHN0cmluZywgSSBleHRlbmRzIFVzZVRhYkluZm88Sz4gPSBVc2VUYWJJbmZvPEs+PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxLLCBJPiB7XHJcbiAgICBzZWxlY3RlZEluZGV4OiBudW1iZXIgfCBudWxsO1xyXG4gICAgb25TZWxlY3QoZXZlbnQ6IFRhYnNDaGFuZ2VFdmVudDxFbGVtZW50Pik6IHZvaWQ7XHJcbiAgICBzZWxlY3Rpb25Nb2RlOiBcImZvY3VzXCIgfCBcImFjdGl2YXRlXCI7XHJcbiAgICBvcmllbnRhdGlvbjogXCJpbmxpbmVcIiB8IFwiYmxvY2tcIjtcclxufVxyXG5cclxudHlwZSBPbWl0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFBpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj47XHJcbi8vZXhwb3J0IHR5cGUgVXNlVGFiUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudCwgSSBleHRlbmRzIFVzZVRhYlNldEl0ZW1JbmZvPEU+PiA9IE9taXQ8SSwgbmV2ZXI+O1xyXG5cclxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlBhbmVsUGFyYW1ldGVyczIgZXh0ZW5kcyBPbWl0PFVzZVRhYlBhbmVsSW5mbzIsIFwiZm9jdXNcIiB8IFwic2V0VmlzaWJsZVwiIHwgXCJnZXRWaXNpYmxlXCI+IHsgfVxyXG5cclxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZVRhYkluZm8gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbyB7XHJcbi8vc2V0U2VsZWN0ZWQoc2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkO1xyXG4vL2dldFNlbGVjdGVkKCk6IGJvb2xlYW4gfCBudWxsO1xyXG5cclxuLy90YWJJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4vL3NldFRhYlBhbmVsSWQodGFiSWQ6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHZvaWQ7XHJcbi8vc2V0U2VsZWN0aW9uTW9kZShtb2RlOiBcImZvY3VzXCIgfCBcImFjdGl2YXRlXCIpOiB2b2lkO1xyXG4vL31cclxuXHJcbmludGVyZmFjZSBVc2VUYWJQYW5lbEluZm8yIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mb0Jhc2U8bnVtYmVyPiB7XHJcbiAgICBzZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgZ2V0VmlzaWJsZSgpOiBib29sZWFuIHwgbnVsbDtcclxuICAgIC8vdGFiUGFuZWxJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgLy9zZXRUYWJJZCh0YWJJZDogc3RyaW5nIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuICAgIGZvY3VzKCk6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiSW5mbzxLIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uSW5mb0Jhc2U8Sz4ge1xyXG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xyXG4gICAgc2V0Q29ycmVzcG9uZGluZ1BhbmVsSWQocGFuZWxJZDogc3RyaW5nKTogdm9pZDtcclxuICAgIC8vZ2V0RWxlbWVudCgpOiBFO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlBhbmVsSW5mbyBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm9CYXNlPG51bWJlcj4ge1xyXG4gICAgc2V0Q29ycmVzcG9uZGluZ1RhYklkKHRhZ0lkOiBzdHJpbmcpOiB2b2lkO1xyXG4gICAgc2V0VmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKTogdm9pZDtcclxufVxyXG5cclxuLypcclxuZXhwb3J0IHR5cGUgVXNlVGFiU2V0PFRhYkVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEkgZXh0ZW5kcyBVc2VUYWJTZXRJdGVtSW5mbzxUYWJFbGVtZW50Pj4gPSAoaW5mbzogSSkgPT4ge1xyXG4gICAgdXNlVGFiUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkVsZW1lbnQ+O1xyXG4gICAgdXNlUGFuZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJQYW5lbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJQYW5lbEVsZW1lbnQ+O1xyXG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW47XHJcbiAgICB0YWJiYWJsZTogYm9vbGVhbjtcclxuICAgIGdldFNlbGVjdGVkOiAoKSA9PiBib29sZWFuO1xyXG59Ki9cclxuXHJcbi8vZXhwb3J0IHR5cGUgVXNlVGFic0xpc3QyPFRhYkxpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZVRhYkxpc3RQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJMaXN0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkxpc3RFbGVtZW50PjsgfVxyXG4vL2V4cG9ydCB0eXBlIFVzZVRhYnNMYWJlbDIgPSA8RSBleHRlbmRzIEVsZW1lbnQ+KCkgPT4geyB1c2VUYWJzTGFiZWxQcm9wczogPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4oeyAuLi5wcm9wcyB9OiBQKSA9PiBVc2VSYW5kb21JZFByb3BzUmV0dXJuVHlwZTxQPjsgfVxyXG4vL2V4cG9ydCB0eXBlIFVzZVRhYjI8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEkgZXh0ZW5kcyBVc2VUYWJJbmZvPiA9IChpbmZvOiBVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIEk+KSA9PiB7IHNlbGVjdGVkOiBib29sZWFuIHwgbnVsbDsgdXNlVGFiUHJvcHM6ICh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJFbGVtZW50PjsgfVxyXG4vL2V4cG9ydCB0eXBlIFVzZVRhYlBhbmVsMjxQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChpbmZvOiBVc2VUYWJQYW5lbFBhcmFtZXRlcnMyKSA9PiB7IHZpc2libGU6IGJvb2xlYW4gfCBudWxsLCB1c2VUYWJQYW5lbFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFuZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFuZWxFbGVtZW50PiB9XHJcbmV4cG9ydCB0eXBlIFVzZVRhYjxUYWJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50PiA9ICh7IC4uLmluZm8gfTogT21pdDxVc2VUYWJJbmZvLCBcInNldENvcnJlc3BvbmRpbmdQYW5lbElkXCI+KSA9PiB7XHJcbiAgICBnZXRFbGVtZW50OiAoKSA9PiBUYWJFbGVtZW50IHwgbnVsbDtcclxuICAgIGdldFNlbGVjdGVkOiAoKSA9PiBib29sZWFuO1xyXG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW47XHJcbiAgICB0YWJiYWJsZTogYm9vbGVhbjtcclxuICAgIHVzZVRhYlByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJFbGVtZW50PjtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFVzZVRhYlBhbmVsPFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKHsgLi4uaW5mbyB9OiBPbWl0PFVzZVRhYlBhbmVsSW5mbywgXCJzZXRDb3JyZXNwb25kaW5nVGFiSWRcIiB8IFwic2V0VmlzaWJsZVwiPikgPT4ge1xyXG4gICAgdmlzaWJsZTogYm9vbGVhbjtcclxuICAgIHVzZVRhYlBhbmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiUGFuZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiUGFuZWxFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFUYWJzPExpc3RFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEsgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmcsIEkgZXh0ZW5kcyBVc2VUYWJJbmZvPEs+ID0gVXNlVGFiSW5mbzxLPj4oeyBzZWxlY3Rpb25Nb2RlLCBzZWxlY3RlZEluZGV4LCBvblNlbGVjdCwgb3JpZW50YXRpb246IGxvZ2ljYWxPcmllbnRhdGlvbiwgY29sbGF0b3IsIGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgaW5pdGlhbEluZGV4LCBuYXZpZ2F0aW9uRGlyZWN0aW9uLCBub1R5cGVhaGVhZCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlLCBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IG90aWMsIHR5cGVhaGVhZFRpbWVvdXQsIC4uLmFyZ3MgfTogVXNlQXJpYVRhYnNQYXJhbWV0ZXJzPEssIEk+KSB7XHJcbiAgICBzZWxlY3Rpb25Nb2RlID8/PSBcImZvY3VzXCI7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIGNoaWxkcmVuOiB0YWJzLFxyXG4gICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXHJcbiAgICAgICAgZm9jdXNTZWxmLFxyXG4gICAgICAgIGdldFRhYmJhYmxlSW5kZXgsXHJcbiAgICAgICAgc2V0VGFiYmFibGVJbmRleCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHNcclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxMaXN0RWxlbWVudCwgVGFiRWxlbWVudCwgc3RyaW5nLCBVc2VUYWJJbmZvPih7XHJcbiAgICAgICAgc2VsZWN0ZWRJbmRleCxcclxuICAgICAgICBjb2xsYXRvcixcclxuICAgICAgICBkaXNhYmxlQXJyb3dLZXlzLFxyXG4gICAgICAgIGRpc2FibGVIb21lRW5kS2V5cyxcclxuICAgICAgICBpbmRleERlbWFuZ2xlcixcclxuICAgICAgICBpbmRleE1hbmdsZXIsXHJcbiAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcclxuICAgICAgICBub1R5cGVhaGVhZCxcclxuICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXHJcbiAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb3RpYz4+KChpKSA9PiB7XHJcbiAgICAgICAgICAgIG90aWM/LihpKTtcclxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk1vZGUgPT0gXCJmb2N1c1wiKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YWJzLmdldEF0KGkhKT8uZ2V0RWxlbWVudCgpITtcclxuICAgICAgICAgICAgICAgIG9uU2VsZWN0Py4oeyB0YXJnZXQsIGN1cnJlbnRUYXJnZXQ6IHRhcmdldCwgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBpISB9IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgdHlwZWFoZWFkVGltZW91dCxcclxuICAgICAgICAuLi5hcmdzXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IGNoaWxkcmVuOiBwYW5lbHMsIHVzZU1hbmFnZWRDaGlsZDogdXNlTWFuYWdlZFBhbmVsIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48VXNlVGFiUGFuZWxJbmZvPih7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0pXHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlTGFiZWxJZFNvdXJjZUVsZW1lbnQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUxhYmVsSWRSZWZlcmVuY2VyRWxlbWVudCB9ID0gdXNlUmFuZG9tSWQ8TGFiZWxFbGVtZW50Pih7IHByZWZpeDogXCJ0YWJzLWxhYmVsLVwiLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9KTtcclxuICAgIC8vY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZUxpc3RJZFNvdXJjZUVsZW1lbnQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUxpc3RJZFJlZmVyZW5jZXJFbGVtZW50IH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJ0YWJzLWxpc3QtXCIgfSk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VMYWJlbElkU291cmNlRWxlbWVudFByb3BzIH0gPSB1c2VMYWJlbElkU291cmNlRWxlbWVudCgpO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUxhYmVsSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIH0gPSB1c2VMYWJlbElkUmVmZXJlbmNlckVsZW1lbnQ8TGlzdEVsZW1lbnQ+KFwibGFiZWxsZWQtYnlcIiBhcyBuZXZlcik7XHJcbiAgICAvL2NvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZUxpc3RJZFNvdXJjZUVsZW1lbnRQcm9wcyB9ID0gdXNlTGlzdElkU291cmNlRWxlbWVudCgpO1xyXG4gICAgLy9jb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlTGlzdElkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlTGlzdElkUmVmZXJlbmNlckVsZW1lbnQoXCJsYWJlbGxlZC1ieVwiIGFzIG5ldmVyKTtcclxuICAgIGNvbnN0IHVzZVRhYnNMYWJlbFByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiA9PiB7IHJldHVybiB1c2VMYWJlbElkU291cmNlRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzPExhYmVsRWxlbWVudD4oe30sIHByb3BzKSkgfSwgW10pO1xyXG4gICAgY29uc3QgdXNlVGFic0xpc3RQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+ID0+IHsgcmV0dXJuIHVzZUxhYmVsSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHModXNlTWVyZ2VkUHJvcHM8TGlzdEVsZW1lbnQ+KHsgcm9sZTogXCJ0YWJsaXN0XCIgfSwgcHJvcHMpKSkgfSwgW10pO1xyXG4gICAgLypjb25zdCB1c2VUYWJTZXQ6IFVzZVRhYlNldDxUYWJFbGVtZW50LCBUYWJQYW5lbEVsZW1lbnQsIEk+ID0gdXNlQ2FsbGJhY2soKGluZm86IEkpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlVGFiSWRTb3VyY2VFbGVtZW50LCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VUYWJJZFJlZmVyZW5jZXJFbGVtZW50IH0gPSB1c2VSYW5kb21JZDxUYWJFbGVtZW50Pih7IHByZWZpeDogXCJ0YWItXCIgfSk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZVRhYlBhbmVsSWRTb3VyY2VFbGVtZW50LCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VUYWJQYW5lbElkUmVmZXJlbmNlckVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkPFRhYlBhbmVsRWxlbWVudD4oeyBwcmVmaXg6IFwidGFiLXBhbmVsLVwiIH0pO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZVRhYklkU291cmNlRWxlbWVudFByb3BzIH0gPSB1c2VUYWJJZFNvdXJjZUVsZW1lbnQoKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlVGFiSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIH0gPSB1c2VUYWJJZFJlZmVyZW5jZXJFbGVtZW50PFRhYlBhbmVsRWxlbWVudD4oXCJsYWJlbGxlZC1ieVwiIGFzIG5ldmVyKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VUYWJQYW5lbElkU291cmNlRWxlbWVudFByb3BzIH0gPSB1c2VUYWJQYW5lbElkU291cmNlRWxlbWVudCgpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VUYWJQYW5lbElkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlVGFiUGFuZWxJZFJlZmVyZW5jZXJFbGVtZW50PFRhYkVsZW1lbnQ+KFwiYXJpYS1jb250cm9sc1wiIGFzIG5ldmVyKTtcclxuICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQsIGdldFNlbGVjdGVkLCBzZWxlY3RlZCwgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZChpbmZvKTtcclxuICAgICAgICBjb25zdCB1c2VUYWJQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJFbGVtZW50PiA9PiB7IHJldHVybiB1c2VUYWJJZFNvdXJjZUVsZW1lbnRQcm9wcyh1c2VUYWJQYW5lbElkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlTWVyZ2VkUHJvcHM8VGFiRWxlbWVudD4oeyByb2xlOiBcInRhYlwiIH0sIHByb3BzKSkpKSB9LCBbXSk7XHJcbiAgICAgICAgY29uc3QgdXNlUGFuZWxQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiUGFuZWxFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYlBhbmVsRWxlbWVudD4gPT4geyByZXR1cm4gdXNlVGFiUGFuZWxJZFNvdXJjZUVsZW1lbnRQcm9wcyh1c2VUYWJJZFJlZmVyZW5jZXJFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHM8VGFiUGFuZWxFbGVtZW50Pih7IHJvbGU6IFwidGFicGFuZWxcIiB9LCBwcm9wcykpKSB9LCBbXSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZVRhYlByb3BzLFxyXG4gICAgICAgICAgICB1c2VQYW5lbFByb3BzLFxyXG4gICAgICAgICAgICBzZWxlY3RlZCxcclxuICAgICAgICAgICAgdGFiYmFibGUsXHJcbiAgICAgICAgICAgIGdldFNlbGVjdGVkXHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pOyovXHJcblxyXG4gICAgY29uc3QgdXNlVGFiOiBVc2VUYWI8VGFiRWxlbWVudD4gPSB1c2VDYWxsYmFjaygoeyAuLi5pbmZvIH06IE9taXQ8VXNlVGFiSW5mbywgXCJzZXRDb3JyZXNwb25kaW5nUGFuZWxJZFwiPikgPT4ge1xyXG4gICAgICAgIGNvbnN0IFtjb3JyZXNwb25kaW5nUGFuZWxJZCwgc2V0Q29ycmVzcG9uZGluZ1BhbmVsSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgICAgICAgY29uc3QgW3JhbmRvbVRhYklkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoXCJ0YWItXCIpKTtcclxuICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQsIGdldFNlbGVjdGVkLCBzZWxlY3RlZCwgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCh7IGluZm86IHsgLi4uaW5mbywgc2V0Q29ycmVzcG9uZGluZ1BhbmVsSWQgfSB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJlc3NQcm9wcyA9IHVzZVByZXNzRXZlbnRIYW5kbGVycyhlID0+IHsgb25TZWxlY3QoeyAuLi4oZSBhcyBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8VGFiRWxlbWVudD4pLCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IGluZm8uaW5kZXggfSB9KTsgfSwge30pO1xyXG5cclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBwYW5lbHMuZ2V0QXQoaW5mby5pbmRleCk/LnNldFZpc2libGUoc2VsZWN0ZWQpO1xyXG4gICAgICAgIH0sIFtpbmZvLmluZGV4LCBzZWxlY3RlZF0pXHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdldEVsZW1lbnQsXHJcbiAgICAgICAgICAgIGdldFNlbGVjdGVkLFxyXG4gICAgICAgICAgICBzZWxlY3RlZCxcclxuICAgICAgICAgICAgdGFiYmFibGUsXHJcbiAgICAgICAgICAgIHVzZVRhYlByb3BzOiBmdW5jdGlvbiB1c2VUYWJQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJFbGVtZW50PiB7IHJldHVybiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlTWVyZ2VkUHJvcHM8VGFiRWxlbWVudD4oeyBcImFyaWEtY29udHJvbHNcIjogY29ycmVzcG9uZGluZ1BhbmVsSWQsIGlkOiByYW5kb21UYWJJZCwgLi4ucHJlc3NQcm9wcyB9IGFzIHt9LCBwcm9wcykpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG4gICAgY29uc3QgdXNlVGFiUGFuZWw6IFVzZVRhYlBhbmVsPFRhYlBhbmVsRWxlbWVudD4gPSB1c2VDYWxsYmFjaygoeyAuLi5pbmZvIH06IE9taXQ8VXNlVGFiUGFuZWxJbmZvLCBcInNldENvcnJlc3BvbmRpbmdUYWJJZFwiIHwgXCJzZXRWaXNpYmxlXCI+KSA9PiB7XHJcbiAgICAgICAgY29uc3QgW2NvcnJlc3BvbmRpbmdUYWJJZCwgc2V0Q29ycmVzcG9uZGluZ1RhYklkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gICAgICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgICAgICBjb25zdCBfOiB2b2lkID0gdXNlTWFuYWdlZFBhbmVsKHsgaW5mbzogeyAuLi5pbmZvLCBzZXRDb3JyZXNwb25kaW5nVGFiSWQsIHNldFZpc2libGUgfSB9KVxyXG4gICAgICAgIGNvbnN0IFtyYW5kb21QYW5lbElkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoXCJ0YWItcGFuZWwtXCIpKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2aXNpYmxlLFxyXG4gICAgICAgICAgICB1c2VUYWJQYW5lbFByb3BzOiBmdW5jdGlvbiB1c2VUYWJQYW5lbFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJQYW5lbEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiUGFuZWxFbGVtZW50PiB7IHJldHVybiB1c2VNZXJnZWRQcm9wczxUYWJQYW5lbEVsZW1lbnQ+KHsgXCJhcmlhLWxhYmVsbGVkYnlcIjogY29ycmVzcG9uZGluZ1RhYklkLCBpZDogcmFuZG9tUGFuZWxJZCB9IGFzIHt9LCBwcm9wcyk7IH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VUYWJzTGFiZWxQcm9wcyxcclxuICAgICAgICB1c2VUYWJzTGlzdFByb3BzLFxyXG4gICAgICAgIHVzZVRhYixcclxuICAgICAgICB1c2VUYWJQYW5lbCxcclxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxyXG4gICAgICAgIGZvY3VzU2VsZixcclxuICAgICAgICBnZXRUYWJiYWJsZUluZGV4LFxyXG4gICAgfVxyXG5cclxuICAgIC8qIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wczogdXNlVGFiTGlzdEhhc0ZvY3VzUHJvcHMsIGdldEZvY3VzZWRJbm5lcjogZ2V0VGFiTGlzdEZvY3VzZWRJbm5lciB9ID0gdXNlSGFzRm9jdXM8TGlzdEVsZW1lbnQ+KHt9KTtcclxuICAgICBjb25zdCBbcGh5c2ljYWxPcmllbnRhdGlvbiwgc2V0UGh5c2ljYWxPcmllbnRhdGlvbl0gPSB1c2VTdGF0ZTxcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIj4oXCJob3Jpem9udGFsXCIpO1xyXG4gICAgIGNvbnN0IHsgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbiwgdXNlTG9naWNhbERpcmVjdGlvblByb3BzIH0gPSB1c2VMb2dpY2FsRGlyZWN0aW9uPExpc3RFbGVtZW50Pih7IG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZTogdXNlQ2FsbGJhY2soKGxvZ2ljYWxEaXJlY3Rpb25JbmZvOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwpID0+IHNldFBoeXNpY2FsT3JpZW50YXRpb24oY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbihsb2dpY2FsT3JpZW50YXRpb24sIGxvZ2ljYWxEaXJlY3Rpb25JbmZvKSksIFtdKSB9KTtcclxuIFxyXG4gICAgIC8vY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VUYWJMaXN0SWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRUYWJMaXN0SWQgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtdGFiLWxpc3QtXCIgfSk7XHJcbiBcclxuICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlVGFiTGlzdElkLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VUYWJMaXN0SWRSZWZlcmVuY2VyIH0gPSB1c2VSYW5kb21JZDxMaXN0RWxlbWVudD4oeyBwcmVmaXg6IFwiYXJpYS10YWJzLWxhYmVsLVwiIH0pO1xyXG4gICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZVRhYkxpc3RJZFByb3BzIH0gPSB1c2VUYWJMaXN0SWQoKTtcclxuICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlVGFiTGlzdElkUmVmZXJlbmNlclByb3BzIH0gPSB1c2VUYWJMaXN0SWRSZWZlcmVuY2VyKFwiYXJpYS1sYWJlbGxlZGJ5XCIpO1xyXG4gXHJcbiAgICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRUYWJzLCBuYXZpZ2F0ZVRvSW5kZXgsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsIHRhYmJhYmxlSW5kZXgsIGludmFsaWRUeXBlYWhlYWQsIGN1cnJlbnRUeXBlYWhlYWQsIGZvY3VzQ3VycmVudCB9ID0gdXNlTGlzdE5hdmlnYXRpb248VGFiRWxlbWVudCwgVXNlVGFiSW5mbz4oeyAuLi5hcmdzLCBzaG91bGRGb2N1c09uQ2hhbmdlOiBnZXRUYWJMaXN0Rm9jdXNlZElubmVyLCBrZXlOYXZpZ2F0aW9uOiBsb2dpY2FsT3JpZW50YXRpb24gfSk7XHJcbiAgICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRQYW5lbHMsIHVzZU1hbmFnZWRDaGlsZDogdXNlTWFuYWdlZFRhYlBhbmVsIH0gPSB1c2VDaGlsZE1hbmFnZXI8VXNlVGFiUGFuZWxJbmZvMj4oKVxyXG4gXHJcbiAgICAgY29uc3QgY2hpbGRDb3VudCA9IG1hbmFnZWRUYWJzLmxlbmd0aDtcclxuIFxyXG4gXHJcbiAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkVGFicylcclxuICAgICAgICAgICAgIGNoaWxkLnNldFNlbGVjdGlvbk1vZGUoc2VsZWN0aW9uTW9kZSk7XHJcbiAgICAgfSwgW3NlbGVjdGlvbk1vZGVdKVxyXG4gXHJcbiBcclxuICAgICB1c2VDaGlsZEZsYWcoeyBhY3RpdmF0ZWRJbmRleDogc2VsZWN0ZWRJbmRleCwgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkVGFicywgc2V0Q2hpbGRGbGFnOiAoaSwgc2VsZWN0ZWQpID0+IG1hbmFnZWRUYWJzW2ldPy5zZXRTZWxlY3RlZChzZWxlY3RlZCksIGdldENoaWxkRmxhZzogaSA9PiAobWFuYWdlZFRhYnNbaV0/LmdldFNlbGVjdGVkKCkpIH0pO1xyXG4gICAgIHVzZUNoaWxkRmxhZyh7IGFjdGl2YXRlZEluZGV4OiBzZWxlY3RlZEluZGV4LCBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRQYW5lbHMsIHNldENoaWxkRmxhZzogKGksIHZpc2libGUpID0+IG1hbmFnZWRQYW5lbHNbaV0/LnNldFZpc2libGUodmlzaWJsZSksIGdldENoaWxkRmxhZzogaSA9PiAobWFuYWdlZFBhbmVsc1tpXT8uZ2V0VmlzaWJsZSgpKSB9KTtcclxuIFxyXG4gICAgIHVzZUxheW91dEVmZmVjdCgoX3ByZXYpID0+IHtcclxuICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCAmJiBzZWxlY3Rpb25Nb2RlID09IFwiYWN0aXZhdGVcIikge1xyXG4gICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB3YWl0IGEgbW9tZW50IHNvIHRoYXQgdGhlIHRhYiBwYW5lbCB3ZSB3YW50IHRvIGZvY3VzXHJcbiAgICAgICAgICAgICAvLyBpcyBhY3R1YWxseSB2aXNpYmxlIChpLmUuIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGNoaWxkIHRvIHJlLXJlbmRlciBpdHNlbGYpLlxyXG4gICAgICAgICAgICAgLy8gV2UgY291bGQsIGFsdGVybmF0aXZlbHksIHNpZ25hbCB0byB0aGUgY2hpbGQgdGhhdCBpdCBzaG91bGQgZm9jdXMgaXRzZWxmXHJcbiAgICAgICAgICAgICAvLyB0aGUgbmV4dCB0aW1lIGl0IHJlbmRlcnMgaXRzZWxmIGFzIHZpc2libGUsXHJcbiAgICAgICAgICAgICAvLyB3aGljaCBtaWdodCBiZSBiZXR0ZXI/XHJcbiAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgbWFuYWdlZFBhbmVsc1tzZWxlY3RlZEluZGV4XT8uZm9jdXMoKTtcclxuICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICB9XHJcbiAgICAgfSwgW2NoaWxkQ291bnQsIHNlbGVjdGVkSW5kZXgsIHNlbGVjdGlvbk1vZGVdKTtcclxuIFxyXG4gICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VMYWJlbElkRWxlbWVudCwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlTGFiZWxJZFJlZmVyZW5jZXIgfSA9IHVzZVJhbmRvbUlkPExhYmVsRWxlbWVudD4oeyBwcmVmaXg6IFwiYXJpYS10YWJzLWxhYmVsXCIgfSk7XHJcbiAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUxhYmVsSWRSZWZlcmVuY2VyUHJvcHMgfSA9IHVzZUxhYmVsSWRSZWZlcmVuY2VyPExpc3RFbGVtZW50PihcImFyaWEtbGFiZWxsZWRieVwiKTtcclxuIFxyXG4gICAgIGNvbnN0IHVzZVRhYlNldCA9IHVzZUNhbGxiYWNrKChpbmZvOiBVc2VUYWJTZXRQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIEk+KSA9PiB7XHJcbiBcclxuICAgICAgICAgY29uc3QgW3NlbGVjdGlvbk1vZGVMLCBzZXRTZWxlY3Rpb25Nb2RlTF0gPSB1c2VTdGF0ZTxcImZvY3VzXCIgfCBcImFjdGl2YXRlXCI+KHNlbGVjdGlvbk1vZGUpO1xyXG4gICAgICAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudDxUYWJFbGVtZW50Pih7fSlcclxuICAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZVRhYklkRWxlbWVudCwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlVGFiSWRSZWZlcmVuY2VyIH0gPSB1c2VSYW5kb21JZDxUYWJFbGVtZW50Pih7IHByZWZpeDogXCJhcmlhLXRhYi1cIiB9KTtcclxuICAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZVRhYlBhbmVsSWRFbGVtZW50LCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VUYWJQYW5lbElkUmVmZXJlbmNlciB9ID0gdXNlUmFuZG9tSWQ8VGFiUGFuZWxFbGVtZW50Pih7IHByZWZpeDogXCJhcmlhLXRhYi1wYW5lbFwiIH0pO1xyXG4gICAgICAgICBjb25zdCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkLCBnZXRTZWxlY3RlZF0gPSB1c2VTdGF0ZTxib29sZWFuIHwgbnVsbD4obnVsbCk7XHJcbiAgICAgICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7IHNldFNlbGVjdGVkLCBnZXRTZWxlY3RlZCwgc2V0U2VsZWN0aW9uTW9kZTogc2V0U2VsZWN0aW9uTW9kZUwsIC4uLmluZm8gfSk7XHJcbiAgICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZm8uaW5kZXgpO1xyXG4gXHJcbiAgICAgICAgIGNvbnN0IHVzZVRhYlByb3BzID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJFbGVtZW50PikgPT4ge1xyXG4gICAgICAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZVRhYlBhbmVsSWRSZWZlcmVuY2VyUHJvcHMgfSA9IHVzZVRhYklkUmVmZXJlbmNlcjxUYWJFbGVtZW50PihcImFyaWEtbGFiZWxsZWRieVwiKTtcclxuICAgICAgICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZVRhYklkUHJvcHMgfSA9IHVzZVRhYklkRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgY29uc3QgbmV3UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkVsZW1lbnQ+ID0gdXNlUHJlc3NFdmVudEhhbmRsZXJzPFRhYkVsZW1lbnQ+KChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGluZm8uaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgIG9uU2VsZWN0Py4oZW5oYW5jZUV2ZW50KGUsIHsgc2VsZWN0ZWRJbmRleDogZ2V0SW5kZXgoKSB9KSk7XHJcbiAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgfSwgdW5kZWZpbmVkKShwcm9wcyk7XHJcbiBcclxuICAgICAgICAgICAgIG5ld1Byb3BzLnJvbGUgPSBcInRhYlwiO1xyXG4gICAgICAgICAgICAgbmV3UHJvcHNbXCJhcmlhLXNlbGVjdGVkXCJdID0gKHNlbGVjdGVkID8/IGZhbHNlKS50b1N0cmluZygpO1xyXG4gXHJcbiAgICAgICAgICAgICByZXR1cm4gdXNlVGFiUGFuZWxJZFJlZmVyZW5jZXJQcm9wcyh1c2VUYWJJZFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VSZWZFbGVtZW50UHJvcHMobmV3UHJvcHMpKSkpO1xyXG4gICAgICAgICB9O1xyXG4gICAgICAgICBjb25zdCB1c2VUYWJQYW5lbFByb3BzID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJQYW5lbEVsZW1lbnQ+KSA9PiB7XHJcbiAgICAgICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlVGFiSWRSZWZlcmVuY2VyUHJvcHMgfSA9IHVzZVRhYklkUmVmZXJlbmNlcjxUYWJQYW5lbEVsZW1lbnQ+KFwiYXJpYS1jb250cm9sc1wiKTtcclxuICAgICAgICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZVRhYlBhbmVsSWRQcm9wcyB9ID0gdXNlVGFiUGFuZWxJZEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcInRhYnBhbmVsXCI7XHJcbiAgICAgICAgICAgICBwcm9wcy50YWJJbmRleCA/Pz0gLTE7ICAgICAgLy8gTWFrZSBzdXJlIHRoZSB0YWIgcGFuZWwgaXMgdGFiYmFibGUuXHJcbiAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8VGFiUGFuZWxFbGVtZW50Pih7fSwgdXNlVGFiSWRSZWZlcmVuY2VyUHJvcHModXNlVGFiUGFuZWxJZFByb3BzKHByb3BzKSkpO1xyXG4gICAgICAgICB9O1xyXG4gXHJcbiAgICAgICAgIHJldHVybiB7IHVzZVRhYlByb3BzLCB1c2VUYWJQYW5lbFByb3BzIH1cclxuICAgICB9LCBbXSk7XHJcbiBcclxuIFxyXG4gICAgIGNvbnN0IHVzZVRhYkxpc3RQcm9wcyA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KSA9PiB7XHJcbiAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcyh7IHJvbGU6IFwidGFibGlzdFwiIH0sIHVzZUxhYmVsSWRSZWZlcmVuY2VyUHJvcHMocHJvcHMpKTtcclxuICAgICB9O1xyXG4gXHJcbiBcclxuICAgICByZXR1cm4geyB1c2VUYWJTZXQsIHVzZVRhYkxpc3RQcm9wcywgdGFiYmFibGVJbmRleCwgZm9jdXNUYWJMaXN0OiBmb2N1c0N1cnJlbnQsIGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQsIG1hbmFnZWRQYW5lbHMsIG1hbmFnZWRUYWJzIH07Ki9cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlR2xvYmFsSGFuZGxlciwgdXNlSGFzRm9jdXMsIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVJhbmRvbUlkLCBVc2VSYW5kb21JZFByb3BzUmV0dXJuVHlwZSwgVXNlUmVmZXJlbmNlZElkUHJvcHNSZXR1cm5UeXBlLCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5cclxuZXhwb3J0IHR5cGUgVXNlVG9vbHRpcFRyaWdnZXI8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlVG9vbHRpcFRyaWdnZXJQcm9wczogKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4gfTtcclxuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sdGlwUGFyYW1ldGVycyB7IG1vdXNlb3ZlckRlbGF5PzogbnVtYmVyLCBtb3VzZW91dERlbGF5PzogbnVtYmVyLCBmb2N1c0RlbGF5PzogbnVtYmVyIH07XHJcbmV4cG9ydCB0eXBlIFVzZVRvb2x0aXA8VHJpZ2dlclR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIFRvb2x0aXBUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlVG9vbHRpcFBhcmFtZXRlcnMpID0+IFVzZVRvb2x0aXBSZXR1cm5UeXBlPFRyaWdnZXJUeXBlLCBUb29sdGlwVHlwZT47XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbHRpcFJldHVyblR5cGU8VHJpZ2dlclR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIFRvb2x0aXBUeXBlIGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgdXNlVG9vbHRpcDogKCkgPT4ge1xyXG4gICAgICAgIHVzZVRvb2x0aXBQcm9wczogKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VG9vbHRpcFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUb29sdGlwVHlwZT47XHJcbiAgICB9O1xyXG4gICAgdXNlVG9vbHRpcFRyaWdnZXI6IFVzZVRvb2x0aXBUcmlnZ2VyPFRyaWdnZXJUeXBlPjtcclxuICAgIGlzT3BlbjogYm9vbGVhbjtcclxuICAgIGdldElzT3BlbjogKCkgPT4gYm9vbGVhbjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFUb29sdGlwPFRyaWdnZXJUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBUb29sdGlwVHlwZSBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudD4oeyBtb3VzZW92ZXJEZWxheSwgbW91c2VvdXREZWxheSwgZm9jdXNEZWxheSB9OiBVc2VUb29sdGlwUGFyYW1ldGVycyk6IFVzZVRvb2x0aXBSZXR1cm5UeXBlPFRyaWdnZXJUeXBlLCBUb29sdGlwVHlwZT4ge1xyXG5cclxuICAgIG1vdXNlb3ZlckRlbGF5ID8/PSA0MDA7XHJcbiAgICBtb3VzZW91dERlbGF5ID8/PSA0MDtcclxuICAgIGZvY3VzRGVsYXkgPz89IDE7XHJcblxyXG4gICAgLy8gVGhlIGVzY2FwZSBrZXkgc2hvdWxkIGNsb3NlIHRvb2x0aXBzLCBidXQgZG8gbm90aGluZyBlbHNlLlxyXG4gICAgLy8gKGkuZS4gY2xvc2luZyBhIHRvb2x0aXAgaW4gYSBkaWFsb2cgTVVTVCBOT1QgY2xvc2UgdGhlIGRpYWxvZyB0b28pXHJcbiAgICAvLyBUT0RPOiBUb29sdGlwcyBhcmUsIGVmZmVjdGl2ZWx5LCBhbHdheXMgdGhlIHRvcG1vc3QgY29tcG9uZW50LFxyXG4gICAgLy8gc28gd2UgY2FuIGp1c3QgaGF2ZSB0aGVtIGxpc3RlbiB0byBhbmQgc3dhbGxvdyBhbGwgXCJFc2NhcGVcIlxyXG4gICAgLy8ga2V5IHByZXNzZXMgYmVmb3JlIGFueW9uZSBlbHNlLiBGb3IgYSBtb3JlIGdlbmVyYWwgcG9wdXAsXHJcbiAgICAvLyBvciBhIHRvb2x0aXAgaW4gYSB0b29sdGlwICghISkgYSBkaWZmZXJlbnQgc29sdXRpb24gd291bGQgYmUgbmVlZGVkLlxyXG4gICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJrZXlkb3duXCIsIChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKGdldE9wZW4oKSAmJiBlLmtleSA9PT0gXCJFc2NhcGVcIiAmJiAhZS5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgc2V0T3BlbihmYWxzZSk7XHJcbiAgICAgICAgICAgIHNldFRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkKGZhbHNlKTtcclxuICAgICAgICAgICAgc2V0VG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZhbHNlKTtcclxuICAgICAgICAgICAgc2V0VG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZChmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xyXG5cclxuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuLCBnZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50LC8vOiB1c2VUb29sdGlwSWRQcm9wcywgXHJcbiAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCwvLzogdXNlVG9vbHRpcElkUmVmZXJlbmNpbmdQcm9wcyBcclxuICAgIH0gPSB1c2VSYW5kb21JZDxUb29sdGlwVHlwZT4oeyBwcmVmaXg6IFwiYXJpYS10b29sdGlwLVwiLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9KTtcclxuXHJcbiAgICBjb25zdCBbLCBzZXRUcmlnZ2VyRm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICBjb25zdCBkZWxheSA9IGZvY3VzZWQgPyBmb2N1c0RlbGF5IDogMTtcclxuICAgICAgICBpZiAoZGVsYXkgIT0gbnVsbCAmJiBpc0Zpbml0ZShkZWxheSkpIHtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZvY3VzZWQpLCBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSksIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFssIHNldFRvb2x0aXBGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gZm9jdXNlZCA/IGZvY3VzRGVsYXkgOiAxO1xyXG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZm9jdXNlZCksIGRlbGF5KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBbLCBzZXRUcmlnZ2VySG92ZXJdID0gdXNlUGFzc2l2ZVN0YXRlKHVzZVN0YWJsZUNhbGxiYWNrKChob3ZlcmluZzogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gaG92ZXJpbmcgPyBtb3VzZW92ZXJEZWxheSA6IG1vdXNlb3V0RGVsYXk7XHJcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgJiYgaXNGaW5pdGUoZGVsYXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gc2V0VHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQoaG92ZXJpbmcpLCBkZWxheSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9KSwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgWywgc2V0VG9vbHRpcEhvdmVyXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VTdGFibGVDYWxsYmFjaygoaG92ZXJpbmc6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICBjb25zdCBkZWxheSA9IGhvdmVyaW5nID8gbW91c2VvdmVyRGVsYXkgOiBtb3VzZW91dERlbGF5O1xyXG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHNldFRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkKGhvdmVyaW5nKSwgZGVsYXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSksIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFt0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkLCBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFt0cmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZCwgc2V0VHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW3Rvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQsIHNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW3Rvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkLCBzZXRUb29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRPcGVuKHRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQgfHwgdHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCB8fCB0b29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZCk7XHJcbiAgICB9LCBbdHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCB8fCB0cmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZCB8fCB0b29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkIHx8IHRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkXSlcclxuXHJcbiAgICBjb25zdCB1c2VUb29sdGlwVHJpZ2dlcjogVXNlVG9vbHRpcFRyaWdnZXI8VHJpZ2dlclR5cGU+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVG9vbHRpcFRyaWdnZXIoKSB7XHJcblxyXG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwicG9pbnRlcm1vdmVcIiwgZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChlLnRhcmdldCBhcyBIVE1MRWxlbWVudCk7XHJcbiAgICAgICAgICAgIHNldFRyaWdnZXJIb3Zlcih0YXJnZXQgPT0gZ2V0RWxlbWVudCgpIGFzIE5vZGUgfHwgISFnZXRFbGVtZW50KCk/LmNvbnRhaW5zKHRhcmdldCkpO1xyXG4gICAgICAgIH0sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gb25Ub3VjaEVuZChlOiBUb3VjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgIChlLnRhcmdldCBhcyBhbnkpLmZvY3VzKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUhhc0ZvY3VzPFRyaWdnZXJUeXBlPih7IG9uRm9jdXNlZElubmVyQ2hhbmdlZDogc2V0VHJpZ2dlckZvY3VzZWQgfSlcclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDxUcmlnZ2VyVHlwZT4oXCJhcmlhLWRlc2NyaWJlZGJ5XCIgYXMgbmV2ZXIpO1xyXG4gICAgICAgICAgICAvLyBOb3RlOiBUaG91Z2ggaXQncyBpbXBvcnRhbnQgdG8gbWFrZSBzdXJlIHRoYXQgZm9jdXNpbmcgYWN0aXZhdGVzIGEgdG9vbHRpcCxcclxuICAgICAgICAgICAgLy8gaXQncyBwZXJmZWN0bHkgcmVhc29uYWJsZSB0aGF0IGEgY2hpbGQgZWxlbWVudCB3aWxsIGJlIHRoZSBvbmUgdGhhdCdzIGZvY3VzZWQsXHJcbiAgICAgICAgICAgIC8vIG5vdCB0aGlzIG9uZSwgc28gd2UgZG9uJ3Qgc2V0IHRhYkluZGV4PTBcclxuICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPz89IC0xO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKFxyXG4gICAgICAgICAgICAgICAgdXNlSGFzRm9jdXNQcm9wcyhcclxuICAgICAgICAgICAgICAgICAgICB1c2VNZXJnZWRQcm9wczxUcmlnZ2VyVHlwZT4oeyBvblRvdWNoRW5kIH0sIChwcm9wcyBhcyBhbnkpIGFzIHVua25vd24gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+KVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyB9O1xyXG5cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCB1c2VUb29sdGlwID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVG9vbHRpcCgpIHtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzIH0gPSB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQoKTtcclxuICAgICAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUhhc0ZvY3VzPFRvb2x0aXBUeXBlPih7IG9uRm9jdXNlZElubmVyQ2hhbmdlZDogc2V0VG9vbHRpcEZvY3VzZWQgfSlcclxuXHJcbiAgICAgICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJwb2ludGVybW92ZVwiLCBlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcclxuICAgICAgICAgICAgc2V0VG9vbHRpcEhvdmVyKHRhcmdldCA9PSBnZXRFbGVtZW50KCkgYXMgTm9kZSB8fCAhIWdldEVsZW1lbnQoKT8uY29udGFpbnModGFyZ2V0KSk7XHJcbiAgICAgICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VUb29sdGlwUHJvcHMoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxUb29sdGlwVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUb29sdGlwVHlwZT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHModXNlSGFzRm9jdXNQcm9wcyh1c2VNZXJnZWRQcm9wczxUb29sdGlwVHlwZT4oe30sIHByb3BzKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlVG9vbHRpcFByb3BzIH07XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VUb29sdGlwLFxyXG4gICAgICAgIHVzZVRvb2x0aXBUcmlnZ2VyLFxyXG4gICAgICAgIGlzT3Blbjogb3BlbixcclxuICAgICAgICBnZXRJc09wZW46IGdldE9wZW5cclxuICAgIH1cclxufVxyXG4iLCJcclxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgcmVuZGVyIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCwgdXNlRHJhZ2dhYmxlLCB1c2VEcm9wcGFibGUsIHVzZUZvY3VzVHJhcCwgdXNlSGFzRm9jdXMsIHVzZU1lcmdlZFByb3BzLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyBFdmVudERldGFpbCB9IGZyb20gXCIuLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VBcmlhQWNjb3JkaW9uLCBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbiB9IGZyb20gXCIuLi91c2UtYWNjb3JkaW9uXCI7XHJcbmltcG9ydCB7IHVzZUFyaWFDaGVja2JveCB9IGZyb20gXCIuLi91c2UtY2hlY2tib3hcIjtcclxuaW1wb3J0IHsgQ2hlY2tib3hHcm91cENoYW5nZUV2ZW50LCB1c2VDaGVja2JveEdyb3VwLCBVc2VDaGVja2JveEdyb3VwQ2hpbGQsIFVzZUNoZWNrYm94R3JvdXBDaGlsZEluZm9CYXNlIH0gZnJvbSBcIi4uL3VzZS1jaGVja2JveC1ncm91cFwiO1xyXG5pbXBvcnQgeyB1c2VBcmlhRGlhbG9nIH0gZnJvbSBcIi4uL3VzZS1kaWFsb2dcIjtcclxuaW1wb3J0IHsgdXNlQXJpYUxpc3Rib3hNdWx0aSwgVXNlTGlzdGJveE11bHRpSXRlbSB9IGZyb20gXCIuLi91c2UtbGlzdGJveC1tdWx0aVwiO1xyXG5pbXBvcnQgeyB1c2VBcmlhTGlzdGJveFNpbmdsZSwgVXNlTGlzdGJveFNpbmdsZUl0ZW0sIFVzZUxpc3Rib3hTaW5nbGVJdGVtSW5mbyB9IGZyb20gXCIuLi91c2UtbGlzdGJveC1zaW5nbGVcIjtcclxuaW1wb3J0IHsgdXNlQXJpYU1lbnUsIFVzZU1lbnVDaGlsZEluZm8sIFVzZU1lbnVJdGVtIH0gZnJvbSBcIi4uL3VzZS1tZW51XCI7XHJcbmltcG9ydCB7IHVzZUFyaWFSYWRpb0dyb3VwLCBVc2VBcmlhUmFkaW9JbmZvQmFzZSwgVXNlUmFkaW8gfSBmcm9tIFwiLi4vdXNlLXJhZGlvLWdyb3VwXCI7XHJcbmltcG9ydCB7IHVzZUFyaWFUYWJzLCBVc2VUYWIsIFVzZVRhYkluZm8sIFVzZVRhYlBhbmVsIH0gZnJvbSBcIi4uL3VzZS10YWJzXCI7XHJcbmltcG9ydCB7IHVzZUFyaWFUb29sdGlwIH0gZnJvbSBcIi4uL3VzZS10b29sdGlwXCI7XHJcblxyXG5jb25zdCBSYW5kb21Xb3JkcyA9IFwiTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLlwiLnNwbGl0KFwiIFwiKTtcclxuXHJcbnR5cGUgRSA9IChFdmVudFRhcmdldCAmIEhUTUxJbnB1dEVsZW1lbnQpO1xyXG50eXBlIEUyID0gRVtcImNsYXNzTmFtZVwiXVxyXG5cclxuXHJcbmNvbnN0IERlbW9Vc2VEcm9wcGFibGUgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB7IGRyb3BwZWRGaWxlcywgZHJvcHBlZFN0cmluZ3MsIGZpbGVzRm9yQ29uc2lkZXJhdGlvbiwgc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24sIHVzZURyb3BwYWJsZVByb3BzLCBkcm9wRXJyb3IgfSA9IHVzZURyb3BwYWJsZTxIVE1MRGl2RWxlbWVudD4oeyBlZmZlY3Q6IFwiY29weVwiIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgcmVmIH0gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50Pih7fSwgeyByZWY6IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsISkgfSlcclxuXHJcbiAgICBjb25zdCBwID0gdXNlRHJvcHBhYmxlUHJvcHMoeyBjbGFzc05hbWU6IFwiZGVtbyBkcm9wcGFibGVcIiB9KTtcclxuXHJcbiAgICBjb25zdCByID0gcC5yZWY7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHsuLi5wfT5cclxuXHJcbiAgICAgICAgICAgIHtkcm9wcGVkU3RyaW5ncyAhPSBudWxsICYmIDxkaXY+RGF0YSBkcm9wcGVkOiA8dWw+eyhPYmplY3QuZW50cmllcyhkcm9wcGVkU3RyaW5ncykgYXMgW2tleW9mIHR5cGVvZiBzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbiwgc3RyaW5nXVtdKS5tYXAoKFt0eXBlLCB2YWx1ZV0pID0+IDxsaT57dHlwZX06IHt2YWx1ZX08L2xpPil9PC91bD48L2Rpdj59XHJcbiAgICAgICAgICAgIHtkcm9wcGVkRmlsZXMgIT0gbnVsbCAmJiA8ZGl2PkZpbGVzIGRyb3BwZWQ6IDx0YWJsZT5cclxuICAgICAgICAgICAgICAgIDx0aGVhZD48dHI+PHRoPk5hbWU8L3RoPjx0aD5TaXplPC90aD48dGg+VHlwZTwvdGg+PHRoPkxhc3QgbW9kaWZpZWQ8L3RoPjwvdHI+PC90aGVhZD5cclxuICAgICAgICAgICAgICAgIDx0Ym9keT57ZHJvcHBlZEZpbGVzLm1hcChmID0+IDx0cj48dGQ+e2YubmFtZX08L3RkPntmLmRhdGEuYnl0ZUxlbmd0aH08dGQ+e2YudHlwZX08L3RkPjx0ZD57bmV3IERhdGUoZi5sYXN0TW9kaWZpZWQgPz8gMCl9PC90ZD48L3RyPil9PC90Ym9keT5cclxuICAgICAgICAgICAgPC90YWJsZT48L2Rpdj59XHJcbiAgICAgICAgICAgIDxociAvPlxyXG5cclxuICAgICAgICAgICAge3N0cmluZ3NGb3JDb25zaWRlcmF0aW9uICE9IG51bGwgJiYgPGRpdj5EYXRhIGJlaW5nIGNvbnNpZGVyZWQ6IDx1bD57QXJyYXkuZnJvbShzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbikubWFwKHR5cGUgPT4gPGxpPnt0eXBlfTwvbGk+KX08L3VsPjwvZGl2Pn1cclxuICAgICAgICAgICAge2ZpbGVzRm9yQ29uc2lkZXJhdGlvbiAhPSBudWxsICYmIDxkaXY+RmlsZXMgYmVpbmcgY29uc2lkZXJlZDogPHVsPntmaWxlc0ZvckNvbnNpZGVyYXRpb24ubWFwKGYgPT4gPGxpPntKU09OLnN0cmluZ2lmeShmKX08L2xpPil9PC91bD48L2Rpdj59XHJcblxyXG4gICAgICAgICAgICA8aHIgLz5cclxuICAgICAgICAgICAge2Ryb3BFcnJvciAmJiA8ZGl2Pntkcm9wRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGRyb3BFcnJvci5tZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkoZHJvcEVycm9yKX08L2Rpdj59XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApXHJcbn1cclxuXHJcbmNvbnN0IERlbW9Vc2VEcmFnZ2FibGUgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB7IGRyYWdnaW5nLCB1c2VEcmFnZ2FibGVQcm9wcywgbGFzdERyb3BFZmZlY3QsIGdldExhc3REcm9wRWZmZWN0LCBnZXREcmFnZ2luZyB9ID0gdXNlRHJhZ2dhYmxlPEhUTUxEaXZFbGVtZW50Pih7IGRhdGE6IHsgXCJ0ZXh0L3BsYWluXCI6IFwiVGhpcyBpcyBjdXN0b20gZHJhZ2dhYmxlIGNvbnRlbnQgb2YgdHlwZSB0ZXh0L3BsYWluLlwiIH0gfSk7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiB7Li4udXNlRHJhZ2dhYmxlUHJvcHMoeyBjbGFzc05hbWU6IFwiZGVtb1wiIH0pfT5cclxuICAgICAgICAgICAgRHJhZ2dhYmxlIGNvbnRlbnRcclxuICAgICAgICA8L2Rpdj4pXHJcbn1cclxuXHJcblxyXG5jb25zdCBEZW1vVXNlRm9jdXNUcmFwID0gbWVtbygoeyBkZXB0aCB9OiB7IGRlcHRoPzogbnVtYmVyIH0pID0+IHtcclxuXHJcbiAgICBjb25zdCBbYWN0aXZlLCBzZXRBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlRm9jdXNUcmFwUHJvcHMgfSA9IHVzZUZvY3VzVHJhcDxIVE1MRGl2RWxlbWVudD4oeyB0cmFwQWN0aXZlOiBhY3RpdmUgfSk7XHJcblxyXG4gICAgY29uc3QgZGl2UHJvcHMgPSB1c2VGb2N1c1RyYXBQcm9wcyh7IHJlZjogdW5kZWZpbmVkLCBjbGFzc05hbWU6IFwiZm9jdXMtdHJhcC1kZW1vXCIgfSk7XHJcbiAgICBpZiAoZGVwdGggPT0gMilcclxuICAgICAgICByZXR1cm4gPGRpdiAvPjtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVtb1wiPlxyXG4gICAgICAgICAgICA8bGFiZWw+QWN0aXZlOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17YWN0aXZlfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRBY3RpdmUoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpOyB9fSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxkaXYgey4uLmRpdlByb3BzfSA+XHJcbiAgICAgICAgICAgICAgICA8RGVtb1VzZUZvY3VzVHJhcENoaWxkIGFjdGl2ZT17YWN0aXZlfSBzZXRBY3RpdmU9e3NldEFjdGl2ZX0gZGVwdGg9e2RlcHRoID8/IDB9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5cclxuY29uc3QgRGVtb1VzZUZvY3VzVHJhcENoaWxkID0gbWVtbygoeyBzZXRBY3RpdmUsIGFjdGl2ZSwgZGVwdGggfTogeyBhY3RpdmU6IGJvb2xlYW4sIHNldEFjdGl2ZTogKGFjdGl2ZTogYm9vbGVhbikgPT4gdm9pZCwgZGVwdGg6IG51bWJlciB9KSA9PiB7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPGJ1dHRvbj5CdXR0b24gMTwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8YnV0dG9uPkJ1dHRvbiAyPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b24+QnV0dG9uIDM8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGxhYmVsPkFjdGl2ZTogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ9e2FjdGl2ZX0gb25JbnB1dD17ZSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgc2V0QWN0aXZlKGUuY3VycmVudFRhcmdldC5jaGVja2VkKTsgfX0gLz48L2xhYmVsPlxyXG5cclxuICAgICAgICA8Lz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuY29uc3QgVXNlQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPEhUTUxCdXR0b25FbGVtZW50LCBIVE1MRGl2RWxlbWVudD4+KG51bGwhKTtcclxuY29uc3QgRGVtb1VzZUFjY29yZGlvbiA9IG1lbW8oKCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IHsgdXNlQXJpYUFjY29yZGlvblNlY3Rpb24gfSA9IHVzZUFyaWFBY2NvcmRpb248SFRNTEJ1dHRvbkVsZW1lbnQsIEhUTUxEaXZFbGVtZW50Pih7IGluaXRpYWxJbmRleDogMCB9KVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFVzZUFjY29yZGlvblNlY3Rpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbn0+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVtb1wiPlxyXG4gICAgICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgICAgICA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezB9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXsxfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxEZW1vQWNjb3JkaW9uU2VjdGlvbiBpbmRleD17Mn0gLz5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L1VzZUFjY29yZGlvblNlY3Rpb25Db250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG59KTtcclxuXHJcbmNvbnN0IERlbW9BY2NvcmRpb25TZWN0aW9uID0gbWVtbygoeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkgPT4ge1xyXG5cclxuICAgIGNvbnN0IHVzZUFjY29yZGlvblNlY3Rpb24gPSB1c2VDb250ZXh0KFVzZUFjY29yZGlvblNlY3Rpb25Db250ZXh0KTtcclxuICAgIGNvbnN0IHsgZXhwYW5kZWQsIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzLCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzIH0gPSB1c2VBY2NvcmRpb25TZWN0aW9uKHsgaW5mbzogeyBpbmRleCwgZmxhZ3M6IHt9IH0gfSk7XHJcblxyXG4gICAgY29uc3QgcCA9IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzKHsgY2xhc3NOYW1lOiBcImFjY29yZGlvbi1zZWN0aW9uLWJvZHlcIiwgaGlkZGVuOiAhZXhwYW5kZWQgfSk7XHJcbiAgICBwLmlkO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFjY29yZGlvbi1zZWN0aW9uXCI+XHJcbiAgICAgICAgICAgIDxidXR0b24gey4uLnVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHMoeyBjbGFzc05hbWU6IFwiYWNjb3JkaW9uLXNlY3Rpb24taGVhZGVyXCIgfSl9PkhlYWRlciAje2luZGV4ICsgMX08L2J1dHRvbj5cclxuICAgICAgICAgICAgPGRpdiB7Li4ucH0+PHA+Qm9keSBjb250ZW50ICN7aW5kZXggKyAxfTwvcD48cD57UmFuZG9tV29yZHMuam9pbihcIiBcIil9PC9wPjwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59KVxyXG5cclxuY29uc3QgRGVtb1VzZUNoZWNrYm94ID0gbWVtbygoKSA9PiB7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlbW9cIj5cclxuICAgICAgICAgICAgICAgIDxDaGVja2JveDEgLz5cclxuICAgICAgICAgICAgICAgIDxDaGVja2JveDIgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxEZW1vVXNlQ2hlY2tib3hHcm91cCAvPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59KTtcclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IENoZWNrYm94MSA9IG1lbW8oKCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExhYmVsRWxlbWVudCB9ID0gdXNlQXJpYUNoZWNrYm94PEhUTUxJbnB1dEVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQ+KHsgZGlzYWJsZWQ6IGZhbHNlLCBjaGVja2VkLCBsYWJlbFBvc2l0aW9uOiBcInNlcGFyYXRlXCIsIG9uSW5wdXQ6IGUgPT4gc2V0Q2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKSwgaW5wdXRUYWc6IFwiaW5wdXRcIiwgbGFiZWxUYWc6IFwibGFiZWxcIiB9KTtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKTtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgIDxpbnB1dCB7Li4udXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyh7IHR5cGU6IFwiY2hlY2tib3hcIiwgfSl9IC8+XHJcbiAgICAgICAgICAgIDxsYWJlbCB7Li4udXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyh7fSl9PkxhYmVsPC9sYWJlbD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIClcclxufSk7XHJcblxyXG5jb25zdCBDaGVja2JveDIgPSBtZW1vKCgpID0+IHtcclxuXHJcbiAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VDaGVja2JveExhYmVsRWxlbWVudCwgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQgfSA9IHVzZUFyaWFDaGVja2JveDxIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50Pih7IGRpc2FibGVkOiBmYWxzZSwgbGFiZWxQb3NpdGlvbjogXCJ3cmFwcGluZ1wiLCBvbklucHV0OiBlID0+IHNldENoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCksIGNoZWNrZWQsIGlucHV0VGFnOiBcImlucHV0XCIsIGxhYmVsVGFnOiBcImxhYmVsXCIgfSk7XHJcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCk7XHJcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KCk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICA8bGFiZWwgey4uLnVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMoe30pfT48aW5wdXQgey4uLnVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMoeyB0eXBlOiBcImNoZWNrYm94XCIgfSl9IC8+IExhYmVsPC9sYWJlbD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIClcclxufSk7XHJcblxyXG5cclxuY29uc3QgQ2hlY2tib3hHcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUNoZWNrYm94R3JvdXBDaGlsZDxIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50LCBzdHJpbmcsIFVzZUNoZWNrYm94R3JvdXBDaGlsZEluZm9CYXNlPHN0cmluZz4+PihudWxsISk7XHJcblxyXG5jb25zdCBEZW1vVXNlQ2hlY2tib3hHcm91cCA9IG1lbW8oKCkgPT4ge1xyXG5cclxuXHJcbiAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGdldEZvY3VzZWRJbm5lciB9ID0gdXNlSGFzRm9jdXM8SFRNTERpdkVsZW1lbnQ+KHt9KVxyXG4gICAgY29uc3QgeyB1c2VDaGVja2JveEdyb3VwQ2hpbGQsIHBhcmVudElzQ2hlY2tlZDogc2VsZklzQ2hlY2tlZCwgcGFyZW50UGVyY2VudENoZWNrZWQ6IHBlcmNlbnRDaGVja2VkLCBjaGVja2JveGVzLCBjdXJyZW50VHlwZWFoZWFkLCBpbnZhbGlkVHlwZWFoZWFkLCB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXQgfSA9IHVzZUNoZWNrYm94R3JvdXA8SFRNTElucHV0RWxlbWVudCwgSFRNTExhYmVsRWxlbWVudCwgc3RyaW5nLCBVc2VDaGVja2JveEdyb3VwQ2hpbGRJbmZvPih7IGluaXRpYWxJbmRleDogMCB9KTtcclxuICAgIC8vY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQgfSA9IHVzZUFyaWFDaGVja2JveDxIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50Pih7IGNoZWNrZWQ6IHNlbGZJc0NoZWNrZWQsIGRpc2FibGVkOiBmYWxzZSwgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiLCBvbklucHV0OiBvbkNoZWNrYm94R3JvdXBJbnB1dCBhcyBhbnksIGlucHV0VGFnOiBcImlucHV0XCIsIGxhYmVsVGFnOiBcImxhYmVsXCIgfSk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcywgdXNlQ2hlY2tib3hHcm91cFBhcmVudExhYmVsUHJvcHMgfSA9IHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dCh7IGlucHV0VGFnOiBcImlucHV0XCIsIGxhYmVsVGFnOiBcImxhYmVsXCIsIGRpc2FibGVkOiBmYWxzZSwgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiIH0pXHJcblxyXG4gICAgcmV0dXJuIDxkaXYgY2xhc3M9XCJkZW1vXCI+XHJcbiAgICAgICAgPENoZWNrYm94R3JvdXBDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VDaGVja2JveEdyb3VwQ2hpbGR9PlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IHsuLi51c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcyh7fSl9IC8+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWwgey4uLnVzZUNoZWNrYm94R3JvdXBQYXJlbnRMYWJlbFByb3BzKHt9KX0+QWxsIGNoZWNrZWQ/PC9sYWJlbD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgey4uLnVzZUhhc0ZvY3VzUHJvcHMoeyBzdHlsZTogeyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleERpcmVjdGlvblwiOiBcImNvbHVtblwiIH0gfSl9ID5cclxuXHJcbiAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyArK2kpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxEZW1vVXNlQ2hlY2tib3hHcm91cENoaWxkIGtleT17aX0gaW5kZXg9e2l9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkoKSl9XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvQ2hlY2tib3hHcm91cENvbnRleHQuUHJvdmlkZXI+XHJcbiAgICA8L2Rpdj5cclxufSk7XHJcblxyXG5cclxuY29uc3QgRGVtb1VzZUNoZWNrYm94R3JvdXBDaGlsZCA9IG1lbW8oKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pID0+IHtcclxuICAgIGNvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkLCBnZXRDaGVja2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IHVzZUNoZWNrYm94R3JvdXBDaGlsZCA9IHVzZUNvbnRleHQoQ2hlY2tib3hHcm91cENvbnRleHQpO1xyXG4gICAgbGV0IHRleHQgPSBgTnVtYmVyICR7aW5kZXggKyAxfSBjaGVja2JveCAke2NoZWNrZWQgPyBcIihjaGVja2VkKVwiIDogXCJcIn1gO1xyXG5cclxuICAgIGNvbnN0IHsgXHJcbiAgICAgICAgdGFiYmFibGUsIFxyXG4gICAgICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHMsIFxyXG4gICAgICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZExhYmVsUHJvcHMgXHJcbiAgICB9ID0gdXNlQ2hlY2tib3hHcm91cENoaWxkKHsgXHJcbiAgICAgICAgb25JbnB1dDogZSA9PiBzZXRDaGVja2VkKGVbRXZlbnREZXRhaWxdLmNoZWNrZWQpLCBcclxuICAgICAgICBpbmZvOiB7XHJcbiAgICAgICAgICAgIGluZGV4LCBcclxuICAgICAgICAgICAgdGV4dCxcclxuICAgICAgICAgICAgZmxhZ3M6IHt9LCBcclxuICAgICAgICB9LCBcclxuICAgICAgICBjaGVja2VkLCBcclxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsIFxyXG4gICAgICAgIGlucHV0VGFnOiBcImlucHV0XCIsIFxyXG4gICAgICAgIGxhYmVsVGFnOiBcImxhYmVsXCIsIFxyXG4gICAgICAgIGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIiBcclxuICAgIH0pO1xyXG4gICAgdGV4dCA9IGBOdW1iZXIgJHtpbmRleCArIDF9IGNoZWNrYm94ICR7Y2hlY2tlZCA/IFwiKGNoZWNrZWQpXCIgOiBcIlwifSAke3RhYmJhYmxlID8gXCIodGFiYmJsZSlcIiA6IFwiXCJ9YDtcclxuICAgIC8vY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQgfSA9IHVzZUFyaWFDaGVja2JveDxIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50Pih7IGNoZWNrZWQsIGRpc2FibGVkOiBmYWxzZSwgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiLCBvbklucHV0OiBlID0+IHsgc2V0Q2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKTsgfSwgaW5wdXRUYWc6IFwiaW5wdXRcIiwgbGFiZWxUYWc6IFwibGFiZWxcIiB9KTtcclxuXHJcbiAgICByZXR1cm4gKDxkaXY+XHJcbiAgICAgICAgPGlucHV0IHsuLi51c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzKHt9KX0gLz5cclxuICAgICAgICA8bGFiZWwgey4uLnVzZUNoZWNrYm94R3JvdXBDaGlsZExhYmVsUHJvcHMoe30pfT57dGV4dH08L2xhYmVsPlxyXG4gICAgPC9kaXY+XHJcbiAgICApO1xyXG59KTtcclxuXHJcblxyXG5jb25zdCBEZW1vVXNlRGlhbG9nID0gbWVtbygoKSA9PiB7XHJcbiAgICBjb25zdCBvbkNsb3NlID0gKCgpID0+IHNldE9wZW4oZmFsc2UpKTtcclxuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCB7IHVzZURpYWxvZ0JhY2tkcm9wLCB1c2VEaWFsb2dCb2R5LCB1c2VEaWFsb2dQcm9wcywgdXNlRGlhbG9nVGl0bGUgfSA9IHVzZUFyaWFEaWFsb2c8SFRNTERpdkVsZW1lbnQsIEhUTUxEaXZFbGVtZW50LCBIVE1MRGl2RWxlbWVudD4oeyBvcGVuLCBvbkNsb3NlOiAoKSA9PiB7IG9uQ2xvc2UoKTsgfSB9KTtcclxuICAgIGNvbnN0IHsgdXNlRGlhbG9nQmFja2Ryb3BQcm9wcyB9ID0gdXNlRGlhbG9nQmFja2Ryb3AoKTtcclxuICAgIGNvbnN0IHsgdXNlRGlhbG9nQm9keVByb3BzIH0gPSB1c2VEaWFsb2dCb2R5KHsgZGVzY3JpcHRpdmU6IHRydWUgfSk7XHJcbiAgICBjb25zdCB7IHVzZURpYWxvZ1RpdGxlUHJvcHMgfSA9IHVzZURpYWxvZ1RpdGxlKCk7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XHJcbiAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17b3Blbn0gb25JbnB1dD17ZSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgc2V0T3BlbihlLmN1cnJlbnRUYXJnZXQuY2hlY2tlZCkgfX0gLz48L2xhYmVsPlxyXG4gICAgICAgICAgICA8ZGl2IHsuLi51c2VEaWFsb2dCYWNrZHJvcFByb3BzKHsgaGlkZGVuOiAhb3BlbiB9KX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IHsuLi51c2VEaWFsb2dQcm9wcyh7fSl9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgey4uLnVzZURpYWxvZ1RpdGxlUHJvcHMoe30pfT5EaWFsb2cgVGl0bGU8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHsuLi51c2VEaWFsb2dCb2R5UHJvcHMoe30pfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHAgdGFiSW5kZXg9ey0xfT5EaWFsb2cgYm9keSBjb250ZW50PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cD57UmFuZG9tV29yZHMuam9pbihcIiBcIil9PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cD57UmFuZG9tV29yZHMuam9pbihcIiBcIil9PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cD57UmFuZG9tV29yZHMuam9pbihcIiBcIil9PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cD48YnV0dG9uIG9uQ2xpY2s9e29uQ2xvc2V9PkNsb3NlPC9idXR0b24+PC9wPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59KTtcclxuXHJcbmNvbnN0IFJhZGlvV3JhcENvbnRleHQgPSBjcmVhdGVDb250ZXh0KGZhbHNlKTtcclxuY29uc3QgUmFkaW9Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VSYWRpbzxudW1iZXIsIEhUTUxJbnB1dEVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQsIFVzZUFyaWFSYWRpb0luZm9CYXNlPj4obnVsbCEpO1xyXG5jb25zdCBEZW1vVXNlUmFkaW9Hcm91cCA9IG1lbW8oKCkgPT4ge1xyXG4gICAgY29uc3QgW3NlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXhdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbd3JhcCwgc2V0V3JhcF0gPSB1c2VTdGF0ZSh1c2VDb250ZXh0KFJhZGlvV3JhcENvbnRleHQpKTtcclxuICAgIGNvbnN0IHsgdXNlUmFkaW8sIHVzZVJhZGlvR3JvdXBQcm9wcyB9ID0gdXNlQXJpYVJhZGlvR3JvdXA8bnVtYmVyLCBIVE1MRGl2RWxlbWVudCwgSFRNTExhYmVsRWxlbWVudCwgSFRNTElucHV0RWxlbWVudCwgSFRNTExhYmVsRWxlbWVudCwgVXNlQXJpYVJhZGlvSW5mb0Jhc2U+KHtcclxuICAgICAgICBuYW1lOiBcInJhZGlvLWRlbW8tMVwiLFxyXG4gICAgICAgIG9uSW5wdXQ6IChlKSA9PiBzZXRTZWxlY3RlZEluZGV4KCtlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZFZhbHVlKSxcclxuICAgICAgICBzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZEluZGV4LFxyXG4gICAgICAgIGdyb3VwTGFiZWxUYWc6IFwibGFiZWxcIixcclxuICAgICAgICBncm91cFRhZzogXCJkaXZcIixcclxuICAgICAgICBcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICByZXR1cm4gPGRpdiBjbGFzcz1cImRlbW9cIj5cclxuICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ9e3dyYXB9IG9uSW5wdXQ9e2UgPT4gc2V0V3JhcCh3ID0+ICF3KX0gLz4gV3JhcHBlciBsYWJlbDwvbGFiZWw+XHJcbiAgICAgICAgPFJhZGlvV3JhcENvbnRleHQuUHJvdmlkZXIga2V5PXt3cmFwfSB2YWx1ZT17d3JhcH0+XHJcbiAgICAgICAgICAgIDxSYWRpb0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVJhZGlvfT5cclxuICAgICAgICAgICAgICAgIDxkaXYgey4uLnVzZVJhZGlvR3JvdXBQcm9wcyh7fSl9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxEZW1vUmFkaW8ga2V5PXtpfSBpbmRleD17aX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKCkpfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvUmFkaW9Db250ZXh0LlByb3ZpZGVyPlxyXG4gICAgICAgIDwvUmFkaW9XcmFwQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIDwvZGl2PlxyXG59KTtcclxuXHJcblxyXG5cclxuY29uc3QgRGVtb1JhZGlvID0gbWVtbygoeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkgPT4ge1xyXG4gICAgY29uc3Qgd3JhcCA9IHVzZUNvbnRleHQoUmFkaW9XcmFwQ29udGV4dCk7XHJcbiAgICBjb25zdCB7IHVzZVJhZGlvSW5wdXQsIHVzZVJhZGlvTGFiZWwsIGNoZWNrZWQsIHRhYmJhYmxlIH0gPSB1c2VDb250ZXh0KFJhZGlvQ29udGV4dCkoeyBpbmZvOiB7IGluZGV4LCB0ZXh0OiBcIlwiLCBmbGFnczoge30gfSwgdmFsdWU6IGluZGV4LCBkaXNhYmxlZDogZmFsc2UsIGxhYmVsUG9zaXRpb246IHdyYXAgPyBcIndyYXBwaW5nXCIgOiBcInNlcGFyYXRlXCIsIGlucHV0VGFnOiBcImlucHV0XCIsIGxhYmVsVGFnOiBcImxhYmVsXCIgfSk7XHJcbiAgICBjb25zdCB7IHVzZVJhZGlvSW5wdXRQcm9wcyB9ID0gdXNlUmFkaW9JbnB1dCh7IHRhZzogXCJpbnB1dFwiIH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYWRpb0xhYmVsUHJvcHMgfSA9IHVzZVJhZGlvTGFiZWwoeyB0YWc6IFwibGFiZWxcIiB9KTtcclxuICAgIGlmICh3cmFwKVxyXG4gICAgICAgIHJldHVybiA8bGFiZWwgey4uLnVzZVJhZGlvTGFiZWxQcm9wcyh7fSl9PjxpbnB1dCB7Li4udXNlUmFkaW9JbnB1dFByb3BzKHt9KX0gLz5OdW1iZXIge2luZGV4ICsgMX0gcmFkaW97Y2hlY2tlZCA/IFwiIChjaGVja2VkKVwiIDogXCJcIn17dGFiYmFibGUgPyBcIiAodGFiYmFibGUpXCIgOiBcIlwifTwvbGFiZWw+O1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiA8ZGl2PjxpbnB1dCB7Li4udXNlUmFkaW9JbnB1dFByb3BzKHt9KX0gLz5OdW1iZXIge2luZGV4ICsgMX0gcmFkaW97Y2hlY2tlZCA/IFwiIChjaGVja2VkKVwiIDogXCJcIn17dGFiYmFibGUgPyBcIiAodGFiYmFibGUpXCIgOiBcIlwifTxsYWJlbCB7Li4udXNlUmFkaW9MYWJlbFByb3BzKHt9KX0+PC9sYWJlbD48L2Rpdj47XHJcbn0pO1xyXG5cclxuXHJcbmNvbnN0IExpc3RCb3hTaW5nbGVJdGVtQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTGlzdGJveFNpbmdsZUl0ZW08SFRNTExJRWxlbWVudCwgc3RyaW5nLCBVc2VMaXN0Ym94U2luZ2xlSXRlbUluZm88SFRNTExJRWxlbWVudCwgc3RyaW5nPj4+KG51bGwhKTtcclxuY29uc3QgRGVtb1VzZUxpc3Rib3hTaW5nbGUgPSBtZW1vKCgpID0+IHtcclxuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVJdGVtLFxyXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCxcclxuICAgICAgICB1c2VMaXN0Ym94U2luZ2xlUHJvcHNcclxuICAgIH0gPSB1c2VBcmlhTGlzdGJveFNpbmdsZTxIVE1MTGFiZWxFbGVtZW50LCBIVE1MVUxpc3RFbGVtZW50LCBIVE1MTElFbGVtZW50LCBzdHJpbmcsIFVzZUxpc3Rib3hTaW5nbGVJdGVtSW5mbzxIVE1MTElFbGVtZW50LCBzdHJpbmc+Pih7XHJcbiAgICAgICAgc2VsZWN0ZWRJbmRleCxcclxuICAgICAgICBvblNlbGVjdDogZSA9PiBzZXRTZWxlY3RlZEluZGV4KGVbRXZlbnREZXRhaWxdLnNlbGVjdGVkSW5kZXgpLCBzZWxlY3Rpb25Nb2RlOiBcImFjdGl2YXRlXCIsIGxhYmVsVGFnOiBcImxhYmVsXCIsIGxpc3RUYWc6IFwidWxcIlxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIHJldHVybiA8ZGl2IGNsYXNzPVwiZGVtb1wiPlxyXG4gICAgICAgIDxMaXN0Qm94U2luZ2xlSXRlbUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUxpc3Rib3hTaW5nbGVJdGVtfT5cclxuICAgICAgICAgICAgPHVsIHsuLi51c2VMaXN0Ym94U2luZ2xlUHJvcHMoe30pfT5cclxuICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb0xpc3Rib3hTaW5nbGVPcHRpb24ga2V5PXtpfSBpbmRleD17aX0gLz5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSgpKX1cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8L0xpc3RCb3hTaW5nbGVJdGVtQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIDwvZGl2PlxyXG59KTtcclxuXHJcblxyXG5cclxuY29uc3QgRGVtb0xpc3Rib3hTaW5nbGVPcHRpb24gPSBtZW1vKCh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciwgfSkgPT4ge1xyXG4gICAgY29uc3QgeyBnZXRTZWxlY3RlZCwgc2VsZWN0ZWQsIHRhYmJhYmxlLCB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzIH0gPSB1c2VDb250ZXh0KExpc3RCb3hTaW5nbGVJdGVtQ29udGV4dCkoeyBpbmRleCwgdGV4dDogYE51bWJlciAke2luZGV4ICsgMX0gb3B0aW9uYCwgZmxhZ3M6IHt9IH0pO1xyXG4gICAgcmV0dXJuIDxsaSB7Li4udXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyh7fSl9Pk51bWJlciB7aW5kZXggKyAxfSBvcHRpb257c2VsZWN0ZWQgPyBcIiAoc2VsZWN0ZWQpXCIgOiBcIlwifXt0YWJiYWJsZSA/IFwiICh0YWJiYWJsZSlcIiA6IFwiXCJ9PC9saT5cclxufSk7XHJcblxyXG5cclxuXHJcblxyXG5cclxuY29uc3QgTGlzdEJveE11bHRpSXRlbUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUxpc3Rib3hNdWx0aUl0ZW08SFRNTExJRWxlbWVudCwgVXNlTGlzdGJveE11bHRpSXRlbUluZm88SFRNTExJRWxlbWVudD4+PihudWxsISk7XHJcbmNvbnN0IERlbW9Vc2VMaXN0Ym94TXVsdGkgPSBtZW1vKCgpID0+IHtcclxuXHJcbiAgICBjb25zdCB7IHVzZUxpc3Rib3hNdWx0aUl0ZW0sIHVzZUxpc3Rib3hNdWx0aUxhYmVsLCB1c2VMaXN0Ym94TXVsdGlQcm9wcywgY3VycmVudFR5cGVhaGVhZCB9ID0gdXNlQXJpYUxpc3Rib3hNdWx0aTxIVE1MTGFiZWxFbGVtZW50LCBIVE1MVUxpc3RFbGVtZW50LCBIVE1MTElFbGVtZW50LCBzdHJpbmcsIFVzZUxpc3Rib3hNdWx0aUl0ZW1JbmZvPEhUTUxMSUVsZW1lbnQ+Pih7IGluaXRpYWxJbmRleDogMCwgbGFiZWxUYWc6IFwibGFiZWxcIiwgbGlzdFRhZzogXCJ1bFwiIH0pO1xyXG5cclxuXHJcbiAgICByZXR1cm4gPGRpdiBjbGFzcz1cImRlbW9cIj5cclxuICAgICAgICA8TGlzdEJveE11bHRpSXRlbUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUxpc3Rib3hNdWx0aUl0ZW19PlxyXG4gICAgICAgICAgICA8dWwgey4uLnVzZUxpc3Rib3hNdWx0aVByb3BzKHt9KX0+XHJcbiAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyArK2kpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxEZW1vTGlzdGJveE11bHRpT3B0aW9uIGtleT17aX0gaW5kZXg9e2l9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkoKSl9XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIHtjdXJyZW50VHlwZWFoZWFkICE9IG51bGwgJiYgPHA+e2N1cnJlbnRUeXBlYWhlYWR9PC9wPn1cclxuICAgICAgICA8L0xpc3RCb3hNdWx0aUl0ZW1Db250ZXh0LlByb3ZpZGVyPlxyXG4gICAgPC9kaXY+XHJcbn0pO1xyXG5cclxuY29uc3QgTWVudUl0ZW1Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VNZW51SXRlbTxIVE1MTElFbGVtZW50LCBVc2VNZW51Q2hpbGRJbmZvPj4obnVsbCEpO1xyXG5jb25zdCBEZW1vTGlzdGJveE11bHRpT3B0aW9uID0gbWVtbygoeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkgPT4ge1xyXG4gICAgY29uc3QgW3NlbGVjdGVkLCBzZXRTZWxlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBsZXQgdGV4dCA9IGBOdW1iZXIgJHtpbmRleCArIDF9IG9wdGlvbiR7c2VsZWN0ZWQgPyBcIiAoc2VsZWN0ZWQpXCIgOiBcIlwifWA7XHJcbiAgICBjb25zdCB7IHRhYmJhYmxlLCB1c2VMaXN0Ym94TXVsdGlJdGVtUHJvcHMgfSA9IHVzZUNvbnRleHQoTGlzdEJveE11bHRpSXRlbUNvbnRleHQpKHsgdGFnOiBcImxpXCIsIGluZGV4LCB0ZXh0LCBvblNlbGVjdDogZSA9PiBzZXRTZWxlY3RlZChlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZCksIHNlbGVjdGVkLCBmbGFnczoge30gfSk7XHJcbiAgICB0ZXh0ID0gYE51bWJlciAke2luZGV4ICsgMX0gb3B0aW9uJHtzZWxlY3RlZCA/IFwiIChzZWxlY3RlZClcIiA6IFwiXCJ9JHt0YWJiYWJsZSA/IFwiICh0YWJiYWJsZSlcIiA6IFwiXCJ9YDtcclxuICAgIHJldHVybiA8bGkgey4uLnVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcyh7fSl9Pnt0ZXh0fTwvbGk+XHJcbn0pO1xyXG5cclxuY29uc3QgRGVtb01lbnUgPSBtZW1vKCgpID0+IHtcclxuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiBzZXRPcGVuKGZhbHNlKTtcclxuICAgIGNvbnN0IG9uT3BlbiA9ICgpID0+IHNldE9wZW4odHJ1ZSk7XHJcbiAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGdldEZvY3VzZWRJbm5lcjogZ2V0TWVudUZvY3VzZWRJbm5lciB9ID0gdXNlSGFzRm9jdXM8SFRNTFVMaXN0RWxlbWVudD4oe30pXHJcblxyXG4gICAgY29uc3QgeyB1c2VNZW51QnV0dG9uLCB1c2VNZW51SXRlbSwgdXNlTWVudVByb3BzIH0gPSB1c2VBcmlhTWVudTxIVE1MVUxpc3RFbGVtZW50LCBIVE1MTElFbGVtZW50LCBzdHJpbmcsIFVzZU1lbnVDaGlsZEluZm8+KHsgb3Blbiwgb25DbG9zZSwgb25PcGVuLCBpbml0aWFsSW5kZXg6IDAgfSk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VNZW51QnV0dG9uUHJvcHMgfSA9IHVzZU1lbnVCdXR0b248SFRNTEJ1dHRvbkVsZW1lbnQ+KHsgdGFnOiBcImJ1dHRvblwiIH0pXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XHJcbiAgICAgICAgICAgIDxNZW51SXRlbUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZU1lbnVJdGVtfT5cclxuICAgICAgICAgICAgICAgIDxidXR0b24gey4uLnVzZU1lbnVCdXR0b25Qcm9wcyh7IG9uQ2xpY2s6IGUgPT4gc2V0T3BlbihvcGVuID0+ICFvcGVuKSB9KX0+T3BlbiBtZW51PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICA8dWwgey4uLnVzZU1lbnVQcm9wcyh1c2VIYXNGb2N1c1Byb3BzKHt9KSl9IGhpZGRlbj17IW9wZW59PlxyXG4gICAgICAgICAgICAgICAgICAgIDxEZW1vTWVudUl0ZW0gaW5kZXg9ezB9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPERlbW9NZW51SXRlbSBpbmRleD17MX0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8RGVtb01lbnVJdGVtIGluZGV4PXsyfSAvPlxyXG4gICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPC9NZW51SXRlbUNvbnRleHQuUHJvdmlkZXI+XHJcblxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59KTtcclxuXHJcbmNvbnN0IERlbW9NZW51SXRlbSA9IG1lbW8oKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pID0+IHtcclxuICAgIGNvbnN0IHVzZUFyaWFNZW51SXRlbSA9IHVzZUNvbnRleHQoTWVudUl0ZW1Db250ZXh0KTtcclxuICAgIGNvbnN0IHsgdXNlTWVudUl0ZW1Qcm9wcyB9ID0gdXNlQXJpYU1lbnVJdGVtKHsgaW5kZXgsIHRleHQ6IGBJdGVtICR7aW5kZXggKyAxfWAsIGZsYWdzOiB7fSB9KTtcclxuICAgIHJldHVybiA8bGkgey4uLnVzZU1lbnVJdGVtUHJvcHMoe30pfT5JdGVtIHtpbmRleCArIDF9PC9saT5cclxufSlcclxuXHJcbmNvbnN0IFRhYkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRhYjxIVE1MTElFbGVtZW50Pj4obnVsbCEpO1xyXG5jb25zdCBUYWJQYW5lbENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRhYlBhbmVsPEhUTUxQYXJhZ3JhcGhFbGVtZW50Pj4obnVsbCEpO1xyXG5jb25zdCBEZW1vVGFicyA9IG1lbW8oKCkgPT4ge1xyXG4gICAgY29uc3QgW3NlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXhdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbc2VsZWN0aW9uTW9kZSwgc2V0U2VsZWN0aW9uTW9kZV0gPSB1c2VTdGF0ZTxcImZvY3VzXCIgfCBcImFjdGl2YXRlXCI+KFwiZm9jdXNcIik7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZVRhYixcclxuICAgICAgICB1c2VUYWJQYW5lbCxcclxuICAgICAgICB1c2VUYWJzTGFiZWxQcm9wcyxcclxuICAgICAgICB1c2VUYWJzTGlzdFByb3BzXHJcbiAgICB9ID0gdXNlQXJpYVRhYnM8SFRNTFVMaXN0RWxlbWVudCwgSFRNTExJRWxlbWVudCwgSFRNTFBhcmFncmFwaEVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQsIHN0cmluZywgVXNlVGFiSW5mbzxIVE1MVUxpc3RFbGVtZW50LCBzdHJpbmc+Pih7XHJcbiAgICAgICAgb25TZWxlY3Q6IGUgPT4gc2V0U2VsZWN0ZWRJbmRleChlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZEluZGV4KSxcclxuICAgICAgICBzZWxlY3RlZEluZGV4LFxyXG4gICAgICAgIHNlbGVjdGlvbk1vZGUsXHJcbiAgICAgICAgb3JpZW50YXRpb246IFwiYmxvY2tcIixcclxuICAgICAgICBpbml0aWFsSW5kZXg6IDBcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxUYWJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJ9ID5cclxuICAgICAgICAgICAgPFRhYlBhbmVsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFiUGFuZWx9ID5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtzZWxlY3Rpb25Nb2RlID09IFwiZm9jdXNcIn0gb25JbnB1dD17KGUpID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRTZWxlY3Rpb25Nb2RlKGUuY3VycmVudFRhcmdldC5jaGVja2VkID8gXCJmb2N1c1wiIDogXCJhY3RpdmF0ZVwiKSB9fSAvPiBBY3RpdmF0ZSBvbiBmb2N1cz88L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCB7Li4udXNlVGFic0xhYmVsUHJvcHMoe30pfT5UYWJzPC9sYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICA8dWwgey4uLnVzZVRhYnNMaXN0UHJvcHMoe30pfT48RGVtb1RhYiBpbmRleD17MH0gLz48RGVtb1RhYiBpbmRleD17MX0gLz48RGVtb1RhYiBpbmRleD17Mn0gLz48RGVtb1RhYiBpbmRleD17M30gLz48RGVtb1RhYiBpbmRleD17NH0gLz48L3VsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXY+PERlbW9UYWJQYW5lbCBpbmRleD17MH0gLz48RGVtb1RhYlBhbmVsIGluZGV4PXsxfSAvPjxEZW1vVGFiUGFuZWwgaW5kZXg9ezJ9IC8+PERlbW9UYWJQYW5lbCBpbmRleD17M30gLz48RGVtb1RhYlBhbmVsIGluZGV4PXs0fSAvPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvVGFiUGFuZWxDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgICAgIDwvVGFiQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIClcclxufSk7XHJcblxyXG5jb25zdCBEZW1vVGFiID0gbWVtbygoeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkgPT4ge1xyXG4gICAgY29uc3QgdXNlVGFiU2V0ID0gdXNlQ29udGV4dChUYWJDb250ZXh0KTtcclxuICAgIGNvbnN0IHsgdXNlVGFiUHJvcHMsIHNlbGVjdGVkLCBnZXRTZWxlY3RlZCwgdGFiYmFibGUsIGdldEVsZW1lbnQgfSA9IHVzZVRhYlNldCh7IGluZGV4LCB0ZXh0OiBcIlwiLCBmbGFnczoge30gfSlcclxuXHJcbiAgICByZXR1cm4gKDw+XHJcbiAgICAgICAgPGxpIHsuLi51c2VUYWJQcm9wcyh7fSl9PlRhYiAje2luZGV4ICsgMX0gKHtgU2VsZWN0ZWQ6ICR7c2VsZWN0ZWR9YH0pPC9saT5cclxuICAgIDwvPilcclxufSk7XHJcblxyXG5jb25zdCBEZW1vVGFiUGFuZWwgPSBtZW1vKCh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSA9PiB7XHJcbiAgICBjb25zdCB1c2VUYWJQYW5lbCA9IHVzZUNvbnRleHQoVGFiUGFuZWxDb250ZXh0KTtcclxuICAgIGNvbnN0IHsgdXNlVGFiUGFuZWxQcm9wcywgdmlzaWJsZSB9ID0gdXNlVGFiUGFuZWwoeyBpbmRleCB9KVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiB7Li4udXNlVGFiUGFuZWxQcm9wcyh7IGhpZGRlbjogIXZpc2libGUgfSl9PlxyXG4gICAgICAgICAgICA8cD5UYWIgcGFuZWwgY29udGVudCAje2luZGV4ICsgMX0gKHtgU2VsZWN0ZWQ6ICR7dmlzaWJsZX1gfSkuPC9wPlxyXG4gICAgICAgICAgICA8cD57UmFuZG9tV29yZHMuc2xpY2UoMCwgTWF0aC5mbG9vcihSYW5kb21Xb3Jkcy5sZW5ndGggLyAoaW5kZXggKyAxKSkpLmpvaW4oXCIgXCIpfTwvcD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIClcclxufSk7XHJcblxyXG5jb25zdCBEZW1vVG9vbHRpcCA9IG1lbW8oKCkgPT4ge1xyXG4gICAgY29uc3QgeyB1c2VUb29sdGlwLCB1c2VUb29sdGlwVHJpZ2dlciwgaXNPcGVuIH0gPSB1c2VBcmlhVG9vbHRpcDxIVE1MU3BhbkVsZW1lbnQsIEhUTUxTcGFuRWxlbWVudD4oe30pO1xyXG4gICAgY29uc3QgeyB1c2VUb29sdGlwUHJvcHMgfSA9IHVzZVRvb2x0aXAoKTtcclxuICAgIGNvbnN0IHsgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyB9ID0gdXNlVG9vbHRpcFRyaWdnZXIoKTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImRlbW9cIj5cclxuICAgICAgICAgICAgPHA+VGhpcyBpcyBhIHBhcmFncmFwaCB3aXRoIGEgPHNwYW4gey4uLnVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMoe30pfT50b29sdGlwIHJpZ2h0IGhlcmUuPC9zcGFuPjxzcGFuIHsuLi51c2VUb29sdGlwUHJvcHMoeyBoaWRkZW46ICFpc09wZW4gfSl9PlRoaXMgaXMgdGhlIHRvb2x0aXAgY29udGVudC48L3NwYW4+PC9wPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59KTtcclxuXHJcbi8qXHJcbmNvbnN0IERlbW9UYWJsZSA9IG1lbW8oKCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IHsgdXNlVGFibGVCb2R5LCB1c2VUYWJsZUZvb3QsIHVzZVRhYmxlSGVhZCwgdXNlVGFibGVQcm9wcywgdXNlVGFibGVSb3cgfSA9IHVzZVRhYmxlPFxyXG4gICAgICAgIEhUTUxUYWJsZUVsZW1lbnQsIEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50LCBIVE1MVGFibGVTZWN0aW9uRWxlbWVudCwgSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQsIEhUTUxUYWJsZVJvd0VsZW1lbnQsIEhUTUxUYWJsZUNlbGxFbGVtZW50LCBIVE1MVGFibGVDZWxsRWxlbWVudD4oe30pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlVGFibGVIZWFkUHJvcHMgfSA9IHVzZVRhYmxlSGVhZCh7fSk7XHJcbiAgICBjb25zdCB7IHVzZVRhYmxlQm9keVByb3BzIH0gPSB1c2VUYWJsZUJvZHkoe30pO1xyXG5cclxuICAgIGNvbnN0IHJvd3M6IFZOb2RlPGFueT5bXSA9IEFycmF5LmZyb20oZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyArK2kpIHtcclxuICAgICAgICAgICAgeWllbGQgPFRhYmxlUm93IHJvd0luZGV4PXtpICsgMX0gLz47XHJcbiAgICAgICAgfVxyXG4gICAgfSgpKTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8VGFibGVSb3dDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJsZVJvd30+XHJcbiAgICAgICAgICAgIDx0YWJsZSB7Li4udXNlVGFibGVQcm9wcyh7fSl9PlxyXG4gICAgICAgICAgICAgICAgPHRoZWFkIHsuLi51c2VUYWJsZUhlYWRQcm9wcyh7IGNoaWxkcmVuOiBbPFRhYmxlSGVhZGVyUm93IHJvd0luZGV4PXswfSAvPl0gfSl9IC8+XHJcbiAgICAgICAgICAgICAgICA8dGJvZHkgey4uLnVzZVRhYmxlQm9keVByb3BzKHsgY2hpbGRyZW46IHJvd3MgfSl9IC8+XHJcbiAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgPC9UYWJsZVJvd0NvbnRleHQuUHJvdmlkZXI+XHJcbiAgICApXHJcblxyXG59KTtcclxuXHJcbmNvbnN0IFRhYmxlUm93Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVGFibGVSb3c8SFRNTFRhYmxlUm93RWxlbWVudCwgSFRNTFRhYmxlQ2VsbEVsZW1lbnQsIEhUTUxUYWJsZUNlbGxFbGVtZW50Pj4obnVsbCEpO1xyXG5cclxuXHJcbmNvbnN0IFRhYmxlUm93ID0gbWVtbyhmdW5jdGlvbiBUYWJsZVJvdyh7IHJvd0luZGV4IH06IHsgcm93SW5kZXg6IG51bWJlciB9KSB7XHJcbiAgICBjb25zdCBpID0gcm93SW5kZXggLSAxO1xyXG4gICAgY29uc3QgdXNlVGFibGVSb3cgPSB1c2VDb250ZXh0KFRhYmxlUm93Q29udGV4dCk7XHJcbiAgICBjb25zdCB7IHJvd0luZGV4QXNTb3J0ZWQsIHJvd0luZGV4QXNVbnNvcnRlZCwgdXNlVGFibGVDZWxsLCB1c2VUYWJsZVJvd1Byb3BzIH0gPSB1c2VUYWJsZVJvdyh7IHJvd0luZGV4LCBsb2NhdGlvbjogXCJib2R5XCIgfSk7XHJcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLCBuZXcgRGF0ZSgpLmdldE1vbnRoKCksIChpICogNykgKiogMik7XHJcblxyXG4gICAgY29uc3QgeyB1c2VUYWJsZUNlbGxQcm9wczogdXNlVGFibGVDZWxsUHJvcHMxLCB1c2VUYWJsZUNlbGxEZWxlZ2F0ZVByb3BzOiB1c2VUYWJsZUNlbGxEZWxlZ2F0ZVByb3BzMSB9ID0gdXNlVGFibGVDZWxsKHsgY29sdW1uSW5kZXg6IDAsIHZhbHVlOiBpIH0pO1xyXG4gICAgY29uc3QgeyB1c2VUYWJsZUNlbGxQcm9wczogdXNlVGFibGVDZWxsUHJvcHMyLCB1c2VUYWJsZUNlbGxEZWxlZ2F0ZVByb3BzOiB1c2VUYWJsZUNlbGxEZWxlZ2F0ZVByb3BzMiB9ID0gdXNlVGFibGVDZWxsKHsgY29sdW1uSW5kZXg6IDEsIHZhbHVlOiBSYW5kb21Xb3Jkc1tpXSB9KTtcclxuICAgIGNvbnN0IHsgdXNlVGFibGVDZWxsUHJvcHM6IHVzZVRhYmxlQ2VsbFByb3BzMywgdXNlVGFibGVDZWxsRGVsZWdhdGVQcm9wczogdXNlVGFibGVDZWxsRGVsZWdhdGVQcm9wczMgfSA9IHVzZVRhYmxlQ2VsbCh7IGNvbHVtbkluZGV4OiAyLCB2YWx1ZTogZGF0ZSB9KTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRyIHsuLi51c2VUYWJsZVJvd1Byb3BzKHsgXCJkYXRhLWluZGV4XCI6IHJvd0luZGV4IH0gYXMge30pfT5cclxuICAgICAgICAgICAgPHRkIHsuLi51c2VUYWJsZUNlbGxQcm9wczEodXNlVGFibGVDZWxsRGVsZWdhdGVQcm9wczEoe30pKX0+e2l9PC90ZD5cclxuICAgICAgICAgICAgPHRkIHsuLi51c2VUYWJsZUNlbGxQcm9wczIodXNlVGFibGVDZWxsRGVsZWdhdGVQcm9wczIoe30pKX0+e1JhbmRvbVdvcmRzW2ldfTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCB7Li4udXNlVGFibGVDZWxsUHJvcHMzKHVzZVRhYmxlQ2VsbERlbGVnYXRlUHJvcHMzKHt9KSl9PntkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpfTwvdGQ+XHJcbiAgICAgICAgPC90cj5cclxuICAgIClcclxufSlcclxuXHJcblxyXG5jb25zdCBUYWJsZUhlYWRlclJvdyA9IG1lbW8oZnVuY3Rpb24gVGFibGVIZWFkZXJSb3coeyByb3dJbmRleCB9OiB7IHJvd0luZGV4OiBudW1iZXIgfSkge1xyXG4gICAgY29uc3QgdXNlVGFibGVSb3cgPSB1c2VDb250ZXh0KFRhYmxlUm93Q29udGV4dCk7XHJcbiAgICBjb25zdCB7IHVzZVRhYmxlSGVhZENlbGwsIHVzZVRhYmxlUm93UHJvcHM6IHVzZVRhYmxlSGVhZFJvd1Byb3BzIH0gPSB1c2VUYWJsZVJvdyh7IHJvd0luZGV4LCBsb2NhdGlvbjogXCJoZWFkXCIgfSk7XHJcbiAgICBjb25zdCB7IHVzZVRhYmxlSGVhZENlbGxQcm9wczogdXNlVGFibGVIZWFkQ2VsbFByb3BzMSwgdXNlVGFibGVIZWFkQ2VsbERlbGVnYXRlUHJvcHM6IHVzZVRhYmxlSGVhZENlbGxEZWxlZ2F0ZVByb3BzMSwgc29ydERpcmVjdGlvbjogc29ydERpcmVjdGlvbjEgfSA9IHVzZVRhYmxlSGVhZENlbGwoeyB0YWc6IFwidGhcIiwgY29sdW1uSW5kZXg6IDAgfSk7XHJcbiAgICBjb25zdCB7IHVzZVRhYmxlSGVhZENlbGxQcm9wczogdXNlVGFibGVIZWFkQ2VsbFByb3BzMiwgdXNlVGFibGVIZWFkQ2VsbERlbGVnYXRlUHJvcHM6IHVzZVRhYmxlSGVhZENlbGxEZWxlZ2F0ZVByb3BzMiwgc29ydERpcmVjdGlvbjogc29ydERpcmVjdGlvbjIgfSA9IHVzZVRhYmxlSGVhZENlbGwoeyB0YWc6IFwidGhcIiwgY29sdW1uSW5kZXg6IDEgfSk7XHJcbiAgICBjb25zdCB7IHVzZVRhYmxlSGVhZENlbGxQcm9wczogdXNlVGFibGVIZWFkQ2VsbFByb3BzMywgdXNlVGFibGVIZWFkQ2VsbERlbGVnYXRlUHJvcHM6IHVzZVRhYmxlSGVhZENlbGxEZWxlZ2F0ZVByb3BzMywgc29ydERpcmVjdGlvbjogc29ydERpcmVjdGlvbjMgfSA9IHVzZVRhYmxlSGVhZENlbGwoeyB0YWc6IFwidGhcIiwgY29sdW1uSW5kZXg6IDIgfSk7XHJcblxyXG5cclxuICAgIHJldHVybiAoPHRyIHsuLi51c2VUYWJsZUhlYWRSb3dQcm9wcyh7IFwiZGF0YS1pbmRleFwiOiByb3dJbmRleCB9IGFzIHt9KX0+XHJcbiAgICAgICAgPHRoIHsuLi51c2VUYWJsZUhlYWRDZWxsUHJvcHMxKHVzZVRhYmxlSGVhZENlbGxEZWxlZ2F0ZVByb3BzMSh7fSkpfT5OdW1iZXIge3NvcnREaXJlY3Rpb24xfTwvdGg+XHJcbiAgICAgICAgPHRoIHsuLi51c2VUYWJsZUhlYWRDZWxsUHJvcHMyKHVzZVRhYmxlSGVhZENlbGxEZWxlZ2F0ZVByb3BzMih7fSkpfT5TdHJpbmcge3NvcnREaXJlY3Rpb24yfTwvdGg+XHJcbiAgICAgICAgPHRoIHsuLi51c2VUYWJsZUhlYWRDZWxsUHJvcHMzKHVzZVRhYmxlSGVhZENlbGxEZWxlZ2F0ZVByb3BzMyh7fSkpfT5EYXRlIHtzb3J0RGlyZWN0aW9uM308L3RoPlxyXG4gICAgPC90cj4pXHJcbn0pKi9cclxuXHJcbmNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcclxuICAgIHJldHVybiA8ZGl2IGNsYXNzPVwiZmxleFwiIHN0eWxlPXt7IGZsZXhXcmFwOiBcIndyYXBcIiB9fT5cclxuICAgICAgICA8RGVtb1VzZUFjY29yZGlvbiAvPlxyXG4gICAgICAgIDxEZW1vVXNlTGlzdGJveFNpbmdsZSAvPlxyXG4gICAgICAgIDxEZW1vVXNlTGlzdGJveE11bHRpIC8+PERlbW9Ub29sdGlwIC8+XHJcbiAgICAgICAgPERlbW9UYWJzIC8+XHJcbiAgICAgICAgPERlbW9Vc2VDaGVja2JveCAvPlxyXG4gICAgICAgIDxEZW1vVXNlUmFkaW9Hcm91cCAvPlxyXG4gICAgICAgIDxEZW1vVXNlRGlhbG9nIC8+XHJcbiAgICAgICAgPERlbW9NZW51IC8+XHJcbiAgICAgICAgey8qXHJcbiAgICAgICBcclxuICAgICAgICA8RGVtb1RhYmxlIC8+XHJcblxyXG5cclxuICAgICAgICA8RGVtb1VzZUZvY3VzVHJhcCAvPlxyXG4gICAgICAgIDxEZW1vVXNlRHJvcHBhYmxlIC8+XHJcbiAgICAgICAgPERlbW9Vc2VEcmFnZ2FibGUgLz5cclxuICAgICAgICA8aW5wdXQgLz4qL31cclxuICAgIDwvZGl2PlxyXG59XHJcblxyXG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgcmVuZGVyKDxDb21wb25lbnQgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9vdFwiKSEpO1xyXG59KVxyXG4iXSwibmFtZXMiOlsidm5vZGVJZCIsInJlcmVuZGVyUXVldWUiLCJ1c2VFbnN1cmVTdGFiaWxpdHkiLCJwYXJlbnRIb29rTmFtZSIsInZhbHVlcyIsInVzZUhlbHBlciIsImZvckVhY2giLCJ2YWx1ZSIsImluZGV4IiwiaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkiLCJ1c2VSZWYiLCJzaG93bkVycm9yIiwiY3VycmVudCIsInVzZVBhc3NpdmVTdGF0ZSIsIm9uQ2hhbmdlIiwiZ2V0SW5pdGlhbFZhbHVlIiwidmFsdWVSZWYiLCJVbnNldCIsImNsZWFudXBDYWxsYmFja1JlZiIsInVuZGVmaW5lZCIsIm9uU2hvdWxkQ2xlYW5VcCIsInVzZUNhbGxiYWNrIiwiY2xlYW51cENhbGxiYWNrIiwidHJ5RW5zdXJlVmFsdWUiLCJpbml0aWFsVmFsdWUiLCJleCIsImdldFZhbHVlIiwiY29uc29sZSIsIndhcm4iLCJyIiwibWljcm90YXNrUXVldWVkIiwiYXJnIiwicHJldkRlcCIsInNldFZhbHVlIiwidXNlTWVyZ2VkQ2hpbGRyZW4iLCJjaGlsZHJlbiIsImxocyIsInJocyIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsImUiLCJ0IiwiZiIsIm4iLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJjbHN4IiwiYXJndW1lbnRzIiwidXNlTWVyZ2VkQ2xhc3NlcyIsImNsYXNzIiwibGhzQ2xhc3MiLCJjbGFzc05hbWUiLCJsaHNDbGFzc05hbWUiLCJyaHNDbGFzcyIsInJoc0NsYXNzTmFtZSIsImxoc0NsYXNzZXMiLCJzcGxpdCIsInJoc0NsYXNzZXMiLCJhbGxDbGFzc2VzIiwiU2V0IiwiZnJvbSIsImpvaW4iLCJwcm9jZXNzUmVmIiwiaW5zdGFuY2UiLCJyZWYiLCJhc3NlcnQiLCJjb21iaW5lZCIsInN0eWxlU3RyaW5nVG9PYmplY3QiLCJzdHlsZSIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwibWFwIiwic3RhdGVtZW50IiwidXNlTWVyZ2VkU3R5bGVzIiwibG9nIiwidXNlTWVyZ2VkUHJvcHMiLCJsaHNBbGwiLCJyaHNBbGwiLCJfbGhzQ2hpbGRyZW4iLCJfbGhzQ2xhc3NOYW1lIiwiX2xoc1N0eWxlIiwiX2xoc1JlZiIsImxoc01pc2MiLCJfcmhzQ2hpbGRyZW4iLCJfcmhzQ2xhc3MiLCJfcmhzQ2xhc3NOYW1lIiwiX3Joc1N0eWxlIiwiX3Joc1JlZiIsInJoc01pc2MiLCJyZXQiLCJ1c2VNZXJnZWRSZWZzIiwicmhzRW50cmllcyIsImVudHJpZXMiLCJyaHNLZXlVIiwicmhzVmFsdWUiLCJyaHNLZXkiLCJsaHNWYWx1ZSIsIm1lcmdlZCIsIm1lcmdlRnVuY3Rpb25zIiwidXNlUmVmRWxlbWVudCIsImFyZ3MiLCJvbkVsZW1lbnRDaGFuZ2UiLCJvblVubW91bnQiLCJvbk1vdW50IiwiaGFuZGxlciIsInByZXZWYWx1ZSIsImNsZWFudXAiLCJhY3RpdmVFbGVtZW50VXBkYXRlcnMiLCJNYXAiLCJsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzIiwid2luZG93Rm9jdXNlZFVwZGF0ZXJzIiwid2luZG93c0ZvY3VzZWRVcGRhdGVycyIsIm1pY3JvdGFza3MiLCJmb3JFYWNoVXBkYXRlciIsIndpbmRvdyIsImhhcyIsImFkZCIsInF1ZXVlTWljcm90YXNrIiwiZGVsZXRlIiwidXBkYXRlcnMiLCJnZXQiLCJ1cGRhdGVyIiwiZm9jdXNvdXQiLCJ0YXJnZXQiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJyZWxhdGVkVGFyZ2V0IiwiZm9jdXNpbiIsImN1cnJlbnRseUZvY3VzZWRFbGVtZW50IiwiVGFibGUiLCJiYXNlNjQiLCJyYW5kb202Qml0cyIsImdlbmVyYXRlUmFuZG9tSWQiLCJwcmVmaXgiLCJyYW5kb202NEJpdHMiLCJwcmV2aW91c0lucHV0cyIsInRvUnVuIiwiY29tbWl0TmFtZSIsIm9yaWdpbmFsQ29tbWl0Iiwib3B0aW9ucyIsIm5ld0NvbW1pdCIsImlkIiwiZWZmZWN0SW5mbyIsImNsZWFyIiwiZWZmZWN0IiwiaW5wdXRzIiwiU3ltYm9sIiwidXNlU3RhYmxlR2V0dGVyIiwidXNlQmVmb3JlTGF5b3V0RWZmZWN0IiwiRXJyb3IiLCJmbiIsImN1cnJlbnRDYWxsYmFja0dldHRlciIsImNyZWF0ZUNvbnRleHQiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiZnJlZVNlbGYiLCJzZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwidG9TdHJpbmdUYWciLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInN0YXRlIiwic2V0U3RhdGVQIiwidXNlU3RhdGVQIiwic2V0U3RhdGUiLCJjYWxsYmFjayIsIm5leHRWYWx1ZSIsImltcGwiLCJ1c2VFZmZlY3ROYXRpdmUiLCJwcmV2SW5wdXRzIiwiZWZmZWN0MiIsImNoYW5nZXMiLCJpIiwiTWF0aCIsIm1heCIsInRvIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0TmF0aXZlIiwidXNlTWFuYWdlZENoaWxkcmVuIiwib25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Iiwib25DaGlsZHJlbk1vdW50Q2hhbmdlIiwiZ2V0SGlnaGVzdEluZGV4IiwibWFuYWdlZENoaWxkcmVuQXJyYXkiLCJhcnIiLCJyZWMiLCJjaGlsZCIsImZpZWxkIiwiaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkIiwicmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyIsInJlbW90ZVVMRUNoaWxkQ2hhbmdlZCIsInJlbW90ZVVMRUNoaWxkTW91bnRlZCIsIm1vdW50ZWQiLCJtb3VudHMiLCJ1bm1vdW50cyIsInVzZU1hbmFnZWRDaGlsZCIsImluZm8iLCJmbGF0IiwiZm9yRWFjaENoaWxkIiwiZ2V0QXQiLCJnZXRNYW5hZ2VkQ2hpbGRJbmZvIiwic2xpY2VTb3J0IiwiY29tcGFyZSIsInNsaWNlIiwic29ydCIsImdldERvY3VtZW50IiwiZWxlbWVudCIsImRvY3VtZW50IiwiZ2xvYmFsVGhpcyIsImNhbmRpZGF0ZVNlbGVjdG9ycyIsImNhbmRpZGF0ZVNlbGVjdG9yIiwibWF0Y2hlcyIsIk5vRWxlbWVudCIsIkVsZW1lbnQiLCJnZXRDYW5kaWRhdGVzIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJwcm90b3R5cGUiLCJpbmNsdWRlQ29udGFpbmVyIiwiY2FuZGlkYXRlcyIsInVuc2hpZnQiLCJlbCIsImdldFJvb3ROb2RlIiwiaXNJbnB1dCIsIm5vZGUiLCJpc0hpZGRlbklucHV0IiwicmFkaW9TZXQiLCJlc2NhcGUiLCJ0YWdOYW1lIiwiYXBwbHkiLCJzb21lIiwiaXNaZXJvQXJlYSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInZpc2liaWxpdHkiLCJpc0RpcmVjdFN1bW1hcnkiLCJjYWxsIiwibm9kZVVuZGVyRGV0YWlscyIsInBhcmVudEVsZW1lbnQiLCJub2RlUm9vdEhvc3QiLCJob3N0Iiwibm9kZUlzQXR0YWNoZWQiLCJjb250YWlucyIsImRpc3BsYXlDaGVjayIsImdldFNoYWRvd1Jvb3QiLCJyb290Tm9kZSIsInNoYWRvd1Jvb3QiLCJhc3NpZ25lZFNsb3QiLCJvcmlnaW5hbE5vZGUiLCJpc0Rpc2FibGVkRnJvbUZpZWxkc2V0IiwicGFyZW50Tm9kZSIsImlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZSIsImRpc2FibGVkIiwiaXRlbSIsInRhYkluZGV4IiwiaXNIaWRkZW4iLCJpc1Njb3BlIiwiaXNEZXRhaWxzV2l0aFN1bW1hcnkiLCJjYW5kaWRhdGVUYWJpbmRleCIsInJlZ3VsYXJUYWJiYWJsZXMiLCJkb2N1bWVudE9yZGVyIiwiZmFjdG9yeSIsInRoaXMiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIl9jbGFzc0NhbGxDaGVjayIsIlR5cGVFcnJvciIsIl9mb2N1c2FibGVFbGVtZW50c1N0cmluZyIsIkluZXJ0Um9vdCIsInJvb3RFbGVtZW50IiwiaW5lcnRNYW5hZ2VyIiwiX2luZXJ0TWFuYWdlciIsIl9yb290RWxlbWVudCIsIl9tYW5hZ2VkTm9kZXMiLCJoYXNBdHRyaWJ1dGUiLCJfc2F2ZWRBcmlhSGlkZGVuIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUiLCJfb2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiX29uTXV0YXRpb24iLCJiaW5kIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiZGVzdHJ1Y3RvciIsImRpc2Nvbm5lY3QiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpbmVydE5vZGUiLCJfdW5tYW5hZ2VOb2RlIiwic3RhcnROb2RlIiwiX3RoaXMyIiwiY29tcG9zZWRUcmVlV2FsayIsIl92aXNpdE5vZGUiLCJhY3RpdmVFbGVtZW50IiwiYm9keSIsIm5vZGVUeXBlIiwiTm9kZSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUiLCJibHVyIiwiZm9jdXMiLCJFTEVNRU5UX05PREUiLCJfYWRvcHRJbmVydFJvb3QiLCJfbWFuYWdlTm9kZSIsInJlZ2lzdGVyIiwiZGVyZWdpc3RlciIsIl91bm1hbmFnZVN1YnRyZWUiLCJfdGhpczMiLCJpbmVydFN1YnJvb3QiLCJnZXRJbmVydFJvb3QiLCJzZXRJbmVydCIsIm1hbmFnZWROb2RlcyIsInNhdmVkSW5lcnROb2RlIiwicmVjb3JkcyIsInJlY29yZCIsInR5cGUiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwiYXR0cmlidXRlTmFtZSIsIm1hbmFnZWROb2RlIiwic2V0IiwiYXJpYUhpZGRlbiIsIkluZXJ0Tm9kZSIsImluZXJ0Um9vdCIsIl9ub2RlIiwiX292ZXJyb2RlRm9jdXNNZXRob2QiLCJfaW5lcnRSb290cyIsIl9zYXZlZFRhYkluZGV4IiwiX2Rlc3Ryb3llZCIsImVuc3VyZVVudGFiYmFibGUiLCJfdGhyb3dJZkRlc3Ryb3llZCIsImRlc3Ryb3llZCIsImhhc1NhdmVkVGFiSW5kZXgiLCJhZGRJbmVydFJvb3QiLCJyZW1vdmVJbmVydFJvb3QiLCJzaXplIiwiSW5lcnRNYW5hZ2VyIiwiX2RvY3VtZW50IiwiX3dhdGNoRm9ySW5lcnQiLCJhZGRJbmVydFN0eWxlIiwiaGVhZCIsImRvY3VtZW50RWxlbWVudCIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiX29uRG9jdW1lbnRMb2FkZWQiLCJpbmVydCIsInBhcmVudCIsIl9pbmVydFJvb3QiLCJpbmVydEVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImluZXJ0RWxlbWVudCIsIl90aGlzIiwic2hhZG93Um9vdEFuY2VzdG9yIiwibG9jYWxOYW1lIiwiY29udGVudCIsImRpc3RyaWJ1dGVkTm9kZXMiLCJnZXREaXN0cmlidXRlZE5vZGVzIiwic2xvdCIsIl9kaXN0cmlidXRlZE5vZGVzIiwiYXNzaWduZWROb2RlcyIsImZsYXR0ZW4iLCJfaSIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZXh0Q29udGVudCIsImFwcGVuZENoaWxkIiwiSFRNTEVsZW1lbnQiLCJoYXNPd25Qcm9wZXJ0eSIsIl9ibG9ja2luZ0VsZW1lbnRzIiwiX2FscmVhZHlJbmVydEVsZW1lbnRzIiwiX3RvcEVsUGFyZW50cyIsIl9zaWJsaW5nc1RvUmVzdG9yZSIsIl9pbmVydFNpYmxpbmdzIiwiX2dldFBhcmVudHMiLCJfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbiIsIl9oYW5kbGVNdXRhdGlvbnMiLCJudWxsYWJsZSIsInRvcCIsImVsZW1zIiwicHVzaCIsImluZGV4T2YiLCJzcGxpY2UiLCJfdG9wQ2hhbmdlZCIsInBvcCIsInJlbW92ZSIsIl9hIiwiX2IiLCJfYyIsIm5ld1RvcCIsInRvS2VlcEluZXJ0Iiwib2xkUGFyZW50cyIsIl9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzIiwibmV3UGFyZW50cyIsInRvU2tpcCIsImoiLCJfc3dhcEluZXJ0ZWRTaWJsaW5nIiwib2xkSW5lcnQiLCJuZXdJbmVydCIsInNpYmxpbmdzVG9SZXN0b3JlIiwiX3BhcmVudE1PIiwiZWxlbWVudHMiLCJtbyIsInNpYmxpbmdzIiwic2libGluZyIsImluZXJ0ZWRTaWJsaW5ncyIsIl9pc0luZXJ0YWJsZSIsInBhcmVudFRvT2JzZXJ2ZSIsIm1heWJlU2hhZHlSb290IiwiX19zaGFkeSIsIm11dGF0aW9ucyIsInBhcmVudHMiLCJtdXRhdGlvbiIsImlkeCIsImluZXJ0ZWRDaGlsZCIsInVzZUJsb2NraW5nRWxlbWVudCIsImVuYWJsZWQiLCJnZXRUYXJnZXQiLCJzdGFibGVHZXRUYXJnZXQiLCJ1c2VTdGFibGVDYWxsYmFjayIsImJsb2NraW5nRWxlbWVudHMiLCJlcnJvciIsInVzZUZvY3VzVHJhcCIsInRyYXBBY3RpdmUiLCJoYW5kbGVBY3RpdmVDaGFuZ2UiLCJyYWZIYW5kbGUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImdldFRvcEVsZW1lbnQiLCJlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8iLCJnZXRMYXN0QWN0aXZlRWxlbWVudCIsImdldEVsZW1lbnQiLCJ1c2VMb2dpY2FsRGlyZWN0aW9uIiwib25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlIiwiZ2V0Q29tcHV0ZWRTdHlsZXMiLCJzZXRDb21wdXRlZFN0eWxlcyIsInJldHVybk51bGwiLCJ1c2VSZWZFbGVtZW50UHJvcHMiLCJ1c2VFbGVtZW50U2l6ZVByb3BzIiwidXNlRWxlbWVudFNpemUiLCJvblNpemVDaGFuZ2UiLCJfIiwiZ2V0TG9naWNhbERpcmVjdGlvbkluZm8iLCJjb21wdXRlZFN0eWxlcyIsInciLCJ3cml0aW5nTW9kZSIsImQiLCJkaXJlY3Rpb24iLCJ0ZXh0T3JpZW50YXRpb24iLCJXcml0aW5nTW9kZXMiLCJjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb24iLCJlbGVtZW50T3JpZW50YXRpb24iLCJjb252ZXJ0VG9QaHlzaWNhbFNpZGUiLCJzaWRlIiwiTSIsImJsb2NrRGlyZWN0aW9uIiwiaW5saW5lRGlyZWN0aW9uIiwiaW5saW5lT3JpZW50YXRpb24iLCJjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uIiwiYmxvY2tPcmllbnRhdGlvbiIsImNvbnZlcnRFbGVtZW50U2l6ZSIsImVsZW1lbnRTaXplIiwiaW5saW5lU2l6ZSIsImJsb2NrU2l6ZSIsImNhcGl0YWxpemUiLCJjbGllbnRCbG9ja1NpemUiLCJvZmZzZXRJbmxpbmVTaXplIiwib2Zmc2V0QmxvY2tTaXplIiwic2Nyb2xsSW5saW5lU2l6ZSIsInNjcm9sbEJsb2NrU2l6ZSIsImYxIiwiZ2V0UGh5c2ljYWxMZWZ0VG9wIiwiZjIiLCJnZXRQaHlzaWNhbFJpZ2h0Qm90dG9tIiwiZjMiLCJmNCIsImNsaWVudElubGluZUluc2V0Iiwic2Nyb2xsSW5saW5lSW5zZXQiLCJvZmZzZXRJbmxpbmVJbnNldCIsInNjcm9sbEJsb2NrSW5zZXQiLCJvZmZzZXRCbG9ja0luc2V0IiwiY2xpZW50QmxvY2tJbnNldCIsImRpciIsImIiLCJsIiwidXNlVGltZW91dCIsInRpbWVvdXQiLCJ0cmlnZ2VySW5kZXgiLCJzdGFibGVDYWxsYmFjayIsInN0YXJ0VGltZVJlZiIsImdldFRpbWVvdXQiLCJ0aW1lb3V0SXNOdWxsIiwibmF2aWdhdGVUb0ZpcnN0IiwibnRmIiwibmF2aWdhdGVUb0xhc3QiLCJudGwiLCJuYXZpZ2F0ZVRvTmV4dCIsIm50biIsIm5hdmlnYXRlVG9QcmV2IiwibnRwIiwibmF2aWdhdGlvbkRpcmVjdGlvbiIsIm5kIiwiZGlzYWJsZUFycm93S2V5cyIsImRhayIsImRpc2FibGVIb21lRW5kS2V5cyIsImRoZWsiLCJ1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHMiLCJnZXREaXNhYmxlQXJyb3dLZXlzIiwiZ2V0RGlzYWJsZUhvbWVFbmRLZXlzIiwidXNlTGluZWFyTmF2aWdhdGlvblByb3BzIiwib25LZXlEb3duIiwiY3RybEtleSIsImdldE5hdmlnYXRpb25EaXJlY3Rpb24iLCJhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uIiwicHJvcE5hbWUiLCJkaXJlY3Rpb25BbGxvd2VkIiwiYWxsb3dzQmxvY2tOYXZpZ2F0aW9uIiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJnZXRJbWVBY3RpdmUiLCJzZXROZXh0VHlwZWFoZWFkQ2hhciIsIm5leHRUeXBlYWhlYWRDaGFyIiwic2V0Q3VycmVudFR5cGVhaGVhZCIsInR5cGVhaGVhZCIsImNvbXBhcmF0b3JTaGFyZWQiLCJzYWZlTGhzIiwic2FmZVJocyIsImNvbGxhdG9yIiwidG9Mb3dlckNhc2UiLCJsb2NhbGVDb21wYXJlIiwiaW5zZXJ0aW5nQ29tcGFyYXRvciIsInRleHQiLCJzdWJzdHJpbmciLCJub1R5cGVhaGVhZCIsInVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyIsIm9uQ29tcG9zaXRpb25TdGFydCIsIl9lIiwic2V0SW1lQWN0aXZlIiwib25Db21wb3NpdGlvbkVuZCIsImRhdGEiLCJpc0Rpc2FibGVkIiwiaW1lQWN0aXZlIiwicmV2ZXJzZSIsImlzQ2hhcmFjdGVyS2V5IiwidGVzdCIsImdldEN1cnJlbnRUeXBlYWhlYWQiLCJ0cmltIiwidXNlUm92aW5nVGFiSW5kZXgiLCJpbml0aWFsSW5kZXgiLCJvbkNoaWxkcmVuTW91bnRDaGFuZ2VVc2VyIiwib25UYWJiYWJsZVJlbmRlciIsIm9uVGFiYmFibGVJbmRleENoYW5nZSIsIm9uVGFiYmVkSW5UbyIsIm9uQW55Rm9jdXNJbiIsIm9uVGFiYmVkT3V0T2YiLCJvbkFueUZvY3VzT3V0Iiwic3RhYmxlT25UYWJiYWJsZVJlbmRlciIsImdldEFueUZvY3VzZWQiLCJzZXRBbnlGb2N1c2VkIiwibmV3Q291bnQiLCJvbGRDb3VudCIsInJldHVyblplcm8iLCJnZXRUYWJiYWJsZUluZGV4Iiwic2V0VGFiYmFibGVJbmRleDIiLCJzZXRUYWJiYWJsZUluZGV4IiwiZnJvbVVzZXJJbnRlcmFjdGlvbiIsIm5leHRJbmRleCIsInByZXZJbmRleCIsImNoYW5nZUluZGV4IiwibmV4dENoaWxkIiwicHJldkNoaWxkIiwiZm9jdXNTZWxmIiwiYmx1clNlbGYiLCJ1bm1vdW50ZWQiLCJ1c2VDaGlsZHJlbkZsYWciLCJjbG9zZXN0Rml0IiwiZml0TnVsbFRvWmVybyIsInVzZVJvdmluZ1RhYkluZGV4Q2hpbGQiLCJmbGFncyIsImJzIiwiZnMiLCJyZXN0SW5mbyIsImlkZW50aXR5IiwidXNlTGlzdE5hdmlnYXRpb24iLCJ0eXBlYWhlYWRUaW1lb3V0IiwiaW5kZXhNYW5nbGVyIiwiaW5kZXhEZW1hbmdsZXIiLCJ1c2VSYW5kb21JZCIsImJhY2t1cFJhbmRvbUlkIiwiZ2V0QmFja3VwUmFuZG9tSWQiLCJ1c2VkSWQiLCJzZXRVc2VkSWQiLCJnZXRVc2VkSWQiLCJtaXNtYXRjaEVycm9yUmVmIiwidXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50IiwidXNlZElkTG9jYWwiLCJzZXRVc2VkSWRMb2NhbCIsImdldFVzZWRJZExvY2FsIiwiZXhjbHVkZXMiLCJleGNsdWRlIiwidXNlUHJlc3NFdmVudEhhbmRsZXJzIiwib25DbGlja1N5bmMiLCJhY3RpdmUiLCJnZXRBY3RpdmUiLCJ0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lIiwic2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSIsInVzZUdsb2JhbEhhbmRsZXIiLCJwcmV2Iiwibm9kZVNlbGVjdGVkVGV4dExlbmd0aCIsIkRhdGUiLCJhIiwiY3VycmVudFRpbWUiLCJ0aW1lRGlmZmVyZW5jZSIsImhhbmRsZVByZXNzIiwicHVsc2UiLCJkZXRhaWwiLCJidXR0b24iLCJvbkFjdGl2ZVN0YXJ0Iiwib25Nb3VzZVVwIiwib25BY3RpdmVTdG9wIiwib25CbHVyIiwic2V0QWN0aXZlIiwib25Nb3VzZUxlYXZlIiwidXNlQXJpYUFjY29yZGlvbiIsIl9jdXJyZW50Rm9jdXNlZEluZGV4Iiwic2V0Q3VycmVudEZvY3VzZWRJbmRleCIsImdldEN1cnJlbnRGb2N1c2VkSW5kZXgiLCJ1c2VNYW5hZ2VkQ2hpbGRTZWN0aW9uIiwibSIsInUiLCJvY21jMSIsIm9jbWMyIiwiY2hhbmdlVGFiYmVkSW5kZXgiLCJ1c2VMaW5lYXJOYXZpZ2F0aW9uIiwiY2hhbmdlRXhwYW5kZWRJbmRleCIsImdldEN1cnJlbnRJbmRleCIsImdldEN1cnJlbnRFeHBhbmRlZEluZGV4IiwiZ2V0VGFiYmVkSW5kZXgiLCJvbkluZGV4Q2hhbmdlIiwib3BlbkZyb21QYXJlbnQiLCJzZXRPcGVuRnJvbVBhcmVudCIsImdldE9wZW5Gcm9tUGFyZW50IiwidXNlQm9keUFzU291cmNlSWQiLCJ1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50IiwidXNlSGVhZGVyQXNSZWZlcmVuY2VySWQiLCJ1c2VIZWFkZXJBc1NvdXJjZUlkIiwidXNlQm9keUFzUmVmZXJlbmNlcklkIiwidXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHMiLCJ1c2VCb2R5QXNTb3VyY2VJZFByb3BzIiwidXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIiwidXNlQm9keUFzUmVmZXJlbmNlcklkUHJvcHMiLCJ1c2VIZWFkZXJBc1NvdXJjZUlkUHJvcHMiLCJ1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZFByb3BzIiwib3BlbiIsIm9wZW5Gcm9tVXNlciIsImdldEluZGV4IiwiZ2V0SGVhZGVyRWxlbWVudCIsInVzZUhlYWRlclJlZkVsZW1lbnRQcm9wcyIsImdldEJvZHlFbGVtZW50IiwidXNlQm9keVJlZkVsZW1lbnRQcm9wcyIsIm9wZW5SZWYiLCJ1c2VMYWJlbCIsImxhYmVsUHJlZml4IiwiaW5wdXRQcmVmaXgiLCJ0YWdJbnB1dCIsInRhZ0xhYmVsIiwidXNlTGFiZWxBc1NvdXJjZUlkIiwidXNlTGFiZWxBc1JlZmVyZW5jZXJJZCIsImxhYmVsSWQiLCJ1c2VJbnB1dEFzU291cmNlSWQiLCJ1c2VJbnB1dEFzUmVmZXJlbmNlcklkIiwiaW5wdXRJZCIsInVzZUxhYmVsQXNTb3VyY2VJZFByb3BzIiwidXNlTGFiZWxBc1JlZmVyZW5jZXJJZFByb3BzIiwidXNlSW5wdXRBc1JlZmVyZW5jZXJJZFByb3BzIiwiaXNTeW50aGV0aWNMYWJlbCIsInVzZUxhYmVsTGFiZWwiLCJ1c2VMYWJlbExhYmVsUHJvcHMiLCJwcm9wc1dpdGhvdXRGb3IiLCJwcm9wc1dpdGhGb3IiLCJ1c2VMYWJlbElucHV0IiwidXNlTGFiZWxJbnB1dFByb3BzIiwiYXJpYUxhYmVsbGVkYnkiLCJwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeSIsInVzZUlucHV0QXNTb3VyY2VJZFByb3BzIiwicHJvcHNXaXRoQXJpYUxhYmVsbGVkQnkiLCJoYW5kbGVzSW5wdXQiLCJ0YWciLCJsYWJlbFBvc2l0aW9uIiwid2hpY2giLCJ1c2VDaGVja2JveExpa2UiLCJjaGVja2VkIiwib25JbnB1dCIsInJvbGUiLCJzdGFibGVPbklucHV0IiwidXNlSUxJbnB1dCIsInVzZUlMTGFiZWwiLCJnZXRMYWJlbEVsZW1lbnQiLCJ1c2VMYWJlbFJlZkVsZW1lbnRQcm9wcyIsImdldElucHV0RWxlbWVudCIsInVzZUlucHV0UmVmRWxlbWVudFByb3BzIiwidXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50IiwidXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQiLCJ1c2VJTElucHV0UHJvcHMiLCJ1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyIsInAwIiwidXNlQXJpYUNoZWNrYm94Iiwib25JbnB1dEVuaGFuY2VkIiwiZW5oYW5jZUV2ZW50IiwidXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50IiwiaXNNaXhlZCIsImlucHV0RWxlbWVudCIsImluZGV0ZXJtaW5hdGUiLCJ1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzIiwidXNlQ2hlY2tib3hHcm91cCIsImFsbElkcyIsImFyaWFDb250cm9scyIsInNldEFyaWFDb250cm9scyIsImNoZWNrZWRDb3VudCIsInNldENoZWNrZWRDb3VudCIsImNoZWNrZWRJbmRpY2VzIiwiZ2V0U2VsZklzQ2hlY2tlZFVuc3RhYmxlIiwicGVyY2VudGFnZSIsImdldFNlbGZJc0NoZWNrZWRTdGFibGUiLCJzZXRTZXRQYXJlbnRDaGVja2JveENoZWNrZWQiLCJzZXRQYXJlbnRDaGVja2JveENoZWNrZWQiLCJzZXRDaGVja2VkIiwidXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQiLCJvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dDIiLCJ1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIiwidXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0UHJvcHMiLCJ1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyIsInNlbGZJc0NoZWNrZWQiLCJuZXh0Q2hlY2tlZCIsInVzZVNvZnREaXNtaXNzIiwib25DbG9zZSIsImdldEVsZW1lbnRzIiwic3RhYmxlR2V0RWxlbWVudHMiLCJnZXRPcGVuIiwib25CYWNrZHJvcENsaWNrIiwic3RhYmxlT25DbG9zZSIsImZvdW5kSW5zaWRlQ2xpY2siLCJ1c2VBY3RpdmVFbGVtZW50UHJvcHMiLCJ1c2VBY3RpdmVFbGVtZW50Iiwib25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSIsIm5ld0VsZW1lbnQiLCJ2YWxpZEZvY3VzYWJsZUVsZW1lbnRzIiwiZm9jdXNhYmxlIiwibW91c2VEb3duIiwidG91Y2hTdGFydCIsImtleURvd24iLCJjYXB0dXJlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVzZVNvZnREaXNtaXNzUHJvcHMiLCJ1c2VNb2RhbCIsInNldE1vZGFsRGVzY3JpYmVkQnlCb2R5IiwidXNlTW9kYWxJZEFzU291cmNlIiwidXNlTW9kYWxJZEFzUmVmZXJlbmNlckVsZW1lbnQiLCJ1c2VCb2R5SWRBc1NvdXJjZSIsInVzZUJvZHlJZFJlZmVyZW5jZXJFbGVtZW50IiwidXNlVGl0bGVJZFJlZmVyZW5jZXJFbGVtZW50IiwidXNlTW9kYWxJZEFzU291cmNlUHJvcHMiLCJ1c2VUaXRsZUlkQXNTb3VyY2UiLCJ1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudFByb3BzIiwidXNlQm9keUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyIsInVzZVRpdGxlSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIiwidXNlTW9kYWxSZWZFbGVtZW50IiwiZ2V0TW9kYWxFbGVtZW50IiwidXNlTW9kYWxCYWNrZHJvcCIsInVzZU1vZGFsQmFja2Ryb3BQcm9wcyIsIm9uUG9pbnRlclVwIiwiYXJpYU1vZGFsIiwidXNlRm9jdXNUcmFwUHJvcHMiLCJwMSIsInAyIiwibW9kYWxEZXNjcmliZWRCeUJvZHkiLCJwRmluYWwiLCJ1c2VNb2RhbFRpdGxlIiwidXNlTW9kYWxUaXRsZVByb3BzIiwidXNlTW9kYWxCb2R5IiwiZGVzY3JpcHRpdmUiLCJ1c2VBcmlhRGlhbG9nIiwidXNlTW9kYWxQcm9wcyIsInVzZURpYWxvZ0JhY2tkcm9wIiwidXNlRGlhbG9nQmFja2Ryb3BQcm9wcyIsInVzZURpYWxvZ0JvZHkiLCJ1c2VNb2RhbEJvZHlQcm9wcyIsInVzZURpYWxvZ0JvZHlQcm9wcyIsInVzZUFyaWFMaXN0Ym94TXVsdGkiLCJ0YWdMaXN0IiwidXNlTGlzdE5hdmlnYXRpb25DaGlsZCIsInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMiLCJjdXJyZW50VHlwZWFoZWFkIiwiaW52YWxpZFR5cGVhaGVhZCIsInNldFNoaWZ0SGVsZCIsImdldFNoaWZ0SGVsZCIsInR5cGVhaGVhZEluUHJvZ3Jlc3MiLCJzZXRUeXBlYWhlYWRJblByb2dyZXNzIiwidXNlTGlzdGJveE11bHRpSXRlbSIsInNlbGVjdGVkIiwiaGlkZGVuIiwib25TZWxlY3QiLCJnZXRTZWxlY3RlZCIsInN0YWJsZU9uU2VsZWN0IiwidGFiYmFibGUiLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMiLCJ1c2VBcmlhTGlzdGJveFNpbmdsZSIsInNlbGVjdGVkSW5kZXgiLCJvdGljIiwic2VsZWN0aW9uTW9kZSIsInVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQiLCJ1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzIiwidXNlTWVudUJhc2UiLCJzZW5kRm9jdXNXaXRoaW5NZW51IiwiZ2V0U2VuZEZvY3VzV2l0aGluTWVudSIsImZvY3VzVHJhcEFjdGl2ZSIsInNldEZvY3VzVHJhcEFjdGl2ZSIsIm9uT3BlbiIsInVzZUhhc0ZvY3VzUHJvcHMiLCJ1c2VNZW51QmFzZUhhc0ZvY3VzUHJvcHMiLCJnZXRMYXN0Rm9jdXNlZElubmVyIiwiZ2V0TWVudUJhc2VMYXN0Rm9jdXNlZElubmVyIiwidXNlSGFzRm9jdXMiLCJ1c2VCdXR0b25IYXNGb2N1c1Byb3BzIiwiZ2V0TWVudUJhc2VCdXR0b25MYXN0Rm9jdXNlZElubmVyIiwic2V0T3BlbmVyRWxlbWVudCIsImdldE9wZW5lckVsZW1lbnQiLCJnZXRCdXR0b25FbGVtZW50IiwidXNlQnV0dG9uUmVmRWxlbWVudFByb3BzIiwidXNlTWVudUJhc2VSZWZFbGVtZW50UHJvcHMiLCJnZXRNZW51RWxlbWVudCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInVzZU1lbnVCYXNlQnV0dG9uUHJvcHMiLCJwcmV2ZW50U2Nyb2xsIiwidXNlTWVudVNlbnRpbmVsIiwidXNlU2VudGluZWxQcm9wcyIsInVzZU1lbnVTZW50aW5lbFByb3BzIiwicmVzdCIsInVzZUZvY3VzU2VudGluZWwiLCJ1c2VNZW51QmFzZVByb3BzIiwiZ2V0UmFkaW9Hcm91cFBhcmVudEVsZW1lbnQiLCJzZXRTZWxlY3RlZEluZGV4IiwiYnlOYW1lIiwidXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb24iLCJvY21jIiwidXNlR3JvdXBMYWJlbElucHV0UHJvcHMiLCJ1c2VSYWRpb0dyb3VwTGFiZWxQcm9wcyIsInVzZUdyb3VwTGFiZWxMYWJlbFByb3BzIiwic2VsZWN0ZWRWYWx1ZSIsInVzZVJhZGlvIiwidXNlQXJpYVJhZGlvIiwiZ2V0Q2hlY2tlZCIsInVzZUFyaWFUYWJzIiwib3JpZW50YXRpb24iLCJsb2dpY2FsT3JpZW50YXRpb24iLCJ0YWJzIiwidXNlVGFiIiwidXNlVGFiUGFuZWwiLCJ1c2VBcmlhVG9vbHRpcCIsIm1vdXNlb3ZlckRlbGF5IiwibW91c2VvdXREZWxheSIsImZvY3VzRGVsYXkiLCJkZWZhdWx0UHJldmVudGVkIiwic2V0T3BlbiIsInNldFRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkIiwic2V0VG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQiLCJzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIiwic2V0VG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCIsInNldFRyaWdnZXJGb2N1c2VkIiwiZm9jdXNlZCIsImRlbGF5IiwiaXNGaW5pdGUiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiaGFuZGxlIiwicmV0dXJuRmFsc2UiLCJzZXRUb29sdGlwRm9jdXNlZCIsInNldFRyaWdnZXJIb3ZlciIsImhvdmVyaW5nIiwic2V0VG9vbHRpcEhvdmVyIiwidHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQiLCJ0b29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkIiwidG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQiLCJ0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIiwidXNlVG9vbHRpcFRyaWdnZXIiLCJvblRvdWNoRW5kIiwib25Gb2N1c2VkSW5uZXJDaGFuZ2VkIiwidXNlVG9vbHRpcFRyaWdnZXJQcm9wcyIsIm1lbW8iLCJfanN4IiwiX2pzeHMiLCJ1c2VDb250ZXh0IiwiX0ZyYWdtZW50IiwicmVuZGVyIl0sIm1hcHBpbmdzIjoiOzs7QUFHSUEsU0FBQUEsQ0FBQUE7SUFBQUEsT0FBQUEsQ0FBQUE7SUFBQUEsT0FBQUEsQ0FBQUE7SUFBQUEsT0FBQUEsQ0FBQUE7SUFBQUEsT0FBQUEsQ0FBQUE7SUFBQUEsT0FBQUEsQ0FBQUE7SUFBQUEsSUN1S0FDLE1DektxQixFRkVyQkQsQ0FBQUE7SUFBQUEsWUFBQUEsQ0FBQUE7SUFBQUEsOEVBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzthR2tCZ0ZFLG1CQUFBQyxnQkFBQTtJQUFBLEVBQUEsS0FBQSxJQUFBLElBQUEsR0FBQSxTQUFBLENBQUEsTUFBQSxFQUFBQyxNQUFBLEdBQUEsSUFBQSxLQUFBLENBQUEsSUFBQSxHQUFBLENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxFQUFBLElBQUEsR0FBQSxDQUFBLEVBQUEsSUFBQSxHQUFBLElBQUEsRUFBQSxJQUFBLEVBQUEsRUFBQTtRQUFBQSxNQUFBLENBQUEsSUFBQSxHQUFBLENBQUEsQ0FBQSxHQUFBLFNBQUEsQ0FBQSxJQUFBLENBQUEsQ0FBQTtJQUFBLEdBQUE7O0lBQzVFQyxFQUFBQSxTQUFBLENBQU1ELGFBQU4sR0FBQSxDQUFBLENBQUE7TUFDQUEsTUFBQSxDQUFBRSxPQUFBLFVBQUEsQ0FBQSxDQUFBO0lBQ0EsRUFBQSxPQUFBOztJQUdRLEVBQUEsU0FBQUQsU0FBQSxDQUFTRSxLQUFULEVBQVNDLEtBQVQsRUFBUztJQUVUO0lBQ0gsSUFBQSxNQUFBQyx1QkFBQSxHQUFBQyxDQUFB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
