(function () {
    'use strict';

    var n,
        l$1,
        u$1,
        t$1,
        o$2,
        r$2,
        f$1 = {},
        e$2 = [],
        c$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function s$1(n, l) {
      for (var u in l) n[u] = l[u];

      return n;
    }

    function a$1(n) {
      var l = n.parentNode;
      l && l.removeChild(n);
    }

    function h$1(l, u, i) {
      var t,
          o,
          r,
          f = {};

      for (r in u) "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];

      if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) void 0 === f[r] && (f[r] = l.defaultProps[r]);
      return v$1(l, f, t, o, null);
    }

    function v$1(n, i, t, o, r) {
      var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u$1 : r
      };
      return null == r && null != l$1.vnode && l$1.vnode(f), f;
    }

    function p$1(n) {
      return n.children;
    }

    function d$1(n, l) {
      this.props = n, this.context = l;
    }

    function _$1(n, l) {
      if (null == l) return n.__ ? _$1(n.__, n.__.__k.indexOf(n) + 1) : null;

      for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;

      return "function" == typeof n.type ? _$1(n) : null;
    }

    function k$1(n) {
      var l, u;

      if (null != (n = n.__) && null != n.__c) {
        for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
          n.__e = n.__c.base = u.__e;
          break;
        }

        return k$1(n);
      }
    }

    function b$1(n) {
      (!n.__d && (n.__d = !0) && t$1.push(n) && !g$2.__r++ || o$2 !== l$1.debounceRendering) && ((o$2 = l$1.debounceRendering) || setTimeout)(g$2);
    }

    function g$2() {
      for (var n; g$2.__r = t$1.length;) n = t$1.sort(function (n, l) {
        return n.__v.__b - l.__v.__b;
      }), t$1 = [], n.some(function (n) {
        var l, u, i, t, o, r;
        n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = s$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? _$1(t) : o, t.__h), z$1(u, t), t.__e != o && k$1(t)));
      });
    }

    function w$2(n, l, u, i, t, o, r, c, s, a) {
      var h,
          y,
          d,
          k,
          b,
          g,
          w,
          x = i && i.__k || e$2,
          C = x.length;

      for (u.__k = [], h = 0; h < l.length; h++) if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? v$1(null, k, null, null, k) : Array.isArray(k) ? v$1(p$1, {
        children: k
      }, null, null, null) : k.__b > 0 ? v$1(k.type, k.props, k.key, null, k.__v) : k)) {
        if (k.__ = u, k.__b = u.__b + 1, null === (d = x[h]) || d && k.key == d.key && k.type === d.type) x[h] = void 0;else for (y = 0; y < C; y++) {
          if ((d = x[y]) && k.key == d.key && k.type === d.type) {
            x[y] = void 0;
            break;
          }

          d = null;
        }
        j$2(n, k, d = d || f$1, t, o, r, c, s, a), b = k.__e, (y = k.ref) && d.ref != y && (w || (w = []), d.ref && w.push(d.ref, null, k), w.push(y, k.__c || b, k)), null != b ? (null == g && (g = b), "function" == typeof k.type && k.__k === d.__k ? k.__d = s = m$1(k, s, n) : s = A$1(n, k, d, x, b, s), "function" == typeof u.type && (u.__d = s)) : s && d.__e == s && s.parentNode != n && (s = _$1(d));
      }

      for (u.__e = g, h = C; h--;) null != x[h] && ("function" == typeof u.type && null != x[h].__e && x[h].__e == u.__d && (u.__d = _$1(i, h + 1)), N(x[h], x[h]));

      if (w) for (h = 0; h < w.length; h++) M$1(w[h], w[++h], w[++h]);
    }

    function m$1(n, l, u) {
      for (var i, t = n.__k, o = 0; t && o < t.length; o++) (i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? m$1(i, l, u) : A$1(u, i, i, t, i.__e, l));

      return l;
    }

    function x$1(n, l) {
      return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
        x$1(n, l);
      }) : l.push(n)), l;
    }

    function A$1(n, l, u, i, t, o) {
      var r, f, e;
      if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
        for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) if (f == t) break n;

        n.insertBefore(t, o), r = o;
      }
      return void 0 !== r ? r : t.nextSibling;
    }

    function C$1(n, l, u, i, t) {
      var o;

      for (o in u) "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);

      for (o in l) t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
    }

    function $$1(n, l, u) {
      "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || c$1.test(l) ? u : u + "px";
    }

    function H$1(n, l, u, i, t) {
      var o;

      n: if ("style" === l) {
        if ("string" == typeof u) n.style.cssText = u;else {
          if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || $$1(n.style, l, "");
          if (u) for (l in u) i && u[l] === i[l] || $$1(n.style, l, u[l]);
        }
      } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$2 : I, o) : n.removeEventListener(l, o ? T$2 : I, o);else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
          n[l] = null == u ? "" : u;
          break n;
        } catch (n) {}
        "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
      }
    }

    function I(n) {
      this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
    }

    function T$2(n) {
      this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
    }

    function j$2(n, u, i, t, o, r, f, e, c) {
      var a,
          h,
          v,
          y,
          _,
          k,
          b,
          g,
          m,
          x,
          A,
          C,
          $,
          H = u.type;

      if (void 0 !== u.constructor) return null;
      null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (a = l$1.__b) && a(u);

      try {
        n: if ("function" == typeof H) {
          if (g = u.props, m = (a = H.contextType) && t[a.__c], x = a ? m ? m.props.value : a.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in H && H.prototype.render ? u.__c = h = new H(g, x) : (u.__c = h = new d$1(g, x), h.constructor = H, h.render = O$1), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != H.getDerivedStateFromProps && (h.__s == h.state && (h.__s = s$1({}, h.__s)), s$1(h.__s, H.getDerivedStateFromProps(g, h.__s))), y = h.props, _ = h.state, v) null == H.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
            if (null == H.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
              h.props = g, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
                n && (n.__ = u);
              }), h.__h.length && f.push(h);
              break n;
            }

            null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
              h.componentDidUpdate(y, _, k);
            });
          }
          if (h.context = x, h.props = g, h.__v = u, h.__P = n, A = l$1.__r, C = 0, "prototype" in H && H.prototype.render) h.state = h.__s, h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context);else do {
            h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
          } while (h.__d && ++C < 25);
          h.state = h.__s, null != h.getChildContext && (t = s$1(s$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, _)), $ = null != a && a.type === p$1 && null == a.key ? a.props.children : a, w$2(n, Array.isArray($) ? $ : [$], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);

        (a = l$1.diffed) && a(u);
      } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
      }
    }

    function z$1(n, u) {
      l$1.__c && l$1.__c(u, n), n.some(function (u) {
        try {
          n = u.__h, u.__h = [], n.some(function (n) {
            n.call(u);
          });
        } catch (n) {
          l$1.__e(n, u.__v);
        }
      });
    }

    function L$1(l, u, i, t, o, r, e, c) {
      var s,
          h,
          v,
          y = i.props,
          p = u.props,
          d = u.type,
          k = 0;
      if ("svg" === d && (o = !0), null != r) for (; k < r.length; k++) if ((s = r[k]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
        l = s, r[k] = null;
        break;
      }

      if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
      }

      if (null === d) y === p || c && l.data === p || (l.data = p);else {
        if (r = r && n.call(l.childNodes), h = (y = i.props || f$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
          if (null != r) for (y = {}, k = 0; k < l.attributes.length; k++) y[l.attributes[k].name] = l.attributes[k].value;
          (v || h) && (v && (h && v.__html == h.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }

        if (C$1(l, p, y, o, c), v) u.__k = [];else if (k = u.props.children, w$2(l, Array.isArray(k) ? k : [k], u, i, t, o && "foreignObject" !== d, r, e, r ? r[0] : i.__k && _$1(i, 0), c), null != r) for (k = r.length; k--;) null != r[k] && a$1(r[k]);
        c || ("value" in p && void 0 !== (k = p.value) && (k !== l.value || "progress" === d && !k || "option" === d && k !== y.value) && H$1(l, "value", k, y.value, !1), "checked" in p && void 0 !== (k = p.checked) && k !== l.checked && H$1(l, "checked", k, y.checked, !1));
      }
      return l;
    }

    function M$1(n, u, i) {
      try {
        "function" == typeof n ? n(u) : n.current = u;
      } catch (n) {
        l$1.__e(n, i);
      }
    }

    function N(n, u, i) {
      var t, o;

      if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$1(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
          t.componentWillUnmount();
        } catch (n) {
          l$1.__e(n, u);
        }
        t.base = t.__P = null;
      }

      if (t = n.__k) for (o = 0; o < t.length; o++) t[o] && N(t[o], u, "function" != typeof n.type);
      i || null == n.__e || a$1(n.__e), n.__e = n.__d = void 0;
    }

    function O$1(n, l, u) {
      return this.constructor(n, u);
    }

    function P$1(u, i, t) {
      var o, r, e;
      l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, e = [], j$2(i, u = (!o && t || i).__k = h$1(p$1, null, [u]), r || f$1, f$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, e, !o && t ? t : r ? r.__e : i.firstChild, o), z$1(e, u);
    }

    function B(n, l) {
      var u = {
        __c: l = "__cC" + r$2++,
        __: n,
        Consumer: function (n, l) {
          return n.children(l);
        },
        Provider: function (n) {
          var u, i;
          return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
            return i;
          }, this.shouldComponentUpdate = function (n) {
            this.props.value !== n.value && u.some(b$1);
          }, this.sub = function (n) {
            u.push(n);
            var l = n.componentWillUnmount;

            n.componentWillUnmount = function () {
              u.splice(u.indexOf(n), 1), l && l.call(n);
            };
          }), n.children;
        }
      };
      return u.Provider.__ = u.Consumer.contextType = u;
    }

    n = e$2.slice, l$1 = {
      __e: function (n, l, u, i) {
        for (var t, o, r; l = l.__;) if ((t = l.__c) && !t.__) try {
          if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), r) return t.__E = t;
        } catch (l) {
          n = l;
        }

        throw n;
      }
    }, u$1 = 0, d$1.prototype.setState = function (n, l) {
      var u;
      u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s$1({}, this.state), "function" == typeof n && (n = n(s$1({}, u), this.props)), n && s$1(u, n), null != n && this.__v && (l && this.__h.push(l), b$1(this));
    }, d$1.prototype.forceUpdate = function (n) {
      this.__v && (this.__e = !0, n && this.__h.push(n), b$1(this));
    }, d$1.prototype.render = p$1, t$1 = [], g$2.__r = 0, r$2 = 0;

    var o$1 = 0;

    function e$1(_, e, n, t, f) {
      var l,
          s,
          u = {};

      for (s in e) "ref" == s ? l = e[s] : u[s] = e[s];

      var a = {
        type: _,
        props: u,
        key: n,
        ref: l,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: --o$1,
        __source: f,
        __self: t
      };
      if ("function" == typeof _ && (l = _.defaultProps)) for (s in l) void 0 === u[s] && (u[s] = l[s]);
      return l$1.vnode && l$1.vnode(a), a;
    }

    var t,
        r$1,
        u,
        i,
        o = 0,
        c = [],
        f = [],
        e = l$1.__b,
        a = l$1.__r,
        v = l$1.diffed,
        l = l$1.__c,
        m = l$1.unmount;

    function d(t, u) {
      l$1.__h && l$1.__h(r$1, t, o || u), o = 0;
      var i = r$1.__H || (r$1.__H = {
        __: [],
        __h: []
      });
      return t >= i.__.length && i.__.push({
        __V: f
      }), i.__[t];
    }

    function p(n) {
      return o = 1, y(z, n);
    }

    function y(n, u, i) {
      var o = d(t++, 2);

      if (o.t = n, !o.__c && (o.__ = [i ? i(u) : z(void 0, u), function (n) {
        var t = o.__N ? o.__N[0] : o.__[0],
            r = o.t(t, n);
        t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
      }], o.__c = r$1, !r$1.u)) {
        r$1.u = !0;
        var c = r$1.shouldComponentUpdate;

        r$1.shouldComponentUpdate = function (n, t, r) {
          if (!o.__c.__H) return !0;

          var u = o.__c.__H.__.filter(function (n) {
            return n.__c;
          });

          if (u.every(function (n) {
            return !n.__N;
          })) return !c || c.call(this, n, t, r);
          var i = !1;
          return u.forEach(function (n) {
            if (n.__N) {
              var t = n.__[0];
              n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
            }
          }), !!i && (!c || c.call(this, n, t, r));
        };
      }

      return o.__N || o.__;
    }

    function h(u, i) {
      var o = d(t++, 3);
      !l$1.__s && w$1(o.__H, i) && (o.__ = u, o.i = i, r$1.__H.__h.push(o));
    }

    function s(u, i) {
      var o = d(t++, 4);
      !l$1.__s && w$1(o.__H, i) && (o.__ = u, o.i = i, r$1.__h.push(o));
    }

    function _(n) {
      return o = 5, F$1(function () {
        return {
          current: n
        };
      }, []);
    }

    function F$1(n, r) {
      var u = d(t++, 7);
      return w$1(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;
    }

    function T$1(n, t) {
      return o = 8, F$1(function () {
        return n;
      }, t);
    }

    function q$1(n) {
      var u = r$1.context[n.__c],
          i = d(t++, 9);
      return i.c = n, u ? (null == i.__ && (i.__ = !0, u.sub(r$1)), u.props.value) : n.__;
    }

    function b() {
      for (var t; t = c.shift();) if (t.__P && t.__H) try {
        t.__H.__h.forEach(j$1), t.__H.__h.forEach(k), t.__H.__h = [];
      } catch (r) {
        t.__H.__h = [], l$1.__e(r, t.__v);
      }
    }

    l$1.__b = function (n) {
      r$1 = null, e && e(n);
    }, l$1.__r = function (n) {
      a && a(n), t = 0;
      var i = (r$1 = n.__c).__H;
      i && (u === r$1 ? (i.__h = [], r$1.__h = [], i.__.forEach(function (n) {
        n.__N && (n.__ = n.__N), n.__V = f, n.__N = n.i = void 0;
      })) : (i.__h.forEach(j$1), i.__h.forEach(k), i.__h = [])), u = r$1;
    }, l$1.diffed = function (t) {
      v && v(t);
      var o = t.__c;
      o && o.__H && (o.__H.__h.length && (1 !== c.push(o) && i === l$1.requestAnimationFrame || ((i = l$1.requestAnimationFrame) || function (n) {
        var t,
            r = function () {
          clearTimeout(u), g$1 && cancelAnimationFrame(t), setTimeout(n);
        },
            u = setTimeout(r, 100);

        g$1 && (t = requestAnimationFrame(r));
      })(b)), o.__H.__.forEach(function (n) {
        n.i && (n.__H = n.i), n.__V !== f && (n.__ = n.__V), n.i = void 0, n.__V = f;
      })), u = r$1 = null;
    }, l$1.__c = function (t, r) {
      r.some(function (t) {
        try {
          t.__h.forEach(j$1), t.__h = t.__h.filter(function (n) {
            return !n.__ || k(n);
          });
        } catch (u) {
          r.some(function (n) {
            n.__h && (n.__h = []);
          }), r = [], l$1.__e(u, t.__v);
        }
      }), l && l(t, r);
    }, l$1.unmount = function (t) {
      m && m(t);
      var r,
          u = t.__c;
      u && u.__H && (u.__H.__.forEach(function (n) {
        try {
          j$1(n);
        } catch (n) {
          r = n;
        }
      }), r && l$1.__e(r, u.__v));
    };
    var g$1 = "function" == typeof requestAnimationFrame;

    function j$1(n) {
      var t = r$1,
          u = n.__c;
      "function" == typeof u && (n.__c = void 0, u()), r$1 = t;
    }

    function k(n) {
      var t = r$1;
      n.__c = n.__(), r$1 = t;
    }

    function w$1(n, t) {
      return !n || n.length !== t.length || t.some(function (t, r) {
        return t !== n[r];
      });
    }

    function z(n, t) {
      return "function" == typeof t ? t(n) : t;
    }

    const EventDetail = Symbol("event-detail");
    function enhanceEvent(e, detail) {
      const event = e;
      event[EventDetail] = detail;
      return event;
    }
    const alreadyWarned = new Set();
    function warnOnOverwrite(componentName, propName, propValue, newValue) {
      const key = `${componentName};${propName}`;

      if (propValue != null) {
        if (!alreadyWarned.has(key)) {
          alreadyWarned.add(key);
          console.warn(`The ${propName} attribute on ${componentName} was given a value of ${propValue} but is being overwritten to ${newValue} for conformance. Consider removing it before passing those props to ${componentName}.`);
        }
      }

      return newValue;
    }

    const HeadingLevelContext = B(0);
    function Heading(_ref) {
      let {
        children,
        heading,
        ...props
      } = _ref;
      const headingLevelBeforeUs = q$1(HeadingLevelContext);
      const newHeadingLevel = headingLevelBeforeUs + 1;
      let tag;

      if (newHeadingLevel <= 6) {
        tag = `h${newHeadingLevel}`;
      } else {
        tag = 'div';
        props["aria-level"] = warnOnOverwrite("Heading", "aria-level", props["aria-level"], `${newHeadingLevel}`);
      }

      return e$1(p$1, {
        children: e$1(HeadingReset, {
          newLevel: headingLevelBeforeUs + 1,
          children: [h$1(tag, props, heading), children]
        })
      });
    }
    function HeadingReset(_ref2) {
      let {
        newLevel,
        children
      } = _ref2;
      return e$1(HeadingLevelContext.Provider, {
        value: newLevel,
        children: children
      });
    }

    /**
     * Debug hook.
     *
     * Given a value or set of values, emits a console error if any of them change from one render to the next.
     *
     * Eventually, when useEvent lands, we hopefully won't need this.
     */

    function useEnsureStability(parentHookName) {
      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }

      useHelper(values.length, 0);
      values.forEach(useHelper);
      return;

      function useHelper(value, index) {
        // Make sure that the provided functions are perfectly stable across renders
        const helperToEnsureStability = _(value);
        const shownError = _(false);

        if (helperToEnsureStability.current != value) {
          if (!shownError.current) {
            /* eslint-disable no-debugger */
            debugger;
            console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
            shownError.current = true;
          }
        }
      }
    }
    /**
     * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
     *
     * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
     *
     * To summarize, it's like a `useState`-`useEffect` mashup:
     *
     * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
     * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
     * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
     * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
     *
     * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
     *
     * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @returns
     */

    function usePassiveState(onChange, getInitialValue) {
      const valueRef = _(Unset$1);
      const warningRef = _(false);
      const cleanupCallbackRef = _(undefined); // Make sure that the provided functions are perfectly stable across renders

      useEnsureStability("usePassiveState", onChange, getInitialValue); // Shared between "dependency changed" and "component unmounted".

      const onShouldCleanUp = T$1(() => {
        const cleanupCallback = cleanupCallbackRef.current;
        if (cleanupCallback) cleanupCallback();
      }, []); // There are a couple places where we'd like to use our initial
      // value in place of having no value at all yet.
      // This is the shared code for that, used on mount and whenever
      // getValue is called.

      const tryEnsureValue = T$1(() => {
        if (valueRef.current === Unset$1 && getInitialValue != undefined) {
          try {
            var _onChange;

            const initialValue = getInitialValue();
            valueRef.current = initialValue;
            cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
          } catch (ex) {// Exceptions are intentional to allow bailout (without exposing the Unset symbol)
          }
        }
      }, [
        /* getInitialValue and onChange intentionally omitted */
      ]);
      const getValue = T$1(() => {
        if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component."); // The first time we call getValue, if we haven't been given a value yet,
        // (and we were given an initial value to use)
        // return the initial value instead of nothing.

        if (valueRef.current === Unset$1) tryEnsureValue();
        return valueRef.current === Unset$1 ? undefined : valueRef.current;
      }, []);
      s(() => {
        // Make sure we've run our effect at least once on mount.
        // (If we have an initial value, of course)
        tryEnsureValue();
      }, []); // The actual code the user calls to (possibly) run a new effect.

      const r = _({
        microtaskQueued: false,
        arg: undefined,
        prevDep: undefined,
        handle: null
      });
      const setValue = T$1(arg => {
        r.current.prevDep = valueRef.current === Unset$1 ? undefined : getValue();
        r.current.arg = arg;

        if (!r.current.microtaskQueued) {
          r.current.microtaskQueued = true;
          r.current.handle = setTimeout(() => {
            r.current.microtaskQueued = false;
            r.current.handle = null;
            const prevDep = r.current.prevDep;
            const arg = r.current.arg;
            const dep = arg instanceof Function ? arg(prevDep) : arg;

            if (dep !== valueRef.current) {
              // Indicate to the user that they shouldn't call getValue during onChange
              warningRef.current = true;

              try {
                var _onChange2;

                // Call any registered cleanup function
                onShouldCleanUp();
                cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(dep, prevDep)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
                valueRef.current = dep;
              } finally {
                // Allow the user to normally call getValue again
                warningRef.current = false;
              }
            }
          }, 0);
        }
      }, []);
      return [getValue, setValue];
    }
    const Unset$1 = Symbol(); // Easy constants for getInitialValue

    function returnTrue() {
      return true;
    }
    function returnFalse$1() {
      return false;
    }
    function returnNull() {
      return null;
    }
    function returnZero() {
      return 0;
    }

    function useMergedChildren(_ref, _ref2) {
      let {
        children: lhs
      } = _ref;
      let {
        children: rhs
      } = _ref2;

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return h$1(p$1, {}, lhs, rhs);
      }
    }

    function r(e) {
      var t,
          f,
          n = "";
      if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
      return n;
    }

    function clsx() {
      for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);

      return n;
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */

    function useMergedClasses(_ref, _ref2) {
      let {
        class: lhsClass,
        className: lhsClassName
      } = _ref;
      let {
        class: rhsClass,
        className: rhsClassName
      } = _ref2;

      // Note: For the sake of forward compatibility, this function is labelled as
      // a hook, but as it uses no other hooks it technically isn't one.
      if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
        const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
        const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
        const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
        return Array.from(allClasses).join(" ");
      } else {
        return undefined;
      }
    }

    function processRef(instance, ref) {
      if (typeof ref === "function") {
        ref(instance);
      } else if (ref != null) {
        ref.current = instance;
      } else {
        /* eslint-disable no-debugger */
        debugger;
        console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
      }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */


    function useMergedRefs(_ref, _ref2) {
      let {
        ref: rhs
      } = _ref;
      let {
        ref: lhs
      } = _ref2;
      const combined = T$1(current => {
        processRef(current, lhs);
        processRef(current, rhs);
      }, [lhs, rhs]);

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return combined;
      }
    }

    function styleStringToObject(style) {
      // TODO: This sucks D:
      return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
    }
    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */


    function useMergedStyles(lhs, rhs) {
      var _lhs$style, _rhs$style2;

      // Easy case, when there are no styles to merge return nothing.
      if (!(lhs !== null && lhs !== void 0 && lhs.style) && !(rhs !== null && rhs !== void 0 && rhs.style)) return undefined;

      if (typeof lhs != typeof rhs) {
        // Easy cases, when one is null and the other isn't.
        if (lhs !== null && lhs !== void 0 && lhs.style && !(rhs !== null && rhs !== void 0 && rhs.style)) return lhs.style;
        if (!(lhs !== null && lhs !== void 0 && lhs.style) && rhs !== null && rhs !== void 0 && rhs.style) return rhs.style; // They're both non-null but different types.
        // Convert the string type to an object bag type and run it again.

        if (lhs !== null && lhs !== void 0 && lhs.style && rhs !== null && rhs !== void 0 && rhs.style) {
          // (useMergedStyles isn't a true hook -- this isn't a violation)
          if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") return useMergedStyles({
            style: styleStringToObject(lhs === null || lhs === void 0 ? void 0 : lhs.style)
          }, rhs);
          if (typeof (rhs === null || rhs === void 0 ? void 0 : rhs.style) == "string") return useMergedStyles(lhs, {
            style: styleStringToObject(rhs === null || rhs === void 0 ? void 0 : rhs.style)
          });
        } // Logic???


        return undefined;
      } // They're both strings, just concatenate them.


      if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") {
        var _rhs$style;

        return `${lhs.style};${(_rhs$style = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style !== void 0 ? _rhs$style : ""}`;
      } // They're both objects, just merge them.


      return { ...((_lhs$style = lhs === null || lhs === void 0 ? void 0 : lhs.style) !== null && _lhs$style !== void 0 ? _lhs$style : {}),
        ...((_rhs$style2 = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style2 !== void 0 ? _rhs$style2 : {})
      };
    }

    let log = console.warn;
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */

    function useMergedProps(lhsAll, rhsAll) {
      // First, separate the props we were given into two groups:
      // lhsAll and rhsAll contain all the props we were given, and
      // lhsMisc and rhsMisc contain all props *except* for the easy ones
      // like className and style that we already know how to merge.
      const {
        children: _lhsChildren,
        class: _lhsClass,
        className: _lhsClassName,
        style: _lhsStyle,
        ref: _lhsRef,
        ...lhsMisc
      } = lhsAll;
      const {
        children: _rhsChildren,
        class: _rhsClass,
        className: _rhsClassName,
        style: _rhsStyle,
        ref: _rhsRef,
        ...rhsMisc
      } = rhsAll;
      const ret = { ...lhsMisc,
        ref: useMergedRefs(lhsAll, rhsAll),
        style: useMergedStyles(lhsAll, rhsAll),
        className: useMergedClasses(lhsAll, rhsAll),
        children: useMergedChildren(lhsAll, rhsAll)
      };
      if (ret.ref === undefined) delete ret.ref;
      if (ret.style === undefined) delete ret.style;
      if (ret.className === undefined) delete ret.className;
      if (ret.children === undefined) delete ret.children; // Now, do *everything* else
      // Merge every remaining existing entry in lhs with what we've already put in ret.
      //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];

      const rhsEntries = Object.entries(rhsMisc);

      for (const [rhsKeyU, rhsValue] of rhsEntries) {
        const rhsKey = rhsKeyU;
        const lhsValue = lhsMisc[rhsKey];

        if (typeof lhsValue === "function" || typeof rhsValue === "function") {
          // They're both functions that can be merged (or one's a function and the other's null).
          // Not an *easy* case, but a well-defined one.
          const merged = mergeFunctions(lhsValue, rhsValue);
          ret[rhsKey] = merged;
        } else {
          // Uh...we're here because one of them's null, right?
          if (lhsValue == null && rhsValue == null) {
            if (rhsValue === null && lhsValue === undefined) ret[rhsKey] = rhsValue;else ret[rhsKey] = lhsValue;
          }

          if (lhsValue == null) ret[rhsKey] = rhsValue;else if (rhsValue == null) ret[rhsKey] = lhsValue;else if (rhsValue == lhsValue) ; else {
            var _log;

            // Ugh.
            // No good strategies here, just log it if requested
            (_log = log) === null || _log === void 0 ? void 0 : _log(`The prop "${rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
            ret[rhsKey] = rhsValue;
          }
        }
      }

      return ret;
    }

    function mergeFunctions(lhs, rhs) {
      if (!lhs) return rhs;
      if (!rhs) return lhs;
      return function () {
        const lv = lhs(...arguments);
        const rv = rhs(...arguments);
        if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
      };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */

    function useRefElement(args) {
      const {
        onElementChange,
        onMount,
        onUnmount
      } = args !== null && args !== void 0 ? args : {};
      useEnsureStability("useRefElement", onElementChange, onMount, onUnmount); // Called (indirectly) by the ref that the element receives.

      const handler = T$1((e, prevValue) => {
        const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
        if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
        if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
        return cleanup;
      }, []); // Let us store the actual (reference to) the element we capture

      const [getElement, setElement] = usePassiveState(handler, returnNull);
      const useRefElementProps = T$1(props => useMergedProps({
        ref: setElement
      }, props), []); // Return both the element and the hook that modifies 
      // the props and allows us to actually find the element

      return {
        useRefElementProps,
        getElement
      };
    }

    const activeElementUpdaters = new Map();
    const lastActiveElementUpdaters = new Map();
    const windowFocusedUpdaters = new Map();
    const windowsFocusedUpdaters = new Map();
    const microtasks = new Set(); // The focusin and focusout events often fire syncronously in the middle of running code.
    // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
    // For the purpose of improving stability, we debounce all focus events to the next microtask.

    function forEachUpdater(window, map, value) {
      if (!microtasks.has(map)) {
        microtasks.add(map);
        queueMicrotask(() => {
          microtasks.delete(map);
          const updaters = map.get(window);

          if (updaters) {
            for (const updater of updaters) {
              updater === null || updater === void 0 ? void 0 : updater(value);
            }
          }
        });
      }
    }

    function focusout(e) {
      const window = e.target.ownerDocument.defaultView;

      if (e.relatedTarget == null) {
        forEachUpdater(window, activeElementUpdaters, null);
      }
    }

    function focusin(e) {
      const window = e.target.ownerDocument.defaultView;
      const currentlyFocusedElement = e.target;
      forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
      forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
    }

    function windowFocus(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, true);
      forEachUpdater(window, windowFocusedUpdaters, true);
    }

    function windowBlur(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, false);
      forEachUpdater(window, windowFocusedUpdaters, false);
    }
    /**
     * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
     * * `getActiveElement()`
     * * `getLastActiveElement()`
     * * `getWindowFocused()`
     *
     * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
     *
     * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
     *
     * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
     */


    function useActiveElement(_ref) {
      let {
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        onMount,
        onUnmount,
        onMountChange
      } = _ref;
      useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, onMountChange, onMount, onUnmount);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onMount,
        onUnmount,
        onElementChange: T$1((element, prevValue) => {
          onMountChange === null || onMountChange === void 0 ? void 0 : onMountChange(element, prevValue);

          if (element) {
            var _activeElementUpdater, _activeElementUpdater2, _activeElementUpdater3, _lastActiveElementUpd, _windowFocusedUpdater;

            const document = element.ownerDocument;
            const window = document === null || document === void 0 ? void 0 : document.defaultView;

            if (((_activeElementUpdater = (_activeElementUpdater2 = activeElementUpdaters.get(window)) === null || _activeElementUpdater2 === void 0 ? void 0 : _activeElementUpdater2.size) !== null && _activeElementUpdater !== void 0 ? _activeElementUpdater : 0) === 0) {
              document === null || document === void 0 ? void 0 : document.addEventListener("focusin", focusin, {
                passive: true
              });
              document === null || document === void 0 ? void 0 : document.addEventListener("focusout", focusout, {
                passive: true
              });
              window === null || window === void 0 ? void 0 : window.addEventListener("focus", windowFocus, {
                passive: true
              });
              window === null || window === void 0 ? void 0 : window.addEventListener("blur", windowBlur, {
                passive: true
              });
            } // Add them even if they're undefined to more easily
            // manage the ">0 means don't add handlers" logic.


            const localActiveElementUpdaters = (_activeElementUpdater3 = activeElementUpdaters.get(window)) !== null && _activeElementUpdater3 !== void 0 ? _activeElementUpdater3 : new Set();
            const localLastActiveElementUpdaters = (_lastActiveElementUpd = lastActiveElementUpdaters.get(window)) !== null && _lastActiveElementUpd !== void 0 ? _lastActiveElementUpd : new Set();
            const localWindowFocusedUpdaters = (_windowFocusedUpdater = windowFocusedUpdaters.get(window)) !== null && _windowFocusedUpdater !== void 0 ? _windowFocusedUpdater : new Set();
            localActiveElementUpdaters.add(setActiveElement);
            localLastActiveElementUpdaters.add(setLastActiveElement);
            localWindowFocusedUpdaters.add(setWindowFocused);
            activeElementUpdaters.set(window, localActiveElementUpdaters);
            lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
            windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
            return () => {
              activeElementUpdaters.get(window).delete(setActiveElement);
              lastActiveElementUpdaters.get(window).delete(setLastActiveElement);
              windowFocusedUpdaters.get(window).delete(setWindowFocused);

              if (activeElementUpdaters.size === 0) {
                document === null || document === void 0 ? void 0 : document.removeEventListener("focusin", focusin);
                document === null || document === void 0 ? void 0 : document.removeEventListener("focusout", focusout);
                window === null || window === void 0 ? void 0 : window.removeEventListener("focus", windowFocus);
                window === null || window === void 0 ? void 0 : window.removeEventListener("blur", windowBlur);
              }
            };
          }
        }, [])
      });
      const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
      const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
      const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
      return {
        getElement,
        useActiveElementProps: useRefElementProps,
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }

    const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";

    function base64(value) {
      return Table[value];
    }

    function random6Bits() {
      return Math.floor(Math.random() * 0b1000000);
    }

    function random64Bits() {
      return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     *
     *
     * (This is here, in this particular file, to avoid circular dependencies
     * without also making a utilities file.
     * Once we can remove this hook, we can put this function back with useRandomId)
     */


    function generateRandomId(prefix) {
      return `${prefix !== null && prefix !== void 0 ? prefix : "id-"}${random64Bits().map(n => base64(n)).join("")}`;
    }
    const previousInputs = new Map();
    const toRun = new Map(); // TODO: Whether this goes in options.diffed or options._commit
    // is a post-suspense question.
    // Right now, using options._commit has the problem of running
    // *after* refs are applied, but we need to come before even that
    // so `ref={someStableFunction}` works.
    // 
    // Also it's private.
    //
    // ...
    // Well, useEvent or whatever is finally, finally 4 years later finally here
    // which is cool and means we won't need this at all soon.
    // So for now we'll stick with diff to prevent any weirdness with
    // commit being private and all.

    const commitName = "diffed";
    const originalCommit = l$1[commitName];

    const newCommit = function () {
      for (const [id, effectInfo] of toRun) {
        const oldInputs = previousInputs.get(id);

        if (argsChanged(oldInputs, effectInfo.inputs)) {
          var _effectInfo$cleanup;

          (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
          effectInfo.cleanup = effectInfo.effect();
          previousInputs.set(id, effectInfo.inputs);
        }
      }

      toRun.clear();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
    };

    l$1[commitName] = newCommit;
    /**
     * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
     *
     * Every render, we send the arguments to be evaluated after diffing has completed,
     * which happens before.
     *
     * @param effect
     * @param inputs
     */

    function useBeforeLayoutEffect(effect, inputs) {
      /*(() => {
          const cleanup = useRef<void | (() => void) | null>(null);
          const prevArgsRef = useRef<Inputs>(null!);
          if (argsChanged(inputs, prevArgsRef.current)) {
              prevArgsRef.current = inputs!;
              if (cleanup.current)
                  cleanup.current();
              cleanup.current = effect();
          }
      })();*/
      const [id] = p(() => generateRandomId());
      toRun.set(id, {
        effect,
        inputs,
        cleanup: null
      });
      h(() => {
        return () => {
          toRun.delete(id);
          previousInputs.delete(id);
        };
      }, [id]);
    }

    function argsChanged(oldArgs, newArgs) {
      return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
    }

    const Unset = Symbol("unset");
    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * This uses `options.diffed` in order to run before everything, even
     * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
     *
     * @param value
     * @returns
     */

    function useStableGetter(value) {
      const ref = _(Unset);
      useBeforeLayoutEffect(() => {
        ref.current = value;
      }, [value]);
      return T$1(() => {
        if (ref.current === Unset) {
          throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
        }

        return ref.current;
      }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * Do not use during the render phase!  `useLayoutEffect` is fine though.
     */

    function useStableCallback(fn) {
      const currentCallbackGetter = useStableGetter(fn);
      return T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []);
    }

    B(null);

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */

    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();

    /** Built-in value references. */

    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */

    var objectProto$5 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var nativeObjectToString$1 = objectProto$5.toString;
    /** Built-in value references. */

    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */

    function getRawTag(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);

      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }

      return result;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var nativeObjectToString = objectProto$4.toString;
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */

    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /** `Object#toString` result references. */

    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';
    /** Built-in value references. */

    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */

    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }

      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */

    function useState(initialState) {
      // We keep both, but overrride the `setState` functionality
      const [state, setStateP] = p(initialState);
      const ref = _(state); // Hijack the normal setter function 
      // to also set our ref to the new value

      const setState = T$1(value => {
        if (typeof value === "function") {
          const callback = value;
          setStateP(prevValue => {
            const nextValue = callback(prevValue);
            ref.current = nextValue;
            return nextValue;
          });
        } else {
          ref.current = value;
          setStateP(value);
        }
      }, []);

      const getState = () => {
        return ref.current;
      };

      console.assert(ref.current === state || typeof state === "number" && isNaN(state));
      return [state, setState, getState];
    }

    /**
     * Wrap the native `useEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     * @param impl You can choose whether to use `useEffect` or `useLayoutEffect` by
     * passing one of them as this argument. By default, it's `useEffect`.
     */

    function useEffect(effect, inputs) {
      let impl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : h;
      const prevInputs = _(undefined);

      const effect2 = () => {
        const changes = [];

        if (inputs && prevInputs.current) {
          for (let i = 0; i < Math.max(prevInputs.current.length, inputs.length); ++i) {
            if (prevInputs.current[i] != inputs[i]) changes[i] = {
              from: prevInputs.current[i],
              to: inputs[i]
            };
          }
        }

        const ret = effect(prevInputs.current, changes);
        prevInputs.current = inputs;
        return ret;
      };

      impl(effect2, inputs);
    }

    /**
     * Wrap the native `useLayoutEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     */

    function useLayoutEffect(effect, inputs) {
      return useEffect(effect, inputs, s);
    }

    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is designed to be lightweight, in that the parent keeps no state
     * and runs no effects.  Each child *does* run an effect, but with no state
     * changes unless you explicitly request them.
     *
     *
     */


    function useManagedChildren(parentParameters) {
      const {
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters;
      useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
      const getHighestIndex = T$1(() => {
        return managedChildrenArray.current.highestIndex;
      }, []); // All the information we have about our children is stored in this **stable** array.
      // Any mutations to this array **DO NOT** trigger any sort of a re-render.

      const managedChildrenArray = _({
        arr: [],
        rec: {},
        highestIndex: 0,
        lowestIndex: 0
      }); // For indirect access to each child
      // Compare getManagedChildInfo
      // TODO: The primary use for this is flaggable closest fits
      // which need to search all children for that closest fit.
      // It would be nice if there was something better for that.

      const forEachChild = T$1(f => {
        for (const child of managedChildrenArray.current.arr) {
          f(child);
        }

        for (const field in managedChildrenArray.current.rec) {
          const child = managedChildrenArray.current.rec[field];
          if (child) f(child);
        }
      }, []); // Retrieves the information associated with the child with the given index.
      // `undefined` if not child there, or it's unmounted.

      const getManagedChildInfo = T$1(index => {
        if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
      }, []); // tl;dr this is a way to have run useLayoutEffect once after all N children
      // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
      // ourselves because of having a `childCount` state or anything similar.
      //
      // When the child count ref updates, we want the parent to also run an effect
      // to maybe do something with all these children that just mounted.
      // The easiest way would be useEffect(..., [childCount]) but
      // that would require us having a childCount state, then calling
      // setChildCount and re-rendering every time children mount
      // (only one re-render at a time unless children are staggered, but still)
      // 
      // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
      // to emulate running ULE on the parent. Only the first child will actually queue
      // the microtask (by checking hasRemoteULE first) so that the "effect" only
      // runs once. When it's done, hasRemoteULE is reset so it can run again if
      // more children mount/unmount.

      const hasRemoteULEChildMounted = _(null);
      const remoteULEChildChangedCausers = _(new Set());
      const remoteULEChildChanged = T$1(index => {
        if (remoteULEChildChangedCausers.current.size == 0) {
          queueMicrotask(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }

        remoteULEChildChangedCausers.current.add(index);
        return () => {};
      }, [
        /* Must remain stable */
      ]);
      const remoteULEChildMounted = T$1((index, mounted) => {
        if (!hasRemoteULEChildMounted.current) {
          hasRemoteULEChildMounted.current = {
            mounts: new Set(),
            unmounts: new Set()
          };
          queueMicrotask(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            hasRemoteULEChildMounted.current = null;
          });
        }

        if (mounted) {
          managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
        } else {
          if (typeof index == "number") {
            delete managedChildrenArray.current.arr[index];
            let shave = 0;

            while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) ++shave;

            managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - 1 - shave, shave);
          } else delete managedChildrenArray.current.rec[index];
        }

        hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
      }, [
        /* Must remain stable */
      ]);
      const useManagedChild = T$1(_ref => {
        let {
          managedChild: info
        } = _ref;
        // Any time our child props change, make that information available
        // the parent if they need it.
        // The parent can listen for all updates and only act on the ones it cares about,
        // and multiple children updating in the same tick will all be sent at once.
        useLayoutEffect(() => {
          var _info$flags, _info$flags2;

          // Insert this information in-place
          if (typeof info.index == "number") managedChildrenArray.current.arr[info.index] = {
            index: info.index,
            flags: (_info$flags = info.flags) !== null && _info$flags !== void 0 ? _info$flags : {},
            subInfo: info.subInfo
          };else managedChildrenArray.current.rec[info.index] = {
            index: info.index,
            flags: (_info$flags2 = info.flags) !== null && _info$flags2 !== void 0 ? _info$flags2 : {},
            subInfo: info.subInfo
          };
          return remoteULEChildChanged(info.index);
        }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
        // When we mount, notify the parent via queueMicrotask
        // (every child does this, so everything's coordinated to only queue a single microtask per tick)
        // Do the same on unmount.
        // Note: It's important that this comes AFTER remoteULEChildChanged
        // so that remoteULEChildMounted has access to all the info on mount.

        useLayoutEffect(() => {
          remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, true);
          return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, false);
        }, [info.index]);
      }, [
        /* Must remain stable */
      ]);
      const managedChildren = _({ ...{
          _: managedChildrenArray.current
        },
        forEach: forEachChild,
        getAt: getManagedChildInfo,
        getHighestIndex: getHighestIndex,
        arraySlice: () => {
          return managedChildrenArray.current.arr.slice();
        }
      });
      return {
        useManagedChild,
        managedChildren: {
          children: managedChildren.current
        }
      };
    }
    /**
     * An extension to useManagedChildren that handles the following common case:
     * 1. You have a bunch of children
     * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
     * 3. The parent has control over who is "selected" via a numerical index.
     *
     * This hook allows for much easier control over selection management.
     *
     * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
     * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
     *
     * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
     *
     *
     * @param param0
     * @returns
     */

    function useChildrenFlag(_ref2) {
      let {
        children,
        initialIndex,
        closestFit,
        onIndexChange,
        key
      } = _ref2;
      useEnsureStability("useChildrenFlag", onIndexChange, key);
      const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange, T$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, []));
      const [getRequestedIndex, setRequestedIndex] = usePassiveState(null, T$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, [])); //    const getFitNullToZero = useStableGetter(fitNullToZero);
      // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)

      const getClosestFit = T$1(requestedIndex => {
        let closestDistance = Infinity;
        let closestIndex = null;
        children.forEach(child => {
          var _child$flags, _child$flags$key;

          if ((_child$flags = child.flags) !== null && _child$flags !== void 0 && (_child$flags$key = _child$flags[key]) !== null && _child$flags$key !== void 0 && _child$flags$key.isValid()) {
            const newDistance = Math.abs(child.index - requestedIndex);

            if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
              closestDistance = newDistance;
              closestIndex = child.index;
            }
          }
        });
        return closestIndex;
      }, [
        /* Must remain stable! */
      ]); // Any time a child mounts/unmounts, we need to double-check to see if that affects 
      // the "currently selected" (or whatever) index.  The two cases we're looking for:
      // 1. The currently selected child unmounted
      // 2. A child mounted, and it mounts with the index we're looking for

      const reevaluateClosestFit = useStableCallback(() => {
        var _currentChild$flags, _currentChild$flags$k;

        const requestedIndex = getRequestedIndex();
        const currentIndex = getCurrentIndex();
        const currentChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !((_currentChild$flags = currentChild.flags) !== null && _currentChild$flags !== void 0 && (_currentChild$flags$k = _currentChild$flags[key]) !== null && _currentChild$flags$k !== void 0 && _currentChild$flags$k.isValid()))) {
          var _currentChild$flags2;

          currentChild === null || currentChild === void 0 ? void 0 : (_currentChild$flags2 = currentChild.flags) === null || _currentChild$flags2 === void 0 ? void 0 : _currentChild$flags2[key].set(false);
          const closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex);

          if (closestFitIndex != null) {
            var _closestFitChild$flag;

            const closestFitChild = children.getAt(closestFitIndex);
            console.assert(closestFitChild != null, "Internal logic???");
            (_closestFitChild$flag = closestFitChild.flags) === null || _closestFitChild$flag === void 0 ? void 0 : _closestFitChild$flag[key].set(true);
          }
        }
      });
      const changeIndex = T$1(arg => {
        const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg; //if (requestedIndex == null && getFitNullToZero())
        //    requestedIndex = 0;

        setRequestedIndex(requestedIndex);
        const currentIndex = getCurrentIndex();
        if (currentIndex == requestedIndex) return requestedIndex;
        let newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
        const oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex == null) {
          var _oldMatchingChild$fla;

          // Easy case
          setCurrentIndex(null);
          oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla = oldMatchingChild.flags) === null || _oldMatchingChild$fla === void 0 ? void 0 : _oldMatchingChild$fla[key].set(false);
          return null;
        } else {
          var _newMatchingChild$fla;

          if (newMatchingChild && (_newMatchingChild$fla = newMatchingChild.flags) !== null && _newMatchingChild$fla !== void 0 && _newMatchingChild$fla[key].isValid()) {
            var _oldMatchingChild$fla2, _newMatchingChild$fla2;

            setCurrentIndex(requestedIndex);
            oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla2 = oldMatchingChild.flags) === null || _oldMatchingChild$fla2 === void 0 ? void 0 : _oldMatchingChild$fla2[key].set(false);
            (_newMatchingChild$fla2 = newMatchingChild.flags) === null || _newMatchingChild$fla2 === void 0 ? void 0 : _newMatchingChild$fla2[key].set(true);
            return requestedIndex;
          } else {
            const closestFitIndex = getClosestFit(requestedIndex);
            setCurrentIndex(closestFitIndex);

            if (closestFitIndex != null) {
              var _oldMatchingChild$fla3, _newMatchingChild$fla3;

              newMatchingChild = children.getAt(closestFitIndex);
              console.assert(newMatchingChild != null, "Internal logic???");
              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla3 = oldMatchingChild.flags) === null || _oldMatchingChild$fla3 === void 0 ? void 0 : _oldMatchingChild$fla3[key].set(false);
              (_newMatchingChild$fla3 = newMatchingChild.flags) === null || _newMatchingChild$fla3 === void 0 ? void 0 : _newMatchingChild$fla3[key].set(true);
              return closestFitIndex;
            } else {
              var _oldMatchingChild$fla4;

              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla4 = oldMatchingChild.flags) === null || _oldMatchingChild$fla4 === void 0 ? void 0 : _oldMatchingChild$fla4[key].set(false);
              return null;
            }
          }
        }
      }, []);
      useLayoutEffect(() => {
        var _children$getAt, _children$getAt$flags, _children$getAt$flags2;

        if (initialIndex != null) (_children$getAt = children.getAt(initialIndex)) === null || _children$getAt === void 0 ? void 0 : (_children$getAt$flags = _children$getAt.flags) === null || _children$getAt$flags === void 0 ? void 0 : (_children$getAt$flags2 = _children$getAt$flags[key]) === null || _children$getAt$flags2 === void 0 ? void 0 : _children$getAt$flags2.set(true);
      }, []);
      return {
        changeIndex,
        reevaluateClosestFit,
        getCurrentIndex
      };
    }
    /*export type Spread<A extends {}, B extends {}> = Omit<A, keyof B> & B;
    export function spread<A extends {}, B extends {}>(a: A, b: B): Spread<A, B> {
        return {
            ...a,
            ...b
        }
    }*/

    /*
    function test() {
        type C = { foo: "bar" };
        type K = "flag2";

        const { children, useManagedChild } = useManagedChildren<number, C, K>({ managedChildren: { onChildrenMountChange: useStableCallback<OnChildrenMountChange<number>>((mounted, unmounted) => onChildrenMountChange(mounted, unmounted)) } });
        useManagedChild({ managedChild: { index: 0, info: { foo: "bar" }, flags: {  } } });
        const { changeIndex, getCurrentIndex, onChildrenMountChange } = useChildrenFlag<C, K>({ children, initialIndex: 0, key: "flag2" })
    }*/

    function getDocument(element) {
      var _ref, _ref2, _element$ownerDocumen;

      return (_ref = (_ref2 = (_element$ownerDocumen = element === null || element === void 0 ? void 0 : element.ownerDocument) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : document) !== null && _ref2 !== void 0 ? _ref2 : window.document) !== null && _ref !== void 0 ? _ref : globalThis.document;
    }

    function useElementSize(_ref) {
      let {
        getObserveBox,
        onSizeChange
      } = _ref;
      useEnsureStability("useElementSize", getObserveBox, onSizeChange);
      const [getSize, setSize] = usePassiveState(onSizeChange, returnNull);
      const currentObserveBox = _(undefined);
      const needANewObserver = T$1((element, observeBox) => {
        if (element) {
          const document = getDocument(element);
          const window = document.defaultView;

          const handleUpdate = () => {
            if (element.isConnected) {
              const {
                clientWidth,
                scrollWidth,
                offsetWidth,
                clientHeight,
                scrollHeight,
                offsetHeight,
                clientLeft,
                scrollLeft,
                offsetLeft,
                clientTop,
                scrollTop,
                offsetTop
              } = element;
              setSize({
                clientWidth,
                scrollWidth,
                offsetWidth,
                clientHeight,
                scrollHeight,
                offsetHeight,
                clientLeft,
                scrollLeft,
                offsetLeft,
                clientTop,
                scrollTop,
                offsetTop
              });
            }
          };

          if (window && "ResizeObserver" in window) {
            const observer = new ResizeObserver(_entries => {
              handleUpdate();
            });
            observer.observe(element, {
              box: observeBox
            });
            return () => observer.disconnect();
          } else {
            document.addEventListener("resize", handleUpdate, {
              passive: true
            });
            return () => document.removeEventListener("resize", handleUpdate);
          }
        }
      }, []);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: T$1(e => needANewObserver(e, getObserveBox === null || getObserveBox === void 0 ? void 0 : getObserveBox()), [])
      });
      h(() => {
        if (getObserveBox) {
          if (currentObserveBox.current !== getObserveBox()) needANewObserver(getElement(), getObserveBox());
        }
      });
      return {
        getElement,
        getSize,
        useElementSizeProps: useRefElementProps
      };
    }

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */

    function useGlobalHandler(target, type, handler, options) {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      let stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
      if (handler == null) stableHandler = null;
      h(() => {
        if (stableHandler) {
          target.addEventListener(type, stableHandler, options);
          return () => target.removeEventListener(type, stableHandler, options);
        }
      }, [target, type, stableHandler]);
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    (function (module, exports) {
      (function (global, factory) {
        factory() ;
      })(commonjsGlobal, function () {

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        /**
         * This work is licensed under the W3C Software and Document License
         * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
         */


        (function () {
          // Return early if we're not running inside of the browser.
          if (typeof window === 'undefined') {
            return;
          } // Convenience function for converting NodeLists.

          /** @type {typeof Array.prototype.slice} */


          var slice = Array.prototype.slice;
          /**
           * IE has a non-standard name for "matches".
           * @type {typeof Element.prototype.matches}
           */

          var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
          /** @type {string} */

          var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
          /**
           * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
           * attribute.
           *
           * Its main functions are:
           *
           * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
           *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
           *   each focusable node in the subtree with the singleton `InertManager` which manages all known
           *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
           *   instance exists for each focusable node which has at least one inert root as an ancestor.
           *
           * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
           *   attribute is removed from the root node). This is handled in the destructor, which calls the
           *   `deregister` method on `InertManager` for each managed inert node.
           */


          var InertRoot = function () {
            /**
             * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
             * @param {!InertManager} inertManager The global singleton InertManager object.
             */
            function InertRoot(rootElement, inertManager) {
              _classCallCheck(this, InertRoot);
              /** @type {!InertManager} */


              this._inertManager = inertManager;
              /** @type {!HTMLElement} */

              this._rootElement = rootElement;
              /**
               * @type {!Set<!InertNode>}
               * All managed focusable nodes in this InertRoot's subtree.
               */

              this._managedNodes = new Set(); // Make the subtree hidden from assistive technology

              if (this._rootElement.hasAttribute('aria-hidden')) {
                /** @type {?string} */
                this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
              } else {
                this._savedAriaHidden = null;
              }

              this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes


              this._makeSubtreeUnfocusable(this._rootElement); // Watch for:
              // - any additions in the subtree: make them unfocusable too
              // - any removals from the subtree: remove them from this inert root's managed nodes
              // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
              //   element, make that node a managed node.


              this._observer = new MutationObserver(this._onMutation.bind(this));

              this._observer.observe(this._rootElement, {
                attributes: true,
                childList: true,
                subtree: true
              });
            }
            /**
             * Call this whenever this object is about to become obsolete.  This unwinds all of the state
             * stored in this object and updates the state of all of the managed nodes.
             */


            _createClass(InertRoot, [{
              key: 'destructor',
              value: function destructor() {
                this._observer.disconnect();

                if (this._rootElement) {
                  if (this._savedAriaHidden !== null) {
                    this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                  } else {
                    this._rootElement.removeAttribute('aria-hidden');
                  }
                }

                this._managedNodes.forEach(function (inertNode) {
                  this._unmanageNode(inertNode.node);
                }, this); // Note we cast the nulls to the ANY type here because:
                // 1) We want the class properties to be declared as non-null, or else we
                //    need even more casts throughout this code. All bets are off if an
                //    instance has been destroyed and a method is called.
                // 2) We don't want to cast "this", because we want type-aware optimizations
                //    to know which properties we're setting.


                this._observer =
                /** @type {?} */
                null;
                this._rootElement =
                /** @type {?} */
                null;
                this._managedNodes =
                /** @type {?} */
                null;
                this._inertManager =
                /** @type {?} */
                null;
              }
              /**
               * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
               */

            }, {
              key: '_makeSubtreeUnfocusable',

              /**
               * @param {!Node} startNode
               */
              value: function _makeSubtreeUnfocusable(startNode) {
                var _this2 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this2._visitNode(node);
                });
                var activeElement = document.activeElement;

                if (!document.body.contains(startNode)) {
                  // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                  var node = startNode;
                  /** @type {!ShadowRoot|undefined} */

                  var root = undefined;

                  while (node) {
                    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      root =
                      /** @type {!ShadowRoot} */
                      node;
                      break;
                    }

                    node = node.parentNode;
                  }

                  if (root) {
                    activeElement = root.activeElement;
                  }
                }

                if (startNode.contains(activeElement)) {
                  activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1
                  // calling blur() will not actually move the focus.
                  // To work around this we call focus() on the body instead.

                  if (activeElement === document.activeElement) {
                    document.body.focus();
                  }
                }
              }
              /**
               * @param {!Node} node
               */

            }, {
              key: '_visitNode',
              value: function _visitNode(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of
                // this inert root, so all of its managed nodes need to be adopted by this InertRoot.

                if (element !== this._rootElement && element.hasAttribute('inert')) {
                  this._adoptInertRoot(element);
                }

                if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                  this._manageNode(element);
                }
              }
              /**
               * Register the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_manageNode',
              value: function _manageNode(node) {
                var inertNode = this._inertManager.register(node, this);

                this._managedNodes.add(inertNode);
              }
              /**
               * Unregister the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_unmanageNode',
              value: function _unmanageNode(node) {
                var inertNode = this._inertManager.deregister(node, this);

                if (inertNode) {
                  this._managedNodes['delete'](inertNode);
                }
              }
              /**
               * Unregister the entire subtree starting at `startNode`.
               * @param {!Node} startNode
               */

            }, {
              key: '_unmanageSubtree',
              value: function _unmanageSubtree(startNode) {
                var _this3 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this3._unmanageNode(node);
                });
              }
              /**
               * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
               * @param {!HTMLElement} node
               */

            }, {
              key: '_adoptInertRoot',
              value: function _adoptInertRoot(node) {
                var inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,
                // so register it now if need be.


                if (!inertSubroot) {
                  this._inertManager.setInert(node, true);

                  inertSubroot = this._inertManager.getInertRoot(node);
                }

                inertSubroot.managedNodes.forEach(function (savedInertNode) {
                  this._manageNode(savedInertNode.node);
                }, this);
              }
              /**
               * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_onMutation',
              value: function _onMutation(records, self) {
                records.forEach(function (record) {
                  var target =
                  /** @type {!HTMLElement} */
                  record.target;

                  if (record.type === 'childList') {
                    // Manage added nodes
                    slice.call(record.addedNodes).forEach(function (node) {
                      this._makeSubtreeUnfocusable(node);
                    }, this); // Un-manage removed nodes

                    slice.call(record.removedNodes).forEach(function (node) {
                      this._unmanageSubtree(node);
                    }, this);
                  } else if (record.type === 'attributes') {
                    if (record.attributeName === 'tabindex') {
                      // Re-initialise inert node if tabindex changes
                      this._manageNode(target);
                    } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                      // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                      // already managed nodes from this inert subroot.
                      this._adoptInertRoot(target);

                      var inertSubroot = this._inertManager.getInertRoot(target);

                      this._managedNodes.forEach(function (managedNode) {
                        if (target.contains(managedNode.node)) {
                          inertSubroot._manageNode(managedNode.node);
                        }
                      });
                    }
                  }
                }, this);
              }
            }, {
              key: 'managedNodes',
              get: function get() {
                return new Set(this._managedNodes);
              }
              /** @return {boolean} */

            }, {
              key: 'hasSavedAriaHidden',
              get: function get() {
                return this._savedAriaHidden !== null;
              }
              /** @param {?string} ariaHidden */

            }, {
              key: 'savedAriaHidden',
              set: function set(ariaHidden) {
                this._savedAriaHidden = ariaHidden;
              }
              /** @return {?string} */
              ,
              get: function get() {
                return this._savedAriaHidden;
              }
            }]);

            return InertRoot;
          }();
          /**
           * `InertNode` initialises and manages a single inert node.
           * A node is inert if it is a descendant of one or more inert root elements.
           *
           * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
           * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
           * is intrinsically focusable or not.
           *
           * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
           * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
           * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
           * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
           * or removes the `tabindex` attribute if the element is intrinsically focusable.
           */


          var InertNode = function () {
            /**
             * @param {!Node} node A focusable element to be made inert.
             * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
             */
            function InertNode(node, inertRoot) {
              _classCallCheck(this, InertNode);
              /** @type {!Node} */


              this._node = node;
              /** @type {boolean} */

              this._overrodeFocusMethod = false;
              /**
               * @type {!Set<!InertRoot>} The set of descendant inert roots.
               *    If and only if this set becomes empty, this node is no longer inert.
               */

              this._inertRoots = new Set([inertRoot]);
              /** @type {?number} */

              this._savedTabIndex = null;
              /** @type {boolean} */

              this._destroyed = false; // Save any prior tabindex info and make this node untabbable

              this.ensureUntabbable();
            }
            /**
             * Call this whenever this object is about to become obsolete.
             * This makes the managed node focusable again and deletes all of the previously stored state.
             */


            _createClass(InertNode, [{
              key: 'destructor',
              value: function destructor() {
                this._throwIfDestroyed();

                if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                  var element =
                  /** @type {!HTMLElement} */
                  this._node;

                  if (this._savedTabIndex !== null) {
                    element.setAttribute('tabindex', this._savedTabIndex);
                  } else {
                    element.removeAttribute('tabindex');
                  } // Use `delete` to restore native focus method.


                  if (this._overrodeFocusMethod) {
                    delete element.focus;
                  }
                } // See note in InertRoot.destructor for why we cast these nulls to ANY.


                this._node =
                /** @type {?} */
                null;
                this._inertRoots =
                /** @type {?} */
                null;
                this._destroyed = true;
              }
              /**
               * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
               * If the object has been destroyed, any attempt to access it will cause an exception.
               */

            }, {
              key: '_throwIfDestroyed',

              /**
               * Throw if user tries to access destroyed InertNode.
               */
              value: function _throwIfDestroyed() {
                if (this.destroyed) {
                  throw new Error('Trying to access destroyed InertNode');
                }
              }
              /** @return {boolean} */

            }, {
              key: 'ensureUntabbable',

              /** Save the existing tabindex value and make the node untabbable and unfocusable */
              value: function ensureUntabbable() {
                if (this.node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                this.node;

                if (matches.call(element, _focusableElementsString)) {
                  if (
                  /** @type {!HTMLElement} */
                  element.tabIndex === -1 && this.hasSavedTabIndex) {
                    return;
                  }

                  if (element.hasAttribute('tabindex')) {
                    this._savedTabIndex =
                    /** @type {!HTMLElement} */
                    element.tabIndex;
                  }

                  element.setAttribute('tabindex', '-1');

                  if (element.nodeType === Node.ELEMENT_NODE) {
                    element.focus = function () {};

                    this._overrodeFocusMethod = true;
                  }
                } else if (element.hasAttribute('tabindex')) {
                  this._savedTabIndex =
                  /** @type {!HTMLElement} */
                  element.tabIndex;
                  element.removeAttribute('tabindex');
                }
              }
              /**
               * Add another inert root to this inert node's set of managing inert roots.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'addInertRoot',
              value: function addInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots.add(inertRoot);
              }
              /**
               * Remove the given inert root from this inert node's set of managing inert roots.
               * If the set of managing inert roots becomes empty, this node is no longer inert,
               * so the object should be destroyed.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'removeInertRoot',
              value: function removeInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots['delete'](inertRoot);

                if (this._inertRoots.size === 0) {
                  this.destructor();
                }
              }
            }, {
              key: 'destroyed',
              get: function get() {
                return (
                  /** @type {!InertNode} */
                  this._destroyed
                );
              }
            }, {
              key: 'hasSavedTabIndex',
              get: function get() {
                return this._savedTabIndex !== null;
              }
              /** @return {!Node} */

            }, {
              key: 'node',
              get: function get() {
                this._throwIfDestroyed();

                return this._node;
              }
              /** @param {?number} tabIndex */

            }, {
              key: 'savedTabIndex',
              set: function set(tabIndex) {
                this._throwIfDestroyed();

                this._savedTabIndex = tabIndex;
              }
              /** @return {?number} */
              ,
              get: function get() {
                this._throwIfDestroyed();

                return this._savedTabIndex;
              }
            }]);

            return InertNode;
          }();
          /**
           * InertManager is a per-document singleton object which manages all inert roots and nodes.
           *
           * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
           * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
           * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
           * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
           * is created for each such node, via the `_managedNodes` map.
           */


          var InertManager = function () {
            /**
             * @param {!Document} document
             */
            function InertManager(document) {
              _classCallCheck(this, InertManager);

              if (!document) {
                throw new Error('Missing required argument; InertManager needs to wrap a document.');
              }
              /** @type {!Document} */


              this._document = document;
              /**
               * All managed nodes known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertNode>}
               */

              this._managedNodes = new Map();
              /**
               * All inert roots known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertRoot>}
               */

              this._inertRoots = new Map();
              /**
               * Observer for mutations on `document.body`.
               * @type {!MutationObserver}
               */

              this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.

              addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.

              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
              } else {
                this._onDocumentLoaded();
              }
            }
            /**
             * Set whether the given element should be an inert root or not.
             * @param {!HTMLElement} root
             * @param {boolean} inert
             */


            _createClass(InertManager, [{
              key: 'setInert',
              value: function setInert(root, inert) {
                if (inert) {
                  if (this._inertRoots.has(root)) {
                    // element is already inert
                    return;
                  }

                  var inertRoot = new InertRoot(root, this);
                  root.setAttribute('inert', '');

                  this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.
                  // Ensure inert styles are added there.


                  if (!this._document.body.contains(root)) {
                    var parent = root.parentNode;

                    while (parent) {
                      if (parent.nodeType === 11) {
                        addInertStyle(parent);
                      }

                      parent = parent.parentNode;
                    }
                  }
                } else {
                  if (!this._inertRoots.has(root)) {
                    // element is already non-inert
                    return;
                  }

                  var _inertRoot = this._inertRoots.get(root);

                  _inertRoot.destructor();

                  this._inertRoots['delete'](root);

                  root.removeAttribute('inert');
                }
              }
              /**
               * Get the InertRoot object corresponding to the given inert root element, if any.
               * @param {!Node} element
               * @return {!InertRoot|undefined}
               */

            }, {
              key: 'getInertRoot',
              value: function getInertRoot(element) {
                return this._inertRoots.get(element);
              }
              /**
               * Register the given InertRoot as managing the given node.
               * In the case where the node has a previously existing inert root, this inert root will
               * be added to its set of inert roots.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {!InertNode} inertNode
               */

            }, {
              key: 'register',
              value: function register(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (inertNode !== undefined) {
                  // node was already in an inert subtree
                  inertNode.addInertRoot(inertRoot);
                } else {
                  inertNode = new InertNode(node, inertRoot);
                }

                this._managedNodes.set(node, inertNode);

                return inertNode;
              }
              /**
               * De-register the given InertRoot as managing the given inert node.
               * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
               * node from the InertManager's set of managed nodes if it is destroyed.
               * If the node is not currently managed, this is essentially a no-op.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
               */

            }, {
              key: 'deregister',
              value: function deregister(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (!inertNode) {
                  return null;
                }

                inertNode.removeInertRoot(inertRoot);

                if (inertNode.destroyed) {
                  this._managedNodes['delete'](node);
                }

                return inertNode;
              }
              /**
               * Callback used when document has finished loading.
               */

            }, {
              key: '_onDocumentLoaded',
              value: function _onDocumentLoaded() {
                // Find all inert roots in document and make them actually inert.
                var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
                inertElements.forEach(function (inertElement) {
                  this.setInert(inertElement, true);
                }, this); // Comment this out to use programmatic API only.

                this._observer.observe(this._document.body || this._document.documentElement, {
                  attributes: true,
                  subtree: true,
                  childList: true
                });
              }
              /**
               * Callback used when mutation observer detects attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_watchForInert',
              value: function _watchForInert(records, self) {
                var _this = this;

                records.forEach(function (record) {
                  switch (record.type) {
                    case 'childList':
                      slice.call(record.addedNodes).forEach(function (node) {
                        if (node.nodeType !== Node.ELEMENT_NODE) {
                          return;
                        }

                        var inertElements = slice.call(node.querySelectorAll('[inert]'));

                        if (matches.call(node, '[inert]')) {
                          inertElements.unshift(node);
                        }

                        inertElements.forEach(function (inertElement) {
                          this.setInert(inertElement, true);
                        }, _this);
                      }, _this);
                      break;

                    case 'attributes':
                      if (record.attributeName !== 'inert') {
                        return;
                      }

                      var target =
                      /** @type {!HTMLElement} */
                      record.target;
                      var inert = target.hasAttribute('inert');

                      _this.setInert(target, inert);

                      break;
                  }
                }, this);
              }
            }]);

            return InertManager;
          }();
          /**
           * Recursively walk the composed tree from |node|.
           * @param {!Node} node
           * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
           *     before descending into child nodes.
           * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
           */


          function composedTreeWalk(node, callback, shadowRootAncestor) {
            if (node.nodeType == Node.ELEMENT_NODE) {
              var element =
              /** @type {!HTMLElement} */
              node;

              if (callback) {
                callback(element);
              } // Descend into node:
              // If it has a ShadowRoot, ignore all child elements - these will be picked
              // up by the <content> or <shadow> elements. Descend straight into the
              // ShadowRoot.


              var shadowRoot =
              /** @type {!HTMLElement} */
              element.shadowRoot;

              if (shadowRoot) {
                composedTreeWalk(shadowRoot, callback);
                return;
              } // If it is a <content> element, descend into distributed elements - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'content') {
                var content =
                /** @type {!HTMLContentElement} */
                element; // Verifies if ShadowDom v0 is supported.

                var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];

                for (var i = 0; i < distributedNodes.length; i++) {
                  composedTreeWalk(distributedNodes[i], callback);
                }

                return;
              } // If it is a <slot> element, descend into assigned nodes - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'slot') {
                var slot =
                /** @type {!HTMLSlotElement} */
                element; // Verify if ShadowDom v1 is supported.

                var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                  flatten: true
                }) : [];

                for (var _i = 0; _i < _distributedNodes.length; _i++) {
                  composedTreeWalk(_distributedNodes[_i], callback);
                }

                return;
              }
            } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
            // element, nor a <shadow> element recurse normally.


            var child = node.firstChild;

            while (child != null) {
              composedTreeWalk(child, callback);
              child = child.nextSibling;
            }
          }
          /**
           * Adds a style element to the node containing the inert specific styles
           * @param {!Node} node
           */


          function addInertStyle(node) {
            if (node.querySelector('style#inert-style, link#inert-style')) {
              return;
            }

            var style = document.createElement('style');
            style.setAttribute('id', 'inert-style');
            style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
            node.appendChild(style);
          }

          if (!HTMLElement.prototype.hasOwnProperty('inert')) {
            /** @type {!InertManager} */
            var inertManager = new InertManager(document);
            Object.defineProperty(HTMLElement.prototype, 'inert', {
              enumerable: true,

              /** @this {!HTMLElement} */
              get: function get() {
                return this.hasAttribute('inert');
              },

              /** @this {!HTMLElement} */
              set: function set(inert) {
                inertManager.setInert(this, inert);
              }
            });
          }
        })();
      });
    })();

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
      var _a, _b, _c;
      /* Symbols for private properties */


      const _blockingElements = Symbol();

      const _alreadyInertElements = Symbol();

      const _topElParents = Symbol();

      const _siblingsToRestore = Symbol();

      const _parentMO = Symbol();
      /* Symbols for private static methods */


      const _topChanged = Symbol();

      const _swapInertedSibling = Symbol();

      const _inertSiblings = Symbol();

      const _restoreInertedSiblings = Symbol();

      const _getParents = Symbol();

      const _getDistributedChildren = Symbol();

      const _isInertable = Symbol();

      const _handleMutations = Symbol();

      class BlockingElementsImpl {
        constructor() {
          /**
           * The blocking elements.
           */
          this[_a] = [];
          /**
           * Used to keep track of the parents of the top element, from the element
           * itself up to body. When top changes, the old top might have been removed
           * from the document, so we need to memoize the inerted parents' siblings
           * in order to restore their inerteness when top changes.
           */

          this[_b] = [];
          /**
           * Elements that are already inert before the first blocking element is
           * pushed.
           */

          this[_c] = new Set();
        }

        destructor() {
          // Restore original inertness.
          this[_restoreInertedSiblings](this[_topElParents]); // Note we don't want to make these properties nullable on the class,
          // since then we'd need non-null casts in many places. Calling a method on
          // a BlockingElements instance after calling destructor will result in an
          // exception.


          const nullable = this;
          nullable[_blockingElements] = null;
          nullable[_topElParents] = null;
          nullable[_alreadyInertElements] = null;
        }

        get top() {
          const elems = this[_blockingElements];
          return elems[elems.length - 1] || null;
        }

        push(element) {
          if (!element || element === this.top) {
            return;
          } // Remove it from the stack, we'll bring it to the top.


          this.remove(element);

          this[_topChanged](element);

          this[_blockingElements].push(element);
        }

        remove(element) {
          const i = this[_blockingElements].indexOf(element);

          if (i === -1) {
            return false;
          }

          this[_blockingElements].splice(i, 1); // Top changed only if the removed element was the top element.


          if (i === this[_blockingElements].length) {
            this[_topChanged](this.top);
          }

          return true;
        }

        pop() {
          const top = this.top;
          top && this.remove(top);
          return top;
        }

        has(element) {
          return this[_blockingElements].indexOf(element) !== -1;
        }
        /**
         * Sets `inert` to all document elements except the new top element, its
         * parents, and its distributed content.
         */


        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
          const toKeepInert = this[_alreadyInertElements];
          const oldParents = this[_topElParents]; // No new top, reset old top if any.

          if (!newTop) {
            this[_restoreInertedSiblings](oldParents);

            toKeepInert.clear();
            this[_topElParents] = [];
            return;
          }

          const newParents = this[_getParents](newTop); // New top is not contained in the main document!


          if (newParents[newParents.length - 1].parentNode !== document.body) {
            throw Error('Non-connected element cannot be a blocking element');
          } // Cast here because we know we'll call _inertSiblings on newParents
          // below.


          this[_topElParents] = newParents;

          const toSkip = this[_getDistributedChildren](newTop); // No previous top element.


          if (!oldParents.length) {
            this[_inertSiblings](newParents, toSkip, toKeepInert);

            return;
          }

          let i = oldParents.length - 1;
          let j = newParents.length - 1; // Find common parent. Index 0 is the element itself (so stop before it).

          while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
            i--;
            j--;
          } // If up the parents tree there are 2 elements that are siblings, swap
          // the inerted sibling.


          if (oldParents[i] !== newParents[j]) {
            this[_swapInertedSibling](oldParents[i], newParents[j]);
          } // Restore old parents siblings inertness.


          i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i)); // Make new parents siblings inert.

          j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
        }
        /**
         * Swaps inertness between two sibling elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_swapInertedSibling](oldInert, newInert) {
          const siblingsToRestore = oldInert[_siblingsToRestore]; // oldInert is not contained in siblings to restore, so we have to check
          // if it's inertable and if already inert.

          if (this[_isInertable](oldInert) && !oldInert.inert) {
            oldInert.inert = true;
            siblingsToRestore.add(oldInert);
          } // If newInert was already between the siblings to restore, it means it is
          // inertable and must be restored.


          if (siblingsToRestore.has(newInert)) {
            newInert.inert = false;
            siblingsToRestore.delete(newInert);
          }

          newInert[_parentMO] = oldInert[_parentMO];
          newInert[_siblingsToRestore] = siblingsToRestore;
          oldInert[_parentMO] = undefined;
          oldInert[_siblingsToRestore] = undefined;
        }
        /**
         * Restores original inertness to the siblings of the elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_restoreInertedSiblings](elements) {
          for (const element of elements) {
            const mo = element[_parentMO];
            mo.disconnect();
            element[_parentMO] = undefined;
            const siblings = element[_siblingsToRestore];

            for (const sibling of siblings) {
              sibling.inert = false;
            }

            element[_siblingsToRestore] = undefined;
          }
        }
        /**
         * Inerts the siblings of the elements except the elements to skip. Stores
         * the inerted siblings into the element's symbol `_siblingsToRestore`.
         * Pass `toKeepInert` to collect the already inert elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_inertSiblings](elements, toSkip, toKeepInert) {
          for (const element of elements) {
            // Assume element is not a Document, so it must have a parentNode.
            const parent = element.parentNode;
            const children = parent.children;
            const inertedSiblings = new Set();

            for (let j = 0; j < children.length; j++) {
              const sibling = children[j]; // Skip the input element, if not inertable or to be skipped.

              if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
                continue;
              } // Should be collected since already inerted.


              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            } // Store the siblings that were inerted.


            element[_siblingsToRestore] = inertedSiblings; // Observe only immediate children mutations on the parent.

            const mo = new MutationObserver(this[_handleMutations].bind(this));
            element[_parentMO] = mo;
            let parentToObserve = parent; // If we're using the ShadyDOM polyfill, then our parent could be a
            // shady root, which is an object that acts like a ShadowRoot, but isn't
            // actually a node in the real DOM. Observe the real DOM parent instead.

            const maybeShadyRoot = parentToObserve;

            if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
              parentToObserve = maybeShadyRoot.host;
            }

            mo.observe(parentToObserve, {
              childList: true
            });
          }
        }
        /**
         * Handles newly added/removed nodes by toggling their inertness.
         * It also checks if the current top Blocking Element has been removed,
         * notifying and removing it.
         */


        [_handleMutations](mutations) {
          const parents = this[_topElParents];
          const toKeepInert = this[_alreadyInertElements];

          for (const mutation of mutations) {
            // If the target is a shadowRoot, get its host as we skip shadowRoots when
            // computing _topElParents.
            const target = mutation.target.host || mutation.target;
            const idx = target === document.body ? parents.length : parents.indexOf(target);
            const inertedChild = parents[idx - 1];
            const inertedSiblings = inertedChild[_siblingsToRestore]; // To restore.

            for (let i = 0; i < mutation.removedNodes.length; i++) {
              const sibling = mutation.removedNodes[i];

              if (sibling === inertedChild) {
                console.info('Detected removal of the top Blocking Element.');
                this.pop();
                return;
              }

              if (inertedSiblings.has(sibling)) {
                sibling.inert = false;
                inertedSiblings.delete(sibling);
              }
            } // To inert.


            for (let i = 0; i < mutation.addedNodes.length; i++) {
              const sibling = mutation.addedNodes[i];

              if (!this[_isInertable](sibling)) {
                continue;
              }

              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            }
          }
        }
        /**
         * Returns if the element is inertable.
         */


        [_isInertable](element) {
          return false === /^(style|template|script)$/.test(element.localName);
        }
        /**
         * Returns the list of newParents of an element, starting from element
         * (included) up to `document.body` (excluded).
         */


        [_getParents](element) {
          const parents = [];
          let current = element; // Stop to body.

          while (current && current !== document.body) {
            // Skip shadow roots.
            if (current.nodeType === Node.ELEMENT_NODE) {
              parents.push(current);
            } // ShadowDom v1


            if (current.assignedSlot) {
              // Collect slots from deepest slot to top.
              while (current = current.assignedSlot) {
                parents.push(current);
              } // Continue the search on the top slot.


              current = parents.pop();
              continue;
            }

            current = current.parentNode || current.host;
          }

          return parents;
        }
        /**
         * Returns the distributed children of the element's shadow root.
         * Returns null if the element doesn't have a shadow root.
         */


        [_getDistributedChildren](element) {
          const shadowRoot = element.shadowRoot;

          if (!shadowRoot) {
            return null;
          }

          const result = new Set();
          let i;
          let j;
          let nodes;
          const slots = shadowRoot.querySelectorAll('slot');

          if (slots.length && slots[0].assignedNodes) {
            for (i = 0; i < slots.length; i++) {
              nodes = slots[i].assignedNodes({
                flatten: true
              });

              for (j = 0; j < nodes.length; j++) {
                if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                  result.add(nodes[j]);
                }
              }
            } // No need to search for <content>.

          }

          return result;
        }

      }

      document.$blockingElements = new BlockingElementsImpl();
    })();

    /**
     * Returns a function that will, when called, force the component
     * that uses this hook to re-render itself.
     *
     * It's a bit smelly, so best to use sparingly.
     */

    function useForceUpdate() {
      const [, set] = p(0);
      return _(() => set(i => ++i)).current;
    }

    function useHasFocus(_ref) {
      let {
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onLastActiveElementChange,
        onActiveElementChange,
        onWindowFocusedChange
      } = _ref;
      useEnsureStability("useHasFocus", onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange);
      const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse$1);
      const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse$1);
      const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse$1);
      const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse$1);
      const {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused,
        useActiveElementProps,
        getElement
      } = useActiveElement({
        onActiveElementChange: T$1((activeElement, prevActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == activeElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(activeElement));
          setFocused(focused);
          setFocusedInner(focusedInner);
          onActiveElementChange === null || onActiveElementChange === void 0 ? void 0 : onActiveElementChange(activeElement, prevActiveElement);
        }, []),
        onLastActiveElementChange: T$1((lastActiveElement, prevLastActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == lastActiveElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(lastActiveElement));
          setLastFocused(focused);
          setLastFocusedInner(focusedInner);
          onLastActiveElementChange === null || onLastActiveElementChange === void 0 ? void 0 : onLastActiveElementChange(lastActiveElement, prevLastActiveElement);
        }, []),
        onWindowFocusedChange
      });
      const useHasFocusProps = T$1(props => {
        return useActiveElementProps(props);
      }, []);
      return {
        useHasFocusProps,
        getElement,
        getFocused,
        getFocusedInner,
        getLastFocused,
        getLastFocusedInner,
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }

    function capitalize(str) {
      return str[0].toUpperCase() + str.substring(1);
    }
    /**
     * Inspects the element's style and determines the logical direction that text flows.
     *
     * Certain CSS properties, like `block-size`, respect the current writing mode and text direction.
     * But `transform`, `clip`, etc. don't.
     *
     * This is provided so that CSS properties can consistently use those logical properties.
     *
     * See https://drafts.csswg.org/css-writing-modes/#logical-to-physical
     *
     * @returns An object containing the following functions:
     * * `getLogicalDirection`: retrieves a `LogicalDirectionInfo` representing the current state of the element. (Function is constant between renders)
     * * `convertElementSize`: When used in conjunction with `useElementSize`, allows you to retrieve the logical size of an element instead of the physical size.
     * * `convertToLogicalOrientation`: Based on the current direction, converts "horizontal" or "vertical" to "inline" or "block".
     * * `convertToPhysicalOrientation`:  Based on the current direction, converts "inline" or "block" to "horizontal" or "vertical".
     */


    function useLogicalDirection(_ref) {
      let {
        onLogicalDirectionChange
      } = _ref;
      useEnsureStability("useLogicalDirection", onLogicalDirectionChange);
      const [getComputedStyles, setComputedStyles] = usePassiveState(null, returnNull);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: T$1(element => {
          if (element) {
            setComputedStyles(window.getComputedStyle(element));
          }
        }, [])
      }); // TODO: There's no way to refresh which writing mode we have once mounted.
      //   A. There's no way to watch for CSS style changes
      //   B. Calling getComputedStyle after every render for every element gets expensive fast and
      //   C. Is not necessary for most use cases that will never switch writing-mode within a single component
      //      (Those that do will need to mount and unmount the component that uses it)
      //
      // As a solution, here's a cheap workaround that checks when the element's size has changed,
      // and if so, tests if the writing mode has changed too.
      //
      // This will work for at least some number of cases, but a better solution is still needed.

      const {
        useElementSizeProps
      } = useElementSize({
        onSizeChange: T$1(_ => onLogicalDirectionChange === null || onLogicalDirectionChange === void 0 ? void 0 : onLogicalDirectionChange(getLogicalDirectionInfo()), [])
      });
      const getLogicalDirectionInfo = T$1(() => {
        const computedStyles = getComputedStyles();

        if (computedStyles) {
          const w = computedStyles.writingMode;
          let d = computedStyles.direction;
          const t = computedStyles.textOrientation;
          if (t == "upright") d = "ltr";
          return { ...WritingModes[w || "horizontal-tb"][d || "ltr"]
          };
        }

        return null;
      }, []); //const [getLogicalDirectionInfo, setLogicalDirectionInfo] = usePassiveState<LogicalDirectionInfo>(onLogicalDirectionChange);

      const convertToLogicalOrientation = T$1((elementOrientation, direction) => {
        var _direction, _direction2;

        (_direction = direction) !== null && _direction !== void 0 ? _direction : direction = getLogicalDirectionInfo();
        if (((_direction2 = direction) === null || _direction2 === void 0 ? void 0 : _direction2.inlineOrientation) === elementOrientation) return "inline";
        return "block";
      }, []);
      const convertToPhysicalSide = T$1((side, direction) => {
        var _direction3, _direction$blockDirec, _direction4, _direction$blockDirec2, _direction5, _direction$inlineDire, _direction6, _direction$inlineDire2, _direction7;

        (_direction3 = direction) !== null && _direction3 !== void 0 ? _direction3 : direction = getLogicalDirectionInfo();

        switch (side) {
          case "block-start":
            return M[((_direction$blockDirec = (_direction4 = direction) === null || _direction4 === void 0 ? void 0 : _direction4.blockDirection) !== null && _direction$blockDirec !== void 0 ? _direction$blockDirec : "ttb")[0]];

          case "block-end":
            return M[((_direction$blockDirec2 = (_direction5 = direction) === null || _direction5 === void 0 ? void 0 : _direction5.blockDirection) !== null && _direction$blockDirec2 !== void 0 ? _direction$blockDirec2 : "ttb")[2]];

          case "inline-start":
            return M[((_direction$inlineDire = (_direction6 = direction) === null || _direction6 === void 0 ? void 0 : _direction6.inlineDirection) !== null && _direction$inlineDire !== void 0 ? _direction$inlineDire : "ltr")[0]];

          case "inline-end":
            return M[((_direction$inlineDire2 = (_direction7 = direction) === null || _direction7 === void 0 ? void 0 : _direction7.inlineDirection) !== null && _direction$inlineDire2 !== void 0 ? _direction$inlineDire2 : "ltr")[2]];
        }
      }, []);
      const convertToLogicalSide = T$1((side, direction) => {
        var _direction8, _direction9, _direction10;

        (_direction8 = direction) !== null && _direction8 !== void 0 ? _direction8 : direction = getLogicalDirectionInfo();

        if (((_direction9 = direction) === null || _direction9 === void 0 ? void 0 : _direction9.inlineOrientation) === "vertical") {
          switch (side) {
            case "top":
              return direction.inlineDirection === "ttb" ? "inline-start" : "inline-end";

            case "bottom":
              return direction.inlineDirection === "btt" ? "inline-start" : "inline-end";

            case "left":
              return direction.blockDirection === "ltr" ? "block-start" : "block-end";

            case "right":
              return direction.blockDirection === "rtl" ? "block-start" : "block-end";
          }
        } else if (((_direction10 = direction) === null || _direction10 === void 0 ? void 0 : _direction10.inlineOrientation) === "horizontal") {
          switch (side) {
            case "top":
              return direction.blockDirection === "ttb" ? "block-start" : "block-end";

            case "bottom":
              return direction.blockDirection === "btt" ? "block-start" : "block-end";

            case "left":
              return direction.inlineDirection === "ltr" ? "inline-start" : "inline-end";

            case "right":
              return direction.inlineDirection === "rtl" ? "inline-start" : "inline-end";
          }
        }
        /* eslint-disable no-debugger */


        debugger;
        console.assert(false);
        return "inline-start";
      }, []);
      const convertToPhysicalOrientation = T$1((elementOrientation, direction) => {
        var _direction11;

        (_direction11 = direction) !== null && _direction11 !== void 0 ? _direction11 : direction = getLogicalDirectionInfo();

        if (elementOrientation == "inline") {
          var _direction12;

          if (((_direction12 = direction) === null || _direction12 === void 0 ? void 0 : _direction12.inlineOrientation) == "horizontal") return "horizontal";
          return "vertical";
        } else {
          var _direction13;

          if (((_direction13 = direction) === null || _direction13 === void 0 ? void 0 : _direction13.blockOrientation) == "vertical") return "vertical";
          return "horizontal";
        }
      }, []);
      const convertElementSize = T$1((elementSize, direction) => {
        var _direction14;

        (_direction14 = direction) !== null && _direction14 !== void 0 ? _direction14 : direction = getLogicalDirectionInfo();

        if (direction) {
          const {
            inlineSize,
            blockSize,
            inlineDirection,
            blockDirection
          } = direction; // Size is relatively simple

          const clientInlineSize = elementSize[`client${capitalize(inlineSize)}`];
          const clientBlockSize = elementSize[`client${capitalize(blockSize)}`];
          const offsetInlineSize = elementSize[`offset${capitalize(inlineSize)}`];
          const offsetBlockSize = elementSize[`offset${capitalize(blockSize)}`];
          const scrollInlineSize = elementSize[`scroll${capitalize(inlineSize)}`];
          const scrollBlockSize = elementSize[`scroll${capitalize(blockSize)}`];
          const f1 = getPhysicalLeftTop(inlineDirection);
          const f2 = getPhysicalRightBottom(inlineDirection);
          const f3 = getPhysicalLeftTop(blockDirection);
          const f4 = getPhysicalRightBottom(blockDirection);
          const clientInlineInset = elementSize[`client${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`client${capitalize(f2)}`]);
          const scrollInlineInset = elementSize[`scroll${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`scroll${capitalize(f2)}`]);
          const offsetInlineInset = elementSize[`offset${capitalize(f1)}`] == undefined ? undefined : elementSize[`offset${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`offset${capitalize(f2)}`]);
          const clientBlockInset = elementSize[`client${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`client${capitalize(f4)}`]);
          const scrollBlockInset = elementSize[`scroll${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`scroll${capitalize(f4)}`]);
          const offsetBlockInset = elementSize[`offset${capitalize(f3)}`] == undefined ? undefined : elementSize[`offset${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`offset${capitalize(f4)}`]);
          return {
            clientInlineSize,
            scrollInlineSize,
            offsetInlineSize,
            clientBlockSize,
            scrollBlockSize,
            offsetBlockSize,
            clientInlineInset,
            scrollInlineInset,
            offsetInlineInset,
            clientBlockInset,
            scrollBlockInset,
            offsetBlockInset
          };
        }

        return null;
      }, []);
      return {
        useLogicalDirectionProps: T$1(props => useRefElementProps(useElementSizeProps(props)), []),
        getElement,
        getLogicalDirectionInfo,
        convertToLogicalSize: convertElementSize,
        convertToLogicalOrientation,
        convertToPhysicalOrientation,
        convertToLogicalSide,
        convertToPhysicalSide
      };
    } // Position requires us to sometimes use one property (like `left`)
    // or sometimes two (like `left` + `width`)

    function getPhysicalLeftTop(dir) {
      if (dir === "ltr" || dir == "rtl") return "left";
      return "top";
    }

    function getPhysicalRightBottom(dir) {
      if (dir === "rtl") return "width";
      if (dir === "btt") return "height";
      return null;
    } // Helper for extracting info from "ltr", "ttb", etc.


    const M = {
      t: "top",
      b: "bottom",
      l: "left",
      r: "right"
    };
    const HorizontalTbLtr = {
      inlineDirection: "ltr",
      blockDirection: "ttb",
      inlineOrientation: "horizontal",
      blockOrientation: "vertical",
      inlineSize: "width",
      blockSize: "height",
      leftRightDirection: "ltr",
      overUnderDirection: "ttb"
    };
    const HorizontalTbRtl = { ...HorizontalTbLtr,
      inlineDirection: "rtl"
    };
    const VerticalRlLtr = {
      inlineDirection: "ttb",
      blockDirection: "rtl",
      inlineOrientation: "vertical",
      blockOrientation: "horizontal",
      inlineSize: "height",
      blockSize: "width",
      leftRightDirection: "ttb",
      overUnderDirection: "rtl"
    };
    const VerticalRlRtl = { ...VerticalRlLtr,
      inlineDirection: "btt"
    };
    const SidewaysRlLtr = { ...VerticalRlLtr
    };
    const SidewaysRlRtl = { ...VerticalRlRtl
    };
    const VerticalLrLtr = { ...VerticalRlLtr,
      blockDirection: "ltr"
    };
    const VerticalLrRtl = { ...VerticalRlRtl,
      blockDirection: "ltr"
    };
    const SidewaysLtLtr = { ...VerticalLrLtr,
      inlineDirection: "btt",
      leftRightDirection: "btt",
      overUnderDirection: "ltr"
    };
    const SidewaysLtRtl = { ...SidewaysLtLtr,
      inlineDirection: "ttb"
    };
    const HorizontalTb = {
      ltr: HorizontalTbLtr,
      rtl: HorizontalTbRtl
    };
    const VerticalRl = {
      ltr: VerticalRlLtr,
      rtl: VerticalRlRtl
    };
    const VerticalLr = {
      ltr: VerticalLrLtr,
      rtl: VerticalLrRtl
    };
    const SidewaysRl = {
      ltr: SidewaysRlLtr,
      rtl: SidewaysRlRtl
    };
    const SidewaysLr = {
      ltr: SidewaysLtLtr,
      rtl: SidewaysLtRtl
    };
    const WritingModes = {
      "horizontal-tb": HorizontalTb,
      "vertical-lr": VerticalLr,
      "vertical-rl": VerticalRl,
      "sideways-lr": SidewaysLr,
      "sideways-rl": SidewaysRl
    };

    function useTimeout(_ref) {
      let {
        timeout,
        callback,
        triggerIndex
      } = _ref;
      const stableCallback = useStableCallback(() => {
        startTimeRef.current = null;
        callback();
      });
      const getTimeout = useStableGetter(timeout); // Set any time we start timeout.
      // Unset any time the timeout completes

      const startTimeRef = _(null);
      const timeoutIsNull = timeout == null; // Any time the triggerIndex changes (including on mount)
      // restart the timeout.  The timeout does NOT reset
      // when the duration or callback changes, only triggerIndex.

      h(() => {
        if (!timeoutIsNull) {
          const timeout = getTimeout();
          console.assert(timeoutIsNull == (timeout == null));

          if (timeout != null) {
            startTimeRef.current = +new Date();
            const handle = setTimeout(stableCallback, timeout);
            return () => clearTimeout(handle);
          }
        }
      }, [triggerIndex, timeoutIsNull]);
      const getElapsedTime = T$1(() => {
        var _startTimeRef$current;

        return +new Date() - +((_startTimeRef$current = startTimeRef.current) !== null && _startTimeRef$current !== void 0 ? _startTimeRef$current : new Date());
      }, []);
      const getRemainingTime = T$1(() => {
        const timeout = getTimeout();
        return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
      }, []);
      return {
        getElapsedTime,
        getRemainingTime
      };
    }

    /** Arguments passed to the child 'useLinearNavigationChild` */
    //export interface UseLinearNavigationChildInfo { }

    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useLinearNavigation(_ref) {
      var _nd;

      let {
        linearNavigation: {
          navigateToFirst: ntf,
          navigateToLast: ntl,
          navigateToNext: ntn,
          navigateToPrev: ntp,
          navigationDirection: nd,
          disableArrowKeys: dak,
          disableHomeEndKeys: dhek
        }
      } = _ref;
      (_nd = nd) !== null && _nd !== void 0 ? _nd : nd = "either";
      const {
        getLogicalDirectionInfo,
        useLogicalDirectionProps
      } = useLogicalDirection({});
      const navigateToFirst = useStableCallback(ntf);
      const navigateToLast = useStableCallback(ntl);
      const navigateToNext = useStableCallback(ntn);
      const navigateToPrev = useStableCallback(ntp);
      const getDisableArrowKeys = useStableGetter(dak);
      const getDisableHomeEndKeys = useStableGetter(dhek);
      const getNavigationDirection = useStableGetter(nd);
      return {
        linearNavigation: {},
        useLinearNavigationProps: T$1(props => {
          const onKeyDown = e => {
            // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
            if (e.ctrlKey || e.metaKey) return;
            const info = getLogicalDirectionInfo();
            const navigationDirection = getNavigationDirection();
            const disableArrowKeys = getDisableArrowKeys();
            const disableHomeEndKeys = getDisableHomeEndKeys();
            const allowsBlockNavigation = navigationDirection == "block" || navigationDirection == "either";
            const allowsInlineNavigation = navigationDirection == "inline" || navigationDirection == "either";

            switch (e.key) {
              case "ArrowUp":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowDown":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowLeft":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "rtl") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowRight":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "rtl") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  e.preventDefault();
                  e.stopPropagation();
                  break;
                }

              case "Home":
                if (!disableHomeEndKeys) {
                  navigateToFirst();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;

              case "End":
                if (!disableHomeEndKeys) {
                  navigateToLast();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;
            }
          };

          return useLogicalDirectionProps(useMergedProps({
            onKeyDown
          }, props));
        }, [])
      };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useTypeaheadNavigation(_ref2) {
      let {
        typeaheadNavigation: {
          collator,
          getIndex,
          typeaheadTimeout,
          setIndex,
          noTypeahead
        }
      } = _ref2;
      // For typeahead, keep track of what our current "search" string is (if we have one)
      // and also clear it every 1000 ms since the last time it changed.
      // Next, keep a mapping of typeahead values to indices for faster searching.
      // And, for the user's sake, let them know when their typeahead can't match anything anymore
      const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
      useTimeout({
        timeout: typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000,
        callback: () => {
          setCurrentTypeahead(null);
          setInvalidTypeahead(null);
        },
        triggerIndex: currentTypeahead
      });
      const sortedTypeaheadInfo = _([]);
      const [invalidTypeahead, setInvalidTypeahead] = useState(false); // Handle typeahead for input method editors as well
      // Essentially, when active, ignore further keys 
      // because we're waiting for a CompositionEnd event

      const [, setImeActive, getImeActive] = useState(false); // Because composition events fire *after* keydown events 
      // (but within the same task, which, TODO, could be browser-dependent),
      // we can use this to keep track of which event we're listening for on the first keydown.

      const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
      useLayoutEffect(() => {
        if (nextTypeaheadChar !== null) {
          setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar);
          setNextTypeaheadChar(null);
        }
      }, [nextTypeaheadChar]);
      const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
        var _safeRhs$toLowerCase;

        let compare; // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
        // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.

        safeLhs = safeLhs.normalize("NFD");
        safeRhs = safeRhs.normalize("NFD");
        if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
        return compare;
      });
      const insertingComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          return comparatorShared(lhs, rhs.text);
        }

        return lhs - rhs;
      });
      const typeaheadComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          // During typeahead, all strings longer than ours should be truncated
          // so that they're all considered equally by that point.
          return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
        }

        return lhs - rhs;
      });
      const isDisabled = useStableGetter(noTypeahead);
      const useTypeaheadNavigationProps = T$1(function (_ref3) {
        let { ...props
        } = _ref3;

        const onCompositionStart = _e => {
          setImeActive(true);
        };

        const onCompositionEnd = e => {
          setNextTypeaheadChar(e.data);
          setImeActive(false);
        };

        const onKeyDown = e => {
          if (isDisabled()) return;
          const imeActive = getImeActive();
          const key = e.key; // Not handled by typeahead (i.e. assume this is a keyboard shortcut)

          if (e.ctrlKey || e.metaKey) return;

          if (!imeActive && e.key === "Backspace") {
            // Remove the last character in a way that doesn't split UTF-16 surrogates.
            setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
            e.preventDefault();
            e.stopPropagation();
            return;
          } // The key property represents the typed character OR the "named key attribute" of the key pressed.
          // There's no definite way to tell the difference, but for all intents and purposes
          // there are no one-character names, and there are no non-ASCII-alpha names.
          // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.


          const isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);

          if (isCharacterKey) {
            var _getCurrentTypeahead;

            if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ; else {
              e.preventDefault();
              e.stopPropagation(); // Note: Won't be true for the first keydown
              // but will be overwritten before useLayoutEffect is called
              // to actually apply the change

              if (!imeActive) setNextTypeaheadChar(key);
            }
          }
        };

        return useMergedProps({
          onKeyDown,
          onCompositionStart,
          onCompositionEnd
        }, props);
      }, []); // Handle changes in typeahead that cause changes to the tabbable index

      h(() => {
        if (currentTypeahead && sortedTypeaheadInfo.current.length) {
          const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);

          if (sortedTypeaheadIndex < 0) {
            // The user has typed an entry that doesn't exist in the list
            // (or more specifically "for which there is no entry that starts with that input")
            setInvalidTypeahead(true);
          } else {
            setInvalidTypeahead(false);
            /*
              We know roughly where, in the sorted array of strings, our next typeahead location is.
              But roughly isn't good enough if there are multiple matches.
              To convert our sorted index to the unsorted index we need, we have to find the first
              element that matches us *and* (if any such exist) is *after* our current selection.
                In other words, the only way typeahead moves backwards relative to our current
              position is if the only other option is behind us.
                It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
              Though there's also a case for just going upwards to the nearest to prevent jumpiness.
              But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
              I dunno. Going back to the start is the simplist though.
                Basically what this does: Starting from where we found ourselves after our binary search,
              scan backwards and forwards through all adjacent entries that also compare equally so that
              we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
              (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
                TODO: The binary search starts this off with a solid O(log n), but one-character
              searches are, thanks to pigeonhole principal, eventually guaranteed to become
              O(n*log n). This is annoying but probably not easily solvable? There could be an
              exception for one-character strings, but that's just kicking the can down
              the road. Maybe one or two characters would be good enough though.
            */
            // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.

            let lowestUnsortedIndexAll = null;
            let lowestSortedIndexAll = sortedTypeaheadIndex; // These two are only set for elements that are ahead of us, but the principle's the same otherwise

            let lowestUnsortedIndexNext = null;
            let lowestSortedIndexNext = sortedTypeaheadIndex;

            const updateBestFit = u => {
              var _getIndex;

              if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                lowestUnsortedIndexAll = u;
                lowestSortedIndexAll = i;
              }

              if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > ((_getIndex = getIndex()) !== null && _getIndex !== void 0 ? _getIndex : -Infinity)) {
                lowestUnsortedIndexNext = u;
                lowestSortedIndexNext = i;
              }
            };

            let i = sortedTypeaheadIndex;

            while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              --i;
            }

            i = sortedTypeaheadIndex;

            while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              ++i;
            }

            if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
          }
        }
      }, [currentTypeahead]);
      const useTypeaheadNavigationChild = T$1(_ref4 => {
        let {
          index,
          text
        } = _ref4;
        h(() => {
          if (text) {
            // Find where to insert this item.
            // Because all index values should be unique, the returned sortedIndex
            // should always refer to a new location (i.e. be negative)                
            const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
            console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
              unsortedIndex: index,
              text
            }) == 0);

            if (sortedIndex < 0) {
              sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, {
                text,
                unsortedIndex: index
              });
            } else {
              sortedTypeaheadInfo.current.splice(sortedIndex, 0, {
                text,
                unsortedIndex: index
              });
            }

            return () => {
              // When unmounting, find where we were and remove ourselves.
              // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
              const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
              console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
                unsortedIndex: index,
                text
              }) == 0);

              if (sortedIndex >= 0) {
                sortedTypeaheadInfo.current.splice(sortedIndex, 1);
              }
            };
          }
        }, [text]);
        return;
      }, []);
      return {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
      };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */

    function binarySearch(array, wanted, comparator) {
      let firstIndex = 0;
      let lastIndex = array.length - 1;

      while (firstIndex <= lastIndex) {
        const testIndex = lastIndex + firstIndex >> 1;
        const comparisonResult = comparator(wanted, array[testIndex]);

        if (comparisonResult > 0) {
          firstIndex = testIndex + 1;
        } else if (comparisonResult < 0) {
          lastIndex = testIndex - 1;
        } else {
          return testIndex;
        }
      }

      return -firstIndex - 1;
    }

    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `shouldFocusOnChange` should return true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const [focusedInner, setFocusedInner] = useState(false);
     * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */

    function useRovingTabIndex(parentParameters) {
      var _initialIndex;

      let {
        rovingTabIndex: {
          initialIndex,
          onTabbedInTo,
          onTabbedOutOf,
          onTabbableRender,
          onTabbableIndexChange
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters;
      (_initialIndex = initialIndex) !== null && _initialIndex !== void 0 ? _initialIndex : initialIndex = 0;
      const stableOnTabbableRender = useStableCallback(onTabbableRender !== null && onTabbableRender !== void 0 ? onTabbableRender : () => {});
      const [_getAnyFocused, setAnyFocused] = usePassiveState(useStableCallback((newCount, oldCount) => {
        if (oldCount == 0 && newCount > 0) {
          onTabbedInTo === null || onTabbedInTo === void 0 ? void 0 : onTabbedInTo();
        }

        if (newCount == 0 && (oldCount !== null && oldCount !== void 0 ? oldCount : 0) > 0) {
          onTabbedOutOf === null || onTabbedOutOf === void 0 ? void 0 : onTabbedOutOf();
        }
      }), returnZero); // Keep track of three things related to the currently tabbable element's index:
      // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.

      const [getTabbableIndex, setTabbableIndex2] = usePassiveState(onTabbableIndexChange, T$1(() => {
        var _initialIndex2;

        return (_initialIndex2 = initialIndex) !== null && _initialIndex2 !== void 0 ? _initialIndex2 : 0;
      }, []));
      const setTabbableIndex = T$1((updater, fromUserInteraction) => {
        setTabbableIndex2(prevIndex => {
          let nextIndex = prevIndex;
          if (typeof updater === "function") nextIndex = updater(prevIndex !== null && prevIndex !== void 0 ? prevIndex : null);else nextIndex = updater;
          nextIndex = changeIndex(nextIndex);

          if (prevIndex != nextIndex) {
            const nextChild = nextIndex == null ? null : parentReturnType.managedChildren.children.getAt(nextIndex);
            const prevChild = prevIndex == null ? null : parentReturnType.managedChildren.children.getAt(prevIndex);
            if (prevChild != null) prevChild.subInfo.blurSelf();
            if (nextChild != null && fromUserInteraction) nextChild.subInfo.focusSelf();
          }

          return nextIndex;
        });
      }, []); // Any time the tabbable index changes,
      // notify the previous child that it's no longer tabbable,
      // and notify the next child that is allowed to be tabbed to.

      const parentReturnType = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange: useStableCallback((mounted, unmounted) => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(mounted, unmounted);
            reevaluateClosestFit();
          })
        }
      });
      const {
        useManagedChild
      } = parentReturnType;
      const {
        changeIndex,
        reevaluateClosestFit
      } = useChildrenFlag({
        initialIndex,
        children: parentReturnType.managedChildren.children,
        closestFit: true,
        key: "tabbable"
      });
      const useRovingTabIndexChild = T$1(childParameters => {
        const {
          subInfo,
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            hidden,
            blurSelf: blurSelfOverride,
            focusSelf: focusSelfOverride
          }
        } = childParameters;
        h(() => {
          reevaluateClosestFit();
        }, [!!hidden]);
        const bsOverride = useStableGetter(blurSelfOverride);
        const fsOverride = useStableGetter(focusSelfOverride);
        const focusSelf = T$1(() => {
          const fs = fsOverride();

          if (fs) {
            console.log(`useRovingTabIndexChild[${index}].focusSelf (override)`);
            fs();
          } else {
            var _element$focus;

            console.log(`useRovingTabIndexChild[${index}].focusSelf (default)`);
            const element = getElement();
            if (element) (_element$focus = element.focus) === null || _element$focus === void 0 ? void 0 : _element$focus.call(element);
          }
        }, []);
        const blurSelf = T$1(() => {
          const bs = bsOverride();

          if (bs) {
            console.log(`useRovingTabIndexChild[${index}].blurSelf (override)`);
            bs();
          } else {
            var _element$blur;

            console.log(`useRovingTabIndexChild[${index}].blurSelf (default)`);
            const element = getElement();
            if (element) (_element$blur = element.blur) === null || _element$blur === void 0 ? void 0 : _element$blur.call(element);
          }
        }, []);
        const onFocusedInnerChanged = useStableCallback(focused => {
          setAnyFocused(prev => focused ? (prev !== null && prev !== void 0 ? prev : 0) + 1 : (prev !== null && prev !== void 0 ? prev : 0) - 1);

          if (focused) {
            console.log(`Child ${index} has been focused and will set itself as the tabbable child`);
            setTabbableIndex(index, true);
          }
        });
        const {
          getElement,
          useHasFocusProps
        } = useHasFocus({
          onFocusedInnerChanged
        });
        const [tabbable, setTabbable, getTabbable] = useState(false);
        const tabbableFlags = _({
          get: getTabbable,
          set: setTabbable,
          isValid: useStableCallback(() => !hidden)
        });

        useManagedChild({
          managedChild: {
            index,
            flags: { ...flags,
              tabbable: tabbableFlags.current
            },
            subInfo: {
              blurSelf,
              focusSelf,
              getElement,
              hidden: !!hidden,
              subInfo
            }
          }
        });

        h(() => {
          if (tabbable) stableOnTabbableRender(index);
        }, [tabbable, index]);

        function useRovingTabIndexChildProps(props) {
          console.assert(props.tabIndex == null);
          return useMergedProps(useHasFocusProps({
            tabIndex: tabbable ? 0 : -1
          }), props);
        }

        return {
          useRovingTabIndexChildProps,
          rovingTabIndex: {
            getElement,
            tabbable,
            getTabbable
          }
        };
      }, [
        /* Must remain stable */
      ]);
      const focusSelf = T$1(() => {
        var _parentReturnType$man, _parentReturnType$man2, _parentReturnType$man3;

        console.log(`useRovingTabIndex.focusSelf`);
        const index = getTabbableIndex();
        if (index != null) (_parentReturnType$man = parentReturnType.managedChildren.children.getAt(index)) === null || _parentReturnType$man === void 0 ? void 0 : (_parentReturnType$man2 = (_parentReturnType$man3 = _parentReturnType$man.subInfo).focusSelf) === null || _parentReturnType$man2 === void 0 ? void 0 : _parentReturnType$man2.call(_parentReturnType$man3);else setTabbableIndex(null, true);
      }, []);
      return {
        useRovingTabIndexChild,
        managedChildren: {
          children: parentReturnType.managedChildren.children
        },
        rovingTabIndex: {
          setTabbableIndex,
          getTabbableIndex,
          focusSelf
        }
      };
    }
    /*function test() {
        const { children, focusSelf, getTabbableIndex, setTabbableIndex, useRovingTabIndexChild, } = useRovingTabIndex<HTMLDivElement, { "foo": "bar" }, "flag2">({ managedChildren: {}, rovingTabIndex: {} });
        const { } = useRovingTabIndexChild({ managedChildren: { index: 0, flags: {} }, rti: { info3: { foo: "bar" } } });
    }*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;
      array || (array = Array(length));

      while (++index < length) {
        array[index] = source[index];
      }

      return array;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor,
        nativeRandom = Math.random;
    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */

    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */

    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;
      size = size === undefined ? length : size;

      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];
        array[rand] = array[index];
        array[index] = value;
      }

      array.length = size;
      return array;
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */

    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }

      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */

    function baseValues(object, props) {
      return arrayMap(props, function (key) {
        return object[key];
      });
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }

    /** `Object#toString` result references. */

    var argsTag$1 = '[object Arguments]';
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */

    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }

    /** Used for built-in method references. */

    var objectProto$3 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    /** Built-in value references. */

    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */

    var isArguments = baseIsArguments(function () {
      return arguments;
    }()) ? baseIsArguments : function (value) {
      return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */

    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    /** Built-in value references. */

    var Buffer = moduleExports$1 ? root.Buffer : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */

    var isBuffer = nativeIsBuffer || stubFalse;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */

    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */

    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /** Used to identify `toStringTag` values of typed arrays. */

    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */

    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */

    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        } // Legacy `process.binding('util')` for Node.js < 10.


        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    /* Node.js helper references. */

    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */

    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */

    var objectProto$2 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
        key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */

    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$1;
      return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */

    var objectProto = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */

    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }

    /** `Object#toString` result references. */

    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */

    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      } // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.


      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */

    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */

    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */

    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */

    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */

    function useRearrangeableChildren(_ref) {
      let {
        rearrangeableChildren: {
          getIndex
        }
      } = _ref;
      // These are used to keep track of a mapping between unsorted index <---> sorted index.
      // These are needed for navigation with the arrow keys.
      const mangleMap = _(new Map());
      const demangleMap = _(new Map());
      const indexMangler = T$1(n => {
        var _mangleMap$current$ge;

        return (_mangleMap$current$ge = mangleMap.current.get(n)) !== null && _mangleMap$current$ge !== void 0 ? _mangleMap$current$ge : n;
      }, []);
      const indexDemangler = T$1(n => {
        var _demangleMap$current$;

        return (_demangleMap$current$ = demangleMap.current.get(n)) !== null && _demangleMap$current$ !== void 0 ? _demangleMap$current$ : n;
      }, []); // The sort function needs to be able to update whoever has all the sortable children.
      // Because that might not be the consumer of *this* hook directly (e.g. a table uses
      // this hook, but it's tbody that actually needs updating), we need to remotely
      // get and set a forceUpdate function.
      //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);

      const [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
      const rearrange = T$1(sortedRows => {
        var _getForceUpdate;

        // Update our sorted <--> unsorted indices map 
        // and rerender the whole table, basically
        for (let indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
          const indexAsUnsorted = sortedRows[indexAsSorted].index;
          mangleMap.current.set(indexAsUnsorted, indexAsSorted);
          demangleMap.current.set(indexAsSorted, indexAsUnsorted);
        }

        (_getForceUpdate = getForceUpdate()) === null || _getForceUpdate === void 0 ? void 0 : _getForceUpdate();
      }, []);
      const useRearrangeableProps = T$1(_ref2 => {
        let {
          children,
          ...props
        } = _ref2;
        const forceUpdate = useForceUpdate();
        s(() => {
          setForceUpdate(_prev => forceUpdate);
        }, [forceUpdate]);
        return useMergedProps({
          children: children.slice().map(child => ({
            child,
            mangledIndex: indexMangler(getIndex(child.props)),
            demangledIndex: getIndex(child.props)
          })).sort((lhs, rhs) => {
            return lhs.mangledIndex - rhs.mangledIndex;
          }).map(_ref3 => {
            let {
              child,
              mangledIndex,
              demangledIndex
            } = _ref3;
            return h$1(child.type, { ...child.props,
              key: demangledIndex,
              "data-mangled-index": mangledIndex,
              "data-unmangled-index": demangledIndex
            });
          })
        }, props);
      }, []);
      return {
        useRearrangeableProps,
        rearrangeableChildren: {
          indexMangler,
          indexDemangler,
          mangleMap,
          demangleMap,
          rearrange
        }
      };
    }
    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */

    function useSortableChildren(_ref4) {
      let {
        rearrangeableChildren: {
          getIndex
        },
        sortableChildren: {
          compare: userCompare,
          getValue
        }
      } = _ref4;
      const compare = userCompare !== null && userCompare !== void 0 ? userCompare : defaultCompare;
      const {
        useRearrangeableProps: useSortableProps,
        ...rearrangeableChildrenReturnType
      } = useRearrangeableChildren({
        rearrangeableChildren: {
          getIndex
        }
      });
      const {
        rearrangeableChildren: {
          rearrange
        }
      } = rearrangeableChildrenReturnType; // The actual sort function.

      const sort = T$1(function (managedRows, direction) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        const sortedRows = managedRows.arraySlice().sort((lhsRow, rhsRow) => {
          const lhsValue = getValue(lhsRow, ...args);
          const rhsValue = getValue(rhsRow, ...args);
          const result = compare(lhsValue, rhsValue); // lhsRow.getManagedCells()?.[column]?.value, rhsRow.getManagedCells()?.[column]?.value);

          if (direction[0] == "d") return -result;
          return result;
        });
        return rearrange(sortedRows);
      }, [
        /* Must remain stable */
      ]);
      const shuffle$1 = T$1(managedRows => {
        const shuffledRows = shuffle(managedRows.arraySlice());
        return rearrange(shuffledRows);
      }, [
        /* Must remain stable */
      ]);
      return {
        useSortableProps,
        sortableChildren: {
          sort,
          shuffle: shuffle$1
        },
        rearrangeableChildren: rearrangeableChildrenReturnType.rearrangeableChildren
      };
    }

    function defaultCompare(lhs, rhs) {
      return compare1(lhs, rhs);

      function compare3(lhs, rhs) {
        // Coerce strings to numbers if they seem to stay the same when serialized
        if (`${+lhs}` === lhs) lhs = +lhs;
        if (`${+rhs}` === rhs) rhs = +rhs; // At this point, if either argument is a string, turn the other one into one too

        if (typeof lhs === "string") rhs = `${rhs}`;
        if (typeof rhs === "string") lhs = `${lhs}`;
        console.assert(typeof lhs === typeof rhs);
        if (typeof lhs === "string") return lhs.localeCompare(rhs);
        if (typeof lhs === "number") return +lhs - +rhs;
        return 0;
      }

      function compare2(lhs, rhs) {
        if (typeof lhs === "boolean" || lhs instanceof Date) lhs = +lhs;
        if (typeof rhs === "boolean" || rhs instanceof Date) rhs = +rhs;
        return compare3(lhs, rhs);
      }

      function compare1(lhs, rhs) {
        if (lhs == null && rhs == null) {
          // They're both null
          return 0;
        } else if (lhs == null || rhs == null) {
          // One of the two is null -- easy case
          return lhs != null ? 1 : -1;
        }

        return compare2(lhs, rhs);
      }
    }

    function identity(t) {
      return t;
    }
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */


    function useListNavigation(_ref) {
      var _indexMangler, _indexDemangler;

      let {
        managedChildren: mc,
        rovingTabIndex,
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        linearNavigation,
        typeaheadNavigation
      } = _ref;
      (_indexMangler = indexMangler) !== null && _indexMangler !== void 0 ? _indexMangler : indexMangler = identity;
      (_indexDemangler = indexDemangler) !== null && _indexDemangler !== void 0 ? _indexDemangler : indexDemangler = identity;
      useEnsureStability("useListNavigation", indexMangler, indexDemangler);
      const parentReturnType = useRovingTabIndex({
        managedChildren: mc,
        rovingTabIndex
      });
      const {
        useRovingTabIndexChild,
        managedChildren: {
          children
        },
        rovingTabIndex: {
          getTabbableIndex,
          setTabbableIndex
        }
      } = parentReturnType;
      const navigateToIndex = T$1((i, fromUserInteraction) => {
        if (i != null) {
          var _indexMangler2, _indexDemangler2;

          const nextIndex = tryNavigateToIndex({
            children: children,
            default: 0,
            target: i,
            searchDirection: 1,
            indexMangler: (_indexMangler2 = indexMangler) !== null && _indexMangler2 !== void 0 ? _indexMangler2 : identity,
            indexDemangler: (_indexDemangler2 = indexDemangler) !== null && _indexDemangler2 !== void 0 ? _indexDemangler2 : identity
          });
          setTabbableIndex(i == null ? null : nextIndex, fromUserInteraction);
        } else {
          setTabbableIndex(null, fromUserInteraction);
        }
      }, []);
      const {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
      } = useTypeaheadNavigation({
        typeaheadNavigation: {
          getIndex: getTabbableIndex,
          setIndex: T$1(index => {
            setTabbableIndex(index, true);
          }, []),
          ...typeaheadNavigation
        }
      });
      const {
        useLinearNavigationProps
      } = useLinearNavigation({
        linearNavigation: {
          navigateToPrev: T$1(() => {
            setTabbableIndex(c => {
              var _indexMangler3, _indexDemangler3;

              return tryNavigateToIndex({
                children,
                default: c !== null && c !== void 0 ? c : 0,
                target: indexDemangler(indexMangler(c !== null && c !== void 0 ? c : 0) - 1),
                searchDirection: -1,
                indexMangler: (_indexMangler3 = indexMangler) !== null && _indexMangler3 !== void 0 ? _indexMangler3 : identity,
                indexDemangler: (_indexDemangler3 = indexDemangler) !== null && _indexDemangler3 !== void 0 ? _indexDemangler3 : identity
              });
            }, true);
          }, []),
          navigateToNext: T$1(() => {
            setTabbableIndex(c => {
              var _indexMangler4, _indexDemangler4;

              return tryNavigateToIndex({
                children,
                default: c !== null && c !== void 0 ? c : 0,
                target: indexDemangler(indexMangler(c !== null && c !== void 0 ? c : 0) + 1),
                searchDirection: 1,
                indexMangler: (_indexMangler4 = indexMangler) !== null && _indexMangler4 !== void 0 ? _indexMangler4 : identity,
                indexDemangler: (_indexDemangler4 = indexDemangler) !== null && _indexDemangler4 !== void 0 ? _indexDemangler4 : identity
              });
            }, true);
          }, []),
          navigateToFirst: T$1(() => {
            navigateToIndex(indexDemangler(0), true);
          }, []),
          navigateToLast: T$1(() => {
            navigateToIndex(indexDemangler(children.getHighestIndex()), true);
          }, []),
          ...linearNavigation
        }
      });
      const useListNavigationProps = T$1(props => {
        return useLinearNavigationProps(useTypeaheadNavigationProps(props));
      }, [useLinearNavigationProps, useTypeaheadNavigationProps]);
      const useListNavigationChild = T$1(_ref2 => {
        let {
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden
          },
          listNavigation: {
            text
          },
          subInfo
        } = _ref2;

        useTypeaheadNavigationChild({
          text,
          index
        });

        const getIndex = useStableGetter(index);
        useEffect(() => {
          return () => {
            if (getTabbableIndex() == getIndex()) {
              navigateToIndex(index, false);
            }
          };
        }, []);
        const {
          useRovingTabIndexChildProps,
          rovingTabIndex: {
            tabbable,
            getTabbable,
            getElement
          }
        } = useRovingTabIndexChild({
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden: !!hidden
          },
          subInfo: {
            text,
            subInfo
          }
        });

        const useListNavigationChildProps = function (_ref3) {
          let { ...props
          } = _ref3;
          return useMergedProps(useRovingTabIndexChildProps({
            inert: hidden
          }), props);
        };

        return {
          useListNavigationChildProps,
          rovingTabIndex: {
            tabbable,
            getTabbable,
            getElement
          }
        };
      }, [useTypeaheadNavigationChild, useRovingTabIndexChild, navigateToIndex]);
      return {
        useListNavigationChild,
        useListNavigationProps,
        listNavigation: {
          navigateToIndex
        },
        managedChildren: parentReturnType.managedChildren,
        rovingTabIndex: parentReturnType.rovingTabIndex,
        linearNavigation: {},
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
        /*listNavigation: { navigateToIndex },
        rovingTabIndex: { focusSelf, getTabbableIndex, setTabbableIndex },
        linearNavigation: {},
        typeaheadNavigation: { currentTypeahead, invalidTypeahead }*/

      };
    }
    /**
     * It's very common to combine a tabbable list of things and "selection" of one of those things.
     *
     * Lists, radio buttons, tabs, etc. etc.
     *
     * This is a shortcut that combines the two with the correct typing.
     * @param param0
     * @returns
     */

    function useListNavigationSingleSelection(_ref4) {
      var _ref5;

      let {
        singleSelection: {
          selectedIndex
        },
        listNavigation,
        managedChildren: {
          /*onChildrenMountChange: ocmc,*/
          ...mc
        },
        rovingTabIndex: {
          initialIndex,
          ...rovingTabIndex
        },
        linearNavigation,
        typeaheadNavigation
      } = _ref4;
      const parentReturnType = useListNavigation({
        listNavigation,
        managedChildren: { ...mc
          /*onChildrenMountChange: useStableCallback<OnChildrenMountChange<number>>((mounted, unmounted) => {
              reevaluateClosestFit();
              ocmc?.(mounted, unmounted);
          })*/

        },
        rovingTabIndex: {
          initialIndex: (_ref5 = initialIndex !== null && initialIndex !== void 0 ? initialIndex : selectedIndex) !== null && _ref5 !== void 0 ? _ref5 : undefined,
          ...rovingTabIndex
        },
        linearNavigation,
        typeaheadNavigation
      });
      const {
        useListNavigationChild,
        useListNavigationProps,
        ...listRest
      } = parentReturnType;
      const {
        managedChildren: {
          children
        }
      } = listRest;
      const {
        changeIndex: changeSelectedIndex,
        getCurrentIndex: getSelectedIndex //reevaluateClosestFit

      } = useChildrenFlag({
        children: children,
        initialIndex: selectedIndex,
        key: "selected",
        closestFit: false
      });
      s(() => {
        changeSelectedIndex(selectedIndex);
      }, [selectedIndex]);
      return {
        useListNavigationSingleSelectionChild: T$1(_ref6 => {
          let {
            managedChild: {
              index,
              flags
            },
            rovingTabIndex: rti,
            listNavigation: ls,
            subInfo
          } = _ref6;
          const [isSelected, setIsSelected, getIsSelected] = useState(getSelectedIndex() == index);
          const selectedRef = _({
            get: getIsSelected,
            set: setIsSelected,
            isValid: useStableCallback(() => !rti.hidden)
          });
          const {
            rovingTabIndex: rti_ret,
            useListNavigationChildProps
          } = useListNavigationChild({
            managedChild: {
              index,
              flags: {
                selected: selectedRef.current,
                ...flags
              }
            },
            rovingTabIndex: rti,
            listNavigation: ls,
            subInfo
          });
          return {
            useListNavigationSingleSelectionChildProps: useListNavigationChildProps,
            rovingTabIndex: rti_ret,
            singleSelection: {
              selected: isSelected,
              getSelected: getIsSelected
            }
          };
        }, []),
        useListNavigationSingleSelectionProps: T$1(function () {
          return useListNavigationProps(...arguments);
        }, []),
        ...listRest,
        singleSelection: {}
      };
    }
    function tryNavigateToIndex(_ref9) {
      let {
        children,
        searchDirection,
        indexDemangler,
        indexMangler,
        target
      } = _ref9;
      const upper = children.getHighestIndex();
      const lower = 0;

      if (searchDirection === -1) {
        while (target >= lower && children.getAt(target) == null || !!((_children$getAt = children.getAt(target)) !== null && _children$getAt !== void 0 && _children$getAt.subInfo.hidden)) {
          var _children$getAt;

          target = indexDemangler(indexMangler(target) - 1);
        }

        return target < lower ? indexDemangler(lower) : target;
      } else if (searchDirection === 1) {
        while (target <= upper && children.getAt(target) == null || !!((_children$getAt2 = children.getAt(target)) !== null && _children$getAt2 !== void 0 && _children$getAt2.subInfo.hidden)) {
          var _children$getAt2;

          target = indexDemangler(indexMangler(target) + 1);
        }

        return target > upper ? indexDemangler(upper) : target;
      } else {
        return lower;
      }
    }

    function useGridNavigation(_ref) {
      var _rti$initialIndex;

      let {
        managedChildren: mc,
        rovingTabIndex: rti,
        listNavigation: ls,
        linearNavigation: ln,
        typeaheadNavigation: tn
      } = _ref;
      const [currentColumn, setCurrentColumn, getCurrentColumn] = useState((_rti$initialIndex = rti.initialIndex) !== null && _rti$initialIndex !== void 0 ? _rti$initialIndex : 0);
      const {
        useListNavigationChild: useListNavigationChildAsGridRow,
        useListNavigationProps: useListNavigationPropsAsGridParent,
        ...parentLsReturnType
      } = useListNavigation({
        managedChildren: mc,
        rovingTabIndex: rti,
        listNavigation: ls,
        linearNavigation: {
          navigationDirection: "block",
          ...ln
        },
        typeaheadNavigation: tn
      });
      const useGridNavigationRow = T$1(_ref2 => {
        let {
          asChildRowOfSection: asChild,
          asParentRowOfCells: asParent
        } = _ref2;
        // Override the focusSelf that rovingTabIndex does.
        // Instead of focusing the entire row, we ask the cell that corresponds
        // to our current column to focus itself.
        const focusSelf = useStableCallback(() => {
          const c2 = getCurrentColumn();
          console.log(`row #${asChild.managedChild.index},${c2} focusSelf`);

          if (asChild.rovingTabIndex.focusSelf) {
            asChild.rovingTabIndex.focusSelf();
          } else {
            navigateToIndex(c2 !== null && c2 !== void 0 ? c2 : 0, true);
          }
        });
        const rowLsChildReturnType = useListNavigationChildAsGridRow({
          managedChild: asChild.managedChild,
          listNavigation: { ...asChild.listNavigation
          },
          rovingTabIndex: { ...asChild.rovingTabIndex,
            focusSelf
          },
          subInfo: asChild.subInfo
        });
        const {
          rovingTabIndex: {
            tabbable
          },
          useListNavigationChildProps
        } = rowLsChildReturnType;
        h(() => {
          if (!tabbable) {
            navigateToIndex(null, false);
          }
        }, [tabbable]);
        const rowLsReturnType = useListNavigation({
          managedChildren: { ...asParent.managedChildren
          },
          rovingTabIndex: { ...asParent.rovingTabIndex
          },
          linearNavigation: { ...asParent.linearNavigation,
            navigationDirection: "inline"
          },
          typeaheadNavigation: { ...asParent.typeaheadNavigation,
            noTypeahead: true
          },
          listNavigation: { ...asParent.listNavigation
          }
        });
        const {
          rovingTabIndex: {
            setTabbableIndex
          },
          useListNavigationChild: useGridNavigationColumn2,
          useListNavigationProps: useGridNavigationColumnProps,
          listNavigation: {
            navigateToIndex
          }
        } = rowLsReturnType; //const rowHidden = !!asChild.rovingTabIndex.hidden;

        const useGridNavigationCell = T$1(_ref3 => {
          let {
            subInfo,
            managedChild,
            listNavigation: ls,
            rovingTabIndex: {
              blurSelf: bs,
              focusSelf: fs,
              ...rti
            }
          } = _ref3;
          //rti.hidden || rowHidden;
          const focusSelf = useStableCallback(() => {
            var _rti_cell_ret$getElem, _rti_cell_ret$getElem2;

            console.log(`cell #${managedChild.index} focusSelf`);
            setCurrentColumn(managedChild.index);
            setTabbableIndex(managedChild.index, false);
            if (fs) fs();else (_rti_cell_ret$getElem = rti_cell_ret.getElement()) === null || _rti_cell_ret$getElem === void 0 ? void 0 : (_rti_cell_ret$getElem2 = _rti_cell_ret$getElem.focus) === null || _rti_cell_ret$getElem2 === void 0 ? void 0 : _rti_cell_ret$getElem2.call(_rti_cell_ret$getElem);
          });
          const blurSelf = useStableCallback(() => {
            var _rti_cell_ret$getElem3, _rti_cell_ret$getElem4;

            if (bs) bs();else (_rti_cell_ret$getElem3 = rti_cell_ret.getElement()) === null || _rti_cell_ret$getElem3 === void 0 ? void 0 : (_rti_cell_ret$getElem4 = _rti_cell_ret$getElem3.blur) === null || _rti_cell_ret$getElem4 === void 0 ? void 0 : _rti_cell_ret$getElem4.call(_rti_cell_ret$getElem3);
          });
          const {
            useListNavigationChildProps,
            rovingTabIndex: rti_cell_ret
          } = useGridNavigationColumn2({
            managedChild: managedChild,
            listNavigation: { ...ls
            },
            rovingTabIndex: {
              blurSelf,
              focusSelf,
              ...rti
            },
            subInfo
          });
          const {
            useHasFocusProps
          } = useHasFocus({
            onLastFocusedInnerChanged: useStableCallback(focused => {
              if (focused) {
                setCurrentColumn(managedChild.index);
                setTabbableIndex(managedChild.index, false);
              }
            })
          });
          const ret = {
            gridNavigation: {
              getCurrentColumn
            },
            rovingTabIndex: rti_cell_ret,
            useGridNavigationCellProps: function (props) {
              return useListNavigationChildProps(useGridNavigationColumnProps(useHasFocusProps(props)));
            }
          };
          return ret;
        }, []);
        const ret = {
          asParentOfCells: {
            linearNavigation: rowLsReturnType.linearNavigation,
            listNavigation: rowLsReturnType.listNavigation,
            managedChildren: rowLsReturnType.managedChildren,
            rovingTabIndex: rowLsReturnType.rovingTabIndex,
            typeaheadNavigation: rowLsReturnType.typeaheadNavigation
          },
          asChildRow: rowLsChildReturnType,
          useGridNavigationCell,
          useGridNavigationRowProps: function (props) {
            const ret = useListNavigationChildProps(props);
            ret.tabIndex = -1;
            return ret;
          }
        };
        return ret;
      }, []);
      return {
        gridNavigation: {
          getCurrentColumn,
          currentColumn
        },
        linearNavigation: parentLsReturnType.linearNavigation,
        listNavigation: parentLsReturnType.listNavigation,
        rovingTabIndex: parentLsReturnType.rovingTabIndex,
        typeaheadNavigation: parentLsReturnType.typeaheadNavigation,
        managedChildren: parentLsReturnType.managedChildren,
        useGridNavigationRow,
        useGridNavigationProps: useListNavigationPropsAsGridParent
      };
    }

    /**
     * Returns a hook that modifies a set of props to provide a randomly-generated ID if one was not provided.
     *
     * If you'd like to use the ID in a property that's *not* named `id` (like `for` or `aria-labelledby` or whatnot), `useReferencedIdProps` is also provided.
     *
     * And the randomly-generated id itself is also provided in case you want to handle the logic yourself without `useMergedProps`.
     *
     * Unlike most other `use*Props` hooks, these are mostly stable.
     */

    function useRandomId(_ref) {
      let {
        randomId: {
          prefix
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref;
      const [backupRandomId,, getBackupRandomId] = useState(() => generateRandomId(prefix));
      const [usedId, setUsedId, getUsedId] = useState(() => getBackupRandomId());
      const mismatchErrorRef = _(false);
      useEnsureStability("useRandomId", prefix);
      const {
        useManagedChild,
        ...managedChildrenReturnType
      } = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      const {
        managedChildren: {
          children
        }
      } = managedChildrenReturnType;
      const useRandomIdSourceElement = T$1(() => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId());
        const {
          useRefElementProps,
          getElement
        } = useRefElement(); // Every time the source element renders, inspect the ID it actually used
        // (whether it was ours or not isn't up to us, it's up to the component)
        // so this is how we notify the referencer component of changes

        h(() => {
          const element = getElement();

          if (element) {
            children.getAt("referencer").subInfo.setUsedId(element.id);
            setUsedId(element.id);
          }
        });

        useManagedChild({
          managedChild: {
            index: "source",
            subInfo: {
              setUsedId: setUsedIdLocal
            }
          }
        });

        const useRandomIdSourceElementProps = T$1(function (p) {
          p.id || (p.id = backupRandomId);
          return useRefElementProps(p);
        }, []);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdSourceElementProps
        };
      }, []);
      const useRandomIdReferencerElement = T$1(idPropName => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId()); // Whatever ID was most recently used by the actual "id" prop of the source element

        useEnsureStability(idPropName);

        useManagedChild({
          managedChild: {
            index: "referencer",
            subInfo: {
              setUsedId: setUsedIdLocal
            }
          }
        });

        const useRandomIdReferencerElementProps = T$1(function (_ref2) {
          let {
            [idPropName]: givenId,
            ...p
          } = _ref2;

          if (givenId && usedId) {
            if (givenId != usedId) {
              if (!mismatchErrorRef.current) {
                mismatchErrorRef.current = true;
                console.error(`Multiple mis-matched IDs were provided for the ${idPropName} prop: the child explicitly specified ${givenId} in its  ${idPropName} prop, but the parent told this child to use ${usedId} (the parent's ID).`);
              }
            }
          }

          return useMergedProps(p, {
            [idPropName]: usedId
          });
        }, [usedId]);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdReferencerElementProps
        };
      }, []);
      return {
        randomId: {
          usedId,
          getUsedId
        },
        ...managedChildrenReturnType,
        useRandomIdSourceElement,
        useRandomIdReferencerElement
      };
    }

    let pulse = "vibrate" in navigator ? () => navigator.vibrate(10) : () => {};

    function excludes(target, exclude) {
      if (exclude !== null && exclude !== void 0 && exclude[target]) return true;
      return false;
    }
    /**
     * selection.containsNode doesn't account for selection.isCollapsed,
     * so here's a workaround for that.
     *
     * We also only look for the selection end to only catch the
     * essense of a non-existant "selectionstop" event.
     *
     * @param element
     * @returns
     */


    function nodeSelectedTextLength(element) {
      if (element && element instanceof Node) {
        const selection = window.getSelection();

        for (let i = 0; i < ((_selection$rangeCount = selection === null || selection === void 0 ? void 0 : selection.rangeCount) !== null && _selection$rangeCount !== void 0 ? _selection$rangeCount : 0); ++i) {
          var _selection$rangeCount;

          const range = selection.getRangeAt(i);

          if (element.contains(range.endContainer) && !(selection !== null && selection !== void 0 && selection.isCollapsed)) {
            return selection.toString().length;
          }
        }
      }

      return 0;
    }
    /**
     * Adds the necessary event handlers to create a "press"-like event for
     * buttons and anything else that's "click/tap/press/touch"-able.
     *
     * Notably, the following cases are covered:
     * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
     * * Double-clicks won't select text.
     * * Conversely, manually selecting text won't invoke a press.
     * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
     * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClickSync
     * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
     */


    function usePressEventHandlers(onClickSync, exclude) {
      const {
        useRefElementProps,
        getElement
      } = useRefElement({}); // A button can be activated in multiple ways, so on the off chance
      // that multiple are triggered at once, we only *actually* register
      // a press once all of our "on" signals have turned back to "off".
      // We approximate this by just incrementing when active, and
      // decrementing when deactivated.
      //
      // As an emergency failsafe, when the element loses focus,
      // this is reset back to 0.

      const [active, setActive, getActive] = useState(0); // If we the current text selection changes to include this element
      // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
      // because its only purpose was selecting text, not clicking buttons.
      //
      // To catch this, any time the text selection includes us while in the middle
      // of a click, this flag is set, which cancels the activation of a press.
      // The flag is reset any time the selection is empty or the button is
      // no longer active.

      const [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
      useGlobalHandler(document, "selectionchange", _ => {
        setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
      });
      useEffect(() => {
        if (active == 0) setTextSelectedDuringActivationStartTime(null);
      }, [active == 0]);
      const onActiveStart = useStableCallback(_ => {
        setActive(a => ++a);
      });
      const onActiveStop = useStableCallback(e => {
        setActive(a => Math.max(0, --a));
        const currentTime = new Date();
        const timeDifference = textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime;
        const charactersSelected = nodeSelectedTextLength(getElement()); // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
        // then this isn't a press event.
        // TODO: This should measure glyphs instead of characters.

        if (charactersSelected > 1 || (timeDifference !== null && timeDifference !== void 0 ? timeDifference : 0) > 250 && charactersSelected >= 1) {
          e.preventDefault();
          return;
        }

        if (getActive() <= 0) {
          handlePress(e);
        }
      });
      const handlePress = useStableCallback(e => {
        if (onClickSync) {
          // Note: The element is focused here because of iOS Safari.
          //
          // It's always iOS Safari.
          //
          // iOS Safari (tested on 12) downright refuses to allow 
          // elements to be manually focused UNLESS it happens within
          // an event handler like this.  It also doesn't focus
          // buttons by default when clicked, tapped, etc.
          //
          // If it becomes problematic that button-likes explicitly become
          // focused when they are pressed, then an alternative solution for
          // the question of "how do menu buttons keep their menus open"
          // and other focus-related nonsense needs to be figured out.
          //
          // For iOS Safari.
          //
          const element = getElement();
          if (element && "focus" in element) element === null || element === void 0 ? void 0 : element.focus(); // Whatever the browser was going to do with this event,
          // forget it. We're turning it into a "press" event.

          e.preventDefault(); // Also stop anyone else from listening to this event,
          // since we're explicitly handling it.
          // (Notably, this allows labels to wrap inputs, with them
          // both having press event handlers, without double-firing)

          e.stopPropagation(); // Haptic feedback for this press event

          pulse(); // Actually call our handler.

          onClickSync(e);
        }
      });
      const onMouseDown = excludes("click", exclude) ? undefined : e => {
        // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
        // but also don't prevent the user from selecting that text manually if they really want to
        // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
        if (e.detail > 1) e.preventDefault();
        if (e.button === 0) onActiveStart(e);
      };
      const onMouseUp = excludes("click", exclude) ? undefined : e => {
        if (e.button === 0 && active > 0) onActiveStop(e);
      };

      const onBlur = _ => {
        setActive(0);
      };

      const onMouseLeave = excludes("click", exclude) ? undefined : onBlur;
      const onKeyDown = excludes("space", exclude) && excludes("enter", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync && !excludes("space", exclude)) {
          // We don't actually activate it on a space keydown
          // but we do preventDefault to stop the page from scrolling.
          onActiveStart(e);
          e.preventDefault();
        }

        if (e.key == "Enter" && !excludes("enter", exclude)) {
          e.preventDefault();
          onActiveStart(e);
          onActiveStop(e);
        }
      };
      const onKeyUp = excludes("space", exclude) ? undefined : e => {
        if (e.key == " " && !excludes("space", exclude)) onActiveStop(e);
      };

      const onClick = e => {
        e.preventDefault();

        if (e.detail > 1) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
      };

      return useRefElementProps({
        onKeyDown,
        onKeyUp,
        onBlur,
        onMouseDown,
        onMouseUp,
        onMouseLeave,
        onClick,
        style: textSelectedDuringActivationStartTime != null ? {
          cursor: "text"
        } : undefined,
        ...{
          "data-pseudo-active": active && textSelectedDuringActivationStartTime == null ? "true" : undefined
        }
      });
    }
    function useAriaButton(_ref) {
      let {
        tag,
        pressed,
        onPress,
        disabled
      } = _ref;

      function useAriaButtonProps(_ref2) {
        let {
          "aria-pressed": ariaPressed,
          tabIndex,
          role,
          ...p
        } = _ref2;
        const props = useMergedProps(usePressEventHandlers(e => {
          var _ref3;

          return (_ref3 = disabled ? null : onPress) === null || _ref3 === void 0 ? void 0 : _ref3(enhanceEvent(e, {
            pressed: pressed == null ? null : !pressed
          }));
        }, undefined), p);
        const baseProps = {
          role,
          tabIndex,
          "aria-pressed": ariaPressed !== null && ariaPressed !== void 0 ? ariaPressed : pressed === true ? "true" : pressed === false ? "false" : undefined
        };
        const buttonProps = { ...baseProps,
          disabled: disabled && disabled != "soft" ? true : false,
          "aria-disabled": disabled === 'soft' ? 'true' : undefined
        };
        const divProps = { ...baseProps,
          tabIndex: tabIndex !== null && tabIndex !== void 0 ? tabIndex : 0,
          role: role !== null && role !== void 0 ? role : "button",
          "aria-disabled": disabled ? "true" : undefined
        };
        const anchorProps = { ...divProps
        };

        switch (tag) {
          case "button":
            return useMergedProps(buttonProps, props);

          case "a":
            return useMergedProps(anchorProps, props);

          default:
            return useMergedProps(divProps, props);
        }
      }

      return {
        useAriaButtonProps
      };
    }

    //export interface UseAriaAccordionSectionHeaderReturnType<E extends Element> { useAriaAccordionSectionHeaderProps: (props: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; }
    //export type UseAriaAccordionSectionBody<E extends Element> = () => UseAriaAccordionSectionBodyReturnType<E>;
    //export interface UseAriaAccordionSectionBodyReturnType<E extends Element> { useAriaAccordionSectionBodyProps: (props: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; }

    function useAriaAccordion(_ref) {
      let {
        accordion: {
          initialIndex
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref;
      const [_currentFocusedIndex, setCurrentFocusedIndex, getCurrentFocusedIndex] = useState(null);
      const mcReturnType = useManagedChildren({
        managedChildren: {
          onChildrenMountChange: useStableCallback((m, u) => {
            ocmc2();
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(m, u);
          }),
          onAfterChildLayoutEffect
        }
      });
      const {
        useManagedChild,
        managedChildren: {
          children
        }
      } = mcReturnType;
      const navigateToFirst = T$1(() => {
        changeTabbedIndex(0);
      }, []);
      const navigateToLast = T$1(() => {
        changeTabbedIndex(children.getHighestIndex());
      }, []);
      const navigateToPrev = T$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) - 1);
      }, []);
      const navigateToNext = T$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) + 1);
      }, []);
      const linearReturnType = useLinearNavigation({
        linearNavigation: {
          navigateToFirst,
          navigateToLast,
          navigateToNext,
          navigateToPrev,
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection: navigationDirection !== null && navigationDirection !== void 0 ? navigationDirection : "block"
        }
      });
      const {
        useLinearNavigationProps
      } = linearReturnType;
      const {
        changeIndex: changeExpandedIndex,
        getCurrentIndex: _getCurrentExpandedIndex
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "open",
        closestFit: false
      });
      const {
        changeIndex: changeTabbedIndex,
        getCurrentIndex: _getTabbedIndex,
        reevaluateClosestFit: ocmc2
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "tabbed",
        closestFit: true,
        onIndexChange: T$1(i => {
          if (i != null) {
            var _children$getAt;

            (_children$getAt = children.getAt(i)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.focus();
          }
        }, [])
      });
      const useAriaAccordionSection = T$1(_ref2 => {
        var _ref3;

        let {
          button: {
            tag,
            disabled
          },
          accordionSection: {
            open: openFromUser
          },
          managedChildren: {
            index
          }
        } = _ref2;
        const [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
        const {
          useRandomIdSourceElement: useBodyAsSourceId,
          useRandomIdReferencerElement: useHeaderAsReferencerId,
          randomId: {
            usedId: bodyId,
            getUsedId: getBodyId
          }
        } = useRandomId({
          randomId: {
            prefix: "aria-accordion-section-body-"
          },
          managedChildren: {
            onAfterChildLayoutEffect: null,
            onChildrenMountChange: null
          }
        });
        const {
          useRandomIdSourceElement: useHeaderAsSourceId,
          useRandomIdReferencerElement: useBodyAsReferencerId,
          randomId: {
            usedId: headerId,
            getUsedId: getHeaderId
          }
        } = useRandomId({
          randomId: {
            prefix: "aria-accordion-section-header-"
          },
          managedChildren: {
            onAfterChildLayoutEffect: null,
            onChildrenMountChange: null
          }
        });
        const {
          useRandomIdSourceElementProps: useBodyAsSourceIdProps
        } = useBodyAsSourceId();
        const {
          useRandomIdReferencerElementProps: useBodyAsReferencerIdProps
        } = useBodyAsReferencerId("aria-labelledby");
        const {
          useRandomIdSourceElementProps: useHeaderAsSourceIdProps
        } = useHeaderAsSourceId();
        const {
          useRandomIdReferencerElementProps: useHeaderAsReferencerIdProps
        } = useHeaderAsReferencerId("aria-controls");
        const open = (_ref3 = openFromUser !== null && openFromUser !== void 0 ? openFromUser : openFromParent) !== null && _ref3 !== void 0 ? _ref3 : false; //const getOpen = useStableGetter(!!open);

        const getIndex = useStableGetter(index);
        const {
          getElement: getHeaderElement,
          useRefElementProps: useHeaderRefElementProps
        } = useRefElement({});
        const {
          getElement: getBodyElement,
          useRefElementProps: useBodyRefElementProps
        } = useRefElement({});
        const focus = T$1(() => {
          var _getHeaderElement;

          if (getCurrentFocusedIndex() != null) (_getHeaderElement = getHeaderElement()) === null || _getHeaderElement === void 0 ? void 0 : _getHeaderElement.focus();
        }, []);
        const openRef = _({
          get: () => !!getOpenFromParent(),
          set: open => {
            setOpenFromParent(open);

            if (open) {
              const bodyElement = getBodyElement();
              setCurrentFocusedIndex(getIndex());

              if (bodyElement) {
                queueMicrotask(() => bodyElement.focus());
              }
            }
          },
          isValid: returnTrue
        });
        const tabbedRef = _({
          get: () => getCurrentFocusedIndex() == getIndex(),
          set: open => {
            if (open) setCurrentFocusedIndex(getIndex());
          },
          isValid: returnTrue
        });

        useManagedChild({
          managedChild: {
            index: index,
            flags: {
              open: openRef.current,
              tabbed: tabbedRef.current
            },
            subInfo: {
              focus,
              getOpenFromParent,
              setOpenFromParent
            } // info: { index, setOpenFromParent, getOpenFromParent, focus, flags: { open: openRef.current, tabbed: tabbedRef.current } }

          }
        });

        function useAriaAccordionSectionHeaderProps(_ref4) {
          var _ref5;

          let {
            ["aria-expanded"]: ariaExpanded,
            ["aria-disabled"]: ariaDisabled,
            ...props
          } = _ref4;

          //const onFocus = () => { changeTabbedIndex(index); }
          const onPress = () => {
            if (getOpenFromParent()) changeExpandedIndex(null);else changeExpandedIndex(index);
          };

          props.tabIndex = 0;
          const {
            useAriaButtonProps
          } = useAriaButton({
            tag,
            disabled,
            onPress
          });
          const retB = useAriaButtonProps(props); //const retB = useMergedProps<HeaderElement>(usePressEventHandlers<HeaderElement>(onClick, undefined), props);

          const {
            useHasFocusProps
          } = useHasFocus({
            onFocusedInnerChanged: useStableCallback(focused => {
              if (focused) changeTabbedIndex(index);
            })
          }); //const ret3: h.JSX.HTMLAttributes<HeaderElement>
          //    = useMergedProps<HeaderElement>(retD, { onFocus });

          return useHasFocusProps(useLinearNavigationProps(useHeaderAsSourceIdProps(useHeaderAsReferencerIdProps({
            "aria-expanded": ((_ref5 = ariaExpanded !== null && ariaExpanded !== void 0 ? ariaExpanded : open) !== null && _ref5 !== void 0 ? _ref5 : false).toString(),
            "aria-disabled": ariaDisabled !== null && ariaDisabled !== void 0 ? ariaDisabled : open ? "true" : undefined,
            ...useHeaderRefElementProps(retB)
          }))));
        }

        function useAriaAccordionSectionBodyProps(_ref6) {
          var _ret2$tabIndex;

          let {
            role,
            ...props
          } = _ref6;
          const ret1 = useBodyAsReferencerIdProps({
            role: role !== null && role !== void 0 ? role : "region",
            ...props
          });
          const ret2 = useBodyAsSourceIdProps(ret1);
          (_ret2$tabIndex = ret2.tabIndex) !== null && _ret2$tabIndex !== void 0 ? _ret2$tabIndex : ret2.tabIndex = -1;
          return useBodyRefElementProps(ret2);
        }

        return {
          accordionSection: {
            expanded: open,
            focused: getCurrentFocusedIndex() == index,
            bodyId,
            headerId,
            getBodyId,
            getHeaderId
          },
          useAriaAccordionSectionHeaderProps,
          useAriaAccordionSectionBodyProps
        };
      }, []);
      return {
        managedChildren: mcReturnType.managedChildren,
        accordion: {
          changeExpandedIndex
        },
        useAriaAccordionSection
      };
    }

    /**
     * Adds an ID and "aria-labelledby" for two elements, an "input" element and a "label" element.
     *
     * Returns the `useReferencedIdProps` hooks if you need to also add other ID-referencer attributes, like `for`
     *
     * @see useInputLabel
     */

    function useLabel(_ref) {
      let {
        label: {
          prefixInput,
          prefixLabel,
          tagInput,
          tagLabel
        }
      } = _ref;
      const {
        useRandomIdSourceElement: useLabelAsSourceId,
        useRandomIdReferencerElement: useLabelAsReferencerId,
        randomId: {
          usedId: labelId,
          getUsedId: getLabelId
        }
      } = useRandomId({
        randomId: {
          prefix: prefixLabel
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useInputAsSourceId,
        useRandomIdReferencerElement: useInputAsReferencerId,
        randomId: {
          usedId: inputId,
          getUsedId: getInputId
        }
      } = useRandomId({
        randomId: {
          prefix: prefixInput
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElementProps: useLabelAsSourceIdProps
      } = useLabelAsSourceId();
      const {
        useRandomIdSourceElementProps: useInputAsSourceIdProps
      } = useInputAsSourceId();
      const {
        useRandomIdReferencerElementProps: useLabelAsReferencerIdProps
      } = useLabelAsReferencerId("aria-labelledby");
      const {
        useRandomIdReferencerElementProps: useInputAsReferencerIdProps
      } = useInputAsReferencerId("for");
      const isSyntheticLabel = tagInput != "input" || tagLabel != "label";
      const useLabelLabel = T$1(function useLabelLabel() {
        return {
          useLabelLabelProps: props => {
            const propsWithoutFor = useLabelAsSourceIdProps(props);
            const propsWithFor = useInputAsReferencerIdProps(propsWithoutFor);
            if (tagLabel == "label" && tagInput == "input") return propsWithFor;else return propsWithoutFor;
          }
        };
      }, [isSyntheticLabel]);
      const useLabelInput = T$1(function useLabelInput() {
        return {
          useLabelInputProps: _ref2 => {
            let {
              "aria-labelledby": ariaLabelledby,
              ...props
            } = _ref2;
            console.assert(!ariaLabelledby);
            const propsWithoutAriaLabelledBy = useInputAsSourceIdProps(props);
            const propsWithAriaLabelledBy = useLabelAsReferencerIdProps(propsWithoutAriaLabelledBy);
            if (isSyntheticLabel && !props["aria-label"]) return propsWithAriaLabelledBy;else return propsWithoutAriaLabelledBy;
          }
        };
      }, [isSyntheticLabel]);
      return {
        useLabelInput,
        useLabelLabel,
        label: {
          labelId,
          inputId,
          getLabelId,
          getInputId
        }
      };
    }

    function useAriaListboxSingle(_ref) {
      let {
        listboxSingle: {
          selectionMode,
          tagLabel,
          tagList,
          onSelect,
          ..._lbs
        },
        singleSelection: {
          selectedIndex,
          ...ss
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          ...rti
        },
        typeaheadNavigation: { ...tn
        }
      } = _ref;
      const {
        useLabelInput,
        useLabelLabel,
        ...labelReturnType
      } = useLabel({
        label: {
          prefixLabel: "aria-listbox-label-",
          prefixInput: "aria-listbox-",
          tagInput: tagList,
          tagLabel: tagLabel
        }
      });
      const {
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps,
        ...listReturnType
      } = useListNavigationSingleSelection({
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti,
          onTabbableIndexChange: useStableCallback(i => {
            onTabbableIndexChange === null || onTabbableIndexChange === void 0 ? void 0 : onTabbableIndexChange(i);

            if (selectionMode == "focus") {
              var _children$getAt;

              const target = (_children$getAt = children.getAt(i)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.getElement();
              if (target) onSelect === null || onSelect === void 0 ? void 0 : onSelect({
                target,
                currentTarget: target,
                [EventDetail]: {
                  selectedIndex: i
                }
              });
            }
          })
        },
        singleSelection: { ...ss,
          selectedIndex
        },
        typeaheadNavigation: tn
      });
      const {
        managedChildren: {
          children
        }
      } = listReturnType;
      const {
        useLabelInputProps
      } = useLabelInput();
      const stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
      const useListboxSingleItem = T$1(_ref2 => {
        let {
          listboxSingleItem: {
            disabled
          },
          listNavigation,
          managedChild,
          rovingTabIndex
        } = _ref2;
        const {
          rovingTabIndex: rti_ret,
          singleSelection: ss_ret,
          useListNavigationSingleSelectionChildProps
        } = useListNavigationSingleSelectionChild({
          managedChild,
          listNavigation,
          rovingTabIndex,
          subInfo: {}
        });
        const index = managedChild.index;
        h(() => {
          const element = rti_ret.getElement();

          if (element && rti_ret.tabbable && selectionMode == "focus") {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
          }
        }, [rti_ret.tabbable, selectionMode, index]);
        return {
          useListboxSingleItemProps,
          rovingTabIndex: rti_ret,
          singleSelection: ss_ret
        };

        function useListboxSingleItemProps(props) {
          var _ss_ret$selected;

          const newProps = usePressEventHandlers(disabled ? null : e => {
            const element = rti_ret.getElement();
            if (element) stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
            e.preventDefault();
          }, undefined);
          props.role = "option"; //props["aria-setsize"] = (children.getHighestIndex() + 1).toString();
          //props["aria-posinset"] = (info.index + 1).toString();

          props["aria-selected"] = ((_ss_ret$selected = ss_ret.selected) !== null && _ss_ret$selected !== void 0 ? _ss_ret$selected : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useListNavigationSingleSelectionChildProps(useMergedProps(newProps, props));
        }
      }, [useListNavigationSingleSelectionChild, selectionMode]);
      const useListboxSingleLabel = T$1(function useListboxSingleLabel() {
        function useListboxSingleLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxSingleLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxSingleItem,
        useListboxSingleProps,
        useListboxSingleLabel,
        ...listReturnType,
        ...labelReturnType
        /*label: labelReturnType.label,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        managedChildren: listReturnType.managedChildren,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation*/

      };

      function useListboxSingleProps(props) {
        props.role = "listbox";
        return useListNavigationSingleSelectionProps(useLabelInputProps(props));
      }
    }

    /*export interface UseListboxMultiReturnType<LabelElement extends Element, ListElement extends Element, ListItemElement extends Element> extends Omit<UseListNavigationReturnType<ListElement, ListItemElement, {}, never>, "useListNavigationChild" | "useListNavigationProps"> {
        useListboxMultiItem: UseListboxMultiItem<ListItemElement>;
        useListboxMultiProps: (props: h.JSX.HTMLAttributes<ListElement>) => h.JSX.HTMLAttributes<ListElement>;
        useListboxMultiLabel: () => { useListboxMultiLabelProps: (props: h.JSX.HTMLAttributes<LabelElement>) => h.JSX.HTMLAttributes<LabelElement>; }
    }*/

    function useAriaListboxMulti(_ref) {
      let {
        listboxMulti: {
          tagLabel,
          tagList
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          ...rti
        },
        typeaheadNavigation: { ...tn
        }
      } = _ref;
      //const { useHasFocusProps, getFocusedInner } = useHasFocus<ListElement>({});
      const {
        useLabelInput,
        useLabelLabel
      } = useLabel({
        label: {
          prefixLabel: "aria-listbox-label-",
          prefixInput: "aria-listbox-",
          tagLabel: tagLabel,
          tagInput: tagList
        }
      });
      const listReturnType = useListNavigation({
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti,
          onTabbableIndexChange: useStableCallback(i => {
            onTabbableIndexChange === null || onTabbableIndexChange === void 0 ? void 0 : onTabbableIndexChange(i);
            /*if (selectionMode == "focus") {
                const target = (children.getAt(i!)?.subInfo.getElement());
                if (target)
                    onSelect?.({ target, currentTarget: target, [EventDetail]: { selectedIndex: i! } });
            }*/
          })
        },
        typeaheadNavigation: tn
      });
      const {
        useListNavigationChild,
        useListNavigationProps,
        rovingTabIndex: {
          setTabbableIndex
        }
      } = listReturnType;
      const {
        useLabelInputProps
      } = useLabelInput();
      const [getShiftHeld, setShiftHeld] = usePassiveState(null, returnFalse$1);
      const useListboxMultiItem = T$1(_ref2 => {
        let {
          listboxMultiItem: {
            selected,
            disabled,
            onSelect
          },
          managedChild,
          listNavigation: ls,
          rovingTabIndex: rti
        } = _ref2;
        const getSelected = useStableGetter(selected);
        const {
          useRefElementProps,
          getElement
        } = useRefElement({});
        const stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
        const {
          useListNavigationChildProps,
          rovingTabIndex: rti2_ret
        } = useListNavigationChild({
          listNavigation: ls,
          managedChild,
          rovingTabIndex: rti,
          subInfo: {
            selected,
            onSelect
          }
        });
        useLayoutEffect(() => {
          const element = getElement();

          if (element && getShiftHeld()) {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selected: true
              }
            });
          }
        }, [rti2_ret.tabbable]);
        return {
          useListboxMultiItemProps,
          listboxMultiItem: {
            getSelected,
            tabbable: rti2_ret.tabbable
          },
          rovingTabIndex: rti2_ret
        };

        function useListboxMultiItemProps(props) {
          var _rti2_ret$tabbable;

          const newProps = usePressEventHandlers(disabled ? null : e => {
            console.log(`Multi ${managedChild.index} is ${getSelected().toString()} and changing to ${(!getSelected()).toString()}`);
            setTabbableIndex(managedChild.index, false);
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({ ...e,
              [EventDetail]: {
                selected: !getSelected()
              }
            });
            e.preventDefault();
          }, {});
          props.role = "option"; //props["aria-setsize"] = (childCount).toString();
          //props["aria-posinset"] = (info.index + 1).toString();

          props["aria-selected"] = ((_rti2_ret$tabbable = rti2_ret.tabbable) !== null && _rti2_ret$tabbable !== void 0 ? _rti2_ret$tabbable : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useRefElementProps(useListNavigationChildProps(useMergedProps(newProps, props)));
        }
      }, [useListNavigationChild]);
      const useListboxMultiLabel = T$1(function useListboxMultiLabel() {
        function useListboxMultiLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxMultiLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxMultiItem,
        useListboxMultiProps,
        useListboxMultiLabel,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation,
        managedChildren: listReturnType.managedChildren
      };

      function useListboxMultiProps(props) {
        props.role = "listbox";
        props["aria-multiselectable"] = "true";
        return useListNavigationProps(useLabelInputProps(useMergedProps({
          onKeyDown,
          onKeyUp,
          onfocusout: onFocusOut
        }, props)));
      }

      function onKeyDown(e) {
        if (e.key == "Shift") setShiftHeld(true);
      }

      function onKeyUp(e) {
        if (e.key == "Shift") setShiftHeld(false);
      }

      function onFocusOut(_) {
        setShiftHeld(false);
      }
    }

    function returnFalse() {
      return false;
    }

    function useAriaTooltip(_ref) {
      var _mouseoverDelay, _mouseoutDelay, _focusDelay;

      let {
        mouseoverDelay,
        mouseoutDelay,
        focusDelay
      } = _ref;
      (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
      (_mouseoutDelay = mouseoutDelay) !== null && _mouseoutDelay !== void 0 ? _mouseoutDelay : mouseoutDelay = 40;
      (_focusDelay = focusDelay) !== null && _focusDelay !== void 0 ? _focusDelay : focusDelay = 1; // The escape key should close tooltips, but do nothing else.
      // (i.e. closing a tooltip in a dialog MUST NOT close the dialog too)
      // TODO: Tooltips are, effectively, always the topmost component,
      // so we can just have them listen to and swallow all "Escape"
      // key presses before anyone else. For a more general popup,
      // or a tooltip in a tooltip (!!) a different solution would be needed.

      useGlobalHandler(document, "keydown", e => {
        if (getOpen() && e.key === "Escape" && !e.defaultPrevented) {
          e.preventDefault();
          e.stopImmediatePropagation();
          setOpen(false);
          setTriggerHoverDelayCorrected(false);
          setTooltipHoverDelayCorrected(false);
          setTriggerFocusedDelayCorrected(false);
          setTooltipFocusedDelayCorrected(false);
        }
      }, {
        capture: true
      });
      const [open, setOpen, getOpen] = useState(false);
      const {
        useRandomIdSourceElement,
        //: useTooltipIdProps, 
        useRandomIdReferencerElement //: useTooltipIdReferencingProps 

      } = useRandomId({
        randomId: {
          prefix: "aria-tooltip-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const [, setTriggerFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTriggerFocusedDelayCorrected(focused), focused ? focusDelay : 1);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTooltipFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTooltipFocusedDelayCorrected(focused), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTriggerHover] = usePassiveState(useStableCallback(hovering => {
        const delay = hovering ? mouseoverDelay : mouseoutDelay;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTriggerHoverDelayCorrected(hovering), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTooltipHover] = usePassiveState(useStableCallback(hovering => {
        const delay = hovering ? mouseoverDelay : mouseoutDelay;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTooltipHoverDelayCorrected(hovering), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [triggerFocusedDelayCorrected, setTriggerFocusedDelayCorrected] = useState(false);
      const [triggerHoverDelayCorrected, setTriggerHoverDelayCorrected] = useState(false);
      const [tooltipFocusedDelayCorrected, setTooltipFocusedDelayCorrected] = useState(false);
      const [tooltipHoverDelayCorrected, setTooltipHoverDelayCorrected] = useState(false);
      h(() => {
        setOpen(triggerFocusedDelayCorrected || triggerHoverDelayCorrected || tooltipFocusedDelayCorrected || tooltipHoverDelayCorrected);
      }, [triggerFocusedDelayCorrected || triggerHoverDelayCorrected || tooltipFocusedDelayCorrected || tooltipHoverDelayCorrected]);
      const useTooltipTrigger = T$1(function useTooltipTrigger() {
        useGlobalHandler(document, "pointermove", e => {
          var _getElement;

          const target = e.target;
          setTriggerHover(target == getElement() || !!((_getElement = getElement()) !== null && _getElement !== void 0 && _getElement.contains(target)));
        }, {
          capture: true
        });

        function onTouchEnd(e) {
          e.target.focus();
        }

        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({
          onFocusedInnerChanged: setTriggerFocused
        });

        function useTooltipTriggerProps(_ref2) {
          var _props$tabIndex;

          let { ...props
          } = _ref2;
          const {
            useRandomIdReferencerElementProps
          } = useRandomIdReferencerElement("aria-describedby"); // Note: Though it's important to make sure that focusing activates a tooltip,
          // it's perfectly reasonable that a child element will be the one that's focused,
          // not this one, so we don't set tabIndex=0

          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1;
          return useRandomIdReferencerElementProps(useHasFocusProps(useMergedProps({
            onTouchEnd
          }, props)));
        }

        return {
          useTooltipTriggerProps
        };
      }, []);
      const useTooltip = T$1(function useTooltip() {
        const {
          useRandomIdSourceElementProps
        } = useRandomIdSourceElement();
        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({
          onFocusedInnerChanged: setTooltipFocused
        });
        useGlobalHandler(document, "pointermove", e => {
          var _getElement2;

          const target = e.target;
          setTooltipHover(target == getElement() || !!((_getElement2 = getElement()) !== null && _getElement2 !== void 0 && _getElement2.contains(target)));
        }, {
          capture: true
        });

        function useTooltipProps(_ref3) {
          let { ...props
          } = _ref3;
          return useRandomIdSourceElementProps(useHasFocusProps(useMergedProps({}, props)));
        }

        return {
          useTooltipProps
        };
      }, []);
      return {
        useTooltip,
        useTooltipTrigger,
        isOpen: open,
        getIsOpen: getOpen
      };
    }

    function useAriaTable(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      const [getCurrentSortColumn, setCurrentSortColumn] = usePassiveState(null, returnNull);
      const bodySort = _(null);
      const {
        useGridNavigationProps,
        useGridNavigationRow,
        ...gridNavRet1
      } = useGridNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children: rows
        }
      } = gridNavRet1;
      const useTableRow = T$1(_ref2 => {
        let {
          asChildRowOfSection,
          asParentRowOfCells,
          tableRow: {
            location
          }
        } = _ref2;
        const getCells = T$1(() => {
          return cells;
        }, []);
        const {
          useGridNavigationCell,
          useGridNavigationRowProps,
          ...gridNavRet2
        } = useGridNavigationRow({
          asChildRowOfSection: { ...asChildRowOfSection,
            subInfo: {
              getCells,
              location
            }
          },
          asParentRowOfCells
        });
        const {
          asParentOfCells: {
            managedChildren: {
              children: cells
            }
          }
        } = gridNavRet2;
        const useTableCell = T$1(_ref3 => {
          let {
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo
          } = _ref3;
          const {
            useGridNavigationCellProps,
            ...gridNavRet3
          } = useGridNavigationCell({
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo
          });
          const sort = useStableCallback(() => {
            var _getCurrentSortColumn;

            const sortInfo = (_getCurrentSortColumn = getCurrentSortColumn()) !== null && _getCurrentSortColumn !== void 0 ? _getCurrentSortColumn : {
              index: -1,
              direction: 'ascending'
            };
            const cellIndex = managedChild.index;

            if (sortInfo.index != cellIndex) {
              if (sortInfo.direction[0] == 'a') sortInfo.direction = 'descending';else sortInfo.direction = 'ascending';
            }

            sortInfo.index = managedChild.index;
            setCurrentSortColumn(sortInfo);
            bodySort.current();
          });

          const useTableCellProps = props => props;

          return {
            tableHeaderCell: {
              sort
            },
            useTableCellProps,
            ...gridNavRet3
          };
        }, []);

        const useTableRowProps = props => props;

        return {
          useTableCell,
          useTableRowProps,
          ...gridNavRet2
        };
      }, []);
      const useTableBody = T$1(() => {
        const getIndex = T$1(i => i.index, []);
        const getValue = T$1(i => {
          var _getCurrentSortColumn2, _getCurrentSortColumn3, _cell$subInfo$subInfo, _cell$subInfo$subInfo2;

          const cells = i.subInfo.subInfo.subInfo.getCells();
          const cell = cells.getAt((_getCurrentSortColumn2 = (_getCurrentSortColumn3 = getCurrentSortColumn()) === null || _getCurrentSortColumn3 === void 0 ? void 0 : _getCurrentSortColumn3.index) !== null && _getCurrentSortColumn2 !== void 0 ? _getCurrentSortColumn2 : 0);
          return {
            location: (_cell$subInfo$subInfo = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.location) !== null && _cell$subInfo$subInfo !== void 0 ? _cell$subInfo$subInfo : "head",
            value: (_cell$subInfo$subInfo2 = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.value) !== null && _cell$subInfo$subInfo2 !== void 0 ? _cell$subInfo$subInfo2 : -1
          }; //return cells.getAt(getCurrentSortColumn()?.index ?? 0)?.subInfo.subInfo.subInfo.value ?? null;
        }, []);

        const compare = (lhs, rhs) => {
          var _lhs$value, _rhs$value;

          if (lhs.location === rhs.location) return +((_lhs$value = lhs.value) !== null && _lhs$value !== void 0 ? _lhs$value : -Infinity) - +((_rhs$value = rhs.value) !== null && _rhs$value !== void 0 ? _rhs$value : -Infinity);
          if (lhs.location == 'head') return -1;
          if (lhs.location == 'body') return rhs.location == 'head' ? -1 : 1;
          return 1;
        };

        const {
          useSortableProps,
          ...sortableRet
        } = useSortableChildren({
          rearrangeableChildren: {
            getIndex
          },
          sortableChildren: {
            compare,
            getValue
          }
        });
        const {
          sortableChildren: {
            sort
          }
        } = sortableRet;
        useLayoutEffect(() => {
          bodySort.current = () => {
            var _getCurrentSortColumn4, _getCurrentSortColumn5;

            sort(rows, (_getCurrentSortColumn4 = (_getCurrentSortColumn5 = getCurrentSortColumn()) === null || _getCurrentSortColumn5 === void 0 ? void 0 : _getCurrentSortColumn5.direction) !== null && _getCurrentSortColumn4 !== void 0 ? _getCurrentSortColumn4 : 'ascending');
          };
        }, [sort]);

        const useTableBodyProps = props => {
          console.assert(props.children != null);
          return useSortableProps(props);
        };

        return {
          useTableBodyProps,
          ...sortableRet
        };
      }, []);
      const useTableProps = useGridNavigationProps;
      return {
        useTableProps,
        useTableBody,
        useTableRow,
        ...gridNavRet1
      };
    }

    function S(n, t) {
      for (var e in t) n[e] = t[e];

      return n;
    }

    function g(n, t) {
      for (var e in n) if ("__source" !== e && !(e in t)) return !0;

      for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;

      return !1;
    }

    function C(n) {
      this.props = n;
    }

    (C.prototype = new d$1()).isPureReactComponent = !0, C.prototype.shouldComponentUpdate = function (n, t) {
      return g(this.props, n) || g(this.state, t);
    };
    var w = l$1.__b;

    l$1.__b = function (n) {
      n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), w && w(n);
    };

    var x = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;

    function R(n) {
      function t(t) {
        var e = S({}, t);
        return delete e.ref, n(e, t.ref || null);
      }

      return t.$$typeof = x, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
    }

    var A = l$1.__e;

    l$1.__e = function (n, t, e, r) {
      if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
      A(n, t, e, r);
    };

    var O = l$1.unmount;

    function T() {
      this.__u = 0, this.t = null, this.__b = null;
    }

    function L(n) {
      var t = n.__.__c;
      return t && t.__a && t.__a(n);
    }

    function D() {
      this.u = null, this.o = null;
    }

    l$1.unmount = function (n) {
      var t = n.__c;
      t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), O && O(n);
    }, (T.prototype = new d$1()).__c = function (n, t) {
      var e = t.__c,
          r = this;
      null == r.t && (r.t = []), r.t.push(e);

      var u = L(r.__v),
          o = !1,
          i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };

      e.__R = i;

      var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;

            r.__v.__k[0] = function n(t, e, r) {
              return t && (t.__v = null, t.__k = t.__k && t.__k.map(function (t) {
                return n(t, e, r);
              }), t.__c && t.__c.__P === e && (t.__e && r.insertBefore(t.__e, t.__d), t.__c.__e = !0, t.__c.__P = r)), t;
            }(n, n.__c.__P, n.__c.__O);
          }

          var t;

          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
          c = !0 === t.__h;

      r.__u++ || c || r.setState({
        __a: r.__b = r.__v.__k[0]
      }), n.then(i, i);
    }, T.prototype.componentWillUnmount = function () {
      this.t = [];
    }, T.prototype.render = function (n, t) {
      if (this.__b) {
        if (this.__v.__k) {
          var e = document.createElement("div"),
              r = this.__v.__k[0].__c;

          this.__v.__k[0] = function n(t, e, r) {
            return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach(function (n) {
              "function" == typeof n.__c && n.__c();
            }), t.__c.__H = null), null != (t = S({}, t)).__c && (t.__c.__P === r && (t.__c.__P = e), t.__c = null), t.__k = t.__k && t.__k.map(function (t) {
              return n(t, e, r);
            })), t;
          }(this.__b, e, r.__O = r.__P);
        }

        this.__b = null;
      }

      var u = t.__a && h$1(p$1, null, n.fallback);
      return u && (u.__h = null), [h$1(p$1, null, t.__a ? null : n.children), u];
    };

    var F = function (n, t, e) {
      if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
        for (; e.length > 3;) e.pop()();

        if (e[1] < e[0]) break;
        n.u = e = e[2];
      }
    };

    (D.prototype = new d$1()).__a = function (n) {
      var t = this,
          e = L(t.__v),
          r = t.o.get(n);
      return r[0]++, function (u) {
        var o = function () {
          t.props.revealOrder ? (r.push(u), F(t, n, r)) : u();
        };

        e ? e(o) : o();
      };
    }, D.prototype.render = function (n) {
      this.u = null, this.o = new Map();
      var t = x$1(n.children);
      n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

      for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);

      return n.children;
    }, D.prototype.componentDidUpdate = D.prototype.componentDidMount = function () {
      var n = this;
      this.o.forEach(function (t, e) {
        F(n, e, t);
      });
    };

    var W = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        P = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        $ = "undefined" != typeof document,
        j = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };

    d$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (n) {
      Object.defineProperty(d$1.prototype, n, {
        configurable: !0,
        get: function () {
          return this["UNSAFE_" + n];
        },
        set: function (t) {
          Object.defineProperty(this, n, {
            configurable: !0,
            writable: !0,
            value: t
          });
        }
      });
    });
    var H = l$1.event;

    function Z() {}

    function Y() {
      return this.cancelBubble;
    }

    function q() {
      return this.defaultPrevented;
    }

    l$1.event = function (n) {
      return H && (n = H(n)), n.persist = Z, n.isPropagationStopped = Y, n.isDefaultPrevented = q, n.nativeEvent = n;
    };

    var J = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
        K = l$1.vnode;

    l$1.vnode = function (n) {
      var t = n.type,
          e = n.props,
          r = e;

      if ("string" == typeof t) {
        var u = -1 === t.indexOf("-");

        for (var o in r = {}, e) {
          var i = e[o];
          $ && "children" === o && "noscript" === t || "value" === o && "defaultValue" in e && null == i || ("defaultValue" === o && "value" in e && null == e.value ? o = "value" : "download" === o && !0 === i ? i = "" : /ondoubleclick/i.test(o) ? o = "ondblclick" : /^onchange(textarea|input)/i.test(o + t) && !j(e.type) ? o = "oninput" : /^onfocus$/i.test(o) ? o = "onfocusin" : /^onblur$/i.test(o) ? o = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(o) ? o = o.toLowerCase() : u && P.test(o) ? o = o.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === i && (i = void 0), /^oninput$/i.test(o) && (o = o.toLowerCase(), r[o] && (o = "oninputCapture")), r[o] = i);
        }

        "select" == t && r.multiple && Array.isArray(r.value) && (r.value = x$1(e.children).forEach(function (n) {
          n.props.selected = -1 != r.value.indexOf(n.props.value);
        })), "select" == t && null != r.defaultValue && (r.value = x$1(e.children).forEach(function (n) {
          n.props.selected = r.multiple ? -1 != r.defaultValue.indexOf(n.props.value) : r.defaultValue == n.props.value;
        })), n.props = r, e.class != e.className && (J.enumerable = "className" in e, null != e.className && (r.class = e.className), Object.defineProperty(r, "className", J));
      }

      n.$$typeof = W, K && K(n);
    };

    var Q = l$1.__r;

    l$1.__r = function (n) {
      Q && Q(n), n.__c;
    };

    /*export interface AriaAccordionSectionPropsDerivedFrom {
        expanded: boolean;
        accordionSections: ManagedChildren<UseAriaAccordionSectionInfoBase>;
    }*/

    const AccordionSectionContext = B(null);

    function AriaAccordionU(_ref) {
      let {
        disableArrowKeys,
        disableHomeEndKeys,
        expandedIndex,
        initialIndex,
        navigationDirection,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        render,
        children
      } = _ref;
      const {
        useAriaAccordionSection,
        ...provider
      } = useAriaAccordion({
        accordion: {
          initialIndex
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      useEffect(() => {
        provider.accordion.changeExpandedIndex(expandedIndex !== null && expandedIndex !== void 0 ? expandedIndex : null);
      }, [expandedIndex]);
      return e$1(AccordionSectionContext.Provider, {
        value: useAriaAccordionSection,
        children: (render !== null && render !== void 0 ? render : defaultRenderAccordion)(provider, children)
      });
    }

    function defaultRenderAccordion(info, children) {
      return e$1(p$1, {
        children: children
      });
    }

    function defaultRenderSection(info, headingProps, bodyProps) {
      return e$1(p$1, {
        children: e$1(Heading, {
          heading: e$1("div", { ...headingProps
          }),
          children: e$1("div", { ...bodyProps
          })
        })
      });
    }

    function AriaAccordionSectionU(_ref2) {
      let {
        open,
        index,
        tag,
        disabled,
        render
      } = _ref2;
      const useAriaAccordionSection = q$1(AccordionSectionContext);
      const {
        useAriaAccordionSectionBodyProps,
        useAriaAccordionSectionHeaderProps,
        ...sectionInfo
      } = useAriaAccordionSection({
        button: {
          tag,
          disabled
        },
        accordionSection: {
          open
        },
        managedChildren: {
          index
        }
      });
      return (render !== null && render !== void 0 ? render : defaultRenderSection)(sectionInfo, useAriaAccordionSectionHeaderProps({}), useAriaAccordionSectionBodyProps({}));
    }

    const AriaAccordion = R(AriaAccordionU);
    const AriaAccordionSection = R(AriaAccordionSectionU);

    B(null);

    const ListboxMultiContext = B(null);

    function ListboxMultiU(_ref, ref) {
      let {
        render,
        tagLabel,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf,
        typeaheadTimeout,
        tagList,
        children: vnodeChildren
      } = _ref;
      const {
        useListboxMultiItem,
        useListboxMultiLabel,
        useListboxMultiProps,
        ...listboxReturnType
      } = useAriaListboxMulti({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listboxMulti: {
          tagLabel,
          tagList
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender,
          onTabbedInTo,
          onTabbedOutOf
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useListboxMultiLabelProps
      } = useListboxMultiLabel();
      const p1 = useListboxMultiLabelProps({});
      const p2 = useListboxMultiProps({
        children: vnodeChildren,
        ref
      });
      return e$1(ListboxMultiContext.Provider, {
        value: useListboxMultiItem,
        children: (render !== null && render !== void 0 ? render : defaultListRender$1)(listboxReturnType, p1, p2)
      });
    }

    function defaultListRender$1(info, labelProps, listProps) {
      const label = e$1("div", { ...labelProps
      });

      const list = e$1("ul", { ...listProps
      });

      return e$1(p$1, {
        children: [label, list]
      });
    }

    function defaultListItemRender$1(info, listItemProps) {
      const listItem = e$1("li", { ...listItemProps
      });

      return e$1(p$1, {
        children: listItem
      });
    }

    function ListboxMultiItemU(_ref2, ref) {
      let {
        index,
        blurSelf,
        disabled,
        flags,
        focusSelf,
        render,
        text,
        hidden,
        selected,
        onSelect
      } = _ref2;
      const {
        useListboxMultiItemProps,
        ...itemReturn
      } = q$1(ListboxMultiContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        listboxMultiItem: {
          disabled,
          selected,
          onSelect
        }
      }); //const listItem = createElement(tagListItem, useListboxMultiItemProps({ ref }) as any);

      return e$1(p$1, {
        children: (render !== null && render !== void 0 ? render : defaultListItemRender$1)(itemReturn, useListboxMultiItemProps({
          ref
        }))
      });
    }

    R(ListboxMultiU);
    R(ListboxMultiItemU);

    const ListboxSingleContext = B(null);

    function ListboxSingleU(_ref, ref) {
      let {
        render,
        selectedIndex,
        tagLabel,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf,
        typeaheadTimeout,
        selectionMode,
        tagList,
        onSelect,
        children: vnodeChildren
      } = _ref;
      const {
        useListboxSingleItem,
        useListboxSingleLabel,
        useListboxSingleProps,
        ...listboxReturnType
      } = useAriaListboxSingle({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listboxSingle: {
          selectionMode,
          tagLabel,
          tagList,
          onSelect
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender,
          onTabbedInTo,
          onTabbedOutOf
        },
        singleSelection: {
          selectedIndex
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useListboxSingleLabelProps
      } = useListboxSingleLabel();
      const label = h$1(tagLabel, useListboxSingleLabelProps({}));
      const list = h$1(tagList, useListboxSingleProps({
        children: vnodeChildren,
        ref
      }));
      return e$1(ListboxSingleContext.Provider, {
        value: useListboxSingleItem,
        children: (render !== null && render !== void 0 ? render : defaultListRender)({ ...listboxReturnType
        }, label, list)
      });
    }

    function defaultListRender() {
      for (var _len = arguments.length, _ref2 = new Array(_len), _key = 0; _key < _len; _key++) {
        _ref2[_key] = arguments[_key];
      }

      let [_info, label, list] = _ref2;
      return e$1(p$1, {
        children: [label, list]
      });
    }

    function defaultListItemRender() {
      for (var _len2 = arguments.length, _ref3 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        _ref3[_key2] = arguments[_key2];
      }

      let [_info, listItem] = _ref3;
      return e$1(p$1, {
        children: listItem
      });
    }

    function ListboxSingleItemU(_ref4, ref) {
      let {
        index,
        tagListItem,
        blurSelf,
        disabled,
        flags,
        focusSelf,
        render,
        text,
        hidden
      } = _ref4;
      const {
        useListboxSingleItemProps,
        rovingTabIndex,
        singleSelection
      } = q$1(ListboxSingleContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        listboxSingleItem: {
          disabled
        }
      });
      const listItem = h$1(tagListItem, useListboxSingleItemProps({
        ref
      }));
      return e$1(p$1, {
        children: (render !== null && render !== void 0 ? render : defaultListItemRender)({
          rovingTabIndex,
          singleSelection
        }, listItem)
      });
    }

    R(ListboxSingleU);
    R(ListboxSingleItemU);

    B(null);

    B(null);

    const SliderThumbContext = B(null);

    function SliderThumbU(_ref2, ref) {
      let {
        label,
        tag,
        value,
        max,
        min,
        onValueChange,
        index,
        flags,
        render,
        valueText
      } = _ref2;
      const {
        useAriaSliderThumbProps,
        ...sliderInfo
      } = q$1(SliderThumbContext)({
        managedChild: {
          index,
          flags
        },
        sliderThumb: {
          label,
          tag,
          value,
          max,
          min,
          onValueChange,
          valueText
        }
      });
      return (render !== null && render !== void 0 ? render : defaultRenderThumb)(sliderInfo, useAriaSliderThumbProps({
        ref
      }));
    }

    function defaultRenderThumb(info, thumbProps) {
      return e$1("input", { ...thumbProps
      });
    }

    R(SliderThumbU);

    const LocationContext = B(null);
    const TableBodyContext = B(null);
    const TableRowContext = B(null);
    const TableCellContext = B(null);

    function defaultRenderTable(info, tableProps) {
      return e$1("table", { ...tableProps
      });
    }

    function defaultRenderTableBody(info, bodyProps) {
      return e$1("tbody", { ...bodyProps
      });
    }

    function defaultRenderTableHead(headProps) {
      return e$1("thead", { ...headProps
      });
    }

    function defaultRenderTableFoot(footProps) {
      return e$1("tfoot", { ...footProps
      });
    }

    function defaultRenderTableRow(info, rowProps) {
      return e$1("tr", { ...rowProps
      });
    }

    function defaultRenderTableCell(info, cellProps) {
      return e$1("td", { ...cellProps
      });
    }

    function TableU(_ref, ref) {
      let {
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf,
        typeaheadTimeout,
        render
      } = _ref;
      const {
        useTableBody,
        useTableProps,
        useTableRow,
        ...tableInfo
      } = useAriaTable({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys
        },
        listNavigation: {},
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender,
          onTabbedInTo,
          onTabbedOutOf
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      return e$1(TableBodyContext.Provider, {
        value: useTableBody,
        children: e$1(TableRowContext.Provider, {
          value: useTableRow,
          children: (render !== null && render !== void 0 ? render : defaultRenderTable)(tableInfo, useTableProps({
            ref
          }))
        })
      });
    }

    function TableBodyU(_ref2, ref) {
      let {
        render
      } = _ref2;
      const {
        useTableBodyProps,
        ...sectionInfo
      } = q$1(TableBodyContext)({});
      return e$1(LocationContext.Provider, {
        value: "body",
        children: (render !== null && render !== void 0 ? render : defaultRenderTableBody)(sectionInfo, useTableBodyProps({
          ref
        }))
      });
    }

    function TableHeadU(_ref3, ref) {
      let {
        render
      } = _ref3;
      return e$1(LocationContext.Provider, {
        value: "head",
        children: (render !== null && render !== void 0 ? render : defaultRenderTableHead)({
          ref
        })
      });
    }

    function TableFootU(_ref4, ref) {
      let {
        render
      } = _ref4;
      return e$1(LocationContext.Provider, {
        value: "foot",
        children: (render !== null && render !== void 0 ? render : defaultRenderTableFoot)({
          ref
        })
      });
    }

    function TableRowU(_ref5, ref) {
      let {
        index,
        text,
        blurSelf,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        flags,
        focusSelf,
        hidden,
        indexDemangler,
        indexMangler,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        onTabbedInTo,
        onTabbedOutOf,
        typeaheadTimeout,
        render
      } = _ref5;
      const {
        useTableCell,
        useTableRowProps,
        ...rowInfo
      } = q$1(TableRowContext)({
        asChildRowOfSection: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden
          },
          subInfo: {}
        },
        asParentRowOfCells: {
          linearNavigation: {
            disableArrowKeys,
            disableHomeEndKeys
          },
          listNavigation: {
            indexDemangler,
            indexMangler
          },
          managedChildren: {
            onAfterChildLayoutEffect,
            onChildrenMountChange
          },
          rovingTabIndex: {
            initialIndex,
            onTabbableIndexChange,
            onTabbableRender,
            onTabbedInTo,
            onTabbedOutOf
          },
          typeaheadNavigation: {
            collator,
            noTypeahead,
            typeaheadTimeout
          }
        },
        tableRow: {
          location: q$1(LocationContext)
        }
      });
      return e$1(TableCellContext.Provider, {
        value: useTableCell,
        children: (render !== null && render !== void 0 ? render : defaultRenderTableRow)(rowInfo, useTableRowProps({
          ref
        }))
      });
    }

    function TableCellU(_ref6, ref) {
      let {
        index,
        text,
        blurSelf,
        flags,
        focusSelf,
        hidden,
        value,
        render
      } = _ref6;
      const {
        useTableCellProps,
        ...cellInfo
      } = q$1(TableCellContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        subInfo: {
          location: q$1(LocationContext),
          value
        }
      });
      return (render !== null && render !== void 0 ? render : defaultRenderTableCell)(cellInfo, useTableCellProps({
        ref
      }));
    }

    R(TableU);
    R(TableBodyU);
    R(TableHeadU);
    R(TableFootU);
    R(TableRowU);
    R(TableCellU);

    B(null);
    B(null);

    B(null);

    function defaultRender(info, triggerProps, tooltipProps) {
      return e$1(p$1, {
        children: [e$1("div", { ...triggerProps
        }), e$1("div", { ...tooltipProps
        })]
      });
    }

    function TooltipU(_ref) {
      let {
        focusDelay,
        mouseoutDelay,
        mouseoverDelay,
        render
      } = _ref;
      const {
        useTooltip,
        useTooltipTrigger,
        ...info
      } = useAriaTooltip({
        focusDelay,
        mouseoutDelay,
        mouseoverDelay
      });
      const {
        useTooltipTriggerProps
      } = useTooltipTrigger();
      const {
        useTooltipProps
      } = useTooltip();
      return e$1(p$1, {
        children: (render !== null && render !== void 0 ? render : defaultRender)(info, useTooltipTriggerProps({}), useTooltipProps({}))
      });
    }

    R(TooltipU);

    function DemoAccordion(props) {
        return e$1(AriaAccordion, { ...props, render: (info, children) => { return e$1("div", { id: "accordion-demo", children: children }); } });
    }
    function DemoAccordionSection({ index, body, heading, disabled, open }) {
        return e$1(AriaAccordionSection, { index: index, open: open, disabled: disabled, render: (info, headerProps, bodyProps) => {
                return (e$1(p$1, { children: e$1(Heading, { heading: e$1("div", { ...headerProps, children: [heading, " (", !info.accordionSection.expanded && "not ", " open), (", !info.accordionSection.focused && "not ", " focused)"] }), children: e$1("div", { ...bodyProps, children: body }) }) }));
            } });
    }
    function Blurb() {
        return (e$1(p$1, { children: [e$1("p", { children: [e$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/accordion/", children: "In accordance with the ARIA guidelines for Accordion patterns," }), " this widget supports the following:"] }), e$1("ul", { children: [e$1("li", { children: ["Each section's header and body are linked via ID; the body is ", e$1("code", { children: "labelled-by" }), " the header and the header ", e$1("code", { children: "control" }), "s the body."] }), e$1("li", { children: "The header is a button and responds to keyboard, mouse, touch, etc. events, regardless of the element used." }), e$1("li", { children: ["If the header element is not a ", e$1("code", { children: "<button>" }), " element, it is given that ", e$1("code", { children: "role" }), "."] }), e$1("li", { children: "Up/down & Home/End keys navigate through the list, as does Tab and Shift+Tab" }), e$1("li", {})] }), e$1("p", { children: ["Important: The ", e$1("code", { children: "render" }), " prop each ", e$1("code", { children: "AccordionSection" }), " takes must wrap the button with a ", e$1("a", { href: "https://w3c.github.io/aria/#heading", children: "heading" }), " (e.g. ", e$1("code", { children: "h3" }), ", or ", e$1("code", { children: "<Heading>" }), "). See the default implementation for an example."] })] }));
    }
    function Code() {
        return (e$1("code", { children: `<AriaAccordion render={...}>
    <AriaAccordionSection index={0} render={...} />
    <AriaAccordionSection index={1} render={...} />
    <AriaAccordionSection index={2} render={...} />
</AriaAccordion>` }));
    }
    function Demo() {
        return (e$1(p$1, { children: [e$1(Blurb, {}), e$1(Code, {}), e$1(DemoAccordion, { children: [e$1(DemoAccordionSection, { index: 0, heading: "Accordion section #0", body: "Body content #0", disabled: false }), e$1(DemoAccordionSection, { index: 1, heading: "Accordion section #1", body: "Body content #1", disabled: false }), e$1(DemoAccordionSection, { index: 2, heading: "Accordion section #2 (disabled)", body: "Body content #2", disabled: true }), e$1(DemoAccordionSection, { index: 3, heading: "Accordion section #3 (forced open)", body: "Body content #3", disabled: false, open: true }), e$1(DemoAccordionSection, { index: 4, heading: "Accordion section #4 (forced closed)", body: "Body content #4", disabled: false, open: false })] })] }));
    }

    //const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const Component = () => {
        return (e$1(Heading, { heading: "Demos", children: e$1(Heading, { heading: "Accordion", children: e$1(Demo, {}) }) }));
    };
    requestAnimationFrame(() => {
        P$1(e$1(Component, {}), document.getElementById("root"));
    });

})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jcmVhdGUtZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NvbnN0YW50cy5qcyIsIi4uL3NyYy9jb21wb25lbnQvaGVhZGluZy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXBhc3NpdmUtc3RhdGUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm0uanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1jbGFzc2VzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbWVyZ2VkLXJlZnMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtc3R5bGVzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbWVyZ2VkLXByb3BzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtcmVmLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1hY3RpdmUtZWxlbWVudC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Utc3RhYmxlLWdldHRlci50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXN0YWJsZS1jYWxsYmFjay50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWFuaW1hdGlvbi1mcmFtZS50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19TeW1ib2wuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRSYXdUYWcuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VHZXRUYWcuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Utc3RhdGUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1lZmZlY3QudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1sYXlvdXQtZWZmZWN0LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtY2hpbGQtbWFuYWdlci50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWRvY3VtZW50LWNsYXNzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZXZlbnQtaGFuZGxlci50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvd2ljZy1pbmVydC9kaXN0L2luZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2Jsb2NraW5nLWVsZW1lbnRzL3NyYy9ibG9ja2luZy1lbGVtZW50cy50cyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZm9yY2UtdXBkYXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbG9naWNhbC1kaXJlY3Rpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS10aW1lb3V0LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXJvdmluZy10YWJpbmRleC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUmFuZG9tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2h1ZmZsZVNlbGYuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVGltZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2h1ZmZsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc2h1ZmZsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Utc29ydGFibGUtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1saXN0LW5hdmlnYXRpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1ncmlkLW5hdmlnYXRpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1yYW5kb20taWQudHN4IiwiLi4vc3JjL3VzZS1idXR0b24udHMiLCIuLi9zcmMvdXNlLWFjY29yZGlvbi50c3giLCIuLi9zcmMvdXNlLWxhYmVsLnRzIiwiLi4vc3JjL3VzZS1saXN0Ym94LXNpbmdsZS50cyIsIi4uL3NyYy91c2UtbGlzdGJveC1tdWx0aS50cyIsIi4uL3NyYy91c2UtdG9vbHRpcC50cyIsIi4uL3NyYy91c2UtdGFibGUudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9hY2NvcmRpb24udHN4IiwiLi4vc3JjL2NvbXBvbmVudC9jaGVja2JveC1ncm91cC50c3giLCIuLi9zcmMvY29tcG9uZW50L2xpc3Rib3gtbXVsdGkudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9saXN0Ym94LXNpbmdsZS50c3giLCIuLi9zcmMvY29tcG9uZW50L21lbnUudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9yYWRpby1ncm91cC50c3giLCIuLi9zcmMvY29tcG9uZW50L3NsaWRlci50c3giLCIuLi9zcmMvY29tcG9uZW50L3RhYmxlLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvdGFicy50c3giLCIuLi9zcmMvY29tcG9uZW50L3Rvb2x0aXAudHN4IiwiZGVtb3MvYWNjb3JkaW9uLnRzeCIsImluZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuXG5sZXQgdm5vZGVJZCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlIGFuIHZpcnR1YWwgbm9kZSAodXNlZCBmb3IgSlNYKVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIGNvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJvcHNdIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuJykuQ29tcG9uZW50Q2hpbGRyZW4+fSBbY2hpbGRyZW5dIFRoZSBjaGlsZHJlbiBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge30sXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAna2V5Jykga2V5ID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBpZiAoaSA9PSAncmVmJykgcmVmID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jaGlsZHJlbiA9XG5cdFx0XHRhcmd1bWVudHMubGVuZ3RoID4gMyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGNoaWxkcmVuO1xuXHR9XG5cblx0Ly8gSWYgYSBDb21wb25lbnQgVk5vZGUsIGNoZWNrIGZvciBhbmQgYXBwbHkgZGVmYXVsdFByb3BzXG5cdC8vIE5vdGU6IHR5cGUgbWF5IGJlIHVuZGVmaW5lZCBpbiBkZXZlbG9wbWVudCwgbXVzdCBuZXZlciBlcnJvciBoZXJlLlxuXHRpZiAodHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLmRlZmF1bHRQcm9wcyAhPSBudWxsKSB7XG5cdFx0Zm9yIChpIGluIHR5cGUuZGVmYXVsdFByb3BzKSB7XG5cdFx0XHRpZiAobm9ybWFsaXplZFByb3BzW2ldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gdHlwZS5kZWZhdWx0UHJvcHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG5vcm1hbGl6ZWRQcm9wcywga2V5LCByZWYsIG51bGwpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFZOb2RlICh1c2VkIGludGVybmFsbHkgYnkgUHJlYWN0KVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIENvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBwcm9wcyBUaGUgcHJvcGVydGllcyBvZiB0aGlzIHZpcnR1YWwgbm9kZS5cbiAqIElmIHRoaXMgdmlydHVhbCBub2RlIHJlcHJlc2VudHMgYSB0ZXh0IG5vZGUsIHRoaXMgaXMgdGhlIHRleHQgb2YgdGhlIG5vZGUgKHN0cmluZyBvciBudW1iZXIpLlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBrZXkgVGhlIGtleSBmb3IgdGhpcyB2aXJ0dWFsIG5vZGUsIHVzZWQgd2hlblxuICogZGlmZmluZyBpdCBhZ2FpbnN0IGl0cyBjaGlsZHJlblxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInJlZlwiXX0gcmVmIFRoZSByZWYgcHJvcGVydHkgdGhhdCB3aWxsXG4gKiByZWNlaXZlIGEgcmVmZXJlbmNlIHRvIGl0cyBjcmVhdGVkIGNoaWxkXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywga2V5LCByZWYsIG9yaWdpbmFsKSB7XG5cdC8vIFY4IHNlZW1zIHRvIGJlIGJldHRlciBhdCBkZXRlY3RpbmcgdHlwZSBzaGFwZXMgaWYgdGhlIG9iamVjdCBpcyBhbGxvY2F0ZWQgZnJvbSB0aGUgc2FtZSBjYWxsIHNpdGVcblx0Ly8gRG8gbm90IGlubGluZSBpbnRvIGNyZWF0ZUVsZW1lbnQgYW5kIGNvZXJjZVRvVk5vZGUhXG5cdGNvbnN0IHZub2RlID0ge1xuXHRcdHR5cGUsXG5cdFx0cHJvcHMsXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRfY2hpbGRyZW46IG51bGwsXG5cdFx0X3BhcmVudDogbnVsbCxcblx0XHRfZGVwdGg6IDAsXG5cdFx0X2RvbTogbnVsbCxcblx0XHQvLyBfbmV4dERvbSBtdXN0IGJlIGluaXRpYWxpemVkIHRvIHVuZGVmaW5lZCBiL2MgaXQgd2lsbCBldmVudHVhbGx5XG5cdFx0Ly8gYmUgc2V0IHRvIGRvbS5uZXh0U2libGluZyB3aGljaCBjYW4gcmV0dXJuIGBudWxsYCBhbmQgaXQgaXMgaW1wb3J0YW50XG5cdFx0Ly8gdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuIHVuaW5pdGlhbGl6ZWQgX25leHREb20gYW5kXG5cdFx0Ly8gYSBfbmV4dERvbSB0aGF0IGhhcyBiZWVuIHNldCB0byBgbnVsbGBcblx0XHRfbmV4dERvbTogdW5kZWZpbmVkLFxuXHRcdF9jb21wb25lbnQ6IG51bGwsXG5cdFx0X2h5ZHJhdGluZzogbnVsbCxcblx0XHRjb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuXHRcdF9vcmlnaW5hbDogb3JpZ2luYWwgPT0gbnVsbCA/ICsrdm5vZGVJZCA6IG9yaWdpbmFsXG5cdH07XG5cblx0Ly8gT25seSBpbnZva2UgdGhlIHZub2RlIGhvb2sgaWYgdGhpcyB3YXMgKm5vdCogYSBkaXJlY3QgY29weTpcblx0aWYgKG9yaWdpbmFsID09IG51bGwgJiYgb3B0aW9ucy52bm9kZSAhPSBudWxsKSBvcHRpb25zLnZub2RlKHZub2RlKTtcblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG5cdHJldHVybiB7IGN1cnJlbnQ6IG51bGwgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEZyYWdtZW50KHByb3BzKSB7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIFByZWFjdCBWTm9kZS5cbiAqIEBwYXJhbSB7Kn0gdm5vZGVcbiAqIEByZXR1cm5zIHt2bm9kZSBpcyBpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRFbGVtZW50ID0gdm5vZGUgPT5cblx0dm5vZGUgIT0gbnVsbCAmJiB2bm9kZS5jb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkO1xuIiwiaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGRpZmYsIGNvbW1pdFJvb3QgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5cbi8qKlxuICogQmFzZSBDb21wb25lbnQgY2xhc3MuIFByb3ZpZGVzIGBzZXRTdGF0ZSgpYCBhbmQgYGZvcmNlVXBkYXRlKClgLCB3aGljaFxuICogdHJpZ2dlciByZW5kZXJpbmdcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBUaGUgaW5pdGlhbCBjb21wb25lbnQgcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IFRoZSBpbml0aWFsIGNvbnRleHQgZnJvbSBwYXJlbnQgY29tcG9uZW50cydcbiAqIGdldENoaWxkQ29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KSB7XG5cdHRoaXMucHJvcHMgPSBwcm9wcztcblx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuLyoqXG4gKiBVcGRhdGUgY29tcG9uZW50IHN0YXRlIGFuZCBzY2hlZHVsZSBhIHJlLXJlbmRlci5cbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0ge29iamVjdCB8ICgoczogb2JqZWN0LCBwOiBvYmplY3QpID0+IG9iamVjdCl9IHVwZGF0ZSBBIGhhc2ggb2Ygc3RhdGVcbiAqIHByb3BlcnRpZXMgdG8gdXBkYXRlIHdpdGggbmV3IHZhbHVlcyBvciBhIGZ1bmN0aW9uIHRoYXQgZ2l2ZW4gdGhlIGN1cnJlbnRcbiAqIHN0YXRlIGFuZCBwcm9wcyByZXR1cm5zIGEgbmV3IHBhcnRpYWwgc3RhdGVcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIGNvbXBvbmVudCBzdGF0ZSBpc1xuICogdXBkYXRlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24odXBkYXRlLCBjYWxsYmFjaykge1xuXHQvLyBvbmx5IGNsb25lIHN0YXRlIHdoZW4gY29weWluZyB0byBuZXh0U3RhdGUgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBzO1xuXHRpZiAodGhpcy5fbmV4dFN0YXRlICE9IG51bGwgJiYgdGhpcy5fbmV4dFN0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZTtcblx0fSBlbHNlIHtcblx0XHRzID0gdGhpcy5fbmV4dFN0YXRlID0gYXNzaWduKHt9LCB0aGlzLnN0YXRlKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgdXBkYXRlID09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBTb21lIGxpYnJhcmllcyBsaWtlIGBpbW1lcmAgbWFyayB0aGUgY3VycmVudCBzdGF0ZSBhcyByZWFkb25seSxcblx0XHQvLyBwcmV2ZW50aW5nIHVzIGZyb20gbXV0YXRpbmcgaXQsIHNvIHdlIG5lZWQgdG8gY2xvbmUgaXQuIFNlZSAjMjcxNlxuXHRcdHVwZGF0ZSA9IHVwZGF0ZShhc3NpZ24oe30sIHMpLCB0aGlzLnByb3BzKTtcblx0fVxuXG5cdGlmICh1cGRhdGUpIHtcblx0XHRhc3NpZ24ocywgdXBkYXRlKTtcblx0fVxuXG5cdC8vIFNraXAgdXBkYXRlIGlmIHVwZGF0ZXIgZnVuY3Rpb24gcmV0dXJuZWQgbnVsbFxuXHRpZiAodXBkYXRlID09IG51bGwpIHJldHVybjtcblxuXHRpZiAodGhpcy5fdm5vZGUpIHtcblx0XHRpZiAoY2FsbGJhY2spIHRoaXMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9XG59O1xuXG4vKipcbiAqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudFxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciBjb21wb25lbnQgaXNcbiAqIHJlLXJlbmRlcmVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRpZiAodGhpcy5fdm5vZGUpIHtcblx0XHQvLyBTZXQgcmVuZGVyIG1vZGUgc28gdGhhdCB3ZSBjYW4gZGlmZmVyZW50aWF0ZSB3aGVyZSB0aGUgcmVuZGVyIHJlcXVlc3Rcblx0XHQvLyBpcyBjb21pbmcgZnJvbS4gV2UgbmVlZCB0aGlzIGJlY2F1c2UgZm9yY2VVcGRhdGUgc2hvdWxkIG5ldmVyIGNhbGxcblx0XHQvLyBzaG91bGRDb21wb25lbnRVcGRhdGVcblx0XHR0aGlzLl9mb3JjZSA9IHRydWU7XG5cdFx0aWYgKGNhbGxiYWNrKSB0aGlzLl9yZW5kZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBBY2NlcHRzIGBwcm9wc2AgYW5kIGBzdGF0ZWAsIGFuZCByZXR1cm5zIGEgbmV3IFZpcnR1YWwgRE9NIHRyZWUgdG8gYnVpbGQuXG4gKiBWaXJ0dWFsIERPTSBpcyBnZW5lcmFsbHkgY29uc3RydWN0ZWQgdmlhIFtKU1hdKGh0dHA6Ly9qYXNvbmZvcm1hdC5jb20vd3RmLWlzLWpzeCkuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgUHJvcHMgKGVnOiBKU1ggYXR0cmlidXRlcykgcmVjZWl2ZWQgZnJvbSBwYXJlbnRcbiAqIGVsZW1lbnQvY29tcG9uZW50XG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgVGhlIGNvbXBvbmVudCdzIGN1cnJlbnQgc3RhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IENvbnRleHQgb2JqZWN0LCBhcyByZXR1cm5lZCBieSB0aGUgbmVhcmVzdFxuICogYW5jZXN0b3IncyBgZ2V0Q2hpbGRDb250ZXh0KClgXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW4gfCB2b2lkfVxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IEZyYWdtZW50O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcGFyYW0ge251bWJlciB8IG51bGx9IFtjaGlsZEluZGV4XVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9tU2libGluZyh2bm9kZSwgY2hpbGRJbmRleCkge1xuXHRpZiAoY2hpbGRJbmRleCA9PSBudWxsKSB7XG5cdFx0Ly8gVXNlIGNoaWxkSW5kZXg9PW51bGwgYXMgYSBzaWduYWwgdG8gcmVzdW1lIHRoZSBzZWFyY2ggZnJvbSB0aGUgdm5vZGUncyBzaWJsaW5nXG5cdFx0cmV0dXJuIHZub2RlLl9wYXJlbnRcblx0XHRcdD8gZ2V0RG9tU2libGluZyh2bm9kZS5fcGFyZW50LCB2bm9kZS5fcGFyZW50Ll9jaGlsZHJlbi5pbmRleE9mKHZub2RlKSArIDEpXG5cdFx0XHQ6IG51bGw7XG5cdH1cblxuXHRsZXQgc2libGluZztcblx0Zm9yICg7IGNoaWxkSW5kZXggPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBjaGlsZEluZGV4KyspIHtcblx0XHRzaWJsaW5nID0gdm5vZGUuX2NoaWxkcmVuW2NoaWxkSW5kZXhdO1xuXG5cdFx0aWYgKHNpYmxpbmcgIT0gbnVsbCAmJiBzaWJsaW5nLl9kb20gIT0gbnVsbCkge1xuXHRcdFx0Ly8gU2luY2UgdXBkYXRlUGFyZW50RG9tUG9pbnRlcnMga2VlcHMgX2RvbSBwb2ludGVyIGNvcnJlY3QsXG5cdFx0XHQvLyB3ZSBjYW4gcmVseSBvbiBfZG9tIHRvIHRlbGwgdXMgaWYgdGhpcyBzdWJ0cmVlIGNvbnRhaW5zIGFcblx0XHRcdC8vIHJlbmRlcmVkIERPTSBub2RlLCBhbmQgd2hhdCB0aGUgZmlyc3QgcmVuZGVyZWQgRE9NIG5vZGUgaXNcblx0XHRcdHJldHVybiBzaWJsaW5nLl9kb207XG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgd2UgZ2V0IGhlcmUsIHdlIGhhdmUgbm90IGZvdW5kIGEgRE9NIG5vZGUgaW4gdGhpcyB2bm9kZSdzIGNoaWxkcmVuLlxuXHQvLyBXZSBtdXN0IHJlc3VtZSBmcm9tIHRoaXMgdm5vZGUncyBzaWJsaW5nIChpbiBpdCdzIHBhcmVudCBfY2hpbGRyZW4gYXJyYXkpXG5cdC8vIE9ubHkgY2xpbWIgdXAgYW5kIHNlYXJjaCB0aGUgcGFyZW50IGlmIHdlIGFyZW4ndCBzZWFyY2hpbmcgdGhyb3VnaCBhIERPTVxuXHQvLyBWTm9kZSAobWVhbmluZyB3ZSByZWFjaGVkIHRoZSBET00gcGFyZW50IG9mIHRoZSBvcmlnaW5hbCB2bm9kZSB0aGF0IGJlZ2FuXG5cdC8vIHRoZSBzZWFyY2gpXG5cdHJldHVybiB0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBudWxsO1xufVxuXG4vKipcbiAqIFRyaWdnZXIgaW4tcGxhY2UgcmUtcmVuZGVyaW5nIG9mIGEgY29tcG9uZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIHJlcmVuZGVyXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudChjb21wb25lbnQpIHtcblx0bGV0IHZub2RlID0gY29tcG9uZW50Ll92bm9kZSxcblx0XHRvbGREb20gPSB2bm9kZS5fZG9tLFxuXHRcdHBhcmVudERvbSA9IGNvbXBvbmVudC5fcGFyZW50RG9tO1xuXG5cdGlmIChwYXJlbnREb20pIHtcblx0XHRsZXQgY29tbWl0UXVldWUgPSBbXTtcblx0XHRjb25zdCBvbGRWTm9kZSA9IGFzc2lnbih7fSwgdm5vZGUpO1xuXHRcdG9sZFZOb2RlLl9vcmlnaW5hbCA9IHZub2RlLl9vcmlnaW5hbCArIDE7XG5cblx0XHRkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0dm5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGNvbXBvbmVudC5fZ2xvYmFsQ29udGV4dCxcblx0XHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHRcdHZub2RlLl9oeWRyYXRpbmcgIT0gbnVsbCA/IFtvbGREb21dIDogbnVsbCxcblx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0b2xkRG9tID09IG51bGwgPyBnZXREb21TaWJsaW5nKHZub2RlKSA6IG9sZERvbSxcblx0XHRcdHZub2RlLl9oeWRyYXRpbmdcblx0XHQpO1xuXHRcdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcblxuXHRcdGlmICh2bm9kZS5fZG9tICE9IG9sZERvbSkge1xuXHRcdFx0dXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKSB7XG5cdGlmICgodm5vZGUgPSB2bm9kZS5fcGFyZW50KSAhPSBudWxsICYmIHZub2RlLl9jb21wb25lbnQgIT0gbnVsbCkge1xuXHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBudWxsO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgY2hpbGQgPSB2bm9kZS5fY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5fZG9tICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuX2RvbSA9IHZub2RlLl9jb21wb25lbnQuYmFzZSA9IGNoaWxkLl9kb207XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgcmVuZGVyIHF1ZXVlXG4gKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn1cbiAqL1xubGV0IHJlcmVuZGVyUXVldWUgPSBbXTtcblxuLypcbiAqIFRoZSB2YWx1ZSBvZiBgQ29tcG9uZW50LmRlYm91bmNlYCBtdXN0IGFzeW5jaHJvbm91c2x5IGludm9rZSB0aGUgcGFzc2VkIGluIGNhbGxiYWNrLiBJdCBpc1xuICogaW1wb3J0YW50IHRoYXQgY29udHJpYnV0b3JzIHRvIFByZWFjdCBjYW4gY29uc2lzdGVudGx5IHJlYXNvbiBhYm91dCB3aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAsIGV0Yy5cbiAqIGRvLCBhbmQgd2hlbiB0aGVpciBlZmZlY3RzIHdpbGwgYmUgYXBwbGllZC4gU2VlIHRoZSBsaW5rcyBiZWxvdyBmb3Igc29tZSBmdXJ0aGVyIHJlYWRpbmcgb24gZGVzaWduaW5nXG4gKiBhc3luY2hyb25vdXMgQVBJcy5cbiAqICogW0Rlc2lnbmluZyBBUElzIGZvciBBc3luY2hyb255XShodHRwczovL2Jsb2cuaXpzLm1lLzIwMTMvMDgvZGVzaWduaW5nLWFwaXMtZm9yLWFzeW5jaHJvbnkpXG4gKiAqIFtDYWxsYmFja3Mgc3luY2hyb25vdXMgYW5kIGFzeW5jaHJvbm91c10oaHR0cHM6Ly9ibG9nLm9tZXRlci5jb20vMjAxMS8wNy8yNC9jYWxsYmFja3Mtc3luY2hyb25vdXMtYW5kLWFzeW5jaHJvbm91cy8pXG4gKi9cblxubGV0IHByZXZEZWJvdW5jZTtcblxuLyoqXG4gKiBFbnF1ZXVlIGEgcmVyZW5kZXIgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjIFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoYykge1xuXHRpZiAoXG5cdFx0KCFjLl9kaXJ0eSAmJlxuXHRcdFx0KGMuX2RpcnR5ID0gdHJ1ZSkgJiZcblx0XHRcdHJlcmVuZGVyUXVldWUucHVzaChjKSAmJlxuXHRcdFx0IXByb2Nlc3MuX3JlcmVuZGVyQ291bnQrKykgfHxcblx0XHRwcmV2RGVib3VuY2UgIT09IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdcblx0KSB7XG5cdFx0cHJldkRlYm91bmNlID0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZztcblx0XHQocHJldkRlYm91bmNlIHx8IHNldFRpbWVvdXQpKHByb2Nlc3MpO1xuXHR9XG59XG5cbi8qKiBGbHVzaCB0aGUgcmVuZGVyIHF1ZXVlIGJ5IHJlcmVuZGVyaW5nIGFsbCBxdWV1ZWQgY29tcG9uZW50cyAqL1xuZnVuY3Rpb24gcHJvY2VzcygpIHtcblx0bGV0IHF1ZXVlO1xuXHR3aGlsZSAoKHByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSByZXJlbmRlclF1ZXVlLmxlbmd0aCkpIHtcblx0XHRxdWV1ZSA9IHJlcmVuZGVyUXVldWUuc29ydCgoYSwgYikgPT4gYS5fdm5vZGUuX2RlcHRoIC0gYi5fdm5vZGUuX2RlcHRoKTtcblx0XHRyZXJlbmRlclF1ZXVlID0gW107XG5cdFx0Ly8gRG9uJ3QgdXBkYXRlIGByZW5kZXJDb3VudGAgeWV0LiBLZWVwIGl0cyB2YWx1ZSBub24temVybyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5XG5cdFx0Ly8gcHJvY2VzcygpIGNhbGxzIGZyb20gZ2V0dGluZyBzY2hlZHVsZWQgd2hpbGUgYHF1ZXVlYCBpcyBzdGlsbCBiZWluZyBjb25zdW1lZC5cblx0XHRxdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0aWYgKGMuX2RpcnR5KSByZW5kZXJDb21wb25lbnQoYyk7XG5cdFx0fSk7XG5cdH1cbn1cbnByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSAwO1xuIiwiZXhwb3J0IGNvbnN0IEVNUFRZX09CSiA9IHt9O1xuZXhwb3J0IGNvbnN0IEVNUFRZX0FSUiA9IFtdO1xuZXhwb3J0IGNvbnN0IElTX05PTl9ESU1FTlNJT05BTCA9IC9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkfGl0ZXJhL2k7XG4iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgd2Fybk9uT3ZlcndyaXRlIH0gZnJvbSBcIi4uL3Byb3BzXCI7XHJcblxyXG5jb25zdCBIZWFkaW5nTGV2ZWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgwKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBIZWFkaW5nKHsgY2hpbGRyZW4sIGhlYWRpbmcsIC4uLnByb3BzIH06IHsgaGVhZGluZzogQ29tcG9uZW50Q2hpbGRyZW4gfSAmIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxIZWFkaW5nRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IGhlYWRpbmdMZXZlbEJlZm9yZVVzID0gdXNlQ29udGV4dChIZWFkaW5nTGV2ZWxDb250ZXh0KTtcclxuICAgIGNvbnN0IG5ld0hlYWRpbmdMZXZlbCA9IGhlYWRpbmdMZXZlbEJlZm9yZVVzICsgMTtcclxuICAgIGxldCB0YWc6IHN0cmluZztcclxuICAgIGlmIChuZXdIZWFkaW5nTGV2ZWwgPD0gNikge1xyXG4gICAgICAgIHRhZyA9IGBoJHtuZXdIZWFkaW5nTGV2ZWx9YDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRhZyA9ICdkaXYnO1xyXG4gICAgICAgIHByb3BzW1wiYXJpYS1sZXZlbFwiXSA9IHdhcm5Pbk92ZXJ3cml0ZShcIkhlYWRpbmdcIiwgXCJhcmlhLWxldmVsXCIsIHByb3BzW1wiYXJpYS1sZXZlbFwiXSwgYCR7bmV3SGVhZGluZ0xldmVsfWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgPEhlYWRpbmdSZXNldCBuZXdMZXZlbD17aGVhZGluZ0xldmVsQmVmb3JlVXMgKyAxfT5cclxuICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnIGFzIGFueSwgcHJvcHMsIGhlYWRpbmcpfVxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9IZWFkaW5nUmVzZXQ+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBIZWFkaW5nUmVzZXQoeyBuZXdMZXZlbCwgY2hpbGRyZW4gfTogeyBuZXdMZXZlbDogbnVtYmVyLCBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4gfSl7ICAgIFxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8SGVhZGluZ0xldmVsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bmV3TGV2ZWx9PlxyXG4gICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9IZWFkaW5nTGV2ZWxDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG59XHJcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuXG5leHBvcnQgdHlwZSBQYXNzaXZlU3RhdGVVcGRhdGVyPFM+ID0gKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VD4gPSAoKHZhbHVlOiBULCBwcmV2VmFsdWU6IFQgfCB1bmRlZmluZWQpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSk7XG5cbi8qKlxuICogRGVidWcgaG9vay5cbiAqIFxuICogR2l2ZW4gYSB2YWx1ZSBvciBzZXQgb2YgdmFsdWVzLCBlbWl0cyBhIGNvbnNvbGUgZXJyb3IgaWYgYW55IG9mIHRoZW0gY2hhbmdlIGZyb20gb25lIHJlbmRlciB0byB0aGUgbmV4dC5cbiAqIFxuICogRXZlbnR1YWxseSwgd2hlbiB1c2VFdmVudCBsYW5kcywgd2UgaG9wZWZ1bGx5IHdvbid0IG5lZWQgdGhpcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVuc3VyZVN0YWJpbGl0eTxUIGV4dGVuZHMgYW55W10+KHBhcmVudEhvb2tOYW1lOiBzdHJpbmcsIC4uLnZhbHVlczogVCkge1xuICAgIHVzZUhlbHBlcih2YWx1ZXMubGVuZ3RoLCAwKTtcbiAgICB2YWx1ZXMuZm9yRWFjaCh1c2VIZWxwZXIpO1xuICAgIHJldHVybjtcblxuXG4gICAgZnVuY3Rpb24gdXNlSGVscGVyPFU+KHZhbHVlOiBVLCBpbmRleDogbnVtYmVyKSB7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBhcmUgcGVyZmVjdGx5IHN0YWJsZSBhY3Jvc3MgcmVuZGVyc1xuICAgICAgICBjb25zdCBoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eSA9IHVzZVJlZih2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHNob3duRXJyb3IgPSB1c2VSZWYoZmFsc2UpO1xuICAgICAgICBpZiAoaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudCAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFzaG93bkVycm9yLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZSBob29rICR7cGFyZW50SG9va05hbWV9IHJlcXVpcmVzIHNvbWUgb3IgYWxsIG9mIGl0cyBhcmd1bWVudHMgcmVtYWluIHN0YWJsZSBhY3Jvc3MgZWFjaCByZW5kZXI7IHBsZWFzZSBjaGVjayB0aGUgJHtpbmRleH0taW5kZXhlZCBhcmd1bWVudC5gKTtcbiAgICAgICAgICAgICAgICBzaG93bkVycm9yLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYHVzZVN0YXRlYCwgYnV0IGZvciB2YWx1ZXMgdGhhdCBhcmVuJ3QgXCJyZW5kZXItaW1wb3J0YW50XCIgJm5kYXNoOyB1cGRhdGVzIGRvbid0IGNhdXNlIGEgcmUtcmVuZGVyIGFuZCBzbyB0aGUgdmFsdWUgc2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHJlbmRlciAodGhvdWdoIGl0IGNlcnRhaW5seSBjYW4sIGF0IGxlYXN0IGJ5IHJlLXJlbmRlcmluZyBhZ2FpbikuXG4gKiBcbiAqIFRvIGNvbXBlbnNhdGUgZm9yIHRoaXMsIHlvdSBzaG91bGQgcGFzcyBhIGB1c2VFZmZlY3RgLWVzcXVlIGNhbGxiYWNrIHRoYXQgaXMgcnVuIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSnVzdCBsaWtlIGB1c2VFZmZlY3RgLCB0aGlzIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQncyBydW4gYmVmb3JlIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgKG9yLCBzYXksIHdoZW4gdGhlIHZhbHVlIG1lZXRzIHNvbWUgY3JpdGVyaWEpLCB0aGlzIGlzIHdoZXJlIHlvdSdsbCB3YW50IHRvIHB1dCBpbiBhIGNhbGwgdG8gYSBgc2V0U3RhdGVgIGZ1bmN0aW9uLlxuICogXG4gKiBUbyBzdW1tYXJpemUsIGl0J3MgbGlrZSBhIGB1c2VTdGF0ZWAtYHVzZUVmZmVjdGAgbWFzaHVwOlxuICogXG4gKiAxLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHRoaXMgdmVyc2lvbiBvZiBgc2V0U3RhdGVgIGRvZXNuJ3QgcmUtcmVuZGVyIHRoZSB3aG9sZSBjb21wb25lbnRcbiAqIDIuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgeW91IGNhbiBydW4gYSBmdW5jdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIHRoYXQgb3B0aW9uYWxseSByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvblxuICogMy4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgeW91IHRyaWdnZXIgdGhlIGVmZmVjdCBmdW5jdGlvbiBcInJlbW90ZWx5XCIgaW5zdGVhZCBvZiBpdCBydW5uaW5nIGFmdGVyIHJlbmRlcmluZ1xuICogNC4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgdGhlIHNpbmdsZSBcImRlcGVuZGVuY3lcIiBpcyBiYXNlZCBvbiB5b3VyIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAqIFxuICogTm90ZSB0aGF0IHdoaWxlIGNhbGxpbmcgYHNldFN0YXRlYCBkb2Vzbid0IGNhdXNlIGFueSByZS1yZW5kZXJzLCB5b3UgY2FuIGRvIHRoYXQgd2l0aGluIHlvdXIgYG9uQ2hhbmdlYCBmdW5jdGlvbiwgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzIHZpYSB0aGF0IGBzZXRTdGF0ZWAuXG4gKiBcbiAqIEBwYXJhbSBvbkNoYW5nZSBUaGUgXCJlZmZlY3RcIiBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYHVzZUVmZmVjdGAncyBcImVmZmVjdFwiIGZ1bmN0aW9uLiAgTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBnZXRJbml0aWFsVmFsdWUgSWYgcHJvdmlkZWQsIHRoZSBlZmZlY3Qgd2lsbCBiZSBpbnZva2VkIG9uY2Ugd2l0aCB0aGlzIHZhbHVlIG9uIG1vdW50LiBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXNzaXZlU3RhdGU8VD4ob25DaGFuZ2U6IHVuZGVmaW5lZCB8IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUPiwgZ2V0SW5pdGlhbFZhbHVlPzogKCkgPT4gVCk6IHJlYWRvbmx5IFtnZXRTdGF0ZVN0YWJsZTogKCkgPT4gVCwgc2V0U3RhdGVTdGFibGU6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD5dIHtcblxuICAgIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmPFQgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcbiAgICBjb25zdCB3YXJuaW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2tSZWYgPSB1c2VSZWY8dW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpPih1bmRlZmluZWQpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBhcmUgcGVyZmVjdGx5IHN0YWJsZSBhY3Jvc3MgcmVuZGVyc1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVBhc3NpdmVTdGF0ZVwiLCBvbkNoYW5nZSwgZ2V0SW5pdGlhbFZhbHVlKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIFwiZGVwZW5kZW5jeSBjaGFuZ2VkXCIgYW5kIFwiY29tcG9uZW50IHVubW91bnRlZFwiLlxuICAgIGNvbnN0IG9uU2hvdWxkQ2xlYW5VcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cENhbGxiYWNrID0gY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChjbGVhbnVwQ2FsbGJhY2spXG4gICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2soKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGVyZSBhcmUgYSBjb3VwbGUgcGxhY2VzIHdoZXJlIHdlJ2QgbGlrZSB0byB1c2Ugb3VyIGluaXRpYWxcbiAgICAvLyB2YWx1ZSBpbiBwbGFjZSBvZiBoYXZpbmcgbm8gdmFsdWUgYXQgYWxsIHlldC5cbiAgICAvLyBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZSBmb3IgdGhhdCwgdXNlZCBvbiBtb3VudCBhbmQgd2hlbmV2ZXJcbiAgICAvLyBnZXRWYWx1ZSBpcyBjYWxsZWQuXG4gICAgY29uc3QgdHJ5RW5zdXJlVmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCAmJiBnZXRJbml0aWFsVmFsdWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldEluaXRpYWxWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/Lihpbml0aWFsVmFsdWUsIHVuZGVmaW5lZCkgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbnMgYXJlIGludGVudGlvbmFsIHRvIGFsbG93IGJhaWxvdXQgKHdpdGhvdXQgZXhwb3NpbmcgdGhlIFVuc2V0IHN5bWJvbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFsvKiBnZXRJbml0aWFsVmFsdWUgYW5kIG9uQ2hhbmdlIGludGVudGlvbmFsbHkgb21pdHRlZCAqL10pO1xuXG5cbiAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHdhcm5pbmdSZWYuY3VycmVudClcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkR1cmluZyBvbkNoYW5nZSwgcHJlZmVyIHVzaW5nIHRoZSAodmFsdWUsIHByZXZWYWx1ZSkgYXJndW1lbnRzIGluc3RlYWQgb2YgZ2V0VmFsdWUgLS0gaXQncyBhbWJpZ3VvdXMgYXMgdG8gaWYgeW91J3JlIGFza2luZyBmb3IgdGhlIG9sZCBvciBuZXcgdmFsdWUgYXQgdGhpcyBwb2ludCBpbiB0aW1lIGZvciB0aGlzIGNvbXBvbmVudC5cIik7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2UgY2FsbCBnZXRWYWx1ZSwgaWYgd2UgaGF2ZW4ndCBiZWVuIGdpdmVuIGEgdmFsdWUgeWV0LFxuICAgICAgICAvLyAoYW5kIHdlIHdlcmUgZ2l2ZW4gYW4gaW5pdGlhbCB2YWx1ZSB0byB1c2UpXG4gICAgICAgIC8vIHJldHVybiB0aGUgaW5pdGlhbCB2YWx1ZSBpbnN0ZWFkIG9mIG5vdGhpbmcuXG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldClcbiAgICAgICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCEgOiB2YWx1ZVJlZi5jdXJyZW50ISkgYXMgVDtcbiAgICB9LCBbXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UndmUgcnVuIG91ciBlZmZlY3QgYXQgbGVhc3Qgb25jZSBvbiBtb3VudC5cbiAgICAgICAgLy8gKElmIHdlIGhhdmUgYW4gaW5pdGlhbCB2YWx1ZSwgb2YgY291cnNlKVxuICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuXG5cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGUgYWN0dWFsIGNvZGUgdGhlIHVzZXIgY2FsbHMgdG8gKHBvc3NpYmx5KSBydW4gYSBuZXcgZWZmZWN0LlxuICAgIGNvbnN0IHIgPSB1c2VSZWYoeyBtaWNyb3Rhc2tRdWV1ZWQ6IGZhbHNlLCBhcmc6IHVuZGVmaW5lZCBhcyB1bmRlZmluZWQgfCBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD4+WzBdLCBwcmV2RGVwOiB1bmRlZmluZWQgYXMgVCB8IHVuZGVmaW5lZCwgaGFuZGxlOiBudWxsIGFzIG51bWJlciB8IG51bGwgfSk7XG4gICAgY29uc3Qgc2V0VmFsdWUgPSB1c2VDYWxsYmFjazxQYXNzaXZlU3RhdGVVcGRhdGVyPFQ+PigoYXJnKSA9PiB7XG4gICAgICAgIHIuY3VycmVudC5wcmV2RGVwID0gdmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQgOiBnZXRWYWx1ZSgpO1xuICAgICAgICByLmN1cnJlbnQuYXJnID0gYXJnO1xuICAgICAgICBpZiAoIXIuY3VycmVudC5taWNyb3Rhc2tRdWV1ZWQpIHtcbiAgICAgICAgICAgIHIuY3VycmVudC5taWNyb3Rhc2tRdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgci5jdXJyZW50LmhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHIuY3VycmVudC5taWNyb3Rhc2tRdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByLmN1cnJlbnQuaGFuZGxlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2RGVwID0gci5jdXJyZW50LnByZXZEZXA7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gci5jdXJyZW50LmFyZyE7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVwID0gYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcocHJldkRlcCEpIDogYXJnO1xuICAgICAgICAgICAgICAgIGlmIChkZXAgIT09IHZhbHVlUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZSB0byB0aGUgdXNlciB0aGF0IHRoZXkgc2hvdWxkbid0IGNhbGwgZ2V0VmFsdWUgZHVyaW5nIG9uQ2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYW55IHJlZ2lzdGVyZWQgY2xlYW51cCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25TaG91bGRDbGVhblVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKGRlcCwgcHJldkRlcCkgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBkZXA7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIG5vcm1hbGx5IGNhbGwgZ2V0VmFsdWUgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuXG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gW2dldFZhbHVlLCBzZXRWYWx1ZV0gYXMgY29uc3Q7XG59XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKCk7XG5cbi8vIEVhc3kgY29uc3RhbnRzIGZvciBnZXRJbml0aWFsVmFsdWVcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5UcnVlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5OdWxsKCkgeyByZXR1cm4gbnVsbDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblVuZGVmaW5lZCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblplcm8oKSB7IHJldHVybiAwOyB9IiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbih7IGNoaWxkcmVuOiBsaHMgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwiY2hpbGRyZW5cIj4sIHsgY2hpbGRyZW46IHJoc306IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcImNoaWxkcmVuXCI+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0ge1xuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCBsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwiaW1wb3J0IHsgZGVmYXVsdCBhcyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXHJcbiAqIER1cGxpY2F0ZSBjbGFzc2VzIGFyZSByZW1vdmVkIChvcmRlciBkb2Vzbid0IG1hdHRlciBhbnl3YXkpLlxyXG4gKiBcclxuICogQHBhcmFtIGxocyBDbGFzc2VzIG9mIHRoZSBmaXJzdCBjb21wb25lbnRcclxuICogQHBhcmFtIHJocyBDbGFzc2VzIG9mIHRoZSBzZWNvbmQgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgY29tYmluZWQgY2xhc3NlcyBmcm9tIGJvdGggYXJndW1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENsYXNzZXM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0Pih7IGNsYXNzOiBsaHNDbGFzcywgY2xhc3NOYW1lOiBsaHNDbGFzc05hbWUgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgXCJjbGFzc1wiIHwgXCJjbGFzc05hbWVcIj4sIHsgY2xhc3M6IHJoc0NsYXNzLCBjbGFzc05hbWU6IHJoc0NsYXNzTmFtZX06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHJcbiAgICAvLyBOb3RlOiBGb3IgdGhlIHNha2Ugb2YgZm9yd2FyZCBjb21wYXRpYmlsaXR5LCB0aGlzIGZ1bmN0aW9uIGlzIGxhYmVsbGVkIGFzXHJcbiAgICAvLyBhIGhvb2ssIGJ1dCBhcyBpdCB1c2VzIG5vIG90aGVyIGhvb2tzIGl0IHRlY2huaWNhbGx5IGlzbid0IG9uZS5cclxuXHJcbiAgICBpZiAobGhzQ2xhc3MgfHwgcmhzQ2xhc3MgfHwgbGhzQ2xhc3NOYW1lIHx8IHJoc0NsYXNzTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGxoc0NsYXNzZXMgPSBjbHN4KGxoc0NsYXNzLCBsaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgY29uc3QgYWxsQ2xhc3NlcyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20obGhzQ2xhc3NlcyksIC4uLkFycmF5LmZyb20ocmhzQ2xhc3NlcyldKVxyXG5cclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCwgUmVmLCBSZWZDYWxsYmFjaywgUmVmT2JqZWN0IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUmVmPFQ+KGluc3RhbmNlOiBUIHwgbnVsbCwgcmVmOiBSZWY8VD4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgKHJlZiBhcyBSZWZPYmplY3Q8VCB8IG51bGw+KS5jdXJyZW50ID0gaW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZhbHNlLCBcIlVua25vd24gcmVmIHR5cGUgZm91bmQgdGhhdCB3YXMgbmVpdGhlciBhIFJlZkNhbGxiYWNrIG5vciBhIFJlZk9iamVjdFwiKTtcclxuICAgIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFI8RT4ge1xyXG4gICAgcmVmPzogUmVmPEU+O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxyXG4gKiBAcGFyYW0gbGhzIFxyXG4gKiBAcGFyYW0gcmhzIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRSZWZzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyByZWY6IHJocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgeyByZWY6IGxocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikge1xyXG4gICAgY29uc3QgY29tYmluZWQ6IFJlZkNhbGxiYWNrPEU+ID0gdXNlQ2FsbGJhY2soKGN1cnJlbnQ6IEUgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCBsaHMpO1xyXG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcclxuICAgIH0sIFtsaHMsIHJoc10pO1xyXG5cclxuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQhO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmhzITtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxocyE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbmZ1bmN0aW9uIHN0eWxlU3RyaW5nVG9PYmplY3Qoc3R5bGU6IHN0cmluZyk6IGguSlNYLkNTU1Byb3BlcnRpZXMge1xyXG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhzdHlsZS5zcGxpdChcIjtcIikubWFwKHN0YXRlbWVudCA9PiBzdGF0ZW1lbnQuc3BsaXQoXCI6XCIpKSkgYXMgdW5rbm93biBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2VzIHR3byBzdHlsZSBvYmplY3RzLCByZXR1cm5pbmcgdGhlIHJlc3VsdC5cclxuICogXHJcbiAqIEBwYXJhbSBzdHlsZSBUaGUgdXNlci1naXZlbiBzdHlsZSBwcm9wIGZvciB0aGlzIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gb2JqIFRoZSBDU1MgcHJvcGVydGllcyB5b3Ugd2FudCBhZGRlZCB0byB0aGUgdXNlci1naXZlbiBzdHlsZVxyXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkU3R5bGVzKGxoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4sIHJoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSB7XHJcblxyXG4gICAgLy8gRWFzeSBjYXNlLCB3aGVuIHRoZXJlIGFyZSBubyBzdHlsZXMgdG8gbWVyZ2UgcmV0dXJuIG5vdGhpbmcuXHJcbiAgICBpZiAoIWxocz8uc3R5bGUgJiYgIXJocz8uc3R5bGUpXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XHJcbiAgICAgICAgLy8gRWFzeSBjYXNlcywgd2hlbiBvbmUgaXMgbnVsbCBhbmQgdGhlIG90aGVyIGlzbid0LlxyXG4gICAgICAgIGlmIChsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gbGhzLnN0eWxlO1xyXG4gICAgICAgIGlmICghbGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzLnN0eWxlO1xyXG5cclxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgdHlwZSB0byBhbiBvYmplY3QgYmFnIHR5cGUgYW5kIHJ1biBpdCBhZ2Fpbi5cclxuICAgICAgICBpZiAobGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKSB7XHJcbiAgICAgICAgICAgIC8vICh1c2VNZXJnZWRTdHlsZXMgaXNuJ3QgYSB0cnVlIGhvb2sgLS0gdGhpcyBpc24ndCBhIHZpb2xhdGlvbilcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKHsgc3R5bGU6IHN0eWxlU3RyaW5nVG9PYmplY3QobGhzPy5zdHlsZSBhcyBzdHJpbmcpIH0sIHJocykgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgeyBzdHlsZTogc3R5bGVTdHJpbmdUb09iamVjdChyaHM/LnN0eWxlIGFzIHN0cmluZykgfSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvZ2ljPz8/XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGV5J3JlIGJvdGggc3RyaW5ncywganVzdCBjb25jYXRlbmF0ZSB0aGVtLlxyXG4gICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gYCR7bGhzLnN0eWxlfTske3Jocz8uc3R5bGUgPz8gXCJcIn1gIGFzIHVua25vd24gYXMgc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZXkncmUgYm90aCBvYmplY3RzLCBqdXN0IG1lcmdlIHRoZW0uXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLihsaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgICAgIC4uLihyaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXHJcbiAgICB9IGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW5cIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2xhc3NlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2xhc3Nlc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1yZWZzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzXCI7XHJcblxyXG5sZXQgbG9nID0gY29uc29sZS53YXJuO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdQcm9wQ29uZmxpY3RzKGxvZzI6IHR5cGVvZiBjb25zb2xlW1wibG9nXCJdKSB7XHJcbiAgICBsb2cgPSBsb2cyXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAqIFxyXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxyXG4gKiBAcGFyYW0gbGhzMiBcclxuICogQHBhcmFtIHJoczIgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4obGhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgcmhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcclxuICAgIC8vIEZpcnN0LCBzZXBhcmF0ZSB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiBpbnRvIHR3byBncm91cHM6XHJcbiAgICAvLyBsaHNBbGwgYW5kIHJoc0FsbCBjb250YWluIGFsbCB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiwgYW5kXHJcbiAgICAvLyBsaHNNaXNjIGFuZCByaHNNaXNjIGNvbnRhaW4gYWxsIHByb3BzICpleGNlcHQqIGZvciB0aGUgZWFzeSBvbmVzXHJcbiAgICAvLyBsaWtlIGNsYXNzTmFtZSBhbmQgc3R5bGUgdGhhdCB3ZSBhbHJlYWR5IGtub3cgaG93IHRvIG1lcmdlLlxyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX2xoc0NoaWxkcmVuLCBjbGFzczogX2xoc0NsYXNzLCBjbGFzc05hbWU6IF9saHNDbGFzc05hbWUsIHN0eWxlOiBfbGhzU3R5bGUsIHJlZjogX2xoc1JlZiwgLi4ubGhzTWlzYyB9ID0gbGhzQWxsO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX3Joc0NoaWxkcmVuLCBjbGFzczogX3Joc0NsYXNzLCBjbGFzc05hbWU6IF9yaHNDbGFzc05hbWUsIHN0eWxlOiBfcmhzU3R5bGUsIHJlZjogX3Joc1JlZiwgLi4ucmhzTWlzYyB9ID0gcmhzQWxsO1xyXG5cclxuICAgIGNvbnN0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7XHJcbiAgICAgICAgLi4ubGhzTWlzYyxcclxuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIGNsYXNzTmFtZTogdXNlTWVyZ2VkQ2xhc3NlcyhsaHNBbGwsIHJoc0FsbCksXHJcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbCwgcmhzQWxsKSxcclxuICAgIH0gYXMgYW55O1xyXG5cclxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xyXG4gICAgaWYgKHJldC5zdHlsZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnN0eWxlO1xyXG4gICAgaWYgKHJldC5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jbGFzc05hbWU7XHJcbiAgICBpZiAocmV0LmNoaWxkcmVuID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2hpbGRyZW47XHJcblxyXG4gICAgLy8gTm93LCBkbyAqZXZlcnl0aGluZyogZWxzZVxyXG4gICAgLy8gTWVyZ2UgZXZlcnkgcmVtYWluaW5nIGV4aXN0aW5nIGVudHJ5IGluIGxocyB3aXRoIHdoYXQgd2UndmUgYWxyZWFkeSBwdXQgaW4gcmV0LlxyXG4gICAgLy9jb25zdCBsaHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMobGhzKSBhcyBba2V5b2YgVCwgVFtrZXlvZiBUXV1bXTtcclxuICAgIGNvbnN0IHJoc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhyaHNNaXNjKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtyaHNLZXlVLCByaHNWYWx1ZV0gb2YgcmhzRW50cmllcykge1xyXG4gICAgICAgIGNvbnN0IHJoc0tleSA9IHJoc0tleVUgYXMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcblxyXG4gICAgICAgIGNvbnN0IGxoc1ZhbHVlID0gbGhzTWlzY1tyaHNLZXkgYXMga2V5b2YgdHlwZW9mIGxoc01pc2NdO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGxoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgbWVyZ2VkIChvciBvbmUncyBhIGZ1bmN0aW9uIGFuZCB0aGUgb3RoZXIncyBudWxsKS5cclxuICAgICAgICAgICAgLy8gTm90IGFuICplYXN5KiBjYXNlLCBidXQgYSB3ZWxsLWRlZmluZWQgb25lLlxyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZUZ1bmN0aW9ucyhsaHNWYWx1ZSBhcyBuZXZlciwgcmhzVmFsdWUgYXMgbmV2ZXIpO1xyXG4gICAgICAgICAgICByZXRbcmhzS2V5IGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+XSA9IG1lcmdlZCBhcyBuZXZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XHJcbiAgICAgICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsICYmIHJoc1ZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IGxoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke3Joc0tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZSBhcyBuZXZlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUZ1bmN0aW9uczxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4obGhzOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBVIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG5cclxuICAgIGlmICghbGhzKVxyXG4gICAgICAgIHJldHVybiByaHM7XHJcbiAgICBpZiAoIXJocylcclxuICAgICAgICByZXR1cm4gbGhzO1xyXG5cclxuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHJ2ID0gcmhzKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qXHJcbmZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG5cclxuICAgIGNvbnN0IGlkMDogR2VuZXJpY0dldDx7fSwgXCJpZFwiLCBzdHJpbmc+ID0gXCJcIjtcclxuICAgIGNvbnN0IGlkMzogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ0OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDU6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNjogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgLy9jb25zdCBpZDI6IFppcFNpbmdsZTxzdHJpbmcgfCB1bmRlZmluZWQsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDE6IFppcE9iamVjdDx7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0geyBpZDogdW5kZWZpbmVkIH07XHJcblxyXG4gICAgdHlwZSBNMSA9IEdlbmVyaWNHZXQ8UCwgXCJzdHlsZVwiLCBzdHJpbmc+O1xyXG4gICAgdHlwZSBNMiA9IEdlbmVyaWNHZXQ8e30sIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIGNvbnN0IG0xOiBNMSA9IFwiXCI7XHJcbiAgICBjb25zdCBtMjogTTEgPSB1bmRlZmluZWQ7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xyXG4gICAgY29uc3QgbTM6IE0xID0gMDtcclxuXHJcbiAgICBjb25zdCBtNDogTTIgPSBcIlwiO1xyXG4gICAgY29uc3QgbTU6IE0yID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG02OiBNMiA9IDA7XHJcblxyXG4gICAgY29uc3QgcDE6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDI6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDM6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNDogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHt9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHt9KTtcclxuICAgIGNvbnN0IHA1ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywge30pO1xyXG4gICAgY29uc3QgcDYgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNyA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IFwic3RyaW5nXCIgfSk7XHJcblxyXG5cclxuICAgIHAxLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwMi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcDMuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHA0LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHA1LmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDcuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNy5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDUuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA3LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBpdCB3b3JrcyByZWN1cnNpdmVseVxyXG4gICAgY29uc3QgcjFhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDEpO1xyXG4gICAgY29uc3QgcjFiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDEpO1xyXG4gICAgY29uc3QgcjJhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDIpO1xyXG4gICAgY29uc3QgcjJiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDIpO1xyXG4gICAgY29uc3QgcjNhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDMpO1xyXG4gICAgY29uc3QgcjNiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDMpO1xyXG4gICAgY29uc3QgcjRhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDQpO1xyXG4gICAgY29uc3QgcjRiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDQpO1xyXG4gICAgY29uc3QgcjVhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDUpO1xyXG4gICAgY29uc3QgcjViID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDUpO1xyXG4gICAgY29uc3QgcjZhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDYpO1xyXG4gICAgY29uc3QgcjZiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDYpO1xyXG4gICAgY29uc3QgcjdhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDcpO1xyXG4gICAgY29uc3QgcjdiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDcpO1xyXG5cclxuXHJcbiAgICByMWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIxYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcjNhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByM2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHI0YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjRiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHI1YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjViLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI2Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByN2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNWEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjViLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI2YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmIuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjdhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3Yi5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjVhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjViLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG59XHJcbmZ1bmN0aW9uIGFjY2VwdHNOZXZlcihuOiBuZXZlcikge31cclxuKi8iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGdldEVsZW1lbnQoKTogVCB8IG51bGw7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlUmVmRWxlbWVudFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcclxuICAgIG9uRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsPjtcclxuICAgIG9uTW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcclxuICAgIG9uVW5tb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogQWxsb3dzIGFjY2Vzc2luZyB0aGUgZWxlbWVudCBhIHJlZiByZWZlcmVuY2VzIGFzIHNvb24gYXMgaXQgZG9lcyBzby5cclxuICogKlRoaXMgaG9vayBpdHNlbGYgcmV0dXJucyBhIGhvb2sqLS11c2VSZWZFbGVtZW50UHJvcHMgbW9kaWZpZXMgdGhlIHByb3BzIHRoYXQgeW91IHdlcmUgZ29pbmcgdG8gcGFzcyB0byBhbiBIVE1MRWxlbWVudCwgXHJcbiAqIGFkZGluZyBhIFJlZkNhbGxiYWNrIGFuZCBtZXJnaW5nIGl0IHdpdGggYW55IGV4aXN0aW5nIHJlZiB0aGF0IGV4aXN0ZWQgb24gdGhlIHByb3BzLlxyXG4gKiBcclxuICogRG9uJ3QgZm9yZ2V0IHRvIHByb3ZpZGUgdGhlIEVsZW1lbnQgYXMgdGhlIHR5cGUgYXJndW1lbnQhXHJcbiAqIFxyXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudCwgYW5kIHRoZSBzdWItaG9vayB0aGF0IG1ha2VzIGl0IHJldHJpZXZhYmxlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnQ8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PihhcmdzPzogVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4pOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiB7XHJcbiAgICBjb25zdCB7IG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50IH0gPSAoYXJncyA/PyB7fSk7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUmVmRWxlbWVudFwiLCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCk7XHJcblxyXG4gICAgLy8gQ2FsbGVkIChpbmRpcmVjdGx5KSBieSB0aGUgcmVmIHRoYXQgdGhlIGVsZW1lbnQgcmVjZWl2ZXMuXHJcbiAgICBjb25zdCBoYW5kbGVyID0gdXNlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGw+PigoZSwgcHJldlZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IG9uRWxlbWVudENoYW5nZT8uKGUsIHByZXZWYWx1ZSk7XHJcbiAgICAgICAgaWYgKHByZXZWYWx1ZSlcclxuICAgICAgICAgICAgb25Vbm1vdW50Py4ocHJldlZhbHVlISk7XHJcblxyXG4gICAgICAgIGlmIChlKVxyXG4gICAgICAgICAgICBvbk1vdW50Py4oZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIC8vIExldCB1cyBzdG9yZSB0aGUgYWN0dWFsIChyZWZlcmVuY2UgdG8pIHRoZSBlbGVtZW50IHdlIGNhcHR1cmVcclxuICAgIGNvbnN0IFtnZXRFbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxUIHwgbnVsbD4oaGFuZGxlciwgcmV0dXJuTnVsbCk7XHJcbiAgICBjb25zdCB1c2VSZWZFbGVtZW50UHJvcHMgPSB1c2VDYWxsYmFjazxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPltcInVzZVJlZkVsZW1lbnRQcm9wc1wiXT4oKHByb3BzKSA9PiB1c2VNZXJnZWRQcm9wczxUPih7IHJlZjogc2V0RWxlbWVudCB9LCBwcm9wcyksIFtdKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcclxuICAgIC8vIHRoZSBwcm9wcyBhbmQgYWxsb3dzIHVzIHRvIGFjdHVhbGx5IGZpbmQgdGhlIGVsZW1lbnRcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlUmVmRWxlbWVudFByb3BzLFxyXG4gICAgICAgIGdldEVsZW1lbnRcclxuICAgIH1cclxufVxyXG4iLCJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgcmV0dXJuVHJ1ZSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnMsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5cblxuLyoqXG4gKiBcbiAqIFRoZXJlIGFyZSBzZXZlcmFsIGRpZmZlcmVudCB3YXlzIHRoYXQgYSBmb2N1cyBldmVudCBjYW4gaGFwcGVuLiAgQXNzdW1lXG4gKiB0aGUgZm9sbG93aW5nIHN0ZXBzIGhhcHBlbiBpbiBvcmRlcjpcbiAqIFxuICogMS4gVGhlIHBhZ2UgbG9hZHMuXG4gKiAgICAqIE5vdGhpbmcgaXMgZm9jdXNlZCwgYnV0IGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBgYm9keWAuIFxuICogICAgKiBObyBmb2N1cyBldmVudHMgYXJlIGZpcmVkLlxuICogMi4gVGhlIHdpbmRvdyBpcyBmb2N1c2VkLCBhbiB1bmZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIHRleHQgaXMgc2VsZWN0ZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCByZW1haW5zIGFzIGBib2R5YC5cbiAqICAgICogQSBgZm9jdXNgL2Bmb2N1c2luYCBldmVudCAqTUlHSFQqIGJlIGZpcmVkIGZvciBgYm9keWAuIERlcGVuZGluZyBvblxuICogICAgICB0aGUgYnJvd3NlciwgdGhpcyBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlIGhhbmRsZXIgd2FzIGF0dGFjaGVkIHRvIGB3aW5kb3dgIG9yIGBkb2N1bWVudGAuXG4gKiAgICAgIFByb2JhYmx5IGp1c3QgYmVzdCB0byBub3QgcmVseSBvbiBpdCwgb3IgbGlzdGVuIHRvIGB3aW5kb3dgIGZvY3VzIGV2ZW50cyBkaXJlY3RseS5cbiAqIDMuIEEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgbmV3IGVsZW1lbnQgYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxuICogICAgKiBgZm9jdXNvdXRgIGFuZCBgYmx1cmAgYXJlICpub3QqIGZpcmVkIG9uIGBib2R5YC5cbiAqICAgICogYGZvY3VzYCBhbmQgYGZvY3VzaW5gIGFyZSBmaXJlZCBvbiB0aGUgbmV3IGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxuICogNC4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXG4gKiAgICAqICoqVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gdGhlIGBib2R5YCoqIGJlZm9yZSBhbnkgZXZlbnQgZXZlbiBmaXJlcy5cbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyB0aGUgbmV3IGVsZW1lbnQuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgbm93IHNldCB0byB0aGUgbmV3IGVsZW1lbnQuXG4gKiAgICAqIGBmb2N1c2luYCBpcyBmaXJlZCBvbiB0aGUgbmV3IGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyB0aGUgb2xkIGVsZW1lbnQuXG4gKiA1LiBBbiB1bmZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIHRleHQgaXMgc2VsZWN0ZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gYGJvZHlgLlxuICogICAgKiBgYmx1cmAgYW5kIGBmb2N1c291dGAgYXJlIGZpcmVkIG9uIHRoZSBvbGQgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwuXG4gKiAgICAqIGBmb2N1c2luYCBpcyAqbm90KiBmaXJlZCBvbiBgYm9keWAuXG4gKiBcbiAqIFxuICogSW4gc3VtbWFyeTpcbiAqIDEuIEZvY3VzIGV2ZW50cyAqZG8qIG5vdGlmeSB1cyBvZiBhbGwgY2hhbmdlcyBpbiBmb2N1cywgYnV0IHRoZXJlIGlzIG5vIG9uZSBzaW5nbGUgY29tcHJlaGVuc2l2ZSBldmVudCB0aGF0IHByb3ZpZGVzIHVzIHdpdGggYWxsIGF2YWlsYWJsZSBpbmZvcm1hdGlvbi5cbiAqIDIuIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCAqaXMgbm90KiBhbHdheXMgdGhlIHNhbWUgYXMgd2hhdCdzIGJlaW5nIHJlZmVyZW5jZWQgYnkgYSBmb2N1cyBldmVudC4gSW4gcGFydGljdWxhciwgaXQgbWF5IGJlY29tZSBgYm9keWAgYXQgYW55IGFyYml0cmFyeSB0aW1lLlxuICogMy4gQSBgYmx1cmAgd2l0aG91dCBhIGBmb2N1c2AgY2FuIGFuZCB3aWxsIG9jY3VyLiBUaGlzIG1lYW5zIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBzb2xlbHkgdXNlIGBmb2N1c2AgdG8gZGV0ZWN0IGFsbCBjaGFuZ2VzLlxuICogNC4gQSBgYmx1cmAgZXZlbnQgd2hvc2UgYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwgaW5kaWNhdGVzIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBmb2xsb3dpbmcgYGZvY3VzYCBldmVudC5cbiAqIFxuICogXG4gKiBAcGFyYW0gY2FsbGJhY2sgXG4gKiBAcmV0dXJucyBcbiAqL1xuY29uc3QgX2R1bW15ID0gMDtcblxuY29uc3QgYWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBOb2RlIHwgbnVsbCkgPT4gdm9pZCk+PigpO1xuY29uc3QgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogTm9kZSkgPT4gdm9pZCk+PigpO1xuY29uc3Qgd2luZG93Rm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChmb2N1c2VkOiBib29sZWFuKSA9PiB2b2lkKT4+KCk7XG5jb25zdCB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBib29sZWFuPigpO1xuXG5jb25zdCBtaWNyb3Rhc2tzID0gbmV3IFNldDxNYXA8YW55LCBhbnk+PigpO1xuXG4vLyBUaGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgZXZlbnRzIG9mdGVuIGZpcmUgc3luY3Jvbm91c2x5IGluIHRoZSBtaWRkbGUgb2YgcnVubmluZyBjb2RlLlxuLy8gRS5HLiBjYWxsaW5nIGVsZW1lbnQuZm9jdXMoKSBjYW4gY2F1c2UgYSBmb2N1c2luIGV2ZW50IGhhbmRsZXIgdG8gaW1tZWRpYXRlbHkgaW50ZXJydXB0IHRoYXQgY29kZS5cbi8vIEZvciB0aGUgcHVycG9zZSBvZiBpbXByb3Zpbmcgc3RhYmlsaXR5LCB3ZSBkZWJvdW5jZSBhbGwgZm9jdXMgZXZlbnRzIHRvIHRoZSBuZXh0IG1pY3JvdGFzay5cbmZ1bmN0aW9uIGZvckVhY2hVcGRhdGVyPFQ+KHdpbmRvdzogV2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgbWFwOiBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogVCkgPT4gdm9pZCk+PiwgdmFsdWU6IFQpIHtcbiAgICBpZiAoIW1pY3JvdGFza3MuaGFzKG1hcCkpIHtcbiAgICAgICAgbWljcm90YXNrcy5hZGQobWFwKTtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgbWljcm90YXNrcy5kZWxldGUobWFwKTtcblxuICAgICAgICAgICAgY29uc3QgdXBkYXRlcnMgPSBtYXAuZ2V0KHdpbmRvdyk7XG4gICAgICAgICAgICBpZiAodXBkYXRlcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZXIgb2YgdXBkYXRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlcj8uKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9jdXNvdXQoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG4gICAgaWYgKGUucmVsYXRlZFRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBudWxsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEp1c3Qgd2FpdCBmb3IgdGhlIGZvY3VzaW4gZXZlbnQuXG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGZvY3VzaW4oZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIGNvbnN0IGN1cnJlbnRseUZvY3VzZWRFbGVtZW50ID0gZS50YXJnZXQgYXMgKEVsZW1lbnQgJiBIVE1MT3JTVkdFbGVtZW50KTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGFjdGl2ZUVsZW1lbnRVcGRhdGVycywgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycywgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiB3aW5kb3dGb2N1cyhlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS50YXJnZXQgOiBlLmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLmN1cnJlbnRUYXJnZXQgOiAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyk7XG4gICAgd2luZG93c0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCB0cnVlKTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIHdpbmRvd0ZvY3VzZWRVcGRhdGVycywgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHdpbmRvd0JsdXIoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUudGFyZ2V0IDogZS5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS5jdXJyZW50VGFyZ2V0IDogKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgZmFsc2UpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLCBmYWxzZSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnM8VCBleHRlbmRzIE5vZGU+IHtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcy4gTXVzdCBiZSBzdGFibGUuXG4gICAgICovXG4gICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8RWxlbWVudCB8IG51bGw+O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzIGFuZCBpcyBub3QgbnVsbC4gXG4gICAgICogTXVzdCBiZSBzdGFibGUuXG4gICAgICovXG4gICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnQ+O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSB3aW5kb3cgZ2FpbnMvbG9zZXMgZm9jdXMuIE11c3QgYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPGJvb2xlYW4+O1xuXG4gICAgb25Nb3VudD86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+W1wib25Nb3VudFwiXTtcbiAgICBvblVubW91bnQ/OiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPltcIm9uVW5tb3VudFwiXTtcbiAgICBvbk1vdW50Q2hhbmdlPzogVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD5bXCJvbkVsZW1lbnRDaGFuZ2VcIl07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGU8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgT21pdDxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiwgXCJ1c2VSZWZFbGVtZW50UHJvcHNcIj4ge1xuICAgIC8qKiBcbiAgICAgKiBSZXR1cm5zIHdoYXRldmVyIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWQsIG9yIGBudWxsYCBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50IHwgbnVsbDtcbiAgICAvKiogXG4gICAgICogUmV0dXJucyB3aGF0ZXZlciBlbGVtZW50IGlzIGN1cnJlbnRseSBmb2N1c2VkLCBvciB3aGF0ZXZlciBlbGVtZW50IHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnRcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQ6ICgpID0+IEVsZW1lbnQ7XG4gICAgLyoqIFxuICAgICAqIFJldHVybnMgaWYgdGhlIHdpbmRvdyBpdHNlbGYgaGFzIGZvY3VzIG9yIG5vdFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBnZXRXaW5kb3dGb2N1c2VkOiAoKSA9PiBib29sZWFuO1xuXG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VBY3RpdmVFbGVtZW50UHJvcHM6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+W1widXNlUmVmRWxlbWVudFByb3BzXCJdO1xufVxuXG4vKipcbiAqIEFsbG93cyB5b3UgdG8gaW5zcGVjdCB3aGljaCBlbGVtZW50IGluIHRoZSBgZG9jdW1lbnRgIGN1cnJlbnRseSBoYXMgZm9jdXMsIHdoaWNoIHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgbm9uZSBhcmUgY3VycmVudGx5LCBhbmQgd2hldGhlciBvciBub3QgdGhlIHdpbmRvdyBoYXMgZm9jdXMgYnkgcmV0dXJuaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICogKiBgZ2V0QWN0aXZlRWxlbWVudCgpYFxuICogKiBgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQoKWBcbiAqICogYGdldFdpbmRvd0ZvY3VzZWQoKWBcbiAqIFxuICogKFRoZSBkb2N1bWVudCdzIGJvZHkgcmVjZWl2aW5nIGZvY3VzLCBsaWtlIGl0IGRvZXMgd2hlbiB5b3UgY2xpY2sgb24gYW4gZW1wdHkgYXJlYSwgaXMgY291bnRlZCBhcyBubyBlbGVtZW50IGhhdmluZyBmb2N1cyBmb3IgYWxsIGludGVudHMgYW5kIHB1cnBvc2VzKVxuICogXG4gKiBUaGlzIGlzIGEgcGFzc2l2ZSBob29rLCBzbyBieSBkZWZhdWx0IGl0IHJldHVybnMgZ2V0dGVyIGZ1bmN0aW9ucyB0aGF0IHJlcG9ydCB0aGlzIGluZm9ybWF0aW9uIGJ1dCB0aGUgY29tcG9uZW50IHdpbGwgbm90IHJlLXJlbmRlciBieSBkZWZhdWx0IHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMuXG4gKiBcbiAqIElmIHlvdSBuZWVkIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMsIHVzZSB0aGUgYG9uKkNoYW5nZWAgYXJndW1lbnRzIHRvIHNldCBzb21lIHN0YXRlIG9uIHlvdXIgZW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aXZlRWxlbWVudDxUIGV4dGVuZHMgTm9kZT4oeyBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50LCBvbk1vdW50Q2hhbmdlIH06IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzPFQ+KTogVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGU8VD4ge1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlQWN0aXZlRWxlbWVudFwiLCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgb25Nb3VudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50KTtcblxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHtcbiAgICAgICAgb25Nb3VudCxcbiAgICAgICAgb25Vbm1vdW50LFxuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlbGVtZW50OiBUIHwgbnVsbCwgcHJldlZhbHVlOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VudENoYW5nZT8uKGVsZW1lbnQsIHByZXZWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpbmRvdyA9IGRvY3VtZW50Py5kZWZhdWx0VmlldztcblxuICAgICAgICAgICAgICAgIGlmICgoYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpPy5zaXplID8/IDApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZm9jdXNvdXQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgd2luZG93Rm9jdXMsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZW0gZXZlbiBpZiB0aGV5J3JlIHVuZGVmaW5lZCB0byBtb3JlIGVhc2lseVxuICAgICAgICAgICAgICAgIC8vIG1hbmFnZSB0aGUgXCI+MCBtZWFucyBkb24ndCBhZGQgaGFuZGxlcnNcIiBsb2dpYy5cbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMgPSB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuXG4gICAgICAgICAgICAgICAgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMuYWRkKHNldEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGUgfCBudWxsPik7XG4gICAgICAgICAgICAgICAgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChzZXRMYXN0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZT4pO1xuICAgICAgICAgICAgICAgIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzLmFkZChzZXRXaW5kb3dGb2N1c2VkKTtcblxuICAgICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyk7XG4gICAgICAgICAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xuICAgICAgICAgICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykhLmRlbGV0ZShzZXRBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlIHwgbnVsbD4pO1xuICAgICAgICAgICAgICAgICAgICBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUoc2V0TGFzdEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGU+KTtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUoc2V0V2luZG93Rm9jdXNlZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1cik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKVxuICAgIH0pXG5cbiAgICBjb25zdCBbZ2V0QWN0aXZlRWxlbWVudCwgc2V0QWN0aXZlRWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8RWxlbWVudCB8IG51bGw+KG9uQWN0aXZlRWxlbWVudENoYW5nZSwgcmV0dXJuTnVsbCk7XG4gICAgY29uc3QgW2dldExhc3RBY3RpdmVFbGVtZW50LCBzZXRMYXN0QWN0aXZlRWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8RWxlbWVudD4ob25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgcmV0dXJuTnVsbCBhcyAoKSA9PiBuZXZlcik7XG4gICAgY29uc3QgW2dldFdpbmRvd0ZvY3VzZWQsIHNldFdpbmRvd0ZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmV0dXJuVHJ1ZSk7XG5cbiAgICByZXR1cm4geyBnZXRFbGVtZW50LCB1c2VBY3RpdmVFbGVtZW50UHJvcHM6IHVzZVJlZkVsZW1lbnRQcm9wcywgZ2V0QWN0aXZlRWxlbWVudCwgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsIGdldFdpbmRvd0ZvY3VzZWQgfTtcbn1cbiIsIlxuaW1wb3J0IHsgQ29tcG9uZW50LCBvcHRpb25zLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEVmZmVjdENhbGxiYWNrLCBJbnB1dHMsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cblxuXG5jb25zdCBUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLVwiO1xuXG5mdW5jdGlvbiBiYXNlNjQodmFsdWU6IG51bWJlcikge1xuICAgIHJldHVybiBUYWJsZVt2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTZCaXRzKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAwYjEwMDAwMDApO1xufVxuXG5mdW5jdGlvbiByYW5kb202NEJpdHMoKSB7XG4gICAgcmV0dXJuIFtyYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpXSBhcyBjb25zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIHdpdGggYW4gb3B0aW9uYWwgcHJlZml4LlxuICogTm90ZSB0aGF0IGlmIHRoZSBwcmVmaXggaXMgKmV4cGxpY2l0bHkqIHNldCB0byBcIlwiLCB0aGVuXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxuICogXG4gKiBcbiAqIChUaGlzIGlzIGhlcmUsIGluIHRoaXMgcGFydGljdWxhciBmaWxlLCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbiAqIHdpdGhvdXQgYWxzbyBtYWtpbmcgYSB1dGlsaXRpZXMgZmlsZS5cbiAqIE9uY2Ugd2UgY2FuIHJlbW92ZSB0aGlzIGhvb2ssIHdlIGNhbiBwdXQgdGhpcyBmdW5jdGlvbiBiYWNrIHdpdGggdXNlUmFuZG9tSWQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeD86IHN0cmluZykge1xuICAgIHJldHVybiBgJHtwcmVmaXggPz8gXCJpZC1cIn0ke3JhbmRvbTY0Qml0cygpLm1hcChuID0+IGJhc2U2NChuKSkuam9pbihcIlwiKX1gO1xufVxuXG5jb25zdCBwcmV2aW91c0lucHV0cyA9IG5ldyBNYXA8c3RyaW5nLCBJbnB1dHMgfCB1bmRlZmluZWQ+KCk7XG5jb25zdCB0b1J1biA9IG5ldyBNYXA8c3RyaW5nLCB7IGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cywgY2xlYW51cDogbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWQgfCAoKCkgPT4gdm9pZCkgfT4oKTtcblxuXG4vLyBUT0RPOiBXaGV0aGVyIHRoaXMgZ29lcyBpbiBvcHRpb25zLmRpZmZlZCBvciBvcHRpb25zLl9jb21taXRcbi8vIGlzIGEgcG9zdC1zdXNwZW5zZSBxdWVzdGlvbi5cbi8vIFJpZ2h0IG5vdywgdXNpbmcgb3B0aW9ucy5fY29tbWl0IGhhcyB0aGUgcHJvYmxlbSBvZiBydW5uaW5nXG4vLyAqYWZ0ZXIqIHJlZnMgYXJlIGFwcGxpZWQsIGJ1dCB3ZSBuZWVkIHRvIGNvbWUgYmVmb3JlIGV2ZW4gdGhhdFxuLy8gc28gYHJlZj17c29tZVN0YWJsZUZ1bmN0aW9ufWAgd29ya3MuXG4vLyBcbi8vIEFsc28gaXQncyBwcml2YXRlLlxuLy9cbi8vIC4uLlxuLy8gV2VsbCwgdXNlRXZlbnQgb3Igd2hhdGV2ZXIgaXMgZmluYWxseSwgZmluYWxseSA0IHllYXJzIGxhdGVyIGZpbmFsbHkgaGVyZVxuLy8gd2hpY2ggaXMgY29vbCBhbmQgbWVhbnMgd2Ugd29uJ3QgbmVlZCB0aGlzIGF0IGFsbCBzb29uLlxuLy8gU28gZm9yIG5vdyB3ZSdsbCBzdGljayB3aXRoIGRpZmYgdG8gcHJldmVudCBhbnkgd2VpcmRuZXNzIHdpdGhcbi8vIGNvbW1pdCBiZWluZyBwcml2YXRlIGFuZCBhbGwuXG5jb25zdCBjb21taXROYW1lID0gXCJkaWZmZWRcIjtcblxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdIGFzICh2bm9kZTogVk5vZGUsIGNvbW1pdFF1ZXVlOiBDb21wb25lbnRbXSkgPT4gdm9pZDtcbmNvbnN0IG5ld0NvbW1pdDogdHlwZW9mIG9yaWdpbmFsQ29tbWl0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZWZmZWN0SW5mb10gb2YgdG9SdW4pIHtcbiAgICAgICAgY29uc3Qgb2xkSW5wdXRzID0gcHJldmlvdXNJbnB1dHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKG9sZElucHV0cywgZWZmZWN0SW5mby5pbnB1dHMpKSB7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXA/LigpO1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLnNldChpZCwgZWZmZWN0SW5mby5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUnVuLmNsZWFyKCk7XG4gICAgb3JpZ2luYWxDb21taXQ/LiguLi5hcmdzKTtcbn1cbm9wdGlvbnNbY29tbWl0TmFtZV0gPSBuZXdDb21taXQgYXMgbmV2ZXJcblxuLyoqXG4gKiBTZW1pLXByaXZhdGUgZnVuY3Rpb24gdG8gYWxsb3cgc3RhYmxlIGNhbGxiYWNrcyBldmVuIHdpdGhpbiBgdXNlTGF5b3V0RWZmZWN0YCBhbmQgcmVmIGFzc2lnbm1lbnQuXG4gKiBcbiAqIEV2ZXJ5IHJlbmRlciwgd2Ugc2VuZCB0aGUgYXJndW1lbnRzIHRvIGJlIGV2YWx1YXRlZCBhZnRlciBkaWZmaW5nIGhhcyBjb21wbGV0ZWQsXG4gKiB3aGljaCBoYXBwZW5zIGJlZm9yZS5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgaW5wdXRzPzogSW5wdXRzKSB7XG5cbiAgICAvKigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSB1c2VSZWY8dm9pZCB8ICgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpO1xuICAgICAgICBjb25zdCBwcmV2QXJnc1JlZiA9IHVzZVJlZjxJbnB1dHM+KG51bGwhKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKGlucHV0cywgcHJldkFyZ3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIHByZXZBcmdzUmVmLmN1cnJlbnQgPSBpbnB1dHMhO1xuICAgICAgICAgICAgaWYgKGNsZWFudXAuY3VycmVudClcbiAgICAgICAgICAgICAgICBjbGVhbnVwLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCA9IGVmZmVjdCgpO1xuICAgICAgICB9XG4gICAgfSkoKTsqL1xuXG4gICAgY29uc3QgW2lkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoKSk7XG4gICAgdG9SdW4uc2V0KGlkLCB7IGVmZmVjdCwgaW5wdXRzLCBjbGVhbnVwOiBudWxsIH0pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfSwgW2lkXSlcbn1cblxuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncz86IElucHV0cywgbmV3QXJncz86IElucHV0cyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIShcbiAgICAgICAgIW9sZEFyZ3MgfHxcbiAgICAgICAgb2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3M/Lmxlbmd0aCB8fFxuICAgICAgICBuZXdBcmdzPy5zb21lKChhcmcsIGluZGV4KSA9PiBhcmcgIT09IG9sZEFyZ3NbaW5kZXhdKVxuICAgICk7XG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUJlZm9yZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdFwiO1xuXG5jb25zdCBVbnNldCA9IFN5bWJvbChcInVuc2V0XCIpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IHZhbHVlLCByZXR1cm5zIGEgY29uc3RhbnQgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gKiBcbiAqIFRoaXMgdXNlcyBgb3B0aW9ucy5kaWZmZWRgIGluIG9yZGVyIHRvIHJ1biBiZWZvcmUgZXZlcnl0aGluZywgZXZlblxuICogcmVmIGFzc2lnbm1lbnQuIFRoaXMgbWVhbnMgdGhpcyBnZXR0ZXIgaXMgc2FmZSB0byB1c2UgYW55d2hlcmUgKioqZXhjZXB0IHRoZSByZW5kZXIgcGhhc2UqKiouXG4gKiBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlR2V0dGVyPFQ+KHZhbHVlOiBUKTogKCkgPT4gVCB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KFVuc2V0IGFzIHVua25vd24gYXMgVCk7XG4gICAgdXNlQmVmb3JlTGF5b3V0RWZmZWN0KCgpID0+IHsgcmVmLmN1cnJlbnQgPSB2YWx1ZTsgfSwgW3ZhbHVlXSk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50IGFzIHVua25vd24gPT09IFVuc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUdldHRlcigpIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlci4nKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgICB9LCBbXSlcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cblxuLyoqXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXG4gKiBzbyB0aGF0IGl0IGNhbiBiZSBleGNsdWRlZCBmcm9tIHRoZSBkZXBlbmRlbmN5IGFycmF5cyBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcy5cbiAqIFxuICogRG8gbm90IHVzZSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSEgIGB1c2VMYXlvdXRFZmZlY3RgIGlzIGZpbmUgdGhvdWdoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlQ2FsbGJhY2s8VCBleHRlbmRzICguLi5fYXJnczogYW55W10pID0+IGFueT4oZm46IFQpOiBUIHtcbiAgICBjb25zdCBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIgPSB1c2VTdGFibGVHZXR0ZXI8VD4oZm4pO1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KTogUmV0dXJuVHlwZTxUPiA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIoKSguLi5hcmdzKTtcbiAgICB9LCBbXSkgYXMgVDtcbn0iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlQmF0Y2hlZEFuaW1hdGlvbkZyYW1lcyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcblxuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJhZGRDYWxsYmFja1wiXT4oKGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5zZXQoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKTsgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJyZW1vdmVDYWxsYmFja1wiXT4oKGNhbGxiYWNrKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LmRlbGV0ZShjYWxsYmFjayk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnRleHRJbmZvID0gdXNlUmVmPENvbnRleHRUeXBlPihudWxsISk7XG4gICAgaWYgKGNvbnRleHRJbmZvLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgY29udGV4dEluZm8uY3VycmVudCA9IHsgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrIH07XG4gICAgY29uc3QgYWxsQ2FsbGJhY2tzID0gdXNlUmVmPE1hcDxSYWZDYWxsYmFja1R5cGUsIGFueT4+KG51bGwhKTtcbiAgICBpZiAoYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gLTE7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFmV2l0aEJhdGNoZWRDYWxsYmFja3MobXNTaW5jZUxhc3Q6IG51bWJlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hlZFJhZkNhbGxiYWNrLCB0YWddIG9mIGFsbENhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlZFJhZkNhbGxiYWNrKG1zU2luY2VMYXN0LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEluZm8uY3VycmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyPilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdpdGggZWZmZWN0aXZlbHkgdGhlIHNhbWUgcnVsZXMgYXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKiBcbiAgICAgKiBEb2Vzbid0IG5lZWQgdG8gYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiBudWxsIHwgKChtc1NpbmNlTGFzdDogbnVtYmVyKSA9PiB2b2lkKTtcbn1cblxuLyoqXG4gKiBUaGUgKG9wdGlvbmFsbHkgbm9uLXN0YWJsZSkgYGNhbGxiYWNrYCB5b3UgcHJvdmlkZSB3aWxsIHN0YXJ0IHJ1bm5pbmcgZXZlcnkgZnJhbWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gKiBcbiAqIFBhc3NpbmcgYG51bGxgIGlzIGZpbmUgYW5kIHNpbXBseSBzdG9wcyB0aGUgZWZmZWN0IHVudGlsIHlvdSByZXN0YXJ0IGl0IGJ5IHByb3ZpZGluZyBhIG5vbi1udWxsIGNhbGxiYWNrLlxuICogXG4gKiAqKlRoaXMgaG9vayBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXQgYWxsLCBpbmNsdWRpbmcgbm8gcHJvcC1tb2RpZnlpbmcgaG9va3MqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQW5pbWF0aW9uRnJhbWUoeyBjYWxsYmFjayB9OiBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMpOiB2b2lkIHtcbiAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2l2ZW4gY2FsbGJhY2sgdGhhdCdzIHN0YWJsZVxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2sgPz8gbm9vcCk7XG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSAoY2FsbGJhY2sgIT0gbnVsbCk7XG5cbiAgICBjb25zdCBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSB1c2VDb250ZXh0KFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuYWRkQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LnJlbW92ZUNhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFsc28gY2FsbHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgcmFmQ2FsbGJhY2sgPSAobXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVDYWxsYmFjayhtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCwgaGFzQ2FsbGJhY2tdKVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH07XG5cblxuICAgIGNvbnNvbGUuYXNzZXJ0KHJlZi5jdXJyZW50ID09PSBzdGF0ZSB8fCAodHlwZW9mIHN0YXRlID09PSBcIm51bWJlclwiICYmIGlzTmFOKHN0YXRlKSkpO1xuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiaW1wb3J0IHsgSW5wdXRzLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0TmF0aXZlLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG4vKipcclxuICogV3JhcCB0aGUgbmF0aXZlIGB1c2VFZmZlY3RgIHRvIGFkZCBhcmd1bWVudHMgXHJcbiAqIHRoYXQgYWxsb3cgYWNjZXNzaW5nIHRoZSBwcmV2aW91cyB2YWx1ZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXHJcbiAqIGFzIHdlbGwgYXMgdGhlIGNoYW5nZXMgdGhhdCBjYXVzZWQgdGhlIGhvb2sgdG8gYmUgY2FsbGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXHJcbiAqIFxyXG4gKiBAcGFyYW0gZWZmZWN0IFxyXG4gKiBAcGFyYW0gaW5wdXRzIFxyXG4gKiBAcGFyYW0gaW1wbCBZb3UgY2FuIGNob29zZSB3aGV0aGVyIHRvIHVzZSBgdXNlRWZmZWN0YCBvciBgdXNlTGF5b3V0RWZmZWN0YCBieVxyXG4gKiBwYXNzaW5nIG9uZSBvZiB0aGVtIGFzIHRoaXMgYXJndW1lbnQuIEJ5IGRlZmF1bHQsIGl0J3MgYHVzZUVmZmVjdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlRWZmZWN0PEkgZXh0ZW5kcyBJbnB1dHM+KGVmZmVjdDogKHByZXY6IEkgfCB1bmRlZmluZWQsIGNoYW5nZXM6IEVmZmVjdENoYW5nZTxJLCBudW1iZXI+W10pID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSwgaW5wdXRzPzogSSwgaW1wbCA9IHVzZUVmZmVjdE5hdGl2ZSkge1xyXG5cclxuICAgIGNvbnN0IHByZXZJbnB1dHMgPSB1c2VSZWY8dW5kZWZpbmVkIHwgST4odW5kZWZpbmVkKTtcclxuICAgIGNvbnN0IGVmZmVjdDIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlczogeyBmcm9tOiBhbnksIHRvOiBhbnkgfVtdID0gW107XHJcbiAgICAgICAgaWYgKGlucHV0cyAmJiBwcmV2SW5wdXRzLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heChwcmV2SW5wdXRzLmN1cnJlbnQubGVuZ3RoLCBpbnB1dHMubGVuZ3RoKTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldklucHV0cy5jdXJyZW50W2ldICE9IGlucHV0c1tpXSlcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzW2ldID0geyBmcm9tOiBwcmV2SW5wdXRzLmN1cnJlbnRbaV0sIHRvOiBpbnB1dHNbaV0gfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJldCA9IGVmZmVjdChwcmV2SW5wdXRzLmN1cnJlbnQsIGNoYW5nZXMpO1xyXG4gICAgICAgIHByZXZJbnB1dHMuY3VycmVudCA9IGlucHV0cztcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfTtcclxuXHJcbiAgICBpbXBsKGVmZmVjdDIsIGlucHV0cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRWZmZWN0Q2hhbmdlPEkgZXh0ZW5kcyBJbnB1dHMsIE4gZXh0ZW5kcyBudW1iZXI+IHsgZnJvbTogSVtOXSwgdG86IElbTl0gfVxyXG4iLCJpbXBvcnQgeyBJbnB1dHMsIHVzZUxheW91dEVmZmVjdCBhcyB1c2VMYXlvdXRFZmZlY3ROYXRpdmUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFZmZlY3RDaGFuZ2UsIHVzZUVmZmVjdCB9IGZyb20gXCIuL3VzZS1lZmZlY3RcIjtcblxuLyoqXG4gKiBXcmFwIHRoZSBuYXRpdmUgYHVzZUxheW91dEVmZmVjdGAgdG8gYWRkIGFyZ3VtZW50cyBcbiAqIHRoYXQgYWxsb3cgYWNjZXNzaW5nIHRoZSBwcmV2aW91cyB2YWx1ZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhcyB3ZWxsIGFzIHRoZSBjaGFuZ2VzIHRoYXQgY2F1c2VkIHRoZSBob29rIHRvIGJlIGNhbGxlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICogXG4gKiBAcGFyYW0gZWZmZWN0IFxuICogQHBhcmFtIGlucHV0cyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdDxJIGV4dGVuZHMgSW5wdXRzPihlZmZlY3Q6IChwcmV2OiBJIHwgdW5kZWZpbmVkLCBjaGFuZ2VzOiBFZmZlY3RDaGFuZ2U8SSwgbnVtYmVyPltdKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSksIGlucHV0cz86IEkpIHtcbiAgICByZXR1cm4gdXNlRWZmZWN0KGVmZmVjdCwgaW5wdXRzLCB1c2VMYXlvdXRFZmZlY3ROYXRpdmUpO1xufVxuIiwiaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuLyoqXG4gKiBSZW1pbmRlciBvZiBvcmRlciBvZiBleGVjdXRpb246XG4gKiBcbiAqICogKHRyZWUgbW91bnRzKVxuICogKiBQYXJlbnQgcmVuZGVyc1xuICogKiBDaGlsZHJlbiByZW5kZXJcbiAqICogQ2hpbGRyZW4gcmVjZWl2ZSByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIFBhcmVudCByZWNlaXZlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdHNcbiAqIFxuICogKiAodHJlZSB1bm1vdW50cylcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogUGFyZW50IGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIENoaWxkIGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcbiAqICogUmVuZGVyaW5nIHN0YXJ0cyBhdCB0aGUgcm9vdCwgIGJ1dCBlZmZlY3RzIGFuZCByZWZzIHN0YXJ0IGF0IHRoZSBsZWF2ZXMuXG4gKiAqIHJlZnMgYXJlICp1c3VhbGx5KiBjYWxsZWQgYmVmb3JlIGVmZmVjdHMsIGJ1dCBvbmx5IHdoZW4gdGhhdCBIVE1MRWxlbWVudCByZW5kZXJzLiBCYXNpY2FsbHkganVzdCBhIHJlbWluZGVyIHRoYXQgYSBjb21wb25lbnQgY2FuIGJlIG1vdW50ZWQgd2l0aG91dCBpdCBleGlzdGluZyBpbiB0aGUgRE9NLlxuICovXG5jb25zdCBfY29tbWVudHMgPSB2b2lkICgwKTtcblxuXG4vKipcbiAqIEluZm9ybWF0aW9uIHRoYXQgY2hpbGRyZW4gYW5kIHBhcmVudHMgdXNlIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cbiAqIFxuICogKiBgaW5kZXhgIHJlZmVycyB0byB3aGljaCBjaGlsZCB0aGlzIGlzLlxuICogKiBgZmxhZ3NgIGFyZSBxdWljay1hbmQtZWFzeSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgeW91IGNhbiBvcHRpb25hbGx5IHVzZVxuICogKiBgc3ViSW5mb2AgaXMgYW55dGhpbmcgdXNlZCBieSBhIGRlcml2ZWQgaG9vay4gYHVzZVJvdmluZ1RhYkluZGV4YCwgZm9yIGV4YW1wbGUsIG5lZWRzIHRvIGtub3cgaG93IHRvIGZvY3VzIGFuIGFyYml0cmFyeSBjaGlsZCwgc28gdGhlIGNoaWxkIHBvcHVsYXRlcyBgaW5mb2Agd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyBhIG1ldGhvZCBjYWxsZWQgYGZvY3VzU2VsZmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkSW5mbzxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgaW5kZXg6IFQ7XG4gICAgZmxhZ3M/OiBQYXJ0aWFsPFJlY29yZDxLLCBDaGlsZEZsYWdPcGVyYXRpb25zPj47XG4gICAgc3ViSW5mbzogQztcbn1cblxuXG5cbmV4cG9ydCB0eXBlIE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgobW91bnRlZDogU2V0PFQ+LCB1bm1vdW50ZWQ6IFNldDxUPikgPT4gdm9pZCk7XG5leHBvcnQgdHlwZSBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKGNhdXNlcnM6IEl0ZXJhYmxlPFQ+KSA9PiB2b2lkKTtcblxuaW50ZXJmYWNlIE1DUDxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nPiB7XG4gICAgLyoqXG4gICAgICogUnVucyBhZnRlciBvbmUgb3IgbW9yZSBjaGlsZHJlbiBoYXZlIHVwZGF0ZWQgdGhlaXIgaW5mb3JtYXRpb24gKGluZGV4LCBldGMuKS5cbiAgICAgKiBcbiAgICAgKiBPbmx5IG9uZSB3aWxsIHJ1biBwZXIgdGljaywganVzdCBsaWtlIGxheW91dEVmZmVjdCwgYnV0IGl0IGlzbid0XG4gICAgICogKmd1YXJhbnRlZWQqIHRvIGhhdmUgYWN0dWFsbHkgYmVlbiBhIGNoYW5nZS5cbiAgICAgKi9cbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PFQ+O1xuXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyB0aGUgYWJvdmUsIGJ1dCBvbmx5IGZvciBtb3VudC91bm1vdW50IChvciB3aGVuIGEgY2hpbGQgY2hhbmdlcyBpdHMgaW5kZXgpXG4gICAgICovXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxUPjtcbn1cblxuZXhwb3J0IHR5cGUgTWFuYWdlZENoaWxkcmVuT21pdHMgPSBrZXlvZiBNQ1A8YW55PjtcbmV4cG9ydCB0eXBlIE1hbmFnZWRDaGlsZE9taXRzID0ga2V5b2YgTWFuYWdlZENoaWxkSW5mbzxhbnksIGFueSwgYW55PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIE9taXRzIGV4dGVuZHMga2V5b2YgTUNQPFQ+PiB7XG4gICAgbWFuYWdlZENoaWxkcmVuOiBPbWl0PE1DUDxUPiwgT21pdHM+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgQywgSyBleHRlbmRzIHN0cmluZywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzPiB7XG4gICAgbWFuYWdlZENoaWxkOiBPbWl0PE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz4sIE1jT21pdHM+O1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgQywgSyBleHRlbmRzIHN0cmluZz4ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNoaWxkIHRoYXQgcmVuZGVyZWQgaXRzZWxmIHdpdGggdGhlIHJlcXVlc3RlZCBrZXkuXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKiAoZXZlbiB0aG91Z2ggaXQncyBub3QgYSBmdW5jdGlvbiwgdGhlIGlkZW50aXR5IG9mIHRoaXMgb2JqZWN0IG5ldmVyIGNoYW5nZXMpXG4gICAgICovXG4gICAgbWFuYWdlZENoaWxkcmVuOiB7XG4gICAgICAgIGNoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48VCwgQywgSz47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxULCBDLCBLPiB7XG4gICAgLyoqXG4gICAgICogQSBob29rIHRoYXQgbXVzdCBiZSBjYWxsZWQgYnkgZXZlcnkgY2hpbGQgY29tcG9uZW50IHRoYXRcbiAgICAgKiBpcyB0byBiZSBtYW5hZ2VkIGJ5IHRoaXMgb25lLiBUaGUgYXJndW1lbnQgdG8gdGhlIGhvb2tcbiAgICAgKiBpcyBqdXN0IHRoZSBiYWcgb2YgcHJvcGVydGllcyB0byBwYXNzIHRvIHRoZSBwYXJlbnQsXG4gICAgICogaW5jbHVkaW5nIHRoZSBjaGlsZCdzIGluZGV4LlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICB1c2VNYW5hZ2VkQ2hpbGQ6IFVzZU1hbmFnZWRDaGlsZDxULCBDLCBLPjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZSA9IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIFVzZU1hbmFnZWRDaGlsZDxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPFQsIEMsIEssIG5ldmVyPikgPT4gVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTtcblxuXG5cblxuXG5cbi8qKlxuICogQWJzdHJhY3Rpb24gb3ZlciB0aGUgbWFuYWdlZCBjaGlsZHJlblxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZHJlbjxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGdldEF0KGluZGV4OiBUKTogTWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPiB8IHVuZGVmaW5lZDtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0SGlnaGVzdEluZGV4KCk6IG51bWJlcjtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZm9yRWFjaDogKGY6IChjaGlsZDogTWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPikgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAgIC8qKiAqKlVOU1RBQkxFKiosIGFsc28gaW50ZXJuYWwtdXNlIG9ubHksIGFsc28gVE9ETyBuZWVkIGEgd29ya2Fyb3VuZCBmb3IgdGhpcyBmb3Igc29ydGFibGUgY2hpbGRyZW4gKi9cbiAgICBhcnJheVNsaWNlOiAoKSA9PiBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+W107XG59XG5cblxuXG5cbi8vZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxJIGV4dGVuZHMge30+ID0geyBpbmZvOiBJIH07XG5cbi8qKlxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxuICogY2hpbGQgY29tcG9uZW50cyBvbmNlIHRoZXkgaGF2ZSByZW5kZXJlZC5cbiAqIFxuICogVGhpcyBob29rIGlzIGRlc2lnbmVkIHRvIGJlIGxpZ2h0d2VpZ2h0LCBpbiB0aGF0IHRoZSBwYXJlbnQga2VlcHMgbm8gc3RhdGVcbiAqIGFuZCBydW5zIG5vIGVmZmVjdHMuICBFYWNoIGNoaWxkICpkb2VzKiBydW4gYW4gZWZmZWN0LCBidXQgd2l0aCBubyBzdGF0ZVxuICogY2hhbmdlcyB1bmxlc3MgeW91IGV4cGxpY2l0bHkgcmVxdWVzdCB0aGVtLlxuICogXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hbmFnZWRDaGlsZHJlbjxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPihwYXJlbnRQYXJhbWV0ZXJzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFQsIG5ldmVyPik6IFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8VCwgQywgSz4ge1xuICAgIC8vdHlwZSBJID0gSTMgJiBNYW5hZ2VkQ2hpbGRJbmZvQmFzZTxzdHJpbmcgfCBudW1iZXI+O1xuICAgIHR5cGUgSW5mbyA9IE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz47XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH0gPSBwYXJlbnRQYXJhbWV0ZXJzO1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTWFuYWdlZENoaWxkcmVuXCIsIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlKTtcblxuICAgIGNvbnN0IGdldEhpZ2hlc3RJbmRleCA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xuICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXg7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gQWxsIHRoZSBpbmZvcm1hdGlvbiB3ZSBoYXZlIGFib3V0IG91ciBjaGlsZHJlbiBpcyBzdG9yZWQgaW4gdGhpcyAqKnN0YWJsZSoqIGFycmF5LlxuICAgIC8vIEFueSBtdXRhdGlvbnMgdG8gdGhpcyBhcnJheSAqKkRPIE5PVCoqIHRyaWdnZXIgYW55IHNvcnQgb2YgYSByZS1yZW5kZXIuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuQXJyYXkgPSB1c2VSZWY8eyBhcnI6IEFycmF5PEluZm8+OyByZWM6IFBhcnRpYWw8UmVjb3JkPFQsIEluZm8+PjsgaGlnaGVzdEluZGV4OiBudW1iZXIsIGxvd2VzdEluZGV4OiBudW1iZXIgfT4oeyBhcnI6IFtdLCByZWM6IHt9LCBoaWdoZXN0SW5kZXg6IDAsIGxvd2VzdEluZGV4OiAwIH0pO1xuXG4gICAgLy8gRm9yIGluZGlyZWN0IGFjY2VzcyB0byBlYWNoIGNoaWxkXG4gICAgLy8gQ29tcGFyZSBnZXRNYW5hZ2VkQ2hpbGRJbmZvXG4gICAgLy8gVE9ETzogVGhlIHByaW1hcnkgdXNlIGZvciB0aGlzIGlzIGZsYWdnYWJsZSBjbG9zZXN0IGZpdHNcbiAgICAvLyB3aGljaCBuZWVkIHRvIHNlYXJjaCBhbGwgY2hpbGRyZW4gZm9yIHRoYXQgY2xvc2VzdCBmaXQuXG4gICAgLy8gSXQgd291bGQgYmUgbmljZSBpZiB0aGVyZSB3YXMgc29tZXRoaW5nIGJldHRlciBmb3IgdGhhdC5cbiAgICBjb25zdCBmb3JFYWNoQ2hpbGQgPSB1c2VDYWxsYmFjaygoZjogKGNoaWxkOiBJbmZvKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIpIHsgZihjaGlsZCk7IH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlYykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQ6IEluZm8gfCB1bmRlZmluZWQgPSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tmaWVsZCBhcyBrZXlvZiBSZWNvcmQ8VCwgSW5mbz5dO1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICAvLyBSZXRyaWV2ZXMgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hpbGQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgLy8gYHVuZGVmaW5lZGAgaWYgbm90IGNoaWxkIHRoZXJlLCBvciBpdCdzIHVubW91bnRlZC5cbiAgICBjb25zdCBnZXRNYW5hZ2VkQ2hpbGRJbmZvID0gdXNlQ2FsbGJhY2s8TWFuYWdlZENoaWxkcmVuPFQsIEMsIEs+W1wiZ2V0QXRcIl0+KChpbmRleDogVCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5kZXggYXMgbnVtYmVyXSE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tpbmRleCBhcyBUXSE7XG4gICAgfSwgW10pXG5cbiAgICAvLyB0bDtkciB0aGlzIGlzIGEgd2F5IHRvIGhhdmUgcnVuIHVzZUxheW91dEVmZmVjdCBvbmNlIGFmdGVyIGFsbCBOIGNoaWxkcmVuXG4gICAgLy8gaGF2ZSBtb3VudGVkIGFuZCBydW4gKnRoZWlyKiB1c2VMYXlvdXRFZmZlY3QsIGJ1dCBhbHNvICp3aXRob3V0KiByZS1yZW5kZXJpbmdcbiAgICAvLyBvdXJzZWx2ZXMgYmVjYXVzZSBvZiBoYXZpbmcgYSBgY2hpbGRDb3VudGAgc3RhdGUgb3IgYW55dGhpbmcgc2ltaWxhci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIGNoaWxkIGNvdW50IHJlZiB1cGRhdGVzLCB3ZSB3YW50IHRoZSBwYXJlbnQgdG8gYWxzbyBydW4gYW4gZWZmZWN0XG4gICAgLy8gdG8gbWF5YmUgZG8gc29tZXRoaW5nIHdpdGggYWxsIHRoZXNlIGNoaWxkcmVuIHRoYXQganVzdCBtb3VudGVkLlxuICAgIC8vIFRoZSBlYXNpZXN0IHdheSB3b3VsZCBiZSB1c2VFZmZlY3QoLi4uLCBbY2hpbGRDb3VudF0pIGJ1dFxuICAgIC8vIHRoYXQgd291bGQgcmVxdWlyZSB1cyBoYXZpbmcgYSBjaGlsZENvdW50IHN0YXRlLCB0aGVuIGNhbGxpbmdcbiAgICAvLyBzZXRDaGlsZENvdW50IGFuZCByZS1yZW5kZXJpbmcgZXZlcnkgdGltZSBjaGlsZHJlbiBtb3VudFxuICAgIC8vIChvbmx5IG9uZSByZS1yZW5kZXIgYXQgYSB0aW1lIHVubGVzcyBjaGlsZHJlbiBhcmUgc3RhZ2dlcmVkLCBidXQgc3RpbGwpXG4gICAgLy8gXG4gICAgLy8gQXMgYW4gYWx0ZXJuYXRlIHNvbHV0aW9uLCBhbnkgdGltZSBhIGNoaWxkIHVzZXMgVUxFIG9uIG1vdW50LCBpdCBxdWV1ZXMgYSBtaWNyb3Rhc2tcbiAgICAvLyB0byBlbXVsYXRlIHJ1bm5pbmcgVUxFIG9uIHRoZSBwYXJlbnQuIE9ubHkgdGhlIGZpcnN0IGNoaWxkIHdpbGwgYWN0dWFsbHkgcXVldWVcbiAgICAvLyB0aGUgbWljcm90YXNrIChieSBjaGVja2luZyBoYXNSZW1vdGVVTEUgZmlyc3QpIHNvIHRoYXQgdGhlIFwiZWZmZWN0XCIgb25seVxuICAgIC8vIHJ1bnMgb25jZS4gV2hlbiBpdCdzIGRvbmUsIGhhc1JlbW90ZVVMRSBpcyByZXNldCBzbyBpdCBjYW4gcnVuIGFnYWluIGlmXG4gICAgLy8gbW9yZSBjaGlsZHJlbiBtb3VudC91bm1vdW50LlxuICAgIGNvbnN0IGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZCA9IHVzZVJlZjx7IG1vdW50czogU2V0PFQ+LCB1bm1vdW50czogU2V0PFQ+IH0gfCBudWxsPihudWxsKTtcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzID0gdXNlUmVmKG5ldyBTZXQ8VD4oKSk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBUKSA9PiB7XG5cbiAgICAgICAgaWYgKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5zaXplID09IDApIHtcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/LihyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuYWRkKGluZGV4KTtcblxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBULCBtb3VudGVkOiBib29sZWFuKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICghaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIG1vdW50czogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIHVubW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50IS5tb3VudHMsIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50IS51bm1vdW50cylcbiAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCA9IE1hdGgubWF4KG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4LCBpbmRleCBhcyBudW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl07XG4gICAgICAgICAgICAgICAgbGV0IHNoYXZlID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2hhdmUgPD0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoICYmIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW21hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDEgLSBzaGF2ZV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgKytzaGF2ZTtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zcGxpY2UobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMSAtIHNoYXZlLCBzaGF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIFRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnRbbW91bnRlZCA/IFwibW91bnRzXCIgOiBcInVubW91bnRzXCJdLmFkZChpbmRleCk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG5cbiAgICBjb25zdCB1c2VNYW5hZ2VkQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VNYW5hZ2VkQ2hpbGQ8VCwgQywgSz4+KCh7IG1hbmFnZWRDaGlsZDogaW5mbywgfSkgPT4ge1xuICAgICAgICAvLyBBbnkgdGltZSBvdXIgY2hpbGQgcHJvcHMgY2hhbmdlLCBtYWtlIHRoYXQgaW5mb3JtYXRpb24gYXZhaWxhYmxlXG4gICAgICAgIC8vIHRoZSBwYXJlbnQgaWYgdGhleSBuZWVkIGl0LlxuICAgICAgICAvLyBUaGUgcGFyZW50IGNhbiBsaXN0ZW4gZm9yIGFsbCB1cGRhdGVzIGFuZCBvbmx5IGFjdCBvbiB0aGUgb25lcyBpdCBjYXJlcyBhYm91dCxcbiAgICAgICAgLy8gYW5kIG11bHRpcGxlIGNoaWxkcmVuIHVwZGF0aW5nIGluIHRoZSBzYW1lIHRpY2sgd2lsbCBhbGwgYmUgc2VudCBhdCBvbmNlLlxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoaXMgaW5mb3JtYXRpb24gaW4tcGxhY2VcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5mby5pbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZm8uaW5kZXggYXMgbnVtYmVyXSA9IHsgaW5kZXg6IGluZm8uaW5kZXgsIGZsYWdzOiBpbmZvLmZsYWdzID8/IHt9LCBzdWJJbmZvOiBpbmZvLnN1YkluZm8gfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tpbmZvLmluZGV4IGFzIFRdID0geyBpbmRleDogaW5mby5pbmRleCwgZmxhZ3M6IGluZm8uZmxhZ3MgPz8ge30sIHN1YkluZm86IGluZm8uc3ViSW5mbyB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZChpbmZvLmluZGV4IGFzIFQpO1xuICAgICAgICB9LCBbLi4uT2JqZWN0LmVudHJpZXMoaW5mbykuZmxhdCg5KV0pOyAgLy8gOSBpcyBpbmZpbml0eSwgcmlnaHQ/IFN1cmUuIFVucmVsYXRlZDogVE9ETy5cblxuICAgICAgICAvLyBXaGVuIHdlIG1vdW50LCBub3RpZnkgdGhlIHBhcmVudCB2aWEgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgLy8gKGV2ZXJ5IGNoaWxkIGRvZXMgdGhpcywgc28gZXZlcnl0aGluZydzIGNvb3JkaW5hdGVkIHRvIG9ubHkgcXVldWUgYSBzaW5nbGUgbWljcm90YXNrIHBlciB0aWNrKVxuICAgICAgICAvLyBEbyB0aGUgc2FtZSBvbiB1bm1vdW50LlxuICAgICAgICAvLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgY29tZXMgQUZURVIgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkXG4gICAgICAgIC8vIHNvIHRoYXQgcmVtb3RlVUxFQ2hpbGRNb3VudGVkIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSBpbmZvIG9uIG1vdW50LlxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5mby5pbmRleCBhcyBULCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmZvLmluZGV4IGFzIFQsIGZhbHNlKTtcbiAgICAgICAgfSwgW2luZm8uaW5kZXhdKTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbiA9IHVzZVJlZjxNYW5hZ2VkQ2hpbGRyZW48VCwgQywgSz4+KHtcbiAgICAgICAgLi4ueyBfOiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50IH0gYXMge30sXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZCxcbiAgICAgICAgZ2V0QXQ6IGdldE1hbmFnZWRDaGlsZEluZm8sXG4gICAgICAgIGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdEluZGV4LFxuICAgICAgICBhcnJheVNsaWNlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTWFuYWdlZENoaWxkLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW46IG1hbmFnZWRDaGlsZHJlbi5jdXJyZW50IH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIGNoaWxkIGlzIGNvbnNpZGVyZWQgYWN0aXZlIG9uIG1vdW50LlxuICAgICAqIFxuICAgICAqIEFmdGVyIG1vdW50LCBjaGFuZ2UgdGhlIGN1cnJlbnQgYWN0aXZlIGNoaWxkIHdpdGggYGNoYW5nZUluZGV4YC5cbiAgICAgKi9cbiAgICBpbml0aWFsSW5kZXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHByb3ZpZGVkLCBpZiB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXggZG9lc24ndCBtYXAgb250byBhbnlcbiAgICAgKiBwcm92aWRlZCBjaGlsZCAoZWl0aGVyIGJlY2F1c2UgaXQncyB0b28gbGFyZ2Ugb3IgdGhhdCBjaGlsZFxuICAgICAqIGRvZXNuJ3QgZXhpc3QpLCB0aGUgY2xvc2VzdCBjaGlsZCB0byB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXhcbiAgICAgKiB3aWxsIGhhdmUgaXRzIGZsYWcgc2V0IGluc3RlYWQuXG4gICAgICogXG4gICAgICogVXNlIHdpdGggY2F1dGlvbiwgYW5kIGNvbnNpZGVyIGhvdyBhIGNoaWxkIGhhdmluZyBpdHMgZmxhZyBzZXRcbiAgICAgKiB3aGlsZSB0aGUgcGFyZW50IHRoaW5rcyBpdCBzaG91bGRuJ3QgYmUgY291bGQgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICAgIC8vY2xvc2VzdEZpdD86IGJvb2xlYW47XG4gICAgY2xvc2VzdEZpdDogYm9vbGVhbjtcblxuICAgIGNoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmRleCBpcyBzZWxlY3RlZC5cbiAgICAgKiBcbiAgICAgKiBOb3RhYmx5LCB0aGUgdmFsdWUgY2FuIGJlIGRpZmZlcmVudCB0aGFuIHdoYXQgd2FzIGNhbGxlZCB3aXRoIGNoYW5nZUluZGV4KClcbiAgICAgKiBpZiB0aGUgcmVxdWVzdGVkIGluZGV4IGRpZG4ndCBleGlzdCBvciB3YXMgaGlkZGVuLlxuICAgICAqL1xuICAgIG9uSW5kZXhDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxudW1iZXIgfCBudWxsPjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2hpbGRyZW4gaGF2ZSBtdWx0aXBsZSBmbGFncywgdGhlIGBrZXlgIHBhcmFtZXRlciBjb250cm9scyB3aGljaCBmbGFnIHdlJ3JlIGNoZWNraW5nLlxuICAgICAqIFxuICAgICAqIFRoaXMgY2FuIGJlIGFueXRoaW5nIHlvdSB3YW50LCBidXQgbXVzdCBub3QgY2hhbmdlLlxuICAgICAqL1xuICAgIGtleTogSztcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkRmxhZ09wZXJhdGlvbnMge1xuXG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4gd2hldGhlciB0aGUgY3VycmVudCBjaGlsZCBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBnZXQ6ICgpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGNoaWxkIG11c3Qgc2V0IGl0c2VsZiBhcyBhY3RpdmUvaW5hY3RpdmUsIHdoYXRldmVyIHRoYXQgZW50YWlscy5cbiAgICAgKiBUaGlzIGNvdWxkIGJlIGFzIHNpbXBsZSBhcyBhIHNldFN0YXRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHNldDogKGFjdGl2ZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB0cnVlIGlmIHRoaXMgY2hpbGQgaXMgYSB2YWxpZCBjYW5kaWRhdGUgdG8gYmUgZmxhZ2dlZCwgYW5kIGZhbHNlIGlmIG5vdC5cbiAgICAgKiBNb3N0IGNoaWxkcmVuIHNob3VsZCByZXR1cm4gdHJ1ZS4gUmV0dXJuaW5nIGZhbHNlIGlzIG9ubHkgdXNlZnVsIHRvIG1hcmsgYSBjaGlsZCBhcyBcImludmFsaWRcIiBpbiBzb21lIHdheS5cbiAgICAgKiBSZW1vdmluZyBhIGNoaWxkIGZyb20gdGhlIGxpc3QgZG9lcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZywgYnV0IHRoaXMgbGV0cyB5b3Uga2VlcCB0aGUgY2hpbGQgYXJvdW5kLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKTogYm9vbGVhbjtcbn1cblxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgRmxhZ2dhYmxlQ2hpbGRJbmZvQjxLIGV4dGVuZHMgc3RyaW5nPiB7IGZsYWdzOiBQYXJ0aWFsPFJlY29yZDxLLCBDaGlsZEZsYWdPcGVyYXRpb25zPj4gfSBcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGUge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgY2hhbmdlSW5kZXg6IChhcmc6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSkgPT4gbnVtYmVyIHwgbnVsbDtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxuICAgICAqICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBudW1iZXIgfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB1c2VNYW5hZ2VkQ2hpbGRyZW4gdGhhdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY29tbW9uIGNhc2U6XG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXG4gKiAzLiBUaGUgcGFyZW50IGhhcyBjb250cm9sIG92ZXIgd2hvIGlzIFwic2VsZWN0ZWRcIiB2aWEgYSBudW1lcmljYWwgaW5kZXguXG4gKiBcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cbiAqIFxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxuICogXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGNoaWxkcmVuLCBpbml0aWFsSW5kZXgsIGNsb3Nlc3RGaXQsIG9uSW5kZXhDaGFuZ2UsIGtleSB9OiBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPEMsIEs+KTogVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZSB7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlQ2hpbGRyZW5GbGFnXCIsIG9uSW5kZXhDaGFuZ2UsIGtleSk7XG5cbiAgICBjb25zdCBbZ2V0Q3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBudW1iZXI+KG9uSW5kZXhDaGFuZ2UsIHVzZUNhbGxiYWNrKCgpID0+IChpbml0aWFsSW5kZXggPz8gKG51bGwpKSwgW10pKTtcblxuICAgIGNvbnN0IFtnZXRSZXF1ZXN0ZWRJbmRleCwgc2V0UmVxdWVzdGVkSW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBudW1iZXI+KG51bGwsIHVzZUNhbGxiYWNrKCgpID0+IChpbml0aWFsSW5kZXggPz8gKG51bGwpKSwgW10pKTtcblxuICAgIC8vICAgIGNvbnN0IGdldEZpdE51bGxUb1plcm8gPSB1c2VTdGFibGVHZXR0ZXIoZml0TnVsbFRvWmVybyk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgYW5kIGNoYW5nZUluZGV4LCBub3QgcHVibGljIChidXQgY291bGQgYmUgSSBndWVzcylcbiAgICBjb25zdCBnZXRDbG9zZXN0Rml0ID0gdXNlQ2FsbGJhY2soKHJlcXVlc3RlZEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBsZXQgY2xvc2VzdEluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZC5mbGFncz8uW2tleV0/LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rpc3RhbmNlID0gTWF0aC5hYnMoY2hpbGQuaW5kZXggLSByZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlIHx8IChuZXdEaXN0YW5jZSA9PSBjbG9zZXN0RGlzdGFuY2UgJiYgY2hpbGQuaW5kZXggPCByZXF1ZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGNoaWxkLmluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9zZXN0SW5kZXg7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSEgKi9dKTtcblxuICAgIC8vIEFueSB0aW1lIGEgY2hpbGQgbW91bnRzL3VubW91bnRzLCB3ZSBuZWVkIHRvIGRvdWJsZS1jaGVjayB0byBzZWUgaWYgdGhhdCBhZmZlY3RzIFxuICAgIC8vIHRoZSBcImN1cnJlbnRseSBzZWxlY3RlZFwiIChvciB3aGF0ZXZlcikgaW5kZXguICBUaGUgdHdvIGNhc2VzIHdlJ3JlIGxvb2tpbmcgZm9yOlxuICAgIC8vIDEuIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2hpbGQgdW5tb3VudGVkXG4gICAgLy8gMi4gQSBjaGlsZCBtb3VudGVkLCBhbmQgaXQgbW91bnRzIHdpdGggdGhlIGluZGV4IHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAgY29uc3QgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gZ2V0UmVxdWVzdGVkSW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ICE9IG51bGwgJiYgY2xvc2VzdEZpdCAmJiAocmVxdWVzdGVkSW5kZXggIT0gY3VycmVudEluZGV4IHx8IGN1cnJlbnRDaGlsZCA9PSBudWxsIHx8ICFjdXJyZW50Q2hpbGQuZmxhZ3M/LltrZXldPy5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICBjdXJyZW50Q2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCk7XG4gICAgICAgICAgICBpZiAoY2xvc2VzdEZpdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0Q2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChjbG9zZXN0Rml0Q2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0Rml0Q2hpbGQuZmxhZ3M/LltrZXldIS5zZXQodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4gICAgY29uc3QgY2hhbmdlSW5kZXggPSB1c2VDYWxsYmFjaygoYXJnOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0pID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSBhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyhnZXRSZXF1ZXN0ZWRJbmRleCgpKSA6IGFyZztcbiAgICAgICAgLy9pZiAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCAmJiBnZXRGaXROdWxsVG9aZXJvKCkpXG4gICAgICAgIC8vICAgIHJlcXVlc3RlZEluZGV4ID0gMDtcblxuICAgICAgICBzZXRSZXF1ZXN0ZWRJbmRleChyZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xuICAgICAgICBpZiAoY3VycmVudEluZGV4ID09IHJlcXVlc3RlZEluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuXG4gICAgICAgIGxldCBuZXdNYXRjaGluZ0NoaWxkID0gKHJlcXVlc3RlZEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQocmVxdWVzdGVkSW5kZXgpKTtcbiAgICAgICAgY29uc3Qgb2xkTWF0Y2hpbmdDaGlsZCA9IChjdXJyZW50SW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChjdXJyZW50SW5kZXgpKTtcbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEVhc3kgY2FzZVxuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KG51bGwpO1xuICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobmV3TWF0Y2hpbmdDaGlsZCAmJiBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzPy5ba2V5XSEuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgbmV3TWF0Y2hpbmdDaGlsZC5mbGFncz8uW2tleV0hLnNldCh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdEZpdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF0Y2hpbmdDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChuZXdNYXRjaGluZ0NoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XG4gICAgICAgICAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF0Y2hpbmdDaGlsZC5mbGFncz8uW2tleV0hLnNldCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3RGaXRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGluaXRpYWxJbmRleCAhPSBudWxsKVxuICAgICAgICAgICAgY2hpbGRyZW4uZ2V0QXQoaW5pdGlhbEluZGV4KT8uZmxhZ3M/LltrZXldPy5zZXQodHJ1ZSk7XG4gICAgfSwgW10pXG5cbiAgICByZXR1cm4geyBjaGFuZ2VJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQsIGdldEN1cnJlbnRJbmRleCB9O1xufVxuXG5cblxuLypleHBvcnQgdHlwZSBTcHJlYWQ8QSBleHRlbmRzIHt9LCBCIGV4dGVuZHMge30+ID0gT21pdDxBLCBrZXlvZiBCPiAmIEI7XG5leHBvcnQgZnVuY3Rpb24gc3ByZWFkPEEgZXh0ZW5kcyB7fSwgQiBleHRlbmRzIHt9PihhOiBBLCBiOiBCKTogU3ByZWFkPEEsIEI+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5hLFxuICAgICAgICAuLi5iXG4gICAgfVxufSovXG5cbi8qXG5mdW5jdGlvbiB0ZXN0KCkge1xuICAgIHR5cGUgQyA9IHsgZm9vOiBcImJhclwiIH07XG4gICAgdHlwZSBLID0gXCJmbGFnMlwiO1xuXG4gICAgY29uc3QgeyBjaGlsZHJlbiwgdXNlTWFuYWdlZENoaWxkIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPih7IG1hbmFnZWRDaGlsZHJlbjogeyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobW91bnRlZCwgdW5tb3VudGVkKSA9PiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UobW91bnRlZCwgdW5tb3VudGVkKSkgfSB9KTtcbiAgICB1c2VNYW5hZ2VkQ2hpbGQoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXg6IDAsIGluZm86IHsgZm9vOiBcImJhclwiIH0sIGZsYWdzOiB7ICB9IH0gfSk7XG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleCwgZ2V0Q3VycmVudEluZGV4LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSA9IHVzZUNoaWxkcmVuRmxhZzxDLCBLPih7IGNoaWxkcmVuLCBpbml0aWFsSW5kZXg6IDAsIGtleTogXCJmbGFnMlwiIH0pXG59Ki9cbiIsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREb2N1bWVudChlbGVtZW50PzogTm9kZSkgeyByZXR1cm4gKGVsZW1lbnQ/Lm93bmVyRG9jdW1lbnQgPz8gZG9jdW1lbnQgPz8gd2luZG93LmRvY3VtZW50ID8/IGdsb2JhbFRoaXMuZG9jdW1lbnQpOyB9XG5cbnR5cGUgUCA9IFBhcmFtZXRlcnM8dHlwZW9mIGNsc3g+O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlRG9jdW1lbnRDbGFzcyhjbGFzc05hbWU6IFBbMF0sIGFjdGl2ZT86IGJvb2xlYW4sIGVsZW1lbnQ/OiBIVE1MRWxlbWVudCkge1xuICAgIGVsZW1lbnQgPz89IGdldERvY3VtZW50KCkuZG9jdW1lbnRFbGVtZW50O1xuICAgIGNsYXNzTmFtZSA9IGNsc3goY2xhc3NOYW1lKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUgYXMgc3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZWxlbWVudCEuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUgYXMgc3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSwgW2NsYXNzTmFtZSwgYWN0aXZlLCBlbGVtZW50XSk7XG5cbn1cbiIsImltcG9ydCB7IGgsIFByZWFjdERPTUF0dHJpYnV0ZXMgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHVzZWQgdG8gc2VsZWN0ICpqdXN0KiB0aGUgdHlwZWQgYWRkRXZlbnRMaXN0ZW5lciBcclxuICogYW5kIG5vdCB0aGUgZ2VuZXJpYyBcIkknbGwgYWNjZXB0IGFueSBzdHJpbmcgYW5kIGFueSBoYW5kbGVyXCIgb25lLlxyXG4gKiBcclxuICogVE9ETzogVGhpcyBcIlwiXCJ3b3Jrc1wiXCJcIiBidXQgaXQncyBub3QgZ3JlYXQgYW5kIGltcGxpY2l0bHkgcmVsaWVzIG9uXHJcbiAqIGxpYi5kb20udHMgYWx3YXlzIGdpdmVpbmcgdGhlIHR3byBvdmVybG9hZHMgaW4gdGhlIHNhbWUgb3JkZXIsIHdpdGggdGhlXHJcbiAqIHR5cGVkIG9uZSBmaXJzdC4gKlRoYXQqIHByb2JhYmx5IHdvbid0IGNoYW5nZSwgYnV0IGlmIG1vcmUgb3ZlcmxvYWRzXHJcbiAqIGFyZSBldmVyIGFkZGVkIHRoaXMgd2lsbCBuZWVkIGFkanVzdG1lbnQuXHJcbiAqIFxyXG4gKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUyNzYxMTU2IGZvciBob3cgc2VsZWN0aW5nIHRoZSBjb3JyZWN0IG92ZXJsb2FkIHdvcmtzLlxyXG4gKi9cclxudHlwZSBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczxUPiA9XHJcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGluZmVyIFIgfSA/IFIgOlxyXG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55IH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxyXG4gICAgVCBleHRlbmRzICguLi5hcmdzOiBpbmZlciBSKSA9PiBhbnkgPyBSIDogW107XHJcblxyXG4vLyBHZXQganVzdCB0aGUgdHlwZWQgdmVyc2lvbiBvZiBhZGRFdmVudExpc3RlbmVyLCBpZiBpdCBleGlzdHNcclxudHlwZSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9ICguLi5hcmdzOiBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczwoVFtcImFkZEV2ZW50TGlzdGVuZXJcIl0pPikgPT4gdm9pZDtcclxuXHJcbi8vIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIFwiYWRkRXZlbnRMaXN0ZW5lclwiICh0aGUgZXZlbnQgdHlwZSBhcyBhIHN0cmluZylcclxudHlwZSBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+IGV4dGVuZHMgKCh0eXBlOiBpbmZlciBLMiwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBLMiA6IHN0cmluZztcclxuXHJcblxyXG4vLyBUT0RPOiBUaGlzIGlzbid0IHF1aXRlIGFibGUgdG8gbmFycm93IGRvd24gdGhlIGV4YWN0IGV2ZW50IHR5cGUgZm9yIHVua25vd24gcmVhc29ucy5cclxuLy8gSW5zdGVhZCBpdCByZXR1cm5zIGEgdW5pb24gb2YgYWxsIGF2YWlsYWJsZSBldmVudCB0eXBlcywgd2hpY2ggaXMuLi5maW5lLCBJIGd1ZXNzLlxyXG4vLyBJIGRvbid0IGtub3cgd2h5IGBpbmZlciBIYCBpcyBkb2luZyB0aGF0IHdoZW4gdGhlIHR5cGUgc2hvdWxkIGJlIG5hcnJvd2VkIGJ5IGBUYCB0aG91Z2guLi5cclxuLy8gTm90ZSB0aGF0IHRoZSB0eXBlIHBhcmFtZXRlciBpcyBzdGlsbCB1c2VkLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IG5hcnJvdyBkb3duIHRoZSB0eXBlLFxyXG4vLyBiZWNhdXNlIG90aGVyd2lzZSwgaW5zdGVhZCBvZiBiZWluZyBhIHVuaW9uIG9mIGFsbCB0eXBlcywgaXQncyBqdXN0IGBhbnlgXHJcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXI8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+IGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiBpbmZlciBILCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IE5vbk51bGxhYmxlPEg+IDogbmV2ZXI7XHJcbi8vKChUeXBlZEFkZEV2ZW50TGlzdGVuZXI8RT4gJiAoKHR5cGU6IFQsIGhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZCwgLi4uYXJnczogYW55W10pID0+IGFueSkpIGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogaW5mZXIgSCkgPT4gYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IEggOiBGdW5jdGlvbikgLyomIChUIGV4dGVuZHMga2V5b2YgR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwPyBHbG9iYWxFdmVudEhhbmRsZXJzRXZlbnRNYXBbVF0gOiAoZTogRXZlbnQpID0+IHZvaWQpKi87XHJcblxyXG50eXBlIFBhcmFtZXRlcnMyPFQgZXh0ZW5kcyAoRXZlbnRMaXN0ZW5lck9iamVjdCB8ICgoLi4uYXJnczogYW55KSA9PiBhbnkpKT4gPVxyXG4gICAgVCBleHRlbmRzIEV2ZW50TGlzdGVuZXJPYmplY3QgPyBQYXJhbWV0ZXJzPFRbXCJoYW5kbGVFdmVudFwiXT4gOlxyXG4gICAgVCBleHRlbmRzICguLi5hcmdzOiBpbmZlciBQKSA9PiBhbnkgPyBQIDogbmV2ZXI7XHJcblxyXG5cclxudHlwZSBUeXBlZEV2ZW50SGFuZGxlckV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVCBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPEU+PiA9IFBhcmFtZXRlcnMyPFR5cGVkRXZlbnRIYW5kbGVyPEUsIFQ+PlswXTtcclxuXHJcblxyXG4vKipcclxuICogQWxsb3dzIGF0dGFjaGluZyBhbiBldmVudCBoYW5kbGVyIHRvIGFueSAqbm9uLVByZWFjdCogZWxlbWVudCwgYW5kIHJlbW92aW5nIGl0IHdoZW4gdGhlIGNvbXBvbmVudCB1c2luZyB0aGUgaG9vayB1bm1vdW50cy4gVGhlIGNhbGxiYWNrIGRvZXMgbm90IG5lZWQgdG8gYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxyXG4gKiBcclxuICogRHVlIHRvIHR5cGluZyBsaW1pdGF0aW9ucywgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBsaWtlIHRoaXM6XHJcbiAqIFxyXG4gKiBgdXNlRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiaW5wdXRcIik8SW5wdXRFdmVudD4oZSA9PiB7fSlgXHJcbiAqIFxyXG4gKiBUaGUgdHlwZSBhcmd1bWVudCBpcyBvcHRpb25hbCwgYnV0IG5hcnJvd3MgZG93biB0aGUgdHlwZSBmcm9tIFwiYSB1bmlvbiBvZiBhbGwgZXZlbnRzXCIgdG8gd2hhdGV2ZXIgeW91IHNwZWNpZnksIGFuZCBlcnJvcnMgaWYgaXQgZG9lc24ndCBleGlzdC5cclxuICogXHJcbiAqIFRoZXJlIGlzIGEgc2VwYXJhdGUgdmVyc2lvbiB0aGF0IGF0dGFjaGVzIGV2ZW50IGhhbmRsZXJzIHRvIGEgc2V0IG9mIHByb3BzLiBcclxuICogSXQgdGFrZXMgZGlmZmVyZW50IGV2ZW50IHN0cmluZyB0eXBlcyAob25FdmVudCB2cyBvbmV2ZW50KS5cclxuICogXHJcbiAqIEBwYXJhbSB0YXJnZXQgQSAqbm9uLVByZWFjdCogbm9kZSB0byBhdHRhY2ggdGhlIGV2ZW50IHRvLlxyXG4gKiBAcmV0dXJuc1xyXG4gKiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlcjxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcclxuXHJcbiAgICAvLyBOb3RlIHRvIHNlbGY6IFRoZSB0eXBpbmcgZG9lc24ndCBpbXByb3ZlIGV2ZW4gaWYgdGhpcyBpcyBzcGxpdCB1cCBpbnRvIGEgc3ViLWZ1bmN0aW9uLlxyXG4gICAgLy8gTm8gbWF0dGVyIHdoYXQsIGl0IHNlZW1zIGltcG9zc2libGUgdG8gZ2V0IHRoZSBoYW5kbGVyJ3MgZXZlbnQgb2JqZWN0IHR5cGVkIHBlcmZlY3RseS5cclxuICAgIC8vIEl0IHNlZW1zIGxpa2UgaXQncyBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgdHVwZXMuXHJcbiAgICAvLyBBZ2Fpbiwgbm8gbWF0dGVyIHdoYXQgY29tYmluYXRpb24gb2Ygc3ViLSBvciBzdWItc3ViLWZ1bmN0aW9ucyB1c2VkLlxyXG5cclxuICAgIGxldCBzdGFibGVIYW5kbGVyOiBFdmVudExpc3RlbmVyIHwgbnVsbCA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIgPz8gKCgpID0+IHsgfSkpIGFzIEV2ZW50TGlzdGVuZXI7XHJcbiAgICBpZiAoaGFuZGxlciA9PSBudWxsKVxyXG4gICAgICAgIHN0YWJsZUhhbmRsZXIgPSBudWxsO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3RhcmdldCwgdHlwZSwgc3RhYmxlSGFuZGxlcl0pO1xyXG59XHJcblxyXG4vKipcclxuICogQW4gYWx0ZXJuYXRpdmUgd2F5IHRvIGFkZCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIGVsZW1lbnQuIFVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpbnRlZ3JhdGluZyAzcmQgcGFydHkgbGlicmFyaWVzIHRoYXQgZXhwZWN0IGEgZ2VuZXJpYyBcImFkZCBldmVudCBoYW5kbGVyXCIgZnVuY3Rpb24uXHJcbiAqIFxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgeW91IHRvIG1vZGlmeSBhIHNldCBvZiBwcm9wcyB0byBhcHBseSB0aGlzIGhhbmRsZXIuXHJcbiAqIFxyXG4gKiBGb3IgdHlwaW5nIHJlYXNvbnMsIHRoaXMgZnVuY3Rpb24gaXMgc3BsaXQgaW50byB0d28uICBVc2FnZSBpcyBsaWtlIHRoZSBmb2xsb3dpbmc6XHJcbiAqIFxyXG4gKiBgYGBcclxuICogY29uc3QgeyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH0gPSB1c2VMb2NhbEV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4oKShcIm9uTW91c2VEb3duXCIsIGUgPT4geyAgfSk7XHJcbiAqIGNvbnN0IGRpdlByb3BzID0gdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyhwcm9wcyk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvY2FsSGFuZGxlcjxFbGVtZW50VHlwZSBleHRlbmRzIChIVE1MRWxlbWVudFRhZ05hbWVNYXBba2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwXSB8IFNWR0VsZW1lbnRUYWdOYW1lTWFwW2tleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwXSk+KCkge1xyXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKDxFdmVudFR5cGUgZXh0ZW5kcyBFeGNsdWRlPGtleW9mIGguSlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+LCBrZXlvZiBQcmVhY3RET01BdHRyaWJ1dGVzPj4odHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBOb25OdWxsYWJsZTxoLkpTWC5ET01BdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPltFdmVudFR5cGVdPikgPT4ge1xyXG5cclxuICAgICAgICBjb25zdCBzdGFibGVIYW5kbGVyID0gdXNlU3RhYmxlQ2FsbGJhY2soaGFuZGxlcik7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RWxlbWVudFR5cGU+KHsgW3R5cGVdOiBzdGFibGVIYW5kbGVyIH0gYXMgeyBbSyBpbiBFdmVudFR5cGVdOiB0eXBlb2YgaGFuZGxlciB9LCBwcm9wcykgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+O1xyXG4gICAgICAgIH0sIFt0eXBlXSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgfTtcclxuXHJcbiAgICB9LCBbXSk7XHJcbn1cclxuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdpbmVydCcsIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gICAqIChodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsLzIwMTUvY29weXJpZ2h0LXNvZnR3YXJlLWFuZC1kb2N1bWVudCkuXG4gICAqL1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIHdlJ3JlIG5vdCBydW5uaW5nIGluc2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBOb2RlTGlzdHMuXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICAgKiBAdHlwZSB7dHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXN9XG4gICAgICovXG4gICAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdmFyIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZyA9IFsnYVtocmVmXScsICdhcmVhW2hyZWZdJywgJ2lucHV0Om5vdChbZGlzYWJsZWRdKScsICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJywgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKScsICdidXR0b246bm90KFtkaXNhYmxlZF0pJywgJ2RldGFpbHMnLCAnc3VtbWFyeScsICdpZnJhbWUnLCAnb2JqZWN0JywgJ2VtYmVkJywgJ1tjb250ZW50ZWRpdGFibGVdJ10uam9pbignLCcpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Um9vdGAgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBzdWJ0cmVlLCBpLmUuIGEgRE9NIHN1YnRyZWUgd2hvc2Ugcm9vdCBlbGVtZW50IGhhcyBhbiBgaW5lcnRgXG4gICAgICogYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogSXRzIG1haW4gZnVuY3Rpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgICAqICAgc3VidHJlZS4gVGhlIGBtYWtlU3VidHJlZVVuZm9jdXNhYmxlKClgIG1ldGhvZCBoYW5kbGVzIGNvbGxlY3RpbmcgYEluZXJ0Tm9kZWBzIHZpYSByZWdpc3RlcmluZ1xuICAgICAqICAgZWFjaCBmb2N1c2FibGUgbm9kZSBpbiB0aGUgc3VidHJlZSB3aXRoIHRoZSBzaW5nbGV0b24gYEluZXJ0TWFuYWdlcmAgd2hpY2ggbWFuYWdlcyBhbGwga25vd25cbiAgICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgICAqICAgaW5zdGFuY2UgZXhpc3RzIGZvciBlYWNoIGZvY3VzYWJsZSBub2RlIHdoaWNoIGhhcyBhdCBsZWFzdCBvbmUgaW5lcnQgcm9vdCBhcyBhbiBhbmNlc3Rvci5cbiAgICAgKlxuICAgICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAgICogICBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSByb290IG5vZGUpLiBUaGlzIGlzIGhhbmRsZWQgaW4gdGhlIGRlc3RydWN0b3IsIHdoaWNoIGNhbGxzIHRoZVxuICAgICAqICAgYGRlcmVnaXN0ZXJgIG1ldGhvZCBvbiBgSW5lcnRNYW5hZ2VyYCBmb3IgZWFjaCBtYW5hZ2VkIGluZXJ0IG5vZGUuXG4gICAgICovXG5cbiAgICB2YXIgSW5lcnRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRNYW5hZ2VyfSBpbmVydE1hbmFnZXIgVGhlIGdsb2JhbCBzaW5nbGV0b24gSW5lcnRNYW5hZ2VyIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Um9vdCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydE5vZGU+fVxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBmb2N1c2FibGUgbm9kZXMgaW4gdGhpcyBJbmVydFJvb3QncyBzdWJ0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIE1ha2UgdGhlIHN1YnRyZWUgaGlkZGVuIGZyb20gYXNzaXN0aXZlIHRlY2hub2xvZ3lcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSB0aGlzLl9yb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICAvLyBNYWtlIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIHN1YnRyZWUgdW5mb2N1c2FibGUgYW5kIGFkZCB0aGVtIHRvIF9tYW5hZ2VkTm9kZXNcbiAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSh0aGlzLl9yb290RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgICAvLyAtIGFueSBhZGRpdGlvbnMgaW4gdGhlIHN1YnRyZWU6IG1ha2UgdGhlbSB1bmZvY3VzYWJsZSB0b29cbiAgICAgICAgLy8gLSBhbnkgcmVtb3ZhbHMgZnJvbSB0aGUgc3VidHJlZTogcmVtb3ZlIHRoZW0gZnJvbSB0aGlzIGluZXJ0IHJvb3QncyBtYW5hZ2VkIG5vZGVzXG4gICAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgICAvLyAgIGVsZW1lbnQsIG1ha2UgdGhhdCBub2RlIGEgbWFuYWdlZCBub2RlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29uTXV0YXRpb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAgICogc3RvcmVkIGluIHRoaXMgb2JqZWN0IGFuZCB1cGRhdGVzIHRoZSBzdGF0ZSBvZiBhbGwgb2YgdGhlIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBOb3RlIHdlIGNhc3QgdGhlIG51bGxzIHRvIHRoZSBBTlkgdHlwZSBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAgIC8vICAgIG5lZWQgZXZlbiBtb3JlIGNhc3RzIHRocm91Z2hvdXQgdGhpcyBjb2RlLiBBbGwgYmV0cyBhcmUgb2ZmIGlmIGFuXG4gICAgICAgICAgLy8gICAgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkIGFuZCBhIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgICAgLy8gICAgdG8ga25vdyB3aGljaCBwcm9wZXJ0aWVzIHdlJ3JlIHNldHRpbmcuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4geyFTZXQ8IUluZXJ0Tm9kZT59IEEgY29weSBvZiB0aGlzIEluZXJ0Um9vdCdzIG1hbmFnZWQgbm9kZXMgc2V0LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBzdGFydE5vZGUgbWF5IGJlIGluIHNoYWRvdyBET00sIHNvIGZpbmQgaXRzIG5lYXJlc3Qgc2hhZG93Um9vdCB0byBnZXQgdGhlIGFjdGl2ZUVsZW1lbnQuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R9ICovbm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0Tm9kZS5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgICAvLyBjYWxsaW5nIGJsdXIoKSB3aWxsIG5vdCBhY3R1YWxseSBtb3ZlIHRoZSBmb2N1cy5cbiAgICAgICAgICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMgd2UgY2FsbCBmb2N1cygpIG9uIHRoZSBib2R5IGluc3RlYWQuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmlzaXROb2RlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuXG4gICAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAgIC8vIHRoaXMgaW5lcnQgcm9vdCwgc28gYWxsIG9mIGl0cyBtYW5hZ2VkIG5vZGVzIG5lZWQgdG8gYmUgYWRvcHRlZCBieSB0aGlzIEluZXJ0Um9vdC5cbiAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIucmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmFkZChpbmVydE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShpbmVydE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBlbnRpcmUgc3VidHJlZSBzdGFydGluZyBhdCBgc3RhcnROb2RlYC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlU3VidHJlZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fdW5tYW5hZ2VOb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgZGVzY2VuZGFudCBub2RlIGlzIGZvdW5kIHdpdGggYW4gYGluZXJ0YCBhdHRyaWJ1dGUsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fkb3B0SW5lcnRSb290KG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcblxuICAgICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgICAgLy8gc28gcmVnaXN0ZXIgaXQgbm93IGlmIG5lZWQgYmUuXG4gICAgICAgICAgaWYgKCFpbmVydFN1YnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShzYXZlZEluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBzdWJ0cmVlIGFkZGl0aW9ucywgcmVtb3ZhbHMsIG9yIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uTXV0YXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uTXV0YXRpb24ocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAvLyBVbi1tYW5hZ2UgcmVtb3ZlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5yZW1vdmVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlLWluaXRpYWxpc2UgaW5lcnQgbm9kZSBpZiB0YWJpbmRleCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZSh0YXJnZXQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbmV3IGluZXJ0IHJvb3QgaXMgYWRkZWQsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzIGFuZCBtYWtlIHN1cmUgaXQga25vd3MgYWJvdXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBtYW5hZ2VkIG5vZGVzIGZyb20gdGhpcyBpbmVydCBzdWJyb290LlxuICAgICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRTdWJyb290Ll9tYW5hZ2VOb2RlKG1hbmFnZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5fbWFuYWdlZE5vZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/c3RyaW5nfSBhcmlhSGlkZGVuICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXJpYUhpZGRlbikge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IGFyaWFIaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydFJvb3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Tm9kZWAgaW5pdGlhbGlzZXMgYW5kIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgbm9kZS5cbiAgICAgKiBBIG5vZGUgaXMgaW5lcnQgaWYgaXQgaXMgYSBkZXNjZW5kYW50IG9mIG9uZSBvciBtb3JlIGluZXJ0IHJvb3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBPbiBjb25zdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHNhdmVzIHRoZSBleGlzdGluZyBgdGFiaW5kZXhgIHZhbHVlIGZvciB0aGUgbm9kZSwgaWYgYW55LCBhbmRcbiAgICAgKiBlaXRoZXIgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgb3Igc2V0cyBpdCB0byBgLTFgLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZWxlbWVudFxuICAgICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIGBJbmVydE5vZGVgIG1haW50YWlucyBhIHNldCBvZiBgSW5lcnRSb290YHMgd2hpY2ggYXJlIGRlc2NlbmRhbnRzIG9mIHRoaXMgYEluZXJ0Tm9kZWAuIFdoZW4gYW5cbiAgICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICAgKiBgSW5lcnROb2RlYCB2aWEgYHJlbW92ZUluZXJ0Um9vdCgpYCwgd2hpY2ggaW4gdHVybiBkZXN0cm95cyB0aGUgYEluZXJ0Tm9kZWAgaWYgbm8gYEluZXJ0Um9vdGBzXG4gICAgICogcmVtYWluIGluIHRoZSBzZXQuIE9uIGRlc3RydWN0aW9uLCBgSW5lcnROb2RlYCByZWluc3RhdGVzIHRoZSBzdG9yZWQgYHRhYmluZGV4YCBpZiBvbmUgZXhpc3RzLFxuICAgICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIEEgZm9jdXNhYmxlIGVsZW1lbnQgdG8gYmUgbWFkZSBpbmVydC5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290IFRoZSBpbmVydCByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5lcnQgbm9kZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnROb2RlKTtcblxuICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Um9vdD59IFRoZSBzZXQgb2YgZGVzY2VuZGFudCBpbmVydCByb290cy5cbiAgICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgU2V0KFtpbmVydFJvb3RdKTtcblxuICAgICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2F2ZSBhbnkgcHJpb3IgdGFiaW5kZXggaW5mbyBhbmQgbWFrZSB0aGlzIG5vZGUgdW50YWJiYWJsZVxuICAgICAgICB0aGlzLmVuc3VyZVVudGFiYmFibGUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLlxuICAgICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Tm9kZSwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMuX25vZGU7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYGRlbGV0ZWAgdG8gcmVzdG9yZSBuYXRpdmUgZm9jdXMgbWV0aG9kLlxuICAgICAgICAgICAgaWYgKHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgICB0aGlzLl9ub2RlID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQsIGFueSBhdHRlbXB0IHRvIGFjY2VzcyBpdCB3aWxsIGNhdXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Rocm93SWZEZXN0cm95ZWQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Rocm93SWZEZXN0cm95ZWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgICAgLyoqIFNhdmUgdGhlIGV4aXN0aW5nIHRhYmluZGV4IHZhbHVlIGFuZCBtYWtlIHRoZSBub2RlIHVudGFiYmFibGUgYW5kIHVuZm9jdXNhYmxlICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmVVbnRhYmJhYmxlKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSkge1xuICAgICAgICAgICAgaWYgKCAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4ID09PSAtMSAmJiB0aGlzLmhhc1NhdmVkVGFiSW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbm90aGVyIGluZXJ0IHJvb3QgdG8gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdhZGRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLmFkZChpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBmcm9tIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICAgKiBzbyB0aGUgb2JqZWN0IHNob3VsZCBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3llZCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHshSW5lcnROb2RlfSAqL3RoaXMuX2Rlc3Ryb3llZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ25vZGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/bnVtYmVyfSB0YWJJbmRleCAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YWJJbmRleCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P251bWJlcn0gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBXaGVuIGFuIGVsZW1lbnQgYmVjb21lcyBhbiBpbmVydCByb290IGJ5IGhhdmluZyBhbiBgaW5lcnRgIGF0dHJpYnV0ZSBzZXQgYW5kL29yIGl0cyBgaW5lcnRgXG4gICAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICAgKiBUaGUgYEluZXJ0Um9vdGAgaW4gdHVybiByZWdpc3RlcnMgaXRzZWxmIGFzIG1hbmFnaW5nIGFsbCBvZiB0aGUgZWxlbWVudCdzIGZvY3VzYWJsZSBkZXNjZW5kYW50XG4gICAgICogbm9kZXMgdmlhIHRoZSBgcmVnaXN0ZXIoKWAgbWV0aG9kLiBUaGUgYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgIGluc3RhbmNlXG4gICAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshRG9jdW1lbnR9IGRvY3VtZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRNYW5hZ2VyKTtcblxuICAgICAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHshRG9jdW1lbnR9ICovXG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIG5vZGVzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIGluZXJ0IHJvb3RzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnRSb290Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICAgKiBAdHlwZSB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gQWRkIGluZXJ0IHN0eWxlLlxuICAgICAgICBhZGRJbmVydFN0eWxlKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRvY3VtZW50TG9hZGVkLmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZCBiZSBhbiBpbmVydCByb290IG9yIG5vdC5cbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluZXJ0XG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAgICBrZXk6ICdzZXRJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbmVydChyb290LCBpbmVydCkge1xuICAgICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBpbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmVydFJvb3QgPSBuZXcgSW5lcnRSb290KHJvb3QsIHRoaXMpO1xuICAgICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290cy5zZXQocm9vdCwgaW5lcnRSb290KTtcbiAgICAgICAgICAgIC8vIElmIG5vdCBjb250YWluZWQgaW4gdGhlIGRvY3VtZW50LCBpdCBtdXN0IGJlIGluIGEgc2hhZG93Um9vdC5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHJvb3QpKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgYWRkSW5lcnRTdHlsZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgICAgX2luZXJ0Um9vdC5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShyb290KTtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIEluZXJ0Um9vdCBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBlbGVtZW50LCBpZiBhbnkuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmVydFJvb3QoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbmVydFJvb3RzLmdldChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBub2RlLlxuICAgICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgICAqIGJlIGFkZGVkIHRvIGl0cyBzZXQgb2YgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Tm9kZX0gaW5lcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbm9kZSB3YXMgYWxyZWFkeSBpbiBhbiBpbmVydCBzdWJ0cmVlXG4gICAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZXJ0Tm9kZSA9IG5ldyBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuc2V0KG5vZGUsIGluZXJ0Tm9kZSk7XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlLXJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIGluZXJ0IG5vZGUuXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICAgKiBub2RlIGZyb20gdGhlIEluZXJ0TWFuYWdlcidzIHNldCBvZiBtYW5hZ2VkIG5vZGVzIGlmIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICogSWYgdGhlIG5vZGUgaXMgbm90IGN1cnJlbnRseSBtYW5hZ2VkLCB0aGlzIGlzIGVzc2VudGlhbGx5IGEgbm8tb3AuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7P0luZXJ0Tm9kZX0gVGhlIHBvdGVudGlhbGx5IGRlc3Ryb3llZCBJbmVydE5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgaWYgYW55LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXJlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKCFpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0Tm9kZS5yZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9jdW1lbnRMb2FkZWQoKSB7XG4gICAgICAgICAgLy8gRmluZCBhbGwgaW5lcnQgcm9vdHMgaW4gZG9jdW1lbnQgYW5kIG1ha2UgdGhlbSBhY3R1YWxseSBpbmVydC5cbiAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gQ29tbWVudCB0aGlzIG91dCB0byB1c2UgcHJvZ3JhbW1hdGljIEFQSSBvbmx5LlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZG9jdW1lbnQuYm9keSB8fCB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgc3VidHJlZTogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3dhdGNoRm9ySW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhdGNoRm9ySW5lcnQocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0ID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRJbmVydCh0YXJnZXQsIGluZXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRNYW5hZ2VyO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHdhbGsgdGhlIGNvbXBvc2VkIHRyZWUgZnJvbSB8bm9kZXwuXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uICghSFRNTEVsZW1lbnQpKT19IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50IHRyYXZlcnNlZCxcbiAgICAgKiAgICAgYmVmb3JlIGRlc2NlbmRpbmcgaW50byBjaGlsZCBub2Rlcy5cbiAgICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY29tcG9zZWRUcmVlV2Fsayhub2RlLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVzY2VuZCBpbnRvIG5vZGU6XG4gICAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgICAvLyB1cCBieSB0aGUgPGNvbnRlbnQ+IG9yIDxzaGFkb3c+IGVsZW1lbnRzLiBEZXNjZW5kIHN0cmFpZ2h0IGludG8gdGhlXG4gICAgICAgIC8vIFNoYWRvd1Jvb3QuXG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc2hhZG93Um9vdCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBkaXN0cmlidXRlZCBlbGVtZW50cyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnY29udGVudCcpIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmaWVzIGlmIFNoYWRvd0RvbSB2MCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIGRpc3RyaWJ1dGVkTm9kZXMgPSBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMgPyBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhkaXN0cmlidXRlZE5vZGVzW2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8c2xvdD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGFzc2lnbmVkIG5vZGVzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdzbG90Jykge1xuICAgICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZ5IGlmIFNoYWRvd0RvbSB2MSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIF9kaXN0cmlidXRlZE5vZGVzID0gc2xvdC5hc3NpZ25lZE5vZGVzID8gc2xvdC5hc3NpZ25lZE5vZGVzKHsgZmxhdHRlbjogdHJ1ZSB9KSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoX2Rpc3RyaWJ1dGVkTm9kZXNbX2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgICAvLyBlbGVtZW50LCBub3IgYSA8c2hhZG93PiBlbGVtZW50IHJlY3Vyc2Ugbm9ybWFsbHkuXG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGNoaWxkLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgICBpZiAobm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZSNpbmVydC1zdHlsZSwgbGluayNpbmVydC1zdHlsZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2luZXJ0LXN0eWxlJyk7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG5cbiAgICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgdmFyIGluZXJ0TWFuYWdlciA9IG5ldyBJbmVydE1hbmFnZXIoZG9jdW1lbnQpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmVydCkge1xuICAgICAgICAgIGluZXJ0TWFuYWdlci5zZXRJbmVydCh0aGlzLCBpbmVydCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSkoKTtcblxufSkpKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogYEJsb2NraW5nRWxlbWVudHNgIG1hbmFnZXMgYSBzdGFjayBvZiBlbGVtZW50cyB0aGF0IGluZXJ0IHRoZSBpbnRlcmFjdGlvblxuICogb3V0c2lkZSB0aGVtLiBUaGUgdG9wIGVsZW1lbnQgaXMgdGhlIGludGVyYWN0aXZlIHBhcnQgb2YgdGhlIGRvY3VtZW50LlxuICogVGhlIHN0YWNrIGNhbiBiZSB1cGRhdGVkIHdpdGggdGhlIG1ldGhvZHMgYHB1c2gsIHJlbW92ZSwgcG9wYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgLyoqXG4gICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuIFRoaXMgZW1wdGllc1xuICAgKiB0aGUgYmxvY2tpbmcgZWxlbWVudHNcbiAgICovXG4gIGRlc3RydWN0b3IoKTogdm9pZDtcblxuICAvKipcbiAgICogVGhlIHRvcCBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgdG9wOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBlbGVtZW50IHRvIHRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICovXG4gIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nIGVsZW1lbnRzLiBSZXR1cm5zIHRydWUgaWYgdGhlXG4gICAqIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHRvcCBibG9ja2luZyBlbGVtZW50IGFuZCByZXR1cm5zIGl0LlxuICAgKi9cbiAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgYSBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIGV4dGVuZHMgRG9jdW1lbnQge1xuICAkYmxvY2tpbmdFbGVtZW50czogQmxvY2tpbmdFbGVtZW50cztcbn1cblxuKCgpID0+IHtcbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBwcm9wZXJ0aWVzICovXG4gIGNvbnN0IF9ibG9ja2luZ0VsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9hbHJlYWR5SW5lcnRFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfdG9wRWxQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zaWJsaW5nc1RvUmVzdG9yZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfcGFyZW50TU8gPSBTeW1ib2woKTtcblxuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHN0YXRpYyBtZXRob2RzICovXG4gIGNvbnN0IF90b3BDaGFuZ2VkID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zd2FwSW5lcnRlZFNpYmxpbmcgPSBTeW1ib2woKTtcbiAgY29uc3QgX2luZXJ0U2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX3Jlc3RvcmVJbmVydGVkU2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4gPSBTeW1ib2woKTtcbiAgY29uc3QgX2lzSW5lcnRhYmxlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9oYW5kbGVNdXRhdGlvbnMgPSBTeW1ib2woKTtcblxuICBpbnRlcmZhY2UgSW5lcnRhYmxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGluZXJ0PzogYm9vbGVhbjtcbiAgfVxuXG4gIGludGVyZmFjZSBJbnRlcm5hbFN0YXRlIHtcbiAgICBbX3NpYmxpbmdzVG9SZXN0b3JlXTogU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT47XG4gICAgW19wYXJlbnRNT106IE11dGF0aW9uT2JzZXJ2ZXI7XG4gIH1cbiAgaW50ZXJmYWNlIEhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIEludGVybmFsU3RhdGUge31cbiAgaW50ZXJmYWNlIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgUGFydGlhbDxJbnRlcm5hbFN0YXRlPiB7fVxuXG4gIC8qKlxuICAgKiBTaGFkeURPTSBzaGFkeSByb290cyBsb29rIGEgbG90IGxpa2UgcmVhbCBTaGFkb3dSb290cy4gVGhlIF9fc2hhZHkgcHJvcGVydHlcbiAgICogZ2l2ZXMgdGhlbSBhd2F5LCB0aG91Z2guXG4gICAqL1xuICBpbnRlcmZhY2UgTWF5YmVTaGFkeVJvb3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBfX3NoYWR5OiB1bmtub3duO1xuICAgIGhvc3Q6IEVsZW1lbnQ7XG4gIH1cblxuICBjbGFzcyBCbG9ja2luZ0VsZW1lbnRzSW1wbCBpbXBsZW1lbnRzIEJsb2NraW5nRWxlbWVudHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBwcml2YXRlW19ibG9ja2luZ0VsZW1lbnRzXTogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcGFyZW50cyBvZiB0aGUgdG9wIGVsZW1lbnQsIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgKiBpdHNlbGYgdXAgdG8gYm9keS4gV2hlbiB0b3AgY2hhbmdlcywgdGhlIG9sZCB0b3AgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgKiBmcm9tIHRoZSBkb2N1bWVudCwgc28gd2UgbmVlZCB0byBtZW1vaXplIHRoZSBpbmVydGVkIHBhcmVudHMnIHNpYmxpbmdzXG4gICAgICogaW4gb3JkZXIgdG8gcmVzdG9yZSB0aGVpciBpbmVydGVuZXNzIHdoZW4gdG9wIGNoYW5nZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wRWxQYXJlbnRzXTogSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBFbGVtZW50cyB0aGF0IGFyZSBhbHJlYWR5IGluZXJ0IGJlZm9yZSB0aGUgZmlyc3QgYmxvY2tpbmcgZWxlbWVudCBpc1xuICAgICAqIHB1c2hlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBuZXcgU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT4oKTtcblxuICAgIGRlc3RydWN0b3IoKTogdm9pZCB7XG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGluZXJ0bmVzcy5cbiAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKHRoaXNbX3RvcEVsUGFyZW50c10pO1xuICAgICAgLy8gTm90ZSB3ZSBkb24ndCB3YW50IHRvIG1ha2UgdGhlc2UgcHJvcGVydGllcyBudWxsYWJsZSBvbiB0aGUgY2xhc3MsXG4gICAgICAvLyBzaW5jZSB0aGVuIHdlJ2QgbmVlZCBub24tbnVsbCBjYXN0cyBpbiBtYW55IHBsYWNlcy4gQ2FsbGluZyBhIG1ldGhvZCBvblxuICAgICAgLy8gYSBCbG9ja2luZ0VsZW1lbnRzIGluc3RhbmNlIGFmdGVyIGNhbGxpbmcgZGVzdHJ1Y3RvciB3aWxsIHJlc3VsdCBpbiBhblxuICAgICAgLy8gZXhjZXB0aW9uLlxuICAgICAgY29uc3QgbnVsbGFibGUgPSB0aGlzIGFzIHVua25vd24gYXMge1xuICAgICAgICBbX2Jsb2NraW5nRWxlbWVudHNdOiBudWxsO1xuICAgICAgICBbX3RvcEVsUGFyZW50c106IG51bGw7XG4gICAgICAgIFtfYWxyZWFkeUluZXJ0RWxlbWVudHNdOiBudWxsO1xuICAgICAgfTtcbiAgICAgIG51bGxhYmxlW19ibG9ja2luZ0VsZW1lbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfdG9wRWxQYXJlbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgdG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgZWxlbXMgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXTtcbiAgICAgIHJldHVybiBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH1cblxuICAgIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50ID09PSB0aGlzLnRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIHdlJ2xsIGJyaW5nIGl0IHRvIHRoZSB0b3AuXG4gICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICAgIHRoaXNbX3RvcENoYW5nZWRdKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnNwbGljZShpLCAxKTtcbiAgICAgIC8vIFRvcCBjaGFuZ2VkIG9ubHkgaWYgdGhlIHJlbW92ZWQgZWxlbWVudCB3YXMgdGhlIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKGkgPT09IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmxlbmd0aCkge1xuICAgICAgICB0aGlzW190b3BDaGFuZ2VkXSh0aGlzLnRvcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRvcCAmJiB0aGlzLnJlbW92ZSh0b3ApO1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGBpbmVydGAgdG8gYWxsIGRvY3VtZW50IGVsZW1lbnRzIGV4Y2VwdCB0aGUgbmV3IHRvcCBlbGVtZW50LCBpdHNcbiAgICAgKiBwYXJlbnRzLCBhbmQgaXRzIGRpc3RyaWJ1dGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wQ2hhbmdlZF0obmV3VG9wOiBNYXliZUhhc0ludGVybmFsU3RhdGV8bnVsbCk6IHZvaWQge1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBjb25zdCBvbGRQYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIC8vIE5vIG5ldyB0b3AsIHJlc2V0IG9sZCB0b3AgaWYgYW55LlxuICAgICAgaWYgKCFuZXdUb3ApIHtcbiAgICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cyk7XG4gICAgICAgIHRvS2VlcEluZXJ0LmNsZWFyKCk7XG4gICAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBbXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdQYXJlbnRzID0gdGhpc1tfZ2V0UGFyZW50c10obmV3VG9wKTtcbiAgICAgIC8vIE5ldyB0b3AgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgbWFpbiBkb2N1bWVudCFcbiAgICAgIGlmIChuZXdQYXJlbnRzW25ld1BhcmVudHMubGVuZ3RoIC0gMV0ucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm9uLWNvbm5lY3RlZCBlbGVtZW50IGNhbm5vdCBiZSBhIGJsb2NraW5nIGVsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIC8vIENhc3QgaGVyZSBiZWNhdXNlIHdlIGtub3cgd2UnbGwgY2FsbCBfaW5lcnRTaWJsaW5ncyBvbiBuZXdQYXJlbnRzXG4gICAgICAvLyBiZWxvdy5cbiAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBuZXdQYXJlbnRzIGFzIEFycmF5PEhhc0ludGVybmFsU3RhdGU+O1xuXG4gICAgICBjb25zdCB0b1NraXAgPSB0aGlzW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShuZXdUb3ApO1xuXG4gICAgICAvLyBObyBwcmV2aW91cyB0b3AgZWxlbWVudC5cbiAgICAgIGlmICghb2xkUGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cywgdG9Ta2lwLCB0b0tlZXBJbmVydCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSBvbGRQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgaiA9IG5ld1BhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIC8vIEZpbmQgY29tbW9uIHBhcmVudC4gSW5kZXggMCBpcyB0aGUgZWxlbWVudCBpdHNlbGYgKHNvIHN0b3AgYmVmb3JlIGl0KS5cbiAgICAgIHdoaWxlIChpID4gMCAmJiBqID4gMCAmJiBvbGRQYXJlbnRzW2ldID09PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgICAgLy8gSWYgdXAgdGhlIHBhcmVudHMgdHJlZSB0aGVyZSBhcmUgMiBlbGVtZW50cyB0aGF0IGFyZSBzaWJsaW5ncywgc3dhcFxuICAgICAgLy8gdGhlIGluZXJ0ZWQgc2libGluZy5cbiAgICAgIGlmIChvbGRQYXJlbnRzW2ldICE9PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIHRoaXNbX3N3YXBJbmVydGVkU2libGluZ10ob2xkUGFyZW50c1tpXSwgbmV3UGFyZW50c1tqXSk7XG4gICAgICB9XG4gICAgICAvLyBSZXN0b3JlIG9sZCBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0bmVzcy5cbiAgICAgIGkgPiAwICYmIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMuc2xpY2UoMCwgaSkpO1xuICAgICAgLy8gTWFrZSBuZXcgcGFyZW50cyBzaWJsaW5ncyBpbmVydC5cbiAgICAgIGogPiAwICYmIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMuc2xpY2UoMCwgaiksIHRvU2tpcCwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgaW5lcnRuZXNzIGJldHdlZW4gdHdvIHNpYmxpbmcgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfc3dhcEluZXJ0ZWRTaWJsaW5nXShcbiAgICAgICAgb2xkSW5lcnQ6IEhhc0ludGVybmFsU3RhdGUsIG5ld0luZXJ0OiBNYXliZUhhc0ludGVybmFsU3RhdGUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNpYmxpbmdzVG9SZXN0b3JlID0gb2xkSW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgIC8vIG9sZEluZXJ0IGlzIG5vdCBjb250YWluZWQgaW4gc2libGluZ3MgdG8gcmVzdG9yZSwgc28gd2UgaGF2ZSB0byBjaGVja1xuICAgICAgLy8gaWYgaXQncyBpbmVydGFibGUgYW5kIGlmIGFscmVhZHkgaW5lcnQuXG4gICAgICBpZiAodGhpc1tfaXNJbmVydGFibGVdKG9sZEluZXJ0KSAmJiAhb2xkSW5lcnQuaW5lcnQpIHtcbiAgICAgICAgb2xkSW5lcnQuaW5lcnQgPSB0cnVlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5hZGQob2xkSW5lcnQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbmV3SW5lcnQgd2FzIGFscmVhZHkgYmV0d2VlbiB0aGUgc2libGluZ3MgdG8gcmVzdG9yZSwgaXQgbWVhbnMgaXQgaXNcbiAgICAgIC8vIGluZXJ0YWJsZSBhbmQgbXVzdCBiZSByZXN0b3JlZC5cbiAgICAgIGlmIChzaWJsaW5nc1RvUmVzdG9yZS5oYXMobmV3SW5lcnQpKSB7XG4gICAgICAgIG5ld0luZXJ0LmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmRlbGV0ZShuZXdJbmVydCk7XG4gICAgICB9XG4gICAgICBuZXdJbmVydFtfcGFyZW50TU9dID0gb2xkSW5lcnRbX3BhcmVudE1PXTtcbiAgICAgIG5ld0luZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBzaWJsaW5nc1RvUmVzdG9yZTtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIGluZXJ0bmVzcyB0byB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKGVsZW1lbnRzOiBIYXNJbnRlcm5hbFN0YXRlW10pIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBtbyA9IGVsZW1lbnRbX3BhcmVudE1PXTtcbiAgICAgICAgbW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgICBmb3IgKGNvbnN0IHNpYmxpbmcgb2Ygc2libGluZ3MpIHtcbiAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZXJ0cyB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzIGV4Y2VwdCB0aGUgZWxlbWVudHMgdG8gc2tpcC4gU3RvcmVzXG4gICAgICogdGhlIGluZXJ0ZWQgc2libGluZ3MgaW50byB0aGUgZWxlbWVudCdzIHN5bWJvbCBgX3NpYmxpbmdzVG9SZXN0b3JlYC5cbiAgICAgKiBQYXNzIGB0b0tlZXBJbmVydGAgdG8gY29sbGVjdCB0aGUgYWxyZWFkeSBpbmVydCBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19pbmVydFNpYmxpbmdzXShcbiAgICAgICAgZWxlbWVudHM6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdLCB0b1NraXA6IFNldDxIVE1MRWxlbWVudD58bnVsbCxcbiAgICAgICAgdG9LZWVwSW5lcnQ6IFNldDxIVE1MRWxlbWVudD58bnVsbCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIC8vIEFzc3VtZSBlbGVtZW50IGlzIG5vdCBhIERvY3VtZW50LCBzbyBpdCBtdXN0IGhhdmUgYSBwYXJlbnROb2RlLlxuICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUhO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBjaGlsZHJlbltqXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgLy8gU2tpcCB0aGUgaW5wdXQgZWxlbWVudCwgaWYgbm90IGluZXJ0YWJsZSBvciB0byBiZSBza2lwcGVkLlxuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBlbGVtZW50IHx8ICF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykgfHxcbiAgICAgICAgICAgICAgKHRvU2tpcCAmJiB0b1NraXAuaGFzKHNpYmxpbmcpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNob3VsZCBiZSBjb2xsZWN0ZWQgc2luY2UgYWxyZWFkeSBpbmVydGVkLlxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIHNpYmxpbmdzIHRoYXQgd2VyZSBpbmVydGVkLlxuICAgICAgICBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBpbmVydGVkU2libGluZ3M7XG4gICAgICAgIC8vIE9ic2VydmUgb25seSBpbW1lZGlhdGUgY2hpbGRyZW4gbXV0YXRpb25zIG9uIHRoZSBwYXJlbnQuXG4gICAgICAgIGNvbnN0IG1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpc1tfaGFuZGxlTXV0YXRpb25zXS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZWxlbWVudFtfcGFyZW50TU9dID0gbW87XG4gICAgICAgIGxldCBwYXJlbnRUb09ic2VydmUgPSBwYXJlbnQ7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHRoZSBTaGFkeURPTSBwb2x5ZmlsbCwgdGhlbiBvdXIgcGFyZW50IGNvdWxkIGJlIGFcbiAgICAgICAgLy8gc2hhZHkgcm9vdCwgd2hpY2ggaXMgYW4gb2JqZWN0IHRoYXQgYWN0cyBsaWtlIGEgU2hhZG93Um9vdCwgYnV0IGlzbid0XG4gICAgICAgIC8vIGFjdHVhbGx5IGEgbm9kZSBpbiB0aGUgcmVhbCBET00uIE9ic2VydmUgdGhlIHJlYWwgRE9NIHBhcmVudCBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBtYXliZVNoYWR5Um9vdCA9IHBhcmVudFRvT2JzZXJ2ZSBhcyBNYXliZVNoYWR5Um9vdDtcbiAgICAgICAgaWYgKG1heWJlU2hhZHlSb290Ll9fc2hhZHkgJiYgbWF5YmVTaGFkeVJvb3QuaG9zdCkge1xuICAgICAgICAgIHBhcmVudFRvT2JzZXJ2ZSA9IG1heWJlU2hhZHlSb290Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbW8ub2JzZXJ2ZShwYXJlbnRUb09ic2VydmUsIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbmV3bHkgYWRkZWQvcmVtb3ZlZCBub2RlcyBieSB0b2dnbGluZyB0aGVpciBpbmVydG5lc3MuXG4gICAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIGN1cnJlbnQgdG9wIEJsb2NraW5nIEVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgKiBub3RpZnlpbmcgYW5kIHJlbW92aW5nIGl0LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2hhbmRsZU11dGF0aW9uc10obXV0YXRpb25zOiBNdXRhdGlvblJlY29yZFtdKTogdm9pZCB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHNoYWRvd1Jvb3QsIGdldCBpdHMgaG9zdCBhcyB3ZSBza2lwIHNoYWRvd1Jvb3RzIHdoZW5cbiAgICAgICAgLy8gY29tcHV0aW5nIF90b3BFbFBhcmVudHMuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IChtdXRhdGlvbi50YXJnZXQgYXMgU2hhZG93Um9vdCkuaG9zdCB8fCBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSA/XG4gICAgICAgICAgICBwYXJlbnRzLmxlbmd0aCA6XG4gICAgICAgICAgICBwYXJlbnRzLmluZGV4T2YodGFyZ2V0IGFzIEhhc0ludGVybmFsU3RhdGUpO1xuICAgICAgICBjb25zdCBpbmVydGVkQ2hpbGQgPSBwYXJlbnRzW2lkeCAtIDFdO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBpbmVydGVkQ2hpbGRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcblxuICAgICAgICAvLyBUbyByZXN0b3JlLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBpbmVydGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnRGV0ZWN0ZWQgcmVtb3ZhbCBvZiB0aGUgdG9wIEJsb2NraW5nIEVsZW1lbnQuJyk7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5lcnRlZFNpYmxpbmdzLmhhcyhzaWJsaW5nKSkge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmRlbGV0ZShzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBpbmVydC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLmFkZGVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmICghdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgaW5lcnRhYmxlLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2lzSW5lcnRhYmxlXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGZhbHNlID09PSAvXihzdHlsZXx0ZW1wbGF0ZXxzY3JpcHQpJC8udGVzdChlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBuZXdQYXJlbnRzIG9mIGFuIGVsZW1lbnQsIHN0YXJ0aW5nIGZyb20gZWxlbWVudFxuICAgICAqIChpbmNsdWRlZCkgdXAgdG8gYGRvY3VtZW50LmJvZHlgIChleGNsdWRlZCkuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0UGFyZW50c10oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBBcnJheTxIVE1MRWxlbWVudD4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnQ6IEhUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkID0gZWxlbWVudDtcbiAgICAgIC8vIFN0b3AgdG8gYm9keS5cbiAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgLy8gU2tpcCBzaGFkb3cgcm9vdHMuXG4gICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGFkb3dEb20gdjFcbiAgICAgICAgaWYgKGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gQ29sbGVjdCBzbG90cyBmcm9tIGRlZXBlc3Qgc2xvdCB0byB0b3AuXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPSBjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb250aW51ZSB0aGUgc2VhcmNoIG9uIHRoZSB0b3Agc2xvdC5cbiAgICAgICAgICBjdXJyZW50ID0gcGFyZW50cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICAgICAoY3VycmVudCBhcyBOb2RlIGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0cmlidXRlZCBjaGlsZHJlbiBvZiB0aGUgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBzaGFkb3cgcm9vdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShlbGVtZW50OiBIVE1MRWxlbWVudCk6XG4gICAgICAgIFNldDxIVE1MRWxlbWVudD58bnVsbCB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgIGxldCBpO1xuICAgICAgbGV0IGo7XG4gICAgICBsZXQgbm9kZXM7XG4gICAgICBjb25zdCBzbG90cyA9IHNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgICAgaWYgKHNsb3RzLmxlbmd0aCAmJiBzbG90c1swXS5hc3NpZ25lZE5vZGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzID0gc2xvdHNbaV0uYXNzaWduZWROb2Rlcyh7XG4gICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICByZXN1bHQuYWRkKG5vZGVzW2pdIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZWFyY2ggZm9yIDxjb250ZW50Pi5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgKGRvY3VtZW50IGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzID1cbiAgICAgIG5ldyBCbG9ja2luZ0VsZW1lbnRzSW1wbCgpO1xufSkoKTtcbiIsImltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCwgd2hlbiBjYWxsZWQsIGZvcmNlIHRoZSBjb21wb25lbnRcbiAqIHRoYXQgdXNlcyB0aGlzIGhvb2sgdG8gcmUtcmVuZGVyIGl0c2VsZi5cbiAqIFxuICogSXQncyBhIGJpdCBzbWVsbHksIHNvIGJlc3QgdG8gdXNlIHNwYXJpbmdseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICAgIGNvbnN0IFssIHNldF0gPSB1c2VTdGF0ZSgwKTtcbiAgICByZXR1cm4gdXNlUmVmKCgpID0+IHNldChpID0+ICsraSkpLmN1cnJlbnQ7XG59IiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWxlbWVudFNpemUsIHVzZUVsZW1lbnRTaXplIH0gZnJvbSBcIi4vdXNlLWVsZW1lbnQtc2l6ZVwiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xuXG4vL2V4cG9ydCB0eXBlIEJsb2NrRmxvd0RpcmVjdGlvbiA9IFwiZG93bndhcmRzXCIgfCBcImxlZnR3YXJkc1wiIHwgXCJyaWdodHdhcmRzXCI7XG5leHBvcnQgdHlwZSBQaHlzaWNhbERpcmVjdGlvbiA9IFwibHRyXCIgfCBcInJ0bFwiIHwgXCJ0dGJcIiB8IFwiYnR0XCI7XG5leHBvcnQgdHlwZSBQaHlzaWNhbE9yaWVudGF0aW9uID0gXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCI7XG5leHBvcnQgdHlwZSBQaHlzaWNhbFNpemUgPSBcIndpZHRoXCIgfCBcImhlaWdodFwiO1xuXG5leHBvcnQgdHlwZSBMb2dpY2FsT3JpZW50YXRpb24gPSBcImlubGluZVwiIHwgXCJibG9ja1wiO1xuXG4vL2V4cG9ydCB0eXBlIExpbmVPcmllbnRhdGlvbiA9IFwidXByaWdodFwiIHwgXCJsZWZ0cmlnaHRcIiB8IFwiZG93bnJpZ2h0XCIgfCBcInJpZ2h0cmlnaHRcIjtcblxudHlwZSBXcml0aW5nTW9kZSA9IFwiaG9yaXpvbnRhbC10YlwiIHwgXCJ2ZXJ0aWNhbC1sclwiIHwgXCJzaWRld2F5cy1ybFwiIHwgXCJ2ZXJ0aWNhbC1ybFwiIHwgXCJzaWRld2F5cy1sclwiO1xudHlwZSBEaXJlY3Rpb24gPSBcImx0clwiIHwgXCJydGxcIjtcbnR5cGUgVGV4dE9yaWVudGF0aW9uID0gXCJtaXhlZFwiIHwgXCJ1cHJpZ2h0XCIgfCBcInNpZGV3YXlzXCI7XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemU8VCBleHRlbmRzIHN0cmluZz4oc3RyOiBUKTogQ2FwaXRhbGl6ZTxUPiB7XG4gICAgcmV0dXJuIChzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSkpIGFzIENhcGl0YWxpemU8VD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTG9naWNhbERpcmVjdGlvblBhcmFtZXRlcnMge1xuICAgIG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZT8oaW5mbzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dpY2FsRWxlbWVudFNpemUge1xuICAgIGNsaWVudElubGluZVNpemU6IG51bWJlcjtcbiAgICBzY3JvbGxJbmxpbmVTaXplOiBudW1iZXI7XG4gICAgb2Zmc2V0SW5saW5lU2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNsaWVudEJsb2NrU2l6ZTogbnVtYmVyO1xuICAgIHNjcm9sbEJsb2NrU2l6ZTogbnVtYmVyO1xuICAgIG9mZnNldEJsb2NrU2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNsaWVudElubGluZUluc2V0OiBudW1iZXI7XG4gICAgc2Nyb2xsSW5saW5lSW5zZXQ6IG51bWJlcjtcbiAgICBvZmZzZXRJbmxpbmVJbnNldDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNsaWVudEJsb2NrSW5zZXQ6IG51bWJlcjtcbiAgICBzY3JvbGxCbG9ja0luc2V0OiBudW1iZXI7XG4gICAgb2Zmc2V0QmxvY2tJbnNldDogbnVtYmVyIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEluc3BlY3RzIHRoZSBlbGVtZW50J3Mgc3R5bGUgYW5kIGRldGVybWluZXMgdGhlIGxvZ2ljYWwgZGlyZWN0aW9uIHRoYXQgdGV4dCBmbG93cy5cbiAqIFxuICogQ2VydGFpbiBDU1MgcHJvcGVydGllcywgbGlrZSBgYmxvY2stc2l6ZWAsIHJlc3BlY3QgdGhlIGN1cnJlbnQgd3JpdGluZyBtb2RlIGFuZCB0ZXh0IGRpcmVjdGlvbi5cbiAqIEJ1dCBgdHJhbnNmb3JtYCwgYGNsaXBgLCBldGMuIGRvbid0LlxuICogXG4gKiBUaGlzIGlzIHByb3ZpZGVkIHNvIHRoYXQgQ1NTIHByb3BlcnRpZXMgY2FuIGNvbnNpc3RlbnRseSB1c2UgdGhvc2UgbG9naWNhbCBwcm9wZXJ0aWVzLlxuICogXG4gKiBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy13cml0aW5nLW1vZGVzLyNsb2dpY2FsLXRvLXBoeXNpY2FsXG4gKiBcbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICogKiBgZ2V0TG9naWNhbERpcmVjdGlvbmA6IHJldHJpZXZlcyBhIGBMb2dpY2FsRGlyZWN0aW9uSW5mb2AgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50LiAoRnVuY3Rpb24gaXMgY29uc3RhbnQgYmV0d2VlbiByZW5kZXJzKVxuICogKiBgY29udmVydEVsZW1lbnRTaXplYDogV2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUVsZW1lbnRTaXplYCwgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSB0aGUgbG9naWNhbCBzaXplIG9mIGFuIGVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgcGh5c2ljYWwgc2l6ZS4gXG4gKiAqIGBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb25gOiBCYXNlZCBvbiB0aGUgY3VycmVudCBkaXJlY3Rpb24sIGNvbnZlcnRzIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIiB0byBcImlubGluZVwiIG9yIFwiYmxvY2tcIi5cbiAqICogYGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb25gOiAgQmFzZWQgb24gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBjb252ZXJ0cyBcImlubGluZVwiIG9yIFwiYmxvY2tcIiB0byBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2dpY2FsRGlyZWN0aW9uPFQgZXh0ZW5kcyBFbGVtZW50Pih7IG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZSB9OiBVc2VMb2dpY2FsRGlyZWN0aW9uUGFyYW1ldGVycyk6IFVzZUxvZ2ljYWxEaXJlY3Rpb25SZXR1cm5UeXBlPFQ+IHtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUxvZ2ljYWxEaXJlY3Rpb25cIiwgb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlKTtcblxuICAgIGNvbnN0IFtnZXRDb21wdXRlZFN0eWxlcywgc2V0Q29tcHV0ZWRTdHlsZXNdID0gdXNlUGFzc2l2ZVN0YXRlPENTU1N0eWxlRGVjbGFyYXRpb24gfCBudWxsPihudWxsLCByZXR1cm5OdWxsKTtcblxuXG4gICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8VD4oe1xuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlbGVtZW50OiBUIHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRDb21wdXRlZFN0eWxlcyh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKVxuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gcmVmcmVzaCB3aGljaCB3cml0aW5nIG1vZGUgd2UgaGF2ZSBvbmNlIG1vdW50ZWQuXG4gICAgLy8gICBBLiBUaGVyZSdzIG5vIHdheSB0byB3YXRjaCBmb3IgQ1NTIHN0eWxlIGNoYW5nZXNcbiAgICAvLyAgIEIuIENhbGxpbmcgZ2V0Q29tcHV0ZWRTdHlsZSBhZnRlciBldmVyeSByZW5kZXIgZm9yIGV2ZXJ5IGVsZW1lbnQgZ2V0cyBleHBlbnNpdmUgZmFzdCBhbmRcbiAgICAvLyAgIEMuIElzIG5vdCBuZWNlc3NhcnkgZm9yIG1vc3QgdXNlIGNhc2VzIHRoYXQgd2lsbCBuZXZlciBzd2l0Y2ggd3JpdGluZy1tb2RlIHdpdGhpbiBhIHNpbmdsZSBjb21wb25lbnRcbiAgICAvLyAgICAgIChUaG9zZSB0aGF0IGRvIHdpbGwgbmVlZCB0byBtb3VudCBhbmQgdW5tb3VudCB0aGUgY29tcG9uZW50IHRoYXQgdXNlcyBpdClcbiAgICAvL1xuICAgIC8vIEFzIGEgc29sdXRpb24sIGhlcmUncyBhIGNoZWFwIHdvcmthcm91bmQgdGhhdCBjaGVja3Mgd2hlbiB0aGUgZWxlbWVudCdzIHNpemUgaGFzIGNoYW5nZWQsXG4gICAgLy8gYW5kIGlmIHNvLCB0ZXN0cyBpZiB0aGUgd3JpdGluZyBtb2RlIGhhcyBjaGFuZ2VkIHRvby5cbiAgICAvL1xuICAgIC8vIFRoaXMgd2lsbCB3b3JrIGZvciBhdCBsZWFzdCBzb21lIG51bWJlciBvZiBjYXNlcywgYnV0IGEgYmV0dGVyIHNvbHV0aW9uIGlzIHN0aWxsIG5lZWRlZC5cbiAgICBjb25zdCB7IHVzZUVsZW1lbnRTaXplUHJvcHMgfSA9IHVzZUVsZW1lbnRTaXplPFQ+KHsgb25TaXplQ2hhbmdlOiB1c2VDYWxsYmFjayhfID0+IG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZT8uKGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCkpLCBbXSkgfSlcblxuICAgIGNvbnN0IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGVzKCk7XG4gICAgICAgIGlmIChjb21wdXRlZFN0eWxlcykge1xuICAgICAgICAgICAgY29uc3QgdyA9IGNvbXB1dGVkU3R5bGVzLndyaXRpbmdNb2RlIGFzIFdyaXRpbmdNb2RlO1xuICAgICAgICAgICAgbGV0IGQgPSBjb21wdXRlZFN0eWxlcy5kaXJlY3Rpb24gYXMgRGlyZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgdCA9IGNvbXB1dGVkU3R5bGVzLnRleHRPcmllbnRhdGlvbiBhcyBUZXh0T3JpZW50YXRpb247XG5cbiAgICAgICAgICAgIGlmICh0ID09IFwidXByaWdodFwiKVxuICAgICAgICAgICAgICAgIGQgPSBcImx0clwiO1xuXG4gICAgICAgICAgICByZXR1cm4gKHsgLi4uV3JpdGluZ01vZGVzW3cgfHwgXCJob3Jpem9udGFsLXRiXCJdW2QgfHwgXCJsdHJcIl0gfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCBbXSlcblxuICAgIC8vY29uc3QgW2dldExvZ2ljYWxEaXJlY3Rpb25JbmZvLCBzZXRMb2dpY2FsRGlyZWN0aW9uSW5mb10gPSB1c2VQYXNzaXZlU3RhdGU8TG9naWNhbERpcmVjdGlvbkluZm8+KG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZSk7XG5cbiAgICBjb25zdCBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb24gPSB1c2VDYWxsYmFjaygoZWxlbWVudE9yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gZWxlbWVudE9yaWVudGF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIFwiaW5saW5lXCI7XG4gICAgICAgIHJldHVybiBcImJsb2NrXCI7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgY29udmVydFRvUGh5c2ljYWxTaWRlID0gdXNlQ2FsbGJhY2soKHNpZGU6IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcIiB8IFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIgPT4ge1xuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XG5cbiAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stc3RhcnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5ibG9ja0RpcmVjdGlvbiA/PyBcInR0YlwiKVswXSBhcyBcInRcIiB8IFwiYlwiIHwgXCJsXCIgfCBcInJcIl07XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uYmxvY2tEaXJlY3Rpb24gPz8gXCJ0dGJcIilbMl0gYXMgXCJ0XCIgfCBcImJcIiB8IFwibFwiIHwgXCJyXCJdO1xuXG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uaW5saW5lRGlyZWN0aW9uID8/IFwibHRyXCIpWzBdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uaW5saW5lRGlyZWN0aW9uID8/IFwibHRyXCIpWzJdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgY29udmVydFRvTG9naWNhbFNpZGUgPSB1c2VDYWxsYmFjaygoc2lkZTogXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKTogXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiIHwgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIiA9PiB7XG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJ0dGJcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uaW5saW5lRGlyZWN0aW9uID09PSBcImJ0dFwiID8gXCJpbmxpbmUtc3RhcnRcIiA6IFwiaW5saW5lLWVuZFwiO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uYmxvY2tEaXJlY3Rpb24gPT09IFwicnRsXCIgPyBcImJsb2NrLXN0YXJ0XCIgOiBcImJsb2NrLWVuZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uYmxvY2tEaXJlY3Rpb24gPT09IFwidHRiXCIgPyBcImJsb2NrLXN0YXJ0XCIgOiBcImJsb2NrLWVuZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJidHRcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5pbmxpbmVEaXJlY3Rpb24gPT09IFwicnRsXCIgPyBcImlubGluZS1zdGFydFwiIDogXCJpbmxpbmUtZW5kXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UpO1xuICAgICAgICByZXR1cm4gXCJpbmxpbmUtc3RhcnRcIjtcblxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbiA9IHVzZUNhbGxiYWNrKChlbGVtZW50T3JpZW50YXRpb246IExvZ2ljYWxPcmllbnRhdGlvbiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgaWYgKGVsZW1lbnRPcmllbnRhdGlvbiA9PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PSBcImhvcml6b250YWxcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbj8uYmxvY2tPcmllbnRhdGlvbiA9PSBcInZlcnRpY2FsXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcblxuICAgICAgICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgY29udmVydEVsZW1lbnRTaXplID0gdXNlQ2FsbGJhY2soKGVsZW1lbnRTaXplOiBFbGVtZW50U2l6ZSwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKTogTG9naWNhbEVsZW1lbnRTaXplIHwgbnVsbCA9PiB7XG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgeyBpbmxpbmVTaXplLCBibG9ja1NpemUsIGlubGluZURpcmVjdGlvbiwgYmxvY2tEaXJlY3Rpb24gfSA9IGRpcmVjdGlvbjtcblxuICAgICAgICAgICAgLy8gU2l6ZSBpcyByZWxhdGl2ZWx5IHNpbXBsZVxuICAgICAgICAgICAgY29uc3QgY2xpZW50SW5saW5lU2l6ZSA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoaW5saW5lU2l6ZSl9YF07XG4gICAgICAgICAgICBjb25zdCBjbGllbnRCbG9ja1NpemUgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGJsb2NrU2l6ZSl9YF07XG5cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldElubGluZVNpemUgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGlubGluZVNpemUpfWBdO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0QmxvY2tTaXplID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShibG9ja1NpemUpfWBdO1xuXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxJbmxpbmVTaXplID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShpbmxpbmVTaXplKX1gXTtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEJsb2NrU2l6ZSA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoYmxvY2tTaXplKX1gXTtcblxuXG5cblxuICAgICAgICAgICAgY29uc3QgZjEgPSBnZXRQaHlzaWNhbExlZnRUb3AoaW5saW5lRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGYyID0gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShpbmxpbmVEaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBjb25zdCBmMyA9IGdldFBoeXNpY2FsTGVmdFRvcChibG9ja0RpcmVjdGlvbik7XG4gICAgICAgICAgICBjb25zdCBmNCA9IGdldFBoeXNpY2FsUmlnaHRCb3R0b20oYmxvY2tEaXJlY3Rpb24pO1xuXG5cbiAgICAgICAgICAgY29uc3QgY2xpZW50SW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGYxKX1gXSArICghZjIgPyAwIDogZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmMil9YF0pO1xuICAgICAgICAgICBjb25zdCBzY3JvbGxJbmxpbmVJbnNldCA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjEpfWBdICsgKCFmMiA/IDAgOiBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGYyKX1gXSk7XG4gICAgICAgICAgIGNvbnN0IG9mZnNldElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMSl9YF0gPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogKGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjEpfWBdISArICghZjIgPyAwIDogZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMil9YF0hKSk7XG5cblxuICAgICAgICAgICAgY29uc3QgY2xpZW50QmxvY2tJbnNldCA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjMpfWBdICsgKCFmNCA/IDAgOiBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGY0KX1gXSk7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMyl9YF0gKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjQpfWBdKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldEJsb2NrSW5zZXQgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYzKX1gXSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAoZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMyl9YF0hICsgKCFmNCA/IDAgOiBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGY0KX1gXSEpKTtcblxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsaWVudElubGluZVNpemUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW5saW5lU2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRJbmxpbmVTaXplLFxuICAgICAgICAgICAgICAgIGNsaWVudEJsb2NrU2l6ZSxcbiAgICAgICAgICAgICAgICBzY3JvbGxCbG9ja1NpemUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0QmxvY2tTaXplLFxuICAgICAgICAgICAgICAgIGNsaWVudElubGluZUluc2V0LFxuICAgICAgICAgICAgICAgIHNjcm9sbElubGluZUluc2V0LFxuICAgICAgICAgICAgICAgIG9mZnNldElubGluZUluc2V0LFxuICAgICAgICAgICAgICAgIGNsaWVudEJsb2NrSW5zZXQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsQmxvY2tJbnNldCxcbiAgICAgICAgICAgICAgICBvZmZzZXRCbG9ja0luc2V0LFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHM6IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VFbGVtZW50U2l6ZVByb3BzKHByb3BzKSksIFtdKSxcbiAgICAgICAgZ2V0RWxlbWVudCxcbiAgICAgICAgZ2V0TG9naWNhbERpcmVjdGlvbkluZm8sXG4gICAgICAgIGNvbnZlcnRUb0xvZ2ljYWxTaXplOiBjb252ZXJ0RWxlbWVudFNpemUsXG4gICAgICAgIGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbixcbiAgICAgICAgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbixcbiAgICAgICAgY29udmVydFRvTG9naWNhbFNpZGUsXG4gICAgICAgIGNvbnZlcnRUb1BoeXNpY2FsU2lkZVxuICAgIH07XG59XG5cbi8vIFBvc2l0aW9uIHJlcXVpcmVzIHVzIHRvIHNvbWV0aW1lcyB1c2Ugb25lIHByb3BlcnR5IChsaWtlIGBsZWZ0YClcbi8vIG9yIHNvbWV0aW1lcyB0d28gKGxpa2UgYGxlZnRgICsgYHdpZHRoYClcbmZ1bmN0aW9uIGdldFBoeXNpY2FsTGVmdFRvcChkaXI6IFBoeXNpY2FsRGlyZWN0aW9uKSB7IGlmIChkaXIgPT09IFwibHRyXCIgfHwgZGlyID09IFwicnRsXCIpIHJldHVybiBcImxlZnRcIjsgcmV0dXJuIFwidG9wXCI7IH1cbmZ1bmN0aW9uIGdldFBoeXNpY2FsUmlnaHRCb3R0b20oZGlyOiBQaHlzaWNhbERpcmVjdGlvbikgeyBpZiAoZGlyID09PSBcInJ0bFwiKSByZXR1cm4gXCJ3aWR0aFwiOyBpZiAoZGlyID09PSBcImJ0dFwiKSByZXR1cm4gXCJoZWlnaHRcIjsgcmV0dXJuIG51bGw7IH1cblxuLy8gSGVscGVyIGZvciBleHRyYWN0aW5nIGluZm8gZnJvbSBcImx0clwiLCBcInR0YlwiLCBldGMuXG5jb25zdCBNID0ge1xuICAgIHQ6IFwidG9wXCIsXG4gICAgYjogXCJib3R0b21cIixcbiAgICBsOiBcImxlZnRcIixcbiAgICByOiBcInJpZ2h0XCJcbn0gYXMgY29uc3Q7XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMb2dpY2FsRGlyZWN0aW9uUmV0dXJuVHlwZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRFbGVtZW50OiAoKSA9PiBUIHwgbnVsbDtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvOiAoKSA9PiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgRWxlbWVudFNpemUgaW5mbyBmcm9tIHVzZUVsZW1lbnRTaXplLCBjb252ZXJ0cyBhbGwgdGhvc2UgcGh5c2ljYWwgcHJvcGVydGllcyB0byB0aGVpciBsb2dpY2FsIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgY29udmVydFRvTG9naWNhbFNpemU6IChlbGVtZW50U2l6ZTogRWxlbWVudFNpemUsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gTG9naWNhbEVsZW1lbnRTaXplIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIGBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcImAgaW50byBgXCJpbmxpbmVcIiB8IFwiYmxvY2tcImBcbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uOiAoZWxlbWVudE9yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaW5saW5lXCIgfCBcImJsb2NrXCI7XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBgXCJpbmxpbmVcIiB8IFwiYmxvY2tcImAgaW50byBgXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCJgXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb246IChlbGVtZW50T3JpZW50YXRpb246IExvZ2ljYWxPcmllbnRhdGlvbiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIjtcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIGBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiYCBpbnRvIGBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiIHwgXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiYFxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBjb252ZXJ0VG9Mb2dpY2FsU2lkZTogKHNpZGU6IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiIHwgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIjtcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIGBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiIHwgXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiYCBpbnRvIGBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiYFxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBjb252ZXJ0VG9QaHlzaWNhbFNpZGU6IChzaWRlOiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCI7XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2ljYWxEaXJlY3Rpb25JbmZvIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBkaXJlY3Rpb24gdGV4dCBmbG93cywgZ2x5cGggYnkgZ2x5cGguICBCeSBmYXIgdGhlIG1vc3QgY29tcGxleCBwcm9wZXJ0eS5cbiAgICAgKiBcbiAgICAgKiB8YHdyaXRpbmctbW9kZWB8YGRpcmVjdGlvbmB8UmVzdWx0fFxuICAgICAqIHwtLS0tLXwtLS0tLXwtLS0tLXxcbiAgICAgKiB8YGhvcml6b250YWwtdGJgfGBsdHJgfGBsdHJgfFxuICAgICAqIHxgaG9yaXpvbnRhbC10YmB8YHJ0bGB8YHJ0bGB8XG4gICAgICogfGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgfGBsdHJgfGB0dGJgfFxuICAgICAqIHxgdmVydGljYWwtcmxgICYgYHNpZGV3YXlzLXJsYHxgcnRsYHxgYnR0YHxcbiAgICAgKiB8YHZlcnRpY2FsLWxyYHxgbHRyYHxgdHRiYHxcbiAgICAgKiB8YHZlcnRpY2FsLWxyYHxgcnRsYHxgYnR0YHxcbiAgICAgKiB8YHNpZGV3YXlzLWxyYHxgbHRyYHxgYnR0YHxcbiAgICAgKiB8YHNpZGV3YXlzLWxyYHxgcnRsYHxgdHRiYHxcbiAgICAgKi9cbiAgICBpbmxpbmVEaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU2ltcGxpZmllZCB2ZXJzaW9uIG9mIGBpbmxpbmVEaXJlY3Rpb25gOlxuICAgICAqIFxuICAgICAqICogYGhvcml6b250YWxgIGZvciBgaG9yaXpvbnRhbC10YmBcbiAgICAgKiAqIGB2ZXJ0aWNhbGAgZm9yIGFsbCBvdGhlcnNcbiAgICAgKi9cbiAgICBpbmxpbmVPcmllbnRhdGlvbjogUGh5c2ljYWxPcmllbnRhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGRpcmVjdGlvbiB0ZXh0IGZsb3dzLCBsaW5lIGJ5IGxpbmUuXG4gICAgICogXG4gICAgICogKiBgdHRiYCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYHJ0bGAgZm9yIGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYGx0cmAgZm9yIGB2ZXJ0aWNhbC1scmAgJiBgc2lkZXdheXMtbHJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqL1xuICAgIGJsb2NrRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFNpbXBsaWZpZWQgdmVyc2lvbiBvZiBgYmxvY2tEaXJlY3Rpb25gOlxuICAgICAqIFxuICAgICAqICogYHZlcnRpY2FsYCBmb3IgYGhvcml6b250YWwtdGJgXG4gICAgICogKiBgaG9yaXpvbnRhbGAgZm9yIGFsbCBvdGhlcnNcbiAgICAgKi9cbiAgICBibG9ja09yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBob3cgeW91IGNhbiAqcGh5c2ljYWxseSogcmVmZXIgdG8gdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgaW4gdGhlICppbmxpbmUqIHNpemUuXG4gICAgICogXG4gICAgICogKiBgd2lkdGhgIGZvciBgaG9yaXpvbnRhbC10YmAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXG4gICAgICogKiBgaGVpZ2h0YCBmb3IgYWxsIG90aGVyc1xuICAgICAqL1xuICAgIGlubGluZVNpemU6IFBoeXNpY2FsU2l6ZTtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgaG93IHlvdSBjYW4gKnBoeXNpY2FsbHkqIHJlZmVyIHRvIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IGluIHRoZSAqYmxvY2sqIHNpemUuXG4gICAgICogXG4gICAgICogKiBgaGVpZ2h0YCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYHdpZHRoYCBmb3IgYWxsIG90aGVyc1xuICAgICAqL1xuICAgIGJsb2NrU2l6ZTogUGh5c2ljYWxTaXplO1xuXG4gICAgLyoqXG4gICAgICogRm9yIGVhY2ggZ2x5cGgsIGFzY2VuZGVycyB0byBkZXNjZW5kZXJzICpwaHlzaWNhbGx5KiBnbzpcbiAgICAgKiBcbiAgICAgKiAqIGB0dGJgIGZvciBgaG9yaXpvbnRhbC10YmBcbiAgICAgKiAqIGBydGxgIGZvciBgdmVydGljYWwtcmxgLCBgdmVydGljYWwtbHJgLCAmIGBzaWRld2F5cy1ybGBcbiAgICAgKiAqIGBsdHJgIGZvciBgc2lkZXdheXMtbHJgXG4gICAgICovXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEZvciBlYWNoIGdseXBoLCBpdHMgXCJsZWZ0XCIgc2lkZSAodGhpbmsgb2YgdGhpcyByZWxhdGl2ZSB0byBgd3JpdGluZy1tb2RlYCBidXQgKm5vdCogcmVsYXRpdmUgdG8gYGRpcmVjdGlvbmAsIG9yIGFsdGVybmF0aXZlbHkgd2hhdCBgdGV4dC1hbGlnbjogbGVmdGAgbWVhbnMpIHRvIGl0cyBcInJpZ2h0XCIgc2lkZSAqcGh5c2ljYWxseSogZ29lcyBmcm9tOlxuICAgICAqIFxuICAgICAqICogYGx0cmAgZm9yIGBob3Jpem9udGFsLXRiYFxuICAgICAqICogYHR0YmAgZm9yIGB2ZXJ0aWNhbC1ybGAsIGB2ZXJ0aWNhbC1scmAsICYgYHNpZGV3YXlzLXJsYFxuICAgICAqICogYGJ0dGAgZm9yIGBzaWRld2F5cy1scmBcbiAgICAgKi9cbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xufVxuXG5jb25zdCBIb3Jpem9udGFsVGJMdHI6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIGlubGluZURpcmVjdGlvbjogXCJsdHJcIixcbiAgICBibG9ja0RpcmVjdGlvbjogXCJ0dGJcIixcblxuICAgIGlubGluZU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICBibG9ja09yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXG5cbiAgICBpbmxpbmVTaXplOiBcIndpZHRoXCIsXG4gICAgYmxvY2tTaXplOiBcImhlaWdodFwiLFxuXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcImx0clwiLFxuICAgIG92ZXJVbmRlckRpcmVjdGlvbjogXCJ0dGJcIlxufTtcblxuY29uc3QgSG9yaXpvbnRhbFRiUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5Ib3Jpem9udGFsVGJMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInJ0bFwiLFxufTtcblxuY29uc3QgVmVydGljYWxSbEx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiLFxuICAgIGJsb2NrRGlyZWN0aW9uOiBcInJ0bFwiLFxuXG4gICAgaW5saW5lT3JpZW50YXRpb246IFwidmVydGljYWxcIixcbiAgICBibG9ja09yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcblxuICAgIGlubGluZVNpemU6IFwiaGVpZ2h0XCIsXG4gICAgYmxvY2tTaXplOiBcIndpZHRoXCIsXG5cbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwidHRiXCIsXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcInJ0bFwiXG59O1xuXG5jb25zdCBWZXJ0aWNhbFJsUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5WZXJ0aWNhbFJsTHRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIlxufTtcblxuXG5jb25zdCBTaWRld2F5c1JsTHRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHsgLi4uVmVydGljYWxSbEx0ciB9O1xuY29uc3QgU2lkZXdheXNSbFJ0bDogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7IC4uLlZlcnRpY2FsUmxSdGwgfTtcblxuY29uc3QgVmVydGljYWxMckx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgLi4uVmVydGljYWxSbEx0cixcbiAgICBibG9ja0RpcmVjdGlvbjogXCJsdHJcIixcbn07XG5cbmNvbnN0IFZlcnRpY2FsTHJSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLlZlcnRpY2FsUmxSdGwsXG4gICAgYmxvY2tEaXJlY3Rpb246IFwibHRyXCIsXG59O1xuXG5jb25zdCBTaWRld2F5c0x0THRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5WZXJ0aWNhbExyTHRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIixcblxuICAgIGxlZnRSaWdodERpcmVjdGlvbjogXCJidHRcIixcbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFwibHRyXCJcbn07XG5cbmNvbnN0IFNpZGV3YXlzTHRSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLlNpZGV3YXlzTHRMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiXG59O1xuXG5cblxuY29uc3QgSG9yaXpvbnRhbFRiID0ge1xuICAgIGx0cjogSG9yaXpvbnRhbFRiTHRyLFxuICAgIHJ0bDogSG9yaXpvbnRhbFRiUnRsXG59IGFzIGNvbnN0O1xuXG5jb25zdCBWZXJ0aWNhbFJsID0ge1xuICAgIGx0cjogVmVydGljYWxSbEx0cixcbiAgICBydGw6IFZlcnRpY2FsUmxSdGxcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IFZlcnRpY2FsTHIgPSB7XG4gICAgbHRyOiBWZXJ0aWNhbExyTHRyLFxuICAgIHJ0bDogVmVydGljYWxMclJ0bFxufSBhcyBjb25zdDtcblxuY29uc3QgU2lkZXdheXNSbCA9IHtcbiAgICBsdHI6IFNpZGV3YXlzUmxMdHIsXG4gICAgcnRsOiBTaWRld2F5c1JsUnRsXG59IGFzIGNvbnN0O1xuXG5jb25zdCBTaWRld2F5c0xyID0ge1xuICAgIGx0cjogU2lkZXdheXNMdEx0cixcbiAgICBydGw6IFNpZGV3YXlzTHRSdGxcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IFdyaXRpbmdNb2RlcyA9IHtcbiAgICBcImhvcml6b250YWwtdGJcIjogSG9yaXpvbnRhbFRiLFxuICAgIFwidmVydGljYWwtbHJcIjogVmVydGljYWxMcixcbiAgICBcInZlcnRpY2FsLXJsXCI6IFZlcnRpY2FsUmwsXG4gICAgXCJzaWRld2F5cy1sclwiOiBTaWRld2F5c0xyLFxuICAgIFwic2lkZXdheXMtcmxcIjogU2lkZXdheXNSbFxufSBhcyBjb25zdDtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUaW1lb3V0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2AuICBcbiAgICAgKiBJZiBgbnVsbGAsIGNhbmNlbHMgdGhlIHRpbWVvdXQgaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgdGltZW91dDogbnVtYmVyIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdG8gdGhpcyBwcm9wIGJldHdlZW4gcmVuZGVycyBjYW4gYmUgdXNlZCB0byBjbGVhciB0aGUgY3VycmVudCB0aW1lb3V0IGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqL1xuICAgIHRyaWdnZXJJbmRleD86IHVua25vd247XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYHRpbWVvdXRgIG1zIGFmdGVyIG1vdW50LCBvciB0aGUgbGFzdCBjaGFuZ2UgdG8gYHRyaWdnZXJJbmRleGAuXG4gICAgICogXG4gICAgICogRG9lcyAqbm90KiBuZWVkIHRvIGJlIHN0YWJsZS4gR28gYWhlYWQgYW5kIHBhc3MgYW4gYW5vbnltb3VzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVGltZW91dCh7IHRpbWVvdXQsIGNhbGxiYWNrLCB0cmlnZ2VySW5kZXggfTogVXNlVGltZW91dCkge1xuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBzdGFydFRpbWVSZWYuY3VycmVudCA9IG51bGw7IGNhbGxiYWNrKCk7IH0pO1xuICAgIGNvbnN0IGdldFRpbWVvdXQgPSB1c2VTdGFibGVHZXR0ZXIodGltZW91dCk7XG5cbiAgICAvLyBTZXQgYW55IHRpbWUgd2Ugc3RhcnQgdGltZW91dC5cbiAgICAvLyBVbnNldCBhbnkgdGltZSB0aGUgdGltZW91dCBjb21wbGV0ZXNcbiAgICBjb25zdCBzdGFydFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCB0aW1lb3V0SXNOdWxsID0gKHRpbWVvdXQgPT0gbnVsbCk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgdHJpZ2dlckluZGV4IGNoYW5nZXMgKGluY2x1ZGluZyBvbiBtb3VudClcbiAgICAvLyByZXN0YXJ0IHRoZSB0aW1lb3V0LiAgVGhlIHRpbWVvdXQgZG9lcyBOT1QgcmVzZXRcbiAgICAvLyB3aGVuIHRoZSBkdXJhdGlvbiBvciBjYWxsYmFjayBjaGFuZ2VzLCBvbmx5IHRyaWdnZXJJbmRleC5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRpbWVvdXRJc051bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aW1lb3V0SXNOdWxsID09ICh0aW1lb3V0ID09IG51bGwpKTtcbiAgICBcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVSZWYuY3VycmVudCA9ICsobmV3IERhdGUoKSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChzdGFibGVDYWxsYmFjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sIFt0cmlnZ2VySW5kZXgsIHRpbWVvdXRJc051bGxdKVxuXG4gICAgY29uc3QgZ2V0RWxhcHNlZFRpbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKyhuZXcgRGF0ZSgpKSkgLSAoKyhzdGFydFRpbWVSZWYuY3VycmVudCA/PyBuZXcgRGF0ZSgpKSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0UmVtYWluaW5nVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgcmV0dXJuIHRpbWVvdXQgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1heCgwLCB0aW1lb3V0IC0gZ2V0RWxhcHNlZFRpbWUoKSlcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyBnZXRFbGFwc2VkVGltZSwgZ2V0UmVtYWluaW5nVGltZSB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VMb2dpY2FsRGlyZWN0aW9uIH0gZnJvbSBcIi4vdXNlLWxvZ2ljYWwtZGlyZWN0aW9uXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VUaW1lb3V0IH0gZnJvbSBcIi4vdXNlLXRpbWVvdXRcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIGxpbmVhck5hdmlnYXRpb246IHt9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqIFxuICAgICAqIFRoZXNlIHByb3BzIGNhbiBiZSBhdHRhdGNoZWQgZWl0aGVyIHRvIHRoZSBwYXJlbnQgb3IgdG8gZWFjaCBpbmRpdmlkdWFsIGNoaWxkLlxuICAgICAqIFdoaWNoZXZlciB3b3JrcyBiZXR0ZXIgZm9yIHlvdXIgc2NlbmFyaW8uXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKiBcbiAgICAgKiAqL1xuICAgIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pjtcbn1cblxuaW50ZXJmYWNlIExOUCB7XG4gICAgbmF2aWdhdGVUb05leHQoKTogdm9pZDtcbiAgICBuYXZpZ2F0ZVRvUHJldigpOiB2b2lkO1xuICAgIG5hdmlnYXRlVG9GaXJzdCgpOiB2b2lkO1xuICAgIG5hdmlnYXRlVG9MYXN0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hpY2ggYXJyb3cga2V5cyBhcmUgdXNlZCB0byBuYXZpZ2F0ZSB0aHJvdWdoIHRoZSBjb21wb25lbnQuXG4gICAgICogUmVsYXRpdmUgdG8gdGhlIHdyaXRpbmcgbW9kZSwgc28gaW4gRW5nbGlzaCwgXCJpbmxpbmVcIiBjb3JyZXNwb25kc1xuICAgICAqIHRvIHRoZSBsZWZ0ICYgcmlnaHQgYXJyb3cga2V5cywgYW5kIFwiYmxvY2tcIiB0byB0aGUgdXAgJiBkb3duIGFycm93IGtleXMuXG4gICAgICogXG4gICAgICogVXNlIFwiZWl0aGVyXCIgdG8gYWxsb3cgbmF2aWdhdGlvbiBpbiBlaXRoZXIgZGlyZWN0aW9uLlxuICAgICAqIFxuICAgICAqIFVzZSBcIm5vbmVcIiB0byBkaXNhbGxvdyBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgaW4gYW55IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uPzogXCJpbmxpbmVcIiB8IFwiYmxvY2tcIiB8IFwiZWl0aGVyXCIgfCBcIm5vbmVcIjtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgd2lsbCBiZSBcbiAgICAgKiBkaXNhYmxlZCwgYnV0IG5hdmlnYXRpb24gd2l0aCB0aGUgaG9tZSAmIGVuZCBrZXlzIHdpbGxcbiAgICAgKiBiZSB1bmFmZmVjdGVkLlxuICAgICAqL1xuICAgIGRpc2FibGVBcnJvd0tleXM/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIG5hdmlnYXRpb24gd2l0aCB0aGUgaG9tZSAmIGVuZCBrZXlzIHdpbGxcbiAgICAgKiBiZSBkaXNhYmxlZCwgYnV0IG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlXG4gICAgICogdW5hZmZlY3RlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlSG9tZUVuZEtleXM/OiBib29sZWFuO1xufVxuZXhwb3J0IHR5cGUgTGluZWFyTmF2aWdhdGlvbk9taXRzID0ga2V5b2YgTE5QO1xuXG4vKiogQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcGFyZW50IGB1c2VMaW5lYXJOYXZpZ2F0aW9uYCAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxPbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cz4ge1xuICAgIGxpbmVhck5hdmlnYXRpb246IE9taXQ8TE5QLCBPbWl0cz5cbn1cblxuXG4vKiogQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgY2hpbGQgJ3VzZUxpbmVhck5hdmlnYXRpb25DaGlsZGAgKi9cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRJbmZvIHsgfVxuXG4vKipcbiAqIFdoZW4gdXNlZCBpbiB0YW5kZW0gd2l0aCBgdXNlUm92aW5nVGFiSW5kZXhgLCBhbGxvd3MgY29udHJvbCBvZlxuICogdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdGhlIGFycm93IGtleXMuXG4gKiBcbiAqIEBzZWUgdXNlTGlzdE5hdmlnYXRpb24sIHdoaWNoIHBhY2thZ2VzIGV2ZXJ5dGhpbmcgdXAgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaW5lYXJOYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBsaW5lYXJOYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9GaXJzdDogbnRmLCBuYXZpZ2F0ZVRvTGFzdDogbnRsLCBuYXZpZ2F0ZVRvTmV4dDogbnRuLCBuYXZpZ2F0ZVRvUHJldjogbnRwLCBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBuZCwgZGlzYWJsZUFycm93S2V5czogZGFrLCBkaXNhYmxlSG9tZUVuZEtleXM6IGRoZWsgfSB9OiBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlcj4pOiBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xuXG4gICAgbmQgPz89IFwiZWl0aGVyXCI7XG5cbiAgICBjb25zdCB7IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvLCB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHMgfSA9IHVzZUxvZ2ljYWxEaXJlY3Rpb248UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHt9KTtcblxuICAgIGNvbnN0IG5hdmlnYXRlVG9GaXJzdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG50Zik7XG4gICAgY29uc3QgbmF2aWdhdGVUb0xhc3QgPSB1c2VTdGFibGVDYWxsYmFjayhudGwpO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9OZXh0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRuKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvUHJldiA9IHVzZVN0YWJsZUNhbGxiYWNrKG50cCk7XG4gICAgY29uc3QgZ2V0RGlzYWJsZUFycm93S2V5cyA9IHVzZVN0YWJsZUdldHRlcihkYWspO1xuICAgIGNvbnN0IGdldERpc2FibGVIb21lRW5kS2V5cyA9IHVzZVN0YWJsZUdldHRlcihkaGVrKTtcbiAgICBjb25zdCBnZXROYXZpZ2F0aW9uRGlyZWN0aW9uID0gdXNlU3RhYmxlR2V0dGVyKG5kKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXG4gICAgICAgIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wczogdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4gPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBvbktleURvd24gPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxuICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuYXZpZ2F0aW9uRGlyZWN0aW9uID0gZ2V0TmF2aWdhdGlvbkRpcmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FibGVBcnJvd0tleXMgPSBnZXREaXNhYmxlQXJyb3dLZXlzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzYWJsZUhvbWVFbmRLZXlzID0gZ2V0RGlzYWJsZUhvbWVFbmRLZXlzKCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd3NCbG9ja05hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImJsb2NrXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJpbmxpbmVcIiB8fCBuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiZWl0aGVyXCIpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcImJsb2NrRGlyZWN0aW9uXCIgOiBcImlubGluZURpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IGFsbG93c0Jsb2NrTmF2aWdhdGlvbiA6IGFsbG93c0lubGluZU5hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwiYnR0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcImJsb2NrRGlyZWN0aW9uXCIgOiBcImlubGluZURpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IGFsbG93c0Jsb2NrTmF2aWdhdGlvbiA6IGFsbG93c0lubGluZU5hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwiYnR0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwiaW5saW5lRGlyZWN0aW9uXCIgOiBcImJsb2NrRGlyZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gYWxsb3dzSW5saW5lTmF2aWdhdGlvbiA6IGFsbG93c0Jsb2NrTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJydGxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImlubGluZURpcmVjdGlvblwiIDogXCJibG9ja0RpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IGFsbG93c0lubGluZU5hdmlnYXRpb24gOiBhbGxvd3NCbG9ja05hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwicnRsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVIb21lRW5kS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlSG9tZUVuZEtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHModXNlTWVyZ2VkUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHsgb25LZXlEb3duIH0sIHByb3BzKSlcbiAgICAgICAgfSwgW10pLFxuICAgIH1cblxuXG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcbiAgICAgICAgY3VycmVudFR5cGVhaGVhZDogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZDogYm9vbGVhbiB8IG51bGw7XG4gICAgfVxufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICAvKipcbiAgICAgKiBDYW4gYmUgdXNlZCBvbiBlaXRoZXIgdGhlIHBhcmVudCBvciBlYWNoIGNoaWxkIGVsZW1lbnQuXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzPFBhcmVudE9yQ2hpbGRFbGVtZW50PjtcblxuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ7XG5cbn1cblxuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZSA9IHZvaWQ7XG5cbmludGVyZmFjZSBUTlAge1xuICAgIC8qKlxuICAgICAqIEEgY29sbGF0b3IgdG8gdXNlIHdoZW4gY29tcGFyaW5nLiBJZiBub3QgcHJvdmlkZWQsIHNpbXBseSB1c2VzIGBsb2NhbGVDb21wYXJlYCBhZnRlciB0cmFuc2Zvcm1pbmcgZWFjaCB0byBsb3dlcmNhc2UsIHdoaWNoIHdpbGwsIGF0IGJlc3QsIHdvcmsgb2theSBpbiBFbmdsaXNoLlxuICAgICAqL1xuICAgIGNvbGxhdG9yPzogSW50bC5Db2xsYXRvcjtcblxuICAgIG5vVHlwZWFoZWFkPzogYm9vbGVhbjtcblxuICAgIHR5cGVhaGVhZFRpbWVvdXQ/OiBudW1iZXI7XG4gICAgZ2V0SW5kZXgoKTogbnVtYmVyIHwgbnVsbDtcbiAgICBzZXRJbmRleCh2YWx1ZTogbnVtYmVyIHwgbnVsbCB8ICgocHJldmlvdXNWYWx1ZTogbnVtYmVyIHwgbnVsbCkgPT4gKG51bWJlciB8IG51bGwpKSk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyA9IGtleW9mIFROUDtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxPbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cz4ge1xuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IE9taXQ8VE5QLCBPbWl0cz5cbn1cblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNoaWxkICd1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRgICovXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBJZiBwcm92aWRlZCwgYWxsb3dzIHRoaXMgY29tcG9uZW50IHRvIGJlIG5hdmlnYXRlZCB0byBieSB0eXBpbmcgdGhpcyBzdHJpbmcuIFxuICAgICAqIEl0IHNob3VsZCBiZSB0aGUgc2FtZSB0ZXh0IGNvbnRlbnQgYXMgd2hhdGV2ZXIncyBkaXNwbGF5ZWQsIGlkZWFsbHkuXG4gICAgICovXG4gICAgdGV4dDogc3RyaW5nIHwgbnVsbDtcblxuICAgIGluZGV4OiBudW1iZXI7XG59XG5cbi8qKiBUeXBlIG9mIHRoZSBjaGlsZCdzIHN1Yi1ob29rICovXG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQgPSAoYXJnczogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycykgPT4gVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTtcblxuXG4vKipcbiAqIEFsbG93cyBmb3IgdGhlIHNlbGVjdGlvbiBvZiBhIG1hbmFnZWQgY2hpbGQgYnkgdHlwaW5nIHRoZSBnaXZlbiB0ZXh0IGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAqIFxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVR5cGVhaGVhZE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIGdldEluZGV4LCB0eXBlYWhlYWRUaW1lb3V0LCBzZXRJbmRleCwgbm9UeXBlYWhlYWQgfSB9OiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlcj4pOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xuXG5cbiAgICAvLyBGb3IgdHlwZWFoZWFkLCBrZWVwIHRyYWNrIG9mIHdoYXQgb3VyIGN1cnJlbnQgXCJzZWFyY2hcIiBzdHJpbmcgaXMgKGlmIHdlIGhhdmUgb25lKVxuICAgIC8vIGFuZCBhbHNvIGNsZWFyIGl0IGV2ZXJ5IDEwMDAgbXMgc2luY2UgdGhlIGxhc3QgdGltZSBpdCBjaGFuZ2VkLlxuICAgIC8vIE5leHQsIGtlZXAgYSBtYXBwaW5nIG9mIHR5cGVhaGVhZCB2YWx1ZXMgdG8gaW5kaWNlcyBmb3IgZmFzdGVyIHNlYXJjaGluZy5cbiAgICAvLyBBbmQsIGZvciB0aGUgdXNlcidzIHNha2UsIGxldCB0aGVtIGtub3cgd2hlbiB0aGVpciB0eXBlYWhlYWQgY2FuJ3QgbWF0Y2ggYW55dGhpbmcgYW55bW9yZVxuICAgIGNvbnN0IFtjdXJyZW50VHlwZWFoZWFkLCBzZXRDdXJyZW50VHlwZWFoZWFkLCBnZXRDdXJyZW50VHlwZWFoZWFkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIHVzZVRpbWVvdXQoeyB0aW1lb3V0OiB0eXBlYWhlYWRUaW1lb3V0ID8/IDEwMDAsIGNhbGxiYWNrOiAoKSA9PiB7IHNldEN1cnJlbnRUeXBlYWhlYWQobnVsbCk7IHNldEludmFsaWRUeXBlYWhlYWQobnVsbCk7IH0sIHRyaWdnZXJJbmRleDogY3VycmVudFR5cGVhaGVhZCB9KTtcbiAgICBjb25zdCBzb3J0ZWRUeXBlYWhlYWRJbmZvID0gdXNlUmVmPHsgdGV4dDogc3RyaW5nLCB1bnNvcnRlZEluZGV4OiBudW1iZXIgfVtdPihbXSk7XG4gICAgY29uc3QgW2ludmFsaWRUeXBlYWhlYWQsIHNldEludmFsaWRUeXBlYWhlYWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KGZhbHNlKTtcblxuICAgIC8vIEhhbmRsZSB0eXBlYWhlYWQgZm9yIGlucHV0IG1ldGhvZCBlZGl0b3JzIGFzIHdlbGxcbiAgICAvLyBFc3NlbnRpYWxseSwgd2hlbiBhY3RpdmUsIGlnbm9yZSBmdXJ0aGVyIGtleXMgXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSB3YWl0aW5nIGZvciBhIENvbXBvc2l0aW9uRW5kIGV2ZW50XG4gICAgY29uc3QgWywgc2V0SW1lQWN0aXZlLCBnZXRJbWVBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy8gQmVjYXVzZSBjb21wb3NpdGlvbiBldmVudHMgZmlyZSAqYWZ0ZXIqIGtleWRvd24gZXZlbnRzIFxuICAgIC8vIChidXQgd2l0aGluIHRoZSBzYW1lIHRhc2ssIHdoaWNoLCBUT0RPLCBjb3VsZCBiZSBicm93c2VyLWRlcGVuZGVudCksXG4gICAgLy8gd2UgY2FuIHVzZSB0aGlzIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnQgd2UncmUgbGlzdGVuaW5nIGZvciBvbiB0aGUgZmlyc3Qga2V5ZG93bi5cbiAgICBjb25zdCBbbmV4dFR5cGVhaGVhZENoYXIsIHNldE5leHRUeXBlYWhlYWRDaGFyXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChuZXh0VHlwZWFoZWFkQ2hhciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0Q3VycmVudFR5cGVhaGVhZCh0eXBlYWhlYWQgPT4gKCh0eXBlYWhlYWQgPz8gXCJcIikgKyBuZXh0VHlwZWFoZWFkQ2hhcikpO1xuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIobnVsbCk7XG4gICAgICAgIH1cbiAgICB9LCBbbmV4dFR5cGVhaGVhZENoYXJdKTtcblxuXG4gICAgY29uc3QgY29tcGFyYXRvclNoYXJlZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChzYWZlTGhzOiBzdHJpbmcsIHNhZmVSaHM6IHN0cmluZykgPT4ge1xuICAgICAgICBsZXQgY29tcGFyZTogbnVtYmVyO1xuICAgICAgICAvLyBGb3IgdGhlIHB1cnBvc2VzIG9mIHR5cGVhaGVhZCwgb25seSBjb21wYXJlIGEgc3RyaW5nIG9mIHRoZSBzYW1lIHNpemUgYXMgb3VyIGN1cnJlbnRseSB0eXBlZCBzdHJpbmcuXG4gICAgICAgIC8vIEJ5IG5vcm1hbGl6aW5nIHRoZW0gZmlyc3QsIHdlIGVuc3VyZSB0aGlzIGJ5dGUtYnktYnl0ZSBoYW5kbGluZyBvZiByYXcgY2hhcmFjdGVyIGRhdGEgd29ya3Mgb3V0IG9rYXkuXG4gICAgICAgIHNhZmVMaHMgPSBzYWZlTGhzLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgc2FmZVJocyA9IHNhZmVSaHMubm9ybWFsaXplKFwiTkZEXCIpXG5cbiAgICAgICAgaWYgKGNvbGxhdG9yKVxuICAgICAgICAgICAgY29tcGFyZSA9IGNvbGxhdG9yLmNvbXBhcmUoc2FmZUxocywgc2FmZVJocylcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGFyZSA9IHNhZmVMaHMudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKHNhZmVSaHMudG9Mb3dlckNhc2UoKSA/PyBcIlwiKTtcblxuICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGluc2VydGluZ0NvbXBhcmF0b3IgPSB1c2VTdGFibGVDYWxsYmFjaygobGhzOiBzdHJpbmcsIHJoczogeyB0ZXh0OiBzdHJpbmc7IHVuc29ydGVkSW5kZXg6IG51bWJlcjsgfSkgPT4ge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaHMudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3JTaGFyZWQobGhzLCByaHMudGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGxocyBhcyB1bmtub3duIGFzIG51bWJlcikgLSAocmhzIGFzIHVua25vd24gYXMgbnVtYmVyKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHR5cGVhaGVhZENvbXBhcmF0b3IgPSB1c2VTdGFibGVDYWxsYmFjaygobGhzOiBzdHJpbmcsIHJoczogeyB0ZXh0OiBzdHJpbmc7IHVuc29ydGVkSW5kZXg6IG51bWJlcjsgfSkgPT4ge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaHMudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gRHVyaW5nIHR5cGVhaGVhZCwgYWxsIHN0cmluZ3MgbG9uZ2VyIHRoYW4gb3VycyBzaG91bGQgYmUgdHJ1bmNhdGVkXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZXkncmUgYWxsIGNvbnNpZGVyZWQgZXF1YWxseSBieSB0aGF0IHBvaW50LlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3JTaGFyZWQobGhzLCByaHMudGV4dC5zdWJzdHJpbmcoMCwgbGhzLmxlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChsaHMgYXMgdW5rbm93biBhcyBudW1iZXIpIC0gKHJocyBhcyB1bmtub3duIGFzIG51bWJlcik7XG4gICAgfSk7XG5cbiAgICBjb25zdCBpc0Rpc2FibGVkID0gdXNlU3RhYmxlR2V0dGVyKG5vVHlwZWFoZWFkKTtcblxuXG4gICAgY29uc3QgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcblxuICAgICAgICBjb25zdCBvbkNvbXBvc2l0aW9uU3RhcnQgPSAoX2U6IENvbXBvc2l0aW9uRXZlbnQpID0+IHsgc2V0SW1lQWN0aXZlKHRydWUpIH07XG4gICAgICAgIGNvbnN0IG9uQ29tcG9zaXRpb25FbmQgPSAoZTogQ29tcG9zaXRpb25FdmVudCkgPT4ge1xuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoZS5kYXRhKTtcbiAgICAgICAgICAgIHNldEltZUFjdGl2ZShmYWxzZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBpbWVBY3RpdmUgPSBnZXRJbWVBY3RpdmUoKTtcblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gZS5rZXk7XG5cbiAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxuICAgICAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoIWltZUFjdGl2ZSAmJiBlLmtleSA9PT0gXCJCYWNrc3BhY2VcIikge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gYSB3YXkgdGhhdCBkb2Vzbid0IHNwbGl0IFVURi0xNiBzdXJyb2dhdGVzLlxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlYWhlYWQodCA9PiB0ID09PSBudWxsID8gbnVsbCA6IFsuLi50XS5yZXZlcnNlKCkuc2xpY2UoMSkucmV2ZXJzZSgpLmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGtleSBwcm9wZXJ0eSByZXByZXNlbnRzIHRoZSB0eXBlZCBjaGFyYWN0ZXIgT1IgdGhlIFwibmFtZWQga2V5IGF0dHJpYnV0ZVwiIG9mIHRoZSBrZXkgcHJlc3NlZC5cbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gZGVmaW5pdGUgd2F5IHRvIHRlbGwgdGhlIGRpZmZlcmVuY2UsIGJ1dCBmb3IgYWxsIGludGVudHMgYW5kIHB1cnBvc2VzXG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gb25lLWNoYXJhY3RlciBuYW1lcywgYW5kIHRoZXJlIGFyZSBubyBub24tQVNDSUktYWxwaGEgbmFtZXMuXG4gICAgICAgICAgICAvLyBUaHVzLCBhbnkgb25lLWNoYXJhY3RlciBvciBub24tQVNDSUkgdmFsdWUgZm9yIGBrZXlgIGlzICphbG1vc3QgY2VydGFpbmx5KiBhIHR5cGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGNvbnN0IGlzQ2hhcmFjdGVyS2V5ID0gKGtleS5sZW5ndGggPT09IDEgfHwgIS9eW0EtWmEtel0vLnRlc3Qoa2V5KSk7XG4gICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXJLZXkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gXCIgXCIgJiYgKGdldEN1cnJlbnRUeXBlYWhlYWQoKSA/PyBcIlwiKS50cmltKCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgYmVjYXVzZSBhIHNwYWNlYmFyIGNhbid0IGV2ZXIgXG4gICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIGEgdHlwZWFoZWFkLCBvbmx5IGNvbnRpbnVlIG9uZS5cblxuICAgICAgICAgICAgICAgICAgICAvLyAoU3BlY2lmaWNhbGx5LCBsZXQgdGhlIGV2ZW50IGNvbnRpbnVlIHByb3BhZ2F0aW9uIGluIHRoaXMgY2FzZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdvbid0IGJlIHRydWUgZm9yIHRoZSBmaXJzdCBrZXlkb3duXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJlZm9yZSB1c2VMYXlvdXRFZmZlY3QgaXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGFjdHVhbGx5IGFwcGx5IHRoZSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD4oeyBvbktleURvd24sIG9uQ29tcG9zaXRpb25TdGFydCwgb25Db21wb3NpdGlvbkVuZCwgfSwgcHJvcHMpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIEhhbmRsZSBjaGFuZ2VzIGluIHR5cGVhaGVhZCB0aGF0IGNhdXNlIGNoYW5nZXMgdG8gdGhlIHRhYmJhYmxlIGluZGV4XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnRUeXBlYWhlYWQgJiYgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50Lmxlbmd0aCkge1xuXG5cblxuICAgICAgICAgICAgY29uc3Qgc29ydGVkVHlwZWFoZWFkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCBjdXJyZW50VHlwZWFoZWFkLCB0eXBlYWhlYWRDb21wYXJhdG9yKTtcblxuICAgICAgICAgICAgaWYgKHNvcnRlZFR5cGVhaGVhZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGhhcyB0eXBlZCBhbiBlbnRyeSB0aGF0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAvLyAob3IgbW9yZSBzcGVjaWZpY2FsbHkgXCJmb3Igd2hpY2ggdGhlcmUgaXMgbm8gZW50cnkgdGhhdCBzdGFydHMgd2l0aCB0aGF0IGlucHV0XCIpXG4gICAgICAgICAgICAgICAgc2V0SW52YWxpZFR5cGVhaGVhZCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEludmFsaWRUeXBlYWhlYWQoZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgIFdlIGtub3cgcm91Z2hseSB3aGVyZSwgaW4gdGhlIHNvcnRlZCBhcnJheSBvZiBzdHJpbmdzLCBvdXIgbmV4dCB0eXBlYWhlYWQgbG9jYXRpb24gaXMuXG4gICAgICAgICAgICAgICAgICBCdXQgcm91Z2hseSBpc24ndCBnb29kIGVub3VnaCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgIFRvIGNvbnZlcnQgb3VyIHNvcnRlZCBpbmRleCB0byB0aGUgdW5zb3J0ZWQgaW5kZXggd2UgbmVlZCwgd2UgaGF2ZSB0byBmaW5kIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgZWxlbWVudCB0aGF0IG1hdGNoZXMgdXMgKmFuZCogKGlmIGFueSBzdWNoIGV4aXN0KSBpcyAqYWZ0ZXIqIG91ciBjdXJyZW50IHNlbGVjdGlvbi5cblxuICAgICAgICAgICAgICAgICAgSW4gb3RoZXIgd29yZHMsIHRoZSBvbmx5IHdheSB0eXBlYWhlYWQgbW92ZXMgYmFja3dhcmRzIHJlbGF0aXZlIHRvIG91ciBjdXJyZW50XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiBpcyBpZiB0aGUgb25seSBvdGhlciBvcHRpb24gaXMgYmVoaW5kIHVzLlxuXG4gICAgICAgICAgICAgICAgICBJdCdzIG5vdCBzcGVjaWZpZWQgaW4gV0FJLUFSSUEgd2hhdCB0byBkbyBpbiB0aGF0IGNhc2UuICBJIHN1cHBvc2Ugd3JhcCBiYWNrIHRvIHRoZSBzdGFydD9cbiAgICAgICAgICAgICAgICAgIFRob3VnaCB0aGVyZSdzIGFsc28gYSBjYXNlIGZvciBqdXN0IGdvaW5nIHVwd2FyZHMgdG8gdGhlIG5lYXJlc3QgdG8gcHJldmVudCBqdW1waW5lc3MuXG4gICAgICAgICAgICAgICAgICBCdXQgaWYgeW91J3JlIGFscmVhZHkgZG9pbmcgdHlwZWFoZWFkIG9uIGFuIHVuc29ydGVkIGxpc3QsIGxpa2UsIGp1bXBpbmVzcyBjYW4ndCBiZSBhdm9pZGVkLlxuICAgICAgICAgICAgICAgICAgSSBkdW5uby4gR29pbmcgYmFjayB0byB0aGUgc3RhcnQgaXMgdGhlIHNpbXBsaXN0IHRob3VnaC5cblxuICAgICAgICAgICAgICAgICAgQmFzaWNhbGx5IHdoYXQgdGhpcyBkb2VzOiBTdGFydGluZyBmcm9tIHdoZXJlIHdlIGZvdW5kIG91cnNlbHZlcyBhZnRlciBvdXIgYmluYXJ5IHNlYXJjaCxcbiAgICAgICAgICAgICAgICAgIHNjYW4gYmFja3dhcmRzIGFuZCBmb3J3YXJkcyB0aHJvdWdoIGFsbCBhZGphY2VudCBlbnRyaWVzIHRoYXQgYWxzbyBjb21wYXJlIGVxdWFsbHkgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgd2UgY2FuIGZpbmQgdGhlIG9uZSB3aG9zZSBgdW5zb3J0ZWRJbmRleGAgaXMgdGhlIGxvd2VzdCBhbW9uZ3N0IGFsbCBvdGhlciBlcXVhbCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAoYW5kIGFsc28gdGhlIGxvd2VzdCBgdW5zb3J0ZWRJbmRleGAgeWFkZGEgeWFkZGEgZXhjZXB0IHRoYXQgaXQgY29tZXMgYWZ0ZXIgdXMpLlxuXG4gICAgICAgICAgICAgICAgICBUT0RPOiBUaGUgYmluYXJ5IHNlYXJjaCBzdGFydHMgdGhpcyBvZmYgd2l0aCBhIHNvbGlkIE8obG9nIG4pLCBidXQgb25lLWNoYXJhY3RlciBcbiAgICAgICAgICAgICAgICAgIHNlYXJjaGVzIGFyZSwgdGhhbmtzIHRvIHBpZ2VvbmhvbGUgcHJpbmNpcGFsLCBldmVudHVhbGx5IGd1YXJhbnRlZWQgdG8gYmVjb21lIFxuICAgICAgICAgICAgICAgICAgTyhuKmxvZyBuKS4gVGhpcyBpcyBhbm5veWluZyBidXQgcHJvYmFibHkgbm90IGVhc2lseSBzb2x2YWJsZT8gVGhlcmUgY291bGQgYmUgYW4gXG4gICAgICAgICAgICAgICAgICBleGNlcHRpb24gZm9yIG9uZS1jaGFyYWN0ZXIgc3RyaW5ncywgYnV0IHRoYXQncyBqdXN0IGtpY2tpbmcgdGhlIGNhbiBkb3duIFxuICAgICAgICAgICAgICAgICAgdGhlIHJvYWQuIE1heWJlIG9uZSBvciB0d28gY2hhcmFjdGVycyB3b3VsZCBiZSBnb29kIGVub3VnaCB0aG91Z2guXG4gICAgICAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY2FuZGlkYXRlcycgcG9zaXRpb25zIGluIGJvdGggb3VyIHNvcnRlZCBhcnJheSBhbmQgdGhlIHVuc29ydGVkIERPTS5cbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4QWxsID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSB0d28gYXJlIG9ubHkgc2V0IGZvciBlbGVtZW50cyB0aGF0IGFyZSBhaGVhZCBvZiB1cywgYnV0IHRoZSBwcmluY2lwbGUncyB0aGUgc2FtZSBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUJlc3RGaXQgPSAodTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U29ydGVkSW5kZXhBbGwgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPT0gbnVsbCB8fCB1IDwgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQpICYmIHUgPiAoZ2V0SW5kZXgoKSA/PyAtSW5maW5pdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9IHU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGkgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIHR5cGVhaGVhZENvbXBhcmF0b3IoY3VycmVudFR5cGVhaGVhZCwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50Lmxlbmd0aCAmJiB0eXBlYWhlYWRDb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5kZXgoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2xvd2VzdFNvcnRlZEluZGV4TmV4dF0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleEFsbCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5kZXgoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2xvd2VzdFNvcnRlZEluZGV4QWxsXS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtjdXJyZW50VHlwZWFoZWFkXSk7XG5cbiAgICBjb25zdCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ+KCh7IGluZGV4LCB0ZXh0IH0pID0+IHtcblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRleHQpIHtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgd2hlcmUgdG8gaW5zZXJ0IHRoaXMgaXRlbS5cbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIGFsbCBpbmRleCB2YWx1ZXMgc2hvdWxkIGJlIHVuaXF1ZSwgdGhlIHJldHVybmVkIHNvcnRlZEluZGV4XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGFsd2F5cyByZWZlciB0byBhIG5ldyBsb2NhdGlvbiAoaS5lLiBiZSBuZWdhdGl2ZSkgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCB0ZXh0LCBpbnNlcnRpbmdDb21wYXJhdG9yKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDAgfHwgaW5zZXJ0aW5nQ29tcGFyYXRvcihzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbc29ydGVkSW5kZXhdLnRleHQsIHsgdW5zb3J0ZWRJbmRleDogaW5kZXgsIHRleHQgfSkgPT0gMCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKC1zb3J0ZWRJbmRleCAtIDEsIDAsIHsgdGV4dCwgdW5zb3J0ZWRJbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKHNvcnRlZEluZGV4LCAwLCB7IHRleHQsIHVuc29ydGVkSW5kZXg6IGluZGV4IH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdW5tb3VudGluZywgZmluZCB3aGVyZSB3ZSB3ZXJlIGFuZCByZW1vdmUgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBBZ2Fpbiwgd2Ugc2hvdWxkIGFsd2F5cyBmaW5kIG91cnNlbHZlcyBiZWNhdXNlIHRoZXJlIHNob3VsZCBiZSBubyBkdXBsaWNhdGUgdmFsdWVzIGlmIGVhY2ggaW5kZXggaXMgdW5pcXVlLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIHRleHQsIGluc2VydGluZ0NvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDAgfHwgaW5zZXJ0aW5nQ29tcGFyYXRvcihzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbc29ydGVkSW5kZXhdLnRleHQsIHsgdW5zb3J0ZWRJbmRleDogaW5kZXgsIHRleHQgfSkgPT0gMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2Uoc29ydGVkSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbdGV4dF0pO1xuXG4gICAgICAgIHJldHVybjtcblxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzLFxuXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXG4gICAgICAgICAgICBpbnZhbGlkVHlwZWFoZWFkLFxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogWW91ciB1c3VhbCBiaW5hcnkgc2VhcmNoIGltcGxlbWVudGF0aW9uLlxuICogXG4gKiBJdCdzIHVzZWQgaGVyZSB0byBxdWlja2x5IGZpbmQgYSBnb29kIHNwb3QgdG8gc3RhcnQgc2VhcmNoaW5nIGZvciBvdXIgbmV4dCB0eXBlYWhlYWQgY2FuZGlkYXRlLlxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2ggdGhyb3VnaFxuICogQHBhcmFtIHdhbnRlZCBUaGUgdmFsdWUgeW91J2QgbGlrZSB0byBmaW5kXG4gKiBAcGFyYW0gY29tcGFyYXRvciBDb21wYXJlcyBgd2FudGVkYCB3aXRoIHRoZSBjdXJyZW50IHZhbHVlIGluIGBhcnJheWBcbiAqIEByZXR1cm5zIEEgbm9uLW5lZ2F0aXZlIHZhbHVlIGlmIGB3YW50ZWRgIHdhcyBmb3VuZCwgYW5kIGEgbmVnYXRpdmUgbnVtYmVyIGlmIG5vdC4gXG4gKiBUaGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBudW1iZXIsIG1pbnVzIG9uZSwgaXMgd2hlcmUgYHdhbnRlZGAgKndvdWxkKiBiZSBmb3VuZCBpZiBpdCAqd2FzKiBpbiBgYXJyYXlgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2g8VCwgVSwgRiBleHRlbmRzIChsaHM6IFUsIHJoczogVCkgPT4gbnVtYmVyPihhcnJheTogVFtdLCB3YW50ZWQ6IFUsIGNvbXBhcmF0b3I6IEYpOiBudW1iZXIge1xuICAgIGxldCBmaXJzdEluZGV4ID0gMDtcbiAgICBsZXQgbGFzdEluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoZmlyc3RJbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgdGVzdEluZGV4ID0gKGxhc3RJbmRleCArIGZpcnN0SW5kZXgpID4+IDE7XG4gICAgICAgIGNvbnN0IGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJhdG9yKHdhbnRlZCwgYXJyYXlbdGVzdEluZGV4XSk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgICAgICBmaXJzdEluZGV4ID0gdGVzdEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gdGVzdEluZGV4IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLWZpcnN0SW5kZXggLSAxO1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW5PbWl0cywgT25DaGlsZHJlbk1vdW50Q2hhbmdlLCB1c2VDaGlsZHJlbkZsYWcsIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlSGFzRm9jdXMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHJldHVyblplcm8sIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5cbi8vZXhwb3J0IHR5cGUgVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm88SyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvQmFzZTxLPj4gPSBSZXF1aXJlZDxJPiAmIEZsYWdnYWJsZUNoaWxkSW5mbzxcInRhYmJhYmxlXCI+ICYge1xuLy99O1xuXG5leHBvcnQgdHlwZSBPblRhYmJhYmxlSW5kZXhDaGFuZ2UgPSAodGFiYmFibGVJbmRleDogbnVtYmVyIHwgbnVsbCkgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88RSBleHRlbmRzIEVsZW1lbnQsIEM+IHtcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0YWJiaW5nIHRocm91Z2ggdGhpcyBjb21wb25lbnQgd2lsbCBjYXVzZSB0aGUgcmVmZXJlbmNlZCBlbGVtZW50IHRvIGJlIGZvY3VzZWQuXG4gICAgICogXG4gICAgICogWW91IGNhbiBvdmVycmlkZSB0aGlzIGJlaGF2aW9yIHRvIGRvIHNvbWV0aGluZyBkaWZmZXJlbnQgaWYgeW91J2QgbGlrZS5cbiAgICAgKi9cbiAgICBmb2N1c1NlbGYoKTogdm9pZDtcblxuICAgIGJsdXJTZWxmKCk6IHZvaWQ7XG5cbiAgICBnZXRFbGVtZW50KCk6IEUgfCBudWxsO1xuXG4gICAgaGlkZGVuOiBib29sZWFuO1xuXG4gICAgc3ViSW5mbzogQztcbn1cblxuaW50ZXJmYWNlIFJUSVAge1xuICAgIC8vIENhbGxlZCBkdXJpbmcgYW4gZWZmZWN0IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIHJlbmRlcmVkIGl0c2VsZiBpbiBhIHRhYmJhYmxlIHN0YXRlXG4gICAgb25UYWJiYWJsZVJlbmRlcj86IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPzogT25UYWJiYWJsZUluZGV4Q2hhbmdlO1xuXG4gICAgb25UYWJiZWRJblRvPzogKCkgPT4gdm9pZDtcbiAgICBvblRhYmJlZE91dE9mPzogKCkgPT4gdm9pZDtcblxuICAgIGluaXRpYWxJbmRleD86IG51bWJlcjtcbn1cbmV4cG9ydCB0eXBlIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzID0ga2V5b2YgUlRJUDtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPG51bWJlciwgTWNPbWl0cz4ge1xuICAgIHJvdmluZ1RhYkluZGV4OiBPbWl0PFJUSVAsIFJ0aU9taXRzPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVJbmZvPFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88bnVtYmVyLCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG4gICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgc2V0VGFiYmFibGVJbmRleDogKHVwZGF0ZXI6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0VGFiYmFibGVJbmRleDogKCkgPT4gbnVtYmVyIHwgbnVsbDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZm9jdXNTZWxmOiAoKSA9PiB2b2lkO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCI+XG57XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkOiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz47XG59XG5cbmV4cG9ydCB0eXBlIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cyA9IGtleW9mIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxhbnksIGFueT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZywgUnRpY09taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiBleHRlbmRzXG4gICAgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxudW1iZXIsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxhbnksIFJ0aVN1YkluZm8+LCBFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiLCBNY09taXRzIHwgXCJzdWJJbmZvXCI+IHtcbiAgICByb3ZpbmdUYWJJbmRleDogT21pdDxQYXJ0aWFsPE9taXQ8VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgYW55PiwgXCJnZXRFbGVtZW50XCIgfCBcInN1YkluZm9cIj4+LCBSdGljT21pdHM+O1xuICAgIHN1YkluZm86IFN1YmJlc3RJbmZvO1xufVxuXG5leHBvcnQgdHlwZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMsIG5ldmVyLCBuZXZlciwgUnRpU3ViSW5mbz4pID0+IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICB0YWJiYWJsZTogYm9vbGVhbjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0VGFiYmFibGUoKTogYm9vbGVhbjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0RWxlbWVudCgpOiBDaGlsZEVsZW1lbnQgfCBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50Pjtcbn1cblxuXG4vKipcbiAqIEltcGxlbWVudHMgYSByb3ZpbmcgdGFiaW5kZXggc3lzdGVtIHdoZXJlIG9ubHkgb25lIFwiZm9jdXNhYmxlXCJcbiAqIGNvbXBvbmVudCBpbiBhIHNldCBpcyBhYmxlIHRvIHJlY2VpdmUgYSB0YWIgZm9jdXMuICpXaGljaCpcbiAqIG9mIHRob3NlIGVsZW1lbnRzIHJlY2VpdmVzIGZvY3VzIGlzIGRldGVybWluZWQgYnkgeW91LCBidXQgaXQnc1xuICogcmVjb21tZW5kZWQgdG8gb2ZmbG9hZCB0aGF0IGxvZ2ljIHRoZW4gdG8gYW5vdGhlciBob29rLCBsaWtlXG4gKiBgdXNlTGluZWFyTmF2aWdhdGlvbmAsIHdoaWNoIGxldHMgeW91IGNoYW5nZSB0aGUgdGFiYmFibGVcbiAqIGVsZW1lbnQgd2l0aCB0aGUgYXJyb3cga2V5cywgYHVzZVR5cGVhaGVhZE5hdmlnYXRpb25gLCB3aGljaFxuICogbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZSBpbmRleCB3aXRoIHR5cGVhaGVhZCwgb3JcbiAqIGB1c2VMaXN0TmF2aWdhdGlvbmAgaWYgeW91IGp1c3Qgd2FudCBldmVyeXRoaW5nIGJ1bmRsZWQgdG9nZXRoZXIuXG4gKiBcbiAqIE5vdGUgdGhhdCB0aGUgY2hpbGQgaG9vayByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZFxuICogYnkgZXZlcnkgY2hpbGQgdGhhdCB1c2VzIHRoaXMgcm92aW5nIHRhYmluZGV4IGxvZ2ljLiAgVGhlXG4gKiBwcm9wLW1vZGlmeWluZyBob29rICp0aGF0KiBob29rIHJldHVybnMgc2hvdWxkIHRoZW4gYmUgdXNlZFxuICogb24gdGhlIGNoaWxkJ3MgZWxlbWVudCwgYXMgd2VsbCBhcyBhbnkgb3RoZXIgZWxlbWVudHMgeW91J2QgbGlrZVxuICogdG8gYmUgZXhwbGljaXRseSBtYWRlIHVudGFiYmFibGUgdG9vLlxuICogXG4gKiBgc2hvdWxkRm9jdXNPbkNoYW5nZWAgc2hvdWxkIHJldHVybiB0cnVlIGlmIGZvY3VzIGlzIFxuICogY29udGFpbmVkIHdpdGhpbiB3aGF0ZXZlciBlbGVtZW50IGNvbnRhaW5zIHRoZSByb3ZpbmcgdGFiIGluZGV4LlxuICogR2VuZXJhbGx5IGFzIHNpbXBsZSBhcyB0aGUgZm9sbG93aW5nOlxuICogYGBgXG4gKiBjb25zdCBbZm9jdXNlZElubmVyLCBzZXRGb2N1c2VkSW5uZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICogY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxQYXJlbnRFbGVtZW50Pih7IHNldEZvY3VzZWRJbm5lciB9KTtcbiAqIGNvbnN0IGZvY3VzT25DaGFuZ2UgPSAoZm9jdXNlZElubmVyICE9IGZhbHNlKTtcbiAqIGBgYFxuICogSXQncyBub3QgaW5jbHVkZWQgaGVyZSBiZWNhdXNlIGB1c2VSb3ZpbmdUYWJJbmRleGAgZG9lc24ndCBrbm93IFxuICogYW55dGhpbmcgYWJvdXQgdGhlIGNvbnRhaW5lciBlbGVtZW50LCBvbmx5IGNoaWxkcmVuIGVsZW1lbnRzLlxuICogQW5kIGp1c3QgYXMgd2VsbCEgQ2hpbGRyZW4gc2hvdWxkIGJlIGFsbG93ZWQgYXQgdGhlIHJvb3QsIFxuICogcmVnYXJkbGVzcyBvZiBpZiBpdCdzIHRoZSB3aG9sZSBhcHAgb3IganVzdCBhIGdpdmVuIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdmluZ1RhYkluZGV4PENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+KHBhcmVudFBhcmFtZXRlcnM6IFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczxuZXZlciwgbmV2ZXI+KTogVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4ge1xuXG4gICAgbGV0IHsgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJlZEluVG8sIG9uVGFiYmVkT3V0T2YsIG9uVGFiYmFibGVSZW5kZXIsIG9uVGFiYmFibGVJbmRleENoYW5nZSB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9ID0gcGFyZW50UGFyYW1ldGVycztcblxuICAgIGluaXRpYWxJbmRleCA/Pz0gMDtcbiAgICBjb25zdCBzdGFibGVPblRhYmJhYmxlUmVuZGVyID0gdXNlU3RhYmxlQ2FsbGJhY2sob25UYWJiYWJsZVJlbmRlciA/PyAoKCkgPT4geyB9KSk7XG4gICAgY29uc3QgW19nZXRBbnlGb2N1c2VkLCBzZXRBbnlGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxudW1iZXI+KHVzZVN0YWJsZUNhbGxiYWNrKChuZXdDb3VudDogbnVtYmVyLCBvbGRDb3VudDogbnVtYmVyIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgIGlmIChvbGRDb3VudCA9PSAwICYmIG5ld0NvdW50ID4gMCkge1xuICAgICAgICAgICAgb25UYWJiZWRJblRvPy4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdDb3VudCA9PSAwICYmIChvbGRDb3VudCA/PyAwKSA+IDApIHtcbiAgICAgICAgICAgIG9uVGFiYmVkT3V0T2Y/LigpO1xuICAgICAgICB9XG4gICAgfSksIHJldHVyblplcm8pO1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aHJlZSB0aGluZ3MgcmVsYXRlZCB0byB0aGUgY3VycmVudGx5IHRhYmJhYmxlIGVsZW1lbnQncyBpbmRleDpcbiAgICAvLyBXaGF0IGl0IGlzLCBhbmQgd2hldGhlciwgd2hlbiB3ZSByZW5kZXIgdGhpcyBjb21wb25lbnQgYW5kIGl0J3MgY2hhbmdlZCwgdG8gYWxzbyBmb2N1cyB0aGUgZWxlbWVudCB0aGF0IHdhcyBtYWRlIHRhYmJhYmxlLlxuICAgIGNvbnN0IFtnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4Ml0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyIHwgbnVsbD4ob25UYWJiYWJsZUluZGV4Q2hhbmdlLCB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiBpbml0aWFsSW5kZXggPz8gMCB9LCBbXSkpO1xuICAgIGNvbnN0IHNldFRhYmJhYmxlSW5kZXggPSB1c2VDYWxsYmFjaygodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7XG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXgyKChwcmV2SW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXBkYXRlciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IHVwZGF0ZXIocHJldkluZGV4ID8/IG51bGwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IHVwZGF0ZXI7XG5cbiAgICAgICAgICAgIG5leHRJbmRleCA9IGNoYW5nZUluZGV4KG5leHRJbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2SW5kZXggIT0gbmV4dEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4uZ2V0QXQobmV4dEluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBwcmV2SW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbi5nZXRBdChwcmV2SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZDaGlsZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBwcmV2Q2hpbGQuc3ViSW5mby5ibHVyU2VsZigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZCAhPSBudWxsICYmIGZyb21Vc2VySW50ZXJhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGlsZC5zdWJJbmZvLmZvY3VzU2VsZigpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0SW5kZXg7XG4gICAgICAgIH0pO1xuXG4gICAgfSwgW10pO1xuXG4gICAgLy8gQW55IHRpbWUgdGhlIHRhYmJhYmxlIGluZGV4IGNoYW5nZXMsXG4gICAgLy8gbm90aWZ5IHRoZSBwcmV2aW91cyBjaGlsZCB0aGF0IGl0J3Mgbm8gbG9uZ2VyIHRhYmJhYmxlLFxuICAgIC8vIGFuZCBub3RpZnkgdGhlIG5leHQgY2hpbGQgdGhhdCBpcyBhbGxvd2VkIHRvIGJlIHRhYmJlZCB0by5cbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCI+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7XG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobW91bnRlZCwgdW5tb3VudGVkKSA9PiB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKG1vdW50ZWQsIHVubW91bnRlZCk7IHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7IH0pLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGQgfSA9IHBhcmVudFJldHVyblR5cGU7XG5cbiAgICBjb25zdCB7IGNoYW5nZUluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdCB9ID0gdXNlQ2hpbGRyZW5GbGFnPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8+LCBFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiPih7IGluaXRpYWxJbmRleCwgY2hpbGRyZW46IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLCBjbG9zZXN0Rml0OiB0cnVlLCBrZXk6IFwidGFiYmFibGVcIiB9KTtcblxuICAgIGNvbnN0IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQgPSB1c2VDYWxsYmFjazxVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4+KChjaGlsZFBhcmFtZXRlcnMpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN1YkluZm8sIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHsgaGlkZGVuLCBibHVyU2VsZjogYmx1clNlbGZPdmVycmlkZSwgZm9jdXNTZWxmOiBmb2N1c1NlbGZPdmVycmlkZSB9IH0gPSBjaGlsZFBhcmFtZXRlcnM7XG5cbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7XG4gICAgICAgIH0sIFshIWhpZGRlbl0pXG5cblxuICAgICAgICBjb25zdCBic092ZXJyaWRlID0gdXNlU3RhYmxlR2V0dGVyKGJsdXJTZWxmT3ZlcnJpZGUpO1xuICAgICAgICBjb25zdCBmc092ZXJyaWRlID0gdXNlU3RhYmxlR2V0dGVyKGZvY3VzU2VsZk92ZXJyaWRlKTtcbiAgICAgICAgY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnMgPSBmc092ZXJyaWRlKCk7XG4gICAgICAgICAgICBpZiAoZnMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFske2luZGV4fV0uZm9jdXNTZWxmIChvdmVycmlkZSlgKTtcbiAgICAgICAgICAgICAgICBmcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRbJHtpbmRleH1dLmZvY3VzU2VsZiAoZGVmYXVsdClgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpIGFzIChFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzPy4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgICAgICBjb25zdCBibHVyU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJzID0gYnNPdmVycmlkZSgpO1xuICAgICAgICAgICAgaWYgKGJzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRbJHtpbmRleH1dLmJsdXJTZWxmIChvdmVycmlkZSlgKTtcbiAgICAgICAgICAgICAgICBicygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRbJHtpbmRleH1dLmJsdXJTZWxmIChkZWZhdWx0KWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCkgYXMgKEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYmx1cj8uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBjb25zdCBvbkZvY3VzZWRJbm5lckNoYW5nZWQgPSB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgc2V0QW55Rm9jdXNlZChwcmV2ID0+IChmb2N1c2VkID8gKChwcmV2ID8/IDApICsgMSkgOiAoKHByZXYgPz8gMCkgLSAxKSkpO1xuICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ2hpbGQgJHtpbmRleH0gaGFzIGJlZW4gZm9jdXNlZCBhbmQgd2lsbCBzZXQgaXRzZWxmIGFzIHRoZSB0YWJiYWJsZSBjaGlsZGApO1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxDaGlsZEVsZW1lbnQ+KHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkIH0pO1xuXG4gICAgICAgIGNvbnN0IFt0YWJiYWJsZSwgc2V0VGFiYmFibGUsIGdldFRhYmJhYmxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAgICAgY29uc3QgdGFiYmFibGVGbGFncyA9IHVzZVJlZjxDaGlsZEZsYWdPcGVyYXRpb25zPih7IGdldDogZ2V0VGFiYmFibGUsIHNldDogc2V0VGFiYmFibGUsIGlzVmFsaWQ6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+ICFoaWRkZW4pIH0pO1xuXG4gICAgICAgIGNvbnN0IF86IHZvaWQgPSB1c2VNYW5hZ2VkQ2hpbGQoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHsgLi4uZmxhZ3MsIHRhYmJhYmxlOiB0YWJiYWJsZUZsYWdzLmN1cnJlbnQgfSBhcyBQYXJ0aWFsPFJlY29yZDxFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiLCBDaGlsZEZsYWdPcGVyYXRpb25zPj4sXG4gICAgICAgICAgICAgICAgc3ViSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICBibHVyU2VsZixcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNTZWxmLFxuICAgICAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46ICEhaGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICBzdWJJbmZvXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWJiYWJsZSlcbiAgICAgICAgICAgICAgICBzdGFibGVPblRhYmJhYmxlUmVuZGVyKGluZGV4KTtcbiAgICAgICAgfSwgW3RhYmJhYmxlLCBpbmRleF0pXG4gICAgICAgIGZ1bmN0aW9uIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4ge1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQocHJvcHMudGFiSW5kZXggPT0gbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50Pih1c2VIYXNGb2N1c1Byb3BzKHsgdGFiSW5kZXg6IHRhYmJhYmxlID8gMCA6IC0xIH0pLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGB1c2VSb3ZpbmdUYWJJbmRleC5mb2N1c1NlbGZgKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRUYWJiYWJsZUluZGV4KCk7XG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKVxuICAgICAgICAgICAgcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4uZ2V0QXQoaW5kZXgpPy5zdWJJbmZvLmZvY3VzU2VsZj8uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobnVsbCwgdHJ1ZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbiB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleCxcbiAgICAgICAgICAgIGdldFRhYmJhYmxlSW5kZXgsXG4gICAgICAgICAgICBmb2N1c1NlbGYsXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKmZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgZm9jdXNTZWxmLCBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4LCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCB9ID0gdXNlUm92aW5nVGFiSW5kZXg8SFRNTERpdkVsZW1lbnQsIHsgXCJmb29cIjogXCJiYXJcIiB9LCBcImZsYWcyXCI+KHsgbWFuYWdlZENoaWxkcmVuOiB7fSwgcm92aW5nVGFiSW5kZXg6IHt9IH0pO1xuICAgIGNvbnN0IHsgfSA9IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQoeyBtYW5hZ2VkQ2hpbGRyZW46IHsgaW5kZXg6IDAsIGZsYWdzOiB7fSB9LCBydGk6IHsgaW5mbzM6IHsgZm9vOiBcImJhclwiIH0gfSB9KTtcbn0qL1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlBcnJheTtcbiIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUmFuZG9tO1xuIiwiaW1wb3J0IGJhc2VSYW5kb20gZnJvbSAnLi9fYmFzZVJhbmRvbS5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gIH1cbiAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaHVmZmxlU2VsZjtcbiIsImltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBzaHVmZmxlU2VsZiBmcm9tICcuL19zaHVmZmxlU2VsZi5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5U2h1ZmZsZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TWFwO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VWYWx1ZXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVGltZXM7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNBcmd1bWVudHM7XG4iLCJpbXBvcnQgYmFzZUlzQXJndW1lbnRzIGZyb20gJy4vX2Jhc2VJc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuaW1wb3J0IHN0dWJGYWxzZSBmcm9tICcuL3N0dWJGYWxzZS5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCdWZmZXI7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSW5kZXg7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5hcnk7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcbiIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcbiIsImltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlcztcbiIsImltcG9ydCBzaHVmZmxlU2VsZiBmcm9tICcuL19zaHVmZmxlU2VsZi5qcyc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJy4vdmFsdWVzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2h1ZmZsZTtcbiIsImltcG9ydCBhcnJheVNodWZmbGUgZnJvbSAnLi9fYXJyYXlTaHVmZmxlLmpzJztcbmltcG9ydCBiYXNlU2h1ZmZsZSBmcm9tICcuL19iYXNlU2h1ZmZsZS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICovXG5mdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaHVmZmxlO1xuIiwiaW1wb3J0ICogYXMgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE11dGFibGVSZWYsIHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZEluZm8sIE1hbmFnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VGb3JjZVVwZGF0ZSB9IGZyb20gXCIuL3VzZS1mb3JjZS11cGRhdGVcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCBsb2Rhc2hTaHVmZmxlIGZyb20gXCJsb2Rhc2gtZXMvc2h1ZmZsZVwiO1xuXG5leHBvcnQgdHlwZSBHZXRJbmRleDxDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChyb3c6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPikgPT4gKG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQpO1xuZXhwb3J0IHR5cGUgR2V0VmFsdWU8QywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWPiA9IChyb3c6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPiwgLi4uYXJnczogRykgPT4gVjtcbmV4cG9ydCB0eXBlIENvbXBhcmU8Vj4gPSAobGhzOiBWLCByaHM6IFYpID0+IG51bWJlcjtcblxuLyoqXG4gKiBBbGwgb2YgdGhlc2UgZnVuY3Rpb25zICoqTVVTVCoqIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcblxuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuLCBlLmcuLCB0aGUgcm93IGluZGV4IG9mIHRoaXMgY2hpbGRcbiAgICAgKiAoVXN1YWxseSBqdXN0IGFuIGBpbmRleGAgcHJvcClcbiAgICAgKi9cbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXg6IEdldEluZGV4PEMsIEs+OyB9XG59XG5cbi8qKlxuICogQWxsIG9mIHRoZXNlIGZ1bmN0aW9ucyAqKk1VU1QqKiBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWPiBleHRlbmRzIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSz4ge1xuICAgIHNvcnRhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11c3QgcmV0dXJuIHRoZSB2YWx1ZSB0aGlzIGNoaWxkIHVzZXMgUkU6IHNvcnRpbmcuXG4gICAgICAgICAqIElmIHlvdSBkb24ndCBjYXJlIGFib3V0IHNvcnRpbmcgKHlvdSBqdXN0IHVzZSBcbiAgICAgICAgICogeW91ciBvd25hcmJpdHJhcnkgcmVvcmRlcmluZyksIHRoaXMgd2lsbCBuZXZlclxuICAgICAgICAgKiBiZSB1c2VkLCBzbyBpdCBjYW4gcmV0dXJuIGFueXRoaW5nLlxuICAgICAgICAgKiBAcGFyYW0gcm93IFxuICAgICAgICAgKiBAcGFyYW0gYXJncyBcbiAgICAgICAgICovXG4gICAgICAgIGdldFZhbHVlOiBHZXRWYWx1ZTxDLCBLLCBHLCBWPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbHMgaG93IHZhbHVlcyBjb21wYXJlIGFnYWluc3QgZWFjaCBvdGhlci5cbiAgICAgICAgICogQHBhcmFtIGxocyBcbiAgICAgICAgICogQHBhcmFtIHJocyBcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBhcmU6IENvbXBhcmU8Vj47XG4gICAgfVxufVxuXG5cblxuLyoqXG4gKiBIb29rIHRoYXQgYWxsb3dzIGZvciB0aGUgKipkaXJlY3QgZGVzY2VuZGFudCoqIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IHRvIGJlIHJlLW9yZGVyZWQgYW5kIHNvcnRlZC5cbiAqIFxuICogKlRoaXMgaXMgKipzZXBhcmF0ZSoqIGZyb20gXCJtYW5hZ2VkXCIgY2hpbGRyZW4sIHdoaWNoIGNhbiBiZSBhbnkgbGV2ZWwgb2YgY2hpbGQgbmVlZGVkISBTb3J0YWJsZS9yZWFycmFuZ2VhYmxlIGNoaWxkcmVuIG11c3QgYmUgKipkaXJlY3QgZGVzY2VuZGFudHMqKiBvZiB0aGUgcGFyZW50IHRoYXQgdXNlcyB0aGlzIGhvb2shKlxuICogXG4gKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uYDsgaXQgdGFrZXMgdGhlIHNhbWUgYGluZGV4TWFuZ2xlcmAgYW5kIGBpbmRleERlbWFuZ2xlcmAgXG4gKiBmdW5jdGlvbnMgdGhhdCB0aGlzIGhvb2sgcmV0dXJucy4gYHVzZUxpc3ROYXZpZ2F0aW9uYCBkb2VzIG5vdCBkaXJlY3RseSB1c2UgdGhpcyBob29rIGJlY2F1c2UsIGFzIG1lbnRpb25lZCwgXG4gKiB0aGlzIGhvb2sgaW1wb3NlcyBzZXJpb3VzIHJlc3RyaWN0aW9ucyBvbiBjaGlsZCBzdHJ1Y3R1cmUsIHdoaWxlIGB1c2VMaXN0TmF2aWdhdGlvbmAgYWxsb3dzIGFueXRoaW5nLlxuICogXG4gKiBCZXNpZGVzIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIHRoYXQncyByZXR1cm5lZCwgdGhlIGBzb3J0YCBmdW5jdGlvbiB0aGF0J3MgcmV0dXJuZWQgd2lsbFxuICogc29ydCBhbGwgY2hpbGRyZW4gYWNjb3JkaW5nIHRvIHRoZWlyIHZhbHVlIGZyb20gdGhlIGBnZXRWYWx1ZWAgYXJndW1lbnQgeW91IHBhc3MgaW4uXG4gKiBcbiAqIElmIHlvdSB3YW50IHRvIHBlcmZvcm0gc29tZSByZS1vcmRlcmluZyBvcGVyYXRpb24gdGhhdCdzICpub3QqIGEgc29ydCwgeW91IGNhbiBtYW51YWxseVxuICogcmUtbWFwIGVhY2ggY2hpbGQncyBwb3NpdGlvbiB1c2luZyBgbWFuZ2xlTWFwYCBhbmQgYGRlbWFuZ2xlTWFwYCwgd2hpY2ggY29udmVydCBiZXR3ZWVuXG4gKiBzb3J0ZWQgYW5kIHVuc29ydGVkIGluZGV4IHBvc2l0aW9ucy5cbiAqIFxuICogQWdhaW4sIHVubGlrZSBzb21lIG90aGVyIGhvb2tzLCAqKnRoZXNlIGNoaWxkcmVuIG11c3QgYmUgZGlyZWN0IGRlc2NlbmRhbnRzKiouIFRoaXMgaXMgYmVjYXVzZVxuICogdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgaW5zcGVjdHMgdGhlIGdpdmVuIGNoaWxkcmVuLCB0aGVuIHJlLWNyZWF0ZXMgdGhlbSB3aXRoIG5ldyBga2V5YHMuXG4gKiBCZWNhdXNlIGtleXMgYXJlIGdpdmVuIHNwZWNpYWwgdHJlYXRtZW50IGFuZCBhIGNoaWxkIGhhcyBubyB3YXkgb2YgbW9kaWZ5aW5nIGl0cyBvd24ga2V5XG4gKiB0aGVyZSdzIG5vIG90aGVyIHRpbWUgb3IgcGxhY2UgdGhpcyBjYW4gaGFwcGVuIG90aGVyIHRoYW4gZXhhY3RseSB3aXRoaW4gdGhlIHBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4IH0gfTogVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLPik6IFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQywgSz4ge1xuXG4gICAgLy8gVGhlc2UgYXJlIHVzZWQgdG8ga2VlcCB0cmFjayBvZiBhIG1hcHBpbmcgYmV0d2VlbiB1bnNvcnRlZCBpbmRleCA8LS0tPiBzb3J0ZWQgaW5kZXguXG4gICAgLy8gVGhlc2UgYXJlIG5lZWRlZCBmb3IgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzLlxuICAgIGNvbnN0IG1hbmdsZU1hcCA9IHVzZVJlZihuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpKTtcbiAgICBjb25zdCBkZW1hbmdsZU1hcCA9IHVzZVJlZihuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpKTtcbiAgICBjb25zdCBpbmRleE1hbmdsZXIgPSB1c2VDYWxsYmFjaygobjogbnVtYmVyKSA9PiAobWFuZ2xlTWFwLmN1cnJlbnQuZ2V0KG4pID8/IG4pLCBbXSk7XG4gICAgY29uc3QgaW5kZXhEZW1hbmdsZXIgPSB1c2VDYWxsYmFjaygobjogbnVtYmVyKSA9PiAoZGVtYW5nbGVNYXAuY3VycmVudC5nZXQobikgPz8gbiksIFtdKTtcblxuICAgIC8vIFRoZSBzb3J0IGZ1bmN0aW9uIG5lZWRzIHRvIGJlIGFibGUgdG8gdXBkYXRlIHdob2V2ZXIgaGFzIGFsbCB0aGUgc29ydGFibGUgY2hpbGRyZW4uXG4gICAgLy8gQmVjYXVzZSB0aGF0IG1pZ2h0IG5vdCBiZSB0aGUgY29uc3VtZXIgb2YgKnRoaXMqIGhvb2sgZGlyZWN0bHkgKGUuZy4gYSB0YWJsZSB1c2VzXG4gICAgLy8gdGhpcyBob29rLCBidXQgaXQncyB0Ym9keSB0aGF0IGFjdHVhbGx5IG5lZWRzIHVwZGF0aW5nKSwgd2UgbmVlZCB0byByZW1vdGVseVxuICAgIC8vIGdldCBhbmQgc2V0IGEgZm9yY2VVcGRhdGUgZnVuY3Rpb24uXG4gICAgLy9jb25zdCBbZ2V0Rm9yY2VVcGRhdGUsIHNldEZvcmNlVXBkYXRlXSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgKCgpID0+IHZvaWQpPihudWxsLCByZXR1cm5OdWxsKTtcbiAgICBjb25zdCBbZ2V0Rm9yY2VVcGRhdGUsIHNldEZvcmNlVXBkYXRlXSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgKCgpID0+IHZvaWQpPihudWxsLCByZXR1cm5OdWxsKTtcblxuICAgIGNvbnN0IHJlYXJyYW5nZSA9IHVzZUNhbGxiYWNrKChzb3J0ZWRSb3dzOiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz5bXSkgPT4ge1xuXG4gICAgICAgIC8vIFVwZGF0ZSBvdXIgc29ydGVkIDwtLT4gdW5zb3J0ZWQgaW5kaWNlcyBtYXAgXG4gICAgICAgIC8vIGFuZCByZXJlbmRlciB0aGUgd2hvbGUgdGFibGUsIGJhc2ljYWxseVxuICAgICAgICBmb3IgKGxldCBpbmRleEFzU29ydGVkID0gMDsgaW5kZXhBc1NvcnRlZCA8IHNvcnRlZFJvd3MubGVuZ3RoOyArK2luZGV4QXNTb3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4QXNVbnNvcnRlZCA9IHNvcnRlZFJvd3NbaW5kZXhBc1NvcnRlZF0uaW5kZXg7XG5cbiAgICAgICAgICAgIG1hbmdsZU1hcC5jdXJyZW50LnNldChpbmRleEFzVW5zb3J0ZWQsIGluZGV4QXNTb3J0ZWQpO1xuICAgICAgICAgICAgZGVtYW5nbGVNYXAuY3VycmVudC5zZXQoaW5kZXhBc1NvcnRlZCwgaW5kZXhBc1Vuc29ydGVkKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgZ2V0Rm9yY2VVcGRhdGUoKT8uKCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgdXNlUmVhcnJhbmdlYWJsZVByb3BzID0gdXNlQ2FsbGJhY2soKHsgY2hpbGRyZW4sIC4uLnByb3BzIH06IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuPzogVk5vZGU8YW55PltdIH0pID0+IHtcblxuICAgICAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHNldEZvcmNlVXBkYXRlKF9wcmV2ID0+IGZvcmNlVXBkYXRlKTsgfSwgW2ZvcmNlVXBkYXRlXSlcblxuICAgICAgICByZXR1cm4gKHVzZU1lcmdlZFByb3BzPFBhcmVudEVsZW1lbnQ+KHtcbiAgICAgICAgICAgIGNoaWxkcmVuOlxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiBhcyBWTm9kZTxNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4+W10pXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoY2hpbGQgPT4gKHsgY2hpbGQsIG1hbmdsZWRJbmRleDogaW5kZXhNYW5nbGVyKGdldEluZGV4KGNoaWxkLnByb3BzISkhKSwgZGVtYW5nbGVkSW5kZXg6IGdldEluZGV4KGNoaWxkLnByb3BzKSB9KSlcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGxocywgcmhzKSA9PiB7IHJldHVybiBsaHMubWFuZ2xlZEluZGV4IC0gcmhzLm1hbmdsZWRJbmRleCB9KVxuICAgICAgICAgICAgICAgICAgICAubWFwKCh7IGNoaWxkLCBtYW5nbGVkSW5kZXgsIGRlbWFuZ2xlZEluZGV4IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoKGNoaWxkLnR5cGUgYXMgYW55LCB7IC4uLmNoaWxkLnByb3BzLCBrZXk6IGRlbWFuZ2xlZEluZGV4LCBcImRhdGEtbWFuZ2xlZC1pbmRleFwiOiBtYW5nbGVkSW5kZXgsIFwiZGF0YS11bm1hbmdsZWQtaW5kZXhcIjogZGVtYW5nbGVkSW5kZXggfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIHByb3BzKSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHsgdXNlUmVhcnJhbmdlYWJsZVByb3BzLCByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgaW5kZXhNYW5nbGVyLCBpbmRleERlbWFuZ2xlciwgbWFuZ2xlTWFwLCBkZW1hbmdsZU1hcCwgcmVhcnJhbmdlIH0gfTtcbn1cblxuXG4vKipcbiAqIEhvb2sgdGhhdCBhbGxvd3MgZm9yIHRoZSAqKmRpcmVjdCBkZXNjZW5kYW50KiogY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgdG8gYmUgcmUtb3JkZXJlZCBhbmQgc29ydGVkLlxuICogXG4gKiAqVGhpcyBpcyAqKnNlcGFyYXRlKiogZnJvbSBcIm1hbmFnZWRcIiBjaGlsZHJlbiwgd2hpY2ggY2FuIGJlIGFueSBsZXZlbCBvZiBjaGlsZCBuZWVkZWQhIFNvcnRhYmxlL3JlYXJyYW5nZWFibGUgY2hpbGRyZW4gbXVzdCBiZSAqKmRpcmVjdCBkZXNjZW5kYW50cyoqIG9mIHRoZSBwYXJlbnQgdGhhdCB1c2VzIHRoaXMgaG9vayEqIFxuICogXG4gKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uYDsgaXQgdGFrZXMgdGhlIHNhbWUgYGluZGV4TWFuZ2xlcmAgYW5kIGBpbmRleERlbWFuZ2xlcmAgXG4gKiBmdW5jdGlvbnMgdGhhdCB0aGlzIGhvb2sgcmV0dXJucy4gYHVzZUxpc3ROYXZpZ2F0aW9uYCBkb2VzIG5vdCBkaXJlY3RseSB1c2UgdGhpcyBob29rIGJlY2F1c2UsIGFzIG1lbnRpb25lZCwgXG4gKiB0aGlzIGhvb2sgaW1wb3NlcyBzZXJpb3VzIHJlc3RyaWN0aW9ucyBvbiBjaGlsZCBzdHJ1Y3R1cmUsIHdoaWxlIGB1c2VMaXN0TmF2aWdhdGlvbmAgYWxsb3dzIGFueXRoaW5nLlxuICogXG4gKiBCZXNpZGVzIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIHRoYXQncyByZXR1cm5lZCwgdGhlIGBzb3J0YCBmdW5jdGlvbiB0aGF0J3MgcmV0dXJuZWQgd2lsbFxuICogc29ydCBhbGwgY2hpbGRyZW4gYWNjb3JkaW5nIHRvIHRoZWlyIHZhbHVlIGZyb20gdGhlIGBnZXRWYWx1ZWAgYXJndW1lbnQgeW91IHBhc3MgaW4uXG4gKiBcbiAqIElmIHlvdSB3YW50IHRvIHBlcmZvcm0gc29tZSByZS1vcmRlcmluZyBvcGVyYXRpb24gdGhhdCdzICpub3QqIGEgc29ydCwgeW91IGNhbiBtYW51YWxseVxuICogcmUtbWFwIGVhY2ggY2hpbGQncyBwb3NpdGlvbiB1c2luZyBgbWFuZ2xlTWFwYCBhbmQgYGRlbWFuZ2xlTWFwYCwgd2hpY2ggY29udmVydCBiZXR3ZWVuXG4gKiBzb3J0ZWQgYW5kIHVuc29ydGVkIGluZGV4IHBvc2l0aW9ucy5cbiAqIFxuICogQWdhaW4sIHVubGlrZSBzb21lIG90aGVyIGhvb2tzLCAqKnRoZXNlIGNoaWxkcmVuIG11c3QgYmUgZGlyZWN0IGRlc2NlbmRhbnRzKiouIFRoaXMgaXMgYmVjYXVzZVxuICogdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgaW5zcGVjdHMgdGhlIGdpdmVuIGNoaWxkcmVuLCB0aGVuIHJlLWNyZWF0ZXMgdGhlbSB3aXRoIG5ldyBga2V5YHMuXG4gKiBCZWNhdXNlIGtleXMgYXJlIGdpdmVuIHNwZWNpYWwgdHJlYXRtZW50IGFuZCBhIGNoaWxkIGhhcyBubyB3YXkgb2YgbW9kaWZ5aW5nIGl0cyBvd24ga2V5XG4gKiB0aGVyZSdzIG5vIG90aGVyIHRpbWUgb3IgcGxhY2UgdGhpcyBjYW4gaGFwcGVuIG90aGVyIHRoYW4gZXhhY3RseSB3aXRoaW4gdGhlIHBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10sIFY+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4IH0sIHNvcnRhYmxlQ2hpbGRyZW46IHsgY29tcGFyZTogdXNlckNvbXBhcmUsIGdldFZhbHVlIH0gfTogVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSywgRywgVj4pOiBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDLCBLLCBHPiB7XG5cbiAgICBjb25zdCBjb21wYXJlID0gKHVzZXJDb21wYXJlID8/IGRlZmF1bHRDb21wYXJlKTtcblxuICAgIGNvbnN0IHsgdXNlUmVhcnJhbmdlYWJsZVByb3BzOiB1c2VTb3J0YWJsZVByb3BzLCAuLi5yZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlIH0gPSB1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgQywgSz4oeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXggfSB9KTtcbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyByZWFycmFuZ2UgfSB9ID0gcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZTtcbiAgICAvLyBUaGUgYWN0dWFsIHNvcnQgZnVuY3Rpb24uXG4gICAgY29uc3Qgc29ydCA9IHVzZUNhbGxiYWNrKChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4sIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiLCAuLi5hcmdzOiBHKTogUHJvbWlzZTx2b2lkPiB8IHZvaWQgPT4ge1xuXG4gICAgICAgIGNvbnN0IHNvcnRlZFJvd3MgPSBtYW5hZ2VkUm93cy5hcnJheVNsaWNlKCkuc29ydCgobGhzUm93LCByaHNSb3cpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgbGhzVmFsdWUgPSBnZXRWYWx1ZShsaHNSb3csIC4uLmFyZ3MpIGFzIGFueTtcbiAgICAgICAgICAgIGNvbnN0IHJoc1ZhbHVlID0gZ2V0VmFsdWUocmhzUm93LCAuLi5hcmdzKSBhcyBhbnk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJlKGxoc1ZhbHVlLCByaHNWYWx1ZSkgLy8gbGhzUm93LmdldE1hbmFnZWRDZWxscygpPy5bY29sdW1uXT8udmFsdWUsIHJoc1Jvdy5nZXRNYW5hZ2VkQ2VsbHMoKT8uW2NvbHVtbl0/LnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb25bMF0gPT0gXCJkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC1yZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWFycmFuZ2Uoc29ydGVkUm93cyk7XG5cbiAgICB9LCBbIC8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3Qgc2h1ZmZsZSA9IHVzZUNhbGxiYWNrKChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4pOiBQcm9taXNlPHZvaWQ+IHwgdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IHNodWZmbGVkUm93cyA9IGxvZGFzaFNodWZmbGUobWFuYWdlZFJvd3MuYXJyYXlTbGljZSgpKVxuICAgICAgICByZXR1cm4gcmVhcnJhbmdlKHNodWZmbGVkUm93cyk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjogeyBzb3J0LCBzaHVmZmxlIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZS5yZWFycmFuZ2VhYmxlQ2hpbGRyZW5cbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3MgYW4gYXJyYXkgb2Ygbm90LXNvcnRlZCBjaGlsZCBpbmZvcm1hdGlvbiB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAqIGFuZCB0aGUgY2hpbGRyZW4gd2lsbCByZS1hcnJhbmdlIHRoZW1zZWx2ZXMgdG8gbWF0Y2guXG4gICAgICAgICAqICBcbiAgICAgICAgICogKipTVEFCTEUqKlxuICAgICAgICAgKiAgXG4gICAgICAgICAqIFxuICAgICAgICAgKi9cbiAgICAgICAgcmVhcnJhbmdlOiAocm93c0luT3JkZXI6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPltdKSA9PiB2b2lkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBpbmRleE1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgbWFuZ2xlTWFwOiBNdXRhYmxlUmVmPE1hcDxudW1iZXIsIG51bWJlcj4+O1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBkZW1hbmdsZU1hcDogTXV0YWJsZVJlZjxNYXA8bnVtYmVyLCBudW1iZXI+PjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VSZWFycmFuZ2VhYmxlUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW4/OiBWTm9kZTxhbnk+W10gfCB1bmRlZmluZWQ7IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+O1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLPiB7XG4gICAgc29ydGFibGVDaGlsZHJlbjogey8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNvcnQ6IChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4sIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiLCAuLi5hcmdzOiBHKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgc2h1ZmZsZTogKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPikgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gICAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzXG4gICAgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEssIEc+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVNvcnRhYmxlUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW4/OiBWTm9kZTxhbnk+W10gfCB1bmRlZmluZWQ7IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGxoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkLCByaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjb21wYXJlMShsaHMsIHJocyk7XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlMyhsaHM6IHN0cmluZyB8IG51bWJlciwgcmhzOiBzdHJpbmcgfCBudW1iZXIpIHtcblxuICAgICAgICAvLyBDb2VyY2Ugc3RyaW5ncyB0byBudW1iZXJzIGlmIHRoZXkgc2VlbSB0byBzdGF5IHRoZSBzYW1lIHdoZW4gc2VyaWFsaXplZFxuICAgICAgICBpZiAoYCR7K2xoc31gID09PSBsaHMpXG4gICAgICAgICAgICBsaHMgPSArbGhzO1xuICAgICAgICBpZiAoYCR7K3Joc31gID09PSByaHMpXG4gICAgICAgICAgICByaHMgPSArcmhzO1xuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGlmIGVpdGhlciBhcmd1bWVudCBpcyBhIHN0cmluZywgdHVybiB0aGUgb3RoZXIgb25lIGludG8gb25lIHRvb1xuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJocyA9IGAke3Joc31gO1xuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGxocyA9IGAke2xoc31gO1xuXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBsaHMgPT09IHR5cGVvZiByaHMpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGxocy5sb2NhbGVDb21wYXJlKHJocyBhcyBzdHJpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiArbGhzIC0gK3JocztcblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZTIobGhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSwgcmhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJib29sZWFuXCIgfHwgbGhzIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgIGxocyA9ICtsaHM7XG4gICAgICAgIGlmICh0eXBlb2YgcmhzID09PSBcImJvb2xlYW5cIiB8fCByaHMgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICAgICAgcmhzID0gK3JocztcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUzKGxocywgcmhzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZTEobGhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhleSdyZSBib3RoIG51bGxcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxocyA9PSBudWxsIHx8IHJocyA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBPbmUgb2YgdGhlIHR3byBpcyBudWxsIC0tIGVhc3kgY2FzZVxuICAgICAgICAgICAgcmV0dXJuIGxocyAhPSBudWxsID8gMSA6IC0xXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBhcmUyKGxocywgcmhzKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW4sIE1hbmFnZWRDaGlsZHJlbk9taXRzLCB1c2VDaGlsZHJlbkZsYWcgfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcIi4vdXNlLWVmZmVjdFwiO1xuaW1wb3J0IHsgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIHVzZUxpbmVhck5hdmlnYXRpb24sIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIHVzZVR5cGVhaGVhZE5hdmlnYXRpb24sIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgdXNlUm92aW5nVGFiSW5kZXgsIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm8sIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVycywgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbywgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvIH0gZnJvbSBcIi4vdXNlLXJvdmluZy10YWJpbmRleFwiO1xuaW1wb3J0IHsgdXNlU29ydGFibGVDaGlsZHJlbiwgVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMsIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1zb3J0YWJsZS1jaGlsZHJlblwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcblxuXG4vKipcbiAqIFxuICogVE9ETzogVGhpcyB0YWJsZSB3YXMgc2NyYXBwZWQgd2hlbiB0aGlzIHdhcyBjaGFuZ2VkIHRvIGp1c3QgYWNjZXB0IGEgY29sbGF0b3IgZGlyZWN0bHksXG4gKiBidXQgaXQncyBub3QgYmFkIGZvciBhIGNvbGxhdGlvbiBjcmFzaCBjb3Vyc2UgYW5kIEkgbWlnaHQgdXNlIGl0IGFnYWluLlxuICogRXZlbiBqdXN0IGFzIGEgXCJ0aGlzIGlzIHdoeSBpdCdzIGltcG9ydGFudCBhbmQgZ29vZCB0byB1c2UgdGhlc2UgdGhpbmdzXCIgdGhpbmcuXG4gKiBcbiAqIHxMYW5nLnxUYXJnZXR8VXNlciBpbnB1dHxgYmFzZWB8YGFjY2VudGB8YGNhc2VgfGB2YXJpYW50YHxcbiAqIHwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfFxuICogfEVOfEhpfEJ5ZXzinYx84p2MfOKdjHzinYx8XG4gKiB8RU58SGl8SGl84pyFfOKchXzinIV84pyFfFxuICogfEVOfEhpfO+8qO+9iXzinIV84pyFfOKchXzinYx8XG4gKiB8RU58SGl8aGl84pyFfOKchXzinYx84p2MfFxuICogfEVOfEhpfEjDr3zinIV84p2MfOKdjHzinYx8XG4gKiB8RU58w6V8YWF84p2MfOKdjHzinYx84p2MfFxuICogfERBfMOlfGFhfOKchXzinIV84pyFfOKdjHxcbiAqIHxEQXzDpXxBQXzinIV84pyFfOKdjHzinYx8XG4gKiB8REF8w6V8QWF84pyFfOKchXzinYx84p2MfFxuICogfERBfMOlfGFBfOKdjHzinYx84p2MfOKdjHxcbiAqIHxFTnzDpXxhfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxhfOKchXzinIV84p2MfOKdjHxcbiAqIHxKUHzvqqp8552AfOKchXzinIV84pyFfOKchXxcbiAqIHxKUHzjgqt87722fOKchXzinIV84pyFfOKchXxcbiAqIHxKUHzjgqt844GLfOKchXzinIV84pyFfOKdjHxcbiAqIHxKUHzjgqt844O1fOKchXzinIV84pyFfOKdjHxcbiAqIHxKUHzjgqt844uVfOKchXzinIV84p2MfOKdjHxcbiAqIHxKUHzjgqt844KsfOKchXzinYx84p2MfOKdjHxcbiAqIHxKUHzjgqt85YqbfOKdjHzinYx84p2MfOKdjHxcbiAqIHxaSHzntIV857qifOKdjHzinYx84p2MfOKdjHxcbiAqIFxuICogXG4gKiAoTm90ZSB0byBzZWxmOiBBdCBzb21lIHBvaW50LCB0aGlzIGZpbGUgd2lsbCBwcm9iYWJseSBiZSBub3JtYWxpemVkXG4gKiBieSBzb21lYm9keSBhbmQg76qqIHdpbGwgdHVybiBiYWNrIGludG8g552ALilcbiAqIFxuICovXG5jb25zdCBfZHVtbXk6IGFueSA9IG51bGw7XG5cblxuZnVuY3Rpb24gaWRlbnRpdHk8VD4odDogVCkgeyByZXR1cm4gdDsgfVxudHlwZSBPbWl0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFBpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj47XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxDPiB7XG4gICAgdGV4dDogc3RyaW5nO1xuXG4gICAgc3ViSW5mbzogQztcbn1cblxuLyoqXG4gKiBAcGFyYW0gZnJvbVVzZXJJbnRlcmFjdGlvbiBXaGV0aGVyIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGlzIGNoaWxkIGFzIGEgbWVhbnMgb2YgbmF2aWdhdGluZyB0byBpdC4gIEluIHRoYXQgd2FzIHRoZSBjYXNlLCB0aGUgY2hpbGQgaXMgYWxzbyBmb2N1c2VkLiBPdGhlcndpc2UsIGZvY3VzIG1vdmVzIGFzIHRoZSBicm93c2VyIGRldGVybWluZXMuXG4gKi9cbmV4cG9ydCB0eXBlIE5hdmlnYXRlVG9JbmRleCA9IChpOiBudW1iZXIgfCBudWxsLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xuXG5cbmludGVyZmFjZSBMU1Age1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBhbmQgaW5kZXhEZW1hbmdsZXIgYXJlIHVzZWQgdG8gYWxsb3cgY2hpbGRyZW4gdG8gYmUgbmF2aWdhdGVkIGluIGFuIG9yZGVyXG4gICAgICogdGhhdCBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1hdGNoIHRoZWlyIGNoaWxkIG9yZGVyLCBsaWtlIGlmIGEgbGlzdCBpcyBzb3J0ZWQuXG4gICAgICogXG4gICAgICogVXNlZCB0byB0dXJuIGFuIFwiYWJzb2x1dGVcIiBpbmRleCBpbnRvIGEgXCJzb3J0ZWQvZmlsdGVyZWQvbWFuZ2xlZFwiIG9uZS5cbiAgICAgKiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgbmF2aWdhdGVUb0ZpcnN0IG1hbmdsZXMgMCBhbmQgbmF2aWdhdGVzIHRvIHRoYXQgcmVzdWx0aW5nIHJvdy5cbiAgICAgKiBAcGFyYW0gcmF3SW5kZXggXG4gICAgICovXG4gICAgaW5kZXhNYW5nbGVyPyhyYXdJbmRleDogbnVtYmVyKTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byB0dXJuIGEgXCJtYW5nbGVkXCIgaW5kZXggaW50byBpdCdzIFwidW5zb3J0ZWRcIiBvciBcInVubWFuZ2xlZFwiIGluZGV4LlxuICAgICAqIFxuICAgICAqIEZvciBleGFtcGxlLCB3aGVuIGluY3JlbWVudGluZyBvciBkZWNyZW1lbnRpbmcgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpbmRleCxcbiAgICAgKiBpdCBuZWVkcyB0byBiZSBkZW1hbmdsZWQgdG8gZG8gXCJub3JtYWxcIiBtYXRoIG9uIGl0LCBhbmQgdGhlbiByZS1tYW5nbGVkIChhYm92ZSlcbiAgICAgKiB0byB0dXJuIHRoYXQgYWJzb2x1dGUgcm93IGluZGV4IGJhY2sgaW50byBhIG1hbmdsZWQgb25lLlxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1lZEluZGV4IFxuICAgICAqL1xuICAgIGluZGV4RGVtYW5nbGVyPyh0cmFuc2Zvcm1lZEluZGV4OiBudW1iZXIpOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzID0ga2V5b2YgTFNQO1xuXG4vLyAqKiogUGFyYW1ldGVycyAobGlzdCwgbGlzdC1zaW5nbGUsIGxpc3QtY2hpbGQsIGxpc3Qtc2luZ2xlLWNoaWxkKVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHNcbiAgICBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8UnRpT21pdHMsIE1jT21pdHM+LFxuICAgIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFRuT21pdHMgfCBcImdldEluZGV4XCIgfCBcInNldEluZGV4XCI+LFxuICAgIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPExuT21pdHMgfCBcIm5hdmlnYXRlVG9GaXJzdFwiIHwgXCJuYXZpZ2F0ZVRvTGFzdFwiIHwgXCJuYXZpZ2F0ZVRvTmV4dFwiIHwgXCJuYXZpZ2F0ZVRvUHJldlwiPiB7XG4gICAgbGlzdE5hdmlnYXRpb246IE9taXQ8TFNQLCBMc09taXRzPjtcbn1cblxuaW50ZXJmYWNlIFNTUCB7XG4gICAgc2VsZWN0ZWRJbmRleDogbnVtYmVyIHwgbnVsbDtcbn1cbmV4cG9ydCB0eXBlIFNpbmdsZVNlbGVjdGlvbk9taXRzID0ga2V5b2YgU1NQO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxTU09taXRzIGV4dGVuZHMgU2luZ2xlU2VsZWN0aW9uT21pdHMsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4ge1xuICAgIHNpbmdsZVNlbGVjdGlvbjogT21pdDxTU1AsIFNTT21pdHM+O1xufVxuZXhwb3J0IHR5cGUgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzID0ga2V5b2YgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPGFueT47XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cywgUnRpT21pdHMsIE1jT21pdHMsIFN1YmJlc3RJbmZvPiB7XG4gICAgLy9yb3ZpbmdUYWJJbmRleDogT21pdDxVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cywgbmV2ZXI+W1wicm92aW5nVGFiSW5kZXhcIl0sIFwic3ViSW5mb1wiPjtcbiAgICBsaXN0TmF2aWdhdGlvbjogT21pdDxVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgTHNPbWl0cyB8IFwic3ViSW5mb1wiPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLIHwgXCJzZWxlY3RlZFwiLCBMc09taXRzLCBSdGlPbWl0cywgTWNPbWl0cywgU3ViYmVzdEluZm8+IHtcblxufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVJbmZvPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+PiwgXCJ0YWJiYWJsZVwiIHwgRXh0cmFGbGFnS2V5cz4sIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICBsaXN0TmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvSW5kZXg6IE5hdmlnYXRlVG9JbmRleCB9O1xufVxuXG4vLyAqKiogUmV0dXJuIHR5cGVzIChsaXN0LCBsaXN0LXNpbmdsZSwgbGlzdC1jaGlsZCwgbGlzdC1zaW5nbGUtY2hpbGQpXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcblxuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogVXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4ge1xuICAgIHNpbmdsZVNlbGVjdGlvbjoge31cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIEMsIEs+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLPjtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHM6IFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPltcInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNcIl07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIHNpbmdsZVNlbGVjdGlvbjoge1xuICAgICAgICBzZWxlY3RlZDogYm9vbGVhbjtcbiAgICAgICAgZ2V0U2VsZWN0ZWQoKTogYm9vbGVhbjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XG4gICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+W1widXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzXCJdO1xufVxuXG5cbmV4cG9ydCB0eXBlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQz4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5cbmV4cG9ydCB0eXBlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8QywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQz4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5cblxuXG4vKipcbiAqIEltcGxlbWVudHMgcHJvcGVyIGtleWJvYXJkIG5hdmlnYXRpb24gZm9yIGNvbXBvbmVudHMgbGlrZSBsaXN0Ym94ZXMsIGJ1dHRvbiBncm91cHMsIG1lbnVzLCBldGMuXG4gKiBcbiAqIEluIHRoZSBkb2N1bWVudCBvcmRlciwgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSBcImZvY3VzZWRcIiBvciBcInRhYmJhYmxlXCIgZWxlbWVudCwgbWFraW5nIGl0IGFjdCBtb3JlIGxpa2Ugb25lIGNvbXBsZXRlIHVuaXQgaW4gY29tcGFyaXNvbiB0byBldmVyeXRoaW5nIGFyb3VuZCBpdC5cbiAqIE5hdmlnYXRpbmcgZm9yd2FyZHMvYmFja3dhcmRzIGNhbiBiZSBkb25lIHdpdGggdGhlIGFycm93IGtleXMsIEhvbWUvRW5kIGtleXMsIG9yIGFueSBhbnkgdGV4dCBmb3IgdHlwZWFoZWFkIHRvIGZvY3VzIHRoZSBuZXh0IGl0ZW0gdGhhdCBtYXRjaGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+KHtcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IG1jLFxuICAgIHJvdmluZ1RhYkluZGV4LFxuICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25cbn06IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4ge1xuICAgIGluZGV4TWFuZ2xlciA/Pz0gaWRlbnRpdHk7XG4gICAgaW5kZXhEZW1hbmdsZXIgPz89IGlkZW50aXR5O1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTGlzdE5hdmlnYXRpb25cIiwgaW5kZXhNYW5nbGVyLCBpbmRleERlbWFuZ2xlcik7XG5cblxuICAgIGNvbnN0IHBhcmVudFJldHVyblR5cGUgPSB1c2VSb3ZpbmdUYWJJbmRleDxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+LCBFeHRyYUZsYWdLZXlzPih7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9LCByb3ZpbmdUYWJJbmRleDogeyBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4IH0gfSA9IHBhcmVudFJldHVyblR5cGU7XG5cbiAgICBjb25zdCBuYXZpZ2F0ZVRvSW5kZXggPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyIHwgbnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoaSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0cnlOYXZpZ2F0ZVRvSW5kZXgoe1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgICAgIHRhcmdldDogaSxcbiAgICAgICAgICAgICAgICBzZWFyY2hEaXJlY3Rpb246IDEsXG4gICAgICAgICAgICAgICAgaW5kZXhNYW5nbGVyOiBpbmRleE1hbmdsZXIgPz8gaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgaW5kZXhEZW1hbmdsZXI6IGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaSA9PSBudWxsID8gbnVsbCA6IG5leHRJbmRleCwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG51bGwsIGZyb21Vc2VySW50ZXJhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgICAgIGludmFsaWRUeXBlYWhlYWRcbiAgICAgICAgfVxuICAgIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7XG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIGdldEluZGV4OiBnZXRUYWJiYWJsZUluZGV4LFxuICAgICAgICAgICAgc2V0SW5kZXg6IHVzZUNhbGxiYWNrKChpbmRleDogKG51bWJlciB8IG51bGwpIHwgKChwcmV2OiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICAuLi50eXBlYWhlYWROYXZpZ2F0aW9uXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCB7IHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyB9ID0gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldjogdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlOYXZpZ2F0ZVRvSW5kZXgoeyBjaGlsZHJlbiwgZGVmYXVsdDogYyA/PyAwLCB0YXJnZXQ6IGluZGV4RGVtYW5nbGVyIShpbmRleE1hbmdsZXIhKChjID8/IDApKSAtIDEpLCBzZWFyY2hEaXJlY3Rpb246IC0xLCBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSwgaW5kZXhEZW1hbmdsZXI6IGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5IH0pXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSlcbiAgICAgICAgICAgIH0sIFtdKSxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0OiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU5hdmlnYXRlVG9JbmRleCh7IGNoaWxkcmVuLCBkZWZhdWx0OiBjID8/IDAsIHRhcmdldDogaW5kZXhEZW1hbmdsZXIhKGluZGV4TWFuZ2xlciEoYyA/PyAwKSArIDEpLCBzZWFyY2hEaXJlY3Rpb246IDEsIGluZGV4TWFuZ2xlcjogaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LCBpbmRleERlbWFuZ2xlcjogaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHkgfSk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSlcbiAgICAgICAgICAgIH0sIFtdKSxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdDogdXNlQ2FsbGJhY2soKCkgPT4geyBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXhEZW1hbmdsZXIhKDApLCB0cnVlKTsgfSwgW10pLFxuICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3Q6IHVzZUNhbGxiYWNrKCgpID0+IHsgbmF2aWdhdGVUb0luZGV4KGluZGV4RGVtYW5nbGVyIShjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSksIHRydWUpOyB9LCBbXSksXG4gICAgICAgICAgICAuLi5saW5lYXJOYXZpZ2F0aW9uXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiA9PiB7XG4gICAgICAgIHJldHVybiB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHModXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzKHByb3BzKSk7XG4gICAgfSwgW3VzZUxpbmVhck5hdmlnYXRpb25Qcm9wcywgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzXSk7XG5cblxuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPj4oKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW4gfSwgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LCBzdWJJbmZvIH0pID0+IHtcblxuICAgICAgICBjb25zdCBfdjogdm9pZCA9IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCh7IHRleHQsIGluZGV4IH0pO1xuICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUdldHRlcihpbmRleCk7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGdldFRhYmJhYmxlSW5kZXgoKSA9PSBnZXRJbmRleCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChpbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldEVsZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSA9IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuOiAhIWhpZGRlbiB9LFxuICAgICAgICAgICAgc3ViSW5mbzogeyB0ZXh0LCBzdWJJbmZvIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PiA9IGZ1bmN0aW9uICh7IC4uLnByb3BzIH0pIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxDaGlsZEVsZW1lbnQ+KHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcygoKHsgaW5lcnQ6IGhpZGRlbiB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pKSksIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldEVsZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFt1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIG5hdmlnYXRlVG9JbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcblxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvSW5kZXggfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHBhcmVudFJldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQgfVxuICAgICAgICAvKmxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleCB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGdldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXggfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9Ki9cbiAgICB9XG59XG5cblxuXG5cblxuXG4vKipcbiAqIEl0J3MgdmVyeSBjb21tb24gdG8gY29tYmluZSBhIHRhYmJhYmxlIGxpc3Qgb2YgdGhpbmdzIGFuZCBcInNlbGVjdGlvblwiIG9mIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKiBcbiAqIExpc3RzLCByYWRpbyBidXR0b25zLCB0YWJzLCBldGMuIGV0Yy5cbiAqIFxuICogVGhpcyBpcyBhIHNob3J0Y3V0IHRoYXQgY29tYmluZXMgdGhlIHR3byB3aXRoIHRoZSBjb3JyZWN0IHR5cGluZy5cbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oe1xuICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4IH0sXG4gICAgbGlzdE5hdmlnYXRpb24sXG4gICAgbWFuYWdlZENoaWxkcmVuOiB7IC8qb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY21jLCovIC4uLm1jIH0sXG4gICAgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCAuLi5yb3ZpbmdUYWJJbmRleCB9LFxuICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblxufTogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+IHtcbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSyB8IFwic2VsZWN0ZWRcIj4oe1xuICAgICAgICBsaXN0TmF2aWdhdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7XG4gICAgICAgICAgICAuLi5tYyxcbiAgICAgICAgICAgIC8qb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPbkNoaWxkcmVuTW91bnRDaGFuZ2U8bnVtYmVyPj4oKG1vdW50ZWQsIHVubW91bnRlZCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7XG4gICAgICAgICAgICAgICAgb2NtYz8uKG1vdW50ZWQsIHVubW91bnRlZCk7XG4gICAgICAgICAgICB9KSovXG4gICAgICAgIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgICAgICBpbml0aWFsSW5kZXg6IChpbml0aWFsSW5kZXggPz8gc2VsZWN0ZWRJbmRleCA/PyB1bmRlZmluZWQpLFxuICAgICAgICAgICAgLi4ucm92aW5nVGFiSW5kZXhcbiAgICAgICAgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblxuICAgIH0pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxuICAgICAgICAuLi5saXN0UmVzdFxuICAgIH0gPSBwYXJlbnRSZXR1cm5UeXBlO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSB9ID0gbGlzdFJlc3Q7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGNoYW5nZUluZGV4OiBjaGFuZ2VTZWxlY3RlZEluZGV4LFxuICAgICAgICBnZXRDdXJyZW50SW5kZXg6IGdldFNlbGVjdGVkSW5kZXgsXG4gICAgICAgIC8vcmVldmFsdWF0ZUNsb3Nlc3RGaXRcbiAgICB9ID0gdXNlQ2hpbGRyZW5GbGFnPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxDPj4sIEsgfCBcInNlbGVjdGVkXCI+KHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBpbml0aWFsSW5kZXg6IHNlbGVjdGVkSW5kZXgsXG4gICAgICAgIGtleTogXCJzZWxlY3RlZFwiLFxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZVxuICAgIH0pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2hhbmdlU2VsZWN0ZWRJbmRleChzZWxlY3RlZEluZGV4KTtcbiAgICB9LCBbc2VsZWN0ZWRJbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogdXNlQ2FsbGJhY2s8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEsgfCBcInNlbGVjdGVkXCI+PigoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHJvdmluZ1RhYkluZGV4OiBydGksIGxpc3ROYXZpZ2F0aW9uOiBscywgc3ViSW5mbyB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbaXNTZWxlY3RlZCwgc2V0SXNTZWxlY3RlZCwgZ2V0SXNTZWxlY3RlZF0gPSB1c2VTdGF0ZShnZXRTZWxlY3RlZEluZGV4KCkgPT0gaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRSZWYgPSB1c2VSZWY8Q2hpbGRGbGFnT3BlcmF0aW9ucz4oeyBnZXQ6IGdldElzU2VsZWN0ZWQsIHNldDogc2V0SXNTZWxlY3RlZCwgaXNWYWxpZDogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4gIXJ0aS5oaWRkZW4pIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9yZXQsXG4gICAgICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzXG4gICAgICAgICAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5mbGFnc1xuICAgICAgICAgICAgICAgICAgICB9IGFzIFBhcnRpYWw8UmVjb3JkPEsgfCBcInNlbGVjdGVkXCIgfCBcInRhYmJhYmxlXCIsIENoaWxkRmxhZ09wZXJhdGlvbnM+PlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aSxcbiAgICAgICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogbHMsXG4gICAgICAgICAgICAgICAgc3ViSW5mb1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wczogdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfcmV0LFxuICAgICAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZDogaXNTZWxlY3RlZCwgZ2V0U2VsZWN0ZWQ6IGdldElzU2VsZWN0ZWQgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgW10pLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiB1c2VDYWxsYmFjaygoLi4ucDogUGFyYW1ldGVyczx0eXBlb2YgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcz4pID0+IHsgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMoLi4ucCkgfSwgW10pLFxuICAgICAgICAuLi5saXN0UmVzdCxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7fVxuICAgIH1cbn1cblxuXG5cblxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgViwgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHNcbiAgICBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cyB8IFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIsIExuT21pdHMsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPixcbiAgICBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLLCBHLCBWPiB7XG59XG5cbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cz4gPSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBMc09taXRzLCBSdGlPbWl0cywgTWNPbWl0cywgQz47XG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyPikgPT4gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLPixcbiAgICBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSywgRz4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLLCBHPiB7XG4gICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblByb3BzOiAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuOiBWTm9kZTxhbnk+W107IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+XG4gICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb248UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgdHlwZWFoZWFkTmF2aWdhdGlvbiwgcmVhcnJhbmdlYWJsZUNoaWxkcmVuLCBzb3J0YWJsZUNoaWxkcmVuIH06IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPEMsIEssIEcsIFYsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEssIEc+IHtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcbiAgICAgICAgLi4uc29ydGFibGVDaGlsZHJlblJldHVyblR5cGVcbiAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50LCBDLCBLLCBHLCBWPih7XG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbixcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSB9ID0gc29ydGFibGVDaGlsZHJlblJldHVyblR5cGU7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCAuLi5saXN0TmF2aWdhdGlvbiB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgIH0pO1xuXG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblByb3BzID0gKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiB7XG4gICAgICAgIHJldHVybiAodXNlTGlzdE5hdmlnYXRpb25Qcm9wcyh1c2VTb3J0YWJsZVByb3BzKHByb3BzKSkpXG4gICAgfVxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz4gPSAocCkgPT4ge1xuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25DaGlsZChwKVxuICAgIH1cblxuICAgIHJldHVybiAoe1xuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGUsXG4gICAgICAgIC4uLnNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlXG4gICAgICAgIC8qbWFuYWdlZENoaWxkcmVuOiBsaXN0TmF2UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBsaXN0TmF2UmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGlzdE5hdlJldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IGxpc3ROYXZSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBsaXN0TmF2UmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuOiBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZS5zb3J0YWJsZUNoaWxkcmVuLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlLnJlYXJyYW5nZWFibGVDaGlsZHJlbiovXG4gICAgfSk7XG5cbn1cblxuZXhwb3J0IHR5cGUgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGFyZ3M6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIEM+KSA9PiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFNTT21pdHMgZXh0ZW5kcyBTaW5nbGVTZWxlY3Rpb25PbWl0cywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFNTT21pdHMsIExzT21pdHMgfCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiLCBMbk9taXRzLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSywgRz4sIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzXG4gICAgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSywgRz4ge1xuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PlxuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24sIHR5cGVhaGVhZE5hdmlnYXRpb24gfTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEssIFtdPiB7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXG4gICAgICAgIC4uLnNvcnRhYmxlUmV0dXJuVHlwZVxuICAgIH0gPSB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQsIEMsIEssIFtdLCBudW1iZXI+KHtcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4OiB1c2VDYWxsYmFjaygocm93KSA9PiByb3cuaW5kZXgsIFtdKSB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuOiB7XG4gICAgICAgICAgICBnZXRWYWx1ZTogdXNlQ2FsbGJhY2soKHJvdykgPT4gcm93LmluZGV4LCBbXSksXG4gICAgICAgICAgICBjb21wYXJlOiB1c2VDYWxsYmFjaygobGhzLCByaHMpID0+IHsgcmV0dXJuIGxocyAtIHJoczsgfSwgW10pLFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0gfSA9IHNvcnRhYmxlUmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGVcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIC4uLmxpc3ROYXZpZ2F0aW9uIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcm92aW5nVGFiSW5kZXgsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHR5cGVhaGVhZE5hdmlnYXRpb24sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogc2luZ2xlU2VsZWN0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMgPSAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuOiBWTm9kZTxhbnk+W107IH0pID0+IHtcbiAgICAgICAgcmV0dXJuICh1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHVzZVNvcnRhYmxlUHJvcHMocHJvcHMpKSk7XG4gICAgfVxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCA9IChwOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4ge1xuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHtcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLFxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXG4gICAgICAgIC8vc29ydGFibGU6IHsgc29ydCwgc2h1ZmZsZSwgcmVhcnJhbmdlLCBkZW1hbmdsZU1hcCwgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgbWFuZ2xlTWFwIH0sXG4gICAgICAgIC4uLnNvcnRhYmxlUmV0dXJuVHlwZSxcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGVcbiAgICB9KTtcblxufVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBUcnlOYXZpZ2F0ZVRvSW5kZXhQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBjaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPEM+PiwgSz47XG4gICAgZGVmYXVsdDogbnVtYmVyO1xuICAgIHRhcmdldDogbnVtYmVyO1xuICAgIHNlYXJjaERpcmVjdGlvbjogMSB8IC0xO1xuICAgIGluZGV4TWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xuICAgIGluZGV4RGVtYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyeU5hdmlnYXRlVG9JbmRleDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGNoaWxkcmVuLCBzZWFyY2hEaXJlY3Rpb24sIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIHRhcmdldCB9OiBUcnlOYXZpZ2F0ZVRvSW5kZXhQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSz4pIHtcbiAgICBjb25zdCB1cHBlciA9IGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpO1xuICAgIGNvbnN0IGxvd2VyID0gMDtcblxuICAgIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgIHdoaWxlICgodGFyZ2V0ID49IGxvd2VyICYmIChjaGlsZHJlbi5nZXRBdCh0YXJnZXQpID09IG51bGwpIHx8ICEhY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KT8uc3ViSW5mby5oaWRkZW4pKVxuICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXhEZW1hbmdsZXIoaW5kZXhNYW5nbGVyKHRhcmdldCkgLSAxKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0IDwgbG93ZXIgPyBpbmRleERlbWFuZ2xlcihsb3dlcikgOiB0YXJnZXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gMSkge1xuICAgICAgICB3aGlsZSAoKHRhcmdldCA8PSB1cHBlciAmJiBjaGlsZHJlbi5nZXRBdCh0YXJnZXQpID09IG51bGwpIHx8ICEhY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KT8uc3ViSW5mby5oaWRkZW4pXG4gICAgICAgICAgICB0YXJnZXQgPSBpbmRleERlbWFuZ2xlcihpbmRleE1hbmdsZXIodGFyZ2V0KSArIDEpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQgPiB1cHBlciA/IGluZGV4RGVtYW5nbGVyKHVwcGVyKSA6IHRhcmdldDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBsb3dlcjtcbiAgICB9XG59XG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkT21pdHMsIE1hbmFnZWRDaGlsZHJlbk9taXRzIH0gZnJvbSBcInVzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyB9IGZyb20gXCJ1c2Uta2V5Ym9hcmQtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cyB9IGZyb20gXCJ1c2Utcm92aW5nLXRhYmluZGV4XCI7XG5pbXBvcnQgeyB1c2VIYXNGb2N1cyB9IGZyb20gXCIuL3VzZS1oYXMtZm9jdXNcIjtcbmltcG9ydCB7IExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtbGlzdC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5cbi8qKlxuICogR3JpZHMgYXJlIGltcGxlbWVudGVkIHVzaW5nIHR3byBzZXRzIG9mIGxpc3QgbmF2aWdhdGlvbi5cbiAqIFxuICogVGhpcyByZXN1bHRzIGluIGEgbG90IG9mIHRoaW5ncyB3aXRoIHZlcnkgc2ltaWxhciBuYW1lcyBhbmQganVzdCBjb25mdXNpb24gYWxsIGFyb3VuZC4gUGxlYXNlIHVzZSBjYXV0aW9uLlxuICovXG5cbi8vIFBhcmFtZXRlcnMgKHBhcmVudCwgcm93LCBjZWxsKVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgfCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiLCBMbk9taXRzIHwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCIsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8XG4gICAgQ1IsXG4gICAgS1IgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLFxuICAgIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsXG4gICAgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyxcbiAgICBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLFxuICAgIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyxcblxuICAgIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cyxcbiAgICBSdGlDaGlsZE9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLFxuICAgIE1jQ2hpbGRPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLFxuXG4gICAgU3ViYmVzdEluZm9cbiAgICA+IHtcbiAgICBhc1BhcmVudFJvd09mQ2VsbHM6IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzIHwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCIsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPjtcbiAgICBhc0NoaWxkUm93T2ZTZWN0aW9uOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDUiwgS1IsIExzQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cywgTWNDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz5cblxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzPENDLCBLQyBleHRlbmRzIHN0cmluZywgTHNDaGlsZE9taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBSdGlDaGlsZE9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY0NoaWxkT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDQywgS0MsIExzQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cywgTWNDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4ge1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG4gICAgZ3JpZE5hdmlnYXRpb246IHtcbiAgICAgICAgZ2V0Q3VycmVudENvbHVtbigpOiBudW1iZXIgfCBudWxsO1xuICAgICAgICBjdXJyZW50Q29sdW1uOiBudW1iZXIgfCBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENSLCBDQywgS1IgZXh0ZW5kcyBzdHJpbmcsIEtDIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ1IsIEtSPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25Sb3c6IFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDUiwgQ0MsIEtSLCBLQz47XG4gICAgdXNlR3JpZE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPclJvd0VsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPclJvd0VsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm88Um93IGV4dGVuZHMgRWxlbWVudCwgQ2VsbCBleHRlbmRzIEVsZW1lbnQsIENDLCBLQyBleHRlbmRzIHN0cmluZz4ge1xuICAgIGFzQ2hpbGRSb3c6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxSb3c+O1xuICAgIGFzUGFyZW50T2ZDZWxsczogVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDZWxsLCBDQywgS0M+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3cgZXh0ZW5kcyBFbGVtZW50LCBDZWxsIGV4dGVuZHMgRWxlbWVudCwgQ0MsIEtDIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm88Um93LCBDZWxsLCBDQywgS0M+IHtcbiAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGw6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbDxDZWxsLCBDQywgS0M+O1xuICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2VsbD4ge1xuICAgIGdyaWROYXZpZ2F0aW9uOiB7XG4gICAgICAgIC8vcm93SXNUYWJiYWJsZTogYm9vbGVhbjtcbiAgICAgICAgLy9nZXRSb3dJc1RhYmJhYmxlKCk6IGJvb2xlYW47XG4gICAgICAgIGdldEN1cnJlbnRDb2x1bW4oKTogbnVtYmVyIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGw+O1xufVxuXG5cbmV4cG9ydCB0eXBlIFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvdyBleHRlbmRzIEVsZW1lbnQsIENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDUiwgQ0MsIEtSIGV4dGVuZHMgc3RyaW5nLCBLQyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPENSLCBLUiwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDUj4pID0+IFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3csIENlbGwsIENDLCBLQz47XG5leHBvcnQgdHlwZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbCBleHRlbmRzIEVsZW1lbnQsIENDLCBLQyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDQywgS0MsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIENDPikgPT4gVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsPjtcblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlR3JpZE5hdmlnYXRpb248XG4gICAgUGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbiAgICBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbiAgICBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgUm93U3ViSW5mbyxcbiAgICBDZWxsU3ViSW5mbyxcbiAgICBSb3dFeHRyYUZsYWdzIGV4dGVuZHMgc3RyaW5nLFxuICAgIENlbGxFeHRyYUZsYWdzIGV4dGVuZHMgc3RyaW5nXG4+KHtcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IG1jLFxuICAgIHJvdmluZ1RhYkluZGV4OiBydGksXG4gICAgbGlzdE5hdmlnYXRpb246IGxzLFxuICAgIGxpbmVhck5hdmlnYXRpb246IGxuLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuXG59OiBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSb3dTdWJJbmZvLCBDZWxsU3ViSW5mbywgUm93RXh0cmFGbGFncywgQ2VsbEV4dHJhRmxhZ3M+IHtcbiAgICBjb25zdCBbY3VycmVudENvbHVtbiwgc2V0Q3VycmVudENvbHVtbiwgZ2V0Q3VycmVudENvbHVtbl0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihydGkuaW5pdGlhbEluZGV4ID8/IDApO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkOiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkQXNHcmlkUm93LFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzOiB1c2VMaXN0TmF2aWdhdGlvblByb3BzQXNHcmlkUGFyZW50LFxuICAgICAgICAuLi5wYXJlbnRMc1JldHVyblR5cGVcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBSb3dTdWJJbmZvLCBSb3dFeHRyYUZsYWdzPih7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGksXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBscyxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcImJsb2NrXCIsIC4uLmxuIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuLFxuICAgIH0pO1xuXG5cbiAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvblJvdyA9IHVzZUNhbGxiYWNrPFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSb3dTdWJJbmZvLCBDZWxsU3ViSW5mbywgUm93RXh0cmFGbGFncywgQ2VsbEV4dHJhRmxhZ3M+PigoeyBhc0NoaWxkUm93T2ZTZWN0aW9uOiBhc0NoaWxkLCBhc1BhcmVudFJvd09mQ2VsbHM6IGFzUGFyZW50IH0pID0+IHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGZvY3VzU2VsZiB0aGF0IHJvdmluZ1RhYkluZGV4IGRvZXMuXG4gICAgICAgIC8vIEluc3RlYWQgb2YgZm9jdXNpbmcgdGhlIGVudGlyZSByb3csIHdlIGFzayB0aGUgY2VsbCB0aGF0IGNvcnJlc3BvbmRzXG4gICAgICAgIC8vIHRvIG91ciBjdXJyZW50IGNvbHVtbiB0byBmb2N1cyBpdHNlbGYuXG4gICAgICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gZ2V0Q3VycmVudENvbHVtbigpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYHJvdyAjJHthc0NoaWxkLm1hbmFnZWRDaGlsZC5pbmRleH0sJHtjMn0gZm9jdXNTZWxmYCk7XG4gICAgICAgICAgICBpZiAoYXNDaGlsZC5yb3ZpbmdUYWJJbmRleC5mb2N1c1NlbGYpIHtcbiAgICAgICAgICAgICAgICBhc0NoaWxkLnJvdmluZ1RhYkluZGV4LmZvY3VzU2VsZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGMyID8/IDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByb3dMc0NoaWxkUmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRBc0dyaWRSb3coe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiBhc0NoaWxkLm1hbmFnZWRDaGlsZCxcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmFzQ2hpbGQubGlzdE5hdmlnYXRpb24gfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IC4uLmFzQ2hpbGQucm92aW5nVGFiSW5kZXgsIGZvY3VzU2VsZiB9LFxuICAgICAgICAgICAgc3ViSW5mbzogYXNDaGlsZC5zdWJJbmZvLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleDogeyB0YWJiYWJsZSB9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMgfSA9IHJvd0xzQ2hpbGRSZXR1cm5UeXBlO1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0YWJiYWJsZSkge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt0YWJiYWJsZV0pO1xuXG4gICAgICAgIGNvbnN0IHJvd0xzUmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uPENlbGxFbGVtZW50LCBDZWxsRWxlbWVudCwgQ2VsbFN1YkluZm8sIENlbGxFeHRyYUZsYWdzPih7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4uYXNQYXJlbnQubWFuYWdlZENoaWxkcmVuIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyAuLi5hc1BhcmVudC5yb3ZpbmdUYWJJbmRleCB9LFxuICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgICAgIC4uLmFzUGFyZW50LmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbjogXCJpbmxpbmVcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IC4uLmFzUGFyZW50LnR5cGVhaGVhZE5hdmlnYXRpb24sIG5vVHlwZWFoZWFkOiB0cnVlIH0sXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5hc1BhcmVudC5saXN0TmF2aWdhdGlvbiB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXg6IHsgc2V0VGFiYmFibGVJbmRleCB9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkOiB1c2VHcmlkTmF2aWdhdGlvbkNvbHVtbjIsIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM6IHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uUHJvcHMsIGxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleCB9IH0gPSByb3dMc1JldHVyblR5cGU7XG5cbiAgICAgICAgLy9jb25zdCByb3dIaWRkZW4gPSAhIWFzQ2hpbGQucm92aW5nVGFiSW5kZXguaGlkZGVuO1xuXG4gICAgICAgIGNvbnN0IHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCA9IHVzZUNhbGxiYWNrPFVzZUdyaWROYXZpZ2F0aW9uQ2VsbDxDZWxsRWxlbWVudCwgQ2VsbFN1YkluZm8sIENlbGxFeHRyYUZsYWdzPj4oKHsgc3ViSW5mbywgbWFuYWdlZENoaWxkLCBsaXN0TmF2aWdhdGlvbjogbHMsIHJvdmluZ1RhYkluZGV4OiB7IGJsdXJTZWxmOiBicywgZm9jdXNTZWxmOiBmcywgLi4ucnRpIH0gfSkgPT4ge1xuICAgICAgICAgICAgLy9ydGkuaGlkZGVuIHx8IHJvd0hpZGRlbjtcblxuICAgICAgICAgICAgY29uc3QgZm9jdXNTZWxmID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBjZWxsICMke21hbmFnZWRDaGlsZC5pbmRleH0gZm9jdXNTZWxmYCk7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudENvbHVtbihtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobWFuYWdlZENoaWxkLmluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZzKVxuICAgICAgICAgICAgICAgICAgICBmcygpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKHJ0aV9jZWxsX3JldC5nZXRFbGVtZW50KCkgYXMgRWxlbWVudCAmIFBhcnRpYWw8SFRNTEVsZW1lbnQ+KT8uZm9jdXM/LigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBibHVyU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYnMpXG4gICAgICAgICAgICAgICAgICAgIGJzKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAocnRpX2NlbGxfcmV0LmdldEVsZW1lbnQoKSBhcyBFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pPy5ibHVyPy4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX2NlbGxfcmV0XG4gICAgICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25Db2x1bW4yKHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IG1hbmFnZWRDaGlsZCxcbiAgICAgICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGJsdXJTZWxmLCBmb2N1c1NlbGYsIC4uLnJ0aSB9LFxuICAgICAgICAgICAgICAgIHN1YkluZm9cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPENlbGxFbGVtZW50Pih7XG4gICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDb2x1bW4obWFuYWdlZENoaWxkLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobWFuYWdlZENoaWxkLmluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgY29uc3QgcmV0OiBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGxFbGVtZW50PiA9IHtcbiAgICAgICAgICAgICAgICBncmlkTmF2aWdhdGlvbjogeyBnZXRDdXJyZW50Q29sdW1uIH0sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9jZWxsX3JldCxcbiAgICAgICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wczogZnVuY3Rpb24gPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD4+KHByb3BzOiBQKSB7IHJldHVybiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlR3JpZE5hdmlnYXRpb25Db2x1bW5Qcm9wcyh1c2VIYXNGb2N1c1Byb3BzKHByb3BzKSkpOyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGNvbnN0IHJldDogVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+ID0ge1xuICAgICAgICAgICAgYXNQYXJlbnRPZkNlbGxzOiB7XG4gICAgICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogcm93THNSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHJvd0xzUmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHJvd0xzUmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJvd0xzUmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiByb3dMc1JldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzQ2hpbGRSb3c6IHJvd0xzQ2hpbGRSZXR1cm5UeXBlLFxuXG4gICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGwsXG4gICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzOiBmdW5jdGlvbiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvd0VsZW1lbnQ+Pihwcm9wczogUCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgcmV0LnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIGdldEN1cnJlbnRDb2x1bW4sXG4gICAgICAgICAgICBjdXJyZW50Q29sdW1uXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHBhcmVudExzUmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogcGFyZW50THNSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcGFyZW50THNSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBwYXJlbnRMc1JldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBwYXJlbnRMc1JldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvdyxcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Qcm9wczogdXNlTGlzdE5hdmlnYXRpb25Qcm9wc0FzR3JpZFBhcmVudCxcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdFwiO1xuaW1wb3J0IHsgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuZXhwb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9XG5cbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkUHJvcHNQYXJhbWV0ZXJzID0gVXNlUmVmZXJlbmNlZElkUHJvcHNQYXJhbWV0ZXJzPFwiaWRcIj47XG5leHBvcnQgdHlwZSBVc2VSYW5kb21JZFByb3BzUmV0dXJuVHlwZTxQIGV4dGVuZHMgVXNlUmFuZG9tSWRQcm9wc1BhcmFtZXRlcnM+ID0gVXNlUmVmZXJlbmNlZElkUHJvcHNSZXR1cm5UeXBlPFAsIFwiaWRcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFuZG9tSWRQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxcInJlZmVyZW5jZXJcIiB8IFwic291cmNlXCIsIG5ldmVyPiB7XG4gICAgcmFuZG9tSWQ6IHtcbiAgICAgICAgcHJlZml4Pzogc3RyaW5nO1xuICAgIH1cbn1cblxuXG5leHBvcnQgdHlwZSBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8SyBleHRlbmRzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+ID0gUGFydGlhbDxSZWNvcmQ8SywgYW55Pj47Ly88RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4geyB9O1xuXG5cbmV4cG9ydCB0eXBlIFVzZVJlZmVyZW5jZWRJZFByb3BzUmV0dXJuVHlwZTxQIGV4dGVuZHMgVXNlUmVmZXJlbmNlZElkUHJvcHNQYXJhbWV0ZXJzPGFueT4sIEsgZXh0ZW5kcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+PiA9IE9taXQ8UCwgSz4gJiBSZWNvcmQ8Sywgc3RyaW5nPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFJldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88XCJyZWZlcmVuY2VyXCIgfCBcInNvdXJjZVwiLCB7fSwgbmV2ZXI+IHtcbiAgICByYW5kb21JZDoge1xuICAgICAgICB1c2VkSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0VXNlZElkKCk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFuZG9tSWRSZXR1cm5UeXBlV2l0aEhvb2tzPFMgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJhbmRvbUlkUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ8Uz47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiBVc2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50O1xufVxuXG5pbnRlcmZhY2UgUmFuZG9tSWRDaGlsZEluZm9CYXNlIHtcbiAgICBzZXRVc2VkSWQoaWQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgLy9zZW5kU291cmNlSWRUb1JlZmVyZW5jZXJFbGVtZW50KHNvdXJjZUlkOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ8UyBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4gVXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UmV0dXJuVHlwZTxTPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnRSZXR1cm5UeXBlPFMgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdXNlZElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRVc2VkSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxTPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uz47XG59XG5cbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQgPSA8UiBleHRlbmRzIEVsZW1lbnQ+KGlkUHJvcE5hbWU6IGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PikgPT4gVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFJldHVyblR5cGU8Uj47XG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRSZXR1cm5UeXBlPFIgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdXNlZElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRVc2VkSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uj4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFI+O1xufVxuXG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgaG9vayB0aGF0IG1vZGlmaWVzIGEgc2V0IG9mIHByb3BzIHRvIHByb3ZpZGUgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKiBcbiAqIElmIHlvdSdkIGxpa2UgdG8gdXNlIHRoZSBJRCBpbiBhIHByb3BlcnR5IHRoYXQncyAqbm90KiBuYW1lZCBgaWRgIChsaWtlIGBmb3JgIG9yIGBhcmlhLWxhYmVsbGVkYnlgIG9yIHdoYXRub3QpLCBgdXNlUmVmZXJlbmNlZElkUHJvcHNgIGlzIGFsc28gcHJvdmlkZWQuXG4gKiBcbiAqIEFuZCB0aGUgcmFuZG9tbHktZ2VuZXJhdGVkIGlkIGl0c2VsZiBpcyBhbHNvIHByb3ZpZGVkIGluIGNhc2UgeW91IHdhbnQgdG8gaGFuZGxlIHRoZSBsb2dpYyB5b3Vyc2VsZiB3aXRob3V0IGB1c2VNZXJnZWRQcm9wc2AuXG4gKiBcbiAqIFVubGlrZSBtb3N0IG90aGVyIGB1c2UqUHJvcHNgIGhvb2tzLCB0aGVzZSBhcmUgbW9zdGx5IHN0YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJhbmRvbUlkPFMgZXh0ZW5kcyBFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeCB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9OiBVc2VSYW5kb21JZFBhcmFtZXRlcnMpOiBVc2VSYW5kb21JZFJldHVyblR5cGVXaXRoSG9va3M8Uz4ge1xuICAgIGNvbnN0IFtiYWNrdXBSYW5kb21JZCwgLCBnZXRCYWNrdXBSYW5kb21JZF0gPSB1c2VTdGF0ZTxzdHJpbmc+KCgpID0+IGdlbmVyYXRlUmFuZG9tSWQocHJlZml4KSk7XG4gICAgY29uc3QgW3VzZWRJZCwgc2V0VXNlZElkLCBnZXRVc2VkSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPigoKSA9PiBnZXRCYWNrdXBSYW5kb21JZCgpKTtcbiAgICBjb25zdCBtaXNtYXRjaEVycm9yUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VSYW5kb21JZFwiLCBwcmVmaXgpO1xuXG4gICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGQsIC4uLm1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUgfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxcInJlZmVyZW5jZXJcIiB8IFwic291cmNlXCIsIFJhbmRvbUlkQ2hpbGRJbmZvQmFzZSwgbmV2ZXI+KHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfSk7XG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSB9ID0gbWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCA9IHVzZUNhbGxiYWNrPFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTPj4oKCkgPT4ge1xuICAgICAgICBjb25zdCBbdXNlZElkTG9jYWwsIHNldFVzZWRJZExvY2FsLCBnZXRVc2VkSWRMb2NhbF0gPSB1c2VTdGF0ZShnZXRVc2VkSWQoKSk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PFM+KCk7XG4gICAgICAgIC8vIEV2ZXJ5IHRpbWUgdGhlIHNvdXJjZSBlbGVtZW50IHJlbmRlcnMsIGluc3BlY3QgdGhlIElEIGl0IGFjdHVhbGx5IHVzZWRcbiAgICAgICAgLy8gKHdoZXRoZXIgaXQgd2FzIG91cnMgb3Igbm90IGlzbid0IHVwIHRvIHVzLCBpdCdzIHVwIHRvIHRoZSBjb21wb25lbnQpXG4gICAgICAgIC8vIHNvIHRoaXMgaXMgaG93IHdlIG5vdGlmeSB0aGUgcmVmZXJlbmNlciBjb21wb25lbnQgb2YgY2hhbmdlc1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5nZXRBdChcInJlZmVyZW5jZXJcIikhLnN1YkluZm8uc2V0VXNlZElkKGVsZW1lbnQuaWQpO1xuICAgICAgICAgICAgICAgIHNldFVzZWRJZChlbGVtZW50LmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgXzogdm9pZCA9IHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleDogXCJzb3VyY2VcIiwgc3ViSW5mbzogeyBzZXRVc2VkSWQ6IHNldFVzZWRJZExvY2FsIH0gfSB9KTtcblxuICAgICAgICBjb25zdCB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyA9IHVzZUNhbGxiYWNrPFVzZVJhbmRvbUlkU291cmNlRWxlbWVudFJldHVyblR5cGU8Uz5bXCJ1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wc1wiXT4oZnVuY3Rpb24gKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFM+KSB7XG4gICAgICAgICAgICBwLmlkIHx8PSBiYWNrdXBSYW5kb21JZDtcbiAgICAgICAgICAgIHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHMocCk7XG4gICAgICAgIH0sIFtdKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VkSWQ6IHVzZWRJZExvY2FsLFxuICAgICAgICAgICAgZ2V0VXNlZElkOiBnZXRVc2VkSWRMb2NhbCxcbiAgICAgICAgICAgIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCA9IHVzZUNhbGxiYWNrPFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ+KDxSIGV4dGVuZHMgRWxlbWVudD4oaWRQcm9wTmFtZToga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uj4pID0+IHtcbiAgICAgICAgY29uc3QgW3VzZWRJZExvY2FsLCBzZXRVc2VkSWRMb2NhbCwgZ2V0VXNlZElkTG9jYWxdID0gdXNlU3RhdGUoZ2V0VXNlZElkKCkpO1xuICAgICAgICAvLyBXaGF0ZXZlciBJRCB3YXMgbW9zdCByZWNlbnRseSB1c2VkIGJ5IHRoZSBhY3R1YWwgXCJpZFwiIHByb3Agb2YgdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIHVzZUVuc3VyZVN0YWJpbGl0eShpZFByb3BOYW1lKTtcblxuICAgICAgICBjb25zdCBfdjogdm9pZCA9IHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleDogXCJyZWZlcmVuY2VyXCIsIHN1YkluZm86IHsgc2V0VXNlZElkOiBzZXRVc2VkSWRMb2NhbCB9IH0gfSk7XG5cbiAgICAgICAgY29uc3QgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzID0gdXNlQ2FsbGJhY2s8VXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFJldHVyblR5cGU8Uj5bXCJ1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHNcIl0+KGZ1bmN0aW9uIDxSIGV4dGVuZHMgRWxlbWVudD4oeyBbaWRQcm9wTmFtZV06IGdpdmVuSWQsIC4uLnAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uj4pIHtcbiAgICAgICAgICAgIGlmIChnaXZlbklkICYmIHVzZWRJZCkge1xuICAgICAgICAgICAgICAgIGlmIChnaXZlbklkICE9IHVzZWRJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1pc21hdGNoRXJyb3JSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlzbWF0Y2hFcnJvclJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYE11bHRpcGxlIG1pcy1tYXRjaGVkIElEcyB3ZXJlIHByb3ZpZGVkIGZvciB0aGUgJHtpZFByb3BOYW1lfSBwcm9wOiB0aGUgY2hpbGQgZXhwbGljaXRseSBzcGVjaWZpZWQgJHtnaXZlbklkfSBpbiBpdHMgICR7aWRQcm9wTmFtZX0gcHJvcCwgYnV0IHRoZSBwYXJlbnQgdG9sZCB0aGlzIGNoaWxkIHRvIHVzZSAke3VzZWRJZH0gKHRoZSBwYXJlbnQncyBJRCkuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Uj4ocCwgeyBbaWRQcm9wTmFtZV06IHVzZWRJZCB9KTtcbiAgICAgICAgfSwgW3VzZWRJZF0pO1xuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZWRJZDogdXNlZElkTG9jYWwsXG4gICAgICAgICAgICBnZXRVc2VkSWQ6IGdldFVzZWRJZExvY2FsLFxuICAgICAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzXG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByYW5kb21JZDoge1xuICAgICAgICAgICAgdXNlZElkLFxuICAgICAgICAgICAgZ2V0VXNlZElkXG4gICAgICAgIH0sXG4gICAgICAgIC4uLm1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUsXG4gICAgICAgIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCxcbiAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFxuICAgIH07XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUdsb2JhbEhhbmRsZXIsIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsLCBUYWdTZW5zaXRpdmVQcm9wcyB9IGZyb20gXCIuL3Byb3BzXCI7XHJcblxyXG5sZXQgcHVsc2UgPSAoXCJ2aWJyYXRlXCIgaW4gbmF2aWdhdG9yKSA/ICgoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMCkpIDogKCgpID0+IHsgfSk7XHJcblxyXG4vKipcclxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBlbmFibGUvZGlzYWJsZSBidXR0b24gdmlicmF0aW9uIHB1bHNlcyBvbiBhbiBhcHAtd2lkZSBzY2FsZS5cclxuICogXHJcbiAqIFxyXG4gKiBAcGFyYW0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcnVuIHdoZW4gYSBidXR0b24gaXMgdGFwcGVkLlxyXG4gKiAoRGVmYXVsdCBpcyBgKCkgPT4gbmF2aWdhdG9yLnZpYnJhdGUoMTApYCBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQsIGEgbm9vcCBvdGhlcndpc2UpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2V0QnV0dG9uVmlicmF0ZShmdW5jOiAoKSA9PiB2b2lkKSB7XHJcbiAgICBwdWxzZSA9IGZ1bmM7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEJ1dHRvblByZXNzRXZlbnQ8RXZlbnRUeXBlIGV4dGVuZHMgRXZlbnQ+ID0gRXZlbnRUeXBlICYgeyBbRXZlbnREZXRhaWxdOiB7IHByZXNzZWQ6IGJvb2xlYW4gfCBudWxsIH0gfTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUJ1dHRvblBhcmFtZXRlcnM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiBleHRlbmRzIFRhZ1NlbnNpdGl2ZVByb3BzPEU+IHtcclxuICAgIGRpc2FibGVkPzogYm9vbGVhbiB8IFwic29mdFwiIHwgXCJoYXJkXCI7XHJcbiAgICBwcmVzc2VkPzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBvblByZXNzPyhldmVudDogQnV0dG9uUHJlc3NFdmVudDxoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4+IHwgQnV0dG9uUHJlc3NFdmVudDxoLkpTWC5UYXJnZXRlZEtleWJvYXJkRXZlbnQ8RT4gfCBCdXR0b25QcmVzc0V2ZW50PGguSlNYLlRhcmdldGVkRXZlbnQ8RT4+Pik6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUJ1dHRvblJldHVyblR5cGU8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XHJcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xyXG4gICAgdXNlQXJpYUJ1dHRvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGV4Y2x1ZGVzKHRhcmdldDogXCJjbGlja1wiIHwgXCJzcGFjZVwiIHwgXCJlbnRlclwiLCBleGNsdWRlOiB1bmRlZmluZWQgfCB7IGNsaWNrPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIHNwYWNlPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIGVudGVyPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQgfSkge1xyXG4gICAgaWYgKGV4Y2x1ZGU/Llt0YXJnZXRdKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIHNlbGVjdGlvbi5jb250YWluc05vZGUgZG9lc24ndCBhY2NvdW50IGZvciBzZWxlY3Rpb24uaXNDb2xsYXBzZWQsXHJcbiAqIHNvIGhlcmUncyBhIHdvcmthcm91bmQgZm9yIHRoYXQuXHJcbiAqIFxyXG4gKiBXZSBhbHNvIG9ubHkgbG9vayBmb3IgdGhlIHNlbGVjdGlvbiBlbmQgdG8gb25seSBjYXRjaCB0aGUgXHJcbiAqIGVzc2Vuc2Ugb2YgYSBub24tZXhpc3RhbnQgXCJzZWxlY3Rpb25zdG9wXCIgZXZlbnQuXHJcbiAqIFxyXG4gKiBAcGFyYW0gZWxlbWVudCBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5mdW5jdGlvbiBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGVsZW1lbnQ6IEV2ZW50VGFyZ2V0IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHNlbGVjdGlvbj8ucmFuZ2VDb3VudCA/PyAwKTsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uIS5nZXRSYW5nZUF0KGkpITtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY29udGFpbnMocmFuZ2UuZW5kQ29udGFpbmVyKSAmJiAhc2VsZWN0aW9uPy5pc0NvbGxhcHNlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbiEudG9TdHJpbmcoKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIHRoZSBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnMgdG8gY3JlYXRlIGEgXCJwcmVzc1wiLWxpa2UgZXZlbnQgZm9yXHJcbiAqIGJ1dHRvbnMgYW5kIGFueXRoaW5nIGVsc2UgdGhhdCdzIFwiY2xpY2svdGFwL3ByZXNzL3RvdWNoXCItYWJsZS5cclxuICogXHJcbiAqIE5vdGFibHksIHRoZSBmb2xsb3dpbmcgY2FzZXMgYXJlIGNvdmVyZWQ6XHJcbiAqICogVGhlIHRhcmdldCBlbGVtZW50IGlzIHByb3Blcmx5IGZvY3VzZWQsIGV2ZW4gb24gaU9TIFNhZmFyaSAoKmVzcGVjaWFsbHkqIG9uIGlPUyBTYWZhcmkpXHJcbiAqICogRG91YmxlLWNsaWNrcyB3b24ndCBzZWxlY3QgdGV4dC4gXHJcbiAqICogQ29udmVyc2VseSwgbWFudWFsbHkgc2VsZWN0aW5nIHRleHQgd29uJ3QgaW52b2tlIGEgcHJlc3MuXHJcbiAqICogS2V5Ym9hcmQgZXZlbnRzICZtZGFzaDsgYGVudGVyYCBpbW1lZGlhdGVseSBpbnZva2VzIHRoZSBoYW5kbGVyLCB3aGlsZSBgc3BhY2VgIGludm9rZXMgaXQgb24ga2V5dXAuXHJcbiAqICogSGFwdGljIGZlZWRiYWNrIChvbiwgbGlrZSwgdGhlIG9uZSBicm93c2VyIGNvbWJpbmF0aW9uIHRoYXQgc3VwcG9ydHMgaXQgJm1kYXNoOyB0aGlzIGNhbiBiZSBkaXNhYmxlZCBhcHAtd2lkZSB3aXRoIGBzZXRCdXR0b25WaWJyYXRlYClcclxuICogXHJcbiAqIEluIGFkZGl0aW9uLCB3aGVuIHRoZSBDU1MgYDphY3RpdmVgIHBzZXVkby1jbGFzcyB3b3VsZCBhcHBseSB0byBhIG5vcm1hbCBidXR0b25cclxuICogKGkuZS4gd2hlbiBob2xkaW5nIHRoZSBzcGFjZWJhciBvciBkdXJpbmcgbW91c2Vkb3duKSwgYHsgXCJkYXRhLXBzZXVkby1hY3RpdmVcIjogXCJ0cnVlXCIgfWBcclxuICogaXMgYWRkZWQgdG8gdGhlIHByb3BzLiAgWW91IGNhbiBlaXRoZXIgbGV0IGl0IHBhc3MgdGhyb3VnaCBhbmQgc3R5bGUgaXQgdGhyb3VnaCBuZXcgQ1NTLFxyXG4gKiBvciBpbnNwZWN0IHRoZSByZXR1cm5lZCBwcm9wcyBmb3IgaXQgYW5kIGFkZCBlLmcuIGFuIGAuYWN0aXZlYCBjbGFzcyBmb3IgZXhpc3RpbmcgQ1NTXHJcbiAqIFxyXG4gKiBAcGFyYW0gb25DbGlja1N5bmMgXHJcbiAqIEBwYXJhbSBleGNsdWRlIFdoZXRoZXIgdGhlIHBvbHlmaWxsIHNob3VsZG4ndCBhcHBseSAoY2FuIHNwZWNpZnkgZm9yIHNwZWNpZmljIGludGVyYWN0aW9ucylcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VQcmVzc0V2ZW50SGFuZGxlcnM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PihvbkNsaWNrU3luYzogKChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PEU+KSA9PiB2b2lkKSB8IG51bGwgfCB1bmRlZmluZWQsIGV4Y2x1ZGU6IHVuZGVmaW5lZCB8IHsgY2xpY2s/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgc3BhY2U/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgZW50ZXI/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCB9KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4ge1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PEU+KHt9KTtcclxuXHJcbiAgICAvLyBBIGJ1dHRvbiBjYW4gYmUgYWN0aXZhdGVkIGluIG11bHRpcGxlIHdheXMsIHNvIG9uIHRoZSBvZmYgY2hhbmNlXHJcbiAgICAvLyB0aGF0IG11bHRpcGxlIGFyZSB0cmlnZ2VyZWQgYXQgb25jZSwgd2Ugb25seSAqYWN0dWFsbHkqIHJlZ2lzdGVyXHJcbiAgICAvLyBhIHByZXNzIG9uY2UgYWxsIG9mIG91ciBcIm9uXCIgc2lnbmFscyBoYXZlIHR1cm5lZCBiYWNrIHRvIFwib2ZmXCIuXHJcbiAgICAvLyBXZSBhcHByb3hpbWF0ZSB0aGlzIGJ5IGp1c3QgaW5jcmVtZW50aW5nIHdoZW4gYWN0aXZlLCBhbmRcclxuICAgIC8vIGRlY3JlbWVudGluZyB3aGVuIGRlYWN0aXZhdGVkLlxyXG4gICAgLy9cclxuICAgIC8vIEFzIGFuIGVtZXJnZW5jeSBmYWlsc2FmZSwgd2hlbiB0aGUgZWxlbWVudCBsb3NlcyBmb2N1cyxcclxuICAgIC8vIHRoaXMgaXMgcmVzZXQgYmFjayB0byAwLlxyXG4gICAgY29uc3QgW2FjdGl2ZSwgc2V0QWN0aXZlLCBnZXRBY3RpdmVdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gICAgLy8gSWYgd2UgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gY2hhbmdlcyB0byBpbmNsdWRlIHRoaXMgZWxlbWVudFxyXG4gICAgLy8gRFVSSU5HIGUuZy4gYSBtb3VzZWRvd24sIHRoZW4gd2UgZG9uJ3Qgd2FudCB0aGUgbW91c2V1cCB0byBcImNvdW50XCIsIGFzIGl0IHdlcmUsXHJcbiAgICAvLyBiZWNhdXNlIGl0cyBvbmx5IHB1cnBvc2Ugd2FzIHNlbGVjdGluZyB0ZXh0LCBub3QgY2xpY2tpbmcgYnV0dG9ucy5cclxuICAgIC8vXHJcbiAgICAvLyBUbyBjYXRjaCB0aGlzLCBhbnkgdGltZSB0aGUgdGV4dCBzZWxlY3Rpb24gaW5jbHVkZXMgdXMgd2hpbGUgaW4gdGhlIG1pZGRsZVxyXG4gICAgLy8gb2YgYSBjbGljaywgdGhpcyBmbGFnIGlzIHNldCwgd2hpY2ggY2FuY2VscyB0aGUgYWN0aXZhdGlvbiBvZiBhIHByZXNzLlxyXG4gICAgLy8gVGhlIGZsYWcgaXMgcmVzZXQgYW55IHRpbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBvciB0aGUgYnV0dG9uIGlzXHJcbiAgICAvLyBubyBsb25nZXIgYWN0aXZlLlxyXG4gICAgY29uc3QgW3RleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUsIHNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWVdID0gdXNlU3RhdGU8RGF0ZSB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwic2VsZWN0aW9uY2hhbmdlXCIsIF8gPT4ge1xyXG4gICAgICAgIHNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUocHJldiA9PiBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGdldEVsZW1lbnQoKSkgPT0gMCA/IG51bGwgOiBwcmV2ICE9IG51bGwgPyBwcmV2IDogbmV3IERhdGUoKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChhY3RpdmUgPT0gMClcclxuICAgICAgICAgICAgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZShudWxsKTtcclxuICAgIH0sIFthY3RpdmUgPT0gMF0pO1xyXG5cclxuICAgIGNvbnN0IG9uQWN0aXZlU3RhcnQgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25DbGlja1N5bmM+PigoXykgPT4ge1xyXG4gICAgICAgIHNldEFjdGl2ZShhID0+ICsrYSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBvbkFjdGl2ZVN0b3AgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25DbGlja1N5bmM+PigoZSkgPT4ge1xyXG4gICAgICAgIHNldEFjdGl2ZShhID0+IE1hdGgubWF4KDAsIC0tYSkpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgY29uc3QgdGltZURpZmZlcmVuY2UgPSAodGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSA9PSBudWxsID8gbnVsbCA6ICtjdXJyZW50VGltZSAtICt0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lKTtcclxuICAgICAgICBjb25zdCBjaGFyYWN0ZXJzU2VsZWN0ZWQgPSBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGdldEVsZW1lbnQoKSlcclxuXHJcbiAgICAgICAgLy8gSWYgd2UncmUgc2VsZWN0aW5nIHRleHQgKGhldXJpc3RpY2FsbHkgZGV0ZXJtaW5lZCBieSBzZWxlY3RpbmcgZm9yIGxvbmdlciB0aGFuIDEvNCBhIHNlY29uZCwgb3IgbW9yZSB0aGFuIDIgY2hhcmFjdGVycylcclxuICAgICAgICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBwcmVzcyBldmVudC5cclxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBtZWFzdXJlIGdseXBocyBpbnN0ZWFkIG9mIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgaWYgKGNoYXJhY3RlcnNTZWxlY3RlZCA+IDEgfHwgKCh0aW1lRGlmZmVyZW5jZSA/PyAwKSA+IDI1MCAmJiBjaGFyYWN0ZXJzU2VsZWN0ZWQgPj0gMSkpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZ2V0QWN0aXZlKCkgPD0gMCkge1xyXG4gICAgICAgICAgICBoYW5kbGVQcmVzcyhlKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVQcmVzcyA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvbkNsaWNrU3luYz4+KChlKSA9PiB7XHJcbiAgICAgICAgaWYgKG9uQ2xpY2tTeW5jKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBOb3RlOiBUaGUgZWxlbWVudCBpcyBmb2N1c2VkIGhlcmUgYmVjYXVzZSBvZiBpT1MgU2FmYXJpLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBJdCdzIGFsd2F5cyBpT1MgU2FmYXJpLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBpT1MgU2FmYXJpICh0ZXN0ZWQgb24gMTIpIGRvd25yaWdodCByZWZ1c2VzIHRvIGFsbG93IFxyXG4gICAgICAgICAgICAvLyBlbGVtZW50cyB0byBiZSBtYW51YWxseSBmb2N1c2VkIFVOTEVTUyBpdCBoYXBwZW5zIHdpdGhpblxyXG4gICAgICAgICAgICAvLyBhbiBldmVudCBoYW5kbGVyIGxpa2UgdGhpcy4gIEl0IGFsc28gZG9lc24ndCBmb2N1c1xyXG4gICAgICAgICAgICAvLyBidXR0b25zIGJ5IGRlZmF1bHQgd2hlbiBjbGlja2VkLCB0YXBwZWQsIGV0Yy5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gSWYgaXQgYmVjb21lcyBwcm9ibGVtYXRpYyB0aGF0IGJ1dHRvbi1saWtlcyBleHBsaWNpdGx5IGJlY29tZVxyXG4gICAgICAgICAgICAvLyBmb2N1c2VkIHdoZW4gdGhleSBhcmUgcHJlc3NlZCwgdGhlbiBhbiBhbHRlcm5hdGl2ZSBzb2x1dGlvbiBmb3JcclxuICAgICAgICAgICAgLy8gdGhlIHF1ZXN0aW9uIG9mIFwiaG93IGRvIG1lbnUgYnV0dG9ucyBrZWVwIHRoZWlyIG1lbnVzIG9wZW5cIlxyXG4gICAgICAgICAgICAvLyBhbmQgb3RoZXIgZm9jdXMtcmVsYXRlZCBub25zZW5zZSBuZWVkcyB0byBiZSBmaWd1cmVkIG91dC5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gRm9yIGlPUyBTYWZhcmkuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIFwiZm9jdXNcIiBpbiAoZWxlbWVudCBhcyBFdmVudFRhcmdldCBhcyBIVE1MRWxlbWVudCkpXHJcbiAgICAgICAgICAgICAgICAoZWxlbWVudCBhcyBFdmVudFRhcmdldCBhcyBIVE1MRWxlbWVudCB8IG51bGwpPy5mb2N1cygpO1xyXG5cclxuICAgICAgICAgICAgLy8gV2hhdGV2ZXIgdGhlIGJyb3dzZXIgd2FzIGdvaW5nIHRvIGRvIHdpdGggdGhpcyBldmVudCxcclxuICAgICAgICAgICAgLy8gZm9yZ2V0IGl0LiBXZSdyZSB0dXJuaW5nIGl0IGludG8gYSBcInByZXNzXCIgZXZlbnQuXHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFsc28gc3RvcCBhbnlvbmUgZWxzZSBmcm9tIGxpc3RlbmluZyB0byB0aGlzIGV2ZW50LFxyXG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBleHBsaWNpdGx5IGhhbmRsaW5nIGl0LlxyXG4gICAgICAgICAgICAvLyAoTm90YWJseSwgdGhpcyBhbGxvd3MgbGFiZWxzIHRvIHdyYXAgaW5wdXRzLCB3aXRoIHRoZW1cclxuICAgICAgICAgICAgLy8gYm90aCBoYXZpbmcgcHJlc3MgZXZlbnQgaGFuZGxlcnMsIHdpdGhvdXQgZG91YmxlLWZpcmluZylcclxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhhcHRpYyBmZWVkYmFjayBmb3IgdGhpcyBwcmVzcyBldmVudFxyXG4gICAgICAgICAgICBwdWxzZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWN0dWFsbHkgY2FsbCBvdXIgaGFuZGxlci5cclxuICAgICAgICAgICAgb25DbGlja1N5bmMoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSBleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xyXG4gICAgICAgIC8vIFN0b3AgZG91YmxlIGNsaWNrcyBmcm9tIHNlbGVjdGluZyB0ZXh0IGluIGFuIGNvbXBvbmVudCB0aGF0J3MgKnN1cHBvc2VkKiB0byBiZSBhY3RpbmcgbGlrZSBhIGJ1dHRvbixcclxuICAgICAgICAvLyBidXQgYWxzbyBkb24ndCBwcmV2ZW50IHRoZSB1c2VyIGZyb20gc2VsZWN0aW5nIHRoYXQgdGV4dCBtYW51YWxseSBpZiB0aGV5IHJlYWxseSB3YW50IHRvXHJcbiAgICAgICAgLy8gKHdoaWNoIHVzZXItc2VsZWN0OiBub25lIHdvdWxkIGRvLCBidXQgY2FuY2VsbGluZyBhIGRvdWJsZSBjbGljayBvbiBtb3VzZURvd24gZG9lc24ndClcclxuICAgICAgICBpZiAoZS5kZXRhaWwgPiAxKVxyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cclxuICAgICAgICBpZiAoZS5idXR0b24gPT09IDApXHJcbiAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbk1vdXNlVXAgPSBleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xyXG4gICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCAmJiBhY3RpdmUgPiAwKVxyXG4gICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IG9uQmx1ciA9IChfOiBoLkpTWC5UYXJnZXRlZEV2ZW50PEU+KSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKDApO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBjb25zdCBvbk1vdXNlTGVhdmUgPSBleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogb25CbHVyO1xyXG5cclxuICAgIGNvbnN0IG9uS2V5RG93biA9IGV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkgJiYgZXhjbHVkZXMoXCJlbnRlclwiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlOiBoLkpTWC5UYXJnZXRlZEtleWJvYXJkRXZlbnQ8RT4pID0+IHtcclxuICAgICAgICBpZiAoZS5rZXkgPT0gXCIgXCIgJiYgb25DbGlja1N5bmMgJiYgIWV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkpIHtcclxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgYWN0aXZhdGUgaXQgb24gYSBzcGFjZSBrZXlkb3duXHJcbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBkbyBwcmV2ZW50RGVmYXVsdCB0byBzdG9wIHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nLlxyXG4gICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZS5rZXkgPT0gXCJFbnRlclwiICYmICFleGNsdWRlcyhcImVudGVyXCIsIGV4Y2x1ZGUpKSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgb25BY3RpdmVTdGFydChlKTtcclxuICAgICAgICAgICAgb25BY3RpdmVTdG9wKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvbktleVVwID0gZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlOiBoLkpTWC5UYXJnZXRlZEtleWJvYXJkRXZlbnQ8RT4pID0+IHtcclxuICAgICAgICBpZiAoZS5rZXkgPT0gXCIgXCIgJiYgIWV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkpXHJcbiAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvbkNsaWNrID0gKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBpZiAoZS5kZXRhaWwgPiAxKSB7XHJcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHMoKHsgb25LZXlEb3duLCBvbktleVVwLCBvbkJsdXIsIG9uTW91c2VEb3duLCBvbk1vdXNlVXAsIG9uTW91c2VMZWF2ZSwgb25DbGljaywgc3R5bGU6ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lICE9IG51bGwpID8geyBjdXJzb3I6IFwidGV4dFwiIH0gOiB1bmRlZmluZWQsIC4uLnsgXCJkYXRhLXBzZXVkby1hY3RpdmVcIjogYWN0aXZlICYmICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lID09IG51bGwpID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSBhcyB7fSB9KSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhQnV0dG9uPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyB0YWcsIHByZXNzZWQsIG9uUHJlc3MsIGRpc2FibGVkIH06IFVzZUFyaWFCdXR0b25QYXJhbWV0ZXJzPEU+KTogVXNlQXJpYUJ1dHRvblJldHVyblR5cGU8RT4ge1xyXG5cclxuICAgIGZ1bmN0aW9uIHVzZUFyaWFCdXR0b25Qcm9wcyh7IFwiYXJpYS1wcmVzc2VkXCI6IGFyaWFQcmVzc2VkLCB0YWJJbmRleCwgcm9sZSwgLi4ucCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvcHMgPSB1c2VNZXJnZWRQcm9wczxFPih1c2VQcmVzc0V2ZW50SGFuZGxlcnM8RT4oKGUpID0+IChkaXNhYmxlZD8gbnVsbCA6IG9uUHJlc3MpPy4oZW5oYW5jZUV2ZW50KGUsIHsgcHJlc3NlZDogcHJlc3NlZCA9PSBudWxsID8gbnVsbCA6ICFwcmVzc2VkIH0pKSwgdW5kZWZpbmVkKSwgcCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VQcm9wcyA9IHsgcm9sZSwgdGFiSW5kZXgsIFwiYXJpYS1wcmVzc2VkXCI6IGFyaWFQcmVzc2VkID8/IChwcmVzc2VkID09PSB0cnVlID8gXCJ0cnVlXCIgOiBwcmVzc2VkID09PSBmYWxzZSA/IFwiZmFsc2VcIiA6IHVuZGVmaW5lZCkgfTtcclxuICAgICAgICBjb25zdCBidXR0b25Qcm9wcyA9IHsgLi4uYmFzZVByb3BzLCBkaXNhYmxlZDogKGRpc2FibGVkICYmIGRpc2FibGVkICE9IFwic29mdFwiKT8gdHJ1ZSA6IGZhbHNlLCBcImFyaWEtZGlzYWJsZWRcIjogKGRpc2FibGVkID09PSAnc29mdCc/ICd0cnVlJyA6IHVuZGVmaW5lZCkgfTtcclxuICAgICAgICBjb25zdCBkaXZQcm9wcyA9IHsgLi4uYmFzZVByb3BzLCB0YWJJbmRleDogdGFiSW5kZXggPz8gMCwgcm9sZTogcm9sZSA/PyBcImJ1dHRvblwiLCBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQ/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH07XHJcbiAgICAgICAgY29uc3QgYW5jaG9yUHJvcHMgPSB7IC4uLmRpdlByb3BzIH07XHJcblxyXG4gICAgICAgIHN3aXRjaCAodGFnKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJidXR0b25cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPihidXR0b25Qcm9wcywgcHJvcHMpO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBcImFcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPihhbmNob3JQcm9wcywgcHJvcHMpO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPihkaXZQcm9wcywgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUFyaWFCdXR0b25Qcm9wc1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgT25DaGlsZHJlbk1vdW50Q2hhbmdlLCByZXR1cm5UcnVlLCB1c2VDaGlsZHJlbkZsYWcsIHVzZUhhc0ZvY3VzLCB1c2VMaW5lYXJOYXZpZ2F0aW9uLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlQXJpYUJ1dHRvbiwgVXNlQXJpYUJ1dHRvblBhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcblxyXG5leHBvcnQgdHlwZSBVc2VBcmlhQWNjb3JkaW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUFyaWFBY2NvcmRpb25QYXJhbWV0ZXJzKSA9PiBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PikgPT4gVXNlQXJpYUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxcIm5hdmlnYXRlVG9GaXJzdFwiIHwgXCJuYXZpZ2F0ZVRvTGFzdFwiIHwgXCJuYXZpZ2F0ZVRvTmV4dFwiIHwgXCJuYXZpZ2F0ZVRvUHJldlwiPiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxudW1iZXIsIG5ldmVyPiB7XHJcbiAgICBhY2NvcmRpb246IHsgaW5pdGlhbEluZGV4PzogbnVtYmVyIHwgbnVsbDsgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25SZXR1cm5UeXBlSW5mbyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPG51bWJlciwgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25JbmZvQmFzZSwgXCJ0YWJiZWRcIiB8IFwib3BlblwiPiB7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgYWNjb3JkaW9uOiB7IGNoYW5nZUV4cGFuZGVkSW5kZXg6IChhcmc6IG51bWJlciB8ICgocHJldlN0YXRlOiBudW1iZXIgfCBudWxsKSA9PiBudW1iZXIgfCBudWxsKSB8IG51bGwpID0+IG51bWJlciB8IG51bGw7IH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFyaWFBY2NvcmRpb25SZXR1cm5UeXBlSW5mbyB7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb246IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlIHtcclxuICAgIHNldE9wZW5Gcm9tUGFyZW50KG9wZW46IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgZ2V0T3BlbkZyb21QYXJlbnQoKTogYm9vbGVhbiB8IG51bGw7XHJcbiAgICBmb2N1cygpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgbWFuYWdlZENoaWxkcmVuOiBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPG51bWJlciwgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25JbmZvQmFzZSwgXCJ0YWJiZWRcIiB8IFwib3BlblwiLCBcInN1YkluZm9cIiB8IFwiZmxhZ3NcIj5bXCJtYW5hZ2VkQ2hpbGRcIl07XHJcbiAgICBhY2NvcmRpb25TZWN0aW9uOiB7IG9wZW4/OiBib29sZWFuIHwgdW5kZWZpbmVkOyB9XHJcbiAgICBidXR0b246IE9taXQ8VXNlQXJpYUJ1dHRvblBhcmFtZXRlcnM8SGVhZGVyRWxlbWVudD4sIFwib25QcmVzc1wiIHwgXCJwcmVzc2VkXCI+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgYWNjb3JkaW9uU2VjdGlvbjoge1xyXG4gICAgICAgIGV4cGFuZGVkOiBib29sZWFuO1xyXG4gICAgICAgIGZvY3VzZWQ6IGJvb2xlYW47XHJcbiAgICAgICAgaGVhZGVySWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICBib2R5SWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICBnZXRIZWFkZXJJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgZ2V0Qm9keUlkKCk6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVXaXRoSG9va3M8SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvIHtcclxuICAgIC8qKiAqVW5zdGFibGUqICovXHJcbiAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PjtcclxuICAgIC8qKiAqVW5zdGFibGUqICovXHJcbiAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PjtcclxufVxyXG5cclxuXHJcbi8vZXhwb3J0IHR5cGUgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXI8RSBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUFyaWFCdXR0b25QYXJhbWV0ZXJzPEU+KSA9PiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclJldHVyblR5cGU8RT47XHJcbi8vZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IHsgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47IH1cclxuLy9leHBvcnQgdHlwZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHk8RSBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4gVXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UmV0dXJuVHlwZTxFPjtcclxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IHsgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+OyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvbjxIZWFkZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50Pih7IGFjY29yZGlvbjogeyBpbml0aWFsSW5kZXggfSwgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfTogVXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMpOiBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD4ge1xyXG5cclxuICAgIGNvbnN0IFtfY3VycmVudEZvY3VzZWRJbmRleCwgc2V0Q3VycmVudEZvY3VzZWRJbmRleCwgZ2V0Q3VycmVudEZvY3VzZWRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcclxuXHJcbiAgICBjb25zdCBtY1JldHVyblR5cGUgPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlLCBcInRhYmJlZFwiIHwgXCJvcGVuXCI+KHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHtcclxuICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPbkNoaWxkcmVuTW91bnRDaGFuZ2U8bnVtYmVyPj4oKG0sIHUpID0+IHsgb2NtYzIoKTsgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4obSwgdSk7IH0pLFxyXG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3RcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZCwgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0gfSA9IG1jUmV0dXJuVHlwZTtcclxuXHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvRmlyc3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7IGNoYW5nZVRhYmJlZEluZGV4KDApOyB9LCBbXSk7XHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTGFzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkpOyB9LCBbXSk7XHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvUHJldiA9IHVzZUNhbGxiYWNrKCgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoaSA9PiAoKGkgPz8gMCkgLSAxKSkgfSwgW10pO1xyXG4gICAgY29uc3QgbmF2aWdhdGVUb05leHQgPSB1c2VDYWxsYmFjaygoKSA9PiB7IGNoYW5nZVRhYmJlZEluZGV4KGkgPT4gKChpID8/IDApICsgMSkpIH0sIFtdKTtcclxuICAgIGNvbnN0IGxpbmVhclJldHVyblR5cGUgPSB1c2VMaW5lYXJOYXZpZ2F0aW9uPEhlYWRlckVsZW1lbnQ+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdCxcclxuICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3QsXHJcbiAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0LFxyXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldixcclxuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5cyxcclxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxyXG4gICAgICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBuYXZpZ2F0aW9uRGlyZWN0aW9uID8/IFwiYmxvY2tcIlxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGluZWFyTmF2aWdhdGlvblByb3BzIH0gPSBsaW5lYXJSZXR1cm5UeXBlO1xyXG5cclxuXHJcbiAgICBjb25zdCB7IGNoYW5nZUluZGV4OiBjaGFuZ2VFeHBhbmRlZEluZGV4LCBnZXRDdXJyZW50SW5kZXg6IF9nZXRDdXJyZW50RXhwYW5kZWRJbmRleCB9ID0gdXNlQ2hpbGRyZW5GbGFnKHtcclxuICAgICAgICBpbml0aWFsSW5kZXgsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAga2V5OiBcIm9wZW5cIixcclxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleDogY2hhbmdlVGFiYmVkSW5kZXgsIGdldEN1cnJlbnRJbmRleDogX2dldFRhYmJlZEluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdDogb2NtYzIgfSA9IHVzZUNoaWxkcmVuRmxhZyh7XHJcbiAgICAgICAgaW5pdGlhbEluZGV4LFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGtleTogXCJ0YWJiZWRcIixcclxuICAgICAgICBjbG9zZXN0Rml0OiB0cnVlLFxyXG4gICAgICAgIG9uSW5kZXhDaGFuZ2U6IHVzZUNhbGxiYWNrKChpOiBudW1iZXIgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KGkpPy5zdWJJbmZvLmZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbXSlcclxuICAgIH0pXHJcblxyXG4gICAgY29uc3QgdXNlQXJpYUFjY29yZGlvblNlY3Rpb246IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PiA9IHVzZUNhbGxiYWNrPFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50Pj4oKHsgYnV0dG9uOiB7IHRhZywgZGlzYWJsZWQgfSwgYWNjb3JkaW9uU2VjdGlvbjogeyBvcGVuOiBvcGVuRnJvbVVzZXIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IGluZGV4IH0gfSkgPT4ge1xyXG5cclxuXHJcbiAgICAgICAgY29uc3QgW29wZW5Gcm9tUGFyZW50LCBzZXRPcGVuRnJvbVBhcmVudCwgZ2V0T3BlbkZyb21QYXJlbnRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KG51bGwpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VCb2R5QXNTb3VyY2VJZCwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlSGVhZGVyQXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogYm9keUlkLCBnZXRVc2VkSWQ6IGdldEJvZHlJZCB9IH0gPSB1c2VSYW5kb21JZDxCb2R5RWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS1hY2NvcmRpb24tc2VjdGlvbi1ib2R5LVwiIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VIZWFkZXJBc1NvdXJjZUlkLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VCb2R5QXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogaGVhZGVySWQsIGdldFVzZWRJZDogZ2V0SGVhZGVySWQgfSB9ID0gdXNlUmFuZG9tSWQ8SGVhZGVyRWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS1hY2NvcmRpb24tc2VjdGlvbi1oZWFkZXItXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlQm9keUFzU291cmNlSWRQcm9wcyB9ID0gdXNlQm9keUFzU291cmNlSWQoKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlQm9keUFzUmVmZXJlbmNlcklkUHJvcHMgfSA9IHVzZUJvZHlBc1JlZmVyZW5jZXJJZDxCb2R5RWxlbWVudD4oXCJhcmlhLWxhYmVsbGVkYnlcIiBhcyBuZXZlcik7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlSGVhZGVyQXNTb3VyY2VJZFByb3BzIH0gPSB1c2VIZWFkZXJBc1NvdXJjZUlkKCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUhlYWRlckFzUmVmZXJlbmNlcklkUHJvcHMgfSA9IHVzZUhlYWRlckFzUmVmZXJlbmNlcklkPEhlYWRlckVsZW1lbnQ+KFwiYXJpYS1jb250cm9sc1wiIGFzIG5ldmVyKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb3BlbiA9ICgob3BlbkZyb21Vc2VyID8/IG9wZW5Gcm9tUGFyZW50KSA/PyBmYWxzZSk7XHJcbiAgICAgICAgLy9jb25zdCBnZXRPcGVuID0gdXNlU3RhYmxlR2V0dGVyKCEhb3Blbik7XHJcbiAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VTdGFibGVHZXR0ZXIoaW5kZXgpO1xyXG5cclxuICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldEhlYWRlckVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlSGVhZGVyUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PEhlYWRlckVsZW1lbnQ+KHt9KTtcclxuICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldEJvZHlFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUJvZHlSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8Qm9keUVsZW1lbnQ+KHt9KTtcclxuICAgICAgICBjb25zdCBmb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGdldEN1cnJlbnRGb2N1c2VkSW5kZXgoKSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgKGdldEhlYWRlckVsZW1lbnQoKSBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkKT8uZm9jdXMoKTtcclxuICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgY29uc3Qgb3BlblJlZiA9IHVzZVJlZih7XHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gISFnZXRPcGVuRnJvbVBhcmVudCgpLFxyXG4gICAgICAgICAgICBzZXQ6IChvcGVuOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXRPcGVuRnJvbVBhcmVudChvcGVuKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3Blbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlFbGVtZW50ID0gZ2V0Qm9keUVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50Rm9jdXNlZEluZGV4KGdldEluZGV4KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBib2R5RWxlbWVudC5mb2N1cygpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IHJldHVyblRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB0YWJiZWRSZWYgPSB1c2VSZWYoe1xyXG4gICAgICAgICAgICBnZXQ6ICgpID0+IChnZXRDdXJyZW50Rm9jdXNlZEluZGV4KCkgPT0gZ2V0SW5kZXgoKSksXHJcbiAgICAgICAgICAgIHNldDogKG9wZW46IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChvcGVuKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRGb2N1c2VkSW5kZXgoZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IHJldHVyblRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBfXzogdm9pZCA9IHVzZU1hbmFnZWRDaGlsZCh7XHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDoge1xyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuOiBvcGVuUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFiYmVkOiB0YWJiZWRSZWYuY3VycmVudFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN1YkluZm86IHtcclxuICAgICAgICAgICAgICAgICAgICBmb2N1cyxcclxuICAgICAgICAgICAgICAgICAgICBnZXRPcGVuRnJvbVBhcmVudCxcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcGVuRnJvbVBhcmVudFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIGluZm86IHsgaW5kZXgsIHNldE9wZW5Gcm9tUGFyZW50LCBnZXRPcGVuRnJvbVBhcmVudCwgZm9jdXMsIGZsYWdzOiB7IG9wZW46IG9wZW5SZWYuY3VycmVudCwgdGFiYmVkOiB0YWJiZWRSZWYuY3VycmVudCB9IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzKHsgW1wiYXJpYS1leHBhbmRlZFwiXTogYXJpYUV4cGFuZGVkLCBbXCJhcmlhLWRpc2FibGVkXCJdOiBhcmlhRGlzYWJsZWQsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4ge1xyXG5cclxuICAgICAgICAgICAgLy9jb25zdCBvbkZvY3VzID0gKCkgPT4geyBjaGFuZ2VUYWJiZWRJbmRleChpbmRleCk7IH1cclxuICAgICAgICAgICAgY29uc3Qgb25QcmVzcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChnZXRPcGVuRnJvbVBhcmVudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUV4cGFuZGVkSW5kZXgobnVsbCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRXhwYW5kZWRJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBwcm9wcy50YWJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlQXJpYUJ1dHRvblByb3BzIH0gPSB1c2VBcmlhQnV0dG9uKHsgdGFnLCBkaXNhYmxlZCwgb25QcmVzcyB9KTtcclxuICAgICAgICAgICAgY29uc3QgcmV0QiA9IHVzZUFyaWFCdXR0b25Qcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgICAgIC8vY29uc3QgcmV0QiA9IHVzZU1lcmdlZFByb3BzPEhlYWRlckVsZW1lbnQ+KHVzZVByZXNzRXZlbnRIYW5kbGVyczxIZWFkZXJFbGVtZW50PihvbkNsaWNrLCB1bmRlZmluZWQpLCBwcm9wcyk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8SGVhZGVyRWxlbWVudD4oe1xyXG4gICAgICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUYWJiZWRJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgLy9jb25zdCByZXQzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PlxyXG4gICAgICAgICAgICAvLyAgICA9IHVzZU1lcmdlZFByb3BzPEhlYWRlckVsZW1lbnQ+KHJldEQsIHsgb25Gb2N1cyB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXNlSGFzRm9jdXNQcm9wcyh1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHModXNlSGVhZGVyQXNTb3VyY2VJZFByb3BzKHVzZUhlYWRlckFzUmVmZXJlbmNlcklkUHJvcHMoe1xyXG4gICAgICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IChhcmlhRXhwYW5kZWQgPz8gb3BlbiA/PyBmYWxzZSkudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiAoYXJpYURpc2FibGVkID8/IChvcGVuID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQpKSxcclxuICAgICAgICAgICAgICAgIC4uLnVzZUhlYWRlclJlZkVsZW1lbnRQcm9wcyhyZXRCKVxyXG4gICAgICAgICAgICB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+KSkpKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyh7IHJvbGUsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldDEgPSB1c2VCb2R5QXNSZWZlcmVuY2VySWRQcm9wcyh7IHJvbGU6IHJvbGUgPz8gXCJyZWdpb25cIiwgLi4ucHJvcHMgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldDIgPSB1c2VCb2R5QXNTb3VyY2VJZFByb3BzKHJldDEpO1xyXG4gICAgICAgICAgICByZXQyLnRhYkluZGV4ID8/PSAtMTtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZUJvZHlSZWZFbGVtZW50UHJvcHMocmV0Mik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhY2NvcmRpb25TZWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRlZDogb3BlbixcclxuICAgICAgICAgICAgICAgIGZvY3VzZWQ6IChnZXRDdXJyZW50Rm9jdXNlZEluZGV4KCkgPT0gaW5kZXgpLFxyXG4gICAgICAgICAgICAgICAgYm9keUlkLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVySWQsXHJcbiAgICAgICAgICAgICAgICBnZXRCb2R5SWQsXHJcbiAgICAgICAgICAgICAgICBnZXRIZWFkZXJJZFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzLFxyXG4gICAgICAgICAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyxcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtY1JldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIGFjY29yZGlvbjogeyBjaGFuZ2VFeHBhbmRlZEluZGV4IH0sXHJcbiAgICAgICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb24sXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMsIHVzZVJhbmRvbUlkLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZyB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZVByZXNzRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcclxuXHJcbmludGVyZmFjZSBVTEk8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgcHJlZml4TGFiZWw6IHN0cmluZztcclxuICAgIHByZWZpeElucHV0OiBzdHJpbmc7XHJcbiAgICB0YWdJbnB1dDogRWxlbWVudFRvVGFnPElucHV0RWxlbWVudD47XHJcbiAgICB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIExhYmVsT21pdHMgPSBrZXlvZiBVTEk8YW55LCBhbnk+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMYWJlbFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTE9taXRzIGV4dGVuZHMgTGFiZWxPbWl0cz4ge1xyXG4gICAgbGFiZWw6IE9taXQ8VUxJPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgTE9taXRzPlxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgbGFiZWw6IHtcclxuICAgICAgICBsYWJlbElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgaW5wdXRJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKiAqKlN0YWJsZSoqICovXHJcbiAgICAgICAgZ2V0TGFiZWxJZDogKCkgPT4gc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKiAqKlN0YWJsZSoqICovXHJcbiAgICAgICAgZ2V0SW5wdXRJZDogKCkgPT4gc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxhYmVsUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgLyoqICpOb3RhYmx5IHVuc3RhYmxlKiAqL1xyXG4gICAgdXNlTGFiZWxJbnB1dDogKCkgPT4geyB1c2VMYWJlbElucHV0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjsgfTtcclxuICAgIC8qKiAqTm90YWJseSB1bnN0YWJsZSogKi9cclxuICAgIHVzZUxhYmVsTGFiZWw6ICgpID0+IHsgdXNlTGFiZWxMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47IH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIElEIGFuZCBcImFyaWEtbGFiZWxsZWRieVwiIGZvciB0d28gZWxlbWVudHMsIGFuIFwiaW5wdXRcIiBlbGVtZW50IGFuZCBhIFwibGFiZWxcIiBlbGVtZW50LlxyXG4gKiBcclxuICogUmV0dXJucyB0aGUgYHVzZVJlZmVyZW5jZWRJZFByb3BzYCBob29rcyBpZiB5b3UgbmVlZCB0byBhbHNvIGFkZCBvdGhlciBJRC1yZWZlcmVuY2VyIGF0dHJpYnV0ZXMsIGxpa2UgYGZvcmBcclxuICogXHJcbiAqIEBzZWUgdXNlSW5wdXRMYWJlbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxhYmVsPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbGFiZWw6IHsgcHJlZml4SW5wdXQsIHByZWZpeExhYmVsLCB0YWdJbnB1dCwgdGFnTGFiZWwgfSB9OiBVc2VMYWJlbFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIG5ldmVyPik6IFVzZUxhYmVsUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4ge1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VMYWJlbEFzU291cmNlSWQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUxhYmVsQXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogbGFiZWxJZCwgZ2V0VXNlZElkOiBnZXRMYWJlbElkIH0gfSA9IHVzZVJhbmRvbUlkPExhYmVsRWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IHByZWZpeExhYmVsIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZUlucHV0QXNTb3VyY2VJZCwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlSW5wdXRBc1JlZmVyZW5jZXJJZCwgcmFuZG9tSWQ6IHsgdXNlZElkOiBpbnB1dElkLCBnZXRVc2VkSWQ6IGdldElucHV0SWQgfSB9ID0gdXNlUmFuZG9tSWQ8SW5wdXRFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogcHJlZml4SW5wdXQgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VMYWJlbEFzU291cmNlSWRQcm9wcyB9ID0gdXNlTGFiZWxBc1NvdXJjZUlkKCk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VJbnB1dEFzU291cmNlSWRQcm9wcyB9ID0gdXNlSW5wdXRBc1NvdXJjZUlkKCk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlTGFiZWxBc1JlZmVyZW5jZXJJZFByb3BzIH0gPSB1c2VMYWJlbEFzUmVmZXJlbmNlcklkPElucHV0RWxlbWVudD4oXCJhcmlhLWxhYmVsbGVkYnlcIiBhcyBuZXZlcik7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlSW5wdXRBc1JlZmVyZW5jZXJJZFByb3BzIH0gPSB1c2VJbnB1dEFzUmVmZXJlbmNlcklkPExhYmVsRWxlbWVudD4oXCJmb3JcIik7XHJcblxyXG4gICAgY29uc3QgaXNTeW50aGV0aWNMYWJlbCA9ICh0YWdJbnB1dCAhPSBcImlucHV0XCIgfHwgdGFnTGFiZWwgIT0gXCJsYWJlbFwiKTtcclxuXHJcbiAgICBjb25zdCB1c2VMYWJlbExhYmVsOiAoKCkgPT4geyB1c2VMYWJlbExhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfSkgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VMYWJlbExhYmVsKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUxhYmVsTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhvdXRGb3IgPSB1c2VMYWJlbEFzU291cmNlSWRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhGb3IgPSB1c2VJbnB1dEFzUmVmZXJlbmNlcklkUHJvcHMocHJvcHNXaXRob3V0Rm9yKTtcclxuICAgICAgICAgICAgICAgIGlmICh0YWdMYWJlbCA9PSBcImxhYmVsXCIgJiYgdGFnSW5wdXQgPT0gXCJpbnB1dFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1dpdGhGb3I7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzV2l0aG91dEZvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtpc1N5bnRoZXRpY0xhYmVsXSk7XHJcblxyXG4gICAgY29uc3QgdXNlTGFiZWxJbnB1dCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUxhYmVsSW5wdXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlTGFiZWxJbnB1dFByb3BzOiAoeyBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRieSwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoIWFyaWFMYWJlbGxlZGJ5KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeSA9IHVzZUlucHV0QXNTb3VyY2VJZFByb3BzKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzV2l0aEFyaWFMYWJlbGxlZEJ5ID0gdXNlTGFiZWxBc1JlZmVyZW5jZXJJZFByb3BzKHByb3BzV2l0aG91dEFyaWFMYWJlbGxlZEJ5KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N5bnRoZXRpY0xhYmVsICYmICFwcm9wc1tcImFyaWEtbGFiZWxcIl0pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzV2l0aEFyaWFMYWJlbGxlZEJ5O1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbaXNTeW50aGV0aWNMYWJlbF0pXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VMYWJlbElucHV0LFxyXG4gICAgICAgIHVzZUxhYmVsTGFiZWwsXHJcbiAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgbGFiZWxJZCxcclxuICAgICAgICAgICAgaW5wdXRJZCxcclxuICAgICAgICAgICAgZ2V0TGFiZWxJZCxcclxuICAgICAgICAgICAgZ2V0SW5wdXRJZFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCB0eXBlIENoZWNrYm94Q2hlY2tlZFR5cGUgPSBib29sZWFuIHwgXCJtaXhlZFwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzPElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+IHtcclxuICAgIGxhYmVsOiBVc2VMYWJlbFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGUsIFwicHJlZml4TGFiZWxcIiB8IFwicHJlZml4SW5wdXRcIj5bXCJsYWJlbFwiXTtcclxuICAgIGNoZWNrYm94TGlrZToge1xyXG4gICAgICAgIGxhYmVsUG9zaXRpb246IFwid3JhcHBpbmdcIiB8IFwic2VwYXJhdGVcIjtcclxuICAgICAgICAvKiogVGhlIHJvbGUgYXR0cmlidXRlIHRvIHVzZSwgd2hlbiBhcHBsaWNhYmxlICovXHJcbiAgICAgICAgcm9sZTogc3RyaW5nO1xyXG4gICAgICAgIGRpc2FibGVkOiBib29sZWFuO1xyXG4gICAgICAgIGNoZWNrZWQ6IENoZWNrYm94Q2hlY2tlZFR5cGU7XHJcbiAgICAgICAgb25JbnB1dD8oZXZlbnQ6IGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlPik6IHZvaWQ7XHJcbiAgICAgICAgb25JbnB1dD8oZXZlbnQ6IGguSlNYLlRhcmdldGVkRXZlbnQ8TGFiZWxUeXBlPik6IHZvaWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGhhbmRsZXNJbnB1dCA9IDxFIGV4dGVuZHMgRWxlbWVudD4odGFnOiBFbGVtZW50VG9UYWc8RT4sIGxhYmVsUG9zaXRpb246IFwid3JhcHBpbmdcIiB8IFwic2VwYXJhdGVcIiwgd2hpY2g6IFwiaW5wdXQtZWxlbWVudFwiIHwgXCJsYWJlbC1lbGVtZW50XCIpID0+IHtcclxuICAgIGlmIChsYWJlbFBvc2l0aW9uID09PSBcInNlcGFyYXRlXCIpIHtcclxuICAgICAgICBpZiAod2hpY2ggPT09IFwiaW5wdXQtZWxlbWVudFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBlbHNlIGlmICh3aGljaCA9PT0gXCJsYWJlbC1lbGVtZW50XCIpXHJcbiAgICAgICAgICAgIHJldHVybiB0YWcgIT0gXCJpbnB1dFwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGFiZWxQb3NpdGlvbiA9PT0gXCJ3cmFwcGluZ1wiKSB7XHJcbiAgICAgICAgaWYgKHdoaWNoID09PSBcImlucHV0LWVsZW1lbnRcIilcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICh3aGljaCA9PSBcImxhYmVsLWVsZW1lbnRcIilcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQ8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7XHJcbiAgICBnZXRJbnB1dEVsZW1lbnQ6ICgpID0+IElucHV0VHlwZSB8IG51bGw7XHJcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xyXG4gICAgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHM6ICh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudDxMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHtcclxuICAgIC8qKiAqVW5zdGFibGUqICovXHJcbiAgICB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wczogKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgY2hlY2tib3hMaWtlOiB7XHJcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgICAgICBnZXRMYWJlbEVsZW1lbnQ6ICgpID0+IExhYmVsVHlwZSB8IG51bGw7XHJcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgICAgICBnZXRJbnB1dEVsZW1lbnQ6ICgpID0+IElucHV0VHlwZSB8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGVJbmZvPElucHV0VHlwZSwgTGFiZWxUeXBlPiB7XHJcbiAgICAvKiogKk5vdGFibHkgdW5zdGFibGUqICovXHJcbiAgICB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQ6IFVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDxJbnB1dFR5cGU+O1xyXG4gICAgLyoqICpOb3RhYmx5IHVuc3RhYmxlKiAqL1xyXG4gICAgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50OiAoKSA9PiB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzOiAoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+OyB9O1xyXG59XHJcblxyXG4vKipcclxuICogSGFuZGxlcyBsYWJlbCB0eXBlICh3cmFwcGluZyBvciBzZXBhcmF0ZSkgZm9yIGNoZWNrYm94ZXMsIHJhZGlvcywgc3dpdGNoZXMsIGV0Yy5cclxuICogXHJcbiAqIElmIGl0J3MgYSB0b2dnbGVhYmxlIGNsaWNrLXRoaW5nIHdpdGggYSBsYWJlbCAodGhhdCBjYW4gYWxzbyBiZSBjbGlja2VkKSwgdGhlbiBpdCdzIGEgY2hlY2tib3gtbGlrZS5cclxuICogQHBhcmFtIHBhcmFtMCBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlPElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgY2hlY2tib3hMaWtlOiB7IGNoZWNrZWQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCByb2xlLCBvbklucHV0IH0sIGxhYmVsOiB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9IH06IFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KTogVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dFR5cGUsIExhYmVsVHlwZT4ge1xyXG5cclxuICAgIGNvbnN0IHN0YWJsZU9uSW5wdXQgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxJbnB1dFR5cGU+IHwgaC5KU1guVGFyZ2V0ZWRFdmVudDxMYWJlbFR5cGU+KSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgb25JbnB1dD8uKGUgYXMgaC5KU1guVGFyZ2V0ZWRFdmVudDxJbnB1dFR5cGU+KTsgfSk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0OiB1c2VJTElucHV0LCB1c2VMYWJlbExhYmVsOiB1c2VJTExhYmVsLCBsYWJlbCB9ID0gdXNlTGFiZWw8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KHsgbGFiZWw6IHsgcHJlZml4TGFiZWw6IFwiYXJpYS1jaGVja2JveC1sYWJlbC1cIiwgcHJlZml4SW5wdXQ6IFwiYXJpYS1jaGVja2JveC1pbnB1dC1cIiwgdGFnSW5wdXQ6IHRhZ0lucHV0LCB0YWdMYWJlbDogdGFnTGFiZWwgfSB9KTtcclxuXHJcblxyXG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRMYWJlbEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlTGFiZWxSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8TGFiZWxUeXBlPigpO1xyXG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRJbnB1dEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlSW5wdXRSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8SW5wdXRUeXBlPigpO1xyXG5cclxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDogVXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50PElucHV0VHlwZT4gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VDaGVja2JveElucHV0RWxlbWVudCgpIHtcclxuICAgICAgICBjb25zdCB0YWcgPSB0YWdJbnB1dDtcclxuICAgICAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXRQcm9wczogdXNlSUxJbnB1dFByb3BzIH0gPSB1c2VJTElucHV0KCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8SW5wdXRUeXBlPih7fSk7XHJcblxyXG4gICAgICAgIC8vIG9uQ2xpY2sgYW5kIG9uQ2hhbmdlIGFyZSBhIGJpdCBtZXNzeSwgc28gd2UgbmVlZCB0b1xyXG4gICAgICAgIC8vICphbHdheXMqIG1ha2Ugc3VyZSB0aGF0IHRoZSB2aXNpYmxlIHN0YXRlIGlzIGNvcnJlY3RcclxuICAgICAgICAvLyBhZnRlciBhbGwgdGhlIGV2ZW50IGR1c3Qgc2V0dGxlcy5cclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMjc0NSxcclxuICAgICAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMTg5OSNpc3N1ZWNvbW1lbnQtNTI1NjkwMTk0XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgdGFnID09IFwiaW5wdXRcIikge1xyXG4gICAgICAgICAgICAgICAgKGVsZW1lbnQgYXMgRWxlbWVudCBhcyBIVE1MSW5wdXRFbGVtZW50KS5pbmRldGVybWluYXRlID0gKGNoZWNrZWQgPT09IFwibWl4ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAoZWxlbWVudCBhcyBFbGVtZW50IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSAoY2hlY2tlZCA9PT0gdHJ1ZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFt0YWcsIGNoZWNrZWRdKVxyXG5cclxuICAgICAgICByZXR1cm4geyBnZXRJbnB1dEVsZW1lbnQ6IGdldEVsZW1lbnQsIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzIH07XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiwgQ2hyb21lIHdvbid0IGZpcmUgb25JbnB1dCBldmVudHMgZm9yIHJhZGlvIGJ1dHRvbnMgdGhhdCBhcmUgdGFiSW5kZXg9LTE/P1xyXG4gICAgICAgICAgICAvLyBOZWVkcyBpbnZlc3RpZ2F0aW5nLCBidXQgb25JbnB1dCB3b3JrcyBmaW5lIGluIEZpcmVmb3hcclxuICAgICAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgICAgICBsZXQgcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4gPSB1c2VQcmVzc0V2ZW50SGFuZGxlcnM8SW5wdXRUeXBlPihkaXNhYmxlZCB8fCAhaGFuZGxlc0lucHV0KHRhZywgbGFiZWxQb3NpdGlvbiwgXCJpbnB1dC1lbGVtZW50XCIpID8gdW5kZWZpbmVkIDogc3RhYmxlT25JbnB1dCwgdW5kZWZpbmVkKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0YWcgPT0gXCJpbnB1dFwiKVxyXG4gICAgICAgICAgICAgICAgcHJvcHMub25JbnB1dCA9IChlOiBFdmVudCkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgcHJvcHMgPSB1c2VSZWZFbGVtZW50UHJvcHModXNlSUxJbnB1dFByb3BzKHByb3BzKSk7XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSB3cmFwcGVkIGxhYmVsIGhhbmRsZXMgYWxsIGludGVyYWN0aW9ucyxcclxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoaXMgZWxlbWVudCBjYW4ndCBiZSBpbnRlcmFjdGVkIHdpdGhcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgaXQncyBhbiBpbnB1dCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgcHJvcHMuaW5lcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uRm9jdXMgPSBfID0+IChnZXRMYWJlbEVsZW1lbnQoKSBhcyBIVE1MRWxlbWVudCB8IG51bGwpPy5mb2N1cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gXCJpbnB1dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCA9IChjaGVja2VkID09PSB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnJvbGUgPSByb2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtY2hlY2tlZFwiXSA9IGNoZWNrZWQgPT09IFwibWl4ZWRcIiA/IFwibWl4ZWRcIiA6IGNoZWNrZWQgPT09IHRydWUgPyBcInRydWVcIiA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IGRpc2FibGVkLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBsYWJlbCBjbGlja3MgY2FuJ3QgYWZmZWN0IHRoZSBjaGVja2JveCB3aGlsZSBpdCdzIGRpc2FibGVkXHJcbiAgICAgICAgICAgIHByb3BzLm9uQ2xpY2sgPSBkaXNhYmxlZCA/ICgoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSkgOiBwcm9wcy5vbkNsaWNrO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZUlucHV0UmVmRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzPElucHV0VHlwZT4ocDAsIHByb3BzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3VzZUlMSW5wdXQsIHJvbGUsIGxhYmVsUG9zaXRpb24sIGRpc2FibGVkLCBjaGVja2VkLCB0YWdJbnB1dF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KCkge1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ0xhYmVsO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTGFiZWxMYWJlbFByb3BzOiB1c2VJTExhYmVsUHJvcHMgfSA9IHVzZUlMTGFiZWwoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPiB7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPiA9IHVzZVByZXNzRXZlbnRIYW5kbGVyczxMYWJlbFR5cGU+KGRpc2FibGVkIHx8ICFoYW5kbGVzSW5wdXQodGFnLCBsYWJlbFBvc2l0aW9uLCBcImxhYmVsLWVsZW1lbnRcIikgPyB1bmRlZmluZWQgOiBzdGFibGVPbklucHV0LCB1bmRlZmluZWQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocDAudGFiSW5kZXggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcy50YWJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAocDAucm9sZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLnJvbGUgPSByb2xlO1xyXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbXCJhcmlhLWRpc2FibGVkXCJdID0gZGlzYWJsZWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1jaGVja2VkXCJdID0gY2hlY2tlZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIG9uZSBjYXNlIHdoZXJlIHRoZXJlJ3MgYWxtb3N0IG5vdGhpbmcgdG8gZG9cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IG5vcm1hbCBjYXNlIHdoZXJlIGV2ZXJ5dGhpbmcgYWN0cyBhY2NvcmRpbmcgbm9ybWFsIEhUTUwgbWVjaGFuaWNzLlxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSnVzdCBtYWtlIHN1cmUgdGhhdCBsYWJlbCBjbGlja3MgY2FuJ3QgYWZmZWN0IHRoZSBjaGVja2JveCB3aGlsZSBpdCdzIGRpc2FibGVkXHJcbiAgICAgICAgICAgIG5ld1Byb3BzLm9uQ2xpY2sgPSBkaXNhYmxlZCA/ICgoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSkgOiBuZXdQcm9wcy5vbkNsaWNrO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZUxhYmVsUmVmRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzPExhYmVsVHlwZT4obmV3UHJvcHMsIHVzZUlMTGFiZWxQcm9wcyhwMCkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzIH07XHJcblxyXG4gICAgfSwgW3VzZUlMTGFiZWwsIGRpc2FibGVkLCBjaGVja2VkLCByb2xlLCBsYWJlbFBvc2l0aW9uLCB0YWdMYWJlbF0pO1xyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCxcclxuICAgICAgICB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsXHJcbiAgICAgICAgY2hlY2tib3hMaWtlOiB7XHJcbiAgICAgICAgICAgIGdldExhYmVsRWxlbWVudCxcclxuICAgICAgICAgICAgZ2V0SW5wdXRFbGVtZW50LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFiZWxcclxuICAgIH07XHJcblxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBPblRhYmJhYmxlSW5kZXhDaGFuZ2UsIHVzZU1lcmdlZFByb3BzLCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtbGlzdC1uYXZpZ2F0aW9uXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VQcmVzc0V2ZW50SGFuZGxlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcbmltcG9ydCB7IHVzZUxhYmVsLCBVc2VMYWJlbFJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XHJcblxyXG5leHBvcnQgdHlwZSBMaXN0Ym94U2luZ2xlU2VsZWN0RXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IHsgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfSB9ICYgUGljazxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+LCBcInRhcmdldFwiIHwgXCJjdXJyZW50VGFyZ2V0XCI+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+IHtcclxuICAgIGxpc3Rib3hTaW5nbGU6IHtcclxuICAgICAgICBzZWxlY3Rpb25Nb2RlOiBcImZvY3VzXCIgfCBcImFjdGl2YXRlXCI7XHJcbiAgICAgICAgb25TZWxlY3Q/KGV2ZW50OiBMaXN0Ym94U2luZ2xlU2VsZWN0RXZlbnQ8RWxlbWVudD4pOiB2b2lkO1xyXG4gICAgICAgIHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PjtcclxuICAgICAgICB0YWdMaXN0OiBFbGVtZW50VG9UYWc8TGlzdEVsZW1lbnQ+O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVycyBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8e30sIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sIFwic3ViSW5mb1wiPiB7XHJcbiAgICBsaXN0Ym94U2luZ2xlSXRlbTogeyBkaXNhYmxlZD86IGJvb2xlYW47IH1cclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgdHlwZSBVc2VMaXN0Ym94U2luZ2xlSXRlbTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChpbmZvOiBVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnMpID0+IFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxMaXN0SXRlbUVsZW1lbnQ+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4ge1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiB7XHJcbiAgICB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RJdGVtRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RJdGVtRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4sIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4ge1xyXG4gICAgdXNlTGlzdGJveFNpbmdsZUl0ZW06IFVzZUxpc3Rib3hTaW5nbGVJdGVtPExpc3RJdGVtRWxlbWVudD47XHJcbiAgICB1c2VMaXN0Ym94U2luZ2xlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD47XHJcbiAgICB1c2VMaXN0Ym94U2luZ2xlTGFiZWw6ICgpID0+IHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYUxpc3Rib3hTaW5nbGU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XHJcbiAgICBsaXN0Ym94U2luZ2xlOiB7IHNlbGVjdGlvbk1vZGUsIHRhZ0xhYmVsLCB0YWdMaXN0LCBvblNlbGVjdCwgLi4uX2xicyB9LFxyXG4gICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXgsIC4uLnNzIH0sXHJcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxuIH0sXHJcbiAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxyXG4gICAgbWFuYWdlZENoaWxkcmVuOiB7IC4uLm1jIH0sXHJcbiAgICByb3ZpbmdUYWJJbmRleDogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIC4uLnJ0aSB9LFxyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyAuLi50biB9XHJcbn06IFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+KTogVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVXaXRoSG9va3M8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50PiB7XHJcblxyXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0LCB1c2VMYWJlbExhYmVsLCAuLi5sYWJlbFJldHVyblR5cGUgfSA9IHVzZUxhYmVsPExpc3RFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcclxuICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICBwcmVmaXhMYWJlbDogXCJhcmlhLWxpc3Rib3gtbGFiZWwtXCIsXHJcbiAgICAgICAgICAgIHByZWZpeElucHV0OiBcImFyaWEtbGlzdGJveC1cIixcclxuICAgICAgICAgICAgdGFnSW5wdXQ6IHRhZ0xpc3QsXHJcbiAgICAgICAgICAgIHRhZ0xhYmVsOiB0YWdMYWJlbFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCwgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcywgLi4ubGlzdFJldHVyblR5cGUgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4oe1xyXG5cclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxuIH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4ubHMgfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4ubWMgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgICAgICAuLi5ydGksXHJcbiAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25UYWJiYWJsZUluZGV4Q2hhbmdlPigoaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPy4oaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uTW9kZSA9PSBcImZvY3VzXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoY2hpbGRyZW4uZ2V0QXQoaSEpPy5zdWJJbmZvLmdldEVsZW1lbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldClcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Q/Lih7IHRhcmdldCwgY3VycmVudFRhcmdldDogdGFyZ2V0LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IGkhIH0gfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IC4uLnNzLCBzZWxlY3RlZEluZGV4IH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdG5cclxuICAgIH0pO1xyXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSB9ID0gbGlzdFJldHVyblR5cGU7XHJcbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXRQcm9wcyB9ID0gdXNlTGFiZWxJbnB1dCgpO1xyXG4gICAgY29uc3Qgc3RhYmxlT25TZWxlY3QgPSB1c2VTdGFibGVDYWxsYmFjayhvblNlbGVjdCA/PyAoKCkgPT4geyB9KSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZUxpc3Rib3hTaW5nbGVJdGVtID0gdXNlQ2FsbGJhY2s8VXNlTGlzdGJveFNpbmdsZUl0ZW08TGlzdEl0ZW1FbGVtZW50Pj4oKHsgbGlzdGJveFNpbmdsZUl0ZW06IHsgZGlzYWJsZWQgfSwgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXggfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXg6IHJ0aV9yZXQsIHNpbmdsZVNlbGVjdGlvbjogc3NfcmV0LCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQoe1xyXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQsXHJcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICAgICAgc3ViSW5mbzoge31cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IG1hbmFnZWRDaGlsZC5pbmRleDtcclxuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHJ0aV9yZXQuZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBydGlfcmV0LnRhYmJhYmxlICYmIHNlbGVjdGlvbk1vZGUgPT0gXCJmb2N1c1wiKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFibGVPblNlbGVjdD8uKHsgdGFyZ2V0OiBlbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBlbGVtZW50LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IGluZGV4IH0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbcnRpX3JldC50YWJiYWJsZSwgc2VsZWN0aW9uTW9kZSwgaW5kZXhdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyxcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9yZXQsXHJcbiAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbjogc3NfcmV0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEl0ZW1FbGVtZW50Pj4ocHJvcHM6IFApIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RJdGVtRWxlbWVudD4gPSB1c2VQcmVzc0V2ZW50SGFuZGxlcnM8TGlzdEl0ZW1FbGVtZW50PihkaXNhYmxlZCA/IG51bGwgOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHJ0aV9yZXQuZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlT25TZWxlY3Q/Lih7IHRhcmdldDogZWxlbWVudCwgY3VycmVudFRhcmdldDogZWxlbWVudCwgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBpbmRleCB9IH0pO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQpO1xyXG5cclxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwib3B0aW9uXCI7XHJcbiAgICAgICAgICAgIC8vcHJvcHNbXCJhcmlhLXNldHNpemVcIl0gPSAoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkgKyAxKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAvL3Byb3BzW1wiYXJpYS1wb3NpbnNldFwiXSA9IChpbmZvLmluZGV4ICsgMSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXNlbGVjdGVkXCJdID0gKHNzX3JldC5zZWxlY3RlZCA/PyBmYWxzZSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxyXG4gICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWRpc2FibGVkXCJdID0gXCJ0cnVlXCI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzKHVzZU1lcmdlZFByb3BzPExpc3RJdGVtRWxlbWVudD4obmV3UHJvcHMsIHByb3BzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsIHNlbGVjdGlvbk1vZGVdKTtcclxuXHJcblxyXG4gICAgY29uc3QgdXNlTGlzdGJveFNpbmdsZUxhYmVsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZUxhYmVsKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlTGFiZWxMYWJlbFByb3BzIH0gPSB1c2VMYWJlbExhYmVsKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VMYWJlbExhYmVsUHJvcHMocHJvcHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHMgfTtcclxuICAgIH0sIFt1c2VMYWJlbExhYmVsXSk7XHJcblxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZUl0ZW0sXHJcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZVByb3BzLFxyXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCxcclxuICAgICAgICAuLi5saXN0UmV0dXJuVHlwZSxcclxuICAgICAgICAuLi5sYWJlbFJldHVyblR5cGVcclxuICAgICAgICAvKmxhYmVsOiBsYWJlbFJldHVyblR5cGUubGFiZWwsXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBsaXN0UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IGxpc3RSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLnR5cGVhaGVhZE5hdmlnYXRpb24qL1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZVByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pIHtcclxuICAgICAgICBwcm9wcy5yb2xlID0gXCJsaXN0Ym94XCI7XHJcbiAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHModXNlTGFiZWxJbnB1dFByb3BzKHByb3BzKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgT25UYWJiYWJsZUluZGV4Q2hhbmdlLCByZXR1cm5GYWxzZSwgdXNlTGF5b3V0RWZmZWN0LCB1c2VMaXN0TmF2aWdhdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCB1c2VNZXJnZWRQcm9wcywgdXNlUGFzc2l2ZVN0YXRlLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VQcmVzc0V2ZW50SGFuZGxlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcbmltcG9ydCB7IHVzZUxhYmVsIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XHJcblxyXG5leHBvcnQgdHlwZSBMaXN0Ym94TXVsdGlTZWxlY3RFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0geyBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiBib29sZWFuIH0gfSAmIFBpY2s8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPiwgXCJ0YXJnZXRcIiB8IFwiY3VycmVudFRhcmdldFwiPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4ge1xyXG4gICAgbGlzdGJveE11bHRpOiB7XHJcbiAgICAgICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xyXG4gICAgICAgIHRhZ0xpc3Q6IEVsZW1lbnRUb1RhZzxMaXN0RWxlbWVudD5cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVycyBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8SW5mbywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiwgXCJzdWJJbmZvXCI+IHtcclxuICAgIGxpc3Rib3hNdWx0aUl0ZW06IHsgZGlzYWJsZWQ/OiBib29sZWFuOyB9ICYgSW5mbztcclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgdHlwZSBVc2VMaXN0Ym94TXVsdGlJdGVtPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChpbmZvOiBVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVycykgPT4gVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVXaXRoSG9va3M8RT47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlSW5mbzxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88RT4ge1xyXG4gICAgbGlzdGJveE11bHRpSXRlbToge1xyXG4gICAgICAgIHRhYmJhYmxlOiBib29sZWFuO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVXaXRoSG9va3M8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVJbmZvPEU+IHtcclxuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCwgSW5mbywgbmV2ZXI+IHtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiB7XHJcbiAgICB1c2VMaXN0Ym94TXVsdGlJdGVtOiBVc2VMaXN0Ym94TXVsdGlJdGVtPExpc3RJdGVtRWxlbWVudD47XHJcbiAgICB1c2VMaXN0Ym94TXVsdGlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PjtcclxuICAgIHVzZUxpc3Rib3hNdWx0aUxhYmVsOiAoKSA9PiB7IHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfVxyXG59XHJcblxyXG5cclxuaW50ZXJmYWNlIEluZm8ge1xyXG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW47XHJcbiAgICBvblNlbGVjdD8oZXZlbnQ6IChMaXN0Ym94TXVsdGlTZWxlY3RFdmVudDxFbGVtZW50PikpOiB2b2lkO1xyXG59XHJcblxyXG5cclxuLypleHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aVJldHVyblR5cGU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4sIFwidXNlTGlzdE5hdmlnYXRpb25DaGlsZFwiIHwgXCJ1c2VMaXN0TmF2aWdhdGlvblByb3BzXCI+IHtcclxuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW06IFVzZUxpc3Rib3hNdWx0aUl0ZW08TGlzdEl0ZW1FbGVtZW50PjtcclxuICAgIHVzZUxpc3Rib3hNdWx0aVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+O1xyXG4gICAgdXNlTGlzdGJveE11bHRpTGFiZWw6ICgpID0+IHsgdXNlTGlzdGJveE11bHRpTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+OyB9XHJcbn0qL1xyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhTGlzdGJveE11bHRpPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgbGlzdGJveE11bHRpOiB7IHRhZ0xhYmVsLCB0YWdMaXN0IH0sXHJcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxuIH0sXHJcbiAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxyXG4gICAgbWFuYWdlZENoaWxkcmVuOiB7IC4uLm1jIH0sXHJcbiAgICByb3ZpbmdUYWJJbmRleDogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIC4uLnJ0aSB9LFxyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyAuLi50biB9XHJcbn06IFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4pOiBVc2VMaXN0Ym94TXVsdGlSZXR1cm5UeXBlV2l0aEhvb2tzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4ge1xyXG5cclxuXHJcbiAgICAvL2NvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0Rm9jdXNlZElubmVyIH0gPSB1c2VIYXNGb2N1czxMaXN0RWxlbWVudD4oe30pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dCwgdXNlTGFiZWxMYWJlbCB9ID0gdXNlTGFiZWw8TGlzdEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIHByZWZpeExhYmVsOiBcImFyaWEtbGlzdGJveC1sYWJlbC1cIixcclxuICAgICAgICAgICAgcHJlZml4SW5wdXQ6IFwiYXJpYS1saXN0Ym94LVwiLFxyXG4gICAgICAgICAgICB0YWdMYWJlbDogdGFnTGFiZWwsXHJcbiAgICAgICAgICAgIHRhZ0lucHV0OiB0YWdMaXN0XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbGlzdFJldHVyblR5cGUgPSB1c2VMaXN0TmF2aWdhdGlvbjxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBJbmZvLCBuZXZlcj4oe1xyXG5cclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxuIH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4ubHMgfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4ubWMgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgICAgICAuLi5ydGksXHJcbiAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25UYWJiYWJsZUluZGV4Q2hhbmdlPigoaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPy4oaSk7XHJcbiAgICAgICAgICAgICAgICAvKmlmIChzZWxlY3Rpb25Nb2RlID09IFwiZm9jdXNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChjaGlsZHJlbi5nZXRBdChpISk/LnN1YkluZm8uZ2V0RWxlbWVudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdD8uKHsgdGFyZ2V0LCBjdXJyZW50VGFyZ2V0OiB0YXJnZXQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogaSEgfSB9KTtcclxuICAgICAgICAgICAgICAgIH0qL1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IHNldFRhYmJhYmxlSW5kZXggfVxyXG4gICAgfSA9IGxpc3RSZXR1cm5UeXBlXHJcblxyXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHMgfSA9IHVzZUxhYmVsSW5wdXQoKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0U2hpZnRIZWxkLCBzZXRTaGlmdEhlbGRdID0gdXNlUGFzc2l2ZVN0YXRlKG51bGwsIHJldHVybkZhbHNlKTtcclxuXHJcbiAgICBjb25zdCB1c2VMaXN0Ym94TXVsdGlJdGVtID0gdXNlQ2FsbGJhY2s8VXNlTGlzdGJveE11bHRpSXRlbTxMaXN0SXRlbUVsZW1lbnQ+PigoeyBsaXN0Ym94TXVsdGlJdGVtOiB7IHNlbGVjdGVkLCBkaXNhYmxlZCwgb25TZWxlY3QgfSwgbWFuYWdlZENoaWxkLCBsaXN0TmF2aWdhdGlvbjogbHMsIHJvdmluZ1RhYkluZGV4OiBydGkgfSkgPT4ge1xyXG4gICAgICAgIHR5cGUgRSA9IExpc3RJdGVtRWxlbWVudDtcclxuICAgICAgICBjb25zdCBnZXRTZWxlY3RlZCA9IHVzZVN0YWJsZUdldHRlcihzZWxlY3RlZCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8RT4oe30pO1xyXG4gICAgICAgIGNvbnN0IHN0YWJsZU9uU2VsZWN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sob25TZWxlY3QgPz8gKCgpID0+IHsgfSkpO1xyXG5cclxuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcywgcm92aW5nVGFiSW5kZXg6IHJ0aTJfcmV0IH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHsgbGlzdE5hdmlnYXRpb246IGxzLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4OiBydGksIHN1YkluZm86IHsgc2VsZWN0ZWQsIG9uU2VsZWN0IH0gfSk7XHJcblxyXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGdldFNoaWZ0SGVsZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFibGVPblNlbGVjdD8uKHsgdGFyZ2V0OiBlbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBlbGVtZW50LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiB0cnVlIH0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbcnRpMl9yZXQudGFiYmFibGVdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTGlzdGJveE11bHRpSXRlbVByb3BzLCBsaXN0Ym94TXVsdGlJdGVtOiB7IGdldFNlbGVjdGVkLCB0YWJiYWJsZTogcnRpMl9yZXQudGFiYmFibGUgfSwgcm92aW5nVGFiSW5kZXg6IHJ0aTJfcmV0IH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiA9IHVzZVByZXNzRXZlbnRIYW5kbGVyczxFPihkaXNhYmxlZCA/IG51bGwgOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE11bHRpICR7bWFuYWdlZENoaWxkLmluZGV4fSBpcyAke2dldFNlbGVjdGVkKCkudG9TdHJpbmcoKX0gYW5kIGNoYW5naW5nIHRvICR7KCFnZXRTZWxlY3RlZCgpKS50b1N0cmluZygpfWApXHJcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG1hbmFnZWRDaGlsZC5pbmRleCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgc3RhYmxlT25TZWxlY3Q/Lih7IC4uLmUsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWQ6ICFnZXRTZWxlY3RlZCgpIH0gfSk7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH0sIHt9KTtcclxuXHJcbiAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcIm9wdGlvblwiO1xyXG4gICAgICAgICAgICAvL3Byb3BzW1wiYXJpYS1zZXRzaXplXCJdID0gKGNoaWxkQ291bnQpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIC8vcHJvcHNbXCJhcmlhLXBvc2luc2V0XCJdID0gKGluZm8uaW5kZXggKyAxKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBwcm9wc1tcImFyaWEtc2VsZWN0ZWRcIl0gPSAocnRpMl9yZXQudGFiYmFibGUgPz8gZmFsc2UpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZClcclxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IFwidHJ1ZVwiO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlTWVyZ2VkUHJvcHM8RT4obmV3UHJvcHMsIHByb3BzKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LCBbdXNlTGlzdE5hdmlnYXRpb25DaGlsZF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUxpc3Rib3hNdWx0aUxhYmVsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTGlzdGJveE11bHRpTGFiZWwoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlTGlzdGJveE11bHRpTGFiZWxQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHVzZUxhYmVsTGFiZWxQcm9wcyB9ID0gdXNlTGFiZWxMYWJlbCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTGFiZWxMYWJlbFByb3BzKHByb3BzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHMgfTtcclxuICAgIH0sIFt1c2VMYWJlbExhYmVsXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VMaXN0Ym94TXVsdGlJdGVtLFxyXG4gICAgICAgIHVzZUxpc3Rib3hNdWx0aVByb3BzLFxyXG4gICAgICAgIHVzZUxpc3Rib3hNdWx0aUxhYmVsLFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBsaXN0UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbGlzdFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB1c2VMaXN0Ym94TXVsdGlQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IHtcclxuICAgICAgICBwcm9wcy5yb2xlID0gXCJsaXN0Ym94XCI7XHJcbiAgICAgICAgcHJvcHNbXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiXSA9IFwidHJ1ZVwiO1xyXG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzKHVzZUxhYmVsSW5wdXRQcm9wcyh1c2VNZXJnZWRQcm9wczxMaXN0RWxlbWVudD4oeyBvbktleURvd24sIG9uS2V5VXAsIG9uZm9jdXNvdXQ6IG9uRm9jdXNPdXQgfSwgcHJvcHMpKSk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBvbktleURvd24oZTogS2V5Ym9hcmRFdmVudCkgeyBpZiAoZS5rZXkgPT0gXCJTaGlmdFwiKSBzZXRTaGlmdEhlbGQodHJ1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIG9uS2V5VXAoZTogS2V5Ym9hcmRFdmVudCkgeyBpZiAoZS5rZXkgPT0gXCJTaGlmdFwiKSBzZXRTaGlmdEhlbGQoZmFsc2UpOyB9XHJcbiAgICBmdW5jdGlvbiBvbkZvY3VzT3V0KF86IEZvY3VzRXZlbnQpIHsgc2V0U2hpZnRIZWxkKGZhbHNlKTsgfVxyXG5cclxufSIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUdsb2JhbEhhbmRsZXIsIHVzZUhhc0ZvY3VzLCB1c2VNZXJnZWRQcm9wcywgdXNlUGFzc2l2ZVN0YXRlLCB1c2VSYW5kb21JZCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcbmV4cG9ydCB0eXBlIFVzZVRvb2x0aXBUcmlnZ2VyPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHM6ICh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+IH07XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbHRpcFBhcmFtZXRlcnMgeyBtb3VzZW92ZXJEZWxheT86IG51bWJlciwgbW91c2VvdXREZWxheT86IG51bWJlciwgZm9jdXNEZWxheT86IG51bWJlciB9XHJcbmV4cG9ydCB0eXBlIFVzZVRvb2x0aXA8VHJpZ2dlclR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIFRvb2x0aXBUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlVG9vbHRpcFBhcmFtZXRlcnMpID0+IFVzZVRvb2x0aXBSZXR1cm5UeXBlV2l0aEhvb2tzPFRyaWdnZXJUeXBlLCBUb29sdGlwVHlwZT47XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbHRpcFJldHVyblR5cGVJbmZvIHtcclxuICAgIGlzT3BlbjogYm9vbGVhbjtcclxuICAgIGdldElzT3BlbjogKCkgPT4gYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sdGlwUmV0dXJuVHlwZVdpdGhIb29rczxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQsIFRvb2x0aXBUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlVG9vbHRpcDogKCkgPT4ge1xyXG4gICAgICAgIHVzZVRvb2x0aXBQcm9wczogKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VG9vbHRpcFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUb29sdGlwVHlwZT47XHJcbiAgICB9O1xyXG4gICAgdXNlVG9vbHRpcFRyaWdnZXI6IFVzZVRvb2x0aXBUcmlnZ2VyPFRyaWdnZXJUeXBlPjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFUb29sdGlwPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudCwgVG9vbHRpcFR5cGUgZXh0ZW5kcyBFbGVtZW50Pih7IG1vdXNlb3ZlckRlbGF5LCBtb3VzZW91dERlbGF5LCBmb2N1c0RlbGF5IH06IFVzZVRvb2x0aXBQYXJhbWV0ZXJzKTogVXNlVG9vbHRpcFJldHVyblR5cGVXaXRoSG9va3M8VHJpZ2dlclR5cGUsIFRvb2x0aXBUeXBlPiB7XHJcblxyXG4gICAgbW91c2VvdmVyRGVsYXkgPz89IDQwMDtcclxuICAgIG1vdXNlb3V0RGVsYXkgPz89IDQwO1xyXG4gICAgZm9jdXNEZWxheSA/Pz0gMTtcclxuXHJcbiAgICAvLyBUaGUgZXNjYXBlIGtleSBzaG91bGQgY2xvc2UgdG9vbHRpcHMsIGJ1dCBkbyBub3RoaW5nIGVsc2UuXHJcbiAgICAvLyAoaS5lLiBjbG9zaW5nIGEgdG9vbHRpcCBpbiBhIGRpYWxvZyBNVVNUIE5PVCBjbG9zZSB0aGUgZGlhbG9nIHRvbylcclxuICAgIC8vIFRPRE86IFRvb2x0aXBzIGFyZSwgZWZmZWN0aXZlbHksIGFsd2F5cyB0aGUgdG9wbW9zdCBjb21wb25lbnQsXHJcbiAgICAvLyBzbyB3ZSBjYW4ganVzdCBoYXZlIHRoZW0gbGlzdGVuIHRvIGFuZCBzd2FsbG93IGFsbCBcIkVzY2FwZVwiXHJcbiAgICAvLyBrZXkgcHJlc3NlcyBiZWZvcmUgYW55b25lIGVsc2UuIEZvciBhIG1vcmUgZ2VuZXJhbCBwb3B1cCxcclxuICAgIC8vIG9yIGEgdG9vbHRpcCBpbiBhIHRvb2x0aXAgKCEhKSBhIGRpZmZlcmVudCBzb2x1dGlvbiB3b3VsZCBiZSBuZWVkZWQuXHJcbiAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcImtleWRvd25cIiwgKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoZ2V0T3BlbigpICYmIGUua2V5ID09PSBcIkVzY2FwZVwiICYmICFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBzZXRPcGVuKGZhbHNlKTtcclxuICAgICAgICAgICAgc2V0VHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICBzZXRUb29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIHNldFRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICBzZXRUb29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB7IGNhcHR1cmU6IHRydWUgfSk7XHJcblxyXG4gICAgY29uc3QgW29wZW4sIHNldE9wZW4sIGdldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQsLy86IHVzZVRvb2x0aXBJZFByb3BzLCBcclxuICAgICAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50LC8vOiB1c2VUb29sdGlwSWRSZWZlcmVuY2luZ1Byb3BzIFxyXG4gICAgfSA9IHVzZVJhbmRvbUlkPFRvb2x0aXBUeXBlPih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLXRvb2x0aXAtXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XHJcblxyXG4gICAgY29uc3QgWywgc2V0VHJpZ2dlckZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlKHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGVsYXkgPSBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDE7XHJcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgJiYgaXNGaW5pdGUoZGVsYXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gc2V0VHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZChmb2N1c2VkKSwgZm9jdXNlZCA/IGZvY3VzRGVsYXkgOiAxKTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBbLCBzZXRUb29sdGlwRm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICBjb25zdCBkZWxheSA9IGZvY3VzZWQgPyBmb2N1c0RlbGF5IDogMTtcclxuICAgICAgICBpZiAoZGVsYXkgIT0gbnVsbCAmJiBpc0Zpbml0ZShkZWxheSkpIHtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUb29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZvY3VzZWQpLCBkZWxheSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9KSwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgWywgc2V0VHJpZ2dlckhvdmVyXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VTdGFibGVDYWxsYmFjaygoaG92ZXJpbmc6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICBjb25zdCBkZWxheSA9IGhvdmVyaW5nID8gbW91c2VvdmVyRGVsYXkgOiBtb3VzZW91dERlbGF5O1xyXG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHNldFRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkKGhvdmVyaW5nKSwgZGVsYXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSksIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFssIHNldFRvb2x0aXBIb3Zlcl0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGhvdmVyaW5nOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGVsYXkgPSBob3ZlcmluZyA/IG1vdXNlb3ZlckRlbGF5IDogbW91c2VvdXREZWxheTtcclxuICAgICAgICBpZiAoZGVsYXkgIT0gbnVsbCAmJiBpc0Zpbml0ZShkZWxheSkpIHtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUb29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZChob3ZlcmluZyksIGRlbGF5KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBbdHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCwgc2V0VHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQsIHNldFRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFt0b29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkLCBzZXRUb29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFt0b29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZCwgc2V0VG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0T3Blbih0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIHx8IHRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkIHx8IHRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQpO1xyXG4gICAgfSwgW3RyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQgfHwgdHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCB8fCB0b29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZF0pXHJcblxyXG4gICAgY29uc3QgdXNlVG9vbHRpcFRyaWdnZXI6IFVzZVRvb2x0aXBUcmlnZ2VyPFRyaWdnZXJUeXBlPiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVRvb2x0aXBUcmlnZ2VyKCkge1xyXG5cclxuICAgICAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInBvaW50ZXJtb3ZlXCIsIGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xyXG4gICAgICAgICAgICBzZXRUcmlnZ2VySG92ZXIodGFyZ2V0ID09IGdldEVsZW1lbnQoKSBhcyBOb2RlIHx8ICEhZ2V0RWxlbWVudCgpPy5jb250YWlucyh0YXJnZXQpKTtcclxuICAgICAgICB9LCB7IGNhcHR1cmU6IHRydWUgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIG9uVG91Y2hFbmQoZTogVG91Y2hFdmVudCkge1xyXG4gICAgICAgICAgICAoZS50YXJnZXQgYXMgYW55KS5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VIYXNGb2N1czxUcmlnZ2VyVHlwZT4oeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQ6IHNldFRyaWdnZXJGb2N1c2VkIH0pXHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VUb29sdGlwVHJpZ2dlclByb3BzKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+IHtcclxuICAgICAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgfSA9IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ8VHJpZ2dlclR5cGU+KFwiYXJpYS1kZXNjcmliZWRieVwiIGFzIG5ldmVyKTtcclxuICAgICAgICAgICAgLy8gTm90ZTogVGhvdWdoIGl0J3MgaW1wb3J0YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGZvY3VzaW5nIGFjdGl2YXRlcyBhIHRvb2x0aXAsXHJcbiAgICAgICAgICAgIC8vIGl0J3MgcGVyZmVjdGx5IHJlYXNvbmFibGUgdGhhdCBhIGNoaWxkIGVsZW1lbnQgd2lsbCBiZSB0aGUgb25lIHRoYXQncyBmb2N1c2VkLFxyXG4gICAgICAgICAgICAvLyBub3QgdGhpcyBvbmUsIHNvIHdlIGRvbid0IHNldCB0YWJJbmRleD0wXHJcbiAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID8/PSAtMTtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyhcclxuICAgICAgICAgICAgICAgIHVzZUhhc0ZvY3VzUHJvcHMoXHJcbiAgICAgICAgICAgICAgICAgICAgdXNlTWVyZ2VkUHJvcHM8VHJpZ2dlclR5cGU+KHsgb25Ub3VjaEVuZCB9LCAocHJvcHMgYXMgYW55KSBhcyB1bmtub3duIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPilcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMgfTtcclxuXHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgdXNlVG9vbHRpcCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVRvb2x0aXAoKSB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50KCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VIYXNGb2N1czxUb29sdGlwVHlwZT4oeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQ6IHNldFRvb2x0aXBGb2N1c2VkIH0pXHJcblxyXG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwicG9pbnRlcm1vdmVcIiwgZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChlLnRhcmdldCBhcyBIVE1MRWxlbWVudCk7XHJcbiAgICAgICAgICAgIHNldFRvb2x0aXBIb3Zlcih0YXJnZXQgPT0gZ2V0RWxlbWVudCgpIGFzIE5vZGUgfHwgISFnZXRFbGVtZW50KCk/LmNvbnRhaW5zKHRhcmdldCkpO1xyXG4gICAgICAgIH0sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlVG9vbHRpcFByb3BzKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VG9vbHRpcFR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VG9vbHRpcFR5cGU+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzKHVzZUhhc0ZvY3VzUHJvcHModXNlTWVyZ2VkUHJvcHM8VG9vbHRpcFR5cGU+KHt9LCBwcm9wcykpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZVRvb2x0aXBQcm9wcyB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlVG9vbHRpcCxcclxuICAgICAgICB1c2VUb29sdGlwVHJpZ2dlcixcclxuICAgICAgICBpc09wZW46IG9wZW4sXHJcbiAgICAgICAgZ2V0SXNPcGVuOiBnZXRPcGVuXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgTWFuYWdlZENoaWxkcmVuLCByZXR1cm5OdWxsLCB1c2VHcmlkTmF2aWdhdGlvbiwgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzLCB1c2VMYXlvdXRFZmZlY3QsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbywgdXNlUGFzc2l2ZVN0YXRlLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm8sIHVzZVNvcnRhYmxlQ2hpbGRyZW4sIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm8sIFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1ncmlkLW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgQ29tcGFyZSwgR2V0SW5kZXgsIEdldFZhbHVlLCBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2Utc29ydGFibGUtY2hpbGRyZW5cIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcbmV4cG9ydCB0eXBlIFRhYmxlVmFsdWVUeXBlID0gc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IGJvb2xlYW4gfCBEYXRlO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlQm9keVBhcmFtZXRlcnMgeyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlUm93UGFyYW1ldGVyczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8VXNlQXJpYVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4sIG5ldmVyLCBuZXZlciwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIHt9PiwgXCJzdWJJbmZvXCI+IHtcclxuICAgIHRhYmxlUm93OiBQaWNrPFVzZUFyaWFUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBcImxvY2F0aW9uXCI+O1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzPFVzZUFyaWFUYWJsZUNlbGxTdWJJbmZvLCBuZXZlciwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwgVXNlQXJpYVRhYmxlQ2VsbFN1YkluZm8+IHsgfVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgbG9jYXRpb246IFwiaGVhZFwiIHwgXCJib2R5XCIgfCBcImZvb3RcIjtcclxuICAgIGdldENlbGxzKCk6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDZWxsRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPFVzZUFyaWFUYWJsZUNlbGxTdWJJbmZvPj4sIFwidGFiYmFibGVcIj47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlQ2VsbFN1YkluZm8ge1xyXG4gICAgbG9jYXRpb246IFwiaGVhZFwiIHwgXCJib2R5XCIgfCBcImZvb3RcIjtcclxuICAgIHZhbHVlOiBUYWJsZVZhbHVlVHlwZTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PiB7IHRhYmxlSGVhZGVyQ2VsbDogeyBzb3J0KCk6IHZvaWQgfSB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBVc2VBcmlhVGFibGVDZWxsU3ViSW5mbywgbmV2ZXI+IHsgfVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFUYWJsZUJvZHlSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Um93RWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPFVzZUFyaWFUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+Pj4sIG5ldmVyLCBbXT4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIFVzZUFyaWFUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBuZXZlcj4geyB9XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVDZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQXJpYVRhYmxlQ2VsbFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PiB7IHVzZVRhYmxlQ2VsbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+OyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFyaWFUYWJsZVJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7IHVzZVRhYmxlQ2VsbDogVXNlQXJpYVRhYmxlQ2VsbDxDZWxsRWxlbWVudD47IHVzZVRhYmxlUm93UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvd0VsZW1lbnQ+OyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlQm9keVJldHVyblR5cGVXaXRoSG9va3M8Qm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhVGFibGVCb2R5UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHsgdXNlVGFibGVCb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keVNlY3Rpb25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keVNlY3Rpb25FbGVtZW50PiB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlUmV0dXJuVHlwZVdpdGhIb29rczxUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFyaWFUYWJsZVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7XHJcbiAgICB1c2VUYWJsZVJvdzogVXNlQXJpYVRhYmxlUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PjtcclxuICAgIHVzZVRhYmxlQm9keTogVXNlQXJpYVRhYmxlQm9keTxCb2R5U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PjtcclxuICAgIHVzZVRhYmxlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlQXJpYVRhYmxlQ2VsbDxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKHA6IFVzZUFyaWFUYWJsZUNlbGxQYXJhbWV0ZXJzKSA9PiBVc2VBcmlhVGFibGVDZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsRWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZUFyaWFUYWJsZVJvdzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChwOiBVc2VBcmlhVGFibGVSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50PikgPT4gVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZUFyaWFUYWJsZUJvZHk8Qm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAocDogVXNlQXJpYVRhYmxlQm9keVBhcmFtZXRlcnMpID0+IFVzZUFyaWFUYWJsZUJvZHlSZXR1cm5UeXBlV2l0aEhvb2tzPEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFUYWJsZTxcclxuICAgIFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXHJcbiAgICBCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxyXG4gICAgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXHJcbiAgICBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnRcclxuPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCB0eXBlYWhlYWROYXZpZ2F0aW9uIH06IFVzZUFyaWFUYWJsZVBhcmFtZXRlcnMpOiBVc2VBcmlhVGFibGVSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYmxlRWxlbWVudCwgQm9keVNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4ge1xyXG5cclxuICAgIGNvbnN0IFtnZXRDdXJyZW50U29ydENvbHVtbiwgc2V0Q3VycmVudFNvcnRDb2x1bW5dID0gdXNlUGFzc2l2ZVN0YXRlPHsgaW5kZXg6IG51bWJlciwgZGlyZWN0aW9uOiBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCIgfSB8IG51bGw+KG51bGwsIHJldHVybk51bGwpO1xyXG4gICAgY29uc3QgYm9keVNvcnQgPSB1c2VSZWY8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCk7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHMsXHJcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3csXHJcbiAgICAgICAgLi4uZ3JpZE5hdlJldDFcclxuICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvbjxUYWJsZUVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBVc2VBcmlhVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50PiwgVXNlQXJpYVRhYmxlQ2VsbFN1YkluZm8sIG5ldmVyLCBuZXZlcj4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb24sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuOiByb3dzIH0gfSA9IGdyaWROYXZSZXQxO1xyXG5cclxuICAgIGNvbnN0IHVzZVRhYmxlUm93ID0gdXNlQ2FsbGJhY2s8VXNlQXJpYVRhYmxlUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50Pj4oKHsgYXNDaGlsZFJvd09mU2VjdGlvbiwgYXNQYXJlbnRSb3dPZkNlbGxzLCB0YWJsZVJvdzogeyBsb2NhdGlvbiB9IH06IFVzZUFyaWFUYWJsZVJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+KTogVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4gPT4ge1xyXG5cclxuICAgICAgICBjb25zdCBnZXRDZWxscyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNlbGxzO1xyXG4gICAgICAgIH0sIFtdKVxyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCxcclxuICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyxcclxuICAgICAgICAgICAgLi4uZ3JpZE5hdlJldDJcclxuICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25Sb3coeyBhc0NoaWxkUm93T2ZTZWN0aW9uOiB7IC4uLmFzQ2hpbGRSb3dPZlNlY3Rpb24sIHN1YkluZm86IHsgZ2V0Q2VsbHMsIGxvY2F0aW9uIH0gfSwgYXNQYXJlbnRSb3dPZkNlbGxzIH0pO1xyXG5cclxuICAgICAgICBjb25zdCB7IGFzUGFyZW50T2ZDZWxsczogeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW46IGNlbGxzIH0gfSB9ID0gZ3JpZE5hdlJldDI7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZVRhYmxlQ2VsbCA9IHVzZUNhbGxiYWNrPFVzZUFyaWFUYWJsZUNlbGw8Q2VsbEVsZW1lbnQ+PigoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgc3ViSW5mbyB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzLFxyXG4gICAgICAgICAgICAgICAgLi4uZ3JpZE5hdlJldDNcclxuICAgICAgICAgICAgfSA9IHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCh7IGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4LCBzdWJJbmZvIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc29ydCA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRJbmZvID0gZ2V0Q3VycmVudFNvcnRDb2x1bW4oKSA/PyB7IGluZGV4OiAtMSwgZGlyZWN0aW9uOiAnYXNjZW5kaW5nJyB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbEluZGV4ID0gbWFuYWdlZENoaWxkLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvcnRJbmZvLmluZGV4ICE9IGNlbGxJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0SW5mby5kaXJlY3Rpb25bMF0gPT0gJ2EnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0SW5mby5kaXJlY3Rpb24gPSAnZGVzY2VuZGluZyc7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0SW5mby5kaXJlY3Rpb24gPSAnYXNjZW5kaW5nJztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzb3J0SW5mby5pbmRleCA9IG1hbmFnZWRDaGlsZC5pbmRleDtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRTb3J0Q29sdW1uKHNvcnRJbmZvKTtcclxuXHJcbiAgICAgICAgICAgICAgICBib2R5U29ydC5jdXJyZW50ISgpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVzZVRhYmxlQ2VsbFByb3BzOiB0eXBlb2YgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMgPSAocHJvcHMpID0+IHByb3BzO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdGFibGVIZWFkZXJDZWxsOiB7IHNvcnQgfSxcclxuICAgICAgICAgICAgICAgIHVzZVRhYmxlQ2VsbFByb3BzLFxyXG4gICAgICAgICAgICAgICAgLi4uZ3JpZE5hdlJldDNcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LCBbXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZVRhYmxlUm93UHJvcHM6IHR5cGVvZiB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzID0gKHByb3BzKSA9PiBwcm9wcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlVGFibGVDZWxsLFxyXG4gICAgICAgICAgICB1c2VUYWJsZVJvd1Byb3BzLFxyXG4gICAgICAgICAgICAuLi5ncmlkTmF2UmV0MlxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCB1c2VUYWJsZUJvZHkgPSB1c2VDYWxsYmFjazxVc2VBcmlhVGFibGVCb2R5PEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+PigoKSA9PiB7XHJcbiAgICAgICAgdHlwZSBDID0gVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPFJvd0VsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxVc2VBcmlhVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50Pj4+O1xyXG4gICAgICAgIHR5cGUgViA9IHtsb2NhdGlvbjogXCJoZWFkXCIgfCBcImJvZHlcIiB8IFwiZm9vdFwiLCB2YWx1ZTogVGFibGVWYWx1ZVR5cGV9O1xyXG4gICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlQ2FsbGJhY2s8R2V0SW5kZXg8QywgbmV2ZXI+PigoaSkgPT4gaS5pbmRleCwgW10pO1xyXG4gICAgICAgIGNvbnN0IGdldFZhbHVlID0gdXNlQ2FsbGJhY2s8R2V0VmFsdWU8QywgbmV2ZXIsIFtdLCBWPj4oKGkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VsbHMgPSBpLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmdldENlbGxzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjZWxscy5nZXRBdChnZXRDdXJyZW50U29ydENvbHVtbigpPy5pbmRleCA/PyAwKTtcclxuICAgICAgICAgICAgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogY2VsbD8uc3ViSW5mby5zdWJJbmZvLnN1YkluZm8ubG9jYXRpb24gPz8gXCJoZWFkXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2VsbD8uc3ViSW5mby5zdWJJbmZvLnN1YkluZm8udmFsdWUgPz8gLTFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuIGNlbGxzLmdldEF0KGdldEN1cnJlbnRTb3J0Q29sdW1uKCk/LmluZGV4ID8/IDApPy5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby52YWx1ZSA/PyBudWxsO1xyXG4gICAgICAgIH0sIFtdKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29tcGFyZTogQ29tcGFyZTxWPiA9IChsaHMsIHJocykgPT4ge1xyXG4gICAgICAgICAgICBpZiAobGhzLmxvY2F0aW9uID09PSByaHMubG9jYXRpb24pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKyhsaHMudmFsdWUgPz8gLUluZmluaXR5KSAtICsocmhzLnZhbHVlID8/IC1JbmZpbml0eSk7XHJcbiAgICAgICAgICAgIGlmIChsaHMubG9jYXRpb24gPT0gJ2hlYWQnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICBpZiAobGhzLmxvY2F0aW9uID09ICdib2R5JylcclxuICAgICAgICAgICAgICAgIHJldHVybiByaHMubG9jYXRpb24gPT0gJ2hlYWQnPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxyXG4gICAgICAgICAgICAuLi5zb3J0YWJsZVJldFxyXG4gICAgICAgIH0gPSB1c2VTb3J0YWJsZUNoaWxkcmVuPEJvZHlTZWN0aW9uRWxlbWVudCwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPFJvd0VsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxVc2VBcmlhVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50Pj4+LCBuZXZlciwgW10sIFY+KHtcclxuICAgICAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7XHJcbiAgICAgICAgICAgICAgICBnZXRJbmRleFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzb3J0YWJsZUNoaWxkcmVuOiB7XHJcbiAgICAgICAgICAgICAgICBjb21wYXJlLFxyXG4gICAgICAgICAgICAgICAgZ2V0VmFsdWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCB7IHNvcnRhYmxlQ2hpbGRyZW46IHsgc29ydCB9IH0gPSBzb3J0YWJsZVJldDtcclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBib2R5U29ydC5jdXJyZW50ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc29ydChyb3dzLCBnZXRDdXJyZW50U29ydENvbHVtbigpPy5kaXJlY3Rpb24gPz8gJ2FzY2VuZGluZycpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sIFtzb3J0XSlcclxuXHJcbiAgICAgICAgY29uc3QgdXNlVGFibGVCb2R5UHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4pID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQocHJvcHMuY2hpbGRyZW4gIT0gbnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VTb3J0YWJsZVByb3BzKHByb3BzIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4gJiB7IGNoaWxkcmVuOiBhbnkgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VUYWJsZUJvZHlQcm9wcyxcclxuICAgICAgICAgICAgLi4uc29ydGFibGVSZXRcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgdXNlVGFibGVQcm9wczogdHlwZW9mIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHMgPSB1c2VHcmlkTmF2aWdhdGlvblByb3BzO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlVGFibGVQcm9wcyxcclxuICAgICAgICB1c2VUYWJsZUJvZHksXHJcbiAgICAgICAgdXNlVGFibGVSb3csXHJcbiAgICAgICAgLi4uZ3JpZE5hdlJldDFcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBVc2VBcmlhQnV0dG9uUGFyYW1ldGVycyB9IGZyb20gXCJ1c2UtYnV0dG9uXCI7XHJcbmltcG9ydCB7IHVzZUFyaWFBY2NvcmRpb24sIFVzZUFyaWFBY2NvcmRpb25QYXJhbWV0ZXJzLCBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZUluZm8sIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uLCBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnMsIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLWFjY29yZGlvblwiO1xyXG5pbXBvcnQgeyBIZWFkaW5nIH0gZnJvbSBcIi4vaGVhZGluZ1wiO1xyXG5cclxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXJpYUFjY29yZGlvblByb3BzIGV4dGVuZHNcclxuICAgIEdldDxVc2VBcmlhQWNjb3JkaW9uUGFyYW1ldGVycywgXCJhY2NvcmRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMsIFwibGluZWFyTmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VBcmlhQWNjb3JkaW9uUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4ge1xyXG4gICAgZXhwYW5kZWRJbmRleD86IG51bWJlciB8IHVuZGVmaW5lZCB8IG51bGw7XHJcbiAgICBjaGlsZHJlbj86IENvbXBvbmVudENoaWxkcmVuO1xyXG4gICAgcmVuZGVyPyhpbmZvOiBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZUluZm8sIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbik6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXJpYUFjY29yZGlvblNlY3Rpb25Qcm9wczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlQXJpYUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+LCBcImFjY29yZGlvblNlY3Rpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZHJlblwiPixcclxuICAgIE9taXQ8VXNlQXJpYUJ1dHRvblBhcmFtZXRlcnM8SGVhZGVyRWxlbWVudD4sIFwicHJlc3NlZFwiIHwgXCJvblByZXNzXCI+IHtcclxuICAgIC8vdGFnSGVhZGVyOiBFbGVtZW50VG9UYWc8SGVhZGVyRWxlbWVudD47XHJcbiAgICAvL3RhZ0JvZHk6IEVsZW1lbnRUb1RhZzxCb2R5RWxlbWVudD47XHJcbiAgICAvL3Byb3BzSGVhZGVyKCk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+O1xyXG4gICAgLy9wcm9wc0JvZHkoKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+O1xyXG4gICAgcmVuZGVyPyhpbmZvOiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvLCBoZWFkZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4sIGJvZHlQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuLypleHBvcnQgaW50ZXJmYWNlIEFyaWFBY2NvcmRpb25TZWN0aW9uUHJvcHNEZXJpdmVkRnJvbSB7XHJcbiAgICBleHBhbmRlZDogYm9vbGVhbjtcclxuICAgIGFjY29yZGlvblNlY3Rpb25zOiBNYW5hZ2VkQ2hpbGRyZW48VXNlQXJpYUFjY29yZGlvblNlY3Rpb25JbmZvQmFzZT47XHJcbn0qL1xyXG5cclxuY29uc3QgQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPGFueSwgYW55Pj4obnVsbCEpO1xyXG5mdW5jdGlvbiBBcmlhQWNjb3JkaW9uVSh7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgZXhwYW5kZWRJbmRleCwgaW5pdGlhbEluZGV4LCBuYXZpZ2F0aW9uRGlyZWN0aW9uLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgcmVuZGVyLCBjaGlsZHJlbiB9OiBBcmlhQWNjb3JkaW9uUHJvcHMpIHtcclxuICAgIGNvbnN0IHsgdXNlQXJpYUFjY29yZGlvblNlY3Rpb24sIC4uLnByb3ZpZGVyIH0gPSB1c2VBcmlhQWNjb3JkaW9uKHtcclxuICAgICAgICBhY2NvcmRpb246IHsgaW5pdGlhbEluZGV4IH0sXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHsgcHJvdmlkZXIuYWNjb3JkaW9uLmNoYW5nZUV4cGFuZGVkSW5kZXgoZXhwYW5kZWRJbmRleCEgPz8gbnVsbCk7IH0sIFtleHBhbmRlZEluZGV4XSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8QWNjb3JkaW9uU2VjdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUFyaWFBY2NvcmRpb25TZWN0aW9ufT57KHJlbmRlciA/PyBkZWZhdWx0UmVuZGVyQWNjb3JkaW9uKShwcm92aWRlciwgY2hpbGRyZW4pfTwvQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQuUHJvdmlkZXI+XHJcbiAgICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJBY2NvcmRpb24oaW5mbzogVXNlQXJpYUFjY29yZGlvblJldHVyblR5cGVJbmZvLCBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4pOiBWTm9kZTxhbnk+IHtcclxuICAgIHJldHVybiAoPD57Y2hpbGRyZW59PC8+KVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyU2VjdGlvbihpbmZvOiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvLCBoZWFkaW5nUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIGJvZHlQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pik6IFZOb2RlPGFueT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPXs8ZGl2IHsuLi5oZWFkaW5nUHJvcHN9IC8+fT5cclxuICAgICAgICAgICAgICAgIDxkaXYgey4uLmJvZHlQcm9wc30gLz5cclxuICAgICAgICAgICAgPC9IZWFkaW5nPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBBcmlhQWNjb3JkaW9uU2VjdGlvblU8SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBvcGVuLCBpbmRleCwgdGFnLCBkaXNhYmxlZCwgcmVuZGVyIH06IEFyaWFBY2NvcmRpb25TZWN0aW9uUHJvcHM8SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbiA9IHVzZUNvbnRleHQoQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQpO1xyXG4gICAgY29uc3QgeyB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcywgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcywgLi4uc2VjdGlvbkluZm8gfSA9IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uKHsgYnV0dG9uOiB7IHRhZywgZGlzYWJsZWQgfSwgYWNjb3JkaW9uU2VjdGlvbjogeyBvcGVuIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBpbmRleCB9IH0pO1xyXG5cclxuICAgIHJldHVybiAocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJTZWN0aW9uKShzZWN0aW9uSW5mbywgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcyh7fSksIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzKHt9KSk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBBcmlhQWNjb3JkaW9uID0gZm9yd2FyZFJlZihBcmlhQWNjb3JkaW9uVSkgYXMgdHlwZW9mIEFyaWFBY2NvcmRpb25VO1xyXG5leHBvcnQgY29uc3QgQXJpYUFjY29yZGlvblNlY3Rpb24gPSBmb3J3YXJkUmVmKEFyaWFBY2NvcmRpb25TZWN0aW9uVSkgYXMgdHlwZW9mIEFyaWFBY2NvcmRpb25TZWN0aW9uVTtcclxuXHJcbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0LCBoLCBSZW5kZXJhYmxlUHJvcHMsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VDaGVja2JveEdyb3VwLCBVc2VDaGVja2JveEdyb3VwQ2hpbGQsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvLCBVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVycywgVXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtY2hlY2tib3gtZ3JvdXBcIjtcclxuaW1wb3J0IHsgZGVmYXVsdFJlbmRlckNvbWJpbmVkLCBkZWZhdWx0UmVuZGVyU2VwYXJhdGUgfSBmcm9tIFwiLi9jaGVja2JveFwiO1xyXG5cclxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcclxudHlwZSBHZXQyPFQsIEsgZXh0ZW5kcyBrZXlvZiBULCBLMiBleHRlbmRzIGtleW9mIFRbS10+ID0gVFtLXVtLMl07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94R3JvdXBQcm9wczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBSZW5kZXJhYmxlUHJvcHM8e30+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkcmVuXCI+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImNoZWNrYm94XCI+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJjaGVja2JveExpa2VcIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImxhYmVsXCI+IHtcclxuICAgIC8qcGFyZW50RGlzYWJsZWQ/OiBib29sZWFuO1xyXG4gICAgdGFnSW5wdXQ6IEVsZW1lbnRUb1RhZzxJbnB1dFR5cGU+O1xyXG4gICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbFR5cGU+O1xyXG4gICAgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiIHwgXCJ3cmFwcGluZ1wiOyovXHJcbiAgICAvL3Byb3BzSW5wdXQoKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjtcclxuICAgIC8vcHJvcHNMYWJlbCgpOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xyXG4gICAgcmVuZGVyPyhpbmZvOiBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBpbnB1dDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgbGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbik6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tib3hHcm91cENoZWNrYm94UHJvcHM8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xyXG4gICAgR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgXCJhc0NoZWNrYm94XCIsIFwiY2hlY2tib3hcIj4sXHJcbiAgICBHZXQyPFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBcImFzQ2hlY2tib3hcIiwgXCJsYWJlbFwiPixcclxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveFwiLCBcImNoZWNrYm94TGlrZVwiPixcclxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveEdyb3VwQ2hpbGRcIiwgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveEdyb3VwQ2hpbGRcIiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveEdyb3VwQ2hpbGRcIiwgXCJtYW5hZ2VkQ2hpbGRcIj4ge1xyXG4gICAgLy9sYWJlbFBvc2l0aW9uOiBcInNlcGFyYXRlXCIgfCBcIndyYXBwaW5nXCI7XHJcbiAgICBwcm9wc0lucHV0KCk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT47XHJcbiAgICBwcm9wc0xhYmVsKCk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT47XHJcbiAgICByZW5kZXI/KGluZm86IFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgaW5wdXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIGxhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNoaWxkU2VwYXJhdGUoaW5wdXRUYWc6IHN0cmluZywgaW5wdXRMYWJlbDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvPGFueSwgYW55PiwgaW5wdXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIGxhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KTogVk5vZGU8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJTZXBhcmF0ZShpbnB1dFRhZywgaW5wdXRMYWJlbCkoaW5mbywgaW5wdXQsIGxhYmVsKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNoaWxkQ29tYmluZWQoaW5wdXRUYWc6IHN0cmluZywgaW5wdXRMYWJlbDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvPGFueSwgYW55PiwgaW5wdXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIGxhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KTogVk5vZGU8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJDb21iaW5lZChpbnB1dFRhZywgaW5wdXRMYWJlbCkoaW5mbywgaW5wdXQsIGxhYmVsKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckdyb3VwU2VwYXJhdGUoaW5wdXRUYWc6IHN0cmluZywgaW5wdXRMYWJlbDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxhbnksIGFueT4sIGlucHV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBsYWJlbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuKTogVk5vZGU8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIHtkZWZhdWx0UmVuZGVyU2VwYXJhdGUoaW5wdXRUYWcsIGlucHV0TGFiZWwpKGluZm8sIGlucHV0LCBsYWJlbCl9XHJcbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgIDwvPlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckdyb3VwQ29tYmluZWQoaW5wdXRUYWc6IHN0cmluZywgaW5wdXRMYWJlbDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxhbnksIGFueT4sIGlucHV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBsYWJlbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuKTogVk5vZGU8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIHtkZWZhdWx0UmVuZGVyQ29tYmluZWQoaW5wdXRUYWcsIGlucHV0TGFiZWwpKGluZm8sIGlucHV0LCBsYWJlbCl9XHJcbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgIDwvPlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgVXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQ2hlY2tib3hHcm91cENoaWxkPGFueSwgYW55Pj4obnVsbCEpO1xyXG5leHBvcnQgZnVuY3Rpb24gQ2hlY2tib3hHcm91cDxJbnB1dFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcclxuICAgIGNoaWxkcmVuLFxyXG4gICAgZGlzYWJsZWQ6IHBhcmVudERpc2FibGVkLFxyXG4gICAgdGFnSW5wdXQsXHJcbiAgICB0YWdMYWJlbCxcclxuICAgIHJlbmRlcixcclxuICAgIGxhYmVsUG9zaXRpb24sXHJcbiAgICBpbml0aWFsSW5kZXgsXHJcbiAgICBjb2xsYXRvcixcclxuICAgIGRpc2FibGVBcnJvd0tleXMsXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxyXG4gICAgbm9UeXBlYWhlYWQsXHJcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxyXG4gICAgaW5kZXhEZW1hbmdsZXIsXHJcbiAgICBpbmRleE1hbmdsZXIsXHJcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXHJcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxyXG4gICAgb25UYWJiZWRJblRvLFxyXG4gICAgb25UYWJiZWRPdXRPZlxyXG59OiBDaGVja2JveEdyb3VwUHJvcHM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlQ2hlY2tib3hHcm91cENoaWxkLFxyXG4gICAgICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dCxcclxuICAgICAgICAuLi5jaGVja2JveEdyb3VwUGFyZW50SW5mb1xyXG4gICAgfSA9IHVzZUNoZWNrYm94R3JvdXA8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciwgb25UYWJiZWRJblRvLCBvblRhYmJlZE91dE9mIH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0UHJvcHMsIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRMYWJlbFByb3BzIH0gPSB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXQoeyBjaGVja2JveDoge30sIGNoZWNrYm94TGlrZTogeyBkaXNhYmxlZDogcGFyZW50RGlzYWJsZWQsIGxhYmVsUG9zaXRpb24gfSwgbGFiZWw6IHsgdGFnSW5wdXQsIHRhZ0xhYmVsIH0gfSk7XHJcblxyXG4gICAgY29uc3QgaW5wdXRQcm9wcyA9IHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzKHt9KTtcclxuICAgIGNvbnN0IGxhYmVsUHJvcHMgPSB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyh7fSk7XHJcbiAgICBsZXQgY29tYmluZWQ6IFZOb2RlPGFueT47XHJcbiAgICBpZiAobGFiZWxQb3NpdGlvbiA9PSBcInNlcGFyYXRlXCIpIHtcclxuICAgICAgICBjb21iaW5lZCA9IChyZW5kZXIgPz8gZGVmYXVsdFJlbmRlckdyb3VwU2VwYXJhdGUodGFnSW5wdXQsIHRhZ0xhYmVsKSkoY2hlY2tib3hHcm91cFBhcmVudEluZm8sIGlucHV0UHJvcHMsIGxhYmVsUHJvcHMsIGNoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbWJpbmVkID0gKHJlbmRlciA/PyBkZWZhdWx0UmVuZGVyR3JvdXBDb21iaW5lZCh0YWdJbnB1dCwgdGFnTGFiZWwpKShjaGVja2JveEdyb3VwUGFyZW50SW5mbywgaW5wdXRQcm9wcywgbGFiZWxQcm9wcywgY2hpbGRyZW4pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUNoZWNrYm94R3JvdXBDaGlsZH0+e2NvbWJpbmVkfTwvVXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENoZWNrYm94R3JvdXBDaGVja2JveDxJbnB1dFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcclxuICAgIGNoZWNrZWQsXHJcbiAgICBkaXNhYmxlZCxcclxuICAgIGluZGV4LFxyXG4gICAgbGFiZWxQb3NpdGlvbixcclxuICAgIHRhZ0lucHV0LFxyXG4gICAgdGFnTGFiZWwsXHJcbiAgICB0ZXh0LFxyXG4gICAgYmx1clNlbGYsXHJcbiAgICBmbGFncyxcclxuICAgIGZvY3VzU2VsZixcclxuICAgIGhpZGRlbixcclxuICAgIG9uSW5wdXQsXHJcbiAgICByZW5kZXJcclxufTogQ2hlY2tib3hHcm91cENoZWNrYm94UHJvcHM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KSB7XHJcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHMsIHVzZUNoZWNrYm94R3JvdXBDaGlsZExhYmVsUHJvcHMsIC4uLmNoZWNrYm94R3JvdXBDaGlsZEluZm8gfSA9IHVzZUNvbnRleHQoVXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dCkoe1xyXG4gICAgICAgIGFzQ2hlY2tib3g6IHtcclxuICAgICAgICAgICAgY2hlY2tib3g6IHsgb25JbnB1dCB9LFxyXG4gICAgICAgICAgICBjaGVja2JveExpa2U6IHsgY2hlY2tlZCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24gfSxcclxuICAgICAgICAgICAgbGFiZWw6IHsgdGFnSW5wdXQsIHRhZ0xhYmVsIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFzQ2hlY2tib3hHcm91cENoaWxkOiB7XHJcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDoge1xyXG4gICAgICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBmbGFnc1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgICAgICAgICAgYmx1clNlbGYsXHJcbiAgICAgICAgICAgICAgICBmb2N1c1NlbGYsXHJcbiAgICAgICAgICAgICAgICBoaWRkZW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGlucHV0UHJvcHMgPSB1c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzKHt9KTtcclxuICAgIGNvbnN0IGxhYmVsUHJvcHMgPSB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzKHt9KTtcclxuICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIikge1xyXG4gICAgICAgIHJldHVybiAocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJDaGlsZFNlcGFyYXRlKHRhZ0lucHV0LCB0YWdMYWJlbCkpKGNoZWNrYm94R3JvdXBDaGlsZEluZm8sIGlucHV0UHJvcHMsIGxhYmVsUHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIChyZW5kZXIgPz8gZGVmYXVsdFJlbmRlckNoaWxkQ29tYmluZWQodGFnSW5wdXQsIHRhZ0xhYmVsKSkoY2hlY2tib3hHcm91cENoaWxkSW5mbywgaW5wdXRQcm9wcywgbGFiZWxQcm9wcyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VBcmlhTGlzdGJveE11bHRpLCBVc2VMaXN0Ym94TXVsdGlJdGVtLCBVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVycywgVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVJbmZvLCBVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzLCBVc2VMaXN0Ym94TXVsdGlSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtbGlzdGJveC1tdWx0aVwiO1xyXG5cclxuXHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94TXVsdGlQcm9wczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveE11bHRpUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZHJlblwiPixcclxuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImxpc3Rib3hNdWx0aVwiPiB7XHJcbiAgICAvL3RhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PjtcclxuICAgIHJlbmRlcj8oaW5mbzogVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiwgbGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4sIGxpc3Q6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50Pik6IFZOb2RlPGFueT47XHJcbiAgICBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW47XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94TXVsdGlJdGVtUHJvcHM8TGlzdGJveEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xyXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aUl0ZW1QYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZFwiPixcclxuICAgIE9taXQ8R2V0PFVzZUxpc3Rib3hNdWx0aUl0ZW1QYXJhbWV0ZXJzLCBcImxpc3ROYXZpZ2F0aW9uXCI+LCBcInN1YkluZm9cIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveE11bHRpSXRlbVBhcmFtZXRlcnMsIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveE11bHRpSXRlbVBhcmFtZXRlcnMsIFwibGlzdGJveE11bHRpSXRlbVwiPiB7XHJcbiAgICByZW5kZXI/KGluZm86IFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlSW5mbzxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBsaXN0SXRlbVByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0Ym94SXRlbUVsZW1lbnQ+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuY29uc3QgTGlzdGJveE11bHRpQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTGlzdGJveE11bHRpSXRlbTxhbnk+PihudWxsISk7XHJcblxyXG5mdW5jdGlvbiBMaXN0Ym94TXVsdGlVPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7XHJcbiAgICByZW5kZXIsXHJcbiAgICB0YWdMYWJlbCxcclxuICAgIGNvbGxhdG9yLFxyXG4gICAgZGlzYWJsZUFycm93S2V5cyxcclxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcclxuICAgIGluZGV4RGVtYW5nbGVyLFxyXG4gICAgaW5kZXhNYW5nbGVyLFxyXG4gICAgaW5pdGlhbEluZGV4LFxyXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcclxuICAgIG5vVHlwZWFoZWFkLFxyXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxyXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZVJlbmRlcixcclxuICAgIG9uVGFiYmVkSW5UbyxcclxuICAgIG9uVGFiYmVkT3V0T2YsXHJcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxyXG4gICAgdGFnTGlzdCxcclxuICAgIGNoaWxkcmVuOiB2bm9kZUNoaWxkcmVuXHJcbn06IExpc3Rib3hNdWx0aVByb3BzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4sIHJlZjogUmVmPExpc3RFbGVtZW50Pikge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW0sXHJcbiAgICAgICAgdXNlTGlzdGJveE11bHRpTGFiZWwsXHJcbiAgICAgICAgdXNlTGlzdGJveE11bHRpUHJvcHMsXHJcbiAgICAgICAgLi4ubGlzdGJveFJldHVyblR5cGVcclxuICAgIH0gPSB1c2VBcmlhTGlzdGJveE11bHRpPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXHJcbiAgICAgICAgbGlzdGJveE11bHRpOiB7IHRhZ0xhYmVsLCB0YWdMaXN0IH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyLCBvblRhYmJlZEluVG8sIG9uVGFiYmVkT3V0T2YgfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHMgfSA9IHVzZUxpc3Rib3hNdWx0aUxhYmVsKCk7XHJcblxyXG4gICAgY29uc3QgcDEgPSAgdXNlTGlzdGJveE11bHRpTGFiZWxQcm9wcyh7fSk7XHJcbiAgICBjb25zdCBwMiA9IHVzZUxpc3Rib3hNdWx0aVByb3BzKHsgY2hpbGRyZW46IHZub2RlQ2hpbGRyZW4sIHJlZiB9KTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPExpc3Rib3hNdWx0aUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUxpc3Rib3hNdWx0aUl0ZW19PlxyXG4gICAgICAgICAgICB7KHJlbmRlciA/PyBkZWZhdWx0TGlzdFJlbmRlcikobGlzdGJveFJldHVyblR5cGUsIHAxLCBwMil9XHJcbiAgICAgICAgPC9MaXN0Ym94TXVsdGlDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0TGlzdFJlbmRlcihpbmZvOiBVc2VMaXN0Ym94TXVsdGlSZXR1cm5UeXBlSW5mbzxhbnk+LCBsYWJlbFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBsaXN0UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pOiBWTm9kZTxhbnk+IHtcclxuICAgIGNvbnN0IGxhYmVsID0gPGRpdiB7Li4ubGFiZWxQcm9wc30gLz47XHJcbiAgICBjb25zdCBsaXN0ID0gPHVsIHsuLi5saXN0UHJvcHN9IC8+O1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PntsYWJlbH17bGlzdH08Lz5cclxuICAgIClcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdExpc3RJdGVtUmVuZGVyKGluZm86IFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlSW5mbzxhbnk+LCBsaXN0SXRlbVByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KTogVk5vZGU8YW55PiB7XHJcbiAgICBjb25zdCBsaXN0SXRlbSA9IDxsaSB7Li4ubGlzdEl0ZW1Qcm9wc30gLz47XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+e2xpc3RJdGVtfTwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBMaXN0Ym94TXVsdGlJdGVtVTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGluZGV4LCBibHVyU2VsZiwgZGlzYWJsZWQsIGZsYWdzLCBmb2N1c1NlbGYsIHJlbmRlciwgdGV4dCwgaGlkZGVuLCBzZWxlY3RlZCwgb25TZWxlY3QgfTogTGlzdGJveE11bHRpSXRlbVByb3BzPExpc3RJdGVtRWxlbWVudD4sIHJlZjogUmVmPExpc3RJdGVtRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHsgdXNlTGlzdGJveE11bHRpSXRlbVByb3BzLCAuLi5pdGVtUmV0dXJuIH0gPSB1c2VDb250ZXh0KExpc3Rib3hNdWx0aUNvbnRleHQpKHsgXHJcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCBcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW4gfSwgXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LCBcclxuICAgICAgICBsaXN0Ym94TXVsdGlJdGVtOiB7IGRpc2FibGVkLCBzZWxlY3RlZCwgb25TZWxlY3R9XHJcbiAgICB9KTtcclxuICAgIC8vY29uc3QgbGlzdEl0ZW0gPSBjcmVhdGVFbGVtZW50KHRhZ0xpc3RJdGVtLCB1c2VMaXN0Ym94TXVsdGlJdGVtUHJvcHMoeyByZWYgfSkgYXMgYW55KTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD57KHJlbmRlciA/PyBkZWZhdWx0TGlzdEl0ZW1SZW5kZXIpKGl0ZW1SZXR1cm4sIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcyh7IHJlZiB9KSl9PC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBMaXN0Ym94TXVsdGkgPSBmb3J3YXJkUmVmKExpc3Rib3hNdWx0aVUpIGFzIHR5cGVvZiBMaXN0Ym94TXVsdGlVO1xyXG5leHBvcnQgY29uc3QgTGlzdGJveE11bHRpSXRlbSA9IGZvcndhcmRSZWYoTGlzdGJveE11bHRpSXRlbVUpIGFzIHR5cGVvZiBMaXN0Ym94TXVsdGlJdGVtVTtcclxuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFbGVtZW50VG9UYWcgfSBmcm9tIFwicHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQXJpYUxpc3Rib3hTaW5nbGUsIFVzZUxpc3Rib3hTaW5nbGVJdGVtLCBVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnMsIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm8sIFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzLCBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLWxpc3Rib3gtc2luZ2xlXCI7XHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94U2luZ2xlUHJvcHM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwic2luZ2xlU2VsZWN0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibGlzdGJveFNpbmdsZVwiPiB7XHJcbiAgICB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD47XHJcbiAgICByZW5kZXI/KGluZm86IFVzZUxpc3Rib3hTaW5nbGVSZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+LCBsYWJlbDogVk5vZGU8YW55PiwgbGlzdDogVk5vZGU8YW55Pik6IFZOb2RlPGFueT47XHJcbiAgICBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW47XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94U2luZ2xlSXRlbVByb3BzPExpc3Rib3hJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkXCI+LFxyXG4gICAgT21pdDxHZXQ8VXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzLCBcImxpc3ROYXZpZ2F0aW9uXCI+LCBcInN1YkluZm9cIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVycywgXCJsaXN0Ym94U2luZ2xlSXRlbVwiPiB7XHJcbiAgICB0YWdMaXN0SXRlbTogRWxlbWVudFRvVGFnPExpc3Rib3hJdGVtRWxlbWVudD47XHJcbiAgICByZW5kZXI/KGluZm86IFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm88TGlzdGJveEl0ZW1FbGVtZW50PiwgbGlzdEl0ZW06IFZOb2RlPGFueT4pOiBWTm9kZTxhbnk+O1xyXG59XHJcblxyXG5jb25zdCBMaXN0Ym94U2luZ2xlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTGlzdGJveFNpbmdsZUl0ZW08YW55Pj4obnVsbCEpO1xyXG5cclxuZnVuY3Rpb24gTGlzdGJveFNpbmdsZVU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcclxuICAgIHJlbmRlcixcclxuXHJcbiAgICBzZWxlY3RlZEluZGV4LFxyXG4gICAgdGFnTGFiZWwsXHJcbiAgICBjb2xsYXRvcixcclxuICAgIGRpc2FibGVBcnJvd0tleXMsXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICBpbmRleERlbWFuZ2xlcixcclxuICAgIGluZGV4TWFuZ2xlcixcclxuICAgIGluaXRpYWxJbmRleCxcclxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXHJcbiAgICBub1R5cGVhaGVhZCxcclxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcclxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVSZW5kZXIsXHJcbiAgICBvblRhYmJlZEluVG8sXHJcbiAgICBvblRhYmJlZE91dE9mLFxyXG4gICAgdHlwZWFoZWFkVGltZW91dCxcclxuICAgIHNlbGVjdGlvbk1vZGUsXHJcbiAgICB0YWdMaXN0LFxyXG4gICAgb25TZWxlY3QsXHJcbiAgICBjaGlsZHJlbjogdm5vZGVDaGlsZHJlblxyXG59OiBMaXN0Ym94U2luZ2xlUHJvcHM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50PiwgcmVmOiBSZWY8TGlzdEVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZUl0ZW0sXHJcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZUxhYmVsLFxyXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVQcm9wcyxcclxuICAgICAgICAuLi5saXN0Ym94UmV0dXJuVHlwZVxyXG4gICAgfSA9IHVzZUFyaWFMaXN0Ym94U2luZ2xlPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXHJcbiAgICAgICAgbGlzdGJveFNpbmdsZTogeyBzZWxlY3Rpb25Nb2RlLCB0YWdMYWJlbCwgdGFnTGlzdCwgb25TZWxlY3QgfSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIsIG9uVGFiYmVkSW5Ubywgb25UYWJiZWRPdXRPZiB9LFxyXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4IH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcyB9ID0gdXNlTGlzdGJveFNpbmdsZUxhYmVsKCk7XHJcbiAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwsIHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzKHt9KSBhcyBhbnkpO1xyXG4gICAgY29uc3QgbGlzdCA9IGNyZWF0ZUVsZW1lbnQodGFnTGlzdCwgdXNlTGlzdGJveFNpbmdsZVByb3BzKHsgY2hpbGRyZW46IHZub2RlQ2hpbGRyZW4sIHJlZiB9KSBhcyBhbnkpO1xyXG5cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxMaXN0Ym94U2luZ2xlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlTGlzdGJveFNpbmdsZUl0ZW19PlxyXG4gICAgICAgICAgICB7KHJlbmRlciA/PyBkZWZhdWx0TGlzdFJlbmRlcikoeyAuLi5saXN0Ym94UmV0dXJuVHlwZSB9LCBsYWJlbCwgbGlzdCl9XHJcbiAgICAgICAgPC9MaXN0Ym94U2luZ2xlQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIClcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdExpc3RSZW5kZXIoLi4uW19pbmZvLCBsYWJlbCwgbGlzdF06IFBhcmFtZXRlcnM8Tm9uTnVsbGFibGU8TGlzdGJveFNpbmdsZVByb3BzPGFueSwgYW55LCBhbnk+W1wicmVuZGVyXCJdPj4pOiBWTm9kZTxhbnk+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD57bGFiZWx9e2xpc3R9PC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRMaXN0SXRlbVJlbmRlciguLi5bX2luZm8sIGxpc3RJdGVtXTogUGFyYW1ldGVyczxOb25OdWxsYWJsZTxMaXN0Ym94U2luZ2xlSXRlbVByb3BzPGFueT5bXCJyZW5kZXJcIl0+Pik6IFZOb2RlPGFueT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PntsaXN0SXRlbX08Lz5cclxuICAgIClcclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBMaXN0Ym94U2luZ2xlSXRlbVU8TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBpbmRleCwgdGFnTGlzdEl0ZW0sIGJsdXJTZWxmLCBkaXNhYmxlZCwgZmxhZ3MsIGZvY3VzU2VsZiwgcmVuZGVyLCB0ZXh0LCBoaWRkZW4gfTogTGlzdGJveFNpbmdsZUl0ZW1Qcm9wczxMaXN0SXRlbUVsZW1lbnQ+LCByZWY6IFJlZjxMaXN0SXRlbUVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZUxpc3Rib3hTaW5nbGVJdGVtUHJvcHMsIHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24gfSA9IHVzZUNvbnRleHQoTGlzdGJveFNpbmdsZUNvbnRleHQpKHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuIH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxyXG4gICAgICAgIGxpc3Rib3hTaW5nbGVJdGVtOiB7IGRpc2FibGVkIH1cclxuICAgIH0pO1xyXG4gICAgY29uc3QgbGlzdEl0ZW0gPSBjcmVhdGVFbGVtZW50KHRhZ0xpc3RJdGVtLCB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzKHsgcmVmIH0pIGFzIGFueSk7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+eyhyZW5kZXIgPz8gZGVmYXVsdExpc3RJdGVtUmVuZGVyKSh7IHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24gfSwgbGlzdEl0ZW0pfTwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgTGlzdGJveFNpbmdsZSA9IGZvcndhcmRSZWYoTGlzdGJveFNpbmdsZVUpIGFzIHR5cGVvZiBMaXN0Ym94U2luZ2xlVTtcclxuZXhwb3J0IGNvbnN0IExpc3Rib3hTaW5nbGVJdGVtID0gZm9yd2FyZFJlZihMaXN0Ym94U2luZ2xlSXRlbVUpIGFzIHR5cGVvZiBMaXN0Ym94U2luZ2xlSXRlbVU7XHJcbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VBcmlhTWVudSwgVXNlQXJpYU1lbnVJdGVtUGFyYW1ldGVycywgVXNlQXJpYU1lbnVJdGVtUmV0dXJuVHlwZUluZm8sIFVzZUFyaWFNZW51UGFyYW1ldGVycywgVXNlQXJpYU1lbnVSZXR1cm5UeXBlSW5mbywgVXNlTWVudUl0ZW0gfSBmcm9tIFwiLi4vdXNlLW1lbnVcIjtcclxuXHJcbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE1lbnVQcm9wczxNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyAvL09taXQ8VXNlQXJpYU1lbnVQYXJhbWV0ZXJzPEUsIEssIEk+LCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiIHwgXCJvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3RcIiB8IFwib25DaGlsZHJlbk1vdW50Q2hhbmdlXCIgfCBcIm9uVGFiYmFibGVJbmRleENoYW5nZVwiIHwgXCJvblRhYmJhYmxlUmVuZGVyXCIgfCBcIm9uVGFiYmVkSW5Ub1wiIHwgXCJvblRhYmJlZE91dE9mXCI+ICYge1xyXG4gICAgR2V0PFVzZUFyaWFNZW51UGFyYW1ldGVyczxuZXZlcj4sIFwibWVudVwiPixcclxuICAgIEdldDxVc2VBcmlhTWVudVBhcmFtZXRlcnM8bmV2ZXI+LCBcIm1lbnVTdXJmYWNlXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFNZW51UGFyYW1ldGVyczxuZXZlcj4sIFwic29mdERpc21pc3NcIj4sXHJcbiAgICBHZXQ8VXNlQXJpYU1lbnVQYXJhbWV0ZXJzPG5ldmVyPiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFNZW51UGFyYW1ldGVyczxuZXZlcj4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYU1lbnVQYXJhbWV0ZXJzPG5ldmVyPiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDxVc2VBcmlhTWVudVBhcmFtZXRlcnM8bmV2ZXI+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYU1lbnVQYXJhbWV0ZXJzPG5ldmVyPiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj5cclxuXHJcbntcclxuICAgIC8vcHJvcHNNZW51QnV0dG9uOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+O1xyXG4gICAgLy9wcm9wc01lbnVTZW50aW5lbDogKHdoaWNoOiBcInRvcFwiIHwgXCJib3R0b21cIikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PjtcclxuICAgIC8vcHJvcHNNZW51OiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+O1xyXG5cclxuICAgIC8vdGFnTWVudUJ1dHRvbjogYW55O1xyXG4gICAgLy90YWdNZW51OiBhbnk7XHJcbiAgICAvL3RhZ1NlbnRpbmVsOiBhbnk7XHJcblxyXG5cclxuICAgIHJlbmRlcj8obWVudUluZm86IFVzZUFyaWFNZW51UmV0dXJuVHlwZUluZm88TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+LCBtZW51QnV0dG9uUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PiwgbWVudTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVBhcmVudEVsZW1lbnQ+LCBmaXJzdFNlbnRpbmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBsYXN0U2VudGluZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pOiBWTm9kZTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZW51SXRlbVByb3BzPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgXHJcbkdldDxVc2VBcmlhTWVudUl0ZW1QYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZFwiPixcclxuR2V0PFVzZUFyaWFNZW51SXRlbVBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbkdldDxVc2VBcmlhTWVudUl0ZW1QYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+IHtcclxuICAgIHJlbmRlcj8oaW5mbzogVXNlQXJpYU1lbnVJdGVtUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50PiwgbGlzdEl0ZW06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pOiBWTm9kZTtcclxuICAgIC8vdGFnTWVudUl0ZW06IGFueTtcclxuICAgIC8vcHJvcHNNZW51SXRlbTogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PlxyXG59XHJcblxyXG5jb25zdCBNZW51SXRlbUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZU1lbnVJdGVtPGFueT4+KG51bGwhKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBNZW51PFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgaW5pdGlhbEluZGV4LFxyXG4gICAgY29sbGF0b3IsXHJcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxyXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxyXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcclxuICAgIG5vVHlwZWFoZWFkLFxyXG4gICAgdHlwZWFoZWFkVGltZW91dCxcclxuICAgIG9uT3BlbixcclxuICAgIG9uQ2xvc2UsXHJcbiAgICBvcGVuLFxyXG5cclxuICAgIG9wZW5EaXJlY3Rpb24sXHJcbiAgICBzZW5kRm9jdXNUb01lbnUsXHJcbiAgICBpbmRleERlbWFuZ2xlcixcclxuICAgIGluZGV4TWFuZ2xlcixcclxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcclxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVSZW5kZXIsXHJcbiAgICBvblRhYmJlZEluVG8sXHJcbiAgICBvblRhYmJlZE91dE9mLFxyXG5cclxuICAgIHJlbmRlclxyXG5cclxufTogTWVudVByb3BzPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQnV0dG9uRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VNZW51QnV0dG9uUHJvcHMsXHJcbiAgICAgICAgdXNlTWVudUl0ZW0sXHJcbiAgICAgICAgdXNlTWVudVByb3BzLFxyXG4gICAgICAgIHVzZU1lbnVTZW50aW5lbCxcclxuICAgICAgICAuLi5tZW51UmV0dXJuXHJcbiAgICB9ID0gdXNlQXJpYU1lbnU8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBCdXR0b25FbGVtZW50Pih7XHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXHJcbiAgICAgICAgbWVudTogeyBvbk9wZW4sIG9wZW5EaXJlY3Rpb24gfSxcclxuICAgICAgICBtZW51U3VyZmFjZTogeyBzZW5kRm9jdXNUb01lbnUsIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIsIG9uVGFiYmVkSW5Ubywgb25UYWJiZWRPdXRPZiB9LFxyXG4gICAgICAgIHNvZnREaXNtaXNzOiB7IG9uQ2xvc2UsIG9wZW4gfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbWVudUJ1dHRvblByb3BzID0gdXNlTWVudUJ1dHRvblByb3BzKHt9KTtcclxuICAgIGNvbnN0IG1lbnVQcm9wcyA9IHVzZU1lbnVQcm9wcyh7fSk7XHJcbiAgICBjb25zdCB7IHVzZU1lbnVTZW50aW5lbFByb3BzOiB1c2VGaXJzdFNlbnRpbmVsUHJvcHMgfSA9IHVzZU1lbnVTZW50aW5lbCgpO1xyXG4gICAgY29uc3QgeyB1c2VNZW51U2VudGluZWxQcm9wczogdXNlTGFzdFNlbnRpbmVsUHJvcHMgfSA9IHVzZU1lbnVTZW50aW5lbCgpO1xyXG4gICAgY29uc3QgZmlyc3RTZW50aW5lbFByb3BzID0gdXNlRmlyc3RTZW50aW5lbFByb3BzKHt9KTtcclxuICAgIGNvbnN0IGxhc3RTZW50aW5lbFByb3BzID0gdXNlTGFzdFNlbnRpbmVsUHJvcHMoe30pO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TWVudUl0ZW1Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VNZW51SXRlbX0+XHJcbiAgICAgICAgICAgIHsocmVuZGVyID8/IGRlZmF1bHRNZW51UmVuZGVyKShtZW51UmV0dXJuLCBtZW51QnV0dG9uUHJvcHMsIG1lbnVQcm9wcywgZmlyc3RTZW50aW5lbFByb3BzLCBsYXN0U2VudGluZWxQcm9wcyl9XHJcbiAgICAgICAgPC9NZW51SXRlbUNvbnRleHQuUHJvdmlkZXI+XHJcbiAgICApXHJcblxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gTWVudUl0ZW08TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIsIGluZGV4LCB0ZXh0LCBoaWRkZW4sIGJsdXJTZWxmLCBmbGFncywgZm9jdXNTZWxmIH06IE1lbnVJdGVtUHJvcHM8TWVudUl0ZW1FbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VNZW51SXRlbVByb3BzLCAuLi5yZXN0IH0gPSB1c2VDb250ZXh0KE1lbnVJdGVtQ29udGV4dCkoe1xyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIChyZW5kZXIgPz8gZGVmYXVsdE1lbnVJdGVtUmVuZGVyKShyZXN0LCB1c2VNZW51SXRlbVByb3BzKHt9KSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRNZW51UmVuZGVyKG1lbnVJbmZvOiBVc2VBcmlhTWVudVJldHVyblR5cGVJbmZvPGFueSwgYW55LCBhbnk+LCBtZW51QnV0dG9uUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIG1lbnVQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgZmlyc3RTZW50aW5lbFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBsYXN0U2VudGluZWxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xyXG4gICAgY29uc3QgZmlyc3RTZW50aW5lbCA9IDxkaXYgey4uLmZpcnN0U2VudGluZWxQcm9wc30gLz47XHJcbiAgICBjb25zdCBsYXN0U2VudGluZWwgPSA8ZGl2IHsuLi5sYXN0U2VudGluZWxQcm9wc30gLz47XHJcbiAgICBjb25zdCBtZW51ID0gPD57Zmlyc3RTZW50aW5lbH17bWVudVByb3BzLmNoaWxkcmVufXtsYXN0U2VudGluZWx9PC8+O1xyXG4gICAgY29uc3QgbWVudUJ1dHRvbiA9IDxkaXYgey4uLm1lbnVCdXR0b25Qcm9wc30gLz5cclxuICAgIC8vbWVudS5wcm9wcy5jaGlsZHJlbiA9IDw+e2ZpcnN0U2VudGluZWx9e21lbnUucHJvcHMuY2hpbGRyZW59e2xhc3RTZW50aW5lbH08Lz5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD57bWVudUJ1dHRvbn17bWVudX08Lz5cclxuICAgIClcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdE1lbnVJdGVtUmVuZGVyPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KGluZm86IFVzZUFyaWFNZW51SXRlbVJldHVyblR5cGVJbmZvPE1lbnVJdGVtRWxlbWVudD4sIG1lbnVJdGVtUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pIHtcclxuICAgIHJldHVybiAoPGRpdiB7Li4ubWVudUl0ZW1Qcm9wc30gLz4pO1xyXG59IiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZUFyaWFSYWRpb0dyb3VwLCBVc2VBcmlhUmFkaW9Hcm91cFBhcmFtZXRlcnMsIFVzZUFyaWFSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm8sIFVzZUFyaWFSYWRpb1BhcmFtZXRlcnMsIFVzZVJhZGlvLCBVc2VSYWRpb1JldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS1yYWRpby1ncm91cFwiO1xyXG5cclxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmFkaW9Hcm91cFByb3BzPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDxVc2VBcmlhUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInJhZGlvR3JvdXBcIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDxVc2VBcmlhUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xyXG4gICAgLy9wcm9wc0dyb3VwTGFiZWw6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyb3VwTGFiZWxFbGVtZW50PjtcclxuICAgIC8vcHJvcHNHcm91cDogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JvdXBFbGVtZW50PjtcclxuICAgIHJlbmRlcj8oaW5mbzogVXNlQXJpYVJhZGlvR3JvdXBSZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQ+LCBsYWJlbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JvdXBMYWJlbEVsZW1lbnQ+LCBncm91cDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JvdXBFbGVtZW50Pik6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUmFkaW9Qcm9wczxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlQXJpYVJhZGlvUGFyYW1ldGVyczxWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwicmFkaW9cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVJhZGlvUGFyYW1ldGVyczxWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVJhZGlvUGFyYW1ldGVyczxWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVJhZGlvUGFyYW1ldGVyczxWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwibWFuYWdlZENoaWxkXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInJhZGlvXCI+IHtcclxuICAgIC8vIHByb3BzTGFiZWw6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XHJcbiAgICAvL3Byb3BzSW5wdXQ6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47XHJcbiAgICByZW5kZXI/KGluZm86IFVzZVJhZGlvUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50PiwgaW5wdXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4sIGxhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdEdyb3VwUmVuZGVyKGluZm86IFVzZUFyaWFSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88YW55PiwgbGFiZWxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgZ3JvdXBQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xyXG4gICAgY29uc3QgbGFiZWwgPSA8ZGl2IHsuLi5sYWJlbFByb3BzfSAvPjtcclxuICAgIGNvbnN0IGdyb3VwID0gPGRpdiB7Li4uZ3JvdXBQcm9wc30gLz47XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIHtsYWJlbH1cclxuICAgICAgICAgICAge2dyb3VwfVxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5jb25zdCBSYWRpb0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVJhZGlvPGFueSwgYW55LCBhbnk+PihudWxsISk7XHJcbmV4cG9ydCBmdW5jdGlvbiBSYWRpb0dyb3VwPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcclxuICAgIHJlbmRlcixcclxuICAgIHRhZ0dyb3VwLFxyXG4gICAgdGFnR3JvdXBMYWJlbCxcclxuICAgIGluaXRpYWxJbmRleCxcclxuICAgIG5hbWUsXHJcbiAgICBvbklucHV0LFxyXG4gICAgc2VsZWN0ZWRWYWx1ZSxcclxuICAgIGNvbGxhdG9yLFxyXG4gICAgZGlzYWJsZUFycm93S2V5cyxcclxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcclxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXHJcbiAgICBub1R5cGVhaGVhZCxcclxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXHJcbiAgICBpbmRleERlbWFuZ2xlcixcclxuICAgIGluZGV4TWFuZ2xlcixcclxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcclxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVSZW5kZXIsXHJcbiAgICBvblRhYmJlZEluVG8sXHJcbiAgICBvblRhYmJlZE91dE9mXHJcbn06IFJhZGlvR3JvdXBQcm9wczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VSYWRpbyxcclxuICAgICAgICB1c2VSYWRpb0dyb3VwTGFiZWxQcm9wcyxcclxuICAgICAgICB1c2VSYWRpb0dyb3VwUHJvcHMsXHJcbiAgICAgICAgLi4ucmFkaW9Hcm91cFJldHVyblxyXG4gICAgfSA9IHVzZUFyaWFSYWRpb0dyb3VwPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pih7XHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXHJcbiAgICAgICAgcmFkaW9Hcm91cDogeyBuYW1lLCBvbklucHV0LCBzZWxlY3RlZFZhbHVlLCB0YWdHcm91cCwgdGFnR3JvdXBMYWJlbCB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyLCBvblRhYmJlZEluVG8sIG9uVGFiYmVkT3V0T2YgfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxSYWRpb0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVJhZGlvfT5cclxuICAgICAgICAgICAgeyhyZW5kZXIgPz8gZGVmYXVsdEdyb3VwUmVuZGVyKShyYWRpb0dyb3VwUmV0dXJuLCB1c2VSYWRpb0dyb3VwTGFiZWxQcm9wcyh7fSksIHVzZVJhZGlvR3JvdXBQcm9wcyh7fSkpfVxyXG4gICAgICAgIDwvUmFkaW9Db250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyU2VwYXJhdGUoaW5wdXRUYWc6IHN0cmluZywgaW5wdXRMYWJlbDogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVJhZGlvUmV0dXJuVHlwZUluZm88YW55PiwgaW5wdXRQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgbGFiZWxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pik6IFZOb2RlPGFueT4ge1xyXG4gICAgICAgIGNvbnN0IGlucHV0ID0gY3JlYXRlRWxlbWVudChpbnB1dFRhZywgaW5wdXRQcm9wcyk7XHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KGlucHV0TGFiZWwsIGxhYmVsUHJvcHMpO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAge2lucHV0fVxyXG4gICAgICAgICAgICAgICAge2xhYmVsfVxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDb21iaW5lZChpbnB1dFRhZzogc3RyaW5nLCBpbnB1dExhYmVsOiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlUmFkaW9SZXR1cm5UeXBlSW5mbzxhbnk+LCBpbnB1dFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCB7IGNoaWxkcmVuLCAuLi5sYWJlbFByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pOiBWTm9kZTxhbnk+IHtcclxuICAgICAgICBjb25zdCBpbnB1dCA9IGNyZWF0ZUVsZW1lbnQoaW5wdXRUYWcsIGlucHV0UHJvcHMpO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsID0gY3JlYXRlRWxlbWVudChpbnB1dExhYmVsLCB7IC4uLmxhYmVsUHJvcHMsIGNoaWxkcmVuOiA8PntpbnB1dH17Y2hpbGRyZW59PC8+IH0pO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICB7bGFiZWx9XHJcbiAgICAgICAgICAgIDwvPlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFJhZGlvPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgZGlzYWJsZWQsIGluZGV4LCB0ZXh0LCBoaWRkZW4sIHRhZ0lucHV0LCBsYWJlbFBvc2l0aW9uLCB0YWdMYWJlbCwgdmFsdWUsIHJlbmRlciwgZmxhZ3MsIGJsdXJTZWxmLCBmb2N1c1NlbGYgfTogUmFkaW9Qcm9wczxWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHsgdXNlUmFkaW9JbnB1dCwgdXNlUmFkaW9MYWJlbCwgLi4ucmFkaW9SZXR1cm4gfSA9IHVzZUNvbnRleHQoUmFkaW9Db250ZXh0KSh7XHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcclxuICAgICAgICByYWRpbzogeyBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsLCB2YWx1ZSB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGhpZGRlbiwgZm9jdXNTZWxmLCBibHVyU2VsZiB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZVJhZGlvSW5wdXRQcm9wcyB9ID0gdXNlUmFkaW9JbnB1dCh7IHRhZzogdGFnSW5wdXQgfSk7XHJcbiAgICBjb25zdCB7IHVzZVJhZGlvTGFiZWxQcm9wcyB9ID0gdXNlUmFkaW9MYWJlbCh7IHRhZzogdGFnTGFiZWwgfSk7XHJcblxyXG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIChyZW5kZXIgPz8gZGVmYXVsdFJlbmRlclNlcGFyYXRlKHRhZ0lucHV0LCB0YWdMYWJlbCkpKHJhZGlvUmV0dXJuLCB1c2VSYWRpb0lucHV0UHJvcHMoe30pLCB1c2VSYWRpb0xhYmVsUHJvcHMoe30pKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJDb21iaW5lZCh0YWdJbnB1dCwgdGFnTGFiZWwpKShyYWRpb1JldHVybiwgdXNlUmFkaW9JbnB1dFByb3BzKHt9KSwgdXNlUmFkaW9MYWJlbFByb3BzKHt9KSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VBcmlhU2xpZGVyLCBVc2VBcmlhU2xpZGVyUGFyYW1ldGVycywgVXNlQXJpYVNsaWRlclRodW1iLCBVc2VBcmlhU2xpZGVyVGh1bWJQYXJhbWV0ZXJzLCBVc2VBcmlhU2xpZGVyVGh1bWJSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2Utc2xpZGVyXCI7XHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJQcm9wcyBleHRlbmRzIEdldDxVc2VBcmlhU2xpZGVyUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sIEdldDxVc2VBcmlhU2xpZGVyUGFyYW1ldGVycywgXCJzbGlkZXJcIj4ge1xyXG4gICAgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuO1xyXG4gICAgLy9yZW5kZXI/KGluZm86IFVzZUFyaWFTbGlkZXJSZXR1cm5UeXBlSW5mbywpOiBWTm9kZTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJUaHVtYlByb3BzPFRodW1iRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgR2V0PFVzZUFyaWFTbGlkZXJUaHVtYlBhcmFtZXRlcnM8VGh1bWJFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRcIj4sIEdldDxVc2VBcmlhU2xpZGVyVGh1bWJQYXJhbWV0ZXJzPFRodW1iRWxlbWVudD4sIFwic2xpZGVyVGh1bWJcIj4ge1xyXG4gICAgcmVuZGVyPyhpbmZvOiBVc2VBcmlhU2xpZGVyVGh1bWJSZXR1cm5UeXBlSW5mbywgdGh1bWJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGh1bWJFbGVtZW50Pik6IFZOb2RlO1xyXG59XHJcblxyXG5jb25zdCBTbGlkZXJUaHVtYkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUFyaWFTbGlkZXJUaHVtYjxhbnk+PihudWxsISk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gU2xpZGVyKHsgbWF4LCBtaW4sIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlLCBjaGlsZHJlbiB9OiBTbGlkZXJQcm9wcykge1xyXG4gICAgY29uc3QgeyB1c2VBcmlhU2xpZGVyVGh1bWIsIC4uLl9zbGlkZXJJbmZvIH0gPSB1c2VBcmlhU2xpZGVyKHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcclxuICAgICAgICBzbGlkZXI6IHsgbWF4LCBtaW4gfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8U2xpZGVyVGh1bWJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VBcmlhU2xpZGVyVGh1bWJ9PntjaGlsZHJlbn08L1NsaWRlclRodW1iQ29udGV4dC5Qcm92aWRlcj5cclxuICAgICk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFNsaWRlclRodW1iVTxUaHVtYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxhYmVsLCB0YWcsIHZhbHVlLCBtYXgsIG1pbiwgb25WYWx1ZUNoYW5nZSwgaW5kZXgsIGZsYWdzLCByZW5kZXIsIHZhbHVlVGV4dCB9OiBTbGlkZXJUaHVtYlByb3BzPFRodW1iRWxlbWVudD4sIHJlZjogUmVmPFRodW1iRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHsgdXNlQXJpYVNsaWRlclRodW1iUHJvcHMsIC4uLnNsaWRlckluZm8gfSA9IHVzZUNvbnRleHQoU2xpZGVyVGh1bWJDb250ZXh0KSh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgc2xpZGVyVGh1bWI6IHsgbGFiZWwsIHRhZywgdmFsdWUsIG1heCwgbWluLCBvblZhbHVlQ2hhbmdlLCB2YWx1ZVRleHQgfSB9KTtcclxuXHJcbiAgICByZXR1cm4gKHJlbmRlciA/PyBkZWZhdWx0UmVuZGVyVGh1bWIpKHNsaWRlckluZm8sIHVzZUFyaWFTbGlkZXJUaHVtYlByb3BzKHtyZWZ9KSlcclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRodW1iKGluZm86IFVzZUFyaWFTbGlkZXJUaHVtYlJldHVyblR5cGVJbmZvLCB0aHVtYlByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KSB7XHJcbiAgICByZXR1cm4gPGlucHV0IHsuLi50aHVtYlByb3BzfSAvPlxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgU2xpZGVyVGh1bWIgPSBmb3J3YXJkUmVmKFNsaWRlclRodW1iVSkgYXMgdHlwZW9mIFNsaWRlclRodW1iVTtcclxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZUFyaWFUYWJsZSwgVXNlQXJpYVRhYmxlQm9keSwgVXNlQXJpYVRhYmxlQm9keVBhcmFtZXRlcnMsIFVzZUFyaWFUYWJsZUJvZHlSZXR1cm5UeXBlSW5mbywgVXNlQXJpYVRhYmxlQ2VsbCwgVXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnMsIFVzZUFyaWFUYWJsZUNlbGxSZXR1cm5UeXBlSW5mbywgVXNlQXJpYVRhYmxlUGFyYW1ldGVycywgVXNlQXJpYVRhYmxlUmV0dXJuVHlwZUluZm8sIFVzZUFyaWFUYWJsZVJvdywgVXNlQXJpYVRhYmxlUm93UGFyYW1ldGVycywgVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLXRhYmxlXCI7XHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVQcm9wczxUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlQXJpYVRhYmxlUGFyYW1ldGVycywgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFUYWJsZVBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVRhYmxlUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVRhYmxlUGFyYW1ldGVycywgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDxVc2VBcmlhVGFibGVQYXJhbWV0ZXJzLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xyXG4gICAgLy90YWdUYWJsZTogRWxlbWVudFRvVGFnPFRhYmxlRWxlbWVudD47XHJcbiAgICAvL3Byb3BzVGFibGUoKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVFbGVtZW50PjtcclxuICAgIHJlbmRlcj8oaW5mbzogVXNlQXJpYVRhYmxlUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCB0YWJsZVByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+KTogVk5vZGU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVCb2R5UHJvcHM8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFyaWFUYWJsZUJvZHlQYXJhbWV0ZXJzIHtcclxuICAgIHJlbmRlcj8oaW5mbzogVXNlQXJpYVRhYmxlQm9keVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgdGFibGVCb2R5UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFNlY3Rpb25FbGVtZW50Pik6IFZOb2RlO1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVIZWFkUHJvcHM8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICByZW5kZXI/KHRhYmxlSGVhZFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxTZWN0aW9uRWxlbWVudD4pOiBWTm9kZTtcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlRm9vdFByb3BzPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgcmVuZGVyPyh0YWJsZUZvb3RQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8U2VjdGlvbkVsZW1lbnQ+KTogVk5vZGU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVSb3dQcm9wczxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQyPFVzZUFyaWFUYWJsZVJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzQ2hpbGRSb3dPZlNlY3Rpb25cIiwgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDI8VXNlQXJpYVRhYmxlUm93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNDaGlsZFJvd09mU2VjdGlvblwiLCBcIm1hbmFnZWRDaGlsZFwiPixcclxuICAgIEdldDI8VXNlQXJpYVRhYmxlUm93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNDaGlsZFJvd09mU2VjdGlvblwiLCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0MjxVc2VBcmlhVGFibGVSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJhc1BhcmVudFJvd09mQ2VsbHNcIiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0MjxVc2VBcmlhVGFibGVSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJhc1BhcmVudFJvd09mQ2VsbHNcIiwgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDI8VXNlQXJpYVRhYmxlUm93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwibWFuYWdlZENoaWxkcmVuXCI+LFxyXG4gICAgR2V0MjxVc2VBcmlhVGFibGVSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJhc1BhcmVudFJvd09mQ2VsbHNcIiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDI8VXNlQXJpYVRhYmxlUm93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPiB7XHJcbiAgICByZW5kZXI/KGluZm86IFVzZUFyaWFUYWJsZVJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgdGFibGVSb3dQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4pOiBWTm9kZTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUNlbGxQcm9wczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDxVc2VBcmlhVGFibGVDZWxsUGFyYW1ldGVycywgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VBcmlhVGFibGVDZWxsUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRcIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnMsIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnMsIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBPbWl0PEdldDxVc2VBcmlhVGFibGVDZWxsUGFyYW1ldGVycywgXCJzdWJJbmZvXCI+LCBcImxvY2F0aW9uXCI+IHtcclxuICAgIHJlbmRlcj8oaW5mbzogVXNlQXJpYVRhYmxlQ2VsbFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PiwgdGFibGVSb3dQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+KTogVk5vZGU7XHJcbn1cclxuXHJcbmNvbnN0IExvY2F0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8XCJoZWFkXCIgfCBcImJvZHlcIiB8IFwiZm9vdFwiPihudWxsISk7XHJcblxyXG5jb25zdCBUYWJsZUJvZHlDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VBcmlhVGFibGVCb2R5PGFueSwgYW55LCBhbnk+PihudWxsISk7XHJcbmNvbnN0IFRhYmxlUm93Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQXJpYVRhYmxlUm93PGFueSwgYW55Pj4obnVsbCEpO1xyXG5jb25zdCBUYWJsZUNlbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VBcmlhVGFibGVDZWxsPGFueT4+KG51bGwhKTtcclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZShpbmZvOiBVc2VBcmlhVGFibGVSZXR1cm5UeXBlSW5mbzxhbnksIGFueT4sIHRhYmxlUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pIHtcclxuICAgIHJldHVybiA8dGFibGUgey4uLnRhYmxlUHJvcHN9IC8+XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZUJvZHkoaW5mbzogVXNlQXJpYVRhYmxlQm9keVJldHVyblR5cGVJbmZvPGFueSwgYW55PiwgYm9keVByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KSB7XHJcbiAgICByZXR1cm4gPHRib2R5IHsuLi5ib2R5UHJvcHN9IC8+XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZUhlYWQoaGVhZFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KSB7XHJcbiAgICByZXR1cm4gPHRoZWFkIHsuLi5oZWFkUHJvcHN9IC8+XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZUZvb3QoZm9vdFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KSB7XHJcbiAgICByZXR1cm4gPHRmb290IHsuLi5mb290UHJvcHN9IC8+XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZVJvdyhpbmZvOiBVc2VBcmlhVGFibGVSb3dSZXR1cm5UeXBlSW5mbzxhbnksIGFueT4sIHJvd1Byb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KSB7XHJcbiAgICByZXR1cm4gPHRyIHsuLi5yb3dQcm9wc30gLz5cclxufVxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlQ2VsbChpbmZvOiBVc2VBcmlhVGFibGVDZWxsUmV0dXJuVHlwZUluZm88YW55PiwgY2VsbFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KSB7XHJcbiAgICByZXR1cm4gPHRkIHsuLi5jZWxsUHJvcHN9IC8+XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRhYmxlVTxUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XHJcbiAgICBjb2xsYXRvcixcclxuICAgIGRpc2FibGVBcnJvd0tleXMsXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICBpbml0aWFsSW5kZXgsXHJcbiAgICBub1R5cGVhaGVhZCxcclxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcclxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVSZW5kZXIsXHJcbiAgICBvblRhYmJlZEluVG8sXHJcbiAgICBvblRhYmJlZE91dE9mLFxyXG4gICAgdHlwZWFoZWFkVGltZW91dCxcclxuICAgIHJlbmRlclxyXG59OiBUYWJsZVByb3BzPFRhYmxlRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbGVtZW50PiwgcmVmOiBSZWY8VGFibGVFbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VUYWJsZUJvZHksIHVzZVRhYmxlUHJvcHMsIHVzZVRhYmxlUm93LCAuLi50YWJsZUluZm8gfSA9IHVzZUFyaWFUYWJsZTxUYWJsZUVsZW1lbnQsIFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsZW1lbnQ+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cyB9LFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7fSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciwgb25UYWJiZWRJblRvLCBvblRhYmJlZE91dE9mIH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8VGFibGVCb2R5Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFibGVCb2R5fT5cclxuICAgICAgICAgICAgPFRhYmxlUm93Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFibGVSb3d9PlxyXG4gICAgICAgICAgICAgICAgeyhyZW5kZXIgPz8gZGVmYXVsdFJlbmRlclRhYmxlKSh0YWJsZUluZm8sIHVzZVRhYmxlUHJvcHMoeyByZWYgfSkpfVxyXG4gICAgICAgICAgICA8L1RhYmxlUm93Q29udGV4dC5Qcm92aWRlcj5cclxuICAgICAgICA8L1RhYmxlQm9keUNvbnRleHQuUHJvdmlkZXI+XHJcbiAgICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRhYmxlQm9keVU8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgcmVuZGVyXHJcbn06IFRhYmxlQm9keVByb3BzPFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCByZWY6IFJlZjxTZWN0aW9uRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHsgdXNlVGFibGVCb2R5UHJvcHMsIC4uLnNlY3Rpb25JbmZvIH0gPSB1c2VDb250ZXh0KFRhYmxlQm9keUNvbnRleHQpKHt9KTtcclxuICAgIHJldHVybiA8TG9jYXRpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPVwiYm9keVwiPnsocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJUYWJsZUJvZHkpKHNlY3Rpb25JbmZvLCB1c2VUYWJsZUJvZHlQcm9wcyh7IHJlZiB9KSl9PC9Mb2NhdGlvbkNvbnRleHQuUHJvdmlkZXI+XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRhYmxlSGVhZFU8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHJlbmRlciB9OiBUYWJsZUhlYWRQcm9wczxTZWN0aW9uRWxlbWVudD4sIHJlZjogUmVmPFNlY3Rpb25FbGVtZW50Pikge1xyXG4gICAgcmV0dXJuIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9XCJoZWFkXCI+eyhyZW5kZXIgPz8gZGVmYXVsdFJlbmRlclRhYmxlSGVhZCkoeyByZWYgfSl9PC9Mb2NhdGlvbkNvbnRleHQuUHJvdmlkZXI+XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRhYmxlRm9vdFU8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHJlbmRlciB9OiBUYWJsZUZvb3RQcm9wczxTZWN0aW9uRWxlbWVudD4sIHJlZjogUmVmPFNlY3Rpb25FbGVtZW50Pikge1xyXG4gICAgcmV0dXJuIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9XCJmb290XCI+eyhyZW5kZXIgPz8gZGVmYXVsdFJlbmRlclRhYmxlRm9vdCkoeyByZWYgfSl9PC9Mb2NhdGlvbkNvbnRleHQuUHJvdmlkZXI+XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRhYmxlUm93VTxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgaW5kZXgsXHJcbiAgICB0ZXh0LFxyXG4gICAgYmx1clNlbGYsXHJcbiAgICBjb2xsYXRvcixcclxuICAgIGRpc2FibGVBcnJvd0tleXMsXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICBmbGFncyxcclxuICAgIGZvY3VzU2VsZixcclxuICAgIGhpZGRlbixcclxuICAgIGluZGV4RGVtYW5nbGVyLFxyXG4gICAgaW5kZXhNYW5nbGVyLFxyXG4gICAgaW5pdGlhbEluZGV4LFxyXG4gICAgbm9UeXBlYWhlYWQsXHJcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXHJcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxyXG4gICAgb25UYWJiZWRJblRvLFxyXG4gICAgb25UYWJiZWRPdXRPZixcclxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXHJcbiAgICByZW5kZXJcclxufTogVGFibGVSb3dQcm9wczxSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCByZWY6IFJlZjxSb3dFbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VUYWJsZUNlbGwsIHVzZVRhYmxlUm93UHJvcHMsIC4uLnJvd0luZm8gfSA9IHVzZUNvbnRleHQoVGFibGVSb3dDb250ZXh0KSh7XHJcbiAgICAgICAgYXNDaGlsZFJvd09mU2VjdGlvbjoge1xyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuIH0sXHJcbiAgICAgICAgICAgIHN1YkluZm86IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhc1BhcmVudFJvd09mQ2VsbHM6IHtcclxuICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMgfSxcclxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxyXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIsIG9uVGFiYmVkSW5Ubywgb25UYWJiZWRPdXRPZiB9LFxyXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0YWJsZVJvdzogeyBsb2NhdGlvbjogdXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIDxUYWJsZUNlbGxDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJsZUNlbGx9PnsocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJUYWJsZVJvdykocm93SW5mbywgdXNlVGFibGVSb3dQcm9wcyh7IHJlZiB9KSl9PC9UYWJsZUNlbGxDb250ZXh0LlByb3ZpZGVyPlxyXG59XHJcblxyXG5mdW5jdGlvbiBUYWJsZUNlbGxVPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBpbmRleCwgdGV4dCwgYmx1clNlbGYsIGZsYWdzLCBmb2N1c1NlbGYsIGhpZGRlbiwgdmFsdWUsIHJlbmRlciB9OiBUYWJsZUNlbGxQcm9wczxDZWxsRWxlbWVudD4sIHJlZjogUmVmPENlbGxFbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VUYWJsZUNlbGxQcm9wcywgLi4uY2VsbEluZm8gfSA9IHVzZUNvbnRleHQoVGFibGVDZWxsQ29udGV4dCkoe1xyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuIH0sXHJcbiAgICAgICAgc3ViSW5mbzoge1xyXG4gICAgICAgICAgICBsb2NhdGlvbjogdXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLFxyXG4gICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJUYWJsZUNlbGwpKGNlbGxJbmZvLCB1c2VUYWJsZUNlbGxQcm9wcyh7IHJlZiB9KSk7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBUYWJsZSA9IGZvcndhcmRSZWYoVGFibGVVKSBhcyB0eXBlb2YgVGFibGVVO1xyXG5leHBvcnQgY29uc3QgVGFibGVCb2R5ID0gZm9yd2FyZFJlZihUYWJsZUJvZHlVKSBhcyB0eXBlb2YgVGFibGVCb2R5VTtcclxuZXhwb3J0IGNvbnN0IFRhYmxlSGVhZCA9IGZvcndhcmRSZWYoVGFibGVIZWFkVSkgYXMgdHlwZW9mIFRhYmxlSGVhZFU7XHJcbmV4cG9ydCBjb25zdCBUYWJsZUZvb3QgPSBmb3J3YXJkUmVmKFRhYmxlRm9vdFUpIGFzIHR5cGVvZiBUYWJsZUZvb3RVO1xyXG5leHBvcnQgY29uc3QgVGFibGVSb3cgPSBmb3J3YXJkUmVmKFRhYmxlUm93VSkgYXMgdHlwZW9mIFRhYmxlUm93VTtcclxuZXhwb3J0IGNvbnN0IFRhYmxlQ2VsbCA9IGZvcndhcmRSZWYoVGFibGVDZWxsVSkgYXMgdHlwZW9mIFRhYmxlQ2VsbFU7XHJcblxyXG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgVXNlQXJpYVRhYiwgVXNlQXJpYVRhYkxpc3RSZXR1cm5UeXBlSW5mbywgVXNlQXJpYVRhYlBhbmVsLCBVc2VBcmlhVGFiUGFyYW1ldGVycywgVXNlQXJpYVRhYlJldHVyblR5cGVJbmZvLCB1c2VBcmlhVGFicywgVXNlQXJpYVRhYnNQYXJhbWV0ZXJzLCBVc2VBcmlhVGFic1JldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS10YWJzXCI7XHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFic1Byb3BzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDI8VXNlQXJpYVRhYnNQYXJhbWV0ZXJzLCBcInRhYkxpc3RcIiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0MjxVc2VBcmlhVGFic1BhcmFtZXRlcnMsIFwidGFiTGlzdFwiLCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0MjxVc2VBcmlhVGFic1BhcmFtZXRlcnMsIFwidGFiTGlzdFwiLCBcIm1hbmFnZWRDaGlsZHJlblwiPixcclxuICAgIEdldDI8VXNlQXJpYVRhYnNQYXJhbWV0ZXJzLCBcInRhYkxpc3RcIiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDI8VXNlQXJpYVRhYnNQYXJhbWV0ZXJzLCBcInRhYkxpc3RcIiwgXCJzaW5nbGVTZWxlY3Rpb25cIj4sXHJcbiAgICBHZXQyPFVzZUFyaWFUYWJzUGFyYW1ldGVycywgXCJ0YWJMaXN0XCIsIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPixcclxuICAgIEdldDI8VXNlQXJpYVRhYnNQYXJhbWV0ZXJzLCBcInRhYlBhbmVsc1wiLCBcIm1hbmFnZWRDaGlsZHJlblwiPiB7XHJcbiAgICByZW5kZXI/KHRhYnNJbmZvOiBVc2VBcmlhVGFic1JldHVyblR5cGVJbmZvICYgVXNlQXJpYVRhYkxpc3RSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PiwgbGFiZWxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiwgdGFiTGlzdFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pOiBWTm9kZTxhbnk+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRhYlByb3BzPFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIEdldDxVc2VBcmlhVGFiUGFyYW1ldGVycywgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VBcmlhVGFiUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRcIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVRhYlBhcmFtZXRlcnMsIFwicm92aW5nVGFiSW5kZXhcIj4ge1xyXG4gICAgLy8gdGFnTGlzdEl0ZW06IEVsZW1lbnRUb1RhZzxMaXN0Ym94SXRlbUVsZW1lbnQ+O1xyXG4gICAgLy8gcHJvcHNMaXN0SXRlbTogKGFyZ3M6IEFyaWFMaXN0Ym94U2luZ2xlUHJvcHNEZXJpdmVkRnJvbSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdGJveEl0ZW1FbGVtZW50PjtcclxuICAgIHJlbmRlcj8oaW5mbzogVXNlQXJpYVRhYlJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+LCBsaXN0SXRlbTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xyXG59XHJcblxyXG5jb25zdCBUYWJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VBcmlhVGFiPGFueT4+KG51bGwhKTtcclxuY29uc3QgVGFiUGFuZWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VBcmlhVGFiUGFuZWw8YW55Pj4obnVsbCEpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFRhYnM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiUGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgc2VsZWN0ZWRJbmRleCxcclxuICAgIGNvbGxhdG9yLFxyXG4gICAgZGlzYWJsZUFycm93S2V5cyxcclxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcclxuICAgIGluZGV4RGVtYW5nbGVyLFxyXG4gICAgaW5kZXhNYW5nbGVyLFxyXG4gICAgaW5pdGlhbEluZGV4LFxyXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcclxuICAgIG5vVHlwZWFoZWFkLFxyXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxyXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZVJlbmRlcixcclxuICAgIG9uVGFiYmVkSW5UbyxcclxuICAgIG9uVGFiYmVkT3V0T2YsXHJcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxyXG4gICAgcmVuZGVyXHJcbn06IFRhYnNQcm9wczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBUYWJFbGVtZW50Pikge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUFyaWFUYWJMaXN0LFxyXG4gICAgICAgIHVzZUFyaWFUYWJMaXN0TGFiZWwsXHJcbiAgICAgICAgdXNlQXJpYVRhYlBhbmVsLFxyXG4gICAgICAgIC4uLnRhYnNJbmZvXHJcbiAgICB9ID0gdXNlQXJpYVRhYnM8TGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYlBhbmVsRWxlbWVudCwgTGFiZWxFbGVtZW50Pih7XHJcbiAgICAgICAgdGFiTGlzdDoge1xyXG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciwgb25UYWJiZWRJblRvLCBvblRhYmJlZE91dE9mIH0sXHJcbiAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4IH0sXHJcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHRhYlBhbmVsczoge1xyXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlQXJpYVRhYiwgdXNlQXJpYVRhYkxpc3RQcm9wcywgLi4udGFibGlzdEluZm8gfSA9IHVzZUFyaWFUYWJMaXN0KHt9KTtcclxuICAgIGNvbnN0IHsgdXNlQXJpYVRhYkxpc3RMYWJlbFByb3BzIH0gPSB1c2VBcmlhVGFiTGlzdExhYmVsKHt9KVxyXG5cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxUYWJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VBcmlhVGFifT5cclxuICAgICAgICAgICAgPFRhYlBhbmVsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlQXJpYVRhYlBhbmVsfT5cclxuICAgICAgICAgICAgICAgIHsocmVuZGVyID8/IGRlZmF1bHRUYWJzUmVuZGVyKSh7IC4uLnRhYnNJbmZvLCAuLi50YWJsaXN0SW5mbyB9LCB1c2VBcmlhVGFiTGlzdExhYmVsUHJvcHMoe30pLCB1c2VBcmlhVGFiTGlzdFByb3BzKHt9KSl9XHJcbiAgICAgICAgICAgIDwvVGFiUGFuZWxDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgICAgIDwvVGFiQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFRhYjxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBpbmRleCwgdGV4dCwgYmx1clNlbGYsIGZsYWdzLCBmb2N1c1NlbGYsIGhpZGRlbiwgcmVuZGVyIH06IFRhYlByb3BzPFRhYkVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZUFyaWFUYWJQcm9wcywgLi4udGFiSW5mbyB9ID0gdXNlQ29udGV4dChUYWJDb250ZXh0KSh7IGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSwgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW4gfSB9KTtcclxuXHJcbiAgICByZXR1cm4gKHJlbmRlciA/PyBkZWZhdWx0VGFiUmVuZGVyKSh0YWJJbmZvLCB1c2VBcmlhVGFiUHJvcHMoe30pKVxyXG5cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRUYWJzUmVuZGVyKHRhYnNJbmZvOiBVc2VBcmlhVGFic1JldHVyblR5cGVJbmZvICYgVXNlQXJpYVRhYkxpc3RSZXR1cm5UeXBlSW5mbzxhbnk+LCBsYWJlbFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBsaXN0UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pIHtcclxuICAgIGNvbnN0IGxhYmVsID0gPGRpdiB7Li4ubGFiZWxQcm9wc30gLz47XHJcbiAgICBjb25zdCBsaXN0ID0gPGRpdiB7Li4ubGlzdFByb3BzfSAvPjtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD57bGFiZWx9e2xpc3R9PC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRUYWJSZW5kZXIodGFiSW5mbzogVXNlQXJpYVRhYlJldHVyblR5cGVJbmZvPGFueT4sIHRhYlByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KSB7XHJcbiAgICBjb25zdCB0YWIgPSA8ZGl2IHsuLi50YWJQcm9wc30gLz47XHJcbiAgICByZXR1cm4gKHRhYilcclxufVxyXG4iLCJpbXBvcnQgeyBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUFyaWFUb29sdGlwLCBVc2VUb29sdGlwUGFyYW1ldGVycywgVXNlVG9vbHRpcFJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS10b29sdGlwXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRvb2x0aXBQcm9wczxUVCBleHRlbmRzIEVsZW1lbnQsIFRUVCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVG9vbHRpcFBhcmFtZXRlcnMge1xyXG4gICAgcmVuZGVyPzogKGluZm86IFVzZVRvb2x0aXBSZXR1cm5UeXBlSW5mbywgdHJpZ2dlclByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUVD4sIHRvb2x0aXBQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VFRUPikgPT4gVk5vZGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXIoaW5mbzogVXNlVG9vbHRpcFJldHVyblR5cGVJbmZvLCB0cmlnZ2VyUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIHRvb2x0aXBQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8ZGl2IHsuLi50cmlnZ2VyUHJvcHN9IC8+XHJcbiAgICAgICAgICAgIDxkaXYgey4uLnRvb2x0aXBQcm9wc30gLz5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZnVuY3Rpb24gVG9vbHRpcFU8VFQgZXh0ZW5kcyBFbGVtZW50LCBUVFQgZXh0ZW5kcyBFbGVtZW50Pih7IGZvY3VzRGVsYXksIG1vdXNlb3V0RGVsYXksIG1vdXNlb3ZlckRlbGF5LCByZW5kZXIgfTogVG9vbHRpcFByb3BzPFRULCBUVFQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZVRvb2x0aXAsIHVzZVRvb2x0aXBUcmlnZ2VyLCAuLi5pbmZvIH0gPSB1c2VBcmlhVG9vbHRpcDxUVCwgVFRUPih7IGZvY3VzRGVsYXksIG1vdXNlb3V0RGVsYXksIG1vdXNlb3ZlckRlbGF5IH0pO1xyXG4gICAgY29uc3QgeyB1c2VUb29sdGlwVHJpZ2dlclByb3BzIH0gPSB1c2VUb29sdGlwVHJpZ2dlcigpO1xyXG4gICAgY29uc3QgeyB1c2VUb29sdGlwUHJvcHMgfSA9IHVzZVRvb2x0aXAoKTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgeyhyZW5kZXIgPz8gZGVmYXVsdFJlbmRlcikoaW5mbywgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyh7fSksIHVzZVRvb2x0aXBQcm9wcyh7fSkgYXMgYW55KX1cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFRvb2x0aXAgPSBmb3J3YXJkUmVmKFRvb2x0aXBVKSBhcyB1bmtub3duIGFzIHR5cGVvZiBUb29sdGlwVTtcclxuIiwiXHJcbmltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBoLCBSZW5kZXJhYmxlUHJvcHMgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IEFyaWFBY2NvcmRpb24sIEFyaWFBY2NvcmRpb25TZWN0aW9uLCBIZWFkaW5nIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XHJcblxyXG5mdW5jdGlvbiBEZW1vQWNjb3JkaW9uKHByb3BzOiBSZW5kZXJhYmxlUHJvcHM8e30+KSB7XHJcbiAgICByZXR1cm4gPEFyaWFBY2NvcmRpb24gey4uLnByb3BzfSByZW5kZXI9eyhpbmZvLCBjaGlsZHJlbikgPT4geyByZXR1cm4gPGRpdiBpZD1cImFjY29yZGlvbi1kZW1vXCI+e2NoaWxkcmVufTwvZGl2PiB9fSAvPlxyXG59XHJcblxyXG5mdW5jdGlvbiBEZW1vQWNjb3JkaW9uU2VjdGlvbih7IGluZGV4LCBib2R5LCBoZWFkaW5nLCBkaXNhYmxlZCwgb3BlbiB9OiB7IG9wZW4/OiBib29sZWFuLCBkaXNhYmxlZDogYm9vbGVhbiwgaW5kZXg6IG51bWJlciwgaGVhZGluZzogQ29tcG9uZW50Q2hpbGRyZW4sIGJvZHk6IENvbXBvbmVudENoaWxkcmVuIH0pIHtcclxuICAgIHJldHVybiA8QXJpYUFjY29yZGlvblNlY3Rpb248SFRNTERpdkVsZW1lbnQsIEhUTUxEaXZFbGVtZW50PiBpbmRleD17aW5kZXh9IG9wZW49e29wZW59IGRpc2FibGVkPXtkaXNhYmxlZH0gcmVuZGVyPXsoaW5mbywgaGVhZGVyUHJvcHMsIGJvZHlQcm9wcykgPT4ge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPXs8ZGl2IHsuLi5oZWFkZXJQcm9wc30+e2hlYWRpbmd9ICh7IWluZm8uYWNjb3JkaW9uU2VjdGlvbi5leHBhbmRlZCAmJiBcIm5vdCBcIn0gb3BlbiksICh7IWluZm8uYWNjb3JkaW9uU2VjdGlvbi5mb2N1c2VkICYmIFwibm90IFwifSBmb2N1c2VkKTwvZGl2Pn0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiB7Li4uYm9keVByb3BzfT57Ym9keX08L2Rpdj5cclxuICAgICAgICAgICAgICAgIDwvSGVhZGluZz5cclxuICAgICAgICAgICAgPC8+XHJcbiAgICAgICAgKVxyXG4gICAgfX0+PC9BcmlhQWNjb3JkaW9uU2VjdGlvbj5cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9hY2NvcmRpb24vXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIEFjY29yZGlvbiBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+RWFjaCBzZWN0aW9uJ3MgaGVhZGVyIGFuZCBib2R5IGFyZSBsaW5rZWQgdmlhIElEOyB0aGUgYm9keSBpcyA8Y29kZT5sYWJlbGxlZC1ieTwvY29kZT4gdGhlIGhlYWRlciBhbmQgdGhlIGhlYWRlciA8Y29kZT5jb250cm9sPC9jb2RlPnMgdGhlIGJvZHkuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgaGVhZGVyIGlzIGEgYnV0dG9uIGFuZCByZXNwb25kcyB0byBrZXlib2FyZCwgbW91c2UsIHRvdWNoLCBldGMuIGV2ZW50cywgcmVnYXJkbGVzcyBvZiB0aGUgZWxlbWVudCB1c2VkLjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+SWYgdGhlIGhlYWRlciBlbGVtZW50IGlzIG5vdCBhIDxjb2RlPiZsdDtidXR0b24mZ3Q7PC9jb2RlPiBlbGVtZW50LCBpdCBpcyBnaXZlbiB0aGF0IDxjb2RlPnJvbGU8L2NvZGU+LjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+VXAvZG93biAmYW1wOyBIb21lL0VuZCBrZXlzIG5hdmlnYXRlIHRocm91Z2ggdGhlIGxpc3QsIGFzIGRvZXMgVGFiIGFuZCBTaGlmdCtUYWI8L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPjwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDxwPkltcG9ydGFudDogVGhlIDxjb2RlPnJlbmRlcjwvY29kZT4gcHJvcCBlYWNoIDxjb2RlPkFjY29yZGlvblNlY3Rpb248L2NvZGU+IHRha2VzIG11c3Qgd3JhcCB0aGUgYnV0dG9uIHdpdGggYSA8YSBocmVmPVwiaHR0cHM6Ly93M2MuZ2l0aHViLmlvL2FyaWEvI2hlYWRpbmdcIj5oZWFkaW5nPC9hPiAoZS5nLiA8Y29kZT5oMzwvY29kZT4sIG9yIDxjb2RlPiZsdDtIZWFkaW5nJmd0OzwvY29kZT4pLiBTZWUgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIGFuIGV4YW1wbGUuPC9wPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcclxuICAgIHJldHVybiAoPGNvZGU+e2A8QXJpYUFjY29yZGlvbiByZW5kZXI9ey4uLn0+XHJcbiAgICA8QXJpYUFjY29yZGlvblNlY3Rpb24gaW5kZXg9ezB9IHJlbmRlcj17Li4ufSAvPlxyXG4gICAgPEFyaWFBY2NvcmRpb25TZWN0aW9uIGluZGV4PXsxfSByZW5kZXI9ey4uLn0gLz5cclxuICAgIDxBcmlhQWNjb3JkaW9uU2VjdGlvbiBpbmRleD17Mn0gcmVuZGVyPXsuLi59IC8+XHJcbjwvQXJpYUFjY29yZGlvbj5gfTwvY29kZT4pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPEJsdXJiIC8+XHJcbiAgICAgICAgICAgIDxDb2RlIC8+XHJcbiAgICAgICAgICAgIDxEZW1vQWNjb3JkaW9uPlxyXG4gICAgICAgICAgICAgICAgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXswfSBoZWFkaW5nPVwiQWNjb3JkaW9uIHNlY3Rpb24gIzBcIiBib2R5PVwiQm9keSBjb250ZW50ICMwXCIgZGlzYWJsZWQ9e2ZhbHNlfSAvPlxyXG4gICAgICAgICAgICAgICAgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXsxfSBoZWFkaW5nPVwiQWNjb3JkaW9uIHNlY3Rpb24gIzFcIiBib2R5PVwiQm9keSBjb250ZW50ICMxXCIgZGlzYWJsZWQ9e2ZhbHNlfSAvPlxyXG4gICAgICAgICAgICAgICAgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXsyfSBoZWFkaW5nPVwiQWNjb3JkaW9uIHNlY3Rpb24gIzIgKGRpc2FibGVkKVwiIGJvZHk9XCJCb2R5IGNvbnRlbnQgIzJcIiBkaXNhYmxlZD17dHJ1ZX0gLz5cclxuICAgICAgICAgICAgICAgIDxEZW1vQWNjb3JkaW9uU2VjdGlvbiBpbmRleD17M30gaGVhZGluZz1cIkFjY29yZGlvbiBzZWN0aW9uICMzIChmb3JjZWQgb3BlbilcIiBib2R5PVwiQm9keSBjb250ZW50ICMzXCIgZGlzYWJsZWQ9e2ZhbHNlfSBvcGVuPXt0cnVlfSAvPlxyXG4gICAgICAgICAgICAgICAgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXs0fSBoZWFkaW5nPVwiQWNjb3JkaW9uIHNlY3Rpb24gIzQgKGZvcmNlZCBjbG9zZWQpXCIgYm9keT1cIkJvZHkgY29udGVudCAjNFwiIGRpc2FibGVkPXtmYWxzZX0gb3Blbj17ZmFsc2V9IC8+XHJcbiAgICAgICAgICAgIDwvRGVtb0FjY29yZGlvbj5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufSIsIlxyXG5pbXBvcnQgeyByZW5kZXIsIGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IEhlYWRpbmcgfSBmcm9tIFwiLi4vY29tcG9uZW50L2hlYWRpbmdcIjtcclxuaW1wb3J0ICogYXMgQWNjb3JkaW9uIGZyb20gXCIuL2RlbW9zL2FjY29yZGlvblwiXHJcblxyXG4vL2NvbnN0IFJhbmRvbVdvcmRzID0gXCJMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4gVXQgZW5pbSBhZCBtaW5pbSB2ZW5pYW0sIHF1aXMgbm9zdHJ1ZCBleGVyY2l0YXRpb24gdWxsYW1jbyBsYWJvcmlzIG5pc2kgdXQgYWxpcXVpcCBleCBlYSBjb21tb2RvIGNvbnNlcXVhdC4gRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2UgY2lsbHVtIGRvbG9yZSBldSBmdWdpYXQgbnVsbGEgcGFyaWF0dXIuIEV4Y2VwdGV1ciBzaW50IG9jY2FlY2F0IGN1cGlkYXRhdCBub24gcHJvaWRlbnQsIHN1bnQgaW4gY3VscGEgcXVpIG9mZmljaWEgZGVzZXJ1bnQgbW9sbGl0IGFuaW0gaWQgZXN0IGxhYm9ydW0uXCIuc3BsaXQoXCIgXCIpO1xyXG5cclxuXHJcbmNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkRlbW9zXCI+XHJcbiAgICAgICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiQWNjb3JkaW9uXCI+PEFjY29yZGlvbi5EZW1vIC8+PC9IZWFkaW5nPlxyXG4gICAgICAgICAgICAgICAgey8qXHJcbiAgICAgICBcclxuICAgICAgICA8RGVtb1RhYmxlIC8+XHJcblxyXG5cclxuICAgICAgICA8RGVtb1VzZUZvY3VzVHJhcCAvPlxyXG4gICAgICAgIDxEZW1vVXNlRHJvcHBhYmxlIC8+XHJcbiAgICAgICAgPERlbW9Vc2VEcmFnZ2FibGUgLz5cclxuICAgICAgICA8aW5wdXQgLz4qL31cclxuICAgICAgICA8L0hlYWRpbmc+KVxyXG59XHJcblxyXG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgcmVuZGVyKDxDb21wb25lbnQgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9vdFwiKSEpO1xyXG59KVxyXG4iXSwibmFtZXMiOlsidm5vZGVJZCIsInJlcmVuZGVyUXVldWUiLCJIZWFkaW5nTGV2ZWxDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImhlYWRpbmciLCJwcm9wcyIsImhlYWRpbmdMZXZlbEJlZm9yZVVzIiwidXNlQ29udGV4dCIsInRhZyIsIm5ld0hlYWRpbmdMZXZlbCIsIndhcm5Pbk92ZXJ3cml0ZSIsIl9qc3giLCJjaGlsZHJlbiIsIl9qc3hzIiwiSGVhZGluZ1Jlc2V0IiwibmV3TGV2ZWwiLCJ1c2VFbnN1cmVTdGFiaWxpdHkiLCJwYXJlbnRIb29rTmFtZSIsInZhbHVlcyIsInVzZUhlbHBlciIsImZvckVhY2giLCJ2YWx1ZSIsImluZGV4IiwiaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkiLCJ1c2VSZWYiLCJzaG93bkVycm9yIiwiY3VycmVudCIsInVzZVBhc3NpdmVTdGF0ZSIsIm9uQ2hhbmdlIiwiZ2V0SW5pdGlhbFZhbHVlIiwidmFsdWVSZWYiLCJVbnNldCIsIndhcm5pbmdSZWYiLCJjbGVhbnVwQ2FsbGJhY2tSZWYiLCJ1bmRlZmluZWQiLCJvblNob3VsZENsZWFuVXAiLCJ1c2VDYWxsYmFjayIsImNsZWFudXBDYWxsYmFjayIsInRyeUVuc3VyZVZhbHVlIiwiaW5pdGlhbFZhbHVlIiwiZXgiLCJnZXRWYWx1ZSIsIndhcm4iLCJ1c2VMYXlvdXRFZmZlY3QiLCJyIiwibWljcm90YXNrUXVldWVkIiwiYXJnIiwicHJldkRlcCIsImhhbmRsZSIsInNldFRpbWVvdXQiLCJkZXAiLCJGdW5jdGlvbiIsInVzZU1lcmdlZENoaWxkcmVuIiwibGhzIiwicmhzIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwiZSIsInQiLCJmIiwibiIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsImNsc3giLCJhcmd1bWVudHMiLCJ1c2VNZXJnZWRDbGFzc2VzIiwiY2xhc3MiLCJsaHNDbGFzcyIsImNsYXNzTmFtZSIsImxoc0NsYXNzTmFtZSIsInJoc0NsYXNzIiwicmhzQ2xhc3NOYW1lIiwibGhzQ2xhc3NlcyIsInNwbGl0IiwicmhzQ2xhc3NlcyIsImFsbENsYXNzZXMiLCJTZXQiLCJmcm9tIiwiam9pbiIsInByb2Nlc3NSZWYiLCJpbnN0YW5jZSIsInJlZiIsImNvbnNvbGUiLCJhc3NlcnQiLCJjb21iaW5lZCIsInN0eWxlU3RyaW5nVG9PYmplY3QiLCJzdHlsZSIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwibWFwIiwic3RhdGVtZW50IiwidXNlTWVyZ2VkU3R5bGVzIiwibG9nIiwidXNlTWVyZ2VkUHJvcHMiLCJsaHNBbGwiLCJyaHNBbGwiLCJfbGhzQ2hpbGRyZW4iLCJfbGhzQ2xhc3NOYW1lIiwiX2xoc1N0eWxlIiwiX2xoc1JlZiIsImxoc01pc2MiLCJfcmhzQ2hpbGRyZW4iLCJfcmhzQ2xhc3MiLCJfcmhzQ2xhc3NOYW1lIiwiX3Joc1N0eWxlIiwiX3Joc1JlZiIsInJoc01pc2MiLCJyZXQiLCJ1c2VNZXJnZWRSZWZzIiwicmhzRW50cmllcyIsImVudHJpZXMiLCJyaHNLZXlVIiwicmhzVmFsdWUiLCJyaHNLZXkiLCJsaHNWYWx1ZSIsIm1lcmdlZCIsIm1lcmdlRnVuY3Rpb25zIiwidXNlUmVmRWxlbWVudCIsImFyZ3MiLCJvbkVsZW1lbnRDaGFuZ2UiLCJvbk1vdW50Iiwib25Vbm1vdW50IiwiaGFuZGxlciIsInByZXZWYWx1ZSIsImFjdGl2ZUVsZW1lbnRVcGRhdGVycyIsIk1hcCIsImxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMiLCJ3aW5kb3dGb2N1c2VkVXBkYXRlcnMiLCJ3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzIiwibWljcm90YXNrcyIsImZvckVhY2hVcGRhdGVyIiwid2luZG93IiwiaGFzIiwiYWRkIiwicXVldWVNaWNyb3Rhc2siLCJkZWxldGUiLCJ1cGRhdGVycyIsImdldCIsInVwZGF0ZXIiLCJmb2N1c291dCIsInRhcmdldCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsInJlbGF0ZWRUYXJnZXQiLCJmb2N1c2luIiwiY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQiLCJUYWJsZSIsImJhc2U2NCIsInJhbmRvbTZCaXRzIiwiZ2VuZXJhdGVSYW5kb21JZCIsInByZWZpeCIsInJhbmRvbTY0Qml0cyIsInByZXZpb3VzSW5wdXRzIiwidG9SdW4iLCJjb21taXROYW1lIiwib3JpZ2luYWxDb21taXQiLCJvcHRpb25zIiwibmV3Q29tbWl0IiwiaWQiLCJlZmZlY3RJbmZvIiwiY2xlYXIiLCJlZmZlY3QiLCJpbnB1dHMiLCJTeW1ib2wiLCJ1c2VTdGFibGVHZXR0ZXIiLCJ1c2VCZWZvcmVMYXlvdXRFZmZlY3QiLCJFcnJvciIsImZuIiwiY3VycmVudENhbGxiYWNrR2V0dGVyIiwiaXNPYmplY3QiLCJ0eXBlIiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsImZyZWVTZWxmIiwic2VsZiIsInJvb3QiLCJvYmplY3RQcm90byIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJ0b1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJnZXRSYXdUYWciLCJpc093biIsImNhbGwiLCJ1bm1hc2tlZCIsInJlc3VsdCIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsImJhc2VHZXRUYWciLCJpc09iamVjdExpa2UiLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInN0YXRlIiwic2V0U3RhdGVQIiwidXNlU3RhdGVQIiwic2V0U3RhdGUiLCJjYWxsYmFjayIsIm5leHRWYWx1ZSIsImltcGwiLCJ1c2VFZmZlY3ROYXRpdmUiLCJwcmV2SW5wdXRzIiwiZWZmZWN0MiIsImNoYW5nZXMiLCJpIiwiTWF0aCIsIm1heCIsInRvIiwidXNlRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0TmF0aXZlIiwicGFyZW50UGFyYW1ldGVycyIsIm1hbmFnZWRDaGlsZHJlbiIsIm9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCIsIm9uQ2hpbGRyZW5Nb3VudENoYW5nZSIsImdldEhpZ2hlc3RJbmRleCIsIm1hbmFnZWRDaGlsZHJlbkFycmF5IiwiaGlnaGVzdEluZGV4IiwiYXJyIiwicmVjIiwibG93ZXN0SW5kZXgiLCJmb3JFYWNoQ2hpbGQiLCJjaGlsZCIsImZpZWxkIiwicmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyIsInJlbW90ZVVMRUNoaWxkQ2hhbmdlZCIsInNpemUiLCJyZW1vdGVVTEVDaGlsZE1vdW50ZWQiLCJtb3VudGVkIiwiaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkIiwibW91bnRzIiwidW5tb3VudHMiLCJzaGF2ZSIsInNwbGljZSIsInVzZU1hbmFnZWRDaGlsZCIsIm1hbmFnZWRDaGlsZCIsImluZm8iLCJmbGFncyIsInN1YkluZm8iLCJmbGF0IiwiYXJyYXlTbGljZSIsImdldERvY3VtZW50IiwiZWxlbWVudCIsImRvY3VtZW50IiwiZ2xvYmFsVGhpcyIsImZhY3RvcnkiLCJ0aGlzIiwiX2NyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsYXNzQ2FsbENoZWNrIiwiVHlwZUVycm9yIiwic2xpY2UiLCJtYXRjaGVzIiwiRWxlbWVudCIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nIiwiSW5lcnRSb290Iiwicm9vdEVsZW1lbnQiLCJpbmVydE1hbmFnZXIiLCJfaW5lcnRNYW5hZ2VyIiwiX3Jvb3RFbGVtZW50IiwiX21hbmFnZWROb2RlcyIsImhhc0F0dHJpYnV0ZSIsIl9zYXZlZEFyaWFIaWRkZW4iLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSIsIl9vYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJfb25NdXRhdGlvbiIsImJpbmQiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJkZXN0cnVjdG9yIiwiZGlzY29ubmVjdCIsInJlbW92ZUF0dHJpYnV0ZSIsImluZXJ0Tm9kZSIsIl91bm1hbmFnZU5vZGUiLCJub2RlIiwic3RhcnROb2RlIiwiX3RoaXMyIiwiY29tcG9zZWRUcmVlV2FsayIsIl92aXNpdE5vZGUiLCJhY3RpdmVFbGVtZW50IiwiYm9keSIsImNvbnRhaW5zIiwibm9kZVR5cGUiLCJOb2RlIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsInBhcmVudE5vZGUiLCJibHVyIiwiZm9jdXMiLCJFTEVNRU5UX05PREUiLCJfYWRvcHRJbmVydFJvb3QiLCJfbWFuYWdlTm9kZSIsInJlZ2lzdGVyIiwiZGVyZWdpc3RlciIsIl91bm1hbmFnZVN1YnRyZWUiLCJfdGhpczMiLCJpbmVydFN1YnJvb3QiLCJnZXRJbmVydFJvb3QiLCJzZXRJbmVydCIsIm1hbmFnZWROb2RlcyIsInNhdmVkSW5lcnROb2RlIiwicmVjb3JkcyIsInJlY29yZCIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJhdHRyaWJ1dGVOYW1lIiwibWFuYWdlZE5vZGUiLCJzZXQiLCJhcmlhSGlkZGVuIiwiSW5lcnROb2RlIiwiaW5lcnRSb290IiwiX25vZGUiLCJfb3ZlcnJvZGVGb2N1c01ldGhvZCIsIl9pbmVydFJvb3RzIiwiX3NhdmVkVGFiSW5kZXgiLCJfZGVzdHJveWVkIiwiZW5zdXJlVW50YWJiYWJsZSIsIl90aHJvd0lmRGVzdHJveWVkIiwiZGVzdHJveWVkIiwidGFiSW5kZXgiLCJoYXNTYXZlZFRhYkluZGV4IiwiYWRkSW5lcnRSb290IiwicmVtb3ZlSW5lcnRSb290IiwiSW5lcnRNYW5hZ2VyIiwiX2RvY3VtZW50IiwiX3dhdGNoRm9ySW5lcnQiLCJhZGRJbmVydFN0eWxlIiwiaGVhZCIsImRvY3VtZW50RWxlbWVudCIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiX29uRG9jdW1lbnRMb2FkZWQiLCJpbmVydCIsInBhcmVudCIsIl9pbmVydFJvb3QiLCJpbmVydEVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImluZXJ0RWxlbWVudCIsIl90aGlzIiwidW5zaGlmdCIsInNoYWRvd1Jvb3RBbmNlc3RvciIsInNoYWRvd1Jvb3QiLCJsb2NhbE5hbWUiLCJjb250ZW50IiwiZGlzdHJpYnV0ZWROb2RlcyIsImdldERpc3RyaWJ1dGVkTm9kZXMiLCJzbG90IiwiX2Rpc3RyaWJ1dGVkTm9kZXMiLCJhc3NpZ25lZE5vZGVzIiwiZmxhdHRlbiIsIl9pIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicXVlcnlTZWxlY3RvciIsInRleHRDb250ZW50IiwiYXBwZW5kQ2hpbGQiLCJIVE1MRWxlbWVudCIsIl9ibG9ja2luZ0VsZW1lbnRzIiwiX2FscmVhZHlJbmVydEVsZW1lbnRzIiwiX3RvcEVsUGFyZW50cyIsIl9zaWJsaW5nc1RvUmVzdG9yZSIsIl9pbmVydFNpYmxpbmdzIiwiX2dldFBhcmVudHMiLCJfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbiIsIl9oYW5kbGVNdXRhdGlvbnMiLCJudWxsYWJsZSIsInRvcCIsImVsZW1zIiwicHVzaCIsImluZGV4T2YiLCJfdG9wQ2hhbmdlZCIsInBvcCIsInJlbW92ZSIsIl9hIiwiX2IiLCJfYyIsIm5ld1RvcCIsInRvS2VlcEluZXJ0Iiwib2xkUGFyZW50cyIsIl9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzIiwibmV3UGFyZW50cyIsInRvU2tpcCIsImoiLCJfc3dhcEluZXJ0ZWRTaWJsaW5nIiwib2xkSW5lcnQiLCJuZXdJbmVydCIsInNpYmxpbmdzVG9SZXN0b3JlIiwiX3BhcmVudE1PIiwiZWxlbWVudHMiLCJtbyIsInNpYmxpbmdzIiwic2libGluZyIsImluZXJ0ZWRTaWJsaW5ncyIsIl9pc0luZXJ0YWJsZSIsInBhcmVudFRvT2JzZXJ2ZSIsIm1heWJlU2hhZHlSb290IiwiX19zaGFkeSIsImhvc3QiLCJtdXRhdGlvbnMiLCJwYXJlbnRzIiwibXV0YXRpb24iLCJpZHgiLCJpbmVydGVkQ2hpbGQiLCJ1c2VGb3JjZVVwZGF0ZSIsInVzZUxvZ2ljYWxEaXJlY3Rpb24iLCJvbkxvZ2ljYWxEaXJlY3Rpb25DaGFuZ2UiLCJnZXRDb21wdXRlZFN0eWxlcyIsInNldENvbXB1dGVkU3R5bGVzIiwicmV0dXJuTnVsbCIsImdldEVsZW1lbnQiLCJ1c2VSZWZFbGVtZW50UHJvcHMiLCJnZXRDb21wdXRlZFN0eWxlIiwidXNlRWxlbWVudFNpemVQcm9wcyIsInVzZUVsZW1lbnRTaXplIiwib25TaXplQ2hhbmdlIiwiXyIsImdldExvZ2ljYWxEaXJlY3Rpb25JbmZvIiwiY29tcHV0ZWRTdHlsZXMiLCJ3Iiwid3JpdGluZ01vZGUiLCJkIiwiZGlyZWN0aW9uIiwidGV4dE9yaWVudGF0aW9uIiwiV3JpdGluZ01vZGVzIiwiY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uIiwiZWxlbWVudE9yaWVudGF0aW9uIiwiY29udmVydFRvUGh5c2ljYWxTaWRlIiwic2lkZSIsIk0iLCJibG9ja0RpcmVjdGlvbiIsImlubGluZURpcmVjdGlvbiIsImlubGluZU9yaWVudGF0aW9uIiwiY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbiIsImJsb2NrT3JpZW50YXRpb24iLCJjb252ZXJ0RWxlbWVudFNpemUiLCJlbGVtZW50U2l6ZSIsImlubGluZVNpemUiLCJibG9ja1NpemUiLCJjYXBpdGFsaXplIiwiY2xpZW50QmxvY2tTaXplIiwib2Zmc2V0SW5saW5lU2l6ZSIsIm9mZnNldEJsb2NrU2l6ZSIsInNjcm9sbElubGluZVNpemUiLCJzY3JvbGxCbG9ja1NpemUiLCJmMSIsImdldFBoeXNpY2FsTGVmdFRvcCIsImYyIiwiZ2V0UGh5c2ljYWxSaWdodEJvdHRvbSIsImYzIiwiZjQiLCJjbGllbnRJbmxpbmVJbnNldCIsInNjcm9sbElubGluZUluc2V0Iiwib2Zmc2V0SW5saW5lSW5zZXQiLCJzY3JvbGxCbG9ja0luc2V0Iiwib2Zmc2V0QmxvY2tJbnNldCIsImNsaWVudEJsb2NrSW5zZXQiLCJkaXIiLCJiIiwibCIsInVzZVRpbWVvdXQiLCJ0aW1lb3V0IiwidHJpZ2dlckluZGV4Iiwic3RhYmxlQ2FsbGJhY2siLCJ1c2VTdGFibGVDYWxsYmFjayIsInN0YXJ0VGltZVJlZiIsImdldFRpbWVvdXQiLCJ0aW1lb3V0SXNOdWxsIiwidXNlTGluZWFyTmF2aWdhdGlvbiIsImxpbmVhck5hdmlnYXRpb24iLCJuYXZpZ2F0ZVRvRmlyc3QiLCJudGYiLCJuYXZpZ2F0ZVRvTGFzdCIsIm50bCIsIm5hdmlnYXRlVG9OZXh0IiwibnRuIiwibmF2aWdhdGVUb1ByZXYiLCJudHAiLCJuYXZpZ2F0aW9uRGlyZWN0aW9uIiwibmQiLCJkaXNhYmxlQXJyb3dLZXlzIiwiZGFrIiwiZGlzYWJsZUhvbWVFbmRLZXlzIiwiZGhlayIsInVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wcyIsImdldERpc2FibGVIb21lRW5kS2V5cyIsInVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyIsIm9uS2V5RG93biIsImN0cmxLZXkiLCJtZXRhS2V5IiwiZ2V0TmF2aWdhdGlvbkRpcmVjdGlvbiIsImdldERpc2FibGVBcnJvd0tleXMiLCJhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uIiwicHJvcE5hbWUiLCJkaXJlY3Rpb25BbGxvd2VkIiwiYWxsb3dzQmxvY2tOYXZpZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uIiwidHlwZWFoZWFkTmF2aWdhdGlvbiIsImNvbGxhdG9yIiwiZ2V0SW5kZXgiLCJ0eXBlYWhlYWRUaW1lb3V0Iiwic2V0SW5kZXgiLCJub1R5cGVhaGVhZCIsImN1cnJlbnRUeXBlYWhlYWQiLCJnZXRDdXJyZW50VHlwZWFoZWFkIiwic2V0Q3VycmVudFR5cGVhaGVhZCIsInNldEludmFsaWRUeXBlYWhlYWQiLCJpbnZhbGlkVHlwZWFoZWFkIiwic2V0SW1lQWN0aXZlIiwiZ2V0SW1lQWN0aXZlIiwibmV4dFR5cGVhaGVhZENoYXIiLCJzZXROZXh0VHlwZWFoZWFkQ2hhciIsInR5cGVhaGVhZCIsInNhZmVMaHMiLCJjb21wYXJlIiwibm9ybWFsaXplIiwic2FmZVJocyIsInRvTG93ZXJDYXNlIiwibG9jYWxlQ29tcGFyZSIsImluc2VydGluZ0NvbXBhcmF0b3IiLCJ0ZXh0IiwiY29tcGFyYXRvclNoYXJlZCIsInN1YnN0cmluZyIsInVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyIsIm9uQ29tcG9zaXRpb25TdGFydCIsIl9lIiwiaW1lQWN0aXZlIiwicmV2ZXJzZSIsInVzZVJvdmluZ1RhYkluZGV4Iiwicm92aW5nVGFiSW5kZXgiLCJpbml0aWFsSW5kZXgiLCJvblRhYmJlZEluVG8iLCJvblRhYmJlZE91dE9mIiwib25UYWJiYWJsZVJlbmRlciIsIm9uVGFiYmFibGVJbmRleENoYW5nZSIsInN0YWJsZU9uVGFiYmFibGVSZW5kZXIiLCJfZ2V0QW55Rm9jdXNlZCIsInNldEFueUZvY3VzZWQiLCJuZXdDb3VudCIsIm9sZENvdW50IiwiZ2V0VGFiYmFibGVJbmRleCIsInNldFRhYmJhYmxlSW5kZXgyIiwic2V0VGFiYmFibGVJbmRleCIsImZyb21Vc2VySW50ZXJhY3Rpb24iLCJwcmV2SW5kZXgiLCJuZXh0SW5kZXgiLCJjaGFuZ2VJbmRleCIsIm5leHRDaGlsZCIsInBhcmVudFJldHVyblR5cGUiLCJnZXRBdCIsInByZXZDaGlsZCIsImJsdXJTZWxmIiwiZm9jdXNTZWxmIiwidXNlTWFuYWdlZENoaWxkcmVuIiwidW5tb3VudGVkIiwicmVldmFsdWF0ZUNsb3Nlc3RGaXQiLCJjb3B5QXJyYXkiLCJzb3VyY2UiLCJhcnJheSIsIm5hdGl2ZUZsb29yIiwiZmxvb3IiLCJuYXRpdmVSYW5kb20iLCJyYW5kb20iLCJiYXNlUmFuZG9tIiwibG93ZXIiLCJ1cHBlciIsInNodWZmbGVTZWxmIiwibGFzdEluZGV4IiwicmFuZCIsImFycmF5U2h1ZmZsZSIsImFycmF5TWFwIiwiaXRlcmF0ZWUiLCJiYXNlVmFsdWVzIiwib2JqZWN0IiwiYmFzZVRpbWVzIiwiYXJnc1RhZyIsImJhc2VJc0FyZ3VtZW50cyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMiLCJzdHViRmFsc2UiLCJmcmVlRXhwb3J0cyIsImV4cG9ydHMiLCJmcmVlTW9kdWxlIiwibW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIkJ1ZmZlciIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJpc0luZGV4IiwidGVzdCIsImlzTGVuZ3RoIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJiYXNlSXNUeXBlZEFycmF5IiwiYmFzZVVuYXJ5IiwiZnVuYyIsImZyZWVQcm9jZXNzIiwicHJvY2VzcyIsIm5vZGVVdGlsIiwidHlwZXMiLCJyZXF1aXJlIiwiYmluZGluZyIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiU3RyaW5nIiwiaXNQcm90b3R5cGUiLCJDdG9yIiwiY29uc3RydWN0b3IiLCJwcm90byIsIm92ZXJBcmciLCJ0cmFuc2Zvcm0iLCJuYXRpdmVLZXlzIiwia2V5cyIsImJhc2VLZXlzIiwiYXN5bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImlzRnVuY3Rpb24iLCJpc0FycmF5TGlrZSIsImJhc2VTaHVmZmxlIiwiY29sbGVjdGlvbiIsInNodWZmbGUiLCJzZXRGb3JjZVVwZGF0ZSIsInJlYXJyYW5nZSIsInNvcnRlZFJvd3MiLCJpbmRleEFzU29ydGVkIiwiaW5kZXhBc1Vuc29ydGVkIiwibWFuZ2xlTWFwIiwiZGVtYW5nbGVNYXAiLCJ1c2VSZWFycmFuZ2VhYmxlUHJvcHMiLCJmb3JjZVVwZGF0ZSIsIl9wcmV2IiwibWFuZ2xlZEluZGV4IiwiaW5kZXhNYW5nbGVyIiwiZGVtYW5nbGVkSW5kZXgiLCJzb3J0IiwiaCIsInJlYXJyYW5nZWFibGVDaGlsZHJlbiIsImluZGV4RGVtYW5nbGVyIiwidXNlU29ydGFibGVDaGlsZHJlbiIsInNvcnRhYmxlQ2hpbGRyZW4iLCJ1c2VyQ29tcGFyZSIsImRlZmF1bHRDb21wYXJlIiwidXNlU29ydGFibGVQcm9wcyIsInJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGUiLCJ1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW4iLCJ1c2VMaXN0TmF2aWdhdGlvbiIsIm1jIiwibGlzdE5hdmlnYXRpb24iLCJpZGVudGl0eSIsInVzZVJvdmluZ1RhYkluZGV4Q2hpbGQiLCJ0cnlOYXZpZ2F0ZVRvSW5kZXgiLCJkZWZhdWx0Iiwic2VhcmNoRGlyZWN0aW9uIiwidXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkIiwiYyIsIm5hdmlnYXRlVG9JbmRleCIsInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMiLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkIiwiaGlkZGVuIiwidXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzIiwidGFiYmFibGUiLCJnZXRUYWJiYWJsZSIsInVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyIsInVzZUdyaWROYXZpZ2F0aW9uIiwicnRpIiwibHMiLCJsbiIsInRuIiwic2V0Q3VycmVudENvbHVtbiIsImdldEN1cnJlbnRDb2x1bW4iLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkQXNHcmlkUm93IiwidXNlTGlzdE5hdmlnYXRpb25Qcm9wc0FzR3JpZFBhcmVudCIsInVzZUdyaWROYXZpZ2F0aW9uUm93IiwiYXNDaGlsZFJvd09mU2VjdGlvbiIsImFzQ2hpbGQiLCJhc1BhcmVudFJvd09mQ2VsbHMiLCJhc1BhcmVudCIsImMyIiwidXNlUmFuZG9tSWQiLCJyYW5kb21JZCIsImJhY2t1cFJhbmRvbUlkIiwiZ2V0QmFja3VwUmFuZG9tSWQiLCJ1c2VkSWQiLCJzZXRVc2VkSWQiLCJnZXRVc2VkSWQiLCJtaXNtYXRjaEVycm9yUmVmIiwiZXhjbHVkZXMiLCJleGNsdWRlIiwib25DbGlja1N5bmMiLCJhY3RpdmUiLCJzZXRBY3RpdmUiLCJnZXRBY3RpdmUiLCJ0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lIiwic2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSIsInVzZUdsb2JhbEhhbmRsZXIiLCJwcmV2Iiwibm9kZVNlbGVjdGVkVGV4dExlbmd0aCIsIkRhdGUiLCJhIiwiY3VycmVudFRpbWUiLCJ0aW1lRGlmZmVyZW5jZSIsImNoYXJhY3RlcnNTZWxlY3RlZCIsImhhbmRsZVByZXNzIiwicHVsc2UiLCJvbk1vdXNlRG93biIsImRldGFpbCIsImJ1dHRvbiIsIm9uQWN0aXZlU3RhcnQiLCJvbk1vdXNlVXAiLCJvbkFjdGl2ZVN0b3AiLCJvbkJsdXIiLCJvbk1vdXNlTGVhdmUiLCJ1c2VBcmlhQWNjb3JkaW9uIiwiYWNjb3JkaW9uIiwiX2N1cnJlbnRGb2N1c2VkSW5kZXgiLCJzZXRDdXJyZW50Rm9jdXNlZEluZGV4IiwiZ2V0Q3VycmVudEZvY3VzZWRJbmRleCIsIm1jUmV0dXJuVHlwZSIsIm0iLCJ1Iiwib2NtYzIiLCJjaGFuZ2VUYWJiZWRJbmRleCIsImxpbmVhclJldHVyblR5cGUiLCJjaGFuZ2VFeHBhbmRlZEluZGV4IiwiZ2V0Q3VycmVudEluZGV4IiwiX2dldEN1cnJlbnRFeHBhbmRlZEluZGV4IiwidXNlQ2hpbGRyZW5GbGFnIiwiY2xvc2VzdEZpdCIsIl9nZXRUYWJiZWRJbmRleCIsIm9uSW5kZXhDaGFuZ2UiLCJkaXNhYmxlZCIsImFjY29yZGlvblNlY3Rpb24iLCJvcGVuIiwib3BlbkZyb21Vc2VyIiwib3BlbkZyb21QYXJlbnQiLCJzZXRPcGVuRnJvbVBhcmVudCIsInVzZVJhbmRvbUlkU291cmNlRWxlbWVudCIsInVzZUJvZHlBc1NvdXJjZUlkIiwidXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCIsInVzZUhlYWRlckFzUmVmZXJlbmNlcklkIiwiYm9keUlkIiwiZ2V0Qm9keUlkIiwidXNlSGVhZGVyQXNTb3VyY2VJZCIsInVzZUJvZHlBc1JlZmVyZW5jZXJJZCIsImhlYWRlcklkIiwiZ2V0SGVhZGVySWQiLCJ1c2VCb2R5QXNTb3VyY2VJZFByb3BzIiwidXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIiwidXNlQm9keUFzUmVmZXJlbmNlcklkUHJvcHMiLCJ1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyIsInVzZUhlYWRlckFzU291cmNlSWRQcm9wcyIsInVzZUhlYWRlckFzUmVmZXJlbmNlcklkUHJvcHMiLCJnZXRIZWFkZXJFbGVtZW50IiwidXNlSGVhZGVyUmVmRWxlbWVudFByb3BzIiwiZ2V0Qm9keUVsZW1lbnQiLCJ1c2VCb2R5UmVmRWxlbWVudFByb3BzIiwib3BlblJlZiIsImdldE9wZW5Gcm9tUGFyZW50IiwiYm9keUVsZW1lbnQiLCJpc1ZhbGlkIiwicmV0dXJuVHJ1ZSIsInRhYmJlZFJlZiIsInVzZUxhYmVsIiwibGFiZWwiLCJwcmVmaXhJbnB1dCIsInByZWZpeExhYmVsIiwidGFnSW5wdXQiLCJ0YWdMYWJlbCIsInVzZUxhYmVsQXNTb3VyY2VJZCIsInVzZUxhYmVsQXNSZWZlcmVuY2VySWQiLCJsYWJlbElkIiwiZ2V0TGFiZWxJZCIsInVzZUlucHV0QXNTb3VyY2VJZCIsInVzZUlucHV0QXNSZWZlcmVuY2VySWQiLCJpbnB1dElkIiwiZ2V0SW5wdXRJZCIsInVzZUxhYmVsQXNTb3VyY2VJZFByb3BzIiwidXNlSW5wdXRBc1NvdXJjZUlkUHJvcHMiLCJ1c2VMYWJlbEFzUmVmZXJlbmNlcklkUHJvcHMiLCJ1c2VJbnB1dEFzUmVmZXJlbmNlcklkUHJvcHMiLCJpc1N5bnRoZXRpY0xhYmVsIiwidXNlTGFiZWxMYWJlbCIsInVzZUxhYmVsTGFiZWxQcm9wcyIsInByb3BzV2l0aG91dEZvciIsInByb3BzV2l0aEZvciIsInVzZUxhYmVsSW5wdXQiLCJwcm9wc1dpdGhBcmlhTGFiZWxsZWRCeSIsInByb3BzV2l0aG91dEFyaWFMYWJlbGxlZEJ5IiwidXNlQXJpYUxpc3Rib3hTaW5nbGUiLCJsaXN0Ym94U2luZ2xlIiwidGFnTGlzdCIsIm9uU2VsZWN0IiwiX2xicyIsInNlbGVjdGVkSW5kZXgiLCJsYWJlbFJldHVyblR5cGUiLCJ1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkIiwidXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyIsImxpc3RSZXR1cm5UeXBlIiwidXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb24iLCJzZWxlY3Rpb25Nb2RlIiwiY3VycmVudFRhcmdldCIsIkV2ZW50RGV0YWlsIiwic2luZ2xlU2VsZWN0aW9uIiwic3MiLCJ1c2VMYWJlbElucHV0UHJvcHMiLCJzdGFibGVPblNlbGVjdCIsInVzZUFyaWFMaXN0Ym94TXVsdGkiLCJ1c2VBcmlhVG9vbHRpcCIsIm1vdXNlb3ZlckRlbGF5IiwibW91c2VvdXREZWxheSIsImZvY3VzRGVsYXkiLCJnZXRPcGVuIiwiZGVmYXVsdFByZXZlbnRlZCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInNldE9wZW4iLCJzZXRUcmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZCIsInNldFRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkIiwic2V0VHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCIsInNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJjYXB0dXJlIiwic2V0VHJpZ2dlckZvY3VzZWQiLCJmb2N1c2VkIiwiZGVsYXkiLCJpc0Zpbml0ZSIsImNsZWFyVGltZW91dCIsInJldHVybkZhbHNlIiwic2V0VG9vbHRpcEZvY3VzZWQiLCJzZXRUcmlnZ2VySG92ZXIiLCJob3ZlcmluZyIsInNldFRvb2x0aXBIb3ZlciIsInRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJ0cmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZCIsInRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJ0b29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZCIsInVzZVRvb2x0aXBUcmlnZ2VyIiwib25Ub3VjaEVuZCIsInVzZUhhc0ZvY3VzUHJvcHMiLCJ1c2VIYXNGb2N1cyIsIm9uRm9jdXNlZElubmVyQ2hhbmdlZCIsInVzZUFyaWFUYWJsZSIsInNldEN1cnJlbnRTb3J0Q29sdW1uIiwiYm9keVNvcnQiLCJ1c2VHcmlkTmF2aWdhdGlvblByb3BzIiwiZ3JpZE5hdlJldDEiLCJyb3dzIiwidXNlVGFibGVSb3ciLCJ0YWJsZVJvdyIsImxvY2F0aW9uIiwiY2VsbHMiLCJ1c2VHcmlkTmF2aWdhdGlvbkNlbGwiLCJ1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzIiwiZ2V0Q2VsbHMiLCJhc1BhcmVudE9mQ2VsbHMiLCJncmlkTmF2UmV0MiIsInVzZVRhYmxlQ2VsbCIsInVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzIiwiZ3JpZE5hdlJldDMiLCJzb3J0SW5mbyIsImdldEN1cnJlbnRTb3J0Q29sdW1uIiwiY2VsbEluZGV4IiwiTGlzdGJveE11bHRpQ29udGV4dCIsIkxpc3Rib3hNdWx0aVUiLCJyZW5kZXIiLCJMaXN0Ym94U2luZ2xlQ29udGV4dCIsIlNsaWRlclRodW1iQ29udGV4dCIsIkxvY2F0aW9uQ29udGV4dCIsIlRhYmxlQm9keUNvbnRleHQiLCJUYWJsZVJvd0NvbnRleHQiLCJUYWJsZUNlbGxDb250ZXh0IiwiZGVmYXVsdFJlbmRlclRhYmxlIiwidGFibGVQcm9wcyIsImRlZmF1bHRSZW5kZXJUYWJsZUJvZHkiLCJib2R5UHJvcHMiLCJkZWZhdWx0UmVuZGVyVGFibGVIZWFkIiwiaGVhZFByb3BzIiwiZGVmYXVsdFJlbmRlclRhYmxlRm9vdCIsImZvb3RQcm9wcyIsInJvd1Byb3BzIiwiZGVmYXVsdFJlbmRlclRhYmxlQ2VsbCIsImNlbGxQcm9wcyIsImRlZmF1bHRSZW5kZXIiLCJ0cmlnZ2VyUHJvcHMiLCJ0b29sdGlwUHJvcHMiLCJfRnJhZ21lbnQiLCJBY2NvcmRpb24uRGVtbyJdLCJtYXBwaW5ncyI6Ijs7O0FB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
