(function () {
	'use strict';

	var n,
	    l$1,
	    u$1,
	    t$1,
	    o$2,
	    r$1,
	    f$1,
	    e$2 = {},
	    c$1 = [],
	    s$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

	function a$1(n, l) {
	  for (var u in l) n[u] = l[u];

	  return n;
	}

	function h$1(n) {
	  var l = n.parentNode;
	  l && l.removeChild(n);
	}

	function v$1(l, u, i) {
	  var t,
	      o,
	      r,
	      f = {};

	  for (r in u) "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];

	  if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) void 0 === f[r] && (f[r] = l.defaultProps[r]);
	  return y$1(l, f, t, o, null);
	}

	function y$1(n, i, t, o, r) {
	  var f = {
	    type: n,
	    props: i,
	    key: t,
	    ref: o,
	    __k: null,
	    __: null,
	    __b: 0,
	    __e: null,
	    __d: void 0,
	    __c: null,
	    __h: null,
	    constructor: void 0,
	    __v: null == r ? ++u$1 : r
	  };
	  return null == r && null != l$1.vnode && l$1.vnode(f), f;
	}

	function d$1(n) {
	  return n.children;
	}

	function _(n, l) {
	  this.props = n, this.context = l;
	}

	function k$1(n, l) {
	  if (null == l) return n.__ ? k$1(n.__, n.__.__k.indexOf(n) + 1) : null;

	  for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;

	  return "function" == typeof n.type ? k$1(n) : null;
	}

	function b$1(n) {
	  var l, u;

	  if (null != (n = n.__) && null != n.__c) {
	    for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
	      n.__e = n.__c.base = u.__e;
	      break;
	    }

	    return b$1(n);
	  }
	}

	function m$1(n) {
	  (!n.__d && (n.__d = !0) && t$1.push(n) && !g$2.__r++ || r$1 !== l$1.debounceRendering) && ((r$1 = l$1.debounceRendering) || o$2)(g$2);
	}

	function g$2() {
	  for (var n; g$2.__r = t$1.length;) n = t$1.sort(function (n, l) {
	    return n.__v.__b - l.__v.__b;
	  }), t$1 = [], n.some(function (n) {
	    var l, u, i, t, o, r;
	    n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = a$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? k$1(t) : o, t.__h), z$2(u, t), t.__e != o && b$1(t)));
	  });
	}

	function w$2(n, l, u, i, t, o, r, f, s, a) {
	  var h,
	      v,
	      p,
	      _,
	      b,
	      m,
	      g,
	      w = i && i.__k || c$1,
	      A = w.length;

	  for (u.__k = [], h = 0; h < l.length; h++) if (null != (_ = u.__k[h] = null == (_ = l[h]) || "boolean" == typeof _ ? null : "string" == typeof _ || "number" == typeof _ || "bigint" == typeof _ ? y$1(null, _, null, null, _) : Array.isArray(_) ? y$1(d$1, {
	    children: _
	  }, null, null, null) : _.__b > 0 ? y$1(_.type, _.props, _.key, null, _.__v) : _)) {
	    if (_.__ = u, _.__b = u.__b + 1, null === (p = w[h]) || p && _.key == p.key && _.type === p.type) w[h] = void 0;else for (v = 0; v < A; v++) {
	      if ((p = w[v]) && _.key == p.key && _.type === p.type) {
	        w[v] = void 0;
	        break;
	      }

	      p = null;
	    }
	    j$2(n, _, p = p || e$2, t, o, r, f, s, a), b = _.__e, (v = _.ref) && p.ref != v && (g || (g = []), p.ref && g.push(p.ref, null, _), g.push(v, _.__c || b, _)), null != b ? (null == m && (m = b), "function" == typeof _.type && _.__k === p.__k ? _.__d = s = x(_, s, n) : s = P$1(n, _, p, w, b, s), "function" == typeof u.type && (u.__d = s)) : s && p.__e == s && s.parentNode != n && (s = k$1(p));
	  }

	  for (u.__e = m, h = A; h--;) null != w[h] && ("function" == typeof u.type && null != w[h].__e && w[h].__e == u.__d && (u.__d = k$1(i, h + 1)), N(w[h], w[h]));

	  if (g) for (h = 0; h < g.length; h++) M$2(g[h], g[++h], g[++h]);
	}

	function x(n, l, u) {
	  for (var i, t = n.__k, o = 0; t && o < t.length; o++) (i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? x(i, l, u) : P$1(u, i, i, t, i.__e, l));

	  return l;
	}

	function A$2(n, l) {
	  return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
	    A$2(n, l);
	  }) : l.push(n)), l;
	}

	function P$1(n, l, u, i, t, o) {
	  var r, f, e;
	  if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
	    for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) if (f == t) break n;

	    n.insertBefore(t, o), r = o;
	  }
	  return void 0 !== r ? r : t.nextSibling;
	}

	function C$1(n, l, u, i, t) {
	  var o;

	  for (o in u) "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);

	  for (o in l) t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
	}

	function $(n, l, u) {
	  "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || s$1.test(l) ? u : u + "px";
	}

	function H$1(n, l, u, i, t) {
	  var o;

	  n: if ("style" === l) {
	    if ("string" == typeof u) n.style.cssText = u;else {
	      if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || $(n.style, l, "");
	      if (u) for (l in u) i && u[l] === i[l] || $(n.style, l, u[l]);
	    }
	  } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$2 : I, o) : n.removeEventListener(l, o ? T$2 : I, o);else if ("dangerouslySetInnerHTML" !== l) {
	    if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
	      n[l] = null == u ? "" : u;
	      break n;
	    } catch (n) {}
	    "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
	  }
	}

	function I(n) {
	  this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
	}

	function T$2(n) {
	  this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
	}

	function j$2(n, u, i, t, o, r, f, e, c) {
	  var s,
	      h,
	      v,
	      y,
	      p,
	      k,
	      b,
	      m,
	      g,
	      x,
	      A,
	      P,
	      C,
	      $ = u.type;
	  if (void 0 !== u.constructor) return null;
	  null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (s = l$1.__b) && s(u);

	  try {
	    n: if ("function" == typeof $) {
	      if (m = u.props, g = (s = $.contextType) && t[s.__c], x = s ? g ? g.props.value : s.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in $ && $.prototype.render ? u.__c = h = new $(m, x) : (u.__c = h = new _(m, x), h.constructor = $, h.render = O$1), g && g.sub(h), h.props = m, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != $.getDerivedStateFromProps && (h.__s == h.state && (h.__s = a$1({}, h.__s)), a$1(h.__s, $.getDerivedStateFromProps(m, h.__s))), y = h.props, p = h.state, v) null == $.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
	        if (null == $.getDerivedStateFromProps && m !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(m, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(m, h.__s, x) || u.__v === i.__v) {
	          h.props = m, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
	            n && (n.__ = u);
	          }), h.__h.length && f.push(h);
	          break n;
	        }

	        null != h.componentWillUpdate && h.componentWillUpdate(m, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
	          h.componentDidUpdate(y, p, k);
	        });
	      }
	      if (h.context = x, h.props = m, h.__v = u, h.__P = n, A = l$1.__r, P = 0, "prototype" in $ && $.prototype.render) h.state = h.__s, h.__d = !1, A && A(u), s = h.render(h.props, h.state, h.context);else do {
	        h.__d = !1, A && A(u), s = h.render(h.props, h.state, h.context), h.state = h.__s;
	      } while (h.__d && ++P < 25);
	      h.state = h.__s, null != h.getChildContext && (t = a$1(a$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, p)), C = null != s && s.type === d$1 && null == s.key ? s.props.children : s, w$2(n, Array.isArray(C) ? C : [C], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
	    } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);

	    (s = l$1.diffed) && s(u);
	  } catch (n) {
	    u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
	  }
	}

	function z$2(n, u) {
	  l$1.__c && l$1.__c(u, n), n.some(function (u) {
	    try {
	      n = u.__h, u.__h = [], n.some(function (n) {
	        n.call(u);
	      });
	    } catch (n) {
	      l$1.__e(n, u.__v);
	    }
	  });
	}

	function L$1(l, u, i, t, o, r, f, c) {
	  var s,
	      a,
	      v,
	      y = i.props,
	      p = u.props,
	      d = u.type,
	      _ = 0;
	  if ("svg" === d && (o = !0), null != r) for (; _ < r.length; _++) if ((s = r[_]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
	    l = s, r[_] = null;
	    break;
	  }

	  if (null == l) {
	    if (null === d) return document.createTextNode(p);
	    l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
	  }

	  if (null === d) y === p || c && l.data === p || (l.data = p);else {
	    if (r = r && n.call(l.childNodes), a = (y = i.props || e$2).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
	      if (null != r) for (y = {}, _ = 0; _ < l.attributes.length; _++) y[l.attributes[_].name] = l.attributes[_].value;
	      (v || a) && (v && (a && v.__html == a.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
	    }

	    if (C$1(l, p, y, o, c), v) u.__k = [];else if (_ = u.props.children, w$2(l, Array.isArray(_) ? _ : [_], u, i, t, o && "foreignObject" !== d, r, f, r ? r[0] : i.__k && k$1(i, 0), c), null != r) for (_ = r.length; _--;) null != r[_] && h$1(r[_]);
	    c || ("value" in p && void 0 !== (_ = p.value) && (_ !== l.value || "progress" === d && !_ || "option" === d && _ !== y.value) && H$1(l, "value", _, y.value, !1), "checked" in p && void 0 !== (_ = p.checked) && _ !== l.checked && H$1(l, "checked", _, y.checked, !1));
	  }
	  return l;
	}

	function M$2(n, u, i) {
	  try {
	    "function" == typeof n ? n(u) : n.current = u;
	  } catch (n) {
	    l$1.__e(n, i);
	  }
	}

	function N(n, u, i) {
	  var t, o;

	  if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$2(t, null, u)), null != (t = n.__c)) {
	    if (t.componentWillUnmount) try {
	      t.componentWillUnmount();
	    } catch (n) {
	      l$1.__e(n, u);
	    }
	    t.base = t.__P = null;
	  }

	  if (t = n.__k) for (o = 0; o < t.length; o++) t[o] && N(t[o], u, "function" != typeof n.type);
	  i || null == n.__e || h$1(n.__e), n.__e = n.__d = void 0;
	}

	function O$1(n, l, u) {
	  return this.constructor(n, u);
	}

	function S$1(u, i, t) {
	  var o, r, f;
	  l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, f = [], j$2(i, u = (!o && t || i).__k = v$1(d$1, null, [u]), r || e$2, e$2, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, f, !o && t ? t : r ? r.__e : i.firstChild, o), z$2(f, u);
	}

	function D(n, l) {
	  var u = {
	    __c: l = "__cC" + f$1++,
	    __: n,
	    Consumer: function (n, l) {
	      return n.children(l);
	    },
	    Provider: function (n) {
	      var u, i;
	      return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
	        return i;
	      }, this.shouldComponentUpdate = function (n) {
	        this.props.value !== n.value && u.some(m$1);
	      }, this.sub = function (n) {
	        u.push(n);
	        var l = n.componentWillUnmount;

	        n.componentWillUnmount = function () {
	          u.splice(u.indexOf(n), 1), l && l.call(n);
	        };
	      }), n.children;
	    }
	  };
	  return u.Provider.__ = u.Consumer.contextType = u;
	}

	n = c$1.slice, l$1 = {
	  __e: function (n, l, u, i) {
	    for (var t, o, r; l = l.__;) if ((t = l.__c) && !t.__) try {
	      if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), r) return t.__E = t;
	    } catch (l) {
	      n = l;
	    }

	    throw n;
	  }
	}, u$1 = 0, _.prototype.setState = function (n, l) {
	  var u;
	  u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = a$1({}, this.state), "function" == typeof n && (n = n(a$1({}, u), this.props)), n && a$1(u, n), null != n && this.__v && (l && this.__h.push(l), m$1(this));
	}, _.prototype.forceUpdate = function (n) {
	  this.__v && (this.__e = !0, n && this.__h.push(n), m$1(this));
	}, _.prototype.render = d$1, t$1 = [], o$2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, g$2.__r = 0, f$1 = 0;

	var o$1 = 0;

	function e$1(_, e, n, t, f) {
	  var l,
	      s,
	      u = {};

	  for (s in e) "ref" == s ? l = e[s] : u[s] = e[s];

	  var a = {
	    type: _,
	    props: u,
	    key: n,
	    ref: l,
	    __k: null,
	    __: null,
	    __b: 0,
	    __e: null,
	    __d: void 0,
	    __c: null,
	    __h: null,
	    constructor: void 0,
	    __v: --o$1,
	    __source: f,
	    __self: t
	  };
	  if ("function" == typeof _ && (l = _.defaultProps)) for (s in l) void 0 === u[s] && (u[s] = l[s]);
	  return l$1.vnode && l$1.vnode(a), a;
	}

	var t,
	    u,
	    r,
	    o,
	    i = 0,
	    c = [],
	    f = l$1.__b,
	    e = l$1.__r,
	    a = l$1.diffed,
	    v = l$1.__c,
	    l = l$1.unmount;

	function m(t, r) {
	  l$1.__h && l$1.__h(u, t, i || r), i = 0;
	  var o = u.__H || (u.__H = {
	    __: [],
	    __h: []
	  });
	  return t >= o.__.length && o.__.push({}), o.__[t];
	}

	function d(n) {
	  return i = 1, p(z$1, n);
	}

	function p(n, r, o) {
	  var i = m(t++, 2);
	  return i.t = n, i.__c || (i.__ = [o ? o(r) : z$1(void 0, r), function (n) {
	    var t = i.t(i.__[0], n);
	    i.__[0] !== t && (i.__ = [t, i.__[1]], i.__c.setState({}));
	  }], i.__c = u), i.__;
	}

	function y(r, o) {
	  var i = m(t++, 3);
	  !l$1.__s && w$1(i.__H, o) && (i.__ = r, i.u = o, u.__H.__h.push(i));
	}

	function h(r, o) {
	  var i = m(t++, 4);
	  !l$1.__s && w$1(i.__H, o) && (i.__ = r, i.u = o, u.__h.push(i));
	}

	function s(n) {
	  return i = 5, A$1(function () {
	    return {
	      current: n
	    };
	  }, []);
	}

	function A$1(n, u) {
	  var r = m(t++, 7);
	  return w$1(r.__H, u) ? (r.o = n(), r.u = u, r.__h = n, r.o) : r.__;
	}

	function F(n, t) {
	  return i = 8, A$1(function () {
	    return n;
	  }, t);
	}

	function T$1(n) {
	  var r = u.context[n.__c],
	      o = m(t++, 9);
	  return o.c = n, r ? (null == o.__ && (o.__ = !0, r.sub(u)), r.props.value) : n.__;
	}

	function b() {
	  for (var t; t = c.shift();) if (t.__P) try {
	    t.__H.__h.forEach(j$1), t.__H.__h.forEach(k), t.__H.__h = [];
	  } catch (u) {
	    t.__H.__h = [], l$1.__e(u, t.__v);
	  }
	}

	l$1.__b = function (n) {
	  u = null, f && f(n);
	}, l$1.__r = function (n) {
	  e && e(n), t = 0;
	  var o = (u = n.__c).__H;
	  o && (r === u ? (o.__h = [], u.__h = [], o.__.forEach(function (n) {
	    n.o = n.u = void 0;
	  })) : (o.__.forEach(function (n) {
	    n.u && (n.__H = n.u), n.o && (n.__ = n.o), n.o = n.u = void 0;
	  }), o.__h.forEach(j$1), o.__h.forEach(k), o.__h = [])), r = u;
	}, l$1.diffed = function (t) {
	  a && a(t);
	  var i = t.__c;
	  i && i.__H && i.__H.__h.length && (1 !== c.push(i) && o === l$1.requestAnimationFrame || ((o = l$1.requestAnimationFrame) || function (n) {
	    var t,
	        u = function () {
	      clearTimeout(r), g$1 && cancelAnimationFrame(t), setTimeout(n);
	    },
	        r = setTimeout(u, 100);

	    g$1 && (t = requestAnimationFrame(u));
	  })(b)), u = null, r = null;
	}, l$1.__c = function (t, u) {
	  u.some(function (t) {
	    try {
	      t.__H && t.__H.__.forEach(function (n) {
	        n.u && (n.__H = n.u), n.o && (n.__ = n.o), n.o = n.u = void 0;
	      }), t.__h.forEach(j$1), t.__h = t.__h.filter(function (n) {
	        return !n.__ || k(n);
	      });
	    } catch (r) {
	      u.some(function (n) {
	        n.__h && (n.__h = []);
	      }), u = [], l$1.__e(r, t.__v);
	    }
	  }), v && v(t, u);
	}, l$1.unmount = function (t) {
	  l && l(t);
	  var u,
	      r = t.__c;
	  r && r.__H && (r.__H.__.forEach(function (n) {
	    try {
	      j$1(n);
	    } catch (n) {
	      u = n;
	    }
	  }), u && l$1.__e(u, r.__v));
	};
	var g$1 = "function" == typeof requestAnimationFrame;

	function j$1(n) {
	  var t = u,
	      r = n.__c;
	  "function" == typeof r && (n.__c = void 0, r()), u = t;
	}

	function k(n) {
	  var t = u;
	  n.__c = n.__(), u = t;
	}

	function w$1(n, t) {
	  return !n || n.length !== t.length || t.some(function (t, u) {
	    return t !== n[u];
	  });
	}

	function z$1(n, t) {
	  return "function" == typeof t ? t(n) : t;
	}

	function toVal(mix) {
	  var k,
	      y,
	      str = '';

	  if (typeof mix === 'string' || typeof mix === 'number') {
	    str += mix;
	  } else if (typeof mix === 'object') {
	    if (Array.isArray(mix)) {
	      for (k = 0; k < mix.length; k++) {
	        if (mix[k]) {
	          if (y = toVal(mix[k])) {
	            str && (str += ' ');
	            str += y;
	          }
	        }
	      }
	    } else {
	      for (k in mix) {
	        if (mix[k]) {
	          str && (str += ' ');
	          str += k;
	        }
	      }
	    }
	  }

	  return str;
	}

	function clsx () {
	  var i = 0,
	      tmp,
	      x,
	      str = '';

	  while (i < arguments.length) {
	    if (tmp = arguments[i++]) {
	      if (x = toVal(tmp)) {
	        str && (str += ' ');
	        str += x;
	      }
	    }
	  }

	  return str;
	}

	function getDocument(element) {
	  var _ref, _ref2, _element$ownerDocumen;

	  return (_ref = (_ref2 = (_element$ownerDocumen = element === null || element === void 0 ? void 0 : element.ownerDocument) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : document) !== null && _ref2 !== void 0 ? _ref2 : window.document) !== null && _ref !== void 0 ? _ref : globalThis.document;
	}

	/**
	 * Debug hook.
	 *
	 * Given a value or set of values, emits a console error if any of them change from one render to the next.
	 *
	 * Eventually, when useEvent lands, we hopefully won't need this.
	 */

	function useEnsureStability(parentHookName) {
	  for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    values[_key - 1] = arguments[_key];
	  }

	  useHelper(values.length, 0);
	  values.forEach(useHelper);
	  return;

	  function useHelper(value, index) {
	    // Make sure that the provided functions are perfectly stable across renders
	    const helperToEnsureStability = s(value);
	    const shownError = s(false);

	    if (helperToEnsureStability.current != value) {
	      if (!shownError.current) {
	        /* eslint-disable no-debugger */
	        debugger;
	        console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
	        shownError.current = true;
	      }
	    }
	  }
	}
	/**
	 * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
	 *
	 * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
	 *
	 * To summarize, it's like a `useState`-`useEffect` mashup:
	 *
	 * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
	 * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
	 * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
	 * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
	 *
	 * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
	 *
	 * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
	 * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
	 * @returns
	 */

	function usePassiveState(onChange, getInitialValue) {
	  const valueRef = s(Unset$1);
	  const warningRef = s(false);
	  const cleanupCallbackRef = s(undefined); // Make sure that the provided functions are perfectly stable across renders

	  useEnsureStability("usePassiveState", onChange, getInitialValue); // Shared between "dependency changed" and "component unmounted".

	  const onShouldCleanUp = F(() => {
	    const cleanupCallback = cleanupCallbackRef.current;
	    if (cleanupCallback) cleanupCallback();
	  }, []); // There are a couple places where we'd like to use our initial
	  // value in place of having no value at all yet.
	  // This is the shared code for that, used on mount and whenever
	  // getValue is called.

	  const tryEnsureValue = F(() => {
	    if (valueRef.current === Unset$1 && getInitialValue != undefined) {
	      try {
	        var _onChange;

	        const initialValue = getInitialValue();
	        valueRef.current = initialValue;
	        cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
	      } catch (ex) {// Exceptions are intentional to allow bailout (without exposing the Unset symbol)
	      }
	    }
	  }, [
	    /* getInitialValue and onChange intentionally omitted */
	  ]);
	  const getValue = F(() => {
	    if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component."); // The first time we call getValue, if we haven't been given a value yet,
	    // (and we were given an initial value to use)
	    // return the initial value instead of nothing.

	    if (valueRef.current === Unset$1) tryEnsureValue();
	    return valueRef.current === Unset$1 ? undefined : valueRef.current;
	  }, []);
	  h(() => {
	    // Make sure we've run our effect at least once on mount.
	    // (If we have an initial value, of course)
	    tryEnsureValue();
	  }, []); // The actual code the user calls to (possibly) run a new effect.

	  const setValue = F(arg => {
	    const prevDep = valueRef.current === Unset$1 ? undefined : getValue();
	    const dep = arg instanceof Function ? arg(prevDep) : arg;

	    if (dep !== valueRef.current) {
	      var _onChange2;

	      // Indicate to the user that they shouldn't call getValue during onChange
	      warningRef.current = true; // Call any registerd cleanup function

	      onShouldCleanUp();
	      cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(dep, prevDep)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
	      valueRef.current = dep; // Allow the user to normally call getValue again

	      warningRef.current = false;
	    }
	  }, []);
	  return [getValue, setValue];
	}
	const Unset$1 = Symbol(); // Easy constants for getInitialValue

	function returnTrue() {
	  return true;
	}
	function returnFalse$1() {
	  return false;
	}
	function returnNull$1() {
	  return null;
	}

	function useMergedChildren(lhsProps, rhsProps) {
	  const lhs = lhsProps === null || lhsProps === void 0 ? void 0 : lhsProps.children;
	  const rhs = rhsProps === null || rhsProps === void 0 ? void 0 : rhsProps.children;

	  if (lhs == null && rhs == null) {
	    return undefined;
	  } else if (lhs == null) {
	    return rhs;
	  } else if (rhs == null) {
	    return lhs;
	  } else {
	    const ret = v$1(d$1, {}, lhs, rhs);
	    return ret;
	  }
	}

	/**
	 * Given two sets of props, merges their `class` and `className` properties.
	 * Duplicate classes are removed (order doesn't matter anyway).
	 *
	 * @param lhs Classes of the first component
	 * @param rhs Classes of the second component
	 * @returns A string representing all combined classes from both arguments.
	 */

	function useMergedClasses(lhs, rhs) {
	  // Note: For the sake of forward compatibility, this function is labelled as
	  // a hook, but as it uses no other hooks it technically isn't one.
	  return mergeClasses(lhs, rhs);
	}

	function mergeClasses(lhs, rhs) {
	  const lhsClass = lhs === null || lhs === void 0 ? void 0 : lhs.class;
	  const lhsClassName = lhs === null || lhs === void 0 ? void 0 : lhs.className;
	  const rhsClass = rhs === null || rhs === void 0 ? void 0 : rhs.class;
	  const rhsClassName = rhs === null || rhs === void 0 ? void 0 : rhs.className;

	  if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
	    const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
	    const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
	    const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
	    return Array.from(allClasses).join(" ");
	  } else {
	    return undefined;
	  }
	}

	function processRef(instance, ref) {
	  if (typeof ref === "function") {
	    ref(instance);
	  } else if (ref != null) {
	    ref.current = instance;
	  } else {
	    /* eslint-disable no-debugger */
	    debugger;
	    console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
	  }
	}
	/**
	 * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
	 * @param lhs
	 * @param rhs
	 * @returns
	 */


	function useMergedRefs() {
	  return function (lhsProps, rhsProps) {
	    const lhs = lhsProps === null || lhsProps === void 0 ? void 0 : lhsProps.ref;
	    const rhs = rhsProps === null || rhsProps === void 0 ? void 0 : rhsProps.ref;
	    const combined = F(current => {
	      processRef(current, lhs);
	      processRef(current, rhs);
	    }, [lhs, rhs]);

	    if (lhs == null && rhs == null) {
	      return undefined;
	    } else if (lhs == null) {
	      return rhs;
	    } else if (rhs == null) {
	      return lhs;
	    } else {
	      return combined;
	    }
	  };
	}

	function styleStringToObject(style) {
	  // TODO: This sucks D:
	  return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
	}
	/**
	 * Merges two style objects, returning the result.
	 *
	 * @param style The user-given style prop for this component
	 * @param obj The CSS properties you want added to the user-given style
	 * @returns A CSS object containing the properties of both objects.
	 */


	function useMergedStyles(lhs, rhs) {
	  var _lhs$style, _rhs$style2;

	  // Easy case, when there are no styles to merge return nothing.
	  if (!(lhs !== null && lhs !== void 0 && lhs.style) && !(rhs !== null && rhs !== void 0 && rhs.style)) return undefined;

	  if (typeof lhs != typeof rhs) {
	    // Easy cases, when one is null and the other isn't.
	    if (lhs !== null && lhs !== void 0 && lhs.style && !(rhs !== null && rhs !== void 0 && rhs.style)) return lhs.style;
	    if (!(lhs !== null && lhs !== void 0 && lhs.style) && rhs !== null && rhs !== void 0 && rhs.style) return rhs.style; // They're both non-null but different types.
	    // Convert the string type to an object bag type and run it again.

	    if (lhs !== null && lhs !== void 0 && lhs.style && rhs !== null && rhs !== void 0 && rhs.style) {
	      // (useMergedStyles isn't a true hook -- this isn't a violation)
	      if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") return useMergedStyles({
	        style: styleStringToObject(lhs === null || lhs === void 0 ? void 0 : lhs.style)
	      }, rhs);
	      if (typeof (rhs === null || rhs === void 0 ? void 0 : rhs.style) == "string") return useMergedStyles(lhs, {
	        style: styleStringToObject(rhs === null || rhs === void 0 ? void 0 : rhs.style)
	      });
	    } // Logic???


	    return undefined;
	  } // They're both strings, just concatenate them.


	  if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") {
	    var _rhs$style;

	    return `${lhs.style};${(_rhs$style = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style !== void 0 ? _rhs$style : ""}`;
	  } // They're both objects, just merge them.


	  return { ...((_lhs$style = lhs === null || lhs === void 0 ? void 0 : lhs.style) !== null && _lhs$style !== void 0 ? _lhs$style : {}),
	    ...((_rhs$style2 = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style2 !== void 0 ? _rhs$style2 : {})
	  };
	}

	let log = console.warn;
	/**
	 * Given two sets of props, merges them and returns the result.
	 *
	 * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
	 * @param lhs2
	 * @param rhs2
	 * @returns
	 */

	function useMergedProps() {
	  return function (lhsAll, rhsAll) {
	    // First, separate the props we were given into two groups:
	    // lhsAll and rhsAll contain all the props we were given, and
	    // lhsMisc and rhsMisc contain all props *except* for the easy ones
	    // like className and style that we already know how to merge.
	    const {
	      children: _lhsChildren,
	      class: _lhsClass,
	      className: _lhsClassName,
	      style: _lhsStyle,
	      ref: _lhsRef,
	      ...lhsMisc
	    } = lhsAll;
	    const {
	      children: _rhsChildren,
	      class: _rhsClass,
	      className: _rhsClassName,
	      style: _rhsStyle,
	      ref: _rhsRef,
	      ...rhsMisc
	    } = rhsAll;
	    const ret = { ...lhsMisc,
	      ref: useMergedRefs()(lhsAll, rhsAll),
	      style: useMergedStyles(lhsAll, rhsAll),
	      className: useMergedClasses(lhsAll, rhsAll),
	      children: useMergedChildren(lhsAll, rhsAll)
	    };
	    if (ret.ref === undefined) delete ret.ref;
	    if (ret.style === undefined) delete ret.style;
	    if (ret.className === undefined) delete ret.className;
	    if (ret.children === undefined) delete ret.children; // Now, do *everything* else
	    // Merge every remaining existing entry in lhs with what we've already put in ret.
	    //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];

	    const rhsEntries = Object.entries(rhsMisc);

	    for (const [rhsKey, rhsValue] of rhsEntries) {
	      const lhsValue = lhsMisc[rhsKey];

	      if (typeof lhsValue === "function" || typeof rhsValue === "function") {
	        // They're both functions that can be merged (or one's a function and the other's null).
	        // Not an *easy* case, but a well-defined one.
	        const merged = mergeFunctions(lhsValue, rhsValue);
	        ret[rhsKey] = merged;
	      } else {
	        // Uh...we're here because one of them's null, right?
	        if (lhsValue == null && rhsValue == null) {
	          if (rhsValue === null && lhsValue === undefined) ret[rhsKey] = rhsValue;else ret[rhsKey] = lhsValue;
	        }

	        if (lhsValue == null) ret[rhsKey] = rhsValue;else if (rhsValue == null) ret[rhsKey] = lhsValue;else if (rhsValue == lhsValue) ; else {
	          var _log;

	          // Ugh.
	          // No good strategies here, just log it if requested
	          (_log = log) === null || _log === void 0 ? void 0 : _log(`The prop "${typeof rhsKey == "symbol" ? "<symbol>" : rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
	          ret[rhsKey] = rhsValue;
	        }
	      }
	    }

	    return ret;
	  };
	}

	function mergeFunctions(lhs, rhs) {
	  if (!lhs) return rhs;
	  if (!rhs) return lhs;
	  return function () {
	    const lv = lhs(...arguments);
	    const rv = rhs(...arguments);
	    if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
	  };
	}
	/*
	function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

	    const id0: GenericGet<{}, "id", string> = "";
	    const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
	    const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
	    const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
	    const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
	    //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
	    const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

	    type M1 = GenericGet<P, "style", string>;
	    type M2 = GenericGet<{}, "style", string>;
	    const m1: M1 = "";
	    const m2: M1 = undefined;
	    /// @ts-expect-error    Because number isn't assignable to string
	    const m3: M1 = 0;

	    const m4: M2 = "";
	    const m5: M2 = undefined;
	    /// @ts-expect-error    Because number isn't assignable to string
	    const m6: M2 = 0;

	    const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
	    const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
	    const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
	    const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
	    const p5 = useMergedProps<HTMLInputElement>()(props, {});
	    const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
	    const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


	    p1.id?.concat("");
	    p2.id?.concat("");
	    /// @ts-expect-error    id can't be anything but undefined
	    p3.id?.concat("");
	    /// @ts-expect-error    id can't be anything but undefined
	    p4.id?.concat("");


	    p5.id?.concat("");
	    p6.id?.concat("");
	    p7.id?.concat("");

	    /// @ts-expect-error    id must contain undefined
	    p5.id.concat("");
	    /// @ts-expect-error    id must contain undefined
	    p6.id.concat("");
	    /// @ts-expect-error    id must contain undefined
	    p7.id.concat("");


	    if (p5.allowFullScreen === undefined) {}
	    else if (p5.allowFullScreen === false) {}
	    else if (p5.allowFullScreen === true) {}
	    else {
	        acceptsNever(p5.allowFullScreen);
	    }


	    if (p6.allowFullScreen === undefined) {}
	    else if (p6.allowFullScreen === false) {}
	    else if (p6.allowFullScreen === true) {}
	    else {
	        acceptsNever(p6.allowFullScreen);
	    }


	    if (p7.allowFullScreen === undefined) {}
	    else if (p7.allowFullScreen === false) {}
	    else if (p7.allowFullScreen === true) {}
	    else {
	        acceptsNever(p7.allowFullScreen);
	    }


	    // Make sure it works recursively
	    const r1a = useMergedProps<HTMLInputElement>()({}, p1);
	    const r1b = useMergedProps<HTMLInputElement>()(props, p1);
	    const r2a = useMergedProps<HTMLInputElement>()({}, p2);
	    const r2b = useMergedProps<HTMLInputElement>()(props, p2);
	    const r3a = useMergedProps<HTMLInputElement>()({}, p3);
	    const r3b = useMergedProps<HTMLInputElement>()(props, p3);
	    const r4a = useMergedProps<HTMLInputElement>()({}, p4);
	    const r4b = useMergedProps<HTMLInputElement>()(props, p4);
	    const r5a = useMergedProps<HTMLInputElement>()({}, p5);
	    const r5b = useMergedProps<HTMLInputElement>()(props, p5);
	    const r6a = useMergedProps<HTMLInputElement>()({}, p6);
	    const r6b = useMergedProps<HTMLInputElement>()(props, p6);
	    const r7a = useMergedProps<HTMLInputElement>()({}, p7);
	    const r7b = useMergedProps<HTMLInputElement>()(props, p7);


	    r1a.id?.concat("");
	    r1b.id?.concat("");
	    r2a.id?.concat("");
	    r2b.id?.concat("");
	    // @ts-expect-error    id can't be anything but undefined
	    r3a.id?.concat("");
	    r3b.id?.concat("");
	    /// @ts-expect-error    id can't be anything but undefined
	    r4a.id?.concat("");
	    r4b.id?.concat("");


	    r5a.id?.concat("");
	    r5b.id?.concat("");
	    r6a.id?.concat("");
	    r6b.id?.concat("");
	    r7a.id?.concat("");
	    r7b.id?.concat("");

	    /// @ts-expect-error    id must contain undefined
	    r5a.id.concat("");
	    /// @ts-expect-error    id must contain undefined
	    r5b.id.concat("");
	    /// @ts-expect-error    id must contain undefined
	    r6a.id.concat("");
	    /// @ts-expect-error    id must contain undefined
	    r6b.id.concat("");
	    /// @ts-expect-error    id must contain undefined
	    r7a.id.concat("");
	    /// @ts-expect-error    id must contain undefined
	    r7b.id.concat("");


	    if (r5a.allowFullScreen === undefined) {}
	    else if (r5a.allowFullScreen === false) {}
	    else if (r5a.allowFullScreen === true) {}
	    else {
	        acceptsNever(r5a.allowFullScreen);
	    }


	    if (r5b.allowFullScreen === undefined) {}
	    else if (r5b.allowFullScreen === false) {}
	    else if (r5b.allowFullScreen === true) {}
	    else {
	        acceptsNever(r5b.allowFullScreen);
	    }


	    if (r6a.allowFullScreen === undefined) {}
	    else if (r6a.allowFullScreen === false) {}
	    else if (r6a.allowFullScreen === true) {}
	    else {
	        acceptsNever(r6a.allowFullScreen);
	    }


	    if (r6b.allowFullScreen === undefined) {}
	    else if (r6b.allowFullScreen === false) {}
	    else if (r6b.allowFullScreen === true) {}
	    else {
	        acceptsNever(r6b.allowFullScreen);
	    }


	    if (r7a.allowFullScreen === undefined) {}
	    else if (r7a.allowFullScreen === false) {}
	    else if (r7a.allowFullScreen === true) {}
	    else {
	        acceptsNever(r7a.allowFullScreen);
	    }


	    if (r7b.allowFullScreen === undefined) {}
	    else if (r7b.allowFullScreen === false) {}
	    else if (r7b.allowFullScreen === true) {}
	    else {
	        acceptsNever(r7b.allowFullScreen);
	    }

	}
	function acceptsNever(n: never) {}
	*/

	function returnNull() {
	  return null;
	}
	/**
	 * Allows accessing the element a ref references as soon as it does so.
	 * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
	 * adding a RefCallback and merging it with any existing ref that existed on the props.
	 *
	 * Don't forget to provide the Element as the type argument!
	 *
	 * @returns The element, and the sub-hook that makes it retrievable.
	 */


	function useRefElement(args) {
	  const {
	    onElementChange,
	    onMount,
	    onUnmount
	  } = args !== null && args !== void 0 ? args : {};
	  useEnsureStability("useRefElement", onElementChange, onMount, onUnmount); // Called (indirectly) by the ref that the element receives.

	  const handler = F((e, prevValue) => {
	    onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
	    if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
	    if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
	  }, []); // Let us store the actual (reference to) the element we capture

	  const [getElement, setElement] = usePassiveState(handler, returnNull); // Create a RefCallback that's fired when mounted 
	  // and that notifies us of our element when we have it

	  const myRef = F(e => {
	    if (e) setElement(() => e);
	  }, []);
	  const useRefElementProps = F(props => useMergedProps()({
	    ref: myRef
	  }, props), []); // Return both the element and the hook that modifies 
	  // the props and allows us to actually find the element

	  return {
	    useRefElementProps,
	    getElement
	  };
	}

	function useElementSize(_ref) {
	  let {
	    getObserveBox,
	    onSizeChange
	  } = _ref;
	  useEnsureStability("useElementSize", getObserveBox, onSizeChange);
	  const [getSize, setSize] = usePassiveState(onSizeChange, returnNull$1);
	  const currentObserveBox = s(undefined);
	  const needANewObserver = F((element, observeBox) => {
	    if (element) {
	      const document = getDocument(element);
	      const window = document.defaultView;

	      const handleUpdate = () => {
	        if (element.isConnected) {
	          const {
	            clientWidth,
	            scrollWidth,
	            offsetWidth,
	            clientHeight,
	            scrollHeight,
	            offsetHeight,
	            clientLeft,
	            scrollLeft,
	            offsetLeft,
	            clientTop,
	            scrollTop,
	            offsetTop
	          } = element;
	          setSize({
	            clientWidth,
	            scrollWidth,
	            offsetWidth,
	            clientHeight,
	            scrollHeight,
	            offsetHeight,
	            clientLeft,
	            scrollLeft,
	            offsetLeft,
	            clientTop,
	            scrollTop,
	            offsetTop
	          });
	        }
	      };

	      if (window && "ResizeObserver" in window) {
	        const observer = new ResizeObserver(_entries => {
	          handleUpdate();
	        });
	        observer.observe(element, {
	          box: observeBox
	        });
	        return () => observer.disconnect();
	      } else {
	        document.addEventListener("resize", handleUpdate, {
	          passive: true
	        });
	        return () => document.removeEventListener("resize", handleUpdate);
	      }
	    }
	  }, []);
	  const {
	    getElement,
	    useRefElementProps
	  } = useRefElement({
	    onElementChange: F(e => needANewObserver(e, getObserveBox === null || getObserveBox === void 0 ? void 0 : getObserveBox()), [])
	  });
	  y(() => {
	    if (getObserveBox) {
	      if (currentObserveBox.current !== getObserveBox()) needANewObserver(getElement(), getObserveBox());
	    }
	  });
	  return {
	    getElement,
	    getSize,
	    useElementSizeProps: useRefElementProps
	  };
	}

	function capitalize(str) {
	  return str[0].toUpperCase() + str.substr(1);
	}
	/**
	 * Inspects the element's style and determines the logical direction that text flows.
	 *
	 * Certain CSS properties, like `block-size`, respect the current writing mode and text direction.
	 * But `transform`, `clip`, etc. don't.
	 *
	 * This is provided so that CSS properties can consistently use those logical properties.
	 *
	 * See https://drafts.csswg.org/css-writing-modes/#logical-to-physical
	 *
	 * @returns An object containing the following functions:
	 * * `getLogicalDirection`: retrieves a `LogicalDirectionInfo` representing the current state of the element. (Function is constant between renders)
	 * * `convertElementSize`: When used in conjunction with `useElementSize`, allows you to retrieve the logical size of an element instead of the physical size.
	 * * `convertToLogicalOrientation`: Based on the current direction, converts "horizontal" or "vertical" to "inline" or "block".
	 * * `convertToPhysicalOrientation`:  Based on the current direction, converts "inline" or "block" to "horizontal" or "vertical".
	 */


	function useLogicalDirection(_ref) {
	  let {
	    onLogicalDirectionChange
	  } = _ref;
	  useEnsureStability("useLogicalDirection", onLogicalDirectionChange);
	  const [getComputedStyles, setComputedStyles] = usePassiveState(null, returnNull$1);
	  const {
	    getElement,
	    useRefElementProps
	  } = useRefElement({
	    onElementChange: F(element => {
	      if (element) {
	        setComputedStyles(window.getComputedStyle(element));
	      }
	    }, [])
	  }); // TODO: There's no way to refresh which writing mode we have once mounted.
	  //   A. There's no way to watch for CSS style changes
	  //   B. Calling getComputedStyle after every render for every element gets expensive fast and
	  //   C. Is not necessary for most use cases that will never switch writing-mode within a single component
	  //      (Those that do will need to mount and unmount the component that uses it)
	  //
	  // As a solution, here's a cheap workaround that checks when the element's size has changed,
	  // and if so, tests if the writing mode has changed too.
	  //
	  // This will work for at least some number of cases, but a better solution is still needed.

	  const {
	    useElementSizeProps
	  } = useElementSize({
	    onSizeChange: F(_ => onLogicalDirectionChange === null || onLogicalDirectionChange === void 0 ? void 0 : onLogicalDirectionChange(getLogicalDirectionInfo()), [])
	  });
	  const getLogicalDirectionInfo = F(() => {
	    const computedStyles = getComputedStyles();

	    if (computedStyles) {
	      const w = computedStyles.writingMode;
	      let d = computedStyles.direction;
	      const t = computedStyles.textOrientation;
	      if (t == "upright") d = "ltr";
	      return { ...WritingModes[w || "horizontal-tb"][d || "ltr"]
	      };
	    }

	    return null;
	  }, []); //const [getLogicalDirectionInfo, setLogicalDirectionInfo] = usePassiveState<LogicalDirectionInfo>(onLogicalDirectionChange);

	  const convertToLogicalOrientation = F((elementOrientation, direction) => {
	    var _direction, _direction2;

	    (_direction = direction) !== null && _direction !== void 0 ? _direction : direction = getLogicalDirectionInfo();
	    if (((_direction2 = direction) === null || _direction2 === void 0 ? void 0 : _direction2.inlineOrientation) === elementOrientation) return "inline";
	    return "block";
	  }, []);
	  const convertToPhysicalSide = F((side, direction) => {
	    var _direction3, _direction$blockDirec, _direction4, _direction$blockDirec2, _direction5, _direction$inlineDire, _direction6, _direction$inlineDire2, _direction7;

	    (_direction3 = direction) !== null && _direction3 !== void 0 ? _direction3 : direction = getLogicalDirectionInfo();

	    switch (side) {
	      case "block-start":
	        return M$1[((_direction$blockDirec = (_direction4 = direction) === null || _direction4 === void 0 ? void 0 : _direction4.blockDirection) !== null && _direction$blockDirec !== void 0 ? _direction$blockDirec : "ttb")[0]];

	      case "block-end":
	        return M$1[((_direction$blockDirec2 = (_direction5 = direction) === null || _direction5 === void 0 ? void 0 : _direction5.blockDirection) !== null && _direction$blockDirec2 !== void 0 ? _direction$blockDirec2 : "ttb")[2]];

	      case "inline-start":
	        return M$1[((_direction$inlineDire = (_direction6 = direction) === null || _direction6 === void 0 ? void 0 : _direction6.inlineDirection) !== null && _direction$inlineDire !== void 0 ? _direction$inlineDire : "ltr")[0]];

	      case "inline-end":
	        return M$1[((_direction$inlineDire2 = (_direction7 = direction) === null || _direction7 === void 0 ? void 0 : _direction7.inlineDirection) !== null && _direction$inlineDire2 !== void 0 ? _direction$inlineDire2 : "ltr")[2]];
	    }
	  }, []);
	  const convertToLogicalSide = F((side, direction) => {
	    var _direction8, _direction9, _direction10;

	    (_direction8 = direction) !== null && _direction8 !== void 0 ? _direction8 : direction = getLogicalDirectionInfo();

	    if (((_direction9 = direction) === null || _direction9 === void 0 ? void 0 : _direction9.inlineOrientation) === "vertical") {
	      switch (side) {
	        case "top":
	          return direction.inlineDirection === "ttb" ? "inline-start" : "inline-end";

	        case "bottom":
	          return direction.inlineDirection === "btt" ? "inline-start" : "inline-end";

	        case "left":
	          return direction.blockDirection === "ltr" ? "block-start" : "block-end";

	        case "right":
	          return direction.blockDirection === "rtl" ? "block-start" : "block-end";
	      }
	    } else if (((_direction10 = direction) === null || _direction10 === void 0 ? void 0 : _direction10.inlineOrientation) === "horizontal") {
	      switch (side) {
	        case "top":
	          return direction.blockDirection === "ttb" ? "block-start" : "block-end";

	        case "bottom":
	          return direction.blockDirection === "btt" ? "block-start" : "block-end";

	        case "left":
	          return direction.inlineDirection === "ltr" ? "inline-start" : "inline-end";

	        case "right":
	          return direction.inlineDirection === "rtl" ? "inline-start" : "inline-end";
	      }
	    }
	    /* eslint-disable no-debugger */


	    debugger;
	    console.assert(false);
	    return "inline-start";
	  }, []);
	  const convertToPhysicalOrientation = F((elementOrientation, direction) => {
	    var _direction11;

	    (_direction11 = direction) !== null && _direction11 !== void 0 ? _direction11 : direction = getLogicalDirectionInfo();

	    if (elementOrientation == "inline") {
	      var _direction12;

	      if (((_direction12 = direction) === null || _direction12 === void 0 ? void 0 : _direction12.inlineOrientation) == "horizontal") return "horizontal";
	      return "vertical";
	    } else {
	      var _direction13;

	      if (((_direction13 = direction) === null || _direction13 === void 0 ? void 0 : _direction13.blockOrientation) == "vertical") return "vertical";
	      return "horizontal";
	    }
	  }, []);
	  const convertElementSize = F((elementSize, direction) => {
	    var _direction14;

	    (_direction14 = direction) !== null && _direction14 !== void 0 ? _direction14 : direction = getLogicalDirectionInfo();

	    if (direction) {
	      const {
	        inlineSize,
	        blockSize,
	        inlineDirection,
	        blockDirection
	      } = direction; // Size is relatively simple

	      const clientInlineSize = elementSize[`client${capitalize(inlineSize)}`];
	      const clientBlockSize = elementSize[`client${capitalize(blockSize)}`];
	      const offsetInlineSize = elementSize[`offset${capitalize(inlineSize)}`];
	      const offsetBlockSize = elementSize[`offset${capitalize(blockSize)}`];
	      const scrollInlineSize = elementSize[`scroll${capitalize(inlineSize)}`];
	      const scrollBlockSize = elementSize[`scroll${capitalize(blockSize)}`];
	      const f1 = getPhysicalLeftTop(inlineDirection);
	      const f2 = getPhysicalRightBottom(inlineDirection);
	      const f3 = getPhysicalLeftTop(blockDirection);
	      const f4 = getPhysicalRightBottom(blockDirection);
	      const clientInlineInset = elementSize[`client${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`client${capitalize(f2)}`]);
	      const scrollInlineInset = elementSize[`scroll${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`scroll${capitalize(f2)}`]);
	      const offsetInlineInset = elementSize[`offset${capitalize(f1)}`] == undefined ? undefined : elementSize[`offset${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`offset${capitalize(f2)}`]);
	      const clientBlockInset = elementSize[`client${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`client${capitalize(f4)}`]);
	      const scrollBlockInset = elementSize[`scroll${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`scroll${capitalize(f4)}`]);
	      const offsetBlockInset = elementSize[`offset${capitalize(f3)}`] == undefined ? undefined : elementSize[`offset${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`offset${capitalize(f4)}`]);
	      return {
	        clientInlineSize,
	        scrollInlineSize,
	        offsetInlineSize,
	        clientBlockSize,
	        scrollBlockSize,
	        offsetBlockSize,
	        clientInlineInset,
	        scrollInlineInset,
	        offsetInlineInset,
	        clientBlockInset,
	        scrollBlockInset,
	        offsetBlockInset
	      };
	    }

	    return null;
	  }, []);
	  return {
	    useLogicalDirectionProps: F(props => useRefElementProps(useElementSizeProps(props)), []),
	    getElement,
	    getLogicalDirectionInfo,
	    convertToLogicalSize: convertElementSize,
	    convertToLogicalOrientation,
	    convertToPhysicalOrientation,
	    convertToLogicalSide,
	    convertToPhysicalSide
	  };
	} // Position requires us to sometimes use one property (like `left`)
	// or sometimes two (like `left` + `width`)

	function getPhysicalLeftTop(dir) {
	  if (dir === "ltr" || dir == "rtl") return "left";
	  return "top";
	}

	function getPhysicalRightBottom(dir) {
	  if (dir === "rtl") return "width";
	  if (dir === "btt") return "height";
	  return null;
	} // Helper for extracting info from "ltr", "ttb", etc.


	const M$1 = {
	  t: "top",
	  b: "bottom",
	  l: "left",
	  r: "right"
	};
	const HorizontalTbLtr = {
	  inlineDirection: "ltr",
	  blockDirection: "ttb",
	  inlineOrientation: "horizontal",
	  blockOrientation: "vertical",
	  inlineSize: "width",
	  blockSize: "height",
	  leftRightDirection: "ltr",
	  overUnderDirection: "ttb"
	};
	const HorizontalTbRtl = { ...HorizontalTbLtr,
	  inlineDirection: "rtl"
	};
	const VerticalRlLtr = {
	  inlineDirection: "ttb",
	  blockDirection: "rtl",
	  inlineOrientation: "vertical",
	  blockOrientation: "horizontal",
	  inlineSize: "height",
	  blockSize: "width",
	  leftRightDirection: "ttb",
	  overUnderDirection: "rtl"
	};
	const VerticalRlRtl = { ...VerticalRlLtr,
	  inlineDirection: "btt"
	};
	const SidewaysRlLtr = { ...VerticalRlLtr
	};
	const SidewaysRlRtl = { ...VerticalRlRtl
	};
	const VerticalLrLtr = { ...VerticalRlLtr,
	  blockDirection: "ltr"
	};
	const VerticalLrRtl = { ...VerticalRlRtl,
	  blockDirection: "ltr"
	};
	const SidewaysLtLtr = { ...VerticalLrLtr,
	  inlineDirection: "btt",
	  leftRightDirection: "btt",
	  overUnderDirection: "ltr"
	};
	const SidewaysLtRtl = { ...SidewaysLtLtr,
	  inlineDirection: "ttb"
	};
	const HorizontalTb = {
	  ltr: HorizontalTbLtr,
	  rtl: HorizontalTbRtl
	};
	const VerticalRl = {
	  ltr: VerticalRlLtr,
	  rtl: VerticalRlRtl
	};
	const VerticalLr = {
	  ltr: VerticalLrLtr,
	  rtl: VerticalLrRtl
	};
	const SidewaysRl = {
	  ltr: SidewaysRlLtr,
	  rtl: SidewaysRlRtl
	};
	const SidewaysLr = {
	  ltr: SidewaysLtLtr,
	  rtl: SidewaysLtRtl
	};
	const WritingModes = {
	  "horizontal-tb": HorizontalTb,
	  "vertical-lr": VerticalLr,
	  "vertical-rl": VerticalRl,
	  "sideways-lr": SidewaysLr,
	  "sideways-rl": SidewaysRl
	};

	/**
	 * Slightly enhanced version of `useState` that includes a getter that remains constant
	 * (i.e. you can use it in `useEffect` and friends without it being a dependency).
	 *
	 * @param initialState
	 * @returns
	 */

	function useState(initialState) {
	  // We keep both, but overrride the `setState` functionality
	  const [state, setStateP] = d(initialState);
	  const ref = s(state); // Hijack the normal setter function 
	  // to also set our ref to the new value

	  const setState = F(value => {
	    if (typeof value === "function") {
	      const callback = value;
	      setStateP(prevValue => {
	        const nextValue = callback(prevValue);
	        ref.current = nextValue;
	        return nextValue;
	      });
	    } else {
	      ref.current = value;
	      setStateP(value);
	    }
	  }, []);

	  const getState = () => {
	    return ref.current;
	  };

	  console.assert(ref.current === state || typeof state === "number" && isNaN(state));
	  return [state, setState, getState];
	}

	const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";

	function base64(value) {
	  return Table[value];
	}

	function random6Bits() {
	  return Math.floor(Math.random() * 0b1000000);
	}

	function random64Bits() {
	  return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
	}
	/**
	 * Returns a randomly-generated ID with an optional prefix.
	 * Note that if the prefix is *explicitly* set to "", then
	 * IDs that are not valid under HTML4 may be generated. Oh no.
	 */


	function generateRandomId(prefix) {
	  return `${prefix !== null && prefix !== void 0 ? prefix : "id-"}${random64Bits().map(n => base64(n)).join("")}`;
	}
	/**
	 * Returns a hook that modifies a set of props to provide a randomly-generated ID if one was not provided.
	 *
	 * If you'd like to use the ID in a property that's *not* named `id` (like `for` or `aria-labelledby` or whatnot), `useReferencedIdProps` is also provided.
	 *
	 * And the randomly-generated id itself is also provided in case you want to handle the logic yourself without `useMergedProps`.
	 *
	 * Unlike most other `use*Props` hooks, these are mostly stable.
	 */

	function useRandomId() {
	  let {
	    prefix
	  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  const [randomId, setRandomId] = useState(() => generateRandomId(prefix));
	  const [_watchPrefixUpdates, setWatchPrefixUpdates, getWatchPrefixUpdates] = useState(false);
	  h(() => {
	    const watchPrefixUpdates = getWatchPrefixUpdates();
	    if (watchPrefixUpdates) setRandomId(() => generateRandomId(prefix));
	    setWatchPrefixUpdates(true);
	  }, [prefix]); // Whatever ID was most recently used by the actual "id" prop.
	  // Used so that any ID-referencing props don't need to provide the same value.
	  //
	  // TODO: This does mean that on the first render, if just the ID is provided,
	  // there will be a temporary mismatch, but it's corrected before rendering finishes.
	  // Is this okay?

	  const [usedId, setUsedId, getUsedId] = useState(undefined);
	  const useReferencedIdProps = F(function useReferencedIdProps(idPropName) {
	    const ret = function (_ref) {
	      var _ref2, _ref3;

	      let {
	        [idPropName]: givenId,
	        ...props
	      } = _ref;
	      const usedId2 = (_ref2 = (_ref3 = givenId !== null && givenId !== void 0 ? givenId : usedId) !== null && _ref3 !== void 0 ? _ref3 : randomId) !== null && _ref2 !== void 0 ? _ref2 : undefined;
	      if (idPropName === "id") setUsedId(usedId2);
	      return useMergedProps()({
	        [idPropName]: usedId2
	      }, props);
	    };

	    return ret;
	  }, [usedId, randomId]);
	  const useRandomIdProps = F(function useRandomIdProps(p) {
	    return useReferencedIdProps("id")(p);
	  }, [useReferencedIdProps]);
	  return {
	    randomId,
	    id: usedId,
	    getId: getUsedId,
	    useRandomIdProps,
	    useReferencedIdProps
	  };
	}

	const previousInputs = new Map();
	const toRun = new Map(); // TODO: Whether this goes in options.diffed or options._commit
	// is a post-suspense question.
	// Right now, using options._commit has the problem of running
	// *after* refs are applied, but we need to come before even that
	// so `ref={someStableFunction}` works.
	// 
	// Also it's private.
	//
	// ...
	// Well, useEvent or whatever is finally, finally 4 years later finally here
	// which is cool and means we won't need this at all soon.
	// So for now we'll stick with diff to prevent any weirdness with
	// commit being private and all.

	const commitName = "diffed";
	const originalCommit = l$1[commitName];

	const newCommit = function () {
	  for (const [id, effectInfo] of toRun) {
	    const oldInputs = previousInputs.get(id);

	    if (argsChanged(oldInputs, effectInfo.inputs)) {
	      var _effectInfo$cleanup;

	      (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
	      effectInfo.cleanup = effectInfo.effect();
	      previousInputs.set(id, effectInfo.inputs);
	    }
	  }

	  toRun.clear();

	  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	    args[_key] = arguments[_key];
	  }

	  originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
	};

	l$1[commitName] = newCommit;
	/**
	 * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
	 *
	 * Every render, we send the arguments to be evaluated after diffing has completed,
	 * which happens before.
	 *
	 * @param effect
	 * @param inputs
	 */

	function useBeforeLayoutEffect(effect, inputs) {
	  /*(() => {
	      const cleanup = useRef<void | (() => void) | null>(null);
	      const prevArgsRef = useRef<Inputs>(null!);
	      if (argsChanged(inputs, prevArgsRef.current)) {
	          prevArgsRef.current = inputs!;
	          if (cleanup.current)
	              cleanup.current();
	          cleanup.current = effect();
	      }
	  })();*/
	  const [id] = d(() => generateRandomId());
	  toRun.set(id, {
	    effect,
	    inputs,
	    cleanup: null
	  });
	  y(() => {
	    return () => {
	      toRun.delete(id);
	      previousInputs.delete(id);
	    };
	  }, [id]);
	}

	function argsChanged(oldArgs, newArgs) {
	  return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
	}

	const Unset = Symbol("unset");
	/**
	 * Given an input value, returns a constant getter function that can be used
	 * inside of `useEffect` and friends without including it in the dependency array.
	 *
	 * This uses `options.diffed` in order to run before everything, even
	 * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
	 *
	 * @param value
	 * @returns
	 */

	function useStableGetter(value) {
	  const ref = s(Unset);
	  useBeforeLayoutEffect(() => {
	    ref.current = value;
	  }, [value]);
	  return F(() => {
	    if (ref.current === Unset) {
	      throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
	    }

	    return ref.current;
	  }, []);
	}

	/**
	 * Alternate useCallback() which always returns the same (wrapped) function reference
	 * so that it can be excluded from the dependency arrays of `useEffect` and friends.
	 *
	 * Do not use during the render phase!  `useLayoutEffect` is fine though.
	 */

	function useStableCallback(fn) {
	  const currentCallbackGetter = useStableGetter(fn);
	  return F(function () {
	    return currentCallbackGetter()(...arguments);
	  }, []);
	}

	/**
	 * Wrap the native `useEffect` to add arguments
	 * that allow accessing the previous value as the first argument,
	 * as well as the changes that caused the hook to be called as the second argument.
	 *
	 * @param effect
	 * @param inputs
	 * @param impl You can choose whether to use `useEffect` or `useLayoutEffect` by
	 * passing one of them as this argument. By default, it's `useEffect`.
	 */

	function useEffect(effect, inputs) {
	  let impl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : y;
	  const prevInputs = s(undefined);

	  const effect2 = () => {
	    const changes = [];

	    if (inputs && prevInputs.current) {
	      for (let i = 0; i < Math.max(prevInputs.current.length, inputs.length); ++i) {
	        if (prevInputs.current[i] != inputs[i]) changes[i] = {
	          from: prevInputs.current[i],
	          to: inputs[i]
	        };
	      }
	    }

	    const ret = effect(prevInputs.current, changes);
	    prevInputs.current = inputs;
	    return ret;
	  };

	  impl(effect2, inputs);
	}

	/**
	 * Wrap the native `useLayoutEffect` to add arguments
	 * that allow accessing the previous value as the first argument,
	 * as well as the changes that caused the hook to be called as the second argument.
	 *
	 * @param effect
	 * @param inputs
	 */

	function useLayoutEffect(effect, inputs) {
	  return useEffect(effect, inputs, h);
	}

	function useTimeout(_ref) {
	  let {
	    timeout,
	    callback,
	    triggerIndex
	  } = _ref;
	  const stableCallback = useStableCallback(() => {
	    startTimeRef.current = null;
	    callback();
	  });
	  const getTimeout = useStableGetter(timeout); // Set any time we start timeout.
	  // Unset any time the timeout completes

	  const startTimeRef = s(null);
	  const timeoutIsNull = timeout == null; // Any time the triggerIndex changes (including on mount)
	  // restart the timeout.  The timeout does NOT reset
	  // when the duration or callback changes, only triggerIndex.

	  y(() => {
	    if (!timeoutIsNull) {
	      const timeout = getTimeout();
	      console.assert(timeoutIsNull == (timeout == null));

	      if (timeout != null) {
	        startTimeRef.current = +new Date();
	        const handle = setTimeout(stableCallback, timeout);
	        return () => clearTimeout(handle);
	      }
	    }
	  }, [triggerIndex, timeoutIsNull]);
	  const getElapsedTime = F(() => {
	    var _startTimeRef$current;

	    return +new Date() - +((_startTimeRef$current = startTimeRef.current) !== null && _startTimeRef$current !== void 0 ? _startTimeRef$current : new Date());
	  }, []);
	  const getRemainingTime = F(() => {
	    const timeout = getTimeout();
	    return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
	  }, []);
	  return {
	    getElapsedTime,
	    getRemainingTime
	  };
	}

	/**
	 * When used in tandem with `useRovingTabIndex`, allows control of
	 * the tabbable index with the arrow keys.
	 *
	 * @see useListNavigation, which packages everything up together.
	 */

	function useLinearNavigation(_ref) {
	  var _navigationDirection;

	  let {
	    index,
	    navigateToFirst,
	    navigateToLast,
	    navigateToNext,
	    navigateToPrev,
	    managedChildren,
	    navigationDirection,
	    disableArrowKeys,
	    disableHomeEndKeys
	  } = _ref;
	  (_navigationDirection = navigationDirection) !== null && _navigationDirection !== void 0 ? _navigationDirection : navigationDirection = "either";
	  const childCount = managedChildren.length; // Make sure the tabbable index never escapes the bounds of all available children
	  // TODO: Keep track of the original index and keep it, at least until keyboard navigation.

	  useLayoutEffect(() => {
	    if (index !== null) {
	      if (index < 0) {
	        navigateToFirst();
	      } else if (childCount > 0 && index >= childCount) {
	        navigateToLast();
	      }
	    }
	  }, [index, childCount, navigateToFirst, navigateToLast]);
	  const {
	    getLogicalDirectionInfo,
	    useLogicalDirectionProps
	  } = useLogicalDirection({});

	  const onKeyDown = e => {
	    // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
	    if (e.ctrlKey || e.metaKey) return;
	    const info = getLogicalDirectionInfo();
	    const allowsBlockNavigation = navigationDirection == "block" || navigationDirection == "either";
	    const allowsInlineNavigation = navigationDirection == "inline" || navigationDirection == "either";

	    switch (e.key) {
	      case "ArrowUp":
	        {
	          const propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
	          const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation);

	          if (directionAllowed) {
	            if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
	              navigateToNext();
	            } else {
	              navigateToPrev();
	            }

	            e.preventDefault();
	            e.stopPropagation();
	          }

	          break;
	        }

	      case "ArrowDown":
	        {
	          const propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
	          const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation);

	          if (directionAllowed) {
	            if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
	              navigateToPrev();
	            } else {
	              navigateToNext();
	            }

	            e.preventDefault();
	            e.stopPropagation();
	          }

	          break;
	        }

	      case "ArrowLeft":
	        {
	          const propName = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";
	          const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation);

	          if (directionAllowed) {
	            if ((info === null || info === void 0 ? void 0 : info[propName]) === "rtl") {
	              navigateToNext();
	            } else {
	              navigateToPrev();
	            }

	            e.preventDefault();
	            e.stopPropagation();
	          }

	          break;
	        }

	      case "ArrowRight":
	        {
	          const propName = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";
	          const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation);

	          if (directionAllowed) {
	            if ((info === null || info === void 0 ? void 0 : info[propName]) === "rtl") {
	              navigateToPrev();
	            } else {
	              navigateToNext();
	            }

	            e.preventDefault();
	            e.stopPropagation();
	          }

	          e.preventDefault();
	          e.stopPropagation();
	          break;
	        }

	      case "Home":
	        if (!disableHomeEndKeys) {
	          navigateToFirst();
	          e.preventDefault();
	          e.stopPropagation();
	        }

	        break;

	      case "End":
	        if (!disableHomeEndKeys) {
	          navigateToLast();
	          e.preventDefault();
	          e.stopPropagation();
	        }

	        break;
	    }
	  };

	  return {
	    useLinearNavigationProps: F(props => {
	      return useLogicalDirectionProps(useMergedProps()({
	        onKeyDown
	      }, props));
	    }, [])
	  };
	}
	/**
	 * Allows for the selection of a managed child by typing the given text associated with it.
	 *
	 * @see useListNavigation, which packages everything up together.
	 */

	function useTypeaheadNavigation(_ref2) {
	  let {
	    collator,
	    getIndex,
	    typeaheadTimeout,
	    setIndex
	  } = _ref2;
	  // For typeahead, keep track of what our current "search" string is (if we have one)
	  // and also clear it every 1000 ms since the last time it changed.
	  // Next, keep a mapping of typeahead values to indices for faster searching.
	  // And, for the user's sake, let them know when their typeahead can't match anything anymore
	  const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
	  useTimeout({
	    timeout: typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000,
	    callback: () => {
	      setCurrentTypeahead(null);
	      setInvalidTypeahead(null);
	    },
	    triggerIndex: currentTypeahead
	  });
	  const sortedTypeaheadInfo = s([]);
	  const [invalidTypeahead, setInvalidTypeahead] = useState(false); // Handle typeahead for input method editors as well
	  // Essentially, when active, ignore further keys 
	  // because we're waiting for a CompositionEnd event

	  const [, setImeActive, getImeActive] = useState(false); // Because composition events fire *after* keydown events 
	  // (but within the same task, which, TODO, could be browser-dependent),
	  // we can use this to keep track of which event we're listening for on the first keydown.

	  const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
	  useLayoutEffect(() => {
	    if (nextTypeaheadChar !== null) {
	      setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar);
	      setNextTypeaheadChar(null);
	    }
	  }, [nextTypeaheadChar]);
	  const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
	    var _safeRhs$toLowerCase;

	    let compare; // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
	    // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.

	    safeLhs = safeLhs.normalize("NFD");
	    safeRhs = safeRhs.normalize("NFD");
	    if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
	    return compare;
	  });
	  const insertingComparator = useStableCallback((lhs, rhs) => {
	    if (typeof lhs === "string" && typeof rhs.text === "string") {
	      return comparatorShared(lhs, rhs.text);
	    }

	    return lhs - rhs;
	  });
	  const typeaheadComparator = useStableCallback((lhs, rhs) => {
	    if (typeof lhs === "string" && typeof rhs.text === "string") {
	      // During typeahead, all strings longer than ours should be truncated
	      // so that they're all considered equally by that point.
	      return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
	    }

	    return lhs - rhs;
	  });
	  const useTypeaheadNavigationProps = F(function (_ref3) {
	    let { ...props
	    } = _ref3;

	    const onCompositionStart = _e => {
	      setImeActive(true);
	    };

	    const onCompositionEnd = e => {
	      setNextTypeaheadChar(e.data);
	      setImeActive(false);
	    };

	    const onKeyDown = e => {
	      const imeActive = getImeActive();
	      const key = e.key; // Not handled by typeahead (i.e. assume this is a keyboard shortcut)

	      if (e.ctrlKey || e.metaKey) return;

	      if (!imeActive && e.key === "Backspace") {
	        // Remove the last character in a way that doesn't split UTF-16 surrogates.
	        setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
	        e.preventDefault();
	        e.stopPropagation();
	        return;
	      } // The key property represents the typed character OR the "named key attribute" of the key pressed.
	      // There's no definite way to tell the difference, but for all intents and purposes
	      // there are no one-character names, and there are no non-ASCII-alpha names.
	      // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.


	      const isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);

	      if (isCharacterKey) {
	        var _getCurrentTypeahead;

	        if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ; else {
	          e.preventDefault();
	          e.stopPropagation(); // Note: Won't be true for the first keydown
	          // but will be overwritten before useLayoutEffect is called
	          // to actually apply the change

	          if (!imeActive) setNextTypeaheadChar(key);
	        }
	      }
	    };

	    return useMergedProps()({
	      onKeyDown,
	      onCompositionStart,
	      onCompositionEnd
	    }, props);
	  }, []); // Handle changes in typeahead that cause changes to the tabbable index

	  y(() => {
	    if (currentTypeahead && sortedTypeaheadInfo.current.length) {
	      const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);

	      if (sortedTypeaheadIndex < 0) {
	        // The user has typed an entry that doesn't exist in the list
	        // (or more specifically "for which there is no entry that starts with that input")
	        setInvalidTypeahead(true);
	      } else {
	        setInvalidTypeahead(false);
	        /*
	          We know roughly where, in the sorted array of strings, our next typeahead location is.
	          But roughly isn't good enough if there are multiple matches.
	          To convert our sorted index to the unsorted index we need, we have to find the first
	          element that matches us *and* (if any such exist) is *after* our current selection.
	           In other words, the only way typeahead moves backwards relative to our current
	          position is if the only other option is behind us.
	           It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
	          Though there's also a case for just going upwards to the nearest to prevent jumpiness.
	          But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
	          I dunno. Going back to the start is the simplist though.
	           Basically what this does: Starting from where we found ourselves after our binary search,
	          scan backwards and forwards through all adjacent entries that also compare equally so that
	          we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
	          (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
	           TODO: The binary search starts this off with a solid O(log n), but one-character
	          searches are, thanks to pigeonhole principal, eventually guaranteed to become
	          O(n*log n). This is annoying but probably not easily solvable? There could be an
	          exception for one-character strings, but that's just kicking the can down
	          the road. Maybe one or two characters would be good enough though.
	        */
	        // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.

	        let lowestUnsortedIndexAll = null;
	        let lowestSortedIndexAll = sortedTypeaheadIndex; // These two are only set for elements that are ahead of us, but the principle's the same otherwise

	        let lowestUnsortedIndexNext = null;
	        let lowestSortedIndexNext = sortedTypeaheadIndex;

	        const updateBestFit = u => {
	          var _getIndex;

	          if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
	            lowestUnsortedIndexAll = u;
	            lowestSortedIndexAll = i;
	          }

	          if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > ((_getIndex = getIndex()) !== null && _getIndex !== void 0 ? _getIndex : -Infinity)) {
	            lowestUnsortedIndexNext = u;
	            lowestSortedIndexNext = i;
	          }
	        };

	        let i = sortedTypeaheadIndex;

	        while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
	          updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
	          --i;
	        }

	        i = sortedTypeaheadIndex;

	        while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
	          updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
	          ++i;
	        }

	        if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
	      }
	    }
	  }, [currentTypeahead]);
	  const useTypeaheadNavigationChild = F(_ref4 => {
	    let {
	      text,
	      ...i
	    } = _ref4;
	    y(() => {
	      if (text) {
	        // Find where to insert this item.
	        // Because all index values should be unique, the returned sortedIndex
	        // should always refer to a new location (i.e. be negative)                
	        const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
	        console.assert(sortedIndex < 0 || sortedTypeaheadInfo.current[sortedIndex].text == text);

	        if (sortedIndex < 0) {
	          sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, {
	            text,
	            unsortedIndex: i.index
	          });
	        } else {
	          sortedTypeaheadInfo.current.splice(sortedIndex, 0, {
	            text,
	            unsortedIndex: i.index
	          });
	        }

	        return () => {
	          // When unmounting, find where we were and remove ourselves.
	          // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
	          const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
	          console.assert(sortedIndex < 0 || sortedTypeaheadInfo.current[sortedIndex].text == text);

	          if (sortedIndex >= 0) {
	            sortedTypeaheadInfo.current.splice(sortedIndex, 1);
	          }
	        };
	      }
	    }, [text]);
	    return {};
	  }, []);
	  return {
	    useTypeaheadNavigationChild,
	    useTypeaheadNavigationProps,
	    currentTypeahead,
	    invalidTypeahead
	  };
	}
	/**
	 * Your usual binary search implementation.
	 *
	 * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
	 * @param array The array to search through
	 * @param wanted The value you'd like to find
	 * @param comparator Compares `wanted` with the current value in `array`
	 * @returns A non-negative value if `wanted` was found, and a negative number if not.
	 * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
	 */

	function binarySearch(array, wanted, comparator) {
	  let firstIndex = 0;
	  let lastIndex = array.length - 1;

	  while (firstIndex <= lastIndex) {
	    const testIndex = lastIndex + firstIndex >> 1;
	    const comparisonResult = comparator(wanted, array[testIndex]);

	    if (comparisonResult > 0) {
	      firstIndex = testIndex + 1;
	    } else if (comparisonResult < 0) {
	      lastIndex = testIndex - 1;
	    } else {
	      return testIndex;
	    }
	  }

	  return -firstIndex - 1;
	}

	/**
	 * Allows a parent component to access information about certain
	 * child components once they have rendered.
	 *
	 * This hook is slightly more complicated in that it returns both a
	 * prop-modifying hook, but also a hook that each child will need
	 * to use: `useManagedChild`.  It's stable across renders, so just
	 * toss it into a `Context` so the children can have access to it.
	 * This function registers the child with the parent and provides
	 * it with any requested information, but doesn't do anything else
	 * until it unmounts and retracts that information.
	 */

	function useChildManager() {
	  // This is blindly updated any time a child mounts or unmounts itself.
	  // Used to make sure that any time the array of managed children updates,
	  // we also re-render.
	  const [_childUpdateIndex, setChildUpdateIndex] = useState(0);
	  const [totalChildrenMounted, setTotalChildrenMounted, getTotalChildrenMounted] = useState(0);
	  const [totalChildrenUnounted, setTotalChildrenUnounted, _getTotalChildrenUnounted] = useState(0);
	  const childrenCurrentlyMounted = totalChildrenMounted - totalChildrenUnounted;
	  const managedChildren = s([]
	  /** TODO: Any problems caused by using an array when it should be an object? */
	  );
	  const mountedChildren = s([]);
	  const mountOrder = s(new Map());
	  const indicesByElement = s(new Map());
	  const deletedIndices = s(new Set()); // Used to keep track of indices that have "over-mounted" and by how much.
	  // We need this so that we don't erase saved information when a component
	  // "overmounts" over another which then, correctly, switches *itself* to something else.
	  // In general, this should only happen when components are swapping between indices.
	  // By the time they're done, this map should be all 0s again, at which point
	  // it's okay to actually run the unmount code.
	  // 
	  // TODO: throw a console.assert somewhere to make up for the lost 
	  // "are you sure you want to overwrite this child's index!" assertion.
	  // Namely, is this map all 0s when the parent element re-renders? 
	  // Probably not because of setChildUpdateIndex

	  const overmountCount = s(new Map());
	  const getMountIndex = F(index => {
	    return mountOrder.current.get(index);
	  }, []);
	  const useManagedChild = F(info => {
	    const {
	      getElement,
	      useRefElementProps
	    } = useRefElement({
	      onElementChange: F(element => {
	        if (element) {
	          indicesByElement.current.set(element, info.index);
	          deletedIndices.current.delete(info.index);

	          if (managedChildren.current[info.index] != undefined) {
	            var _overmountCount$curre;

	            overmountCount.current.set(info.index, ((_overmountCount$curre = overmountCount.current.get(info.index)) !== null && _overmountCount$curre !== void 0 ? _overmountCount$curre : 0) + 1);
	          }

	          setChildUpdateIndex(c => ++c);
	          managedChildren.current[info.index] = { ...info
	          };
	          return () => {
	            var _overmountCount$curre2;

	            setChildUpdateIndex(c => ++c);

	            if (((_overmountCount$curre2 = overmountCount.current.get(info.index)) !== null && _overmountCount$curre2 !== void 0 ? _overmountCount$curre2 : 0) > 0) {
	              var _overmountCount$curre3;

	              overmountCount.current.set(info.index, ((_overmountCount$curre3 = overmountCount.current.get(info.index)) !== null && _overmountCount$curre3 !== void 0 ? _overmountCount$curre3 : 0) - 1);
	            } else {
	              delete managedChildren.current[info.index];
	              deletedIndices.current.add(info.index);

	              if (typeof info.index === "number") {
	                while (managedChildren.current.length && managedChildren.current[managedChildren.current.length - 1] === undefined) managedChildren.current.length -= 1;
	              }

	              indicesByElement.current.delete(element);
	            }
	          };
	        }
	      }, [])
	    });
	    useLayoutEffect(() => {
	      const index = getTotalChildrenMounted();
	      mountOrder.current.set(info.index, index);
	      mountedChildren.current[index] = info;
	      setTotalChildrenMounted(t => ++t);
	      return () => {
	        mountOrder.current.delete(info.index);
	        mountedChildren.current[index] = null;
	        setTotalChildrenUnounted(t => ++t);
	      };
	    }, [info.index]); // Any time our child props change, make that information available generally.
	    // *Don't re-render*, otherwise we'd be stuck in an
	    // infinite loop every time an anonymous function is passed.
	    // It comes in from the props so the child was already updated by it --
	    // we don't need the parent to re-render every single child any time
	    // "onClick" updates or whatever.  The relevant child already knows,
	    // and that's what matters.

	    useLayoutEffect(() => {
	      if (managedChildren.current[info.index] != undefined) managedChildren.current[info.index] = { ...info
	      };
	    }, [...Object.entries(info).flat()]);
	    return {
	      getElement,
	      useManagedChildProps: useRefElementProps
	    };
	  }, []);
	  return {
	    useManagedChild,
	    childCount: childrenCurrentlyMounted,
	    managedChildren: managedChildren.current,
	    mountedChildren: mountedChildren.current,
	    indicesByElement: indicesByElement.current,
	    totalChildrenMounted,
	    totalChildrenUnounted,
	    getMountIndex,
	    deletedIndices: deletedIndices.current
	  };
	}
	/**
	 * Helper function for letting children know when they are or are not the
	 * current selected/expanded/focused/whatever child.
	 *
	 * Automatically handles when children are mounted & unmounted and such.
	 *
	 * While it will be called once for every child on mount, after that setFlag
	 * is guaranteed to only be called once on activation and once on deactivation,
	 * so it's generally safe to put side effects inside if necessary.
	 * It's also safe to make it non-stable.
	 *
	 * @param activatedIndex What index the current selected (etc.) child is
	 * @param length How many children exist (as managedChildren.length)
	 * @param setFlag A function that probably looks like (i, flag) => managedChildren[i].setActive(flag)
	 * @param useEffect Which version of useEffect to use. Default is `useLayoutEffect`.
	 */

	function useChildFlag(_ref) {
	  var _useEffect;

	  let {
	    activatedIndex,
	    closestFit,
	    managedChildren,
	    setChildFlag,
	    getChildFlag,
	    useEffect
	  } = _ref;
	  (_useEffect = useEffect) !== null && _useEffect !== void 0 ? _useEffect : useEffect = useLayoutEffect;
	  if (closestFit) console.assert(typeof activatedIndex == "number" || activatedIndex == null); // Whenever we re-render, make sure that any children that have mounted
	  // have their flags properly set.  We know it's unset if it was null,
	  // in which case we just set it to true or false.
	  //
	  // And, I mean, as long as we're already iterating through every child
	  // on every render to check for newly mounted children, might as well
	  // just handle changed in the activatedIndex here too.

	  useEffect(() => {
	    // TODO: We have limited information about when a child mounts or unmounts
	    // and so we don't know where to look for any null entries that need changing.
	    // We know when activatedIndex changes and what it was, but not much else.
	    // Looping over every child *works*, and it's not an expensive loop by any means,
	    // but, like, eugh.
	    // Also, before we do anything, see if we need to "correct" activatedIndex.
	    // It could be pointing to a child that doesn't exist, and if closestFit is given,
	    // we need to adjust activatedIndex to point to a valid child.
	    if (typeof activatedIndex == "number" && Array.isArray(managedChildren) && managedChildren[activatedIndex] == null) {
	      // Oh dear. Are we actively correcting this?
	      if (closestFit) {
	        // Oh dear.
	        // Search up and down the list of children for any that actually exist.
	        let searchHigh = activatedIndex + 1;
	        let searchLow = activatedIndex - 1;

	        while (searchLow >= 0 && managedChildren[searchLow] == null || searchHigh < managedChildren.length && managedChildren[searchHigh] == null) {
	          ++searchHigh;
	          --searchLow;
	        }

	        if (searchLow >= 0 && managedChildren[searchLow] != null) {
	          activatedIndex = searchLow;
	        } else if (searchHigh < managedChildren.length && managedChildren[searchHigh] != null) {
	          activatedIndex = searchHigh;
	        } // Now that we've done that, if any valid children exist, we've reset activatedIndex to point to it instead.
	        // Now we'll fall through to the for loop set and unset our flags based on this "corrected" value.
	        //
	        // We don't correct it or save it anywhere because we'd very much like to return to it
	        // if the child remounts itself.

	      }
	    }

	    if (Array.isArray(managedChildren)) {
	      for (let i = 0; i < managedChildren.length; ++i) {
	        const shouldBeSet = i == activatedIndex;

	        if (getChildFlag(i) != shouldBeSet) {
	          setChildFlag(i, shouldBeSet);
	        }
	      }
	    } else {
	      Object.entries(managedChildren).forEach(_ref2 => {
	        let [i, _info] = _ref2;
	        const shouldBeSet = i == activatedIndex;

	        if (getChildFlag(i) != shouldBeSet) {
	          setChildFlag(i, shouldBeSet);
	        }
	      });
	    }
	  });
	}

	/**
	 * Implements a roving tabindex system where only one "focusable"
	 * component in a set is able to receive a tab focus. *Which*
	 * of those elements receives focus is determined by you, but it's
	 * recommended to offload that logic then to another hook, like
	 * `useLinearNavigation`, which lets you change the tabbable
	 * element with the arrow keys, `useTypeaheadNavigation`, which
	 * lets you change the tabbable index with typeahead, or
	 * `useListNavigation` if you just want everything bundled together.
	 *
	 * Note that the child hook returned by this function must be used
	 * by every child that uses this roving tabindex logic.  The
	 * prop-modifying hook *that* hook returns should then be used
	 * on the child's element, as well as any other elements you'd like
	 * to be explicitly made untabbable too.
	 *
	 * `shouldFocusOnChange` should return true if focus is
	 * contained within whatever element contains the roving tab index.
	 * Generally as simple as the following:
	 * ```
	 * const [focusedInner, setFocusedInner] = useState(false);
	 * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
	 * const focusOnChange = (focusedInner != false);
	 * ```
	 * It's not included here because `useRovingTabIndex` doesn't know
	 * anything about the container element, only children elements.
	 * And just as well! Children should be allowed at the root,
	 * regardless of if it's the whole app or just a given component.
	 */

	function useRovingTabIndex(_ref) {
	  let {
	    shouldFocusOnChange: foc,
	    tabbableIndex
	  } = _ref;
	  const getShouldFocusOnChange = useStableGetter(foc);
	  const getTabbableIndex = useStableGetter(tabbableIndex); // Call the hook that allows us to collect information from children who provide it

	  const {
	    managedChildren,
	    childCount,
	    useManagedChild,
	    indicesByElement,
	    ...rest
	  } = useChildManager(); // Any time the tabbable index changes,
	  // notify the previous child that it's no longer tabbable,
	  // and notify the next child that is allowed to be tabbed to.

	  useChildFlag({
	    activatedIndex: tabbableIndex,
	    managedChildren,
	    closestFit: true,
	    setChildFlag: (index, tabbable) => {
	      var _managedChildren$inde;

	      if (index != null) (_managedChildren$inde = managedChildren[index]) === null || _managedChildren$inde === void 0 ? void 0 : _managedChildren$inde.setTabbable(tabbable);
	    },
	    getChildFlag: index => {
	      var _managedChildren$inde2, _managedChildren$inde3;

	      return (_managedChildren$inde2 = (_managedChildren$inde3 = managedChildren[index]) === null || _managedChildren$inde3 === void 0 ? void 0 : _managedChildren$inde3.getTabbable()) !== null && _managedChildren$inde2 !== void 0 ? _managedChildren$inde2 : null;
	    }
	  });
	  const useRovingTabIndexChild = F(info => {
	    const [rrafIndex, setRrafIndex] = useState(1);
	    const rerenderAndFocus = F(() => {
	      setRrafIndex(i => ++i);
	    }, []);
	    const [tabbable, setTabbable, getTabbable] = useState(null);
	    const newInfo = { ...info,
	      rerenderAndFocus,
	      setTabbable: F(tabbable => {
	        setTabbable(tabbable);
	      }, []),
	      getTabbable
	    };
	    const {
	      getElement,
	      useManagedChildProps
	    } = useManagedChild(newInfo);
	    y(() => {
	      const element = getElement();

	      if (tabbable) {
	        const shouldFocusOnChange = getShouldFocusOnChange()();

	        if (shouldFocusOnChange && "focus" in element) {
	          requestAnimationFrame(() => {
	            queueMicrotask(() => {
	              element.focus();
	            });
	          });
	        }
	      }
	    }, [tabbable, rrafIndex]);

	    function useRovingTabIndexSiblingProps(_ref2) {
	      let {
	        tabIndex,
	        ...props
	      } = _ref2;

	      if (tabIndex == null) {
	        if (tabbable) tabIndex = 0;else tabIndex = -1;
	      }

	      return useMergedProps()({
	        tabIndex
	      }, props);
	    }

	    function useRovingTabIndexChildProps(_ref3) {
	      let {
	        tabIndex,
	        ...props
	      } = _ref3;

	      if (tabIndex == null) {
	        if (tabbable) tabIndex = 0;else tabIndex = -1;
	      }

	      return useMergedProps()(useManagedChildProps({
	        tabIndex
	      }), props);
	    }

	    return {
	      useRovingTabIndexChildProps,
	      useRovingTabIndexSiblingProps,
	      tabbable
	    };
	  }, [useManagedChild]);
	  return {
	    useRovingTabIndexChild,
	    childCount,
	    managedChildren,
	    indicesByElement,
	    focusCurrent: F(() => {
	      var _getTabbableIndex;

	      if (managedChildren[(_getTabbableIndex = getTabbableIndex()) !== null && _getTabbableIndex !== void 0 ? _getTabbableIndex : 0].getTabbable()) {
	        var _managedChildren, _getTabbableIndex2;

	        (_managedChildren = managedChildren[(_getTabbableIndex2 = getTabbableIndex()) !== null && _getTabbableIndex2 !== void 0 ? _getTabbableIndex2 : 0]) === null || _managedChildren === void 0 ? void 0 : _managedChildren.rerenderAndFocus();
	      } else {
	        var _getTabbableIndex3;

	        // For whatever reason, the previously tabbable child
	        // is no longer tabbable without us knowing about it.
	        // Maybe it unmounted?
	        // Either way, try to find the newly-selected child.
	        // (I don't think this code path has ever been run)

	        /* eslint-disable no-debugger */
	        debugger;
	        let i = (_getTabbableIndex3 = getTabbableIndex()) !== null && _getTabbableIndex3 !== void 0 ? _getTabbableIndex3 : 0;
	        let j = i + 1;

	        while (i >= 0) {
	          var _getTabbableIndex4;

	          --i;

	          if (managedChildren[(_getTabbableIndex4 = getTabbableIndex()) !== null && _getTabbableIndex4 !== void 0 ? _getTabbableIndex4 : 0].getTabbable()) {
	            var _managedChildren2, _getTabbableIndex5;

	            (_managedChildren2 = managedChildren[(_getTabbableIndex5 = getTabbableIndex()) !== null && _getTabbableIndex5 !== void 0 ? _getTabbableIndex5 : 0]) === null || _managedChildren2 === void 0 ? void 0 : _managedChildren2.rerenderAndFocus();
	            return;
	          }
	        }

	        while (j < managedChildren.length) {
	          var _getTabbableIndex6;

	          ++j;

	          if (managedChildren[(_getTabbableIndex6 = getTabbableIndex()) !== null && _getTabbableIndex6 !== void 0 ? _getTabbableIndex6 : 0].getTabbable()) {
	            var _managedChildren3, _getTabbableIndex7;

	            (_managedChildren3 = managedChildren[(_getTabbableIndex7 = getTabbableIndex()) !== null && _getTabbableIndex7 !== void 0 ? _getTabbableIndex7 : 0]) === null || _managedChildren3 === void 0 ? void 0 : _managedChildren3.rerenderAndFocus();
	            return;
	          }
	        }
	      }
	    }, []),
	    ...rest
	  };
	}

	function identity(t) {
	  return t;
	}
	/**
	 * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
	 *
	 * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
	 * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
	 */


	function useListNavigation(_ref) {
	  var _indexMangler, _indexDemangler, _keyNavigation, _getTabbableIndex;

	  let {
	    initialIndex,
	    shouldFocusOnChange,
	    collator,
	    keyNavigation,
	    indexMangler,
	    indexDemangler
	  } = _ref;
	  (_indexMangler = indexMangler) !== null && _indexMangler !== void 0 ? _indexMangler : indexMangler = identity;
	  (_indexDemangler = indexDemangler) !== null && _indexDemangler !== void 0 ? _indexDemangler : indexDemangler = identity;
	  (_keyNavigation = keyNavigation) !== null && _keyNavigation !== void 0 ? _keyNavigation : keyNavigation = "either";
	  useEnsureStability("useListNavigation", indexMangler, indexDemangler); // Keep track of three things related to the currently tabbable element's index:
	  // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.

	  const [tabbableIndex, setTabbableIndex, getTabbableIndex] = useState(initialIndex === undefined ? 0 : initialIndex);
	  const {
	    managedChildren,
	    indicesByElement,
	    useRovingTabIndexChild,
	    focusCurrent,
	    ...rest
	  } = useRovingTabIndex({
	    shouldFocusOnChange,
	    tabbableIndex
	  });
	  /*const navigateToIndex = useCallback((i: number | null) => { setTabbableIndex(i); }, []);
	  const navigateToFirst = useCallback(() => { tryNavigateToIndex(managedChildren,) setTabbableIndex(indexMangler!(0)); }, []);
	  const navigateToLast = useCallback(() => { setTabbableIndex(indexMangler!(managedChildren.length - 1)); }, []);
	  const navigateToPrev = useCallback(() => { setTabbableIndex(i => indexMangler!(indexDemangler!(i ?? 0) - 1)) }, [indexDemangler, indexMangler]);
	  const navigateToNext = useCallback(() => { setTabbableIndex(i => indexMangler!(indexDemangler!(i ?? 0) + 1)) }, [indexDemangler, indexMangler]);
	  */

	  const navigateToIndex = F(i => {
	    var _indexMangler2, _indexDemangler2;

	    setTabbableIndex(i == null ? null : tryNavigateToIndex(managedChildren, 0, i, 1, (_indexMangler2 = indexMangler) !== null && _indexMangler2 !== void 0 ? _indexMangler2 : identity, (_indexDemangler2 = indexDemangler) !== null && _indexDemangler2 !== void 0 ? _indexDemangler2 : identity));
	  }, []);
	  const navigateToFirst = F(() => {
	    var _indexMangler3, _indexDemangler3;

	    setTabbableIndex(tryNavigateToIndex(managedChildren, 0, 0, 1, (_indexMangler3 = indexMangler) !== null && _indexMangler3 !== void 0 ? _indexMangler3 : identity, (_indexDemangler3 = indexDemangler) !== null && _indexDemangler3 !== void 0 ? _indexDemangler3 : identity));
	  }, []);
	  const navigateToLast = F(() => {
	    var _indexMangler4, _indexDemangler4;

	    setTabbableIndex(tryNavigateToIndex(managedChildren, managedChildren.length, managedChildren.length, -1, (_indexMangler4 = indexMangler) !== null && _indexMangler4 !== void 0 ? _indexMangler4 : identity, (_indexDemangler4 = indexDemangler) !== null && _indexDemangler4 !== void 0 ? _indexDemangler4 : identity));
	  }, []);
	  const navigateToPrev = F(() => {
	    setTabbableIndex(c => {
	      var _indexMangler5, _indexDemangler5;

	      return tryNavigateToIndex(managedChildren, c !== null && c !== void 0 ? c : 0, (c !== null && c !== void 0 ? c : 0) - 1, -1, (_indexMangler5 = indexMangler) !== null && _indexMangler5 !== void 0 ? _indexMangler5 : identity, (_indexDemangler5 = indexDemangler) !== null && _indexDemangler5 !== void 0 ? _indexDemangler5 : identity);
	    });
	  }, []);
	  const navigateToNext = F(() => {
	    setTabbableIndex(c => {
	      var _indexMangler6, _indexDemangler6;

	      return tryNavigateToIndex(managedChildren, c !== null && c !== void 0 ? c : 0, (c !== null && c !== void 0 ? c : 0) + 1, 1, (_indexMangler6 = indexMangler) !== null && _indexMangler6 !== void 0 ? _indexMangler6 : identity, (_indexDemangler6 = indexDemangler) !== null && _indexDemangler6 !== void 0 ? _indexDemangler6 : identity);
	    });
	  }, []);
	  const setIndex = F(index => {
	    setTabbableIndex(index);
	  }, []);
	  const {
	    currentTypeahead,
	    invalidTypeahead,
	    useTypeaheadNavigationChild,
	    useTypeaheadNavigationProps
	  } = useTypeaheadNavigation({
	    collator,
	    getIndex: getTabbableIndex,
	    setIndex,
	    typeaheadTimeout: 1000
	  });
	  const {
	    useLinearNavigationProps
	  } = useLinearNavigation({
	    navigationDirection: keyNavigation,
	    index: (_getTabbableIndex = getTabbableIndex()) !== null && _getTabbableIndex !== void 0 ? _getTabbableIndex : 0,
	    managedChildren,
	    navigateToPrev,
	    navigateToNext,
	    navigateToFirst,
	    navigateToLast
	  });
	  const useListNavigationProps = F(props => {
	    return useLinearNavigationProps(useTypeaheadNavigationProps(props));
	  }, [useLinearNavigationProps, useTypeaheadNavigationProps]);
	  const useListNavigationChild = F(info => {
	    useTypeaheadNavigationChild(info); //const { useLinearNavigationChildProps } = useLinearNavigationChild(info as I);


	    const {
	      useRovingTabIndexChildProps,
	      useRovingTabIndexSiblingProps,
	      tabbable
	    } = useRovingTabIndexChild(info);

	    const useListNavigationChildProps = function (_ref2) {
	      let { ...props
	      } = _ref2;
	      return useMergedProps()(useRovingTabIndexChildProps({
	        onClick: roveToSelf,
	        hidden: info.hidden
	      }), props);
	    };

	    const roveToSelf = F(() => {
	      navigateToIndex(info.index);
	    }, []);
	    return {
	      useListNavigationChildProps,
	      useListNavigationSiblingProps: useRovingTabIndexSiblingProps,
	      tabbable
	    };
	  }, [useTypeaheadNavigationChild, useRovingTabIndexChild, navigateToIndex]);
	  return {
	    useListNavigationChild,
	    useListNavigationProps,
	    currentTypeahead,
	    invalidTypeahead,
	    tabbableIndex,
	    managedChildren,
	    indicesByElement,
	    navigateToIndex,
	    navigateToNext,
	    navigateToPrev,
	    navigateToFirst,
	    navigateToLast,
	    focusCurrent,
	    ...rest
	  };
	}
	function tryNavigateToIndex(managedCells, initial, target, searchDirection, indexMangler, indexDemangler) {
	  function helper() {
	    if (searchDirection === -1) {
	      while (target >= 0 && (managedCells[target] == null || !!((_managedCells$target = managedCells[target]) !== null && _managedCells$target !== void 0 && _managedCells$target.hidden))) {
	        var _managedCells$target;

	        target = indexMangler(indexDemangler(target) - 1);
	      }

	      return target < 0 ? initial : target;
	    } else if (searchDirection === 1) {
	      while (target < managedCells.length && managedCells[target] == null || !!((_managedCells$target2 = managedCells[target]) !== null && _managedCells$target2 !== void 0 && _managedCells$target2.hidden)) {
	        var _managedCells$target2;

	        target = indexMangler(indexDemangler(target) + 1);
	      }

	      return target >= managedCells.length ? initial : target;
	    } else {
	      return initial;
	    }
	  }

	  return helper();
	}

	D(null);

	function useDraggable(_ref) {
	  let {
	    effectAllowed,
	    data,
	    dragImage,
	    dragImageXOffset,
	    dragImageYOffset
	  } = _ref;
	  const [dragging, setDragging, getDragging] = useState(false);
	  const [lastDropEffect, setLastDropEffect, getLastDropEffect] = useState(null);
	  const useDraggableProps = F(p => {
	    const ref = s(null);

	    const onDragStart = e => {
	      //e.preventDefault();
	      setDragging(true);

	      if (e.dataTransfer) {
	        e.dataTransfer.effectAllowed = effectAllowed !== null && effectAllowed !== void 0 ? effectAllowed : "all";
	        if (dragImage) e.dataTransfer.setDragImage(dragImage, dragImageXOffset !== null && dragImageXOffset !== void 0 ? dragImageXOffset : 0, dragImageYOffset !== null && dragImageYOffset !== void 0 ? dragImageYOffset : 0);
	        const entries = Object.entries(data);

	        for (const [mimeType, data] of entries) {
	          e.dataTransfer.setData(mimeType, data);
	        }
	      }
	    };

	    const onDragEnd = e => {
	      e.preventDefault();
	      setDragging(false);

	      if (e.dataTransfer) {
	        if (e.dataTransfer.dropEffect != "none") {
	          setLastDropEffect(e.dataTransfer.dropEffect);
	        } else {
	          setLastDropEffect(null);
	        }
	      }
	    };

	    return useMergedProps()({
	      draggable: true,
	      onDragStart,
	      onDragEnd,
	      ref
	    }, p);
	  }, [effectAllowed, dragImage, dragImageXOffset, dragImageYOffset, ...Object.entries(data).flat()]); // Return both the element and the hook that modifies 
	  // the props and allows us to actually find the element

	  const ret = {
	    useDraggableProps,
	    dragging,
	    getDragging,
	    // Set once a drag has completed with the resulting action
	    // Useful for removing the element afterwards if it was "move"
	    lastDropEffect,

	    /**
	     * Test
	     */
	    getLastDropEffect
	  };
	  return ret;
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	class DroppableFileError extends Error {
	  constructor(fileName, base) {
	    var _base$message;

	    super((_base$message = base === null || base === void 0 ? void 0 : base.message) !== null && _base$message !== void 0 ? _base$message : "An unspecified error occurred reading the file.");

	    _defineProperty(this, "fileName", void 0);

	    _defineProperty(this, "errorType", void 0);

	    this.fileName = fileName;
	    this.errorType = base === null || base === void 0 ? void 0 : base.name;
	  }

	} //MergedProps<UseRefElementPropsReturnType<E, Pick<h.JSX.HTMLAttributes<E>, "onDragEnter" | "onDragLeave" | "onDragOver" | "onDrop">>, P>;

	function useDroppable(_ref) {
	  let {
	    effect
	  } = _ref;
	  const [filesForConsideration, setFilesForConsideration] = useState(null);
	  const [stringsForConsideration, setStringsForConsideration] = useState(null);
	  const [droppedFiles, setDroppedFiles] = useState(null);
	  const [droppedStrings, setDroppedStrings] = useState(null);
	  const [dropError, setDropError] = useState(undefined); // All the promises generated from the drop events.
	  // Used to process multiple drop events in succession

	  const dropPromisesRef = s([]);
	  const [currentPromiseIndex, setCurrentPromiseIndex, getCurrentPromiseIndex] = useState(-1);
	  const [promiseCount, setPromiseCount, getPromiseCount] = useState(0); // Any time we add a new promise, if there's no current promise running, we need to start one.
	  // If there is one, then we don't need to do anything, since it runs the same check.

	  y(() => {
	    const currentPromiseIndex = getCurrentPromiseIndex();
	    const promiseCount = getPromiseCount();

	    if (promiseCount > 0) {
	      if (currentPromiseIndex + 1 < promiseCount) {
	        setCurrentPromiseIndex(i => ++i);
	      }
	    }
	  }, [promiseCount]); // Anytime our current promise changes,
	  // wait for it to finish, then set our state to its result.
	  // Finally, check to see if there are anymore promises.
	  // If there are, then increase currentPromiseCount,
	  // which will trigger this again.
	  //
	  // This shouldn't happen *often*, but maybe in the case of
	  // individually dropping a bunch of large files or something.

	  y(() => {
	    if (currentPromiseIndex >= 0) {
	      const currentPromise = dropPromisesRef.current[currentPromiseIndex];
	      currentPromise.then(info => {
	        if (info !== null) {
	          const {
	            files,
	            strings
	          } = info;
	          setDroppedFiles(files);
	          setDroppedStrings(strings);
	        } // Now that we're done, are there more promises in the queue?


	        const currentPromiseIndex = getCurrentPromiseIndex();
	        const promiseCount = getPromiseCount();

	        if (currentPromiseIndex + 1 < promiseCount) {
	          // Since this promise has started, more have been added.
	          // Run this effect again.
	          setCurrentPromiseIndex(i => ++i);
	        }
	      });
	    }
	  }, [currentPromiseIndex]);

	  const useDroppableProps = p => {
	    //const ref = useRef<E>(null);
	    // Handle collecting the current file metadata or MIME types.
	    const onDragEnter = e => {
	      e.preventDefault();

	      if (e.dataTransfer) {
	        // Is there a default? I can't find one anywhere.
	        e.dataTransfer.dropEffect = effect !== null && effect !== void 0 ? effect : "move";
	        const newMimeTypes = new Set();
	        const newFiles = new Array();

	        for (const item of (_e$dataTransfer$items = (_e$dataTransfer = e.dataTransfer) === null || _e$dataTransfer === void 0 ? void 0 : _e$dataTransfer.items) !== null && _e$dataTransfer$items !== void 0 ? _e$dataTransfer$items : []) {
	          var _e$dataTransfer$items, _e$dataTransfer;

	          const {
	            kind,
	            type
	          } = item;

	          if (kind === "string") {
	            newMimeTypes.add(type);
	          } else if (kind === "file") {
	            newFiles.push({
	              type: item.type
	            });
	          }
	        }

	        setFilesForConsideration(newFiles);
	        setStringsForConsideration(newMimeTypes);
	      }
	    }; // Handle resetting the current file metadata or MIME types


	    const onDragLeave = e => {
	      e.preventDefault();
	      setFilesForConsideration(null);
	      setStringsForConsideration(null);
	    }; // Boilerplate, I guess


	    const onDragOver = e => {
	      e.preventDefault();
	    }; // Handle getting the drop data asynchronously


	    const onDrop = e => {
	      e.preventDefault();
	      setFilesForConsideration(null);
	      setStringsForConsideration(null);
	      const allPromises = new Array();
	      const dropData = {};
	      const dropFile = [];

	      for (const item of (_e$dataTransfer$items2 = (_e$dataTransfer2 = e.dataTransfer) === null || _e$dataTransfer2 === void 0 ? void 0 : _e$dataTransfer2.items) !== null && _e$dataTransfer$items2 !== void 0 ? _e$dataTransfer$items2 : []) {
	        var _e$dataTransfer$items2, _e$dataTransfer2;

	        const {
	          kind,
	          type
	        } = item;

	        if (kind === "string") {
	          allPromises.push(new Promise((resolve, _reject) => item.getAsString(resolve)).then(str => dropData[type] = str));
	        } else if (kind === "file") {
	          const file = item.getAsFile();

	          if (file) {
	            allPromises.push(new Promise((resolve, reject) => {
	              const reader = new FileReader();

	              reader.onload = _ => {
	                resolve();
	                const data = reader.result;
	                dropFile.push({
	                  data,
	                  name: file.name,
	                  type: file.type,
	                  size: data.byteLength,
	                  lastModified: file.lastModified
	                });
	              };

	              reader.onerror = _ => {
	                reject(new DroppableFileError(file.name, reader.error));
	              };

	              reader.onabort = _ => {
	                reject(new DroppableFileError(file.name, reader.error));
	              };

	              reader.readAsArrayBuffer(file);
	            }));
	            dropFile.push();
	          }
	        }
	      }

	      dropPromisesRef.current.push(Promise.all(allPromises).then(() => {
	        setPromiseCount(i => ++i);
	        setDropError(null);
	        return {
	          strings: dropData,
	          files: dropFile
	        };
	      }).catch(ex => {
	        /* eslint-disable no-debugger */
	        debugger;
	        setPromiseCount(i => ++i);
	        setDropError(ex);
	        return null;
	      }));
	    };

	    return useMergedProps()({
	      onDragEnter,
	      onDragLeave,
	      onDragOver,
	      onDrop
	    }, p);
	  };

	  return {
	    useDroppableProps,
	    filesForConsideration,
	    stringsForConsideration,
	    droppedFiles,
	    droppedStrings,
	    dropError
	  };
	}

	/**
	 * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
	 *
	 * Due to typing limitations, this function must be called like this:
	 *
	 * `useEventHandler(element, "input")<InputEvent>(e => {})`
	 *
	 * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
	 *
	 * There is a separate version that attaches event handlers to a set of props.
	 * It takes different event string types (onEvent vs onevent).
	 *
	 * @param target A *non-Preact* node to attach the event to.
	 * @returns
	 * *
	 */

	function useGlobalHandler(target, type, handler, options) {
	  // Note to self: The typing doesn't improve even if this is split up into a sub-function.
	  // No matter what, it seems impossible to get the handler's event object typed perfectly.
	  // It seems like it's guaranteed to always be a union of all available tupes.
	  // Again, no matter what combination of sub- or sub-sub-functions used.
	  let stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
	  if (handler == null) stableHandler = null;
	  y(() => {
	    if (stableHandler) {
	      target.addEventListener(type, stableHandler, options);
	      return () => target.removeEventListener(type, stableHandler, options);
	    }
	  }, [target, type, stableHandler]);
	}

	const activeElementUpdaters = new Map();
	const lastActiveElementUpdaters = new Map();
	const windowFocusedUpdaters = new Map();
	const windowsFocusedUpdaters = new Map();

	function forEachUpdater(window, map, value) {
	  for (const [otherWindow, updaters] of map) {
	    if (window === otherWindow) {
	      for (const updater of updaters) {
	        updater === null || updater === void 0 ? void 0 : updater(value);
	      }
	    }
	  }
	}

	function focusout(e) {
	  const window = e.target.ownerDocument.defaultView;

	  if (e.relatedTarget == null) {
	    forEachUpdater(window, activeElementUpdaters, null);
	  }
	}

	function focusin(e) {
	  const window = e.target.ownerDocument.defaultView;
	  const currentlyFocusedElement = e.target;
	  forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
	  forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
	}

	function windowFocus(e) {
	  const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
	  windowsFocusedUpdaters.set(window, true);
	  forEachUpdater(window, windowFocusedUpdaters, true);
	}

	function windowBlur(e) {
	  const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
	  windowsFocusedUpdaters.set(window, false);
	  forEachUpdater(window, windowFocusedUpdaters, false);
	}
	/**
	 * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
	 * * `getActiveElement()`
	 * * `getLastActiveElement()`
	 * * `getWindowFocused()`
	 *
	 * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
	 *
	 * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
	 *
	 * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
	 */


	function useActiveElement(_ref) {
	  let {
	    onActiveElementChange,
	    onLastActiveElementChange,
	    onWindowFocusedChange,
	    onMount,
	    onUnmount,
	    onMountChange
	  } = _ref;
	  useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, onMountChange, onMount, onUnmount);
	  const {
	    getElement,
	    useRefElementProps
	  } = useRefElement({
	    onMount,
	    onUnmount,
	    onElementChange: F((element, prevValue) => {
	      onMountChange === null || onMountChange === void 0 ? void 0 : onMountChange(element, prevValue);

	      if (element) {
	        var _activeElementUpdater, _activeElementUpdater2, _activeElementUpdater3, _lastActiveElementUpd, _windowFocusedUpdater;

	        const document = element.ownerDocument;
	        const window = document === null || document === void 0 ? void 0 : document.defaultView;

	        if (((_activeElementUpdater = (_activeElementUpdater2 = activeElementUpdaters.get(window)) === null || _activeElementUpdater2 === void 0 ? void 0 : _activeElementUpdater2.size) !== null && _activeElementUpdater !== void 0 ? _activeElementUpdater : 0) === 0) {
	          document === null || document === void 0 ? void 0 : document.addEventListener("focusin", focusin, {
	            passive: true
	          });
	          document === null || document === void 0 ? void 0 : document.addEventListener("focusout", focusout, {
	            passive: true
	          });
	          window === null || window === void 0 ? void 0 : window.addEventListener("focus", windowFocus, {
	            passive: true
	          });
	          window === null || window === void 0 ? void 0 : window.addEventListener("blur", windowBlur, {
	            passive: true
	          });
	        } // Add them even if they're undefined to more easily
	        // manage the ">0 means don't add handlers" logic.


	        const localActiveElementUpdaters = (_activeElementUpdater3 = activeElementUpdaters.get(window)) !== null && _activeElementUpdater3 !== void 0 ? _activeElementUpdater3 : new Set();
	        const localLastActiveElementUpdaters = (_lastActiveElementUpd = lastActiveElementUpdaters.get(window)) !== null && _lastActiveElementUpd !== void 0 ? _lastActiveElementUpd : new Set();
	        const localWindowFocusedUpdaters = (_windowFocusedUpdater = windowFocusedUpdaters.get(window)) !== null && _windowFocusedUpdater !== void 0 ? _windowFocusedUpdater : new Set();
	        localActiveElementUpdaters.add(setActiveElement);
	        localLastActiveElementUpdaters.add(setLastActiveElement);
	        localWindowFocusedUpdaters.add(setWindowFocused);
	        activeElementUpdaters.set(window, localActiveElementUpdaters);
	        lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
	        windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
	        return () => {
	          activeElementUpdaters.get(window).delete(setActiveElement);
	          lastActiveElementUpdaters.get(window).delete(setLastActiveElement);
	          windowFocusedUpdaters.get(window).delete(setWindowFocused);

	          if (activeElementUpdaters.size === 0) {
	            document === null || document === void 0 ? void 0 : document.removeEventListener("focusin", focusin);
	            document === null || document === void 0 ? void 0 : document.removeEventListener("focusout", focusout);
	            window === null || window === void 0 ? void 0 : window.removeEventListener("focus", windowFocus);
	            window === null || window === void 0 ? void 0 : window.removeEventListener("blur", windowBlur);
	          }
	        };
	      }
	    }, [])
	  });
	  const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull$1);
	  const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull$1);
	  const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
	  return {
	    getElement,
	    useActiveElementProps: useRefElementProps,
	    getActiveElement,
	    getLastActiveElement,
	    getWindowFocused
	  };
	}

	function useHasFocus(_ref) {
	  let {
	    onFocusedChanged,
	    onFocusedInnerChanged,
	    onLastFocusedChanged,
	    onLastFocusedInnerChanged,
	    onLastActiveElementChange,
	    onActiveElementChange,
	    onWindowFocusedChange
	  } = _ref;
	  useEnsureStability("useHasFocus", onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange);
	  const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse$1);
	  const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse$1);
	  const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse$1);
	  const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse$1);
	  const {
	    getActiveElement,
	    getLastActiveElement,
	    getWindowFocused,
	    useActiveElementProps,
	    getElement
	  } = useActiveElement({
	    onActiveElementChange: F((activeElement, prevActiveElement) => {
	      const selfElement = getElement();
	      const focused = selfElement != null && selfElement == activeElement;
	      const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(activeElement));
	      setFocused(focused);
	      setFocusedInner(focusedInner);
	      onActiveElementChange === null || onActiveElementChange === void 0 ? void 0 : onActiveElementChange(activeElement, prevActiveElement);
	    }, []),
	    onLastActiveElementChange: F((lastActiveElement, prevLastActiveElement) => {
	      const selfElement = getElement();
	      const focused = selfElement != null && selfElement == lastActiveElement;
	      const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(lastActiveElement));
	      setLastFocused(focused);
	      setLastFocusedInner(focusedInner);
	      onLastActiveElementChange === null || onLastActiveElementChange === void 0 ? void 0 : onLastActiveElementChange(lastActiveElement, prevLastActiveElement);
	    }, []),
	    onWindowFocusedChange
	  });
	  const useHasFocusProps = F(props => {
	    return useActiveElementProps(props);
	  }, [useActiveElementProps]);
	  return {
	    useHasFocusProps,
	    getElement,
	    getFocused,
	    getFocusedInner,
	    getLastFocused,
	    getLastFocusedInner,
	    getActiveElement,
	    getLastActiveElement,
	    getWindowFocused
	  };
	}

	function useInterval(_ref) {
	  let {
	    interval,
	    callback
	  } = _ref;
	  // Get a wrapper around the given callback that's stable
	  const stableCallback = useStableCallback(callback);
	  const getInterval = useStableGetter(interval);
	  y(() => {
	    const interval = getInterval();
	    let lastDelayUsed = interval;
	    if (interval == null) return; // Get a wrapper around the wrapper around the callback
	    // that clears and resets the interval if it changes.

	    const adjustableCallback = () => {
	      stableCallback();
	      const currentInterval = getInterval();

	      if (currentInterval != lastDelayUsed) {
	        clearInterval(handle);
	        if (currentInterval != null) handle = setInterval(adjustableCallback, lastDelayUsed = currentInterval);
	      }
	    };

	    let handle = setInterval(adjustableCallback, interval);
	    return () => clearInterval(handle);
	  }, []);
	}

	/*!
	* tabbable 5.3.3
	* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
	*/
	var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
	var NoElement = typeof Element === 'undefined';
	var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
	var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
	  return element.getRootNode();
	} : function (element) {
	  return element.ownerDocument;
	};

	var isInput = function isInput(node) {
	  return node.tagName === 'INPUT';
	};

	var isHiddenInput = function isHiddenInput(node) {
	  return isInput(node) && node.type === 'hidden';
	};

	var isDetailsWithSummary = function isDetailsWithSummary(node) {
	  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
	    return child.tagName === 'SUMMARY';
	  });
	  return r;
	};

	var isZeroArea = function isZeroArea(node) {
	  var _node$getBoundingClie = node.getBoundingClientRect(),
	      width = _node$getBoundingClie.width,
	      height = _node$getBoundingClie.height;

	  return width === 0 && height === 0;
	};

	var isHidden = function isHidden(node, _ref) {
	  var displayCheck = _ref.displayCheck,
	      getShadowRoot = _ref.getShadowRoot; // NOTE: visibility will be `undefined` if node is detached from the document
	  //  (see notes about this further down), which means we will consider it visible
	  //  (this is legacy behavior from a very long way back)
	  // NOTE: we check this regardless of `displayCheck="none"` because this is a
	  //  _visibility_ check, not a _display_ check

	  if (getComputedStyle(node).visibility === 'hidden') {
	    return true;
	  }

	  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
	  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

	  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
	    return true;
	  } // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
	  //  (but NOT _the_ document; see second 'If' comment below for more).
	  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
	  //  is attached, and the one we need to check if it's in the document or not (because the
	  //  shadow, and all nodes it contains, is never considered in the document since shadows
	  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
	  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
	  //  visibility, including all the nodes it contains). The host could be any normal node,
	  //  or a custom element (i.e. web component). Either way, that's the one that is considered
	  //  part of the document, not the shadow root, nor any of its children (i.e. the node being
	  //  tested).
	  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
	  //  document (per the docs) and while it's a Document-type object, that document does not
	  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
	  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
	  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
	  //  node is actually detached.


	  var nodeRootHost = getRootNode(node).host;
	  var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);

	  if (!displayCheck || displayCheck === 'full') {
	    if (typeof getShadowRoot === 'function') {
	      // figure out if we should consider the node to be in an undisclosed shadow and use the
	      //  'non-zero-area' fallback
	      var originalNode = node;

	      while (node) {
	        var parentElement = node.parentElement;
	        var rootNode = getRootNode(node);

	        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
	        ) {
	          // node has an undisclosed shadow which means we can only treat it as a black box, so we
	          //  fall back to a non-zero-area test
	          return isZeroArea(node);
	        } else if (node.assignedSlot) {
	          // iterate up slot
	          node = node.assignedSlot;
	        } else if (!parentElement && rootNode !== node.ownerDocument) {
	          // cross shadow boundary
	          node = rootNode.host;
	        } else {
	          // iterate up normal dom
	          node = parentElement;
	        }
	      }

	      node = originalNode;
	    } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
	    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
	    //  it might be a falsy value, which means shadow DOM support is disabled
	    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
	    //  now we can just test to see if it would normally be visible or not, provided it's
	    //  attached to the main document.
	    // NOTE: We must consider case where node is inside a shadow DOM and given directly to
	    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.


	    if (nodeIsAttached) {
	      // this works wherever the node is: if there's at least one client rect, it's
	      //  somehow displayed; it also covers the CSS 'display: contents' case where the
	      //  node itself is hidden in place of its contents; and there's no need to search
	      //  up the hierarchy either
	      return !node.getClientRects().length;
	    } // Else, the node isn't attached to the document, which means the `getClientRects()`
	    //  API will __always__ return zero rects (this can happen, for example, if React
	    //  is used to render nodes onto a detached tree, as confirmed in this thread:
	    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
	    //
	    // It also means that even window.getComputedStyle(node).display will return `undefined`
	    //  because styles are only computed for nodes that are in the document.
	    //
	    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
	    //  somehow. Though it was never stated officially, anyone who has ever used tabbable
	    //  APIs on nodes in detached containers has actually implicitly used tabbable in what
	    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
	    //  considering __everything__ to be visible because of the innability to determine styles.

	  } else if (displayCheck === 'non-zero-area') {
	    // NOTE: Even though this tests that the node's client rect is non-zero to determine
	    //  whether it's displayed, and that a detached node will __always__ have a zero-area
	    //  client rect, we don't special-case for whether the node is attached or not. In
	    //  this mode, we do want to consider nodes that have a zero area to be hidden at all
	    //  times, and that includes attached or not.
	    return isZeroArea(node);
	  } // visible, as far as we can tell, or per current `displayCheck` mode


	  return false;
	}; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
	//  unless they are in the _first_ <legend> element of the top-most disabled
	//  fieldset


	var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
	  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
	    var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>

	    while (parentNode) {
	      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
	        // look for the first <legend> among the children of the disabled <fieldset>
	        for (var i = 0; i < parentNode.children.length; i++) {
	          var child = parentNode.children.item(i); // when the first <legend> (in document order) is found

	          if (child.tagName === 'LEGEND') {
	            // if its parent <fieldset> is not nested in another disabled <fieldset>,
	            // return whether `node` is a descendant of its first <legend>
	            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
	          }
	        } // the disabled <fieldset> containing `node` has no <legend>


	        return true;
	      }

	      parentNode = parentNode.parentElement;
	    }
	  } // else, node's tabbable/focusable state should not be affected by a fieldset's
	  //  enabled/disabled state


	  return false;
	};

	var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
	  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
	  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
	    return false;
	  }

	  return true;
	};

	var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

	var isFocusable = function isFocusable(node, options) {
	  options = options || {};

	  if (!node) {
	    throw new Error('No node provided');
	  }

	  if (matches.call(node, focusableCandidateSelector) === false) {
	    return false;
	  }

	  return isNodeMatchingSelectorFocusable(options, node);
	};

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	(function (module, exports) {
	  (function (global, factory) {
	    factory() ;
	  })(commonjsGlobal, function () {

	    var _createClass = function () {
	      function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	          var descriptor = props[i];
	          descriptor.enumerable = descriptor.enumerable || false;
	          descriptor.configurable = true;
	          if ("value" in descriptor) descriptor.writable = true;
	          Object.defineProperty(target, descriptor.key, descriptor);
	        }
	      }

	      return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);
	        if (staticProps) defineProperties(Constructor, staticProps);
	        return Constructor;
	      };
	    }();

	    function _classCallCheck(instance, Constructor) {
	      if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	      }
	    }
	    /**
	     * This work is licensed under the W3C Software and Document License
	     * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
	     */


	    (function () {
	      // Return early if we're not running inside of the browser.
	      if (typeof window === 'undefined') {
	        return;
	      } // Convenience function for converting NodeLists.

	      /** @type {typeof Array.prototype.slice} */


	      var slice = Array.prototype.slice;
	      /**
	       * IE has a non-standard name for "matches".
	       * @type {typeof Element.prototype.matches}
	       */

	      var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
	      /** @type {string} */

	      var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
	      /**
	       * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
	       * attribute.
	       *
	       * Its main functions are:
	       *
	       * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
	       *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
	       *   each focusable node in the subtree with the singleton `InertManager` which manages all known
	       *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
	       *   instance exists for each focusable node which has at least one inert root as an ancestor.
	       *
	       * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
	       *   attribute is removed from the root node). This is handled in the destructor, which calls the
	       *   `deregister` method on `InertManager` for each managed inert node.
	       */


	      var InertRoot = function () {
	        /**
	         * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
	         * @param {!InertManager} inertManager The global singleton InertManager object.
	         */
	        function InertRoot(rootElement, inertManager) {
	          _classCallCheck(this, InertRoot);
	          /** @type {!InertManager} */


	          this._inertManager = inertManager;
	          /** @type {!HTMLElement} */

	          this._rootElement = rootElement;
	          /**
	           * @type {!Set<!InertNode>}
	           * All managed focusable nodes in this InertRoot's subtree.
	           */

	          this._managedNodes = new Set(); // Make the subtree hidden from assistive technology

	          if (this._rootElement.hasAttribute('aria-hidden')) {
	            /** @type {?string} */
	            this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
	          } else {
	            this._savedAriaHidden = null;
	          }

	          this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes


	          this._makeSubtreeUnfocusable(this._rootElement); // Watch for:
	          // - any additions in the subtree: make them unfocusable too
	          // - any removals from the subtree: remove them from this inert root's managed nodes
	          // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
	          //   element, make that node a managed node.


	          this._observer = new MutationObserver(this._onMutation.bind(this));

	          this._observer.observe(this._rootElement, {
	            attributes: true,
	            childList: true,
	            subtree: true
	          });
	        }
	        /**
	         * Call this whenever this object is about to become obsolete.  This unwinds all of the state
	         * stored in this object and updates the state of all of the managed nodes.
	         */


	        _createClass(InertRoot, [{
	          key: 'destructor',
	          value: function destructor() {
	            this._observer.disconnect();

	            if (this._rootElement) {
	              if (this._savedAriaHidden !== null) {
	                this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
	              } else {
	                this._rootElement.removeAttribute('aria-hidden');
	              }
	            }

	            this._managedNodes.forEach(function (inertNode) {
	              this._unmanageNode(inertNode.node);
	            }, this); // Note we cast the nulls to the ANY type here because:
	            // 1) We want the class properties to be declared as non-null, or else we
	            //    need even more casts throughout this code. All bets are off if an
	            //    instance has been destroyed and a method is called.
	            // 2) We don't want to cast "this", because we want type-aware optimizations
	            //    to know which properties we're setting.


	            this._observer =
	            /** @type {?} */
	            null;
	            this._rootElement =
	            /** @type {?} */
	            null;
	            this._managedNodes =
	            /** @type {?} */
	            null;
	            this._inertManager =
	            /** @type {?} */
	            null;
	          }
	          /**
	           * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
	           */

	        }, {
	          key: '_makeSubtreeUnfocusable',

	          /**
	           * @param {!Node} startNode
	           */
	          value: function _makeSubtreeUnfocusable(startNode) {
	            var _this2 = this;

	            composedTreeWalk(startNode, function (node) {
	              return _this2._visitNode(node);
	            });
	            var activeElement = document.activeElement;

	            if (!document.body.contains(startNode)) {
	              // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
	              var node = startNode;
	              /** @type {!ShadowRoot|undefined} */

	              var root = undefined;

	              while (node) {
	                if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
	                  root =
	                  /** @type {!ShadowRoot} */
	                  node;
	                  break;
	                }

	                node = node.parentNode;
	              }

	              if (root) {
	                activeElement = root.activeElement;
	              }
	            }

	            if (startNode.contains(activeElement)) {
	              activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1
	              // calling blur() will not actually move the focus.
	              // To work around this we call focus() on the body instead.

	              if (activeElement === document.activeElement) {
	                document.body.focus();
	              }
	            }
	          }
	          /**
	           * @param {!Node} node
	           */

	        }, {
	          key: '_visitNode',
	          value: function _visitNode(node) {
	            if (node.nodeType !== Node.ELEMENT_NODE) {
	              return;
	            }

	            var element =
	            /** @type {!HTMLElement} */
	            node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of
	            // this inert root, so all of its managed nodes need to be adopted by this InertRoot.

	            if (element !== this._rootElement && element.hasAttribute('inert')) {
	              this._adoptInertRoot(element);
	            }

	            if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
	              this._manageNode(element);
	            }
	          }
	          /**
	           * Register the given node with this InertRoot and with InertManager.
	           * @param {!Node} node
	           */

	        }, {
	          key: '_manageNode',
	          value: function _manageNode(node) {
	            var inertNode = this._inertManager.register(node, this);

	            this._managedNodes.add(inertNode);
	          }
	          /**
	           * Unregister the given node with this InertRoot and with InertManager.
	           * @param {!Node} node
	           */

	        }, {
	          key: '_unmanageNode',
	          value: function _unmanageNode(node) {
	            var inertNode = this._inertManager.deregister(node, this);

	            if (inertNode) {
	              this._managedNodes['delete'](inertNode);
	            }
	          }
	          /**
	           * Unregister the entire subtree starting at `startNode`.
	           * @param {!Node} startNode
	           */

	        }, {
	          key: '_unmanageSubtree',
	          value: function _unmanageSubtree(startNode) {
	            var _this3 = this;

	            composedTreeWalk(startNode, function (node) {
	              return _this3._unmanageNode(node);
	            });
	          }
	          /**
	           * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
	           * @param {!HTMLElement} node
	           */

	        }, {
	          key: '_adoptInertRoot',
	          value: function _adoptInertRoot(node) {
	            var inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,
	            // so register it now if need be.


	            if (!inertSubroot) {
	              this._inertManager.setInert(node, true);

	              inertSubroot = this._inertManager.getInertRoot(node);
	            }

	            inertSubroot.managedNodes.forEach(function (savedInertNode) {
	              this._manageNode(savedInertNode.node);
	            }, this);
	          }
	          /**
	           * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
	           * @param {!Array<!MutationRecord>} records
	           * @param {!MutationObserver} self
	           */

	        }, {
	          key: '_onMutation',
	          value: function _onMutation(records, self) {
	            records.forEach(function (record) {
	              var target =
	              /** @type {!HTMLElement} */
	              record.target;

	              if (record.type === 'childList') {
	                // Manage added nodes
	                slice.call(record.addedNodes).forEach(function (node) {
	                  this._makeSubtreeUnfocusable(node);
	                }, this); // Un-manage removed nodes

	                slice.call(record.removedNodes).forEach(function (node) {
	                  this._unmanageSubtree(node);
	                }, this);
	              } else if (record.type === 'attributes') {
	                if (record.attributeName === 'tabindex') {
	                  // Re-initialise inert node if tabindex changes
	                  this._manageNode(target);
	                } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
	                  // If a new inert root is added, adopt its managed nodes and make sure it knows about the
	                  // already managed nodes from this inert subroot.
	                  this._adoptInertRoot(target);

	                  var inertSubroot = this._inertManager.getInertRoot(target);

	                  this._managedNodes.forEach(function (managedNode) {
	                    if (target.contains(managedNode.node)) {
	                      inertSubroot._manageNode(managedNode.node);
	                    }
	                  });
	                }
	              }
	            }, this);
	          }
	        }, {
	          key: 'managedNodes',
	          get: function get() {
	            return new Set(this._managedNodes);
	          }
	          /** @return {boolean} */

	        }, {
	          key: 'hasSavedAriaHidden',
	          get: function get() {
	            return this._savedAriaHidden !== null;
	          }
	          /** @param {?string} ariaHidden */

	        }, {
	          key: 'savedAriaHidden',
	          set: function set(ariaHidden) {
	            this._savedAriaHidden = ariaHidden;
	          }
	          /** @return {?string} */
	          ,
	          get: function get() {
	            return this._savedAriaHidden;
	          }
	        }]);

	        return InertRoot;
	      }();
	      /**
	       * `InertNode` initialises and manages a single inert node.
	       * A node is inert if it is a descendant of one or more inert root elements.
	       *
	       * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
	       * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
	       * is intrinsically focusable or not.
	       *
	       * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
	       * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
	       * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
	       * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
	       * or removes the `tabindex` attribute if the element is intrinsically focusable.
	       */


	      var InertNode = function () {
	        /**
	         * @param {!Node} node A focusable element to be made inert.
	         * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
	         */
	        function InertNode(node, inertRoot) {
	          _classCallCheck(this, InertNode);
	          /** @type {!Node} */


	          this._node = node;
	          /** @type {boolean} */

	          this._overrodeFocusMethod = false;
	          /**
	           * @type {!Set<!InertRoot>} The set of descendant inert roots.
	           *    If and only if this set becomes empty, this node is no longer inert.
	           */

	          this._inertRoots = new Set([inertRoot]);
	          /** @type {?number} */

	          this._savedTabIndex = null;
	          /** @type {boolean} */

	          this._destroyed = false; // Save any prior tabindex info and make this node untabbable

	          this.ensureUntabbable();
	        }
	        /**
	         * Call this whenever this object is about to become obsolete.
	         * This makes the managed node focusable again and deletes all of the previously stored state.
	         */


	        _createClass(InertNode, [{
	          key: 'destructor',
	          value: function destructor() {
	            this._throwIfDestroyed();

	            if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
	              var element =
	              /** @type {!HTMLElement} */
	              this._node;

	              if (this._savedTabIndex !== null) {
	                element.setAttribute('tabindex', this._savedTabIndex);
	              } else {
	                element.removeAttribute('tabindex');
	              } // Use `delete` to restore native focus method.


	              if (this._overrodeFocusMethod) {
	                delete element.focus;
	              }
	            } // See note in InertRoot.destructor for why we cast these nulls to ANY.


	            this._node =
	            /** @type {?} */
	            null;
	            this._inertRoots =
	            /** @type {?} */
	            null;
	            this._destroyed = true;
	          }
	          /**
	           * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
	           * If the object has been destroyed, any attempt to access it will cause an exception.
	           */

	        }, {
	          key: '_throwIfDestroyed',

	          /**
	           * Throw if user tries to access destroyed InertNode.
	           */
	          value: function _throwIfDestroyed() {
	            if (this.destroyed) {
	              throw new Error('Trying to access destroyed InertNode');
	            }
	          }
	          /** @return {boolean} */

	        }, {
	          key: 'ensureUntabbable',

	          /** Save the existing tabindex value and make the node untabbable and unfocusable */
	          value: function ensureUntabbable() {
	            if (this.node.nodeType !== Node.ELEMENT_NODE) {
	              return;
	            }

	            var element =
	            /** @type {!HTMLElement} */
	            this.node;

	            if (matches.call(element, _focusableElementsString)) {
	              if (
	              /** @type {!HTMLElement} */
	              element.tabIndex === -1 && this.hasSavedTabIndex) {
	                return;
	              }

	              if (element.hasAttribute('tabindex')) {
	                this._savedTabIndex =
	                /** @type {!HTMLElement} */
	                element.tabIndex;
	              }

	              element.setAttribute('tabindex', '-1');

	              if (element.nodeType === Node.ELEMENT_NODE) {
	                element.focus = function () {};

	                this._overrodeFocusMethod = true;
	              }
	            } else if (element.hasAttribute('tabindex')) {
	              this._savedTabIndex =
	              /** @type {!HTMLElement} */
	              element.tabIndex;
	              element.removeAttribute('tabindex');
	            }
	          }
	          /**
	           * Add another inert root to this inert node's set of managing inert roots.
	           * @param {!InertRoot} inertRoot
	           */

	        }, {
	          key: 'addInertRoot',
	          value: function addInertRoot(inertRoot) {
	            this._throwIfDestroyed();

	            this._inertRoots.add(inertRoot);
	          }
	          /**
	           * Remove the given inert root from this inert node's set of managing inert roots.
	           * If the set of managing inert roots becomes empty, this node is no longer inert,
	           * so the object should be destroyed.
	           * @param {!InertRoot} inertRoot
	           */

	        }, {
	          key: 'removeInertRoot',
	          value: function removeInertRoot(inertRoot) {
	            this._throwIfDestroyed();

	            this._inertRoots['delete'](inertRoot);

	            if (this._inertRoots.size === 0) {
	              this.destructor();
	            }
	          }
	        }, {
	          key: 'destroyed',
	          get: function get() {
	            return (
	              /** @type {!InertNode} */
	              this._destroyed
	            );
	          }
	        }, {
	          key: 'hasSavedTabIndex',
	          get: function get() {
	            return this._savedTabIndex !== null;
	          }
	          /** @return {!Node} */

	        }, {
	          key: 'node',
	          get: function get() {
	            this._throwIfDestroyed();

	            return this._node;
	          }
	          /** @param {?number} tabIndex */

	        }, {
	          key: 'savedTabIndex',
	          set: function set(tabIndex) {
	            this._throwIfDestroyed();

	            this._savedTabIndex = tabIndex;
	          }
	          /** @return {?number} */
	          ,
	          get: function get() {
	            this._throwIfDestroyed();

	            return this._savedTabIndex;
	          }
	        }]);

	        return InertNode;
	      }();
	      /**
	       * InertManager is a per-document singleton object which manages all inert roots and nodes.
	       *
	       * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
	       * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
	       * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
	       * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
	       * is created for each such node, via the `_managedNodes` map.
	       */


	      var InertManager = function () {
	        /**
	         * @param {!Document} document
	         */
	        function InertManager(document) {
	          _classCallCheck(this, InertManager);

	          if (!document) {
	            throw new Error('Missing required argument; InertManager needs to wrap a document.');
	          }
	          /** @type {!Document} */


	          this._document = document;
	          /**
	           * All managed nodes known to this InertManager. In a map to allow looking up by Node.
	           * @type {!Map<!Node, !InertNode>}
	           */

	          this._managedNodes = new Map();
	          /**
	           * All inert roots known to this InertManager. In a map to allow looking up by Node.
	           * @type {!Map<!Node, !InertRoot>}
	           */

	          this._inertRoots = new Map();
	          /**
	           * Observer for mutations on `document.body`.
	           * @type {!MutationObserver}
	           */

	          this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.

	          addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.

	          if (document.readyState === 'loading') {
	            document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
	          } else {
	            this._onDocumentLoaded();
	          }
	        }
	        /**
	         * Set whether the given element should be an inert root or not.
	         * @param {!HTMLElement} root
	         * @param {boolean} inert
	         */


	        _createClass(InertManager, [{
	          key: 'setInert',
	          value: function setInert(root, inert) {
	            if (inert) {
	              if (this._inertRoots.has(root)) {
	                // element is already inert
	                return;
	              }

	              var inertRoot = new InertRoot(root, this);
	              root.setAttribute('inert', '');

	              this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.
	              // Ensure inert styles are added there.


	              if (!this._document.body.contains(root)) {
	                var parent = root.parentNode;

	                while (parent) {
	                  if (parent.nodeType === 11) {
	                    addInertStyle(parent);
	                  }

	                  parent = parent.parentNode;
	                }
	              }
	            } else {
	              if (!this._inertRoots.has(root)) {
	                // element is already non-inert
	                return;
	              }

	              var _inertRoot = this._inertRoots.get(root);

	              _inertRoot.destructor();

	              this._inertRoots['delete'](root);

	              root.removeAttribute('inert');
	            }
	          }
	          /**
	           * Get the InertRoot object corresponding to the given inert root element, if any.
	           * @param {!Node} element
	           * @return {!InertRoot|undefined}
	           */

	        }, {
	          key: 'getInertRoot',
	          value: function getInertRoot(element) {
	            return this._inertRoots.get(element);
	          }
	          /**
	           * Register the given InertRoot as managing the given node.
	           * In the case where the node has a previously existing inert root, this inert root will
	           * be added to its set of inert roots.
	           * @param {!Node} node
	           * @param {!InertRoot} inertRoot
	           * @return {!InertNode} inertNode
	           */

	        }, {
	          key: 'register',
	          value: function register(node, inertRoot) {
	            var inertNode = this._managedNodes.get(node);

	            if (inertNode !== undefined) {
	              // node was already in an inert subtree
	              inertNode.addInertRoot(inertRoot);
	            } else {
	              inertNode = new InertNode(node, inertRoot);
	            }

	            this._managedNodes.set(node, inertNode);

	            return inertNode;
	          }
	          /**
	           * De-register the given InertRoot as managing the given inert node.
	           * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
	           * node from the InertManager's set of managed nodes if it is destroyed.
	           * If the node is not currently managed, this is essentially a no-op.
	           * @param {!Node} node
	           * @param {!InertRoot} inertRoot
	           * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
	           */

	        }, {
	          key: 'deregister',
	          value: function deregister(node, inertRoot) {
	            var inertNode = this._managedNodes.get(node);

	            if (!inertNode) {
	              return null;
	            }

	            inertNode.removeInertRoot(inertRoot);

	            if (inertNode.destroyed) {
	              this._managedNodes['delete'](node);
	            }

	            return inertNode;
	          }
	          /**
	           * Callback used when document has finished loading.
	           */

	        }, {
	          key: '_onDocumentLoaded',
	          value: function _onDocumentLoaded() {
	            // Find all inert roots in document and make them actually inert.
	            var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
	            inertElements.forEach(function (inertElement) {
	              this.setInert(inertElement, true);
	            }, this); // Comment this out to use programmatic API only.

	            this._observer.observe(this._document.body || this._document.documentElement, {
	              attributes: true,
	              subtree: true,
	              childList: true
	            });
	          }
	          /**
	           * Callback used when mutation observer detects attribute changes.
	           * @param {!Array<!MutationRecord>} records
	           * @param {!MutationObserver} self
	           */

	        }, {
	          key: '_watchForInert',
	          value: function _watchForInert(records, self) {
	            var _this = this;

	            records.forEach(function (record) {
	              switch (record.type) {
	                case 'childList':
	                  slice.call(record.addedNodes).forEach(function (node) {
	                    if (node.nodeType !== Node.ELEMENT_NODE) {
	                      return;
	                    }

	                    var inertElements = slice.call(node.querySelectorAll('[inert]'));

	                    if (matches.call(node, '[inert]')) {
	                      inertElements.unshift(node);
	                    }

	                    inertElements.forEach(function (inertElement) {
	                      this.setInert(inertElement, true);
	                    }, _this);
	                  }, _this);
	                  break;

	                case 'attributes':
	                  if (record.attributeName !== 'inert') {
	                    return;
	                  }

	                  var target =
	                  /** @type {!HTMLElement} */
	                  record.target;
	                  var inert = target.hasAttribute('inert');

	                  _this.setInert(target, inert);

	                  break;
	              }
	            }, this);
	          }
	        }]);

	        return InertManager;
	      }();
	      /**
	       * Recursively walk the composed tree from |node|.
	       * @param {!Node} node
	       * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
	       *     before descending into child nodes.
	       * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
	       */


	      function composedTreeWalk(node, callback, shadowRootAncestor) {
	        if (node.nodeType == Node.ELEMENT_NODE) {
	          var element =
	          /** @type {!HTMLElement} */
	          node;

	          if (callback) {
	            callback(element);
	          } // Descend into node:
	          // If it has a ShadowRoot, ignore all child elements - these will be picked
	          // up by the <content> or <shadow> elements. Descend straight into the
	          // ShadowRoot.


	          var shadowRoot =
	          /** @type {!HTMLElement} */
	          element.shadowRoot;

	          if (shadowRoot) {
	            composedTreeWalk(shadowRoot, callback);
	            return;
	          } // If it is a <content> element, descend into distributed elements - these
	          // are elements from outside the shadow root which are rendered inside the
	          // shadow DOM.


	          if (element.localName == 'content') {
	            var content =
	            /** @type {!HTMLContentElement} */
	            element; // Verifies if ShadowDom v0 is supported.

	            var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];

	            for (var i = 0; i < distributedNodes.length; i++) {
	              composedTreeWalk(distributedNodes[i], callback);
	            }

	            return;
	          } // If it is a <slot> element, descend into assigned nodes - these
	          // are elements from outside the shadow root which are rendered inside the
	          // shadow DOM.


	          if (element.localName == 'slot') {
	            var slot =
	            /** @type {!HTMLSlotElement} */
	            element; // Verify if ShadowDom v1 is supported.

	            var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
	              flatten: true
	            }) : [];

	            for (var _i = 0; _i < _distributedNodes.length; _i++) {
	              composedTreeWalk(_distributedNodes[_i], callback);
	            }

	            return;
	          }
	        } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
	        // element, nor a <shadow> element recurse normally.


	        var child = node.firstChild;

	        while (child != null) {
	          composedTreeWalk(child, callback);
	          child = child.nextSibling;
	        }
	      }
	      /**
	       * Adds a style element to the node containing the inert specific styles
	       * @param {!Node} node
	       */


	      function addInertStyle(node) {
	        if (node.querySelector('style#inert-style, link#inert-style')) {
	          return;
	        }

	        var style = document.createElement('style');
	        style.setAttribute('id', 'inert-style');
	        style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
	        node.appendChild(style);
	      }

	      if (!HTMLElement.prototype.hasOwnProperty('inert')) {
	        /** @type {!InertManager} */
	        var inertManager = new InertManager(document);
	        Object.defineProperty(HTMLElement.prototype, 'inert', {
	          enumerable: true,

	          /** @this {!HTMLElement} */
	          get: function get() {
	            return this.hasAttribute('inert');
	          },

	          /** @this {!HTMLElement} */
	          set: function set(inert) {
	            inertManager.setInert(this, inert);
	          }
	        });
	      }
	    })();
	  });
	})();

	/**
	 * @license
	 * Copyright 2016 Google Inc. All rights reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	(() => {
	  var _a, _b, _c;
	  /* Symbols for private properties */


	  const _blockingElements = Symbol();

	  const _alreadyInertElements = Symbol();

	  const _topElParents = Symbol();

	  const _siblingsToRestore = Symbol();

	  const _parentMO = Symbol();
	  /* Symbols for private static methods */


	  const _topChanged = Symbol();

	  const _swapInertedSibling = Symbol();

	  const _inertSiblings = Symbol();

	  const _restoreInertedSiblings = Symbol();

	  const _getParents = Symbol();

	  const _getDistributedChildren = Symbol();

	  const _isInertable = Symbol();

	  const _handleMutations = Symbol();

	  class BlockingElementsImpl {
	    constructor() {
	      /**
	       * The blocking elements.
	       */
	      this[_a] = [];
	      /**
	       * Used to keep track of the parents of the top element, from the element
	       * itself up to body. When top changes, the old top might have been removed
	       * from the document, so we need to memoize the inerted parents' siblings
	       * in order to restore their inerteness when top changes.
	       */

	      this[_b] = [];
	      /**
	       * Elements that are already inert before the first blocking element is
	       * pushed.
	       */

	      this[_c] = new Set();
	    }

	    destructor() {
	      // Restore original inertness.
	      this[_restoreInertedSiblings](this[_topElParents]); // Note we don't want to make these properties nullable on the class,
	      // since then we'd need non-null casts in many places. Calling a method on
	      // a BlockingElements instance after calling destructor will result in an
	      // exception.


	      const nullable = this;
	      nullable[_blockingElements] = null;
	      nullable[_topElParents] = null;
	      nullable[_alreadyInertElements] = null;
	    }

	    get top() {
	      const elems = this[_blockingElements];
	      return elems[elems.length - 1] || null;
	    }

	    push(element) {
	      if (!element || element === this.top) {
	        return;
	      } // Remove it from the stack, we'll bring it to the top.


	      this.remove(element);

	      this[_topChanged](element);

	      this[_blockingElements].push(element);
	    }

	    remove(element) {
	      const i = this[_blockingElements].indexOf(element);

	      if (i === -1) {
	        return false;
	      }

	      this[_blockingElements].splice(i, 1); // Top changed only if the removed element was the top element.


	      if (i === this[_blockingElements].length) {
	        this[_topChanged](this.top);
	      }

	      return true;
	    }

	    pop() {
	      const top = this.top;
	      top && this.remove(top);
	      return top;
	    }

	    has(element) {
	      return this[_blockingElements].indexOf(element) !== -1;
	    }
	    /**
	     * Sets `inert` to all document elements except the new top element, its
	     * parents, and its distributed content.
	     */


	    [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
	      const toKeepInert = this[_alreadyInertElements];
	      const oldParents = this[_topElParents]; // No new top, reset old top if any.

	      if (!newTop) {
	        this[_restoreInertedSiblings](oldParents);

	        toKeepInert.clear();
	        this[_topElParents] = [];
	        return;
	      }

	      const newParents = this[_getParents](newTop); // New top is not contained in the main document!


	      if (newParents[newParents.length - 1].parentNode !== document.body) {
	        throw Error('Non-connected element cannot be a blocking element');
	      } // Cast here because we know we'll call _inertSiblings on newParents
	      // below.


	      this[_topElParents] = newParents;

	      const toSkip = this[_getDistributedChildren](newTop); // No previous top element.


	      if (!oldParents.length) {
	        this[_inertSiblings](newParents, toSkip, toKeepInert);

	        return;
	      }

	      let i = oldParents.length - 1;
	      let j = newParents.length - 1; // Find common parent. Index 0 is the element itself (so stop before it).

	      while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
	        i--;
	        j--;
	      } // If up the parents tree there are 2 elements that are siblings, swap
	      // the inerted sibling.


	      if (oldParents[i] !== newParents[j]) {
	        this[_swapInertedSibling](oldParents[i], newParents[j]);
	      } // Restore old parents siblings inertness.


	      i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i)); // Make new parents siblings inert.

	      j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
	    }
	    /**
	     * Swaps inertness between two sibling elements.
	     * Sets the property `inert` over the attribute since the inert spec
	     * doesn't specify if it should be reflected.
	     * https://html.spec.whatwg.org/multipage/interaction.html#inert
	     */


	    [_swapInertedSibling](oldInert, newInert) {
	      const siblingsToRestore = oldInert[_siblingsToRestore]; // oldInert is not contained in siblings to restore, so we have to check
	      // if it's inertable and if already inert.

	      if (this[_isInertable](oldInert) && !oldInert.inert) {
	        oldInert.inert = true;
	        siblingsToRestore.add(oldInert);
	      } // If newInert was already between the siblings to restore, it means it is
	      // inertable and must be restored.


	      if (siblingsToRestore.has(newInert)) {
	        newInert.inert = false;
	        siblingsToRestore.delete(newInert);
	      }

	      newInert[_parentMO] = oldInert[_parentMO];
	      newInert[_siblingsToRestore] = siblingsToRestore;
	      oldInert[_parentMO] = undefined;
	      oldInert[_siblingsToRestore] = undefined;
	    }
	    /**
	     * Restores original inertness to the siblings of the elements.
	     * Sets the property `inert` over the attribute since the inert spec
	     * doesn't specify if it should be reflected.
	     * https://html.spec.whatwg.org/multipage/interaction.html#inert
	     */


	    [_restoreInertedSiblings](elements) {
	      for (const element of elements) {
	        const mo = element[_parentMO];
	        mo.disconnect();
	        element[_parentMO] = undefined;
	        const siblings = element[_siblingsToRestore];

	        for (const sibling of siblings) {
	          sibling.inert = false;
	        }

	        element[_siblingsToRestore] = undefined;
	      }
	    }
	    /**
	     * Inerts the siblings of the elements except the elements to skip. Stores
	     * the inerted siblings into the element's symbol `_siblingsToRestore`.
	     * Pass `toKeepInert` to collect the already inert elements.
	     * Sets the property `inert` over the attribute since the inert spec
	     * doesn't specify if it should be reflected.
	     * https://html.spec.whatwg.org/multipage/interaction.html#inert
	     */


	    [_inertSiblings](elements, toSkip, toKeepInert) {
	      for (const element of elements) {
	        // Assume element is not a Document, so it must have a parentNode.
	        const parent = element.parentNode;
	        const children = parent.children;
	        const inertedSiblings = new Set();

	        for (let j = 0; j < children.length; j++) {
	          const sibling = children[j]; // Skip the input element, if not inertable or to be skipped.

	          if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
	            continue;
	          } // Should be collected since already inerted.


	          if (toKeepInert && sibling.inert) {
	            toKeepInert.add(sibling);
	          } else {
	            sibling.inert = true;
	            inertedSiblings.add(sibling);
	          }
	        } // Store the siblings that were inerted.


	        element[_siblingsToRestore] = inertedSiblings; // Observe only immediate children mutations on the parent.

	        const mo = new MutationObserver(this[_handleMutations].bind(this));
	        element[_parentMO] = mo;
	        let parentToObserve = parent; // If we're using the ShadyDOM polyfill, then our parent could be a
	        // shady root, which is an object that acts like a ShadowRoot, but isn't
	        // actually a node in the real DOM. Observe the real DOM parent instead.

	        const maybeShadyRoot = parentToObserve;

	        if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
	          parentToObserve = maybeShadyRoot.host;
	        }

	        mo.observe(parentToObserve, {
	          childList: true
	        });
	      }
	    }
	    /**
	     * Handles newly added/removed nodes by toggling their inertness.
	     * It also checks if the current top Blocking Element has been removed,
	     * notifying and removing it.
	     */


	    [_handleMutations](mutations) {
	      const parents = this[_topElParents];
	      const toKeepInert = this[_alreadyInertElements];

	      for (const mutation of mutations) {
	        // If the target is a shadowRoot, get its host as we skip shadowRoots when
	        // computing _topElParents.
	        const target = mutation.target.host || mutation.target;
	        const idx = target === document.body ? parents.length : parents.indexOf(target);
	        const inertedChild = parents[idx - 1];
	        const inertedSiblings = inertedChild[_siblingsToRestore]; // To restore.

	        for (let i = 0; i < mutation.removedNodes.length; i++) {
	          const sibling = mutation.removedNodes[i];

	          if (sibling === inertedChild) {
	            console.info('Detected removal of the top Blocking Element.');
	            this.pop();
	            return;
	          }

	          if (inertedSiblings.has(sibling)) {
	            sibling.inert = false;
	            inertedSiblings.delete(sibling);
	          }
	        } // To inert.


	        for (let i = 0; i < mutation.addedNodes.length; i++) {
	          const sibling = mutation.addedNodes[i];

	          if (!this[_isInertable](sibling)) {
	            continue;
	          }

	          if (toKeepInert && sibling.inert) {
	            toKeepInert.add(sibling);
	          } else {
	            sibling.inert = true;
	            inertedSiblings.add(sibling);
	          }
	        }
	      }
	    }
	    /**
	     * Returns if the element is inertable.
	     */


	    [_isInertable](element) {
	      return false === /^(style|template|script)$/.test(element.localName);
	    }
	    /**
	     * Returns the list of newParents of an element, starting from element
	     * (included) up to `document.body` (excluded).
	     */


	    [_getParents](element) {
	      const parents = [];
	      let current = element; // Stop to body.

	      while (current && current !== document.body) {
	        // Skip shadow roots.
	        if (current.nodeType === Node.ELEMENT_NODE) {
	          parents.push(current);
	        } // ShadowDom v1


	        if (current.assignedSlot) {
	          // Collect slots from deepest slot to top.
	          while (current = current.assignedSlot) {
	            parents.push(current);
	          } // Continue the search on the top slot.


	          current = parents.pop();
	          continue;
	        }

	        current = current.parentNode || current.host;
	      }

	      return parents;
	    }
	    /**
	     * Returns the distributed children of the element's shadow root.
	     * Returns null if the element doesn't have a shadow root.
	     */


	    [_getDistributedChildren](element) {
	      const shadowRoot = element.shadowRoot;

	      if (!shadowRoot) {
	        return null;
	      }

	      const result = new Set();
	      let i;
	      let j;
	      let nodes;
	      const slots = shadowRoot.querySelectorAll('slot');

	      if (slots.length && slots[0].assignedNodes) {
	        for (i = 0; i < slots.length; i++) {
	          nodes = slots[i].assignedNodes({
	            flatten: true
	          });

	          for (j = 0; j < nodes.length; j++) {
	            if (nodes[j].nodeType === Node.ELEMENT_NODE) {
	              result.add(nodes[j]);
	            }
	          }
	        } // No need to search for <content>.

	      }

	      return result;
	    }

	  }

	  document.$blockingElements = new BlockingElementsImpl();
	})();

	function blockingElements() {
	  return getDocument().$blockingElements;
	}
	/**
	 * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
	 *
	 * Automatically handles consecutive calls with a loosely applied stack operation
	 * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
	 * it'll take to find its way into the spec, if ever)
	 * @param target
	 */


	function useBlockingElement(enabled, getTarget) {
	  const stableGetTarget = useStableCallback(getTarget);
	  /**
	   * Push/pop the element from the blockingElements stack.
	   */

	  h(() => {
	    const target = stableGetTarget();

	    if (enabled) {
	      // Sometimes blockingElements will fail if, for example,
	      // the target element isn't connected to document.body.
	      // This is rare, but it's better to fail silently with weird tabbing behavior
	      // than to crash the entire application.
	      try {
	        blockingElements().push(target);
	        return () => {
	          blockingElements().remove(target);
	        };
	      } catch (ex) {
	        // Well, semi-silently.
	        console.error(ex);
	      }
	    }
	  }, [enabled]);
	}
	function getTopElement() {
	  return blockingElements().top;
	}

	const elementsToRestoreFocusTo = new Map();
	function useFocusTrap(_ref) {
	  let {
	    trapActive
	  } = _ref;
	  const handleActiveChange = F((trapActive, element) => {
	    if (trapActive && element) {
	      let rafHandle = requestAnimationFrame(() => {
	        // TODO: This extra queueMicrotask is needed for
	        // ...reasons?
	        queueMicrotask(() => {
	          var _findFirstFocusable;

	          (_findFirstFocusable = findFirstFocusable(element)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
	          rafHandle = 0;
	        });
	      });
	      return () => {
	        if (rafHandle) cancelAnimationFrame(rafHandle);
	      };
	    } else if (element) {
	      // Restore the focus to the element
	      // that has returned to the top of the stack
	      let rafHandle = requestAnimationFrame(() => {
	        queueMicrotask(() => {
	          var _elementsToRestoreFoc;

	          (_elementsToRestoreFoc = elementsToRestoreFocusTo.get(getTopElement())) === null || _elementsToRestoreFoc === void 0 ? void 0 : _elementsToRestoreFoc.focus();
	          rafHandle = 0;
	        });
	      });
	      return () => {
	        if (rafHandle) cancelAnimationFrame(rafHandle);
	      };
	    }
	  }, []);
	  const {
	    getLastActiveElement,
	    useActiveElementProps,
	    getElement
	  } = useActiveElement({
	    onMountChange: useStableCallback(element => handleActiveChange(trapActive, element))
	  }); // When the trap becomes active, before we let the blockingElements hook run,
	  // keep track of whatever's currently focused and save it.

	  h(() => {
	    const element = getElement();

	    if (trapActive && element) {
	      var _getLastActiveElement;

	      const document = getDocument(element); // Save the currently focused element
	      // to whatever's currently at the top of the stack

	      elementsToRestoreFocusTo.set(getTopElement(), (_getLastActiveElement = getLastActiveElement()) !== null && _getLastActiveElement !== void 0 ? _getLastActiveElement : document.body);
	    }
	  }, [trapActive]);
	  useBlockingElement(trapActive, getElement);
	  /**
	   * Any time we activate or deactivate the trap,
	   * change focus to something else (something in
	   * the trap if it's active, or whatever we've
	   * tracked in elementsToRestoreFocusTo if not)
	   */

	  h(() => {
	    handleActiveChange(trapActive, getElement());
	  }, [trapActive]);

	  const useFocusTrapProps = props => {
	    const p1 = useActiveElementProps(props);
	    const p2 = {
	      "aria-modal": trapActive ? "true" : undefined
	    };
	    return useMergedProps()(p1, p2);
	  };

	  return {
	    useFocusTrapProps,
	    getElement
	  };
	}
	/**
	 * Returns the first focusable element contained within the given node, or null if none are found.
	 * @param element
	 * @returns
	 */

	function findFirstFocusable(element) {
	  const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
	    acceptNode: node => node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
	  });
	  const firstFocusable = treeWalker.firstChild();
	  return firstFocusable;
	}

	function C(n, t) {
	  for (var e in t) n[e] = t[e];

	  return n;
	}

	function S(n, t) {
	  for (var e in n) if ("__source" !== e && !(e in t)) return !0;

	  for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;

	  return !1;
	}

	function E(n) {
	  this.props = n;
	}

	function g(n, t) {
	  function e(n) {
	    var e = this.props.ref,
	        r = e == n.ref;
	    return !r && e && (e.call ? e(null) : e.current = null), t ? !t(this.props, n) || !r : S(this.props, n);
	  }

	  function r(t) {
	    return this.shouldComponentUpdate = e, v$1(n, t);
	  }

	  return r.displayName = "Memo(" + (n.displayName || n.name) + ")", r.prototype.isReactComponent = !0, r.__f = !0, r;
	}

	(E.prototype = new _()).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function (n, t) {
	  return S(this.props, n) || S(this.state, t);
	};
	var w = l$1.__b;

	l$1.__b = function (n) {
	  n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), w && w(n);
	};

	var A = l$1.__e;

	l$1.__e = function (n, t, e, r) {
	  if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
	  A(n, t, e, r);
	};

	var O = l$1.unmount;

	function L() {
	  this.__u = 0, this.t = null, this.__b = null;
	}

	function U(n) {
	  var t = n.__.__c;
	  return t && t.__e && t.__e(n);
	}

	function M() {
	  this.u = null, this.o = null;
	}

	l$1.unmount = function (n) {
	  var t = n.__c;
	  t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), O && O(n);
	}, (L.prototype = new _()).__c = function (n, t) {
	  var e = t.__c,
	      r = this;
	  null == r.t && (r.t = []), r.t.push(e);

	  var u = U(r.__v),
	      o = !1,
	      i = function () {
	    o || (o = !0, e.__R = null, u ? u(l) : l());
	  };

	  e.__R = i;

	  var l = function () {
	    if (! --r.__u) {
	      if (r.state.__e) {
	        var n = r.state.__e;

	        r.__v.__k[0] = function n(t, e, r) {
	          return t && (t.__v = null, t.__k = t.__k && t.__k.map(function (t) {
	            return n(t, e, r);
	          }), t.__c && t.__c.__P === e && (t.__e && r.insertBefore(t.__e, t.__d), t.__c.__e = !0, t.__c.__P = r)), t;
	        }(n, n.__c.__P, n.__c.__O);
	      }

	      var t;

	      for (r.setState({
	        __e: r.__b = null
	      }); t = r.t.pop();) t.forceUpdate();
	    }
	  },
	      f = !0 === t.__h;

	  r.__u++ || f || r.setState({
	    __e: r.__b = r.__v.__k[0]
	  }), n.then(i, i);
	}, L.prototype.componentWillUnmount = function () {
	  this.t = [];
	}, L.prototype.render = function (n, t) {
	  if (this.__b) {
	    if (this.__v.__k) {
	      var e = document.createElement("div"),
	          r = this.__v.__k[0].__c;

	      this.__v.__k[0] = function n(t, e, r) {
	        return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach(function (n) {
	          "function" == typeof n.__c && n.__c();
	        }), t.__c.__H = null), null != (t = C({}, t)).__c && (t.__c.__P === r && (t.__c.__P = e), t.__c = null), t.__k = t.__k && t.__k.map(function (t) {
	          return n(t, e, r);
	        })), t;
	      }(this.__b, e, r.__O = r.__P);
	    }

	    this.__b = null;
	  }

	  var u = t.__e && v$1(d$1, null, n.fallback);
	  return u && (u.__h = null), [v$1(d$1, null, t.__e ? null : n.children), u];
	};

	var T = function (n, t, e) {
	  if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
	    for (; e.length > 3;) e.pop()();

	    if (e[1] < e[0]) break;
	    n.u = e = e[2];
	  }
	};

	(M.prototype = new _()).__e = function (n) {
	  var t = this,
	      e = U(t.__v),
	      r = t.o.get(n);
	  return r[0]++, function (u) {
	    var o = function () {
	      t.props.revealOrder ? (r.push(u), T(t, n, r)) : u();
	    };

	    e ? e(o) : o();
	  };
	}, M.prototype.render = function (n) {
	  this.u = null, this.o = new Map();
	  var t = A$2(n.children);
	  n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

	  for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);

	  return n.children;
	}, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function () {
	  var n = this;
	  this.o.forEach(function (t, e) {
	    T(n, e, t);
	  });
	};

	var P = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
	    V = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
	    j = "undefined" != typeof document,
	    z = function (n) {
	  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
	};

	_.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (n) {
	  Object.defineProperty(_.prototype, n, {
	    configurable: !0,
	    get: function () {
	      return this["UNSAFE_" + n];
	    },
	    set: function (t) {
	      Object.defineProperty(this, n, {
	        configurable: !0,
	        writable: !0,
	        value: t
	      });
	    }
	  });
	});
	var H = l$1.event;

	function Z() {}

	function Y() {
	  return this.cancelBubble;
	}

	function q() {
	  return this.defaultPrevented;
	}

	l$1.event = function (n) {
	  return H && (n = H(n)), n.persist = Z, n.isPropagationStopped = Y, n.isDefaultPrevented = q, n.nativeEvent = n;
	};

	var J = {
	  configurable: !0,
	  get: function () {
	    return this.class;
	  }
	},
	    K = l$1.vnode;

	l$1.vnode = function (n) {
	  var t = n.type,
	      e = n.props,
	      r = e;

	  if ("string" == typeof t) {
	    var u = -1 === t.indexOf("-");

	    for (var o in r = {}, e) {
	      var i = e[o];
	      j && "children" === o && "noscript" === t || "value" === o && "defaultValue" in e && null == i || ("defaultValue" === o && "value" in e && null == e.value ? o = "value" : "download" === o && !0 === i ? i = "" : /ondoubleclick/i.test(o) ? o = "ondblclick" : /^onchange(textarea|input)/i.test(o + t) && !z(e.type) ? o = "oninput" : /^onfocus$/i.test(o) ? o = "onfocusin" : /^onblur$/i.test(o) ? o = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(o) ? o = o.toLowerCase() : u && V.test(o) ? o = o.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === i && (i = void 0), /^oninput/i.test(o) && (o = o.toLowerCase(), r[o] && (o = "oninputCapture")), r[o] = i);
	    }

	    "select" == t && r.multiple && Array.isArray(r.value) && (r.value = A$2(e.children).forEach(function (n) {
	      n.props.selected = -1 != r.value.indexOf(n.props.value);
	    })), "select" == t && null != r.defaultValue && (r.value = A$2(e.children).forEach(function (n) {
	      n.props.selected = r.multiple ? -1 != r.defaultValue.indexOf(n.props.value) : r.defaultValue == n.props.value;
	    })), n.props = r, e.class != e.className && (J.enumerable = "className" in e, null != e.className && (r.class = e.className), Object.defineProperty(r, "className", J));
	  }

	  n.$$typeof = P, K && K(n);
	};

	var Q = l$1.__r;

	l$1.__r = function (n) {
	  Q && Q(n), n.__c;
	};

	const EventDetail = Symbol("event-detail");
	function enhanceEvent(e, detail) {
	  const event = e;
	  event[EventDetail] = detail;
	  return event;
	}

	let pulse = "vibrate" in navigator ? () => navigator.vibrate(10) : () => {};

	function excludes(target, exclude) {
	  if (exclude !== null && exclude !== void 0 && exclude[target]) return true;
	  return false;
	}
	/**
	 * selection.containsNode doesn't account for selection.isCollapsed,
	 * so here's a workaround for that.
	 *
	 * We also only look for the selection end to only catch the
	 * essense of a non-existant "selectionstop" event.
	 *
	 * @param element
	 * @returns
	 */


	function nodeSelectedTextLength(element) {
	  if (element && element instanceof Node) {
	    const selection = window.getSelection();

	    for (let i = 0; i < ((_selection$rangeCount = selection === null || selection === void 0 ? void 0 : selection.rangeCount) !== null && _selection$rangeCount !== void 0 ? _selection$rangeCount : 0); ++i) {
	      var _selection$rangeCount;

	      const range = selection.getRangeAt(i);

	      if (element.contains(range.endContainer) && !(selection !== null && selection !== void 0 && selection.isCollapsed)) {
	        return selection.toString().length;
	      }
	    }
	  }

	  return 0;
	}
	/**
	 * Adds the necessary event handlers to create a "press"-like event for
	 * buttons and anything else that's "click/tap/press/touch"-able.
	 *
	 * Notably, the following cases are covered:
	 * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
	 * * Double-clicks won't select text.
	 * * Conversely, manually selecting text won't invoke a press.
	 * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
	 * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
	 *
	 * In addition, when the CSS `:active` pseudo-class would apply to a normal button
	 * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
	 * is added to the props.  You can either let it pass through and style it through new CSS,
	 * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
	 *
	 * @param onClickSync
	 * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
	 */


	function usePressEventHandlers(onClickSync, exclude) {
	  const {
	    useRefElementProps,
	    getElement
	  } = useRefElement({}); // A button can be activated in multiple ways, so on the off chance
	  // that multiple are triggered at once, we only *actually* register
	  // a press once all of our "on" signals have turned back to "off".
	  // We approximate this by just incrementing when active, and
	  // decrementing when deactivated.
	  //
	  // As an emergency failsafe, when the element looses focus,
	  // this is reset back to 0.

	  const [active, setActive, getActive] = useState(0); // If we the current text selection changes to include this element
	  // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
	  // because its only purpose was selecting text, not clicking buttons.
	  //
	  // To catch this, any time the text selection includes us while in the middle
	  // of a click, this flag is set, which cancels the activation of a press.
	  // The flag is reset any time the selection is empty or the button is
	  // no longer active.

	  const [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
	  useGlobalHandler(document, "selectionchange", _ => {
	    setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
	  });
	  useEffect(() => {
	    if (active == 0) setTextSelectedDuringActivationStartTime(null);
	  }, [active == 0]);
	  const onActiveStart = useStableCallback(_ => {
	    setActive(a => ++a);
	  });
	  const onActiveStop = useStableCallback(e => {
	    setActive(a => Math.max(0, --a));
	    const currentTime = new Date();
	    const timeDifference = textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime; // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
	    // then this isn't a press event.
	    // TODO: This should measure glyphs instead of characters.

	    if (timeDifference && timeDifference > 250 || nodeSelectedTextLength(getElement()) >= 2) {
	      e.preventDefault();
	      return;
	    }

	    if (getActive() <= 0) {
	      handlePress(e);
	    }
	  });
	  const handlePress = useStableCallback(e => {
	    if (onClickSync) {
	      // Note: The element is focused here because of iOS Safari.
	      //
	      // It's always iOS Safari.
	      //
	      // iOS Safari (tested on 12) downright refuses to allow 
	      // elements to be manually focused UNLESS it happens within
	      // an event handler like this.  It also doesn't focus
	      // buttons by default when clicked, tapped, etc.
	      //
	      // If it becomes problematic that button-likes explicitly become
	      // focused when they are pressed, then an alternative solution for
	      // the question of "how do menu buttons keep their menus open"
	      // and other focus-related nonsense needs to be figured out.
	      //
	      // For iOS Safari.
	      //
	      const element = getElement();
	      if (element && "focus" in element) element === null || element === void 0 ? void 0 : element.focus(); // Whatever the browser was going to do with this event,
	      // forget it. We're turning it into a "press" event.

	      e.preventDefault(); // Also stop anyone else from listening to this event,
	      // since we're explicitly handling it.
	      // (Notably, this allows labels to wrap inputs, with them
	      // both having press event handlers, without double-firing)

	      e.stopPropagation(); // Haptic feedback for this press event

	      pulse(); // Actually call our handler.

	      onClickSync(e);
	    }
	  });
	  const onMouseDown = excludes("click", exclude) ? undefined : e => {
	    // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
	    // but also don't prevent the user from selecting that text manually if they really want to
	    // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
	    if (e.detail > 1) e.preventDefault();
	    if (e.button === 0) onActiveStart(e);
	  };
	  const onMouseUp = excludes("click", exclude) ? undefined : e => {
	    if (e.button === 0 && active > 0) onActiveStop(e);
	  };

	  const onBlur = _ => {
	    setActive(0);
	  };

	  const onMouseLeave = excludes("click", exclude) ? undefined : onBlur;
	  const onKeyDown = excludes("space", exclude) && excludes("enter", exclude) ? undefined : e => {
	    if (e.key == " " && onClickSync && !excludes("space", exclude)) {
	      // We don't actually activate it on a space keydown
	      // but we do preventDefault to stop the page from scrolling.
	      onActiveStart(e);
	      e.preventDefault();
	    }

	    if (e.key == "Enter" && !excludes("enter", exclude)) {
	      e.preventDefault();
	      onActiveStart(e);
	      onActiveStop(e);
	    }
	  };
	  const onKeyUp = excludes("space", exclude) ? undefined : e => {
	    if (e.key == " " && !excludes("space", exclude)) onActiveStop(e);
	  };

	  const onClick = e => {
	    e.preventDefault();

	    if (e.detail > 1) {
	      e.stopImmediatePropagation();
	      e.stopPropagation();
	    }
	  };

	  return props => useRefElementProps(useMergedProps()({
	    onKeyDown,
	    onKeyUp,
	    onBlur,
	    onMouseDown,
	    onMouseUp,
	    onMouseLeave,
	    onClick,
	    style: textSelectedDuringActivationStartTime != null ? {
	      cursor: "text"
	    } : undefined,
	    ...{
	      "data-pseudo-active": active && textSelectedDuringActivationStartTime == null ? "true" : undefined
	    }
	  }, props));
	}

	function useAriaAccordion(_ref) {
	  let {
	    expandedIndex,
	    setExpandedIndex
	  } = _ref;
	  const [lastFocusedIndex, setLastFocusedIndex, _getLastFocusedIndex] = useState(null);
	  const [_currentFocusedIndex, setCurrentFocusedIndex, getCurrentFocusedIndex] = useState(null);
	  const stableSetExpandedIndex = useStableCallback(setExpandedIndex !== null && setExpandedIndex !== void 0 ? setExpandedIndex : () => {});
	  const {
	    managedChildren: managedAccordionSections,
	    useManagedChild: useManagedChildSection
	  } = useChildManager();
	  const navigateToFirst = F(() => {
	    setLastFocusedIndex(0);
	  }, []);
	  const navigateToLast = F(() => {
	    setLastFocusedIndex(managedAccordionSections.length - 1);
	  }, []);
	  const navigateToPrev = F(() => {
	    setLastFocusedIndex(i => (i !== null && i !== void 0 ? i : 0) - 1);
	  }, []);
	  const navigateToNext = F(() => {
	    setLastFocusedIndex(i => (i !== null && i !== void 0 ? i : 0) + 1);
	  }, []);
	  const {
	    useLinearNavigationProps
	  } = useLinearNavigation({
	    managedChildren: managedAccordionSections,
	    navigationDirection: "block",
	    index: lastFocusedIndex !== null && lastFocusedIndex !== void 0 ? lastFocusedIndex : 0,
	    navigateToFirst,
	    navigateToLast,
	    navigateToPrev,
	    navigateToNext
	  });
	  useChildFlag({
	    activatedIndex: expandedIndex,
	    managedChildren: managedAccordionSections,
	    setChildFlag: (i, open) => {
	      var _managedAccordionSect;

	      return (_managedAccordionSect = managedAccordionSections[i]) === null || _managedAccordionSect === void 0 ? void 0 : _managedAccordionSect.setOpenFromParent(open);
	    },
	    getChildFlag: i => {
	      var _managedAccordionSect2, _managedAccordionSect3;

	      return (_managedAccordionSect2 = (_managedAccordionSect3 = managedAccordionSections[i]) === null || _managedAccordionSect3 === void 0 ? void 0 : _managedAccordionSect3.getOpenFromParent()) !== null && _managedAccordionSect2 !== void 0 ? _managedAccordionSect2 : null;
	    }
	  });
	  useChildFlag({
	    activatedIndex: lastFocusedIndex,
	    managedChildren: managedAccordionSections,
	    setChildFlag: (i, open) => open && managedAccordionSections[i].focus(),
	    getChildFlag: _ => false
	  });
	  const useAriaAccordionSection = F(args => {
	    var _ref2, _args$open;

	    const index = args.index;
	    const [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
	    const {
	      useRandomIdProps: useBodyRandomIdProps,
	      useReferencedIdProps: useReferencedBodyIdProps
	    } = useRandomId({
	      prefix: "aria-accordion-section-body-"
	    });
	    const {
	      useRandomIdProps: useHeadRandomIdProps,
	      useReferencedIdProps: useReferencedHeadIdProps
	    } = useRandomId({
	      prefix: "aria-accordion-section-header-"
	    });
	    const open = (_ref2 = (_args$open = args.open) !== null && _args$open !== void 0 ? _args$open : openFromParent) !== null && _ref2 !== void 0 ? _ref2 : null; // TODO: Convert to use useManagedChild so that this hook 
	    // is stable without (directly) depending on the open state.

	    const useAriaAccordionSectionHeader = F(function useAriaAccordionSectionHeader(_ref3) {
	      const {
	        getElement,
	        useHasFocusProps
	      } = useHasFocus({
	        onFocusedChanged: F(focused => {
	          if (focused) setCurrentFocusedIndex(index);else setCurrentFocusedIndex(oldIndex => oldIndex === index ? null : index);
	        }, [])
	      });
	      const focus = F(() => {
	        var _getElement;

	        if (getCurrentFocusedIndex() != null) (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.focus();
	      }, []);
	      const {
	        useManagedChildProps
	      } = useManagedChildSection({
	        index,
	        open,
	        setOpenFromParent,
	        getOpenFromParent,
	        focus
	      });

	      function useAriaAccordionSectionHeaderProps(_ref4) {
	        let {
	          ["aria-expanded"]: ariaExpanded,
	          ["aria-disabled"]: ariaDisabled,
	          ...props
	        } = _ref4;

	        const onFocus = () => {
	          setLastFocusedIndex(args.index);
	        };

	        const onClick = () => {
	          if (getOpenFromParent()) stableSetExpandedIndex(null);else stableSetExpandedIndex(args.index);
	        };

	        const retB = useMergedProps()({
	          tabIndex: 0
	        }, usePressEventHandlers(onClick, undefined)(props));
	        const ret3 = useMergedProps()(useHeadRandomIdProps(useReferencedBodyIdProps("aria-controls")({
	          "aria-expanded": ariaExpanded !== null && ariaExpanded !== void 0 ? ariaExpanded : (!!open).toString(),
	          "aria-disabled": ariaDisabled !== null && ariaDisabled !== void 0 ? ariaDisabled : open ? "true" : undefined,
	          ...useHasFocusProps(useManagedChildProps(retB))
	        })), {
	          onFocus
	        });
	        return useLinearNavigationProps(ret3);
	      }

	      return {
	        useAriaAccordionSectionHeaderProps
	      };
	    }, [useLinearNavigationProps, index, open]);
	    const useAriaAccordionSectionBody = F(function useAriaAccordionSectionBody() {
	      function useAriaAccordionSectionBodyProps(_ref5) {
	        let {
	          role,
	          ...props
	        } = _ref5;
	        const ret1 = useReferencedHeadIdProps("aria-labelledby")({
	          role: role !== null && role !== void 0 ? role : "region",
	          ...props
	        });
	        const ret2 = useBodyRandomIdProps(ret1);
	        return ret2;
	      }

	      return {
	        useAriaAccordionSectionBodyProps
	      };
	    }, []);
	    return {
	      expanded: open,
	      useAriaAccordionSectionHeader,
	      useAriaAccordionSectionBody
	    };
	  }, [useLinearNavigationProps]);
	  return {
	    useAriaAccordionSection,
	    managedChildren: managedAccordionSections
	  };
	}

	/**
	 * Adds an ID and "aria-labelledby" for two elements, an "input" element and a "label" element.
	 *
	 * Returns the `useReferencedIdProps` hooks if you need to also add other ID-referencing attributes, like `for`
	 *
	 * @see useInputLabel
	 */

	function useGenericLabel() {
	  let {
	    labelPrefix,
	    inputPrefix,
	    backupText
	  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
	    labelPrefix: "label-",
	    inputPrefix: "input-"
	  };
	  const [labelElement, setLabelElement] = d(null);
	  const [inputElement, setInputElement] = d(null);
	  const {
	    getElement: getLabelElement,
	    useRefElementProps: useLabelRefElementProps
	  } = useRefElement({
	    onElementChange: setLabelElement
	  });
	  const {
	    getElement: getInputElement,
	    useRefElementProps: useInputRefElementProps
	  } = useRefElement({
	    onElementChange: setInputElement
	  });
	  const {
	    useRandomIdProps: useLabelRandomIdProps,
	    id: labelId,
	    useReferencedIdProps: useReferencedLabelIdProps
	  } = useRandomId({
	    prefix: labelPrefix
	  });
	  const {
	    useRandomIdProps: useInputRandomIdProps,
	    id: inputId,
	    useReferencedIdProps: useReferencedInputIdProps
	  } = useRandomId({
	    prefix: inputPrefix
	  });
	  const labelHasMounted = !!labelElement;
	  const useGenericLabelLabel = F(function useGenericLabelLabel() {
	    return {
	      useGenericLabelLabelProps: props => {
	        return useLabelRandomIdProps(useLabelRefElementProps(props));
	      }
	    };
	  }, []);
	  const useGenericLabelInput = F(function useGenericLabelInput() {
	    return {
	      useGenericLabelInputProps: _ref => {
	        var _ref2;

	        let {
	          "aria-labelledby": ariaLabelledby,
	          "aria-label": ariaLabel,
	          ...props
	        } = _ref;
	        console.assert(!ariaLabelledby);
	        return useInputRandomIdProps(useReferencedLabelIdProps("aria-labelledby")(useInputRefElementProps(useMergedProps()({
	          "aria-label": (_ref2 = !labelHasMounted ? backupText : ariaLabel) !== null && _ref2 !== void 0 ? _ref2 : ariaLabel
	        }, props))));
	      }
	    };
	  }, [labelHasMounted]);
	  return {
	    useGenericLabelInput,
	    useGenericLabelLabel,
	    useReferencedLabelIdProps,
	    useReferencedInputIdProps,
	    labelId,
	    inputId,
	    labelElement,
	    inputElement,
	    getLabelElement,
	    getInputElement
	  };
	}
	/**
	 * Handles the attributes `id`, `for`, and `aria-labelledby` for to related elements.
	 *
	 * It's assumed that the label is an `HTMLLabelElement`, and the input is something for which
	 * the `for` attribute can reference.
	 *
	 */

	function useInputLabel() {
	  let {
	    labelPrefix,
	    inputPrefix
	  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
	    labelPrefix: "label-",
	    inputPrefix: "input-"
	  };
	  const {
	    useGenericLabelInput,
	    useGenericLabelLabel,
	    useReferencedInputIdProps,
	    inputId,
	    labelId,
	    inputElement,
	    getInputElement,
	    labelElement,
	    getLabelElement
	  } = useGenericLabel({
	    labelPrefix,
	    inputPrefix
	  });
	  const useInputLabelLabel = F(function useInputLabelLabel(_ref3) {
	    let {
	      tag
	    } = _ref3;
	    const {
	      useGenericLabelLabelProps
	    } = useGenericLabelLabel();
	    return {
	      useInputLabelLabelProps(props) {
	        const withFor = useReferencedInputIdProps("for")(props);
	        const withoutFor = props;
	        return useGenericLabelLabelProps(tag == "label" ? withFor : withoutFor);
	      }

	    };
	  }, [useGenericLabelInput]);
	  const useInputLabelInput = F(function useInputLabelInput() {
	    const {
	      useGenericLabelInputProps
	    } = useGenericLabelInput();
	    return {
	      useInputLabelInputProps(props) {
	        return useGenericLabelInputProps(props);
	      }

	    };
	  }, [useGenericLabelLabel]);
	  return {
	    useInputLabelLabel,
	    useInputLabelInput,
	    labelId,
	    inputId,
	    inputElement,
	    labelElement,
	    getInputElement,
	    getLabelElement
	  };
	}

	const handlesInput = (tag, labelPosition, which) => {
	  if (labelPosition === "separate") {
	    if (which === "input-element") return true;else if (which === "label-element") return tag != "input";
	  } else if (labelPosition === "wrapping") {
	    if (which === "input-element") return false;
	    if (which == "label-element") return true;
	  }
	};
	/**
	 * Handles label type (wrapping or separate) for checkboxes, radios, switches, etc.
	 * @param param0
	 * @returns
	 */


	function useCheckboxLike(_ref4) {
	  let {
	    checked,
	    disabled,
	    labelPosition,
	    onInput,
	    role
	  } = _ref4;
	  const stableOnInput = useStableCallback(e => {
	    e.preventDefault();
	    onInput === null || onInput === void 0 ? void 0 : onInput(e);
	  });
	  const {
	    useInputLabelInput: useILInput,
	    useInputLabelLabel: useILLabel,
	    getLabelElement,
	    getInputElement
	  } = useInputLabel({
	    labelPrefix: "aria-checkbox-label-",
	    inputPrefix: "aria-checkbox-input-"
	  });
	  const useCheckboxLikeInputElement = F(function useCheckboxInputElement(_ref5) {
	    let {
	      tag
	    } = _ref5;
	    const {
	      useInputLabelInputProps: useILInputProps
	    } = useILInput();
	    const {
	      useRefElementProps,
	      getElement
	    } = useRefElement({}); // onClick and onChange are a bit messy, so we need to
	    // *always* make sure that the visible state is correct
	    // after all the event dust settles.
	    // See https://github.com/preactjs/preact/issues/2745,
	    // and https://github.com/preactjs/preact/issues/1899#issuecomment-525690194

	    y(() => {
	      const element = getElement();

	      if (element && tag == "input") {
	        element.checked = checked;
	      }
	    }, [tag, checked]);
	    return {
	      getInputElement: getElement,
	      useCheckboxLikeInputElementProps
	    };

	    function useCheckboxLikeInputElementProps(_ref6) {
	      let { ...p0
	      } = _ref6;
	      // For some reason, Chrome won't fire onInput events for radio buttons that are tabIndex=-1??
	      // Needs investigating, but onInput works fine in Firefox
	      // TODO
	      let props = usePressEventHandlers(disabled || !handlesInput(tag, labelPosition, "input-element") ? undefined : stableOnInput, undefined)({});
	      if (tag == "input") props.onInput = e => e.preventDefault();
	      props = useRefElementProps(useILInputProps(props));

	      if (labelPosition == "wrapping") {
	        // Because the wrapped label handles all interactions,
	        // we need to make sure this element can't be interacted with
	        // even if it's an input element.
	        props.inert = true;
	        props.tabIndex = -1;

	        props.onFocus = _ => getLabelElement().focus();
	      } else {
	        if (tag === "input") {
	          props.checked = checked;
	        } else {
	          props.role = role;
	          props.tabIndex = 0;
	          props["aria-checked"] = checked ? "true" : undefined;
	        }

	        props["aria-disabled"] = disabled.toString();
	      } // Make sure that label clicks can't affect the checkbox while it's disabled


	      props.onClick = disabled ? e => {
	        e.preventDefault();
	      } : props.onClick;
	      return useMergedProps()(p0, props);
	    }
	  }, [useILInput, role, labelPosition, disabled, checked]);
	  const useCheckboxLikeLabelElement = F(function useCheckboxLabelElement(_ref7) {
	    let {
	      tag
	    } = _ref7;
	    const {
	      useInputLabelLabelProps: useILLabelProps
	    } = useILLabel({
	      tag
	    });

	    function useCheckboxLikeLabelElementProps(_ref8) {
	      let { ...p0
	      } = _ref8;
	      const newProps = usePressEventHandlers(disabled || !handlesInput(tag, labelPosition, "label-element") ? undefined : stableOnInput, undefined)({});

	      if (labelPosition == "wrapping") {
	        if (p0.tabIndex == null) newProps.tabIndex = 0;
	        if (p0.role == null) newProps.role = role;
	        newProps["aria-disabled"] = disabled.toString();
	        newProps["aria-checked"] = checked.toString();
	      } // Just make sure that label clicks can't affect the checkbox while it's disabled


	      newProps.onClick = disabled ? e => {
	        e.preventDefault();
	      } : newProps.onClick;
	      return useMergedProps()(newProps, useILLabelProps(p0));
	    }

	    return {
	      useCheckboxLikeLabelElementProps
	    };
	  }, [useILLabel, disabled, checked, role, labelPosition]);
	  return {
	    useCheckboxLikeInputElement,
	    useCheckboxLikeLabelElement,
	    getLabelElement,
	    getInputElement
	  };
	}

	function useAriaCheckbox(_ref) {
	  let {
	    labelPosition,
	    checked,
	    onInput,
	    disabled
	  } = _ref;

	  const onInputEnhanced = e => onInput === null || onInput === void 0 ? void 0 : onInput(enhanceEvent(e, {
	    checked: !checked
	  }));

	  const {
	    useCheckboxLikeInputElement,
	    useCheckboxLikeLabelElement
	  } = useCheckboxLike({
	    checked: !!checked,
	    labelPosition,
	    role: "checkbox",
	    disabled,
	    onInput: onInputEnhanced
	  });
	  const useCheckboxInputElement = F(function useCheckboxInputElement(_ref2) {
	    let {
	      tag
	    } = _ref2;
	    const {
	      getInputElement,
	      useCheckboxLikeInputElementProps
	    } = useCheckboxLikeInputElement({
	      tag
	    });
	    const isMixed = checked == "mixed";
	    y(() => {
	      const inputElement = getInputElement();

	      if (inputElement && tag === "input") {
	        inputElement.indeterminate = isMixed;
	      }
	    }, [isMixed, tag]);
	    return {
	      useCheckboxInputElementProps
	    };

	    function useCheckboxInputElementProps(_ref3) {
	      var _props$checked;

	      let { ...p0
	      } = _ref3;
	      const props = useCheckboxLikeInputElementProps(p0);
	      (_props$checked = props.checked) !== null && _props$checked !== void 0 ? _props$checked : props.checked = !!checked;
	      if (tag == "input") props.type = "checkbox";
	      return props;
	    }
	  }, [useCheckboxLikeInputElement, checked, labelPosition, disabled]);
	  const useCheckboxLabelElement = F(function useCheckboxLabelElement(_ref4) {
	    let {
	      tag
	    } = _ref4;
	    const {
	      useCheckboxLikeLabelElementProps
	    } = useCheckboxLikeLabelElement({
	      tag
	    });

	    function useCheckboxLabelElementProps(_ref5) {
	      let { ...props
	      } = _ref5;
	      return useCheckboxLikeLabelElementProps(props);
	    }

	    return {
	      useCheckboxLabelElementProps
	    };
	  }, [useCheckboxLikeLabelElement, disabled, labelPosition]);
	  return {
	    useCheckboxInputElement,
	    useCheckboxLabelElement
	  };
	}

	/**
	 *
	 *
	 * @param param0
	 * @returns
	 */

	function useCheckboxGroup(_ref) {
	  let {
	    collator,
	    keyNavigation,
	    shouldFocusOnChange,
	    onUpdateChildren: onUpdateChildrenUnstable
	  } = _ref;
	  const onUpdateChildren = useStableCallback(onUpdateChildrenUnstable);
	  const {
	    managedChildren,
	    useListNavigationChild,
	    useListNavigationProps,
	    tabbableIndex,
	    focusCurrent,
	    currentTypeahead,
	    invalidTypeahead
	  } = useListNavigation({
	    collator,
	    keyNavigation,
	    shouldFocusOnChange
	  }); //const [uncheckedCount, setUnheckedCount] = useState(0);

	  const [checkedCount, setCheckedCount] = useState(0);
	  const checkedIndices = s(new Set()); //const [selfIsChecked, setSelfIsChecked, getSelfIsChecked] = useState<boolean | "mixed">(false);

	  const getSelfIsCheckedUnstable = F(() => {
	    const percentage = checkedCount / managedChildren.length;
	    return percentage <= 0 ? false : percentage >= 1 ? true : "mixed";
	  }, [checkedCount, managedChildren.length]);
	  const getSelfIsCheckedStable = useStableCallback(getSelfIsCheckedUnstable); // If the user has changed the parent checkbox's value, then this ref holds a memory of what values were held before.
	  // Otherwise, it's null when the last input was from a child checkbox. 

	  const savedCheckedValues = s(null);
	  const onCheckboxGroupParentInput = F(e => {
	    e.preventDefault();
	    const selfIsChecked = getSelfIsCheckedStable();

	    if (selfIsChecked === true || selfIsChecked === false && savedCheckedValues.current == null) {
	      return onUpdateChildren(enhanceEvent(e, {
	        childrenChecked: false
	      }));
	    } else if (selfIsChecked === "mixed") {
	      savedCheckedValues.current = new Map();

	      for (const child of managedChildren) {
	        savedCheckedValues.current.set(child.index, child.getChecked());
	      }

	      return onUpdateChildren(enhanceEvent(e, {
	        childrenChecked: true
	      }));
	    } else {
	      var _savedCheckedValues$c;

	      return onUpdateChildren(enhanceEvent(e, {
	        childrenChecked: (_savedCheckedValues$c = savedCheckedValues.current) !== null && _savedCheckedValues$c !== void 0 ? _savedCheckedValues$c : true
	      }));
	    }
	  }, []); // Keep track of all child IDs, and any time any of them change, 
	  // generate a new string with all of them concatenated together
	  // (but only once per render);

	  const allIds = s(new Set());
	  const [ariaControls, setAriaControls] = useState("");
	  const [updateIndex, setIdUpdateIndex] = useState(0);
	  const notifyChecked = F((index, checked) => {
	    if (checked === true) {
	      if (!checkedIndices.current.has(index)) {
	        setCheckedCount(c => c + 1);
	        checkedIndices.current.add(index);
	      }
	    } else {
	      if (checkedIndices.current.has(index)) {
	        setCheckedCount(c => c - 1);
	        checkedIndices.current.delete(index);
	      }
	    }
	  }, [setCheckedCount, checkedIndices]);
	  /*useEffect(() => {
	      let percentage = checkedCount / managedChildren.length;
	      setSelfIsChecked(percentage <= 0 ? false : percentage >= 1 ? true : "mixed")
	  }, [setSelfIsChecked, managedChildren.length, checkedCount]);*/

	  const useCheckboxGroupParentProps = F(props => {
	    return useMergedProps()({
	      "aria-controls": ariaControls
	    }, props);
	  }, [ariaControls]);
	  useEffect(() => {
	    setAriaControls(Array.from(allIds.current).join(" "));
	  }, [updateIndex]);
	  const useCheckboxGroupChild = F(function (_ref2) {
	    let {
	      index,
	      text,
	      checked,
	      id,
	      ...rest
	    } = _ref2;
	    const getChecked = useStableGetter(checked);
	    useEffect(() => {
	      allIds.current.add(id);
	      setIdUpdateIndex(i => ++i);
	      return () => {
	        allIds.current.delete(id);
	        setIdUpdateIndex(i => ++i);
	      };
	    }, [id]);
	    useEffect(() => {
	      notifyChecked(index, checked);
	    }, [index, checked]);
	    const {
	      tabbable,
	      useListNavigationChildProps
	    } = useListNavigationChild({
	      index,
	      text,
	      id,
	      getChecked,
	      ...rest
	    });
	    return {
	      tabbable,
	      useCheckboxGroupChildProps: F(props => useMergedProps()({}, useListNavigationChildProps(useListNavigationProps(props))), [useListNavigationProps, useListNavigationChildProps])
	    };
	  }, [useListNavigationProps, notifyChecked, useListNavigationChild]);
	  return {
	    managedCheckboxes: managedChildren,
	    useCheckboxGroupChild,
	    useCheckboxGroupParentProps,
	    parentIsChecked: getSelfIsCheckedUnstable(),
	    parentPercentChecked: checkedCount / managedChildren.length,
	    onCheckboxGroupParentInput,
	    tabbableIndex,
	    focus: focusCurrent,
	    currentTypeahead,
	    invalidTypeahead,
	    managedChildren
	  };
	}

	/**
	 * Adds event handlers for a modal-like soft-dismiss interaction.
	 *
	 * That is, any clicks or taps outside of the given component,
	 * or any time the Escape key is pressed within the component,
	 * (with various browser oddities regarding clicks on blank or inert areas handled)
	 * the component will request to close itself.
	 *
	 * Of course, if you don't do anything in the `onClose` function,
	 * it won't be a soft dismiss anymore.
	 *
	 * @param param0
	 * @returns
	 */

	function useSoftDismiss(_ref) {
	  let {
	    onClose,
	    getElements
	  } = _ref;
	  const stableOnClose = useStableCallback(onClose);
	  const stableGetElements = useStableCallback(getElements);
	  const getOpen = useStableGetter(open);
	  const onBackdropClick = F(function onBackdropClick(e) {
	    var _getElement;

	    const document = (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.ownerDocument; // Basically, "was this event fired on the root-most element, or at least an element not contained by the modal?"
	    // Either could be how the browser handles these sorts of "interacting with nothing" events.

	    if (e.target == (document === null || document === void 0 ? void 0 : document.documentElement)) {
	      stableOnClose("backdrop");
	    }

	    let elements = stableGetElements();

	    if (elements && e.target instanceof Element) {
	      if (!Array.isArray(elements)) elements = [elements];
	      let foundInsideClick = false;

	      for (const element of elements) {
	        if (element.contains(e.target)) {
	          foundInsideClick = true;
	          break;
	        }
	      }

	      if (!foundInsideClick) onClose("backdrop");
	    }
	  }, []);
	  const {
	    useActiveElementProps,
	    getElement
	  } = useActiveElement({
	    onLastActiveElementChange: F(newElement => {
	      let validFocusableElements = stableGetElements();

	      if (validFocusableElements) {
	        if (!Array.isArray(validFocusableElements)) validFocusableElements = [validFocusableElements];

	        for (const focusable of validFocusableElements) {
	          if (focusable !== null && focusable !== void 0 && focusable.contains(newElement)) return;
	        }
	      }

	      onClose("lost-focus");
	    }, [])
	  });
	  const {
	    useRefElementProps
	  } = useRefElement({
	    onElementChange: F(e => {
	      const document = e === null || e === void 0 ? void 0 : e.ownerDocument;
	      const window = document === null || document === void 0 ? void 0 : document.defaultView; // Since everything else is inert, we listen for captured clicks on the window
	      // (we don't use onClick since that doesn't fire when clicked on empty/inert areas)
	      // Note: We need a *separate* touch event on mobile Safari, because
	      // it doesn't let click events bubble or be captured from traditionally non-interactive elements,
	      // but touch events work as expected.

	      const mouseDown = e => {
	        if (getOpen()) onBackdropClick(e);
	      };

	      const touchStart = e => {
	        if (getOpen()) onBackdropClick(e);
	      };

	      const keyDown = e => {
	        if (e.key === "Escape") {
	          stableOnClose("escape");
	        }
	      };

	      window === null || window === void 0 ? void 0 : window.addEventListener("mousedown", mouseDown, {
	        capture: true
	      });
	      window === null || window === void 0 ? void 0 : window.addEventListener("touchstart", touchStart, {
	        capture: true
	      });
	      window === null || window === void 0 ? void 0 : window.addEventListener("keydown", keyDown);
	      return () => {
	        window === null || window === void 0 ? void 0 : window.removeEventListener("mousedown", mouseDown);
	        window === null || window === void 0 ? void 0 : window.removeEventListener("touchstart", touchStart);
	        window === null || window === void 0 ? void 0 : window.removeEventListener("keydown", keyDown);
	      };
	    }, [])
	  });
	  return {
	    useSoftDismissProps: F(props => useActiveElementProps(useRefElementProps(props)), [useActiveElementProps, useRefElementProps])
	  };
	}
	/**
	 * A generic modal hook, used by modal dialogs, but can also
	 * be used by anything that's modal with a backdrop.
	 * @param param0
	 * @returns
	 */

	function useModal(_ref2) {
	  let {
	    open,
	    onClose
	  } = _ref2;
	  const stableOnClose = useStableCallback(onClose);
	  const [modalDescribedByBody, setModalDescribedByBody] = useState(false);
	  useHideScroll(open);
	  const {
	    useRandomIdProps: useModalIdProps
	  } = useRandomId({
	    prefix: "aria-modal-"
	  });
	  const {
	    useRandomIdProps: useBodyIdProps,
	    useReferencedIdProps: useBodyReferencingIdProps
	  } = useRandomId({
	    prefix: "aria-modal-body-"
	  });
	  const {
	    useRandomIdProps: useTitleIdProps,
	    useReferencedIdProps: useTitleReferencingIdProps
	  } = useRandomId({
	    prefix: "aria-modal-title-"
	  });
	  const {
	    useRefElementProps: useModalRefElement,
	    getElement: getModalElement
	  } = useRefElement({});
	  const {
	    useSoftDismissProps
	  } = useSoftDismiss({
	    onClose: stableOnClose,
	    getElements: getModalElement
	  });
	  const useModalBackdrop = F(function useModalBackdrop() {
	    function useModalBackdropProps(props) {
	      return useMergedProps()({
	        onPointerUp: () => stableOnClose("backdrop")
	      }, props);
	    }

	    return {
	      useModalBackdropProps
	    };
	  }, []);

	  const useModalProps = function (_ref3) {
	    let {
	      "aria-modal": ariaModal,
	      role,
	      ...p0
	    } = _ref3;
	    console.assert(!ariaModal);
	    const {
	      useFocusTrapProps
	    } = useFocusTrap({
	      trapActive: open
	    });
	    const p1 = useTitleReferencingIdProps("aria-labelledby")(p0);
	    const p2 = useModalIdProps(p1);
	    const pFinal = useBodyReferencingIdProps("aria-describedby")(p2);
	    return useFocusTrapProps(useSoftDismissProps(useMergedProps()(useModalRefElement({
	      role: role || "dialog"
	    }), modalDescribedByBody ? pFinal : p2)));
	  };

	  const useModalTitle = F(function useModalTitle() {
	    const useModalTitleProps = function (props) {
	      return useTitleIdProps(props);
	    };

	    return {
	      useModalTitleProps
	    };
	  }, []);
	  const useModalBody = F(function useModalBody(_ref4) {
	    let {
	      descriptive
	    } = _ref4;
	    setModalDescribedByBody(descriptive);

	    const useModalBodyProps = function (props) {
	      return useBodyIdProps(props);
	    };

	    return {
	      useModalBodyProps
	    };
	  }, []);
	  return {
	    useModalProps,
	    useModalTitle,
	    useModalBody,
	    useModalBackdrop
	  };
	}
	/**
	 * Allows for hiding the scroll bar of the root HTML element
	 * without shifting the layout of the page more than adding a fow pixels
	 * of padding to the root element if necessary.
	 * @param hideScroll
	 */

	function useHideScroll(hideScroll) {
	  const [getScrollbarWidth, setScrollbarWidth] = usePassiveState(null);
	  const [getScrollbarHeight, setScrollbarHeight] = usePassiveState(null);
	  y(() => {
	    if (hideScroll) {
	      // When scrolling is resumed, we'll need to restore the original scroll positions
	      // so we need to keep this information around
	      const originalScrollTop = document.documentElement.scrollTop;
	      const originalScrollLeft = document.documentElement.scrollLeft; // Measure the width of the page (minus the scrollbar)

	      const widthWithScrollBar = document.documentElement.scrollWidth;
	      const heightWithScrollBar = document.documentElement.scrollHeight; // Apply a class that hides the scrollbar.

	      document.documentElement.classList.add("document-scroll-hidden"); // In case multiple things are locking scroll, keep track of how many are doing that
	      // (just add 1 on enable, subtract 1 on disable)

	      document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") + 1).toString(); // Measure the new width without a scrollbar 
	      // so we can take the difference as the scrollbar width.

	      const widthWithoutScrollBar = document.documentElement.scrollWidth;
	      const heightWithoutScrollBar = document.documentElement.scrollHeight;
	      let scrollbarWidth = widthWithoutScrollBar - widthWithScrollBar;
	      let scrollbarHeight = heightWithoutScrollBar - heightWithScrollBar; // Failsafe -- if this measuring trick does something unexpected, just ignore it

	      if (scrollbarWidth > 80) scrollbarWidth = 0;
	      if (scrollbarHeight > 80) scrollbarHeight = 0; // Make our measurements available as CSS properties for general use

	      document.documentElement.style.setProperty("--root-scrollbar-width", `${scrollbarWidth}px`);
	      document.documentElement.style.setProperty("--root-scrollbar-height", `${scrollbarHeight}px`);
	      document.documentElement.style.setProperty("--root-scrollstop-top", `${originalScrollTop}px`);
	      document.documentElement.style.setProperty("--root-scrollstop-left", `${originalScrollLeft}px`);
	      setScrollbarWidth(scrollbarWidth);
	      setScrollbarHeight(scrollbarHeight);
	      return () => {
	        // Undo all the things we just did
	        document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") - 1).toString();

	        if (document.documentElement.dataset["scrollHiders"] == "0") {
	          // If we were the last scroll-locking thing to stop, then remove the class that stops scrolling.
	          document.documentElement.removeAttribute("data-scroll-hiders");
	          document.documentElement.classList.remove("document-scroll-hidden"); // Also, restore the original scroll position
	          // We do this by forcing the scroll behavior to not be smooth
	          // (it's instant if nothing is set to smooth, https://www.w3.org/TR/cssom-view/#scrolling),
	          // scrolling, then restoring the original scroll behavior 
	          // (which was probably already auto anyway, but just to be safe)

	          const originalScrollBehavior = document.documentElement.style.scrollBehavior;
	          document.documentElement.style.scrollBehavior = "auto";
	          document.documentElement.scrollTo({
	            top: originalScrollTop,
	            left: originalScrollLeft,
	            behavior: "auto"
	          });
	          document.documentElement.style.scrollBehavior = originalScrollBehavior;
	        }
	      };
	    }
	  }, [hideScroll]);
	  return {
	    getScrollbarWidth,
	    getScrollbarHeight
	  };
	}

	function useAriaDialog(_ref) {
	  let {
	    open,
	    onClose
	  } = _ref;
	  // TODO: Differences between dialog and modal go here, presumably.
	  // Non-modal dialogs need to be able to be repositioned, etc.
	  const {
	    useModalBackdrop,
	    useModalBody,
	    useModalProps,
	    useModalTitle
	  } = useModal({
	    open,
	    onClose
	  });
	  const useDialogBackdrop = F(() => {
	    const {
	      useModalBackdropProps
	    } = useModalBackdrop();
	    return {
	      useDialogBackdropProps: useModalBackdropProps
	    };
	  }, [useModalBackdrop]);
	  const useDialogBody = F(_ref2 => {
	    let {
	      descriptive
	    } = _ref2;
	    const {
	      useModalBodyProps
	    } = useModalBody({
	      descriptive
	    });
	    return {
	      useDialogBodyProps: useModalBodyProps
	    };
	  }, [useModalBackdrop]);
	  const useDialogProps = useModalProps;
	  const useDialogTitle = F(() => {
	    const {
	      useModalTitleProps
	    } = useModalTitle();
	    return {
	      useDialogTitleProps: useModalTitleProps
	    };
	  }, [useModalTitle]);
	  return {
	    useDialogProps,
	    useDialogTitle,
	    useDialogBody,
	    useDialogBackdrop
	  };
	}

	function useAriaListboxMulti(_ref) {
	  let { ...args
	  } = _ref;
	  const {
	    useHasFocusProps,
	    getFocusedInner
	  } = useHasFocus({});
	  const {
	    useGenericLabelInput,
	    useGenericLabelLabel
	  } = useGenericLabel({
	    labelPrefix: "aria-listbox-label-",
	    inputPrefix: "aria-listbox-"
	  });
	  const {
	    useListNavigationChild,
	    useListNavigationProps,
	    navigateToIndex,
	    managedChildren,
	    currentTypeahead,
	    focusCurrent,
	    tabbableIndex,
	    invalidTypeahead
	  } = useListNavigation({ ...args,
	    shouldFocusOnChange: getFocusedInner
	  });
	  const {
	    useGenericLabelInputProps
	  } = useGenericLabelInput();
	  const childCount = managedChildren.length;
	  const [, setShiftHeld, getShiftHeld] = useState(false);
	  const typeaheadInProgress = !!currentTypeahead;
	  y(() => {
	    for (let i = 0; i < childCount; ++i) {
	      managedChildren[i].setTypeaheadInProgress(typeaheadInProgress);
	    }
	  }, [typeaheadInProgress, childCount]);
	  const useListboxMultiItem = F(info => {
	    var _info$onSelect;

	    const selected = info.selected;
	    const [typeaheadInProgress, setTypeaheadInProgress] = useState(false);
	    const getSelected = useStableGetter(selected);
	    const {
	      useRefElementProps,
	      getElement
	    } = useRefElement({});
	    const stableOnSelect = useStableCallback((_info$onSelect = info.onSelect) !== null && _info$onSelect !== void 0 ? _info$onSelect : () => {});
	    const {
	      tabbable,
	      useListNavigationChildProps
	    } = useListNavigationChild({ ...info,
	      setTypeaheadInProgress
	    });
	    useLayoutEffect(() => {
	      const element = getElement();

	      if (element && getShiftHeld()) {
	        stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
	          target: element,
	          currentTarget: element,
	          [EventDetail]: {
	            selected: true
	          }
	        });
	      }
	    }, [tabbable]);
	    return {
	      useListboxMultiItemProps,
	      tabbable
	    };

	    function useListboxMultiItemProps(props) {
	      const newProps = usePressEventHandlers(info.disabled ? null : e => {
	        navigateToIndex(info.index);
	        stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({ ...e,
	          [EventDetail]: {
	            selected: !getSelected()
	          }
	        });
	        e.preventDefault();
	      }, {
	        space: typeaheadInProgress ? "exclude" : undefined
	      })({});
	      props.role = "option";
	      props["aria-setsize"] = childCount.toString();
	      props["aria-posinset"] = (info.index + 1).toString();
	      props["aria-selected"] = (tabbable !== null && tabbable !== void 0 ? tabbable : false).toString();
	      if (info.disabled) props["aria-disabled"] = "true";
	      return useRefElementProps(useListNavigationChildProps(useMergedProps()(newProps, props)));
	    }
	  }, [useListNavigationChild, childCount, typeaheadInProgress]);
	  const useListboxMultiLabel = F(function useListboxMultiLabel() {
	    function useListboxMultiLabelProps(props) {
	      const {
	        useGenericLabelLabelProps
	      } = useGenericLabelLabel();
	      return useGenericLabelLabelProps(props);
	    }

	    return {
	      useListboxMultiLabelProps
	    };
	  }, [useGenericLabelLabel]);
	  return {
	    useListboxMultiItem,
	    useListboxMultiProps,
	    useListboxMultiLabel,
	    tabbableIndex,
	    currentTypeahead,
	    invalidTypeahead,
	    focus: focusCurrent,
	    managedChildren
	  };

	  function useListboxMultiProps(props) {
	    props.role = "listbox";
	    props["aria-multiselectable"] = "true";
	    return useListNavigationProps(useHasFocusProps(useGenericLabelInputProps(useMergedProps()({
	      onKeyDown,
	      onKeyUp,
	      onFocusOut
	    }, props))));
	  }

	  function onKeyDown(e) {
	    if (e.key == "Shift") setShiftHeld(true);
	  }

	  function onKeyUp(e) {
	    if (e.key == "Shift") setShiftHeld(false);
	  }

	  function onFocusOut(_) {
	    setShiftHeld(false);
	  }
	}

	function useAriaListboxSingle(_ref) {
	  let {
	    selectedIndex,
	    onSelect,
	    selectionMode,
	    ...args
	  } = _ref;
	  const [anyItemsFocused, setAnyItemsFocused, getAnyItemsFocused] = useState(false);
	  const {
	    useGenericLabelInput,
	    useGenericLabelLabel,
	    getInputElement
	  } = useGenericLabel({
	    labelPrefix: "aria-listbox-label-",
	    inputPrefix: "aria-listbox-"
	  });
	  const {
	    useListNavigationChild,
	    useListNavigationProps,
	    navigateToIndex,
	    managedChildren,
	    tabbableIndex,
	    focusCurrent,
	    currentTypeahead,
	    invalidTypeahead
	  } = useListNavigation({ ...args,
	    shouldFocusOnChange: getAnyItemsFocused
	  });
	  const {
	    useGenericLabelInputProps
	  } = useGenericLabelInput();
	  const stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {}); // Track whether the currently focused element is a child of the list box parent element.
	  // When it's not, we reset the tabbable index back to the currently selected element.

	  const {
	    useActiveElementProps
	  } = useActiveElement({
	    onActiveElementChange: F(activeElement => {
	      var _getInputElement;

	      return setAnyItemsFocused(!!((_getInputElement = getInputElement()) !== null && _getInputElement !== void 0 && _getInputElement.contains(activeElement)));
	    }, [])
	  });
	  y(() => {
	    if (!anyItemsFocused) navigateToIndex(selectedIndex);
	  }, [anyItemsFocused, selectedIndex, navigateToIndex]);
	  useChildFlag({
	    activatedIndex: selectedIndex,
	    managedChildren,
	    setChildFlag: (i, selected) => {
	      var _managedChildren$i;

	      return (_managedChildren$i = managedChildren[i]) === null || _managedChildren$i === void 0 ? void 0 : _managedChildren$i.setSelected(selected);
	    },
	    getChildFlag: i => {
	      var _managedChildren$i$ge, _managedChildren$i2;

	      return (_managedChildren$i$ge = (_managedChildren$i2 = managedChildren[i]) === null || _managedChildren$i2 === void 0 ? void 0 : _managedChildren$i2.getSelected()) !== null && _managedChildren$i$ge !== void 0 ? _managedChildren$i$ge : null;
	    }
	  });
	  useLayoutEffect(() => {
	    navigateToIndex(selectedIndex);
	  }, [selectedIndex, managedChildren.length]);
	  const childCount = managedChildren.length;
	  const useListboxSingleItem = F(info => {
	    const [selected, setSelected, getSelected] = useState(null);
	    const {
	      tabbable,
	      useListNavigationChildProps
	    } = useListNavigationChild({
	      setSelected,
	      getSelected,
	      ...info
	    });
	    const {
	      getElement,
	      useRefElementProps
	    } = useRefElement({});
	    const index = info.index;
	    y(() => {
	      const element = getElement();

	      if (element && tabbable && selectionMode == "focus") {
	        stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
	          target: element,
	          currentTarget: element,
	          [EventDetail]: {
	            selectedIndex: index
	          }
	        });
	      }
	    }, [tabbable, selectionMode, index]);
	    return {
	      useListboxSingleItemProps,
	      tabbable,
	      selected,
	      getSelected
	    };

	    function useListboxSingleItemProps(props) {
	      const newProps = usePressEventHandlers(info.disabled ? null : e => {
	        navigateToIndex(info.index);
	        const element = getElement();
	        if (element) stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
	          target: element,
	          currentTarget: element,
	          [EventDetail]: {
	            selectedIndex: index
	          }
	        });
	        e.preventDefault();
	      }, undefined)({});
	      props.role = "option";
	      props["aria-setsize"] = childCount.toString();
	      props["aria-posinset"] = (info.index + 1).toString();
	      props["aria-selected"] = (selected !== null && selected !== void 0 ? selected : false).toString();
	      if (info.disabled) props["aria-disabled"] = "true";
	      return useListNavigationChildProps(useMergedProps()(newProps, useRefElementProps(props)));
	    }
	  }, [useListNavigationChild, selectionMode, childCount]);
	  const useListboxSingleLabel = F(function useListboxSingleLabel() {
	    function useListboxSingleLabelProps(props) {
	      const {
	        useGenericLabelLabelProps
	      } = useGenericLabelLabel();
	      useGenericLabelLabelProps(props);
	    }

	    return {
	      useListboxSingleLabelProps
	    };
	  }, [useGenericLabelLabel]);
	  return {
	    useListboxSingleItem,
	    useListboxSingleProps,
	    useListboxSingleLabel,
	    tabbableIndex,
	    focus: focusCurrent,
	    currentTypeahead,
	    invalidTypeahead,
	    managedChildren
	  };

	  function useListboxSingleProps(props) {
	    props.role = "listbox";
	    return useListNavigationProps(useGenericLabelInputProps(useActiveElementProps(props)));
	  }
	}

	/**
	 * A menu is a popup control that contains a list of menu items, and that's it.
	 * It has very well-defined logic for managing those items as the menu's state changes.
	 *
	 * A MenuBase is just the "popup" part without the "list of menu items" part. It can
	 * (really, must) have interactive controls, but these controls are allowed to be more
	 * free-form. This means that, like a dialog, you must tell this hook
	 * where within the popup to send focus when opened (for a menu it's just the first
	 * menu item, but with custom content you'll need to provide this).
	 *
	 */

	function useMenuBase(_ref) {
	  let {
	    sendFocusWithinMenu,
	    ...args
	  } = _ref;
	  const getSendFocusWithinMenu = useStableGetter(sendFocusWithinMenu);
	  const [focusTrapActive, setFocusTrapActive] = useState(null);
	  const onClose = args.onClose;
	  const onOpen = args.onOpen;
	  const menubar = args.menubar;
	  const open = menubar ? true : args.open;
	  const stableOnClose = useStableCallback(onClose !== null && onClose !== void 0 ? onClose : () => {});
	  const getOpen = useStableGetter(open); // TODO: It's awkward that the button focus props are out here where we don't have its type,
	  // but focus management is super sensitive, and even waiting for a useLayoutEffect to sync state here
	  // would be too late, so it would look like there's a moment between menu focus lost and button focus gained
	  // where nothing is focused. 

	  const {
	    useHasFocusProps: useMenuBaseHasFocusProps,
	    getLastFocusedInner: getMenuBaseLastFocusedInner
	  } = useHasFocus({
	    /*onLastFocusedInnerChanged: onMenuOrButtonLostLastFocus*/
	  });
	  const {
	    useHasFocusProps: useButtonHasFocusProps,
	    getLastFocusedInner: getMenuBaseButtonLastFocusedInner
	  } = useHasFocus({
	    /*onLastFocusedInnerChanged: onMenuOrButtonLostLastFocus*/
	  });
	  const [, setOpenerElement, getOpenerElement] = useState(null);
	  const {
	    useRandomIdProps: useMenuBaseIdProps,
	    useReferencedIdProps: useMenuBaseIdReferencingProps
	  } = useRandomId({
	    prefix: "aria-menu-"
	  });
	  const {
	    getElement: getButtonElement,
	    useRefElementProps: useButtonRefElementProps
	  } = useRefElement({
	    onElementChange: setOpenerElement
	  });
	  const {
	    getElement: getMenuElement,
	    useRefElementProps: useMenuBaseRefElementProps
	  } = useRefElement({});
	  const {
	    useSoftDismissProps
	  } = useSoftDismiss({
	    onClose: stableOnClose,
	    getElements: () => [getButtonElement(), getMenuElement()]
	  });
	  y(() => {
	    setFocusTrapActive(open);
	  }, [open]);
	  const useMenuBaseProps = F(props => {
	    function onKeyDown(e) {
	      if (e.key == "Escape" && getOpen()) {
	        stableOnClose();
	        e.stopPropagation();
	        e.stopImmediatePropagation();
	        e.preventDefault();
	      }
	    }

	    return useSoftDismissProps(useMenuBaseHasFocusProps(useMenuBaseRefElementProps(useMenuBaseIdProps(useMergedProps()({
	      onKeyDown
	    }, props)))));
	  }, [useSoftDismissProps, useMenuBaseHasFocusProps, useMenuBaseRefElementProps, useMenuBaseIdProps]);
	  const useMenuBaseButtonProps = F(props => {
	    return useButtonRefElementProps(useButtonHasFocusProps(useMenuBaseIdReferencingProps("aria-controls")(props)));
	  }, [useButtonHasFocusProps, useButtonRefElementProps, useMenuBaseIdReferencingProps]);
	  y(() => {
	    const sendFocusWithinMenu = getSendFocusWithinMenu();

	    if (focusTrapActive) {
	      sendFocusWithinMenu === null || sendFocusWithinMenu === void 0 ? void 0 : sendFocusWithinMenu();
	    } else if (focusTrapActive === false) {
	      var _getOpenerElement;

	      if (getMenuBaseLastFocusedInner()) (_getOpenerElement = getOpenerElement()) === null || _getOpenerElement === void 0 ? void 0 : _getOpenerElement.focus({
	        preventScroll: true
	      });
	    } else ;
	  }, [focusTrapActive]);
	  return {
	    useMenuSentinel: F(() => {
	      const {
	        useSentinelProps: useMenuSentinelProps,
	        ...rest
	      } = useFocusSentinel({
	        open,
	        onClose: onClose !== null && onClose !== void 0 ? onClose : () => {},
	        sendFocusWithinMenu
	      });
	      return {
	        useMenuSentinelProps,
	        ...rest
	      };
	    }, [open, onClose, sendFocusWithinMenu]),
	    focusTrapActive,
	    useMenuBaseProps,
	    useMenuBaseButtonProps,
	    getMenuBaseLastFocusedInner,
	    getMenuBaseButtonLastFocusedInner,
	    open,
	    onOpen,
	    onClose
	  };
	} // A focus sentinal is a hidden but focusable element that comes at the start or end 
	// of the out-of-place-focusable component that, when activated or focused over, closes the component
	// (if focused within 100ms of the open prop changing, instead of
	// closing, focusing the sentinel immediately asks it to focus itself).
	// This exists for things like menus which can have focus but also need a way to return
	// to whatever out-of-place parent they came from when naturally tabbed out of (as opposed
	// to dialogs which loop back around when tabbed out of). While mouse users can click out of a menu
	// and keyboard users can escape to close a menu, screen readers and other input methods 
	// that don't use those two would become stuck.

	function useFocusSentinel(_ref2) {
	  let {
	    open,
	    onClose,
	    sendFocusWithinMenu
	  } = _ref2;
	  const getSendFocusWithinMenu = useStableGetter(sendFocusWithinMenu);
	  const stableOnClose = useStableCallback(onClose);
	  const [firstSentinelIsActive, setFirstSentinelIsActive] = useState(false);
	  useTimeout({
	    callback: () => {
	      setFirstSentinelIsActive(open);
	    },
	    timeout: 100,
	    triggerIndex: `${open}-${firstSentinelIsActive}`
	  });
	  const onFocus = firstSentinelIsActive ? () => stableOnClose() : () => {
	    var _getSendFocusWithinMe;

	    return (_getSendFocusWithinMe = getSendFocusWithinMenu()) === null || _getSendFocusWithinMe === void 0 ? void 0 : _getSendFocusWithinMe();
	  };

	  const onClick = () => stableOnClose();

	  return {
	    useSentinelProps: function (p) {
	      return useMergedProps()({
	        onFocus,
	        onClick
	      }, p);
	    }
	  };
	}
	function useAriaMenu(_ref3) {
	  let {
	    collator,
	    keyNavigation,
	    noTypeahead,
	    noWrap,
	    typeaheadTimeout,
	    ...args
	  } = _ref3;
	  const {
	    managedChildren,
	    useListNavigationChild,
	    useListNavigationProps,
	    tabbableIndex,
	    focusCurrent: focusMenu,
	    currentTypeahead,
	    invalidTypeahead
	  } = useListNavigation({
	    collator,
	    keyNavigation,
	    noTypeahead,
	    noWrap,
	    typeaheadTimeout,
	    shouldFocusOnChange: F(() => getMenuBaseLastFocusedInner() || getMenuBaseButtonLastFocusedInner(), [])
	  });
	  const {
	    useMenuSentinel,
	    useMenuBaseButtonProps,
	    useMenuBaseProps,
	    getMenuBaseButtonLastFocusedInner,
	    getMenuBaseLastFocusedInner,
	    open,
	    onOpen,
	    onClose
	  } = useMenuBase({ ...args,
	    sendFocusWithinMenu: focusMenu !== null && focusMenu !== void 0 ? focusMenu : () => {}
	  });
	  const useMenuButton = F(_ref4 => {
	    return {
	      useMenuButtonProps: function (p) {
	        const props = useMenuBaseButtonProps(p);
	        props["aria-haspopup"] = "menu";
	        props["aria-expanded"] = open ? "true" : undefined;
	        return props;
	      }
	    };
	  }, [open, onClose, onOpen, useMenuBaseButtonProps]);
	  const useMenuItem = F(args => {
	    const {
	      useListNavigationChildProps
	    } = useListNavigationChild(args);

	    function useMenuItemProps(_ref5) {
	      let { ...props
	      } = _ref5;
	      props.role = "menuitem";
	      return useMergedProps()({}, useListNavigationChildProps(props));
	    }

	    return {
	      useMenuItemProps
	    };
	  }, []);

	  function useMenuProps(_ref6) {
	    let { ...props
	    } = _ref6;
	    props.role = "menu";
	    return useMenuBaseProps(useListNavigationProps(props));
	  }

	  return {
	    useMenuProps,
	    useMenuButton,
	    useMenuItem,
	    useMenuSentinel,
	    //useMenuSubmenuItem,
	    focusMenu,
	    currentTypeahead,
	    invalidTypeahead,
	    tabbableIndex,
	    managedChildren
	  };
	}

	function useAriaTabs(_ref) {
	  let {
	    selectionMode,
	    selectedIndex,
	    onSelect,
	    orientation: logicalOrientation,
	    ...args
	  } = _ref;
	  const {
	    useHasFocusProps: useTabListHasFocusProps,
	    getFocusedInner: getTabListFocusedInner
	  } = useHasFocus({});
	  const [physicalOrientation, setPhysicalOrientation] = useState("horizontal");
	  const {
	    convertToPhysicalOrientation,
	    useLogicalDirectionProps
	  } = useLogicalDirection({
	    onLogicalDirectionChange: F(logicalDirectionInfo => setPhysicalOrientation(convertToPhysicalOrientation(logicalOrientation, logicalDirectionInfo)), [])
	  }); //const { useRandomIdProps: useTabListIdProps, useReferencedIdProps: useReferencedTabListId } = useRandomId({ prefix: "aria-tab-list-" });

	  const {
	    useRandomIdProps: useTabLabelIdProps,
	    useReferencedIdProps: useReferencedTabLabelId
	  } = useRandomId({
	    prefix: "aria-tab-label-"
	  });
	  const {
	    managedChildren: managedTabs,
	    navigateToIndex,
	    useListNavigationChild,
	    useListNavigationProps,
	    tabbableIndex,
	    invalidTypeahead,
	    currentTypeahead,
	    focusCurrent
	  } = useListNavigation({ ...args,
	    shouldFocusOnChange: getTabListFocusedInner,
	    keyNavigation: logicalOrientation
	  });
	  const {
	    managedChildren: managedPanels,
	    useManagedChild: useManagedTabPanel
	  } = useChildManager();
	  const childCount = managedTabs.length;
	  useLayoutEffect(() => {
	    for (const child of managedTabs) child.setSelectionMode(selectionMode);
	  }, [selectionMode]);
	  useChildFlag({
	    activatedIndex: selectedIndex,
	    managedChildren: managedTabs,
	    setChildFlag: (i, selected) => {
	      var _managedTabs$i;

	      return (_managedTabs$i = managedTabs[i]) === null || _managedTabs$i === void 0 ? void 0 : _managedTabs$i.setSelected(selected);
	    },
	    getChildFlag: i => {
	      var _managedTabs$i2;

	      return (_managedTabs$i2 = managedTabs[i]) === null || _managedTabs$i2 === void 0 ? void 0 : _managedTabs$i2.getSelected();
	    }
	  });
	  useChildFlag({
	    activatedIndex: selectedIndex,
	    managedChildren: managedPanels,
	    setChildFlag: (i, visible) => {
	      var _managedPanels$i;

	      return (_managedPanels$i = managedPanels[i]) === null || _managedPanels$i === void 0 ? void 0 : _managedPanels$i.setVisible(visible);
	    },
	    getChildFlag: i => {
	      var _managedPanels$i2;

	      return (_managedPanels$i2 = managedPanels[i]) === null || _managedPanels$i2 === void 0 ? void 0 : _managedPanels$i2.getVisible();
	    }
	  });
	  useLayoutEffect(_prev => {
	    if (selectedIndex != null && selectionMode == "activate") {
	      // TODO: We need to wait a moment so that the tab panel we want to focus
	      // is actually visible (i.e. we need to wait for the child to re-render itself).
	      // We could, alternatively, signal to the child that it should focus itself
	      // the next time it renders itself as visible,
	      // which might be better?
	      queueMicrotask(() => {
	        var _managedPanels$select;

	        (_managedPanels$select = managedPanels[selectedIndex]) === null || _managedPanels$select === void 0 ? void 0 : _managedPanels$select.focus();
	      });
	    }
	  }, [childCount, selectedIndex, selectionMode]);
	  const useTab = F(function useTab(info) {
	    const [selectionModeL, setSelectionModeL] = useState(selectionMode);
	    const {
	      useRefElementProps,
	      getElement
	    } = useRefElement({});
	    const [tabPanelId, setTabPanelId] = useState(undefined);
	    const {
	      useRandomIdProps: useTabIdProps,
	      id: tabId
	    } = useRandomId({
	      prefix: "aria-tab-"
	    });
	    const [selected, setSelected, getSelected] = useState(null);
	    const {
	      tabbable,
	      useListNavigationChildProps
	    } = useListNavigationChild({
	      setSelected,
	      getSelected,
	      tabId,
	      setTabPanelId,
	      setSelectionMode: setSelectionModeL,
	      ...info
	    });
	    const getIndex = useStableGetter(info.index);
	    y(() => {
	      const element = getElement();

	      if (tabbable && selectionModeL == "focus") {
	        onSelect({
	          target: element,
	          currentTarget: element,
	          [EventDetail]: {
	            selectedIndex: getIndex()
	          }
	        });
	      }
	    }, [tabbable, selectionMode]);
	    y(() => {
	      var _managedPanels$info$i;

	      (_managedPanels$info$i = managedPanels[info.index]) === null || _managedPanels$info$i === void 0 ? void 0 : _managedPanels$info$i.setTabId(tabId);
	    }, [tabId, info.index]);

	    function useTabProps(_ref2) {
	      let { ...props
	      } = _ref2;
	      const newProps = usePressEventHandlers(e => {
	        navigateToIndex(info.index);
	        onSelect === null || onSelect === void 0 ? void 0 : onSelect(enhanceEvent(e, {
	          selectedIndex: getIndex()
	        }));
	        e.preventDefault();
	      }, undefined)(props);
	      newProps.role = "tab";
	      newProps["aria-selected"] = (selected !== null && selected !== void 0 ? selected : false).toString();
	      newProps["aria-controls"] = tabPanelId;
	      return useMergedProps()({}, useTabIdProps(useListNavigationChildProps(useRefElementProps(newProps))));
	    }

	    return {
	      useTabProps,
	      selected
	    };
	  }, []);
	  const useTabPanel = F(function usePanel(info) {
	    //const [shouldFocus, setShouldFocus] = useState(false);
	    const [, setTabId] = useState(undefined);
	    const [visible, setVisible, getVisible] = useState(null);
	    const {
	      useRandomIdProps: usePanelIdProps,
	      id: tabPanelId
	    } = useRandomId({
	      prefix: "aria-tab-panel-"
	    });
	    const {
	      useManagedChildProps,
	      getElement
	    } = useManagedTabPanel({ ...info,
	      tabPanelId,
	      setTabId,
	      focus,
	      setVisible: setVisible,
	      getVisible: getVisible
	    });

	    function focus() {
	      const element = getElement();

	      if (element && getTabListFocusedInner()) {
	        element === null || element === void 0 ? void 0 : element.focus({
	          preventScroll: true
	        });
	      }
	    }

	    y(() => {
	      var _managedTabs$info$ind;

	      (_managedTabs$info$ind = managedTabs[info.index]) === null || _managedTabs$info$ind === void 0 ? void 0 : _managedTabs$info$ind.setTabPanelId(tabPanelId);
	    }, [tabPanelId, info.index]);

	    function useTabPanelProps(_ref3) {
	      var _managedTabs$info$ind2, _props$tabIndex;

	      let { ...props
	      } = _ref3;
	      props["aria-labelledby"] = (_managedTabs$info$ind2 = managedTabs[info.index]) === null || _managedTabs$info$ind2 === void 0 ? void 0 : _managedTabs$info$ind2.tabId;
	      props.role = "tabpanel";
	      (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1; // Make sure the tab panel is tabbable.

	      return useMergedProps()({}, usePanelIdProps(useManagedChildProps(props)));
	    }

	    return {
	      useTabPanelProps,
	      visible
	    };
	  }, []);
	  const useTabsList = F(function useTabList() {
	    function useTabListProps(_ref4) {
	      let { ...props
	      } = _ref4;
	      props.role = "tablist";
	      props["aria-orientation"] = physicalOrientation;
	      return useReferencedTabLabelId("aria-labelledby")(useTabListHasFocusProps(useLogicalDirectionProps(useListNavigationProps(props))));
	    }

	    return {
	      useTabListProps
	    };
	  }, [useListNavigationProps, physicalOrientation]);
	  const useTabsLabel = F(function useTabsLabel() {
	    function useTabsLabelProps(_ref5) {
	      let { ...props
	      } = _ref5;
	      return useTabLabelIdProps(props);
	    }

	    return {
	      useTabsLabelProps
	    };
	  }, []);
	  return {
	    useTab,
	    useTabPanel,
	    useTabsList,
	    useTabsLabel,
	    tabbableIndex,
	    focusTabList: focusCurrent,
	    currentTypeahead,
	    invalidTypeahead,
	    managedPanels,
	    managedTabs
	  };
	}

	function returnFalse() {
	  return false;
	}

	function useAriaTooltip(_ref) {
	  var _mouseoverDelay, _mouseoutDelay, _focusDelay;

	  let {
	    mouseoverDelay,
	    mouseoutDelay,
	    focusDelay
	  } = _ref;
	  (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
	  (_mouseoutDelay = mouseoutDelay) !== null && _mouseoutDelay !== void 0 ? _mouseoutDelay : mouseoutDelay = 40;
	  (_focusDelay = focusDelay) !== null && _focusDelay !== void 0 ? _focusDelay : focusDelay = 1; // The escape key should close tooltips, but do nothing else.
	  // (i.e. closing a tooltip in a dialog MUST NOT close the dialog too)
	  // TODO: Tooltips are, effectively, always the topmost component,
	  // so we can just have them listen to and swallow all "Escape"
	  // key presses before anyone else. For a more general popup,
	  // or a tooltip in a tooltip (!!) a different solution would be needed.

	  useGlobalHandler(document, "keydown", e => {
	    if (getOpen() && e.key === "Escape" && !e.defaultPrevented) {
	      e.preventDefault();
	      e.stopImmediatePropagation();
	      setOpen(false);
	      setTriggerHoverDelayCorrected(false);
	      setTooltipHoverDelayCorrected(false);
	      setTriggerFocusedDelayCorrected(false);
	      setTooltipFocusedDelayCorrected(false);
	    }
	  }, {
	    capture: true
	  });
	  const [open, setOpen, getOpen] = useState(false);
	  const {
	    useRandomIdProps: useTooltipIdProps,
	    useReferencedIdProps: useTooltipIdReferencingProps
	  } = useRandomId({
	    prefix: "aria-tooltip-"
	  });
	  const [, setTriggerFocused] = usePassiveState(useStableCallback(focused => {
	    const delay = focused ? focusDelay : 1;

	    if (delay != null && isFinite(delay)) {
	      const handle = setTimeout(() => setTriggerFocusedDelayCorrected(focused), focused ? focusDelay : 1);
	      return () => clearTimeout(handle);
	    }
	  }), returnFalse);
	  const [, setTooltipFocused] = usePassiveState(useStableCallback(focused => {
	    const delay = focused ? focusDelay : 1;

	    if (delay != null && isFinite(delay)) {
	      const handle = setTimeout(() => setTooltipFocusedDelayCorrected(focused), delay);
	      return () => clearTimeout(handle);
	    }
	  }), returnFalse);
	  const [, setTriggerHover] = usePassiveState(useStableCallback(hovering => {
	    const delay = hovering ? mouseoverDelay : mouseoutDelay;

	    if (delay != null && isFinite(delay)) {
	      const handle = setTimeout(() => setTriggerHoverDelayCorrected(hovering), delay);
	      return () => clearTimeout(handle);
	    }
	  }), returnFalse);
	  const [, setTooltipHover] = usePassiveState(useStableCallback(hovering => {
	    const delay = hovering ? mouseoverDelay : mouseoutDelay;

	    if (delay != null && isFinite(delay)) {
	      const handle = setTimeout(() => setTooltipHoverDelayCorrected(hovering), delay);
	      return () => clearTimeout(handle);
	    }
	  }), returnFalse);
	  const [triggerFocusedDelayCorrected, setTriggerFocusedDelayCorrected] = useState(false);
	  const [triggerHoverDelayCorrected, setTriggerHoverDelayCorrected] = useState(false);
	  const [tooltipFocusedDelayCorrected, setTooltipFocusedDelayCorrected] = useState(false);
	  const [tooltipHoverDelayCorrected, setTooltipHoverDelayCorrected] = useState(false);
	  y(() => {
	    setOpen(triggerFocusedDelayCorrected || triggerHoverDelayCorrected || tooltipFocusedDelayCorrected || tooltipHoverDelayCorrected);
	  }, [triggerFocusedDelayCorrected || triggerHoverDelayCorrected || tooltipFocusedDelayCorrected || tooltipHoverDelayCorrected]);
	  const useTooltipTrigger = F(function useTooltipTrigger() {
	    useGlobalHandler(document, "pointermove", e => {
	      var _getElement;

	      const target = e.target;
	      setTriggerHover(target == getElement() || !!((_getElement = getElement()) !== null && _getElement !== void 0 && _getElement.contains(target)));
	    }, {
	      capture: true
	    });

	    function onTouchEnd(e) {
	      e.target.focus();
	    }

	    const {
	      useHasFocusProps,
	      getElement
	    } = useHasFocus({
	      onFocusedInnerChanged: setTriggerFocused
	    });

	    function useTooltipTriggerProps(_ref2) {
	      var _props$tabIndex;

	      let { ...props
	      } = _ref2;
	      // Note: Though it's important to make sure that focusing activates a tooltip,
	      // it's perfectly reasonable that a child element will be the one that's focused,
	      // not this one, so we don't set tabIndex=0
	      (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1;
	      return useTooltipIdReferencingProps("aria-describedby")(useHasFocusProps(useMergedProps()({
	        onTouchEnd
	      }, props)));
	    }

	    return {
	      useTooltipTriggerProps
	    };
	  }, [useTooltipIdReferencingProps]);
	  const useTooltip = F(function useTooltip() {
	    const {
	      useHasFocusProps,
	      getElement
	    } = useHasFocus({
	      onFocusedInnerChanged: setTooltipFocused
	    });
	    useGlobalHandler(document, "pointermove", e => {
	      var _getElement2;

	      const target = e.target;
	      setTooltipHover(target == getElement() || !!((_getElement2 = getElement()) !== null && _getElement2 !== void 0 && _getElement2.contains(target)));
	    }, {
	      capture: true
	    });

	    function useTooltipProps(_ref3) {
	      let { ...props
	      } = _ref3;
	      return useTooltipIdProps(useHasFocusProps(useMergedProps()({}, props)));
	    }

	    return {
	      useTooltipProps
	    };
	  }, [useTooltipIdProps]);
	  return {
	    useTooltip,
	    useTooltipTrigger,
	    isOpen: open,
	    getIsOpen: getOpen
	  };
	}

	function useAriaRadioGroup(_ref) {
	  let {
	    name,
	    selectedValue,
	    onInput
	  } = _ref;
	  const {
	    getElement: getRadioGroupParentElement,
	    useRefElementProps
	  } = useRefElement({}); //const getSelectedIndex = useCallback((selectedValue: V) => { return byName.current.get(selectedValue) ?? 0 }, [])

	  const [selectedIndex, setSelectedIndex] = useState(0);
	  const byName = s(new Map());
	  const stableOnInput = useStableCallback(onInput);
	  const [anyRadiosFocused, setAnyRadiosFocused, getAnyRadiosFocused] = useState(false);
	  const {
	    managedChildren,
	    useListNavigationChild,
	    useListNavigationProps,
	    navigateToIndex,
	    tabbableIndex,
	    focusCurrent,
	    currentTypeahead,
	    invalidTypeahead
	  } = useListNavigation({
	    shouldFocusOnChange: getAnyRadiosFocused
	  }); // Track whether the currently focused element is a child of the radio group parent element.
	  // When it's not, we reset the tabbable index back to the currently selected element.

	  const {
	    useActiveElementProps
	  } = useActiveElement({
	    onActiveElementChange: F(activeElement => {
	      var _getRadioGroupParentE;

	      return setAnyRadiosFocused(!!((_getRadioGroupParentE = getRadioGroupParentElement()) !== null && _getRadioGroupParentE !== void 0 && _getRadioGroupParentE.contains(activeElement)));
	    }, [])
	  });
	  y(() => {
	    if (!anyRadiosFocused) navigateToIndex(selectedIndex !== null && selectedIndex !== void 0 ? selectedIndex : 0);
	  }, [anyRadiosFocused, selectedIndex, navigateToIndex]);
	  const useRadioGroupProps = F(_ref2 => {
	    let { ...props
	    } = _ref2;
	    props.role = "radiogroup";
	    return useListNavigationProps(useRefElementProps(useActiveElementProps(props)));
	  }, [useRefElementProps, useActiveElementProps]);
	  const correctedIndex = selectedIndex == null || selectedIndex < 0 || selectedIndex >= managedChildren.length ? null : selectedIndex;
	  useChildFlag({
	    activatedIndex: correctedIndex,
	    managedChildren,
	    setChildFlag: (i, checked) => {
	      var _managedChildren$i;

	      return (_managedChildren$i = managedChildren[i]) === null || _managedChildren$i === void 0 ? void 0 : _managedChildren$i.setChecked(checked);
	    },
	    getChildFlag: i => {
	      var _managedChildren$i$ge, _managedChildren$i2;

	      return (_managedChildren$i$ge = (_managedChildren$i2 = managedChildren[i]) === null || _managedChildren$i2 === void 0 ? void 0 : _managedChildren$i2.getChecked()) !== null && _managedChildren$i$ge !== void 0 ? _managedChildren$i$ge : false;
	    }
	  });
	  y(() => {
	    const selectedIndex = byName.current.get(selectedValue);
	    setSelectedIndex(selectedIndex !== null && selectedIndex !== void 0 ? selectedIndex : null);
	  }, [byName, selectedValue]);
	  const useRadio = F(function useAriaRadio(_ref3) {
	    let {
	      value,
	      index,
	      text,
	      disabled,
	      labelPosition,
	      ...rest
	    } = _ref3;
	    const [checked, setChecked, getChecked] = useState(null);
	    const onInput = F(e => {
	      stableOnInput(enhanceEvent(e, {
	        selectedValue: value
	      }));
	    }, [stableOnInput, value, index]);
	    const {
	      useCheckboxLikeInputElement,
	      useCheckboxLikeLabelElement
	    } = useCheckboxLike({
	      checked: checked !== null && checked !== void 0 ? checked : false,
	      disabled,
	      labelPosition,
	      onInput,
	      role: "radio"
	    });
	    h(() => {
	      byName.current.set(value, index);
	      return () => {
	        byName.current.delete(value);
	      };
	    }, [byName, value, index]);
	    const {
	      tabbable,
	      useListNavigationChildProps
	    } = useListNavigationChild({
	      index,
	      setChecked,
	      getChecked,
	      text,
	      ...rest
	    });

	    const useRadioInput = _ref4 => {
	      let {
	        tag
	      } = _ref4;

	      const useRadioInputProps = props => {
	        if (tag == "input") {
	          props.name = name;
	          props.checked = checked !== null && checked !== void 0 ? checked : false;
	          props.type = "radio";
	        } else {
	          props["aria-checked"] = (checked !== null && checked !== void 0 ? checked : false).toString();
	        }

	        const propsIfInputHandlesFocus = useListNavigationChildProps(props);
	        const {
	          useCheckboxLikeInputElementProps
	        } = useCheckboxLikeInputElement({
	          tag
	        });
	        return useMergedProps()(useCheckboxLikeInputElementProps({}), labelPosition == "separate" ? propsIfInputHandlesFocus : props);
	      };

	      return {
	        useRadioInputProps
	      };
	    };

	    const useRadioLabel = F(_ref5 => {
	      let {
	        tag
	      } = _ref5;

	      const useRadioLabelProps = props => {
	        const {
	          useCheckboxLikeLabelElementProps
	        } = useCheckboxLikeLabelElement({
	          tag
	        });
	        const propsIfLabelHandlesFocus = useListNavigationChildProps(props);
	        return useCheckboxLikeLabelElementProps(useMergedProps()({}, labelPosition == "wrapping" ? propsIfLabelHandlesFocus : props));
	      };

	      return {
	        useRadioLabelProps
	      };
	    }, [useCheckboxLikeLabelElement]);
	    return {
	      useRadioInput,
	      useRadioLabel,
	      checked: checked !== null && checked !== void 0 ? checked : false,
	      tabbable: tabbable !== null && tabbable !== void 0 ? tabbable : false
	    };
	  }, [byName, useListNavigationChild]);
	  return {
	    useRadio,
	    useRadioGroupProps,
	    managedChildren,
	    selectedIndex,
	    tabbableIndex,
	    focusRadio: focusCurrent,
	    currentTypeahead,
	    invalidTypeahead,
	    anyRadiosFocused
	  };
	}

	const DemoUseInterval = () => {
	    const [interval, setInterval] = d(1000);
	    const [fireCount, setFireCount] = d(0);
	    useInterval({ interval, callback: () => setFireCount(i => ++i) });
	    return (e$1("div", { class: "demo", children: [e$1("label", { children: ["Interval duration: ", e$1("input", { type: "number", value: interval, onInput: e => setInterval(e.currentTarget.valueAsNumber) })] }), e$1("div", { children: ["The callback has been called ", fireCount, " time", fireCount === 1 ? "" : "s", "."] })] }));
	};

	const RandomWords$1 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
	const RovingChildContext = D(null);
	const DemoUseRovingTabIndex = g(() => {
	    const [lastFocusedInner, setLastFocusedInner, getLastFocusedInner] = useState(false);
	    const { useHasFocusProps } = useHasFocus({ onLastFocusedInnerChanged: setLastFocusedInner });
	    const { useListNavigationChild, currentTypeahead, tabbableIndex, useListNavigationProps, navigateToIndex } = useListNavigation({ shouldFocusOnChange: getLastFocusedInner });
	    //const { useRovingTabIndexChild, useRovingTabIndexProps } = useRovingTabIndex<HTMLUListElement, RovingTabIndexChildInfo>({ tabbableIndex, focusOnChange: false });
	    return (e$1("div", { className: "demo", children: [e$1("h2", { children: "Keyboard & List Navigation" }), e$1("h3", { children: e$1("code", { children: "useRovingTabIndex" }) }), e$1("p", { children: ["Native HTML elements offer fantastic keyboard accessability, but cover a relatively limited number of use cases. There is no native HTML tree element, for example, that allows keyboard navigation of its items, nor is it possible to combine the keyboard navigation behavior of a ", e$1("code", { children: "<select>" }), " menu with the menu in a drawer component."] }), e$1("p", { children: ["When coming across a List or a Menu or a RadioGroup or a ToggleButtonGroup or any other \"one component made up of child components\", the usual expected behavior, at least natively, is that tabbing into the component is one action, and tabbing out is another.  Navigating ", e$1("em", { children: "within" }), " the component is done with the arrow keys or other methods."] }), e$1("p", { children: ["This is important both for accessability, but also just for general usability.  When tabbing back and forth, the ability to skip a long list without needing to trudge through ", e$1("em", { children: "every one" }), " of its child elements is extremely important."] }), e$1("p", { children: [e$1("code", { children: "useListNavigation" }), " wraps up the functionality of a few hooks (", e$1("code", { children: "useRovingTabIndex" }), ", ", e$1("code", { children: "useLinearNavigation" }), ", ", e$1("code", { children: "useTypeaheadNavigation" }), "to allow for ARIA-compliant navigation of lists and other similar components.  For more advanced use cases, you can use the other hooks individually."] }), e$1("p", { children: [e$1("code", { children: "useListNavigation" }), " (and ", e$1("code", { children: "useRovingTabIndex" }), ") internally use ", e$1("code", { children: "useChildManager" }), ", which is how the child elements and the parent communicate with each other. This means there are virtually no restrictions on how the DOM is set up as long as you can provide the children with the ", e$1("code", { children: "useListNavigationChild" }), " hook that's returned, usually with a simple ", e$1("code", { children: "Context" }), ". If the child element itself has a focusable element, like a button, it can also be wired up to disable itself Feel free to nest them too, as long as you are aware of your ", e$1("code", { children: "Context" }), " management (i.e. remember that you need to create a new ", e$1("code", { children: "Context" }), " for each use case)."] }), e$1("label", { children: ["Tabbable index: ", e$1("input", { type: "number", value: tabbableIndex ?? undefined, onInput: e => { e.preventDefault(); navigateToIndex(e.currentTarget.valueAsNumber); } })] }), e$1("ul", { ...useHasFocusProps(useListNavigationProps({})), children: e$1(RovingChildContext.Provider, { value: useListNavigationChild, children: Array.from((function* () {
	                        for (let i = 0; i < 10; ++i) {
	                            yield e$1(DemoUseRovingTabIndexChild, { index: i }, i);
	                        }
	                    })()) }) }), currentTypeahead && e$1("div", { children: ["Typeahead: ", currentTypeahead] })] }));
	});
	const DemoUseRovingTabIndexChild = g((({ index }) => {
	    const [randomWord] = useState(() => RandomWords$1[index /*Math.floor(Math.random() * (RandomWords.length - 1))*/]);
	    const useRovingTabIndexChild = T$1(RovingChildContext);
	    const text = `${randomWord} This is item #${index + 1}`;
	    const { useListNavigationChildProps, useListNavigationSiblingProps, tabbable } = useRovingTabIndexChild({ index, text, hidden: (index == 5) });
	    const props = useListNavigationChildProps({});
	    return (e$1("li", { ...props, children: [text, " (", tabbable ? "Tabbable" : "Not tabbable", ")", e$1("input", { ...useListNavigationSiblingProps({ type: "checkbox" }) })] }));
	}));

	const DemoUseTimeout = () => {
	    const [timeout, setTimeout] = d(1000);
	    const [triggerIndex, setTriggerIndex] = d("");
	    const [fireCount, setFireCount] = d(0);
	    useTimeout({ timeout, triggerIndex, callback: () => setFireCount(i => ++i) });
	    return (e$1("div", { class: "demo", children: [e$1("label", { children: ["Timeout duration: ", e$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), e$1("label", { children: ["Refresh key: ", e$1("input", { type: "text", value: triggerIndex, onInput: e => setTriggerIndex(e.currentTarget.value) })] }), e$1("div", { children: ["The callback has been called ", fireCount, " time", fireCount === 1 ? "" : "s", "."] })] }));
	};

	const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
	const DemoUseDroppable = () => {
	    const { droppedFiles, droppedStrings, filesForConsideration, stringsForConsideration, useDroppableProps, dropError } = useDroppable({ effect: "copy" });
	    useMergedProps()({}, { ref: s(null) });
	    const p = useDroppableProps({ className: "demo droppable" });
	    p.ref;
	    return (e$1("div", { ...p, children: [droppedStrings != null && e$1("div", { children: ["Data dropped: ", e$1("ul", { children: Object.entries(droppedStrings).map(([type, value]) => e$1("li", { children: [type, ": ", value] })) })] }), droppedFiles != null && e$1("div", { children: ["Files dropped: ", e$1("table", { children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Name" }), e$1("th", { children: "Size" }), e$1("th", { children: "Type" }), e$1("th", { children: "Last modified" })] }) }), e$1("tbody", { children: droppedFiles.map(f => e$1("tr", { children: [e$1("td", { children: f.name }), f.data.byteLength, e$1("td", { children: f.type }), e$1("td", { children: new Date(f.lastModified ?? 0) })] })) })] })] }), e$1("hr", {}), stringsForConsideration != null && e$1("div", { children: ["Data being considered: ", e$1("ul", { children: Array.from(stringsForConsideration).map(type => e$1("li", { children: type })) })] }), filesForConsideration != null && e$1("div", { children: ["Files being considered: ", e$1("ul", { children: filesForConsideration.map(f => e$1("li", { children: JSON.stringify(f) })) })] }), e$1("hr", {}), dropError && e$1("div", { children: dropError instanceof Error ? dropError.message : JSON.stringify(dropError) })] }));
	};
	const DemoUseDraggable = () => {
	    const { dragging, useDraggableProps, lastDropEffect, getLastDropEffect, getDragging } = useDraggable({ data: { "text/plain": "This is custom draggable content of type text/plain." } });
	    return (e$1("div", { ...useDraggableProps({ className: "demo" }), children: "Draggable content" }));
	};
	const DemoUseFocusTrap = g(({ depth }) => {
	    const [active, setActive] = useState(false);
	    const { useFocusTrapProps } = useFocusTrap({ trapActive: active });
	    const divProps = useFocusTrapProps({ ref: undefined, className: "focus-trap-demo" });
	    if (depth == 2)
	        return e$1("div", {});
	    return (e$1("div", { className: "demo", children: [e$1("label", { children: ["Active: ", e$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] }), e$1("div", { ...divProps, children: e$1(DemoUseFocusTrapChild, { active: active, setActive: setActive, depth: depth ?? 0 }) })] }));
	});
	const DemoUseFocusTrapChild = g(({ setActive, active, depth }) => {
	    return (e$1(d$1, { children: [e$1("button", { children: "Button 1" }), e$1("button", { children: "Button 2" }), e$1("button", { children: "Button 3" }), e$1("label", { children: ["Active: ", e$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] })] }));
	});
	const UseAccordionSectionContext = D(null);
	const DemoUseAccordion = g(() => {
	    const [expandedIndex, setExpandedIndex] = useState(0);
	    const { useAriaAccordionSection } = useAriaAccordion({ expandedIndex, setExpandedIndex });
	    return (e$1(UseAccordionSectionContext.Provider, { value: useAriaAccordionSection, children: e$1("div", { className: "demo", children: e$1("div", { children: [e$1(DemoAccordionSection, { index: 0 }), e$1(DemoAccordionSection, { index: 1 }), e$1(DemoAccordionSection, { index: 2 })] }) }) }));
	});
	const DemoAccordionSection = g(({ index }) => {
	    const useAccordionSection = T$1(UseAccordionSectionContext);
	    const { expanded, useAriaAccordionSectionBody, useAriaAccordionSectionHeader } = useAccordionSection({ index });
	    const { useAriaAccordionSectionBodyProps } = useAriaAccordionSectionBody();
	    const { useAriaAccordionSectionHeaderProps } = useAriaAccordionSectionHeader({ tag: "button" });
	    const p = useAriaAccordionSectionBodyProps({ className: "accordion-section-body", hidden: !expanded });
	    p.id;
	    return (e$1("div", { className: "accordion-section", children: [e$1("button", { ...useAriaAccordionSectionHeaderProps({ className: "accordion-section-header" }), children: ["Header #", index + 1] }), e$1("div", { ...p, children: [e$1("p", { children: ["Body content #", index + 1] }), e$1("p", { children: RandomWords.join(" ") })] })] }));
	});
	const DemoUseCheckbox = g(() => {
	    return (e$1(d$1, { children: [e$1("div", { className: "demo", children: [e$1(Checkbox1, {}), e$1(Checkbox2, {})] }), e$1(DemoUseCheckboxGroup, {})] }));
	});
	const Checkbox1 = g(() => {
	    const [checked, setChecked] = useState(false);
	    const { useCheckboxInputElement, useCheckboxLabelElement } = useAriaCheckbox({ disabled: false, checked, labelPosition: "separate", onInput: e => setChecked(e[EventDetail].checked) });
	    const { useCheckboxInputElementProps } = useCheckboxInputElement({ tag: "input" });
	    const { useCheckboxLabelElementProps } = useCheckboxLabelElement({ tag: "label" });
	    return (e$1("div", { children: [e$1("input", { ...useCheckboxInputElementProps({ type: "checkbox", }) }), e$1("label", { ...useCheckboxLabelElementProps({}), children: "Label" })] }));
	});
	const Checkbox2 = g(() => {
	    const [checked, setChecked] = useState(false);
	    const { useCheckboxLabelElement, useCheckboxInputElement } = useAriaCheckbox({ disabled: false, labelPosition: "wrapping", onInput: e => setChecked(e[EventDetail].checked), checked });
	    const { useCheckboxInputElementProps } = useCheckboxInputElement({ tag: "input" });
	    const { useCheckboxLabelElementProps } = useCheckboxLabelElement({ tag: "label" });
	    return (e$1("div", { children: e$1("label", { ...useCheckboxLabelElementProps({}), children: [e$1("input", { ...useCheckboxInputElementProps({ type: "checkbox" }) }), " Label"] }) }));
	});
	const CheckboxGroupContext = D(null);
	const DemoUseCheckboxGroup = g(() => {
	    const onUpdateChildren = (event) => {
	        const value = event[EventDetail].childrenChecked;
	        let selectedValues = new Set();
	        for (let i = 0; i < 10; ++i) {
	            if (value === false) ;
	            else if (value === true)
	                selectedValues.add(i);
	            else if (value.get(i) === true)
	                selectedValues.add(i);
	        }
	        setSelectedValues(selectedValues);
	    };
	    const { useHasFocusProps, getFocusedInner } = useHasFocus({});
	    const { useCheckboxGroupParentProps: useCheckboxGroupCheckboxProps, useCheckboxGroupChild, parentIsChecked: selfIsChecked, parentPercentChecked: percentChecked, onCheckboxGroupParentInput: onCheckboxGroupInput } = useCheckboxGroup({ shouldFocusOnChange: getFocusedInner, onUpdateChildren });
	    const { useCheckboxInputElement, useCheckboxLabelElement } = useAriaCheckbox({ checked: selfIsChecked, disabled: false, labelPosition: "separate", onInput: onCheckboxGroupInput });
	    const { useCheckboxInputElementProps } = useCheckboxInputElement({ tag: "input" });
	    const { useCheckboxLabelElementProps } = useCheckboxLabelElement({ tag: "label" });
	    const [selectedValues, setSelectedValues] = useState(new Set());
	    return e$1("div", { class: "demo", children: e$1(CheckboxGroupContext.Provider, { value: useCheckboxGroupChild, children: [e$1("div", { children: [e$1("input", { ...useCheckboxInputElementProps(useCheckboxGroupCheckboxProps({})) }), e$1("label", { ...useCheckboxLabelElementProps({}), children: "All checked?" })] }), e$1("div", { ...useHasFocusProps({ style: { "display": "flex", "flexDirection": "column" } }), children: Array.from((function* () {
	                        for (let i = 0; i < 10; ++i) {
	                            function setSelected2(selected) {
	                                setSelectedValues(selectedValues => {
	                                    let next = new Set(selectedValues);
	                                    if (selected && !next.has(i)) {
	                                        next.add(i);
	                                        return next;
	                                    }
	                                    else if (!selected && next.has(i)) {
	                                        next.delete(i);
	                                        return next;
	                                    }
	                                    return selectedValues;
	                                });
	                            }
	                            yield e$1(DemoUseCheckboxGroupChild, { index: i, checked: !!selectedValues.has(i), setChecked: setSelected2 }, i);
	                        }
	                    })()) })] }) });
	});
	const DemoUseCheckboxGroupChild = g(({ index, checked, setChecked }) => {
	    const { randomId } = useRandomId();
	    const useCheckboxGroupChild = T$1(CheckboxGroupContext);
	    let text = `Number ${index + 1} checkbox ${checked ? "(checked)" : ""}`;
	    const { tabbable, useCheckboxGroupChildProps } = useCheckboxGroupChild({ index, text, checked, id: randomId });
	    text = `Number ${index + 1} checkbox ${checked ? "(checked)" : ""} ${tabbable ? "(tabbble)" : ""}`;
	    const { useCheckboxInputElement, useCheckboxLabelElement } = useAriaCheckbox({ checked, disabled: false, labelPosition: "separate", onInput: e => { setChecked(e[EventDetail].checked); } });
	    const { useCheckboxInputElementProps } = useCheckboxInputElement({ tag: "input" });
	    const { useCheckboxLabelElementProps } = useCheckboxLabelElement({ tag: "label" });
	    return (e$1("div", { children: [e$1("input", { ...useCheckboxInputElementProps(useCheckboxGroupChildProps({})) }), e$1("label", { ...useCheckboxLabelElementProps({}), children: text })] }));
	});
	const DemoUseDialog = g(() => {
	    const onClose = (() => setOpen(false));
	    const [open, setOpen] = useState(false);
	    const { useDialogBackdrop, useDialogBody, useDialogProps, useDialogTitle } = useAriaDialog({ open, onClose });
	    const { useDialogBackdropProps } = useDialogBackdrop();
	    const { useDialogBodyProps } = useDialogBody({ descriptive: true });
	    const { useDialogTitleProps } = useDialogTitle();
	    return (e$1("div", { class: "demo", children: [e$1("label", { children: e$1("input", { type: "checkbox", checked: open, onInput: e => { e.preventDefault(); setOpen(e.currentTarget.checked); } }) }), e$1("div", { ...useDialogBackdropProps({ hidden: !open }), children: e$1("div", { ...useDialogProps({}), children: [e$1("div", { ...useDialogTitleProps({}), children: "Dialog Title" }), e$1("div", { ...useDialogBodyProps({}), children: [e$1("p", { tabIndex: -1, children: "Dialog body content" }), e$1("p", { children: RandomWords.join(" ") }), e$1("p", { children: RandomWords.join(" ") }), e$1("p", { children: RandomWords.join(" ") }), e$1("p", { children: e$1("button", { onClick: onClose, children: "Close" }) })] })] }) })] }));
	});
	const RadioWrapContext = D(false);
	const RadioContext = D(null);
	const DemoUseRadioGroup = g(() => {
	    const [selectedIndex, setSelectedIndex] = useState(0);
	    const [wrap, setWrap] = useState(T$1(RadioWrapContext));
	    const { useRadio, useRadioGroupProps, anyRadiosFocused } = useAriaRadioGroup({
	        name: "radio-demo-1",
	        onInput: (e) => setSelectedIndex(+e[EventDetail].selectedValue),
	        selectedValue: selectedIndex
	    });
	    return e$1("div", { class: "demo", children: [e$1("label", { children: [e$1("input", { type: "checkbox", checked: wrap, onInput: e => setWrap(w => !w) }), " Wrapper label"] }), e$1(RadioWrapContext.Provider, { value: wrap, children: [anyRadiosFocused.toString(), e$1(RadioContext.Provider, { value: useRadio, children: e$1("div", { ...useRadioGroupProps({}), children: Array.from((function* () {
	                                for (let i = 0; i < 10; ++i) {
	                                    yield e$1(DemoRadio, { index: i }, i);
	                                }
	                            })()) }) })] }, wrap)] });
	});
	const DemoRadio = g(({ index }) => {
	    const wrap = T$1(RadioWrapContext);
	    const { useRadioInput, useRadioLabel, checked, tabbable } = T$1(RadioContext)({ index, text: null, value: index, disabled: false, labelPosition: wrap ? "wrapping" : "separate" });
	    const { useRadioInputProps } = useRadioInput({ tag: "input" });
	    const { useRadioLabelProps } = useRadioLabel({ tag: "label" });
	    if (wrap)
	        return e$1("label", { ...useRadioLabelProps({}), children: [e$1("input", { ...useRadioInputProps({}) }), "Number ", index + 1, " radio", checked ? " (checked)" : "", tabbable ? " (tabbable)" : ""] });
	    else
	        return e$1("div", { children: [e$1("input", { ...useRadioInputProps({}) }), "Number ", index + 1, " radio", checked ? " (checked)" : "", tabbable ? " (tabbable)" : "", e$1("label", { ...useRadioLabelProps({}) })] });
	});
	const ListBoxSingleItemContext = D(null);
	const DemoUseListboxSingle = g(() => {
	    const [selectedIndex, setSelectedIndex] = useState(0);
	    const { useListboxSingleItem, useListboxSingleLabel, useListboxSingleProps } = useAriaListboxSingle({ selectedIndex, onSelect: e => setSelectedIndex(e[EventDetail].selectedIndex), selectionMode: "activate" });
	    return e$1("div", { class: "demo", children: e$1(ListBoxSingleItemContext.Provider, { value: useListboxSingleItem, children: e$1("ul", { ...useListboxSingleProps({}), children: Array.from((function* () {
	                    for (let i = 0; i < 10; ++i) {
	                        yield e$1(DemoListboxSingleOption, { index: i }, i);
	                    }
	                })()) }) }) });
	});
	const DemoListboxSingleOption = g(({ index }) => {
	    const { getSelected, selected, tabbable, useListboxSingleItemProps } = T$1(ListBoxSingleItemContext)({ index, text: null, tag: "li" });
	    return e$1("li", { ...useListboxSingleItemProps({}), children: ["Number ", index + 1, " option", selected ? " (selected)" : "", tabbable ? " (tabbable)" : ""] });
	});
	const ListBoxMultiItemContext = D(null);
	const DemoUseListboxMulti = g(() => {
	    const { useListboxMultiItem, useListboxMultiLabel, useListboxMultiProps, currentTypeahead } = useAriaListboxMulti({});
	    const [selectedValues, setSelectedValues] = useState(new Set());
	    return e$1("div", { class: "demo", children: e$1(ListBoxMultiItemContext.Provider, { value: useListboxMultiItem, children: [e$1("ul", { ...useListboxMultiProps({}), children: Array.from((function* () {
	                        for (let i = 0; i < 10; ++i) {
	                            function setSelected2(selected) {
	                                setSelectedValues(selectedValues => {
	                                    let next = new Set(selectedValues);
	                                    if (selected && !next.has(i)) {
	                                        next.add(i);
	                                        return next;
	                                    }
	                                    else if (!selected && next.has(i)) {
	                                        next.delete(i);
	                                        return next;
	                                    }
	                                    return selectedValues;
	                                });
	                            }
	                            yield e$1(DemoListboxMultiOption, { index: i, selected: !!selectedValues.has(i), setSelected: setSelected2 }, i);
	                        }
	                    })()) }), currentTypeahead != null && e$1("p", { children: currentTypeahead })] }) });
	});
	const MenuItemContext = D(null);
	const DemoListboxMultiOption = g(({ index, selected, setSelected }) => {
	    let text = `Number ${index + 1} option${selected ? " (selected)" : ""}`;
	    const { tabbable, useListboxMultiItemProps } = T$1(ListBoxMultiItemContext)({ tag: "li", index, text, onSelect: e => setSelected(e[EventDetail].selected), selected });
	    text = `Number ${index + 1} option${selected ? " (selected)" : ""}${tabbable ? " (tabbable)" : ""}`;
	    return e$1("li", { ...useListboxMultiItemProps({}), children: text });
	});
	const DemoMenu = g(() => {
	    const [open, setOpen] = useState(false);
	    const onClose = () => setOpen(false);
	    const onOpen = () => setOpen(true);
	    const { useHasFocusProps, getFocusedInner: getMenuFocusedInner } = useHasFocus({});
	    const { useMenuButton, useMenuItem, useMenuProps } = useAriaMenu({ open, onClose, onOpen, shouldFocusOnChange: getMenuFocusedInner });
	    const { useMenuButtonProps } = useMenuButton({ tag: "button" });
	    return (e$1("div", { class: "demo", children: e$1(MenuItemContext.Provider, { value: useMenuItem, children: [e$1("button", { ...useMenuButtonProps({ onClick: e => setOpen(open => !open) }), children: "Open menu" }), e$1("ul", { ...useMenuProps(useHasFocusProps({})), hidden: !open, children: [e$1(DemoMenuItem, { index: 0 }), e$1(DemoMenuItem, { index: 1 }), e$1(DemoMenuItem, { index: 2 })] })] }) }));
	});
	const DemoMenuItem = g(({ index }) => {
	    const useAriaMenuItem = T$1(MenuItemContext);
	    const { useMenuItemProps } = useAriaMenuItem({ index, text: null });
	    return e$1("li", { ...useMenuItemProps({}), children: ["Item ", index + 1] });
	});
	const TabContext = D(null);
	const TabPanelContext = D(null);
	const DemoTabs = g(() => {
	    const [selectedIndex, setSelectedIndex] = useState(0);
	    const [selectionMode, setSelectionMode] = useState("focus");
	    const { useTabPanel, useTabsLabel, useTab, useTabsList } = useAriaTabs({ onSelect: e => setSelectedIndex(e[EventDetail].selectedIndex), selectedIndex, selectionMode, orientation: "block" });
	    const { useTabListProps } = useTabsList();
	    return (e$1(TabContext.Provider, { value: useTab, children: e$1(TabPanelContext.Provider, { value: useTabPanel, children: e$1("div", { class: "demo", children: [e$1("label", { children: [e$1("input", { type: "checkbox", checked: selectionMode == "focus", onInput: (e) => { e.preventDefault(); setSelectionMode(e.currentTarget.checked ? "focus" : "activate"); } }), " Activate on focus?"] }), e$1("ul", { ...useTabListProps({}), children: [e$1(DemoTab, { index: 0 }), e$1(DemoTab, { index: 1 }), e$1(DemoTab, { index: 2 }), e$1(DemoTab, { index: 3 }), e$1(DemoTab, { index: 4 })] }), e$1("div", { children: [e$1(DemoTabPanel, { index: 0 }), e$1(DemoTabPanel, { index: 1 }), e$1(DemoTabPanel, { index: 2 }), e$1(DemoTabPanel, { index: 3 }), e$1(DemoTabPanel, { index: 4 })] })] }) }) }));
	});
	const DemoTab = g(({ index }) => {
	    const useTab = T$1(TabContext);
	    const { useTabProps, selected } = useTab({ index, text: null, tag: "li" });
	    return (e$1(d$1, { children: e$1("li", { ...useTabProps({}), children: ["Tab #", index + 1, " (", `Selected: ${selected}`, ")"] }) }));
	});
	const DemoTabPanel = g(({ index }) => {
	    const useTabPanel = T$1(TabPanelContext);
	    const { useTabPanelProps, visible } = useTabPanel({ index });
	    return (e$1("div", { ...useTabPanelProps({ hidden: !visible }), children: [e$1("p", { children: ["Tab panel content #", index + 1, " (", `Selected: ${visible}`, ")."] }), e$1("p", { children: RandomWords.slice(0, Math.floor(RandomWords.length / (index + 1))).join(" ") })] }));
	});
	const DemoTooltip = g(() => {
	    const { useTooltip, useTooltipTrigger, isOpen } = useAriaTooltip({});
	    const { useTooltipProps } = useTooltip();
	    const { useTooltipTriggerProps } = useTooltipTrigger();
	    return (e$1("div", { class: "demo", children: e$1("p", { children: ["This is a paragraph with a ", e$1("span", { ...useTooltipTriggerProps({}), children: "tooltip right here." }), e$1("span", { ...useTooltipProps({ hidden: !isOpen }), children: "This is the tooltip content." })] }) }));
	});
	/*
	const DemoTable = memo(() => {

	    const { useTableBody, useTableFoot, useTableHead, useTableProps, useTableRow } = useTable<
	        HTMLTableElement, HTMLTableSectionElement, HTMLTableSectionElement, HTMLTableSectionElement, HTMLTableRowElement, HTMLTableCellElement, HTMLTableCellElement>({});

	    const { useTableHeadProps } = useTableHead({});
	    const { useTableBodyProps } = useTableBody({});

	    const rows: VNode<any>[] = Array.from(function* () {
	        for (let i = 0; i < 10; ++i) {
	            yield <TableRow rowIndex={i + 1} />;
	        }
	    }());


	    return (
	        <TableRowContext.Provider value={useTableRow}>
	            <table {...useTableProps({})}>
	                <thead {...useTableHeadProps({ children: [<TableHeaderRow rowIndex={0} />] })} />
	                <tbody {...useTableBodyProps({ children: rows })} />
	            </table>
	        </TableRowContext.Provider>
	    )

	});

	const TableRowContext = createContext<UseTableRow<HTMLTableRowElement, HTMLTableCellElement, HTMLTableCellElement>>(null!);


	const TableRow = memo(function TableRow({ rowIndex }: { rowIndex: number }) {
	    const i = rowIndex - 1;
	    const useTableRow = useContext(TableRowContext);
	    const { rowIndexAsSorted, rowIndexAsUnsorted, useTableCell, useTableRowProps } = useTableRow({ rowIndex, location: "body" });
	    const date = new Date(new Date().getFullYear(), new Date().getMonth(), (i * 7) ** 2);

	    const { useTableCellProps: useTableCellProps1, useTableCellDelegateProps: useTableCellDelegateProps1 } = useTableCell({ columnIndex: 0, value: i });
	    const { useTableCellProps: useTableCellProps2, useTableCellDelegateProps: useTableCellDelegateProps2 } = useTableCell({ columnIndex: 1, value: RandomWords[i] });
	    const { useTableCellProps: useTableCellProps3, useTableCellDelegateProps: useTableCellDelegateProps3 } = useTableCell({ columnIndex: 2, value: date });
	    return (
	        <tr {...useTableRowProps({ "data-index": rowIndex } as {})}>
	            <td {...useTableCellProps1(useTableCellDelegateProps1({}))}>{i}</td>
	            <td {...useTableCellProps2(useTableCellDelegateProps2({}))}>{RandomWords[i]}</td>
	            <td {...useTableCellProps3(useTableCellDelegateProps3({}))}>{date.toLocaleDateString()}</td>
	        </tr>
	    )
	})


	const TableHeaderRow = memo(function TableHeaderRow({ rowIndex }: { rowIndex: number }) {
	    const useTableRow = useContext(TableRowContext);
	    const { useTableHeadCell, useTableRowProps: useTableHeadRowProps } = useTableRow({ rowIndex, location: "head" });
	    const { useTableHeadCellProps: useTableHeadCellProps1, useTableHeadCellDelegateProps: useTableHeadCellDelegateProps1, sortDirection: sortDirection1 } = useTableHeadCell({ tag: "th", columnIndex: 0 });
	    const { useTableHeadCellProps: useTableHeadCellProps2, useTableHeadCellDelegateProps: useTableHeadCellDelegateProps2, sortDirection: sortDirection2 } = useTableHeadCell({ tag: "th", columnIndex: 1 });
	    const { useTableHeadCellProps: useTableHeadCellProps3, useTableHeadCellDelegateProps: useTableHeadCellDelegateProps3, sortDirection: sortDirection3 } = useTableHeadCell({ tag: "th", columnIndex: 2 });


	    return (<tr {...useTableHeadRowProps({ "data-index": rowIndex } as {})}>
	        <th {...useTableHeadCellProps1(useTableHeadCellDelegateProps1({}))}>Number {sortDirection1}</th>
	        <th {...useTableHeadCellProps2(useTableHeadCellDelegateProps2({}))}>String {sortDirection2}</th>
	        <th {...useTableHeadCellProps3(useTableHeadCellDelegateProps3({}))}>Date {sortDirection3}</th>
	    </tr>)
	})*/
	const Component = () => {
	    return e$1("div", { class: "flex", style: { flexWrap: "wrap" }, children: [e$1(DemoTooltip, {}), e$1(DemoTabs, {}), e$1(DemoUseTimeout, {}), e$1(DemoUseInterval, {}), e$1(DemoMenu, {}), e$1(DemoUseListboxSingle, {}), e$1(DemoUseListboxMulti, {}), e$1(DemoUseCheckbox, {}), e$1(DemoUseRadioGroup, {}), e$1(DemoUseAccordion, {}), e$1(DemoUseDialog, {}), e$1(DemoUseRovingTabIndex, {}), e$1(DemoUseFocusTrap, {}), e$1(DemoUseDroppable, {}), e$1(DemoUseDraggable, {}), e$1("input", {})] });
	};
	requestAnimationFrame(() => {
	    S$1(e$1(Component, {}), document.getElementById("root"));
	});

})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jcmVhdGUtZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1kb2N1bWVudC1jbGFzcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXBhc3NpdmUtc3RhdGUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtY2xhc3Nlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1yZWZzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbWVyZ2VkLXN0eWxlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1wcm9wcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXJlZi1lbGVtZW50LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbG9naWNhbC1kaXJlY3Rpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1zdGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXJhbmRvbS1pZC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Utc3RhYmxlLWdldHRlci50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXN0YWJsZS1jYWxsYmFjay50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWVmZmVjdC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWxheW91dC1lZmZlY3QudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS10aW1lb3V0LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWNoaWxkLW1hbmFnZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1yb3ZpbmctdGFiaW5kZXgudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1hbmltYXRpb24tZnJhbWUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1kcmFnZ2FibGUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1kcm9wcGFibGUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1ldmVudC1oYW5kbGVyLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtYWN0aXZlLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1pbnRlcnZhbC50c3giLCIuLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvc3JjL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3dpY2ctaW5lcnQvZGlzdC9pbmVydC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ibG9ja2luZy1lbGVtZW50cy9zcmMvYmxvY2tpbmctZWxlbWVudHMudHMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWJsb2NraW5nLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1mb2N1cy10cmFwLnRzeCIsIi4uL3NyYy91c2UtYnV0dG9uLnRzIiwiLi4vc3JjL3VzZS1hY2NvcmRpb24udHN4IiwiLi4vc3JjL3VzZS1sYWJlbC50cyIsIi4uL3NyYy91c2UtY2hlY2tib3gudHMiLCIuLi9zcmMvdXNlLWNoZWNrYm94LWdyb3VwLnRzIiwiLi4vc3JjL3VzZS1tb2RhbC50cyIsIi4uL3NyYy91c2UtZGlhbG9nLnRzIiwiLi4vc3JjL3VzZS1saXN0Ym94LW11bHRpLnRzIiwiLi4vc3JjL3VzZS1saXN0Ym94LXNpbmdsZS50cyIsIi4uL3NyYy91c2UtbWVudS50cyIsIi4uL3NyYy91c2UtdGFicy50cyIsIi4uL3NyYy91c2UtdG9vbHRpcC50cyIsIi4uL3NyYy91c2UtcmFkaW8tZ3JvdXAudHN4IiwiZGVtb3MvdXNlLWludGVydmFsLnRzeCIsImRlbW9zL3VzZS1yb3ZpbmctdGFiLWluZGV4LnRzeCIsImRlbW9zL3VzZS10aW1lb3V0LnRzeCIsImluZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuXG5sZXQgdm5vZGVJZCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlIGFuIHZpcnR1YWwgbm9kZSAodXNlZCBmb3IgSlNYKVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIGNvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJvcHNdIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuJykuQ29tcG9uZW50Q2hpbGRyZW4+fSBbY2hpbGRyZW5dIFRoZSBjaGlsZHJlbiBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge30sXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAna2V5Jykga2V5ID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBpZiAoaSA9PSAncmVmJykgcmVmID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jaGlsZHJlbiA9XG5cdFx0XHRhcmd1bWVudHMubGVuZ3RoID4gMyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGNoaWxkcmVuO1xuXHR9XG5cblx0Ly8gSWYgYSBDb21wb25lbnQgVk5vZGUsIGNoZWNrIGZvciBhbmQgYXBwbHkgZGVmYXVsdFByb3BzXG5cdC8vIE5vdGU6IHR5cGUgbWF5IGJlIHVuZGVmaW5lZCBpbiBkZXZlbG9wbWVudCwgbXVzdCBuZXZlciBlcnJvciBoZXJlLlxuXHRpZiAodHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLmRlZmF1bHRQcm9wcyAhPSBudWxsKSB7XG5cdFx0Zm9yIChpIGluIHR5cGUuZGVmYXVsdFByb3BzKSB7XG5cdFx0XHRpZiAobm9ybWFsaXplZFByb3BzW2ldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gdHlwZS5kZWZhdWx0UHJvcHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG5vcm1hbGl6ZWRQcm9wcywga2V5LCByZWYsIG51bGwpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFZOb2RlICh1c2VkIGludGVybmFsbHkgYnkgUHJlYWN0KVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIENvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBwcm9wcyBUaGUgcHJvcGVydGllcyBvZiB0aGlzIHZpcnR1YWwgbm9kZS5cbiAqIElmIHRoaXMgdmlydHVhbCBub2RlIHJlcHJlc2VudHMgYSB0ZXh0IG5vZGUsIHRoaXMgaXMgdGhlIHRleHQgb2YgdGhlIG5vZGUgKHN0cmluZyBvciBudW1iZXIpLlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBrZXkgVGhlIGtleSBmb3IgdGhpcyB2aXJ0dWFsIG5vZGUsIHVzZWQgd2hlblxuICogZGlmZmluZyBpdCBhZ2FpbnN0IGl0cyBjaGlsZHJlblxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInJlZlwiXX0gcmVmIFRoZSByZWYgcHJvcGVydHkgdGhhdCB3aWxsXG4gKiByZWNlaXZlIGEgcmVmZXJlbmNlIHRvIGl0cyBjcmVhdGVkIGNoaWxkXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywga2V5LCByZWYsIG9yaWdpbmFsKSB7XG5cdC8vIFY4IHNlZW1zIHRvIGJlIGJldHRlciBhdCBkZXRlY3RpbmcgdHlwZSBzaGFwZXMgaWYgdGhlIG9iamVjdCBpcyBhbGxvY2F0ZWQgZnJvbSB0aGUgc2FtZSBjYWxsIHNpdGVcblx0Ly8gRG8gbm90IGlubGluZSBpbnRvIGNyZWF0ZUVsZW1lbnQgYW5kIGNvZXJjZVRvVk5vZGUhXG5cdGNvbnN0IHZub2RlID0ge1xuXHRcdHR5cGUsXG5cdFx0cHJvcHMsXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRfY2hpbGRyZW46IG51bGwsXG5cdFx0X3BhcmVudDogbnVsbCxcblx0XHRfZGVwdGg6IDAsXG5cdFx0X2RvbTogbnVsbCxcblx0XHQvLyBfbmV4dERvbSBtdXN0IGJlIGluaXRpYWxpemVkIHRvIHVuZGVmaW5lZCBiL2MgaXQgd2lsbCBldmVudHVhbGx5XG5cdFx0Ly8gYmUgc2V0IHRvIGRvbS5uZXh0U2libGluZyB3aGljaCBjYW4gcmV0dXJuIGBudWxsYCBhbmQgaXQgaXMgaW1wb3J0YW50XG5cdFx0Ly8gdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuIHVuaW5pdGlhbGl6ZWQgX25leHREb20gYW5kXG5cdFx0Ly8gYSBfbmV4dERvbSB0aGF0IGhhcyBiZWVuIHNldCB0byBgbnVsbGBcblx0XHRfbmV4dERvbTogdW5kZWZpbmVkLFxuXHRcdF9jb21wb25lbnQ6IG51bGwsXG5cdFx0X2h5ZHJhdGluZzogbnVsbCxcblx0XHRjb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuXHRcdF9vcmlnaW5hbDogb3JpZ2luYWwgPT0gbnVsbCA/ICsrdm5vZGVJZCA6IG9yaWdpbmFsXG5cdH07XG5cblx0Ly8gT25seSBpbnZva2UgdGhlIHZub2RlIGhvb2sgaWYgdGhpcyB3YXMgKm5vdCogYSBkaXJlY3QgY29weTpcblx0aWYgKG9yaWdpbmFsID09IG51bGwgJiYgb3B0aW9ucy52bm9kZSAhPSBudWxsKSBvcHRpb25zLnZub2RlKHZub2RlKTtcblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG5cdHJldHVybiB7IGN1cnJlbnQ6IG51bGwgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEZyYWdtZW50KHByb3BzKSB7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIFByZWFjdCBWTm9kZS5cbiAqIEBwYXJhbSB7Kn0gdm5vZGVcbiAqIEByZXR1cm5zIHt2bm9kZSBpcyBpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRFbGVtZW50ID0gdm5vZGUgPT5cblx0dm5vZGUgIT0gbnVsbCAmJiB2bm9kZS5jb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkO1xuIiwiaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGRpZmYsIGNvbW1pdFJvb3QgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5cbi8qKlxuICogQmFzZSBDb21wb25lbnQgY2xhc3MuIFByb3ZpZGVzIGBzZXRTdGF0ZSgpYCBhbmQgYGZvcmNlVXBkYXRlKClgLCB3aGljaFxuICogdHJpZ2dlciByZW5kZXJpbmdcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBUaGUgaW5pdGlhbCBjb21wb25lbnQgcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IFRoZSBpbml0aWFsIGNvbnRleHQgZnJvbSBwYXJlbnQgY29tcG9uZW50cydcbiAqIGdldENoaWxkQ29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KSB7XG5cdHRoaXMucHJvcHMgPSBwcm9wcztcblx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuLyoqXG4gKiBVcGRhdGUgY29tcG9uZW50IHN0YXRlIGFuZCBzY2hlZHVsZSBhIHJlLXJlbmRlci5cbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0ge29iamVjdCB8ICgoczogb2JqZWN0LCBwOiBvYmplY3QpID0+IG9iamVjdCl9IHVwZGF0ZSBBIGhhc2ggb2Ygc3RhdGVcbiAqIHByb3BlcnRpZXMgdG8gdXBkYXRlIHdpdGggbmV3IHZhbHVlcyBvciBhIGZ1bmN0aW9uIHRoYXQgZ2l2ZW4gdGhlIGN1cnJlbnRcbiAqIHN0YXRlIGFuZCBwcm9wcyByZXR1cm5zIGEgbmV3IHBhcnRpYWwgc3RhdGVcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIGNvbXBvbmVudCBzdGF0ZSBpc1xuICogdXBkYXRlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24odXBkYXRlLCBjYWxsYmFjaykge1xuXHQvLyBvbmx5IGNsb25lIHN0YXRlIHdoZW4gY29weWluZyB0byBuZXh0U3RhdGUgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBzO1xuXHRpZiAodGhpcy5fbmV4dFN0YXRlICE9IG51bGwgJiYgdGhpcy5fbmV4dFN0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZTtcblx0fSBlbHNlIHtcblx0XHRzID0gdGhpcy5fbmV4dFN0YXRlID0gYXNzaWduKHt9LCB0aGlzLnN0YXRlKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgdXBkYXRlID09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBTb21lIGxpYnJhcmllcyBsaWtlIGBpbW1lcmAgbWFyayB0aGUgY3VycmVudCBzdGF0ZSBhcyByZWFkb25seSxcblx0XHQvLyBwcmV2ZW50aW5nIHVzIGZyb20gbXV0YXRpbmcgaXQsIHNvIHdlIG5lZWQgdG8gY2xvbmUgaXQuIFNlZSAjMjcxNlxuXHRcdHVwZGF0ZSA9IHVwZGF0ZShhc3NpZ24oe30sIHMpLCB0aGlzLnByb3BzKTtcblx0fVxuXG5cdGlmICh1cGRhdGUpIHtcblx0XHRhc3NpZ24ocywgdXBkYXRlKTtcblx0fVxuXG5cdC8vIFNraXAgdXBkYXRlIGlmIHVwZGF0ZXIgZnVuY3Rpb24gcmV0dXJuZWQgbnVsbFxuXHRpZiAodXBkYXRlID09IG51bGwpIHJldHVybjtcblxuXHRpZiAodGhpcy5fdm5vZGUpIHtcblx0XHRpZiAoY2FsbGJhY2spIHRoaXMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9XG59O1xuXG4vKipcbiAqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudFxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciBjb21wb25lbnQgaXNcbiAqIHJlLXJlbmRlcmVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRpZiAodGhpcy5fdm5vZGUpIHtcblx0XHQvLyBTZXQgcmVuZGVyIG1vZGUgc28gdGhhdCB3ZSBjYW4gZGlmZmVyZW50aWF0ZSB3aGVyZSB0aGUgcmVuZGVyIHJlcXVlc3Rcblx0XHQvLyBpcyBjb21pbmcgZnJvbS4gV2UgbmVlZCB0aGlzIGJlY2F1c2UgZm9yY2VVcGRhdGUgc2hvdWxkIG5ldmVyIGNhbGxcblx0XHQvLyBzaG91bGRDb21wb25lbnRVcGRhdGVcblx0XHR0aGlzLl9mb3JjZSA9IHRydWU7XG5cdFx0aWYgKGNhbGxiYWNrKSB0aGlzLl9yZW5kZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBBY2NlcHRzIGBwcm9wc2AgYW5kIGBzdGF0ZWAsIGFuZCByZXR1cm5zIGEgbmV3IFZpcnR1YWwgRE9NIHRyZWUgdG8gYnVpbGQuXG4gKiBWaXJ0dWFsIERPTSBpcyBnZW5lcmFsbHkgY29uc3RydWN0ZWQgdmlhIFtKU1hdKGh0dHA6Ly9qYXNvbmZvcm1hdC5jb20vd3RmLWlzLWpzeCkuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgUHJvcHMgKGVnOiBKU1ggYXR0cmlidXRlcykgcmVjZWl2ZWQgZnJvbSBwYXJlbnRcbiAqIGVsZW1lbnQvY29tcG9uZW50XG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgVGhlIGNvbXBvbmVudCdzIGN1cnJlbnQgc3RhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IENvbnRleHQgb2JqZWN0LCBhcyByZXR1cm5lZCBieSB0aGUgbmVhcmVzdFxuICogYW5jZXN0b3IncyBgZ2V0Q2hpbGRDb250ZXh0KClgXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW4gfCB2b2lkfVxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IEZyYWdtZW50O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcGFyYW0ge251bWJlciB8IG51bGx9IFtjaGlsZEluZGV4XVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9tU2libGluZyh2bm9kZSwgY2hpbGRJbmRleCkge1xuXHRpZiAoY2hpbGRJbmRleCA9PSBudWxsKSB7XG5cdFx0Ly8gVXNlIGNoaWxkSW5kZXg9PW51bGwgYXMgYSBzaWduYWwgdG8gcmVzdW1lIHRoZSBzZWFyY2ggZnJvbSB0aGUgdm5vZGUncyBzaWJsaW5nXG5cdFx0cmV0dXJuIHZub2RlLl9wYXJlbnRcblx0XHRcdD8gZ2V0RG9tU2libGluZyh2bm9kZS5fcGFyZW50LCB2bm9kZS5fcGFyZW50Ll9jaGlsZHJlbi5pbmRleE9mKHZub2RlKSArIDEpXG5cdFx0XHQ6IG51bGw7XG5cdH1cblxuXHRsZXQgc2libGluZztcblx0Zm9yICg7IGNoaWxkSW5kZXggPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBjaGlsZEluZGV4KyspIHtcblx0XHRzaWJsaW5nID0gdm5vZGUuX2NoaWxkcmVuW2NoaWxkSW5kZXhdO1xuXG5cdFx0aWYgKHNpYmxpbmcgIT0gbnVsbCAmJiBzaWJsaW5nLl9kb20gIT0gbnVsbCkge1xuXHRcdFx0Ly8gU2luY2UgdXBkYXRlUGFyZW50RG9tUG9pbnRlcnMga2VlcHMgX2RvbSBwb2ludGVyIGNvcnJlY3QsXG5cdFx0XHQvLyB3ZSBjYW4gcmVseSBvbiBfZG9tIHRvIHRlbGwgdXMgaWYgdGhpcyBzdWJ0cmVlIGNvbnRhaW5zIGFcblx0XHRcdC8vIHJlbmRlcmVkIERPTSBub2RlLCBhbmQgd2hhdCB0aGUgZmlyc3QgcmVuZGVyZWQgRE9NIG5vZGUgaXNcblx0XHRcdHJldHVybiBzaWJsaW5nLl9kb207XG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgd2UgZ2V0IGhlcmUsIHdlIGhhdmUgbm90IGZvdW5kIGEgRE9NIG5vZGUgaW4gdGhpcyB2bm9kZSdzIGNoaWxkcmVuLlxuXHQvLyBXZSBtdXN0IHJlc3VtZSBmcm9tIHRoaXMgdm5vZGUncyBzaWJsaW5nIChpbiBpdCdzIHBhcmVudCBfY2hpbGRyZW4gYXJyYXkpXG5cdC8vIE9ubHkgY2xpbWIgdXAgYW5kIHNlYXJjaCB0aGUgcGFyZW50IGlmIHdlIGFyZW4ndCBzZWFyY2hpbmcgdGhyb3VnaCBhIERPTVxuXHQvLyBWTm9kZSAobWVhbmluZyB3ZSByZWFjaGVkIHRoZSBET00gcGFyZW50IG9mIHRoZSBvcmlnaW5hbCB2bm9kZSB0aGF0IGJlZ2FuXG5cdC8vIHRoZSBzZWFyY2gpXG5cdHJldHVybiB0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBudWxsO1xufVxuXG4vKipcbiAqIFRyaWdnZXIgaW4tcGxhY2UgcmUtcmVuZGVyaW5nIG9mIGEgY29tcG9uZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIHJlcmVuZGVyXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudChjb21wb25lbnQpIHtcblx0bGV0IHZub2RlID0gY29tcG9uZW50Ll92bm9kZSxcblx0XHRvbGREb20gPSB2bm9kZS5fZG9tLFxuXHRcdHBhcmVudERvbSA9IGNvbXBvbmVudC5fcGFyZW50RG9tO1xuXG5cdGlmIChwYXJlbnREb20pIHtcblx0XHRsZXQgY29tbWl0UXVldWUgPSBbXTtcblx0XHRjb25zdCBvbGRWTm9kZSA9IGFzc2lnbih7fSwgdm5vZGUpO1xuXHRcdG9sZFZOb2RlLl9vcmlnaW5hbCA9IHZub2RlLl9vcmlnaW5hbCArIDE7XG5cblx0XHRkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0dm5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGNvbXBvbmVudC5fZ2xvYmFsQ29udGV4dCxcblx0XHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHRcdHZub2RlLl9oeWRyYXRpbmcgIT0gbnVsbCA/IFtvbGREb21dIDogbnVsbCxcblx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0b2xkRG9tID09IG51bGwgPyBnZXREb21TaWJsaW5nKHZub2RlKSA6IG9sZERvbSxcblx0XHRcdHZub2RlLl9oeWRyYXRpbmdcblx0XHQpO1xuXHRcdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcblxuXHRcdGlmICh2bm9kZS5fZG9tICE9IG9sZERvbSkge1xuXHRcdFx0dXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKSB7XG5cdGlmICgodm5vZGUgPSB2bm9kZS5fcGFyZW50KSAhPSBudWxsICYmIHZub2RlLl9jb21wb25lbnQgIT0gbnVsbCkge1xuXHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBudWxsO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgY2hpbGQgPSB2bm9kZS5fY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5fZG9tICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuX2RvbSA9IHZub2RlLl9jb21wb25lbnQuYmFzZSA9IGNoaWxkLl9kb207XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgcmVuZGVyIHF1ZXVlXG4gKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn1cbiAqL1xubGV0IHJlcmVuZGVyUXVldWUgPSBbXTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gKiBAdHlwZSB7KGNiOiAoKSA9PiB2b2lkKSA9PiB2b2lkfVxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLy8gTm90ZSB0aGUgZm9sbG93aW5nIGxpbmUgaXNuJ3QgdHJlZS1zaGFrZW4gYnkgcm9sbHVwIGN1eiBvZiByb2xsdXAvcm9sbHVwIzI1NjZcbmNvbnN0IGRlZmVyID1cblx0dHlwZW9mIFByb21pc2UgPT0gJ2Z1bmN0aW9uJ1xuXHRcdD8gUHJvbWlzZS5wcm90b3R5cGUudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKVxuXHRcdDogc2V0VGltZW91dDtcblxuLypcbiAqIFRoZSB2YWx1ZSBvZiBgQ29tcG9uZW50LmRlYm91bmNlYCBtdXN0IGFzeW5jaHJvbm91c2x5IGludm9rZSB0aGUgcGFzc2VkIGluIGNhbGxiYWNrLiBJdCBpc1xuICogaW1wb3J0YW50IHRoYXQgY29udHJpYnV0b3JzIHRvIFByZWFjdCBjYW4gY29uc2lzdGVudGx5IHJlYXNvbiBhYm91dCB3aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAsIGV0Yy5cbiAqIGRvLCBhbmQgd2hlbiB0aGVpciBlZmZlY3RzIHdpbGwgYmUgYXBwbGllZC4gU2VlIHRoZSBsaW5rcyBiZWxvdyBmb3Igc29tZSBmdXJ0aGVyIHJlYWRpbmcgb24gZGVzaWduaW5nXG4gKiBhc3luY2hyb25vdXMgQVBJcy5cbiAqICogW0Rlc2lnbmluZyBBUElzIGZvciBBc3luY2hyb255XShodHRwczovL2Jsb2cuaXpzLm1lLzIwMTMvMDgvZGVzaWduaW5nLWFwaXMtZm9yLWFzeW5jaHJvbnkpXG4gKiAqIFtDYWxsYmFja3Mgc3luY2hyb25vdXMgYW5kIGFzeW5jaHJvbm91c10oaHR0cHM6Ly9ibG9nLm9tZXRlci5jb20vMjAxMS8wNy8yNC9jYWxsYmFja3Mtc3luY2hyb25vdXMtYW5kLWFzeW5jaHJvbm91cy8pXG4gKi9cblxubGV0IHByZXZEZWJvdW5jZTtcblxuLyoqXG4gKiBFbnF1ZXVlIGEgcmVyZW5kZXIgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjIFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoYykge1xuXHRpZiAoXG5cdFx0KCFjLl9kaXJ0eSAmJlxuXHRcdFx0KGMuX2RpcnR5ID0gdHJ1ZSkgJiZcblx0XHRcdHJlcmVuZGVyUXVldWUucHVzaChjKSAmJlxuXHRcdFx0IXByb2Nlc3MuX3JlcmVuZGVyQ291bnQrKykgfHxcblx0XHRwcmV2RGVib3VuY2UgIT09IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdcblx0KSB7XG5cdFx0cHJldkRlYm91bmNlID0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZztcblx0XHQocHJldkRlYm91bmNlIHx8IGRlZmVyKShwcm9jZXNzKTtcblx0fVxufVxuXG4vKiogRmx1c2ggdGhlIHJlbmRlciBxdWV1ZSBieSByZXJlbmRlcmluZyBhbGwgcXVldWVkIGNvbXBvbmVudHMgKi9cbmZ1bmN0aW9uIHByb2Nlc3MoKSB7XG5cdGxldCBxdWV1ZTtcblx0d2hpbGUgKChwcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gcmVyZW5kZXJRdWV1ZS5sZW5ndGgpKSB7XG5cdFx0cXVldWUgPSByZXJlbmRlclF1ZXVlLnNvcnQoKGEsIGIpID0+IGEuX3Zub2RlLl9kZXB0aCAtIGIuX3Zub2RlLl9kZXB0aCk7XG5cdFx0cmVyZW5kZXJRdWV1ZSA9IFtdO1xuXHRcdC8vIERvbid0IHVwZGF0ZSBgcmVuZGVyQ291bnRgIHlldC4gS2VlcCBpdHMgdmFsdWUgbm9uLXplcm8gdG8gcHJldmVudCB1bm5lY2Vzc2FyeVxuXHRcdC8vIHByb2Nlc3MoKSBjYWxscyBmcm9tIGdldHRpbmcgc2NoZWR1bGVkIHdoaWxlIGBxdWV1ZWAgaXMgc3RpbGwgYmVpbmcgY29uc3VtZWQuXG5cdFx0cXVldWUuc29tZShjID0+IHtcblx0XHRcdGlmIChjLl9kaXJ0eSkgcmVuZGVyQ29tcG9uZW50KGMpO1xuXHRcdH0pO1xuXHR9XG59XG5wcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gMDtcbiIsImV4cG9ydCBjb25zdCBFTVBUWV9PQkogPSB7fTtcbmV4cG9ydCBjb25zdCBFTVBUWV9BUlIgPSBbXTtcbmV4cG9ydCBjb25zdCBJU19OT05fRElNRU5TSU9OQUwgPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO1xuIiwiZnVuY3Rpb24gdG9WYWwobWl4KSB7XG5cdHZhciBrLCB5LCBzdHI9Jyc7XG5cblx0aWYgKHR5cGVvZiBtaXggPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBtaXggPT09ICdudW1iZXInKSB7XG5cdFx0c3RyICs9IG1peDtcblx0fSBlbHNlIGlmICh0eXBlb2YgbWl4ID09PSAnb2JqZWN0Jykge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KG1peCkpIHtcblx0XHRcdGZvciAoaz0wOyBrIDwgbWl4Lmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdGlmIChtaXhba10pIHtcblx0XHRcdFx0XHRpZiAoeSA9IHRvVmFsKG1peFtrXSkpIHtcblx0XHRcdFx0XHRcdHN0ciAmJiAoc3RyICs9ICcgJyk7XG5cdFx0XHRcdFx0XHRzdHIgKz0geTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChrIGluIG1peCkge1xuXHRcdFx0XHRpZiAobWl4W2tdKSB7XG5cdFx0XHRcdFx0c3RyICYmIChzdHIgKz0gJyAnKTtcblx0XHRcdFx0XHRzdHIgKz0gaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcblx0dmFyIGk9MCwgdG1wLCB4LCBzdHI9Jyc7XG5cdHdoaWxlIChpIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGlmICh0bXAgPSBhcmd1bWVudHNbaSsrXSkge1xuXHRcdFx0aWYgKHggPSB0b1ZhbCh0bXApKSB7XG5cdFx0XHRcdHN0ciAmJiAoc3RyICs9ICcgJyk7XG5cdFx0XHRcdHN0ciArPSB4XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdHI7XG59XG4iLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9jdW1lbnQoZWxlbWVudD86IE5vZGUpIHsgcmV0dXJuIChlbGVtZW50Py5vd25lckRvY3VtZW50ID8/IGRvY3VtZW50ID8/IHdpbmRvdy5kb2N1bWVudCA/PyBnbG9iYWxUaGlzLmRvY3VtZW50KTsgfVxuXG50eXBlIFAgPSBQYXJhbWV0ZXJzPHR5cGVvZiBjbHN4PjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURvY3VtZW50Q2xhc3MoY2xhc3NOYW1lOiBQWzBdLCBhY3RpdmU/OiBib29sZWFuLCBlbGVtZW50PzogSFRNTEVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID8/PSBnZXREb2N1bWVudCgpLmRvY3VtZW50RWxlbWVudDtcbiAgICBjbGFzc05hbWUgPSBjbHN4KGNsYXNzTmFtZSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lIGFzIHN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGVsZW1lbnQhLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lIGFzIHN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sIFtjbGFzc05hbWUsIGFjdGl2ZSwgZWxlbWVudF0pO1xuXG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWR1Y2VyLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cblxuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTPiA9ICh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQ+ID0gKCh2YWx1ZTogVCwgcHJldlZhbHVlOiBUIHwgdW5kZWZpbmVkKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpO1xuXG4vKipcbiAqIERlYnVnIGhvb2suXG4gKiBcbiAqIEdpdmVuIGEgdmFsdWUgb3Igc2V0IG9mIHZhbHVlcywgZW1pdHMgYSBjb25zb2xlIGVycm9yIGlmIGFueSBvZiB0aGVtIGNoYW5nZSBmcm9tIG9uZSByZW5kZXIgdG8gdGhlIG5leHQuXG4gKiBcbiAqIEV2ZW50dWFsbHksIHdoZW4gdXNlRXZlbnQgbGFuZHMsIHdlIGhvcGVmdWxseSB3b24ndCBuZWVkIHRoaXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFbnN1cmVTdGFiaWxpdHk8VCBleHRlbmRzIGFueVtdPihwYXJlbnRIb29rTmFtZTogc3RyaW5nLCAuLi52YWx1ZXM6IFQpIHtcbiAgICB1c2VIZWxwZXIodmFsdWVzLmxlbmd0aCwgMCk7XG4gICAgdmFsdWVzLmZvckVhY2godXNlSGVscGVyKTtcbiAgICByZXR1cm47XG5cblxuICAgIGZ1bmN0aW9uIHVzZUhlbHBlcjxVPih2YWx1ZTogVSwgaW5kZXg6IG51bWJlcikge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICAgICAgY29uc3QgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkgPSB1c2VSZWYodmFsdWUpO1xuICAgICAgICBjb25zdCBzaG93bkVycm9yID0gdXNlUmVmKGZhbHNlKTtcbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnQgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghc2hvd25FcnJvci5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBUaGUgaG9vayAke3BhcmVudEhvb2tOYW1lfSByZXF1aXJlcyBzb21lIG9yIGFsbCBvZiBpdHMgYXJndW1lbnRzIHJlbWFpbiBzdGFibGUgYWNyb3NzIGVhY2ggcmVuZGVyOyBwbGVhc2UgY2hlY2sgdGhlICR7aW5kZXh9LWluZGV4ZWQgYXJndW1lbnQuYCk7XG4gICAgICAgICAgICAgICAgc2hvd25FcnJvci5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFzc2l2ZVN0YXRlMjxUPihvbkNoYW5nZTogdW5kZWZpbmVkIHwgbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQ+LCBnZXRJbml0aWFsOiAoKSA9PiBUKTogWygpID0+IFQsIFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD5dIHtcbiAgICB0eXBlIFN0YXRlVHlwZSA9IHsgdmFsdWU6IFQgfCB0eXBlb2YgVW5zZXQgfVxuICAgIFxuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGNsZWFudXBDYWxsYmFja1JlZiA9IHVzZVJlZjx2b2lkIHwgdW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpPih1bmRlZmluZWQpO1xuXG4gICAgY29uc3QgW3N0b3JlZCwgc2V0U3RvcmVkXSA9IHVzZVJlZHVjZXI8U3RhdGVUeXBlLCBUPigocHJldiwgYWN0aW9uKSA9PiB7XG4gICAgICAgIGlmIChwcmV2LnZhbHVlICE9PSBhY3Rpb24pIHtcbiAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQpIFxuICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gb25DaGFuZ2U/LihhY3Rpb24sIHByZXYudmFsdWUgPT09IFVuc2V0PyBnZXRJbml0aWFsKCkgOiBwcmV2LnZhbHVlKTtcbiAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHByZXYudmFsdWUgPSBhY3Rpb247XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgIH0sIHsgdmFsdWU6IFVuc2V0IH0pO1xuXG4gICAgY29uc3QgZ2V0U3RhdGUgPSB1c2VDYWxsYmFjaygoKTogVCA9PiB7IFxuICAgICAgICBpZiAod2FybmluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVyaW5nIG9uQ2hhbmdlLCBwcmVmZXIgdXNpbmcgdGhlICh2YWx1ZSwgcHJldlZhbHVlKSBhcmd1bWVudHMgaW5zdGVhZCBvZiBnZXRWYWx1ZSAtLSBpdCdzIGFtYmlndW91cyBhcyB0byBpZiB5b3UncmUgYXNraW5nIGZvciB0aGUgb2xkIG9yIG5ldyB2YWx1ZSBhdCB0aGlzIHBvaW50IGluIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50LlwiKTtcblxuICAgICAgICByZXR1cm4gc3RvcmVkLnZhbHVlID09PSBVbnNldD8gZ2V0SW5pdGlhbCgpIDogc3RvcmVkLnZhbHVlO1xuICAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBzZXRTdGF0ZSA9IHVzZUNhbGxiYWNrPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD4+KChuZXh0VmFsdWVHZXR0ZXIpID0+IHtcbiAgICAgICAgbGV0IG5leHRWYWx1ZTogVDtcbiAgICAgICAgaWYgKG5leHRWYWx1ZUdldHRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgICAgICAgbmV4dFZhbHVlR2V0dGVyKGdldFN0YXRlKCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXh0VmFsdWUgPSBuZXh0VmFsdWVHZXR0ZXI7XG5cbiAgICAgICAgc2V0U3RvcmVkKG5leHRWYWx1ZSEpO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtnZXRTdGF0ZSwgc2V0U3RhdGVdO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYHVzZVN0YXRlYCwgYnV0IGZvciB2YWx1ZXMgdGhhdCBhcmVuJ3QgXCJyZW5kZXItaW1wb3J0YW50XCIgJm5kYXNoOyB1cGRhdGVzIGRvbid0IGNhdXNlIGEgcmUtcmVuZGVyIGFuZCBzbyB0aGUgdmFsdWUgc2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHJlbmRlciAodGhvdWdoIGl0IGNlcnRhaW5seSBjYW4sIGF0IGxlYXN0IGJ5IHJlLXJlbmRlcmluZyBhZ2FpbikuXG4gKiBcbiAqIFRvIGNvbXBlbnNhdGUgZm9yIHRoaXMsIHlvdSBzaG91bGQgcGFzcyBhIGB1c2VFZmZlY3RgLWVzcXVlIGNhbGxiYWNrIHRoYXQgaXMgcnVuIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSnVzdCBsaWtlIGB1c2VFZmZlY3RgLCB0aGlzIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQncyBydW4gYmVmb3JlIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgKG9yLCBzYXksIHdoZW4gdGhlIHZhbHVlIG1lZXRzIHNvbWUgY3JpdGVyaWEpLCB0aGlzIGlzIHdoZXJlIHlvdSdsbCB3YW50IHRvIHB1dCBpbiBhIGNhbGwgdG8gYSBgc2V0U3RhdGVgIGZ1bmN0aW9uLlxuICogXG4gKiBUbyBzdW1tYXJpemUsIGl0J3MgbGlrZSBhIGB1c2VTdGF0ZWAtYHVzZUVmZmVjdGAgbWFzaHVwOlxuICogXG4gKiAxLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHRoaXMgdmVyc2lvbiBvZiBgc2V0U3RhdGVgIGRvZXNuJ3QgcmUtcmVuZGVyIHRoZSB3aG9sZSBjb21wb25lbnRcbiAqIDIuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgeW91IGNhbiBydW4gYSBmdW5jdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIHRoYXQgb3B0aW9uYWxseSByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvblxuICogMy4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgeW91IHRyaWdnZXIgdGhlIGVmZmVjdCBmdW5jdGlvbiBcInJlbW90ZWx5XCIgaW5zdGVhZCBvZiBpdCBydW5uaW5nIGFmdGVyIHJlbmRlcmluZ1xuICogNC4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgdGhlIHNpbmdsZSBcImRlcGVuZGVuY3lcIiBpcyBiYXNlZCBvbiB5b3VyIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAqIFxuICogTm90ZSB0aGF0IHdoaWxlIGNhbGxpbmcgYHNldFN0YXRlYCBkb2Vzbid0IGNhdXNlIGFueSByZS1yZW5kZXJzLCB5b3UgY2FuIGRvIHRoYXQgd2l0aGluIHlvdXIgYG9uQ2hhbmdlYCBmdW5jdGlvbiwgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzIHZpYSB0aGF0IGBzZXRTdGF0ZWAuXG4gKiBcbiAqIEBwYXJhbSBvbkNoYW5nZSBUaGUgXCJlZmZlY3RcIiBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYHVzZUVmZmVjdGAncyBcImVmZmVjdFwiIGZ1bmN0aW9uLiAgTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBnZXRJbml0aWFsVmFsdWUgSWYgcHJvdmlkZWQsIHRoZSBlZmZlY3Qgd2lsbCBiZSBpbnZva2VkIG9uY2Ugd2l0aCB0aGlzIHZhbHVlIG9uIG1vdW50LiBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXNzaXZlU3RhdGU8VD4ob25DaGFuZ2U6IHVuZGVmaW5lZCB8IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUPiwgZ2V0SW5pdGlhbFZhbHVlPzogKCkgPT4gVCk6IHJlYWRvbmx5IFsoKSA9PiBULCBQYXNzaXZlU3RhdGVVcGRhdGVyPFQ+XSB7XG5cbiAgICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZjxUIHwgdHlwZW9mIFVuc2V0PihVbnNldCk7XG4gICAgY29uc3Qgd2FybmluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgY2xlYW51cENhbGxiYWNrUmVmID0gdXNlUmVmPHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKT4odW5kZWZpbmVkKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VQYXNzaXZlU3RhdGVcIiwgb25DaGFuZ2UsIGdldEluaXRpYWxWYWx1ZSk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBcImRlcGVuZGVuY3kgY2hhbmdlZFwiIGFuZCBcImNvbXBvbmVudCB1bm1vdW50ZWRcIi5cbiAgICBjb25zdCBvblNob3VsZENsZWFuVXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXBDYWxsYmFjayA9IGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50O1xuICAgICAgICBpZiAoY2xlYW51cENhbGxiYWNrKVxuICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrKCk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlcmUgYXJlIGEgY291cGxlIHBsYWNlcyB3aGVyZSB3ZSdkIGxpa2UgdG8gdXNlIG91ciBpbml0aWFsXG4gICAgLy8gdmFsdWUgaW4gcGxhY2Ugb2YgaGF2aW5nIG5vIHZhbHVlIGF0IGFsbCB5ZXQuXG4gICAgLy8gVGhpcyBpcyB0aGUgc2hhcmVkIGNvZGUgZm9yIHRoYXQsIHVzZWQgb24gbW91bnQgYW5kIHdoZW5ldmVyXG4gICAgLy8gZ2V0VmFsdWUgaXMgY2FsbGVkLlxuICAgIGNvbnN0IHRyeUVuc3VyZVZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgJiYgZ2V0SW5pdGlhbFZhbHVlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsVmFsdWUgPSBnZXRJbml0aWFsVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4oaW5pdGlhbFZhbHVlLCB1bmRlZmluZWQpID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHRpb25zIGFyZSBpbnRlbnRpb25hbCB0byBhbGxvdyBiYWlsb3V0ICh3aXRob3V0IGV4cG9zaW5nIHRoZSBVbnNldCBzeW1ib2wpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbLyogZ2V0SW5pdGlhbFZhbHVlIGFuZCBvbkNoYW5nZSBpbnRlbnRpb25hbGx5IG9taXR0ZWQgKi9dKTtcblxuXG4gICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh3YXJuaW5nUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEdXJpbmcgb25DaGFuZ2UsIHByZWZlciB1c2luZyB0aGUgKHZhbHVlLCBwcmV2VmFsdWUpIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIGdldFZhbHVlIC0tIGl0J3MgYW1iaWd1b3VzIGFzIHRvIGlmIHlvdSdyZSBhc2tpbmcgZm9yIHRoZSBvbGQgb3IgbmV3IHZhbHVlIGF0IHRoaXMgcG9pbnQgaW4gdGltZSBmb3IgdGhpcyBjb21wb25lbnQuXCIpO1xuXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIGNhbGwgZ2V0VmFsdWUsIGlmIHdlIGhhdmVuJ3QgYmVlbiBnaXZlbiBhIHZhbHVlIHlldCxcbiAgICAgICAgLy8gKGFuZCB3ZSB3ZXJlIGdpdmVuIGFuIGluaXRpYWwgdmFsdWUgdG8gdXNlKVxuICAgICAgICAvLyByZXR1cm4gdGhlIGluaXRpYWwgdmFsdWUgaW5zdGVhZCBvZiBub3RoaW5nLlxuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQpXG4gICAgICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuXG4gICAgICAgIHJldHVybiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQhIDogdmFsdWVSZWYuY3VycmVudCEpIGFzIFQ7XG4gICAgfSwgW10pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3ZlIHJ1biBvdXIgZWZmZWN0IGF0IGxlYXN0IG9uY2Ugb24gbW91bnQuXG4gICAgICAgIC8vIChJZiB3ZSBoYXZlIGFuIGluaXRpYWwgdmFsdWUsIG9mIGNvdXJzZSlcbiAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcblxuXG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlIGFjdHVhbCBjb2RlIHRoZSB1c2VyIGNhbGxzIHRvIChwb3NzaWJseSkgcnVuIGEgbmV3IGVmZmVjdC5cbiAgICBjb25zdCBzZXRWYWx1ZSA9IHVzZUNhbGxiYWNrPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD4+KChhcmcpID0+IHtcbiAgICAgICAgY29uc3QgcHJldkRlcCA9IHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogZ2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3QgZGVwID0gYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcocHJldkRlcCEpIDogYXJnO1xuXG4gICAgICAgIGlmIChkZXAgIT09IHZhbHVlUmVmLmN1cnJlbnQpIHtcblxuICAgICAgICAgICAgLy8gSW5kaWNhdGUgdG8gdGhlIHVzZXIgdGhhdCB0aGV5IHNob3VsZG4ndCBjYWxsIGdldFZhbHVlIGR1cmluZyBvbkNoYW5nZVxuICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQ2FsbCBhbnkgcmVnaXN0ZXJkIGNsZWFudXAgZnVuY3Rpb25cbiAgICAgICAgICAgIG9uU2hvdWxkQ2xlYW5VcCgpO1xuICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/LihkZXAsIHByZXZEZXApID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gZGVwO1xuXG4gICAgICAgICAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBub3JtYWxseSBjYWxsIGdldFZhbHVlIGFnYWluXG4gICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBbZ2V0VmFsdWUsIHNldFZhbHVlXSBhcyBjb25zdDtcbn1cblxuY29uc3QgVW5zZXQgPSBTeW1ib2woKTtcblxuLy8gRWFzeSBjb25zdGFudHMgZm9yIGdldEluaXRpYWxWYWx1ZVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblRydWUoKSB7IHJldHVybiB0cnVlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybk51bGwoKSB7IHJldHVybiBudWxsOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVW5kZWZpbmVkKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuWmVybygpIHsgcmV0dXJuIDA7IH0iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbjxMaHMgZXh0ZW5kcyBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PiwgXCJjaGlsZHJlblwiPiB8IG51bGwgfCB1bmRlZmluZWQsIFJocyBleHRlbmRzIFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcImNoaWxkcmVuXCI+IHwgbnVsbCB8IHVuZGVmaW5lZD4obGhzUHJvcHM6IExocywgcmhzUHJvcHM6IFJocyk6IENvbXBvbmVudENoaWxkcmVuIHtcblxuICAgIGNvbnN0IGxocyA9IGxoc1Byb3BzPy5jaGlsZHJlbjtcbiAgICBjb25zdCByaHMgPSByaHNQcm9wcz8uY2hpbGRyZW47XG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByaHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByZXQgPSBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgbGhzLCByaHMpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGRlZmF1bHQgYXMgY2xzeCB9IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVpciBgY2xhc3NgIGFuZCBgY2xhc3NOYW1lYCBwcm9wZXJ0aWVzLlxyXG4gKiBEdXBsaWNhdGUgY2xhc3NlcyBhcmUgcmVtb3ZlZCAob3JkZXIgZG9lc24ndCBtYXR0ZXIgYW55d2F5KS5cclxuICogXHJcbiAqIEBwYXJhbSBsaHMgQ2xhc3NlcyBvZiB0aGUgZmlyc3QgY29tcG9uZW50XHJcbiAqIEBwYXJhbSByaHMgQ2xhc3NlcyBvZiB0aGUgc2Vjb25kIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIGNvbWJpbmVkIGNsYXNzZXMgZnJvbSBib3RoIGFyZ3VtZW50cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDbGFzc2VzPExocyBleHRlbmRzIE1lcmdlQ2xhc3Nlc1Byb3BzIHwgbnVsbCB8IHVuZGVmaW5lZCwgUmhzIGV4dGVuZHMgTWVyZ2VDbGFzc2VzUHJvcHMgfCBudWxsIHwgdW5kZWZpbmVkPihsaHM6IExocywgcmhzOiBSaHMpOiBNZXJnZWRDbGFzc2VzPExocywgUmhzPiB7XHJcblxyXG4gICAgLy8gTm90ZTogRm9yIHRoZSBzYWtlIG9mIGZvcndhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmdW5jdGlvbiBpcyBsYWJlbGxlZCBhc1xyXG4gICAgLy8gYSBob29rLCBidXQgYXMgaXQgdXNlcyBubyBvdGhlciBob29rcyBpdCB0ZWNobmljYWxseSBpc24ndCBvbmUuXHJcbiAgICByZXR1cm4gbWVyZ2VDbGFzc2VzKGxocywgcmhzKTtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTWVyZ2VkQ2xhc3NlczxMaHMgZXh0ZW5kcyBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+IHwgbnVsbCB8IHVuZGVmaW5lZCwgUmhzIGV4dGVuZHMgUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBcImNsYXNzXCIgfCBcImNsYXNzTmFtZVwiPiB8IG51bGwgfCB1bmRlZmluZWQ+ID1cclxuICAgIE5vbk51bGxhYmxlPEdldEJvdGhDbGFzc2VzPExocz4+IGV4dGVuZHMgbmV2ZXIgP1xyXG4gICAgTm9uTnVsbGFibGU8R2V0Qm90aENsYXNzZXM8UmhzPj4gZXh0ZW5kcyBuZXZlciA/XHJcbiAgICB1bmRlZmluZWQgfCBzdHJpbmcgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvdGggYXJlIG9ubHkgbnVsbFxyXG4gICAgTm9uTnVsbGFibGU8R2V0Qm90aENsYXNzZXM8UmhzPj4gOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJocyBjb250YWlucyBhIHZhbHVlLCBsaHMgaXMgb25seSBudWxsXHJcbiAgICBOb25OdWxsYWJsZTxHZXRCb3RoQ2xhc3NlczxSaHM+PiBleHRlbmRzIG5ldmVyID8gTm9uTnVsbGFibGU8R2V0Qm90aENsYXNzZXM8TGhzPj4gOiAgICAvLyBMaHMgY29udGFpbnMgYSB2YWx1ZSwgcmhzIGlzIG9ubHkgbnVsbFxyXG4gICAgc3RyaW5nOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb3RoIHR5cGVzIGFyZSBub24tbnVsbFxyXG5cclxuXHJcblxyXG50eXBlIEdldENsYXNzT3JVbmRlZmluZWQ8VCBleHRlbmRzIHsgY2xhc3M/OiBhbnkgfSB8IG51bGwgfCB1bmRlZmluZWQ+ID0gVCBleHRlbmRzIHsgY2xhc3M6IGluZmVyIFUgfSA/IFUgOiB1bmRlZmluZWQ7XHJcbnR5cGUgR2V0Q2xhc3NOYW1lT3JVbmRlZmluZWQ8VCBleHRlbmRzIHsgY2xhc3NOYW1lPzogYW55IH0gfCBudWxsIHwgdW5kZWZpbmVkPiA9IFQgZXh0ZW5kcyB7IGNsYXNzTmFtZTogaW5mZXIgVSB9ID8gVSA6IHVuZGVmaW5lZDtcclxudHlwZSBHZXRCb3RoQ2xhc3NlczxUIGV4dGVuZHMgeyBjbGFzcz86IGFueSwgY2xhc3NOYW1lPzogYW55IH0gfCBudWxsIHwgdW5kZWZpbmVkPiA9XHJcbk5vbk51bGxhYmxlPEdldENsYXNzT3JVbmRlZmluZWQ8VD4gfCBHZXRDbGFzc05hbWVPclVuZGVmaW5lZDxUPj4gZXh0ZW5kcyBuZXZlcj8gdW5kZWZpbmVkIDogc3RyaW5nO1xyXG5cclxuZXhwb3J0IHR5cGUgTWVyZ2VDbGFzc2VzUHJvcHMgPSBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+O1xyXG5cclxuZnVuY3Rpb24gbWVyZ2VDbGFzc2VzPExocyBleHRlbmRzIE1lcmdlQ2xhc3Nlc1Byb3BzIHwgbnVsbCB8IHVuZGVmaW5lZCwgUmhzIGV4dGVuZHMgTWVyZ2VDbGFzc2VzUHJvcHMgfCBudWxsIHwgdW5kZWZpbmVkPihsaHM6IExocywgcmhzOiBSaHMpOiBNZXJnZWRDbGFzc2VzPExocywgUmhzPiB7XHJcbiAgICBjb25zdCBsaHNDbGFzcyA9IGxocz8uY2xhc3M7XHJcbiAgICBjb25zdCBsaHNDbGFzc05hbWUgPSBsaHM/LmNsYXNzTmFtZTtcclxuICAgIGNvbnN0IHJoc0NsYXNzID0gcmhzPy5jbGFzcztcclxuICAgIGNvbnN0IHJoc0NsYXNzTmFtZSA9IHJocz8uY2xhc3NOYW1lO1xyXG5cclxuICAgIGlmIChsaHNDbGFzcyB8fCByaHNDbGFzcyB8fCBsaHNDbGFzc05hbWUgfHwgcmhzQ2xhc3NOYW1lKSB7XHJcbiAgICAgICAgY29uc3QgbGhzQ2xhc3NlcyA9IGNsc3gobGhzQ2xhc3MsIGxoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgIGNvbnN0IHJoc0NsYXNzZXMgPSBjbHN4KHJoc0NsYXNzLCByaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBjb25zdCBhbGxDbGFzc2VzID0gbmV3IFNldChbLi4uQXJyYXkuZnJvbShsaHNDbGFzc2VzKSwgLi4uQXJyYXkuZnJvbShyaHNDbGFzc2VzKV0pXHJcblxyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGFsbENsYXNzZXMpLmpvaW4oXCIgXCIpIGFzIE1lcmdlZENsYXNzZXM8TGhzLCBSaHM+O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZCBhcyBNZXJnZWRDbGFzc2VzPExocywgUmhzPjtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBSZWYsIFJlZkNhbGxiYWNrLCBSZWZPYmplY3QgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWY8VD4oaW5zdGFuY2U6IFQgfCBudWxsLCByZWY6IFJlZjxUPiB8IG51bGwgfCB1bmRlZmluZWQpIHtcclxuICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZWYoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVmICE9IG51bGwpIHtcclxuICAgICAgICAocmVmIGFzIFJlZk9iamVjdDxUIHwgbnVsbD4pLmN1cnJlbnQgPSBpbnN0YW5jZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXHJcbiAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UsIFwiVW5rbm93biByZWYgdHlwZSBmb3VuZCB0aGF0IHdhcyBuZWl0aGVyIGEgUmVmQ2FsbGJhY2sgbm9yIGEgUmVmT2JqZWN0XCIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgUjxFPiB7XHJcbiAgICByZWY/OiBSZWY8RT47XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ29tYmluZXMgdHdvIHJlZnMgaW50byBvbmUuIFRoaXMgYWxsb3dzIGEgY29tcG9uZW50IHRvIGJvdGggdXNlIGl0cyBvd24gcmVmICphbmQqIGZvcndhcmQgYSByZWYgdGhhdCB3YXMgZ2l2ZW4gdG8gaXQuXHJcbiAqIEBwYXJhbSBsaHMgXHJcbiAqIEBwYXJhbSByaHMgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFJlZnM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PigpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiA8TGhzIGV4dGVuZHMgUjxFPiwgUmhzIGV4dGVuZHMgUjxFPj4obGhzUHJvcHM6IExocyB8IG51bGwgfCB1bmRlZmluZWQsIHJoc1Byb3BzOiBSaHMgfCBudWxsIHwgdW5kZWZpbmVkKTogUmVmPEU+IHtcclxuXHJcbiAgICAgICAgY29uc3QgbGhzID0gbGhzUHJvcHM/LnJlZjtcclxuICAgICAgICBjb25zdCByaHMgPSByaHNQcm9wcz8ucmVmO1xyXG4gICAgICAgIGNvbnN0IGNvbWJpbmVkOiBSZWZDYWxsYmFjazxFPiA9IHVzZUNhbGxiYWNrKChjdXJyZW50OiBFIHwgbnVsbCkgPT4ge1xyXG4gICAgICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIGxocyk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcclxuICAgICAgICB9LCBbbGhzLCByaHNdKTtcclxuXHJcblxyXG4gICAgICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkITtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJocyE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsaHMhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5cclxuZnVuY3Rpb24gc3R5bGVTdHJpbmdUb09iamVjdChzdHlsZTogc3RyaW5nKTogaC5KU1guQ1NTUHJvcGVydGllcyB7XHJcbiAgICAvLyBUT0RPOiBUaGlzIHN1Y2tzIEQ6XHJcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHN0eWxlLnNwbGl0KFwiO1wiKS5tYXAoc3RhdGVtZW50ID0+IHN0YXRlbWVudC5zcGxpdChcIjpcIikpKSBhcyB1bmtub3duIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXJnZXMgdHdvIHN0eWxlIG9iamVjdHMsIHJldHVybmluZyB0aGUgcmVzdWx0LlxyXG4gKiBcclxuICogQHBhcmFtIHN0eWxlIFRoZSB1c2VyLWdpdmVuIHN0eWxlIHByb3AgZm9yIHRoaXMgY29tcG9uZW50XHJcbiAqIEBwYXJhbSBvYmogVGhlIENTUyBwcm9wZXJ0aWVzIHlvdSB3YW50IGFkZGVkIHRvIHRoZSB1c2VyLWdpdmVuIHN0eWxlXHJcbiAqIEByZXR1cm5zIEEgQ1NTIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIGJvdGggb2JqZWN0cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRTdHlsZXM8TGhzIGV4dGVuZHMgUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBcInN0eWxlXCI+IHwgbnVsbCB8IHVuZGVmaW5lZCwgUmhzIGV4dGVuZHMgUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCBcInN0eWxlXCI+IHwgbnVsbCB8IHVuZGVmaW5lZD4obGhzOiBMaHMsIHJoczogUmhzKTogdW5kZWZpbmVkIHwgc3RyaW5nIHwgaC5KU1guQ1NTUHJvcGVydGllcyB7XHJcblxyXG4gICAgLy8gRWFzeSBjYXNlLCB3aGVuIHRoZXJlIGFyZSBubyBzdHlsZXMgdG8gbWVyZ2UgcmV0dXJuIG5vdGhpbmcuXHJcbiAgICBpZiAoIWxocz8uc3R5bGUgJiYgIXJocz8uc3R5bGUpXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XHJcbiAgICAgICAgLy8gRWFzeSBjYXNlcywgd2hlbiBvbmUgaXMgbnVsbCBhbmQgdGhlIG90aGVyIGlzbid0LlxyXG4gICAgICAgIGlmIChsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gbGhzLnN0eWxlO1xyXG4gICAgICAgIGlmICghbGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzLnN0eWxlO1xyXG5cclxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgdHlwZSB0byBhbiBvYmplY3QgYmFnIHR5cGUgYW5kIHJ1biBpdCBhZ2Fpbi5cclxuICAgICAgICBpZiAobGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKSB7XHJcbiAgICAgICAgICAgIC8vICh1c2VNZXJnZWRTdHlsZXMgaXNuJ3QgYSB0cnVlIGhvb2sgLS0gdGhpcyBpc24ndCBhIHZpb2xhdGlvbilcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKHsgc3R5bGU6IHN0eWxlU3RyaW5nVG9PYmplY3QobGhzPy5zdHlsZSBhcyBzdHJpbmcpIH0sIHJocykgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgeyBzdHlsZTogc3R5bGVTdHJpbmdUb09iamVjdChyaHM/LnN0eWxlIGFzIHN0cmluZykgfSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvZ2ljPz8/XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGV5J3JlIGJvdGggc3RyaW5ncywganVzdCBjb25jYXRlbmF0ZSB0aGVtLlxyXG4gICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gYCR7bGhzLnN0eWxlfTske3Jocz8uc3R5bGUgPz8gXCJcIn1gIGFzIHVua25vd24gYXMgc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZXkncmUgYm90aCBvYmplY3RzLCBqdXN0IG1lcmdlIHRoZW0uXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLihsaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgICAgIC4uLihyaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXHJcbiAgICB9IGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW5cIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2xhc3NlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2xhc3Nlc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1yZWZzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzXCI7XHJcblxyXG5sZXQgbG9nID0gY29uc29sZS53YXJuO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdQcm9wQ29uZmxpY3RzKGxvZzI6IHR5cGVvZiBjb25zb2xlW1wibG9nXCJdKSB7XHJcbiAgICBsb2cgPSBsb2cyXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHR5cGUgdGhhdCByZXByZXNlbnRzIHRoZSBtZXJnaW5nIG9mIHR3byBwcm9wIG9iamVjdHNcclxuICovXHJcbmV4cG9ydCB0eXBlIE1lcmdlZFByb3BzPEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+LCBVIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+ID0gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gJiBPbWl0PFQsIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+PiAmIE9taXQ8VSwga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+O1xyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlbSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gKiBcclxuICogVGhlIGhvb2sgaXMgYXdhcmUgb2YgYW5kIGNhbiBpbnRlbGxpZ2VudGx5IG1lcmdlIGBjbGFzc05hbWVgLCBgY2xhc3NgLCBgc3R5bGVgLCBgcmVmYCwgYW5kIGFsbCBldmVudCBoYW5kbGVycy5cclxuICogQHBhcmFtIGxoczIgXHJcbiAqIEBwYXJhbSByaHMyIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRQcm9wczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KCkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIDxUIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFUgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4obGhzQWxsOiBULCByaHNBbGw6IFUpOiBNZXJnZWRQcm9wczxFLCBULCBVPiB7XHJcblxyXG5cclxuICAgICAgICAvLyBGaXJzdCwgc2VwYXJhdGUgdGhlIHByb3BzIHdlIHdlcmUgZ2l2ZW4gaW50byB0d28gZ3JvdXBzOlxyXG4gICAgICAgIC8vIGxoc0FsbCBhbmQgcmhzQWxsIGNvbnRhaW4gYWxsIHRoZSBwcm9wcyB3ZSB3ZXJlIGdpdmVuLCBhbmRcclxuICAgICAgICAvLyBsaHNNaXNjIGFuZCByaHNNaXNjIGNvbnRhaW4gYWxsIHByb3BzICpleGNlcHQqIGZvciB0aGUgZWFzeSBvbmVzXHJcbiAgICAgICAgLy8gbGlrZSBjbGFzc05hbWUgYW5kIHN0eWxlIHRoYXQgd2UgYWxyZWFkeSBrbm93IGhvdyB0byBtZXJnZS5cclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBfbGhzQ2hpbGRyZW4sIGNsYXNzOiBfbGhzQ2xhc3MsIGNsYXNzTmFtZTogX2xoc0NsYXNzTmFtZSwgc3R5bGU6IF9saHNTdHlsZSwgcmVmOiBfbGhzUmVmLCAuLi5saHNNaXNjIH0gPSBsaHNBbGw7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogX3Joc0NoaWxkcmVuLCBjbGFzczogX3Joc0NsYXNzLCBjbGFzc05hbWU6IF9yaHNDbGFzc05hbWUsIHN0eWxlOiBfcmhzU3R5bGUsIHJlZjogX3Joc1JlZiwgLi4ucmhzTWlzYyB9ID0gcmhzQWxsO1xyXG5cclxuICAgICAgICBjb25zdCByZXQ6IE1lcmdlZFByb3BzPEUsIFQsIFU+ID0ge1xyXG4gICAgICAgICAgICAuLi5saHNNaXNjLFxyXG4gICAgICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4oKShsaHNBbGwsIHJoc0FsbCksXHJcbiAgICAgICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgICAgICBjbGFzc05hbWU6IHVzZU1lcmdlZENsYXNzZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogdXNlTWVyZ2VkQ2hpbGRyZW4obGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIH0gYXMgYW55O1xyXG5cclxuICAgICAgICBpZiAocmV0LnJlZiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnJlZjtcclxuICAgICAgICBpZiAocmV0LnN0eWxlID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuc3R5bGU7XHJcbiAgICAgICAgaWYgKHJldC5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jbGFzc05hbWU7XHJcbiAgICAgICAgaWYgKHJldC5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNoaWxkcmVuO1xyXG5cclxuICAgICAgICAvLyBOb3csIGRvICpldmVyeXRoaW5nKiBlbHNlXHJcbiAgICAgICAgLy8gTWVyZ2UgZXZlcnkgcmVtYWluaW5nIGV4aXN0aW5nIGVudHJ5IGluIGxocyB3aXRoIHdoYXQgd2UndmUgYWxyZWFkeSBwdXQgaW4gcmV0LlxyXG4gICAgICAgIC8vY29uc3QgbGhzRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGxocykgYXMgW2tleW9mIFQsIFRba2V5b2YgVF1dW107XHJcbiAgICAgICAgY29uc3QgcmhzRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHJoc01pc2MpIGFzIFtrZXlvZiBVLCBVW2tleW9mIFVdXVtdO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IFtyaHNLZXksIHJoc1ZhbHVlXSBvZiByaHNFbnRyaWVzKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsaHNWYWx1ZSA9IGxoc01pc2NbcmhzS2V5IGFzIGtleW9mIHR5cGVvZiBsaHNNaXNjXTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGhzVmFsdWUgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmhzVmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgbWVyZ2VkIChvciBvbmUncyBhIGZ1bmN0aW9uIGFuZCB0aGUgb3RoZXIncyBudWxsKS5cclxuICAgICAgICAgICAgICAgIC8vIE5vdCBhbiAqZWFzeSogY2FzZSwgYnV0IGEgd2VsbC1kZWZpbmVkIG9uZS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlRnVuY3Rpb25zKGxoc1ZhbHVlIGFzIG5ldmVyLCByaHNWYWx1ZSBhcyBuZXZlcik7XHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5IGFzIGtleW9mIE1lcmdlZFByb3BzPEUsIFQsIFU+XSA9IG1lcmdlZCBhcyBuZXZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XHJcbiAgICAgICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbCAmJiByaHNWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJoc1ZhbHVlID09PSBudWxsICYmIGxoc1ZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXkgYXMga2V5b2YgTWVyZ2VkUHJvcHM8RSwgVCwgVT5dID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbcmhzS2V5IGFzIGtleW9mIE1lcmdlZFByb3BzPEUsIFQsIFU+XSA9IGxoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGxoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleSBhcyBrZXlvZiBNZXJnZWRQcm9wczxFLCBULCBVPl0gPSByaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleSBhcyBrZXlvZiBNZXJnZWRQcm9wczxFLCBULCBVPl0gPSBsaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChyaHNWYWx1ZSBhcyBhbnkpID09IGxoc1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgcmVhbGx5IGlkZWFsIHRob3VnaC5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVnaC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgbG9nPy4oYFRoZSBwcm9wIFwiJHt0eXBlb2YgcmhzS2V5ID09IFwic3ltYm9sXCIgPyBcIjxzeW1ib2w+XCIgOiByaHNLZXkgYXMgc3RyaW5nfVwiIGNhbm5vdCBzaW11bHRhbmVvdXNseSBiZSB0aGUgdmFsdWVzICR7bGhzVmFsdWV9IGFuZCAke3Joc1ZhbHVlfS4gT25lIG11c3QgYmUgY2hvc2VuIG91dHNpZGUgb2YgdXNlTWVyZ2VkUHJvcHMuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleSBhcyBrZXlvZiBNZXJnZWRQcm9wczxFLCBULCBVPl0gPSByaHNWYWx1ZSBhcyBuZXZlclxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUZ1bmN0aW9uczxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4obGhzOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBVIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG5cclxuICAgIGlmICghbGhzKVxyXG4gICAgICAgIHJldHVybiByaHM7XHJcbiAgICBpZiAoIXJocylcclxuICAgICAgICByZXR1cm4gbGhzO1xyXG5cclxuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHJ2ID0gcmhzKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qXHJcbmZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG5cclxuICAgIGNvbnN0IGlkMDogR2VuZXJpY0dldDx7fSwgXCJpZFwiLCBzdHJpbmc+ID0gXCJcIjtcclxuICAgIGNvbnN0IGlkMzogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ0OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDU6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNjogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgLy9jb25zdCBpZDI6IFppcFNpbmdsZTxzdHJpbmcgfCB1bmRlZmluZWQsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDE6IFppcE9iamVjdDx7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0geyBpZDogdW5kZWZpbmVkIH07XHJcblxyXG4gICAgdHlwZSBNMSA9IEdlbmVyaWNHZXQ8UCwgXCJzdHlsZVwiLCBzdHJpbmc+O1xyXG4gICAgdHlwZSBNMiA9IEdlbmVyaWNHZXQ8e30sIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIGNvbnN0IG0xOiBNMSA9IFwiXCI7XHJcbiAgICBjb25zdCBtMjogTTEgPSB1bmRlZmluZWQ7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xyXG4gICAgY29uc3QgbTM6IE0xID0gMDtcclxuXHJcbiAgICBjb25zdCBtNDogTTIgPSBcIlwiO1xyXG4gICAgY29uc3QgbTU6IE0yID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG02OiBNMiA9IDA7XHJcblxyXG4gICAgY29uc3QgcDE6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDI6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDM6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNDogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHt9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHt9KTtcclxuICAgIGNvbnN0IHA1ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywge30pO1xyXG4gICAgY29uc3QgcDYgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNyA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IFwic3RyaW5nXCIgfSk7XHJcblxyXG5cclxuICAgIHAxLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwMi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcDMuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHA0LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHA1LmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDcuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNy5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDUuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA3LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBpdCB3b3JrcyByZWN1cnNpdmVseVxyXG4gICAgY29uc3QgcjFhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDEpO1xyXG4gICAgY29uc3QgcjFiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDEpO1xyXG4gICAgY29uc3QgcjJhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDIpO1xyXG4gICAgY29uc3QgcjJiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDIpO1xyXG4gICAgY29uc3QgcjNhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDMpO1xyXG4gICAgY29uc3QgcjNiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDMpO1xyXG4gICAgY29uc3QgcjRhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDQpO1xyXG4gICAgY29uc3QgcjRiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDQpO1xyXG4gICAgY29uc3QgcjVhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDUpO1xyXG4gICAgY29uc3QgcjViID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDUpO1xyXG4gICAgY29uc3QgcjZhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDYpO1xyXG4gICAgY29uc3QgcjZiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDYpO1xyXG4gICAgY29uc3QgcjdhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDcpO1xyXG4gICAgY29uc3QgcjdiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDcpO1xyXG5cclxuXHJcbiAgICByMWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIxYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcjNhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByM2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHI0YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjRiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHI1YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjViLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI2Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByN2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNWEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjViLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI2YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmIuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjdhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3Yi5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjVhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjViLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG59XHJcbmZ1bmN0aW9uIGFjY2VwdHNOZXZlcihuOiBuZXZlcikge31cclxuKi8iLCJpbXBvcnQgeyBoLCBSZWZDYWxsYmFjayB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IE1lcmdlZFByb3BzLCB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuXHJcbmV4cG9ydCB0eXBlIFVzZVJlZkVsZW1lbnRQcm9wc1JldHVyblR5cGU8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBQIGV4dGVuZHMge30+ID0gTWVyZ2VkUHJvcHM8VCwgUCwge30+O1xyXG5cclxuZXhwb3J0IHR5cGUgVXNlUmVmRWxlbWVudFByb3BzPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSA8UCBleHRlbmRzIHt9Pihwcm9wczogUCkgPT4gVXNlUmVmRWxlbWVudFByb3BzUmV0dXJuVHlwZTxULCBQPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFJldHVyblR5cGU8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XHJcbiAgICBnZXRFbGVtZW50OiAoKSA9PiBUIHwgbnVsbDtcclxuICAgIHVzZVJlZkVsZW1lbnRQcm9wczogVXNlUmVmRWxlbWVudFByb3BzPFQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcclxuICAgIG9uRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsPjtcclxuICAgIG9uTW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcclxuICAgIG9uVW5tb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xyXG59XHJcbmZ1bmN0aW9uIHJldHVybk51bGwoKSB7IHJldHVybiBudWxsOyB9XHJcbi8qKlxyXG4gKiBBbGxvd3MgYWNjZXNzaW5nIHRoZSBlbGVtZW50IGEgcmVmIHJlZmVyZW5jZXMgYXMgc29vbiBhcyBpdCBkb2VzIHNvLlxyXG4gKiAqVGhpcyBob29rIGl0c2VsZiByZXR1cm5zIGEgaG9vayotLXVzZVJlZkVsZW1lbnRQcm9wcyBtb2RpZmllcyB0aGUgcHJvcHMgdGhhdCB5b3Ugd2VyZSBnb2luZyB0byBwYXNzIHRvIGFuIEhUTUxFbGVtZW50LCBcclxuICogYWRkaW5nIGEgUmVmQ2FsbGJhY2sgYW5kIG1lcmdpbmcgaXQgd2l0aCBhbnkgZXhpc3RpbmcgcmVmIHRoYXQgZXhpc3RlZCBvbiB0aGUgcHJvcHMuXHJcbiAqIFxyXG4gKiBEb24ndCBmb3JnZXQgdG8gcHJvdmlkZSB0aGUgRWxlbWVudCBhcyB0aGUgdHlwZSBhcmd1bWVudCFcclxuICogXHJcbiAqIEByZXR1cm5zIFRoZSBlbGVtZW50LCBhbmQgdGhlIHN1Yi1ob29rIHRoYXQgbWFrZXMgaXQgcmV0cmlldmFibGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmRWxlbWVudDxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGFyZ3M/OiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcclxuICAgIGNvbnN0IHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfSA9IChhcmdzID8/IHt9KTtcclxuXHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VSZWZFbGVtZW50XCIsIG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50KTtcclxuXHJcbiAgICAvLyBDYWxsZWQgKGluZGlyZWN0bHkpIGJ5IHRoZSByZWYgdGhhdCB0aGUgZWxlbWVudCByZWNlaXZlcy5cclxuICAgIGNvbnN0IGhhbmRsZXIgPSB1c2VDYWxsYmFjazxPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbD4+KChlLCBwcmV2VmFsdWUpID0+IHtcclxuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U/LihlLCBwcmV2VmFsdWUpO1xyXG4gICAgICAgIGlmIChwcmV2VmFsdWUpXHJcbiAgICAgICAgICAgIG9uVW5tb3VudD8uKHByZXZWYWx1ZSEpO1xyXG5cclxuICAgICAgICBpZiAoZSlcclxuICAgICAgICAgICAgb25Nb3VudD8uKGUpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIC8vIExldCB1cyBzdG9yZSB0aGUgYWN0dWFsIChyZWZlcmVuY2UgdG8pIHRoZSBlbGVtZW50IHdlIGNhcHR1cmVcclxuICAgIGNvbnN0IFtnZXRFbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxUIHwgbnVsbD4oaGFuZGxlciwgcmV0dXJuTnVsbCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgUmVmQ2FsbGJhY2sgdGhhdCdzIGZpcmVkIHdoZW4gbW91bnRlZCBcclxuICAgIC8vIGFuZCB0aGF0IG5vdGlmaWVzIHVzIG9mIG91ciBlbGVtZW50IHdoZW4gd2UgaGF2ZSBpdFxyXG4gICAgY29uc3QgbXlSZWY6IFJlZkNhbGxiYWNrPFQ+ID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcclxuICAgICAgICBpZiAoZSlcclxuICAgICAgICAgICAgc2V0RWxlbWVudCgoKSA9PiBlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCB1c2VSZWZFbGVtZW50UHJvcHMgPSB1c2VDYWxsYmFjazxVc2VSZWZFbGVtZW50UHJvcHM8VD4+KDxQIGV4dGVuZHMge30+KHByb3BzOiBQKTogVXNlUmVmRWxlbWVudFByb3BzUmV0dXJuVHlwZTxULCBQPiA9PiB1c2VNZXJnZWRQcm9wczxUPigpKHsgcmVmOiBteVJlZiB9LCBwcm9wcyksIFtdKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcclxuICAgIC8vIHRoZSBwcm9wcyBhbmQgYWxsb3dzIHVzIHRvIGFjdHVhbGx5IGZpbmQgdGhlIGVsZW1lbnRcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlUmVmRWxlbWVudFByb3BzLFxyXG4gICAgICAgIGdldEVsZW1lbnRcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50U2l6ZSwgdXNlRWxlbWVudFNpemUgfSBmcm9tIFwiLi91c2UtZWxlbWVudC1zaXplXCI7XG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5cbi8vZXhwb3J0IHR5cGUgQmxvY2tGbG93RGlyZWN0aW9uID0gXCJkb3dud2FyZHNcIiB8IFwibGVmdHdhcmRzXCIgfCBcInJpZ2h0d2FyZHNcIjtcbmV4cG9ydCB0eXBlIFBoeXNpY2FsRGlyZWN0aW9uID0gXCJsdHJcIiB8IFwicnRsXCIgfCBcInR0YlwiIHwgXCJidHRcIjtcbmV4cG9ydCB0eXBlIFBoeXNpY2FsT3JpZW50YXRpb24gPSBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIjtcbmV4cG9ydCB0eXBlIFBoeXNpY2FsU2l6ZSA9IFwid2lkdGhcIiB8IFwiaGVpZ2h0XCI7XG5cbmV4cG9ydCB0eXBlIExvZ2ljYWxPcmllbnRhdGlvbiA9IFwiaW5saW5lXCIgfCBcImJsb2NrXCI7XG5cbi8vZXhwb3J0IHR5cGUgTGluZU9yaWVudGF0aW9uID0gXCJ1cHJpZ2h0XCIgfCBcImxlZnRyaWdodFwiIHwgXCJkb3ducmlnaHRcIiB8IFwicmlnaHRyaWdodFwiO1xuXG50eXBlIFdyaXRpbmdNb2RlID0gXCJob3Jpem9udGFsLXRiXCIgfCBcInZlcnRpY2FsLWxyXCIgfCBcInNpZGV3YXlzLXJsXCIgfCBcInZlcnRpY2FsLXJsXCIgfCBcInNpZGV3YXlzLWxyXCI7XG50eXBlIERpcmVjdGlvbiA9IFwibHRyXCIgfCBcInJ0bFwiO1xudHlwZSBUZXh0T3JpZW50YXRpb24gPSBcIm1peGVkXCIgfCBcInVwcmlnaHRcIiB8IFwic2lkZXdheXNcIjtcblxuZnVuY3Rpb24gY2FwaXRhbGl6ZTxUIGV4dGVuZHMgc3RyaW5nPihzdHI6IFQpOiBDYXBpdGFsaXplPFQ+IHtcbiAgICByZXR1cm4gKHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cigxKSkgYXMgQ2FwaXRhbGl6ZTxUPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMb2dpY2FsRGlyZWN0aW9uUGFyYW1ldGVycyB7XG4gICAgb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlPyhpbmZvOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2ljYWxFbGVtZW50U2l6ZSB7XG4gICAgY2xpZW50SW5saW5lU2l6ZTogbnVtYmVyO1xuICAgIHNjcm9sbElubGluZVNpemU6IG51bWJlcjtcbiAgICBvZmZzZXRJbmxpbmVTaXplOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50QmxvY2tTaXplOiBudW1iZXI7XG4gICAgc2Nyb2xsQmxvY2tTaXplOiBudW1iZXI7XG4gICAgb2Zmc2V0QmxvY2tTaXplOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50SW5saW5lSW5zZXQ6IG51bWJlcjtcbiAgICBzY3JvbGxJbmxpbmVJbnNldDogbnVtYmVyO1xuICAgIG9mZnNldElubGluZUluc2V0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50QmxvY2tJbnNldDogbnVtYmVyO1xuICAgIHNjcm9sbEJsb2NrSW5zZXQ6IG51bWJlcjtcbiAgICBvZmZzZXRCbG9ja0luc2V0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSW5zcGVjdHMgdGhlIGVsZW1lbnQncyBzdHlsZSBhbmQgZGV0ZXJtaW5lcyB0aGUgbG9naWNhbCBkaXJlY3Rpb24gdGhhdCB0ZXh0IGZsb3dzLlxuICogXG4gKiBDZXJ0YWluIENTUyBwcm9wZXJ0aWVzLCBsaWtlIGBibG9jay1zaXplYCwgcmVzcGVjdCB0aGUgY3VycmVudCB3cml0aW5nIG1vZGUgYW5kIHRleHQgZGlyZWN0aW9uLlxuICogQnV0IGB0cmFuc2Zvcm1gLCBgY2xpcGAsIGV0Yy4gZG9uJ3QuXG4gKiBcbiAqIFRoaXMgaXMgcHJvdmlkZWQgc28gdGhhdCBDU1MgcHJvcGVydGllcyBjYW4gY29uc2lzdGVudGx5IHVzZSB0aG9zZSBsb2dpY2FsIHByb3BlcnRpZXMuXG4gKiBcbiAqIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXdyaXRpbmctbW9kZXMvI2xvZ2ljYWwtdG8tcGh5c2ljYWxcbiAqIFxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnM6XG4gKiAqIGBnZXRMb2dpY2FsRGlyZWN0aW9uYDogcmV0cmlldmVzIGEgYExvZ2ljYWxEaXJlY3Rpb25JbmZvYCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuIChGdW5jdGlvbiBpcyBjb25zdGFudCBiZXR3ZWVuIHJlbmRlcnMpXG4gKiAqIGBjb252ZXJ0RWxlbWVudFNpemVgOiBXaGVuIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgdXNlRWxlbWVudFNpemVgLCBhbGxvd3MgeW91IHRvIHJldHJpZXZlIHRoZSBsb2dpY2FsIHNpemUgb2YgYW4gZWxlbWVudCBpbnN0ZWFkIG9mIHRoZSBwaHlzaWNhbCBzaXplLiBcbiAqICogYGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbmA6IEJhc2VkIG9uIHRoZSBjdXJyZW50IGRpcmVjdGlvbiwgY29udmVydHMgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiIHRvIFwiaW5saW5lXCIgb3IgXCJibG9ja1wiLlxuICogKiBgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbmA6ICBCYXNlZCBvbiB0aGUgY3VycmVudCBkaXJlY3Rpb24sIGNvbnZlcnRzIFwiaW5saW5lXCIgb3IgXCJibG9ja1wiIHRvIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvZ2ljYWxEaXJlY3Rpb248VCBleHRlbmRzIEVsZW1lbnQ+KHsgb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlIH06IFVzZUxvZ2ljYWxEaXJlY3Rpb25QYXJhbWV0ZXJzKTogVXNlTG9naWNhbERpcmVjdGlvblJldHVyblR5cGU8VD4ge1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTG9naWNhbERpcmVjdGlvblwiLCBvbkxvZ2ljYWxEaXJlY3Rpb25DaGFuZ2UpO1xuXG4gICAgY29uc3QgW2dldENvbXB1dGVkU3R5bGVzLCBzZXRDb21wdXRlZFN0eWxlc10gPSB1c2VQYXNzaXZlU3RhdGU8Q1NTU3R5bGVEZWNsYXJhdGlvbiB8IG51bGw+KG51bGwsIHJldHVybk51bGwpO1xuXG5cbiAgICBjb25zdCB7IGdldEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxUPih7XG4gICAgICAgIG9uRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKGVsZW1lbnQ6IFQgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHNldENvbXB1dGVkU3R5bGVzKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pXG4gICAgfSk7XG5cbiAgICAvLyBUT0RPOiBUaGVyZSdzIG5vIHdheSB0byByZWZyZXNoIHdoaWNoIHdyaXRpbmcgbW9kZSB3ZSBoYXZlIG9uY2UgbW91bnRlZC5cbiAgICAvLyAgIEEuIFRoZXJlJ3Mgbm8gd2F5IHRvIHdhdGNoIGZvciBDU1Mgc3R5bGUgY2hhbmdlc1xuICAgIC8vICAgQi4gQ2FsbGluZyBnZXRDb21wdXRlZFN0eWxlIGFmdGVyIGV2ZXJ5IHJlbmRlciBmb3IgZXZlcnkgZWxlbWVudCBnZXRzIGV4cGVuc2l2ZSBmYXN0IGFuZFxuICAgIC8vICAgQy4gSXMgbm90IG5lY2Vzc2FyeSBmb3IgbW9zdCB1c2UgY2FzZXMgdGhhdCB3aWxsIG5ldmVyIHN3aXRjaCB3cml0aW5nLW1vZGUgd2l0aGluIGEgc2luZ2xlIGNvbXBvbmVudFxuICAgIC8vICAgICAgKFRob3NlIHRoYXQgZG8gd2lsbCBuZWVkIHRvIG1vdW50IGFuZCB1bm1vdW50IHRoZSBjb21wb25lbnQgdGhhdCB1c2VzIGl0KVxuICAgIC8vXG4gICAgLy8gQXMgYSBzb2x1dGlvbiwgaGVyZSdzIGEgY2hlYXAgd29ya2Fyb3VuZCB0aGF0IGNoZWNrcyB3aGVuIHRoZSBlbGVtZW50J3Mgc2l6ZSBoYXMgY2hhbmdlZCxcbiAgICAvLyBhbmQgaWYgc28sIHRlc3RzIGlmIHRoZSB3cml0aW5nIG1vZGUgaGFzIGNoYW5nZWQgdG9vLlxuICAgIC8vXG4gICAgLy8gVGhpcyB3aWxsIHdvcmsgZm9yIGF0IGxlYXN0IHNvbWUgbnVtYmVyIG9mIGNhc2VzLCBidXQgYSBiZXR0ZXIgc29sdXRpb24gaXMgc3RpbGwgbmVlZGVkLlxuICAgIGNvbnN0IHsgdXNlRWxlbWVudFNpemVQcm9wcyB9ID0gdXNlRWxlbWVudFNpemUoeyBvblNpemVDaGFuZ2U6IHVzZUNhbGxiYWNrKF8gPT4gb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlPy4oZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKSksIFtdKSB9KVxuXG4gICAgY29uc3QgZ2V0TG9naWNhbERpcmVjdGlvbkluZm8gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZXMoKTtcbiAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGVzKSB7XG4gICAgICAgICAgICBjb25zdCB3ID0gY29tcHV0ZWRTdHlsZXMud3JpdGluZ01vZGUgYXMgV3JpdGluZ01vZGU7XG4gICAgICAgICAgICBsZXQgZCA9IGNvbXB1dGVkU3R5bGVzLmRpcmVjdGlvbiBhcyBEaXJlY3Rpb247XG4gICAgICAgICAgICBjb25zdCB0ID0gY29tcHV0ZWRTdHlsZXMudGV4dE9yaWVudGF0aW9uIGFzIFRleHRPcmllbnRhdGlvbjtcblxuICAgICAgICAgICAgaWYgKHQgPT0gXCJ1cHJpZ2h0XCIpXG4gICAgICAgICAgICAgICAgZCA9IFwibHRyXCI7XG5cbiAgICAgICAgICAgIHJldHVybiAoeyAuLi5Xcml0aW5nTW9kZXNbdyB8fCBcImhvcml6b250YWwtdGJcIl1bZCB8fCBcImx0clwiXSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sIFtdKVxuXG4gICAgLy9jb25zdCBbZ2V0TG9naWNhbERpcmVjdGlvbkluZm8sIHNldExvZ2ljYWxEaXJlY3Rpb25JbmZvXSA9IHVzZVBhc3NpdmVTdGF0ZTxMb2dpY2FsRGlyZWN0aW9uSW5mbz4ob25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlKTtcblxuICAgIGNvbnN0IGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbiA9IHVzZUNhbGxiYWNrKChlbGVtZW50T3JpZW50YXRpb246IFBoeXNpY2FsT3JpZW50YXRpb24sIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XG4gICAgICAgIGlmIChkaXJlY3Rpb24/LmlubGluZU9yaWVudGF0aW9uID09PSBlbGVtZW50T3JpZW50YXRpb24pXG4gICAgICAgICAgICByZXR1cm4gXCJpbmxpbmVcIjtcbiAgICAgICAgcmV0dXJuIFwiYmxvY2tcIjtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb252ZXJ0VG9QaHlzaWNhbFNpZGUgPSB1c2VDYWxsYmFjaygoc2lkZTogXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiIHwgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKTogXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiA9PiB7XG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcblxuICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1zdGFydFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBNWyhkaXJlY3Rpb24/LmJsb2NrRGlyZWN0aW9uID8/IFwidHRiXCIpWzBdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1lbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5ibG9ja0RpcmVjdGlvbiA/PyBcInR0YlwiKVsyXSBhcyBcInRcIiB8IFwiYlwiIHwgXCJsXCIgfCBcInJcIl07XG5cbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtc3RhcnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5pbmxpbmVEaXJlY3Rpb24gPz8gXCJsdHJcIilbMF0gYXMgXCJ0XCIgfCBcImJcIiB8IFwibFwiIHwgXCJyXCJdO1xuICAgICAgICAgICAgY2FzZSBcImlubGluZS1lbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5pbmxpbmVEaXJlY3Rpb24gPz8gXCJsdHJcIilbMl0gYXMgXCJ0XCIgfCBcImJcIiB8IFwibFwiIHwgXCJyXCJdO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBjb252ZXJ0VG9Mb2dpY2FsU2lkZSA9IHVzZUNhbGxiYWNrKChzaWRlOiBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpOiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiID0+IHtcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uaW5saW5lRGlyZWN0aW9uID09PSBcInR0YlwiID8gXCJpbmxpbmUtc3RhcnRcIiA6IFwiaW5saW5lLWVuZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5pbmxpbmVEaXJlY3Rpb24gPT09IFwiYnR0XCIgPyBcImlubGluZS1zdGFydFwiIDogXCJpbmxpbmUtZW5kXCI7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmJsb2NrRGlyZWN0aW9uID09PSBcImx0clwiID8gXCJibG9jay1zdGFydFwiIDogXCJibG9jay1lbmRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJydGxcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2lkZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJ0dGJcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmJsb2NrRGlyZWN0aW9uID09PSBcImJ0dFwiID8gXCJibG9jay1zdGFydFwiIDogXCJibG9jay1lbmRcIjtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uaW5saW5lRGlyZWN0aW9uID09PSBcImx0clwiID8gXCJpbmxpbmUtc3RhcnRcIiA6IFwiaW5saW5lLWVuZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJydGxcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICBjb25zb2xlLmFzc2VydChmYWxzZSk7XG4gICAgICAgIHJldHVybiBcImlubGluZS1zdGFydFwiO1xuXG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uID0gdXNlQ2FsbGJhY2soKGVsZW1lbnRPcmllbnRhdGlvbjogTG9naWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICBpZiAoZWxlbWVudE9yaWVudGF0aW9uID09IFwiaW5saW5lXCIpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24/LmlubGluZU9yaWVudGF0aW9uID09IFwiaG9yaXpvbnRhbFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImhvcml6b250YWxcIjtcbiAgICAgICAgICAgIHJldHVybiBcInZlcnRpY2FsXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uPy5ibG9ja09yaWVudGF0aW9uID09IFwidmVydGljYWxcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xuXG4gICAgICAgICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBjb252ZXJ0RWxlbWVudFNpemUgPSB1c2VDYWxsYmFjaygoZWxlbWVudFNpemU6IEVsZW1lbnRTaXplLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpOiBMb2dpY2FsRWxlbWVudFNpemUgfCBudWxsID0+IHtcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlubGluZVNpemUsIGJsb2NrU2l6ZSwgaW5saW5lRGlyZWN0aW9uLCBibG9ja0RpcmVjdGlvbiB9ID0gZGlyZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBTaXplIGlzIHJlbGF0aXZlbHkgc2ltcGxlXG4gICAgICAgICAgICBjb25zdCBjbGllbnRJbmxpbmVTaXplID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShpbmxpbmVTaXplKX1gXTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudEJsb2NrU2l6ZSA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoYmxvY2tTaXplKX1gXTtcblxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0SW5saW5lU2l6ZSA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoaW5saW5lU2l6ZSl9YF07XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRCbG9ja1NpemUgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGJsb2NrU2l6ZSl9YF07XG5cbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbElubGluZVNpemUgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGlubGluZVNpemUpfWBdO1xuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQmxvY2tTaXplID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShibG9ja1NpemUpfWBdO1xuXG5cblxuXG4gICAgICAgICAgICBjb25zdCBmMSA9IGdldFBoeXNpY2FsTGVmdFRvcChpbmxpbmVEaXJlY3Rpb24pO1xuICAgICAgICAgICAgY29uc3QgZjIgPSBnZXRQaHlzaWNhbFJpZ2h0Qm90dG9tKGlubGluZURpcmVjdGlvbik7XG5cbiAgICAgICAgICAgIGNvbnN0IGYzID0gZ2V0UGh5c2ljYWxMZWZ0VG9wKGJsb2NrRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGY0ID0gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShibG9ja0RpcmVjdGlvbik7XG5cblxuICAgICAgICAgICBjb25zdCBjbGllbnRJbmxpbmVJbnNldCA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjEpfWBdICsgKCFmMiA/IDAgOiBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGYyKX1gXSk7XG4gICAgICAgICAgIGNvbnN0IHNjcm9sbElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMSl9YF0gKyAoIWYyID8gMCA6IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjIpfWBdKTtcbiAgICAgICAgICAgY29uc3Qgb2Zmc2V0SW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYxKX1gXSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAoZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMSl9YF0hICsgKCFmMiA/IDAgOiBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYyKX1gXSEpKTtcblxuXG4gICAgICAgICAgICBjb25zdCBjbGllbnRCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmMyl9YF0gKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjQpfWBdKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEJsb2NrSW5zZXQgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGYzKX1gXSArICghZjQgPyAwIDogZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmNCl9YF0pO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0QmxvY2tJbnNldCA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjMpfWBdID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IChlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYzKX1gXSEgKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjQpfWBdISkpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2xpZW50SW5saW5lU2l6ZSxcbiAgICAgICAgICAgICAgICBzY3JvbGxJbmxpbmVTaXplLFxuICAgICAgICAgICAgICAgIG9mZnNldElubGluZVNpemUsXG4gICAgICAgICAgICAgICAgY2xpZW50QmxvY2tTaXplLFxuICAgICAgICAgICAgICAgIHNjcm9sbEJsb2NrU2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRCbG9ja1NpemUsXG4gICAgICAgICAgICAgICAgY2xpZW50SW5saW5lSW5zZXQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW5saW5lSW5zZXQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0SW5saW5lSW5zZXQsXG4gICAgICAgICAgICAgICAgY2xpZW50QmxvY2tJbnNldCxcbiAgICAgICAgICAgICAgICBzY3JvbGxCbG9ja0luc2V0LFxuICAgICAgICAgICAgICAgIG9mZnNldEJsb2NrSW5zZXQsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wczogdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4gdXNlUmVmRWxlbWVudFByb3BzKHVzZUVsZW1lbnRTaXplUHJvcHMocHJvcHMpKSwgW10pLFxuICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbyxcbiAgICAgICAgY29udmVydFRvTG9naWNhbFNpemU6IGNvbnZlcnRFbGVtZW50U2l6ZSxcbiAgICAgICAgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uLFxuICAgICAgICBjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uLFxuICAgICAgICBjb252ZXJ0VG9Mb2dpY2FsU2lkZSxcbiAgICAgICAgY29udmVydFRvUGh5c2ljYWxTaWRlXG4gICAgfTtcbn1cblxuLy8gUG9zaXRpb24gcmVxdWlyZXMgdXMgdG8gc29tZXRpbWVzIHVzZSBvbmUgcHJvcGVydHkgKGxpa2UgYGxlZnRgKVxuLy8gb3Igc29tZXRpbWVzIHR3byAobGlrZSBgbGVmdGAgKyBgd2lkdGhgKVxuZnVuY3Rpb24gZ2V0UGh5c2ljYWxMZWZ0VG9wKGRpcjogUGh5c2ljYWxEaXJlY3Rpb24pIHsgaWYgKGRpciA9PT0gXCJsdHJcIiB8fCBkaXIgPT0gXCJydGxcIikgcmV0dXJuIFwibGVmdFwiOyByZXR1cm4gXCJ0b3BcIjsgfVxuZnVuY3Rpb24gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShkaXI6IFBoeXNpY2FsRGlyZWN0aW9uKSB7IGlmIChkaXIgPT09IFwicnRsXCIpIHJldHVybiBcIndpZHRoXCI7IGlmIChkaXIgPT09IFwiYnR0XCIpIHJldHVybiBcImhlaWdodFwiOyByZXR1cm4gbnVsbDsgfVxuXG4vLyBIZWxwZXIgZm9yIGV4dHJhY3RpbmcgaW5mbyBmcm9tIFwibHRyXCIsIFwidHRiXCIsIGV0Yy5cbmNvbnN0IE0gPSB7XG4gICAgdDogXCJ0b3BcIixcbiAgICBiOiBcImJvdHRvbVwiLFxuICAgIGw6IFwibGVmdFwiLFxuICAgIHI6IFwicmlnaHRcIlxufSBhcyBjb25zdDtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxvZ2ljYWxEaXJlY3Rpb25SZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XG4gICAgZ2V0RWxlbWVudDogKCkgPT4gVCB8IG51bGw7XG4gICAgZ2V0TG9naWNhbERpcmVjdGlvbkluZm86ICgpID0+IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoZSBFbGVtZW50U2l6ZSBpbmZvIGZyb20gdXNlRWxlbWVudFNpemUsIGNvbnZlcnRzIGFsbCB0aG9zZSBwaHlzaWNhbCBwcm9wZXJ0aWVzIHRvIHRoZWlyIGxvZ2ljYWwgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGNvbnZlcnRUb0xvZ2ljYWxTaXplOiAoZWxlbWVudFNpemU6IEVsZW1lbnRTaXplLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IExvZ2ljYWxFbGVtZW50U2l6ZSB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBgXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCJgIGludG8gYFwiaW5saW5lXCIgfCBcImJsb2NrXCJgXG4gICAgICovXG4gICAgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uOiAoZWxlbWVudE9yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaW5saW5lXCIgfCBcImJsb2NrXCI7XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBgXCJpbmxpbmVcIiB8IFwiYmxvY2tcImAgaW50byBgXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCJgXG4gICAgICovXG4gICAgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbjogKGVsZW1lbnRPcmllbnRhdGlvbjogTG9naWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiO1xuXG4gICAgLyoqXG4gICAgICogVHVybnMgYFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCJgIGludG8gYFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIgfCBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCJgXG4gICAgICovXG4gICAgY29udmVydFRvTG9naWNhbFNpZGU6IChzaWRlOiBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcIiB8IFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCI7XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIiB8IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcImAgaW50byBgXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcImBcbiAgICAgKi9cbiAgICBjb252ZXJ0VG9QaHlzaWNhbFNpZGU6IChzaWRlOiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCI7XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2ljYWxEaXJlY3Rpb25JbmZvIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBkaXJlY3Rpb24gdGV4dCBmbG93cywgZ2x5cGggYnkgZ2x5cGguICBCeSBmYXIgdGhlIG1vc3QgY29tcGxleCBwcm9wZXJ0eS5cbiAgICAgKiBcbiAgICAgKiB8YHdyaXRpbmctbW9kZWB8YGRpcmVjdGlvbmB8UmVzdWx0fFxuICAgICAqIHwtLS0tLXwtLS0tLXwtLS0tLXxcbiAgICAgKiB8YGhvcml6b250YWwtdGJgfGBsdHJgfGBsdHJgfFxuICAgICAqIHxgaG9yaXpvbnRhbC10YmB8YHJ0bGB8YHJ0bGB8XG4gICAgICogfGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgfGBsdHJgfGB0dGJgfFxuICAgICAqIHxgdmVydGljYWwtcmxgICYgYHNpZGV3YXlzLXJsYHxgcnRsYHxgYnR0YHxcbiAgICAgKiB8YHZlcnRpY2FsLWxyYHxgbHRyYHxgdHRiYHxcbiAgICAgKiB8YHZlcnRpY2FsLWxyYHxgcnRsYHxgYnR0YHxcbiAgICAgKiB8YHNpZGV3YXlzLWxyYHxgbHRyYHxgYnR0YHxcbiAgICAgKiB8YHNpZGV3YXlzLWxyYHxgcnRsYHxgdHRiYHxcbiAgICAgKi9cbiAgICBpbmxpbmVEaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU2ltcGxpZmllZCB2ZXJzaW9uIG9mIGBpbmxpbmVEaXJlY3Rpb25gOlxuICAgICAqIFxuICAgICAqICogYGhvcml6b250YWxgIGZvciBgaG9yaXpvbnRhbC10YmBcbiAgICAgKiAqIGB2ZXJ0aWNhbGAgZm9yIGFsbCBvdGhlcnNcbiAgICAgKi9cbiAgICBpbmxpbmVPcmllbnRhdGlvbjogUGh5c2ljYWxPcmllbnRhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGRpcmVjdGlvbiB0ZXh0IGZsb3dzLCBsaW5lIGJ5IGxpbmUuXG4gICAgICogXG4gICAgICogKiBgdHRiYCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYHJ0bGAgZm9yIGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYGx0cmAgZm9yIGB2ZXJ0aWNhbC1scmAgJiBgc2lkZXdheXMtbHJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqL1xuICAgIGJsb2NrRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFNpbXBsaWZpZWQgdmVyc2lvbiBvZiBgYmxvY2tEaXJlY3Rpb25gOlxuICAgICAqIFxuICAgICAqICogYHZlcnRpY2FsYCBmb3IgYGhvcml6b250YWwtdGJgXG4gICAgICogKiBgaG9yaXpvbnRhbGAgZm9yIGFsbCBvdGhlcnNcbiAgICAgKi9cbiAgICBibG9ja09yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBob3cgeW91IGNhbiAqcGh5c2ljYWxseSogcmVmZXIgdG8gdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgaW4gdGhlICppbmxpbmUqIHNpemUuXG4gICAgICogXG4gICAgICogKiBgd2lkdGhgIGZvciBgaG9yaXpvbnRhbC10YmAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXG4gICAgICogKiBgaGVpZ2h0YCBmb3IgYWxsIG90aGVyc1xuICAgICAqL1xuICAgIGlubGluZVNpemU6IFBoeXNpY2FsU2l6ZTtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgaG93IHlvdSBjYW4gKnBoeXNpY2FsbHkqIHJlZmVyIHRvIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IGluIHRoZSAqYmxvY2sqIHNpemUuXG4gICAgICogXG4gICAgICogKiBgaGVpZ2h0YCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYHdpZHRoYCBmb3IgYWxsIG90aGVyc1xuICAgICAqL1xuICAgIGJsb2NrU2l6ZTogUGh5c2ljYWxTaXplO1xuXG4gICAgLyoqXG4gICAgICogRm9yIGVhY2ggZ2x5cGgsIGFzY2VuZGVycyB0byBkZXNjZW5kZXJzICpwaHlzaWNhbGx5KiBnbzpcbiAgICAgKiBcbiAgICAgKiAqIGB0dGJgIGZvciBgaG9yaXpvbnRhbC10YmBcbiAgICAgKiAqIGBydGxgIGZvciBgdmVydGljYWwtcmxgLCBgdmVydGljYWwtbHJgLCAmIGBzaWRld2F5cy1ybGBcbiAgICAgKiAqIGBsdHJgIGZvciBgc2lkZXdheXMtbHJgXG4gICAgICovXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEZvciBlYWNoIGdseXBoLCBpdHMgXCJsZWZ0XCIgc2lkZSAodGhpbmsgb2YgdGhpcyByZWxhdGl2ZSB0byBgd3JpdGluZy1tb2RlYCBidXQgKm5vdCogcmVsYXRpdmUgdG8gYGRpcmVjdGlvbmAsIG9yIGFsdGVybmF0aXZlbHkgd2hhdCBgdGV4dC1hbGlnbjogbGVmdGAgbWVhbnMpIHRvIGl0cyBcInJpZ2h0XCIgc2lkZSAqcGh5c2ljYWxseSogZ29lcyBmcm9tOlxuICAgICAqIFxuICAgICAqICogYGx0cmAgZm9yIGBob3Jpem9udGFsLXRiYFxuICAgICAqICogYHR0YmAgZm9yIGB2ZXJ0aWNhbC1ybGAsIGB2ZXJ0aWNhbC1scmAsICYgYHNpZGV3YXlzLXJsYFxuICAgICAqICogYGJ0dGAgZm9yIGBzaWRld2F5cy1scmBcbiAgICAgKi9cbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xufVxuXG5jb25zdCBIb3Jpem9udGFsVGJMdHI6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIGlubGluZURpcmVjdGlvbjogXCJsdHJcIixcbiAgICBibG9ja0RpcmVjdGlvbjogXCJ0dGJcIixcblxuICAgIGlubGluZU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICBibG9ja09yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXG5cbiAgICBpbmxpbmVTaXplOiBcIndpZHRoXCIsXG4gICAgYmxvY2tTaXplOiBcImhlaWdodFwiLFxuXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcImx0clwiLFxuICAgIG92ZXJVbmRlckRpcmVjdGlvbjogXCJ0dGJcIlxufTtcblxuY29uc3QgSG9yaXpvbnRhbFRiUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5Ib3Jpem9udGFsVGJMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInJ0bFwiLFxufTtcblxuY29uc3QgVmVydGljYWxSbEx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiLFxuICAgIGJsb2NrRGlyZWN0aW9uOiBcInJ0bFwiLFxuXG4gICAgaW5saW5lT3JpZW50YXRpb246IFwidmVydGljYWxcIixcbiAgICBibG9ja09yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcblxuICAgIGlubGluZVNpemU6IFwiaGVpZ2h0XCIsXG4gICAgYmxvY2tTaXplOiBcIndpZHRoXCIsXG5cbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwidHRiXCIsXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcInJ0bFwiXG59O1xuXG5jb25zdCBWZXJ0aWNhbFJsUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5WZXJ0aWNhbFJsTHRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIlxufTtcblxuXG5jb25zdCBTaWRld2F5c1JsTHRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHsgLi4uVmVydGljYWxSbEx0ciB9O1xuY29uc3QgU2lkZXdheXNSbFJ0bDogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7IC4uLlZlcnRpY2FsUmxSdGwgfTtcblxuY29uc3QgVmVydGljYWxMckx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgLi4uVmVydGljYWxSbEx0cixcbiAgICBibG9ja0RpcmVjdGlvbjogXCJsdHJcIixcbn07XG5cbmNvbnN0IFZlcnRpY2FsTHJSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLlZlcnRpY2FsUmxSdGwsXG4gICAgYmxvY2tEaXJlY3Rpb246IFwibHRyXCIsXG59O1xuXG5jb25zdCBTaWRld2F5c0x0THRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5WZXJ0aWNhbExyTHRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIixcblxuICAgIGxlZnRSaWdodERpcmVjdGlvbjogXCJidHRcIixcbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFwibHRyXCJcbn07XG5cbmNvbnN0IFNpZGV3YXlzTHRSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLlNpZGV3YXlzTHRMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiXG59O1xuXG5cblxuY29uc3QgSG9yaXpvbnRhbFRiID0ge1xuICAgIGx0cjogSG9yaXpvbnRhbFRiTHRyLFxuICAgIHJ0bDogSG9yaXpvbnRhbFRiUnRsXG59IGFzIGNvbnN0O1xuXG5jb25zdCBWZXJ0aWNhbFJsID0ge1xuICAgIGx0cjogVmVydGljYWxSbEx0cixcbiAgICBydGw6IFZlcnRpY2FsUmxSdGxcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IFZlcnRpY2FsTHIgPSB7XG4gICAgbHRyOiBWZXJ0aWNhbExyTHRyLFxuICAgIHJ0bDogVmVydGljYWxMclJ0bFxufSBhcyBjb25zdDtcblxuY29uc3QgU2lkZXdheXNSbCA9IHtcbiAgICBsdHI6IFNpZGV3YXlzUmxMdHIsXG4gICAgcnRsOiBTaWRld2F5c1JsUnRsXG59IGFzIGNvbnN0O1xuXG5jb25zdCBTaWRld2F5c0xyID0ge1xuICAgIGx0cjogU2lkZXdheXNMdEx0cixcbiAgICBydGw6IFNpZGV3YXlzTHRSdGxcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IFdyaXRpbmdNb2RlcyA9IHtcbiAgICBcImhvcml6b250YWwtdGJcIjogSG9yaXpvbnRhbFRiLFxuICAgIFwidmVydGljYWwtbHJcIjogVmVydGljYWxMcixcbiAgICBcInZlcnRpY2FsLXJsXCI6IFZlcnRpY2FsUmwsXG4gICAgXCJzaWRld2F5cy1sclwiOiBTaWRld2F5c0xyLFxuICAgIFwic2lkZXdheXMtcmxcIjogU2lkZXdheXNSbFxufSBhcyBjb25zdDtcbiIsIlxuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZVAgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbi8qKlxuICogU2xpZ2h0bHkgZW5oYW5jZWQgdmVyc2lvbiBvZiBgdXNlU3RhdGVgIHRoYXQgaW5jbHVkZXMgYSBnZXR0ZXIgdGhhdCByZW1haW5zIGNvbnN0YW50XG4gKiAoaS5lLiB5b3UgY2FuIHVzZSBpdCBpbiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcyB3aXRob3V0IGl0IGJlaW5nIGEgZGVwZW5kZW5jeSkuXG4gKiBcbiAqIEBwYXJhbSBpbml0aWFsU3RhdGUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlPFQ+KGluaXRpYWxTdGF0ZTogVCB8ICgoKSA9PiBUKSk6IHJlYWRvbmx5IFt2YWx1ZTogVCwgc2V0VmFsdWU6IFN0YXRlVXBkYXRlcjxUPiwgZ2V0VmFsdWU6ICgpID0+IFRdIHtcblxuICAgIC8vIFdlIGtlZXAgYm90aCwgYnV0IG92ZXJycmlkZSB0aGUgYHNldFN0YXRlYCBmdW5jdGlvbmFsaXR5XG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZVBdID0gdXNlU3RhdGVQKGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKHN0YXRlKTtcblxuICAgIC8vIEhpamFjayB0aGUgbm9ybWFsIHNldHRlciBmdW5jdGlvbiBcbiAgICAvLyB0byBhbHNvIHNldCBvdXIgcmVmIHRvIHRoZSBuZXcgdmFsdWVcbiAgICBjb25zdCBzZXRTdGF0ZSA9IHVzZUNhbGxiYWNrPFN0YXRlVXBkYXRlcjxUPj4odmFsdWUgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdmFsdWUgYXMgKChfcHJldlZhbHVlOiBUKSA9PiBUKTtcbiAgICAgICAgICAgIHNldFN0YXRlUChwcmV2VmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IGNhbGxiYWNrKHByZXZWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldFN0YXRlUCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRTdGF0ZSA9ICgpID0+IHsgcmV0dXJuIHJlZi5jdXJyZW50OyB9O1xuXG5cbiAgICBjb25zb2xlLmFzc2VydChyZWYuY3VycmVudCA9PT0gc3RhdGUgfHwgKHR5cGVvZiBzdGF0ZSA9PT0gXCJudW1iZXJcIiAmJiBpc05hTihzdGF0ZSkpKTtcbiAgICByZXR1cm4gW3N0YXRlLCBzZXRTdGF0ZSwgZ2V0U3RhdGVdIGFzIGNvbnN0O1xufSIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG5jb25zdCBUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLVwiO1xuXG5mdW5jdGlvbiBiYXNlNjQodmFsdWU6IG51bWJlcikge1xuICAgIHJldHVybiBUYWJsZVt2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTZCaXRzKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAwYjEwMDAwMDApO1xufVxuXG5mdW5jdGlvbiByYW5kb202NEJpdHMoKSB7XG4gICAgcmV0dXJuIFtyYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpXSBhcyBjb25zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIHdpdGggYW4gb3B0aW9uYWwgcHJlZml4LlxuICogTm90ZSB0aGF0IGlmIHRoZSBwcmVmaXggaXMgKmV4cGxpY2l0bHkqIHNldCB0byBcIlwiLCB0aGVuXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JZChwcmVmaXg/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7cHJlZml4ID8/IFwiaWQtXCJ9JHtyYW5kb202NEJpdHMoKS5tYXAobiA9PiBiYXNlNjQobikpLmpvaW4oXCJcIil9YDtcbn1cblxuZXhwb3J0IHR5cGUgVXNlUmFuZG9tSWRQcm9wcyA9IDxQIGV4dGVuZHMgVXNlUmFuZG9tSWRQcm9wc1BhcmFtZXRlcnM+KHA6IFApID0+IFVzZVJhbmRvbUlkUHJvcHNSZXR1cm5UeXBlPFA+O1xuZXhwb3J0IHR5cGUgVXNlUmFuZG9tSWRQcm9wc1BhcmFtZXRlcnMgPSBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8XCJpZFwiPjtcbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkUHJvcHNSZXR1cm5UeXBlPFAgZXh0ZW5kcyBVc2VSYW5kb21JZFByb3BzUGFyYW1ldGVycz4gPSBVc2VSZWZlcmVuY2VkSWRQcm9wc1JldHVyblR5cGU8UCwgXCJpZFwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFBhcmFtZXRlcnMgeyBwcmVmaXg/OiBzdHJpbmc7IH1cblxuZXhwb3J0IHR5cGUgVXNlUmVmZXJlbmNlZElkUHJvcHM8SyBleHRlbmRzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+ID0gPFAgZXh0ZW5kcyBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8YW55Pj4ocHJvcHM6IFApID0+IFVzZVJlZmVyZW5jZWRJZFByb3BzUmV0dXJuVHlwZTxQLCBLPjtcbmV4cG9ydCB0eXBlIFVzZVJlZmVyZW5jZWRJZFByb3BzUGFyYW1ldGVyczxLIGV4dGVuZHMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pj4gPSBQYXJ0aWFsPFJlY29yZDxLLCBhbnk+PjsvLzxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7IH07XG5cblxuZXhwb3J0IHR5cGUgVXNlUmVmZXJlbmNlZElkUHJvcHNSZXR1cm5UeXBlPFAgZXh0ZW5kcyBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8YW55PiwgSyBleHRlbmRzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+ID0gT21pdDxQLCBLPiAmIFJlY29yZDxLLCBzdHJpbmc+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkUmV0dXJuVHlwZSB7XG4gICAgcmFuZG9tSWQ6IHN0cmluZztcblxuICAgIC8vIE5vdGU6IEVmZmVjdGl2ZWx5IGxhZ3MgYmVoaW5kIGJ5IG9uZSByZW5kZXIsIHRoZW4gcmUtcmVuZGVycyBhbmQgc3luY3MgYmFjayB1cCwgd2hlbiBhbiBJRCBpcyBwcm92aWRlZFxuICAgIGlkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZ2V0SWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIHVzZVJhbmRvbUlkUHJvcHM6IFVzZVJhbmRvbUlkUHJvcHM7XG4gICAgdXNlUmVmZXJlbmNlZElkUHJvcHM6IDxLIGV4dGVuZHMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pj4oaWRQcm9wTmFtZTogSykgPT4gVXNlUmVmZXJlbmNlZElkUHJvcHM8Sz47XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGhvb2sgdGhhdCBtb2RpZmllcyBhIHNldCBvZiBwcm9wcyB0byBwcm92aWRlIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIGlmIG9uZSB3YXMgbm90IHByb3ZpZGVkLlxuICogXG4gKiBJZiB5b3UnZCBsaWtlIHRvIHVzZSB0aGUgSUQgaW4gYSBwcm9wZXJ0eSB0aGF0J3MgKm5vdCogbmFtZWQgYGlkYCAobGlrZSBgZm9yYCBvciBgYXJpYS1sYWJlbGxlZGJ5YCBvciB3aGF0bm90KSwgYHVzZVJlZmVyZW5jZWRJZFByb3BzYCBpcyBhbHNvIHByb3ZpZGVkLlxuICogXG4gKiBBbmQgdGhlIHJhbmRvbWx5LWdlbmVyYXRlZCBpZCBpdHNlbGYgaXMgYWxzbyBwcm92aWRlZCBpbiBjYXNlIHlvdSB3YW50IHRvIGhhbmRsZSB0aGUgbG9naWMgeW91cnNlbGYgd2l0aG91dCBgdXNlTWVyZ2VkUHJvcHNgLlxuICogXG4gKiBVbmxpa2UgbW9zdCBvdGhlciBgdXNlKlByb3BzYCBob29rcywgdGhlc2UgYXJlIG1vc3RseSBzdGFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSYW5kb21JZCh7IHByZWZpeCB9OiBVc2VSYW5kb21JZFBhcmFtZXRlcnMgPSB7fSk6IFVzZVJhbmRvbUlkUmV0dXJuVHlwZSB7XG4gICAgY29uc3QgW3JhbmRvbUlkLCBzZXRSYW5kb21JZF0gPSB1c2VTdGF0ZTxzdHJpbmc+KCgpID0+IGdlbmVyYXRlUmFuZG9tSWQocHJlZml4KSk7XG4gICAgY29uc3QgW193YXRjaFByZWZpeFVwZGF0ZXMsIHNldFdhdGNoUHJlZml4VXBkYXRlcywgZ2V0V2F0Y2hQcmVmaXhVcGRhdGVzXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB3YXRjaFByZWZpeFVwZGF0ZXMgPSBnZXRXYXRjaFByZWZpeFVwZGF0ZXMoKTtcbiAgICAgICAgaWYgKHdhdGNoUHJlZml4VXBkYXRlcylcbiAgICAgICAgICAgIHNldFJhbmRvbUlkKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQocHJlZml4KSk7XG4gICAgICAgIHNldFdhdGNoUHJlZml4VXBkYXRlcyh0cnVlKTtcbiAgICB9LCBbcHJlZml4XSlcblxuICAgIC8vIFdoYXRldmVyIElEIHdhcyBtb3N0IHJlY2VudGx5IHVzZWQgYnkgdGhlIGFjdHVhbCBcImlkXCIgcHJvcC5cbiAgICAvLyBVc2VkIHNvIHRoYXQgYW55IElELXJlZmVyZW5jaW5nIHByb3BzIGRvbid0IG5lZWQgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZS5cbiAgICAvL1xuICAgIC8vIFRPRE86IFRoaXMgZG9lcyBtZWFuIHRoYXQgb24gdGhlIGZpcnN0IHJlbmRlciwgaWYganVzdCB0aGUgSUQgaXMgcHJvdmlkZWQsXG4gICAgLy8gdGhlcmUgd2lsbCBiZSBhIHRlbXBvcmFyeSBtaXNtYXRjaCwgYnV0IGl0J3MgY29ycmVjdGVkIGJlZm9yZSByZW5kZXJpbmcgZmluaXNoZXMuXG4gICAgLy8gSXMgdGhpcyBva2F5P1xuICAgIGNvbnN0IFt1c2VkSWQsIHNldFVzZWRJZCwgZ2V0VXNlZElkXSA9IHVzZVN0YXRlPHN0cmluZyB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IHVzZVJlZmVyZW5jZWRJZFByb3BzID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlUmVmZXJlbmNlZElkUHJvcHM8SyBleHRlbmRzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+KGlkUHJvcE5hbWU6IEspIHtcblxuICAgICAgICBjb25zdCByZXQ6IFVzZVJlZmVyZW5jZWRJZFByb3BzPEs+ID0gZnVuY3Rpb24gPFAgZXh0ZW5kcyBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8YW55Pj4oeyBbaWRQcm9wTmFtZV06IGdpdmVuSWQsIC4uLnByb3BzIH06IFApOiBVc2VSZWZlcmVuY2VkSWRQcm9wc1JldHVyblR5cGU8UCwgSz4ge1xuXG4gICAgICAgICAgICBjb25zdCB1c2VkSWQyID0gKGdpdmVuSWQgPz8gdXNlZElkID8/IHJhbmRvbUlkID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBpZiAoaWRQcm9wTmFtZSA9PT0gXCJpZFwiKVxuICAgICAgICAgICAgICAgIHNldFVzZWRJZCh1c2VkSWQyKTtcblxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEhUTUxFbGVtZW50PigpKHsgW2lkUHJvcE5hbWVdOiB1c2VkSWQyIH0sIHByb3BzKSBhcyB1bmtub3duIGFzIFVzZVJlZmVyZW5jZWRJZFByb3BzUmV0dXJuVHlwZTxQLCBLPjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSwgW3VzZWRJZCwgcmFuZG9tSWRdKTtcblxuICAgIGNvbnN0IHVzZVJhbmRvbUlkUHJvcHM6IFVzZVJhbmRvbUlkUHJvcHMgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VSYW5kb21JZFByb3BzPFAgZXh0ZW5kcyBVc2VSYW5kb21JZFByb3BzUGFyYW1ldGVycz4ocDogUCk6IFVzZVJhbmRvbUlkUHJvcHNSZXR1cm5UeXBlPFA+IHtcbiAgICAgICAgcmV0dXJuIHVzZVJlZmVyZW5jZWRJZFByb3BzKFwiaWRcIikocCk7XG4gICAgfSwgW3VzZVJlZmVyZW5jZWRJZFByb3BzXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByYW5kb21JZCxcbiAgICAgICAgaWQ6IHVzZWRJZCxcbiAgICAgICAgZ2V0SWQ6IGdldFVzZWRJZCxcbiAgICAgICAgdXNlUmFuZG9tSWRQcm9wcyxcbiAgICAgICAgdXNlUmVmZXJlbmNlZElkUHJvcHNcbiAgICB9O1xufVxuIiwiXG5pbXBvcnQgeyBDb21wb25lbnQsIG9wdGlvbnMsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgRWZmZWN0Q2FsbGJhY2ssIElucHV0cywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGdlbmVyYXRlUmFuZG9tSWQgfSBmcm9tIFwiLi91c2UtcmFuZG9tLWlkXCI7XG5cbmNvbnN0IHByZXZpb3VzSW5wdXRzID0gbmV3IE1hcDxzdHJpbmcsIElucHV0cyB8IHVuZGVmaW5lZD4oKTtcbmNvbnN0IHRvUnVuID0gbmV3IE1hcDxzdHJpbmcsIHsgZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgaW5wdXRzPzogSW5wdXRzLCBjbGVhbnVwOiBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZCB8ICgoKSA9PiB2b2lkKSB9PigpO1xuXG5cbi8vIFRPRE86IFdoZXRoZXIgdGhpcyBnb2VzIGluIG9wdGlvbnMuZGlmZmVkIG9yIG9wdGlvbnMuX2NvbW1pdFxuLy8gaXMgYSBwb3N0LXN1c3BlbnNlIHF1ZXN0aW9uLlxuLy8gUmlnaHQgbm93LCB1c2luZyBvcHRpb25zLl9jb21taXQgaGFzIHRoZSBwcm9ibGVtIG9mIHJ1bm5pbmdcbi8vICphZnRlciogcmVmcyBhcmUgYXBwbGllZCwgYnV0IHdlIG5lZWQgdG8gY29tZSBiZWZvcmUgZXZlbiB0aGF0XG4vLyBzbyBgcmVmPXtzb21lU3RhYmxlRnVuY3Rpb259YCB3b3Jrcy5cbi8vIFxuLy8gQWxzbyBpdCdzIHByaXZhdGUuXG4vL1xuLy8gLi4uXG4vLyBXZWxsLCB1c2VFdmVudCBvciB3aGF0ZXZlciBpcyBmaW5hbGx5LCBmaW5hbGx5IDQgeWVhcnMgbGF0ZXIgZmluYWxseSBoZXJlXG4vLyB3aGljaCBpcyBjb29sIGFuZCBtZWFucyB3ZSB3b24ndCBuZWVkIHRoaXMgYXQgYWxsIHNvb24uXG4vLyBTbyBmb3Igbm93IHdlJ2xsIHN0aWNrIHdpdGggZGlmZiB0byBwcmV2ZW50IGFueSB3ZWlyZG5lc3Mgd2l0aFxuLy8gY29tbWl0IGJlaW5nIHByaXZhdGUgYW5kIGFsbC5cbmNvbnN0IGNvbW1pdE5hbWUgPSBcImRpZmZlZFwiO1xuXG5jb25zdCBvcmlnaW5hbENvbW1pdCA9IG9wdGlvbnNbY29tbWl0TmFtZV0gYXMgKHZub2RlOiBWTm9kZSwgY29tbWl0UXVldWU6IENvbXBvbmVudFtdKSA9PiB2b2lkO1xuY29uc3QgbmV3Q29tbWl0OiB0eXBlb2Ygb3JpZ2luYWxDb21taXQgPSAoLi4uYXJncykgPT4ge1xuICAgIGZvciAoY29uc3QgW2lkLCBlZmZlY3RJbmZvXSBvZiB0b1J1bikge1xuICAgICAgICBjb25zdCBvbGRJbnB1dHMgPSBwcmV2aW91c0lucHV0cy5nZXQoaWQpO1xuICAgICAgICBpZiAoYXJnc0NoYW5nZWQob2xkSW5wdXRzLCBlZmZlY3RJbmZvLmlucHV0cykpIHtcbiAgICAgICAgICAgIGVmZmVjdEluZm8uY2xlYW51cD8uKCk7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXAgPSBlZmZlY3RJbmZvLmVmZmVjdCgpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuc2V0KGlkLCBlZmZlY3RJbmZvLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9SdW4uY2xlYXIoKTtcbiAgICBvcmlnaW5hbENvbW1pdD8uKC4uLmFyZ3MpO1xufVxub3B0aW9uc1tjb21taXROYW1lXSA9IG5ld0NvbW1pdCBhcyBuZXZlclxuXG4vKipcbiAqIFNlbWktcHJpdmF0ZSBmdW5jdGlvbiB0byBhbGxvdyBzdGFibGUgY2FsbGJhY2tzIGV2ZW4gd2l0aGluIGB1c2VMYXlvdXRFZmZlY3RgIGFuZCByZWYgYXNzaWdubWVudC5cbiAqIFxuICogRXZlcnkgcmVuZGVyLCB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgdG8gYmUgZXZhbHVhdGVkIGFmdGVyIGRpZmZpbmcgaGFzIGNvbXBsZXRlZCxcbiAqIHdoaWNoIGhhcHBlbnMgYmVmb3JlLlxuICogXG4gKiBAcGFyYW0gZWZmZWN0IFxuICogQHBhcmFtIGlucHV0cyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJlZm9yZUxheW91dEVmZmVjdChlZmZlY3Q6IEVmZmVjdENhbGxiYWNrLCBpbnB1dHM/OiBJbnB1dHMpIHtcblxuICAgIC8qKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IHVzZVJlZjx2b2lkIHwgKCgpID0+IHZvaWQpIHwgbnVsbD4obnVsbCk7XG4gICAgICAgIGNvbnN0IHByZXZBcmdzUmVmID0gdXNlUmVmPElucHV0cz4obnVsbCEpO1xuICAgICAgICBpZiAoYXJnc0NoYW5nZWQoaW5wdXRzLCBwcmV2QXJnc1JlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgcHJldkFyZ3NSZWYuY3VycmVudCA9IGlucHV0cyE7XG4gICAgICAgICAgICBpZiAoY2xlYW51cC5jdXJyZW50KVxuICAgICAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCgpO1xuICAgICAgICAgICAgY2xlYW51cC5jdXJyZW50ID0gZWZmZWN0KCk7XG4gICAgICAgIH1cbiAgICB9KSgpOyovXG5cbiAgICBjb25zdCBbaWRdID0gdXNlU3RhdGUoKCkgPT4gZ2VuZXJhdGVSYW5kb21JZCgpKTtcbiAgICB0b1J1bi5zZXQoaWQsIHsgZWZmZWN0LCBpbnB1dHMsIGNsZWFudXA6IG51bGwgfSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdG9SdW4uZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICB9LCBbaWRdKVxufVxuXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzPzogSW5wdXRzLCBuZXdBcmdzPzogSW5wdXRzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhKFxuICAgICAgICAhb2xkQXJncyB8fFxuICAgICAgICBvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncz8ubGVuZ3RoIHx8XG4gICAgICAgIG5ld0FyZ3M/LnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG4gICAgKTtcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlQmVmb3JlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0XCI7XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKFwidW5zZXRcIik7XG5cbi8qKlxuICogR2l2ZW4gYW4gaW5wdXQgdmFsdWUsIHJldHVybnMgYSBjb25zdGFudCBnZXR0ZXIgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBcbiAqIGluc2lkZSBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcyB3aXRob3V0IGluY2x1ZGluZyBpdCBpbiB0aGUgZGVwZW5kZW5jeSBhcnJheS5cbiAqIFxuICogVGhpcyB1c2VzIGBvcHRpb25zLmRpZmZlZGAgaW4gb3JkZXIgdG8gcnVuIGJlZm9yZSBldmVyeXRoaW5nLCBldmVuXG4gKiByZWYgYXNzaWdubWVudC4gVGhpcyBtZWFucyB0aGlzIGdldHRlciBpcyBzYWZlIHRvIHVzZSBhbnl3aGVyZSAqKipleGNlcHQgdGhlIHJlbmRlciBwaGFzZSoqKi5cbiAqIFxuICogQHBhcmFtIHZhbHVlIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVHZXR0ZXI8VD4odmFsdWU6IFQpOiAoKSA9PiBUIHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWY8VD4oVW5zZXQgYXMgdW5rbm93biBhcyBUKTtcbiAgICB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoKCkgPT4geyByZWYuY3VycmVudCA9IHZhbHVlOyB9LCBbdmFsdWVdKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAocmVmLmN1cnJlbnQgYXMgdW5rbm93biA9PT0gVW5zZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgcmV0cmlldmVkIGZyb20gdXNlU3RhYmxlR2V0dGVyKCkgY2Fubm90IGJlIGNhbGxlZCBkdXJpbmcgcmVuZGVyLicpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZi5jdXJyZW50O1xuICAgIH0sIFtdKVxufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuXG4vKipcbiAqIEFsdGVybmF0ZSB1c2VDYWxsYmFjaygpIHdoaWNoIGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lICh3cmFwcGVkKSBmdW5jdGlvbiByZWZlcmVuY2VcbiAqIHNvIHRoYXQgaXQgY2FuIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGRlcGVuZGVuY3kgYXJyYXlzIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzLlxuICogXG4gKiBEbyBub3QgdXNlIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlISAgYHVzZUxheW91dEVmZmVjdGAgaXMgZmluZSB0aG91Z2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjazxUIGV4dGVuZHMgKC4uLl9hcmdzOiBhbnlbXSkgPT4gYW55PihmbjogVCk6IFQge1xuICAgIGNvbnN0IGN1cnJlbnRDYWxsYmFja0dldHRlciA9IHVzZVN0YWJsZUdldHRlcjxUPihmbik7XG5cbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pOiBSZXR1cm5UeXBlPFQ+ID0+IHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDYWxsYmFja0dldHRlcigpKC4uLmFyZ3MpO1xuICAgIH0sIFtdKSBhcyBUO1xufSIsImltcG9ydCB7IElucHV0cywgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdE5hdGl2ZSwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5cclxuLyoqXHJcbiAqIFdyYXAgdGhlIG5hdGl2ZSBgdXNlRWZmZWN0YCB0byBhZGQgYXJndW1lbnRzIFxyXG4gKiB0aGF0IGFsbG93IGFjY2Vzc2luZyB0aGUgcHJldmlvdXMgdmFsdWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxyXG4gKiBhcyB3ZWxsIGFzIHRoZSBjaGFuZ2VzIHRoYXQgY2F1c2VkIHRoZSBob29rIHRvIGJlIGNhbGxlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4gKiBcclxuICogQHBhcmFtIGVmZmVjdCBcclxuICogQHBhcmFtIGlucHV0cyBcclxuICogQHBhcmFtIGltcGwgWW91IGNhbiBjaG9vc2Ugd2hldGhlciB0byB1c2UgYHVzZUVmZmVjdGAgb3IgYHVzZUxheW91dEVmZmVjdGAgYnlcclxuICogcGFzc2luZyBvbmUgb2YgdGhlbSBhcyB0aGlzIGFyZ3VtZW50LiBCeSBkZWZhdWx0LCBpdCdzIGB1c2VFZmZlY3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdDxJIGV4dGVuZHMgSW5wdXRzPihlZmZlY3Q6IChwcmV2OiBJIHwgdW5kZWZpbmVkLCBjaGFuZ2VzOiBFZmZlY3RDaGFuZ2U8SSwgbnVtYmVyPltdKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSksIGlucHV0cz86IEksIGltcGwgPSB1c2VFZmZlY3ROYXRpdmUpIHtcclxuXHJcbiAgICBjb25zdCBwcmV2SW5wdXRzID0gdXNlUmVmPHVuZGVmaW5lZCB8IEk+KHVuZGVmaW5lZCk7XHJcbiAgICBjb25zdCBlZmZlY3QyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZXM6IHsgZnJvbTogYW55LCB0bzogYW55IH1bXSA9IFtdO1xyXG4gICAgICAgIGlmIChpbnB1dHMgJiYgcHJldklucHV0cy5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgocHJldklucHV0cy5jdXJyZW50Lmxlbmd0aCwgaW5wdXRzLmxlbmd0aCk7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZJbnB1dHMuY3VycmVudFtpXSAhPSBpbnB1dHNbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlc1tpXSA9IHsgZnJvbTogcHJldklucHV0cy5jdXJyZW50W2ldLCB0bzogaW5wdXRzW2ldIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXQgPSBlZmZlY3QocHJldklucHV0cy5jdXJyZW50LCBjaGFuZ2VzKTtcclxuICAgICAgICBwcmV2SW5wdXRzLmN1cnJlbnQgPSBpbnB1dHM7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH07XHJcblxyXG4gICAgaW1wbChlZmZlY3QyLCBpbnB1dHMpO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVmZmVjdENoYW5nZTxJIGV4dGVuZHMgSW5wdXRzLCBOIGV4dGVuZHMgbnVtYmVyPiB7IGZyb206IElbTl0sIHRvOiBJW05dIH1cclxuIiwiaW1wb3J0IHsgSW5wdXRzLCB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0TmF0aXZlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWZmZWN0Q2hhbmdlLCB1c2VFZmZlY3QgfSBmcm9tIFwiLi91c2UtZWZmZWN0XCI7XG5cbi8qKlxuICogV3JhcCB0aGUgbmF0aXZlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGFkZCBhcmd1bWVudHMgXG4gKiB0aGF0IGFsbG93IGFjY2Vzc2luZyB0aGUgcHJldmlvdXMgdmFsdWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYXMgd2VsbCBhcyB0aGUgY2hhbmdlcyB0aGF0IGNhdXNlZCB0aGUgaG9vayB0byBiZSBjYWxsZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3Q8SSBleHRlbmRzIElucHV0cz4oZWZmZWN0OiAocHJldjogSSB8IHVuZGVmaW5lZCwgY2hhbmdlczogRWZmZWN0Q2hhbmdlPEksIG51bWJlcj5bXSkgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpLCBpbnB1dHM/OiBJKSB7XG4gICAgcmV0dXJuIHVzZUVmZmVjdChlZmZlY3QsIGlucHV0cywgdXNlTGF5b3V0RWZmZWN0TmF0aXZlKTtcbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUaW1lb3V0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2AuICBcbiAgICAgKiBJZiBgbnVsbGAsIGNhbmNlbHMgdGhlIHRpbWVvdXQgaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgdGltZW91dDogbnVtYmVyIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdG8gdGhpcyBwcm9wIGJldHdlZW4gcmVuZGVycyBjYW4gYmUgdXNlZCB0byBjbGVhciB0aGUgY3VycmVudCB0aW1lb3V0IGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqL1xuICAgIHRyaWdnZXJJbmRleD86IHVua25vd247XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYHRpbWVvdXRgIG1zIGFmdGVyIG1vdW50LCBvciB0aGUgbGFzdCBjaGFuZ2UgdG8gYHRyaWdnZXJJbmRleGAuXG4gICAgICogXG4gICAgICogRG9lcyAqbm90KiBuZWVkIHRvIGJlIHN0YWJsZS4gR28gYWhlYWQgYW5kIHBhc3MgYW4gYW5vbnltb3VzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVGltZW91dCh7IHRpbWVvdXQsIGNhbGxiYWNrLCB0cmlnZ2VySW5kZXggfTogVXNlVGltZW91dCkge1xuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBzdGFydFRpbWVSZWYuY3VycmVudCA9IG51bGw7IGNhbGxiYWNrKCk7IH0pO1xuICAgIGNvbnN0IGdldFRpbWVvdXQgPSB1c2VTdGFibGVHZXR0ZXIodGltZW91dCk7XG5cbiAgICAvLyBTZXQgYW55IHRpbWUgd2Ugc3RhcnQgdGltZW91dC5cbiAgICAvLyBVbnNldCBhbnkgdGltZSB0aGUgdGltZW91dCBjb21wbGV0ZXNcbiAgICBjb25zdCBzdGFydFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCB0aW1lb3V0SXNOdWxsID0gKHRpbWVvdXQgPT0gbnVsbCk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgdHJpZ2dlckluZGV4IGNoYW5nZXMgKGluY2x1ZGluZyBvbiBtb3VudClcbiAgICAvLyByZXN0YXJ0IHRoZSB0aW1lb3V0LiAgVGhlIHRpbWVvdXQgZG9lcyBOT1QgcmVzZXRcbiAgICAvLyB3aGVuIHRoZSBkdXJhdGlvbiBvciBjYWxsYmFjayBjaGFuZ2VzLCBvbmx5IHRyaWdnZXJJbmRleC5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRpbWVvdXRJc051bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aW1lb3V0SXNOdWxsID09ICh0aW1lb3V0ID09IG51bGwpKTtcbiAgICBcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVSZWYuY3VycmVudCA9ICsobmV3IERhdGUoKSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChzdGFibGVDYWxsYmFjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sIFt0cmlnZ2VySW5kZXgsIHRpbWVvdXRJc051bGxdKVxuXG4gICAgY29uc3QgZ2V0RWxhcHNlZFRpbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKyhuZXcgRGF0ZSgpKSkgLSAoKyhzdGFydFRpbWVSZWYuY3VycmVudCA/PyBuZXcgRGF0ZSgpKSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0UmVtYWluaW5nVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgcmV0dXJuIHRpbWVvdXQgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1heCgwLCB0aW1lb3V0IC0gZ2V0RWxhcHNlZFRpbWUoKSlcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyBnZXRFbGFwc2VkVGltZSwgZ2V0UmVtYWluaW5nVGltZSB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZEluZm8gfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWxheW91dC1lZmZlY3RcIjtcbmltcG9ydCB7IHVzZUxvZ2ljYWxEaXJlY3Rpb24gfSBmcm9tIFwiLi91c2UtbG9naWNhbC1kaXJlY3Rpb25cIjtcbmltcG9ydCB7IE1lcmdlZFByb3BzLCB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IFVzZVJlZkVsZW1lbnRQcm9wc1JldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcbmltcG9ydCB7IHVzZVRpbWVvdXQgfSBmcm9tIFwiLi91c2UtdGltZW91dFwiO1xuXG5cblxuXG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGU8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIC8vIFRoZXNlIHByb3BzIGNhbiBiZSBhdHRhdGNoZWQgZWl0aGVyIHRvIHRoZSBwYXJlbnQgb3IgdG8gZWFjaCBpbmRpdmlkdWFsIGNoaWxkLlxuICAgIC8vIFdoaWNoZXZlciB3b3JrcyBiZXR0ZXIgZm9yIHlvdXIgc2NlbmFyaW8uXG4gICAgdXNlTGluZWFyTmF2aWdhdGlvblByb3BzOiBVc2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHM8Q2hpbGRFbGVtZW50Pjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlTGluZWFyTmF2aWdhdGlvblByb3BzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+Pihwcm9wczogUCkgPT4gVXNlUmVmRWxlbWVudFByb3BzUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQsIGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4+XG5cblxuXG4vKiogQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcGFyZW50IGB1c2VMaW5lYXJOYXZpZ2F0aW9uYCAqL1xuaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzQmFzZSB7XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hpY2ggYXJyb3cga2V5cyBhcmUgdXNlZCB0byBuYXZpZ2F0ZSB0aHJvdWdoIHRoZSBjb21wb25lbnQuXG4gICAgICogUmVsYXRpdmUgdG8gdGhlIHdyaXRpbmcgbW9kZSwgc28gaW4gRW5nbGlzaCwgXCJpbmxpbmVcIiBjb3JyZXNwb25kc1xuICAgICAqIHRvIHRoZSBsZWZ0ICYgcmlnaHQgYXJyb3cga2V5cywgYW5kIFwiYmxvY2tcIiB0byB0aGUgdXAgJiBkb3duIGFycm93IGtleXMuXG4gICAgICogXG4gICAgICogVXNlIFwiZWl0aGVyXCIgdG8gYWxsb3cgbmF2aWdhdGlvbiBpbiBlaXRoZXIgZGlyZWN0aW9uLlxuICAgICAqIFxuICAgICAqIFVzZSBcIm5vbmVcIiB0byBkaXNhbGxvdyBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgaW4gYW55IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uPzogXCJpbmxpbmVcIiB8IFwiYmxvY2tcIiB8IFwiZWl0aGVyXCIgfCBcIm5vbmVcIjtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgd2lsbCBiZSBcbiAgICAgKiBkaXNhYmxlZCwgYnV0IG5hdmlnYXRpb24gd2l0aCB0aGUgaG9tZSAmIGVuZCBrZXlzIHdpbGxcbiAgICAgKiBiZSB1bmFmZmVjdGVkLlxuICAgICAqL1xuICAgIGRpc2FibGVBcnJvd0tleXM/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIG5hdmlnYXRpb24gd2l0aCB0aGUgaG9tZSAmIGVuZCBrZXlzIHdpbGxcbiAgICAgKiBiZSBkaXNhYmxlZCwgYnV0IG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlXG4gICAgICogdW5hZmZlY3RlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlSG9tZUVuZEtleXM/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1hbmFnZWRDaGlsZHJlbiB5b3UgaGF2ZSBmcm9tIHVzZVJvdmluZ1RhYkluZGV4IFxuICAgICAqIChwcmVzdW1hYmx5LCBidXQgaXQgY291bGQgYWxzbyBqdXN0IGJlIGZyb20gdXNlQ2hpbGRNYW5hZ2VyKVxuICAgICAqL1xuICAgIG1hbmFnZWRDaGlsZHJlbjogVXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkSW5mb1tdO1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc0Jhc2Uge1xuICAgIG5hdmlnYXRlVG9OZXh0KCk6IHZvaWQ7XG4gICAgbmF2aWdhdGVUb1ByZXYoKTogdm9pZDtcbiAgICBuYXZpZ2F0ZVRvRmlyc3QoKTogdm9pZDtcbiAgICBuYXZpZ2F0ZVRvTGFzdCgpOiB2b2lkO1xuICAgIGluZGV4OiBudW1iZXI7XG59XG5cblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNoaWxkICd1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRgICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25DaGlsZEluZm8gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlcj4geyB9XG5cbi8qKiBSZXR1cm4gdHlwZSBvZiB0aGUgY2hpbGQgYHVzZUxpbmVhck5hdmlnYXRpb25DaGlsZFByb3BzYCAqL1xuZXhwb3J0IHR5cGUgVXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkUHJvcHNSZXR1cm5UeXBlPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFAgZXh0ZW5kcyB7fT4gPSBNZXJnZWRQcm9wczxDaGlsZEVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQcm9wc1JldHVyblR5cGU8Q2hpbGRFbGVtZW50LCB7IHRhYkluZGV4OiBudW1iZXI7IH0+LCBPbWl0PFAsIFwidGFiSW5kZXhcIj4+O1xuXG5cbi8qKlxuICogV2hlbiB1c2VkIGluIHRhbmRlbSB3aXRoIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGFsbG93cyBjb250cm9sIG9mXG4gKiB0aGUgdGFiYmFibGUgaW5kZXggd2l0aCB0aGUgYXJyb3cga2V5cy5cbiAqIFxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmVhck5hdmlnYXRpb248Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBpbmRleCwgbmF2aWdhdGVUb0ZpcnN0LCBuYXZpZ2F0ZVRvTGFzdCwgbmF2aWdhdGVUb05leHQsIG5hdmlnYXRlVG9QcmV2LCBtYW5hZ2VkQ2hpbGRyZW4sIG5hdmlnYXRpb25EaXJlY3Rpb24sIGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cyB9OiBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyk6IFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlPENoaWxkRWxlbWVudD4ge1xuXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbiA/Pz0gXCJlaXRoZXJcIjtcblxuICAgIGNvbnN0IGNoaWxkQ291bnQgPSBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSB0YWJiYWJsZSBpbmRleCBuZXZlciBlc2NhcGVzIHRoZSBib3VuZHMgb2YgYWxsIGF2YWlsYWJsZSBjaGlsZHJlblxuICAgIC8vIFRPRE86IEtlZXAgdHJhY2sgb2YgdGhlIG9yaWdpbmFsIGluZGV4IGFuZCBrZWVwIGl0LCBhdCBsZWFzdCB1bnRpbCBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRDb3VudCA+IDAgJiYgaW5kZXggPj0gY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9MYXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbaW5kZXgsIGNoaWxkQ291bnQsIG5hdmlnYXRlVG9GaXJzdCwgbmF2aWdhdGVUb0xhc3RdKTtcblxuICAgIGNvbnN0IHsgZ2V0TG9naWNhbERpcmVjdGlvbkluZm8sIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wcyB9ID0gdXNlTG9naWNhbERpcmVjdGlvbjxDaGlsZEVsZW1lbnQ+KHt9KTtcblxuICAgIGNvbnN0IG9uS2V5RG93biA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxuICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjb25zdCBpbmZvID0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcblxuICAgICAgICBjb25zdCBhbGxvd3NCbG9ja05hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImJsb2NrXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcbiAgICAgICAgY29uc3QgYWxsb3dzSW5saW5lTmF2aWdhdGlvbiA9IChuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiaW5saW5lXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcblxuICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gYWxsb3dzQmxvY2tOYXZpZ2F0aW9uIDogYWxsb3dzSW5saW5lTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcImJ0dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gYWxsb3dzQmxvY2tOYXZpZ2F0aW9uIDogYWxsb3dzSW5saW5lTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcImJ0dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImlubGluZURpcmVjdGlvblwiIDogXCJibG9ja0RpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uIDogYWxsb3dzQmxvY2tOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwicnRsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJpbmxpbmVEaXJlY3Rpb25cIiA6IFwiYmxvY2tEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gYWxsb3dzSW5saW5lTmF2aWdhdGlvbiA6IGFsbG93c0Jsb2NrTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcInJ0bFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVIb21lRW5kS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvRmlyc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZUhvbWVFbmRLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9MYXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHM6IHVzZUNhbGxiYWNrKDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50Pj4ocHJvcHM6IFApID0+IHsgcmV0dXJuIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wcyh1c2VNZXJnZWRQcm9wczxDaGlsZEVsZW1lbnQ+KCkoeyBvbktleURvd24gfSwgcHJvcHMpKSB9LCBbXSksXG4gICAgfVxuXG5cbn1cblxuXG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGU8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSSBleHRlbmRzIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZEluZm8+IHtcbiAgICAvLyBDYW4gYmUgdXNlZCBvbiBlaXRoZXIgdGhlIHBhcmVudCBvciBlYWNoIGNoaWxkIGVsZW1lbnQuXG4gICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM8Q2hpbGRFbGVtZW50PjtcblxuICAgIC8vIE11c3QgYmUgdXNlZCBvbiBlYWNoIGNoaWxkIGVsZW1lbnQuXG4gICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBJPjtcblxuXG4gICAgY3VycmVudFR5cGVhaGVhZDogc3RyaW5nIHwgbnVsbDtcbiAgICBpbnZhbGlkVHlwZWFoZWFkOiBib29sZWFuIHwgbnVsbDtcbn1cblxuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiA9IDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHByb3BzOiBQKSA9PiBNZXJnZWRQcm9wczxFLCBQLCBQPlxuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxfRSBleHRlbmRzIEVsZW1lbnQ+ID0gdm9pZDtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzIHtcblxuICAgIC8qKlxuICAgICAqIEEgY29sbGF0b3IgdG8gdXNlIHdoZW4gY29tcGFyaW5nLiBJZiBub3QgcHJvdmlkZWQsIHNpbXBseSB1c2VzIGBsb2NhbGVDb21wYXJlYCBhZnRlciB0cmFuc2Zvcm1pbmcgZWFjaCB0byBsb3dlcmNhc2UsIHdoaWNoIHdpbGwsIGF0IGJlc3QsIHdvcmsgb2theSBpbiBFbmdsaXNoLlxuICAgICAqL1xuICAgIGNvbGxhdG9yPzogSW50bC5Db2xsYXRvcjtcblxuICAgIHR5cGVhaGVhZFRpbWVvdXQ/OiBudW1iZXI7XG4gICAgZ2V0SW5kZXgoKTogbnVtYmVyIHwgbnVsbDtcbiAgICBzZXRJbmRleCh2YWx1ZTogbnVtYmVyIHwgbnVsbCB8ICgocHJldmlvdXNWYWx1ZTogbnVtYmVyIHwgbnVsbCkgPT4gKG51bWJlciB8IG51bGwpKSk6IHZvaWQ7XG59XG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjaGlsZCAndXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkYCAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRJbmZvIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXI+IHtcbiAgICAvKipcbiAgICAgKiBJZiBwcm92aWRlZCwgYWxsb3dzIHRoaXMgY29tcG9uZW50IHRvIGJlIG5hdmlnYXRlZCB0byBieSB0eXBpbmcgdGhpcyBzdHJpbmcuIFxuICAgICAqIEl0IHNob3VsZCBiZSB0aGUgc2FtZSB0ZXh0IGNvbnRlbnQgYXMgd2hhdGV2ZXIncyBkaXNwbGF5ZWQsIGlkZWFsbHkuXG4gICAgICovXG4gICAgdGV4dDogc3RyaW5nIHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkSW5mbyB7IH1cblxuLyoqIFR5cGUgb2YgdGhlIGNoaWxkJ3Mgc3ViLWhvb2sgKi9cbmV4cG9ydCB0eXBlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkSW5mbz4gPSAoeyB0ZXh0LCBpbmRleCwgLi4uaSB9OiBJKSA9PiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudD47XG5cbi8qKiBSZXR1cm4gdHlwZSBvZiB0aGUgY2hpbGQgYHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFByb3BzYCAqL1xuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQIGV4dGVuZHMge30+ID0gTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50LCBVc2VSZWZFbGVtZW50UHJvcHNSZXR1cm5UeXBlPENoaWxkRWxlbWVudCwge1xuICAgIG9uS2V5RG93bjogKGU6IEtleWJvYXJkRXZlbnQpID0+IHZvaWQ7XG4gICAgb25Db21wb3NpdGlvblN0YXJ0OiAoZTogQ29tcG9zaXRpb25FdmVudCkgPT4gdm9pZDtcbiAgICBvbkNvbXBvc2l0aW9uRW5kOiAoZTogQ29tcG9zaXRpb25FdmVudCkgPT4gdm9pZDtcbn0+LCBQPjtcblxuXG4vKipcbiAqIEFsbG93cyBmb3IgdGhlIHNlbGVjdGlvbiBvZiBhIG1hbmFnZWQgY2hpbGQgYnkgdHlwaW5nIHRoZSBnaXZlbiB0ZXh0IGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAqIFxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVR5cGVhaGVhZE5hdmlnYXRpb248Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSSBleHRlbmRzIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZEluZm8+KHsgY29sbGF0b3IsIGdldEluZGV4LCB0eXBlYWhlYWRUaW1lb3V0LCBzZXRJbmRleCB9OiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyk6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlPENoaWxkRWxlbWVudCwgST4ge1xuXG5cbiAgICAvLyBGb3IgdHlwZWFoZWFkLCBrZWVwIHRyYWNrIG9mIHdoYXQgb3VyIGN1cnJlbnQgXCJzZWFyY2hcIiBzdHJpbmcgaXMgKGlmIHdlIGhhdmUgb25lKVxuICAgIC8vIGFuZCBhbHNvIGNsZWFyIGl0IGV2ZXJ5IDEwMDAgbXMgc2luY2UgdGhlIGxhc3QgdGltZSBpdCBjaGFuZ2VkLlxuICAgIC8vIE5leHQsIGtlZXAgYSBtYXBwaW5nIG9mIHR5cGVhaGVhZCB2YWx1ZXMgdG8gaW5kaWNlcyBmb3IgZmFzdGVyIHNlYXJjaGluZy5cbiAgICAvLyBBbmQsIGZvciB0aGUgdXNlcidzIHNha2UsIGxldCB0aGVtIGtub3cgd2hlbiB0aGVpciB0eXBlYWhlYWQgY2FuJ3QgbWF0Y2ggYW55dGhpbmcgYW55bW9yZVxuICAgIGNvbnN0IFtjdXJyZW50VHlwZWFoZWFkLCBzZXRDdXJyZW50VHlwZWFoZWFkLCBnZXRDdXJyZW50VHlwZWFoZWFkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIHVzZVRpbWVvdXQoeyB0aW1lb3V0OiB0eXBlYWhlYWRUaW1lb3V0ID8/IDEwMDAsIGNhbGxiYWNrOiAoKSA9PiB7IHNldEN1cnJlbnRUeXBlYWhlYWQobnVsbCk7IHNldEludmFsaWRUeXBlYWhlYWQobnVsbCk7IH0sIHRyaWdnZXJJbmRleDogY3VycmVudFR5cGVhaGVhZCB9KTtcbiAgICBjb25zdCBzb3J0ZWRUeXBlYWhlYWRJbmZvID0gdXNlUmVmPHsgdGV4dDogc3RyaW5nLCB1bnNvcnRlZEluZGV4OiBudW1iZXIgfVtdPihbXSk7XG4gICAgY29uc3QgW2ludmFsaWRUeXBlYWhlYWQsIHNldEludmFsaWRUeXBlYWhlYWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KGZhbHNlKTtcblxuICAgIC8vIEhhbmRsZSB0eXBlYWhlYWQgZm9yIGlucHV0IG1ldGhvZCBlZGl0b3JzIGFzIHdlbGxcbiAgICAvLyBFc3NlbnRpYWxseSwgd2hlbiBhY3RpdmUsIGlnbm9yZSBmdXJ0aGVyIGtleXMgXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSB3YWl0aW5nIGZvciBhIENvbXBvc2l0aW9uRW5kIGV2ZW50XG4gICAgY29uc3QgWywgc2V0SW1lQWN0aXZlLCBnZXRJbWVBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy8gQmVjYXVzZSBjb21wb3NpdGlvbiBldmVudHMgZmlyZSAqYWZ0ZXIqIGtleWRvd24gZXZlbnRzIFxuICAgIC8vIChidXQgd2l0aGluIHRoZSBzYW1lIHRhc2ssIHdoaWNoLCBUT0RPLCBjb3VsZCBiZSBicm93c2VyLWRlcGVuZGVudCksXG4gICAgLy8gd2UgY2FuIHVzZSB0aGlzIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnQgd2UncmUgbGlzdGVuaW5nIGZvciBvbiB0aGUgZmlyc3Qga2V5ZG93bi5cbiAgICBjb25zdCBbbmV4dFR5cGVhaGVhZENoYXIsIHNldE5leHRUeXBlYWhlYWRDaGFyXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChuZXh0VHlwZWFoZWFkQ2hhciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0Q3VycmVudFR5cGVhaGVhZCh0eXBlYWhlYWQgPT4gKCh0eXBlYWhlYWQgPz8gXCJcIikgKyBuZXh0VHlwZWFoZWFkQ2hhcikpO1xuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIobnVsbCk7XG4gICAgICAgIH1cbiAgICB9LCBbbmV4dFR5cGVhaGVhZENoYXJdKTtcblxuXG4gICAgY29uc3QgY29tcGFyYXRvclNoYXJlZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChzYWZlTGhzOiBzdHJpbmcsIHNhZmVSaHM6IHN0cmluZykgPT4ge1xuICAgICAgICBsZXQgY29tcGFyZTogbnVtYmVyO1xuICAgICAgICAvLyBGb3IgdGhlIHB1cnBvc2VzIG9mIHR5cGVhaGVhZCwgb25seSBjb21wYXJlIGEgc3RyaW5nIG9mIHRoZSBzYW1lIHNpemUgYXMgb3VyIGN1cnJlbnRseSB0eXBlZCBzdHJpbmcuXG4gICAgICAgIC8vIEJ5IG5vcm1hbGl6aW5nIHRoZW0gZmlyc3QsIHdlIGVuc3VyZSB0aGlzIGJ5dGUtYnktYnl0ZSBoYW5kbGluZyBvZiByYXcgY2hhcmFjdGVyIGRhdGEgd29ya3Mgb3V0IG9rYXkuXG4gICAgICAgIHNhZmVMaHMgPSBzYWZlTGhzLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgc2FmZVJocyA9IHNhZmVSaHMubm9ybWFsaXplKFwiTkZEXCIpXG5cbiAgICAgICAgaWYgKGNvbGxhdG9yKVxuICAgICAgICAgICAgY29tcGFyZSA9IGNvbGxhdG9yLmNvbXBhcmUoc2FmZUxocywgc2FmZVJocylcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGFyZSA9IHNhZmVMaHMudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKHNhZmVSaHMudG9Mb3dlckNhc2UoKSA/PyBcIlwiKTtcblxuICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGluc2VydGluZ0NvbXBhcmF0b3IgPSB1c2VTdGFibGVDYWxsYmFjaygobGhzOiBJW1widGV4dFwiXSwgcmhzOiB7IHRleHQ6IElbXCJ0ZXh0XCJdOyB1bnNvcnRlZEluZGV4OiBudW1iZXI7IH0pID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmhzLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yU2hhcmVkKGxocywgcmhzLnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChsaHMgYXMgdW5rbm93biBhcyBudW1iZXIpIC0gKHJocyBhcyB1bmtub3duIGFzIG51bWJlcik7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0eXBlYWhlYWRDb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxoczogSVtcInRleHRcIl0sIHJoczogeyB0ZXh0OiBJW1widGV4dFwiXTsgdW5zb3J0ZWRJbmRleDogbnVtYmVyOyB9KSA9PiB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJocy50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBEdXJpbmcgdHlwZWFoZWFkLCBhbGwgc3RyaW5ncyBsb25nZXIgdGhhbiBvdXJzIHNob3VsZCBiZSB0cnVuY2F0ZWRcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhleSdyZSBhbGwgY29uc2lkZXJlZCBlcXVhbGx5IGJ5IHRoYXQgcG9pbnQuXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvclNoYXJlZChsaHMsIHJocy50ZXh0LnN1YnN0cmluZygwLCBsaHMubGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGxocyBhcyB1bmtub3duIGFzIG51bWJlcikgLSAocmhzIGFzIHVua25vd24gYXMgbnVtYmVyKTtcbiAgICB9KTtcblxuXG4gICAgY29uc3QgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM8Q2hpbGRFbGVtZW50PiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50Pj4oeyAuLi5wcm9wcyB9OiBQKTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQsIFA+IHtcblxuICAgICAgICBjb25zdCBvbkNvbXBvc2l0aW9uU3RhcnQgPSAoX2U6IENvbXBvc2l0aW9uRXZlbnQpID0+IHsgc2V0SW1lQWN0aXZlKHRydWUpIH07XG4gICAgICAgIGNvbnN0IG9uQ29tcG9zaXRpb25FbmQgPSAoZTogQ29tcG9zaXRpb25FdmVudCkgPT4ge1xuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoZS5kYXRhKTtcbiAgICAgICAgICAgIHNldEltZUFjdGl2ZShmYWxzZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgaW1lQWN0aXZlID0gZ2V0SW1lQWN0aXZlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGUua2V5O1xuXG4gICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCBieSB0eXBlYWhlYWQgKGkuZS4gYXNzdW1lIHRoaXMgaXMgYSBrZXlib2FyZCBzaG9ydGN1dClcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUgJiYgZS5rZXkgPT09IFwiQmFja3NwYWNlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgY2hhcmFjdGVyIGluIGEgd2F5IHRoYXQgZG9lc24ndCBzcGxpdCBVVEYtMTYgc3Vycm9nYXRlcy5cbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHQgPT4gdCA9PT0gbnVsbCA/IG51bGwgOiBbLi4udF0ucmV2ZXJzZSgpLnNsaWNlKDEpLnJldmVyc2UoKS5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBrZXkgcHJvcGVydHkgcmVwcmVzZW50cyB0aGUgdHlwZWQgY2hhcmFjdGVyIE9SIHRoZSBcIm5hbWVkIGtleSBhdHRyaWJ1dGVcIiBvZiB0aGUga2V5IHByZXNzZWQuXG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIGRlZmluaXRlIHdheSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlLCBidXQgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3Nlc1xuICAgICAgICAgICAgLy8gdGhlcmUgYXJlIG5vIG9uZS1jaGFyYWN0ZXIgbmFtZXMsIGFuZCB0aGVyZSBhcmUgbm8gbm9uLUFTQ0lJLWFscGhhIG5hbWVzLlxuICAgICAgICAgICAgLy8gVGh1cywgYW55IG9uZS1jaGFyYWN0ZXIgb3Igbm9uLUFTQ0lJIHZhbHVlIGZvciBga2V5YCBpcyAqYWxtb3N0IGNlcnRhaW5seSogYSB0eXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBjb25zdCBpc0NoYXJhY3RlcktleSA9IChrZXkubGVuZ3RoID09PSAxIHx8ICEvXltBLVphLXpdLy50ZXN0KGtleSkpO1xuICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVyS2V5KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwiIFwiICYmIChnZXRDdXJyZW50VHlwZWFoZWFkKCkgPz8gXCJcIikudHJpbSgpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGJlY2F1c2UgYSBzcGFjZWJhciBjYW4ndCBldmVyIFxuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWF0ZSBhIHR5cGVhaGVhZCwgb25seSBjb250aW51ZSBvbmUuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gKFNwZWNpZmljYWxseSwgbGV0IHRoZSBldmVudCBjb250aW51ZSBwcm9wYWdhdGlvbiBpbiB0aGlzIGNhc2UpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBXb24ndCBiZSB0cnVlIGZvciB0aGUgZmlyc3Qga2V5ZG93blxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWZvcmUgdXNlTGF5b3V0RWZmZWN0IGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhY3R1YWxseSBhcHBseSB0aGUgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1lQWN0aXZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50PigpKHsgb25LZXlEb3duLCBvbkNvbXBvc2l0aW9uU3RhcnQsIG9uQ29tcG9zaXRpb25FbmQsIH0sIHByb3BzKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBIYW5kbGUgY2hhbmdlcyBpbiB0eXBlYWhlYWQgdGhhdCBjYXVzZSBjaGFuZ2VzIHRvIHRoZSB0YWJiYWJsZSBpbmRleFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50VHlwZWFoZWFkICYmIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGgpIHtcblxuXG5cbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZFR5cGVhaGVhZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgdHlwZWFoZWFkQ29tcGFyYXRvcik7XG5cbiAgICAgICAgICAgIGlmIChzb3J0ZWRUeXBlYWhlYWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBoYXMgdHlwZWQgYW4gZW50cnkgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgLy8gKG9yIG1vcmUgc3BlY2lmaWNhbGx5IFwiZm9yIHdoaWNoIHRoZXJlIGlzIG5vIGVudHJ5IHRoYXQgc3RhcnRzIHdpdGggdGhhdCBpbnB1dFwiKVxuICAgICAgICAgICAgICAgIHNldEludmFsaWRUeXBlYWhlYWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICBXZSBrbm93IHJvdWdobHkgd2hlcmUsIGluIHRoZSBzb3J0ZWQgYXJyYXkgb2Ygc3RyaW5ncywgb3VyIG5leHQgdHlwZWFoZWFkIGxvY2F0aW9uIGlzLlxuICAgICAgICAgICAgICAgICAgQnV0IHJvdWdobHkgaXNuJ3QgZ29vZCBlbm91Z2ggaWYgdGhlcmUgYXJlIG11bHRpcGxlIG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgICBUbyBjb252ZXJ0IG91ciBzb3J0ZWQgaW5kZXggdG8gdGhlIHVuc29ydGVkIGluZGV4IHdlIG5lZWQsIHdlIGhhdmUgdG8gZmluZCB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHVzICphbmQqIChpZiBhbnkgc3VjaCBleGlzdCkgaXMgKmFmdGVyKiBvdXIgY3VycmVudCBzZWxlY3Rpb24uXG5cbiAgICAgICAgICAgICAgICAgIEluIG90aGVyIHdvcmRzLCB0aGUgb25seSB3YXkgdHlwZWFoZWFkIG1vdmVzIGJhY2t3YXJkcyByZWxhdGl2ZSB0byBvdXIgY3VycmVudFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gaXMgaWYgdGhlIG9ubHkgb3RoZXIgb3B0aW9uIGlzIGJlaGluZCB1cy5cblxuICAgICAgICAgICAgICAgICAgSXQncyBub3Qgc3BlY2lmaWVkIGluIFdBSS1BUklBIHdoYXQgdG8gZG8gaW4gdGhhdCBjYXNlLiAgSSBzdXBwb3NlIHdyYXAgYmFjayB0byB0aGUgc3RhcnQ/XG4gICAgICAgICAgICAgICAgICBUaG91Z2ggdGhlcmUncyBhbHNvIGEgY2FzZSBmb3IganVzdCBnb2luZyB1cHdhcmRzIHRvIHRoZSBuZWFyZXN0IHRvIHByZXZlbnQganVtcGluZXNzLlxuICAgICAgICAgICAgICAgICAgQnV0IGlmIHlvdSdyZSBhbHJlYWR5IGRvaW5nIHR5cGVhaGVhZCBvbiBhbiB1bnNvcnRlZCBsaXN0LCBsaWtlLCBqdW1waW5lc3MgY2FuJ3QgYmUgYXZvaWRlZC5cbiAgICAgICAgICAgICAgICAgIEkgZHVubm8uIEdvaW5nIGJhY2sgdG8gdGhlIHN0YXJ0IGlzIHRoZSBzaW1wbGlzdCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgICAgIEJhc2ljYWxseSB3aGF0IHRoaXMgZG9lczogU3RhcnRpbmcgZnJvbSB3aGVyZSB3ZSBmb3VuZCBvdXJzZWx2ZXMgYWZ0ZXIgb3VyIGJpbmFyeSBzZWFyY2gsXG4gICAgICAgICAgICAgICAgICBzY2FuIGJhY2t3YXJkcyBhbmQgZm9yd2FyZHMgdGhyb3VnaCBhbGwgYWRqYWNlbnQgZW50cmllcyB0aGF0IGFsc28gY29tcGFyZSBlcXVhbGx5IHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgIHdlIGNhbiBmaW5kIHRoZSBvbmUgd2hvc2UgYHVuc29ydGVkSW5kZXhgIGlzIHRoZSBsb3dlc3QgYW1vbmdzdCBhbGwgb3RoZXIgZXF1YWwgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgKGFuZCBhbHNvIHRoZSBsb3dlc3QgYHVuc29ydGVkSW5kZXhgIHlhZGRhIHlhZGRhIGV4Y2VwdCB0aGF0IGl0IGNvbWVzIGFmdGVyIHVzKS5cblxuICAgICAgICAgICAgICAgICAgVE9ETzogVGhlIGJpbmFyeSBzZWFyY2ggc3RhcnRzIHRoaXMgb2ZmIHdpdGggYSBzb2xpZCBPKGxvZyBuKSwgYnV0IG9uZS1jaGFyYWN0ZXIgXG4gICAgICAgICAgICAgICAgICBzZWFyY2hlcyBhcmUsIHRoYW5rcyB0byBwaWdlb25ob2xlIHByaW5jaXBhbCwgZXZlbnR1YWxseSBndWFyYW50ZWVkIHRvIGJlY29tZSBcbiAgICAgICAgICAgICAgICAgIE8obipsb2cgbikuIFRoaXMgaXMgYW5ub3lpbmcgYnV0IHByb2JhYmx5IG5vdCBlYXNpbHkgc29sdmFibGU/IFRoZXJlIGNvdWxkIGJlIGFuIFxuICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uIGZvciBvbmUtY2hhcmFjdGVyIHN0cmluZ3MsIGJ1dCB0aGF0J3MganVzdCBraWNraW5nIHRoZSBjYW4gZG93biBcbiAgICAgICAgICAgICAgICAgIHRoZSByb2FkLiBNYXliZSBvbmUgb3IgdHdvIGNoYXJhY3RlcnMgd291bGQgYmUgZ29vZCBlbm91Z2ggdGhvdWdoLlxuICAgICAgICAgICAgICAgICovXG5cblxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGFyZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGNhbmRpZGF0ZXMnIHBvc2l0aW9ucyBpbiBib3RoIG91ciBzb3J0ZWQgYXJyYXkgYW5kIHRoZSB1bnNvcnRlZCBET00uXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFVuc29ydGVkSW5kZXhBbGw6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RTb3J0ZWRJbmRleEFsbCA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgdHdvIGFyZSBvbmx5IHNldCBmb3IgZWxlbWVudHMgdGhhdCBhcmUgYWhlYWQgb2YgdXMsIGJ1dCB0aGUgcHJpbmNpcGxlJ3MgdGhlIHNhbWUgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0U29ydGVkSW5kZXhOZXh0ID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVCZXN0Rml0ID0gKHU6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9PSBudWxsIHx8IHUgPCBsb3dlc3RVbnNvcnRlZEluZGV4QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RVbnNvcnRlZEluZGV4QWxsID0gdTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNvcnRlZEluZGV4QWxsID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0KSAmJiB1ID4gKGdldEluZGV4KCkgPz8gLUluZmluaXR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U29ydGVkSW5kZXhOZXh0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBpID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiB0eXBlYWhlYWRDb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGggJiYgdHlwZWFoZWFkQ29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQmVzdEZpdChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleE5leHRdLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleEFsbF0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbY3VycmVudFR5cGVhaGVhZF0pO1xuXG4gICAgY29uc3QgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkID0gdXNlQ2FsbGJhY2s8VXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgST4+KCh7IHRleHQsIC4uLmkgfTogSSkgPT4ge1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGV4dCkge1xuXG4gICAgICAgICAgICAgICAgLy8gRmluZCB3aGVyZSB0byBpbnNlcnQgdGhpcyBpdGVtLlxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgYWxsIGluZGV4IHZhbHVlcyBzaG91bGQgYmUgdW5pcXVlLCB0aGUgcmV0dXJuZWQgc29ydGVkSW5kZXhcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYWx3YXlzIHJlZmVyIHRvIGEgbmV3IGxvY2F0aW9uIChpLmUuIGJlIG5lZ2F0aXZlKSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIHRleHQsIGluc2VydGluZ0NvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbc29ydGVkSW5kZXhdLnRleHQgPT0gdGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKC1zb3J0ZWRJbmRleCAtIDEsIDAsIHsgdGV4dCwgdW5zb3J0ZWRJbmRleDogaS5pbmRleCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2Uoc29ydGVkSW5kZXgsIDAsIHsgdGV4dCwgdW5zb3J0ZWRJbmRleDogaS5pbmRleCB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVubW91bnRpbmcsIGZpbmQgd2hlcmUgd2Ugd2VyZSBhbmQgcmVtb3ZlIG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWdhaW4sIHdlIHNob3VsZCBhbHdheXMgZmluZCBvdXJzZWx2ZXMgYmVjYXVzZSB0aGVyZSBzaG91bGQgYmUgbm8gZHVwbGljYXRlIHZhbHVlcyBpZiBlYWNoIGluZGV4IGlzIHVuaXF1ZS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCB0ZXh0LCBpbnNlcnRpbmdDb21wYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoc29ydGVkSW5kZXggPCAwIHx8IHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtzb3J0ZWRJbmRleF0udGV4dCA9PSB0ZXh0KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGVkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZShzb3J0ZWRJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt0ZXh0XSk7XG5cbiAgICAgICAgcmV0dXJuIHt9XG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyxcblxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxuICAgICAgICBpbnZhbGlkVHlwZWFoZWFkLFxuICAgIH1cbn1cblxuXG4vKipcbiAqIFlvdXIgdXN1YWwgYmluYXJ5IHNlYXJjaCBpbXBsZW1lbnRhdGlvbi5cbiAqIFxuICogSXQncyB1c2VkIGhlcmUgdG8gcXVpY2tseSBmaW5kIGEgZ29vZCBzcG90IHRvIHN0YXJ0IHNlYXJjaGluZyBmb3Igb3VyIG5leHQgdHlwZWFoZWFkIGNhbmRpZGF0ZS5cbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoIHRocm91Z2hcbiAqIEBwYXJhbSB3YW50ZWQgVGhlIHZhbHVlIHlvdSdkIGxpa2UgdG8gZmluZFxuICogQHBhcmFtIGNvbXBhcmF0b3IgQ29tcGFyZXMgYHdhbnRlZGAgd2l0aCB0aGUgY3VycmVudCB2YWx1ZSBpbiBgYXJyYXlgXG4gKiBAcmV0dXJucyBBIG5vbi1uZWdhdGl2ZSB2YWx1ZSBpZiBgd2FudGVkYCB3YXMgZm91bmQsIGFuZCBhIG5lZ2F0aXZlIG51bWJlciBpZiBub3QuIFxuICogVGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgbnVtYmVyLCBtaW51cyBvbmUsIGlzIHdoZXJlIGB3YW50ZWRgICp3b3VsZCogYmUgZm91bmQgaWYgaXQgKndhcyogaW4gYGFycmF5YFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoPFQsIFUsIEYgZXh0ZW5kcyAobGhzOiBVLCByaHM6IFQpID0+IG51bWJlcj4oYXJyYXk6IFRbXSwgd2FudGVkOiBVLCBjb21wYXJhdG9yOiBGKTogbnVtYmVyIHtcbiAgICBsZXQgZmlyc3RJbmRleCA9IDA7XG4gICAgbGV0IGxhc3RJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGZpcnN0SW5kZXggPD0gbGFzdEluZGV4KSB7XG4gICAgICAgIGNvbnN0IHRlc3RJbmRleCA9IChsYXN0SW5kZXggKyBmaXJzdEluZGV4KSA+PiAxO1xuICAgICAgICBjb25zdCBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyYXRvcih3YW50ZWQsIGFycmF5W3Rlc3RJbmRleF0pO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICAgICAgZmlyc3RJbmRleCA9IHRlc3RJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IHRlc3RJbmRleCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC1maXJzdEluZGV4IC0gMTtcbn1cbiIsImltcG9ydCB7IElucHV0cywgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVmZmVjdENoYW5nZSB9IGZyb20gXCIuL3VzZS1lZmZlY3RcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UHJvcHMgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5cblxuLy9leHBvcnQgY29uc3QgSW5kZXhQZW5kaW5nID0gU3ltYm9sKFwiaW5kZXgtcGVuZGluZ1wiKTtcblxuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRJbmZvPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmc+IHtcblxuICAgIC8qKlxuICAgICAqIEEga2V5IHVzZWQgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhlIGNoaWxkIGFtb25nc3QgaXRzIHNpYmxpbmdzLlxuICAgICAqIFRoZSBpbmRpY2VzIGRvIG5vdCAqbmVjZXNzYXJpbHkqIG5lZWQgdG8gYmUgc2VxdWVudGlhbCAoZXNwZWNpYWxseVxuICAgICAqIGluIHRoZSBjYXNlIG9mIHN0cmluZyBpbmRpY2VzKSwgYnV0IG90aGVyIGhvb2tzIHRoYXQgZGVwZW5kXG4gICAgICogb24gYHVzZU1hbmFnZWRDaGlsZGAgbWF5IHNwZWNpZmljYWxseSB3YW50IHNlcXVlbnRpYWxseS1vcmRlcmVkXG4gICAgICogaW5kaWNlcyAoZS5nLiBgdXNlTGluZWFyTmF2aWdhdGlvbmApXG4gICAgICovXG4gICAgaW5kZXg6IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcbiAgICBnZXRFbGVtZW50KCk6IEUgfCBudWxsO1xuICAgIHVzZU1hbmFnZWRDaGlsZFByb3BzOiBVc2VSZWZFbGVtZW50UHJvcHM8RT47XG59XG5cbmV4cG9ydCB0eXBlIFVzZWRNYW5hZ2VkQ2hpbGQ8SSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4gPSA8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PihpbmZvOiBJKSA9PiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPEU+O1xuLy9leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGRQcm9wczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gPFAgZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRQcm9wc1BhcmFtZXRlcnM8RT4+KHByb3BzOiBQKSA9PiBVc2VNYW5hZ2VkQ2hpbGRQcm9wc1JldHVyblR5cGU8RSwgUD47XG4vL2V4cG9ydCB0eXBlIFVzZU1hbmFnZWRDaGlsZFByb3BzUGFyYW1ldGVyczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gVXNlUmVmRWxlbWVudFByb3BzUGFyYW1ldGVyczxFPjtcbi8vZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkUHJvcHNSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgUCBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZFByb3BzUGFyYW1ldGVyczxFPj4gPSB2b2lkO1xuXG50eXBlIEluZm9Ub0tleTxJIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiA9IElbXCJpbmRleFwiXTtcbnR5cGUgTWFuYWdlZENoaWxkcmVuPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEkgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPFQ+PiA9IFQgZXh0ZW5kcyBzdHJpbmcgPyBSZWNvcmQ8c3RyaW5nLCBJPiA6IElbXTtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZE1hbmFnZXJSZXR1cm5UeXBlPEkgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvKipcbiAgICAgKiBBIGhvb2sgdGhhdCBtdXN0IGJlIGNhbGxlZCBieSBldmVyeSBjaGlsZCBjb21wb25lbnQgdGhhdFxuICAgICAqIGlzIHRvIGJlIG1hbmFnZWQgYnkgdGhpcyBvbmUuIFRoZSBhcmd1bWVudCB0byB0aGUgaG9va1xuICAgICAqIGlzIGp1c3QgdGhlIGJhZyBvZiBwcm9wZXJ0aWVzIHRvIHBhc3MgdG8gdGhlIHBhcmVudCxcbiAgICAgKiBpbmNsdWRpbmcgdGhlIGNoaWxkJ3MgaW5kZXguXG4gICAgICovXG4gICAgdXNlTWFuYWdlZENoaWxkOiBVc2VkTWFuYWdlZENoaWxkPEk+O1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgYWxsIGN1cnJlbnRseSBtYW5hZ2VkIGNoaWxkcmVuLFxuICAgICAqIG9yIHJhdGhlciB0aGUgaW5mb3JtYXRpb24gdGhleSBwcm92aWRlZFxuICAgICAqIHRoZSBwYXJlbnQuXG4gICAgICogXG4gICAgICogVGhlIGluZGV4IHRoYXQgdGhlIGNoaWxkIHByb3ZpZGVkIGlzIHdoZXJlIGl0IGlzIGxvY2F0ZWQgaW4gdGhpcyBzdHJ1Y3R1cmUuIEZvciBudW1lcmljIElEcywgdGhpcyBpcyBqdXN0IGFuIGFycmF5LCB3aXRoIGVhY2ggb2JqZWN0IGF0IHRoYXQgbG9jYXRpb24gaW4gdGhlIGFycmF5LlxuICAgICAqIFxuICAgICAqIFRoaXMgaXMgZ2VuZXJhbGx5IGp1c3QgYW4gYXJyYXksIHRob3VnaCBpdCBjYW4gYmUgYSBSZWNvcmQgaW5zdGVhZCBpZiBzdHJpbmcgSURzIGFyZSB1c2VkIGluc3RlYWQgb2YgbnVtZXJpYyBJRHMuXG4gICAgICovXG4gICAgbWFuYWdlZENoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48SW5mb1RvS2V5PEk+LCBJPjtcblxuICAgIC8qKlxuICAgICAqIFNlcGFyYXRlIGZyb20gYG1hbmFnZWRDaGlsZHJlbmAsIHRoaXMga2VlcHMgdHJhY2sgb2YgYWxsIG1vdW50ZWQgY2hpbGRyZW4gaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBtb3VudGVkLlxuICAgICAqIGBnZXRNb3VudEluZGV4YCB3aWxsIHJldHVybiB0aGUgaW5kZXggaW50byB0aGlzIGFycmF5IGdpdmVuIHRoZSBjaGlsZCdzIGluZGV4LlxuICAgICAqICBcbiAgICAgKiBXaGVuIHVubW91bnRlZCwgaXRzIGVudHJ5IGJlY29tZXMgbnVsbC5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGFuZCBgbWFuYWdlZENoaWxkcmVuYCB3aWxsIGFsd2F5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnRzLCBidXQgbGlrZWx5IGluIGEgZGlmZmVyZW50IG9yZGVyIGFuZCBpbiBkaWZmZXJlbnQgbG9jYXRpb25zLlxuICAgICAqL1xuICAgIG1vdW50ZWRDaGlsZHJlbjogKG51bGwgfCBJKVtdO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBudW1iZXIgb2YgY2hpbGRyZW4gYmVpbmcgbWFuYWdlZCBcbiAgICAgKiAoc3BlY2lmaWNhbGx5IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBoYXZlIG1vdW50ZWQgKmFuZCogYXJlIHN0aWxsIG1vdW50ZWQuKS5cbiAgICAgKiBcbiAgICAgKiBGb3IgbW9zdCBhcnJheS1saWtlIGNoaWxkIHN0cnVjdHVyZXMgd2l0aCBudW1lcmljIElEcywgdGhpcyB3aWxsIG1hdGNoIHVwIHdpdGggYG1hbmFnZWRDaGlsZHJlbi5sZW5ndGhgLlxuICAgICAqL1xuICAgIGNoaWxkQ291bnQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBoYXZlIGJlZW4gbW91bnRlZCwgcmVnYXJkbGVzcyBvZiBpZiB0aGV5J3ZlIHNpbmNlIHVubW91bnRlZCB0aGVtc2VsdmVzLlxuICAgICAqL1xuICAgIHRvdGFsQ2hpbGRyZW5Nb3VudGVkOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgaGF2ZSB1bm1vdW50ZWQgLS0gdGhpcyBpcyAwIHVudGlsIGF0IGxlYXN0IHNvbWUgdGltZSBhZnRlciBgdG90YWxDaGlsZHJlbk1vdW50ZWRgIGlzID4wLlxuICAgICAqL1xuICAgIHRvdGFsQ2hpbGRyZW5Vbm91bnRlZDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbiB3aGF0IHBvc2l0aW9uIHRoaXMgY2hpbGQgbW91bnRlZC4gSWYgdGhpcyBpcyB0aGUgbW9zdCByZWNlbnRseSBtb3VudGVkIGNoaWxkLCBpdCB3aWxsIHJldHVybiBhIHZhbHVlIGVxdWFsIHRvIGB0b3RhbENoaWxkcmVuTW91bnRlZGAgLSAxLlxuICAgICAqIFxuICAgICAqICoqT24gdGhlIGNoaWxkIHNpZGUsIGNhbm5vdCBiZSB1c2VkIGluc2lkZSB1c2VMYXlvdXRFZmZlY3QqKiAoT24gdGhlIHBhcmVudCBzaWRlIGl0J3MgZmluZSBhdCBhbnkgcG9pbnQpLiAgSWYgbXVsdGlwbGUgY2hpbGRyZW4gYXJlIG1vdW50ZWQgb24gdGhlIHNhbWUgZnJhbWUsIHRoZWlyIG1vdW50IGluZGljZXMgcmVsYXRpdmUgdG8gZWFjaCBvdGhlciB3aWxsIGJlIGFyYml0cmFyeSBidXQgY29uc2lzdGVudCAoYXNzdW1pbmcgUHJlYWN0J3MgaXMpLlxuICAgICAqL1xuICAgIGdldE1vdW50SW5kZXgoaW5kZXg6IEluZm9Ub0tleTxJPik6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoZSBFbGVtZW50IHRoYXQgdGhlIGNoaWxkIG1vdW50cyBhcywgcmV0dXJucyBpdHMgYGluZGV4YCBwcm9wLlxuICAgICAqL1xuICAgIGluZGljZXNCeUVsZW1lbnQ6IE1hcDxFdmVudFRhcmdldCwgSW5mb1RvS2V5PEk+PlxuXG4gICAgLyoqXG4gICAgICogQSBzZXQgY29udGFpbmluZyBldmVyeSBpbmRleCB0aGF0IGhhcyB1bm1vdW50ZWQgYnV0IG5vdCBldmVyIHJlLW1vdW50ZWQgaXRzZWxmLlxuICAgICAqIFxuICAgICAqIEluIGEgbnVtZXJpYywgbGluZWFyIGxpc3QsIHRoaXMgd291bGQgcmVwcmVzZW50IGVpdGhlciBob2xlcyBpbiB0aGUgbGlzdCwgb3Igc3BhY2VzIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICovXG4gICAgZGVsZXRlZEluZGljZXM6IFNldDxJbmZvVG9LZXk8ST4+O1xufVxuXG4vKipcbiAqIEFsbG93cyBhIHBhcmVudCBjb21wb25lbnQgdG8gYWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IGNlcnRhaW5cbiAqIGNoaWxkIGNvbXBvbmVudHMgb25jZSB0aGV5IGhhdmUgcmVuZGVyZWQuXG4gKiBcbiAqIFRoaXMgaG9vayBpcyBzbGlnaHRseSBtb3JlIGNvbXBsaWNhdGVkIGluIHRoYXQgaXQgcmV0dXJucyBib3RoIGFcbiAqIHByb3AtbW9kaWZ5aW5nIGhvb2ssIGJ1dCBhbHNvIGEgaG9vayB0aGF0IGVhY2ggY2hpbGQgd2lsbCBuZWVkXG4gKiB0byB1c2U6IGB1c2VNYW5hZ2VkQ2hpbGRgLiAgSXQncyBzdGFibGUgYWNyb3NzIHJlbmRlcnMsIHNvIGp1c3QgXG4gKiB0b3NzIGl0IGludG8gYSBgQ29udGV4dGAgc28gdGhlIGNoaWxkcmVuIGNhbiBoYXZlIGFjY2VzcyB0byBpdC5cbiAqIFRoaXMgZnVuY3Rpb24gcmVnaXN0ZXJzIHRoZSBjaGlsZCB3aXRoIHRoZSBwYXJlbnQgYW5kIHByb3ZpZGVzXG4gKiBpdCB3aXRoIGFueSByZXF1ZXN0ZWQgaW5mb3JtYXRpb24sIGJ1dCBkb2Vzbid0IGRvIGFueXRoaW5nIGVsc2VcbiAqIHVudGlsIGl0IHVubW91bnRzIGFuZCByZXRyYWN0cyB0aGF0IGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hpbGRNYW5hZ2VyPEkgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+KCk6IFVzZUNoaWxkTWFuYWdlclJldHVyblR5cGU8ST4ge1xuICAgIHR5cGUgSyA9IEluZm9Ub0tleTxJPlxuXG4gICAgLy8gVGhpcyBpcyBibGluZGx5IHVwZGF0ZWQgYW55IHRpbWUgYSBjaGlsZCBtb3VudHMgb3IgdW5tb3VudHMgaXRzZWxmLlxuICAgIC8vIFVzZWQgdG8gbWFrZSBzdXJlIHRoYXQgYW55IHRpbWUgdGhlIGFycmF5IG9mIG1hbmFnZWQgY2hpbGRyZW4gdXBkYXRlcyxcbiAgICAvLyB3ZSBhbHNvIHJlLXJlbmRlci5cbiAgICBjb25zdCBbX2NoaWxkVXBkYXRlSW5kZXgsIHNldENoaWxkVXBkYXRlSW5kZXhdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW3RvdGFsQ2hpbGRyZW5Nb3VudGVkLCBzZXRUb3RhbENoaWxkcmVuTW91bnRlZCwgZ2V0VG90YWxDaGlsZHJlbk1vdW50ZWRdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW3RvdGFsQ2hpbGRyZW5Vbm91bnRlZCwgc2V0VG90YWxDaGlsZHJlblVub3VudGVkLCBfZ2V0VG90YWxDaGlsZHJlblVub3VudGVkXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IGNoaWxkcmVuQ3VycmVudGx5TW91bnRlZCA9IHRvdGFsQ2hpbGRyZW5Nb3VudGVkIC0gdG90YWxDaGlsZHJlblVub3VudGVkO1xuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbiA9IHVzZVJlZjxNYW5hZ2VkQ2hpbGRyZW48SW5mb1RvS2V5PEk+LCBJPj4oW10gYXMgYW55IGFzIE1hbmFnZWRDaGlsZHJlbjxJbmZvVG9LZXk8ST4sIEk+IC8qKiBUT0RPOiBBbnkgcHJvYmxlbXMgY2F1c2VkIGJ5IHVzaW5nIGFuIGFycmF5IHdoZW4gaXQgc2hvdWxkIGJlIGFuIG9iamVjdD8gKi8pO1xuICAgIGNvbnN0IG1vdW50ZWRDaGlsZHJlbiA9IHVzZVJlZjwobnVsbCB8IEkpW10+KFtdKTtcbiAgICBjb25zdCBtb3VudE9yZGVyID0gdXNlUmVmPE1hcDxLLCBudW1iZXI+PihuZXcgTWFwKCkpO1xuICAgIGNvbnN0IGluZGljZXNCeUVsZW1lbnQgPSB1c2VSZWY8TWFwPEV2ZW50VGFyZ2V0LCBLPj4obmV3IE1hcCgpKTtcbiAgICBjb25zdCBkZWxldGVkSW5kaWNlcyA9IHVzZVJlZjxTZXQ8Sz4+KG5ldyBTZXQ8Sz4oKSk7XG5cbiAgICAvLyBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgaW5kaWNlcyB0aGF0IGhhdmUgXCJvdmVyLW1vdW50ZWRcIiBhbmQgYnkgaG93IG11Y2guXG4gICAgLy8gV2UgbmVlZCB0aGlzIHNvIHRoYXQgd2UgZG9uJ3QgZXJhc2Ugc2F2ZWQgaW5mb3JtYXRpb24gd2hlbiBhIGNvbXBvbmVudFxuICAgIC8vIFwib3Zlcm1vdW50c1wiIG92ZXIgYW5vdGhlciB3aGljaCB0aGVuLCBjb3JyZWN0bHksIHN3aXRjaGVzICppdHNlbGYqIHRvIHNvbWV0aGluZyBlbHNlLlxuICAgIC8vIEluIGdlbmVyYWwsIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIHdoZW4gY29tcG9uZW50cyBhcmUgc3dhcHBpbmcgYmV0d2VlbiBpbmRpY2VzLlxuICAgIC8vIEJ5IHRoZSB0aW1lIHRoZXkncmUgZG9uZSwgdGhpcyBtYXAgc2hvdWxkIGJlIGFsbCAwcyBhZ2FpbiwgYXQgd2hpY2ggcG9pbnRcbiAgICAvLyBpdCdzIG9rYXkgdG8gYWN0dWFsbHkgcnVuIHRoZSB1bm1vdW50IGNvZGUuXG4gICAgLy8gXG4gICAgLy8gVE9ETzogdGhyb3cgYSBjb25zb2xlLmFzc2VydCBzb21ld2hlcmUgdG8gbWFrZSB1cCBmb3IgdGhlIGxvc3QgXG4gICAgLy8gXCJhcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gb3ZlcndyaXRlIHRoaXMgY2hpbGQncyBpbmRleCFcIiBhc3NlcnRpb24uXG4gICAgLy8gTmFtZWx5LCBpcyB0aGlzIG1hcCBhbGwgMHMgd2hlbiB0aGUgcGFyZW50IGVsZW1lbnQgcmUtcmVuZGVycz8gXG4gICAgLy8gUHJvYmFibHkgbm90IGJlY2F1c2Ugb2Ygc2V0Q2hpbGRVcGRhdGVJbmRleFxuICAgIGNvbnN0IG92ZXJtb3VudENvdW50ID0gdXNlUmVmKG5ldyBNYXA8SywgbnVtYmVyPigpKTtcblxuICAgIGNvbnN0IGdldE1vdW50SW5kZXggPSB1c2VDYWxsYmFjaygoaW5kZXg6IEspID0+IHsgcmV0dXJuIG1vdW50T3JkZXIuY3VycmVudC5nZXQoaW5kZXgpITsgfSwgW10pO1xuXG4gICAgY29uc3QgdXNlTWFuYWdlZENoaWxkOiBVc2VkTWFuYWdlZENoaWxkPEk+ID0gdXNlQ2FsbGJhY2soPENoaWxkVHlwZSBleHRlbmRzIEV2ZW50VGFyZ2V0PihpbmZvOiBJKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PENoaWxkVHlwZT4oeyBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlbGVtZW50OiBDaGlsZFR5cGUgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGluZGljZXNCeUVsZW1lbnQuY3VycmVudC5zZXQoZWxlbWVudCwgaW5mby5pbmRleCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlZEluZGljZXMuY3VycmVudC5kZWxldGUoaW5mby5pbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hbmFnZWRDaGlsZHJlbi5jdXJyZW50W2luZm8uaW5kZXggYXMga2V5b2YgTWFuYWdlZENoaWxkcmVuPEluZm9Ub0tleTxJPiwgST5dICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvdmVybW91bnRDb3VudC5jdXJyZW50LnNldChpbmZvLmluZGV4LCAob3Zlcm1vdW50Q291bnQuY3VycmVudC5nZXQoaW5mby5pbmRleCkgPz8gMCkgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRDaGlsZFVwZGF0ZUluZGV4KGMgPT4gKytjKTtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4uY3VycmVudFtpbmZvLmluZGV4IGFzIGtleW9mIE1hbmFnZWRDaGlsZHJlbjxJbmZvVG9LZXk8ST4sIEk+XSA9IHsgLi4uaW5mbyB9IGFzIGFueTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldENoaWxkVXBkYXRlSW5kZXgoYyA9PiArK2MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKG92ZXJtb3VudENvdW50LmN1cnJlbnQuZ2V0KGluZm8uaW5kZXgpID8/IDApID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3Zlcm1vdW50Q291bnQuY3VycmVudC5zZXQoaW5mby5pbmRleCwgKG92ZXJtb3VudENvdW50LmN1cnJlbnQuZ2V0KGluZm8uaW5kZXgpID8/IDApIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuLmN1cnJlbnRbaW5mby5pbmRleCBhcyBrZXlvZiBNYW5hZ2VkQ2hpbGRyZW48SW5mb1RvS2V5PEk+LCBJPl07XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVkSW5kaWNlcy5jdXJyZW50LmFkZChpbmZvLmluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmZvLmluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG1hbmFnZWRDaGlsZHJlbi5jdXJyZW50Lmxlbmd0aCAmJiAobWFuYWdlZENoaWxkcmVuLmN1cnJlbnQgYXMgSVtdKVsobWFuYWdlZENoaWxkcmVuLmN1cnJlbnQgYXMgSVtdKS5sZW5ndGggLSAxXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWFuYWdlZENoaWxkcmVuLmN1cnJlbnQgYXMgSVtdKS5sZW5ndGggLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXNCeUVsZW1lbnQuY3VycmVudC5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKSB9KTtcblxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBnZXRUb3RhbENoaWxkcmVuTW91bnRlZCgpO1xuICAgICAgICAgICAgbW91bnRPcmRlci5jdXJyZW50LnNldChpbmZvLmluZGV4LCBpbmRleCk7XG4gICAgICAgICAgICBtb3VudGVkQ2hpbGRyZW4uY3VycmVudFtpbmRleF0gPSBpbmZvO1xuICAgICAgICAgICAgc2V0VG90YWxDaGlsZHJlbk1vdW50ZWQodCA9PiArK3QpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBtb3VudE9yZGVyLmN1cnJlbnQuZGVsZXRlKGluZm8uaW5kZXgpO1xuICAgICAgICAgICAgICAgIG1vdW50ZWRDaGlsZHJlbi5jdXJyZW50W2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2V0VG90YWxDaGlsZHJlblVub3VudGVkKHQgPT4gKyt0KTtcblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgW2luZm8uaW5kZXhdKTtcblxuICAgICAgICAvLyBBbnkgdGltZSBvdXIgY2hpbGQgcHJvcHMgY2hhbmdlLCBtYWtlIHRoYXQgaW5mb3JtYXRpb24gYXZhaWxhYmxlIGdlbmVyYWxseS5cbiAgICAgICAgLy8gKkRvbid0IHJlLXJlbmRlciosIG90aGVyd2lzZSB3ZSdkIGJlIHN0dWNrIGluIGFuXG4gICAgICAgIC8vIGluZmluaXRlIGxvb3AgZXZlcnkgdGltZSBhbiBhbm9ueW1vdXMgZnVuY3Rpb24gaXMgcGFzc2VkLlxuICAgICAgICAvLyBJdCBjb21lcyBpbiBmcm9tIHRoZSBwcm9wcyBzbyB0aGUgY2hpbGQgd2FzIGFscmVhZHkgdXBkYXRlZCBieSBpdCAtLVxuICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRoZSBwYXJlbnQgdG8gcmUtcmVuZGVyIGV2ZXJ5IHNpbmdsZSBjaGlsZCBhbnkgdGltZVxuICAgICAgICAvLyBcIm9uQ2xpY2tcIiB1cGRhdGVzIG9yIHdoYXRldmVyLiAgVGhlIHJlbGV2YW50IGNoaWxkIGFscmVhZHkga25vd3MsXG4gICAgICAgIC8vIGFuZCB0aGF0J3Mgd2hhdCBtYXR0ZXJzLlxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG1hbmFnZWRDaGlsZHJlbi5jdXJyZW50W2luZm8uaW5kZXggYXMga2V5b2YgTWFuYWdlZENoaWxkcmVuPEluZm9Ub0tleTxJPiwgST5dICE9IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4uY3VycmVudFtpbmZvLmluZGV4IGFzIGtleW9mIE1hbmFnZWRDaGlsZHJlbjxJbmZvVG9LZXk8ST4sIEk+XSA9IHsgLi4uaW5mbyB9IGFzIGFueTtcbiAgICAgICAgfSwgWy4uLk9iamVjdC5lbnRyaWVzKGluZm8pLmZsYXQoKV0pO1xuXG4gICAgICAgIHJldHVybiB7IGdldEVsZW1lbnQsIHVzZU1hbmFnZWRDaGlsZFByb3BzOiB1c2VSZWZFbGVtZW50UHJvcHMgfVxuICAgIH0sIFtdKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTWFuYWdlZENoaWxkLFxuICAgICAgICBjaGlsZENvdW50OiBjaGlsZHJlbkN1cnJlbnRseU1vdW50ZWQsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLmN1cnJlbnQsXG4gICAgICAgIG1vdW50ZWRDaGlsZHJlbjogbW91bnRlZENoaWxkcmVuLmN1cnJlbnQsXG4gICAgICAgIGluZGljZXNCeUVsZW1lbnQ6IGluZGljZXNCeUVsZW1lbnQuY3VycmVudCxcbiAgICAgICAgdG90YWxDaGlsZHJlbk1vdW50ZWQsXG4gICAgICAgIHRvdGFsQ2hpbGRyZW5Vbm91bnRlZCxcbiAgICAgICAgZ2V0TW91bnRJbmRleCxcbiAgICAgICAgZGVsZXRlZEluZGljZXM6IGRlbGV0ZWRJbmRpY2VzLmN1cnJlbnRcbiAgICB9XG59XG5cbnR5cGUgVUUgPSA8SSBleHRlbmRzIElucHV0cz4oZWZmZWN0OiAocHJldjogSSwgY2hhbmdlczogRWZmZWN0Q2hhbmdlPEksIG51bWJlcj5bXSkgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpLCBpbnB1dHM6IEkpID0+IHZvaWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRGbGFnUGFyYW1ldGVyczxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxUPj4ge1xuXG4gICAgLyoqXG4gICAgICogV2hpY2ggY2hpbGQgaW5kZXggcmVmZXJzIHRvIHRoZSBjdXJyZW50bHkgXCJhY3RpdmVcIiBjaGlsZC5cbiAgICAgKi9cbiAgICBhY3RpdmF0ZWRJbmRleDogVCB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICBtYW5hZ2VkQ2hpbGRyZW46IChudWxsIHwgdW5kZWZpbmVkIHwgSSlbXSB8IFJlY29yZDxzdHJpbmcsIG51bGwgfCB1bmRlZmluZWQgfCBJPjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcHJvdmlkZWQsIGlmIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleCBkb2Vzbid0IG1hcCBvbnRvIGFueVxuICAgICAqIHByb3ZpZGVkIGNoaWxkIChlaXRoZXIgYmVjYXVzZSBpdCdzIHRvbyBsYXJnZSBvciB0aGF0IGNoaWxkXG4gICAgICogZG9lc24ndCBleGlzdCksIHRoZSBjbG9zZXN0IGNoaWxkIHRvIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleFxuICAgICAqIHdpbGwgaGF2ZSBpdHMgZmxhZyBzZXQgaW5zdGVhZC5cbiAgICAgKiBcbiAgICAgKiBVc2Ugd2l0aCBjYXV0aW9uLCBhbmQgY29uc2lkZXIgaG93IGEgY2hpbGQgaGF2aW5nIGl0cyBmbGFnIHNldFxuICAgICAqIHdoaWxlIHRoZSBwYXJlbnQgdGhpbmtzIGl0IHNob3VsZG4ndCBiZSBjb3VsZCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gICAgY2xvc2VzdEZpdD86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIGNhbGxlZCBvbmNlIHdoZW4gYSBnaXZlbiBjaGlsZCBoYXMgYmVjb21lIHRoZSBcImFjdGl2ZVwiIGNoaWxkLlxuICAgICAqIEdlbmVyYWxseSwgdGhpcyB3aWxsIGxvb2sgbGlrZSBcbiAgICAgKiBgKGksIHNldCkgPT4gbWFuYWdlZENoaWxkcmVuW2ldLnNldEFjdGl2ZShzZXQpYCBcbiAgICAgKiBvciBzaW1pbGFyLlxuICAgICAqL1xuICAgIHNldENoaWxkRmxhZzogKGluZGV4OiBULCBzZXQ6IGJvb2xlYW4pID0+IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBvciBub3QgYSBjaGlsZCBuZWVkcyBpdHMgZmxhZyBzZXRcbiAgICAgKiBib3RoIGluIGdlbmVyYWwgY2FzZXMgYnV0IGFsc28gd2hlbiBhIGNoaWxkIHVubW91bnRzIGFuZCBhIG5ldyBjaGlsZFxuICAgICAqIG1vdW50cyBpbiBpdHMgcGxhY2Ugd2l0aCB0aGUgc2FtZSBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRDaGlsZEZsYWc6IChpbmRleDogVCkgPT4gYm9vbGVhbiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgY2hpbGQgZmxhZyBzZXR0aW5nIGhhcHBlbnMgZHVyaW5nIGB1c2VMYXlvdXRFZmZlY3RgLiAgSWYgeW91XG4gICAgICogd291bGQgcHJlZmVyIGl0IHRvIGhhcHBlbiBkdXJpbmcgYHVzZUVmZmVjdGAsIHBhc3MgdGhhdCBpbXBsZW1lbnRhdGlvbiBpblxuICAgICAqIGhlcmUuXG4gICAgICovXG4gICAgdXNlRWZmZWN0PzogKDxJIGV4dGVuZHMgSW5wdXRzPihlZmZlY3Q6IChwcmV2OiBJIHwgdW5kZWZpbmVkLCBjaGFuZ2VzOiBFZmZlY3RDaGFuZ2U8SSwgbnVtYmVyPltdKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSksIGlucHV0cz86IEkpID0+IHZvaWQgfCBVRSk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBsZXR0aW5nIGNoaWxkcmVuIGtub3cgd2hlbiB0aGV5IGFyZSBvciBhcmUgbm90IHRoZVxuICogY3VycmVudCBzZWxlY3RlZC9leHBhbmRlZC9mb2N1c2VkL3doYXRldmVyIGNoaWxkLlxuICogXG4gKiBBdXRvbWF0aWNhbGx5IGhhbmRsZXMgd2hlbiBjaGlsZHJlbiBhcmUgbW91bnRlZCAmIHVubW91bnRlZCBhbmQgc3VjaC5cbiAqIFxuICogV2hpbGUgaXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZXZlcnkgY2hpbGQgb24gbW91bnQsIGFmdGVyIHRoYXQgc2V0RmxhZyBcbiAqIGlzIGd1YXJhbnRlZWQgdG8gb25seSBiZSBjYWxsZWQgb25jZSBvbiBhY3RpdmF0aW9uIGFuZCBvbmNlIG9uIGRlYWN0aXZhdGlvbixcbiAqIHNvIGl0J3MgZ2VuZXJhbGx5IHNhZmUgdG8gcHV0IHNpZGUgZWZmZWN0cyBpbnNpZGUgaWYgbmVjZXNzYXJ5LiAgXG4gKiBJdCdzIGFsc28gc2FmZSB0byBtYWtlIGl0IG5vbi1zdGFibGUuXG4gKiBcbiAqIEBwYXJhbSBhY3RpdmF0ZWRJbmRleCBXaGF0IGluZGV4IHRoZSBjdXJyZW50IHNlbGVjdGVkIChldGMuKSBjaGlsZCBpc1xuICogQHBhcmFtIGxlbmd0aCBIb3cgbWFueSBjaGlsZHJlbiBleGlzdCAoYXMgbWFuYWdlZENoaWxkcmVuLmxlbmd0aClcbiAqIEBwYXJhbSBzZXRGbGFnIEEgZnVuY3Rpb24gdGhhdCBwcm9iYWJseSBsb29rcyBsaWtlIChpLCBmbGFnKSA9PiBtYW5hZ2VkQ2hpbGRyZW5baV0uc2V0QWN0aXZlKGZsYWcpXG4gKiBAcGFyYW0gdXNlRWZmZWN0IFdoaWNoIHZlcnNpb24gb2YgdXNlRWZmZWN0IHRvIHVzZS4gRGVmYXVsdCBpcyBgdXNlTGF5b3V0RWZmZWN0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkRmxhZzxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxUPj4oeyBhY3RpdmF0ZWRJbmRleCwgY2xvc2VzdEZpdCwgbWFuYWdlZENoaWxkcmVuLCBzZXRDaGlsZEZsYWcsIGdldENoaWxkRmxhZywgdXNlRWZmZWN0IH06IFVzZUNoaWxkRmxhZ1BhcmFtZXRlcnM8VCwgST4pIHtcblxuICAgIHVzZUVmZmVjdCA/Pz0gdXNlTGF5b3V0RWZmZWN0O1xuXG4gICAgaWYgKGNsb3Nlc3RGaXQpXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBhY3RpdmF0ZWRJbmRleCA9PSBcIm51bWJlclwiIHx8IGFjdGl2YXRlZEluZGV4ID09IG51bGwpO1xuXG4gICAgLy8gV2hlbmV2ZXIgd2UgcmUtcmVuZGVyLCBtYWtlIHN1cmUgdGhhdCBhbnkgY2hpbGRyZW4gdGhhdCBoYXZlIG1vdW50ZWRcbiAgICAvLyBoYXZlIHRoZWlyIGZsYWdzIHByb3Blcmx5IHNldC4gIFdlIGtub3cgaXQncyB1bnNldCBpZiBpdCB3YXMgbnVsbCxcbiAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGp1c3Qgc2V0IGl0IHRvIHRydWUgb3IgZmFsc2UuXG4gICAgLy9cbiAgICAvLyBBbmQsIEkgbWVhbiwgYXMgbG9uZyBhcyB3ZSdyZSBhbHJlYWR5IGl0ZXJhdGluZyB0aHJvdWdoIGV2ZXJ5IGNoaWxkXG4gICAgLy8gb24gZXZlcnkgcmVuZGVyIHRvIGNoZWNrIGZvciBuZXdseSBtb3VudGVkIGNoaWxkcmVuLCBtaWdodCBhcyB3ZWxsXG4gICAgLy8ganVzdCBoYW5kbGUgY2hhbmdlZCBpbiB0aGUgYWN0aXZhdGVkSW5kZXggaGVyZSB0b28uXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcblxuXG4gICAgICAgIC8vIFRPRE86IFdlIGhhdmUgbGltaXRlZCBpbmZvcm1hdGlvbiBhYm91dCB3aGVuIGEgY2hpbGQgbW91bnRzIG9yIHVubW91bnRzXG4gICAgICAgIC8vIGFuZCBzbyB3ZSBkb24ndCBrbm93IHdoZXJlIHRvIGxvb2sgZm9yIGFueSBudWxsIGVudHJpZXMgdGhhdCBuZWVkIGNoYW5naW5nLlxuICAgICAgICAvLyBXZSBrbm93IHdoZW4gYWN0aXZhdGVkSW5kZXggY2hhbmdlcyBhbmQgd2hhdCBpdCB3YXMsIGJ1dCBub3QgbXVjaCBlbHNlLlxuICAgICAgICAvLyBMb29waW5nIG92ZXIgZXZlcnkgY2hpbGQgKndvcmtzKiwgYW5kIGl0J3Mgbm90IGFuIGV4cGVuc2l2ZSBsb29wIGJ5IGFueSBtZWFucyxcbiAgICAgICAgLy8gYnV0LCBsaWtlLCBldWdoLlxuXG5cbiAgICAgICAgLy8gQWxzbywgYmVmb3JlIHdlIGRvIGFueXRoaW5nLCBzZWUgaWYgd2UgbmVlZCB0byBcImNvcnJlY3RcIiBhY3RpdmF0ZWRJbmRleC5cbiAgICAgICAgLy8gSXQgY291bGQgYmUgcG9pbnRpbmcgdG8gYSBjaGlsZCB0aGF0IGRvZXNuJ3QgZXhpc3QsIGFuZCBpZiBjbG9zZXN0Rml0IGlzIGdpdmVuLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGFkanVzdCBhY3RpdmF0ZWRJbmRleCB0byBwb2ludCB0byBhIHZhbGlkIGNoaWxkLlxuICAgICAgICBpZiAodHlwZW9mIGFjdGl2YXRlZEluZGV4ID09IFwibnVtYmVyXCIgJiYgQXJyYXkuaXNBcnJheShtYW5hZ2VkQ2hpbGRyZW4pICYmIG1hbmFnZWRDaGlsZHJlblthY3RpdmF0ZWRJbmRleF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gT2ggZGVhci4gQXJlIHdlIGFjdGl2ZWx5IGNvcnJlY3RpbmcgdGhpcz9cbiAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0KSB7XG4gICAgICAgICAgICAgICAgLy8gT2ggZGVhci5cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggdXAgYW5kIGRvd24gdGhlIGxpc3Qgb2YgY2hpbGRyZW4gZm9yIGFueSB0aGF0IGFjdHVhbGx5IGV4aXN0LlxuXG4gICAgICAgICAgICAgICAgbGV0IHNlYXJjaEhpZ2ggPSBhY3RpdmF0ZWRJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgbGV0IHNlYXJjaExvdyA9IGFjdGl2YXRlZEluZGV4IC0gMTtcblxuICAgICAgICAgICAgICAgIHdoaWxlICgoc2VhcmNoTG93ID49IDAgJiYgbWFuYWdlZENoaWxkcmVuW3NlYXJjaExvd10gPT0gbnVsbCkgfHwgKHNlYXJjaEhpZ2ggPCBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoICYmIG1hbmFnZWRDaGlsZHJlbltzZWFyY2hIaWdoXSA9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICArK3NlYXJjaEhpZ2g7XG4gICAgICAgICAgICAgICAgICAgIC0tc2VhcmNoTG93O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hMb3cgPj0gMCAmJiBtYW5hZ2VkQ2hpbGRyZW5bc2VhcmNoTG93XSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIChhY3RpdmF0ZWRJbmRleCBhcyBudW1iZXIpID0gc2VhcmNoTG93O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWFyY2hIaWdoIDwgbWFuYWdlZENoaWxkcmVuLmxlbmd0aCAmJiBtYW5hZ2VkQ2hpbGRyZW5bc2VhcmNoSGlnaF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAoYWN0aXZhdGVkSW5kZXggYXMgbnVtYmVyKSA9IHNlYXJjaEhpZ2g7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTm93IHRoYXQgd2UndmUgZG9uZSB0aGF0LCBpZiBhbnkgdmFsaWQgY2hpbGRyZW4gZXhpc3QsIHdlJ3ZlIHJlc2V0IGFjdGl2YXRlZEluZGV4IHRvIHBvaW50IHRvIGl0IGluc3RlYWQuXG4gICAgICAgICAgICAgICAgLy8gTm93IHdlJ2xsIGZhbGwgdGhyb3VnaCB0byB0aGUgZm9yIGxvb3Agc2V0IGFuZCB1bnNldCBvdXIgZmxhZ3MgYmFzZWQgb24gdGhpcyBcImNvcnJlY3RlZFwiIHZhbHVlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgY29ycmVjdCBpdCBvciBzYXZlIGl0IGFueXdoZXJlIGJlY2F1c2Ugd2UnZCB2ZXJ5IG11Y2ggbGlrZSB0byByZXR1cm4gdG8gaXRcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2hpbGQgcmVtb3VudHMgaXRzZWxmLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWFuYWdlZENoaWxkcmVuKSl7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFuYWdlZENoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRCZVNldCA9IChpID09IGFjdGl2YXRlZEluZGV4KTtcbiAgICAgICAgICAgIGlmIChnZXRDaGlsZEZsYWcoaSBhcyBUKSAhPSBzaG91bGRCZVNldCkge1xuICAgICAgICAgICAgICAgIHNldENoaWxkRmxhZyhpIGFzIFQsIHNob3VsZEJlU2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhtYW5hZ2VkQ2hpbGRyZW4pLmZvckVhY2goKFtpLCBfaW5mb10pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRCZVNldCA9IChpID09IGFjdGl2YXRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q2hpbGRGbGFnKGkgYXMgVCkgIT0gc2hvdWxkQmVTZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q2hpbGRGbGFnKGkgYXMgVCwgc2hvdWxkQmVTZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9KTtcblxufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZEluZm8sIHVzZUNoaWxkRmxhZywgdXNlQ2hpbGRNYW5hZ2VyLCBVc2VDaGlsZE1hbmFnZXJSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IE1lcmdlZFByb3BzLCB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IFVzZVJlZkVsZW1lbnRQcm9wc1JldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG5leHBvcnQgdHlwZSBPbWl0U3Ryb25nPFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFBpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj47XG5cblxuXG4vKiogUmV0dXJuIHR5cGUgb2YgYHVzZVJvdmluZ1RhYkluZGV4YCAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGU8SSBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPiBleHRlbmRzIE9taXRTdHJvbmc8VXNlQ2hpbGRNYW5hZ2VyUmV0dXJuVHlwZTxJPiwgXCJ1c2VNYW5hZ2VkQ2hpbGRcIj4ge1xuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8ST47XG4gICAgY2hpbGRDb3VudDogbnVtYmVyO1xuXG4gICAgLy8gRm9jdXNlcyB3aGF0ZXZlciBpcyB0aGUgY3VycmVudGx5IHRhYmJhYmxlIGVsZW1lbnRcbiAgICBmb2N1c0N1cnJlbnQ6IG51bGwgfCAoKCkgPT4gdm9pZCk7XG59XG5cbi8qKiBSZXR1cm4gdHlwZSBvZiBgdXNlUm92aW5nVGFiSW5kZXhDaGlsZGAgKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wczogVXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzPENoaWxkRWxlbWVudD47XG4gICAgdXNlUm92aW5nVGFiSW5kZXhTaWJsaW5nUHJvcHM6IFVzZVJvdmluZ1RhYkluZGV4U2libGluZ1Byb3BzPENoaWxkRWxlbWVudD47XG4gICAgdGFiYmFibGU6IGJvb2xlYW4gfCBudWxsO1xufVxuXG5cblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHBhcmVudCBgdXNlUm92aW5nVGFiSW5kZXhgICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyB7XG5cbiAgICAvKipcbiAgICAgKiBgbnVsbGAgaXMgc3BlY2lhbC11c2Ugb25seSB0byBpbmRpY2F0ZSB0aGF0IHRoZSBlbnRpcmUgY29tcG9uZW50IGlzIGRpc2FibGVkIGFuZCBub3QgdGFiYmFibGUuXG4gICAgICovXG4gICAgdGFiYmFibGVJbmRleDogbnVtYmVyIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZW5ldmVyIHRoZSBjdXJyZW50bHkgdGFiYmFibGUgY2hpbGQgY2hhbmdlcywgYSBkZWNpc2lvbiBuZWVkcyB0byBiZSBtYWRlXG4gICAgICogYWJvdXQgd2hldGhlciB0aGUga2V5Ym9hcmQgZm9jdXMgc2hvdWxkIGZvbGxvdyB0aGF0IGNoYW5nZSBiZWNhdXNlIHRoZVxuICAgICAqIHVzZXIgcHJlc3NlZCBEb3duIGluIGEgdmVydGljYWwgbGlzdCwgb3IgYWx0ZXJuYXRpdmVseSBpZiBpdCB3YXMganVzdFxuICAgICAqIHNvbWV0aGluZyBjb21wbGV0ZWx5IHVucmVsYXRlZCBvbiB0aGUgb3RoZXIgc2lkZSBvZiB0aGUgcGFnZSB3aGVyZSB3ZSBXT1VMRE4nVFxuICAgICAqIHdhbnQgdG8geWFuayBrZXlib2FyZCBmb2N1cyBhbGwgdGhlIHdheSBiYWNrIHRoZXJlLlxuICAgICAqIFxuICAgICAqIEluIGdlbmVyYWwsIHRoaXMgc2hvdWxkIGp1c3QgYmUgaG9va2VkIHVwIHRvIGEgcGFyZW50J3MgXCJnZXRGb2N1c2VkSW5uZXJcIlxuICAgICAqIGZ1bmN0aW9uLCBzbyB0aGF0IHdlIG9ubHkgZm9jdXMgb24gY2hhbmdlIHdoZW4gdGhlIGNvbXBvbmVudCBhcyBhIHdob2xlXG4gICAgICogaGFzIGZvY3VzIHNvbWV3aGVyZSBpbnNpZGUsIGJ1dCB5b3UgY2FuIHdpZGVuL25hcnJvdyB0aGF0IGlmIG5lZWRlZC5cbiAgICAgKi9cbiAgICBzaG91bGRGb2N1c09uQ2hhbmdlKCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPEkgZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbz4gPSBPbWl0U3Ryb25nPEksIFwic2V0VGFiYmFibGVcIiB8IFwiZ2V0VGFiYmFibGVcIiB8IFwicmVyZW5kZXJBbmRGb2N1c1wiPjtcblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNoaWxkICd1c2VSb3ZpbmdUYWJJbmRleENoaWxkYCAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbyBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyPiB7XG4gICAgc2V0VGFiYmFibGUodGFiYmFibGU6IGJvb2xlYW4pOiB2b2lkO1xuICAgIGdldFRhYmJhYmxlKCk6IGJvb2xlYW4gfCBudWxsO1xuICAgIHJlcmVuZGVyQW5kRm9jdXMoKTogdm9pZDtcbn1cblxuXG5cbi8vZXhwb3J0IHR5cGUgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8SSBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPiA9IE9taXRTdHJvbmc8SSwgXCJzZXRUYWJiYWJsZVwiIHwgXCJnZXRUYWJiYWJsZVwiIHwgXCJyZXJlbmRlckFuZEZvY3VzXCI+O1xuXG4vKiogVHlwZSBvZiB0aGUgY2hpbGQncyBzdWItaG9vayAqL1xuZXhwb3J0IHR5cGUgVXNlUm92aW5nVGFiSW5kZXhDaGlsZDxJIGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm8+ID0gPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHByb3BzOiBJKSA9PiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+O1xuXG5leHBvcnQgdHlwZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHNQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PjtcbmV4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4U2libGluZ1Byb3BzUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD47XG5cbi8qKiBSZXR1cm4gdHlwZSBvZiB0aGUgY2hpbGQgYHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wc2AgKi9cbmV4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wc1JldHVyblR5cGU8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4+ID0gTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50LCBVc2VSZWZFbGVtZW50UHJvcHNSZXR1cm5UeXBlPENoaWxkRWxlbWVudCwgeyB0YWJJbmRleDogbnVtYmVyOyB9PiwgT21pdFN0cm9uZzxQLCBcInRhYkluZGV4XCI+PjtcbmV4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4U2libGluZ1Byb3BzUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50Pj4gPSBQOyAvL01lcmdlZFByb3BzPENoaWxkRWxlbWVudCwgeyB0YWJJbmRleDogbnVtYmVyOyB9LCBPbWl0U3Ryb25nPFAsIFwidGFiSW5kZXhcIj4+O1xuXG5leHBvcnQgdHlwZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSA8UCBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wc1BhcmFtZXRlcnM8Q2hpbGRFbGVtZW50Pj4ocHJvcHM6IFApID0+IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wc1JldHVyblR5cGU8Q2hpbGRFbGVtZW50LCBQPlxuZXhwb3J0IHR5cGUgVXNlUm92aW5nVGFiSW5kZXhTaWJsaW5nUHJvcHM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSA8UCBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4U2libGluZ1Byb3BzUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+Pihwcm9wczogUCkgPT4gVXNlUm92aW5nVGFiSW5kZXhTaWJsaW5nUHJvcHNSZXR1cm5UeXBlPENoaWxkRWxlbWVudCwgUD5cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgcm92aW5nIHRhYmluZGV4IHN5c3RlbSB3aGVyZSBvbmx5IG9uZSBcImZvY3VzYWJsZVwiXG4gKiBjb21wb25lbnQgaW4gYSBzZXQgaXMgYWJsZSB0byByZWNlaXZlIGEgdGFiIGZvY3VzLiAqV2hpY2gqXG4gKiBvZiB0aG9zZSBlbGVtZW50cyByZWNlaXZlcyBmb2N1cyBpcyBkZXRlcm1pbmVkIGJ5IHlvdSwgYnV0IGl0J3NcbiAqIHJlY29tbWVuZGVkIHRvIG9mZmxvYWQgdGhhdCBsb2dpYyB0aGVuIHRvIGFub3RoZXIgaG9vaywgbGlrZVxuICogYHVzZUxpbmVhck5hdmlnYXRpb25gLCB3aGljaCBsZXRzIHlvdSBjaGFuZ2UgdGhlIHRhYmJhYmxlXG4gKiBlbGVtZW50IHdpdGggdGhlIGFycm93IGtleXMsIGB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uYCwgd2hpY2hcbiAqIGxldHMgeW91IGNoYW5nZSB0aGUgdGFiYmFibGUgaW5kZXggd2l0aCB0eXBlYWhlYWQsIG9yXG4gKiBgdXNlTGlzdE5hdmlnYXRpb25gIGlmIHlvdSBqdXN0IHdhbnQgZXZlcnl0aGluZyBidW5kbGVkIHRvZ2V0aGVyLlxuICogXG4gKiBOb3RlIHRoYXQgdGhlIGNoaWxkIGhvb2sgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWRcbiAqIGJ5IGV2ZXJ5IGNoaWxkIHRoYXQgdXNlcyB0aGlzIHJvdmluZyB0YWJpbmRleCBsb2dpYy4gIFRoZVxuICogcHJvcC1tb2RpZnlpbmcgaG9vayAqdGhhdCogaG9vayByZXR1cm5zIHNob3VsZCB0aGVuIGJlIHVzZWRcbiAqIG9uIHRoZSBjaGlsZCdzIGVsZW1lbnQsIGFzIHdlbGwgYXMgYW55IG90aGVyIGVsZW1lbnRzIHlvdSdkIGxpa2VcbiAqIHRvIGJlIGV4cGxpY2l0bHkgbWFkZSB1bnRhYmJhYmxlIHRvby5cbiAqIFxuICogYHNob3VsZEZvY3VzT25DaGFuZ2VgIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiBmb2N1cyBpcyBcbiAqIGNvbnRhaW5lZCB3aXRoaW4gd2hhdGV2ZXIgZWxlbWVudCBjb250YWlucyB0aGUgcm92aW5nIHRhYiBpbmRleC5cbiAqIEdlbmVyYWxseSBhcyBzaW1wbGUgYXMgdGhlIGZvbGxvd2luZzpcbiAqIGBgYFxuICogY29uc3QgW2ZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAqIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8UGFyZW50RWxlbWVudD4oeyBzZXRGb2N1c2VkSW5uZXIgfSk7XG4gKiBjb25zdCBmb2N1c09uQ2hhbmdlID0gKGZvY3VzZWRJbm5lciAhPSBmYWxzZSk7XG4gKiBgYGBcbiAqIEl0J3Mgbm90IGluY2x1ZGVkIGhlcmUgYmVjYXVzZSBgdXNlUm92aW5nVGFiSW5kZXhgIGRvZXNuJ3Qga25vdyBcbiAqIGFueXRoaW5nIGFib3V0IHRoZSBjb250YWluZXIgZWxlbWVudCwgb25seSBjaGlsZHJlbiBlbGVtZW50cy5cbiAqIEFuZCBqdXN0IGFzIHdlbGwhIENoaWxkcmVuIHNob3VsZCBiZSBhbGxvd2VkIGF0IHRoZSByb290LCBcbiAqIHJlZ2FyZGxlc3Mgb2YgaWYgaXQncyB0aGUgd2hvbGUgYXBwIG9yIGp1c3QgYSBnaXZlbiBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleDxJIGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm8+KHsgc2hvdWxkRm9jdXNPbkNoYW5nZTogZm9jLCB0YWJiYWJsZUluZGV4IH06IFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyk6IFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZTxJPiB7XG5cbiAgICBjb25zdCBnZXRTaG91bGRGb2N1c09uQ2hhbmdlID0gdXNlU3RhYmxlR2V0dGVyKGZvYyk7XG5cbiAgICBjb25zdCBnZXRUYWJiYWJsZUluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKHRhYmJhYmxlSW5kZXgpO1xuXG4gICAgLy8gQ2FsbCB0aGUgaG9vayB0aGF0IGFsbG93cyB1cyB0byBjb2xsZWN0IGluZm9ybWF0aW9uIGZyb20gY2hpbGRyZW4gd2hvIHByb3ZpZGUgaXRcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbiwgY2hpbGRDb3VudCwgdXNlTWFuYWdlZENoaWxkLCBpbmRpY2VzQnlFbGVtZW50LCAuLi5yZXN0IH0gPSB1c2VDaGlsZE1hbmFnZXI8ST4oKTtcblxuICAgIC8vIEFueSB0aW1lIHRoZSB0YWJiYWJsZSBpbmRleCBjaGFuZ2VzLFxuICAgIC8vIG5vdGlmeSB0aGUgcHJldmlvdXMgY2hpbGQgdGhhdCBpdCdzIG5vIGxvbmdlciB0YWJiYWJsZSxcbiAgICAvLyBhbmQgbm90aWZ5IHRoZSBuZXh0IGNoaWxkIHRoYXQgaXMgYWxsb3dlZCB0byBiZSB0YWJiZWQgdG8uXG4gICAgdXNlQ2hpbGRGbGFnKHtcbiAgICAgICAgYWN0aXZhdGVkSW5kZXg6IHRhYmJhYmxlSW5kZXgsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgY2xvc2VzdEZpdDogdHJ1ZSxcbiAgICAgICAgc2V0Q2hpbGRGbGFnOiAoaW5kZXgsIHRhYmJhYmxlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gbnVsbClcbiAgICAgICAgICAgICAgICAobWFuYWdlZENoaWxkcmVuW2luZGV4IGFzIGtleW9mIHR5cGVvZiBtYW5hZ2VkQ2hpbGRyZW5dIGFzIEkpPy5zZXRUYWJiYWJsZSh0YWJiYWJsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldENoaWxkRmxhZzogKGluZGV4KSA9PiAobWFuYWdlZENoaWxkcmVuW2luZGV4XT8uZ2V0VGFiYmFibGUoKSA/PyBudWxsKVxuICAgIH0pO1xuXG4gICAgY29uc3QgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCA9IHVzZUNhbGxiYWNrPFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8ST4+KDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PihpbmZvOiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxJPik6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudD4gPT4ge1xuXG4gICAgICAgIGNvbnN0IFtycmFmSW5kZXgsIHNldFJyYWZJbmRleF0gPSB1c2VTdGF0ZSgxKTtcbiAgICAgICAgY29uc3QgcmVyZW5kZXJBbmRGb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHsgc2V0UnJhZkluZGV4KGkgPT4gKytpKSB9LCBbXSk7XG4gICAgICAgIGNvbnN0IFt0YWJiYWJsZSwgc2V0VGFiYmFibGUsIGdldFRhYmJhYmxlXSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBudWxsPihudWxsKTtcblxuXG4gICAgICAgIGNvbnN0IG5ld0luZm8gPSB7XG4gICAgICAgICAgICAuLi5pbmZvLFxuICAgICAgICAgICAgcmVyZW5kZXJBbmRGb2N1cyxcbiAgICAgICAgICAgIHNldFRhYmJhYmxlOiB1c2VDYWxsYmFjaygodGFiYmFibGU6IGJvb2xlYW4pID0+IHsgc2V0VGFiYmFibGUodGFiYmFibGUpOyB9LCBbXSksXG4gICAgICAgICAgICBnZXRUYWJiYWJsZVxuICAgICAgICB9IGFzIGFueSBhcyBJO1xuXG4gICAgICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlTWFuYWdlZENoaWxkUHJvcHMgfSA9IHVzZU1hbmFnZWRDaGlsZDxDaGlsZEVsZW1lbnQ+KG5ld0luZm8pO1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKHRhYmJhYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkRm9jdXNPbkNoYW5nZSA9IGdldFNob3VsZEZvY3VzT25DaGFuZ2UoKSgpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRGb2N1c09uQ2hhbmdlICYmIFwiZm9jdXNcIiBpbiAoZWxlbWVudCBhcyBFbGVtZW50IGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVsZW1lbnQgYXMgRWxlbWVudCBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpKS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3RhYmJhYmxlLCBycmFmSW5kZXhdKTtcblxuICAgICAgICBmdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleFNpYmxpbmdQcm9wczxQIGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhTaWJsaW5nUHJvcHNQYXJhbWV0ZXJzPGFueT4+KHsgdGFiSW5kZXgsIC4uLnByb3BzIH06IFApOiBVc2VSb3ZpbmdUYWJJbmRleFNpYmxpbmdQcm9wc1JldHVyblR5cGU8YW55LCBQPiB7XG5cbiAgICAgICAgICAgIGlmICh0YWJJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhYmJhYmxlKVxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RWxlbWVudD4oKSh7IHRhYkluZGV4IH0sIHByb3BzKSBhcyBQO1xuICAgICAgICB9XG5cblxuICAgICAgICBmdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHM8UCBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wc1BhcmFtZXRlcnM8Q2hpbGRFbGVtZW50Pj4oeyB0YWJJbmRleCwgLi4ucHJvcHMgfTogUCk6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wc1JldHVyblR5cGU8Q2hpbGRFbGVtZW50LCBQPiB7XG5cblxuICAgICAgICAgICAgaWYgKHRhYkluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFiYmFibGUpXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxDaGlsZEVsZW1lbnQ+KCkodXNlTWFuYWdlZENoaWxkUHJvcHMoeyB0YWJJbmRleCB9KSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyxcbiAgICAgICAgICAgIHVzZVJvdmluZ1RhYkluZGV4U2libGluZ1Byb3BzLFxuICAgICAgICAgICAgdGFiYmFibGVcbiAgICAgICAgfVxuICAgIH0sIFt1c2VNYW5hZ2VkQ2hpbGRdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsXG4gICAgICAgIGNoaWxkQ291bnQsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgaW5kaWNlc0J5RWxlbWVudCxcbiAgICAgICAgZm9jdXNDdXJyZW50OiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBpZiAobWFuYWdlZENoaWxkcmVuW2dldFRhYmJhYmxlSW5kZXgoKSA/PyAwXS5nZXRUYWJiYWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuW2dldFRhYmJhYmxlSW5kZXgoKSA/PyAwXT8ucmVyZW5kZXJBbmRGb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIHdoYXRldmVyIHJlYXNvbiwgdGhlIHByZXZpb3VzbHkgdGFiYmFibGUgY2hpbGRcbiAgICAgICAgICAgICAgICAvLyBpcyBubyBsb25nZXIgdGFiYmFibGUgd2l0aG91dCB1cyBrbm93aW5nIGFib3V0IGl0LlxuICAgICAgICAgICAgICAgIC8vIE1heWJlIGl0IHVubW91bnRlZD9cbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgd2F5LCB0cnkgdG8gZmluZCB0aGUgbmV3bHktc2VsZWN0ZWQgY2hpbGQuXG5cbiAgICAgICAgICAgICAgICAvLyAoSSBkb24ndCB0aGluayB0aGlzIGNvZGUgcGF0aCBoYXMgZXZlciBiZWVuIHJ1bilcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIGxldCBpID0gZ2V0VGFiYmFibGVJbmRleCgpID8/IDA7XG4gICAgICAgICAgICAgICAgbGV0IGogPSBpICsgMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmFnZWRDaGlsZHJlbltnZXRUYWJiYWJsZUluZGV4KCkgPz8gMF0uZ2V0VGFiYmFibGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuW2dldFRhYmJhYmxlSW5kZXgoKSA/PyAwXT8ucmVyZW5kZXJBbmRGb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbWFuYWdlZENoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYW5hZ2VkQ2hpbGRyZW5bZ2V0VGFiYmFibGVJbmRleCgpID8/IDBdLmdldFRhYmJhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbltnZXRUYWJiYWJsZUluZGV4KCkgPz8gMF0/LnJlcmVuZGVyQW5kRm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pLFxuXG4gICAgICAgIC4uLnJlc3RcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlQmF0Y2hlZEFuaW1hdGlvbkZyYW1lcyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcblxuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJhZGRDYWxsYmFja1wiXT4oKGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5zZXQoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKTsgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJyZW1vdmVDYWxsYmFja1wiXT4oKGNhbGxiYWNrKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LmRlbGV0ZShjYWxsYmFjayk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnRleHRJbmZvID0gdXNlUmVmPENvbnRleHRUeXBlPihudWxsISk7XG4gICAgaWYgKGNvbnRleHRJbmZvLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgY29udGV4dEluZm8uY3VycmVudCA9IHsgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrIH07XG4gICAgY29uc3QgYWxsQ2FsbGJhY2tzID0gdXNlUmVmPE1hcDxSYWZDYWxsYmFja1R5cGUsIGFueT4+KG51bGwhKTtcbiAgICBpZiAoYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gLTE7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFmV2l0aEJhdGNoZWRDYWxsYmFja3MobXNTaW5jZUxhc3Q6IG51bWJlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hlZFJhZkNhbGxiYWNrLCB0YWddIG9mIGFsbENhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlZFJhZkNhbGxiYWNrKG1zU2luY2VMYXN0LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEluZm8uY3VycmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyPilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdpdGggZWZmZWN0aXZlbHkgdGhlIHNhbWUgcnVsZXMgYXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKi9cbiAgICBjYWxsYmFjazogbnVsbCB8ICgobXNTaW5jZUxhc3Q6IG51bWJlcikgPT4gdm9pZCk7XG59XG5cbi8qKlxuICogVGhlIChvcHRpb25hbGx5IG5vbi1zdGFibGUpIGBjYWxsYmFja2AgeW91IHByb3ZpZGUgd2lsbCBzdGFydCBydW5uaW5nIGV2ZXJ5IGZyYW1lIGFmdGVyIHRoZSBjb21wb25lbnQgbW91bnRzLlxuICogXG4gKiBQYXNzaW5nIGBudWxsYCBpcyBmaW5lIGFuZCBzaW1wbHkgc3RvcHMgdGhlIGVmZmVjdCB1bnRpbCB5b3UgcmVzdGFydCBpdCBieSBwcm92aWRpbmcgYSBub24tbnVsbCBjYWxsYmFjay5cbiAqIFxuICogKipUaGlzIGhvb2sgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGF0IGFsbCwgaW5jbHVkaW5nIG5vIHByb3AtbW9kaWZ5aW5nIGhvb2tzKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFuaW1hdGlvbkZyYW1lKHsgY2FsbGJhY2sgfTogVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIGdpdmVuIGNhbGxiYWNrIHRoYXQncyBzdGFibGVcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKGNhbGxiYWNrID8/IG5vb3ApO1xuICAgIGNvbnN0IGhhc0NhbGxiYWNrID0gKGNhbGxiYWNrICE9IG51bGwpO1xuXG4gICAgY29uc3Qgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gdXNlQ29udGV4dChTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LmFkZENhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5yZW1vdmVDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgd3JhcHBlciBhcm91bmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbHNvIGNhbGxzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFnYWluLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZkNhbGxiYWNrID0gKG1zOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlQ2FsbGJhY2sobXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQsIGhhc0NhbGxiYWNrXSlcbn1cblxuLy8gZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5mdW5jdGlvbiBub29wKCkgeyB9XG4iLCJpbXBvcnQgeyBoLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgTWVyZ2VkUHJvcHMsIHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcblxuaW50ZXJmYWNlIFVzZURyYWdnYWJsZVJldHVyblR5cGU8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XG4gICAgdXNlRHJhZ2dhYmxlUHJvcHM6IFVzZURyYWdnYWJsZVByb3BzPEU+O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IGluIHF1ZXN0aW9uIGlzIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkXG4gICAgICovXG4gICAgZHJhZ2dpbmc6IGJvb2xlYW47XG4gICAgZ2V0RHJhZ2dpbmc6ICgpID0+IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBPbmNlIHRoZSBkcmFnIGVuZHMsIGlmIGl0IHdhcyBvdmVyIGEgdmFsaWQgZHJvcHBhYmxlLCB0aGlzIHdpbGwgYmVcbiAgICAgKiBzZXQgdG8gdGhlIGBkcm9wRWZmZWN0YCB2YWx1ZSBpdCBoYWQuXG4gICAgICogXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBkZXRlY3Qgd2hlbiB0aGUgZWxlbWVudCBoYXMgZHJvcHBlZCwgXG4gICAgICogYW5kIHRoZW4gd2hhdCBzaG91bGQgYmUgZG9uZSB3aXRoIGl0IChnZW5lcmFsbHkgZGVsZXRlZCBpZiB0aGUgZWZmZWN0IHdhcyBcIm1vdmVcIilcbiAgICAgKi9cbiAgICBsYXN0RHJvcEVmZmVjdDogRGF0YVRyYW5zZmVyW1wiZHJvcEVmZmVjdFwiXSB8IG51bGw7XG4gICAgZ2V0TGFzdERyb3BFZmZlY3Q6ICgpID0+IChEYXRhVHJhbnNmZXJbXCJkcm9wRWZmZWN0XCJdIHwgbnVsbCk7XG59XG5cbnR5cGUgVXNlRHJhZ2dhYmxlUHJvcHM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHA6IFApID0+IE1lcmdlZFByb3BzPEUsIHtcbiAgICBkcmFnZ2FibGU6IGJvb2xlYW47XG4gICAgb25EcmFnU3RhcnQ6IChlOiBEcmFnRXZlbnQpID0+IHZvaWQ7XG4gICAgb25EcmFnRW5kOiAoZTogRHJhZ0V2ZW50KSA9PiB2b2lkO1xuICAgIHJlZjogUmVmPEU+O1xufSwgUD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRHJhZ2dhYmxlUGFyYW1ldGVycyB7XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIHRvIHRoZSBEcmFnIGFuZCBEcm9wIEFQSSAtLSBhbGxvd3MgbGltaXRpbmcgdGhlIGFyZWFzIHRoaXMgZWxlbWVudCBjYW4gYmUgZHJvcHBlZC5cbiAgICAgKiBGb3IgZXhhbXBsZSwgc2V0dGluZyB0aGlzIHRvIFwiY29weUxpbmtcIiB3aWxsIGFsbG93IHRoaXMgdGhpcyB0byBiZSBkcm9wcGVkIG9udG9cbiAgICAgKiBhIGRyb3BwYWJsZSB3aXRoIGFuIGVmZmVjdCBvZiBcImNvcHlcIiBvciBcImxpbmtcIiwgYnV0IG5vdCBcIm1vdmVcIi5cbiAgICAgKiBcbiAgICAgKi9cbiAgICBlZmZlY3RBbGxvd2VkPzogRGF0YVRyYW5zZmVyW1wiZWZmZWN0QWxsb3dlZFwiXSB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIENhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYSBjdXN0b20gZHJhZyBpbWFnZSBpbnN0ZWFkIG9mIHRoZSBicm93c2VyIGRlZmF1bHQgKGEgdHJhbnNwYXJlbnQgcmVuZGVyIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50LCBnZW5lcmFsbHkpXG4gICAgICovXG4gICAgZHJhZ0ltYWdlPzogSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudDtcbiAgICBkcmFnSW1hZ2VYT2Zmc2V0PzogbnVtYmVyO1xuICAgIGRyYWdJbWFnZVlPZmZzZXQ/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIGEgZGljdGlvbmFyeSBtYXBwaW5nIG9mIE1JTUUgdHlwZXMgdG8gZGF0YVxuICAgICAqL1xuICAgIGRhdGE6IHsgW21pbWVUeXBlOiBzdHJpbmddOiBzdHJpbmcgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURyYWdnYWJsZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZWZmZWN0QWxsb3dlZCwgZGF0YSwgZHJhZ0ltYWdlLCBkcmFnSW1hZ2VYT2Zmc2V0LCBkcmFnSW1hZ2VZT2Zmc2V0IH06IFVzZURyYWdnYWJsZVBhcmFtZXRlcnMpIHtcblxuICAgIGNvbnN0IFtkcmFnZ2luZywgc2V0RHJhZ2dpbmcsIGdldERyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbbGFzdERyb3BFZmZlY3QsIHNldExhc3REcm9wRWZmZWN0LCBnZXRMYXN0RHJvcEVmZmVjdF0gPSB1c2VTdGF0ZTxEYXRhVHJhbnNmZXJbXCJkcm9wRWZmZWN0XCJdIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCB1c2VEcmFnZ2FibGVQcm9wcyA9IHVzZUNhbGxiYWNrKDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHA6IFApID0+IHtcblxuICAgICAgICBjb25zdCByZWYgPSB1c2VSZWY8RT4obnVsbCk7XG5cbiAgICAgICAgY29uc3Qgb25EcmFnU3RhcnQgPSAoZTogRHJhZ0V2ZW50KSA9PiB7XG4gICAgICAgICAgICAvL2UucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNldERyYWdnaW5nKHRydWUpO1xuICAgICAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IChlZmZlY3RBbGxvd2VkID8/IFwiYWxsXCIpO1xuICAgICAgICAgICAgICAgIGlmIChkcmFnSW1hZ2UpXG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShkcmFnSW1hZ2UsIGRyYWdJbWFnZVhPZmZzZXQgPz8gMCwgZHJhZ0ltYWdlWU9mZnNldCA/PyAwKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGRhdGEpIGFzIFttaW1lVHlwZTogc3RyaW5nLCBkYXRhOiBzdHJpbmddW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbWltZVR5cGUsIGRhdGFdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShtaW1lVHlwZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9uRHJhZ0VuZCA9IChlOiBEcmFnRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNldERyYWdnaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlcikge1xuICAgICAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ICE9IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldExhc3REcm9wRWZmZWN0KGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TGFzdERyb3BFZmZlY3QobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KCkoe1xuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICAgICAgb25EcmFnU3RhcnQsXG4gICAgICAgICAgICBvbkRyYWdFbmQsXG4gICAgICAgICAgICByZWZcbiAgICAgICAgfSwgcCk7XG5cbiAgICB9LCBbZWZmZWN0QWxsb3dlZCwgZHJhZ0ltYWdlLCBkcmFnSW1hZ2VYT2Zmc2V0LCBkcmFnSW1hZ2VZT2Zmc2V0LCAuLi5PYmplY3QuZW50cmllcyhkYXRhKS5mbGF0KCldKTtcblxuICAgIC8vIFJldHVybiBib3RoIHRoZSBlbGVtZW50IGFuZCB0aGUgaG9vayB0aGF0IG1vZGlmaWVzIFxuICAgIC8vIHRoZSBwcm9wcyBhbmQgYWxsb3dzIHVzIHRvIGFjdHVhbGx5IGZpbmQgdGhlIGVsZW1lbnRcbiAgICBjb25zdCByZXQ6IFVzZURyYWdnYWJsZVJldHVyblR5cGU8RT4gPSB7XG4gICAgICAgIHVzZURyYWdnYWJsZVByb3BzLFxuICAgICAgICBkcmFnZ2luZyxcbiAgICAgICAgZ2V0RHJhZ2dpbmcsXG5cbiAgICAgICAgLy8gU2V0IG9uY2UgYSBkcmFnIGhhcyBjb21wbGV0ZWQgd2l0aCB0aGUgcmVzdWx0aW5nIGFjdGlvblxuICAgICAgICAvLyBVc2VmdWwgZm9yIHJlbW92aW5nIHRoZSBlbGVtZW50IGFmdGVyd2FyZHMgaWYgaXQgd2FzIFwibW92ZVwiXG4gICAgICAgIGxhc3REcm9wRWZmZWN0LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXN0XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXN0RHJvcEVmZmVjdFxuICAgIH07XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBNZXJnZWRQcm9wcywgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyBVc2VSZWZFbGVtZW50UHJvcHNSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyb3BwYWJsZVJldHVyblR5cGU8RSBleHRlbmRzIEhUTUxFbGVtZW50PiB7XG5cbiAgICAvKipcbiAgICAgKiBIb29rIGZvciBtb2RpZnlpbmcgdGhlIHByb3BzIHlvdSB3ZXJlIGdvaW5nIHRvIHBhc3MgdG8geW91ciBkcm9wIHRhcmdldCBFbGVtZW50LlxuICAgICAqL1xuICAgIHVzZURyb3BwYWJsZVByb3BzOiBVc2VEcm9wcGFibGVQcm9wczxFPjtcblxuICAgIC8qKlxuICAgICAqIFdoaWxlIHNvbWV0aGluZyBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyBlbGVtZW50LCB0aGlzIHdpbGwgY29udGFpbiBhbnkgaW5mb3JtYXRpb24gYWJvdXQgYW55IGZpbGVzIGluY2x1ZGVkIGluIHRoYXQgZHJvcC5cbiAgICAgKiBPdGhlcndpc2UsIGl0J2xsIGJlIG51bGwsIG1lYW5pbmcgbm90aGluZyBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyBlbGVtZW50LlxuICAgICAqL1xuICAgIGZpbGVzRm9yQ29uc2lkZXJhdGlvbjogRHJvcEZpbGVNZXRhZGF0YVtdIHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBXaGlsZSBzb21ldGhpbmcgaXMgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoaXMgZWxlbWVudCwgYSBsaXN0IG9mIGF2YWlsYWJsZSBNSU1FIHR5cGVzIGZvciB0aGUgbm9uLWZpbGUgZGF0YSB3aWxsIGJlIGxpc3RlZCBoZXJlLlxuICAgICAqIE90aGVyd2lzZSwgaXQnbGwgYmUgbnVsbCwgbWVhbmluZyBub3RoaW5nIGlzIGJlaW5nIGRyYWdnZWQgb3ZlciB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgc3RyaW5nc0ZvckNvbnNpZGVyYXRpb246IFNldDxzdHJpbmc+IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZmlsZXMgYXJlIGRyb3BwZWQgb3ZlciB0aGUgZWxlbWVudCwgdGhlaXIgZGF0YSB3aWxsIGJlIGdpdmVuIGhlcmUuXG4gICAgICogVGhpcyB3aWxsIHVwZGF0ZSBhcyBuZXcgZHJvcHMgaGFwcGVuLlxuICAgICAqL1xuICAgIGRyb3BwZWRGaWxlczogRHJvcEZpbGVbXSB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIG5vbi1maWxlIGRhdGEgaXMgZHJvcHBlZCBvdmVyIHRoZSBlbGVtZW50LCB0aGVpciBkYXRhIHdpbGwgYmUgZ2l2ZW4gaGVyZS5cbiAgICAgKiBUaGlzIHdpbGwgdXBkYXRlIGFzIG5ldyBkcm9wcyBoYXBwZW4uXG4gICAgICovXG4gICAgZHJvcHBlZFN0cmluZ3M6IHsgW01pbWVUeXBlOiBzdHJpbmddOiBzdHJpbmcgfSB8IG51bGw7XG5cblxuICAgIGRyb3BFcnJvcjogdW5rbm93bjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VEcm9wcGFibGVQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBNYXBzIHRvIHRoZSBEcmFnIGFuZCBEcm9wIEFQSSAtLSBlZmZlY3RpdmVseSBtZWFucyBcImFzIGNsb3NlIGFzIHBvc3NpYmxlLCB3aGF0J3MgaGFwcGVuaW5nIHRvIHRoZSBkYXRhIHdoZW4gSSBkcm9wIGl0IGhlcmU/IFxuICAgICAqIEFtIEkgY29weWluZyBpdCBhbmQgbGVhdmluZyB0aGUgb3JpZ2luYWwsIGFtIEkgbW92aW5nIGl0IGFuZCBkZWxldGluZyB0aGUgb3JpZ2luYWwsIG9yIGFtIEkgbGlua2luZyBpdCB0byB0aGUgb3JpZ2luYWw/XCJcbiAgICAgKiBcbiAgICAgKiBXaGF0ZXZlciBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyB3aWxsIGhhdmUgaXRzIG93biBwZXJtaXNzaW9uIHRoYXQncyBjaGVja2VkIGFnYWluc3QgdGhpcy5cbiAgICAgKi9cbiAgICBlZmZlY3Q6IERhdGFUcmFuc2ZlcltcImRyb3BFZmZlY3RcIl0gfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcEZpbGUgZXh0ZW5kcyBEcm9wRmlsZU1ldGFkYXRhIHsgbmFtZTogc3RyaW5nLCBkYXRhOiBBcnJheUJ1ZmZlciwgc2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkLCBsYXN0TW9kaWZpZWQ6IG51bWJlciB8IHVuZGVmaW5lZCB9XG5leHBvcnQgaW50ZXJmYWNlIERyb3BGaWxlTWV0YWRhdGEgeyB0eXBlOiBzdHJpbmcgfCB1bmRlZmluZWQgfVxuXG5cbnR5cGUgRHJvcHBhYmxlRmlsZUVycm9yVHlwZSA9IFwiSW5kZXhTaXplRXJyb3JcIiB8IFwiSGllcmFyY2h5UmVxdWVzdEVycm9yXCIgfCBcIldyb25nRG9jdW1lbnRFcnJvclwiIHwgXCJJbnZhbGlkQ2hhcmFjdGVyRXJyb3JcIiB8IFwiTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3JcIiB8IFwiTm90Rm91bmRFcnJvclwiIHwgXCJOb3RTdXBwb3J0ZWRFcnJvclwiIHwgXCJJbnZhbGlkU3RhdGVFcnJvclwiIHwgXCJJblVzZUF0dHJpYnV0ZUVycm9yXCIgfCBcIlN5bnRheEVycm9yXCIgfCBcIkludmFsaWRNb2RpZmljYXRpb25FcnJvclwiIHwgXCJOYW1lc3BhY2VFcnJvclwiIHwgXCJJbnZhbGlkQWNjZXNzRXJyb3JcIiB8IFwiVHlwZU1pc21hdGNoRXJyb3JcIiB8IFwiU2VjdXJpdHlFcnJvclwiIHwgXCJOZXR3b3JrRXJyb3JcIiB8IFwiQWJvcnRFcnJvclwiIHwgXCJVUkxNaXNtYXRjaEVycm9yXCIgfCBcIlF1b3RhRXhjZWVkZWRFcnJvclwiIHwgXCJUaW1lb3V0RXJyb3JcIiB8IFwiSW52YWxpZE5vZGVUeXBlRXJyb3JcIiB8IFwiRGF0YUNsb25lRXJyb3JcIiB8IFwiRW5jb2RpbmdFcnJvclwiIHwgXCJOb3RSZWFkYWJsZUVycm9yXCIgfCBcIlVua25vd25FcnJvclwiIHwgXCJDb25zdHJhaW50RXJyb3JcIiB8IFwiRGF0YUVycm9yXCIgfCBcIlRyYW5zYWN0aW9uSW5hY3RpdmVFcnJvclwiIHwgXCJSZWFkT25seUVycm9yXCIgfCBcIlZlcnNpb25FcnJvclwiIHwgXCJPcGVyYXRpb25FcnJvclwiIHwgXCJOb3RBbGxvd2VkRXJyb3JcIjtcblxuZXhwb3J0IGNsYXNzIERyb3BwYWJsZUZpbGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBmaWxlTmFtZTogc3RyaW5nO1xuICAgIGVycm9yVHlwZTogRHJvcHBhYmxlRmlsZUVycm9yVHlwZTtcblxuICAgIGNvbnN0cnVjdG9yKGZpbGVOYW1lOiBzdHJpbmcsIGJhc2U6IERPTUV4Y2VwdGlvbiB8IG51bGwpIHtcbiAgICAgICAgc3VwZXIoYmFzZT8ubWVzc2FnZSA/PyBcIkFuIHVuc3BlY2lmaWVkIGVycm9yIG9jY3VycmVkIHJlYWRpbmcgdGhlIGZpbGUuXCIpO1xuICAgICAgICB0aGlzLmZpbGVOYW1lID0gZmlsZU5hbWU7XG4gICAgICAgIHRoaXMuZXJyb3JUeXBlID0gKGJhc2U/Lm5hbWUgYXMgRHJvcHBhYmxlRmlsZUVycm9yVHlwZSk7XG4gICAgfVxuXG59XG5cbnR5cGUgVXNlRHJvcHBhYmxlUHJvcHM8RSBleHRlbmRzIEhUTUxFbGVtZW50PiA9IDxQIGV4dGVuZHMgVXNlRHJvcHBhYmxlUHJvcHNQYXJhbWV0ZXJzPEU+PihwOiBQKSA9PiBVc2VEcm9wcGFibGVQcm9wc1JldHVyblR5cGU8RSwgUD47XG50eXBlIFVzZURyb3BwYWJsZVByb3BzUGFyYW1ldGVyczxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+ID0gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG50eXBlIFVzZURyb3BwYWJsZVByb3BzUmV0dXJuVHlwZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQsIFAgZXh0ZW5kcyBVc2VEcm9wcGFibGVQcm9wc1BhcmFtZXRlcnM8RT4+ID0gXG5NZXJnZWRQcm9wczxFLCBVc2VSZWZFbGVtZW50UHJvcHNSZXR1cm5UeXBlPEUsIHsgb25EcmFnRW50ZXI6IChlOiBEcmFnRXZlbnQpID0+IHZvaWQ7IG9uRHJhZ0xlYXZlOiAoZTogRHJhZ0V2ZW50KSA9PiB2b2lkOyBvbkRyYWdPdmVyOiAoZTogRHJhZ0V2ZW50KSA9PiB2b2lkOyBvbkRyb3A6IChlOiBEcmFnRXZlbnQpID0+IHZvaWQ7IH0+LCBQPjtcbi8vTWVyZ2VkUHJvcHM8VXNlUmVmRWxlbWVudFByb3BzUmV0dXJuVHlwZTxFLCBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+LCBcIm9uRHJhZ0VudGVyXCIgfCBcIm9uRHJhZ0xlYXZlXCIgfCBcIm9uRHJhZ092ZXJcIiB8IFwib25Ecm9wXCI+PiwgUD47XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURyb3BwYWJsZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgZWZmZWN0IH06IFVzZURyb3BwYWJsZVBhcmFtZXRlcnMpOiBVc2VEcm9wcGFibGVSZXR1cm5UeXBlPEU+IHtcblxuICAgIGNvbnN0IFtmaWxlc0ZvckNvbnNpZGVyYXRpb24sIHNldEZpbGVzRm9yQ29uc2lkZXJhdGlvbl0gPSB1c2VTdGF0ZTxudWxsIHwgRHJvcEZpbGVNZXRhZGF0YVtdPihudWxsKTtcbiAgICBjb25zdCBbc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24sIHNldFN0cmluZ3NGb3JDb25zaWRlcmF0aW9uXSA9IHVzZVN0YXRlPG51bGwgfCBTZXQ8c3RyaW5nPj4obnVsbCk7XG5cbiAgICBjb25zdCBbZHJvcHBlZEZpbGVzLCBzZXREcm9wcGVkRmlsZXNdID0gdXNlU3RhdGU8bnVsbCB8IERyb3BGaWxlW10+KG51bGwpO1xuICAgIGNvbnN0IFtkcm9wcGVkU3RyaW5ncywgc2V0RHJvcHBlZFN0cmluZ3NdID0gdXNlU3RhdGU8bnVsbCB8IHsgW01pbWVUeXBlOiBzdHJpbmddOiBzdHJpbmcgfT4obnVsbCk7XG5cbiAgICBjb25zdCBbZHJvcEVycm9yLCBzZXREcm9wRXJyb3JdID0gdXNlU3RhdGU8dW5rbm93biB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuICAgIC8vIEFsbCB0aGUgcHJvbWlzZXMgZ2VuZXJhdGVkIGZyb20gdGhlIGRyb3AgZXZlbnRzLlxuICAgIC8vIFVzZWQgdG8gcHJvY2VzcyBtdWx0aXBsZSBkcm9wIGV2ZW50cyBpbiBzdWNjZXNzaW9uXG4gICAgY29uc3QgZHJvcFByb21pc2VzUmVmID0gdXNlUmVmPFByb21pc2U8bnVsbCB8IHsgc3RyaW5nczogeyBbbWltZVR5cGU6IHN0cmluZ106IHN0cmluZyB9LCBmaWxlczogRHJvcEZpbGVbXSB9PltdPihbXSk7XG4gICAgY29uc3QgW2N1cnJlbnRQcm9taXNlSW5kZXgsIHNldEN1cnJlbnRQcm9taXNlSW5kZXgsIGdldEN1cnJlbnRQcm9taXNlSW5kZXhdID0gdXNlU3RhdGUoLTEpO1xuICAgIGNvbnN0IFtwcm9taXNlQ291bnQsIHNldFByb21pc2VDb3VudCwgZ2V0UHJvbWlzZUNvdW50XSA9IHVzZVN0YXRlKDApO1xuXG4gICAgLy8gQW55IHRpbWUgd2UgYWRkIGEgbmV3IHByb21pc2UsIGlmIHRoZXJlJ3Mgbm8gY3VycmVudCBwcm9taXNlIHJ1bm5pbmcsIHdlIG5lZWQgdG8gc3RhcnQgb25lLlxuICAgIC8vIElmIHRoZXJlIGlzIG9uZSwgdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLCBzaW5jZSBpdCBydW5zIHRoZSBzYW1lIGNoZWNrLlxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcm9taXNlSW5kZXggPSBnZXRDdXJyZW50UHJvbWlzZUluZGV4KCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VDb3VudCA9IGdldFByb21pc2VDb3VudCgpO1xuXG4gICAgICAgIGlmIChwcm9taXNlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBpZiAoKGN1cnJlbnRQcm9taXNlSW5kZXggKyAxKSA8IHByb21pc2VDb3VudCkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRQcm9taXNlSW5kZXgoaSA9PiArK2kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LCBbcHJvbWlzZUNvdW50XSk7XG5cbiAgICAvLyBBbnl0aW1lIG91ciBjdXJyZW50IHByb21pc2UgY2hhbmdlcyxcbiAgICAvLyB3YWl0IGZvciBpdCB0byBmaW5pc2gsIHRoZW4gc2V0IG91ciBzdGF0ZSB0byBpdHMgcmVzdWx0LlxuICAgIC8vIEZpbmFsbHksIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55bW9yZSBwcm9taXNlcy5cbiAgICAvLyBJZiB0aGVyZSBhcmUsIHRoZW4gaW5jcmVhc2UgY3VycmVudFByb21pc2VDb3VudCxcbiAgICAvLyB3aGljaCB3aWxsIHRyaWdnZXIgdGhpcyBhZ2Fpbi5cbiAgICAvL1xuICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiAqb2Z0ZW4qLCBidXQgbWF5YmUgaW4gdGhlIGNhc2Ugb2ZcbiAgICAvLyBpbmRpdmlkdWFsbHkgZHJvcHBpbmcgYSBidW5jaCBvZiBsYXJnZSBmaWxlcyBvciBzb21ldGhpbmcuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9taXNlSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFByb21pc2UgPSBkcm9wUHJvbWlzZXNSZWYuY3VycmVudFtjdXJyZW50UHJvbWlzZUluZGV4XTtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnRoZW4oKGluZm8pID0+IHtcblxuICAgICAgICAgICAgICAgIGlmIChpbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmlsZXMsIHN0cmluZ3MgfSA9IGluZm87XG4gICAgICAgICAgICAgICAgICAgIHNldERyb3BwZWRGaWxlcyhmaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldERyb3BwZWRTdHJpbmdzKHN0cmluZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE5vdyB0aGF0IHdlJ3JlIGRvbmUsIGFyZSB0aGVyZSBtb3JlIHByb21pc2VzIGluIHRoZSBxdWV1ZT9cblxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQcm9taXNlSW5kZXggPSBnZXRDdXJyZW50UHJvbWlzZUluZGV4KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZUNvdW50ID0gZ2V0UHJvbWlzZUNvdW50KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRQcm9taXNlSW5kZXggKyAxKSA8IHByb21pc2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGlzIHByb21pc2UgaGFzIHN0YXJ0ZWQsIG1vcmUgaGF2ZSBiZWVuIGFkZGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBSdW4gdGhpcyBlZmZlY3QgYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRQcm9taXNlSW5kZXgoaSA9PiArK2kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9LCBbY3VycmVudFByb21pc2VJbmRleF0pXG5cblxuICAgIGNvbnN0IHVzZURyb3BwYWJsZVByb3BzOiBVc2VEcm9wcGFibGVQcm9wczxFPiA9IDxQIGV4dGVuZHMgVXNlRHJvcHBhYmxlUHJvcHNQYXJhbWV0ZXJzPEU+PihwOiBQKTogVXNlRHJvcHBhYmxlUHJvcHNSZXR1cm5UeXBlPEUsIFA+ID0+IHtcblxuICAgICAgICAvL2NvbnN0IHJlZiA9IHVzZVJlZjxFPihudWxsKTtcblxuICAgICAgICAvLyBIYW5kbGUgY29sbGVjdGluZyB0aGUgY3VycmVudCBmaWxlIG1ldGFkYXRhIG9yIE1JTUUgdHlwZXMuXG4gICAgICAgIGNvbnN0IG9uRHJhZ0VudGVyID0gKGU6IERyYWdFdmVudCkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJcyB0aGVyZSBhIGRlZmF1bHQ/IEkgY2FuJ3QgZmluZCBvbmUgYW55d2hlcmUuXG4gICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IChlZmZlY3QgPz8gXCJtb3ZlXCIpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TWltZVR5cGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RmlsZXMgPSBuZXcgQXJyYXk8RHJvcEZpbGVNZXRhZGF0YT4oKTtcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBlLmRhdGFUcmFuc2Zlcj8uaXRlbXMgPz8gW10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBraW5kLCB0eXBlIH0gPSBpdGVtO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChraW5kID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdNaW1lVHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtpbmQgPT09IFwiZmlsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGaWxlcy5wdXNoKHsgdHlwZTogaXRlbS50eXBlIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXRGaWxlc0ZvckNvbnNpZGVyYXRpb24obmV3RmlsZXMpO1xuICAgICAgICAgICAgICAgIHNldFN0cmluZ3NGb3JDb25zaWRlcmF0aW9uKG5ld01pbWVUeXBlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSGFuZGxlIHJlc2V0dGluZyB0aGUgY3VycmVudCBmaWxlIG1ldGFkYXRhIG9yIE1JTUUgdHlwZXNcbiAgICAgICAgY29uc3Qgb25EcmFnTGVhdmUgPSAoZTogRHJhZ0V2ZW50KSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzZXRGaWxlc0ZvckNvbnNpZGVyYXRpb24obnVsbCk7XG4gICAgICAgICAgICBzZXRTdHJpbmdzRm9yQ29uc2lkZXJhdGlvbihudWxsKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBCb2lsZXJwbGF0ZSwgSSBndWVzc1xuICAgICAgICBjb25zdCBvbkRyYWdPdmVyID0gKGU6IERyYWdFdmVudCkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGdldHRpbmcgdGhlIGRyb3AgZGF0YSBhc3luY2hyb25vdXNseVxuICAgICAgICBjb25zdCBvbkRyb3AgPSAoZTogRHJhZ0V2ZW50KSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHNldEZpbGVzRm9yQ29uc2lkZXJhdGlvbihudWxsKTtcbiAgICAgICAgICAgIHNldFN0cmluZ3NGb3JDb25zaWRlcmF0aW9uKG51bGwpO1xuXG4gICAgICAgICAgICBjb25zdCBhbGxQcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPHVua25vd24+PigpO1xuXG4gICAgICAgICAgICBjb25zdCBkcm9wRGF0YTogeyBbbWltZVR5cGU6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICAgICAgICBjb25zdCBkcm9wRmlsZTogRHJvcEZpbGVbXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZS5kYXRhVHJhbnNmZXI/Lml0ZW1zID8/IFtdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBraW5kLCB0eXBlIH0gPSBpdGVtO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsUHJvbWlzZXMucHVzaCgobmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgX3JlamVjdCkgPT4gaXRlbS5nZXRBc1N0cmluZyhyZXNvbHZlKSkpLnRoZW4oc3RyID0+IGRyb3BEYXRhW3R5cGVdID0gc3RyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtpbmQgPT09IFwiZmlsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBpdGVtLmdldEFzRmlsZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gKF8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSByZWFkZXIucmVzdWx0IGFzIEFycmF5QnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEZpbGUucHVzaCh7IGRhdGEsIG5hbWU6IGZpbGUubmFtZSwgdHlwZTogZmlsZS50eXBlLCBzaXplOiBkYXRhLmJ5dGVMZW5ndGgsIGxhc3RNb2RpZmllZDogZmlsZS5sYXN0TW9kaWZpZWQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gKF8pID0+IHsgcmVqZWN0KG5ldyBEcm9wcGFibGVGaWxlRXJyb3IoZmlsZS5uYW1lLCByZWFkZXIuZXJyb3IpKTsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9uYWJvcnQgPSAoXykgPT4geyByZWplY3QobmV3IERyb3BwYWJsZUZpbGVFcnJvcihmaWxlLm5hbWUsIHJlYWRlci5lcnJvcikpOyB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BGaWxlLnB1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBkcm9wUHJvbWlzZXNSZWYuY3VycmVudC5wdXNoKFByb21pc2UuYWxsKGFsbFByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRQcm9taXNlQ291bnQoaSA9PiArK2kpO1xuICAgICAgICAgICAgICAgIHNldERyb3BFcnJvcihudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdzOiBkcm9wRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZXM6IGRyb3BGaWxlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZXggPT4ge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgc2V0UHJvbWlzZUNvdW50KGkgPT4gKytpKTtcbiAgICAgICAgICAgICAgICBzZXREcm9wRXJyb3IoZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG5cblxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oKSh7IG9uRHJhZ0VudGVyLCBvbkRyYWdMZWF2ZSwgb25EcmFnT3Zlciwgb25Ecm9wIH0sIHApO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VEcm9wcGFibGVQcm9wcyxcbiAgICAgICAgZmlsZXNGb3JDb25zaWRlcmF0aW9uLFxuICAgICAgICBzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbixcbiAgICAgICAgZHJvcHBlZEZpbGVzLFxuICAgICAgICBkcm9wcGVkU3RyaW5ncyxcblxuICAgICAgICBkcm9wRXJyb3JcbiAgICB9XG59XG5cblxuIiwiaW1wb3J0IHsgaCwgUHJlYWN0RE9NQXR0cmlidXRlcyB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgTWVyZ2VkUHJvcHMsIHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHVzZWQgdG8gc2VsZWN0ICpqdXN0KiB0aGUgdHlwZWQgYWRkRXZlbnRMaXN0ZW5lciBcclxuICogYW5kIG5vdCB0aGUgZ2VuZXJpYyBcIkknbGwgYWNjZXB0IGFueSBzdHJpbmcgYW5kIGFueSBoYW5kbGVyXCIgb25lLlxyXG4gKiBcclxuICogVE9ETzogVGhpcyBcIlwiXCJ3b3Jrc1wiXCJcIiBidXQgaXQncyBub3QgZ3JlYXQgYW5kIGltcGxpY2l0bHkgcmVsaWVzIG9uXHJcbiAqIGxpYi5kb20udHMgYWx3YXlzIGdpdmVpbmcgdGhlIHR3byBvdmVybG9hZHMgaW4gdGhlIHNhbWUgb3JkZXIsIHdpdGggdGhlXHJcbiAqIHR5cGVkIG9uZSBmaXJzdC4gKlRoYXQqIHByb2JhYmx5IHdvbid0IGNoYW5nZSwgYnV0IGlmIG1vcmUgb3ZlcmxvYWRzXHJcbiAqIGFyZSBldmVyIGFkZGVkIHRoaXMgd2lsbCBuZWVkIGFkanVzdG1lbnQuXHJcbiAqIFxyXG4gKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUyNzYxMTU2IGZvciBob3cgc2VsZWN0aW5nIHRoZSBjb3JyZWN0IG92ZXJsb2FkIHdvcmtzLlxyXG4gKi9cclxudHlwZSBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczxUPiA9XHJcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGluZmVyIFIgfSA/IFIgOlxyXG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55IH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxyXG4gICAgVCBleHRlbmRzICguLi5hcmdzOiBpbmZlciBSKSA9PiBhbnkgPyBSIDogW107XHJcblxyXG4vLyBHZXQganVzdCB0aGUgdHlwZWQgdmVyc2lvbiBvZiBhZGRFdmVudExpc3RlbmVyLCBpZiBpdCBleGlzdHNcclxudHlwZSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9ICguLi5hcmdzOiBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczwoVFtcImFkZEV2ZW50TGlzdGVuZXJcIl0pPikgPT4gdm9pZDtcclxuXHJcbi8vIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIFwiYWRkRXZlbnRMaXN0ZW5lclwiICh0aGUgZXZlbnQgdHlwZSBhcyBhIHN0cmluZylcclxudHlwZSBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+IGV4dGVuZHMgKCh0eXBlOiBpbmZlciBLMiwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBLMiA6IHN0cmluZztcclxuXHJcblxyXG4vLyBUT0RPOiBUaGlzIGlzbid0IHF1aXRlIGFibGUgdG8gbmFycm93IGRvd24gdGhlIGV4YWN0IGV2ZW50IHR5cGUgZm9yIHVua25vd24gcmVhc29ucy5cclxuLy8gSW5zdGVhZCBpdCByZXR1cm5zIGEgdW5pb24gb2YgYWxsIGF2YWlsYWJsZSBldmVudCB0eXBlcywgd2hpY2ggaXMuLi5maW5lLCBJIGd1ZXNzLlxyXG4vLyBJIGRvbid0IGtub3cgd2h5IGBpbmZlciBIYCBpcyBkb2luZyB0aGF0IHdoZW4gdGhlIHR5cGUgc2hvdWxkIGJlIG5hcnJvd2VkIGJ5IGBUYCB0aG91Z2guLi5cclxuLy8gTm90ZSB0aGF0IHRoZSB0eXBlIHBhcmFtZXRlciBpcyBzdGlsbCB1c2VkLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IG5hcnJvdyBkb3duIHRoZSB0eXBlLFxyXG4vLyBiZWNhdXNlIG90aGVyd2lzZSwgaW5zdGVhZCBvZiBiZWluZyBhIHVuaW9uIG9mIGFsbCB0eXBlcywgaXQncyBqdXN0IGBhbnlgXHJcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXI8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+IGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiBpbmZlciBILCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IE5vbk51bGxhYmxlPEg+IDogbmV2ZXI7XHJcbi8vKChUeXBlZEFkZEV2ZW50TGlzdGVuZXI8RT4gJiAoKHR5cGU6IFQsIGhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZCwgLi4uYXJnczogYW55W10pID0+IGFueSkpIGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogaW5mZXIgSCkgPT4gYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IEggOiBGdW5jdGlvbikgLyomIChUIGV4dGVuZHMga2V5b2YgR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwPyBHbG9iYWxFdmVudEhhbmRsZXJzRXZlbnRNYXBbVF0gOiAoZTogRXZlbnQpID0+IHZvaWQpKi87XHJcblxyXG50eXBlIFBhcmFtZXRlcnMyPFQgZXh0ZW5kcyAoRXZlbnRMaXN0ZW5lck9iamVjdCB8ICgoLi4uYXJnczogYW55KSA9PiBhbnkpKT4gPVxyXG4gICAgVCBleHRlbmRzIEV2ZW50TGlzdGVuZXJPYmplY3QgPyBQYXJhbWV0ZXJzPFRbXCJoYW5kbGVFdmVudFwiXT4gOlxyXG4gICAgVCBleHRlbmRzICguLi5hcmdzOiBpbmZlciBQKSA9PiBhbnkgPyBQIDogbmV2ZXI7XHJcblxyXG5cclxudHlwZSBUeXBlZEV2ZW50SGFuZGxlckV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVCBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPEU+PiA9IFBhcmFtZXRlcnMyPFR5cGVkRXZlbnRIYW5kbGVyPEUsIFQ+PlswXTtcclxuXHJcblxyXG4vKipcclxuICogQWxsb3dzIGF0dGFjaGluZyBhbiBldmVudCBoYW5kbGVyIHRvIGFueSAqbm9uLVByZWFjdCogZWxlbWVudCwgYW5kIHJlbW92aW5nIGl0IHdoZW4gdGhlIGNvbXBvbmVudCB1c2luZyB0aGUgaG9vayB1bm1vdW50cy4gVGhlIGNhbGxiYWNrIGRvZXMgbm90IG5lZWQgdG8gYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxyXG4gKiBcclxuICogRHVlIHRvIHR5cGluZyBsaW1pdGF0aW9ucywgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBsaWtlIHRoaXM6XHJcbiAqIFxyXG4gKiBgdXNlRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiaW5wdXRcIik8SW5wdXRFdmVudD4oZSA9PiB7fSlgXHJcbiAqIFxyXG4gKiBUaGUgdHlwZSBhcmd1bWVudCBpcyBvcHRpb25hbCwgYnV0IG5hcnJvd3MgZG93biB0aGUgdHlwZSBmcm9tIFwiYSB1bmlvbiBvZiBhbGwgZXZlbnRzXCIgdG8gd2hhdGV2ZXIgeW91IHNwZWNpZnksIGFuZCBlcnJvcnMgaWYgaXQgZG9lc24ndCBleGlzdC5cclxuICogXHJcbiAqIFRoZXJlIGlzIGEgc2VwYXJhdGUgdmVyc2lvbiB0aGF0IGF0dGFjaGVzIGV2ZW50IGhhbmRsZXJzIHRvIGEgc2V0IG9mIHByb3BzLiBcclxuICogSXQgdGFrZXMgZGlmZmVyZW50IGV2ZW50IHN0cmluZyB0eXBlcyAob25FdmVudCB2cyBvbmV2ZW50KS5cclxuICogXHJcbiAqIEBwYXJhbSB0YXJnZXQgQSAqbm9uLVByZWFjdCogbm9kZSB0byBhdHRhY2ggdGhlIGV2ZW50IHRvLlxyXG4gKiBAcmV0dXJuc1xyXG4gKiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlcjxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcclxuXHJcbiAgICAvLyBOb3RlIHRvIHNlbGY6IFRoZSB0eXBpbmcgZG9lc24ndCBpbXByb3ZlIGV2ZW4gaWYgdGhpcyBpcyBzcGxpdCB1cCBpbnRvIGEgc3ViLWZ1bmN0aW9uLlxyXG4gICAgLy8gTm8gbWF0dGVyIHdoYXQsIGl0IHNlZW1zIGltcG9zc2libGUgdG8gZ2V0IHRoZSBoYW5kbGVyJ3MgZXZlbnQgb2JqZWN0IHR5cGVkIHBlcmZlY3RseS5cclxuICAgIC8vIEl0IHNlZW1zIGxpa2UgaXQncyBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgdHVwZXMuXHJcbiAgICAvLyBBZ2Fpbiwgbm8gbWF0dGVyIHdoYXQgY29tYmluYXRpb24gb2Ygc3ViLSBvciBzdWItc3ViLWZ1bmN0aW9ucyB1c2VkLlxyXG5cclxuICAgIGxldCBzdGFibGVIYW5kbGVyOiBFdmVudExpc3RlbmVyIHwgbnVsbCA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIgPz8gKCgpID0+IHsgfSkpIGFzIEV2ZW50TGlzdGVuZXI7XHJcbiAgICBpZiAoaGFuZGxlciA9PSBudWxsKVxyXG4gICAgICAgIHN0YWJsZUhhbmRsZXIgPSBudWxsO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3RhcmdldCwgdHlwZSwgc3RhYmxlSGFuZGxlcl0pO1xyXG59XHJcblxyXG4vKipcclxuICogQW4gYWx0ZXJuYXRpdmUgd2F5IHRvIGFkZCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIGVsZW1lbnQuIFVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpbnRlZ3JhdGluZyAzcmQgcGFydHkgbGlicmFyaWVzIHRoYXQgZXhwZWN0IGEgZ2VuZXJpYyBcImFkZCBldmVudCBoYW5kbGVyXCIgZnVuY3Rpb24uXHJcbiAqIFxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgeW91IHRvIG1vZGlmeSBhIHNldCBvZiBwcm9wcyB0byBhcHBseSB0aGlzIGhhbmRsZXIuXHJcbiAqIFxyXG4gKiBGb3IgdHlwaW5nIHJlYXNvbnMsIHRoaXMgZnVuY3Rpb24gaXMgc3BsaXQgaW50byB0d28uICBVc2FnZSBpcyBsaWtlIHRoZSBmb2xsb3dpbmc6XHJcbiAqIFxyXG4gKiBgYGBcclxuICogY29uc3QgeyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH0gPSB1c2VMb2NhbEV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4oKShcIm9uTW91c2VEb3duXCIsIGUgPT4geyAgfSk7XHJcbiAqIGNvbnN0IGRpdlByb3BzID0gdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyhwcm9wcyk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvY2FsSGFuZGxlcjxFbGVtZW50VHlwZSBleHRlbmRzIChIVE1MRWxlbWVudFRhZ05hbWVNYXBba2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwXSB8IFNWR0VsZW1lbnRUYWdOYW1lTWFwW2tleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwXSk+KCkge1xyXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKDxFdmVudFR5cGUgZXh0ZW5kcyBFeGNsdWRlPGtleW9mIGguSlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+LCBrZXlvZiBQcmVhY3RET01BdHRyaWJ1dGVzPj4odHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBOb25OdWxsYWJsZTxoLkpTWC5ET01BdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPltFdmVudFR5cGVdPikgPT4ge1xyXG5cclxuICAgICAgICBjb25zdCBzdGFibGVIYW5kbGVyID0gdXNlU3RhYmxlQ2FsbGJhY2soaGFuZGxlcik7XHJcblxyXG4gICAgICAgIHR5cGUgQXR0cmlidXRlcyA9IChFbGVtZW50VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50ID8gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+IDpcclxuICAgICAgICAgICAgRWxlbWVudFR5cGUgZXh0ZW5kcyBTVkdFbGVtZW50ID8gaC5KU1guU1ZHQXR0cmlidXRlczxFbGVtZW50VHlwZT4gOiBoLkpTWC5ET01BdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPilcclxuXHJcbiAgICAgICAgY29uc3QgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyA9IHVzZUNhbGxiYWNrKDxQIGV4dGVuZHMgQXR0cmlidXRlcz4ocHJvcHM6IFApID0+IHtcclxuICAgICAgICAgICAgdHlwZSBQMiA9IFJlcXVpcmVkPFBpY2s8aC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT4sIEV2ZW50VHlwZT4+O1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RWxlbWVudFR5cGU+KCkoeyBbdHlwZV06IHN0YWJsZUhhbmRsZXIgfSBhcyB7IFtLIGluIEV2ZW50VHlwZV06IHR5cGVvZiBoYW5kbGVyIH0sIHByb3BzKSBhcyBNZXJnZWRQcm9wczxFbGVtZW50VHlwZSwgUDIsIFA+O1xyXG4gICAgICAgIH0sIFt0eXBlXSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgfTtcclxuXHJcbiAgICB9LCBbXSk7XHJcbn1cclxuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJldHVyblRydWUsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xuXG5cbi8qKlxuICogXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCBkaWZmZXJlbnQgd2F5cyB0aGF0IGEgZm9jdXMgZXZlbnQgY2FuIGhhcHBlbi4gIEFzc3VtZVxuICogdGhlIGZvbGxvd2luZyBzdGVwcyBoYXBwZW4gaW4gb3JkZXI6XG4gKiBcbiAqIDEuIFRoZSBwYWdlIGxvYWRzLlxuICogICAgKiBOb3RoaW5nIGlzIGZvY3VzZWQsIGJ1dCBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYGJvZHlgLiBcbiAqICAgICogTm8gZm9jdXMgZXZlbnRzIGFyZSBmaXJlZC5cbiAqIDIuIFRoZSB3aW5kb3cgaXMgZm9jdXNlZCwgYW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgcmVtYWlucyBhcyBgYm9keWAuXG4gKiAgICAqIEEgYGZvY3VzYC9gZm9jdXNpbmAgZXZlbnQgKk1JR0hUKiBiZSBmaXJlZCBmb3IgYGJvZHlgLiBEZXBlbmRpbmcgb25cbiAqICAgICAgdGhlIGJyb3dzZXIsIHRoaXMgZGVwZW5kcyBvbiB3aGV0aGVyIHRoZSBoYW5kbGVyIHdhcyBhdHRhY2hlZCB0byBgd2luZG93YCBvciBgZG9jdW1lbnRgLlxuICogICAgICBQcm9iYWJseSBqdXN0IGJlc3QgdG8gbm90IHJlbHkgb24gaXQsIG9yIGxpc3RlbiB0byBgd2luZG93YCBmb2N1cyBldmVudHMgZGlyZWN0bHkuXG4gKiAzLiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gdGhlIG5ldyBlbGVtZW50IGJlZm9yZSBhbnkgZXZlbnQgZXZlbiBmaXJlcy5cbiAqICAgICogYGZvY3Vzb3V0YCBhbmQgYGJsdXJgIGFyZSAqbm90KiBmaXJlZCBvbiBgYm9keWAuXG4gKiAgICAqIGBmb2N1c2AgYW5kIGBmb2N1c2luYCBhcmUgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cbiAqIDQuIEEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgZXRjLlxuICogICAgKiAqKlRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBgYm9keWAqKiBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG5ldyBlbGVtZW50LlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIG5vdyBzZXQgdG8gdGhlIG5ldyBlbGVtZW50LlxuICogICAgKiBgZm9jdXNpbmAgaXMgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG9sZCBlbGVtZW50LlxuICogNS4gQW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIGBib2R5YC5cbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxuICogICAgKiBgZm9jdXNpbmAgaXMgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxuICogXG4gKiBcbiAqIEluIHN1bW1hcnk6XG4gKiAxLiBGb2N1cyBldmVudHMgKmRvKiBub3RpZnkgdXMgb2YgYWxsIGNoYW5nZXMgaW4gZm9jdXMsIGJ1dCB0aGVyZSBpcyBubyBvbmUgc2luZ2xlIGNvbXByZWhlbnNpdmUgZXZlbnQgdGhhdCBwcm92aWRlcyB1cyB3aXRoIGFsbCBhdmFpbGFibGUgaW5mb3JtYXRpb24uXG4gKiAyLiBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgKmlzIG5vdCogYWx3YXlzIHRoZSBzYW1lIGFzIHdoYXQncyBiZWluZyByZWZlcmVuY2VkIGJ5IGEgZm9jdXMgZXZlbnQuIEluIHBhcnRpY3VsYXIsIGl0IG1heSBiZWNvbWUgYGJvZHlgIGF0IGFueSBhcmJpdHJhcnkgdGltZS5cbiAqIDMuIEEgYGJsdXJgIHdpdGhvdXQgYSBgZm9jdXNgIGNhbiBhbmQgd2lsbCBvY2N1ci4gVGhpcyBtZWFucyBpdCBpcyBub3QgcG9zc2libGUgdG8gc29sZWx5IHVzZSBgZm9jdXNgIHRvIGRldGVjdCBhbGwgY2hhbmdlcy5cbiAqIDQuIEEgYGJsdXJgIGV2ZW50IHdob3NlIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsIGluZGljYXRlcyB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gZm9sbG93aW5nIGBmb2N1c2AgZXZlbnQuXG4gKiBcbiAqIFxuICogQHBhcmFtIGNhbGxiYWNrIFxuICogQHJldHVybnMgXG4gKi9cbmNvbnN0IF9kdW1teSA9IDA7XG5cbmNvbnN0IGFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogTm9kZSB8IG51bGwpID0+IHZvaWQpPj4oKTtcbmNvbnN0IGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGU6IE5vZGUpID0+IHZvaWQpPj4oKTtcbmNvbnN0IHdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZm9jdXNlZDogYm9vbGVhbikgPT4gdm9pZCk+PigpO1xuY29uc3Qgd2luZG93c0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgYm9vbGVhbj4oKTtcblxuZnVuY3Rpb24gZm9yRWFjaFVwZGF0ZXI8VD4od2luZG93OiBXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBtYXA6IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBUKSA9PiB2b2lkKT4+LCB2YWx1ZTogVCkge1xuICAgIGZvciAoY29uc3QgW290aGVyV2luZG93LCB1cGRhdGVyc10gb2YgbWFwKSB7XG4gICAgICAgIGlmICh3aW5kb3cgPT09IG90aGVyV2luZG93KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZXIgb2YgdXBkYXRlcnMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyPy4odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb2N1c291dChlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cbiAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIG51bGwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSnVzdCB3YWl0IGZvciB0aGUgZm9jdXNpbiBldmVudC5cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gZm9jdXNpbihlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgY29uc3QgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQgPSBlLnRhcmdldCBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHdpbmRvd0ZvY3VzKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIHRydWUpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gd2luZG93Qmx1cihlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS50YXJnZXQgOiBlLmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLmN1cnJlbnRUYXJnZXQgOiAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyk7XG4gICAgd2luZG93c0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCBmYWxzZSk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMsIGZhbHNlKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyczxUIGV4dGVuZHMgTm9kZT4ge1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbD47XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMgYW5kIGlzIG5vdCBudWxsLiBcbiAgICAgKiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8VD47XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIHdpbmRvdyBnYWlucy9sb3NlcyBmb2N1cy4gTXVzdCBiZSBzdGFibGUuXG4gICAgICovXG4gICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8Ym9vbGVhbj47XG5cbiAgICBvbk1vdW50PzogVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD5bXCJvbk1vdW50XCJdO1xuICAgIG9uVW5tb3VudD86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+W1wib25Vbm1vdW50XCJdO1xuICAgIG9uTW91bnRDaGFuZ2U/OiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPltcIm9uRWxlbWVudENoYW5nZVwiXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY3RpdmVFbGVtZW50UmV0dXJuVHlwZTxUIGV4dGVuZHMgTm9kZT4gZXh0ZW5kcyBPbWl0PFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+LCBcInVzZVJlZkVsZW1lbnRQcm9wc1wiPiB7XG4gICAgLyoqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3IgYG51bGxgIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50ICovXG4gICAgZ2V0QWN0aXZlRWxlbWVudDogKCkgPT4gVCB8IG51bGw7XG4gICAgLyoqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3Igd2hhdGV2ZXIgZWxlbWVudCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50ICovXG4gICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQ6ICgpID0+IFQ7XG4gICAgLyoqIFJldHVybnMgaWYgdGhlIHdpbmRvdyBpdHNlbGYgaGFzIGZvY3VzIG9yIG5vdCAqL1xuICAgIGdldFdpbmRvd0ZvY3VzZWQ6ICgpID0+IGJvb2xlYW47XG5cbiAgICB1c2VBY3RpdmVFbGVtZW50UHJvcHM6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+W1widXNlUmVmRWxlbWVudFByb3BzXCJdO1xufVxuXG4vKipcbiAqIEFsbG93cyB5b3UgdG8gaW5zcGVjdCB3aGljaCBlbGVtZW50IGluIHRoZSBgZG9jdW1lbnRgIGN1cnJlbnRseSBoYXMgZm9jdXMsIHdoaWNoIHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgbm9uZSBhcmUgY3VycmVudGx5LCBhbmQgd2hldGhlciBvciBub3QgdGhlIHdpbmRvdyBoYXMgZm9jdXMgYnkgcmV0dXJuaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICogKiBgZ2V0QWN0aXZlRWxlbWVudCgpYFxuICogKiBgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQoKWBcbiAqICogYGdldFdpbmRvd0ZvY3VzZWQoKWBcbiAqIFxuICogKFRoZSBkb2N1bWVudCdzIGJvZHkgcmVjZWl2aW5nIGZvY3VzLCBsaWtlIGl0IGRvZXMgd2hlbiB5b3UgY2xpY2sgb24gYW4gZW1wdHkgYXJlYSwgaXMgY291bnRlZCBhcyBubyBlbGVtZW50IGhhdmluZyBmb2N1cyBmb3IgYWxsIGludGVudHMgYW5kIHB1cnBvc2VzKVxuICogXG4gKiBUaGlzIGlzIGEgcGFzc2l2ZSBob29rLCBzbyBieSBkZWZhdWx0IGl0IHJldHVybnMgZ2V0dGVyIGZ1bmN0aW9ucyB0aGF0IHJlcG9ydCB0aGlzIGluZm9ybWF0aW9uIGJ1dCB0aGUgY29tcG9uZW50IHdpbGwgbm90IHJlLXJlbmRlciBieSBkZWZhdWx0IHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMuXG4gKiBcbiAqIElmIHlvdSBuZWVkIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMsIHVzZSB0aGUgYG9uKkNoYW5nZWAgYXJndW1lbnRzIHRvIHNldCBzb21lIHN0YXRlIG9uIHlvdXIgZW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aXZlRWxlbWVudDxUIGV4dGVuZHMgTm9kZT4oeyBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50LCBvbk1vdW50Q2hhbmdlIH06IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzPFQ+KTogVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGU8VD4ge1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlQWN0aXZlRWxlbWVudFwiLCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgb25Nb3VudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50KTtcblxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHtcbiAgICAgICAgb25Nb3VudCwgXG4gICAgICAgIG9uVW5tb3VudCxcbiAgICAgICAgb25FbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoZWxlbWVudDogVCB8IG51bGwsIHByZXZWYWx1ZTogVCB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgIG9uTW91bnRDaGFuZ2U/LihlbGVtZW50LCBwcmV2VmFsdWUpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgICAgICBjb25zdCB3aW5kb3cgPSBkb2N1bWVudD8uZGVmYXVsdFZpZXc7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KT8uc2l6ZSA/PyAwKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbiwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1ciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGVtIGV2ZW4gaWYgdGhleSdyZSB1bmRlZmluZWQgdG8gbW9yZSBlYXNpbHlcbiAgICAgICAgICAgICAgICAvLyBtYW5hZ2UgdGhlIFwiPjAgbWVhbnMgZG9uJ3QgYWRkIGhhbmRsZXJzXCIgbG9naWMuXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzID0gd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcblxuICAgICAgICAgICAgICAgIGxvY2FsQWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChzZXRBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlIHwgbnVsbD4pO1xuICAgICAgICAgICAgICAgIGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5hZGQoc2V0TGFzdEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGU+KTtcbiAgICAgICAgICAgICAgICBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycy5hZGQoc2V0V2luZG93Rm9jdXNlZCk7XG5cbiAgICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xuICAgICAgICAgICAgICAgIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzKTtcbiAgICAgICAgICAgICAgICB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUoc2V0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZSB8IG51bGw+KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKHNldExhc3RBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlPik7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKHNldFdpbmRvd0ZvY3VzZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGZvY3VzaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBmb2N1c291dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHdpbmRvd0JsdXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSlcbiAgICB9KVxuXG4gICAgY29uc3QgW2dldEFjdGl2ZUVsZW1lbnQsIHNldEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPFQgfCBudWxsPihvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwpO1xuICAgIGNvbnN0IFtnZXRMYXN0QWN0aXZlRWxlbWVudCwgc2V0TGFzdEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPFQ+KG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwgYXMgKCkgPT4gbmV2ZXIpO1xuICAgIGNvbnN0IFtnZXRXaW5kb3dGb2N1c2VkLCBzZXRXaW5kb3dGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIHJldHVyblRydWUpO1xuXG4gICAgcmV0dXJuIHsgZ2V0RWxlbWVudCwgdXNlQWN0aXZlRWxlbWVudFByb3BzOiB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEFjdGl2ZUVsZW1lbnQsIGdldExhc3RBY3RpdmVFbGVtZW50LCBnZXRXaW5kb3dGb2N1c2VkIH07XG59XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUludGVydmFsIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2AuXG4gICAgICovXG4gICAgaW50ZXJ2YWw6IG51bWJlciB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYHRpbWVvdXRgIG1zIGFmdGVyIG1vdW50LCBvciB0aGUgbGFzdCBjaGFuZ2UgdG8gYHRyaWdnZXJJbmRleGAuXG4gICAgICovXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnRlcnZhbCh7IGludGVydmFsLCBjYWxsYmFjayB9OiBVc2VJbnRlcnZhbCkge1xuICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSBnaXZlbiBjYWxsYmFjayB0aGF0J3Mgc3RhYmxlXG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgY29uc3QgZ2V0SW50ZXJ2YWwgPSB1c2VTdGFibGVHZXR0ZXIoaW50ZXJ2YWwpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBnZXRJbnRlcnZhbCgpO1xuICAgICAgICBsZXQgbGFzdERlbGF5VXNlZCA9IGludGVydmFsO1xuXG4gICAgICAgIGlmIChpbnRlcnZhbCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG5cbiAgICAgICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIHdyYXBwZXIgYXJvdW5kIHRoZSBjYWxsYmFja1xuICAgICAgICAvLyB0aGF0IGNsZWFycyBhbmQgcmVzZXRzIHRoZSBpbnRlcnZhbCBpZiBpdCBjaGFuZ2VzLlxuICAgICAgICBjb25zdCBhZGp1c3RhYmxlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBzdGFibGVDYWxsYmFjaygpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEludGVydmFsID0gZ2V0SW50ZXJ2YWwoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW50ZXJ2YWwgIT0gbGFzdERlbGF5VXNlZCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEludGVydmFsICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHNldEludGVydmFsKGFkanVzdGFibGVDYWxsYmFjaywgbGFzdERlbGF5VXNlZCA9IGN1cnJlbnRJbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhbmRsZSA9IHNldEludGVydmFsKGFkanVzdGFibGVDYWxsYmFjaywgaW50ZXJ2YWwpO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChoYW5kbGUpO1xuICAgIH0sIFtdKTtcbn1cblxuIiwiY29uc3QgY2FuZGlkYXRlU2VsZWN0b3JzID0gW1xuICAnaW5wdXQnLFxuICAnc2VsZWN0JyxcbiAgJ3RleHRhcmVhJyxcbiAgJ2FbaHJlZl0nLFxuICAnYnV0dG9uJyxcbiAgJ1t0YWJpbmRleF06bm90KHNsb3QpJyxcbiAgJ2F1ZGlvW2NvbnRyb2xzXScsXG4gICd2aWRlb1tjb250cm9sc10nLFxuICAnW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSknLFxuICAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnLFxuICAnZGV0YWlscycsXG5dO1xuY29uc3QgY2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi8gY2FuZGlkYXRlU2VsZWN0b3JzLmpvaW4oJywnKTtcblxuY29uc3QgTm9FbGVtZW50ID0gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnO1xuXG5jb25zdCBtYXRjaGVzID0gTm9FbGVtZW50XG4gID8gZnVuY3Rpb24gKCkge31cbiAgOiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cbmNvbnN0IGdldFJvb3ROb2RlID1cbiAgIU5vRWxlbWVudCAmJiBFbGVtZW50LnByb3RvdHlwZS5nZXRSb290Tm9kZVxuICAgID8gKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKVxuICAgIDogKGVsZW1lbnQpID0+IGVsZW1lbnQub3duZXJEb2N1bWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIGNvbnRhaW5lciB0byBjaGVjayBpblxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgdG8gY2hlY2tcbiAqIEBwYXJhbSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xuICogQHJldHVybnMge0VsZW1lbnRbXX1cbiAqL1xuY29uc3QgZ2V0Q2FuZGlkYXRlcyA9IGZ1bmN0aW9uIChlbCwgaW5jbHVkZUNvbnRhaW5lciwgZmlsdGVyKSB7XG4gIGxldCBjYW5kaWRhdGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KFxuICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2FuZGlkYXRlU2VsZWN0b3IpXG4gICk7XG4gIGlmIChpbmNsdWRlQ29udGFpbmVyICYmIG1hdGNoZXMuY2FsbChlbCwgY2FuZGlkYXRlU2VsZWN0b3IpKSB7XG4gICAgY2FuZGlkYXRlcy51bnNoaWZ0KGVsKTtcbiAgfVxuICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5maWx0ZXIoZmlsdGVyKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBHZXRTaGFkb3dSb290XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdG8gY2hlY2sgZm9yIHNoYWRvdyByb290XG4gKiBAcmV0dXJucyB7U2hhZG93Um9vdHxib29sZWFufSBTaGFkb3dSb290IGlmIGF2YWlsYWJsZSBvciBib29sZWFuIGluZGljYXRpbmcgaWYgYSBzaGFkb3dSb290IGlzIGF0dGFjaGVkIGJ1dCBub3QgYXZhaWxhYmxlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFNoYWRvd1Jvb3RGaWx0ZXJcbiAqIEBwYXJhbSB7RWxlbWVudH0gc2hhZG93SG9zdE5vZGUgdGhlIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgc2hhZG93IGNvbnRlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGEgc2hhZG93IHJvb3QgY291bGQgcG90ZW50aWFsbHkgY29udGFpbiB2YWxpZCBjYW5kaWRhdGVzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2FuZGlkYXRlc1Njb3BlXG4gKiBAcHJvcGVydHkge0VsZW1lbnR9IHNjb3BlIGNvbnRhaW5zIGlubmVyIGNhbmRpZGF0ZXNcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudFtdfSBjYW5kaWRhdGVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJdGVyYXRpdmVPcHRpb25zXG4gKiBAcHJvcGVydHkge0dldFNoYWRvd1Jvb3R8Ym9vbGVhbn0gZ2V0U2hhZG93Um9vdCB0cnVlIGlmIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQ7IGZhbHN5IGlmIG5vdDtcbiAqICBpZiBhIGZ1bmN0aW9uLCBpbXBsaWVzIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQgYW5kIGVpdGhlciByZXR1cm5zIHRoZSBzaGFkb3cgcm9vdCBvZiBhbiBlbGVtZW50XG4gKiAgb3IgYSBib29sZWFuIHN0YXRpbmcgaWYgaXQgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyByb290XG4gKiBAcHJvcGVydHkgeyhub2RlOiBFbGVtZW50KSA9PiBib29sZWFufSBmaWx0ZXIgZmlsdGVyIGNhbmRpZGF0ZXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmxhdHRlbiBpZiB0cnVlIHRoZW4gcmVzdWx0IHdpbGwgZmxhdHRlbiBhbnkgQ2FuZGlkYXRlc1Njb3BlIGludG8gdGhlIHJldHVybmVkIGxpc3RcbiAqIEBwcm9wZXJ0eSB7U2hhZG93Um9vdEZpbHRlcn0gc2hhZG93Um9vdEZpbHRlciBmaWx0ZXIgc2hhZG93IHJvb3RzO1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50W119IGVsZW1lbnRzIGxpc3Qgb2YgZWxlbWVudCBjb250YWluZXJzIHRvIG1hdGNoIGNhbmRpZGF0ZXMgZnJvbVxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgbGlzdCB0byBjaGVja1xuICogQHBhcmFtIHtJdGVyYXRpdmVPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlc1Njb3BlPn1cbiAqL1xuY29uc3QgZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5ID0gZnVuY3Rpb24gKFxuICBlbGVtZW50cyxcbiAgaW5jbHVkZUNvbnRhaW5lcixcbiAgb3B0aW9uc1xuKSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbXTtcbiAgY29uc3QgZWxlbWVudHNUb0NoZWNrID0gQXJyYXkuZnJvbShlbGVtZW50cyk7XG4gIHdoaWxlIChlbGVtZW50c1RvQ2hlY2subGVuZ3RoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzVG9DaGVjay5zaGlmdCgpO1xuICAgIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdTTE9UJykge1xuICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2xvdCBzY29wZSAoc2xvdCBpdHNlbGYgY2Fubm90IGJlIGZvY3VzYWJsZSlcbiAgICAgIGNvbnN0IGFzc2lnbmVkID0gZWxlbWVudC5hc3NpZ25lZEVsZW1lbnRzKCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gYXNzaWduZWQubGVuZ3RoID8gYXNzaWduZWQgOiBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgY29uc3QgbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShjb250ZW50LCB0cnVlLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKC4uLm5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBzY29wZTogZWxlbWVudCxcbiAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2hlY2sgY2FuZGlkYXRlIGVsZW1lbnRcbiAgICAgIGNvbnN0IHZhbGlkQ2FuZGlkYXRlID0gbWF0Y2hlcy5jYWxsKGVsZW1lbnQsIGNhbmRpZGF0ZVNlbGVjdG9yKTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsaWRDYW5kaWRhdGUgJiZcbiAgICAgICAgb3B0aW9ucy5maWx0ZXIoZWxlbWVudCkgJiZcbiAgICAgICAgKGluY2x1ZGVDb250YWluZXIgfHwgIWVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKVxuICAgICAgKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gaXRlcmF0ZSBvdmVyIHNoYWRvdyBjb250ZW50IGlmIHBvc3NpYmxlXG4gICAgICBjb25zdCBzaGFkb3dSb290ID1cbiAgICAgICAgZWxlbWVudC5zaGFkb3dSb290IHx8XG4gICAgICAgIC8vIGNoZWNrIGZvciBhbiB1bmRpc2Nsb3NlZCBzaGFkb3dcbiAgICAgICAgKHR5cGVvZiBvcHRpb25zLmdldFNoYWRvd1Jvb3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICBvcHRpb25zLmdldFNoYWRvd1Jvb3QoZWxlbWVudCkpO1xuXG4gICAgICBjb25zdCB2YWxpZFNoYWRvd1Jvb3QgPVxuICAgICAgICAhb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyIHx8IG9wdGlvbnMuc2hhZG93Um9vdEZpbHRlcihlbGVtZW50KTtcblxuICAgICAgaWYgKHNoYWRvd1Jvb3QgJiYgdmFsaWRTaGFkb3dSb290KSB7XG4gICAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNjb3BlIElJRiBhIHNoYWRvdyByb290IG5vZGUgd2FzIGdpdmVuOyBvdGhlcndpc2UsIGFuIHVuZGlzY2xvc2VkXG4gICAgICAgIC8vICBzaGFkb3cgZXhpc3RzLCBzbyBsb29rIGF0IGxpZ2h0IGRvbSBjaGlsZHJlbiBhcyBmYWxsYmFjayBCVVQgY3JlYXRlIGEgc2NvcGUgZm9yIGFueVxuICAgICAgICAvLyAgY2hpbGQgY2FuZGlkYXRlcyBmb3VuZCBiZWNhdXNlIHRoZXkncmUgbGlrZWx5IHNsb3R0ZWQgZWxlbWVudHMgKGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgICAgIC8vICBjaGlsZHJlbiBvZiB0aGUgd2ViIGNvbXBvbmVudCBlbGVtZW50ICh3aGljaCBoYXMgdGhlIHNoYWRvdyksIGluIHRoZSBsaWdodCBkb20sIGJ1dFxuICAgICAgICAvLyAgc2xvdHRlZCBzb21ld2hlcmUgX2luc2lkZV8gdGhlIHVuZGlzY2xvc2VkIHNoYWRvdykgLS0gdGhlIHNjb3BlIGlzIGNyZWF0ZWQgYmVsb3csXG4gICAgICAgIC8vICBfYWZ0ZXJfIHdlIHJldHVybiBmcm9tIHRoaXMgcmVjdXJzaXZlIGNhbGxcbiAgICAgICAgY29uc3QgbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShcbiAgICAgICAgICBzaGFkb3dSb290ID09PSB0cnVlID8gZWxlbWVudC5jaGlsZHJlbiA6IHNoYWRvd1Jvb3QuY2hpbGRyZW4sXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5uZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgICAgc2NvcGU6IGVsZW1lbnQsXG4gICAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVyZSdzIG5vdCBzaGFkb3cgc28ganVzdCBkaWcgaW50byB0aGUgZWxlbWVudCdzIChsaWdodCBkb20pIGNoaWxkcmVuXG4gICAgICAgIC8vICBfX3dpdGhvdXRfXyBnaXZpbmcgdGhlIGVsZW1lbnQgc3BlY2lhbCBzY29wZSB0cmVhdG1lbnRcbiAgICAgICAgZWxlbWVudHNUb0NoZWNrLnVuc2hpZnQoLi4uZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuY29uc3QgZ2V0VGFiaW5kZXggPSBmdW5jdGlvbiAobm9kZSwgaXNTY29wZSkge1xuICBpZiAobm9kZS50YWJJbmRleCA8IDApIHtcbiAgICAvLyBpbiBDaHJvbWUsIDxkZXRhaWxzLz4sIDxhdWRpbyBjb250cm9scy8+IGFuZCA8dmlkZW8gY29udHJvbHMvPiBlbGVtZW50cyBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAtMSB3aGVuIHRoZSAndGFiaW5kZXgnIGF0dHJpYnV0ZSBpc24ndCBzcGVjaWZpZWQgaW4gdGhlIERPTSxcbiAgICAvLyB5ZXQgdGhleSBhcmUgc3RpbGwgcGFydCBvZiB0aGUgcmVndWxhciB0YWIgb3JkZXI7IGluIEZGLCB0aGV5IGdldCBhIGRlZmF1bHRcbiAgICAvLyBgdGFiSW5kZXhgIG9mIDA7IHNpbmNlIENocm9tZSBzdGlsbCBwdXRzIHRob3NlIGVsZW1lbnRzIGluIHRoZSByZWd1bGFyIHRhYlxuICAgIC8vIG9yZGVyLCBjb25zaWRlciB0aGVpciB0YWIgaW5kZXggdG8gYmUgMC5cbiAgICAvLyBBbHNvIGJyb3dzZXJzIGRvIG5vdCByZXR1cm4gYHRhYkluZGV4YCBjb3JyZWN0bHkgZm9yIGNvbnRlbnRFZGl0YWJsZSBub2RlcztcbiAgICAvLyBzbyBpZiB0aGV5IGRvbid0IGhhdmUgYSB0YWJpbmRleCBhdHRyaWJ1dGUgc3BlY2lmaWNhbGx5IHNldCwgYXNzdW1lIGl0J3MgMC5cbiAgICAvL1xuICAgIC8vIGlzU2NvcGUgaXMgcG9zaXRpdmUgZm9yIGN1c3RvbSBlbGVtZW50IHdpdGggc2hhZG93IHJvb3Qgb3Igc2xvdCB0aGF0IGJ5IGRlZmF1bHRcbiAgICAvLyBoYXZlIHRhYkluZGV4IC0xLCBidXQgbmVlZCB0byBiZSBzb3J0ZWQgYnkgZG9jdW1lbnQgb3JkZXIgaW4gb3JkZXIgZm9yIHRoZWlyXG4gICAgLy8gY29udGVudCB0byBiZSBpbnNlcnRlZCBpbiB0aGUgY29ycmVjdCBwb3NpdGlvblxuICAgIGlmIChcbiAgICAgIChpc1Njb3BlIHx8XG4gICAgICAgIC9eKEFVRElPfFZJREVPfERFVEFJTFMpJC8udGVzdChub2RlLnRhZ05hbWUpIHx8XG4gICAgICAgIG5vZGUuaXNDb250ZW50RWRpdGFibGUpICYmXG4gICAgICBpc05hTihwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApKVxuICAgICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGUudGFiSW5kZXg7XG59O1xuXG5jb25zdCBzb3J0T3JkZXJlZFRhYmJhYmxlcyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBhLnRhYkluZGV4ID09PSBiLnRhYkluZGV4XG4gICAgPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXJcbiAgICA6IGEudGFiSW5kZXggLSBiLnRhYkluZGV4O1xufTtcblxuY29uc3QgaXNJbnB1dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdJTlBVVCc7XG59O1xuXG5jb25zdCBpc0hpZGRlbklucHV0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAnaGlkZGVuJztcbn07XG5cbmNvbnN0IGlzRGV0YWlsc1dpdGhTdW1tYXJ5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgY29uc3QgciA9XG4gICAgbm9kZS50YWdOYW1lID09PSAnREVUQUlMUycgJiZcbiAgICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgIC5hcHBseShub2RlLmNoaWxkcmVuKVxuICAgICAgLnNvbWUoKGNoaWxkKSA9PiBjaGlsZC50YWdOYW1lID09PSAnU1VNTUFSWScpO1xuICByZXR1cm4gcjtcbn07XG5cbmNvbnN0IGdldENoZWNrZWRSYWRpbyA9IGZ1bmN0aW9uIChub2RlcywgZm9ybSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldLmNoZWNrZWQgJiYgbm9kZXNbaV0uZm9ybSA9PT0gZm9ybSkge1xuICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgaXNUYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKCFub2RlLm5hbWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCByYWRpb1Njb3BlID0gbm9kZS5mb3JtIHx8IGdldFJvb3ROb2RlKG5vZGUpO1xuICBjb25zdCBxdWVyeVJhZGlvcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHJhZGlvU2NvcGUucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBuYW1lICsgJ1wiXSdcbiAgICApO1xuICB9O1xuXG4gIGxldCByYWRpb1NldDtcbiAgaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5DU1MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJhZGlvU2V0ID0gcXVlcnlSYWRpb3Mod2luZG93LkNTUy5lc2NhcGUobm9kZS5uYW1lKSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHJhZGlvU2V0ID0gcXVlcnlSYWRpb3Mobm9kZS5uYW1lKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnTG9va3MgbGlrZSB5b3UgaGF2ZSBhIHJhZGlvIGJ1dHRvbiB3aXRoIGEgbmFtZSBhdHRyaWJ1dGUgY29udGFpbmluZyBpbnZhbGlkIENTUyBzZWxlY3RvciBjaGFyYWN0ZXJzIGFuZCBuZWVkIHRoZSBDU1MuZXNjYXBlIHBvbHlmaWxsOiAlcycsXG4gICAgICAgIGVyci5tZXNzYWdlXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNoZWNrZWQgPSBnZXRDaGVja2VkUmFkaW8ocmFkaW9TZXQsIG5vZGUuZm9ybSk7XG4gIHJldHVybiAhY2hlY2tlZCB8fCBjaGVja2VkID09PSBub2RlO1xufTtcblxuY29uc3QgaXNSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ3JhZGlvJztcbn07XG5cbmNvbnN0IGlzTm9uVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc1JhZGlvKG5vZGUpICYmICFpc1RhYmJhYmxlUmFkaW8obm9kZSk7XG59O1xuXG5jb25zdCBpc1plcm9BcmVhID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gd2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwO1xufTtcbmNvbnN0IGlzSGlkZGVuID0gZnVuY3Rpb24gKG5vZGUsIHsgZGlzcGxheUNoZWNrLCBnZXRTaGFkb3dSb290IH0pIHtcbiAgLy8gTk9URTogdmlzaWJpbGl0eSB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIG5vZGUgaXMgZGV0YWNoZWQgZnJvbSB0aGUgZG9jdW1lbnRcbiAgLy8gIChzZWUgbm90ZXMgYWJvdXQgdGhpcyBmdXJ0aGVyIGRvd24pLCB3aGljaCBtZWFucyB3ZSB3aWxsIGNvbnNpZGVyIGl0IHZpc2libGVcbiAgLy8gICh0aGlzIGlzIGxlZ2FjeSBiZWhhdmlvciBmcm9tIGEgdmVyeSBsb25nIHdheSBiYWNrKVxuICAvLyBOT1RFOiB3ZSBjaGVjayB0aGlzIHJlZ2FyZGxlc3Mgb2YgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgYmVjYXVzZSB0aGlzIGlzIGFcbiAgLy8gIF92aXNpYmlsaXR5XyBjaGVjaywgbm90IGEgX2Rpc3BsYXlfIGNoZWNrXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBpc0RpcmVjdFN1bW1hcnkgPSBtYXRjaGVzLmNhbGwobm9kZSwgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyk7XG4gIGNvbnN0IG5vZGVVbmRlckRldGFpbHMgPSBpc0RpcmVjdFN1bW1hcnkgPyBub2RlLnBhcmVudEVsZW1lbnQgOiBub2RlO1xuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGVVbmRlckRldGFpbHMsICdkZXRhaWxzOm5vdChbb3Blbl0pIConKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVGhlIHJvb3Qgbm9kZSBpcyB0aGUgc2hhZG93IHJvb3QgaWYgdGhlIG5vZGUgaXMgaW4gYSBzaGFkb3cgRE9NOyBzb21lIGRvY3VtZW50IG90aGVyd2lzZVxuICAvLyAgKGJ1dCBOT1QgX3RoZV8gZG9jdW1lbnQ7IHNlZSBzZWNvbmQgJ0lmJyBjb21tZW50IGJlbG93IGZvciBtb3JlKS5cbiAgLy8gSWYgcm9vdE5vZGUgaXMgc2hhZG93IHJvb3QsIGl0J2xsIGhhdmUgYSBob3N0LCB3aGljaCBpcyB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgc2hhZG93XG4gIC8vICBpcyBhdHRhY2hlZCwgYW5kIHRoZSBvbmUgd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIGluIHRoZSBkb2N1bWVudCBvciBub3QgKGJlY2F1c2UgdGhlXG4gIC8vICBzaGFkb3csIGFuZCBhbGwgbm9kZXMgaXQgY29udGFpbnMsIGlzIG5ldmVyIGNvbnNpZGVyZWQgaW4gdGhlIGRvY3VtZW50IHNpbmNlIHNoYWRvd3NcbiAgLy8gIGJlaGF2ZSBsaWtlIHNlbGYtY29udGFpbmVkIERPTXM7IGJ1dCBpZiB0aGUgc2hhZG93J3MgSE9TVCwgd2hpY2ggaXMgcGFydCBvZiB0aGUgZG9jdW1lbnQsXG4gIC8vICBpcyBoaWRkZW4sIG9yIGlzIG5vdCBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmIGJ1dCBpcyBkZXRhY2hlZCwgaXQgd2lsbCBhZmZlY3QgdGhlIHNoYWRvdydzXG4gIC8vICB2aXNpYmlsaXR5LCBpbmNsdWRpbmcgYWxsIHRoZSBub2RlcyBpdCBjb250YWlucykuIFRoZSBob3N0IGNvdWxkIGJlIGFueSBub3JtYWwgbm9kZSxcbiAgLy8gIG9yIGEgY3VzdG9tIGVsZW1lbnQgKGkuZS4gd2ViIGNvbXBvbmVudCkuIEVpdGhlciB3YXksIHRoYXQncyB0aGUgb25lIHRoYXQgaXMgY29uc2lkZXJlZFxuICAvLyAgcGFydCBvZiB0aGUgZG9jdW1lbnQsIG5vdCB0aGUgc2hhZG93IHJvb3QsIG5vciBhbnkgb2YgaXRzIGNoaWxkcmVuIChpLmUuIHRoZSBub2RlIGJlaW5nXG4gIC8vICB0ZXN0ZWQpLlxuICAvLyBJZiByb290Tm9kZSBpcyBub3QgYSBzaGFkb3cgcm9vdCwgaXQgd29uJ3QgaGF2ZSBhIGhvc3QsIGFuZCBzbyByb290Tm9kZSBzaG91bGQgYmUgdGhlXG4gIC8vICBkb2N1bWVudCAocGVyIHRoZSBkb2NzKSBhbmQgd2hpbGUgaXQncyBhIERvY3VtZW50LXR5cGUgb2JqZWN0LCB0aGF0IGRvY3VtZW50IGRvZXMgbm90XG4gIC8vICBhcHBlYXIgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG5vZGUncyBgb3duZXJEb2N1bWVudGAgZm9yIHNvbWUgcmVhc29uLCBzbyBpdCdzIHNhZmVyXG4gIC8vICB0byBpZ25vcmUgdGhlIHJvb3ROb2RlIGF0IHRoaXMgcG9pbnQsIGFuZCB1c2UgYG5vZGUub3duZXJEb2N1bWVudGAuIE90aGVyd2lzZSxcbiAgLy8gIHVzaW5nIGByb290Tm9kZS5jb250YWlucyhub2RlKWAgd2lsbCBfYWx3YXlzXyBiZSB0cnVlIHdlJ2xsIGdldCBmYWxzZS1wb3NpdGl2ZXMgd2hlblxuICAvLyAgbm9kZSBpcyBhY3R1YWxseSBkZXRhY2hlZC5cbiAgY29uc3Qgbm9kZVJvb3RIb3N0ID0gZ2V0Um9vdE5vZGUobm9kZSkuaG9zdDtcbiAgY29uc3Qgbm9kZUlzQXR0YWNoZWQgPVxuICAgIG5vZGVSb290SG9zdD8ub3duZXJEb2N1bWVudC5jb250YWlucyhub2RlUm9vdEhvc3QpIHx8XG4gICAgbm9kZS5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGUpO1xuXG4gIGlmICghZGlzcGxheUNoZWNrIHx8IGRpc3BsYXlDaGVjayA9PT0gJ2Z1bGwnKSB7XG4gICAgaWYgKHR5cGVvZiBnZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBmaWd1cmUgb3V0IGlmIHdlIHNob3VsZCBjb25zaWRlciB0aGUgbm9kZSB0byBiZSBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgYW5kIHVzZSB0aGVcbiAgICAgIC8vICAnbm9uLXplcm8tYXJlYScgZmFsbGJhY2tcbiAgICAgIGNvbnN0IG9yaWdpbmFsTm9kZSA9IG5vZGU7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICBjb25zdCByb290Tm9kZSA9IGdldFJvb3ROb2RlKG5vZGUpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcGFyZW50RWxlbWVudCAmJlxuICAgICAgICAgICFwYXJlbnRFbGVtZW50LnNoYWRvd1Jvb3QgJiZcbiAgICAgICAgICBnZXRTaGFkb3dSb290KHBhcmVudEVsZW1lbnQpID09PSB0cnVlIC8vIGNoZWNrIGlmIHRoZXJlJ3MgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5vZGUgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyB3aGljaCBtZWFucyB3ZSBjYW4gb25seSB0cmVhdCBpdCBhcyBhIGJsYWNrIGJveCwgc28gd2VcbiAgICAgICAgICAvLyAgZmFsbCBiYWNrIHRvIGEgbm9uLXplcm8tYXJlYSB0ZXN0XG4gICAgICAgICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIHNsb3RcbiAgICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmVudEVsZW1lbnQgJiYgcm9vdE5vZGUgIT09IG5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgIC8vIGNyb3NzIHNoYWRvdyBib3VuZGFyeVxuICAgICAgICAgIG5vZGUgPSByb290Tm9kZS5ob3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgbm9ybWFsIGRvbVxuICAgICAgICAgIG5vZGUgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBvcmlnaW5hbE5vZGU7XG4gICAgfVxuICAgIC8vIGVsc2UsIGBnZXRTaGFkb3dSb290YCBtaWdodCBiZSB0cnVlLCBidXQgYWxsIHRoYXQgZG9lcyBpcyBlbmFibGUgc2hhZG93IERPTSBzdXBwb3J0XG4gICAgLy8gIChpLmUuIGl0IGRvZXMgbm90IGFsc28gcHJlc3VtZSB0aGF0IGFsbCBub2RlcyBtaWdodCBoYXZlIHVuZGlzY2xvc2VkIHNoYWRvd3MpOyBvclxuICAgIC8vICBpdCBtaWdodCBiZSBhIGZhbHN5IHZhbHVlLCB3aGljaCBtZWFucyBzaGFkb3cgRE9NIHN1cHBvcnQgaXMgZGlzYWJsZWRcblxuICAgIC8vIFNpbmNlIHdlIGRpZG4ndCBmaW5kIGl0IHNpdHRpbmcgaW4gYW4gdW5kaXNjbG9zZWQgc2hhZG93IChvciBzaGFkb3dzIGFyZSBkaXNhYmxlZClcbiAgICAvLyAgbm93IHdlIGNhbiBqdXN0IHRlc3QgdG8gc2VlIGlmIGl0IHdvdWxkIG5vcm1hbGx5IGJlIHZpc2libGUgb3Igbm90LCBwcm92aWRlZCBpdCdzXG4gICAgLy8gIGF0dGFjaGVkIHRvIHRoZSBtYWluIGRvY3VtZW50LlxuICAgIC8vIE5PVEU6IFdlIG11c3QgY29uc2lkZXIgY2FzZSB3aGVyZSBub2RlIGlzIGluc2lkZSBhIHNoYWRvdyBET00gYW5kIGdpdmVuIGRpcmVjdGx5IHRvXG4gICAgLy8gIGBpc1RhYmJhYmxlKClgIG9yIGBpc0ZvY3VzYWJsZSgpYCAtLSByZWdhcmRsZXNzIG9mIGBnZXRTaGFkb3dSb290YCBvcHRpb24gc2V0dGluZy5cblxuICAgIGlmIChub2RlSXNBdHRhY2hlZCkge1xuICAgICAgLy8gdGhpcyB3b3JrcyB3aGVyZXZlciB0aGUgbm9kZSBpczogaWYgdGhlcmUncyBhdCBsZWFzdCBvbmUgY2xpZW50IHJlY3QsIGl0J3NcbiAgICAgIC8vICBzb21laG93IGRpc3BsYXllZDsgaXQgYWxzbyBjb3ZlcnMgdGhlIENTUyAnZGlzcGxheTogY29udGVudHMnIGNhc2Ugd2hlcmUgdGhlXG4gICAgICAvLyAgbm9kZSBpdHNlbGYgaXMgaGlkZGVuIGluIHBsYWNlIG9mIGl0cyBjb250ZW50czsgYW5kIHRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2hcbiAgICAgIC8vICB1cCB0aGUgaGllcmFyY2h5IGVpdGhlclxuICAgICAgcmV0dXJuICFub2RlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIEVsc2UsIHRoZSBub2RlIGlzbid0IGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhlIGBnZXRDbGllbnRSZWN0cygpYFxuICAgIC8vICBBUEkgd2lsbCBfX2Fsd2F5c19fIHJldHVybiB6ZXJvIHJlY3RzICh0aGlzIGNhbiBoYXBwZW4sIGZvciBleGFtcGxlLCBpZiBSZWFjdFxuICAgIC8vICBpcyB1c2VkIHRvIHJlbmRlciBub2RlcyBvbnRvIGEgZGV0YWNoZWQgdHJlZSwgYXMgY29uZmlybWVkIGluIHRoaXMgdGhyZWFkOlxuICAgIC8vICBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzkxMTcjaXNzdWVjb21tZW50LTI4NDIyODg3MClcbiAgICAvL1xuICAgIC8vIEl0IGFsc28gbWVhbnMgdGhhdCBldmVuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLmRpc3BsYXkgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAvLyAgYmVjYXVzZSBzdHlsZXMgYXJlIG9ubHkgY29tcHV0ZWQgZm9yIG5vZGVzIHRoYXQgYXJlIGluIHRoZSBkb2N1bWVudC5cbiAgICAvL1xuICAgIC8vIE5PVEU6IFRISVMgSEFTIEJFRU4gVEhFIENBU0UgRk9SIFlFQVJTLiBJdCBpcyBub3QgbmV3LCBub3IgaXMgaXQgY2F1c2VkIGJ5IHRhYmJhYmxlXG4gICAgLy8gIHNvbWVob3cuIFRob3VnaCBpdCB3YXMgbmV2ZXIgc3RhdGVkIG9mZmljaWFsbHksIGFueW9uZSB3aG8gaGFzIGV2ZXIgdXNlZCB0YWJiYWJsZVxuICAgIC8vICBBUElzIG9uIG5vZGVzIGluIGRldGFjaGVkIGNvbnRhaW5lcnMgaGFzIGFjdHVhbGx5IGltcGxpY2l0bHkgdXNlZCB0YWJiYWJsZSBpbiB3aGF0XG4gICAgLy8gIHdhcyBsYXRlciAoYXMgb2YgdjUuMi4wIG9uIEFwciA5LCAyMDIxKSBjYWxsZWQgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgbW9kZSAtLSBlc3NlbnRpYWxseVxuICAgIC8vICBjb25zaWRlcmluZyBfX2V2ZXJ5dGhpbmdfXyB0byBiZSB2aXNpYmxlIGJlY2F1c2Ugb2YgdGhlIGlubmFiaWxpdHkgdG8gZGV0ZXJtaW5lIHN0eWxlcy5cbiAgfSBlbHNlIGlmIChkaXNwbGF5Q2hlY2sgPT09ICdub24temVyby1hcmVhJykge1xuICAgIC8vIE5PVEU6IEV2ZW4gdGhvdWdoIHRoaXMgdGVzdHMgdGhhdCB0aGUgbm9kZSdzIGNsaWVudCByZWN0IGlzIG5vbi16ZXJvIHRvIGRldGVybWluZVxuICAgIC8vICB3aGV0aGVyIGl0J3MgZGlzcGxheWVkLCBhbmQgdGhhdCBhIGRldGFjaGVkIG5vZGUgd2lsbCBfX2Fsd2F5c19fIGhhdmUgYSB6ZXJvLWFyZWFcbiAgICAvLyAgY2xpZW50IHJlY3QsIHdlIGRvbid0IHNwZWNpYWwtY2FzZSBmb3Igd2hldGhlciB0aGUgbm9kZSBpcyBhdHRhY2hlZCBvciBub3QuIEluXG4gICAgLy8gIHRoaXMgbW9kZSwgd2UgZG8gd2FudCB0byBjb25zaWRlciBub2RlcyB0aGF0IGhhdmUgYSB6ZXJvIGFyZWEgdG8gYmUgaGlkZGVuIGF0IGFsbFxuICAgIC8vICB0aW1lcywgYW5kIHRoYXQgaW5jbHVkZXMgYXR0YWNoZWQgb3Igbm90LlxuICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xuICB9XG5cbiAgLy8gdmlzaWJsZSwgYXMgZmFyIGFzIHdlIGNhbiB0ZWxsLCBvciBwZXIgY3VycmVudCBgZGlzcGxheUNoZWNrYCBtb2RlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIGZvcm0gZmllbGRzIChuZXN0ZWQpIGluc2lkZSBhIGRpc2FibGVkIGZpZWxkc2V0IGFyZSBub3QgZm9jdXNhYmxlL3RhYmJhYmxlXG4vLyAgdW5sZXNzIHRoZXkgYXJlIGluIHRoZSBfZmlyc3RfIDxsZWdlbmQ+IGVsZW1lbnQgb2YgdGhlIHRvcC1tb3N0IGRpc2FibGVkXG4vLyAgZmllbGRzZXRcbmNvbnN0IGlzRGlzYWJsZWRGcm9tRmllbGRzZXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoL14oSU5QVVR8QlVUVE9OfFNFTEVDVHxURVhUQVJFQSkkLy50ZXN0KG5vZGUudGFnTmFtZSkpIHtcbiAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAvLyBjaGVjayBpZiBgbm9kZWAgaXMgY29udGFpbmVkIGluIGEgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS50YWdOYW1lID09PSAnRklFTERTRVQnICYmIHBhcmVudE5vZGUuZGlzYWJsZWQpIHtcbiAgICAgICAgLy8gbG9vayBmb3IgdGhlIGZpcnN0IDxsZWdlbmQ+IGFtb25nIHRoZSBjaGlsZHJlbiBvZiB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHBhcmVudE5vZGUuY2hpbGRyZW4uaXRlbShpKTtcbiAgICAgICAgICAvLyB3aGVuIHRoZSBmaXJzdCA8bGVnZW5kPiAoaW4gZG9jdW1lbnQgb3JkZXIpIGlzIGZvdW5kXG4gICAgICAgICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09ICdMRUdFTkQnKSB7XG4gICAgICAgICAgICAvLyBpZiBpdHMgcGFyZW50IDxmaWVsZHNldD4gaXMgbm90IG5lc3RlZCBpbiBhbm90aGVyIGRpc2FibGVkIDxmaWVsZHNldD4sXG4gICAgICAgICAgICAvLyByZXR1cm4gd2hldGhlciBgbm9kZWAgaXMgYSBkZXNjZW5kYW50IG9mIGl0cyBmaXJzdCA8bGVnZW5kPlxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChwYXJlbnROb2RlLCAnZmllbGRzZXRbZGlzYWJsZWRdIConKVxuICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgOiAhY2hpbGQuY29udGFpbnMobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkaXNhYmxlZCA8ZmllbGRzZXQ+IGNvbnRhaW5pbmcgYG5vZGVgIGhhcyBubyA8bGVnZW5kPlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gZWxzZSwgbm9kZSdzIHRhYmJhYmxlL2ZvY3VzYWJsZSBzdGF0ZSBzaG91bGQgbm90IGJlIGFmZmVjdGVkIGJ5IGEgZmllbGRzZXQnc1xuICAvLyAgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIG5vZGUpIHtcbiAgaWYgKFxuICAgIG5vZGUuZGlzYWJsZWQgfHxcbiAgICBpc0hpZGRlbklucHV0KG5vZGUpIHx8XG4gICAgaXNIaWRkZW4obm9kZSwgb3B0aW9ucykgfHxcbiAgICAvLyBGb3IgYSBkZXRhaWxzIGVsZW1lbnQgd2l0aCBhIHN1bW1hcnksIHRoZSBzdW1tYXJ5IGVsZW1lbnQgZ2V0cyB0aGUgZm9jdXNcbiAgICBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB8fFxuICAgIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQobm9kZSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIG5vZGUpIHtcbiAgaWYgKFxuICAgIGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB8fFxuICAgIGdldFRhYmluZGV4KG5vZGUpIDwgMCB8fFxuICAgICFpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUgPSBmdW5jdGlvbiAoc2hhZG93SG9zdE5vZGUpIHtcbiAgY29uc3QgdGFiSW5kZXggPSBwYXJzZUludChzaGFkb3dIb3N0Tm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKTtcbiAgaWYgKGlzTmFOKHRhYkluZGV4KSB8fCB0YWJJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSWYgYSBjdXN0b20gZWxlbWVudCBoYXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgdGFiaW5kZXgsXG4gIC8vIGJyb3dzZXJzIHdpbGwgbm90IGFsbG93IHRhYiB0YXJnZXRpbmcgc2FpZCBlbGVtZW50J3MgY2hpbGRyZW4uXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48RWxlbWVudHxDYW5kaWRhdGVzU2NvcGU+fSBjYW5kaWRhdGVzXG4gKiBAcmV0dXJucyBFbGVtZW50W11cbiAqL1xuY29uc3Qgc29ydEJ5T3JkZXIgPSBmdW5jdGlvbiAoY2FuZGlkYXRlcykge1xuICBjb25zdCByZWd1bGFyVGFiYmFibGVzID0gW107XG4gIGNvbnN0IG9yZGVyZWRUYWJiYWJsZXMgPSBbXTtcbiAgY2FuZGlkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgY29uc3QgaXNTY29wZSA9ICEhaXRlbS5zY29wZTtcbiAgICBjb25zdCBlbGVtZW50ID0gaXNTY29wZSA/IGl0ZW0uc2NvcGUgOiBpdGVtO1xuICAgIGNvbnN0IGNhbmRpZGF0ZVRhYmluZGV4ID0gZ2V0VGFiaW5kZXgoZWxlbWVudCwgaXNTY29wZSk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBpc1Njb3BlID8gc29ydEJ5T3JkZXIoaXRlbS5jYW5kaWRhdGVzKSA6IGVsZW1lbnQ7XG4gICAgaWYgKGNhbmRpZGF0ZVRhYmluZGV4ID09PSAwKSB7XG4gICAgICBpc1Njb3BlXG4gICAgICAgID8gcmVndWxhclRhYmJhYmxlcy5wdXNoKC4uLmVsZW1lbnRzKVxuICAgICAgICA6IHJlZ3VsYXJUYWJiYWJsZXMucHVzaChlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgZG9jdW1lbnRPcmRlcjogaSxcbiAgICAgICAgdGFiSW5kZXg6IGNhbmRpZGF0ZVRhYmluZGV4LFxuICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICBpc1Njb3BlOiBpc1Njb3BlLFxuICAgICAgICBjb250ZW50OiBlbGVtZW50cyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG9yZGVyZWRUYWJiYWJsZXNcbiAgICAuc29ydChzb3J0T3JkZXJlZFRhYmJhYmxlcylcbiAgICAucmVkdWNlKChhY2MsIHNvcnRhYmxlKSA9PiB7XG4gICAgICBzb3J0YWJsZS5pc1Njb3BlXG4gICAgICAgID8gYWNjLnB1c2goLi4uc29ydGFibGUuY29udGVudClcbiAgICAgICAgOiBhY2MucHVzaChzb3J0YWJsZS5jb250ZW50KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pXG4gICAgLmNvbmNhdChyZWd1bGFyVGFiYmFibGVzKTtcbn07XG5cbmNvbnN0IHRhYmJhYmxlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCBjYW5kaWRhdGVzO1xuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShbZWxdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucyksXG4gICAgICBmbGF0dGVuOiBmYWxzZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcbiAgICAgIHNoYWRvd1Jvb3RGaWx0ZXI6IGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoXG4gICAgICBlbCxcbiAgICAgIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lcixcbiAgICAgIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc29ydEJ5T3JkZXIoY2FuZGlkYXRlcyk7XG59O1xuXG5jb25zdCBmb2N1c2FibGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgbGV0IGNhbmRpZGF0ZXM7XG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtlbF0sIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwge1xuICAgICAgZmlsdGVyOiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucyksXG4gICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgZ2V0U2hhZG93Um9vdDogb3B0aW9ucy5nZXRTaGFkb3dSb290LFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKFxuICAgICAgZWwsXG4gICAgICBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsXG4gICAgICBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucylcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG5jb25zdCBpc1RhYmJhYmxlID0gZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICB9XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgY2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlKG9wdGlvbnMsIG5vZGUpO1xufTtcblxuY29uc3QgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi8gY2FuZGlkYXRlU2VsZWN0b3JzXG4gIC5jb25jYXQoJ2lmcmFtZScpXG4gIC5qb2luKCcsJyk7XG5cbmNvbnN0IGlzRm9jdXNhYmxlID0gZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICB9XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmV4cG9ydCB7IHRhYmJhYmxlLCBmb2N1c2FibGUsIGlzVGFiYmFibGUsIGlzRm9jdXNhYmxlIH07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ2luZXJ0JywgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICAvKipcbiAgICogVGhpcyB3b3JrIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBXM0MgU29mdHdhcmUgYW5kIERvY3VtZW50IExpY2Vuc2VcbiAgICogKGh0dHA6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvMjAxNS9jb3B5cmlnaHQtc29mdHdhcmUtYW5kLWRvY3VtZW50KS5cbiAgICovXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZXR1cm4gZWFybHkgaWYgd2UncmUgbm90IHJ1bm5pbmcgaW5zaWRlIG9mIHRoZSBicm93c2VyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgICAvKiogQHR5cGUge3R5cGVvZiBBcnJheS5wcm90b3R5cGUuc2xpY2V9ICovXG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgLyoqXG4gICAgICogSUUgaGFzIGEgbm9uLXN0YW5kYXJkIG5hbWUgZm9yIFwibWF0Y2hlc1wiLlxuICAgICAqIEB0eXBlIHt0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc31cbiAgICAgKi9cbiAgICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XG5cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgICAvKipcbiAgICAgKiBgSW5lcnRSb290YCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IHN1YnRyZWUsIGkuZS4gYSBET00gc3VidHJlZSB3aG9zZSByb290IGVsZW1lbnQgaGFzIGFuIGBpbmVydGBcbiAgICAgKiBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBJdHMgbWFpbiBmdW5jdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogLSB0byBjcmVhdGUgYW5kIG1haW50YWluIGEgc2V0IG9mIG1hbmFnZWQgYEluZXJ0Tm9kZWBzLCBpbmNsdWRpbmcgd2hlbiBtdXRhdGlvbnMgb2NjdXIgaW4gdGhlXG4gICAgICogICBzdWJ0cmVlLiBUaGUgYG1ha2VTdWJ0cmVlVW5mb2N1c2FibGUoKWAgbWV0aG9kIGhhbmRsZXMgY29sbGVjdGluZyBgSW5lcnROb2RlYHMgdmlhIHJlZ2lzdGVyaW5nXG4gICAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgICAqICAgZm9jdXNhYmxlIG5vZGVzIHdpdGhpbiBpbmVydCBzdWJ0cmVlcy4gYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgXG4gICAgICogICBpbnN0YW5jZSBleGlzdHMgZm9yIGVhY2ggZm9jdXNhYmxlIG5vZGUgd2hpY2ggaGFzIGF0IGxlYXN0IG9uZSBpbmVydCByb290IGFzIGFuIGFuY2VzdG9yLlxuICAgICAqXG4gICAgICogLSB0byBub3RpZnkgYWxsIG1hbmFnZWQgYEluZXJ0Tm9kZWBzIHdoZW4gdGhpcyBzdWJ0cmVlIHN0b3BzIGJlaW5nIGluZXJ0IChpLmUuIHdoZW4gdGhlIGBpbmVydGBcbiAgICAgKiAgIGF0dHJpYnV0ZSBpcyByZW1vdmVkIGZyb20gdGhlIHJvb3Qgbm9kZSkuIFRoaXMgaXMgaGFuZGxlZCBpbiB0aGUgZGVzdHJ1Y3Rvciwgd2hpY2ggY2FsbHMgdGhlXG4gICAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICAgKi9cblxuICAgIHZhciBJbmVydFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290RWxlbWVudCBUaGUgSFRNTEVsZW1lbnQgYXQgdGhlIHJvb3Qgb2YgdGhlIGluZXJ0IHN1YnRyZWUuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydE1hbmFnZXJ9IGluZXJ0TWFuYWdlciBUaGUgZ2xvYmFsIHNpbmdsZXRvbiBJbmVydE1hbmFnZXIgb2JqZWN0LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydFJvb3Qocm9vdEVsZW1lbnQsIGluZXJ0TWFuYWdlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRSb290KTtcblxuICAgICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IGluZXJ0TWFuYWdlcjtcblxuICAgICAgICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Tm9kZT59XG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHs/c3RyaW5nfSAqL1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIC8vIE1ha2UgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0aGUgc3VidHJlZSB1bmZvY3VzYWJsZSBhbmQgYWRkIHRoZW0gdG8gX21hbmFnZWROb2Rlc1xuICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgICAvLyBXYXRjaCBmb3I6XG4gICAgICAgIC8vIC0gYW55IGFkZGl0aW9ucyBpbiB0aGUgc3VidHJlZTogbWFrZSB0aGVtIHVuZm9jdXNhYmxlIHRvb1xuICAgICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgICAgLy8gLSBhdHRyaWJ1dGUgY2hhbmdlczogaWYgYHRhYmluZGV4YCBpcyBhZGRlZCwgb3IgcmVtb3ZlZCBmcm9tIGFuIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlXG4gICAgICAgIC8vICAgZWxlbWVudCwgbWFrZSB0aGF0IG5vZGUgYSBtYW5hZ2VkIG5vZGUuXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9yb290RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS4gIFRoaXMgdW53aW5kcyBhbGwgb2YgdGhlIHN0YXRlXG4gICAgICAgKiBzdG9yZWQgaW4gdGhpcyBvYmplY3QgYW5kIHVwZGF0ZXMgdGhlIHN0YXRlIG9mIGFsbCBvZiB0aGUgbWFuYWdlZCBub2Rlcy5cbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydFJvb3QsIFt7XG4gICAgICAgIGtleTogJ2Rlc3RydWN0b3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRoaXMuX3NhdmVkQXJpYUhpZGRlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5tYW5hZ2VOb2RlKGluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgICAvLyAxKSBXZSB3YW50IHRoZSBjbGFzcyBwcm9wZXJ0aWVzIHRvIGJlIGRlY2xhcmVkIGFzIG5vbi1udWxsLCBvciBlbHNlIHdlXG4gICAgICAgICAgLy8gICAgbmVlZCBldmVuIG1vcmUgY2FzdHMgdGhyb3VnaG91dCB0aGlzIGNvZGUuIEFsbCBiZXRzIGFyZSBvZmYgaWYgYW5cbiAgICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgICAvLyAyKSBXZSBkb24ndCB3YW50IHRvIGNhc3QgXCJ0aGlzXCIsIGJlY2F1c2Ugd2Ugd2FudCB0eXBlLWF3YXJlIG9wdGltaXphdGlvbnNcbiAgICAgICAgICAvLyAgICB0byBrbm93IHdoaWNoIHByb3BlcnRpZXMgd2UncmUgc2V0dGluZy5cbiAgICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5fdmlzaXROb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0Tm9kZSBtYXkgYmUgaW4gc2hhZG93IERPTSwgc28gZmluZCBpdHMgbmVhcmVzdCBzaGFkb3dSb290IHRvIGdldCB0aGUgYWN0aXZlRWxlbWVudC5cbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHshU2hhZG93Um9vdHx1bmRlZmluZWR9ICovXG4gICAgICAgICAgICB2YXIgcm9vdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICByb290ID0gLyoqIEB0eXBlIHshU2hhZG93Um9vdH0gKi9ub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gcm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnROb2RlLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAgIC8vIEluIElFMTEsIGlmIGFuIGVsZW1lbnQgaXMgYWxyZWFkeSBmb2N1c2VkLCBhbmQgdGhlbiBzZXQgdG8gdGFiaW5kZXg9LTFcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgYmx1cigpIHdpbGwgbm90IGFjdHVhbGx5IG1vdmUgdGhlIGZvY3VzLlxuICAgICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdmlzaXROb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF92aXNpdE5vZGUobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgICAvLyBJZiBhIGRlc2NlbmRhbnQgaW5lcnQgcm9vdCBiZWNvbWVzIHVuLWluZXJ0LCBpdHMgZGVzY2VuZGFudHMgd2lsbCBzdGlsbCBiZSBpbmVydCBiZWNhdXNlIG9mXG4gICAgICAgICAgLy8gdGhpcyBpbmVydCByb290LCBzbyBhbGwgb2YgaXRzIG1hbmFnZWQgbm9kZXMgbmVlZCB0byBiZSBhZG9wdGVkIGJ5IHRoaXMgSW5lcnRSb290LlxuICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QoZWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5yZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdW5tYW5hZ2VOb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXNbJ2RlbGV0ZSddKGluZXJ0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlU3VidHJlZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VTdWJ0cmVlKHN0YXJ0Tm9kZSkge1xuICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLl91bm1hbmFnZU5vZGUobm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19hZG9wdEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRvcHRJbmVydFJvb3Qobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgICAgLy8gRHVyaW5nIGluaXRpYWxpc2F0aW9uIHRoaXMgaW5lcnQgcm9vdCBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIHlldCxcbiAgICAgICAgICAvLyBzbyByZWdpc3RlciBpdCBub3cgaWYgbmVlZCBiZS5cbiAgICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyLnNldEluZXJ0KG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmVydFN1YnJvb3QubWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHNhdmVkSW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHNhdmVkSW5lcnROb2RlLm5vZGUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gc2VsZlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfb25NdXRhdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9yZWNvcmQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgICAvLyBNYW5hZ2UgYWRkZWQgbm9kZXNcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgIC8vIFVuLW1hbmFnZSByZW1vdmVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlU3VidHJlZShub2RlKTtcbiAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAndGFiaW5kZXgnKSB7XG4gICAgICAgICAgICAgICAgLy8gUmUtaW5pdGlhbGlzZSBpbmVydCBub2RlIGlmIHRhYmluZGV4IGNoYW5nZXNcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiByZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ2luZXJ0JyAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBuZXcgaW5lcnQgcm9vdCBpcyBhZGRlZCwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMgYW5kIG1ha2Ugc3VyZSBpdCBrbm93cyBhYm91dCB0aGVcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5jb250YWlucyhtYW5hZ2VkTm9kZS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydFN1YnJvb3QuX21hbmFnZU5vZGUobWFuYWdlZE5vZGUubm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdtYW5hZ2VkTm9kZXMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcGFyYW0gez9zdHJpbmd9IGFyaWFIaWRkZW4gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhcmlhSGlkZGVuKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHs/c3RyaW5nfSAqL1xuICAgICAgICAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW47XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Um9vdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBgSW5lcnROb2RlYCBpbml0aWFsaXNlcyBhbmQgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBub2RlLlxuICAgICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIE9uIGNvbnN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgc2F2ZXMgdGhlIGV4aXN0aW5nIGB0YWJpbmRleGAgdmFsdWUgZm9yIHRoZSBub2RlLCBpZiBhbnksIGFuZFxuICAgICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAgICogaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUgb3Igbm90LlxuICAgICAqXG4gICAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgICAqIGBJbmVydFJvb3RgIGlzIGRlc3Ryb3llZCwgYW5kIGNhbGxzIGBJbmVydE1hbmFnZXIuZGVyZWdpc3RlcigpYCwgdGhlIGBJbmVydE1hbmFnZXJgIG5vdGlmaWVzIHRoZVxuICAgICAqIGBJbmVydE5vZGVgIHZpYSBgcmVtb3ZlSW5lcnRSb290KClgLCB3aGljaCBpbiB0dXJuIGRlc3Ryb3lzIHRoZSBgSW5lcnROb2RlYCBpZiBubyBgSW5lcnRSb290YHNcbiAgICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAgICogb3IgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgaWYgdGhlIGVsZW1lbnQgaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUuXG4gICAgICovXG5cblxuICAgIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgQSBmb2N1c2FibGUgZWxlbWVudCB0byBiZSBtYWRlIGluZXJ0LlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IU5vZGV9ICovXG4gICAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiAgICBJZiBhbmQgb25seSBpZiB0aGlzIHNldCBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IG51bGw7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBTYXZlIGFueSBwcmlvciB0YWJpbmRleCBpbmZvIGFuZCBtYWtlIHRoaXMgbm9kZSB1bnRhYmJhYmxlXG4gICAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICAgKiBUaGlzIG1ha2VzIHRoZSBtYW5hZ2VkIG5vZGUgZm9jdXNhYmxlIGFnYWluIGFuZCBkZWxldGVzIGFsbCBvZiB0aGUgcHJldmlvdXNseSBzdG9yZWQgc3RhdGUuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX25vZGUgJiYgdGhpcy5fbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5fbm9kZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRoaXMuX3NhdmVkVGFiSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBgZGVsZXRlYCB0byByZXN0b3JlIG5hdGl2ZSBmb2N1cyBtZXRob2QuXG4gICAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudC5mb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZWUgbm90ZSBpbiBJbmVydFJvb3QuZGVzdHJ1Y3RvciBmb3Igd2h5IHdlIGNhc3QgdGhlc2UgbnVsbHMgdG8gQU5ZLlxuICAgICAgICAgIHRoaXMuX25vZGUgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG9iamVjdCBpcyBvYnNvbGV0ZSBiZWNhdXNlIHRoZSBtYW5hZ2VkIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICAgKiBJZiB0aGUgb2JqZWN0IGhhcyBiZWVuIGRlc3Ryb3llZCwgYW55IGF0dGVtcHQgdG8gYWNjZXNzIGl0IHdpbGwgY2F1c2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdGhyb3dJZkRlc3Ryb3llZCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhyb3cgaWYgdXNlciB0cmllcyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBkZXN0cm95ZWQgSW5lcnROb2RlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZW5zdXJlVW50YWJiYWJsZScsXG5cblxuICAgICAgICAvKiogU2F2ZSB0aGUgZXhpc3RpbmcgdGFiaW5kZXggdmFsdWUgYW5kIG1ha2UgdGhlIG5vZGUgdW50YWJiYWJsZSBhbmQgdW5mb2N1c2FibGUgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMubm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLm5vZGU7XG4gICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpKSB7XG4gICAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGFub3RoZXIgaW5lcnQgcm9vdCB0byB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBJZiB0aGUgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzIGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQsXG4gICAgICAgICAqIHNvIHRoZSBvYmplY3Qgc2hvdWxkIGJlIGRlc3Ryb3llZC5cbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RydWN0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgeyFJbmVydE5vZGV9ICovdGhpcy5fZGVzdHJveWVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7IU5vZGV9ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbm9kZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcGFyYW0gez9udW1iZXJ9IHRhYkluZGV4ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRhYkluZGV4KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSB0YWJJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgICAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleDtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnROb2RlO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEluZXJ0TWFuYWdlciBpcyBhIHBlci1kb2N1bWVudCBzaW5nbGV0b24gb2JqZWN0IHdoaWNoIG1hbmFnZXMgYWxsIGluZXJ0IHJvb3RzIGFuZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICAgKiBwcm9wZXJ0eSBzZXQgdG8gYHRydWVgLCB0aGUgYHNldEluZXJ0YCBtZXRob2QgY3JlYXRlcyBhbiBgSW5lcnRSb290YCBvYmplY3QgZm9yIHRoZSBlbGVtZW50LlxuICAgICAqIFRoZSBgSW5lcnRSb290YCBpbiB0dXJuIHJlZ2lzdGVycyBpdHNlbGYgYXMgbWFuYWdpbmcgYWxsIG9mIHRoZSBlbGVtZW50J3MgZm9jdXNhYmxlIGRlc2NlbmRhbnRcbiAgICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICAgKiBpcyBjcmVhdGVkIGZvciBlYWNoIHN1Y2ggbm9kZSwgdmlhIHRoZSBgX21hbmFnZWROb2Rlc2AgbWFwLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFEb2N1bWVudH0gZG9jdW1lbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRNYW5hZ2VyKGRvY3VtZW50KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE1hbmFnZXIpO1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ7IEluZXJ0TWFuYWdlciBuZWVkcyB0byB3cmFwIGEgZG9jdW1lbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydE5vZGU+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgaW5lcnQgcm9vdHMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT2JzZXJ2ZXIgZm9yIG11dGF0aW9ucyBvbiBgZG9jdW1lbnQuYm9keWAuXG4gICAgICAgICAqIEB0eXBlIHshTXV0YXRpb25PYnNlcnZlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fd2F0Y2hGb3JJbmVydC5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBBZGQgaW5lcnQgc3R5bGUuXG4gICAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgZG9jdW1lbnQgdG8gYmUgbG9hZGVkLlxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fb25Eb2N1bWVudExvYWRlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IHJvb3RcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5lcnRcbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydE1hbmFnZXIsIFt7XG4gICAgICAgIGtleTogJ3NldEluZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgICAgaWYgKGluZXJ0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgICByb290LnNldEF0dHJpYnV0ZSgnaW5lcnQnLCAnJyk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLnNldChyb290LCBpbmVydFJvb3QpO1xuICAgICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgICAgLy8gRW5zdXJlIGluZXJ0IHN0eWxlcyBhcmUgYWRkZWQgdGhlcmUuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RvY3VtZW50LmJvZHkuY29udGFpbnMocm9vdCkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IG5vbi1pbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfaW5lcnRSb290ID0gdGhpcy5faW5lcnRSb290cy5nZXQocm9vdCk7XG4gICAgICAgICAgICBfaW5lcnRSb290LmRlc3RydWN0b3IoKTtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgSW5lcnRSb290IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmVydCByb290IGVsZW1lbnQsIGlmIGFueS5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJuIHshSW5lcnRSb290fHVuZGVmaW5lZH1cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0SW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluZXJ0Um9vdChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgICAqIEluIHRoZSBjYXNlIHdoZXJlIHRoZSBub2RlIGhhcyBhIHByZXZpb3VzbHkgZXhpc3RpbmcgaW5lcnQgcm9vdCwgdGhpcyBpbmVydCByb290IHdpbGxcbiAgICAgICAgICogYmUgYWRkZWQgdG8gaXRzIHNldCBvZiBpbmVydCByb290cy5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKiBAcmV0dXJuIHshSW5lcnROb2RlfSBpbmVydE5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVnaXN0ZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICAgIGluZXJ0Tm9kZS5hZGRJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5zZXQobm9kZSwgaW5lcnROb2RlKTtcblxuICAgICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAgICogUmVtb3ZlcyB0aGUgaW5lcnQgcm9vdCBmcm9tIHRoZSBJbmVydE5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMsIGFuZCByZW1vdmUgdGhlIGluZXJ0XG4gICAgICAgICAqIG5vZGUgZnJvbSB0aGUgSW5lcnRNYW5hZ2VyJ3Mgc2V0IG9mIG1hbmFnZWQgbm9kZXMgaWYgaXQgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVyZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5fbWFuYWdlZE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXNbJ2RlbGV0ZSddKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIGRvY3VtZW50IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfb25Eb2N1bWVudExvYWRlZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Eb2N1bWVudExvYWRlZCgpIHtcbiAgICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbCh0aGlzLl9kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBDb21tZW50IHRoaXMgb3V0IHRvIHVzZSBwcm9ncmFtbWF0aWMgQVBJIG9ubHkuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gc2VsZlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfd2F0Y2hGb3JJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICdjaGlsZExpc3QnOlxuICAgICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCAnW2luZXJ0XScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMudW5zaGlmdChub2RlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSAhPT0gJ2luZXJ0Jykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgICAgICB2YXIgaW5lcnQgPSB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb24gKCFIVE1MRWxlbWVudCkpPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBlYWNoIGVsZW1lbnQgdHJhdmVyc2VkLFxuICAgICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7P1NoYWRvd1Jvb3Q9fSBzaGFkb3dSb290QW5jZXN0b3IgVGhlIG5lYXJlc3QgU2hhZG93Um9vdCBhbmNlc3RvciwgaWYgYW55LlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovbm9kZTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgICAgLy8gSWYgaXQgaGFzIGEgU2hhZG93Um9vdCwgaWdub3JlIGFsbCBjaGlsZCBlbGVtZW50cyAtIHRoZXNlIHdpbGwgYmUgcGlja2VkXG4gICAgICAgIC8vIHVwIGJ5IHRoZSA8Y29udGVudD4gb3IgPHNoYWRvdz4gZWxlbWVudHMuIERlc2NlbmQgc3RyYWlnaHQgaW50byB0aGVcbiAgICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgICAgdmFyIHNoYWRvd1Jvb3QgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICAgIHZhciBjb250ZW50ID0gLyoqIEB0eXBlIHshSFRNTENvbnRlbnRFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZpZXMgaWYgU2hhZG93RG9tIHYwIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGRpc3RyaWJ1dGVkTm9kZXNbaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgdmFyIHNsb3QgPSAvKiogQHR5cGUgeyFIVE1MU2xvdEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgICAvLyBWZXJpZnkgaWYgU2hhZG93RG9tIHYxIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9kaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhfZGlzdHJpYnV0ZWROb2Rlc1tfaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgbmVpdGhlciB0aGUgcGFyZW50IG9mIGEgU2hhZG93Um9vdCwgYSA8Y29udGVudD4gZWxlbWVudCwgYSA8c2xvdD5cbiAgICAgIC8vIGVsZW1lbnQsIG5vciBhIDxzaGFkb3c+IGVsZW1lbnQgcmVjdXJzZSBub3JtYWxseS5cbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoY2hpbGQsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdHlsZSBlbGVtZW50IHRvIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIGluZXJ0IHNwZWNpZmljIHN0eWxlc1xuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRJbmVydFN0eWxlKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlI2luZXJ0LXN0eWxlLCBsaW5rI2luZXJ0LXN0eWxlJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gJ1xcbicgKyAnW2luZXJ0XSB7XFxuJyArICcgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbicgKyAnICBjdXJzb3I6IGRlZmF1bHQ7XFxuJyArICd9XFxuJyArICdcXG4nICsgJ1tpbmVydF0sIFtpbmVydF0gKiB7XFxuJyArICcgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICd9XFxuJztcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cblxuICAgIGlmICghSFRNTEVsZW1lbnQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdpbmVydCcpKSB7XG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUsICdpbmVydCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGluZXJ0KSB7XG4gICAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KSgpO1xuXG59KSkpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBgQmxvY2tpbmdFbGVtZW50c2AgbWFuYWdlcyBhIHN0YWNrIG9mIGVsZW1lbnRzIHRoYXQgaW5lcnQgdGhlIGludGVyYWN0aW9uXG4gKiBvdXRzaWRlIHRoZW0uIFRoZSB0b3AgZWxlbWVudCBpcyB0aGUgaW50ZXJhY3RpdmUgcGFydCBvZiB0aGUgZG9jdW1lbnQuXG4gKiBUaGUgc3RhY2sgY2FuIGJlIHVwZGF0ZWQgd2l0aCB0aGUgbWV0aG9kcyBgcHVzaCwgcmVtb3ZlLCBwb3BgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJsb2NraW5nRWxlbWVudHMge1xuICAvKipcbiAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS4gVGhpcyBlbXB0aWVzXG4gICAqIHRoZSBibG9ja2luZyBlbGVtZW50c1xuICAgKi9cbiAgZGVzdHJ1Y3RvcigpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgdG9wIGJsb2NraW5nIGVsZW1lbnQuXG4gICAqL1xuICB0b3A6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGVsZW1lbnQgdG8gdGhlIGJsb2NraW5nIGVsZW1lbnRzLlxuICAgKi9cbiAgcHVzaChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVsZW1lbnQgZnJvbSB0aGUgYmxvY2tpbmcgZWxlbWVudHMuIFJldHVybnMgdHJ1ZSBpZiB0aGVcbiAgICogZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgdG9wIGJsb2NraW5nIGVsZW1lbnQgYW5kIHJldHVybnMgaXQuXG4gICAqL1xuICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgZWxlbWVudCBpcyBhIGJsb2NraW5nIGVsZW1lbnQuXG4gICAqL1xuICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMgZXh0ZW5kcyBEb2N1bWVudCB7XG4gICRibG9ja2luZ0VsZW1lbnRzOiBCbG9ja2luZ0VsZW1lbnRzO1xufVxuXG4oKCkgPT4ge1xuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHByb3BlcnRpZXMgKi9cbiAgY29uc3QgX2Jsb2NraW5nRWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2FscmVhZHlJbmVydEVsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF90b3BFbFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3NpYmxpbmdzVG9SZXN0b3JlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9wYXJlbnRNTyA9IFN5bWJvbCgpO1xuXG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgc3RhdGljIG1ldGhvZHMgKi9cbiAgY29uc3QgX3RvcENoYW5nZWQgPSBTeW1ib2woKTtcbiAgY29uc3QgX3N3YXBJbmVydGVkU2libGluZyA9IFN5bWJvbCgpO1xuICBjb25zdCBfaW5lcnRTaWJsaW5ncyA9IFN5bWJvbCgpO1xuICBjb25zdCBfcmVzdG9yZUluZXJ0ZWRTaWJsaW5ncyA9IFN5bWJvbCgpO1xuICBjb25zdCBfZ2V0UGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbiA9IFN5bWJvbCgpO1xuICBjb25zdCBfaXNJbmVydGFibGUgPSBTeW1ib2woKTtcbiAgY29uc3QgX2hhbmRsZU11dGF0aW9ucyA9IFN5bWJvbCgpO1xuXG4gIGludGVyZmFjZSBJbmVydGFibGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgaW5lcnQ/OiBib29sZWFuO1xuICB9XG5cbiAgaW50ZXJmYWNlIEludGVybmFsU3RhdGUge1xuICAgIFtfc2libGluZ3NUb1Jlc3RvcmVdOiBTZXQ8TWF5YmVIYXNJbnRlcm5hbFN0YXRlPjtcbiAgICBbX3BhcmVudE1PXTogTXV0YXRpb25PYnNlcnZlcjtcbiAgfVxuICBpbnRlcmZhY2UgSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgSW50ZXJuYWxTdGF0ZSB7fVxuICBpbnRlcmZhY2UgTWF5YmVIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBQYXJ0aWFsPEludGVybmFsU3RhdGU+IHt9XG5cbiAgLyoqXG4gICAqIFNoYWR5RE9NIHNoYWR5IHJvb3RzIGxvb2sgYSBsb3QgbGlrZSByZWFsIFNoYWRvd1Jvb3RzLiBUaGUgX19zaGFkeSBwcm9wZXJ0eVxuICAgKiBnaXZlcyB0aGVtIGF3YXksIHRob3VnaC5cbiAgICovXG4gIGludGVyZmFjZSBNYXliZVNoYWR5Um9vdCBleHRlbmRzIEVsZW1lbnQge1xuICAgIF9fc2hhZHk6IHVua25vd247XG4gICAgaG9zdDogRWxlbWVudDtcbiAgfVxuXG4gIGNsYXNzIEJsb2NraW5nRWxlbWVudHNJbXBsIGltcGxlbWVudHMgQmxvY2tpbmdFbGVtZW50cyB7XG4gICAgLyoqXG4gICAgICogVGhlIGJsb2NraW5nIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2Jsb2NraW5nRWxlbWVudHNdOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBwYXJlbnRzIG9mIHRoZSB0b3AgZWxlbWVudCwgZnJvbSB0aGUgZWxlbWVudFxuICAgICAqIGl0c2VsZiB1cCB0byBib2R5LiBXaGVuIHRvcCBjaGFuZ2VzLCB0aGUgb2xkIHRvcCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAqIGZyb20gdGhlIGRvY3VtZW50LCBzbyB3ZSBuZWVkIHRvIG1lbW9pemUgdGhlIGluZXJ0ZWQgcGFyZW50cycgc2libGluZ3NcbiAgICAgKiBpbiBvcmRlciB0byByZXN0b3JlIHRoZWlyIGluZXJ0ZW5lc3Mgd2hlbiB0b3AgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBwcml2YXRlW190b3BFbFBhcmVudHNdOiBIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEVsZW1lbnRzIHRoYXQgYXJlIGFscmVhZHkgaW5lcnQgYmVmb3JlIHRoZSBmaXJzdCBibG9ja2luZyBlbGVtZW50IGlzXG4gICAgICogcHVzaGVkLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG5ldyBTZXQ8TWF5YmVIYXNJbnRlcm5hbFN0YXRlPigpO1xuXG4gICAgZGVzdHJ1Y3RvcigpOiB2b2lkIHtcbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgaW5lcnRuZXNzLlxuICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10odGhpc1tfdG9wRWxQYXJlbnRzXSk7XG4gICAgICAvLyBOb3RlIHdlIGRvbid0IHdhbnQgdG8gbWFrZSB0aGVzZSBwcm9wZXJ0aWVzIG51bGxhYmxlIG9uIHRoZSBjbGFzcyxcbiAgICAgIC8vIHNpbmNlIHRoZW4gd2UnZCBuZWVkIG5vbi1udWxsIGNhc3RzIGluIG1hbnkgcGxhY2VzLiBDYWxsaW5nIGEgbWV0aG9kIG9uXG4gICAgICAvLyBhIEJsb2NraW5nRWxlbWVudHMgaW5zdGFuY2UgYWZ0ZXIgY2FsbGluZyBkZXN0cnVjdG9yIHdpbGwgcmVzdWx0IGluIGFuXG4gICAgICAvLyBleGNlcHRpb24uXG4gICAgICBjb25zdCBudWxsYWJsZSA9IHRoaXMgYXMgdW5rbm93biBhcyB7XG4gICAgICAgIFtfYmxvY2tpbmdFbGVtZW50c106IG51bGw7XG4gICAgICAgIFtfdG9wRWxQYXJlbnRzXTogbnVsbDtcbiAgICAgICAgW19hbHJlYWR5SW5lcnRFbGVtZW50c106IG51bGw7XG4gICAgICB9O1xuICAgICAgbnVsbGFibGVbX2Jsb2NraW5nRWxlbWVudHNdID0gbnVsbDtcbiAgICAgIG51bGxhYmxlW190b3BFbFBhcmVudHNdID0gbnVsbDtcbiAgICAgIG51bGxhYmxlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBudWxsO1xuICAgIH1cblxuICAgIGdldCB0b3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCBlbGVtcyA9IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdO1xuICAgICAgcmV0dXJuIGVsZW1zW2VsZW1zLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gICAgfVxuXG4gICAgcHVzaChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQgPT09IHRoaXMudG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgd2UnbGwgYnJpbmcgaXQgdG8gdGhlIHRvcC5cbiAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0oZWxlbWVudCk7XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5wdXNoKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJlbW92ZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgY29uc3QgaSA9IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uc3BsaWNlKGksIDEpO1xuICAgICAgLy8gVG9wIGNoYW5nZWQgb25seSBpZiB0aGUgcmVtb3ZlZCBlbGVtZW50IHdhcyB0aGUgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoaSA9PT0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX3RvcENoYW5nZWRdKHRoaXMudG9wKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgdG9wICYmIHRoaXMucmVtb3ZlKHRvcCk7XG4gICAgICByZXR1cm4gdG9wO1xuICAgIH1cblxuICAgIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmluZGV4T2YoZWxlbWVudCkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYGluZXJ0YCB0byBhbGwgZG9jdW1lbnQgZWxlbWVudHMgZXhjZXB0IHRoZSBuZXcgdG9wIGVsZW1lbnQsIGl0c1xuICAgICAqIHBhcmVudHMsIGFuZCBpdHMgZGlzdHJpYnV0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBwcml2YXRlW190b3BDaGFuZ2VkXShuZXdUb3A6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZXxudWxsKTogdm9pZCB7XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGNvbnN0IG9sZFBhcmVudHMgPSB0aGlzW190b3BFbFBhcmVudHNdO1xuICAgICAgLy8gTm8gbmV3IHRvcCwgcmVzZXQgb2xkIHRvcCBpZiBhbnkuXG4gICAgICBpZiAoIW5ld1RvcCkge1xuICAgICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzKTtcbiAgICAgICAgdG9LZWVwSW5lcnQuY2xlYXIoKTtcbiAgICAgICAgdGhpc1tfdG9wRWxQYXJlbnRzXSA9IFtdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1BhcmVudHMgPSB0aGlzW19nZXRQYXJlbnRzXShuZXdUb3ApO1xuICAgICAgLy8gTmV3IHRvcCBpcyBub3QgY29udGFpbmVkIGluIHRoZSBtYWluIGRvY3VtZW50IVxuICAgICAgaWYgKG5ld1BhcmVudHNbbmV3UGFyZW50cy5sZW5ndGggLSAxXS5wYXJlbnROb2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb24tY29ubmVjdGVkIGVsZW1lbnQgY2Fubm90IGJlIGEgYmxvY2tpbmcgZWxlbWVudCcpO1xuICAgICAgfVxuICAgICAgLy8gQ2FzdCBoZXJlIGJlY2F1c2Ugd2Uga25vdyB3ZSdsbCBjYWxsIF9pbmVydFNpYmxpbmdzIG9uIG5ld1BhcmVudHNcbiAgICAgIC8vIGJlbG93LlxuICAgICAgdGhpc1tfdG9wRWxQYXJlbnRzXSA9IG5ld1BhcmVudHMgYXMgQXJyYXk8SGFzSW50ZXJuYWxTdGF0ZT47XG5cbiAgICAgIGNvbnN0IHRvU2tpcCA9IHRoaXNbX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW5dKG5ld1RvcCk7XG5cbiAgICAgIC8vIE5vIHByZXZpb3VzIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKCFvbGRQYXJlbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLCB0b1NraXAsIHRvS2VlcEluZXJ0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSA9IG9sZFBhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBqID0gbmV3UGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgLy8gRmluZCBjb21tb24gcGFyZW50LiBJbmRleCAwIGlzIHRoZSBlbGVtZW50IGl0c2VsZiAoc28gc3RvcCBiZWZvcmUgaXQpLlxuICAgICAgd2hpbGUgKGkgPiAwICYmIGogPiAwICYmIG9sZFBhcmVudHNbaV0gPT09IG5ld1BhcmVudHNbal0pIHtcbiAgICAgICAgaS0tO1xuICAgICAgICBqLS07XG4gICAgICB9XG4gICAgICAvLyBJZiB1cCB0aGUgcGFyZW50cyB0cmVlIHRoZXJlIGFyZSAyIGVsZW1lbnRzIHRoYXQgYXJlIHNpYmxpbmdzLCBzd2FwXG4gICAgICAvLyB0aGUgaW5lcnRlZCBzaWJsaW5nLlxuICAgICAgaWYgKG9sZFBhcmVudHNbaV0gIT09IG5ld1BhcmVudHNbal0pIHtcbiAgICAgICAgdGhpc1tfc3dhcEluZXJ0ZWRTaWJsaW5nXShvbGRQYXJlbnRzW2ldLCBuZXdQYXJlbnRzW2pdKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlc3RvcmUgb2xkIHBhcmVudHMgc2libGluZ3MgaW5lcnRuZXNzLlxuICAgICAgaSA+IDAgJiYgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cy5zbGljZSgwLCBpKSk7XG4gICAgICAvLyBNYWtlIG5ldyBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0LlxuICAgICAgaiA+IDAgJiYgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cy5zbGljZSgwLCBqKSwgdG9Ta2lwLCBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyBpbmVydG5lc3MgYmV0d2VlbiB0d28gc2libGluZyBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19zd2FwSW5lcnRlZFNpYmxpbmddKFxuICAgICAgICBvbGRJbmVydDogSGFzSW50ZXJuYWxTdGF0ZSwgbmV3SW5lcnQ6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZSk6IHZvaWQge1xuICAgICAgY29uc3Qgc2libGluZ3NUb1Jlc3RvcmUgPSBvbGRJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgLy8gb2xkSW5lcnQgaXMgbm90IGNvbnRhaW5lZCBpbiBzaWJsaW5ncyB0byByZXN0b3JlLCBzbyB3ZSBoYXZlIHRvIGNoZWNrXG4gICAgICAvLyBpZiBpdCdzIGluZXJ0YWJsZSBhbmQgaWYgYWxyZWFkeSBpbmVydC5cbiAgICAgIGlmICh0aGlzW19pc0luZXJ0YWJsZV0ob2xkSW5lcnQpICYmICFvbGRJbmVydC5pbmVydCkge1xuICAgICAgICBvbGRJbmVydC5pbmVydCA9IHRydWU7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmFkZChvbGRJbmVydCk7XG4gICAgICB9XG4gICAgICAvLyBJZiBuZXdJbmVydCB3YXMgYWxyZWFkeSBiZXR3ZWVuIHRoZSBzaWJsaW5ncyB0byByZXN0b3JlLCBpdCBtZWFucyBpdCBpc1xuICAgICAgLy8gaW5lcnRhYmxlIGFuZCBtdXN0IGJlIHJlc3RvcmVkLlxuICAgICAgaWYgKHNpYmxpbmdzVG9SZXN0b3JlLmhhcyhuZXdJbmVydCkpIHtcbiAgICAgICAgbmV3SW5lcnQuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuZGVsZXRlKG5ld0luZXJ0KTtcbiAgICAgIH1cbiAgICAgIG5ld0luZXJ0W19wYXJlbnRNT10gPSBvbGRJbmVydFtfcGFyZW50TU9dO1xuICAgICAgbmV3SW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHNpYmxpbmdzVG9SZXN0b3JlO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3BhcmVudE1PXSA9IHVuZGVmaW5lZDtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19zaWJsaW5nc1RvUmVzdG9yZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgb3JpZ2luYWwgaW5lcnRuZXNzIHRvIHRoZSBzaWJsaW5ncyBvZiB0aGUgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10oZWxlbWVudHM6IEhhc0ludGVybmFsU3RhdGVbXSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IG1vID0gZWxlbWVudFtfcGFyZW50TU9dO1xuICAgICAgICBtby5kaXNjb25uZWN0KCk7XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3BhcmVudE1PXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAgIGZvciAoY29uc3Qgc2libGluZyBvZiBzaWJsaW5ncykge1xuICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19zaWJsaW5nc1RvUmVzdG9yZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5lcnRzIHRoZSBzaWJsaW5ncyBvZiB0aGUgZWxlbWVudHMgZXhjZXB0IHRoZSBlbGVtZW50cyB0byBza2lwLiBTdG9yZXNcbiAgICAgKiB0aGUgaW5lcnRlZCBzaWJsaW5ncyBpbnRvIHRoZSBlbGVtZW50J3Mgc3ltYm9sIGBfc2libGluZ3NUb1Jlc3RvcmVgLlxuICAgICAqIFBhc3MgYHRvS2VlcEluZXJ0YCB0byBjb2xsZWN0IHRoZSBhbHJlYWR5IGluZXJ0IGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX2luZXJ0U2libGluZ3NdKFxuICAgICAgICBlbGVtZW50czogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10sIHRvU2tpcDogU2V0PEhUTUxFbGVtZW50PnxudWxsLFxuICAgICAgICB0b0tlZXBJbmVydDogU2V0PEhUTUxFbGVtZW50PnxudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgLy8gQXNzdW1lIGVsZW1lbnQgaXMgbm90IGEgRG9jdW1lbnQsIHNvIGl0IG11c3QgaGF2ZSBhIHBhcmVudE5vZGUuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSE7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBuZXcgU2V0PEhUTUxFbGVtZW50PigpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IGNoaWxkcmVuW2pdIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICAvLyBTa2lwIHRoZSBpbnB1dCBlbGVtZW50LCBpZiBub3QgaW5lcnRhYmxlIG9yIHRvIGJlIHNraXBwZWQuXG4gICAgICAgICAgaWYgKHNpYmxpbmcgPT09IGVsZW1lbnQgfHwgIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSB8fFxuICAgICAgICAgICAgICAodG9Ta2lwICYmIHRvU2tpcC5oYXMoc2libGluZykpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2hvdWxkIGJlIGNvbGxlY3RlZCBzaW5jZSBhbHJlYWR5IGluZXJ0ZWQuXG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9yZSB0aGUgc2libGluZ3MgdGhhdCB3ZXJlIGluZXJ0ZWQuXG4gICAgICAgIGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IGluZXJ0ZWRTaWJsaW5ncztcbiAgICAgICAgLy8gT2JzZXJ2ZSBvbmx5IGltbWVkaWF0ZSBjaGlsZHJlbiBtdXRhdGlvbnMgb24gdGhlIHBhcmVudC5cbiAgICAgICAgY29uc3QgbW8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzW19oYW5kbGVNdXRhdGlvbnNdLmJpbmQodGhpcykpO1xuICAgICAgICBlbGVtZW50W19wYXJlbnRNT10gPSBtbztcbiAgICAgICAgbGV0IHBhcmVudFRvT2JzZXJ2ZSA9IHBhcmVudDtcbiAgICAgICAgLy8gSWYgd2UncmUgdXNpbmcgdGhlIFNoYWR5RE9NIHBvbHlmaWxsLCB0aGVuIG91ciBwYXJlbnQgY291bGQgYmUgYVxuICAgICAgICAvLyBzaGFkeSByb290LCB3aGljaCBpcyBhbiBvYmplY3QgdGhhdCBhY3RzIGxpa2UgYSBTaGFkb3dSb290LCBidXQgaXNuJ3RcbiAgICAgICAgLy8gYWN0dWFsbHkgYSBub2RlIGluIHRoZSByZWFsIERPTS4gT2JzZXJ2ZSB0aGUgcmVhbCBET00gcGFyZW50IGluc3RlYWQuXG4gICAgICAgIGNvbnN0IG1heWJlU2hhZHlSb290ID0gcGFyZW50VG9PYnNlcnZlIGFzIE1heWJlU2hhZHlSb290O1xuICAgICAgICBpZiAobWF5YmVTaGFkeVJvb3QuX19zaGFkeSAmJiBtYXliZVNoYWR5Um9vdC5ob3N0KSB7XG4gICAgICAgICAgcGFyZW50VG9PYnNlcnZlID0gbWF5YmVTaGFkeVJvb3QuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBtby5vYnNlcnZlKHBhcmVudFRvT2JzZXJ2ZSwge1xuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBuZXdseSBhZGRlZC9yZW1vdmVkIG5vZGVzIGJ5IHRvZ2dsaW5nIHRoZWlyIGluZXJ0bmVzcy5cbiAgICAgKiBJdCBhbHNvIGNoZWNrcyBpZiB0aGUgY3VycmVudCB0b3AgQmxvY2tpbmcgRWxlbWVudCBoYXMgYmVlbiByZW1vdmVkLFxuICAgICAqIG5vdGlmeWluZyBhbmQgcmVtb3ZpbmcgaXQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfaGFuZGxlTXV0YXRpb25zXShtdXRhdGlvbnM6IE11dGF0aW9uUmVjb3JkW10pOiB2b2lkIHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSB0aGlzW190b3BFbFBhcmVudHNdO1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgc2hhZG93Um9vdCwgZ2V0IGl0cyBob3N0IGFzIHdlIHNraXAgc2hhZG93Um9vdHMgd2hlblxuICAgICAgICAvLyBjb21wdXRpbmcgX3RvcEVsUGFyZW50cy5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG11dGF0aW9uLnRhcmdldCBhcyBTaGFkb3dSb290KS5ob3N0IHx8IG11dGF0aW9uLnRhcmdldDtcbiAgICAgICAgY29uc3QgaWR4ID0gdGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5ID9cbiAgICAgICAgICAgIHBhcmVudHMubGVuZ3RoIDpcbiAgICAgICAgICAgIHBhcmVudHMuaW5kZXhPZih0YXJnZXQgYXMgSGFzSW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRDaGlsZCA9IHBhcmVudHNbaWR4IC0gMV07XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IGluZXJ0ZWRDaGlsZFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuXG4gICAgICAgIC8vIFRvIHJlc3RvcmUuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLnJlbW92ZWROb2Rlc1tpXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgaWYgKHNpYmxpbmcgPT09IGluZXJ0ZWRDaGlsZCkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdEZXRlY3RlZCByZW1vdmFsIG9mIHRoZSB0b3AgQmxvY2tpbmcgRWxlbWVudC4nKTtcbiAgICAgICAgICAgIHRoaXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmVydGVkU2libGluZ3MuaGFzKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuZGVsZXRlKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvIGluZXJ0LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24uYWRkZWROb2Rlc1tpXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgaWYgKCF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgZWxlbWVudCBpcyBpbmVydGFibGUuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfaXNJbmVydGFibGVdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gZmFsc2UgPT09IC9eKHN0eWxlfHRlbXBsYXRlfHNjcmlwdCkkLy50ZXN0KGVsZW1lbnQubG9jYWxOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIG5ld1BhcmVudHMgb2YgYW4gZWxlbWVudCwgc3RhcnRpbmcgZnJvbSBlbGVtZW50XG4gICAgICogKGluY2x1ZGVkKSB1cCB0byBgZG9jdW1lbnQuYm9keWAgKGV4Y2x1ZGVkKS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXRQYXJlbnRzXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IEFycmF5PEhUTUxFbGVtZW50PiB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgICBsZXQgY3VycmVudDogSFRNTEVsZW1lbnR8bnVsbHx1bmRlZmluZWQgPSBlbGVtZW50O1xuICAgICAgLy8gU3RvcCB0byBib2R5LlxuICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAvLyBTa2lwIHNoYWRvdyByb290cy5cbiAgICAgICAgaWYgKGN1cnJlbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNoYWRvd0RvbSB2MVxuICAgICAgICBpZiAoY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBDb2xsZWN0IHNsb3RzIGZyb20gZGVlcGVzdCBzbG90IHRvIHRvcC5cbiAgICAgICAgICB3aGlsZSAoY3VycmVudCA9IGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENvbnRpbnVlIHRoZSBzZWFyY2ggb24gdGhlIHRvcCBzbG90LlxuICAgICAgICAgIGN1cnJlbnQgPSBwYXJlbnRzLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnQgfHxcbiAgICAgICAgICAgIChjdXJyZW50IGFzIE5vZGUgYXMgU2hhZG93Um9vdCkuaG9zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpc3RyaWJ1dGVkIGNoaWxkcmVuIG9mIHRoZSBlbGVtZW50J3Mgc2hhZG93IHJvb3QuXG4gICAgICogUmV0dXJucyBudWxsIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhIHNoYWRvdyByb290LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW5dKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTpcbiAgICAgICAgU2V0PEhUTUxFbGVtZW50PnxudWxsIHtcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBlbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICBpZiAoIXNoYWRvd1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0PEhUTUxFbGVtZW50PigpO1xuICAgICAgbGV0IGk7XG4gICAgICBsZXQgajtcbiAgICAgIGxldCBub2RlcztcbiAgICAgIGNvbnN0IHNsb3RzID0gc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdzbG90Jyk7XG4gICAgICBpZiAoc2xvdHMubGVuZ3RoICYmIHNsb3RzWzBdLmFzc2lnbmVkTm9kZXMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZXMgPSBzbG90c1tpXS5hc3NpZ25lZE5vZGVzKHtcbiAgICAgICAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNbal0ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5hZGQobm9kZXNbal0gYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBObyBuZWVkIHRvIHNlYXJjaCBmb3IgPGNvbnRlbnQ+LlxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAoZG9jdW1lbnQgYXMgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cykuJGJsb2NraW5nRWxlbWVudHMgPVxuICAgICAgbmV3IEJsb2NraW5nRWxlbWVudHNJbXBsKCk7XG59KSgpO1xuIiwiaW1wb3J0IFwid2ljZy1pbmVydFwiO1xuaW1wb3J0IFwiYmxvY2tpbmctZWxlbWVudHNcIjtcbmltcG9ydCB7IERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMgfSBmcm9tIFwiYmxvY2tpbmctZWxlbWVudHNcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGdldERvY3VtZW50IH0gZnJvbSBcIi4vdXNlLWRvY3VtZW50LWNsYXNzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuZnVuY3Rpb24gYmxvY2tpbmdFbGVtZW50cygpIHsgcmV0dXJuIChnZXREb2N1bWVudCgpIGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzIH1cbi8qKlxuICogQWxsb3dzIGFuIGVsZW1lbnQgdG8gdHJhcCBmb2N1cyBieSBhcHBseWluZyB0aGUgXCJpbmVydFwiIGF0dHJpYnV0ZSB0byBhbGwgc2libGluZywgYXVudCwgYW5kIHVuY2xlIG5vZGVzLlxuICogXG4gKiBBdXRvbWF0aWNhbGx5IGhhbmRsZXMgY29uc2VjdXRpdmUgY2FsbHMgd2l0aCBhIGxvb3NlbHkgYXBwbGllZCBzdGFjayBvcGVyYXRpb24gXG4gKiAoc3BlY2lmaWNhbGx5IHZpYSBgYmxvY2tpbmdFbGVtZW50c2AsIHdpdGggYSBzbWFsbCBwb2x5ZmlsbCBiZWNhdXNlIEknbSBub3Qgc3VyZSBob3cgbG9uZ1xuICogaXQnbGwgdGFrZSB0byBmaW5kIGl0cyB3YXkgaW50byB0aGUgc3BlYywgaWYgZXZlcilcbiAqIEBwYXJhbSB0YXJnZXQgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCbG9ja2luZ0VsZW1lbnQ8RSBleHRlbmRzIEVsZW1lbnQ+KGVuYWJsZWQ6IGJvb2xlYW4sIGdldFRhcmdldDogKCkgPT4gKEUgfCBudWxsKSkge1xuXG4gICAgY29uc3Qgc3RhYmxlR2V0VGFyZ2V0ID0gdXNlU3RhYmxlQ2FsbGJhY2soZ2V0VGFyZ2V0KTtcblxuICAgIC8qKlxuICAgICAqIFB1c2gvcG9wIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nRWxlbWVudHMgc3RhY2suXG4gICAgICovXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gc3RhYmxlR2V0VGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBibG9ja2luZ0VsZW1lbnRzIHdpbGwgZmFpbCBpZiwgZm9yIGV4YW1wbGUsXG4gICAgICAgICAgICAvLyB0aGUgdGFyZ2V0IGVsZW1lbnQgaXNuJ3QgY29ubmVjdGVkIHRvIGRvY3VtZW50LmJvZHkuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHJhcmUsIGJ1dCBpdCdzIGJldHRlciB0byBmYWlsIHNpbGVudGx5IHdpdGggd2VpcmQgdGFiYmluZyBiZWhhdmlvclxuICAgICAgICAgICAgLy8gdGhhbiB0byBjcmFzaCB0aGUgZW50aXJlIGFwcGxpY2F0aW9uLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBibG9ja2luZ0VsZW1lbnRzKCkucHVzaCh0YXJnZXQgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tpbmdFbGVtZW50cygpLnJlbW92ZSh0YXJnZXQgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIC8vIFdlbGwsIHNlbWktc2lsZW50bHkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbZW5hYmxlZF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wRWxlbWVudCgpIHtcbiAgICByZXR1cm4gYmxvY2tpbmdFbGVtZW50cygpLnRvcDtcbn1cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGlzRm9jdXNhYmxlIH0gZnJvbSBcInRhYmJhYmxlXCI7XG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50IH0gZnJvbSBcIi4vdXNlLWFjdGl2ZS1lbGVtZW50XCI7XG5pbXBvcnQgeyBnZXRUb3BFbGVtZW50LCB1c2VCbG9ja2luZ0VsZW1lbnQgfSBmcm9tIFwiLi91c2UtYmxvY2tpbmctZWxlbWVudFwiO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tIFwiLi91c2UtZG9jdW1lbnQtY2xhc3NcIjtcbmltcG9ydCB7IE1lcmdlZFByb3BzLCB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IFVzZVJlZkVsZW1lbnRQcm9wc1JldHVyblR5cGUsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1RyYXBQYXJhbWV0ZXJzIHsgdHJhcEFjdGl2ZTogYm9vbGVhbjsgfVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUZvY3VzVHJhcFJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiwgXCJ1c2VSZWZFbGVtZW50UHJvcHNcIj4ge1xuICAgIHVzZUZvY3VzVHJhcFByb3BzOiBVc2VGb2N1c1RyYXBQcm9wczxFPjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUZvY3VzVHJhcFByb3BzUGFyYW1ldGVyczxFIGV4dGVuZHMgTm9kZT4gZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7IH1cbmV4cG9ydCB0eXBlIFVzZUZvY3VzVHJhcFByb3BzUmV0dXJuVHlwZTxFIGV4dGVuZHMgTm9kZSwgUCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+PiA9IE1lcmdlZFByb3BzPEUsIFVzZVJlZkVsZW1lbnRQcm9wc1JldHVyblR5cGU8RSwgUD4sIHsgIH0+XG5cbmV4cG9ydCB0eXBlIFVzZUZvY3VzVHJhcFByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiA9IDxQIGV4dGVuZHMgVXNlRm9jdXNUcmFwUHJvcHNQYXJhbWV0ZXJzPEU+Pihwcm9wczogUCkgPT4gVXNlRm9jdXNUcmFwUHJvcHNSZXR1cm5UeXBlPEUsIFA+O1xuXG5cblxuY29uc3QgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvID0gbmV3IE1hcDxFbGVtZW50IHwgbnVsbCwgKE5vZGUgJiBIVE1MT3JTVkdFbGVtZW50KT4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvY3VzVHJhcDxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgdHJhcEFjdGl2ZSB9OiBVc2VGb2N1c1RyYXBQYXJhbWV0ZXJzKTogVXNlRm9jdXNUcmFwUmV0dXJuVHlwZTxFPiB7XG4gICAgXG4gICAgY29uc3QgaGFuZGxlQWN0aXZlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHRyYXBBY3RpdmU6IGJvb2xlYW4sIGVsZW1lbnQ6IEUgfCBudWxsKSA9PiB7XG4gICAgICAgIGlmICh0cmFwQWN0aXZlICYmIGVsZW1lbnQpIHtcblxuICAgICAgICAgICAgbGV0IHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBleHRyYSBxdWV1ZU1pY3JvdGFzayBpcyBuZWVkZWQgZm9yXG4gICAgICAgICAgICAgICAgLy8gLi4ucmVhc29ucz9cbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50KT8uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFmSGFuZGxlID0gMDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGZvY3VzIHRvIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAvLyB0aGF0IGhhcyByZXR1cm5lZCB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAgICAgICAgbGV0IHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8uZ2V0KGdldFRvcEVsZW1lbnQoKSk/LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBcbiAgICBjb25zdCB7IGdldExhc3RBY3RpdmVFbGVtZW50LCB1c2VBY3RpdmVFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUFjdGl2ZUVsZW1lbnQ8RT4oeyBvbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjaygoZWxlbWVudDogRSB8IG51bGwpID0+IGhhbmRsZUFjdGl2ZUNoYW5nZSh0cmFwQWN0aXZlLCBlbGVtZW50KSkgfSk7XG5cblxuICAgIC8vIFdoZW4gdGhlIHRyYXAgYmVjb21lcyBhY3RpdmUsIGJlZm9yZSB3ZSBsZXQgdGhlIGJsb2NraW5nRWxlbWVudHMgaG9vayBydW4sXG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGF0ZXZlcidzIGN1cnJlbnRseSBmb2N1c2VkIGFuZCBzYXZlIGl0LlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgIGlmICh0cmFwQWN0aXZlICYmIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHRvIHdoYXRldmVyJ3MgY3VycmVudGx5IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICAgICAgICBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8uc2V0KGdldFRvcEVsZW1lbnQoKSwgKGdldExhc3RBY3RpdmVFbGVtZW50KCkgYXMgKE5vZGUgJiBIVE1MT3JTVkdFbGVtZW50KSkgPz8gZG9jdW1lbnQuYm9keSk7XG4gICAgICAgIH1cbiAgICB9LCBbdHJhcEFjdGl2ZV0pO1xuXG4gICAgdXNlQmxvY2tpbmdFbGVtZW50KHRyYXBBY3RpdmUsIGdldEVsZW1lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQW55IHRpbWUgd2UgYWN0aXZhdGUgb3IgZGVhY3RpdmF0ZSB0aGUgdHJhcCxcbiAgICAgKiBjaGFuZ2UgZm9jdXMgdG8gc29tZXRoaW5nIGVsc2UgKHNvbWV0aGluZyBpblxuICAgICAqIHRoZSB0cmFwIGlmIGl0J3MgYWN0aXZlLCBvciB3aGF0ZXZlciB3ZSd2ZVxuICAgICAqIHRyYWNrZWQgaW4gZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvIGlmIG5vdClcbiAgICAgKi9cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBoYW5kbGVBY3RpdmVDaGFuZ2UodHJhcEFjdGl2ZSwgZ2V0RWxlbWVudCgpKTtcbiAgICB9LCBbdHJhcEFjdGl2ZV0pO1xuXG4gICAgY29uc3QgdXNlRm9jdXNUcmFwUHJvcHMgPSAoPFAgZXh0ZW5kcyBVc2VGb2N1c1RyYXBQcm9wc1BhcmFtZXRlcnM8RT4+KHByb3BzOiBQKSA9PiB7XG4gICAgICAgIGNvbnN0IHAxID0gdXNlQWN0aXZlRWxlbWVudFByb3BzKHByb3BzKTtcbiAgICAgICAgY29uc3QgcDIgPSB7IFwiYXJpYS1tb2RhbFwiOiB0cmFwQWN0aXZlID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KCkocDEsIHAyKTtcbiAgICB9KTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlRm9jdXNUcmFwUHJvcHMsXG4gICAgICAgIGdldEVsZW1lbnRcbiAgICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IGNvbnRhaW5lZCB3aXRoaW4gdGhlIGdpdmVuIG5vZGUsIG9yIG51bGwgaWYgbm9uZSBhcmUgZm91bmQuXG4gKiBAcGFyYW0gZWxlbWVudCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0Rm9jdXNhYmxlKGVsZW1lbnQ6IE5vZGUpIHtcbiAgICBjb25zdCB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgeyBhY2NlcHROb2RlOiAobm9kZSkgPT4gKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGlzRm9jdXNhYmxlKG5vZGUpID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUIDogTm9kZUZpbHRlci5GSUxURVJfU0tJUCkgfSlcbiAgICBjb25zdCBmaXJzdEZvY3VzYWJsZSA9IHRyZWVXYWxrZXIuZmlyc3RDaGlsZCgpIGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCkgfCBudWxsO1xuICAgIHJldHVybiBmaXJzdEZvY3VzYWJsZTtcbn1cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE1lcmdlZFByb3BzLCB1c2VFZmZlY3QsIHVzZUdsb2JhbEhhbmRsZXIsIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCwgVGFnU2Vuc2l0aXZlUHJvcHMgfSBmcm9tIFwiLi9wcm9wc1wiO1xuXG5sZXQgcHVsc2UgPSAoXCJ2aWJyYXRlXCIgaW4gbmF2aWdhdG9yKSA/ICgoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMCkpIDogKCgpID0+IHsgfSk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBlbmFibGUvZGlzYWJsZSBidXR0b24gdmlicmF0aW9uIHB1bHNlcyBvbiBhbiBhcHAtd2lkZSBzY2FsZS5cbiAqIFxuICogXG4gKiBAcGFyYW0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcnVuIHdoZW4gYSBidXR0b24gaXMgdGFwcGVkLlxuICogKERlZmF1bHQgaXMgYCgpID0+IG5hdmlnYXRvci52aWJyYXRlKDEwKWAgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LCBhIG5vb3Agb3RoZXJ3aXNlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0QnV0dG9uVmlicmF0ZShmdW5jOiAoKSA9PiB2b2lkKSB7XG4gICAgcHVsc2UgPSBmdW5jO1xufVxuXG5leHBvcnQgdHlwZSBCdXR0b25QcmVzc0V2ZW50PEV2ZW50VHlwZSBleHRlbmRzIEV2ZW50PiA9IEV2ZW50VHlwZSAmIHsgW0V2ZW50RGV0YWlsXTogeyBwcmVzc2VkOiBib29sZWFuIHwgbnVsbCB9IH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUJ1dHRvblBhcmFtZXRlcnM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiBleHRlbmRzIFRhZ1NlbnNpdGl2ZVByb3BzPEU+IHtcbiAgICBwcmVzc2VkPzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgb25QcmVzcz8oZXZlbnQ6IEJ1dHRvblByZXNzRXZlbnQ8aC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+PiB8IEJ1dHRvblByZXNzRXZlbnQ8aC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PEU+IHwgQnV0dG9uUHJlc3NFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+Pj4pOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFCdXR0b25SZXR1cm5UeXBlPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIHVzZUFyaWFCdXR0b25Qcm9wczogVXNlQXJpYUJ1dHRvblByb3BzPEU+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VBcmlhQnV0dG9uUHJvcHM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IDxQIGV4dGVuZHMgVXNlQXJpYUJ1dHRvblByb3BzUGFyYW1ldGVyczxFPj4ocHJvcHM6IFApID0+IFVzZUFyaWFCdXR0b25Qcm9wc1JldHVyblR5cGU8RSwgUD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUJ1dHRvblByb3BzUGFyYW1ldGVyczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4geyB9XG5leHBvcnQgdHlwZSBVc2VBcmlhQnV0dG9uUHJvcHNSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgUCBleHRlbmRzIFVzZUFyaWFCdXR0b25Qcm9wc1BhcmFtZXRlcnM8RT4+ID1cbiAgICBNZXJnZWRQcm9wczxFLCB7IFwiYXJpYS1wcmVzc2VkXCI6IHN0cmluZyB8IHVuZGVmaW5lZDsgcm9sZTogc3RyaW5nOyB0YWJJbmRleDogbnVtYmVyOyBvbktleURvd246IGguSlNYLktleWJvYXJkRXZlbnRIYW5kbGVyPEU+OyBvbktleVVwOiBoLkpTWC5LZXlib2FyZEV2ZW50SGFuZGxlcjxFPjsgfSwgT21pdDxQLCBcImFyaWEtcHJlc3NlZFwiIHwgXCJ0YWJJbmRleFwiIHwgXCJyb2xlXCI+PiB8XG4gICAgTWVyZ2VkUHJvcHM8RSwgeyBcImFyaWEtcHJlc3NlZFwiOiBzdHJpbmcgfCB1bmRlZmluZWQ7IH0sIE9taXQ8UCwgXCJhcmlhLXByZXNzZWRcIiB8IFwidGFiSW5kZXhcIiB8IFwicm9sZVwiPj47XG5cblxuZnVuY3Rpb24gZXhjbHVkZXModGFyZ2V0OiBcImNsaWNrXCIgfCBcInNwYWNlXCIgfCBcImVudGVyXCIsIGV4Y2x1ZGU6IHVuZGVmaW5lZCB8IHsgY2xpY2s/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgc3BhY2U/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgZW50ZXI/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCB9KSB7XG4gICAgaWYgKGV4Y2x1ZGU/Llt0YXJnZXRdKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBzZWxlY3Rpb24uY29udGFpbnNOb2RlIGRvZXNuJ3QgYWNjb3VudCBmb3Igc2VsZWN0aW9uLmlzQ29sbGFwc2VkLFxuICogc28gaGVyZSdzIGEgd29ya2Fyb3VuZCBmb3IgdGhhdC5cbiAqIFxuICogV2UgYWxzbyBvbmx5IGxvb2sgZm9yIHRoZSBzZWxlY3Rpb24gZW5kIHRvIG9ubHkgY2F0Y2ggdGhlIFxuICogZXNzZW5zZSBvZiBhIG5vbi1leGlzdGFudCBcInNlbGVjdGlvbnN0b3BcIiBldmVudC5cbiAqIFxuICogQHBhcmFtIGVsZW1lbnQgXG4gKiBAcmV0dXJucyBcbiAqL1xuZnVuY3Rpb24gbm9kZVNlbGVjdGVkVGV4dExlbmd0aChlbGVtZW50OiBFdmVudFRhcmdldCB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50IGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHNlbGVjdGlvbj8ucmFuZ2VDb3VudCA/PyAwKTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbiEuZ2V0UmFuZ2VBdChpKSE7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhyYW5nZS5lbmRDb250YWluZXIpICYmICFzZWxlY3Rpb24/LmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbiEudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnMgdG8gY3JlYXRlIGEgXCJwcmVzc1wiLWxpa2UgZXZlbnQgZm9yXG4gKiBidXR0b25zIGFuZCBhbnl0aGluZyBlbHNlIHRoYXQncyBcImNsaWNrL3RhcC9wcmVzcy90b3VjaFwiLWFibGUuXG4gKiBcbiAqIE5vdGFibHksIHRoZSBmb2xsb3dpbmcgY2FzZXMgYXJlIGNvdmVyZWQ6XG4gKiAqIFRoZSB0YXJnZXQgZWxlbWVudCBpcyBwcm9wZXJseSBmb2N1c2VkLCBldmVuIG9uIGlPUyBTYWZhcmkgKCplc3BlY2lhbGx5KiBvbiBpT1MgU2FmYXJpKVxuICogKiBEb3VibGUtY2xpY2tzIHdvbid0IHNlbGVjdCB0ZXh0LiBcbiAqICogQ29udmVyc2VseSwgbWFudWFsbHkgc2VsZWN0aW5nIHRleHQgd29uJ3QgaW52b2tlIGEgcHJlc3MuXG4gKiAqIEtleWJvYXJkIGV2ZW50cyAmbWRhc2g7IGBlbnRlcmAgaW1tZWRpYXRlbHkgaW52b2tlcyB0aGUgaGFuZGxlciwgd2hpbGUgYHNwYWNlYCBpbnZva2VzIGl0IG9uIGtleXVwLlxuICogKiBIYXB0aWMgZmVlZGJhY2sgKG9uLCBsaWtlLCB0aGUgb25lIGJyb3dzZXIgY29tYmluYXRpb24gdGhhdCBzdXBwb3J0cyBpdCAmbWRhc2g7IHRoaXMgY2FuIGJlIGRpc2FibGVkIGFwcC13aWRlIHdpdGggYHNldEJ1dHRvblZpYnJhdGVgKVxuICogXG4gKiBJbiBhZGRpdGlvbiwgd2hlbiB0aGUgQ1NTIGA6YWN0aXZlYCBwc2V1ZG8tY2xhc3Mgd291bGQgYXBwbHkgdG8gYSBub3JtYWwgYnV0dG9uXG4gKiAoaS5lLiB3aGVuIGhvbGRpbmcgdGhlIHNwYWNlYmFyIG9yIGR1cmluZyBtb3VzZWRvd24pLCBgeyBcImRhdGEtcHNldWRvLWFjdGl2ZVwiOiBcInRydWVcIiB9YFxuICogaXMgYWRkZWQgdG8gdGhlIHByb3BzLiAgWW91IGNhbiBlaXRoZXIgbGV0IGl0IHBhc3MgdGhyb3VnaCBhbmQgc3R5bGUgaXQgdGhyb3VnaCBuZXcgQ1NTLFxuICogb3IgaW5zcGVjdCB0aGUgcmV0dXJuZWQgcHJvcHMgZm9yIGl0IGFuZCBhZGQgZS5nLiBhbiBgLmFjdGl2ZWAgY2xhc3MgZm9yIGV4aXN0aW5nIENTU1xuICogXG4gKiBAcGFyYW0gb25DbGlja1N5bmMgXG4gKiBAcGFyYW0gZXhjbHVkZSBXaGV0aGVyIHRoZSBwb2x5ZmlsbCBzaG91bGRuJ3QgYXBwbHkgKGNhbiBzcGVjaWZ5IGZvciBzcGVjaWZpYyBpbnRlcmFjdGlvbnMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQcmVzc0V2ZW50SGFuZGxlcnM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PihvbkNsaWNrU3luYzogKChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PEU+KSA9PiB2b2lkKSB8IG51bGwgfCB1bmRlZmluZWQsIGV4Y2x1ZGU6IHVuZGVmaW5lZCB8IHsgY2xpY2s/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgc3BhY2U/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgZW50ZXI/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCB9KSB7XG5cbiAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudDxFPih7fSk7XG5cbiAgICAvLyBBIGJ1dHRvbiBjYW4gYmUgYWN0aXZhdGVkIGluIG11bHRpcGxlIHdheXMsIHNvIG9uIHRoZSBvZmYgY2hhbmNlXG4gICAgLy8gdGhhdCBtdWx0aXBsZSBhcmUgdHJpZ2dlcmVkIGF0IG9uY2UsIHdlIG9ubHkgKmFjdHVhbGx5KiByZWdpc3RlclxuICAgIC8vIGEgcHJlc3Mgb25jZSBhbGwgb2Ygb3VyIFwib25cIiBzaWduYWxzIGhhdmUgdHVybmVkIGJhY2sgdG8gXCJvZmZcIi5cbiAgICAvLyBXZSBhcHByb3hpbWF0ZSB0aGlzIGJ5IGp1c3QgaW5jcmVtZW50aW5nIHdoZW4gYWN0aXZlLCBhbmRcbiAgICAvLyBkZWNyZW1lbnRpbmcgd2hlbiBkZWFjdGl2YXRlZC5cbiAgICAvL1xuICAgIC8vIEFzIGFuIGVtZXJnZW5jeSBmYWlsc2FmZSwgd2hlbiB0aGUgZWxlbWVudCBsb29zZXMgZm9jdXMsXG4gICAgLy8gdGhpcyBpcyByZXNldCBiYWNrIHRvIDAuXG4gICAgY29uc3QgW2FjdGl2ZSwgc2V0QWN0aXZlLCBnZXRBY3RpdmVdID0gdXNlU3RhdGUoMCk7XG5cbiAgICAvLyBJZiB3ZSB0aGUgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiBjaGFuZ2VzIHRvIGluY2x1ZGUgdGhpcyBlbGVtZW50XG4gICAgLy8gRFVSSU5HIGUuZy4gYSBtb3VzZWRvd24sIHRoZW4gd2UgZG9uJ3Qgd2FudCB0aGUgbW91c2V1cCB0byBcImNvdW50XCIsIGFzIGl0IHdlcmUsXG4gICAgLy8gYmVjYXVzZSBpdHMgb25seSBwdXJwb3NlIHdhcyBzZWxlY3RpbmcgdGV4dCwgbm90IGNsaWNraW5nIGJ1dHRvbnMuXG4gICAgLy9cbiAgICAvLyBUbyBjYXRjaCB0aGlzLCBhbnkgdGltZSB0aGUgdGV4dCBzZWxlY3Rpb24gaW5jbHVkZXMgdXMgd2hpbGUgaW4gdGhlIG1pZGRsZVxuICAgIC8vIG9mIGEgY2xpY2ssIHRoaXMgZmxhZyBpcyBzZXQsIHdoaWNoIGNhbmNlbHMgdGhlIGFjdGl2YXRpb24gb2YgYSBwcmVzcy5cbiAgICAvLyBUaGUgZmxhZyBpcyByZXNldCBhbnkgdGltZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IG9yIHRoZSBidXR0b24gaXNcbiAgICAvLyBubyBsb25nZXIgYWN0aXZlLlxuICAgIGNvbnN0IFt0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lLCBzZXRUZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lXSA9IHVzZVN0YXRlPERhdGUgfCBudWxsPihudWxsKTtcblxuICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwic2VsZWN0aW9uY2hhbmdlXCIsIF8gPT4ge1xuICAgICAgICBzZXRUZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lKHByZXYgPT4gbm9kZVNlbGVjdGVkVGV4dExlbmd0aChnZXRFbGVtZW50KCkpID09IDA/IG51bGwgOiBwcmV2ICE9IG51bGw/IHByZXYgOiBuZXcgRGF0ZSgpKTtcbiAgICB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmUgPT0gMClcbiAgICAgICAgICAgIHNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUobnVsbCk7XG4gICAgfSwgW2FjdGl2ZSA9PSAwXSk7XG5cbiAgICBjb25zdCBvbkFjdGl2ZVN0YXJ0ID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2xpY2tTeW5jPj4oKF8pID0+IHtcbiAgICAgICAgc2V0QWN0aXZlKGEgPT4gKythKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uQWN0aXZlU3RvcCA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvbkNsaWNrU3luYz4+KChlKSA9PiB7XG4gICAgICAgIHNldEFjdGl2ZShhID0+IE1hdGgubWF4KDAsIC0tYSkpO1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdGltZURpZmZlcmVuY2UgPSAodGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSA9PSBudWxsPyBudWxsIDogK2N1cnJlbnRUaW1lIC0gK3RleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUpO1xuXG4gICAgICAgIC8vIElmIHdlJ3JlIHNlbGVjdGluZyB0ZXh0IChoZXVyaXN0aWNhbGx5IGRldGVybWluZWQgYnkgc2VsZWN0aW5nIGZvciBsb25nZXIgdGhhbiAxLzQgYSBzZWNvbmQsIG9yIG1vcmUgdGhhbiAyIGNoYXJhY3RlcnMpXG4gICAgICAgIC8vIHRoZW4gdGhpcyBpc24ndCBhIHByZXNzIGV2ZW50LlxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBtZWFzdXJlIGdseXBocyBpbnN0ZWFkIG9mIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmICgodGltZURpZmZlcmVuY2UgJiYgdGltZURpZmZlcmVuY2UgPiAyNTApIHx8IG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZ2V0RWxlbWVudCgpKSA+PSAyKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2V0QWN0aXZlKCkgPD0gMCkge1xuICAgICAgICAgICAgaGFuZGxlUHJlc3MoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGhhbmRsZVByZXNzID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2xpY2tTeW5jPj4oKGUpID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2tTeW5jKSB7XG5cbiAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBlbGVtZW50IGlzIGZvY3VzZWQgaGVyZSBiZWNhdXNlIG9mIGlPUyBTYWZhcmkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSXQncyBhbHdheXMgaU9TIFNhZmFyaS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpT1MgU2FmYXJpICh0ZXN0ZWQgb24gMTIpIGRvd25yaWdodCByZWZ1c2VzIHRvIGFsbG93IFxuICAgICAgICAgICAgLy8gZWxlbWVudHMgdG8gYmUgbWFudWFsbHkgZm9jdXNlZCBVTkxFU1MgaXQgaGFwcGVucyB3aXRoaW5cbiAgICAgICAgICAgIC8vIGFuIGV2ZW50IGhhbmRsZXIgbGlrZSB0aGlzLiAgSXQgYWxzbyBkb2Vzbid0IGZvY3VzXG4gICAgICAgICAgICAvLyBidXR0b25zIGJ5IGRlZmF1bHQgd2hlbiBjbGlja2VkLCB0YXBwZWQsIGV0Yy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJZiBpdCBiZWNvbWVzIHByb2JsZW1hdGljIHRoYXQgYnV0dG9uLWxpa2VzIGV4cGxpY2l0bHkgYmVjb21lXG4gICAgICAgICAgICAvLyBmb2N1c2VkIHdoZW4gdGhleSBhcmUgcHJlc3NlZCwgdGhlbiBhbiBhbHRlcm5hdGl2ZSBzb2x1dGlvbiBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBxdWVzdGlvbiBvZiBcImhvdyBkbyBtZW51IGJ1dHRvbnMga2VlcCB0aGVpciBtZW51cyBvcGVuXCJcbiAgICAgICAgICAgIC8vIGFuZCBvdGhlciBmb2N1cy1yZWxhdGVkIG5vbnNlbnNlIG5lZWRzIHRvIGJlIGZpZ3VyZWQgb3V0LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZvciBpT1MgU2FmYXJpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBcImZvY3VzXCIgaW4gKGVsZW1lbnQgYXMgRXZlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQpKVxuICAgICAgICAgICAgICAgIChlbGVtZW50IGFzIEV2ZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50IHwgbnVsbCk/LmZvY3VzKCk7XG5cbiAgICAgICAgICAgIC8vIFdoYXRldmVyIHRoZSBicm93c2VyIHdhcyBnb2luZyB0byBkbyB3aXRoIHRoaXMgZXZlbnQsXG4gICAgICAgICAgICAvLyBmb3JnZXQgaXQuIFdlJ3JlIHR1cm5pbmcgaXQgaW50byBhIFwicHJlc3NcIiBldmVudC5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgLy8gQWxzbyBzdG9wIGFueW9uZSBlbHNlIGZyb20gbGlzdGVuaW5nIHRvIHRoaXMgZXZlbnQsXG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBleHBsaWNpdGx5IGhhbmRsaW5nIGl0LlxuICAgICAgICAgICAgLy8gKE5vdGFibHksIHRoaXMgYWxsb3dzIGxhYmVscyB0byB3cmFwIGlucHV0cywgd2l0aCB0aGVtXG4gICAgICAgICAgICAvLyBib3RoIGhhdmluZyBwcmVzcyBldmVudCBoYW5kbGVycywgd2l0aG91dCBkb3VibGUtZmlyaW5nKVxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgLy8gSGFwdGljIGZlZWRiYWNrIGZvciB0aGlzIHByZXNzIGV2ZW50XG4gICAgICAgICAgICBwdWxzZSgpO1xuXG4gICAgICAgICAgICAvLyBBY3R1YWxseSBjYWxsIG91ciBoYW5kbGVyLlxuICAgICAgICAgICAgb25DbGlja1N5bmMoZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG9uTW91c2VEb3duID0gZXhjbHVkZXMoXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgLy8gU3RvcCBkb3VibGUgY2xpY2tzIGZyb20gc2VsZWN0aW5nIHRleHQgaW4gYW4gY29tcG9uZW50IHRoYXQncyAqc3VwcG9zZWQqIHRvIGJlIGFjdGluZyBsaWtlIGEgYnV0dG9uLFxuICAgICAgICAvLyBidXQgYWxzbyBkb24ndCBwcmV2ZW50IHRoZSB1c2VyIGZyb20gc2VsZWN0aW5nIHRoYXQgdGV4dCBtYW51YWxseSBpZiB0aGV5IHJlYWxseSB3YW50IHRvXG4gICAgICAgIC8vICh3aGljaCB1c2VyLXNlbGVjdDogbm9uZSB3b3VsZCBkbywgYnV0IGNhbmNlbGxpbmcgYSBkb3VibGUgY2xpY2sgb24gbW91c2VEb3duIGRvZXNuJ3QpXG4gICAgICAgIGlmIChlLmRldGFpbCA+IDEpXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cblxuICAgICAgICBpZiAoZS5idXR0b24gPT09IDApXG4gICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xuICAgIH1cbiAgICBjb25zdCBvbk1vdXNlVXAgPSBleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xuICAgICAgICBpZiAoZS5idXR0b24gPT09IDAgJiYgYWN0aXZlID4gMClcbiAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25CbHVyID0gKF86IGguSlNYLlRhcmdldGVkRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgc2V0QWN0aXZlKDApO1xuICAgIH1cblxuXG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlID0gZXhjbHVkZXMoXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IG9uQmx1cjtcblxuICAgIGNvbnN0IG9uS2V5RG93biA9IGV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkgJiYgZXhjbHVkZXMoXCJlbnRlclwiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlOiBoLkpTWC5UYXJnZXRlZEtleWJvYXJkRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKGUua2V5ID09IFwiIFwiICYmIG9uQ2xpY2tTeW5jICYmICFleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBhY3RpdmF0ZSBpdCBvbiBhIHNwYWNlIGtleWRvd25cbiAgICAgICAgICAgIC8vIGJ1dCB3ZSBkbyBwcmV2ZW50RGVmYXVsdCB0byBzdG9wIHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nLlxuICAgICAgICAgICAgb25BY3RpdmVTdGFydChlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLmtleSA9PSBcIkVudGVyXCIgJiYgIWV4Y2x1ZGVzKFwiZW50ZXJcIiwgZXhjbHVkZSkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XG4gICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvbktleVVwID0gZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlOiBoLkpTWC5UYXJnZXRlZEtleWJvYXJkRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKGUua2V5ID09IFwiIFwiICYmICFleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpKVxuICAgICAgICAgICAgb25BY3RpdmVTdG9wKGUpO1xuICAgIH1cblxuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZTogaC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGUuZGV0YWlsID4gMSkge1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4ocHJvcHM6IFApID0+IHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VNZXJnZWRQcm9wczxFPigpKHsgb25LZXlEb3duLCBvbktleVVwLCBvbkJsdXIsIG9uTW91c2VEb3duLCBvbk1vdXNlVXAsIG9uTW91c2VMZWF2ZSwgb25DbGljaywgc3R5bGU6ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lICE9IG51bGwpID8geyBjdXJzb3I6IFwidGV4dFwiIH0gOiB1bmRlZmluZWQsIC4uLnsgXCJkYXRhLXBzZXVkby1hY3RpdmVcIjogYWN0aXZlICYmICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lID09IG51bGwpID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSBhcyB7fSB9LCBwcm9wcykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYUJ1dHRvbjxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KHsgdGFnLCBwcmVzc2VkLCBvblByZXNzIH06IFVzZUFyaWFCdXR0b25QYXJhbWV0ZXJzPEU+KTogVXNlQXJpYUJ1dHRvblJldHVyblR5cGU8RT4ge1xuXG4gICAgZnVuY3Rpb24gdXNlQXJpYUJ1dHRvblByb3BzPFAgZXh0ZW5kcyBVc2VBcmlhQnV0dG9uUHJvcHNQYXJhbWV0ZXJzPEU+Pih7IFwiYXJpYS1wcmVzc2VkXCI6IGFyaWFQcmVzc2VkLCB0YWJJbmRleCwgcm9sZSwgLi4ucCB9OiBQKTogVXNlQXJpYUJ1dHRvblByb3BzUmV0dXJuVHlwZTxFLCBQPiB7XG5cbiAgICAgICAgY29uc3QgcHJvcHMgPSB1c2VQcmVzc0V2ZW50SGFuZGxlcnM8RT4oKGUpID0+IG9uUHJlc3M/LihlbmhhbmNlRXZlbnQoZSwgeyBwcmVzc2VkOiBwcmVzc2VkID09IG51bGwgPyBudWxsIDogIXByZXNzZWQgfSkpLCB1bmRlZmluZWQpKHApO1xuXG4gICAgICAgIGNvbnN0IGJ1dHRvblByb3BzID0geyByb2xlLCB0YWJJbmRleCwgXCJhcmlhLXByZXNzZWRcIjogYXJpYVByZXNzZWQgPz8gKHByZXNzZWQgPT09IHRydWUgPyBcInRydWVcIiA6IHByZXNzZWQgPT09IGZhbHNlID8gXCJmYWxzZVwiIDogdW5kZWZpbmVkKSB9O1xuICAgICAgICBjb25zdCBkaXZQcm9wcyA9IHsgLi4uYnV0dG9uUHJvcHMsIHRhYkluZGV4OiB0YWJJbmRleCA/PyAwLCByb2xlOiByb2xlID8/IFwiYnV0dG9uXCIgfTtcbiAgICAgICAgY29uc3QgYW5jaG9yUHJvcHMgPSB7IC4uLmRpdlByb3BzIH07XG5cbiAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oKShidXR0b25Qcm9wcyBhcyBhbnksIHByb3BzIGFzIGFueSk7XG5cbiAgICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KCkoYW5jaG9yUHJvcHMgYXMgYW55LCBwcm9wcyBhcyBhbnkpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPigpKGRpdlByb3BzIGFzIGFueSwgcHJvcHMgYXMgYW55KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUFyaWFCdXR0b25Qcm9wc1xuICAgIH1cbn1cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkSW5mbywgdXNlQ2hpbGRGbGFnLCB1c2VDaGlsZE1hbmFnZXIsIHVzZUhhc0ZvY3VzLCB1c2VMaW5lYXJOYXZpZ2F0aW9uLCB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIFVzZVJhbmRvbUlkUHJvcHNSZXR1cm5UeXBlLCBVc2VSZWZFbGVtZW50UHJvcHNSZXR1cm5UeXBlLCBVc2VSZWZlcmVuY2VkSWRQcm9wc1JldHVyblR5cGUsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFRhZ1NlbnNpdGl2ZVByb3BzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZVByZXNzRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcblxuZXhwb3J0IHR5cGUgVXNlQXJpYUFjY29yZGlvbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMpID0+IFVzZUFyaWFBY2NvcmRpb25SZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudD47XG5leHBvcnQgdHlwZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbjxFIGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlQXJpYUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzKSA9PiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGU8RT47XG5leHBvcnQgdHlwZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiA9IDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHByb3BzOiBQKSA9PiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzUmV0dXJuVHlwZTxFLCBQPjtcbmV4cG9ydCB0eXBlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiA9IDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHByb3BzOiBQKSA9PiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wc1JldHVyblR5cGU8RSwgUD47XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uUGFyYW1ldGVycyB7XG4gICAgZXhwYW5kZWRJbmRleD86IG51bWJlciB8IG51bGw7XG4gICAgc2V0RXhwYW5kZWRJbmRleD8oaTogbnVtYmVyIHwgbnVsbCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUFjY29yZGlvblJldHVyblR5cGU8X1BhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb246IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPENoaWxkRWxlbWVudD47XG4gICAgbWFuYWdlZENoaWxkcmVuOiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkluZm9bXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkluZm8gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlcj4ge1xuICAgIG9wZW4/OiBib29sZWFuIHwgdW5kZWZpbmVkIHwgbnVsbDtcbiAgICBzZXRPcGVuRnJvbVBhcmVudChvcGVuOiBib29sZWFuKTogdm9pZDtcbiAgICBnZXRPcGVuRnJvbVBhcmVudCgpOiBib29sZWFuIHwgbnVsbDtcbiAgICBmb2N1cygpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVycyBleHRlbmRzIE9taXQ8VXNlQXJpYUFjY29yZGlvblNlY3Rpb25JbmZvLCBcInNldE9wZW5Gcm9tUGFyZW50XCIgfCBcImdldE9wZW5Gcm9tUGFyZW50XCIgfCBcImZvY3VzXCI+IHtcbiAgICBvcGVuPzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGU8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGV4cGFuZGVkOiBib29sZWFuIHwgbnVsbDtcbiAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlcjogVXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXI8Q2hpbGRFbGVtZW50PjtcbiAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHk6IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keTtcbn1cblxuZXhwb3J0IHR5cGUgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wc1JldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQsIFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4gPSBVc2VSZWZFbGVtZW50UHJvcHNSZXR1cm5UeXBlPEUsIFA+O1xuZXhwb3J0IHR5cGUgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHNSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50LCBQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+ID0gVXNlUmFuZG9tSWRQcm9wc1JldHVyblR5cGU8VXNlUmVmZXJlbmNlZElkUHJvcHNSZXR1cm5UeXBlPHsgcm9sZTogc3RyaW5nOyB9ICYgT21pdDxQLCBcInJvbGVcIj4sIFwiYXJpYS1sYWJlbGxlZGJ5XCI+PjtcblxuZXhwb3J0IHR5cGUgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXI8RSBleHRlbmRzIEVsZW1lbnQ+ID0gKHsgdGFnIH06IFRhZ1NlbnNpdGl2ZVByb3BzPEU+KSA9PiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclJldHVyblR5cGU8RT47XG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4geyB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzOiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzPEU+OyB9XG5leHBvcnQgdHlwZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHkgPSA8RSBleHRlbmRzIEVsZW1lbnQ+KCkgPT4gVXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UmV0dXJuVHlwZTxFPjtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4geyB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wczogVXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHM8RT47IH1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25Qcm9wc1BhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4geyB9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhQWNjb3JkaW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGV4cGFuZGVkSW5kZXgsIHNldEV4cGFuZGVkSW5kZXggfTogVXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMpOiBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQ+IHtcblxuICAgIGNvbnN0IFtsYXN0Rm9jdXNlZEluZGV4LCBzZXRMYXN0Rm9jdXNlZEluZGV4LCBfZ2V0TGFzdEZvY3VzZWRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbX2N1cnJlbnRGb2N1c2VkSW5kZXgsIHNldEN1cnJlbnRGb2N1c2VkSW5kZXgsIGdldEN1cnJlbnRGb2N1c2VkSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3Qgc3RhYmxlU2V0RXhwYW5kZWRJbmRleCA9IHVzZVN0YWJsZUNhbGxiYWNrKHNldEV4cGFuZGVkSW5kZXggPz8gKCgpID0+IHsgfSkpO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRBY2NvcmRpb25TZWN0aW9ucywgdXNlTWFuYWdlZENoaWxkOiB1c2VNYW5hZ2VkQ2hpbGRTZWN0aW9uIH0gPSB1c2VDaGlsZE1hbmFnZXI8VXNlQXJpYUFjY29yZGlvblNlY3Rpb25JbmZvPigpO1xuXG4gICAgY29uc3QgbmF2aWdhdGVUb0ZpcnN0ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBzZXRMYXN0Rm9jdXNlZEluZGV4KCgwKSk7IH0sIFtdKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTGFzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgc2V0TGFzdEZvY3VzZWRJbmRleCgobWFuYWdlZEFjY29yZGlvblNlY3Rpb25zLmxlbmd0aCAtIDEpKTsgfSwgW10pO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9QcmV2ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBzZXRMYXN0Rm9jdXNlZEluZGV4KGkgPT4gKChpID8/IDApIC0gMSkpIH0sIFtdKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTmV4dCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgc2V0TGFzdEZvY3VzZWRJbmRleChpID0+ICgoaSA/PyAwKSArIDEpKSB9LCBbXSk7XG4gICAgY29uc3QgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHMgfSA9IHVzZUxpbmVhck5hdmlnYXRpb248Q2hpbGRFbGVtZW50Pih7IG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZEFjY29yZGlvblNlY3Rpb25zLCBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcImJsb2NrXCIsIGluZGV4OiBsYXN0Rm9jdXNlZEluZGV4ID8/IDAsIG5hdmlnYXRlVG9GaXJzdCwgbmF2aWdhdGVUb0xhc3QsIG5hdmlnYXRlVG9QcmV2LCBuYXZpZ2F0ZVRvTmV4dCB9KTtcblxuICAgIHVzZUNoaWxkRmxhZyh7XG4gICAgICAgIGFjdGl2YXRlZEluZGV4OiBleHBhbmRlZEluZGV4LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRBY2NvcmRpb25TZWN0aW9ucyxcbiAgICAgICAgc2V0Q2hpbGRGbGFnOiAoaSwgb3BlbikgPT4gbWFuYWdlZEFjY29yZGlvblNlY3Rpb25zW2ldPy5zZXRPcGVuRnJvbVBhcmVudChvcGVuKSxcbiAgICAgICAgZ2V0Q2hpbGRGbGFnOiAoaSkgPT4gKG1hbmFnZWRBY2NvcmRpb25TZWN0aW9uc1tpXT8uZ2V0T3BlbkZyb21QYXJlbnQoKSA/PyBudWxsKVxuICAgIH0pO1xuXG4gICAgdXNlQ2hpbGRGbGFnKHtcbiAgICAgICAgYWN0aXZhdGVkSW5kZXg6IGxhc3RGb2N1c2VkSW5kZXgsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZEFjY29yZGlvblNlY3Rpb25zLFxuICAgICAgICBzZXRDaGlsZEZsYWc6IChpLCBvcGVuKSA9PiBvcGVuICYmIG1hbmFnZWRBY2NvcmRpb25TZWN0aW9uc1tpXS5mb2N1cygpLFxuICAgICAgICBnZXRDaGlsZEZsYWc6IChfKSA9PiBmYWxzZVxuICAgIH0pXG5cbiAgICBjb25zdCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbiA9IHVzZUNhbGxiYWNrPFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPENoaWxkRWxlbWVudD4+KChhcmdzOiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnMpOiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGU8Q2hpbGRFbGVtZW50PiA9PiB7XG5cbiAgICAgICAgY29uc3QgaW5kZXggPSBhcmdzLmluZGV4O1xuXG4gICAgICAgIGNvbnN0IFtvcGVuRnJvbVBhcmVudCwgc2V0T3BlbkZyb21QYXJlbnQsIGdldE9wZW5Gcm9tUGFyZW50XSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBudWxsPihudWxsKTtcblxuXG5cbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VCb2R5UmFuZG9tSWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRCb2R5SWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1hY2NvcmRpb24tc2VjdGlvbi1ib2R5LVwiIH0pO1xuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUHJvcHM6IHVzZUhlYWRSYW5kb21JZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlUmVmZXJlbmNlZEhlYWRJZFByb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLWFjY29yZGlvbi1zZWN0aW9uLWhlYWRlci1cIiB9KTtcblxuICAgICAgICBjb25zdCBvcGVuID0gKChhcmdzLm9wZW4gPz8gb3BlbkZyb21QYXJlbnQpID8/IG51bGwpO1xuXG4gICAgICAgIC8vIFRPRE86IENvbnZlcnQgdG8gdXNlIHVzZU1hbmFnZWRDaGlsZCBzbyB0aGF0IHRoaXMgaG9vayBcbiAgICAgICAgLy8gaXMgc3RhYmxlIHdpdGhvdXQgKGRpcmVjdGx5KSBkZXBlbmRpbmcgb24gdGhlIG9wZW4gc3RhdGUuXG4gICAgICAgIGNvbnN0IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyID0gdXNlQ2FsbGJhY2s8VXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXI8Q2hpbGRFbGVtZW50Pj4oZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXIoeyAuLi5fIH0pIHtcblxuICAgICAgICAgICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxDaGlsZEVsZW1lbnQ+KHtcbiAgICAgICAgICAgICAgICBvbkZvY3VzZWRDaGFuZ2VkOiB1c2VDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRGb2N1c2VkSW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50Rm9jdXNlZEluZGV4KG9sZEluZGV4ID0+IG9sZEluZGV4ID09PSBpbmRleCA/IG51bGwgOiBpbmRleCk7XG5cbiAgICAgICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZm9jdXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGdldEN1cnJlbnRGb2N1c2VkSW5kZXgoKSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAoZ2V0RWxlbWVudCgpIGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQpPy5mb2N1cygpO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGRQcm9wcyB9ID0gdXNlTWFuYWdlZENoaWxkU2VjdGlvbjxDaGlsZEVsZW1lbnQ+KHsgaW5kZXgsIG9wZW4sIHNldE9wZW5Gcm9tUGFyZW50LCBnZXRPcGVuRnJvbVBhcmVudCwgZm9jdXMgfSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4+KHsgW1wiYXJpYS1leHBhbmRlZFwiXTogYXJpYUV4cGFuZGVkLCBbXCJhcmlhLWRpc2FibGVkXCJdOiBhcmlhRGlzYWJsZWQsIC4uLnByb3BzIH06IFApOiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQsIFA+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG9uRm9jdXMgPSAoKSA9PiB7IHNldExhc3RGb2N1c2VkSW5kZXgoYXJncy5pbmRleCk7IH1cbiAgICAgICAgICAgICAgICBjb25zdCBvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0T3BlbkZyb21QYXJlbnQoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWJsZVNldEV4cGFuZGVkSW5kZXgobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWJsZVNldEV4cGFuZGVkSW5kZXgoYXJncy5pbmRleCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHJldEIgPSB1c2VNZXJnZWRQcm9wczxDaGlsZEVsZW1lbnQ+KCkoeyB0YWJJbmRleDogMCB9LCB1c2VQcmVzc0V2ZW50SGFuZGxlcnM8Q2hpbGRFbGVtZW50PihvbkNsaWNrLCB1bmRlZmluZWQpKHByb3BzKSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXQzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+XG4gICAgICAgICAgICAgICAgICAgID0gdXNlTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50PigpKHVzZUhlYWRSYW5kb21JZFByb3BzKHVzZVJlZmVyZW5jZWRCb2R5SWRQcm9wcyhcImFyaWEtY29udHJvbHNcIikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IChhcmlhRXhwYW5kZWQgPz8gKCEhb3BlbikudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFyaWEtZGlzYWJsZWRcIjogKGFyaWFEaXNhYmxlZCA/PyAob3BlbiA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi51c2VIYXNGb2N1c1Byb3BzKHVzZU1hbmFnZWRDaGlsZFByb3BzKHJldEIpKVxuICAgICAgICAgICAgICAgICAgICB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pKSwgeyBvbkZvY3VzIH0pO1xuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTGluZWFyTmF2aWdhdGlvblByb3BzKHJldDMpIGFzIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHNSZXR1cm5UeXBlPENoaWxkRWxlbWVudCwgUD47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHMgfTtcbiAgICAgICAgfSwgW3VzZUxpbmVhck5hdmlnYXRpb25Qcm9wcywgaW5kZXgsIG9wZW5dKTtcblxuXG4gICAgICAgIGNvbnN0IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keTxFIGV4dGVuZHMgRWxlbWVudD4oKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHsgcm9sZSwgLi4ucHJvcHMgfTogUCk6IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzUmV0dXJuVHlwZTxFLCBQPiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0MSA9IHVzZVJlZmVyZW5jZWRIZWFkSWRQcm9wcyhcImFyaWEtbGFiZWxsZWRieVwiKSh7IHJvbGU6IHJvbGUgPz8gXCJyZWdpb25cIiwgLi4ucHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0MiA9IHVzZUJvZHlSYW5kb21JZFByb3BzKHJldDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wc1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGV4cGFuZGVkOiBvcGVuLFxuICAgICAgICAgICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXIsXG4gICAgICAgICAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHksXG4gICAgICAgIH1cbiAgICB9LCBbdXNlTGluZWFyTmF2aWdhdGlvblByb3BzXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkQWNjb3JkaW9uU2VjdGlvbnNcbiAgICB9XG59XG5cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgTWVyZ2VkUHJvcHMsIHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgVXNlUmFuZG9tSWRQcm9wc1JldHVyblR5cGUsIHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQcm9wc1JldHVyblR5cGUsIFVzZVJlZmVyZW5jZWRJZFByb3BzUmV0dXJuVHlwZSwgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFRhZ1NlbnNpdGl2ZVByb3BzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZVByZXNzRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VHZW5lcmljTGFiZWxQYXJhbWV0ZXJzIHtcbiAgICBsYWJlbFByZWZpeDogc3RyaW5nO1xuICAgIGlucHV0UHJlZml4OiBzdHJpbmc7XG4gICAgYmFja3VwVGV4dD86IHN0cmluZ1xufVxuXG4vKipcbiAqIEFkZHMgYW4gSUQgYW5kIFwiYXJpYS1sYWJlbGxlZGJ5XCIgZm9yIHR3byBlbGVtZW50cywgYW4gXCJpbnB1dFwiIGVsZW1lbnQgYW5kIGEgXCJsYWJlbFwiIGVsZW1lbnQuXG4gKiBcbiAqIFJldHVybnMgdGhlIGB1c2VSZWZlcmVuY2VkSWRQcm9wc2AgaG9va3MgaWYgeW91IG5lZWQgdG8gYWxzbyBhZGQgb3RoZXIgSUQtcmVmZXJlbmNpbmcgYXR0cmlidXRlcywgbGlrZSBgZm9yYFxuICogXG4gKiBAc2VlIHVzZUlucHV0TGFiZWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUdlbmVyaWNMYWJlbCh7IGxhYmVsUHJlZml4LCBpbnB1dFByZWZpeCwgYmFja3VwVGV4dCB9OiBVc2VHZW5lcmljTGFiZWxQYXJhbWV0ZXJzID0geyBsYWJlbFByZWZpeDogXCJsYWJlbC1cIiwgaW5wdXRQcmVmaXg6IFwiaW5wdXQtXCIgfSkge1xuXG4gICAgY29uc3QgW2xhYmVsRWxlbWVudCwgc2V0TGFiZWxFbGVtZW50XSA9IHVzZVN0YXRlPEVsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbaW5wdXRFbGVtZW50LCBzZXRJbnB1dEVsZW1lbnRdID0gdXNlU3RhdGU8RWxlbWVudCB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0TGFiZWxFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUxhYmVsUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PGFueT4oeyBvbkVsZW1lbnRDaGFuZ2U6IHNldExhYmVsRWxlbWVudCB9KTtcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldElucHV0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VJbnB1dFJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxhbnk+KHsgb25FbGVtZW50Q2hhbmdlOiBzZXRJbnB1dEVsZW1lbnQgfSk7XG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VMYWJlbFJhbmRvbUlkUHJvcHMsIGlkOiBsYWJlbElkLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlUmVmZXJlbmNlZExhYmVsSWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IGxhYmVsUHJlZml4IH0pO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlSW5wdXRSYW5kb21JZFByb3BzLCBpZDogaW5wdXRJZCwgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBpbnB1dFByZWZpeCB9KTtcblxuICAgIGNvbnN0IGxhYmVsSGFzTW91bnRlZCA9ICEhKGxhYmVsRWxlbWVudCk7XG5cbiAgICBjb25zdCB1c2VHZW5lcmljTGFiZWxMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUdlbmVyaWNMYWJlbExhYmVsPEUgZXh0ZW5kcyBFbGVtZW50PigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHM6IDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHByb3BzOiBQKSA9PiB7IHJldHVybiB1c2VMYWJlbFJhbmRvbUlkUHJvcHModXNlTGFiZWxSZWZFbGVtZW50UHJvcHMocHJvcHMpKTsgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgdXNlR2VuZXJpY0xhYmVsSW5wdXQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VHZW5lcmljTGFiZWxJbnB1dDxFIGV4dGVuZHMgRWxlbWVudD4oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VHZW5lcmljTGFiZWxJbnB1dFByb3BzOiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+Pih7IFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZGJ5LCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLCAuLi5wcm9wcyB9OiBQKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoIWFyaWFMYWJlbGxlZGJ5KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiAodXNlSW5wdXRSYW5kb21JZFByb3BzKFxuICAgICAgICAgICAgICAgICAgICB1c2VSZWZlcmVuY2VkTGFiZWxJZFByb3BzKFwiYXJpYS1sYWJlbGxlZGJ5XCIpKFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlSW5wdXRSZWZFbGVtZW50UHJvcHMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlTWVyZ2VkUHJvcHM8RT4oKSh7IFwiYXJpYS1sYWJlbFwiOiAoIWxhYmVsSGFzTW91bnRlZCA/IGJhY2t1cFRleHQgOiBhcmlhTGFiZWwpID8/IGFyaWFMYWJlbCB9LCBwcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2xhYmVsSGFzTW91bnRlZF0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VHZW5lcmljTGFiZWxJbnB1dCxcbiAgICAgICAgdXNlR2VuZXJpY0xhYmVsTGFiZWwsXG4gICAgICAgIHVzZVJlZmVyZW5jZWRMYWJlbElkUHJvcHMsXG4gICAgICAgIHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMsXG4gICAgICAgIGxhYmVsSWQsXG4gICAgICAgIGlucHV0SWQsXG4gICAgICAgIGxhYmVsRWxlbWVudCxcbiAgICAgICAgaW5wdXRFbGVtZW50LFxuICAgICAgICBnZXRMYWJlbEVsZW1lbnQsXG4gICAgICAgIGdldElucHV0RWxlbWVudCxcbiAgICB9XG5cbn1cblxuZXhwb3J0IHR5cGUgVXNlSW5wdXRMYWJlbExhYmVsID0gPEUgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZyB9OiBUYWdTZW5zaXRpdmVQcm9wczxFPikgPT4ge1xuICAgIHVzZUlucHV0TGFiZWxMYWJlbFByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4ocHJvcHM6IFApOiBVc2VSYW5kb21JZFByb3BzUmV0dXJuVHlwZTxVc2VSZWZFbGVtZW50UHJvcHNSZXR1cm5UeXBlPGFueSwgUCB8IFVzZVJlZmVyZW5jZWRJZFByb3BzUmV0dXJuVHlwZTxQLCBcImZvclwiPj4+O1xufTtcblxuZXhwb3J0IHR5cGUgVXNlSW5wdXRMYWJlbElucHV0ID0gPEUgZXh0ZW5kcyBFbGVtZW50PigpID0+IHtcbiAgICB1c2VJbnB1dExhYmVsSW5wdXRQcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHByb3BzOiBQKTogVXNlUmFuZG9tSWRQcm9wc1JldHVyblR5cGU8VXNlUmVmZXJlbmNlZElkUHJvcHNSZXR1cm5UeXBlPFVzZVJlZkVsZW1lbnRQcm9wc1JldHVyblR5cGU8YW55LCBNZXJnZWRQcm9wczxFLCB7XG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgfSwgT21pdDxQLCBcImFyaWEtbGFiZWxsZWRieVwiIHwgXCJhcmlhLWxhYmVsXCI+Pj4sIFwiYXJpYS1sYWJlbGxlZGJ5XCI+Pjtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBhdHRyaWJ1dGVzIGBpZGAsIGBmb3JgLCBhbmQgYGFyaWEtbGFiZWxsZWRieWAgZm9yIHRvIHJlbGF0ZWQgZWxlbWVudHMuXG4gKiBcbiAqIEl0J3MgYXNzdW1lZCB0aGF0IHRoZSBsYWJlbCBpcyBhbiBgSFRNTExhYmVsRWxlbWVudGAsIGFuZCB0aGUgaW5wdXQgaXMgc29tZXRoaW5nIGZvciB3aGljaFxuICogdGhlIGBmb3JgIGF0dHJpYnV0ZSBjYW4gcmVmZXJlbmNlLlxuICogXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnB1dExhYmVsKHsgbGFiZWxQcmVmaXgsIGlucHV0UHJlZml4IH0gPSB7IGxhYmVsUHJlZml4OiBcImxhYmVsLVwiLCBpbnB1dFByZWZpeDogXCJpbnB1dC1cIiB9KSB7XG5cbiAgICBjb25zdCB7IHVzZUdlbmVyaWNMYWJlbElucHV0LCB1c2VHZW5lcmljTGFiZWxMYWJlbCwgdXNlUmVmZXJlbmNlZElucHV0SWRQcm9wcywgaW5wdXRJZCwgbGFiZWxJZCwgaW5wdXRFbGVtZW50LCBnZXRJbnB1dEVsZW1lbnQsIGxhYmVsRWxlbWVudCwgZ2V0TGFiZWxFbGVtZW50IH0gPSB1c2VHZW5lcmljTGFiZWwoeyBsYWJlbFByZWZpeCwgaW5wdXRQcmVmaXggfSk7XG5cbiAgICBjb25zdCB1c2VJbnB1dExhYmVsTGFiZWw6IFVzZUlucHV0TGFiZWxMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUlucHV0TGFiZWxMYWJlbDxFIGV4dGVuZHMgRWxlbWVudD4oeyB0YWcgfTogVGFnU2Vuc2l0aXZlUHJvcHM8RT4pIHtcbiAgICAgICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxMYWJlbFByb3BzIH0gPSB1c2VHZW5lcmljTGFiZWxMYWJlbDxFPigpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VJbnB1dExhYmVsTGFiZWxQcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHByb3BzOiBQKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2l0aEZvciA9IHVzZVJlZmVyZW5jZWRJbnB1dElkUHJvcHMoXCJmb3JcIikocHJvcHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpdGhvdXRGb3IgPSBwcm9wcztcblxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VHZW5lcmljTGFiZWxMYWJlbFByb3BzKHRhZyA9PSBcImxhYmVsXCIgPyB3aXRoRm9yIDogd2l0aG91dEZvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbdXNlR2VuZXJpY0xhYmVsSW5wdXRdKTtcblxuICAgIGNvbnN0IHVzZUlucHV0TGFiZWxJbnB1dDogVXNlSW5wdXRMYWJlbElucHV0ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlSW5wdXRMYWJlbElucHV0PEUgZXh0ZW5kcyBFbGVtZW50PigpIHtcbiAgICAgICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VHZW5lcmljTGFiZWxJbnB1dDxFPigpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VJbnB1dExhYmVsSW5wdXRQcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHByb3BzOiBQKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUdlbmVyaWNMYWJlbElucHV0UHJvcHMocHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3VzZUdlbmVyaWNMYWJlbExhYmVsXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VJbnB1dExhYmVsTGFiZWwsXG4gICAgICAgIHVzZUlucHV0TGFiZWxJbnB1dCxcbiAgICAgICAgbGFiZWxJZCxcbiAgICAgICAgaW5wdXRJZCxcbiAgICAgICAgaW5wdXRFbGVtZW50LFxuICAgICAgICBsYWJlbEVsZW1lbnQsXG4gICAgICAgIGdldElucHV0RWxlbWVudCxcbiAgICAgICAgZ2V0TGFiZWxFbGVtZW50XG4gICAgfVxufVxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzPElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCI7XG4gICAgcm9sZTogc3RyaW5nO1xuICAgIGRpc2FibGVkOiBib29sZWFuO1xuICAgIGNoZWNrZWQ6IGJvb2xlYW47XG4gICAgb25JbnB1dD8oZXZlbnQ6IGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlPik6IHZvaWQ7XG4gICAgb25JbnB1dD8oZXZlbnQ6IGguSlNYLlRhcmdldGVkRXZlbnQ8TGFiZWxUeXBlPik6IHZvaWQ7XG59XG5cbmNvbnN0IGhhbmRsZXNJbnB1dCA9IDxFIGV4dGVuZHMgRWxlbWVudD4odGFnOiBFbGVtZW50VG9UYWc8RT4sIGxhYmVsUG9zaXRpb246IFwid3JhcHBpbmdcIiB8IFwic2VwYXJhdGVcIiwgd2hpY2g6IFwiaW5wdXQtZWxlbWVudFwiIHwgXCJsYWJlbC1lbGVtZW50XCIpID0+IHtcbiAgICBpZiAobGFiZWxQb3NpdGlvbiA9PT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICAgIGlmICh3aGljaCA9PT0gXCJpbnB1dC1lbGVtZW50XCIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAod2hpY2ggPT09IFwibGFiZWwtZWxlbWVudFwiKVxuICAgICAgICAgICAgcmV0dXJuIHRhZyAhPSBcImlucHV0XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT09IFwid3JhcHBpbmdcIikge1xuICAgICAgICBpZiAod2hpY2ggPT09IFwiaW5wdXQtZWxlbWVudFwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAod2hpY2ggPT0gXCJsYWJlbC1lbGVtZW50XCIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQ8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoeyB0YWcgfTogVGFnU2Vuc2l0aXZlUHJvcHM8SW5wdXRUeXBlPikgPT4ge1xuICAgIGdldElucHV0RWxlbWVudDogKCkgPT4gSW5wdXRUeXBlIHwgbnVsbDtcbiAgICB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wczogPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+Pih7IC4uLnAwIH06IFApID0+IE1lcmdlZFByb3BzPElucHV0VHlwZSwgUCwgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPj47XG59XG5cbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudDxMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9ICh7IHRhZyB9OiBUYWdTZW5zaXRpdmVQcm9wczxMYWJlbFR5cGU+KSA9PiB7XG4gICAgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHM6IDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPj4oeyAuLi5wMCB9OiBQKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+O1xufVxuXG4vKipcbiAqIEhhbmRsZXMgbGFiZWwgdHlwZSAod3JhcHBpbmcgb3Igc2VwYXJhdGUpIGZvciBjaGVja2JveGVzLCByYWRpb3MsIHN3aXRjaGVzLCBldGMuXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGVja2JveExpa2U8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4oeyBjaGVja2VkLCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgb25JbnB1dCwgcm9sZSB9OiBVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPikge1xuXG4gICAgY29uc3Qgc3RhYmxlT25JbnB1dCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0VHlwZT4gfCBoLkpTWC5UYXJnZXRlZEV2ZW50PExhYmVsVHlwZT4pID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBvbklucHV0Py4oZSBhcyBoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0VHlwZT4pOyB9KTtcblxuICAgIGNvbnN0IHsgdXNlSW5wdXRMYWJlbElucHV0OiB1c2VJTElucHV0LCB1c2VJbnB1dExhYmVsTGFiZWw6IHVzZUlMTGFiZWwsIGdldExhYmVsRWxlbWVudCwgZ2V0SW5wdXRFbGVtZW50IH0gPSB1c2VJbnB1dExhYmVsKHsgbGFiZWxQcmVmaXg6IFwiYXJpYS1jaGVja2JveC1sYWJlbC1cIiwgaW5wdXRQcmVmaXg6IFwiYXJpYS1jaGVja2JveC1pbnB1dC1cIiB9KTtcblxuXG5cblxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDogVXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50PElucHV0VHlwZT4gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VDaGVja2JveElucHV0RWxlbWVudCh7IHRhZyB9OiBUYWdTZW5zaXRpdmVQcm9wczxJbnB1dFR5cGU+KSB7XG4gICAgICAgIGNvbnN0IHsgdXNlSW5wdXRMYWJlbElucHV0UHJvcHM6IHVzZUlMSW5wdXRQcm9wcyB9ID0gdXNlSUxJbnB1dDxJbnB1dFR5cGU+KCk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PElucHV0VHlwZT4oe30pO1xuXG4gICAgICAgIC8vIG9uQ2xpY2sgYW5kIG9uQ2hhbmdlIGFyZSBhIGJpdCBtZXNzeSwgc28gd2UgbmVlZCB0b1xuICAgICAgICAvLyAqYWx3YXlzKiBtYWtlIHN1cmUgdGhhdCB0aGUgdmlzaWJsZSBzdGF0ZSBpcyBjb3JyZWN0XG4gICAgICAgIC8vIGFmdGVyIGFsbCB0aGUgZXZlbnQgZHVzdCBzZXR0bGVzLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMjc0NSxcbiAgICAgICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzE4OTkjaXNzdWVjb21tZW50LTUyNTY5MDE5NFxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHRhZyA9PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICAoZWxlbWVudCBhcyBFbGVtZW50IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSBjaGVja2VkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt0YWcsIGNoZWNrZWRdKVxuXG4gICAgICAgIHJldHVybiB7IGdldElucHV0RWxlbWVudDogZ2V0RWxlbWVudCwgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMgfTtcblxuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+Pih7IC4uLnAwIH06IFApIHtcblxuICAgICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBDaHJvbWUgd29uJ3QgZmlyZSBvbklucHV0IGV2ZW50cyBmb3IgcmFkaW8gYnV0dG9ucyB0aGF0IGFyZSB0YWJJbmRleD0tMT8/XG4gICAgICAgICAgICAvLyBOZWVkcyBpbnZlc3RpZ2F0aW5nLCBidXQgb25JbnB1dCB3b3JrcyBmaW5lIGluIEZpcmVmb3hcbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIGxldCBwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPiA9IHVzZVByZXNzRXZlbnRIYW5kbGVyczxJbnB1dFR5cGU+KGRpc2FibGVkIHx8ICFoYW5kbGVzSW5wdXQodGFnLCBsYWJlbFBvc2l0aW9uLCBcImlucHV0LWVsZW1lbnRcIikgPyB1bmRlZmluZWQgOiBzdGFibGVPbklucHV0LCB1bmRlZmluZWQpKHt9KTtcblxuICAgICAgICAgICAgaWYgKHRhZyA9PSBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgcHJvcHMub25JbnB1dCA9IChlOiBFdmVudCkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBwcm9wcyA9IHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VJTElucHV0UHJvcHMocHJvcHMpKTtcblxuXG4gICAgICAgICAgICBpZiAobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSB3cmFwcGVkIGxhYmVsIGhhbmRsZXMgYWxsIGludGVyYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGlzIGVsZW1lbnQgY2FuJ3QgYmUgaW50ZXJhY3RlZCB3aXRoXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpZiBpdCdzIGFuIGlucHV0IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgcHJvcHMuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgcHJvcHMub25Gb2N1cyA9IF8gPT4gZ2V0TGFiZWxFbGVtZW50KCkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0YWcgPT09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jaGVja2VkID0gY2hlY2tlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnJvbGUgPSByb2xlO1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy50YWJJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1jaGVja2VkXCJdID0gY2hlY2tlZCA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBkaXNhYmxlZC50b1N0cmluZygpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGxhYmVsIGNsaWNrcyBjYW4ndCBhZmZlY3QgdGhlIGNoZWNrYm94IHdoaWxlIGl0J3MgZGlzYWJsZWRcbiAgICAgICAgICAgIHByb3BzLm9uQ2xpY2sgPSBkaXNhYmxlZCA/ICgoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSkgOiBwcm9wcy5vbkNsaWNrO1xuXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8SW5wdXRUeXBlPigpKHAwLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9LCBbdXNlSUxJbnB1dCwgcm9sZSwgbGFiZWxQb3NpdGlvbiwgZGlzYWJsZWQsIGNoZWNrZWRdKTtcblxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KHsgdGFnIH06IFRhZ1NlbnNpdGl2ZVByb3BzPExhYmVsVHlwZT4pIHtcbiAgICAgICAgY29uc3QgeyB1c2VJbnB1dExhYmVsTGFiZWxQcm9wczogdXNlSUxMYWJlbFByb3BzIH0gPSB1c2VJTExhYmVsPExhYmVsVHlwZT4oeyB0YWcgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT4+KHsgLi4ucDAgfTogUCkge1xuXG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPiA9IHVzZVByZXNzRXZlbnRIYW5kbGVyczxMYWJlbFR5cGU+KGRpc2FibGVkIHx8ICFoYW5kbGVzSW5wdXQodGFnLCBsYWJlbFBvc2l0aW9uLCBcImxhYmVsLWVsZW1lbnRcIikgPyB1bmRlZmluZWQgOiBzdGFibGVPbklucHV0LCB1bmRlZmluZWQpKHt9KTtcblxuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAwLnRhYkluZGV4ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAocDAucm9sZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcy5yb2xlID0gcm9sZTtcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBkaXNhYmxlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1jaGVja2VkXCJdID0gY2hlY2tlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9uZSBjYXNlIHdoZXJlIHRoZXJlJ3MgYWxtb3N0IG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBub3JtYWwgY2FzZSB3aGVyZSBldmVyeXRoaW5nIGFjdHMgYWNjb3JkaW5nIG5vcm1hbCBIVE1MIG1lY2hhbmljcy5cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBKdXN0IG1ha2Ugc3VyZSB0aGF0IGxhYmVsIGNsaWNrcyBjYW4ndCBhZmZlY3QgdGhlIGNoZWNrYm94IHdoaWxlIGl0J3MgZGlzYWJsZWRcbiAgICAgICAgICAgIG5ld1Byb3BzLm9uQ2xpY2sgPSBkaXNhYmxlZCA/ICgoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSkgOiBuZXdQcm9wcy5vbkNsaWNrO1xuXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8TGFiZWxUeXBlPigpKG5ld1Byb3BzLCB1c2VJTExhYmVsUHJvcHMocDApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzIH07XG5cbiAgICB9LCBbdXNlSUxMYWJlbCwgZGlzYWJsZWQsIGNoZWNrZWQsIHJvbGUsIGxhYmVsUG9zaXRpb25dKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LFxuICAgICAgICB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsXG4gICAgICAgIGdldExhYmVsRWxlbWVudCxcbiAgICAgICAgZ2V0SW5wdXRFbGVtZW50XG4gICAgfTtcblxuXG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwsIFRhZ1NlbnNpdGl2ZVByb3BzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUNoZWNrYm94TGlrZSwgVXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xuXG5cblxuZXhwb3J0IHR5cGUgQ2hlY2tib3hDaGFuZ2VFdmVudDxFdmVudFR5cGUgZXh0ZW5kcyBFdmVudD4gPSBFdmVudFR5cGUgJiB7IFtFdmVudERldGFpbF06IHsgY2hlY2tlZDogYm9vbGVhbiB9IH07XG5cbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94SW5wdXRFbGVtZW50PElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKHsgdGFnIH06IFRhZ1NlbnNpdGl2ZVByb3BzPElucHV0VHlwZT4pID0+IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wczogPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+Pih7IC4uLnAwIH06IFApID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT47IH1cbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94TGFiZWxFbGVtZW50PExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKHsgdGFnIH06IFRhZ1NlbnNpdGl2ZVByb3BzPExhYmVsVHlwZT4pID0+IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wczogPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+Pih7IC4uLnAwIH06IFApID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT47IH1cblxuXG5pbnRlcmZhY2UgVXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIEw+LCBcIm9uSW5wdXRcIiB8IFwicm9sZVwiIHwgXCJjaGVja2VkXCI+IHtcbiAgICBjaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiO1xuICAgIG9uSW5wdXQ/KGV2ZW50OiBDaGVja2JveENoYW5nZUV2ZW50PGguSlNYLlRhcmdldGVkRXZlbnQ8ST4+KTogdm9pZDtcbiAgICBvbklucHV0PyhldmVudDogQ2hlY2tib3hDaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PEw+Pik6IHZvaWQ7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFDaGVja2JveDxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50Pih7IGxhYmVsUG9zaXRpb24sIGNoZWNrZWQsIG9uSW5wdXQsIGRpc2FibGVkIH06IFVzZUFyaWFDaGVja2JveFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KSB7XG5cbiAgICBjb25zdCBvbklucHV0RW5oYW5jZWQgPSAoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxJbnB1dFR5cGUgfCBMYWJlbFR5cGUsIEV2ZW50PikgPT4gb25JbnB1dD8uKGVuaGFuY2VFdmVudChlIGFzIGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlLCBFdmVudD4sIHsgY2hlY2tlZDogIWNoZWNrZWQgfSkpO1xuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQgfSA9IHVzZUNoZWNrYm94TGlrZTxJbnB1dFR5cGUsIExhYmVsVHlwZT4oeyBjaGVja2VkOiAhIWNoZWNrZWQsIGxhYmVsUG9zaXRpb24sIHJvbGU6IFwiY2hlY2tib3hcIiwgZGlzYWJsZWQsIG9uSW5wdXQ6IG9uSW5wdXRFbmhhbmNlZCB9KTtcblxuICAgIGNvbnN0IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50OiBVc2VDaGVja2JveElucHV0RWxlbWVudDxJbnB1dFR5cGU+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoeyB0YWcgfTogVGFnU2Vuc2l0aXZlUHJvcHM8SW5wdXRUeXBlPikge1xuICAgICAgICBjb25zdCB7IGdldElucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCh7IHRhZyB9KVxuICAgICAgICBjb25zdCBpc01peGVkID0gKGNoZWNrZWQgPT0gXCJtaXhlZFwiKTtcblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5wdXRFbGVtZW50ID0gZ2V0SW5wdXRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoaW5wdXRFbGVtZW50ICYmIHRhZyA9PT0gXCJpbnB1dFwiKSB7XG4gICAgICAgICAgICAgICAgKGlucHV0RWxlbWVudCBhcyBhbnkpLmluZGV0ZXJtaW5hdGUgPSBpc01peGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbaXNNaXhlZCwgdGFnXSk7XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4+KHsgLi4ucDAgfTogUCkge1xuXG4gICAgICAgICAgICBjb25zdCBwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPiA9IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzKHAwKTtcbiAgICAgICAgICAgIHByb3BzLmNoZWNrZWQgPz89ICEhY2hlY2tlZDtcblxuICAgICAgICAgICAgaWYgKHRhZyA9PSBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgcHJvcHMudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgICB9XG4gICAgfSwgW3VzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCwgY2hlY2tlZCwgbGFiZWxQb3NpdGlvbiwgZGlzYWJsZWRdKTtcblxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoeyB0YWcgfTogVGFnU2Vuc2l0aXZlUHJvcHM8TGFiZWxUeXBlPikge1xuICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQoeyB0YWcgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPj4oeyAuLi5wcm9wcyB9OiBQKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMocHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9O1xuICAgIH0sIFt1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uXSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50LFxuICAgICAgICB1c2VDaGVja2JveExhYmVsRWxlbWVudFxuICAgIH07XG5cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgdXNlTWVyZ2VkUHJvcHMsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuXG5leHBvcnQgdHlwZSBDaGVja2JveEdyb3VwQ2hhbmdlRXZlbnQ8RXZlbnRUeXBlIGV4dGVuZHMgRXZlbnQ+ID0gRXZlbnRUeXBlICYgeyBbRXZlbnREZXRhaWxdOiB7IGNoaWxkcmVuQ2hlY2tlZDogYm9vbGVhbiB8IE1hcDxudW1iZXIsIGJvb2xlYW4gfCBcIm1peGVkXCI+IH0gfTtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBwYXJlbnQgY2hlY2tib3ggaXMgY2hhbmdlZCBhbmQgYW4gdXBkYXRlIG9mXG4gICAgICogYWxsIHRoZSBjaGlsZHJlbiBuZWVkcyB0byBvY2N1ci5cbiAgICAgKiBcbiAgICAgKiBgZXZlbnRbRXZlbnREZXRhaWxdLmNoaWxkcmVuQ2hlY2tlZGAgd2lsbCBiZSBcbiAgICAgKiAqIHRydWUgd2hlbiBhbGwgY2hpbGRyZW4gbmVlZCB0byBiZWNvbWUgY2hlY2tlZFxuICAgICAqICogZmFsc2Ugd2hlbiBhbGwgY2hpbGRyZW4gbmVlZCB0byBiZWNvbWUgdW5jaGVja2VkXG4gICAgICogKiBBIGBNYXA8aW5kZXgsY2hlY2tlZD5gIG9mIGVhY2ggY2hpbGQncyBzdGF0dXMgd2hlbiByZXZlcnRpbmcgdG8gXCJtaXhlZFwiLlxuICAgICAqIFxuICAgICAqIEJlY2F1c2Ugd2UncmUgZGVhbGluZyB3aXRoIGNvbnRyb2xsZWQgY29tcG9uZW50cyBoZXJlLCBhbmQgdGhlIGRhdGEgZm9yXG4gICAgICogd2hhdCBjaGVja2JveGVzIGFyZSBjaGVja2VkIGxpdmUgKm91dHNpZGUqIG9mIGFueSBvZiB0aGVzZSBob29rcyxcbiAgICAgKiBpdCdzIHlvdSB3aG8ncyByZXNwb25zaWJsZSBmb3IgbGlzdGVuaW5nIGZvciB0aGlzIGV2ZW50LCBtb2RpZnlpbmcgdGhlXG4gICAgICogZGF0YSwgYW5kIHJlLXJlbmRlcmluZyBhcHByb3ByaWF0ZWx5LlxuICAgICAqIFxuICAgICAqIEhpZ2hseSByZWNvbW1lbmRlZCB0bywgZm9yIGV4YW1wbGUsIGFkZCBlYWNoIGNoaWxkJ3MgYG9uSW5wdXRgIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBhdmFpbGFibGUgaW4gdGhlIGNoaWxkIGluZm8gdGhlIHBhcmVudCBnZXRzIHNvIGl0IGNhbiBjYWxsIHRoZSBoYW5kbGVyXG4gICAgICogcmVtb3RlbHkgZnJvbSBgbWFuYWdlZENoZWNrYm94ZXNgLlxuICAgICAqIEBwYXJhbSBldmVudCBcbiAgICAgKi9cbiAgICBvblVwZGF0ZUNoaWxkcmVuKGV2ZW50OiBDaGVja2JveEdyb3VwQ2hhbmdlRXZlbnQ8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPj4pOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBDaGlsZEluZm8gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbyB7XG4gICAgLyoqXG4gICAgICogVGhlIGlkIGF0dHJpYnV0ZSB1c2VkIGZvciB0aGUgY2hpbGQuXG4gICAgICovXG4gICAgaWQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGNoZWNrZWQgc3RhdGUgb2YgdGhpcyBjaGlsZC5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGlzIHVzZWQgYnkgdGhlIHBhcmVudCB3aGVuZXZlciBpdCdzIGludGVyYWN0ZWQgd2l0aCBcbiAgICAgKiBhbmQgYWJvdXQgdG8gZm9yY2UgZXZlcnkgb25lIHRvIGJlIHNvbWV0aGluZyBkaWZmZXJlbnQgLS0gXG4gICAgICogaXQgd2lsbCBzYXZlIHRoZSBzdGF0ZSBvZiBhbGwgY2hpbGQgY2hlY2tib3hlcyBmb3IgbGF0ZXJcbiAgICAgKiBieSBhc2tpbmcgZWFjaCBvbmUgd2hhdCBpdHMgY3VycmVudCBzdGF0ZSBpcyBpbmRpdmlkdWFsbHlcbiAgICAgKiBhdCB0aGF0IG1vbWVudC5cbiAgICAgKiBcbiAgICAgKiBBbGwgdGhlIGNoZWNrYm94J3Mgc3RhdGVzIGFyZSBjYXB0dXJlZCB3aGVuIHRoZSBwYXJlbnRcbiAgICAgKiBpcyBpbiB0aGUgXCJtaXhlZFwiIHN0YXRlIGFuZCBpcyBjbGlja2VkLiBJdCBrZWVwcyB0aGVtXG4gICAgICogdGhhdCB3YXkgdW50aWwgdGhlIHNhbWUgY29uZGl0aW9ucyBhcmlzZSBhZ2Fpbi5cbiAgICAgKi9cbiAgICBnZXRDaGVja2VkKCk6IGJvb2xlYW4gfCBcIm1peGVkXCI7XG59XG5cbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQcm9wczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pj4ocHJvcHM6IFApID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD5cblxuXG5cbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SSBleHRlbmRzIFVzZUNoZWNrYm94R3JvdXBDaGlsZEluZm8+ID0gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8T21pdDxJLCBcImdldENoZWNrZWRcIj4+ICYgeyBjaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiIH07XG5cbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94R3JvdXBDaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgVXNlQ2hlY2tib3hHcm91cENoaWxkSW5mbz4gPSAoYXJnczogVXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJPikgPT4ge1xuICAgIHRhYmJhYmxlOiBib29sZWFuIHwgbnVsbDtcbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRQcm9wczogPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+Pih7IHRhYkluZGV4LCAuLi5wcm9wcyB9OiBQKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xufVxuXG5cblxuXG4vKipcbiAqIFxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGVja2JveEdyb3VwPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEkgZXh0ZW5kcyBVc2VDaGVja2JveEdyb3VwQ2hpbGRJbmZvPih7IGNvbGxhdG9yLCBrZXlOYXZpZ2F0aW9uLCBzaG91bGRGb2N1c09uQ2hhbmdlLCBvblVwZGF0ZUNoaWxkcmVuOiBvblVwZGF0ZUNoaWxkcmVuVW5zdGFibGUgfTogVXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50Pikge1xuXG4gICAgY29uc3Qgb25VcGRhdGVDaGlsZHJlbiA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uVXBkYXRlQ2hpbGRyZW5VbnN0YWJsZSk7XG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW4sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsIHRhYmJhYmxlSW5kZXgsIGZvY3VzQ3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9ID0gdXNlTGlzdE5hdmlnYXRpb248SW5wdXRFbGVtZW50LCBJPih7IGNvbGxhdG9yLCBrZXlOYXZpZ2F0aW9uLCBzaG91bGRGb2N1c09uQ2hhbmdlIH0pO1xuXG4gICAgLy9jb25zdCBbdW5jaGVja2VkQ291bnQsIHNldFVuaGVja2VkQ291bnRdID0gdXNlU3RhdGUoMCk7XG5cbiAgICBjb25zdCBbY2hlY2tlZENvdW50LCBzZXRDaGVja2VkQ291bnRdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgY2hlY2tlZEluZGljZXMgPSB1c2VSZWYobmV3IFNldDxudW1iZXI+KCkpO1xuICAgIC8vY29uc3QgW3NlbGZJc0NoZWNrZWQsIHNldFNlbGZJc0NoZWNrZWQsIGdldFNlbGZJc0NoZWNrZWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IFwibWl4ZWRcIj4oZmFsc2UpO1xuXG4gICAgY29uc3QgZ2V0U2VsZklzQ2hlY2tlZFVuc3RhYmxlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gY2hlY2tlZENvdW50IC8gbWFuYWdlZENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHBlcmNlbnRhZ2UgPD0gMCA/IGZhbHNlIDogcGVyY2VudGFnZSA+PSAxID8gdHJ1ZSA6IFwibWl4ZWRcIjtcbiAgICB9LCBbY2hlY2tlZENvdW50LCBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoXSk7XG5cbiAgICBjb25zdCBnZXRTZWxmSXNDaGVja2VkU3RhYmxlID0gdXNlU3RhYmxlQ2FsbGJhY2soZ2V0U2VsZklzQ2hlY2tlZFVuc3RhYmxlKTtcblxuICAgIC8vIElmIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSBwYXJlbnQgY2hlY2tib3gncyB2YWx1ZSwgdGhlbiB0aGlzIHJlZiBob2xkcyBhIG1lbW9yeSBvZiB3aGF0IHZhbHVlcyB3ZXJlIGhlbGQgYmVmb3JlLlxuICAgIC8vIE90aGVyd2lzZSwgaXQncyBudWxsIHdoZW4gdGhlIGxhc3QgaW5wdXQgd2FzIGZyb20gYSBjaGlsZCBjaGVja2JveC4gXG4gICAgY29uc3Qgc2F2ZWRDaGVja2VkVmFsdWVzID0gdXNlUmVmPE1hcDxudW1iZXIsIGJvb2xlYW4gfCBcIm1peGVkXCI+IHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3Qgb25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQgPSB1c2VDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxJbnB1dEVsZW1lbnQ+KSA9PiB7XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGNvbnN0IHNlbGZJc0NoZWNrZWQgPSBnZXRTZWxmSXNDaGVja2VkU3RhYmxlKCk7XG4gICAgICAgIGlmIChzZWxmSXNDaGVja2VkID09PSB0cnVlIHx8IChzZWxmSXNDaGVja2VkID09PSBmYWxzZSAmJiBzYXZlZENoZWNrZWRWYWx1ZXMuY3VycmVudCA9PSBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9uVXBkYXRlQ2hpbGRyZW4oZW5oYW5jZUV2ZW50KGUsIHsgY2hpbGRyZW5DaGVja2VkOiBmYWxzZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZklzQ2hlY2tlZCA9PT0gXCJtaXhlZFwiKSB7XG5cbiAgICAgICAgICAgIHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBzYXZlZENoZWNrZWRWYWx1ZXMuY3VycmVudC5zZXQoY2hpbGQuaW5kZXgsIGNoaWxkLmdldENoZWNrZWQoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvblVwZGF0ZUNoaWxkcmVuKGVuaGFuY2VFdmVudChlLCB7IGNoaWxkcmVuQ2hlY2tlZDogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb25VcGRhdGVDaGlsZHJlbihlbmhhbmNlRXZlbnQoZSwgeyBjaGlsZHJlbkNoZWNrZWQ6IHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50ID8/IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCBjaGlsZCBJRHMsIGFuZCBhbnkgdGltZSBhbnkgb2YgdGhlbSBjaGFuZ2UsIFxuICAgIC8vIGdlbmVyYXRlIGEgbmV3IHN0cmluZyB3aXRoIGFsbCBvZiB0aGVtIGNvbmNhdGVuYXRlZCB0b2dldGhlclxuICAgIC8vIChidXQgb25seSBvbmNlIHBlciByZW5kZXIpO1xuICAgIGNvbnN0IGFsbElkcyA9IHVzZVJlZihuZXcgU2V0PHN0cmluZz4oKSk7XG4gICAgY29uc3QgW2FyaWFDb250cm9scywgc2V0QXJpYUNvbnRyb2xzXSA9IHVzZVN0YXRlKFwiXCIpO1xuICAgIGNvbnN0IFt1cGRhdGVJbmRleCwgc2V0SWRVcGRhdGVJbmRleF0gPSB1c2VTdGF0ZSgwKTtcblxuICAgIGNvbnN0IG5vdGlmeUNoZWNrZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlciwgY2hlY2tlZDogYm9vbGVhbiB8IFwibWl4ZWRcIikgPT4ge1xuICAgICAgICBpZiAoY2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCFjaGVja2VkSW5kaWNlcy5jdXJyZW50LmhhcyhpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBzZXRDaGVja2VkQ291bnQoYyA9PiAoYyArIDEpKTtcbiAgICAgICAgICAgICAgICBjaGVja2VkSW5kaWNlcy5jdXJyZW50LmFkZChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlZEluZGljZXMuY3VycmVudC5oYXMoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2hlY2tlZENvdW50KGMgPT4gKGMgLSAxKSk7XG4gICAgICAgICAgICAgICAgY2hlY2tlZEluZGljZXMuY3VycmVudC5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3NldENoZWNrZWRDb3VudCwgY2hlY2tlZEluZGljZXNdKTtcblxuICAgIC8qdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IHBlcmNlbnRhZ2UgPSBjaGVja2VkQ291bnQgLyBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICBzZXRTZWxmSXNDaGVja2VkKHBlcmNlbnRhZ2UgPD0gMCA/IGZhbHNlIDogcGVyY2VudGFnZSA+PSAxID8gdHJ1ZSA6IFwibWl4ZWRcIilcbiAgICB9LCBbc2V0U2VsZklzQ2hlY2tlZCwgbWFuYWdlZENoaWxkcmVuLmxlbmd0aCwgY2hlY2tlZENvdW50XSk7Ki9cblxuICAgIGNvbnN0IHVzZUNoZWNrYm94R3JvdXBQYXJlbnRQcm9wczogVXNlQ2hlY2tib3hHcm91cFBhcmVudFByb3BzPElucHV0RWxlbWVudD4gPSB1c2VDYWxsYmFjayg8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4+KHByb3BzOiBQKSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxJbnB1dEVsZW1lbnQ+KCkoeyBcImFyaWEtY29udHJvbHNcIjogYXJpYUNvbnRyb2xzIH0sIHByb3BzKTtcbiAgICB9LCBbYXJpYUNvbnRyb2xzXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRBcmlhQ29udHJvbHMoQXJyYXkuZnJvbShhbGxJZHMuY3VycmVudCkuam9pbihcIiBcIikpO1xuICAgIH0sIFt1cGRhdGVJbmRleF0pXG5cbiAgICBjb25zdCB1c2VDaGVja2JveEdyb3VwQ2hpbGQ6IFVzZUNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dEVsZW1lbnQsIEk+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHsgaW5kZXgsIHRleHQsIGNoZWNrZWQsIGlkLCAuLi5yZXN0IH06IFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8ST4pIHtcblxuICAgICAgICBjb25zdCBnZXRDaGVja2VkID0gdXNlU3RhYmxlR2V0dGVyKGNoZWNrZWQpO1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBhbGxJZHMuY3VycmVudC5hZGQoaWQpO1xuICAgICAgICAgICAgc2V0SWRVcGRhdGVJbmRleChpID0+ICsraSk7XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYWxsSWRzLmN1cnJlbnQuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICBzZXRJZFVwZGF0ZUluZGV4KGkgPT4gKytpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW2lkXSk7XG5cblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgbm90aWZ5Q2hlY2tlZChpbmRleCwgY2hlY2tlZCk7XG4gICAgICAgIH0sIFtpbmRleCwgY2hlY2tlZF0pO1xuXG4gICAgICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7IGluZGV4LCB0ZXh0LCBpZCwgZ2V0Q2hlY2tlZCwgLi4ucmVzdCB9IGFzIHVua25vd24gYXMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8ST4pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YWJiYWJsZSxcbiAgICAgICAgICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZFByb3BzOiB1c2VDYWxsYmFjayg8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4+KHByb3BzOiBQKSA9PiB1c2VNZXJnZWRQcm9wczxJbnB1dEVsZW1lbnQ+KCkoe30sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvblByb3BzKHByb3BzKSkpLCBbdXNlTGlzdE5hdmlnYXRpb25Qcm9wcywgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzXSlcbiAgICAgICAgfVxuXG5cbiAgICB9LCBbdXNlTGlzdE5hdmlnYXRpb25Qcm9wcywgbm90aWZ5Q2hlY2tlZCwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFuYWdlZENoZWNrYm94ZXM6IG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgdXNlQ2hlY2tib3hHcm91cENoaWxkLFxuICAgICAgICB1c2VDaGVja2JveEdyb3VwUGFyZW50UHJvcHMsXG4gICAgICAgIHBhcmVudElzQ2hlY2tlZDogZ2V0U2VsZklzQ2hlY2tlZFVuc3RhYmxlKCkgYXMgYm9vbGVhbiB8IFwibWl4ZWRcIixcbiAgICAgICAgcGFyZW50UGVyY2VudENoZWNrZWQ6IChjaGVja2VkQ291bnQgLyBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoKSxcbiAgICAgICAgb25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQsXG4gICAgICAgIHRhYmJhYmxlSW5kZXgsXG4gICAgICAgIGZvY3VzOiBmb2N1c0N1cnJlbnQsXG4gICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblxuICAgIH07XG59IiwiXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCwgdXNlRm9jdXNUcmFwLCB1c2VNZXJnZWRQcm9wcywgdXNlUGFzc2l2ZVN0YXRlLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb2Z0RGlzbWlzc1BhcmFtZXRlcnMge1xuXG4gICAgLyoqXG4gICAgICogTXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBjb3VudCBhcyBcIndpdGhpblwiIHRoaXMgY29tcG9uZW50LlxuICAgICAqIFxuICAgICAqIFVzdWFsbHkganVzdCBhIHNpbmdsZSBlbGVtZW50LCBidXQgZS5nLiBhIE1lbnUgKyBNZW51QnV0dG9uIGNvdWxkIGhhdmUgdHdvLlxuICAgICAqL1xuICAgIGdldEVsZW1lbnRzOiAoKSA9PiBFbGVtZW50IHwgRWxlbWVudFtdIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGlzbWlzc2VkXG4gICAgICovXG4gICAgb25DbG9zZShyZWFzb246IFwiYmFja2Ryb3BcIiB8IFwiZXNjYXBlXCIgfCBcImxvc3QtZm9jdXNcIik6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTW9kYWxQYXJhbWV0ZXJzIGV4dGVuZHMgT21pdDxVc2VTb2Z0RGlzbWlzc1BhcmFtZXRlcnMsIFwiZ2V0RWxlbWVudHNcIj4ge1xuICAgIG9wZW46IGJvb2xlYW47XG59XG5cbi8qKlxuICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgYSBtb2RhbC1saWtlIHNvZnQtZGlzbWlzcyBpbnRlcmFjdGlvbi5cbiAqIFxuICogVGhhdCBpcywgYW55IGNsaWNrcyBvciB0YXBzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGNvbXBvbmVudCwgXG4gKiBvciBhbnkgdGltZSB0aGUgRXNjYXBlIGtleSBpcyBwcmVzc2VkIHdpdGhpbiB0aGUgY29tcG9uZW50LFxuICogKHdpdGggdmFyaW91cyBicm93c2VyIG9kZGl0aWVzIHJlZ2FyZGluZyBjbGlja3Mgb24gYmxhbmsgb3IgaW5lcnQgYXJlYXMgaGFuZGxlZClcbiAqIHRoZSBjb21wb25lbnQgd2lsbCByZXF1ZXN0IHRvIGNsb3NlIGl0c2VsZi5cbiAqIFxuICogT2YgY291cnNlLCBpZiB5b3UgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhlIGBvbkNsb3NlYCBmdW5jdGlvbixcbiAqIGl0IHdvbid0IGJlIGEgc29mdCBkaXNtaXNzIGFueW1vcmUuXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNvZnREaXNtaXNzPFQgZXh0ZW5kcyBOb2RlPih7IG9uQ2xvc2UsIGdldEVsZW1lbnRzIH06IFVzZVNvZnREaXNtaXNzUGFyYW1ldGVycykge1xuXG4gICAgY29uc3Qgc3RhYmxlT25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UpO1xuICAgIGNvbnN0IHN0YWJsZUdldEVsZW1lbnRzID0gdXNlU3RhYmxlQ2FsbGJhY2soZ2V0RWxlbWVudHMpO1xuICAgIGNvbnN0IGdldE9wZW4gPSB1c2VTdGFibGVHZXR0ZXIob3Blbik7XG5cbiAgICBjb25zdCBvbkJhY2tkcm9wQ2xpY2sgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBvbkJhY2tkcm9wQ2xpY2soZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxhbnk+KSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RWxlbWVudCgpPy5vd25lckRvY3VtZW50O1xuXG4gICAgICAgIC8vIEJhc2ljYWxseSwgXCJ3YXMgdGhpcyBldmVudCBmaXJlZCBvbiB0aGUgcm9vdC1tb3N0IGVsZW1lbnQsIG9yIGF0IGxlYXN0IGFuIGVsZW1lbnQgbm90IGNvbnRhaW5lZCBieSB0aGUgbW9kYWw/XCJcbiAgICAgICAgLy8gRWl0aGVyIGNvdWxkIGJlIGhvdyB0aGUgYnJvd3NlciBoYW5kbGVzIHRoZXNlIHNvcnRzIG9mIFwiaW50ZXJhY3Rpbmcgd2l0aCBub3RoaW5nXCIgZXZlbnRzLlxuICAgICAgICBpZiAoZS50YXJnZXQgPT0gZG9jdW1lbnQ/LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICAgc3RhYmxlT25DbG9zZShcImJhY2tkcm9wXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGVsZW1lbnRzID0gc3RhYmxlR2V0RWxlbWVudHMoKTtcblxuICAgICAgICBpZiAoZWxlbWVudHMgJiYgZS50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZWxlbWVudHMpKVxuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcblxuICAgICAgICAgICAgbGV0IGZvdW5kSW5zaWRlQ2xpY2sgPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kSW5zaWRlQ2xpY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZm91bmRJbnNpZGVDbGljaylcbiAgICAgICAgICAgICAgICBvbkNsb3NlKFwiYmFja2Ryb3BcIik7XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IHsgdXNlQWN0aXZlRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VBY3RpdmVFbGVtZW50PFQ+KHtcbiAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKG5ld0VsZW1lbnQ6IFQgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBsZXQgdmFsaWRGb2N1c2FibGVFbGVtZW50cyA9IHN0YWJsZUdldEVsZW1lbnRzKCk7XG5cbiAgICAgICAgICAgIGlmICh2YWxpZEZvY3VzYWJsZUVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbGlkRm9jdXNhYmxlRWxlbWVudHMpKVxuICAgICAgICAgICAgICAgICAgICB2YWxpZEZvY3VzYWJsZUVsZW1lbnRzID0gW3ZhbGlkRm9jdXNhYmxlRWxlbWVudHNdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmb2N1c2FibGUgb2YgdmFsaWRGb2N1c2FibGVFbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNhYmxlPy5jb250YWlucyhuZXdFbGVtZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9uQ2xvc2UoXCJsb3N0LWZvY3VzXCIpO1xuICAgICAgICB9LCBbXSlcbiAgICB9KTtcblxuXG4gICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8VD4oe1xuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlOiBUIHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBlPy5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgY29uc3Qgd2luZG93ID0gZG9jdW1lbnQ/LmRlZmF1bHRWaWV3O1xuXG4gICAgICAgICAgICAvLyBTaW5jZSBldmVyeXRoaW5nIGVsc2UgaXMgaW5lcnQsIHdlIGxpc3RlbiBmb3IgY2FwdHVyZWQgY2xpY2tzIG9uIHRoZSB3aW5kb3dcbiAgICAgICAgICAgIC8vICh3ZSBkb24ndCB1c2Ugb25DbGljayBzaW5jZSB0aGF0IGRvZXNuJ3QgZmlyZSB3aGVuIGNsaWNrZWQgb24gZW1wdHkvaW5lcnQgYXJlYXMpXG4gICAgICAgICAgICAvLyBOb3RlOiBXZSBuZWVkIGEgKnNlcGFyYXRlKiB0b3VjaCBldmVudCBvbiBtb2JpbGUgU2FmYXJpLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyBpdCBkb2Vzbid0IGxldCBjbGljayBldmVudHMgYnViYmxlIG9yIGJlIGNhcHR1cmVkIGZyb20gdHJhZGl0aW9uYWxseSBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsXG4gICAgICAgICAgICAvLyBidXQgdG91Y2ggZXZlbnRzIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgICAgICAgICBjb25zdCBtb3VzZURvd24gPSAoZTogTW91c2VFdmVudCkgPT4geyBpZiAoZ2V0T3BlbigpKSBvbkJhY2tkcm9wQ2xpY2soZSk7IH07XG4gICAgICAgICAgICBjb25zdCB0b3VjaFN0YXJ0ID0gKGU6IFRvdWNoRXZlbnQpID0+IHsgaWYgKGdldE9wZW4oKSkgb25CYWNrZHJvcENsaWNrKGUpOyB9O1xuICAgICAgICAgICAgY29uc3Qga2V5RG93biA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7IGlmIChlLmtleSA9PT0gXCJFc2NhcGVcIikgeyBzdGFibGVPbkNsb3NlKFwiZXNjYXBlXCIpOyB9IH07XG5cbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBtb3VzZURvd24sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdG91Y2hTdGFydCwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlEb3duKTtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VEb3duKTtcbiAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoU3RhcnQpO1xuICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5RG93bik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgdXNlU29mdERpc21pc3NQcm9wczogdXNlQ2FsbGJhY2soPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxUPj4ocHJvcHM6IFApID0+IHVzZUFjdGl2ZUVsZW1lbnRQcm9wcyh1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpKSwgW3VzZUFjdGl2ZUVsZW1lbnRQcm9wcywgdXNlUmVmRWxlbWVudFByb3BzXSkgfVxufVxuXG4vKipcbiAqIEEgZ2VuZXJpYyBtb2RhbCBob29rLCB1c2VkIGJ5IG1vZGFsIGRpYWxvZ3MsIGJ1dCBjYW4gYWxzb1xuICogYmUgdXNlZCBieSBhbnl0aGluZyB0aGF0J3MgbW9kYWwgd2l0aCBhIGJhY2tkcm9wLlxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTW9kYWw8TW9kYWxFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgb3Blbiwgb25DbG9zZSB9OiBVc2VNb2RhbFBhcmFtZXRlcnMpIHtcblxuICAgIGNvbnN0IHN0YWJsZU9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjayhvbkNsb3NlKTtcblxuICAgIGNvbnN0IFttb2RhbERlc2NyaWJlZEJ5Qm9keSwgc2V0TW9kYWxEZXNjcmliZWRCeUJvZHldID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHVzZUhpZGVTY3JvbGwob3Blbik7XG5cbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUHJvcHM6IHVzZU1vZGFsSWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1tb2RhbC1cIiB9KTtcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUHJvcHM6IHVzZUJvZHlJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlQm9keVJlZmVyZW5jaW5nSWRQcm9wcyB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS1tb2RhbC1ib2R5LVwiIH0pO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlVGl0bGVJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlVGl0bGVSZWZlcmVuY2luZ0lkUHJvcHMgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtbW9kYWwtdGl0bGUtXCIgfSk7XG5cbiAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wczogdXNlTW9kYWxSZWZFbGVtZW50LCBnZXRFbGVtZW50OiBnZXRNb2RhbEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8TW9kYWxFbGVtZW50Pih7fSlcbiAgICBjb25zdCB7IHVzZVNvZnREaXNtaXNzUHJvcHMgfSA9IHVzZVNvZnREaXNtaXNzPE1vZGFsRWxlbWVudD4oeyBvbkNsb3NlOiBzdGFibGVPbkNsb3NlLCBnZXRFbGVtZW50czogZ2V0TW9kYWxFbGVtZW50IH0pO1xuXG4gICAgY29uc3QgdXNlTW9kYWxCYWNrZHJvcCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZU1vZGFsQmFja2Ryb3A8QmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZU1vZGFsQmFja2Ryb3BQcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8QmFja2Ryb3BFbGVtZW50Pj4ocHJvcHM6IFApIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxCYWNrZHJvcEVsZW1lbnQ+KCkoeyBvblBvaW50ZXJVcDogKCkgPT4gc3RhYmxlT25DbG9zZShcImJhY2tkcm9wXCIpIH0sIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCB1c2VNb2RhbFByb3BzID0gZnVuY3Rpb24gPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxNb2RhbEVsZW1lbnQ+Pih7IFwiYXJpYS1tb2RhbFwiOiBhcmlhTW9kYWwsIHJvbGUsIC4uLnAwIH06IFApIHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoIWFyaWFNb2RhbCk7XG4gICAgICAgIGNvbnN0IHsgdXNlRm9jdXNUcmFwUHJvcHMgfSA9IHVzZUZvY3VzVHJhcDxNb2RhbEVsZW1lbnQ+KHsgdHJhcEFjdGl2ZTogb3BlbiB9KTtcbiAgICAgICAgY29uc3QgcDEgPSB1c2VUaXRsZVJlZmVyZW5jaW5nSWRQcm9wcyhcImFyaWEtbGFiZWxsZWRieVwiKShwMCk7XG4gICAgICAgIGNvbnN0IHAyID0gdXNlTW9kYWxJZFByb3BzKHAxKTtcbiAgICAgICAgY29uc3QgcEZpbmFsID0gdXNlQm9keVJlZmVyZW5jaW5nSWRQcm9wcyhcImFyaWEtZGVzY3JpYmVkYnlcIikocDIpO1xuICAgICAgICByZXR1cm4gdXNlRm9jdXNUcmFwUHJvcHModXNlU29mdERpc21pc3NQcm9wcyh1c2VNZXJnZWRQcm9wczxNb2RhbEVsZW1lbnQ+KCkodXNlTW9kYWxSZWZFbGVtZW50KHsgcm9sZTogcm9sZSB8fCBcImRpYWxvZ1wiIH0pLCBtb2RhbERlc2NyaWJlZEJ5Qm9keSA/IHBGaW5hbCA6IHAyKSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZU1vZGFsVGl0bGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VNb2RhbFRpdGxlPFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KCkge1xuXG4gICAgICAgIGNvbnN0IHVzZU1vZGFsVGl0bGVQcm9wcyA9IGZ1bmN0aW9uIDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50Pj4ocHJvcHM6IFApIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VUaXRsZUlkUHJvcHMocHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlTW9kYWxUaXRsZVByb3BzIH07XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCB1c2VNb2RhbEJvZHkgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VNb2RhbEJvZHk8Qm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGRlc2NyaXB0aXZlIH06IHsgZGVzY3JpcHRpdmU6IGJvb2xlYW4gfSkge1xuICAgICAgICBzZXRNb2RhbERlc2NyaWJlZEJ5Qm9keShkZXNjcmlwdGl2ZSk7XG5cbiAgICAgICAgY29uc3QgdXNlTW9kYWxCb2R5UHJvcHMgPSBmdW5jdGlvbiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50Pj4ocHJvcHM6IFApIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VCb2R5SWRQcm9wcyhwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB1c2VNb2RhbEJvZHlQcm9wcyB9O1xuICAgIH0sIFtdKVxuXG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZU1vZGFsUHJvcHMsXG4gICAgICAgIHVzZU1vZGFsVGl0bGUsXG4gICAgICAgIHVzZU1vZGFsQm9keSxcbiAgICAgICAgdXNlTW9kYWxCYWNrZHJvcFxuICAgIH1cbn1cblxuXG4vKipcbiAqIEFsbG93cyBmb3IgaGlkaW5nIHRoZSBzY3JvbGwgYmFyIG9mIHRoZSByb290IEhUTUwgZWxlbWVudFxuICogd2l0aG91dCBzaGlmdGluZyB0aGUgbGF5b3V0IG9mIHRoZSBwYWdlIG1vcmUgdGhhbiBhZGRpbmcgYSBmb3cgcGl4ZWxzXG4gKiBvZiBwYWRkaW5nIHRvIHRoZSByb290IGVsZW1lbnQgaWYgbmVjZXNzYXJ5LlxuICogQHBhcmFtIGhpZGVTY3JvbGwgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VIaWRlU2Nyb2xsKGhpZGVTY3JvbGw6IGJvb2xlYW4pIHtcbiAgICBjb25zdCBbZ2V0U2Nyb2xsYmFyV2lkdGgsIHNldFNjcm9sbGJhcldpZHRoXSA9IHVzZVBhc3NpdmVTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbZ2V0U2Nyb2xsYmFySGVpZ2h0LCBzZXRTY3JvbGxiYXJIZWlnaHRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGhpZGVTY3JvbGwpIHtcblxuICAgICAgICAgICAgLy8gV2hlbiBzY3JvbGxpbmcgaXMgcmVzdW1lZCwgd2UnbGwgbmVlZCB0byByZXN0b3JlIHRoZSBvcmlnaW5hbCBzY3JvbGwgcG9zaXRpb25zXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGtlZXAgdGhpcyBpbmZvcm1hdGlvbiBhcm91bmRcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2Nyb2xsVG9wID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2Nyb2xsTGVmdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuXG4gICAgICAgICAgICAvLyBNZWFzdXJlIHRoZSB3aWR0aCBvZiB0aGUgcGFnZSAobWludXMgdGhlIHNjcm9sbGJhcilcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoV2l0aFNjcm9sbEJhciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodFdpdGhTY3JvbGxCYXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBBcHBseSBhIGNsYXNzIHRoYXQgaGlkZXMgdGhlIHNjcm9sbGJhci5cbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZG9jdW1lbnQtc2Nyb2xsLWhpZGRlblwiKTtcblxuICAgICAgICAgICAgLy8gSW4gY2FzZSBtdWx0aXBsZSB0aGluZ3MgYXJlIGxvY2tpbmcgc2Nyb2xsLCBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGFyZSBkb2luZyB0aGF0XG4gICAgICAgICAgICAvLyAoanVzdCBhZGQgMSBvbiBlbmFibGUsIHN1YnRyYWN0IDEgb24gZGlzYWJsZSlcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdID0gKCsoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gfHwgXCIwXCIpICsgMSkudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgLy8gTWVhc3VyZSB0aGUgbmV3IHdpZHRoIHdpdGhvdXQgYSBzY3JvbGxiYXIgXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gdGFrZSB0aGUgZGlmZmVyZW5jZSBhcyB0aGUgc2Nyb2xsYmFyIHdpZHRoLlxuICAgICAgICAgICAgY29uc3Qgd2lkdGhXaXRob3V0U2Nyb2xsQmFyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0V2l0aG91dFNjcm9sbEJhciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsYmFyV2lkdGggPSAod2lkdGhXaXRob3V0U2Nyb2xsQmFyIC0gd2lkdGhXaXRoU2Nyb2xsQmFyKTtcbiAgICAgICAgICAgIGxldCBzY3JvbGxiYXJIZWlnaHQgPSAoaGVpZ2h0V2l0aG91dFNjcm9sbEJhciAtIGhlaWdodFdpdGhTY3JvbGxCYXIpO1xuXG4gICAgICAgICAgICAvLyBGYWlsc2FmZSAtLSBpZiB0aGlzIG1lYXN1cmluZyB0cmljayBkb2VzIHNvbWV0aGluZyB1bmV4cGVjdGVkLCBqdXN0IGlnbm9yZSBpdFxuICAgICAgICAgICAgaWYgKHNjcm9sbGJhcldpZHRoID4gODApXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFyV2lkdGggPSAwO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGJhckhlaWdodCA+IDgwKVxuICAgICAgICAgICAgICAgIHNjcm9sbGJhckhlaWdodCA9IDA7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugb3VyIG1lYXN1cmVtZW50cyBhdmFpbGFibGUgYXMgQ1NTIHByb3BlcnRpZXMgZm9yIGdlbmVyYWwgdXNlXG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXJvb3Qtc2Nyb2xsYmFyLXdpZHRoXCIsIGAke3Njcm9sbGJhcldpZHRofXB4YCk7XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXJvb3Qtc2Nyb2xsYmFyLWhlaWdodFwiLCBgJHtzY3JvbGxiYXJIZWlnaHR9cHhgKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcm9vdC1zY3JvbGxzdG9wLXRvcFwiLCBgJHtvcmlnaW5hbFNjcm9sbFRvcH1weGApO1xuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1yb290LXNjcm9sbHN0b3AtbGVmdFwiLCBgJHtvcmlnaW5hbFNjcm9sbExlZnR9cHhgKTtcblxuICAgICAgICAgICAgc2V0U2Nyb2xsYmFyV2lkdGgoc2Nyb2xsYmFyV2lkdGgpO1xuICAgICAgICAgICAgc2V0U2Nyb2xsYmFySGVpZ2h0KHNjcm9sbGJhckhlaWdodCk7XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVW5kbyBhbGwgdGhlIHRoaW5ncyB3ZSBqdXN0IGRpZFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdID0gKCsoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gfHwgXCIwXCIpIC0gMSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gPT0gXCIwXCIpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIHRoZSBsYXN0IHNjcm9sbC1sb2NraW5nIHRoaW5nIHRvIHN0b3AsIHRoZW4gcmVtb3ZlIHRoZSBjbGFzcyB0aGF0IHN0b3BzIHNjcm9sbGluZy5cbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2Nyb2xsLWhpZGVyc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJkb2N1bWVudC1zY3JvbGwtaGlkZGVuXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsc28sIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkbyB0aGlzIGJ5IGZvcmNpbmcgdGhlIHNjcm9sbCBiZWhhdmlvciB0byBub3QgYmUgc21vb3RoXG4gICAgICAgICAgICAgICAgICAgIC8vIChpdCdzIGluc3RhbnQgaWYgbm90aGluZyBpcyBzZXQgdG8gc21vb3RoLCBodHRwczovL3d3dy53My5vcmcvVFIvY3Nzb20tdmlldy8jc2Nyb2xsaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsaW5nLCB0aGVuIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgc2Nyb2xsIGJlaGF2aW9yIFxuICAgICAgICAgICAgICAgICAgICAvLyAod2hpY2ggd2FzIHByb2JhYmx5IGFscmVhZHkgYXV0byBhbnl3YXksIGJ1dCBqdXN0IHRvIGJlIHNhZmUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2Nyb2xsQmVoYXZpb3IgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3I7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IFwiYXV0b1wiO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG8oeyB0b3A6IG9yaWdpbmFsU2Nyb2xsVG9wLCBsZWZ0OiBvcmlnaW5hbFNjcm9sbExlZnQsIGJlaGF2aW9yOiBcImF1dG9cIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gb3JpZ2luYWxTY3JvbGxCZWhhdmlvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0sIFtoaWRlU2Nyb2xsXSk7XG5cbiAgICByZXR1cm4geyBnZXRTY3JvbGxiYXJXaWR0aCwgZ2V0U2Nyb2xsYmFySGVpZ2h0IH07XG59XG5cbiIsIlxyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTW9kYWwgfSBmcm9tIFwiLi91c2UtbW9kYWxcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhRGlhbG9nPERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBvcGVuLCBvbkNsb3NlIH06IHsgb3BlbjogYm9vbGVhbiwgb25DbG9zZTogKHJlYXNvbjogXCJlc2NhcGVcIiB8IFwiYmFja2Ryb3BcIikgPT4gdm9pZCB9KSB7XHJcbiAgICAvLyBUT0RPOiBEaWZmZXJlbmNlcyBiZXR3ZWVuIGRpYWxvZyBhbmQgbW9kYWwgZ28gaGVyZSwgcHJlc3VtYWJseS5cclxuICAgIC8vIE5vbi1tb2RhbCBkaWFsb2dzIG5lZWQgdG8gYmUgYWJsZSB0byBiZSByZXBvc2l0aW9uZWQsIGV0Yy5cclxuICAgIGNvbnN0IHsgdXNlTW9kYWxCYWNrZHJvcCwgdXNlTW9kYWxCb2R5LCB1c2VNb2RhbFByb3BzLCB1c2VNb2RhbFRpdGxlIH0gPSB1c2VNb2RhbDxEaWFsb2dFbGVtZW50Pih7IG9wZW4sIG9uQ2xvc2UgfSk7XHJcblxyXG4gICAgY29uc3QgdXNlRGlhbG9nQmFja2Ryb3AgPSB1c2VDYWxsYmFjayg8RSBleHRlbmRzIEhUTUxFbGVtZW50PigpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9ID0gdXNlTW9kYWxCYWNrZHJvcDxFPigpO1xyXG4gICAgICAgIHJldHVybiB7IHVzZURpYWxvZ0JhY2tkcm9wUHJvcHM6IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9O1xyXG4gICAgfSwgW3VzZU1vZGFsQmFja2Ryb3BdKTtcclxuXHJcbiAgICBjb25zdCB1c2VEaWFsb2dCb2R5ID0gdXNlQ2FsbGJhY2soPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGRlc2NyaXB0aXZlIH06IHsgZGVzY3JpcHRpdmU6IGJvb2xlYW4gfSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxCb2R5UHJvcHMgfSA9IHVzZU1vZGFsQm9keTxFPih7IGRlc2NyaXB0aXZlIH0pO1xyXG4gICAgICAgIHJldHVybiB7IHVzZURpYWxvZ0JvZHlQcm9wczogdXNlTW9kYWxCb2R5UHJvcHMgfTtcclxuICAgIH0sIFt1c2VNb2RhbEJhY2tkcm9wXSk7XHJcbiAgICBjb25zdCB1c2VEaWFsb2dQcm9wcyA9IHVzZU1vZGFsUHJvcHM7XHJcblxyXG4gICAgY29uc3QgdXNlRGlhbG9nVGl0bGUgPSB1c2VDYWxsYmFjayg8RSBleHRlbmRzIEVsZW1lbnQ+KCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxUaXRsZVByb3BzIH0gPSB1c2VNb2RhbFRpdGxlPEU+KCk7XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlRGlhbG9nVGl0bGVQcm9wczogdXNlTW9kYWxUaXRsZVByb3BzIH07XHJcbiAgICB9LCBbdXNlTW9kYWxUaXRsZV0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlRGlhbG9nUHJvcHMsXHJcbiAgICAgICAgdXNlRGlhbG9nVGl0bGUsXHJcbiAgICAgICAgdXNlRGlhbG9nQm9keSxcclxuICAgICAgICB1c2VEaWFsb2dCYWNrZHJvcFxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBNZXJnZWRQcm9wcywgdXNlSGFzRm9jdXMsIHVzZUxheW91dEVmZmVjdCwgdXNlTGlzdE5hdmlnYXRpb24sIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHNSZXR1cm5UeXBlLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UHJvcHNSZXR1cm5UeXBlLCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlR2V0dGVyLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRXZlbnREZXRhaWwsIFRhZ1NlbnNpdGl2ZVByb3BzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZVByZXNzRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcbmltcG9ydCB7IHVzZUdlbmVyaWNMYWJlbCB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xuXG5leHBvcnQgdHlwZSBMaXN0Ym94TXVsdGlTZWxlY3RFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0geyBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiBib29sZWFuIH0gfSAmIFBpY2s8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPiwgXCJ0YXJnZXRcIiB8IFwiY3VycmVudFRhcmdldFwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzIGV4dGVuZHMgT21pdDxVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFwic2hvdWxkRm9jdXNPbkNoYW5nZVwiPiB7IH1cblxuXG5cbnR5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+O1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpSXRlbUluZm88RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZEluZm8sIFRhZ1NlbnNpdGl2ZVByb3BzPEU+IHtcbiAgICBzZWxlY3RlZDogYm9vbGVhbjtcbiAgICBvblNlbGVjdD8oZXZlbnQ6IChMaXN0Ym94TXVsdGlTZWxlY3RFdmVudDxFbGVtZW50PikpOiB2b2lkO1xuICAgIHNldFR5cGVhaGVhZEluUHJvZ3Jlc3MoaW5Qcm9ncmVzczogYm9vbGVhbik6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIFVzZUxpc3Rib3hNdWx0aUl0ZW1QYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgVXNlTGlzdGJveE11bHRpSXRlbUluZm88RT4+ID0gT21pdDxJLCBcInNldFR5cGVhaGVhZEluUHJvZ3Jlc3NcIiB8IFwiZ2V0VGFiYmFibGVcIiB8IFwic2V0VGFiYmFibGVcIiB8IFwicmVyZW5kZXJBbmRGb2N1c1wiPiAmIHtcbiAgICBkaXNhYmxlZD86IGJvb2xlYW47XG59O1xuXG5leHBvcnQgdHlwZSBVc2VMaXN0Ym94TXVsdGlJdGVtPEUgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgVXNlTGlzdGJveE11bHRpSXRlbUluZm88RT4+ID0gKGluZm86IFVzZUxpc3Rib3hNdWx0aUl0ZW1QYXJhbWV0ZXJzPEUsIEk+KSA9PiB7XG4gICAgdXNlTGlzdGJveE11bHRpSXRlbVByb3BzOiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+Pihwcm9wczogUCkgPT4gVXNlUmVmRWxlbWVudFByb3BzUmV0dXJuVHlwZTxFLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHNSZXR1cm5UeXBlPEUsIE1lcmdlZFByb3BzPEUsIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+LCBQPj4+O1xuICAgIHRhYmJhYmxlOiBib29sZWFuIHwgbnVsbDtcbn1cblxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFMaXN0Ym94TXVsdGk8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEkgZXh0ZW5kcyBVc2VMaXN0Ym94TXVsdGlJdGVtSW5mbzxDaGlsZEVsZW1lbnQ+Pih7IC4uLmFyZ3MgfTogVXNlTGlzdGJveE11bHRpUGFyYW1ldGVycykge1xuICAgIHR5cGUgRSA9IFBhcmVudEVsZW1lbnQ7XG5cbiAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGdldEZvY3VzZWRJbm5lciB9ID0gdXNlSGFzRm9jdXM8RT4oe30pO1xuXG4gICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxJbnB1dCwgdXNlR2VuZXJpY0xhYmVsTGFiZWwgfSA9IHVzZUdlbmVyaWNMYWJlbCh7IGxhYmVsUHJlZml4OiBcImFyaWEtbGlzdGJveC1sYWJlbC1cIiwgaW5wdXRQcmVmaXg6IFwiYXJpYS1saXN0Ym94LVwiIH0pXG4gICAgY29uc3QgeyB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCB1c2VMaXN0TmF2aWdhdGlvblByb3BzLCBuYXZpZ2F0ZVRvSW5kZXgsIG1hbmFnZWRDaGlsZHJlbiwgY3VycmVudFR5cGVhaGVhZCwgZm9jdXNDdXJyZW50LCB0YWJiYWJsZUluZGV4LCBpbnZhbGlkVHlwZWFoZWFkIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxDaGlsZEVsZW1lbnQsIFVzZUxpc3Rib3hNdWx0aUl0ZW1JbmZvPENoaWxkRWxlbWVudD4+KHsgLi4uYXJncywgc2hvdWxkRm9jdXNPbkNoYW5nZTogZ2V0Rm9jdXNlZElubmVyIH0pO1xuICAgIGNvbnN0IHsgdXNlR2VuZXJpY0xhYmVsSW5wdXRQcm9wcyB9ID0gdXNlR2VuZXJpY0xhYmVsSW5wdXQ8RT4oKTtcblxuICAgIGNvbnN0IGNoaWxkQ291bnQgPSBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgY29uc3QgWywgc2V0U2hpZnRIZWxkLCBnZXRTaGlmdEhlbGRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3QgdHlwZWFoZWFkSW5Qcm9ncmVzcyA9ICghIWN1cnJlbnRUeXBlYWhlYWQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbltpXS5zZXRUeXBlYWhlYWRJblByb2dyZXNzKHR5cGVhaGVhZEluUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgfSwgW3R5cGVhaGVhZEluUHJvZ3Jlc3MsIGNoaWxkQ291bnRdKTtcblxuICAgIGNvbnN0IHVzZUxpc3Rib3hNdWx0aUl0ZW06IFVzZUxpc3Rib3hNdWx0aUl0ZW08Q2hpbGRFbGVtZW50LCBJPiA9IHVzZUNhbGxiYWNrKChpbmZvOiBVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEk+KSA9PiB7XG4gICAgICAgIHR5cGUgRSA9IENoaWxkRWxlbWVudDtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBpbmZvLnNlbGVjdGVkO1xuICAgICAgICBjb25zdCBbdHlwZWFoZWFkSW5Qcm9ncmVzcywgc2V0VHlwZWFoZWFkSW5Qcm9ncmVzc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgICAgIGNvbnN0IGdldFNlbGVjdGVkID0gdXNlU3RhYmxlR2V0dGVyKHNlbGVjdGVkKTtcbiAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8RT4oe30pO1xuICAgICAgICBjb25zdCBzdGFibGVPblNlbGVjdCA9IHVzZVN0YWJsZUNhbGxiYWNrKGluZm8ub25TZWxlY3QgPz8gKCgpID0+IHsgfSkpO1xuXG4gICAgICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7IC4uLmluZm8sIHNldFR5cGVhaGVhZEluUHJvZ3Jlc3MgfSk7XG5cbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBnZXRTaGlmdEhlbGQoKSkge1xuICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyB0YXJnZXQ6IGVsZW1lbnQsIGN1cnJlbnRUYXJnZXQ6IGVsZW1lbnQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWQ6IHRydWUgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3RhYmJhYmxlXSk7XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlTGlzdGJveE11bHRpSXRlbVByb3BzLCB0YWJiYWJsZSB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHByb3BzOiBQKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB1c2VQcmVzc0V2ZW50SGFuZGxlcnM8RT4oaW5mby5kaXNhYmxlZD8gbnVsbCA6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGluZm8uaW5kZXgpO1xuICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyAuLi5lLCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiAhZ2V0U2VsZWN0ZWQoKSB9IH0pO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0sIHsgc3BhY2U6IHR5cGVhaGVhZEluUHJvZ3Jlc3MgPyBcImV4Y2x1ZGVcIiA6IHVuZGVmaW5lZCB9KSh7fSk7XG5cbiAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcIm9wdGlvblwiO1xuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXNldHNpemVcIl0gPSAoY2hpbGRDb3VudCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1wb3NpbnNldFwiXSA9IChpbmZvLmluZGV4ICsgMSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1zZWxlY3RlZFwiXSA9ICh0YWJiYWJsZSA/PyBmYWxzZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChpbmZvLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IFwidHJ1ZVwiO1xuXG4gICAgICAgICAgICByZXR1cm4gdXNlUmVmRWxlbWVudFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VNZXJnZWRQcm9wczxFPigpKG5ld1Byb3BzLCBwcm9wcykpKTtcbiAgICAgICAgfVxuXG4gICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsIGNoaWxkQ291bnQsIHR5cGVhaGVhZEluUHJvZ3Jlc3NdKTtcblxuICAgIGNvbnN0IHVzZUxpc3Rib3hNdWx0aUxhYmVsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTGlzdGJveE11bHRpTGFiZWw8RSBleHRlbmRzIEhUTUxFbGVtZW50PigpIHtcbiAgICAgICAgZnVuY3Rpb24gdXNlTGlzdGJveE11bHRpTGFiZWxQcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHByb3BzOiBQKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVzZUdlbmVyaWNMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUdlbmVyaWNMYWJlbExhYmVsPEU+KCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlR2VuZXJpY0xhYmVsTGFiZWxQcm9wcyhwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB1c2VMaXN0Ym94TXVsdGlMYWJlbFByb3BzIH07XG4gICAgfSwgW3VzZUdlbmVyaWNMYWJlbExhYmVsXSk7XG5cbiAgICByZXR1cm4geyB1c2VMaXN0Ym94TXVsdGlJdGVtLCB1c2VMaXN0Ym94TXVsdGlQcm9wcywgdXNlTGlzdGJveE11bHRpTGFiZWwsIHRhYmJhYmxlSW5kZXgsIGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQsIGZvY3VzOiBmb2N1c0N1cnJlbnQsIG1hbmFnZWRDaGlsZHJlbiB9O1xuXG5cbiAgICBmdW5jdGlvbiB1c2VMaXN0Ym94TXVsdGlQcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHByb3BzOiBQKSB7XG4gICAgICAgIHByb3BzLnJvbGUgPSBcImxpc3Rib3hcIjtcbiAgICAgICAgcHJvcHNbXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiXSA9IFwidHJ1ZVwiO1xuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyh1c2VIYXNGb2N1c1Byb3BzKHVzZUdlbmVyaWNMYWJlbElucHV0UHJvcHModXNlTWVyZ2VkUHJvcHM8RT4oKSh7IG9uS2V5RG93biwgb25LZXlVcCwgb25Gb2N1c091dCB9LCBwcm9wcykpKSk7XG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihlOiBLZXlib2FyZEV2ZW50KSB7IGlmIChlLmtleSA9PSBcIlNoaWZ0XCIpIHNldFNoaWZ0SGVsZCh0cnVlKTsgfVxuICAgIGZ1bmN0aW9uIG9uS2V5VXAoZTogS2V5Ym9hcmRFdmVudCkgeyBpZiAoZS5rZXkgPT0gXCJTaGlmdFwiKSBzZXRTaGlmdEhlbGQoZmFsc2UpOyB9XG4gICAgZnVuY3Rpb24gb25Gb2N1c091dChfOiBGb2N1c0V2ZW50KSB7IHNldFNoaWZ0SGVsZChmYWxzZSk7IH1cblxufSIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBNZXJnZWRQcm9wcywgdXNlQWN0aXZlRWxlbWVudCwgdXNlQ2hpbGRGbGFnLCB1c2VMYXlvdXRFZmZlY3QsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzUmV0dXJuVHlwZSwgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFByb3BzUmV0dXJuVHlwZSwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFdmVudERldGFpbCwgVGFnU2Vuc2l0aXZlUHJvcHMgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlUHJlc3NFdmVudEhhbmRsZXJzIH0gZnJvbSBcIi4vdXNlLWJ1dHRvblwiO1xuaW1wb3J0IHsgdXNlR2VuZXJpY0xhYmVsIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XG5cbnR5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+O1xuZXhwb3J0IHR5cGUgTGlzdGJveFNpbmdsZVNlbGVjdEV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSB7IFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogbnVtYmVyIH0gfSAmIFBpY2s8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPiwgXCJ0YXJnZXRcIiB8IFwiY3VycmVudFRhcmdldFwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVycyBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBcInNob3VsZEZvY3VzT25DaGFuZ2VcIj4ge1xuICAgIHNlbGVjdGlvbk1vZGU6IFwiZm9jdXNcIiB8IFwiYWN0aXZhdGVcIjtcbiAgICBzZWxlY3RlZEluZGV4OiBudW1iZXIgfCBudWxsO1xuICAgIG9uU2VsZWN0PyhldmVudDogTGlzdGJveFNpbmdsZVNlbGVjdEV2ZW50PEVsZW1lbnQ+KTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlSXRlbUluZm88RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZEluZm8sIFRhZ1NlbnNpdGl2ZVByb3BzPEU+IHtcbiAgICBzZXRTZWxlY3RlZChzZWxlY3RlZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgZ2V0U2VsZWN0ZWQoKTogYm9vbGVhbiB8IG51bGw7XG59XG5cblxuXG5leHBvcnQgdHlwZSBVc2VMaXN0Ym94U2luZ2xlSXRlbTxFIGV4dGVuZHMgRWxlbWVudCwgSSBleHRlbmRzIFVzZUxpc3Rib3hTaW5nbGVJdGVtSW5mbzxFPj4gPSAoaW5mbzogVXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzPEUsIEk+KSA9PiBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGU8RT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZUl0ZW1SZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wczogPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4ocHJvcHM6IFApID0+IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wc1JldHVyblR5cGU8RSwgTWVyZ2VkUHJvcHM8RSwgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFVzZVJlZkVsZW1lbnRQcm9wc1JldHVyblR5cGU8RSwgUD4+PjtcbiAgICB0YWJiYWJsZTogYm9vbGVhbiB8IG51bGw7XG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW4gfCBudWxsO1xuICAgIGdldFNlbGVjdGVkOiAoKSA9PiBib29sZWFuIHwgbnVsbDtcbn1cblxuXG5leHBvcnQgdHlwZSBVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQsIEkgZXh0ZW5kcyBVc2VMaXN0Ym94U2luZ2xlSXRlbUluZm88RT4+ID0gT21pdDxJLCBcImdldFRhYmJhYmxlXCIgfCBcInNldFRhYmJhYmxlXCIgfCBcInJlcmVuZGVyQW5kRm9jdXNcIiB8IFwiZ2V0U2VsZWN0ZWRcIiB8IFwic2V0U2VsZWN0ZWRcIj4gJiB7XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFMaXN0Ym94U2luZ2xlPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgVXNlTGlzdGJveFNpbmdsZUl0ZW1JbmZvPENoaWxkRWxlbWVudD4+KHsgc2VsZWN0ZWRJbmRleCwgb25TZWxlY3QsIHNlbGVjdGlvbk1vZGUsIC4uLmFyZ3MgfTogVXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnMpIHtcblxuICAgIGNvbnN0IFthbnlJdGVtc0ZvY3VzZWQsIHNldEFueUl0ZW1zRm9jdXNlZCwgZ2V0QW55SXRlbXNGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIGNvbnN0IHsgdXNlR2VuZXJpY0xhYmVsSW5wdXQsIHVzZUdlbmVyaWNMYWJlbExhYmVsLCBnZXRJbnB1dEVsZW1lbnQgfSA9IHVzZUdlbmVyaWNMYWJlbCh7IGxhYmVsUHJlZml4OiBcImFyaWEtbGlzdGJveC1sYWJlbC1cIiwgaW5wdXRQcmVmaXg6IFwiYXJpYS1saXN0Ym94LVwiIH0pXG4gICAgY29uc3QgeyB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCB1c2VMaXN0TmF2aWdhdGlvblByb3BzLCBuYXZpZ2F0ZVRvSW5kZXgsIG1hbmFnZWRDaGlsZHJlbiwgdGFiYmFibGVJbmRleCwgZm9jdXNDdXJyZW50LCBjdXJyZW50VHlwZWFoZWFkLCBpbnZhbGlkVHlwZWFoZWFkIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxDaGlsZEVsZW1lbnQsIEk+KHsgLi4uYXJncywgc2hvdWxkRm9jdXNPbkNoYW5nZTogZ2V0QW55SXRlbXNGb2N1c2VkIH0pO1xuICAgIGNvbnN0IHsgdXNlR2VuZXJpY0xhYmVsSW5wdXRQcm9wcyB9ID0gdXNlR2VuZXJpY0xhYmVsSW5wdXQ8UGFyZW50RWxlbWVudD4oKTtcbiAgICBjb25zdCBzdGFibGVPblNlbGVjdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uU2VsZWN0ID8/ICgoKSA9PiB7IH0pKTtcblxuICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnQgaXMgYSBjaGlsZCBvZiB0aGUgbGlzdCBib3ggcGFyZW50IGVsZW1lbnQuXG4gICAgLy8gV2hlbiBpdCdzIG5vdCwgd2UgcmVzZXQgdGhlIHRhYmJhYmxlIGluZGV4IGJhY2sgdG8gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBlbGVtZW50LlxuICAgIGNvbnN0IHsgdXNlQWN0aXZlRWxlbWVudFByb3BzIH0gPSB1c2VBY3RpdmVFbGVtZW50PFBhcmVudEVsZW1lbnQ+KHsgb25BY3RpdmVFbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoYWN0aXZlRWxlbWVudDogTm9kZSB8IG51bGwpID0+IHNldEFueUl0ZW1zRm9jdXNlZCghIShnZXRJbnB1dEVsZW1lbnQoKT8uY29udGFpbnMoYWN0aXZlRWxlbWVudCkpKSwgW10pIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghYW55SXRlbXNGb2N1c2VkKVxuICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KHNlbGVjdGVkSW5kZXgpO1xuICAgIH0sIFthbnlJdGVtc0ZvY3VzZWQsIHNlbGVjdGVkSW5kZXgsIG5hdmlnYXRlVG9JbmRleF0pO1xuXG4gICAgdXNlQ2hpbGRGbGFnKHtcbiAgICAgICAgYWN0aXZhdGVkSW5kZXg6IHNlbGVjdGVkSW5kZXgsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgc2V0Q2hpbGRGbGFnOiAoaSwgc2VsZWN0ZWQpID0+IG1hbmFnZWRDaGlsZHJlbltpXT8uc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpLFxuICAgICAgICBnZXRDaGlsZEZsYWc6IChpKSA9PiAobWFuYWdlZENoaWxkcmVuW2ldPy5nZXRTZWxlY3RlZCgpID8/IG51bGwpXG4gICAgfSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoc2VsZWN0ZWRJbmRleCk7XG4gICAgfSwgW3NlbGVjdGVkSW5kZXgsIG1hbmFnZWRDaGlsZHJlbi5sZW5ndGhdKTtcblxuICAgIGNvbnN0IGNoaWxkQ291bnQgPSBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgY29uc3QgdXNlTGlzdGJveFNpbmdsZUl0ZW06IFVzZUxpc3Rib3hTaW5nbGVJdGVtPENoaWxkRWxlbWVudCwgST4gPSB1c2VDYWxsYmFjaygoaW5mbzogVXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgST4pOiBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGU8Q2hpbGRFbGVtZW50PiA9PiB7XG4gICAgICAgIHR5cGUgRSA9IENoaWxkRWxlbWVudDtcbiAgICAgICAgY29uc3QgW3NlbGVjdGVkLCBzZXRTZWxlY3RlZCwgZ2V0U2VsZWN0ZWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KG51bGwpO1xuICAgICAgICBjb25zdCB7IHRhYmJhYmxlLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoeyBzZXRTZWxlY3RlZCwgZ2V0U2VsZWN0ZWQsIC4uLmluZm8gfSBhcyBJKTtcbiAgICAgICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8Q2hpbGRFbGVtZW50Pih7fSk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaW5mby5pbmRleDtcblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHRhYmJhYmxlICYmIHNlbGVjdGlvbk1vZGUgPT0gXCJmb2N1c1wiKSB7XG4gICAgICAgICAgICAgICAgc3RhYmxlT25TZWxlY3Q/Lih7IHRhcmdldDogZWxlbWVudCwgY3VycmVudFRhcmdldDogZWxlbWVudCwgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBpbmRleCB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbdGFiYmFibGUsIHNlbGVjdGlvbk1vZGUsIGluZGV4XSk7XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcywgdGFiYmFibGUsIHNlbGVjdGVkLCBnZXRTZWxlY3RlZCB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVJdGVtUHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+Pihwcm9wczogUCkge1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+ID0gdXNlUHJlc3NFdmVudEhhbmRsZXJzPEU+KGluZm8uZGlzYWJsZWQ/IG51bGwgOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChpbmZvLmluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBzdGFibGVPblNlbGVjdD8uKHsgdGFyZ2V0OiBlbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBlbGVtZW50LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IGluZGV4IH0gfSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSwgdW5kZWZpbmVkKSh7fSk7XG5cbiAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcIm9wdGlvblwiO1xuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXNldHNpemVcIl0gPSAoY2hpbGRDb3VudCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1wb3NpbnNldFwiXSA9IChpbmZvLmluZGV4ICsgMSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1zZWxlY3RlZFwiXSA9IChzZWxlY3RlZCA/PyBmYWxzZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChpbmZvLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IFwidHJ1ZVwiXG5cbiAgICAgICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50PigpKG5ld1Byb3BzLCB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpKSk7XG4gICAgICAgIH1cbiAgICB9LCBbdXNlTGlzdE5hdmlnYXRpb25DaGlsZCwgc2VsZWN0aW9uTW9kZSwgY2hpbGRDb3VudF0pO1xuXG5cbiAgICBjb25zdCB1c2VMaXN0Ym94U2luZ2xlTGFiZWwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlTGFiZWw8RSBleHRlbmRzIEhUTUxFbGVtZW50PigpIHtcbiAgICAgICAgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+Pihwcm9wczogUCkge1xuICAgICAgICAgICAgY29uc3QgeyB1c2VHZW5lcmljTGFiZWxMYWJlbFByb3BzIH0gPSB1c2VHZW5lcmljTGFiZWxMYWJlbDxFPigpO1xuICAgICAgICAgICAgdXNlR2VuZXJpY0xhYmVsTGFiZWxQcm9wcyhwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcyB9O1xuICAgIH0sIFt1c2VHZW5lcmljTGFiZWxMYWJlbF0pO1xuXG5cbiAgICByZXR1cm4geyB1c2VMaXN0Ym94U2luZ2xlSXRlbSwgdXNlTGlzdGJveFNpbmdsZVByb3BzLCB1c2VMaXN0Ym94U2luZ2xlTGFiZWwsIHRhYmJhYmxlSW5kZXgsIGZvY3VzOiBmb2N1c0N1cnJlbnQsIGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQsIG1hbmFnZWRDaGlsZHJlbiB9O1xuXG5cbiAgICBmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlUHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+Pihwcm9wczogUCkge1xuICAgICAgICBwcm9wcy5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzKHVzZUdlbmVyaWNMYWJlbElucHV0UHJvcHModXNlQWN0aXZlRWxlbWVudFByb3BzKHByb3BzKSkpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBNZXJnZWRQcm9wcywgdXNlSGFzRm9jdXMsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wc1JldHVyblR5cGUsIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgdXNlTWVyZ2VkUHJvcHMsIHVzZVJhbmRvbUlkLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlR2V0dGVyLCB1c2VTdGF0ZSwgdXNlVGltZW91dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlU29mdERpc21pc3MgfSBmcm9tIFwiLi91c2UtbW9kYWxcIjtcblxuaW50ZXJmYWNlIFVzZU1lbnVCYXNlUGFyYW1ldGVyczEge1xuICAgIG9wZW46IGJvb2xlYW47XG4gICAgb25DbG9zZSgpOiB2b2lkO1xuICAgIG9uT3BlbigpOiB2b2lkO1xufVxuXG5pbnRlcmZhY2UgVXNlTWVudUJhc2VQYXJhbWV0ZXJzMiB7XG4gICAgbWVudWJhcjogdHJ1ZTtcbn1cblxuaW50ZXJmYWNlIFVzZU1lbnVQYXJhbWV0ZXJzMSBleHRlbmRzIFVzZU1lbnVCYXNlUGFyYW1ldGVyczEsIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycyB7XG59XG5cbmludGVyZmFjZSBVc2VNZW51UGFyYW1ldGVyczIgZXh0ZW5kcyBVc2VNZW51QmFzZVBhcmFtZXRlcnMyLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMge1xufVxuXG5leHBvcnQgdHlwZSBVc2VNZW51QmFzZVBhcmFtZXRlcnMgPSAoVXNlTWVudUJhc2VQYXJhbWV0ZXJzMSB8IFVzZU1lbnVCYXNlUGFyYW1ldGVyczIpICYgeyBzZW5kRm9jdXNXaXRoaW5NZW51KCk6IHZvaWQ7IH07XG5leHBvcnQgdHlwZSBVc2VBcmlhTWVudVBhcmFtZXRlcnMgPSAoVXNlTWVudVBhcmFtZXRlcnMxIHwgVXNlTWVudVBhcmFtZXRlcnMyKTtcbmV4cG9ydCB0eXBlIFVzZU1lbnVTdWJtZW51SXRlbVBhcmFtZXRlcnMgPSBVc2VBcmlhTWVudVBhcmFtZXRlcnMgJiB7fVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktaW50ZXJmYWNlICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVCdXR0b25QYXJhbWV0ZXJzIHsgfVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtQ2hlY2tib3hJbmZvPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbyB7XG4gICAgdHlwZTogXCJjaGVja2JveFwiO1xuICAgIGNoZWNrZWQ6IGJvb2xlYW4gfCBcIm1peGVkXCI7XG4gICAgb25DaGFuZ2UoZTogeyBbRXZlbnREZXRhaWxdOiB7IGNoZWNrZWQ6IGJvb2xlYW4gfSB9ICYgaC5KU1guVGFyZ2V0ZWRFdmVudDxFLCBFdmVudD4pOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtUmFkaW9JbmZvPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbyB7XG4gICAgdHlwZTogXCJyYWRpb1wiO1xuICAgIGNoZWNrZWQ6IGJvb2xlYW47XG4gICAgb25DaGFuZ2UoZTogeyBbRXZlbnREZXRhaWxdOiB7IGNoZWNrZWQ6IGJvb2xlYW4gfSB9ICYgaC5KU1guVGFyZ2V0ZWRFdmVudDxFLCBFdmVudD4pOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtRGVmYXVsdEluZm88RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvIHtcbiAgICB0eXBlPzogXCJkZWZhdWx0XCI7XG4gICAgb25DbGljaz8oZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxFPik6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIFVzZU1lbnVJdGVtQ2hlY2tib3hQYXJhbWV0ZXJzPEkgZXh0ZW5kcyBVc2VNZW51Q2hpbGRJbmZvPiA9IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEk+O1xuZXhwb3J0IHR5cGUgVXNlTWVudUl0ZW1SYWRpb1BhcmFtZXRlcnM8SSBleHRlbmRzIFVzZU1lbnVDaGlsZEluZm8+ID0gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8ST47XG5leHBvcnQgdHlwZSBVc2VNZW51SXRlbURlZmF1bHRQYXJhbWV0ZXJzPEkgZXh0ZW5kcyBVc2VNZW51Q2hpbGRJbmZvPiA9IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEk+O1xuXG5cbmV4cG9ydCB0eXBlIFVzZU1lbnVJdGVtPEUgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgVXNlTWVudUNoaWxkSW5mbz4gPSAoYXJnczogVXNlTWVudUl0ZW1EZWZhdWx0UGFyYW1ldGVyczxJPikgPT4ge1xuICAgIHVzZU1lbnVJdGVtUHJvcHM6IDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHsgLi4ucHJvcHMgfTogUCkgPT4gTWVyZ2VkUHJvcHM8RSwge1xuICAgICAgICBvbkNsaWNrOiBoLkpTWC5Nb3VzZUV2ZW50SGFuZGxlcjxFPjtcbiAgICB9LCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHNSZXR1cm5UeXBlPEUsIFA+PlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVDaGlsZEluZm8gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbyB7XG5cbn1cbmV4cG9ydCB0eXBlIFVzZU1lbnVDaGlsZFBhcmFtZXRlcnM8SSBleHRlbmRzIFVzZU1lbnVDaGlsZEluZm8+ID0gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8ST47XG5cbi8qKlxuICogQSBtZW51IGlzIGEgcG9wdXAgY29udHJvbCB0aGF0IGNvbnRhaW5zIGEgbGlzdCBvZiBtZW51IGl0ZW1zLCBhbmQgdGhhdCdzIGl0LlxuICogSXQgaGFzIHZlcnkgd2VsbC1kZWZpbmVkIGxvZ2ljIGZvciBtYW5hZ2luZyB0aG9zZSBpdGVtcyBhcyB0aGUgbWVudSdzIHN0YXRlIGNoYW5nZXMuXG4gKiBcbiAqIEEgTWVudUJhc2UgaXMganVzdCB0aGUgXCJwb3B1cFwiIHBhcnQgd2l0aG91dCB0aGUgXCJsaXN0IG9mIG1lbnUgaXRlbXNcIiBwYXJ0LiBJdCBjYW5cbiAqIChyZWFsbHksIG11c3QpIGhhdmUgaW50ZXJhY3RpdmUgY29udHJvbHMsIGJ1dCB0aGVzZSBjb250cm9scyBhcmUgYWxsb3dlZCB0byBiZSBtb3JlXG4gKiBmcmVlLWZvcm0uIFRoaXMgbWVhbnMgdGhhdCwgbGlrZSBhIGRpYWxvZywgeW91IG11c3QgdGVsbCB0aGlzIGhvb2tcbiAqIHdoZXJlIHdpdGhpbiB0aGUgcG9wdXAgdG8gc2VuZCBmb2N1cyB3aGVuIG9wZW5lZCAoZm9yIGEgbWVudSBpdCdzIGp1c3QgdGhlIGZpcnN0XG4gKiBtZW51IGl0ZW0sIGJ1dCB3aXRoIGN1c3RvbSBjb250ZW50IHlvdSdsbCBuZWVkIHRvIHByb3ZpZGUgdGhpcykuXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbnVCYXNlPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHNlbmRGb2N1c1dpdGhpbk1lbnUsIC4uLmFyZ3MgfTogVXNlTWVudUJhc2VQYXJhbWV0ZXJzKSB7XG4gICAgdHlwZSBFID0gUGFyZW50RWxlbWVudDtcblxuICAgIGNvbnN0IGdldFNlbmRGb2N1c1dpdGhpbk1lbnUgPSB1c2VTdGFibGVHZXR0ZXIoc2VuZEZvY3VzV2l0aGluTWVudSk7XG4gICAgY29uc3QgW2ZvY3VzVHJhcEFjdGl2ZSwgc2V0Rm9jdXNUcmFwQWN0aXZlXSA9IHVzZVN0YXRlPG51bGwgfCBib29sZWFuPihudWxsKTtcblxuICAgIGNvbnN0IG9uQ2xvc2UgPSAoYXJncyBhcyBQYXJ0aWFsPFVzZU1lbnVQYXJhbWV0ZXJzMT4pLm9uQ2xvc2U7XG4gICAgY29uc3Qgb25PcGVuID0gKGFyZ3MgYXMgUGFydGlhbDxVc2VNZW51UGFyYW1ldGVyczE+KS5vbk9wZW47XG4gICAgY29uc3QgbWVudWJhciA9IChhcmdzIGFzIFBhcnRpYWw8VXNlTWVudVBhcmFtZXRlcnMyPikubWVudWJhcjtcbiAgICBjb25zdCBvcGVuID0gKG1lbnViYXIgPyB0cnVlIDogKGFyZ3MgYXMgVXNlTWVudVBhcmFtZXRlcnMxKS5vcGVuKTtcbiAgICBjb25zdCBzdGFibGVPbkNsb3NlID0gdXNlU3RhYmxlQ2FsbGJhY2sob25DbG9zZSA/PyAoKCkgPT4geyB9KSk7XG4gICAgY29uc3QgZ2V0T3BlbiA9IHVzZVN0YWJsZUdldHRlcihvcGVuKTtcblxuICAgIC8vIFRPRE86IEl0J3MgYXdrd2FyZCB0aGF0IHRoZSBidXR0b24gZm9jdXMgcHJvcHMgYXJlIG91dCBoZXJlIHdoZXJlIHdlIGRvbid0IGhhdmUgaXRzIHR5cGUsXG4gICAgLy8gYnV0IGZvY3VzIG1hbmFnZW1lbnQgaXMgc3VwZXIgc2Vuc2l0aXZlLCBhbmQgZXZlbiB3YWl0aW5nIGZvciBhIHVzZUxheW91dEVmZmVjdCB0byBzeW5jIHN0YXRlIGhlcmVcbiAgICAvLyB3b3VsZCBiZSB0b28gbGF0ZSwgc28gaXQgd291bGQgbG9vayBsaWtlIHRoZXJlJ3MgYSBtb21lbnQgYmV0d2VlbiBtZW51IGZvY3VzIGxvc3QgYW5kIGJ1dHRvbiBmb2N1cyBnYWluZWRcbiAgICAvLyB3aGVyZSBub3RoaW5nIGlzIGZvY3VzZWQuIFxuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wczogdXNlTWVudUJhc2VIYXNGb2N1c1Byb3BzLCBnZXRMYXN0Rm9jdXNlZElubmVyOiBnZXRNZW51QmFzZUxhc3RGb2N1c2VkSW5uZXIgfSA9IHVzZUhhc0ZvY3VzPEU+KHsgLypvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkOiBvbk1lbnVPckJ1dHRvbkxvc3RMYXN0Rm9jdXMqLyB9KTtcbiAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHM6IHVzZUJ1dHRvbkhhc0ZvY3VzUHJvcHMsIGdldExhc3RGb2N1c2VkSW5uZXI6IGdldE1lbnVCYXNlQnV0dG9uTGFzdEZvY3VzZWRJbm5lciB9ID0gdXNlSGFzRm9jdXM8YW55Pih7IC8qb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogb25NZW51T3JCdXR0b25Mb3N0TGFzdEZvY3VzKi8gfSk7XG5cbiAgICBjb25zdCBbLCBzZXRPcGVuZXJFbGVtZW50LCBnZXRPcGVuZXJFbGVtZW50XSA9IHVzZVN0YXRlPChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCkgfCBudWxsPihudWxsKTtcblxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlTWVudUJhc2VJZFByb3BzLCB1c2VSZWZlcmVuY2VkSWRQcm9wczogdXNlTWVudUJhc2VJZFJlZmVyZW5jaW5nUHJvcHMgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtbWVudS1cIiB9KTtcblxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0QnV0dG9uRWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VCdXR0b25SZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8YW55Pih7IG9uRWxlbWVudENoYW5nZTogc2V0T3BlbmVyRWxlbWVudCB9KTtcblxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0TWVudUVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlTWVudUJhc2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8YW55Pih7fSk7XG4gICAgY29uc3QgeyB1c2VTb2Z0RGlzbWlzc1Byb3BzIH0gPSB1c2VTb2Z0RGlzbWlzczxhbnk+KHsgb25DbG9zZTogc3RhYmxlT25DbG9zZSwgZ2V0RWxlbWVudHM6ICgpID0+IChbZ2V0QnV0dG9uRWxlbWVudCgpLCBnZXRNZW51RWxlbWVudCgpXSkgfSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRGb2N1c1RyYXBBY3RpdmUob3Blbik7XG4gICAgfSwgW29wZW5dKTtcblxuXG5cbiAgICBjb25zdCB1c2VNZW51QmFzZVByb3BzID0gdXNlQ2FsbGJhY2soPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50Pj4ocHJvcHM6IFApID0+IHtcbiAgICAgICAgZnVuY3Rpb24gb25LZXlEb3duKGU6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChlLmtleSA9PSBcIkVzY2FwZVwiICYmIGdldE9wZW4oKSkge1xuICAgICAgICAgICAgICAgIHN0YWJsZU9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVzZVNvZnREaXNtaXNzUHJvcHModXNlTWVudUJhc2VIYXNGb2N1c1Byb3BzKHVzZU1lbnVCYXNlUmVmRWxlbWVudFByb3BzKHVzZU1lbnVCYXNlSWRQcm9wcyh1c2VNZXJnZWRQcm9wczxQYXJlbnRFbGVtZW50PigpKHsgb25LZXlEb3duIH0sIChwcm9wcykpKSkpKTtcbiAgICB9LCBbdXNlU29mdERpc21pc3NQcm9wcywgdXNlTWVudUJhc2VIYXNGb2N1c1Byb3BzLCB1c2VNZW51QmFzZVJlZkVsZW1lbnRQcm9wcywgdXNlTWVudUJhc2VJZFByb3BzXSk7XG5cbiAgICBjb25zdCB1c2VNZW51QmFzZUJ1dHRvblByb3BzID0gdXNlQ2FsbGJhY2soPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+Pihwcm9wczogUCkgPT4ge1xuICAgICAgICByZXR1cm4gdXNlQnV0dG9uUmVmRWxlbWVudFByb3BzKHVzZUJ1dHRvbkhhc0ZvY3VzUHJvcHModXNlTWVudUJhc2VJZFJlZmVyZW5jaW5nUHJvcHMoXCJhcmlhLWNvbnRyb2xzXCIpKHByb3BzKSkpO1xuICAgIH0sIFt1c2VCdXR0b25IYXNGb2N1c1Byb3BzLCB1c2VCdXR0b25SZWZFbGVtZW50UHJvcHMsIHVzZU1lbnVCYXNlSWRSZWZlcmVuY2luZ1Byb3BzXSk7XG5cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbmRGb2N1c1dpdGhpbk1lbnUgPSBnZXRTZW5kRm9jdXNXaXRoaW5NZW51KCk7XG5cbiAgICAgICAgaWYgKGZvY3VzVHJhcEFjdGl2ZSkge1xuICAgICAgICAgICAgc2VuZEZvY3VzV2l0aGluTWVudT8uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9jdXNUcmFwQWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGdldE1lbnVCYXNlTGFzdEZvY3VzZWRJbm5lcigpKVxuICAgICAgICAgICAgICAgIGdldE9wZW5lckVsZW1lbnQoKT8uZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbnVsbCwgc28gd2UndmUgb25seSBqdXN0IG1vdW50ZWQgYW5kIHNob3VsZG4ndCBmb2N1cyBvdXJzZWx2ZXMuXG4gICAgICAgIH1cbiAgICB9LCBbZm9jdXNUcmFwQWN0aXZlXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VNZW51U2VudGluZWw6IHVzZUNhbGxiYWNrKDxFIGV4dGVuZHMgRWxlbWVudD4oKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHVzZVNlbnRpbmVsUHJvcHM6IHVzZU1lbnVTZW50aW5lbFByb3BzLCAuLi5yZXN0IH0gPSB1c2VGb2N1c1NlbnRpbmVsPEU+KHsgb3Blbiwgb25DbG9zZTogKG9uQ2xvc2UgPz8gKCgpID0+IHsgfSkpLCBzZW5kRm9jdXNXaXRoaW5NZW51IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgdXNlTWVudVNlbnRpbmVsUHJvcHMsIC4uLnJlc3QgfTtcbiAgICAgICAgfSwgW29wZW4sIG9uQ2xvc2UsIHNlbmRGb2N1c1dpdGhpbk1lbnVdKSxcbiAgICAgICAgZm9jdXNUcmFwQWN0aXZlLFxuICAgICAgICB1c2VNZW51QmFzZVByb3BzLFxuICAgICAgICB1c2VNZW51QmFzZUJ1dHRvblByb3BzLFxuICAgICAgICBnZXRNZW51QmFzZUxhc3RGb2N1c2VkSW5uZXIsXG4gICAgICAgIGdldE1lbnVCYXNlQnV0dG9uTGFzdEZvY3VzZWRJbm5lcixcbiAgICAgICAgb3BlbixcbiAgICAgICAgb25PcGVuLFxuICAgICAgICBvbkNsb3NlXG4gICAgfVxufVxuXG5cbi8vIEEgZm9jdXMgc2VudGluYWwgaXMgYSBoaWRkZW4gYnV0IGZvY3VzYWJsZSBlbGVtZW50IHRoYXQgY29tZXMgYXQgdGhlIHN0YXJ0IG9yIGVuZCBcbi8vIG9mIHRoZSBvdXQtb2YtcGxhY2UtZm9jdXNhYmxlIGNvbXBvbmVudCB0aGF0LCB3aGVuIGFjdGl2YXRlZCBvciBmb2N1c2VkIG92ZXIsIGNsb3NlcyB0aGUgY29tcG9uZW50XG4vLyAoaWYgZm9jdXNlZCB3aXRoaW4gMTAwbXMgb2YgdGhlIG9wZW4gcHJvcCBjaGFuZ2luZywgaW5zdGVhZCBvZlxuLy8gY2xvc2luZywgZm9jdXNpbmcgdGhlIHNlbnRpbmVsIGltbWVkaWF0ZWx5IGFza3MgaXQgdG8gZm9jdXMgaXRzZWxmKS5cbi8vIFRoaXMgZXhpc3RzIGZvciB0aGluZ3MgbGlrZSBtZW51cyB3aGljaCBjYW4gaGF2ZSBmb2N1cyBidXQgYWxzbyBuZWVkIGEgd2F5IHRvIHJldHVyblxuLy8gdG8gd2hhdGV2ZXIgb3V0LW9mLXBsYWNlIHBhcmVudCB0aGV5IGNhbWUgZnJvbSB3aGVuIG5hdHVyYWxseSB0YWJiZWQgb3V0IG9mIChhcyBvcHBvc2VkXG4vLyB0byBkaWFsb2dzIHdoaWNoIGxvb3AgYmFjayBhcm91bmQgd2hlbiB0YWJiZWQgb3V0IG9mKS4gV2hpbGUgbW91c2UgdXNlcnMgY2FuIGNsaWNrIG91dCBvZiBhIG1lbnVcbi8vIGFuZCBrZXlib2FyZCB1c2VycyBjYW4gZXNjYXBlIHRvIGNsb3NlIGEgbWVudSwgc2NyZWVuIHJlYWRlcnMgYW5kIG90aGVyIGlucHV0IG1ldGhvZHMgXG4vLyB0aGF0IGRvbid0IHVzZSB0aG9zZSB0d28gd291bGQgYmVjb21lIHN0dWNrLlxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvY3VzU2VudGluZWw8RSBleHRlbmRzIEVsZW1lbnQ+KHsgb3Blbiwgb25DbG9zZSwgc2VuZEZvY3VzV2l0aGluTWVudSB9OiB7IG9wZW46IGJvb2xlYW4sIG9uQ2xvc2U6ICgpID0+IHZvaWQ7IHNlbmRGb2N1c1dpdGhpbk1lbnU6ICgpID0+IHZvaWQ7IH0pIHtcbiAgICBjb25zdCBnZXRTZW5kRm9jdXNXaXRoaW5NZW51ID0gdXNlU3RhYmxlR2V0dGVyKHNlbmRGb2N1c1dpdGhpbk1lbnUpO1xuICAgIGNvbnN0IHN0YWJsZU9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjayhvbkNsb3NlKTtcblxuICAgIGNvbnN0IFtmaXJzdFNlbnRpbmVsSXNBY3RpdmUsIHNldEZpcnN0U2VudGluZWxJc0FjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgdXNlVGltZW91dCh7IGNhbGxiYWNrOiAoKSA9PiB7IHNldEZpcnN0U2VudGluZWxJc0FjdGl2ZShvcGVuKTsgfSwgdGltZW91dDogMTAwLCB0cmlnZ2VySW5kZXg6IGAke29wZW59LSR7Zmlyc3RTZW50aW5lbElzQWN0aXZlfWAgfSk7XG5cblxuICAgIGNvbnN0IG9uRm9jdXMgPSBmaXJzdFNlbnRpbmVsSXNBY3RpdmUgPyAoKCkgPT4gc3RhYmxlT25DbG9zZSgpKSA6ICgoKSA9PiBnZXRTZW5kRm9jdXNXaXRoaW5NZW51KCk/LigpKTtcbiAgICBjb25zdCBvbkNsaWNrID0gKCkgPT4gc3RhYmxlT25DbG9zZSgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlU2VudGluZWxQcm9wczogZnVuY3Rpb24gPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4ocDogUCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KCkoeyBvbkZvY3VzLCBvbkNsaWNrIH0sIHApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYU1lbnU8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEkgZXh0ZW5kcyBVc2VNZW51Q2hpbGRJbmZvPih7IGNvbGxhdG9yLCBrZXlOYXZpZ2F0aW9uLCBub1R5cGVhaGVhZCwgbm9XcmFwLCB0eXBlYWhlYWRUaW1lb3V0LCAuLi5hcmdzIH06IFVzZUFyaWFNZW51UGFyYW1ldGVycykge1xuXG5cblxuICAgIGNvbnN0IHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxuICAgICAgICB0YWJiYWJsZUluZGV4LFxuICAgICAgICBmb2N1c0N1cnJlbnQ6IGZvY3VzTWVudSxcbiAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZFxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxDaGlsZEVsZW1lbnQsIEk+KHsgXG4gICAgICAgIGNvbGxhdG9yLCBcbiAgICAgICAga2V5TmF2aWdhdGlvbiwgXG4gICAgICAgIG5vVHlwZWFoZWFkLCBcbiAgICAgICAgbm9XcmFwLCBcbiAgICAgICAgdHlwZWFoZWFkVGltZW91dCwgXG4gICAgICAgIHNob3VsZEZvY3VzT25DaGFuZ2U6IHVzZUNhbGxiYWNrKCgpOiBib29sZWFuID0+IGdldE1lbnVCYXNlTGFzdEZvY3VzZWRJbm5lcigpIHx8IGdldE1lbnVCYXNlQnV0dG9uTGFzdEZvY3VzZWRJbm5lcigpLCBbXSkgXG4gICAgfSk7XG5cblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTWVudVNlbnRpbmVsLFxuICAgICAgICB1c2VNZW51QmFzZUJ1dHRvblByb3BzLFxuICAgICAgICB1c2VNZW51QmFzZVByb3BzLFxuICAgICAgICBnZXRNZW51QmFzZUJ1dHRvbkxhc3RGb2N1c2VkSW5uZXIsXG4gICAgICAgIGdldE1lbnVCYXNlTGFzdEZvY3VzZWRJbm5lcixcbiAgICAgICAgb3BlbixcbiAgICAgICAgb25PcGVuLFxuICAgICAgICBvbkNsb3NlXG4gICAgfSA9IHVzZU1lbnVCYXNlPFBhcmVudEVsZW1lbnQ+KHsgXG4gICAgICAgIC4uLmFyZ3MsIFxuICAgICAgICBzZW5kRm9jdXNXaXRoaW5NZW51OiBmb2N1c01lbnUgPz8gKCgpID0+IHsgfSkgXG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VNZW51QnV0dG9uID0gdXNlQ2FsbGJhY2soPEUgZXh0ZW5kcyBFbGVtZW50Pih7IC4uLl8gfTogVXNlTWVudUJ1dHRvblBhcmFtZXRlcnMpID0+IHtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlTWVudUJ1dHRvblByb3BzOiBmdW5jdGlvbiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+PihwOiBQKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB1c2VNZW51QmFzZUJ1dHRvblByb3BzKHApO1xuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1oYXNwb3B1cFwiXSA9IFwibWVudVwiO1xuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1leHBhbmRlZFwiXSA9IG9wZW4gPyBcInRydWVcIiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbb3Blbiwgb25DbG9zZSwgb25PcGVuLCB1c2VNZW51QmFzZUJ1dHRvblByb3BzXSk7XG5cbiAgICBjb25zdCB1c2VNZW51SXRlbTogVXNlTWVudUl0ZW08Q2hpbGRFbGVtZW50LCBJPiA9IHVzZUNhbGxiYWNrKChhcmdzOiBVc2VNZW51SXRlbURlZmF1bHRQYXJhbWV0ZXJzPEk+KSA9PiB7XG4gICAgICAgIHR5cGUgRSA9IENoaWxkRWxlbWVudDtcblxuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZChhcmdzKTtcblxuICAgICAgICBmdW5jdGlvbiB1c2VNZW51SXRlbVByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4oeyAuLi5wcm9wcyB9OiBQKSB7XG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJtZW51aXRlbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KCkoe30sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlTWVudUl0ZW1Qcm9wcyB9O1xuICAgIH0sIFtdKTtcblxuXG4gICAgZnVuY3Rpb24gdXNlTWVudVByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50Pj4oeyAuLi5wcm9wcyB9OiBQKSB7XG4gICAgICAgIHByb3BzLnJvbGUgPSBcIm1lbnVcIjtcbiAgICAgICAgcmV0dXJuIHVzZU1lbnVCYXNlUHJvcHModXNlTGlzdE5hdmlnYXRpb25Qcm9wcyhwcm9wcykpO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTWVudVByb3BzLFxuICAgICAgICB1c2VNZW51QnV0dG9uLFxuXG4gICAgICAgIHVzZU1lbnVJdGVtLFxuICAgICAgICB1c2VNZW51U2VudGluZWwsXG4gICAgICAgIC8vdXNlTWVudVN1Ym1lbnVJdGVtLFxuXG4gICAgICAgIGZvY3VzTWVudSxcblxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxuICAgICAgICBpbnZhbGlkVHlwZWFoZWFkLFxuXG4gICAgICAgIHRhYmJhYmxlSW5kZXgsXG5cbiAgICAgICAgbWFuYWdlZENoaWxkcmVuXG5cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBMb2dpY2FsRGlyZWN0aW9uSW5mbywgTWFuYWdlZENoaWxkSW5mbywgTWVyZ2VkUHJvcHMsIHVzZUNoaWxkRmxhZywgdXNlQ2hpbGRNYW5hZ2VyLCB1c2VIYXNGb2N1cywgdXNlTGF5b3V0RWZmZWN0LCB1c2VMaXN0TmF2aWdhdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25DaGlsZEluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIHVzZUxvZ2ljYWxEaXJlY3Rpb24sIHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgVXNlUmFuZG9tSWRQcm9wc1JldHVyblR5cGUsIHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQcm9wc1JldHVyblR5cGUsIFVzZVJlZmVyZW5jZWRJZFByb3BzUmV0dXJuVHlwZSwgdXNlU3RhYmxlR2V0dGVyLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwsIFRhZ1NlbnNpdGl2ZVByb3BzIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlUHJlc3NFdmVudEhhbmRsZXJzIH0gZnJvbSBcIi4vdXNlLWJ1dHRvblwiO1xyXG5cclxuZXhwb3J0IHR5cGUgVGFic0NoYW5nZUV2ZW50PEUgZXh0ZW5kcyBFbGVtZW50PiA9IHsgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfSB9ICYgUGljazxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+LCBcInRhcmdldFwiIHwgXCJjdXJyZW50VGFyZ2V0XCI+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFic1BhcmFtZXRlcnMgZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgXCJrZXlOYXZpZ2F0aW9uXCIgfCBcInNob3VsZEZvY3VzT25DaGFuZ2VcIj4ge1xyXG4gICAgc2VsZWN0ZWRJbmRleDogbnVtYmVyIHwgbnVsbDtcclxuICAgIG9uU2VsZWN0KGV2ZW50OiBUYWJzQ2hhbmdlRXZlbnQ8RWxlbWVudD4pOiB2b2lkO1xyXG4gICAgc2VsZWN0aW9uTW9kZTogXCJmb2N1c1wiIHwgXCJhY3RpdmF0ZVwiO1xyXG4gICAgb3JpZW50YXRpb246IFwiaW5saW5lXCIgfCBcImJsb2NrXCI7XHJcbn1cclxuXHJcbnR5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+O1xyXG5leHBvcnQgdHlwZSBVc2VUYWJQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgVXNlVGFiSW5mbz4gPSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxPbWl0PEksIFwidGFiSWRcIiB8IFwic2V0VGFiUGFuZWxJZFwiIHwgXCJzZXRTZWxlY3RlZFwiIHwgXCJnZXRTZWxlY3RlZFwiIHwgXCJzZXRTZWxlY3Rpb25Nb2RlXCI+PiAmIFRhZ1NlbnNpdGl2ZVByb3BzPEU+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJQYW5lbFBhcmFtZXRlcnMgZXh0ZW5kcyBPbWl0PFVzZVRhYlBhbmVsSW5mbywgXCJ0YWJQYW5lbElkXCIgfCBcInNldFRhYklkXCIgfCBcImZvY3VzXCIgfCBcInNldFZpc2libGVcIiB8IFwiZ2V0VmlzaWJsZVwiPiB7IH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiSW5mbyBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvIHtcclxuICAgIHNldFNlbGVjdGVkKHNlbGVjdGVkOiBib29sZWFuKTogdm9pZDtcclxuICAgIGdldFNlbGVjdGVkKCk6IGJvb2xlYW4gfCBudWxsO1xyXG5cclxuICAgIHRhYklkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICBzZXRUYWJQYW5lbElkKHRhYklkOiBzdHJpbmcgfCB1bmRlZmluZWQpOiB2b2lkO1xyXG4gICAgc2V0U2VsZWN0aW9uTW9kZShtb2RlOiBcImZvY3VzXCIgfCBcImFjdGl2YXRlXCIpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlBhbmVsSW5mbyBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyPiB7XHJcbiAgICBzZXRWaXNpYmxlKHZpc2libGU6IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgZ2V0VmlzaWJsZSgpOiBib29sZWFuIHwgbnVsbDtcclxuICAgIHRhYlBhbmVsSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgIHNldFRhYklkKHRhYklkOiBzdHJpbmcgfCB1bmRlZmluZWQpOiB2b2lkO1xyXG4gICAgZm9jdXMoKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlVGFic0xpc3Q8VGFiTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlVGFiTGlzdFByb3BzOiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkxpc3RFbGVtZW50Pj4ocHJvcHM6IFApID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkxpc3RFbGVtZW50PjsgfVxyXG5leHBvcnQgdHlwZSBVc2VUYWJzTGFiZWwgPSA8RSBleHRlbmRzIEVsZW1lbnQ+KCkgPT4geyB1c2VUYWJzTGFiZWxQcm9wczogPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4oeyAuLi5wcm9wcyB9OiBQKSA9PiBVc2VSYW5kb21JZFByb3BzUmV0dXJuVHlwZTxQPjsgfVxyXG5leHBvcnQgdHlwZSBVc2VUYWI8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEkgZXh0ZW5kcyBVc2VUYWJJbmZvPiA9IChpbmZvOiBVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIEk+KSA9PiB7IHNlbGVjdGVkOiBib29sZWFuIHwgbnVsbDsgdXNlVGFiUHJvcHM6IDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4+KHsgLi4ucHJvcHMgfTogUCkgPT4gTWVyZ2VkUHJvcHM8VGFiRWxlbWVudCwge30sIFVzZVJlZmVyZW5jZWRJZFByb3BzUmV0dXJuVHlwZTxVc2VSYW5kb21JZFByb3BzUmV0dXJuVHlwZTxhbnk+LCBcImFyaWEtY29udHJvbHNcIj4+OyB9XHJcbmV4cG9ydCB0eXBlIFVzZVRhYlBhbmVsPFBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGluZm86IFVzZVRhYlBhbmVsUGFyYW1ldGVycykgPT4geyB2aXNpYmxlOiBib29sZWFuIHwgbnVsbCwgdXNlVGFiUGFuZWxQcm9wczogPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxQYW5lbEVsZW1lbnQ+PihwOiBQKSA9PiBNZXJnZWRQcm9wczxQYW5lbEVsZW1lbnQsIHt9LCBVc2VSYW5kb21JZFByb3BzUmV0dXJuVHlwZTxVc2VSZWZFbGVtZW50UHJvcHNSZXR1cm5UeXBlPFBhbmVsRWxlbWVudCwgUD4+PiB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYVRhYnM8TGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiUGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBzZWxlY3Rpb25Nb2RlLCBzZWxlY3RlZEluZGV4LCBvblNlbGVjdCwgb3JpZW50YXRpb246IGxvZ2ljYWxPcmllbnRhdGlvbiwgLi4uYXJncyB9OiBVc2VBcmlhVGFic1BhcmFtZXRlcnMpIHtcclxuXHJcbiAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHM6IHVzZVRhYkxpc3RIYXNGb2N1c1Byb3BzLCBnZXRGb2N1c2VkSW5uZXI6IGdldFRhYkxpc3RGb2N1c2VkSW5uZXIgfSA9IHVzZUhhc0ZvY3VzPExpc3RFbGVtZW50Pih7fSk7XHJcbiAgICBjb25zdCBbcGh5c2ljYWxPcmllbnRhdGlvbiwgc2V0UGh5c2ljYWxPcmllbnRhdGlvbl0gPSB1c2VTdGF0ZTxcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIj4oXCJob3Jpem9udGFsXCIpO1xyXG4gICAgY29uc3QgeyBjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uLCB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHMgfSA9IHVzZUxvZ2ljYWxEaXJlY3Rpb248TGlzdEVsZW1lbnQ+KHsgb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlOiB1c2VDYWxsYmFjaygobG9naWNhbERpcmVjdGlvbkluZm86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCkgPT4gc2V0UGh5c2ljYWxPcmllbnRhdGlvbihjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uKGxvZ2ljYWxPcmllbnRhdGlvbiwgbG9naWNhbERpcmVjdGlvbkluZm8pKSwgW10pIH0pO1xyXG5cclxuICAgIC8vY29uc3QgeyB1c2VSYW5kb21JZFByb3BzOiB1c2VUYWJMaXN0SWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRUYWJMaXN0SWQgfSA9IHVzZVJhbmRvbUlkKHsgcHJlZml4OiBcImFyaWEtdGFiLWxpc3QtXCIgfSk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUHJvcHM6IHVzZVRhYkxhYmVsSWRQcm9wcywgdXNlUmVmZXJlbmNlZElkUHJvcHM6IHVzZVJlZmVyZW5jZWRUYWJMYWJlbElkIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLXRhYi1sYWJlbC1cIiB9KTtcclxuXHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZFRhYnMsIG5hdmlnYXRlVG9JbmRleCwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCwgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcywgdGFiYmFibGVJbmRleCwgaW52YWxpZFR5cGVhaGVhZCwgY3VycmVudFR5cGVhaGVhZCwgZm9jdXNDdXJyZW50IH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxUYWJFbGVtZW50LCBVc2VUYWJJbmZvPih7IC4uLmFyZ3MsIHNob3VsZEZvY3VzT25DaGFuZ2U6IGdldFRhYkxpc3RGb2N1c2VkSW5uZXIsIGtleU5hdmlnYXRpb246IGxvZ2ljYWxPcmllbnRhdGlvbiB9KTtcclxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkUGFuZWxzLCB1c2VNYW5hZ2VkQ2hpbGQ6IHVzZU1hbmFnZWRUYWJQYW5lbCB9ID0gdXNlQ2hpbGRNYW5hZ2VyPFVzZVRhYlBhbmVsSW5mbz4oKVxyXG5cclxuICAgIGNvbnN0IGNoaWxkQ291bnQgPSBtYW5hZ2VkVGFicy5sZW5ndGg7XHJcblxyXG5cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkVGFicylcclxuICAgICAgICAgICAgY2hpbGQuc2V0U2VsZWN0aW9uTW9kZShzZWxlY3Rpb25Nb2RlKTtcclxuICAgIH0sIFtzZWxlY3Rpb25Nb2RlXSlcclxuXHJcblxyXG4gICAgdXNlQ2hpbGRGbGFnKHsgYWN0aXZhdGVkSW5kZXg6IHNlbGVjdGVkSW5kZXgsIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZFRhYnMsIHNldENoaWxkRmxhZzogKGksIHNlbGVjdGVkKSA9PiBtYW5hZ2VkVGFic1tpXT8uc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpLCBnZXRDaGlsZEZsYWc6IGkgPT4gKG1hbmFnZWRUYWJzW2ldPy5nZXRTZWxlY3RlZCgpKSB9KTtcclxuICAgIHVzZUNoaWxkRmxhZyh7IGFjdGl2YXRlZEluZGV4OiBzZWxlY3RlZEluZGV4LCBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRQYW5lbHMsIHNldENoaWxkRmxhZzogKGksIHZpc2libGUpID0+IG1hbmFnZWRQYW5lbHNbaV0/LnNldFZpc2libGUodmlzaWJsZSksIGdldENoaWxkRmxhZzogaSA9PiAobWFuYWdlZFBhbmVsc1tpXT8uZ2V0VmlzaWJsZSgpKSB9KTtcclxuXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKF9wcmV2KSA9PiB7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbCAmJiBzZWxlY3Rpb25Nb2RlID09IFwiYWN0aXZhdGVcIikge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHdhaXQgYSBtb21lbnQgc28gdGhhdCB0aGUgdGFiIHBhbmVsIHdlIHdhbnQgdG8gZm9jdXNcclxuICAgICAgICAgICAgLy8gaXMgYWN0dWFsbHkgdmlzaWJsZSAoaS5lLiB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBjaGlsZCB0byByZS1yZW5kZXIgaXRzZWxmKS5cclxuICAgICAgICAgICAgLy8gV2UgY291bGQsIGFsdGVybmF0aXZlbHksIHNpZ25hbCB0byB0aGUgY2hpbGQgdGhhdCBpdCBzaG91bGQgZm9jdXMgaXRzZWxmXHJcbiAgICAgICAgICAgIC8vIHRoZSBuZXh0IHRpbWUgaXQgcmVuZGVycyBpdHNlbGYgYXMgdmlzaWJsZSxcclxuICAgICAgICAgICAgLy8gd2hpY2ggbWlnaHQgYmUgYmV0dGVyP1xyXG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VkUGFuZWxzW3NlbGVjdGVkSW5kZXhdPy5mb2N1cygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbY2hpbGRDb3VudCwgc2VsZWN0ZWRJbmRleCwgc2VsZWN0aW9uTW9kZV0pO1xyXG5cclxuXHJcbiAgICBjb25zdCB1c2VUYWI6IFVzZVRhYjxUYWJFbGVtZW50LCBVc2VUYWJJbmZvPiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVRhYihpbmZvOiBVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIFVzZVRhYkluZm8+KSB7XHJcbiAgICAgICAgY29uc3QgW3NlbGVjdGlvbk1vZGVMLCBzZXRTZWxlY3Rpb25Nb2RlTF0gPSB1c2VTdGF0ZTxcImZvY3VzXCIgfCBcImFjdGl2YXRlXCI+KHNlbGVjdGlvbk1vZGUpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PFRhYkVsZW1lbnQ+KHt9KVxyXG4gICAgICAgIGNvbnN0IFt0YWJQYW5lbElkLCBzZXRUYWJQYW5lbElkXSA9IHVzZVN0YXRlPHN0cmluZyB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKVxyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlVGFiSWRQcm9wcywgaWQ6IHRhYklkIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLXRhYi1cIiB9KTtcclxuICAgICAgICBjb25zdCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkLCBnZXRTZWxlY3RlZF0gPSB1c2VTdGF0ZTxib29sZWFuIHwgbnVsbD4obnVsbCk7XHJcbiAgICAgICAgY29uc3QgeyB0YWJiYWJsZSwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzIH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHsgc2V0U2VsZWN0ZWQsIGdldFNlbGVjdGVkLCB0YWJJZCwgc2V0VGFiUGFuZWxJZCwgc2V0U2VsZWN0aW9uTW9kZTogc2V0U2VsZWN0aW9uTW9kZUwsIC4uLmluZm8gfSk7XHJcbiAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VTdGFibGVHZXR0ZXIoaW5mby5pbmRleCk7XHJcblxyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGlmICh0YWJiYWJsZSAmJiBzZWxlY3Rpb25Nb2RlTCA9PSBcImZvY3VzXCIpIHtcclxuICAgICAgICAgICAgICAgIG9uU2VsZWN0KHsgdGFyZ2V0OiBlbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBlbGVtZW50LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IGdldEluZGV4KCkgfSB9IGFzIFRhYnNDaGFuZ2VFdmVudDxFbGVtZW50Pik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbdGFiYmFibGUsIHNlbGVjdGlvbk1vZGVdKTtcclxuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHsgbWFuYWdlZFBhbmVsc1tpbmZvLmluZGV4XT8uc2V0VGFiSWQodGFiSWQpIH0sIFt0YWJJZCwgaW5mby5pbmRleF0pO1xyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlVGFiUHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkVsZW1lbnQ+Pih7IC4uLnByb3BzIH06IFApIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkVsZW1lbnQ+ID0gdXNlUHJlc3NFdmVudEhhbmRsZXJzPFRhYkVsZW1lbnQ+KChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoaW5mby5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBvblNlbGVjdD8uKGVuaGFuY2VFdmVudChlLCB7IHNlbGVjdGVkSW5kZXg6IGdldEluZGV4KCkgfSkpO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQpKHByb3BzKTtcclxuXHJcbiAgICAgICAgICAgIG5ld1Byb3BzLnJvbGUgPSBcInRhYlwiO1xyXG4gICAgICAgICAgICBuZXdQcm9wc1tcImFyaWEtc2VsZWN0ZWRcIl0gPSAoc2VsZWN0ZWQgPz8gZmFsc2UpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1jb250cm9sc1wiXSA9IHRhYlBhbmVsSWQ7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8VGFiRWxlbWVudD4oKSh7fSwgdXNlVGFiSWRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlUmVmRWxlbWVudFByb3BzKG5ld1Byb3BzKSkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZVRhYlByb3BzLCBzZWxlY3RlZCB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IHVzZVRhYlBhbmVsOiBVc2VUYWJQYW5lbDxUYWJQYW5lbEVsZW1lbnQ+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlUGFuZWwoaW5mbzogVXNlVGFiUGFuZWxQYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgLy9jb25zdCBbc2hvdWxkRm9jdXMsIHNldFNob3VsZEZvY3VzXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgICAgICBjb25zdCBbLCBzZXRUYWJJZF0gPSB1c2VTdGF0ZTx1bmRlZmluZWQgfCBzdHJpbmc+KHVuZGVmaW5lZCk7XHJcbiAgICAgICAgY29uc3QgW3Zpc2libGUsIHNldFZpc2libGUsIGdldFZpc2libGVdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KG51bGwpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlUGFuZWxJZFByb3BzLCBpZDogdGFiUGFuZWxJZCB9ID0gdXNlUmFuZG9tSWQoeyBwcmVmaXg6IFwiYXJpYS10YWItcGFuZWwtXCIgfSk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlTWFuYWdlZFRhYlBhbmVsPFRhYlBhbmVsRWxlbWVudD4oeyAuLi5pbmZvLCB0YWJQYW5lbElkLCBzZXRUYWJJZCwgZm9jdXMsIHNldFZpc2libGU6IHNldFZpc2libGUsIGdldFZpc2libGU6IGdldFZpc2libGUgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGZvY3VzKCkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBnZXRUYWJMaXN0Rm9jdXNlZElubmVyKCkpIHtcclxuICAgICAgICAgICAgICAgIChlbGVtZW50IGFzIEVsZW1lbnQgfCBudWxsIGFzIEhUTUxPclNWR0VsZW1lbnQgfCBudWxsKT8uZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4geyBtYW5hZ2VkVGFic1tpbmZvLmluZGV4XT8uc2V0VGFiUGFuZWxJZCh0YWJQYW5lbElkKSB9LCBbdGFiUGFuZWxJZCwgaW5mby5pbmRleF0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VUYWJQYW5lbFByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJQYW5lbEVsZW1lbnQ+Pih7IC4uLnByb3BzIH06IFApIHtcclxuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWxhYmVsbGVkYnlcIl0gPSBtYW5hZ2VkVGFic1tpbmZvLmluZGV4XT8udGFiSWQ7XHJcbiAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcInRhYnBhbmVsXCI7XHJcbiAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID8/PSAtMTsgICAgICAvLyBNYWtlIHN1cmUgdGhlIHRhYiBwYW5lbCBpcyB0YWJiYWJsZS5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPFRhYlBhbmVsRWxlbWVudD4oKSh7fSwgdXNlUGFuZWxJZFByb3BzKHVzZU1hbmFnZWRDaGlsZFByb3BzKHByb3BzKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlVGFiUGFuZWxQcm9wcywgdmlzaWJsZSB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuXHJcbiAgICBjb25zdCB1c2VUYWJzTGlzdDogVXNlVGFic0xpc3Q8TGlzdEVsZW1lbnQ+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVGFiTGlzdCgpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlVGFiTGlzdFByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4+KHsgLi4ucHJvcHMgfTogUCkge1xyXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJ0YWJsaXN0XCI7XHJcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1vcmllbnRhdGlvblwiXSA9IHBoeXNpY2FsT3JpZW50YXRpb247XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VSZWZlcmVuY2VkVGFiTGFiZWxJZChcImFyaWEtbGFiZWxsZWRieVwiKSh1c2VUYWJMaXN0SGFzRm9jdXNQcm9wcyh1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHModXNlTGlzdE5hdmlnYXRpb25Qcm9wcyhwcm9wcyBhcyBhbnkpKSkgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IGFzIHVua25vd24gYXMgTWVyZ2VkUHJvcHM8TGlzdEVsZW1lbnQsIHt9LCBQPik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VUYWJMaXN0UHJvcHMgfTtcclxuICAgIH0sIFt1c2VMaXN0TmF2aWdhdGlvblByb3BzLCBwaHlzaWNhbE9yaWVudGF0aW9uXSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZVRhYnNMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVRhYnNMYWJlbDxFIGV4dGVuZHMgRWxlbWVudD4oKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gdXNlVGFic0xhYmVsUHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+Pih7IC4uLnByb3BzIH06IFApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZVRhYkxhYmVsSWRQcm9wcyhwcm9wcykgYXMgVXNlUmFuZG9tSWRQcm9wc1JldHVyblR5cGU8UD47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VUYWJzTGFiZWxQcm9wcyB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiB7IHVzZVRhYiwgdXNlVGFiUGFuZWwsIHVzZVRhYnNMaXN0LCB1c2VUYWJzTGFiZWwsIHRhYmJhYmxlSW5kZXgsIGZvY3VzVGFiTGlzdDogZm9jdXNDdXJyZW50LCBjdXJyZW50VHlwZWFoZWFkLCBpbnZhbGlkVHlwZWFoZWFkLCBtYW5hZ2VkUGFuZWxzLCBtYW5hZ2VkVGFicyB9O1xyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgTWVyZ2VkUHJvcHMsIHVzZUdsb2JhbEhhbmRsZXIsIHVzZUhhc0ZvY3VzLCBVc2VIYXNGb2N1c1Byb3BzUmV0dXJuVHlwZSwgdXNlTWVyZ2VkUHJvcHMsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlUmFuZG9tSWQsIFVzZVJhbmRvbUlkUHJvcHNSZXR1cm5UeXBlLCBVc2VSZWZlcmVuY2VkSWRQcm9wc1JldHVyblR5cGUsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG5leHBvcnQgdHlwZSBVc2VUb29sdGlwVHJpZ2dlciA9IDxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQ+KCkgPT4geyB1c2VUb29sdGlwVHJpZ2dlclByb3BzOiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPj4oeyAuLi5wcm9wcyB9OiBQKSA9PiBVc2VSZWZlcmVuY2VkSWRQcm9wc1JldHVyblR5cGU8TWVyZ2VkUHJvcHM8VHJpZ2dlclR5cGUsIHsgb25Qb2ludGVyRW50ZXI6IChlOiBNb3VzZUV2ZW50KSA9PiB2b2lkOyBvblBvaW50ZXJMZWF2ZTogKGU6IE1vdXNlRXZlbnQpID0+IHZvaWQ7IH0sIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPj4sIFwiYXJpYS1kZXNjcmliZWRieVwiPjsgfVxuZXhwb3J0IHR5cGUgVXNlVG9vbHRpcCA9IDxUb29sdGlwVHlwZSBleHRlbmRzIEVsZW1lbnQ+KCkgPT4geyB1c2VUb29sdGlwUHJvcHM6IDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8VG9vbHRpcFR5cGU+Pih7IC4uLnByb3BzIH06IFApID0+IFVzZVJhbmRvbUlkUHJvcHNSZXR1cm5UeXBlPFVzZUhhc0ZvY3VzUHJvcHNSZXR1cm5UeXBlPFRvb2x0aXBUeXBlLCBNZXJnZWRQcm9wczxUb29sdGlwVHlwZSwgeyBvblBvaW50ZXJFbnRlcjogKGU6IE1vdXNlRXZlbnQpID0+IHZvaWQ7IG9uUG9pbnRlckxlYXZlOiAoZTogTW91c2VFdmVudCkgPT4gdm9pZDsgfSwgUD4+PjsgfVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhVG9vbHRpcCh7IG1vdXNlb3ZlckRlbGF5LCBtb3VzZW91dERlbGF5LCBmb2N1c0RlbGF5IH06IHsgbW91c2VvdmVyRGVsYXk/OiBudW1iZXIsIG1vdXNlb3V0RGVsYXk/OiBudW1iZXIsIGZvY3VzRGVsYXk/OiBudW1iZXIgfSkge1xuXG4gICAgbW91c2VvdmVyRGVsYXkgPz89IDQwMDtcbiAgICBtb3VzZW91dERlbGF5ID8/PSA0MDtcbiAgICBmb2N1c0RlbGF5ID8/PSAxO1xuXG4gICAgLy8gVGhlIGVzY2FwZSBrZXkgc2hvdWxkIGNsb3NlIHRvb2x0aXBzLCBidXQgZG8gbm90aGluZyBlbHNlLlxuICAgIC8vIChpLmUuIGNsb3NpbmcgYSB0b29sdGlwIGluIGEgZGlhbG9nIE1VU1QgTk9UIGNsb3NlIHRoZSBkaWFsb2cgdG9vKVxuICAgIC8vIFRPRE86IFRvb2x0aXBzIGFyZSwgZWZmZWN0aXZlbHksIGFsd2F5cyB0aGUgdG9wbW9zdCBjb21wb25lbnQsXG4gICAgLy8gc28gd2UgY2FuIGp1c3QgaGF2ZSB0aGVtIGxpc3RlbiB0byBhbmQgc3dhbGxvdyBhbGwgXCJFc2NhcGVcIlxuICAgIC8vIGtleSBwcmVzc2VzIGJlZm9yZSBhbnlvbmUgZWxzZS4gRm9yIGEgbW9yZSBnZW5lcmFsIHBvcHVwLFxuICAgIC8vIG9yIGEgdG9vbHRpcCBpbiBhIHRvb2x0aXAgKCEhKSBhIGRpZmZlcmVudCBzb2x1dGlvbiB3b3VsZCBiZSBuZWVkZWQuXG4gICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJrZXlkb3duXCIsIChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChnZXRPcGVuKCkgJiYgZS5rZXkgPT09IFwiRXNjYXBlXCIgJiYgIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHNldE9wZW4oZmFsc2UpO1xuICAgICAgICAgICAgc2V0VHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgc2V0VG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgc2V0VHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICBzZXRUb29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcblxuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuLCBnZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRQcm9wczogdXNlVG9vbHRpcElkUHJvcHMsIHVzZVJlZmVyZW5jZWRJZFByb3BzOiB1c2VUb29sdGlwSWRSZWZlcmVuY2luZ1Byb3BzIH0gPSB1c2VSYW5kb21JZCh7IHByZWZpeDogXCJhcmlhLXRvb2x0aXAtXCIgfSk7XG5cbiAgICBjb25zdCBbLCBzZXRUcmlnZ2VyRm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDE7XG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZvY3VzZWQpLCBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDEpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgfSksIHJldHVybkZhbHNlKTtcbiAgICBjb25zdCBbLCBzZXRUb29sdGlwRm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDE7XG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUb29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZvY3VzZWQpLCBkZWxheSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9KSwgcmV0dXJuRmFsc2UpO1xuICAgIGNvbnN0IFssIHNldFRyaWdnZXJIb3Zlcl0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGhvdmVyaW5nOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gaG92ZXJpbmcgPyBtb3VzZW92ZXJEZWxheSA6IG1vdXNlb3V0RGVsYXk7XG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUcmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZChob3ZlcmluZyksIGRlbGF5KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH0pLCByZXR1cm5GYWxzZSk7XG4gICAgY29uc3QgWywgc2V0VG9vbHRpcEhvdmVyXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VTdGFibGVDYWxsYmFjaygoaG92ZXJpbmc6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBob3ZlcmluZyA/IG1vdXNlb3ZlckRlbGF5IDogbW91c2VvdXREZWxheTtcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgJiYgaXNGaW5pdGUoZGVsYXkpKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHNldFRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkKGhvdmVyaW5nKSwgZGVsYXkpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgfSksIHJldHVybkZhbHNlKTtcbiAgICBjb25zdCBbdHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCwgc2V0VHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3RyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkLCBzZXRUcmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3Rvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQsIHNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFt0b29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZCwgc2V0VG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0T3Blbih0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIHx8IHRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkIHx8IHRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQpO1xuICAgIH0sIFt0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIHx8IHRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkIHx8IHRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWRdKVxuXG4gICAgY29uc3QgdXNlVG9vbHRpcFRyaWdnZXI6IFVzZVRvb2x0aXBUcmlnZ2VyID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVG9vbHRpcFRyaWdnZXI8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50PigpIHtcblxuICAgICAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInBvaW50ZXJtb3ZlXCIsIGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIHNldFRyaWdnZXJIb3Zlcih0YXJnZXQgPT0gZ2V0RWxlbWVudCgpIGFzIE5vZGUgfHwgISFnZXRFbGVtZW50KCk/LmNvbnRhaW5zKHRhcmdldCkpO1xuICAgICAgICB9LCB7IGNhcHR1cmU6IHRydWUgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gb25Ub3VjaEVuZChlOiBUb3VjaEV2ZW50KSB7XG4gICAgICAgICAgICAoZS50YXJnZXQgYXMgYW55KS5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VIYXNGb2N1czxUcmlnZ2VyVHlwZT4oeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQ6IHNldFRyaWdnZXJGb2N1c2VkIH0pXG5cblxuICAgICAgICBmdW5jdGlvbiB1c2VUb29sdGlwVHJpZ2dlclByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4+KHsgLi4ucHJvcHMgfTogUCkge1xuICAgICAgICAgICAgLy8gTm90ZTogVGhvdWdoIGl0J3MgaW1wb3J0YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGZvY3VzaW5nIGFjdGl2YXRlcyBhIHRvb2x0aXAsXG4gICAgICAgICAgICAvLyBpdCdzIHBlcmZlY3RseSByZWFzb25hYmxlIHRoYXQgYSBjaGlsZCBlbGVtZW50IHdpbGwgYmUgdGhlIG9uZSB0aGF0J3MgZm9jdXNlZCxcbiAgICAgICAgICAgIC8vIG5vdCB0aGlzIG9uZSwgc28gd2UgZG9uJ3Qgc2V0IHRhYkluZGV4PTBcbiAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID8/PSAtMTtcbiAgICAgICAgICAgIHJldHVybiB1c2VUb29sdGlwSWRSZWZlcmVuY2luZ1Byb3BzKFwiYXJpYS1kZXNjcmliZWRieVwiKShcbiAgICAgICAgICAgICAgICB1c2VIYXNGb2N1c1Byb3BzKFxuICAgICAgICAgICAgICAgICAgICB1c2VNZXJnZWRQcm9wczxUcmlnZ2VyVHlwZT4oKSh7IG9uVG91Y2hFbmQgfSwgKHByb3BzIGFzIGFueSkgYXMgdW5rbm93biBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMgfTtcblxuICAgIH0sIFt1c2VUb29sdGlwSWRSZWZlcmVuY2luZ1Byb3BzXSk7XG5cbiAgICBjb25zdCB1c2VUb29sdGlwID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVG9vbHRpcDxUb29sdGlwVHlwZSBleHRlbmRzIEVsZW1lbnQ+KCkge1xuICAgICAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUhhc0ZvY3VzPFRvb2x0aXBUeXBlPih7IG9uRm9jdXNlZElubmVyQ2hhbmdlZDogc2V0VG9vbHRpcEZvY3VzZWQgfSlcblxuICAgICAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInBvaW50ZXJtb3ZlXCIsIGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIHNldFRvb2x0aXBIb3Zlcih0YXJnZXQgPT0gZ2V0RWxlbWVudCgpIGFzIE5vZGUgfHwgISFnZXRFbGVtZW50KCk/LmNvbnRhaW5zKHRhcmdldCkpO1xuICAgICAgICB9LCB7IGNhcHR1cmU6IHRydWUgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gdXNlVG9vbHRpcFByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxUb29sdGlwVHlwZT4+KHsgLi4ucHJvcHMgfTogUCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZVRvb2x0aXBJZFByb3BzKHVzZUhhc0ZvY3VzUHJvcHModXNlTWVyZ2VkUHJvcHM8VG9vbHRpcFR5cGU+KCkoeyB9LCBwcm9wcykpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZVRvb2x0aXBQcm9wcyB9O1xuICAgIH0sIFt1c2VUb29sdGlwSWRQcm9wc10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlVG9vbHRpcCxcbiAgICAgICAgdXNlVG9vbHRpcFRyaWdnZXIsXG4gICAgICAgIGlzT3Blbjogb3BlbixcbiAgICAgICAgZ2V0SXNPcGVuOiBnZXRPcGVuXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE1lcmdlZFByb3BzLCB1c2VBY3RpdmVFbGVtZW50LCB1c2VDaGlsZEZsYWcsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsLCBUYWdTZW5zaXRpdmVQcm9wcyB9IGZyb20gXCIuL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VDaGVja2JveExpa2UsIFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcblxuZXhwb3J0IHR5cGUgUmFkaW9DaGFuZ2VFdmVudDxFdmVudFR5cGUgZXh0ZW5kcyBFdmVudD4gPSBFdmVudFR5cGUgJiB7IFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRWYWx1ZTogc3RyaW5nIH0gfTtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4ge1xuICAgIG5hbWU6IHN0cmluZztcblxuICAgIHNlbGVjdGVkVmFsdWU6IFY7XG4gICAgb25JbnB1dChldmVudDogUmFkaW9DaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PEVsZW1lbnQ+Pik6IHZvaWQ7XG4gICAgb25JbnB1dChldmVudDogUmFkaW9DaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PEVsZW1lbnQ+Pik6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVJhZGlvSW5mbyBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvIHtcbiAgICBzZXRDaGVja2VkKGNoZWNrZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICAgIGdldENoZWNrZWQoKTogYm9vbGVhbiB8IG51bGw7XG59XG5cblxuXG5cbmV4cG9ydCB0eXBlIFVzZUFyaWFSYWRpb1BhcmFtZXRlcnM8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50LCBJbmZvIGV4dGVuZHMgVXNlQXJpYVJhZGlvSW5mbz4gPSBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEluZm8+LCBcInNldENoZWNrZWRcIiB8IFwiZ2V0Q2hlY2tlZFwiPiAmXG4gICAgT21pdDxVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIEw+LCBcIm9uSW5wdXRcIiB8IFwicm9sZVwiIHwgXCJjaGVja2VkXCI+ICYge1xuICAgICAgICBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCI7XG4gICAgICAgIHZhbHVlOiBWO1xuICAgICAgICBkaXNhYmxlZDogYm9vbGVhbjtcbiAgICB9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhUmFkaW9Hcm91cDxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHIGV4dGVuZHMgRWxlbWVudCwgSSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50LCBJbmZvIGV4dGVuZHMgVXNlQXJpYVJhZGlvSW5mbz4oeyBuYW1lLCBzZWxlY3RlZFZhbHVlLCBvbklucHV0IH06IFVzZUFyaWFSYWRpb0dyb3VwUGFyYW1ldGVyczxWPikge1xuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0UmFkaW9Hcm91cFBhcmVudEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxHPih7fSk7XG5cbiAgICAvL2NvbnN0IGdldFNlbGVjdGVkSW5kZXggPSB1c2VDYWxsYmFjaygoc2VsZWN0ZWRWYWx1ZTogVikgPT4geyByZXR1cm4gYnlOYW1lLmN1cnJlbnQuZ2V0KHNlbGVjdGVkVmFsdWUpID8/IDAgfSwgW10pXG5cbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPigwKTtcbiAgICBjb25zdCBieU5hbWUgPSB1c2VSZWYobmV3IE1hcDxWLCBhbnk+KCkpO1xuICAgIGNvbnN0IHN0YWJsZU9uSW5wdXQgPSB1c2VTdGFibGVDYWxsYmFjayhvbklucHV0KTtcblxuICAgIGNvbnN0IFthbnlSYWRpb3NGb2N1c2VkLCBzZXRBbnlSYWRpb3NGb2N1c2VkLCBnZXRBbnlSYWRpb3NGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCB1c2VMaXN0TmF2aWdhdGlvblByb3BzLCBuYXZpZ2F0ZVRvSW5kZXgsIHRhYmJhYmxlSW5kZXgsIGZvY3VzQ3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9ID0gdXNlTGlzdE5hdmlnYXRpb248SSwgSW5mbz4oeyBzaG91bGRGb2N1c09uQ2hhbmdlOiBnZXRBbnlSYWRpb3NGb2N1c2VkIH0pO1xuXG4gICAgLy8gVHJhY2sgd2hldGhlciB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHRoZSByYWRpbyBncm91cCBwYXJlbnQgZWxlbWVudC5cbiAgICAvLyBXaGVuIGl0J3Mgbm90LCB3ZSByZXNldCB0aGUgdGFiYmFibGUgaW5kZXggYmFjayB0byB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVsZW1lbnQuXG4gICAgY29uc3QgeyB1c2VBY3RpdmVFbGVtZW50UHJvcHMgfSA9IHVzZUFjdGl2ZUVsZW1lbnQoeyBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChhY3RpdmVFbGVtZW50OiBOb2RlIHwgbnVsbCkgPT4gc2V0QW55UmFkaW9zRm9jdXNlZCghIShnZXRSYWRpb0dyb3VwUGFyZW50RWxlbWVudCgpPy5jb250YWlucyhhY3RpdmVFbGVtZW50KSkpLCBbXSkgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFhbnlSYWRpb3NGb2N1c2VkKVxuICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KHNlbGVjdGVkSW5kZXggPz8gMCk7XG4gICAgfSwgW2FueVJhZGlvc0ZvY3VzZWQsIHNlbGVjdGVkSW5kZXgsIG5hdmlnYXRlVG9JbmRleF0pO1xuXG5cbiAgICBjb25zdCB1c2VSYWRpb0dyb3VwUHJvcHMgPSB1c2VDYWxsYmFjayg8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEc+Pih7IC4uLnByb3BzIH06IFApID0+IHtcbiAgICAgICAgcHJvcHMucm9sZSA9IFwicmFkaW9ncm91cFwiO1xuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyh1c2VSZWZFbGVtZW50UHJvcHModXNlQWN0aXZlRWxlbWVudFByb3BzKHByb3BzKSkpO1xuICAgIH0sIFt1c2VSZWZFbGVtZW50UHJvcHMsIHVzZUFjdGl2ZUVsZW1lbnRQcm9wc10pO1xuXG4gICAgY29uc3QgY29ycmVjdGVkSW5kZXggPSAoc2VsZWN0ZWRJbmRleCA9PSBudWxsIHx8IHNlbGVjdGVkSW5kZXggPCAwIHx8IHNlbGVjdGVkSW5kZXggPj0gbWFuYWdlZENoaWxkcmVuLmxlbmd0aCkgPyBudWxsIDogc2VsZWN0ZWRJbmRleDtcbiAgICB1c2VDaGlsZEZsYWcoe1xuICAgICAgICBhY3RpdmF0ZWRJbmRleDogY29ycmVjdGVkSW5kZXgsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgc2V0Q2hpbGRGbGFnOiAoaSwgY2hlY2tlZCkgPT4gbWFuYWdlZENoaWxkcmVuW2ldPy5zZXRDaGVja2VkKGNoZWNrZWQpLFxuICAgICAgICBnZXRDaGlsZEZsYWc6ICgoaSkgPT4gbWFuYWdlZENoaWxkcmVuW2ldPy5nZXRDaGVja2VkKCkgPz8gZmFsc2UpXG4gICAgfSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gYnlOYW1lLmN1cnJlbnQuZ2V0KHNlbGVjdGVkVmFsdWUpO1xuICAgICAgICBzZXRTZWxlY3RlZEluZGV4KHNlbGVjdGVkSW5kZXggPz8gbnVsbCk7XG4gICAgfSwgW2J5TmFtZSwgc2VsZWN0ZWRWYWx1ZV0pO1xuXG5cblxuICAgIGNvbnN0IHVzZVJhZGlvOiBVc2VSYWRpbzxWLCBJLCBMLCBJbmZvPiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUFyaWFSYWRpbyh7IHZhbHVlLCBpbmRleCwgdGV4dCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24sIC4uLnJlc3QgfTogVXNlQXJpYVJhZGlvUGFyYW1ldGVyczxWLCBJLCBMLCBJbmZvPikge1xuXG4gICAgICAgIGNvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkLCBnZXRDaGVja2VkXSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBudWxsPihudWxsKTtcblxuICAgICAgICBjb25zdCBvbklucHV0ID0gdXNlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8ST4gfCBoLkpTWC5UYXJnZXRlZEV2ZW50PEw+KSA9PiB7XG4gICAgICAgICAgICBzdGFibGVPbklucHV0KGVuaGFuY2VFdmVudChlIGFzIGFueSwgeyBzZWxlY3RlZFZhbHVlOiB2YWx1ZSB9KSk7XG4gICAgICAgIH0sIFtzdGFibGVPbklucHV0LCB2YWx1ZSwgaW5kZXhdKTtcblxuICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50IH0gPSB1c2VDaGVja2JveExpa2U8SSwgTD4oeyBjaGVja2VkOiAoY2hlY2tlZCA/PyBmYWxzZSksIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCBvbklucHV0LCByb2xlOiBcInJhZGlvXCIgfSk7XG5cblxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgYnlOYW1lLmN1cnJlbnQuc2V0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4geyBieU5hbWUuY3VycmVudC5kZWxldGUodmFsdWUpOyB9XG4gICAgICAgIH0sIFtieU5hbWUsIHZhbHVlLCBpbmRleF0pO1xuXG4gICAgICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7IGluZGV4LCBzZXRDaGVja2VkLCBnZXRDaGVja2VkLCB0ZXh0LCAuLi5yZXN0IH0gYXMgYW55IGFzIEluZm8pO1xuXG4gICAgICAgIGNvbnN0IHVzZVJhZGlvSW5wdXQ6IFVzZVJhZGlvSW5wdXQ8ST4gPSAoeyB0YWcgfTogVGFnU2Vuc2l0aXZlUHJvcHM8ST4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVzZVJhZGlvSW5wdXRQcm9wcyA9IDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST4+KHByb3BzOiBQKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNoZWNrZWQgPSAoY2hlY2tlZCA/PyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnR5cGUgPSBcInJhZGlvXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtY2hlY2tlZFwiXSA9IChjaGVja2VkID8/IGZhbHNlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzSWZJbnB1dEhhbmRsZXNGb2N1cyA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQoeyB0YWcgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh1c2VNZXJnZWRQcm9wczxJPigpKCh1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyh7fSkpLCBsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIj8gcHJvcHNJZklucHV0SGFuZGxlc0ZvY3VzIDogcHJvcHMpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXNlUmFkaW9JbnB1dFByb3BzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgdXNlUmFkaW9MYWJlbDogVXNlUmFkaW9MYWJlbDxMPiA9IHVzZUNhbGxiYWNrKCh7IHRhZyB9OiBUYWdTZW5zaXRpdmVQcm9wczxMPikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXNlUmFkaW9MYWJlbFByb3BzID0gPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxMPj4ocHJvcHM6IFApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQoeyB0YWcgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNJZkxhYmVsSGFuZGxlc0ZvY3VzID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHByb3BzIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzPEw+KCkoe30gYXMgYW55LCBsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIj8gcHJvcHNJZkxhYmVsSGFuZGxlc0ZvY3VzIGFzIGFueSA6IHByb3BzIGFzIGFueSkpXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVzZVJhZGlvTGFiZWxQcm9wc1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50XSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZVJhZGlvSW5wdXQsXG4gICAgICAgICAgICB1c2VSYWRpb0xhYmVsLFxuICAgICAgICAgICAgY2hlY2tlZDogY2hlY2tlZCA/PyBmYWxzZSxcbiAgICAgICAgICAgIHRhYmJhYmxlOiB0YWJiYWJsZSA/PyBmYWxzZVxuICAgICAgICB9XG5cbiAgICB9LCBbYnlOYW1lLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VSYWRpbyxcbiAgICAgICAgdXNlUmFkaW9Hcm91cFByb3BzLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgICAgIHRhYmJhYmxlSW5kZXgsXG4gICAgICAgIGZvY3VzUmFkaW86IGZvY3VzQ3VycmVudCxcbiAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZCxcbiAgICAgICAgYW55UmFkaW9zRm9jdXNlZFxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb1JldHVyblR5cGU8SSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdXNlUmFkaW9JbnB1dDogVXNlUmFkaW9JbnB1dDxJPjtcbiAgICB1c2VSYWRpb0xhYmVsOiBVc2VSYWRpb0xhYmVsPEw+O1xuICAgIGNoZWNrZWQ6IGJvb2xlYW47XG4gICAgdGFiYmFibGU6IGJvb2xlYW47XG59XG5cbnR5cGUgVXNlUmFkaW9JbnB1dDxJIGV4dGVuZHMgRWxlbWVudD4gPSAoeyB0YWcgfTogVGFnU2Vuc2l0aXZlUHJvcHM8ST4pID0+IHsgdXNlUmFkaW9JbnB1dFByb3BzOiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+Pihwcm9wczogUCkgPT4gTWVyZ2VkUHJvcHM8SSwgaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST4sIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+PjsgfVxudHlwZSBVc2VSYWRpb0xhYmVsPEwgZXh0ZW5kcyBFbGVtZW50PiA9ICh7IHRhZyB9OiBUYWdTZW5zaXRpdmVQcm9wczxMPikgPT4geyB1c2VSYWRpb0xhYmVsUHJvcHM6IDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8TD4+KHByb3BzOiBQKSA9PiBNZXJnZWRQcm9wczxMLCBoLkpTWC5IVE1MQXR0cmlidXRlczxMPiwgaC5KU1guSFRNTEF0dHJpYnV0ZXM8TD4+OyB9XG5cbmV4cG9ydCB0eXBlIFVzZVJhZGlvPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEkgZXh0ZW5kcyBFbGVtZW50LCBMIGV4dGVuZHMgRWxlbWVudCwgSW5mbyBleHRlbmRzIFVzZUFyaWFSYWRpb0luZm8+ID0gKHsgdmFsdWUsIGluZGV4LCB0ZXh0LCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiB9OiBVc2VBcmlhUmFkaW9QYXJhbWV0ZXJzPFYsIEksIEwsIEluZm8+KSA9PiBVc2VSYWRpb1JldHVyblR5cGU8SSwgTD5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUludGVydmFsIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcblxuXG5leHBvcnQgY29uc3QgRGVtb1VzZUludGVydmFsID0gKCkgPT4ge1xuICAgIGNvbnN0IFtpbnRlcnZhbCwgc2V0SW50ZXJ2YWxdID0gdXNlU3RhdGUoMTAwMCk7XG5cbiAgICBjb25zdCBbZmlyZUNvdW50LCBzZXRGaXJlQ291bnRdID0gdXNlU3RhdGUoMCk7XG5cbiAgICB1c2VJbnRlcnZhbCh7IGludGVydmFsLCBjYWxsYmFjazogKCkgPT4gc2V0RmlyZUNvdW50KGkgPT4gKytpKSB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XG4gICAgICAgICAgICA8bGFiZWw+SW50ZXJ2YWwgZHVyYXRpb246IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e2ludGVydmFsfSBvbklucHV0PXtlID0+IHNldEludGVydmFsKGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5UaGUgY2FsbGJhY2sgaGFzIGJlZW4gY2FsbGVkIHtmaXJlQ291bnR9IHRpbWV7ZmlyZUNvdW50ID09PSAxID8gXCJcIiA6IFwic1wifS48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZU1lbW8gfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBtZW1vLCB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZUhhc0ZvY3VzLCB1c2VMaXN0TmF2aWdhdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25DaGlsZCwgVXNlTGlzdE5hdmlnYXRpb25DaGlsZEluZm8sIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcblxuXG5jb25zdCBSYW5kb21Xb3JkcyA9IFwiTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLlwiLnNwbGl0KFwiIFwiKTtcblxuY29uc3QgUm92aW5nQ2hpbGRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPEhUTUxMSUVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvPj4obnVsbCEpXG5leHBvcnQgY29uc3QgRGVtb1VzZVJvdmluZ1RhYkluZGV4ID0gbWVtbygoKSA9PiB7XG5cbiAgICBjb25zdCBbbGFzdEZvY3VzZWRJbm5lciwgc2V0TGFzdEZvY3VzZWRJbm5lciwgZ2V0TGFzdEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPEhUTUxVTGlzdEVsZW1lbnQ+KHsgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogc2V0TGFzdEZvY3VzZWRJbm5lciB9KTtcbiAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsIGN1cnJlbnRUeXBlYWhlYWQsIHRhYmJhYmxlSW5kZXgsIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsIG5hdmlnYXRlVG9JbmRleCB9ID0gdXNlTGlzdE5hdmlnYXRpb248SFRNTExJRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25DaGlsZEluZm8+KHsgc2hvdWxkRm9jdXNPbkNoYW5nZTogZ2V0TGFzdEZvY3VzZWRJbm5lciB9KTtcbiAgICAvL2NvbnN0IHsgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgdXNlUm92aW5nVGFiSW5kZXhQcm9wcyB9ID0gdXNlUm92aW5nVGFiSW5kZXg8SFRNTFVMaXN0RWxlbWVudCwgUm92aW5nVGFiSW5kZXhDaGlsZEluZm8+KHsgdGFiYmFibGVJbmRleCwgZm9jdXNPbkNoYW5nZTogZmFsc2UgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlbW9cIj5cbiAgICAgICAgICAgIDxoMj5LZXlib2FyZCAmYW1wOyBMaXN0IE5hdmlnYXRpb248L2gyPlxuICAgICAgICAgICAgPGgzPjxjb2RlPnVzZVJvdmluZ1RhYkluZGV4PC9jb2RlPjwvaDM+XG5cbiAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgIE5hdGl2ZSBIVE1MIGVsZW1lbnRzIG9mZmVyIGZhbnRhc3RpYyBrZXlib2FyZCBhY2Nlc3NhYmlsaXR5LCBidXQgY292ZXIgYSByZWxhdGl2ZWx5IGxpbWl0ZWQgbnVtYmVyIG9mIHVzZSBjYXNlcy5cbiAgICAgICAgICAgICAgICBUaGVyZSBpcyBubyBuYXRpdmUgSFRNTCB0cmVlIGVsZW1lbnQsIGZvciBleGFtcGxlLCB0aGF0IGFsbG93cyBrZXlib2FyZCBuYXZpZ2F0aW9uIG9mIGl0cyBpdGVtcyxcbiAgICAgICAgICAgICAgICBub3IgaXMgaXQgcG9zc2libGUgdG8gY29tYmluZSB0aGUga2V5Ym9hcmQgbmF2aWdhdGlvbiBiZWhhdmlvciBvZiBhIDxjb2RlPntcIjxzZWxlY3Q+XCJ9PC9jb2RlPiBtZW51IHdpdGggdGhlIG1lbnUgaW4gYSBkcmF3ZXIgY29tcG9uZW50LjwvcD5cblxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgV2hlbiBjb21pbmcgYWNyb3NzIGEgTGlzdCBvciBhIE1lbnUgb3IgYSBSYWRpb0dyb3VwIG9yIGEgVG9nZ2xlQnV0dG9uR3JvdXAgb3IgYW55IG90aGVyIFwib25lIGNvbXBvbmVudCBtYWRlIHVwIG9mIGNoaWxkIGNvbXBvbmVudHNcIiwgdGhlIHVzdWFsIGV4cGVjdGVkIGJlaGF2aW9yLFxuICAgICAgICAgICAgICAgIGF0IGxlYXN0IG5hdGl2ZWx5LCBpcyB0aGF0IHRhYmJpbmcgaW50byB0aGUgY29tcG9uZW50IGlzIG9uZSBhY3Rpb24sIGFuZCB0YWJiaW5nIG91dCBpcyBhbm90aGVyLiAgTmF2aWdhdGluZyA8ZW0+d2l0aGluPC9lbT4gdGhlIGNvbXBvbmVudCBpcyBkb25lIHdpdGggdGhlIGFycm93IGtleXMgb3Igb3RoZXIgbWV0aG9kcy5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgIFRoaXMgaXMgaW1wb3J0YW50IGJvdGggZm9yIGFjY2Vzc2FiaWxpdHksIGJ1dCBhbHNvIGp1c3QgZm9yIGdlbmVyYWwgdXNhYmlsaXR5LiAgV2hlbiB0YWJiaW5nIGJhY2sgYW5kIGZvcnRoLCB0aGUgYWJpbGl0eSB0byBza2lwIGEgbG9uZyBsaXN0IHdpdGhvdXQgbmVlZGluZyB0byB0cnVkZ2UgdGhyb3VnaCA8ZW0+ZXZlcnkgb25lPC9lbT4gb2YgaXRzIGNoaWxkIGVsZW1lbnRzIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQuXG4gICAgICAgICAgICA8L3A+XG5cbiAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgIDxjb2RlPnVzZUxpc3ROYXZpZ2F0aW9uPC9jb2RlPiB3cmFwcyB1cCB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhIGZldyBob29rcyAoPGNvZGU+dXNlUm92aW5nVGFiSW5kZXg8L2NvZGU+LCA8Y29kZT51c2VMaW5lYXJOYXZpZ2F0aW9uPC9jb2RlPiwgPGNvZGU+dXNlVHlwZWFoZWFkTmF2aWdhdGlvbjwvY29kZT5cbiAgICAgICAgICAgICAgICB0byBhbGxvdyBmb3IgQVJJQS1jb21wbGlhbnQgbmF2aWdhdGlvbiBvZiBsaXN0cyBhbmQgb3RoZXIgc2ltaWxhciBjb21wb25lbnRzLiAgRm9yIG1vcmUgYWR2YW5jZWQgdXNlIGNhc2VzLCB5b3UgY2FuIHVzZSB0aGUgb3RoZXIgaG9va3MgaW5kaXZpZHVhbGx5LlxuICAgICAgICAgICAgPC9wPlxuXG4gICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICA8Y29kZT51c2VMaXN0TmF2aWdhdGlvbjwvY29kZT4gKGFuZCA8Y29kZT51c2VSb3ZpbmdUYWJJbmRleDwvY29kZT4pIGludGVybmFsbHkgdXNlIDxjb2RlPnVzZUNoaWxkTWFuYWdlcjwvY29kZT4sIHdoaWNoIGlzIGhvdyB0aGUgY2hpbGQgZWxlbWVudHMgYW5kIHRoZSBwYXJlbnQgY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyLlxuICAgICAgICAgICAgICAgIFRoaXMgbWVhbnMgdGhlcmUgYXJlIHZpcnR1YWxseSBubyByZXN0cmljdGlvbnMgb24gaG93IHRoZSBET00gaXMgc2V0IHVwIGFzIGxvbmcgYXMgeW91IGNhbiBwcm92aWRlIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSA8Y29kZT51c2VMaXN0TmF2aWdhdGlvbkNoaWxkPC9jb2RlPiBob29rIHRoYXQncyByZXR1cm5lZCwgdXN1YWxseSB3aXRoIGEgc2ltcGxlIDxjb2RlPkNvbnRleHQ8L2NvZGU+LlxuICAgICAgICAgICAgICAgIElmIHRoZSBjaGlsZCBlbGVtZW50IGl0c2VsZiBoYXMgYSBmb2N1c2FibGUgZWxlbWVudCwgbGlrZSBhIGJ1dHRvbiwgaXQgY2FuIGFsc28gYmUgd2lyZWQgdXAgdG8gZGlzYWJsZSBpdHNlbGZcbiAgICAgICAgICAgICAgICBGZWVsIGZyZWUgdG8gbmVzdCB0aGVtIHRvbywgYXMgbG9uZyBhcyB5b3UgYXJlIGF3YXJlIG9mIHlvdXIgPGNvZGU+Q29udGV4dDwvY29kZT4gbWFuYWdlbWVudCAoaS5lLiByZW1lbWJlciB0aGF0IHlvdSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyA8Y29kZT5Db250ZXh0PC9jb2RlPiBmb3IgZWFjaCB1c2UgY2FzZSkuXG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8bGFiZWw+VGFiYmFibGUgaW5kZXg6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3RhYmJhYmxlSW5kZXggPz8gdW5kZWZpbmVkfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBuYXZpZ2F0ZVRvSW5kZXgoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpOyB9fSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8dWwgey4uLnVzZUhhc0ZvY3VzUHJvcHModXNlTGlzdE5hdmlnYXRpb25Qcm9wcyh7fSkpfT5cbiAgICAgICAgICAgICAgICA8Um92aW5nQ2hpbGRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VMaXN0TmF2aWdhdGlvbkNoaWxkfT5cbiAgICAgICAgICAgICAgICAgICAge0FycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb1VzZVJvdmluZ1RhYkluZGV4Q2hpbGQgaW5kZXg9e2l9IGtleT17aX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkoKSl9XG4gICAgICAgICAgICAgICAgPC9Sb3ZpbmdDaGlsZENvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAge2N1cnJlbnRUeXBlYWhlYWQgJiYgPGRpdj5UeXBlYWhlYWQ6IHtjdXJyZW50VHlwZWFoZWFkfTwvZGl2Pn1cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn0pXG5cbmNvbnN0IFByZWZpeCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIjtcbmNvbnN0IERlbW9Vc2VSb3ZpbmdUYWJJbmRleENoaWxkID0gbWVtbygoKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pID0+IHtcbiAgICBjb25zdCBbcmFuZG9tV29yZF0gPSB1c2VTdGF0ZSgoKSA9PiBSYW5kb21Xb3Jkc1tpbmRleC8qTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKFJhbmRvbVdvcmRzLmxlbmd0aCAtIDEpKSovXSk7XG4gICAgY29uc3QgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCA9IHVzZUNvbnRleHQoUm92aW5nQ2hpbGRDb250ZXh0KTtcbiAgICBjb25zdCB0ZXh0ID0gYCR7cmFuZG9tV29yZH0gVGhpcyBpcyBpdGVtICMke2luZGV4ICsgMX1gO1xuICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLCB1c2VMaXN0TmF2aWdhdGlvblNpYmxpbmdQcm9wcywgdGFiYmFibGUgfSA9IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQoeyBpbmRleCwgdGV4dCwgaGlkZGVuOiAoaW5kZXggPT0gNSkgfSk7XG4gICAgXG4gICAgY29uc3QgcHJvcHMgPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMoe30pO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxsaSB7Li4ucHJvcHN9Pnt0ZXh0fSAoe3RhYmJhYmxlPyBcIlRhYmJhYmxlXCIgOiBcIk5vdCB0YWJiYWJsZVwifSk8aW5wdXQgey4uLnVzZUxpc3ROYXZpZ2F0aW9uU2libGluZ1Byb3BzKHsgdHlwZTogXCJjaGVja2JveFwiIH0pfSAvPjwvbGk+XG4gICAgKVxufSkpOyIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVRpbWVvdXQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuXG5cbmV4cG9ydCBjb25zdCBEZW1vVXNlVGltZW91dCA9ICgpID0+IHtcbiAgICBjb25zdCBbdGltZW91dCwgc2V0VGltZW91dF0gPSB1c2VTdGF0ZSgxMDAwKTtcbiAgICBjb25zdCBbdHJpZ2dlckluZGV4LCBzZXRUcmlnZ2VySW5kZXhdID0gdXNlU3RhdGUoXCJcIik7XG5cbiAgICBjb25zdCBbZmlyZUNvdW50LCBzZXRGaXJlQ291bnRdID0gdXNlU3RhdGUoMCk7XG5cbiAgICB1c2VUaW1lb3V0KHsgdGltZW91dCwgdHJpZ2dlckluZGV4LCBjYWxsYmFjazogKCkgPT4gc2V0RmlyZUNvdW50KGkgPT4gKytpKSB9KVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzcz1cImRlbW9cIj5cbiAgICAgICAgICAgIDxsYWJlbD5UaW1lb3V0IGR1cmF0aW9uOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXt0aW1lb3V0fSBvbklucHV0PXtlID0+IHNldFRpbWVvdXQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8bGFiZWw+UmVmcmVzaCBrZXk6IDxpbnB1dCB0eXBlPVwidGV4dFwiIHZhbHVlPXt0cmlnZ2VySW5kZXh9IG9uSW5wdXQ9e2UgPT4gc2V0VHJpZ2dlckluZGV4KGUuY3VycmVudFRhcmdldC52YWx1ZSl9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXY+VGhlIGNhbGxiYWNrIGhhcyBiZWVuIGNhbGxlZCB7ZmlyZUNvdW50fSB0aW1le2ZpcmVDb3VudCA9PT0gMSA/IFwiXCIgOiBcInNcIn0uPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn1cbiIsIlxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgRnJhZ21lbnQsIGgsIHJlbmRlciwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VBbmltYXRpb25GcmFtZSwgdXNlRHJhZ2dhYmxlLCB1c2VEcm9wcGFibGUsIHVzZUVsZW1lbnRTaXplLCB1c2VGb2N1c1RyYXAsIHVzZUhhc0ZvY3VzLCB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IGZvcndhcmRSZWYsIG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VBcmlhQWNjb3JkaW9uLCBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbiB9IGZyb20gXCIuLi91c2UtYWNjb3JkaW9uXCI7XG5pbXBvcnQgeyB1c2VBcmlhQ2hlY2tib3ggfSBmcm9tIFwiLi4vdXNlLWNoZWNrYm94XCI7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwQ2hhbmdlRXZlbnQsIHVzZUNoZWNrYm94R3JvdXAsIFVzZUNoZWNrYm94R3JvdXBDaGlsZCwgVXNlQ2hlY2tib3hHcm91cENoaWxkSW5mbyB9IGZyb20gXCIuLi91c2UtY2hlY2tib3gtZ3JvdXBcIjtcbmltcG9ydCB7IHVzZUFyaWFEaWFsb2cgfSBmcm9tIFwiLi4vdXNlLWRpYWxvZ1wiO1xuaW1wb3J0IHsgdXNlQXJpYUxpc3Rib3hNdWx0aSwgVXNlTGlzdGJveE11bHRpSXRlbSwgVXNlTGlzdGJveE11bHRpSXRlbUluZm8sIFVzZUxpc3Rib3hNdWx0aUl0ZW1QYXJhbWV0ZXJzIH0gZnJvbSBcIi4uL3VzZS1saXN0Ym94LW11bHRpXCI7XG5pbXBvcnQgeyB1c2VBcmlhTGlzdGJveFNpbmdsZSwgVXNlTGlzdGJveFNpbmdsZUl0ZW0sIFVzZUxpc3Rib3hTaW5nbGVJdGVtSW5mbyB9IGZyb20gXCIuLi91c2UtbGlzdGJveC1zaW5nbGVcIjtcbmltcG9ydCB7IHVzZUFyaWFNZW51LCBVc2VNZW51Q2hpbGRJbmZvLCBVc2VNZW51SXRlbSB9IGZyb20gXCIuLi91c2UtbWVudVwiO1xuaW1wb3J0IHsgdXNlVGFibGUsIFVzZVRhYmxlUm93IH0gZnJvbSBcIi4uL3VzZS10YWJsZVwiO1xuaW1wb3J0IHsgdXNlQXJpYVRhYnMsIFVzZVRhYiwgVXNlVGFiSW5mbywgVXNlVGFiUGFuZWwgfSBmcm9tIFwiLi4vdXNlLXRhYnNcIjtcbmltcG9ydCB7IHVzZUFyaWFUb29sdGlwIH0gZnJvbSBcIi4uL3VzZS10b29sdGlwXCI7XG5pbXBvcnQgeyB1c2VBcmlhUmFkaW9Hcm91cCwgVXNlQXJpYVJhZGlvSW5mbywgVXNlUmFkaW8gfSBmcm9tIFwiLi4vdXNlLXJhZGlvLWdyb3VwXCJcbmltcG9ydCB7IERlbW9Vc2VJbnRlcnZhbCB9IGZyb20gXCIuL2RlbW9zL3VzZS1pbnRlcnZhbFwiO1xuaW1wb3J0IHsgRGVtb1VzZVJvdmluZ1RhYkluZGV4IH0gZnJvbSBcIi4vZGVtb3MvdXNlLXJvdmluZy10YWItaW5kZXhcIjtcbmltcG9ydCB7IERlbW9Vc2VUaW1lb3V0IH0gZnJvbSBcIi4vZGVtb3MvdXNlLXRpbWVvdXRcIjtcblxuY29uc3QgUmFuZG9tV29yZHMgPSBcIkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNjaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiBVdCBlbmltIGFkIG1pbmltIHZlbmlhbSwgcXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhIGNvbW1vZG8gY29uc2VxdWF0LiBEdWlzIGF1dGUgaXJ1cmUgZG9sb3IgaW4gcmVwcmVoZW5kZXJpdCBpbiB2b2x1cHRhdGUgdmVsaXQgZXNzZSBjaWxsdW0gZG9sb3JlIGV1IGZ1Z2lhdCBudWxsYSBwYXJpYXR1ci4gRXhjZXB0ZXVyIHNpbnQgb2NjYWVjYXQgY3VwaWRhdGF0IG5vbiBwcm9pZGVudCwgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3QgbGFib3J1bS5cIi5zcGxpdChcIiBcIik7XG5cbnR5cGUgRSA9IChFdmVudFRhcmdldCAmIEhUTUxJbnB1dEVsZW1lbnQpO1xudHlwZSBFMiA9IEVbXCJjbGFzc05hbWVcIl1cblxuXG5jb25zdCBEZW1vVXNlRHJvcHBhYmxlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZHJvcHBlZEZpbGVzLCBkcm9wcGVkU3RyaW5ncywgZmlsZXNGb3JDb25zaWRlcmF0aW9uLCBzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbiwgdXNlRHJvcHBhYmxlUHJvcHMsIGRyb3BFcnJvciB9ID0gdXNlRHJvcHBhYmxlPEhUTUxEaXZFbGVtZW50Pih7IGVmZmVjdDogXCJjb3B5XCIgfSk7XG5cbiAgICBjb25zdCB7IHJlZiB9ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgeyByZWY6IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsISkgfSlcblxuICAgIGNvbnN0IHAgPSB1c2VEcm9wcGFibGVQcm9wcyh7IGNsYXNzTmFtZTogXCJkZW1vIGRyb3BwYWJsZVwiIH0pO1xuXG4gICAgY29uc3QgciA9IHAucmVmO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiB7Li4ucH0+XG5cbiAgICAgICAgICAgIHtkcm9wcGVkU3RyaW5ncyAhPSBudWxsICYmIDxkaXY+RGF0YSBkcm9wcGVkOiA8dWw+eyhPYmplY3QuZW50cmllcyhkcm9wcGVkU3RyaW5ncykgYXMgW2tleW9mIHR5cGVvZiBzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbiwgc3RyaW5nXVtdKS5tYXAoKFt0eXBlLCB2YWx1ZV0pID0+IDxsaT57dHlwZX06IHt2YWx1ZX08L2xpPil9PC91bD48L2Rpdj59XG4gICAgICAgICAgICB7ZHJvcHBlZEZpbGVzICE9IG51bGwgJiYgPGRpdj5GaWxlcyBkcm9wcGVkOiA8dGFibGU+XG4gICAgICAgICAgICAgICAgPHRoZWFkPjx0cj48dGg+TmFtZTwvdGg+PHRoPlNpemU8L3RoPjx0aD5UeXBlPC90aD48dGg+TGFzdCBtb2RpZmllZDwvdGg+PC90cj48L3RoZWFkPlxuICAgICAgICAgICAgICAgIDx0Ym9keT57ZHJvcHBlZEZpbGVzLm1hcChmID0+IDx0cj48dGQ+e2YubmFtZX08L3RkPntmLmRhdGEuYnl0ZUxlbmd0aH08dGQ+e2YudHlwZX08L3RkPjx0ZD57bmV3IERhdGUoZi5sYXN0TW9kaWZpZWQgPz8gMCl9PC90ZD48L3RyPil9PC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+PC9kaXY+fVxuICAgICAgICAgICAgPGhyIC8+XG5cbiAgICAgICAgICAgIHtzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbiAhPSBudWxsICYmIDxkaXY+RGF0YSBiZWluZyBjb25zaWRlcmVkOiA8dWw+e0FycmF5LmZyb20oc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24pLm1hcCh0eXBlID0+IDxsaT57dHlwZX08L2xpPil9PC91bD48L2Rpdj59XG4gICAgICAgICAgICB7ZmlsZXNGb3JDb25zaWRlcmF0aW9uICE9IG51bGwgJiYgPGRpdj5GaWxlcyBiZWluZyBjb25zaWRlcmVkOiA8dWw+e2ZpbGVzRm9yQ29uc2lkZXJhdGlvbi5tYXAoZiA9PiA8bGk+e0pTT04uc3RyaW5naWZ5KGYpfTwvbGk+KX08L3VsPjwvZGl2Pn1cblxuICAgICAgICAgICAgPGhyIC8+XG4gICAgICAgICAgICB7ZHJvcEVycm9yICYmIDxkaXY+e2Ryb3BFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZHJvcEVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShkcm9wRXJyb3IpfTwvZGl2Pn1cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufVxuXG5jb25zdCBEZW1vVXNlRHJhZ2dhYmxlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgZHJhZ2dpbmcsIHVzZURyYWdnYWJsZVByb3BzLCBsYXN0RHJvcEVmZmVjdCwgZ2V0TGFzdERyb3BFZmZlY3QsIGdldERyYWdnaW5nIH0gPSB1c2VEcmFnZ2FibGU8SFRNTERpdkVsZW1lbnQ+KHsgZGF0YTogeyBcInRleHQvcGxhaW5cIjogXCJUaGlzIGlzIGN1c3RvbSBkcmFnZ2FibGUgY29udGVudCBvZiB0eXBlIHRleHQvcGxhaW4uXCIgfSB9KTtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiB7Li4udXNlRHJhZ2dhYmxlUHJvcHMoeyBjbGFzc05hbWU6IFwiZGVtb1wiIH0pfT5cbiAgICAgICAgICAgIERyYWdnYWJsZSBjb250ZW50XG4gICAgICAgIDwvZGl2Pilcbn1cblxuXG5jb25zdCBEZW1vVXNlRm9jdXNUcmFwID0gbWVtbygoeyBkZXB0aCB9OiB7IGRlcHRoPzogbnVtYmVyIH0pID0+IHtcblxuICAgIGNvbnN0IFthY3RpdmUsIHNldEFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCB7IHVzZUZvY3VzVHJhcFByb3BzIH0gPSB1c2VGb2N1c1RyYXA8SFRNTERpdkVsZW1lbnQ+KHsgdHJhcEFjdGl2ZTogYWN0aXZlIH0pO1xuXG4gICAgY29uc3QgZGl2UHJvcHMgPSB1c2VGb2N1c1RyYXBQcm9wcyh7IHJlZjogdW5kZWZpbmVkLCBjbGFzc05hbWU6IFwiZm9jdXMtdHJhcC1kZW1vXCIgfSk7XG4gICAgaWYgKGRlcHRoID09IDIpXG4gICAgICAgIHJldHVybiA8ZGl2IC8+O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZW1vXCI+XG4gICAgICAgICAgICA8bGFiZWw+QWN0aXZlOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17YWN0aXZlfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRBY3RpdmUoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpOyB9fSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IHsuLi5kaXZQcm9wc30gPlxuICAgICAgICAgICAgICAgIDxEZW1vVXNlRm9jdXNUcmFwQ2hpbGQgYWN0aXZlPXthY3RpdmV9IHNldEFjdGl2ZT17c2V0QWN0aXZlfSBkZXB0aD17ZGVwdGggPz8gMH0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufSk7XG5cblxuY29uc3QgRGVtb1VzZUZvY3VzVHJhcENoaWxkID0gbWVtbygoeyBzZXRBY3RpdmUsIGFjdGl2ZSwgZGVwdGggfTogeyBhY3RpdmU6IGJvb2xlYW4sIHNldEFjdGl2ZTogKGFjdGl2ZTogYm9vbGVhbikgPT4gdm9pZCwgZGVwdGg6IG51bWJlciB9KSA9PiB7XG5cblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8YnV0dG9uPkJ1dHRvbiAxPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uPkJ1dHRvbiAyPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uPkJ1dHRvbiAzPC9idXR0b24+XG4gICAgICAgICAgICA8bGFiZWw+QWN0aXZlOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17YWN0aXZlfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRBY3RpdmUoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpOyB9fSAvPjwvbGFiZWw+XG5cbiAgICAgICAgPC8+XG4gICAgKTtcbn0pO1xuXG5jb25zdCBVc2VBY2NvcmRpb25TZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQXJpYUFjY29yZGlvblNlY3Rpb248SFRNTEJ1dHRvbkVsZW1lbnQ+PihudWxsISk7XG5jb25zdCBEZW1vVXNlQWNjb3JkaW9uID0gbWVtbygoKSA9PiB7XG5cbiAgICBjb25zdCBbZXhwYW5kZWRJbmRleCwgc2V0RXhwYW5kZWRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPigwKTtcblxuICAgIGNvbnN0IHsgdXNlQXJpYUFjY29yZGlvblNlY3Rpb24gfSA9IHVzZUFyaWFBY2NvcmRpb248SFRNTERpdkVsZW1lbnQsIEhUTUxCdXR0b25FbGVtZW50Pih7IGV4cGFuZGVkSW5kZXgsIHNldEV4cGFuZGVkSW5kZXggfSlcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxVc2VBY2NvcmRpb25TZWN0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlQXJpYUFjY29yZGlvblNlY3Rpb259PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZW1vXCI+XG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXswfSAvPlxuICAgICAgICAgICAgICAgICAgICA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezF9IC8+XG4gICAgICAgICAgICAgICAgICAgIDxEZW1vQWNjb3JkaW9uU2VjdGlvbiBpbmRleD17Mn0gLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L1VzZUFjY29yZGlvblNlY3Rpb25Db250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn0pO1xuXG5jb25zdCBEZW1vQWNjb3JkaW9uU2VjdGlvbiA9IG1lbW8oKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pID0+IHtcblxuICAgIGNvbnN0IHVzZUFjY29yZGlvblNlY3Rpb24gPSB1c2VDb250ZXh0KFVzZUFjY29yZGlvblNlY3Rpb25Db250ZXh0KTtcbiAgICBjb25zdCB7IGV4cGFuZGVkLCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHksIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyIH0gPSB1c2VBY2NvcmRpb25TZWN0aW9uKHsgaW5kZXggfSk7XG5cbiAgICBjb25zdCB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzIH0gPSB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHk8SFRNTERpdkVsZW1lbnQ+KCk7XG4gICAgY29uc3QgeyB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzIH0gPSB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlcih7IHRhZzogXCJidXR0b25cIiB9KTtcblxuICAgIGNvbnN0IHAgPSB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyh7IGNsYXNzTmFtZTogXCJhY2NvcmRpb24tc2VjdGlvbi1ib2R5XCIsIGhpZGRlbjogIWV4cGFuZGVkIH0pO1xuICAgIHAuaWQ7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhY2NvcmRpb24tc2VjdGlvblwiPlxuICAgICAgICAgICAgPGJ1dHRvbiB7Li4udXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcyh7IGNsYXNzTmFtZTogXCJhY2NvcmRpb24tc2VjdGlvbi1oZWFkZXJcIiB9KX0+SGVhZGVyICN7aW5kZXggKyAxfTwvYnV0dG9uPlxuICAgICAgICAgICAgPGRpdiB7Li4ucH0+PHA+Qm9keSBjb250ZW50ICN7aW5kZXggKyAxfTwvcD48cD57UmFuZG9tV29yZHMuam9pbihcIiBcIil9PC9wPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApXG59KVxuXG5jb25zdCBEZW1vVXNlQ2hlY2tib3ggPSBtZW1vKCgpID0+IHtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlbW9cIj5cbiAgICAgICAgICAgICAgICA8Q2hlY2tib3gxIC8+XG4gICAgICAgICAgICAgICAgPENoZWNrYm94MiAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8RGVtb1VzZUNoZWNrYm94R3JvdXAgLz5cbiAgICAgICAgPC8+XG4gICAgKVxufSk7XG5cblxuXG5cbmNvbnN0IENoZWNrYm94MSA9IG1lbW8oKCkgPT4ge1xuXG4gICAgY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQgfSA9IHVzZUFyaWFDaGVja2JveDxIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50Pih7IGRpc2FibGVkOiBmYWxzZSwgY2hlY2tlZCwgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiLCBvbklucHV0OiBlID0+IHNldENoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCkgfSk7XG4gICAgY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveElucHV0RWxlbWVudCh7IHRhZzogXCJpbnB1dFwiIH0pO1xuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoeyB0YWc6IFwibGFiZWxcIiB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8aW5wdXQgey4uLnVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMoeyB0eXBlOiBcImNoZWNrYm94XCIsIH0pfSAvPlxuICAgICAgICAgICAgPGxhYmVsIHsuLi51c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzKHt9KX0+TGFiZWw8L2xhYmVsPlxuICAgICAgICA8L2Rpdj5cbiAgICApXG59KTtcblxuY29uc3QgQ2hlY2tib3gyID0gbWVtbygoKSA9PiB7XG5cbiAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCB7IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50LCB1c2VDaGVja2JveElucHV0RWxlbWVudCB9ID0gdXNlQXJpYUNoZWNrYm94PEhUTUxJbnB1dEVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQ+KHsgZGlzYWJsZWQ6IGZhbHNlLCBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIsIG9uSW5wdXQ6IGUgPT4gc2V0Q2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKSwgY2hlY2tlZCB9KTtcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KHsgdGFnOiBcImlucHV0XCIgfSk7XG4gICAgY29uc3QgeyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExhYmVsRWxlbWVudCh7IHRhZzogXCJsYWJlbFwiIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIDxsYWJlbCB7Li4udXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyh7fSl9PjxpbnB1dCB7Li4udXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyh7IHR5cGU6IFwiY2hlY2tib3hcIiB9KX0gLz4gTGFiZWw8L2xhYmVsPlxuICAgICAgICA8L2Rpdj5cbiAgICApXG59KTtcblxuXG5jb25zdCBDaGVja2JveEdyb3VwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQ2hlY2tib3hHcm91cENoaWxkPEhUTUxJbnB1dEVsZW1lbnQsIFVzZUNoZWNrYm94R3JvdXBDaGlsZEluZm8+PihudWxsISk7XG5cbmNvbnN0IERlbW9Vc2VDaGVja2JveEdyb3VwID0gbWVtbygoKSA9PiB7XG5cbiAgICBjb25zdCBvblVwZGF0ZUNoaWxkcmVuID0gKGV2ZW50OiBDaGVja2JveEdyb3VwQ2hhbmdlRXZlbnQ8aC5KU1guVGFyZ2V0ZWRFdmVudDxIVE1MSW5wdXRFbGVtZW50Pj4pOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudFtFdmVudERldGFpbF0uY2hpbGRyZW5DaGVja2VkO1xuICAgICAgICBsZXQgc2VsZWN0ZWRWYWx1ZXMgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7IC8qIERvIG5vdGhpbmcgKi8gfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMuYWRkKGkpO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuZ2V0KGkpID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzLmFkZChpKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgc2V0U2VsZWN0ZWRWYWx1ZXMoc2VsZWN0ZWRWYWx1ZXMpO1xuICAgIH07XG5cblxuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0Rm9jdXNlZElubmVyIH0gPSB1c2VIYXNGb2N1czxIVE1MRGl2RWxlbWVudD4oe30pXG4gICAgY29uc3QgeyB1c2VDaGVja2JveEdyb3VwUGFyZW50UHJvcHM6IHVzZUNoZWNrYm94R3JvdXBDaGVja2JveFByb3BzLCB1c2VDaGVja2JveEdyb3VwQ2hpbGQsIHBhcmVudElzQ2hlY2tlZDogc2VsZklzQ2hlY2tlZCwgcGFyZW50UGVyY2VudENoZWNrZWQ6IHBlcmNlbnRDaGVja2VkLCBvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dDogb25DaGVja2JveEdyb3VwSW5wdXQgfSA9IHVzZUNoZWNrYm94R3JvdXA8SFRNTElucHV0RWxlbWVudCwgVXNlQ2hlY2tib3hHcm91cENoaWxkSW5mbz4oeyBzaG91bGRGb2N1c09uQ2hhbmdlOiBnZXRGb2N1c2VkSW5uZXIsIG9uVXBkYXRlQ2hpbGRyZW4gfSk7XG4gICAgY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQgfSA9IHVzZUFyaWFDaGVja2JveDxIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50Pih7IGNoZWNrZWQ6IHNlbGZJc0NoZWNrZWQsIGRpc2FibGVkOiBmYWxzZSwgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiLCBvbklucHV0OiBvbkNoZWNrYm94R3JvdXBJbnB1dCBhcyBhbnkgfSk7XG5cbiAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KHsgdGFnOiBcImlucHV0XCIgfSk7XG4gICAgY29uc3QgeyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExhYmVsRWxlbWVudCh7IHRhZzogXCJsYWJlbFwiIH0pO1xuICAgIGNvbnN0IFtzZWxlY3RlZFZhbHVlcywgc2V0U2VsZWN0ZWRWYWx1ZXNdID0gdXNlU3RhdGU8U2V0PG51bWJlcj4+KG5ldyBTZXQoKSk7XG5cblxuICAgIHJldHVybiA8ZGl2IGNsYXNzPVwiZGVtb1wiPlxuICAgICAgICA8Q2hlY2tib3hHcm91cENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUNoZWNrYm94R3JvdXBDaGlsZH0+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxpbnB1dCB7Li4udXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyh1c2VDaGVja2JveEdyb3VwQ2hlY2tib3hQcm9wcyh7fSkpfSAvPlxuICAgICAgICAgICAgICAgIDxsYWJlbCB7Li4udXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyh7fSl9PkFsbCBjaGVja2VkPzwvbGFiZWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgey4uLnVzZUhhc0ZvY3VzUHJvcHMoeyBzdHlsZTogeyBcImRpc3BsYXlcIjogXCJmbGV4XCIsIFwiZmxleERpcmVjdGlvblwiOiBcImNvbHVtblwiIH0gfSl9ID5cblxuICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldFNlbGVjdGVkMihzZWxlY3RlZDogYm9vbGVhbikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRWYWx1ZXMoc2VsZWN0ZWRWYWx1ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5ldyBTZXQoc2VsZWN0ZWRWYWx1ZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiAhbmV4dC5oYXMoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQuYWRkKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNlbGVjdGVkICYmIG5leHQuaGFzKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LmRlbGV0ZShpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkVmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxEZW1vVXNlQ2hlY2tib3hHcm91cENoaWxkIGtleT17aX0gaW5kZXg9e2l9IGNoZWNrZWQ9eyEhc2VsZWN0ZWRWYWx1ZXMuaGFzKGkpfSBzZXRDaGVja2VkPXtzZXRTZWxlY3RlZDJ9IC8+XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L0NoZWNrYm94R3JvdXBDb250ZXh0LlByb3ZpZGVyPlxuICAgIDwvZGl2PlxufSk7XG5cblxuY29uc3QgRGVtb1VzZUNoZWNrYm94R3JvdXBDaGlsZCA9IG1lbW8oKHsgaW5kZXgsIGNoZWNrZWQsIHNldENoZWNrZWQgfTogeyBpbmRleDogbnVtYmVyLCBjaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiLCBzZXRDaGVja2VkKHNlbGVjdGVkOiBib29sZWFuIHwgXCJtaXhlZFwiKTogdm9pZCB9KSA9PiB7XG4gICAgY29uc3QgeyByYW5kb21JZCB9ID0gdXNlUmFuZG9tSWQoKTtcbiAgICBjb25zdCB1c2VDaGVja2JveEdyb3VwQ2hpbGQgPSB1c2VDb250ZXh0KENoZWNrYm94R3JvdXBDb250ZXh0KTtcbiAgICBsZXQgdGV4dCA9IGBOdW1iZXIgJHtpbmRleCArIDF9IGNoZWNrYm94ICR7Y2hlY2tlZCA/IFwiKGNoZWNrZWQpXCIgOiBcIlwifWA7XG4gICAgY29uc3QgeyB0YWJiYWJsZSwgdXNlQ2hlY2tib3hHcm91cENoaWxkUHJvcHMgfSA9IHVzZUNoZWNrYm94R3JvdXBDaGlsZCh7IGluZGV4LCB0ZXh0LCBjaGVja2VkLCBpZDogcmFuZG9tSWQgfSk7XG4gICAgdGV4dCA9IGBOdW1iZXIgJHtpbmRleCArIDF9IGNoZWNrYm94ICR7Y2hlY2tlZCA/IFwiKGNoZWNrZWQpXCIgOiBcIlwifSAke3RhYmJhYmxlID8gXCIodGFiYmJsZSlcIiA6IFwiXCJ9YDtcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExhYmVsRWxlbWVudCB9ID0gdXNlQXJpYUNoZWNrYm94PEhUTUxJbnB1dEVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQ+KHsgY2hlY2tlZCwgZGlzYWJsZWQ6IGZhbHNlLCBsYWJlbFBvc2l0aW9uOiBcInNlcGFyYXRlXCIsIG9uSW5wdXQ6IGUgPT4geyBzZXRDaGVja2VkKGVbRXZlbnREZXRhaWxdLmNoZWNrZWQpOyB9IH0pO1xuXG4gICAgY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveElucHV0RWxlbWVudCh7IHRhZzogXCJpbnB1dFwiIH0pO1xuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoeyB0YWc6IFwibGFiZWxcIiB9KTtcblxuICAgIHJldHVybiAoPGRpdj5cbiAgICAgICAgPGlucHV0IHsuLi51c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKHVzZUNoZWNrYm94R3JvdXBDaGlsZFByb3BzKHt9KSl9IC8+XG4gICAgICAgIDxsYWJlbCB7Li4udXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyh7fSl9Pnt0ZXh0fTwvbGFiZWw+XG4gICAgPC9kaXY+XG4gICAgKTtcbn0pO1xuXG5cbmNvbnN0IERlbW9Vc2VEaWFsb2cgPSBtZW1vKCgpID0+IHtcbiAgICBjb25zdCBvbkNsb3NlID0gKCgpID0+IHNldE9wZW4oZmFsc2UpKTtcbiAgICBjb25zdCBbb3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCB7IHVzZURpYWxvZ0JhY2tkcm9wLCB1c2VEaWFsb2dCb2R5LCB1c2VEaWFsb2dQcm9wcywgdXNlRGlhbG9nVGl0bGUgfSA9IHVzZUFyaWFEaWFsb2c8SFRNTERpdkVsZW1lbnQ+KHsgb3Blbiwgb25DbG9zZSB9KTtcbiAgICBjb25zdCB7IHVzZURpYWxvZ0JhY2tkcm9wUHJvcHMgfSA9IHVzZURpYWxvZ0JhY2tkcm9wPEhUTUxEaXZFbGVtZW50PigpO1xuICAgIGNvbnN0IHsgdXNlRGlhbG9nQm9keVByb3BzIH0gPSB1c2VEaWFsb2dCb2R5KHsgZGVzY3JpcHRpdmU6IHRydWUgfSk7XG4gICAgY29uc3QgeyB1c2VEaWFsb2dUaXRsZVByb3BzIH0gPSB1c2VEaWFsb2dUaXRsZSgpO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XG4gICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ9e29wZW59IG9uSW5wdXQ9e2UgPT4geyBlLnByZXZlbnREZWZhdWx0KCk7IHNldE9wZW4oZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpIH19IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgey4uLnVzZURpYWxvZ0JhY2tkcm9wUHJvcHMoeyBoaWRkZW46ICFvcGVuIH0pfT5cbiAgICAgICAgICAgICAgICA8ZGl2IHsuLi51c2VEaWFsb2dQcm9wcyh7fSl9PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHsuLi51c2VEaWFsb2dUaXRsZVByb3BzKHt9KX0+RGlhbG9nIFRpdGxlPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgey4uLnVzZURpYWxvZ0JvZHlQcm9wcyh7fSl9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHAgdGFiSW5kZXg9ey0xfT5EaWFsb2cgYm9keSBjb250ZW50PC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHA+e1JhbmRvbVdvcmRzLmpvaW4oXCIgXCIpfTwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwPntSYW5kb21Xb3Jkcy5qb2luKFwiIFwiKX08L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cD57UmFuZG9tV29yZHMuam9pbihcIiBcIil9PC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHA+PGJ1dHRvbiBvbkNsaWNrPXtvbkNsb3NlfT5DbG9zZTwvYnV0dG9uPjwvcD5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufSk7XG5cbmNvbnN0IFJhZGlvV3JhcENvbnRleHQgPSBjcmVhdGVDb250ZXh0KGZhbHNlKTtcbmNvbnN0IFJhZGlvQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlUmFkaW88bnVtYmVyLCBIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50LCBVc2VBcmlhUmFkaW9JbmZvPj4obnVsbCEpO1xuY29uc3QgRGVtb1VzZVJhZGlvR3JvdXAgPSBtZW1vKCgpID0+IHtcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZSgwKTtcbiAgICBjb25zdCBbd3JhcCwgc2V0V3JhcF0gPSB1c2VTdGF0ZSh1c2VDb250ZXh0KFJhZGlvV3JhcENvbnRleHQpKTtcbiAgICBjb25zdCB7IHVzZVJhZGlvLCB1c2VSYWRpb0dyb3VwUHJvcHMsIGFueVJhZGlvc0ZvY3VzZWQgfSA9IHVzZUFyaWFSYWRpb0dyb3VwPG51bWJlciwgSFRNTERpdkVsZW1lbnQsIEhUTUxJbnB1dEVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQsIFVzZUFyaWFSYWRpb0luZm8+KHtcbiAgICAgICAgbmFtZTogXCJyYWRpby1kZW1vLTFcIixcbiAgICAgICAgb25JbnB1dDogKGUpID0+IHNldFNlbGVjdGVkSW5kZXgoK2VbRXZlbnREZXRhaWxdLnNlbGVjdGVkVmFsdWUpLFxuICAgICAgICBzZWxlY3RlZFZhbHVlOiBzZWxlY3RlZEluZGV4XG4gICAgfSk7XG5cblxuICAgIHJldHVybiA8ZGl2IGNsYXNzPVwiZGVtb1wiPlxuICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ9e3dyYXB9IG9uSW5wdXQ9e2UgPT4gc2V0V3JhcCh3ID0+ICF3KX0gLz4gV3JhcHBlciBsYWJlbDwvbGFiZWw+XG4gICAgICAgIDxSYWRpb1dyYXBDb250ZXh0LlByb3ZpZGVyIGtleT17d3JhcH0gdmFsdWU9e3dyYXB9PlxuICAgICAgICAgICAge2FueVJhZGlvc0ZvY3VzZWQudG9TdHJpbmcoKX1cbiAgICAgICAgICAgIDxSYWRpb0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVJhZGlvfT5cbiAgICAgICAgICAgICAgICA8ZGl2IHsuLi51c2VSYWRpb0dyb3VwUHJvcHMoe30pfT5cbiAgICAgICAgICAgICAgICAgICAge0FycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb1JhZGlvIGtleT17aX0gaW5kZXg9e2l9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9SYWRpb0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgIDwvUmFkaW9XcmFwQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8L2Rpdj5cbn0pO1xuXG5cblxuY29uc3QgRGVtb1JhZGlvID0gbWVtbygoeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkgPT4ge1xuICAgIGNvbnN0IHdyYXAgPSB1c2VDb250ZXh0KFJhZGlvV3JhcENvbnRleHQpO1xuICAgIGNvbnN0IHsgdXNlUmFkaW9JbnB1dCwgdXNlUmFkaW9MYWJlbCwgY2hlY2tlZCwgdGFiYmFibGUgfSA9IHVzZUNvbnRleHQoUmFkaW9Db250ZXh0KSh7IGluZGV4LCB0ZXh0OiBudWxsLCB2YWx1ZTogaW5kZXgsIGRpc2FibGVkOiBmYWxzZSwgbGFiZWxQb3NpdGlvbjogd3JhcCA/IFwid3JhcHBpbmdcIiA6IFwic2VwYXJhdGVcIiB9KTtcbiAgICBjb25zdCB7IHVzZVJhZGlvSW5wdXRQcm9wcyB9ID0gdXNlUmFkaW9JbnB1dCh7IHRhZzogXCJpbnB1dFwiIH0pO1xuICAgIGNvbnN0IHsgdXNlUmFkaW9MYWJlbFByb3BzIH0gPSB1c2VSYWRpb0xhYmVsKHsgdGFnOiBcImxhYmVsXCIgfSk7XG4gICAgaWYgKHdyYXApXG4gICAgICAgIHJldHVybiA8bGFiZWwgey4uLnVzZVJhZGlvTGFiZWxQcm9wcyh7fSl9PjxpbnB1dCB7Li4udXNlUmFkaW9JbnB1dFByb3BzKHt9KX0gLz5OdW1iZXIge2luZGV4ICsgMX0gcmFkaW97Y2hlY2tlZCA/IFwiIChjaGVja2VkKVwiIDogXCJcIn17dGFiYmFibGUgPyBcIiAodGFiYmFibGUpXCIgOiBcIlwifTwvbGFiZWw+O1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDxkaXY+PGlucHV0IHsuLi51c2VSYWRpb0lucHV0UHJvcHMoe30pfSAvPk51bWJlciB7aW5kZXggKyAxfSByYWRpb3tjaGVja2VkID8gXCIgKGNoZWNrZWQpXCIgOiBcIlwifXt0YWJiYWJsZSA/IFwiICh0YWJiYWJsZSlcIiA6IFwiXCJ9PGxhYmVsIHsuLi51c2VSYWRpb0xhYmVsUHJvcHMoe30pfT48L2xhYmVsPjwvZGl2Pjtcbn0pO1xuXG5cbmNvbnN0IExpc3RCb3hTaW5nbGVJdGVtQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTGlzdGJveFNpbmdsZUl0ZW08SFRNTExJRWxlbWVudCwgVXNlTGlzdGJveFNpbmdsZUl0ZW1JbmZvPEhUTUxMSUVsZW1lbnQ+Pj4obnVsbCEpO1xuY29uc3QgRGVtb1VzZUxpc3Rib3hTaW5nbGUgPSBtZW1vKCgpID0+IHtcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZSgwKTtcbiAgICBjb25zdCB7IHVzZUxpc3Rib3hTaW5nbGVJdGVtLCB1c2VMaXN0Ym94U2luZ2xlTGFiZWwsIHVzZUxpc3Rib3hTaW5nbGVQcm9wcyB9ID0gdXNlQXJpYUxpc3Rib3hTaW5nbGU8SFRNTFVMaXN0RWxlbWVudCwgSFRNTExJRWxlbWVudCwgVXNlTGlzdGJveFNpbmdsZUl0ZW1JbmZvPEhUTUxMSUVsZW1lbnQ+Pih7IHNlbGVjdGVkSW5kZXgsIG9uU2VsZWN0OiBlID0+IHNldFNlbGVjdGVkSW5kZXgoZVtFdmVudERldGFpbF0uc2VsZWN0ZWRJbmRleCksIHNlbGVjdGlvbk1vZGU6IFwiYWN0aXZhdGVcIiB9KTtcblxuXG4gICAgcmV0dXJuIDxkaXYgY2xhc3M9XCJkZW1vXCI+XG4gICAgICAgIDxMaXN0Qm94U2luZ2xlSXRlbUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUxpc3Rib3hTaW5nbGVJdGVtfT5cbiAgICAgICAgICAgIDx1bCB7Li4udXNlTGlzdGJveFNpbmdsZVByb3BzKHt9KX0+XG4gICAgICAgICAgICAgICAge0FycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9MaXN0Ym94U2luZ2xlT3B0aW9uIGtleT17aX0gaW5kZXg9e2l9IC8+XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpKX1cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvTGlzdEJveFNpbmdsZUl0ZW1Db250ZXh0LlByb3ZpZGVyPlxuICAgIDwvZGl2PlxufSk7XG5cblxuXG5jb25zdCBEZW1vTGlzdGJveFNpbmdsZU9wdGlvbiA9IG1lbW8oKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyLCB9KSA9PiB7XG4gICAgY29uc3QgeyBnZXRTZWxlY3RlZCwgc2VsZWN0ZWQsIHRhYmJhYmxlLCB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzIH0gPSB1c2VDb250ZXh0KExpc3RCb3hTaW5nbGVJdGVtQ29udGV4dCkoeyBpbmRleCwgdGV4dDogbnVsbCwgdGFnOiBcImxpXCIgfSk7XG4gICAgcmV0dXJuIDxsaSB7Li4udXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyh7fSl9Pk51bWJlciB7aW5kZXggKyAxfSBvcHRpb257c2VsZWN0ZWQgPyBcIiAoc2VsZWN0ZWQpXCIgOiBcIlwifXt0YWJiYWJsZSA/IFwiICh0YWJiYWJsZSlcIiA6IFwiXCJ9PC9saT5cbn0pO1xuXG5cblxuXG5cbmNvbnN0IExpc3RCb3hNdWx0aUl0ZW1Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VMaXN0Ym94TXVsdGlJdGVtPEhUTUxMSUVsZW1lbnQsIFVzZUxpc3Rib3hNdWx0aUl0ZW1JbmZvPEhUTUxMSUVsZW1lbnQ+Pj4obnVsbCEpO1xuY29uc3QgRGVtb1VzZUxpc3Rib3hNdWx0aSA9IG1lbW8oKCkgPT4ge1xuXG4gICAgY29uc3QgeyB1c2VMaXN0Ym94TXVsdGlJdGVtLCB1c2VMaXN0Ym94TXVsdGlMYWJlbCwgdXNlTGlzdGJveE11bHRpUHJvcHMsIGN1cnJlbnRUeXBlYWhlYWQgfSA9IHVzZUFyaWFMaXN0Ym94TXVsdGk8SFRNTFVMaXN0RWxlbWVudCwgSFRNTExJRWxlbWVudCwgVXNlTGlzdGJveE11bHRpSXRlbUluZm88SFRNTExJRWxlbWVudD4+KHt9KTtcblxuICAgIGNvbnN0IFtzZWxlY3RlZFZhbHVlcywgc2V0U2VsZWN0ZWRWYWx1ZXNdID0gdXNlU3RhdGU8U2V0PG51bWJlcj4+KG5ldyBTZXQoKSk7XG5cblxuICAgIHJldHVybiA8ZGl2IGNsYXNzPVwiZGVtb1wiPlxuICAgICAgICA8TGlzdEJveE11bHRpSXRlbUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUxpc3Rib3hNdWx0aUl0ZW19PlxuICAgICAgICAgICAgPHVsIHsuLi51c2VMaXN0Ym94TXVsdGlQcm9wcyh7fSl9PlxuICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldFNlbGVjdGVkMihzZWxlY3RlZDogYm9vbGVhbikge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWRWYWx1ZXMoc2VsZWN0ZWRWYWx1ZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5ldyBTZXQoc2VsZWN0ZWRWYWx1ZXMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiAhbmV4dC5oYXMoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQuYWRkKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNlbGVjdGVkICYmIG5leHQuaGFzKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0LmRlbGV0ZShpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkVmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxEZW1vTGlzdGJveE11bHRpT3B0aW9uIGtleT17aX0gaW5kZXg9e2l9IHNlbGVjdGVkPXshIXNlbGVjdGVkVmFsdWVzLmhhcyhpKX0gc2V0U2VsZWN0ZWQ9e3NldFNlbGVjdGVkMn0gLz5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCkpfVxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIHtjdXJyZW50VHlwZWFoZWFkICE9IG51bGwgJiYgPHA+e2N1cnJlbnRUeXBlYWhlYWR9PC9wPn1cbiAgICAgICAgPC9MaXN0Qm94TXVsdGlJdGVtQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8L2Rpdj5cbn0pO1xuXG5jb25zdCBNZW51SXRlbUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZU1lbnVJdGVtPEhUTUxMSUVsZW1lbnQsIFVzZU1lbnVDaGlsZEluZm8+PihudWxsISk7XG5jb25zdCBEZW1vTGlzdGJveE11bHRpT3B0aW9uID0gbWVtbygoeyBpbmRleCwgc2VsZWN0ZWQsIHNldFNlbGVjdGVkIH06IHsgaW5kZXg6IG51bWJlciwgc2VsZWN0ZWQ6IGJvb2xlYW4sIHNldFNlbGVjdGVkKHNlbGVjdGVkOiBib29sZWFuKTogdm9pZCB9KSA9PiB7XG4gICAgbGV0IHRleHQgPSBgTnVtYmVyICR7aW5kZXggKyAxfSBvcHRpb24ke3NlbGVjdGVkID8gXCIgKHNlbGVjdGVkKVwiIDogXCJcIn1gO1xuICAgIGNvbnN0IHsgdGFiYmFibGUsIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcyB9ID0gdXNlQ29udGV4dChMaXN0Qm94TXVsdGlJdGVtQ29udGV4dCkoeyB0YWc6IFwibGlcIiwgaW5kZXgsIHRleHQsIG9uU2VsZWN0OiBlID0+IHNldFNlbGVjdGVkKGVbRXZlbnREZXRhaWxdLnNlbGVjdGVkKSwgc2VsZWN0ZWQgfSk7XG4gICAgdGV4dCA9IGBOdW1iZXIgJHtpbmRleCArIDF9IG9wdGlvbiR7c2VsZWN0ZWQgPyBcIiAoc2VsZWN0ZWQpXCIgOiBcIlwifSR7dGFiYmFibGUgPyBcIiAodGFiYmFibGUpXCIgOiBcIlwifWA7XG4gICAgcmV0dXJuIDxsaSB7Li4udXNlTGlzdGJveE11bHRpSXRlbVByb3BzKHt9KX0+e3RleHR9PC9saT5cbn0pO1xuXG5jb25zdCBEZW1vTWVudSA9IG1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4gc2V0T3BlbihmYWxzZSk7XG4gICAgY29uc3Qgb25PcGVuID0gKCkgPT4gc2V0T3Blbih0cnVlKTtcbiAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGdldEZvY3VzZWRJbm5lcjogZ2V0TWVudUZvY3VzZWRJbm5lciB9ID0gdXNlSGFzRm9jdXM8SFRNTFVMaXN0RWxlbWVudD4oe30pXG5cbiAgICBjb25zdCB7IHVzZU1lbnVCdXR0b24sIHVzZU1lbnVJdGVtLCB1c2VNZW51UHJvcHMgfSA9IHVzZUFyaWFNZW51PEhUTUxVTGlzdEVsZW1lbnQsIEhUTUxMSUVsZW1lbnQsIFVzZU1lbnVDaGlsZEluZm8+KHsgb3Blbiwgb25DbG9zZSwgb25PcGVuLCBzaG91bGRGb2N1c09uQ2hhbmdlOiBnZXRNZW51Rm9jdXNlZElubmVyIH0pO1xuXG4gICAgY29uc3QgeyB1c2VNZW51QnV0dG9uUHJvcHMgfSA9IHVzZU1lbnVCdXR0b248SFRNTEJ1dHRvbkVsZW1lbnQ+KHsgdGFnOiBcImJ1dHRvblwiIH0pXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzcz1cImRlbW9cIj5cbiAgICAgICAgICAgIDxNZW51SXRlbUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZU1lbnVJdGVtfT5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHsuLi51c2VNZW51QnV0dG9uUHJvcHMoeyBvbkNsaWNrOiBlID0+IHNldE9wZW4ob3BlbiA9PiAhb3BlbikgfSl9Pk9wZW4gbWVudTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDx1bCB7Li4udXNlTWVudVByb3BzKHVzZUhhc0ZvY3VzUHJvcHMoe30pKX0gaGlkZGVuPXshb3Blbn0+XG4gICAgICAgICAgICAgICAgICAgIDxEZW1vTWVudUl0ZW0gaW5kZXg9ezB9IC8+XG4gICAgICAgICAgICAgICAgICAgIDxEZW1vTWVudUl0ZW0gaW5kZXg9ezF9IC8+XG4gICAgICAgICAgICAgICAgICAgIDxEZW1vTWVudUl0ZW0gaW5kZXg9ezJ9IC8+XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDwvTWVudUl0ZW1Db250ZXh0LlByb3ZpZGVyPlxuXG4gICAgICAgIDwvZGl2PlxuICAgIClcbn0pO1xuXG5jb25zdCBEZW1vTWVudUl0ZW0gPSBtZW1vKCh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSA9PiB7XG4gICAgY29uc3QgdXNlQXJpYU1lbnVJdGVtID0gdXNlQ29udGV4dChNZW51SXRlbUNvbnRleHQpO1xuICAgIGNvbnN0IHsgdXNlTWVudUl0ZW1Qcm9wcyB9ID0gdXNlQXJpYU1lbnVJdGVtKHsgaW5kZXgsIHRleHQ6IG51bGwgfSk7XG4gICAgcmV0dXJuIDxsaSB7Li4udXNlTWVudUl0ZW1Qcm9wcyh7fSl9Pkl0ZW0ge2luZGV4ICsgMX08L2xpPlxufSlcblxuY29uc3QgVGFiQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVGFiPEhUTUxMSUVsZW1lbnQsIFVzZVRhYkluZm8+PihudWxsISk7XG5jb25zdCBUYWJQYW5lbENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRhYlBhbmVsPEhUTUxQYXJhZ3JhcGhFbGVtZW50Pj4obnVsbCEpO1xuY29uc3QgRGVtb1RhYnMgPSBtZW1vKCgpID0+IHtcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZSgwKTtcbiAgICBjb25zdCBbc2VsZWN0aW9uTW9kZSwgc2V0U2VsZWN0aW9uTW9kZV0gPSB1c2VTdGF0ZTxcImZvY3VzXCIgfCBcImFjdGl2YXRlXCI+KFwiZm9jdXNcIik7XG5cbiAgICBjb25zdCB7IHVzZVRhYlBhbmVsLCB1c2VUYWJzTGFiZWwsIHVzZVRhYiwgdXNlVGFic0xpc3QgfSA9IHVzZUFyaWFUYWJzPEhUTUxVTGlzdEVsZW1lbnQsIEhUTUxMSUVsZW1lbnQsIEhUTUxQYXJhZ3JhcGhFbGVtZW50Pih7IG9uU2VsZWN0OiBlID0+IHNldFNlbGVjdGVkSW5kZXgoZVtFdmVudERldGFpbF0uc2VsZWN0ZWRJbmRleCksIHNlbGVjdGVkSW5kZXgsIHNlbGVjdGlvbk1vZGUsIG9yaWVudGF0aW9uOiBcImJsb2NrXCIgfSk7XG5cbiAgICBjb25zdCB7IHVzZVRhYkxpc3RQcm9wcyB9ID0gdXNlVGFic0xpc3QoKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxUYWJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJ9ID5cbiAgICAgICAgICAgIDxUYWJQYW5lbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVRhYlBhbmVsfSA+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRlbW9cIj5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtzZWxlY3Rpb25Nb2RlID09IFwiZm9jdXNcIn0gb25JbnB1dD17KGUpID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRTZWxlY3Rpb25Nb2RlKGUuY3VycmVudFRhcmdldC5jaGVja2VkID8gXCJmb2N1c1wiIDogXCJhY3RpdmF0ZVwiKSB9fSAvPiBBY3RpdmF0ZSBvbiBmb2N1cz88L2xhYmVsPlxuXG4gICAgICAgICAgICAgICAgICAgIDx1bCB7Li4udXNlVGFiTGlzdFByb3BzKHt9KX0+PERlbW9UYWIgaW5kZXg9ezB9IC8+PERlbW9UYWIgaW5kZXg9ezF9IC8+PERlbW9UYWIgaW5kZXg9ezJ9IC8+PERlbW9UYWIgaW5kZXg9ezN9IC8+PERlbW9UYWIgaW5kZXg9ezR9IC8+PC91bD5cbiAgICAgICAgICAgICAgICAgICAgPGRpdj48RGVtb1RhYlBhbmVsIGluZGV4PXswfSAvPjxEZW1vVGFiUGFuZWwgaW5kZXg9ezF9IC8+PERlbW9UYWJQYW5lbCBpbmRleD17Mn0gLz48RGVtb1RhYlBhbmVsIGluZGV4PXszfSAvPjxEZW1vVGFiUGFuZWwgaW5kZXg9ezR9IC8+PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L1RhYlBhbmVsQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9UYWJDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn0pO1xuXG5jb25zdCBEZW1vVGFiID0gbWVtbygoeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkgPT4ge1xuICAgIGNvbnN0IHVzZVRhYiA9IHVzZUNvbnRleHQoVGFiQ29udGV4dCk7XG4gICAgY29uc3QgeyB1c2VUYWJQcm9wcywgc2VsZWN0ZWQgfSA9IHVzZVRhYih7IGluZGV4LCB0ZXh0OiBudWxsLCB0YWc6IFwibGlcIiB9KVxuXG4gICAgcmV0dXJuICg8PlxuICAgICAgICA8bGkgey4uLnVzZVRhYlByb3BzKHt9KX0+VGFiICN7aW5kZXggKyAxfSAoe2BTZWxlY3RlZDogJHtzZWxlY3RlZH1gfSk8L2xpPlxuICAgIDwvPilcbn0pO1xuXG5jb25zdCBEZW1vVGFiUGFuZWwgPSBtZW1vKCh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSA9PiB7XG4gICAgY29uc3QgdXNlVGFiUGFuZWwgPSB1c2VDb250ZXh0KFRhYlBhbmVsQ29udGV4dCk7XG4gICAgY29uc3QgeyB1c2VUYWJQYW5lbFByb3BzLCB2aXNpYmxlIH0gPSB1c2VUYWJQYW5lbCh7IGluZGV4IH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IHsuLi51c2VUYWJQYW5lbFByb3BzKHsgaGlkZGVuOiAhdmlzaWJsZSB9KX0+XG4gICAgICAgICAgICA8cD5UYWIgcGFuZWwgY29udGVudCAje2luZGV4ICsgMX0gKHtgU2VsZWN0ZWQ6ICR7dmlzaWJsZX1gfSkuPC9wPlxuICAgICAgICAgICAgPHA+e1JhbmRvbVdvcmRzLnNsaWNlKDAsIE1hdGguZmxvb3IoUmFuZG9tV29yZHMubGVuZ3RoIC8gKGluZGV4ICsgMSkpKS5qb2luKFwiIFwiKX08L3A+XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn0pO1xuXG5jb25zdCBEZW1vVG9vbHRpcCA9IG1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHsgdXNlVG9vbHRpcCwgdXNlVG9vbHRpcFRyaWdnZXIsIGlzT3BlbiB9ID0gdXNlQXJpYVRvb2x0aXAoe30pO1xuICAgIGNvbnN0IHsgdXNlVG9vbHRpcFByb3BzIH0gPSB1c2VUb29sdGlwPEhUTUxTcGFuRWxlbWVudD4oKTtcbiAgICBjb25zdCB7IHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMgfSA9IHVzZVRvb2x0aXBUcmlnZ2VyPEhUTUxTcGFuRWxlbWVudD4oKTtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZGVtb1wiPlxuICAgICAgICAgICAgPHA+VGhpcyBpcyBhIHBhcmFncmFwaCB3aXRoIGEgPHNwYW4gey4uLnVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMoe30pfT50b29sdGlwIHJpZ2h0IGhlcmUuPC9zcGFuPjxzcGFuIHsuLi51c2VUb29sdGlwUHJvcHMoeyBoaWRkZW46ICFpc09wZW4gfSl9PlRoaXMgaXMgdGhlIHRvb2x0aXAgY29udGVudC48L3NwYW4+PC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICApXG59KTtcblxuLypcbmNvbnN0IERlbW9UYWJsZSA9IG1lbW8oKCkgPT4ge1xuXG4gICAgY29uc3QgeyB1c2VUYWJsZUJvZHksIHVzZVRhYmxlRm9vdCwgdXNlVGFibGVIZWFkLCB1c2VUYWJsZVByb3BzLCB1c2VUYWJsZVJvdyB9ID0gdXNlVGFibGU8XG4gICAgICAgIEhUTUxUYWJsZUVsZW1lbnQsIEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50LCBIVE1MVGFibGVTZWN0aW9uRWxlbWVudCwgSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQsIEhUTUxUYWJsZVJvd0VsZW1lbnQsIEhUTUxUYWJsZUNlbGxFbGVtZW50LCBIVE1MVGFibGVDZWxsRWxlbWVudD4oe30pO1xuXG4gICAgY29uc3QgeyB1c2VUYWJsZUhlYWRQcm9wcyB9ID0gdXNlVGFibGVIZWFkKHt9KTtcbiAgICBjb25zdCB7IHVzZVRhYmxlQm9keVByb3BzIH0gPSB1c2VUYWJsZUJvZHkoe30pO1xuXG4gICAgY29uc3Qgcm93czogVk5vZGU8YW55PltdID0gQXJyYXkuZnJvbShmdW5jdGlvbiogKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyArK2kpIHtcbiAgICAgICAgICAgIHlpZWxkIDxUYWJsZVJvdyByb3dJbmRleD17aSArIDF9IC8+O1xuICAgICAgICB9XG4gICAgfSgpKTtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFRhYmxlUm93Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFibGVSb3d9PlxuICAgICAgICAgICAgPHRhYmxlIHsuLi51c2VUYWJsZVByb3BzKHt9KX0+XG4gICAgICAgICAgICAgICAgPHRoZWFkIHsuLi51c2VUYWJsZUhlYWRQcm9wcyh7IGNoaWxkcmVuOiBbPFRhYmxlSGVhZGVyUm93IHJvd0luZGV4PXswfSAvPl0gfSl9IC8+XG4gICAgICAgICAgICAgICAgPHRib2R5IHsuLi51c2VUYWJsZUJvZHlQcm9wcyh7IGNoaWxkcmVuOiByb3dzIH0pfSAvPlxuICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgPC9UYWJsZVJvd0NvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxuXG59KTtcblxuY29uc3QgVGFibGVSb3dDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWJsZVJvdzxIVE1MVGFibGVSb3dFbGVtZW50LCBIVE1MVGFibGVDZWxsRWxlbWVudCwgSFRNTFRhYmxlQ2VsbEVsZW1lbnQ+PihudWxsISk7XG5cblxuY29uc3QgVGFibGVSb3cgPSBtZW1vKGZ1bmN0aW9uIFRhYmxlUm93KHsgcm93SW5kZXggfTogeyByb3dJbmRleDogbnVtYmVyIH0pIHtcbiAgICBjb25zdCBpID0gcm93SW5kZXggLSAxO1xuICAgIGNvbnN0IHVzZVRhYmxlUm93ID0gdXNlQ29udGV4dChUYWJsZVJvd0NvbnRleHQpO1xuICAgIGNvbnN0IHsgcm93SW5kZXhBc1NvcnRlZCwgcm93SW5kZXhBc1Vuc29ydGVkLCB1c2VUYWJsZUNlbGwsIHVzZVRhYmxlUm93UHJvcHMgfSA9IHVzZVRhYmxlUm93KHsgcm93SW5kZXgsIGxvY2F0aW9uOiBcImJvZHlcIiB9KTtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLCBuZXcgRGF0ZSgpLmdldE1vbnRoKCksIChpICogNykgKiogMik7XG5cbiAgICBjb25zdCB7IHVzZVRhYmxlQ2VsbFByb3BzOiB1c2VUYWJsZUNlbGxQcm9wczEsIHVzZVRhYmxlQ2VsbERlbGVnYXRlUHJvcHM6IHVzZVRhYmxlQ2VsbERlbGVnYXRlUHJvcHMxIH0gPSB1c2VUYWJsZUNlbGwoeyBjb2x1bW5JbmRleDogMCwgdmFsdWU6IGkgfSk7XG4gICAgY29uc3QgeyB1c2VUYWJsZUNlbGxQcm9wczogdXNlVGFibGVDZWxsUHJvcHMyLCB1c2VUYWJsZUNlbGxEZWxlZ2F0ZVByb3BzOiB1c2VUYWJsZUNlbGxEZWxlZ2F0ZVByb3BzMiB9ID0gdXNlVGFibGVDZWxsKHsgY29sdW1uSW5kZXg6IDEsIHZhbHVlOiBSYW5kb21Xb3Jkc1tpXSB9KTtcbiAgICBjb25zdCB7IHVzZVRhYmxlQ2VsbFByb3BzOiB1c2VUYWJsZUNlbGxQcm9wczMsIHVzZVRhYmxlQ2VsbERlbGVnYXRlUHJvcHM6IHVzZVRhYmxlQ2VsbERlbGVnYXRlUHJvcHMzIH0gPSB1c2VUYWJsZUNlbGwoeyBjb2x1bW5JbmRleDogMiwgdmFsdWU6IGRhdGUgfSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPHRyIHsuLi51c2VUYWJsZVJvd1Byb3BzKHsgXCJkYXRhLWluZGV4XCI6IHJvd0luZGV4IH0gYXMge30pfT5cbiAgICAgICAgICAgIDx0ZCB7Li4udXNlVGFibGVDZWxsUHJvcHMxKHVzZVRhYmxlQ2VsbERlbGVnYXRlUHJvcHMxKHt9KSl9PntpfTwvdGQ+XG4gICAgICAgICAgICA8dGQgey4uLnVzZVRhYmxlQ2VsbFByb3BzMih1c2VUYWJsZUNlbGxEZWxlZ2F0ZVByb3BzMih7fSkpfT57UmFuZG9tV29yZHNbaV19PC90ZD5cbiAgICAgICAgICAgIDx0ZCB7Li4udXNlVGFibGVDZWxsUHJvcHMzKHVzZVRhYmxlQ2VsbERlbGVnYXRlUHJvcHMzKHt9KSl9PntkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygpfTwvdGQ+XG4gICAgICAgIDwvdHI+XG4gICAgKVxufSlcblxuXG5jb25zdCBUYWJsZUhlYWRlclJvdyA9IG1lbW8oZnVuY3Rpb24gVGFibGVIZWFkZXJSb3coeyByb3dJbmRleCB9OiB7IHJvd0luZGV4OiBudW1iZXIgfSkge1xuICAgIGNvbnN0IHVzZVRhYmxlUm93ID0gdXNlQ29udGV4dChUYWJsZVJvd0NvbnRleHQpO1xuICAgIGNvbnN0IHsgdXNlVGFibGVIZWFkQ2VsbCwgdXNlVGFibGVSb3dQcm9wczogdXNlVGFibGVIZWFkUm93UHJvcHMgfSA9IHVzZVRhYmxlUm93KHsgcm93SW5kZXgsIGxvY2F0aW9uOiBcImhlYWRcIiB9KTtcbiAgICBjb25zdCB7IHVzZVRhYmxlSGVhZENlbGxQcm9wczogdXNlVGFibGVIZWFkQ2VsbFByb3BzMSwgdXNlVGFibGVIZWFkQ2VsbERlbGVnYXRlUHJvcHM6IHVzZVRhYmxlSGVhZENlbGxEZWxlZ2F0ZVByb3BzMSwgc29ydERpcmVjdGlvbjogc29ydERpcmVjdGlvbjEgfSA9IHVzZVRhYmxlSGVhZENlbGwoeyB0YWc6IFwidGhcIiwgY29sdW1uSW5kZXg6IDAgfSk7XG4gICAgY29uc3QgeyB1c2VUYWJsZUhlYWRDZWxsUHJvcHM6IHVzZVRhYmxlSGVhZENlbGxQcm9wczIsIHVzZVRhYmxlSGVhZENlbGxEZWxlZ2F0ZVByb3BzOiB1c2VUYWJsZUhlYWRDZWxsRGVsZWdhdGVQcm9wczIsIHNvcnREaXJlY3Rpb246IHNvcnREaXJlY3Rpb24yIH0gPSB1c2VUYWJsZUhlYWRDZWxsKHsgdGFnOiBcInRoXCIsIGNvbHVtbkluZGV4OiAxIH0pO1xuICAgIGNvbnN0IHsgdXNlVGFibGVIZWFkQ2VsbFByb3BzOiB1c2VUYWJsZUhlYWRDZWxsUHJvcHMzLCB1c2VUYWJsZUhlYWRDZWxsRGVsZWdhdGVQcm9wczogdXNlVGFibGVIZWFkQ2VsbERlbGVnYXRlUHJvcHMzLCBzb3J0RGlyZWN0aW9uOiBzb3J0RGlyZWN0aW9uMyB9ID0gdXNlVGFibGVIZWFkQ2VsbCh7IHRhZzogXCJ0aFwiLCBjb2x1bW5JbmRleDogMiB9KTtcblxuXG4gICAgcmV0dXJuICg8dHIgey4uLnVzZVRhYmxlSGVhZFJvd1Byb3BzKHsgXCJkYXRhLWluZGV4XCI6IHJvd0luZGV4IH0gYXMge30pfT5cbiAgICAgICAgPHRoIHsuLi51c2VUYWJsZUhlYWRDZWxsUHJvcHMxKHVzZVRhYmxlSGVhZENlbGxEZWxlZ2F0ZVByb3BzMSh7fSkpfT5OdW1iZXIge3NvcnREaXJlY3Rpb24xfTwvdGg+XG4gICAgICAgIDx0aCB7Li4udXNlVGFibGVIZWFkQ2VsbFByb3BzMih1c2VUYWJsZUhlYWRDZWxsRGVsZWdhdGVQcm9wczIoe30pKX0+U3RyaW5nIHtzb3J0RGlyZWN0aW9uMn08L3RoPlxuICAgICAgICA8dGggey4uLnVzZVRhYmxlSGVhZENlbGxQcm9wczModXNlVGFibGVIZWFkQ2VsbERlbGVnYXRlUHJvcHMzKHt9KSl9PkRhdGUge3NvcnREaXJlY3Rpb24zfTwvdGg+XG4gICAgPC90cj4pXG59KSovXG5cbmNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gPGRpdiBjbGFzcz1cImZsZXhcIiBzdHlsZT17eyBmbGV4V3JhcDogXCJ3cmFwXCIgfX0+XG4gICAgICAgIDxEZW1vVG9vbHRpcCAvPlxuICAgICAgICB7Lyo8RGVtb1RhYmxlIC8+Ki99XG4gICAgICAgIDxEZW1vVGFicyAvPlxuICAgICAgICA8RGVtb1VzZVRpbWVvdXQgLz5cbiAgICAgICAgPERlbW9Vc2VJbnRlcnZhbCAvPlxuICAgICAgICA8RGVtb01lbnUgLz5cbiAgICAgICAgPERlbW9Vc2VMaXN0Ym94U2luZ2xlIC8+XG4gICAgICAgIDxEZW1vVXNlTGlzdGJveE11bHRpIC8+XG4gICAgICAgIDxEZW1vVXNlQ2hlY2tib3ggLz5cbiAgICAgICAgPERlbW9Vc2VSYWRpb0dyb3VwIC8+XG4gICAgICAgIDxEZW1vVXNlQWNjb3JkaW9uIC8+XG4gICAgICAgIDxEZW1vVXNlRGlhbG9nIC8+XG4gICAgICAgIDxEZW1vVXNlUm92aW5nVGFiSW5kZXggLz5cblxuXG4gICAgICAgIDxEZW1vVXNlRm9jdXNUcmFwIC8+XG4gICAgICAgIDxEZW1vVXNlRHJvcHBhYmxlIC8+XG4gICAgICAgIDxEZW1vVXNlRHJhZ2dhYmxlIC8+XG4gICAgICAgIDxpbnB1dCAvPlxuICAgIDwvZGl2PlxufVxuXG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHJlbmRlcig8Q29tcG9uZW50IC8+LCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJvb3RcIikhKTtcbn0pXG4iXSwibmFtZXMiOlsidm5vZGVJZCIsInJlcmVuZGVyUXVldWUiLCJFTVBUWV9BUlIiLCJ0b1ZhbCIsIm1peCIsImsiLCJ5Iiwic3RyIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwiaSIsInRtcCIsIngiLCJhcmd1bWVudHMiLCJnZXREb2N1bWVudCIsImVsZW1lbnQiLCJvd25lckRvY3VtZW50IiwiZG9jdW1lbnQiLCJ3aW5kb3ciLCJnbG9iYWxUaGlzIiwidXNlRW5zdXJlU3RhYmlsaXR5IiwicGFyZW50SG9va05hbWUiLCJ2YWx1ZXMiLCJ1c2VIZWxwZXIiLCJmb3JFYWNoIiwidmFsdWUiLCJpbmRleCIsImhlbHBlclRvRW5zdXJlU3RhYmlsaXR5IiwidXNlUmVmIiwic2hvd25FcnJvciIsImN1cnJlbnQiLCJ1c2VQYXNzaXZlU3RhdGUiLCJvbkNoYW5nZSIsImdldEluaXRpYWxWYWx1ZSIsInZhbHVlUmVmIiwiVW5zZXQiLCJjbGVhbnVwQ2FsbGJhY2tSZWYiLCJ1bmRlZmluZWQiLCJvblNob3VsZENsZWFuVXAiLCJ1c2VDYWxsYmFjayIsImNsZWFudXBDYWxsYmFjayIsInRyeUVuc3VyZVZhbHVlIiwiaW5pdGlhbFZhbHVlIiwiZXgiLCJnZXRWYWx1ZSIsIndhcm5pbmdSZWYiLCJjb25zb2xlIiwid2FybiIsInVzZU1lcmdlZENoaWxkcmVuIiwibGhzUHJvcHMiLCJyaHNQcm9wcyIsImNoaWxkcmVuIiwicmhzIiwibGhzIiwicmV0IiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwidXNlTWVyZ2VkQ2xhc3NlcyIsIm1lcmdlQ2xhc3NlcyIsInByb2Nlc3NSZWYiLCJpbnN0YW5jZSIsInJlZiIsImFzc2VydCIsInVzZU1lcmdlZFJlZnMiLCJjb21iaW5lZCIsInN0eWxlU3RyaW5nVG9PYmplY3QiLCJzdHlsZSIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwic3BsaXQiLCJtYXAiLCJzdGF0ZW1lbnQiLCJ1c2VNZXJnZWRTdHlsZXMiLCJsb2ciLCJ1c2VNZXJnZWRQcm9wcyIsImxoc0FsbCIsInJoc0FsbCIsIl9saHNDaGlsZHJlbiIsImNsYXNzIiwiX2xoc0NsYXNzIiwiY2xhc3NOYW1lIiwiX2xoc0NsYXNzTmFtZSIsIl9saHNTdHlsZSIsIl9saHNSZWYiLCJsaHNNaXNjIiwiX3Joc0NoaWxkcmVuIiwiX3Joc0NsYXNzIiwiX3Joc0NsYXNzTmFtZSIsIl9yaHNTdHlsZSIsIl9yaHNSZWYiLCJyaHNNaXNjIiwiZW50cmllcyIsInJoc0tleSIsInJoc0VudHJpZXMiLCJsaHNWYWx1ZSIsInJoc1ZhbHVlIiwibWVyZ2VkIiwibWVyZ2VGdW5jdGlvbnMiLCJyZXR1cm5OdWxsIiwidXNlUmVmRWxlbWVudCIsImFyZ3MiLCJvbkVsZW1lbnRDaGFuZ2UiLCJvbk1vdW50Iiwib25Vbm1vdW50IiwiaGFuZGxlciIsImUiLCJwcmV2VmFsdWUiLCJ1c2VMb2dpY2FsRGlyZWN0aW9uIiwib25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlIiwiZ2V0Q29tcHV0ZWRTdHlsZXMiLCJzZXRDb21wdXRlZFN0eWxlcyIsImdldEVsZW1lbnQiLCJ1c2VSZWZFbGVtZW50UHJvcHMiLCJnZXRDb21wdXRlZFN0eWxlIiwidXNlRWxlbWVudFNpemVQcm9wcyIsInVzZUVsZW1lbnRTaXplIiwib25TaXplQ2hhbmdlIiwiXyIsImdldExvZ2ljYWxEaXJlY3Rpb25JbmZvIiwiY29tcHV0ZWRTdHlsZXMiLCJ3Iiwid3JpdGluZ01vZGUiLCJkIiwiZGlyZWN0aW9uIiwidCIsInRleHRPcmllbnRhdGlvbiIsIldyaXRpbmdNb2RlcyIsImNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbiIsImVsZW1lbnRPcmllbnRhdGlvbiIsImNvbnZlcnRUb1BoeXNpY2FsU2lkZSIsInNpZGUiLCJNIiwiYmxvY2tEaXJlY3Rpb24iLCJpbmxpbmVEaXJlY3Rpb24iLCJpbmxpbmVPcmllbnRhdGlvbiIsImNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb24iLCJibG9ja09yaWVudGF0aW9uIiwiY29udmVydEVsZW1lbnRTaXplIiwiZWxlbWVudFNpemUiLCJpbmxpbmVTaXplIiwiYmxvY2tTaXplIiwiY2FwaXRhbGl6ZSIsImNsaWVudEJsb2NrU2l6ZSIsIm9mZnNldElubGluZVNpemUiLCJvZmZzZXRCbG9ja1NpemUiLCJzY3JvbGxJbmxpbmVTaXplIiwic2Nyb2xsQmxvY2tTaXplIiwiZjEiLCJnZXRQaHlzaWNhbExlZnRUb3AiLCJmMiIsImdldFBoeXNpY2FsUmlnaHRCb3R0b20iLCJmMyIsImY0IiwiY2xpZW50SW5saW5lSW5zZXQiLCJzY3JvbGxJbmxpbmVJbnNldCIsIm9mZnNldElubGluZUluc2V0Iiwic2Nyb2xsQmxvY2tJbnNldCIsIm9mZnNldEJsb2NrSW5zZXQiLCJjbGllbnRCbG9ja0luc2V0IiwicHJvcHMiLCJkaXIiLCJiIiwibCIsInIiLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInN0YXRlIiwic2V0U3RhdGVQIiwidXNlU3RhdGVQIiwic2V0U3RhdGUiLCJjYWxsYmFjayIsIm5leHRWYWx1ZSIsIlRhYmxlIiwiYmFzZTY0IiwicmFuZG9tNkJpdHMiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJ1c2VSYW5kb21JZCIsInByZWZpeCIsInNldFJhbmRvbUlkIiwiZ2VuZXJhdGVSYW5kb21JZCIsIl93YXRjaFByZWZpeFVwZGF0ZXMiLCJzZXRXYXRjaFByZWZpeFVwZGF0ZXMiLCJnZXRXYXRjaFByZWZpeFVwZGF0ZXMiLCJ3YXRjaFByZWZpeFVwZGF0ZXMiLCJwcmV2aW91c0lucHV0cyIsIk1hcCIsInRvUnVuIiwib3JpZ2luYWxDb21taXQiLCJvcHRpb25zIiwiY29tbWl0TmFtZSIsIm5ld0NvbW1pdCIsImlkIiwiZWZmZWN0SW5mbyIsIm9sZElucHV0cyIsImdldCIsImFyZ3NDaGFuZ2VkIiwiaW5wdXRzIiwiY2xlYW51cCIsImVmZmVjdCIsInNldCIsInVzZUVmZmVjdCIsImRlbGV0ZSIsIlN5bWJvbCIsInVzZVN0YWJsZUdldHRlciIsInVzZUJlZm9yZUxheW91dEVmZmVjdCIsIkVycm9yIiwiZm4iLCJjdXJyZW50Q2FsbGJhY2tHZXR0ZXIiLCJpbXBsIiwidXNlRWZmZWN0TmF0aXZlIiwicHJldklucHV0cyIsImVmZmVjdDIiLCJjaGFuZ2VzIiwibWF4IiwiZnJvbSIsInRvIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0TmF0aXZlIiwidXNlVGltZW91dCIsInRpbWVvdXQiLCJ0cmlnZ2VySW5kZXgiLCJzdGFibGVDYWxsYmFjayIsInVzZVN0YWJsZUNhbGxiYWNrIiwic3RhcnRUaW1lUmVmIiwiZ2V0VGltZW91dCIsInRpbWVvdXRJc051bGwiLCJ1c2VMaW5lYXJOYXZpZ2F0aW9uIiwibmF2aWdhdGVUb0ZpcnN0IiwibmF2aWdhdGVUb0xhc3QiLCJuYXZpZ2F0ZVRvTmV4dCIsIm5hdmlnYXRlVG9QcmV2IiwibWFuYWdlZENoaWxkcmVuIiwibmF2aWdhdGlvbkRpcmVjdGlvbiIsImRpc2FibGVBcnJvd0tleXMiLCJkaXNhYmxlSG9tZUVuZEtleXMiLCJjaGlsZENvdW50IiwidXNlTG9naWNhbERpcmVjdGlvblByb3BzIiwib25LZXlEb3duIiwiY3RybEtleSIsIm1ldGFLZXkiLCJpbmZvIiwiYWxsb3dzQmxvY2tOYXZpZ2F0aW9uIiwiYWxsb3dzSW5saW5lTmF2aWdhdGlvbiIsImtleSIsInByb3BOYW1lIiwiZGlyZWN0aW9uQWxsb3dlZCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwidXNlVHlwZWFoZWFkTmF2aWdhdGlvbiIsImNvbGxhdG9yIiwiZ2V0SW5kZXgiLCJ0eXBlYWhlYWRUaW1lb3V0Iiwic2V0SW5kZXgiLCJnZXRDdXJyZW50VHlwZWFoZWFkIiwic2V0Q3VycmVudFR5cGVhaGVhZCIsImN1cnJlbnRUeXBlYWhlYWQiLCJpbnZhbGlkVHlwZWFoZWFkIiwic2V0SW52YWxpZFR5cGVhaGVhZCIsImdldEltZUFjdGl2ZSIsIm5leHRUeXBlYWhlYWRDaGFyIiwic2V0TmV4dFR5cGVhaGVhZENoYXIiLCJ0eXBlYWhlYWQiLCJjb21wYXJhdG9yU2hhcmVkIiwic2FmZUxocyIsInNhZmVSaHMiLCJjb21wYXJlIiwibm9ybWFsaXplIiwidG9Mb3dlckNhc2UiLCJsb2NhbGVDb21wYXJlIiwiaW5zZXJ0aW5nQ29tcGFyYXRvciIsInRleHQiLCJ0eXBlYWhlYWRDb21wYXJhdG9yIiwib25Db21wb3NpdGlvblN0YXJ0IiwiX2UiLCJzZXRJbWVBY3RpdmUiLCJvbkNvbXBvc2l0aW9uRW5kIiwiZGF0YSIsImltZUFjdGl2ZSIsIl9jaGlsZFVwZGF0ZUluZGV4Iiwic2V0Q2hpbGRVcGRhdGVJbmRleCIsInRvdGFsQ2hpbGRyZW5Nb3VudGVkIiwiZ2V0VG90YWxDaGlsZHJlbk1vdW50ZWQiLCJ0b3RhbENoaWxkcmVuVW5vdW50ZWQiLCJzZXRUb3RhbENoaWxkcmVuVW5vdW50ZWQiLCJfZ2V0VG90YWxDaGlsZHJlblVub3VudGVkIiwiY2hpbGRyZW5DdXJyZW50bHlNb3VudGVkIiwibW91bnRlZENoaWxkcmVuIiwibW91bnRPcmRlciIsImluZGljZXNCeUVsZW1lbnQiLCJkZWxldGVkSW5kaWNlcyIsIlNldCIsIm92ZXJtb3VudENvdW50IiwiZ2V0TW91bnRJbmRleCIsImMiLCJhZGQiLCJzZXRUb3RhbENoaWxkcmVuTW91bnRlZCIsInVzZVJvdmluZ1RhYkluZGV4Iiwic2hvdWxkRm9jdXNPbkNoYW5nZSIsImZvYyIsInRhYmJhYmxlSW5kZXgiLCJnZXRTaG91bGRGb2N1c09uQ2hhbmdlIiwidXNlTWFuYWdlZENoaWxkIiwicmVzdCIsInVzZUNoaWxkTWFuYWdlciIsImFjdGl2YXRlZEluZGV4IiwidGFiYmFibGUiLCJzZXRUYWJiYWJsZSIsImdldENoaWxkRmxhZyIsImdldFRhYmJhYmxlIiwicnJhZkluZGV4Iiwic2V0UnJhZkluZGV4IiwicmVyZW5kZXJBbmRGb2N1cyIsIm5ld0luZm8iLCJjcmVhdGVDb250ZXh0IiwidXNlRHJhZ2dhYmxlIiwiZWZmZWN0QWxsb3dlZCIsImRyYWdJbWFnZSIsImRyYWdJbWFnZVhPZmZzZXQiLCJkcmFnSW1hZ2VZT2Zmc2V0IiwiY29uc3RydWN0b3IiLCJmaWxlTmFtZSIsImJhc2UiLCJtZXNzYWdlIiwiZXJyb3JUeXBlIiwibmFtZSIsImZpbGVzRm9yQ29uc2lkZXJhdGlvbiIsInNldEZpbGVzRm9yQ29uc2lkZXJhdGlvbiIsInNldFN0cmluZ3NGb3JDb25zaWRlcmF0aW9uIiwiZHJvcHBlZEZpbGVzIiwic2V0RHJvcHBlZEZpbGVzIiwiZHJvcHBlZFN0cmluZ3MiLCJzZXREcm9wcGVkU3RyaW5ncyIsInNldERyb3BFcnJvciIsImRyb3BQcm9taXNlc1JlZiIsInNldEN1cnJlbnRQcm9taXNlSW5kZXgiLCJnZXRDdXJyZW50UHJvbWlzZUluZGV4Iiwic2V0UHJvbWlzZUNvdW50IiwiZ2V0UHJvbWlzZUNvdW50IiwiY3VycmVudFByb21pc2VJbmRleCIsInByb21pc2VDb3VudCIsImN1cnJlbnRQcm9taXNlIiwidGhlbiIsImZpbGVzIiwic3RyaW5ncyIsInVzZURyb3BwYWJsZVByb3BzIiwicCIsIm9uRHJhZ0VudGVyIiwiZGF0YVRyYW5zZmVyIiwiZHJvcEVmZmVjdCIsIm5ld01pbWVUeXBlcyIsIm5ld0ZpbGVzIiwiYWN0aXZlRWxlbWVudFVwZGF0ZXJzIiwibGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyIsIndpbmRvd3NGb2N1c2VkVXBkYXRlcnMiLCJmb3JFYWNoVXBkYXRlciIsIm90aGVyV2luZG93IiwidXBkYXRlcnMiLCJ1cGRhdGVyIiwiZm9jdXNvdXQiLCJ0YXJnZXQiLCJkZWZhdWx0VmlldyIsInJlbGF0ZWRUYXJnZXQiLCJmb2N1c2luIiwiY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQiLCJ3aW5kb3dGb2N1cyIsInVzZUludGVydmFsIiwiaW50ZXJ2YWwiLCJnZXRJbnRlcnZhbCIsImxhc3REZWxheVVzZWQiLCJjYW5kaWRhdGVTZWxlY3RvcnMiLCJjYW5kaWRhdGVTZWxlY3RvciIsIm1hdGNoZXMiLCJOb0VsZW1lbnQiLCJFbGVtZW50IiwiZ2V0Q2FuZGlkYXRlcyIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwicHJvdG90eXBlIiwiaW5jbHVkZUNvbnRhaW5lciIsImNhbmRpZGF0ZXMiLCJ1bnNoaWZ0IiwiZWwiLCJnZXRSb290Tm9kZSIsImlzSW5wdXQiLCJub2RlIiwiaXNIaWRkZW5JbnB1dCIsInJhZGlvU2V0IiwiZXNjYXBlIiwidGFnTmFtZSIsInNsaWNlIiwiYXBwbHkiLCJzb21lIiwiY2hpbGQiLCJpc1plcm9BcmVhIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJ2aXNpYmlsaXR5IiwiaXNEaXJlY3RTdW1tYXJ5IiwiY2FsbCIsIm5vZGVVbmRlckRldGFpbHMiLCJwYXJlbnRFbGVtZW50Iiwibm9kZVJvb3RIb3N0IiwiaG9zdCIsIm5vZGVJc0F0dGFjaGVkIiwiY29udGFpbnMiLCJkaXNwbGF5Q2hlY2siLCJnZXRTaGFkb3dSb290Iiwicm9vdE5vZGUiLCJzaGFkb3dSb290IiwiYXNzaWduZWRTbG90Iiwib3JpZ2luYWxOb2RlIiwiaXNEaXNhYmxlZEZyb21GaWVsZHNldCIsInBhcmVudE5vZGUiLCJpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUiLCJkaXNhYmxlZCIsIml0ZW0iLCJ0YWJJbmRleCIsImlzSGlkZGVuIiwiaXNTY29wZSIsImlzRGV0YWlsc1dpdGhTdW1tYXJ5IiwiY2FuZGlkYXRlVGFiaW5kZXgiLCJyZWd1bGFyVGFiYmFibGVzIiwiZG9jdW1lbnRPcmRlciIsImdsb2JhbCIsImZhY3RvcnkiLCJ0aGlzIiwiX2NyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsYXNzQ2FsbENoZWNrIiwiVHlwZUVycm9yIiwiX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nIiwiam9pbiIsIkluZXJ0Um9vdCIsInJvb3RFbGVtZW50IiwiaW5lcnRNYW5hZ2VyIiwiX2luZXJ0TWFuYWdlciIsIl9yb290RWxlbWVudCIsIl9tYW5hZ2VkTm9kZXMiLCJoYXNBdHRyaWJ1dGUiLCJfc2F2ZWRBcmlhSGlkZGVuIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUiLCJfb2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwiX29uTXV0YXRpb24iLCJiaW5kIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZXMiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiZGVzdHJ1Y3RvciIsImRpc2Nvbm5lY3QiLCJyZW1vdmVBdHRyaWJ1dGUiLCJpbmVydE5vZGUiLCJfdW5tYW5hZ2VOb2RlIiwic3RhcnROb2RlIiwiX3RoaXMyIiwiY29tcG9zZWRUcmVlV2FsayIsIl92aXNpdE5vZGUiLCJhY3RpdmVFbGVtZW50IiwiYm9keSIsInJvb3QiLCJub2RlVHlwZSIsIk5vZGUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiYmx1ciIsImZvY3VzIiwiRUxFTUVOVF9OT0RFIiwiX2Fkb3B0SW5lcnRSb290IiwiX21hbmFnZU5vZGUiLCJyZWdpc3RlciIsImRlcmVnaXN0ZXIiLCJfdW5tYW5hZ2VTdWJ0cmVlIiwiX3RoaXMzIiwiaW5lcnRTdWJyb290IiwiZ2V0SW5lcnRSb290Iiwic2V0SW5lcnQiLCJtYW5hZ2VkTm9kZXMiLCJzYXZlZEluZXJ0Tm9kZSIsInJlY29yZHMiLCJzZWxmIiwicmVjb3JkIiwidHlwZSIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJhdHRyaWJ1dGVOYW1lIiwibWFuYWdlZE5vZGUiLCJhcmlhSGlkZGVuIiwiSW5lcnROb2RlIiwiaW5lcnRSb290IiwiX25vZGUiLCJfb3ZlcnJvZGVGb2N1c01ldGhvZCIsIl9pbmVydFJvb3RzIiwiX3NhdmVkVGFiSW5kZXgiLCJfZGVzdHJveWVkIiwiZW5zdXJlVW50YWJiYWJsZSIsIl90aHJvd0lmRGVzdHJveWVkIiwiZGVzdHJveWVkIiwiaGFzU2F2ZWRUYWJJbmRleCIsImFkZEluZXJ0Um9vdCIsInJlbW92ZUluZXJ0Um9vdCIsInNpemUiLCJJbmVydE1hbmFnZXIiLCJfZG9jdW1lbnQiLCJfd2F0Y2hGb3JJbmVydCIsImFkZEluZXJ0U3R5bGUiLCJoZWFkIiwiZG9jdW1lbnRFbGVtZW50IiwicmVhZHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfb25Eb2N1bWVudExvYWRlZCIsImluZXJ0IiwiaGFzIiwicGFyZW50IiwiX2luZXJ0Um9vdCIsImluZXJ0RWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5lcnRFbGVtZW50IiwiX3RoaXMiLCJzaGFkb3dSb290QW5jZXN0b3IiLCJsb2NhbE5hbWUiLCJjb250ZW50IiwiZGlzdHJpYnV0ZWROb2RlcyIsImdldERpc3RyaWJ1dGVkTm9kZXMiLCJzbG90IiwiX2Rpc3RyaWJ1dGVkTm9kZXMiLCJhc3NpZ25lZE5vZGVzIiwiZmxhdHRlbiIsIl9pIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicXVlcnlTZWxlY3RvciIsInRleHRDb250ZW50IiwiYXBwZW5kQ2hpbGQiLCJIVE1MRWxlbWVudCIsImhhc093blByb3BlcnR5IiwiX2Jsb2NraW5nRWxlbWVudHMiLCJfYWxyZWFkeUluZXJ0RWxlbWVudHMiLCJfdG9wRWxQYXJlbnRzIiwiX3NpYmxpbmdzVG9SZXN0b3JlIiwiX2luZXJ0U2libGluZ3MiLCJfZ2V0UGFyZW50cyIsIl9nZXREaXN0cmlidXRlZENoaWxkcmVuIiwiX2hhbmRsZU11dGF0aW9ucyIsIm51bGxhYmxlIiwidG9wIiwiZWxlbXMiLCJwdXNoIiwiaW5kZXhPZiIsInNwbGljZSIsIl90b3BDaGFuZ2VkIiwicG9wIiwicmVtb3ZlIiwiX2EiLCJfYiIsIl9jIiwibmV3VG9wIiwidG9LZWVwSW5lcnQiLCJvbGRQYXJlbnRzIiwiX3Jlc3RvcmVJbmVydGVkU2libGluZ3MiLCJjbGVhciIsIm5ld1BhcmVudHMiLCJ0b1NraXAiLCJqIiwiX3N3YXBJbmVydGVkU2libGluZyIsIm9sZEluZXJ0IiwibmV3SW5lcnQiLCJzaWJsaW5nc1RvUmVzdG9yZSIsIl9wYXJlbnRNTyIsImVsZW1lbnRzIiwibW8iLCJzaWJsaW5ncyIsInNpYmxpbmciLCJpbmVydGVkU2libGluZ3MiLCJfaXNJbmVydGFibGUiLCJwYXJlbnRUb09ic2VydmUiLCJtYXliZVNoYWR5Um9vdCIsIl9fc2hhZHkiLCJtdXRhdGlvbnMiLCJwYXJlbnRzIiwibXV0YXRpb24iLCJpZHgiLCJpbmVydGVkQ2hpbGQiLCJ1c2VCbG9ja2luZ0VsZW1lbnQiLCJlbmFibGVkIiwiZ2V0VGFyZ2V0Iiwic3RhYmxlR2V0VGFyZ2V0IiwiYmxvY2tpbmdFbGVtZW50cyIsImVycm9yIiwiZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvIiwidXNlRm9jdXNUcmFwIiwidHJhcEFjdGl2ZSIsInJhZkhhbmRsZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInF1ZXVlTWljcm90YXNrIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJnZXRUb3BFbGVtZW50IiwiZ2V0TGFzdEFjdGl2ZUVsZW1lbnQiLCJ1c2VBY3RpdmVFbGVtZW50Iiwib25Nb3VudENoYW5nZSIsImhhbmRsZUFjdGl2ZUNoYW5nZSIsImV4Y2x1ZGVzIiwiZXhjbHVkZSIsInJhbmdlIiwic2VsZWN0aW9uIiwiZ2V0UmFuZ2VBdCIsImVuZENvbnRhaW5lciIsImlzQ29sbGFwc2VkIiwidG9TdHJpbmciLCJ1c2VQcmVzc0V2ZW50SGFuZGxlcnMiLCJvbkNsaWNrU3luYyIsImFjdGl2ZSIsInNldEFjdGl2ZSIsImdldEFjdGl2ZSIsInNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUiLCJwcmV2Iiwibm9kZVNlbGVjdGVkVGV4dExlbmd0aCIsIkRhdGUiLCJhIiwiY3VycmVudFRpbWUiLCJ0aW1lRGlmZmVyZW5jZSIsInRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUiLCJoYW5kbGVQcmVzcyIsInB1bHNlIiwib25Nb3VzZURvd24iLCJkZXRhaWwiLCJidXR0b24iLCJvbkFjdGl2ZVN0YXJ0Iiwib25Nb3VzZVVwIiwib25BY3RpdmVTdG9wIiwib25CbHVyIiwidXNlQXJpYUFjY29yZGlvbiIsImV4cGFuZGVkSW5kZXgiLCJzZXRFeHBhbmRlZEluZGV4IiwiX2N1cnJlbnRGb2N1c2VkSW5kZXgiLCJzZXRDdXJyZW50Rm9jdXNlZEluZGV4IiwiZ2V0Q3VycmVudEZvY3VzZWRJbmRleCIsInN0YWJsZVNldEV4cGFuZGVkSW5kZXgiLCJtYW5hZ2VkQWNjb3JkaW9uU2VjdGlvbnMiLCJ1c2VNYW5hZ2VkQ2hpbGRTZWN0aW9uIiwic2V0TGFzdEZvY3VzZWRJbmRleCIsInVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyIsImxhc3RGb2N1c2VkSW5kZXgiLCJzZXRDaGlsZEZsYWciLCJvcGVuIiwic2V0T3BlbkZyb21QYXJlbnQiLCJnZXRPcGVuRnJvbVBhcmVudCIsIm9wZW5Gcm9tUGFyZW50IiwidXNlR2VuZXJpY0xhYmVsIiwibGFiZWxQcmVmaXgiLCJpbnB1dFByZWZpeCIsImJhY2t1cFRleHQiLCJsYWJlbEVsZW1lbnQiLCJzZXRMYWJlbEVsZW1lbnQiLCJpbnB1dEVsZW1lbnQiLCJzZXRJbnB1dEVsZW1lbnQiLCJnZXRMYWJlbEVsZW1lbnQiLCJ1c2VMYWJlbFJlZkVsZW1lbnRQcm9wcyIsImdldElucHV0RWxlbWVudCIsInVzZUlucHV0UmVmRWxlbWVudFByb3BzIiwidXNlUmFuZG9tSWRQcm9wcyIsInVzZUxhYmVsUmFuZG9tSWRQcm9wcyIsImxhYmVsSWQiLCJ1c2VSZWZlcmVuY2VkSWRQcm9wcyIsInVzZVJlZmVyZW5jZWRMYWJlbElkUHJvcHMiLCJ1c2VJbnB1dFJhbmRvbUlkUHJvcHMiLCJpbnB1dElkIiwidXNlUmVmZXJlbmNlZElucHV0SWRQcm9wcyIsInVzZUdlbmVyaWNMYWJlbExhYmVsIiwidXNlR2VuZXJpY0xhYmVsTGFiZWxQcm9wcyIsInVzZUdlbmVyaWNMYWJlbElucHV0IiwidXNlR2VuZXJpY0xhYmVsSW5wdXRQcm9wcyIsImFyaWFMYWJlbGxlZGJ5IiwiYXJpYUxhYmVsIiwibGFiZWxIYXNNb3VudGVkIiwidXNlSW5wdXRMYWJlbCIsInVzZUlucHV0TGFiZWxMYWJlbCIsInRhZyIsInVzZUlucHV0TGFiZWxMYWJlbFByb3BzIiwid2l0aG91dEZvciIsIndpdGhGb3IiLCJ1c2VJbnB1dExhYmVsSW5wdXQiLCJ1c2VJbnB1dExhYmVsSW5wdXRQcm9wcyIsImhhbmRsZXNJbnB1dCIsImxhYmVsUG9zaXRpb24iLCJ3aGljaCIsInVzZUNoZWNrYm94TGlrZSIsImNoZWNrZWQiLCJvbklucHV0Iiwicm9sZSIsInVzZUlMSW5wdXQiLCJ1c2VJTExhYmVsIiwidXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50IiwidXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQiLCJ1c2VJTElucHV0UHJvcHMiLCJ1c2VBcmlhQ2hlY2tib3giLCJvbklucHV0RW5oYW5jZWQiLCJlbmhhbmNlRXZlbnQiLCJ1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQiLCJ1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyIsImlzTWl4ZWQiLCJpbmRldGVybWluYXRlIiwidXNlQ2hlY2tib3hHcm91cCIsImtleU5hdmlnYXRpb24iLCJvblVwZGF0ZUNoaWxkcmVuIiwib25VcGRhdGVDaGlsZHJlblVuc3RhYmxlIiwidXNlTGlzdE5hdmlnYXRpb25DaGlsZCIsInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMiLCJmb2N1c0N1cnJlbnQiLCJ1c2VMaXN0TmF2aWdhdGlvbiIsImNoZWNrZWRDb3VudCIsInNldENoZWNrZWRDb3VudCIsImNoZWNrZWRJbmRpY2VzIiwiZ2V0U2VsZklzQ2hlY2tlZFVuc3RhYmxlIiwicGVyY2VudGFnZSIsImdldFNlbGZJc0NoZWNrZWRTdGFibGUiLCJzYXZlZENoZWNrZWRWYWx1ZXMiLCJvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dCIsInNlbGZJc0NoZWNrZWQiLCJjaGlsZHJlbkNoZWNrZWQiLCJ1c2VTb2Z0RGlzbWlzcyIsIm9uQ2xvc2UiLCJnZXRFbGVtZW50cyIsInN0YWJsZU9uQ2xvc2UiLCJzdGFibGVHZXRFbGVtZW50cyIsImdldE9wZW4iLCJvbkJhY2tkcm9wQ2xpY2siLCJmb3VuZEluc2lkZUNsaWNrIiwidXNlQWN0aXZlRWxlbWVudFByb3BzIiwib25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSIsIm5ld0VsZW1lbnQiLCJ2YWxpZEZvY3VzYWJsZUVsZW1lbnRzIiwiZm9jdXNhYmxlIiwibW91c2VEb3duIiwidG91Y2hTdGFydCIsImtleURvd24iLCJjYXB0dXJlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVzZVNvZnREaXNtaXNzUHJvcHMiLCJ1c2VNb2RhbCIsIm1vZGFsRGVzY3JpYmVkQnlCb2R5Iiwic2V0TW9kYWxEZXNjcmliZWRCeUJvZHkiLCJ1c2VIaWRlU2Nyb2xsIiwidXNlTW9kYWxSZWZFbGVtZW50IiwiZ2V0TW9kYWxFbGVtZW50IiwidXNlTW9kYWxCYWNrZHJvcCIsIm9uUG9pbnRlclVwIiwidXNlTW9kYWxCYWNrZHJvcFByb3BzIiwidXNlTW9kYWxQcm9wcyIsImFyaWFNb2RhbCIsInAwIiwidXNlRm9jdXNUcmFwUHJvcHMiLCJwMSIsInVzZVRpdGxlUmVmZXJlbmNpbmdJZFByb3BzIiwicDIiLCJ1c2VNb2RhbElkUHJvcHMiLCJwRmluYWwiLCJ1c2VCb2R5UmVmZXJlbmNpbmdJZFByb3BzIiwidXNlTW9kYWxUaXRsZSIsInVzZU1vZGFsVGl0bGVQcm9wcyIsInVzZVRpdGxlSWRQcm9wcyIsInVzZU1vZGFsQm9keSIsImRlc2NyaXB0aXZlIiwidXNlTW9kYWxCb2R5UHJvcHMiLCJ1c2VCb2R5SWRQcm9wcyIsImhpZGVTY3JvbGwiLCJ1c2VBcmlhRGlhbG9nIiwidXNlRGlhbG9nQmFja2Ryb3AiLCJ1c2VEaWFsb2dCYWNrZHJvcFByb3BzIiwidXNlRGlhbG9nQm9keSIsInVzZURpYWxvZ0JvZHlQcm9wcyIsInVzZURpYWxvZ1Byb3BzIiwidXNlRGlhbG9nVGl0bGUiLCJ1c2VEaWFsb2dUaXRsZVByb3BzIiwidXNlQXJpYUxpc3Rib3hNdWx0aSIsInVzZUhhc0ZvY3VzUHJvcHMiLCJnZXRGb2N1c2VkSW5uZXIiLCJ1c2VIYXNGb2N1cyIsIm5hdmlnYXRlVG9JbmRleCIsInNldFNoaWZ0SGVsZCIsImdldFNoaWZ0SGVsZCIsInR5cGVhaGVhZEluUHJvZ3Jlc3MiLCJzZXRUeXBlYWhlYWRJblByb2dyZXNzIiwidXNlTGlzdGJveE11bHRpSXRlbSIsInNlbGVjdGVkIiwiZ2V0U2VsZWN0ZWQiLCJzdGFibGVPblNlbGVjdCIsIm9uU2VsZWN0IiwidXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzIiwidXNlQXJpYUxpc3Rib3hTaW5nbGUiLCJzZWxlY3RlZEluZGV4Iiwic2VsZWN0aW9uTW9kZSIsImFueUl0ZW1zRm9jdXNlZCIsImdldEFueUl0ZW1zRm9jdXNlZCIsIm9uQWN0aXZlRWxlbWVudENoYW5nZSIsInNldEFueUl0ZW1zRm9jdXNlZCIsInVzZUNoaWxkRmxhZyIsInNldFNlbGVjdGVkIiwidXNlTGlzdGJveFNpbmdsZUl0ZW0iLCJ1c2VNZW51QmFzZSIsInNlbmRGb2N1c1dpdGhpbk1lbnUiLCJnZXRTZW5kRm9jdXNXaXRoaW5NZW51IiwiZm9jdXNUcmFwQWN0aXZlIiwic2V0Rm9jdXNUcmFwQWN0aXZlIiwib25PcGVuIiwibWVudWJhciIsImdldExhc3RGb2N1c2VkSW5uZXIiLCJnZXRNZW51QmFzZUxhc3RGb2N1c2VkSW5uZXIiLCJ1c2VCdXR0b25IYXNGb2N1c1Byb3BzIiwiZ2V0TWVudUJhc2VCdXR0b25MYXN0Rm9jdXNlZElubmVyIiwic2V0T3BlbmVyRWxlbWVudCIsImdldE9wZW5lckVsZW1lbnQiLCJ1c2VNZW51QmFzZUlkUHJvcHMiLCJ1c2VNZW51QmFzZUlkUmVmZXJlbmNpbmdQcm9wcyIsImdldEJ1dHRvbkVsZW1lbnQiLCJ1c2VCdXR0b25SZWZFbGVtZW50UHJvcHMiLCJnZXRNZW51RWxlbWVudCIsInVzZU1lbnVCYXNlUmVmRWxlbWVudFByb3BzIiwidXNlTWVudUJhc2VQcm9wcyIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInVzZU1lbnVCYXNlSGFzRm9jdXNQcm9wcyIsInVzZU1lbnVCYXNlQnV0dG9uUHJvcHMiLCJwcmV2ZW50U2Nyb2xsIiwidXNlTWVudVNlbnRpbmVsIiwidXNlU2VudGluZWxQcm9wcyIsInVzZU1lbnVTZW50aW5lbFByb3BzIiwidXNlRm9jdXNTZW50aW5lbCIsInVzZUFyaWFUYWJzIiwib3JpZW50YXRpb24iLCJsb2dpY2FsT3JpZW50YXRpb24iLCJ1c2VUYWJMaXN0SGFzRm9jdXNQcm9wcyIsImdldFRhYkxpc3RGb2N1c2VkSW5uZXIiLCJwaHlzaWNhbE9yaWVudGF0aW9uIiwic2V0UGh5c2ljYWxPcmllbnRhdGlvbiIsImxvZ2ljYWxEaXJlY3Rpb25JbmZvIiwidXNlVGFiTGFiZWxJZFByb3BzIiwidXNlUmVmZXJlbmNlZFRhYkxhYmVsSWQiLCJtYW5hZ2VkVGFicyIsIm1hbmFnZWRQYW5lbHMiLCJ1c2VNYW5hZ2VkVGFiUGFuZWwiLCJ2aXNpYmxlIiwic2V0VmlzaWJsZSIsImdldFZpc2libGUiLCJfcHJldiIsInVzZVRhYiIsInNlbGVjdGlvbk1vZGVMIiwic2V0U2VsZWN0aW9uTW9kZUwiLCJ0YWJQYW5lbElkIiwic2V0VGFiUGFuZWxJZCIsInRhYklkIiwic2V0U2VsZWN0aW9uTW9kZSIsImN1cnJlbnRUYXJnZXQiLCJFdmVudERldGFpbCIsInJldHVybkZhbHNlIiwidXNlQXJpYVRvb2x0aXAiLCJtb3VzZW92ZXJEZWxheSIsIm1vdXNlb3V0RGVsYXkiLCJmb2N1c0RlbGF5IiwiZGVmYXVsdFByZXZlbnRlZCIsInNldE9wZW4iLCJzZXRUcmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZCIsInNldFRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkIiwic2V0VHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCIsInNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJ1c2VUb29sdGlwSWRSZWZlcmVuY2luZ1Byb3BzIiwic2V0VHJpZ2dlckZvY3VzZWQiLCJmb2N1c2VkIiwiZGVsYXkiLCJpc0Zpbml0ZSIsImhhbmRsZSIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJzZXRUb29sdGlwRm9jdXNlZCIsInNldFRyaWdnZXJIb3ZlciIsImhvdmVyaW5nIiwic2V0VG9vbHRpcEhvdmVyIiwidHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCIsInRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkIiwidG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCIsInRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkIiwidXNlVG9vbHRpcFRyaWdnZXIiLCJ1c2VHbG9iYWxIYW5kbGVyIiwib25Ub3VjaEVuZCIsIm9uRm9jdXNlZElubmVyQ2hhbmdlZCIsInVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMiLCJ1c2VBcmlhUmFkaW9Hcm91cCIsInNlbGVjdGVkVmFsdWUiLCJnZXRSYWRpb0dyb3VwUGFyZW50RWxlbWVudCIsInNldFNlbGVjdGVkSW5kZXgiLCJieU5hbWUiLCJzdGFibGVPbklucHV0IiwiYW55UmFkaW9zRm9jdXNlZCIsInNldEFueVJhZGlvc0ZvY3VzZWQiLCJnZXRBbnlSYWRpb3NGb2N1c2VkIiwidXNlUmFkaW9Hcm91cFByb3BzIiwiY29ycmVjdGVkSW5kZXgiLCJzZXRDaGVja2VkIiwiZ2V0Q2hlY2tlZCIsInVzZVJhZGlvIiwidXNlQXJpYVJhZGlvIiwidXNlUmFkaW9JbnB1dCIsIl9qc3hzIiwiX2pzeCIsIlJhbmRvbVdvcmRzIiwibWVtbyIsInVzZUNvbnRleHQiLCJfRnJhZ21lbnQiLCJyZW5kZXIiXSwibWFwcGluZ3MiOiI7OztBQUdJQSxNQUFBQSxDQUFBQTtDQUFBQSxPQUFBQSxDQUFBQTtDQUFBQSxPQUFBQSxDQUFBQTtDQUFBQSxPQUFBQSxDQUFBQTtDQUFBQSxPQUFBQSxDQUFBQTtDQUFBQSxPQUFBQSxDQUFBQTtDQUFBQSxPQUFBQSxDQUFBQTtDQUFBQSxJQ3VLQUMsTUN6S1NDLEVGRVRGLENBQUFBO0NBQUFBLFlBQUFBLENBQUFBO0NBQUFBLDhFQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUMsRUFBQSxDQUFNLElBQU0sRUFDbk0sWUFBWSxJQUFJLElBQUksSUFBSUEsMkNBQW9CQSxHQUN6QyxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFPRCxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsTUFBQSxFQUFBLENBQWEsRUFBQUEsR0FBYSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxNQUFBLEVBQUEsQ0FBQSxFQUFBQSwrQkFBYSxFQUFBQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLGVBQUEsRUFBQSxDQUFzQixJQUFLLEVBQVEsQ0FBQSxFQUNyRkEseUJBQVEsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUlELHVCQUFJQyxHQUFLLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUMsQ0FBQyxJQUFJLEdBQU0sRUFBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBQ0EsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBSyxDQUFDLENBQUMsSUFBSSxHQUFNLEVBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksSUFBSSxDQUFDLENBQUMsRUFBTSxDQUFBLENBQUEsRUFBQSxDQUFLLENBQUMsRUFBUyxDQUFBLENBQUEsRUFBQSxDQUMxSSxJQUFNLEVBQ2RBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxDQUFNLEVBRUwsdUJBQXVCLElBQUksSUFBSSxJQUFJRCxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEseUJBQUEsRUFBNEJDLHNCQUFLLEtBQUssQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJQSxzQkFBSyxJQUFJLEVBQUEsQ0FBTSxDQUFDLEVBQU0sQ0FBQSxDQUFBLEVBQUEsQ0FBTSxFQUNoSixxQkFBcUIsSUFBSSxJQUFJLElBQUlELEdBQUEsQ0FBQSxLQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSwwQkFBQSxFQUE2QkMsc0JBQUsscUJBQXFCLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSUEsR0FBSyxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFBLENBQU0sQ0FBQyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQU0sRUFFNUlBLEdBQU0sQ0FBQSxJQUFBLEVBQUEsRUFBQSxDQUFBLEVBQ0wsU0FBUyxJQUFJQSxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFNLFNBQVMsWUFBWSxLQUFLLEdBQUcsU0FBUyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFPLENBQUEsQ0FBQSxFQUFBLENBQ25HLEVBQ1Q7Q0FDTCxDQUFDLENBQUE7Q0FFRCxNQUFNLGdCQUFnQixHQUFHLE1BQUs7S0FDMUIsTUFBTSxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxjQUFjLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLEdBQUcsWUFBWSxDQUFpQixFQUFFLElBQUksRUFBRSxFQUFFLFlBQVksRUFBRSxzREFBc0QsRUFBRSxFQUFFLENBQUMsQ0FBQztDQUd6TSxJQUFBLFFBQ0lBLEdBQUEsQ0FBQSxLQUFBLEVBQUEsRUFBQSxHQUFTLGlCQUFpQixDQUFDLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBRTNDLFFBQUEsRUFBQSxtQkFBQSxFQUFBLENBQUEsRUFBQztDQUNmLENBQUMsQ0FBQTtDQUdELE1BQU0sZ0JBQWdCLEdBQUdFLENBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFzQixLQUFJO0tBRTVELE1BQU0sQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0NBRTVDLElBQUEsTUFBTSxFQUFFLGlCQUFpQixFQUFFLEdBQUcsWUFBWSxDQUFpQixFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO0NBRW5GLElBQUEsTUFBTSxRQUFRLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxDQUFDLENBQUM7S0FDckYsSUFBSSxLQUFLLElBQUksQ0FBQztDQUNWLFFBQUEsT0FBT0YsY0FBTyxDQUFDO0NBRW5CLElBQUEsUUFDSUQsR0FBQSxDQUFBLEtBQUEsRUFBQSxFQUFLLFNBQVMsRUFBQyxNQUFNLEVBQUEsUUFBQSxFQUFBLENBQ2pCQSxHQUFlLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsVUFBQSxFQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQU8sSUFBSSxFQUFDLFVBQVUsRUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQU0sRUFBQSxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUEsQ0FBSSxDQUFRLEVBQUEsQ0FBQSxFQUM1SUEsR0FBUyxDQUFBLEtBQUEsRUFBQSxFQUFBLEdBQUEsUUFBUSxFQUNiLFFBQUEsRUFBQUEsR0FBQSxDQUFDLHFCQUFxQixFQUFDLEVBQUEsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxLQUFLLElBQUksQ0FBQyxFQUFBLENBQUksRUFDaEYsQ0FBQSxDQUFBLEVBQUEsQ0FDSixFQUNSO0NBQ04sQ0FBQyxDQUFDLENBQUM7Q0FHSCxNQUFNLHFCQUFxQixHQUFHRSxDQUFJLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUE0RSxLQUFJO0tBRzFJLFFBQ0lILHNCQUNJQyxHQUF5QixDQUFBLFFBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxVQUFBLEVBQUEsQ0FBQSxFQUN6QkEsdUNBQXlCLEVBQ3pCQSxHQUFBLENBQUEsUUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFVBQUEsRUFBQSxDQUF5QixFQUN6QkQsR0FBZSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLFVBQUEsRUFBQUMsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFPLElBQUksRUFBQyxVQUFVLEVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFNLEVBQUEsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFJLENBQUEsQ0FBQSxFQUFBLENBQVEsQ0FFN0ksRUFBQSxDQUFBLEVBQ0w7Q0FDTixDQUFDLENBQUMsQ0FBQztDQUVILE1BQU0sMEJBQTBCLEdBQUd0bEIsQ0FBYSxDQUE2QyxJQUFLLENBQUMsQ0FBQztDQUNwRyxNQUFNLGdCQUFnQixHQUFHd2xCLENBQUksQ0FBQyxNQUFLO0tBRS9CLE1BQU0sQ0FBQyxhQUFhLEVBQUUsZ0JBQWdCLENBQUMsR0FBRyxRQUFRLENBQWdCLENBQUMsQ0FBQyxDQUFDO0NBRXJFLElBQUEsTUFBTSxFQUFFLHVCQUF1QixFQUFFLEdBQUcsZ0JBQWdCLENBQW9DLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixFQUFFLENBQUMsQ0FBQTtDQUU1SCxJQUFBLFFBQ0lGLEdBQUMsQ0FBQSwwQkFBMEIsQ0FBQyxRQUFRLEVBQUEsRUFBQyxLQUFLLEVBQUUsdUJBQXVCLFlBQy9EQSxHQUFLLENBQUEsS0FBQSxFQUFBLEVBQUEsU0FBUyxFQUFDLE1BQU0sRUFBQSxRQUFBLEVBQ2pCRCx3QkFDSUMsR0FBQyxDQUFBLG9CQUFvQixJQUFDLEtBQUssRUFBRSxDQUFDLEVBQUksQ0FBQSxFQUNsQ0EsSUFBQyxvQkFBb0IsRUFBQSxFQUFDLEtBQUssRUFBRSxDQUFDLEdBQUksRUFDbENBLEdBQUEsQ0FBQyxvQkFBb0IsRUFBQyxFQUFBLEtBQUssRUFBRSxDQUFDLEVBQUEsQ0FBSSxJQUNoQyxFQUNKLENBQUEsRUFBQSxDQUM0QixFQUN6QztDQUNMLENBQUMsQ0FBQyxDQUFDO0NBRUgsTUFBTSxvQkFBb0IsR0FBR0UsQ0FBSSxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQXFCLEtBQUk7Q0FFL0QsSUFBQSxNQUFNLG1CQUFtQixHQUFHQyxHQUFVLENBQUMsMEJBQTBCLENBQUMsQ0FBQztDQUNuRSxJQUFBLE1BQU0sRUFBRSxRQUFRLEVBQUUsMkJBQTJCLEVBQUUsNkJBQTZCLEVBQUUsR0FBRyxtQkFBbUIsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FFaEgsSUFBQSxNQUFNLEVBQUUsZ0NBQWdDLEVBQUUsR0FBRywyQkFBMkIsRUFBa0IsQ0FBQztDQUMzRixJQUFBLE1BQU0sRUFBRSxrQ0FBa0MsRUFBRSxHQUFHLDZCQUE2QixDQUFDLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7Q0FFaEcsSUFBQSxNQUFNLENBQUMsR0FBRyxnQ0FBZ0MsQ0FBQyxFQUFFLFNBQVMsRUFBRSx3QkFBd0IsRUFBRSxNQUFNLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0tBQ3ZHLENBQUMsQ0FBQyxFQUFFLENBQUM7Q0FDTCxJQUFBLFFBQ0lKLEdBQUssQ0FBQSxLQUFBLEVBQUEsRUFBQSxTQUFTLEVBQUMsbUJBQW1CLEVBQUEsUUFBQSxFQUFBLENBQzlCQSxtQkFBWSxrQ0FBa0MsQ0FBQyxFQUFFLFNBQVMsRUFBRSwwQkFBMEIsRUFBRSxDQUFDLEVBQVcsUUFBQSxFQUFBLENBQUEsVUFBQSxFQUFBLEtBQUssR0FBRyxDQUFDLENBQUEsRUFBQSxDQUFVLEVBQ3ZIQSxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsR0FBUyxDQUFDLEVBQUUsUUFBQSxFQUFBLENBQUFBLEdBQUEsQ0FBQSxHQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxnQkFBQSxFQUFrQixLQUFLLEdBQUcsQ0FBQyxJQUFLLEVBQUFDLEdBQUEsQ0FBQSxHQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBSyxDQUFNLEVBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FDOUUsRUFDVDtDQUNMLENBQUMsQ0FBQyxDQUFBO0NBRUYsTUFBTSxlQUFlLEdBQUdFLENBQUksQ0FBQyxNQUFLO0tBRTlCLFFBQ0lILHNCQUNJQSxHQUFLLENBQUEsS0FBQSxFQUFBLEVBQUEsU0FBUyxFQUFDLE1BQU0sRUFBQSxRQUFBLEVBQUEsQ0FDakJDLElBQUMsU0FBUyxFQUFBLEVBQUEsQ0FBRyxFQUNiQSxHQUFDLENBQUEsU0FBUyxLQUFHLENBQ1gsRUFBQSxDQUFBLEVBQ05BLElBQUMsb0JBQW9CLEVBQUEsRUFBQSxDQUFHLENBQ3pCLEVBQUEsQ0FBQSxFQUNOO0NBQ0wsQ0FBQyxDQUFDLENBQUM7Q0FLSCxNQUFNLFNBQVMsR0FBR0UsQ0FBSSxDQUFDLE1BQUs7S0FFeEIsTUFBTSxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FFOUMsSUFBQSxNQUFNLEVBQUUsdUJBQXVCLEVBQUUsdUJBQXVCLEVBQUUsR0FBRyxlQUFlLENBQXFDLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQzVOLElBQUEsTUFBTSxFQUFFLDRCQUE0QixFQUFFLEdBQUcsdUJBQXVCLENBQUMsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztDQUNuRixJQUFBLE1BQU0sRUFBRSw0QkFBNEIsRUFBRSxHQUFHLHVCQUF1QixDQUFDLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7S0FFbkYsUUFDSUgsd0JBQ0lDLEdBQVcsQ0FBQSxPQUFBLEVBQUEsRUFBQSxHQUFBLDRCQUE0QixDQUFDLEVBQUUsSUFBSSxFQUFFLFVBQVUsR0FBRyxDQUFDLEVBQUksQ0FBQSxFQUNsRUEsa0JBQVcsNEJBQTRCLENBQUMsRUFBRSxDQUFDLEVBQUEsUUFBQSxFQUFBLE9BQUEsRUFBQSxDQUFlLENBQ3hELEVBQUEsQ0FBQSxFQUNUO0NBQ0wsQ0FBQyxDQUFDLENBQUM7Q0FFSCxNQUFNLFNBQVMsR0FBR0UsQ0FBSSxDQUFDLE1BQUs7S0FFeEIsTUFBTSxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FFOUMsSUFBQSxNQUFNLEVBQUUsdUJBQXVCLEVBQUUsdUJBQXVCLEVBQUUsR0FBRyxlQUFlLENBQXFDLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxhQUFhLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0NBQzVOLElBQUEsTUFBTSxFQUFFLDRCQUE0QixFQUFFLEdBQUcsdUJBQXVCLENBQUMsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztDQUNuRixJQUFBLE1BQU0sRUFBRSw0QkFBNEIsRUFBRSxHQUFHLHVCQUF1QixDQUFDLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7S0FFbkYsUUFDSUYsdUJBQ0lELEdBQVcsQ0FBQSxPQUFBLEVBQUEsRUFBQSxHQUFBLDRCQUE0QixDQUFDLEVBQUUsQ0FBQyxhQUFFQyxHQUFXLENBQUEsT0FBQSxFQUFBLEVBQUEsR0FBQSw0QkFBNEIsQ0FBQyxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFJLENBQUEsRUFBQSxRQUFBLENBQUEsRUFBQSxDQUFjLEVBQzFILENBQUEsRUFDVDtDQUNMLENBQUMsQ0FBQyxDQUFDO0NBR0gsTUFBTSxvQkFBb0IsR0FBR3RsQixDQUFhLENBQXFFLElBQUssQ0FBQyxDQUFDO0NBRXRILE1BQU0sb0JBQW9CLEdBQUd3bEIsQ0FBSSxDQUFDLE1BQUs7Q0FFbkMsSUFBQSxNQUFNLGdCQUFnQixHQUFHLENBQUMsS0FBc0UsS0FBVTtTQUN0RyxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsZUFBZSxDQUFDO0NBQ2pELFFBQUEsSUFBSSxjQUFjLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztTQUN2QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO0NBQ3pCLFlBQUEsSUFBSSxLQUFLLEtBQUssS0FBSyxFQUFFLENBQW9CO2tCQUNwQyxJQUFJLEtBQUssS0FBSyxJQUFJO0NBQ25CLGdCQUFBLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDckIsaUJBQUEsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUk7Q0FDMUIsZ0JBQUEsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUU3QixTQUFBO1NBRUQsaUJBQWlCLENBQUMsY0FBYyxDQUFDLENBQUM7Q0FDdEMsS0FBQyxDQUFDO0tBR0YsTUFBTSxFQUFFLGdCQUFnQixFQUFFLGVBQWUsRUFBRSxHQUFHLFdBQVcsQ0FBaUIsRUFBRSxDQUFDLENBQUE7Q0FDN0UsSUFBQSxNQUFNLEVBQUUsMkJBQTJCLEVBQUUsNkJBQTZCLEVBQUUscUJBQXFCLEVBQUUsZUFBZSxFQUFFLGFBQWEsRUFBRSxvQkFBb0IsRUFBRSxjQUFjLEVBQUUsMEJBQTBCLEVBQUUsb0JBQW9CLEVBQUUsR0FBRyxnQkFBZ0IsQ0FBOEMsRUFBRSxtQkFBbUIsRUFBRSxlQUFlLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO0tBQ2hWLE1BQU0sRUFBRSx1QkFBdUIsRUFBRSx1QkFBdUIsRUFBRSxHQUFHLGVBQWUsQ0FBcUMsRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsb0JBQTJCLEVBQUUsQ0FBQyxDQUFDO0NBRS9OLElBQUEsTUFBTSxFQUFFLDRCQUE0QixFQUFFLEdBQUcsdUJBQXVCLENBQUMsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztDQUNuRixJQUFBLE1BQU0sRUFBRSw0QkFBNEIsRUFBRSxHQUFHLHVCQUF1QixDQUFDLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7Q0FDbkYsSUFBQSxNQUFNLENBQUMsY0FBYyxFQUFFLGlCQUFpQixDQUFDLEdBQUcsUUFBUSxDQUFjLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQztLQUc3RSxPQUFPRixHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUssS0FBSyxFQUFDLE1BQU0sRUFBQSxRQUFBLEVBQ3BCRCxHQUFDLENBQUEsb0JBQW9CLENBQUMsUUFBUSxFQUFDLEVBQUEsS0FBSyxFQUFFLHFCQUFxQixhQUN2REEsR0FDSSxDQUFBLEtBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsR0FBVyw0QkFBNEIsQ0FBQyw2QkFBNkIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFBLENBQUksRUFDOUVBLEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBQSxHQUFXLDRCQUE0QixDQUFDLEVBQUUsQ0FBQyxFQUFBLFFBQUEsRUFBQSxjQUFBLEVBQUEsQ0FBc0IsQ0FDL0QsRUFBQSxDQUFBLEVBQ05BLEdBQVMsQ0FBQSxLQUFBLEVBQUEsRUFBQSxHQUFBLGdCQUFnQixDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxlQUFlLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxFQUFBLFFBQUEsRUFFakYsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLGFBQVM7eUJBQ2xCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUU7NkJBQ3pCLFNBQVMsWUFBWSxDQUFDLFFBQWlCLEVBQUE7aUNBRW5DLGlCQUFpQixDQUFDLGNBQWMsSUFBRztDQUMvQixvQ0FBQSxJQUFJLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQztxQ0FFbkMsSUFBSSxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO0NBQzFCLHdDQUFBLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDWix3Q0FBQSxPQUFPLElBQUksQ0FBQztDQUNmLHFDQUFBOzBDQUNJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtDQUMvQix3Q0FBQSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ2Ysd0NBQUEsT0FBTyxJQUFJLENBQUM7Q0FDZixxQ0FBQTtDQUVELG9DQUFBLE9BQU8sY0FBYyxDQUFDO0NBQzFCLGlDQUFDLENBQUMsQ0FBQzs4QkFFTjs2QkFFRCxNQUFNQSxHQUFBLENBQUMseUJBQXlCLEVBQUEsRUFBUyxLQUFLLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFBLEVBQXZFLENBQUMsQ0FBMEUsQ0FBQTtDQUNwSCx5QkFBQTtDQUNMLHFCQUFDLEdBQUcsQ0FBQyxFQUNILENBQUEsQ0FBQSxFQUFBLENBQ3NCLEdBQzlCLENBQUE7Q0FDVixDQUFDLENBQUMsQ0FBQztDQUdILE1BQU0seUJBQXlCLEdBQUdFLENBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQWdHLEtBQUk7Q0FDcEssSUFBQSxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsV0FBVyxFQUFFLENBQUM7Q0FDbkMsSUFBQSxNQUFNLHFCQUFxQixHQUFHQyxHQUFVLENBQUMsb0JBQW9CLENBQUMsQ0FBQztDQUMvRCxJQUFBLElBQUksSUFBSSxHQUFHLENBQUEsT0FBQSxFQUFVLEtBQUssR0FBRyxDQUFDLENBQWEsVUFBQSxFQUFBLE9BQU8sR0FBRyxXQUFXLEdBQUcsRUFBRSxFQUFFLENBQUM7S0FDeEUsTUFBTSxFQUFFLFFBQVEsRUFBRSwwQkFBMEIsRUFBRSxHQUFHLHFCQUFxQixDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7S0FDL0csSUFBSSxHQUFHLENBQVUsT0FBQSxFQUFBLEtBQUssR0FBRyxDQUFDLENBQWEsVUFBQSxFQUFBLE9BQU8sR0FBRyxXQUFXLEdBQUcsRUFBRSxDQUFBLENBQUEsRUFBSSxRQUFRLEdBQUcsV0FBVyxHQUFHLEVBQUUsQ0FBQSxDQUFFLENBQUM7Q0FDbkcsSUFBQSxNQUFNLEVBQUUsdUJBQXVCLEVBQUUsdUJBQXVCLEVBQUUsR0FBRyxlQUFlLENBQXFDLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxNQUFNLFVBQVUsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztDQUVqTyxJQUFBLE1BQU0sRUFBRSw0QkFBNEIsRUFBRSxHQUFHLHVCQUF1QixDQUFDLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7Q0FDbkYsSUFBQSxNQUFNLEVBQUUsNEJBQTRCLEVBQUUsR0FBRyx1QkFBdUIsQ0FBQyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0tBRW5GLFFBQVFKLHdCQUNKQyxHQUFXLENBQUEsT0FBQSxFQUFBLEVBQUEsR0FBQSw0QkFBNEIsQ0FBQywwQkFBMEIsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFBLENBQUksRUFDM0VBLEdBQVcsQ0FBQSxPQUFBLEVBQUEsRUFBQSxHQUFBLDRCQUE0QixDQUFDLEVBQUUsQ0FBQyxZQUFHLElBQUksRUFBQSxDQUFTLENBQ3pELEVBQUEsQ0FBQSxFQUNKO0NBQ04sQ0FBQyxDQUFDLENBQUM7Q0FHSCxNQUFNLGFBQWEsR0FBR0UsQ0FBSSxDQUFDLE1BQUs7S0FDNUIsTUFBTSxPQUFPLElBQUksTUFBTSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztLQUN2QyxNQUFNLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUV4QyxJQUFBLE1BQU0sRUFBRSxpQkFBaUIsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxHQUFHLGFBQWEsQ0FBaUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztDQUM5SCxJQUFBLE1BQU0sRUFBRSxzQkFBc0IsRUFBRSxHQUFHLGlCQUFpQixFQUFrQixDQUFDO0NBQ3ZFLElBQUEsTUFBTSxFQUFFLGtCQUFrQixFQUFFLEdBQUcsYUFBYSxDQUFDLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7Q0FDcEUsSUFBQSxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsR0FBRyxjQUFjLEVBQUUsQ0FBQztLQUNqRCxRQUNJSCxHQUFLLENBQUEsS0FBQSxFQUFBLEVBQUEsS0FBSyxFQUFDLE1BQU0sRUFDYixRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBT0EsR0FBTyxDQUFBLE9BQUEsRUFBQSxFQUFBLElBQUksRUFBQyxVQUFVLEVBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFHLEVBQUcsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUEsRUFBRSxFQUFJLENBQUEsRUFBQSxDQUFRLEVBQy9IQSxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsR0FBUyxzQkFBc0IsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLEVBQUEsUUFBQSxFQUM5Q0QsR0FBUyxDQUFBLEtBQUEsRUFBQSxFQUFBLEdBQUEsY0FBYyxDQUFDLEVBQUUsQ0FBQyxFQUFBLFFBQUEsRUFBQSxDQUN2QkMsZ0JBQVMsbUJBQW1CLENBQUMsRUFBRSxDQUFDLEVBQW9CLFFBQUEsRUFBQSxjQUFBLEVBQUEsQ0FBQSxFQUNwREQsR0FBUyxDQUFBLEtBQUEsRUFBQSxFQUFBLEdBQUEsa0JBQWtCLENBQUMsRUFBRSxDQUFDLEVBQUEsUUFBQSxFQUFBLENBQzNCQyxHQUFHLENBQUEsR0FBQSxFQUFBLEVBQUEsUUFBUSxFQUFFLENBQUMsQ0FBQyxFQUF5QixRQUFBLEVBQUEscUJBQUEsRUFBQSxDQUFBLEVBQ3hDQSxHQUFJLENBQUEsR0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUEsQ0FBSyxFQUM5QkEsR0FBQSxDQUFBLEdBQUEsRUFBQSxFQUFBLFFBQUEsRUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFBLENBQUssRUFDOUJBLEdBQUEsQ0FBQSxHQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBSyxDQUFBLEVBQzlCQSxHQUFHLENBQUEsR0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBQSxHQUFBLENBQUEsUUFBQSxFQUFBLEVBQVEsT0FBTyxFQUFFLE9BQU8sRUFBQSxRQUFBLEVBQUEsT0FBQSxFQUFBLENBQWdCLEVBQUksQ0FBQSxDQUFBLEVBQUEsQ0FDN0MsQ0FDSixFQUFBLENBQUEsRUFBQSxDQUNKLENBQ0osRUFBQSxDQUFBLEVBQ1Q7Q0FDTCxDQUFDLENBQUMsQ0FBQztDQUVILE1BQU0sZ0JBQWdCLEdBQUd0bEIsQ0FBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0NBQzlDLE1BQU0sWUFBWSxHQUFHQSxDQUFhLENBQXlFLElBQUssQ0FBQyxDQUFDO0NBQ2xILE1BQU0saUJBQWlCLEdBQUd3bEIsQ0FBSSxDQUFDLE1BQUs7S0FDaEMsTUFBTSxDQUFDLGFBQWEsRUFBRSxnQkFBZ0IsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN0RCxJQUFBLE1BQU0sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLEdBQUcsUUFBUSxDQUFDQyxHQUFVLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO0tBQy9ELE1BQU0sRUFBRSxRQUFRLEVBQUUsa0JBQWtCLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxpQkFBaUIsQ0FBK0U7Q0FDdkosUUFBQSxJQUFJLEVBQUUsY0FBYztDQUNwQixRQUFBLE9BQU8sRUFBRSxDQUFDLENBQUMsS0FBSyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxhQUFhLENBQUM7Q0FDL0QsUUFBQSxhQUFhLEVBQUUsYUFBYTtDQUMvQixLQUFBLENBQUMsQ0FBQztDQUdILElBQUEsT0FBT0osR0FBSyxDQUFBLEtBQUEsRUFBQSxFQUFBLEtBQUssRUFBQyxNQUFNLGFBQ3BCQSxHQUFPLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBTyxJQUFJLEVBQUMsVUFBVSxFQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUEsQ0FBSSxzQkFBc0IsRUFDckdELEdBQUEsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUEsRUFBWSxLQUFLLEVBQUUsSUFBSSxFQUM1QyxRQUFBLEVBQUEsQ0FBQSxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsRUFDNUJDLEdBQUMsQ0FBQSxZQUFZLENBQUMsUUFBUSxFQUFBLEVBQUMsS0FBSyxFQUFFLFFBQVEsRUFBQSxRQUFBLEVBQ2xDQSxHQUFTLENBQUEsS0FBQSxFQUFBLEVBQUEsR0FBQSxrQkFBa0IsQ0FBQyxFQUFFLENBQUMsRUFDMUIsUUFBQSxFQUFBLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxhQUFTO2lDQUNsQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFO3FDQUN6QixNQUFNQSxHQUFBLENBQUMsU0FBUyxFQUFTLEVBQUEsS0FBSyxFQUFFLENBQUMsRUFBQSxFQUFYLENBQUMsQ0FBYyxDQUFBO0NBQ3hDLGlDQUFBOzhCQUNKLEdBQUcsQ0FBQyxFQUFBLENBQ0gsR0FDYyxDQVZJLEVBQUEsRUFBQSxJQUFJLENBV1IsQ0FBQSxFQUFBLENBQzFCLENBQUE7Q0FDVixDQUFDLENBQUMsQ0FBQztDQUlILE1BQU0sU0FBUyxHQUFHRSxDQUFJLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBcUIsS0FBSTtDQUNwRCxJQUFBLE1BQU0sSUFBSSxHQUFHQyxHQUFVLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztDQUMxQyxJQUFBLE1BQU0sRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsR0FBR0EsR0FBVSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxJQUFJLEdBQUcsVUFBVSxHQUFHLFVBQVUsRUFBRSxDQUFDLENBQUM7Q0FDMUwsSUFBQSxNQUFNLEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxhQUFhLENBQUMsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztDQUMvRCxJQUFBLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxHQUFHLGFBQWEsQ0FBQyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0NBQy9ELElBQUEsSUFBSSxJQUFJO0NBQ0osUUFBQSxPQUFPSixrQkFBVyxrQkFBa0IsQ0FBQyxFQUFFLENBQUMsYUFBRUMsR0FBVyxDQUFBLE9BQUEsRUFBQSxFQUFBLEdBQUEsa0JBQWtCLENBQUMsRUFBRSxDQUFDLEVBQUksQ0FBQSxFQUFBLFNBQUEsRUFBUSxLQUFLLEdBQUcsQ0FBQyxFQUFRLFFBQUEsRUFBQSxPQUFPLEdBQUcsWUFBWSxHQUFHLEVBQUUsRUFBRSxRQUFRLEdBQUcsYUFBYSxHQUFHLEVBQUUsSUFBUyxDQUFDOztDQUU1SyxRQUFBLE9BQU9ELHdCQUFLQyxHQUFXLENBQUEsT0FBQSxFQUFBLEVBQUEsR0FBQSxrQkFBa0IsQ0FBQyxFQUFFLENBQUMsRUFBSSxDQUFBLEVBQUEsU0FBQSxFQUFRLEtBQUssR0FBRyxDQUFDLEVBQVEsUUFBQSxFQUFBLE9BQU8sR0FBRyxZQUFZLEdBQUcsRUFBRSxFQUFFLFFBQVEsR0FBRyxhQUFhLEdBQUcsRUFBRSxFQUFDQSxrQkFBVyxrQkFBa0IsQ0FBQyxFQUFFLENBQUMsRUFBQSxDQUFVLElBQU0sQ0FBQztDQUMvTCxDQUFDLENBQUMsQ0FBQztDQUdILE1BQU0sd0JBQXdCLEdBQUd0bEIsQ0FBYSxDQUErRSxJQUFLLENBQUMsQ0FBQztDQUNwSSxNQUFNLG9CQUFvQixHQUFHd2xCLENBQUksQ0FBQyxNQUFLO0tBQ25DLE1BQU0sQ0FBQyxhQUFhLEVBQUUsZ0JBQWdCLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDdEQsSUFBQSxNQUFNLEVBQUUsb0JBQW9CLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUsR0FBRyxvQkFBb0IsQ0FBMkUsRUFBRSxhQUFhLEVBQUUsUUFBUSxFQUFFLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsYUFBYSxDQUFDLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUM7S0FHM1IsT0FBT0YsR0FBQSxDQUFBLEtBQUEsRUFBQSxFQUFLLEtBQUssRUFBQyxNQUFNLEVBQUEsUUFBQSxFQUNwQkEsR0FBQyxDQUFBLHdCQUF3QixDQUFDLFFBQVEsRUFBQyxFQUFBLEtBQUssRUFBRSxvQkFBb0IsWUFDMURBLEdBQVEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxHQUFBLHFCQUFxQixDQUFDLEVBQUUsQ0FBQyxFQUFBLFFBQUEsRUFDNUIsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLGFBQVM7cUJBQ2xCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUU7eUJBQ3pCLE1BQU1BLEdBQUEsQ0FBQyx1QkFBdUIsRUFBUyxFQUFBLEtBQUssRUFBRSxDQUFDLEVBQUEsRUFBWCxDQUFDLENBQWMsQ0FBQTtDQUN0RCxxQkFBQTtDQUNMLGlCQUFDLEdBQUcsQ0FBQyxFQUNKLENBQUEsRUFBQSxDQUMyQixHQUNsQyxDQUFBO0NBQ1YsQ0FBQyxDQUFDLENBQUM7Q0FJSCxNQUFNLHVCQUF1QixHQUFHRSxDQUFJLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBc0IsS0FBSTtLQUNuRSxNQUFNLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUseUJBQXlCLEVBQUUsR0FBR0MsR0FBVSxDQUFDLHdCQUF3QixDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztDQUM5SSxJQUFBLE9BQU9KLEdBQVEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxHQUFBLHlCQUF5QixDQUFDLEVBQUUsQ0FBQyxFQUFBLFFBQUEsRUFBQSxDQUFBLFNBQUEsRUFBVSxLQUFLLEdBQUcsQ0FBQyxFQUFBLFNBQUEsRUFBUyxRQUFRLEdBQUcsYUFBYSxHQUFHLEVBQUUsRUFBRSxRQUFRLEdBQUcsYUFBYSxHQUFHLEVBQUUsSUFBTSxDQUFBO0NBQzlJLENBQUMsQ0FBQyxDQUFDO0NBTUgsTUFBTSx1QkFBdUIsR0FBR3JsQixDQUFhLENBQTZFLElBQUssQ0FBQyxDQUFDO0NBQ2pJLE1BQU0sbUJBQW1CLEdBQUd3bEIsQ0FBSSxDQUFDLE1BQUs7Q0FFbEMsSUFBQSxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsb0JBQW9CLEVBQUUsb0JBQW9CLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxtQkFBbUIsQ0FBMEUsRUFBRSxDQUFDLENBQUM7Q0FFL0wsSUFBQSxNQUFNLENBQUMsY0FBYyxFQUFFLGlCQUFpQixDQUFDLEdBQUcsUUFBUSxDQUFjLElBQUksR0FBRyxFQUFFLENBQUMsQ0FBQztLQUc3RSxPQUFPRixHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUssS0FBSyxFQUFDLE1BQU0sRUFBQSxRQUFBLEVBQ3BCRCxHQUFDLENBQUEsdUJBQXVCLENBQUMsUUFBUSxFQUFDLEVBQUEsS0FBSyxFQUFFLG1CQUFtQixhQUN4REMsR0FBUSxDQUFBLElBQUEsRUFBQSxFQUFBLEdBQUEsb0JBQW9CLENBQUMsRUFBRSxDQUFDLEVBQUEsUUFBQSxFQUMzQixLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBUzt5QkFDbEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRTs2QkFDekIsU0FBUyxZQUFZLENBQUMsUUFBaUIsRUFBQTtpQ0FFbkMsaUJBQWlCLENBQUMsY0FBYyxJQUFHO0NBQy9CLG9DQUFBLElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO3FDQUVuQyxJQUFJLFFBQVEsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU7Q0FDMUIsd0NBQUEsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNaLHdDQUFBLE9BQU8sSUFBSSxDQUFDO0NBQ2YscUNBQUE7MENBQ0ksSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO0NBQy9CLHdDQUFBLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDZix3Q0FBQSxPQUFPLElBQUksQ0FBQztDQUNmLHFDQUFBO0NBRUQsb0NBQUEsT0FBTyxjQUFjLENBQUM7Q0FDMUIsaUNBQUMsQ0FBQyxDQUFDOzhCQUVOOzZCQUVELE1BQU1BLEdBQUEsQ0FBQyxzQkFBc0IsRUFBQSxFQUFTLEtBQUssRUFBRSxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUEsRUFBekUsQ0FBQyxDQUE0RSxDQUFBO0NBQ25ILHlCQUFBO0NBQ0wscUJBQUMsR0FBRyxDQUFDLEVBQUEsQ0FDSixFQUNKLGdCQUFnQixJQUFJLElBQUksSUFBSUEsR0FBSSxDQUFBLEdBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxnQkFBZ0IsRUFBSyxDQUFBLENBQUEsRUFBQSxDQUN2QixHQUNqQyxDQUFBO0NBQ1YsQ0FBQyxDQUFDLENBQUM7Q0FFSCxNQUFNLGVBQWUsR0FBR3RsQixDQUFhLENBQStDLElBQUssQ0FBQyxDQUFDO0NBQzNGLE1BQU0sc0JBQXNCLEdBQUd3bEIsQ0FBSSxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLFdBQVcsRUFBOEUsS0FBSTtDQUNqSixJQUFBLElBQUksSUFBSSxHQUFHLENBQUEsT0FBQSxFQUFVLEtBQUssR0FBRyxDQUFDLENBQVUsT0FBQSxFQUFBLFFBQVEsR0FBRyxhQUFhLEdBQUcsRUFBRSxFQUFFLENBQUM7Q0FDeEUsSUFBQSxNQUFNLEVBQUUsUUFBUSxFQUFFLHdCQUF3QixFQUFFLEdBQUdDLEdBQVUsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO0tBQzlLLElBQUksR0FBRyxDQUFVLE9BQUEsRUFBQSxLQUFLLEdBQUcsQ0FBQyxDQUFVLE9BQUEsRUFBQSxRQUFRLEdBQUcsYUFBYSxHQUFHLEVBQUUsQ0FBQSxFQUFHLFFBQVEsR0FBRyxhQUFhLEdBQUcsRUFBRSxDQUFBLENBQUUsQ0FBQztLQUNwRyxPQUFPSCxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsR0FBUSx3QkFBd0IsQ0FBQyxFQUFFLENBQUMsRUFBRyxRQUFBLEVBQUEsSUFBSSxHQUFNLENBQUE7Q0FDNUQsQ0FBQyxDQUFDLENBQUM7Q0FFSCxNQUFNLFFBQVEsR0FBR0UsQ0FBSSxDQUFDLE1BQUs7S0FDdkIsTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDeEMsTUFBTSxPQUFPLEdBQUcsTUFBTSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDckMsTUFBTSxNQUFNLEdBQUcsTUFBTSxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7Q0FDbkMsSUFBQSxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLG1CQUFtQixFQUFFLEdBQUcsV0FBVyxDQUFtQixFQUFFLENBQUMsQ0FBQTtLQUVwRyxNQUFNLEVBQUUsYUFBYSxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsR0FBRyxXQUFXLENBQW9ELEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsbUJBQW1CLEVBQUUsQ0FBQyxDQUFDO0NBRXpMLElBQUEsTUFBTSxFQUFFLGtCQUFrQixFQUFFLEdBQUcsYUFBYSxDQUFvQixFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFBO0NBQ2xGLElBQUEsUUFDSUYsR0FBSyxDQUFBLEtBQUEsRUFBQSxFQUFBLEtBQUssRUFBQyxNQUFNLFlBQ2JELEdBQUMsQ0FBQSxlQUFlLENBQUMsUUFBUSxJQUFDLEtBQUssRUFBRSxXQUFXLEVBQUEsUUFBQSxFQUFBLENBQ3hDQyxtQkFBWSxrQkFBa0IsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsMEJBQW9CLEVBQzVGRCxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsR0FBUSxZQUFZLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxJQUFJLGFBQ3JEQyxHQUFDLENBQUEsWUFBWSxJQUFDLEtBQUssRUFBRSxDQUFDLEVBQUksQ0FBQSxFQUMxQkEsR0FBQyxDQUFBLFlBQVksSUFBQyxLQUFLLEVBQUUsQ0FBQyxFQUFBLENBQUksRUFDMUJBLEdBQUMsQ0FBQSxZQUFZLEVBQUMsRUFBQSxLQUFLLEVBQUUsQ0FBQyxFQUFBLENBQUksSUFDekIsQ0FDa0IsRUFBQSxDQUFBLEVBQUEsQ0FFekIsRUFDVDtDQUNMLENBQUMsQ0FBQyxDQUFDO0NBRUgsTUFBTSxZQUFZLEdBQUdFLENBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFxQixLQUFJO0NBQ3ZELElBQUEsTUFBTSxlQUFlLEdBQUdDLEdBQVUsQ0FBQyxlQUFlLENBQUMsQ0FBQztDQUNwRCxJQUFBLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxHQUFHLGVBQWUsQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztLQUNwRSxPQUFPSixHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsR0FBUSxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsc0JBQVEsS0FBSyxHQUFHLENBQUMsQ0FBQSxFQUFBLENBQU0sQ0FBQTtDQUM5RCxDQUFDLENBQUMsQ0FBQTtDQUVGLE1BQU0sVUFBVSxHQUFHcmxCLENBQWEsQ0FBb0MsSUFBSyxDQUFDLENBQUM7Q0FDM0UsTUFBTSxlQUFlLEdBQUdBLENBQWEsQ0FBb0MsSUFBSyxDQUFDLENBQUM7Q0FDaEYsTUFBTSxRQUFRLEdBQUd3bEIsQ0FBSSxDQUFDLE1BQUs7S0FDdkIsTUFBTSxDQUFDLGFBQWEsRUFBRSxnQkFBZ0IsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUN0RCxNQUFNLENBQUMsYUFBYSxFQUFFLGdCQUFnQixDQUFDLEdBQUcsUUFBUSxDQUF1QixPQUFPLENBQUMsQ0FBQztDQUVsRixJQUFBLE1BQU0sRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsR0FBRyxXQUFXLENBQXdELEVBQUUsUUFBUSxFQUFFLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsYUFBYSxDQUFDLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztDQUVyUCxJQUFBLE1BQU0sRUFBRSxlQUFlLEVBQUUsR0FBRyxXQUFXLEVBQUUsQ0FBQztDQUUxQyxJQUFBLFFBQ0lGLEdBQUMsQ0FBQSxVQUFVLENBQUMsUUFBUSxJQUFDLEtBQUssRUFBRSxNQUFNLEVBQUEsUUFBQSxFQUM5QkEsSUFBQyxlQUFlLENBQUMsUUFBUSxFQUFBLEVBQUMsS0FBSyxFQUFFLFdBQVcsRUFDeEMsUUFBQSxFQUFBRCxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUssS0FBSyxFQUFDLE1BQU0sRUFDYixRQUFBLEVBQUEsQ0FBQUEsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFPQyxlQUFPLElBQUksRUFBQyxVQUFVLEVBQUMsT0FBTyxFQUFFLGFBQWEsSUFBSSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxLQUFPLEVBQUEsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLEdBQUcsT0FBTyxHQUFHLFVBQVUsQ0FBQyxDQUFBLEVBQUUsRUFBSSxDQUFBLEVBQUEscUJBQUEsQ0FBQSxFQUFBLENBQTJCLEVBRXhNRCxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsR0FBUSxlQUFlLENBQUMsRUFBRSxDQUFDLEVBQUUsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQyxPQUFPLEVBQUMsRUFBQSxLQUFLLEVBQUUsQ0FBQyxHQUFJLEVBQUFBLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxLQUFLLEVBQUUsQ0FBQyxFQUFJLENBQUEsRUFBQUEsSUFBQyxPQUFPLEVBQUEsRUFBQyxLQUFLLEVBQUUsQ0FBQyxHQUFJLEVBQUFBLEdBQUEsQ0FBQyxPQUFPLEVBQUEsRUFBQyxLQUFLLEVBQUUsQ0FBQyxFQUFJLENBQUEsRUFBQUEsSUFBQyxPQUFPLEVBQUEsRUFBQyxLQUFLLEVBQUUsQ0FBQyxFQUFJLENBQUEsQ0FBQSxFQUFBLENBQUssRUFDM0lELEdBQUssQ0FBQSxLQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFDLFlBQVksRUFBQyxFQUFBLEtBQUssRUFBRSxDQUFDLEdBQUksRUFBQUEsR0FBQSxDQUFDLFlBQVksRUFBQSxFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUksQ0FBQSxFQUFBQSxJQUFDLFlBQVksRUFBQSxFQUFDLEtBQUssRUFBRSxDQUFDLEdBQUksRUFBQUEsR0FBQSxDQUFDLFlBQVksRUFBQSxFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUksQ0FBQSxFQUFBQSxJQUFDLFlBQVksRUFBQSxFQUFDLEtBQUssRUFBRSxDQUFDLEVBQUksQ0FBQSxDQUFBLEVBQUEsQ0FBTSxJQUMzSSxFQUNpQixDQUFBLEVBQUEsQ0FDVCxFQUN6QjtDQUNMLENBQUMsQ0FBQyxDQUFDO0NBRUgsTUFBTSxPQUFPLEdBQUdFLENBQUksQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFxQixLQUFJO0NBQ2xELElBQUEsTUFBTSxNQUFNLEdBQUdDLEdBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQztLQUN0QyxNQUFNLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxHQUFHLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFBO0NBRTFFLElBQUEsUUFBUUgsR0FDSixDQUFBSSxHQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUFMLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxHQUFRLFdBQVcsQ0FBQyxFQUFFLENBQUMsRUFBUSxRQUFBLEVBQUEsQ0FBQSxPQUFBLEVBQUEsS0FBSyxHQUFHLENBQUMsUUFBSSxDQUFhLFVBQUEsRUFBQSxRQUFRLEVBQUUsRUFBTyxHQUFBLENBQUEsRUFBQSxDQUFBLEVBQUEsQ0FDM0UsRUFBQztDQUNSLENBQUMs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
