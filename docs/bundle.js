(function () {
    'use strict';

    var n,
        l$1,
        u$1,
        t,
        o$2,
        r$2,
        f$1 = {},
        e$1 = [],
        c$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function s$1(n, l) {
      for (var u in l) n[u] = l[u];

      return n;
    }

    function a$1(n) {
      var l = n.parentNode;
      l && l.removeChild(n);
    }

    function h$1(l, u, i) {
      var t,
          o,
          r,
          f = {};

      for (r in u) "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];

      if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) void 0 === f[r] && (f[r] = l.defaultProps[r]);
      return v$1(l, f, t, o, null);
    }

    function v$1(n, i, t, o, r) {
      var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u$1 : r
      };
      return null == r && null != l$1.vnode && l$1.vnode(f), f;
    }

    function p$1(n) {
      return n.children;
    }

    function d$1(n, l) {
      this.props = n, this.context = l;
    }

    function _$2(n, l) {
      if (null == l) return n.__ ? _$2(n.__, n.__.__k.indexOf(n) + 1) : null;

      for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;

      return "function" == typeof n.type ? _$2(n) : null;
    }

    function k$1(n) {
      var l, u;

      if (null != (n = n.__) && null != n.__c) {
        for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
          n.__e = n.__c.base = u.__e;
          break;
        }

        return k$1(n);
      }
    }

    function b(n) {
      (!n.__d && (n.__d = !0) && t.push(n) && !g$2.__r++ || o$2 !== l$1.debounceRendering) && ((o$2 = l$1.debounceRendering) || setTimeout)(g$2);
    }

    function g$2() {
      for (var n; g$2.__r = t.length;) n = t.sort(function (n, l) {
        return n.__v.__b - l.__v.__b;
      }), t = [], n.some(function (n) {
        var l, u, i, t, o, r;
        n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = s$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? _$2(t) : o, t.__h), z$2(u, t), t.__e != o && k$1(t)));
      });
    }

    function w$2(n, l, u, i, t, o, r, c, s, a) {
      var h,
          y,
          d,
          k,
          b,
          g,
          w,
          x = i && i.__k || e$1,
          C = x.length;

      for (u.__k = [], h = 0; h < l.length; h++) if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? v$1(null, k, null, null, k) : Array.isArray(k) ? v$1(p$1, {
        children: k
      }, null, null, null) : k.__b > 0 ? v$1(k.type, k.props, k.key, k.ref ? k.ref : null, k.__v) : k)) {
        if (k.__ = u, k.__b = u.__b + 1, null === (d = x[h]) || d && k.key == d.key && k.type === d.type) x[h] = void 0;else for (y = 0; y < C; y++) {
          if ((d = x[y]) && k.key == d.key && k.type === d.type) {
            x[y] = void 0;
            break;
          }

          d = null;
        }
        j$2(n, k, d = d || f$1, t, o, r, c, s, a), b = k.__e, (y = k.ref) && d.ref != y && (w || (w = []), d.ref && w.push(d.ref, null, k), w.push(y, k.__c || b, k)), null != b ? (null == g && (g = b), "function" == typeof k.type && k.__k === d.__k ? k.__d = s = m$1(k, s, n) : s = A$1(n, k, d, x, b, s), "function" == typeof u.type && (u.__d = s)) : s && d.__e == s && s.parentNode != n && (s = _$2(d));
      }

      for (u.__e = g, h = C; h--;) null != x[h] && ("function" == typeof u.type && null != x[h].__e && x[h].__e == u.__d && (u.__d = _$2(i, h + 1)), N(x[h], x[h]));

      if (w) for (h = 0; h < w.length; h++) M$1(w[h], w[++h], w[++h]);
    }

    function m$1(n, l, u) {
      for (var i, t = n.__k, o = 0; t && o < t.length; o++) (i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? m$1(i, l, u) : A$1(u, i, i, t, i.__e, l));

      return l;
    }

    function x$1(n, l) {
      return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
        x$1(n, l);
      }) : l.push(n)), l;
    }

    function A$1(n, l, u, i, t, o) {
      var r, f, e;
      if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
        for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) if (f == t) break n;

        n.insertBefore(t, o), r = o;
      }
      return void 0 !== r ? r : t.nextSibling;
    }

    function C$2(n, l, u, i, t) {
      var o;

      for (o in u) "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);

      for (o in l) t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
    }

    function $$1(n, l, u) {
      "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || c$1.test(l) ? u : u + "px";
    }

    function H$1(n, l, u, i, t) {
      var o;

      n: if ("style" === l) {
        if ("string" == typeof u) n.style.cssText = u;else {
          if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || $$1(n.style, l, "");
          if (u) for (l in u) i && u[l] === i[l] || $$1(n.style, l, u[l]);
        }
      } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$2 : I$1, o) : n.removeEventListener(l, o ? T$2 : I$1, o);else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
          n[l] = null == u ? "" : u;
          break n;
        } catch (n) {}
        "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
      }
    }

    function I$1(n) {
      this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
    }

    function T$2(n) {
      this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
    }

    function j$2(n, u, i, t, o, r, f, e, c) {
      var a,
          h,
          v,
          y,
          _,
          k,
          b,
          g,
          m,
          x,
          A,
          C,
          $,
          H = u.type;

      if (void 0 !== u.constructor) return null;
      null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (a = l$1.__b) && a(u);

      try {
        n: if ("function" == typeof H) {
          if (g = u.props, m = (a = H.contextType) && t[a.__c], x = a ? m ? m.props.value : a.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in H && H.prototype.render ? u.__c = h = new H(g, x) : (u.__c = h = new d$1(g, x), h.constructor = H, h.render = O$1), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != H.getDerivedStateFromProps && (h.__s == h.state && (h.__s = s$1({}, h.__s)), s$1(h.__s, H.getDerivedStateFromProps(g, h.__s))), y = h.props, _ = h.state, v) null == H.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
            if (null == H.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
              h.props = g, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
                n && (n.__ = u);
              }), h.__h.length && f.push(h);
              break n;
            }

            null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
              h.componentDidUpdate(y, _, k);
            });
          }
          if (h.context = x, h.props = g, h.__v = u, h.__P = n, A = l$1.__r, C = 0, "prototype" in H && H.prototype.render) h.state = h.__s, h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context);else do {
            h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
          } while (h.__d && ++C < 25);
          h.state = h.__s, null != h.getChildContext && (t = s$1(s$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, _)), $ = null != a && a.type === p$1 && null == a.key ? a.props.children : a, w$2(n, Array.isArray($) ? $ : [$], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);

        (a = l$1.diffed) && a(u);
      } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
      }
    }

    function z$2(n, u) {
      l$1.__c && l$1.__c(u, n), n.some(function (u) {
        try {
          n = u.__h, u.__h = [], n.some(function (n) {
            n.call(u);
          });
        } catch (n) {
          l$1.__e(n, u.__v);
        }
      });
    }

    function L$1(l, u, i, t, o, r, e, c) {
      var s,
          h,
          v,
          y = i.props,
          p = u.props,
          d = u.type,
          k = 0;
      if ("svg" === d && (o = !0), null != r) for (; k < r.length; k++) if ((s = r[k]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
        l = s, r[k] = null;
        break;
      }

      if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
      }

      if (null === d) y === p || c && l.data === p || (l.data = p);else {
        if (r = r && n.call(l.childNodes), h = (y = i.props || f$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
          if (null != r) for (y = {}, k = 0; k < l.attributes.length; k++) y[l.attributes[k].name] = l.attributes[k].value;
          (v || h) && (v && (h && v.__html == h.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }

        if (C$2(l, p, y, o, c), v) u.__k = [];else if (k = u.props.children, w$2(l, Array.isArray(k) ? k : [k], u, i, t, o && "foreignObject" !== d, r, e, r ? r[0] : i.__k && _$2(i, 0), c), null != r) for (k = r.length; k--;) null != r[k] && a$1(r[k]);
        c || ("value" in p && void 0 !== (k = p.value) && (k !== l.value || "progress" === d && !k || "option" === d && k !== y.value) && H$1(l, "value", k, y.value, !1), "checked" in p && void 0 !== (k = p.checked) && k !== l.checked && H$1(l, "checked", k, y.checked, !1));
      }
      return l;
    }

    function M$1(n, u, i) {
      try {
        "function" == typeof n ? n(u) : n.current = u;
      } catch (n) {
        l$1.__e(n, i);
      }
    }

    function N(n, u, i) {
      var t, o;

      if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$1(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
          t.componentWillUnmount();
        } catch (n) {
          l$1.__e(n, u);
        }
        t.base = t.__P = null, n.__c = void 0;
      }

      if (t = n.__k) for (o = 0; o < t.length; o++) t[o] && N(t[o], u, "function" != typeof n.type);
      i || null == n.__e || a$1(n.__e), n.__ = n.__e = n.__d = void 0;
    }

    function O$1(n, l, u) {
      return this.constructor(n, u);
    }

    function P$1(u, i, t) {
      var o, r, e;
      l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, e = [], j$2(i, u = (!o && t || i).__k = h$1(p$1, null, [u]), r || f$1, f$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, e, !o && t ? t : r ? r.__e : i.firstChild, o), z$2(e, u);
    }

    function B$2(n, l) {
      var u = {
        __c: l = "__cC" + r$2++,
        __: n,
        Consumer: function (n, l) {
          return n.children(l);
        },
        Provider: function (n) {
          var u, i;
          return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
            return i;
          }, this.shouldComponentUpdate = function (n) {
            this.props.value !== n.value && u.some(b);
          }, this.sub = function (n) {
            u.push(n);
            var l = n.componentWillUnmount;

            n.componentWillUnmount = function () {
              u.splice(u.indexOf(n), 1), l && l.call(n);
            };
          }), n.children;
        }
      };
      return u.Provider.__ = u.Consumer.contextType = u;
    }

    n = e$1.slice, l$1 = {
      __e: function (n, l, u, i) {
        for (var t, o, r; l = l.__;) if ((t = l.__c) && !t.__) try {
          if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), r) return t.__E = t;
        } catch (l) {
          n = l;
        }

        throw n;
      }
    }, u$1 = 0, d$1.prototype.setState = function (n, l) {
      var u;
      u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s$1({}, this.state), "function" == typeof n && (n = n(s$1({}, u), this.props)), n && s$1(u, n), null != n && this.__v && (l && this.__h.push(l), b(this));
    }, d$1.prototype.forceUpdate = function (n) {
      this.__v && (this.__e = !0, n && this.__h.push(n), b(this));
    }, d$1.prototype.render = p$1, t = [], g$2.__r = 0, r$2 = 0;

    var _$1 = 0;

    function o$1(o, e, n, t, f) {
      var l,
          s,
          u = {};

      for (s in e) "ref" == s ? l = e[s] : u[s] = e[s];

      var a = {
        type: o,
        props: u,
        key: n,
        ref: l,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: --_$1,
        __source: f,
        __self: t
      };
      if ("function" == typeof o && (l = o.defaultProps)) for (s in l) void 0 === u[s] && (u[s] = l[s]);
      return l$1.vnode && l$1.vnode(a), a;
    }

    var r$1,
        u,
        i,
        o,
        f = 0,
        c = [],
        e = [],
        a = l$1.__b,
        v = l$1.__r,
        l = l$1.diffed,
        m = l$1.__c,
        d = l$1.unmount;

    function p(t, r) {
      l$1.__h && l$1.__h(u, t, f || r), f = 0;
      var i = u.__H || (u.__H = {
        __: [],
        __h: []
      });
      return t >= i.__.length && i.__.push({
        __V: e
      }), i.__[t];
    }

    function y(n) {
      return f = 1, h(C$1, n);
    }

    function h(n, t, i) {
      var o = p(r$1++, 2);

      if (o.t = n, !o.__c && (o.__ = [i ? i(t) : C$1(void 0, t), function (n) {
        var t = o.__N ? o.__N[0] : o.__[0],
            r = o.t(t, n);
        t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
      }], o.__c = u, !u.u)) {
        u.u = !0;
        var f = u.shouldComponentUpdate;

        u.shouldComponentUpdate = function (n, t, r) {
          if (!o.__c.__H) return !0;

          var u = o.__c.__H.__.filter(function (n) {
            return n.__c;
          });

          if (u.every(function (n) {
            return !n.__N;
          })) return !f || f.call(this, n, t, r);
          var i = !1;
          return u.forEach(function (n) {
            if (n.__N) {
              var t = n.__[0];
              n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
            }
          }), !!i && (!f || f.call(this, n, t, r));
        };
      }

      return o.__N || o.__;
    }

    function s(t, i) {
      var o = p(r$1++, 3);
      !l$1.__s && B$1(o.__H, i) && (o.__ = t, o.i = i, u.__H.__h.push(o));
    }

    function _(t, i) {
      var o = p(r$1++, 4);
      !l$1.__s && B$1(o.__H, i) && (o.__ = t, o.i = i, u.__h.push(o));
    }

    function A(n) {
      return f = 5, T$1(function () {
        return {
          current: n
        };
      }, []);
    }

    function T$1(n, t) {
      var u = p(r$1++, 7);
      return B$1(u.__H, t) ? (u.__V = n(), u.i = t, u.__h = n, u.__V) : u.__;
    }

    function q$1(n, t) {
      return f = 8, T$1(function () {
        return n;
      }, t);
    }

    function x(n) {
      var t = u.context[n.__c],
          i = p(r$1++, 9);
      return i.c = n, t ? (null == i.__ && (i.__ = !0, t.sub(u)), t.props.value) : n.__;
    }

    function g$1() {
      for (var t; t = c.shift();) if (t.__P && t.__H) try {
        t.__H.__h.forEach(w$1), t.__H.__h.forEach(z$1), t.__H.__h = [];
      } catch (r) {
        t.__H.__h = [], l$1.__e(r, t.__v);
      }
    }

    l$1.__b = function (n) {
      "function" != typeof n.type || n.o || n.type === p$1 ? n.o || (n.o = n.__ && n.__.o ? n.__.o : "") : n.o = (n.__ && n.__.o ? n.__.o : "") + (n.__ && n.__.__k ? n.__.__k.indexOf(n) : 0), u = null, a && a(n);
    }, l$1.__r = function (n) {
      v && v(n), r$1 = 0;
      var t = (u = n.__c).__H;
      t && (i === u ? (t.__h = [], u.__h = [], t.__.forEach(function (n) {
        n.__N && (n.__ = n.__N), n.__V = e, n.__N = n.i = void 0;
      })) : (t.__h.forEach(w$1), t.__h.forEach(z$1), t.__h = [])), i = u;
    }, l$1.diffed = function (t) {
      l && l(t);
      var r = t.__c;
      r && r.__H && (r.__H.__h.length && (1 !== c.push(r) && o === l$1.requestAnimationFrame || ((o = l$1.requestAnimationFrame) || k)(g$1)), r.__H.__.forEach(function (n) {
        n.i && (n.__H = n.i), n.__V !== e && (n.__ = n.__V), n.i = void 0, n.__V = e;
      })), i = u = null;
    }, l$1.__c = function (t, r) {
      r.some(function (t) {
        try {
          t.__h.forEach(w$1), t.__h = t.__h.filter(function (n) {
            return !n.__ || z$1(n);
          });
        } catch (u) {
          r.some(function (n) {
            n.__h && (n.__h = []);
          }), r = [], l$1.__e(u, t.__v);
        }
      }), m && m(t, r);
    }, l$1.unmount = function (t) {
      d && d(t);
      var r,
          u = t.__c;
      u && u.__H && (u.__H.__.forEach(function (n) {
        try {
          w$1(n);
        } catch (n) {
          r = n;
        }
      }), u.__H = void 0, r && l$1.__e(r, u.__v));
    };
    var j$1 = "function" == typeof requestAnimationFrame;

    function k(n) {
      var t,
          r = function () {
        clearTimeout(u), j$1 && cancelAnimationFrame(t), setTimeout(n);
      },
          u = setTimeout(r, 100);

      j$1 && (t = requestAnimationFrame(r));
    }

    function w$1(n) {
      var t = u,
          r = n.__c;
      "function" == typeof r && (n.__c = void 0, r()), u = t;
    }

    function z$1(n) {
      var t = u;
      n.__c = n.__(), u = t;
    }

    function B$1(n, t) {
      return !n || n.length !== t.length || t.some(function (t, r) {
        return t !== n[r];
      });
    }

    function C$1(n, t) {
      return "function" == typeof t ? t(n) : t;
    }

    function g(n, t) {
      for (var e in t) n[e] = t[e];

      return n;
    }

    function C(n, t) {
      for (var e in n) if ("__source" !== e && !(e in t)) return !0;

      for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;

      return !1;
    }

    function E(n) {
      this.props = n;
    }

    function w(n, e) {
      function r(n) {
        var t = this.props.ref,
            r = t == n.ref;
        return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : C(this.props, n);
      }

      function u(e) {
        return this.shouldComponentUpdate = r, h$1(n, e);
      }

      return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = !0, u.__f = !0, u;
    }

    (E.prototype = new d$1()).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function (n, t) {
      return C(this.props, n) || C(this.state, t);
    };
    var R = l$1.__b;

    l$1.__b = function (n) {
      n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), R && R(n);
    };

    var O = l$1.__e;

    l$1.__e = function (n, t, e, r) {
      if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
      O(n, t, e, r);
    };

    var T = l$1.unmount;

    function I(n, t, e) {
      return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
        "function" == typeof n.__c && n.__c();
      }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
        return I(n, t, e);
      })), n;
    }

    function L(n, t, e) {
      return n && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
        return L(n, t, e);
      }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
    }

    function U() {
      this.__u = 0, this.t = null, this.__b = null;
    }

    function D(n) {
      var t = n.__.__c;
      return t && t.__a && t.__a(n);
    }

    function M() {
      this.u = null, this.o = null;
    }

    l$1.unmount = function (n) {
      var t = n.__c;
      t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), T && T(n);
    }, (U.prototype = new d$1()).__c = function (n, t) {
      var e = t.__c,
          r = this;
      null == r.t && (r.t = []), r.t.push(e);

      var u = D(r.__v),
          o = !1,
          i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };

      e.__R = i;

      var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;
            r.__v.__k[0] = L(n, n.__c.__P, n.__c.__O);
          }

          var t;

          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
          c = !0 === t.__h;

      r.__u++ || c || r.setState({
        __a: r.__b = r.__v.__k[0]
      }), n.then(i, i);
    }, U.prototype.componentWillUnmount = function () {
      this.t = [];
    }, U.prototype.render = function (n, e) {
      if (this.__b) {
        if (this.__v.__k) {
          var r = document.createElement("div"),
              o = this.__v.__k[0].__c;
          this.__v.__k[0] = I(this.__b, r, o.__O = o.__P);
        }

        this.__b = null;
      }

      var i = e.__a && h$1(p$1, null, n.fallback);
      return i && (i.__h = null), [h$1(p$1, null, e.__a ? null : n.children), i];
    };

    var V = function (n, t, e) {
      if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
        for (; e.length > 3;) e.pop()();

        if (e[1] < e[0]) break;
        n.u = e = e[2];
      }
    };

    function W(n) {
      return this.getChildContext = function () {
        return n.context;
      }, n.children;
    }

    function P(n) {
      var e = this,
          r = n.i;
      e.componentWillUnmount = function () {
        P$1(null, e.l), e.l = null, e.i = null;
      }, e.i && e.i !== r && e.componentWillUnmount(), n.__v ? (e.l || (e.i = r, e.l = {
        nodeType: 1,
        parentNode: r,
        childNodes: [],
        appendChild: function (n) {
          this.childNodes.push(n), e.i.appendChild(n);
        },
        insertBefore: function (n, t) {
          this.childNodes.push(n), e.i.appendChild(n);
        },
        removeChild: function (n) {
          this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), e.i.removeChild(n);
        }
      }), P$1(h$1(W, {
        context: e.context
      }, n.__v), e.l)) : e.l && e.componentWillUnmount();
    }

    function $(n, e) {
      var r = h$1(P, {
        __v: n,
        i: e
      });
      return r.containerInfo = e, r;
    }

    (M.prototype = new d$1()).__a = function (n) {
      var t = this,
          e = D(t.__v),
          r = t.o.get(n);
      return r[0]++, function (u) {
        var o = function () {
          t.props.revealOrder ? (r.push(u), V(t, n, r)) : u();
        };

        e ? e(o) : o();
      };
    }, M.prototype.render = function (n) {
      this.u = null, this.o = new Map();
      var t = x$1(n.children);
      n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

      for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);

      return n.children;
    }, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function () {
      var n = this;
      this.o.forEach(function (t, e) {
        V(n, e, t);
      });
    };

    var j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        z = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        B = "undefined" != typeof document,
        H = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };

    d$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
      Object.defineProperty(d$1.prototype, t, {
        configurable: !0,
        get: function () {
          return this["UNSAFE_" + t];
        },
        set: function (n) {
          Object.defineProperty(this, t, {
            configurable: !0,
            writable: !0,
            value: n
          });
        }
      });
    });
    var q = l$1.event;

    function G() {}

    function J() {
      return this.cancelBubble;
    }

    function K() {
      return this.defaultPrevented;
    }

    l$1.event = function (n) {
      return q && (n = q(n)), n.persist = G, n.isPropagationStopped = J, n.isDefaultPrevented = K, n.nativeEvent = n;
    };

    var X = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
        nn = l$1.vnode;

    l$1.vnode = function (n) {
      var t = n.type,
          e = n.props,
          u = e;

      if ("string" == typeof t) {
        var o = -1 === t.indexOf("-");

        for (var i in u = {}, e) {
          var l = e[i];
          B && "children" === i && "noscript" === t || "value" === i && "defaultValue" in e && null == l || ("defaultValue" === i && "value" in e && null == e.value ? i = "value" : "download" === i && !0 === l ? l = "" : /ondoubleclick/i.test(i) ? i = "ondblclick" : /^onchange(textarea|input)/i.test(i + t) && !H(e.type) ? i = "oninput" : /^onfocus$/i.test(i) ? i = "onfocusin" : /^onblur$/i.test(i) ? i = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && z.test(i) ? i = i.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = "oninputCapture")), u[i] = l);
        }

        "select" == t && u.multiple && Array.isArray(u.value) && (u.value = x$1(e.children).forEach(function (n) {
          n.props.selected = -1 != u.value.indexOf(n.props.value);
        })), "select" == t && null != u.defaultValue && (u.value = x$1(e.children).forEach(function (n) {
          n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
        })), n.props = u, e.class != e.className && (X.enumerable = "className" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, "className", X));
      }

      n.$$typeof = j, nn && nn(n);
    };

    var tn = l$1.__r;

    l$1.__r = function (n) {
      tn && tn(n), n.__c;
    };

    const EventDetail = Symbol("event-detail");
    function enhanceEvent(e, detail) {
      const event = e;
      event[EventDetail] = detail;
      return event;
    }
    const alreadyWarned = new Set();
    function warnOnOverwrite(componentName, propName, propValue, newValue) {
      const key = `${componentName};${propName}`;

      if (propValue != null) {
        if (!alreadyWarned.has(key)) {
          alreadyWarned.add(key);
          console.warn(`The ${propName} attribute on ${componentName} was given a value of ${propValue} but is being overwritten to ${newValue} for conformance. Consider removing it before passing those props to ${componentName}.`);
        }
      }

      return newValue;
    }
    function debugLog(who) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
    }

    const HeadingLevelContext = B$2(0);
    const Heading = w(function Heading(_ref) {
      let {
        children,
        heading,
        ...props
      } = _ref;
      const headingLevelBeforeUs = x(HeadingLevelContext);
      const newHeadingLevel = headingLevelBeforeUs + 1;
      let tag;

      if (newHeadingLevel <= 6) {
        tag = `h${newHeadingLevel}`;
      } else {
        tag = 'div';
        props["aria-level"] = warnOnOverwrite("Heading", "aria-level", props["aria-level"], `${newHeadingLevel}`);
      }

      return o$1(p$1, {
        children: o$1(HeadingReset, {
          newLevel: headingLevelBeforeUs + 1,
          children: [h$1(tag, props, heading), children]
        })
      });
    });
    const HeadingReset = w(function HeadingReset(_ref2) {
      let {
        newLevel,
        children
      } = _ref2;
      return o$1(HeadingLevelContext.Provider, {
        value: newLevel,
        children: children
      });
    });

    /**
     * Debug hook.
     *
     * Given a value or set of values, emits a console error if any of them change from one render to the next.
     *
     * Eventually, when useEvent lands, we hopefully won't need this.
     */

    function useEnsureStability(parentHookName) {
      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }

      useHelper(values.length, 0);
      values.forEach(useHelper);
      return;

      function useHelper(value, index) {
        // Make sure that the provided functions are perfectly stable across renders
        const helperToEnsureStability = A(value);
        const shownError = A(false);

        if (helperToEnsureStability.current != value) {
          if (!shownError.current) {
            /* eslint-disable no-debugger */
            debugger;
            console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
            shownError.current = true;
          }
        }
      }
    }
    function debounceRendering(f) {
      var _options$debounceRend;

      ((_options$debounceRend = l$1.debounceRendering) !== null && _options$debounceRend !== void 0 ? _options$debounceRend : setTimeout)(f);
    }
    /**
     * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
     *
     * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
     *
     * To summarize, it's like a `useState`-`useEffect` mashup:
     *
     * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
     * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
     * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
     * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
     *
     * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
     *
     * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
     * @returns
     */

    function usePassiveState(onChange, getInitialValue, customDebounceRendering) {
      const valueRef = A(Unset$1);
      const warningRef = A(false);
      const cleanupCallbackRef = A(undefined); // Make sure that the provided functions are perfectly stable across renders

      useEnsureStability("usePassiveState", onChange, getInitialValue, customDebounceRendering); // Shared between "dependency changed" and "component unmounted".

      const onShouldCleanUp = q$1(() => {
        const cleanupCallback = cleanupCallbackRef.current;
        if (cleanupCallback) cleanupCallback();
      }, []); // There are a couple places where we'd like to use our initial
      // value in place of having no value at all yet.
      // This is the shared code for that, used on mount and whenever
      // getValue is called.

      const tryEnsureValue = q$1(() => {
        if (valueRef.current === Unset$1 && getInitialValue != undefined) {
          try {
            var _onChange;

            const initialValue = getInitialValue();
            valueRef.current = initialValue;
            cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
          } catch (ex) {// Exceptions are intentional to allow bailout (without exposing the Unset symbol)
          }
        }
      }, [
        /* getInitialValue and onChange intentionally omitted */
      ]);
      const getValue = q$1(() => {
        if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component."); // The first time we call getValue, if we haven't been given a value yet,
        // (and we were given an initial value to use)
        // return the initial value instead of nothing.

        if (valueRef.current === Unset$1) tryEnsureValue();
        return valueRef.current === Unset$1 ? undefined : valueRef.current;
      }, []);
      _(() => {
        // Make sure we've run our effect at least once on mount.
        // (If we have an initial value, of course)
        tryEnsureValue();
      }, []); // The actual code the user calls to (possibly) run a new effect.

      const r = A({
        prevDep: Unset$1
      });
      const setValue = q$1(arg => {
        // Regardless of anything else, figure out what our next value is about to be.
        const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg;

        if (r.current.prevDep === Unset$1 && nextValue !== valueRef.current) {
          // This is the first request to change this value.
          // Evaluate the request immediately, then queue up the onChange function
          // Save our current value so that we can compare against it later
          // (if we flip back to this state, then we won't send the onChange function)
          r.current.prevDep = valueRef.current; // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately

          valueRef.current = nextValue; // Schedule the actual check and invocation of onChange later to let effects settle

          (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering)(() => {
            const nextDep = valueRef.current;
            const prevDep = r.current.prevDep;

            if (r.current.prevDep != valueRef.current) {
              warningRef.current = true;

              try {
                var _onChange2;

                // Call any registered cleanup function
                onShouldCleanUp();
                cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$1 ? undefined : prevDep)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
                valueRef.current = nextDep;
              } finally {
                // Allow the user to normally call getValue again
                warningRef.current = false;
              }
            } // We've finished with everything, so mark us as being on a clean slate again.


            r.current.prevDep = Unset$1;
          });
        } // Update the value immediately.
        // This will be checked against prevDep to see if we should actually call onChange


        valueRef.current = nextValue;
      }, []);
      return [getValue, setValue];
    }
    const Unset$1 = Symbol(); // Easy constants for getInitialValue

    function returnTrue() {
      return true;
    }
    function returnFalse$1() {
      return false;
    }
    function returnNull() {
      return null;
    }

    /*
    const activeElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node | null) => void)>>();
    const lastActiveElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node) => void)>>();
    const windowFocusedUpdaters = new Map<Window | null | undefined, Set<undefined | ((focused: boolean) => void)>>();
    const windowsFocusedUpdaters = new Map<Window | null | undefined, boolean>();*/

    const activeElementUpdaters = new Map();
    const lastActiveElementUpdaters = new Map();
    const windowFocusedUpdaters = new Map();
    const windowsFocusedUpdaters = new Map(); //const microtasks = new Map<Set<any>, any>();
    // The focusin and focusout events often fire syncronously in the middle of running code.
    // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
    // For the purpose of improving stability, we debounce all focus events to the next microtask.

    function forEachUpdater(window, map, value) {
      const updaters = map.get(window);

      if (updaters) {
        //if (!microtasks.has(updatersKey)) {
        //debounceRendering(() => {
        //const updatersKey = map.get(window)!;
        //const value = microtasks.get(updatersKey);
        //microtasks.delete(updatersKey);
        if (updaters) {
          for (const updater of updaters) {
            const {
              lastSent,
              send
            } = updater;

            if (value !== lastSent) {
              send(value);
              updater.lastSent = value;
            }
          }
        } //});
        //}
        //microtasks.set(updatersKey, value);

      }
    }

    function focusout(e) {
      const window = e.target.ownerDocument.defaultView;

      if (e.relatedTarget == null) {
        forEachUpdater(window, activeElementUpdaters, null);
      }
    }

    function focusin(e) {
      const window = e.target.ownerDocument.defaultView;
      const currentlyFocusedElement = e.target;
      forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
      forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
    }

    function windowFocus(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, true);
      forEachUpdater(window, windowFocusedUpdaters, true);
    }

    function windowBlur(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, false);
      forEachUpdater(window, windowFocusedUpdaters, false);
    }
    /**
     * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
     * * `getActiveElement()`
     * * `getLastActiveElement()`
     * * `getWindowFocused()`
     *
     * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
     *
     * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
     *
     * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
     */


    function useActiveElement(_ref) {
      let {
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        getDocument,
        getWindow
      } = _ref;
      useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, getDocument, getWindow);
      s(() => {
        var _getWindow, _activeElementUpdater, _activeElementUpdater2, _activeElementUpdater3, _lastActiveElementUpd, _windowFocusedUpdater;

        const document = getDocument();
        const window = (_getWindow = getWindow === null || getWindow === void 0 ? void 0 : getWindow(document)) !== null && _getWindow !== void 0 ? _getWindow : document === null || document === void 0 ? void 0 : document.defaultView;

        if (((_activeElementUpdater = (_activeElementUpdater2 = activeElementUpdaters.get(window)) === null || _activeElementUpdater2 === void 0 ? void 0 : _activeElementUpdater2.size) !== null && _activeElementUpdater !== void 0 ? _activeElementUpdater : 0) === 0) {
          document === null || document === void 0 ? void 0 : document.addEventListener("focusin", focusin, {
            passive: true
          });
          document === null || document === void 0 ? void 0 : document.addEventListener("focusout", focusout, {
            passive: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("focus", windowFocus, {
            passive: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("blur", windowBlur, {
            passive: true
          });
        } // Add them even if they're undefined to more easily
        // manage the ">0 means don't add handlers" logic.


        const localActiveElementUpdaters = (_activeElementUpdater3 = activeElementUpdaters.get(window)) !== null && _activeElementUpdater3 !== void 0 ? _activeElementUpdater3 : new Set();
        const localLastActiveElementUpdaters = (_lastActiveElementUpd = lastActiveElementUpdaters.get(window)) !== null && _lastActiveElementUpd !== void 0 ? _lastActiveElementUpd : new Set();
        const localWindowFocusedUpdaters = (_windowFocusedUpdater = windowFocusedUpdaters.get(window)) !== null && _windowFocusedUpdater !== void 0 ? _windowFocusedUpdater : new Set();
        const laeu = {
          send: setActiveElement,
          lastSent: undefined
        };
        const llaeu = {
          send: setLastActiveElement,
          lastSent: undefined
        };
        const lwfu = {
          send: setWindowFocused,
          lastSent: undefined
        };
        localActiveElementUpdaters.add(laeu);
        localLastActiveElementUpdaters.add(llaeu);
        localWindowFocusedUpdaters.add(lwfu);
        activeElementUpdaters.set(window, localActiveElementUpdaters);
        lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
        windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
        return () => {
          activeElementUpdaters.get(window).delete(laeu);
          lastActiveElementUpdaters.get(window).delete(laeu);
          windowFocusedUpdaters.get(window).delete(lwfu);

          if (activeElementUpdaters.size === 0) {
            document === null || document === void 0 ? void 0 : document.removeEventListener("focusin", focusin);
            document === null || document === void 0 ? void 0 : document.removeEventListener("focusout", focusout);
            window === null || window === void 0 ? void 0 : window.removeEventListener("focus", windowFocus);
            window === null || window === void 0 ? void 0 : window.removeEventListener("blur", windowBlur);
          }
        };
      }, []);
      const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
      const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
      const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
      return {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }

    const Table$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";

    function base64(value) {
      return Table$1[value];
    }

    function random6Bits() {
      return Math.floor(Math.random() * 0b1000000);
    }

    function random64Bits() {
      return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     *
     *
     * (This is here, in this particular file, to avoid circular dependencies
     * without also making a utilities file.
     * Once we can remove this hook, we can put this function back with useRandomId)
     */


    function generateRandomId(prefix) {
      return `${prefix !== null && prefix !== void 0 ? prefix : "id-"}${random64Bits().map(n => base64(n)).join("")}`;
    }
    const previousInputs = new Map();
    const toRun = new Map(); // TODO: Whether this goes in options.diffed or options._commit
    // is a post-suspense question.
    // Right now, using options._commit has the problem of running
    // *after* refs are applied, but we need to come before even that
    // so `ref={someStableFunction}` works.
    // 
    // Also it's private.
    //
    // ...
    // Well, useEvent or whatever is finally, finally 4 years later finally here
    // which is cool and means we won't need this at all soon.
    // So for now we'll stick with diff to prevent any weirdness with
    // commit being private and all.

    const commitName = "diffed";
    const originalCommit = l$1[commitName];

    const newCommit = function () {
      for (const [id, effectInfo] of toRun) {
        const oldInputs = previousInputs.get(id);

        if (argsChanged(oldInputs, effectInfo.inputs)) {
          var _effectInfo$cleanup;

          (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
          effectInfo.cleanup = effectInfo.effect();
          previousInputs.set(id, effectInfo.inputs);
        }
      }

      toRun.clear();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
    };

    l$1[commitName] = newCommit;
    /**
     * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
     *
     * Every render, we send the arguments to be evaluated after diffing has completed,
     * which happens before.
     *
     * @param effect
     * @param inputs
     */

    function useBeforeLayoutEffect(effect, inputs) {
      /*(() => {
          const cleanup = useRef<void | (() => void) | null>(null);
          const prevArgsRef = useRef<Inputs>(null!);
          if (argsChanged(inputs, prevArgsRef.current)) {
              prevArgsRef.current = inputs!;
              if (cleanup.current)
                  cleanup.current();
              cleanup.current = effect();
          }
      })();*/
      const [id] = y(() => generateRandomId());
      toRun.set(id, {
        effect,
        inputs,
        cleanup: null
      });
      s(() => {
        return () => {
          toRun.delete(id);
          previousInputs.delete(id);
        };
      }, [id]);
    }

    function argsChanged(oldArgs, newArgs) {
      return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
    }

    const Unset = Symbol("unset");
    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * This uses `options.diffed` in order to run before everything, even
     * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
     *
     * @param value
     * @returns
     */

    function useStableGetter(value) {
      const ref = A(Unset);
      useBeforeLayoutEffect(() => {
        ref.current = value;
      }, [value]);
      return q$1(() => {
        if (ref.current === Unset) {
          throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
        }

        return ref.current;
      }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * Do not use during the render phase!  `useLayoutEffect` is fine though.
     */

    function useStableCallback(fn) {
      const currentCallbackGetter = useStableGetter(fn);
      return q$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []);
    }

    B$2(null);

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */

    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();

    /** Built-in value references. */

    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */

    var objectProto$5 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var nativeObjectToString$1 = objectProto$5.toString;
    /** Built-in value references. */

    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */

    function getRawTag(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);

      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }

      return result;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var nativeObjectToString = objectProto$4.toString;
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */

    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /** `Object#toString` result references. */

    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';
    /** Built-in value references. */

    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */

    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }

      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */

    function useState(initialState) {
      // We keep both, but overrride the `setState` functionality
      const [state, setStateP] = y(initialState);
      const ref = A(state); // Hijack the normal setter function 
      // to also set our ref to the new value

      const setState = q$1(value => {
        if (typeof value === "function") {
          const callback = value;
          setStateP(prevValue => {
            const nextValue = callback(prevValue);
            ref.current = nextValue;
            return nextValue;
          });
        } else {
          ref.current = value;
          setStateP(value);
        }
      }, []);

      const getState = () => {
        return ref.current;
      };

      console.assert(ref.current === state || typeof state === "number" && isNaN(state));
      return [state, setState, getState];
    }

    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is designed to be lightweight, in that the parent keeps no state
     * and runs no effects.  Each child *does* run an effect, but with no state
     * changes unless you explicitly request them.
     *
     *
     */


    function useManagedChildren(parentParameters) {
      const {
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters;
      useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
      const getHighestIndex = q$1(() => {
        return managedChildrenArray.current.highestIndex;
      }, []); // All the information we have about our children is stored in this **stable** array.
      // Any mutations to this array **DO NOT** trigger any sort of a re-render.

      const managedChildrenArray = A({
        arr: [],
        rec: {},
        highestIndex: 0,
        lowestIndex: 0
      }); // For indirect access to each child
      // Compare getManagedChildInfo
      // TODO: The primary use for this is flaggable closest fits
      // which needs to search all children for that closest fit.
      // It would be nice if there was something better for that.

      const forEachChild = q$1(f => {
        for (const child of managedChildrenArray.current.arr) {
          if (child) f(child);
        }

        for (const field in managedChildrenArray.current.rec) {
          const child = managedChildrenArray.current.rec[field];
          if (child) f(child);
        }
      }, []); // Retrieves the information associated with the child with the given index.
      // `undefined` if not child there, or it's unmounted.

      const getManagedChildInfo = q$1(index => {
        if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
      }, []); // tl;dr this is a way to have run useLayoutEffect once after all N children
      // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
      // ourselves because of having a `childCount` state or anything similar.
      //
      // When the child count ref updates, we want the parent to also run an effect
      // to maybe do something with all these children that just mounted.
      // The easiest way would be useEffect(..., [childCount]) but
      // that would require us having a childCount state, then calling
      // setChildCount and re-rendering every time children mount
      // (only one re-render at a time unless children are staggered, but still)
      // 
      // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
      // to emulate running ULE on the parent. Only the first child will actually queue
      // the microtask (by checking hasRemoteULE first) so that the "effect" only
      // runs once. When it's done, hasRemoteULE is reset so it can run again if
      // more children mount/unmount.

      const hasRemoteULEChildMounted = A(null);
      const remoteULEChildChangedCausers = A(new Set());
      const remoteULEChildChanged = q$1(index => {
        if (remoteULEChildChangedCausers.current.size == 0) {
          debounceRendering(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }

        remoteULEChildChangedCausers.current.add(index);
        return () => {};
      }, [
        /* Must remain stable */
      ]);
      const remoteULEChildMounted = q$1((index, mounted) => {
        if (!hasRemoteULEChildMounted.current) {
          hasRemoteULEChildMounted.current = {
            mounts: new Set(),
            unmounts: new Set()
          };
          debounceRendering(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            hasRemoteULEChildMounted.current = null;
          });
        }

        if (mounted) {
          managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
        } else {
          if (typeof index == "number") {
            delete managedChildrenArray.current.arr[index];
            let shave = 0;

            while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
              ++shave;
            }

            managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
          } else delete managedChildrenArray.current.rec[index];
        }

        hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
      }, [
        /* Must remain stable */
      ]);
      const useManagedChild = q$1(_ref => {
        let {
          managedChild: info
        } = _ref;
        // Any time our child props change, make that information available
        // the parent if they need it.
        // The parent can listen for all updates and only act on the ones it cares about,
        // and multiple children updating in the same tick will all be sent at once.
        _(() => {
          // Insert this information in-place
          if (typeof info.index == "number") {
            var _info$flags;

            managedChildrenArray.current.arr[info.index] = {
              index: info.index,
              flags: (_info$flags = info.flags) !== null && _info$flags !== void 0 ? _info$flags : {},
              subInfo: info.subInfo
            };
          } else {
            var _info$flags2;

            managedChildrenArray.current.rec[info.index] = {
              index: info.index,
              flags: (_info$flags2 = info.flags) !== null && _info$flags2 !== void 0 ? _info$flags2 : {},
              subInfo: info.subInfo
            };
          }

          return remoteULEChildChanged(info.index);
        }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
        // When we mount, notify the parent via queueMicrotask
        // (every child does this, so everything's coordinated to only queue a single microtask per tick)
        // Do the same on unmount.
        // Note: It's important that this comes AFTER remoteULEChildChanged
        // so that remoteULEChildMounted has access to all the info on mount.

        _(() => {
          remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, true);
          return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, false);
        }, [info.index]);
      }, [
        /* Must remain stable */
      ]);
      const managedChildren = A({ ...{
          _: managedChildrenArray.current
        },
        forEach: forEachChild,
        getAt: getManagedChildInfo,
        getHighestIndex: getHighestIndex,
        arraySlice: () => {
          return managedChildrenArray.current.arr.slice();
        }
      });
      return {
        useManagedChild,
        managedChildren: {
          children: managedChildren.current
        }
      };
    }
    /**
     * An extension to useManagedChildren that handles the following common case:
     * 1. You have a bunch of children
     * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
     * 3. The parent has control over who is "selected" via a numerical index.
     *
     * This hook allows for much easier control over selection management.
     *
     * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
     * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
     *
     * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
     *
     *
     * @param param0
     * @returns
     */

    function useChildrenFlag(_ref2) {
      let {
        children,
        initialIndex,
        closestFit,
        onIndexChange,
        key
      } = _ref2;
      useEnsureStability("useChildrenFlag", onIndexChange, key);
      const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange, q$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, []));
      const [getRequestedIndex, setRequestedIndex] = usePassiveState(null, q$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, [])); //    const getFitNullToZero = useStableGetter(fitNullToZero);
      // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)

      const getClosestFit = q$1(requestedIndex => {
        let closestDistance = Infinity;
        let closestIndex = null;
        children.forEach(child => {
          var _child$flags, _child$flags$key;

          if ((_child$flags = child.flags) !== null && _child$flags !== void 0 && (_child$flags$key = _child$flags[key]) !== null && _child$flags$key !== void 0 && _child$flags$key.isValid()) {
            const newDistance = Math.abs(child.index - requestedIndex);

            if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
              closestDistance = newDistance;
              closestIndex = child.index;
            }
          }
        });
        return closestIndex;
      }, [
        /* Must remain stable! */
      ]); // Any time a child mounts/unmounts, we need to double-check to see if that affects 
      // the "currently selected" (or whatever) index.  The two cases we're looking for:
      // 1. The currently selected child unmounted
      // 2. A child mounted, and it mounts with the index we're looking for

      const reevaluateClosestFit = useStableCallback(() => {
        var _currentChild$flags, _currentChild$flags$k;

        const requestedIndex = getRequestedIndex();
        const currentIndex = getCurrentIndex();
        const currentChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !((_currentChild$flags = currentChild.flags) !== null && _currentChild$flags !== void 0 && (_currentChild$flags$k = _currentChild$flags[key]) !== null && _currentChild$flags$k !== void 0 && _currentChild$flags$k.isValid()))) {
          var _currentChild$flags2;

          currentChild === null || currentChild === void 0 ? void 0 : (_currentChild$flags2 = currentChild.flags) === null || _currentChild$flags2 === void 0 ? void 0 : _currentChild$flags2[key].set(false);
          const closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex);

          if (closestFitIndex != null) {
            var _closestFitChild$flag;

            const closestFitChild = children.getAt(closestFitIndex);
            console.assert(closestFitChild != null, "Internal logic???");
            (_closestFitChild$flag = closestFitChild.flags) === null || _closestFitChild$flag === void 0 ? void 0 : _closestFitChild$flag[key].set(true);
          }
        }
      });
      const changeIndex = q$1(arg => {
        const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg; //if (requestedIndex == null && getFitNullToZero())
        //    requestedIndex = 0;

        setRequestedIndex(requestedIndex);
        const currentIndex = getCurrentIndex();
        if (currentIndex == requestedIndex) return requestedIndex;
        let newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
        const oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex == null) {
          var _oldMatchingChild$fla;

          // Easy case
          setCurrentIndex(null);
          oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla = oldMatchingChild.flags) === null || _oldMatchingChild$fla === void 0 ? void 0 : _oldMatchingChild$fla[key].set(false);
          return null;
        } else {
          var _newMatchingChild$fla;

          if (newMatchingChild && (_newMatchingChild$fla = newMatchingChild.flags) !== null && _newMatchingChild$fla !== void 0 && _newMatchingChild$fla[key].isValid()) {
            var _oldMatchingChild$fla2, _newMatchingChild$fla2;

            setCurrentIndex(requestedIndex);
            oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla2 = oldMatchingChild.flags) === null || _oldMatchingChild$fla2 === void 0 ? void 0 : _oldMatchingChild$fla2[key].set(false);
            (_newMatchingChild$fla2 = newMatchingChild.flags) === null || _newMatchingChild$fla2 === void 0 ? void 0 : _newMatchingChild$fla2[key].set(true);
            return requestedIndex;
          } else {
            const closestFitIndex = getClosestFit(requestedIndex);
            setCurrentIndex(closestFitIndex);

            if (closestFitIndex != null) {
              var _oldMatchingChild$fla3, _newMatchingChild$fla3;

              newMatchingChild = children.getAt(closestFitIndex);
              console.assert(newMatchingChild != null, "Internal logic???");
              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla3 = oldMatchingChild.flags) === null || _oldMatchingChild$fla3 === void 0 ? void 0 : _oldMatchingChild$fla3[key].set(false);
              (_newMatchingChild$fla3 = newMatchingChild.flags) === null || _newMatchingChild$fla3 === void 0 ? void 0 : _newMatchingChild$fla3[key].set(true);
              return closestFitIndex;
            } else {
              var _oldMatchingChild$fla4;

              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla4 = oldMatchingChild.flags) === null || _oldMatchingChild$fla4 === void 0 ? void 0 : _oldMatchingChild$fla4[key].set(false);
              return null;
            }
          }
        }
      }, []);
      _(() => {
        var _children$getAt, _children$getAt$flags, _children$getAt$flags2;

        if (initialIndex != null) (_children$getAt = children.getAt(initialIndex)) === null || _children$getAt === void 0 ? void 0 : (_children$getAt$flags = _children$getAt.flags) === null || _children$getAt$flags === void 0 ? void 0 : (_children$getAt$flags2 = _children$getAt$flags[key]) === null || _children$getAt$flags2 === void 0 ? void 0 : _children$getAt$flags2.set(true);
      }, []);
      return {
        changeIndex,
        reevaluateClosestFit,
        getCurrentIndex
      };
    }

    function r(e) {
      var t,
          f,
          n = "";
      if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
      return n;
    }

    function clsx() {
      for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);

      return n;
    }

    function getDocument$e(element) {
      var _ref, _ref2, _element$ownerDocumen;

      return (_ref = (_ref2 = (_element$ownerDocumen = element === null || element === void 0 ? void 0 : element.ownerDocument) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : document) !== null && _ref2 !== void 0 ? _ref2 : window.document) !== null && _ref !== void 0 ? _ref : globalThis.document;
    }

    function useMergedChildren(_ref, _ref2) {
      let {
        children: lhs
      } = _ref;
      let {
        children: rhs
      } = _ref2;

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return h$1(p$1, {}, lhs, rhs);
      }
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */

    function useMergedClasses(_ref, _ref2) {
      let {
        class: lhsClass,
        className: lhsClassName
      } = _ref;
      let {
        class: rhsClass,
        className: rhsClassName
      } = _ref2;

      // Note: For the sake of forward compatibility, this function is labelled as
      // a hook, but as it uses no other hooks it technically isn't one.
      if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
        const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
        const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
        const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
        return Array.from(allClasses).join(" ");
      } else {
        return undefined;
      }
    }

    function processRef(instance, ref) {
      if (typeof ref === "function") {
        ref(instance);
      } else if (ref != null) {
        ref.current = instance;
      } else {
        /* eslint-disable no-debugger */
        debugger;
        console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
      }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */


    function useMergedRefs(_ref, _ref2) {
      let {
        ref: rhs
      } = _ref;
      let {
        ref: lhs
      } = _ref2;
      const combined = q$1(current => {
        processRef(current, lhs);
        processRef(current, rhs);
      }, [lhs, rhs]);

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return combined;
      }
    }

    function styleStringToObject(style) {
      // TODO: This sucks D:
      return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
    }
    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */


    function useMergedStyles(lhs, rhs) {
      var _lhs$style, _rhs$style2;

      // Easy case, when there are no styles to merge return nothing.
      if (!(lhs !== null && lhs !== void 0 && lhs.style) && !(rhs !== null && rhs !== void 0 && rhs.style)) return undefined;

      if (typeof lhs != typeof rhs) {
        // Easy cases, when one is null and the other isn't.
        if (lhs !== null && lhs !== void 0 && lhs.style && !(rhs !== null && rhs !== void 0 && rhs.style)) return lhs.style;
        if (!(lhs !== null && lhs !== void 0 && lhs.style) && rhs !== null && rhs !== void 0 && rhs.style) return rhs.style; // They're both non-null but different types.
        // Convert the string type to an object bag type and run it again.

        if (lhs !== null && lhs !== void 0 && lhs.style && rhs !== null && rhs !== void 0 && rhs.style) {
          // (useMergedStyles isn't a true hook -- this isn't a violation)
          if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") return useMergedStyles({
            style: styleStringToObject(lhs === null || lhs === void 0 ? void 0 : lhs.style)
          }, rhs);
          if (typeof (rhs === null || rhs === void 0 ? void 0 : rhs.style) == "string") return useMergedStyles(lhs, {
            style: styleStringToObject(rhs === null || rhs === void 0 ? void 0 : rhs.style)
          });
        } // Logic???


        return undefined;
      } // They're both strings, just concatenate them.


      if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") {
        var _rhs$style;

        return `${lhs.style};${(_rhs$style = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style !== void 0 ? _rhs$style : ""}`;
      } // They're both objects, just merge them.


      return { ...((_lhs$style = lhs === null || lhs === void 0 ? void 0 : lhs.style) !== null && _lhs$style !== void 0 ? _lhs$style : {}),
        ...((_rhs$style2 = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style2 !== void 0 ? _rhs$style2 : {})
      };
    }

    let log = console.warn;
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */

    function useMergedProps(lhsAll, rhsAll) {
      // First, separate the props we were given into two groups:
      // lhsAll and rhsAll contain all the props we were given, and
      // lhsMisc and rhsMisc contain all props *except* for the easy ones
      // like className and style that we already know how to merge.
      const {
        children: _lhsChildren,
        class: _lhsClass,
        className: _lhsClassName,
        style: _lhsStyle,
        ref: _lhsRef,
        ...lhsMisc
      } = lhsAll;
      const {
        children: _rhsChildren,
        class: _rhsClass,
        className: _rhsClassName,
        style: _rhsStyle,
        ref: _rhsRef,
        ...rhsMisc
      } = rhsAll;
      const ret = { ...lhsMisc,
        ref: useMergedRefs(lhsAll, rhsAll),
        style: useMergedStyles(lhsAll, rhsAll),
        className: useMergedClasses(lhsAll, rhsAll),
        children: useMergedChildren(lhsAll, rhsAll)
      };
      if (ret.ref === undefined) delete ret.ref;
      if (ret.style === undefined) delete ret.style;
      if (ret.className === undefined) delete ret.className;
      if (ret.children === undefined) delete ret.children; // Now, do *everything* else
      // Merge every remaining existing entry in lhs with what we've already put in ret.
      //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];

      const rhsEntries = Object.entries(rhsMisc);

      for (const [rhsKeyU, rhsValue] of rhsEntries) {
        const rhsKey = rhsKeyU;
        const lhsValue = lhsMisc[rhsKey];

        if (typeof lhsValue === "function" || typeof rhsValue === "function") {
          // They're both functions that can be merged (or one's a function and the other's null).
          // Not an *easy* case, but a well-defined one.
          const merged = mergeFunctions(lhsValue, rhsValue);
          ret[rhsKey] = merged;
        } else {
          // Uh...we're here because one of them's null, right?
          if (lhsValue == null && rhsValue == null) {
            if (rhsValue === null && lhsValue === undefined) ret[rhsKey] = rhsValue;else ret[rhsKey] = lhsValue;
          }

          if (lhsValue == null) ret[rhsKey] = rhsValue;else if (rhsValue == null) ret[rhsKey] = lhsValue;else if (rhsValue == lhsValue) ; else {
            var _log;

            // Ugh.
            // No good strategies here, just log it if requested
            (_log = log) === null || _log === void 0 ? void 0 : _log(`The prop "${rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
            ret[rhsKey] = rhsValue;
          }
        }
      }

      return ret;
    }

    function mergeFunctions(lhs, rhs) {
      if (!lhs) return rhs;
      if (!rhs) return lhs;
      return function () {
        const lv = lhs(...arguments);
        const rv = rhs(...arguments);
        if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
      };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */

    function useRefElement(args) {
      const {
        onElementChange,
        onMount,
        onUnmount
      } = args !== null && args !== void 0 ? args : {};
      useEnsureStability("useRefElement", onElementChange, onMount, onUnmount); // Called (indirectly) by the ref that the element receives.

      const handler = q$1((e, prevValue) => {
        const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
        if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
        if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
        return cleanup;
      }, []); // Let us store the actual (reference to) the element we capture

      const [getElement, setElement] = usePassiveState(handler, returnNull, runImmediately);
      const useRefElementProps = q$1(props => useMergedProps({
        ref: setElement
      }, props), []); // Return both the element and the hook that modifies 
      // the props and allows us to actually find the element

      return {
        useRefElementProps,
        getElement
      };
    }

    function runImmediately(f) {
      f();
    }

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */

    function useGlobalHandler(target, type, handler, options) {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      let stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
      if (handler == null) stableHandler = null;
      s(() => {
        if (stableHandler) {
          target.addEventListener(type, stableHandler, options);
          return () => target.removeEventListener(type, stableHandler, options);
        }
      }, [target, type, stableHandler]);
    }

    /*!
    * tabbable 6.0.0
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var NoElement = typeof Element === 'undefined';
    var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
      return element.getRootNode();
    } : function (element) {
      return element.ownerDocument;
    };

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };


    var isNodeAttached = function isNodeAttached(node) {
      var _nodeRootHost; // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
      //  (but NOT _the_ document; see second 'If' comment below for more).
      // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
      //  is attached, and the one we need to check if it's in the document or not (because the
      //  shadow, and all nodes it contains, is never considered in the document since shadows
      //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
      //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
      //  visibility, including all the nodes it contains). The host could be any normal node,
      //  or a custom element (i.e. web component). Either way, that's the one that is considered
      //  part of the document, not the shadow root, nor any of its children (i.e. the node being
      //  tested).
      // To further complicate things, we have to look all the way up until we find a shadow HOST
      //  that is attached (or find none) because the node might be in nested shadows...
      // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
      //  document (per the docs) and while it's a Document-type object, that document does not
      //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
      //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
      //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
      //  node is actually detached.


      var nodeRootHost = getRootNode(node).host;
      var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));

      while (!attached && nodeRootHost) {
        var _nodeRootHost2; // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
        //  which means we need to get the host's host and check if that parent host is contained
        //  in (i.e. attached to) the document


        nodeRootHost = getRootNode(nodeRootHost).host;
        attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
      }

      return attached;
    };

    var isZeroArea = function isZeroArea(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(),
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      return width === 0 && height === 0;
    };

    var isHidden = function isHidden(node, _ref) {
      var displayCheck = _ref.displayCheck,
          getShadowRoot = _ref.getShadowRoot; // NOTE: visibility will be `undefined` if node is detached from the document
      //  (see notes about this further down), which means we will consider it visible
      //  (this is legacy behavior from a very long way back)
      // NOTE: we check this regardless of `displayCheck="none"` because this is a
      //  _visibility_ check, not a _display_ check

      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      }

      if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
        if (typeof getShadowRoot === 'function') {
          // figure out if we should consider the node to be in an undisclosed shadow and use the
          //  'non-zero-area' fallback
          var originalNode = node;

          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);

            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
            ) {
              // node has an undisclosed shadow which means we can only treat it as a black box, so we
              //  fall back to a non-zero-area test
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              // iterate up slot
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              // cross shadow boundary
              node = rootNode.host;
            } else {
              // iterate up normal dom
              node = parentElement;
            }
          }

          node = originalNode;
        } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.


        if (isNodeAttached(node)) {
          // this works wherever the node is: if there's at least one client rect, it's
          //  somehow displayed; it also covers the CSS 'display: contents' case where the
          //  node itself is hidden in place of its contents; and there's no need to search
          //  up the hierarchy either
          return !node.getClientRects().length;
        } // Else, the node isn't attached to the document, which means the `getClientRects()`
        //  API will __always__ return zero rects (this can happen, for example, if React
        //  is used to render nodes onto a detached tree, as confirmed in this thread:
        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
        //
        // It also means that even window.getComputedStyle(node).display will return `undefined`
        //  because styles are only computed for nodes that are in the document.
        //
        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
        //  somehow. Though it was never stated officially, anyone who has ever used tabbable
        //  APIs on nodes in detached containers has actually implicitly used tabbable in what
        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
        //  considering __everything__ to be visible because of the innability to determine styles.
        //
        // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
        //  nodes as visible with the 'none' fallback.__


        if (displayCheck !== 'legacy-full') {
          return true; // hidden
        } // else, fallback to 'none' mode and consider the node visible

      } else if (displayCheck === 'non-zero-area') {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
      } // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
      //  it's visible


      return false;
    }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset


    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>

        while (parentNode) {
          if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
            // look for the first <legend> among the children of the disabled <fieldset>
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i); // when the first <legend> (in document order) is found

              if (child.tagName === 'LEGEND') {
                // if its parent <fieldset> is not nested in another disabled <fieldset>,
                // return whether `node` is a descendant of its first <legend>
                return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
              }
            } // the disabled <fieldset> containing `node` has no <legend>


            return true;
          }

          parentNode = parentNode.parentElement;
        }
      } // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state


      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    (function (module, exports) {
      (function (global, factory) {
        factory() ;
      })(commonjsGlobal, function () {

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        /**
         * This work is licensed under the W3C Software and Document License
         * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
         */


        (function () {
          // Return early if we're not running inside of the browser.
          if (typeof window === 'undefined') {
            return;
          } // Convenience function for converting NodeLists.

          /** @type {typeof Array.prototype.slice} */


          var slice = Array.prototype.slice;
          /**
           * IE has a non-standard name for "matches".
           * @type {typeof Element.prototype.matches}
           */

          var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
          /** @type {string} */

          var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
          /**
           * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
           * attribute.
           *
           * Its main functions are:
           *
           * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
           *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
           *   each focusable node in the subtree with the singleton `InertManager` which manages all known
           *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
           *   instance exists for each focusable node which has at least one inert root as an ancestor.
           *
           * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
           *   attribute is removed from the root node). This is handled in the destructor, which calls the
           *   `deregister` method on `InertManager` for each managed inert node.
           */


          var InertRoot = function () {
            /**
             * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
             * @param {!InertManager} inertManager The global singleton InertManager object.
             */
            function InertRoot(rootElement, inertManager) {
              _classCallCheck(this, InertRoot);
              /** @type {!InertManager} */


              this._inertManager = inertManager;
              /** @type {!HTMLElement} */

              this._rootElement = rootElement;
              /**
               * @type {!Set<!InertNode>}
               * All managed focusable nodes in this InertRoot's subtree.
               */

              this._managedNodes = new Set(); // Make the subtree hidden from assistive technology

              if (this._rootElement.hasAttribute('aria-hidden')) {
                /** @type {?string} */
                this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
              } else {
                this._savedAriaHidden = null;
              }

              this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes


              this._makeSubtreeUnfocusable(this._rootElement); // Watch for:
              // - any additions in the subtree: make them unfocusable too
              // - any removals from the subtree: remove them from this inert root's managed nodes
              // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
              //   element, make that node a managed node.


              this._observer = new MutationObserver(this._onMutation.bind(this));

              this._observer.observe(this._rootElement, {
                attributes: true,
                childList: true,
                subtree: true
              });
            }
            /**
             * Call this whenever this object is about to become obsolete.  This unwinds all of the state
             * stored in this object and updates the state of all of the managed nodes.
             */


            _createClass(InertRoot, [{
              key: 'destructor',
              value: function destructor() {
                this._observer.disconnect();

                if (this._rootElement) {
                  if (this._savedAriaHidden !== null) {
                    this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                  } else {
                    this._rootElement.removeAttribute('aria-hidden');
                  }
                }

                this._managedNodes.forEach(function (inertNode) {
                  this._unmanageNode(inertNode.node);
                }, this); // Note we cast the nulls to the ANY type here because:
                // 1) We want the class properties to be declared as non-null, or else we
                //    need even more casts throughout this code. All bets are off if an
                //    instance has been destroyed and a method is called.
                // 2) We don't want to cast "this", because we want type-aware optimizations
                //    to know which properties we're setting.


                this._observer =
                /** @type {?} */
                null;
                this._rootElement =
                /** @type {?} */
                null;
                this._managedNodes =
                /** @type {?} */
                null;
                this._inertManager =
                /** @type {?} */
                null;
              }
              /**
               * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
               */

            }, {
              key: '_makeSubtreeUnfocusable',

              /**
               * @param {!Node} startNode
               */
              value: function _makeSubtreeUnfocusable(startNode) {
                var _this2 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this2._visitNode(node);
                });
                var activeElement = document.activeElement;

                if (!document.body.contains(startNode)) {
                  // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                  var node = startNode;
                  /** @type {!ShadowRoot|undefined} */

                  var root = undefined;

                  while (node) {
                    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      root =
                      /** @type {!ShadowRoot} */
                      node;
                      break;
                    }

                    node = node.parentNode;
                  }

                  if (root) {
                    activeElement = root.activeElement;
                  }
                }

                if (startNode.contains(activeElement)) {
                  activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1
                  // calling blur() will not actually move the focus.
                  // To work around this we call focus() on the body instead.

                  if (activeElement === document.activeElement) {
                    document.body.focus();
                  }
                }
              }
              /**
               * @param {!Node} node
               */

            }, {
              key: '_visitNode',
              value: function _visitNode(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of
                // this inert root, so all of its managed nodes need to be adopted by this InertRoot.

                if (element !== this._rootElement && element.hasAttribute('inert')) {
                  this._adoptInertRoot(element);
                }

                if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                  this._manageNode(element);
                }
              }
              /**
               * Register the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_manageNode',
              value: function _manageNode(node) {
                var inertNode = this._inertManager.register(node, this);

                this._managedNodes.add(inertNode);
              }
              /**
               * Unregister the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_unmanageNode',
              value: function _unmanageNode(node) {
                var inertNode = this._inertManager.deregister(node, this);

                if (inertNode) {
                  this._managedNodes['delete'](inertNode);
                }
              }
              /**
               * Unregister the entire subtree starting at `startNode`.
               * @param {!Node} startNode
               */

            }, {
              key: '_unmanageSubtree',
              value: function _unmanageSubtree(startNode) {
                var _this3 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this3._unmanageNode(node);
                });
              }
              /**
               * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
               * @param {!HTMLElement} node
               */

            }, {
              key: '_adoptInertRoot',
              value: function _adoptInertRoot(node) {
                var inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,
                // so register it now if need be.


                if (!inertSubroot) {
                  this._inertManager.setInert(node, true);

                  inertSubroot = this._inertManager.getInertRoot(node);
                }

                inertSubroot.managedNodes.forEach(function (savedInertNode) {
                  this._manageNode(savedInertNode.node);
                }, this);
              }
              /**
               * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_onMutation',
              value: function _onMutation(records, self) {
                records.forEach(function (record) {
                  var target =
                  /** @type {!HTMLElement} */
                  record.target;

                  if (record.type === 'childList') {
                    // Manage added nodes
                    slice.call(record.addedNodes).forEach(function (node) {
                      this._makeSubtreeUnfocusable(node);
                    }, this); // Un-manage removed nodes

                    slice.call(record.removedNodes).forEach(function (node) {
                      this._unmanageSubtree(node);
                    }, this);
                  } else if (record.type === 'attributes') {
                    if (record.attributeName === 'tabindex') {
                      // Re-initialise inert node if tabindex changes
                      this._manageNode(target);
                    } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                      // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                      // already managed nodes from this inert subroot.
                      this._adoptInertRoot(target);

                      var inertSubroot = this._inertManager.getInertRoot(target);

                      this._managedNodes.forEach(function (managedNode) {
                        if (target.contains(managedNode.node)) {
                          inertSubroot._manageNode(managedNode.node);
                        }
                      });
                    }
                  }
                }, this);
              }
            }, {
              key: 'managedNodes',
              get: function get() {
                return new Set(this._managedNodes);
              }
              /** @return {boolean} */

            }, {
              key: 'hasSavedAriaHidden',
              get: function get() {
                return this._savedAriaHidden !== null;
              }
              /** @param {?string} ariaHidden */

            }, {
              key: 'savedAriaHidden',
              set: function set(ariaHidden) {
                this._savedAriaHidden = ariaHidden;
              }
              /** @return {?string} */
              ,
              get: function get() {
                return this._savedAriaHidden;
              }
            }]);

            return InertRoot;
          }();
          /**
           * `InertNode` initialises and manages a single inert node.
           * A node is inert if it is a descendant of one or more inert root elements.
           *
           * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
           * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
           * is intrinsically focusable or not.
           *
           * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
           * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
           * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
           * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
           * or removes the `tabindex` attribute if the element is intrinsically focusable.
           */


          var InertNode = function () {
            /**
             * @param {!Node} node A focusable element to be made inert.
             * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
             */
            function InertNode(node, inertRoot) {
              _classCallCheck(this, InertNode);
              /** @type {!Node} */


              this._node = node;
              /** @type {boolean} */

              this._overrodeFocusMethod = false;
              /**
               * @type {!Set<!InertRoot>} The set of descendant inert roots.
               *    If and only if this set becomes empty, this node is no longer inert.
               */

              this._inertRoots = new Set([inertRoot]);
              /** @type {?number} */

              this._savedTabIndex = null;
              /** @type {boolean} */

              this._destroyed = false; // Save any prior tabindex info and make this node untabbable

              this.ensureUntabbable();
            }
            /**
             * Call this whenever this object is about to become obsolete.
             * This makes the managed node focusable again and deletes all of the previously stored state.
             */


            _createClass(InertNode, [{
              key: 'destructor',
              value: function destructor() {
                this._throwIfDestroyed();

                if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                  var element =
                  /** @type {!HTMLElement} */
                  this._node;

                  if (this._savedTabIndex !== null) {
                    element.setAttribute('tabindex', this._savedTabIndex);
                  } else {
                    element.removeAttribute('tabindex');
                  } // Use `delete` to restore native focus method.


                  if (this._overrodeFocusMethod) {
                    delete element.focus;
                  }
                } // See note in InertRoot.destructor for why we cast these nulls to ANY.


                this._node =
                /** @type {?} */
                null;
                this._inertRoots =
                /** @type {?} */
                null;
                this._destroyed = true;
              }
              /**
               * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
               * If the object has been destroyed, any attempt to access it will cause an exception.
               */

            }, {
              key: '_throwIfDestroyed',

              /**
               * Throw if user tries to access destroyed InertNode.
               */
              value: function _throwIfDestroyed() {
                if (this.destroyed) {
                  throw new Error('Trying to access destroyed InertNode');
                }
              }
              /** @return {boolean} */

            }, {
              key: 'ensureUntabbable',

              /** Save the existing tabindex value and make the node untabbable and unfocusable */
              value: function ensureUntabbable() {
                if (this.node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                this.node;

                if (matches.call(element, _focusableElementsString)) {
                  if (
                  /** @type {!HTMLElement} */
                  element.tabIndex === -1 && this.hasSavedTabIndex) {
                    return;
                  }

                  if (element.hasAttribute('tabindex')) {
                    this._savedTabIndex =
                    /** @type {!HTMLElement} */
                    element.tabIndex;
                  }

                  element.setAttribute('tabindex', '-1');

                  if (element.nodeType === Node.ELEMENT_NODE) {
                    element.focus = function () {};

                    this._overrodeFocusMethod = true;
                  }
                } else if (element.hasAttribute('tabindex')) {
                  this._savedTabIndex =
                  /** @type {!HTMLElement} */
                  element.tabIndex;
                  element.removeAttribute('tabindex');
                }
              }
              /**
               * Add another inert root to this inert node's set of managing inert roots.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'addInertRoot',
              value: function addInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots.add(inertRoot);
              }
              /**
               * Remove the given inert root from this inert node's set of managing inert roots.
               * If the set of managing inert roots becomes empty, this node is no longer inert,
               * so the object should be destroyed.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'removeInertRoot',
              value: function removeInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots['delete'](inertRoot);

                if (this._inertRoots.size === 0) {
                  this.destructor();
                }
              }
            }, {
              key: 'destroyed',
              get: function get() {
                return (
                  /** @type {!InertNode} */
                  this._destroyed
                );
              }
            }, {
              key: 'hasSavedTabIndex',
              get: function get() {
                return this._savedTabIndex !== null;
              }
              /** @return {!Node} */

            }, {
              key: 'node',
              get: function get() {
                this._throwIfDestroyed();

                return this._node;
              }
              /** @param {?number} tabIndex */

            }, {
              key: 'savedTabIndex',
              set: function set(tabIndex) {
                this._throwIfDestroyed();

                this._savedTabIndex = tabIndex;
              }
              /** @return {?number} */
              ,
              get: function get() {
                this._throwIfDestroyed();

                return this._savedTabIndex;
              }
            }]);

            return InertNode;
          }();
          /**
           * InertManager is a per-document singleton object which manages all inert roots and nodes.
           *
           * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
           * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
           * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
           * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
           * is created for each such node, via the `_managedNodes` map.
           */


          var InertManager = function () {
            /**
             * @param {!Document} document
             */
            function InertManager(document) {
              _classCallCheck(this, InertManager);

              if (!document) {
                throw new Error('Missing required argument; InertManager needs to wrap a document.');
              }
              /** @type {!Document} */


              this._document = document;
              /**
               * All managed nodes known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertNode>}
               */

              this._managedNodes = new Map();
              /**
               * All inert roots known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertRoot>}
               */

              this._inertRoots = new Map();
              /**
               * Observer for mutations on `document.body`.
               * @type {!MutationObserver}
               */

              this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.

              addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.

              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
              } else {
                this._onDocumentLoaded();
              }
            }
            /**
             * Set whether the given element should be an inert root or not.
             * @param {!HTMLElement} root
             * @param {boolean} inert
             */


            _createClass(InertManager, [{
              key: 'setInert',
              value: function setInert(root, inert) {
                if (inert) {
                  if (this._inertRoots.has(root)) {
                    // element is already inert
                    return;
                  }

                  var inertRoot = new InertRoot(root, this);
                  root.setAttribute('inert', '');

                  this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.
                  // Ensure inert styles are added there.


                  if (!this._document.body.contains(root)) {
                    var parent = root.parentNode;

                    while (parent) {
                      if (parent.nodeType === 11) {
                        addInertStyle(parent);
                      }

                      parent = parent.parentNode;
                    }
                  }
                } else {
                  if (!this._inertRoots.has(root)) {
                    // element is already non-inert
                    return;
                  }

                  var _inertRoot = this._inertRoots.get(root);

                  _inertRoot.destructor();

                  this._inertRoots['delete'](root);

                  root.removeAttribute('inert');
                }
              }
              /**
               * Get the InertRoot object corresponding to the given inert root element, if any.
               * @param {!Node} element
               * @return {!InertRoot|undefined}
               */

            }, {
              key: 'getInertRoot',
              value: function getInertRoot(element) {
                return this._inertRoots.get(element);
              }
              /**
               * Register the given InertRoot as managing the given node.
               * In the case where the node has a previously existing inert root, this inert root will
               * be added to its set of inert roots.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {!InertNode} inertNode
               */

            }, {
              key: 'register',
              value: function register(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (inertNode !== undefined) {
                  // node was already in an inert subtree
                  inertNode.addInertRoot(inertRoot);
                } else {
                  inertNode = new InertNode(node, inertRoot);
                }

                this._managedNodes.set(node, inertNode);

                return inertNode;
              }
              /**
               * De-register the given InertRoot as managing the given inert node.
               * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
               * node from the InertManager's set of managed nodes if it is destroyed.
               * If the node is not currently managed, this is essentially a no-op.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
               */

            }, {
              key: 'deregister',
              value: function deregister(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (!inertNode) {
                  return null;
                }

                inertNode.removeInertRoot(inertRoot);

                if (inertNode.destroyed) {
                  this._managedNodes['delete'](node);
                }

                return inertNode;
              }
              /**
               * Callback used when document has finished loading.
               */

            }, {
              key: '_onDocumentLoaded',
              value: function _onDocumentLoaded() {
                // Find all inert roots in document and make them actually inert.
                var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
                inertElements.forEach(function (inertElement) {
                  this.setInert(inertElement, true);
                }, this); // Comment this out to use programmatic API only.

                this._observer.observe(this._document.body || this._document.documentElement, {
                  attributes: true,
                  subtree: true,
                  childList: true
                });
              }
              /**
               * Callback used when mutation observer detects attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_watchForInert',
              value: function _watchForInert(records, self) {
                var _this = this;

                records.forEach(function (record) {
                  switch (record.type) {
                    case 'childList':
                      slice.call(record.addedNodes).forEach(function (node) {
                        if (node.nodeType !== Node.ELEMENT_NODE) {
                          return;
                        }

                        var inertElements = slice.call(node.querySelectorAll('[inert]'));

                        if (matches.call(node, '[inert]')) {
                          inertElements.unshift(node);
                        }

                        inertElements.forEach(function (inertElement) {
                          this.setInert(inertElement, true);
                        }, _this);
                      }, _this);
                      break;

                    case 'attributes':
                      if (record.attributeName !== 'inert') {
                        return;
                      }

                      var target =
                      /** @type {!HTMLElement} */
                      record.target;
                      var inert = target.hasAttribute('inert');

                      _this.setInert(target, inert);

                      break;
                  }
                }, this);
              }
            }]);

            return InertManager;
          }();
          /**
           * Recursively walk the composed tree from |node|.
           * @param {!Node} node
           * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
           *     before descending into child nodes.
           * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
           */


          function composedTreeWalk(node, callback, shadowRootAncestor) {
            if (node.nodeType == Node.ELEMENT_NODE) {
              var element =
              /** @type {!HTMLElement} */
              node;

              if (callback) {
                callback(element);
              } // Descend into node:
              // If it has a ShadowRoot, ignore all child elements - these will be picked
              // up by the <content> or <shadow> elements. Descend straight into the
              // ShadowRoot.


              var shadowRoot =
              /** @type {!HTMLElement} */
              element.shadowRoot;

              if (shadowRoot) {
                composedTreeWalk(shadowRoot, callback);
                return;
              } // If it is a <content> element, descend into distributed elements - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'content') {
                var content =
                /** @type {!HTMLContentElement} */
                element; // Verifies if ShadowDom v0 is supported.

                var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];

                for (var i = 0; i < distributedNodes.length; i++) {
                  composedTreeWalk(distributedNodes[i], callback);
                }

                return;
              } // If it is a <slot> element, descend into assigned nodes - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'slot') {
                var slot =
                /** @type {!HTMLSlotElement} */
                element; // Verify if ShadowDom v1 is supported.

                var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                  flatten: true
                }) : [];

                for (var _i = 0; _i < _distributedNodes.length; _i++) {
                  composedTreeWalk(_distributedNodes[_i], callback);
                }

                return;
              }
            } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
            // element, nor a <shadow> element recurse normally.


            var child = node.firstChild;

            while (child != null) {
              composedTreeWalk(child, callback);
              child = child.nextSibling;
            }
          }
          /**
           * Adds a style element to the node containing the inert specific styles
           * @param {!Node} node
           */


          function addInertStyle(node) {
            if (node.querySelector('style#inert-style, link#inert-style')) {
              return;
            }

            var style = document.createElement('style');
            style.setAttribute('id', 'inert-style');
            style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
            node.appendChild(style);
          }

          if (!HTMLElement.prototype.hasOwnProperty('inert')) {
            /** @type {!InertManager} */
            var inertManager = new InertManager(document);
            Object.defineProperty(HTMLElement.prototype, 'inert', {
              enumerable: true,

              /** @this {!HTMLElement} */
              get: function get() {
                return this.hasAttribute('inert');
              },

              /** @this {!HTMLElement} */
              set: function set(inert) {
                inertManager.setInert(this, inert);
              }
            });
          }
        })();
      });
    })();

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
      var _a, _b, _c;
      /* Symbols for private properties */


      const _blockingElements = Symbol();

      const _alreadyInertElements = Symbol();

      const _topElParents = Symbol();

      const _siblingsToRestore = Symbol();

      const _parentMO = Symbol();
      /* Symbols for private static methods */


      const _topChanged = Symbol();

      const _swapInertedSibling = Symbol();

      const _inertSiblings = Symbol();

      const _restoreInertedSiblings = Symbol();

      const _getParents = Symbol();

      const _getDistributedChildren = Symbol();

      const _isInertable = Symbol();

      const _handleMutations = Symbol();

      class BlockingElementsImpl {
        constructor() {
          /**
           * The blocking elements.
           */
          this[_a] = [];
          /**
           * Used to keep track of the parents of the top element, from the element
           * itself up to body. When top changes, the old top might have been removed
           * from the document, so we need to memoize the inerted parents' siblings
           * in order to restore their inerteness when top changes.
           */

          this[_b] = [];
          /**
           * Elements that are already inert before the first blocking element is
           * pushed.
           */

          this[_c] = new Set();
        }

        destructor() {
          // Restore original inertness.
          this[_restoreInertedSiblings](this[_topElParents]); // Note we don't want to make these properties nullable on the class,
          // since then we'd need non-null casts in many places. Calling a method on
          // a BlockingElements instance after calling destructor will result in an
          // exception.


          const nullable = this;
          nullable[_blockingElements] = null;
          nullable[_topElParents] = null;
          nullable[_alreadyInertElements] = null;
        }

        get top() {
          const elems = this[_blockingElements];
          return elems[elems.length - 1] || null;
        }

        push(element) {
          if (!element || element === this.top) {
            return;
          } // Remove it from the stack, we'll bring it to the top.


          this.remove(element);

          this[_topChanged](element);

          this[_blockingElements].push(element);
        }

        remove(element) {
          const i = this[_blockingElements].indexOf(element);

          if (i === -1) {
            return false;
          }

          this[_blockingElements].splice(i, 1); // Top changed only if the removed element was the top element.


          if (i === this[_blockingElements].length) {
            this[_topChanged](this.top);
          }

          return true;
        }

        pop() {
          const top = this.top;
          top && this.remove(top);
          return top;
        }

        has(element) {
          return this[_blockingElements].indexOf(element) !== -1;
        }
        /**
         * Sets `inert` to all document elements except the new top element, its
         * parents, and its distributed content.
         */


        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
          const toKeepInert = this[_alreadyInertElements];
          const oldParents = this[_topElParents]; // No new top, reset old top if any.

          if (!newTop) {
            this[_restoreInertedSiblings](oldParents);

            toKeepInert.clear();
            this[_topElParents] = [];
            return;
          }

          const newParents = this[_getParents](newTop); // New top is not contained in the main document!


          if (newParents[newParents.length - 1].parentNode !== document.body) {
            throw Error('Non-connected element cannot be a blocking element');
          } // Cast here because we know we'll call _inertSiblings on newParents
          // below.


          this[_topElParents] = newParents;

          const toSkip = this[_getDistributedChildren](newTop); // No previous top element.


          if (!oldParents.length) {
            this[_inertSiblings](newParents, toSkip, toKeepInert);

            return;
          }

          let i = oldParents.length - 1;
          let j = newParents.length - 1; // Find common parent. Index 0 is the element itself (so stop before it).

          while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
            i--;
            j--;
          } // If up the parents tree there are 2 elements that are siblings, swap
          // the inerted sibling.


          if (oldParents[i] !== newParents[j]) {
            this[_swapInertedSibling](oldParents[i], newParents[j]);
          } // Restore old parents siblings inertness.


          i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i)); // Make new parents siblings inert.

          j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
        }
        /**
         * Swaps inertness between two sibling elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_swapInertedSibling](oldInert, newInert) {
          const siblingsToRestore = oldInert[_siblingsToRestore]; // oldInert is not contained in siblings to restore, so we have to check
          // if it's inertable and if already inert.

          if (this[_isInertable](oldInert) && !oldInert.inert) {
            oldInert.inert = true;
            siblingsToRestore.add(oldInert);
          } // If newInert was already between the siblings to restore, it means it is
          // inertable and must be restored.


          if (siblingsToRestore.has(newInert)) {
            newInert.inert = false;
            siblingsToRestore.delete(newInert);
          }

          newInert[_parentMO] = oldInert[_parentMO];
          newInert[_siblingsToRestore] = siblingsToRestore;
          oldInert[_parentMO] = undefined;
          oldInert[_siblingsToRestore] = undefined;
        }
        /**
         * Restores original inertness to the siblings of the elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_restoreInertedSiblings](elements) {
          for (const element of elements) {
            const mo = element[_parentMO];
            mo.disconnect();
            element[_parentMO] = undefined;
            const siblings = element[_siblingsToRestore];

            for (const sibling of siblings) {
              sibling.inert = false;
            }

            element[_siblingsToRestore] = undefined;
          }
        }
        /**
         * Inerts the siblings of the elements except the elements to skip. Stores
         * the inerted siblings into the element's symbol `_siblingsToRestore`.
         * Pass `toKeepInert` to collect the already inert elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_inertSiblings](elements, toSkip, toKeepInert) {
          for (const element of elements) {
            // Assume element is not a Document, so it must have a parentNode.
            const parent = element.parentNode;
            const children = parent.children;
            const inertedSiblings = new Set();

            for (let j = 0; j < children.length; j++) {
              const sibling = children[j]; // Skip the input element, if not inertable or to be skipped.

              if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
                continue;
              } // Should be collected since already inerted.


              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            } // Store the siblings that were inerted.


            element[_siblingsToRestore] = inertedSiblings; // Observe only immediate children mutations on the parent.

            const mo = new MutationObserver(this[_handleMutations].bind(this));
            element[_parentMO] = mo;
            let parentToObserve = parent; // If we're using the ShadyDOM polyfill, then our parent could be a
            // shady root, which is an object that acts like a ShadowRoot, but isn't
            // actually a node in the real DOM. Observe the real DOM parent instead.

            const maybeShadyRoot = parentToObserve;

            if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
              parentToObserve = maybeShadyRoot.host;
            }

            mo.observe(parentToObserve, {
              childList: true
            });
          }
        }
        /**
         * Handles newly added/removed nodes by toggling their inertness.
         * It also checks if the current top Blocking Element has been removed,
         * notifying and removing it.
         */


        [_handleMutations](mutations) {
          const parents = this[_topElParents];
          const toKeepInert = this[_alreadyInertElements];

          for (const mutation of mutations) {
            // If the target is a shadowRoot, get its host as we skip shadowRoots when
            // computing _topElParents.
            const target = mutation.target.host || mutation.target;
            const idx = target === document.body ? parents.length : parents.indexOf(target);
            const inertedChild = parents[idx - 1];
            const inertedSiblings = inertedChild[_siblingsToRestore]; // To restore.

            for (let i = 0; i < mutation.removedNodes.length; i++) {
              const sibling = mutation.removedNodes[i];

              if (sibling === inertedChild) {
                console.info('Detected removal of the top Blocking Element.');
                this.pop();
                return;
              }

              if (inertedSiblings.has(sibling)) {
                sibling.inert = false;
                inertedSiblings.delete(sibling);
              }
            } // To inert.


            for (let i = 0; i < mutation.addedNodes.length; i++) {
              const sibling = mutation.addedNodes[i];

              if (!this[_isInertable](sibling)) {
                continue;
              }

              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            }
          }
        }
        /**
         * Returns if the element is inertable.
         */


        [_isInertable](element) {
          return false === /^(style|template|script)$/.test(element.localName);
        }
        /**
         * Returns the list of newParents of an element, starting from element
         * (included) up to `document.body` (excluded).
         */


        [_getParents](element) {
          const parents = [];
          let current = element; // Stop to body.

          while (current && current !== document.body) {
            // Skip shadow roots.
            if (current.nodeType === Node.ELEMENT_NODE) {
              parents.push(current);
            } // ShadowDom v1


            if (current.assignedSlot) {
              // Collect slots from deepest slot to top.
              while (current = current.assignedSlot) {
                parents.push(current);
              } // Continue the search on the top slot.


              current = parents.pop();
              continue;
            }

            current = current.parentNode || current.host;
          }

          return parents;
        }
        /**
         * Returns the distributed children of the element's shadow root.
         * Returns null if the element doesn't have a shadow root.
         */


        [_getDistributedChildren](element) {
          const shadowRoot = element.shadowRoot;

          if (!shadowRoot) {
            return null;
          }

          const result = new Set();
          let i;
          let j;
          let nodes;
          const slots = shadowRoot.querySelectorAll('slot');

          if (slots.length && slots[0].assignedNodes) {
            for (i = 0; i < slots.length; i++) {
              nodes = slots[i].assignedNodes({
                flatten: true
              });

              for (j = 0; j < nodes.length; j++) {
                if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                  result.add(nodes[j]);
                }
              }
            } // No need to search for <content>.

          }

          return result;
        }

      }

      document.$blockingElements = new BlockingElementsImpl();
    })();

    function blockingElements() {
      return getDocument$e().$blockingElements;
    }
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */


    function useBlockingElement(enabled, getTarget) {
      const stableGetTarget = useStableCallback(getTarget);
      /**
       * Push/pop the element from the blockingElements stack.
       */

      _(() => {
        const target = stableGetTarget();

        if (enabled) {
          // Sometimes blockingElements will fail if, for example,
          // the target element isn't connected to document.body.
          // This is rare, but it's better to fail silently with weird tabbing behavior
          // than to crash the entire application.
          try {
            blockingElements().push(target);
            return () => {
              blockingElements().remove(target);
            };
          } catch (ex) {
            // Well, semi-silently.
            console.error(ex);
          }
        }
      }, [enabled]);
    }
    function getTopElement() {
      return blockingElements().top;
    }

    const elementsToRestoreFocusTo = new Map();
    function useFocusTrap(_ref) {
      let {
        trapActive
      } = _ref;
      const handleActiveChange = q$1((trapActive, element) => {
        if (trapActive && element) {
          let rafHandle = requestAnimationFrame(() => {
            // TODO: This extra queueMicrotask is needed for
            // ...reasons?
            queueMicrotask(() => {
              var _findFirstFocusable;

              (_findFirstFocusable = findFirstFocusable(element)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        } else if (element) {
          // Restore the focus to the element
          // that has returned to the top of the stack
          let rafHandle = requestAnimationFrame(() => {
            queueMicrotask(() => {
              var _elementsToRestoreFoc;

              (_elementsToRestoreFoc = elementsToRestoreFocusTo.get(getTopElement())) === null || _elementsToRestoreFoc === void 0 ? void 0 : _elementsToRestoreFoc.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        }
      }, []);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: useStableCallback(element => handleActiveChange(trapActive, element))
      });
      const {
        getLastActiveElement
      } = useActiveElement({
        getDocument: useStableCallback(() => {
          var _getElement$ownerDocu, _getElement;

          return (_getElement$ownerDocu = (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.ownerDocument) !== null && _getElement$ownerDocu !== void 0 ? _getElement$ownerDocu : window.document;
        })
      }); // When the trap becomes active, before we let the blockingElements hook run,
      // keep track of whatever's currently focused and save it.

      _(() => {
        const element = getElement();

        if (trapActive && element) {
          var _getLastActiveElement;

          const document = getDocument$e(element); // Save the currently focused element
          // to whatever's currently at the top of the stack

          elementsToRestoreFocusTo.set(getTopElement(), (_getLastActiveElement = getLastActiveElement()) !== null && _getLastActiveElement !== void 0 ? _getLastActiveElement : document.body);
        }
      }, [trapActive]);
      useBlockingElement(trapActive, getElement);
      /**
       * Any time we activate or deactivate the trap,
       * change focus to something else (something in
       * the trap if it's active, or whatever we've
       * tracked in elementsToRestoreFocusTo if not)
       */

      _(() => {
        handleActiveChange(trapActive, getElement());
      }, [trapActive]);

      const useFocusTrapProps = props => {
        const p1 = useRefElementProps(props);
        const p2 = {
          "aria-modal": trapActive ? "true" : undefined
        };
        return useMergedProps(p1, p2);
      };

      return {
        useFocusTrapProps,
        getElement
      };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */

    function findFirstFocusable(element) {
      const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: node => node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      });
      const firstFocusable = treeWalker.firstChild();
      return firstFocusable;
    }

    /**
     * Returns a function that will, when called, force the component
     * that uses this hook to re-render itself.
     *
     * It's a bit smelly, so best to use sparingly.
     */

    function useForceUpdate() {
      const [, set] = y(0);
      return A(() => set(i => ++i)).current;
    }

    function useHasFocus(_ref) {
      let {
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onLastActiveElementChange,
        onActiveElementChange,
        onWindowFocusedChange,
        getDocument,
        getWindow,
        onElementChange,
        onMount,
        onUnmount
      } = _ref;
      useEnsureStability("useHasFocus", onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange);
      const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse$1);
      const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse$1);
      const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse$1);
      const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse$1);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange,
        onMount,
        onUnmount
      });
      const {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      } = useActiveElement({
        getDocument,
        getWindow,
        onActiveElementChange: q$1((activeElement, prevActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == activeElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(activeElement));
          setFocused(focused);
          setFocusedInner(focusedInner);
          onActiveElementChange === null || onActiveElementChange === void 0 ? void 0 : onActiveElementChange(activeElement, prevActiveElement);
        }, []),
        onLastActiveElementChange: q$1((lastActiveElement, prevLastActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == lastActiveElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(lastActiveElement));
          setLastFocused(focused);
          setLastFocusedInner(focusedInner);
          onLastActiveElementChange === null || onLastActiveElementChange === void 0 ? void 0 : onLastActiveElementChange(lastActiveElement, prevLastActiveElement);
        }, []),
        onWindowFocusedChange
      });
      const useHasFocusProps = q$1(props => {
        return useRefElementProps(props);
      }, []);
      return {
        useHasFocusProps,
        getElement,
        getFocused,
        getFocusedInner,
        getLastFocused,
        getLastFocusedInner,
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }
    function useChildrenHaveFocus(_ref2) {
      let {
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref2;
      const {
        managedChildren,
        useManagedChild
      } = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      const allElementsRef = A(new Set());
      const [_getFocusCount, setFocusCount] = usePassiveState(useStableCallback((anyFocused, anyPreviouslyFocused) => {
        console.log(`Changing focus count from ${anyPreviouslyFocused} to ${anyFocused}`);
        console.assert(anyFocused >= 0 && anyFocused <= 1);
        if (anyFocused && !anyPreviouslyFocused) onAnyGainedFocus === null || onAnyGainedFocus === void 0 ? void 0 : onAnyGainedFocus();
        if (!anyFocused && anyPreviouslyFocused) onAllLostFocus === null || onAllLostFocus === void 0 ? void 0 : onAllLostFocus();
      }));
      const useChildrenHaveFocusChild = q$1(_ref3 => {
        let {
          onElementChange,
          onMount,
          onUnmount,
          getDocument,
          getWindow,
          onActiveElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onWindowFocusedChange,
          managedChild: {
            index,
            flags
          }
        } = _ref3;
        useManagedChild({
          managedChild: {
            index,
            subInfo: {},
            flags
          }
        });
        const {
          useHasFocusProps,
          ...hasFocus
        } = useHasFocus({
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange: q$1((e, prev) => {
            let r = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prev);

            if (e) {
              allElementsRef.current.add(e);
              return () => {
                r === null || r === void 0 ? void 0 : r();
                allElementsRef.current.delete(e);
              };
            }
          }, [onElementChange]),
          onMount,
          onUnmount,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged: useStableCallback((focused, prev) => {
            if (focused) {
              console.log(`Child ${index} is focused`);
              setFocusCount(p => (p !== null && p !== void 0 ? p : 0) + 1);
            } else if (!focused && prev) {
              console.log(`Child ${index} is unfocused`);
              setFocusCount(p => (p !== null && p !== void 0 ? p : 0) - 1);
            }

            onLastFocusedInnerChanged === null || onLastFocusedInnerChanged === void 0 ? void 0 : onLastFocusedInnerChanged(focused, prev);
          }),
          onWindowFocusedChange
        });
        return {
          useChildrenHaveFocusChildProps: useHasFocusProps,
          ...hasFocus
        };
      }, []);
      return {
        managedChildren,
        useChildrenHaveFocusChild
      };
    }

    /**
     * Adds the necessary event handlers to create a "press"-like event for
     * any element, whether it's a native <BUTTON> or regular <DIV>.
     *
     * Notably, the following cases are covered:
     * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
     * * Double-clicks won't select text.
     * * Conversely, manually selecting text won't invoke a press.
     * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
     * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClickSync
     * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
     */

    function usePress(_ref) {
      let {
        exclude,
        hasFocus: {
          onFocusedInnerChanged,
          ...hasFocus
        },
        onClickSync
      } = _ref;
      // A button can be activated in multiple ways, so on the off chance
      // that multiple are triggered at once, we only *actually* register
      // a press once all of our "on" signals have turned back to "off".
      // We approximate this by just incrementing when active, and
      // decrementing when deactivated.
      //
      // As an emergency failsafe, when the element loses focus,
      // this is reset back to 0.
      const [active, setActive, getActive] = useState(0);
      const forceUpdate = useForceUpdate();
      const {
        useHasFocusProps,
        getElement
      } = useHasFocus({ ...hasFocus,
        onFocusedInnerChanged: useStableCallback((f, p) => {
          onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(f, p);

          if (!f) {
            setActive(0);
          }
        })
      }); // If we the current text selection changes to include this element
      // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
      // because its only purpose was selecting text, not clicking buttons.
      //
      // To catch this, any time the text selection includes us while in the middle
      // of a click, this flag is set, which cancels the activation of a press.
      // The flag is reset any time the selection is empty or the button is
      // no longer active.

      const [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
      const pseudoActive = active && textSelectedDuringActivationStartTime == null;
      useGlobalHandler(document, "selectionchange", _ => {
        setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
      });
      s(() => {
        if (active == 0) setTextSelectedDuringActivationStartTime(null);
      }, [active == 0]);
      const onActiveStart = useStableCallback(_ => {
        setActive(a => ++a);
      });
      const onActiveStop = useStableCallback(e => {
        setActive(a => Math.max(0, --a));
        const currentTime = new Date();
        const timeDifference = textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime;
        const charactersSelected = nodeSelectedTextLength(getElement()); // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
        // then this isn't a press event.
        // TODO: This should measure glyphs instead of characters.

        if (charactersSelected > 1 || (timeDifference !== null && timeDifference !== void 0 ? timeDifference : 0) > 250 && charactersSelected >= 1) {
          e.preventDefault();
          return;
        }

        if (getActive() <= 0) {
          handlePress(e);
          forceUpdate(); // TODO: Remove when issue resolved https://github.com/preactjs/preact/issues/3731
        }
      });
      const handlePress = useStableCallback(e => {
        if (onClickSync) {
          // Note: The element is focused here because of iOS Safari.
          //
          // It's always iOS Safari.
          //
          // iOS Safari (tested on 12) downright refuses to allow 
          // elements to be manually focused UNLESS it happens within
          // an event handler like this.  It also doesn't focus
          // buttons by default when clicked, tapped, etc.
          //
          // If it becomes problematic that button-likes explicitly become
          // focused when they are pressed, then an alternative solution for
          // the question of "how do menu buttons keep their menus open"
          // and other focus-related nonsense needs to be figured out.
          //
          // For iOS Safari.
          //
          const element = getElement();
          if (element && "focus" in element) element === null || element === void 0 ? void 0 : element.focus(); // Whatever the browser was going to do with this event,
          // forget it. We're turning it into a "press" event.

          e.preventDefault(); // Also stop anyone else from listening to this event,
          // since we're explicitly handling it.
          // (Notably, this allows labels to wrap inputs, with them
          // both having press event handlers, without double-firing)

          e.stopPropagation(); // Haptic feedback for this press event

          try {
            // The default implementation doesn't throw,
            // but we should guard against user implementations that could.
            pulse();
          } finally {
            // Actually call our handler.
            onClickSync(e);
          }
        }
      });
      const onMouseDown = excludes("click", exclude) ? undefined : e => {
        // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
        // but also don't prevent the user from selecting that text manually if they really want to
        // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
        if (e.detail > 1) e.preventDefault();
        if (e.button === 0) onActiveStart(e);
      };
      const onMouseUp = excludes("click", exclude) ? undefined : e => {
        if (e.button === 0 && active > 0) onActiveStop(e);
      };
      const onMouseLeave = useStableCallback(() => {
        if (!excludes("click", exclude)) setActive(0);
      });
      const onKeyDown = excludes("space", exclude) && excludes("enter", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync && !excludes("space", exclude)) {
          // We don't actually activate it on a space keydown
          // but we do preventDefault to stop the page from scrolling.
          onActiveStart(e);
          e.preventDefault();
        }

        if (e.key == "Enter" && !excludes("enter", exclude)) {
          e.preventDefault();
          onActiveStart(e);
          onActiveStop(e);
        }
      };
      const onKeyUp = excludes("space", exclude) ? undefined : e => {
        if (e.key == " " && !excludes("space", exclude)) onActiveStop(e);
      };

      const onClick = e => {
        e.preventDefault();

        if (e.detail > 1) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
      };

      return function usePressProps(props) {
        return useMergedProps(props, useHasFocusProps({
          onKeyDown,
          onKeyUp,
          onMouseDown,
          onMouseUp,
          onMouseLeave,
          onClick,
          style: textSelectedDuringActivationStartTime != null ? {
            cursor: "text"
          } : undefined,
          ...{
            "data-pseudo-active": pseudoActive ? "true" : undefined
          }
        }));
      };
    }
    /**
     * selection.containsNode doesn't account for selection.isCollapsed,
     * so here's a workaround for that.
     *
     * We also only look for the selection end to only catch the
     * essense of a non-existant "selectionstop" event.
     *
     * @param element
     * @returns
     */

    function nodeSelectedTextLength(element) {
      if (element && element instanceof Node) {
        const selection = window.getSelection();

        for (let i = 0; i < ((_selection$rangeCount = selection === null || selection === void 0 ? void 0 : selection.rangeCount) !== null && _selection$rangeCount !== void 0 ? _selection$rangeCount : 0); ++i) {
          var _selection$rangeCount;

          const range = selection.getRangeAt(i);

          if (element.contains(range.endContainer) && !(selection !== null && selection !== void 0 && selection.isCollapsed)) {
            return selection.toString().length;
          }
        }
      }

      return 0;
    }

    let pulse = "vibrate" in navigator && navigator.vibrate instanceof Function ? () => navigator.vibrate(10) : () => {};

    function excludes(target, exclude) {
      if (exclude !== null && exclude !== void 0 && exclude[target]) return true;
      return false;
    }

    function useTimeout(_ref) {
      let {
        timeout,
        callback,
        triggerIndex
      } = _ref;
      const stableCallback = useStableCallback(() => {
        startTimeRef.current = null;
        callback();
      });
      const getTimeout = useStableGetter(timeout); // Set any time we start timeout.
      // Unset any time the timeout completes

      const startTimeRef = A(null);
      const timeoutIsNull = timeout == null; // Any time the triggerIndex changes (including on mount)
      // restart the timeout.  The timeout does NOT reset
      // when the duration or callback changes, only triggerIndex.

      s(() => {
        if (!timeoutIsNull) {
          const timeout = getTimeout();
          console.assert(timeoutIsNull == (timeout == null));

          if (timeout != null) {
            startTimeRef.current = +new Date();
            const handle = setTimeout(stableCallback, timeout);
            return () => clearTimeout(handle);
          }
        }
      }, [triggerIndex, timeoutIsNull]);
      const getElapsedTime = q$1(() => {
        var _startTimeRef$current;

        return +new Date() - +((_startTimeRef$current = startTimeRef.current) !== null && _startTimeRef$current !== void 0 ? _startTimeRef$current : new Date());
      }, []);
      const getRemainingTime = q$1(() => {
        const timeout = getTimeout();
        return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
      }, []);
      return {
        getElapsedTime,
        getRemainingTime
      };
    }

    /** Arguments passed to the child 'useLinearNavigationChild` */
    //export interface UseLinearNavigationChildInfo { }

    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useLinearNavigation(_ref) {
      var _nd;

      let {
        linearNavigation: {
          navigateToFirst: ntf,
          navigateToLast: ntl,
          navigateToNext: ntn,
          navigateToPrev: ntp,
          navigationDirection: nd,
          disableArrowKeys: dak,
          disableHomeEndKeys: dhek
        }
      } = _ref;
      (_nd = nd) !== null && _nd !== void 0 ? _nd : nd = "either"; //const { getLogicalDirectionInfo, useLogicalDirectionProps } = useLogicalDirection<ParentOrChildElement>({});

      const navigateToFirst = useStableCallback(ntf);
      const navigateToLast = useStableCallback(ntl);
      const navigateToNext = useStableCallback(ntn);
      const navigateToPrev = useStableCallback(ntp);
      const getDisableArrowKeys = useStableGetter(dak);
      const getDisableHomeEndKeys = useStableGetter(dhek);
      const getNavigationDirection = useStableGetter(nd);
      return {
        linearNavigation: {},
        useLinearNavigationProps: q$1(props => {
          const onKeyDown = e => {
            // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
            if (e.ctrlKey || e.metaKey) return; //const info = getLogicalDirectionInfo();

            const navigationDirection = getNavigationDirection();
            const disableArrowKeys = getDisableArrowKeys();
            const disableHomeEndKeys = getDisableHomeEndKeys();
            const allowsVerticalNavigation = navigationDirection == "vertical" || navigationDirection == "either";
            const allowsHorizontalNavigation = navigationDirection == "horizontal" || navigationDirection == "either";

            switch (e.key) {
              case "ArrowUp":
                {
                  //const propName = (info?.blockOrientation === "vertical" ? "blockDirection" : "inlineDirection");
                  const directionAllowed = !disableArrowKeys && allowsVerticalNavigation;

                  if (directionAllowed) {
                    navigateToPrev();
                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowDown":
                {
                  const directionAllowed = !disableArrowKeys && allowsVerticalNavigation;

                  if (directionAllowed) {
                    navigateToNext();
                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowLeft":
                {
                  const directionAllowed = !disableArrowKeys && allowsHorizontalNavigation;

                  if (directionAllowed) {
                    navigateToPrev();
                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowRight":
                {
                  const directionAllowed = !disableArrowKeys && allowsHorizontalNavigation;

                  if (directionAllowed) {
                    navigateToNext();
                    e.preventDefault();
                    e.stopPropagation();
                  }

                  e.preventDefault();
                  e.stopPropagation();
                  break;
                }

              case "Home":
                if (!disableHomeEndKeys) {
                  navigateToFirst();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;

              case "End":
                if (!disableHomeEndKeys) {
                  navigateToLast();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;
            }
          };

          return useMergedProps({
            onKeyDown
          }, props);
        }, [])
      };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useTypeaheadNavigation(_ref2) {
      let {
        typeaheadNavigation: {
          collator,
          getIndex,
          typeaheadTimeout,
          setIndex,
          noTypeahead
        }
      } = _ref2;
      // For typeahead, keep track of what our current "search" string is (if we have one)
      // and also clear it every 1000 ms since the last time it changed.
      // Next, keep a mapping of typeahead values to indices for faster searching.
      // And, for the user's sake, let them know when their typeahead can't match anything anymore
      const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
      useTimeout({
        timeout: typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000,
        callback: () => {
          setCurrentTypeahead(null);
          setInvalidTypeahead(null);
        },
        triggerIndex: currentTypeahead
      });
      const sortedTypeaheadInfo = A([]);
      const [invalidTypeahead, setInvalidTypeahead] = useState(false); // Handle typeahead for input method editors as well
      // Essentially, when active, ignore further keys 
      // because we're waiting for a CompositionEnd event

      const [, setImeActive, getImeActive] = useState(false); // Because composition events fire *after* keydown events 
      // (but within the same task, which, TODO, could be browser-dependent),
      // we can use this to keep track of which event we're listening for on the first keydown.

      const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
      _(() => {
        if (nextTypeaheadChar !== null) {
          setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar);
          setNextTypeaheadChar(null);
        }
      }, [nextTypeaheadChar]);
      const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
        var _safeRhs$toLowerCase;

        let compare; // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
        // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.

        safeLhs = safeLhs.normalize("NFD");
        safeRhs = safeRhs.normalize("NFD");
        if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
        return compare;
      });
      const insertingComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          return comparatorShared(lhs, rhs.text);
        }

        return lhs - rhs;
      });
      const typeaheadComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          // During typeahead, all strings longer than ours should be truncated
          // so that they're all considered equally by that point.
          return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
        }

        return lhs - rhs;
      });
      const isDisabled = useStableGetter(noTypeahead);
      const useTypeaheadNavigationProps = q$1(function (_ref3) {
        let { ...props
        } = _ref3;

        const onCompositionStart = _e => {
          setImeActive(true);
        };

        const onCompositionEnd = e => {
          setNextTypeaheadChar(e.data);
          setImeActive(false);
        };

        const onKeyDown = e => {
          if (isDisabled()) return;
          const imeActive = getImeActive();
          const key = e.key; // Not handled by typeahead (i.e. assume this is a keyboard shortcut)

          if (e.ctrlKey || e.metaKey) return;

          if (!imeActive && e.key === "Backspace") {
            // Remove the last character in a way that doesn't split UTF-16 surrogates.
            setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
            e.preventDefault();
            e.stopPropagation();
            return;
          } // The key property represents the typed character OR the "named key attribute" of the key pressed.
          // There's no definite way to tell the difference, but for all intents and purposes
          // there are no one-character names, and there are no non-ASCII-alpha names.
          // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.


          const isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);

          if (isCharacterKey) {
            var _getCurrentTypeahead;

            if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ; else {
              e.preventDefault();
              e.stopPropagation(); // Note: Won't be true for the first keydown
              // but will be overwritten before useLayoutEffect is called
              // to actually apply the change

              if (!imeActive) setNextTypeaheadChar(key);
            }
          }
        };

        return useMergedProps({
          onKeyDown,
          onCompositionStart,
          onCompositionEnd
        }, props);
      }, []); // Handle changes in typeahead that cause changes to the tabbable index

      s(() => {
        if (currentTypeahead && sortedTypeaheadInfo.current.length) {
          const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);

          if (sortedTypeaheadIndex < 0) {
            // The user has typed an entry that doesn't exist in the list
            // (or more specifically "for which there is no entry that starts with that input")
            setInvalidTypeahead(true);
          } else {
            setInvalidTypeahead(false);
            /*
              We know roughly where, in the sorted array of strings, our next typeahead location is.
              But roughly isn't good enough if there are multiple matches.
              To convert our sorted index to the unsorted index we need, we have to find the first
              element that matches us *and* (if any such exist) is *after* our current selection.
                In other words, the only way typeahead moves backwards relative to our current
              position is if the only other option is behind us.
                It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
              Though there's also a case for just going upwards to the nearest to prevent jumpiness.
              But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
              I dunno. Going back to the start is the simplist though.
                Basically what this does: Starting from where we found ourselves after our binary search,
              scan backwards and forwards through all adjacent entries that also compare equally so that
              we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
              (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
                TODO: The binary search starts this off with a solid O(log n), but one-character
              searches are, thanks to pigeonhole principal, eventually guaranteed to become
              O(n*log n). This is annoying but probably not easily solvable? There could be an
              exception for one-character strings, but that's just kicking the can down
              the road. Maybe one or two characters would be good enough though.
            */
            // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.

            let lowestUnsortedIndexAll = null;
            let lowestSortedIndexAll = sortedTypeaheadIndex; // These two are only set for elements that are ahead of us, but the principle's the same otherwise

            let lowestUnsortedIndexNext = null;
            let lowestSortedIndexNext = sortedTypeaheadIndex;

            const updateBestFit = u => {
              var _getIndex;

              if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                lowestUnsortedIndexAll = u;
                lowestSortedIndexAll = i;
              }

              if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > ((_getIndex = getIndex()) !== null && _getIndex !== void 0 ? _getIndex : -Infinity)) {
                lowestUnsortedIndexNext = u;
                lowestSortedIndexNext = i;
              }
            };

            let i = sortedTypeaheadIndex;

            while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              --i;
            }

            i = sortedTypeaheadIndex;

            while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              ++i;
            }

            if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
          }
        }
      }, [currentTypeahead]);
      const useTypeaheadNavigationChild = q$1(_ref4 => {
        let {
          index,
          text
        } = _ref4;
        s(() => {
          if (text) {
            // Find where to insert this item.
            // Because all index values should be unique, the returned sortedIndex
            // should always refer to a new location (i.e. be negative)                
            const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
            console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
              unsortedIndex: index,
              text
            }) == 0);

            if (sortedIndex < 0) {
              sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, {
                text,
                unsortedIndex: index
              });
            } else {
              sortedTypeaheadInfo.current.splice(sortedIndex, 0, {
                text,
                unsortedIndex: index
              });
            }

            return () => {
              // When unmounting, find where we were and remove ourselves.
              // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
              const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
              console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
                unsortedIndex: index,
                text
              }) == 0);

              if (sortedIndex >= 0) {
                sortedTypeaheadInfo.current.splice(sortedIndex, 1);
              }
            };
          }
        }, [text]);
        return;
      }, []);
      return {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
      };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */

    function binarySearch(array, wanted, comparator) {
      let firstIndex = 0;
      let lastIndex = array.length - 1;

      while (firstIndex <= lastIndex) {
        const testIndex = lastIndex + firstIndex >> 1;
        const comparisonResult = comparator(wanted, array[testIndex]);

        if (comparisonResult > 0) {
          firstIndex = testIndex + 1;
        } else if (comparisonResult < 0) {
          lastIndex = testIndex - 1;
        } else {
          return testIndex;
        }
      }

      return -firstIndex - 1;
    }

    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `shouldFocusOnChange` should return true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const [focusedInner, setFocusedInner] = useState(false);
     * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */

    function useRovingTabIndex(parentParameters) {
      var _initialIndex;

      let {
        rovingTabIndex: {
          initialIndex,
          onTabbableRender,
          onTabbableIndexChange
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters;
      (_initialIndex = initialIndex) !== null && _initialIndex !== void 0 ? _initialIndex : initialIndex = 0;
      const stableOnTabbableRender = useStableCallback(onTabbableRender !== null && onTabbableRender !== void 0 ? onTabbableRender : () => {});
      /*const [_getAnyFocused, setAnyFocused] = usePassiveState<number>(useStableCallback((newCount: number, oldCount: number | undefined) => {
          if (oldCount == 0 && newCount > 0) {
              onTabbedInTo?.();
          }
            if (newCount == 0 && (oldCount ?? 0) > 0) {
              onTabbedOutOf?.();
          }
      }), returnZero);*/
      // Keep track of three things related to the currently tabbable element's index:
      // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.

      const [getTabbableIndex, setTabbableIndex2] = usePassiveState(onTabbableIndexChange, q$1(() => {
        var _initialIndex2;

        return (_initialIndex2 = initialIndex) !== null && _initialIndex2 !== void 0 ? _initialIndex2 : 0;
      }, []));
      const setTabbableIndex = q$1((updater, fromUserInteraction) => {
        setTabbableIndex2(prevIndex => {
          let nextIndex = prevIndex;
          if (typeof updater === "function") nextIndex = updater(prevIndex !== null && prevIndex !== void 0 ? prevIndex : null);else nextIndex = updater;
          nextIndex = changeIndex(nextIndex);

          if (prevIndex != nextIndex) {
            const nextChild = nextIndex == null ? null : parentReturnType.managedChildren.children.getAt(nextIndex); //const prevChild = prevIndex == null ? null : parentReturnType.managedChildren.children.getAt(prevIndex);
            //if (prevChild != null)
            //    prevChild.subInfo.blurSelf();

            if (nextChild != null && fromUserInteraction) nextChild.subInfo.focusSelf();
          }

          return nextIndex;
        });
      }, []); // Any time the tabbable index changes,
      // notify the previous child that it's no longer tabbable,
      // and notify the next child that is allowed to be tabbed to.

      const parentReturnType = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange: useStableCallback((mounted, unmounted) => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(mounted, unmounted);
            reevaluateClosestFit();
          })
        }
      });
      const {
        useManagedChild
      } = parentReturnType;
      const {
        changeIndex,
        reevaluateClosestFit
      } = useChildrenFlag({
        initialIndex,
        children: parentReturnType.managedChildren.children,
        closestFit: true,
        key: "tabbable"
      });
      const useRovingTabIndexChild = q$1(childParameters => {
        const {
          subInfo,
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            hidden,
            focusSelf: focusSelfOverride
          }
        } = childParameters;
        s(() => {
          reevaluateClosestFit();
        }, [!!hidden]);
        const fsOverride = useStableGetter(focusSelfOverride);
        const focusSelf = q$1(() => {
          const fs = fsOverride();

          if (fs) {
            fs();
          } else {
            var _element$focus;

            const element = getElement();
            if (element) (_element$focus = element.focus) === null || _element$focus === void 0 ? void 0 : _element$focus.call(element);
          }
        }, []);
        /*const blurSelf = useCallback(() => {
            const bs = bsOverride();
            if (bs) {
                bs();
            }
            else {
                const element = getElement() as (Element & Partial<HTMLElement>);
                if (element)
                    element.blur?.();
            }
        }, []);*/

        const onFocusedInnerChanged = useStableCallback((focused, _prevFocused) => {
          if (focused) {
            setTabbableIndex(index, false);
          }
        });
        const {
          getElement,
          useHasFocusProps
        } = useHasFocus({
          onFocusedInnerChanged,
          getDocument: q$1(() => {
            var _getElement$ownerDocu, _getElement;

            return (_getElement$ownerDocu = (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.ownerDocument) !== null && _getElement$ownerDocu !== void 0 ? _getElement$ownerDocu : window.document;
          }, [])
        });
        const [tabbable, setTabbable, getTabbable] = useState(false);
        const tabbableFlags = A({
          get: getTabbable,
          set: setTabbable,
          isValid: useStableCallback(() => !hidden)
        });

        useManagedChild({
          managedChild: {
            index,
            flags: { ...flags,
              tabbable: tabbableFlags.current
            },
            subInfo: {
              //blurSelf,
              focusSelf,
              getElement,
              hidden: !!hidden,
              subInfo
            }
          }
        });

        s(() => {
          if (tabbable) stableOnTabbableRender(index);
        }, [tabbable, index]);

        function useRovingTabIndexChildProps(props) {
          console.assert(props.tabIndex == null);
          return useMergedProps(useHasFocusProps({
            tabIndex: tabbable ? 0 : -1
          }), props);
        }

        return {
          useRovingTabIndexChildProps,
          rovingTabIndex: {
            getElement,
            tabbable,
            getTabbable
          }
        };
      }, [
        /* Must remain stable */
      ]);
      const focusSelf = q$1(() => {
        var _parentReturnType$man, _parentReturnType$man2, _parentReturnType$man3;

        console.log(`useRovingTabIndex.focusSelf`);
        const index = getTabbableIndex();
        if (index != null) (_parentReturnType$man = parentReturnType.managedChildren.children.getAt(index)) === null || _parentReturnType$man === void 0 ? void 0 : (_parentReturnType$man2 = (_parentReturnType$man3 = _parentReturnType$man.subInfo).focusSelf) === null || _parentReturnType$man2 === void 0 ? void 0 : _parentReturnType$man2.call(_parentReturnType$man3);else setTabbableIndex(null, true);
      }, []);
      return {
        useRovingTabIndexChild,
        managedChildren: {
          children: parentReturnType.managedChildren.children
        },
        rovingTabIndex: {
          setTabbableIndex,
          getTabbableIndex,
          focusSelf
        }
      };
    }
    /*function test() {
        const { children, focusSelf, getTabbableIndex, setTabbableIndex, useRovingTabIndexChild, } = useRovingTabIndex<HTMLDivElement, { "foo": "bar" }, "flag2">({ managedChildren: {}, rovingTabIndex: {} });
        const { } = useRovingTabIndexChild({ managedChildren: { index: 0, flags: {} }, rti: { info3: { foo: "bar" } } });
    }*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;
      array || (array = Array(length));

      while (++index < length) {
        array[index] = source[index];
      }

      return array;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor,
        nativeRandom = Math.random;
    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */

    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */

    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;
      size = size === undefined ? length : size;

      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];
        array[rand] = array[index];
        array[index] = value;
      }

      array.length = size;
      return array;
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */

    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }

      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */

    function baseValues(object, props) {
      return arrayMap(props, function (key) {
        return object[key];
      });
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }

    /** `Object#toString` result references. */

    var argsTag$1 = '[object Arguments]';
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */

    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }

    /** Used for built-in method references. */

    var objectProto$3 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    /** Built-in value references. */

    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */

    var isArguments = baseIsArguments(function () {
      return arguments;
    }()) ? baseIsArguments : function (value) {
      return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */

    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    /** Built-in value references. */

    var Buffer = moduleExports$1 ? root.Buffer : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */

    var isBuffer = nativeIsBuffer || stubFalse;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */

    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */

    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /** Used to identify `toStringTag` values of typed arrays. */

    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */

    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */

    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        } // Legacy `process.binding('util')` for Node.js < 10.


        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    /* Node.js helper references. */

    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */

    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */

    var objectProto$2 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
        key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */

    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$1;
      return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */

    var objectProto = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */

    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }

    /** `Object#toString` result references. */

    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */

    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      } // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.


      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */

    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */

    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */

    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */

    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */

    function useRearrangeableChildren(_ref) {
      let {
        rearrangeableChildren: {
          getIndex
        }
      } = _ref;
      // These are used to keep track of a mapping between unsorted index <---> sorted index.
      // These are needed for navigation with the arrow keys.
      const mangleMap = A(new Map());
      const demangleMap = A(new Map());
      const indexMangler = q$1(n => {
        var _mangleMap$current$ge;

        return (_mangleMap$current$ge = mangleMap.current.get(n)) !== null && _mangleMap$current$ge !== void 0 ? _mangleMap$current$ge : n;
      }, []);
      const indexDemangler = q$1(n => {
        var _demangleMap$current$;

        return (_demangleMap$current$ = demangleMap.current.get(n)) !== null && _demangleMap$current$ !== void 0 ? _demangleMap$current$ : n;
      }, []); // The sort function needs to be able to update whoever has all the sortable children.
      // Because that might not be the consumer of *this* hook directly (e.g. a table uses
      // this hook, but it's tbody that actually needs updating), we need to remotely
      // get and set a forceUpdate function.
      //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);

      const [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
      const rearrange = q$1(sortedRows => {
        var _getForceUpdate;

        // Update our sorted <--> unsorted indices map 
        // and rerender the whole table, basically
        for (let indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
          const indexAsUnsorted = sortedRows[indexAsSorted].index;
          mangleMap.current.set(indexAsUnsorted, indexAsSorted);
          demangleMap.current.set(indexAsSorted, indexAsUnsorted);
        }

        (_getForceUpdate = getForceUpdate()) === null || _getForceUpdate === void 0 ? void 0 : _getForceUpdate();
      }, []);
      const useRearrangeableProps = q$1(_ref2 => {
        let {
          children,
          ...props
        } = _ref2;
        const forceUpdate = useForceUpdate();
        _(() => {
          setForceUpdate(_prev => forceUpdate);
        }, [forceUpdate]);
        return useMergedProps({
          children: children.slice().map(child => ({
            child,
            mangledIndex: indexMangler(getIndex(child.props)),
            demangledIndex: getIndex(child.props)
          })).sort((lhs, rhs) => {
            return lhs.mangledIndex - rhs.mangledIndex;
          }).map(_ref3 => {
            let {
              child,
              mangledIndex,
              demangledIndex
            } = _ref3;
            return h$1(child.type, { ...child.props,
              key: demangledIndex,
              "data-mangled-index": mangledIndex,
              "data-unmangled-index": demangledIndex
            });
          })
        }, props);
      }, []);
      return {
        useRearrangeableProps,
        rearrangeableChildren: {
          indexMangler,
          indexDemangler,
          mangleMap,
          demangleMap,
          rearrange
        }
      };
    }
    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */

    function useSortableChildren(_ref4) {
      let {
        rearrangeableChildren: {
          getIndex
        },
        sortableChildren: {
          compare: userCompare,
          getValue
        }
      } = _ref4;
      const compare = userCompare !== null && userCompare !== void 0 ? userCompare : defaultCompare;
      const {
        useRearrangeableProps: useSortableProps,
        ...rearrangeableChildrenReturnType
      } = useRearrangeableChildren({
        rearrangeableChildren: {
          getIndex
        }
      });
      const {
        rearrangeableChildren: {
          rearrange
        }
      } = rearrangeableChildrenReturnType; // The actual sort function.

      const sort = q$1(function (managedRows, direction) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        const sortedRows = managedRows.arraySlice().sort((lhsRow, rhsRow) => {
          const lhsValue = getValue(lhsRow, ...args);
          const rhsValue = getValue(rhsRow, ...args);
          const result = compare(lhsValue, rhsValue); // lhsRow.getManagedCells()?.[column]?.value, rhsRow.getManagedCells()?.[column]?.value);

          if (direction[0] == "d") return -result;
          return result;
        });
        return rearrange(sortedRows);
      }, [
        /* Must remain stable */
      ]);
      const shuffle$1 = q$1(managedRows => {
        const shuffledRows = shuffle(managedRows.arraySlice());
        return rearrange(shuffledRows);
      }, [
        /* Must remain stable */
      ]);
      return {
        useSortableProps,
        sortableChildren: {
          sort,
          shuffle: shuffle$1
        },
        rearrangeableChildren: rearrangeableChildrenReturnType.rearrangeableChildren
      };
    }

    function defaultCompare(lhs, rhs) {
      return compare1(lhs, rhs);

      function compare3(lhs, rhs) {
        // Coerce strings to numbers if they seem to stay the same when serialized
        if (`${+lhs}` === lhs) lhs = +lhs;
        if (`${+rhs}` === rhs) rhs = +rhs; // At this point, if either argument is a string, turn the other one into one too

        if (typeof lhs === "string") rhs = `${rhs}`;
        if (typeof rhs === "string") lhs = `${lhs}`;
        console.assert(typeof lhs === typeof rhs);
        if (typeof lhs === "string") return lhs.localeCompare(rhs);
        if (typeof lhs === "number") return +lhs - +rhs;
        return 0;
      }

      function compare2(lhs, rhs) {
        if (typeof lhs === "boolean" || lhs instanceof Date) lhs = +lhs;
        if (typeof rhs === "boolean" || rhs instanceof Date) rhs = +rhs;
        return compare3(lhs, rhs);
      }

      function compare1(lhs, rhs) {
        if (lhs == null && rhs == null) {
          // They're both null
          return 0;
        } else if (lhs == null || rhs == null) {
          // One of the two is null -- easy case
          return lhs != null ? 1 : -1;
        }

        return compare2(lhs, rhs);
      }
    }

    function identity$2(t) {
      return t;
    }
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */


    function useListNavigation(_ref) {
      var _indexMangler, _indexDemangler;

      let {
        managedChildren: {
          onChildrenMountChange,
          ...mc
        },
        rovingTabIndex,
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        linearNavigation,
        typeaheadNavigation
      } = _ref;
      (_indexMangler = indexMangler) !== null && _indexMangler !== void 0 ? _indexMangler : indexMangler = identity$2;
      (_indexDemangler = indexDemangler) !== null && _indexDemangler !== void 0 ? _indexDemangler : indexDemangler = identity$2;
      useEnsureStability("useListNavigation", indexMangler, indexDemangler);
      const parentReturnType = useRovingTabIndex({
        managedChildren: { ...mc,
          onChildrenMountChange: q$1((m, u) => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(m, u);
          }, [])
        },
        rovingTabIndex
      });
      const {
        useRovingTabIndexChild,
        managedChildren: {
          children
        },
        rovingTabIndex: {
          getTabbableIndex,
          setTabbableIndex
        }
      } = parentReturnType;
      const navigateToIndex = q$1((i, fromUserInteraction) => {
        if (i != null) {
          var _indexMangler2, _indexDemangler2;

          const nextIndex = tryNavigateToIndex({
            children: children,
            default: 0,
            target: i,
            searchDirection: 1,
            indexMangler: (_indexMangler2 = indexMangler) !== null && _indexMangler2 !== void 0 ? _indexMangler2 : identity$2,
            indexDemangler: (_indexDemangler2 = indexDemangler) !== null && _indexDemangler2 !== void 0 ? _indexDemangler2 : identity$2
          });
          setTabbableIndex(i == null ? null : nextIndex, fromUserInteraction);
        } else {
          setTabbableIndex(null, fromUserInteraction);
        }
      }, []);
      const {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
      } = useTypeaheadNavigation({
        typeaheadNavigation: {
          getIndex: getTabbableIndex,
          setIndex: q$1(index => {
            setTabbableIndex(index, true);
          }, []),
          ...typeaheadNavigation
        }
      });
      const {
        useLinearNavigationProps
      } = useLinearNavigation({
        linearNavigation: {
          navigateToPrev: q$1(() => {
            setTabbableIndex(c => {
              var _indexMangler3, _indexDemangler3;

              return tryNavigateToIndex({
                children,
                default: c !== null && c !== void 0 ? c : 0,
                target: indexDemangler(indexMangler(c !== null && c !== void 0 ? c : 0) - 1),
                searchDirection: -1,
                indexMangler: (_indexMangler3 = indexMangler) !== null && _indexMangler3 !== void 0 ? _indexMangler3 : identity$2,
                indexDemangler: (_indexDemangler3 = indexDemangler) !== null && _indexDemangler3 !== void 0 ? _indexDemangler3 : identity$2
              });
            }, true);
          }, []),
          navigateToNext: q$1(() => {
            setTabbableIndex(c => {
              var _indexMangler4, _indexDemangler4;

              return tryNavigateToIndex({
                children,
                default: c !== null && c !== void 0 ? c : 0,
                target: indexDemangler(indexMangler(c !== null && c !== void 0 ? c : 0) + 1),
                searchDirection: 1,
                indexMangler: (_indexMangler4 = indexMangler) !== null && _indexMangler4 !== void 0 ? _indexMangler4 : identity$2,
                indexDemangler: (_indexDemangler4 = indexDemangler) !== null && _indexDemangler4 !== void 0 ? _indexDemangler4 : identity$2
              });
            }, true);
          }, []),
          navigateToFirst: q$1(() => {
            navigateToIndex(indexDemangler(0), true);
          }, []),
          navigateToLast: q$1(() => {
            navigateToIndex(indexDemangler(children.getHighestIndex()), true);
          }, []),
          ...linearNavigation
        }
      });
      const useListNavigationProps = q$1(props => {
        return useLinearNavigationProps(useTypeaheadNavigationProps(props));
      }, [useLinearNavigationProps, useTypeaheadNavigationProps]);
      const useListNavigationChild = q$1(_ref2 => {
        let {
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            focusSelf,
            hidden
          },
          listNavigation: {
            text
          },
          subInfo
        } = _ref2;

        useTypeaheadNavigationChild({
          text,
          index
        });

        const getIndex = useStableGetter(index);
        s(() => {
          return () => {
            if (getTabbableIndex() == getIndex()) {
              navigateToIndex(index, false);
            }
          };
        }, []);
        const {
          useRovingTabIndexChildProps,
          rovingTabIndex: {
            tabbable,
            getTabbable,
            getElement
          }
        } = useRovingTabIndexChild({
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            focusSelf,
            hidden: !!hidden
          },
          subInfo: {
            text,
            subInfo
          }
        });

        const useListNavigationChildProps = function (_ref3) {
          let { ...props
          } = _ref3;
          return useMergedProps(useRovingTabIndexChildProps({
            inert: hidden
          }), props);
        };

        return {
          useListNavigationChildProps,
          rovingTabIndex: {
            tabbable,
            getTabbable,
            getElement
          }
        };
      }, [useTypeaheadNavigationChild, useRovingTabIndexChild, navigateToIndex]);
      return {
        useListNavigationChild,
        useListNavigationProps,
        listNavigation: {
          navigateToIndex
        },
        managedChildren: parentReturnType.managedChildren,
        rovingTabIndex: parentReturnType.rovingTabIndex,
        linearNavigation: {},
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
        /*listNavigation: { navigateToIndex },
        rovingTabIndex: { focusSelf, getTabbableIndex, setTabbableIndex },
        linearNavigation: {},
        typeaheadNavigation: { currentTypeahead, invalidTypeahead }*/

      };
    }
    /**
     * It's very common to combine a tabbable list of things and "selection" of one of those things.
     *
     * Lists, radio buttons, tabs, etc. etc.
     *
     * This is a shortcut that combines the two with the correct typing.
     * @param param0
     * @returns
     */

    function useListNavigationSingleSelection(_ref4) {
      let {
        singleSelection: {
          selectedIndex,
          selectionMode,
          onSelectedIndexChange
        },
        listNavigation,
        managedChildren,
        rovingTabIndex: { ...rovingTabIndex
        },
        linearNavigation,
        typeaheadNavigation,
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        }
      } = _ref4;
      const parentReturnType = useListNavigation({
        listNavigation,
        managedChildren,
        rovingTabIndex: {
          initialIndex: selectedIndex !== null && selectedIndex !== void 0 ? selectedIndex : undefined,
          ...rovingTabIndex
        },
        linearNavigation,
        typeaheadNavigation
      });
      const {
        useChildrenHaveFocusChild
      } = useChildrenHaveFocus({
        childrenHaveFocus: {
          onAllLostFocus: useStableCallback(() => {
            onAllLostFocus === null || onAllLostFocus === void 0 ? void 0 : onAllLostFocus();
            if (selectedIndex != null) setTabbableIndex(selectedIndex, false);
          }),
          onAnyGainedFocus
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const stableOnChange = useStableCallback(onSelectedIndexChange);
      const {
        useListNavigationChild,
        useListNavigationProps,
        ...listRest
      } = parentReturnType;
      const {
        managedChildren: {
          children
        },
        rovingTabIndex: {
          setTabbableIndex
        }
      } = listRest;
      const {
        changeIndex: changeSelectedIndex,
        getCurrentIndex: getSelectedIndex //reevaluateClosestFit

      } = useChildrenFlag({
        children: children,
        initialIndex: selectedIndex,
        key: "selected",
        closestFit: false
      });
      _(() => {
        changeSelectedIndex(selectedIndex);
      }, [selectedIndex]);
      return {
        useListNavigationSingleSelectionChild: q$1(_ref5 => {
          let {
            managedChild: {
              index,
              flags
            },
            rovingTabIndex: rti,
            listNavigation: ls,
            hasFocus: {
              onFocusedInnerChanged,
              ...hasFocus
            },
            subInfo
          } = _ref5;
          const [isSelected, setIsSelected, getIsSelected] = useState(getSelectedIndex() == index);
          const selectedRef = A({
            get: getIsSelected,
            set: setIsSelected,
            isValid: useStableCallback(() => !rti.hidden)
          });
          const {
            useChildrenHaveFocusChildProps,
            getElement
          } = useChildrenHaveFocusChild({
            onFocusedInnerChanged: useStableCallback((focused, prev) => {
              onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);

              if (selectionMode == 'focus' && focused) {
                stableOnChange({
                  target: getElement(),
                  currentTarget: getElement()
                }, getIndex());
              }
            }),
            ...hasFocus,
            managedChild: {
              index
            }
          });
          const {
            rovingTabIndex: rti_ret,
            useListNavigationChildProps
          } = useListNavigationChild({
            managedChild: {
              index,
              flags: {
                selected: selectedRef.current,
                ...flags
              }
            },
            rovingTabIndex: rti,
            listNavigation: ls,
            subInfo
          });
          const getIndex = useStableGetter(index);
          const usePressProps = usePress({
            onClickSync: e => {
              stableOnChange(e, getIndex());
            },
            exclude: {},
            hasFocus
          });
          return {
            useListNavigationSingleSelectionChildProps: props => usePressProps(useChildrenHaveFocusChildProps(useListNavigationChildProps(props))),
            rovingTabIndex: rti_ret,
            singleSelection: {
              selected: isSelected,
              getSelected: getIsSelected
            }
          };
        }, [selectionMode]),
        useListNavigationSingleSelectionProps: q$1(function () {
          return useListNavigationProps(...arguments);
        }, []),
        ...listRest,
        singleSelection: {}
      };
    }
    function tryNavigateToIndex(_ref8) {
      let {
        children,
        searchDirection,
        indexDemangler,
        indexMangler,
        target
      } = _ref8;
      const upper = children.getHighestIndex();
      const lower = 0;

      if (searchDirection === -1) {
        while (target >= lower && children.getAt(target) == null || !!((_children$getAt = children.getAt(target)) !== null && _children$getAt !== void 0 && _children$getAt.subInfo.hidden)) {
          var _children$getAt;

          target = indexDemangler(indexMangler(target) - 1);
        }

        return target < lower ? indexDemangler(lower) : target;
      } else if (searchDirection === 1) {
        while (target <= upper && children.getAt(target) == null || !!((_children$getAt2 = children.getAt(target)) !== null && _children$getAt2 !== void 0 && _children$getAt2.subInfo.hidden)) {
          var _children$getAt2;

          target = indexDemangler(indexMangler(target) + 1);
        }

        return target > upper ? indexDemangler(upper) : target;
      } else {
        return lower;
      }
    }

    function useGridNavigation(_ref) {
      var _rti$initialIndex;

      let {
        managedChildren: mc,
        rovingTabIndex: rti,
        listNavigation: ls,
        linearNavigation: ln,
        typeaheadNavigation: tn,
        gridNavigation: {
          rowIndexDemangler,
          rowIndexMangler
        }
      } = _ref;
      const [currentColumn, setCurrentColumn, getCurrentColumn] = useState((_rti$initialIndex = rti.initialIndex) !== null && _rti$initialIndex !== void 0 ? _rti$initialIndex : 0);
      const {
        useListNavigationChild: useListNavigationChildAsGridRow,
        useListNavigationProps: useListNavigationPropsAsGridParent,
        ...parentLsReturnType
      } = useListNavigation({
        managedChildren: mc,
        rovingTabIndex: rti,
        listNavigation: {
          indexDemangler: rowIndexDemangler,
          indexMangler: rowIndexMangler,
          ...ls
        },
        linearNavigation: {
          navigationDirection: "vertical",
          ...ln
        },
        typeaheadNavigation: tn
      });
      const useGridNavigationRow = q$1(_ref2 => {
        let {
          asChildRowOfSection: asChild,
          asParentRowOfCells: asParent
        } = _ref2;
        // Override the focusSelf that rovingTabIndex does.
        // Instead of focusing the entire row, we ask the cell that corresponds
        // to our current column to focus itself.
        const focusSelf = useStableCallback(() => {
          const c2 = getCurrentColumn();

          if (asChild.rovingTabIndex.focusSelf) {
            asChild.rovingTabIndex.focusSelf();
          } else {
            navigateToIndex(c2 !== null && c2 !== void 0 ? c2 : 0, true);
          }
        });
        const rowLsChildReturnType = useListNavigationChildAsGridRow({
          managedChild: asChild.managedChild,
          listNavigation: { ...asChild.listNavigation
          },
          rovingTabIndex: { ...asChild.rovingTabIndex,
            focusSelf
          },
          subInfo: asChild.subInfo
        });
        const {
          rovingTabIndex: {
            tabbable
          },
          useListNavigationChildProps
        } = rowLsChildReturnType;
        s(() => {
          if (!tabbable) {
            navigateToIndex(null, false);
          }
        }, [tabbable]);
        const rowLsReturnType = useListNavigation({
          managedChildren: { ...asParent.managedChildren
          },
          rovingTabIndex: { ...asParent.rovingTabIndex
          },
          linearNavigation: { ...asParent.linearNavigation,
            navigationDirection: "horizontal"
          },
          typeaheadNavigation: { ...asParent.typeaheadNavigation,
            noTypeahead: true
          },
          listNavigation: { ...asParent.listNavigation
          }
        });
        const {
          rovingTabIndex: {
            setTabbableIndex
          },
          useListNavigationChild: useGridNavigationColumn2,
          useListNavigationProps: useGridNavigationColumnProps,
          listNavigation: {
            navigateToIndex
          }
        } = rowLsReturnType; //const rowHidden = !!asChild.rovingTabIndex.hidden;

        const useGridNavigationCell = q$1(_ref3 => {
          let {
            subInfo,
            hasFocus: {
              onLastFocusedInnerChanged,
              ...hasFocus
            },
            managedChild,
            listNavigation: ls,
            rovingTabIndex: {
              focusSelf: fs,
              ...rti
            }
          } = _ref3;
          //rti.hidden || rowHidden;
          const focusSelf = useStableCallback(() => {
            var _rti_cell_ret$getElem, _rti_cell_ret$getElem2;

            setCurrentColumn(managedChild.index);
            setTabbableIndex(managedChild.index, false);
            if (fs) fs();else (_rti_cell_ret$getElem = rti_cell_ret.getElement()) === null || _rti_cell_ret$getElem === void 0 ? void 0 : (_rti_cell_ret$getElem2 = _rti_cell_ret$getElem.focus) === null || _rti_cell_ret$getElem2 === void 0 ? void 0 : _rti_cell_ret$getElem2.call(_rti_cell_ret$getElem);
          });
          /*const blurSelf = useStableCallback(() => {
              if (bs)
                  bs();
              else
                  (rti_cell_ret.getElement() as Element & Partial<HTMLElement>)?.blur?.();
          });*/

          const {
            useListNavigationChildProps,
            rovingTabIndex: rti_cell_ret
          } = useGridNavigationColumn2({
            managedChild: managedChild,
            listNavigation: { ...ls
            },
            rovingTabIndex: {
              focusSelf,
              ...rti
            },
            subInfo
          });
          const {
            useHasFocusProps
          } = useHasFocus({
            onLastFocusedInnerChanged: useStableCallback((focused, prev) => {
              onLastFocusedInnerChanged === null || onLastFocusedInnerChanged === void 0 ? void 0 : onLastFocusedInnerChanged(focused, prev);

              if (focused) {
                setCurrentColumn(managedChild.index);
                setTabbableIndex(managedChild.index, false);
              }
            }),
            ...hasFocus
          });
          const ret = {
            gridNavigation: {
              getCurrentColumn
            },
            rovingTabIndex: rti_cell_ret,
            useGridNavigationCellProps: function (props) {
              return useListNavigationChildProps(useGridNavigationColumnProps(useHasFocusProps(props)));
            }
          };
          return ret;
        }, []);
        const ret = {
          asParentOfCells: {
            linearNavigation: rowLsReturnType.linearNavigation,
            listNavigation: rowLsReturnType.listNavigation,
            managedChildren: rowLsReturnType.managedChildren,
            rovingTabIndex: rowLsReturnType.rovingTabIndex,
            typeaheadNavigation: rowLsReturnType.typeaheadNavigation
          },
          asChildRow: rowLsChildReturnType,
          useGridNavigationCell,
          useGridNavigationRowProps: function (props) {
            const ret = useListNavigationChildProps(props);
            ret.tabIndex = -1;
            return ret;
          }
        };
        return ret;
      }, []);
      return {
        gridNavigation: {
          getCurrentColumn,
          currentColumn
        },
        linearNavigation: parentLsReturnType.linearNavigation,
        listNavigation: parentLsReturnType.listNavigation,
        rovingTabIndex: parentLsReturnType.rovingTabIndex,
        typeaheadNavigation: parentLsReturnType.typeaheadNavigation,
        managedChildren: parentLsReturnType.managedChildren,
        useGridNavigationRow,
        useGridNavigationProps: useListNavigationPropsAsGridParent
      };
    }

    /**
     * Returns a hook that modifies a set of props to provide a randomly-generated ID if one was not provided.
     *
     * If you'd like to use the ID in a property that's *not* named `id` (like `for` or `aria-labelledby` or whatnot), `useReferencedIdProps` is also provided.
     *
     * And the randomly-generated id itself is also provided in case you want to handle the logic yourself without `useMergedProps`.
     *
     * Unlike most other `use*Props` hooks, these are mostly stable.
     */

    function useRandomId(_ref) {
      let {
        randomId: {
          prefix
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref;
      const [backupRandomId,, getBackupRandomId] = useState(() => generateRandomId(prefix));
      const [usedId, setUsedId, getUsedId] = useState(() => getBackupRandomId());
      const mismatchErrorRef = A(false);
      useEnsureStability("useRandomId", prefix);
      const {
        useManagedChild,
        ...managedChildrenReturnType
      } = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      const {
        managedChildren: {
          children
        }
      } = managedChildrenReturnType;
      const useRandomIdSourceElement = q$1(() => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId());
        const {
          useRefElementProps,
          getElement
        } = useRefElement(); // Every time the source element renders, inspect the ID it actually used
        // (whether it was ours or not isn't up to us, it's up to the component)
        // so this is how we notify the referencer component of changes

        s(() => {
          const element = getElement();

          if (element) {
            children.getAt("referencer").subInfo.setUsedId(element.id);
            setUsedId(element.id);
          }
        });

        useManagedChild({
          managedChild: {
            index: "source",
            subInfo: {
              setUsedId: setUsedIdLocal
            }
          }
        });

        const useRandomIdSourceElementProps = q$1(function (p) {
          p.id || (p.id = backupRandomId);
          return useRefElementProps(p);
        }, []);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdSourceElementProps
        };
      }, []);
      const useRandomIdReferencerElement = q$1(idPropName => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId()); // Whatever ID was most recently used by the actual "id" prop of the source element

        useEnsureStability(idPropName);

        useManagedChild({
          managedChild: {
            index: "referencer",
            subInfo: {
              setUsedId: setUsedIdLocal
            }
          }
        });

        const useRandomIdReferencerElementProps = q$1(function (_ref2) {
          let {
            [idPropName]: givenId,
            ...p
          } = _ref2;

          if (givenId && usedId) {
            if (givenId != usedId) {
              if (!mismatchErrorRef.current) {
                mismatchErrorRef.current = true;
                console.error(`Multiple mis-matched IDs were provided for the ${idPropName} prop: the child explicitly specified ${givenId} in its  ${idPropName} prop, but the parent told this child to use ${usedId} (the parent's ID).`);
              }
            }
          }

          return useMergedProps(p, {
            [idPropName]: usedId
          });
        }, [usedId]);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdReferencerElementProps
        };
      }, []);
      return {
        randomId: {
          usedId,
          getUsedId
        },
        ...managedChildrenReturnType,
        useRandomIdSourceElement,
        useRandomIdReferencerElement
      };
    }

    function useButton(_ref) {
      let {
        button: {
          tagButton,
          disabled,
          onPress,
          pressed
        },
        hasFocus
      } = _ref;
      debugLog("useButton");

      function useButtonProps(_ref2) {
        let {
          "aria-pressed": ariaPressed,
          tabIndex,
          role,
          ...p
        } = _ref2;
        const usePressProps = usePress({
          onClickSync: e => {
            var _ref3;

            return (_ref3 = disabled ? null : onPress) === null || _ref3 === void 0 ? void 0 : _ref3(enhanceEvent(e, {
              pressed: pressed == null ? null : !pressed
            }));
          },
          exclude: undefined,
          hasFocus
        });
        const props = usePressProps(p);
        const baseProps = {
          role,
          tabIndex,
          "aria-pressed": ariaPressed !== null && ariaPressed !== void 0 ? ariaPressed : pressed === true ? "true" : pressed === false ? "false" : undefined
        };
        const buttonProps = { ...baseProps,
          disabled: disabled && disabled != "soft" ? true : false,
          "aria-disabled": disabled === 'soft' ? 'true' : undefined
        };
        const divProps = { ...baseProps,
          tabIndex: tabIndex !== null && tabIndex !== void 0 ? tabIndex : disabled === "hard" ? -1 : 0,
          role: role !== null && role !== void 0 ? role : "button",
          "aria-disabled": disabled ? "true" : undefined
        };

        switch (tagButton) {
          case "button":
            return useMergedProps(buttonProps, props);

          default:
            return useMergedProps(divProps, props);
        }
      }

      return {
        useButtonProps
      };
    }

    //export interface UseAccordionSectionHeaderReturnType<E extends Element> { useAccordionSectionHeaderProps: (props: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; }
    //export type UseAccordionSectionBody<E extends Element> = () => UseAccordionSectionBodyReturnType<E>;
    //export interface UseAccordionSectionBodyReturnType<E extends Element> { useAccordionSectionBodyProps: (props: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; }

    function useAccordion(_ref) {
      let {
        accordion: {
          initialIndex
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref;
      debugLog("useAccordian");
      const [_currentFocusedIndex, setCurrentFocusedIndex, getCurrentFocusedIndex] = useState(null);
      const mcReturnType = useManagedChildren({
        managedChildren: {
          onChildrenMountChange: useStableCallback((m, u) => {
            ocmc2();
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(m, u);
          }),
          onAfterChildLayoutEffect
        }
      });
      const {
        useManagedChild,
        managedChildren: {
          children
        }
      } = mcReturnType;
      const navigateToFirst = q$1(() => {
        changeTabbedIndex(0);
      }, []);
      const navigateToLast = q$1(() => {
        changeTabbedIndex(children.getHighestIndex());
      }, []);
      const navigateToPrev = q$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) - 1);
      }, []);
      const navigateToNext = q$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) + 1);
      }, []);
      const linearReturnType = useLinearNavigation({
        linearNavigation: {
          navigateToFirst,
          navigateToLast,
          navigateToNext,
          navigateToPrev,
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection: navigationDirection !== null && navigationDirection !== void 0 ? navigationDirection : "vertical" // TODO: Make this relative to the page's logical direction

        }
      });
      const {
        useLinearNavigationProps
      } = linearReturnType;
      const {
        changeIndex: changeExpandedIndex,
        getCurrentIndex: _getCurrentExpandedIndex
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "open",
        closestFit: false
      });
      const {
        changeIndex: changeTabbedIndex,
        getCurrentIndex: _getTabbedIndex,
        reevaluateClosestFit: ocmc2
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "tabbed",
        closestFit: true,
        onIndexChange: q$1(i => {
          if (i != null) {
            var _children$getAt;

            (_children$getAt = children.getAt(i)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.focus();
          }
        }, [])
      });
      const useAccordionSection = q$1(_ref2 => {
        var _ref3;

        let {
          button: {
            disabled,
            tagButton
          },
          accordionSection: {
            open: openFromUser
          },
          managedChildren: {
            index
          },
          hasFocus: {
            onFocusedInnerChanged,
            ...hasFocus
          }
        } = _ref2;
        debugLog("useAccordianSection");
        const [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
        const {
          useRandomIdSourceElement: useBodyAsSourceId,
          useRandomIdReferencerElement: useHeaderAsReferencerId,
          randomId: {
            usedId: bodyId,
            getUsedId: getBodyId
          }
        } = useRandomId({
          randomId: {
            prefix: "aria-accordion-section-body-"
          },
          managedChildren: {
            onAfterChildLayoutEffect: null,
            onChildrenMountChange: null
          }
        });
        const {
          useRandomIdSourceElement: useHeaderAsSourceId,
          useRandomIdReferencerElement: useBodyAsReferencerId,
          randomId: {
            usedId: headerId,
            getUsedId: getHeaderId
          }
        } = useRandomId({
          randomId: {
            prefix: "aria-accordion-section-header-"
          },
          managedChildren: {
            onAfterChildLayoutEffect: null,
            onChildrenMountChange: null
          }
        });
        const {
          useRandomIdSourceElementProps: useBodyAsSourceIdProps
        } = useBodyAsSourceId();
        const {
          useRandomIdReferencerElementProps: useBodyAsReferencerIdProps
        } = useBodyAsReferencerId("aria-labelledby");
        const {
          useRandomIdSourceElementProps: useHeaderAsSourceIdProps
        } = useHeaderAsSourceId();
        const {
          useRandomIdReferencerElementProps: useHeaderAsReferencerIdProps
        } = useHeaderAsReferencerId("aria-controls");
        const open = (_ref3 = openFromUser !== null && openFromUser !== void 0 ? openFromUser : openFromParent) !== null && _ref3 !== void 0 ? _ref3 : false; //const getOpen = useStableGetter(!!open);

        const getIndex = useStableGetter(index);
        const {
          getElement: getHeaderElement,
          useRefElementProps: useHeaderRefElementProps
        } = useRefElement({});
        const {
          getElement: getBodyElement,
          useRefElementProps: useBodyRefElementProps
        } = useRefElement({});
        const focus = q$1(() => {
          var _getHeaderElement;

          if (getCurrentFocusedIndex() != null) (_getHeaderElement = getHeaderElement()) === null || _getHeaderElement === void 0 ? void 0 : _getHeaderElement.focus();
        }, []);
        const openRef = A({
          get: () => !!getOpenFromParent(),
          set: open => {
            setOpenFromParent(open);

            if (open) {
              const bodyElement = getBodyElement();
              setCurrentFocusedIndex(getIndex());

              if (bodyElement) {
                queueMicrotask(() => bodyElement.focus());
              }
            }
          },
          isValid: returnTrue
        });
        const tabbedRef = A({
          get: () => getCurrentFocusedIndex() == getIndex(),
          set: open => {
            if (open) setCurrentFocusedIndex(getIndex());
          },
          isValid: returnTrue
        });

        useManagedChild({
          managedChild: {
            index: index,
            flags: {
              open: openRef.current,
              tabbed: tabbedRef.current
            },
            subInfo: {
              focus,
              getOpenFromParent,
              setOpenFromParent
            } // info: { index, setOpenFromParent, getOpenFromParent, focus, flags: { open: openRef.current, tabbed: tabbedRef.current } }

          }
        });

        function useAccordionSectionHeaderProps(_ref4) {
          var _ref5;

          let {
            ["aria-expanded"]: ariaExpanded,
            ["aria-disabled"]: ariaDisabled,
            ...props
          } = _ref4;

          //const onFocus = () => { changeTabbedIndex(index); }
          const onPress = () => {
            if (getOpenFromParent()) changeExpandedIndex(null);else changeExpandedIndex(index);
          };

          props.tabIndex = 0;
          const {
            useButtonProps
          } = useButton({
            button: {
              tagButton,
              disabled,
              onPress
            },
            hasFocus: { ...hasFocus,
              onFocusedInnerChanged: useStableCallback((focused, prev) => {
                onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);
                if (focused) changeTabbedIndex(index);
              })
            }
          });
          const retB = useButtonProps(props); //const ret3: h.JSX.HTMLAttributes<HeaderElement>
          //    = useMergedProps<HeaderElement>(retD, { onFocus });

          return useLinearNavigationProps(useHeaderAsSourceIdProps(useHeaderAsReferencerIdProps({
            "aria-expanded": ((_ref5 = ariaExpanded !== null && ariaExpanded !== void 0 ? ariaExpanded : open) !== null && _ref5 !== void 0 ? _ref5 : false).toString(),
            "aria-disabled": ariaDisabled !== null && ariaDisabled !== void 0 ? ariaDisabled : open ? "true" : undefined,
            ...useHeaderRefElementProps(retB)
          })));
        }

        function useAccordionSectionBodyProps(_ref6) {
          var _ret2$tabIndex;

          let {
            role,
            ...props
          } = _ref6;
          const ret1 = useBodyAsReferencerIdProps({
            role: role !== null && role !== void 0 ? role : "region",
            ...props
          });
          const ret2 = useBodyAsSourceIdProps(ret1);
          (_ret2$tabIndex = ret2.tabIndex) !== null && _ret2$tabIndex !== void 0 ? _ret2$tabIndex : ret2.tabIndex = -1;
          return useBodyRefElementProps(ret2);
        }

        return {
          accordionSection: {
            expanded: open,
            focused: getCurrentFocusedIndex() == index,
            bodyId,
            headerId,
            getBodyId,
            getHeaderId
          },
          useAccordionSectionHeaderProps,
          useAccordionSectionBodyProps
        };
      }, []);
      return {
        managedChildren: mcReturnType.managedChildren,
        accordion: {
          changeExpandedIndex
        },
        useAccordionSection
      };
    }

    /**
     * Adds an ID and "aria-labelledby" for two elements, an "input" element and a "label" element.
     *
     * Returns the `useReferencedIdProps` hooks if you need to also add other ID-referencer attributes, like `for`
     *
     * @see useInputLabel
     */

    function useLabel(_ref) {
      let {
        label: {
          prefixInput,
          prefixLabel,
          tagInput,
          tagLabel
        }
      } = _ref;
      const {
        useRandomIdSourceElement: useLabelAsSourceId,
        useRandomIdReferencerElement: useLabelAsReferencerId,
        randomId: {
          usedId: labelId,
          getUsedId: getLabelId
        }
      } = useRandomId({
        randomId: {
          prefix: prefixLabel
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useInputAsSourceId,
        useRandomIdReferencerElement: useInputAsReferencerId,
        randomId: {
          usedId: inputId,
          getUsedId: getInputId
        }
      } = useRandomId({
        randomId: {
          prefix: prefixInput
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElementProps: useLabelAsSourceIdProps
      } = useLabelAsSourceId();
      const {
        useRandomIdSourceElementProps: useInputAsSourceIdProps
      } = useInputAsSourceId();
      const {
        useRandomIdReferencerElementProps: useLabelAsReferencerIdProps
      } = useLabelAsReferencerId("aria-labelledby");
      const {
        useRandomIdReferencerElementProps: useInputAsReferencerIdProps
      } = useInputAsReferencerId("for");
      const isSyntheticLabel = tagInput != "input" || tagLabel != "label";
      const useLabelLabel = q$1(function useLabelLabel() {
        return {
          useLabelLabelProps: props => {
            const propsWithoutFor = useLabelAsSourceIdProps(props);
            const propsWithFor = useInputAsReferencerIdProps(propsWithoutFor);
            if (tagLabel == "label" && tagInput == "input") return propsWithFor;else return propsWithoutFor;
          }
        };
      }, [isSyntheticLabel]);
      const useLabelInput = q$1(function useLabelInput() {
        return {
          useLabelInputProps: _ref2 => {
            let {
              "aria-labelledby": ariaLabelledby,
              ...props
            } = _ref2;
            console.assert(!ariaLabelledby);
            const propsWithoutAriaLabelledBy = useInputAsSourceIdProps(props);
            const propsWithAriaLabelledBy = useLabelAsReferencerIdProps(propsWithoutAriaLabelledBy);
            if (isSyntheticLabel && !props["aria-label"]) return propsWithAriaLabelledBy;else return propsWithoutAriaLabelledBy;
          }
        };
      }, [isSyntheticLabel]);
      return {
        useLabelInput,
        useLabelLabel,
        label: {
          labelId,
          inputId,
          getLabelId,
          getInputId
        }
      };
    }

    const handlesInput = (tag, labelPosition, which) => {
      if (labelPosition === "separate") {
        if (which === "input-element") return true;else if (which === "label-element") return tag != "input";
      } else if (labelPosition === "wrapping") {
        if (which === "input-element") return false;
        if (which == "label-element") return true;
      }
    };
    /**
     * Handles label type (wrapping or separate) for checkboxes, radios, switches, etc.
     *
     * If it's a toggleable click-thing with a label (that can also be clicked), then it's a checkbox-like.
     * @param param0
     * @returns
     */


    function useCheckboxLike(_ref3) {
      let {
        checkboxLike: {
          checked,
          disabled,
          labelPosition,
          role,
          onCheckedChange
        },
        label: {
          tagInput,
          tagLabel
        },
        hasFocusInput,
        hasFocusLabel
      } = _ref3;
      const stableOnInput = useStableCallback(e => {
        e.preventDefault();
        onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(e);
      });
      const {
        useLabelInput: useILInput,
        useLabelLabel: useILLabel,
        label
      } = useLabel({
        label: {
          prefixLabel: "aria-checkbox-label-",
          prefixInput: "aria-checkbox-input-",
          tagInput: tagInput,
          tagLabel: tagLabel
        }
      });
      const {
        getElement: getLabelElement,
        useRefElementProps: useLabelRefElementProps
      } = useRefElement();
      const {
        getElement: getInputElement,
        useRefElementProps: useInputRefElementProps
      } = useRefElement();
      const useCheckboxLikeInputElement = q$1(function useCheckboxInputElement() {
        const tag = tagInput;
        const {
          useLabelInputProps: useILInputProps
        } = useILInput();
        const {
          useRefElementProps,
          getElement
        } = useRefElement({}); // onClick and onChange are a bit messy, so we need to
        // *always* make sure that the visible state is correct
        // after all the event dust settles.
        // See https://github.com/preactjs/preact/issues/2745,
        // and https://github.com/preactjs/preact/issues/1899#issuecomment-525690194

        s(() => {
          const element = getElement();

          if (element && tag == "input") {
            element.indeterminate = checked === "mixed";
            element.checked = checked === true;
          }
        }, [tag, checked]);
        return {
          getInputElement: getElement,
          useCheckboxLikeInputElementProps
        };

        function useCheckboxLikeInputElementProps(_ref4) {
          let { ...p0
          } = _ref4;
          // For some reason, Chrome won't fire onInput events for radio buttons that are tabIndex=-1??
          // Needs investigating, but onInput works fine in Firefox
          // TODO
          const usePressProps = usePress({
            onClickSync: disabled || !handlesInput(tag, labelPosition, "input-element") ? undefined : stableOnInput,
            exclude: undefined,
            hasFocus: hasFocusInput
          });
          let props = usePressProps(p0);
          if (tag == "input") props.onInput = e => e.preventDefault();
          props = useRefElementProps(useILInputProps(props));

          if (labelPosition == "wrapping") {
            // Because the wrapped label handles all interactions,
            // we need to make sure this element can't be interacted with
            // even if it's an input element.
            props.inert = true;
            props.tabIndex = -1;
            props.role = "presentation";
            props["aria-hidden"] = "true";

            props.onFocus = _ => {
              var _getLabelElement;

              return (_getLabelElement = getLabelElement()) === null || _getLabelElement === void 0 ? void 0 : _getLabelElement.focus();
            };
          } else {
            if (tag === "input") {
              props.checked = checked === true;
            } else {
              props.role = role;
              props.tabIndex = 0;
              props["aria-checked"] = checked === "mixed" ? "mixed" : checked === true ? "true" : undefined;
            }

            props["aria-disabled"] = disabled.toString();
          } // Make sure that label clicks can't affect the checkbox while it's disabled


          props.onClick = disabled ? e => {
            e.preventDefault();
          } : props.onClick;
          return useInputRefElementProps(useMergedProps(p0, props));
        }
      }, [useILInput, role, labelPosition, disabled, checked, tagInput]);
      const useCheckboxLikeLabelElement = q$1(function useCheckboxLabelElement() {
        const tag = tagLabel;
        const {
          useLabelLabelProps: useILLabelProps
        } = useILLabel();

        function useCheckboxLikeLabelElementProps(_ref5) {
          let { ...p0
          } = _ref5;
          const usePressProps = usePress({
            onClickSync: disabled || !handlesInput(tag, labelPosition, "label-element") ? undefined : stableOnInput,
            exclude: undefined,
            hasFocus: hasFocusLabel
          });
          const newProps = usePressProps(p0);

          if (labelPosition == "wrapping") {
            if (newProps.tabIndex == null) newProps.tabIndex = 0;
            if (newProps.role == null) newProps.role = role;
            newProps["aria-disabled"] = disabled.toString();
            newProps["aria-checked"] = checked.toString();
          } // Just make sure that label clicks can't affect the checkbox while it's disabled


          newProps.onClick = disabled ? e => {
            e.preventDefault();
          } : newProps.onClick;
          return useILLabelProps(useLabelRefElementProps(newProps));
        }

        return {
          useCheckboxLikeLabelElementProps
        };
      }, [useILLabel, disabled, checked, role, labelPosition, tagLabel]);
      return {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        checkboxLike: {
          getLabelElement,
          getInputElement
        },
        label
      };
    }

    function useCheckbox(_ref) {
      let {
        checkboxLike,
        label,
        checkbox,
        hasFocusInput,
        hasFocusLabel
      } = _ref;
      debugLog("useCheckbox");
      const {
        disabled,
        labelPosition,
        checked
      } = checkboxLike;
      const {
        tagInput,
        tagLabel
      } = label;
      const {
        onCheckedChange: onInput
      } = checkbox;

      const onInputEnhanced = e => onInput === null || onInput === void 0 ? void 0 : onInput(enhanceEvent(e, {
        checked: !checked
      }));

      const {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        ...checkboxLikeRest
      } = useCheckboxLike({
        hasFocusInput,
        hasFocusLabel,
        checkboxLike: {
          role: "checkbox",
          checked,
          onCheckedChange: onInputEnhanced,
          disabled,
          labelPosition
        },
        label
      });
      const useCheckboxInputElement = q$1(function useCheckboxInputElement() {
        const tag = tagInput;
        const {
          useCheckboxLikeInputElementProps
        } = useCheckboxLikeInputElement();
        return {
          useCheckboxInputElementProps
        };

        function useCheckboxInputElementProps(_ref2) {
          var _props$checked;

          let { ...p0
          } = _ref2;
          const props = useCheckboxLikeInputElementProps(p0);
          (_props$checked = props.checked) !== null && _props$checked !== void 0 ? _props$checked : props.checked = !!checked;
          if (tag == "input") props.type = "checkbox";
          return props;
        }
      }, [useCheckboxLikeInputElement, checked, labelPosition, disabled, tagInput]);
      const useCheckboxLabelElement = q$1(function useCheckboxLabelElement() {
        const {
          useCheckboxLikeLabelElementProps
        } = useCheckboxLikeLabelElement();

        function useCheckboxLabelElementProps(_ref3) {
          let { ...props
          } = _ref3;
          return useCheckboxLikeLabelElementProps(props);
        }

        return {
          useCheckboxLabelElementProps
        };
      }, [useCheckboxLikeLabelElement, disabled, labelPosition, tagLabel]);
      return {
        useCheckboxInputElement,
        useCheckboxLabelElement,
        ...checkboxLikeRest
      };
    }

    /**
     *
     *
     * @param param0
     * @returns
     */

    function useCheckboxGroup(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      debugLog("useCheckboxGroup"); //const onUpdateChildren = useStableCallback(onUpdateChildrenUnstable ?? (() => {}));

      const {
        useListNavigationChild,
        useListNavigationProps,
        ...listReturnType
      } = useListNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children
        }
      } = listReturnType; //const [uncheckedCount, setUnheckedCount] = useState(0);
      // Keep track of all child IDs, and any time any of them change, 
      // generate a new string with all of them concatenated together
      // (but only once per render);

      const allIds = A(new Set());
      const [ariaControls, setControls] = useState("");
      const [updateIndex, setIdUpdateIndex] = useState(0);
      const [checkedCount, setCheckedCount] = useState(0);
      const checkedIndices = A(new Set()); //const [selfIsChecked, setSelfIsChecked, getSelfIsChecked] = useState<boolean | "mixed">(false);

      const getSelfIsCheckedUnstable = q$1(() => {
        const percentage = checkedCount / (children.getHighestIndex() + 1);
        return percentage <= 0 ? false : percentage >= 1 ? true : "mixed";
      }, [checkedCount]);
      const getSelfIsCheckedStable = useStableCallback(getSelfIsCheckedUnstable);
      const [setParentCheckboxChecked, setSetParentCheckboxChecked] = useState(null);
      s(() => {
        setParentCheckboxChecked === null || setParentCheckboxChecked === void 0 ? void 0 : setParentCheckboxChecked(checkedCount == 0 ? false : checkedCount == children.getHighestIndex() + 1 ? true : "mixed");
      }, [setParentCheckboxChecked, checkedCount]); // If the user has changed the parent checkbox's value, then this ref holds a memory of what values were held before.
      // Otherwise, it's null when the last input was from a child checkbox. 
      //const savedCheckedValues = useRef<Map<number, boolean | "mixed"> | null>(null);

      const useCheckboxGroupParentInput = q$1(_ref2 => {
        let {
          checkbox,
          checkboxLike,
          label,
          hasFocusLabel,
          hasFocusInput
        } = _ref2;
        debugLog("useCheckboxGroupParent");
        const {
          disabled,
          labelPosition,
          ..._void2
        } = checkboxLike;
        const {
          tagInput,
          tagLabel,
          ..._void3
        } = label;
        const [checked, setChecked] = useState(false);
        s(() => {
          setSetParentCheckboxChecked(() => setChecked);
        }, []);
        const {
          useCheckboxInputElement,
          useCheckboxLabelElement
        } = useCheckbox({
          checkboxLike: {
            labelPosition,
            checked,
            disabled
          },
          label: {
            tagInput,
            tagLabel
          },
          checkbox: {
            onCheckedChange: onCheckboxGroupParentInput2
          },
          hasFocusInput,
          hasFocusLabel
        });
        const {
          useCheckboxInputElementProps
        } = useCheckboxInputElement();
        const {
          useCheckboxLabelElementProps
        } = useCheckboxLabelElement();
        return {
          useCheckboxGroupParentInputProps: function useCheckboxGroupParentInputProps(props) {
            const ret = useMergedProps(useMergedProps({}, {
              "aria-controls": ariaControls,
              onInput: tagInput == "input" ? e => e.preventDefault() : undefined
            }), props);
            return useCheckboxInputElementProps(labelPosition == "separate" ? ret : props);
          },
          useCheckboxGroupParentLabelProps: function useCheckboxGroupParentLabelProps(props) {
            const ret = useMergedProps(useMergedProps({}, {
              "aria-controls": ariaControls
            }), props);
            return useCheckboxLabelElementProps(labelPosition == "wrapping" ? ret : props);
          }
        };
      }, [ariaControls]);
      const onCheckboxGroupParentInput2 = q$1(e => {
        e.preventDefault();
        const selfIsChecked = getSelfIsCheckedStable();
        const nextChecked = selfIsChecked === false ? "mixed" : selfIsChecked === "mixed" ? true : false;
        let willChangeAny = false;
        children.forEach(child => willChangeAny || (willChangeAny = child.subInfo.subInfo.subInfo.checked != child.subInfo.subInfo.subInfo.getLastUserChecked()));
        children.forEach(child => {
          var _child$subInfo$subInf, _child$subInfo$subInf2;

          let checked;

          if (nextChecked == "mixed") {
            if (willChangeAny) checked = child.subInfo.subInfo.subInfo.getLastUserChecked();else checked = true;
          } else {
            checked = nextChecked;
          }

          (_child$subInfo$subInf = (_child$subInfo$subInf2 = child.subInfo.subInfo.subInfo).onCheckedChange) === null || _child$subInfo$subInf === void 0 ? void 0 : _child$subInfo$subInf.call(_child$subInfo$subInf2, enhanceEvent(e, {
            checked
          }));
        });
        /*if (selfIsChecked === true || (selfIsChecked === false && savedCheckedValues.current == null)) {
            return onUpdateChildren(enhanceEvent(e, { childrenChecked: false }));
        }
        else if (selfIsChecked === "mixed") {
              savedCheckedValues.current = new Map();
            children.forEach(child => {
                savedCheckedValues.current!.set(child.index, child.getLastUserChecked());
            })
              return onUpdateChildren(enhanceEvent(e, { childrenChecked: true }));
        }
        else {
            return onUpdateChildren(enhanceEvent(e, { childrenChecked: savedCheckedValues.current ?? true }));
        }*/
      }, []);
      const notifyChecked = q$1((index, checked) => {
        if (checked === true) {
          if (!checkedIndices.current.has(index)) {
            setCheckedCount(c => c + 1);
            checkedIndices.current.add(index);
          }
        } else {
          if (checkedIndices.current.has(index)) {
            setCheckedCount(c => c - 1);
            checkedIndices.current.delete(index);
          }
        }
      }, []);
      /*useEffect(() => {
          let percentage = checkedCount / managedChildren.length;
          setSelfIsChecked(percentage <= 0 ? false : percentage >= 1 ? true : "mixed")
      }, [setSelfIsChecked, managedChildren.length, checkedCount]);*/

      /*const useCheckboxGroupParentProps = useCallback((props: h.JSX.HTMLAttributes<InputElement>) => {
          return
      }, [ariaControls]);*/

      s(() => {
        setControls(Array.from(allIds.current).join(" "));
      }, [updateIndex]);
      const useCheckboxGroupChild = q$1(function (_ref3) {
        let {
          asCheckbox,
          asCheckboxGroupChild
        } = _ref3;
        debugLog("useCheckboxGroupChild", asCheckboxGroupChild.managedChild.index, asCheckbox.checkboxLike.checked);
        const {
          checkbox: {
            onCheckedChange
          },
          checkboxLike: {
            checked,
            disabled,
            labelPosition
          },
          label: {
            tagInput,
            tagLabel
          },
          hasFocusInput,
          hasFocusLabel
        } = asCheckbox;
        const {
          managedChild: {
            index
          }
        } = asCheckboxGroupChild; //labelPosition ??= "separate";

        const [getLastUserChecked, setLastUserChecked] = usePassiveState(null, returnFalse$1);
        const {
          useCheckboxInputElement,
          useCheckboxLabelElement,
          ...checkboxReturnType
        } = useCheckbox({
          checkbox: {
            onCheckedChange: useStableCallback(e => {
              setLastUserChecked(e[EventDetail].checked);
              onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(e);
            })
          },
          checkboxLike: {
            checked,
            labelPosition,
            disabled
          },
          label: {
            tagInput,
            tagLabel
          },
          hasFocusInput,
          hasFocusLabel
        });
        const {
          label: {
            inputId,
            labelId
          }
        } = checkboxReturnType; //const getChecked = useStableGetter(checked);

        const controlsId = labelPosition == "separate" ? inputId : labelId;
        s(() => {
          allIds.current.add(controlsId);
          setIdUpdateIndex(i => ++i);
          return () => {
            allIds.current.delete(controlsId);
            setIdUpdateIndex(i => ++i);
          };
        }, [controlsId]);
        s(() => {
          notifyChecked(index, checked);
        }, [index, checked]);
        const {
          useListNavigationChildProps,
          ...listNavigationReturnType
        } = useListNavigationChild({
          subInfo: {
            getLastUserChecked,
            onCheckedChange,
            checked
          },
          listNavigation: { ...asCheckboxGroupChild.listNavigation
          },
          managedChild: asCheckboxGroupChild.managedChild,
          rovingTabIndex: asCheckboxGroupChild.rovingTabIndex
        });
        return {
          checkboxLike: checkboxReturnType.checkboxLike,
          label: checkboxReturnType.label,
          rovingTabIndex: listNavigationReturnType.rovingTabIndex,
          useCheckboxGroupChildInputProps: props => {
            const {
              useCheckboxInputElementProps
            } = useCheckboxInputElement();
            const ret = useCheckboxInputElementProps(props);
            const ret2 = useListNavigationChildProps(useListNavigationProps(ret));
            return labelPosition == "separate" ? ret2 : ret;
          },
          useCheckboxGroupChildLabelProps: props => {
            const {
              useCheckboxLabelElementProps
            } = useCheckboxLabelElement();
            const ret = useCheckboxLabelElementProps(props);
            const ret2 = useListNavigationChildProps(useListNavigationProps(ret));
            return labelPosition == "wrapping" ? ret2 : ret;
          }
        };
      }, []);
      return {
        useCheckboxGroupChild,
        useCheckboxGroupParentInput,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        managedChildren: listReturnType.managedChildren,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation,
        checkboxGroup: {
          parentIsChecked: getSelfIsCheckedUnstable(),
          parentPercentChecked: checkedCount / (children.getHighestIndex() + 1)
        }
      };
    }

    /**
     * Adds event handlers for a modal-like soft-dismiss interaction.
     *
     * That is, any clicks or taps outside of the given component,
     * or any time the Escape key is pressed within the component,
     * (with various browser oddities regarding clicks on blank or inert areas handled)
     * the component will request to close itself.
     *
     * Of course, if you don't do anything in the `onClose` function,
     * it won't be a soft dismiss anymore.
     *
     * @param param0
     * @returns
     */

    function useSoftDismiss(_ref) {
      let {
        softDismiss: {
          onClose,
          getElements,
          open
        },
        activeElement: {
          onLastActiveElementChange,
          ...activeElement
        }
      } = _ref;
      const stableOnClose = useStableCallback(onClose);
      const stableGetElements = useStableCallback(getElements);
      const getOpen = useStableGetter(open);
      const {
        getDocument
      } = activeElement;
      const onBackdropClick = q$1(function onBackdropClick(e) {
        if (!getOpen()) return;
        const document = getDocument(); // Basically, "was this event fired on the root-most element, or at least an element not contained by the modal?"
        // Either could be how the browser handles these sorts of "interacting with nothing" events.

        if (e.target == (document === null || document === void 0 ? void 0 : document.documentElement)) {
          stableOnClose("backdrop");
        }

        let elements = stableGetElements();

        if (elements && e.target instanceof Element) {
          if (!Array.isArray(elements)) elements = [elements];
          let foundInsideClick = false;

          for (const element of elements) {
            if (element && element.contains(e.target)) {
              foundInsideClick = true;
              break;
            }
          }

          if (!foundInsideClick) {
            onClose("backdrop");
          }
        }
      }, []);
      useActiveElement({ ...activeElement,
        onLastActiveElementChange: q$1((newElement, prev) => {
          onLastActiveElementChange === null || onLastActiveElementChange === void 0 ? void 0 : onLastActiveElementChange(newElement, prev);
          let validFocusableElements = stableGetElements();

          if (validFocusableElements) {
            if (!Array.isArray(validFocusableElements)) validFocusableElements = [validFocusableElements];

            for (const focusable of validFocusableElements) {
              if (focusable !== null && focusable !== void 0 && focusable.contains(newElement)) return;
            }
          }

          onClose("lost-focus");
        }, [])
      });
      const {
        useRefElementProps
      } = useRefElement({
        onMount: q$1(() => {
          debugger;
        }, []),
        onUnmount: q$1(() => {
          debugger;
        }, []),
        onElementChange: q$1(e => {
          debugger;

          if (e) {
            const document = e.ownerDocument;
            const window = document === null || document === void 0 ? void 0 : document.defaultView; // Since everything else is inert, we listen for captured clicks on the window
            // (we don't use onClick since that doesn't fire when clicked on empty/inert areas)
            // Note: We need a *separate* touch event on mobile Safari, because
            // it doesn't let click events bubble or be captured from traditionally non-interactive elements,
            // but touch events work as expected.

            const mouseDown = e => {
              if (getOpen()) onBackdropClick(e);
            };

            const touchStart = e => {
              if (getOpen()) onBackdropClick(e);
            };

            const keyDown = e => {
              if (e.key === "Escape") {
                stableOnClose("escape");
              }
            };

            window === null || window === void 0 ? void 0 : window.addEventListener("mousedown", mouseDown, {
              capture: true
            });
            window === null || window === void 0 ? void 0 : window.addEventListener("touchstart", touchStart, {
              capture: true
            });
            window === null || window === void 0 ? void 0 : window.addEventListener("keydown", keyDown);
            return () => {
              window === null || window === void 0 ? void 0 : window.removeEventListener("mousedown", mouseDown);
              window === null || window === void 0 ? void 0 : window.removeEventListener("touchstart", touchStart);
              window === null || window === void 0 ? void 0 : window.removeEventListener("keydown", keyDown);
            };
          }
        }, [])
      });
      return {
        useSoftDismissProps: q$1(props => {
          debugger;
          return useRefElementProps(props);
        }, []),
        softDismiss: {
          onBackdropClick
        }
      };
    }
    /**
     * A generic modal hook, used by modal dialogs, but can also
     * be used by anything that's modal with a backdrop.
     * @param param0
     * @returns
     */

    function useModal(_ref2) {
      var _focusSelf;

      let {
        modal: {
          bodyIsOnlySemantic: descriptive,
          focusSelf
        },
        softDismiss: {
          onClose,
          open
        },
        activeElement
      } = _ref2;
      const {
        useRefElementProps: useTitleRefElementProps,
        getElement: getTitleElement
      } = useRefElement({});
      const {
        useRefElementProps: useBodyRefElementProps,
        getElement: getBodyElement
      } = useRefElement({});
      (_focusSelf = focusSelf) !== null && _focusSelf !== void 0 ? _focusSelf : focusSelf = () => {
        if (descriptive) {
          var _getBodyElement;

          (_getBodyElement = getBodyElement()) === null || _getBodyElement === void 0 ? void 0 : _getBodyElement.focus({
            preventScroll: true
          });
        } else {
          const titleElement = getTitleElement();
          if (titleElement) titleElement.focus({
            preventScroll: true
          });
        } //const elementToFocus = getTitleElement() ?? getBodyElement()

      };
      const stableOnClose = useStableCallback(onClose);
      const stableFocusSelf = useStableCallback(focusSelf); //const [modalDescribedByBody, setModalDescribedByBody] = useState(false);

      useHideScroll(open);
      const {
        useRandomIdSourceElement: useModalIdAsSource,
        useRandomIdReferencerElement: useModalIdAsReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-modal-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useBodyIdAsSource,
        useRandomIdReferencerElement: useBodyIdReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-modal-body-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useTitleIdAsSource,
        useRandomIdReferencerElement: useTitleIdReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-modal-title-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRefElementProps: useModalRefElement,
        getElement: getModalElement
      } = useRefElement({});
      const {
        softDismiss: {
          onBackdropClick
        },
        useSoftDismissProps
      } = useSoftDismiss({
        softDismiss: {
          onClose: stableOnClose,
          getElements: getModalElement,
          open: !!open
        },
        activeElement
      });
      const useModalBackdrop = q$1(function useModalBackdrop() {
        function useModalBackdropProps(props) {
          return useMergedProps({
            onPointerUp: onBackdropClick
          }, props);
        }

        return {
          useModalBackdropProps
        };
      }, []);

      const useModalFocusContainerProps = function (props) {
        const {
          useFocusTrapProps
        } = useFocusTrap({
          trapActive: open
        });
        return useFocusTrapProps(props);
      };

      const useModalProps = function (_ref3) {
        let {
          "aria-modal": ariaModal,
          role,
          ...p0
        } = _ref3;
        const {
          useRandomIdSourceElementProps: useModalIdAsSourceProps
        } = useModalIdAsSource();
        const {
          useRandomIdReferencerElementProps: useTitleIdReferencerElementProps
        } = useTitleIdReferencerElement("aria-labelledby");
        const {
          useRandomIdReferencerElementProps: useBodyIdReferencerElementProps
        } = useBodyIdReferencerElement("aria-describedby");
        console.assert(!ariaModal);
        s(() => {
          if (open) stableFocusSelf();
        }, [open]);
        const p1 = useBodyIdReferencerElementProps(p0);
        const p2 = useModalIdAsSourceProps(p1);
        const pFinal = useTitleIdReferencerElementProps(p2);
        return useSoftDismissProps(useMergedProps(useModalRefElement({
          role: role || "dialog"
        }), descriptive ? pFinal : p2));
      };

      const useModalTitle = q$1(function useModalTitle() {
        const {
          useRandomIdSourceElementProps: useTitleIdAsSourceProps
        } = useTitleIdAsSource();

        const useModalTitleProps = function (props) {
          var _props$tabIndex;

          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1;
          return useTitleRefElementProps(useTitleIdAsSourceProps(props));
        };

        return {
          useModalTitleProps
        };
      }, []);
      const useModalBody = q$1(function useModalBody() {
        const {
          useRandomIdSourceElementProps: useBodyIdAsSourceProps
        } = useBodyIdAsSource();
        const {
          useRandomIdReferencerElementProps: useModalIdAsReferencerElementProps
        } = useModalIdAsReferencerElement("data-modal-id");

        const useModalBodyProps = function (props) {
          var _props$tabIndex2;

          (_props$tabIndex2 = props.tabIndex) !== null && _props$tabIndex2 !== void 0 ? _props$tabIndex2 : props.tabIndex = -1;
          return useBodyRefElementProps(useBodyIdAsSourceProps(useModalIdAsReferencerElementProps(props)));
        };

        return {
          useModalBodyProps
        };
      }, []);
      return {
        useModalProps,
        useModalTitle,
        useModalBody,
        useModalBackdrop,
        useModalFocusContainerProps,
        softDismiss: {
          onBackdropClick
        }
      };
    }
    /**
     * Allows for hiding the scroll bar of the root HTML element
     * without shifting the layout of the page more than adding a fow pixels
     * of padding to the root element if necessary.
     * @param hideScroll
     */

    function useHideScroll(hideScroll) {
      const [getScrollbarWidth, setScrollbarWidth] = usePassiveState(null);
      const [getScrollbarHeight, setScrollbarHeight] = usePassiveState(null);
      s(() => {
        if (hideScroll) {
          // When scrolling is resumed, we'll need to restore the original scroll positions
          // so we need to keep this information around
          const originalScrollTop = document.documentElement.scrollTop;
          const originalScrollLeft = document.documentElement.scrollLeft; // Measure the width of the page (minus the scrollbar)

          const widthWithScrollBar = document.documentElement.scrollWidth;
          const heightWithScrollBar = document.documentElement.scrollHeight; // Apply a class that hides the scrollbar.

          document.documentElement.classList.add("document-scroll-hidden"); // In case multiple things are locking scroll, keep track of how many are doing that
          // (just add 1 on enable, subtract 1 on disable)

          document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") + 1).toString(); // Measure the new width without a scrollbar 
          // so we can take the difference as the scrollbar width.

          const widthWithoutScrollBar = document.documentElement.scrollWidth;
          const heightWithoutScrollBar = document.documentElement.scrollHeight;
          let scrollbarWidth = widthWithoutScrollBar - widthWithScrollBar;
          let scrollbarHeight = heightWithoutScrollBar - heightWithScrollBar; // Failsafe -- if this measuring trick does something unexpected, just ignore it

          if (scrollbarWidth > 80) scrollbarWidth = 0;
          if (scrollbarHeight > 80) scrollbarHeight = 0; // Make our measurements available as CSS properties for general use

          document.documentElement.style.setProperty("--root-scrollbar-width", `${scrollbarWidth}px`);
          document.documentElement.style.setProperty("--root-scrollbar-height", `${scrollbarHeight}px`);
          document.documentElement.style.setProperty("--root-scrollstop-top", `${originalScrollTop}px`);
          document.documentElement.style.setProperty("--root-scrollstop-left", `${originalScrollLeft}px`);
          setScrollbarWidth(scrollbarWidth);
          setScrollbarHeight(scrollbarHeight);
          return () => {
            // Undo all the things we just did
            document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") - 1).toString();

            if (document.documentElement.dataset["scrollHiders"] == "0") {
              // If we were the last scroll-locking thing to stop, then remove the class that stops scrolling.
              document.documentElement.removeAttribute("data-scroll-hiders");
              document.documentElement.classList.remove("document-scroll-hidden"); // Also, restore the original scroll position
              // We do this by forcing the scroll behavior to not be smooth
              // (it's instant if nothing is set to smooth, https://www.w3.org/TR/cssom-view/#scrolling),
              // scrolling, then restoring the original scroll behavior 
              // (which was probably already auto anyway, but just to be safe)

              const originalScrollBehavior = document.documentElement.style.scrollBehavior;
              document.documentElement.style.scrollBehavior = "auto";
              document.documentElement.scrollTo({
                top: originalScrollTop,
                left: originalScrollLeft,
                behavior: "auto"
              });
              document.documentElement.style.scrollBehavior = originalScrollBehavior;
            }
          };
        }
      }, [hideScroll]);
      return {
        getScrollbarWidth,
        getScrollbarHeight
      };
    }

    function useDialog(_ref) {
      let {
        softDismiss: {
          open
        },
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        dialog: {
          onClose
        },
        activeElement
      } = _ref;
      debugLog("useDialog"); // TODO: Differences between dialog and modal go here, presumably.
      // Non-modal dialogs need to be able to be repositioned, etc.

      const {
        useModalBackdrop,
        useModalBody,
        useModalProps,
        useModalTitle,
        softDismiss: {
          onBackdropClick
        },
        useModalFocusContainerProps
      } = useModal({
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        softDismiss: {
          onClose,
          open
        },
        activeElement
      });
      const useDialogBackdrop = q$1(() => {
        const {
          useModalBackdropProps
        } = useModalBackdrop();
        return {
          useDialogBackdropProps: useModalBackdropProps
        };
      }, [useModalBackdrop]);
      const useDialogBody = q$1(() => {
        const {
          useModalBodyProps
        } = useModalBody();
        return {
          useDialogBodyProps: useModalBodyProps
        };
      }, [useModalBackdrop]);
      const useDialogProps = useModalProps;
      const useDialogTitle = q$1(() => {
        const {
          useModalTitleProps
        } = useModalTitle();
        return {
          useDialogTitleProps: useModalTitleProps
        };
      }, [useModalTitle]);
      return {
        useDialogProps,
        useDialogTitle,
        useDialogBody,
        useDialogBackdrop,
        useDialogFocusContainerProps: useModalFocusContainerProps,
        softDismiss: {
          onBackdropClick
        }
      };
    }

    function useDrawer(_ref) {
      let {
        softDismiss: {
          open,
          onClose
        },
        activeElement,
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        }
      } = _ref;
      debugLog("useDrawer"); // TODO: Drawers are not always modal.

      const {
        useModalBackdrop,
        useModalBody,
        useModalProps,
        useModalTitle,
        useModalFocusContainerProps,
        softDismiss: {
          onBackdropClick
        }
      } = useModal({
        modal: {
          bodyIsOnlySemantic: bodyIsOnlySemantic !== null && bodyIsOnlySemantic !== void 0 ? bodyIsOnlySemantic : false,
          focusSelf
        },
        softDismiss: {
          onClose,
          open
        },
        activeElement
      });
      const useDrawerBackdrop = q$1(() => {
        const {
          useModalBackdropProps
        } = useModalBackdrop();
        return {
          useDrawerBackdropProps: useModalBackdropProps
        };
      }, [useModalBackdrop]);
      const useDrawerBody = q$1(() => {
        const {
          useModalBodyProps
        } = useModalBody();
        return {
          useDrawerBodyProps: useModalBodyProps
        };
      }, [useModalBackdrop]);
      const useDrawerProps = useModalProps;
      const useDrawerTitle = q$1(() => {
        const {
          useModalTitleProps
        } = useModalTitle();
        return {
          useDrawerTitleProps: useModalTitleProps
        };
      }, [useModalTitle]);
      return {
        useDrawerProps,
        useDrawerTitle,
        useDrawerBody,
        useDrawerBackdrop,
        useDrawerFocusContainerProps: useModalFocusContainerProps,
        softDismiss: {
          onBackdropClick
        }
      };
    }

    function useListboxSingle(_ref) {
      let {
        listboxSingle: {
          tagLabel,
          tagList,
          onSelect,
          ..._lbs
        },
        singleSelection: {
          selectedIndex,
          ...ss
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti
        },
        typeaheadNavigation: { ...tn
        },
        childrenHaveFocus: { ...chf
        }
      } = _ref;
      debugLog("useListboxSingle", selectedIndex);
      const {
        useLabelInput,
        useLabelLabel,
        ...labelReturnType
      } = useLabel({
        label: {
          prefixLabel: "aria-listbox-label-",
          prefixInput: "aria-listbox-",
          tagInput: tagList,
          tagLabel: tagLabel
        }
      });
      const onSelectedIndexChange = useStableCallback((event, newIndex) => {
        stableOnSelect(enhanceEvent(event, {
          selectedIndex: newIndex
        }));
      });
      const {
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps,
        ...listReturnType
      } = useListNavigationSingleSelection({
        childrenHaveFocus: { ...chf
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti
        },
        singleSelection: { ...ss,
          onSelectedIndexChange,
          selectedIndex
        },
        typeaheadNavigation: tn
      });
      const {
        useLabelInputProps
      } = useLabelInput();
      const stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
      const useListboxSingleItem = q$1(_ref2 => {
        let {
          listboxSingleItem: {
            disabled
          },
          listNavigation,
          managedChild,
          rovingTabIndex,
          hasFocus
        } = _ref2;
        debugLog("useListboxSingleItem", managedChild.index);
        const {
          rovingTabIndex: rti_ret,
          singleSelection: ss_ret,
          useListNavigationSingleSelectionChildProps
        } = useListNavigationSingleSelectionChild({
          managedChild,
          listNavigation,
          rovingTabIndex,
          hasFocus,
          subInfo: {}
        });
        return {
          useListboxSingleItemProps,
          rovingTabIndex: rti_ret,
          singleSelection: ss_ret
        };

        function useListboxSingleItemProps(props) {
          var _ss_ret$selected;

          props.role = "option";
          props["aria-selected"] = ((_ss_ret$selected = ss_ret.selected) !== null && _ss_ret$selected !== void 0 ? _ss_ret$selected : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useListNavigationSingleSelectionChildProps(props);
        }
      }, [useListNavigationSingleSelectionChild]);
      const useListboxSingleLabel = q$1(function useListboxSingleLabel() {
        function useListboxSingleLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxSingleLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxSingleItem,
        useListboxSingleProps,
        useListboxSingleLabel,
        ...listReturnType,
        ...labelReturnType
      };

      function useListboxSingleProps(props) {
        props.role = "listbox";
        return useListNavigationSingleSelectionProps(useLabelInputProps(props));
      }
    }
    function useListboxGroup() {
      const {
        useRandomIdReferencerElement,
        useRandomIdSourceElement
      } = useRandomId({
        randomId: {
          prefix: "listbox-multi-group"
        },
        managedChildren: {}
      });
      const {
        useRandomIdSourceElementProps
      } = useRandomIdSourceElement();
      const {
        useRandomIdReferencerElementProps
      } = useRandomIdReferencerElement("aria-labelledby");

      const useListboxGroupHeadingProps = props => {
        return useRandomIdSourceElementProps(props);
      };

      const useListboxGroupContainerProps = _ref3 => {
        let {
          role,
          ...props
        } = _ref3;
        return useRandomIdReferencerElementProps({
          role: warnOnOverwrite("useListboxMultiGroupProps", "role", role, "group"),
          ...props
        });
      };

      return {
        useListboxGroupContainerProps,
        useListboxGroupHeadingProps
      };
    }

    /*export interface UseListboxMultiReturnType<LabelElement extends Element, ListElement extends Element, ListItemElement extends Element> extends Omit<UseListNavigationReturnType<ListElement, ListItemElement, {}, never>, "useListNavigationChild" | "useListNavigationProps"> {
        useListboxMultiItem: UseListboxMultiItem<ListItemElement>;
        useListboxMultiProps: (props: h.JSX.HTMLAttributes<ListElement>) => h.JSX.HTMLAttributes<ListElement>;
        useListboxMultiLabel: () => { useListboxMultiLabelProps: (props: h.JSX.HTMLAttributes<LabelElement>) => h.JSX.HTMLAttributes<LabelElement>; }
    }*/

    function useListboxMulti(_ref) {
      let {
        listboxMulti: {
          tagLabel,
          tagList
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          ...rti
        },
        typeaheadNavigation: { ...tn
        }
      } = _ref;
      debugLog("useListboxMulti"); //const { useHasFocusProps, getFocusedInner } = useHasFocus<ListElement>({});

      const {
        useLabelInput,
        useLabelLabel
      } = useLabel({
        label: {
          prefixLabel: "aria-listbox-label-",
          prefixInput: "aria-listbox-",
          tagLabel: tagLabel,
          tagInput: tagList
        }
      });
      const listReturnType = useListNavigation({
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti,
          onTabbableIndexChange: useStableCallback(i => {
            onTabbableIndexChange === null || onTabbableIndexChange === void 0 ? void 0 : onTabbableIndexChange(i);
            /*if (selectionMode == "focus") {
                const target = (children.getAt(i!)?.subInfo.getElement());
                if (target)
                    onSelect?.({ target, currentTarget: target, [EventDetail]: { selectedIndex: i! } });
            }*/
          })
        },
        typeaheadNavigation: tn
      });
      const {
        useListNavigationChild,
        useListNavigationProps,
        rovingTabIndex: {
          setTabbableIndex
        }
      } = listReturnType;
      const {
        useLabelInputProps
      } = useLabelInput();
      const [getShiftHeld, setShiftHeld] = usePassiveState(null, returnFalse$1);
      const useListboxMultiItem = q$1(_ref2 => {
        let {
          listboxMultiItem: {
            selected,
            disabled,
            onSelectedChange
          },
          managedChild,
          listNavigation: ls,
          rovingTabIndex: rti,
          hasFocus
        } = _ref2;
        debugLog("useListboxMultiItem", managedChild.index, selected);
        const getSelected = useStableGetter(selected);
        const {
          useRefElementProps,
          getElement
        } = useRefElement({});
        const stableOnSelect = useStableCallback(onSelectedChange !== null && onSelectedChange !== void 0 ? onSelectedChange : () => {});
        const {
          useListNavigationChildProps,
          rovingTabIndex: rti2_ret
        } = useListNavigationChild({
          listNavigation: ls,
          managedChild,
          rovingTabIndex: rti,
          subInfo: {
            selected,
            onSelect: stableOnSelect
          }
        });
        _(() => {
          const element = getElement();

          if (element && getShiftHeld()) {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selected: true
              }
            });
          }
        }, [rti2_ret.tabbable]);
        return {
          useListboxMultiItemProps,
          listboxMultiItem: {
            getSelected,
            tabbable: rti2_ret.tabbable
          },
          rovingTabIndex: rti2_ret
        };

        function useListboxMultiItemProps(props) {
          var _rti2_ret$tabbable;

          const usePressProps = usePress({
            onClickSync: disabled ? null : e => {
              setTabbableIndex(managedChild.index, false);
              stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({ ...e,
                [EventDetail]: {
                  selected: !getSelected()
                }
              });
              e.preventDefault();
            },
            exclude: {},
            hasFocus
          });
          props.role = "option"; //props["aria-setsize"] = (childCount).toString();
          //props["aria-posinset"] = (info.index + 1).toString();

          props["aria-selected"] = ((_rti2_ret$tabbable = rti2_ret.tabbable) !== null && _rti2_ret$tabbable !== void 0 ? _rti2_ret$tabbable : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useRefElementProps(useListNavigationChildProps(usePressProps(props)));
        }
      }, [useListNavigationChild]);
      const useListboxMultiLabel = q$1(function useListboxMultiLabel() {
        function useListboxMultiLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxMultiLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxMultiItem,
        useListboxMultiProps,
        useListboxMultiLabel,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation,
        managedChildren: listReturnType.managedChildren
      };

      function useListboxMultiProps(props) {
        props.role = "listbox";
        props["aria-multiselectable"] = "true";
        return useListNavigationProps(useLabelInputProps(useMergedProps({
          onKeyDown,
          onKeyUp,
          onfocusout: onFocusOut
        }, props)));
      }

      function onKeyDown(e) {
        if (e.key == "Shift") setShiftHeld(true);
      }

      function onKeyUp(e) {
        if (e.key == "Shift") setShiftHeld(false);
      }

      function onFocusOut(_) {
        setShiftHeld(false);
      }
    }

    //export type UseMenuChildParameters<I extends UseMenuChildInfo> = I;

    /**
     * A menu is a popup control that contains a list of menu items, and that's it.
     * It has very well-defined logic for managing those items as the menu's state changes.
     *
     * A MenuBase is just the "popup" part without the "list of menu items" part. It can
     * (really, must) have interactive controls, but these controls are allowed to be more
     * free-form. This means that, like a dialog, you must tell this hook
     * where within the popup to send focus when opened (for a menu it's just the first
     * menu item, but with custom content you'll need to provide this).
     *
     */

    function useMenuSurface(_ref) {
      var _intersectionObserver;

      let {
        softDismiss,
        menuSurface: {
          sendFocusToMenu,
          role
        },
        activeElement
      } = _ref;
      debugLog("useMenuSurface"); //const sendFocusWithinMenu = useStableCallback(sendFocusToMenu);
      //const [focusTrapActive, setFocusTrapActive] = useState<null | boolean>(null);

      const {
        open,
        onClose: userOnClose
      } = softDismiss;
      const onClose = useStableCallback(reason => {
        if (reason != "lost-focus") {
          const opener = getOpenerElement();
          if (opener && "focus" in opener) opener.focus({
            preventScroll: true
          });
        }

        return userOnClose(reason);
      });
      useEnsureStability("useMenuSurface", onClose, role, sendFocusToMenu);
      const getIsOpen = useStableGetter(open);
      const intersectionObserver = A(null);
      const [getSurfaceFullyVisible, setSurfaceFullyVisible] = usePassiveState(null, returnFalse$1);
      (_intersectionObserver = intersectionObserver.current) !== null && _intersectionObserver !== void 0 ? _intersectionObserver : intersectionObserver.current = new IntersectionObserver((entries, _observer) => {
        for (const entry of entries) {
          setSurfaceFullyVisible(entry.intersectionRatio >= 1);
        }
      }, {
        root: null,
        threshold: [0, 1]
      });
      const [, setOpenerElement, getOpenerElement] = useState(null); //const { useHasFocusProps: useMenuBaseHasFocusProps, ...surfaceHasFocus } = useHasFocus<MenuSurfaceElement>({ ...hasFocusSurface });
      //const { useHasFocusProps: useButtonHasFocusProps, ...buttonHasFocus } = useHasFocus<MenuButtonElement>({ ...hasFocusButton });
      //const { getLastFocusedInner: getMenuBaseLastFocusedInner } = surfaceHasFocus;

      const {
        useRandomIdSourceElement,
        useRandomIdReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-menu-"
        },
        managedChildren: {}
      });
      const {
        useRandomIdSourceElementProps
      } = useRandomIdSourceElement();
      const {
        useRandomIdReferencerElementProps
      } = useRandomIdReferencerElement("aria-controls");
      const {
        getElement: getButtonElement,
        useRefElementProps: useButtonRefElementProps
      } = useRefElement({
        onElementChange: setOpenerElement
      });
      const {
        getElement: getMenuElement,
        useRefElementProps: useMenuBaseRefElementProps
      } = useRefElement({});
      const {
        useSoftDismissProps,
        ...softDismissReturn
      } = useSoftDismiss({
        softDismiss: { ...softDismiss,
          getElements: () => [getButtonElement(), getMenuElement()]
        },
        activeElement
      });

      const useMenuSurfaceProps = props => {
        function onKeyDown(e) {
          const open = getIsOpen();

          if (e.key == "Escape" && open) {
            onClose("escape");
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.preventDefault();
          }
        }

        return useSoftDismissProps(useMenuBaseRefElementProps(useMergedProps({
          onKeyDown
        }, props)));
      };

      const useMenuSurfaceButtonProps = props => {
        props["aria-expanded"] = warnOnOverwrite("useMenuSurfaceButtonProps", "aria-expanded", open, open.toString());
        props["aria-haspopup"] = warnOnOverwrite("useMenuSurfaceButtonProps", "aria-haspopup", role, role);
        return useButtonRefElementProps(useRandomIdReferencerElementProps(props));
      };

      s(() => {
        if (open === true) {
          sendFocusToMenu === null || sendFocusToMenu === void 0 ? void 0 : sendFocusToMenu();
          setTimeout(() => {
            if (!getSurfaceFullyVisible()) {
              var _getMenuElement;

              (_getMenuElement = getMenuElement()) === null || _getMenuElement === void 0 ? void 0 : _getMenuElement.scrollIntoView();
            }
          });
        }
      }, [open]);

      function useMenuSurfaceChildProps(props) {
        props.role = role;
        return useRandomIdSourceElementProps(props);
      }

      return {
        useMenuSurfaceChildProps,
        useMenuSurfaceSentinel: q$1(() => {
          debugLog("useMenuSurfaceSentinel");
          const {
            useSentinelProps: useMenuSentinelProps,
            ...rest
          } = useFocusSentinel({
            focusSentinel: {
              open: open === true,
              onClose: () => onClose("escape"),
              sendFocusToMenu
            }
          });
          return {
            useMenuSentinelProps,
            ...rest
          };
        }, [open, onClose]),
        useMenuSurfaceProps,
        useMenuSurfaceButtonProps,
        menuSurface: {
          /*getActiveElement: buttonHasFocus.getActiveElement,
          getLastActiveElement: buttonHasFocus.getLastActiveElement,
          getButtonElement: buttonHasFocus.getElement,
          getButtonFocused: buttonHasFocus.getFocused,
          getButtonFocusedInner: buttonHasFocus.getFocusedInner,
          getButtonLastFocused: buttonHasFocus.getLastFocused,
          getButtonLastFocusedInner: buttonHasFocus.getLastFocusedInner,
          getSurfaceElement: surfaceHasFocus.getElement,
          getSurfaceFocused: surfaceHasFocus.getFocused,
          getSurfaceFocusedInner: surfaceHasFocus.getFocusedInner,
          getSurfaceLastFocused: surfaceHasFocus.getLastFocused,
          getSurfaceLastFocusedInner: surfaceHasFocus.getLastFocusedInner,
          getWindowFocused: buttonHasFocus.getWindowFocused,*/
        },
        ...softDismissReturn //getMenuBaseLastFocusedInner,
        //getMenuBaseButtonLastFocusedInner,
        //open,
        //onOpen,
        //onClose

      };
    } // A focus sentinal is a hidden but focusable element that comes at the start or end 
    // of the out-of-place-focusable component that, when activated or focused over, closes the component
    // (if focused within 100ms of the open prop changing, instead of
    // closing, focusing the sentinel immediately asks it to focus itself).
    // This exists for things like menus which can have focus but also need a way to return
    // to whatever out-of-place parent they came from when naturally tabbed out of (as opposed
    // to dialogs which loop back around when tabbed out of). While mouse users can click out of a menu
    // and keyboard users can escape to close a menu, screen readers and other input methods 
    // that don't use those two would become stuck.

    function useFocusSentinel(_ref2) {
      let {
        focusSentinel: {
          open,
          onClose,
          sendFocusToMenu
        }
      } = _ref2;
      debugLog("useFocusSentinel");
      const getSendFocusWithinMenu = useStableGetter(sendFocusToMenu);
      const stableOnClose = useStableCallback(onClose);
      const [firstSentinelIsActive, setFirstSentinelIsActive] = useState(false);
      useTimeout({
        callback: () => {
          setFirstSentinelIsActive(open);
        },
        timeout: 100,
        triggerIndex: `${open}-${firstSentinelIsActive}`
      });
      const onFocus = firstSentinelIsActive ? () => stableOnClose() : () => {
        var _getSendFocusWithinMe;

        return (_getSendFocusWithinMe = getSendFocusWithinMenu()) === null || _getSendFocusWithinMe === void 0 ? void 0 : _getSendFocusWithinMe();
      };

      const onClick = () => stableOnClose();

      return {
        useSentinelProps: function (_ref3) {
          let {
            tabIndex,
            ...p
          } = _ref3;
          return useMergedProps({
            onFocus,
            onClick,
            tabIndex: warnOnOverwrite("useFocusSentinel", "tabIndex", tabIndex, 0)
          }, p);
        }
      };
    }
    function useMenu(_ref4) {
      let {
        menuButtonHasFocus,
        linearNavigation,
        listNavigation,
        managedChildren,
        menuSurface,
        rovingTabIndex,
        softDismiss,
        typeaheadNavigation,
        menu,
        activeElement
      } = _ref4;
      debugLog("useMenu");
      const {
        onOpen
      } = menu;
      const {
        open,
        onClose
      } = softDismiss;
      const {
        useListNavigationChild,
        useListNavigationProps,
        ...useListNavReturn
      } = useListNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children
        }
      } = useListNavReturn;
      const {
        /*useMenuSentinel,
        useMenuBaseButtonProps,
        useMenuBaseProps,
        open,
        onOpen,
        onClose: _onClose,*/
        useMenuSurfaceButtonProps,
        useMenuSurfaceProps,
        useMenuSurfaceSentinel,
        useMenuSurfaceChildProps,
        ...menuRest
      } = useMenuSurface({
        menuSurface: { ...menuSurface,
          role: "menu",
          sendFocusToMenu: q$1(() => {
            var _children$getAt;

            return (_children$getAt = children.getAt(0)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.focusSelf();
          }, [])
        },
        softDismiss,
        //hasFocusButton,
        //hasFocusSurface,
        activeElement //sendFocusWithinMenu: focusMenu ?? (() => { })

      });

      const useMenuButtonProps = p => {
        const usePressProps = usePress({
          onClickSync: () => {
            if (open) onClose === null || onClose === void 0 ? void 0 : onClose("escape");else onOpen === null || onOpen === void 0 ? void 0 : onOpen();
          },
          exclude: {},
          hasFocus: menuButtonHasFocus
        });
        const props = useMenuSurfaceButtonProps(p);
        return usePressProps(props);
      };

      const useMenuItem = q$1(_ref5 => {
        let {
          listNavigation,
          managedChild,
          rovingTabIndex
        } = _ref5;
        debugLog("useMenuItem", managedChild.index);
        const {
          useListNavigationChildProps,
          ...listNavRet
        } = useListNavigationChild({
          listNavigation,
          managedChild,
          rovingTabIndex,
          subInfo: {}
        });

        function useMenuItemProps(_ref6) {
          let { ...props
          } = _ref6;
          props.role = "menuitem";
          return useMergedProps({}, useListNavigationChildProps(props));
        }

        return {
          useMenuItemProps,
          ...listNavRet
        };
      }, []);

      function useMenuProps(props) {
        return useListNavigationProps(useMenuSurfaceChildProps(props));
      }

      return {
        useMenuProps,
        useMenuSurfaceProps,
        useMenuButtonProps,
        useMenuItem,
        useMenuSentinel: useMenuSurfaceSentinel,
        //useMenuSubmenuItem,
        ...useListNavReturn,
        ...menuRest
        /*focusMenu,
          currentTypeahead,
        invalidTypeahead,
          managedChildren,*/

      };
    }

    /*
    export function useTabs<TabListElement extends Element, TabElement extends Element, PanelElement extends Element, LabelElement extends Element>({ tabPanels: { managedChildren: { onChildrenMountChange: ocmc, ...tabPanelsManagedChildren } } }: UseTabsParameters): UseTabsReturnTypeWithHooks<TabListElement, TabElement, PanelElement, LabelElement> {
        const {
            useListNavigationSingleSelectionChild,
            useListNavigationSingleSelectionProps
        } = useListNavigationSingleSelection<TabListElement, TabElement, TabInfo, never>({
            childrenHaveFocus: {},
            linearNavigation: {},
            listNavigation: {},
            managedChildren: {},
            rovingTabIndex: {},
            singleSelection: {},
            typeaheadNavigation: {}
         });

        const useTab = useCallback(() => {}, []);
        const useTabPanel = useCallback(() => {});
        function useTabListProps(props: h.JSX.HTMLAttributes<TabListElement>) { return useListNavigationSingleSelectionProps(props); }
        function useTabLabelProps() {}

        return {

        }
        
    }*/

    function useTabs(_ref) {
      let {
        tabPanels: {
          managedChildren: {
            onChildrenMountChange: ocmc,
            ...tabPanelsManagedChildren
          }
        }
      } = _ref;
      debugLog("useTabs");
      const baseId = generateRandomId("aria-tabs-"); //const getTabListId = useCallback(() => { return baseId + "-tab-list"; }, []);

      const getTabId = q$1(index => {
        return baseId + "-tab-" + index;
      }, []);
      const getPanelId = q$1(index => {
        return baseId + "-panel-" + index;
      }, []); // Used for the panels, not the tabs in the tablist.
      // Those are in useTabList itself.

      const {
        useManagedChild,
        ...managedChildrenRet
      } = useManagedChildren({
        managedChildren: { ...tabPanelsManagedChildren,
          onChildrenMountChange: useStableCallback((m, u) => {
            ocmc === null || ocmc === void 0 ? void 0 : ocmc(m, u);
            reevaluateClosestFit();
          })
        }
      });
      const {
        changeIndex: changeVisiblePanel,
        getCurrentIndex: getVisibleIndex,
        reevaluateClosestFit
      } = useChildrenFlag({
        children: managedChildrenRet.managedChildren.children,
        closestFit: false,
        initialIndex: null,
        key: "visible"
      }); //const { useRandomIdReferencerElement, useRandomIdSourceElement } = useRandomId({ randomId: { prefix: "aria-tabs-" }, managedChildren: { onAfterChildLayoutEffect: null, onChildrenMountChange: null } });

      const {
        useLabelInput,
        useLabelLabel
      } = useLabel({
        label: {
          prefixInput: "",
          prefixLabel: "",
          tagInput: "div",
          tagLabel: "div"
        }
      });
      const useTabListLabel = q$1(() => {
        const {
          useLabelLabelProps
        } = useLabelLabel();

        function useTabListLabelProps(props) {
          return useLabelLabelProps(props);
        }

        return {
          useTabListLabelProps
        };
      }, [useLabelLabel]);
      const useTabList = q$1(_ref2 => {
        let {
          childrenHaveFocus,
          tabs: {
            onSelectedIndexChange
          },
          linearNavigation,
          listNavigation,
          managedChildren: tabListManagedChildren,
          rovingTabIndex,
          singleSelection,
          typeaheadNavigation
        } = _ref2;
        debugLog("useTabList");
        const stableOnSelectedIndexChange = useStableCallback(onSelectedIndexChange);
        const {
          useListNavigationSingleSelectionChild,
          useListNavigationSingleSelectionProps,
          ...listNavRet1
        } = useListNavigationSingleSelection({
          linearNavigation,
          listNavigation,
          managedChildren: tabListManagedChildren,
          rovingTabIndex,
          singleSelection: { ...singleSelection,
            onSelectedIndexChange: q$1((event, index) => {
              onSelectedIndexChange === null || onSelectedIndexChange === void 0 ? void 0 : onSelectedIndexChange(enhanceEvent(event, {
                selectedIndex: index
              }));
            }, [])
          },
          typeaheadNavigation,
          childrenHaveFocus
        });
        s(() => {
          changeVisiblePanel(singleSelection.selectedIndex);
        }, [singleSelection.selectedIndex]);
        const {
          useLabelInputProps
        } = useLabelInput();
        const useTab = q$1(_ref3 => {
          let {
            listNavigation,
            managedChild,
            rovingTabIndex,
            hasFocus
          } = _ref3;
          debugLog("useTab", managedChild.index);
          const {
            useListNavigationSingleSelectionChildProps,
            ...listNavRet2
          } = useListNavigationSingleSelectionChild({
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo: {},
            hasFocus
          });
          const {
            singleSelection: {
              selected
            },
            rovingTabIndex: {
              tabbable
            }
          } = listNavRet2;

          const useTabProps = _ref4 => {
            let {
              role,
              "aria-controls": ariaControls,
              "aria-selected": ariaSelected,
              ...props
            } = _ref4;
            const panelId = getPanelId(managedChild.index);
            const tabId = getTabId(managedChild.index);
            const usePressProps = usePress({
              onClickSync: e => {
                stableOnSelectedIndexChange(enhanceEvent(e, {
                  selectedIndex: managedChild.index
                }));
              },
              exclude: {},
              hasFocus
            });
            return useListNavigationSingleSelectionChildProps(useMergedProps({
              role: warnOnOverwrite("useTab", "role", role, "tab"),
              "aria-controls": warnOnOverwrite("useTab", "ariaControls", ariaControls, panelId),
              "aria-selected": warnOnOverwrite("useTab", "ariaSelected", ariaSelected, selected ? "true" : undefined),
              "data-tabbable": tabbable.toString(),
              id: tabId
            }, usePressProps(props)));
          };

          return {
            useTabProps,
            ...listNavRet2
          };
        }, [useLabelInput, useListNavigationSingleSelectionChild]);

        const useTabListProps = _ref5 => {
          let {
            role,
            "aria-orientation": ariaOrientation,
            ...props
          } = _ref5;
          return useListNavigationSingleSelectionProps(useLabelInputProps(useMergedProps({
            role: warnOnOverwrite("useTabList", "role", role, "tablist"),
            "aria-orientation": ariaOrientation !== null && ariaOrientation !== void 0 ? ariaOrientation : "horizontal"
          }, props)));
        };

        return {
          tabList: listNavRet1,
          useTabListProps,
          useTab
        };
      }, [useLabelInput]);
      const useTabPanel = q$1(_ref6 => {
        let {
          managedChild: {
            flags,
            ...managedChild
          }
        } = _ref6;
        debugLog("useTabPanel", managedChild.index); //const [correspondingTabId, setCorrespondingTabId] = useState<string | null>(null);

        const [isVisible, setIsVisible, getIsVisible] = useState(getVisibleIndex() == managedChild.index);
        const visibleRef = A({
          get: getIsVisible,
          set: setIsVisible,
          isValid: returnTrue
        });
        useManagedChild({
          managedChild: { ...managedChild,
            flags: {
              visible: visibleRef.current,
              ...flags
            },
            subInfo: {}
          }
        });
        const panelId = getPanelId(managedChild.index);
        const tabId = getTabId(managedChild.index);

        const useTabPanelProps = _ref7 => {
          let {
            role,
            "aria-labelledby": ariaLabelledBy,
            id,
            ...props
          } = _ref7;
          return useMergedProps({
            role: warnOnOverwrite("useTabPanelProps", "role", role, "tabpanel"),
            "aria-labelledby": warnOnOverwrite("useTabPanelProps", "aria-labelledby", ariaLabelledBy, tabId),
            id: warnOnOverwrite("useTabPanelProps", "id", id, panelId)
          }, props);
        };

        return {
          useTabPanelProps,
          tabPanel: {
            visible: isVisible,
            getVisible: getIsVisible
          }
        };
      }, []);
      return {
        useTabListLabel,
        useTabList,
        useTabPanel,
        tabPanels: managedChildrenRet
      };
    }

    function returnFalse() {
      return false;
    }

    function useTooltip(_ref) {
      var _mouseoverDelay, _mouseoutToleranceDel, _focusDelay;

      let {
        mouseoverDelay,
        mouseoutToleranceDelay,
        focusDelay
      } = _ref;
      debugLog("useTooltip");
      (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
      (_mouseoutToleranceDel = mouseoutToleranceDelay) !== null && _mouseoutToleranceDel !== void 0 ? _mouseoutToleranceDel : mouseoutToleranceDelay = 500;
      (_focusDelay = focusDelay) !== null && _focusDelay !== void 0 ? _focusDelay : focusDelay = 1; // The escape key should close tooltips, but do nothing else.
      // (i.e. closing a tooltip in a dialog MUST NOT close the dialog too)
      // TODO: Tooltips are, effectively, always the topmost component,
      // so we can just have them listen to and swallow all "Escape"
      // key presses before anyone else. For a more general popup,
      // or a tooltip in a tooltip (!!) a different solution would be needed.

      useGlobalHandler(document, "keydown", e => {
        if (getOpen() && e.key === "Escape" && !e.defaultPrevented) {
          e.preventDefault();
          e.stopImmediatePropagation();
          setOpen(false);
          setHoverState("hidden");
          setTriggerFocusedDelayCorrected(false);
          setTooltipFocusedDelayCorrected(false);
        }
      }, {
        capture: true
      });
      const [open, setOpen, getOpen] = useState(false);
      const {
        useRandomIdSourceElement,
        //: useTooltipIdProps, 
        useRandomIdReferencerElement //: useTooltipIdReferencingProps 

      } = useRandomId({
        randomId: {
          prefix: "aria-tooltip-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const [, setTriggerFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTriggerFocusedDelayCorrected(focused), focused ? focusDelay : 1);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTooltipFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTooltipFocusedDelayCorrected(focused), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const onHoverChange = useStableCallback(function onHoverChange(hovering) {
        if (hovering) {
          switch (hoverState) {
            case "hiding":
              {
                // We're hoving over the tooltip right after hovering away from it.
                // In this case, we show it again immediately
                setHoverState("shown");
                break;
              }

            case "hidden":
              {
                // The tooltip isn't showing and hasn't for awhile (if ever)
                // Wait for our mouseover delay
                setHoverState("showing2");
                break; //const handle = setTimeout(() => { console.log("setHoverState(shown)");  setHoverState("shown") }, mouseoverDelay);
                //return () => clearTimeout(handle);
              }
          }
        } else {
          switch (hoverState) {
            case "shown":
              {
                // The mouse has left the trigger, but delay truly hiding it for a moment
                setHoverState("hiding");
                break; //const handle = setTimeout(() => { console.log("setHoverState(hidden)"); setHoverState("hidden");}, mouseoverDelay);
                //return () => clearTimeout(handle);
              }

            case "showing2":
              {
                // During a mouseover delay, when we mouseout,
                // just reset the timer
                setHoverState("hidden");
                break;
              }
          }
        }
      });
      const [, setTriggerHover] = usePassiveState(onHoverChange, returnFalse);
      const [, setTooltipHover] = usePassiveState(onHoverChange, returnFalse);
      const [triggerFocusedDelayCorrected, setTriggerFocusedDelayCorrected] = useState(false);
      const [hoverState, setHoverState] = useState("hidden");
      useTimeout({
        triggerIndex: hoverState,
        timeout: hoverState == "showing2" ? mouseoverDelay : null,
        callback: () => {
          if (hoverState == "showing2") {
            setHoverState("shown");
          }
        }
      });
      useTimeout({
        triggerIndex: hoverState,
        timeout: hoverState == "hiding" ? mouseoutToleranceDelay : null,
        callback: () => {
          if (hoverState == "hiding") {
            setHoverState("hidden");
          }
        }
      }); //const [triggerHoverDelayCorrected, setTriggerHoverDelayCorrected] = useState(false);

      const [tooltipFocusedDelayCorrected, setTooltipFocusedDelayCorrected] = useState(false); //const [tooltipHoverDelayCorrected, setTooltipHoverDelayCorrected] = useState(false);

      const hoverDelayCorrected = hoverState == "shown";
      s(() => {
        setOpen(triggerFocusedDelayCorrected || hoverDelayCorrected || tooltipFocusedDelayCorrected);
      }, [triggerFocusedDelayCorrected || hoverDelayCorrected || tooltipFocusedDelayCorrected]);
      const useTooltipTrigger = q$1(function useTooltipTrigger(_ref2) {
        let {
          hasFocus: {
            onFocusedInnerChanged,
            ...hasFocus
          }
        } = _ref2;
        debugLog("useTooltipTrigger");
        useGlobalHandler(document, "pointermove", e => {
          var _getElement;

          const target = e.target;
          setTriggerHover(target == getElement() || !!((_getElement = getElement()) !== null && _getElement !== void 0 && _getElement.contains(target)));
        }, {
          capture: true
        });

        function onTouchEnd(e) {
          e.target.focus();
        }

        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({ ...hasFocus,
          onFocusedInnerChanged: useStableCallback((focused, prev) => {
            onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);
            setTriggerFocused(focused);
          })
        });

        function useTooltipTriggerProps(_ref3) {
          var _props$tabIndex;

          let { ...props
          } = _ref3;
          const {
            useRandomIdReferencerElementProps
          } = useRandomIdReferencerElement("aria-describedby"); // Note: Though it's important to make sure that focusing activates a tooltip,
          // it's perfectly reasonable that a child element will be the one that's focused,
          // not this one, so we don't set tabIndex=0

          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1;
          return useRandomIdReferencerElementProps(useHasFocusProps(useMergedProps({
            onTouchEnd
          }, props)));
        }

        return {
          useTooltipTriggerProps
        };
      }, []);
      const useTooltipPopup = q$1(function useTooltip(_ref4) {
        let {
          hasFocus: {
            onFocusedInnerChanged,
            ...hasFocus
          }
        } = _ref4;
        debugLog("useTooltipTooltip");
        const {
          useRandomIdSourceElementProps
        } = useRandomIdSourceElement();
        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({
          onFocusedInnerChanged: useStableCallback((focused, prev) => {
            onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);
            setTooltipFocused(focused);
          }),
          ...hasFocus
        });
        useGlobalHandler(document, "pointermove", e => {
          var _getElement2;

          const target = e.target;
          setTooltipHover(target == getElement() || !!((_getElement2 = getElement()) !== null && _getElement2 !== void 0 && _getElement2.contains(target)));
        }, {
          capture: true
        });

        function useTooltipPopupProps(_ref5) {
          let { ...props
          } = _ref5;
          return useRandomIdSourceElementProps(useHasFocusProps(useMergedProps({}, props)));
        }

        return {
          useTooltipPopupProps
        };
      }, []);
      return {
        useTooltipPopup,
        useTooltipTrigger,
        isOpen: open,
        getIsOpen: getOpen
      };
    }

    function useRadioGroup(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        radioGroup: {
          name,
          onSelectedValueChange,
          selectedValue,
          tagGroup,
          tagGroupLabel
        },
        rovingTabIndex,
        typeaheadNavigation,
        childrenHaveFocus,
        singleSelection: {
          selectionMode
        }
      } = _ref;
      debugLog("useRadioGroup", selectedValue);
      const {
        getElement: _getRadioGroupParentElement,
        useRefElementProps
      } = useRefElement({}); //const getSelectedIndex = useCallback((selectedValue: V) => { return byName.current.get(selectedValue) ?? 0 }, [])

      const [selectedIndex, setSelectedIndex] = useState(0);
      const byName = A(new Map()); //const stableOnInput = useStableCallback(onSelectedValueChange);
      //const [anyRadiosFocused, setAnyRadiosFocused, getAnyRadiosFocused] = useState(false);

      const {
        useLabelInput: useGroupLabelInput,
        useLabelLabel: useGroupLabelLabel
      } = useLabel({
        label: {
          prefixLabel: "aria-radio-group-label-",
          tagInput: tagGroup,
          tagLabel: tagGroupLabel,
          prefixInput: "aria-radio-group-"
        }
      });
      const {
        useLabelInputProps: useGroupLabelInputProps
      } = useGroupLabelInput();
      const {
        useLabelLabelProps: useGroupLabelLabelProps
      } = useGroupLabelLabel();
      const onSelectedIndexChange = useStableCallback((e, newIndex) => {
        var _listNavRet$managedCh;

        onSelectedValueChange(enhanceEvent(e, {
          selectedValue: (_listNavRet$managedCh = listNavRet.managedChildren.children.getAt(newIndex)) === null || _listNavRet$managedCh === void 0 ? void 0 : _listNavRet$managedCh.subInfo.subInfo.subInfo.getValue()
        }));
      });
      const {
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps,
        ...listNavRet
      } = useListNavigationSingleSelection({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        singleSelection: {
          selectedIndex,
          onSelectedIndexChange,
          selectionMode
        },
        typeaheadNavigation,
        childrenHaveFocus
      }); // Track whether the currently focused element is a child of the radio group parent element.
      // When it's not, we reset the tabbable index back to the currently selected element.
      //const { useActiveElementProps } = useActiveElement<G>({ onActiveElementChange: useCallback((activeElement: Node | null) => setAnyRadiosFocused(!!(getRadioGroupParentElement()?.contains(activeElement))), []) });

      /*useEffect(() => {
          if (!anyRadiosFocused)
              navigateToIndex(selectedIndex ?? 0);
      }, [anyRadiosFocused, selectedIndex, navigateToIndex]);*/

      const useRadioGroupProps = q$1(_ref2 => {
        let { ...props
        } = _ref2;
        props.role = "radiogroup";
        return useGroupLabelInputProps(useListNavigationSingleSelectionProps(useRefElementProps(props)));
      }, [useRefElementProps]);
      const useRadioGroupLabelProps = q$1(props => {
        return useGroupLabelLabelProps(props);
      }, [useGroupLabelLabelProps]); //const correctedIndex = (selectedIndex == null || selectedIndex < 0 || selectedIndex >= managedChildren.length) ? null : selectedIndex;

      /*const { onChildrenMountChange } = useChildrenFlag({
          initialIndex: 0,
          children,
          key: "selected"
          //setChildFlag: (i, checked) => managedChildren[i]?.setChecked(checked),
          //getChildFlag: ((i) => managedChildren[i]?.getChecked() ?? false)
      });*/

      s(() => {
        if (selectedValue == null) {
          setSelectedIndex(null);
        } else {
          const selectedIndex = byName.current.get(selectedValue);
          setSelectedIndex(selectedIndex !== null && selectedIndex !== void 0 ? selectedIndex : null);
        }
      }, [byName, selectedValue]);
      const useRadio = q$1(function useRadio(_ref3) {
        let {
          listNavigation,
          managedChild,
          rovingTabIndex,
          hasFocusInput,
          hasFocusLabel,
          radio: {
            disabled,
            labelPosition,
            tagInput,
            tagLabel,
            value
          }
        } = _ref3;
        const index = managedChild.index;
        debugLog("useRadio", index); //const [checked, setChecked, getChecked] = useState<boolean | null>(null);

        const onInput = useStableCallback(e => {
          e.preventDefault();
          onSelectedIndexChange(e, index);
        });
        const getValue = useStableGetter(value);
        const {
          useListNavigationSingleSelectionChildProps,
          ...listNavRet
        } = useListNavigationSingleSelectionChild({
          listNavigation,
          rovingTabIndex,
          managedChild,
          hasFocus: hasFocusInput,
          subInfo: {
            getValue
          }
        });
        const {
          singleSelection: {
            selected: checked
          }
        } = listNavRet;
        const {
          useCheckboxLikeInputElement,
          useCheckboxLikeLabelElement
        } = useCheckboxLike({
          checkboxLike: {
            checked: checked !== null && checked !== void 0 ? checked : false,
            labelPosition,
            disabled,
            onCheckedChange: onInput,
            role: "radio"
          },
          label: {
            tagInput: tagInput,
            tagLabel: tagLabel
          },
          hasFocusInput,
          hasFocusLabel
        });
        _(() => {
          byName.current.set(value, index);
          return () => {
            byName.current.delete(value);
          };
        }, [byName, value, index]);

        const useRadioInput = () => {
          const tag = tagInput;

          const useRadioInputProps = props => {
            if (tag == "input") {
              props.name = name;
              props.checked = checked !== null && checked !== void 0 ? checked : false;
              props.type = "radio";
            } else {
              props["aria-checked"] = (checked !== null && checked !== void 0 ? checked : false).toString();
            }

            const propsIfInputHandlesFocus = useListNavigationSingleSelectionChildProps(props);
            const {
              useCheckboxLikeInputElementProps
            } = useCheckboxLikeInputElement();
            return useMergedProps(useCheckboxLikeInputElementProps({}), labelPosition == "separate" ? propsIfInputHandlesFocus : props);
          };

          return {
            useRadioInputProps
          };
        };

        const useRadioLabel = q$1(() => {
          //const tag = tagLabel;
          const useRadioLabelProps = props => {
            const {
              useCheckboxLikeLabelElementProps
            } = useCheckboxLikeLabelElement();
            const propsIfLabelHandlesFocus = useListNavigationSingleSelectionChildProps(props);
            return useCheckboxLikeLabelElementProps(useMergedProps({}, labelPosition == "wrapping" ? propsIfLabelHandlesFocus : props));
          };

          return {
            useRadioLabelProps
          };
        }, [useCheckboxLikeLabelElement]);
        return {
          useRadioInput,
          useRadioLabel,
          ...listNavRet //checked: checked ?? false,
          //tabbable: tabbable ?? false

        };
      }, [byName, useListNavigationSingleSelectionChild]);
      return {
        useRadio,
        useRadioGroupProps,
        useRadioGroupLabelProps,
        radioGroup: {
          selectedIndex,
          selectedValue
        },
        ...listNavRet
      };
    }

    function useSlider(_ref) {
      let {
        slider: {
          max: maxParent,
          min: minParent
        },
        managedChildren
      } = _ref;
      debugLog("useSlider");
      const {
        useManagedChild,
        ...childrenInfo
      } = useManagedChildren({
        managedChildren
      });
      const useSliderThumb = q$1(function useSliderThumb(_ref2) {
        let {
          managedChild,
          sliderThumb
        } = _ref2;
        debugLog("useSliderThumb", managedChild.index);
        const [minParentCopy, setMinParentCopy] = y(minParent);
        const [maxParentCopy, setMaxParentCopy] = y(maxParent);

        useManagedChild({
          managedChild: { ...managedChild,
            subInfo: {
              setMax: setMaxParentCopy,
              setMin: setMinParentCopy
            }
          }
        });

        const {
          tag,
          value,
          max: maxOverride,
          min: minOverride,
          onValueChange,
          valueText,
          label
        } = sliderThumb;
        const min = minOverride !== null && minOverride !== void 0 ? minOverride : minParentCopy;
        const max = maxOverride !== null && maxOverride !== void 0 ? maxOverride : maxParentCopy;
        return {
          useSliderThumbProps,
          sliderThumb: {
            min,
            max
          }
        };

        function useSliderThumbProps(props) {
          let newProps = tag == "input" ? {
            min,
            max,
            value,
            type: "range"
          } : {
            "aria-valuemax": `${max}`,
            "aria-valuemin": `${min}`,
            "aria-valuenow": `${value}`
          };
          newProps = { ...newProps,
            "aria-label": label,
            "aria-valuetext": valueText,
            style: {
              "--range-value": `${value}`,
              "--range-value-text": `${valueText}`
            }
          };

          if (tag == "input") {
            newProps.onInput = e => {
              onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange({
                currentTarget: e.currentTarget,
                target: e.target,
                [EventDetail]: {
                  value: e.currentTarget.valueAsNumber
                }
              });
            };
          } else {
            throw new Error("Unimplemented");
          }

          return useMergedProps(newProps, props);
        }
      }, []);
      return {
        useSliderThumb,
        ...childrenInfo
      };
    }

    function useToasts(_ref) {
      let {
        managedChildren: {
          onChildrenMountChange: ocmu,
          onAfterChildLayoutEffect
        },
        toasts: {
          visibleCount
        }
      } = _ref;
      debugLog("useToasts"); // Normally, this does just look like [0, 1, 2, 3], etc
      // so it could be just an index to the current toast,
      // but if we dismiss toasts out of order, it's [0, 2, 3] or something.
      // So just keep track of it all in a big ol', there's only one of these on a page anyway,
      // and if you're pusing 10000 toasts at once an Array<number> isn't going to be your bottleneck.

      const currentIndexQueue = A([]);
      const [politeness, setPoliteness] = useState("polite");
      const getMaxVisibleCount = useStableGetter(visibleCount);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({});
      const {
        useManagedChild,
        ...childInfo
      } = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange: ocmu
        }
      });
      const {
        managedChildren: {
          children: toastQueue
        }
      } = childInfo; // When a toast is shown or hidden, always make sure that we're showing all the toasts that we should be.

      const showHighestPriorityToast = q$1(() => {
        const max = Math.min(getMaxVisibleCount(), currentIndexQueue.current.length);

        for (let i = 0; i < max; ++i) {
          const highestPriorityToast = toastQueue.getAt(currentIndexQueue.current[i]);
          console.assert(!!highestPriorityToast);
          highestPriorityToast === null || highestPriorityToast === void 0 ? void 0 : highestPriorityToast.subInfo.show();
        }
      }, []); // Any time a new toast mounts, update our bottommostToastIndex to point to it if necessary
      // ("necessary" just meaning if it's the first toast ever or all prior toasts have been dismissed)

      const onAnyToastMounted = q$1(toastIndex => {
        var _toastQueue$getAt;

        currentIndexQueue.current.push(toastIndex);
        (_toastQueue$getAt = toastQueue.getAt(toastIndex)) === null || _toastQueue$getAt === void 0 ? void 0 : _toastQueue$getAt.subInfo.setNumberAheadOfMe(currentIndexQueue.current.length - 1);
        showHighestPriorityToast();
      }, []); // Any time a toast is dismissed, update our bottommostToastIndex to point to the next toast in the queue, if one exists.

      const onAnyToastDismissed = q$1(_index => {
        var _toastQueue$getAt2;

        // When we dismiss a toast, remove it from the "to-display" queue by actually splicing it out of the array.
        // Then notify each toast of its change in position within that queue to keep the two in sync.
        const removalIndex = currentIndexQueue.current.findIndex(i => i == _index); // For all toasts that have already been dismissed, shift them even further back by one to "make space" 
        // (they're removed from the queue but this is the negative index they would have if we kept negatives in the queue)
        // for the newly-dismissed toast.

        toastQueue.forEach(c => {
          c.subInfo.setNumberAheadOfMe(prev => {
            if (prev < 0) return prev - 1;else return prev;
          });
        }); // Let this toast know that it's now the most recently dismissed toast

        (_toastQueue$getAt2 = toastQueue.getAt(_index)) === null || _toastQueue$getAt2 === void 0 ? void 0 : _toastQueue$getAt2.subInfo.setNumberAheadOfMe(-1); // Notify all toasts waiting behind this one in the queue that they've moved up one slot

        toastQueue.forEach(c => {
          c.subInfo.setNumberAheadOfMe(prev => {
            if (prev > removalIndex) return prev - 1;else return prev;
          });
        }); // Actually modify the queue itself

        currentIndexQueue.current.splice(removalIndex, 1); // And after all that, make sure that we're showing any toasts that have been waiting in the queue

        showHighestPriorityToast();
      }, []);
      const [_mouseOver2, setMouseOver, _getMouseOver] = useState(false);
      useGlobalHandler(document, "pointermove", e => {
        var _getElement;

        const mouseOver = e.target != null && e.target instanceof Node && (((_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.contains(e.target)) || getElement() == e.target);
        setMouseOver(mouseOver);
      }); // Any time the index pointing to the currently-showing toast changes,
      // update the relevant children and let them know that they're now either active or dismissed.

      /*const { changeIndex, reevaluateClosestFit } = useChildrenFlag<ToastInfo, "showing">({
          initialIndex: activeToastIndex,
          children: toastQueue,
          key: "showing",
          closestFit: false,
      });
      useEffect(() => {
          changeIndex(activeToastIndex);
      }, [activeToastIndex]);*/

      const useToast = q$1(_ref2 => {
        let {
          toast: {
            politeness,
            timeout
          },
          managedChild: {
            index
          }
        } = _ref2;
        debugLog("useToast", index);
        const [numberOfToastsAheadOfUs, setNumberOfToastsAheadOfUs] = useState(Infinity);
        const getIndex = useStableGetter(index);
        const [dismissed2, setDismissed2, getDismissed2] = useState(false);
        const [showing2, setShowing2, getShowing2] = useState(false); //const [dismissed, setDismissed] = useState(false);
        //const [status, setStatus, getStatus] = useState<"pending" | "active" | "dismissed">("pending");
        //const dismissed = (status === "dismissed");

        const dismiss = q$1(() => {
          if (!getDismissed2()) onAnyToastDismissed(getIndex());
          setDismissed2(true);
          setShowing2(false);
        }, []);
        const show = q$1(() => {
          setShowing2(true);
        }, []);
        s(() => {
          if (!getDismissed2() && !getShowing2()) {
            if (numberOfToastsAheadOfUs >= 0 && numberOfToastsAheadOfUs < getMaxVisibleCount()) {
              show();
            }
          }
        }, [numberOfToastsAheadOfUs]); //const toastId = generateRandomId("toast-");

        _(() => {
          setPoliteness(politeness !== null && politeness !== void 0 ? politeness : "polite");
        }, [politeness]);
        const focus = q$1(() => {
          const element = getElement();

          if (element) {
            const firstFocusable = findFirstFocusable(element);
            firstFocusable === null || firstFocusable === void 0 ? void 0 : firstFocusable.focus();
          }
        }, []);
        /*const [showing, setShowing2, getShowing] = useState(false);
        const setShowing: StateUpdater<boolean> = ((u) => {
            setShowing2(prev => {
                const ret: boolean = (typeof u == 'function') ? u(prev) : u;
                  if (ret === false) {
                    setDismissed(true);
                    onAnyToastDismissed(getIndex())
                }
                  return ret;
            });
        })*/
        //const showingRef = useRef<ChildFlagOperations>({ get: getShowing, set: setShowing, isValid: returnTrue });

        useManagedChild({
          managedChild: {
            index,
            flags: {
              /*showing: showingRef.current*/
            },
            subInfo: {
              focus,
              setNumberAheadOfMe: setNumberOfToastsAheadOfUs,
              show
            }
          }
        }); //const isActive = (status === "active");


        const [triggerIndex, setTriggerIndex] = useState(1);
        const resetDismissTimer = q$1(() => {
          setTriggerIndex(i => ++i);
        }, []);
        s(() => {
          onAnyToastMounted(index);
        }, []);
        /*useEffect(() => {
            if (!showing)
                onAnyToastDismissed(index)
        }, [showing]);*/

        const dismissTimeoutKey = timeout == null || numberOfToastsAheadOfUs != 0 ? null : isFinite(timeout) ? timeout : timeout > 0 ? null : 0;
        useTimeout({
          timeout: dismissTimeoutKey,
          callback: () => {
            if (showing2) dismiss();
          },
          triggerIndex: showing2 ? triggerIndex : false
        });
        return {
          toast: {
            dismissed: dismissed2,
            showing: showing2,
            numberOfToastsAheadOfUs,
            dismiss,
            resetDismissTimer
          }
        };
      }, []);

      function useToastContainerProps(_ref3) {
        var _ref4;

        let {
          role,
          "aria-live": ariaLive,
          "aria-relevant": ariaRelevant,
          ...props
        } = _ref3;
        return useMergedProps(useRefElementProps({
          class: "toasts-container",
          role: role || "status",
          "aria-live": (_ref4 = politeness !== null && politeness !== void 0 ? politeness : ariaLive) !== null && _ref4 !== void 0 ? _ref4 : "polite",
          "aria-relevant": ariaRelevant !== null && ariaRelevant !== void 0 ? ariaRelevant : "additions"
        }), props);
      }

      return {
        useToast,
        useToastContainerProps,
        ...childInfo,
        toasts: {}
      };
    }

    function identity$1(t) {
      return t;
    }

    function useTable(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      debugLog("useTable");
      const [getCurrentSortColumn, setCurrentSortColumn] = usePassiveState(null, returnNull);
      const bodySort = A(null);
      const manglers = A({
        rowIndexMangler: identity$1,
        rowIndexDemangler: identity$1
      });
      const {
        useGridNavigationProps,
        useGridNavigationRow,
        ...gridNavRet1
      } = useGridNavigation({
        linearNavigation,
        listNavigation: { ...listNavigation
        },
        gridNavigation: {
          rowIndexDemangler: q$1(n => manglers.current.rowIndexDemangler(n), []),
          rowIndexMangler: q$1(n => manglers.current.rowIndexMangler(n), [])
        },
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children: rows
        }
      } = gridNavRet1;
      const useTableRow = q$1(_ref2 => {
        let {
          asChildRowOfSection,
          asParentRowOfCells,
          tableRow: {
            location,
            tagTableRow
          }
        } = _ref2;
        debugLog("useTableRow", asChildRowOfSection.managedChild.index);
        const getCells = q$1(() => {
          return cells;
        }, []);
        const {
          useGridNavigationCell,
          useGridNavigationRowProps,
          ...gridNavRet2
        } = useGridNavigationRow({
          asChildRowOfSection: { ...asChildRowOfSection,
            subInfo: {
              getCells,
              location
            }
          },
          asParentRowOfCells
        });
        const {
          asParentOfCells: {
            managedChildren: {
              children: cells
            }
          }
        } = gridNavRet2;
        const useTableCell = q$1(_ref3 => {
          let {
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo,
            hasFocus,
            tableCell: {
              tagTableCell,
              headerType
            }
          } = _ref3;
          const [mySortDirection, setMySortDirection] = useState(null);
          debugLog("useTableCell", managedChild.index);
          const {
            useGridNavigationCellProps,
            ...gridNavRet3
          } = useGridNavigationCell({
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo: { ...subInfo,
              setMySortDirection
            },
            hasFocus
          });
          const sort = useStableCallback(() => {
            var _getCurrentSortColumn;

            const sortInfo = (_getCurrentSortColumn = getCurrentSortColumn()) !== null && _getCurrentSortColumn !== void 0 ? _getCurrentSortColumn : {
              index: -1,
              direction: 'ascending'
            };
            const cellIndex = managedChild.index;

            if (sortInfo.index == cellIndex) {
              if (sortInfo.direction[0] == 'a') {
                sortInfo.direction = 'descending';
              } else {
                sortInfo.direction = 'ascending';
              }
            } else {
              sortInfo.direction = "ascending";
            }

            sortInfo.index = managedChild.index;
            setCurrentSortColumn(sortInfo);
            getCells().forEach(cell => {
              if (cell.index == managedChild.index) {
                cell.subInfo.subInfo.subInfo.setMySortDirection(sortInfo.direction);
              } else {
                cell.subInfo.subInfo.subInfo.setMySortDirection(null);
              }
            });
            bodySort.current();
          });

          const useTableCellProps = props => {
            if (tagTableCell != "td" && tagTableCell != "th") {
              if (headerType == "row") props.role = warnOnOverwrite("useTableCell", "role", props.role, "rowheader");else if (headerType == "column") props.role = warnOnOverwrite("useTableCell", "role", props.role, "columnheader");else props.role = warnOnOverwrite("useTableCell", "role", props.role, "cell");
            } else {
              if (headerType == "row") props.scope = warnOnOverwrite("useTableCell", "scope", props.scope, "row");else if (headerType == "column") props.scope = warnOnOverwrite("useTableCell", "scope", props.scope, "col");
            }

            if (headerType != null) {
              if (mySortDirection == "descending") {
                props["aria-sort"] = warnOnOverwrite("useTableCell", "aria-sort", props["aria-sort"], "descending");
              } else if (mySortDirection == "ascending") {
                props["aria-sort"] = warnOnOverwrite("useTableCell", "aria-sort", props["aria-sort"], "ascending");
              }
            }

            return useGridNavigationCellProps(props);
          };

          return {
            tableHeaderCell: {
              sort,
              sortDirection: mySortDirection
            },
            useTableCellProps,
            ...gridNavRet3
          };
        }, []);

        const useTableRowProps = props => {
          if (tagTableRow != "tr") props.role = warnOnOverwrite("useTableRow", "role", props.role, "row");
          return useGridNavigationRowProps(props);
        };

        return {
          useTableCell,
          useTableRowProps,
          ...gridNavRet2
        };
      }, []);
      const useTableBody = q$1(() => {
        debugLog("useTableBody");
        const getIndex = q$1(i => i.index, []);
        const getValue = q$1(i => {
          var _getCurrentSortColumn2, _getCurrentSortColumn3, _cell$subInfo$subInfo, _cell$subInfo$subInfo2;

          const cells = i.subInfo.subInfo.subInfo.getCells();
          const cell = cells.getAt((_getCurrentSortColumn2 = (_getCurrentSortColumn3 = getCurrentSortColumn()) === null || _getCurrentSortColumn3 === void 0 ? void 0 : _getCurrentSortColumn3.index) !== null && _getCurrentSortColumn2 !== void 0 ? _getCurrentSortColumn2 : 0);
          return {
            location: (_cell$subInfo$subInfo = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.location) !== null && _cell$subInfo$subInfo !== void 0 ? _cell$subInfo$subInfo : "head",
            value: (_cell$subInfo$subInfo2 = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.value) !== null && _cell$subInfo$subInfo2 !== void 0 ? _cell$subInfo$subInfo2 : -1
          }; //return cells.getAt(getCurrentSortColumn()?.index ?? 0)?.subInfo.subInfo.subInfo.value ?? null;
        }, []);

        const compare = (lhs, rhs) => {
          var _lhs$value, _rhs$value;

          if (lhs.location === rhs.location) return +((_lhs$value = lhs.value) !== null && _lhs$value !== void 0 ? _lhs$value : -Infinity) - +((_rhs$value = rhs.value) !== null && _rhs$value !== void 0 ? _rhs$value : -Infinity);
          if (lhs.location == 'head') return -1;
          if (lhs.location == 'body') return rhs.location == 'head' ? -1 : 1;
          return 1;
        };

        const {
          useSortableProps,
          ...sortableRet
        } = useSortableChildren({
          rearrangeableChildren: {
            getIndex
          },
          sortableChildren: {
            compare,
            getValue
          }
        });
        const {
          sortableChildren: {
            sort
          },
          rearrangeableChildren: {
            indexDemangler,
            indexMangler
          }
        } = sortableRet;
        s(() => {
          manglers.current.rowIndexDemangler = indexDemangler;
          manglers.current.rowIndexMangler = indexMangler;
        }, [indexDemangler, indexMangler]);
        _(() => {
          bodySort.current = () => {
            var _getCurrentSortColumn4, _getCurrentSortColumn5;

            sort(rows, (_getCurrentSortColumn4 = (_getCurrentSortColumn5 = getCurrentSortColumn()) === null || _getCurrentSortColumn5 === void 0 ? void 0 : _getCurrentSortColumn5.direction) !== null && _getCurrentSortColumn4 !== void 0 ? _getCurrentSortColumn4 : 'ascending');
          };
        }, [sort]);

        const useTableBodyProps = props => {
          console.assert(props.children != null);
          return useSortableProps(props);
        };

        return {
          useTableBodyProps,
          ...sortableRet
        };
      }, []);
      const useTableProps = useGridNavigationProps;
      const useTableSectionProps = q$1((tag, location, props) => {
        if (!(tag == "thead" || tag == "tbody" || tag == "tfoot")) {
          props.role = warnOnOverwrite("useTableSectionProps", "role", props.role, "rowgroup");
        }

        return props;
      }, []);
      return {
        useTableProps,
        useTableBody,
        useTableRow,
        useTableSectionProps,
        ...gridNavRet1
      };
    }

    function identity(t) {
      return t;
    }

    function useGridlist(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      debugLog("useGridlist");
      const [getCurrentSortColumn, setCurrentSortColumn] = usePassiveState(null, returnNull);
      const bodySort = A(null); // TODO: Comparing the location should happen out here, not in each section so that grid navigation works right...

      const manglers = A({
        rowIndexMangler: identity,
        rowIndexDemangler: identity
      });
      const {
        useGridNavigationProps,
        useGridNavigationRow,
        ...gridNavRet1
      } = useGridNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation,
        gridNavigation: {
          rowIndexDemangler: q$1(n => manglers.current.rowIndexDemangler(n), []),
          rowIndexMangler: q$1(n => manglers.current.rowIndexMangler(n), [])
        }
      });
      const {
        managedChildren: {
          children: rows
        }
      } = gridNavRet1;
      const useGridlistRow = q$1(_ref2 => {
        let {
          asChildRowOfSection,
          asParentRowOfCells,
          gridlistRow: {
            locationIndex
          }
        } = _ref2;
        debugLog("useGridlistRow", asChildRowOfSection.managedChild.index);
        const getCells = q$1(() => {
          return cells;
        }, []);
        const {
          useGridNavigationCell,
          useGridNavigationRowProps,
          ...gridNavRet2
        } = useGridNavigationRow({
          asChildRowOfSection: { ...asChildRowOfSection,
            subInfo: {
              getCells,
              locationIndex
            }
          },
          asParentRowOfCells
        });
        const {
          asParentOfCells: {
            managedChildren: {
              children: cells
            }
          }
        } = gridNavRet2;
        const useGridlistChild = q$1(_ref3 => {
          let {
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo,
            hasFocus
          } = _ref3;
          debugLog("useGridlistChild", managedChild.index);
          const {
            useGridNavigationCellProps,
            ...gridNavRet3
          } = useGridNavigationCell({
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo,
            hasFocus
          });

          const useGridlistChildProps = props => {
            props.role = warnOnOverwrite("useGridlistChild", "role", props.role, "cell");
            return useGridNavigationCellProps(props);
          };

          return {
            useGridlistChildProps,
            ...gridNavRet3
          };
        }, []);

        const useGridlistRowProps = props => {
          props.role = warnOnOverwrite("useGridlistRow", "role", props.role, "row");
          return useGridNavigationRowProps(props);
        };

        return {
          useGridlistChild,
          useGridlistRowProps,
          ...gridNavRet2
        };
      }, []);
      const useGridlistSection = q$1(_ref4 => {
        let {
          compareRows
        } = _ref4;
        debugLog("useGridlistSection");
        const getIndex = q$1(i => i.index, []);
        const getValue = q$1(i => {
          var _getCurrentSortColumn, _getCurrentSortColumn2, _cell$subInfo$subInfo, _cell$index;

          const cells = i.subInfo.subInfo.subInfo.getCells();
          const cell = cells.getAt((_getCurrentSortColumn = (_getCurrentSortColumn2 = getCurrentSortColumn()) === null || _getCurrentSortColumn2 === void 0 ? void 0 : _getCurrentSortColumn2.index) !== null && _getCurrentSortColumn !== void 0 ? _getCurrentSortColumn : 0);
          return {
            locationIndex: (_cell$subInfo$subInfo = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.locationIndex) !== null && _cell$subInfo$subInfo !== void 0 ? _cell$subInfo$subInfo : 0,
            index: (_cell$index = cell === null || cell === void 0 ? void 0 : cell.index) !== null && _cell$index !== void 0 ? _cell$index : 0
          };
        }, []);

        const compare = (lhs, rhs) => {
          if (lhs.locationIndex === rhs.locationIndex) return compareRows(lhs.index, rhs.index);
          return lhs.locationIndex - rhs.locationIndex;
        };

        const {
          useSortableProps,
          ...sortableRet
        } = useSortableChildren({
          rearrangeableChildren: {
            getIndex
          },
          sortableChildren: {
            compare,
            getValue
          }
        });
        const {
          sortableChildren: {
            sort
          }
        } = sortableRet;
        _(() => {
          bodySort.current = () => {
            var _getCurrentSortColumn3, _getCurrentSortColumn4;

            sort(rows, (_getCurrentSortColumn3 = (_getCurrentSortColumn4 = getCurrentSortColumn()) === null || _getCurrentSortColumn4 === void 0 ? void 0 : _getCurrentSortColumn4.direction) !== null && _getCurrentSortColumn3 !== void 0 ? _getCurrentSortColumn3 : 'ascending');
          };
        }, [sort]);

        const useGridlistSectionProps = props => {
          console.assert(props.children != null);
          props.role = warnOnOverwrite("useGridlistSection", "role", props.role, "rowgroup");
          return useSortableProps(props);
        };

        return {
          useGridlistSectionProps,
          ...sortableRet
        };
      }, []);

      const useGridlistProps = props => {
        props.role = warnOnOverwrite("useGridlist", "role", props.role, "grid");
        return useGridNavigationProps(props);
      };

      return {
        useGridlistProps,
        useGridlistSection,
        useGridlistRow,
        ...gridNavRet1
      };
    }

    function useToolbar(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation,
        toolbar: {
          orientation
        }
      } = _ref;
      const {
        useListNavigationChild,
        useListNavigationProps,
        ...listRet
      } = useListNavigation({
        linearNavigation: { ...linearNavigation,
          navigationDirection: orientation
        },
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const useToolbarChild = q$1(i => {
        const {
          useListNavigationChildProps,
          ...listRet
        } = useListNavigationChild(i);
        return { ...listRet,
          useToolbarChildProps: useListNavigationChildProps
        };
      }, []);

      function useToolbarProps(p) {
        warnOnOverwrite("useToolbar", "role", p.role, "toolbar");
        return useListNavigationProps(p);
      }

      return { ...listRet,
        useToolbarProps,
        useToolbarChild
      };
    }

    const AccordionSectionContext = B$2(null);
    const Accordion = w(function Accordion(_ref) {
      let {
        disableArrowKeys,
        disableHomeEndKeys,
        expandedIndex,
        initialIndex,
        navigationDirection,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        render
      } = _ref;
      const {
        useAccordionSection,
        ...provider
      } = useAccordion({
        accordion: {
          initialIndex
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      s(() => {
        provider.accordion.changeExpandedIndex(expandedIndex !== null && expandedIndex !== void 0 ? expandedIndex : null);
      }, [expandedIndex]);
      return o$1(AccordionSectionContext.Provider, {
        value: useAccordionSection,
        children: render(provider)
      });
    });
    function defaultRenderAccordionSection(_ref2) {
      let {
        makePropsHeadingContainer,
        makePropsHeadingButton,
        makePropsBody,
        tagBody,
        tagHeadingButton
      } = _ref2;
      return function (info, modifyHeadingButtonProps, modifyBodyProps) {
        return o$1(p$1, {
          children: o$1(Heading, { ...makePropsHeadingContainer(info),
            heading: h$1(tagHeadingButton, modifyHeadingButtonProps(makePropsHeadingButton(info))),
            children: h$1(tagBody, modifyBodyProps(makePropsBody(info)))
          })
        });
      };
    }
    const AccordionSection = w(function AccordionSection(_ref3) {
      let {
        open,
        index,
        tagButton,
        disabled,
        render,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref3;
      const useAccordionSection = x(AccordionSectionContext);
      const {
        useAccordionSectionBodyProps,
        useAccordionSectionHeaderProps,
        ...sectionInfo
      } = useAccordionSection({
        button: {
          disabled,
          tagButton
        },
        accordionSection: {
          open
        },
        managedChildren: {
          index
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return render(sectionInfo, useAccordionSectionHeaderProps, useAccordionSectionBodyProps);
    });

    function defaultRenderButton(tag, makeButtonProps) {
      return function (modifyButtonProps) {
        return h$1(tag, modifyButtonProps(makeButtonProps({})));
      };
    }
    const Button = w(function Button(_ref) {
      let {
        tagButton,
        onPress,
        pressed,
        render,
        disabled,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref;
      const {
        useButtonProps
      } = useButton({
        button: {
          tagButton,
          onPress,
          pressed,
          disabled
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return render(useButtonProps);
    });

    function defaultRenderCheckboxLike(_ref) {
      let {
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      } = _ref;
      return function (info, modifyInputProps, modifyLabelProps) {
        if (labelPosition == "wrapping") {
          const inputPropsBase = makeInputProps(info);
          const labelPropsBase = makeLabelProps(info);
          const inputProps = modifyInputProps(inputPropsBase);
          const {
            children,
            ...labelProps
          } = modifyLabelProps(labelPropsBase);
          const input = h$1(tagInput, inputProps);
          const label = h$1(tagLabel, { ...labelProps,
            children: o$1(p$1, {
              children: [input, children]
            })
          });
          return o$1(p$1, {
            children: label
          });
        } else if (labelPosition == "separate") {
          const inputProps = modifyInputProps(makeInputProps(info));
          const labelProps = modifyLabelProps(makeLabelProps(info));
          const input = h$1(tagInput, inputProps);
          const label = h$1(tagLabel, labelProps);
          return o$1(p$1, {
            children: [input, label]
          });
        } else {
          const userProps = makeInputProps(info);
          console.assert(!!userProps["aria-label"]);
          return h$1(tagInput, modifyInputProps(userProps));
        }
      };
    }
    function defaultRenderCheckbox(_ref2) {
      let {
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      } = _ref2;
      return defaultRenderCheckboxLike({
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      });
    }
    const Checkbox = w(function Checkbox(_ref3) {
      let {
        checked,
        disabled,
        tagLabel,
        labelPosition,
        tagInput,
        onCheckedChange,
        render,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref3;
      const {
        useCheckboxInputElement,
        useCheckboxLabelElement,
        ...checkboxInfo
      } = useCheckbox({
        checkbox: {
          onCheckedChange
        },
        checkboxLike: {
          checked,
          disabled,
          labelPosition
        },
        label: {
          tagInput,
          tagLabel
        },
        hasFocusInput: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        },
        hasFocusLabel: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange: onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount: onMount,
          onUnmount: onUnmount,
          onWindowFocusedChange
        }
      });
      const {
        useCheckboxInputElementProps
      } = useCheckboxInputElement();
      const {
        useCheckboxLabelElementProps
      } = useCheckboxLabelElement();
      return render(checkboxInfo, useCheckboxInputElementProps, useCheckboxLabelElementProps);
    });

    function defaultRenderCheckboxGroupChild(_ref) {
      let {
        tagInput,
        tagLabel,
        labelPosition,
        makeInputProps,
        makeLabelProps
      } = _ref;
      return function (info, modifyInputProps, modifyLabelProps) {
        return defaultRenderCheckboxLike({
          labelPosition,
          tagInput,
          tagLabel,
          makeInputProps,
          makeLabelProps
        })(info, modifyInputProps, modifyLabelProps);
      };
    }
    function defaultRenderCheckboxGroup(_ref2) {
      let {
        children,
        labelPosition,
        makeInputProps,
        makeLabelProps,
        tagInput,
        tagLabel
      } = _ref2;
      return function (info, modifyInputProps, modifyLabelProps) {
        return o$1(p$1, {
          children: [defaultRenderCheckboxLike({
            labelPosition,
            makeInputProps,
            makeLabelProps,
            tagInput,
            tagLabel
          })(info, modifyInputProps, modifyLabelProps), children]
        });
      };
    }
    const UseCheckboxGroupChildContext = B$2(null);
    const CheckboxGroup = w(function CheckboxGroup(_ref3) {
      let {
        disabled: parentDisabled,
        tagInput,
        tagLabel,
        render,
        getDocument,
        getWindow,
        labelPosition,
        initialIndex,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        indexDemangler,
        indexMangler,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender
      } = _ref3;
      const {
        useCheckboxGroupChild,
        useCheckboxGroupParentInput,
        ...checkboxGroupParentInfo
      } = useCheckboxGroup({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useCheckboxGroupParentInputProps,
        useCheckboxGroupParentLabelProps
      } = useCheckboxGroupParentInput({
        checkbox: {},
        checkboxLike: {
          disabled: parentDisabled,
          labelPosition
        },
        label: {
          tagInput,
          tagLabel
        },
        hasFocusInput: {
          getWindow,
          getDocument
        },
        hasFocusLabel: {
          getWindow,
          getDocument
        }
      });
      let wrapping;

      if (labelPosition == "separate") {
        wrapping = render(checkboxGroupParentInfo, useCheckboxGroupParentInputProps, useCheckboxGroupParentLabelProps);
      } else {
        wrapping = render(checkboxGroupParentInfo, useCheckboxGroupParentInputProps, useCheckboxGroupParentLabelProps);
      }

      return o$1(UseCheckboxGroupChildContext.Provider, {
        value: useCheckboxGroupChild,
        children: wrapping
      });
    });
    const CheckboxGroupCheckbox = w(function CheckboxGroupCheckbox(_ref4) {
      let {
        checked,
        disabled,
        index,
        labelPosition,
        tagInput,
        tagLabel,
        text,
        getWindow,
        getDocument,
        flags,
        focusSelf,
        hidden,
        onCheckedChange,
        render
      } = _ref4;
      const {
        useCheckboxGroupChildInputProps,
        useCheckboxGroupChildLabelProps,
        ...checkboxGroupChildInfo
      } = x(UseCheckboxGroupChildContext)({
        asCheckbox: {
          checkbox: {
            onCheckedChange
          },
          checkboxLike: {
            checked,
            disabled,
            labelPosition
          },
          label: {
            tagInput,
            tagLabel
          },
          hasFocusInput: {
            getWindow,
            getDocument
          },
          hasFocusLabel: {
            getWindow,
            getDocument
          }
        },
        asCheckboxGroupChild: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            focusSelf,
            hidden
          }
        }
      });

      if (labelPosition == "separate") {
        return render(checkboxGroupChildInfo, useCheckboxGroupChildInputProps, useCheckboxGroupChildLabelProps);
      } else {
        return render(checkboxGroupChildInfo, useCheckboxGroupChildInputProps, useCheckboxGroupChildLabelProps);
      }
    });

    function defaultRenderPortal(_ref) {
      var _portalRef$current;

      let {
        portalId,
        children
      } = _ref;
      const portalRef = A(null);
      (_portalRef$current = portalRef.current) !== null && _portalRef$current !== void 0 ? _portalRef$current : portalRef.current = document.getElementById(portalId);
      if (portalRef.current) return $(children, portalRef.current);else return children;
    }
    function defaultRenderModal(_ref2) {
      let {
        portalId,
        tagFocusContainer,
        tagBackdrop,
        tagBody,
        tagDialog,
        tagTitle,
        makePropsFocusContainer,
        makePropsBackdrop,
        makePropsBody,
        makePropsDialog,
        makePropsTitle
      } = _ref2;
      return function (dialogInfo, modifyFocusContainerProps, modifyDialogProps, modifyTitleProps, modifyBodyProps, modifyBackdropProps) {
        const {
          children: titleChildren,
          ...titleProps
        } = modifyTitleProps(makePropsTitle(dialogInfo));
        const {
          children: bodyChildren,
          ...bodyProps
        } = modifyBodyProps(makePropsBody(dialogInfo));
        const {
          children: dialogChildren,
          ...dialogProps
        } = modifyDialogProps(makePropsDialog(dialogInfo));
        const {
          children: backdropChildren,
          ...backdropProps
        } = modifyBackdropProps(makePropsBackdrop(dialogInfo));
        const {
          children: focusContainerChildren,
          ...focusContainerProps
        } = modifyFocusContainerProps(makePropsFocusContainer(dialogInfo));
        const title = h$1(tagTitle, titleProps, titleChildren);
        const body = h$1(tagBody, bodyProps, bodyChildren);
        const dialog = h$1(tagDialog, dialogProps, dialogChildren, title, body);
        const backdrop = h$1(tagBackdrop, backdropProps, backdropChildren);
        const focusContainer = h$1(tagFocusContainer, focusContainerProps, o$1("div", {
          children: [focusContainerChildren, dialog, backdrop]
        }));
        return defaultRenderPortal({
          portalId,
          children: focusContainer
        });
      };
    }
    function defaultRenderDialog(_ref3) {
      let {
        portalId,
        tagFocusContainer,
        tagBackdrop,
        tagBody,
        tagDialog,
        tagTitle,
        makePropsFocusContainer,
        makePropsBackdrop,
        makePropsBody,
        makePropsDialog,
        makePropsTitle
      } = _ref3;
      return defaultRenderModal({
        portalId,
        tagFocusContainer,
        tagBackdrop,
        tagBody,
        tagDialog,
        tagTitle,
        makePropsFocusContainer,
        makePropsBackdrop,
        makePropsBody,
        makePropsDialog,
        makePropsTitle
      });
    }
    const Dialog = w(function Dialog(_ref4) {
      let {
        onClose,
        open,
        bodyIsOnlySemantic,
        getDocument,
        getWindow,
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        focusSelf,
        render
      } = _ref4;
      const {
        useDialogBackdrop,
        useDialogBody,
        useDialogProps,
        useDialogTitle,
        useDialogFocusContainerProps,
        ...r
      } = useDialog({
        dialog: {
          onClose
        },
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        softDismiss: {
          open
        },
        activeElement: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onLastActiveElementChange,
          onWindowFocusedChange
        }
      });
      const {
        useDialogTitleProps
      } = useDialogTitle();
      const {
        useDialogBodyProps
      } = useDialogBody();
      const {
        useDialogBackdropProps
      } = useDialogBackdrop();
      return render(r, useDialogFocusContainerProps, useDialogProps, useDialogTitleProps, useDialogBodyProps, useDialogBackdropProps);
    });

    w(function Drawer(_ref2) {
      let {
        render,
        onClose,
        open,
        bodyIsOnlySemantic,
        focusSelf,
        getDocument,
        getWindow,
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange
      } = _ref2;
      const {
        useDrawerBackdrop,
        useDrawerBody,
        useDrawerProps,
        useDrawerTitle,
        useDrawerFocusContainerProps,
        ...drawerInfo
      } = useDrawer({
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        softDismiss: {
          onClose,
          open
        },
        activeElement: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onLastActiveElementChange,
          onWindowFocusedChange
        }
      });
      const {
        useDrawerTitleProps
      } = useDrawerTitle();
      const {
        useDrawerBodyProps
      } = useDrawerBody();
      const {
        useDrawerBackdropProps
      } = useDrawerBackdrop();
      return render(drawerInfo, useDrawerFocusContainerProps, useDrawerProps, useDrawerTitleProps, useDrawerBodyProps, useDrawerBackdropProps);
    });

    const ListboxSingleContext = B$2(null);

    function ListboxSingleU(_ref) {
      let {
        render,
        selectedIndex,
        tagLabel,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        onAllLostFocus,
        onAnyGainedFocus,
        selectionMode,
        tagList,
        onSelect
      } = _ref;
      const {
        useListboxSingleItem,
        useListboxSingleLabel,
        useListboxSingleProps,
        ...listboxReturnType
      } = useListboxSingle({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listboxSingle: {
          tagLabel,
          tagList,
          onSelect
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          onTabbableRender
        },
        singleSelection: {
          selectedIndex,
          selectionMode
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        },
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        }
      });
      const {
        useListboxSingleLabelProps
      } = useListboxSingleLabel(); //const label = createElement(tagLabel, useListboxSingleLabelProps({}) as any);
      //const list = createElement(tagList, useListboxSingleProps({ children: vnodeChildren, ref }) as any);

      return o$1(ListboxSingleContext.Provider, {
        value: useListboxSingleItem,
        children: render({ ...listboxReturnType
        }, useListboxSingleLabelProps, useListboxSingleProps)
      });
    }

    function defaultRenderListboxSingle(_ref2) {
      let {
        makePropsList,
        makePropsLabel,
        tagLabel,
        tagList
      } = _ref2;
      return defaultRenderList({
        makePropsLabel,
        makePropsList,
        tagLabel,
        tagList
      });
    }
    function defaultRenderListboxSingleItem(_ref3) {
      let {
        makePropsListItem,
        tagListItem
      } = _ref3;
      return defaultRenderListItem({
        makePropsListItem,
        tagListItem
      });
    }

    function ListboxSingleItemU(_ref4) {
      let {
        index,
        disabled,
        flags,
        focusSelf,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render,
        text,
        hidden
      } = _ref4;
      const {
        useListboxSingleItemProps,
        rovingTabIndex,
        singleSelection
      } = x(ListboxSingleContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        listboxSingleItem: {
          disabled
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return o$1(p$1, {
        children: render({
          rovingTabIndex,
          singleSelection
        }, useListboxSingleItemProps)
      });
    }

    const ListboxSingle = w(ListboxSingleU);
    const ListboxSingleItem = w(ListboxSingleItemU);
    w(ListboxGroupU);

    function ListboxGroupU(_ref5) {
      let {
        render
      } = _ref5;
      const {
        useListboxGroupHeadingProps,
        useListboxGroupContainerProps
      } = useListboxGroup();
      return render(useListboxGroupContainerProps, useListboxGroupHeadingProps);
    }
    function defaultRenderList(_ref7) {
      let {
        makePropsList,
        makePropsLabel,
        tagLabel,
        tagList
      } = _ref7;
      return function (info, modifyPropsLabel, modifyPropsList) {
        const label = h$1(tagLabel, modifyPropsLabel(makePropsLabel(info)));
        const list = h$1(tagList, modifyPropsList(makePropsList(info)));
        return o$1(p$1, {
          children: [label, list]
        });
      };
    }
    function defaultRenderListItem(_ref8) {
      let {
        makePropsListItem,
        tagListItem
      } = _ref8;
      return function (info, modifyPropsListItem) {
        return h$1(tagListItem, modifyPropsListItem(makePropsListItem(info)));
      };
    }

    const ListboxMultiContext = B$2(null);
    const ListboxMulti = w(function ListboxMulti(_ref) {
      let {
        render,
        tagLabel,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        tagList
      } = _ref;
      const {
        useListboxMultiItem,
        useListboxMultiLabel,
        useListboxMultiProps,
        ...listboxReturnType
      } = useListboxMulti({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listboxMulti: {
          tagLabel,
          tagList
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useListboxMultiLabelProps
      } = useListboxMultiLabel();
      return o$1(ListboxMultiContext.Provider, {
        value: useListboxMultiItem,
        children: render(listboxReturnType, useListboxMultiLabelProps, useListboxMultiProps)
      });
    });
    function defaultRenderListboxMulti(_ref2) {
      let {
        makePropsList,
        makePropsLabel,
        tagLabel,
        tagList
      } = _ref2;
      return defaultRenderList({
        makePropsLabel,
        makePropsList,
        tagLabel,
        tagList
      });
    }
    function defaultRenderListboxMultiItem(_ref3) {
      let {
        makePropsListItem,
        tagListItem
      } = _ref3;
      return defaultRenderListItem({
        makePropsListItem,
        tagListItem
      });
    }
    const ListboxMultiItem = w(function ListboxMultiItem(_ref4) {
      let {
        index,
        disabled,
        flags,
        focusSelf,
        render,
        text,
        hidden,
        selected,
        onSelectedChange,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref4;
      const {
        useListboxMultiItemProps,
        ...itemReturn
      } = x(ListboxMultiContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        listboxMultiItem: {
          disabled,
          selected,
          onSelectedChange
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return o$1(p$1, {
        children: render(itemReturn, useListboxMultiItemProps)
      });
    });

    const MenuItemContext = B$2(null);
    const Menu = w(function Menu(_ref) {
      let {
        initialIndex,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        onOpen,
        onClose,
        open,
        openDirection,
        indexDemangler,
        indexMangler,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        getDocument,
        getWindow,
        render
      } = _ref;
      const {
        useMenuButtonProps,
        useMenuItem,
        useMenuProps,
        useMenuSentinel,
        useMenuSurfaceProps,
        ...menuReturn
      } = useMenu({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        menu: {
          onOpen: useStableCallback(onOpen),
          openDirection
        },
        menuSurface: {},
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        softDismiss: {
          onClose: useStableCallback(onClose),
          open
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        },
        activeElement: {
          getDocument,
          getWindow
        },
        menuButtonHasFocus: {
          getDocument,
          getWindow
        }
      });
      const {
        useMenuSentinelProps: useFirstSentinelProps
      } = useMenuSentinel();
      const {
        useMenuSentinelProps: useLastSentinelProps
      } = useMenuSentinel();
      return o$1(MenuItemContext.Provider, {
        value: useMenuItem,
        children: render(menuReturn, useMenuButtonProps, useMenuSurfaceProps, useMenuProps, useFirstSentinelProps, useLastSentinelProps)
      });
    });
    const MenuItem = w(function MenuItem(_ref2) {
      let {
        render,
        index,
        text,
        hidden,
        flags,
        focusSelf
      } = _ref2;
      const {
        useMenuItemProps,
        ...rest
      } = x(MenuItemContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        }
      });
      return render(rest, useMenuItemProps);
    });
    function defaultRenderMenu(_ref3) {
      let {
        portalId,
        tagButton,
        tagMenu,
        tagSurface,
        tagSentinel,
        makePropsButton,
        makePropsMenu,
        makePropsSurface,
        makePropsSentinel
      } = _ref3;
      return function (menuInfo, modifyMenuButtonProps, modifyMenuSurfaceProps, modifyMenuProps, modifyFirstSentinelProps, modifyLastSentinelProps) {
        const {
          children: surfaceChildren,
          ...surfaceProps
        } = modifyMenuSurfaceProps(makePropsSurface(menuInfo));
        const {
          children: menuChildren,
          ...menuProps
        } = modifyMenuProps(makePropsMenu(menuInfo));
        return o$1(p$1, {
          children: [h$1(tagButton, modifyMenuButtonProps(makePropsButton(menuInfo))), defaultRenderPortal({
            portalId,
            children: h$1(tagSurface, { ...surfaceProps,
              children: o$1(p$1, {
                children: [h$1(tagSentinel, modifyFirstSentinelProps(makePropsSentinel(menuInfo))), surfaceChildren, h$1(tagMenu, { ...menuProps,
                  children: o$1(p$1, {
                    children: menuChildren
                  })
                }), h$1(tagSentinel, modifyLastSentinelProps(makePropsSentinel(menuInfo)))]
              })
            })
          })]
        });
      };
    }
    function defaultRenderMenuItem(_ref4) {
      let {
        makePropsMenuItem: makePropsMenuItem,
        tagMenuItem
      } = _ref4;
      return function (info, modifyMenuItemProps) {
        return h$1(tagMenuItem, modifyMenuItemProps(makePropsMenuItem(info)));
      };
    }

    function defaultRenderRadioGroup(_ref) {
      let {
        tagGroup,
        tagLabel,
        makePropsGroup,
        makePropsLabel
      } = _ref;
      return function (info, modifyLabelProps, modifyGroupProps) {
        return o$1(p$1, {
          children: [h$1(tagLabel, modifyLabelProps(makePropsLabel(info))), h$1(tagGroup, modifyGroupProps(makePropsGroup(info)))]
        });
      };
    }
    const RadioContext = B$2(null);
    const RadioGroup = w(function RadioGroup(_ref2) {
      let {
        render,
        tagGroup,
        tagGroupLabel,
        name,
        onSelectedValueChange,
        selectedValue,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        indexDemangler,
        indexMangler,
        onAllLostFocus,
        onAnyGainedFocus,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender
      } = _ref2;
      const {
        useRadio,
        useRadioGroupLabelProps,
        useRadioGroupProps,
        ...radioGroupReturn
      } = useRadioGroup({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        radioGroup: {
          name,
          onSelectedValueChange,
          selectedValue,
          tagGroup,
          tagGroupLabel
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        },
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        },
        singleSelection: {
          selectionMode: "focus"
        }
      });
      return o$1(RadioContext.Provider, {
        value: useRadio,
        children: render(radioGroupReturn, useRadioGroupLabelProps, useRadioGroupProps)
      });
    });
    function defaultRenderRadio(_ref3) {
      let {
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps,
        labelPosition
      } = _ref3;
      return defaultRenderCheckboxLike({
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      });
    }
    const Radio = w(function Radio(_ref4) {
      let {
        disabled,
        index,
        text,
        hidden,
        tagInput,
        labelPosition,
        tagLabel,
        value,
        render,
        flags,
        focusSelf,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref4;
      const {
        useRadioInput,
        useRadioLabel,
        ...radioReturn
      } = x(RadioContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        radio: {
          disabled,
          labelPosition,
          tagInput,
          tagLabel,
          value
        },
        rovingTabIndex: {
          hidden,
          focusSelf
        },
        hasFocusInput: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        },
        hasFocusLabel: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      const {
        useRadioInputProps
      } = useRadioInput({
        tag: tagInput
      });
      const {
        useRadioLabelProps
      } = useRadioLabel({
        tag: tagLabel
      });
      return render(radioReturn, useRadioInputProps, useRadioLabelProps);
    });

    const SliderThumbContext = B$2(null);
    const Slider = w(function Slider(_ref) {
      let {
        max,
        min,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        children
      } = _ref;
      const {
        useSliderThumb,
        ..._sliderInfo
      } = useSlider({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        slider: {
          max,
          min
        }
      });
      return o$1(SliderThumbContext.Provider, {
        value: useSliderThumb,
        children: children
      });
    });
    const SliderThumb = w(function SliderThumbU(_ref2) {
      let {
        label,
        tag,
        value,
        max,
        min,
        onValueChange,
        index,
        flags,
        render,
        valueText
      } = _ref2;
      const {
        useSliderThumbProps,
        ...sliderInfo
      } = x(SliderThumbContext)({
        managedChild: {
          index,
          flags
        },
        sliderThumb: {
          label,
          tag,
          value,
          max,
          min,
          onValueChange,
          valueText
        }
      });
      return render(sliderInfo, useSliderThumbProps);
    });
    function defaultRenderSliderThumb(_ref3) {
      let {
        tagThumb,
        makePropsThumb
      } = _ref3;
      return function (info, modifyThumbProps) {
        return h$1(tagThumb, modifyThumbProps(makePropsThumb(info)));
      };
    }

    const LocationContext = B$2(null);
    const TableSectionContext = B$2(null);
    const TableBodyContext = B$2(null);
    const TableRowContext = B$2(null);
    const TableCellContext = B$2(null);
    function defaultRenderTable(_ref) {
      let {
        tagTable,
        makePropsTable
      } = _ref;
      return function (info, modifyPropsTable) {
        return h$1(tagTable, modifyPropsTable(makePropsTable(info)));
      };
    }
    function defaultRenderTableBody(_ref2) {
      let {
        tagTableBody,
        makePropsTableBody
      } = _ref2;
      return function (info, modifyPropsTableBody) {
        return h$1(tagTableBody, modifyPropsTableBody(makePropsTableBody(info)));
      };
    }
    function defaultRenderTableHead(_ref3) {
      let {
        tagTableHead,
        makePropsTableHead
      } = _ref3;
      return function (modifyPropsTableHead) {
        return h$1(tagTableHead, modifyPropsTableHead(makePropsTableHead()));
      };
    }
    function defaultRenderTableRow(_ref5) {
      let {
        tagTableRow,
        makePropsTableRow
      } = _ref5;
      return function (info, modifyPropsTableRow) {
        return h$1(tagTableRow, modifyPropsTableRow(makePropsTableRow(info)));
      };
    }
    function defaultRenderTableCell(_ref6) {
      let {
        tagTableCell,
        makePropsTableCell
      } = _ref6;
      return function (info, modifyPropsTableCell) {
        return h$1(tagTableCell, modifyPropsTableCell(makePropsTableCell(info)));
      };
    }
    const Table = w(function TableU(_ref7) {
      let {
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        render
      } = _ref7;
      const {
        useTableBody,
        useTableProps,
        useTableRow,
        useTableSectionProps,
        ...tableInfo
      } = useTable({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys
        },
        listNavigation: {},
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      return o$1(TableSectionContext.Provider, {
        value: useTableSectionProps,
        children: o$1(TableBodyContext.Provider, {
          value: useTableBody,
          children: o$1(TableRowContext.Provider, {
            value: useTableRow,
            children: render(tableInfo, useTableProps)
          })
        })
      });
    });
    const TableBody = w(function TableBodyU(_ref8) {
      let {
        render
      } = _ref8;
      const {
        useTableBodyProps,
        ...sectionInfo
      } = x(TableBodyContext)({});
      return o$1(LocationContext.Provider, {
        value: "body",
        children: render(sectionInfo, useTableBodyProps)
      });
    });
    const TableHead = w(function TableHeadU(_ref9) {
      let {
        render,
        tagTableHead
      } = _ref9;
      const useTableSectionPropsBase = x(TableSectionContext);

      const useTableSectionProps = props => useTableSectionPropsBase(tagTableHead, "head", props);

      return o$1(LocationContext.Provider, {
        value: "head",
        children: render(useTableSectionProps)
      });
    });
    w(function TableFootU(_ref10) {
      let {
        render,
        tagTableFoot
      } = _ref10;
      const useTableSectionPropsBase = x(TableSectionContext);

      const useTableSectionProps = props => useTableSectionPropsBase(tagTableFoot, "foot", props);

      return o$1(LocationContext.Provider, {
        value: "foot",
        children: render(useTableSectionProps)
      });
    });
    const TableRow = w(function TableRowU(_ref11) {
      let {
        index,
        text,
        tagTableRow,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        flags,
        focusSelf,
        hidden,
        indexDemangler,
        indexMangler,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        render
      } = _ref11;
      const {
        useTableCell,
        useTableRowProps,
        ...rowInfo
      } = x(TableRowContext)({
        asChildRowOfSection: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            focusSelf,
            hidden
          },
          subInfo: {}
        },
        asParentRowOfCells: {
          linearNavigation: {
            disableArrowKeys,
            disableHomeEndKeys
          },
          listNavigation: {
            indexDemangler,
            indexMangler
          },
          managedChildren: {
            onAfterChildLayoutEffect,
            onChildrenMountChange
          },
          rovingTabIndex: {
            initialIndex,
            onTabbableIndexChange,
            onTabbableRender
          },
          typeaheadNavigation: {
            collator,
            noTypeahead,
            typeaheadTimeout
          }
        },
        tableRow: {
          location: x(LocationContext),
          tagTableRow
        }
      });
      return o$1(TableCellContext.Provider, {
        value: useTableCell,
        children: render(rowInfo, useTableRowProps)
      });
    });
    const TableCell = w(function TableCell(_ref12) {
      let {
        index,
        text,
        flags,
        focusSelf,
        hidden,
        value,
        headerType,
        tagTableCell,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render
      } = _ref12;
      const {
        useTableCellProps,
        ...cellInfo
      } = x(TableCellContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        },
        subInfo: {
          location: x(LocationContext),
          value
        },
        tableCell: {
          headerType,
          tagTableCell
        }
      });
      return render(cellInfo, useTableCellProps);
    });

    const TabContext = B$2(null);
    const TabPanelContext = B$2(null);
    const Tabs = w(function Tabs(_ref) {
      let {
        selectedIndex,
        selectionMode,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        onAllLostFocus,
        onAnyGainedFocus,
        onSelectedIndexChange,
        render
      } = _ref;
      const {
        useTabList,
        useTabListLabel,
        useTabPanel,
        ...tabsInfo
      } = useTabs({
        tabPanels: {
          managedChildren: {
            onAfterChildLayoutEffect,
            onChildrenMountChange
          }
        }
      });
      const {
        useTab,
        useTabListProps,
        ...tablistInfo
      } = useTabList({
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        },
        tabs: {
          onSelectedIndexChange
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          onTabbableRender
        },
        singleSelection: {
          selectedIndex,
          selectionMode
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useTabListLabelProps
      } = useTabListLabel({});
      return o$1(TabContext.Provider, {
        value: useTab,
        children: o$1(TabPanelContext.Provider, {
          value: useTabPanel,
          children: render({ ...tabsInfo,
            ...tablistInfo
          }, useTabListLabelProps, useTabListProps)
        })
      });
    });
    const Tab = w(function Tab(_ref2) {
      let {
        index,
        text,
        flags,
        focusSelf,
        hidden,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render
      } = _ref2;
      const {
        useTabProps,
        ...tabInfo
      } = x(TabContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return render(tabInfo, useTabProps);
    });
    const TabPanel = w(function TabPanel(_ref3) {
      let {
        index,
        flags,
        render
      } = _ref3;
      const {
        useTabPanelProps,
        ...tabPanelInfo
      } = x(TabPanelContext)({
        managedChild: {
          index,
          flags
        }
      });
      return render(tabPanelInfo, useTabPanelProps);
    });
    function defaultRenderTabs(_ref4) {
      let {
        tagLabel,
        tagList,
        makePropsLabel,
        makePropsList,
        panels
      } = _ref4;
      return function (tabsInfo, modifyLabelProps, modifyListProps) {
        const label = h$1(tagLabel, modifyLabelProps(makePropsLabel(tabsInfo)));
        const list = h$1(tagList, modifyListProps(makePropsList(tabsInfo)));
        return o$1(p$1, {
          children: [label, list, panels]
        });
      };
    }
    function defaultRenderTab(_ref5) {
      let {
        makePropsTab,
        tagTab
      } = _ref5;
      return function (tabInfo, modifyTabProps) {
        return h$1(tagTab, modifyTabProps(makePropsTab(tabInfo)));
      };
    }
    function defaultRenderTabPanel(_ref6) {
      let {
        makePropsTabPanel,
        tagTabPanel
      } = _ref6;
      return function (tabPanelInfo, modifyTabPanelProps) {
        return h$1(tagTabPanel, modifyTabPanelProps(makePropsTabPanel(tabPanelInfo)));
      };
    }

    /*export function defaultRenderToasts({}: {}) {
        return function (args: UseToastsReturnTypeInfo, props: h.JSX.HTMLAttributes<ContainerType>) {
            return (
            <div>

            </div>
            )
        }
    }*/

    const ToastContext = B$2(null);
    const Toasts = w(function Toasts(_ref) {
      let {
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        render,
        visibleCount
      } = _ref;
      const {
        useToast,
        useToastContainerProps,
        ...info
      } = useToasts({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        toasts: {
          visibleCount
        }
      });
      return o$1(ToastContext.Provider, {
        value: useToast,
        children: render(info, useToastContainerProps({}))
      });
    });
    const Toast = w(function Toast(_ref2) {
      let {
        render,
        index,
        timeout,
        flags,
        politeness
      } = _ref2;
      const { ...toastInfo
      } = x(ToastContext)({
        managedChild: {
          index,
          flags
        },
        toast: {
          timeout,
          politeness
        }
      });
      return render(toastInfo);
    });

    function defaultRenderTooltip(_ref) {
      let {
        tagTooltip,
        tagTrigger,
        makeTooltipProps,
        makeTriggerProps,
        portalId
      } = _ref;
      return function (info, modifyPropsTrigger, modifyPropsTooltip) {
        return o$1(p$1, {
          children: [h$1(tagTrigger, modifyPropsTrigger(makeTriggerProps(info))), defaultRenderPortal({
            portalId,
            children: h$1(tagTooltip, modifyPropsTooltip(makeTooltipProps(info)))
          })]
        });
      };
    }
    const Tooltip = w(function TooltipU(_ref2) {
      let {
        focusDelay,
        mouseoutToleranceDelay,
        mouseoverDelay,
        getDocument,
        getWindow,
        render
      } = _ref2;
      const {
        useTooltipPopup,
        useTooltipTrigger,
        ...info
      } = useTooltip({
        focusDelay,
        mouseoutToleranceDelay,
        mouseoverDelay
      });
      const {
        useTooltipTriggerProps
      } = useTooltipTrigger({
        hasFocus: {
          getDocument,
          getWindow
        }
      });
      const {
        useTooltipPopupProps
      } = useTooltipPopup({
        hasFocus: {
          getDocument,
          getWindow
        }
      });
      return render(info, useTooltipTriggerProps, useTooltipPopupProps);
    });

    const LocationIndexContext = B$2(0);
    B$2(null);
    const GridlistSectionContext = B$2(null);
    const GridlistRowContext = B$2(null);
    const GridlistChildContext = B$2(null);
    function defaultRenderGridlist(_ref) {
      let {
        tagGridlist,
        makePropsGridlist
      } = _ref;
      return function (info, modifyPropsGridlist) {
        return h$1(tagGridlist, modifyPropsGridlist(makePropsGridlist(info)));
      };
    }
    function defaultRenderGridlistSection(_ref2) {
      let {
        tagGridlistSection,
        makePropsGridlistSection
      } = _ref2;
      return function (info, modifyPropsGridlistSection) {
        return h$1(tagGridlistSection, modifyPropsGridlistSection(makePropsGridlistSection(info)));
      };
    }
    function defaultRenderGridlistRow(_ref5) {
      let {
        tagGridlistRow,
        makePropsGridlistRow
      } = _ref5;
      return function (info, modifyPropsGridlistRow) {
        return h$1(tagGridlistRow, modifyPropsGridlistRow(makePropsGridlistRow(info)));
      };
    }
    function defaultRenderGridlistChild(_ref6) {
      let {
        tagGridlistChild,
        makePropsGridlistChild
      } = _ref6;
      return function (info, modifyPropsGridlistChild) {
        return h$1(tagGridlistChild, modifyPropsGridlistChild(makePropsGridlistChild(info)));
      };
    }
    const Gridlist = w(function GridlistU(_ref7) {
      let {
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        render
      } = _ref7;
      const {
        useGridlistSection,
        useGridlistProps,
        useGridlistRow,
        ...gridlistInfo
      } = useGridlist({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys
        },
        listNavigation: {},
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      return o$1(GridlistSectionContext.Provider, {
        value: useGridlistSection,
        children: o$1(GridlistRowContext.Provider, {
          value: useGridlistRow,
          children: render(gridlistInfo, useGridlistProps)
        })
      });
    });
    const GridlistSection = w(function GridlistSectionU(_ref8) {
      let {
        render,
        compareRows,
        index
      } = _ref8;
      const {
        useGridlistSectionProps,
        ...sectionInfo
      } = x(GridlistSectionContext)({
        compareRows
      });
      return o$1(LocationIndexContext.Provider, {
        value: index,
        children: render(sectionInfo, useGridlistSectionProps)
      });
    });
    const GridlistRow = w(function GridlistRowU(_ref9, ref) {
      let {
        index,
        text,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        flags,
        focusSelf,
        hidden,
        indexDemangler,
        indexMangler,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        render
      } = _ref9;
      const {
        useGridlistChild,
        useGridlistRowProps,
        ...rowInfo
      } = x(GridlistRowContext)({
        asChildRowOfSection: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            focusSelf,
            hidden
          },
          subInfo: {}
        },
        asParentRowOfCells: {
          linearNavigation: {
            disableArrowKeys,
            disableHomeEndKeys
          },
          listNavigation: {
            indexDemangler,
            indexMangler
          },
          managedChildren: {
            onAfterChildLayoutEffect,
            onChildrenMountChange
          },
          rovingTabIndex: {
            initialIndex,
            onTabbableIndexChange,
            onTabbableRender
          },
          typeaheadNavigation: {
            collator,
            noTypeahead,
            typeaheadTimeout
          }
        },
        gridlistRow: {
          locationIndex: x(LocationIndexContext)
        }
      });
      return o$1(GridlistChildContext.Provider, {
        value: useGridlistChild,
        children: render(rowInfo, useGridlistRowProps)
      });
    });
    const GridlistChild = w(function GridlistChild(_ref10, ref) {
      let {
        index,
        text,
        flags,
        focusSelf,
        hidden,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render
      } = _ref10;
      const {
        useGridlistChildProps,
        ...cellInfo
      } = x(GridlistChildContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        },
        subInfo: {
          locationIndex: x(LocationIndexContext)
        }
      });
      return render(cellInfo, useGridlistChildProps);
    });

    const ToolbarContext = B$2(null);

    function ToolbarU(_ref) {
      let {
        render,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        orientation,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        initialIndex
      } = _ref;
      const {
        useToolbarChild,
        useToolbarProps,
        ...listboxReturnType
      } = useToolbar({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys
        },
        toolbar: {
          orientation
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          onTabbableRender,
          initialIndex
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      return o$1(ToolbarContext.Provider, {
        value: useToolbarChild,
        children: render({ ...listboxReturnType
        }, useToolbarProps)
      });
    }

    function ToolbarChildU(_ref2) {
      let {
        index,
        render,
        flags,
        focusSelf,
        hidden,
        text
      } = _ref2;
      const {
        useToolbarChildProps,
        rovingTabIndex
      } = x(ToolbarContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        subInfo: undefined
      });
      return o$1(p$1, {
        children: render({
          rovingTabIndex
        }, useToolbarChildProps)
      });
    }

    const Toolbar = w(ToolbarU);
    const ToolbarChild = w(ToolbarChildU);
    function defaultRenderToolbar(_ref3) {
      let {
        makePropsContainer,
        tagContainer
      } = _ref3;
      return function (info, modifyPropsContainer) {
        const list = h$1(tagContainer, modifyPropsContainer(makePropsContainer(info)));
        return o$1(p$1, {
          children: list
        });
      };
    }

    function DemoAccordion({ children, ...props }) {
        return o$1(Accordion, { ...props, render: (_info) => { return o$1("div", { id: "accordion-demo", children: children }); } });
    }
    function getDocument$d() {
        return window.document;
    }
    const DemoAccordionSection = w(function DemoAccordionSection({ index, body, heading, disabled, open }) {
        return o$1(AccordionSection, { index: index, tagButton: "button", open: open, disabled: disabled, getDocument: getDocument$d, render: defaultRenderAccordionSection({
                makePropsBody: (info) => { return { hidden: !info.accordionSection.expanded, children: body }; },
                makePropsHeadingButton: () => { return { children: heading }; },
                makePropsHeadingContainer: () => ({}),
                tagBody: "div",
                tagHeadingButton: "button"
            }) });
    });
    function Blurb$f() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/accordion/", children: "In accordance with the ARIA guidelines for Accordion patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["Each section's header and body are linked via ID; the body is ", o$1("code", { children: "labelled-by" }), " the header and the header ", o$1("code", { children: "control" }), "s the body."] }), o$1("li", { children: "The header is a button and responds to keyboard, mouse, touch, etc. events, regardless of the element used." }), o$1("li", { children: ["If the header element is not a ", o$1("code", { children: "<button>" }), " element, it is given that ", o$1("code", { children: "role" }), "."] }), o$1("li", { children: "Up/down & Home/End keys navigate through the list, as does Tab and Shift+Tab" }), o$1("li", {})] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["The ", o$1("code", { children: "render" }), " prop each ", o$1("code", { children: "AccordionSection" }), " takes must wrap the header button with a ", o$1("a", { href: "https://w3c.github.io/aria/#heading", children: "heading" }), " (e.g. ", o$1("code", { children: "h3" }), ", or ", o$1("code", { children: "<Heading>" }), "). See the default implementation for an example."] }) })] }));
    }
    function Code$f() {
        return (o$1("code", { children: `<Accordion render={...}>
    <AccordionSection index={0} render={...} />
    <AccordionSection index={1} render={...} />
    <AccordionSection index={2} render={...} />
</Accordion>` }));
    }
    function Demo$f() {
        const [count, setCount] = y(5);
        return (o$1(p$1, { children: [o$1(Blurb$f, {}), o$1(Code$f, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of accordion sections"] }), o$1(DemoAccordion, { children: o$1(p$1, { children: Array.from((function* () {
                            yield o$1(DemoAccordionSection, { index: 0, heading: "Accordion section #0", body: "Body content #0", disabled: false });
                            yield o$1(DemoAccordionSection, { index: 1, heading: "Accordion section #1", body: "Body content #1", disabled: false });
                            yield o$1(DemoAccordionSection, { index: 2, heading: "Accordion section #2 (disabled)", body: "Body content #2", disabled: true });
                            yield o$1(DemoAccordionSection, { index: 3, heading: "Accordion section #3 (forced open)", body: "Body content #3", disabled: false, open: true });
                            yield o$1(DemoAccordionSection, { index: 4, heading: "Accordion section #4 (forced closed)", body: "Body content #4", disabled: false, open: false });
                            for (let i = 5; i < count; ++i) {
                                yield o$1(DemoAccordionSection, { index: i, heading: `Accordion section #${i}`, body: `BodyContent #${i}`, disabled: false });
                            }
                        })()).slice(0, count) }) })] }));
    }

    function getDocument$c() {
        return window.document;
    }
    function Blurb$e() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/button/", children: "In accordance with the ARIA guidelines for Button patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["Whether using an actual ", o$1("code", { children: "<button>" }), ", or something else like a ", o$1("code", { children: "<div>" }), ", the proper roles and event handlers will be applied."] }), o$1("li", { children: "Buttons can be toggled (pressed or unpressed)." }), o$1("li", { children: ["The button responds to keyboard, mouse, touch, etc. events, regardless of the element used.", o$1("ul", { children: [o$1("li", { children: "Double-clicks do not select text, but text is still selectable without it counting as a press/click" }), o$1("li", { children: "When Enter is pressed, the button is immediately activated" }), o$1("li", { children: "When Space is pressed, the button is activated once released" }), o$1("li", { children: "iOS Safari properly focuses the button" })] })] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["If your button contains only an icon (or other non-descriptive content, etc.), you must provide an ", o$1("code", { children: "aria-label" }), " manually stating what happens when the button is pressed."] }) })] }));
    }
    function Code$e() {
        return (o$1("code", { children: `<Button tag="button">Button</Button>
    <Button tag="div">Div</Button>` }));
    }
    function Demo$e() {
        const [pressed, setPressed] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$e, {}), o$1(Code$e, {}), o$1(DemoButton, { disabled: false, tag: "button" }), o$1(DemoButton, { disabled: "soft", tag: "button" }), o$1(DemoButton, { disabled: "hard", tag: "button" }), o$1(DemoButton, { disabled: false, tag: "div" }), o$1(DemoButton, { disabled: "soft", tag: "div" }), o$1(DemoButton, { disabled: "hard", tag: "div" }), o$1(Button, { getDocument: getDocument$c, disabled: false, tagButton: "button", pressed: pressed, onPress: e => setPressed(e[EventDetail].pressed ?? false), render: defaultRenderButton("button", () => ({ children: `Toggle button (${pressed ? "pressed" : "unpressed"})` })) })] }));
    }
    function DemoButton({ tag, disabled }) {
        const onPress = () => { alert("Button clicked"); };
        return (o$1(Button, { getDocument: getDocument$c, tagButton: tag, onPress: onPress, render: defaultRenderButton(tag, () => ({ class: "btn", children: `${tag} ${disabled ? ` disabled (${disabled == "soft" ? "soft" : "hard"})` : ""}` })) }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <Button disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function Blurb$d() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/checkbox/", children: "In accordance with the ARIA guidelines for Checkbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: "Toggles between checked and unchecked when pressed (clicked, Enter pressed, Space released, etc.)" }), o$1("li", { children: ["Can be ", o$1("code", { children: "mixed" }), " instead, though ", o$1("code", { children: "onInput" }), " will only ever be called with ", o$1("code", { children: "true" }), " or ", o$1("code", { children: "false" })] }), o$1("li", { children: ["Supports using ", o$1("code", { children: "<input>" }), "s and ", o$1("code", { children: "<label>" }), "s, as well as just plain ol' ", o$1("code", { children: "<div>" }), "s on either/both"] }), o$1("li", { children: "The checkbox and label can be sibling elements, like normal, or the label can wrap the input for a larger hit area. In all cases, the appropriate roles/event handlers will be applied to each element." }), o$1("li", { children: "When selecting the text of a checkbox's label, this does not change the checkbox's state" }), o$1("li", { children: "Double-clicking the label checks & un-checks the checkbox instead of selecting the label's text" }), o$1("li", { children: "Checkbox groups (with a tri-state parent) are a separate component/hook" })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", { children: "render" }), " prop and setting ", o$1("code", { children: "labelPosition" }), " to be \"separate\"), you must pass ", o$1("code", { children: "aria-label" }), " as a prop to the checkbox manually. Not providing one will print an error to the console, but it it not required by the type system."] }) })] }));
    }
    function Code$d() {
        return (o$1("code", { children: `<Checkbox checked={true} labelPosition="separate" tagInput="input" tagLabel="label">Label text</Checkbox>` }));
    }
    function Demo$d() {
        const [checked, setChecked] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$d, {}), o$1(Code$d, {}), o$1(Button, { tagButton: "button", getDocument: getDocument$b, onPress: () => { setChecked("mixed"); }, render: defaultRenderButton("button", () => ({ children: "Change to mixed" })) }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "separate", disabled: false, tagInput: "input", tagLabel: "label" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "wrapping", disabled: false, tagInput: "input", tagLabel: "label" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "separate", disabled: false, tagInput: "div", tagLabel: "label" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "wrapping", disabled: false, tagInput: "div", tagLabel: "label" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "separate", disabled: false, tagInput: "input", tagLabel: "div" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "wrapping", disabled: false, tagInput: "input", tagLabel: "div" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "separate", disabled: false, tagInput: "div", tagLabel: "div" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "wrapping", disabled: false, tagInput: "div", tagLabel: "div" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "hidden", disabled: false, tagInput: "input", tagLabel: "label" })] }));
    }
    function DemoCheckbox$1({ labelPosition, tagInput, tagLabel, disabled, checked, setChecked }) {
        //const [checked, setChecked] = useState(false);
        return (o$1("div", { style: { border: "1px solid black" }, children: [o$1(Checkbox, { getDocument: getDocument$b, disabled: disabled, checked: checked, onCheckedChange: e => setChecked(e[EventDetail].checked), labelPosition: labelPosition == "hidden" ? "separate" : labelPosition, tagInput: tagInput, tagLabel: tagLabel, render: defaultRenderCheckbox({
                        labelPosition,
                        tagInput,
                        tagLabel,
                        makeInputProps: () => ({ "aria-label": labelPosition == "hidden" ? `Hidden label (technically separate), ${tagInput} and ${tagLabel} ${checked ? "checked" : "not checked"}` : undefined, }),
                        makeLabelProps: () => ({ children: `${labelPosition}, ${tagInput} and ${tagLabel}, ${checked ? "checked" : "not checked"}` })
                    }) }), labelPosition == "hidden" && o$1("div", { children: ["(This is not a label -- the actual label is via the ", o$1("code", { children: "aria-label" }), " prop)"] })] }));
    }
    function getDocument$b() {
        return window.document;
    }

    function getDocument$a() {
        return window.document;
    }
    function DemoCheckbox({ index }) {
        const [checked, setChecked] = useState(false);
        const labelText = `Checkbox #${index}`;
        return (o$1(CheckboxGroupCheckbox, { render: defaultRenderCheckboxGroupChild({
                labelPosition: "separate",
                tagInput: "input",
                tagLabel: "label",
                makeInputProps: () => ({}),
                makeLabelProps: () => ({ children: labelText })
            }), getDocument: getDocument$a, checked: checked, index: index, disabled: false, labelPosition: "separate", text: labelText, tagInput: "input", tagLabel: "label", onCheckedChange: e => setChecked(e[EventDetail].checked) }));
    }
    function Blurb$c() {
        return (o$1(p$1, { children: [o$1("p", { children: ["Checkbox groups are an alternative to multi-select lists. There is no role of ", o$1("code", { children: "checkboxgroup" }), ", but this aims to be an ARIA-compliant implementation of a checkbox group."] }), o$1("ul", { children: [o$1("li", { children: ["All normal ", o$1("code", { children: "Checkbox" }), " functionality is supported on each individual checkbox."] }), o$1("li", { children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"." }), o$1("li", { children: ["The parent checkbox reacts to each child's ", o$1("code", { children: "checked" }), " prop and updates its own internal ", o$1("code", { children: "checked" }), " attribute (be aware of this if they're asyncronous, as you'll want to ensure they all resolve on the same tick with ", o$1("code", { children: "Promise.all" }), " to not clobber the user's inputs)."] }), o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["It is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", { children: "role=group" }), " that references that label by overriding ", o$1("code", { children: "render" }), "."] }), o$1("li", { children: ["See the caveat above for when each child's ", o$1("code", { children: "onInput" }), " takes a variable amount of time to actually update the ", o$1("code", { children: "checked" }), " prop, as it can clobber the user's last input when clicking on the parent"] })] })] }));
    }
    function Code$c() {
        return (o$1("code", { children: `` }));
    }
    function Demo$c() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$c, {}), o$1(Code$c, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of checkboxes"] }), o$1("div", { children: o$1(CheckboxGroup, { getDocument: getDocument$a, disabled: false, labelPosition: "separate", tagInput: "input", tagLabel: "label", render: defaultRenderCheckboxGroup({
                            labelPosition: "separate",
                            tagInput: "input",
                            tagLabel: "label",
                            makeInputProps: () => ({}),
                            makeLabelProps: () => ({ children: "Group checkbox parent" }),
                            children: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield o$1("div", { children: o$1(DemoCheckbox, { index: i }, i) });
                                }
                            })())
                        }) }) })] }));
    }

    function getDocument$9() {
        return window.document;
    }
    const DemoListItem$3 = w(function DemoListItem({ index }) {
        const [selected, setSelected] = useState(false);
        const labelText = `List item #${index}${selected ? " (selected)" : ""}`;
        return (o$1(ListboxMultiItem, { getDocument: getDocument$9, selected: selected, index: index, disabled: false, text: labelText, onSelectedChange: e => { setSelected(e[EventDetail].selected); }, render: defaultRenderListboxMultiItem({ tagListItem: "li", makePropsListItem: () => ({ children: labelText }) }) }));
    });
    function Blurb$b() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"." }), o$1("li", { children: ["The parent checkbox reacts to each child's ", o$1("code", { children: "checked" }), " prop and updates its own internal ", o$1("code", { children: "checked" }), " attribute (be aware of this if they're asyncronous, as you'll want to ensure they all resolve on the same tick with ", o$1("code", { children: "Promise.all" }), " to not clobber the user's inputs)."] }), o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "Grouping is supported" }), o$1("li", { children: "Sorting/reordering is supported, though not provided by default, as it's mutually exclusive with grouping." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["It is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", { children: "role=group" }), " that references that label by overriding ", o$1("code", { children: "render" }), "."] }), o$1("li", { children: ["See the caveat above for when each child's ", o$1("code", { children: "onInput" }), " takes a variable amount of time to actually update the ", o$1("code", { children: "checked" }), " prop, as it can clobber the user's last input when clicking on the parent"] })] })] }));
    }
    function Code$b() {
        return (o$1("code", { children: `` }));
    }
    function Demo$b() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$b, {}), o$1(Code$b, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of list items"] }), o$1("div", { children: o$1(ListboxMulti, { tagLabel: "label", tagList: "ul", render: defaultRenderListboxMulti({
                            tagLabel: "label", tagList: "ul", makePropsLabel: () => ({}), makePropsList: () => ({
                                children: Array.from((function* () {
                                    for (let i = 0; i < count; ++i) {
                                        yield o$1(DemoListItem$3, { index: i }, i);
                                    }
                                })())
                            })
                        }) }) })] }));
    }

    function getDocument$8() { return window.document; }
    const DemoListItem$2 = w(function DemoListItem({ index }) {
        return (o$1(ListboxSingleItem, { index: index, getDocument: getDocument$8, disabled: false, text: `List item #${index}`, render: defaultRenderListboxSingleItem({ tagListItem: "li", makePropsListItem: ({ singleSelection: { selected } }) => ({ children: `List item #${index}${selected ? " (selected)" : ""}` }) }) }));
    });
    function Blurb$a() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["In terms of keyboard navigation and tabbing through elements, a Listbox is considered a ", o$1("strong", { children: "single" }), " tab stop; in other words, no matter how many list items there are in a Listbox, it only takes one press of the Tab button to go through it.", o$1("ul", { children: [o$1("li", { children: "When a Listbox is tabbed into, the most recently selected item is given focus" }), o$1("li", { children: "Pressing Tab again navigates out of the listbox; no other list items are tabbable other than the one currently designated." }), o$1("li", { children: "Pressing the arrow keys navigates through the Listbox one item at a time" }), o$1("li", { children: "Pressing the Home/End keys move focus to the first/last items respectively" }), o$1("li", { children: "Typing any sequence of text starts typeahead that navigates to the next item that matches what's being typed" }), o$1("li", { children: "Focus & selection management is as optimized as possible; only two children re-render at a time when focus or selection changes" }), o$1("li", { children: "These apply generally to all composite components with a variable number of children (Tab Lists, Radio Groups, Multi-Select Listboxes etc.)" })] })] }), o$1("li", { children: ["Rather than each individual list item knowing whether it is selected or not (as with multi-select lists), here the parent knows the ", o$1("code", { children: "selectedIndex" }), " and simply notifies the (max two) relevant children any time it changes."] }), o$1("li", { children: "Grouping is supported" }), o$1("li", { children: "Sorting/reordering is supported, though not provided by default, as it's mutually exclusive with grouping." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "Listboxes do not support interactive content within them (e.g. a dropdown menu), as ARIA specifies that this is a different pattern." }) })] }));
    }
    function Code$a() {
        return (o$1("code", { children: `` }));
    }
    function Demo$a() {
        const [selectedIndex, setSelectedIndex] = useState(null);
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$a, {}), o$1(Code$a, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of list items"] }), o$1("div", { children: o$1(ListboxSingle, { render: defaultRenderListboxSingle({
                            tagLabel: "label", tagList: "ol", makePropsLabel: () => ({}), makePropsList: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1(DemoListItem$2, { index: i }, i);
                                        }
                                    })()) })
                            })
                        }), selectionMode: "activation", tagLabel: "label", tagList: "ol", selectedIndex: selectedIndex, onSelect: e => setSelectedIndex(e[EventDetail].selectedIndex) }) })] }));
    }

    function DemoListItem$1({ index }) {
        return (o$1(MenuItem, { index: index, text: `List item #${index}`, render: defaultRenderMenuItem({ tagMenuItem: "li", makePropsMenuItem: () => ({ children: `Menu item #${index}` }) }) }));
    }
    function getDocument$7() { return window.document; }
    function Blurb$9() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it." }), o$1("li", { children: "When the menu is closed because another element on the page was focused instead, focus will not be modified." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code$9() {
        return (o$1("code", { children: `` }));
    }
    function Demo$9() {
        const [count, setCount] = useState(5);
        const [open, setOpen] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$9, {}), o$1(Code$9, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of menu items"] }), o$1("div", { children: o$1(Menu, { getDocument: getDocument$7, onOpen: () => setOpen(true), onClose: () => setOpen(false), open: open, openDirection: "down", render: defaultRenderMenu({
                            tagButton: "button",
                            tagMenu: "ul",
                            tagSentinel: "div",
                            tagSurface: "div",
                            portalId: "portal",
                            makePropsButton: () => ({ children: "Open menu" + (open ? " (open)" : " (closed)") }),
                            makePropsMenu: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1("div", { children: o$1(DemoListItem$1, { index: i }, i) });
                                        }
                                    })()) })
                            }),
                            makePropsSurface: () => ({ style: { display: !open ? "none" : undefined } }),
                            makePropsSentinel: () => ({}),
                        }) }) })] }));
    }

    function getDocument$6() {
        return window.document;
    }
    const DemoRadioButton = w(function DemoRadioButton({ index }) {
        const value = `Radio button #${index}`;
        return (o$1(Radio, { index: index, getDocument: getDocument$6, disabled: false, labelPosition: "separate", text: value, value: index, tagInput: "input", tagLabel: "label", render: defaultRenderRadio({
                labelPosition: "separate",
                tagInput: "input",
                tagLabel: "label",
                makeInputProps: () => ({ name: "radio-demo" }),
                makeLabelProps: () => ({ children: value })
            }) }));
    });
    function Blurb$8() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/radiobutton/", children: "In accordance with the ARIA guidelines for Radio Button patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "The input & label support the same text-selection affordances as Checkboxes (labels can be selected, but double-clicking doesn't select the text and selecting text doesn't count as an input)" }), o$1("li", { children: "Selection state is handled by the parent; instead of specifying whether any given radio button is checked or not, the parent notifies each child of the necessary changes." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", { children: "render" }), " prop and setting ", o$1("code", { children: "labelPosition" }), " to be \"separate\"), you must pass ", o$1("code", { children: "aria-label" }), " as a prop to the checkbox manually. Not providing one will print an error to the console, but it it not required by the type system."] }), o$1("li", { children: ["The above also applies to the radio group as a whole; ARIA requires that all Radio Buttons be contained within an element with a specific role which is labelled either by an element (handled for you) or ", o$1("code", { children: "aria-label" }), " (specified by you manually on the input)."] })] })] }));
    }
    function Code$8() {
        return (o$1("code", { children: `` }));
    }
    function Demo$8() {
        const [selectedIndex, setSelectedIndex] = useState(null);
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$8, {}), o$1(Code$8, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of radio buttons"] }), o$1("div", { children: o$1(RadioGroup, { name: "radio-demo", onSelectedValueChange: e => setSelectedIndex(e[EventDetail].selectedValue ?? 0), selectedValue: selectedIndex, tagGroupLabel: "label", tagGroup: "div", render: defaultRenderRadioGroup({
                            tagGroup: "div",
                            tagLabel: "label",
                            makePropsGroup: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1(DemoRadioButton, { index: i }, i);
                                        }
                                    })()) })
                            }),
                            makePropsLabel: (info) => ({ children: "Radio group example " + "(" + info.radioGroup.selectedIndex?.toString() + ")" })
                        }) }) })] }));
    }

    function DemoSliderThumb({ index }) {
        const [value, setValue] = useState(0);
        return (o$1(SliderThumb, { index: index, tag: "input", label: `Slider thumb #${index}`, value: value, onValueChange: e => setValue(e[EventDetail].value), min: 0, max: 10, render: defaultRenderSliderThumb({ tagThumb: "input", makePropsThumb: () => ({}) }) }));
    }
    function Blurb$7() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it." }), o$1("li", { children: "When the menu is closed because another element on the page was focused instead, focus will not be modified." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code$7() {
        return (o$1("code", { children: `` }));
    }
    function Demo$7() {
        const [count, setCount] = useState(5);
        useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$7, {}), o$1(Code$7, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of slider thumbs"] }), o$1("div", { children: o$1(Slider, { min: 0, max: 10, children: o$1(p$1, { children: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield o$1("div", { children: o$1(DemoSliderThumb, { index: i }, i) });
                                }
                            })()) }) }) })] }));
    }

    function getDocument$5() { return window.document; }
    function Blurb$6() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/dialogmodal/", children: "In accordance with the ARIA guidelines for Modal Dialog patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: "Dialogs block all other elements on the page from receiving focus/interaction and being perceivable to screen readers." }), o$1("li", { children: "Dialogs can be dismissed by pressing Escape or clicking the element designated as the backdrop, both of which can be cancelled/ignored if you need" }), o$1("li", { children: "When opened, the dialog will focus its title or body content as appropriate, however read below under Things Not Handled for caveats." }), o$1("li", { children: "When closed for any reason, the element that was responsible for opening the dialog will be focused." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["By default, when opened, a dialog will focus its body content or title content depending on ", o$1("code", { children: "bodyIsOnlySemantic" }), ", which indicates that the dialog's body contains no interactive elements. This may not be suitable for all situations."] }), o$1("li", { children: ["It is ", o$1("em", { children: "hightly" }), " recommended to override ", o$1("code", { children: "focusSelf" }), " for all dialogs you create, and have it focus whatever element makes the most sense for your particular dialog.", o$1("ul", { children: [o$1("li", { children: "Dialogs that act like a form should focus the first interactive element" }), o$1("li", { children: "Dialogs that perform destructive actions should focus the \"Cancel\" button" }), o$1("li", { children: "In some cases, it's best to focus the first paragraph of the body." })] }), "In all cases, consider that the first focused element will both be how keyboard users interact with the dialog, but also the first thing a screen reader will read aloud."] })] })] }));
    }
    function Code$6() {
        return (o$1("code", { children: `` }));
    }
    function Demo$6() {
        const [open, setOpen] = useState(false);
        q$1((...args) => { console.log(...args); }, []);
        return (o$1(p$1, { children: [o$1(Blurb$6, {}), o$1(Code$6, {}), o$1("div", { children: [o$1(Button, { tagButton: "button", getDocument: getDocument$5, onPress: () => setOpen(true), render: defaultRenderButton("button", () => ({ children: "Open dialog " + (open ? "(open)" : "(closed)") })) }), o$1(Dialog, { getDocument: getDocument$5, onClose: () => setOpen(false), open: open, bodyIsOnlySemantic: true, render: defaultRenderDialog({
                                portalId: "portal",
                                makePropsBackdrop: () => ({ "data-type": "backdrop" }),
                                makePropsFocusContainer: () => ({ "data-type": "focus" }),
                                makePropsBody: () => ({ children: "Dialog body", "data-type": "body" }),
                                makePropsDialog: () => ({ style: { display: !open ? "none" : undefined }, "data-type": "dialog" }),
                                makePropsTitle: () => ({ children: "Dialog title", "data-type": "title" }),
                                tagBackdrop: "div",
                                tagBody: "div",
                                tagDialog: "div",
                                tagTitle: "div",
                                tagFocusContainer: "div"
                            }) })] })] }));
    }

    function getDocument$4() { return window.document; }
    function Blurb$5() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/tabpanel/", children: "In accordance with the ARIA guidelines for Tab and Tab Panel patterns," }), " this widget supports the following:"] }), o$1("ul", { children: o$1("li", { children: ["The tabs are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }) }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code$5() {
        return (o$1("code", { children: `` }));
    }
    function Demo$5() {
        const [count, setCount] = useState(5);
        const [selectedIndex, setSelectedIndex] = useState(0);
        return (o$1(p$1, { children: [o$1(Blurb$5, {}), o$1(Code$5, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of tabs"] }), o$1("div", { children: o$1(Tabs, { selectedIndex: selectedIndex, selectionMode: "focus", onSelectedIndexChange: e => setSelectedIndex(e[EventDetail].selectedIndex), render: defaultRenderTabs({
                            panels: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield o$1(DemoTabPanel, { i: i });
                                }
                            })()),
                            tagLabel: "label",
                            tagList: "ul",
                            makePropsLabel: () => ({ children: "Tabs example" }),
                            makePropsList: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1(DemoTab, { i: i });
                                        }
                                    })()) })
                            })
                        }) }) })] }));
    }
    const DemoTab = w(function DemoTab({ i }) {
        const label = `Tab #${i}`;
        return o$1(Tab, { index: i, getDocument: getDocument$4, render: defaultRenderTab({ tagTab: "li", makePropsTab: () => ({ children: label }) }), text: label }, i);
    });
    const DemoTabPanel = w(function DemoTabPanel({ i }) {
        const label = `Tab panel #${i}`;
        return o$1(TabPanel, { index: i, render: defaultRenderTabPanel({ tagTabPanel: "div", makePropsTabPanel: ({ tabPanel: { visible } }) => ({ hidden: !visible, children: label }) }) }, i);
    });

    function getDocument$3() { return window.document; }
    function Blurb$4() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/tooltip/", children: "Tooltips have yet to be well defined in many areas" }), ", but this implementation aims to support common use cases:"] }), o$1("ul", { children: [o$1("li", { children: "Hovering or focusing the trigger element shows the tooltip" }), o$1("li", { children: "The tooltip stays shown when it itself is hovered/focused as well, so that the text inside can be selected" }), o$1("li", { children: "Moving the mouse between the trigger and the tooltip has some tolerance associated with immediately hiding the tooltip." }), o$1("li", { children: "Hovering, focusing, and re-hovering can each have a custom delay associated with it" })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["You must ensure that either the tooltip contains a focusable element (a button, link, ", o$1("code", { children: "<div tabIndex=\"-1\" />" }), ", etc.)"] }), o$1("li", { children: "Long presses on mobile devices are not yet handled (e.g. a long press on a button triggers a tooltip but does not activate the button)" })] })] }));
    }
    function Code$4() {
        return (o$1("code", { children: `` }));
    }
    function Demo$4() {
        return (o$1(p$1, { children: [o$1(Blurb$4, {}), o$1(Code$4, {}), o$1("div", { children: ["The following text triggers a tooltip: ", o$1(Tooltip, { getDocument: getDocument$3, render: defaultRenderTooltip({
                                portalId: "portal",
                                makeTooltipProps: ({ isOpen }) => ({ children: "This text describes the triggering text in more detail.", style: { opacity: +isOpen } }),
                                makeTriggerProps: () => ({ children: "Tooltip-triggering text that is hoverable and focusable:", tabIndex: 0 }),
                                tagTooltip: "div",
                                tagTrigger: "span"
                            }) })] })] }));
    }

    function Blurb$3() {
        return (o$1(p$1, { children: [o$1("p", { children: o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/alert/", children: "Toasts (aka snackbars) are implemented using the Alert pattern." }) }), o$1("ul", { children: [o$1("li", { children: "Pushing a toasts causes its contents to be shown visibly (and audibly with a screen reader)" }), o$1("li", { children: "Only new toasts are announced" }), o$1("li", { children: "Toasts are shown as soon as they are pushed, but you can control the maximum number shown at once with" }), o$1("li", { children: "Toasts can be dismissed in any order" }), o$1("li", { children: "Toasts can be set to auto-dismiss." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: "Auto-dismiss behavior is very situational. An auto-dismissed toast should only refer to information that can be viewed elsewhere; \"X files deleted\" can be double-checked in the Recycle Bin, \"X has logged in\" which you can along with everyone else in a tab somewhere, etc. This obviously cannot be checked programmatically." }), o$1("li", { children: "TODO: Focus management related to toasts that have interactive content" }), o$1("li", { children: "TODO: Toasts are still announced even when the current browser tab is hidden instead of saving them for when the user returns" }), o$1("li", { children: "TODO: Toasts still auto-dismiss when they have focus/are being interacted with" })] })] }));
    }
    function Code$3() {
        return (o$1("code", { children: `` }));
    }
    function Demo$3() {
        const currentIndex = A(0);
        const [toasts, setToasts] = useState([]);
        const pushToast = q$1(() => {
            const index = currentIndex.current;
            currentIndex.current += 1;
            setToasts(t => [...t, o$1(Toast, { index: index, render: ({ toast: { dismiss, showing, dismissed, numberOfToastsAheadOfUs } }) => (o$1("div", { style: showing ? {} : { opacity: 0.5 }, children: ["This the toast with an index of ", index, ". (#", numberOfToastsAheadOfUs, " in the queue to be shown). ", o$1("button", { disabled: dismissed, onClick: dismiss, children: "Click to dismiss" })] })), timeout: null }, index)]);
        }, []);
        return (o$1(p$1, { children: [o$1(Blurb$3, {}), o$1(Code$3, {}), o$1("button", { onClick: pushToast, children: "Push a toast" }), o$1("div", { children: o$1(Toasts, { visibleCount: 3, render: (info, props) => { return o$1("div", { ...props, children: toasts }); } }) })] }));
    }

    function getDocument$2() { return window.document; }
    function Blurb$2() {
        return (o$1(p$1, { children: [o$1("p", { children: ["This is an implementation of an interactive data table that complies with ", o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/table/", children: "the ARIA guidelines for Table patterns" }), "."] }), o$1("ul", { children: [o$1("li", { children: ["In terms of keyboard navigation and tabbing through elements, a Table is considered a ", o$1("strong", { children: "single" }), " tab stop; in other words, no matter how many cells there are in a table (including if the cells contain interactive elements), it only takes one press of the Tab button to go through it.", o$1("ul", { children: [o$1("li", { children: ["Pressing the arrow keys navigates through the cells of the Table. You can override each cell's ", o$1("code", { children: "focusSelf" }), " prop to handle child elements."] }), o$1("li", { children: "Most other rules of list navigation apply (as in Listboxes), but in two dimensions." })] })] }), o$1("li", { children: ["The body rows are sortable via each cell's ", o$1("code", { children: "value" }), " prop. As a result of this, each row must be a ", o$1("em", { children: "direct" }), " child of the body, like as a normal array of children with no intervening JSX."] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["If you don't need all the sorting and focus management and such, there's no reason not to just use the good old ", o$1("code", { children: "<table>" }), " element."] }), o$1("li", { children: ["It's up to you to make sure that any interactive elements within a table cell respond to focus management properly with the aforementioned ", o$1("code", { children: "focusSelf" }), " prop and a properly placed ", o$1("code", { children: ["tabIndex=", "{", "info.rovingTabIndex.tabbable? 0 : -1", "}"] }), " in the ", o$1("code", { children: "render" }), " prop."] })] })] }));
    }
    function Code$2() {
        return (o$1("code", { children: `` }));
    }
    function DemoInput({ tabbable }) {
        const [v, setV] = useState("");
        return (o$1("input", { type: "text", tabIndex: tabbable ? 0 : -1, onInput: q$1((e) => {
                setV(e.currentTarget.value);
                e.preventDefault();
            }, []), value: v }));
    }
    function DemoTableCell({ index, header }) {
        const r = A(Math.random());
        if (header) {
            const text = `Header #${index}`;
            return o$1(TableCell, { headerType: "column", tagTableCell: "th", index: index, getDocument: getDocument$2, text: text, value: text, render: defaultRenderTableCell({ tagTableCell: "th", makePropsTableCell: (info) => ({ children: o$1("button", { tabIndex: info.rovingTabIndex.tabbable ? 0 : -1, onClick: () => info.tableHeaderCell.sort(), children: text }) }) }) });
        }
        else {
            switch (index) {
                case 0:
                    return o$1(TableCell, { headerType: null, tagTableCell: "td", index: index, getDocument: getDocument$2, text: "", value: "", render: defaultRenderTableCell({
                            tagTableCell: "td", makePropsTableCell: (info) => ({
                                children: o$1(DemoInput, { tabbable: info.rovingTabIndex.tabbable })
                            })
                        }) });
                default:
                    return o$1(TableCell, { headerType: null, tagTableCell: "td", index: index, getDocument: getDocument$2, text: r.current.toString(), value: r.current.toString(), render: defaultRenderTableCell({ tagTableCell: "td", makePropsTableCell: () => ({ children: r.current.toString() }) }) });
            }
        }
    }
    function Demo$2() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$2, {}), o$1(Code$2, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of table rows"] }), o$1("div", { children: o$1(Table, { noTypeahead: true, render: defaultRenderTable({
                            tagTable: "table",
                            makePropsTable: () => ({
                                children: o$1(p$1, { children: [o$1(TableHead, { tagTableHead: "thead", render: defaultRenderTableHead({
                                                tagTableHead: "thead",
                                                makePropsTableHead: () => ({
                                                    children: o$1(TableRow, { tagTableRow: "tr", noTypeahead: true, index: 0, text: "", render: defaultRenderTableRow({
                                                            tagTableRow: "tr",
                                                            makePropsTableRow: () => ({
                                                                children: o$1(p$1, { children: [o$1(DemoTableCell, { index: 0, header: true }, 0), o$1(DemoTableCell, { index: 1, header: true }, 1), o$1(DemoTableCell, { index: 2, header: true }, 2)] })
                                                            })
                                                        }) })
                                                })
                                            }) }), o$1(TableBody, { render: defaultRenderTableBody({
                                                tagTableBody: "tbody",
                                                makePropsTableBody: () => ({
                                                    children: Array.from(function* () {
                                                        for (let i = 0; i < count; ++i) {
                                                            yield o$1(TableRow, { tagTableRow: "tr", noTypeahead: true, index: i + 1, text: "", render: defaultRenderTableRow({
                                                                    tagTableRow: "tr",
                                                                    makePropsTableRow: () => ({
                                                                        children: o$1(p$1, { children: [o$1(DemoTableCell, { index: 0 }, 0), o$1(DemoTableCell, { index: 1 }, 1), o$1(DemoTableCell, { index: 2 }, 2)] })
                                                                    })
                                                                }) }, i);
                                                        }
                                                    }())
                                                })
                                            }) })] })
                            })
                        }) }) })] }));
    }

    function getDocument$1() { return window.document; }
    function Blurb$1() {
        return (o$1(p$1, { children: [o$1("p", { children: ["Because Listboxes are not allowed to contain interactive content, a Gridlist is semantically a list that ", o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/grid/", children: "complies with the ARIA pattern for grids" }), "."] }), o$1("ul", { children: [o$1("li", { children: "In terms of keyboard navigation and tabbing through elements, a Gridlist is like a Listbox, but in two dimensions, like a Table." }), o$1("li", { children: "The rows of a Gridlist are sortable. It is possible to have multiple, independently sortable sections within the same Gridlist." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["It's up to you to make sure that any interactive elements within a Gridlist respond to focus management properly with ", o$1("code", { children: "focusSelf" }), " prop and a properly placed ", o$1("code", { children: ["tabIndex=", "{", "info.rovingTabIndex.tabbable? 0 : -1", "}"] }), " in the ", o$1("code", { children: "render" }), " prop."] }), o$1("li", { children: "Any given row in a Gridlist can be marked as selected, but this is up to you to handle manually at the moment" })] })] }));
    }
    function Code$1() {
        return (o$1("code", { children: `` }));
    }
    function DemoGridlistChild1({ row }) {
        const text = "Gridlist child " + row;
        return o$1(GridlistChild, { getDocument: getDocument$1, index: 0, locationIndex: 0, text: text, render: defaultRenderGridlistChild({ tagGridlistChild: "div", makePropsGridlistChild: (info) => ({ children: text }) }) });
    }
    function DemoGridlistChild2() {
        const ref = A(null);
        const [b, setB] = useState(false);
        return o$1(GridlistChild, { focusSelf: () => ref.current?.focus(), getDocument: getDocument$1, index: 1, locationIndex: 0, text: b.toString(), render: defaultRenderGridlistChild({ tagGridlistChild: "div", makePropsGridlistChild: (info) => ({ children: o$1("input", { ref: ref, type: "checkbox", tabIndex: info.rovingTabIndex.tabbable ? 0 : -1, checked: b, onInput: e => setB(e.currentTarget.checked) }) }) }) });
    }
    function Demo$1() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$1, {}), o$1(Code$1, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of table rows"] }), o$1("div", { children: o$1(Gridlist, { initialIndex: 0, render: defaultRenderGridlist({
                            tagGridlist: "div", makePropsGridlist: (info) => ({
                                children: o$1(GridlistSection, { index: 0, compareRows: (lhs, rhs) => lhs - rhs, render: defaultRenderGridlistSection({
                                        tagGridlistSection: "div", makePropsGridlistSection: (info) => ({
                                            children: Array.from(function* () {
                                                for (let i = 0; i < count; ++i) {
                                                    yield o$1(GridlistRow, { index: i, text: "", render: defaultRenderGridlistRow({
                                                            tagGridlistRow: "div", makePropsGridlistRow: (info) => ({
                                                                children: [o$1(DemoGridlistChild1, { row: i }), o$1(DemoGridlistChild2, {})]
                                                            })
                                                        }) });
                                                }
                                            }())
                                        })
                                    }) })
                            })
                        }) }) })] }));
    }

    function getDocument() { return window.document; }
    const DemoListItem = w(function DemoListItem({ index }) {
        return (o$1(ToolbarChild, { index: index, text: `List item #${index}`, render: ({ rovingTabIndex: { tabbable } }, modifyProps) => {
                return o$1(Button, { getDocument: getDocument, tagButton: "button", render: defaultRenderButton("button", () => modifyProps({ "data-tabbable": tabbable.toString(), children: `Button #${index}` })) });
            } }));
    });
    function Blurb() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/toolbar/", children: "In accordance with the ARIA guidelines for Toolbar patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: "A Toolbar is a single widget for the purposes of keyboard navigation, like a Listbox." }), o$1("li", { children: "Toolbars are well-suited for \"button group\" patterns as well. Multiple groups can be contained within a single Toolbar, even multiple different types of components." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["You must label the Toolbar with ", o$1("code", { children: "aria-label" }), "."] }) })] }));
    }
    function Code() {
        return (o$1("code", { children: `` }));
    }
    function Demo() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb, {}), o$1(Code, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of list items"] }), o$1("div", { children: o$1(Toolbar, { orientation: "horizontal", render: defaultRenderToolbar({
                            tagContainer: "div",
                            makePropsContainer: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1(DemoListItem, { index: i }, i);
                                        }
                                    })()) })
                            })
                        }) }) })] }));
    }

    //import { options } from "preact";
    //options.debounceRendering = queueMicrotask;
    //const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const Component = () => {
        return (o$1(Heading, { heading: "Demos", children: [o$1(Heading, { heading: "Toolbar", children: o$1(Demo, {}) }), o$1(Heading, { heading: "Dialog", children: o$1(Demo$6, {}) }), o$1(Heading, { heading: "Gridlist", children: o$1(Demo$1, {}) }), o$1(Heading, { heading: "Table", children: o$1(Demo$2, {}) }), o$1(Heading, { heading: "Toast", children: o$1(Demo$3, {}) }), o$1(Heading, { heading: "Tooltip", children: o$1(Demo$4, {}) }), o$1(Heading, { heading: "Tabs", children: o$1(Demo$5, {}) }), o$1(Heading, { heading: "Slider", children: o$1(Demo$7, {}) }), o$1(Heading, { heading: "Single-select Listbox", children: o$1(Demo$a, {}) }), o$1(Heading, { heading: "Accordion", children: o$1(Demo$f, {}) }), o$1(Heading, { heading: "Button", children: o$1(Demo$e, {}) }), o$1(Heading, { heading: "Checkbox", children: o$1(Demo$d, {}) }), o$1(Heading, { heading: "Checkbox Group", children: o$1(Demo$c, {}) }), o$1(Heading, { heading: "Multi-select Listbox", children: o$1(Demo$b, {}) }), o$1(Heading, { heading: "Menu", children: o$1(Demo$9, {}) }), o$1(Heading, { heading: "Radio", children: o$1(Demo$8, {}) })] }));
    };
    requestAnimationFrame(() => {
        P$1(o$1(Component, {}), document.getElementById("root"));
    });

})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyIuLi9zcmMvY29tcG9uZW50L2hlYWRpbmcudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1wYXNzaXZlLXN0YXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtYWN0aXZlLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1zdGFibGUtY2FsbGJhY2sudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1hbmltYXRpb24tZnJhbWUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXN0YXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtY2hpbGQtbWFuYWdlci50c3giLCIuLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZG9jdW1lbnQtY2xhc3MudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtY2xhc3Nlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1yZWZzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbWVyZ2VkLXN0eWxlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1wcm9wcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXJlZi1lbGVtZW50LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZXZlbnQtaGFuZGxlci50c3giLCIuLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvc3JjL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3dpY2ctaW5lcnQvZGlzdC9pbmVydC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ibG9ja2luZy1lbGVtZW50cy9zcmMvYmxvY2tpbmctZWxlbWVudHMudHMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWJsb2NraW5nLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1mb2N1cy10cmFwLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZm9yY2UtdXBkYXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtaGFzLWZvY3VzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtcHJlc3MudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS10aW1lb3V0LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXJvdmluZy10YWJpbmRleC50c3giLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUmFuZG9tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2h1ZmZsZVNlbGYuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVGltZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2h1ZmZsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc2h1ZmZsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Utc29ydGFibGUtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1saXN0LW5hdmlnYXRpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1ncmlkLW5hdmlnYXRpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1yYW5kb20taWQudHN4IiwiLi4vc3JjL3VzZS1idXR0b24udHMiLCIuLi9zcmMvdXNlLWFjY29yZGlvbi50c3giLCIuLi9zcmMvdXNlLWxhYmVsLnRzIiwiLi4vc3JjL3VzZS1jaGVja2JveC1ncm91cC50cyIsIi4uL3NyYy91c2UtbW9kYWwudHMiLCIuLi9zcmMvdXNlLWRyYXdlci50cyIsIi4uL3NyYy91c2UtbGlzdGJveC1zaW5nbGUudHMiLCIuLi9zcmMvdXNlLWxpc3Rib3gtbXVsdGkudHMiLCIuLi9zcmMvdXNlLW1lbnUudHMiLCIuLi9zcmMvdXNlLXRhYnMudHMiLCIuLi9zcmMvdXNlLXRvb2x0aXAudHMiLCIuLi9zcmMvdXNlLXJhZGlvLWdyb3VwLnRzeCIsIi4uL3NyYy91c2UtdG9hc3RzLnRzeCIsIi4uL3NyYy91c2UtdGFibGUudHN4IiwiLi4vc3JjL3VzZS1ncmlkbGlzdC50c3giLCIuLi9zcmMvdXNlLXRvb2xiYXIudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9hY2NvcmRpb24udHN4IiwiLi4vc3JjL2NvbXBvbmVudC9jaGVja2JveC50c3giLCIuLi9zcmMvY29tcG9uZW50L2NoZWNrYm94LWdyb3VwLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvZGlhbG9nLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvbGlzdGJveC1zaW5nbGUudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9tZW51LnRzeCIsIi4uL3NyYy9jb21wb25lbnQvcmFkaW8tZ3JvdXAudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9zbGlkZXIudHN4IiwiLi4vc3JjL2NvbXBvbmVudC90YWJsZS50c3giLCIuLi9zcmMvY29tcG9uZW50L3RhYnMudHN4IiwiLi4vc3JjL2NvbXBvbmVudC90b29sdGlwLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvZ3JpZGxpc3QudHN4IiwiLi4vc3JjL2NvbXBvbmVudC90b29sYmFyLnRzeCIsImRlbW9zL2FjY29yZGlvbi50c3giLCJkZW1vcy9idXR0b24udHN4IiwiZGVtb3MvY2hlY2tib3gudHN4IiwiZGVtb3MvY2hlY2tib3gtZ3JvdXAudHN4IiwiZGVtb3MvbGlzdGJveC1tdWx0aS50c3giLCJkZW1vcy9saXN0Ym94LXNpbmdsZS50c3giLCJkZW1vcy9tZW51LnRzeCIsImRlbW9zL3JhZGlvLnRzeCIsImRlbW9zL3NsaWRlci50c3giLCJkZW1vcy9kaWFsb2cudHN4IiwiZGVtb3MvdGFicy50c3giLCJkZW1vcy90b29sdGlwLnRzeCIsImRlbW9zL3RvYXN0LnRzeCIsImRlbW9zL3RhYmxlLnRzeCIsImRlbW9zL2dyaWRsaXN0LnRzeCIsImRlbW9zL3Rvb2xiYXIudHN4IiwiaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCB3YXJuT25PdmVyd3JpdGUgfSBmcm9tIFwiLi4vcHJvcHNcIjtcclxuXHJcbmNvbnN0IEhlYWRpbmdMZXZlbENvbnRleHQgPSBjcmVhdGVDb250ZXh0KDApO1xyXG5cclxuZXhwb3J0IGNvbnN0IEhlYWRpbmcgPSBtZW1vKGZ1bmN0aW9uIEhlYWRpbmc8VCBleHRlbmRzIEVsZW1lbnQ+KHsgY2hpbGRyZW4sIGhlYWRpbmcsIC4uLnByb3BzIH06IHsgaGVhZGluZzogQ29tcG9uZW50Q2hpbGRyZW4gfSAmIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KSB7XHJcbiAgICBjb25zdCBoZWFkaW5nTGV2ZWxCZWZvcmVVcyA9IHVzZUNvbnRleHQoSGVhZGluZ0xldmVsQ29udGV4dCk7XHJcbiAgICBjb25zdCBuZXdIZWFkaW5nTGV2ZWwgPSBoZWFkaW5nTGV2ZWxCZWZvcmVVcyArIDE7XHJcbiAgICBsZXQgdGFnOiBzdHJpbmc7XHJcbiAgICBpZiAobmV3SGVhZGluZ0xldmVsIDw9IDYpIHtcclxuICAgICAgICB0YWcgPSBgaCR7bmV3SGVhZGluZ0xldmVsfWA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0YWcgPSAnZGl2JztcclxuICAgICAgICBwcm9wc1tcImFyaWEtbGV2ZWxcIl0gPSB3YXJuT25PdmVyd3JpdGUoXCJIZWFkaW5nXCIsIFwiYXJpYS1sZXZlbFwiLCBwcm9wc1tcImFyaWEtbGV2ZWxcIl0sIGAke25ld0hlYWRpbmdMZXZlbH1gKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxIZWFkaW5nUmVzZXQgbmV3TGV2ZWw9e2hlYWRpbmdMZXZlbEJlZm9yZVVzICsgMX0+XHJcbiAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWcgYXMgYW55LCBwcm9wcywgaGVhZGluZyl9XHJcbiAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgICAgIDwvSGVhZGluZ1Jlc2V0PlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59KVxyXG5cclxuZXhwb3J0IGNvbnN0IEhlYWRpbmdSZXNldCA9IG1lbW8oZnVuY3Rpb24gSGVhZGluZ1Jlc2V0KHsgbmV3TGV2ZWwsIGNoaWxkcmVuIH06IHsgbmV3TGV2ZWw6IG51bWJlciwgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEhlYWRpbmdMZXZlbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e25ld0xldmVsfT5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvSGVhZGluZ0xldmVsQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIClcclxufSlcclxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gXCJwcmVhY3RcIlxuXG5leHBvcnQgdHlwZSBQYXNzaXZlU3RhdGVVcGRhdGVyPFM+ID0gKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VD4gPSAoKHZhbHVlOiBULCBwcmV2VmFsdWU6IFQgfCB1bmRlZmluZWQpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSk7XG5cbi8qKlxuICogRGVidWcgaG9vay5cbiAqIFxuICogR2l2ZW4gYSB2YWx1ZSBvciBzZXQgb2YgdmFsdWVzLCBlbWl0cyBhIGNvbnNvbGUgZXJyb3IgaWYgYW55IG9mIHRoZW0gY2hhbmdlIGZyb20gb25lIHJlbmRlciB0byB0aGUgbmV4dC5cbiAqIFxuICogRXZlbnR1YWxseSwgd2hlbiB1c2VFdmVudCBsYW5kcywgd2UgaG9wZWZ1bGx5IHdvbid0IG5lZWQgdGhpcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVuc3VyZVN0YWJpbGl0eTxUIGV4dGVuZHMgYW55W10+KHBhcmVudEhvb2tOYW1lOiBzdHJpbmcsIC4uLnZhbHVlczogVCkge1xuICAgIHVzZUhlbHBlcih2YWx1ZXMubGVuZ3RoLCAwKTtcbiAgICB2YWx1ZXMuZm9yRWFjaCh1c2VIZWxwZXIpO1xuICAgIHJldHVybjtcblxuXG4gICAgZnVuY3Rpb24gdXNlSGVscGVyPFU+KHZhbHVlOiBVLCBpbmRleDogbnVtYmVyKSB7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBhcmUgcGVyZmVjdGx5IHN0YWJsZSBhY3Jvc3MgcmVuZGVyc1xuICAgICAgICBjb25zdCBoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eSA9IHVzZVJlZih2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHNob3duRXJyb3IgPSB1c2VSZWYoZmFsc2UpO1xuICAgICAgICBpZiAoaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkuY3VycmVudCAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFzaG93bkVycm9yLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZSBob29rICR7cGFyZW50SG9va05hbWV9IHJlcXVpcmVzIHNvbWUgb3IgYWxsIG9mIGl0cyBhcmd1bWVudHMgcmVtYWluIHN0YWJsZSBhY3Jvc3MgZWFjaCByZW5kZXI7IHBsZWFzZSBjaGVjayB0aGUgJHtpbmRleH0taW5kZXhlZCBhcmd1bWVudC5gKTtcbiAgICAgICAgICAgICAgICBzaG93bkVycm9yLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2VSZW5kZXJpbmcoZjogKCkgPT4gdm9pZCkge1xuICAgIChvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID8/IHNldFRpbWVvdXQpKGYpO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYHVzZVN0YXRlYCwgYnV0IGZvciB2YWx1ZXMgdGhhdCBhcmVuJ3QgXCJyZW5kZXItaW1wb3J0YW50XCIgJm5kYXNoOyB1cGRhdGVzIGRvbid0IGNhdXNlIGEgcmUtcmVuZGVyIGFuZCBzbyB0aGUgdmFsdWUgc2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHJlbmRlciAodGhvdWdoIGl0IGNlcnRhaW5seSBjYW4sIGF0IGxlYXN0IGJ5IHJlLXJlbmRlcmluZyBhZ2FpbikuXG4gKiBcbiAqIFRvIGNvbXBlbnNhdGUgZm9yIHRoaXMsIHlvdSBzaG91bGQgcGFzcyBhIGB1c2VFZmZlY3RgLWVzcXVlIGNhbGxiYWNrIHRoYXQgaXMgcnVuIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSnVzdCBsaWtlIGB1c2VFZmZlY3RgLCB0aGlzIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQncyBydW4gYmVmb3JlIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgKG9yLCBzYXksIHdoZW4gdGhlIHZhbHVlIG1lZXRzIHNvbWUgY3JpdGVyaWEpLCB0aGlzIGlzIHdoZXJlIHlvdSdsbCB3YW50IHRvIHB1dCBpbiBhIGNhbGwgdG8gYSBgc2V0U3RhdGVgIGZ1bmN0aW9uLlxuICogXG4gKiBUbyBzdW1tYXJpemUsIGl0J3MgbGlrZSBhIGB1c2VTdGF0ZWAtYHVzZUVmZmVjdGAgbWFzaHVwOlxuICogXG4gKiAxLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHRoaXMgdmVyc2lvbiBvZiBgc2V0U3RhdGVgIGRvZXNuJ3QgcmUtcmVuZGVyIHRoZSB3aG9sZSBjb21wb25lbnRcbiAqIDIuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgeW91IGNhbiBydW4gYSBmdW5jdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIHRoYXQgb3B0aW9uYWxseSByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvblxuICogMy4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgeW91IHRyaWdnZXIgdGhlIGVmZmVjdCBmdW5jdGlvbiBcInJlbW90ZWx5XCIgaW5zdGVhZCBvZiBpdCBydW5uaW5nIGFmdGVyIHJlbmRlcmluZ1xuICogNC4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgdGhlIHNpbmdsZSBcImRlcGVuZGVuY3lcIiBpcyBiYXNlZCBvbiB5b3VyIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAqIFxuICogTm90ZSB0aGF0IHdoaWxlIGNhbGxpbmcgYHNldFN0YXRlYCBkb2Vzbid0IGNhdXNlIGFueSByZS1yZW5kZXJzLCB5b3UgY2FuIGRvIHRoYXQgd2l0aGluIHlvdXIgYG9uQ2hhbmdlYCBmdW5jdGlvbiwgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzIHZpYSB0aGF0IGBzZXRTdGF0ZWAuXG4gKiBcbiAqIEBwYXJhbSBvbkNoYW5nZSBUaGUgXCJlZmZlY3RcIiBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYHVzZUVmZmVjdGAncyBcImVmZmVjdFwiIGZ1bmN0aW9uLiAgTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBnZXRJbml0aWFsVmFsdWUgSWYgcHJvdmlkZWQsIHRoZSBlZmZlY3Qgd2lsbCBiZSBpbnZva2VkIG9uY2Ugd2l0aCB0aGlzIHZhbHVlIG9uIG1vdW50LiBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHBhcmFtIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIEJ5IGRlZmF1bHQsIGNoYW5nZXMgdG8gcGFzc2l2ZSBzdGF0ZSBhcmUgZGVsYXllZCBieSBvbmUgdGljayBzbyB0aGF0IHdlIG9ubHkgY2hlY2sgZm9yIGNoYW5nZXMgaW4gYSBzaW1pbGFyIHdheSB0byBQcmVhY3QuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyB0bywgZm9yIGV4YW1wbGUsIGFsd2F5cyBydW4gaW1tZWRpYXRlbHkgaW5zdGVhZC5cbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFzc2l2ZVN0YXRlPFQ+KG9uQ2hhbmdlOiB1bmRlZmluZWQgfCBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VD4sIGdldEluaXRpYWxWYWx1ZT86ICgpID0+IFQsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nPzogdHlwZW9mIGRlYm91bmNlUmVuZGVyaW5nKTogcmVhZG9ubHkgW2dldFN0YXRlU3RhYmxlOiAoKSA9PiBULCBzZXRTdGF0ZVN0YWJsZTogUGFzc2l2ZVN0YXRlVXBkYXRlcjxUPl0ge1xuXG4gICAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWY8VCB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGNsZWFudXBDYWxsYmFja1JlZiA9IHVzZVJlZjx1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk+KHVuZGVmaW5lZCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUGFzc2l2ZVN0YXRlXCIsIG9uQ2hhbmdlLCBnZXRJbml0aWFsVmFsdWUsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIFwiZGVwZW5kZW5jeSBjaGFuZ2VkXCIgYW5kIFwiY29tcG9uZW50IHVubW91bnRlZFwiLlxuICAgIGNvbnN0IG9uU2hvdWxkQ2xlYW5VcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cENhbGxiYWNrID0gY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChjbGVhbnVwQ2FsbGJhY2spXG4gICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2soKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGVyZSBhcmUgYSBjb3VwbGUgcGxhY2VzIHdoZXJlIHdlJ2QgbGlrZSB0byB1c2Ugb3VyIGluaXRpYWxcbiAgICAvLyB2YWx1ZSBpbiBwbGFjZSBvZiBoYXZpbmcgbm8gdmFsdWUgYXQgYWxsIHlldC5cbiAgICAvLyBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZSBmb3IgdGhhdCwgdXNlZCBvbiBtb3VudCBhbmQgd2hlbmV2ZXJcbiAgICAvLyBnZXRWYWx1ZSBpcyBjYWxsZWQuXG4gICAgY29uc3QgdHJ5RW5zdXJlVmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCAmJiBnZXRJbml0aWFsVmFsdWUgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldEluaXRpYWxWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/Lihpbml0aWFsVmFsdWUsIHVuZGVmaW5lZCkgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIC8vIEV4Y2VwdGlvbnMgYXJlIGludGVudGlvbmFsIHRvIGFsbG93IGJhaWxvdXQgKHdpdGhvdXQgZXhwb3NpbmcgdGhlIFVuc2V0IHN5bWJvbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFsvKiBnZXRJbml0aWFsVmFsdWUgYW5kIG9uQ2hhbmdlIGludGVudGlvbmFsbHkgb21pdHRlZCAqL10pO1xuXG5cbiAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHdhcm5pbmdSZWYuY3VycmVudClcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkR1cmluZyBvbkNoYW5nZSwgcHJlZmVyIHVzaW5nIHRoZSAodmFsdWUsIHByZXZWYWx1ZSkgYXJndW1lbnRzIGluc3RlYWQgb2YgZ2V0VmFsdWUgLS0gaXQncyBhbWJpZ3VvdXMgYXMgdG8gaWYgeW91J3JlIGFza2luZyBmb3IgdGhlIG9sZCBvciBuZXcgdmFsdWUgYXQgdGhpcyBwb2ludCBpbiB0aW1lIGZvciB0aGlzIGNvbXBvbmVudC5cIik7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2UgY2FsbCBnZXRWYWx1ZSwgaWYgd2UgaGF2ZW4ndCBiZWVuIGdpdmVuIGEgdmFsdWUgeWV0LFxuICAgICAgICAvLyAoYW5kIHdlIHdlcmUgZ2l2ZW4gYW4gaW5pdGlhbCB2YWx1ZSB0byB1c2UpXG4gICAgICAgIC8vIHJldHVybiB0aGUgaW5pdGlhbCB2YWx1ZSBpbnN0ZWFkIG9mIG5vdGhpbmcuXG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldClcbiAgICAgICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cbiAgICAgICAgcmV0dXJuICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCEgOiB2YWx1ZVJlZi5jdXJyZW50ISkgYXMgVDtcbiAgICB9LCBbXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UndmUgcnVuIG91ciBlZmZlY3QgYXQgbGVhc3Qgb25jZSBvbiBtb3VudC5cbiAgICAgICAgLy8gKElmIHdlIGhhdmUgYW4gaW5pdGlhbCB2YWx1ZSwgb2YgY291cnNlKVxuICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuXG5cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBUaGUgYWN0dWFsIGNvZGUgdGhlIHVzZXIgY2FsbHMgdG8gKHBvc3NpYmx5KSBydW4gYSBuZXcgZWZmZWN0LlxuICAgIGNvbnN0IHIgPSB1c2VSZWYoeyBwcmV2RGVwOiBVbnNldCBhcyBUIHwgKHR5cGVvZiBVbnNldCkgfSk7XG4gICAgY29uc3Qgc2V0VmFsdWUgPSB1c2VDYWxsYmFjazxQYXNzaXZlU3RhdGVVcGRhdGVyPFQ+PigoYXJnKSA9PiB7XG5cbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiBhbnl0aGluZyBlbHNlLCBmaWd1cmUgb3V0IHdoYXQgb3VyIG5leHQgdmFsdWUgaXMgYWJvdXQgdG8gYmUuXG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IChhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCA6IHZhbHVlUmVmLmN1cnJlbnQpIDogYXJnKTtcblxuXG4gICAgICAgIGlmIChyLmN1cnJlbnQucHJldkRlcCA9PT0gVW5zZXQgJiYgbmV4dFZhbHVlICE9PSB2YWx1ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByZXF1ZXN0IHRvIGNoYW5nZSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgLy8gRXZhbHVhdGUgdGhlIHJlcXVlc3QgaW1tZWRpYXRlbHksIHRoZW4gcXVldWUgdXAgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uXG5cbiAgICAgICAgICAgIC8vIFNhdmUgb3VyIGN1cnJlbnQgdmFsdWUgc28gdGhhdCB3ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGl0IGxhdGVyXG4gICAgICAgICAgICAvLyAoaWYgd2UgZmxpcCBiYWNrIHRvIHRoaXMgc3RhdGUsIHRoZW4gd2Ugd29uJ3Qgc2VuZCB0aGUgb25DaGFuZ2UgZnVuY3Rpb24pXG4gICAgICAgICAgICByLmN1cnJlbnQucHJldkRlcCA9IHZhbHVlUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHVwZGF0ZSB0aGlzIGhlcmUgKGFzIHdlbGwgYXMgYmVsb3cpIGluIGNhc2UgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgaW52b2tlcyB0aGlzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgYWN0dWFsIGNoZWNrIGFuZCBpbnZvY2F0aW9uIG9mIG9uQ2hhbmdlIGxhdGVyIHRvIGxldCBlZmZlY3RzIHNldHRsZVxuICAgICAgICAgICAgKGN1c3RvbURlYm91bmNlUmVuZGVyaW5nID8/IGRlYm91bmNlUmVuZGVyaW5nKSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dERlcCA9IHZhbHVlUmVmLmN1cnJlbnQhIGFzIFQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkRlcCA9IHIuY3VycmVudC5wcmV2RGVwIDtcbiAgICAgICAgICAgICAgICBpZiAoci5jdXJyZW50LnByZXZEZXAgIT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGFueSByZWdpc3RlcmVkIGNsZWFudXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvdWxkQ2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/LihuZXh0RGVwLCBwcmV2RGVwID09PSBVbnNldD8gdW5kZWZpbmVkIDogcHJldkRlcCkgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0RGVwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gbm9ybWFsbHkgY2FsbCBnZXRWYWx1ZSBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGZpbmlzaGVkIHdpdGggZXZlcnl0aGluZywgc28gbWFyayB1cyBhcyBiZWluZyBvbiBhIGNsZWFuIHNsYXRlIGFnYWluLlxuICAgICAgICAgICAgICAgIHIuY3VycmVudC5wcmV2RGVwID0gVW5zZXQ7XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2YWx1ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNoZWNrZWQgYWdhaW5zdCBwcmV2RGVwIHRvIHNlZSBpZiB3ZSBzaG91bGQgYWN0dWFsbHkgY2FsbCBvbkNoYW5nZVxuICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtnZXRWYWx1ZSwgc2V0VmFsdWVdIGFzIGNvbnN0O1xufVxuXG5jb25zdCBVbnNldCA9IFN5bWJvbCgpO1xuXG4vLyBFYXN5IGNvbnN0YW50cyBmb3IgZ2V0SW5pdGlhbFZhbHVlXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHsgcmV0dXJuIHRydWU7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuTnVsbCgpIHsgcmV0dXJuIG51bGw7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5VbmRlZmluZWQoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5aZXJvKCkgeyByZXR1cm4gMDsgfSIsIlxuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgcmV0dXJuVHJ1ZSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuXG5cbi8qKlxuICogXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCBkaWZmZXJlbnQgd2F5cyB0aGF0IGEgZm9jdXMgZXZlbnQgY2FuIGhhcHBlbi4gIEFzc3VtZVxuICogdGhlIGZvbGxvd2luZyBzdGVwcyBoYXBwZW4gaW4gb3JkZXI6XG4gKiBcbiAqIDEuIFRoZSBwYWdlIGxvYWRzLlxuICogICAgKiBOb3RoaW5nIGlzIGZvY3VzZWQsIGJ1dCBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYGJvZHlgLiBcbiAqICAgICogTm8gZm9jdXMgZXZlbnRzIGFyZSBmaXJlZC5cbiAqIDIuIFRoZSB3aW5kb3cgaXMgZm9jdXNlZCwgYW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgcmVtYWlucyBhcyBgYm9keWAuXG4gKiAgICAqIEEgYGZvY3VzYC9gZm9jdXNpbmAgZXZlbnQgKk1JR0hUKiBiZSBmaXJlZCBmb3IgYGJvZHlgLiBEZXBlbmRpbmcgb25cbiAqICAgICAgdGhlIGJyb3dzZXIsIHRoaXMgZGVwZW5kcyBvbiB3aGV0aGVyIHRoZSBoYW5kbGVyIHdhcyBhdHRhY2hlZCB0byBgd2luZG93YCBvciBgZG9jdW1lbnRgLlxuICogICAgICBQcm9iYWJseSBqdXN0IGJlc3QgdG8gbm90IHJlbHkgb24gaXQsIG9yIGxpc3RlbiB0byBgd2luZG93YCBmb2N1cyBldmVudHMgZGlyZWN0bHkuXG4gKiAzLiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gdGhlIG5ldyBlbGVtZW50IGJlZm9yZSBhbnkgZXZlbnQgZXZlbiBmaXJlcy5cbiAqICAgICogYGZvY3Vzb3V0YCBhbmQgYGJsdXJgIGFyZSAqbm90KiBmaXJlZCBvbiBgYm9keWAuXG4gKiAgICAqIGBmb2N1c2AgYW5kIGBmb2N1c2luYCBhcmUgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cbiAqIDQuIEEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgZXRjLlxuICogICAgKiAqKlRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBgYm9keWAqKiBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG5ldyBlbGVtZW50LlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIG5vdyBzZXQgdG8gdGhlIG5ldyBlbGVtZW50LlxuICogICAgKiBgZm9jdXNpbmAgaXMgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG9sZCBlbGVtZW50LlxuICogNS4gQW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIGBib2R5YC5cbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxuICogICAgKiBgZm9jdXNpbmAgaXMgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxuICogXG4gKiBcbiAqIEluIHN1bW1hcnk6XG4gKiAxLiBGb2N1cyBldmVudHMgKmRvKiBub3RpZnkgdXMgb2YgYWxsIGNoYW5nZXMgaW4gZm9jdXMsIGJ1dCB0aGVyZSBpcyBubyBvbmUgc2luZ2xlIGNvbXByZWhlbnNpdmUgZXZlbnQgdGhhdCBwcm92aWRlcyB1cyB3aXRoIGFsbCBhdmFpbGFibGUgaW5mb3JtYXRpb24uXG4gKiAyLiBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgKmlzIG5vdCogYWx3YXlzIHRoZSBzYW1lIGFzIHdoYXQncyBiZWluZyByZWZlcmVuY2VkIGJ5IGEgZm9jdXMgZXZlbnQuIEluIHBhcnRpY3VsYXIsIGl0IG1heSBiZWNvbWUgYGJvZHlgIGF0IGFueSBhcmJpdHJhcnkgdGltZS5cbiAqIDMuIEEgYGJsdXJgIHdpdGhvdXQgYSBgZm9jdXNgIGNhbiBhbmQgd2lsbCBvY2N1ci4gVGhpcyBtZWFucyBpdCBpcyBub3QgcG9zc2libGUgdG8gc29sZWx5IHVzZSBgZm9jdXNgIHRvIGRldGVjdCBhbGwgY2hhbmdlcy5cbiAqIDQuIEEgYGJsdXJgIGV2ZW50IHdob3NlIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsIGluZGljYXRlcyB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gZm9sbG93aW5nIGBmb2N1c2AgZXZlbnQuXG4gKiBcbiAqL1xuY29uc3QgX2R1bW15ID0gMDtcblxuaW50ZXJmYWNlIEZvbzxUPiB7XG4gICAgbGFzdFNlbnQ6IFQgfCB1bmRlZmluZWQ7XG4gICAgc2VuZDogKGU6IFQpID0+IHZvaWQ7XG59XG4vKlxuY29uc3QgYWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBOb2RlIHwgbnVsbCkgPT4gdm9pZCk+PigpO1xuY29uc3QgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogTm9kZSkgPT4gdm9pZCk+PigpO1xuY29uc3Qgd2luZG93Rm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChmb2N1c2VkOiBib29sZWFuKSA9PiB2b2lkKT4+KCk7XG5jb25zdCB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBib29sZWFuPigpOyovXG5jb25zdCBhY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDxGb288Tm9kZSB8IG51bGw+Pj4oKTtcbmNvbnN0IGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDxGb288Tm9kZT4+PigpO1xuY29uc3Qgd2luZG93Rm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPGJvb2xlYW4+Pj4oKTtcbmNvbnN0IHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIGJvb2xlYW4+KCk7XG5cbi8vY29uc3QgbWljcm90YXNrcyA9IG5ldyBNYXA8U2V0PGFueT4sIGFueT4oKTtcblxuLy8gVGhlIGZvY3VzaW4gYW5kIGZvY3Vzb3V0IGV2ZW50cyBvZnRlbiBmaXJlIHN5bmNyb25vdXNseSBpbiB0aGUgbWlkZGxlIG9mIHJ1bm5pbmcgY29kZS5cbi8vIEUuRy4gY2FsbGluZyBlbGVtZW50LmZvY3VzKCkgY2FuIGNhdXNlIGEgZm9jdXNpbiBldmVudCBoYW5kbGVyIHRvIGltbWVkaWF0ZWx5IGludGVycnVwdCB0aGF0IGNvZGUuXG4vLyBGb3IgdGhlIHB1cnBvc2Ugb2YgaW1wcm92aW5nIHN0YWJpbGl0eSwgd2UgZGVib3VuY2UgYWxsIGZvY3VzIGV2ZW50cyB0byB0aGUgbmV4dCBtaWNyb3Rhc2suXG5mdW5jdGlvbiBmb3JFYWNoVXBkYXRlcjxUPih3aW5kb3c6IFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIG1hcDogTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDxGb288VD4+PiwgdmFsdWU6IFQpIHtcbiAgICBjb25zdCB1cGRhdGVycyA9IG1hcC5nZXQod2luZG93KTtcbiAgICBpZiAodXBkYXRlcnMpIHtcbiAgICAgICAgLy9pZiAoIW1pY3JvdGFza3MuaGFzKHVwZGF0ZXJzS2V5KSkge1xuICAgICAgICAvL2RlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgLy9jb25zdCB1cGRhdGVyc0tleSA9IG1hcC5nZXQod2luZG93KSE7XG4gICAgICAgIC8vY29uc3QgdmFsdWUgPSBtaWNyb3Rhc2tzLmdldCh1cGRhdGVyc0tleSk7XG4gICAgICAgIC8vbWljcm90YXNrcy5kZWxldGUodXBkYXRlcnNLZXkpO1xuXG4gICAgICAgIGlmICh1cGRhdGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB1cGRhdGVyIG9mIHVwZGF0ZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsYXN0U2VudCwgc2VuZCB9ID0gdXBkYXRlcjtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGxhc3RTZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVyLmxhc3RTZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy99KTtcbiAgICAgICAgLy99XG5cbiAgICAgICAgLy9taWNyb3Rhc2tzLnNldCh1cGRhdGVyc0tleSwgdmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9jdXNvdXQoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG4gICAgaWYgKGUucmVsYXRlZFRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBudWxsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEp1c3Qgd2FpdCBmb3IgdGhlIGZvY3VzaW4gZXZlbnQuXG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGZvY3VzaW4oZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIGNvbnN0IGN1cnJlbnRseUZvY3VzZWRFbGVtZW50ID0gZS50YXJnZXQgYXMgKEVsZW1lbnQgJiBIVE1MT3JTVkdFbGVtZW50KTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGFjdGl2ZUVsZW1lbnRVcGRhdGVycywgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycywgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiB3aW5kb3dGb2N1cyhlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS50YXJnZXQgOiBlLmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLmN1cnJlbnRUYXJnZXQgOiAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyk7XG4gICAgd2luZG93c0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCB0cnVlKTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIHdpbmRvd0ZvY3VzZWRVcGRhdGVycywgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHdpbmRvd0JsdXIoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUudGFyZ2V0IDogZS5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS5jdXJyZW50VGFyZ2V0IDogKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgZmFsc2UpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLCBmYWxzZSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMge1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxFbGVtZW50IHwgbnVsbD47XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMgYW5kIGlzIG5vdCBudWxsLiBcbiAgICAgKiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8RWxlbWVudD47XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIHdpbmRvdyBnYWlucy9sb3NlcyBmb2N1cy4gTXVzdCBiZSBzdGFibGUuXG4gICAgICovXG4gICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8Ym9vbGVhbj47XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGRvY3VtZW50IGFzc29jaWF0ZWQgd2l0aCB3aGF0ZXZlciBlbGVtZW50cyB3ZSdyZSBsaXN0ZW5pbmcgdG8uXG4gICAgICogXG4gICAgICogRS5HLiBzb21lRGl2RWxlbWVudC5vd25lckRvY3VtZW50XG4gICAgICogXG4gICAgICogKipNVVNUKiogYmUgc3RhYmxlXG4gICAgICovXG4gICAgZ2V0RG9jdW1lbnQoKTogRG9jdW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCBldmVudCBoYW5kbGVycyBhcmUgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50J3MgZGVmYXVsdFZpZXcgV2luZG93LlxuICAgICAqIElmIHlvdSBuZWVkIHNvbWV0aGluZyBkaWZmZXJlbnQsIG92ZXJyaWRlIGl0IGhlcmUuXG4gICAgICogXG4gICAgICogKipNVVNUKiogYmUgc3RhYmxlXG4gICAgICovXG4gICAgZ2V0V2luZG93Pyhkb2N1bWVudDogRG9jdW1lbnQpOiBXaW5kb3c7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUge1xuICAgIC8qKiBcbiAgICAgKiBSZXR1cm5zIHdoYXRldmVyIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWQsIG9yIGBudWxsYCBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50IHwgbnVsbDtcbiAgICAvKiogXG4gICAgICogUmV0dXJucyB3aGF0ZXZlciBlbGVtZW50IGlzIGN1cnJlbnRseSBmb2N1c2VkLCBvciB3aGF0ZXZlciBlbGVtZW50IHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnRcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQ6ICgpID0+IEVsZW1lbnQ7XG4gICAgLyoqIFxuICAgICAqIFJldHVybnMgaWYgdGhlIHdpbmRvdyBpdHNlbGYgaGFzIGZvY3VzIG9yIG5vdFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBnZXRXaW5kb3dGb2N1c2VkOiAoKSA9PiBib29sZWFuO1xufVxuXG4vKipcbiAqIEFsbG93cyB5b3UgdG8gaW5zcGVjdCB3aGljaCBlbGVtZW50IGluIHRoZSBgZG9jdW1lbnRgIGN1cnJlbnRseSBoYXMgZm9jdXMsIHdoaWNoIHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgbm9uZSBhcmUgY3VycmVudGx5LCBhbmQgd2hldGhlciBvciBub3QgdGhlIHdpbmRvdyBoYXMgZm9jdXMgYnkgcmV0dXJuaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICogKiBgZ2V0QWN0aXZlRWxlbWVudCgpYFxuICogKiBgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQoKWBcbiAqICogYGdldFdpbmRvd0ZvY3VzZWQoKWBcbiAqIFxuICogKFRoZSBkb2N1bWVudCdzIGJvZHkgcmVjZWl2aW5nIGZvY3VzLCBsaWtlIGl0IGRvZXMgd2hlbiB5b3UgY2xpY2sgb24gYW4gZW1wdHkgYXJlYSwgaXMgY291bnRlZCBhcyBubyBlbGVtZW50IGhhdmluZyBmb2N1cyBmb3IgYWxsIGludGVudHMgYW5kIHB1cnBvc2VzKVxuICogXG4gKiBUaGlzIGlzIGEgcGFzc2l2ZSBob29rLCBzbyBieSBkZWZhdWx0IGl0IHJldHVybnMgZ2V0dGVyIGZ1bmN0aW9ucyB0aGF0IHJlcG9ydCB0aGlzIGluZm9ybWF0aW9uIGJ1dCB0aGUgY29tcG9uZW50IHdpbGwgbm90IHJlLXJlbmRlciBieSBkZWZhdWx0IHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMuXG4gKiBcbiAqIElmIHlvdSBuZWVkIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMsIHVzZSB0aGUgYG9uKkNoYW5nZWAgYXJndW1lbnRzIHRvIHNldCBzb21lIHN0YXRlIG9uIHlvdXIgZW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aXZlRWxlbWVudCh7IG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCBnZXREb2N1bWVudCwgZ2V0V2luZG93IH06IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzKTogVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUge1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlQWN0aXZlRWxlbWVudFwiLCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IChnZXRXaW5kb3c/Lihkb2N1bWVudCkgPz8gZG9jdW1lbnQ/LmRlZmF1bHRWaWV3KTtcblxuICAgICAgICBpZiAoKGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KT8uc2l6ZSA/PyAwKSA9PT0gMCkge1xuICAgICAgICAgICAgZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGZvY3VzaW4sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZm9jdXNvdXQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHdpbmRvd0JsdXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGVtIGV2ZW4gaWYgdGhleSdyZSB1bmRlZmluZWQgdG8gbW9yZSBlYXNpbHlcbiAgICAgICAgLy8gbWFuYWdlIHRoZSBcIj4wIG1lYW5zIGRvbid0IGFkZCBoYW5kbGVyc1wiIGxvZ2ljLlxuICAgICAgICBjb25zdCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XG5cbiAgICAgICAgY29uc3QgbGFldSA9IHsgc2VuZDogc2V0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZSB8IG51bGw+LCBsYXN0U2VudDogdW5kZWZpbmVkIH1cbiAgICAgICAgY29uc3QgbGxhZXUgPSB7IHNlbmQ6IHNldExhc3RBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlPiwgbGFzdFNlbnQ6IHVuZGVmaW5lZCB9O1xuICAgICAgICBjb25zdCBsd2Z1ID0geyBzZW5kOiBzZXRXaW5kb3dGb2N1c2VkLCBsYXN0U2VudDogdW5kZWZpbmVkIH07XG5cbiAgICAgICAgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMuYWRkKGxhZXUpO1xuICAgICAgICBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuYWRkKGxsYWV1KTtcbiAgICAgICAgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMuYWRkKGx3ZnUpO1xuXG4gICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyk7XG4gICAgICAgIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzKTtcbiAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUobGFldSk7XG4gICAgICAgICAgICBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUobGFldSk7XG4gICAgICAgICAgICB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuZ2V0KHdpbmRvdykhLmRlbGV0ZShsd2Z1KTtcblxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGZvY3VzaW4pO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZm9jdXNvdXQpO1xuICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzKTtcbiAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHdpbmRvd0JsdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBbZ2V0QWN0aXZlRWxlbWVudCwgc2V0QWN0aXZlRWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8RWxlbWVudCB8IG51bGw+KG9uQWN0aXZlRWxlbWVudENoYW5nZSwgcmV0dXJuTnVsbCk7XG4gICAgY29uc3QgW2dldExhc3RBY3RpdmVFbGVtZW50LCBzZXRMYXN0QWN0aXZlRWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8RWxlbWVudD4ob25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgcmV0dXJuTnVsbCBhcyAoKSA9PiBuZXZlcik7XG4gICAgY29uc3QgW2dldFdpbmRvd0ZvY3VzZWQsIHNldFdpbmRvd0ZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmV0dXJuVHJ1ZSk7XG5cbiAgICByZXR1cm4geyBnZXRBY3RpdmVFbGVtZW50LCBnZXRMYXN0QWN0aXZlRWxlbWVudCwgZ2V0V2luZG93Rm9jdXNlZCB9O1xufVxuIiwiXG5pbXBvcnQgeyBDb21wb25lbnQsIG9wdGlvbnMsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgRWZmZWN0Q2FsbGJhY2ssIElucHV0cywgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuXG5cbmNvbnN0IFRhYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OV8tXCI7XG5cbmZ1bmN0aW9uIGJhc2U2NCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgcmV0dXJuIFRhYmxlW3ZhbHVlXTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tNkJpdHMoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDBiMTAwMDAwMCk7XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTY0Qml0cygpIHtcbiAgICByZXR1cm4gW3JhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCksIHJhbmRvbTZCaXRzKCldIGFzIGNvbnN0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgd2l0aCBhbiBvcHRpb25hbCBwcmVmaXguXG4gKiBOb3RlIHRoYXQgaWYgdGhlIHByZWZpeCBpcyAqZXhwbGljaXRseSogc2V0IHRvIFwiXCIsIHRoZW5cbiAqIElEcyB0aGF0IGFyZSBub3QgdmFsaWQgdW5kZXIgSFRNTDQgbWF5IGJlIGdlbmVyYXRlZC4gT2ggbm8uXG4gKiBcbiAqIFxuICogKFRoaXMgaXMgaGVyZSwgaW4gdGhpcyBwYXJ0aWN1bGFyIGZpbGUsIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuICogd2l0aG91dCBhbHNvIG1ha2luZyBhIHV0aWxpdGllcyBmaWxlLlxuICogT25jZSB3ZSBjYW4gcmVtb3ZlIHRoaXMgaG9vaywgd2UgY2FuIHB1dCB0aGlzIGZ1bmN0aW9uIGJhY2sgd2l0aCB1c2VSYW5kb21JZClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tSWQocHJlZml4Pzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGAke3ByZWZpeCA/PyBcImlkLVwifSR7cmFuZG9tNjRCaXRzKCkubWFwKG4gPT4gYmFzZTY0KG4pKS5qb2luKFwiXCIpfWA7XG59XG5cbmNvbnN0IHByZXZpb3VzSW5wdXRzID0gbmV3IE1hcDxzdHJpbmcsIElucHV0cyB8IHVuZGVmaW5lZD4oKTtcbmNvbnN0IHRvUnVuID0gbmV3IE1hcDxzdHJpbmcsIHsgZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgaW5wdXRzPzogSW5wdXRzLCBjbGVhbnVwOiBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZCB8ICgoKSA9PiB2b2lkKSB9PigpO1xuXG5cbi8vIFRPRE86IFdoZXRoZXIgdGhpcyBnb2VzIGluIG9wdGlvbnMuZGlmZmVkIG9yIG9wdGlvbnMuX2NvbW1pdFxuLy8gaXMgYSBwb3N0LXN1c3BlbnNlIHF1ZXN0aW9uLlxuLy8gUmlnaHQgbm93LCB1c2luZyBvcHRpb25zLl9jb21taXQgaGFzIHRoZSBwcm9ibGVtIG9mIHJ1bm5pbmdcbi8vICphZnRlciogcmVmcyBhcmUgYXBwbGllZCwgYnV0IHdlIG5lZWQgdG8gY29tZSBiZWZvcmUgZXZlbiB0aGF0XG4vLyBzbyBgcmVmPXtzb21lU3RhYmxlRnVuY3Rpb259YCB3b3Jrcy5cbi8vIFxuLy8gQWxzbyBpdCdzIHByaXZhdGUuXG4vL1xuLy8gLi4uXG4vLyBXZWxsLCB1c2VFdmVudCBvciB3aGF0ZXZlciBpcyBmaW5hbGx5LCBmaW5hbGx5IDQgeWVhcnMgbGF0ZXIgZmluYWxseSBoZXJlXG4vLyB3aGljaCBpcyBjb29sIGFuZCBtZWFucyB3ZSB3b24ndCBuZWVkIHRoaXMgYXQgYWxsIHNvb24uXG4vLyBTbyBmb3Igbm93IHdlJ2xsIHN0aWNrIHdpdGggZGlmZiB0byBwcmV2ZW50IGFueSB3ZWlyZG5lc3Mgd2l0aFxuLy8gY29tbWl0IGJlaW5nIHByaXZhdGUgYW5kIGFsbC5cbmNvbnN0IGNvbW1pdE5hbWUgPSBcImRpZmZlZFwiO1xuXG5jb25zdCBvcmlnaW5hbENvbW1pdCA9IG9wdGlvbnNbY29tbWl0TmFtZV0gYXMgKHZub2RlOiBWTm9kZSwgY29tbWl0UXVldWU6IENvbXBvbmVudFtdKSA9PiB2b2lkO1xuY29uc3QgbmV3Q29tbWl0OiB0eXBlb2Ygb3JpZ2luYWxDb21taXQgPSAoLi4uYXJncykgPT4ge1xuICAgIGZvciAoY29uc3QgW2lkLCBlZmZlY3RJbmZvXSBvZiB0b1J1bikge1xuICAgICAgICBjb25zdCBvbGRJbnB1dHMgPSBwcmV2aW91c0lucHV0cy5nZXQoaWQpO1xuICAgICAgICBpZiAoYXJnc0NoYW5nZWQob2xkSW5wdXRzLCBlZmZlY3RJbmZvLmlucHV0cykpIHtcbiAgICAgICAgICAgIGVmZmVjdEluZm8uY2xlYW51cD8uKCk7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXAgPSBlZmZlY3RJbmZvLmVmZmVjdCgpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuc2V0KGlkLCBlZmZlY3RJbmZvLmlucHV0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9SdW4uY2xlYXIoKTtcbiAgICBvcmlnaW5hbENvbW1pdD8uKC4uLmFyZ3MpO1xufVxub3B0aW9uc1tjb21taXROYW1lXSA9IG5ld0NvbW1pdCBhcyBuZXZlclxuXG4vKipcbiAqIFNlbWktcHJpdmF0ZSBmdW5jdGlvbiB0byBhbGxvdyBzdGFibGUgY2FsbGJhY2tzIGV2ZW4gd2l0aGluIGB1c2VMYXlvdXRFZmZlY3RgIGFuZCByZWYgYXNzaWdubWVudC5cbiAqIFxuICogRXZlcnkgcmVuZGVyLCB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgdG8gYmUgZXZhbHVhdGVkIGFmdGVyIGRpZmZpbmcgaGFzIGNvbXBsZXRlZCxcbiAqIHdoaWNoIGhhcHBlbnMgYmVmb3JlLlxuICogXG4gKiBAcGFyYW0gZWZmZWN0IFxuICogQHBhcmFtIGlucHV0cyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJlZm9yZUxheW91dEVmZmVjdChlZmZlY3Q6IEVmZmVjdENhbGxiYWNrLCBpbnB1dHM/OiBJbnB1dHMpIHtcblxuICAgIC8qKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IHVzZVJlZjx2b2lkIHwgKCgpID0+IHZvaWQpIHwgbnVsbD4obnVsbCk7XG4gICAgICAgIGNvbnN0IHByZXZBcmdzUmVmID0gdXNlUmVmPElucHV0cz4obnVsbCEpO1xuICAgICAgICBpZiAoYXJnc0NoYW5nZWQoaW5wdXRzLCBwcmV2QXJnc1JlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgcHJldkFyZ3NSZWYuY3VycmVudCA9IGlucHV0cyE7XG4gICAgICAgICAgICBpZiAoY2xlYW51cC5jdXJyZW50KVxuICAgICAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCgpO1xuICAgICAgICAgICAgY2xlYW51cC5jdXJyZW50ID0gZWZmZWN0KCk7XG4gICAgICAgIH1cbiAgICB9KSgpOyovXG5cbiAgICBjb25zdCBbaWRdID0gdXNlU3RhdGUoKCkgPT4gZ2VuZXJhdGVSYW5kb21JZCgpKTtcbiAgICB0b1J1bi5zZXQoaWQsIHsgZWZmZWN0LCBpbnB1dHMsIGNsZWFudXA6IG51bGwgfSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdG9SdW4uZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICB9LCBbaWRdKVxufVxuXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzPzogSW5wdXRzLCBuZXdBcmdzPzogSW5wdXRzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhKFxuICAgICAgICAhb2xkQXJncyB8fFxuICAgICAgICBvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncz8ubGVuZ3RoIHx8XG4gICAgICAgIG5ld0FyZ3M/LnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG4gICAgKTtcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlQmVmb3JlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0XCI7XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKFwidW5zZXRcIik7XG5cbi8qKlxuICogR2l2ZW4gYW4gaW5wdXQgdmFsdWUsIHJldHVybnMgYSBjb25zdGFudCBnZXR0ZXIgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBcbiAqIGluc2lkZSBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcyB3aXRob3V0IGluY2x1ZGluZyBpdCBpbiB0aGUgZGVwZW5kZW5jeSBhcnJheS5cbiAqIFxuICogVGhpcyB1c2VzIGBvcHRpb25zLmRpZmZlZGAgaW4gb3JkZXIgdG8gcnVuIGJlZm9yZSBldmVyeXRoaW5nLCBldmVuXG4gKiByZWYgYXNzaWdubWVudC4gVGhpcyBtZWFucyB0aGlzIGdldHRlciBpcyBzYWZlIHRvIHVzZSBhbnl3aGVyZSAqKipleGNlcHQgdGhlIHJlbmRlciBwaGFzZSoqKi5cbiAqIFxuICogQHBhcmFtIHZhbHVlIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVHZXR0ZXI8VD4odmFsdWU6IFQpOiAoKSA9PiBUIHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWY8VD4oVW5zZXQgYXMgdW5rbm93biBhcyBUKTtcbiAgICB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoKCkgPT4geyByZWYuY3VycmVudCA9IHZhbHVlOyB9LCBbdmFsdWVdKTtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAocmVmLmN1cnJlbnQgYXMgdW5rbm93biA9PT0gVW5zZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgcmV0cmlldmVkIGZyb20gdXNlU3RhYmxlR2V0dGVyKCkgY2Fubm90IGJlIGNhbGxlZCBkdXJpbmcgcmVuZGVyLicpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZi5jdXJyZW50O1xuICAgIH0sIFtdKVxufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuXG4vKipcbiAqIEFsdGVybmF0ZSB1c2VDYWxsYmFjaygpIHdoaWNoIGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lICh3cmFwcGVkKSBmdW5jdGlvbiByZWZlcmVuY2VcbiAqIHNvIHRoYXQgaXQgY2FuIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGRlcGVuZGVuY3kgYXJyYXlzIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzLlxuICogXG4gKiBEbyBub3QgdXNlIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlISAgYHVzZUxheW91dEVmZmVjdGAgaXMgZmluZSB0aG91Z2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjazxUIGV4dGVuZHMgKC4uLl9hcmdzOiBhbnlbXSkgPT4gYW55PihmbjogVCk6IFQge1xuICAgIGNvbnN0IGN1cnJlbnRDYWxsYmFja0dldHRlciA9IHVzZVN0YWJsZUdldHRlcjxUPihmbik7XG5cbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pOiBSZXR1cm5UeXBlPFQ+ID0+IHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDYWxsYmFja0dldHRlcigpKC4uLmFyZ3MpO1xuICAgIH0sIFtdKSBhcyBUO1xufSIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5cbnR5cGUgUmFmQ2FsbGJhY2tUeXBlID0gKG1zU2luY2VMYXN0OiBudW1iZXIsIHRhZz86IGFueSkgPT4gdm9pZDtcblxuaW50ZXJmYWNlIENvbnRleHRUeXBlIHtcbiAgICBhZGRDYWxsYmFjazogKGNhbGxiYWNrOiBSYWZDYWxsYmFja1R5cGUsIHRhZz86IGFueSkgPT4gdm9pZDtcbiAgICByZW1vdmVDYWxsYmFjazogKGNhbGxiYWNrOiBSYWZDYWxsYmFja1R5cGUpID0+IHZvaWQ7XG59XG5cbmNvbnN0IFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8bnVsbCB8IENvbnRleHRUeXBlPihudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIFByb3ZpZGVCYXRjaGVkQW5pbWF0aW9uRnJhbWVzKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW4gfSkge1xuXG4gICAgY29uc3QgYWRkQ2FsbGJhY2sgPSB1c2VDYWxsYmFjazxDb250ZXh0VHlwZVtcImFkZENhbGxiYWNrXCJdPigoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LnNldChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpOyB9LCBbXSk7XG4gICAgY29uc3QgcmVtb3ZlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjazxDb250ZXh0VHlwZVtcInJlbW92ZUNhbGxiYWNrXCJdPigoY2FsbGJhY2spID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuZGVsZXRlKGNhbGxiYWNrKTsgfSwgW10pO1xuXG4gICAgY29uc3QgY29udGV4dEluZm8gPSB1c2VSZWY8Q29udGV4dFR5cGU+KG51bGwhKTtcbiAgICBpZiAoY29udGV4dEluZm8uY3VycmVudCA9PSBudWxsKVxuICAgICAgICBjb250ZXh0SW5mby5jdXJyZW50ID0geyBhZGRDYWxsYmFjaywgcmVtb3ZlQ2FsbGJhY2sgfTtcbiAgICBjb25zdCBhbGxDYWxsYmFja3MgPSB1c2VSZWY8TWFwPFJhZkNhbGxiYWNrVHlwZSwgYW55Pj4obnVsbCEpO1xuICAgIGlmIChhbGxDYWxsYmFja3MuY3VycmVudCA9PSBudWxsKVxuICAgICAgICBhbGxDYWxsYmFja3MuY3VycmVudCA9IG5ldyBNYXAoKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCBoYW5kbGUgPSAtMTtcblxuICAgICAgICBmdW5jdGlvbiByYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyhtc1NpbmNlTGFzdDogbnVtYmVyKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtiYXRjaGVkUmFmQ2FsbGJhY2ssIHRhZ10gb2YgYWxsQ2FsbGJhY2tzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVkUmFmQ2FsbGJhY2sobXNTaW5jZUxhc3QsIHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8U2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0SW5mby5jdXJyZW50fT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9TaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXI+KVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFuaW1hdGlvbkZyYW1lUGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgd2l0aCBlZmZlY3RpdmVseSB0aGUgc2FtZSBydWxlcyBhcyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYFxuICAgICAqIFxuICAgICAqIERvZXNuJ3QgbmVlZCB0byBiZSBzdGFibGUuXG4gICAgICovXG4gICAgY2FsbGJhY2s6IG51bGwgfCAoKG1zU2luY2VMYXN0OiBudW1iZXIpID0+IHZvaWQpO1xufVxuXG4vKipcbiAqIFRoZSAob3B0aW9uYWxseSBub24tc3RhYmxlKSBgY2FsbGJhY2tgIHlvdSBwcm92aWRlIHdpbGwgc3RhcnQgcnVubmluZyBldmVyeSBmcmFtZSBhZnRlciB0aGUgY29tcG9uZW50IG1vdW50cy5cbiAqIFxuICogUGFzc2luZyBgbnVsbGAgaXMgZmluZSBhbmQgc2ltcGx5IHN0b3BzIHRoZSBlZmZlY3QgdW50aWwgeW91IHJlc3RhcnQgaXQgYnkgcHJvdmlkaW5nIGEgbm9uLW51bGwgY2FsbGJhY2suXG4gKiBcbiAqICoqVGhpcyBob29rIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhdCBhbGwsIGluY2x1ZGluZyBubyBwcm9wLW1vZGlmeWluZyBob29rcyoqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBbmltYXRpb25GcmFtZSh7IGNhbGxiYWNrIH06IFVzZUFuaW1hdGlvbkZyYW1lUGFyYW1ldGVycyk6IHZvaWQge1xuICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSBnaXZlbiBjYWxsYmFjayB0aGF0J3Mgc3RhYmxlXG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjayhjYWxsYmFjayA/PyBub29wKTtcbiAgICBjb25zdCBoYXNDYWxsYmFjayA9IChjYWxsYmFjayAhPSBudWxsKTtcblxuICAgIGNvbnN0IHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCA9IHVzZUNvbnRleHQoU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5hZGRDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQucmVtb3ZlQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIHdyYXBwZXIgYXJvdW5kIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgYWxzbyBjYWxscyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICBjb25zdCByYWZDYWxsYmFjayA9IChtczogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWJsZUNhbGxiYWNrKG1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LCBoYXNDYWxsYmFja10pXG59XG5cbi8vIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuZnVuY3Rpb24gbm9vcCgpIHsgfVxuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0O1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdExpa2U7XG4iLCJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlU3RhdGUgYXMgdXNlU3RhdGVQIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG4vKipcbiAqIFNsaWdodGx5IGVuaGFuY2VkIHZlcnNpb24gb2YgYHVzZVN0YXRlYCB0aGF0IGluY2x1ZGVzIGEgZ2V0dGVyIHRoYXQgcmVtYWlucyBjb25zdGFudFxuICogKGkuZS4geW91IGNhbiB1c2UgaXQgaW4gYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpdCBiZWluZyBhIGRlcGVuZGVuY3kpLlxuICogXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZTxUPihpbml0aWFsU3RhdGU6IFQgfCAoKCkgPT4gVCkpOiByZWFkb25seSBbdmFsdWU6IFQsIHNldFZhbHVlOiBTdGF0ZVVwZGF0ZXI8VD4sIGdldFZhbHVlOiAoKSA9PiBUXSB7XG5cbiAgICAvLyBXZSBrZWVwIGJvdGgsIGJ1dCBvdmVycnJpZGUgdGhlIGBzZXRTdGF0ZWAgZnVuY3Rpb25hbGl0eVxuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVQXSA9IHVzZVN0YXRlUChpbml0aWFsU3RhdGUpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihzdGF0ZSk7XG5cbiAgICAvLyBIaWphY2sgdGhlIG5vcm1hbCBzZXR0ZXIgZnVuY3Rpb24gXG4gICAgLy8gdG8gYWxzbyBzZXQgb3VyIHJlZiB0byB0aGUgbmV3IHZhbHVlXG4gICAgY29uc3Qgc2V0U3RhdGUgPSB1c2VDYWxsYmFjazxTdGF0ZVVwZGF0ZXI8VD4+KHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHZhbHVlIGFzICgoX3ByZXZWYWx1ZTogVCkgPT4gVCk7XG4gICAgICAgICAgICBzZXRTdGF0ZVAocHJldlZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBjYWxsYmFjayhwcmV2VmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gICAgICAgICAgICBzZXRTdGF0ZVAodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiB7IHJldHVybiByZWYuY3VycmVudDsgfTtcblxuXG4gICAgY29uc29sZS5hc3NlcnQocmVmLmN1cnJlbnQgPT09IHN0YXRlIHx8ICh0eXBlb2Ygc3RhdGUgPT09IFwibnVtYmVyXCIgJiYgaXNOYU4oc3RhdGUpKSk7XG4gICAgcmV0dXJuIFtzdGF0ZSwgc2V0U3RhdGUsIGdldFN0YXRlXSBhcyBjb25zdDtcbn0iLCJpbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSwgZGVib3VuY2VSZW5kZXJpbmcgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5cbi8qKlxuICogUmVtaW5kZXIgb2Ygb3JkZXIgb2YgZXhlY3V0aW9uOlxuICogXG4gKiAqICh0cmVlIG1vdW50cylcbiAqICogUGFyZW50IHJlbmRlcnNcbiAqICogQ2hpbGRyZW4gcmVuZGVyXG4gKiAqIENoaWxkcmVuIHJlY2VpdmUgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBQYXJlbnQgcmVjZWl2ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZHJlbiBydW4gZWZmZWN0c1xuICogKiBQYXJlbnQgcnVucyBlZmZlY3RzXG4gKiBcbiAqICogKHRyZWUgdW5tb3VudHMpXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIFBhcmVudCBkZWxldGVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogQ2hpbGQgcnVucyBlZmZlY3QtY2xlYW51cFxuICogKiBDaGlsZCBkZWxldGVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqIFxuICogVHdvIHRoaW5ncyB0byBub3RlIGhlcmU6XG4gKiAqIFJlbmRlcmluZyBzdGFydHMgYXQgdGhlIHJvb3QsICBidXQgZWZmZWN0cyBhbmQgcmVmcyBzdGFydCBhdCB0aGUgbGVhdmVzLlxuICogKiByZWZzIGFyZSAqdXN1YWxseSogY2FsbGVkIGJlZm9yZSBlZmZlY3RzLCBidXQgb25seSB3aGVuIHRoYXQgSFRNTEVsZW1lbnQgcmVuZGVycy4gQmFzaWNhbGx5IGp1c3QgYSByZW1pbmRlciB0aGF0IGEgY29tcG9uZW50IGNhbiBiZSBtb3VudGVkIHdpdGhvdXQgaXQgZXhpc3RpbmcgaW4gdGhlIERPTS5cbiAqL1xuY29uc3QgX2NvbW1lbnRzID0gdm9pZCAoMCk7XG5cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiB0aGF0IGNoaWxkcmVuIGFuZCBwYXJlbnRzIHVzZSB0byBjb21tdW5pY2F0ZSB3aXRoIGVhY2ggb3RoZXIuXG4gKiBcbiAqICogYGluZGV4YCByZWZlcnMgdG8gd2hpY2ggY2hpbGQgdGhpcyBpcy5cbiAqICogYGZsYWdzYCBhcmUgcXVpY2stYW5kLWVhc3kgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGF0IHlvdSBjYW4gb3B0aW9uYWxseSB1c2VcbiAqICogYHN1YkluZm9gIGlzIGFueXRoaW5nIHVzZWQgYnkgYSBkZXJpdmVkIGhvb2suIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGZvciBleGFtcGxlLCBuZWVkcyB0byBrbm93IGhvdyB0byBmb2N1cyBhbiBhcmJpdHJhcnkgY2hpbGQsIHNvIHRoZSBjaGlsZCBwb3B1bGF0ZXMgYGluZm9gIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBtZXRob2QgY2FsbGVkIGBmb2N1c1NlbGZgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZEluZm88VCBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgQywgSyBleHRlbmRzIHN0cmluZz4ge1xuICAgIGluZGV4OiBUO1xuICAgIGZsYWdzPzogUGFydGlhbDxSZWNvcmQ8SywgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+O1xuICAgIHN1YkluZm86IEM7XG59XG5cblxuXG5leHBvcnQgdHlwZSBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKG1vdW50ZWQ6IFNldDxUPiwgdW5tb3VudGVkOiBTZXQ8VD4pID0+IHZvaWQpO1xuZXhwb3J0IHR5cGUgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChjYXVzZXJzOiBJdGVyYWJsZTxUPikgPT4gdm9pZCk7XG5cbmludGVyZmFjZSBNQ1A8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZz4ge1xuICAgIC8qKlxuICAgICAqIFJ1bnMgYWZ0ZXIgb25lIG9yIG1vcmUgY2hpbGRyZW4gaGF2ZSB1cGRhdGVkIHRoZWlyIGluZm9ybWF0aW9uIChpbmRleCwgZXRjLikuXG4gICAgICogXG4gICAgICogT25seSBvbmUgd2lsbCBydW4gcGVyIHRpY2ssIGp1c3QgbGlrZSBsYXlvdXRFZmZlY3QsIGJ1dCBpdCBpc24ndFxuICAgICAqICpndWFyYW50ZWVkKiB0byBoYXZlIGFjdHVhbGx5IGJlZW4gYSBjaGFuZ2UuXG4gICAgICovXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxUPjtcblxuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgdGhlIGFib3ZlLCBidXQgb25seSBmb3IgbW91bnQvdW5tb3VudCAob3Igd2hlbiBhIGNoaWxkIGNoYW5nZXMgaXRzIGluZGV4KVxuICAgICAqL1xuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8VD47XG59XG5cbmV4cG9ydCB0eXBlIE1hbmFnZWRDaGlsZHJlbk9taXRzID0ga2V5b2YgTUNQPGFueT47XG5leHBvcnQgdHlwZSBNYW5hZ2VkQ2hpbGRPbWl0cyA9IGtleW9mIE1hbmFnZWRDaGlsZEluZm88YW55LCBhbnksIGFueT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBPbWl0cyBleHRlbmRzIGtleW9mIE1DUDxUPj4ge1xuICAgIG1hbmFnZWRDaGlsZHJlbjogT21pdDxNQ1A8VD4sIE9taXRzPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cz4ge1xuICAgIG1hbmFnZWRDaGlsZDogT21pdDxNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+LCBNY09taXRzPjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGlsZCB0aGF0IHJlbmRlcmVkIGl0c2VsZiB3aXRoIHRoZSByZXF1ZXN0ZWQga2V5LlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKiogKGV2ZW4gdGhvdWdoIGl0J3Mgbm90IGEgZnVuY3Rpb24sIHRoZSBpZGVudGl0eSBvZiB0aGlzIG9iamVjdCBuZXZlciBjaGFuZ2VzKVxuICAgICAqL1xuICAgIG1hbmFnZWRDaGlsZHJlbjoge1xuICAgICAgICBjaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPFQsIEMsIEs+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88VCwgQywgSz4ge1xuICAgIC8qKlxuICAgICAqIEEgaG9vayB0aGF0IG11c3QgYmUgY2FsbGVkIGJ5IGV2ZXJ5IGNoaWxkIGNvbXBvbmVudCB0aGF0XG4gICAgICogaXMgdG8gYmUgbWFuYWdlZCBieSB0aGlzIG9uZS4gVGhlIGFyZ3VtZW50IHRvIHRoZSBob29rXG4gICAgICogaXMganVzdCB0aGUgYmFnIG9mIHByb3BlcnRpZXMgdG8gcGFzcyB0byB0aGUgcGFyZW50LFxuICAgICAqIGluY2x1ZGluZyB0aGUgY2hpbGQncyBpbmRleC5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgdXNlTWFuYWdlZENoaWxkOiBVc2VNYW5hZ2VkQ2hpbGQ8VCwgQywgSz47XG59XG5cbmV4cG9ydCB0eXBlIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGUgPSB2b2lkO1xuXG5leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGQ8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgQywgSyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxULCBDLCBLLCBuZXZlcj4pID0+IFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU7XG5cblxuXG5cblxuXG4vKipcbiAqIEFic3RyYWN0aW9uIG92ZXIgdGhlIG1hbmFnZWQgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRyZW48VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgQywgSyBleHRlbmRzIHN0cmluZz4ge1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRBdChpbmRleDogVCk6IE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGdldEhpZ2hlc3RJbmRleCgpOiBudW1iZXI7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGZvckVhY2g6IChmOiAoY2hpbGQ6IE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz4pID0+IHZvaWQpID0+IHZvaWQ7XG5cbiAgICAvKiogKipVTlNUQUJMRSoqLCBhbHNvIGludGVybmFsLXVzZSBvbmx5LCBhbHNvIFRPRE8gbmVlZCBhIHdvcmthcm91bmQgZm9yIHRoaXMgZm9yIHNvcnRhYmxlIGNoaWxkcmVuICovXG4gICAgYXJyYXlTbGljZTogKCkgPT4gTWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPltdO1xufVxuXG5cblxuXG4vL2V4cG9ydCB0eXBlIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8SSBleHRlbmRzIHt9PiA9IHsgaW5mbzogSSB9O1xuXG4vKipcbiAqIEFsbG93cyBhIHBhcmVudCBjb21wb25lbnQgdG8gYWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IGNlcnRhaW5cbiAqIGNoaWxkIGNvbXBvbmVudHMgb25jZSB0aGV5IGhhdmUgcmVuZGVyZWQuXG4gKiBcbiAqIFRoaXMgaG9vayBpcyBkZXNpZ25lZCB0byBiZSBsaWdodHdlaWdodCwgaW4gdGhhdCB0aGUgcGFyZW50IGtlZXBzIG5vIHN0YXRlXG4gKiBhbmQgcnVucyBubyBlZmZlY3RzLiAgRWFjaCBjaGlsZCAqZG9lcyogcnVuIGFuIGVmZmVjdCwgYnV0IHdpdGggbm8gc3RhdGVcbiAqIGNoYW5nZXMgdW5sZXNzIHlvdSBleHBsaWNpdGx5IHJlcXVlc3QgdGhlbS5cbiAqIFxuICogXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYW5hZ2VkQ2hpbGRyZW48VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgQywgSyBleHRlbmRzIHN0cmluZz4ocGFyZW50UGFyYW1ldGVyczogVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxULCBuZXZlcj4pOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPFQsIEMsIEs+IHtcbiAgICAvL3R5cGUgSSA9IEkzICYgTWFuYWdlZENoaWxkSW5mb0Jhc2U8c3RyaW5nIHwgbnVtYmVyPjtcbiAgICB0eXBlIEluZm8gPSBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+O1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9ID0gcGFyZW50UGFyYW1ldGVycztcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1hbmFnZWRDaGlsZHJlblwiLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSk7XG5cbiAgICBjb25zdCBnZXRIaWdoZXN0SW5kZXggPSB1c2VDYWxsYmFjaygoKTogbnVtYmVyID0+IHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4O1xuICAgIH0sIFtdKTtcblxuICAgIC8vIEFsbCB0aGUgaW5mb3JtYXRpb24gd2UgaGF2ZSBhYm91dCBvdXIgY2hpbGRyZW4gaXMgc3RvcmVkIGluIHRoaXMgKipzdGFibGUqKiBhcnJheS5cbiAgICAvLyBBbnkgbXV0YXRpb25zIHRvIHRoaXMgYXJyYXkgKipETyBOT1QqKiB0cmlnZ2VyIGFueSBzb3J0IG9mIGEgcmUtcmVuZGVyLlxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbkFycmF5ID0gdXNlUmVmPHsgYXJyOiBBcnJheTxJbmZvPjsgcmVjOiBQYXJ0aWFsPFJlY29yZDxULCBJbmZvPj47IGhpZ2hlc3RJbmRleDogbnVtYmVyLCBsb3dlc3RJbmRleDogbnVtYmVyIH0+KHsgYXJyOiBbXSwgcmVjOiB7fSwgaGlnaGVzdEluZGV4OiAwLCBsb3dlc3RJbmRleDogMCB9KTtcblxuICAgIC8vIEZvciBpbmRpcmVjdCBhY2Nlc3MgdG8gZWFjaCBjaGlsZFxuICAgIC8vIENvbXBhcmUgZ2V0TWFuYWdlZENoaWxkSW5mb1xuICAgIC8vIFRPRE86IFRoZSBwcmltYXJ5IHVzZSBmb3IgdGhpcyBpcyBmbGFnZ2FibGUgY2xvc2VzdCBmaXRzXG4gICAgLy8gd2hpY2ggbmVlZHMgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgYmV0dGVyIGZvciB0aGF0LlxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEluZm8pID0+IHZvaWQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikge1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgaW4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkOiBJbmZvIHwgdW5kZWZpbmVkID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbZmllbGQgYXMga2V5b2YgUmVjb3JkPFQsIEluZm8+XTtcbiAgICAgICAgICAgIGlmIChjaGlsZClcbiAgICAgICAgICAgICAgICBmKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgLy8gUmV0cmlldmVzIHRoZSBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIGNoaWxkIHdpdGggdGhlIGdpdmVuIGluZGV4LlxuICAgIC8vIGB1bmRlZmluZWRgIGlmIG5vdCBjaGlsZCB0aGVyZSwgb3IgaXQncyB1bm1vdW50ZWQuXG4gICAgY29uc3QgZ2V0TWFuYWdlZENoaWxkSW5mbyA9IHVzZUNhbGxiYWNrPE1hbmFnZWRDaGlsZHJlbjxULCBDLCBLPltcImdldEF0XCJdPigoaW5kZXg6IFQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl0hO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgVF0hO1xuICAgIH0sIFtdKVxuXG4gICAgLy8gdGw7ZHIgdGhpcyBpcyBhIHdheSB0byBoYXZlIHJ1biB1c2VMYXlvdXRFZmZlY3Qgb25jZSBhZnRlciBhbGwgTiBjaGlsZHJlblxuICAgIC8vIGhhdmUgbW91bnRlZCBhbmQgcnVuICp0aGVpciogdXNlTGF5b3V0RWZmZWN0LCBidXQgYWxzbyAqd2l0aG91dCogcmUtcmVuZGVyaW5nXG4gICAgLy8gb3Vyc2VsdmVzIGJlY2F1c2Ugb2YgaGF2aW5nIGEgYGNoaWxkQ291bnRgIHN0YXRlIG9yIGFueXRoaW5nIHNpbWlsYXIuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBjaGlsZCBjb3VudCByZWYgdXBkYXRlcywgd2Ugd2FudCB0aGUgcGFyZW50IHRvIGFsc28gcnVuIGFuIGVmZmVjdFxuICAgIC8vIHRvIG1heWJlIGRvIHNvbWV0aGluZyB3aXRoIGFsbCB0aGVzZSBjaGlsZHJlbiB0aGF0IGp1c3QgbW91bnRlZC5cbiAgICAvLyBUaGUgZWFzaWVzdCB3YXkgd291bGQgYmUgdXNlRWZmZWN0KC4uLiwgW2NoaWxkQ291bnRdKSBidXRcbiAgICAvLyB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgaGF2aW5nIGEgY2hpbGRDb3VudCBzdGF0ZSwgdGhlbiBjYWxsaW5nXG4gICAgLy8gc2V0Q2hpbGRDb3VudCBhbmQgcmUtcmVuZGVyaW5nIGV2ZXJ5IHRpbWUgY2hpbGRyZW4gbW91bnRcbiAgICAvLyAob25seSBvbmUgcmUtcmVuZGVyIGF0IGEgdGltZSB1bmxlc3MgY2hpbGRyZW4gYXJlIHN0YWdnZXJlZCwgYnV0IHN0aWxsKVxuICAgIC8vIFxuICAgIC8vIEFzIGFuIGFsdGVybmF0ZSBzb2x1dGlvbiwgYW55IHRpbWUgYSBjaGlsZCB1c2VzIFVMRSBvbiBtb3VudCwgaXQgcXVldWVzIGEgbWljcm90YXNrXG4gICAgLy8gdG8gZW11bGF0ZSBydW5uaW5nIFVMRSBvbiB0aGUgcGFyZW50LiBPbmx5IHRoZSBmaXJzdCBjaGlsZCB3aWxsIGFjdHVhbGx5IHF1ZXVlXG4gICAgLy8gdGhlIG1pY3JvdGFzayAoYnkgY2hlY2tpbmcgaGFzUmVtb3RlVUxFIGZpcnN0KSBzbyB0aGF0IHRoZSBcImVmZmVjdFwiIG9ubHlcbiAgICAvLyBydW5zIG9uY2UuIFdoZW4gaXQncyBkb25lLCBoYXNSZW1vdGVVTEUgaXMgcmVzZXQgc28gaXQgY2FuIHJ1biBhZ2FpbiBpZlxuICAgIC8vIG1vcmUgY2hpbGRyZW4gbW91bnQvdW5tb3VudC5cbiAgICBjb25zdCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VSZWY8eyBtb3VudHM6IFNldDxUPiwgdW5tb3VudHM6IFNldDxUPiB9IHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyA9IHVzZVJlZihuZXcgU2V0PFQ+KCkpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogVCkgPT4ge1xuXG4gICAgICAgIGlmIChyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuc2l6ZSA9PSAwKSB7XG4gICAgICAgICAgICBkZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Py4ocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmFkZChpbmRleCk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcblxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkTW91bnRlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogVCwgbW91bnRlZDogYm9vbGVhbik6IHZvaWQgPT4ge1xuICAgICAgICBpZiAoIWhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICBtb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICB1bm1vdW50czogbmV3IFNldCgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEubW91bnRzLCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEudW5tb3VudHMpXG4gICAgICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXggPSBNYXRoLm1heChtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCwgaW5kZXggYXMgbnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdO1xuICAgICAgICAgICAgICAgIGxldCBzaGF2ZSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNoYXZlIDw9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAmJiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyclttYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgKytzaGF2ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc3BsaWNlKG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIHNoYXZlLCBzaGF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIFRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnRbbW91bnRlZCA/IFwibW91bnRzXCIgOiBcInVubW91bnRzXCJdLmFkZChpbmRleCk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG5cbiAgICBjb25zdCB1c2VNYW5hZ2VkQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VNYW5hZ2VkQ2hpbGQ8VCwgQywgSz4+KCh7IG1hbmFnZWRDaGlsZDogaW5mbywgfSkgPT4ge1xuICAgICAgICAvLyBBbnkgdGltZSBvdXIgY2hpbGQgcHJvcHMgY2hhbmdlLCBtYWtlIHRoYXQgaW5mb3JtYXRpb24gYXZhaWxhYmxlXG4gICAgICAgIC8vIHRoZSBwYXJlbnQgaWYgdGhleSBuZWVkIGl0LlxuICAgICAgICAvLyBUaGUgcGFyZW50IGNhbiBsaXN0ZW4gZm9yIGFsbCB1cGRhdGVzIGFuZCBvbmx5IGFjdCBvbiB0aGUgb25lcyBpdCBjYXJlcyBhYm91dCxcbiAgICAgICAgLy8gYW5kIG11bHRpcGxlIGNoaWxkcmVuIHVwZGF0aW5nIGluIHRoZSBzYW1lIHRpY2sgd2lsbCBhbGwgYmUgc2VudCBhdCBvbmNlLlxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoaXMgaW5mb3JtYXRpb24gaW4tcGxhY2VcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5mby5pbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5mby5pbmRleCBhcyBudW1iZXJdID0geyBpbmRleDogaW5mby5pbmRleCwgZmxhZ3M6IGluZm8uZmxhZ3MgPz8ge30sIHN1YkluZm86IGluZm8uc3ViSW5mbyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5mby5pbmRleCBhcyBUXSA9IHsgaW5kZXg6IGluZm8uaW5kZXgsIGZsYWdzOiBpbmZvLmZsYWdzID8/IHt9LCBzdWJJbmZvOiBpbmZvLnN1YkluZm8gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW1vdGVVTEVDaGlsZENoYW5nZWQoaW5mby5pbmRleCBhcyBUKTtcbiAgICAgICAgfSwgWy4uLk9iamVjdC5lbnRyaWVzKGluZm8pLmZsYXQoOSldKTsgIC8vIDkgaXMgaW5maW5pdHksIHJpZ2h0PyBTdXJlLiBVbnJlbGF0ZWQ6IFRPRE8uXG5cbiAgICAgICAgLy8gV2hlbiB3ZSBtb3VudCwgbm90aWZ5IHRoZSBwYXJlbnQgdmlhIHF1ZXVlTWljcm90YXNrXG4gICAgICAgIC8vIChldmVyeSBjaGlsZCBkb2VzIHRoaXMsIHNvIGV2ZXJ5dGhpbmcncyBjb29yZGluYXRlZCB0byBvbmx5IHF1ZXVlIGEgc2luZ2xlIG1pY3JvdGFzayBwZXIgdGljaylcbiAgICAgICAgLy8gRG8gdGhlIHNhbWUgb24gdW5tb3VudC5cbiAgICAgICAgLy8gTm90ZTogSXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIGNvbWVzIEFGVEVSIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZFxuICAgICAgICAvLyBzbyB0aGF0IHJlbW90ZVVMRUNoaWxkTW91bnRlZCBoYXMgYWNjZXNzIHRvIGFsbCB0aGUgaW5mbyBvbiBtb3VudC5cbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZm8uaW5kZXggYXMgVCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5mby5pbmRleCBhcyBULCBmYWxzZSk7XG4gICAgICAgIH0sIFtpbmZvLmluZGV4XSk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG5cbiAgICBjb25zdCBtYW5hZ2VkQ2hpbGRyZW4gPSB1c2VSZWY8TWFuYWdlZENoaWxkcmVuPFQsIEMsIEs+Pih7XG4gICAgICAgIC4uLnsgXzogbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudCB9IGFzIHt9LFxuICAgICAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGQsXG4gICAgICAgIGdldEF0OiBnZXRNYW5hZ2VkQ2hpbGRJbmZvLFxuICAgICAgICBnZXRIaWdoZXN0SW5kZXg6IGdldEhpZ2hlc3RJbmRleCxcbiAgICAgICAgYXJyYXlTbGljZTogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZU1hbmFnZWRDaGlsZCxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuOiBtYW5hZ2VkQ2hpbGRyZW4uY3VycmVudCB9XG4gICAgfVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG5cbiAgICAvKipcbiAgICAgKiBXaGljaCBjaGlsZCBpcyBjb25zaWRlcmVkIGFjdGl2ZSBvbiBtb3VudC5cbiAgICAgKiBcbiAgICAgKiBBZnRlciBtb3VudCwgY2hhbmdlIHRoZSBjdXJyZW50IGFjdGl2ZSBjaGlsZCB3aXRoIGBjaGFuZ2VJbmRleGAuXG4gICAgICovXG4gICAgaW5pdGlhbEluZGV4OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBwcm92aWRlZCwgaWYgdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4IGRvZXNuJ3QgbWFwIG9udG8gYW55XG4gICAgICogcHJvdmlkZWQgY2hpbGQgKGVpdGhlciBiZWNhdXNlIGl0J3MgdG9vIGxhcmdlIG9yIHRoYXQgY2hpbGRcbiAgICAgKiBkb2Vzbid0IGV4aXN0KSwgdGhlIGNsb3Nlc3QgY2hpbGQgdG8gdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4XG4gICAgICogd2lsbCBoYXZlIGl0cyBmbGFnIHNldCBpbnN0ZWFkLlxuICAgICAqIFxuICAgICAqIFVzZSB3aXRoIGNhdXRpb24sIGFuZCBjb25zaWRlciBob3cgYSBjaGlsZCBoYXZpbmcgaXRzIGZsYWcgc2V0XG4gICAgICogd2hpbGUgdGhlIHBhcmVudCB0aGlua3MgaXQgc2hvdWxkbid0IGJlIGNvdWxkIGNhdXNlIGlzc3Vlcy5cbiAgICAgKi9cbiAgICAvL2Nsb3Nlc3RGaXQ/OiBib29sZWFuO1xuICAgIGNsb3Nlc3RGaXQ6IGJvb2xlYW47XG5cbiAgICBjaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz47XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBuZXcgaW5kZXggaXMgc2VsZWN0ZWQuXG4gICAgICogXG4gICAgICogTm90YWJseSwgdGhlIHZhbHVlIGNhbiBiZSBkaWZmZXJlbnQgdGhhbiB3aGF0IHdhcyBjYWxsZWQgd2l0aCBjaGFuZ2VJbmRleCgpXG4gICAgICogaWYgdGhlIHJlcXVlc3RlZCBpbmRleCBkaWRuJ3QgZXhpc3Qgb3Igd2FzIGhpZGRlbi5cbiAgICAgKi9cbiAgICBvbkluZGV4Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8bnVtYmVyIHwgbnVsbD47XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNoaWxkcmVuIGhhdmUgbXVsdGlwbGUgZmxhZ3MsIHRoZSBga2V5YCBwYXJhbWV0ZXIgY29udHJvbHMgd2hpY2ggZmxhZyB3ZSdyZSBjaGVja2luZy5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGNhbiBiZSBhbnl0aGluZyB5b3Ugd2FudCwgYnV0IG11c3Qgbm90IGNoYW5nZS5cbiAgICAgKi9cbiAgICBrZXk6IEs7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBDaGlsZEZsYWdPcGVyYXRpb25zIHtcblxuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuIHdoZXRoZXIgdGhlIGN1cnJlbnQgY2hpbGQgaXMgYWN0aXZlXG4gICAgICovXG4gICAgZ2V0OiAoKSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBjaGlsZCBtdXN0IHNldCBpdHNlbGYgYXMgYWN0aXZlL2luYWN0aXZlLCB3aGF0ZXZlciB0aGF0IGVudGFpbHMuXG4gICAgICogVGhpcyBjb3VsZCBiZSBhcyBzaW1wbGUgYXMgYSBzZXRTdGF0ZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzZXQ6IChhY3RpdmU6IGJvb2xlYW4pID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNoaWxkIGlzIGEgdmFsaWQgY2FuZGlkYXRlIHRvIGJlIGZsYWdnZWQsIGFuZCBmYWxzZSBpZiBub3QuXG4gICAgICogTW9zdCBjaGlsZHJlbiBzaG91bGQgcmV0dXJuIHRydWUuIFJldHVybmluZyBmYWxzZSBpcyBvbmx5IHVzZWZ1bCB0byBtYXJrIGEgY2hpbGQgYXMgXCJpbnZhbGlkXCIgaW4gc29tZSB3YXkuXG4gICAgICogUmVtb3ZpbmcgYSBjaGlsZCBmcm9tIHRoZSBsaXN0IGRvZXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcsIGJ1dCB0aGlzIGxldHMgeW91IGtlZXAgdGhlIGNoaWxkIGFyb3VuZC5cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCk6IGJvb2xlYW47XG59XG5cblxuLy9leHBvcnQgaW50ZXJmYWNlIEZsYWdnYWJsZUNoaWxkSW5mb0I8SyBleHRlbmRzIHN0cmluZz4geyBmbGFnczogUGFydGlhbDxSZWNvcmQ8SywgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+IH0gXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdSZXR1cm5UeXBlIHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGNoYW5nZUluZGV4OiAoYXJnOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0pID0+IG51bWJlciB8IG51bGw7XG4gICAgLyoqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgYSBjaGlsZCBtb3VudHMvdW5tb3VudHMsIG9yIHdoZW5ldmVyIGNhbGxpbmcgYSBjaGlsZCdzIGlzVmFsaWQoKSB3b3VsZCBjaGFuZ2VcbiAgICAgKiAgKi9cbiAgICByZWV2YWx1YXRlQ2xvc2VzdEZpdDogKCkgPT4gdm9pZDtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldEN1cnJlbnRJbmRleDogKCkgPT4gbnVtYmVyIHwgbnVsbDtcbn1cblxuLyoqXG4gKiBBbiBleHRlbnNpb24gdG8gdXNlTWFuYWdlZENoaWxkcmVuIHRoYXQgaGFuZGxlcyB0aGUgZm9sbG93aW5nIGNvbW1vbiBjYXNlOlxuICogMS4gWW91IGhhdmUgYSBidW5jaCBvZiBjaGlsZHJlblxuICogMi4gQXQgYW55IGdpdmVuIHRpbWUsIG9ubHkgMSBvZiB0aGVtIGlzIFwic2VsZWN0ZWRcIiwgXCJhY3RpdmF0ZWRcIiwgXCJmb2N1c2FibGVcIiwgd2hhdGV2ZXIgKG9yIDAgb2YgdGhlbSwgdGhhdCdzIGNvb2wgdG9vLCBqdXN0IDAgb3IgMSB0aG91Z2gpLlxuICogMy4gVGhlIHBhcmVudCBoYXMgY29udHJvbCBvdmVyIHdobyBpcyBcInNlbGVjdGVkXCIgdmlhIGEgbnVtZXJpY2FsIGluZGV4LlxuICogXG4gKiBUaGlzIGhvb2sgYWxsb3dzIGZvciBtdWNoIGVhc2llciBjb250cm9sIG92ZXIgc2VsZWN0aW9uIG1hbmFnZW1lbnQuXG4gKiBcbiAqIE5vdGUgdGhhdCBiZWNhdXNlIHlvdSBtYXkgd2FudCB0byB1c2UgbXVsdGlwbGUgZmxhZ3Mgd2l0aCB0aGUgc2FtZSBjaGlsZHJlbiwgdGhpcyBob29rICpkb2VzIG5vdCogdXNlIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIVxuICogWW91IG5lZWQgdG8gcGFzcyBpdCB0aGUgZXhpc3RpbmcgY2hpbGRyZW4sIGFuZCB5b3UgbXVzdCBwYXNzIHlvdXIgaW52b2NhdGlvbiBvZiBgdXNlTWFuYWdlZENoaWxkcmVuYCB0aGUgcmV0dXJuZWQgYG9uQ2hpbGRyZW5Nb3VudENoYW5nZWAgaGFuZGxlciFcbiAqIFxuICogQWxzbyBiZWNhdXNlIG9mIHRoYXQsIHRoZSB0eXBlcyBvZiB0aGlzIGZ1bmN0aW9uIGFyZSByYXRoZXIgb2RkLiAgSXQncyBiZXR0ZXIgdG8gc3RhcnQgb2ZmIHVzaW5nIGEgaG9vayB0aGF0IGFscmVhZHkgdXNlcyBhIGZsYWcsIHN1Y2ggYXMgYHVzZVJvdmluZ1RhYkluZGV4YCwgYXMgYW4gZXhhbXBsZS5cbiAqIFxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGlsZHJlbkZsYWc8QywgSyBleHRlbmRzIHN0cmluZz4oeyBjaGlsZHJlbiwgaW5pdGlhbEluZGV4LCBjbG9zZXN0Rml0LCBvbkluZGV4Q2hhbmdlLCBrZXkgfTogVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxDLCBLPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGUge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUNoaWxkcmVuRmxhZ1wiLCBvbkluZGV4Q2hhbmdlLCBrZXkpO1xuXG4gICAgY29uc3QgW2dldEN1cnJlbnRJbmRleCwgc2V0Q3VycmVudEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgbnVtYmVyPihvbkluZGV4Q2hhbmdlLCB1c2VDYWxsYmFjaygoKSA9PiAoaW5pdGlhbEluZGV4ID8/IChudWxsKSksIFtdKSk7XG5cbiAgICBjb25zdCBbZ2V0UmVxdWVzdGVkSW5kZXgsIHNldFJlcXVlc3RlZEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgbnVtYmVyPihudWxsLCB1c2VDYWxsYmFjaygoKSA9PiAoaW5pdGlhbEluZGV4ID8/IChudWxsKSksIFtdKSk7XG5cbiAgICAvLyAgICBjb25zdCBnZXRGaXROdWxsVG9aZXJvID0gdXNlU3RhYmxlR2V0dGVyKGZpdE51bGxUb1plcm8pO1xuXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gb25DaGlsZHJlbk1vdW50Q2hhbmdlIGFuZCBjaGFuZ2VJbmRleCwgbm90IHB1YmxpYyAoYnV0IGNvdWxkIGJlIEkgZ3Vlc3MpXG4gICAgY29uc3QgZ2V0Q2xvc2VzdEZpdCA9IHVzZUNhbGxiYWNrKChyZXF1ZXN0ZWRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IGNsb3Nlc3RJbmRleDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQuZmxhZ3M/LltrZXldPy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKGNoaWxkLmluZGV4IC0gcmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIGNoaWxkLmluZGV4IDwgcmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBjaGlsZC5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAxLiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGNoaWxkIHVubW91bnRlZFxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxuICAgIGNvbnN0IHJlZXZhbHVhdGVDbG9zZXN0Rml0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ZWRJbmRleCA9IGdldFJlcXVlc3RlZEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2hpbGQgPSBjdXJyZW50SW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChjdXJyZW50SW5kZXgpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCAhPSBudWxsICYmIGNsb3Nlc3RGaXQgJiYgKHJlcXVlc3RlZEluZGV4ICE9IGN1cnJlbnRJbmRleCB8fCBjdXJyZW50Q2hpbGQgPT0gbnVsbCB8fCAhY3VycmVudENoaWxkLmZsYWdzPy5ba2V5XT8uaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgY3VycmVudENoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChjbG9zZXN0Rml0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdENoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY2xvc2VzdEZpdENoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XG4gICAgICAgICAgICAgICAgY2xvc2VzdEZpdENoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gdXNlQ2FsbGJhY2soKGFyZzogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcoZ2V0UmVxdWVzdGVkSW5kZXgoKSkgOiBhcmc7XG4gICAgICAgIC8vaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwgJiYgZ2V0Rml0TnVsbFRvWmVybygpKVxuICAgICAgICAvLyAgICByZXF1ZXN0ZWRJbmRleCA9IDA7XG5cbiAgICAgICAgc2V0UmVxdWVzdGVkSW5kZXgocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSByZXF1ZXN0ZWRJbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcblxuICAgICAgICBsZXQgbmV3TWF0Y2hpbmdDaGlsZCA9IChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KHJlcXVlc3RlZEluZGV4KSk7XG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBFYXN5IGNhc2VcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsKTtcbiAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5ld01hdGNoaW5nQ2hpbGQgJiYgbmV3TWF0Y2hpbmdDaGlsZC5mbGFncz8uW2tleV0hLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChyZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5zZXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQobmV3TWF0Y2hpbmdDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5zZXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0Rml0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbml0aWFsSW5kZXggIT0gbnVsbClcbiAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KGluaXRpYWxJbmRleCk/LmZsYWdzPy5ba2V5XT8uc2V0KHRydWUpO1xuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0LCBnZXRDdXJyZW50SW5kZXggfTtcbn1cblxuIiwiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERvY3VtZW50KGVsZW1lbnQ/OiBOb2RlKSB7IHJldHVybiAoZWxlbWVudD8ub3duZXJEb2N1bWVudCA/PyBkb2N1bWVudCA/PyB3aW5kb3cuZG9jdW1lbnQgPz8gZ2xvYmFsVGhpcy5kb2N1bWVudCk7IH1cblxudHlwZSBQID0gUGFyYW1ldGVyczx0eXBlb2YgY2xzeD47XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEb2N1bWVudENsYXNzKGNsYXNzTmFtZTogUFswXSwgYWN0aXZlPzogYm9vbGVhbiwgZWxlbWVudD86IEhUTUxFbGVtZW50KSB7XG4gICAgZWxlbWVudCA/Pz0gZ2V0RG9jdW1lbnQoKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgY2xhc3NOYW1lID0gY2xzeChjbGFzc05hbWUpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlbGVtZW50IS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LCBbY2xhc3NOYW1lLCBhY3RpdmUsIGVsZW1lbnRdKTtcblxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbih7IGNoaWxkcmVuOiBsaHMgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwiY2hpbGRyZW5cIj4sIHsgY2hpbGRyZW46IHJoc306IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcImNoaWxkcmVuXCI+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0ge1xuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCBsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgZGVmYXVsdCBhcyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXHJcbiAqIER1cGxpY2F0ZSBjbGFzc2VzIGFyZSByZW1vdmVkIChvcmRlciBkb2Vzbid0IG1hdHRlciBhbnl3YXkpLlxyXG4gKiBcclxuICogQHBhcmFtIGxocyBDbGFzc2VzIG9mIHRoZSBmaXJzdCBjb21wb25lbnRcclxuICogQHBhcmFtIHJocyBDbGFzc2VzIG9mIHRoZSBzZWNvbmQgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgY29tYmluZWQgY2xhc3NlcyBmcm9tIGJvdGggYXJndW1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENsYXNzZXM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0Pih7IGNsYXNzOiBsaHNDbGFzcywgY2xhc3NOYW1lOiBsaHNDbGFzc05hbWUgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgXCJjbGFzc1wiIHwgXCJjbGFzc05hbWVcIj4sIHsgY2xhc3M6IHJoc0NsYXNzLCBjbGFzc05hbWU6IHJoc0NsYXNzTmFtZX06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHJcbiAgICAvLyBOb3RlOiBGb3IgdGhlIHNha2Ugb2YgZm9yd2FyZCBjb21wYXRpYmlsaXR5LCB0aGlzIGZ1bmN0aW9uIGlzIGxhYmVsbGVkIGFzXHJcbiAgICAvLyBhIGhvb2ssIGJ1dCBhcyBpdCB1c2VzIG5vIG90aGVyIGhvb2tzIGl0IHRlY2huaWNhbGx5IGlzbid0IG9uZS5cclxuXHJcbiAgICBpZiAobGhzQ2xhc3MgfHwgcmhzQ2xhc3MgfHwgbGhzQ2xhc3NOYW1lIHx8IHJoc0NsYXNzTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGxoc0NsYXNzZXMgPSBjbHN4KGxoc0NsYXNzLCBsaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgY29uc3QgYWxsQ2xhc3NlcyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20obGhzQ2xhc3NlcyksIC4uLkFycmF5LmZyb20ocmhzQ2xhc3NlcyldKVxyXG5cclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCwgUmVmLCBSZWZDYWxsYmFjaywgUmVmT2JqZWN0IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUmVmPFQ+KGluc3RhbmNlOiBUIHwgbnVsbCwgcmVmOiBSZWY8VD4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgKHJlZiBhcyBSZWZPYmplY3Q8VCB8IG51bGw+KS5jdXJyZW50ID0gaW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZhbHNlLCBcIlVua25vd24gcmVmIHR5cGUgZm91bmQgdGhhdCB3YXMgbmVpdGhlciBhIFJlZkNhbGxiYWNrIG5vciBhIFJlZk9iamVjdFwiKTtcclxuICAgIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFI8RT4ge1xyXG4gICAgcmVmPzogUmVmPEU+O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxyXG4gKiBAcGFyYW0gbGhzIFxyXG4gKiBAcGFyYW0gcmhzIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRSZWZzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyByZWY6IHJocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgeyByZWY6IGxocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikge1xyXG4gICAgY29uc3QgY29tYmluZWQ6IFJlZkNhbGxiYWNrPEU+ID0gdXNlQ2FsbGJhY2soKGN1cnJlbnQ6IEUgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCBsaHMpO1xyXG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcclxuICAgIH0sIFtsaHMsIHJoc10pO1xyXG5cclxuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQhO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmhzITtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxocyE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbmZ1bmN0aW9uIHN0eWxlU3RyaW5nVG9PYmplY3Qoc3R5bGU6IHN0cmluZyk6IGguSlNYLkNTU1Byb3BlcnRpZXMge1xyXG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhzdHlsZS5zcGxpdChcIjtcIikubWFwKHN0YXRlbWVudCA9PiBzdGF0ZW1lbnQuc3BsaXQoXCI6XCIpKSkgYXMgdW5rbm93biBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2VzIHR3byBzdHlsZSBvYmplY3RzLCByZXR1cm5pbmcgdGhlIHJlc3VsdC5cclxuICogXHJcbiAqIEBwYXJhbSBzdHlsZSBUaGUgdXNlci1naXZlbiBzdHlsZSBwcm9wIGZvciB0aGlzIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gb2JqIFRoZSBDU1MgcHJvcGVydGllcyB5b3Ugd2FudCBhZGRlZCB0byB0aGUgdXNlci1naXZlbiBzdHlsZVxyXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkU3R5bGVzKGxoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4sIHJoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSB7XHJcblxyXG4gICAgLy8gRWFzeSBjYXNlLCB3aGVuIHRoZXJlIGFyZSBubyBzdHlsZXMgdG8gbWVyZ2UgcmV0dXJuIG5vdGhpbmcuXHJcbiAgICBpZiAoIWxocz8uc3R5bGUgJiYgIXJocz8uc3R5bGUpXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XHJcbiAgICAgICAgLy8gRWFzeSBjYXNlcywgd2hlbiBvbmUgaXMgbnVsbCBhbmQgdGhlIG90aGVyIGlzbid0LlxyXG4gICAgICAgIGlmIChsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gbGhzLnN0eWxlO1xyXG4gICAgICAgIGlmICghbGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzLnN0eWxlO1xyXG5cclxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgdHlwZSB0byBhbiBvYmplY3QgYmFnIHR5cGUgYW5kIHJ1biBpdCBhZ2Fpbi5cclxuICAgICAgICBpZiAobGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKSB7XHJcbiAgICAgICAgICAgIC8vICh1c2VNZXJnZWRTdHlsZXMgaXNuJ3QgYSB0cnVlIGhvb2sgLS0gdGhpcyBpc24ndCBhIHZpb2xhdGlvbilcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKHsgc3R5bGU6IHN0eWxlU3RyaW5nVG9PYmplY3QobGhzPy5zdHlsZSBhcyBzdHJpbmcpIH0sIHJocykgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgeyBzdHlsZTogc3R5bGVTdHJpbmdUb09iamVjdChyaHM/LnN0eWxlIGFzIHN0cmluZykgfSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvZ2ljPz8/XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGV5J3JlIGJvdGggc3RyaW5ncywganVzdCBjb25jYXRlbmF0ZSB0aGVtLlxyXG4gICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gYCR7bGhzLnN0eWxlfTske3Jocz8uc3R5bGUgPz8gXCJcIn1gIGFzIHVua25vd24gYXMgc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZXkncmUgYm90aCBvYmplY3RzLCBqdXN0IG1lcmdlIHRoZW0uXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLihsaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgICAgIC4uLihyaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXHJcbiAgICB9IGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW5cIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2xhc3NlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2xhc3Nlc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1yZWZzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzXCI7XHJcblxyXG5sZXQgbG9nID0gY29uc29sZS53YXJuO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdQcm9wQ29uZmxpY3RzKGxvZzI6IHR5cGVvZiBjb25zb2xlW1wibG9nXCJdKSB7XHJcbiAgICBsb2cgPSBsb2cyXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAqIFxyXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxyXG4gKiBAcGFyYW0gbGhzMiBcclxuICogQHBhcmFtIHJoczIgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4obGhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgcmhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcclxuICAgIC8vIEZpcnN0LCBzZXBhcmF0ZSB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiBpbnRvIHR3byBncm91cHM6XHJcbiAgICAvLyBsaHNBbGwgYW5kIHJoc0FsbCBjb250YWluIGFsbCB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiwgYW5kXHJcbiAgICAvLyBsaHNNaXNjIGFuZCByaHNNaXNjIGNvbnRhaW4gYWxsIHByb3BzICpleGNlcHQqIGZvciB0aGUgZWFzeSBvbmVzXHJcbiAgICAvLyBsaWtlIGNsYXNzTmFtZSBhbmQgc3R5bGUgdGhhdCB3ZSBhbHJlYWR5IGtub3cgaG93IHRvIG1lcmdlLlxyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX2xoc0NoaWxkcmVuLCBjbGFzczogX2xoc0NsYXNzLCBjbGFzc05hbWU6IF9saHNDbGFzc05hbWUsIHN0eWxlOiBfbGhzU3R5bGUsIHJlZjogX2xoc1JlZiwgLi4ubGhzTWlzYyB9ID0gbGhzQWxsO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX3Joc0NoaWxkcmVuLCBjbGFzczogX3Joc0NsYXNzLCBjbGFzc05hbWU6IF9yaHNDbGFzc05hbWUsIHN0eWxlOiBfcmhzU3R5bGUsIHJlZjogX3Joc1JlZiwgLi4ucmhzTWlzYyB9ID0gcmhzQWxsO1xyXG5cclxuICAgIGNvbnN0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7XHJcbiAgICAgICAgLi4ubGhzTWlzYyxcclxuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIGNsYXNzTmFtZTogdXNlTWVyZ2VkQ2xhc3NlcyhsaHNBbGwsIHJoc0FsbCksXHJcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbCwgcmhzQWxsKSxcclxuICAgIH0gYXMgYW55O1xyXG5cclxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xyXG4gICAgaWYgKHJldC5zdHlsZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnN0eWxlO1xyXG4gICAgaWYgKHJldC5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jbGFzc05hbWU7XHJcbiAgICBpZiAocmV0LmNoaWxkcmVuID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2hpbGRyZW47XHJcblxyXG4gICAgLy8gTm93LCBkbyAqZXZlcnl0aGluZyogZWxzZVxyXG4gICAgLy8gTWVyZ2UgZXZlcnkgcmVtYWluaW5nIGV4aXN0aW5nIGVudHJ5IGluIGxocyB3aXRoIHdoYXQgd2UndmUgYWxyZWFkeSBwdXQgaW4gcmV0LlxyXG4gICAgLy9jb25zdCBsaHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMobGhzKSBhcyBba2V5b2YgVCwgVFtrZXlvZiBUXV1bXTtcclxuICAgIGNvbnN0IHJoc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhyaHNNaXNjKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtyaHNLZXlVLCByaHNWYWx1ZV0gb2YgcmhzRW50cmllcykge1xyXG4gICAgICAgIGNvbnN0IHJoc0tleSA9IHJoc0tleVUgYXMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcblxyXG4gICAgICAgIGNvbnN0IGxoc1ZhbHVlID0gbGhzTWlzY1tyaHNLZXkgYXMga2V5b2YgdHlwZW9mIGxoc01pc2NdO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGxoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgbWVyZ2VkIChvciBvbmUncyBhIGZ1bmN0aW9uIGFuZCB0aGUgb3RoZXIncyBudWxsKS5cclxuICAgICAgICAgICAgLy8gTm90IGFuICplYXN5KiBjYXNlLCBidXQgYSB3ZWxsLWRlZmluZWQgb25lLlxyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZUZ1bmN0aW9ucyhsaHNWYWx1ZSBhcyBuZXZlciwgcmhzVmFsdWUgYXMgbmV2ZXIpO1xyXG4gICAgICAgICAgICByZXRbcmhzS2V5IGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+XSA9IG1lcmdlZCBhcyBuZXZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XHJcbiAgICAgICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsICYmIHJoc1ZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IGxoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke3Joc0tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZSBhcyBuZXZlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUZ1bmN0aW9uczxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4obGhzOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBVIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG5cclxuICAgIGlmICghbGhzKVxyXG4gICAgICAgIHJldHVybiByaHM7XHJcbiAgICBpZiAoIXJocylcclxuICAgICAgICByZXR1cm4gbGhzO1xyXG5cclxuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHJ2ID0gcmhzKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qXHJcbmZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG5cclxuICAgIGNvbnN0IGlkMDogR2VuZXJpY0dldDx7fSwgXCJpZFwiLCBzdHJpbmc+ID0gXCJcIjtcclxuICAgIGNvbnN0IGlkMzogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ0OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDU6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNjogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgLy9jb25zdCBpZDI6IFppcFNpbmdsZTxzdHJpbmcgfCB1bmRlZmluZWQsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDE6IFppcE9iamVjdDx7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0geyBpZDogdW5kZWZpbmVkIH07XHJcblxyXG4gICAgdHlwZSBNMSA9IEdlbmVyaWNHZXQ8UCwgXCJzdHlsZVwiLCBzdHJpbmc+O1xyXG4gICAgdHlwZSBNMiA9IEdlbmVyaWNHZXQ8e30sIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIGNvbnN0IG0xOiBNMSA9IFwiXCI7XHJcbiAgICBjb25zdCBtMjogTTEgPSB1bmRlZmluZWQ7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xyXG4gICAgY29uc3QgbTM6IE0xID0gMDtcclxuXHJcbiAgICBjb25zdCBtNDogTTIgPSBcIlwiO1xyXG4gICAgY29uc3QgbTU6IE0yID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG02OiBNMiA9IDA7XHJcblxyXG4gICAgY29uc3QgcDE6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDI6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDM6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNDogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHt9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHt9KTtcclxuICAgIGNvbnN0IHA1ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywge30pO1xyXG4gICAgY29uc3QgcDYgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNyA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IFwic3RyaW5nXCIgfSk7XHJcblxyXG5cclxuICAgIHAxLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwMi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcDMuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHA0LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHA1LmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDcuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNy5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDUuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA3LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBpdCB3b3JrcyByZWN1cnNpdmVseVxyXG4gICAgY29uc3QgcjFhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDEpO1xyXG4gICAgY29uc3QgcjFiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDEpO1xyXG4gICAgY29uc3QgcjJhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDIpO1xyXG4gICAgY29uc3QgcjJiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDIpO1xyXG4gICAgY29uc3QgcjNhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDMpO1xyXG4gICAgY29uc3QgcjNiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDMpO1xyXG4gICAgY29uc3QgcjRhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDQpO1xyXG4gICAgY29uc3QgcjRiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDQpO1xyXG4gICAgY29uc3QgcjVhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDUpO1xyXG4gICAgY29uc3QgcjViID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDUpO1xyXG4gICAgY29uc3QgcjZhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDYpO1xyXG4gICAgY29uc3QgcjZiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDYpO1xyXG4gICAgY29uc3QgcjdhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDcpO1xyXG4gICAgY29uc3QgcjdiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDcpO1xyXG5cclxuXHJcbiAgICByMWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIxYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcjNhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByM2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHI0YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjRiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHI1YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjViLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI2Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByN2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNWEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjViLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI2YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmIuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjdhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3Yi5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjVhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjViLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG59XHJcbmZ1bmN0aW9uIGFjY2VwdHNOZXZlcihuOiBuZXZlcikge31cclxuKi8iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGdldEVsZW1lbnQoKTogVCB8IG51bGw7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlUmVmRWxlbWVudFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcclxuICAgIG9uRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsPjtcclxuICAgIG9uTW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcclxuICAgIG9uVW5tb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogQWxsb3dzIGFjY2Vzc2luZyB0aGUgZWxlbWVudCBhIHJlZiByZWZlcmVuY2VzIGFzIHNvb24gYXMgaXQgZG9lcyBzby5cclxuICogKlRoaXMgaG9vayBpdHNlbGYgcmV0dXJucyBhIGhvb2sqLS11c2VSZWZFbGVtZW50UHJvcHMgbW9kaWZpZXMgdGhlIHByb3BzIHRoYXQgeW91IHdlcmUgZ29pbmcgdG8gcGFzcyB0byBhbiBIVE1MRWxlbWVudCwgXHJcbiAqIGFkZGluZyBhIFJlZkNhbGxiYWNrIGFuZCBtZXJnaW5nIGl0IHdpdGggYW55IGV4aXN0aW5nIHJlZiB0aGF0IGV4aXN0ZWQgb24gdGhlIHByb3BzLlxyXG4gKiBcclxuICogRG9uJ3QgZm9yZ2V0IHRvIHByb3ZpZGUgdGhlIEVsZW1lbnQgYXMgdGhlIHR5cGUgYXJndW1lbnQhXHJcbiAqIFxyXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudCwgYW5kIHRoZSBzdWItaG9vayB0aGF0IG1ha2VzIGl0IHJldHJpZXZhYmxlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnQ8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PihhcmdzPzogVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4pOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiB7XHJcbiAgICBjb25zdCB7IG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50IH0gPSAoYXJncyA/PyB7fSk7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUmVmRWxlbWVudFwiLCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCk7XHJcblxyXG4gICAgLy8gQ2FsbGVkIChpbmRpcmVjdGx5KSBieSB0aGUgcmVmIHRoYXQgdGhlIGVsZW1lbnQgcmVjZWl2ZXMuXHJcbiAgICBjb25zdCBoYW5kbGVyID0gdXNlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGw+PigoZSwgcHJldlZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IG9uRWxlbWVudENoYW5nZT8uKGUsIHByZXZWYWx1ZSk7XHJcbiAgICAgICAgaWYgKHByZXZWYWx1ZSlcclxuICAgICAgICAgICAgb25Vbm1vdW50Py4ocHJldlZhbHVlISk7XHJcblxyXG4gICAgICAgIGlmIChlKVxyXG4gICAgICAgICAgICBvbk1vdW50Py4oZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIC8vIExldCB1cyBzdG9yZSB0aGUgYWN0dWFsIChyZWZlcmVuY2UgdG8pIHRoZSBlbGVtZW50IHdlIGNhcHR1cmVcclxuICAgIGNvbnN0IFtnZXRFbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxUIHwgbnVsbD4oaGFuZGxlciwgcmV0dXJuTnVsbCwgcnVuSW1tZWRpYXRlbHkpO1xyXG4gICAgY29uc3QgdXNlUmVmRWxlbWVudFByb3BzID0gdXNlQ2FsbGJhY2s8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD5bXCJ1c2VSZWZFbGVtZW50UHJvcHNcIl0+KChwcm9wcykgPT4gdXNlTWVyZ2VkUHJvcHM8VD4oeyByZWY6IHNldEVsZW1lbnQgfSwgcHJvcHMpLCBbXSk7XHJcblxyXG4gICAgLy8gUmV0dXJuIGJvdGggdGhlIGVsZW1lbnQgYW5kIHRoZSBob29rIHRoYXQgbW9kaWZpZXMgXHJcbiAgICAvLyB0aGUgcHJvcHMgYW5kIGFsbG93cyB1cyB0byBhY3R1YWxseSBmaW5kIHRoZSBlbGVtZW50XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVJlZkVsZW1lbnRQcm9wcyxcclxuICAgICAgICBnZXRFbGVtZW50XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJ1bkltbWVkaWF0ZWx5KGY6ICgpID0+IHZvaWQpIHtcclxuICAgIGYoKTtcclxufVxyXG4iLCJpbXBvcnQgeyBoLCBQcmVhY3RET01BdHRyaWJ1dGVzIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB1c2VkIHRvIHNlbGVjdCAqanVzdCogdGhlIHR5cGVkIGFkZEV2ZW50TGlzdGVuZXIgXHJcbiAqIGFuZCBub3QgdGhlIGdlbmVyaWMgXCJJJ2xsIGFjY2VwdCBhbnkgc3RyaW5nIGFuZCBhbnkgaGFuZGxlclwiIG9uZS5cclxuICogXHJcbiAqIFRPRE86IFRoaXMgXCJcIlwid29ya3NcIlwiXCIgYnV0IGl0J3Mgbm90IGdyZWF0IGFuZCBpbXBsaWNpdGx5IHJlbGllcyBvblxyXG4gKiBsaWIuZG9tLnRzIGFsd2F5cyBnaXZlaW5nIHRoZSB0d28gb3ZlcmxvYWRzIGluIHRoZSBzYW1lIG9yZGVyLCB3aXRoIHRoZVxyXG4gKiB0eXBlZCBvbmUgZmlyc3QuICpUaGF0KiBwcm9iYWJseSB3b24ndCBjaGFuZ2UsIGJ1dCBpZiBtb3JlIG92ZXJsb2Fkc1xyXG4gKiBhcmUgZXZlciBhZGRlZCB0aGlzIHdpbGwgbmVlZCBhZGp1c3RtZW50LlxyXG4gKiBcclxuICogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mjc2MTE1NiBmb3IgaG93IHNlbGVjdGluZyB0aGUgY29ycmVjdCBvdmVybG9hZCB3b3Jrcy5cclxuICovXHJcbnR5cGUgRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8VD4gPVxyXG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBpbmZlciBSIH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueSB9ID8gUiA6XHJcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55IH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUikgPT4gYW55ID8gUiA6IFtdO1xyXG5cclxuLy8gR2V0IGp1c3QgdGhlIHR5cGVkIHZlcnNpb24gb2YgYWRkRXZlbnRMaXN0ZW5lciwgaWYgaXQgZXhpc3RzXHJcbnR5cGUgVHlwZWRBZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSAoLi4uYXJnczogRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8KFRbXCJhZGRFdmVudExpc3RlbmVyXCJdKT4pID0+IHZvaWQ7XHJcblxyXG4vLyBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBcImFkZEV2ZW50TGlzdGVuZXJcIiAodGhlIGV2ZW50IHR5cGUgYXMgYSBzdHJpbmcpXHJcbnR5cGUgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPiBleHRlbmRzICgodHlwZTogaW5mZXIgSzIsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSzIgOiBzdHJpbmc7XHJcblxyXG5cclxuLy8gVE9ETzogVGhpcyBpc24ndCBxdWl0ZSBhYmxlIHRvIG5hcnJvdyBkb3duIHRoZSBleGFjdCBldmVudCB0eXBlIGZvciB1bmtub3duIHJlYXNvbnMuXHJcbi8vIEluc3RlYWQgaXQgcmV0dXJucyBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgZXZlbnQgdHlwZXMsIHdoaWNoIGlzLi4uZmluZSwgSSBndWVzcy5cclxuLy8gSSBkb24ndCBrbm93IHdoeSBgaW5mZXIgSGAgaXMgZG9pbmcgdGhhdCB3aGVuIHRoZSB0eXBlIHNob3VsZCBiZSBuYXJyb3dlZCBieSBgVGAgdGhvdWdoLi4uXHJcbi8vIE5vdGUgdGhhdCB0aGUgdHlwZSBwYXJhbWV0ZXIgaXMgc3RpbGwgdXNlZCwgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBuYXJyb3cgZG93biB0aGUgdHlwZSxcclxuLy8gYmVjYXVzZSBvdGhlcndpc2UsIGluc3RlYWQgb2YgYmVpbmcgYSB1bmlvbiBvZiBhbGwgdHlwZXMsIGl0J3MganVzdCBgYW55YFxyXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyPEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVCBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPEU+PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxFPiBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogaW5mZXIgSCwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBOb25OdWxsYWJsZTxIPiA6IG5ldmVyO1xyXG4vLygoVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+ICYgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWQsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpKSBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogKGU6IGluZmVyIEgpID0+IGFueSwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBIIDogRnVuY3Rpb24pIC8qJiAoVCBleHRlbmRzIGtleW9mIEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcD8gR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwW1RdIDogKGU6IEV2ZW50KSA9PiB2b2lkKSovO1xyXG5cclxudHlwZSBQYXJhbWV0ZXJzMjxUIGV4dGVuZHMgKEV2ZW50TGlzdGVuZXJPYmplY3QgfCAoKC4uLmFyZ3M6IGFueSkgPT4gYW55KSk+ID1cclxuICAgIFQgZXh0ZW5kcyBFdmVudExpc3RlbmVyT2JqZWN0ID8gUGFyYW1ldGVyczxUW1wiaGFuZGxlRXZlbnRcIl0+IDpcclxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUCkgPT4gYW55ID8gUCA6IG5ldmVyO1xyXG5cclxuXHJcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFQgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFPj4gPSBQYXJhbWV0ZXJzMjxUeXBlZEV2ZW50SGFuZGxlcjxFLCBUPj5bMF07XHJcblxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBhdHRhY2hpbmcgYW4gZXZlbnQgaGFuZGxlciB0byBhbnkgKm5vbi1QcmVhY3QqIGVsZW1lbnQsIGFuZCByZW1vdmluZyBpdCB3aGVuIHRoZSBjb21wb25lbnQgdXNpbmcgdGhlIGhvb2sgdW5tb3VudHMuIFRoZSBjYWxsYmFjayBkb2VzIG5vdCBuZWVkIHRvIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cclxuICogXHJcbiAqIER1ZSB0byB0eXBpbmcgbGltaXRhdGlvbnMsIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgbGlrZSB0aGlzOlxyXG4gKiBcclxuICogYHVzZUV2ZW50SGFuZGxlcihlbGVtZW50LCBcImlucHV0XCIpPElucHV0RXZlbnQ+KGUgPT4ge30pYFxyXG4gKiBcclxuICogVGhlIHR5cGUgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGJ1dCBuYXJyb3dzIGRvd24gdGhlIHR5cGUgZnJvbSBcImEgdW5pb24gb2YgYWxsIGV2ZW50c1wiIHRvIHdoYXRldmVyIHlvdSBzcGVjaWZ5LCBhbmQgZXJyb3JzIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXHJcbiAqIFxyXG4gKiBUaGVyZSBpcyBhIHNlcGFyYXRlIHZlcnNpb24gdGhhdCBhdHRhY2hlcyBldmVudCBoYW5kbGVycyB0byBhIHNldCBvZiBwcm9wcy4gXHJcbiAqIEl0IHRha2VzIGRpZmZlcmVudCBldmVudCBzdHJpbmcgdHlwZXMgKG9uRXZlbnQgdnMgb25ldmVudCkuXHJcbiAqIFxyXG4gKiBAcGFyYW0gdGFyZ2V0IEEgKm5vbi1QcmVhY3QqIG5vZGUgdG8gYXR0YWNoIHRoZSBldmVudCB0by5cclxuICogQHJldHVybnNcclxuICogKlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdsb2JhbEhhbmRsZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPiwgSCBleHRlbmRzIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8VCwgRXZlbnRUeXBlPj4odGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCAoKGU6IEgpID0+IHZvaWQpLCBvcHRpb25zPzogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdKTogdm9pZCB7XHJcblxyXG4gICAgLy8gTm90ZSB0byBzZWxmOiBUaGUgdHlwaW5nIGRvZXNuJ3QgaW1wcm92ZSBldmVuIGlmIHRoaXMgaXMgc3BsaXQgdXAgaW50byBhIHN1Yi1mdW5jdGlvbi5cclxuICAgIC8vIE5vIG1hdHRlciB3aGF0LCBpdCBzZWVtcyBpbXBvc3NpYmxlIHRvIGdldCB0aGUgaGFuZGxlcidzIGV2ZW50IG9iamVjdCB0eXBlZCBwZXJmZWN0bHkuXHJcbiAgICAvLyBJdCBzZWVtcyBsaWtlIGl0J3MgZ3VhcmFudGVlZCB0byBhbHdheXMgYmUgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIHR1cGVzLlxyXG4gICAgLy8gQWdhaW4sIG5vIG1hdHRlciB3aGF0IGNvbWJpbmF0aW9uIG9mIHN1Yi0gb3Igc3ViLXN1Yi1mdW5jdGlvbnMgdXNlZC5cclxuXHJcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjayhoYW5kbGVyID8/ICgoKSA9PiB7IH0pKSBhcyBFdmVudExpc3RlbmVyO1xyXG4gICAgaWYgKGhhbmRsZXIgPT0gbnVsbClcclxuICAgICAgICBzdGFibGVIYW5kbGVyID0gbnVsbDtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChzdGFibGVIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGFsdGVybmF0aXZlIHdheSB0byBhZGQgYW4gZXZlbnQgaGFuZGxlciB0byBhbiBlbGVtZW50LiBVc2VmdWwgcHJpbWFyaWx5IHdoZW4gaW50ZWdyYXRpbmcgM3JkIHBhcnR5IGxpYnJhcmllcyB0aGF0IGV4cGVjdCBhIGdlbmVyaWMgXCJhZGQgZXZlbnQgaGFuZGxlclwiIGZ1bmN0aW9uLlxyXG4gKiBcclxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHlvdSB0byBtb2RpZnkgYSBzZXQgb2YgcHJvcHMgdG8gYXBwbHkgdGhpcyBoYW5kbGVyLlxyXG4gKiBcclxuICogRm9yIHR5cGluZyByZWFzb25zLCB0aGlzIGZ1bmN0aW9uIGlzIHNwbGl0IGludG8gdHdvLiAgVXNhZ2UgaXMgbGlrZSB0aGUgZm9sbG93aW5nOlxyXG4gKiBcclxuICogYGBgXHJcbiAqIGNvbnN0IHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9ID0gdXNlTG9jYWxFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+KCkoXCJvbk1vdXNlRG93blwiLCBlID0+IHsgIH0pO1xyXG4gKiBjb25zdCBkaXZQcm9wcyA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMocHJvcHMpO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbEhhbmRsZXI8RWxlbWVudFR5cGUgZXh0ZW5kcyAoSFRNTEVsZW1lbnRUYWdOYW1lTWFwW2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcF0gfCBTVkdFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcF0pPigpIHtcclxuICAgIHJldHVybiB1c2VDYWxsYmFjayg8RXZlbnRUeXBlIGV4dGVuZHMgRXhjbHVkZTxrZXlvZiBoLkpTWC5ET01BdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPiwga2V5b2YgUHJlYWN0RE9NQXR0cmlidXRlcz4+KHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogTm9uTnVsbGFibGU8aC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT5bRXZlbnRUeXBlXT4pID0+IHtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhYmxlSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIpO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFbGVtZW50VHlwZT4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEVsZW1lbnRUeXBlPih7IFt0eXBlXTogc3RhYmxlSGFuZGxlciB9IGFzIHsgW0sgaW4gRXZlbnRUeXBlXTogdHlwZW9mIGhhbmRsZXIgfSwgcHJvcHMpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPjtcclxuICAgICAgICB9LCBbdHlwZV0pO1xyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH07XHJcblxyXG4gICAgfSwgW10pO1xyXG59XHJcbiIsImNvbnN0IGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFtcbiAgJ2lucHV0JyxcbiAgJ3NlbGVjdCcsXG4gICd0ZXh0YXJlYScsXG4gICdhW2hyZWZdJyxcbiAgJ2J1dHRvbicsXG4gICdbdGFiaW5kZXhdOm5vdChzbG90KScsXG4gICdhdWRpb1tjb250cm9sc10nLFxuICAndmlkZW9bY29udHJvbHNdJyxcbiAgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0pJyxcbiAgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyxcbiAgJ2RldGFpbHMnLFxuXTtcbmNvbnN0IGNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovIGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJyk7XG5cbmNvbnN0IE5vRWxlbWVudCA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJztcblxuY29uc3QgbWF0Y2hlcyA9IE5vRWxlbWVudFxuICA/IGZ1bmN0aW9uICgpIHt9XG4gIDogRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG5jb25zdCBnZXRSb290Tm9kZSA9XG4gICFOb0VsZW1lbnQgJiYgRWxlbWVudC5wcm90b3R5cGUuZ2V0Um9vdE5vZGVcbiAgICA/IChlbGVtZW50KSA9PiBlbGVtZW50LmdldFJvb3ROb2RlKClcbiAgICA6IChlbGVtZW50KSA9PiBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBjb250YWluZXIgdG8gY2hlY2sgaW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIHRvIGNoZWNrXG4gKiBAcGFyYW0geyhub2RlOiBFbGVtZW50KSA9PiBib29sZWFufSBmaWx0ZXIgZmlsdGVyIGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50W119XG4gKi9cbmNvbnN0IGdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoZWwsIGluY2x1ZGVDb250YWluZXIsIGZpbHRlcikge1xuICBsZXQgY2FuZGlkYXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShcbiAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9yKVxuICApO1xuICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gIH1cbiAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgR2V0U2hhZG93Um9vdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrIGZvciBzaGFkb3cgcm9vdFxuICogQHJldHVybnMge1NoYWRvd1Jvb3R8Ym9vbGVhbn0gU2hhZG93Um9vdCBpZiBhdmFpbGFibGUgb3IgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgc2hhZG93Um9vdCBpcyBhdHRhY2hlZCBidXQgbm90IGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTaGFkb3dSb290RmlsdGVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHNoYWRvd0hvc3ROb2RlIHRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHNoYWRvdyBjb250ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIHNoYWRvdyByb290IGNvdWxkIHBvdGVudGlhbGx5IGNvbnRhaW4gdmFsaWQgY2FuZGlkYXRlcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbmRpZGF0ZXNTY29wZVxuICogQHByb3BlcnR5IHtFbGVtZW50fSBzY29wZSBjb250YWlucyBpbm5lciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge0VsZW1lbnRbXX0gY2FuZGlkYXRlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSXRlcmF0aXZlT3B0aW9uc1xuICogQHByb3BlcnR5IHtHZXRTaGFkb3dSb290fGJvb2xlYW59IGdldFNoYWRvd1Jvb3QgdHJ1ZSBpZiBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkOyBmYWxzeSBpZiBub3Q7XG4gKiAgaWYgYSBmdW5jdGlvbiwgaW1wbGllcyBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkIGFuZCBlaXRoZXIgcmV0dXJucyB0aGUgc2hhZG93IHJvb3Qgb2YgYW4gZWxlbWVudFxuICogIG9yIGEgYm9vbGVhbiBzdGF0aW5nIGlmIGl0IGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgcm9vdFxuICogQHByb3BlcnR5IHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZsYXR0ZW4gaWYgdHJ1ZSB0aGVuIHJlc3VsdCB3aWxsIGZsYXR0ZW4gYW55IENhbmRpZGF0ZXNTY29wZSBpbnRvIHRoZSByZXR1cm5lZCBsaXN0XG4gKiBAcHJvcGVydHkge1NoYWRvd1Jvb3RGaWx0ZXJ9IHNoYWRvd1Jvb3RGaWx0ZXIgZmlsdGVyIHNoYWRvdyByb290cztcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50cyBsaXN0IG9mIGVsZW1lbnQgY29udGFpbmVycyB0byBtYXRjaCBjYW5kaWRhdGVzIGZyb21cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIGxpc3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7SXRlcmF0aXZlT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZXNTY29wZT59XG4gKi9cbmNvbnN0IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseSA9IGZ1bmN0aW9uIChcbiAgZWxlbWVudHMsXG4gIGluY2x1ZGVDb250YWluZXIsXG4gIG9wdGlvbnNcbikge1xuICBjb25zdCBjYW5kaWRhdGVzID0gW107XG4gIGNvbnN0IGVsZW1lbnRzVG9DaGVjayA9IEFycmF5LmZyb20oZWxlbWVudHMpO1xuICB3aGlsZSAoZWxlbWVudHNUb0NoZWNrLmxlbmd0aCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1RvQ2hlY2suc2hpZnQoKTtcbiAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnU0xPVCcpIHtcbiAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNsb3Qgc2NvcGUgKHNsb3QgaXRzZWxmIGNhbm5vdCBiZSBmb2N1c2FibGUpXG4gICAgICBjb25zdCBhc3NpZ25lZCA9IGVsZW1lbnQuYXNzaWduZWRFbGVtZW50cygpO1xuICAgICAgY29uc3QgY29udGVudCA9IGFzc2lnbmVkLmxlbmd0aCA/IGFzc2lnbmVkIDogZWxlbWVudC5jaGlsZHJlbjtcbiAgICAgIGNvbnN0IG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoY29udGVudCwgdHJ1ZSwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5uZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgc2NvcGU6IGVsZW1lbnQsXG4gICAgICAgICAgY2FuZGlkYXRlczogbmVzdGVkQ2FuZGlkYXRlcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNoZWNrIGNhbmRpZGF0ZSBlbGVtZW50XG4gICAgICBjb25zdCB2YWxpZENhbmRpZGF0ZSA9IG1hdGNoZXMuY2FsbChlbGVtZW50LCBjYW5kaWRhdGVTZWxlY3Rvcik7XG4gICAgICBpZiAoXG4gICAgICAgIHZhbGlkQ2FuZGlkYXRlICYmXG4gICAgICAgIG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQpICYmXG4gICAgICAgIChpbmNsdWRlQ29udGFpbmVyIHx8ICFlbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSlcbiAgICAgICkge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBzaGFkb3cgY29udGVudCBpZiBwb3NzaWJsZVxuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9XG4gICAgICAgIGVsZW1lbnQuc2hhZG93Um9vdCB8fFxuICAgICAgICAvLyBjaGVjayBmb3IgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICh0eXBlb2Ygb3B0aW9ucy5nZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgb3B0aW9ucy5nZXRTaGFkb3dSb290KGVsZW1lbnQpKTtcblxuICAgICAgY29uc3QgdmFsaWRTaGFkb3dSb290ID1cbiAgICAgICAgIW9wdGlvbnMuc2hhZG93Um9vdEZpbHRlciB8fCBvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIoZWxlbWVudCk7XG5cbiAgICAgIGlmIChzaGFkb3dSb290ICYmIHZhbGlkU2hhZG93Um9vdCkge1xuICAgICAgICAvLyBhZGQgc2hhZG93IGRvbSBzY29wZSBJSUYgYSBzaGFkb3cgcm9vdCBub2RlIHdhcyBnaXZlbjsgb3RoZXJ3aXNlLCBhbiB1bmRpc2Nsb3NlZFxuICAgICAgICAvLyAgc2hhZG93IGV4aXN0cywgc28gbG9vayBhdCBsaWdodCBkb20gY2hpbGRyZW4gYXMgZmFsbGJhY2sgQlVUIGNyZWF0ZSBhIHNjb3BlIGZvciBhbnlcbiAgICAgICAgLy8gIGNoaWxkIGNhbmRpZGF0ZXMgZm91bmQgYmVjYXVzZSB0aGV5J3JlIGxpa2VseSBzbG90dGVkIGVsZW1lbnRzIChlbGVtZW50cyB0aGF0IGFyZVxuICAgICAgICAvLyAgY2hpbGRyZW4gb2YgdGhlIHdlYiBjb21wb25lbnQgZWxlbWVudCAod2hpY2ggaGFzIHRoZSBzaGFkb3cpLCBpbiB0aGUgbGlnaHQgZG9tLCBidXRcbiAgICAgICAgLy8gIHNsb3R0ZWQgc29tZXdoZXJlIF9pbnNpZGVfIHRoZSB1bmRpc2Nsb3NlZCBzaGFkb3cpIC0tIHRoZSBzY29wZSBpcyBjcmVhdGVkIGJlbG93LFxuICAgICAgICAvLyAgX2FmdGVyXyB3ZSByZXR1cm4gZnJvbSB0aGlzIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgIGNvbnN0IG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoXG4gICAgICAgICAgc2hhZG93Um9vdCA9PT0gdHJ1ZSA/IGVsZW1lbnQuY2hpbGRyZW4gOiBzaGFkb3dSb290LmNoaWxkcmVuLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goLi4ubmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3BlOiBlbGVtZW50LFxuICAgICAgICAgICAgY2FuZGlkYXRlczogbmVzdGVkQ2FuZGlkYXRlcyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlcmUncyBub3Qgc2hhZG93IHNvIGp1c3QgZGlnIGludG8gdGhlIGVsZW1lbnQncyAobGlnaHQgZG9tKSBjaGlsZHJlblxuICAgICAgICAvLyAgX193aXRob3V0X18gZ2l2aW5nIHRoZSBlbGVtZW50IHNwZWNpYWwgc2NvcGUgdHJlYXRtZW50XG4gICAgICAgIGVsZW1lbnRzVG9DaGVjay51bnNoaWZ0KC4uLmVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbmNvbnN0IGdldFRhYmluZGV4ID0gZnVuY3Rpb24gKG5vZGUsIGlzU2NvcGUpIHtcbiAgaWYgKG5vZGUudGFiSW5kZXggPCAwKSB7XG4gICAgLy8gaW4gQ2hyb21lLCA8ZGV0YWlscy8+LCA8YXVkaW8gY29udHJvbHMvPiBhbmQgPHZpZGVvIGNvbnRyb2xzLz4gZWxlbWVudHMgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgLTEgd2hlbiB0aGUgJ3RhYmluZGV4JyBhdHRyaWJ1dGUgaXNuJ3Qgc3BlY2lmaWVkIGluIHRoZSBET00sXG4gICAgLy8geWV0IHRoZXkgYXJlIHN0aWxsIHBhcnQgb2YgdGhlIHJlZ3VsYXIgdGFiIG9yZGVyOyBpbiBGRiwgdGhleSBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAwOyBzaW5jZSBDaHJvbWUgc3RpbGwgcHV0cyB0aG9zZSBlbGVtZW50cyBpbiB0aGUgcmVndWxhciB0YWJcbiAgICAvLyBvcmRlciwgY29uc2lkZXIgdGhlaXIgdGFiIGluZGV4IHRvIGJlIDAuXG4gICAgLy8gQWxzbyBicm93c2VycyBkbyBub3QgcmV0dXJuIGB0YWJJbmRleGAgY29ycmVjdGx5IGZvciBjb250ZW50RWRpdGFibGUgbm9kZXM7XG4gICAgLy8gc28gaWYgdGhleSBkb24ndCBoYXZlIGEgdGFiaW5kZXggYXR0cmlidXRlIHNwZWNpZmljYWxseSBzZXQsIGFzc3VtZSBpdCdzIDAuXG4gICAgLy9cbiAgICAvLyBpc1Njb3BlIGlzIHBvc2l0aXZlIGZvciBjdXN0b20gZWxlbWVudCB3aXRoIHNoYWRvdyByb290IG9yIHNsb3QgdGhhdCBieSBkZWZhdWx0XG4gICAgLy8gaGF2ZSB0YWJJbmRleCAtMSwgYnV0IG5lZWQgdG8gYmUgc29ydGVkIGJ5IGRvY3VtZW50IG9yZGVyIGluIG9yZGVyIGZvciB0aGVpclxuICAgIC8vIGNvbnRlbnQgdG8gYmUgaW5zZXJ0ZWQgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb25cbiAgICBpZiAoXG4gICAgICAoaXNTY29wZSB8fFxuICAgICAgICAvXihBVURJT3xWSURFT3xERVRBSUxTKSQvLnRlc3Qobm9kZS50YWdOYW1lKSB8fFxuICAgICAgICBub2RlLmlzQ29udGVudEVkaXRhYmxlKSAmJlxuICAgICAgaXNOYU4ocGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKSlcbiAgICApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlLnRhYkluZGV4O1xufTtcblxuY29uc3Qgc29ydE9yZGVyZWRUYWJiYWJsZXMgPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gYS50YWJJbmRleCA9PT0gYi50YWJJbmRleFxuICAgID8gYS5kb2N1bWVudE9yZGVyIC0gYi5kb2N1bWVudE9yZGVyXG4gICAgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn07XG5cbmNvbnN0IGlzSW5wdXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU5QVVQnO1xufTtcblxuY29uc3QgaXNIaWRkZW5JbnB1dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ2hpZGRlbic7XG59O1xuXG5jb25zdCBpc0RldGFpbHNXaXRoU3VtbWFyeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGNvbnN0IHIgPVxuICAgIG5vZGUudGFnTmFtZSA9PT0gJ0RFVEFJTFMnICYmXG4gICAgQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAuYXBwbHkobm9kZS5jaGlsZHJlbilcbiAgICAgIC5zb21lKChjaGlsZCkgPT4gY2hpbGQudGFnTmFtZSA9PT0gJ1NVTU1BUlknKTtcbiAgcmV0dXJuIHI7XG59O1xuXG5jb25zdCBnZXRDaGVja2VkUmFkaW8gPSBmdW5jdGlvbiAobm9kZXMsIGZvcm0pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkICYmIG5vZGVzW2ldLmZvcm0gPT09IGZvcm0pIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGlzVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghbm9kZS5uYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcmFkaW9TY29wZSA9IG5vZGUuZm9ybSB8fCBnZXRSb290Tm9kZShub2RlKTtcbiAgY29uc3QgcXVlcnlSYWRpb3MgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiByYWRpb1Njb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAnaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCInICsgbmFtZSArICdcIl0nXG4gICAgKTtcbiAgfTtcblxuICBsZXQgcmFkaW9TZXQ7XG4gIGlmIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuQ1NTICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuQ1NTLmVzY2FwZSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKHdpbmRvdy5DU1MuZXNjYXBlKG5vZGUubmFtZSkpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKG5vZGUubmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLFxuICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjaGVja2VkID0gZ2V0Q2hlY2tlZFJhZGlvKHJhZGlvU2V0LCBub2RlLmZvcm0pO1xuICByZXR1cm4gIWNoZWNrZWQgfHwgY2hlY2tlZCA9PT0gbm9kZTtcbn07XG5cbmNvbnN0IGlzUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdyYWRpbyc7XG59O1xuXG5jb25zdCBpc05vblRhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNSYWRpbyhub2RlKSAmJiAhaXNUYWJiYWJsZVJhZGlvKG5vZGUpO1xufTtcblxuLy8gZGV0ZXJtaW5lcyBpZiBhIG5vZGUgaXMgdWx0aW1hdGVseSBhdHRhY2hlZCB0byB0aGUgd2luZG93J3MgZG9jdW1lbnRcbmNvbnN0IGlzTm9kZUF0dGFjaGVkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgLy8gVGhlIHJvb3Qgbm9kZSBpcyB0aGUgc2hhZG93IHJvb3QgaWYgdGhlIG5vZGUgaXMgaW4gYSBzaGFkb3cgRE9NOyBzb21lIGRvY3VtZW50IG90aGVyd2lzZVxuICAvLyAgKGJ1dCBOT1QgX3RoZV8gZG9jdW1lbnQ7IHNlZSBzZWNvbmQgJ0lmJyBjb21tZW50IGJlbG93IGZvciBtb3JlKS5cbiAgLy8gSWYgcm9vdE5vZGUgaXMgc2hhZG93IHJvb3QsIGl0J2xsIGhhdmUgYSBob3N0LCB3aGljaCBpcyB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgc2hhZG93XG4gIC8vICBpcyBhdHRhY2hlZCwgYW5kIHRoZSBvbmUgd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIGluIHRoZSBkb2N1bWVudCBvciBub3QgKGJlY2F1c2UgdGhlXG4gIC8vICBzaGFkb3csIGFuZCBhbGwgbm9kZXMgaXQgY29udGFpbnMsIGlzIG5ldmVyIGNvbnNpZGVyZWQgaW4gdGhlIGRvY3VtZW50IHNpbmNlIHNoYWRvd3NcbiAgLy8gIGJlaGF2ZSBsaWtlIHNlbGYtY29udGFpbmVkIERPTXM7IGJ1dCBpZiB0aGUgc2hhZG93J3MgSE9TVCwgd2hpY2ggaXMgcGFydCBvZiB0aGUgZG9jdW1lbnQsXG4gIC8vICBpcyBoaWRkZW4sIG9yIGlzIG5vdCBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmIGJ1dCBpcyBkZXRhY2hlZCwgaXQgd2lsbCBhZmZlY3QgdGhlIHNoYWRvdydzXG4gIC8vICB2aXNpYmlsaXR5LCBpbmNsdWRpbmcgYWxsIHRoZSBub2RlcyBpdCBjb250YWlucykuIFRoZSBob3N0IGNvdWxkIGJlIGFueSBub3JtYWwgbm9kZSxcbiAgLy8gIG9yIGEgY3VzdG9tIGVsZW1lbnQgKGkuZS4gd2ViIGNvbXBvbmVudCkuIEVpdGhlciB3YXksIHRoYXQncyB0aGUgb25lIHRoYXQgaXMgY29uc2lkZXJlZFxuICAvLyAgcGFydCBvZiB0aGUgZG9jdW1lbnQsIG5vdCB0aGUgc2hhZG93IHJvb3QsIG5vciBhbnkgb2YgaXRzIGNoaWxkcmVuIChpLmUuIHRoZSBub2RlIGJlaW5nXG4gIC8vICB0ZXN0ZWQpLlxuICAvLyBUbyBmdXJ0aGVyIGNvbXBsaWNhdGUgdGhpbmdzLCB3ZSBoYXZlIHRvIGxvb2sgYWxsIHRoZSB3YXkgdXAgdW50aWwgd2UgZmluZCBhIHNoYWRvdyBIT1NUXG4gIC8vICB0aGF0IGlzIGF0dGFjaGVkIChvciBmaW5kIG5vbmUpIGJlY2F1c2UgdGhlIG5vZGUgbWlnaHQgYmUgaW4gbmVzdGVkIHNoYWRvd3MuLi5cbiAgLy8gSWYgcm9vdE5vZGUgaXMgbm90IGEgc2hhZG93IHJvb3QsIGl0IHdvbid0IGhhdmUgYSBob3N0LCBhbmQgc28gcm9vdE5vZGUgc2hvdWxkIGJlIHRoZVxuICAvLyAgZG9jdW1lbnQgKHBlciB0aGUgZG9jcykgYW5kIHdoaWxlIGl0J3MgYSBEb2N1bWVudC10eXBlIG9iamVjdCwgdGhhdCBkb2N1bWVudCBkb2VzIG5vdFxuICAvLyAgYXBwZWFyIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBub2RlJ3MgYG93bmVyRG9jdW1lbnRgIGZvciBzb21lIHJlYXNvbiwgc28gaXQncyBzYWZlclxuICAvLyAgdG8gaWdub3JlIHRoZSByb290Tm9kZSBhdCB0aGlzIHBvaW50LCBhbmQgdXNlIGBub2RlLm93bmVyRG9jdW1lbnRgLiBPdGhlcndpc2UsXG4gIC8vICB1c2luZyBgcm9vdE5vZGUuY29udGFpbnMobm9kZSlgIHdpbGwgX2Fsd2F5c18gYmUgdHJ1ZSB3ZSdsbCBnZXQgZmFsc2UtcG9zaXRpdmVzIHdoZW5cbiAgLy8gIG5vZGUgaXMgYWN0dWFsbHkgZGV0YWNoZWQuXG4gIGxldCBub2RlUm9vdEhvc3QgPSBnZXRSb290Tm9kZShub2RlKS5ob3N0O1xuICBsZXQgYXR0YWNoZWQgPSAhIShcbiAgICBub2RlUm9vdEhvc3Q/Lm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZVJvb3RIb3N0KSB8fFxuICAgIG5vZGUub3duZXJEb2N1bWVudC5jb250YWlucyhub2RlKVxuICApO1xuXG4gIHdoaWxlICghYXR0YWNoZWQgJiYgbm9kZVJvb3RIb3N0KSB7XG4gICAgLy8gc2luY2UgaXQncyBub3QgYXR0YWNoZWQgYW5kIHdlIGhhdmUgYSByb290IGhvc3QsIHRoZSBub2RlIE1VU1QgYmUgaW4gYSBuZXN0ZWQgc2hhZG93IERPTSxcbiAgICAvLyAgd2hpY2ggbWVhbnMgd2UgbmVlZCB0byBnZXQgdGhlIGhvc3QncyBob3N0IGFuZCBjaGVjayBpZiB0aGF0IHBhcmVudCBob3N0IGlzIGNvbnRhaW5lZFxuICAgIC8vICBpbiAoaS5lLiBhdHRhY2hlZCB0bykgdGhlIGRvY3VtZW50XG4gICAgbm9kZVJvb3RIb3N0ID0gZ2V0Um9vdE5vZGUobm9kZVJvb3RIb3N0KS5ob3N0O1xuICAgIGF0dGFjaGVkID0gISFub2RlUm9vdEhvc3Q/Lm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZVJvb3RIb3N0KTtcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hlZDtcbn07XG5cbmNvbnN0IGlzWmVyb0FyZWEgPSBmdW5jdGlvbiAobm9kZSkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDA7XG59O1xuY29uc3QgaXNIaWRkZW4gPSBmdW5jdGlvbiAobm9kZSwgeyBkaXNwbGF5Q2hlY2ssIGdldFNoYWRvd1Jvb3QgfSkge1xuICAvLyBOT1RFOiB2aXNpYmlsaXR5IHdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgbm9kZSBpcyBkZXRhY2hlZCBmcm9tIHRoZSBkb2N1bWVudFxuICAvLyAgKHNlZSBub3RlcyBhYm91dCB0aGlzIGZ1cnRoZXIgZG93biksIHdoaWNoIG1lYW5zIHdlIHdpbGwgY29uc2lkZXIgaXQgdmlzaWJsZVxuICAvLyAgKHRoaXMgaXMgbGVnYWN5IGJlaGF2aW9yIGZyb20gYSB2ZXJ5IGxvbmcgd2F5IGJhY2spXG4gIC8vIE5PVEU6IHdlIGNoZWNrIHRoaXMgcmVnYXJkbGVzcyBvZiBgZGlzcGxheUNoZWNrPVwibm9uZVwiYCBiZWNhdXNlIHRoaXMgaXMgYVxuICAvLyAgX3Zpc2liaWxpdHlfIGNoZWNrLCBub3QgYSBfZGlzcGxheV8gY2hlY2tcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUobm9kZSkudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGlzRGlyZWN0U3VtbWFyeSA9IG1hdGNoZXMuY2FsbChub2RlLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnKTtcbiAgY29uc3Qgbm9kZVVuZGVyRGV0YWlscyA9IGlzRGlyZWN0U3VtbWFyeSA/IG5vZGUucGFyZW50RWxlbWVudCA6IG5vZGU7XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZVVuZGVyRGV0YWlscywgJ2RldGFpbHM6bm90KFtvcGVuXSkgKicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoXG4gICAgIWRpc3BsYXlDaGVjayB8fFxuICAgIGRpc3BsYXlDaGVjayA9PT0gJ2Z1bGwnIHx8XG4gICAgZGlzcGxheUNoZWNrID09PSAnbGVnYWN5LWZ1bGwnXG4gICkge1xuICAgIGlmICh0eXBlb2YgZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gZmlndXJlIG91dCBpZiB3ZSBzaG91bGQgY29uc2lkZXIgdGhlIG5vZGUgdG8gYmUgaW4gYW4gdW5kaXNjbG9zZWQgc2hhZG93IGFuZCB1c2UgdGhlXG4gICAgICAvLyAgJ25vbi16ZXJvLWFyZWEnIGZhbGxiYWNrXG4gICAgICBjb25zdCBvcmlnaW5hbE5vZGUgPSBub2RlO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBnZXRSb290Tm9kZShub2RlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBhcmVudEVsZW1lbnQgJiZcbiAgICAgICAgICAhcGFyZW50RWxlbWVudC5zaGFkb3dSb290ICYmXG4gICAgICAgICAgZ2V0U2hhZG93Um9vdChwYXJlbnRFbGVtZW50KSA9PT0gdHJ1ZSAvLyBjaGVjayBpZiB0aGVyZSdzIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xuICAgICAgICApIHtcbiAgICAgICAgICAvLyBub2RlIGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgd2hpY2ggbWVhbnMgd2UgY2FuIG9ubHkgdHJlYXQgaXQgYXMgYSBibGFjayBib3gsIHNvIHdlXG4gICAgICAgICAgLy8gIGZhbGwgYmFjayB0byBhIG5vbi16ZXJvLWFyZWEgdGVzdFxuICAgICAgICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gaXRlcmF0ZSB1cCBzbG90XG4gICAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90O1xuICAgICAgICB9IGVsc2UgaWYgKCFwYXJlbnRFbGVtZW50ICYmIHJvb3ROb2RlICE9PSBub2RlLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAvLyBjcm9zcyBzaGFkb3cgYm91bmRhcnlcbiAgICAgICAgICBub2RlID0gcm9vdE5vZGUuaG9zdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIG5vcm1hbCBkb21cbiAgICAgICAgICBub2RlID0gcGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlID0gb3JpZ2luYWxOb2RlO1xuICAgIH1cbiAgICAvLyBlbHNlLCBgZ2V0U2hhZG93Um9vdGAgbWlnaHQgYmUgdHJ1ZSwgYnV0IGFsbCB0aGF0IGRvZXMgaXMgZW5hYmxlIHNoYWRvdyBET00gc3VwcG9ydFxuICAgIC8vICAoaS5lLiBpdCBkb2VzIG5vdCBhbHNvIHByZXN1bWUgdGhhdCBhbGwgbm9kZXMgbWlnaHQgaGF2ZSB1bmRpc2Nsb3NlZCBzaGFkb3dzKTsgb3JcbiAgICAvLyAgaXQgbWlnaHQgYmUgYSBmYWxzeSB2YWx1ZSwgd2hpY2ggbWVhbnMgc2hhZG93IERPTSBzdXBwb3J0IGlzIGRpc2FibGVkXG5cbiAgICAvLyBTaW5jZSB3ZSBkaWRuJ3QgZmluZCBpdCBzaXR0aW5nIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyAob3Igc2hhZG93cyBhcmUgZGlzYWJsZWQpXG4gICAgLy8gIG5vdyB3ZSBjYW4ganVzdCB0ZXN0IHRvIHNlZSBpZiBpdCB3b3VsZCBub3JtYWxseSBiZSB2aXNpYmxlIG9yIG5vdCwgcHJvdmlkZWQgaXQnc1xuICAgIC8vICBhdHRhY2hlZCB0byB0aGUgbWFpbiBkb2N1bWVudC5cbiAgICAvLyBOT1RFOiBXZSBtdXN0IGNvbnNpZGVyIGNhc2Ugd2hlcmUgbm9kZSBpcyBpbnNpZGUgYSBzaGFkb3cgRE9NIGFuZCBnaXZlbiBkaXJlY3RseSB0b1xuICAgIC8vICBgaXNUYWJiYWJsZSgpYCBvciBgaXNGb2N1c2FibGUoKWAgLS0gcmVnYXJkbGVzcyBvZiBgZ2V0U2hhZG93Um9vdGAgb3B0aW9uIHNldHRpbmcuXG5cbiAgICBpZiAoaXNOb2RlQXR0YWNoZWQobm9kZSkpIHtcbiAgICAgIC8vIHRoaXMgd29ya3Mgd2hlcmV2ZXIgdGhlIG5vZGUgaXM6IGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGNsaWVudCByZWN0LCBpdCdzXG4gICAgICAvLyAgc29tZWhvdyBkaXNwbGF5ZWQ7IGl0IGFsc28gY292ZXJzIHRoZSBDU1MgJ2Rpc3BsYXk6IGNvbnRlbnRzJyBjYXNlIHdoZXJlIHRoZVxuICAgICAgLy8gIG5vZGUgaXRzZWxmIGlzIGhpZGRlbiBpbiBwbGFjZSBvZiBpdHMgY29udGVudHM7IGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoXG4gICAgICAvLyAgdXAgdGhlIGhpZXJhcmNoeSBlaXRoZXJcbiAgICAgIHJldHVybiAhbm9kZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBFbHNlLCB0aGUgbm9kZSBpc24ndCBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoZSBgZ2V0Q2xpZW50UmVjdHMoKWBcbiAgICAvLyAgQVBJIHdpbGwgX19hbHdheXNfXyByZXR1cm4gemVybyByZWN0cyAodGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgUmVhY3RcbiAgICAvLyAgaXMgdXNlZCB0byByZW5kZXIgbm9kZXMgb250byBhIGRldGFjaGVkIHRyZWUsIGFzIGNvbmZpcm1lZCBpbiB0aGlzIHRocmVhZDpcbiAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy85MTE3I2lzc3VlY29tbWVudC0yODQyMjg4NzApXG4gICAgLy9cbiAgICAvLyBJdCBhbHNvIG1lYW5zIHRoYXQgZXZlbiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgLy8gIGJlY2F1c2Ugc3R5bGVzIGFyZSBvbmx5IGNvbXB1dGVkIGZvciBub2RlcyB0aGF0IGFyZSBpbiB0aGUgZG9jdW1lbnQuXG4gICAgLy9cbiAgICAvLyBOT1RFOiBUSElTIEhBUyBCRUVOIFRIRSBDQVNFIEZPUiBZRUFSUy4gSXQgaXMgbm90IG5ldywgbm9yIGlzIGl0IGNhdXNlZCBieSB0YWJiYWJsZVxuICAgIC8vICBzb21laG93LiBUaG91Z2ggaXQgd2FzIG5ldmVyIHN0YXRlZCBvZmZpY2lhbGx5LCBhbnlvbmUgd2hvIGhhcyBldmVyIHVzZWQgdGFiYmFibGVcbiAgICAvLyAgQVBJcyBvbiBub2RlcyBpbiBkZXRhY2hlZCBjb250YWluZXJzIGhhcyBhY3R1YWxseSBpbXBsaWNpdGx5IHVzZWQgdGFiYmFibGUgaW4gd2hhdFxuICAgIC8vICB3YXMgbGF0ZXIgKGFzIG9mIHY1LjIuMCBvbiBBcHIgOSwgMjAyMSkgY2FsbGVkIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIG1vZGUgLS0gZXNzZW50aWFsbHlcbiAgICAvLyAgY29uc2lkZXJpbmcgX19ldmVyeXRoaW5nX18gdG8gYmUgdmlzaWJsZSBiZWNhdXNlIG9mIHRoZSBpbm5hYmlsaXR5IHRvIGRldGVybWluZSBzdHlsZXMuXG4gICAgLy9cbiAgICAvLyB2Ni4wLjA6IEFzIG9mIHRoaXMgbWFqb3IgcmVsZWFzZSwgdGhlIGRlZmF1bHQgJ2Z1bGwnIG9wdGlvbiBfX25vIGxvbmdlciB0cmVhdHMgZGV0YWNoZWRcbiAgICAvLyAgbm9kZXMgYXMgdmlzaWJsZSB3aXRoIHRoZSAnbm9uZScgZmFsbGJhY2suX19cbiAgICBpZiAoZGlzcGxheUNoZWNrICE9PSAnbGVnYWN5LWZ1bGwnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gaGlkZGVuXG4gICAgfVxuICAgIC8vIGVsc2UsIGZhbGxiYWNrIHRvICdub25lJyBtb2RlIGFuZCBjb25zaWRlciB0aGUgbm9kZSB2aXNpYmxlXG4gIH0gZWxzZSBpZiAoZGlzcGxheUNoZWNrID09PSAnbm9uLXplcm8tYXJlYScpIHtcbiAgICAvLyBOT1RFOiBFdmVuIHRob3VnaCB0aGlzIHRlc3RzIHRoYXQgdGhlIG5vZGUncyBjbGllbnQgcmVjdCBpcyBub24temVybyB0byBkZXRlcm1pbmVcbiAgICAvLyAgd2hldGhlciBpdCdzIGRpc3BsYXllZCwgYW5kIHRoYXQgYSBkZXRhY2hlZCBub2RlIHdpbGwgX19hbHdheXNfXyBoYXZlIGEgemVyby1hcmVhXG4gICAgLy8gIGNsaWVudCByZWN0LCB3ZSBkb24ndCBzcGVjaWFsLWNhc2UgZm9yIHdoZXRoZXIgdGhlIG5vZGUgaXMgYXR0YWNoZWQgb3Igbm90LiBJblxuICAgIC8vICB0aGlzIG1vZGUsIHdlIGRvIHdhbnQgdG8gY29uc2lkZXIgbm9kZXMgdGhhdCBoYXZlIGEgemVybyBhcmVhIHRvIGJlIGhpZGRlbiBhdCBhbGxcbiAgICAvLyAgdGltZXMsIGFuZCB0aGF0IGluY2x1ZGVzIGF0dGFjaGVkIG9yIG5vdC5cbiAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgfVxuXG4gIC8vIHZpc2libGUsIGFzIGZhciBhcyB3ZSBjYW4gdGVsbCwgb3IgcGVyIGN1cnJlbnQgYGRpc3BsYXlDaGVjaz1ub25lYCBtb2RlLCB3ZSBhc3N1bWVcbiAgLy8gIGl0J3MgdmlzaWJsZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBmb3JtIGZpZWxkcyAobmVzdGVkKSBpbnNpZGUgYSBkaXNhYmxlZCBmaWVsZHNldCBhcmUgbm90IGZvY3VzYWJsZS90YWJiYWJsZVxuLy8gIHVubGVzcyB0aGV5IGFyZSBpbiB0aGUgX2ZpcnN0XyA8bGVnZW5kPiBlbGVtZW50IG9mIHRoZSB0b3AtbW9zdCBkaXNhYmxlZFxuLy8gIGZpZWxkc2V0XG5jb25zdCBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKC9eKElOUFVUfEJVVFRPTnxTRUxFQ1R8VEVYVEFSRUEpJC8udGVzdChub2RlLnRhZ05hbWUpKSB7XG4gICAgbGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgLy8gY2hlY2sgaWYgYG5vZGVgIGlzIGNvbnRhaW5lZCBpbiBhIGRpc2FibGVkIDxmaWVsZHNldD5cbiAgICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgICAgaWYgKHBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ0ZJRUxEU0VUJyAmJiBwYXJlbnROb2RlLmRpc2FibGVkKSB7XG4gICAgICAgIC8vIGxvb2sgZm9yIHRoZSBmaXJzdCA8bGVnZW5kPiBhbW9uZyB0aGUgY2hpbGRyZW4gb2YgdGhlIGRpc2FibGVkIDxmaWVsZHNldD5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnROb2RlLmNoaWxkcmVuLml0ZW0oaSk7XG4gICAgICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgPGxlZ2VuZD4gKGluIGRvY3VtZW50IG9yZGVyKSBpcyBmb3VuZFxuICAgICAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnTEVHRU5EJykge1xuICAgICAgICAgICAgLy8gaWYgaXRzIHBhcmVudCA8ZmllbGRzZXQ+IGlzIG5vdCBuZXN0ZWQgaW4gYW5vdGhlciBkaXNhYmxlZCA8ZmllbGRzZXQ+LFxuICAgICAgICAgICAgLy8gcmV0dXJuIHdoZXRoZXIgYG5vZGVgIGlzIGEgZGVzY2VuZGFudCBvZiBpdHMgZmlyc3QgPGxlZ2VuZD5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwocGFyZW50Tm9kZSwgJ2ZpZWxkc2V0W2Rpc2FibGVkXSAqJylcbiAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgIDogIWNoaWxkLmNvbnRhaW5zKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PiBjb250YWluaW5nIGBub2RlYCBoYXMgbm8gPGxlZ2VuZD5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIGVsc2UsIG5vZGUncyB0YWJiYWJsZS9mb2N1c2FibGUgc3RhdGUgc2hvdWxkIG5vdCBiZSBhZmZlY3RlZCBieSBhIGZpZWxkc2V0J3NcbiAgLy8gIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGVcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBub2RlKSB7XG4gIGlmIChcbiAgICBub2RlLmRpc2FibGVkIHx8XG4gICAgaXNIaWRkZW5JbnB1dChub2RlKSB8fFxuICAgIGlzSGlkZGVuKG5vZGUsIG9wdGlvbnMpIHx8XG4gICAgLy8gRm9yIGEgZGV0YWlscyBlbGVtZW50IHdpdGggYSBzdW1tYXJ5LCB0aGUgc3VtbWFyeSBlbGVtZW50IGdldHMgdGhlIGZvY3VzXG4gICAgaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkgfHxcbiAgICBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBub2RlKSB7XG4gIGlmIChcbiAgICBpc05vblRhYmJhYmxlUmFkaW8obm9kZSkgfHxcbiAgICBnZXRUYWJpbmRleChub2RlKSA8IDAgfHxcbiAgICAhaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlID0gZnVuY3Rpb24gKHNoYWRvd0hvc3ROb2RlKSB7XG4gIGNvbnN0IHRhYkluZGV4ID0gcGFyc2VJbnQoc2hhZG93SG9zdE5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG4gIGlmIChpc05hTih0YWJJbmRleCkgfHwgdGFiSW5kZXggPj0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElmIGEgY3VzdG9tIGVsZW1lbnQgaGFzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIHRhYmluZGV4LFxuICAvLyBicm93c2VycyB3aWxsIG5vdCBhbGxvdyB0YWIgdGFyZ2V0aW5nIHNhaWQgZWxlbWVudCdzIGNoaWxkcmVuLlxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlc1Njb3BlPn0gY2FuZGlkYXRlc1xuICogQHJldHVybnMgRWxlbWVudFtdXG4gKi9cbmNvbnN0IHNvcnRCeU9yZGVyID0gZnVuY3Rpb24gKGNhbmRpZGF0ZXMpIHtcbiAgY29uc3QgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICBjb25zdCBvcmRlcmVkVGFiYmFibGVzID0gW107XG4gIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIGNvbnN0IGlzU2NvcGUgPSAhIWl0ZW0uc2NvcGU7XG4gICAgY29uc3QgZWxlbWVudCA9IGlzU2NvcGUgPyBpdGVtLnNjb3BlIDogaXRlbTtcbiAgICBjb25zdCBjYW5kaWRhdGVUYWJpbmRleCA9IGdldFRhYmluZGV4KGVsZW1lbnQsIGlzU2NvcGUpO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gaXNTY29wZSA/IHNvcnRCeU9yZGVyKGl0ZW0uY2FuZGlkYXRlcykgOiBlbGVtZW50O1xuICAgIGlmIChjYW5kaWRhdGVUYWJpbmRleCA9PT0gMCkge1xuICAgICAgaXNTY29wZVxuICAgICAgICA/IHJlZ3VsYXJUYWJiYWJsZXMucHVzaCguLi5lbGVtZW50cylcbiAgICAgICAgOiByZWd1bGFyVGFiYmFibGVzLnB1c2goZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yZGVyZWRUYWJiYWJsZXMucHVzaCh7XG4gICAgICAgIGRvY3VtZW50T3JkZXI6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVUYWJpbmRleCxcbiAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgaXNTY29wZTogaXNTY29wZSxcbiAgICAgICAgY29udGVudDogZWxlbWVudHMsXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvcmRlcmVkVGFiYmFibGVzXG4gICAgLnNvcnQoc29ydE9yZGVyZWRUYWJiYWJsZXMpXG4gICAgLnJlZHVjZSgoYWNjLCBzb3J0YWJsZSkgPT4ge1xuICAgICAgc29ydGFibGUuaXNTY29wZVxuICAgICAgICA/IGFjYy5wdXNoKC4uLnNvcnRhYmxlLmNvbnRlbnQpXG4gICAgICAgIDogYWNjLnB1c2goc29ydGFibGUuY29udGVudCk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKVxuICAgIC5jb25jYXQocmVndWxhclRhYmJhYmxlcyk7XG59O1xuXG5jb25zdCB0YWJiYWJsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBsZXQgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogZmFsc2UsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgICBzaGFkb3dSb290RmlsdGVyOiBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKFxuICAgICAgZWwsXG4gICAgICBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsXG4gICAgICBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNvcnRCeU9yZGVyKGNhbmRpZGF0ZXMpO1xufTtcblxuY29uc3QgZm9jdXNhYmxlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCBjYW5kaWRhdGVzO1xuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShbZWxdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhcbiAgICAgIGVsLFxuICAgICAgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLFxuICAgICAgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuY29uc3QgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmNvbnN0IGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovIGNhbmRpZGF0ZVNlbGVjdG9yc1xuICAuY29uY2F0KCdpZnJhbWUnKVxuICAuam9pbignLCcpO1xuXG5jb25zdCBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5leHBvcnQgeyB0YWJiYWJsZSwgZm9jdXNhYmxlLCBpc1RhYmJhYmxlLCBpc0ZvY3VzYWJsZSB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdpbmVydCcsIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gICAqIChodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsLzIwMTUvY29weXJpZ2h0LXNvZnR3YXJlLWFuZC1kb2N1bWVudCkuXG4gICAqL1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIHdlJ3JlIG5vdCBydW5uaW5nIGluc2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBOb2RlTGlzdHMuXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICAgKiBAdHlwZSB7dHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXN9XG4gICAgICovXG4gICAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdmFyIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZyA9IFsnYVtocmVmXScsICdhcmVhW2hyZWZdJywgJ2lucHV0Om5vdChbZGlzYWJsZWRdKScsICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJywgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKScsICdidXR0b246bm90KFtkaXNhYmxlZF0pJywgJ2RldGFpbHMnLCAnc3VtbWFyeScsICdpZnJhbWUnLCAnb2JqZWN0JywgJ2VtYmVkJywgJ1tjb250ZW50ZWRpdGFibGVdJ10uam9pbignLCcpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Um9vdGAgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBzdWJ0cmVlLCBpLmUuIGEgRE9NIHN1YnRyZWUgd2hvc2Ugcm9vdCBlbGVtZW50IGhhcyBhbiBgaW5lcnRgXG4gICAgICogYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogSXRzIG1haW4gZnVuY3Rpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgICAqICAgc3VidHJlZS4gVGhlIGBtYWtlU3VidHJlZVVuZm9jdXNhYmxlKClgIG1ldGhvZCBoYW5kbGVzIGNvbGxlY3RpbmcgYEluZXJ0Tm9kZWBzIHZpYSByZWdpc3RlcmluZ1xuICAgICAqICAgZWFjaCBmb2N1c2FibGUgbm9kZSBpbiB0aGUgc3VidHJlZSB3aXRoIHRoZSBzaW5nbGV0b24gYEluZXJ0TWFuYWdlcmAgd2hpY2ggbWFuYWdlcyBhbGwga25vd25cbiAgICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgICAqICAgaW5zdGFuY2UgZXhpc3RzIGZvciBlYWNoIGZvY3VzYWJsZSBub2RlIHdoaWNoIGhhcyBhdCBsZWFzdCBvbmUgaW5lcnQgcm9vdCBhcyBhbiBhbmNlc3Rvci5cbiAgICAgKlxuICAgICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAgICogICBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSByb290IG5vZGUpLiBUaGlzIGlzIGhhbmRsZWQgaW4gdGhlIGRlc3RydWN0b3IsIHdoaWNoIGNhbGxzIHRoZVxuICAgICAqICAgYGRlcmVnaXN0ZXJgIG1ldGhvZCBvbiBgSW5lcnRNYW5hZ2VyYCBmb3IgZWFjaCBtYW5hZ2VkIGluZXJ0IG5vZGUuXG4gICAgICovXG5cbiAgICB2YXIgSW5lcnRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRNYW5hZ2VyfSBpbmVydE1hbmFnZXIgVGhlIGdsb2JhbCBzaW5nbGV0b24gSW5lcnRNYW5hZ2VyIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Um9vdCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydE5vZGU+fVxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBmb2N1c2FibGUgbm9kZXMgaW4gdGhpcyBJbmVydFJvb3QncyBzdWJ0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIE1ha2UgdGhlIHN1YnRyZWUgaGlkZGVuIGZyb20gYXNzaXN0aXZlIHRlY2hub2xvZ3lcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSB0aGlzLl9yb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICAvLyBNYWtlIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIHN1YnRyZWUgdW5mb2N1c2FibGUgYW5kIGFkZCB0aGVtIHRvIF9tYW5hZ2VkTm9kZXNcbiAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSh0aGlzLl9yb290RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgICAvLyAtIGFueSBhZGRpdGlvbnMgaW4gdGhlIHN1YnRyZWU6IG1ha2UgdGhlbSB1bmZvY3VzYWJsZSB0b29cbiAgICAgICAgLy8gLSBhbnkgcmVtb3ZhbHMgZnJvbSB0aGUgc3VidHJlZTogcmVtb3ZlIHRoZW0gZnJvbSB0aGlzIGluZXJ0IHJvb3QncyBtYW5hZ2VkIG5vZGVzXG4gICAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgICAvLyAgIGVsZW1lbnQsIG1ha2UgdGhhdCBub2RlIGEgbWFuYWdlZCBub2RlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29uTXV0YXRpb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAgICogc3RvcmVkIGluIHRoaXMgb2JqZWN0IGFuZCB1cGRhdGVzIHRoZSBzdGF0ZSBvZiBhbGwgb2YgdGhlIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBOb3RlIHdlIGNhc3QgdGhlIG51bGxzIHRvIHRoZSBBTlkgdHlwZSBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAgIC8vICAgIG5lZWQgZXZlbiBtb3JlIGNhc3RzIHRocm91Z2hvdXQgdGhpcyBjb2RlLiBBbGwgYmV0cyBhcmUgb2ZmIGlmIGFuXG4gICAgICAgICAgLy8gICAgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkIGFuZCBhIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgICAgLy8gICAgdG8ga25vdyB3aGljaCBwcm9wZXJ0aWVzIHdlJ3JlIHNldHRpbmcuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4geyFTZXQ8IUluZXJ0Tm9kZT59IEEgY29weSBvZiB0aGlzIEluZXJ0Um9vdCdzIG1hbmFnZWQgbm9kZXMgc2V0LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBzdGFydE5vZGUgbWF5IGJlIGluIHNoYWRvdyBET00sIHNvIGZpbmQgaXRzIG5lYXJlc3Qgc2hhZG93Um9vdCB0byBnZXQgdGhlIGFjdGl2ZUVsZW1lbnQuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R9ICovbm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0Tm9kZS5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgICAvLyBjYWxsaW5nIGJsdXIoKSB3aWxsIG5vdCBhY3R1YWxseSBtb3ZlIHRoZSBmb2N1cy5cbiAgICAgICAgICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMgd2UgY2FsbCBmb2N1cygpIG9uIHRoZSBib2R5IGluc3RlYWQuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmlzaXROb2RlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuXG4gICAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAgIC8vIHRoaXMgaW5lcnQgcm9vdCwgc28gYWxsIG9mIGl0cyBtYW5hZ2VkIG5vZGVzIG5lZWQgdG8gYmUgYWRvcHRlZCBieSB0aGlzIEluZXJ0Um9vdC5cbiAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIucmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmFkZChpbmVydE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShpbmVydE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBlbnRpcmUgc3VidHJlZSBzdGFydGluZyBhdCBgc3RhcnROb2RlYC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlU3VidHJlZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fdW5tYW5hZ2VOb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgZGVzY2VuZGFudCBub2RlIGlzIGZvdW5kIHdpdGggYW4gYGluZXJ0YCBhdHRyaWJ1dGUsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fkb3B0SW5lcnRSb290KG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcblxuICAgICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgICAgLy8gc28gcmVnaXN0ZXIgaXQgbm93IGlmIG5lZWQgYmUuXG4gICAgICAgICAgaWYgKCFpbmVydFN1YnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShzYXZlZEluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBzdWJ0cmVlIGFkZGl0aW9ucywgcmVtb3ZhbHMsIG9yIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uTXV0YXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uTXV0YXRpb24ocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAvLyBVbi1tYW5hZ2UgcmVtb3ZlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5yZW1vdmVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlLWluaXRpYWxpc2UgaW5lcnQgbm9kZSBpZiB0YWJpbmRleCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZSh0YXJnZXQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbmV3IGluZXJ0IHJvb3QgaXMgYWRkZWQsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzIGFuZCBtYWtlIHN1cmUgaXQga25vd3MgYWJvdXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBtYW5hZ2VkIG5vZGVzIGZyb20gdGhpcyBpbmVydCBzdWJyb290LlxuICAgICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRTdWJyb290Ll9tYW5hZ2VOb2RlKG1hbmFnZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5fbWFuYWdlZE5vZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/c3RyaW5nfSBhcmlhSGlkZGVuICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXJpYUhpZGRlbikge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IGFyaWFIaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydFJvb3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Tm9kZWAgaW5pdGlhbGlzZXMgYW5kIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgbm9kZS5cbiAgICAgKiBBIG5vZGUgaXMgaW5lcnQgaWYgaXQgaXMgYSBkZXNjZW5kYW50IG9mIG9uZSBvciBtb3JlIGluZXJ0IHJvb3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBPbiBjb25zdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHNhdmVzIHRoZSBleGlzdGluZyBgdGFiaW5kZXhgIHZhbHVlIGZvciB0aGUgbm9kZSwgaWYgYW55LCBhbmRcbiAgICAgKiBlaXRoZXIgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgb3Igc2V0cyBpdCB0byBgLTFgLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZWxlbWVudFxuICAgICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIGBJbmVydE5vZGVgIG1haW50YWlucyBhIHNldCBvZiBgSW5lcnRSb290YHMgd2hpY2ggYXJlIGRlc2NlbmRhbnRzIG9mIHRoaXMgYEluZXJ0Tm9kZWAuIFdoZW4gYW5cbiAgICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICAgKiBgSW5lcnROb2RlYCB2aWEgYHJlbW92ZUluZXJ0Um9vdCgpYCwgd2hpY2ggaW4gdHVybiBkZXN0cm95cyB0aGUgYEluZXJ0Tm9kZWAgaWYgbm8gYEluZXJ0Um9vdGBzXG4gICAgICogcmVtYWluIGluIHRoZSBzZXQuIE9uIGRlc3RydWN0aW9uLCBgSW5lcnROb2RlYCByZWluc3RhdGVzIHRoZSBzdG9yZWQgYHRhYmluZGV4YCBpZiBvbmUgZXhpc3RzLFxuICAgICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIEEgZm9jdXNhYmxlIGVsZW1lbnQgdG8gYmUgbWFkZSBpbmVydC5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290IFRoZSBpbmVydCByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5lcnQgbm9kZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnROb2RlKTtcblxuICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Um9vdD59IFRoZSBzZXQgb2YgZGVzY2VuZGFudCBpbmVydCByb290cy5cbiAgICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgU2V0KFtpbmVydFJvb3RdKTtcblxuICAgICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2F2ZSBhbnkgcHJpb3IgdGFiaW5kZXggaW5mbyBhbmQgbWFrZSB0aGlzIG5vZGUgdW50YWJiYWJsZVxuICAgICAgICB0aGlzLmVuc3VyZVVudGFiYmFibGUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLlxuICAgICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Tm9kZSwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMuX25vZGU7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYGRlbGV0ZWAgdG8gcmVzdG9yZSBuYXRpdmUgZm9jdXMgbWV0aG9kLlxuICAgICAgICAgICAgaWYgKHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgICB0aGlzLl9ub2RlID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQsIGFueSBhdHRlbXB0IHRvIGFjY2VzcyBpdCB3aWxsIGNhdXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Rocm93SWZEZXN0cm95ZWQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Rocm93SWZEZXN0cm95ZWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgICAgLyoqIFNhdmUgdGhlIGV4aXN0aW5nIHRhYmluZGV4IHZhbHVlIGFuZCBtYWtlIHRoZSBub2RlIHVudGFiYmFibGUgYW5kIHVuZm9jdXNhYmxlICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmVVbnRhYmJhYmxlKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSkge1xuICAgICAgICAgICAgaWYgKCAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4ID09PSAtMSAmJiB0aGlzLmhhc1NhdmVkVGFiSW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbm90aGVyIGluZXJ0IHJvb3QgdG8gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdhZGRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLmFkZChpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBmcm9tIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICAgKiBzbyB0aGUgb2JqZWN0IHNob3VsZCBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3llZCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHshSW5lcnROb2RlfSAqL3RoaXMuX2Rlc3Ryb3llZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ25vZGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/bnVtYmVyfSB0YWJJbmRleCAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YWJJbmRleCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P251bWJlcn0gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBXaGVuIGFuIGVsZW1lbnQgYmVjb21lcyBhbiBpbmVydCByb290IGJ5IGhhdmluZyBhbiBgaW5lcnRgIGF0dHJpYnV0ZSBzZXQgYW5kL29yIGl0cyBgaW5lcnRgXG4gICAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICAgKiBUaGUgYEluZXJ0Um9vdGAgaW4gdHVybiByZWdpc3RlcnMgaXRzZWxmIGFzIG1hbmFnaW5nIGFsbCBvZiB0aGUgZWxlbWVudCdzIGZvY3VzYWJsZSBkZXNjZW5kYW50XG4gICAgICogbm9kZXMgdmlhIHRoZSBgcmVnaXN0ZXIoKWAgbWV0aG9kLiBUaGUgYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgIGluc3RhbmNlXG4gICAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshRG9jdW1lbnR9IGRvY3VtZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRNYW5hZ2VyKTtcblxuICAgICAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHshRG9jdW1lbnR9ICovXG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIG5vZGVzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIGluZXJ0IHJvb3RzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnRSb290Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICAgKiBAdHlwZSB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gQWRkIGluZXJ0IHN0eWxlLlxuICAgICAgICBhZGRJbmVydFN0eWxlKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRvY3VtZW50TG9hZGVkLmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZCBiZSBhbiBpbmVydCByb290IG9yIG5vdC5cbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluZXJ0XG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAgICBrZXk6ICdzZXRJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbmVydChyb290LCBpbmVydCkge1xuICAgICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBpbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmVydFJvb3QgPSBuZXcgSW5lcnRSb290KHJvb3QsIHRoaXMpO1xuICAgICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290cy5zZXQocm9vdCwgaW5lcnRSb290KTtcbiAgICAgICAgICAgIC8vIElmIG5vdCBjb250YWluZWQgaW4gdGhlIGRvY3VtZW50LCBpdCBtdXN0IGJlIGluIGEgc2hhZG93Um9vdC5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHJvb3QpKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgYWRkSW5lcnRTdHlsZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgICAgX2luZXJ0Um9vdC5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShyb290KTtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIEluZXJ0Um9vdCBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBlbGVtZW50LCBpZiBhbnkuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmVydFJvb3QoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbmVydFJvb3RzLmdldChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBub2RlLlxuICAgICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgICAqIGJlIGFkZGVkIHRvIGl0cyBzZXQgb2YgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Tm9kZX0gaW5lcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbm9kZSB3YXMgYWxyZWFkeSBpbiBhbiBpbmVydCBzdWJ0cmVlXG4gICAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZXJ0Tm9kZSA9IG5ldyBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuc2V0KG5vZGUsIGluZXJ0Tm9kZSk7XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlLXJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIGluZXJ0IG5vZGUuXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICAgKiBub2RlIGZyb20gdGhlIEluZXJ0TWFuYWdlcidzIHNldCBvZiBtYW5hZ2VkIG5vZGVzIGlmIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICogSWYgdGhlIG5vZGUgaXMgbm90IGN1cnJlbnRseSBtYW5hZ2VkLCB0aGlzIGlzIGVzc2VudGlhbGx5IGEgbm8tb3AuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7P0luZXJ0Tm9kZX0gVGhlIHBvdGVudGlhbGx5IGRlc3Ryb3llZCBJbmVydE5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgaWYgYW55LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXJlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKCFpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0Tm9kZS5yZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9jdW1lbnRMb2FkZWQoKSB7XG4gICAgICAgICAgLy8gRmluZCBhbGwgaW5lcnQgcm9vdHMgaW4gZG9jdW1lbnQgYW5kIG1ha2UgdGhlbSBhY3R1YWxseSBpbmVydC5cbiAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gQ29tbWVudCB0aGlzIG91dCB0byB1c2UgcHJvZ3JhbW1hdGljIEFQSSBvbmx5LlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZG9jdW1lbnQuYm9keSB8fCB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgc3VidHJlZTogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3dhdGNoRm9ySW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhdGNoRm9ySW5lcnQocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0ID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRJbmVydCh0YXJnZXQsIGluZXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRNYW5hZ2VyO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHdhbGsgdGhlIGNvbXBvc2VkIHRyZWUgZnJvbSB8bm9kZXwuXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uICghSFRNTEVsZW1lbnQpKT19IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50IHRyYXZlcnNlZCxcbiAgICAgKiAgICAgYmVmb3JlIGRlc2NlbmRpbmcgaW50byBjaGlsZCBub2Rlcy5cbiAgICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY29tcG9zZWRUcmVlV2Fsayhub2RlLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVzY2VuZCBpbnRvIG5vZGU6XG4gICAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgICAvLyB1cCBieSB0aGUgPGNvbnRlbnQ+IG9yIDxzaGFkb3c+IGVsZW1lbnRzLiBEZXNjZW5kIHN0cmFpZ2h0IGludG8gdGhlXG4gICAgICAgIC8vIFNoYWRvd1Jvb3QuXG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc2hhZG93Um9vdCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBkaXN0cmlidXRlZCBlbGVtZW50cyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnY29udGVudCcpIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmaWVzIGlmIFNoYWRvd0RvbSB2MCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIGRpc3RyaWJ1dGVkTm9kZXMgPSBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMgPyBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhkaXN0cmlidXRlZE5vZGVzW2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8c2xvdD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGFzc2lnbmVkIG5vZGVzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdzbG90Jykge1xuICAgICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZ5IGlmIFNoYWRvd0RvbSB2MSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIF9kaXN0cmlidXRlZE5vZGVzID0gc2xvdC5hc3NpZ25lZE5vZGVzID8gc2xvdC5hc3NpZ25lZE5vZGVzKHsgZmxhdHRlbjogdHJ1ZSB9KSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoX2Rpc3RyaWJ1dGVkTm9kZXNbX2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgICAvLyBlbGVtZW50LCBub3IgYSA8c2hhZG93PiBlbGVtZW50IHJlY3Vyc2Ugbm9ybWFsbHkuXG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGNoaWxkLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgICBpZiAobm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZSNpbmVydC1zdHlsZSwgbGluayNpbmVydC1zdHlsZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2luZXJ0LXN0eWxlJyk7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG5cbiAgICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgdmFyIGluZXJ0TWFuYWdlciA9IG5ldyBJbmVydE1hbmFnZXIoZG9jdW1lbnQpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmVydCkge1xuICAgICAgICAgIGluZXJ0TWFuYWdlci5zZXRJbmVydCh0aGlzLCBpbmVydCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSkoKTtcblxufSkpKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogYEJsb2NraW5nRWxlbWVudHNgIG1hbmFnZXMgYSBzdGFjayBvZiBlbGVtZW50cyB0aGF0IGluZXJ0IHRoZSBpbnRlcmFjdGlvblxuICogb3V0c2lkZSB0aGVtLiBUaGUgdG9wIGVsZW1lbnQgaXMgdGhlIGludGVyYWN0aXZlIHBhcnQgb2YgdGhlIGRvY3VtZW50LlxuICogVGhlIHN0YWNrIGNhbiBiZSB1cGRhdGVkIHdpdGggdGhlIG1ldGhvZHMgYHB1c2gsIHJlbW92ZSwgcG9wYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgLyoqXG4gICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuIFRoaXMgZW1wdGllc1xuICAgKiB0aGUgYmxvY2tpbmcgZWxlbWVudHNcbiAgICovXG4gIGRlc3RydWN0b3IoKTogdm9pZDtcblxuICAvKipcbiAgICogVGhlIHRvcCBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgdG9wOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBlbGVtZW50IHRvIHRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICovXG4gIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nIGVsZW1lbnRzLiBSZXR1cm5zIHRydWUgaWYgdGhlXG4gICAqIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHRvcCBibG9ja2luZyBlbGVtZW50IGFuZCByZXR1cm5zIGl0LlxuICAgKi9cbiAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgYSBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIGV4dGVuZHMgRG9jdW1lbnQge1xuICAkYmxvY2tpbmdFbGVtZW50czogQmxvY2tpbmdFbGVtZW50cztcbn1cblxuKCgpID0+IHtcbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBwcm9wZXJ0aWVzICovXG4gIGNvbnN0IF9ibG9ja2luZ0VsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9hbHJlYWR5SW5lcnRFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfdG9wRWxQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zaWJsaW5nc1RvUmVzdG9yZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfcGFyZW50TU8gPSBTeW1ib2woKTtcblxuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHN0YXRpYyBtZXRob2RzICovXG4gIGNvbnN0IF90b3BDaGFuZ2VkID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zd2FwSW5lcnRlZFNpYmxpbmcgPSBTeW1ib2woKTtcbiAgY29uc3QgX2luZXJ0U2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX3Jlc3RvcmVJbmVydGVkU2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4gPSBTeW1ib2woKTtcbiAgY29uc3QgX2lzSW5lcnRhYmxlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9oYW5kbGVNdXRhdGlvbnMgPSBTeW1ib2woKTtcblxuICBpbnRlcmZhY2UgSW5lcnRhYmxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGluZXJ0PzogYm9vbGVhbjtcbiAgfVxuXG4gIGludGVyZmFjZSBJbnRlcm5hbFN0YXRlIHtcbiAgICBbX3NpYmxpbmdzVG9SZXN0b3JlXTogU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT47XG4gICAgW19wYXJlbnRNT106IE11dGF0aW9uT2JzZXJ2ZXI7XG4gIH1cbiAgaW50ZXJmYWNlIEhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIEludGVybmFsU3RhdGUge31cbiAgaW50ZXJmYWNlIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgUGFydGlhbDxJbnRlcm5hbFN0YXRlPiB7fVxuXG4gIC8qKlxuICAgKiBTaGFkeURPTSBzaGFkeSByb290cyBsb29rIGEgbG90IGxpa2UgcmVhbCBTaGFkb3dSb290cy4gVGhlIF9fc2hhZHkgcHJvcGVydHlcbiAgICogZ2l2ZXMgdGhlbSBhd2F5LCB0aG91Z2guXG4gICAqL1xuICBpbnRlcmZhY2UgTWF5YmVTaGFkeVJvb3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBfX3NoYWR5OiB1bmtub3duO1xuICAgIGhvc3Q6IEVsZW1lbnQ7XG4gIH1cblxuICBjbGFzcyBCbG9ja2luZ0VsZW1lbnRzSW1wbCBpbXBsZW1lbnRzIEJsb2NraW5nRWxlbWVudHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBwcml2YXRlW19ibG9ja2luZ0VsZW1lbnRzXTogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcGFyZW50cyBvZiB0aGUgdG9wIGVsZW1lbnQsIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgKiBpdHNlbGYgdXAgdG8gYm9keS4gV2hlbiB0b3AgY2hhbmdlcywgdGhlIG9sZCB0b3AgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgKiBmcm9tIHRoZSBkb2N1bWVudCwgc28gd2UgbmVlZCB0byBtZW1vaXplIHRoZSBpbmVydGVkIHBhcmVudHMnIHNpYmxpbmdzXG4gICAgICogaW4gb3JkZXIgdG8gcmVzdG9yZSB0aGVpciBpbmVydGVuZXNzIHdoZW4gdG9wIGNoYW5nZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wRWxQYXJlbnRzXTogSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBFbGVtZW50cyB0aGF0IGFyZSBhbHJlYWR5IGluZXJ0IGJlZm9yZSB0aGUgZmlyc3QgYmxvY2tpbmcgZWxlbWVudCBpc1xuICAgICAqIHB1c2hlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBuZXcgU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT4oKTtcblxuICAgIGRlc3RydWN0b3IoKTogdm9pZCB7XG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGluZXJ0bmVzcy5cbiAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKHRoaXNbX3RvcEVsUGFyZW50c10pO1xuICAgICAgLy8gTm90ZSB3ZSBkb24ndCB3YW50IHRvIG1ha2UgdGhlc2UgcHJvcGVydGllcyBudWxsYWJsZSBvbiB0aGUgY2xhc3MsXG4gICAgICAvLyBzaW5jZSB0aGVuIHdlJ2QgbmVlZCBub24tbnVsbCBjYXN0cyBpbiBtYW55IHBsYWNlcy4gQ2FsbGluZyBhIG1ldGhvZCBvblxuICAgICAgLy8gYSBCbG9ja2luZ0VsZW1lbnRzIGluc3RhbmNlIGFmdGVyIGNhbGxpbmcgZGVzdHJ1Y3RvciB3aWxsIHJlc3VsdCBpbiBhblxuICAgICAgLy8gZXhjZXB0aW9uLlxuICAgICAgY29uc3QgbnVsbGFibGUgPSB0aGlzIGFzIHVua25vd24gYXMge1xuICAgICAgICBbX2Jsb2NraW5nRWxlbWVudHNdOiBudWxsO1xuICAgICAgICBbX3RvcEVsUGFyZW50c106IG51bGw7XG4gICAgICAgIFtfYWxyZWFkeUluZXJ0RWxlbWVudHNdOiBudWxsO1xuICAgICAgfTtcbiAgICAgIG51bGxhYmxlW19ibG9ja2luZ0VsZW1lbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfdG9wRWxQYXJlbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgdG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgZWxlbXMgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXTtcbiAgICAgIHJldHVybiBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH1cblxuICAgIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50ID09PSB0aGlzLnRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIHdlJ2xsIGJyaW5nIGl0IHRvIHRoZSB0b3AuXG4gICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICAgIHRoaXNbX3RvcENoYW5nZWRdKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnNwbGljZShpLCAxKTtcbiAgICAgIC8vIFRvcCBjaGFuZ2VkIG9ubHkgaWYgdGhlIHJlbW92ZWQgZWxlbWVudCB3YXMgdGhlIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKGkgPT09IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmxlbmd0aCkge1xuICAgICAgICB0aGlzW190b3BDaGFuZ2VkXSh0aGlzLnRvcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRvcCAmJiB0aGlzLnJlbW92ZSh0b3ApO1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGBpbmVydGAgdG8gYWxsIGRvY3VtZW50IGVsZW1lbnRzIGV4Y2VwdCB0aGUgbmV3IHRvcCBlbGVtZW50LCBpdHNcbiAgICAgKiBwYXJlbnRzLCBhbmQgaXRzIGRpc3RyaWJ1dGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wQ2hhbmdlZF0obmV3VG9wOiBNYXliZUhhc0ludGVybmFsU3RhdGV8bnVsbCk6IHZvaWQge1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBjb25zdCBvbGRQYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIC8vIE5vIG5ldyB0b3AsIHJlc2V0IG9sZCB0b3AgaWYgYW55LlxuICAgICAgaWYgKCFuZXdUb3ApIHtcbiAgICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cyk7XG4gICAgICAgIHRvS2VlcEluZXJ0LmNsZWFyKCk7XG4gICAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBbXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdQYXJlbnRzID0gdGhpc1tfZ2V0UGFyZW50c10obmV3VG9wKTtcbiAgICAgIC8vIE5ldyB0b3AgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgbWFpbiBkb2N1bWVudCFcbiAgICAgIGlmIChuZXdQYXJlbnRzW25ld1BhcmVudHMubGVuZ3RoIC0gMV0ucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm9uLWNvbm5lY3RlZCBlbGVtZW50IGNhbm5vdCBiZSBhIGJsb2NraW5nIGVsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIC8vIENhc3QgaGVyZSBiZWNhdXNlIHdlIGtub3cgd2UnbGwgY2FsbCBfaW5lcnRTaWJsaW5ncyBvbiBuZXdQYXJlbnRzXG4gICAgICAvLyBiZWxvdy5cbiAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBuZXdQYXJlbnRzIGFzIEFycmF5PEhhc0ludGVybmFsU3RhdGU+O1xuXG4gICAgICBjb25zdCB0b1NraXAgPSB0aGlzW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShuZXdUb3ApO1xuXG4gICAgICAvLyBObyBwcmV2aW91cyB0b3AgZWxlbWVudC5cbiAgICAgIGlmICghb2xkUGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cywgdG9Ta2lwLCB0b0tlZXBJbmVydCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSBvbGRQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgaiA9IG5ld1BhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIC8vIEZpbmQgY29tbW9uIHBhcmVudC4gSW5kZXggMCBpcyB0aGUgZWxlbWVudCBpdHNlbGYgKHNvIHN0b3AgYmVmb3JlIGl0KS5cbiAgICAgIHdoaWxlIChpID4gMCAmJiBqID4gMCAmJiBvbGRQYXJlbnRzW2ldID09PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgICAgLy8gSWYgdXAgdGhlIHBhcmVudHMgdHJlZSB0aGVyZSBhcmUgMiBlbGVtZW50cyB0aGF0IGFyZSBzaWJsaW5ncywgc3dhcFxuICAgICAgLy8gdGhlIGluZXJ0ZWQgc2libGluZy5cbiAgICAgIGlmIChvbGRQYXJlbnRzW2ldICE9PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIHRoaXNbX3N3YXBJbmVydGVkU2libGluZ10ob2xkUGFyZW50c1tpXSwgbmV3UGFyZW50c1tqXSk7XG4gICAgICB9XG4gICAgICAvLyBSZXN0b3JlIG9sZCBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0bmVzcy5cbiAgICAgIGkgPiAwICYmIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMuc2xpY2UoMCwgaSkpO1xuICAgICAgLy8gTWFrZSBuZXcgcGFyZW50cyBzaWJsaW5ncyBpbmVydC5cbiAgICAgIGogPiAwICYmIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMuc2xpY2UoMCwgaiksIHRvU2tpcCwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgaW5lcnRuZXNzIGJldHdlZW4gdHdvIHNpYmxpbmcgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfc3dhcEluZXJ0ZWRTaWJsaW5nXShcbiAgICAgICAgb2xkSW5lcnQ6IEhhc0ludGVybmFsU3RhdGUsIG5ld0luZXJ0OiBNYXliZUhhc0ludGVybmFsU3RhdGUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNpYmxpbmdzVG9SZXN0b3JlID0gb2xkSW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgIC8vIG9sZEluZXJ0IGlzIG5vdCBjb250YWluZWQgaW4gc2libGluZ3MgdG8gcmVzdG9yZSwgc28gd2UgaGF2ZSB0byBjaGVja1xuICAgICAgLy8gaWYgaXQncyBpbmVydGFibGUgYW5kIGlmIGFscmVhZHkgaW5lcnQuXG4gICAgICBpZiAodGhpc1tfaXNJbmVydGFibGVdKG9sZEluZXJ0KSAmJiAhb2xkSW5lcnQuaW5lcnQpIHtcbiAgICAgICAgb2xkSW5lcnQuaW5lcnQgPSB0cnVlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5hZGQob2xkSW5lcnQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbmV3SW5lcnQgd2FzIGFscmVhZHkgYmV0d2VlbiB0aGUgc2libGluZ3MgdG8gcmVzdG9yZSwgaXQgbWVhbnMgaXQgaXNcbiAgICAgIC8vIGluZXJ0YWJsZSBhbmQgbXVzdCBiZSByZXN0b3JlZC5cbiAgICAgIGlmIChzaWJsaW5nc1RvUmVzdG9yZS5oYXMobmV3SW5lcnQpKSB7XG4gICAgICAgIG5ld0luZXJ0LmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmRlbGV0ZShuZXdJbmVydCk7XG4gICAgICB9XG4gICAgICBuZXdJbmVydFtfcGFyZW50TU9dID0gb2xkSW5lcnRbX3BhcmVudE1PXTtcbiAgICAgIG5ld0luZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBzaWJsaW5nc1RvUmVzdG9yZTtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIGluZXJ0bmVzcyB0byB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKGVsZW1lbnRzOiBIYXNJbnRlcm5hbFN0YXRlW10pIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBtbyA9IGVsZW1lbnRbX3BhcmVudE1PXTtcbiAgICAgICAgbW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgICBmb3IgKGNvbnN0IHNpYmxpbmcgb2Ygc2libGluZ3MpIHtcbiAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZXJ0cyB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzIGV4Y2VwdCB0aGUgZWxlbWVudHMgdG8gc2tpcC4gU3RvcmVzXG4gICAgICogdGhlIGluZXJ0ZWQgc2libGluZ3MgaW50byB0aGUgZWxlbWVudCdzIHN5bWJvbCBgX3NpYmxpbmdzVG9SZXN0b3JlYC5cbiAgICAgKiBQYXNzIGB0b0tlZXBJbmVydGAgdG8gY29sbGVjdCB0aGUgYWxyZWFkeSBpbmVydCBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19pbmVydFNpYmxpbmdzXShcbiAgICAgICAgZWxlbWVudHM6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdLCB0b1NraXA6IFNldDxIVE1MRWxlbWVudD58bnVsbCxcbiAgICAgICAgdG9LZWVwSW5lcnQ6IFNldDxIVE1MRWxlbWVudD58bnVsbCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIC8vIEFzc3VtZSBlbGVtZW50IGlzIG5vdCBhIERvY3VtZW50LCBzbyBpdCBtdXN0IGhhdmUgYSBwYXJlbnROb2RlLlxuICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUhO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBjaGlsZHJlbltqXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgLy8gU2tpcCB0aGUgaW5wdXQgZWxlbWVudCwgaWYgbm90IGluZXJ0YWJsZSBvciB0byBiZSBza2lwcGVkLlxuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBlbGVtZW50IHx8ICF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykgfHxcbiAgICAgICAgICAgICAgKHRvU2tpcCAmJiB0b1NraXAuaGFzKHNpYmxpbmcpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNob3VsZCBiZSBjb2xsZWN0ZWQgc2luY2UgYWxyZWFkeSBpbmVydGVkLlxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIHNpYmxpbmdzIHRoYXQgd2VyZSBpbmVydGVkLlxuICAgICAgICBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBpbmVydGVkU2libGluZ3M7XG4gICAgICAgIC8vIE9ic2VydmUgb25seSBpbW1lZGlhdGUgY2hpbGRyZW4gbXV0YXRpb25zIG9uIHRoZSBwYXJlbnQuXG4gICAgICAgIGNvbnN0IG1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpc1tfaGFuZGxlTXV0YXRpb25zXS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZWxlbWVudFtfcGFyZW50TU9dID0gbW87XG4gICAgICAgIGxldCBwYXJlbnRUb09ic2VydmUgPSBwYXJlbnQ7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHRoZSBTaGFkeURPTSBwb2x5ZmlsbCwgdGhlbiBvdXIgcGFyZW50IGNvdWxkIGJlIGFcbiAgICAgICAgLy8gc2hhZHkgcm9vdCwgd2hpY2ggaXMgYW4gb2JqZWN0IHRoYXQgYWN0cyBsaWtlIGEgU2hhZG93Um9vdCwgYnV0IGlzbid0XG4gICAgICAgIC8vIGFjdHVhbGx5IGEgbm9kZSBpbiB0aGUgcmVhbCBET00uIE9ic2VydmUgdGhlIHJlYWwgRE9NIHBhcmVudCBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBtYXliZVNoYWR5Um9vdCA9IHBhcmVudFRvT2JzZXJ2ZSBhcyBNYXliZVNoYWR5Um9vdDtcbiAgICAgICAgaWYgKG1heWJlU2hhZHlSb290Ll9fc2hhZHkgJiYgbWF5YmVTaGFkeVJvb3QuaG9zdCkge1xuICAgICAgICAgIHBhcmVudFRvT2JzZXJ2ZSA9IG1heWJlU2hhZHlSb290Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbW8ub2JzZXJ2ZShwYXJlbnRUb09ic2VydmUsIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbmV3bHkgYWRkZWQvcmVtb3ZlZCBub2RlcyBieSB0b2dnbGluZyB0aGVpciBpbmVydG5lc3MuXG4gICAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIGN1cnJlbnQgdG9wIEJsb2NraW5nIEVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgKiBub3RpZnlpbmcgYW5kIHJlbW92aW5nIGl0LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2hhbmRsZU11dGF0aW9uc10obXV0YXRpb25zOiBNdXRhdGlvblJlY29yZFtdKTogdm9pZCB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHNoYWRvd1Jvb3QsIGdldCBpdHMgaG9zdCBhcyB3ZSBza2lwIHNoYWRvd1Jvb3RzIHdoZW5cbiAgICAgICAgLy8gY29tcHV0aW5nIF90b3BFbFBhcmVudHMuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IChtdXRhdGlvbi50YXJnZXQgYXMgU2hhZG93Um9vdCkuaG9zdCB8fCBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSA/XG4gICAgICAgICAgICBwYXJlbnRzLmxlbmd0aCA6XG4gICAgICAgICAgICBwYXJlbnRzLmluZGV4T2YodGFyZ2V0IGFzIEhhc0ludGVybmFsU3RhdGUpO1xuICAgICAgICBjb25zdCBpbmVydGVkQ2hpbGQgPSBwYXJlbnRzW2lkeCAtIDFdO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBpbmVydGVkQ2hpbGRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcblxuICAgICAgICAvLyBUbyByZXN0b3JlLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBpbmVydGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnRGV0ZWN0ZWQgcmVtb3ZhbCBvZiB0aGUgdG9wIEJsb2NraW5nIEVsZW1lbnQuJyk7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5lcnRlZFNpYmxpbmdzLmhhcyhzaWJsaW5nKSkge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmRlbGV0ZShzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBpbmVydC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLmFkZGVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmICghdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgaW5lcnRhYmxlLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2lzSW5lcnRhYmxlXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGZhbHNlID09PSAvXihzdHlsZXx0ZW1wbGF0ZXxzY3JpcHQpJC8udGVzdChlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBuZXdQYXJlbnRzIG9mIGFuIGVsZW1lbnQsIHN0YXJ0aW5nIGZyb20gZWxlbWVudFxuICAgICAqIChpbmNsdWRlZCkgdXAgdG8gYGRvY3VtZW50LmJvZHlgIChleGNsdWRlZCkuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0UGFyZW50c10oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBBcnJheTxIVE1MRWxlbWVudD4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnQ6IEhUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkID0gZWxlbWVudDtcbiAgICAgIC8vIFN0b3AgdG8gYm9keS5cbiAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgLy8gU2tpcCBzaGFkb3cgcm9vdHMuXG4gICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGFkb3dEb20gdjFcbiAgICAgICAgaWYgKGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gQ29sbGVjdCBzbG90cyBmcm9tIGRlZXBlc3Qgc2xvdCB0byB0b3AuXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPSBjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb250aW51ZSB0aGUgc2VhcmNoIG9uIHRoZSB0b3Agc2xvdC5cbiAgICAgICAgICBjdXJyZW50ID0gcGFyZW50cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICAgICAoY3VycmVudCBhcyBOb2RlIGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0cmlidXRlZCBjaGlsZHJlbiBvZiB0aGUgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBzaGFkb3cgcm9vdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShlbGVtZW50OiBIVE1MRWxlbWVudCk6XG4gICAgICAgIFNldDxIVE1MRWxlbWVudD58bnVsbCB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgIGxldCBpO1xuICAgICAgbGV0IGo7XG4gICAgICBsZXQgbm9kZXM7XG4gICAgICBjb25zdCBzbG90cyA9IHNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgICAgaWYgKHNsb3RzLmxlbmd0aCAmJiBzbG90c1swXS5hc3NpZ25lZE5vZGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzID0gc2xvdHNbaV0uYXNzaWduZWROb2Rlcyh7XG4gICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICByZXN1bHQuYWRkKG5vZGVzW2pdIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZWFyY2ggZm9yIDxjb250ZW50Pi5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgKGRvY3VtZW50IGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzID1cbiAgICAgIG5ldyBCbG9ja2luZ0VsZW1lbnRzSW1wbCgpO1xufSkoKTtcbiIsImltcG9ydCBcIndpY2ctaW5lcnRcIjtcbmltcG9ydCBcImJsb2NraW5nLWVsZW1lbnRzXCI7XG5pbXBvcnQgeyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIH0gZnJvbSBcImJsb2NraW5nLWVsZW1lbnRzXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZXREb2N1bWVudCB9IGZyb20gXCIuL3VzZS1kb2N1bWVudC1jbGFzc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5cbmZ1bmN0aW9uIGJsb2NraW5nRWxlbWVudHMoKSB7IHJldHVybiAoZ2V0RG9jdW1lbnQoKSBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyB9XG4vKipcbiAqIEFsbG93cyBhbiBlbGVtZW50IHRvIHRyYXAgZm9jdXMgYnkgYXBwbHlpbmcgdGhlIFwiaW5lcnRcIiBhdHRyaWJ1dGUgdG8gYWxsIHNpYmxpbmcsIGF1bnQsIGFuZCB1bmNsZSBub2Rlcy5cbiAqIFxuICogQXV0b21hdGljYWxseSBoYW5kbGVzIGNvbnNlY3V0aXZlIGNhbGxzIHdpdGggYSBsb29zZWx5IGFwcGxpZWQgc3RhY2sgb3BlcmF0aW9uIFxuICogKHNwZWNpZmljYWxseSB2aWEgYGJsb2NraW5nRWxlbWVudHNgLCB3aXRoIGEgc21hbGwgcG9seWZpbGwgYmVjYXVzZSBJJ20gbm90IHN1cmUgaG93IGxvbmdcbiAqIGl0J2xsIHRha2UgdG8gZmluZCBpdHMgd2F5IGludG8gdGhlIHNwZWMsIGlmIGV2ZXIpXG4gKiBAcGFyYW0gdGFyZ2V0IFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmxvY2tpbmdFbGVtZW50PEUgZXh0ZW5kcyBFbGVtZW50PihlbmFibGVkOiBib29sZWFuLCBnZXRUYXJnZXQ6ICgpID0+IChFIHwgbnVsbCkpIHtcblxuICAgIGNvbnN0IHN0YWJsZUdldFRhcmdldCA9IHVzZVN0YWJsZUNhbGxiYWNrKGdldFRhcmdldCk7XG5cbiAgICAvKipcbiAgICAgKiBQdXNoL3BvcCB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZ0VsZW1lbnRzIHN0YWNrLlxuICAgICAqL1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHN0YWJsZUdldFRhcmdldCgpO1xuXG4gICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgYmxvY2tpbmdFbGVtZW50cyB3aWxsIGZhaWwgaWYsIGZvciBleGFtcGxlLFxuICAgICAgICAgICAgLy8gdGhlIHRhcmdldCBlbGVtZW50IGlzbid0IGNvbm5lY3RlZCB0byBkb2N1bWVudC5ib2R5LlxuICAgICAgICAgICAgLy8gVGhpcyBpcyByYXJlLCBidXQgaXQncyBiZXR0ZXIgdG8gZmFpbCBzaWxlbnRseSB3aXRoIHdlaXJkIHRhYmJpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIHRoYW4gdG8gY3Jhc2ggdGhlIGVudGlyZSBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYmxvY2tpbmdFbGVtZW50cygpLnB1c2godGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NraW5nRWxlbWVudHMoKS5yZW1vdmUodGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBXZWxsLCBzZW1pLXNpbGVudGx5LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2VuYWJsZWRdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGJsb2NraW5nRWxlbWVudHMoKS50b3A7XG59XG5cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBpc0ZvY3VzYWJsZSB9IGZyb20gXCJ0YWJiYWJsZVwiO1xuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCB9IGZyb20gXCIuL3VzZS1hY3RpdmUtZWxlbWVudFwiO1xuaW1wb3J0IHsgZ2V0VG9wRWxlbWVudCwgdXNlQmxvY2tpbmdFbGVtZW50IH0gZnJvbSBcIi4vdXNlLWJsb2NraW5nLWVsZW1lbnRcIjtcbmltcG9ydCB7IGdldERvY3VtZW50IH0gZnJvbSBcIi4vdXNlLWRvY3VtZW50LWNsYXNzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1RyYXBQYXJhbWV0ZXJzIHsgdHJhcEFjdGl2ZTogYm9vbGVhbjsgfVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUZvY3VzVHJhcFJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiwgXCJ1c2VSZWZFbGVtZW50UHJvcHNcIj4ge1xuICAgIC8qKiAqVW5zdGFibGUqIChyZWxpZXMgb24gdGhlIGB0cmFwQWN0aXZlYCBwcm9wKSAqL1xuICAgIHVzZUZvY3VzVHJhcFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbn1cblxuY29uc3QgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvID0gbmV3IE1hcDxFbGVtZW50IHwgbnVsbCwgKE5vZGUgJiBIVE1MT3JTVkdFbGVtZW50KT4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvY3VzVHJhcDxFIGV4dGVuZHMgRWxlbWVudD4oeyB0cmFwQWN0aXZlIH06IFVzZUZvY3VzVHJhcFBhcmFtZXRlcnMpOiBVc2VGb2N1c1RyYXBSZXR1cm5UeXBlPEU+IHtcbiAgICBcbiAgICBjb25zdCBoYW5kbGVBY3RpdmVDaGFuZ2UgPSB1c2VDYWxsYmFjaygodHJhcEFjdGl2ZTogYm9vbGVhbiwgZWxlbWVudDogRSB8IG51bGwpID0+IHtcbiAgICAgICAgaWYgKHRyYXBBY3RpdmUgJiYgZWxlbWVudCkge1xuXG4gICAgICAgICAgICBsZXQgcmFmSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGV4dHJhIHF1ZXVlTWljcm90YXNrIGlzIG5lZWRlZCBmb3JcbiAgICAgICAgICAgICAgICAvLyAuLi5yZWFzb25zP1xuICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmluZEZpcnN0Rm9jdXNhYmxlKGVsZW1lbnQpPy5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICByYWZIYW5kbGUgPSAwO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyYWZIYW5kbGUpXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZkhhbmRsZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnQpIHtcblxuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgZm9jdXMgdG8gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHRoYXQgaGFzIHJldHVybmVkIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICAgICAgICBsZXQgcmFmSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUby5nZXQoZ2V0VG9wRWxlbWVudCgpKT8uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFmSGFuZGxlID0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyYWZIYW5kbGUpXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZkhhbmRsZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIFxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PEU+KHsgb25FbGVtZW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjaygoZWxlbWVudDogRSB8IG51bGwpID0+IGhhbmRsZUFjdGl2ZUNoYW5nZSh0cmFwQWN0aXZlLCBlbGVtZW50KSkgfSlcbiAgICBjb25zdCB7IGdldExhc3RBY3RpdmVFbGVtZW50IH0gPSB1c2VBY3RpdmVFbGVtZW50KHsgZ2V0RG9jdW1lbnQ6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IGdldEVsZW1lbnQoKT8ub3duZXJEb2N1bWVudCA/PyB3aW5kb3cuZG9jdW1lbnQgKSB9KTtcblxuXG4gICAgLy8gV2hlbiB0aGUgdHJhcCBiZWNvbWVzIGFjdGl2ZSwgYmVmb3JlIHdlIGxldCB0aGUgYmxvY2tpbmdFbGVtZW50cyBob29rIHJ1bixcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoYXRldmVyJ3MgY3VycmVudGx5IGZvY3VzZWQgYW5kIHNhdmUgaXQuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHRyYXBBY3RpdmUgJiYgZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudChlbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAgICAgLy8gdG8gd2hhdGV2ZXIncyBjdXJyZW50bHkgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgICAgIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUby5zZXQoZ2V0VG9wRWxlbWVudCgpLCAoZ2V0TGFzdEFjdGl2ZUVsZW1lbnQoKSBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpKSA/PyBkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgfVxuICAgIH0sIFt0cmFwQWN0aXZlXSk7XG5cbiAgICB1c2VCbG9ja2luZ0VsZW1lbnQodHJhcEFjdGl2ZSwgZ2V0RWxlbWVudCk7XG5cbiAgICAvKipcbiAgICAgKiBBbnkgdGltZSB3ZSBhY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHRoZSB0cmFwLFxuICAgICAqIGNoYW5nZSBmb2N1cyB0byBzb21ldGhpbmcgZWxzZSAoc29tZXRoaW5nIGluXG4gICAgICogdGhlIHRyYXAgaWYgaXQncyBhY3RpdmUsIG9yIHdoYXRldmVyIHdlJ3ZlXG4gICAgICogdHJhY2tlZCBpbiBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8gaWYgbm90KVxuICAgICAqL1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGhhbmRsZUFjdGl2ZUNoYW5nZSh0cmFwQWN0aXZlLCBnZXRFbGVtZW50KCkpO1xuICAgIH0sIFt0cmFwQWN0aXZlXSk7XG5cbiAgICBjb25zdCB1c2VGb2N1c1RyYXBQcm9wcyA9ICgocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiB7XG4gICAgICAgIGNvbnN0IHAxID0gdXNlUmVmRWxlbWVudFByb3BzKHByb3BzKTtcbiAgICAgICAgY29uc3QgcDIgPSB7IFwiYXJpYS1tb2RhbFwiOiB0cmFwQWN0aXZlID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHAxLCBwMik7XG4gICAgfSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUZvY3VzVHJhcFByb3BzLFxuICAgICAgICBnZXRFbGVtZW50XG4gICAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBjb250YWluZWQgd2l0aGluIHRoZSBnaXZlbiBub2RlLCBvciBudWxsIGlmIG5vbmUgYXJlIGZvdW5kLlxuICogQHBhcmFtIGVsZW1lbnQgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50OiBOb2RlKSB7XG4gICAgY29uc3QgdHJlZVdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWxlbWVudCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIHsgYWNjZXB0Tm9kZTogKG5vZGUpID0+IChub2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiBpc0ZvY3VzYWJsZShub2RlKSA/IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCA6IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVApIH0pXG4gICAgY29uc3QgZmlyc3RGb2N1c2FibGUgPSB0cmVlV2Fsa2VyLmZpcnN0Q2hpbGQoKSBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpIHwgbnVsbDtcbiAgICByZXR1cm4gZmlyc3RGb2N1c2FibGU7XG59XG5cbiIsImltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCwgd2hlbiBjYWxsZWQsIGZvcmNlIHRoZSBjb21wb25lbnRcbiAqIHRoYXQgdXNlcyB0aGlzIGhvb2sgdG8gcmUtcmVuZGVyIGl0c2VsZi5cbiAqIFxuICogSXQncyBhIGJpdCBzbWVsbHksIHNvIGJlc3QgdG8gdXNlIHNwYXJpbmdseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICAgIGNvbnN0IFssIHNldF0gPSB1c2VTdGF0ZSgwKTtcbiAgICByZXR1cm4gdXNlUmVmKCgpID0+IHNldChpID0+ICsraSkpLmN1cnJlbnQ7XG59IiwiXHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCwgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWFjdGl2ZS1lbGVtZW50XCI7XHJcbmltcG9ydCB7IHJldHVybkZhbHNlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgZWxlbWVudCBpdHNlbGYgY3VycmVudGx5IGhhcyBmb2N1cy5cclxuICAgICAqIFxyXG4gICAgICogYHByZXZGb2N1c2VkYCBpcyBnZW5lcmFsbHkgdGhlIG9wcG9zaXRlIG9mIGBmb2N1c2VkYCwgYnV0IG9uIG1vdW50IGl0J3MgYHVuZGVmaW5lZGAgd2hpbGUgYGZvY3VzZWRgIGlzIHByb2JhYmx5IGZhbHNlIChib3RoIGZhbHN5KVxyXG4gICAgICovXHJcbiAgICBvbkZvY3VzZWRDaGFuZ2VkPyhmb2N1c2VkOiBib29sZWFuLCBwcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaWtlIGBvbkZvY3VzZWRDaGFuZ2VkYCwgYnV0IGFsc28gKmFkZGl0aW9uYWxseSogaWYgYW55IGNoaWxkIGVsZW1lbnRzIGFyZSBmb2N1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAc2VlIHRoaXMub25Gb2N1c2VkQ2hhbmdlZFxyXG4gICAgICovXHJcbiAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbWlsYXIgdG8gYG9uRm9jdXNlZENoYW5nZWRgLCBidXQgaWYgdGhlcmUgaXMgbm8gY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCwgaXMgYHRydWVgIGlmIHRoaXMgZWxlbWVudCB0aGF0ICpkaWQqIGhhdmUgZm9jdXMgbGFzdC5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBpcyBhbHdheXMgYHRydWVgIHdoaWxlIGBmb2N1c2VkYCBpcyBgdHJ1ZWAuIElmIGBmb2N1c2VkYCBpcyBgZmFsc2VgLCB0aGlzIG1heSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgb25MYXN0Rm9jdXNlZENoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmVzIHRoZSBpbXBsaWNhdGlvbnMgb2YgYG9uRm9jdXNlZENoYW5nZWRgIGFuZCBgb25Gb2N1c2VkQ2hhbmdlZGAuXHJcbiAgICAgKi9cclxuICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNGb2N1c1JldHVyblR5cGU8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgT21pdDxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiwgXCJ1c2VSZWZFbGVtZW50UHJvcHNcIj4sIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmaWVzIHRoZSBlbGVtZW50IHRvIGJlIGFibGUgdG8gdHJhY2sgaXRzIG93biBmb2N1cyBzdGF0ZVxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIHVzZUhhc0ZvY3VzUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG5cclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEZvY3VzZWRJbm5lcigpOiBib29sZWFuO1xyXG4gICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgZ2V0TGFzdEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldExhc3RGb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhhc0ZvY3VzPFQgZXh0ZW5kcyBOb2RlPih7IG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9OiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VD4pOiBVc2VIYXNGb2N1c1JldHVyblR5cGU8VD4ge1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUhhc0ZvY3VzXCIsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0Rm9jdXNlZCwgc2V0Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25Gb2N1c2VkQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgW2dldEZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbkZvY3VzZWRJbm5lckNoYW5nZWQsIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFtnZXRMYXN0Rm9jdXNlZCwgc2V0TGFzdEZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBbZ2V0TGFzdEZvY3VzZWRJbm5lciwgc2V0TGFzdEZvY3VzZWRJbm5lcl0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfSk7XHJcblxyXG4gICAgY29uc3QgeyBnZXRBY3RpdmVFbGVtZW50LCBnZXRMYXN0QWN0aXZlRWxlbWVudCwgZ2V0V2luZG93Rm9jdXNlZCB9ID0gdXNlQWN0aXZlRWxlbWVudCh7XHJcbiAgICAgICAgZ2V0RG9jdW1lbnQsXHJcbiAgICAgICAgZ2V0V2luZG93LFxyXG4gICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8VXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnNbXCJvbkFjdGl2ZUVsZW1lbnRDaGFuZ2VcIl0+PigoYWN0aXZlRWxlbWVudCwgcHJldkFjdGl2ZUVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZkVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWQgPSAoc2VsZkVsZW1lbnQgIT0gbnVsbCAmJiAoc2VsZkVsZW1lbnQgPT0gYWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkSW5uZXIgPSAoISFzZWxmRWxlbWVudD8uY29udGFpbnMoYWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkKGZvY3VzZWQpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkSW5uZXIoZm9jdXNlZElubmVyKTtcclxuICAgICAgICAgICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlPy4oYWN0aXZlRWxlbWVudCwgcHJldkFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH0sIFtdKSxcclxuICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjazxOb25OdWxsYWJsZTxVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyc1tcIm9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2VcIl0+PigobGFzdEFjdGl2ZUVsZW1lbnQsIHByZXZMYXN0QWN0aXZlRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxmRWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXNlZCA9IChzZWxmRWxlbWVudCAhPSBudWxsICYmIChzZWxmRWxlbWVudCA9PSBsYXN0QWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkSW5uZXIgPSAoISFzZWxmRWxlbWVudD8uY29udGFpbnMobGFzdEFjdGl2ZUVsZW1lbnQgYXMgTm9kZSB8IG51bGwpKTtcclxuICAgICAgICAgICAgc2V0TGFzdEZvY3VzZWQoZm9jdXNlZCk7XHJcbiAgICAgICAgICAgIHNldExhc3RGb2N1c2VkSW5uZXIoZm9jdXNlZElubmVyKTtcclxuICAgICAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZT8uKGxhc3RBY3RpdmVFbGVtZW50LCBwcmV2TGFzdEFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH0sIFtdKSxcclxuICAgICAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2VcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUhhc0ZvY3VzUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KSA9PiB7IHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpOyB9LCBbXSk7XHJcblxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlSGFzRm9jdXNQcm9wcyxcclxuICAgICAgICBnZXRFbGVtZW50LFxyXG4gICAgICAgIGdldEZvY3VzZWQsXHJcbiAgICAgICAgZ2V0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgIGdldExhc3RGb2N1c2VkLFxyXG4gICAgICAgIGdldExhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgZ2V0QWN0aXZlRWxlbWVudCxcclxuICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudCxcclxuICAgICAgICBnZXRXaW5kb3dGb2N1c2VkXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBuZXZlcj4ge1xyXG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IHtcclxuICAgICAgICBvbkFueUdhaW5lZEZvY3VzPygpOiB2b2lkO1xyXG4gICAgICAgIG9uQWxsTG9zdEZvY3VzPygpOiB2b2lkO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxudW1iZXIsIEZvY3VzSW5mbywgbmV2ZXIsIFwic3ViSW5mb1wiPiwgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEU+IHtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+LCBcInVzZVJlZkVsZW1lbnRQcm9wc1wiPiwgT21pdDxVc2VIYXNGb2N1c1JldHVyblR5cGU8RT4sIFwidXNlSGFzRm9jdXNQcm9wc1wiPiB7XHJcbiAgICB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbn1cclxuXHJcbmludGVyZmFjZSBGb2N1c0luZm8ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88bnVtYmVyLCBGb2N1c0luZm8sIG5ldmVyPiB7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZVdpdGhIb29rcyBleHRlbmRzIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZDogPEUgZXh0ZW5kcyBFbGVtZW50PihwYXJhbWV0ZXJzOiBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczxFPikgPT4gVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFJldHVyblR5cGU8RT47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGlsZHJlbkhhdmVGb2N1cyh7IGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH06IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyk6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZVdpdGhIb29rcyB7XHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbiwgdXNlTWFuYWdlZENoaWxkIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBGb2N1c0luZm8sIG5ldmVyPih7IG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH0pO1xyXG4gICAgY29uc3QgYWxsRWxlbWVudHNSZWYgPSB1c2VSZWY8U2V0PE5vZGU+PihuZXcgU2V0KCkpO1xyXG4gICAgY29uc3QgW19nZXRGb2N1c0NvdW50LCBzZXRGb2N1c0NvdW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxudW1iZXI+KHVzZVN0YWJsZUNhbGxiYWNrKChhbnlGb2N1c2VkOiBudW1iZXIsIGFueVByZXZpb3VzbHlGb2N1c2VkOiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgQ2hhbmdpbmcgZm9jdXMgY291bnQgZnJvbSAke2FueVByZXZpb3VzbHlGb2N1c2VkfSB0byAke2FueUZvY3VzZWR9YCk7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoYW55Rm9jdXNlZCA+PSAwICYmIGFueUZvY3VzZWQgPD0gMSk7XHJcblxyXG4gICAgICAgIGlmIChhbnlGb2N1c2VkICYmICFhbnlQcmV2aW91c2x5Rm9jdXNlZClcclxuICAgICAgICAgICAgb25BbnlHYWluZWRGb2N1cz8uKCk7XHJcbiAgICAgICAgaWYgKCFhbnlGb2N1c2VkICYmIGFueVByZXZpb3VzbHlGb2N1c2VkKVxyXG4gICAgICAgICAgICBvbkFsbExvc3RGb2N1cz8uKCk7XHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc3QgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZCA9IHVzZUNhbGxiYWNrKDxFIGV4dGVuZHMgRWxlbWVudD4oeyBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSB9OiBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczxFPik6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlPEU+ID0+IHtcclxuICAgICAgICB1c2VNYW5hZ2VkQ2hpbGQoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIHN1YkluZm86IHt9LCBmbGFncyB9IH0pO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgLi4uaGFzRm9jdXMgIH0gPSB1c2VIYXNGb2N1czxFPih7XHJcbiAgICAgICAgICAgIGdldERvY3VtZW50LFxyXG4gICAgICAgICAgICBnZXRXaW5kb3csXHJcbiAgICAgICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZSxcclxuICAgICAgICAgICAgb25FbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoZTogRSB8IG51bGwsIHByZXY6IEUgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgciA9IG9uRWxlbWVudENoYW5nZT8uKGUsIHByZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxFbGVtZW50c1JlZi5jdXJyZW50LmFkZChlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByPy4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRWxlbWVudHNSZWYuY3VycmVudC5kZWxldGUoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBbb25FbGVtZW50Q2hhbmdlXSksXHJcbiAgICAgICAgICAgIG9uTW91bnQsXHJcbiAgICAgICAgICAgIG9uVW5tb3VudCxcclxuICAgICAgICAgICAgb25Gb2N1c2VkQ2hhbmdlZCxcclxuICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLFxyXG4gICAgICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLFxyXG4gICAgICAgICAgICBvbkxhc3RGb2N1c2VkQ2hhbmdlZCxcclxuICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENoaWxkICR7aW5kZXh9IGlzIGZvY3VzZWRgKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRGb2N1c0NvdW50KHAgPT4gKHAgPz8gMCkgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFmb2N1c2VkICYmIHByZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ2hpbGQgJHtpbmRleH0gaXMgdW5mb2N1c2VkYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Rm9jdXNDb3VudChwID0+IChwID8/IDApIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZD8uKGZvY3VzZWQsIHByZXYpO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQcm9wczogdXNlSGFzRm9jdXNQcm9wcyxcclxuICAgICAgICAgICAgLi4uaGFzRm9jdXNcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VHbG9iYWxIYW5kbGVyIH0gZnJvbSBcIi4vdXNlLWV2ZW50LWhhbmRsZXJcIjtcbmltcG9ydCB7IHVzZUZvcmNlVXBkYXRlIH0gZnJvbSBcIi4vdXNlLWZvcmNlLXVwZGF0ZVwiO1xuaW1wb3J0IHsgdXNlSGFzRm9jdXMsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1oYXMtZm9jdXNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG5pbnRlcmZhY2UgVXNlUHJlc3NQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBOb2RlPiB7XG4gICAgb25DbGlja1N5bmM6ICgoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxFPikgPT4gdm9pZCkgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgIGV4Y2x1ZGU6IHVuZGVmaW5lZCB8IHsgY2xpY2s/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgc3BhY2U/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgZW50ZXI/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCB9O1xuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT47XG59XG5cbi8qKlxuICogQWRkcyB0aGUgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIHRvIGNyZWF0ZSBhIFwicHJlc3NcIi1saWtlIGV2ZW50IGZvclxuICogYW55IGVsZW1lbnQsIHdoZXRoZXIgaXQncyBhIG5hdGl2ZSA8QlVUVE9OPiBvciByZWd1bGFyIDxESVY+LlxuICogXG4gKiBOb3RhYmx5LCB0aGUgZm9sbG93aW5nIGNhc2VzIGFyZSBjb3ZlcmVkOlxuICogKiBUaGUgdGFyZ2V0IGVsZW1lbnQgaXMgcHJvcGVybHkgZm9jdXNlZCwgZXZlbiBvbiBpT1MgU2FmYXJpICgqZXNwZWNpYWxseSogb24gaU9TIFNhZmFyaSlcbiAqICogRG91YmxlLWNsaWNrcyB3b24ndCBzZWxlY3QgdGV4dC4gXG4gKiAqIENvbnZlcnNlbHksIG1hbnVhbGx5IHNlbGVjdGluZyB0ZXh0IHdvbid0IGludm9rZSBhIHByZXNzLlxuICogKiBLZXlib2FyZCBldmVudHMgJm1kYXNoOyBgZW50ZXJgIGltbWVkaWF0ZWx5IGludm9rZXMgdGhlIGhhbmRsZXIsIHdoaWxlIGBzcGFjZWAgaW52b2tlcyBpdCBvbiBrZXl1cC5cbiAqICogSGFwdGljIGZlZWRiYWNrIChvbiwgbGlrZSwgdGhlIG9uZSBicm93c2VyIGNvbWJpbmF0aW9uIHRoYXQgc3VwcG9ydHMgaXQgJm1kYXNoOyB0aGlzIGNhbiBiZSBkaXNhYmxlZCBhcHAtd2lkZSB3aXRoIGBzZXRCdXR0b25WaWJyYXRlYClcbiAqIFxuICogSW4gYWRkaXRpb24sIHdoZW4gdGhlIENTUyBgOmFjdGl2ZWAgcHNldWRvLWNsYXNzIHdvdWxkIGFwcGx5IHRvIGEgbm9ybWFsIGJ1dHRvblxuICogKGkuZS4gd2hlbiBob2xkaW5nIHRoZSBzcGFjZWJhciBvciBkdXJpbmcgbW91c2Vkb3duKSwgYHsgXCJkYXRhLXBzZXVkby1hY3RpdmVcIjogXCJ0cnVlXCIgfWBcbiAqIGlzIGFkZGVkIHRvIHRoZSBwcm9wcy4gIFlvdSBjYW4gZWl0aGVyIGxldCBpdCBwYXNzIHRocm91Z2ggYW5kIHN0eWxlIGl0IHRocm91Z2ggbmV3IENTUyxcbiAqIG9yIGluc3BlY3QgdGhlIHJldHVybmVkIHByb3BzIGZvciBpdCBhbmQgYWRkIGUuZy4gYW4gYC5hY3RpdmVgIGNsYXNzIGZvciBleGlzdGluZyBDU1NcbiAqIFxuICogQHBhcmFtIG9uQ2xpY2tTeW5jIFxuICogQHBhcmFtIGV4Y2x1ZGUgV2hldGhlciB0aGUgcG9seWZpbGwgc2hvdWxkbid0IGFwcGx5IChjYW4gc3BlY2lmeSBmb3Igc3BlY2lmaWMgaW50ZXJhY3Rpb25zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlc3M8RSBleHRlbmRzIE5vZGU+KHsgZXhjbHVkZSwgaGFzRm9jdXM6IHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCAuLi5oYXNGb2N1cyB9LCBvbkNsaWNrU3luYyB9OiBVc2VQcmVzc1BhcmFtZXRlcnM8RT4pIHtcblxuICAgIC8vIEEgYnV0dG9uIGNhbiBiZSBhY3RpdmF0ZWQgaW4gbXVsdGlwbGUgd2F5cywgc28gb24gdGhlIG9mZiBjaGFuY2VcbiAgICAvLyB0aGF0IG11bHRpcGxlIGFyZSB0cmlnZ2VyZWQgYXQgb25jZSwgd2Ugb25seSAqYWN0dWFsbHkqIHJlZ2lzdGVyXG4gICAgLy8gYSBwcmVzcyBvbmNlIGFsbCBvZiBvdXIgXCJvblwiIHNpZ25hbHMgaGF2ZSB0dXJuZWQgYmFjayB0byBcIm9mZlwiLlxuICAgIC8vIFdlIGFwcHJveGltYXRlIHRoaXMgYnkganVzdCBpbmNyZW1lbnRpbmcgd2hlbiBhY3RpdmUsIGFuZFxuICAgIC8vIGRlY3JlbWVudGluZyB3aGVuIGRlYWN0aXZhdGVkLlxuICAgIC8vXG4gICAgLy8gQXMgYW4gZW1lcmdlbmN5IGZhaWxzYWZlLCB3aGVuIHRoZSBlbGVtZW50IGxvc2VzIGZvY3VzLFxuICAgIC8vIHRoaXMgaXMgcmVzZXQgYmFjayB0byAwLlxuICAgIGNvbnN0IFthY3RpdmUsIHNldEFjdGl2ZSwgZ2V0QWN0aXZlXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUhhc0ZvY3VzKHtcbiAgICAgICAgLi4uaGFzRm9jdXMsXG4gICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGY6IGJvb2xlYW4sIHA6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZD8uKGYsIHApO1xuICAgICAgICAgICAgaWYgKCFmKSB7XG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0pO1xuXG4gICAgLy8gSWYgd2UgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gY2hhbmdlcyB0byBpbmNsdWRlIHRoaXMgZWxlbWVudFxuICAgIC8vIERVUklORyBlLmcuIGEgbW91c2Vkb3duLCB0aGVuIHdlIGRvbid0IHdhbnQgdGhlIG1vdXNldXAgdG8gXCJjb3VudFwiLCBhcyBpdCB3ZXJlLFxuICAgIC8vIGJlY2F1c2UgaXRzIG9ubHkgcHVycG9zZSB3YXMgc2VsZWN0aW5nIHRleHQsIG5vdCBjbGlja2luZyBidXR0b25zLlxuICAgIC8vXG4gICAgLy8gVG8gY2F0Y2ggdGhpcywgYW55IHRpbWUgdGhlIHRleHQgc2VsZWN0aW9uIGluY2x1ZGVzIHVzIHdoaWxlIGluIHRoZSBtaWRkbGVcbiAgICAvLyBvZiBhIGNsaWNrLCB0aGlzIGZsYWcgaXMgc2V0LCB3aGljaCBjYW5jZWxzIHRoZSBhY3RpdmF0aW9uIG9mIGEgcHJlc3MuXG4gICAgLy8gVGhlIGZsYWcgaXMgcmVzZXQgYW55IHRpbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBvciB0aGUgYnV0dG9uIGlzXG4gICAgLy8gbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICBjb25zdCBbdGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSwgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxEYXRlIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgcHNldWRvQWN0aXZlID0gKGFjdGl2ZSAmJiAodGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSA9PSBudWxsKSk7XG5cbiAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInNlbGVjdGlvbmNoYW5nZVwiLCBfID0+IHtcbiAgICAgICAgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZShwcmV2ID0+IG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZ2V0RWxlbWVudCgpKSA9PSAwID8gbnVsbCA6IHByZXYgIT0gbnVsbCA/IHByZXYgOiBuZXcgRGF0ZSgpKTtcbiAgICB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmUgPT0gMClcbiAgICAgICAgICAgIHNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUobnVsbCk7XG5cbiAgICB9LCBbYWN0aXZlID09IDBdKTtcblxuICAgIGNvbnN0IG9uQWN0aXZlU3RhcnQgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25DbGlja1N5bmM+PigoXykgPT4ge1xuICAgICAgICBzZXRBY3RpdmUoYSA9PiArK2EpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb25BY3RpdmVTdG9wID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2xpY2tTeW5jPj4oKGUpID0+IHtcbiAgICAgICAgc2V0QWN0aXZlKGEgPT4gTWF0aC5tYXgoMCwgLS1hKSk7XG5cbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB0aW1lRGlmZmVyZW5jZSA9ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lID09IG51bGwgPyBudWxsIDogK2N1cnJlbnRUaW1lIC0gK3RleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUpO1xuICAgICAgICBjb25zdCBjaGFyYWN0ZXJzU2VsZWN0ZWQgPSBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGdldEVsZW1lbnQoKSlcblxuICAgICAgICAvLyBJZiB3ZSdyZSBzZWxlY3RpbmcgdGV4dCAoaGV1cmlzdGljYWxseSBkZXRlcm1pbmVkIGJ5IHNlbGVjdGluZyBmb3IgbG9uZ2VyIHRoYW4gMS80IGEgc2Vjb25kLCBvciBtb3JlIHRoYW4gMiBjaGFyYWN0ZXJzKVxuICAgICAgICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBwcmVzcyBldmVudC5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbWVhc3VyZSBnbHlwaHMgaW5zdGVhZCBvZiBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY2hhcmFjdGVyc1NlbGVjdGVkID4gMSB8fCAoKHRpbWVEaWZmZXJlbmNlID8/IDApID4gMjUwICYmIGNoYXJhY3RlcnNTZWxlY3RlZCA+PSAxKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdldEFjdGl2ZSgpIDw9IDApIHtcbiAgICAgICAgICAgIGhhbmRsZVByZXNzKGUpO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTsgIC8vIFRPRE86IFJlbW92ZSB3aGVuIGlzc3VlIHJlc29sdmVkIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzM3MzFcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgaGFuZGxlUHJlc3MgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25DbGlja1N5bmM+PigoZSkgPT4ge1xuICAgICAgICBpZiAob25DbGlja1N5bmMpIHtcblxuICAgICAgICAgICAgLy8gTm90ZTogVGhlIGVsZW1lbnQgaXMgZm9jdXNlZCBoZXJlIGJlY2F1c2Ugb2YgaU9TIFNhZmFyaS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJdCdzIGFsd2F5cyBpT1MgU2FmYXJpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlPUyBTYWZhcmkgKHRlc3RlZCBvbiAxMikgZG93bnJpZ2h0IHJlZnVzZXMgdG8gYWxsb3cgXG4gICAgICAgICAgICAvLyBlbGVtZW50cyB0byBiZSBtYW51YWxseSBmb2N1c2VkIFVOTEVTUyBpdCBoYXBwZW5zIHdpdGhpblxuICAgICAgICAgICAgLy8gYW4gZXZlbnQgaGFuZGxlciBsaWtlIHRoaXMuICBJdCBhbHNvIGRvZXNuJ3QgZm9jdXNcbiAgICAgICAgICAgIC8vIGJ1dHRvbnMgYnkgZGVmYXVsdCB3aGVuIGNsaWNrZWQsIHRhcHBlZCwgZXRjLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIElmIGl0IGJlY29tZXMgcHJvYmxlbWF0aWMgdGhhdCBidXR0b24tbGlrZXMgZXhwbGljaXRseSBiZWNvbWVcbiAgICAgICAgICAgIC8vIGZvY3VzZWQgd2hlbiB0aGV5IGFyZSBwcmVzc2VkLCB0aGVuIGFuIGFsdGVybmF0aXZlIHNvbHV0aW9uIGZvclxuICAgICAgICAgICAgLy8gdGhlIHF1ZXN0aW9uIG9mIFwiaG93IGRvIG1lbnUgYnV0dG9ucyBrZWVwIHRoZWlyIG1lbnVzIG9wZW5cIlxuICAgICAgICAgICAgLy8gYW5kIG90aGVyIGZvY3VzLXJlbGF0ZWQgbm9uc2Vuc2UgbmVlZHMgdG8gYmUgZmlndXJlZCBvdXQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRm9yIGlPUyBTYWZhcmkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIFwiZm9jdXNcIiBpbiAoZWxlbWVudCBhcyBFdmVudFRhcmdldCBhcyBIVE1MRWxlbWVudCkpXG4gICAgICAgICAgICAgICAgKGVsZW1lbnQgYXMgRXZlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQgfCBudWxsKT8uZm9jdXMoKTtcblxuICAgICAgICAgICAgLy8gV2hhdGV2ZXIgdGhlIGJyb3dzZXIgd2FzIGdvaW5nIHRvIGRvIHdpdGggdGhpcyBldmVudCxcbiAgICAgICAgICAgIC8vIGZvcmdldCBpdC4gV2UncmUgdHVybmluZyBpdCBpbnRvIGEgXCJwcmVzc1wiIGV2ZW50LlxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAvLyBBbHNvIHN0b3AgYW55b25lIGVsc2UgZnJvbSBsaXN0ZW5pbmcgdG8gdGhpcyBldmVudCxcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGV4cGxpY2l0bHkgaGFuZGxpbmcgaXQuXG4gICAgICAgICAgICAvLyAoTm90YWJseSwgdGhpcyBhbGxvd3MgbGFiZWxzIHRvIHdyYXAgaW5wdXRzLCB3aXRoIHRoZW1cbiAgICAgICAgICAgIC8vIGJvdGggaGF2aW5nIHByZXNzIGV2ZW50IGhhbmRsZXJzLCB3aXRob3V0IGRvdWJsZS1maXJpbmcpXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBIYXB0aWMgZmVlZGJhY2sgZm9yIHRoaXMgcHJlc3MgZXZlbnRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZG9lc24ndCB0aHJvdyxcbiAgICAgICAgICAgICAgICAvLyBidXQgd2Ugc2hvdWxkIGd1YXJkIGFnYWluc3QgdXNlciBpbXBsZW1lbnRhdGlvbnMgdGhhdCBjb3VsZC5cbiAgICAgICAgICAgICAgICBwdWxzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHkgY2FsbCBvdXIgaGFuZGxlci5cbiAgICAgICAgICAgICAgICBvbkNsaWNrU3luYyhlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBvbk1vdXNlRG93biA9IGV4Y2x1ZGVzKFwiY2xpY2tcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+KSA9PiB7XG4gICAgICAgIC8vIFN0b3AgZG91YmxlIGNsaWNrcyBmcm9tIHNlbGVjdGluZyB0ZXh0IGluIGFuIGNvbXBvbmVudCB0aGF0J3MgKnN1cHBvc2VkKiB0byBiZSBhY3RpbmcgbGlrZSBhIGJ1dHRvbixcbiAgICAgICAgLy8gYnV0IGFsc28gZG9uJ3QgcHJldmVudCB0aGUgdXNlciBmcm9tIHNlbGVjdGluZyB0aGF0IHRleHQgbWFudWFsbHkgaWYgdGhleSByZWFsbHkgd2FudCB0b1xuICAgICAgICAvLyAod2hpY2ggdXNlci1zZWxlY3Q6IG5vbmUgd291bGQgZG8sIGJ1dCBjYW5jZWxsaW5nIGEgZG91YmxlIGNsaWNrIG9uIG1vdXNlRG93biBkb2Vzbid0KVxuICAgICAgICBpZiAoZS5kZXRhaWwgPiAxKVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cbiAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKVxuICAgICAgICAgICAgb25BY3RpdmVTdGFydChlKTtcbiAgICB9XG4gICAgY29uc3Qgb25Nb3VzZVVwID0gZXhjbHVkZXMoXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwICYmIGFjdGl2ZSA+IDApXG4gICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XG4gICAgfTtcblxuXG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAoIWV4Y2x1ZGVzKFwiY2xpY2tcIiwgZXhjbHVkZSkpXG4gICAgICAgICAgICBzZXRBY3RpdmUoMCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvbktleURvd24gPSBleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpICYmIGV4Y2x1ZGVzKFwiZW50ZXJcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGlmIChlLmtleSA9PSBcIiBcIiAmJiBvbkNsaWNrU3luYyAmJiAhZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgYWN0aXZhdGUgaXQgb24gYSBzcGFjZSBrZXlkb3duXG4gICAgICAgICAgICAvLyBidXQgd2UgZG8gcHJldmVudERlZmF1bHQgdG8gc3RvcCB0aGUgcGFnZSBmcm9tIHNjcm9sbGluZy5cbiAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5rZXkgPT0gXCJFbnRlclwiICYmICFleGNsdWRlcyhcImVudGVyXCIsIGV4Y2x1ZGUpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xuICAgICAgICAgICAgb25BY3RpdmVTdG9wKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb25LZXlVcCA9IGV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGlmIChlLmtleSA9PSBcIiBcIiAmJiAhZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSlcbiAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbkNsaWNrID0gKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChlLmRldGFpbCA+IDEpIHtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZVByZXNzUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSB7XG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPihwcm9wcywgdXNlSGFzRm9jdXNQcm9wcygoe1xuICAgICAgICAgICAgb25LZXlEb3duLFxuICAgICAgICAgICAgb25LZXlVcCxcbiAgICAgICAgICAgIG9uTW91c2VEb3duLFxuICAgICAgICAgICAgb25Nb3VzZVVwLFxuICAgICAgICAgICAgb25Nb3VzZUxlYXZlLFxuICAgICAgICAgICAgb25DbGljayxcbiAgICAgICAgICAgIHN0eWxlOiAodGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSAhPSBudWxsKSA/IHsgY3Vyc29yOiBcInRleHRcIiB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLi4ueyBcImRhdGEtcHNldWRvLWFjdGl2ZVwiOiBwc2V1ZG9BY3RpdmUgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9IGFzIHt9XG4gICAgICAgIH0pKSk7XG4gICAgfVxufVxuXG5cblxuXG4vKipcbiAqIHNlbGVjdGlvbi5jb250YWluc05vZGUgZG9lc24ndCBhY2NvdW50IGZvciBzZWxlY3Rpb24uaXNDb2xsYXBzZWQsXG4gKiBzbyBoZXJlJ3MgYSB3b3JrYXJvdW5kIGZvciB0aGF0LlxuICogXG4gKiBXZSBhbHNvIG9ubHkgbG9vayBmb3IgdGhlIHNlbGVjdGlvbiBlbmQgdG8gb25seSBjYXRjaCB0aGUgXG4gKiBlc3NlbnNlIG9mIGEgbm9uLWV4aXN0YW50IFwic2VsZWN0aW9uc3RvcFwiIGV2ZW50LlxuICogXG4gKiBAcGFyYW0gZWxlbWVudCBcbiAqIEByZXR1cm5zIFxuICovXG5mdW5jdGlvbiBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGVsZW1lbnQ6IEV2ZW50VGFyZ2V0IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChzZWxlY3Rpb24/LnJhbmdlQ291bnQgPz8gMCk7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24hLmdldFJhbmdlQXQoaSkhO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY29udGFpbnMocmFuZ2UuZW5kQ29udGFpbmVyKSAmJiAhc2VsZWN0aW9uPy5pc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24hLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59XG5cblxubGV0IHB1bHNlID0gKChcInZpYnJhdGVcIiBpbiBuYXZpZ2F0b3IpICYmIChuYXZpZ2F0b3IudmlicmF0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkgPyAoKCkgPT4gbmF2aWdhdG9yLnZpYnJhdGUoMTApKSA6ICgoKSA9PiB7IH0pO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZW5hYmxlL2Rpc2FibGUgYnV0dG9uIHZpYnJhdGlvbiBwdWxzZXMgb24gYW4gYXBwLXdpZGUgc2NhbGUuXG4gKiBcbiAqIFxuICogQHBhcmFtIGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGEgYnV0dG9uIGlzIHRhcHBlZC5cbiAqIChEZWZhdWx0IGlzIGAoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMClgIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdCwgYSBub29wIG90aGVyd2lzZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFByZXNzVmlicmF0ZShmdW5jOiAoKSA9PiB2b2lkKSB7XG4gICAgcHVsc2UgPSBmdW5jO1xufVxuXG5cblxuZnVuY3Rpb24gZXhjbHVkZXModGFyZ2V0OiBcImNsaWNrXCIgfCBcInNwYWNlXCIgfCBcImVudGVyXCIsIGV4Y2x1ZGU6IHVuZGVmaW5lZCB8IHsgY2xpY2s/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgc3BhY2U/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgZW50ZXI/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCB9KSB7XG4gICAgaWYgKGV4Y2x1ZGU/Llt0YXJnZXRdKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUaW1lb3V0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2AuICBcbiAgICAgKiBJZiBgbnVsbGAsIGNhbmNlbHMgdGhlIHRpbWVvdXQgaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgdGltZW91dDogbnVtYmVyIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdG8gdGhpcyBwcm9wIGJldHdlZW4gcmVuZGVycyBjYW4gYmUgdXNlZCB0byBjbGVhciB0aGUgY3VycmVudCB0aW1lb3V0IGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqL1xuICAgIHRyaWdnZXJJbmRleD86IHVua25vd247XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYHRpbWVvdXRgIG1zIGFmdGVyIG1vdW50LCBvciB0aGUgbGFzdCBjaGFuZ2UgdG8gYHRyaWdnZXJJbmRleGAuXG4gICAgICogXG4gICAgICogRG9lcyAqbm90KiBuZWVkIHRvIGJlIHN0YWJsZS4gR28gYWhlYWQgYW5kIHBhc3MgYW4gYW5vbnltb3VzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVGltZW91dCh7IHRpbWVvdXQsIGNhbGxiYWNrLCB0cmlnZ2VySW5kZXggfTogVXNlVGltZW91dCkge1xuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBzdGFydFRpbWVSZWYuY3VycmVudCA9IG51bGw7IGNhbGxiYWNrKCk7IH0pO1xuICAgIGNvbnN0IGdldFRpbWVvdXQgPSB1c2VTdGFibGVHZXR0ZXIodGltZW91dCk7XG5cbiAgICAvLyBTZXQgYW55IHRpbWUgd2Ugc3RhcnQgdGltZW91dC5cbiAgICAvLyBVbnNldCBhbnkgdGltZSB0aGUgdGltZW91dCBjb21wbGV0ZXNcbiAgICBjb25zdCBzdGFydFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCB0aW1lb3V0SXNOdWxsID0gKHRpbWVvdXQgPT0gbnVsbCk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgdHJpZ2dlckluZGV4IGNoYW5nZXMgKGluY2x1ZGluZyBvbiBtb3VudClcbiAgICAvLyByZXN0YXJ0IHRoZSB0aW1lb3V0LiAgVGhlIHRpbWVvdXQgZG9lcyBOT1QgcmVzZXRcbiAgICAvLyB3aGVuIHRoZSBkdXJhdGlvbiBvciBjYWxsYmFjayBjaGFuZ2VzLCBvbmx5IHRyaWdnZXJJbmRleC5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRpbWVvdXRJc051bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aW1lb3V0SXNOdWxsID09ICh0aW1lb3V0ID09IG51bGwpKTtcbiAgICBcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVSZWYuY3VycmVudCA9ICsobmV3IERhdGUoKSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChzdGFibGVDYWxsYmFjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sIFt0cmlnZ2VySW5kZXgsIHRpbWVvdXRJc051bGxdKVxuXG4gICAgY29uc3QgZ2V0RWxhcHNlZFRpbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKyhuZXcgRGF0ZSgpKSkgLSAoKyhzdGFydFRpbWVSZWYuY3VycmVudCA/PyBuZXcgRGF0ZSgpKSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0UmVtYWluaW5nVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgcmV0dXJuIHRpbWVvdXQgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1heCgwLCB0aW1lb3V0IC0gZ2V0RWxhcHNlZFRpbWUoKSlcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyBnZXRFbGFwc2VkVGltZSwgZ2V0UmVtYWluaW5nVGltZSB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTG9naWNhbERpcmVjdGlvbiB9IGZyb20gXCIuL3VzZS1sb2dpY2FsLWRpcmVjdGlvblwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlVGltZW91dCB9IGZyb20gXCIuL3VzZS10aW1lb3V0XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKiBcbiAgICAgKiBUaGVzZSBwcm9wcyBjYW4gYmUgYXR0YXRjaGVkIGVpdGhlciB0byB0aGUgcGFyZW50IG9yIHRvIGVhY2ggaW5kaXZpZHVhbCBjaGlsZC5cbiAgICAgKiBXaGljaGV2ZXIgd29ya3MgYmV0dGVyIGZvciB5b3VyIHNjZW5hcmlvLlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKiogXG4gICAgICogKi9cbiAgICB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD47XG59XG5cbmludGVyZmFjZSBMTlAge1xuICAgIG5hdmlnYXRlVG9OZXh0KCk6IHZvaWQ7XG4gICAgbmF2aWdhdGVUb1ByZXYoKTogdm9pZDtcbiAgICBuYXZpZ2F0ZVRvRmlyc3QoKTogdm9pZDtcbiAgICBuYXZpZ2F0ZVRvTGFzdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIHdoaWNoIGFycm93IGtleXMgYXJlIHVzZWQgdG8gbmF2aWdhdGUgdGhyb3VnaCB0aGUgY29tcG9uZW50LlxuICAgICAqIE5vdCByZWxhdGl2ZSB0byB0aGUgd3JpdGluZyBtb2RlIC0tIHRoZXNlIGFyZSB0aGUgbGl0ZXJhbCBrZXlzIHRoYXQgbmVlZCB0byBiZSBwcmVzc2VkLlxuICAgICAqIFxuICAgICAqIFVzZSBcImVpdGhlclwiIHRvIGFsbG93IG5hdmlnYXRpb24gaW4gZWl0aGVyIGRpcmVjdGlvbi5cbiAgICAgKiBcbiAgICAgKiBVc2UgXCJub25lXCIgdG8gZGlzYWxsb3cgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIGluIGFueSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbj86IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiIHwgXCJlaXRoZXJcIiB8IFwibm9uZVwiO1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlIFxuICAgICAqIGRpc2FibGVkLCBidXQgbmF2aWdhdGlvbiB3aXRoIHRoZSBob21lICYgZW5kIGtleXMgd2lsbFxuICAgICAqIGJlIHVuYWZmZWN0ZWQuXG4gICAgICovXG4gICAgZGlzYWJsZUFycm93S2V5cz86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgbmF2aWdhdGlvbiB3aXRoIHRoZSBob21lICYgZW5kIGtleXMgd2lsbFxuICAgICAqIGJlIGRpc2FibGVkLCBidXQgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIHdpbGwgYmVcbiAgICAgKiB1bmFmZmVjdGVkLlxuICAgICAqL1xuICAgIGRpc2FibGVIb21lRW5kS2V5cz86IGJvb2xlYW47XG59XG5leHBvcnQgdHlwZSBMaW5lYXJOYXZpZ2F0aW9uT21pdHMgPSBrZXlvZiBMTlA7XG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwYXJlbnQgYHVzZUxpbmVhck5hdmlnYXRpb25gICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPE9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzPiB7XG4gICAgbGluZWFyTmF2aWdhdGlvbjogT21pdDxMTlAsIE9taXRzPlxufVxuXG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjaGlsZCAndXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkYCAqL1xuLy9leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25DaGlsZEluZm8geyB9XG5cbi8qKlxuICogV2hlbiB1c2VkIGluIHRhbmRlbSB3aXRoIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGFsbG93cyBjb250cm9sIG9mXG4gKiB0aGUgdGFiYmFibGUgaW5kZXggd2l0aCB0aGUgYXJyb3cga2V5cy5cbiAqIFxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmVhck5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxpbmVhck5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0ZpcnN0OiBudGYsIG5hdmlnYXRlVG9MYXN0OiBudGwsIG5hdmlnYXRlVG9OZXh0OiBudG4sIG5hdmlnYXRlVG9QcmV2OiBudHAsIG5hdmlnYXRpb25EaXJlY3Rpb246IG5kLCBkaXNhYmxlQXJyb3dLZXlzOiBkYWssIGRpc2FibGVIb21lRW5kS2V5czogZGhlayB9IH06IFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyPik6IFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XG5cbiAgICBuZCA/Pz0gXCJlaXRoZXJcIjtcblxuICAgIC8vY29uc3QgeyBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbywgdXNlTG9naWNhbERpcmVjdGlvblByb3BzIH0gPSB1c2VMb2dpY2FsRGlyZWN0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7fSk7XG5cbiAgICBjb25zdCBuYXZpZ2F0ZVRvRmlyc3QgPSB1c2VTdGFibGVDYWxsYmFjayhudGYpO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9MYXN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRsKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTmV4dCA9IHVzZVN0YWJsZUNhbGxiYWNrKG50bik7XG4gICAgY29uc3QgbmF2aWdhdGVUb1ByZXYgPSB1c2VTdGFibGVDYWxsYmFjayhudHApO1xuICAgIGNvbnN0IGdldERpc2FibGVBcnJvd0tleXMgPSB1c2VTdGFibGVHZXR0ZXIoZGFrKTtcbiAgICBjb25zdCBnZXREaXNhYmxlSG9tZUVuZEtleXMgPSB1c2VTdGFibGVHZXR0ZXIoZGhlayk7XG4gICAgY29uc3QgZ2V0TmF2aWdhdGlvbkRpcmVjdGlvbiA9IHVzZVN0YWJsZUdldHRlcihuZCk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxuICAgICAgICB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHM6IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+ID0+IHtcblxuICAgICAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCBieSB0eXBlYWhlYWQgKGkuZS4gYXNzdW1lIHRoaXMgaXMgYSBrZXlib2FyZCBzaG9ydGN1dClcbiAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgLy9jb25zdCBpbmZvID0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuYXZpZ2F0aW9uRGlyZWN0aW9uID0gZ2V0TmF2aWdhdGlvbkRpcmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FibGVBcnJvd0tleXMgPSBnZXREaXNhYmxlQXJyb3dLZXlzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzYWJsZUhvbWVFbmRLZXlzID0gZ2V0RGlzYWJsZUhvbWVFbmRLZXlzKCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd3NWZXJ0aWNhbE5hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcInZlcnRpY2FsXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd3NIb3Jpem9udGFsTmF2aWdhdGlvbiA9IChuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiaG9yaXpvbnRhbFwiIHx8IG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJlaXRoZXJcIik7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIGFsbG93c1ZlcnRpY2FsTmF2aWdhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgYWxsb3dzVmVydGljYWxOYXZpZ2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIGFsbG93c0hvcml6b250YWxOYXZpZ2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgYWxsb3dzSG9yaXpvbnRhbE5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVIb21lRW5kS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlSG9tZUVuZEtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD4oeyBvbktleURvd24gfSwgcHJvcHMpO1xuICAgICAgICB9LCBbXSksXG4gICAgfVxuXG5cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xuICAgICAgICBjdXJyZW50VHlwZWFoZWFkOiBzdHJpbmcgfCBudWxsO1xuICAgICAgICBpbnZhbGlkVHlwZWFoZWFkOiBib29sZWFuIHwgbnVsbDtcbiAgICB9XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKlxuICAgICAqIENhbiBiZSB1c2VkIG9uIGVpdGhlciB0aGUgcGFyZW50IG9yIGVhY2ggY2hpbGQgZWxlbWVudC5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+O1xuXG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDtcblxufVxuXG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+ID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlID0gdm9pZDtcblxuaW50ZXJmYWNlIFROUCB7XG4gICAgLyoqXG4gICAgICogQSBjb2xsYXRvciB0byB1c2Ugd2hlbiBjb21wYXJpbmcuIElmIG5vdCBwcm92aWRlZCwgc2ltcGx5IHVzZXMgYGxvY2FsZUNvbXBhcmVgIGFmdGVyIHRyYW5zZm9ybWluZyBlYWNoIHRvIGxvd2VyY2FzZSwgd2hpY2ggd2lsbCwgYXQgYmVzdCwgd29yayBva2F5IGluIEVuZ2xpc2guXG4gICAgICovXG4gICAgY29sbGF0b3I/OiBJbnRsLkNvbGxhdG9yO1xuXG4gICAgbm9UeXBlYWhlYWQ/OiBib29sZWFuO1xuXG4gICAgdHlwZWFoZWFkVGltZW91dD86IG51bWJlcjtcbiAgICBnZXRJbmRleCgpOiBudW1iZXIgfCBudWxsO1xuICAgIHNldEluZGV4KHZhbHVlOiBudW1iZXIgfCBudWxsIHwgKChwcmV2aW91c1ZhbHVlOiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKTogdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzID0ga2V5b2YgVE5QO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzPE9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzPiB7XG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogT21pdDxUTlAsIE9taXRzPlxufVxuXG4vKiogQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgY2hpbGQgJ3VzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZGAgKi9cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIElmIHByb3ZpZGVkLCBhbGxvd3MgdGhpcyBjb21wb25lbnQgdG8gYmUgbmF2aWdhdGVkIHRvIGJ5IHR5cGluZyB0aGlzIHN0cmluZy4gXG4gICAgICogSXQgc2hvdWxkIGJlIHRoZSBzYW1lIHRleHQgY29udGVudCBhcyB3aGF0ZXZlcidzIGRpc3BsYXllZCwgaWRlYWxseS5cbiAgICAgKi9cbiAgICB0ZXh0OiBzdHJpbmcgfCBudWxsO1xuXG4gICAgaW5kZXg6IG51bWJlcjtcbn1cblxuLyoqIFR5cGUgb2YgdGhlIGNoaWxkJ3Mgc3ViLWhvb2sgKi9cbmV4cG9ydCB0eXBlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCA9IChhcmdzOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzKSA9PiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlO1xuXG5cbi8qKlxuICogQWxsb3dzIGZvciB0aGUgc2VsZWN0aW9uIG9mIGEgbWFuYWdlZCBjaGlsZCBieSB0eXBpbmcgdGhlIGdpdmVuIHRleHQgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICogXG4gKiBAc2VlIHVzZUxpc3ROYXZpZ2F0aW9uLCB3aGljaCBwYWNrYWdlcyBldmVyeXRoaW5nIHVwIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgZ2V0SW5kZXgsIHR5cGVhaGVhZFRpbWVvdXQsIHNldEluZGV4LCBub1R5cGVhaGVhZCB9IH06IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyPik6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XG5cblxuICAgIC8vIEZvciB0eXBlYWhlYWQsIGtlZXAgdHJhY2sgb2Ygd2hhdCBvdXIgY3VycmVudCBcInNlYXJjaFwiIHN0cmluZyBpcyAoaWYgd2UgaGF2ZSBvbmUpXG4gICAgLy8gYW5kIGFsc28gY2xlYXIgaXQgZXZlcnkgMTAwMCBtcyBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IGNoYW5nZWQuXG4gICAgLy8gTmV4dCwga2VlcCBhIG1hcHBpbmcgb2YgdHlwZWFoZWFkIHZhbHVlcyB0byBpbmRpY2VzIGZvciBmYXN0ZXIgc2VhcmNoaW5nLlxuICAgIC8vIEFuZCwgZm9yIHRoZSB1c2VyJ3Mgc2FrZSwgbGV0IHRoZW0ga25vdyB3aGVuIHRoZWlyIHR5cGVhaGVhZCBjYW4ndCBtYXRjaCBhbnl0aGluZyBhbnltb3JlXG4gICAgY29uc3QgW2N1cnJlbnRUeXBlYWhlYWQsIHNldEN1cnJlbnRUeXBlYWhlYWQsIGdldEN1cnJlbnRUeXBlYWhlYWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgdXNlVGltZW91dCh7IHRpbWVvdXQ6IHR5cGVhaGVhZFRpbWVvdXQgPz8gMTAwMCwgY2FsbGJhY2s6ICgpID0+IHsgc2V0Q3VycmVudFR5cGVhaGVhZChudWxsKTsgc2V0SW52YWxpZFR5cGVhaGVhZChudWxsKTsgfSwgdHJpZ2dlckluZGV4OiBjdXJyZW50VHlwZWFoZWFkIH0pO1xuICAgIGNvbnN0IHNvcnRlZFR5cGVhaGVhZEluZm8gPSB1c2VSZWY8eyB0ZXh0OiBzdHJpbmcsIHVuc29ydGVkSW5kZXg6IG51bWJlciB9W10+KFtdKTtcbiAgICBjb25zdCBbaW52YWxpZFR5cGVhaGVhZCwgc2V0SW52YWxpZFR5cGVhaGVhZF0gPSB1c2VTdGF0ZTxib29sZWFuIHwgbnVsbD4oZmFsc2UpO1xuXG4gICAgLy8gSGFuZGxlIHR5cGVhaGVhZCBmb3IgaW5wdXQgbWV0aG9kIGVkaXRvcnMgYXMgd2VsbFxuICAgIC8vIEVzc2VudGlhbGx5LCB3aGVuIGFjdGl2ZSwgaWdub3JlIGZ1cnRoZXIga2V5cyBcbiAgICAvLyBiZWNhdXNlIHdlJ3JlIHdhaXRpbmcgZm9yIGEgQ29tcG9zaXRpb25FbmQgZXZlbnRcbiAgICBjb25zdCBbLCBzZXRJbWVBY3RpdmUsIGdldEltZUFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICAvLyBCZWNhdXNlIGNvbXBvc2l0aW9uIGV2ZW50cyBmaXJlICphZnRlcioga2V5ZG93biBldmVudHMgXG4gICAgLy8gKGJ1dCB3aXRoaW4gdGhlIHNhbWUgdGFzaywgd2hpY2gsIFRPRE8sIGNvdWxkIGJlIGJyb3dzZXItZGVwZW5kZW50KSxcbiAgICAvLyB3ZSBjYW4gdXNlIHRoaXMgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBldmVudCB3ZSdyZSBsaXN0ZW5pbmcgZm9yIG9uIHRoZSBmaXJzdCBrZXlkb3duLlxuICAgIGNvbnN0IFtuZXh0VHlwZWFoZWFkQ2hhciwgc2V0TmV4dFR5cGVhaGVhZENoYXJdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG5leHRUeXBlYWhlYWRDaGFyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHR5cGVhaGVhZCA9PiAoKHR5cGVhaGVhZCA/PyBcIlwiKSArIG5leHRUeXBlYWhlYWRDaGFyKSk7XG4gICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihudWxsKTtcbiAgICAgICAgfVxuICAgIH0sIFtuZXh0VHlwZWFoZWFkQ2hhcl0pO1xuXG5cbiAgICBjb25zdCBjb21wYXJhdG9yU2hhcmVkID0gdXNlU3RhYmxlQ2FsbGJhY2soKHNhZmVMaHM6IHN0cmluZywgc2FmZVJoczogc3RyaW5nKSA9PiB7XG4gICAgICAgIGxldCBjb21wYXJlOiBudW1iZXI7XG4gICAgICAgIC8vIEZvciB0aGUgcHVycG9zZXMgb2YgdHlwZWFoZWFkLCBvbmx5IGNvbXBhcmUgYSBzdHJpbmcgb2YgdGhlIHNhbWUgc2l6ZSBhcyBvdXIgY3VycmVudGx5IHR5cGVkIHN0cmluZy5cbiAgICAgICAgLy8gQnkgbm9ybWFsaXppbmcgdGhlbSBmaXJzdCwgd2UgZW5zdXJlIHRoaXMgYnl0ZS1ieS1ieXRlIGhhbmRsaW5nIG9mIHJhdyBjaGFyYWN0ZXIgZGF0YSB3b3JrcyBvdXQgb2theS5cbiAgICAgICAgc2FmZUxocyA9IHNhZmVMaHMubm9ybWFsaXplKFwiTkZEXCIpO1xuICAgICAgICBzYWZlUmhzID0gc2FmZVJocy5ub3JtYWxpemUoXCJORkRcIilcblxuICAgICAgICBpZiAoY29sbGF0b3IpXG4gICAgICAgICAgICBjb21wYXJlID0gY29sbGF0b3IuY29tcGFyZShzYWZlTGhzLCBzYWZlUmhzKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb21wYXJlID0gc2FmZUxocy50b0xvd2VyQ2FzZSgpLmxvY2FsZUNvbXBhcmUoc2FmZVJocy50b0xvd2VyQ2FzZSgpID8/IFwiXCIpO1xuXG4gICAgICAgIHJldHVybiBjb21wYXJlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaW5zZXJ0aW5nQ29tcGFyYXRvciA9IHVzZVN0YWJsZUNhbGxiYWNrKChsaHM6IHN0cmluZywgcmhzOiB7IHRleHQ6IHN0cmluZzsgdW5zb3J0ZWRJbmRleDogbnVtYmVyOyB9KSA9PiB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJocy50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvclNoYXJlZChsaHMsIHJocy50ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobGhzIGFzIHVua25vd24gYXMgbnVtYmVyKSAtIChyaHMgYXMgdW5rbm93biBhcyBudW1iZXIpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdHlwZWFoZWFkQ29tcGFyYXRvciA9IHVzZVN0YWJsZUNhbGxiYWNrKChsaHM6IHN0cmluZywgcmhzOiB7IHRleHQ6IHN0cmluZzsgdW5zb3J0ZWRJbmRleDogbnVtYmVyOyB9KSA9PiB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJocy50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBEdXJpbmcgdHlwZWFoZWFkLCBhbGwgc3RyaW5ncyBsb25nZXIgdGhhbiBvdXJzIHNob3VsZCBiZSB0cnVuY2F0ZWRcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhleSdyZSBhbGwgY29uc2lkZXJlZCBlcXVhbGx5IGJ5IHRoYXQgcG9pbnQuXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvclNoYXJlZChsaHMsIHJocy50ZXh0LnN1YnN0cmluZygwLCBsaHMubGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGxocyBhcyB1bmtub3duIGFzIG51bWJlcikgLSAocmhzIGFzIHVua25vd24gYXMgbnVtYmVyKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSB1c2VTdGFibGVHZXR0ZXIobm9UeXBlYWhlYWQpO1xuXG5cbiAgICBjb25zdCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD4gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xuXG4gICAgICAgIGNvbnN0IG9uQ29tcG9zaXRpb25TdGFydCA9IChfZTogQ29tcG9zaXRpb25FdmVudCkgPT4geyBzZXRJbWVBY3RpdmUodHJ1ZSkgfTtcbiAgICAgICAgY29uc3Qgb25Db21wb3NpdGlvbkVuZCA9IChlOiBDb21wb3NpdGlvbkV2ZW50KSA9PiB7XG4gICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihlLmRhdGEpO1xuICAgICAgICAgICAgc2V0SW1lQWN0aXZlKGZhbHNlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBvbktleURvd24gPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGNvbnN0IGltZUFjdGl2ZSA9IGdldEltZUFjdGl2ZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBlLmtleTtcblxuICAgICAgICAgICAgLy8gTm90IGhhbmRsZWQgYnkgdHlwZWFoZWFkIChpLmUuIGFzc3VtZSB0aGlzIGlzIGEga2V5Ym9hcmQgc2hvcnRjdXQpXG4gICAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmICghaW1lQWN0aXZlICYmIGUua2V5ID09PSBcIkJhY2tzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsYXN0IGNoYXJhY3RlciBpbiBhIHdheSB0aGF0IGRvZXNuJ3Qgc3BsaXQgVVRGLTE2IHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGVhaGVhZCh0ID0+IHQgPT09IG51bGwgPyBudWxsIDogWy4uLnRdLnJldmVyc2UoKS5zbGljZSgxKS5yZXZlcnNlKCkuam9pbihcIlwiKSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUga2V5IHByb3BlcnR5IHJlcHJlc2VudHMgdGhlIHR5cGVkIGNoYXJhY3RlciBPUiB0aGUgXCJuYW1lZCBrZXkgYXR0cmlidXRlXCIgb2YgdGhlIGtleSBwcmVzc2VkLlxuICAgICAgICAgICAgLy8gVGhlcmUncyBubyBkZWZpbml0ZSB3YXkgdG8gdGVsbCB0aGUgZGlmZmVyZW5jZSwgYnV0IGZvciBhbGwgaW50ZW50cyBhbmQgcHVycG9zZXNcbiAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBvbmUtY2hhcmFjdGVyIG5hbWVzLCBhbmQgdGhlcmUgYXJlIG5vIG5vbi1BU0NJSS1hbHBoYSBuYW1lcy5cbiAgICAgICAgICAgIC8vIFRodXMsIGFueSBvbmUtY2hhcmFjdGVyIG9yIG5vbi1BU0NJSSB2YWx1ZSBmb3IgYGtleWAgaXMgKmFsbW9zdCBjZXJ0YWlubHkqIGEgdHlwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgY29uc3QgaXNDaGFyYWN0ZXJLZXkgPSAoa2V5Lmxlbmd0aCA9PT0gMSB8fCAhL15bQS1aYS16XS8udGVzdChrZXkpKTtcbiAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlcktleSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PSBcIiBcIiAmJiAoZ2V0Q3VycmVudFR5cGVhaGVhZCgpID8/IFwiXCIpLnRyaW0oKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBiZWNhdXNlIGEgc3BhY2ViYXIgY2FuJ3QgZXZlciBcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhdGUgYSB0eXBlYWhlYWQsIG9ubHkgY29udGludWUgb25lLlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIChTcGVjaWZpY2FsbHksIGxldCB0aGUgZXZlbnQgY29udGludWUgcHJvcGFnYXRpb24gaW4gdGhpcyBjYXNlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogV29uJ3QgYmUgdHJ1ZSBmb3IgdGhlIGZpcnN0IGtleWRvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gYmVmb3JlIHVzZUxheW91dEVmZmVjdCBpcyBjYWxsZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYWN0dWFsbHkgYXBwbHkgdGhlIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWltZUFjdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7IG9uS2V5RG93biwgb25Db21wb3NpdGlvblN0YXJ0LCBvbkNvbXBvc2l0aW9uRW5kLCB9LCBwcm9wcyk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gSGFuZGxlIGNoYW5nZXMgaW4gdHlwZWFoZWFkIHRoYXQgY2F1c2UgY2hhbmdlcyB0byB0aGUgdGFiYmFibGUgaW5kZXhcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY3VycmVudFR5cGVhaGVhZCAmJiBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoKSB7XG5cblxuXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRUeXBlYWhlYWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIGN1cnJlbnRUeXBlYWhlYWQsIHR5cGVhaGVhZENvbXBhcmF0b3IpO1xuXG4gICAgICAgICAgICBpZiAoc29ydGVkVHlwZWFoZWFkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgaGFzIHR5cGVkIGFuIGVudHJ5IHRoYXQgZG9lc24ndCBleGlzdCBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIC8vIChvciBtb3JlIHNwZWNpZmljYWxseSBcImZvciB3aGljaCB0aGVyZSBpcyBubyBlbnRyeSB0aGF0IHN0YXJ0cyB3aXRoIHRoYXQgaW5wdXRcIilcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0SW52YWxpZFR5cGVhaGVhZChmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgV2Uga25vdyByb3VnaGx5IHdoZXJlLCBpbiB0aGUgc29ydGVkIGFycmF5IG9mIHN0cmluZ3MsIG91ciBuZXh0IHR5cGVhaGVhZCBsb2NhdGlvbiBpcy5cbiAgICAgICAgICAgICAgICAgIEJ1dCByb3VnaGx5IGlzbid0IGdvb2QgZW5vdWdoIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzLlxuICAgICAgICAgICAgICAgICAgVG8gY29udmVydCBvdXIgc29ydGVkIGluZGV4IHRvIHRoZSB1bnNvcnRlZCBpbmRleCB3ZSBuZWVkLCB3ZSBoYXZlIHRvIGZpbmQgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICBlbGVtZW50IHRoYXQgbWF0Y2hlcyB1cyAqYW5kKiAoaWYgYW55IHN1Y2ggZXhpc3QpIGlzICphZnRlciogb3VyIGN1cnJlbnQgc2VsZWN0aW9uLlxuXG4gICAgICAgICAgICAgICAgICBJbiBvdGhlciB3b3JkcywgdGhlIG9ubHkgd2F5IHR5cGVhaGVhZCBtb3ZlcyBiYWNrd2FyZHMgcmVsYXRpdmUgdG8gb3VyIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIGlzIGlmIHRoZSBvbmx5IG90aGVyIG9wdGlvbiBpcyBiZWhpbmQgdXMuXG5cbiAgICAgICAgICAgICAgICAgIEl0J3Mgbm90IHNwZWNpZmllZCBpbiBXQUktQVJJQSB3aGF0IHRvIGRvIGluIHRoYXQgY2FzZS4gIEkgc3VwcG9zZSB3cmFwIGJhY2sgdG8gdGhlIHN0YXJ0P1xuICAgICAgICAgICAgICAgICAgVGhvdWdoIHRoZXJlJ3MgYWxzbyBhIGNhc2UgZm9yIGp1c3QgZ29pbmcgdXB3YXJkcyB0byB0aGUgbmVhcmVzdCB0byBwcmV2ZW50IGp1bXBpbmVzcy5cbiAgICAgICAgICAgICAgICAgIEJ1dCBpZiB5b3UncmUgYWxyZWFkeSBkb2luZyB0eXBlYWhlYWQgb24gYW4gdW5zb3J0ZWQgbGlzdCwgbGlrZSwganVtcGluZXNzIGNhbid0IGJlIGF2b2lkZWQuXG4gICAgICAgICAgICAgICAgICBJIGR1bm5vLiBHb2luZyBiYWNrIHRvIHRoZSBzdGFydCBpcyB0aGUgc2ltcGxpc3QgdGhvdWdoLlxuXG4gICAgICAgICAgICAgICAgICBCYXNpY2FsbHkgd2hhdCB0aGlzIGRvZXM6IFN0YXJ0aW5nIGZyb20gd2hlcmUgd2UgZm91bmQgb3Vyc2VsdmVzIGFmdGVyIG91ciBiaW5hcnkgc2VhcmNoLFxuICAgICAgICAgICAgICAgICAgc2NhbiBiYWNrd2FyZHMgYW5kIGZvcndhcmRzIHRocm91Z2ggYWxsIGFkamFjZW50IGVudHJpZXMgdGhhdCBhbHNvIGNvbXBhcmUgZXF1YWxseSBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICB3ZSBjYW4gZmluZCB0aGUgb25lIHdob3NlIGB1bnNvcnRlZEluZGV4YCBpcyB0aGUgbG93ZXN0IGFtb25nc3QgYWxsIG90aGVyIGVxdWFsIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgIChhbmQgYWxzbyB0aGUgbG93ZXN0IGB1bnNvcnRlZEluZGV4YCB5YWRkYSB5YWRkYSBleGNlcHQgdGhhdCBpdCBjb21lcyBhZnRlciB1cykuXG5cbiAgICAgICAgICAgICAgICAgIFRPRE86IFRoZSBiaW5hcnkgc2VhcmNoIHN0YXJ0cyB0aGlzIG9mZiB3aXRoIGEgc29saWQgTyhsb2cgbiksIGJ1dCBvbmUtY2hhcmFjdGVyIFxuICAgICAgICAgICAgICAgICAgc2VhcmNoZXMgYXJlLCB0aGFua3MgdG8gcGlnZW9uaG9sZSBwcmluY2lwYWwsIGV2ZW50dWFsbHkgZ3VhcmFudGVlZCB0byBiZWNvbWUgXG4gICAgICAgICAgICAgICAgICBPKG4qbG9nIG4pLiBUaGlzIGlzIGFubm95aW5nIGJ1dCBwcm9iYWJseSBub3QgZWFzaWx5IHNvbHZhYmxlPyBUaGVyZSBjb3VsZCBiZSBhbiBcbiAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiBmb3Igb25lLWNoYXJhY3RlciBzdHJpbmdzLCBidXQgdGhhdCdzIGp1c3Qga2lja2luZyB0aGUgY2FuIGRvd24gXG4gICAgICAgICAgICAgICAgICB0aGUgcm9hZC4gTWF5YmUgb25lIG9yIHR3byBjaGFyYWN0ZXJzIHdvdWxkIGJlIGdvb2QgZW5vdWdoIHRob3VnaC5cbiAgICAgICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjYW5kaWRhdGVzJyBwb3NpdGlvbnMgaW4gYm90aCBvdXIgc29ydGVkIGFycmF5IGFuZCB0aGUgdW5zb3J0ZWQgRE9NLlxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4QWxsOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0U29ydGVkSW5kZXhBbGwgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIHR3byBhcmUgb25seSBzZXQgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIGFoZWFkIG9mIHVzLCBidXQgdGhlIHByaW5jaXBsZSdzIHRoZSBzYW1lIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4TmV4dCA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlQmVzdEZpdCA9ICh1OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgPT0gbnVsbCB8fCB1IDwgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9IHU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleEFsbCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9PSBudWxsIHx8IHUgPCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCkgJiYgdSA+IChnZXRJbmRleCgpID8/IC1JbmZpbml0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ID0gdTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNvcnRlZEluZGV4TmV4dCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgdHlwZWFoZWFkQ29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQmVzdEZpdChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoICYmIHR5cGVhaGVhZENvbXBhcmF0b3IoY3VycmVudFR5cGVhaGVhZCwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBzZXRJbmRleChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbbG93ZXN0U29ydGVkSW5kZXhOZXh0XS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBzZXRJbmRleChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbbG93ZXN0U29ydGVkSW5kZXhBbGxdLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2N1cnJlbnRUeXBlYWhlYWRdKTtcblxuICAgIGNvbnN0IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCA9IHVzZUNhbGxiYWNrPFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZD4oKHsgaW5kZXgsIHRleHQgfSkgPT4ge1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGV4dCkge1xuXG4gICAgICAgICAgICAgICAgLy8gRmluZCB3aGVyZSB0byBpbnNlcnQgdGhpcyBpdGVtLlxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgYWxsIGluZGV4IHZhbHVlcyBzaG91bGQgYmUgdW5pcXVlLCB0aGUgcmV0dXJuZWQgc29ydGVkSW5kZXhcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYWx3YXlzIHJlZmVyIHRvIGEgbmV3IGxvY2F0aW9uIChpLmUuIGJlIG5lZ2F0aXZlKSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIHRleHQsIGluc2VydGluZ0NvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBpbnNlcnRpbmdDb21wYXJhdG9yKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtzb3J0ZWRJbmRleF0udGV4dCwgeyB1bnNvcnRlZEluZGV4OiBpbmRleCwgdGV4dCB9KSA9PSAwKTtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2UoLXNvcnRlZEluZGV4IC0gMSwgMCwgeyB0ZXh0LCB1bnNvcnRlZEluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2Uoc29ydGVkSW5kZXgsIDAsIHsgdGV4dCwgdW5zb3J0ZWRJbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1bm1vdW50aW5nLCBmaW5kIHdoZXJlIHdlIHdlcmUgYW5kIHJlbW92ZSBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFnYWluLCB3ZSBzaG91bGQgYWx3YXlzIGZpbmQgb3Vyc2VsdmVzIGJlY2F1c2UgdGhlcmUgc2hvdWxkIGJlIG5vIGR1cGxpY2F0ZSB2YWx1ZXMgaWYgZWFjaCBpbmRleCBpcyB1bmlxdWUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgdGV4dCwgaW5zZXJ0aW5nQ29tcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBpbnNlcnRpbmdDb21wYXJhdG9yKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtzb3J0ZWRJbmRleF0udGV4dCwgeyB1bnNvcnRlZEluZGV4OiBpbmRleCwgdGV4dCB9KSA9PSAwKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGVkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZShzb3J0ZWRJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt0ZXh0XSk7XG5cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMsXG5cbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgICAgIGludmFsaWRUeXBlYWhlYWQsXG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLyoqXG4gKiBZb3VyIHVzdWFsIGJpbmFyeSBzZWFyY2ggaW1wbGVtZW50YXRpb24uXG4gKiBcbiAqIEl0J3MgdXNlZCBoZXJlIHRvIHF1aWNrbHkgZmluZCBhIGdvb2Qgc3BvdCB0byBzdGFydCBzZWFyY2hpbmcgZm9yIG91ciBuZXh0IHR5cGVhaGVhZCBjYW5kaWRhdGUuXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaCB0aHJvdWdoXG4gKiBAcGFyYW0gd2FudGVkIFRoZSB2YWx1ZSB5b3UnZCBsaWtlIHRvIGZpbmRcbiAqIEBwYXJhbSBjb21wYXJhdG9yIENvbXBhcmVzIGB3YW50ZWRgIHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgaW4gYGFycmF5YFxuICogQHJldHVybnMgQSBub24tbmVnYXRpdmUgdmFsdWUgaWYgYHdhbnRlZGAgd2FzIGZvdW5kLCBhbmQgYSBuZWdhdGl2ZSBudW1iZXIgaWYgbm90LiBcbiAqIFRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIG51bWJlciwgbWludXMgb25lLCBpcyB3aGVyZSBgd2FudGVkYCAqd291bGQqIGJlIGZvdW5kIGlmIGl0ICp3YXMqIGluIGBhcnJheWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaDxULCBVLCBGIGV4dGVuZHMgKGxoczogVSwgcmhzOiBUKSA9PiBudW1iZXI+KGFycmF5OiBUW10sIHdhbnRlZDogVSwgY29tcGFyYXRvcjogRik6IG51bWJlciB7XG4gICAgbGV0IGZpcnN0SW5kZXggPSAwO1xuICAgIGxldCBsYXN0SW5kZXggPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChmaXJzdEluZGV4IDw9IGxhc3RJbmRleCkge1xuICAgICAgICBjb25zdCB0ZXN0SW5kZXggPSAobGFzdEluZGV4ICsgZmlyc3RJbmRleCkgPj4gMTtcbiAgICAgICAgY29uc3QgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmF0b3Iod2FudGVkLCBhcnJheVt0ZXN0SW5kZXhdKTtcblxuICAgICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSB0ZXN0SW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSB0ZXN0SW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRlc3RJbmRleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtZmlyc3RJbmRleCAtIDE7XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBDaGlsZEZsYWdPcGVyYXRpb25zLCBNYW5hZ2VkQ2hpbGRPbWl0cywgTWFuYWdlZENoaWxkcmVuT21pdHMsIE9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgdXNlQ2hpbGRyZW5GbGFnLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZUhhc0ZvY3VzIH0gZnJvbSBcIi4vdXNlLWhhcy1mb2N1c1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcblxuLy9leHBvcnQgdHlwZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbzxLIGV4dGVuZHMgc3RyaW5nLCBJIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZEluZm9CYXNlPEs+PiA9IFJlcXVpcmVkPEk+ICYgRmxhZ2dhYmxlQ2hpbGRJbmZvPFwidGFiYmFibGVcIj4gJiB7XG4vL307XG5cbmV4cG9ydCB0eXBlIE9uVGFiYmFibGVJbmRleENoYW5nZSA9ICh0YWJiYWJsZUluZGV4OiBudW1iZXIgfCBudWxsKSA9PiB2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxFIGV4dGVuZHMgRWxlbWVudCwgQz4ge1xuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRhYmJpbmcgdGhyb3VnaCB0aGlzIGNvbXBvbmVudCB3aWxsIGNhdXNlIHRoZSByZWZlcmVuY2VkIGVsZW1lbnQgdG8gYmUgZm9jdXNlZC5cbiAgICAgKiBcbiAgICAgKiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgdG8gZG8gc29tZXRoaW5nIGRpZmZlcmVudCBpZiB5b3UnZCBsaWtlLlxuICAgICAqL1xuICAgIGZvY3VzU2VsZigpOiB2b2lkO1xuXG4gICAgLy9ibHVyU2VsZigpOiB2b2lkO1xuXG4gICAgZ2V0RWxlbWVudCgpOiBFIHwgbnVsbDtcblxuICAgIGhpZGRlbjogYm9vbGVhbjtcblxuICAgIHN1YkluZm86IEM7XG59XG5cbmludGVyZmFjZSBSVElQIHtcbiAgICAvLyBDYWxsZWQgZHVyaW5nIGFuIGVmZmVjdCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyByZW5kZXJlZCBpdHNlbGYgaW4gYSB0YWJiYWJsZSBzdGF0ZVxuICAgIG9uVGFiYmFibGVSZW5kZXI/OiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcblxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZT86IE9uVGFiYmFibGVJbmRleENoYW5nZTtcblxuICAgIC8vb25UYWJiZWRJblRvPzogKCkgPT4gdm9pZDtcbiAgICAvL29uVGFiYmVkT3V0T2Y/OiAoKSA9PiB2b2lkO1xuXG4gICAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xufVxuZXhwb3J0IHR5cGUgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMgPSBrZXlvZiBSVElQO1xuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8UnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBNY09taXRzPiB7XG4gICAgcm92aW5nVGFiSW5kZXg6IE9taXQ8UlRJUCwgUnRpT21pdHM+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxudW1iZXIsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcbiAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBzZXRUYWJiYWJsZUluZGV4OiAodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRUYWJiYWJsZUluZGV4OiAoKSA9PiBudW1iZXIgfCBudWxsO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBmb2N1c1NlbGY6ICgpID0+IHZvaWQ7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzXG4gICAgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj5cbntcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPjtcbn1cblxuZXhwb3J0IHR5cGUgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzID0ga2V5b2YgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgYW55PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nLCBSdGljT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCIsIE1jT21pdHMgfCBcInN1YkluZm9cIj4ge1xuICAgIHJvdmluZ1RhYkluZGV4OiBPbWl0PFBhcnRpYWw8T21pdDxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88YW55LCBhbnk+LCBcImdldEVsZW1lbnRcIiB8IFwic3ViSW5mb1wiPj4sIFJ0aWNPbWl0cz47XG4gICAgc3ViSW5mbzogU3ViYmVzdEluZm87XG59XG5cbmV4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cywgbmV2ZXIsIG5ldmVyLCBSdGlTdWJJbmZvPikgPT4gVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgIHRhYmJhYmxlOiBib29sZWFuO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRUYWJiYWJsZSgpOiBib29sZWFuO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRFbGVtZW50KCk6IENoaWxkRWxlbWVudCB8IG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xufVxuXG5cbi8qKlxuICogSW1wbGVtZW50cyBhIHJvdmluZyB0YWJpbmRleCBzeXN0ZW0gd2hlcmUgb25seSBvbmUgXCJmb2N1c2FibGVcIlxuICogY29tcG9uZW50IGluIGEgc2V0IGlzIGFibGUgdG8gcmVjZWl2ZSBhIHRhYiBmb2N1cy4gKldoaWNoKlxuICogb2YgdGhvc2UgZWxlbWVudHMgcmVjZWl2ZXMgZm9jdXMgaXMgZGV0ZXJtaW5lZCBieSB5b3UsIGJ1dCBpdCdzXG4gKiByZWNvbW1lbmRlZCB0byBvZmZsb2FkIHRoYXQgbG9naWMgdGhlbiB0byBhbm90aGVyIGhvb2ssIGxpa2VcbiAqIGB1c2VMaW5lYXJOYXZpZ2F0aW9uYCwgd2hpY2ggbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZVxuICogZWxlbWVudCB3aXRoIHRoZSBhcnJvdyBrZXlzLCBgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbmAsIHdoaWNoXG4gKiBsZXRzIHlvdSBjaGFuZ2UgdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdHlwZWFoZWFkLCBvclxuICogYHVzZUxpc3ROYXZpZ2F0aW9uYCBpZiB5b3UganVzdCB3YW50IGV2ZXJ5dGhpbmcgYnVuZGxlZCB0b2dldGhlci5cbiAqIFxuICogTm90ZSB0aGF0IHRoZSBjaGlsZCBob29rIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkXG4gKiBieSBldmVyeSBjaGlsZCB0aGF0IHVzZXMgdGhpcyByb3ZpbmcgdGFiaW5kZXggbG9naWMuICBUaGVcbiAqIHByb3AtbW9kaWZ5aW5nIGhvb2sgKnRoYXQqIGhvb2sgcmV0dXJucyBzaG91bGQgdGhlbiBiZSB1c2VkXG4gKiBvbiB0aGUgY2hpbGQncyBlbGVtZW50LCBhcyB3ZWxsIGFzIGFueSBvdGhlciBlbGVtZW50cyB5b3UnZCBsaWtlXG4gKiB0byBiZSBleHBsaWNpdGx5IG1hZGUgdW50YWJiYWJsZSB0b28uXG4gKiBcbiAqIGBzaG91bGRGb2N1c09uQ2hhbmdlYCBzaG91bGQgcmV0dXJuIHRydWUgaWYgZm9jdXMgaXMgXG4gKiBjb250YWluZWQgd2l0aGluIHdoYXRldmVyIGVsZW1lbnQgY29udGFpbnMgdGhlIHJvdmluZyB0YWIgaW5kZXguXG4gKiBHZW5lcmFsbHkgYXMgc2ltcGxlIGFzIHRoZSBmb2xsb3dpbmc6XG4gKiBgYGBcbiAqIGNvbnN0IFtmb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gKiBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPFBhcmVudEVsZW1lbnQ+KHsgc2V0Rm9jdXNlZElubmVyIH0pO1xuICogY29uc3QgZm9jdXNPbkNoYW5nZSA9IChmb2N1c2VkSW5uZXIgIT0gZmFsc2UpO1xuICogYGBgXG4gKiBJdCdzIG5vdCBpbmNsdWRlZCBoZXJlIGJlY2F1c2UgYHVzZVJvdmluZ1RhYkluZGV4YCBkb2Vzbid0IGtub3cgXG4gKiBhbnl0aGluZyBhYm91dCB0aGUgY29udGFpbmVyIGVsZW1lbnQsIG9ubHkgY2hpbGRyZW4gZWxlbWVudHMuXG4gKiBBbmQganVzdCBhcyB3ZWxsISBDaGlsZHJlbiBzaG91bGQgYmUgYWxsb3dlZCBhdCB0aGUgcm9vdCwgXG4gKiByZWdhcmRsZXNzIG9mIGlmIGl0J3MgdGhlIHdob2xlIGFwcCBvciBqdXN0IGEgZ2l2ZW4gY29tcG9uZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4ocGFyZW50UGFyYW1ldGVyczogVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPG5ldmVyLCBuZXZlcj4pOiBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG5cbiAgICBsZXQgeyByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVSZW5kZXIsIG9uVGFiYmFibGVJbmRleENoYW5nZSB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9ID0gcGFyZW50UGFyYW1ldGVycztcblxuICAgIGluaXRpYWxJbmRleCA/Pz0gMDtcbiAgICBjb25zdCBzdGFibGVPblRhYmJhYmxlUmVuZGVyID0gdXNlU3RhYmxlQ2FsbGJhY2sob25UYWJiYWJsZVJlbmRlciA/PyAoKCkgPT4geyB9KSk7XG4gICAgLypjb25zdCBbX2dldEFueUZvY3VzZWQsIHNldEFueUZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlcj4odXNlU3RhYmxlQ2FsbGJhY2soKG5ld0NvdW50OiBudW1iZXIsIG9sZENvdW50OiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKG9sZENvdW50ID09IDAgJiYgbmV3Q291bnQgPiAwKSB7XG4gICAgICAgICAgICBvblRhYmJlZEluVG8/LigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0NvdW50ID09IDAgJiYgKG9sZENvdW50ID8/IDApID4gMCkge1xuICAgICAgICAgICAgb25UYWJiZWRPdXRPZj8uKCk7XG4gICAgICAgIH1cbiAgICB9KSwgcmV0dXJuWmVybyk7Ki9cblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhyZWUgdGhpbmdzIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnRseSB0YWJiYWJsZSBlbGVtZW50J3MgaW5kZXg6XG4gICAgLy8gV2hhdCBpdCBpcywgYW5kIHdoZXRoZXIsIHdoZW4gd2UgcmVuZGVyIHRoaXMgY29tcG9uZW50IGFuZCBpdCdzIGNoYW5nZWQsIHRvIGFsc28gZm9jdXMgdGhlIGVsZW1lbnQgdGhhdCB3YXMgbWFkZSB0YWJiYWJsZS5cbiAgICBjb25zdCBbZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleDJdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGw+KG9uVGFiYmFibGVJbmRleENoYW5nZSwgdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gaW5pdGlhbEluZGV4ID8/IDAgfSwgW10pKTtcbiAgICBjb25zdCBzZXRUYWJiYWJsZUluZGV4ID0gdXNlQ2FsbGJhY2soKHVwZGF0ZXI6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xuICAgICAgICBzZXRUYWJiYWJsZUluZGV4MigocHJldkluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSB1cGRhdGVyKHByZXZJbmRleCA/PyBudWxsKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSB1cGRhdGVyO1xuXG4gICAgICAgICAgICBuZXh0SW5kZXggPSBjaGFuZ2VJbmRleChuZXh0SW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAocHJldkluZGV4ICE9IG5leHRJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IG5leHRJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KG5leHRJbmRleCk7XG4gICAgICAgICAgICAgICAgLy9jb25zdCBwcmV2Q2hpbGQgPSBwcmV2SW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbi5nZXRBdChwcmV2SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy9pZiAocHJldkNoaWxkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgLy8gICAgcHJldkNoaWxkLnN1YkluZm8uYmx1clNlbGYoKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQgIT0gbnVsbCAmJiBmcm9tVXNlckludGVyYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hpbGQuc3ViSW5mby5mb2N1c1NlbGYoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4O1xuICAgICAgICB9KTtcblxuICAgIH0sIFtdKTtcblxuICAgIC8vIEFueSB0aW1lIHRoZSB0YWJiYWJsZSBpbmRleCBjaGFuZ2VzLFxuICAgIC8vIG5vdGlmeSB0aGUgcHJldmlvdXMgY2hpbGQgdGhhdCBpdCdzIG5vIGxvbmdlciB0YWJiYWJsZSxcbiAgICAvLyBhbmQgbm90aWZ5IHRoZSBuZXh0IGNoaWxkIHRoYXQgaXMgYWxsb3dlZCB0byBiZSB0YWJiZWQgdG8uXG4gICAgY29uc3QgcGFyZW50UmV0dXJuVHlwZSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8+LCBFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiPih7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjoge1xuICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPbkNoaWxkcmVuTW91bnRDaGFuZ2U8bnVtYmVyPj4oKG1vdW50ZWQsIHVubW91bnRlZCkgPT4geyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/Lihtb3VudGVkLCB1bm1vdW50ZWQpOyByZWV2YWx1YXRlQ2xvc2VzdEZpdCgpOyB9KSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgdXNlTWFuYWdlZENoaWxkIH0gPSBwYXJlbnRSZXR1cm5UeXBlO1xuXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgfSA9IHVzZUNoaWxkcmVuRmxhZzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj4oeyBpbml0aWFsSW5kZXgsIGNoaWxkcmVuOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbiwgY2xvc2VzdEZpdDogdHJ1ZSwga2V5OiBcInRhYmJhYmxlXCIgfSk7XG5cbiAgICBjb25zdCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkID0gdXNlQ2FsbGJhY2s8VXNlUm92aW5nVGFiSW5kZXhDaGlsZDxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+PigoY2hpbGRQYXJhbWV0ZXJzKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdWJJbmZvLCBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHJvdmluZ1RhYkluZGV4OiB7IGhpZGRlbiwgZm9jdXNTZWxmOiBmb2N1c1NlbGZPdmVycmlkZSB9IH0gPSBjaGlsZFBhcmFtZXRlcnM7XG5cbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7XG4gICAgICAgIH0sIFshIWhpZGRlbl0pXG5cblxuICAgICAgICBjb25zdCBmc092ZXJyaWRlID0gdXNlU3RhYmxlR2V0dGVyKGZvY3VzU2VsZk92ZXJyaWRlKTtcbiAgICAgICAgY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnMgPSBmc092ZXJyaWRlKCk7XG4gICAgICAgICAgICBpZiAoZnMpIHtcbiAgICAgICAgICAgICAgICBmcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKSBhcyAoRWxlbWVudCAmIFBhcnRpYWw8SFRNTEVsZW1lbnQ+KTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5mb2N1cz8uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgLypjb25zdCBibHVyU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJzID0gYnNPdmVycmlkZSgpO1xuICAgICAgICAgICAgaWYgKGJzKSB7XG4gICAgICAgICAgICAgICAgYnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCkgYXMgKEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYmx1cj8uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTsqL1xuXG4gICAgICAgIGNvbnN0IG9uRm9jdXNlZElubmVyQ2hhbmdlZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuLCBfcHJldkZvY3VzZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxDaGlsZEVsZW1lbnQ+KHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBnZXREb2N1bWVudDogdXNlQ2FsbGJhY2soKCk6IERvY3VtZW50ID0+IHsgcmV0dXJuIChnZXRFbGVtZW50KCk/Lm93bmVyRG9jdW1lbnQpID8/ICh3aW5kb3cuZG9jdW1lbnQpIH0sIFtdKSB9KTtcblxuICAgICAgICBjb25zdCBbdGFiYmFibGUsIHNldFRhYmJhYmxlLCBnZXRUYWJiYWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRhYmJhYmxlRmxhZ3MgPSB1c2VSZWY8Q2hpbGRGbGFnT3BlcmF0aW9ucz4oeyBnZXQ6IGdldFRhYmJhYmxlLCBzZXQ6IHNldFRhYmJhYmxlLCBpc1ZhbGlkOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiAhaGlkZGVuKSB9KTtcblxuICAgICAgICBjb25zdCBfOiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDoge1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGZsYWdzOiB7IC4uLmZsYWdzLCB0YWJiYWJsZTogdGFiYmFibGVGbGFncy5jdXJyZW50IH0gYXMgUGFydGlhbDxSZWNvcmQ8RXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIiwgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+LFxuICAgICAgICAgICAgICAgIHN1YkluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgLy9ibHVyU2VsZixcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNTZWxmLFxuICAgICAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46ICEhaGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICBzdWJJbmZvXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWJiYWJsZSlcbiAgICAgICAgICAgICAgICBzdGFibGVPblRhYmJhYmxlUmVuZGVyKGluZGV4KTtcbiAgICAgICAgfSwgW3RhYmJhYmxlLCBpbmRleF0pXG4gICAgICAgIGZ1bmN0aW9uIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4ge1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQocHJvcHMudGFiSW5kZXggPT0gbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50Pih1c2VIYXNGb2N1c1Byb3BzKHsgdGFiSW5kZXg6IHRhYmJhYmxlID8gMCA6IC0xIH0pLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGB1c2VSb3ZpbmdUYWJJbmRleC5mb2N1c1NlbGZgKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRUYWJiYWJsZUluZGV4KCk7XG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKVxuICAgICAgICAgICAgcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4uZ2V0QXQoaW5kZXgpPy5zdWJJbmZvLmZvY3VzU2VsZj8uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobnVsbCwgdHJ1ZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbiB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleCxcbiAgICAgICAgICAgIGdldFRhYmJhYmxlSW5kZXgsXG4gICAgICAgICAgICBmb2N1c1NlbGYsXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKmZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgZm9jdXNTZWxmLCBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4LCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCB9ID0gdXNlUm92aW5nVGFiSW5kZXg8SFRNTERpdkVsZW1lbnQsIHsgXCJmb29cIjogXCJiYXJcIiB9LCBcImZsYWcyXCI+KHsgbWFuYWdlZENoaWxkcmVuOiB7fSwgcm92aW5nVGFiSW5kZXg6IHt9IH0pO1xuICAgIGNvbnN0IHsgfSA9IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQoeyBtYW5hZ2VkQ2hpbGRyZW46IHsgaW5kZXg6IDAsIGZsYWdzOiB7fSB9LCBydGk6IHsgaW5mbzM6IHsgZm9vOiBcImJhclwiIH0gfSB9KTtcbn0qL1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlBcnJheTtcbiIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUmFuZG9tO1xuIiwiaW1wb3J0IGJhc2VSYW5kb20gZnJvbSAnLi9fYmFzZVJhbmRvbS5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gIH1cbiAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaHVmZmxlU2VsZjtcbiIsImltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBzaHVmZmxlU2VsZiBmcm9tICcuL19zaHVmZmxlU2VsZi5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5U2h1ZmZsZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TWFwO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VWYWx1ZXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVGltZXM7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNBcmd1bWVudHM7XG4iLCJpbXBvcnQgYmFzZUlzQXJndW1lbnRzIGZyb20gJy4vX2Jhc2VJc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuaW1wb3J0IHN0dWJGYWxzZSBmcm9tICcuL3N0dWJGYWxzZS5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCdWZmZXI7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSW5kZXg7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5hcnk7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcbiIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcbiIsImltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlcztcbiIsImltcG9ydCBzaHVmZmxlU2VsZiBmcm9tICcuL19zaHVmZmxlU2VsZi5qcyc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJy4vdmFsdWVzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2h1ZmZsZTtcbiIsImltcG9ydCBhcnJheVNodWZmbGUgZnJvbSAnLi9fYXJyYXlTaHVmZmxlLmpzJztcbmltcG9ydCBiYXNlU2h1ZmZsZSBmcm9tICcuL19iYXNlU2h1ZmZsZS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICovXG5mdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaHVmZmxlO1xuIiwiaW1wb3J0ICogYXMgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE11dGFibGVSZWYsIHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZEluZm8sIE1hbmFnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VGb3JjZVVwZGF0ZSB9IGZyb20gXCIuL3VzZS1mb3JjZS11cGRhdGVcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCBsb2Rhc2hTaHVmZmxlIGZyb20gXCJsb2Rhc2gtZXMvc2h1ZmZsZVwiO1xuXG5leHBvcnQgdHlwZSBHZXRJbmRleDxDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChyb3c6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPikgPT4gKG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQpO1xuZXhwb3J0IHR5cGUgR2V0VmFsdWU8QywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWPiA9IChyb3c6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPiwgLi4uYXJnczogRykgPT4gVjtcbmV4cG9ydCB0eXBlIENvbXBhcmU8Vj4gPSAobGhzOiBWLCByaHM6IFYpID0+IG51bWJlcjtcblxuLyoqXG4gKiBBbGwgb2YgdGhlc2UgZnVuY3Rpb25zICoqTVVTVCoqIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcblxuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuLCBlLmcuLCB0aGUgcm93IGluZGV4IG9mIHRoaXMgY2hpbGRcbiAgICAgKiAoVXN1YWxseSBqdXN0IGFuIGBpbmRleGAgcHJvcClcbiAgICAgKi9cbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXg6IEdldEluZGV4PEMsIEs+OyB9XG59XG5cbi8qKlxuICogQWxsIG9mIHRoZXNlIGZ1bmN0aW9ucyAqKk1VU1QqKiBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWPiBleHRlbmRzIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSz4ge1xuICAgIHNvcnRhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11c3QgcmV0dXJuIHRoZSB2YWx1ZSB0aGlzIGNoaWxkIHVzZXMgUkU6IHNvcnRpbmcuXG4gICAgICAgICAqIElmIHlvdSBkb24ndCBjYXJlIGFib3V0IHNvcnRpbmcgKHlvdSBqdXN0IHVzZSBcbiAgICAgICAgICogeW91ciBvd25hcmJpdHJhcnkgcmVvcmRlcmluZyksIHRoaXMgd2lsbCBuZXZlclxuICAgICAgICAgKiBiZSB1c2VkLCBzbyBpdCBjYW4gcmV0dXJuIGFueXRoaW5nLlxuICAgICAgICAgKiBAcGFyYW0gcm93IFxuICAgICAgICAgKiBAcGFyYW0gYXJncyBcbiAgICAgICAgICovXG4gICAgICAgIGdldFZhbHVlOiBHZXRWYWx1ZTxDLCBLLCBHLCBWPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbHMgaG93IHZhbHVlcyBjb21wYXJlIGFnYWluc3QgZWFjaCBvdGhlci5cbiAgICAgICAgICogQHBhcmFtIGxocyBcbiAgICAgICAgICogQHBhcmFtIHJocyBcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBhcmU6IENvbXBhcmU8Vj47XG4gICAgfVxufVxuXG5cblxuLyoqXG4gKiBIb29rIHRoYXQgYWxsb3dzIGZvciB0aGUgKipkaXJlY3QgZGVzY2VuZGFudCoqIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IHRvIGJlIHJlLW9yZGVyZWQgYW5kIHNvcnRlZC5cbiAqIFxuICogKlRoaXMgaXMgKipzZXBhcmF0ZSoqIGZyb20gXCJtYW5hZ2VkXCIgY2hpbGRyZW4sIHdoaWNoIGNhbiBiZSBhbnkgbGV2ZWwgb2YgY2hpbGQgbmVlZGVkISBTb3J0YWJsZS9yZWFycmFuZ2VhYmxlIGNoaWxkcmVuIG11c3QgYmUgKipkaXJlY3QgZGVzY2VuZGFudHMqKiBvZiB0aGUgcGFyZW50IHRoYXQgdXNlcyB0aGlzIGhvb2shKlxuICogXG4gKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uYDsgaXQgdGFrZXMgdGhlIHNhbWUgYGluZGV4TWFuZ2xlcmAgYW5kIGBpbmRleERlbWFuZ2xlcmAgXG4gKiBmdW5jdGlvbnMgdGhhdCB0aGlzIGhvb2sgcmV0dXJucy4gYHVzZUxpc3ROYXZpZ2F0aW9uYCBkb2VzIG5vdCBkaXJlY3RseSB1c2UgdGhpcyBob29rIGJlY2F1c2UsIGFzIG1lbnRpb25lZCwgXG4gKiB0aGlzIGhvb2sgaW1wb3NlcyBzZXJpb3VzIHJlc3RyaWN0aW9ucyBvbiBjaGlsZCBzdHJ1Y3R1cmUsIHdoaWxlIGB1c2VMaXN0TmF2aWdhdGlvbmAgYWxsb3dzIGFueXRoaW5nLlxuICogXG4gKiBCZXNpZGVzIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIHRoYXQncyByZXR1cm5lZCwgdGhlIGBzb3J0YCBmdW5jdGlvbiB0aGF0J3MgcmV0dXJuZWQgd2lsbFxuICogc29ydCBhbGwgY2hpbGRyZW4gYWNjb3JkaW5nIHRvIHRoZWlyIHZhbHVlIGZyb20gdGhlIGBnZXRWYWx1ZWAgYXJndW1lbnQgeW91IHBhc3MgaW4uXG4gKiBcbiAqIElmIHlvdSB3YW50IHRvIHBlcmZvcm0gc29tZSByZS1vcmRlcmluZyBvcGVyYXRpb24gdGhhdCdzICpub3QqIGEgc29ydCwgeW91IGNhbiBtYW51YWxseVxuICogcmUtbWFwIGVhY2ggY2hpbGQncyBwb3NpdGlvbiB1c2luZyBgbWFuZ2xlTWFwYCBhbmQgYGRlbWFuZ2xlTWFwYCwgd2hpY2ggY29udmVydCBiZXR3ZWVuXG4gKiBzb3J0ZWQgYW5kIHVuc29ydGVkIGluZGV4IHBvc2l0aW9ucy5cbiAqIFxuICogQWdhaW4sIHVubGlrZSBzb21lIG90aGVyIGhvb2tzLCAqKnRoZXNlIGNoaWxkcmVuIG11c3QgYmUgZGlyZWN0IGRlc2NlbmRhbnRzKiouIFRoaXMgaXMgYmVjYXVzZVxuICogdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgaW5zcGVjdHMgdGhlIGdpdmVuIGNoaWxkcmVuLCB0aGVuIHJlLWNyZWF0ZXMgdGhlbSB3aXRoIG5ldyBga2V5YHMuXG4gKiBCZWNhdXNlIGtleXMgYXJlIGdpdmVuIHNwZWNpYWwgdHJlYXRtZW50IGFuZCBhIGNoaWxkIGhhcyBubyB3YXkgb2YgbW9kaWZ5aW5nIGl0cyBvd24ga2V5XG4gKiB0aGVyZSdzIG5vIG90aGVyIHRpbWUgb3IgcGxhY2UgdGhpcyBjYW4gaGFwcGVuIG90aGVyIHRoYW4gZXhhY3RseSB3aXRoaW4gdGhlIHBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4IH0gfTogVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLPik6IFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQywgSz4ge1xuXG4gICAgLy8gVGhlc2UgYXJlIHVzZWQgdG8ga2VlcCB0cmFjayBvZiBhIG1hcHBpbmcgYmV0d2VlbiB1bnNvcnRlZCBpbmRleCA8LS0tPiBzb3J0ZWQgaW5kZXguXG4gICAgLy8gVGhlc2UgYXJlIG5lZWRlZCBmb3IgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzLlxuICAgIGNvbnN0IG1hbmdsZU1hcCA9IHVzZVJlZihuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpKTtcbiAgICBjb25zdCBkZW1hbmdsZU1hcCA9IHVzZVJlZihuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpKTtcbiAgICBjb25zdCBpbmRleE1hbmdsZXIgPSB1c2VDYWxsYmFjaygobjogbnVtYmVyKSA9PiAobWFuZ2xlTWFwLmN1cnJlbnQuZ2V0KG4pID8/IG4pLCBbXSk7XG4gICAgY29uc3QgaW5kZXhEZW1hbmdsZXIgPSB1c2VDYWxsYmFjaygobjogbnVtYmVyKSA9PiAoZGVtYW5nbGVNYXAuY3VycmVudC5nZXQobikgPz8gbiksIFtdKTtcblxuICAgIC8vIFRoZSBzb3J0IGZ1bmN0aW9uIG5lZWRzIHRvIGJlIGFibGUgdG8gdXBkYXRlIHdob2V2ZXIgaGFzIGFsbCB0aGUgc29ydGFibGUgY2hpbGRyZW4uXG4gICAgLy8gQmVjYXVzZSB0aGF0IG1pZ2h0IG5vdCBiZSB0aGUgY29uc3VtZXIgb2YgKnRoaXMqIGhvb2sgZGlyZWN0bHkgKGUuZy4gYSB0YWJsZSB1c2VzXG4gICAgLy8gdGhpcyBob29rLCBidXQgaXQncyB0Ym9keSB0aGF0IGFjdHVhbGx5IG5lZWRzIHVwZGF0aW5nKSwgd2UgbmVlZCB0byByZW1vdGVseVxuICAgIC8vIGdldCBhbmQgc2V0IGEgZm9yY2VVcGRhdGUgZnVuY3Rpb24uXG4gICAgLy9jb25zdCBbZ2V0Rm9yY2VVcGRhdGUsIHNldEZvcmNlVXBkYXRlXSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgKCgpID0+IHZvaWQpPihudWxsLCByZXR1cm5OdWxsKTtcbiAgICBjb25zdCBbZ2V0Rm9yY2VVcGRhdGUsIHNldEZvcmNlVXBkYXRlXSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgKCgpID0+IHZvaWQpPihudWxsLCByZXR1cm5OdWxsKTtcblxuICAgIGNvbnN0IHJlYXJyYW5nZSA9IHVzZUNhbGxiYWNrKChzb3J0ZWRSb3dzOiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz5bXSkgPT4ge1xuXG4gICAgICAgIC8vIFVwZGF0ZSBvdXIgc29ydGVkIDwtLT4gdW5zb3J0ZWQgaW5kaWNlcyBtYXAgXG4gICAgICAgIC8vIGFuZCByZXJlbmRlciB0aGUgd2hvbGUgdGFibGUsIGJhc2ljYWxseVxuICAgICAgICBmb3IgKGxldCBpbmRleEFzU29ydGVkID0gMDsgaW5kZXhBc1NvcnRlZCA8IHNvcnRlZFJvd3MubGVuZ3RoOyArK2luZGV4QXNTb3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4QXNVbnNvcnRlZCA9IHNvcnRlZFJvd3NbaW5kZXhBc1NvcnRlZF0uaW5kZXg7XG5cbiAgICAgICAgICAgIG1hbmdsZU1hcC5jdXJyZW50LnNldChpbmRleEFzVW5zb3J0ZWQsIGluZGV4QXNTb3J0ZWQpO1xuICAgICAgICAgICAgZGVtYW5nbGVNYXAuY3VycmVudC5zZXQoaW5kZXhBc1NvcnRlZCwgaW5kZXhBc1Vuc29ydGVkKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgZ2V0Rm9yY2VVcGRhdGUoKT8uKCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgdXNlUmVhcnJhbmdlYWJsZVByb3BzID0gdXNlQ2FsbGJhY2soKHsgY2hpbGRyZW4sIC4uLnByb3BzIH06IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuPzogVk5vZGU8YW55PltdIH0pID0+IHtcblxuICAgICAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHNldEZvcmNlVXBkYXRlKF9wcmV2ID0+IGZvcmNlVXBkYXRlKTsgfSwgW2ZvcmNlVXBkYXRlXSlcblxuICAgICAgICByZXR1cm4gKHVzZU1lcmdlZFByb3BzPFBhcmVudEVsZW1lbnQ+KHtcbiAgICAgICAgICAgIGNoaWxkcmVuOlxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiBhcyBWTm9kZTxNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4+W10pXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoY2hpbGQgPT4gKHsgY2hpbGQsIG1hbmdsZWRJbmRleDogaW5kZXhNYW5nbGVyKGdldEluZGV4KGNoaWxkLnByb3BzISkhKSwgZGVtYW5nbGVkSW5kZXg6IGdldEluZGV4KGNoaWxkLnByb3BzKSB9KSlcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGxocywgcmhzKSA9PiB7IHJldHVybiBsaHMubWFuZ2xlZEluZGV4IC0gcmhzLm1hbmdsZWRJbmRleCB9KVxuICAgICAgICAgICAgICAgICAgICAubWFwKCh7IGNoaWxkLCBtYW5nbGVkSW5kZXgsIGRlbWFuZ2xlZEluZGV4IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoKGNoaWxkLnR5cGUgYXMgYW55LCB7IC4uLmNoaWxkLnByb3BzLCBrZXk6IGRlbWFuZ2xlZEluZGV4LCBcImRhdGEtbWFuZ2xlZC1pbmRleFwiOiBtYW5nbGVkSW5kZXgsIFwiZGF0YS11bm1hbmdsZWQtaW5kZXhcIjogZGVtYW5nbGVkSW5kZXggfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIHByb3BzKSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHsgdXNlUmVhcnJhbmdlYWJsZVByb3BzLCByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgaW5kZXhNYW5nbGVyLCBpbmRleERlbWFuZ2xlciwgbWFuZ2xlTWFwLCBkZW1hbmdsZU1hcCwgcmVhcnJhbmdlIH0gfTtcbn1cblxuXG4vKipcbiAqIEhvb2sgdGhhdCBhbGxvd3MgZm9yIHRoZSAqKmRpcmVjdCBkZXNjZW5kYW50KiogY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgdG8gYmUgcmUtb3JkZXJlZCBhbmQgc29ydGVkLlxuICogXG4gKiAqVGhpcyBpcyAqKnNlcGFyYXRlKiogZnJvbSBcIm1hbmFnZWRcIiBjaGlsZHJlbiwgd2hpY2ggY2FuIGJlIGFueSBsZXZlbCBvZiBjaGlsZCBuZWVkZWQhIFNvcnRhYmxlL3JlYXJyYW5nZWFibGUgY2hpbGRyZW4gbXVzdCBiZSAqKmRpcmVjdCBkZXNjZW5kYW50cyoqIG9mIHRoZSBwYXJlbnQgdGhhdCB1c2VzIHRoaXMgaG9vayEqIFxuICogXG4gKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uYDsgaXQgdGFrZXMgdGhlIHNhbWUgYGluZGV4TWFuZ2xlcmAgYW5kIGBpbmRleERlbWFuZ2xlcmAgXG4gKiBmdW5jdGlvbnMgdGhhdCB0aGlzIGhvb2sgcmV0dXJucy4gYHVzZUxpc3ROYXZpZ2F0aW9uYCBkb2VzIG5vdCBkaXJlY3RseSB1c2UgdGhpcyBob29rIGJlY2F1c2UsIGFzIG1lbnRpb25lZCwgXG4gKiB0aGlzIGhvb2sgaW1wb3NlcyBzZXJpb3VzIHJlc3RyaWN0aW9ucyBvbiBjaGlsZCBzdHJ1Y3R1cmUsIHdoaWxlIGB1c2VMaXN0TmF2aWdhdGlvbmAgYWxsb3dzIGFueXRoaW5nLlxuICogXG4gKiBCZXNpZGVzIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIHRoYXQncyByZXR1cm5lZCwgdGhlIGBzb3J0YCBmdW5jdGlvbiB0aGF0J3MgcmV0dXJuZWQgd2lsbFxuICogc29ydCBhbGwgY2hpbGRyZW4gYWNjb3JkaW5nIHRvIHRoZWlyIHZhbHVlIGZyb20gdGhlIGBnZXRWYWx1ZWAgYXJndW1lbnQgeW91IHBhc3MgaW4uXG4gKiBcbiAqIElmIHlvdSB3YW50IHRvIHBlcmZvcm0gc29tZSByZS1vcmRlcmluZyBvcGVyYXRpb24gdGhhdCdzICpub3QqIGEgc29ydCwgeW91IGNhbiBtYW51YWxseVxuICogcmUtbWFwIGVhY2ggY2hpbGQncyBwb3NpdGlvbiB1c2luZyBgbWFuZ2xlTWFwYCBhbmQgYGRlbWFuZ2xlTWFwYCwgd2hpY2ggY29udmVydCBiZXR3ZWVuXG4gKiBzb3J0ZWQgYW5kIHVuc29ydGVkIGluZGV4IHBvc2l0aW9ucy5cbiAqIFxuICogQWdhaW4sIHVubGlrZSBzb21lIG90aGVyIGhvb2tzLCAqKnRoZXNlIGNoaWxkcmVuIG11c3QgYmUgZGlyZWN0IGRlc2NlbmRhbnRzKiouIFRoaXMgaXMgYmVjYXVzZVxuICogdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgaW5zcGVjdHMgdGhlIGdpdmVuIGNoaWxkcmVuLCB0aGVuIHJlLWNyZWF0ZXMgdGhlbSB3aXRoIG5ldyBga2V5YHMuXG4gKiBCZWNhdXNlIGtleXMgYXJlIGdpdmVuIHNwZWNpYWwgdHJlYXRtZW50IGFuZCBhIGNoaWxkIGhhcyBubyB3YXkgb2YgbW9kaWZ5aW5nIGl0cyBvd24ga2V5XG4gKiB0aGVyZSdzIG5vIG90aGVyIHRpbWUgb3IgcGxhY2UgdGhpcyBjYW4gaGFwcGVuIG90aGVyIHRoYW4gZXhhY3RseSB3aXRoaW4gdGhlIHBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10sIFY+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4IH0sIHNvcnRhYmxlQ2hpbGRyZW46IHsgY29tcGFyZTogdXNlckNvbXBhcmUsIGdldFZhbHVlIH0gfTogVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSywgRywgVj4pOiBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDLCBLLCBHPiB7XG5cbiAgICBjb25zdCBjb21wYXJlID0gKHVzZXJDb21wYXJlID8/IGRlZmF1bHRDb21wYXJlKTtcblxuICAgIGNvbnN0IHsgdXNlUmVhcnJhbmdlYWJsZVByb3BzOiB1c2VTb3J0YWJsZVByb3BzLCAuLi5yZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlIH0gPSB1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgQywgSz4oeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXggfSB9KTtcbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyByZWFycmFuZ2UgfSB9ID0gcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZTtcbiAgICAvLyBUaGUgYWN0dWFsIHNvcnQgZnVuY3Rpb24uXG4gICAgY29uc3Qgc29ydCA9IHVzZUNhbGxiYWNrKChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4sIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiLCAuLi5hcmdzOiBHKTogUHJvbWlzZTx2b2lkPiB8IHZvaWQgPT4ge1xuXG4gICAgICAgIGNvbnN0IHNvcnRlZFJvd3MgPSBtYW5hZ2VkUm93cy5hcnJheVNsaWNlKCkuc29ydCgobGhzUm93LCByaHNSb3cpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgbGhzVmFsdWUgPSBnZXRWYWx1ZShsaHNSb3csIC4uLmFyZ3MpIGFzIGFueTtcbiAgICAgICAgICAgIGNvbnN0IHJoc1ZhbHVlID0gZ2V0VmFsdWUocmhzUm93LCAuLi5hcmdzKSBhcyBhbnk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJlKGxoc1ZhbHVlLCByaHNWYWx1ZSkgLy8gbGhzUm93LmdldE1hbmFnZWRDZWxscygpPy5bY29sdW1uXT8udmFsdWUsIHJoc1Jvdy5nZXRNYW5hZ2VkQ2VsbHMoKT8uW2NvbHVtbl0/LnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb25bMF0gPT0gXCJkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC1yZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWFycmFuZ2Uoc29ydGVkUm93cyk7XG5cbiAgICB9LCBbIC8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3Qgc2h1ZmZsZSA9IHVzZUNhbGxiYWNrKChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4pOiBQcm9taXNlPHZvaWQ+IHwgdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IHNodWZmbGVkUm93cyA9IGxvZGFzaFNodWZmbGUobWFuYWdlZFJvd3MuYXJyYXlTbGljZSgpKVxuICAgICAgICByZXR1cm4gcmVhcnJhbmdlKHNodWZmbGVkUm93cyk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjogeyBzb3J0LCBzaHVmZmxlIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZS5yZWFycmFuZ2VhYmxlQ2hpbGRyZW5cbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3MgYW4gYXJyYXkgb2Ygbm90LXNvcnRlZCBjaGlsZCBpbmZvcm1hdGlvbiB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAqIGFuZCB0aGUgY2hpbGRyZW4gd2lsbCByZS1hcnJhbmdlIHRoZW1zZWx2ZXMgdG8gbWF0Y2guXG4gICAgICAgICAqICBcbiAgICAgICAgICogKipTVEFCTEUqKlxuICAgICAgICAgKiAgXG4gICAgICAgICAqIFxuICAgICAgICAgKi9cbiAgICAgICAgcmVhcnJhbmdlOiAocm93c0luT3JkZXI6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPltdKSA9PiB2b2lkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBpbmRleE1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgbWFuZ2xlTWFwOiBNdXRhYmxlUmVmPE1hcDxudW1iZXIsIG51bWJlcj4+O1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBkZW1hbmdsZU1hcDogTXV0YWJsZVJlZjxNYXA8bnVtYmVyLCBudW1iZXI+PjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VSZWFycmFuZ2VhYmxlUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW4/OiBWTm9kZTxhbnk+W10gfCB1bmRlZmluZWQ7IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+O1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLPiB7XG4gICAgc29ydGFibGVDaGlsZHJlbjogey8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNvcnQ6IChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4sIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiLCAuLi5hcmdzOiBHKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgc2h1ZmZsZTogKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPikgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gICAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzXG4gICAgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEssIEc+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVNvcnRhYmxlUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW4/OiBWTm9kZTxhbnk+W10gfCB1bmRlZmluZWQ7IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGxoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkLCByaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjb21wYXJlMShsaHMsIHJocyk7XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlMyhsaHM6IHN0cmluZyB8IG51bWJlciwgcmhzOiBzdHJpbmcgfCBudW1iZXIpIHtcblxuICAgICAgICAvLyBDb2VyY2Ugc3RyaW5ncyB0byBudW1iZXJzIGlmIHRoZXkgc2VlbSB0byBzdGF5IHRoZSBzYW1lIHdoZW4gc2VyaWFsaXplZFxuICAgICAgICBpZiAoYCR7K2xoc31gID09PSBsaHMpXG4gICAgICAgICAgICBsaHMgPSArbGhzO1xuICAgICAgICBpZiAoYCR7K3Joc31gID09PSByaHMpXG4gICAgICAgICAgICByaHMgPSArcmhzO1xuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGlmIGVpdGhlciBhcmd1bWVudCBpcyBhIHN0cmluZywgdHVybiB0aGUgb3RoZXIgb25lIGludG8gb25lIHRvb1xuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJocyA9IGAke3Joc31gO1xuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGxocyA9IGAke2xoc31gO1xuXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBsaHMgPT09IHR5cGVvZiByaHMpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGxocy5sb2NhbGVDb21wYXJlKHJocyBhcyBzdHJpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiArbGhzIC0gK3JocztcblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZTIobGhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSwgcmhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJib29sZWFuXCIgfHwgbGhzIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgIGxocyA9ICtsaHM7XG4gICAgICAgIGlmICh0eXBlb2YgcmhzID09PSBcImJvb2xlYW5cIiB8fCByaHMgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICAgICAgcmhzID0gK3JocztcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUzKGxocywgcmhzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZTEobGhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhleSdyZSBib3RoIG51bGxcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxocyA9PSBudWxsIHx8IHJocyA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBPbmUgb2YgdGhlIHR3byBpcyBudWxsIC0tIGVhc3kgY2FzZVxuICAgICAgICAgICAgcmV0dXJuIGxocyAhPSBudWxsID8gMSA6IC0xXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBhcmUyKGxocywgcmhzKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlUHJlc3MgfSBmcm9tIFwiLi91c2UtcHJlc3NcIjtcbmltcG9ydCB7IHVzZUNoaWxkcmVuSGF2ZUZvY3VzLCBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnMsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1oYXMtZm9jdXNcIjtcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW4sIE1hbmFnZWRDaGlsZHJlbk9taXRzLCBPbkNoaWxkcmVuTW91bnRDaGFuZ2UsIHVzZUNoaWxkcmVuRmxhZyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgdXNlTGluZWFyTmF2aWdhdGlvbiwgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbiwgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCB1c2VSb3ZpbmdUYWJJbmRleCwgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLCBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVJbmZvLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm8gfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XG5pbXBvcnQgeyB1c2VTb3J0YWJsZUNoaWxkcmVuLCBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycywgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLXNvcnRhYmxlLWNoaWxkcmVuXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG5cbi8qKlxuICogXG4gKiBUT0RPOiBUaGlzIHRhYmxlIHdhcyBzY3JhcHBlZCB3aGVuIHRoaXMgd2FzIGNoYW5nZWQgdG8ganVzdCBhY2NlcHQgYSBjb2xsYXRvciBkaXJlY3RseSxcbiAqIGJ1dCBpdCdzIG5vdCBiYWQgZm9yIGEgY29sbGF0aW9uIGNyYXNoIGNvdXJzZSBhbmQgSSBtaWdodCB1c2UgaXQgYWdhaW4uXG4gKiBFdmVuIGp1c3QgYXMgYSBcInRoaXMgaXMgd2h5IGl0J3MgaW1wb3J0YW50IGFuZCBnb29kIHRvIHVzZSB0aGVzZSB0aGluZ3NcIiB0aGluZy5cbiAqIFxuICogfExhbmcufFRhcmdldHxVc2VyIGlucHV0fGBiYXNlYHxgYWNjZW50YHxgY2FzZWB8YHZhcmlhbnRgfFxuICogfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18XG4gKiB8RU58SGl8QnllfOKdjHzinYx84p2MfOKdjHxcbiAqIHxFTnxIaXxIaXzinIV84pyFfOKchXzinIV8XG4gKiB8RU58SGl877yo772JfOKchXzinIV84pyFfOKdjHxcbiAqIHxFTnxIaXxoaXzinIV84pyFfOKdjHzinYx8XG4gKiB8RU58SGl8SMOvfOKchXzinYx84p2MfOKdjHxcbiAqIHxFTnzDpXxhYXzinYx84p2MfOKdjHzinYx8XG4gKiB8REF8w6V8YWF84pyFfOKchXzinIV84p2MfFxuICogfERBfMOlfEFBfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxBYXzinIV84pyFfOKdjHzinYx8XG4gKiB8REF8w6V8YUF84p2MfOKdjHzinYx84p2MfFxuICogfEVOfMOlfGF84pyFfOKchXzinYx84p2MfFxuICogfERBfMOlfGF84pyFfOKchXzinYx84p2MfFxuICogfEpQfO+qqnznnYB84pyFfOKchXzinIV84pyFfFxuICogfEpQfOOCq3zvvbZ84pyFfOKchXzinIV84pyFfFxuICogfEpQfOOCq3zjgYt84pyFfOKchXzinIV84p2MfFxuICogfEpQfOOCq3zjg7V84pyFfOKchXzinIV84p2MfFxuICogfEpQfOOCq3zji5V84pyFfOKchXzinYx84p2MfFxuICogfEpQfOOCq3zjgqx84pyFfOKdjHzinYx84p2MfFxuICogfEpQfOOCq3zlipt84p2MfOKdjHzinYx84p2MfFxuICogfFpIfOe0hXznuqJ84p2MfOKdjHzinYx84p2MfFxuICogXG4gKiBcbiAqIChOb3RlIHRvIHNlbGY6IEF0IHNvbWUgcG9pbnQsIHRoaXMgZmlsZSB3aWxsIHByb2JhYmx5IGJlIG5vcm1hbGl6ZWRcbiAqIGJ5IHNvbWVib2R5IGFuZCDvqqogd2lsbCB0dXJuIGJhY2sgaW50byDnnYAuKVxuICogXG4gKi9cbmNvbnN0IF9kdW1teTogYW55ID0gbnVsbDtcblxuXG5mdW5jdGlvbiBpZGVudGl0eTxUPih0OiBUKSB7IHJldHVybiB0OyB9XG50eXBlIE9taXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gUGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+PjtcblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPEM+IHtcbiAgICB0ZXh0OiBzdHJpbmc7XG5cbiAgICBzdWJJbmZvOiBDO1xufVxuXG4vKipcbiAqIEBwYXJhbSBmcm9tVXNlckludGVyYWN0aW9uIFdoZXRoZXIgdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoaXMgY2hpbGQgYXMgYSBtZWFucyBvZiBuYXZpZ2F0aW5nIHRvIGl0LiAgSW4gdGhhdCB3YXMgdGhlIGNhc2UsIHRoZSBjaGlsZCBpcyBhbHNvIGZvY3VzZWQuIE90aGVyd2lzZSwgZm9jdXMgbW92ZXMgYXMgdGhlIGJyb3dzZXIgZGV0ZXJtaW5lcy5cbiAqL1xuZXhwb3J0IHR5cGUgTmF2aWdhdGVUb0luZGV4ID0gKGk6IG51bWJlciB8IG51bGwsIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHZvaWQ7XG5cblxuaW50ZXJmYWNlIExTUCB7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGFuZCBpbmRleERlbWFuZ2xlciBhcmUgdXNlZCB0byBhbGxvdyBjaGlsZHJlbiB0byBiZSBuYXZpZ2F0ZWQgaW4gYW4gb3JkZXJcbiAgICAgKiB0aGF0IGRvZXNuJ3QgbmVjZXNzYXJpbHkgbWF0Y2ggdGhlaXIgY2hpbGQgb3JkZXIsIGxpa2UgaWYgYSBsaXN0IGlzIHNvcnRlZC5cbiAgICAgKiBcbiAgICAgKiBVc2VkIHRvIHR1cm4gYW4gXCJhYnNvbHV0ZVwiIGluZGV4IGludG8gYSBcInNvcnRlZC9maWx0ZXJlZC9tYW5nbGVkXCIgb25lLlxuICAgICAqIFxuICAgICAqIEZvciBleGFtcGxlLCBuYXZpZ2F0ZVRvRmlyc3QgbWFuZ2xlcyAwIGFuZCBuYXZpZ2F0ZXMgdG8gdGhhdCByZXN1bHRpbmcgcm93LlxuICAgICAqIEBwYXJhbSByYXdJbmRleCBcbiAgICAgKi9cbiAgICBpbmRleE1hbmdsZXI/KHJhd0luZGV4OiBudW1iZXIpOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHR1cm4gYSBcIm1hbmdsZWRcIiBpbmRleCBpbnRvIGl0J3MgXCJ1bnNvcnRlZFwiIG9yIFwidW5tYW5nbGVkXCIgaW5kZXguXG4gICAgICogXG4gICAgICogRm9yIGV4YW1wbGUsIHdoZW4gaW5jcmVtZW50aW5nIG9yIGRlY3JlbWVudGluZyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGluZGV4LFxuICAgICAqIGl0IG5lZWRzIHRvIGJlIGRlbWFuZ2xlZCB0byBkbyBcIm5vcm1hbFwiIG1hdGggb24gaXQsIGFuZCB0aGVuIHJlLW1hbmdsZWQgKGFib3ZlKVxuICAgICAqIHRvIHR1cm4gdGhhdCBhYnNvbHV0ZSByb3cgaW5kZXggYmFjayBpbnRvIGEgbWFuZ2xlZCBvbmUuXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybWVkSW5kZXggXG4gICAgICovXG4gICAgaW5kZXhEZW1hbmdsZXI/KHRyYW5zZm9ybWVkSW5kZXg6IG51bWJlcik6IG51bWJlcjtcbn1cblxuZXhwb3J0IHR5cGUgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMgPSBrZXlvZiBMU1A7XG5cbi8vICoqKiBQYXJhbWV0ZXJzIChsaXN0LCBsaXN0LXNpbmdsZSwgbGlzdC1jaGlsZCwgbGlzdC1zaW5nbGUtY2hpbGQpXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kc1xuICAgIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczxSdGlPbWl0cywgTWNPbWl0cz4sXG4gICAgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM8VG5PbWl0cyB8IFwiZ2V0SW5kZXhcIiB8IFwic2V0SW5kZXhcIj4sXG4gICAgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8TG5PbWl0cyB8IFwibmF2aWdhdGVUb0ZpcnN0XCIgfCBcIm5hdmlnYXRlVG9MYXN0XCIgfCBcIm5hdmlnYXRlVG9OZXh0XCIgfCBcIm5hdmlnYXRlVG9QcmV2XCI+IHtcbiAgICBsaXN0TmF2aWdhdGlvbjogT21pdDxMU1AsIExzT21pdHM+O1xufVxuXG5pbnRlcmZhY2UgU1NQIHtcbiAgICBzZWxlY3RlZEluZGV4OiBudW1iZXIgfCBudWxsO1xuICAgIG9uU2VsZWN0ZWRJbmRleENoYW5nZTogKGV2ZW50OiBFdmVudCwgbmV3SW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbiAgICBzZWxlY3Rpb25Nb2RlOiBcImZvY3VzXCIgfCBcImFjdGl2YXRpb25cIjtcbn1cbmV4cG9ydCB0eXBlIFNpbmdsZVNlbGVjdGlvbk9taXRzID0ga2V5b2YgU1NQO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxTU09taXRzIGV4dGVuZHMgU2luZ2xlU2VsZWN0aW9uT21pdHMsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzLCBUbk9taXRzLCBSdGlPbWl0cyB8IFwiaW5pdGlhbEluZGV4XCIsIE1jT21pdHM+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IE9taXQ8U1NQLCBTU09taXRzPjtcbiAgICBjaGlsZHJlbkhhdmVGb2N1czogUGFydGlhbDxVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnNbXCJjaGlsZHJlbkhhdmVGb2N1c1wiXT47XG59XG5leHBvcnQgdHlwZSBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMgPSBrZXlvZiBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88YW55PjtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8THNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4gZXh0ZW5kc1xuICAgIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+LCBFeHRyYUZsYWdLZXlzLCBSdGlPbWl0cywgTWNPbWl0cywgU3ViYmVzdEluZm8+IHtcbiAgICAvL3JvdmluZ1RhYkluZGV4OiBPbWl0PFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+LCBFeHRyYUZsYWdLZXlzLCBuZXZlcj5bXCJyb3ZpbmdUYWJJbmRleFwiXSwgXCJzdWJJbmZvXCI+O1xuICAgIGxpc3ROYXZpZ2F0aW9uOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+LCBMc09taXRzIHwgXCJzdWJJbmZvXCI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLIHwgXCJzZWxlY3RlZFwiLCBMc09taXRzLCBSdGlPbWl0cywgTWNPbWl0cywgU3ViYmVzdEluZm8+IHtcbiAgICBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEU+O1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVJbmZvPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+PiwgXCJ0YWJiYWJsZVwiIHwgRXh0cmFGbGFnS2V5cz4sIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICBsaXN0TmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvSW5kZXg6IE5hdmlnYXRlVG9JbmRleCB9O1xufVxuXG4vLyAqKiogUmV0dXJuIHR5cGVzIChsaXN0LCBsaXN0LXNpbmdsZSwgbGlzdC1jaGlsZCwgbGlzdC1zaW5nbGUtY2hpbGQpXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcblxuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogVXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4ge1xuICAgIHNpbmdsZVNlbGVjdGlvbjoge31cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIEMsIEs+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLPjtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHM6IFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPltcInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNcIl07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIHNpbmdsZVNlbGVjdGlvbjoge1xuICAgICAgICBzZWxlY3RlZDogYm9vbGVhbjtcbiAgICAgICAgZ2V0U2VsZWN0ZWQoKTogYm9vbGVhbjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XG4gICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+W1widXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzXCJdO1xufVxuXG5cbmV4cG9ydCB0eXBlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQz4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5cbmV4cG9ydCB0eXBlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcblxuXG5cbi8qKlxuICogSW1wbGVtZW50cyBwcm9wZXIga2V5Ym9hcmQgbmF2aWdhdGlvbiBmb3IgY29tcG9uZW50cyBsaWtlIGxpc3Rib3hlcywgYnV0dG9uIGdyb3VwcywgbWVudXMsIGV0Yy5cbiAqIFxuICogSW4gdGhlIGRvY3VtZW50IG9yZGVyLCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIFwiZm9jdXNlZFwiIG9yIFwidGFiYmFibGVcIiBlbGVtZW50LCBtYWtpbmcgaXQgYWN0IG1vcmUgbGlrZSBvbmUgY29tcGxldGUgdW5pdCBpbiBjb21wYXJpc29uIHRvIGV2ZXJ5dGhpbmcgYXJvdW5kIGl0LlxuICogTmF2aWdhdGluZyBmb3J3YXJkcy9iYWNrd2FyZHMgY2FuIGJlIGRvbmUgd2l0aCB0aGUgYXJyb3cga2V5cywgSG9tZS9FbmQga2V5cywgb3IgYW55IGFueSB0ZXh0IGZvciB0eXBlYWhlYWQgdG8gZm9jdXMgdGhlIG5leHQgaXRlbSB0aGF0IG1hdGNoZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4oe1xuICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIC4uLm1jIH0sXG4gICAgcm92aW5nVGFiSW5kZXgsXG4gICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxuICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblxufTogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG4gICAgaW5kZXhNYW5nbGVyID8/PSBpZGVudGl0eTtcbiAgICBpbmRleERlbWFuZ2xlciA/Pz0gaWRlbnRpdHk7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VMaXN0TmF2aWdhdGlvblwiLCBpbmRleE1hbmdsZXIsIGluZGV4RGVtYW5nbGVyKTtcblxuXG4gICAgY29uc3QgcGFyZW50UmV0dXJuVHlwZSA9IHVzZVJvdmluZ1RhYkluZGV4PENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXM+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7XG4gICAgICAgICAgICAuLi5tYywgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VDYWxsYmFjazxPbkNoaWxkcmVuTW91bnRDaGFuZ2U8bnVtYmVyPj4oKG0sIHUpID0+IHtcbiAgICAgICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihtLCB1KTtcbiAgICAgICAgICAgIH0sIFtdKVxuICAgICAgICB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSwgcm92aW5nVGFiSW5kZXg6IHsgZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleCB9IH0gPSBwYXJlbnRSZXR1cm5UeXBlO1xuXG4gICAgY29uc3QgbmF2aWdhdGVUb0luZGV4ID0gdXNlQ2FsbGJhY2soKGk6IG51bWJlciB8IG51bGwsIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKGkgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdHJ5TmF2aWdhdGVUb0luZGV4KHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGksXG4gICAgICAgICAgICAgICAgc2VhcmNoRGlyZWN0aW9uOiAxLFxuICAgICAgICAgICAgICAgIGluZGV4TWFuZ2xlcjogaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LFxuICAgICAgICAgICAgICAgIGluZGV4RGVtYW5nbGVyOiBpbmRleERlbWFuZ2xlciA/PyBpZGVudGl0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGkgPT0gbnVsbCA/IG51bGwgOiBuZXh0SW5kZXgsIGZyb21Vc2VySW50ZXJhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChudWxsLCBmcm9tVXNlckludGVyYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXG4gICAgICAgICAgICBpbnZhbGlkVHlwZWFoZWFkXG4gICAgICAgIH1cbiAgICB9ID0gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe1xuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICBnZXRJbmRleDogZ2V0VGFiYmFibGVJbmRleCxcbiAgICAgICAgICAgIHNldEluZGV4OiB1c2VDYWxsYmFjaygoaW5kZXg6IChudW1iZXIgfCBudWxsKSB8ICgocHJldjogbnVtYmVyIHwgbnVsbCkgPT4gKG51bWJlciB8IG51bGwpKSkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgfSwgW10pLFxuICAgICAgICAgICAgLi4udHlwZWFoZWFkTmF2aWdhdGlvblxuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHMgfSA9IHVzZUxpbmVhck5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXY6IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5TmF2aWdhdGVUb0luZGV4KHsgY2hpbGRyZW4sIGRlZmF1bHQ6IGMgPz8gMCwgdGFyZ2V0OiBpbmRleERlbWFuZ2xlciEoaW5kZXhNYW5nbGVyISgoYyA/PyAwKSkgLSAxKSwgc2VhcmNoRGlyZWN0aW9uOiAtMSwgaW5kZXhNYW5nbGVyOiBpbmRleE1hbmdsZXIgPz8gaWRlbnRpdHksIGluZGV4RGVtYW5nbGVyOiBpbmRleERlbWFuZ2xlciA/PyBpZGVudGl0eSB9KVxuICAgICAgICAgICAgICAgIH0sIHRydWUpXG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dDogdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlOYXZpZ2F0ZVRvSW5kZXgoeyBjaGlsZHJlbiwgZGVmYXVsdDogYyA/PyAwLCB0YXJnZXQ6IGluZGV4RGVtYW5nbGVyIShpbmRleE1hbmdsZXIhKGMgPz8gMCkgKyAxKSwgc2VhcmNoRGlyZWN0aW9uOiAxLCBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSwgaW5kZXhEZW1hbmdsZXI6IGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5IH0pO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpXG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvRmlyc3Q6IHVzZUNhbGxiYWNrKCgpID0+IHsgbmF2aWdhdGVUb0luZGV4KGluZGV4RGVtYW5nbGVyISgwKSwgdHJ1ZSk7IH0sIFtdKSxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9MYXN0OiB1c2VDYWxsYmFjaygoKSA9PiB7IG5hdmlnYXRlVG9JbmRleChpbmRleERlbWFuZ2xlciEoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkpLCB0cnVlKTsgfSwgW10pLFxuICAgICAgICAgICAgLi4ubGluZWFyTmF2aWdhdGlvblxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvblByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4gPT4ge1xuICAgICAgICByZXR1cm4gdXNlTGluZWFyTmF2aWdhdGlvblByb3BzKHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyhwcm9wcykpO1xuICAgIH0sIFt1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHMsIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wc10pO1xuXG5cbiAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkID0gdXNlQ2FsbGJhY2s8VXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4+KCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmLCBoaWRkZW4gfSwgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LCBzdWJJbmZvIH0pID0+IHtcblxuICAgICAgICBjb25zdCBfdjogdm9pZCA9IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCh7IHRleHQsIGluZGV4IH0pO1xuICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUdldHRlcihpbmRleCk7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGdldFRhYmJhYmxlSW5kZXgoKSA9PSBnZXRJbmRleCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChpbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldEVsZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSA9IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmLCBoaWRkZW46ICEhaGlkZGVuIH0sXG4gICAgICAgICAgICBzdWJJbmZvOiB7IHRleHQsIHN1YkluZm8gfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+ID0gZnVuY3Rpb24gKHsgLi4ucHJvcHMgfSkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPENoaWxkRWxlbWVudD4odXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzKCgoeyBpbmVydDogaGlkZGVuIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikpKSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGUsXG4gICAgICAgICAgICAgICAgZ2V0VGFiYmFibGUsXG4gICAgICAgICAgICAgICAgZ2V0RWxlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3VzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCwgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgbmF2aWdhdGVUb0luZGV4XSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxuXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcGFyZW50UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9XG4gICAgICAgIC8qbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZiwgZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleCB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjdXJyZW50VHlwZWFoZWFkLCBpbnZhbGlkVHlwZWFoZWFkIH0qL1xuICAgIH1cbn1cblxuXG5cblxuXG5cbi8qKlxuICogSXQncyB2ZXJ5IGNvbW1vbiB0byBjb21iaW5lIGEgdGFiYmFibGUgbGlzdCBvZiB0aGluZ3MgYW5kIFwic2VsZWN0aW9uXCIgb2Ygb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqIFxuICogTGlzdHMsIHJhZGlvIGJ1dHRvbnMsIHRhYnMsIGV0Yy4gZXRjLlxuICogXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgdGhhdCBjb21iaW5lcyB0aGUgdHdvIHdpdGggdGhlIGNvcnJlY3QgdHlwaW5nLlxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7XG4gICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXgsIHNlbGVjdGlvbk1vZGUsIG9uU2VsZWN0ZWRJbmRleENoYW5nZSB9LFxuICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgIG1hbmFnZWRDaGlsZHJlbixcbiAgICByb3ZpbmdUYWJJbmRleDogeyAuLi5yb3ZpbmdUYWJJbmRleCB9LFxuICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICBjaGlsZHJlbkhhdmVGb2N1czogeyBvbkFsbExvc3RGb2N1cywgb25BbnlHYWluZWRGb2N1cyB9XG59OiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4ge1xuICAgIGNvbnN0IHBhcmVudFJldHVyblR5cGUgPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLIHwgXCJzZWxlY3RlZFwiPih7XG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgICAgICBpbml0aWFsSW5kZXg6IChzZWxlY3RlZEluZGV4ID8/IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAuLi5yb3ZpbmdUYWJJbmRleFxuICAgICAgICB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGQgfSA9IHVzZUNoaWxkcmVuSGF2ZUZvY3VzKHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXM6IHtcbiAgICAgICAgICAgIG9uQWxsTG9zdEZvY3VzOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25BbGxMb3N0Rm9jdXM/LigpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoc2VsZWN0ZWRJbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbkFueUdhaW5lZEZvY3VzXG4gICAgICAgIH0sIG1hbmFnZWRDaGlsZHJlbjoge1xuICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLFxuICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHN0YWJsZU9uQ2hhbmdlID0gdXNlU3RhYmxlQ2FsbGJhY2sob25TZWxlY3RlZEluZGV4Q2hhbmdlKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgLi4ubGlzdFJlc3RcbiAgICB9ID0gcGFyZW50UmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0sIHJvdmluZ1RhYkluZGV4OiB7IHNldFRhYmJhYmxlSW5kZXggfSB9ID0gbGlzdFJlc3Q7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGNoYW5nZUluZGV4OiBjaGFuZ2VTZWxlY3RlZEluZGV4LFxuICAgICAgICBnZXRDdXJyZW50SW5kZXg6IGdldFNlbGVjdGVkSW5kZXgsXG4gICAgICAgIC8vcmVldmFsdWF0ZUNsb3Nlc3RGaXRcbiAgICB9ID0gdXNlQ2hpbGRyZW5GbGFnPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxDPj4sIEsgfCBcInNlbGVjdGVkXCI+KHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBpbml0aWFsSW5kZXg6IHNlbGVjdGVkSW5kZXgsXG4gICAgICAgIGtleTogXCJzZWxlY3RlZFwiLFxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZVxuICAgIH0pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2hhbmdlU2VsZWN0ZWRJbmRleChzZWxlY3RlZEluZGV4KTtcbiAgICB9LCBbc2VsZWN0ZWRJbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogdXNlQ2FsbGJhY2s8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEsgfCBcInNlbGVjdGVkXCI+PigoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHJvdmluZ1RhYkluZGV4OiBydGksIGxpc3ROYXZpZ2F0aW9uOiBscywgaGFzRm9jdXM6IHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCAuLi5oYXNGb2N1cyB9LCBzdWJJbmZvIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtpc1NlbGVjdGVkLCBzZXRJc1NlbGVjdGVkLCBnZXRJc1NlbGVjdGVkXSA9IHVzZVN0YXRlKGdldFNlbGVjdGVkSW5kZXgoKSA9PSBpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFJlZiA9IHVzZVJlZjxDaGlsZEZsYWdPcGVyYXRpb25zPih7IGdldDogZ2V0SXNTZWxlY3RlZCwgc2V0OiBzZXRJc1NlbGVjdGVkLCBpc1ZhbGlkOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiAhcnRpLmhpZGRlbikgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZCh7XG4gICAgICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbiwgcHJldjogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/Lihmb2N1c2VkLCBwcmV2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk1vZGUgPT0gJ2ZvY3VzJyAmJiBmb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhYmxlT25DaGFuZ2UoeyB0YXJnZXQ6IGdldEVsZW1lbnQoKSwgY3VycmVudFRhcmdldDogZ2V0RWxlbWVudCgpIH0gYXMgRXZlbnQsIGdldEluZGV4KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5oYXNGb2N1cyxcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXggfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX3JldCxcbiAgICAgICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHNcbiAgICAgICAgICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZsYWdzXG4gICAgICAgICAgICAgICAgICAgIH0gYXMgUGFydGlhbDxSZWNvcmQ8SyB8IFwic2VsZWN0ZWRcIiB8IFwidGFiYmFibGVcIiwgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxuICAgICAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBscyxcbiAgICAgICAgICAgICAgICBzdWJJbmZvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUdldHRlcihpbmRleCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHVzZVByZXNzUHJvcHMgPSB1c2VQcmVzczxDaGlsZEVsZW1lbnQ+KHsgb25DbGlja1N5bmM6IChlKSA9PiB7IHN0YWJsZU9uQ2hhbmdlKGUsIGdldEluZGV4KCkpOyB9LCBleGNsdWRlOiB7fSwgaGFzRm9jdXMgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pID0+IHVzZVByZXNzUHJvcHModXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcykpKSxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX3JldCxcbiAgICAgICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsIGdldFNlbGVjdGVkOiBnZXRJc1NlbGVjdGVkIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtzZWxlY3Rpb25Nb2RlXSksXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHM6IHVzZUNhbGxiYWNrKCguLi5wOiBQYXJhbWV0ZXJzPHR5cGVvZiB1c2VMaXN0TmF2aWdhdGlvblByb3BzPikgPT4geyByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyguLi5wKSB9LCBbXSksXG4gICAgICAgIC4uLmxpc3RSZXN0LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHt9XG4gICAgfVxufVxuXG5cblxuXG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kc1xuICAgIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiwgTG5PbWl0cywgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+LFxuICAgIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEssIEcsIFY+IHtcbn1cblxuZXhwb3J0IHR5cGUgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzPiA9IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEssIExzT21pdHMsIFJ0aU9taXRzLCBNY09taXRzLCBDPjtcbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChwOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXI+KSA9PiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIEMsIEs+LFxuICAgIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLLCBHPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIEMsIEssIEc+IHtcbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD5cbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCB0eXBlYWhlYWROYXZpZ2F0aW9uLCByZWFycmFuZ2VhYmxlQ2hpbGRyZW4sIHNvcnRhYmxlQ2hpbGRyZW4gfTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8QywgSywgRywgViwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSywgRz4ge1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxuICAgICAgICAuLi5zb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVxuICAgIH0gPSB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQsIEMsIEssIEcsIFY+KHtcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuLFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9IH0gPSBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGVcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIC4uLmxpc3ROYXZpZ2F0aW9uIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25Qcm9wcyA9IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4ge1xuICAgICAgICByZXR1cm4gKHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHModXNlU29ydGFibGVQcm9wcyhwcm9wcykpKVxuICAgIH1cbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+ID0gKHApID0+IHtcbiAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQocClcbiAgICB9XG5cbiAgICByZXR1cm4gKHtcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblByb3BzLFxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlLFxuICAgICAgICAuLi5zb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVxuICAgICAgICAvKm1hbmFnZWRDaGlsZHJlbjogbGlzdE5hdlJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogbGlzdE5hdlJldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpc3ROYXZSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBsaXN0TmF2UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogbGlzdE5hdlJldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjogc29ydGFibGVDaGlsZHJlblJldHVyblR5cGUuc29ydGFibGVDaGlsZHJlbixcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZS5yZWFycmFuZ2VhYmxlQ2hpbGRyZW4qL1xuICAgIH0pO1xuXG59XG5cbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhcmdzOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIEM+KSA9PiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFNTT21pdHMgZXh0ZW5kcyBTaW5nbGVTZWxlY3Rpb25PbWl0cywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFNTT21pdHMsIExzT21pdHMgfCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiLCBMbk9taXRzLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSywgRz4sIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzXG4gICAgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSywgRz4ge1xuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PlxuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24sIHR5cGVhaGVhZE5hdmlnYXRpb24sIGNoaWxkcmVuSGF2ZUZvY3VzIH06IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLLCBbXT4ge1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxuICAgICAgICAuLi5zb3J0YWJsZVJldHVyblR5cGVcbiAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50LCBDLCBLLCBbXSwgbnVtYmVyPih7XG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleDogdXNlQ2FsbGJhY2soKHJvdykgPT4gcm93LmluZGV4LCBbXSkgfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjoge1xuICAgICAgICAgICAgZ2V0VmFsdWU6IHVzZUNhbGxiYWNrKChyb3cpID0+IHJvdy5pbmRleCwgW10pLFxuICAgICAgICAgICAgY29tcGFyZTogdXNlQ2FsbGJhY2soKGxocywgcmhzKSA9PiB7IHJldHVybiBsaHMgLSByaHM7IH0sIFtdKSxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9IH0gPSBzb3J0YWJsZVJldHVyblR5cGU7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCAuLi5saXN0TmF2aWdhdGlvbiB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHNpbmdsZVNlbGVjdGlvbixcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXM6IGNoaWxkcmVuSGF2ZUZvY3VzXG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMgPSAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuOiBWTm9kZTxhbnk+W107IH0pID0+IHtcbiAgICAgICAgcmV0dXJuICh1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHVzZVNvcnRhYmxlUHJvcHMocHJvcHMpKSk7XG4gICAgfVxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCA9IChwOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIEM+KSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkKHApO1xuICAgIH1cblxuICAgIHJldHVybiAoe1xuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcbiAgICAgICAgLy9zb3J0YWJsZTogeyBzb3J0LCBzaHVmZmxlLCByZWFycmFuZ2UsIGRlbWFuZ2xlTWFwLCBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCBtYW5nbGVNYXAgfSxcbiAgICAgICAgLi4uc29ydGFibGVSZXR1cm5UeXBlLFxuICAgICAgICAuLi5saXN0TmF2UmV0dXJuVHlwZVxuICAgIH0pO1xuXG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFRyeU5hdmlnYXRlVG9JbmRleFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4ge1xuICAgIGNoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88Qz4+LCBLPjtcbiAgICBkZWZhdWx0OiBudW1iZXI7XG4gICAgdGFyZ2V0OiBudW1iZXI7XG4gICAgc2VhcmNoRGlyZWN0aW9uOiAxIHwgLTE7XG4gICAgaW5kZXhNYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG4gICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJ5TmF2aWdhdGVUb0luZGV4PENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgY2hpbGRyZW4sIHNlYXJjaERpcmVjdGlvbiwgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgdGFyZ2V0IH06IFRyeU5hdmlnYXRlVG9JbmRleFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLPikge1xuICAgIGNvbnN0IHVwcGVyID0gY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCk7XG4gICAgY29uc3QgbG93ZXIgPSAwO1xuXG4gICAgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQgPj0gbG93ZXIgJiYgKGNoaWxkcmVuLmdldEF0KHRhcmdldCkgPT0gbnVsbCkgfHwgISFjaGlsZHJlbi5nZXRBdCh0YXJnZXQpPy5zdWJJbmZvLmhpZGRlbikpXG4gICAgICAgICAgICB0YXJnZXQgPSBpbmRleERlbWFuZ2xlcihpbmRleE1hbmdsZXIodGFyZ2V0KSAtIDEpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQgPCBsb3dlciA/IGluZGV4RGVtYW5nbGVyKGxvd2VyKSA6IHRhcmdldDtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgIHdoaWxlICgodGFyZ2V0IDw9IHVwcGVyICYmIGNoaWxkcmVuLmdldEF0KHRhcmdldCkgPT0gbnVsbCkgfHwgISFjaGlsZHJlbi5nZXRBdCh0YXJnZXQpPy5zdWJJbmZvLmhpZGRlbilcbiAgICAgICAgICAgIHRhcmdldCA9IGluZGV4RGVtYW5nbGVyKGluZGV4TWFuZ2xlcih0YXJnZXQpICsgMSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldCA+IHVwcGVyID8gaW5kZXhEZW1hbmdsZXIodXBwZXIpIDogdGFyZ2V0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvd2VyO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBNYW5hZ2VkQ2hpbGRPbWl0cywgTWFuYWdlZENoaWxkcmVuT21pdHMgfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMgfSBmcm9tIFwiLi91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cyB9IGZyb20gXCIuL3VzZS1yb3ZpbmctdGFiaW5kZXhcIjtcbmltcG9ydCB7IHVzZUhhc0ZvY3VzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XG5pbXBvcnQgeyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCB1c2VMaXN0TmF2aWdhdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWxpc3QtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG4vKipcbiAqIEdyaWRzIGFyZSBpbXBsZW1lbnRlZCB1c2luZyB0d28gc2V0cyBvZiBsaXN0IG5hdmlnYXRpb24uXG4gKiBcbiAqIFRoaXMgcmVzdWx0cyBpbiBhIGxvdCBvZiB0aGluZ3Mgd2l0aCB2ZXJ5IHNpbWlsYXIgbmFtZXMgYW5kIGp1c3QgY29uZnVzaW9uIGFsbCBhcm91bmQuIFBsZWFzZSB1c2UgY2F1dGlvbi5cbiAqL1xuXG4vLyBQYXJhbWV0ZXJzIChwYXJlbnQsIHJvdywgY2VsbClcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiwgTG5PbWl0cyB8IFwibmF2aWdhdGlvbkRpcmVjdGlvblwiLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4ge1xuICAgIGdyaWROYXZpZ2F0aW9uOiB7IFxuICAgICAgICByb3dJbmRleE1hbmdsZXI/OiBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPltcImxpc3ROYXZpZ2F0aW9uXCJdW1wiaW5kZXhNYW5nbGVyXCJdO1xuICAgICAgICByb3dJbmRleERlbWFuZ2xlcj86IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+W1wibGlzdE5hdmlnYXRpb25cIl1bXCJpbmRleERlbWFuZ2xlclwiXTtcbiAgICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8XG4gICAgQ1IsXG4gICAgS1IgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLFxuICAgIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsXG4gICAgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyxcbiAgICBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLFxuICAgIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyxcblxuICAgIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cyxcbiAgICBSdGlDaGlsZE9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLFxuICAgIE1jQ2hpbGRPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLFxuXG4gICAgU3ViYmVzdEluZm9cbiAgICA+IHtcbiAgICBhc1BhcmVudFJvd09mQ2VsbHM6IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzIHwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCIsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPjtcbiAgICBhc0NoaWxkUm93T2ZTZWN0aW9uOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDUiwgS1IsIExzQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cywgTWNDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz5cbiAgICAgICAgXG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmcsIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNDaGlsZE9taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q0MsIEtDLCBMc0NoaWxkT21pdHMsIFJ0aUNoaWxkT21pdHMsIE1jQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IHtcbiAgICBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPENlbGxFbGVtZW50Pjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4ge1xuICAgIGdyaWROYXZpZ2F0aW9uOiB7XG4gICAgICAgIGdldEN1cnJlbnRDb2x1bW4oKTogbnVtYmVyIHwgbnVsbDtcbiAgICAgICAgY3VycmVudENvbHVtbjogbnVtYmVyIHwgbnVsbDtcbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDUiwgQ0MsIEtSIGV4dGVuZHMgc3RyaW5nLCBLQyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENSLCBLUj4ge1xuICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93OiBVc2VHcmlkTmF2aWdhdGlvblJvdzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgQ1IsIENDLCBLUiwgS0M+O1xuICAgIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JSb3dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JSb3dFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvdyBleHRlbmRzIEVsZW1lbnQsIENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBhc0NoaWxkUm93OiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Um93PjtcbiAgICBhc1BhcmVudE9mQ2VsbHM6IFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2VsbCwgQ0MsIEtDPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93IGV4dGVuZHMgRWxlbWVudCwgQ2VsbCBleHRlbmRzIEVsZW1lbnQsIENDLCBLQyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvdywgQ2VsbCwgQ0MsIEtDPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsOiBVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbCwgQ0MsIEtDPjtcbiAgICB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvdz4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvdz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm88Q2VsbCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENlbGw+IHtcbiAgICBncmlkTmF2aWdhdGlvbjoge1xuICAgICAgICAvL3Jvd0lzVGFiYmFibGU6IGJvb2xlYW47XG4gICAgICAgIC8vZ2V0Um93SXNUYWJiYWJsZSgpOiBib29sZWFuO1xuICAgICAgICBnZXRDdXJyZW50Q29sdW1uKCk6IG51bWJlciB8IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm88Q2VsbD4ge1xuICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGw+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsPjtcbn1cblxuXG5leHBvcnQgdHlwZSBVc2VHcmlkTmF2aWdhdGlvblJvdzxSb3cgZXh0ZW5kcyBFbGVtZW50LCBDZWxsIGV4dGVuZHMgRWxlbWVudCwgQ1IsIENDLCBLUiBleHRlbmRzIHN0cmluZywgS0MgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxDUiwgS1IsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQ1I+KSA9PiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93LCBDZWxsLCBDQywgS0M+O1xuZXhwb3J0IHR5cGUgVXNlR3JpZE5hdmlnYXRpb25DZWxsPENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmc+ID0gKHA6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbCwgQ0MsIEtDLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDQz4pID0+IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbD47XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uPFxuICAgIFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxuICAgIFJvd1N1YkluZm8sXG4gICAgQ2VsbFN1YkluZm8sXG4gICAgUm93RXh0cmFGbGFncyBleHRlbmRzIHN0cmluZyxcbiAgICBDZWxsRXh0cmFGbGFncyBleHRlbmRzIHN0cmluZ1xuPih7XG4gICAgbWFuYWdlZENoaWxkcmVuOiBtYyxcbiAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxuICAgIGxpc3ROYXZpZ2F0aW9uOiBscyxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsbixcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0bixcbiAgICBncmlkTmF2aWdhdGlvbjogeyByb3dJbmRleERlbWFuZ2xlciwgcm93SW5kZXhNYW5nbGVyIH1cbn06IFVzZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJvd1N1YkluZm8sIENlbGxTdWJJbmZvLCBSb3dFeHRyYUZsYWdzLCBDZWxsRXh0cmFGbGFncz4ge1xuICAgIGNvbnN0IFtjdXJyZW50Q29sdW1uLCBzZXRDdXJyZW50Q29sdW1uLCBnZXRDdXJyZW50Q29sdW1uXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KHJ0aS5pbml0aWFsSW5kZXggPz8gMCk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRBc0dyaWRSb3csXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM6IHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNBc0dyaWRQYXJlbnQsXG4gICAgICAgIC4uLnBhcmVudExzUmV0dXJuVHlwZVxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIFJvd1N1YkluZm8sIFJvd0V4dHJhRmxhZ3M+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtYyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXI6IHJvd0luZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXI6IHJvd0luZGV4TWFuZ2xlciwgLi4ubHMgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsIC4uLmxuIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuLFxuICAgIH0pO1xuXG5cbiAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvblJvdyA9IHVzZUNhbGxiYWNrPFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSb3dTdWJJbmZvLCBDZWxsU3ViSW5mbywgUm93RXh0cmFGbGFncywgQ2VsbEV4dHJhRmxhZ3M+PigoeyBhc0NoaWxkUm93T2ZTZWN0aW9uOiBhc0NoaWxkLCBhc1BhcmVudFJvd09mQ2VsbHM6IGFzUGFyZW50IH0pID0+IHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGZvY3VzU2VsZiB0aGF0IHJvdmluZ1RhYkluZGV4IGRvZXMuXG4gICAgICAgIC8vIEluc3RlYWQgb2YgZm9jdXNpbmcgdGhlIGVudGlyZSByb3csIHdlIGFzayB0aGUgY2VsbCB0aGF0IGNvcnJlc3BvbmRzXG4gICAgICAgIC8vIHRvIG91ciBjdXJyZW50IGNvbHVtbiB0byBmb2N1cyBpdHNlbGYuXG4gICAgICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gZ2V0Q3VycmVudENvbHVtbigpO1xuICAgICAgICAgICAgaWYgKGFzQ2hpbGQucm92aW5nVGFiSW5kZXguZm9jdXNTZWxmKSB7XG4gICAgICAgICAgICAgICAgYXNDaGlsZC5yb3ZpbmdUYWJJbmRleC5mb2N1c1NlbGYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChjMiA/PyAwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgcm93THNDaGlsZFJldHVyblR5cGUgPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkQXNHcmlkUm93KHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogYXNDaGlsZC5tYW5hZ2VkQ2hpbGQsXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5hc0NoaWxkLmxpc3ROYXZpZ2F0aW9uIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyAuLi5hc0NoaWxkLnJvdmluZ1RhYkluZGV4LCBmb2N1c1NlbGYgfSxcbiAgICAgICAgICAgIHN1YkluZm86IGFzQ2hpbGQuc3ViSW5mbyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXg6IHsgdGFiYmFibGUgfSwgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzIH0gPSByb3dMc0NoaWxkUmV0dXJuVHlwZTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGFiYmFibGUpIHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgobnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbdGFiYmFibGVdKTtcblxuICAgICAgICBjb25zdCByb3dMc1JldHVyblR5cGUgPSB1c2VMaXN0TmF2aWdhdGlvbjxDZWxsRWxlbWVudCwgQ2VsbEVsZW1lbnQsIENlbGxTdWJJbmZvLCBDZWxsRXh0cmFGbGFncz4oe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IC4uLmFzUGFyZW50Lm1hbmFnZWRDaGlsZHJlbiB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgLi4uYXNQYXJlbnQucm92aW5nVGFiSW5kZXggfSxcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb246IHtcbiAgICAgICAgICAgICAgICAuLi5hc1BhcmVudC5saW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICAgIG5hdmlnYXRpb25EaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgLi4uYXNQYXJlbnQudHlwZWFoZWFkTmF2aWdhdGlvbiwgbm9UeXBlYWhlYWQ6IHRydWUgfSxcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmFzUGFyZW50Lmxpc3ROYXZpZ2F0aW9uIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleDogeyBzZXRUYWJiYWJsZUluZGV4IH0sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uMiwgdXNlTGlzdE5hdmlnYXRpb25Qcm9wczogdXNlR3JpZE5hdmlnYXRpb25Db2x1bW5Qcm9wcywgbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4IH0gfSA9IHJvd0xzUmV0dXJuVHlwZTtcblxuICAgICAgICAvL2NvbnN0IHJvd0hpZGRlbiA9ICEhYXNDaGlsZC5yb3ZpbmdUYWJJbmRleC5oaWRkZW47XG5cbiAgICAgICAgY29uc3QgdXNlR3JpZE5hdmlnYXRpb25DZWxsID0gdXNlQ2FsbGJhY2s8VXNlR3JpZE5hdmlnYXRpb25DZWxsPENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+PigoeyBzdWJJbmZvLCBoYXNGb2N1czogeyBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCAuLi5oYXNGb2N1cyB9LCBtYW5hZ2VkQ2hpbGQsIGxpc3ROYXZpZ2F0aW9uOiBscywgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmOiBmcywgLi4ucnRpIH0gfSkgPT4ge1xuICAgICAgICAgICAgLy9ydGkuaGlkZGVuIHx8IHJvd0hpZGRlbjtcblxuICAgICAgICAgICAgY29uc3QgZm9jdXNTZWxmID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDb2x1bW4obWFuYWdlZENoaWxkLmluZGV4KTtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG1hbmFnZWRDaGlsZC5pbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChmcylcbiAgICAgICAgICAgICAgICAgICAgZnMoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIChydGlfY2VsbF9yZXQuZ2V0RWxlbWVudCgpIGFzIEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik/LmZvY3VzPy4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLypjb25zdCBibHVyU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYnMpXG4gICAgICAgICAgICAgICAgICAgIGJzKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAocnRpX2NlbGxfcmV0LmdldEVsZW1lbnQoKSBhcyBFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pPy5ibHVyPy4oKTtcbiAgICAgICAgICAgIH0pOyovXG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfY2VsbF9yZXRcbiAgICAgICAgICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvbkNvbHVtbjIoe1xuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogbWFuYWdlZENoaWxkLFxuICAgICAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmxzIH0sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmLCAuLi5ydGkgfSxcbiAgICAgICAgICAgICAgICBzdWJJbmZvXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxDZWxsRWxlbWVudD4oe1xuICAgICAgICAgICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuLCBwcmV2OiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ/Lihmb2N1c2VkLCBwcmV2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDb2x1bW4obWFuYWdlZENoaWxkLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobWFuYWdlZENoaWxkLmluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5oYXNGb2N1c1xuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgY29uc3QgcmV0OiBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGxFbGVtZW50PiA9IHtcbiAgICAgICAgICAgICAgICBncmlkTmF2aWdhdGlvbjogeyBnZXRDdXJyZW50Q29sdW1uIH0sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9jZWxsX3JldCxcbiAgICAgICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wczogZnVuY3Rpb24gPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD4+KHByb3BzOiBQKSB7IHJldHVybiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlR3JpZE5hdmlnYXRpb25Db2x1bW5Qcm9wcyh1c2VIYXNGb2N1c1Byb3BzKHByb3BzKSkpOyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGNvbnN0IHJldDogVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+ID0ge1xuICAgICAgICAgICAgYXNQYXJlbnRPZkNlbGxzOiB7XG4gICAgICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogcm93THNSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHJvd0xzUmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHJvd0xzUmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJvd0xzUmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiByb3dMc1JldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzQ2hpbGRSb3c6IHJvd0xzQ2hpbGRSZXR1cm5UeXBlLFxuXG4gICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGwsXG4gICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzOiBmdW5jdGlvbiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvd0VsZW1lbnQ+Pihwcm9wczogUCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgcmV0LnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIGdldEN1cnJlbnRDb2x1bW4sXG4gICAgICAgICAgICBjdXJyZW50Q29sdW1uXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHBhcmVudExzUmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogcGFyZW50THNSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcGFyZW50THNSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBwYXJlbnRMc1JldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBwYXJlbnRMc1JldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvdyxcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Qcm9wczogdXNlTGlzdE5hdmlnYXRpb25Qcm9wc0FzR3JpZFBhcmVudCxcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdFwiO1xuaW1wb3J0IHsgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuZXhwb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9XG5cbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkUHJvcHNQYXJhbWV0ZXJzID0gVXNlUmVmZXJlbmNlZElkUHJvcHNQYXJhbWV0ZXJzPFwiaWRcIj47XG5leHBvcnQgdHlwZSBVc2VSYW5kb21JZFByb3BzUmV0dXJuVHlwZTxQIGV4dGVuZHMgVXNlUmFuZG9tSWRQcm9wc1BhcmFtZXRlcnM+ID0gVXNlUmVmZXJlbmNlZElkUHJvcHNSZXR1cm5UeXBlPFAsIFwiaWRcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFuZG9tSWRQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxcInJlZmVyZW5jZXJcIiB8IFwic291cmNlXCIsIG5ldmVyPiB7XG4gICAgcmFuZG9tSWQ6IHtcbiAgICAgICAgcHJlZml4Pzogc3RyaW5nO1xuICAgIH1cbn1cblxuXG5leHBvcnQgdHlwZSBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8SyBleHRlbmRzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+ID0gUGFydGlhbDxSZWNvcmQ8SywgYW55Pj47Ly88RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4geyB9O1xuXG5cbmV4cG9ydCB0eXBlIFVzZVJlZmVyZW5jZWRJZFByb3BzUmV0dXJuVHlwZTxQIGV4dGVuZHMgVXNlUmVmZXJlbmNlZElkUHJvcHNQYXJhbWV0ZXJzPGFueT4sIEsgZXh0ZW5kcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+PiA9IE9taXQ8UCwgSz4gJiBSZWNvcmQ8Sywgc3RyaW5nPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFJldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88XCJyZWZlcmVuY2VyXCIgfCBcInNvdXJjZVwiLCB7fSwgbmV2ZXI+IHtcbiAgICByYW5kb21JZDoge1xuICAgICAgICB1c2VkSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0VXNlZElkKCk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFuZG9tSWRSZXR1cm5UeXBlV2l0aEhvb2tzPFMgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJhbmRvbUlkUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ8Uz47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiBVc2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50O1xufVxuXG5pbnRlcmZhY2UgUmFuZG9tSWRDaGlsZEluZm9CYXNlIHtcbiAgICBzZXRVc2VkSWQoaWQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgLy9zZW5kU291cmNlSWRUb1JlZmVyZW5jZXJFbGVtZW50KHNvdXJjZUlkOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ8UyBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4gVXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UmV0dXJuVHlwZTxTPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnRSZXR1cm5UeXBlPFMgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdXNlZElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRVc2VkSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxTPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uz47XG59XG5cbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQgPSA8UiBleHRlbmRzIEVsZW1lbnQ+KGlkUHJvcE5hbWU6IGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PikgPT4gVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFJldHVyblR5cGU8Uj47XG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRSZXR1cm5UeXBlPFIgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdXNlZElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRVc2VkSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uj4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFI+O1xufVxuXG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgaG9vayB0aGF0IG1vZGlmaWVzIGEgc2V0IG9mIHByb3BzIHRvIHByb3ZpZGUgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKiBcbiAqIElmIHlvdSdkIGxpa2UgdG8gdXNlIHRoZSBJRCBpbiBhIHByb3BlcnR5IHRoYXQncyAqbm90KiBuYW1lZCBgaWRgIChsaWtlIGBmb3JgIG9yIGBhcmlhLWxhYmVsbGVkYnlgIG9yIHdoYXRub3QpLCBgdXNlUmVmZXJlbmNlZElkUHJvcHNgIGlzIGFsc28gcHJvdmlkZWQuXG4gKiBcbiAqIEFuZCB0aGUgcmFuZG9tbHktZ2VuZXJhdGVkIGlkIGl0c2VsZiBpcyBhbHNvIHByb3ZpZGVkIGluIGNhc2UgeW91IHdhbnQgdG8gaGFuZGxlIHRoZSBsb2dpYyB5b3Vyc2VsZiB3aXRob3V0IGB1c2VNZXJnZWRQcm9wc2AuXG4gKiBcbiAqIFVubGlrZSBtb3N0IG90aGVyIGB1c2UqUHJvcHNgIGhvb2tzLCB0aGVzZSBhcmUgbW9zdGx5IHN0YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJhbmRvbUlkPFMgZXh0ZW5kcyBFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeCB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9OiBVc2VSYW5kb21JZFBhcmFtZXRlcnMpOiBVc2VSYW5kb21JZFJldHVyblR5cGVXaXRoSG9va3M8Uz4ge1xuICAgIGNvbnN0IFtiYWNrdXBSYW5kb21JZCwgLCBnZXRCYWNrdXBSYW5kb21JZF0gPSB1c2VTdGF0ZTxzdHJpbmc+KCgpID0+IGdlbmVyYXRlUmFuZG9tSWQocHJlZml4KSk7XG4gICAgY29uc3QgW3VzZWRJZCwgc2V0VXNlZElkLCBnZXRVc2VkSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPigoKSA9PiBnZXRCYWNrdXBSYW5kb21JZCgpKTtcbiAgICBjb25zdCBtaXNtYXRjaEVycm9yUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VSYW5kb21JZFwiLCBwcmVmaXgpO1xuXG4gICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGQsIC4uLm1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUgfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxcInJlZmVyZW5jZXJcIiB8IFwic291cmNlXCIsIFJhbmRvbUlkQ2hpbGRJbmZvQmFzZSwgbmV2ZXI+KHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfSk7XG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSB9ID0gbWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCA9IHVzZUNhbGxiYWNrPFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTPj4oKCkgPT4ge1xuICAgICAgICBjb25zdCBbdXNlZElkTG9jYWwsIHNldFVzZWRJZExvY2FsLCBnZXRVc2VkSWRMb2NhbF0gPSB1c2VTdGF0ZShnZXRVc2VkSWQoKSk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PFM+KCk7XG4gICAgICAgIC8vIEV2ZXJ5IHRpbWUgdGhlIHNvdXJjZSBlbGVtZW50IHJlbmRlcnMsIGluc3BlY3QgdGhlIElEIGl0IGFjdHVhbGx5IHVzZWRcbiAgICAgICAgLy8gKHdoZXRoZXIgaXQgd2FzIG91cnMgb3Igbm90IGlzbid0IHVwIHRvIHVzLCBpdCdzIHVwIHRvIHRoZSBjb21wb25lbnQpXG4gICAgICAgIC8vIHNvIHRoaXMgaXMgaG93IHdlIG5vdGlmeSB0aGUgcmVmZXJlbmNlciBjb21wb25lbnQgb2YgY2hhbmdlc1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5nZXRBdChcInJlZmVyZW5jZXJcIikhLnN1YkluZm8uc2V0VXNlZElkKGVsZW1lbnQuaWQpO1xuICAgICAgICAgICAgICAgIHNldFVzZWRJZChlbGVtZW50LmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgXzogdm9pZCA9IHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleDogXCJzb3VyY2VcIiwgc3ViSW5mbzogeyBzZXRVc2VkSWQ6IHNldFVzZWRJZExvY2FsIH0gfSB9KTtcblxuICAgICAgICBjb25zdCB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyA9IHVzZUNhbGxiYWNrPFVzZVJhbmRvbUlkU291cmNlRWxlbWVudFJldHVyblR5cGU8Uz5bXCJ1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wc1wiXT4oZnVuY3Rpb24gKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFM+KSB7XG4gICAgICAgICAgICBwLmlkIHx8PSBiYWNrdXBSYW5kb21JZDtcbiAgICAgICAgICAgIHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHMocCk7XG4gICAgICAgIH0sIFtdKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VkSWQ6IHVzZWRJZExvY2FsLFxuICAgICAgICAgICAgZ2V0VXNlZElkOiBnZXRVc2VkSWRMb2NhbCxcbiAgICAgICAgICAgIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCA9IHVzZUNhbGxiYWNrPFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ+KDxSIGV4dGVuZHMgRWxlbWVudD4oaWRQcm9wTmFtZToga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uj4pID0+IHtcbiAgICAgICAgY29uc3QgW3VzZWRJZExvY2FsLCBzZXRVc2VkSWRMb2NhbCwgZ2V0VXNlZElkTG9jYWxdID0gdXNlU3RhdGUoZ2V0VXNlZElkKCkpO1xuICAgICAgICAvLyBXaGF0ZXZlciBJRCB3YXMgbW9zdCByZWNlbnRseSB1c2VkIGJ5IHRoZSBhY3R1YWwgXCJpZFwiIHByb3Agb2YgdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIHVzZUVuc3VyZVN0YWJpbGl0eShpZFByb3BOYW1lKTtcblxuICAgICAgICBjb25zdCBfdjogdm9pZCA9IHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleDogXCJyZWZlcmVuY2VyXCIsIHN1YkluZm86IHsgc2V0VXNlZElkOiBzZXRVc2VkSWRMb2NhbCB9IH0gfSk7XG5cbiAgICAgICAgY29uc3QgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzID0gdXNlQ2FsbGJhY2s8VXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFJldHVyblR5cGU8Uj5bXCJ1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHNcIl0+KGZ1bmN0aW9uIDxSIGV4dGVuZHMgRWxlbWVudD4oeyBbaWRQcm9wTmFtZV06IGdpdmVuSWQsIC4uLnAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uj4pIHtcbiAgICAgICAgICAgIGlmIChnaXZlbklkICYmIHVzZWRJZCkge1xuICAgICAgICAgICAgICAgIGlmIChnaXZlbklkICE9IHVzZWRJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1pc21hdGNoRXJyb3JSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlzbWF0Y2hFcnJvclJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYE11bHRpcGxlIG1pcy1tYXRjaGVkIElEcyB3ZXJlIHByb3ZpZGVkIGZvciB0aGUgJHtpZFByb3BOYW1lfSBwcm9wOiB0aGUgY2hpbGQgZXhwbGljaXRseSBzcGVjaWZpZWQgJHtnaXZlbklkfSBpbiBpdHMgICR7aWRQcm9wTmFtZX0gcHJvcCwgYnV0IHRoZSBwYXJlbnQgdG9sZCB0aGlzIGNoaWxkIHRvIHVzZSAke3VzZWRJZH0gKHRoZSBwYXJlbnQncyBJRCkuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Uj4ocCwgeyBbaWRQcm9wTmFtZV06IHVzZWRJZCB9KTtcbiAgICAgICAgfSwgW3VzZWRJZF0pO1xuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZWRJZDogdXNlZElkTG9jYWwsXG4gICAgICAgICAgICBnZXRVc2VkSWQ6IGdldFVzZWRJZExvY2FsLFxuICAgICAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzXG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByYW5kb21JZDoge1xuICAgICAgICAgICAgdXNlZElkLFxuICAgICAgICAgICAgZ2V0VXNlZElkXG4gICAgICAgIH0sXG4gICAgICAgIC4uLm1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUsXG4gICAgICAgIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCxcbiAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFxuICAgIH07XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIHVzZU1lcmdlZFByb3BzLCB1c2VQcmVzcyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IGRlYnVnTG9nLCBFbGVtZW50VG9UYWcsIEVuaGFuY2VkRXZlbnQsIGVuaGFuY2VFdmVudCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgQnV0dG9uUHJlc3NFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gRW5oYW5jZWRFdmVudDxFLCBFdmVudCB8IEV2ZW50LCB7IHByZXNzZWQ6IGJvb2xlYW4gfCBudWxsIH0+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VCdXR0b25QYXJhbWV0ZXJzPEUgZXh0ZW5kcyBOb2RlPiB7XHJcbiAgICBidXR0b246IHtcclxuICAgICAgICB0YWdCdXR0b246IEVsZW1lbnRUb1RhZzxFPjtcclxuICAgICAgICBkaXNhYmxlZD86IGJvb2xlYW4gfCBcInNvZnRcIiB8IFwiaGFyZFwiO1xyXG4gICAgICAgIHByZXNzZWQ/OiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgICAgICBvblByZXNzPyhldmVudDogQnV0dG9uUHJlc3NFdmVudDxFPik6IHZvaWQ7XHJcbiAgICB9XHJcbiAgICBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEU+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJ1dHRvblJldHVyblR5cGU8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XHJcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xyXG4gICAgdXNlQnV0dG9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCdXR0b248RSBleHRlbmRzIE5vZGU+KHsgYnV0dG9uOiB7IHRhZ0J1dHRvbiwgZGlzYWJsZWQsIG9uUHJlc3MsIHByZXNzZWQgfSwgaGFzRm9jdXMgfTogVXNlQnV0dG9uUGFyYW1ldGVyczxFPik6IFVzZUJ1dHRvblJldHVyblR5cGU8RT4ge1xyXG4gICAgZGVidWdMb2coXCJ1c2VCdXR0b25cIik7XHJcblxyXG4gICAgZnVuY3Rpb24gdXNlQnV0dG9uUHJvcHMoeyBcImFyaWEtcHJlc3NlZFwiOiBhcmlhUHJlc3NlZCwgdGFiSW5kZXgsIHJvbGUsIC4uLnAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZVByZXNzUHJvcHMgPSB1c2VQcmVzczxFPih7XHJcbiAgICAgICAgICAgIG9uQ2xpY2tTeW5jOiAoZSkgPT4gKGRpc2FibGVkID8gbnVsbCA6IG9uUHJlc3MpPy4oZW5oYW5jZUV2ZW50KGUsIHsgcHJlc3NlZDogcHJlc3NlZCA9PSBudWxsID8gbnVsbCA6ICFwcmVzc2VkIH0pKSxcclxuICAgICAgICAgICAgZXhjbHVkZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBoYXNGb2N1c1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHByb3BzID0gdXNlUHJlc3NQcm9wcyhwKTtcclxuXHJcbiAgICAgICAgY29uc3QgYmFzZVByb3BzID0geyByb2xlLCB0YWJJbmRleCwgXCJhcmlhLXByZXNzZWRcIjogYXJpYVByZXNzZWQgPz8gKHByZXNzZWQgPT09IHRydWUgPyBcInRydWVcIiA6IHByZXNzZWQgPT09IGZhbHNlID8gXCJmYWxzZVwiIDogdW5kZWZpbmVkKSB9O1xyXG4gICAgICAgIGNvbnN0IGJ1dHRvblByb3BzID0geyAuLi5iYXNlUHJvcHMsIGRpc2FibGVkOiAoZGlzYWJsZWQgJiYgZGlzYWJsZWQgIT0gXCJzb2Z0XCIpID8gdHJ1ZSA6IGZhbHNlLCBcImFyaWEtZGlzYWJsZWRcIjogKGRpc2FibGVkID09PSAnc29mdCcgPyAndHJ1ZScgOiB1bmRlZmluZWQpIH07XHJcbiAgICAgICAgY29uc3QgZGl2UHJvcHMgPSB7IC4uLmJhc2VQcm9wcywgdGFiSW5kZXg6IHRhYkluZGV4ID8/IChkaXNhYmxlZCA9PT0gXCJoYXJkXCIgPyAtMSA6IDApLCByb2xlOiByb2xlID8/IFwiYnV0dG9uXCIsIFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH07XHJcbiAgICAgICAgc3dpdGNoICh0YWdCdXR0b24pIHtcclxuICAgICAgICAgICAgY2FzZSBcImJ1dHRvblwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KGJ1dHRvblByb3BzLCBwcm9wcyk7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KGRpdlByb3BzLCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlQnV0dG9uUHJvcHNcclxuICAgIH1cclxufVxyXG5cclxuXHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IE9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgcmV0dXJuVHJ1ZSwgdXNlQ2hpbGRyZW5GbGFnLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIHVzZUxpbmVhck5hdmlnYXRpb24sIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBkZWJ1Z0xvZyB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZUJ1dHRvbiwgVXNlQnV0dG9uUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcclxuXHJcbmV4cG9ydCB0eXBlIFVzZUFjY29yZGlvbjxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzKSA9PiBVc2VBY2NvcmRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PjtcclxuZXhwb3J0IHR5cGUgVXNlQWNjb3JkaW9uU2VjdGlvbjxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PikgPT4gVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVXaXRoSG9va3M8SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8XCJuYXZpZ2F0ZVRvRmlyc3RcIiB8IFwibmF2aWdhdGVUb0xhc3RcIiB8IFwibmF2aWdhdGVUb05leHRcIiB8IFwibmF2aWdhdGVUb1ByZXZcIj4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBuZXZlcj4ge1xyXG4gICAgYWNjb3JkaW9uOiB7IGluaXRpYWxJbmRleD86IG51bWJlciB8IG51bGw7IH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25SZXR1cm5UeXBlSW5mbyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPG51bWJlciwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlLCBcInRhYmJlZFwiIHwgXCJvcGVuXCI+IHtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBhY2NvcmRpb246IHsgY2hhbmdlRXhwYW5kZWRJbmRleDogKGFyZzogbnVtYmVyIHwgKChwcmV2U3RhdGU6IG51bWJlciB8IG51bGwpID0+IG51bWJlciB8IG51bGwpIHwgbnVsbCkgPT4gbnVtYmVyIHwgbnVsbDsgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblJldHVyblR5cGVXaXRoSG9va3M8SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBY2NvcmRpb25SZXR1cm5UeXBlSW5mbyB7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlQWNjb3JkaW9uU2VjdGlvbjogVXNlQWNjb3JkaW9uU2VjdGlvbjxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlIHtcclxuICAgIHNldE9wZW5Gcm9tUGFyZW50KG9wZW46IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgZ2V0T3BlbkZyb21QYXJlbnQoKTogYm9vbGVhbiB8IG51bGw7XHJcbiAgICBmb2N1cygpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8bnVtYmVyLCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mb0Jhc2UsIFwidGFiYmVkXCIgfCBcIm9wZW5cIiwgXCJzdWJJbmZvXCIgfCBcImZsYWdzXCI+W1wibWFuYWdlZENoaWxkXCJdO1xyXG4gICAgYWNjb3JkaW9uU2VjdGlvbjogeyBvcGVuPzogYm9vbGVhbiB8IHVuZGVmaW5lZDsgfVxyXG4gICAgYnV0dG9uOiBPbWl0PFVzZUJ1dHRvblBhcmFtZXRlcnM8SGVhZGVyRWxlbWVudD5bXCJidXR0b25cIl0sIFwicHJlc3NlZFwiIHwgXCJvblByZXNzXCI+O1xyXG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgYWNjb3JkaW9uU2VjdGlvbjoge1xyXG4gICAgICAgIGV4cGFuZGVkOiBib29sZWFuO1xyXG4gICAgICAgIGZvY3VzZWQ6IGJvb2xlYW47XHJcbiAgICAgICAgaGVhZGVySWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICBib2R5SWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICBnZXRIZWFkZXJJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgZ2V0Qm9keUlkKCk6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbyB7XHJcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xyXG4gICAgdXNlQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PjtcclxuICAgIC8qKiAqVW5zdGFibGUqICovXHJcbiAgICB1c2VBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+O1xyXG59XHJcblxyXG5cclxuLy9leHBvcnQgdHlwZSBVc2VBY2NvcmRpb25TZWN0aW9uSGVhZGVyPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VCdXR0b25QYXJhbWV0ZXJzPEU+KSA9PiBVc2VBY2NvcmRpb25TZWN0aW9uSGVhZGVyUmV0dXJuVHlwZTxFPjtcclxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblNlY3Rpb25IZWFkZXJSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiB7IHVzZUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47IH1cclxuLy9leHBvcnQgdHlwZSBVc2VBY2NvcmRpb25TZWN0aW9uQm9keTxFIGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiBVc2VBY2NvcmRpb25TZWN0aW9uQm9keVJldHVyblR5cGU8RT47XHJcbi8vZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25TZWN0aW9uQm9keVJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IHsgdXNlQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBY2NvcmRpb248SGVhZGVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudD4oeyBhY2NvcmRpb246IHsgaW5pdGlhbEluZGV4IH0sIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH06IFVzZUFjY29yZGlvblBhcmFtZXRlcnMpOiBVc2VBY2NvcmRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PiB7XHJcbiAgICBkZWJ1Z0xvZyhcInVzZUFjY29yZGlhblwiKTtcclxuICAgIGNvbnN0IFtfY3VycmVudEZvY3VzZWRJbmRleCwgc2V0Q3VycmVudEZvY3VzZWRJbmRleCwgZ2V0Q3VycmVudEZvY3VzZWRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcclxuXHJcbiAgICBjb25zdCBtY1JldHVyblR5cGUgPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mb0Jhc2UsIFwidGFiYmVkXCIgfCBcIm9wZW5cIj4oe1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjoge1xyXG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobSwgdSkgPT4geyBvY21jMigpOyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihtLCB1KTsgfSksXHJcbiAgICAgICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTWFuYWdlZENoaWxkLCBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSB9ID0gbWNSZXR1cm5UeXBlO1xyXG5cclxuICAgIGNvbnN0IG5hdmlnYXRlVG9GaXJzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoMCk7IH0sIFtdKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9MYXN0ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBjaGFuZ2VUYWJiZWRJbmRleChjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSk7IH0sIFtdKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9QcmV2ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBjaGFuZ2VUYWJiZWRJbmRleChpID0+ICgoaSA/PyAwKSAtIDEpKSB9LCBbXSk7XHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTmV4dCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoaSA9PiAoKGkgPz8gMCkgKyAxKSkgfSwgW10pO1xyXG4gICAgY29uc3QgbGluZWFyUmV0dXJuVHlwZSA9IHVzZUxpbmVhck5hdmlnYXRpb248SGVhZGVyRWxlbWVudD4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgbmF2aWdhdGVUb0ZpcnN0LFxyXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdCxcclxuICAgICAgICAgICAgbmF2aWdhdGVUb05leHQsXHJcbiAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2LFxyXG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzLFxyXG4gICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICAgICAgICAgIG5hdmlnYXRpb25EaXJlY3Rpb246IG5hdmlnYXRpb25EaXJlY3Rpb24gPz8gXCJ2ZXJ0aWNhbFwiICAvLyBUT0RPOiBNYWtlIHRoaXMgcmVsYXRpdmUgdG8gdGhlIHBhZ2UncyBsb2dpY2FsIGRpcmVjdGlvblxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGluZWFyTmF2aWdhdGlvblByb3BzIH0gPSBsaW5lYXJSZXR1cm5UeXBlO1xyXG5cclxuXHJcbiAgICBjb25zdCB7IGNoYW5nZUluZGV4OiBjaGFuZ2VFeHBhbmRlZEluZGV4LCBnZXRDdXJyZW50SW5kZXg6IF9nZXRDdXJyZW50RXhwYW5kZWRJbmRleCB9ID0gdXNlQ2hpbGRyZW5GbGFnKHtcclxuICAgICAgICBpbml0aWFsSW5kZXgsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAga2V5OiBcIm9wZW5cIixcclxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleDogY2hhbmdlVGFiYmVkSW5kZXgsIGdldEN1cnJlbnRJbmRleDogX2dldFRhYmJlZEluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdDogb2NtYzIgfSA9IHVzZUNoaWxkcmVuRmxhZyh7XHJcbiAgICAgICAgaW5pdGlhbEluZGV4LFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGtleTogXCJ0YWJiZWRcIixcclxuICAgICAgICBjbG9zZXN0Rml0OiB0cnVlLFxyXG4gICAgICAgIG9uSW5kZXhDaGFuZ2U6IHVzZUNhbGxiYWNrKChpOiBudW1iZXIgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KGkpPy5zdWJJbmZvLmZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbXSlcclxuICAgIH0pXHJcblxyXG4gICAgY29uc3QgdXNlQWNjb3JkaW9uU2VjdGlvbjogVXNlQWNjb3JkaW9uU2VjdGlvbjxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD4gPSB1c2VDYWxsYmFjazxVc2VBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50Pj4oKHsgYnV0dG9uOiB7IGRpc2FibGVkLCB0YWdCdXR0b24gfSwgYWNjb3JkaW9uU2VjdGlvbjogeyBvcGVuOiBvcGVuRnJvbVVzZXIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IGluZGV4IH0sIGhhc0ZvY3VzOiB7IG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgLi4uaGFzRm9jdXMgfSB9KSA9PiB7XHJcblxyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlQWNjb3JkaWFuU2VjdGlvblwiKTtcclxuICAgICAgICBjb25zdCBbb3BlbkZyb21QYXJlbnQsIHNldE9wZW5Gcm9tUGFyZW50LCBnZXRPcGVuRnJvbVBhcmVudF0gPSB1c2VTdGF0ZTxib29sZWFuIHwgbnVsbD4obnVsbCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZUJvZHlBc1NvdXJjZUlkLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZCwgcmFuZG9tSWQ6IHsgdXNlZElkOiBib2R5SWQsIGdldFVzZWRJZDogZ2V0Qm9keUlkIH0gfSA9IHVzZVJhbmRvbUlkPEJvZHlFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLWFjY29yZGlvbi1zZWN0aW9uLWJvZHktXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZUhlYWRlckFzU291cmNlSWQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUJvZHlBc1JlZmVyZW5jZXJJZCwgcmFuZG9tSWQ6IHsgdXNlZElkOiBoZWFkZXJJZCwgZ2V0VXNlZElkOiBnZXRIZWFkZXJJZCB9IH0gPSB1c2VSYW5kb21JZDxIZWFkZXJFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLWFjY29yZGlvbi1zZWN0aW9uLWhlYWRlci1cIiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VCb2R5QXNTb3VyY2VJZFByb3BzIH0gPSB1c2VCb2R5QXNTb3VyY2VJZCgpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VCb2R5QXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlQm9keUFzUmVmZXJlbmNlcklkPEJvZHlFbGVtZW50PihcImFyaWEtbGFiZWxsZWRieVwiIGFzIG5ldmVyKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VIZWFkZXJBc1NvdXJjZUlkUHJvcHMgfSA9IHVzZUhlYWRlckFzU291cmNlSWQoKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlSGVhZGVyQXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlSGVhZGVyQXNSZWZlcmVuY2VySWQ8SGVhZGVyRWxlbWVudD4oXCJhcmlhLWNvbnRyb2xzXCIgYXMgbmV2ZXIpO1xyXG5cclxuICAgICAgICBjb25zdCBvcGVuID0gKChvcGVuRnJvbVVzZXIgPz8gb3BlbkZyb21QYXJlbnQpID8/IGZhbHNlKTtcclxuICAgICAgICAvL2NvbnN0IGdldE9wZW4gPSB1c2VTdGFibGVHZXR0ZXIoISFvcGVuKTtcclxuICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUdldHRlcihpbmRleCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0SGVhZGVyRWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VIZWFkZXJSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8SGVhZGVyRWxlbWVudD4oe30pO1xyXG4gICAgICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0Qm9keUVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlQm9keVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxCb2R5RWxlbWVudD4oe30pO1xyXG4gICAgICAgIGNvbnN0IGZvY3VzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZ2V0Q3VycmVudEZvY3VzZWRJbmRleCgpICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAoZ2V0SGVhZGVyRWxlbWVudCgpIGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQpPy5mb2N1cygpO1xyXG4gICAgICAgIH0sIFtdKTtcclxuICAgICAgICBjb25zdCBvcGVuUmVmID0gdXNlUmVmKHtcclxuICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldE9wZW5Gcm9tUGFyZW50KCksXHJcbiAgICAgICAgICAgIHNldDogKG9wZW46IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAgICAgICAgIHNldE9wZW5Gcm9tUGFyZW50KG9wZW4pO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keUVsZW1lbnQgPSBnZXRCb2R5RWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRGb2N1c2VkSW5kZXgoZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGJvZHlFbGVtZW50LmZvY3VzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaXNWYWxpZDogcmV0dXJuVHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHRhYmJlZFJlZiA9IHVzZVJlZih7XHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gKGdldEN1cnJlbnRGb2N1c2VkSW5kZXgoKSA9PSBnZXRJbmRleCgpKSxcclxuICAgICAgICAgICAgc2V0OiAob3BlbjogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZW4pXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudEZvY3VzZWRJbmRleChnZXRJbmRleCgpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaXNWYWxpZDogcmV0dXJuVHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IF9fOiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHtcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XHJcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBmbGFnczoge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IG9wZW5SZWYuY3VycmVudCxcclxuICAgICAgICAgICAgICAgICAgICB0YWJiZWQ6IHRhYmJlZFJlZi5jdXJyZW50XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc3ViSW5mbzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldE9wZW5Gcm9tUGFyZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wZW5Gcm9tUGFyZW50XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8gaW5mbzogeyBpbmRleCwgc2V0T3BlbkZyb21QYXJlbnQsIGdldE9wZW5Gcm9tUGFyZW50LCBmb2N1cywgZmxhZ3M6IHsgb3Blbjogb3BlblJlZi5jdXJyZW50LCB0YWJiZWQ6IHRhYmJlZFJlZi5jdXJyZW50IH0gfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcyh7IFtcImFyaWEtZXhwYW5kZWRcIl06IGFyaWFFeHBhbmRlZCwgW1wiYXJpYS1kaXNhYmxlZFwiXTogYXJpYURpc2FibGVkLCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+IHtcclxuXHJcbiAgICAgICAgICAgIC8vY29uc3Qgb25Gb2N1cyA9ICgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoaW5kZXgpOyB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9uUHJlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2V0T3BlbkZyb21QYXJlbnQoKSlcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VFeHBhbmRlZEluZGV4KG51bGwpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUV4cGFuZGVkSW5kZXgoaW5kZXgpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPSAwO1xyXG4gICAgICAgICAgICBjb25zdCB7IHVzZUJ1dHRvblByb3BzIH0gPSB1c2VCdXR0b248SGVhZGVyRWxlbWVudD4oe1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uOiB7IHRhZ0J1dHRvbiwgZGlzYWJsZWQsIG9uUHJlc3MgfSwgaGFzRm9jdXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAuLi5oYXNGb2N1cyxcclxuICAgICAgICAgICAgICAgICAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuLCBwcmV2OiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZD8uKGZvY3VzZWQsIHByZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVRhYmJlZEluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgcmV0QiA9IHVzZUJ1dHRvblByb3BzKHByb3BzKTtcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIC8vY29uc3QgcmV0MzogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD5cclxuICAgICAgICAgICAgLy8gICAgPSB1c2VNZXJnZWRQcm9wczxIZWFkZXJFbGVtZW50PihyZXRELCB7IG9uRm9jdXMgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyh1c2VIZWFkZXJBc1NvdXJjZUlkUHJvcHModXNlSGVhZGVyQXNSZWZlcmVuY2VySWRQcm9wcyh7XHJcbiAgICAgICAgICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogKGFyaWFFeHBhbmRlZCA/PyBvcGVuID8/IGZhbHNlKS50b1N0cmluZygpLFxyXG4gICAgICAgICAgICAgICAgXCJhcmlhLWRpc2FibGVkXCI6IChhcmlhRGlzYWJsZWQgPz8gKG9wZW4gPyBcInRydWVcIiA6IHVuZGVmaW5lZCkpLFxyXG4gICAgICAgICAgICAgICAgLi4udXNlSGVhZGVyUmVmRWxlbWVudFByb3BzKHJldEIpXHJcbiAgICAgICAgICAgIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4pKSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyh7IHJvbGUsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldDEgPSB1c2VCb2R5QXNSZWZlcmVuY2VySWRQcm9wcyh7IHJvbGU6IHJvbGUgPz8gXCJyZWdpb25cIiwgLi4ucHJvcHMgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJldDIgPSB1c2VCb2R5QXNTb3VyY2VJZFByb3BzKHJldDEpO1xyXG4gICAgICAgICAgICByZXQyLnRhYkluZGV4ID8/PSAtMTtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZUJvZHlSZWZFbGVtZW50UHJvcHMocmV0Mik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBhY2NvcmRpb25TZWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICBleHBhbmRlZDogb3BlbixcclxuICAgICAgICAgICAgICAgIGZvY3VzZWQ6IChnZXRDdXJyZW50Rm9jdXNlZEluZGV4KCkgPT0gaW5kZXgpLFxyXG4gICAgICAgICAgICAgICAgYm9keUlkLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVySWQsXHJcbiAgICAgICAgICAgICAgICBnZXRCb2R5SWQsXHJcbiAgICAgICAgICAgICAgICBnZXRIZWFkZXJJZFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1c2VBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHMsXHJcbiAgICAgICAgICAgIHVzZUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHMsXHJcblxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWNSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcclxuICAgICAgICBhY2NvcmRpb246IHsgY2hhbmdlRXhwYW5kZWRJbmRleCB9LFxyXG4gICAgICAgIHVzZUFjY29yZGlvblNlY3Rpb24sXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzLCB1c2VNZXJnZWRQcm9wcywgdXNlUHJlc3MsIHVzZVJhbmRvbUlkLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZyB9IGZyb20gXCIuL3Byb3BzXCI7XHJcblxyXG5pbnRlcmZhY2UgVUxJPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcclxuICAgIHByZWZpeExhYmVsOiBzdHJpbmc7XHJcbiAgICBwcmVmaXhJbnB1dDogc3RyaW5nO1xyXG4gICAgdGFnSW5wdXQ6IEVsZW1lbnRUb1RhZzxJbnB1dEVsZW1lbnQ+O1xyXG4gICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBMYWJlbE9taXRzID0ga2V5b2YgVUxJPGFueSwgYW55PjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGFiZWxQYXJhbWV0ZXJzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExPbWl0cyBleHRlbmRzIExhYmVsT21pdHM+IHtcclxuICAgIGxhYmVsOiBPbWl0PFVMSTxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIExPbWl0cz5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMYWJlbFJldHVyblR5cGVJbmZvIHtcclxuICAgIGxhYmVsOiB7XHJcbiAgICAgICAgbGFiZWxJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGlucHV0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAvKiogKipTdGFibGUqKiAqL1xyXG4gICAgICAgIGdldExhYmVsSWQ6ICgpID0+IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAvKiogKipTdGFibGUqKiAqL1xyXG4gICAgICAgIGdldElucHV0SWQ6ICgpID0+IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMYWJlbFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMYWJlbFJldHVyblR5cGVJbmZvIHtcclxuICAgIC8qKiAqTm90YWJseSB1bnN0YWJsZSogKi9cclxuICAgIHVzZUxhYmVsSW5wdXQ6ICgpID0+IHsgdXNlTGFiZWxJbnB1dFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47IH07XHJcbiAgICAvKiogKk5vdGFibHkgdW5zdGFibGUqICovXHJcbiAgICB1c2VMYWJlbExhYmVsOiAoKSA9PiB7IHVzZUxhYmVsTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+OyB9O1xyXG59XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBJRCBhbmQgXCJhcmlhLWxhYmVsbGVkYnlcIiBmb3IgdHdvIGVsZW1lbnRzLCBhbiBcImlucHV0XCIgZWxlbWVudCBhbmQgYSBcImxhYmVsXCIgZWxlbWVudC5cclxuICogXHJcbiAqIFJldHVybnMgdGhlIGB1c2VSZWZlcmVuY2VkSWRQcm9wc2AgaG9va3MgaWYgeW91IG5lZWQgdG8gYWxzbyBhZGQgb3RoZXIgSUQtcmVmZXJlbmNlciBhdHRyaWJ1dGVzLCBsaWtlIGBmb3JgXHJcbiAqIFxyXG4gKiBAc2VlIHVzZUlucHV0TGFiZWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMYWJlbDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxhYmVsOiB7IHByZWZpeElucHV0LCBwcmVmaXhMYWJlbCwgdGFnSW5wdXQsIHRhZ0xhYmVsIH0gfTogVXNlTGFiZWxQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBuZXZlcj4pOiBVc2VMYWJlbFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcclxuXHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlTGFiZWxBc1NvdXJjZUlkLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VMYWJlbEFzUmVmZXJlbmNlcklkLCByYW5kb21JZDogeyB1c2VkSWQ6IGxhYmVsSWQsIGdldFVzZWRJZDogZ2V0TGFiZWxJZCB9IH0gPSB1c2VSYW5kb21JZDxMYWJlbEVsZW1lbnQ+KHsgcmFuZG9tSWQ6IHsgcHJlZml4OiBwcmVmaXhMYWJlbCB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VJbnB1dEFzU291cmNlSWQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUlucHV0QXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogaW5wdXRJZCwgZ2V0VXNlZElkOiBnZXRJbnB1dElkIH0gfSA9IHVzZVJhbmRvbUlkPElucHV0RWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IHByZWZpeElucHV0IH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlTGFiZWxBc1NvdXJjZUlkUHJvcHMgfSA9IHVzZUxhYmVsQXNTb3VyY2VJZCgpO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlSW5wdXRBc1NvdXJjZUlkUHJvcHMgfSA9IHVzZUlucHV0QXNTb3VyY2VJZCgpO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUxhYmVsQXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlTGFiZWxBc1JlZmVyZW5jZXJJZDxJbnB1dEVsZW1lbnQ+KFwiYXJpYS1sYWJlbGxlZGJ5XCIgYXMgbmV2ZXIpO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUlucHV0QXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlSW5wdXRBc1JlZmVyZW5jZXJJZDxMYWJlbEVsZW1lbnQ+KFwiZm9yXCIpO1xyXG5cclxuICAgIGNvbnN0IGlzU3ludGhldGljTGFiZWwgPSAodGFnSW5wdXQgIT0gXCJpbnB1dFwiIHx8IHRhZ0xhYmVsICE9IFwibGFiZWxcIik7XHJcblxyXG4gICAgY29uc3QgdXNlTGFiZWxMYWJlbDogKCgpID0+IHsgdXNlTGFiZWxMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47IH0pID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTGFiZWxMYWJlbCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VMYWJlbExhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNXaXRob3V0Rm9yID0gdXNlTGFiZWxBc1NvdXJjZUlkUHJvcHMocHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNXaXRoRm9yID0gdXNlSW5wdXRBc1JlZmVyZW5jZXJJZFByb3BzKHByb3BzV2l0aG91dEZvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnTGFiZWwgPT0gXCJsYWJlbFwiICYmIHRhZ0lucHV0ID09IFwiaW5wdXRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNXaXRoRm9yO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1dpdGhvdXRGb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbaXNTeW50aGV0aWNMYWJlbF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUxhYmVsSW5wdXQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VMYWJlbElucHV0KCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUxhYmVsSW5wdXRQcm9wczogKHsgXCJhcmlhLWxhYmVsbGVkYnlcIjogYXJpYUxhYmVsbGVkYnksIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCFhcmlhTGFiZWxsZWRieSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNXaXRob3V0QXJpYUxhYmVsbGVkQnkgPSB1c2VJbnB1dEFzU291cmNlSWRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhBcmlhTGFiZWxsZWRCeSA9IHVzZUxhYmVsQXNSZWZlcmVuY2VySWRQcm9wcyhwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTeW50aGV0aWNMYWJlbCAmJiAhcHJvcHNbXCJhcmlhLWxhYmVsXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1dpdGhBcmlhTGFiZWxsZWRCeTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNXaXRob3V0QXJpYUxhYmVsbGVkQnk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2lzU3ludGhldGljTGFiZWxdKVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTGFiZWxJbnB1dCxcclxuICAgICAgICB1c2VMYWJlbExhYmVsLFxyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIGxhYmVsSWQsXHJcbiAgICAgICAgICAgIGlucHV0SWQsXHJcbiAgICAgICAgICAgIGdldExhYmVsSWQsXHJcbiAgICAgICAgICAgIGdldElucHV0SWRcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgdHlwZSBDaGVja2JveENoZWNrZWRUeXBlID0gYm9vbGVhbiB8IFwibWl4ZWRcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICBsYWJlbDogVXNlTGFiZWxQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlLCBcInByZWZpeExhYmVsXCIgfCBcInByZWZpeElucHV0XCI+W1wibGFiZWxcIl07XHJcbiAgICBjaGVja2JveExpa2U6IHtcclxuICAgICAgICBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCI7XHJcbiAgICAgICAgLyoqIFRoZSByb2xlIGF0dHJpYnV0ZSB0byB1c2UsIHdoZW4gYXBwbGljYWJsZSAqL1xyXG4gICAgICAgIHJvbGU6IHN0cmluZztcclxuICAgICAgICBkaXNhYmxlZDogYm9vbGVhbjtcclxuICAgICAgICBjaGVja2VkOiBDaGVja2JveENoZWNrZWRUeXBlO1xyXG4gICAgICAgIG9uQ2hlY2tlZENoYW5nZT8oZXZlbnQ6IGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlPik6IHZvaWQ7XHJcbiAgICAgICAgLy9vbklucHV0PyhldmVudDogaC5KU1guVGFyZ2V0ZWRFdmVudDxMYWJlbFR5cGU+KTogdm9pZDtcclxuICAgIH1cclxuICAgIGhhc0ZvY3VzSW5wdXQ6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxJbnB1dFR5cGU+O1xyXG4gICAgaGFzRm9jdXNMYWJlbDogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPExhYmVsVHlwZT47XHJcbn1cclxuXHJcbmNvbnN0IGhhbmRsZXNJbnB1dCA9IDxFIGV4dGVuZHMgRWxlbWVudD4odGFnOiBFbGVtZW50VG9UYWc8RT4sIGxhYmVsUG9zaXRpb246IFwid3JhcHBpbmdcIiB8IFwic2VwYXJhdGVcIiwgd2hpY2g6IFwiaW5wdXQtZWxlbWVudFwiIHwgXCJsYWJlbC1lbGVtZW50XCIpID0+IHtcclxuICAgIGlmIChsYWJlbFBvc2l0aW9uID09PSBcInNlcGFyYXRlXCIpIHtcclxuICAgICAgICBpZiAod2hpY2ggPT09IFwiaW5wdXQtZWxlbWVudFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBlbHNlIGlmICh3aGljaCA9PT0gXCJsYWJlbC1lbGVtZW50XCIpXHJcbiAgICAgICAgICAgIHJldHVybiB0YWcgIT0gXCJpbnB1dFwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGFiZWxQb3NpdGlvbiA9PT0gXCJ3cmFwcGluZ1wiKSB7XHJcbiAgICAgICAgaWYgKHdoaWNoID09PSBcImlucHV0LWVsZW1lbnRcIilcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGlmICh3aGljaCA9PSBcImxhYmVsLWVsZW1lbnRcIilcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQ8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7XHJcbiAgICBnZXRJbnB1dEVsZW1lbnQ6ICgpID0+IElucHV0VHlwZSB8IG51bGw7XHJcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xyXG4gICAgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHM6ICh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudDxMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHtcclxuICAgIC8qKiAqVW5zdGFibGUqICovXHJcbiAgICB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wczogKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgY2hlY2tib3hMaWtlOiB7XHJcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgICAgICBnZXRMYWJlbEVsZW1lbnQ6ICgpID0+IExhYmVsVHlwZSB8IG51bGw7XHJcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgICAgICBnZXRJbnB1dEVsZW1lbnQ6ICgpID0+IElucHV0VHlwZSB8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGVJbmZvPElucHV0VHlwZSwgTGFiZWxUeXBlPiB7XHJcbiAgICAvKiogKk5vdGFibHkgdW5zdGFibGUqICovXHJcbiAgICB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQ6IFVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDxJbnB1dFR5cGU+O1xyXG4gICAgLyoqICpOb3RhYmx5IHVuc3RhYmxlKiAqL1xyXG4gICAgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50OiAoKSA9PiB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzOiAoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+OyB9O1xyXG59XHJcblxyXG4vKipcclxuICogSGFuZGxlcyBsYWJlbCB0eXBlICh3cmFwcGluZyBvciBzZXBhcmF0ZSkgZm9yIGNoZWNrYm94ZXMsIHJhZGlvcywgc3dpdGNoZXMsIGV0Yy5cclxuICogXHJcbiAqIElmIGl0J3MgYSB0b2dnbGVhYmxlIGNsaWNrLXRoaW5nIHdpdGggYSBsYWJlbCAodGhhdCBjYW4gYWxzbyBiZSBjbGlja2VkKSwgdGhlbiBpdCdzIGEgY2hlY2tib3gtbGlrZS5cclxuICogQHBhcmFtIHBhcmFtMCBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlPElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgY2hlY2tib3hMaWtlOiB7IGNoZWNrZWQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCByb2xlLCBvbkNoZWNrZWRDaGFuZ2UgfSwgbGFiZWw6IHsgdGFnSW5wdXQsIHRhZ0xhYmVsIH0sIGhhc0ZvY3VzSW5wdXQsIGhhc0ZvY3VzTGFiZWwgfTogVXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4pOiBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0VHlwZSwgTGFiZWxUeXBlPiB7XHJcblxyXG4gICAgY29uc3Qgc3RhYmxlT25JbnB1dCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0VHlwZT4gfCBoLkpTWC5UYXJnZXRlZEV2ZW50PExhYmVsVHlwZT4pID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgb25DaGVja2VkQ2hhbmdlPy4oZSBhcyBoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0VHlwZT4pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0OiB1c2VJTElucHV0LCB1c2VMYWJlbExhYmVsOiB1c2VJTExhYmVsLCBsYWJlbCB9ID0gdXNlTGFiZWw8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KHsgbGFiZWw6IHsgcHJlZml4TGFiZWw6IFwiYXJpYS1jaGVja2JveC1sYWJlbC1cIiwgcHJlZml4SW5wdXQ6IFwiYXJpYS1jaGVja2JveC1pbnB1dC1cIiwgdGFnSW5wdXQ6IHRhZ0lucHV0LCB0YWdMYWJlbDogdGFnTGFiZWwgfSB9KTtcclxuXHJcblxyXG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRMYWJlbEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlTGFiZWxSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8TGFiZWxUeXBlPigpO1xyXG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRJbnB1dEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlSW5wdXRSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8SW5wdXRUeXBlPigpO1xyXG5cclxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDogVXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50PElucHV0VHlwZT4gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VDaGVja2JveElucHV0RWxlbWVudCgpIHtcclxuICAgICAgICBjb25zdCB0YWcgPSB0YWdJbnB1dDtcclxuICAgICAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXRQcm9wczogdXNlSUxJbnB1dFByb3BzIH0gPSB1c2VJTElucHV0KCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8SW5wdXRUeXBlPih7fSk7XHJcblxyXG4gICAgICAgIC8vIG9uQ2xpY2sgYW5kIG9uQ2hhbmdlIGFyZSBhIGJpdCBtZXNzeSwgc28gd2UgbmVlZCB0b1xyXG4gICAgICAgIC8vICphbHdheXMqIG1ha2Ugc3VyZSB0aGF0IHRoZSB2aXNpYmxlIHN0YXRlIGlzIGNvcnJlY3RcclxuICAgICAgICAvLyBhZnRlciBhbGwgdGhlIGV2ZW50IGR1c3Qgc2V0dGxlcy5cclxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMjc0NSxcclxuICAgICAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMTg5OSNpc3N1ZWNvbW1lbnQtNTI1NjkwMTk0XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgdGFnID09IFwiaW5wdXRcIikge1xyXG4gICAgICAgICAgICAgICAgKGVsZW1lbnQgYXMgRWxlbWVudCBhcyBIVE1MSW5wdXRFbGVtZW50KS5pbmRldGVybWluYXRlID0gKGNoZWNrZWQgPT09IFwibWl4ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAoZWxlbWVudCBhcyBFbGVtZW50IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSAoY2hlY2tlZCA9PT0gdHJ1ZSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFt0YWcsIGNoZWNrZWRdKVxyXG5cclxuICAgICAgICByZXR1cm4geyBnZXRJbnB1dEVsZW1lbnQ6IGdldEVsZW1lbnQsIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzIH07XHJcblxyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiwgQ2hyb21lIHdvbid0IGZpcmUgb25JbnB1dCBldmVudHMgZm9yIHJhZGlvIGJ1dHRvbnMgdGhhdCBhcmUgdGFiSW5kZXg9LTE/P1xyXG4gICAgICAgICAgICAvLyBOZWVkcyBpbnZlc3RpZ2F0aW5nLCBidXQgb25JbnB1dCB3b3JrcyBmaW5lIGluIEZpcmVmb3hcclxuICAgICAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgICAgICBjb25zdCB1c2VQcmVzc1Byb3BzID0gdXNlUHJlc3M8SW5wdXRUeXBlPih7XHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrU3luYzogZGlzYWJsZWQgfHwgIWhhbmRsZXNJbnB1dCh0YWcsIGxhYmVsUG9zaXRpb24sIFwiaW5wdXQtZWxlbWVudFwiKSA/IHVuZGVmaW5lZCA6IHN0YWJsZU9uSW5wdXQsXHJcbiAgICAgICAgICAgICAgICBleGNsdWRlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBoYXNGb2N1czogaGFzRm9jdXNJbnB1dFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGV0IHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+ID0gdXNlUHJlc3NQcm9wcyhwMCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGFnID09IFwiaW5wdXRcIilcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uSW5wdXQgPSAoZTogRXZlbnQpID0+IGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIHByb3BzID0gdXNlUmVmRWxlbWVudFByb3BzKHVzZUlMSW5wdXRQcm9wcyhwcm9wcykpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgd3JhcHBlZCBsYWJlbCBoYW5kbGVzIGFsbCBpbnRlcmFjdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGlzIGVsZW1lbnQgY2FuJ3QgYmUgaW50ZXJhY3RlZCB3aXRoXHJcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGl0J3MgYW4gaW5wdXQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgIHByb3BzLmluZXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcclxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1oaWRkZW5cIl0gPSBcInRydWVcIjtcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uRm9jdXMgPSBfID0+IChnZXRMYWJlbEVsZW1lbnQoKSBhcyBIVE1MRWxlbWVudCB8IG51bGwpPy5mb2N1cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gXCJpbnB1dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCA9IChjaGVja2VkID09PSB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnJvbGUgPSByb2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtY2hlY2tlZFwiXSA9IGNoZWNrZWQgPT09IFwibWl4ZWRcIiA/IFwibWl4ZWRcIiA6IGNoZWNrZWQgPT09IHRydWUgPyBcInRydWVcIiA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IGRpc2FibGVkLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBsYWJlbCBjbGlja3MgY2FuJ3QgYWZmZWN0IHRoZSBjaGVja2JveCB3aGlsZSBpdCdzIGRpc2FibGVkXHJcbiAgICAgICAgICAgIHByb3BzLm9uQ2xpY2sgPSBkaXNhYmxlZCA/ICgoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSkgOiBwcm9wcy5vbkNsaWNrO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZUlucHV0UmVmRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzPElucHV0VHlwZT4ocDAsIHByb3BzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3VzZUlMSW5wdXQsIHJvbGUsIGxhYmVsUG9zaXRpb24sIGRpc2FibGVkLCBjaGVja2VkLCB0YWdJbnB1dF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KCkge1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ0xhYmVsO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTGFiZWxMYWJlbFByb3BzOiB1c2VJTExhYmVsUHJvcHMgfSA9IHVzZUlMTGFiZWwoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPiB7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB1c2VQcmVzc1Byb3BzID0gdXNlUHJlc3M8TGFiZWxUeXBlPih7XHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrU3luYzogZGlzYWJsZWQgfHwgIWhhbmRsZXNJbnB1dCh0YWcsIGxhYmVsUG9zaXRpb24sIFwibGFiZWwtZWxlbWVudFwiKSA/IHVuZGVmaW5lZCA6IHN0YWJsZU9uSW5wdXQsXHJcbiAgICAgICAgICAgICAgICBleGNsdWRlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBoYXNGb2N1czogaGFzRm9jdXNMYWJlbFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbmV3UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT4gPSB1c2VQcmVzc1Byb3BzKHAwKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1Byb3BzLnRhYkluZGV4ID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMudGFiSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1Byb3BzLnJvbGUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcy5yb2xlID0gcm9sZTtcclxuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IGRpc2FibGVkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1tcImFyaWEtY2hlY2tlZFwiXSA9IGNoZWNrZWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBvbmUgY2FzZSB3aGVyZSB0aGVyZSdzIGFsbW9zdCBub3RoaW5nIHRvIGRvXHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBub3JtYWwgY2FzZSB3aGVyZSBldmVyeXRoaW5nIGFjdHMgYWNjb3JkaW5nIG5vcm1hbCBIVE1MIG1lY2hhbmljcy5cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEp1c3QgbWFrZSBzdXJlIHRoYXQgbGFiZWwgY2xpY2tzIGNhbid0IGFmZmVjdCB0aGUgY2hlY2tib3ggd2hpbGUgaXQncyBkaXNhYmxlZFxyXG4gICAgICAgICAgICBuZXdQcm9wcy5vbkNsaWNrID0gZGlzYWJsZWQgPyAoKGUpID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpIH0pIDogbmV3UHJvcHMub25DbGljaztcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB1c2VJTExhYmVsUHJvcHModXNlTGFiZWxSZWZFbGVtZW50UHJvcHMobmV3UHJvcHMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzIH07XHJcblxyXG4gICAgfSwgW3VzZUlMTGFiZWwsIGRpc2FibGVkLCBjaGVja2VkLCByb2xlLCBsYWJlbFBvc2l0aW9uLCB0YWdMYWJlbF0pO1xyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCxcclxuICAgICAgICB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsXHJcbiAgICAgICAgY2hlY2tib3hMaWtlOiB7XHJcbiAgICAgICAgICAgIGdldExhYmVsRWxlbWVudCxcclxuICAgICAgICAgICAgZ2V0SW5wdXRFbGVtZW50LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFiZWxcclxuICAgIH07XHJcblxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyByZXR1cm5GYWxzZSwgdXNlTGlzdE5hdmlnYXRpb24sIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbywgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IENoZWNrYm94Q2hlY2tlZFR5cGUgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcclxuaW1wb3J0IHsgZGVidWdMb2csIEVuaGFuY2VkRXZlbnQsIGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyBDaGVja2JveENoYW5nZUV2ZW50LCB1c2VDaGVja2JveCwgVXNlQ2hlY2tib3hQYXJhbWV0ZXJzLCBVc2VDaGVja2JveFJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWNoZWNrYm94XCI7XHJcblxyXG5leHBvcnQgdHlwZSBDaGVja2JveEdyb3VwQ2hhbmdlRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IEVuaGFuY2VkRXZlbnQ8RSwgRXZlbnQsIHsgY2hpbGRyZW5DaGVja2VkOiBib29sZWFuIHwgTWFwPG51bWJlciwgYm9vbGVhbiB8IFwibWl4ZWRcIj4gfT47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgcGFyZW50IGNoZWNrYm94IGlzIGNoYW5nZWQgYW5kIGFuIHVwZGF0ZSBvZlxyXG4gICAgICogYWxsIHRoZSBjaGlsZHJlbiBuZWVkcyB0byBvY2N1ci5cclxuICAgICAqIFxyXG4gICAgICogYGV2ZW50W0V2ZW50RGV0YWlsXS5jaGlsZHJlbkNoZWNrZWRgIHdpbGwgYmUgXHJcbiAgICAgKiAqIHRydWUgd2hlbiBhbGwgY2hpbGRyZW4gbmVlZCB0byBiZWNvbWUgY2hlY2tlZFxyXG4gICAgICogKiBmYWxzZSB3aGVuIGFsbCBjaGlsZHJlbiBuZWVkIHRvIGJlY29tZSB1bmNoZWNrZWRcclxuICAgICAqICogQSBgTWFwPGluZGV4LGNoZWNrZWQ+YCBvZiBlYWNoIGNoaWxkJ3Mgc3RhdHVzIHdoZW4gcmV2ZXJ0aW5nIHRvIFwibWl4ZWRcIi5cclxuICAgICAqIFxyXG4gICAgICogQmVjYXVzZSB3ZSdyZSBkZWFsaW5nIHdpdGggY29udHJvbGxlZCBjb21wb25lbnRzIGhlcmUsIGFuZCB0aGUgZGF0YSBmb3JcclxuICAgICAqIHdoYXQgY2hlY2tib3hlcyBhcmUgY2hlY2tlZCBsaXZlICpvdXRzaWRlKiBvZiBhbnkgb2YgdGhlc2UgaG9va3MsXHJcbiAgICAgKiBpdCdzIHlvdSB3aG8ncyByZXNwb25zaWJsZSBmb3IgbGlzdGVuaW5nIGZvciB0aGlzIGV2ZW50LCBtb2RpZnlpbmcgdGhlXHJcbiAgICAgKiBkYXRhLCBhbmQgcmUtcmVuZGVyaW5nIGFwcHJvcHJpYXRlbHkuXHJcbiAgICAgKiBcclxuICAgICAqIEhpZ2hseSByZWNvbW1lbmRlZCB0bywgZm9yIGV4YW1wbGUsIGFkZCBlYWNoIGNoaWxkJ3MgYG9uSW5wdXRgIGV2ZW50IGhhbmRsZXJcclxuICAgICAqIGF2YWlsYWJsZSBpbiB0aGUgY2hpbGQgaW5mbyB0aGUgcGFyZW50IGdldHMgc28gaXQgY2FuIGNhbGwgdGhlIGhhbmRsZXJcclxuICAgICAqIHJlbW90ZWx5IGZyb20gYG1hbmFnZWRDaGVja2JveGVzYC5cclxuICAgICAqIEBwYXJhbSBldmVudCBcclxuICAgICAqL1xyXG4gICAgLy9jaGVja2JveEdyb3VwOiB7fVxyXG4gICAgLy9vblVwZGF0ZUNoaWxkcmVuKGV2ZW50OiBDaGVja2JveEdyb3VwQ2hhbmdlRXZlbnQ8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPj4pOiB2b2lkO1xyXG59XHJcblxyXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cENoaWxkSW5mb0Jhc2U8SyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkSW5mb0Jhc2U8Sz4ge1xyXG4vKipcclxuICogVGhlIGlkIGF0dHJpYnV0ZSB1c2VkIGZvciB0aGUgY2hpbGQuXHJcbiAqL1xyXG4vL2lkOiBzdHJpbmc7XHJcblxyXG4vKipcclxuICogVGhlIGN1cnJlbnQgY2hlY2tlZCBzdGF0ZSBvZiB0aGlzIGNoaWxkLlxyXG4gKiBcclxuICogVGhpcyBpcyB1c2VkIGJ5IHRoZSBwYXJlbnQgd2hlbmV2ZXIgaXQncyBpbnRlcmFjdGVkIHdpdGggXHJcbiAqIGFuZCBhYm91dCB0byBmb3JjZSBldmVyeSBvbmUgdG8gYmUgc29tZXRoaW5nIGRpZmZlcmVudCAtLSBcclxuICogaXQgd2lsbCBzYXZlIHRoZSBzdGF0ZSBvZiBhbGwgY2hpbGQgY2hlY2tib3hlcyBmb3IgbGF0ZXJcclxuICogYnkgYXNraW5nIGVhY2ggb25lIHdoYXQgaXRzIGN1cnJlbnQgc3RhdGUgaXMgaW5kaXZpZHVhbGx5XHJcbiAqIGF0IHRoYXQgbW9tZW50LlxyXG4gKiBcclxuICogQWxsIHRoZSBjaGVja2JveCdzIHN0YXRlcyBhcmUgY2FwdHVyZWQgd2hlbiB0aGUgcGFyZW50XHJcbiAqIGlzIGluIHRoZSBcIm1peGVkXCIgc3RhdGUgYW5kIGlzIGNsaWNrZWQuIEl0IGtlZXBzIHRoZW1cclxuICogdGhhdCB3YXkgdW50aWwgdGhlIHNhbWUgY29uZGl0aW9ucyBhcmlzZSBhZ2Fpbi5cclxuICovXHJcbi8vICAgIGdldExhc3RVc2VyQ2hlY2tlZCgpOiBib29sZWFuIHwgXCJtaXhlZFwiO1xyXG4vLyAgICBvbklucHV0OiBVc2VDaGVja2JveFBhcmFtZXRlcnM8YW55LCBhbnk+W1wib25JbnB1dFwiXTtcclxuLy99XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENCRyB7XHJcbiAgICBjaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiO1xyXG4gICAgZ2V0TGFzdFVzZXJDaGVja2VkKCk6IGJvb2xlYW4gfCBcIm1peGVkXCI7XHJcbiAgICBvbkNoZWNrZWRDaGFuZ2U6IFVzZUNoZWNrYm94UGFyYW1ldGVyczxhbnksIGFueT5bXCJjaGVja2JveFwiXVtcIm9uQ2hlY2tlZENoYW5nZVwiXTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICBhc0NoZWNrYm94OiBVc2VDaGVja2JveFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+O1xyXG4gICAgYXNDaGVja2JveEdyb3VwQ2hpbGQ6IHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENCRywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPltcIm1hbmFnZWRDaGlsZFwiXTtcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogT21pdDxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDQkcsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj5bXCJsaXN0TmF2aWdhdGlvblwiXSwgXCJzdWJJbmZvXCI+O1xyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDQkcsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj5bXCJyb3ZpbmdUYWJJbmRleFwiXTtcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VDaGVja2JveFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudD4ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcclxuICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHM6ICh7IHRhYkluZGV4LCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+O1xyXG4gICAgdXNlQ2hlY2tib3hHcm91cENoaWxkTGFiZWxQcm9wczogKHsgdGFiSW5kZXgsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PikgPT4gVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4gLyp7XHJcbiAgICAvL3RhYmJhYmxlOiBib29sZWFuIHwgbnVsbDtcclxuICAgIGNoZWNrYm94TGlrZTogVXNlQ2hlY2tib3hSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImNoZWNrYm94TGlrZVwiXTtcclxuICAgIGxhYmVsOiBVc2VDaGVja2JveFJldHVyblR5cGU8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+W1wibGFiZWxcIl07XHJcbiAgICByb3ZpbmdUYWJJbmRleDogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU8SW5wdXRFbGVtZW50PltcInJvdmluZ1RhYkluZGV4XCJdO1xyXG4gICAgdXNlQ2hlY2tib3hHcm91cENoaWxkSW5wdXRQcm9wczogKHsgdGFiSW5kZXgsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47XHJcbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzOiAoeyB0YWJJbmRleCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjtcclxufSovXHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIF9MYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50LCBDQkcsIG5ldmVyPiB7XHJcbiAgICBjaGVja2JveEdyb3VwOiB7XHJcbiAgICAgICAgcGFyZW50SXNDaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiO1xyXG4gICAgICAgIHBhcmVudFBlcmNlbnRDaGVja2VkOiBudW1iZXI7XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XHJcbiAgICAvKiogKipTVEFCTEUgKiogKi9cclxuICAgIC8vY2hlY2tib3hlczogTWFuYWdlZENoaWxkcmVuPEk+O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFYWNoIGNoaWxkIGNoZWNrYm94IG11c3QgY2FsbCB0aGlzIGhvb2ssICppbiBhZGRpdGlvbiB0byogYHVzZUNoZWNrYm94YFxyXG4gICAgICovXHJcbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGQ6IFVzZUNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD47XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwYXJlbnQgY2hlY2tib3ggbXVzdCB1c2UgdGhpcyBob29rXHJcbiAgICAgKiBcclxuICAgICAqICoqTm90YWJseSB1bnN0YWJsZSEqKiBiZWNhdXNlIGl0IHJlbGllcyBvbiBgYXJpYUNvbnRyb2xzYCwgcG9wdWxhdGVkIGJ5IGFsbCBjaGlsZCBjaGVja2JveGVzXHJcbiAgICAgKi9cclxuICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dDogVXNlQ2hlY2tib3hHcm91cFBhcmVudDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgY2hlY2tib3g6IE9taXQ8VXNlQ2hlY2tib3hQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImNoZWNrYm94XCJdLCBcIm9uQ2hlY2tlZENoYW5nZVwiPjtcclxuICAgIGxhYmVsOiBVc2VDaGVja2JveFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+W1wibGFiZWxcIl07XHJcbiAgICBoYXNGb2N1c0xhYmVsOiBVc2VDaGVja2JveFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+W1wiaGFzRm9jdXNMYWJlbFwiXTtcclxuICAgIGhhc0ZvY3VzSW5wdXQ6IFVzZUNoZWNrYm94UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD5bXCJoYXNGb2N1c0lucHV0XCJdO1xyXG4gICAgY2hlY2tib3hMaWtlOiBPbWl0PFVzZUNoZWNrYm94UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD5bXCJjaGVja2JveExpa2VcIl0sIFwiY2hlY2tlZFwiPjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hHcm91cFBhcmVudDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhOiBVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4pID0+IHtcclxuICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47XHJcbiAgICB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBcclxuICogXHJcbiAqIEBwYXJhbSBwYXJhbTAgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoZWNrYm94R3JvdXA8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgdHlwZWFoZWFkTmF2aWdhdGlvbiB9OiBVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVycyk6IFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XHJcbiAgICBkZWJ1Z0xvZyhcInVzZUNoZWNrYm94R3JvdXBcIik7XHJcbiAgICAvL2NvbnN0IG9uVXBkYXRlQ2hpbGRyZW4gPSB1c2VTdGFibGVDYWxsYmFjayhvblVwZGF0ZUNoaWxkcmVuVW5zdGFibGUgPz8gKCgpID0+IHt9KSk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIC4uLmxpc3RSZXR1cm5UeXBlXHJcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb248SW5wdXRFbGVtZW50LCBJbnB1dEVsZW1lbnQsIENCRywgbmV2ZXI+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcclxuICAgICAgICByb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9IH0gPSBsaXN0UmV0dXJuVHlwZTtcclxuXHJcbiAgICAvL2NvbnN0IFt1bmNoZWNrZWRDb3VudCwgc2V0VW5oZWNrZWRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcblxyXG4gICAgLy8gS2VlcCB0cmFjayBvZiBhbGwgY2hpbGQgSURzLCBhbmQgYW55IHRpbWUgYW55IG9mIHRoZW0gY2hhbmdlLCBcclxuICAgIC8vIGdlbmVyYXRlIGEgbmV3IHN0cmluZyB3aXRoIGFsbCBvZiB0aGVtIGNvbmNhdGVuYXRlZCB0b2dldGhlclxyXG4gICAgLy8gKGJ1dCBvbmx5IG9uY2UgcGVyIHJlbmRlcik7XHJcbiAgICBjb25zdCBhbGxJZHMgPSB1c2VSZWYobmV3IFNldDxzdHJpbmc+KCkpO1xyXG4gICAgY29uc3QgW2FyaWFDb250cm9scywgc2V0Q29udHJvbHNdID0gdXNlU3RhdGUoXCJcIik7XHJcbiAgICBjb25zdCBbdXBkYXRlSW5kZXgsIHNldElkVXBkYXRlSW5kZXhdID0gdXNlU3RhdGUoMCk7XHJcblxyXG5cclxuICAgIGNvbnN0IFtjaGVja2VkQ291bnQsIHNldENoZWNrZWRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IGNoZWNrZWRJbmRpY2VzID0gdXNlUmVmKG5ldyBTZXQ8bnVtYmVyPigpKTtcclxuICAgIC8vY29uc3QgW3NlbGZJc0NoZWNrZWQsIHNldFNlbGZJc0NoZWNrZWQsIGdldFNlbGZJc0NoZWNrZWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IFwibWl4ZWRcIj4oZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IGdldFNlbGZJc0NoZWNrZWRVbnN0YWJsZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gY2hlY2tlZENvdW50IC8gKGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIHBlcmNlbnRhZ2UgPD0gMCA/IGZhbHNlIDogcGVyY2VudGFnZSA+PSAxID8gdHJ1ZSA6IFwibWl4ZWRcIjtcclxuICAgIH0sIFtjaGVja2VkQ291bnRdKTtcclxuXHJcbiAgICBjb25zdCBnZXRTZWxmSXNDaGVja2VkU3RhYmxlID0gdXNlU3RhYmxlQ2FsbGJhY2soZ2V0U2VsZklzQ2hlY2tlZFVuc3RhYmxlKTtcclxuICAgIGNvbnN0IFtzZXRQYXJlbnRDaGVja2JveENoZWNrZWQsIHNldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZF0gPSB1c2VTdGF0ZTxTdGF0ZVVwZGF0ZXI8Q2hlY2tib3hDaGVja2VkVHlwZT4gfCBudWxsPihudWxsKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgc2V0UGFyZW50Q2hlY2tib3hDaGVja2VkPy4oY2hlY2tlZENvdW50ID09IDAgPyBmYWxzZSA6IGNoZWNrZWRDb3VudCA9PSAoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkgKyAxKSA/IHRydWUgOiBcIm1peGVkXCIpO1xyXG4gICAgfSwgW3NldFBhcmVudENoZWNrYm94Q2hlY2tlZCwgY2hlY2tlZENvdW50XSlcclxuXHJcbiAgICAvLyBJZiB0aGUgdXNlciBoYXMgY2hhbmdlZCB0aGUgcGFyZW50IGNoZWNrYm94J3MgdmFsdWUsIHRoZW4gdGhpcyByZWYgaG9sZHMgYSBtZW1vcnkgb2Ygd2hhdCB2YWx1ZXMgd2VyZSBoZWxkIGJlZm9yZS5cclxuICAgIC8vIE90aGVyd2lzZSwgaXQncyBudWxsIHdoZW4gdGhlIGxhc3QgaW5wdXQgd2FzIGZyb20gYSBjaGlsZCBjaGVja2JveC4gXHJcbiAgICAvL2NvbnN0IHNhdmVkQ2hlY2tlZFZhbHVlcyA9IHVzZVJlZjxNYXA8bnVtYmVyLCBib29sZWFuIHwgXCJtaXhlZFwiPiB8IG51bGw+KG51bGwpO1xyXG4gICAgY29uc3QgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0ID0gdXNlQ2FsbGJhY2s8VXNlQ2hlY2tib3hHcm91cFBhcmVudDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4+KCh7IGNoZWNrYm94LCBjaGVja2JveExpa2UsIGxhYmVsLCBoYXNGb2N1c0xhYmVsLCBoYXNGb2N1c0lucHV0IH0pID0+IHtcclxuICAgICAgICBkZWJ1Z0xvZyhcInVzZUNoZWNrYm94R3JvdXBQYXJlbnRcIik7XHJcbiAgICAgICAgY29uc3QgeyAuLi5fdm9pZCB9ID0gY2hlY2tib3g7XHJcbiAgICAgICAgY29uc3QgeyBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgIC4uLl92b2lkMiB9ID0gY2hlY2tib3hMaWtlO1xyXG4gICAgICAgIGNvbnN0IHsgdGFnSW5wdXQsIHRhZ0xhYmVsLCAgLi4uX3ZvaWQzIH0gPSBsYWJlbDtcclxuXHJcbiAgICAgICAgY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWRdID0gdXNlU3RhdGU8Q2hlY2tib3hDaGVja2VkVHlwZT4oZmFsc2UpO1xyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZCgoKSA9PiBzZXRDaGVja2VkKTtcclxuICAgICAgICB9LCBbXSlcclxuICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExhYmVsRWxlbWVudCB9ID0gdXNlQ2hlY2tib3g8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHsgY2hlY2tib3hMaWtlOiB7IGxhYmVsUG9zaXRpb24sIGNoZWNrZWQsIGRpc2FibGVkLCB9LCBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSwgY2hlY2tib3g6IHsgb25DaGVja2VkQ2hhbmdlOiBvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dDIgYXMgYW55LCB9LCBoYXNGb2N1c0lucHV0LCBoYXNGb2N1c0xhYmVsIH0pO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKTtcclxuICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0UHJvcHM6IGZ1bmN0aW9uIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSAodXNlTWVyZ2VkUHJvcHM8SW5wdXRFbGVtZW50Pih1c2VNZXJnZWRQcm9wczxJbnB1dEVsZW1lbnQ+KHt9LCB7IFwiYXJpYS1jb250cm9sc1wiOiBhcmlhQ29udHJvbHMsIG9uSW5wdXQ6IHRhZ0lucHV0ID09IFwiaW5wdXRcIiA/IChlID0+IGUucHJldmVudERlZmF1bHQoKSkgOiB1bmRlZmluZWQgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KSwgcHJvcHMpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiID8gcmV0IDogcHJvcHMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wczogZnVuY3Rpb24gdXNlQ2hlY2tib3hHcm91cFBhcmVudExhYmVsUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9ICh1c2VNZXJnZWRQcm9wczxMYWJlbEVsZW1lbnQ+KHVzZU1lcmdlZFByb3BzPExhYmVsRWxlbWVudD4oe30sIHsgXCJhcmlhLWNvbnRyb2xzXCI6IGFyaWFDb250cm9scyB9IGFzIGFueSkgYXMgYW55LCBwcm9wcykpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIgPyByZXQgOiBwcm9wcylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFthcmlhQ29udHJvbHNdKTtcclxuXHJcbiAgICBjb25zdCBvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dDIgPSB1c2VDYWxsYmFjaygoZTogQ2hlY2tib3hDaGFuZ2VFdmVudDxJbnB1dEVsZW1lbnQ+KSA9PiB7XHJcblxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2VsZklzQ2hlY2tlZCA9IGdldFNlbGZJc0NoZWNrZWRTdGFibGUoKTtcclxuICAgICAgICBjb25zdCBuZXh0Q2hlY2tlZCA9IChzZWxmSXNDaGVja2VkID09PSBmYWxzZSA/IFwibWl4ZWRcIiA6IHNlbGZJc0NoZWNrZWQgPT09IFwibWl4ZWRcIiA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICAgICAgbGV0IHdpbGxDaGFuZ2VBbnkgPSBmYWxzZTtcclxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHdpbGxDaGFuZ2VBbnkgfHw9IChjaGlsZC5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby5jaGVja2VkICE9IGNoaWxkLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmdldExhc3RVc2VyQ2hlY2tlZCgpKSk7XHJcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjaGVja2VkOiBib29sZWFuO1xyXG4gICAgICAgICAgICBpZiAobmV4dENoZWNrZWQgPT0gXCJtaXhlZFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2lsbENoYW5nZUFueSlcclxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gKGNoaWxkLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmdldExhc3RVc2VyQ2hlY2tlZCgpIGFzIGJvb2xlYW4pO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tlZCA9IG5leHRDaGVja2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLm9uQ2hlY2tlZENoYW5nZT8uKGVuaGFuY2VFdmVudChlLCB7IGNoZWNrZWQgfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qaWYgKHNlbGZJc0NoZWNrZWQgPT09IHRydWUgfHwgKHNlbGZJc0NoZWNrZWQgPT09IGZhbHNlICYmIHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50ID09IG51bGwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvblVwZGF0ZUNoaWxkcmVuKGVuaGFuY2VFdmVudChlLCB7IGNoaWxkcmVuQ2hlY2tlZDogZmFsc2UgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzZWxmSXNDaGVja2VkID09PSBcIm1peGVkXCIpIHtcclxuXHJcbiAgICAgICAgICAgIHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcclxuICAgICAgICAgICAgICAgIHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50IS5zZXQoY2hpbGQuaW5kZXgsIGNoaWxkLmdldExhc3RVc2VyQ2hlY2tlZCgpKTtcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvblVwZGF0ZUNoaWxkcmVuKGVuaGFuY2VFdmVudChlLCB7IGNoaWxkcmVuQ2hlY2tlZDogdHJ1ZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gb25VcGRhdGVDaGlsZHJlbihlbmhhbmNlRXZlbnQoZSwgeyBjaGlsZHJlbkNoZWNrZWQ6IHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50ID8/IHRydWUgfSkpO1xyXG4gICAgICAgIH0qL1xyXG4gICAgfSwgW10pXHJcblxyXG4gICAgY29uc3Qgbm90aWZ5Q2hlY2tlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyLCBjaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiKSA9PiB7XHJcbiAgICAgICAgaWYgKGNoZWNrZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgaWYgKCFjaGVja2VkSW5kaWNlcy5jdXJyZW50LmhhcyhpbmRleCkpIHtcclxuICAgICAgICAgICAgICAgIHNldENoZWNrZWRDb3VudChjID0+IChjICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgY2hlY2tlZEluZGljZXMuY3VycmVudC5hZGQoaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tlZEluZGljZXMuY3VycmVudC5oYXMoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDaGVja2VkQ291bnQoYyA9PiAoYyAtIDEpKTtcclxuICAgICAgICAgICAgICAgIGNoZWNrZWRJbmRpY2VzLmN1cnJlbnQuZGVsZXRlKGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvKnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgbGV0IHBlcmNlbnRhZ2UgPSBjaGVja2VkQ291bnQgLyBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgIHNldFNlbGZJc0NoZWNrZWQocGVyY2VudGFnZSA8PSAwID8gZmFsc2UgOiBwZXJjZW50YWdlID49IDEgPyB0cnVlIDogXCJtaXhlZFwiKVxyXG4gICAgfSwgW3NldFNlbGZJc0NoZWNrZWQsIG1hbmFnZWRDaGlsZHJlbi5sZW5ndGgsIGNoZWNrZWRDb3VudF0pOyovXHJcblxyXG4gICAgLypjb25zdCB1c2VDaGVja2JveEdyb3VwUGFyZW50UHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IHtcclxuICAgICAgICByZXR1cm4gXHJcbiAgICB9LCBbYXJpYUNvbnRyb2xzXSk7Ki9cclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldENvbnRyb2xzKEFycmF5LmZyb20oYWxsSWRzLmN1cnJlbnQpLmpvaW4oXCIgXCIpKTtcclxuICAgIH0sIFt1cGRhdGVJbmRleF0pXHJcblxyXG4gICAgY29uc3QgdXNlQ2hlY2tib3hHcm91cENoaWxkOiBVc2VDaGVja2JveEdyb3VwQ2hpbGQ8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+ID0gdXNlQ2FsbGJhY2s8VXNlQ2hlY2tib3hHcm91cENoaWxkPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pj4oZnVuY3Rpb24gKHsgYXNDaGVja2JveCwgYXNDaGVja2JveEdyb3VwQ2hpbGQgfSkge1xyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlQ2hlY2tib3hHcm91cENoaWxkXCIsIGFzQ2hlY2tib3hHcm91cENoaWxkLm1hbmFnZWRDaGlsZC5pbmRleCwgYXNDaGVja2JveC5jaGVja2JveExpa2UuY2hlY2tlZCk7XHJcbiAgICAgICAgY29uc3QgeyBjaGVja2JveDogeyBvbkNoZWNrZWRDaGFuZ2UgfSwgY2hlY2tib3hMaWtlOiB7IGNoZWNrZWQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uIH0sIGxhYmVsOiB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9LCBoYXNGb2N1c0lucHV0LCBoYXNGb2N1c0xhYmVsIH0gPSBhc0NoZWNrYm94O1xyXG4gICAgICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkOiB7IGluZGV4IH0gfSA9IGFzQ2hlY2tib3hHcm91cENoaWxkO1xyXG4gICAgICAgIC8vbGFiZWxQb3NpdGlvbiA/Pz0gXCJzZXBhcmF0ZVwiO1xyXG4gICAgICAgIGNvbnN0IFtnZXRMYXN0VXNlckNoZWNrZWQsIHNldExhc3RVc2VyQ2hlY2tlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbiB8IFwibWl4ZWRcIj4obnVsbCwgcmV0dXJuRmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQsXHJcbiAgICAgICAgICAgIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50LFxyXG4gICAgICAgICAgICAuLi5jaGVja2JveFJldHVyblR5cGVcclxuICAgICAgICB9ID0gdXNlQ2hlY2tib3g8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcclxuICAgICAgICAgICAgY2hlY2tib3g6IHtcclxuICAgICAgICAgICAgICAgIG9uQ2hlY2tlZENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2hlY2tlZENoYW5nZT4+KGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldExhc3RVc2VyQ2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKTtcclxuICAgICAgICAgICAgICAgICAgICBvbkNoZWNrZWRDaGFuZ2U/LihlIGFzIGFueSk7XHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2hlY2tib3hMaWtlOiB7XHJcbiAgICAgICAgICAgICAgICBjaGVja2VkLFxyXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICAgICAgdGFnSW5wdXQsXHJcbiAgICAgICAgICAgICAgICB0YWdMYWJlbFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoYXNGb2N1c0lucHV0LFxyXG4gICAgICAgICAgICBoYXNGb2N1c0xhYmVsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgbGFiZWw6IHsgaW5wdXRJZCwgbGFiZWxJZCB9IH0gPSBjaGVja2JveFJldHVyblR5cGU7XHJcblxyXG4gICAgICAgIC8vY29uc3QgZ2V0Q2hlY2tlZCA9IHVzZVN0YWJsZUdldHRlcihjaGVja2VkKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udHJvbHNJZCA9IChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIiA/IGlucHV0SWQgOiBsYWJlbElkKSE7XHJcblxyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGFsbElkcy5jdXJyZW50LmFkZChjb250cm9sc0lkKTtcclxuICAgICAgICAgICAgc2V0SWRVcGRhdGVJbmRleChpID0+ICsraSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWxsSWRzLmN1cnJlbnQuZGVsZXRlKGNvbnRyb2xzSWQpO1xyXG4gICAgICAgICAgICAgICAgc2V0SWRVcGRhdGVJbmRleChpID0+ICsraSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbY29udHJvbHNJZF0pO1xyXG5cclxuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgbm90aWZ5Q2hlY2tlZChpbmRleCwgY2hlY2tlZCk7XHJcbiAgICAgICAgfSwgW2luZGV4LCBjaGVja2VkXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLCAuLi5saXN0TmF2aWdhdGlvblJldHVyblR5cGUgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoe1xyXG4gICAgICAgICAgICBzdWJJbmZvOiB7IGdldExhc3RVc2VyQ2hlY2tlZCwgb25DaGVja2VkQ2hhbmdlLCBjaGVja2VkIH0sXHJcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmFzQ2hlY2tib3hHcm91cENoaWxkLmxpc3ROYXZpZ2F0aW9uIH0sXHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogYXNDaGVja2JveEdyb3VwQ2hpbGQubWFuYWdlZENoaWxkLFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogYXNDaGVja2JveEdyb3VwQ2hpbGQucm92aW5nVGFiSW5kZXhcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY2hlY2tib3hMaWtlOiBjaGVja2JveFJldHVyblR5cGUuY2hlY2tib3hMaWtlLFxyXG4gICAgICAgICAgICBsYWJlbDogY2hlY2tib3hSZXR1cm5UeXBlLmxhYmVsLFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogbGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgICAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMocHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0MiA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvblByb3BzKHJldCkgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiID8gcmV0MiA6IHJldCkgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXNlQ2hlY2tib3hHcm91cENoaWxkTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJldDIgPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlTGlzdE5hdmlnYXRpb25Qcm9wcyhyZXQgYXMgYW55KSBhcyBhbnkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIiA/IHJldDIgOiByZXQpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZCxcclxuICAgICAgICB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXQsXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBsaXN0UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IGxpc3RSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLnR5cGVhaGVhZE5hdmlnYXRpb24sXHJcbiAgICAgICAgY2hlY2tib3hHcm91cDoge1xyXG4gICAgICAgICAgICBwYXJlbnRJc0NoZWNrZWQ6IGdldFNlbGZJc0NoZWNrZWRVbnN0YWJsZSgpIGFzIGJvb2xlYW4gfCBcIm1peGVkXCIsXHJcbiAgICAgICAgICAgIHBhcmVudFBlcmNlbnRDaGVja2VkOiAoY2hlY2tlZENvdW50IC8gKGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpICsgMSkpLFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQsIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzLCB1c2VGb2N1c1RyYXAsIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVJhbmRvbUlkLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcbmludGVyZmFjZSBTRFAge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGNvdW50IGFzIFwid2l0aGluXCIgdGhpcyBjb21wb25lbnQuXHJcbiAgICAgKiBcclxuICAgICAqIFVzdWFsbHkganVzdCBhIHNpbmdsZSBlbGVtZW50LCBidXQgZS5nLiBhIE1lbnUgKyBNZW51QnV0dG9uIGNvdWxkIGhhdmUgdHdvLlxyXG4gICAgICovXHJcbiAgICBnZXRFbGVtZW50czogKCkgPT4gRWxlbWVudCB8IChFbGVtZW50IHwgbnVsbClbXSB8IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRpc21pc3NlZFxyXG4gICAgICovXHJcbiAgICBvbkNsb3NlKHJlYXNvbjogXCJiYWNrZHJvcFwiIHwgXCJlc2NhcGVcIiB8IFwibG9zdC1mb2N1c1wiKTogdm9pZDtcclxuXHJcbiAgICBvcGVuOiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgTVAge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIHRydWUsIHRoZSBib2R5IGVsZW1lbnQgcHJvdmlkZWQgY29udGFpbnMgcHVyZWx5IHNlbWFudGljIGNvbnRlbnRcclxuICAgICAqIHRoYXQgY2FuIGJlIHJlYWQgb3V0IGJ5IGEgc2NyZWVuIHJlYWRlciBpbiBvbmUgbG9uZywgdW5pbnRlcnJ1cHRlZCBzdHJldGNoLlxyXG4gICAgICogXHJcbiAgICAgKiBUaGlzIHNob3VsZCBiZSBmYWxzZSBpZiB0aGUgbW9kYWwgY29udGFpbnMsIGZvciBleGFtcGxlLCBhIGxpc3Qgb3Igb3RoZXJcclxuICAgICAqIGludGVyYWN0aXZlIHdpZGdldHMsIGFuZCB0cnVlIGlmIGl0J3MgbW9zdGx5IHNob3J0LWZvcm0gdGV4dCBjb250ZW50LlxyXG4gICAgICogXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBmYWxzZSB0byBiZSBvbiB0aGUgc2FmZSBzaWRlLCBidXQgdGhpcyBzaG91bGQgYmUgdHJ1ZSB3aGVuZXZlciByZWFzb25hYmxlLlxyXG4gICAgICovXHJcbiAgICBib2R5SXNPbmx5U2VtYW50aWM/OiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiBhbnkgbW9kYWwgZGlhbG9nIG9wZW5zLCBpdCBtdXN0IHNlbmQgZm9jdXMgdG8gdGhhdCBkaWFsb2csIGlkZWFsbHkgd2hpY2hldmVyIGVsZW1lbnQgbWFrZXMgdGhlIG1vc3Qgc2Vuc2UgaW4gY29udGV4dC5cclxuICAgICAqIFxyXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIGl0J3MgYSBjb25maXJtYXRpb24gZGlhbG9nIGFib3V0IGRlbGV0aW5nIHNvbWV0aGluZywgaXQncyBiZXN0IHRvIHNlbmQgZm9jdXMgdG8gdGhlIFwiY2FuY2VsXCIgYnV0dG9uLlxyXG4gICAgICogXHJcbiAgICAgKiBJbiBvdGhlciBjYXNlcywgaXQgbWFrZXMgbW9yZSBzZW5zZSB0byBmb2N1cyB0aGUgZGlhbG9nJ3MgdGl0bGUsIGZpcnN0IGludGVyYWN0aXZlIGVsZW1lbnQsIGV0Yy5cclxuICAgICAqIFxyXG4gICAgICogQnkgZGVmYXVsdCwgd2UgdHJ5IHRvIHBpY2sgYSBzZW5zaWJsZSBkZWZhdWx0IC0tIGlmIHRoZSBkaWFsb2cgY29udGFpbnMgb25seSBkZXNjcmlwdGl2ZSBjb250ZW50LCB0aGVuIHdlIGZvY3VzIHRoZSBib2R5LiBPdGhlcndpc2Ugd2UgZm9jdXMgdGhlIHRpdGxlLlxyXG4gICAgICogXHJcbiAgICAgKiAqKlBMRUFTRSoqIGNvbnNpZGVyIG92ZXJyaWRpbmcgdGhpcyB0byBwcm92aWRlIHRoZSBiZXN0IGV4cGVyaWVuY2UgZm9yIHlvdXIgZGlhbG9nLiAgWW91IHNob3VsZG4ndCBoYXZlIHRoYXQgbWFueSBtb2RhbCBkaWFsb2dzIGFueXdheSAtLSB0YWtlIHRoYXQgYml0IG9mIGV4dHJhIHRpbWUgaWYgeW91IGNhbi5cclxuICAgICAqL1xyXG4gICAgZm9jdXNTZWxmPygpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBTb2Z0RGlzbWlzc09taXRzID0ga2V5b2YgU0RQO1xyXG5leHBvcnQgdHlwZSBNb2RhbE9taXRzID0ga2V5b2YgTVA7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvZnREaXNtaXNzUGFyYW1ldGVyczxPbWl0cyBleHRlbmRzIFNvZnREaXNtaXNzT21pdHM+IHtcclxuICAgIHNvZnREaXNtaXNzOiBPbWl0PFNEUCwgT21pdHM+O1xyXG4gICAgYWN0aXZlRWxlbWVudDogVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnM7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTW9kYWxQYXJhbWV0ZXJzPE1PIGV4dGVuZHMgTW9kYWxPbWl0cywgU0RPIGV4dGVuZHMgU29mdERpc21pc3NPbWl0cz4gZXh0ZW5kcyBVc2VTb2Z0RGlzbWlzc1BhcmFtZXRlcnM8U0RPIHwgXCJnZXRFbGVtZW50c1wiPiB7XHJcbiAgICBtb2RhbDogT21pdDxNUCwgTU8+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgc29mdERpc21pc3M6IHtcclxuICAgICAgICBvbkJhY2tkcm9wQ2xpY2s6IChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PGFueT4pID0+IHZvaWQ7XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZVdpdGhIb29rczxUIGV4dGVuZHMgTm9kZT4gZXh0ZW5kcyBVc2VTb2Z0RGlzbWlzc1JldHVyblR5cGVJbmZvIHtcclxuICAgIC8qKiBUaGlzIGJhc2ljYWxseSBjYW4gYmUgYW55IGVsZW1lbnQgLS0gaXQncyBvbmx5IHVzZWQgdG8gZ2V0IHRoZSBvd25pbmcgd2luZG93L2RvY3VtZW50LiAqL1xyXG4gICAgdXNlU29mdERpc21pc3NQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBhIG1vZGFsLWxpa2Ugc29mdC1kaXNtaXNzIGludGVyYWN0aW9uLlxyXG4gKiBcclxuICogVGhhdCBpcywgYW55IGNsaWNrcyBvciB0YXBzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGNvbXBvbmVudCwgXHJcbiAqIG9yIGFueSB0aW1lIHRoZSBFc2NhcGUga2V5IGlzIHByZXNzZWQgd2l0aGluIHRoZSBjb21wb25lbnQsXHJcbiAqICh3aXRoIHZhcmlvdXMgYnJvd3NlciBvZGRpdGllcyByZWdhcmRpbmcgY2xpY2tzIG9uIGJsYW5rIG9yIGluZXJ0IGFyZWFzIGhhbmRsZWQpXHJcbiAqIHRoZSBjb21wb25lbnQgd2lsbCByZXF1ZXN0IHRvIGNsb3NlIGl0c2VsZi5cclxuICogXHJcbiAqIE9mIGNvdXJzZSwgaWYgeW91IGRvbid0IGRvIGFueXRoaW5nIGluIHRoZSBgb25DbG9zZWAgZnVuY3Rpb24sXHJcbiAqIGl0IHdvbid0IGJlIGEgc29mdCBkaXNtaXNzIGFueW1vcmUuXHJcbiAqIFxyXG4gKiBAcGFyYW0gcGFyYW0wIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTb2Z0RGlzbWlzczxUIGV4dGVuZHMgTm9kZT4oeyBzb2Z0RGlzbWlzczogeyBvbkNsb3NlLCBnZXRFbGVtZW50cywgb3BlbiB9LCBhY3RpdmVFbGVtZW50OiB7IG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIC4uLmFjdGl2ZUVsZW1lbnQgfSB9OiBVc2VTb2Z0RGlzbWlzc1BhcmFtZXRlcnM8bmV2ZXI+KTogVXNlU29mdERpc21pc3NSZXR1cm5UeXBlV2l0aEhvb2tzPFQ+IHtcclxuXHJcbiAgICBjb25zdCBzdGFibGVPbkNsb3NlID0gdXNlU3RhYmxlQ2FsbGJhY2sob25DbG9zZSk7XHJcbiAgICBjb25zdCBzdGFibGVHZXRFbGVtZW50cyA9IHVzZVN0YWJsZUNhbGxiYWNrKGdldEVsZW1lbnRzKTtcclxuICAgIGNvbnN0IGdldE9wZW4gPSB1c2VTdGFibGVHZXR0ZXIob3Blbik7XHJcblxyXG4gICAgY29uc3QgeyBnZXREb2N1bWVudCB9ID0gYWN0aXZlRWxlbWVudFxyXG5cclxuICAgIGNvbnN0IG9uQmFja2Ryb3BDbGljayA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIG9uQmFja2Ryb3BDbGljayhlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PGFueT4pIHtcclxuICAgICAgICBpZiAoIWdldE9wZW4oKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XHJcblxyXG4gICAgICAgIC8vIEJhc2ljYWxseSwgXCJ3YXMgdGhpcyBldmVudCBmaXJlZCBvbiB0aGUgcm9vdC1tb3N0IGVsZW1lbnQsIG9yIGF0IGxlYXN0IGFuIGVsZW1lbnQgbm90IGNvbnRhaW5lZCBieSB0aGUgbW9kYWw/XCJcclxuICAgICAgICAvLyBFaXRoZXIgY291bGQgYmUgaG93IHRoZSBicm93c2VyIGhhbmRsZXMgdGhlc2Ugc29ydHMgb2YgXCJpbnRlcmFjdGluZyB3aXRoIG5vdGhpbmdcIiBldmVudHMuXHJcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09IGRvY3VtZW50Py5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgc3RhYmxlT25DbG9zZShcImJhY2tkcm9wXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gc3RhYmxlR2V0RWxlbWVudHMoKTtcclxuXHJcbiAgICAgICAgaWYgKGVsZW1lbnRzICYmIGUudGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZWxlbWVudHMpKVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xyXG5cclxuICAgICAgICAgICAgbGV0IGZvdW5kSW5zaWRlQ2xpY2sgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZEluc2lkZUNsaWNrID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFmb3VuZEluc2lkZUNsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICBvbkNsb3NlKFwiYmFja2Ryb3BcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICBjb25zdCB7IC4uLl91bnVzZWQgfSA9IHVzZUFjdGl2ZUVsZW1lbnQoe1xyXG4gICAgICAgIC4uLmFjdGl2ZUVsZW1lbnQsXHJcblxyXG4gICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChuZXdFbGVtZW50OiBFbGVtZW50LCBwcmV2OiBFbGVtZW50IHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U/LihuZXdFbGVtZW50LCBwcmV2KTtcclxuICAgICAgICAgICAgbGV0IHZhbGlkRm9jdXNhYmxlRWxlbWVudHMgPSBzdGFibGVHZXRFbGVtZW50cygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbGlkRm9jdXNhYmxlRWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWxpZEZvY3VzYWJsZUVsZW1lbnRzKSlcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZEZvY3VzYWJsZUVsZW1lbnRzID0gW3ZhbGlkRm9jdXNhYmxlRWxlbWVudHNdO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZm9jdXNhYmxlIG9mIHZhbGlkRm9jdXNhYmxlRWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNhYmxlPy5jb250YWlucyhuZXdFbGVtZW50KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvbkNsb3NlKFwibG9zdC1mb2N1c1wiKTtcclxuICAgICAgICB9LCBbXSlcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxUPih7XHJcbiAgICAgICAgb25Nb3VudDogdXNlQ2FsbGJhY2soKCkgPT4geyBkZWJ1Z2dlcjsgfSwgW10pLFxyXG4gICAgICAgIG9uVW5tb3VudDogdXNlQ2FsbGJhY2soKCkgPT4geyBkZWJ1Z2dlcjsgfSwgW10pLFxyXG4gICAgICAgIG9uRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKGU6IFQgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBlLm93bmVyRG9jdW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3aW5kb3cgPSBkb2N1bWVudD8uZGVmYXVsdFZpZXc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgZXZlcnl0aGluZyBlbHNlIGlzIGluZXJ0LCB3ZSBsaXN0ZW4gZm9yIGNhcHR1cmVkIGNsaWNrcyBvbiB0aGUgd2luZG93XHJcbiAgICAgICAgICAgICAgICAvLyAod2UgZG9uJ3QgdXNlIG9uQ2xpY2sgc2luY2UgdGhhdCBkb2Vzbid0IGZpcmUgd2hlbiBjbGlja2VkIG9uIGVtcHR5L2luZXJ0IGFyZWFzKVxyXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogV2UgbmVlZCBhICpzZXBhcmF0ZSogdG91Y2ggZXZlbnQgb24gbW9iaWxlIFNhZmFyaSwgYmVjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gaXQgZG9lc24ndCBsZXQgY2xpY2sgZXZlbnRzIGJ1YmJsZSBvciBiZSBjYXB0dXJlZCBmcm9tIHRyYWRpdGlvbmFsbHkgbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRvdWNoIGV2ZW50cyB3b3JrIGFzIGV4cGVjdGVkLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2VEb3duID0gKGU6IE1vdXNlRXZlbnQpID0+IHsgaWYgKGdldE9wZW4oKSkgb25CYWNrZHJvcENsaWNrKGUpOyB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG91Y2hTdGFydCA9IChlOiBUb3VjaEV2ZW50KSA9PiB7IGlmIChnZXRPcGVuKCkpIG9uQmFja2Ryb3BDbGljayhlKTsgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleURvd24gPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4geyBpZiAoZS5rZXkgPT09IFwiRXNjYXBlXCIpIHsgc3RhYmxlT25DbG9zZShcImVzY2FwZVwiKTsgfSB9O1xyXG5cclxuICAgICAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBtb3VzZURvd24sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdG91Y2hTdGFydCwgeyBjYXB0dXJlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlEb3duKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBtb3VzZURvd24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdG91Y2hTdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlEb3duKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtdKVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VTb2Z0RGlzbWlzc1Byb3BzOiB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4gPT4geyBkZWJ1Z2dlcjsgcmV0dXJuIHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wcykgfSwgW10pLFxyXG4gICAgICAgIHNvZnREaXNtaXNzOiB7XHJcbiAgICAgICAgICAgIG9uQmFja2Ryb3BDbGljayxcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTW9kYWxSZXR1cm5UeXBlSW5mbyBleHRlbmRzIFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZUluZm8ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VNb2RhbFJldHVyblR5cGVXaXRoSG9va3M8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTW9kYWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZU1vZGFsUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlTW9kYWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNb2RhbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNb2RhbEVsZW1lbnQ+O1xyXG4gICAgdXNlTW9kYWxUaXRsZTogVXNlTW9kYWxUaXRsZTxUaXRsZUVsZW1lbnQ+O1xyXG4gICAgdXNlTW9kYWxCb2R5OiBVc2VNb2RhbEJvZHk8Qm9keUVsZW1lbnQ+XHJcbiAgICB1c2VNb2RhbEJhY2tkcm9wOiBVc2VNb2RhbEJhY2tkcm9wPEJhY2tkcm9wRWxlbWVudD47XHJcbiAgICB1c2VNb2RhbEZvY3VzQ29udGFpbmVyUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+O1xyXG4gICAgLy9zb2Z0RGlzbWlzczogT21pdDxVc2VTb2Z0RGlzbWlzc1JldHVyblR5cGU8TW9kYWxFbGVtZW50PltcInNvZnREaXNtaXNzXCJdLCBcInVzZVNvZnREaXNtaXNzUHJvcHNcIj47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZU1vZGFsVGl0bGU8VGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZU1vZGFsVGl0bGVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+OyB9O1xyXG5leHBvcnQgdHlwZSBVc2VNb2RhbEJvZHk8Qm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlTW9kYWxCb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD47IH07XHJcbmV4cG9ydCB0eXBlIFVzZU1vZGFsQmFja2Ryb3A8QmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZU1vZGFsQmFja2Ryb3BQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+OyB9O1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJpYyBtb2RhbCBob29rLCB1c2VkIGJ5IG1vZGFsIGRpYWxvZ3MsIGJ1dCBjYW4gYWxzb1xyXG4gKiBiZSB1c2VkIGJ5IGFueXRoaW5nIHRoYXQncyBtb2RhbCB3aXRoIGEgYmFja2Ryb3AuXHJcbiAqIEBwYXJhbSBwYXJhbTAgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1vZGFsPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBNb2RhbEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IG1vZGFsOiB7IGJvZHlJc09ubHlTZW1hbnRpYzogZGVzY3JpcHRpdmUsIGZvY3VzU2VsZiB9LCBzb2Z0RGlzbWlzczogeyBvbkNsb3NlLCBvcGVuIH0sIGFjdGl2ZUVsZW1lbnQgfTogVXNlTW9kYWxQYXJhbWV0ZXJzPG5ldmVyLCBuZXZlcj4pOiBVc2VNb2RhbFJldHVyblR5cGVXaXRoSG9va3M8Rm9jdXNDb250YWluZXJFbGVtZW50LCBNb2RhbEVsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudD4ge1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VUaXRsZVJlZkVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudDogZ2V0VGl0bGVFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PFRpdGxlRWxlbWVudD4oe30pO1xyXG4gICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUJvZHlSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQ6IGdldEJvZHlFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PEJvZHlFbGVtZW50Pih7fSk7XHJcbiAgICBmb2N1c1NlbGYgPz89ICgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0aXZlKSB7XHJcbiAgICAgICAgICAgIGdldEJvZHlFbGVtZW50KCk/LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlRWxlbWVudCA9IGdldFRpdGxlRWxlbWVudCgpO1xyXG4gICAgICAgICAgICBpZiAodGl0bGVFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgdGl0bGVFbGVtZW50LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vY29uc3QgZWxlbWVudFRvRm9jdXMgPSBnZXRUaXRsZUVsZW1lbnQoKSA/PyBnZXRCb2R5RWxlbWVudCgpXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHN0YWJsZU9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjayhvbkNsb3NlKTtcclxuICAgIGNvbnN0IHN0YWJsZUZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKGZvY3VzU2VsZik7XHJcblxyXG4gICAgLy9jb25zdCBbbW9kYWxEZXNjcmliZWRCeUJvZHksIHNldE1vZGFsRGVzY3JpYmVkQnlCb2R5XSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIHVzZUhpZGVTY3JvbGwob3Blbik7XHJcblxyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZU1vZGFsSWRBc1NvdXJjZSwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlTW9kYWxJZEFzUmVmZXJlbmNlckVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkPE1vZGFsRWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS1tb2RhbC1cIiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VCb2R5SWRBc1NvdXJjZSwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlQm9keUlkUmVmZXJlbmNlckVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkPEJvZHlFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLW1vZGFsLWJvZHktXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlVGl0bGVJZEFzU291cmNlLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VUaXRsZUlkUmVmZXJlbmNlckVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkPFRpdGxlRWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS1tb2RhbC10aXRsZS1cIiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcclxuXHJcblxyXG4gICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZU1vZGFsUmVmRWxlbWVudCwgZ2V0RWxlbWVudDogZ2V0TW9kYWxFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PE1vZGFsRWxlbWVudD4oe30pXHJcbiAgICBjb25zdCB7IHNvZnREaXNtaXNzOiB7IG9uQmFja2Ryb3BDbGljayB9LCB1c2VTb2Z0RGlzbWlzc1Byb3BzIH0gPSB1c2VTb2Z0RGlzbWlzczxNb2RhbEVsZW1lbnQ+KHsgc29mdERpc21pc3M6IHsgb25DbG9zZTogc3RhYmxlT25DbG9zZSwgZ2V0RWxlbWVudHM6IGdldE1vZGFsRWxlbWVudCwgb3BlbjogISFvcGVuIH0sIGFjdGl2ZUVsZW1lbnQgfSk7XHJcblxyXG4gICAgY29uc3QgdXNlTW9kYWxCYWNrZHJvcCA9IHVzZUNhbGxiYWNrPFVzZU1vZGFsQmFja2Ryb3A8QmFja2Ryb3BFbGVtZW50Pj4oZnVuY3Rpb24gdXNlTW9kYWxCYWNrZHJvcCgpIHtcclxuICAgICAgICBmdW5jdGlvbiB1c2VNb2RhbEJhY2tkcm9wUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEJhY2tkcm9wRWxlbWVudD4oeyBvblBvaW50ZXJVcDogb25CYWNrZHJvcENsaWNrIH0sIHByb3BzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICBjb25zdCB1c2VNb2RhbEZvY3VzQ29udGFpbmVyUHJvcHMgPSBmdW5jdGlvbiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+IHtcclxuICAgICAgICBjb25zdCB7IHVzZUZvY3VzVHJhcFByb3BzIH0gPSB1c2VGb2N1c1RyYXA8Rm9jdXNDb250YWluZXJFbGVtZW50Pih7IHRyYXBBY3RpdmU6IG9wZW4gfSk7XHJcbiAgICAgICAgcmV0dXJuIHVzZUZvY3VzVHJhcFByb3BzKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1c2VNb2RhbFByb3BzID0gZnVuY3Rpb24gKHsgXCJhcmlhLW1vZGFsXCI6IGFyaWFNb2RhbCwgcm9sZSwgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TW9kYWxFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1vZGFsRWxlbWVudD4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZU1vZGFsSWRBc1NvdXJjZVByb3BzIH0gPSB1c2VNb2RhbElkQXNTb3VyY2UoKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlVGl0bGVJZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgfSA9IHVzZVRpdGxlSWRSZWZlcmVuY2VyRWxlbWVudDxNb2RhbEVsZW1lbnQ+KFwiYXJpYS1sYWJlbGxlZGJ5XCIgYXMgbmV2ZXIpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VCb2R5SWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIH0gPSB1c2VCb2R5SWRSZWZlcmVuY2VyRWxlbWVudDxNb2RhbEVsZW1lbnQ+KFwiYXJpYS1kZXNjcmliZWRieVwiIGFzIG5ldmVyKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydCghYXJpYU1vZGFsKTtcclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob3BlbilcclxuICAgICAgICAgICAgICAgIHN0YWJsZUZvY3VzU2VsZigpO1xyXG4gICAgICAgIH0sIFtvcGVuXSlcclxuICAgICAgICBjb25zdCBwMSA9IHVzZUJvZHlJZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMocDApO1xyXG4gICAgICAgIGNvbnN0IHAyID0gdXNlTW9kYWxJZEFzU291cmNlUHJvcHMocDEpO1xyXG4gICAgICAgIGNvbnN0IHBGaW5hbCA9IHVzZVRpdGxlSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKHAyKTtcclxuICAgICAgICByZXR1cm4gdXNlU29mdERpc21pc3NQcm9wcyh1c2VNZXJnZWRQcm9wczxNb2RhbEVsZW1lbnQ+KHVzZU1vZGFsUmVmRWxlbWVudCh7IHJvbGU6IHJvbGUgfHwgXCJkaWFsb2dcIiB9KSwgZGVzY3JpcHRpdmUgPyBwRmluYWwgOiBwMikpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVzZU1vZGFsVGl0bGUgPSB1c2VDYWxsYmFjazxVc2VNb2RhbFRpdGxlPFRpdGxlRWxlbWVudD4+KGZ1bmN0aW9uIHVzZU1vZGFsVGl0bGUoKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZVRpdGxlSWRBc1NvdXJjZVByb3BzIH0gPSB1c2VUaXRsZUlkQXNTb3VyY2UoKTtcclxuICAgICAgICBjb25zdCB1c2VNb2RhbFRpdGxlUHJvcHMgPSBmdW5jdGlvbiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+IHtcclxuICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPz89IC0xO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlVGl0bGVSZWZFbGVtZW50UHJvcHModXNlVGl0bGVJZEFzU291cmNlUHJvcHMocHJvcHMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZU1vZGFsVGl0bGVQcm9wcyB9O1xyXG4gICAgfSwgW10pXHJcblxyXG4gICAgY29uc3QgdXNlTW9kYWxCb2R5ID0gdXNlQ2FsbGJhY2s8VXNlTW9kYWxCb2R5PEJvZHlFbGVtZW50Pj4oZnVuY3Rpb24gdXNlTW9kYWxCb2R5KCkge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZUJvZHlJZEFzU291cmNlUHJvcHMgfSA9IHVzZUJvZHlJZEFzU291cmNlKCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZU1vZGFsSWRBc1JlZmVyZW5jZXJFbGVtZW50UHJvcHMgfSA9IHVzZU1vZGFsSWRBc1JlZmVyZW5jZXJFbGVtZW50PEJvZHlFbGVtZW50PihcImRhdGEtbW9kYWwtaWRcIiBhcyBuZXZlcik7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZU1vZGFsQm9keVByb3BzID0gZnVuY3Rpb24gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4ge1xyXG4gICAgICAgICAgICBwcm9wcy50YWJJbmRleCA/Pz0gLTE7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VCb2R5UmVmRWxlbWVudFByb3BzKHVzZUJvZHlJZEFzU291cmNlUHJvcHModXNlTW9kYWxJZEFzUmVmZXJlbmNlckVsZW1lbnRQcm9wcyhwcm9wcykpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZU1vZGFsQm9keVByb3BzIH07XHJcbiAgICB9LCBbXSlcclxuXHJcblxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTW9kYWxQcm9wcyxcclxuICAgICAgICB1c2VNb2RhbFRpdGxlLFxyXG4gICAgICAgIHVzZU1vZGFsQm9keSxcclxuICAgICAgICB1c2VNb2RhbEJhY2tkcm9wLFxyXG4gICAgICAgIHVzZU1vZGFsRm9jdXNDb250YWluZXJQcm9wcyxcclxuICAgICAgICBzb2Z0RGlzbWlzczogeyBvbkJhY2tkcm9wQ2xpY2sgfVxyXG4gICAgfTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgZm9yIGhpZGluZyB0aGUgc2Nyb2xsIGJhciBvZiB0aGUgcm9vdCBIVE1MIGVsZW1lbnRcclxuICogd2l0aG91dCBzaGlmdGluZyB0aGUgbGF5b3V0IG9mIHRoZSBwYWdlIG1vcmUgdGhhbiBhZGRpbmcgYSBmb3cgcGl4ZWxzXHJcbiAqIG9mIHBhZGRpbmcgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBuZWNlc3NhcnkuXHJcbiAqIEBwYXJhbSBoaWRlU2Nyb2xsIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhpZGVTY3JvbGwoaGlkZVNjcm9sbDogYm9vbGVhbikge1xyXG4gICAgY29uc3QgW2dldFNjcm9sbGJhcldpZHRoLCBzZXRTY3JvbGxiYXJXaWR0aF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcbiAgICBjb25zdCBbZ2V0U2Nyb2xsYmFySGVpZ2h0LCBzZXRTY3JvbGxiYXJIZWlnaHRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGhpZGVTY3JvbGwpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIGlzIHJlc3VtZWQsIHdlJ2xsIG5lZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgc2Nyb2xsIHBvc2l0aW9uc1xyXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGtlZXAgdGhpcyBpbmZvcm1hdGlvbiBhcm91bmRcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTY3JvbGxUb3AgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNjcm9sbExlZnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcclxuXHJcbiAgICAgICAgICAgIC8vIE1lYXN1cmUgdGhlIHdpZHRoIG9mIHRoZSBwYWdlIChtaW51cyB0aGUgc2Nyb2xsYmFyKVxyXG4gICAgICAgICAgICBjb25zdCB3aWR0aFdpdGhTY3JvbGxCYXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodFdpdGhTY3JvbGxCYXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwbHkgYSBjbGFzcyB0aGF0IGhpZGVzIHRoZSBzY3JvbGxiYXIuXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiZG9jdW1lbnQtc2Nyb2xsLWhpZGRlblwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluIGNhc2UgbXVsdGlwbGUgdGhpbmdzIGFyZSBsb2NraW5nIHNjcm9sbCwga2VlcCB0cmFjayBvZiBob3cgbWFueSBhcmUgZG9pbmcgdGhhdFxyXG4gICAgICAgICAgICAvLyAoanVzdCBhZGQgMSBvbiBlbmFibGUsIHN1YnRyYWN0IDEgb24gZGlzYWJsZSlcclxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gPSAoKyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSB8fCBcIjBcIikgKyAxKS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICAgICAgLy8gTWVhc3VyZSB0aGUgbmV3IHdpZHRoIHdpdGhvdXQgYSBzY3JvbGxiYXIgXHJcbiAgICAgICAgICAgIC8vIHNvIHdlIGNhbiB0YWtlIHRoZSBkaWZmZXJlbmNlIGFzIHRoZSBzY3JvbGxiYXIgd2lkdGguXHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoV2l0aG91dFNjcm9sbEJhciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0V2l0aG91dFNjcm9sbEJhciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgICAgIGxldCBzY3JvbGxiYXJXaWR0aCA9ICh3aWR0aFdpdGhvdXRTY3JvbGxCYXIgLSB3aWR0aFdpdGhTY3JvbGxCYXIpO1xyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsYmFySGVpZ2h0ID0gKGhlaWdodFdpdGhvdXRTY3JvbGxCYXIgLSBoZWlnaHRXaXRoU2Nyb2xsQmFyKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEZhaWxzYWZlIC0tIGlmIHRoaXMgbWVhc3VyaW5nIHRyaWNrIGRvZXMgc29tZXRoaW5nIHVuZXhwZWN0ZWQsIGp1c3QgaWdub3JlIGl0XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxiYXJXaWR0aCA+IDgwKVxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFyV2lkdGggPSAwO1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFySGVpZ2h0ID4gODApXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxiYXJIZWlnaHQgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBvdXIgbWVhc3VyZW1lbnRzIGF2YWlsYWJsZSBhcyBDU1MgcHJvcGVydGllcyBmb3IgZ2VuZXJhbCB1c2VcclxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1yb290LXNjcm9sbGJhci13aWR0aFwiLCBgJHtzY3JvbGxiYXJXaWR0aH1weGApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXJvb3Qtc2Nyb2xsYmFyLWhlaWdodFwiLCBgJHtzY3JvbGxiYXJIZWlnaHR9cHhgKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1yb290LXNjcm9sbHN0b3AtdG9wXCIsIGAke29yaWdpbmFsU2Nyb2xsVG9wfXB4YCk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcm9vdC1zY3JvbGxzdG9wLWxlZnRcIiwgYCR7b3JpZ2luYWxTY3JvbGxMZWZ0fXB4YCk7XHJcblxyXG4gICAgICAgICAgICBzZXRTY3JvbGxiYXJXaWR0aChzY3JvbGxiYXJXaWR0aCk7XHJcbiAgICAgICAgICAgIHNldFNjcm9sbGJhckhlaWdodChzY3JvbGxiYXJIZWlnaHQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFVuZG8gYWxsIHRoZSB0aGluZ3Mgd2UganVzdCBkaWRcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdID0gKCsoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gfHwgXCIwXCIpIC0gMSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSA9PSBcIjBcIikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIHRoZSBsYXN0IHNjcm9sbC1sb2NraW5nIHRoaW5nIHRvIHN0b3AsIHRoZW4gcmVtb3ZlIHRoZSBjbGFzcyB0aGF0IHN0b3BzIHNjcm9sbGluZy5cclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1zY3JvbGwtaGlkZXJzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZG9jdW1lbnQtc2Nyb2xsLWhpZGRlblwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxzbywgcmVzdG9yZSB0aGUgb3JpZ2luYWwgc2Nyb2xsIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBieSBmb3JjaW5nIHRoZSBzY3JvbGwgYmVoYXZpb3IgdG8gbm90IGJlIHNtb290aFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIChpdCdzIGluc3RhbnQgaWYgbm90aGluZyBpcyBzZXQgdG8gc21vb3RoLCBodHRwczovL3d3dy53My5vcmcvVFIvY3Nzb20tdmlldy8jc2Nyb2xsaW5nKSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGxpbmcsIHRoZW4gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBzY3JvbGwgYmVoYXZpb3IgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gKHdoaWNoIHdhcyBwcm9iYWJseSBhbHJlYWR5IGF1dG8gYW55d2F5LCBidXQganVzdCB0byBiZSBzYWZlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2Nyb2xsQmVoYXZpb3IgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gXCJhdXRvXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvKHsgdG9wOiBvcmlnaW5hbFNjcm9sbFRvcCwgbGVmdDogb3JpZ2luYWxTY3JvbGxMZWZ0LCBiZWhhdmlvcjogXCJhdXRvXCIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gb3JpZ2luYWxTY3JvbGxCZWhhdmlvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICB9LCBbaGlkZVNjcm9sbF0pO1xyXG5cclxuICAgIHJldHVybiB7IGdldFNjcm9sbGJhcldpZHRoLCBnZXRTY3JvbGxiYXJIZWlnaHQgfTtcclxufVxyXG5cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGRlYnVnTG9nIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlTW9kYWwsIFVzZU1vZGFsUGFyYW1ldGVycywgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1tb2RhbFwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VEcmF3ZXJSZXR1cm5UeXBlSW5mbyBleHRlbmRzIFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZUluZm8ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VEcmF3ZXJSZXR1cm5UeXBlV2l0aEhvb2tzPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1vZGFsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VEcmF3ZXJSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB1c2VEcmF3ZXJQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNb2RhbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNb2RhbEVsZW1lbnQ+O1xyXG4gICAgdXNlRHJhd2VyVGl0bGU6IFVzZURyYXdlclRpdGxlPFRpdGxlRWxlbWVudD47XHJcbiAgICB1c2VEcmF3ZXJCb2R5OiBVc2VEcmF3ZXJCb2R5PEJvZHlFbGVtZW50PlxyXG4gICAgdXNlRHJhd2VyQmFja2Ryb3A6IFVzZURyYXdlckJhY2tkcm9wPEJhY2tkcm9wRWxlbWVudD47XHJcbiAgICB1c2VEcmF3ZXJGb2N1c0NvbnRhaW5lclByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rm9jdXNDb250YWluZXJFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlRHJhd2VyVGl0bGU8VGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZURyYXdlclRpdGxlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50PjsgfTtcclxuZXhwb3J0IHR5cGUgVXNlRHJhd2VyQm9keTxCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VEcmF3ZXJCb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD47IH07XHJcbmV4cG9ydCB0eXBlIFVzZURyYXdlckJhY2tkcm9wPEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VEcmF3ZXJCYWNrZHJvcFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD47IH07XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VEcmF3ZXJQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTW9kYWxQYXJhbWV0ZXJzPG5ldmVyLCBuZXZlcj4ge1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRHJhd2VyPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBEcmF3ZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBzb2Z0RGlzbWlzczogeyBvcGVuLCBvbkNsb3NlIH0sIGFjdGl2ZUVsZW1lbnQsIG1vZGFsOiB7IGJvZHlJc09ubHlTZW1hbnRpYywgZm9jdXNTZWxmIH0gfTogVXNlRHJhd2VyUGFyYW1ldGVycyk6IFVzZURyYXdlclJldHVyblR5cGVXaXRoSG9va3M8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEcmF3ZXJFbGVtZW50LCBUaXRsZUVsZW1lbnQsIEJvZHlFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQ+IHtcclxuXHJcbiAgICBkZWJ1Z0xvZyhcInVzZURyYXdlclwiKTtcclxuXHJcbiAgICAvLyBUT0RPOiBEcmF3ZXJzIGFyZSBub3QgYWx3YXlzIG1vZGFsLlxyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VNb2RhbEJhY2tkcm9wLFxyXG4gICAgICAgIHVzZU1vZGFsQm9keSxcclxuICAgICAgICB1c2VNb2RhbFByb3BzLFxyXG4gICAgICAgIHVzZU1vZGFsVGl0bGUsXHJcbiAgICAgICAgdXNlTW9kYWxGb2N1c0NvbnRhaW5lclByb3BzLFxyXG4gICAgICAgIHNvZnREaXNtaXNzOiB7IG9uQmFja2Ryb3BDbGljayB9XHJcbiAgICB9ID0gdXNlTW9kYWw8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEcmF3ZXJFbGVtZW50LCBUaXRsZUVsZW1lbnQsIEJvZHlFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQ+KHsgbW9kYWw6IHsgYm9keUlzT25seVNlbWFudGljOiAoYm9keUlzT25seVNlbWFudGljID8/IGZhbHNlKSwgZm9jdXNTZWxmIH0sIHNvZnREaXNtaXNzOiB7IG9uQ2xvc2UsIG9wZW4gfSwgYWN0aXZlRWxlbWVudCB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VEcmF3ZXJCYWNrZHJvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9ID0gdXNlTW9kYWxCYWNrZHJvcCgpO1xyXG4gICAgICAgIHJldHVybiB7IHVzZURyYXdlckJhY2tkcm9wUHJvcHM6IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9O1xyXG4gICAgfSwgW3VzZU1vZGFsQmFja2Ryb3BdKTtcclxuXHJcbiAgICBjb25zdCB1c2VEcmF3ZXJCb2R5ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxCb2R5UHJvcHMgfSA9IHVzZU1vZGFsQm9keSgpO1xyXG4gICAgICAgIHJldHVybiB7IHVzZURyYXdlckJvZHlQcm9wczogdXNlTW9kYWxCb2R5UHJvcHMgfTtcclxuICAgIH0sIFt1c2VNb2RhbEJhY2tkcm9wXSk7XHJcbiAgICBjb25zdCB1c2VEcmF3ZXJQcm9wcyA9IHVzZU1vZGFsUHJvcHM7XHJcblxyXG4gICAgY29uc3QgdXNlRHJhd2VyVGl0bGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VNb2RhbFRpdGxlUHJvcHMgfSA9IHVzZU1vZGFsVGl0bGUoKTtcclxuICAgICAgICByZXR1cm4geyB1c2VEcmF3ZXJUaXRsZVByb3BzOiB1c2VNb2RhbFRpdGxlUHJvcHMgfTtcclxuICAgIH0sIFt1c2VNb2RhbFRpdGxlXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VEcmF3ZXJQcm9wcyxcclxuICAgICAgICB1c2VEcmF3ZXJUaXRsZSxcclxuICAgICAgICB1c2VEcmF3ZXJCb2R5LFxyXG4gICAgICAgIHVzZURyYXdlckJhY2tkcm9wLFxyXG4gICAgICAgIHVzZURyYXdlckZvY3VzQ29udGFpbmVyUHJvcHM6IHVzZU1vZGFsRm9jdXNDb250YWluZXJQcm9wcyxcclxuICAgICAgICBzb2Z0RGlzbWlzczogeyBvbkJhY2tkcm9wQ2xpY2sgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzLCB1c2VSYW5kb21JZCwgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxpc3QtbmF2aWdhdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZGVidWdMb2csIEVsZW1lbnRUb1RhZywgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCwgd2Fybk9uT3ZlcndyaXRlIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlTGFiZWwsIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcclxuXHJcbmV4cG9ydCB0eXBlIExpc3Rib3hTaW5nbGVTZWxlY3RFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0geyBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IG51bWJlciB9IH0gJiBQaWNrPGguSlNYLlRhcmdldGVkRXZlbnQ8RT4sIFwidGFyZ2V0XCIgfCBcImN1cnJlbnRUYXJnZXRcIj47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8bmV2ZXIgfCBcIm9uU2VsZWN0ZWRJbmRleENoYW5nZVwiLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+IHtcclxuICAgIGxpc3Rib3hTaW5nbGU6IHtcclxuICAgICAgICAvL3NlbGVjdGlvbk1vZGU6IFwiZm9jdXNcIiB8IFwiYWN0aXZhdGVcIjtcclxuICAgICAgICBvblNlbGVjdD8oZXZlbnQ6IExpc3Rib3hTaW5nbGVTZWxlY3RFdmVudDxFbGVtZW50Pik6IHZvaWQ7XHJcbiAgICAgICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xyXG4gICAgICAgIHRhZ0xpc3Q6IEVsZW1lbnRUb1RhZzxMaXN0RWxlbWVudD47XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8RSwge30sIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sIFwic3ViSW5mb1wiPiB7XHJcbiAgICBsaXN0Ym94U2luZ2xlSXRlbTogeyBkaXNhYmxlZD86IGJvb2xlYW47IH1cclxuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT47XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IHR5cGUgVXNlTGlzdGJveFNpbmdsZUl0ZW08TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoaW5mbzogVXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzPExpc3RJdGVtRWxlbWVudD4pID0+IFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxMaXN0SXRlbUVsZW1lbnQ+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4ge1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiB7XHJcbiAgICB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RJdGVtRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RJdGVtRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4sIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4ge1xyXG4gICAgdXNlTGlzdGJveFNpbmdsZUl0ZW06IFVzZUxpc3Rib3hTaW5nbGVJdGVtPExpc3RJdGVtRWxlbWVudD47XHJcbiAgICB1c2VMaXN0Ym94U2luZ2xlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD47XHJcbiAgICB1c2VMaXN0Ym94U2luZ2xlTGFiZWw6ICgpID0+IHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcclxuICAgIGxpc3Rib3hTaW5nbGU6IHsgdGFnTGFiZWwsIHRhZ0xpc3QsIG9uU2VsZWN0LCAuLi5fbGJzIH0sXHJcbiAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWRJbmRleCwgLi4uc3MgfSxcclxuICAgIGxpbmVhck5hdmlnYXRpb246IHsgLi4ubG4gfSxcclxuICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmxzIH0sXHJcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4ubWMgfSxcclxuICAgIHJvdmluZ1RhYkluZGV4OiB7IC4uLnJ0aSB9LFxyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyAuLi50biB9LFxyXG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IHsgLi4uY2hmIH1cclxufTogVXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4pOiBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQ+IHtcclxuICAgIGRlYnVnTG9nKFwidXNlTGlzdGJveFNpbmdsZVwiLCBzZWxlY3RlZEluZGV4KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXQsIHVzZUxhYmVsTGFiZWwsIC4uLmxhYmVsUmV0dXJuVHlwZSB9ID0gdXNlTGFiZWw8TGlzdEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIHByZWZpeExhYmVsOiBcImFyaWEtbGlzdGJveC1sYWJlbC1cIixcclxuICAgICAgICAgICAgcHJlZml4SW5wdXQ6IFwiYXJpYS1saXN0Ym94LVwiLFxyXG4gICAgICAgICAgICB0YWdJbnB1dDogdGFnTGlzdCxcclxuICAgICAgICAgICAgdGFnTGFiZWw6IHRhZ0xhYmVsXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgb25TZWxlY3RlZEluZGV4Q2hhbmdlID0gdXNlU3RhYmxlQ2FsbGJhY2soKGV2ZW50OiBFdmVudCwgbmV3SW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIHN0YWJsZU9uU2VsZWN0KGVuaGFuY2VFdmVudDxMaXN0SXRlbUVsZW1lbnQsIEV2ZW50LCB7IHNlbGVjdGVkSW5kZXg6IG51bWJlciB9PihldmVudCwgeyBzZWxlY3RlZEluZGV4OiBuZXdJbmRleCB9KSlcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCwgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcywgLi4ubGlzdFJldHVyblR5cGUgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4oe1xyXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IC4uLmNoZiB9LFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgLi4ubG4gfSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyAuLi5tYyB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XHJcbiAgICAgICAgICAgIC4uLnJ0aVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IC4uLnNzLCBvblNlbGVjdGVkSW5kZXhDaGFuZ2UsIHNlbGVjdGVkSW5kZXggfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0blxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VMYWJlbElucHV0KCk7XHJcbiAgICBjb25zdCBzdGFibGVPblNlbGVjdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uU2VsZWN0ID8/ICgoKSA9PiB7IH0pKTtcclxuXHJcblxyXG4gICAgY29uc3QgdXNlTGlzdGJveFNpbmdsZUl0ZW0gPSB1c2VDYWxsYmFjazxVc2VMaXN0Ym94U2luZ2xlSXRlbTxMaXN0SXRlbUVsZW1lbnQ+PigoeyBsaXN0Ym94U2luZ2xlSXRlbTogeyBkaXNhYmxlZCB9LCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgaGFzRm9jdXMgfSkgPT4ge1xyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlTGlzdGJveFNpbmdsZUl0ZW1cIiwgbWFuYWdlZENoaWxkLmluZGV4KTtcclxuICAgICAgICBjb25zdCB7IHJvdmluZ1RhYkluZGV4OiBydGlfcmV0LCBzaW5nbGVTZWxlY3Rpb246IHNzX3JldCwgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzIH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkKHtcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkLFxyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbixcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXgsXHJcbiAgICAgICAgICAgIGhhc0ZvY3VzLFxyXG4gICAgICAgICAgICBzdWJJbmZvOiB7fVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzLFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX3JldCxcclxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiBzc19yZXRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0SXRlbUVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG5cclxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwib3B0aW9uXCI7XHJcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1zZWxlY3RlZFwiXSA9IChzc19yZXQuc2VsZWN0ZWQgPz8gZmFsc2UpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZClcclxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IFwidHJ1ZVwiO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRdKTtcclxuXHJcblxyXG4gICAgY29uc3QgdXNlTGlzdGJveFNpbmdsZUxhYmVsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZUxhYmVsKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlTGFiZWxMYWJlbFByb3BzIH0gPSB1c2VMYWJlbExhYmVsKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VMYWJlbExhYmVsUHJvcHMocHJvcHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHMgfTtcclxuICAgIH0sIFt1c2VMYWJlbExhYmVsXSk7XHJcblxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZUl0ZW0sXHJcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZVByb3BzLFxyXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCxcclxuICAgICAgICAuLi5saXN0UmV0dXJuVHlwZSxcclxuICAgICAgICAuLi5sYWJlbFJldHVyblR5cGVcclxuICAgIH07XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KSB7XHJcbiAgICAgICAgcHJvcHMucm9sZSA9IFwibGlzdGJveFwiO1xyXG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHVzZUxhYmVsSW5wdXRQcm9wcyhwcm9wcykpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0Ym94R3JvdXA8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEhlYWRpbmdFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oKSB7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQsIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCB9ID0gdXNlUmFuZG9tSWQ8SGVhZGluZ0VsZW1lbnQ+KHsgcmFuZG9tSWQ6IHsgcHJlZml4OiBcImxpc3Rib3gtbXVsdGktZ3JvdXBcIiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHt9IH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50KCk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDxDb250YWluZXJFbGVtZW50PihcImFyaWEtbGFiZWxsZWRieVwiKTtcclxuICAgIGNvbnN0IHVzZUxpc3Rib3hHcm91cEhlYWRpbmdQcm9wcyA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGluZ0VsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGluZ0VsZW1lbnQ+ID0+IHtcclxuICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHMocHJvcHMpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHVzZUxpc3Rib3hHcm91cENvbnRhaW5lclByb3BzID0gKHsgcm9sZSwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJFbGVtZW50PiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyh7XHJcbiAgICAgICAgICAgIHJvbGU6IHdhcm5Pbk92ZXJ3cml0ZShcInVzZUxpc3Rib3hNdWx0aUdyb3VwUHJvcHNcIiwgXCJyb2xlXCIsIHJvbGUsIFwiZ3JvdXBcIiksXHJcbiAgICAgICAgICAgIC4uLnByb3BzXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUxpc3Rib3hHcm91cENvbnRhaW5lclByb3BzLFxyXG4gICAgICAgIHVzZUxpc3Rib3hHcm91cEhlYWRpbmdQcm9wcyxcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBPblRhYmJhYmxlSW5kZXhDaGFuZ2UsIHJldHVybkZhbHNlLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVByZXNzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZGVidWdMb2csIEVsZW1lbnRUb1RhZywgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VMYWJlbCB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xyXG5cclxuZXhwb3J0IHR5cGUgTGlzdGJveE11bHRpU2VsZWN0RXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IHsgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZDogYm9vbGVhbiB9IH0gJiBQaWNrPGguSlNYLlRhcmdldGVkRXZlbnQ8RT4sIFwidGFyZ2V0XCIgfCBcImN1cnJlbnRUYXJnZXRcIj47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+IHtcclxuICAgIGxpc3Rib3hNdWx0aToge1xyXG4gICAgICAgIHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PjtcclxuICAgICAgICB0YWdMaXN0OiBFbGVtZW50VG9UYWc8TGlzdEVsZW1lbnQ+XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpSXRlbVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxJbmZvLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LCBcInN1YkluZm9cIj4ge1xyXG4gICAgbGlzdGJveE11bHRpSXRlbToge1xyXG4gICAgICAgIGRpc2FibGVkPzogYm9vbGVhbjtcclxuICAgICAgICBzZWxlY3RlZDogYm9vbGVhbjtcclxuICAgICAgICBvblNlbGVjdGVkQ2hhbmdlPyhldmVudDogKExpc3Rib3hNdWx0aVNlbGVjdEV2ZW50PEU+KSk6IHZvaWQ7XHJcbiAgICB9O1xyXG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxFPjtcclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgdHlwZSBVc2VMaXN0Ym94TXVsdGlJdGVtPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChpbmZvOiBVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVyczxFPikgPT4gVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVXaXRoSG9va3M8RT47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlSW5mbzxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88RT4ge1xyXG4gICAgbGlzdGJveE11bHRpSXRlbToge1xyXG4gICAgICAgIHRhYmJhYmxlOiBib29sZWFuO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVXaXRoSG9va3M8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVJbmZvPEU+IHtcclxuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCwgSW5mbywgbmV2ZXI+IHtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiB7XHJcbiAgICB1c2VMaXN0Ym94TXVsdGlJdGVtOiBVc2VMaXN0Ym94TXVsdGlJdGVtPExpc3RJdGVtRWxlbWVudD47XHJcbiAgICB1c2VMaXN0Ym94TXVsdGlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PjtcclxuICAgIHVzZUxpc3Rib3hNdWx0aUxhYmVsOiAoKSA9PiB7IHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfVxyXG59XHJcblxyXG5cclxuaW50ZXJmYWNlIEluZm8ge1xyXG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW47XHJcbiAgICBvblNlbGVjdD8oZXZlbnQ6IChMaXN0Ym94TXVsdGlTZWxlY3RFdmVudDxFbGVtZW50PikpOiB2b2lkO1xyXG59XHJcblxyXG5cclxuLypleHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aVJldHVyblR5cGU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4sIFwidXNlTGlzdE5hdmlnYXRpb25DaGlsZFwiIHwgXCJ1c2VMaXN0TmF2aWdhdGlvblByb3BzXCI+IHtcclxuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW06IFVzZUxpc3Rib3hNdWx0aUl0ZW08TGlzdEl0ZW1FbGVtZW50PjtcclxuICAgIHVzZUxpc3Rib3hNdWx0aVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+O1xyXG4gICAgdXNlTGlzdGJveE11bHRpTGFiZWw6ICgpID0+IHsgdXNlTGlzdGJveE11bHRpTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+OyB9XHJcbn0qL1xyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0Ym94TXVsdGk8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XHJcbiAgICBsaXN0Ym94TXVsdGk6IHsgdGFnTGFiZWwsIHRhZ0xpc3QgfSxcclxuICAgIGxpbmVhck5hdmlnYXRpb246IHsgLi4ubG4gfSxcclxuICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmxzIH0sXHJcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4ubWMgfSxcclxuICAgIHJvdmluZ1RhYkluZGV4OiB7IG9uVGFiYmFibGVJbmRleENoYW5nZSwgLi4ucnRpIH0sXHJcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IC4uLnRuIH1cclxufTogVXNlTGlzdGJveE11bHRpUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50Pik6IFVzZUxpc3Rib3hNdWx0aVJldHVyblR5cGVXaXRoSG9va3M8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50PiB7XHJcblxyXG4gICAgZGVidWdMb2coXCJ1c2VMaXN0Ym94TXVsdGlcIik7XHJcblxyXG4gICAgLy9jb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGdldEZvY3VzZWRJbm5lciB9ID0gdXNlSGFzRm9jdXM8TGlzdEVsZW1lbnQ+KHt9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXQsIHVzZUxhYmVsTGFiZWwgfSA9IHVzZUxhYmVsPExpc3RFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcclxuICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICBwcmVmaXhMYWJlbDogXCJhcmlhLWxpc3Rib3gtbGFiZWwtXCIsXHJcbiAgICAgICAgICAgIHByZWZpeElucHV0OiBcImFyaWEtbGlzdGJveC1cIixcclxuICAgICAgICAgICAgdGFnTGFiZWw6IHRhZ0xhYmVsLFxyXG4gICAgICAgICAgICB0YWdJbnB1dDogdGFnTGlzdFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGxpc3RSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb248TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgSW5mbywgbmV2ZXI+KHtcclxuXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyAuLi5sbiB9LFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmxzIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IC4uLm1jIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcclxuICAgICAgICAgICAgLi4ucnRpLFxyXG4gICAgICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uVGFiYmFibGVJbmRleENoYW5nZT4oKGkpID0+IHtcclxuICAgICAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZT8uKGkpO1xyXG4gICAgICAgICAgICAgICAgLyppZiAoc2VsZWN0aW9uTW9kZSA9PSBcImZvY3VzXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoY2hpbGRyZW4uZ2V0QXQoaSEpPy5zdWJJbmZvLmdldEVsZW1lbnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldClcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Q/Lih7IHRhcmdldCwgY3VycmVudFRhcmdldDogdGFyZ2V0LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IGkhIH0gfSk7XHJcbiAgICAgICAgICAgICAgICB9Ki9cclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0blxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBzZXRUYWJiYWJsZUluZGV4IH1cclxuICAgIH0gPSBsaXN0UmV0dXJuVHlwZVxyXG5cclxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VMYWJlbElucHV0KCk7XHJcblxyXG4gICAgY29uc3QgW2dldFNoaWZ0SGVsZCwgc2V0U2hpZnRIZWxkXSA9IHVzZVBhc3NpdmVTdGF0ZShudWxsLCByZXR1cm5GYWxzZSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZUxpc3Rib3hNdWx0aUl0ZW0gPSB1c2VDYWxsYmFjazxVc2VMaXN0Ym94TXVsdGlJdGVtPExpc3RJdGVtRWxlbWVudD4+KCh7IGxpc3Rib3hNdWx0aUl0ZW06IHsgc2VsZWN0ZWQsIGRpc2FibGVkLCBvblNlbGVjdGVkQ2hhbmdlIH0sIG1hbmFnZWRDaGlsZCwgbGlzdE5hdmlnYXRpb246IGxzLCByb3ZpbmdUYWJJbmRleDogcnRpLCBoYXNGb2N1cyB9KSA9PiB7XHJcbiAgICAgICAgZGVidWdMb2coXCJ1c2VMaXN0Ym94TXVsdGlJdGVtXCIsIG1hbmFnZWRDaGlsZC5pbmRleCwgc2VsZWN0ZWQpO1xyXG4gICAgICAgIHR5cGUgRSA9IExpc3RJdGVtRWxlbWVudDtcclxuICAgICAgICBjb25zdCBnZXRTZWxlY3RlZCA9IHVzZVN0YWJsZUdldHRlcihzZWxlY3RlZCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8RT4oe30pO1xyXG4gICAgICAgIGNvbnN0IHN0YWJsZU9uU2VsZWN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sob25TZWxlY3RlZENoYW5nZSA/PyAoKCkgPT4geyB9KSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLCByb3ZpbmdUYWJJbmRleDogcnRpMl9yZXQgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoeyBsaXN0TmF2aWdhdGlvbjogbHMsIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXg6IHJ0aSwgc3ViSW5mbzogeyBzZWxlY3RlZCwgb25TZWxlY3Q6IHN0YWJsZU9uU2VsZWN0IH0gfSk7XHJcblxyXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGdldFNoaWZ0SGVsZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFibGVPblNlbGVjdD8uKHsgdGFyZ2V0OiBlbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBlbGVtZW50LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiB0cnVlIH0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbcnRpMl9yZXQudGFiYmFibGVdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTGlzdGJveE11bHRpSXRlbVByb3BzLCBsaXN0Ym94TXVsdGlJdGVtOiB7IGdldFNlbGVjdGVkLCB0YWJiYWJsZTogcnRpMl9yZXQudGFiYmFibGUgfSwgcm92aW5nVGFiSW5kZXg6IHJ0aTJfcmV0IH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZVByZXNzUHJvcHMgPSB1c2VQcmVzczxFPih7XHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrU3luYzogZGlzYWJsZWQgPyBudWxsIDogKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG1hbmFnZWRDaGlsZC5pbmRleCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyAuLi5lLCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiAhZ2V0U2VsZWN0ZWQoKSB9IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH0sIFxyXG4gICAgICAgICAgICAgICAgZXhjbHVkZToge30sXHJcbiAgICAgICAgICAgICAgICBoYXNGb2N1c1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcIm9wdGlvblwiO1xyXG4gICAgICAgICAgICAvL3Byb3BzW1wiYXJpYS1zZXRzaXplXCJdID0gKGNoaWxkQ291bnQpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIC8vcHJvcHNbXCJhcmlhLXBvc2luc2V0XCJdID0gKGluZm8uaW5kZXggKyAxKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBwcm9wc1tcImFyaWEtc2VsZWN0ZWRcIl0gPSAocnRpMl9yZXQudGFiYmFibGUgPz8gZmFsc2UpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZClcclxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IFwidHJ1ZVwiO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlUHJlc3NQcm9wcyhwcm9wcykpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRdKTtcclxuXHJcbiAgICBjb25zdCB1c2VMaXN0Ym94TXVsdGlMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUxhYmVsKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+IHtcclxuICAgICAgICAgICAgY29uc3QgeyB1c2VMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUxhYmVsTGFiZWwoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZUxhYmVsTGFiZWxQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VMaXN0Ym94TXVsdGlMYWJlbFByb3BzIH07XHJcbiAgICB9LCBbdXNlTGFiZWxMYWJlbF0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTGlzdGJveE11bHRpSXRlbSxcclxuICAgICAgICB1c2VMaXN0Ym94TXVsdGlQcm9wcyxcclxuICAgICAgICB1c2VMaXN0Ym94TXVsdGlMYWJlbCxcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogbGlzdFJldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IGxpc3RSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlTGlzdGJveE11bHRpUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PiB7XHJcbiAgICAgICAgcHJvcHMucm9sZSA9IFwibGlzdGJveFwiO1xyXG4gICAgICAgIHByb3BzW1wiYXJpYS1tdWx0aXNlbGVjdGFibGVcIl0gPSBcInRydWVcIjtcclxuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyh1c2VMYWJlbElucHV0UHJvcHModXNlTWVyZ2VkUHJvcHM8TGlzdEVsZW1lbnQ+KHsgb25LZXlEb3duLCBvbktleVVwLCBvbmZvY3Vzb3V0OiBvbkZvY3VzT3V0IH0sIHByb3BzKSkpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGU6IEtleWJvYXJkRXZlbnQpIHsgaWYgKGUua2V5ID09IFwiU2hpZnRcIikgc2V0U2hpZnRIZWxkKHRydWUpOyB9XHJcbiAgICBmdW5jdGlvbiBvbktleVVwKGU6IEtleWJvYXJkRXZlbnQpIHsgaWYgKGUua2V5ID09IFwiU2hpZnRcIikgc2V0U2hpZnRIZWxkKGZhbHNlKTsgfVxyXG4gICAgZnVuY3Rpb24gb25Gb2N1c091dChfOiBGb2N1c0V2ZW50KSB7IHNldFNoaWZ0SGVsZChmYWxzZSk7IH1cclxuXHJcbn0iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIHVzZU1lcmdlZFByb3BzLCB1c2VQcmVzcywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgcmV0dXJuRmFsc2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBkZWJ1Z0xvZywgd2Fybk9uT3ZlcndyaXRlIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU29mdERpc21pc3MsIFVzZVNvZnREaXNtaXNzUGFyYW1ldGVycywgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1tb2RhbFwiO1xyXG5cclxuaW50ZXJmYWNlIE1TUCB7XHJcbiAgICAvKipcclxuICAgICAqIFdoYXQgcm9sZSB0aGUgc3VyZmFjZSBmdWxmaWxscy5cclxuICAgICAqIFxyXG4gICAgICogR2VuZXJhbCBtZW51cyBzaG91bGQgdXNlIFwibWVudVwiLiBcImRpYWxvZ1wiIGNhbiBiZSB1c2VkIGZvciBnZW5lcmljIHBvcC11cCB0aGluZ3MuXHJcbiAgICAgKi9cclxuICAgIHJvbGU6IFwiZGlhbG9nXCIgfCBcIm1lbnVcIiB8IFwidHJlZVwiIHwgXCJncmlkXCIgfCBcImxpc3Rib3hcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gdGhpcyBtZW51IHN1cmZhY2UgaXMgb3BlbmVkLCBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiBpdCBtdXN0IGJlIGZvY3VzZWQuXHJcbiAgICAgKiBcclxuICAgICAqIFRoaXMgY29udHJvbHMgd2hhdCBpcyBmb2N1c2VkIChlLmcuIHRoZSBmaXJzdCBtZW51IGl0ZW0sIHRoZSB3aG9sZSBzdXJmYWNlIGl0c2VsZiwgZXRjLilcclxuICAgICAqL1xyXG4gICAgc2VuZEZvY3VzVG9NZW51KCk6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIE1lbnVTdXJmYWNlT21pdHMgPSBrZXlvZiBNU1A7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVTdXJmYWNlUGFyYW1ldGVyczxfUyBleHRlbmRzIEVsZW1lbnQsIF9CIGV4dGVuZHMgRWxlbWVudCwgTVNPIGV4dGVuZHMgTWVudVN1cmZhY2VPbWl0cz4gZXh0ZW5kcyBVc2VTb2Z0RGlzbWlzc1BhcmFtZXRlcnM8XCJnZXRFbGVtZW50c1wiPiB7XHJcbiAgICBtZW51U3VyZmFjZTogT21pdDxNU1AsIE1TTz47XHJcbiAgICAvL2hhc0ZvY3VzQnV0dG9uOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8Qj47XHJcbiAgICAvL2hhc0ZvY3VzU3VyZmFjZTogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPFM+O1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVBhcmFtZXRlcnM8UyBleHRlbmRzIEVsZW1lbnQsIEIgZXh0ZW5kcyBFbGVtZW50LCBNU08gZXh0ZW5kcyBNZW51U3VyZmFjZU9taXRzPiBleHRlbmRzIFVzZU1lbnVTdXJmYWNlUGFyYW1ldGVyczxTLCBCLCBNU08gfCBcInJvbGVcIiB8IFwic2VuZEZvY3VzVG9NZW51XCI+LCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7XHJcbiAgICBtZW51OiB7XHJcbiAgICAgICAgb25PcGVuKCk6IHZvaWQ7XHJcblxyXG4gICAgICAgIC8vIENvcnJlc3BvbmRzIHRvIHdoYXQgYXJyb3cga2V5IGNhbiBvcGVuIHRoaXMgbWVudVxyXG4gICAgICAgIG9wZW5EaXJlY3Rpb246IFwiZG93blwiIHwgXCJ1cFwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIgfCBudWxsO1xyXG4gICAgfVxyXG4gICAgbWVudUJ1dHRvbkhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8Qj47XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51QnV0dG9uUGFyYW1ldGVycyBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+IHsgfVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtUGFyYW1ldGVycyBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8e30sIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sIFwic3ViSW5mb1wiPiB7IH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVN1cmZhY2VSZXR1cm5UeXBlSW5mbzxfTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgbWVudVN1cmZhY2U6IHtcclxuICAgICAgICAvKmdldEJ1dHRvbkZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgICAgICBnZXRCdXR0b25Gb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcclxuICAgICAgICBnZXRCdXR0b25MYXN0Rm9jdXNlZCgpOiBib29sZWFuO1xyXG4gICAgICAgIGdldEJ1dHRvbkxhc3RGb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcclxuICAgICAgICBnZXRCdXR0b25FbGVtZW50OiAoKSA9PiBNZW51QnV0dG9uRWxlbWVudCB8IG51bGw7XHJcbiAgICAgICAgZ2V0U3VyZmFjZUZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgICAgICBnZXRTdXJmYWNlRm9jdXNlZElubmVyKCk6IGJvb2xlYW47XHJcbiAgICAgICAgZ2V0U3VyZmFjZUxhc3RGb2N1c2VkKCk6IGJvb2xlYW47XHJcbiAgICAgICAgZ2V0U3VyZmFjZUxhc3RGb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcclxuICAgICAgICBnZXRTdXJmYWNlRWxlbWVudDogKCkgPT4gTWVudVBhcmVudEVsZW1lbnQgfCBudWxsO1xyXG4gICAgICAgIGdldEFjdGl2ZUVsZW1lbnQ6ICgpID0+IEVsZW1lbnQgfCBudWxsO1xyXG4gICAgICAgIGdldExhc3RBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50O1xyXG4gICAgICAgIGdldFdpbmRvd0ZvY3VzZWQ6ICgpID0+IGJvb2xlYW47Ki9cclxuICAgIH1cclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVSZXR1cm5UeXBlSW5mbzxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTWVudVN1cmZhY2VSZXR1cm5UeXBlSW5mbzxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50PiwgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUJ1dHRvblJldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPG5ldmVyPiB7IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51SXRlbVJldHVyblR5cGVJbmZvPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPE1lbnVJdGVtRWxlbWVudD4geyB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVTdXJmYWNlUmV0dXJuVHlwZVdpdGhIb29rczxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VNZW51U3VyZmFjZVJldHVyblR5cGVJbmZvPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+IHtcclxuICAgIHVzZU1lbnVTdXJmYWNlU2VudGluZWw6IDxFIGV4dGVuZHMgRWxlbWVudD4oKSA9PiB7IHVzZU1lbnVTZW50aW5lbFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+OyB9O1xyXG4gICAgdXNlTWVudVN1cmZhY2VQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51U3VyZmFjZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51U3VyZmFjZUVsZW1lbnQ+O1xyXG4gICAgdXNlTWVudVN1cmZhY2VDaGlsZFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVQYXJlbnRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVBhcmVudEVsZW1lbnQ+OyAgLy8gTk9UIGEgbWVudSBpdGVtISBUaGlzIGlzIHRoZSBtZW51LCBkaWFsb2csIHBvcHVwLCB3aGF0ZXZlciBhY3R1YWxseSBnZXRzIHRoZSByb2xlLCBhcyBvcHBvc2VkIHRvIHRoZSBzdXJmYWNlIHRoYXQgbGlzdGVucyB0byBtb3VzZSBhbmQga2V5Ym9hcmQgZXZlbnRzXHJcbiAgICB1c2VNZW51U3VyZmFjZUJ1dHRvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PjtcclxuXHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51UmV0dXJuVHlwZVdpdGhIb29rczxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VNZW51UmV0dXJuVHlwZUluZm88TWVudVN1cmZhY2VFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudD4ge1xyXG4gICAgdXNlTWVudVNlbnRpbmVsOiA8RSBleHRlbmRzIEVsZW1lbnQ+KCkgPT4geyB1c2VNZW51U2VudGluZWxQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjsgfTtcclxuICAgIHVzZU1lbnVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVQYXJlbnRFbGVtZW50PjtcclxuICAgIHVzZU1lbnVTdXJmYWNlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVN1cmZhY2VFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVN1cmZhY2VFbGVtZW50PjtcclxuICAgIHVzZU1lbnVCdXR0b25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51QnV0dG9uRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PjtcclxuICAgIHVzZU1lbnVJdGVtOiBVc2VNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQ+O1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUJ1dHRvblJldHVyblR5cGVXaXRoSG9va3MgZXh0ZW5kcyBVc2VNZW51QnV0dG9uUmV0dXJuVHlwZUluZm8geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUl0ZW1SZXR1cm5UeXBlV2l0aEhvb2tzPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+IHsgfVxyXG5cclxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50PiB7fVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51SXRlbVJldHVyblR5cGVXaXRoSG9va3M8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VNZW51SXRlbVJldHVyblR5cGVJbmZvPE1lbnVJdGVtRWxlbWVudD4ge1xyXG4gICAgdXNlTWVudUl0ZW1Qcm9wczogVXNlTWVudUl0ZW1Qcm9wczxNZW51SXRlbUVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VNZW51SXRlbVByb3BzPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51SXRlbUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51SXRlbUVsZW1lbnQ+O1xyXG5cclxuZXhwb3J0IHR5cGUgVXNlTWVudUl0ZW08TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlTWVudUl0ZW1QYXJhbWV0ZXJzKSA9PiBVc2VNZW51SXRlbVJldHVyblR5cGVXaXRoSG9va3M8TWVudUl0ZW1FbGVtZW50PjtcclxuXHJcbi8vZXhwb3J0IGludGVyZmFjZSBVc2VNZW51Q2hpbGRJbmZvQmFzZTxLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPiB7fVxyXG5cclxuLy9leHBvcnQgdHlwZSBVc2VNZW51Q2hpbGRQYXJhbWV0ZXJzPEkgZXh0ZW5kcyBVc2VNZW51Q2hpbGRJbmZvPiA9IEk7XHJcblxyXG4vKipcclxuICogQSBtZW51IGlzIGEgcG9wdXAgY29udHJvbCB0aGF0IGNvbnRhaW5zIGEgbGlzdCBvZiBtZW51IGl0ZW1zLCBhbmQgdGhhdCdzIGl0LlxyXG4gKiBJdCBoYXMgdmVyeSB3ZWxsLWRlZmluZWQgbG9naWMgZm9yIG1hbmFnaW5nIHRob3NlIGl0ZW1zIGFzIHRoZSBtZW51J3Mgc3RhdGUgY2hhbmdlcy5cclxuICogXHJcbiAqIEEgTWVudUJhc2UgaXMganVzdCB0aGUgXCJwb3B1cFwiIHBhcnQgd2l0aG91dCB0aGUgXCJsaXN0IG9mIG1lbnUgaXRlbXNcIiBwYXJ0LiBJdCBjYW5cclxuICogKHJlYWxseSwgbXVzdCkgaGF2ZSBpbnRlcmFjdGl2ZSBjb250cm9scywgYnV0IHRoZXNlIGNvbnRyb2xzIGFyZSBhbGxvd2VkIHRvIGJlIG1vcmVcclxuICogZnJlZS1mb3JtLiBUaGlzIG1lYW5zIHRoYXQsIGxpa2UgYSBkaWFsb2csIHlvdSBtdXN0IHRlbGwgdGhpcyBob29rXHJcbiAqIHdoZXJlIHdpdGhpbiB0aGUgcG9wdXAgdG8gc2VuZCBmb2N1cyB3aGVuIG9wZW5lZCAoZm9yIGEgbWVudSBpdCdzIGp1c3QgdGhlIGZpcnN0XHJcbiAqIG1lbnUgaXRlbSwgYnV0IHdpdGggY3VzdG9tIGNvbnRlbnQgeW91J2xsIG5lZWQgdG8gcHJvdmlkZSB0aGlzKS5cclxuICogXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVudVN1cmZhY2U8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgc29mdERpc21pc3MsIG1lbnVTdXJmYWNlOiB7IHNlbmRGb2N1c1RvTWVudSwgcm9sZSB9LCBhY3RpdmVFbGVtZW50IH06IFVzZU1lbnVTdXJmYWNlUGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBuZXZlcj4pOiBVc2VNZW51U3VyZmFjZVJldHVyblR5cGVXaXRoSG9va3M8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+IHtcclxuICAgIGRlYnVnTG9nKFwidXNlTWVudVN1cmZhY2VcIik7XHJcbiAgICAvL2NvbnN0IHNlbmRGb2N1c1dpdGhpbk1lbnUgPSB1c2VTdGFibGVDYWxsYmFjayhzZW5kRm9jdXNUb01lbnUpO1xyXG4gICAgLy9jb25zdCBbZm9jdXNUcmFwQWN0aXZlLCBzZXRGb2N1c1RyYXBBY3RpdmVdID0gdXNlU3RhdGU8bnVsbCB8IGJvb2xlYW4+KG51bGwpO1xyXG4gICAgY29uc3QgeyBvcGVuLCBvbkNsb3NlOiB1c2VyT25DbG9zZSB9ID0gc29mdERpc21pc3M7XHJcbiAgICBjb25zdCBvbkNsb3NlID0gdXNlU3RhYmxlQ2FsbGJhY2s8dHlwZW9mIHVzZXJPbkNsb3NlPigocmVhc29uKSA9PiB7XHJcbiAgICAgICAgaWYgKHJlYXNvbiAhPSBcImxvc3QtZm9jdXNcIikge1xyXG4gICAgICAgICAgICBjb25zdCBvcGVuZXIgPSAoZ2V0T3BlbmVyRWxlbWVudCgpIGFzIEhUTUxFbGVtZW50IHwgbnVsbCk7XHJcbiAgICAgICAgICAgIGlmIChvcGVuZXIgJiYgXCJmb2N1c1wiIGluIG9wZW5lcilcclxuICAgICAgICAgICAgICAgIG9wZW5lci5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1c2VyT25DbG9zZShyZWFzb24pO1xyXG4gICAgfSlcclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1lbnVTdXJmYWNlXCIsIG9uQ2xvc2UsIHJvbGUsIHNlbmRGb2N1c1RvTWVudSk7XHJcbiAgICBjb25zdCBnZXRJc09wZW4gPSB1c2VTdGFibGVHZXR0ZXIob3Blbik7XHJcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IHVzZVJlZjxJbnRlcnNlY3Rpb25PYnNlcnZlcj4obnVsbCEpO1xyXG4gICAgY29uc3QgW2dldFN1cmZhY2VGdWxseVZpc2libGUsIHNldFN1cmZhY2VGdWxseVZpc2libGVdID0gdXNlUGFzc2l2ZVN0YXRlKG51bGwsIHJldHVybkZhbHNlKTtcclxuICAgIGludGVyc2VjdGlvbk9ic2VydmVyLmN1cnJlbnQgPz89IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcywgX29ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICAgIHNldFN1cmZhY2VGdWxseVZpc2libGUoZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPj0gMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgeyByb290OiBudWxsLCB0aHJlc2hvbGQ6IFswLCAxXSB9KTtcclxuXHJcbiAgICBjb25zdCBbLCBzZXRPcGVuZXJFbGVtZW50LCBnZXRPcGVuZXJFbGVtZW50XSA9IHVzZVN0YXRlPE1lbnVCdXR0b25FbGVtZW50IHwgbnVsbD4obnVsbCk7XHJcblxyXG4gICAgLy9jb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHM6IHVzZU1lbnVCYXNlSGFzRm9jdXNQcm9wcywgLi4uc3VyZmFjZUhhc0ZvY3VzIH0gPSB1c2VIYXNGb2N1czxNZW51U3VyZmFjZUVsZW1lbnQ+KHsgLi4uaGFzRm9jdXNTdXJmYWNlIH0pO1xyXG4gICAgLy9jb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHM6IHVzZUJ1dHRvbkhhc0ZvY3VzUHJvcHMsIC4uLmJ1dHRvbkhhc0ZvY3VzIH0gPSB1c2VIYXNGb2N1czxNZW51QnV0dG9uRWxlbWVudD4oeyAuLi5oYXNGb2N1c0J1dHRvbiB9KTtcclxuXHJcbiAgICAvL2NvbnN0IHsgZ2V0TGFzdEZvY3VzZWRJbm5lcjogZ2V0TWVudUJhc2VMYXN0Rm9jdXNlZElubmVyIH0gPSBzdXJmYWNlSGFzRm9jdXM7XHJcblxyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkPE1lbnVQYXJlbnRFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLW1lbnUtXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7fSB9KTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHMgfSA9IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCgpO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgfSA9IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ8TWVudUJ1dHRvbkVsZW1lbnQ+KFwiYXJpYS1jb250cm9sc1wiIGFzIG5ldmVyKTtcclxuXHJcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldEJ1dHRvbkVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlQnV0dG9uUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PE1lbnVCdXR0b25FbGVtZW50Pih7IG9uRWxlbWVudENoYW5nZTogc2V0T3BlbmVyRWxlbWVudCB9KTtcclxuXHJcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldE1lbnVFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZU1lbnVCYXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PE1lbnVTdXJmYWNlRWxlbWVudD4oe30pO1xyXG4gICAgY29uc3QgeyB1c2VTb2Z0RGlzbWlzc1Byb3BzLCAuLi5zb2Z0RGlzbWlzc1JldHVybiB9ID0gdXNlU29mdERpc21pc3M8YW55Pih7XHJcbiAgICAgICAgc29mdERpc21pc3M6IHtcclxuICAgICAgICAgICAgLi4uc29mdERpc21pc3MsXHJcbiAgICAgICAgICAgIGdldEVsZW1lbnRzOiAoKSA9PiAoW2dldEJ1dHRvbkVsZW1lbnQoKSwgZ2V0TWVudUVsZW1lbnQoKV0pLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aXZlRWxlbWVudFxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZU1lbnVTdXJmYWNlUHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51U3VyZmFjZUVsZW1lbnQ+ID0+IHtcclxuICAgICAgICBmdW5jdGlvbiBvbktleURvd24oZTogS2V5Ym9hcmRFdmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBvcGVuID0gZ2V0SXNPcGVuKCk7XHJcbiAgICAgICAgICAgIGlmIChlLmtleSA9PSBcIkVzY2FwZVwiICYmIG9wZW4pIHtcclxuICAgICAgICAgICAgICAgIG9uQ2xvc2UoXCJlc2NhcGVcIik7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVzZVNvZnREaXNtaXNzUHJvcHMoKHVzZU1lbnVCYXNlUmVmRWxlbWVudFByb3BzKCh1c2VNZXJnZWRQcm9wczxNZW51U3VyZmFjZUVsZW1lbnQ+KHsgb25LZXlEb3duIH0sIChwcm9wcykpKSkpKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgdXNlTWVudVN1cmZhY2VCdXR0b25Qcm9wcyA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUJ1dHRvbkVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUJ1dHRvbkVsZW1lbnQ+ID0+IHtcclxuICAgICAgICBwcm9wc1tcImFyaWEtZXhwYW5kZWRcIl0gPSB3YXJuT25PdmVyd3JpdGUoXCJ1c2VNZW51U3VyZmFjZUJ1dHRvblByb3BzXCIsIFwiYXJpYS1leHBhbmRlZFwiLCBvcGVuLCBvcGVuLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHByb3BzW1wiYXJpYS1oYXNwb3B1cFwiXSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZU1lbnVTdXJmYWNlQnV0dG9uUHJvcHNcIiwgXCJhcmlhLWhhc3BvcHVwXCIsIHJvbGUsIHJvbGUpO1xyXG4gICAgICAgIHJldHVybiB1c2VCdXR0b25SZWZFbGVtZW50UHJvcHMoKHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyhwcm9wcykpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcblxyXG4gICAgICAgIGlmIChvcGVuID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHNlbmRGb2N1c1RvTWVudT8uKCk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFnZXRTdXJmYWNlRnVsbHlWaXNpYmxlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBnZXRNZW51RWxlbWVudCgpPy5zY3JvbGxJbnRvVmlldygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtvcGVuXSk7XHJcblxyXG4gICAgZnVuY3Rpb24gdXNlTWVudVN1cmZhY2VDaGlsZFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD4ge1xyXG4gICAgICAgIHByb3BzLnJvbGUgPSByb2xlO1xyXG4gICAgICAgIHJldHVybiB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyhwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VNZW51U3VyZmFjZUNoaWxkUHJvcHMsXHJcbiAgICAgICAgdXNlTWVudVN1cmZhY2VTZW50aW5lbDogdXNlQ2FsbGJhY2soPEUgZXh0ZW5kcyBFbGVtZW50PigpID0+IHtcclxuICAgICAgICAgICAgZGVidWdMb2coXCJ1c2VNZW51U3VyZmFjZVNlbnRpbmVsXCIpO1xyXG4gICAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgICAgICB1c2VTZW50aW5lbFByb3BzOiB1c2VNZW51U2VudGluZWxQcm9wcyxcclxuICAgICAgICAgICAgICAgIC4uLnJlc3RcclxuICAgICAgICAgICAgfSA9IHVzZUZvY3VzU2VudGluZWw8RT4oe1xyXG4gICAgICAgICAgICAgICAgZm9jdXNTZW50aW5lbDoge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZW46IG9wZW4gPT09IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gb25DbG9zZShcImVzY2FwZVwiKSxcclxuICAgICAgICAgICAgICAgICAgICBzZW5kRm9jdXNUb01lbnVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHVzZU1lbnVTZW50aW5lbFByb3BzLCAuLi5yZXN0IH07XHJcbiAgICAgICAgfSwgW29wZW4sIG9uQ2xvc2VdKSxcclxuICAgICAgICB1c2VNZW51U3VyZmFjZVByb3BzLFxyXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlQnV0dG9uUHJvcHMsXHJcbiAgICAgICAgbWVudVN1cmZhY2U6IHtcclxuICAgICAgICAgICAgLypnZXRBY3RpdmVFbGVtZW50OiBidXR0b25IYXNGb2N1cy5nZXRBY3RpdmVFbGVtZW50LFxyXG4gICAgICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudDogYnV0dG9uSGFzRm9jdXMuZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsXHJcbiAgICAgICAgICAgIGdldEJ1dHRvbkVsZW1lbnQ6IGJ1dHRvbkhhc0ZvY3VzLmdldEVsZW1lbnQsXHJcbiAgICAgICAgICAgIGdldEJ1dHRvbkZvY3VzZWQ6IGJ1dHRvbkhhc0ZvY3VzLmdldEZvY3VzZWQsXHJcbiAgICAgICAgICAgIGdldEJ1dHRvbkZvY3VzZWRJbm5lcjogYnV0dG9uSGFzRm9jdXMuZ2V0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgICAgICBnZXRCdXR0b25MYXN0Rm9jdXNlZDogYnV0dG9uSGFzRm9jdXMuZ2V0TGFzdEZvY3VzZWQsXHJcbiAgICAgICAgICAgIGdldEJ1dHRvbkxhc3RGb2N1c2VkSW5uZXI6IGJ1dHRvbkhhc0ZvY3VzLmdldExhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgICAgIGdldFN1cmZhY2VFbGVtZW50OiBzdXJmYWNlSGFzRm9jdXMuZ2V0RWxlbWVudCxcclxuICAgICAgICAgICAgZ2V0U3VyZmFjZUZvY3VzZWQ6IHN1cmZhY2VIYXNGb2N1cy5nZXRGb2N1c2VkLFxyXG4gICAgICAgICAgICBnZXRTdXJmYWNlRm9jdXNlZElubmVyOiBzdXJmYWNlSGFzRm9jdXMuZ2V0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgICAgICBnZXRTdXJmYWNlTGFzdEZvY3VzZWQ6IHN1cmZhY2VIYXNGb2N1cy5nZXRMYXN0Rm9jdXNlZCxcclxuICAgICAgICAgICAgZ2V0U3VyZmFjZUxhc3RGb2N1c2VkSW5uZXI6IHN1cmZhY2VIYXNGb2N1cy5nZXRMYXN0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgICAgICBnZXRXaW5kb3dGb2N1c2VkOiBidXR0b25IYXNGb2N1cy5nZXRXaW5kb3dGb2N1c2VkLCovXHJcbiAgICAgICAgfSxcclxuICAgICAgICAuLi5zb2Z0RGlzbWlzc1JldHVyblxyXG5cclxuICAgICAgICAvL2dldE1lbnVCYXNlTGFzdEZvY3VzZWRJbm5lcixcclxuICAgICAgICAvL2dldE1lbnVCYXNlQnV0dG9uTGFzdEZvY3VzZWRJbm5lcixcclxuICAgICAgICAvL29wZW4sXHJcbiAgICAgICAgLy9vbk9wZW4sXHJcbiAgICAgICAgLy9vbkNsb3NlXHJcbiAgICB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBGU1AgZXh0ZW5kcyBNU1Age1xyXG4gICAgb3BlbjogYm9vbGVhbjtcclxuICAgIG9uQ2xvc2UoKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgRm9jdXNTZW50aW5lbE9taXRzID0ga2V5b2YgRlNQO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1NlbnRpbmVsUGFyYW1ldGVycyB7XHJcbiAgICBmb2N1c1NlbnRpbmVsOiB7IHNlbmRGb2N1c1RvTWVudTogTVNQW1wic2VuZEZvY3VzVG9NZW51XCJdOyBvcGVuOiBib29sZWFuOyBvbkNsb3NlKCk6IHZvaWQ7IH07XHJcbn1cclxuXHJcblxyXG4vLyBBIGZvY3VzIHNlbnRpbmFsIGlzIGEgaGlkZGVuIGJ1dCBmb2N1c2FibGUgZWxlbWVudCB0aGF0IGNvbWVzIGF0IHRoZSBzdGFydCBvciBlbmQgXHJcbi8vIG9mIHRoZSBvdXQtb2YtcGxhY2UtZm9jdXNhYmxlIGNvbXBvbmVudCB0aGF0LCB3aGVuIGFjdGl2YXRlZCBvciBmb2N1c2VkIG92ZXIsIGNsb3NlcyB0aGUgY29tcG9uZW50XHJcbi8vIChpZiBmb2N1c2VkIHdpdGhpbiAxMDBtcyBvZiB0aGUgb3BlbiBwcm9wIGNoYW5naW5nLCBpbnN0ZWFkIG9mXHJcbi8vIGNsb3NpbmcsIGZvY3VzaW5nIHRoZSBzZW50aW5lbCBpbW1lZGlhdGVseSBhc2tzIGl0IHRvIGZvY3VzIGl0c2VsZikuXHJcbi8vIFRoaXMgZXhpc3RzIGZvciB0aGluZ3MgbGlrZSBtZW51cyB3aGljaCBjYW4gaGF2ZSBmb2N1cyBidXQgYWxzbyBuZWVkIGEgd2F5IHRvIHJldHVyblxyXG4vLyB0byB3aGF0ZXZlciBvdXQtb2YtcGxhY2UgcGFyZW50IHRoZXkgY2FtZSBmcm9tIHdoZW4gbmF0dXJhbGx5IHRhYmJlZCBvdXQgb2YgKGFzIG9wcG9zZWRcclxuLy8gdG8gZGlhbG9ncyB3aGljaCBsb29wIGJhY2sgYXJvdW5kIHdoZW4gdGFiYmVkIG91dCBvZikuIFdoaWxlIG1vdXNlIHVzZXJzIGNhbiBjbGljayBvdXQgb2YgYSBtZW51XHJcbi8vIGFuZCBrZXlib2FyZCB1c2VycyBjYW4gZXNjYXBlIHRvIGNsb3NlIGEgbWVudSwgc2NyZWVuIHJlYWRlcnMgYW5kIG90aGVyIGlucHV0IG1ldGhvZHMgXHJcbi8vIHRoYXQgZG9uJ3QgdXNlIHRob3NlIHR3byB3b3VsZCBiZWNvbWUgc3R1Y2suXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VGb2N1c1NlbnRpbmVsPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGZvY3VzU2VudGluZWw6IHsgb3Blbiwgb25DbG9zZSwgc2VuZEZvY3VzVG9NZW51IH0gfTogVXNlRm9jdXNTZW50aW5lbFBhcmFtZXRlcnMpIHtcclxuICAgIGRlYnVnTG9nKFwidXNlRm9jdXNTZW50aW5lbFwiKTtcclxuICAgIGNvbnN0IGdldFNlbmRGb2N1c1dpdGhpbk1lbnUgPSB1c2VTdGFibGVHZXR0ZXIoc2VuZEZvY3VzVG9NZW51KTtcclxuICAgIGNvbnN0IHN0YWJsZU9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjayhvbkNsb3NlKTtcclxuXHJcbiAgICBjb25zdCBbZmlyc3RTZW50aW5lbElzQWN0aXZlLCBzZXRGaXJzdFNlbnRpbmVsSXNBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgdXNlVGltZW91dCh7IGNhbGxiYWNrOiAoKSA9PiB7IHNldEZpcnN0U2VudGluZWxJc0FjdGl2ZShvcGVuKTsgfSwgdGltZW91dDogMTAwLCB0cmlnZ2VySW5kZXg6IGAke29wZW59LSR7Zmlyc3RTZW50aW5lbElzQWN0aXZlfWAgfSk7XHJcblxyXG5cclxuICAgIGNvbnN0IG9uRm9jdXMgPSBmaXJzdFNlbnRpbmVsSXNBY3RpdmUgPyAoKCkgPT4gc3RhYmxlT25DbG9zZSgpKSA6ICgoKSA9PiBnZXRTZW5kRm9jdXNXaXRoaW5NZW51KCk/LigpKTtcclxuICAgIGNvbnN0IG9uQ2xpY2sgPSAoKSA9PiBzdGFibGVPbkNsb3NlKCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VTZW50aW5lbFByb3BzOiBmdW5jdGlvbiAoeyB0YWJJbmRleCwgLi4ucCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHsgb25Gb2N1cywgb25DbGljaywgdGFiSW5kZXg6IHdhcm5Pbk92ZXJ3cml0ZShcInVzZUZvY3VzU2VudGluZWxcIiwgXCJ0YWJJbmRleFwiLCB0YWJJbmRleCwgMCkgfSwgcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVudTxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtZW51QnV0dG9uSGFzRm9jdXMsIGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIG1lbnVTdXJmYWNlLCByb3ZpbmdUYWJJbmRleCwgc29mdERpc21pc3MsIHR5cGVhaGVhZE5hdmlnYXRpb24sIG1lbnUsIGFjdGl2ZUVsZW1lbnQgfTogVXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCwgbmV2ZXI+KTogVXNlTWVudVJldHVyblR5cGVXaXRoSG9va3M8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudD4ge1xyXG5cclxuICAgIGRlYnVnTG9nKFwidXNlTWVudVwiKTtcclxuICAgIGNvbnN0IHsgb25PcGVuIH0gPSBtZW51O1xyXG4gICAgY29uc3QgeyBvcGVuLCBvbkNsb3NlIH0gPSBzb2Z0RGlzbWlzcztcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIC4uLnVzZUxpc3ROYXZSZXR1cm5cclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCB7fSwgc3RyaW5nPih7XHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbixcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbixcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXgsXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSB9ID0gdXNlTGlzdE5hdlJldHVybjtcclxuXHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIC8qdXNlTWVudVNlbnRpbmVsLFxyXG4gICAgICAgIHVzZU1lbnVCYXNlQnV0dG9uUHJvcHMsXHJcbiAgICAgICAgdXNlTWVudUJhc2VQcm9wcyxcclxuICAgICAgICBvcGVuLFxyXG4gICAgICAgIG9uT3BlbixcclxuICAgICAgICBvbkNsb3NlOiBfb25DbG9zZSwqL1xyXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlQnV0dG9uUHJvcHMsXHJcbiAgICAgICAgdXNlTWVudVN1cmZhY2VQcm9wcyxcclxuICAgICAgICB1c2VNZW51U3VyZmFjZVNlbnRpbmVsLFxyXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlQ2hpbGRQcm9wcyxcclxuICAgICAgICAuLi5tZW51UmVzdFxyXG4gICAgfSA9IHVzZU1lbnVTdXJmYWNlPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50Pih7XHJcbiAgICAgICAgbWVudVN1cmZhY2U6IHtcclxuICAgICAgICAgICAgLi4ubWVudVN1cmZhY2UsXHJcbiAgICAgICAgICAgIHJvbGU6IFwibWVudVwiLFxyXG4gICAgICAgICAgICBzZW5kRm9jdXNUb01lbnU6IHVzZUNhbGxiYWNrKCgpID0+IGNoaWxkcmVuLmdldEF0KDApPy5zdWJJbmZvLmZvY3VzU2VsZigpLCBbXSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNvZnREaXNtaXNzLFxyXG4gICAgICAgIC8vaGFzRm9jdXNCdXR0b24sXHJcbiAgICAgICAgLy9oYXNGb2N1c1N1cmZhY2UsXHJcbiAgICAgICAgYWN0aXZlRWxlbWVudFxyXG4gICAgICAgIC8vc2VuZEZvY3VzV2l0aGluTWVudTogZm9jdXNNZW51ID8/ICgoKSA9PiB7IH0pXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VNZW51QnV0dG9uUHJvcHMgPSAoKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHVzZVByZXNzUHJvcHMgPSB1c2VQcmVzczxNZW51QnV0dG9uRWxlbWVudD4oe1xyXG4gICAgICAgICAgICBvbkNsaWNrU3luYzogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wZW4pXHJcbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZT8uKFwiZXNjYXBlXCIpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG9uT3Blbj8uKCk7XHJcbiAgICAgICAgICAgIH0sIFxyXG4gICAgICAgICAgICBleGNsdWRlOiB7fSxcclxuICAgICAgICAgICAgaGFzRm9jdXM6IG1lbnVCdXR0b25IYXNGb2N1c1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHByb3BzID0gdXNlTWVudVN1cmZhY2VCdXR0b25Qcm9wcyhwKTtcclxuICAgICAgICByZXR1cm4gdXNlUHJlc3NQcm9wcyhwcm9wcyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VNZW51SXRlbSA9IHVzZUNhbGxiYWNrPFVzZU1lbnVJdGVtPE1lbnVJdGVtRWxlbWVudD4+KCh7IGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4IH0pID0+IHtcclxuICAgICAgICBkZWJ1Z0xvZyhcInVzZU1lbnVJdGVtXCIsIG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcblxyXG4gICAgICAgIHR5cGUgRSA9IE1lbnVJdGVtRWxlbWVudDtcclxuXHJcbiAgICAgICAgY29uc3QgeyB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsIC4uLmxpc3ROYXZSZXQgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgc3ViSW5mbzoge30gfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZU1lbnVJdGVtUHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+Pih7IC4uLnByb3BzIH06IFApIHtcclxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwibWVudWl0ZW1cIjtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHt9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMocHJvcHMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZU1lbnVJdGVtUHJvcHMsIC4uLmxpc3ROYXZSZXQgfTtcclxuICAgIH0sIFtdKTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlTWVudVByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD4pIHtcclxuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyh1c2VNZW51U3VyZmFjZUNoaWxkUHJvcHMocHJvcHMpKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VNZW51UHJvcHMsXHJcbiAgICAgICAgdXNlTWVudVN1cmZhY2VQcm9wcyxcclxuXHJcbiAgICAgICAgdXNlTWVudUJ1dHRvblByb3BzLFxyXG5cclxuICAgICAgICB1c2VNZW51SXRlbSxcclxuICAgICAgICB1c2VNZW51U2VudGluZWw6IHVzZU1lbnVTdXJmYWNlU2VudGluZWwsXHJcbiAgICAgICAgLy91c2VNZW51U3VibWVudUl0ZW0sXHJcbiAgICAgICAgLi4udXNlTGlzdE5hdlJldHVybixcclxuICAgICAgICAuLi5tZW51UmVzdFxyXG5cclxuICAgICAgICAvKmZvY3VzTWVudSxcclxuXHJcbiAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcclxuICAgICAgICBpbnZhbGlkVHlwZWFoZWFkLFxyXG5cclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sKi9cclxuXHJcblxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IGdlbmVyYXRlUmFuZG9tSWQsIHJldHVyblRydWUsIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIHVzZU1lcmdlZFByb3BzLCB1c2VQcmVzcywgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgQ2hpbGRGbGFnT3BlcmF0aW9ucywgT25DaGlsZHJlbk1vdW50Q2hhbmdlLCB1c2VDaGlsZHJlbkZsYWcsIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcclxuaW1wb3J0IHsgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxpc3QtbmF2aWdhdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZUxhYmVsIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XHJcbmltcG9ydCB7IGRlYnVnTG9nLCBFbmhhbmNlZEV2ZW50LCBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsLCB3YXJuT25PdmVyd3JpdGUgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnMsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1oYXMtZm9jdXNcIjtcclxuXHJcblxyXG5leHBvcnQgdHlwZSBUYWJzQ2hhbmdlRXZlbnQ8RSBleHRlbmRzIEVsZW1lbnQ+ID0geyBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IG51bWJlciB9IH0gJiBQaWNrPGguSlNYLlRhcmdldGVkRXZlbnQ8RT4sIFwidGFyZ2V0XCIgfCBcImN1cnJlbnRUYXJnZXRcIj47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYnNQYXJhbWV0ZXJzIHtcclxuICAgIHRhYlBhbmVsczogVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxudW1iZXIsIG5ldmVyPjtcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxFLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiwgXCJzdWJJbmZvXCI+IHtcclxuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiUGFuZWxQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxudW1iZXIsIHt9LCBcInZpc2libGVcIiwgXCJzdWJJbmZvXCI+IHsgfVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudD4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiUmV0dXJuVHlwZVdpdGhIb29rczxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUYWJSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PiB7XHJcbiAgICB1c2VUYWJQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJMYWJlbFBhcmFtZXRlcnMgeyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudCBleHRlbmRzIEV2ZW50VGFyZ2V0PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxuZXZlciB8IFwib25TZWxlY3RlZEluZGV4Q2hhbmdlXCIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4ge1xyXG4gICAgdGFiczogeyBvblNlbGVjdGVkSW5kZXhDaGFuZ2UoZTogRW5oYW5jZWRFdmVudDxUYWJFbGVtZW50LCBFdmVudCwgeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfT4pOiB2b2lkOyB9O1xyXG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyc1tcImNoaWxkcmVuSGF2ZUZvY3VzXCJdO1xyXG5cclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYkxpc3RSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgdGFiTGlzdDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50LCBUYWJJbmZvLCBuZXZlcj47XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJMaXN0UmV0dXJuVHlwZVdpdGhIb29rczxUYWJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFiTGlzdFJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+IHtcclxuICAgIHVzZVRhYkxpc3RQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJDb250YWluZXJFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiQ29udGFpbmVyRWxlbWVudD47XHJcbiAgICB1c2VUYWI6ICh7IGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4IH06IFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4pID0+IFVzZVRhYlJldHVyblR5cGVXaXRoSG9va3M8VGFiRWxlbWVudD5cclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB0YWJQYW5lbDogeyB2aXNpYmxlOiBib29sZWFuOyBnZXRWaXNpYmxlOiAoKSA9PiBib29sZWFuOyB9O1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiUGFuZWxSZXR1cm5UeXBlV2l0aEhvb2tzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB1c2VUYWJQYW5lbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYkxpc3RMYWJlbFJldHVyblR5cGVJbmZvIHsgfVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYkxhYmVsUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRhYkxpc3RMYWJlbFJldHVyblR5cGVJbmZvIHtcclxuICAgIHVzZVRhYkxpc3RMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFic1JldHVyblR5cGVJbmZvIHtcclxuICAgIHRhYlBhbmVsczogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88bnVtYmVyLCBUYWJQYW5lbEluZm8sIG5ldmVyPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJzUmV0dXJuVHlwZVdpdGhIb29rczxUYWJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFic1JldHVyblR5cGVJbmZvIHtcclxuICAgIHVzZVRhYkxpc3Q6IFVzZVRhYkxpc3Q8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudD47XHJcbiAgICB1c2VUYWJQYW5lbDogVXNlVGFiUGFuZWw8UGFuZWxFbGVtZW50PjtcclxuICAgIHVzZVRhYkxpc3RMYWJlbDogVXNlVGFiTGlzdExhYmVsPExhYmVsRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZVRhYjxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50PikgPT4gVXNlVGFiUmV0dXJuVHlwZVdpdGhIb29rczxUYWJFbGVtZW50PjtcclxuZXhwb3J0IHR5cGUgVXNlVGFiTGlzdDxUYWJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+KSA9PiBVc2VUYWJMaXN0UmV0dXJuVHlwZVdpdGhIb29rczxUYWJDb250YWluZXJFbGVtZW50LCBUYWJFbGVtZW50PjtcclxuZXhwb3J0IHR5cGUgVXNlVGFiUGFuZWw8UGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlVGFiUGFuZWxQYXJhbWV0ZXJzKSA9PiBVc2VUYWJQYW5lbFJldHVyblR5cGVXaXRoSG9va3M8UGFuZWxFbGVtZW50PjtcclxuZXhwb3J0IHR5cGUgVXNlVGFiTGlzdExhYmVsPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZVRhYkxhYmVsUGFyYW1ldGVycykgPT4gVXNlVGFiTGFiZWxSZXR1cm5UeXBlV2l0aEhvb2tzPExhYmVsRWxlbWVudD47XHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VUYWJzPFRhYkxpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFiUGFuZWxzOiB7IG1hbmFnZWRDaGlsZHJlbjogeyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG9jbWMsIC4uLnRhYlBhbmVsc01hbmFnZWRDaGlsZHJlbiB9IH0gfTogVXNlVGFic1BhcmFtZXRlcnMpOiBVc2VUYWJzUmV0dXJuVHlwZVdpdGhIb29rczxUYWJMaXN0RWxlbWVudCwgVGFiRWxlbWVudCwgUGFuZWxFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcclxuICAgIGNvbnN0IHsgXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCwgXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyBcclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxUYWJMaXN0RWxlbWVudCwgVGFiRWxlbWVudCwgVGFiSW5mbywgbmV2ZXI+KHsgXHJcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXM6IHt9LCBcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSwgXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHt9LCBcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHt9LCBcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge30sIFxyXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjoge30sIFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHt9XHJcbiAgICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXNlVGFiID0gdXNlQ2FsbGJhY2soKCkgPT4ge30sIFtdKTtcclxuICAgIGNvbnN0IHVzZVRhYlBhbmVsID0gdXNlQ2FsbGJhY2soKCkgPT4ge30pO1xyXG4gICAgZnVuY3Rpb24gdXNlVGFiTGlzdFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJMaXN0RWxlbWVudD4pIHsgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMocHJvcHMpOyB9XHJcbiAgICBmdW5jdGlvbiB1c2VUYWJMYWJlbFByb3BzKCkge31cclxuXHJcbiAgICByZXR1cm4ge1xyXG5cclxuICAgIH1cclxuICAgIFxyXG59Ki9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VUYWJzPFRhYkxpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFiUGFuZWxzOiB7IG1hbmFnZWRDaGlsZHJlbjogeyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG9jbWMsIC4uLnRhYlBhbmVsc01hbmFnZWRDaGlsZHJlbiB9IH0gfTogVXNlVGFic1BhcmFtZXRlcnMpOiBVc2VUYWJzUmV0dXJuVHlwZVdpdGhIb29rczxUYWJMaXN0RWxlbWVudCwgVGFiRWxlbWVudCwgUGFuZWxFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcclxuXHJcbiAgICBkZWJ1Z0xvZyhcInVzZVRhYnNcIik7XHJcblxyXG5cclxuICAgIGNvbnN0IGJhc2VJZCA9IGdlbmVyYXRlUmFuZG9tSWQoXCJhcmlhLXRhYnMtXCIpO1xyXG4gICAgLy9jb25zdCBnZXRUYWJMaXN0SWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiBiYXNlSWQgKyBcIi10YWItbGlzdFwiOyB9LCBbXSk7XHJcbiAgICBjb25zdCBnZXRUYWJJZCA9IHVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyKSA9PiB7IHJldHVybiBiYXNlSWQgKyBcIi10YWItXCIgKyBpbmRleDsgfSwgW10pO1xyXG4gICAgY29uc3QgZ2V0UGFuZWxJZCA9IHVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyKSA9PiB7IHJldHVybiBiYXNlSWQgKyBcIi1wYW5lbC1cIiArIGluZGV4OyB9LCBbXSk7XHJcblxyXG4gICAgLy8gVXNlZCBmb3IgdGhlIHBhbmVscywgbm90IHRoZSB0YWJzIGluIHRoZSB0YWJsaXN0LlxyXG4gICAgLy8gVGhvc2UgYXJlIGluIHVzZVRhYkxpc3QgaXRzZWxmLlxyXG4gICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGQsIC4uLm1hbmFnZWRDaGlsZHJlblJldCB9ID0gdXNlTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVGFiUGFuZWxJbmZvLCBcInZpc2libGVcIj4oeyBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4udGFiUGFuZWxzTWFuYWdlZENoaWxkcmVuLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobSwgdSkgPT4geyBvY21jPy4obSwgdSk7IHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7IH0pIH0gfSk7XHJcbiAgICBjb25zdCB7IGNoYW5nZUluZGV4OiBjaGFuZ2VWaXNpYmxlUGFuZWwsIGdldEN1cnJlbnRJbmRleDogZ2V0VmlzaWJsZUluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdCB9ID0gdXNlQ2hpbGRyZW5GbGFnKHsgY2hpbGRyZW46IG1hbmFnZWRDaGlsZHJlblJldC5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4sIGNsb3Nlc3RGaXQ6IGZhbHNlLCBpbml0aWFsSW5kZXg6IG51bGwsIGtleTogXCJ2aXNpYmxlXCIgfSk7XHJcblxyXG4gICAgLy9jb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQsIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCB9ID0gdXNlUmFuZG9tSWQoeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS10YWJzLVwiIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dCwgdXNlTGFiZWxMYWJlbCB9ID0gdXNlTGFiZWw8VGFiTGlzdEVsZW1lbnQsIExhYmVsRWxlbWVudD4oeyBsYWJlbDogeyBwcmVmaXhJbnB1dDogXCJcIiwgcHJlZml4TGFiZWw6IFwiXCIsIHRhZ0lucHV0OiBcImRpdlwiIGFzIGFueSwgdGFnTGFiZWw6IFwiZGl2XCIgYXMgYW55IH0gfSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZVRhYkxpc3RMYWJlbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZUxhYmVsTGFiZWxQcm9wcyB9ID0gdXNlTGFiZWxMYWJlbCgpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVRhYkxpc3RMYWJlbFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSB7IHJldHVybiB1c2VMYWJlbExhYmVsUHJvcHMocHJvcHMpOyB9XHJcbiAgICAgICAgcmV0dXJuIHsgdXNlVGFiTGlzdExhYmVsUHJvcHMgfTtcclxuICAgIH0sIFt1c2VMYWJlbExhYmVsXSk7XHJcblxyXG4gICAgY29uc3QgdXNlVGFiTGlzdCA9IHVzZUNhbGxiYWNrPFVzZVRhYkxpc3Q8VGFiTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQ+PigoeyBjaGlsZHJlbkhhdmVGb2N1cywgdGFiczogeyBvblNlbGVjdGVkSW5kZXhDaGFuZ2UgfSwgbGluZWFyTmF2aWdhdGlvbiwgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZHJlbjogdGFiTGlzdE1hbmFnZWRDaGlsZHJlbiwgcm92aW5nVGFiSW5kZXgsIHNpbmdsZVNlbGVjdGlvbiwgdHlwZWFoZWFkTmF2aWdhdGlvbiB9KSA9PiB7XHJcbiAgICAgICAgZGVidWdMb2coXCJ1c2VUYWJMaXN0XCIpO1xyXG4gICAgICAgIGNvbnN0IHN0YWJsZU9uU2VsZWN0ZWRJbmRleENoYW5nZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uU2VsZWN0ZWRJbmRleENoYW5nZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcclxuICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcclxuICAgICAgICAgICAgLi4ubGlzdE5hdlJldDFcclxuICAgICAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248VGFiTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkluZm8sIG5ldmVyPih7XHJcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHRhYkxpc3RNYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHtcclxuICAgICAgICAgICAgICAgIC4uLnNpbmdsZVNlbGVjdGlvbixcclxuICAgICAgICAgICAgICAgIG9uU2VsZWN0ZWRJbmRleENoYW5nZTogdXNlQ2FsbGJhY2soKGV2ZW50OiBFdmVudCwgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0ZWRJbmRleENoYW5nZT8uKGVuaGFuY2VFdmVudDxUYWJFbGVtZW50LCBFdmVudCwgeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfT4oZXZlbnQsIHsgc2VsZWN0ZWRJbmRleDogaW5kZXggfSkpXHJcbiAgICAgICAgICAgICAgICB9LCBbXSlcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbixcclxuICAgICAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgY2hhbmdlVmlzaWJsZVBhbmVsKHNpbmdsZVNlbGVjdGlvbi5zZWxlY3RlZEluZGV4KTtcclxuICAgICAgICB9LCBbc2luZ2xlU2VsZWN0aW9uLnNlbGVjdGVkSW5kZXhdKTtcclxuXHJcbiAgICAgICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHMgfSA9IHVzZUxhYmVsSW5wdXQoKVxyXG5cclxuICAgICAgICBjb25zdCB1c2VUYWIgPSB1c2VDYWxsYmFjazxVc2VUYWI8VGFiRWxlbWVudD4+KCh7IGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4LCBoYXNGb2N1cyB9OiBVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+KTogVXNlVGFiUmV0dXJuVHlwZVdpdGhIb29rczxUYWJFbGVtZW50PiA9PiB7XHJcbiAgICAgICAgICAgIGRlYnVnTG9nKFwidXNlVGFiXCIsIG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzLCAuLi5saXN0TmF2UmV0MiB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCh7IGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4LCBzdWJJbmZvOiB7fSwgaGFzRm9jdXMgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkIH0sIHJvdmluZ1RhYkluZGV4OiB7IHRhYmJhYmxlIH0gfSA9IGxpc3ROYXZSZXQyO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdXNlVGFiUHJvcHMgPSAoeyByb2xlLCBcImFyaWEtY29udHJvbHNcIjogYXJpYUNvbnRyb2xzLCBcImFyaWEtc2VsZWN0ZWRcIjogYXJpYVNlbGVjdGVkLCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJFbGVtZW50PikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZWxJZCA9IGdldFBhbmVsSWQobWFuYWdlZENoaWxkLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYklkID0gZ2V0VGFiSWQobWFuYWdlZENoaWxkLmluZGV4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VQcmVzc1Byb3BzID0gdXNlUHJlc3M8VGFiRWxlbWVudD4oe1xyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2tTeW5jOiAoZSkgPT4geyBzdGFibGVPblNlbGVjdGVkSW5kZXhDaGFuZ2UoZW5oYW5jZUV2ZW50KGUsIHsgc2VsZWN0ZWRJbmRleDogbWFuYWdlZENoaWxkLmluZGV4IH0pKSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGU6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc0ZvY3VzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzKHVzZU1lcmdlZFByb3BzKHtcclxuICAgICAgICAgICAgICAgICAgICByb2xlOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJcIiwgXCJyb2xlXCIsIHJvbGUsIFwidGFiXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJcIiwgXCJhcmlhQ29udHJvbHNcIiwgYXJpYUNvbnRyb2xzLCBwYW5lbElkKSxcclxuICAgICAgICAgICAgICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFiXCIsIFwiYXJpYVNlbGVjdGVkXCIsIGFyaWFTZWxlY3RlZCwgc2VsZWN0ZWQgPyBcInRydWVcIiA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXRhYmJhYmxlXCI6IHRhYmJhYmxlLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRhYklkXHJcbiAgICAgICAgICAgICAgICB9IGFzIHt9LCB1c2VQcmVzc1Byb3BzKHByb3BzKSkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdXNlVGFiUHJvcHMsXHJcbiAgICAgICAgICAgICAgICAuLi5saXN0TmF2UmV0MlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW3VzZUxhYmVsSW5wdXQsIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRdKTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlVGFiTGlzdFByb3BzID0gKHsgcm9sZSwgXCJhcmlhLW9yaWVudGF0aW9uXCI6IGFyaWFPcmllbnRhdGlvbiwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiTGlzdEVsZW1lbnQ+KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHVzZUxhYmVsSW5wdXRQcm9wcyh1c2VNZXJnZWRQcm9wcyh7XHJcbiAgICAgICAgICAgICAgICByb2xlOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJMaXN0XCIsIFwicm9sZVwiLCByb2xlLCBcInRhYmxpc3RcIiksXHJcbiAgICAgICAgICAgICAgICBcImFyaWEtb3JpZW50YXRpb25cIjogYXJpYU9yaWVudGF0aW9uID8/IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICB9IGFzIHt9LFxyXG4gICAgICAgICAgICAgICAgcHJvcHMpKSlcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0YWJMaXN0OiBsaXN0TmF2UmV0MSxcclxuICAgICAgICAgICAgdXNlVGFiTGlzdFByb3BzLFxyXG4gICAgICAgICAgICB1c2VUYWJcclxuICAgICAgICB9XHJcbiAgICB9LCBbdXNlTGFiZWxJbnB1dF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZVRhYlBhbmVsID0gdXNlQ2FsbGJhY2soKHsgbWFuYWdlZENoaWxkOiB7IGZsYWdzLCAuLi5tYW5hZ2VkQ2hpbGQgfSB9OiBVc2VUYWJQYW5lbFBhcmFtZXRlcnMpID0+IHtcclxuICAgICAgICBkZWJ1Z0xvZyhcInVzZVRhYlBhbmVsXCIsIG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcbiAgICAgICAgLy9jb25zdCBbY29ycmVzcG9uZGluZ1RhYklkLCBzZXRDb3JyZXNwb25kaW5nVGFiSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgICAgICAgY29uc3QgW2lzVmlzaWJsZSwgc2V0SXNWaXNpYmxlLCBnZXRJc1Zpc2libGVdID0gdXNlU3RhdGUoZ2V0VmlzaWJsZUluZGV4KCkgPT0gbWFuYWdlZENoaWxkLmluZGV4KTtcclxuICAgICAgICBjb25zdCB2aXNpYmxlUmVmID0gdXNlUmVmPENoaWxkRmxhZ09wZXJhdGlvbnM+KHsgZ2V0OiBnZXRJc1Zpc2libGUsIHNldDogc2V0SXNWaXNpYmxlLCBpc1ZhbGlkOiByZXR1cm5UcnVlIH0pO1xyXG4gICAgICAgIHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyAuLi5tYW5hZ2VkQ2hpbGQsIGZsYWdzOiB7IHZpc2libGU6IHZpc2libGVSZWYuY3VycmVudCwgLi4uZmxhZ3MgfSwgc3ViSW5mbzoge30gfSB9KTtcclxuICAgICAgICBjb25zdCBwYW5lbElkID0gZ2V0UGFuZWxJZChtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IHRhYklkID0gZ2V0VGFiSWQobWFuYWdlZENoaWxkLmluZGV4KTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlVGFiUGFuZWxQcm9wcyA9ICh7IHJvbGUsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZEJ5LCBpZCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFuZWxFbGVtZW50PikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoe1xyXG4gICAgICAgICAgICAgICAgcm9sZTogd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFiUGFuZWxQcm9wc1wiLCBcInJvbGVcIiwgcm9sZSwgXCJ0YWJwYW5lbFwiKSxcclxuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHdhcm5Pbk92ZXJ3cml0ZShcInVzZVRhYlBhbmVsUHJvcHNcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIiwgYXJpYUxhYmVsbGVkQnksIHRhYklkKSxcclxuICAgICAgICAgICAgICAgIGlkOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJQYW5lbFByb3BzXCIsIFwiaWRcIiwgaWQsIHBhbmVsSWQpXHJcbiAgICAgICAgICAgIH0gYXMge30sIHByb3BzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZVRhYlBhbmVsUHJvcHMsXHJcbiAgICAgICAgICAgIHRhYlBhbmVsOiB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBpc1Zpc2libGUsXHJcbiAgICAgICAgICAgICAgICBnZXRWaXNpYmxlOiBnZXRJc1Zpc2libGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVRhYkxpc3RMYWJlbCxcclxuICAgICAgICB1c2VUYWJMaXN0LFxyXG4gICAgICAgIHVzZVRhYlBhbmVsLFxyXG4gICAgICAgIHRhYlBhbmVsczogbWFuYWdlZENoaWxkcmVuUmV0XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5pbnRlcmZhY2UgVGFiUGFuZWxJbmZvIHtcclxuICAgIC8vc2V0Q29ycmVzcG9uZGluZ1RhYklkKHRhYklkOiBzdHJpbmcpOiB2b2lkO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVGFiSW5mbyB7XHJcbiAgICAvL3NldENvcnJlc3BvbmRpbmdQYW5lbElkKHRhYklkOiBzdHJpbmcpOiB2b2lkO1xyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUdsb2JhbEhhbmRsZXIsIHVzZUhhc0ZvY3VzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVJhbmRvbUlkLCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUsIHVzZVRpbWVvdXQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBkZWJ1Z0xvZyB9IGZyb20gXCIuL3Byb3BzXCI7XHJcblxyXG5leHBvcnQgdHlwZSBVc2VUb29sdGlwVHJpZ2dlcjxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IHsgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxUcmlnZ2VyVHlwZT4gfSkgPT4geyB1c2VUb29sdGlwVHJpZ2dlclByb3BzOiAoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPiB9O1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvb2x0aXBQYXJhbWV0ZXJzIHsgbW91c2VvdmVyRGVsYXk/OiBudW1iZXIsIG1vdXNlb3V0VG9sZXJhbmNlRGVsYXk/OiBudW1iZXIsIGZvY3VzRGVsYXk/OiBudW1iZXIgfVxyXG5leHBvcnQgdHlwZSBVc2VUb29sdGlwPFRyaWdnZXJUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQgfCBTVkdFbGVtZW50LCBUb29sdGlwVHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZVRvb2x0aXBQYXJhbWV0ZXJzKSA9PiBVc2VUb29sdGlwUmV0dXJuVHlwZVdpdGhIb29rczxUcmlnZ2VyVHlwZSwgVG9vbHRpcFR5cGU+O1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvb2x0aXBSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICBpc09wZW46IGJvb2xlYW47XHJcbiAgICBnZXRJc09wZW46ICgpID0+IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbHRpcFJldHVyblR5cGVXaXRoSG9va3M8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50LCBQb3B1cFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRvb2x0aXBSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB1c2VUb29sdGlwUG9wdXA6IChhcmdzOiB7IGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8UG9wdXBUeXBlPiB9KSA9PiB7XHJcbiAgICAgICAgdXNlVG9vbHRpcFBvcHVwUHJvcHM6ICh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwVHlwZT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwVHlwZT47XHJcbiAgICB9O1xyXG4gICAgdXNlVG9vbHRpcFRyaWdnZXI6IFVzZVRvb2x0aXBUcmlnZ2VyPFRyaWdnZXJUeXBlPjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRvb2x0aXA8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50LCBQb3B1cFR5cGUgZXh0ZW5kcyBFbGVtZW50Pih7IG1vdXNlb3ZlckRlbGF5LCBtb3VzZW91dFRvbGVyYW5jZURlbGF5LCBmb2N1c0RlbGF5IH06IFVzZVRvb2x0aXBQYXJhbWV0ZXJzKTogVXNlVG9vbHRpcFJldHVyblR5cGVXaXRoSG9va3M8VHJpZ2dlclR5cGUsIFBvcHVwVHlwZT4ge1xyXG4gICAgZGVidWdMb2coXCJ1c2VUb29sdGlwXCIpO1xyXG5cclxuICAgIG1vdXNlb3ZlckRlbGF5ID8/PSA0MDA7XHJcbiAgICBtb3VzZW91dFRvbGVyYW5jZURlbGF5ID8/PSA1MDA7XHJcbiAgICBmb2N1c0RlbGF5ID8/PSAxO1xyXG5cclxuICAgIC8vIFRoZSBlc2NhcGUga2V5IHNob3VsZCBjbG9zZSB0b29sdGlwcywgYnV0IGRvIG5vdGhpbmcgZWxzZS5cclxuICAgIC8vIChpLmUuIGNsb3NpbmcgYSB0b29sdGlwIGluIGEgZGlhbG9nIE1VU1QgTk9UIGNsb3NlIHRoZSBkaWFsb2cgdG9vKVxyXG4gICAgLy8gVE9ETzogVG9vbHRpcHMgYXJlLCBlZmZlY3RpdmVseSwgYWx3YXlzIHRoZSB0b3Btb3N0IGNvbXBvbmVudCxcclxuICAgIC8vIHNvIHdlIGNhbiBqdXN0IGhhdmUgdGhlbSBsaXN0ZW4gdG8gYW5kIHN3YWxsb3cgYWxsIFwiRXNjYXBlXCJcclxuICAgIC8vIGtleSBwcmVzc2VzIGJlZm9yZSBhbnlvbmUgZWxzZS4gRm9yIGEgbW9yZSBnZW5lcmFsIHBvcHVwLFxyXG4gICAgLy8gb3IgYSB0b29sdGlwIGluIGEgdG9vbHRpcCAoISEpIGEgZGlmZmVyZW50IHNvbHV0aW9uIHdvdWxkIGJlIG5lZWRlZC5cclxuICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwia2V5ZG93blwiLCAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xyXG4gICAgICAgIGlmIChnZXRPcGVuKCkgJiYgZS5rZXkgPT09IFwiRXNjYXBlXCIgJiYgIWUuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIHNldE9wZW4oZmFsc2UpO1xyXG4gICAgICAgICAgICBzZXRIb3ZlclN0YXRlKFwiaGlkZGVuXCIpO1xyXG4gICAgICAgICAgICBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZhbHNlKTtcclxuICAgICAgICAgICAgc2V0VG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZChmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xyXG5cclxuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuLCBnZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50LC8vOiB1c2VUb29sdGlwSWRQcm9wcywgXHJcbiAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCwvLzogdXNlVG9vbHRpcElkUmVmZXJlbmNpbmdQcm9wcyBcclxuICAgIH0gPSB1c2VSYW5kb21JZDxQb3B1cFR5cGU+KHsgcmFuZG9tSWQ6IHsgcHJlZml4OiBcImFyaWEtdG9vbHRpcC1cIiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcclxuXHJcbiAgICBjb25zdCBbLCBzZXRUcmlnZ2VyRm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICBjb25zdCBkZWxheSA9IGZvY3VzZWQgPyBmb2N1c0RlbGF5IDogMTtcclxuICAgICAgICBpZiAoZGVsYXkgIT0gbnVsbCAmJiBpc0Zpbml0ZShkZWxheSkpIHtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZvY3VzZWQpLCBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDEpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSksIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFssIHNldFRvb2x0aXBGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gZm9jdXNlZCA/IGZvY3VzRGVsYXkgOiAxO1xyXG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZm9jdXNlZCksIGRlbGF5KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBvbkhvdmVyQ2hhbmdlID0gdXNlU3RhYmxlQ2FsbGJhY2soZnVuY3Rpb24gb25Ib3ZlckNoYW5nZShob3ZlcmluZzogYm9vbGVhbikge1xyXG4gICAgICAgIGlmIChob3ZlcmluZykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGhvdmVyU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJoaWRpbmdcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGhvdmluZyBvdmVyIHRoZSB0b29sdGlwIHJpZ2h0IGFmdGVyIGhvdmVyaW5nIGF3YXkgZnJvbSBpdC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIHNob3cgaXQgYWdhaW4gaW1tZWRpYXRlbHlcclxuICAgICAgICAgICAgICAgICAgICBzZXRIb3ZlclN0YXRlKFwic2hvd25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiaGlkZGVuXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdG9vbHRpcCBpc24ndCBzaG93aW5nIGFuZCBoYXNuJ3QgZm9yIGF3aGlsZSAoaWYgZXZlcilcclxuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciBvdXIgbW91c2VvdmVyIGRlbGF5XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0SG92ZXJTdGF0ZShcInNob3dpbmcyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7IGNvbnNvbGUubG9nKFwic2V0SG92ZXJTdGF0ZShzaG93bilcIik7ICBzZXRIb3ZlclN0YXRlKFwic2hvd25cIikgfSwgbW91c2VvdmVyRGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGhvdmVyU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJzaG93blwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vdXNlIGhhcyBsZWZ0IHRoZSB0cmlnZ2VyLCBidXQgZGVsYXkgdHJ1bHkgaGlkaW5nIGl0IGZvciBhIG1vbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHNldEhvdmVyU3RhdGUoXCJoaWRpbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHsgY29uc29sZS5sb2coXCJzZXRIb3ZlclN0YXRlKGhpZGRlbilcIik7IHNldEhvdmVyU3RhdGUoXCJoaWRkZW5cIik7fSwgbW91c2VvdmVyRGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInNob3dpbmcyXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEdXJpbmcgYSBtb3VzZW92ZXIgZGVsYXksIHdoZW4gd2UgbW91c2VvdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8ganVzdCByZXNldCB0aGUgdGltZXJcclxuICAgICAgICAgICAgICAgICAgICBzZXRIb3ZlclN0YXRlKFwiaGlkZGVuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICBjb25zdCBbLCBzZXRUcmlnZ2VySG92ZXJdID0gdXNlUGFzc2l2ZVN0YXRlKG9uSG92ZXJDaGFuZ2UsIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFssIHNldFRvb2x0aXBIb3Zlcl0gPSB1c2VQYXNzaXZlU3RhdGUob25Ib3ZlckNoYW5nZSwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgW3RyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQsIHNldFRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2hvdmVyU3RhdGUsIHNldEhvdmVyU3RhdGVdID0gdXNlU3RhdGU8XCJoaWRkZW5cIiB8IFwic2hvd2luZzJcIiB8IFwic2hvd25cIiB8IFwiaGlkaW5nXCI+KFwiaGlkZGVuXCIpO1xyXG5cclxuXHJcblxyXG4gICAgdXNlVGltZW91dCh7XHJcbiAgICAgICAgdHJpZ2dlckluZGV4OiBob3ZlclN0YXRlLFxyXG4gICAgICAgIHRpbWVvdXQ6IChob3ZlclN0YXRlID09IFwic2hvd2luZzJcIikgPyBtb3VzZW92ZXJEZWxheSA6IG51bGwsXHJcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGhvdmVyU3RhdGUgPT0gXCJzaG93aW5nMlwiKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRIb3ZlclN0YXRlKFwic2hvd25cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KVxyXG5cclxuXHJcblxyXG4gICAgdXNlVGltZW91dCh7XHJcbiAgICAgICAgdHJpZ2dlckluZGV4OiBob3ZlclN0YXRlLFxyXG4gICAgICAgIHRpbWVvdXQ6IChob3ZlclN0YXRlID09IFwiaGlkaW5nXCIpID8gbW91c2VvdXRUb2xlcmFuY2VEZWxheSA6IG51bGwsXHJcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGhvdmVyU3RhdGUgPT0gXCJoaWRpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgc2V0SG92ZXJTdGF0ZShcImhpZGRlblwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgLy9jb25zdCBbdHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQsIHNldFRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFt0b29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkLCBzZXRUb29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIC8vY29uc3QgW3Rvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkLCBzZXRUb29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgY29uc3QgaG92ZXJEZWxheUNvcnJlY3RlZCA9IChob3ZlclN0YXRlID09IFwic2hvd25cIik7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldE9wZW4odHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCB8fCBob3ZlckRlbGF5Q29ycmVjdGVkIHx8IHRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQpO1xyXG4gICAgfSwgW3RyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQgfHwgaG92ZXJEZWxheUNvcnJlY3RlZCB8fCB0b29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkXSlcclxuXHJcbiAgICBjb25zdCB1c2VUb29sdGlwVHJpZ2dlcjogVXNlVG9vbHRpcFRyaWdnZXI8VHJpZ2dlclR5cGU+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVG9vbHRpcFRyaWdnZXIoeyBoYXNGb2N1czogeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIC4uLmhhc0ZvY3VzIH0gfTogeyBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPFRyaWdnZXJUeXBlPiB9KSB7XHJcbiAgICAgICAgZGVidWdMb2coXCJ1c2VUb29sdGlwVHJpZ2dlclwiKTtcclxuXHJcbiAgICAgICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJwb2ludGVybW92ZVwiLCBlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcclxuICAgICAgICAgICAgc2V0VHJpZ2dlckhvdmVyKHRhcmdldCA9PSBnZXRFbGVtZW50KCkgYXMgTm9kZSB8fCAhIWdldEVsZW1lbnQoKT8uY29udGFpbnModGFyZ2V0KSk7XHJcbiAgICAgICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBvblRvdWNoRW5kKGU6IFRvdWNoRXZlbnQpIHtcclxuICAgICAgICAgICAgKGUudGFyZ2V0IGFzIGFueSkuZm9jdXMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlSGFzRm9jdXM8VHJpZ2dlclR5cGU+KHtcclxuICAgICAgICAgICAgLi4uaGFzRm9jdXMsXHJcbiAgICAgICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZm9jdXNlZCwgcHJldik7IHNldFRyaWdnZXJGb2N1c2VkKGZvY3VzZWQpIH0pXHJcbiAgICAgICAgfSlcclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDxUcmlnZ2VyVHlwZT4oXCJhcmlhLWRlc2NyaWJlZGJ5XCIgYXMgbmV2ZXIpO1xyXG4gICAgICAgICAgICAvLyBOb3RlOiBUaG91Z2ggaXQncyBpbXBvcnRhbnQgdG8gbWFrZSBzdXJlIHRoYXQgZm9jdXNpbmcgYWN0aXZhdGVzIGEgdG9vbHRpcCxcclxuICAgICAgICAgICAgLy8gaXQncyBwZXJmZWN0bHkgcmVhc29uYWJsZSB0aGF0IGEgY2hpbGQgZWxlbWVudCB3aWxsIGJlIHRoZSBvbmUgdGhhdCdzIGZvY3VzZWQsXHJcbiAgICAgICAgICAgIC8vIG5vdCB0aGlzIG9uZSwgc28gd2UgZG9uJ3Qgc2V0IHRhYkluZGV4PTBcclxuICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPz89IC0xO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKFxyXG4gICAgICAgICAgICAgICAgdXNlSGFzRm9jdXNQcm9wcyhcclxuICAgICAgICAgICAgICAgICAgICB1c2VNZXJnZWRQcm9wczxUcmlnZ2VyVHlwZT4oeyBvblRvdWNoRW5kIH0sIChwcm9wcyBhcyBhbnkpIGFzIHVua25vd24gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+KVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyB9O1xyXG5cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCB1c2VUb29sdGlwUG9wdXAgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VUb29sdGlwKHsgaGFzRm9jdXM6IHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCAuLi5oYXNGb2N1cyB9IH06IHsgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxQb3B1cFR5cGU+IH0pIHtcclxuICAgICAgICBkZWJ1Z0xvZyhcInVzZVRvb2x0aXBUb29sdGlwXCIpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHMgfSA9IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCgpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlSGFzRm9jdXM8UG9wdXBUeXBlPih7IG9uRm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZm9jdXNlZCwgcHJldik7IHNldFRvb2x0aXBGb2N1c2VkKGZvY3VzZWQpOyB9KSwgLi4uaGFzRm9jdXMgfSlcclxuXHJcbiAgICAgICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJwb2ludGVybW92ZVwiLCBlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcclxuICAgICAgICAgICAgc2V0VG9vbHRpcEhvdmVyKHRhcmdldCA9PSBnZXRFbGVtZW50KCkgYXMgTm9kZSB8fCAhIWdldEVsZW1lbnQoKT8uY29udGFpbnModGFyZ2V0KSk7XHJcbiAgICAgICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VUb29sdGlwUG9wdXBQcm9wcyh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQb3B1cFR5cGU+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzKHVzZUhhc0ZvY3VzUHJvcHModXNlTWVyZ2VkUHJvcHM8UG9wdXBUeXBlPih7fSwgcHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VUb29sdGlwUG9wdXBQcm9wcyB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlVG9vbHRpcFBvcHVwLFxyXG4gICAgICAgIHVzZVRvb2x0aXBUcmlnZ2VyLFxyXG4gICAgICAgIGlzT3Blbjogb3BlbixcclxuICAgICAgICBnZXRJc09wZW46IGdldE9wZW5cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb24sIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvLCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnMsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1oYXMtZm9jdXNcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGRlYnVnTG9nLCBFbGVtZW50VG9UYWcsIEVuaGFuY2VkRXZlbnQsIGVuaGFuY2VFdmVudCwgVGFnU2Vuc2l0aXZlUHJvcHMgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VDaGVja2JveExpa2UsIHVzZUxhYmVsIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XHJcblxyXG4vL3R5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+O1xyXG5leHBvcnQgdHlwZSBSYWRpb0NoYW5nZUV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgViBleHRlbmRzIG51bWJlciB8IHN0cmluZz4gPSBFbmhhbmNlZEV2ZW50PEUsIEV2ZW50LCB7IHNlbGVjdGVkVmFsdWU6IFYgfCB1bmRlZmluZWQgfT47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8XCJzZWxlY3RlZEluZGV4XCIgfCBcIm9uU2VsZWN0ZWRJbmRleENoYW5nZVwiLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+IHtcclxuICAgIHJhZGlvR3JvdXA6IHtcclxuICAgICAgICBuYW1lOiBzdHJpbmc7XHJcblxyXG4gICAgICAgIHNlbGVjdGVkVmFsdWU6IFYgfCBudWxsO1xyXG4gICAgICAgIG9uU2VsZWN0ZWRWYWx1ZUNoYW5nZShldmVudDogUmFkaW9DaGFuZ2VFdmVudDxJbnB1dEVsZW1lbnQsIFY+KTogdm9pZDtcclxuICAgICAgICAvL29uSW5wdXQoZXZlbnQ6IFJhZGlvQ2hhbmdlRXZlbnQ8aC5KU1guVGFyZ2V0ZWRFdmVudDxMYWJlbEVsZW1lbnQ+LCBWPik6IHZvaWQ7XHJcbiAgICAgICAgdGFnR3JvdXA6IEVsZW1lbnRUb1RhZzxHcm91cEVsZW1lbnQ+O1xyXG4gICAgICAgIHRhZ0dyb3VwTGFiZWw6IEVsZW1lbnRUb1RhZzxHcm91cExhYmVsRWxlbWVudD47XHJcbiAgICB9XHJcbiAgICBjaGlsZHJlbkhhdmVGb2N1czogVXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzW1wiY2hpbGRyZW5IYXZlRm9jdXNcIl07XHJcbn1cclxuXHJcbi8qZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb0luZm9CYXNlIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZEluZm9CYXNlPFwidGFiYmFibGVcIiB8IFwic2VsZWN0ZWRcIj4ge1xyXG4gICAgc2V0Q2hlY2tlZChjaGVja2VkOiBib29sZWFuKTogdm9pZDtcclxuICAgIGdldENoZWNrZWQoKTogYm9vbGVhbiB8IG51bGw7XHJcbn0qL1xyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb1BhcmFtZXRlcnM8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSSBleHRlbmRzIEVsZW1lbnQsIElMIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPHt9LCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LCBcInN1YkluZm9cIj4ge1xyXG4gICAgcmFkaW86IHtcclxuICAgICAgICBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCI7XHJcbiAgICAgICAgdmFsdWU6IFY7XHJcbiAgICAgICAgZGlzYWJsZWQ6IGJvb2xlYW47XHJcbiAgICAgICAgdGFnSW5wdXQ6IEVsZW1lbnRUb1RhZzxJPjtcclxuICAgICAgICB0YWdMYWJlbDogRWxlbWVudFRvVGFnPElMPjtcclxuICAgIH1cclxuICAgIGhhc0ZvY3VzSW5wdXQ6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxJPjtcclxuICAgIGhhc0ZvY3VzTGFiZWw6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxJTD47XHJcbiAgICAvKk9taXQ8VXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJLCBJTD4sIFwib25JbnB1dFwiIHwgXCJyb2xlXCIgfCBcImNoZWNrZWRcIj4gJiB7XHJcbiAgICAgICAgaW5mbzogT21pdDxJbmZvLCBcInNldENoZWNrZWRcIiB8IFwiZ2V0Q2hlY2tlZFwiIHwgXCJibHVyU2VsZlwiIHwgXCJnZXRFbGVtZW50XCIgfCBcImZvY3VzU2VsZlwiPjtcclxuICAgICAgICBcclxuICAgIH0qL1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhZGlvR3JvdXBSZXR1cm5UeXBlSW5mbzxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPEksIHt9LCBuZXZlcj4ge1xyXG4gICAgcmFkaW9Hcm91cDoge1xyXG4gICAgICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7XHJcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogViB8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFkaW9Hcm91cFJldHVyblR5cGVXaXRoSG9va3M8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgRyBleHRlbmRzIEVsZW1lbnQsIEdMIGV4dGVuZHMgRWxlbWVudCwgSSBleHRlbmRzIEVsZW1lbnQsIElMIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgVXNlUmFkaW9Hcm91cFJldHVyblR5cGVJbmZvPFYsIEk+IHtcclxuICAgIHVzZVJhZGlvR3JvdXBMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdMPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R0w+O1xyXG4gICAgdXNlUmFkaW9Hcm91cFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEc+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHPjtcclxuICAgIHVzZVJhZGlvOiBVc2VSYWRpbzxWLCBJLCBJTD47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VSYWRpb0dyb3VwPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEcgZXh0ZW5kcyBFbGVtZW50LCBHTCBleHRlbmRzIEVsZW1lbnQsIEkgZXh0ZW5kcyBFbGVtZW50LCBJTCBleHRlbmRzIEhUTUxFbGVtZW50Pih7XHJcbiAgICBsaW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgbGlzdE5hdmlnYXRpb24sXHJcbiAgICBtYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICByYWRpb0dyb3VwOiB7IG5hbWUsIG9uU2VsZWN0ZWRWYWx1ZUNoYW5nZSwgc2VsZWN0ZWRWYWx1ZSwgdGFnR3JvdXAsIHRhZ0dyb3VwTGFiZWwgfSxcclxuICAgIHJvdmluZ1RhYkluZGV4LFxyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbixcclxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzLFxyXG4gICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGlvbk1vZGUgfVxyXG59OiBVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHLCBHTCwgST4pOiBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZVdpdGhIb29rczxWLCBHLCBHTCwgSSwgSUw+IHtcclxuICAgIGRlYnVnTG9nKFwidXNlUmFkaW9Hcm91cFwiLCBzZWxlY3RlZFZhbHVlKTtcclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogX2dldFJhZGlvR3JvdXBQYXJlbnRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8Rz4oe30pO1xyXG5cclxuICAgIC8vY29uc3QgZ2V0U2VsZWN0ZWRJbmRleCA9IHVzZUNhbGxiYWNrKChzZWxlY3RlZFZhbHVlOiBWKSA9PiB7IHJldHVybiBieU5hbWUuY3VycmVudC5nZXQoc2VsZWN0ZWRWYWx1ZSkgPz8gMCB9LCBbXSlcclxuXHJcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPigwKTtcclxuICAgIGNvbnN0IGJ5TmFtZSA9IHVzZVJlZihuZXcgTWFwPFYsIGFueT4oKSk7XHJcbiAgICAvL2NvbnN0IHN0YWJsZU9uSW5wdXQgPSB1c2VTdGFibGVDYWxsYmFjayhvblNlbGVjdGVkVmFsdWVDaGFuZ2UpO1xyXG5cclxuICAgIC8vY29uc3QgW2FueVJhZGlvc0ZvY3VzZWQsIHNldEFueVJhZGlvc0ZvY3VzZWQsIGdldEFueVJhZGlvc0ZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dDogdXNlR3JvdXBMYWJlbElucHV0LCB1c2VMYWJlbExhYmVsOiB1c2VHcm91cExhYmVsTGFiZWwgfSA9IHVzZUxhYmVsPEcsIEdMPih7IGxhYmVsOiB7IHByZWZpeExhYmVsOiBcImFyaWEtcmFkaW8tZ3JvdXAtbGFiZWwtXCIsIHRhZ0lucHV0OiB0YWdHcm91cCBhcyBuZXZlciwgdGFnTGFiZWw6IHRhZ0dyb3VwTGFiZWwgYXMgbmV2ZXIsIHByZWZpeElucHV0OiBcImFyaWEtcmFkaW8tZ3JvdXAtXCIgfSB9KVxyXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHM6IHVzZUdyb3VwTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VHcm91cExhYmVsSW5wdXQoKTtcclxuICAgIGNvbnN0IHsgdXNlTGFiZWxMYWJlbFByb3BzOiB1c2VHcm91cExhYmVsTGFiZWxQcm9wcyB9ID0gdXNlR3JvdXBMYWJlbExhYmVsKCk7XHJcblxyXG4gICAgY29uc3Qgb25TZWxlY3RlZEluZGV4Q2hhbmdlID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IEV2ZW50LCBuZXdJbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgb25TZWxlY3RlZFZhbHVlQ2hhbmdlKGVuaGFuY2VFdmVudDxJLCBFdmVudCwgeyBzZWxlY3RlZFZhbHVlOiBWIHwgdW5kZWZpbmVkIH0+KGUsIHsgc2VsZWN0ZWRWYWx1ZTogbGlzdE5hdlJldC5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4uZ2V0QXQobmV3SW5kZXgpPy5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby5nZXRWYWx1ZSgpIH0pKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXHJcbiAgICAgICAgLi4ubGlzdE5hdlJldFxyXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPEcsIEksIHsgZ2V0VmFsdWUoKTogViB9LCBuZXZlcj4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb24sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4LCBvblNlbGVjdGVkSW5kZXhDaGFuZ2UsIHNlbGVjdGlvbk1vZGUgfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uLFxyXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBUcmFjayB3aGV0aGVyIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgdGhlIHJhZGlvIGdyb3VwIHBhcmVudCBlbGVtZW50LlxyXG4gICAgLy8gV2hlbiBpdCdzIG5vdCwgd2UgcmVzZXQgdGhlIHRhYmJhYmxlIGluZGV4IGJhY2sgdG8gdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBlbGVtZW50LlxyXG4gICAgLy9jb25zdCB7IHVzZUFjdGl2ZUVsZW1lbnRQcm9wcyB9ID0gdXNlQWN0aXZlRWxlbWVudDxHPih7IG9uQWN0aXZlRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKGFjdGl2ZUVsZW1lbnQ6IE5vZGUgfCBudWxsKSA9PiBzZXRBbnlSYWRpb3NGb2N1c2VkKCEhKGdldFJhZGlvR3JvdXBQYXJlbnRFbGVtZW50KCk/LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSksIFtdKSB9KTtcclxuICAgIC8qdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWFueVJhZGlvc0ZvY3VzZWQpXHJcbiAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChzZWxlY3RlZEluZGV4ID8/IDApO1xyXG4gICAgfSwgW2FueVJhZGlvc0ZvY3VzZWQsIHNlbGVjdGVkSW5kZXgsIG5hdmlnYXRlVG9JbmRleF0pOyovXHJcblxyXG5cclxuICAgIGNvbnN0IHVzZVJhZGlvR3JvdXBQcm9wcyA9IHVzZUNhbGxiYWNrKCh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEc+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rz4gPT4ge1xyXG4gICAgICAgIHByb3BzLnJvbGUgPSBcInJhZGlvZ3JvdXBcIjtcclxuICAgICAgICByZXR1cm4gdXNlR3JvdXBMYWJlbElucHV0UHJvcHModXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyh1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpKSk7XHJcbiAgICB9LCBbdXNlUmVmRWxlbWVudFByb3BzXSlcclxuXHJcbiAgICBjb25zdCB1c2VSYWRpb0dyb3VwTGFiZWxQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8R0w+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8R0w+ID0+IHsgcmV0dXJuIHVzZUdyb3VwTGFiZWxMYWJlbFByb3BzKHByb3BzKTsgfSwgW3VzZUdyb3VwTGFiZWxMYWJlbFByb3BzXSk7XHJcblxyXG4gICAgLy9jb25zdCBjb3JyZWN0ZWRJbmRleCA9IChzZWxlY3RlZEluZGV4ID09IG51bGwgfHwgc2VsZWN0ZWRJbmRleCA8IDAgfHwgc2VsZWN0ZWRJbmRleCA+PSBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoKSA/IG51bGwgOiBzZWxlY3RlZEluZGV4O1xyXG4gICAgLypjb25zdCB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9ID0gdXNlQ2hpbGRyZW5GbGFnKHtcclxuICAgICAgICBpbml0aWFsSW5kZXg6IDAsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAga2V5OiBcInNlbGVjdGVkXCJcclxuICAgICAgICAvL3NldENoaWxkRmxhZzogKGksIGNoZWNrZWQpID0+IG1hbmFnZWRDaGlsZHJlbltpXT8uc2V0Q2hlY2tlZChjaGVja2VkKSxcclxuICAgICAgICAvL2dldENoaWxkRmxhZzogKChpKSA9PiBtYW5hZ2VkQ2hpbGRyZW5baV0/LmdldENoZWNrZWQoKSA/PyBmYWxzZSlcclxuICAgIH0pOyovXHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoc2VsZWN0ZWRWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXgobnVsbClcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBieU5hbWUuY3VycmVudC5nZXQoc2VsZWN0ZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXgoc2VsZWN0ZWRJbmRleCA/PyBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbYnlOYW1lLCBzZWxlY3RlZFZhbHVlXSk7XHJcblxyXG5cclxuXHJcbiAgICBjb25zdCB1c2VSYWRpbyA9IHVzZUNhbGxiYWNrPFVzZVJhZGlvPFYsIEksIElMPj4oZnVuY3Rpb24gdXNlUmFkaW8oe1xyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZCxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICBoYXNGb2N1c0lucHV0LFxyXG4gICAgICAgIGhhc0ZvY3VzTGFiZWwsXHJcbiAgICAgICAgcmFkaW86IHsgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgdmFsdWUgfVxyXG4gICAgfSkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gbWFuYWdlZENoaWxkLmluZGV4O1xyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlUmFkaW9cIiwgaW5kZXgpO1xyXG4gICAgICAgIC8vY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWQsIGdldENoZWNrZWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgICAgICBjb25zdCBvbklucHV0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8ST4pID0+IHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBvblNlbGVjdGVkSW5kZXhDaGFuZ2UoZSwgaW5kZXgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZVN0YWJsZUdldHRlcih2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMsIC4uLmxpc3ROYXZSZXQgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQoe1xyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbixcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXgsXHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZCxcclxuICAgICAgICAgICAgaGFzRm9jdXM6IGhhc0ZvY3VzSW5wdXQsXHJcbiAgICAgICAgICAgIHN1YkluZm86IHsgZ2V0VmFsdWUgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCB7IHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZDogY2hlY2tlZCB9IH0gPSBsaXN0TmF2UmV0O1xyXG5cclxuICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50IH0gPSB1c2VDaGVja2JveExpa2U8SSwgSUw+KHtcclxuICAgICAgICAgICAgY2hlY2tib3hMaWtlOiB7XHJcbiAgICAgICAgICAgICAgICBjaGVja2VkOiAoY2hlY2tlZCA/PyBmYWxzZSksXHJcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQsXHJcbiAgICAgICAgICAgICAgICBvbkNoZWNrZWRDaGFuZ2U6IG9uSW5wdXQsXHJcbiAgICAgICAgICAgICAgICByb2xlOiBcInJhZGlvXCJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgICAgIHRhZ0lucHV0OiB0YWdJbnB1dCBhcyBuZXZlcixcclxuICAgICAgICAgICAgICAgIHRhZ0xhYmVsOiB0YWdMYWJlbCBhcyBuZXZlclxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoYXNGb2N1c0lucHV0LFxyXG4gICAgICAgICAgICBoYXNGb2N1c0xhYmVsXHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBieU5hbWUuY3VycmVudC5zZXQodmFsdWUsIGluZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgYnlOYW1lLmN1cnJlbnQuZGVsZXRlKHZhbHVlKTsgfVxyXG4gICAgICAgIH0sIFtieU5hbWUsIHZhbHVlLCBpbmRleF0pO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VSYWRpb0lucHV0OiBVc2VSYWRpb0lucHV0PEk+ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0YWcgPSB0YWdJbnB1dDtcclxuICAgICAgICAgICAgY29uc3QgdXNlUmFkaW9JbnB1dFByb3BzID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0YWcgPT0gXCJpbnB1dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCA9IChjaGVja2VkID8/IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy50eXBlID0gXCJyYWRpb1wiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWNoZWNrZWRcIl0gPSAoY2hlY2tlZCA/PyBmYWxzZSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc0lmSW5wdXRIYW5kbGVzRm9jdXMgPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMocHJvcHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh1c2VNZXJnZWRQcm9wczxJPigodXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMoe30pKSwgbGFiZWxQb3NpdGlvbiA9PSBcInNlcGFyYXRlXCIgPyBwcm9wc0lmSW5wdXRIYW5kbGVzRm9jdXMgOiBwcm9wcykpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVzZVJhZGlvSW5wdXRQcm9wc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlUmFkaW9MYWJlbDogVXNlUmFkaW9MYWJlbDxJTD4gPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vY29uc3QgdGFnID0gdGFnTGFiZWw7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZVJhZGlvTGFiZWxQcm9wcyA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SUw+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SUw+ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNJZkxhYmVsSGFuZGxlc0ZvY3VzID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzKHByb3BzIGFzIGFueSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHM8SUw+KHt9IGFzIGFueSwgbGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIgPyBwcm9wc0lmTGFiZWxIYW5kbGVzRm9jdXMgYXMgYW55IDogcHJvcHMgYXMgYW55KSlcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1c2VSYWRpb0xhYmVsUHJvcHNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFt1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlUmFkaW9JbnB1dCxcclxuICAgICAgICAgICAgdXNlUmFkaW9MYWJlbCxcclxuICAgICAgICAgICAgLi4ubGlzdE5hdlJldFxyXG4gICAgICAgICAgICAvL2NoZWNrZWQ6IGNoZWNrZWQgPz8gZmFsc2UsXHJcbiAgICAgICAgICAgIC8vdGFiYmFibGU6IHRhYmJhYmxlID8/IGZhbHNlXHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sIFtieU5hbWUsIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVJhZGlvLFxyXG4gICAgICAgIHVzZVJhZGlvR3JvdXBQcm9wcyxcclxuICAgICAgICB1c2VSYWRpb0dyb3VwTGFiZWxQcm9wcyxcclxuICAgICAgICByYWRpb0dyb3VwOiB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXgsXHJcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVcclxuICAgICAgICB9LFxyXG4gICAgICAgIC4uLmxpc3ROYXZSZXRcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb1JldHVyblR5cGVJbmZvPEkgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxJPiB7IH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFkaW9SZXR1cm5UeXBlV2l0aEhvb2tzPEkgZXh0ZW5kcyBFbGVtZW50LCBMIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSYWRpb1JldHVyblR5cGVJbmZvPEk+IHtcclxuICAgIHVzZVJhZGlvSW5wdXQ6IFVzZVJhZGlvSW5wdXQ8ST47XHJcbiAgICB1c2VSYWRpb0xhYmVsOiBVc2VSYWRpb0xhYmVsPEw+O1xyXG59XHJcblxyXG50eXBlIFVzZVJhZGlvSW5wdXQ8SSBleHRlbmRzIEVsZW1lbnQ+ID0gKHsgdGFnIH06IFRhZ1NlbnNpdGl2ZVByb3BzPEk+KSA9PiB7IHVzZVJhZGlvSW5wdXRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST47IH1cclxudHlwZSBVc2VSYWRpb0xhYmVsPEwgZXh0ZW5kcyBFbGVtZW50PiA9ICh7IHRhZyB9OiBUYWdTZW5zaXRpdmVQcm9wczxMPikgPT4geyB1c2VSYWRpb0xhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEw+OyB9XHJcblxyXG5leHBvcnQgdHlwZSBVc2VSYWRpbzxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQ+ID0gKGE6IFVzZVJhZGlvUGFyYW1ldGVyczxWLCBJLCBMPikgPT4gVXNlUmFkaW9SZXR1cm5UeXBlV2l0aEhvb2tzPEksIEw+XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IGZpbmRGaXJzdEZvY3VzYWJsZSwgdXNlR2xvYmFsSGFuZGxlciwgdXNlTWFuYWdlZENoaWxkcmVuLCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlR2V0dGVyLCB1c2VTdGF0ZSwgdXNlVGltZW91dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcclxuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZGVidWdMb2cgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5cclxuXHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktaW50ZXJmYWNlICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9hc3RzUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBuZXZlcj4ge1xyXG4gICAgdG9hc3RzOiB7XHJcbiAgICAgICAgdmlzaWJsZUNvdW50OiBudW1iZXI7ICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRvYXN0cyB0aGF0IGFyZSBzaG93biBhdCBvbmUgdGltZSAodXNlZCBmb3IgYXV0b21hdGljIG1hbmFnZW1lbnQgb2Ygd2hlbiB0byBzaG93IHRvYXN0cywgaS5lLiBkb24ndCBzaG93IHRoaXMgdG9hc3QgaWYgMiBhcmUgYWxyZWFkeSBvbi1zY3JlZW4gLS0gMSBpcyBhIGdvb2QgZGVmYXVsdClcclxuICAgIH1cclxufVxyXG5cclxudHlwZSBTaG93aW5nID0gbmV2ZXI7IC8vXCJzaG93aW5nXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvYXN0UGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8bnVtYmVyLCBUb2FzdEluZm8sIFNob3dpbmcsIFwic3ViSW5mb1wiPiB7XHJcbiAgICAvL2luZm86IE9taXQ8VG9hc3RJbmZvQmFzZSwgXCJkaXNtaXNzZWRcIiB8IFwiZ2V0U3RhdHVzXCIgfCBcInNldFN0YXR1c1wiIHwgXCJmb2N1c1wiIHwgXCJmbGFnc1wiPjtcclxuICAgIHRvYXN0OiB7XHJcbiAgICAgICAgcG9saXRlbmVzcz86IFwicG9saXRlXCIgfCBcImFzc2VydGl2ZVwiO1xyXG4gICAgICAgIHRpbWVvdXQ6IG51bWJlciB8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVG9hc3RJbmZvIHtcclxuICAgIC8vZGlzbWlzc2VkOiBib29sZWFuO1xyXG4gICAgc2V0TnVtYmVyQWhlYWRPZk1lOiBTdGF0ZVVwZGF0ZXI8bnVtYmVyPjtcclxuICAgIGZvY3VzKCk6IHZvaWQ7XHJcbiAgICBzaG93KCk6IHZvaWQ7XHJcbiAgICAvL3NldFN0YXR1czogU3RhdGVVcGRhdGVyPFwicGVuZGluZ1wiIHwgXCJhY3RpdmVcIiB8IFwiZGlzbWlzc2VkXCI+O1xyXG4gICAgLy9nZXRTdGF0dXMoKTogbnVsbCB8IFwicGVuZGluZ1wiIHwgXCJhY3RpdmVcIiB8IFwiZGlzbWlzc2VkXCI7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZVRvYXN0ID0gKGFyZ3M6IFVzZVRvYXN0UGFyYW1ldGVycykgPT4gVXNlVG9hc3RSZXR1cm5UeXBlSW5mbztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9hc3RSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB0b2FzdDoge1xyXG4gICAgICAgIG51bWJlck9mVG9hc3RzQWhlYWRPZlVzOiBudW1iZXI7XHJcbiAgICAgICAgZGlzbWlzczogKCkgPT4gdm9pZDtcclxuICAgICAgICBkaXNtaXNzZWQ6IGJvb2xlYW47XHJcbiAgICAgICAgc2hvd2luZzogYm9vbGVhbjtcclxuICAgICAgICByZXNldERpc21pc3NUaW1lcjogKCkgPT4gdm9pZDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUb2FzdHNSZXR1cm5UeXBlSW5mbyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPG51bWJlciwgVG9hc3RJbmZvLCBTaG93aW5nPiB7XHJcbiAgICB0b2FzdHM6IHt9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvYXN0UmV0dXJuVHlwZVdpdGhIb29rcyBleHRlbmRzIFVzZVRvYXN0UmV0dXJuVHlwZUluZm8geyB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvYXN0c1JldHVyblR5cGVXaXRoSG9va3M8Q29udGFpbmVyVHlwZSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVG9hc3RzUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlVG9hc3Q6IFVzZVRvYXN0O1xyXG4gICAgdXNlVG9hc3RDb250YWluZXJQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJUeXBlPjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRvYXN0czxDb250YWluZXJUeXBlIGV4dGVuZHMgRWxlbWVudD4oeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY211LCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QgfSwgdG9hc3RzOiB7IHZpc2libGVDb3VudCB9IH06IFVzZVRvYXN0c1BhcmFtZXRlcnMpOiBVc2VUb2FzdHNSZXR1cm5UeXBlV2l0aEhvb2tzPENvbnRhaW5lclR5cGU+IHtcclxuICAgIGRlYnVnTG9nKFwidXNlVG9hc3RzXCIpO1xyXG5cclxuICAgIC8vIE5vcm1hbGx5LCB0aGlzIGRvZXMganVzdCBsb29rIGxpa2UgWzAsIDEsIDIsIDNdLCBldGNcclxuICAgIC8vIHNvIGl0IGNvdWxkIGJlIGp1c3QgYW4gaW5kZXggdG8gdGhlIGN1cnJlbnQgdG9hc3QsXHJcbiAgICAvLyBidXQgaWYgd2UgZGlzbWlzcyB0b2FzdHMgb3V0IG9mIG9yZGVyLCBpdCdzIFswLCAyLCAzXSBvciBzb21ldGhpbmcuXHJcbiAgICAvLyBTbyBqdXN0IGtlZXAgdHJhY2sgb2YgaXQgYWxsIGluIGEgYmlnIG9sJywgdGhlcmUncyBvbmx5IG9uZSBvZiB0aGVzZSBvbiBhIHBhZ2UgYW55d2F5LFxyXG4gICAgLy8gYW5kIGlmIHlvdSdyZSBwdXNpbmcgMTAwMDAgdG9hc3RzIGF0IG9uY2UgYW4gQXJyYXk8bnVtYmVyPiBpc24ndCBnb2luZyB0byBiZSB5b3VyIGJvdHRsZW5lY2suXHJcbiAgICBjb25zdCBjdXJyZW50SW5kZXhRdWV1ZSA9IHVzZVJlZjxudW1iZXJbXT4oW10pO1xyXG5cclxuICAgIGNvbnN0IFtwb2xpdGVuZXNzLCBzZXRQb2xpdGVuZXNzXSA9IHVzZVN0YXRlPFwicG9saXRlXCIgfCBcImFzc2VydGl2ZVwiPihcInBvbGl0ZVwiKTtcclxuXHJcbiAgICBjb25zdCBnZXRNYXhWaXNpYmxlQ291bnQgPSB1c2VTdGFibGVHZXR0ZXIodmlzaWJsZUNvdW50KTtcclxuXHJcbiAgICBjb25zdCB7IGdldEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxDb250YWluZXJUeXBlPih7fSk7XHJcbiAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZCwgLi4uY2hpbGRJbmZvIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBUb2FzdEluZm8sIFNob3dpbmc+KHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY211IH0gfSk7XHJcblxyXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW46IHRvYXN0UXVldWUgfSB9ID0gY2hpbGRJbmZvO1xyXG5cclxuICAgIC8vIFdoZW4gYSB0b2FzdCBpcyBzaG93biBvciBoaWRkZW4sIGFsd2F5cyBtYWtlIHN1cmUgdGhhdCB3ZSdyZSBzaG93aW5nIGFsbCB0aGUgdG9hc3RzIHRoYXQgd2Ugc2hvdWxkIGJlLlxyXG4gICAgY29uc3Qgc2hvd0hpZ2hlc3RQcmlvcml0eVRvYXN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWluKGdldE1heFZpc2libGVDb3VudCgpLCBjdXJyZW50SW5kZXhRdWV1ZS5jdXJyZW50Lmxlbmd0aClcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgKytpKSB7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBoaWdoZXN0UHJpb3JpdHlUb2FzdCA9IHRvYXN0UXVldWUuZ2V0QXQoY3VycmVudEluZGV4UXVldWUuY3VycmVudFtpXSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCEhaGlnaGVzdFByaW9yaXR5VG9hc3QpO1xyXG4gICAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlUb2FzdD8uc3ViSW5mby5zaG93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pXHJcblxyXG4gICAgLy8gQW55IHRpbWUgYSBuZXcgdG9hc3QgbW91bnRzLCB1cGRhdGUgb3VyIGJvdHRvbW1vc3RUb2FzdEluZGV4IHRvIHBvaW50IHRvIGl0IGlmIG5lY2Vzc2FyeVxyXG4gICAgLy8gKFwibmVjZXNzYXJ5XCIganVzdCBtZWFuaW5nIGlmIGl0J3MgdGhlIGZpcnN0IHRvYXN0IGV2ZXIgb3IgYWxsIHByaW9yIHRvYXN0cyBoYXZlIGJlZW4gZGlzbWlzc2VkKVxyXG4gICAgY29uc3Qgb25BbnlUb2FzdE1vdW50ZWQgPSB1c2VDYWxsYmFjaygodG9hc3RJbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgY3VycmVudEluZGV4UXVldWUuY3VycmVudC5wdXNoKHRvYXN0SW5kZXgpO1xyXG4gICAgICAgIHRvYXN0UXVldWUuZ2V0QXQodG9hc3RJbmRleCk/LnN1YkluZm8uc2V0TnVtYmVyQWhlYWRPZk1lKGN1cnJlbnRJbmRleFF1ZXVlLmN1cnJlbnQubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgc2hvd0hpZ2hlc3RQcmlvcml0eVRvYXN0KCk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gQW55IHRpbWUgYSB0b2FzdCBpcyBkaXNtaXNzZWQsIHVwZGF0ZSBvdXIgYm90dG9tbW9zdFRvYXN0SW5kZXggdG8gcG9pbnQgdG8gdGhlIG5leHQgdG9hc3QgaW4gdGhlIHF1ZXVlLCBpZiBvbmUgZXhpc3RzLlxyXG4gICAgY29uc3Qgb25BbnlUb2FzdERpc21pc3NlZCA9IHVzZUNhbGxiYWNrKChfaW5kZXg6IG51bWJlcikgPT4ge1xyXG5cclxuICAgICAgICAvLyBXaGVuIHdlIGRpc21pc3MgYSB0b2FzdCwgcmVtb3ZlIGl0IGZyb20gdGhlIFwidG8tZGlzcGxheVwiIHF1ZXVlIGJ5IGFjdHVhbGx5IHNwbGljaW5nIGl0IG91dCBvZiB0aGUgYXJyYXkuXHJcbiAgICAgICAgLy8gVGhlbiBub3RpZnkgZWFjaCB0b2FzdCBvZiBpdHMgY2hhbmdlIGluIHBvc2l0aW9uIHdpdGhpbiB0aGF0IHF1ZXVlIHRvIGtlZXAgdGhlIHR3byBpbiBzeW5jLlxyXG4gICAgICAgIGNvbnN0IHJlbW92YWxJbmRleCA9IGN1cnJlbnRJbmRleFF1ZXVlLmN1cnJlbnQuZmluZEluZGV4KGkgPT4gaSA9PSBfaW5kZXgpO1xyXG5cclxuXHJcbiAgICAgICAgLy8gRm9yIGFsbCB0b2FzdHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkaXNtaXNzZWQsIHNoaWZ0IHRoZW0gZXZlbiBmdXJ0aGVyIGJhY2sgYnkgb25lIHRvIFwibWFrZSBzcGFjZVwiIFxyXG4gICAgICAgIC8vICh0aGV5J3JlIHJlbW92ZWQgZnJvbSB0aGUgcXVldWUgYnV0IHRoaXMgaXMgdGhlIG5lZ2F0aXZlIGluZGV4IHRoZXkgd291bGQgaGF2ZSBpZiB3ZSBrZXB0IG5lZ2F0aXZlcyBpbiB0aGUgcXVldWUpXHJcbiAgICAgICAgLy8gZm9yIHRoZSBuZXdseS1kaXNtaXNzZWQgdG9hc3QuXHJcbiAgICAgICAgdG9hc3RRdWV1ZS5mb3JFYWNoKGMgPT4ge1xyXG4gICAgICAgICAgICBjLnN1YkluZm8uc2V0TnVtYmVyQWhlYWRPZk1lKHByZXYgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2IC0gMTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gTGV0IHRoaXMgdG9hc3Qga25vdyB0aGF0IGl0J3Mgbm93IHRoZSBtb3N0IHJlY2VudGx5IGRpc21pc3NlZCB0b2FzdFxyXG4gICAgICAgIHRvYXN0UXVldWUuZ2V0QXQoX2luZGV4KT8uc3ViSW5mby5zZXROdW1iZXJBaGVhZE9mTWUoLTEpO1xyXG5cclxuICAgICAgICAvLyBOb3RpZnkgYWxsIHRvYXN0cyB3YWl0aW5nIGJlaGluZCB0aGlzIG9uZSBpbiB0aGUgcXVldWUgdGhhdCB0aGV5J3ZlIG1vdmVkIHVwIG9uZSBzbG90XHJcbiAgICAgICAgdG9hc3RRdWV1ZS5mb3JFYWNoKGMgPT4ge1xyXG4gICAgICAgICAgICBjLnN1YkluZm8uc2V0TnVtYmVyQWhlYWRPZk1lKHByZXYgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPiByZW1vdmFsSW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXYgLSAxO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gQWN0dWFsbHkgbW9kaWZ5IHRoZSBxdWV1ZSBpdHNlbGZcclxuICAgICAgICBjdXJyZW50SW5kZXhRdWV1ZS5jdXJyZW50LnNwbGljZShyZW1vdmFsSW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAvLyBBbmQgYWZ0ZXIgYWxsIHRoYXQsIG1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHNob3dpbmcgYW55IHRvYXN0cyB0aGF0IGhhdmUgYmVlbiB3YWl0aW5nIGluIHRoZSBxdWV1ZVxyXG4gICAgICAgIHNob3dIaWdoZXN0UHJpb3JpdHlUb2FzdCgpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuXHJcblxyXG4gICAgY29uc3QgW19tb3VzZU92ZXIyLCBzZXRNb3VzZU92ZXIsIF9nZXRNb3VzZU92ZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwicG9pbnRlcm1vdmVcIiwgZSA9PiB7XHJcbiAgICAgICAgY29uc3QgbW91c2VPdmVyID0gKGUudGFyZ2V0ICE9IG51bGwgJiYgZS50YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmIChnZXRFbGVtZW50KCk/LmNvbnRhaW5zKGUudGFyZ2V0KSB8fCBnZXRFbGVtZW50KCkgPT0gZS50YXJnZXQpKTtcclxuICAgICAgICBzZXRNb3VzZU92ZXIobW91c2VPdmVyKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFueSB0aW1lIHRoZSBpbmRleCBwb2ludGluZyB0byB0aGUgY3VycmVudGx5LXNob3dpbmcgdG9hc3QgY2hhbmdlcyxcclxuICAgIC8vIHVwZGF0ZSB0aGUgcmVsZXZhbnQgY2hpbGRyZW4gYW5kIGxldCB0aGVtIGtub3cgdGhhdCB0aGV5J3JlIG5vdyBlaXRoZXIgYWN0aXZlIG9yIGRpc21pc3NlZC5cclxuICAgIC8qY29uc3QgeyBjaGFuZ2VJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgfSA9IHVzZUNoaWxkcmVuRmxhZzxUb2FzdEluZm8sIFwic2hvd2luZ1wiPih7XHJcbiAgICAgICAgaW5pdGlhbEluZGV4OiBhY3RpdmVUb2FzdEluZGV4LFxyXG4gICAgICAgIGNoaWxkcmVuOiB0b2FzdFF1ZXVlLFxyXG4gICAgICAgIGtleTogXCJzaG93aW5nXCIsXHJcbiAgICAgICAgY2xvc2VzdEZpdDogZmFsc2UsXHJcbiAgICB9KTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY2hhbmdlSW5kZXgoYWN0aXZlVG9hc3RJbmRleCk7XHJcbiAgICB9LCBbYWN0aXZlVG9hc3RJbmRleF0pOyovXHJcblxyXG4gICAgY29uc3QgdXNlVG9hc3Q6IFVzZVRvYXN0ID0gdXNlQ2FsbGJhY2soKHsgdG9hc3Q6IHsgcG9saXRlbmVzcywgdGltZW91dCB9LCBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXggfSB9OiBVc2VUb2FzdFBhcmFtZXRlcnMpOiBVc2VUb2FzdFJldHVyblR5cGVXaXRoSG9va3MgPT4ge1xyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlVG9hc3RcIiwgaW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IFtudW1iZXJPZlRvYXN0c0FoZWFkT2ZVcywgc2V0TnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXNdID0gdXNlU3RhdGUoSW5maW5pdHkpO1xyXG4gICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZGV4KTtcclxuICAgICAgICBjb25zdCBbZGlzbWlzc2VkMiwgc2V0RGlzbWlzc2VkMiwgZ2V0RGlzbWlzc2VkMl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgW3Nob3dpbmcyLCBzZXRTaG93aW5nMiwgZ2V0U2hvd2luZzJdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgIC8vY29uc3QgW2Rpc21pc3NlZCwgc2V0RGlzbWlzc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgICAgICAvL2NvbnN0IFtzdGF0dXMsIHNldFN0YXR1cywgZ2V0U3RhdHVzXSA9IHVzZVN0YXRlPFwicGVuZGluZ1wiIHwgXCJhY3RpdmVcIiB8IFwiZGlzbWlzc2VkXCI+KFwicGVuZGluZ1wiKTtcclxuICAgICAgICAvL2NvbnN0IGRpc21pc3NlZCA9IChzdGF0dXMgPT09IFwiZGlzbWlzc2VkXCIpO1xyXG4gICAgICAgIGNvbnN0IGRpc21pc3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghZ2V0RGlzbWlzc2VkMigpKVxyXG4gICAgICAgICAgICAgICAgb25BbnlUb2FzdERpc21pc3NlZChnZXRJbmRleCgpKTtcclxuXHJcbiAgICAgICAgICAgIHNldERpc21pc3NlZDIodHJ1ZSk7XHJcbiAgICAgICAgICAgIHNldFNob3dpbmcyKGZhbHNlKTtcclxuICAgICAgICB9LCBbXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNob3cgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFNob3dpbmcyKHRydWUpO1xyXG4gICAgICAgIH0sIFtdKVxyXG5cclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWdldERpc21pc3NlZDIoKSAmJiAhZ2V0U2hvd2luZzIoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bWJlck9mVG9hc3RzQWhlYWRPZlVzID49IDAgJiYgbnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMgPCBnZXRNYXhWaXNpYmxlQ291bnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3coKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtudW1iZXJPZlRvYXN0c0FoZWFkT2ZVc10pXHJcblxyXG4gICAgICAgIC8vY29uc3QgdG9hc3RJZCA9IGdlbmVyYXRlUmFuZG9tSWQoXCJ0b2FzdC1cIik7XHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgc2V0UG9saXRlbmVzcyhwb2xpdGVuZXNzID8/IFwicG9saXRlXCIpOyB9LCBbcG9saXRlbmVzc10pO1xyXG5cclxuXHJcbiAgICAgICAgY29uc3QgZm9jdXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEZvY3VzYWJsZSA9IGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGZpcnN0Rm9jdXNhYmxlPy5mb2N1cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW10pO1xyXG5cclxuICAgICAgICAvKmNvbnN0IFtzaG93aW5nLCBzZXRTaG93aW5nMiwgZ2V0U2hvd2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICAgICAgY29uc3Qgc2V0U2hvd2luZzogU3RhdGVVcGRhdGVyPGJvb2xlYW4+ID0gKCh1KSA9PiB7XHJcbiAgICAgICAgICAgIHNldFNob3dpbmcyKHByZXYgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0OiBib29sZWFuID0gKHR5cGVvZiB1ID09ICdmdW5jdGlvbicpID8gdShwcmV2KSA6IHU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXREaXNtaXNzZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb25BbnlUb2FzdERpc21pc3NlZChnZXRJbmRleCgpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pKi9cclxuICAgICAgICAvL2NvbnN0IHNob3dpbmdSZWYgPSB1c2VSZWY8Q2hpbGRGbGFnT3BlcmF0aW9ucz4oeyBnZXQ6IGdldFNob3dpbmcsIHNldDogc2V0U2hvd2luZywgaXNWYWxpZDogcmV0dXJuVHJ1ZSB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgX186IHZvaWQgPSB1c2VNYW5hZ2VkQ2hpbGQoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzOiB7IC8qc2hvd2luZzogc2hvd2luZ1JlZi5jdXJyZW50Ki8gfSwgc3ViSW5mbzogeyBmb2N1cywgc2V0TnVtYmVyQWhlYWRPZk1lOiBzZXROdW1iZXJPZlRvYXN0c0FoZWFkT2ZVcywgc2hvdyB9IH0gfSk7XHJcblxyXG4gICAgICAgIC8vY29uc3QgaXNBY3RpdmUgPSAoc3RhdHVzID09PSBcImFjdGl2ZVwiKTtcclxuICAgICAgICBjb25zdCBbdHJpZ2dlckluZGV4LCBzZXRUcmlnZ2VySW5kZXhdID0gdXNlU3RhdGUoMSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc2V0RGlzbWlzc1RpbWVyID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRUcmlnZ2VySW5kZXgoaSA9PiArK2kpO1xyXG4gICAgICAgIH0sIFtdKVxyXG5cclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBvbkFueVRvYXN0TW91bnRlZChpbmRleCk7XHJcbiAgICAgICAgfSwgW10pO1xyXG5cclxuICAgICAgICAvKnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghc2hvd2luZylcclxuICAgICAgICAgICAgICAgIG9uQW55VG9hc3REaXNtaXNzZWQoaW5kZXgpXHJcbiAgICAgICAgfSwgW3Nob3dpbmddKTsqL1xyXG5cclxuICAgICAgICBjb25zdCBkaXNtaXNzVGltZW91dEtleSA9ICh0aW1lb3V0ID09IG51bGwgfHwgbnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMgIT0gMCkgPyBudWxsIDogaXNGaW5pdGUodGltZW91dCkgPyB0aW1lb3V0IDogdGltZW91dCA+IDAgPyBudWxsIDogMDtcclxuXHJcbiAgICAgICAgdXNlVGltZW91dCh7XHJcbiAgICAgICAgICAgIHRpbWVvdXQ6IGRpc21pc3NUaW1lb3V0S2V5LFxyXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNob3dpbmcyKVxyXG4gICAgICAgICAgICAgICAgICAgIGRpc21pc3MoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdHJpZ2dlckluZGV4OiBzaG93aW5nMiA/IHRyaWdnZXJJbmRleCA6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b2FzdDoge1xyXG4gICAgICAgICAgICAgICAgZGlzbWlzc2VkOiBkaXNtaXNzZWQyLFxyXG4gICAgICAgICAgICAgICAgc2hvd2luZzogc2hvd2luZzIsXHJcbiAgICAgICAgICAgICAgICBudW1iZXJPZlRvYXN0c0FoZWFkT2ZVcyxcclxuICAgICAgICAgICAgICAgIGRpc21pc3MsXHJcbiAgICAgICAgICAgICAgICByZXNldERpc21pc3NUaW1lclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHVzZVRvYXN0Q29udGFpbmVyUHJvcHMoeyByb2xlLCBcImFyaWEtbGl2ZVwiOiBhcmlhTGl2ZSwgXCJhcmlhLXJlbGV2YW50XCI6IGFyaWFSZWxldmFudCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJUeXBlPiB7XHJcbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPENvbnRhaW5lclR5cGU+KHVzZVJlZkVsZW1lbnRQcm9wcyh7IGNsYXNzOiBcInRvYXN0cy1jb250YWluZXJcIiwgcm9sZTogcm9sZSB8fCBcInN0YXR1c1wiLCBcImFyaWEtbGl2ZVwiOiBwb2xpdGVuZXNzID8/IGFyaWFMaXZlID8/IFwicG9saXRlXCIsIFwiYXJpYS1yZWxldmFudFwiOiBhcmlhUmVsZXZhbnQgPz8gXCJhZGRpdGlvbnNcIiB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPENvbnRhaW5lclR5cGU+KSwgcHJvcHMpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVRvYXN0LFxyXG4gICAgICAgIHVzZVRvYXN0Q29udGFpbmVyUHJvcHMsXHJcbiAgICAgICAgLi4uY2hpbGRJbmZvLFxyXG4gICAgICAgIHRvYXN0czoge31cclxuICAgIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgTWFuYWdlZENoaWxkcmVuLCByZXR1cm5OdWxsLCB1c2VHcmlkTmF2aWdhdGlvbiwgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbywgdXNlUGFzc2l2ZVN0YXRlLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm8sIHVzZVNvcnRhYmxlQ2hpbGRyZW4sIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVJbmZvLCBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm8gfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtZ3JpZC1uYXZpZ2F0aW9uXCI7XHJcbmltcG9ydCB7IENvbXBhcmUsIEdldEluZGV4LCBHZXRWYWx1ZSwgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXNvcnRhYmxlLWNoaWxkcmVuXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBkZWJ1Z0xvZywgRWxlbWVudFRvVGFnLCB3YXJuT25PdmVyd3JpdGUgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5cclxuZXhwb3J0IHR5cGUgVGFibGVWYWx1ZVR5cGUgPSBzdHJpbmcgfCBudW1iZXIgfCBudWxsIHwgYm9vbGVhbiB8IERhdGU7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlUGFyYW1ldGVycyBleHRlbmRzIE9taXQ8VXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiwgXCJncmlkTmF2aWdhdGlvblwiPiB7IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZUJvZHlQYXJhbWV0ZXJzIHsgfVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPFVzZVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4sIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIHt9PiwgXCJzdWJJbmZvXCI+IHtcclxuICAgIHRhYmxlUm93OiBQaWNrPFVzZVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4sIFwibG9jYXRpb25cIj4gJiB7IHRhZ1RhYmxlUm93OiBFbGVtZW50VG9UYWc8Um93RWxlbWVudD4gfTtcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIFVzZVRhYmxlQ2VsbFN1YkluZm8sIG5ldmVyLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCBPbWl0PFVzZVRhYmxlQ2VsbFN1YkluZm8sIFwic2V0TXlTb3J0RGlyZWN0aW9uXCI+PiB7XHJcbiAgICB0YWJsZUNlbGw6IHsgdGFnVGFibGVDZWxsOiBFbGVtZW50VG9UYWc8Q2VsbEVsZW1lbnQ+OyBoZWFkZXJUeXBlOiBcInJvd1wiIHwgXCJjb2x1bW5cIiB8IG51bGwgfTtcclxuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcclxuICAgIGxvY2F0aW9uOiBcImhlYWRcIiB8IFwiYm9keVwiIHwgXCJmb290XCI7XHJcbiAgICBnZXRDZWxscygpOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2VsbEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxVc2VUYWJsZUNlbGxTdWJJbmZvPj4sIFwidGFiYmFibGVcIj47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVDZWxsU3ViSW5mbyB7XHJcbiAgICBsb2NhdGlvbjogXCJoZWFkXCIgfCBcImJvZHlcIiB8IFwiZm9vdFwiO1xyXG4gICAgdmFsdWU6IFRhYmxlVmFsdWVUeXBlO1xyXG4gICAgc2V0TXlTb3J0RGlyZWN0aW9uKGRpcmVjdGlvbjogVGFibGVTb3J0RGlyZWN0aW9uIHwgbnVsbCk6IHZvaWQ7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PiB7IHRhYmxlSGVhZGVyQ2VsbDogeyBzb3J0KCk6IHZvaWQsIHNvcnREaXJlY3Rpb246IFRhYmxlU29ydERpcmVjdGlvbiB8IG51bGw7IH0gfVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBVc2VUYWJsZUNlbGxTdWJJbmZvLCBuZXZlcj4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVCb2R5UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPFJvd0VsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxVc2VUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+Pj4sIG5ldmVyLCBbXT4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgVXNlVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50PiwgbmV2ZXI+IHsgfVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVDZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+IHsgdXNlVGFibGVDZWxsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD47IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUYWJsZVJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7IHVzZVRhYmxlQ2VsbDogVXNlVGFibGVDZWxsPENlbGxFbGVtZW50PjsgdXNlVGFibGVSb3dQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD47IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZUJvZHlSZXR1cm5UeXBlV2l0aEhvb2tzPEJvZHlTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFibGVCb2R5UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHsgdXNlVGFibGVCb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keVNlY3Rpb25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keVNlY3Rpb25FbGVtZW50PiB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFibGVSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4ge1xyXG4gICAgdXNlVGFibGVSb3c6IFVzZVRhYmxlUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PjtcclxuICAgIHVzZVRhYmxlQm9keTogVXNlVGFibGVCb2R5PEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+O1xyXG4gICAgdXNlVGFibGVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+O1xyXG4gICAgdXNlVGFibGVTZWN0aW9uUHJvcHM6ICh0YWc6IHN0cmluZywgbG9jYXRpb246IFVzZVRhYmxlUm93U3ViSW5mbzxhbnk+W1wibG9jYXRpb25cIl0sIHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VUYWJsZUNlbGw8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChwOiBVc2VUYWJsZUNlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50PikgPT4gVXNlVGFibGVDZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsRWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZVRhYmxlUm93PFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKHA6IFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4pID0+IFVzZVRhYmxlUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZVRhYmxlQm9keTxCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChwOiBVc2VUYWJsZUJvZHlQYXJhbWV0ZXJzKSA9PiBVc2VUYWJsZUJvZHlSZXR1cm5UeXBlV2l0aEhvb2tzPEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+O1xyXG5cclxuZXhwb3J0IHR5cGUgVGFibGVTb3J0RGlyZWN0aW9uID0gXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiO1xyXG5cclxuZnVuY3Rpb24gaWRlbnRpdHkodDogbnVtYmVyKSB7IHJldHVybiB0OyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGFibGU8XHJcbiAgICBUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxyXG4gICAgQm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcclxuICAgIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxyXG4gICAgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50XHJcbj4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgdHlwZWFoZWFkTmF2aWdhdGlvbiB9OiBVc2VUYWJsZVBhcmFtZXRlcnMpOiBVc2VUYWJsZVJldHVyblR5cGVXaXRoSG9va3M8VGFibGVFbGVtZW50LCBCb2R5U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7XHJcbiAgICBkZWJ1Z0xvZyhcInVzZVRhYmxlXCIpO1xyXG5cclxuICAgIGNvbnN0IFtnZXRDdXJyZW50U29ydENvbHVtbiwgc2V0Q3VycmVudFNvcnRDb2x1bW5dID0gdXNlUGFzc2l2ZVN0YXRlPHsgaW5kZXg6IG51bWJlciwgZGlyZWN0aW9uOiBUYWJsZVNvcnREaXJlY3Rpb24gfSB8IG51bGw+KG51bGwsIHJldHVybk51bGwpO1xyXG4gICAgY29uc3QgYm9keVNvcnQgPSB1c2VSZWY8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCk7XHJcbiAgICBjb25zdCBtYW5nbGVycyA9IHVzZVJlZih7IHJvd0luZGV4TWFuZ2xlcjogaWRlbnRpdHksIHJvd0luZGV4RGVtYW5nbGVyOiBpZGVudGl0eSB9KTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Qcm9wcyxcclxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvdyxcclxuICAgICAgICAuLi5ncmlkTmF2UmV0MVxyXG4gICAgfSA9IHVzZUdyaWROYXZpZ2F0aW9uPFRhYmxlRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFVzZVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4sIFVzZVRhYmxlQ2VsbFN1YkluZm8sIG5ldmVyLCBuZXZlcj4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4ubGlzdE5hdmlnYXRpb24gfSxcclxuICAgICAgICBncmlkTmF2aWdhdGlvbjogeyByb3dJbmRleERlbWFuZ2xlcjogdXNlQ2FsbGJhY2soKG46IG51bWJlcikgPT4gbWFuZ2xlcnMuY3VycmVudC5yb3dJbmRleERlbWFuZ2xlcihuKSwgW10pLCByb3dJbmRleE1hbmdsZXI6IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IG1hbmdsZXJzLmN1cnJlbnQucm93SW5kZXhNYW5nbGVyKG4pLCBbXSkgfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXgsXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW46IHJvd3MgfSB9ID0gZ3JpZE5hdlJldDE7XHJcblxyXG4gICAgY29uc3QgdXNlVGFibGVSb3cgPSB1c2VDYWxsYmFjazxVc2VUYWJsZVJvdzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4+KCh7IGFzQ2hpbGRSb3dPZlNlY3Rpb24sIGFzUGFyZW50Um93T2ZDZWxscywgdGFibGVSb3c6IHsgbG9jYXRpb24sIHRhZ1RhYmxlUm93IH0gfTogVXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50Pik6IFVzZVRhYmxlUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4gPT4ge1xyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlVGFibGVSb3dcIiwgYXNDaGlsZFJvd09mU2VjdGlvbi5tYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG5cclxuICAgICAgICBjb25zdCBnZXRDZWxscyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNlbGxzO1xyXG4gICAgICAgIH0sIFtdKVxyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCxcclxuICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyxcclxuICAgICAgICAgICAgLi4uZ3JpZE5hdlJldDJcclxuICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25Sb3coeyBhc0NoaWxkUm93T2ZTZWN0aW9uOiB7IC4uLmFzQ2hpbGRSb3dPZlNlY3Rpb24sIHN1YkluZm86IHsgZ2V0Q2VsbHMsIGxvY2F0aW9uIH0gfSwgYXNQYXJlbnRSb3dPZkNlbGxzIH0pO1xyXG5cclxuICAgICAgICBjb25zdCB7IGFzUGFyZW50T2ZDZWxsczogeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW46IGNlbGxzIH0gfSB9ID0gZ3JpZE5hdlJldDI7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZVRhYmxlQ2VsbCA9IHVzZUNhbGxiYWNrPFVzZVRhYmxlQ2VsbDxDZWxsRWxlbWVudD4+KCh7IGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4LCBzdWJJbmZvLCBoYXNGb2N1cywgdGFibGVDZWxsOiB7IHRhZ1RhYmxlQ2VsbCwgaGVhZGVyVHlwZSB9IH0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW215U29ydERpcmVjdGlvbiwgc2V0TXlTb3J0RGlyZWN0aW9uXSA9IHVzZVN0YXRlPFRhYmxlU29ydERpcmVjdGlvbiB8IG51bGw+KG51bGwpO1xyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcInVzZVRhYmxlQ2VsbFwiLCBtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG4gICAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyxcclxuICAgICAgICAgICAgICAgIC4uLmdyaWROYXZSZXQzXHJcbiAgICAgICAgICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvbkNlbGwoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgc3ViSW5mbzogeyAuLi5zdWJJbmZvLCBzZXRNeVNvcnREaXJlY3Rpb24gfSwgaGFzRm9jdXMgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzb3J0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc29ydEluZm8gPSBnZXRDdXJyZW50U29ydENvbHVtbigpID8/IHsgaW5kZXg6IC0xLCBkaXJlY3Rpb246ICdhc2NlbmRpbmcnIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsSW5kZXggPSBtYW5hZ2VkQ2hpbGQuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAoc29ydEluZm8uaW5kZXggPT0gY2VsbEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRJbmZvLmRpcmVjdGlvblswXSA9PSAnYScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydEluZm8uZGlyZWN0aW9uID0gJ2Rlc2NlbmRpbmcnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydEluZm8uZGlyZWN0aW9uID0gJ2FzY2VuZGluZyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydEluZm8uZGlyZWN0aW9uID0gXCJhc2NlbmRpbmdcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzb3J0SW5mby5pbmRleCA9IG1hbmFnZWRDaGlsZC5pbmRleDtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRTb3J0Q29sdW1uKHNvcnRJbmZvKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnZXRDZWxscygpLmZvckVhY2goY2VsbCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwuaW5kZXggPT0gbWFuYWdlZENoaWxkLmluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuc3ViSW5mby5zdWJJbmZvLnN1YkluZm8uc2V0TXlTb3J0RGlyZWN0aW9uKHNvcnRJbmZvLmRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLnNldE15U29ydERpcmVjdGlvbihudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgIGJvZHlTb3J0LmN1cnJlbnQhKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdXNlVGFibGVDZWxsUHJvcHM6IHR5cGVvZiB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyA9IChwcm9wcykgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0YWdUYWJsZUNlbGwgIT0gXCJ0ZFwiICYmIHRhZ1RhYmxlQ2VsbCAhPSBcInRoXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhZGVyVHlwZSA9PSBcInJvd1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5yb2xlID0gd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFibGVDZWxsXCIsIFwicm9sZVwiLCBwcm9wcy5yb2xlLCBcInJvd2hlYWRlclwiKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoZWFkZXJUeXBlID09IFwiY29sdW1uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLnJvbGUgPSB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJsZUNlbGxcIiwgXCJyb2xlXCIsIHByb3BzLnJvbGUsIFwiY29sdW1uaGVhZGVyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMucm9sZSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZVRhYmxlQ2VsbFwiLCBcInJvbGVcIiwgcHJvcHMucm9sZSwgXCJjZWxsXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlclR5cGUgPT0gXCJyb3dcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuc2NvcGUgPSB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJsZUNlbGxcIiwgXCJzY29wZVwiLCBwcm9wcy5zY29wZSwgXCJyb3dcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVhZGVyVHlwZSA9PSBcImNvbHVtblwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5zY29wZSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZVRhYmxlQ2VsbFwiLCBcInNjb3BlXCIsIHByb3BzLnNjb3BlLCBcImNvbFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJUeXBlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobXlTb3J0RGlyZWN0aW9uID09IFwiZGVzY2VuZGluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1zb3J0XCJdID0gd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFibGVDZWxsXCIsIFwiYXJpYS1zb3J0XCIsIHByb3BzW1wiYXJpYS1zb3J0XCJdLCBcImRlc2NlbmRpbmdcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG15U29ydERpcmVjdGlvbiA9PSBcImFzY2VuZGluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1zb3J0XCJdID0gd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFibGVDZWxsXCIsIFwiYXJpYS1zb3J0XCIsIHByb3BzW1wiYXJpYS1zb3J0XCJdLCBcImFzY2VuZGluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMocHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0YWJsZUhlYWRlckNlbGw6IHsgc29ydCwgc29ydERpcmVjdGlvbjogbXlTb3J0RGlyZWN0aW9uIH0sXHJcbiAgICAgICAgICAgICAgICB1c2VUYWJsZUNlbGxQcm9wcyxcclxuICAgICAgICAgICAgICAgIC4uLmdyaWROYXZSZXQzXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSwgW10pO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VUYWJsZVJvd1Byb3BzOiB0eXBlb2YgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyA9IChwcm9wcykgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGFnVGFibGVSb3cgIT0gXCJ0clwiKVxyXG4gICAgICAgICAgICAgICAgcHJvcHMucm9sZSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZVRhYmxlUm93XCIsIFwicm9sZVwiLCBwcm9wcy5yb2xlLCBcInJvd1wiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHMocHJvcHMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZVRhYmxlQ2VsbCxcclxuICAgICAgICAgICAgdXNlVGFibGVSb3dQcm9wcyxcclxuICAgICAgICAgICAgLi4uZ3JpZE5hdlJldDJcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgdXNlVGFibGVCb2R5ID0gdXNlQ2FsbGJhY2s8VXNlVGFibGVCb2R5PEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+PigoKSA9PiB7XHJcbiAgICAgICAgZGVidWdMb2coXCJ1c2VUYWJsZUJvZHlcIik7XHJcbiAgICAgICAgdHlwZSBDID0gVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPFJvd0VsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxVc2VUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+Pj47XHJcbiAgICAgICAgdHlwZSBWID0geyBsb2NhdGlvbjogXCJoZWFkXCIgfCBcImJvZHlcIiB8IFwiZm9vdFwiLCB2YWx1ZTogVGFibGVWYWx1ZVR5cGUgfTtcclxuICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZUNhbGxiYWNrPEdldEluZGV4PEMsIG5ldmVyPj4oKGkpID0+IGkuaW5kZXgsIFtdKTtcclxuICAgICAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZUNhbGxiYWNrPEdldFZhbHVlPEMsIG5ldmVyLCBbXSwgVj4+KChpKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGxzID0gaS5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby5nZXRDZWxscygpO1xyXG4gICAgICAgICAgICBjb25zdCBjZWxsID0gY2VsbHMuZ2V0QXQoZ2V0Q3VycmVudFNvcnRDb2x1bW4oKT8uaW5kZXggPz8gMCk7XHJcbiAgICAgICAgICAgIHJldHVybiAoe1xyXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IGNlbGw/LnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmxvY2F0aW9uID8/IFwiaGVhZFwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNlbGw/LnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLnZhbHVlID8/IC0xXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvL3JldHVybiBjZWxscy5nZXRBdChnZXRDdXJyZW50U29ydENvbHVtbigpPy5pbmRleCA/PyAwKT8uc3ViSW5mby5zdWJJbmZvLnN1YkluZm8udmFsdWUgPz8gbnVsbDtcclxuICAgICAgICB9LCBbXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbXBhcmU6IENvbXBhcmU8Vj4gPSAobGhzLCByaHMpID0+IHtcclxuICAgICAgICAgICAgaWYgKGxocy5sb2NhdGlvbiA9PT0gcmhzLmxvY2F0aW9uKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICsobGhzLnZhbHVlID8/IC1JbmZpbml0eSkgLSArKHJocy52YWx1ZSA/PyAtSW5maW5pdHkpO1xyXG4gICAgICAgICAgICBpZiAobGhzLmxvY2F0aW9uID09ICdoZWFkJylcclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgaWYgKGxocy5sb2NhdGlvbiA9PSAnYm9keScpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmhzLmxvY2F0aW9uID09ICdoZWFkJyA/IC0xIDogMTtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXHJcbiAgICAgICAgICAgIC4uLnNvcnRhYmxlUmV0XHJcbiAgICAgICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48Qm9keVNlY3Rpb25FbGVtZW50LCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Um93RWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPFVzZVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4+PiwgbmV2ZXIsIFtdLCBWPih7XHJcbiAgICAgICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjoge1xyXG4gICAgICAgICAgICAgICAgZ2V0SW5kZXhcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc29ydGFibGVDaGlsZHJlbjoge1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZSxcclxuICAgICAgICAgICAgICAgIGdldFZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgeyBzb3J0YWJsZUNoaWxkcmVuOiB7IHNvcnQgfSwgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSB9ID0gc29ydGFibGVSZXQ7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgbWFuZ2xlcnMuY3VycmVudC5yb3dJbmRleERlbWFuZ2xlciA9IGluZGV4RGVtYW5nbGVyO1xyXG4gICAgICAgICAgICBtYW5nbGVycy5jdXJyZW50LnJvd0luZGV4TWFuZ2xlciA9IGluZGV4TWFuZ2xlcjtcclxuICAgICAgICB9LCBbaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlcl0pO1xyXG5cclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBib2R5U29ydC5jdXJyZW50ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc29ydChyb3dzLCBnZXRDdXJyZW50U29ydENvbHVtbigpPy5kaXJlY3Rpb24gPz8gJ2FzY2VuZGluZycpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sIFtzb3J0XSlcclxuXHJcbiAgICAgICAgY29uc3QgdXNlVGFibGVCb2R5UHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4pID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQocHJvcHMuY2hpbGRyZW4gIT0gbnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VTb3J0YWJsZVByb3BzKHByb3BzIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4gJiB7IGNoaWxkcmVuOiBhbnkgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VUYWJsZUJvZHlQcm9wcyxcclxuICAgICAgICAgICAgLi4uc29ydGFibGVSZXRcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgdXNlVGFibGVQcm9wczogdHlwZW9mIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHMgPSB1c2VHcmlkTmF2aWdhdGlvblByb3BzO1xyXG5cclxuICAgIGNvbnN0IHVzZVRhYmxlU2VjdGlvblByb3BzID0gdXNlQ2FsbGJhY2soKHRhZzogc3RyaW5nLCBsb2NhdGlvbjogVXNlVGFibGVSb3dTdWJJbmZvPGFueT5bXCJsb2NhdGlvblwiXSwgcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pID0+IHtcclxuICAgICAgICBpZiAoISh0YWcgPT0gXCJ0aGVhZFwiIHx8IHRhZyA9PSBcInRib2R5XCIgfHwgdGFnID09IFwidGZvb3RcIikpIHtcclxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZVRhYmxlU2VjdGlvblByb3BzXCIsIFwicm9sZVwiLCBwcm9wcy5yb2xlLCBcInJvd2dyb3VwXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvcHM7XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVRhYmxlUHJvcHMsXHJcbiAgICAgICAgdXNlVGFibGVCb2R5LFxyXG4gICAgICAgIHVzZVRhYmxlUm93LFxyXG4gICAgICAgIHVzZVRhYmxlU2VjdGlvblByb3BzLFxyXG4gICAgICAgIC4uLmdyaWROYXZSZXQxXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgTWFuYWdlZENoaWxkcmVuLCByZXR1cm5OdWxsLCB1c2VHcmlkTmF2aWdhdGlvbiwgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbywgdXNlUGFzc2l2ZVN0YXRlLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm8sIHVzZVNvcnRhYmxlQ2hpbGRyZW4sIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm8sIFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1ncmlkLW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgQ29tcGFyZSwgR2V0SW5kZXgsIEdldFZhbHVlLCBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2Utc29ydGFibGUtY2hpbGRyZW5cIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBkZWJ1Z0xvZywgd2Fybk9uT3ZlcndyaXRlIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RQYXJhbWV0ZXJzIGV4dGVuZHMgT21pdDxVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnM8XCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LCBcImdyaWROYXZpZ2F0aW9uXCI+IHsgfVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0U2VjdGlvblBhcmFtZXRlcnMgeyBjb21wYXJlUm93czogKGxoc0luZGV4OiBudW1iZXIsIHJoc0luZGV4OiBudW1iZXIpID0+IG51bWJlciB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxVc2VHcmlkbGlzdFJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCB7fT4sIFwic3ViSW5mb1wiPiB7XHJcbiAgICBncmlkbGlzdFJvdzogUGljazxVc2VHcmlkbGlzdFJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBcImxvY2F0aW9uSW5kZXhcIj47XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdENoaWxkUGFyYW1ldGVyczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgVXNlR3JpZGxpc3RDaGlsZFN1YkluZm8sIG5ldmVyLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCBVc2VHcmlkbGlzdENoaWxkU3ViSW5mbz4ge1xyXG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxDZWxsRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RSb3dTdWJJbmZvPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgbG9jYXRpb25JbmRleDogbnVtYmVyO1xyXG4gICAgZ2V0Q2VsbHMoKTogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENlbGxFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlR3JpZGxpc3RDaGlsZFN1YkluZm8+PiwgXCJ0YWJiYWJsZVwiPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdENoaWxkU3ViSW5mbyB7XHJcbiAgICBsb2NhdGlvbkluZGV4OiBudW1iZXI7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RDaGlsZFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsRWxlbWVudD4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RSb3dSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFVzZUdyaWRsaXN0Q2hpbGRTdWJJbmZvLCBuZXZlcj4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RTZWN0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPFJvd0VsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxVc2VHcmlkbGlzdFJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+Pj4sIG5ldmVyLCBbXT4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgVXNlR3JpZGxpc3RSb3dTdWJJbmZvPENlbGxFbGVtZW50PiwgbmV2ZXI+IHsgfVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RDaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWRsaXN0Q2hpbGRSZXR1cm5UeXBlSW5mbzxDZWxsRWxlbWVudD4geyB1c2VHcmlkbGlzdENoaWxkUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD47IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdFJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkbGlzdFJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7IHVzZUdyaWRsaXN0Q2hpbGQ6IFVzZUdyaWRsaXN0Q2hpbGQ8Q2VsbEVsZW1lbnQ+OyB1c2VHcmlkbGlzdFJvd1Byb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvd0VsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PjsgfVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0U2VjdGlvblJldHVyblR5cGVXaXRoSG9va3M8Qm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkbGlzdFNlY3Rpb25SZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4geyB1c2VHcmlkbGlzdFNlY3Rpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdFJldHVyblR5cGVXaXRoSG9va3M8R3JpZGxpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkbGlzdFJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7XHJcbiAgICB1c2VHcmlkbGlzdFJvdzogVXNlR3JpZGxpc3RSb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+O1xyXG4gICAgdXNlR3JpZGxpc3RTZWN0aW9uOiBVc2VHcmlkbGlzdFNlY3Rpb248Qm9keVNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudD47XHJcbiAgICB1c2VHcmlkbGlzdFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyaWRsaXN0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyaWRsaXN0RWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZUdyaWRsaXN0Q2hpbGQ8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChwOiBVc2VHcmlkbGlzdENoaWxkUGFyYW1ldGVyczxDZWxsRWxlbWVudD4pID0+IFVzZUdyaWRsaXN0Q2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGxFbGVtZW50PjtcclxuZXhwb3J0IHR5cGUgVXNlR3JpZGxpc3RSb3c8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAocDogVXNlR3JpZGxpc3RSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50PikgPT4gVXNlR3JpZGxpc3RSb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PjtcclxuZXhwb3J0IHR5cGUgVXNlR3JpZGxpc3RTZWN0aW9uPEJvZHlTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKHA6IFVzZUdyaWRsaXN0U2VjdGlvblBhcmFtZXRlcnMpID0+IFVzZUdyaWRsaXN0U2VjdGlvblJldHVyblR5cGVXaXRoSG9va3M8Qm9keVNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudD47XHJcblxyXG5mdW5jdGlvbiBpZGVudGl0eSh0OiBudW1iZXIpIHsgcmV0dXJuIHQ7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkbGlzdDxcclxuICAgIEdyaWRsaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXHJcbiAgICBCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxyXG4gICAgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXHJcbiAgICBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnRcclxuPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCB0eXBlYWhlYWROYXZpZ2F0aW9uIH06IFVzZUdyaWRsaXN0UGFyYW1ldGVycyk6IFVzZUdyaWRsaXN0UmV0dXJuVHlwZVdpdGhIb29rczxHcmlkbGlzdEVsZW1lbnQsIEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHtcclxuICAgIGRlYnVnTG9nKFwidXNlR3JpZGxpc3RcIik7XHJcblxyXG4gICAgY29uc3QgW2dldEN1cnJlbnRTb3J0Q29sdW1uLCBzZXRDdXJyZW50U29ydENvbHVtbl0gPSB1c2VQYXNzaXZlU3RhdGU8eyBpbmRleDogbnVtYmVyLCBkaXJlY3Rpb246IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIiB9IHwgbnVsbD4obnVsbCwgcmV0dXJuTnVsbCk7XHJcbiAgICBjb25zdCBib2R5U29ydCA9IHVzZVJlZjxudWxsIHwgKCgpID0+IHZvaWQpPihudWxsKTtcclxuXHJcbiAgICAvLyBUT0RPOiBDb21wYXJpbmcgdGhlIGxvY2F0aW9uIHNob3VsZCBoYXBwZW4gb3V0IGhlcmUsIG5vdCBpbiBlYWNoIHNlY3Rpb24gc28gdGhhdCBncmlkIG5hdmlnYXRpb24gd29ya3MgcmlnaHQuLi5cclxuICAgIGNvbnN0IG1hbmdsZXJzID0gdXNlUmVmKHsgcm93SW5kZXhNYW5nbGVyOiBpZGVudGl0eSwgcm93SW5kZXhEZW1hbmdsZXI6IGlkZW50aXR5IH0pO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93LFxyXG4gICAgICAgIC4uLmdyaWROYXZSZXQxXHJcbiAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb248R3JpZGxpc3RFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgVXNlR3JpZGxpc3RSb3dTdWJJbmZvPENlbGxFbGVtZW50PiwgVXNlR3JpZGxpc3RDaGlsZFN1YkluZm8sIG5ldmVyLCBuZXZlcj4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb24sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb24sXHJcbiAgICAgICAgZ3JpZE5hdmlnYXRpb246IHsgcm93SW5kZXhEZW1hbmdsZXI6IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IG1hbmdsZXJzLmN1cnJlbnQucm93SW5kZXhEZW1hbmdsZXIobiksIFtdKSwgcm93SW5kZXhNYW5nbGVyOiB1c2VDYWxsYmFjaygobjogbnVtYmVyKSA9PiBtYW5nbGVycy5jdXJyZW50LnJvd0luZGV4TWFuZ2xlcihuKSwgW10pIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogcm93cyB9IH0gPSBncmlkTmF2UmV0MTtcclxuXHJcbiAgICBjb25zdCB1c2VHcmlkbGlzdFJvdyA9IHVzZUNhbGxiYWNrPFVzZUdyaWRsaXN0Um93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50Pj4oKHsgYXNDaGlsZFJvd09mU2VjdGlvbiwgYXNQYXJlbnRSb3dPZkNlbGxzLCBncmlkbGlzdFJvdzogeyBsb2NhdGlvbkluZGV4IH0gfTogVXNlR3JpZGxpc3RSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50Pik6IFVzZUdyaWRsaXN0Um93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4gPT4ge1xyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlR3JpZGxpc3RSb3dcIiwgYXNDaGlsZFJvd09mU2VjdGlvbi5tYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG5cclxuICAgICAgICBjb25zdCBnZXRDZWxscyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNlbGxzO1xyXG4gICAgICAgIH0sIFtdKVxyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCxcclxuICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyxcclxuICAgICAgICAgICAgLi4uZ3JpZE5hdlJldDJcclxuICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25Sb3coeyBhc0NoaWxkUm93T2ZTZWN0aW9uOiB7IC4uLmFzQ2hpbGRSb3dPZlNlY3Rpb24sIHN1YkluZm86IHsgZ2V0Q2VsbHMsIGxvY2F0aW9uSW5kZXggfSB9LCBhc1BhcmVudFJvd09mQ2VsbHMgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgYXNQYXJlbnRPZkNlbGxzOiB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogY2VsbHMgfSB9IH0gPSBncmlkTmF2UmV0MjtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlR3JpZGxpc3RDaGlsZCA9IHVzZUNhbGxiYWNrPFVzZUdyaWRsaXN0Q2hpbGQ8Q2VsbEVsZW1lbnQ+PigoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgc3ViSW5mbywgaGFzRm9jdXMgfSkgPT4ge1xyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcInVzZUdyaWRsaXN0Q2hpbGRcIiwgbWFuYWdlZENoaWxkLmluZGV4KTtcclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMsXHJcbiAgICAgICAgICAgICAgICAuLi5ncmlkTmF2UmV0M1xyXG4gICAgICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25DZWxsKHsgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXgsIHN1YkluZm8sIGhhc0ZvY3VzIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdXNlR3JpZGxpc3RDaGlsZFByb3BzOiB0eXBlb2YgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMgPSAocHJvcHMpID0+IHtcclxuICAgICAgICAgICAgICAgIHByb3BzLnJvbGUgPSB3YXJuT25PdmVyd3JpdGUoXCJ1c2VHcmlkbGlzdENoaWxkXCIsIFwicm9sZVwiLCBwcm9wcy5yb2xlLCBcImNlbGxcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMocHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1c2VHcmlkbGlzdENoaWxkUHJvcHMsXHJcbiAgICAgICAgICAgICAgICAuLi5ncmlkTmF2UmV0M1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sIFtdKTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlR3JpZGxpc3RSb3dQcm9wczogdHlwZW9mIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHMgPSAocHJvcHMpID0+IHtcclxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZUdyaWRsaXN0Um93XCIsIFwicm9sZVwiLCBwcm9wcy5yb2xlLCBcInJvd1wiKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHMocHJvcHMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUdyaWRsaXN0Q2hpbGQsXHJcbiAgICAgICAgICAgIHVzZUdyaWRsaXN0Um93UHJvcHMsXHJcbiAgICAgICAgICAgIC4uLmdyaWROYXZSZXQyXHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IHVzZUdyaWRsaXN0U2VjdGlvbiA9IHVzZUNhbGxiYWNrPFVzZUdyaWRsaXN0U2VjdGlvbjxCb2R5U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50Pj4oKHsgY29tcGFyZVJvd3MgfSkgPT4ge1xyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlR3JpZGxpc3RTZWN0aW9uXCIpO1xyXG4gICAgICAgIHR5cGUgQyA9IFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxSb3dFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlR3JpZGxpc3RSb3dTdWJJbmZvPENlbGxFbGVtZW50Pj4+O1xyXG4gICAgICAgIHR5cGUgViA9IHsgbG9jYXRpb25JbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyIH07XHJcbiAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VDYWxsYmFjazxHZXRJbmRleDxDLCBuZXZlcj4+KChpKSA9PiBpLmluZGV4LCBbXSk7XHJcbiAgICAgICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjazxHZXRWYWx1ZTxDLCBuZXZlciwgW10sIFY+PigoaSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjZWxscyA9IGkuc3ViSW5mby5zdWJJbmZvLnN1YkluZm8uZ2V0Q2VsbHMoKTtcclxuICAgICAgICAgICAgY29uc3QgY2VsbCA9IGNlbGxzLmdldEF0KGdldEN1cnJlbnRTb3J0Q29sdW1uKCk/LmluZGV4ID8/IDApO1xyXG4gICAgICAgICAgICByZXR1cm4gKHtcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uSW5kZXg6IGNlbGw/LnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmxvY2F0aW9uSW5kZXggPz8gMCxcclxuICAgICAgICAgICAgICAgIGluZGV4OiBjZWxsPy5pbmRleCA/PyAwXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIFtdKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29tcGFyZTogQ29tcGFyZTxWPiA9IChsaHMsIHJocykgPT4ge1xyXG4gICAgICAgICAgICBpZiAobGhzLmxvY2F0aW9uSW5kZXggPT09IHJocy5sb2NhdGlvbkluZGV4KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVSb3dzKGxocy5pbmRleCwgcmhzLmluZGV4KTtcclxuICAgICAgICAgICAgcmV0dXJuIGxocy5sb2NhdGlvbkluZGV4IC0gcmhzLmxvY2F0aW9uSW5kZXg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXHJcbiAgICAgICAgICAgIC4uLnNvcnRhYmxlUmV0XHJcbiAgICAgICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48Qm9keVNlY3Rpb25FbGVtZW50LCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Um93RWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPFVzZUdyaWRsaXN0Um93U3ViSW5mbzxDZWxsRWxlbWVudD4+PiwgbmV2ZXIsIFtdLCBWPih7XHJcbiAgICAgICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjoge1xyXG4gICAgICAgICAgICAgICAgZ2V0SW5kZXhcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc29ydGFibGVDaGlsZHJlbjoge1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZSxcclxuICAgICAgICAgICAgICAgIGdldFZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgeyBzb3J0YWJsZUNoaWxkcmVuOiB7IHNvcnQgfSB9ID0gc29ydGFibGVSZXQ7XHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgYm9keVNvcnQuY3VycmVudCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNvcnQocm93cywgZ2V0Q3VycmVudFNvcnRDb2x1bW4oKT8uZGlyZWN0aW9uID8/ICdhc2NlbmRpbmcnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LCBbc29ydF0pXHJcblxyXG4gICAgICAgIGNvbnN0IHVzZUdyaWRsaXN0U2VjdGlvblByb3BzID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHByb3BzLmNoaWxkcmVuICE9IG51bGwpO1xyXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gd2Fybk9uT3ZlcndyaXRlKFwidXNlR3JpZGxpc3RTZWN0aW9uXCIsIFwicm9sZVwiLCBwcm9wcy5yb2xlLCBcInJvd2dyb3VwXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlU29ydGFibGVQcm9wcyhwcm9wcyBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+ICYgeyBjaGlsZHJlbjogYW55IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlR3JpZGxpc3RTZWN0aW9uUHJvcHMsXHJcbiAgICAgICAgICAgIC4uLnNvcnRhYmxlUmV0XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IHVzZUdyaWRsaXN0UHJvcHM6IHR5cGVvZiB1c2VHcmlkTmF2aWdhdGlvblByb3BzID0gKHByb3BzKSA9PiB7XHJcbiAgICAgICAgcHJvcHMucm9sZSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZUdyaWRsaXN0XCIsIFwicm9sZVwiLCBwcm9wcy5yb2xlLCBcImdyaWRcIik7XHJcbiAgICAgICAgcmV0dXJuIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHMocHJvcHMpO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUdyaWRsaXN0UHJvcHMsXHJcbiAgICAgICAgdXNlR3JpZGxpc3RTZWN0aW9uLFxyXG4gICAgICAgIHVzZUdyaWRsaXN0Um93LFxyXG4gICAgICAgIC4uLmdyaWROYXZSZXQxXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTGlzdE5hdmlnYXRpb24sIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBQcm9wTW9kaWZpZXIsIHdhcm5Pbk92ZXJ3cml0ZSB9IGZyb20gXCIuL3Byb3BzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvb2xiYXJQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBcIm5hdmlnYXRpb25EaXJlY3Rpb25cIiwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4ge1xyXG4gICAgdG9vbGJhcjogeyBvcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCI7IH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sYmFyUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwge30sIG5ldmVyPiB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvb2xiYXJSZXR1cm5UeXBlV2l0aEhvb2tzPENvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRvb2xiYXJSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcclxuICAgIHVzZVRvb2xiYXJQcm9wczogUHJvcE1vZGlmaWVyPENvbnRhaW5lckVsZW1lbnQ+O1xyXG4gICAgdXNlVG9vbGJhckNoaWxkOiBVc2VUb29sYmFyQ2hpbGQ8Q2hpbGRFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlVG9vbGJhckNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGk6IFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnMpID0+IFVzZVRvb2xiYXJDaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcclxuZXhwb3J0IHR5cGUgVXNlVG9vbGJhckNoaWxkUGFyYW1ldGVycyA9IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+O1xyXG5leHBvcnQgdHlwZSBVc2VUb29sYmFyQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbGJhckNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRvb2xiYXJDaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xyXG4gICAgdXNlVG9vbGJhckNoaWxkUHJvcHM6IFByb3BNb2RpZmllcjxDaGlsZEVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVG9vbGJhcjxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgdHlwZWFoZWFkTmF2aWdhdGlvbiwgdG9vbGJhcjogeyBvcmllbnRhdGlvbiB9IH06IFVzZVRvb2xiYXJQYXJhbWV0ZXJzKTogVXNlVG9vbGJhclJldHVyblR5cGVXaXRoSG9va3M8Q29udGFpbmVyRWxlbWVudCwgQ2hpbGRFbGVtZW50PiB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIC4uLmxpc3RSZXRcclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxDb250YWluZXJFbGVtZW50LCBDaGlsZEVsZW1lbnQsIHt9LCBuZXZlcj4oeyBcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxpbmVhck5hdmlnYXRpb24sIG5hdmlnYXRpb25EaXJlY3Rpb246IG9yaWVudGF0aW9uIH0sIFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLCBcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sIFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LCBcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uIFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXNlVG9vbGJhckNoaWxkID0gdXNlQ2FsbGJhY2soKGk6IFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnMpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcywgLi4ubGlzdFJldCB9ID0gIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoaSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgLi4ubGlzdFJldCxcclxuICAgICAgICAgICAgdXNlVG9vbGJhckNoaWxkUHJvcHM6IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wc1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKVxyXG5cclxuICAgIGZ1bmN0aW9uIHVzZVRvb2xiYXJQcm9wcyhwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJFbGVtZW50Pikge1xyXG4gICAgICAgIHdhcm5Pbk92ZXJ3cml0ZShcInVzZVRvb2xiYXJcIiwgXCJyb2xlXCIsIHAucm9sZSwgXCJ0b29sYmFyXCIpO1xyXG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzKHApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4ubGlzdFJldCxcclxuICAgICAgICB1c2VUb29sYmFyUHJvcHMsXHJcbiAgICAgICAgdXNlVG9vbGJhckNoaWxkXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwicHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQWNjb3JkaW9uLCBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzLCBVc2VBY2NvcmRpb25SZXR1cm5UeXBlSW5mbywgVXNlQWNjb3JkaW9uU2VjdGlvbiwgVXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnMsIFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtYWNjb3JkaW9uXCI7XHJcbmltcG9ydCB7IEhlYWRpbmcgfSBmcm9tIFwiLi9oZWFkaW5nXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5cclxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWNjb3JkaW9uUHJvcHMgZXh0ZW5kc1xyXG4gICAgR2V0PFVzZUFjY29yZGlvblBhcmFtZXRlcnMsIFwiYWNjb3JkaW9uXCI+LFxyXG4gICAgR2V0PFVzZUFjY29yZGlvblBhcmFtZXRlcnMsIFwibGluZWFyTmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VBY2NvcmRpb25QYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZHJlblwiPiB7XHJcbiAgICBleHBhbmRlZEluZGV4PzogbnVtYmVyIHwgdW5kZWZpbmVkIHwgbnVsbDtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VBY2NvcmRpb25SZXR1cm5UeXBlSW5mbyk6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWNjb3JkaW9uU2VjdGlvblByb3BzPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDxVc2VBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PiwgXCJhY2NvcmRpb25TZWN0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZHJlblwiPixcclxuICAgIFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PixcclxuICAgIEdldDxVc2VBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PiwgXCJidXR0b25cIj4ge1xyXG4gICAgcmVuZGVyKGluZm86IFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbywgbWFrZUhlYWRlclByb3BzOiBQcm9wTW9kaWZpZXI8SGVhZGVyRWxlbWVudD4sIG1ha2VCb2R5UHJvcHM6IFByb3BNb2RpZmllcjxCb2R5RWxlbWVudD4pOiBWTm9kZTxhbnk+O1xyXG59XHJcblxyXG5cclxuY29uc3QgQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUFjY29yZGlvblNlY3Rpb248YW55LCBhbnk+PihudWxsISk7XHJcbmV4cG9ydCBjb25zdCBBY2NvcmRpb24gPSBtZW1vKGZ1bmN0aW9uIEFjY29yZGlvbih7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgZXhwYW5kZWRJbmRleCwgaW5pdGlhbEluZGV4LCBuYXZpZ2F0aW9uRGlyZWN0aW9uLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgcmVuZGVyIH06IEFjY29yZGlvblByb3BzKSB7XHJcbiAgICBjb25zdCB7IHVzZUFjY29yZGlvblNlY3Rpb24sIC4uLnByb3ZpZGVyIH0gPSB1c2VBY2NvcmRpb24oe1xyXG4gICAgICAgIGFjY29yZGlvbjogeyBpbml0aWFsSW5kZXggfSxcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9XHJcbiAgICB9KTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4geyBwcm92aWRlci5hY2NvcmRpb24uY2hhbmdlRXhwYW5kZWRJbmRleChleHBhbmRlZEluZGV4ISA/PyBudWxsKTsgfSwgW2V4cGFuZGVkSW5kZXhdKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxBY2NvcmRpb25TZWN0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlQWNjb3JkaW9uU2VjdGlvbn0+e3JlbmRlcihwcm92aWRlcil9PC9BY2NvcmRpb25TZWN0aW9uQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIClcclxufSlcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyQWNjb3JkaW9uU2VjdGlvbjxIZWFkZXJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBtYWtlUHJvcHNIZWFkaW5nQ29udGFpbmVyLCBtYWtlUHJvcHNIZWFkaW5nQnV0dG9uLCBtYWtlUHJvcHNCb2R5LCB0YWdCb2R5LCB0YWdIZWFkaW5nQnV0dG9uIH06IHsgdGFnSGVhZGluZ0J1dHRvbjogRWxlbWVudFRvVGFnPEhlYWRlckJ1dHRvbkVsZW1lbnQ+OyB0YWdCb2R5OiBFbGVtZW50VG9UYWc8Qm9keUVsZW1lbnQ+OyBtYWtlUHJvcHNIZWFkaW5nQ29udGFpbmVyKGluZm86IFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbyk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckNvbnRhaW5lckVsZW1lbnQ+LCBtYWtlUHJvcHNIZWFkaW5nQnV0dG9uKGluZm86IFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbyk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckJ1dHRvbkVsZW1lbnQ+LCBtYWtlUHJvcHNCb2R5KGluZm86IFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbyk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbywgbW9kaWZ5SGVhZGluZ0J1dHRvblByb3BzOiBQcm9wTW9kaWZpZXI8SGVhZGVyQnV0dG9uRWxlbWVudD4sIG1vZGlmeUJvZHlQcm9wczogUHJvcE1vZGlmaWVyPEJvZHlFbGVtZW50Pik6IFZOb2RlPGFueT4ge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICA8SGVhZGluZzxIZWFkZXJDb250YWluZXJFbGVtZW50PiB7Li4ubWFrZVByb3BzSGVhZGluZ0NvbnRhaW5lcihpbmZvKX0gaGVhZGluZz17Y3JlYXRlRWxlbWVudCh0YWdIZWFkaW5nQnV0dG9uIGFzIG5ldmVyLCBtb2RpZnlIZWFkaW5nQnV0dG9uUHJvcHMobWFrZVByb3BzSGVhZGluZ0J1dHRvbihpbmZvKSkpfT5cclxuICAgICAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdCb2R5IGFzIG5ldmVyLCBtb2RpZnlCb2R5UHJvcHMobWFrZVByb3BzQm9keShpbmZvKSkpfVxyXG4gICAgICAgICAgICAgICAgPC9IZWFkaW5nPlxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBBY2NvcmRpb25TZWN0aW9uID0gbWVtbyhmdW5jdGlvbiBBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcclxuICAgIG9wZW4sXHJcbiAgICBpbmRleCxcclxuICAgIHRhZ0J1dHRvbixcclxuICAgIGRpc2FibGVkLFxyXG4gICAgcmVuZGVyLFxyXG4gICAgZ2V0RG9jdW1lbnQsXHJcbiAgICBnZXRXaW5kb3csXHJcbiAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsXHJcbiAgICBvbkVsZW1lbnRDaGFuZ2UsXHJcbiAgICBvbkZvY3VzZWRDaGFuZ2VkLFxyXG4gICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLFxyXG4gICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSxcclxuICAgIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLFxyXG4gICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCxcclxuICAgIG9uTW91bnQsXHJcbiAgICBvblVubW91bnQsXHJcbiAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2VcclxufTogQWNjb3JkaW9uU2VjdGlvblByb3BzPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50Pikge1xyXG4gICAgY29uc3QgdXNlQWNjb3JkaW9uU2VjdGlvbiA9IHVzZUNvbnRleHQoQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQpO1xyXG4gICAgY29uc3QgeyB1c2VBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzLCB1c2VBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHMsIC4uLnNlY3Rpb25JbmZvIH0gPSB1c2VBY2NvcmRpb25TZWN0aW9uKHtcclxuICAgICAgICBidXR0b246IHsgZGlzYWJsZWQsIHRhZ0J1dHRvbiB9LFxyXG4gICAgICAgIGFjY29yZGlvblNlY3Rpb246IHsgb3BlbiB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBpbmRleCB9LFxyXG4gICAgICAgIGhhc0ZvY3VzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVuZGVyKHNlY3Rpb25JbmZvLCB1c2VBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHMsIHVzZUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHMpO1xyXG59KVxyXG5cclxuXHJcbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwicHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQ2hlY2tib3gsIFVzZUNoZWNrYm94UGFyYW1ldGVycywgVXNlQ2hlY2tib3hSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtY2hlY2tib3hcIjtcclxuXHJcbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94UHJvcHM8SSBleHRlbmRzIEhUTUxFbGVtZW50LCBMIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDxVc2VDaGVja2JveFBhcmFtZXRlcnM8SSwgTD4sIFwiY2hlY2tib3hMaWtlXCI+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94UGFyYW1ldGVyczxJLCBMPiwgXCJjaGVja2JveFwiPixcclxuICAgIEdldDxVc2VDaGVja2JveFBhcmFtZXRlcnM8SSwgTD4sIFwibGFiZWxcIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hQYXJhbWV0ZXJzPEksIEw+LCBcImhhc0ZvY3VzSW5wdXRcIj4ge1xyXG4gICAgcmVuZGVyKGluZm86IFVzZUNoZWNrYm94UmV0dXJuVHlwZUluZm88SSwgTD4sIG1vZGlmeUlucHV0UHJvcHM6IFByb3BNb2RpZmllcjxJPiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPEw+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDaGVja2JveExpa2U8SSBleHRlbmRzIEhUTUxFbGVtZW50LCBMIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEluZm9UeXBlPih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZUlucHV0UHJvcHMsIG1ha2VMYWJlbFByb3BzIH06IERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIEwsIEluZm9UeXBlPikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBJbmZvVHlwZSwgbW9kaWZ5SW5wdXRQcm9wczogUHJvcE1vZGlmaWVyPEk+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TD4pOiBWTm9kZTxhbnk+IHtcclxuXHJcbiAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlucHV0UHJvcHNCYXNlID0gbWFrZUlucHV0UHJvcHMoaW5mbyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsUHJvcHNCYXNlID0gbWFrZUxhYmVsUHJvcHMoaW5mbyk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpbnB1dFByb3BzID0gbW9kaWZ5SW5wdXRQcm9wcyhpbnB1dFByb3BzQmFzZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLmxhYmVsUHJvcHMgfSA9IG1vZGlmeUxhYmVsUHJvcHMobGFiZWxQcm9wc0Jhc2UpO1xyXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNyZWF0ZUVsZW1lbnQodGFnSW5wdXQgYXMgbmV2ZXIsIGlucHV0UHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwgYXMgbmV2ZXIsIHsgLi4ubGFiZWxQcm9wcywgY2hpbGRyZW46IDw+e2lucHV0fXtjaGlsZHJlbn08Lz4gfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgICAgICB7bGFiZWx9XHJcbiAgICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIikge1xyXG4gICAgICAgICAgICBjb25zdCBpbnB1dFByb3BzID0gbW9kaWZ5SW5wdXRQcm9wcyhtYWtlSW5wdXRQcm9wcyhpbmZvKSlcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxQcm9wcyA9IG1vZGlmeUxhYmVsUHJvcHMobWFrZUxhYmVsUHJvcHMoaW5mbykpXHJcblxyXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNyZWF0ZUVsZW1lbnQodGFnSW5wdXQgYXMgbmV2ZXIsIGlucHV0UHJvcHMpO1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwgYXMgbmV2ZXIsIGxhYmVsUHJvcHMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICAgICAge2lucHV0fVxyXG4gICAgICAgICAgICAgICAgICAgIHtsYWJlbH1cclxuICAgICAgICAgICAgICAgIDwvPlxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB1c2VyUHJvcHMgPSBtYWtlSW5wdXRQcm9wcyhpbmZvKTtcclxuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoISF1c2VyUHJvcHNbXCJhcmlhLWxhYmVsXCJdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnSW5wdXQgYXMgbmV2ZXIsIG1vZGlmeUlucHV0UHJvcHModXNlclByb3BzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50LCBJbmZvVHlwZT4ge1xyXG4gICAgbGFiZWxQb3NpdGlvbjogXCJ3cmFwcGluZ1wiIHwgXCJzZXBhcmF0ZVwiIHwgXCJoaWRkZW5cIixcclxuICAgIHRhZ0lucHV0OiBFbGVtZW50VG9UYWc8ST4sXHJcbiAgICB0YWdMYWJlbDogRWxlbWVudFRvVGFnPEw+LFxyXG4gICAgbWFrZUlucHV0UHJvcHM6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST4sXHJcbiAgICBtYWtlTGFiZWxQcm9wczogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMPlxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRSZW5kZXJDaGVja2JveFBhcmFtZXRlcnM8SSBleHRlbmRzIEhUTUxFbGVtZW50LCBMIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgTCwgVXNlQ2hlY2tib3hSZXR1cm5UeXBlSW5mbzxJLCBMPj4geyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNoZWNrYm94PEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZUlucHV0UHJvcHMsIG1ha2VMYWJlbFByb3BzIH06IERlZmF1bHRSZW5kZXJDaGVja2JveFBhcmFtZXRlcnM8SSwgTD4pIHtcclxuICAgIHJldHVybiBkZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlPEksIEwsIFVzZUNoZWNrYm94UmV0dXJuVHlwZUluZm88SSwgTD4+KHsgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsLCBtYWtlSW5wdXRQcm9wcywgbWFrZUxhYmVsUHJvcHMgfSk7XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGNvbnN0IENoZWNrYm94ID0gbWVtbyhmdW5jdGlvbiBDaGVja2JveDxJIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEwgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBjaGVja2VkLCBkaXNhYmxlZCwgdGFnTGFiZWwsIGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCBvbkNoZWNrZWRDaGFuZ2UsIHJlbmRlciwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH06IENoZWNrYm94UHJvcHM8SSwgTD4pIHtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50LCAuLi5jaGVja2JveEluZm8gfSA9IHVzZUNoZWNrYm94PEksIEw+KHtcclxuICAgICAgICBjaGVja2JveDogeyBvbkNoZWNrZWRDaGFuZ2UgfSxcclxuICAgICAgICBjaGVja2JveExpa2U6IHsgY2hlY2tlZCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24gfSxcclxuICAgICAgICBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSxcclxuICAgICAgICBoYXNGb2N1c0lucHV0OiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9LFxyXG4gICAgICAgIGhhc0ZvY3VzTGFiZWw6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2U6IG9uRWxlbWVudENoYW5nZSBhcyBhbnksIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQ6IG9uTW91bnQgYXMgYW55LCBvblVubW91bnQ6IG9uVW5tb3VudCBhcyBhbnksIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKTtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoKTtcclxuXHJcblxyXG4gICAgcmV0dXJuIHJlbmRlcihjaGVja2JveEluZm8sIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMsIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMpO1xyXG59KVxyXG4iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCwgaCwgUmVuZGVyYWJsZVByb3BzLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VDaGVja2JveEdyb3VwLCBVc2VDaGVja2JveEdyb3VwQ2hpbGQsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvLCBVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVycywgVXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtY2hlY2tib3gtZ3JvdXBcIjtcclxuaW1wb3J0IHsgZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSwgRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9jaGVja2JveFwiO1xyXG5cclxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcclxudHlwZSBHZXQyPFQsIEsgZXh0ZW5kcyBrZXlvZiBULCBLMiBleHRlbmRzIGtleW9mIFRbS10+ID0gVFtLXVtLMl07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94R3JvdXBQcm9wczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBSZW5kZXJhYmxlUHJvcHM8e30+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkcmVuXCI+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImNoZWNrYm94XCI+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJjaGVja2JveExpa2VcIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImxhYmVsXCI+IHtcclxuICAgIGdldERvY3VtZW50OiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8SW5wdXRFbGVtZW50PltcImdldERvY3VtZW50XCJdO1xyXG4gICAgZ2V0V2luZG93PzogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPElucHV0RWxlbWVudD5bXCJnZXRXaW5kb3dcIl07XHJcbiAgICByZW5kZXIoaW5mbzogVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgbW9kaWZ5SW5wdXRQcm9wczogUHJvcE1vZGlmaWVyPElucHV0RWxlbWVudD4sIGxhYmVsOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50Pik6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tib3hHcm91cENoZWNrYm94UHJvcHM8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xyXG4gICAgR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgXCJhc0NoZWNrYm94XCIsIFwiY2hlY2tib3hcIj4sXHJcbiAgICBHZXQyPFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBcImFzQ2hlY2tib3hcIiwgXCJsYWJlbFwiPixcclxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveFwiLCBcImNoZWNrYm94TGlrZVwiPixcclxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveEdyb3VwQ2hpbGRcIiwgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveEdyb3VwQ2hpbGRcIiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveEdyb3VwQ2hpbGRcIiwgXCJtYW5hZ2VkQ2hpbGRcIj4ge1xyXG4gICAgZ2V0RG9jdW1lbnQ6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxJbnB1dFR5cGU+W1wiZ2V0RG9jdW1lbnRcIl07XHJcbiAgICBnZXRXaW5kb3c/OiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8SW5wdXRUeXBlPltcImdldFdpbmRvd1wiXTtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIG1vZGlmeUlucHV0UHJvcHM6IFByb3BNb2RpZmllcjxJbnB1dFR5cGU+LCBsYWJlbDogUHJvcE1vZGlmaWVyPExhYmVsVHlwZT4pOiBWTm9kZTxhbnk+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZSwgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRUeXBlLCBMYWJlbFR5cGU+PiB7IH1cclxuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cFBhcmFtZXRlcnM8SW5wdXRUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlLCBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZUluZm88SW5wdXRUeXBlLCBMYWJlbFR5cGU+PiB7XHJcbiAgICBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cENoaWxkPElucHV0VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyB0YWdJbnB1dCwgdGFnTGFiZWwsIGxhYmVsUG9zaXRpb24sIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcyB9OiBEZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBtb2RpZnlJbnB1dFByb3BzOiBQcm9wTW9kaWZpZXI8SW5wdXRUeXBlPiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsVHlwZT4pOiBWTm9kZTxhbnk+IHtcclxuICAgICAgICByZXR1cm4gZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSh7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZUlucHV0UHJvcHMsIG1ha2VMYWJlbFByb3BzIH0pKGluZm8sIG1vZGlmeUlucHV0UHJvcHMsIG1vZGlmeUxhYmVsUHJvcHMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXA8SW5wdXRUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGNoaWxkcmVuLCBsYWJlbFBvc2l0aW9uLCBtYWtlSW5wdXRQcm9wcywgbWFrZUxhYmVsUHJvcHMsIHRhZ0lucHV0LCB0YWdMYWJlbCB9OiBEZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxhbnksIGFueT4sIG1vZGlmeUlucHV0UHJvcHM6IFByb3BNb2RpZmllcjxJbnB1dFR5cGU+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxUeXBlPik6IFZOb2RlPGFueT4ge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICB7ZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSh7IGxhYmVsUG9zaXRpb24sIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcywgdGFnSW5wdXQsIHRhZ0xhYmVsIH0pKGluZm8sIG1vZGlmeUlucHV0UHJvcHMsIG1vZGlmeUxhYmVsUHJvcHMpfVxyXG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUNoZWNrYm94R3JvdXBDaGlsZDxhbnksIGFueT4+KG51bGwhKTtcclxuZXhwb3J0IGNvbnN0IENoZWNrYm94R3JvdXAgPSBtZW1vKGZ1bmN0aW9uIENoZWNrYm94R3JvdXA8SW5wdXRUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEhUTUxFbGVtZW50Pih7XHJcbiAgICBkaXNhYmxlZDogcGFyZW50RGlzYWJsZWQsXHJcbiAgICB0YWdJbnB1dCxcclxuICAgIHRhZ0xhYmVsLFxyXG4gICAgcmVuZGVyLFxyXG4gICAgZ2V0RG9jdW1lbnQsXHJcbiAgICBnZXRXaW5kb3csXHJcbiAgICBsYWJlbFBvc2l0aW9uLFxyXG4gICAgaW5pdGlhbEluZGV4LFxyXG4gICAgY29sbGF0b3IsXHJcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxyXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxyXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcclxuICAgIG5vVHlwZWFoZWFkLFxyXG4gICAgdHlwZWFoZWFkVGltZW91dCxcclxuICAgIGluZGV4RGVtYW5nbGVyLFxyXG4gICAgaW5kZXhNYW5nbGVyLFxyXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxyXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZVJlbmRlclxyXG59OiBDaGVja2JveEdyb3VwUHJvcHM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlQ2hlY2tib3hHcm91cENoaWxkLFxyXG4gICAgICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dCxcclxuICAgICAgICAuLi5jaGVja2JveEdyb3VwUGFyZW50SW5mb1xyXG4gICAgfSA9IHVzZUNoZWNrYm94R3JvdXA8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciB9LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH1cclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzLCB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyB9ID0gdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0KHsgY2hlY2tib3g6IHt9LCBjaGVja2JveExpa2U6IHsgZGlzYWJsZWQ6IHBhcmVudERpc2FibGVkLCBsYWJlbFBvc2l0aW9uIH0sIGxhYmVsOiB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9LCBoYXNGb2N1c0lucHV0OiB7IGdldFdpbmRvdywgZ2V0RG9jdW1lbnQgfSwgaGFzRm9jdXNMYWJlbDogeyBnZXRXaW5kb3csIGdldERvY3VtZW50IH0gfSk7XHJcblxyXG5cclxuICAgIGxldCB3cmFwcGluZzogVk5vZGU8YW55PjtcclxuICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIikge1xyXG4gICAgICAgIHdyYXBwaW5nID0gcmVuZGVyKGNoZWNrYm94R3JvdXBQYXJlbnRJbmZvLCB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcywgdXNlQ2hlY2tib3hHcm91cFBhcmVudExhYmVsUHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd3JhcHBpbmcgPSByZW5kZXIoY2hlY2tib3hHcm91cFBhcmVudEluZm8sIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzLCB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8VXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlQ2hlY2tib3hHcm91cENoaWxkfT57d3JhcHBpbmd9PC9Vc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG59KVxyXG5cclxuZXhwb3J0IGNvbnN0IENoZWNrYm94R3JvdXBDaGVja2JveCA9IG1lbW8oZnVuY3Rpb24gQ2hlY2tib3hHcm91cENoZWNrYm94PElucHV0VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oe1xyXG4gICAgY2hlY2tlZCxcclxuICAgIGRpc2FibGVkLFxyXG4gICAgaW5kZXgsXHJcbiAgICBsYWJlbFBvc2l0aW9uLFxyXG4gICAgdGFnSW5wdXQsXHJcbiAgICB0YWdMYWJlbCxcclxuICAgIHRleHQsXHJcbiAgICBnZXRXaW5kb3csXHJcbiAgICBnZXREb2N1bWVudCxcclxuICAgIGZsYWdzLFxyXG4gICAgZm9jdXNTZWxmLFxyXG4gICAgaGlkZGVuLFxyXG4gICAgb25DaGVja2VkQ2hhbmdlLFxyXG4gICAgcmVuZGVyXHJcbn06IENoZWNrYm94R3JvdXBDaGVja2JveFByb3BzPElucHV0VHlwZSwgTGFiZWxUeXBlPikge1xyXG4gICAgY29uc3QgeyB1c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzLCB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzLCAuLi5jaGVja2JveEdyb3VwQ2hpbGRJbmZvIH0gPSB1c2VDb250ZXh0KFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQpKHtcclxuICAgICAgICBhc0NoZWNrYm94OiB7XHJcbiAgICAgICAgICAgIGNoZWNrYm94OiB7IG9uQ2hlY2tlZENoYW5nZSB9LFxyXG4gICAgICAgICAgICBjaGVja2JveExpa2U6IHsgY2hlY2tlZCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24gfSxcclxuICAgICAgICAgICAgbGFiZWw6IHsgdGFnSW5wdXQsIHRhZ0xhYmVsIH0sXHJcbiAgICAgICAgICAgIGhhc0ZvY3VzSW5wdXQ6IHsgZ2V0V2luZG93LCBnZXREb2N1bWVudCB9LFxyXG4gICAgICAgICAgICBoYXNGb2N1c0xhYmVsOiB7IGdldFdpbmRvdywgZ2V0RG9jdW1lbnQgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXNDaGVja2JveEdyb3VwQ2hpbGQ6IHtcclxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgICAgIHRleHRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgIGZsYWdzXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XHJcbiAgICAgICAgICAgICAgICBmb2N1c1NlbGYsXHJcbiAgICAgICAgICAgICAgICBoaWRkZW5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIikge1xyXG4gICAgICAgIHJldHVybiByZW5kZXIoY2hlY2tib3hHcm91cENoaWxkSW5mbywgdXNlQ2hlY2tib3hHcm91cENoaWxkSW5wdXRQcm9wcywgdXNlQ2hlY2tib3hHcm91cENoaWxkTGFiZWxQcm9wcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcmVuZGVyKGNoZWNrYm94R3JvdXBDaGlsZEluZm8sIHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHMsIHVzZUNoZWNrYm94R3JvdXBDaGlsZExhYmVsUHJvcHMpO1xyXG4gICAgfVxyXG59KTtcclxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgY3JlYXRlUG9ydGFsLCBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VEaWFsb2csIFVzZURpYWxvZ1BhcmFtZXRlcnMsIFVzZURpYWxvZ1JldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS1kaWFsb2dcIjtcclxuXHJcbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERpYWxvZ1Byb3BzPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBEaWFsb2dFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kc1xyXG4gICAgR2V0PFVzZURpYWxvZ1BhcmFtZXRlcnMsIFwic29mdERpc21pc3NcIj4sXHJcbiAgICBHZXQ8VXNlRGlhbG9nUGFyYW1ldGVycywgXCJtb2RhbFwiPixcclxuICAgIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzLFxyXG4gICAgR2V0PFVzZURpYWxvZ1BhcmFtZXRlcnMsIFwiZGlhbG9nXCI+IHtcclxuXHJcbiAgICByZW5kZXIoZGlhbG9nSW5mbzogVXNlRGlhbG9nUmV0dXJuVHlwZUluZm8sIG1vZGlmeUZvY3VzQ29udGFpbmVyUHJvcHM6IFByb3BNb2RpZmllcjxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCBtb2RpZnlEaWFsb2dQcm9wczogUHJvcE1vZGlmaWVyPERpYWxvZ0VsZW1lbnQ+LCBtb2RpZnlUaXRsZVByb3BzOiBQcm9wTW9kaWZpZXI8VGl0bGVFbGVtZW50PiwgbW9kaWZ5Qm9keVByb3BzOiBQcm9wTW9kaWZpZXI8Qm9keUVsZW1lbnQ+LCBtb2RpZnlCYWNrZHJvcFByb3BzOiBQcm9wTW9kaWZpZXI8QmFja2Ryb3BFbGVtZW50Pik6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyUG9ydGFsKHsgcG9ydGFsSWQsIGNoaWxkcmVuIH06IHsgcG9ydGFsSWQ6IHN0cmluZywgY2hpbGRyZW46IFZOb2RlIH0pIHtcclxuICAgIGNvbnN0IHBvcnRhbFJlZiA9IHVzZVJlZjxIVE1MRWxlbWVudD4obnVsbCEpO1xyXG4gICAgcG9ydGFsUmVmLmN1cnJlbnQgPz89IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBvcnRhbElkKSE7XHJcbiAgICBpZiAocG9ydGFsUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgcG9ydGFsUmVmLmN1cnJlbnQpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJNb2RhbDxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEluZm9UeXBlPih7IHBvcnRhbElkLCB0YWdGb2N1c0NvbnRhaW5lciwgdGFnQmFja2Ryb3AsIHRhZ0JvZHksIHRhZ0RpYWxvZywgdGFnVGl0bGUsIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyLCBtYWtlUHJvcHNCYWNrZHJvcCwgbWFrZVByb3BzQm9keSwgbWFrZVByb3BzRGlhbG9nLCBtYWtlUHJvcHNUaXRsZSB9OiB7IHBvcnRhbElkOiBzdHJpbmcsIHRhZ0ZvY3VzQ29udGFpbmVyOiBFbGVtZW50VG9UYWc8Rm9jdXNDb250YWluZXJFbGVtZW50PiwgdGFnRGlhbG9nOiBFbGVtZW50VG9UYWc8RGlhbG9nRWxlbWVudD47IHRhZ1RpdGxlOiBFbGVtZW50VG9UYWc8VGl0bGVFbGVtZW50PjsgdGFnQm9keTogRWxlbWVudFRvVGFnPEJvZHlFbGVtZW50PjsgdGFnQmFja2Ryb3A6IEVsZW1lbnRUb1RhZzxCYWNrZHJvcEVsZW1lbnQ+LCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lcjogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCBtYWtlUHJvcHNEaWFsb2c6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RGlhbG9nRWxlbWVudD4sIG1ha2VQcm9wc0JvZHk6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+LCBtYWtlUHJvcHNUaXRsZTogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+LCBtYWtlUHJvcHNCYWNrZHJvcDogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZGlhbG9nSW5mbzogSW5mb1R5cGUsIG1vZGlmeUZvY3VzQ29udGFpbmVyUHJvcHM6IFByb3BNb2RpZmllcjxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCBtb2RpZnlEaWFsb2dQcm9wczogUHJvcE1vZGlmaWVyPERpYWxvZ0VsZW1lbnQ+LCBtb2RpZnlUaXRsZVByb3BzOiBQcm9wTW9kaWZpZXI8VGl0bGVFbGVtZW50PiwgbW9kaWZ5Qm9keVByb3BzOiBQcm9wTW9kaWZpZXI8Qm9keUVsZW1lbnQ+LCBtb2RpZnlCYWNrZHJvcFByb3BzOiBQcm9wTW9kaWZpZXI8QmFja2Ryb3BFbGVtZW50Pik6IFZOb2RlPGFueT4ge1xyXG5cclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiB0aXRsZUNoaWxkcmVuLCAuLi50aXRsZVByb3BzIH0gPSBtb2RpZnlUaXRsZVByb3BzKG1ha2VQcm9wc1RpdGxlKGRpYWxvZ0luZm8pKTtcclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBib2R5Q2hpbGRyZW4sIC4uLmJvZHlQcm9wcyB9ID0gbW9kaWZ5Qm9keVByb3BzKG1ha2VQcm9wc0JvZHkoZGlhbG9nSW5mbykpO1xyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IGRpYWxvZ0NoaWxkcmVuLCAuLi5kaWFsb2dQcm9wcyB9ID0gbW9kaWZ5RGlhbG9nUHJvcHMobWFrZVByb3BzRGlhbG9nKGRpYWxvZ0luZm8pKTtcclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBiYWNrZHJvcENoaWxkcmVuLCAuLi5iYWNrZHJvcFByb3BzIH0gPSBtb2RpZnlCYWNrZHJvcFByb3BzKG1ha2VQcm9wc0JhY2tkcm9wKGRpYWxvZ0luZm8pKTtcclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBmb2N1c0NvbnRhaW5lckNoaWxkcmVuLCAuLi5mb2N1c0NvbnRhaW5lclByb3BzIH0gPSBtb2RpZnlGb2N1c0NvbnRhaW5lclByb3BzKG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyKGRpYWxvZ0luZm8pKTtcclxuXHJcbiAgICAgICAgY29uc3QgdGl0bGUgPSBjcmVhdGVFbGVtZW50KHRhZ1RpdGxlIGFzIG5ldmVyLCB0aXRsZVByb3BzLCB0aXRsZUNoaWxkcmVuKTtcclxuICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRWxlbWVudCh0YWdCb2R5IGFzIG5ldmVyLCBib2R5UHJvcHMsIGJvZHlDaGlsZHJlbik7XHJcbiAgICAgICAgY29uc3QgZGlhbG9nID0gY3JlYXRlRWxlbWVudCh0YWdEaWFsb2cgYXMgbmV2ZXIsIGRpYWxvZ1Byb3BzLCBkaWFsb2dDaGlsZHJlbiwgdGl0bGUsIGJvZHkpO1xyXG5cclxuICAgICAgICBjb25zdCBiYWNrZHJvcCA9IGNyZWF0ZUVsZW1lbnQodGFnQmFja2Ryb3AgYXMgbmV2ZXIsIGJhY2tkcm9wUHJvcHMsIGJhY2tkcm9wQ2hpbGRyZW4pO1xyXG4gICAgICAgIGNvbnN0IGZvY3VzQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudCh0YWdGb2N1c0NvbnRhaW5lciBhcyBuZXZlciwgZm9jdXNDb250YWluZXJQcm9wcywgPGRpdj57Zm9jdXNDb250YWluZXJDaGlsZHJlbn17ZGlhbG9nfXtiYWNrZHJvcH08L2Rpdj4pO1xyXG5cclxuICAgICAgICByZXR1cm4gZGVmYXVsdFJlbmRlclBvcnRhbCh7XHJcbiAgICAgICAgICAgIHBvcnRhbElkLFxyXG4gICAgICAgICAgICBjaGlsZHJlbjogZm9jdXNDb250YWluZXJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckRpYWxvZzxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgcG9ydGFsSWQsIHRhZ0ZvY3VzQ29udGFpbmVyLCB0YWdCYWNrZHJvcCwgdGFnQm9keSwgdGFnRGlhbG9nLCB0YWdUaXRsZSwgbWFrZVByb3BzRm9jdXNDb250YWluZXIsIG1ha2VQcm9wc0JhY2tkcm9wLCBtYWtlUHJvcHNCb2R5LCBtYWtlUHJvcHNEaWFsb2csIG1ha2VQcm9wc1RpdGxlIH06IHsgcG9ydGFsSWQ6IHN0cmluZywgdGFnRm9jdXNDb250YWluZXI6IEVsZW1lbnRUb1RhZzxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCB0YWdEaWFsb2c6IEVsZW1lbnRUb1RhZzxEaWFsb2dFbGVtZW50PjsgdGFnVGl0bGU6IEVsZW1lbnRUb1RhZzxUaXRsZUVsZW1lbnQ+OyB0YWdCb2R5OiBFbGVtZW50VG9UYWc8Qm9keUVsZW1lbnQ+OyB0YWdCYWNrZHJvcDogRWxlbWVudFRvVGFnPEJhY2tkcm9wRWxlbWVudD4sIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyOiAoaW5mbzogVXNlRGlhbG9nUmV0dXJuVHlwZUluZm8pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD4sIG1ha2VQcm9wc0RpYWxvZzogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxEaWFsb2dFbGVtZW50PiwgbWFrZVByb3BzQm9keTogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4sIG1ha2VQcm9wc1RpdGxlOiAoaW5mbzogVXNlRGlhbG9nUmV0dXJuVHlwZUluZm8pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD4sIG1ha2VQcm9wc0JhY2tkcm9wOiAoaW5mbzogVXNlRGlhbG9nUmV0dXJuVHlwZUluZm8pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJNb2RhbDxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCwgVXNlRGlhbG9nUmV0dXJuVHlwZUluZm8+KHsgcG9ydGFsSWQsIHRhZ0ZvY3VzQ29udGFpbmVyLCB0YWdCYWNrZHJvcCwgdGFnQm9keSwgdGFnRGlhbG9nLCB0YWdUaXRsZSwgbWFrZVByb3BzRm9jdXNDb250YWluZXIsIG1ha2VQcm9wc0JhY2tkcm9wLCBtYWtlUHJvcHNCb2R5LCBtYWtlUHJvcHNEaWFsb2csIG1ha2VQcm9wc1RpdGxlIH0pO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgRGlhbG9nID0gbWVtbyhmdW5jdGlvbiBEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7XHJcbiAgICBvbkNsb3NlLFxyXG4gICAgb3BlbixcclxuICAgIGJvZHlJc09ubHlTZW1hbnRpYyxcclxuICAgIGdldERvY3VtZW50LFxyXG4gICAgZ2V0V2luZG93LFxyXG4gICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlLFxyXG4gICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSxcclxuICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZSxcclxuICAgIGZvY3VzU2VsZixcclxuICAgIHJlbmRlclxyXG59OiBEaWFsb2dQcm9wczxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VEaWFsb2dCYWNrZHJvcCxcclxuICAgICAgICB1c2VEaWFsb2dCb2R5LFxyXG4gICAgICAgIHVzZURpYWxvZ1Byb3BzLFxyXG4gICAgICAgIHVzZURpYWxvZ1RpdGxlLFxyXG4gICAgICAgIHVzZURpYWxvZ0ZvY3VzQ29udGFpbmVyUHJvcHMsXHJcbiAgICAgICAgLi4uclxyXG4gICAgfSA9IHVzZURpYWxvZzxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudD4oeyBkaWFsb2c6IHsgb25DbG9zZSB9LCBtb2RhbDogeyBib2R5SXNPbmx5U2VtYW50aWMsIGZvY3VzU2VsZiB9LCBzb2Z0RGlzbWlzczogeyBvcGVuIH0sIGFjdGl2ZUVsZW1lbnQ6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UgfSB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZURpYWxvZ1RpdGxlUHJvcHMgfSA9IHVzZURpYWxvZ1RpdGxlKCk7XHJcbiAgICBjb25zdCB7IHVzZURpYWxvZ0JvZHlQcm9wcyB9ID0gdXNlRGlhbG9nQm9keSgpO1xyXG4gICAgY29uc3QgeyB1c2VEaWFsb2dCYWNrZHJvcFByb3BzIH0gPSB1c2VEaWFsb2dCYWNrZHJvcCgpO1xyXG5cclxuICAgIHJldHVybiByZW5kZXIociwgdXNlRGlhbG9nRm9jdXNDb250YWluZXJQcm9wcywgdXNlRGlhbG9nUHJvcHMsIHVzZURpYWxvZ1RpdGxlUHJvcHMsIHVzZURpYWxvZ0JvZHlQcm9wcywgdXNlRGlhbG9nQmFja2Ryb3BQcm9wcyk7XHJcblxyXG59KTtcclxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xyXG4vL2ltcG9ydCB7IEVsZW1lbnRUb1RhZyB9IGZyb20gXCIuLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VMaXN0Ym94U2luZ2xlLCB1c2VMaXN0Ym94R3JvdXAsIFVzZUxpc3Rib3hTaW5nbGVJdGVtLCBVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnMsIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm8sIFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzLCBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLWxpc3Rib3gtc2luZ2xlXCI7XHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94U2luZ2xlUHJvcHM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwic2luZ2xlU2VsZWN0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwiY2hpbGRyZW5IYXZlRm9jdXNcIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibGlzdGJveFNpbmdsZVwiPiB7XHJcbiAgICAvL3RhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PjtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiwgbW9kaWZ5UHJvcHNMYWJlbDogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4sIG1vZGlmeVByb3BzTGlzdDogUHJvcE1vZGlmaWVyPExpc3RFbGVtZW50Pik6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94U2luZ2xlSXRlbVByb3BzPExpc3Rib3hJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnM8TGlzdGJveEl0ZW1FbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXHJcbiAgICBPbWl0PEdldDxVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnM8TGlzdGJveEl0ZW1FbGVtZW50PiwgXCJsaXN0TmF2aWdhdGlvblwiPiwgXCJzdWJJbmZvXCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVyczxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVyczxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBcImhhc0ZvY3VzXCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVyczxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBcImxpc3Rib3hTaW5nbGVJdGVtXCI+IHtcclxuICAgIC8vdGFnTGlzdEl0ZW06IEVsZW1lbnRUb1RhZzxMaXN0Ym94SXRlbUVsZW1lbnQ+O1xyXG4gICAgcmVuZGVyKGluZm86IFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm88TGlzdGJveEl0ZW1FbGVtZW50PiwgbW9kaWZ5TGlzdEl0ZW1Qcm9wczogUHJvcE1vZGlmaWVyPExpc3Rib3hJdGVtRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xyXG59XHJcblxyXG5jb25zdCBMaXN0Ym94U2luZ2xlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTGlzdGJveFNpbmdsZUl0ZW08YW55Pj4obnVsbCEpO1xyXG5cclxuZnVuY3Rpb24gTGlzdGJveFNpbmdsZVU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcclxuICAgIHJlbmRlcixcclxuXHJcbiAgICBzZWxlY3RlZEluZGV4LFxyXG4gICAgdGFnTGFiZWwsXHJcbiAgICBjb2xsYXRvcixcclxuICAgIGRpc2FibGVBcnJvd0tleXMsXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICBpbmRleERlbWFuZ2xlcixcclxuICAgIGluZGV4TWFuZ2xlcixcclxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXHJcbiAgICBub1R5cGVhaGVhZCxcclxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcclxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVSZW5kZXIsXHJcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxyXG4gICAgb25BbGxMb3N0Rm9jdXMsXHJcbiAgICBvbkFueUdhaW5lZEZvY3VzLFxyXG4gICAgc2VsZWN0aW9uTW9kZSxcclxuICAgIHRhZ0xpc3QsXHJcbiAgICBvblNlbGVjdFxyXG59OiBMaXN0Ym94U2luZ2xlUHJvcHM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50Pikge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVJdGVtLFxyXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCxcclxuICAgICAgICB1c2VMaXN0Ym94U2luZ2xlUHJvcHMsXHJcbiAgICAgICAgLi4ubGlzdGJveFJldHVyblR5cGVcclxuICAgIH0gPSB1c2VMaXN0Ym94U2luZ2xlPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXHJcbiAgICAgICAgbGlzdGJveFNpbmdsZTogeyB0YWdMYWJlbCwgdGFnTGlzdCwgb25TZWxlY3QgfSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXHJcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXgsIHNlbGVjdGlvbk1vZGUgfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9LFxyXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHMgfSA9IHVzZUxpc3Rib3hTaW5nbGVMYWJlbCgpO1xyXG4gICAgLy9jb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwsIHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzKHt9KSBhcyBhbnkpO1xyXG4gICAgLy9jb25zdCBsaXN0ID0gY3JlYXRlRWxlbWVudCh0YWdMaXN0LCB1c2VMaXN0Ym94U2luZ2xlUHJvcHMoeyBjaGlsZHJlbjogdm5vZGVDaGlsZHJlbiwgcmVmIH0pIGFzIGFueSk7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPExpc3Rib3hTaW5nbGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VMaXN0Ym94U2luZ2xlSXRlbX0+XHJcbiAgICAgICAgICAgIHtyZW5kZXIoeyAuLi5saXN0Ym94UmV0dXJuVHlwZSB9LCB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcywgdXNlTGlzdGJveFNpbmdsZVByb3BzKX1cclxuICAgICAgICA8L0xpc3Rib3hTaW5nbGVDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckxpc3Rib3hTaW5nbGU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNMaXN0LCBtYWtlUHJvcHNMYWJlbCwgdGFnTGFiZWwsIHRhZ0xpc3QgfTogeyB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD4sIHRhZ0xpc3Q6IEVsZW1lbnRUb1RhZzxMaXN0RWxlbWVudD4sIG1ha2VQcm9wc0xhYmVsOiAoaW5mbzogVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4sIG1ha2VQcm9wc0xpc3Q6IChpbmZvOiBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBkZWZhdWx0UmVuZGVyTGlzdDxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50Pj4oeyBtYWtlUHJvcHNMYWJlbCwgbWFrZVByb3BzTGlzdCwgdGFnTGFiZWwsIHRhZ0xpc3QgfSlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJMaXN0Ym94U2luZ2xlSXRlbTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBtYWtlUHJvcHNMaXN0SXRlbSwgdGFnTGlzdEl0ZW0gfTogeyB0YWdMaXN0SXRlbTogRWxlbWVudFRvVGFnPExpc3RJdGVtRWxlbWVudD4sIG1ha2VQcm9wc0xpc3RJdGVtOiAoaW5mbzogVXNlTGlzdGJveFNpbmdsZUl0ZW1SZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0SXRlbUVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBkZWZhdWx0UmVuZGVyTGlzdEl0ZW08TGlzdEl0ZW1FbGVtZW50LCBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4+KHsgbWFrZVByb3BzTGlzdEl0ZW0sIHRhZ0xpc3RJdGVtIH0pO1xyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIExpc3Rib3hTaW5nbGVJdGVtVTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGluZGV4LCBkaXNhYmxlZCwgZmxhZ3MsIGZvY3VzU2VsZiwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCByZW5kZXIsIHRleHQsIGhpZGRlbiB9OiBMaXN0Ym94U2luZ2xlSXRlbVByb3BzPExpc3RJdGVtRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHsgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcywgcm92aW5nVGFiSW5kZXgsIHNpbmdsZVNlbGVjdGlvbiB9ID0gdXNlQ29udGV4dChMaXN0Ym94U2luZ2xlQ29udGV4dCkoe1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbiB9LFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcclxuICAgICAgICBsaXN0Ym94U2luZ2xlSXRlbTogeyBkaXNhYmxlZCB9LFxyXG4gICAgICAgIGhhc0ZvY3VzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+e3JlbmRlcih7IHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24gfSwgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyl9PC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBMaXN0Ym94U2luZ2xlID0gbWVtbyhMaXN0Ym94U2luZ2xlVSkgYXMgdHlwZW9mIExpc3Rib3hTaW5nbGVVO1xyXG5leHBvcnQgY29uc3QgTGlzdGJveFNpbmdsZUl0ZW0gPSBtZW1vKExpc3Rib3hTaW5nbGVJdGVtVSkgYXMgdHlwZW9mIExpc3Rib3hTaW5nbGVJdGVtVTtcclxuZXhwb3J0IGNvbnN0IExpc3Rib3hHcm91cCA9IG1lbW8oTGlzdGJveEdyb3VwVSkgYXMgdHlwZW9mIExpc3Rib3hHcm91cFU7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIExpc3Rib3hHcm91cFByb3BzPENvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICByZW5kZXIobW9kaWZ5Q29udGFpbmVyUHJvcHM6IFByb3BNb2RpZmllcjxDb250YWluZXJFbGVtZW50PiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4pOiBWTm9kZTtcclxufVxyXG5cclxuZnVuY3Rpb24gTGlzdGJveEdyb3VwVTxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIgfTogTGlzdGJveEdyb3VwUHJvcHM8Q29udGFpbmVyRWxlbWVudCwgTGFiZWxFbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VMaXN0Ym94R3JvdXBIZWFkaW5nUHJvcHMsIHVzZUxpc3Rib3hHcm91cENvbnRhaW5lclByb3BzIH0gPSB1c2VMaXN0Ym94R3JvdXA8Q29udGFpbmVyRWxlbWVudCwgTGFiZWxFbGVtZW50PigpO1xyXG4gICAgcmV0dXJuIChyZW5kZXIodXNlTGlzdGJveEdyb3VwQ29udGFpbmVyUHJvcHMsIHVzZUxpc3Rib3hHcm91cEhlYWRpbmdQcm9wcykpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0TGlzdGJveEdyb3VwUmVuZGVyPENvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ0NvbnRhaW5lciwgdGFnTGFiZWwsIG1ha2VQcm9wc0NvbnRhaW5lciwgbWFrZVByb3BzTGFiZWwgfTogeyB0YWdDb250YWluZXI6IEVsZW1lbnRUb1RhZzxDb250YWluZXJFbGVtZW50PiwgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+LCBtYWtlUHJvcHNDb250YWluZXI6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENvbnRhaW5lckVsZW1lbnQ+LCBtYWtlUHJvcHNMYWJlbDogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZGlmeUNvbnRhaW5lclByb3BzOiBQcm9wTW9kaWZpZXI8Q29udGFpbmVyRWxlbWVudD4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxMYWJlbEVsZW1lbnQ+KSB7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucHJvcHNDb250YWluZXIgfSA9IG1vZGlmeUNvbnRhaW5lclByb3BzKG1ha2VQcm9wc0NvbnRhaW5lcigpKTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdDb250YWluZXIgYXMgbmV2ZXIsIHByb3BzQ29udGFpbmVyLCA8PlxyXG4gICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdMYWJlbCBhcyBuZXZlciwgbW9kaWZ5TGFiZWxQcm9wcyhtYWtlUHJvcHNMYWJlbCgpKSl9XHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8Lz4pXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJMaXN0PExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEluZm9UeXBlPih7IG1ha2VQcm9wc0xpc3QsIG1ha2VQcm9wc0xhYmVsLCB0YWdMYWJlbCwgdGFnTGlzdCB9OiB7IHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PiwgdGFnTGlzdDogRWxlbWVudFRvVGFnPExpc3RFbGVtZW50PiwgbWFrZVByb3BzTGFiZWw6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiwgbWFrZVByb3BzTGlzdDogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBJbmZvVHlwZSwgbW9kaWZ5UHJvcHNMYWJlbDogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4sIG1vZGlmeVByb3BzTGlzdDogUHJvcE1vZGlmaWVyPExpc3RFbGVtZW50Pik6IFZOb2RlPGFueT4ge1xyXG4gICAgICAgIGNvbnN0IGxhYmVsID0gY3JlYXRlRWxlbWVudCh0YWdMYWJlbCBhcyBuZXZlciwgbW9kaWZ5UHJvcHNMYWJlbChtYWtlUHJvcHNMYWJlbChpbmZvKSkpO1xyXG4gICAgICAgIGNvbnN0IGxpc3QgPSBjcmVhdGVFbGVtZW50KHRhZ0xpc3QgYXMgbmV2ZXIsIG1vZGlmeVByb3BzTGlzdChtYWtlUHJvcHNMaXN0KGluZm8pKSk7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIHtsYWJlbH1cclxuICAgICAgICAgICAgICAgIHtsaXN0fVxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyTGlzdEl0ZW08TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEluZm9UeXBlPih7IG1ha2VQcm9wc0xpc3RJdGVtLCB0YWdMaXN0SXRlbSB9OiB7IHRhZ0xpc3RJdGVtOiBFbGVtZW50VG9UYWc8TGlzdEl0ZW1FbGVtZW50PiwgbWFrZVByb3BzTGlzdEl0ZW06IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEl0ZW1FbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IEluZm9UeXBlLCBtb2RpZnlQcm9wc0xpc3RJdGVtOiBQcm9wTW9kaWZpZXI8TGlzdEl0ZW1FbGVtZW50Pik6IFZOb2RlPGFueT4ge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0xpc3RJdGVtIGFzIG5ldmVyLCBtb2RpZnlQcm9wc0xpc3RJdGVtKG1ha2VQcm9wc0xpc3RJdGVtKGluZm8pKSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XHJcbmltcG9ydCB7IHVzZU1lbnUsIFVzZU1lbnVJdGVtUGFyYW1ldGVycywgVXNlTWVudUl0ZW1SZXR1cm5UeXBlSW5mbywgVXNlTWVudVBhcmFtZXRlcnMsIFVzZU1lbnVSZXR1cm5UeXBlSW5mbywgVXNlTWVudUl0ZW0gfSBmcm9tIFwiLi4vdXNlLW1lbnVcIjtcclxuaW1wb3J0IHsgZGVmYXVsdFJlbmRlclBvcnRhbCB9IGZyb20gXCIuL2RpYWxvZ1wiO1xyXG5cclxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWVudVByb3BzPFN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTZW50aW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyAvL09taXQ8VXNlTWVudVBhcmFtZXRlcnM8RSwgSywgST4sIFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIgfCBcIm9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdFwiIHwgXCJvbkNoaWxkcmVuTW91bnRDaGFuZ2VcIiB8IFwib25UYWJiYWJsZUluZGV4Q2hhbmdlXCIgfCBcIm9uVGFiYmFibGVSZW5kZXJcIiB8IFwib25UYWJiZWRJblRvXCIgfCBcIm9uVGFiYmVkT3V0T2ZcIj4gJiB7XHJcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJtZW51XCI+LFxyXG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPFN1cmZhY2VFbGVtZW50LCBCdXR0b25FbGVtZW50LCBuZXZlcj4sIFwibWVudVN1cmZhY2VcIj4sXHJcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJzb2Z0RGlzbWlzc1wiPixcclxuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxTdXJmYWNlRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgbmV2ZXI+LCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxTdXJmYWNlRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgbmV2ZXI+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPFN1cmZhY2VFbGVtZW50LCBCdXR0b25FbGVtZW50LCBuZXZlcj4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPixcclxuXHJcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4ge1xyXG4gICAgLy9wcm9wc01lbnVCdXR0b246ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT47XHJcbiAgICAvL3Byb3BzTWVudVNlbnRpbmVsOiAod2hpY2g6IFwidG9wXCIgfCBcImJvdHRvbVwiKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+O1xyXG4gICAgLy9wcm9wc01lbnU6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT47XHJcblxyXG4gICAgLy90YWdNZW51QnV0dG9uOiBhbnk7XHJcbiAgICAvL3RhZ01lbnU6IGFueTtcclxuICAgIC8vdGFnU2VudGluZWw6IGFueTtcclxuXHJcbiAgICBnZXREb2N1bWVudDogVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnNbXCJnZXREb2N1bWVudFwiXTtcclxuICAgIGdldFdpbmRvdz86IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzW1wiZ2V0V2luZG93XCJdO1xyXG5cclxuICAgIHJlbmRlcihtZW51SW5mbzogVXNlTWVudVJldHVyblR5cGVJbmZvPFN1cmZhY2VFbGVtZW50LCBNZW51RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBCdXR0b25FbGVtZW50PiwgbW9kaWZ5TWVudUJ1dHRvblByb3BzOiBQcm9wTW9kaWZpZXI8QnV0dG9uRWxlbWVudD4sIG1vZGlmeU1lbnVTdXJmYWNlUHJvcHM6IFByb3BNb2RpZmllcjxTdXJmYWNlRWxlbWVudD4sIG1vZGlmeU1lbnVQcm9wczogUHJvcE1vZGlmaWVyPE1lbnVFbGVtZW50PiwgbW9kaWZ5Rmlyc3RTZW50aW5lbFByb3BzOiBQcm9wTW9kaWZpZXI8U2VudGluZWxFbGVtZW50PiwgbW9kaWZ5TGFzdFNlbnRpbmVsUHJvcHM6IFByb3BNb2RpZmllcjxTZW50aW5lbEVsZW1lbnQ+KTogVk5vZGU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWVudUl0ZW1Qcm9wczxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlTWVudUl0ZW1QYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZFwiPixcclxuICAgIEdldDxVc2VNZW51SXRlbVBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlTWVudUl0ZW1QYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+IHtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VNZW51SXRlbVJldHVyblR5cGVJbmZvPE1lbnVJdGVtRWxlbWVudD4sIG1vZGlmeUxpc3RJdGVtUHJvcHM6IFByb3BNb2RpZmllcjxNZW51SXRlbUVsZW1lbnQ+KTogVk5vZGU7XHJcbiAgICAvL3RhZ01lbnVJdGVtOiBhbnk7XHJcbiAgICAvL3Byb3BzTWVudUl0ZW06ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT5cclxufVxyXG5cclxuY29uc3QgTWVudUl0ZW1Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VNZW51SXRlbTxhbnk+PihudWxsISk7XHJcblxyXG5leHBvcnQgY29uc3QgTWVudSA9IG1lbW8oZnVuY3Rpb24gTWVudTxTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTZW50aW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgaW5pdGlhbEluZGV4LFxyXG4gICAgY29sbGF0b3IsXHJcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxyXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxyXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcclxuICAgIG5vVHlwZWFoZWFkLFxyXG4gICAgdHlwZWFoZWFkVGltZW91dCxcclxuICAgIG9uT3BlbixcclxuICAgIG9uQ2xvc2UsXHJcbiAgICBvcGVuLFxyXG5cclxuICAgIG9wZW5EaXJlY3Rpb24sXHJcbiAgICBpbmRleERlbWFuZ2xlcixcclxuICAgIGluZGV4TWFuZ2xlcixcclxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcclxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVSZW5kZXIsXHJcblxyXG4gICAgZ2V0RG9jdW1lbnQsXHJcbiAgICBnZXRXaW5kb3csXHJcblxyXG4gICAgcmVuZGVyXHJcblxyXG59OiBNZW51UHJvcHM8U3VyZmFjZUVsZW1lbnQsIFBhcmVudEVsZW1lbnQsIFNlbnRpbmVsRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBCdXR0b25FbGVtZW50Pikge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZU1lbnVCdXR0b25Qcm9wcyxcclxuICAgICAgICB1c2VNZW51SXRlbSxcclxuICAgICAgICB1c2VNZW51UHJvcHMsXHJcbiAgICAgICAgdXNlTWVudVNlbnRpbmVsLFxyXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlUHJvcHMsXHJcbiAgICAgICAgLi4ubWVudVJldHVyblxyXG4gICAgfSA9IHVzZU1lbnU8U3VyZmFjZUVsZW1lbnQsIFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQnV0dG9uRWxlbWVudD4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxyXG4gICAgICAgIG1lbnU6IHsgb25PcGVuOiB1c2VTdGFibGVDYWxsYmFjayhvbk9wZW4pLCBvcGVuRGlyZWN0aW9uIH0sXHJcbiAgICAgICAgbWVudVN1cmZhY2U6IHt9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXHJcbiAgICAgICAgc29mdERpc21pc3M6IHsgb25DbG9zZTogdXNlU3RhYmxlQ2FsbGJhY2sob25DbG9zZSksIG9wZW4gfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9LFxyXG4gICAgICAgIGFjdGl2ZUVsZW1lbnQ6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyB9LFxyXG4gICAgICAgIG1lbnVCdXR0b25IYXNGb2N1czogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93IH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTWVudVNlbnRpbmVsUHJvcHM6IHVzZUZpcnN0U2VudGluZWxQcm9wcyB9ID0gdXNlTWVudVNlbnRpbmVsPFNlbnRpbmVsRWxlbWVudD4oKTtcclxuICAgIGNvbnN0IHsgdXNlTWVudVNlbnRpbmVsUHJvcHM6IHVzZUxhc3RTZW50aW5lbFByb3BzIH0gPSB1c2VNZW51U2VudGluZWw8U2VudGluZWxFbGVtZW50PigpO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TWVudUl0ZW1Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VNZW51SXRlbX0+XHJcbiAgICAgICAgICAgIHtyZW5kZXIobWVudVJldHVybiwgdXNlTWVudUJ1dHRvblByb3BzLCB1c2VNZW51U3VyZmFjZVByb3BzLCB1c2VNZW51UHJvcHMsIHVzZUZpcnN0U2VudGluZWxQcm9wcywgdXNlTGFzdFNlbnRpbmVsUHJvcHMpfVxyXG4gICAgICAgIDwvTWVudUl0ZW1Db250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG5cclxufSlcclxuXHJcbmV4cG9ydCBjb25zdCBNZW51SXRlbSA9IG1lbW8oZnVuY3Rpb24gTWVudUl0ZW08TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIsIGluZGV4LCB0ZXh0LCBoaWRkZW4sIGZsYWdzLCBmb2N1c1NlbGYgfTogTWVudUl0ZW1Qcm9wczxNZW51SXRlbUVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZU1lbnVJdGVtUHJvcHMsIC4uLnJlc3QgfSA9IHVzZUNvbnRleHQoTWVudUl0ZW1Db250ZXh0KSh7XHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbiB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZW5kZXIocmVzdCwgdXNlTWVudUl0ZW1Qcm9wcyk7XHJcbn0pXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlck1lbnU8U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNlbnRpbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHBvcnRhbElkLCB0YWdCdXR0b24sIHRhZ01lbnUsIHRhZ1N1cmZhY2UsIHRhZ1NlbnRpbmVsLCBtYWtlUHJvcHNCdXR0b24sIG1ha2VQcm9wc01lbnUsIG1ha2VQcm9wc1N1cmZhY2UsIG1ha2VQcm9wc1NlbnRpbmVsIH06IHsgcG9ydGFsSWQ6IHN0cmluZywgdGFnU3VyZmFjZTogRWxlbWVudFRvVGFnPFN1cmZhY2VFbGVtZW50PiwgdGFnTWVudTogRWxlbWVudFRvVGFnPE1lbnVFbGVtZW50PiwgdGFnQnV0dG9uOiBFbGVtZW50VG9UYWc8QnV0dG9uRWxlbWVudD4sIHRhZ1NlbnRpbmVsOiBFbGVtZW50VG9UYWc8U2VudGluZWxFbGVtZW50PiwgbWFrZVByb3BzU3VyZmFjZTogKGluZm86IFVzZU1lbnVSZXR1cm5UeXBlSW5mbzxTdXJmYWNlRWxlbWVudCwgTWVudUVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgQnV0dG9uRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFN1cmZhY2VFbGVtZW50PiwgbWFrZVByb3BzTWVudTogKGluZm86IFVzZU1lbnVSZXR1cm5UeXBlSW5mbzxTdXJmYWNlRWxlbWVudCwgTWVudUVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgQnV0dG9uRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVFbGVtZW50PiwgbWFrZVByb3BzQnV0dG9uOiAoaW5mbzogVXNlTWVudVJldHVyblR5cGVJbmZvPFN1cmZhY2VFbGVtZW50LCBNZW51RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBCdXR0b25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8QnV0dG9uRWxlbWVudD4sIG1ha2VQcm9wc1NlbnRpbmVsOiAoaW5mbzogVXNlTWVudVJldHVyblR5cGVJbmZvPFN1cmZhY2VFbGVtZW50LCBNZW51RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBCdXR0b25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8U2VudGluZWxFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lbnVJbmZvOiBVc2VNZW51UmV0dXJuVHlwZUluZm88U3VyZmFjZUVsZW1lbnQsIE1lbnVFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQ+LCBtb2RpZnlNZW51QnV0dG9uUHJvcHM6IFByb3BNb2RpZmllcjxCdXR0b25FbGVtZW50PiwgbW9kaWZ5TWVudVN1cmZhY2VQcm9wczogUHJvcE1vZGlmaWVyPFN1cmZhY2VFbGVtZW50PiwgbW9kaWZ5TWVudVByb3BzOiBQcm9wTW9kaWZpZXI8TWVudUVsZW1lbnQ+LCBtb2RpZnlGaXJzdFNlbnRpbmVsUHJvcHM6IFByb3BNb2RpZmllcjxTZW50aW5lbEVsZW1lbnQ+LCBtb2RpZnlMYXN0U2VudGluZWxQcm9wczogUHJvcE1vZGlmaWVyPFNlbnRpbmVsRWxlbWVudD4pIHtcclxuXHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogc3VyZmFjZUNoaWxkcmVuLCAuLi5zdXJmYWNlUHJvcHMgfSA9IG1vZGlmeU1lbnVTdXJmYWNlUHJvcHMobWFrZVByb3BzU3VyZmFjZShtZW51SW5mbykpO1xyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IG1lbnVDaGlsZHJlbiwgLi4ubWVudVByb3BzIH0gPSBtb2RpZnlNZW51UHJvcHMobWFrZVByb3BzTWVudShtZW51SW5mbykpO1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdCdXR0b24gYXMgbmV2ZXIsIG1vZGlmeU1lbnVCdXR0b25Qcm9wcyhtYWtlUHJvcHNCdXR0b24obWVudUluZm8pKSl9XHJcbiAgICAgICAgICAgICAgICB7ZGVmYXVsdFJlbmRlclBvcnRhbCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9ydGFsSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGNyZWF0ZUVsZW1lbnQodGFnU3VyZmFjZSBhcyBuZXZlciwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdXJmYWNlUHJvcHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAoPD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ1NlbnRpbmVsIGFzIG5ldmVyLCBtb2RpZnlGaXJzdFNlbnRpbmVsUHJvcHMobWFrZVByb3BzU2VudGluZWwobWVudUluZm8pKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3VyZmFjZUNoaWxkcmVufVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnTWVudSBhcyBuZXZlciwgeyAuLi5tZW51UHJvcHMsIGNoaWxkcmVuOiA8PnttZW51Q2hpbGRyZW59PC8+IH0pfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnU2VudGluZWwgYXMgbmV2ZXIsIG1vZGlmeUxhc3RTZW50aW5lbFByb3BzKG1ha2VQcm9wc1NlbnRpbmVsKG1lbnVJbmZvKSkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Lz4pXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICApXHJcblxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IG1ha2VQcm9wc01lbnVJdGVtOiBtYWtlUHJvcHNNZW51SXRlbSwgdGFnTWVudUl0ZW0gfTogeyB0YWdNZW51SXRlbTogRWxlbWVudFRvVGFnPE1lbnVJdGVtRWxlbWVudD4sIG1ha2VQcm9wc01lbnVJdGVtOiAoaW5mbzogVXNlTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51SXRlbUVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+LCBtb2RpZnlNZW51SXRlbVByb3BzOiBQcm9wTW9kaWZpZXI8TWVudUl0ZW1FbGVtZW50Pikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ01lbnVJdGVtIGFzIG5ldmVyLCBtb2RpZnlNZW51SXRlbVByb3BzKG1ha2VQcm9wc01lbnVJdGVtKGluZm8pKSlcclxuICAgIH1cclxufSIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwicHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlUmFkaW9Hcm91cCwgVXNlUmFkaW9Hcm91cFBhcmFtZXRlcnMsIFVzZVJhZGlvR3JvdXBSZXR1cm5UeXBlSW5mbywgVXNlUmFkaW9QYXJhbWV0ZXJzLCBVc2VSYWRpbywgVXNlUmFkaW9SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtcmFkaW8tZ3JvdXBcIjtcclxuaW1wb3J0IHsgZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSwgRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9jaGVja2JveFwiXHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSYWRpb0dyb3VwUHJvcHM8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgR3JvdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xyXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudD4sIFwicmFkaW9Hcm91cFwiPixcclxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQ+LCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50PiwgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZHJlblwiPixcclxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudD4sIFwiY2hpbGRyZW5IYXZlRm9jdXNcIj4sXHJcbiAgICBHZXQ8VXNlUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50PiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+IHtcclxuICAgIC8vcHJvcHNHcm91cExhYmVsOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcm91cExhYmVsRWxlbWVudD47XHJcbiAgICAvL3Byb3BzR3JvdXA6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyb3VwRWxlbWVudD47XHJcbiAgICByZW5kZXIoaW5mbzogVXNlUmFkaW9Hcm91cFJldHVyblR5cGVJbmZvPFYsIElucHV0RWxlbWVudD4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxHcm91cExhYmVsRWxlbWVudD4sIG1vZGlmeUdyb3VwUHJvcHM6IFByb3BNb2RpZmllcjxHcm91cEVsZW1lbnQ+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSYWRpb1Byb3BzPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInJhZGlvXCI+LFxyXG4gICAgR2V0PFVzZVJhZGlvUGFyYW1ldGVyczxWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlUmFkaW9QYXJhbWV0ZXJzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZFwiPixcclxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImhhc0ZvY3VzSW5wdXRcIj4sXHJcbiAgICBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8SW5wdXRFbGVtZW50PixcclxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInJhZGlvXCI+IHtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VSYWRpb1JldHVyblR5cGVJbmZvPElucHV0RWxlbWVudD4sIG1vZGlmeUlucHV0UHJvcHM6IFByb3BNb2RpZmllcjxJbnB1dEVsZW1lbnQ+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50Pik6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyUmFkaW9Hcm91cDxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ0dyb3VwLCB0YWdMYWJlbCwgbWFrZVByb3BzR3JvdXAsIG1ha2VQcm9wc0xhYmVsIH06IHsgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+LCB0YWdHcm91cDogRWxlbWVudFRvVGFnPElucHV0RWxlbWVudD4sIG1ha2VQcm9wc0xhYmVsOiAoaW5mbzogVXNlUmFkaW9Hcm91cFJldHVyblR5cGVJbmZvPFYsIElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4sIG1ha2VQcm9wc0dyb3VwOiAoaW5mbzogVXNlUmFkaW9Hcm91cFJldHVyblR5cGVJbmZvPFYsIElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88ViwgSW5wdXRFbGVtZW50PiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4sIG1vZGlmeUdyb3VwUHJvcHM6IFByb3BNb2RpZmllcjxJbnB1dEVsZW1lbnQ+KSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ0xhYmVsIGFzIG5ldmVyLCBtb2RpZnlMYWJlbFByb3BzKG1ha2VQcm9wc0xhYmVsKGluZm8pKSl9XHJcbiAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdHcm91cCBhcyBuZXZlciwgbW9kaWZ5R3JvdXBQcm9wcyhtYWtlUHJvcHNHcm91cChpbmZvKSkpfVxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IFJhZGlvQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlUmFkaW88YW55LCBhbnksIGFueT4+KG51bGwhKTtcclxuZXhwb3J0IGNvbnN0IFJhZGlvR3JvdXAgPSBtZW1vKGZ1bmN0aW9uIFJhZGlvR3JvdXA8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgR3JvdXBFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIElucHV0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oe1xyXG4gICAgcmVuZGVyLFxyXG4gICAgdGFnR3JvdXAsXHJcbiAgICB0YWdHcm91cExhYmVsLFxyXG4gICAgbmFtZSxcclxuICAgIG9uU2VsZWN0ZWRWYWx1ZUNoYW5nZSxcclxuICAgIHNlbGVjdGVkVmFsdWUsXHJcbiAgICBjb2xsYXRvcixcclxuICAgIGRpc2FibGVBcnJvd0tleXMsXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxyXG4gICAgbm9UeXBlYWhlYWQsXHJcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxyXG4gICAgaW5kZXhEZW1hbmdsZXIsXHJcbiAgICBpbmRleE1hbmdsZXIsXHJcbiAgICBvbkFsbExvc3RGb2N1cyxcclxuICAgIG9uQW55R2FpbmVkRm9jdXMsXHJcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXHJcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxyXG59OiBSYWRpb0dyb3VwUHJvcHM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50Pikge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZVJhZGlvLFxyXG4gICAgICAgIHVzZVJhZGlvR3JvdXBMYWJlbFByb3BzLFxyXG4gICAgICAgIHVzZVJhZGlvR3JvdXBQcm9wcyxcclxuICAgICAgICAuLi5yYWRpb0dyb3VwUmV0dXJuXHJcbiAgICB9ID0gdXNlUmFkaW9Hcm91cDxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxyXG4gICAgICAgIHJhZGlvR3JvdXA6IHsgbmFtZSwgb25TZWxlY3RlZFZhbHVlQ2hhbmdlLCBzZWxlY3RlZFZhbHVlLCB0YWdHcm91cCwgdGFnR3JvdXBMYWJlbCB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciB9LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH0sXHJcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXM6IHsgb25BbGxMb3N0Rm9jdXMsIG9uQW55R2FpbmVkRm9jdXMgfSxcclxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0aW9uTW9kZTogXCJmb2N1c1wiIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFJhZGlvQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlUmFkaW99PlxyXG4gICAgICAgICAgICB7cmVuZGVyKHJhZGlvR3JvdXBSZXR1cm4sIHVzZVJhZGlvR3JvdXBMYWJlbFByb3BzLCB1c2VSYWRpb0dyb3VwUHJvcHMpfVxyXG4gICAgICAgIDwvUmFkaW9Db250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG59KVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0UmVuZGVyUmFkaW9QYXJhbWV0ZXJzPEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIEwsIFVzZVJhZGlvUmV0dXJuVHlwZUluZm88ST4+IHtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyUmFkaW88SSBleHRlbmRzIEhUTUxFbGVtZW50LCBMIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgdGFnSW5wdXQsIHRhZ0xhYmVsLCBtYWtlSW5wdXRQcm9wcywgbWFrZUxhYmVsUHJvcHMsIGxhYmVsUG9zaXRpb24gfTogRGVmYXVsdFJlbmRlclJhZGlvUGFyYW1ldGVyczxJLCBMPikge1xyXG4gICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJDaGVja2JveExpa2U8SSwgTCwgVXNlUmFkaW9SZXR1cm5UeXBlSW5mbzxJPj4oeyBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcyB9KTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFJhZGlvID0gbWVtbyhmdW5jdGlvbiBSYWRpbzxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGRpc2FibGVkLCBpbmRleCwgdGV4dCwgaGlkZGVuLCB0YWdJbnB1dCwgbGFiZWxQb3NpdGlvbiwgdGFnTGFiZWwsIHZhbHVlLCByZW5kZXIsIGZsYWdzLCBmb2N1c1NlbGYsIGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9OiBSYWRpb1Byb3BzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VSYWRpb0lucHV0LCB1c2VSYWRpb0xhYmVsLCAuLi5yYWRpb1JldHVybiB9ID0gdXNlQ29udGV4dChSYWRpb0NvbnRleHQpKHtcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxyXG4gICAgICAgIHJhZGlvOiB7IGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIHZhbHVlIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaGlkZGVuLCBmb2N1c1NlbGYgfSxcclxuICAgICAgICBoYXNGb2N1c0lucHV0OiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9LFxyXG4gICAgICAgIGhhc0ZvY3VzTGFiZWw6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUmFkaW9JbnB1dFByb3BzIH0gPSB1c2VSYWRpb0lucHV0KHsgdGFnOiB0YWdJbnB1dCB9KTtcclxuICAgIGNvbnN0IHsgdXNlUmFkaW9MYWJlbFByb3BzIH0gPSB1c2VSYWRpb0xhYmVsKHsgdGFnOiB0YWdMYWJlbCB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVuZGVyKHJhZGlvUmV0dXJuLCB1c2VSYWRpb0lucHV0UHJvcHMsIHVzZVJhZGlvTGFiZWxQcm9wcyk7XHJcbn0pXHJcbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVNsaWRlciwgVXNlU2xpZGVyUGFyYW1ldGVycywgVXNlU2xpZGVyVGh1bWIsIFVzZVNsaWRlclRodW1iUGFyYW1ldGVycywgVXNlU2xpZGVyVGh1bWJSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2Utc2xpZGVyXCI7XHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJQcm9wcyBleHRlbmRzIEdldDxVc2VTbGlkZXJQYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZHJlblwiPiwgR2V0PFVzZVNsaWRlclBhcmFtZXRlcnMsIFwic2xpZGVyXCI+IHtcclxuICAgIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJUaHVtYlByb3BzPFRodW1iRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgR2V0PFVzZVNsaWRlclRodW1iUGFyYW1ldGVyczxUaHVtYkVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZFwiPiwgR2V0PFVzZVNsaWRlclRodW1iUGFyYW1ldGVyczxUaHVtYkVsZW1lbnQ+LCBcInNsaWRlclRodW1iXCI+IHtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VTbGlkZXJUaHVtYlJldHVyblR5cGVJbmZvLCBtb2RpZnlUaHVtYlByb3BzOiBQcm9wTW9kaWZpZXI8VGh1bWJFbGVtZW50Pik6IFZOb2RlO1xyXG59XHJcblxyXG5jb25zdCBTbGlkZXJUaHVtYkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVNsaWRlclRodW1iPGFueT4+KG51bGwhKTtcclxuXHJcbmV4cG9ydCBjb25zdCBTbGlkZXIgPSBtZW1vKCBmdW5jdGlvbiBTbGlkZXIoeyBtYXgsIG1pbiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIGNoaWxkcmVuIH06IFNsaWRlclByb3BzKSB7XHJcbiAgICBjb25zdCB7IHVzZVNsaWRlclRodW1iLCAuLi5fc2xpZGVySW5mbyB9ID0gdXNlU2xpZGVyKHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcclxuICAgICAgICBzbGlkZXI6IHsgbWF4LCBtaW4gfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8U2xpZGVyVGh1bWJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VTbGlkZXJUaHVtYn0+e2NoaWxkcmVufTwvU2xpZGVyVGh1bWJDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKTtcclxufSlcclxuXHJcbmV4cG9ydCBjb25zdCBTbGlkZXJUaHVtYiA9IG1lbW8oZnVuY3Rpb24gU2xpZGVyVGh1bWJVPFRodW1iRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbGFiZWwsIHRhZywgdmFsdWUsIG1heCwgbWluLCBvblZhbHVlQ2hhbmdlLCBpbmRleCwgZmxhZ3MsIHJlbmRlciwgdmFsdWVUZXh0IH06IFNsaWRlclRodW1iUHJvcHM8VGh1bWJFbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VTbGlkZXJUaHVtYlByb3BzLCAuLi5zbGlkZXJJbmZvIH0gPSB1c2VDb250ZXh0KFNsaWRlclRodW1iQ29udGV4dCkoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHNsaWRlclRodW1iOiB7IGxhYmVsLCB0YWcsIHZhbHVlLCBtYXgsIG1pbiwgb25WYWx1ZUNoYW5nZSwgdmFsdWVUZXh0IH0gfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlbmRlcihzbGlkZXJJbmZvLCB1c2VTbGlkZXJUaHVtYlByb3BzKVxyXG59KVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJTbGlkZXJUaHVtYjxFIGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUaHVtYiwgbWFrZVByb3BzVGh1bWIgfTogeyB0YWdUaHVtYjogRWxlbWVudFRvVGFnPEU+LCBtYWtlUHJvcHNUaHVtYjogKGluZm86IFVzZVNsaWRlclRodW1iUmV0dXJuVHlwZUluZm8pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlU2xpZGVyVGh1bWJSZXR1cm5UeXBlSW5mbywgbW9kaWZ5VGh1bWJQcm9wczogUHJvcE1vZGlmaWVyPEU+KSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGh1bWIgYXMgbmV2ZXIsIG1vZGlmeVRodW1iUHJvcHMobWFrZVByb3BzVGh1bWIoaW5mbykpKVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VUYWJsZSwgVXNlVGFibGVCb2R5LCBVc2VUYWJsZUJvZHlQYXJhbWV0ZXJzLCBVc2VUYWJsZUJvZHlSZXR1cm5UeXBlSW5mbywgVXNlVGFibGVDZWxsLCBVc2VUYWJsZUNlbGxQYXJhbWV0ZXJzLCBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlSW5mbywgVXNlVGFibGVQYXJhbWV0ZXJzLCBVc2VUYWJsZVJldHVyblR5cGVJbmZvLCBVc2VUYWJsZVJldHVyblR5cGVXaXRoSG9va3MsIFVzZVRhYmxlUm93LCBVc2VUYWJsZVJvd1BhcmFtZXRlcnMsIFVzZVRhYmxlUm93UmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLXRhYmxlXCI7XHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVQcm9wczxUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlVGFibGVQYXJhbWV0ZXJzLCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlVGFibGVQYXJhbWV0ZXJzLCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZVRhYmxlUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXHJcbiAgICBHZXQ8VXNlVGFibGVQYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZVRhYmxlUGFyYW1ldGVycywgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+IHtcclxuICAgIC8vdGFnVGFibGU6IEVsZW1lbnRUb1RhZzxUYWJsZUVsZW1lbnQ+O1xyXG4gICAgLy9wcm9wc1RhYmxlKCk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlRWxlbWVudD47XHJcbiAgICByZW5kZXIoaW5mbzogVXNlVGFibGVSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIG1vZGlmeVRhYmxlUHJvcHM6IFByb3BNb2RpZmllcjxUYWJsZUVsZW1lbnQ+KTogVk5vZGU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVCb2R5UHJvcHM8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRhYmxlQm9keVBhcmFtZXRlcnMge1xyXG4gICAgcmVuZGVyKGluZm86IFVzZVRhYmxlQm9keVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgbW9kaWZ5VGFibGVCb2R5UHJvcHM6IFByb3BNb2RpZmllcjxTZWN0aW9uRWxlbWVudD4pOiBWTm9kZTtcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlSGVhZFByb3BzPFQgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICByZW5kZXIobW9kaWZ5VGFibGVIZWFkUHJvcHM6IFByb3BNb2RpZmllcjxUPik6IFZOb2RlO1xyXG4gICAgdGFnVGFibGVIZWFkOiBFbGVtZW50VG9UYWc8VD47XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUZvb3RQcm9wczxUIGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgcmVuZGVyKG1vZGlmeVRhYmxlRm9vdFByb3BzOiBQcm9wTW9kaWZpZXI8VD4pOiBWTm9kZTtcclxuICAgIHRhZ1RhYmxlRm9vdDogRWxlbWVudFRvVGFnPFQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlUm93UHJvcHM8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xyXG4gICAgT21pdDxHZXQ8VXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgXCJ0YWJsZVJvd1wiPiwgXCJsb2NhdGlvblwiPixcclxuICAgIEdldDI8VXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgXCJhc0NoaWxkUm93T2ZTZWN0aW9uXCIsIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFwiYXNDaGlsZFJvd09mU2VjdGlvblwiLCBcIm1hbmFnZWRDaGlsZFwiPixcclxuICAgIEdldDI8VXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgXCJhc0NoaWxkUm93T2ZTZWN0aW9uXCIsIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwibGluZWFyTmF2aWdhdGlvblwiPixcclxuICAgIEdldDI8VXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgXCJhc1BhcmVudFJvd09mQ2VsbHNcIiwgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDI8VXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgXCJhc1BhcmVudFJvd09mQ2VsbHNcIiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXHJcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPiB7XHJcbiAgICByZW5kZXIoaW5mbzogVXNlVGFibGVSb3dSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIG1vZGlmeVRhYmxlUm93UHJvcHM6IFByb3BNb2RpZmllcjxSb3dFbGVtZW50Pik6IFZOb2RlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlQ2VsbFByb3BzPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xyXG4gICAgR2V0PFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcInRhYmxlQ2VsbFwiPixcclxuICAgIEdldDxVc2VUYWJsZUNlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VUYWJsZUNlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXHJcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LFxyXG4gICAgT21pdDxHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwic3ViSW5mb1wiPiwgXCJsb2NhdGlvblwiPiB7XHJcbiAgICByZW5kZXIoaW5mbzogVXNlVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+LCBtb2RpZnlUYWJsZVJvd1Byb3BzOiBQcm9wTW9kaWZpZXI8Q2VsbEVsZW1lbnQ+KTogVk5vZGU7XHJcbn1cclxuXHJcbmNvbnN0IExvY2F0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8XCJoZWFkXCIgfCBcImJvZHlcIiB8IFwiZm9vdFwiPihudWxsISk7XHJcblxyXG5jb25zdCBUYWJsZVNlY3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWJsZVJldHVyblR5cGVXaXRoSG9va3M8YW55LCBhbnksIGFueSwgYW55PltcInVzZVRhYmxlU2VjdGlvblByb3BzXCJdPihudWxsISk7XHJcbmNvbnN0IFRhYmxlQm9keUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRhYmxlQm9keTxhbnksIGFueSwgYW55Pj4obnVsbCEpO1xyXG5jb25zdCBUYWJsZVJvd0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRhYmxlUm93PGFueSwgYW55Pj4obnVsbCEpO1xyXG5jb25zdCBUYWJsZUNlbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWJsZUNlbGw8YW55Pj4obnVsbCEpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZTxUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RhYmxlLCBtYWtlUHJvcHNUYWJsZSB9OiB7IHRhZ1RhYmxlOiBFbGVtZW50VG9UYWc8VGFibGVFbGVtZW50PiwgbWFrZVByb3BzVGFibGU6IChpbmZvOiBVc2VUYWJsZVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVRhYmxlUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc1RhYmxlOiBQcm9wTW9kaWZpZXI8VGFibGVFbGVtZW50Pikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlIGFzIG5ldmVyLCBtb2RpZnlQcm9wc1RhYmxlKG1ha2VQcm9wc1RhYmxlKGluZm8pKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGVCb2R5PFRhYmxlQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RhYmxlQm9keSwgbWFrZVByb3BzVGFibGVCb2R5IH06IHsgdGFnVGFibGVCb2R5OiBFbGVtZW50VG9UYWc8VGFibGVCb2R5RWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlQm9keTogKGluZm86IFVzZVRhYmxlQm9keVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVCb2R5RWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUYWJsZUJvZHlSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIG1vZGlmeVByb3BzVGFibGVCb2R5OiBQcm9wTW9kaWZpZXI8VGFibGVCb2R5RWxlbWVudD4pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJsZUJvZHkgYXMgbmV2ZXIsIG1vZGlmeVByb3BzVGFibGVCb2R5KG1ha2VQcm9wc1RhYmxlQm9keShpbmZvKSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlSGVhZDxUYWJsZUhlYWRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUYWJsZUhlYWQsIG1ha2VQcm9wc1RhYmxlSGVhZCB9OiB7IHRhZ1RhYmxlSGVhZDogRWxlbWVudFRvVGFnPFRhYmxlSGVhZEVsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZUhlYWQ6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlSGVhZEVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobW9kaWZ5UHJvcHNUYWJsZUhlYWQ6IFByb3BNb2RpZmllcjxUYWJsZUhlYWRFbGVtZW50Pikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlSGVhZCBhcyBuZXZlciwgbW9kaWZ5UHJvcHNUYWJsZUhlYWQobWFrZVByb3BzVGFibGVIZWFkKCkpKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZUZvb3Q8VGFibGVGb290RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnVGFibGVGb290LCBtYWtlUHJvcHNUYWJsZUZvb3QgfTogeyB0YWdUYWJsZUZvb3Q6IEVsZW1lbnRUb1RhZzxUYWJsZUZvb3RFbGVtZW50PiwgbWFrZVByb3BzVGFibGVGb290OiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUZvb3RFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZGlmeVByb3BzVGFibGVGb290OiBQcm9wTW9kaWZpZXI8VGFibGVGb290RWxlbWVudD4pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJsZUZvb3QgYXMgbmV2ZXIsIG1vZGlmeVByb3BzVGFibGVGb290KG1ha2VQcm9wc1RhYmxlRm9vdCgpKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGVSb3c8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUYWJsZVJvdywgbWFrZVByb3BzVGFibGVSb3cgfTogeyB0YWdUYWJsZVJvdzogRWxlbWVudFRvVGFnPFJvd0VsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZVJvdzogKGluZm86IFVzZVRhYmxlUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVRhYmxlUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc1RhYmxlUm93OiBQcm9wTW9kaWZpZXI8Um93RWxlbWVudD4pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJsZVJvdyBhcyBuZXZlciwgbW9kaWZ5UHJvcHNUYWJsZVJvdyhtYWtlUHJvcHNUYWJsZVJvdyhpbmZvKSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlQ2VsbDxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnVGFibGVDZWxsLCBtYWtlUHJvcHNUYWJsZUNlbGwgfTogeyB0YWdUYWJsZUNlbGw6IEVsZW1lbnRUb1RhZzxDZWxsRWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlQ2VsbDogKGluZm86IFVzZVRhYmxlQ2VsbFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc1RhYmxlQ2VsbDogUHJvcE1vZGlmaWVyPENlbGxFbGVtZW50Pikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlQ2VsbCBhcyBuZXZlciwgbW9kaWZ5UHJvcHNUYWJsZUNlbGwobWFrZVByb3BzVGFibGVDZWxsKGluZm8pKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBUYWJsZSA9IG1lbW8oZnVuY3Rpb24gVGFibGVVPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcclxuICAgIGNvbGxhdG9yLFxyXG4gICAgZGlzYWJsZUFycm93S2V5cyxcclxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcclxuICAgIGluaXRpYWxJbmRleCxcclxuICAgIG5vVHlwZWFoZWFkLFxyXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxyXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZVJlbmRlcixcclxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXHJcbiAgICByZW5kZXJcclxufTogVGFibGVQcm9wczxUYWJsZUVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudD4pIHtcclxuICAgIGNvbnN0IHsgdXNlVGFibGVCb2R5LCB1c2VUYWJsZVByb3BzLCB1c2VUYWJsZVJvdywgdXNlVGFibGVTZWN0aW9uUHJvcHMsIC4uLnRhYmxlSW5mbyB9ID0gdXNlVGFibGU8VGFibGVFbGVtZW50LCBTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbGVtZW50Pih7XHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMgfSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjoge30sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIgfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxUYWJsZVNlY3Rpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJsZVNlY3Rpb25Qcm9wc30+XHJcbiAgICAgICAgICAgIDxUYWJsZUJvZHlDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJsZUJvZHl9PlxyXG4gICAgICAgICAgICAgICAgPFRhYmxlUm93Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFibGVSb3d9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtyZW5kZXIodGFibGVJbmZvLCB1c2VUYWJsZVByb3BzKX1cclxuICAgICAgICAgICAgICAgIDwvVGFibGVSb3dDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgICAgICAgICA8L1RhYmxlQm9keUNvbnRleHQuUHJvdmlkZXI+XHJcbiAgICAgICAgPC9UYWJsZVNlY3Rpb25Db250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG59KVxyXG5cclxuZXhwb3J0IGNvbnN0IFRhYmxlQm9keSA9IG1lbW8oZnVuY3Rpb24gVGFibGVCb2R5VTxTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHJlbmRlciB9OiBUYWJsZUJvZHlQcm9wczxTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VUYWJsZUJvZHlQcm9wcywgLi4uc2VjdGlvbkluZm8gfSA9IHVzZUNvbnRleHQoVGFibGVCb2R5Q29udGV4dCkoe30pO1xyXG4gICAgcmV0dXJuIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9XCJib2R5XCI+e3JlbmRlcihzZWN0aW9uSW5mbywgdXNlVGFibGVCb2R5UHJvcHMpfTwvTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyPlxyXG59KVxyXG5cclxuZXhwb3J0IGNvbnN0IFRhYmxlSGVhZCA9IG1lbW8oZnVuY3Rpb24gVGFibGVIZWFkVTxUIGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIsIHRhZ1RhYmxlSGVhZCB9OiBUYWJsZUhlYWRQcm9wczxUPikge1xyXG4gICAgY29uc3QgdXNlVGFibGVTZWN0aW9uUHJvcHNCYXNlID0gdXNlQ29udGV4dChUYWJsZVNlY3Rpb25Db250ZXh0KTtcclxuICAgIGNvbnN0IHVzZVRhYmxlU2VjdGlvblByb3BzOiBQcm9wTW9kaWZpZXI8VD4gPSAocHJvcHMpID0+IHVzZVRhYmxlU2VjdGlvblByb3BzQmFzZSh0YWdUYWJsZUhlYWQsIFwiaGVhZFwiLCBwcm9wcyk7XHJcbiAgICByZXR1cm4gPExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT1cImhlYWRcIj57KHJlbmRlcih1c2VUYWJsZVNlY3Rpb25Qcm9wcykpfTwvTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyPlxyXG59KVxyXG5cclxuZXhwb3J0IGNvbnN0IFRhYmxlRm9vdCA9IG1lbW8oZnVuY3Rpb24gVGFibGVGb290VTxUIGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIsIHRhZ1RhYmxlRm9vdCB9OiBUYWJsZUZvb3RQcm9wczxUPikge1xyXG4gICAgY29uc3QgdXNlVGFibGVTZWN0aW9uUHJvcHNCYXNlID0gdXNlQ29udGV4dChUYWJsZVNlY3Rpb25Db250ZXh0KTtcclxuICAgIGNvbnN0IHVzZVRhYmxlU2VjdGlvblByb3BzOiBQcm9wTW9kaWZpZXI8VD4gPSAocHJvcHMpID0+IHVzZVRhYmxlU2VjdGlvblByb3BzQmFzZSh0YWdUYWJsZUZvb3QsIFwiZm9vdFwiLCBwcm9wcyk7XHJcbiAgICByZXR1cm4gPExvY2F0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT1cImZvb3RcIj57KHJlbmRlcih1c2VUYWJsZVNlY3Rpb25Qcm9wcykpfTwvTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyPlxyXG59KVxyXG5cclxuZXhwb3J0IGNvbnN0IFRhYmxlUm93ID0gbWVtbyhmdW5jdGlvbiBUYWJsZVJvd1U8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcclxuICAgIGluZGV4LFxyXG4gICAgdGV4dCxcclxuICAgIHRhZ1RhYmxlUm93LFxyXG4gICAgY29sbGF0b3IsXHJcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxyXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxyXG4gICAgZmxhZ3MsXHJcbiAgICBmb2N1c1NlbGYsXHJcbiAgICBoaWRkZW4sXHJcbiAgICBpbmRleERlbWFuZ2xlcixcclxuICAgIGluZGV4TWFuZ2xlcixcclxuICAgIGluaXRpYWxJbmRleCxcclxuICAgIG5vVHlwZWFoZWFkLFxyXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxyXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZVJlbmRlcixcclxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXHJcbiAgICByZW5kZXJcclxufTogVGFibGVSb3dQcm9wczxSb3dFbGVtZW50LCBDZWxsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZVRhYmxlQ2VsbCwgdXNlVGFibGVSb3dQcm9wcywgLi4ucm93SW5mbyB9ID0gdXNlQ29udGV4dChUYWJsZVJvd0NvbnRleHQpKHtcclxuICAgICAgICBhc0NoaWxkUm93T2ZTZWN0aW9uOiB7XHJcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbiB9LFxyXG4gICAgICAgICAgICBzdWJJbmZvOiB7fVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXNQYXJlbnRSb3dPZkNlbGxzOiB7XHJcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzIH0sXHJcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXHJcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHRhYmxlUm93OiB7IGxvY2F0aW9uOiB1c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCksIHRhZ1RhYmxlUm93IH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIDxUYWJsZUNlbGxDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJsZUNlbGx9PntyZW5kZXIocm93SW5mbywgdXNlVGFibGVSb3dQcm9wcyl9PC9UYWJsZUNlbGxDb250ZXh0LlByb3ZpZGVyPlxyXG59KVxyXG5cclxuZXhwb3J0IGNvbnN0IFRhYmxlQ2VsbCA9IG1lbW8oZnVuY3Rpb24gVGFibGVDZWxsPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBpbmRleCwgdGV4dCwgZmxhZ3MsIGZvY3VzU2VsZiwgaGlkZGVuLCB2YWx1ZSwgaGVhZGVyVHlwZSwgdGFnVGFibGVDZWxsLCBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIHJlbmRlciB9OiBUYWJsZUNlbGxQcm9wczxDZWxsRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHsgdXNlVGFibGVDZWxsUHJvcHMsIC4uLmNlbGxJbmZvIH0gPSB1c2VDb250ZXh0KFRhYmxlQ2VsbENvbnRleHQpKHtcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZiwgaGlkZGVuIH0sXHJcbiAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH0sXHJcbiAgICAgICAgc3ViSW5mbzoge1xyXG4gICAgICAgICAgICBsb2NhdGlvbjogdXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLFxyXG4gICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGFibGVDZWxsOiB7IGhlYWRlclR5cGUsIHRhZ1RhYmxlQ2VsbCB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVuZGVyKGNlbGxJbmZvLCB1c2VUYWJsZUNlbGxQcm9wcyk7XHJcbn0pXHJcblxyXG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XHJcbmltcG9ydCB7IFVzZVRhYiwgVXNlVGFiTGlzdFBhcmFtZXRlcnMsIFVzZVRhYkxpc3RSZXR1cm5UeXBlSW5mbywgVXNlVGFiUGFuZWwsIFVzZVRhYlBhbmVsUGFyYW1ldGVycywgVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbywgVXNlVGFiUGFyYW1ldGVycywgVXNlVGFiUmV0dXJuVHlwZUluZm8sIHVzZVRhYnMsIFVzZVRhYnNQYXJhbWV0ZXJzLCBVc2VUYWJzUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLXRhYnNcIjtcclxuXHJcbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XHJcbnR5cGUgR2V0MjxULCBLIGV4dGVuZHMga2V5b2YgVCwgSzIgZXh0ZW5kcyBrZXlvZiBUW0tdPiA9IFRbS11bSzJdO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUYWJzUHJvcHM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xyXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwibWFuYWdlZENoaWxkcmVuXCI+LFxyXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcInNpbmdsZVNlbGVjdGlvblwiPixcclxuICAgIEdldDxVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcImNoaWxkcmVuSGF2ZUZvY3VzXCI+LFxyXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcInRhYnNcIj4sXHJcbiAgICBHZXQyPFVzZVRhYnNQYXJhbWV0ZXJzLCBcInRhYlBhbmVsc1wiLCBcIm1hbmFnZWRDaGlsZHJlblwiPiB7XHJcbiAgICByZW5kZXIodGFic0luZm86IFVzZVRhYnNSZXR1cm5UeXBlSW5mbyAmIFVzZVRhYkxpc3RSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4sIG1vZGlmeVRhYkxpc3RQcm9wczogUHJvcE1vZGlmaWVyPExpc3RFbGVtZW50Pik6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFiUHJvcHM8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgR2V0PFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXHJcbiAgICBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VGFiRWxlbWVudD4sXHJcbiAgICBHZXQ8VXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFwiPiB7XHJcbiAgICAvLyB0YWdMaXN0SXRlbTogRWxlbWVudFRvVGFnPExpc3Rib3hJdGVtRWxlbWVudD47XHJcbiAgICAvLyBwcm9wc0xpc3RJdGVtOiAoYXJnczogTGlzdGJveFNpbmdsZVByb3BzRGVyaXZlZEZyb20pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3Rib3hJdGVtRWxlbWVudD47XHJcbiAgICByZW5kZXIoaW5mbzogVXNlVGFiUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudD4sIG1vZGlmeUxpc3RJdGVtOiBQcm9wTW9kaWZpZXI8VGFiRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRhYlBhbmVsUHJvcHM8VGFiUGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHZXQ8VXNlVGFiUGFuZWxQYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZFwiPiB7XHJcbiAgICByZW5kZXIoaW5mbzogVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbywgbW9kaWZ5VGFiUGFuZWxQcm9wczogUHJvcE1vZGlmaWVyPFRhYlBhbmVsRWxlbWVudD4pOiBWTm9kZTtcclxufVxyXG5cclxuY29uc3QgVGFiQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVGFiPGFueT4+KG51bGwhKTtcclxuY29uc3QgVGFiUGFuZWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWJQYW5lbDxhbnk+PihudWxsISk7XHJcblxyXG5leHBvcnQgY29uc3QgVGFicyA9IG1lbW8oZnVuY3Rpb24gVGFiczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XHJcbiAgICBzZWxlY3RlZEluZGV4LFxyXG4gICAgc2VsZWN0aW9uTW9kZSxcclxuICAgIGNvbGxhdG9yLFxyXG4gICAgZGlzYWJsZUFycm93S2V5cyxcclxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcclxuICAgIGluZGV4RGVtYW5nbGVyLFxyXG4gICAgaW5kZXhNYW5nbGVyLFxyXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcclxuICAgIG5vVHlwZWFoZWFkLFxyXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxyXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZVJlbmRlcixcclxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXHJcbiAgICBvbkFsbExvc3RGb2N1cyxcclxuICAgIG9uQW55R2FpbmVkRm9jdXMsXHJcbiAgICBvblNlbGVjdGVkSW5kZXhDaGFuZ2UsXHJcbiAgICByZW5kZXJcclxufTogVGFic1Byb3BzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlVGFiTGlzdCxcclxuICAgICAgICB1c2VUYWJMaXN0TGFiZWwsXHJcbiAgICAgICAgdXNlVGFiUGFuZWwsXHJcbiAgICAgICAgLi4udGFic0luZm9cclxuICAgIH0gPSB1c2VUYWJzPExpc3RFbGVtZW50LCBUYWJFbGVtZW50LCBUYWJQYW5lbEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xyXG4gICAgICAgIHRhYlBhbmVsczoge1xyXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlVGFiLCB1c2VUYWJMaXN0UHJvcHMsIC4uLnRhYmxpc3RJbmZvIH0gPSB1c2VUYWJMaXN0KHtcclxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1czogeyBvbkFsbExvc3RGb2N1cywgb25BbnlHYWluZWRGb2N1cyB9LFxyXG4gICAgICAgIHRhYnM6IHsgb25TZWxlY3RlZEluZGV4Q2hhbmdlIH0sXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXHJcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXgsIHNlbGVjdGlvbk1vZGUgfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHsgdXNlVGFiTGlzdExhYmVsUHJvcHMgfSA9IHVzZVRhYkxpc3RMYWJlbCh7fSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8VGFiQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFifT5cclxuICAgICAgICAgICAgPFRhYlBhbmVsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFiUGFuZWx9PlxyXG4gICAgICAgICAgICAgICAge3JlbmRlcih7IC4uLnRhYnNJbmZvLCAuLi50YWJsaXN0SW5mbyB9LCB1c2VUYWJMaXN0TGFiZWxQcm9wcywgdXNlVGFiTGlzdFByb3BzKX1cclxuICAgICAgICAgICAgPC9UYWJQYW5lbENvbnRleHQuUHJvdmlkZXI+XHJcbiAgICAgICAgPC9UYWJDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG59KVxyXG5cclxuZXhwb3J0IGNvbnN0IFRhYiA9IG1lbW8oZnVuY3Rpb24gVGFiPFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGluZGV4LCB0ZXh0LCBmbGFncywgZm9jdXNTZWxmLCBoaWRkZW4sIGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmVuZGVyIH06IFRhYlByb3BzPFRhYkVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZVRhYlByb3BzLCAuLi50YWJJbmZvIH0gPSB1c2VDb250ZXh0KFRhYkNvbnRleHQpKHtcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZiwgaGlkZGVuIH0sXHJcbiAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZW5kZXIodGFiSW5mbywgdXNlVGFiUHJvcHMpXHJcbn0pXHJcblxyXG5leHBvcnQgY29uc3QgVGFiUGFuZWwgPSBtZW1vKGZ1bmN0aW9uIFRhYlBhbmVsPFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgaW5kZXgsIGZsYWdzLCByZW5kZXIgfTogVGFiUGFuZWxQcm9wczxUYWJQYW5lbEVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZVRhYlBhbmVsUHJvcHMsIC4uLnRhYlBhbmVsSW5mbyB9ID0gdXNlQ29udGV4dChUYWJQYW5lbENvbnRleHQpKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9IH0pO1xyXG5cclxuICAgIHJldHVybiByZW5kZXIodGFiUGFuZWxJbmZvLCB1c2VUYWJQYW5lbFByb3BzKVxyXG59KVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdMYWJlbCwgdGFnTGlzdCwgbWFrZVByb3BzTGFiZWwsIG1ha2VQcm9wc0xpc3QsIHBhbmVscyB9OiB7IHBhbmVsczogVk5vZGVbXSwgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+LCB0YWdMaXN0OiBFbGVtZW50VG9UYWc8TGlzdEVsZW1lbnQ+LCBtYWtlUHJvcHNMYWJlbDogKGluZm86IFVzZVRhYnNSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiwgbWFrZVByb3BzTGlzdDogKGluZm86IFVzZVRhYnNSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFic0luZm86IFVzZVRhYnNSZXR1cm5UeXBlSW5mbyAmIFVzZVRhYkxpc3RSZXR1cm5UeXBlSW5mbzxhbnk+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50PiwgbW9kaWZ5TGlzdFByb3BzOiBQcm9wTW9kaWZpZXI8TGlzdEVsZW1lbnQ+KSB7XHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KHRhZ0xhYmVsIGFzIG5ldmVyLCBtb2RpZnlMYWJlbFByb3BzKG1ha2VQcm9wc0xhYmVsKHRhYnNJbmZvKSkpXHJcbiAgICAgICAgY29uc3QgbGlzdCA9IGNyZWF0ZUVsZW1lbnQodGFnTGlzdCBhcyBuZXZlciwgbW9kaWZ5TGlzdFByb3BzKG1ha2VQcm9wc0xpc3QodGFic0luZm8pKSk7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIHtsYWJlbH1cclxuICAgICAgICAgICAgICAgIHtsaXN0fVxyXG4gICAgICAgICAgICAgICAge3BhbmVsc31cclxuICAgICAgICAgICAgPC8+XHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYjxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNUYWIsIHRhZ1RhYiB9OiB7IHRhZ1RhYjogRWxlbWVudFRvVGFnPFRhYkVsZW1lbnQ+LCBtYWtlUHJvcHNUYWI6IChpbmZvOiBVc2VUYWJSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YWJJbmZvOiBVc2VUYWJSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PiwgbW9kaWZ5VGFiUHJvcHM6IFByb3BNb2RpZmllcjxUYWJFbGVtZW50Pikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYiBhcyBuZXZlciwgbW9kaWZ5VGFiUHJvcHMobWFrZVByb3BzVGFiKHRhYkluZm8pKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFiUGFuZWw8VGFiUGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNUYWJQYW5lbCwgdGFnVGFiUGFuZWwgfTogeyB0YWdUYWJQYW5lbDogRWxlbWVudFRvVGFnPFRhYlBhbmVsRWxlbWVudD4sIG1ha2VQcm9wc1RhYlBhbmVsOiAoaW5mbzogVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiUGFuZWxFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhYlBhbmVsSW5mbzogVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbywgbW9kaWZ5VGFiUGFuZWxQcm9wczogUHJvcE1vZGlmaWVyPFRhYlBhbmVsRWxlbWVudD4pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJQYW5lbCBhcyBuZXZlciwgbW9kaWZ5VGFiUGFuZWxQcm9wcyhtYWtlUHJvcHNUYWJQYW5lbCh0YWJQYW5lbEluZm8pKSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVRvb2x0aXAsIFVzZVRvb2x0aXBQYXJhbWV0ZXJzLCBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLXRvb2x0aXBcIjtcclxuaW1wb3J0IHsgZGVmYXVsdFJlbmRlclBvcnRhbCB9IGZyb20gXCIuL2RpYWxvZ1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUb29sdGlwUHJvcHM8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50LCBQb3B1cFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRvb2x0aXBQYXJhbWV0ZXJzIHtcclxuICAgIGdldERvY3VtZW50OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyc1tcImdldERvY3VtZW50XCJdO1xyXG4gICAgZ2V0V2luZG93PzogVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnNbXCJnZXRXaW5kb3dcIl07XHJcbiAgICByZW5kZXIoaW5mbzogVXNlVG9vbHRpcFJldHVyblR5cGVJbmZvLCBtb2RpZnlUcmlnZ2VyUHJvcHM6IFByb3BNb2RpZmllcjxUcmlnZ2VyVHlwZT4sIG1vZGlmeVRvb2x0aXBQcm9wczogUHJvcE1vZGlmaWVyPFBvcHVwVHlwZT4pOiBWTm9kZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUb29sdGlwPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudCwgUG9wdXBUeXBlIGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUb29sdGlwLCB0YWdUcmlnZ2VyLCBtYWtlVG9vbHRpcFByb3BzLCBtYWtlVHJpZ2dlclByb3BzLCBwb3J0YWxJZCB9OiB7IHBvcnRhbElkOiBzdHJpbmcsIHRhZ1RyaWdnZXI6IEVsZW1lbnRUb1RhZzxUcmlnZ2VyVHlwZT4sIHRhZ1Rvb2x0aXA6IEVsZW1lbnRUb1RhZzxQb3B1cFR5cGU+LCBtYWtlVHJpZ2dlclByb3BzOiAoaW5mbzogVXNlVG9vbHRpcFJldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4sIG1ha2VUb29sdGlwUHJvcHM6IChpbmZvOiBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwVHlwZT4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8sIG1vZGlmeVByb3BzVHJpZ2dlcjogUHJvcE1vZGlmaWVyPFRyaWdnZXJUeXBlPiwgbW9kaWZ5UHJvcHNUb29sdGlwOiBQcm9wTW9kaWZpZXI8UG9wdXBUeXBlPikge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdUcmlnZ2VyIGFzIG5ldmVyLCBtb2RpZnlQcm9wc1RyaWdnZXIobWFrZVRyaWdnZXJQcm9wcyhpbmZvKSkpfVxyXG4gICAgICAgICAgICAgICAge2RlZmF1bHRSZW5kZXJQb3J0YWwoe1xyXG4gICAgICAgICAgICAgICAgICAgIHBvcnRhbElkLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjcmVhdGVFbGVtZW50KHRhZ1Rvb2x0aXAgYXMgbmV2ZXIsIG1vZGlmeVByb3BzVG9vbHRpcChtYWtlVG9vbHRpcFByb3BzKGluZm8pKSlcclxuICAgICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBUb29sdGlwID0gbWVtbyhmdW5jdGlvbiBUb29sdGlwVTxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQsIFBvcHVwVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgZm9jdXNEZWxheSwgbW91c2VvdXRUb2xlcmFuY2VEZWxheSwgbW91c2VvdmVyRGVsYXksIGdldERvY3VtZW50LCBnZXRXaW5kb3csIHJlbmRlciB9OiBUb29sdGlwUHJvcHM8VHJpZ2dlclR5cGUsIFBvcHVwVHlwZT4pIHtcclxuICAgIGNvbnN0IHsgdXNlVG9vbHRpcFBvcHVwLCB1c2VUb29sdGlwVHJpZ2dlciwgLi4uaW5mbyB9ID0gdXNlVG9vbHRpcDxUcmlnZ2VyVHlwZSwgUG9wdXBUeXBlPih7IGZvY3VzRGVsYXksIG1vdXNlb3V0VG9sZXJhbmNlRGVsYXksIG1vdXNlb3ZlckRlbGF5IH0pO1xyXG4gICAgY29uc3QgeyB1c2VUb29sdGlwVHJpZ2dlclByb3BzIH0gPSB1c2VUb29sdGlwVHJpZ2dlcih7IGhhc0ZvY3VzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3cgfSB9KTtcclxuICAgIGNvbnN0IHsgdXNlVG9vbHRpcFBvcHVwUHJvcHMgfSA9IHVzZVRvb2x0aXBQb3B1cCh7IGhhc0ZvY3VzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3cgfSB9KTtcclxuICAgIHJldHVybiByZW5kZXIoaW5mbywgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcywgdXNlVG9vbHRpcFBvcHVwUHJvcHMpO1xyXG59KVxyXG5cclxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XHJcbmltcG9ydCB7IHVzZUdyaWRsaXN0LCBVc2VHcmlkbGlzdFNlY3Rpb24sIFVzZUdyaWRsaXN0U2VjdGlvblBhcmFtZXRlcnMsIFVzZUdyaWRsaXN0U2VjdGlvblJldHVyblR5cGVJbmZvLCBVc2VHcmlkbGlzdENoaWxkLCBVc2VHcmlkbGlzdENoaWxkUGFyYW1ldGVycywgVXNlR3JpZGxpc3RDaGlsZFJldHVyblR5cGVJbmZvLCBVc2VHcmlkbGlzdFBhcmFtZXRlcnMsIFVzZUdyaWRsaXN0UmV0dXJuVHlwZUluZm8sIFVzZUdyaWRsaXN0Um93LCBVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnMsIFVzZUdyaWRsaXN0Um93UmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLWdyaWRsaXN0XCI7XHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR3JpZGxpc3RQcm9wczxHcmlkbGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlR3JpZGxpc3RQYXJhbWV0ZXJzLCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlR3JpZGxpc3RQYXJhbWV0ZXJzLCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXHJcbiAgICBHZXQ8VXNlR3JpZGxpc3RQYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVycywgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+IHtcclxuICAgIC8vdGFnR3JpZGxpc3Q6IEVsZW1lbnRUb1RhZzxHcmlkbGlzdEVsZW1lbnQ+O1xyXG4gICAgLy9wcm9wc0dyaWRsaXN0KCk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyaWRsaXN0RWxlbWVudD47XHJcbiAgICByZW5kZXIoaW5mbzogVXNlR3JpZGxpc3RSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIG1vZGlmeUdyaWRsaXN0UHJvcHM6IFByb3BNb2RpZmllcjxHcmlkbGlzdEVsZW1lbnQ+KTogVk5vZGU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR3JpZGxpc3RTZWN0aW9uUHJvcHM8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWRsaXN0U2VjdGlvblBhcmFtZXRlcnMsIFVzZUdyaWRsaXN0U2VjdGlvblBhcmFtZXRlcnMge1xyXG4gICAgaW5kZXg6IG51bWJlcjtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VHcmlkbGlzdFNlY3Rpb25SZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIG1vZGlmeUdyaWRsaXN0U2VjdGlvblByb3BzOiBQcm9wTW9kaWZpZXI8U2VjdGlvbkVsZW1lbnQ+KTogVk5vZGU7XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBHcmlkbGlzdEhlYWRQcm9wcyB7XHJcbiAgICByZW5kZXIoKTogVk5vZGU7XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBHcmlkbGlzdEZvb3RQcm9wcyB7XHJcbiAgICByZW5kZXIoKTogVk5vZGU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgR3JpZGxpc3RSb3dQcm9wczxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNDaGlsZFJvd09mU2VjdGlvblwiLCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzQ2hpbGRSb3dPZlNlY3Rpb25cIiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXHJcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNDaGlsZFJvd09mU2VjdGlvblwiLCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwibWFuYWdlZENoaWxkcmVuXCI+LFxyXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xyXG4gICAgcmVuZGVyKGluZm86IFVzZUdyaWRsaXN0Um93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlHcmlkbGlzdFJvd1Byb3BzOiBQcm9wTW9kaWZpZXI8Um93RWxlbWVudD4pOiBWTm9kZTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBHcmlkbGlzdENoaWxkUHJvcHM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlR3JpZGxpc3RDaGlsZFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUdyaWRsaXN0Q2hpbGRQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXHJcbiAgICBHZXQ8VXNlR3JpZGxpc3RDaGlsZFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZUdyaWRsaXN0Q2hpbGRQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VHcmlkbGlzdENoaWxkUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LFxyXG4gICAgT21pdDxHZXQ8VXNlR3JpZGxpc3RDaGlsZFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcInN1YkluZm9cIj4sIFwibG9jYXRpb25cIj4ge1xyXG4gICAgcmVuZGVyKGluZm86IFVzZUdyaWRsaXN0Q2hpbGRSZXR1cm5UeXBlSW5mbzxDZWxsRWxlbWVudD4sIG1vZGlmeUdyaWRsaXN0Q2hpbGRQcm9wczogUHJvcE1vZGlmaWVyPENlbGxFbGVtZW50Pik6IFZOb2RlO1xyXG59XHJcblxyXG5jb25zdCBMb2NhdGlvbkluZGV4Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoMCk7XHJcblxyXG5jb25zdCBTZXRNYW5nbGVyc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PChtOiAobjogbnVtYmVyKSA9PiBudW1iZXIsIGQ6IChuOiBudW1iZXIpID0+IG51bWJlcikgPT4gdm9pZD4obnVsbCEpO1xyXG5jb25zdCBHcmlkbGlzdFNlY3Rpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VHcmlkbGlzdFNlY3Rpb248YW55LCBhbnksIGFueT4+KG51bGwhKTtcclxuY29uc3QgR3JpZGxpc3RSb3dDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VHcmlkbGlzdFJvdzxhbnksIGFueT4+KG51bGwhKTtcclxuY29uc3QgR3JpZGxpc3RDaGlsZENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUdyaWRsaXN0Q2hpbGQ8YW55Pj4obnVsbCEpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJHcmlkbGlzdDxHcmlkbGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ0dyaWRsaXN0LCBtYWtlUHJvcHNHcmlkbGlzdCB9OiB7IHRhZ0dyaWRsaXN0OiBFbGVtZW50VG9UYWc8R3JpZGxpc3RFbGVtZW50PiwgbWFrZVByb3BzR3JpZGxpc3Q6IChpbmZvOiBVc2VHcmlkbGlzdFJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JpZGxpc3RFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUdyaWRsaXN0UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc0dyaWRsaXN0OiBQcm9wTW9kaWZpZXI8R3JpZGxpc3RFbGVtZW50Pikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0dyaWRsaXN0IGFzIG5ldmVyLCBtb2RpZnlQcm9wc0dyaWRsaXN0KG1ha2VQcm9wc0dyaWRsaXN0KGluZm8pKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyR3JpZGxpc3RTZWN0aW9uPEdyaWRsaXN0U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ0dyaWRsaXN0U2VjdGlvbiwgbWFrZVByb3BzR3JpZGxpc3RTZWN0aW9uIH06IHsgdGFnR3JpZGxpc3RTZWN0aW9uOiBFbGVtZW50VG9UYWc8R3JpZGxpc3RTZWN0aW9uRWxlbWVudD4sIG1ha2VQcm9wc0dyaWRsaXN0U2VjdGlvbjogKGluZm86IFVzZUdyaWRsaXN0U2VjdGlvblJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JpZGxpc3RTZWN0aW9uRWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VHcmlkbGlzdFNlY3Rpb25SZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIG1vZGlmeVByb3BzR3JpZGxpc3RTZWN0aW9uOiBQcm9wTW9kaWZpZXI8R3JpZGxpc3RTZWN0aW9uRWxlbWVudD4pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdHcmlkbGlzdFNlY3Rpb24gYXMgbmV2ZXIsIG1vZGlmeVByb3BzR3JpZGxpc3RTZWN0aW9uKG1ha2VQcm9wc0dyaWRsaXN0U2VjdGlvbihpbmZvKSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckdyaWRsaXN0SGVhZDxHcmlkbGlzdEhlYWRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdHcmlkbGlzdEhlYWQsIG1ha2VQcm9wc0dyaWRsaXN0SGVhZCB9OiB7IHRhZ0dyaWRsaXN0SGVhZDogRWxlbWVudFRvVGFnPEdyaWRsaXN0SGVhZEVsZW1lbnQ+LCBtYWtlUHJvcHNHcmlkbGlzdEhlYWQ6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyaWRsaXN0SGVhZEVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnR3JpZGxpc3RIZWFkIGFzIG5ldmVyLCAobWFrZVByb3BzR3JpZGxpc3RIZWFkKCkpKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJHcmlkbGlzdEZvb3Q8R3JpZGxpc3RGb290RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnR3JpZGxpc3RGb290LCBtYWtlUHJvcHNHcmlkbGlzdEZvb3QgfTogeyB0YWdHcmlkbGlzdEZvb3Q6IEVsZW1lbnRUb1RhZzxHcmlkbGlzdEZvb3RFbGVtZW50PiwgbWFrZVByb3BzR3JpZGxpc3RGb290OiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcmlkbGlzdEZvb3RFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0dyaWRsaXN0Rm9vdCBhcyBuZXZlciwgKG1ha2VQcm9wc0dyaWRsaXN0Rm9vdCgpKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyR3JpZGxpc3RSb3c8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdHcmlkbGlzdFJvdywgbWFrZVByb3BzR3JpZGxpc3RSb3cgfTogeyB0YWdHcmlkbGlzdFJvdzogRWxlbWVudFRvVGFnPFJvd0VsZW1lbnQ+LCBtYWtlUHJvcHNHcmlkbGlzdFJvdzogKGluZm86IFVzZUdyaWRsaXN0Um93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUdyaWRsaXN0Um93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc0dyaWRsaXN0Um93OiBQcm9wTW9kaWZpZXI8Um93RWxlbWVudD4pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdHcmlkbGlzdFJvdyBhcyBuZXZlciwgbW9kaWZ5UHJvcHNHcmlkbGlzdFJvdyhtYWtlUHJvcHNHcmlkbGlzdFJvdyhpbmZvKSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckdyaWRsaXN0Q2hpbGQ8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ0dyaWRsaXN0Q2hpbGQsIG1ha2VQcm9wc0dyaWRsaXN0Q2hpbGQgfTogeyB0YWdHcmlkbGlzdENoaWxkOiBFbGVtZW50VG9UYWc8Q2VsbEVsZW1lbnQ+LCBtYWtlUHJvcHNHcmlkbGlzdENoaWxkOiAoaW5mbzogVXNlR3JpZGxpc3RDaGlsZFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlR3JpZGxpc3RDaGlsZFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PiwgbW9kaWZ5UHJvcHNHcmlkbGlzdENoaWxkOiBQcm9wTW9kaWZpZXI8Q2VsbEVsZW1lbnQ+KSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnR3JpZGxpc3RDaGlsZCBhcyBuZXZlciwgbW9kaWZ5UHJvcHNHcmlkbGlzdENoaWxkKG1ha2VQcm9wc0dyaWRsaXN0Q2hpbGQoaW5mbykpKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEdyaWRsaXN0ID0gbWVtbyhmdW5jdGlvbiBHcmlkbGlzdFU8R3JpZGxpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgU2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgY29sbGF0b3IsXHJcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxyXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxyXG4gICAgaW5pdGlhbEluZGV4LFxyXG4gICAgbm9UeXBlYWhlYWQsXHJcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXHJcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxyXG4gICAgdHlwZWFoZWFkVGltZW91dCxcclxuICAgIHJlbmRlclxyXG59OiBHcmlkbGlzdFByb3BzPEdyaWRsaXN0RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VHcmlkbGlzdFNlY3Rpb24sIHVzZUdyaWRsaXN0UHJvcHMsIHVzZUdyaWRsaXN0Um93LCAuLi5ncmlkbGlzdEluZm8gfSA9IHVzZUdyaWRsaXN0PEdyaWRsaXN0RWxlbWVudCwgU2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudD4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzIH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHt9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxHcmlkbGlzdFNlY3Rpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VHcmlkbGlzdFNlY3Rpb259PlxyXG4gICAgICAgICAgICAgICAgPEdyaWRsaXN0Um93Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlR3JpZGxpc3RSb3d9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtyZW5kZXIoZ3JpZGxpc3RJbmZvLCB1c2VHcmlkbGlzdFByb3BzKX1cclxuICAgICAgICAgICAgICAgIDwvR3JpZGxpc3RSb3dDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgICAgICAgICA8L0dyaWRsaXN0U2VjdGlvbkNvbnRleHQuUHJvdmlkZXI+XHJcbiAgICApXHJcbn0pXHJcblxyXG5leHBvcnQgY29uc3QgR3JpZGxpc3RTZWN0aW9uID0gbWVtbyhmdW5jdGlvbiBHcmlkbGlzdFNlY3Rpb25VPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgcmVuZGVyLCBjb21wYXJlUm93cywgaW5kZXggfTogR3JpZGxpc3RTZWN0aW9uUHJvcHM8U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudD4pIHtcclxuICAgIGNvbnN0IHsgdXNlR3JpZGxpc3RTZWN0aW9uUHJvcHMsIC4uLnNlY3Rpb25JbmZvIH0gPSB1c2VDb250ZXh0KEdyaWRsaXN0U2VjdGlvbkNvbnRleHQpKHsgY29tcGFyZVJvd3MgfSk7XHJcbiAgICByZXR1cm4gPExvY2F0aW9uSW5kZXhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmRleH0+e3JlbmRlcihzZWN0aW9uSW5mbywgdXNlR3JpZGxpc3RTZWN0aW9uUHJvcHMpfTwvTG9jYXRpb25JbmRleENvbnRleHQuUHJvdmlkZXI+XHJcbn0pXHJcblxyXG5leHBvcnQgY29uc3QgR3JpZGxpc3RSb3cgPSBtZW1vKGZ1bmN0aW9uIEdyaWRsaXN0Um93VTxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgaW5kZXgsXHJcbiAgICB0ZXh0LFxyXG4gICAgY29sbGF0b3IsXHJcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxyXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxyXG4gICAgZmxhZ3MsXHJcbiAgICBmb2N1c1NlbGYsXHJcbiAgICBoaWRkZW4sXHJcbiAgICBpbmRleERlbWFuZ2xlcixcclxuICAgIGluZGV4TWFuZ2xlcixcclxuICAgIGluaXRpYWxJbmRleCxcclxuICAgIG5vVHlwZWFoZWFkLFxyXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxyXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZVJlbmRlcixcclxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXHJcbiAgICByZW5kZXJcclxufTogR3JpZGxpc3RSb3dQcm9wczxSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCByZWY6IFJlZjxSb3dFbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VHcmlkbGlzdENoaWxkLCB1c2VHcmlkbGlzdFJvd1Byb3BzLCAuLi5yb3dJbmZvIH0gPSB1c2VDb250ZXh0KEdyaWRsaXN0Um93Q29udGV4dCkoe1xyXG4gICAgICAgIGFzQ2hpbGRSb3dPZlNlY3Rpb246IHtcclxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxyXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZiwgaGlkZGVuIH0sXHJcbiAgICAgICAgICAgIHN1YkluZm86IHt9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhc1BhcmVudFJvd09mQ2VsbHM6IHtcclxuICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMgfSxcclxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxyXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIgfSxcclxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ3JpZGxpc3RSb3c6IHsgbG9jYXRpb25JbmRleDogdXNlQ29udGV4dChMb2NhdGlvbkluZGV4Q29udGV4dCkgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gPEdyaWRsaXN0Q2hpbGRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VHcmlkbGlzdENoaWxkfT57cmVuZGVyKHJvd0luZm8sIHVzZUdyaWRsaXN0Um93UHJvcHMpfTwvR3JpZGxpc3RDaGlsZENvbnRleHQuUHJvdmlkZXI+XHJcbn0pXHJcblxyXG5leHBvcnQgY29uc3QgR3JpZGxpc3RDaGlsZCA9IG1lbW8oZnVuY3Rpb24gR3JpZGxpc3RDaGlsZDxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgaW5kZXgsIHRleHQsIGZsYWdzLCBmb2N1c1NlbGYsIGhpZGRlbiwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCByZW5kZXIgfTogR3JpZGxpc3RDaGlsZFByb3BzPENlbGxFbGVtZW50PiwgcmVmOiBSZWY8Q2VsbEVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZUdyaWRsaXN0Q2hpbGRQcm9wcywgLi4uY2VsbEluZm8gfSA9IHVzZUNvbnRleHQoR3JpZGxpc3RDaGlsZENvbnRleHQpKHtcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZiwgaGlkZGVuIH0sXHJcbiAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH0sXHJcbiAgICAgICAgc3ViSW5mbzoge1xyXG4gICAgICAgICAgICBsb2NhdGlvbkluZGV4OiB1c2VDb250ZXh0KExvY2F0aW9uSW5kZXhDb250ZXh0KVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZW5kZXIoY2VsbEluZm8sIHVzZUdyaWRsaXN0Q2hpbGRQcm9wcyk7XHJcbn0pXHJcblxyXG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XHJcbi8vaW1wb3J0IHsgRWxlbWVudFRvVGFnIH0gZnJvbSBcIi4uL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZVRvb2xiYXIsIFVzZVRvb2xiYXJDaGlsZCwgVXNlVG9vbGJhckNoaWxkUGFyYW1ldGVycywgVXNlVG9vbGJhckNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZVRvb2xiYXJQYXJhbWV0ZXJzLCBVc2VUb29sYmFyUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLXRvb2xiYXJcIjtcclxuXHJcbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xiYXJQcm9wczxUb29sYmFyQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRvb2xiYXJDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlVG9vbGJhclBhcmFtZXRlcnMsIFwibGluZWFyTmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VUb29sYmFyUGFyYW1ldGVycywgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VUb29sYmFyUGFyYW1ldGVycywgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDxVc2VUb29sYmFyUGFyYW1ldGVycywgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZVRvb2xiYXJQYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZHJlblwiPixcclxuICAgIEdldDxVc2VUb29sYmFyUGFyYW1ldGVycywgXCJ0b29sYmFyXCI+IHtcclxuICAgIC8vdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xyXG4gICAgcmVuZGVyKGluZm86IFVzZVRvb2xiYXJSZXR1cm5UeXBlSW5mbzxUb29sYmFyQ2hpbGRFbGVtZW50PiwgbW9kaWZ5UHJvcHNUb29sYmFyOiBQcm9wTW9kaWZpZXI8VG9vbGJhckNvbnRhaW5lckVsZW1lbnQ+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xiYXJDaGlsZFByb3BzPFRvb2xiYXJDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlVG9vbGJhckNoaWxkUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRcIj4sXHJcbiAgICBHZXQ8VXNlVG9vbGJhckNoaWxkUGFyYW1ldGVycywgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDxVc2VUb29sYmFyQ2hpbGRQYXJhbWV0ZXJzLCBcImxpc3ROYXZpZ2F0aW9uXCI+IHtcclxuICAgIC8vdGFnTGlzdEl0ZW06IEVsZW1lbnRUb1RhZzxMaXN0Ym94SXRlbUVsZW1lbnQ+O1xyXG4gICAgcmVuZGVyKGluZm86IFVzZVRvb2xiYXJDaGlsZFJldHVyblR5cGVJbmZvPFRvb2xiYXJDaGlsZEVsZW1lbnQ+LCBtb2RpZnlQcm9wc1Rvb2xiYXJDaGlsZDogUHJvcE1vZGlmaWVyPFRvb2xiYXJDaGlsZEVsZW1lbnQ+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuY29uc3QgVG9vbGJhckNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRvb2xiYXJDaGlsZDxhbnk+PihudWxsISk7XHJcblxyXG5mdW5jdGlvbiBUb29sYmFyVTxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgcmVuZGVyLFxyXG4gICAgY29sbGF0b3IsXHJcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxyXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxyXG4gICAgaW5kZXhEZW1hbmdsZXIsXHJcbiAgICBpbmRleE1hbmdsZXIsXHJcbiAgICBvcmllbnRhdGlvbixcclxuICAgIG5vVHlwZWFoZWFkLFxyXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxyXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxyXG4gICAgb25UYWJiYWJsZVJlbmRlcixcclxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXHJcbiAgICBpbml0aWFsSW5kZXhcclxufTogVG9vbGJhclByb3BzPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VUb29sYmFyQ2hpbGQsXHJcbiAgICAgICAgdXNlVG9vbGJhclByb3BzLFxyXG4gICAgICAgIC4uLmxpc3Rib3hSZXR1cm5UeXBlXHJcbiAgICB9ID0gdXNlVG9vbGJhcjxDb250YWluZXJFbGVtZW50LCBDaGlsZEVsZW1lbnQ+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cyB9LFxyXG4gICAgICAgIHRvb2xiYXI6IHsgb3JpZW50YXRpb24gfSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyLCBpbml0aWFsSW5kZXggfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxUb29sYmFyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVG9vbGJhckNoaWxkfT5cclxuICAgICAgICAgICAge3JlbmRlcih7IC4uLmxpc3Rib3hSZXR1cm5UeXBlIH0sIHVzZVRvb2xiYXJQcm9wcyl9XHJcbiAgICAgICAgPC9Ub29sYmFyQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIClcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIFRvb2xiYXJDaGlsZFU8TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgaW5kZXgsXHJcbiAgICByZW5kZXIsXHJcbiAgICBmbGFncyxcclxuICAgIGZvY3VzU2VsZixcclxuICAgIGhpZGRlbixcclxuICAgIHRleHRcclxufTogVG9vbGJhckNoaWxkUHJvcHM8TGlzdEl0ZW1FbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VUb29sYmFyQ2hpbGRQcm9wcywgcm92aW5nVGFiSW5kZXggfSA9IHVzZUNvbnRleHQoVG9vbGJhckNvbnRleHQpKHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmLCBoaWRkZW4gfSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXHJcbiAgICAgICAgc3ViSW5mbzogdW5kZWZpbmVkIVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PntyZW5kZXIoeyByb3ZpbmdUYWJJbmRleCB9LCB1c2VUb29sYmFyQ2hpbGRQcm9wcyl9PC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBUb29sYmFyID0gbWVtbyhUb29sYmFyVSkgYXMgdHlwZW9mIFRvb2xiYXJVO1xyXG5leHBvcnQgY29uc3QgVG9vbGJhckNoaWxkID0gbWVtbyhUb29sYmFyQ2hpbGRVKSBhcyB0eXBlb2YgVG9vbGJhckNoaWxkVTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVG9vbGJhcjxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNDb250YWluZXIsIHRhZ0NvbnRhaW5lciB9OiB7IHRhZ0NvbnRhaW5lcjogRWxlbWVudFRvVGFnPENvbnRhaW5lckVsZW1lbnQ+LCBtYWtlUHJvcHNDb250YWluZXI6IChpbmZvOiBVc2VUb29sYmFyUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyRWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUb29sYmFyUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiwgbW9kaWZ5UHJvcHNDb250YWluZXI6IFByb3BNb2RpZmllcjxDb250YWluZXJFbGVtZW50Pik6IFZOb2RlPGFueT4ge1xyXG4gICAgICAgIGNvbnN0IGxpc3QgPSBjcmVhdGVFbGVtZW50KHRhZ0NvbnRhaW5lciBhcyBuZXZlciwgbW9kaWZ5UHJvcHNDb250YWluZXIobWFrZVByb3BzQ29udGFpbmVyKGluZm8pKSk7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIHtsaXN0fVxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVG9vbGJhckNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbWFrZVByb3BzQ2hpbGQsIHRhZ0NoaWxkIH06IHsgdGFnQ2hpbGQ6IEVsZW1lbnRUb1RhZzxDaGlsZEVsZW1lbnQ+LCBtYWtlUHJvcHNDaGlsZDogKGluZm86IFVzZVRvb2xiYXJDaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUb29sYmFyQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+LCBtb2RpZnlQcm9wc0xpc3RJdGVtOiBQcm9wTW9kaWZpZXI8Q2hpbGRFbGVtZW50Pik6IFZOb2RlPGFueT4ge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0NoaWxkIGFzIG5ldmVyLCBtb2RpZnlQcm9wc0xpc3RJdGVtKG1ha2VQcm9wc0NoaWxkKGluZm8pKSk7XHJcbiAgICB9XHJcbn0iLCJcclxuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGgsIFJlbmRlcmFibGVQcm9wcyB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBBY2NvcmRpb24sIEFjY29yZGlvblNlY3Rpb24sIGRlZmF1bHRSZW5kZXJBY2NvcmRpb25TZWN0aW9uIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XHJcblxyXG5mdW5jdGlvbiBEZW1vQWNjb3JkaW9uKHsgY2hpbGRyZW4sIC4uLnByb3BzIH06IFJlbmRlcmFibGVQcm9wczx7fT4pIHtcclxuICAgIHJldHVybiA8QWNjb3JkaW9uIHsuLi5wcm9wc30gcmVuZGVyPXsoX2luZm8pID0+IHsgcmV0dXJuIDxkaXYgaWQ9XCJhY2NvcmRpb24tZGVtb1wiPntjaGlsZHJlbn08L2Rpdj4gfX0gLz5cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XHJcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50O1xyXG59XHJcblxyXG5jb25zdCBEZW1vQWNjb3JkaW9uU2VjdGlvbiA9IG1lbW8oZnVuY3Rpb24gRGVtb0FjY29yZGlvblNlY3Rpb24oeyBpbmRleCwgYm9keSwgaGVhZGluZywgZGlzYWJsZWQsIG9wZW4gfTogeyBvcGVuPzogYm9vbGVhbiwgZGlzYWJsZWQ6IGJvb2xlYW4sIGluZGV4OiBudW1iZXIsIGhlYWRpbmc6IENvbXBvbmVudENoaWxkcmVuLCBib2R5OiBDb21wb25lbnRDaGlsZHJlbiB9KSB7XHJcbiAgICByZXR1cm4gPEFjY29yZGlvblNlY3Rpb248SFRNTEJ1dHRvbkVsZW1lbnQsIEhUTUxEaXZFbGVtZW50PiBpbmRleD17aW5kZXh9IHRhZ0J1dHRvbj1cImJ1dHRvblwiIG9wZW49e29wZW59IGRpc2FibGVkPXtkaXNhYmxlZH0gZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fSByZW5kZXI9e2RlZmF1bHRSZW5kZXJBY2NvcmRpb25TZWN0aW9uKHtcclxuICAgICAgICBtYWtlUHJvcHNCb2R5OiAoaW5mbykgPT4geyByZXR1cm4geyBoaWRkZW46ICFpbmZvLmFjY29yZGlvblNlY3Rpb24uZXhwYW5kZWQsIGNoaWxkcmVuOiBib2R5IH0gfSxcclxuICAgICAgICBtYWtlUHJvcHNIZWFkaW5nQnV0dG9uOiAoKSA9PiB7IHJldHVybiB7IGNoaWxkcmVuOiBoZWFkaW5nIH0gfSxcclxuICAgICAgICBtYWtlUHJvcHNIZWFkaW5nQ29udGFpbmVyOiAoKSA9PiAoe30pLFxyXG4gICAgICAgIHRhZ0JvZHk6IFwiZGl2XCIsXHJcbiAgICAgICAgdGFnSGVhZGluZ0J1dHRvbjogXCJidXR0b25cIlxyXG4gICAgfSl9IC8+XHJcbn0pXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2FjY29yZGlvbi9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgQWNjb3JkaW9uIHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5FYWNoIHNlY3Rpb24ncyBoZWFkZXIgYW5kIGJvZHkgYXJlIGxpbmtlZCB2aWEgSUQ7IHRoZSBib2R5IGlzIDxjb2RlPmxhYmVsbGVkLWJ5PC9jb2RlPiB0aGUgaGVhZGVyIGFuZCB0aGUgaGVhZGVyIDxjb2RlPmNvbnRyb2w8L2NvZGU+cyB0aGUgYm9keS48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRoZSBoZWFkZXIgaXMgYSBidXR0b24gYW5kIHJlc3BvbmRzIHRvIGtleWJvYXJkLCBtb3VzZSwgdG91Y2gsIGV0Yy4gZXZlbnRzLCByZWdhcmRsZXNzIG9mIHRoZSBlbGVtZW50IHVzZWQuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5JZiB0aGUgaGVhZGVyIGVsZW1lbnQgaXMgbm90IGEgPGNvZGU+Jmx0O2J1dHRvbiZndDs8L2NvZGU+IGVsZW1lbnQsIGl0IGlzIGdpdmVuIHRoYXQgPGNvZGU+cm9sZTwvY29kZT4uPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5VcC9kb3duICZhbXA7IEhvbWUvRW5kIGtleXMgbmF2aWdhdGUgdGhyb3VnaCB0aGUgbGlzdCwgYXMgZG9lcyBUYWIgYW5kIFNoaWZ0K1RhYjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+PC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIDxjb2RlPnJlbmRlcjwvY29kZT4gcHJvcCBlYWNoIDxjb2RlPkFjY29yZGlvblNlY3Rpb248L2NvZGU+IHRha2VzIG11c3Qgd3JhcCB0aGUgaGVhZGVyIGJ1dHRvbiB3aXRoIGEgPGEgaHJlZj1cImh0dHBzOi8vdzNjLmdpdGh1Yi5pby9hcmlhLyNoZWFkaW5nXCI+aGVhZGluZzwvYT4gKGUuZy4gPGNvZGU+aDM8L2NvZGU+LCBvciA8Y29kZT4mbHQ7SGVhZGluZyZndDs8L2NvZGU+KS4gU2VlIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBhbiBleGFtcGxlLjwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xyXG4gICAgcmV0dXJuICg8Y29kZT57YDxBY2NvcmRpb24gcmVuZGVyPXsuLi59PlxyXG4gICAgPEFjY29yZGlvblNlY3Rpb24gaW5kZXg9ezB9IHJlbmRlcj17Li4ufSAvPlxyXG4gICAgPEFjY29yZGlvblNlY3Rpb24gaW5kZXg9ezF9IHJlbmRlcj17Li4ufSAvPlxyXG4gICAgPEFjY29yZGlvblNlY3Rpb24gaW5kZXg9ezJ9IHJlbmRlcj17Li4ufSAvPlxyXG48L0FjY29yZGlvbj5gfTwvY29kZT4pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xyXG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxCbHVyYiAvPlxyXG4gICAgICAgICAgICA8Q29kZSAvPlxyXG4gICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49ezB9IHZhbHVlPXtjb3VudH0gb25JbnB1dD17ZSA9PiBzZXRDb3VudChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+ICMgb2YgYWNjb3JkaW9uIHNlY3Rpb25zPC9sYWJlbD5cclxuICAgICAgICAgICAgPERlbW9BY2NvcmRpb24+XHJcbiAgICAgICAgICAgICAgICA8PntBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIDxEZW1vQWNjb3JkaW9uU2VjdGlvbiBpbmRleD17MH0gaGVhZGluZz1cIkFjY29yZGlvbiBzZWN0aW9uICMwXCIgYm9keT1cIkJvZHkgY29udGVudCAjMFwiIGRpc2FibGVkPXtmYWxzZX0gLz5cclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezF9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjMVwiIGJvZHk9XCJCb2R5IGNvbnRlbnQgIzFcIiBkaXNhYmxlZD17ZmFsc2V9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXsyfSBoZWFkaW5nPVwiQWNjb3JkaW9uIHNlY3Rpb24gIzIgKGRpc2FibGVkKVwiIGJvZHk9XCJCb2R5IGNvbnRlbnQgIzJcIiBkaXNhYmxlZD17dHJ1ZX0gLz5cclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezN9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjMyAoZm9yY2VkIG9wZW4pXCIgYm9keT1cIkJvZHkgY29udGVudCAjM1wiIGRpc2FibGVkPXtmYWxzZX0gb3Blbj17dHJ1ZX0gLz5cclxuICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezR9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjNCAoZm9yY2VkIGNsb3NlZClcIiBib2R5PVwiQm9keSBjb250ZW50ICM0XCIgZGlzYWJsZWQ9e2ZhbHNlfSBvcGVuPXtmYWxzZX0gLz5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gNTsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXtpfSBoZWFkaW5nPXtgQWNjb3JkaW9uIHNlY3Rpb24gIyR7aX1gfSBib2R5PXtgQm9keUNvbnRlbnQgIyR7aX1gfSBkaXNhYmxlZD17ZmFsc2V9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkoKSkuc2xpY2UoMCwgY291bnQpfTwvPlxyXG4gICAgICAgICAgICA8L0RlbW9BY2NvcmRpb24+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn0iLCJcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBCdXR0b24sIGRlZmF1bHRSZW5kZXJCdXR0b24sIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XHJcblxyXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcclxuICAgIHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvYnV0dG9uL1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBCdXR0b24gcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpPldoZXRoZXIgdXNpbmcgYW4gYWN0dWFsIDxjb2RlPiZsdDtidXR0b24mZ3Q7PC9jb2RlPiwgb3Igc29tZXRoaW5nIGVsc2UgbGlrZSBhIDxjb2RlPiZsdDtkaXYmZ3Q7PC9jb2RlPiwgdGhlIHByb3BlciByb2xlcyBhbmQgZXZlbnQgaGFuZGxlcnMgd2lsbCBiZSBhcHBsaWVkLjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+QnV0dG9ucyBjYW4gYmUgdG9nZ2xlZCAocHJlc3NlZCBvciB1bnByZXNzZWQpLjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIGJ1dHRvbiByZXNwb25kcyB0byBrZXlib2FyZCwgbW91c2UsIHRvdWNoLCBldGMuIGV2ZW50cywgcmVnYXJkbGVzcyBvZiB0aGUgZWxlbWVudCB1c2VkLlxyXG4gICAgICAgICAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPkRvdWJsZS1jbGlja3MgZG8gbm90IHNlbGVjdCB0ZXh0LCBidXQgdGV4dCBpcyBzdGlsbCBzZWxlY3RhYmxlIHdpdGhvdXQgaXQgY291bnRpbmcgYXMgYSBwcmVzcy9jbGljazwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5XaGVuIEVudGVyIGlzIHByZXNzZWQsIHRoZSBidXR0b24gaXMgaW1tZWRpYXRlbHkgYWN0aXZhdGVkPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPldoZW4gU3BhY2UgaXMgcHJlc3NlZCwgdGhlIGJ1dHRvbiBpcyBhY3RpdmF0ZWQgb25jZSByZWxlYXNlZDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5pT1MgU2FmYXJpIHByb3Blcmx5IGZvY3VzZXMgdGhlIGJ1dHRvbjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpPklmIHlvdXIgYnV0dG9uIGNvbnRhaW5zIG9ubHkgYW4gaWNvbiAob3Igb3RoZXIgbm9uLWRlc2NyaXB0aXZlIGNvbnRlbnQsIGV0Yy4pLCB5b3UgbXVzdCBwcm92aWRlIGFuIDxjb2RlPmFyaWEtbGFiZWw8L2NvZGU+IG1hbnVhbGx5IHN0YXRpbmcgd2hhdCBoYXBwZW5zIHdoZW4gdGhlIGJ1dHRvbiBpcyBwcmVzc2VkLjwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xyXG4gICAgcmV0dXJuICg8Y29kZT57YDxCdXR0b24gdGFnPVwiYnV0dG9uXCI+QnV0dG9uPC9CdXR0b24+XHJcbiAgICA8QnV0dG9uIHRhZz1cImRpdlwiPkRpdjwvQnV0dG9uPmB9PC9jb2RlPilcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XHJcbiAgICBjb25zdCBbcHJlc3NlZCwgc2V0UHJlc3NlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPERlbW9CdXR0b24gZGlzYWJsZWQ9e2ZhbHNlfSB0YWc9XCJidXR0b25cIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0J1dHRvbiBkaXNhYmxlZD1cInNvZnRcIiB0YWc9XCJidXR0b25cIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0J1dHRvbiBkaXNhYmxlZD1cImhhcmRcIiB0YWc9XCJidXR0b25cIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0J1dHRvbiBkaXNhYmxlZD17ZmFsc2V9IHRhZz1cImRpdlwiIC8+XHJcbiAgICAgICAgICAgIDxEZW1vQnV0dG9uIGRpc2FibGVkPVwic29mdFwiIHRhZz1cImRpdlwiIC8+XHJcbiAgICAgICAgICAgIDxEZW1vQnV0dG9uIGRpc2FibGVkPVwiaGFyZFwiIHRhZz1cImRpdlwiIC8+XHJcbiAgICAgICAgICAgIDxCdXR0b24gZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fSBkaXNhYmxlZD17ZmFsc2V9IHRhZ0J1dHRvbj1cImJ1dHRvblwiIHByZXNzZWQ9e3ByZXNzZWR9IG9uUHJlc3M9e2UgPT4gc2V0UHJlc3NlZChlW0V2ZW50RGV0YWlsXS5wcmVzc2VkID8/IGZhbHNlKX0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyQnV0dG9uKFwiYnV0dG9uXCIsICgpID0+ICh7IGNoaWxkcmVuOiBgVG9nZ2xlIGJ1dHRvbiAoJHtwcmVzc2VkPyBcInByZXNzZWRcIiA6IFwidW5wcmVzc2VkXCJ9KWB9KSl9IC8+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIERlbW9CdXR0b24oeyB0YWcsIGRpc2FibGVkfTogeyB0YWc6IHN0cmluZywgZGlzYWJsZWQ6IGJvb2xlYW4gfCBcInNvZnRcIiB8IFwiaGFyZFwiIH0pIHtcclxuICAgIGNvbnN0IG9uUHJlc3MgPSAoKSA9PiB7IGFsZXJ0KFwiQnV0dG9uIGNsaWNrZWRcIikgfVxyXG5cclxuICAgIHJldHVybiAoIFxyXG4gICAgICAgIDxCdXR0b24gZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fSB0YWdCdXR0b249e3RhZyBhcyBhbnl9IG9uUHJlc3M9e29uUHJlc3N9IHJlbmRlcj17ZGVmYXVsdFJlbmRlckJ1dHRvbih0YWcsICgpID0+ICh7IGNsYXNzOiBcImJ0blwiLCBjaGlsZHJlbjogYCR7dGFnfSAke2Rpc2FibGVkPyBgIGRpc2FibGVkICgke2Rpc2FibGVkID09IFwic29mdFwiPyBcInNvZnRcIiA6IFwiaGFyZFwifSlgIDogXCJcIn1gIH0pKX0gIC8+XHJcbiAgICApXHJcbn0iLCJcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEJ1dHRvbiwgQ2hlY2tib3gsIGRlZmF1bHRSZW5kZXJCdXR0b24sIGRlZmF1bHRSZW5kZXJDaGVja2JveCwgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcclxuXHJcbi8qZnVuY3Rpb24gRGVtb0J1dHRvbih7IHRhZywgLi4ucHJvcHMgfTogeyB0YWc6IHN0cmluZyB9ICYgUmVuZGVyYWJsZVByb3BzPHt9Pikge1xyXG4gICAgcmV0dXJuIDxCdXR0b24gZGlzYWJsZWQ9e2Rpc2FibGVkfSBvblByZXNzPXtvblByZXNzfSBwcmVzc2VkPXt9IHsuLi5wcm9wc30gdGFnPXt0YWcgYXMgYW55fSAgIC8+XHJcbn0qL1xyXG5cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2NoZWNrYm94L1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBDaGVja2JveCBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+VG9nZ2xlcyBiZXR3ZWVuIGNoZWNrZWQgYW5kIHVuY2hlY2tlZCB3aGVuIHByZXNzZWQgKGNsaWNrZWQsIEVudGVyIHByZXNzZWQsIFNwYWNlIHJlbGVhc2VkLCBldGMuKTwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+Q2FuIGJlIDxjb2RlPm1peGVkPC9jb2RlPiBpbnN0ZWFkLCB0aG91Z2ggPGNvZGU+b25JbnB1dDwvY29kZT4gd2lsbCBvbmx5IGV2ZXIgYmUgY2FsbGVkIHdpdGggPGNvZGU+dHJ1ZTwvY29kZT4gb3IgPGNvZGU+ZmFsc2U8L2NvZGU+PC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5TdXBwb3J0cyB1c2luZyA8Y29kZT4mbHQ7aW5wdXQmZ3Q7PC9jb2RlPnMgYW5kIDxjb2RlPiZsdDtsYWJlbCZndDs8L2NvZGU+cywgYXMgd2VsbCBhcyBqdXN0IHBsYWluIG9sJyA8Y29kZT4mbHQ7ZGl2Jmd0OzwvY29kZT5zIG9uIGVpdGhlci9ib3RoPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgY2hlY2tib3ggYW5kIGxhYmVsIGNhbiBiZSBzaWJsaW5nIGVsZW1lbnRzLCBsaWtlIG5vcm1hbCwgb3IgdGhlIGxhYmVsIGNhbiB3cmFwIHRoZSBpbnB1dCBmb3IgYSBsYXJnZXIgaGl0IGFyZWEuIEluIGFsbCBjYXNlcywgdGhlIGFwcHJvcHJpYXRlIHJvbGVzL2V2ZW50IGhhbmRsZXJzIHdpbGwgYmUgYXBwbGllZCB0byBlYWNoIGVsZW1lbnQuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIHNlbGVjdGluZyB0aGUgdGV4dCBvZiBhIGNoZWNrYm94J3MgbGFiZWwsIHRoaXMgZG9lcyBub3QgY2hhbmdlIHRoZSBjaGVja2JveCdzIHN0YXRlPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5Eb3VibGUtY2xpY2tpbmcgdGhlIGxhYmVsIGNoZWNrcyAmYW1wOyB1bi1jaGVja3MgdGhlIGNoZWNrYm94IGluc3RlYWQgb2Ygc2VsZWN0aW5nIHRoZSBsYWJlbCdzIHRleHQ8L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPkNoZWNrYm94IGdyb3VwcyAod2l0aCBhIHRyaS1zdGF0ZSBwYXJlbnQpIGFyZSBhIHNlcGFyYXRlIGNvbXBvbmVudC9ob29rPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+SWYgeW91ciBjaGVja2JveCBkb2VzIG5vdCBoYXZlIGEgdmlzaWJsZSBsYWJlbCAoYWNoaWV2YWJsZSBieSBieSBvdmVycmlkaW5nIHRoZSA8Y29kZT5yZW5kZXI8L2NvZGU+IHByb3AgYW5kIHNldHRpbmcgPGNvZGU+bGFiZWxQb3NpdGlvbjwvY29kZT4gdG8gYmUgXCJzZXBhcmF0ZVwiKSwgeW91IG11c3QgcGFzcyA8Y29kZT5hcmlhLWxhYmVsPC9jb2RlPiBhcyBhIHByb3AgdG8gdGhlIGNoZWNrYm94IG1hbnVhbGx5LiBOb3QgcHJvdmlkaW5nIG9uZSB3aWxsIHByaW50IGFuIGVycm9yIHRvIHRoZSBjb25zb2xlLCBidXQgaXQgaXQgbm90IHJlcXVpcmVkIGJ5IHRoZSB0eXBlIHN5c3RlbS48L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcclxuICAgIHJldHVybiAoPGNvZGU+e2A8Q2hlY2tib3ggY2hlY2tlZD17dHJ1ZX0gbGFiZWxQb3NpdGlvbj1cInNlcGFyYXRlXCIgdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwibGFiZWxcIj5MYWJlbCB0ZXh0PC9DaGVja2JveD5gfTwvY29kZT4pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xyXG5cclxuICAgIGNvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkXSA9IHVzZVN0YXRlKGZhbHNlIGFzIGJvb2xlYW4gfCBcIm1peGVkXCIpO1xyXG5cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxCbHVyYiAvPlxyXG4gICAgICAgICAgICA8Q29kZSAvPlxyXG4gICAgICAgICAgICA8QnV0dG9uIHRhZ0J1dHRvbj1cImJ1dHRvblwiIGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gb25QcmVzcz17KCkgPT4geyBzZXRDaGVja2VkKFwibWl4ZWRcIiBhcyBhbnkpOyB9fSByZW5kZXI9e2RlZmF1bHRSZW5kZXJCdXR0b24oXCJidXR0b25cIiwgKCkgPT4gKHsgY2hpbGRyZW46IFwiQ2hhbmdlIHRvIG1peGVkXCIgfSkpfSAvPlxyXG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IHNldENoZWNrZWQ9e3NldENoZWNrZWR9IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwibGFiZWxcIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IHNldENoZWNrZWQ9e3NldENoZWNrZWR9IGxhYmVsUG9zaXRpb249XCJ3cmFwcGluZ1wiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwibGFiZWxcIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IHNldENoZWNrZWQ9e3NldENoZWNrZWR9IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJkaXZcIiB0YWdMYWJlbD1cImxhYmVsXCIgLz5cclxuICAgICAgICAgICAgPERlbW9DaGVja2JveCBjaGVja2VkPXtjaGVja2VkfSBzZXRDaGVja2VkPXtzZXRDaGVja2VkfSBsYWJlbFBvc2l0aW9uPVwid3JhcHBpbmdcIiBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiZGl2XCIgdGFnTGFiZWw9XCJsYWJlbFwiIC8+XHJcbiAgICAgICAgICAgIDxEZW1vQ2hlY2tib3ggY2hlY2tlZD17Y2hlY2tlZH0gc2V0Q2hlY2tlZD17c2V0Q2hlY2tlZH0gbGFiZWxQb3NpdGlvbj1cInNlcGFyYXRlXCIgZGlzYWJsZWQ9e2ZhbHNlfSB0YWdJbnB1dD1cImlucHV0XCIgdGFnTGFiZWw9XCJkaXZcIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IHNldENoZWNrZWQ9e3NldENoZWNrZWR9IGxhYmVsUG9zaXRpb249XCJ3cmFwcGluZ1wiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwiZGl2XCIgLz5cclxuICAgICAgICAgICAgPERlbW9DaGVja2JveCBjaGVja2VkPXtjaGVja2VkfSBzZXRDaGVja2VkPXtzZXRDaGVja2VkfSBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIiBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiZGl2XCIgdGFnTGFiZWw9XCJkaXZcIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IHNldENoZWNrZWQ9e3NldENoZWNrZWR9IGxhYmVsUG9zaXRpb249XCJ3cmFwcGluZ1wiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJkaXZcIiB0YWdMYWJlbD1cImRpdlwiIC8+XHJcbiAgICAgICAgICAgIDxEZW1vQ2hlY2tib3ggY2hlY2tlZD17Y2hlY2tlZH0gc2V0Q2hlY2tlZD17c2V0Q2hlY2tlZH0gbGFiZWxQb3NpdGlvbj1cImhpZGRlblwiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwibGFiZWxcIiAvPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBEZW1vQ2hlY2tib3goeyBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIGRpc2FibGVkLCBjaGVja2VkLCBzZXRDaGVja2VkIH06IHsgZGlzYWJsZWQ6IGJvb2xlYW4sIGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIiB8IFwid3JhcHBpbmdcIiB8IFwiaGlkZGVuXCIsIHRhZ0lucHV0OiBzdHJpbmcsIHRhZ0xhYmVsOiBzdHJpbmcsIGNoZWNrZWQ6IGJvb2xlYW4gfCBcIm1peGVkXCIsIHNldENoZWNrZWQ6IFN0YXRlVXBkYXRlcjxib29sZWFuIHwgXCJtaXhlZFwiPiB9KSB7XHJcbiAgICAvL2NvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBzdHlsZT17eyBib3JkZXI6IFwiMXB4IHNvbGlkIGJsYWNrXCIgfX0+XHJcbiAgICAgICAgICAgIDxDaGVja2JveFxyXG4gICAgICAgICAgICBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9XHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XHJcbiAgICAgICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxyXG4gICAgICAgICAgICAgICAgb25DaGVja2VkQ2hhbmdlPXtlID0+IHNldENoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCl9XHJcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uPXtsYWJlbFBvc2l0aW9uID09IFwiaGlkZGVuXCIgPyBcInNlcGFyYXRlXCIgOiBsYWJlbFBvc2l0aW9ufVxyXG4gICAgICAgICAgICAgICAgdGFnSW5wdXQ9e3RhZ0lucHV0IGFzIG5ldmVyfVxyXG4gICAgICAgICAgICAgICAgdGFnTGFiZWw9e3RhZ0xhYmVsIGFzIG5ldmVyfVxyXG4gICAgICAgICAgICAgICAgcmVuZGVyPXtkZWZhdWx0UmVuZGVyQ2hlY2tib3goe1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgdGFnSW5wdXQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFnTGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFrZUlucHV0UHJvcHM6ICgpID0+ICh7IFwiYXJpYS1sYWJlbFwiOiBsYWJlbFBvc2l0aW9uID09IFwiaGlkZGVuXCIgPyBgSGlkZGVuIGxhYmVsICh0ZWNobmljYWxseSBzZXBhcmF0ZSksICR7dGFnSW5wdXR9IGFuZCAke3RhZ0xhYmVsfSAke2NoZWNrZWQgPyBcImNoZWNrZWRcIiA6IFwibm90IGNoZWNrZWRcIn1gIDogdW5kZWZpbmVkLCB9KSxcclxuICAgICAgICAgICAgICAgICAgICBtYWtlTGFiZWxQcm9wczogKCkgPT4gKHsgY2hpbGRyZW46IGAke2xhYmVsUG9zaXRpb259LCAke3RhZ0lucHV0fSBhbmQgJHt0YWdMYWJlbH0sICR7Y2hlY2tlZCA/IFwiY2hlY2tlZFwiIDogXCJub3QgY2hlY2tlZFwifWAgfSlcclxuICAgICAgICAgICAgICAgIH0pfVxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICB7bGFiZWxQb3NpdGlvbiA9PSBcImhpZGRlblwiICYmIDxkaXY+KFRoaXMgaXMgbm90IGEgbGFiZWwgLS0gdGhlIGFjdHVhbCBsYWJlbCBpcyB2aWEgdGhlIDxjb2RlPmFyaWEtbGFiZWw8L2NvZGU+IHByb3ApPC9kaXY+fVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XHJcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50O1xyXG59XHJcbiIsIlxyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IENoZWNrYm94R3JvdXAsIENoZWNrYm94R3JvdXBDaGVja2JveCwgZGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXAsIGRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGQsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XHJcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBEZW1vQ2hlY2tib3goeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xyXG4gICAgY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgbGFiZWxUZXh0ID0gYENoZWNrYm94ICMke2luZGV4fWBcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPENoZWNrYm94R3JvdXBDaGVja2JveCByZW5kZXI9e2RlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGQoe1xyXG4gICAgICAgICAgICBsYWJlbFBvc2l0aW9uOiBcInNlcGFyYXRlXCIsXHJcbiAgICAgICAgICAgIHRhZ0lucHV0OiBcImlucHV0XCIsXHJcbiAgICAgICAgICAgIHRhZ0xhYmVsOiBcImxhYmVsXCIsXHJcbiAgICAgICAgICAgIG1ha2VJbnB1dFByb3BzOiAoKSA9PiAoe30pLFxyXG4gICAgICAgICAgICBtYWtlTGFiZWxQcm9wczogKCkgPT4gKHsgY2hpbGRyZW46IGxhYmVsVGV4dCB9KVxyXG4gICAgICAgIH0pfVxyXG4gICAgICAgICAgICBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9XHJcbiAgICAgICAgICAgIGNoZWNrZWQ9e2NoZWNrZWR9XHJcbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cclxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZhbHNlfVxyXG4gICAgICAgICAgICBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIlxyXG4gICAgICAgICAgICB0ZXh0PXtsYWJlbFRleHR9XHJcbiAgICAgICAgICAgIHRhZ0lucHV0PVwiaW5wdXRcIlxyXG4gICAgICAgICAgICB0YWdMYWJlbD1cImxhYmVsXCJcclxuICAgICAgICAgICAgb25DaGVja2VkQ2hhbmdlPXtlID0+IHNldENoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCl9IC8+XHJcbiAgICApXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8cD5DaGVja2JveCBncm91cHMgYXJlIGFuIGFsdGVybmF0aXZlIHRvIG11bHRpLXNlbGVjdCBsaXN0cy4gVGhlcmUgaXMgbm8gcm9sZSBvZiA8Y29kZT5jaGVja2JveGdyb3VwPC9jb2RlPiwgYnV0IHRoaXMgYWltcyB0byBiZSBhbiBBUklBLWNvbXBsaWFudCBpbXBsZW1lbnRhdGlvbiBvZiBhIGNoZWNrYm94IGdyb3VwLjwvcD5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpPkFsbCBub3JtYWwgPGNvZGU+Q2hlY2tib3g8L2NvZGU+IGZ1bmN0aW9uYWxpdHkgaXMgc3VwcG9ydGVkIG9uIGVhY2ggaW5kaXZpZHVhbCBjaGVja2JveC48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRoZSBwYXJlbnQgY2hlY2tib3ggc3dpdGNoZXMgYmV0d2VlbiAzIHN0YXRlcywgcmVtZW1iZXJpbmcgdGhlIGxhc3Qgc3RhdGUgdGhhdCBjYXVzZWQgaXQgdG8gYmUgXCJtaXhlZFwiLjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIHBhcmVudCBjaGVja2JveCByZWFjdHMgdG8gZWFjaCBjaGlsZCdzIDxjb2RlPmNoZWNrZWQ8L2NvZGU+IHByb3AgYW5kIHVwZGF0ZXMgaXRzIG93biBpbnRlcm5hbCA8Y29kZT5jaGVja2VkPC9jb2RlPiBhdHRyaWJ1dGUgKGJlIGF3YXJlIG9mIHRoaXMgaWYgdGhleSdyZSBhc3luY3Jvbm91cywgYXMgeW91J2xsIHdhbnQgdG8gZW5zdXJlIHRoZXkgYWxsIHJlc29sdmUgb24gdGhlIHNhbWUgdGljayB3aXRoIDxjb2RlPlByb21pc2UuYWxsPC9jb2RlPiB0byBub3QgY2xvYmJlciB0aGUgdXNlcidzIGlucHV0cykuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgY2hpbGRyZW4gYXJlIHRyZWF0ZWQgYXMgYSBjb21wb3NpdGUgY29tcG9uZW50IHdpdGggbGlzdCBuYXZpZ2F0aW9uOyBzZWUgPGNvZGU+QWlyYVNpbmdsZVNlbGVjdExpc3Q8L2NvZGU+IGZvciBtb3JlIGluZm9ybWF0aW9uPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+SXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBwYXJlbnQgY2hlY2tib3ggcHJvdmlkZXMgc3VmZmljaWVudCBsYWJlbGxpbmcgZm9yIGFsbCB0aGUgY2hpbGRyZW4sIHdoaWNoIGhvdyB0aGUgZGVtbyBleGFtcGxlIGlkZW50aWZpZXMgdGhlc2UgZWxlbWVudHMuIElmIHlvdSBoYXZlIGEgc2VwYXJhdGUgbGFiZWwsIHlvdSB3aWxsIG5lZWQgdG8gd3JhcCB0aGUgY2hpbGRyZW4gaW4gYSA8Y29kZT5yb2xlPWdyb3VwPC9jb2RlPiB0aGF0IHJlZmVyZW5jZXMgdGhhdCBsYWJlbCBieSBvdmVycmlkaW5nIDxjb2RlPnJlbmRlcjwvY29kZT4uPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5TZWUgdGhlIGNhdmVhdCBhYm92ZSBmb3Igd2hlbiBlYWNoIGNoaWxkJ3MgPGNvZGU+b25JbnB1dDwvY29kZT4gdGFrZXMgYSB2YXJpYWJsZSBhbW91bnQgb2YgdGltZSB0byBhY3R1YWxseSB1cGRhdGUgdGhlIDxjb2RlPmNoZWNrZWQ8L2NvZGU+IHByb3AsIGFzIGl0IGNhbiBjbG9iYmVyIHRoZSB1c2VyJ3MgbGFzdCBpbnB1dCB3aGVuIGNsaWNraW5nIG9uIHRoZSBwYXJlbnQ8L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcclxuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xyXG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIGNoZWNrYm94ZXM8L2xhYmVsPlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPENoZWNrYm94R3JvdXAgZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fSBkaXNhYmxlZD17ZmFsc2V9IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIHRhZ0lucHV0PVwiaW5wdXRcIiB0YWdMYWJlbD1cImxhYmVsXCIgcmVuZGVyPXtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnSW5wdXQ6IFwiaW5wdXRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTGFiZWw6IFwibGFiZWxcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZUlucHV0UHJvcHM6ICgpID0+ICh7fSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VMYWJlbFByb3BzOiAoKSA9PiAoeyBjaGlsZHJlbjogXCJHcm91cCBjaGVja2JveCBwYXJlbnRcIiB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8ZGl2PjxEZW1vQ2hlY2tib3ggaW5kZXg9e2l9IGtleT17aX0gLz48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSlcclxuICAgICAgICAgICAgICAgICAgICB9KX0gLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn0iLCJcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgTGlzdGJveE11bHRpSXRlbSB9IGZyb20gXCIuLi8uLi9jb21wb25lbnQvbGlzdGJveC1tdWx0aVwiO1xyXG5pbXBvcnQgeyBFdmVudERldGFpbCwgTGlzdGJveE11bHRpLCBkZWZhdWx0UmVuZGVyTGlzdGJveE11bHRpLCBkZWZhdWx0UmVuZGVyTGlzdGJveE11bHRpSXRlbSB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XHJcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50O1xyXG59XHJcblxyXG5jb25zdCBEZW1vTGlzdEl0ZW0gPSBtZW1vKGZ1bmN0aW9uIERlbW9MaXN0SXRlbSh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XHJcbiAgICBjb25zdCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IGxhYmVsVGV4dCA9IGBMaXN0IGl0ZW0gIyR7aW5kZXh9JHtzZWxlY3RlZCA/IFwiIChzZWxlY3RlZClcIiA6IFwiXCJ9YFxyXG5cclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TGlzdGJveE11bHRpSXRlbVxyXG4gICAgICAgIGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gXHJcbiAgICAgICAgICAgIHNlbGVjdGVkPXtzZWxlY3RlZH1cclxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxyXG4gICAgICAgICAgICBkaXNhYmxlZD17ZmFsc2V9XHJcbiAgICAgICAgICAgIHRleHQ9e2xhYmVsVGV4dH1cclxuICAgICAgICAgICAgb25TZWxlY3RlZENoYW5nZT17ZSA9PiB7IHNldFNlbGVjdGVkKGVbRXZlbnREZXRhaWxdLnNlbGVjdGVkKSB9fVxyXG4gICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJMaXN0Ym94TXVsdGlJdGVtKHsgdGFnTGlzdEl0ZW06IFwibGlcIiwgbWFrZVByb3BzTGlzdEl0ZW06ICgpID0+ICh7IGNoaWxkcmVuOiBsYWJlbFRleHQgfSkgfSl9XHJcbiAgICAgICAgLz5cclxuICAgIClcclxufSlcclxuXHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9saXN0Ym94L1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBMaXN0Ym94IHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgY2hpbGRyZW4gYXJlIHRyZWF0ZWQgYXMgYSBjb21wb3NpdGUgY29tcG9uZW50IHdpdGggbGlzdCBuYXZpZ2F0aW9uOyBzZWUgPGNvZGU+QWlyYVNpbmdsZVNlbGVjdExpc3Q8L2NvZGU+IGZvciBtb3JlIGluZm9ybWF0aW9uPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgcGFyZW50IGNoZWNrYm94IHN3aXRjaGVzIGJldHdlZW4gMyBzdGF0ZXMsIHJlbWVtYmVyaW5nIHRoZSBsYXN0IHN0YXRlIHRoYXQgY2F1c2VkIGl0IHRvIGJlIFwibWl4ZWRcIi48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRoZSBwYXJlbnQgY2hlY2tib3ggcmVhY3RzIHRvIGVhY2ggY2hpbGQncyA8Y29kZT5jaGVja2VkPC9jb2RlPiBwcm9wIGFuZCB1cGRhdGVzIGl0cyBvd24gaW50ZXJuYWwgPGNvZGU+Y2hlY2tlZDwvY29kZT4gYXR0cmlidXRlIChiZSBhd2FyZSBvZiB0aGlzIGlmIHRoZXkncmUgYXN5bmNyb25vdXMsIGFzIHlvdSdsbCB3YW50IHRvIGVuc3VyZSB0aGV5IGFsbCByZXNvbHZlIG9uIHRoZSBzYW1lIHRpY2sgd2l0aCA8Y29kZT5Qcm9taXNlLmFsbDwvY29kZT4gdG8gbm90IGNsb2JiZXIgdGhlIHVzZXIncyBpbnB1dHMpLjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIGNoaWxkcmVuIGFyZSB0cmVhdGVkIGFzIGEgY29tcG9zaXRlIGNvbXBvbmVudCB3aXRoIGxpc3QgbmF2aWdhdGlvbjsgc2VlIDxjb2RlPkFpcmFTaW5nbGVTZWxlY3RMaXN0PC9jb2RlPiBmb3IgbW9yZSBpbmZvcm1hdGlvbjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+R3JvdXBpbmcgaXMgc3VwcG9ydGVkPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5Tb3J0aW5nL3Jlb3JkZXJpbmcgaXMgc3VwcG9ydGVkLCB0aG91Z2ggbm90IHByb3ZpZGVkIGJ5IGRlZmF1bHQsIGFzIGl0J3MgbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggZ3JvdXBpbmcuPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+SXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBwYXJlbnQgY2hlY2tib3ggcHJvdmlkZXMgc3VmZmljaWVudCBsYWJlbGxpbmcgZm9yIGFsbCB0aGUgY2hpbGRyZW4sIHdoaWNoIGhvdyB0aGUgZGVtbyBleGFtcGxlIGlkZW50aWZpZXMgdGhlc2UgZWxlbWVudHMuIElmIHlvdSBoYXZlIGEgc2VwYXJhdGUgbGFiZWwsIHlvdSB3aWxsIG5lZWQgdG8gd3JhcCB0aGUgY2hpbGRyZW4gaW4gYSA8Y29kZT5yb2xlPWdyb3VwPC9jb2RlPiB0aGF0IHJlZmVyZW5jZXMgdGhhdCBsYWJlbCBieSBvdmVycmlkaW5nIDxjb2RlPnJlbmRlcjwvY29kZT4uPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5TZWUgdGhlIGNhdmVhdCBhYm92ZSBmb3Igd2hlbiBlYWNoIGNoaWxkJ3MgPGNvZGU+b25JbnB1dDwvY29kZT4gdGFrZXMgYSB2YXJpYWJsZSBhbW91bnQgb2YgdGltZSB0byBhY3R1YWxseSB1cGRhdGUgdGhlIDxjb2RlPmNoZWNrZWQ8L2NvZGU+IHByb3AsIGFzIGl0IGNhbiBjbG9iYmVyIHRoZSB1c2VyJ3MgbGFzdCBpbnB1dCB3aGVuIGNsaWNraW5nIG9uIHRoZSBwYXJlbnQ8L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcclxuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xyXG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIGxpc3QgaXRlbXM8L2xhYmVsPlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPExpc3Rib3hNdWx0aSB0YWdMYWJlbD1cImxhYmVsXCIgdGFnTGlzdD1cInVsXCIgcmVuZGVyPXtkZWZhdWx0UmVuZGVyTGlzdGJveE11bHRpKHtcclxuICAgICAgICAgICAgICAgICAgICB0YWdMYWJlbDogXCJsYWJlbFwiLCB0YWdMaXN0OiBcInVsXCIsIG1ha2VQcm9wc0xhYmVsOiAoKSA9PiAoe30pLCBtYWtlUHJvcHNMaXN0OiAoKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogQXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxEZW1vTGlzdEl0ZW0gaW5kZXg9e2l9IGtleT17aX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSl9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59IiwiXHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJMaXN0Ym94U2luZ2xlSXRlbSwgTGlzdGJveFNpbmdsZUl0ZW0gfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50L2xpc3Rib3gtc2luZ2xlXCI7XHJcbmltcG9ydCB7IEV2ZW50RGV0YWlsLCBMaXN0Ym94U2luZ2xlLCBkZWZhdWx0UmVuZGVyTGlzdGJveFNpbmdsZSB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7IHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7IH1cclxuXHJcbmNvbnN0IERlbW9MaXN0SXRlbSA9IG1lbW8oZnVuY3Rpb24gRGVtb0xpc3RJdGVtKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pIHtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxMaXN0Ym94U2luZ2xlSXRlbTxIVE1MTElFbGVtZW50PiBpbmRleD17aW5kZXh9IGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gZGlzYWJsZWQ9e2ZhbHNlfSB0ZXh0PXtgTGlzdCBpdGVtICMke2luZGV4fWB9IHJlbmRlcj17ZGVmYXVsdFJlbmRlckxpc3Rib3hTaW5nbGVJdGVtKHsgdGFnTGlzdEl0ZW06IFwibGlcIiwgbWFrZVByb3BzTGlzdEl0ZW06ICh7IHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZCB9IH0pID0+ICh7IGNoaWxkcmVuOiBgTGlzdCBpdGVtICMke2luZGV4fSR7c2VsZWN0ZWQgPyBcIiAoc2VsZWN0ZWQpXCIgOiBcIlwifWAgfSkgfSl9IC8+XHJcbiAgICApXHJcbn0pXHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvbGlzdGJveC9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgTGlzdGJveCBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+SW4gdGVybXMgb2Yga2V5Ym9hcmQgbmF2aWdhdGlvbiBhbmQgdGFiYmluZyB0aHJvdWdoIGVsZW1lbnRzLCBhIExpc3Rib3ggaXMgY29uc2lkZXJlZCBhIDxzdHJvbmc+c2luZ2xlPC9zdHJvbmc+IHRhYiBzdG9wOyBpbiBvdGhlciB3b3Jkcywgbm8gbWF0dGVyIGhvdyBtYW55IGxpc3QgaXRlbXMgdGhlcmUgYXJlIGluIGEgTGlzdGJveCwgaXQgb25seSB0YWtlcyBvbmUgcHJlc3Mgb2YgdGhlIFRhYiBidXR0b24gdG8gZ28gdGhyb3VnaCBpdC5cclxuICAgICAgICAgICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5XaGVuIGEgTGlzdGJveCBpcyB0YWJiZWQgaW50bywgdGhlIG1vc3QgcmVjZW50bHkgc2VsZWN0ZWQgaXRlbSBpcyBnaXZlbiBmb2N1czwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5QcmVzc2luZyBUYWIgYWdhaW4gbmF2aWdhdGVzIG91dCBvZiB0aGUgbGlzdGJveDsgbm8gb3RoZXIgbGlzdCBpdGVtcyBhcmUgdGFiYmFibGUgb3RoZXIgdGhhbiB0aGUgb25lIGN1cnJlbnRseSBkZXNpZ25hdGVkLjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5QcmVzc2luZyB0aGUgYXJyb3cga2V5cyBuYXZpZ2F0ZXMgdGhyb3VnaCB0aGUgTGlzdGJveCBvbmUgaXRlbSBhdCBhIHRpbWU8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+UHJlc3NpbmcgdGhlIEhvbWUvRW5kIGtleXMgbW92ZSBmb2N1cyB0byB0aGUgZmlyc3QvbGFzdCBpdGVtcyByZXNwZWN0aXZlbHk8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+VHlwaW5nIGFueSBzZXF1ZW5jZSBvZiB0ZXh0IHN0YXJ0cyB0eXBlYWhlYWQgdGhhdCBuYXZpZ2F0ZXMgdG8gdGhlIG5leHQgaXRlbSB0aGF0IG1hdGNoZXMgd2hhdCdzIGJlaW5nIHR5cGVkPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPkZvY3VzICZhbXA7IHNlbGVjdGlvbiBtYW5hZ2VtZW50IGlzIGFzIG9wdGltaXplZCBhcyBwb3NzaWJsZTsgb25seSB0d28gY2hpbGRyZW4gcmUtcmVuZGVyIGF0IGEgdGltZSB3aGVuIGZvY3VzIG9yIHNlbGVjdGlvbiBjaGFuZ2VzPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlRoZXNlIGFwcGx5IGdlbmVyYWxseSB0byBhbGwgY29tcG9zaXRlIGNvbXBvbmVudHMgd2l0aCBhIHZhcmlhYmxlIG51bWJlciBvZiBjaGlsZHJlbiAoVGFiIExpc3RzLCBSYWRpbyBHcm91cHMsIE11bHRpLVNlbGVjdCBMaXN0Ym94ZXMgZXRjLik8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlJhdGhlciB0aGFuIGVhY2ggaW5kaXZpZHVhbCBsaXN0IGl0ZW0ga25vd2luZyB3aGV0aGVyIGl0IGlzIHNlbGVjdGVkIG9yIG5vdCAoYXMgd2l0aCBtdWx0aS1zZWxlY3QgbGlzdHMpLCBoZXJlIHRoZSBwYXJlbnQga25vd3MgdGhlIDxjb2RlPnNlbGVjdGVkSW5kZXg8L2NvZGU+IGFuZCBzaW1wbHkgbm90aWZpZXMgdGhlIChtYXggdHdvKSByZWxldmFudCBjaGlsZHJlbiBhbnkgdGltZSBpdCBjaGFuZ2VzLjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+R3JvdXBpbmcgaXMgc3VwcG9ydGVkPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5Tb3J0aW5nL3Jlb3JkZXJpbmcgaXMgc3VwcG9ydGVkLCB0aG91Z2ggbm90IHByb3ZpZGVkIGJ5IGRlZmF1bHQsIGFzIGl0J3MgbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggZ3JvdXBpbmcuPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+TGlzdGJveGVzIGRvIG5vdCBzdXBwb3J0IGludGVyYWN0aXZlIGNvbnRlbnQgd2l0aGluIHRoZW0gKGUuZy4gYSBkcm9wZG93biBtZW51KSwgYXMgQVJJQSBzcGVjaWZpZXMgdGhhdCB0aGlzIGlzIGEgZGlmZmVyZW50IHBhdHRlcm4uPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XHJcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcclxuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlPG51bGwgfCBudW1iZXI+KG51bGwpO1xyXG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIGxpc3QgaXRlbXM8L2xhYmVsPlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPExpc3Rib3hTaW5nbGVcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJMaXN0Ym94U2luZ2xlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTGFiZWw6IFwibGFiZWxcIiwgdGFnTGlzdDogXCJvbFwiLCBtYWtlUHJvcHNMYWJlbDogKCkgPT4gKHt9KSwgbWFrZVByb3BzTGlzdDogKCkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiA8PntBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb0xpc3RJdGVtIGluZGV4PXtpfSBrZXk9e2l9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSl9PC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZT1cImFjdGl2YXRpb25cIlxyXG4gICAgICAgICAgICAgICAgICAgIHRhZ0xhYmVsPVwibGFiZWxcIlxyXG4gICAgICAgICAgICAgICAgICAgIHRhZ0xpc3Q9XCJvbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRleD17c2VsZWN0ZWRJbmRleH1cclxuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdD17ZSA9PiBzZXRTZWxlY3RlZEluZGV4KGVbRXZlbnREZXRhaWxdLnNlbGVjdGVkSW5kZXgpfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufSIsIlxyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJNZW51LCBkZWZhdWx0UmVuZGVyTWVudUl0ZW0sIE1lbnUsIE1lbnVJdGVtIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC9tZW51XCI7XHJcblxyXG5mdW5jdGlvbiBEZW1vTGlzdEl0ZW0oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPE1lbnVJdGVtPEhUTUxMSUVsZW1lbnQ+IGluZGV4PXtpbmRleH0gdGV4dD17YExpc3QgaXRlbSAjJHtpbmRleH1gfSByZW5kZXI9e2RlZmF1bHRSZW5kZXJNZW51SXRlbSh7IHRhZ01lbnVJdGVtOiBcImxpXCIsIG1ha2VQcm9wc01lbnVJdGVtOiAoKSA9PiAoeyBjaGlsZHJlbjogYE1lbnUgaXRlbSAjJHtpbmRleH1gIH0pIH0pfSAvPlxyXG4gICAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHsgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9saXN0Ym94L1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBMaXN0Ym94IHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgY2hpbGRyZW4gYXJlIHRyZWF0ZWQgYXMgYSBjb21wb3NpdGUgY29tcG9uZW50IHdpdGggbGlzdCBuYXZpZ2F0aW9uOyBzZWUgPGNvZGU+QWlyYVNpbmdsZVNlbGVjdExpc3Q8L2NvZGU+IGZvciBtb3JlIGluZm9ybWF0aW9uPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIG9wZW5lZCwgdGhlIG1lbnUgd2lsbCBmb2N1cyB0aGUgZmlyc3QgZWxlbWVudCB3aXRoaW4gaXQuIFdoZW4gY2xvc2VkIChieSBwcmVzc2luZyBlc2NhcGUsIHByZXNzaW5nIHRoZSBidXR0b24gYWdhaW4sIG9yIHRhYmJpbmcgb3V0IG9mIHRoZSBtZW51KSwgdGhlIGJ1dHRvbiB0aGF0IG9wZW5lZCBpdCB3aWxsIGhhdmUgZm9jdXMgcmVzdG9yZWQgdG8gaXQuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIHRoZSBtZW51IGlzIGNsb3NlZCBiZWNhdXNlIGFub3RoZXIgZWxlbWVudCBvbiB0aGUgcGFnZSB3YXMgZm9jdXNlZCBpbnN0ZWFkLCBmb2N1cyB3aWxsIG5vdCBiZSBtb2RpZmllZC48L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5UT0RPPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XHJcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcclxuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoNSk7XHJcbiAgICBjb25zdCBbb3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPEJsdXJiIC8+XHJcbiAgICAgICAgICAgIDxDb2RlIC8+XHJcbiAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cIm51bWJlclwiIG1pbj17MH0gdmFsdWU9e2NvdW50fSBvbklucHV0PXtlID0+IHNldENvdW50KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz4gIyBvZiBtZW51IGl0ZW1zPC9sYWJlbD5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxNZW51PEhUTUxEaXZFbGVtZW50LCBIVE1MVUxpc3RFbGVtZW50LCBIVE1MRGl2RWxlbWVudCwgSFRNTExJRWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fVxyXG4gICAgICAgICAgICAgICAgICAgIG9uT3Blbj17KCkgPT4gc2V0T3Blbih0cnVlKX1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRPcGVuKGZhbHNlKX1cclxuICAgICAgICAgICAgICAgICAgICBvcGVuPXtvcGVufVxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW5EaXJlY3Rpb249XCJkb3duXCJcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJNZW51KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnQnV0dG9uOiBcImJ1dHRvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdNZW51OiBcInVsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ1NlbnRpbmVsOiBcImRpdlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdTdXJmYWNlOiBcImRpdlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxJZDogXCJwb3J0YWxcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzQnV0dG9uOiAoKSA9PiAoeyBjaGlsZHJlbjogXCJPcGVuIG1lbnVcIiArIChvcGVuPyBcIiAob3BlbilcIiA6IFwiIChjbG9zZWQpXCIpIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNNZW51OiAoKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IDw+e0FycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxkaXY+PERlbW9MaXN0SXRlbSBpbmRleD17aX0ga2V5PXtpfSAvPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpfTwvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzU3VyZmFjZTogKCkgPT4gKHsgc3R5bGU6IHsgZGlzcGxheTogIW9wZW4/IFwibm9uZVwiIDogdW5kZWZpbmVkIH0gfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc1NlbnRpbmVsOiAoKSA9PiAoe30pLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufSIsIlxyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyUmFkaW8sIFJhZGlvLCBSYWRpb0dyb3VwIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC9yYWRpby1ncm91cFwiO1xyXG5pbXBvcnQgeyBFdmVudERldGFpbCwgZGVmYXVsdFJlbmRlclJhZGlvR3JvdXAgfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcclxuXHJcbmZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xyXG4gICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcclxufVxyXG5cclxuY29uc3QgRGVtb1JhZGlvQnV0dG9uID0gbWVtbyhmdW5jdGlvbiBEZW1vUmFkaW9CdXR0b24oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xyXG5cclxuICAgIGNvbnN0IHZhbHVlID0gYFJhZGlvIGJ1dHRvbiAjJHtpbmRleH1gO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFJhZGlvPG51bWJlciwgSFRNTElucHV0RWxlbWVudCwgSFRNTExhYmVsRWxlbWVudD5cclxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxyXG4gICAgICAgICAgICBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9XHJcbiAgICAgICAgICAgIGRpc2FibGVkPXtmYWxzZX1cclxuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbj1cInNlcGFyYXRlXCJcclxuICAgICAgICAgICAgdGV4dD17dmFsdWV9XHJcbiAgICAgICAgICAgIHZhbHVlPXtpbmRleH1cclxuICAgICAgICAgICAgdGFnSW5wdXQ9XCJpbnB1dFwiXHJcbiAgICAgICAgICAgIHRhZ0xhYmVsPVwibGFiZWxcIlxyXG4gICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJSYWRpbyh7XHJcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uOiBcInNlcGFyYXRlXCIsXHJcbiAgICAgICAgICAgICAgICB0YWdJbnB1dDogXCJpbnB1dFwiLFxyXG4gICAgICAgICAgICAgICAgdGFnTGFiZWw6IFwibGFiZWxcIixcclxuICAgICAgICAgICAgICAgIG1ha2VJbnB1dFByb3BzOiAoKSA9PiAoeyBuYW1lOiBcInJhZGlvLWRlbW9cIiB9KSxcclxuICAgICAgICAgICAgICAgIG1ha2VMYWJlbFByb3BzOiAoKSA9PiAoeyBjaGlsZHJlbjogdmFsdWUgfSlcclxuICAgICAgICAgICAgfSl9IC8+XHJcbiAgICApXHJcbn0pXHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvcmFkaW9idXR0b24vXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIFJhZGlvIEJ1dHRvbiBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIGNoaWxkcmVuIGFyZSB0cmVhdGVkIGFzIGEgY29tcG9zaXRlIGNvbXBvbmVudCB3aXRoIGxpc3QgbmF2aWdhdGlvbjsgc2VlIDxjb2RlPkFpcmFTaW5nbGVTZWxlY3RMaXN0PC9jb2RlPiBmb3IgbW9yZSBpbmZvcm1hdGlvbjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIGlucHV0ICZhbXA7IGxhYmVsIHN1cHBvcnQgdGhlIHNhbWUgdGV4dC1zZWxlY3Rpb24gYWZmb3JkYW5jZXMgYXMgQ2hlY2tib3hlcyAobGFiZWxzIGNhbiBiZSBzZWxlY3RlZCwgYnV0IGRvdWJsZS1jbGlja2luZyBkb2Vzbid0IHNlbGVjdCB0aGUgdGV4dCBhbmQgc2VsZWN0aW5nIHRleHQgZG9lc24ndCBjb3VudCBhcyBhbiBpbnB1dCk8L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlNlbGVjdGlvbiBzdGF0ZSBpcyBoYW5kbGVkIGJ5IHRoZSBwYXJlbnQ7IGluc3RlYWQgb2Ygc3BlY2lmeWluZyB3aGV0aGVyIGFueSBnaXZlbiByYWRpbyBidXR0b24gaXMgY2hlY2tlZCBvciBub3QsIHRoZSBwYXJlbnQgbm90aWZpZXMgZWFjaCBjaGlsZCBvZiB0aGUgbmVjZXNzYXJ5IGNoYW5nZXMuPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+SWYgeW91ciBjaGVja2JveCBkb2VzIG5vdCBoYXZlIGEgdmlzaWJsZSBsYWJlbCAoYWNoaWV2YWJsZSBieSBieSBvdmVycmlkaW5nIHRoZSA8Y29kZT5yZW5kZXI8L2NvZGU+IHByb3AgYW5kIHNldHRpbmcgPGNvZGU+bGFiZWxQb3NpdGlvbjwvY29kZT4gdG8gYmUgXCJzZXBhcmF0ZVwiKSwgeW91IG11c3QgcGFzcyA8Y29kZT5hcmlhLWxhYmVsPC9jb2RlPiBhcyBhIHByb3AgdG8gdGhlIGNoZWNrYm94IG1hbnVhbGx5LiBOb3QgcHJvdmlkaW5nIG9uZSB3aWxsIHByaW50IGFuIGVycm9yIHRvIHRoZSBjb25zb2xlLCBidXQgaXQgaXQgbm90IHJlcXVpcmVkIGJ5IHRoZSB0eXBlIHN5c3RlbS48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRoZSBhYm92ZSBhbHNvIGFwcGxpZXMgdG8gdGhlIHJhZGlvIGdyb3VwIGFzIGEgd2hvbGU7IEFSSUEgcmVxdWlyZXMgdGhhdCBhbGwgUmFkaW8gQnV0dG9ucyBiZSBjb250YWluZWQgd2l0aGluIGFuIGVsZW1lbnQgd2l0aCBhIHNwZWNpZmljIHJvbGUgd2hpY2ggaXMgbGFiZWxsZWQgZWl0aGVyIGJ5IGFuIGVsZW1lbnQgKGhhbmRsZWQgZm9yIHlvdSkgb3IgPGNvZGU+YXJpYS1sYWJlbDwvY29kZT4gKHNwZWNpZmllZCBieSB5b3UgbWFudWFsbHkgb24gdGhlIGlucHV0KS48L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcclxuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xyXG4gICAgY29uc3QgW3NlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXhdID0gdXNlU3RhdGU8bnVsbCB8IG51bWJlcj4obnVsbCk7XHJcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDUpO1xyXG5cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxCbHVyYiAvPlxyXG4gICAgICAgICAgICA8Q29kZSAvPlxyXG4gICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49ezB9IHZhbHVlPXtjb3VudH0gb25JbnB1dD17ZSA9PiBzZXRDb3VudChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+ICMgb2YgcmFkaW8gYnV0dG9uczwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8UmFkaW9Hcm91cDxudW1iZXIsIEhUTUxEaXZFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50LCBIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50PlxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU9XCJyYWRpby1kZW1vXCJcclxuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGVkVmFsdWVDaGFuZ2U9e2UgPT4gc2V0U2VsZWN0ZWRJbmRleChlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZFZhbHVlID8/IDApfVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFsdWU9e3NlbGVjdGVkSW5kZXh9XHJcbiAgICAgICAgICAgICAgICAgICAgdGFnR3JvdXBMYWJlbD1cImxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICB0YWdHcm91cD1cImRpdlwiXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyPXtkZWZhdWx0UmVuZGVyUmFkaW9Hcm91cCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0dyb3VwOiBcImRpdlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdMYWJlbDogXCJsYWJlbFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNHcm91cDogKCkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9SYWRpb0J1dHRvbiBpbmRleD17aX0ga2V5PXtpfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0xhYmVsOiAoaW5mbykgPT4gKHsgY2hpbGRyZW46IFwiUmFkaW8gZ3JvdXAgZXhhbXBsZSBcIiArIFwiKFwiICsgaW5mby5yYWRpb0dyb3VwLnNlbGVjdGVkSW5kZXg/LnRvU3RyaW5nKCkgKyBcIilcIiB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufSIsIlxyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IEV2ZW50RGV0YWlsLCBMaXN0Ym94U2luZ2xlIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XHJcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJTbGlkZXJUaHVtYiwgU2xpZGVyVGh1bWIsIFNsaWRlciB9IGZyb20gXCIuLi8uLi9jb21wb25lbnQvc2xpZGVyXCJcclxuXHJcbmZ1bmN0aW9uIERlbW9TbGlkZXJUaHVtYih7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XHJcbiAgICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHVzZVN0YXRlKDApO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFNsaWRlclRodW1iPEhUTUxJbnB1dEVsZW1lbnQ+XHJcbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cclxuICAgICAgICAgICAgdGFnPVwiaW5wdXRcIlxyXG4gICAgICAgICAgICBsYWJlbD17YFNsaWRlciB0aHVtYiAjJHtpbmRleH1gfVxyXG4gICAgICAgICAgICB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgIG9uVmFsdWVDaGFuZ2U9e2UgPT4gc2V0VmFsdWUoZVtFdmVudERldGFpbF0udmFsdWUpfVxyXG4gICAgICAgICAgICBtaW49ezB9XHJcbiAgICAgICAgICAgIG1heD17MTB9XHJcbiAgICAgICAgICAgIHJlbmRlcj17ZGVmYXVsdFJlbmRlclNsaWRlclRodW1iKHsgdGFnVGh1bWI6IFwiaW5wdXRcIiwgbWFrZVByb3BzVGh1bWI6ICgpID0+ICh7fSkgfSl9IC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldERvY3VtZW50KCkgeyByZXR1cm4gd2luZG93LmRvY3VtZW50OyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2xpc3Rib3gvXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIExpc3Rib3ggcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRoZSBjaGlsZHJlbiBhcmUgdHJlYXRlZCBhcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgd2l0aCBsaXN0IG5hdmlnYXRpb247IHNlZSA8Y29kZT5BaXJhU2luZ2xlU2VsZWN0TGlzdDwvY29kZT4gZm9yIG1vcmUgaW5mb3JtYXRpb248L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPldoZW4gb3BlbmVkLCB0aGUgbWVudSB3aWxsIGZvY3VzIHRoZSBmaXJzdCBlbGVtZW50IHdpdGhpbiBpdC4gV2hlbiBjbG9zZWQgKGJ5IHByZXNzaW5nIGVzY2FwZSwgcHJlc3NpbmcgdGhlIGJ1dHRvbiBhZ2Fpbiwgb3IgdGFiYmluZyBvdXQgb2YgdGhlIG1lbnUpLCB0aGUgYnV0dG9uIHRoYXQgb3BlbmVkIGl0IHdpbGwgaGF2ZSBmb2N1cyByZXN0b3JlZCB0byBpdC48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPldoZW4gdGhlIG1lbnUgaXMgY2xvc2VkIGJlY2F1c2UgYW5vdGhlciBlbGVtZW50IG9uIHRoZSBwYWdlIHdhcyBmb2N1c2VkIGluc3RlYWQsIGZvY3VzIHdpbGwgbm90IGJlIG1vZGlmaWVkLjwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRPRE88L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcclxuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xyXG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcclxuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIHNsaWRlciB0aHVtYnM8L2xhYmVsPlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPFNsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgIG1pbj17MH1cclxuICAgICAgICAgICAgICAgICAgICBtYXg9ezEwfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuPXs8PntBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxkaXY+PERlbW9TbGlkZXJUaHVtYiBpbmRleD17aX0ga2V5PXtpfSAvPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSkoKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgPC8+fSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufSIsIlxyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyRGlhbG9nLCBEaWFsb2cgfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50L2RpYWxvZ1wiO1xyXG5pbXBvcnQgeyBCdXR0b24sIGRlZmF1bHRSZW5kZXJCdXR0b24gfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7IHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvZGlhbG9nbW9kYWwvXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIE1vZGFsIERpYWxvZyBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+RGlhbG9ncyBibG9jayBhbGwgb3RoZXIgZWxlbWVudHMgb24gdGhlIHBhZ2UgZnJvbSByZWNlaXZpbmcgZm9jdXMvaW50ZXJhY3Rpb24gYW5kIGJlaW5nIHBlcmNlaXZhYmxlIHRvIHNjcmVlbiByZWFkZXJzLjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+RGlhbG9ncyBjYW4gYmUgZGlzbWlzc2VkIGJ5IHByZXNzaW5nIEVzY2FwZSBvciBjbGlja2luZyB0aGUgZWxlbWVudCBkZXNpZ25hdGVkIGFzIHRoZSBiYWNrZHJvcCwgYm90aCBvZiB3aGljaCBjYW4gYmUgY2FuY2VsbGVkL2lnbm9yZWQgaWYgeW91IG5lZWQ8L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPldoZW4gb3BlbmVkLCB0aGUgZGlhbG9nIHdpbGwgZm9jdXMgaXRzIHRpdGxlIG9yIGJvZHkgY29udGVudCBhcyBhcHByb3ByaWF0ZSwgaG93ZXZlciByZWFkIGJlbG93IHVuZGVyIFRoaW5ncyBOb3QgSGFuZGxlZCBmb3IgY2F2ZWF0cy48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPldoZW4gY2xvc2VkIGZvciBhbnkgcmVhc29uLCB0aGUgZWxlbWVudCB0aGF0IHdhcyByZXNwb25zaWJsZSBmb3Igb3BlbmluZyB0aGUgZGlhbG9nIHdpbGwgYmUgZm9jdXNlZC48L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5CeSBkZWZhdWx0LCB3aGVuIG9wZW5lZCwgYSBkaWFsb2cgd2lsbCBmb2N1cyBpdHMgYm9keSBjb250ZW50IG9yIHRpdGxlIGNvbnRlbnQgZGVwZW5kaW5nIG9uIDxjb2RlPmJvZHlJc09ubHlTZW1hbnRpYzwvY29kZT4sIHdoaWNoIGluZGljYXRlcyB0aGF0IHRoZSBkaWFsb2cncyBib2R5IGNvbnRhaW5zIG5vIGludGVyYWN0aXZlIGVsZW1lbnRzLiBUaGlzIG1heSBub3QgYmUgc3VpdGFibGUgZm9yIGFsbCBzaXR1YXRpb25zLjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+SXQgaXMgPGVtPmhpZ2h0bHk8L2VtPiByZWNvbW1lbmRlZCB0byBvdmVycmlkZSA8Y29kZT5mb2N1c1NlbGY8L2NvZGU+IGZvciBhbGwgZGlhbG9ncyB5b3UgY3JlYXRlLCBhbmQgaGF2ZSBpdCBmb2N1cyB3aGF0ZXZlciBlbGVtZW50IG1ha2VzIHRoZSBtb3N0IHNlbnNlIGZvciB5b3VyIHBhcnRpY3VsYXIgZGlhbG9nLlxyXG4gICAgICAgICAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPkRpYWxvZ3MgdGhhdCBhY3QgbGlrZSBhIGZvcm0gc2hvdWxkIGZvY3VzIHRoZSBmaXJzdCBpbnRlcmFjdGl2ZSBlbGVtZW50PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPkRpYWxvZ3MgdGhhdCBwZXJmb3JtIGRlc3RydWN0aXZlIGFjdGlvbnMgc2hvdWxkIGZvY3VzIHRoZSBcIkNhbmNlbFwiIGJ1dHRvbjwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5JbiBzb21lIGNhc2VzLCBpdCdzIGJlc3QgdG8gZm9jdXMgdGhlIGZpcnN0IHBhcmFncmFwaCBvZiB0aGUgYm9keS48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgICAgICAgICAgSW4gYWxsIGNhc2VzLCBjb25zaWRlciB0aGF0IHRoZSBmaXJzdCBmb2N1c2VkIGVsZW1lbnQgd2lsbCBib3RoIGJlIGhvdyBrZXlib2FyZCB1c2VycyBpbnRlcmFjdCB3aXRoIHRoZSBkaWFsb2csIGJ1dCBhbHNvIHRoZSBmaXJzdCB0aGluZyBhIHNjcmVlbiByZWFkZXIgd2lsbCByZWFkIGFsb3VkLlxyXG4gICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XHJcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcclxuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCByID0gdXNlQ2FsbGJhY2soKC4uLmFyZ3M6IGFueVtdKSA9PiB7IGNvbnNvbGUubG9nKC4uLmFyZ3MpOyB9LCBbXSk7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPEJsdXJiIC8+XHJcbiAgICAgICAgICAgIDxDb2RlIC8+XHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8QnV0dG9uIHRhZ0J1dHRvbj1cImJ1dHRvblwiIGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gb25QcmVzcz17KCkgPT4gc2V0T3Blbih0cnVlKX0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyQnV0dG9uKFwiYnV0dG9uXCIsICgpID0+ICh7IGNoaWxkcmVuOiBcIk9wZW4gZGlhbG9nIFwiICsgKG9wZW4gPyBcIihvcGVuKVwiIDogXCIoY2xvc2VkKVwiKSB9KSl9IC8+XHJcbiAgICAgICAgICAgICAgICA8RGlhbG9nXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fVxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHNldE9wZW4oZmFsc2UpfVxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW49e29wZW59XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUlzT25seVNlbWFudGljPXt0cnVlfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcj17ZGVmYXVsdFJlbmRlckRpYWxvZyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbElkOiBcInBvcnRhbFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNCYWNrZHJvcDogKCkgPT4gKHsgXCJkYXRhLXR5cGVcIjogXCJiYWNrZHJvcFwiIH0gYXMge30pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lcjogKCkgPT4gKHsgXCJkYXRhLXR5cGVcIjogXCJmb2N1c1wiIH0gYXMge30pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNCb2R5OiAoKSA9PiAoeyBjaGlsZHJlbjogXCJEaWFsb2cgYm9keVwiICwgXCJkYXRhLXR5cGVcIjogXCJib2R5XCJ9IGFzIHt9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzRGlhbG9nOiAoKSA9PiAoeyBzdHlsZTogeyBkaXNwbGF5OiAhb3BlbiA/IFwibm9uZVwiIDogdW5kZWZpbmVkIH0sIFwiZGF0YS10eXBlXCI6IFwiZGlhbG9nXCIgfSBhcyB7fSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc1RpdGxlOiAoKSA9PiAoeyBjaGlsZHJlbjogXCJEaWFsb2cgdGl0bGVcIiwgXCJkYXRhLXR5cGVcIjogXCJ0aXRsZVwiIH0gYXMge30pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdCYWNrZHJvcDogXCJkaXZcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnQm9keTogXCJkaXZcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnRGlhbG9nOiBcImRpdlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdUaXRsZTogXCJkaXZcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnRm9jdXNDb250YWluZXI6IFwiZGl2XCJcclxuICAgICAgICAgICAgICAgICAgICB9KX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcbiIsIlxyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyVGFiLCBkZWZhdWx0UmVuZGVyVGFiUGFuZWwsIGRlZmF1bHRSZW5kZXJUYWJzLCBUYWJzIH0gZnJvbSBcIi4uLy4uL1wiO1xyXG5pbXBvcnQgeyBUYWIsIFRhYlBhbmVsIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC90YWJzXCI7XHJcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7IHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvdGFicGFuZWwvXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIFRhYiBhbmQgVGFiIFBhbmVsIHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgdGFicyBhcmUgdHJlYXRlZCBhcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgd2l0aCBsaXN0IG5hdmlnYXRpb247IHNlZSA8Y29kZT5BaXJhU2luZ2xlU2VsZWN0TGlzdDwvY29kZT4gZm9yIG1vcmUgaW5mb3JtYXRpb248L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5UT0RPPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XHJcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcclxuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoNSk7XHJcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIHRhYnM8L2xhYmVsPlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPFRhYnNcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4PXtzZWxlY3RlZEluZGV4fVxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU9XCJmb2N1c1wiXHJcbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3RlZEluZGV4Q2hhbmdlPXtlID0+IHNldFNlbGVjdGVkSW5kZXgoZVtFdmVudERldGFpbF0uc2VsZWN0ZWRJbmRleCl9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcj17ZGVmYXVsdFJlbmRlclRhYnMoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYW5lbHM6IEFycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb1RhYlBhbmVsIGk9e2l9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdMYWJlbDogXCJsYWJlbFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdMaXN0OiBcInVsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0xhYmVsOiAoKSA9PiAoeyBjaGlsZHJlbjogXCJUYWJzIGV4YW1wbGVcIiB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzTGlzdDogKCkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiA8PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxEZW1vVGFiIGk9e2l9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIH0pfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuY29uc3QgRGVtb1RhYiA9IG1lbW8oZnVuY3Rpb24gRGVtb1RhYih7IGkgfTogeyBpOiBudW1iZXIgfSkge1xyXG4gICAgY29uc3QgbGFiZWwgPSBgVGFiICMke2l9YDtcclxuICAgIHJldHVybiA8VGFiIGtleT17aX0gaW5kZXg9e2l9IGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyVGFiKHsgdGFnVGFiOiBcImxpXCIsIG1ha2VQcm9wc1RhYjogKCkgPT4gKHsgY2hpbGRyZW46IGxhYmVsIH0pIH0pfSB0ZXh0PXtsYWJlbH0gLz5cclxufSlcclxuXHJcbmNvbnN0IERlbW9UYWJQYW5lbCA9IG1lbW8oZnVuY3Rpb24gRGVtb1RhYlBhbmVsKHsgaSB9OiB7IGk6IG51bWJlciB9KSB7XHJcbiAgICBjb25zdCBsYWJlbCA9IGBUYWIgcGFuZWwgIyR7aX1gO1xyXG4gICAgcmV0dXJuIDxUYWJQYW5lbCBpbmRleD17aX0ga2V5PXtpfSByZW5kZXI9e2RlZmF1bHRSZW5kZXJUYWJQYW5lbCh7IHRhZ1RhYlBhbmVsOiBcImRpdlwiLCBtYWtlUHJvcHNUYWJQYW5lbDogKHsgdGFiUGFuZWw6IHsgdmlzaWJsZSB9IH0pID0+ICh7IGhpZGRlbjogIXZpc2libGUsIGNoaWxkcmVuOiBsYWJlbCB9KSB9KX0gLz5cclxufSlcclxuXHJcbiIsIlxyXG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyVG9vbHRpcCwgVG9vbHRpcCB9IGZyb20gXCIuLi8uLi9cIjtcclxuXHJcblxyXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHsgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy90b29sdGlwL1wiPlRvb2x0aXBzIGhhdmUgeWV0IHRvIGJlIHdlbGwgZGVmaW5lZCBpbiBtYW55IGFyZWFzPC9hPiwgYnV0IHRoaXMgaW1wbGVtZW50YXRpb24gYWltcyB0byBzdXBwb3J0IGNvbW1vbiB1c2UgY2FzZXM6PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+SG92ZXJpbmcgb3IgZm9jdXNpbmcgdGhlIHRyaWdnZXIgZWxlbWVudCBzaG93cyB0aGUgdG9vbHRpcDwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIHRvb2x0aXAgc3RheXMgc2hvd24gd2hlbiBpdCBpdHNlbGYgaXMgaG92ZXJlZC9mb2N1c2VkIGFzIHdlbGwsIHNvIHRoYXQgdGhlIHRleHQgaW5zaWRlIGNhbiBiZSBzZWxlY3RlZDwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+TW92aW5nIHRoZSBtb3VzZSBiZXR3ZWVuIHRoZSB0cmlnZ2VyIGFuZCB0aGUgdG9vbHRpcCBoYXMgc29tZSB0b2xlcmFuY2UgYXNzb2NpYXRlZCB3aXRoIGltbWVkaWF0ZWx5IGhpZGluZyB0aGUgdG9vbHRpcC48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPkhvdmVyaW5nLCBmb2N1c2luZywgYW5kIHJlLWhvdmVyaW5nIGNhbiBlYWNoIGhhdmUgYSBjdXN0b20gZGVsYXkgYXNzb2NpYXRlZCB3aXRoIGl0PC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+WW91IG11c3QgZW5zdXJlIHRoYXQgZWl0aGVyIHRoZSB0b29sdGlwIGNvbnRhaW5zIGEgZm9jdXNhYmxlIGVsZW1lbnQgKGEgYnV0dG9uLCBsaW5rLCA8Y29kZT4mbHQ7ZGl2IHRhYkluZGV4PVwiLTFcIiAvJmd0OzwvY29kZT4sIGV0Yy4pPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5Mb25nIHByZXNzZXMgb24gbW9iaWxlIGRldmljZXMgYXJlIG5vdCB5ZXQgaGFuZGxlZCAoZS5nLiBhIGxvbmcgcHJlc3Mgb24gYSBidXR0b24gdHJpZ2dlcnMgYSB0b29sdGlwIGJ1dCBkb2VzIG5vdCBhY3RpdmF0ZSB0aGUgYnV0dG9uKTwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xyXG4gICAgcmV0dXJuICg8Y29kZT57YGB9PC9jb2RlPilcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPEJsdXJiIC8+XHJcbiAgICAgICAgICAgIDxDb2RlIC8+XHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICBUaGUgZm9sbG93aW5nIHRleHQgdHJpZ2dlcnMgYSB0b29sdGlwOiA8VG9vbHRpcCBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9IHJlbmRlcj17ZGVmYXVsdFJlbmRlclRvb2x0aXAoe1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBwb3J0YWxJZDogXCJwb3J0YWxcIixcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbWFrZVRvb2x0aXBQcm9wczogKHsgaXNPcGVuIH0pID0+ICh7IGNoaWxkcmVuOiBcIlRoaXMgdGV4dCBkZXNjcmliZXMgdGhlIHRyaWdnZXJpbmcgdGV4dCBpbiBtb3JlIGRldGFpbC5cIiwgc3R5bGU6IHsgb3BhY2l0eTogK2lzT3BlbiB9IH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ha2VUcmlnZ2VyUHJvcHM6ICgpID0+ICh7IGNoaWxkcmVuOiBcIlRvb2x0aXAtdHJpZ2dlcmluZyB0ZXh0IHRoYXQgaXMgaG92ZXJhYmxlIGFuZCBmb2N1c2FibGU6XCIsIHRhYkluZGV4OiAwIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhZ1Rvb2x0aXA6IFwiZGl2XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFnVHJpZ2dlcjogXCJzcGFuXCJcclxuICAgICAgICAgICAgICAgIH0pfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuXHJcbiIsIlxyXG5pbXBvcnQgeyBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgVG9hc3QsIFRvYXN0cyB9IGZyb20gXCIuLi8uLi9cIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvYWxlcnQvXCI+VG9hc3RzIChha2Egc25hY2tiYXJzKSBhcmUgaW1wbGVtZW50ZWQgdXNpbmcgdGhlIEFsZXJ0IHBhdHRlcm4uPC9hPjwvcD5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpPlB1c2hpbmcgYSB0b2FzdHMgY2F1c2VzIGl0cyBjb250ZW50cyB0byBiZSBzaG93biB2aXNpYmx5IChhbmQgYXVkaWJseSB3aXRoIGEgc2NyZWVuIHJlYWRlcik8L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPk9ubHkgbmV3IHRvYXN0cyBhcmUgYW5ub3VuY2VkPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5Ub2FzdHMgYXJlIHNob3duIGFzIHNvb24gYXMgdGhleSBhcmUgcHVzaGVkLCBidXQgeW91IGNhbiBjb250cm9sIHRoZSBtYXhpbXVtIG51bWJlciBzaG93biBhdCBvbmNlIHdpdGg8L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRvYXN0cyBjYW4gYmUgZGlzbWlzc2VkIGluIGFueSBvcmRlcjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+VG9hc3RzIGNhbiBiZSBzZXQgdG8gYXV0by1kaXNtaXNzLjwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpPkF1dG8tZGlzbWlzcyBiZWhhdmlvciBpcyB2ZXJ5IHNpdHVhdGlvbmFsLiBBbiBhdXRvLWRpc21pc3NlZCB0b2FzdCBzaG91bGQgb25seSByZWZlciB0byBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSB2aWV3ZWQgZWxzZXdoZXJlOyBcIlggZmlsZXMgZGVsZXRlZFwiIGNhbiBiZSBkb3VibGUtY2hlY2tlZCBpbiB0aGUgUmVjeWNsZSBCaW4sIFwiWCBoYXMgbG9nZ2VkIGluXCIgd2hpY2ggeW91IGNhbiBhbG9uZyB3aXRoIGV2ZXJ5b25lIGVsc2UgaW4gYSB0YWIgc29tZXdoZXJlLCBldGMuIFRoaXMgb2J2aW91c2x5IGNhbm5vdCBiZSBjaGVja2VkIHByb2dyYW1tYXRpY2FsbHkuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5UT0RPOiBGb2N1cyBtYW5hZ2VtZW50IHJlbGF0ZWQgdG8gdG9hc3RzIHRoYXQgaGF2ZSBpbnRlcmFjdGl2ZSBjb250ZW50PC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5UT0RPOiBUb2FzdHMgYXJlIHN0aWxsIGFubm91bmNlZCBldmVuIHdoZW4gdGhlIGN1cnJlbnQgYnJvd3NlciB0YWIgaXMgaGlkZGVuIGluc3RlYWQgb2Ygc2F2aW5nIHRoZW0gZm9yIHdoZW4gdGhlIHVzZXIgcmV0dXJuczwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+VE9ETzogVG9hc3RzIHN0aWxsIGF1dG8tZGlzbWlzcyB3aGVuIHRoZXkgaGF2ZSBmb2N1cy9hcmUgYmVpbmcgaW50ZXJhY3RlZCB3aXRoPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XHJcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcclxuXHJcbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSB1c2VSZWYoMCk7XHJcbiAgICBjb25zdCBbdG9hc3RzLCBzZXRUb2FzdHNdID0gdXNlU3RhdGU8Vk5vZGVbXT4oW10pO1xyXG5cclxuICAgIGNvbnN0IHB1c2hUb2FzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGN1cnJlbnRJbmRleC5jdXJyZW50O1xyXG4gICAgICAgIGN1cnJlbnRJbmRleC5jdXJyZW50ICs9IDE7XHJcblxyXG4gICAgICAgIHNldFRvYXN0cyh0ID0+IFsuLi50LCA8VG9hc3QgaW5kZXg9e2luZGV4fSBrZXk9e2luZGV4fSByZW5kZXI9eyh7IHRvYXN0OiB7IGRpc21pc3MsIHNob3dpbmcsIGRpc21pc3NlZCwgbnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMgfSB9KSA9PiAoXHJcbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3Nob3dpbmcgPyB7fSA6IHsgb3BhY2l0eTogMC41IH19PlRoaXMgdGhlIHRvYXN0IHdpdGggYW4gaW5kZXggb2Yge2luZGV4fS4gKCN7bnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXN9IGluIHRoZSBxdWV1ZSB0byBiZSBzaG93bikuIDxidXR0b24gZGlzYWJsZWQ9e2Rpc21pc3NlZH0gb25DbGljaz17ZGlzbWlzc30+Q2xpY2sgdG8gZGlzbWlzczwvYnV0dG9uPjwvZGl2PlxyXG4gICAgICAgICl9IHRpbWVvdXQ9e251bGx9IC8+XSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtwdXNoVG9hc3R9PlB1c2ggYSB0b2FzdDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPFRvYXN0czxIVE1MRGl2RWxlbWVudD4gdmlzaWJsZUNvdW50PXszfSByZW5kZXI9eyhpbmZvLCBwcm9wcykgPT4geyByZXR1cm4gPGRpdiB7Li4ucHJvcHN9Pnt0b2FzdHN9PC9kaXY+IH19IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5cclxuIiwiXHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgbWVtbywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgVGFibGUsIFRhYmxlQm9keSwgVGFibGVCb2R5UHJvcHMsIFRhYmxlQ2VsbCwgVGFibGVDZWxsUHJvcHMsIFRhYmxlRm9vdCwgVGFibGVGb290UHJvcHMsIFRhYmxlSGVhZCwgVGFibGVIZWFkUHJvcHMsIFRhYmxlUHJvcHMsIFRhYmxlUm93LCBUYWJsZVJvd1Byb3BzLCBkZWZhdWx0UmVuZGVyVGFibGUsIGRlZmF1bHRSZW5kZXJUYWJsZUJvZHksIGRlZmF1bHRSZW5kZXJUYWJsZUNlbGwsIGRlZmF1bHRSZW5kZXJUYWJsZUZvb3QsIGRlZmF1bHRSZW5kZXJUYWJsZUhlYWQsIGRlZmF1bHRSZW5kZXJUYWJsZVJvdyB9IGZyb20gXCIuLi8uLi9jb21wb25lbnQvdGFibGVcIjtcclxuaW1wb3J0IHsgRXZlbnREZXRhaWwsIExpc3Rib3hTaW5nbGUsIGRlZmF1bHRSZW5kZXJMaXN0Ym94U2luZ2xlIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiXHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcblxyXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHsgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDsgfVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPHA+VGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBhbiBpbnRlcmFjdGl2ZSBkYXRhIHRhYmxlIHRoYXQgY29tcGxpZXMgd2l0aCA8YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy90YWJsZS9cIj50aGUgQVJJQSBndWlkZWxpbmVzIGZvciBUYWJsZSBwYXR0ZXJuczwvYT4uPC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+SW4gdGVybXMgb2Yga2V5Ym9hcmQgbmF2aWdhdGlvbiBhbmQgdGFiYmluZyB0aHJvdWdoIGVsZW1lbnRzLCBhIFRhYmxlIGlzIGNvbnNpZGVyZWQgYSA8c3Ryb25nPnNpbmdsZTwvc3Ryb25nPiB0YWIgc3RvcDsgaW4gb3RoZXIgd29yZHMsIG5vIG1hdHRlciBob3cgbWFueSBjZWxscyB0aGVyZSBhcmUgaW4gYSB0YWJsZSAoaW5jbHVkaW5nIGlmIHRoZSBjZWxscyBjb250YWluIGludGVyYWN0aXZlIGVsZW1lbnRzKSwgaXQgb25seSB0YWtlcyBvbmUgcHJlc3Mgb2YgdGhlIFRhYiBidXR0b24gdG8gZ28gdGhyb3VnaCBpdC5cclxuICAgICAgICAgICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5QcmVzc2luZyB0aGUgYXJyb3cga2V5cyBuYXZpZ2F0ZXMgdGhyb3VnaCB0aGUgY2VsbHMgb2YgdGhlIFRhYmxlLiBZb3UgY2FuIG92ZXJyaWRlIGVhY2ggY2VsbCdzIDxjb2RlPmZvY3VzU2VsZjwvY29kZT4gcHJvcCB0byBoYW5kbGUgY2hpbGQgZWxlbWVudHMuPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPk1vc3Qgb3RoZXIgcnVsZXMgb2YgbGlzdCBuYXZpZ2F0aW9uIGFwcGx5IChhcyBpbiBMaXN0Ym94ZXMpLCBidXQgaW4gdHdvIGRpbWVuc2lvbnMuPC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgYm9keSByb3dzIGFyZSBzb3J0YWJsZSB2aWEgZWFjaCBjZWxsJ3MgPGNvZGU+dmFsdWU8L2NvZGU+IHByb3AuIEFzIGEgcmVzdWx0IG9mIHRoaXMsIGVhY2ggcm93IG11c3QgYmUgYSA8ZW0+ZGlyZWN0PC9lbT4gY2hpbGQgb2YgdGhlIGJvZHksIGxpa2UgYXMgYSBub3JtYWwgYXJyYXkgb2YgY2hpbGRyZW4gd2l0aCBubyBpbnRlcnZlbmluZyBKU1guPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+SWYgeW91IGRvbid0IG5lZWQgYWxsIHRoZSBzb3J0aW5nIGFuZCBmb2N1cyBtYW5hZ2VtZW50IGFuZCBzdWNoLCB0aGVyZSdzIG5vIHJlYXNvbiBub3QgdG8ganVzdCB1c2UgdGhlIGdvb2Qgb2xkIDxjb2RlPiZsdDt0YWJsZSZndDs8L2NvZGU+IGVsZW1lbnQuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5JdCdzIHVwIHRvIHlvdSB0byBtYWtlIHN1cmUgdGhhdCBhbnkgaW50ZXJhY3RpdmUgZWxlbWVudHMgd2l0aGluIGEgdGFibGUgY2VsbCByZXNwb25kIHRvIGZvY3VzIG1hbmFnZW1lbnQgcHJvcGVybHkgd2l0aCB0aGUgYWZvcmVtZW50aW9uZWQgPGNvZGU+Zm9jdXNTZWxmPC9jb2RlPiBwcm9wIGFuZCBhIHByb3Blcmx5IHBsYWNlZCA8Y29kZT50YWJJbmRleD17XCJ7XCJ9aW5mby5yb3ZpbmdUYWJJbmRleC50YWJiYWJsZT8gMCA6IC0xe1wifVwifTwvY29kZT4gaW4gdGhlIDxjb2RlPnJlbmRlcjwvY29kZT4gcHJvcC48L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcclxuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBEZW1vSW5wdXQoeyB0YWJiYWJsZSB9OiB7IHRhYmJhYmxlOiBib29sZWFuIH0pIHtcclxuICAgIGNvbnN0IFt2LCBzZXRWXSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiB0YWJJbmRleD17dGFiYmFibGUgPyAwIDogLTF9IG9uSW5wdXQ9e3VzZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XHJcbiAgICAgICAgICAgIHNldFYoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH0sIFtdKX0gdmFsdWU9e3Z9IC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIERlbW9UYWJsZUNlbGwoeyBpbmRleCwgaGVhZGVyIH06IHsgaW5kZXg6IG51bWJlciwgaGVhZGVyPzogYm9vbGVhbiB9KSB7XHJcbiAgICBjb25zdCByID0gdXNlUmVmKE1hdGgucmFuZG9tKCkpO1xyXG5cclxuICAgIGlmIChoZWFkZXIpIHtcclxuICAgICAgICBjb25zdCB0ZXh0ID0gYEhlYWRlciAjJHtpbmRleH1gO1xyXG4gICAgICAgIHJldHVybiA8VGFibGVDZWxsIGhlYWRlclR5cGU9XCJjb2x1bW5cIiB0YWdUYWJsZUNlbGw9XCJ0aFwiIGluZGV4PXtpbmRleH0gZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fSB0ZXh0PXt0ZXh0fSB2YWx1ZT17dGV4dH0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyVGFibGVDZWxsKHsgdGFnVGFibGVDZWxsOiBcInRoXCIsIG1ha2VQcm9wc1RhYmxlQ2VsbDogKGluZm8pID0+ICh7IGNoaWxkcmVuOiA8YnV0dG9uIHRhYkluZGV4PXtpbmZvLnJvdmluZ1RhYkluZGV4LnRhYmJhYmxlID8gMCA6IC0xfSBvbkNsaWNrPXsoKSA9PiBpbmZvLnRhYmxlSGVhZGVyQ2VsbC5zb3J0KCl9Pnt0ZXh0fTwvYnV0dG9uPiB9KSB9KX0gLz5cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHRleHQgPSBgQ2VsbCBpbiBjb2x1bW4gIyR7aW5kZXh9YDtcclxuICAgICAgICBzd2l0Y2ggKGluZGV4KSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHJldHVybiA8VGFibGVDZWxsIGhlYWRlclR5cGU9e251bGx9IHRhZ1RhYmxlQ2VsbD1cInRkXCIgaW5kZXg9e2luZGV4fSBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9IHRleHQ9e1wiXCJ9IHZhbHVlPXtcIlwifSByZW5kZXI9e2RlZmF1bHRSZW5kZXJUYWJsZUNlbGwoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRhZ1RhYmxlQ2VsbDogXCJ0ZFwiLCBtYWtlUHJvcHNUYWJsZUNlbGw6IChpbmZvKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogPERlbW9JbnB1dCB0YWJiYWJsZT17aW5mby5yb3ZpbmdUYWJJbmRleC50YWJiYWJsZX0gLz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH0pfSAvPlxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxUYWJsZUNlbGwgaGVhZGVyVHlwZT17bnVsbH0gdGFnVGFibGVDZWxsPVwidGRcIiBpbmRleD17aW5kZXh9IGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gdGV4dD17ci5jdXJyZW50LnRvU3RyaW5nKCl9IHZhbHVlPXtyLmN1cnJlbnQudG9TdHJpbmcoKX0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyVGFibGVDZWxsKHsgdGFnVGFibGVDZWxsOiBcInRkXCIsIG1ha2VQcm9wc1RhYmxlQ2VsbDogKCkgPT4gKHsgY2hpbGRyZW46IHIuY3VycmVudC50b1N0cmluZygpIH0pIH0pfSAvPlxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XHJcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDUpO1xyXG5cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxCbHVyYiAvPlxyXG4gICAgICAgICAgICA8Q29kZSAvPlxyXG4gICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49ezB9IHZhbHVlPXtjb3VudH0gb25JbnB1dD17ZSA9PiBzZXRDb3VudChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+ICMgb2YgdGFibGUgcm93czwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8VGFibGUgbm9UeXBlYWhlYWQ9e3RydWV9IHJlbmRlcj17ZGVmYXVsdFJlbmRlclRhYmxlKHtcclxuICAgICAgICAgICAgICAgICAgICB0YWdUYWJsZTogXCJ0YWJsZVwiLCBcclxuICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNUYWJsZTogKCkgPT4gKHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiA8PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFRhYmxlSGVhZCB0YWdUYWJsZUhlYWQ9XCJ0aGVhZFwiIHJlbmRlcj17ZGVmYXVsdFJlbmRlclRhYmxlSGVhZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnVGFibGVIZWFkOiBcInRoZWFkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzVGFibGVIZWFkOiAoKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogPFRhYmxlUm93IHRhZ1RhYmxlUm93PVwidHJcIiBub1R5cGVhaGVhZD17dHJ1ZX0gaW5kZXg9ezB9IHRleHQ9e1wiXCJ9IHJlbmRlcj17ZGVmYXVsdFJlbmRlclRhYmxlUm93KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ1RhYmxlUm93OiBcInRyXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNUYWJsZVJvdzogKCkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogPD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlbW9UYWJsZUNlbGwga2V5PXswfSBpbmRleD17MH0gaGVhZGVyPXt0cnVlfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGVtb1RhYmxlQ2VsbCBrZXk9ezF9IGluZGV4PXsxfSBoZWFkZXI9e3RydWV9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxEZW1vVGFibGVDZWxsIGtleT17Mn0gaW5kZXg9ezJ9IGhlYWRlcj17dHJ1ZX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJsZUJvZHkgcmVuZGVyPXtkZWZhdWx0UmVuZGVyVGFibGVCb2R5KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdUYWJsZUJvZHk6IFwidGJvZHlcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNUYWJsZUJvZHk6ICgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBBcnJheS5mcm9tKGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8VGFibGVSb3cgdGFnVGFibGVSb3c9XCJ0clwiIG5vVHlwZWFoZWFkPXt0cnVlfSBrZXk9e2l9IGluZGV4PXtpICsgMX0gdGV4dD17XCJcIn0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyVGFibGVSb3coe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdUYWJsZVJvdzogXCJ0clwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNUYWJsZVJvdzogKCkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiA8PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxEZW1vVGFibGVDZWxsIGtleT17MH0gaW5kZXg9ezB9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPERlbW9UYWJsZUNlbGwga2V5PXsxfSBpbmRleD17MX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8RGVtb1RhYmxlQ2VsbCBrZXk9ezJ9IGluZGV4PXsyfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSl9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSl9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Lyo8VGFibGVGb290IHJlbmRlcj17ZGVmYXVsdFJlbmRlclRhYmxlRm9vdCh7IHRhZ1RhYmxlRm9vdDogXCJ0Zm9vdFwiLCBtYWtlUHJvcHNUYWJsZUZvb3Q6ICgpID0+ICh7IGNoaWxkcmVuOiBudWxsIH0pIH0pfSAvPiovfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSl9IC8+XHJcblxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufSIsIlxyXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyR3JpZGxpc3QsIGRlZmF1bHRSZW5kZXJHcmlkbGlzdENoaWxkLCBkZWZhdWx0UmVuZGVyR3JpZGxpc3RSb3csIGRlZmF1bHRSZW5kZXJHcmlkbGlzdFNlY3Rpb24sIEdyaWRsaXN0LCBHcmlkbGlzdENoaWxkLCBHcmlkbGlzdFJvdywgR3JpZGxpc3RTZWN0aW9uIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC9ncmlkbGlzdFwiO1xyXG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyVGFibGUsIGRlZmF1bHRSZW5kZXJUYWJsZUJvZHksIGRlZmF1bHRSZW5kZXJUYWJsZUNlbGwsIGRlZmF1bHRSZW5kZXJUYWJsZUhlYWQsIGRlZmF1bHRSZW5kZXJUYWJsZVJvdywgVGFibGUsIFRhYmxlQm9keSwgVGFibGVDZWxsLCBUYWJsZUhlYWQsIFRhYmxlUm93IH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC90YWJsZVwiO1xyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7IHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7IH1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxwPkJlY2F1c2UgTGlzdGJveGVzIGFyZSBub3QgYWxsb3dlZCB0byBjb250YWluIGludGVyYWN0aXZlIGNvbnRlbnQsIGEgR3JpZGxpc3QgaXMgc2VtYW50aWNhbGx5IGEgbGlzdCB0aGF0IDxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2dyaWQvXCI+Y29tcGxpZXMgd2l0aCB0aGUgQVJJQSBwYXR0ZXJuIGZvciBncmlkczwvYT4uPC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+SW4gdGVybXMgb2Yga2V5Ym9hcmQgbmF2aWdhdGlvbiBhbmQgdGFiYmluZyB0aHJvdWdoIGVsZW1lbnRzLCBhIEdyaWRsaXN0IGlzIGxpa2UgYSBMaXN0Ym94LCBidXQgaW4gdHdvIGRpbWVuc2lvbnMsIGxpa2UgYSBUYWJsZS48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRoZSByb3dzIG9mIGEgR3JpZGxpc3QgYXJlIHNvcnRhYmxlLiBJdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlLCBpbmRlcGVuZGVudGx5IHNvcnRhYmxlIHNlY3Rpb25zIHdpdGhpbiB0aGUgc2FtZSBHcmlkbGlzdC48L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5JdCdzIHVwIHRvIHlvdSB0byBtYWtlIHN1cmUgdGhhdCBhbnkgaW50ZXJhY3RpdmUgZWxlbWVudHMgd2l0aGluIGEgR3JpZGxpc3QgcmVzcG9uZCB0byBmb2N1cyBtYW5hZ2VtZW50IHByb3Blcmx5IHdpdGggPGNvZGU+Zm9jdXNTZWxmPC9jb2RlPiBwcm9wIGFuZCBhIHByb3Blcmx5IHBsYWNlZCA8Y29kZT50YWJJbmRleD17XCJ7XCJ9aW5mby5yb3ZpbmdUYWJJbmRleC50YWJiYWJsZT8gMCA6IC0xe1wifVwifTwvY29kZT4gaW4gdGhlIDxjb2RlPnJlbmRlcjwvY29kZT4gcHJvcC48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPkFueSBnaXZlbiByb3cgaW4gYSBHcmlkbGlzdCBjYW4gYmUgbWFya2VkIGFzIHNlbGVjdGVkLCBidXQgdGhpcyBpcyB1cCB0byB5b3UgdG8gaGFuZGxlIG1hbnVhbGx5IGF0IHRoZSBtb21lbnQ8L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcclxuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBEZW1vR3JpZGxpc3RDaGlsZDEoeyByb3cgfTogeyByb3c6IG51bWJlciB9KSB7XHJcbiAgICBjb25zdCB0ZXh0ID0gXCJHcmlkbGlzdCBjaGlsZCBcIiArIHJvdztcclxuICAgIHJldHVybiA8R3JpZGxpc3RDaGlsZCBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9IGluZGV4PXswfSBsb2NhdGlvbkluZGV4PXswfSB0ZXh0PXt0ZXh0fSByZW5kZXI9e2RlZmF1bHRSZW5kZXJHcmlkbGlzdENoaWxkKHsgdGFnR3JpZGxpc3RDaGlsZDogXCJkaXZcIiwgbWFrZVByb3BzR3JpZGxpc3RDaGlsZDogKGluZm8pID0+ICh7IGNoaWxkcmVuOiB0ZXh0IH0pIH0pfSAvPlxyXG59XHJcblxyXG5mdW5jdGlvbiBEZW1vR3JpZGxpc3RDaGlsZDIoKSB7XHJcbiAgICBjb25zdCByZWYgPSB1c2VSZWY8SFRNTElucHV0RWxlbWVudD4obnVsbCk7XHJcbiAgICBjb25zdCBbYiwgc2V0Ql0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICByZXR1cm4gPEdyaWRsaXN0Q2hpbGQgZm9jdXNTZWxmPXsoKSA9PiByZWYuY3VycmVudD8uZm9jdXMoKX0gZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fSBpbmRleD17MX0gbG9jYXRpb25JbmRleD17MH0gdGV4dD17Yi50b1N0cmluZygpfSByZW5kZXI9e2RlZmF1bHRSZW5kZXJHcmlkbGlzdENoaWxkKHsgdGFnR3JpZGxpc3RDaGlsZDogXCJkaXZcIiwgbWFrZVByb3BzR3JpZGxpc3RDaGlsZDogKGluZm8pID0+ICh7IGNoaWxkcmVuOiA8aW5wdXQgcmVmPXtyZWZ9IHR5cGU9XCJjaGVja2JveFwiIHRhYkluZGV4PXtpbmZvLnJvdmluZ1RhYkluZGV4LnRhYmJhYmxlPyAwIDogLTF9IGNoZWNrZWQ9e2J9IG9uSW5wdXQ9e2UgPT4gc2V0QihlLmN1cnJlbnRUYXJnZXQuY2hlY2tlZCl9IC8+IH0pIH0pfSAvPlxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcclxuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoNSk7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPEJsdXJiIC8+XHJcbiAgICAgICAgICAgIDxDb2RlIC8+XHJcbiAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cIm51bWJlclwiIG1pbj17MH0gdmFsdWU9e2NvdW50fSBvbklucHV0PXtlID0+IHNldENvdW50KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz4gIyBvZiB0YWJsZSByb3dzPC9sYWJlbD5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxHcmlkbGlzdCBpbml0aWFsSW5kZXg9ezB9IHJlbmRlcj17ZGVmYXVsdFJlbmRlckdyaWRsaXN0KHtcclxuICAgICAgICAgICAgICAgICAgICB0YWdHcmlkbGlzdDogXCJkaXZcIiwgbWFrZVByb3BzR3JpZGxpc3Q6IChpbmZvKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogPEdyaWRsaXN0U2VjdGlvbiBpbmRleD17MH0gY29tcGFyZVJvd3M9eyhsaHMsIHJocykgPT4gbGhzIC0gcmhzfSByZW5kZXI9e2RlZmF1bHRSZW5kZXJHcmlkbGlzdFNlY3Rpb24oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnR3JpZGxpc3RTZWN0aW9uOiBcImRpdlwiLCBtYWtlUHJvcHNHcmlkbGlzdFNlY3Rpb246IChpbmZvKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBBcnJheS5mcm9tKGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPEdyaWRsaXN0Um93IGluZGV4PXtpfSB0ZXh0PVwiXCIgcmVuZGVyPXtkZWZhdWx0UmVuZGVyR3JpZGxpc3RSb3coe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0dyaWRsaXN0Um93OiBcImRpdlwiLCBtYWtlUHJvcHNHcmlkbGlzdFJvdzogKGluZm8pID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbPERlbW9HcmlkbGlzdENoaWxkMSByb3c9e2l9IC8+LCA8RGVtb0dyaWRsaXN0Q2hpbGQyIC8+XVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KX0gLz5cclxuICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufSIsIlxyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyBUb29sYmFyQ2hpbGQgfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50L3Rvb2xiYXJcIjtcclxuaW1wb3J0IHsgQnV0dG9uLCBkZWZhdWx0UmVuZGVyQnV0dG9uLCBkZWZhdWx0UmVuZGVyVG9vbGJhciwgVG9vbGJhciB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7IHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7IH1cclxuXHJcbmNvbnN0IERlbW9MaXN0SXRlbSA9IG1lbW8oZnVuY3Rpb24gRGVtb0xpc3RJdGVtKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pIHtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxUb29sYmFyQ2hpbGRcclxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxyXG4gICAgICAgICAgICB0ZXh0PXtgTGlzdCBpdGVtICMke2luZGV4fWB9XHJcbiAgICAgICAgICAgIHJlbmRlcj17KHsgcm92aW5nVGFiSW5kZXg6IHsgdGFiYmFibGUgfSB9LCBtb2RpZnlQcm9wcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDxCdXR0b24gZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fSB0YWdCdXR0b249XCJidXR0b25cIiByZW5kZXI9e2RlZmF1bHRSZW5kZXJCdXR0b24oXCJidXR0b25cIiwgKCkgPT4gbW9kaWZ5UHJvcHMoeyBcImRhdGEtdGFiYmFibGVcIjogdGFiYmFibGUudG9TdHJpbmcoKSwgY2hpbGRyZW46IGBCdXR0b24gIyR7aW5kZXh9YCB9KSl9IC8+XHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgLz5cclxuICAgIClcclxufSlcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgIGV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvdG9vbGJhci9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgVG9vbGJhciBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxyXG4gICAgICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaT5BIFRvb2xiYXIgaXMgYSBzaW5nbGUgd2lkZ2V0IGZvciB0aGUgcHVycG9zZXMgb2Yga2V5Ym9hcmQgbmF2aWdhdGlvbiwgbGlrZSBhIExpc3Rib3guPC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8bGk+VG9vbGJhcnMgYXJlIHdlbGwtc3VpdGVkIGZvciBcImJ1dHRvbiBncm91cFwiIHBhdHRlcm5zIGFzIHdlbGwuIE11bHRpcGxlIGdyb3VwcyBjYW4gYmUgY29udGFpbmVkIHdpdGhpbiBhIHNpbmdsZSBUb29sYmFyLCBldmVuIG11bHRpcGxlIGRpZmZlcmVudCB0eXBlcyBvZiBjb21wb25lbnRzLjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaT5Zb3UgbXVzdCBsYWJlbCB0aGUgVG9vbGJhciB3aXRoIDxjb2RlPmFyaWEtbGFiZWw8L2NvZGU+LjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICApXHJcbiAgICB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcclxuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xyXG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIGxpc3QgaXRlbXM8L2xhYmVsPlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPFRvb2xiYXJcclxuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbj1cImhvcml6b250YWxcIlxyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcj17ZGVmYXVsdFJlbmRlclRvb2xiYXIoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdDb250YWluZXI6IFwiZGl2XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0NvbnRhaW5lcjogKCkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiA8PntBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb0xpc3RJdGVtIGluZGV4PXtpfSBrZXk9e2l9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSl9PC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufSIsIlxyXG5pbXBvcnQgeyByZW5kZXIsIGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IEhlYWRpbmcgfSBmcm9tIFwiLi4vY29tcG9uZW50L2hlYWRpbmdcIjtcclxuaW1wb3J0ICogYXMgQWNjb3JkaW9uIGZyb20gXCIuL2RlbW9zL2FjY29yZGlvblwiXHJcbmltcG9ydCAqIGFzIEJ1dHRvbiBmcm9tIFwiLi9kZW1vcy9idXR0b25cIlxyXG5pbXBvcnQgKiBhcyBDaGVja2JveCBmcm9tIFwiLi9kZW1vcy9jaGVja2JveFwiXHJcbmltcG9ydCAqIGFzIENoZWNrYm94R3JvdXAgZnJvbSBcIi4vZGVtb3MvY2hlY2tib3gtZ3JvdXBcIlxyXG5pbXBvcnQgKiBhcyBMaXN0Ym94TXVsdGkgZnJvbSBcIi4vZGVtb3MvbGlzdGJveC1tdWx0aVwiXHJcbmltcG9ydCAqIGFzIExpc3Rib3hTaW5nbGUgZnJvbSBcIi4vZGVtb3MvbGlzdGJveC1zaW5nbGVcIlxyXG5pbXBvcnQgKiBhcyBNZW51IGZyb20gXCIuL2RlbW9zL21lbnVcIlxyXG5pbXBvcnQgKiBhcyBSYWRpbyBmcm9tIFwiLi9kZW1vcy9yYWRpb1wiXHJcbmltcG9ydCAqIGFzIFNsaWRlciBmcm9tIFwiLi9kZW1vcy9zbGlkZXJcIlxyXG5pbXBvcnQgKiBhcyBEaWFsb2cgZnJvbSBcIi4vZGVtb3MvZGlhbG9nXCJcclxuaW1wb3J0ICogYXMgVGFicyBmcm9tIFwiLi9kZW1vcy90YWJzXCJcclxuaW1wb3J0ICogYXMgVG9vbHRpcCBmcm9tIFwiLi9kZW1vcy90b29sdGlwXCJcclxuaW1wb3J0ICogYXMgVG9hc3QgZnJvbSBcIi4vZGVtb3MvdG9hc3RcIlxyXG5pbXBvcnQgKiBhcyBUYWJsZSBmcm9tIFwiLi9kZW1vcy90YWJsZVwiXHJcbmltcG9ydCAqIGFzIEdyaWRsaXN0IGZyb20gXCIuL2RlbW9zL2dyaWRsaXN0XCJcclxuaW1wb3J0ICogYXMgVG9vbGJhciBmcm9tIFwiLi9kZW1vcy90b29sYmFyXCJcclxuXHJcbi8vaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gXCJwcmVhY3RcIjtcclxuLy9vcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID0gcXVldWVNaWNyb3Rhc2s7XHJcblxyXG4vL2NvbnN0IFJhbmRvbVdvcmRzID0gXCJMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4gVXQgZW5pbSBhZCBtaW5pbSB2ZW5pYW0sIHF1aXMgbm9zdHJ1ZCBleGVyY2l0YXRpb24gdWxsYW1jbyBsYWJvcmlzIG5pc2kgdXQgYWxpcXVpcCBleCBlYSBjb21tb2RvIGNvbnNlcXVhdC4gRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2UgY2lsbHVtIGRvbG9yZSBldSBmdWdpYXQgbnVsbGEgcGFyaWF0dXIuIEV4Y2VwdGV1ciBzaW50IG9jY2FlY2F0IGN1cGlkYXRhdCBub24gcHJvaWRlbnQsIHN1bnQgaW4gY3VscGEgcXVpIG9mZmljaWEgZGVzZXJ1bnQgbW9sbGl0IGFuaW0gaWQgZXN0IGxhYm9ydW0uXCIuc3BsaXQoXCIgXCIpO1xyXG5cclxuXHJcbmNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkRlbW9zXCI+XHJcbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJUb29sYmFyXCI+PFRvb2xiYXIuRGVtbyAvPjwvSGVhZGluZz5cclxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkRpYWxvZ1wiPjxEaWFsb2cuRGVtbyAvPjwvSGVhZGluZz5cclxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkdyaWRsaXN0XCI+PEdyaWRsaXN0LkRlbW8gLz48L0hlYWRpbmc+XHJcbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJUYWJsZVwiPjxUYWJsZS5EZW1vIC8+PC9IZWFkaW5nPlxyXG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiVG9hc3RcIj48VG9hc3QuRGVtbyAvPjwvSGVhZGluZz5cclxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIlRvb2x0aXBcIj48VG9vbHRpcC5EZW1vIC8+PC9IZWFkaW5nPlxyXG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiVGFic1wiPjxUYWJzLkRlbW8gLz48L0hlYWRpbmc+XHJcbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJTbGlkZXJcIj48U2xpZGVyLkRlbW8gLz48L0hlYWRpbmc+XHJcbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJTaW5nbGUtc2VsZWN0IExpc3Rib3hcIj48TGlzdGJveFNpbmdsZS5EZW1vIC8+PC9IZWFkaW5nPlxyXG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiQWNjb3JkaW9uXCI+PEFjY29yZGlvbi5EZW1vIC8+PC9IZWFkaW5nPlxyXG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiQnV0dG9uXCI+PEJ1dHRvbi5EZW1vIC8+PC9IZWFkaW5nPlxyXG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiQ2hlY2tib3hcIj48Q2hlY2tib3guRGVtbyAvPjwvSGVhZGluZz5cclxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkNoZWNrYm94IEdyb3VwXCI+PENoZWNrYm94R3JvdXAuRGVtbyAvPjwvSGVhZGluZz5cclxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIk11bHRpLXNlbGVjdCBMaXN0Ym94XCI+PExpc3Rib3hNdWx0aS5EZW1vIC8+PC9IZWFkaW5nPlxyXG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiTWVudVwiPjxNZW51LkRlbW8gLz48L0hlYWRpbmc+XHJcbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJSYWRpb1wiPjxSYWRpby5EZW1vIC8+PC9IZWFkaW5nPlxyXG4gICAgICAgICAgICB7LypcclxuICAgICAgIFxyXG4gICAgICAgIDxEZW1vVGFibGUgLz5cclxuXHJcblxyXG4gICAgICAgIDxEZW1vVXNlRm9jdXNUcmFwIC8+XHJcbiAgICAgICAgPERlbW9Vc2VEcm9wcGFibGUgLz5cclxuICAgICAgICA8RGVtb1VzZURyYWdnYWJsZSAvPlxyXG4gICAgICAgIDxpbnB1dCAvPiovfVxyXG4gICAgICAgIDwvSGVhZGluZz4pXHJcbn1cclxuXHJcbnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICByZW5kZXIoPENvbXBvbmVudCAvPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyb290XCIpISk7XHJcbn0pXHJcbiJdLCJuYW1lcyI6WyJIZWFkaW5nTGV2ZWxDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIkhlYWRpbmciLCJjaGlsZHJlbiIsImhlYWRpbmciLCJwcm9wcyIsImhlYWRpbmdMZXZlbEJlZm9yZVVzIiwidXNlQ29udGV4dCIsInRhZyIsIm5ld0hlYWRpbmdMZXZlbCIsIndhcm5Pbk92ZXJ3cml0ZSIsIl9qc3giLCJfanN4cyIsIkhlYWRpbmdSZXNldCIsIm5ld0xldmVsIiwidXNlRW5zdXJlU3RhYmlsaXR5IiwicGFyZW50SG9va05hbWUiLCJ2YWx1ZXMiLCJsZW5ndGgiLCJmb3JFYWNoIiwidmFsdWUiLCJpbmRleCIsImhlbHBlclRvRW5zdXJlU3RhYmlsaXR5IiwidXNlUmVmIiwic2hvd25FcnJvciIsImN1cnJlbnQiLCJjb25zb2xlIiwiZXJyb3IiLCJ1c2VQYXNzaXZlU3RhdGUiLCJvbkNoYW5nZSIsImdldEluaXRpYWxWYWx1ZSIsImN1c3RvbURlYm91bmNlUmVuZGVyaW5nIiwidmFsdWVSZWYiLCJVbnNldCIsIndhcm5pbmdSZWYiLCJjbGVhbnVwQ2FsbGJhY2tSZWYiLCJ1bmRlZmluZWQiLCJvblNob3VsZENsZWFuVXAiLCJ1c2VDYWxsYmFjayIsImNsZWFudXBDYWxsYmFjayIsInRyeUVuc3VyZVZhbHVlIiwiaW5pdGlhbFZhbHVlIiwiZXgiLCJnZXRWYWx1ZSIsIndhcm4iLCJzZXRWYWx1ZSIsImFyZyIsIkZ1bmN0aW9uIiwiciIsInByZXZEZXAiLCJuZXh0VmFsdWUiLCJkZWJvdW5jZVJlbmRlcmluZyIsIm5leHREZXAiLCJhY3RpdmVFbGVtZW50VXBkYXRlcnMiLCJNYXAiLCJsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzIiwid2luZG93Rm9jdXNlZFVwZGF0ZXJzIiwiZm9yRWFjaFVwZGF0ZXIiLCJ3aW5kb3ciLCJtYXAiLCJnZXQiLCJ1cGRhdGVycyIsInVwZGF0ZXIiLCJsYXN0U2VudCIsInNlbmQiLCJmb2N1c291dCIsImUiLCJ0YXJnZXQiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJyZWxhdGVkVGFyZ2V0Iiwid2luZG93Qmx1ciIsIldpbmRvdyIsImN1cnJlbnRUYXJnZXQiLCJ3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzIiwic2V0IiwiVGFibGUiLCJiYXNlNjQiLCJyYW5kb202Qml0cyIsImdlbmVyYXRlUmFuZG9tSWQiLCJwcmVmaXgiLCJyYW5kb202NEJpdHMiLCJuIiwiam9pbiIsInByZXZpb3VzSW5wdXRzIiwidG9SdW4iLCJjb21taXROYW1lIiwib3JpZ2luYWxDb21taXQiLCJvcHRpb25zIiwibmV3Q29tbWl0IiwiaWQiLCJlZmZlY3RJbmZvIiwiY2xlYXIiLCJhcmdzIiwiZWZmZWN0IiwiaW5wdXRzIiwiU3ltYm9sIiwidXNlU3RhYmxlR2V0dGVyIiwicmVmIiwidXNlQmVmb3JlTGF5b3V0RWZmZWN0IiwiRXJyb3IiLCJmbiIsImN1cnJlbnRDYWxsYmFja0dldHRlciIsImlzT2JqZWN0IiwidHlwZSIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJPYmplY3QiLCJmcmVlU2VsZiIsInNlbGYiLCJyb290Iiwib2JqZWN0UHJvdG8iLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwidG9TdHJpbmciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiZ2V0UmF3VGFnIiwiaXNPd24iLCJjYWxsIiwidW5tYXNrZWQiLCJyZXN1bHQiLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJiYXNlR2V0VGFnIiwiaXNPYmplY3RMaWtlIiwidXNlU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJzdGF0ZSIsInNldFN0YXRlUCIsInVzZVN0YXRlUCIsInNldFN0YXRlIiwiY2FsbGJhY2siLCJwcmV2VmFsdWUiLCJ1c2VNYW5hZ2VkQ2hpbGRyZW4iLCJwYXJlbnRQYXJhbWV0ZXJzIiwibWFuYWdlZENoaWxkcmVuIiwib25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Iiwib25DaGlsZHJlbk1vdW50Q2hhbmdlIiwiZ2V0SGlnaGVzdEluZGV4IiwibWFuYWdlZENoaWxkcmVuQXJyYXkiLCJoaWdoZXN0SW5kZXgiLCJhcnIiLCJyZWMiLCJsb3dlc3RJbmRleCIsImYiLCJjaGlsZCIsImZpZWxkIiwiaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkIiwiU2V0IiwicmVtb3RlVUxFQ2hpbGRDaGFuZ2VkIiwicmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyIsInNpemUiLCJhZGQiLCJtb3VudGVkIiwibW91bnRzIiwidW5tb3VudHMiLCJNYXRoIiwibWF4Iiwic2hhdmUiLCJzcGxpY2UiLCJ1c2VNYW5hZ2VkQ2hpbGQiLCJtYW5hZ2VkQ2hpbGQiLCJpbmZvIiwidXNlTGF5b3V0RWZmZWN0IiwiZmxhZ3MiLCJzdWJJbmZvIiwiZW50cmllcyIsImZsYXQiLCJyZW1vdGVVTEVDaGlsZE1vdW50ZWQiLCJ0IiwiQXJyYXkiLCJpc0FycmF5IiwiY2xzeCIsImFyZ3VtZW50cyIsImdldERvY3VtZW50IiwiZWxlbWVudCIsImRvY3VtZW50IiwiZ2xvYmFsVGhpcyIsInVzZU1lcmdlZENoaWxkcmVuIiwibGhzIiwicmhzIiwiY3JlYXRlRWxlbWVudCIsIkZyYWdtZW50IiwidXNlTWVyZ2VkQ2xhc3NlcyIsImNsYXNzIiwibGhzQ2xhc3MiLCJjbGFzc05hbWUiLCJsaHNDbGFzc05hbWUiLCJyaHNDbGFzcyIsInJoc0NsYXNzTmFtZSIsImxoc0NsYXNzZXMiLCJzcGxpdCIsInJoc0NsYXNzZXMiLCJhbGxDbGFzc2VzIiwiZnJvbSIsInByb2Nlc3NSZWYiLCJpbnN0YW5jZSIsImFzc2VydCIsImNvbWJpbmVkIiwic3R5bGVTdHJpbmdUb09iamVjdCIsInN0eWxlIiwiZnJvbUVudHJpZXMiLCJzdGF0ZW1lbnQiLCJ1c2VNZXJnZWRTdHlsZXMiLCJsb2ciLCJ1c2VNZXJnZWRQcm9wcyIsImxoc0FsbCIsInJoc0FsbCIsIl9saHNDaGlsZHJlbiIsIl9saHNDbGFzc05hbWUiLCJfbGhzU3R5bGUiLCJfbGhzUmVmIiwibGhzTWlzYyIsIl9yaHNDaGlsZHJlbiIsIl9yaHNDbGFzcyIsIl9yaHNDbGFzc05hbWUiLCJfcmhzU3R5bGUiLCJfcmhzUmVmIiwicmhzTWlzYyIsInJldCIsInVzZU1lcmdlZFJlZnMiLCJyaHNFbnRyaWVzIiwicmhzS2V5VSIsInJoc1ZhbHVlIiwicmhzS2V5IiwibGhzVmFsdWUiLCJtZXJnZWQiLCJtZXJnZUZ1bmN0aW9ucyIsInVzZVJlZkVsZW1lbnQiLCJvbkVsZW1lbnRDaGFuZ2UiLCJvbk1vdW50Iiwib25Vbm1vdW50IiwiaGFuZGxlciIsImNsZWFudXAiLCJjYW5kaWRhdGVTZWxlY3RvcnMiLCJjYW5kaWRhdGVTZWxlY3RvciIsIm1hdGNoZXMiLCJOb0VsZW1lbnQiLCJFbGVtZW50IiwiZ2V0Q2FuZGlkYXRlcyIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwiaW5jbHVkZUNvbnRhaW5lciIsImNhbmRpZGF0ZXMiLCJ1bnNoaWZ0IiwiZWwiLCJnZXRSb290Tm9kZSIsImlzSW5wdXQiLCJub2RlIiwiaXNIaWRkZW5JbnB1dCIsInJhZGlvU2V0IiwiZXNjYXBlIiwidGFnTmFtZSIsInNsaWNlIiwiYXBwbHkiLCJzb21lIiwid2lkdGgiLCJpc0hpZGRlbiIsIm5vZGVVbmRlckRldGFpbHMiLCJob3N0Iiwibm9kZVJvb3RIb3N0IiwiY29udGFpbnMiLCJhdHRhY2hlZCIsIm9yaWdpbmFsTm9kZSIsImlzWmVyb0FyZWEiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJoZWlnaHQiLCJfcmVmIiwiZ2V0U2hhZG93Um9vdCIsImdldENvbXB1dGVkU3R5bGUiLCJ2aXNpYmlsaXR5IiwiaXNEaXJlY3RTdW1tYXJ5IiwiZGlzcGxheUNoZWNrIiwiaXNOb2RlQXR0YWNoZWQiLCJwYXJlbnRFbGVtZW50Iiwicm9vdE5vZGUiLCJzaGFkb3dSb290IiwiYXNzaWduZWRTbG90IiwiZ2V0Q2xpZW50UmVjdHMiLCJwYXJlbnROb2RlIiwiaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSIsImlzRGlzYWJsZWRGcm9tRmllbGRzZXQiLCJpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUiLCJkaXNhYmxlZCIsImkiLCJpdGVtIiwidGFiSW5kZXgiLCJpc1Njb3BlIiwiaXNEZXRhaWxzV2l0aFN1bW1hcnkiLCJjYW5kaWRhdGVUYWJpbmRleCIsInJlZ3VsYXJUYWJiYWJsZXMiLCJkb2N1bWVudE9yZGVyIiwiZmFjdG9yeSIsInRoaXMiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2xhc3NDYWxsQ2hlY2siLCJUeXBlRXJyb3IiLCJfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmciLCJJbmVydFJvb3QiLCJyb290RWxlbWVudCIsImluZXJ0TWFuYWdlciIsIl9pbmVydE1hbmFnZXIiLCJfcm9vdEVsZW1lbnQiLCJfbWFuYWdlZE5vZGVzIiwiaGFzQXR0cmlidXRlIiwiX3NhdmVkQXJpYUhpZGRlbiIsImdldEF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsIl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlIiwiX29ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIl9vbk11dGF0aW9uIiwiYmluZCIsIm9ic2VydmUiLCJhdHRyaWJ1dGVzIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImRlc3RydWN0b3IiLCJkaXNjb25uZWN0IiwicmVtb3ZlQXR0cmlidXRlIiwiaW5lcnROb2RlIiwiX3VubWFuYWdlTm9kZSIsInN0YXJ0Tm9kZSIsIl90aGlzMiIsImNvbXBvc2VkVHJlZVdhbGsiLCJfdmlzaXROb2RlIiwiYWN0aXZlRWxlbWVudCIsImJvZHkiLCJub2RlVHlwZSIsIk5vZGUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiYmx1ciIsImZvY3VzIiwiRUxFTUVOVF9OT0RFIiwiX2Fkb3B0SW5lcnRSb290IiwiX21hbmFnZU5vZGUiLCJyZWdpc3RlciIsImRlcmVnaXN0ZXIiLCJfdW5tYW5hZ2VTdWJ0cmVlIiwiX3RoaXMzIiwiaW5lcnRTdWJyb290IiwiZ2V0SW5lcnRSb290Iiwic2V0SW5lcnQiLCJtYW5hZ2VkTm9kZXMiLCJzYXZlZEluZXJ0Tm9kZSIsInJlY29yZHMiLCJyZWNvcmQiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwiYXR0cmlidXRlTmFtZSIsIm1hbmFnZWROb2RlIiwiYXJpYUhpZGRlbiIsIkluZXJ0Tm9kZSIsImluZXJ0Um9vdCIsIl9ub2RlIiwiX292ZXJyb2RlRm9jdXNNZXRob2QiLCJfaW5lcnRSb290cyIsIl9zYXZlZFRhYkluZGV4IiwiX2Rlc3Ryb3llZCIsImVuc3VyZVVudGFiYmFibGUiLCJfdGhyb3dJZkRlc3Ryb3llZCIsImRlc3Ryb3llZCIsImhhc1NhdmVkVGFiSW5kZXgiLCJhZGRJbmVydFJvb3QiLCJyZW1vdmVJbmVydFJvb3QiLCJJbmVydE1hbmFnZXIiLCJfZG9jdW1lbnQiLCJfd2F0Y2hGb3JJbmVydCIsImFkZEluZXJ0U3R5bGUiLCJoZWFkIiwiZG9jdW1lbnRFbGVtZW50IiwicmVhZHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfb25Eb2N1bWVudExvYWRlZCIsImluZXJ0IiwiaGFzIiwicGFyZW50IiwiX2luZXJ0Um9vdCIsImluZXJ0RWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5lcnRFbGVtZW50IiwiX3RoaXMiLCJzaGFkb3dSb290QW5jZXN0b3IiLCJsb2NhbE5hbWUiLCJjb250ZW50IiwiZGlzdHJpYnV0ZWROb2RlcyIsImdldERpc3RyaWJ1dGVkTm9kZXMiLCJzbG90IiwiX2Rpc3RyaWJ1dGVkTm9kZXMiLCJhc3NpZ25lZE5vZGVzIiwiZmxhdHRlbiIsIl9pIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicXVlcnlTZWxlY3RvciIsInRleHRDb250ZW50IiwiYXBwZW5kQ2hpbGQiLCJIVE1MRWxlbWVudCIsIl9ibG9ja2luZ0VsZW1lbnRzIiwiX2FscmVhZHlJbmVydEVsZW1lbnRzIiwiX3RvcEVsUGFyZW50cyIsIl9zaWJsaW5nc1RvUmVzdG9yZSIsIl9pbmVydFNpYmxpbmdzIiwiX2dldFBhcmVudHMiLCJfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbiIsIl9oYW5kbGVNdXRhdGlvbnMiLCJudWxsYWJsZSIsInRvcCIsImVsZW1zIiwicHVzaCIsImluZGV4T2YiLCJfdG9wQ2hhbmdlZCIsInBvcCIsInJlbW92ZSIsIl9hIiwiX2IiLCJfYyIsIm5ld1RvcCIsInRvS2VlcEluZXJ0Iiwib2xkUGFyZW50cyIsIl9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzIiwibmV3UGFyZW50cyIsInRvU2tpcCIsImoiLCJfc3dhcEluZXJ0ZWRTaWJsaW5nIiwib2xkSW5lcnQiLCJuZXdJbmVydCIsInNpYmxpbmdzVG9SZXN0b3JlIiwiZGVsZXRlIiwiX3BhcmVudE1PIiwiZWxlbWVudHMiLCJtbyIsInNpYmxpbmdzIiwic2libGluZyIsImluZXJ0ZWRTaWJsaW5ncyIsIl9pc0luZXJ0YWJsZSIsInBhcmVudFRvT2JzZXJ2ZSIsIm1heWJlU2hhZHlSb290IiwiX19zaGFkeSIsIm11dGF0aW9ucyIsInBhcmVudHMiLCJtdXRhdGlvbiIsImlkeCIsImluZXJ0ZWRDaGlsZCIsInVzZUJsb2NraW5nRWxlbWVudCIsImVuYWJsZWQiLCJnZXRUYXJnZXQiLCJzdGFibGVHZXRUYXJnZXQiLCJ1c2VTdGFibGVDYWxsYmFjayIsImJsb2NraW5nRWxlbWVudHMiLCJ1c2VGb2N1c1RyYXAiLCJ0cmFwQWN0aXZlIiwiaGFuZGxlQWN0aXZlQ2hhbmdlIiwicmFmSGFuZGxlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicXVldWVNaWNyb3Rhc2siLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImdldFRvcEVsZW1lbnQiLCJlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8iLCJnZXRMYXN0QWN0aXZlRWxlbWVudCIsImdldEVsZW1lbnQiLCJ1c2VGb3JjZVVwZGF0ZSIsInVzZUhhc0ZvY3VzIiwib25Gb2N1c2VkQ2hhbmdlZCIsIm9uRm9jdXNlZElubmVyQ2hhbmdlZCIsIm9uTGFzdEZvY3VzZWRDaGFuZ2VkIiwib25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCIsIm9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UiLCJvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UiLCJvbldpbmRvd0ZvY3VzZWRDaGFuZ2UiLCJnZXRXaW5kb3ciLCJnZXRGb2N1c2VkIiwicmV0dXJuRmFsc2UiLCJzZXRGb2N1c2VkSW5uZXIiLCJzZXRMYXN0Rm9jdXNlZCIsInNldExhc3RGb2N1c2VkSW5uZXIiLCJ1c2VSZWZFbGVtZW50UHJvcHMiLCJnZXRBY3RpdmVFbGVtZW50IiwiZ2V0V2luZG93Rm9jdXNlZCIsInVzZUFjdGl2ZUVsZW1lbnQiLCJwcmV2QWN0aXZlRWxlbWVudCIsInNlbGZFbGVtZW50IiwiZm9jdXNlZCIsImZvY3VzZWRJbm5lciIsInNldEZvY3VzZWQiLCJsYXN0QWN0aXZlRWxlbWVudCIsInByZXZMYXN0QWN0aXZlRWxlbWVudCIsInVzZUhhc0ZvY3VzUHJvcHMiLCJnZXRMYXN0Rm9jdXNlZCIsImdldExhc3RGb2N1c2VkSW5uZXIiLCJ1c2VQcmVzcyIsImV4Y2x1ZGUiLCJoYXNGb2N1cyIsIm9uQ2xpY2tTeW5jIiwiYWN0aXZlIiwic2V0QWN0aXZlIiwiZ2V0QWN0aXZlIiwiZm9yY2VVcGRhdGUiLCJwIiwidGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSIsInNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUiLCJwc2V1ZG9BY3RpdmUiLCJ1c2VHbG9iYWxIYW5kbGVyIiwiXyIsInByZXYiLCJub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoIiwiRGF0ZSIsIm9uQWN0aXZlU3RhcnQiLCJhIiwib25BY3RpdmVTdG9wIiwidGltZURpZmZlcmVuY2UiLCJjdXJyZW50VGltZSIsImNoYXJhY3RlcnNTZWxlY3RlZCIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlUHJlc3MiLCJwdWxzZSIsImV4Y2x1ZGVzIiwiZGV0YWlsIiwiYnV0dG9uIiwib25Nb3VzZVVwIiwib25Nb3VzZUxlYXZlIiwib25DbGljayIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInN0b3BQcm9wYWdhdGlvbiIsInVzZVByZXNzUHJvcHMiLCJvbktleURvd24iLCJjdXJzb3IiLCJ1c2VUaW1lb3V0IiwidGltZW91dCIsInRyaWdnZXJJbmRleCIsInN0YWJsZUNhbGxiYWNrIiwic3RhcnRUaW1lUmVmIiwiZ2V0VGltZW91dCIsInRpbWVvdXRJc051bGwiLCJ1c2VMaW5lYXJOYXZpZ2F0aW9uIiwibGluZWFyTmF2aWdhdGlvbiIsIm5hdmlnYXRlVG9GaXJzdCIsIm50ZiIsIm5hdmlnYXRlVG9MYXN0IiwibnRsIiwibmF2aWdhdGVUb05leHQiLCJudG4iLCJuYXZpZ2F0ZVRvUHJldiIsIm50cCIsIm5hdmlnYXRpb25EaXJlY3Rpb24iLCJuZCIsImRpc2FibGVBcnJvd0tleXMiLCJkYWsiLCJkaXNhYmxlSG9tZUVuZEtleXMiLCJkaGVrIiwiZ2V0RGlzYWJsZUFycm93S2V5cyIsInVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyIsIm1ldGFLZXkiLCJnZXROYXZpZ2F0aW9uRGlyZWN0aW9uIiwiZ2V0RGlzYWJsZUhvbWVFbmRLZXlzIiwiZGlyZWN0aW9uQWxsb3dlZCIsImFsbG93c1ZlcnRpY2FsTmF2aWdhdGlvbiIsImFsbG93c0hvcml6b250YWxOYXZpZ2F0aW9uIiwidXNlVHlwZWFoZWFkTmF2aWdhdGlvbiIsInR5cGVhaGVhZE5hdmlnYXRpb24iLCJjb2xsYXRvciIsImdldEluZGV4IiwidHlwZWFoZWFkVGltZW91dCIsInNldEluZGV4Iiwibm9UeXBlYWhlYWQiLCJjdXJyZW50VHlwZWFoZWFkIiwiZ2V0Q3VycmVudFR5cGVhaGVhZCIsInNldEN1cnJlbnRUeXBlYWhlYWQiLCJzZXRJbnZhbGlkVHlwZWFoZWFkIiwiaW52YWxpZFR5cGVhaGVhZCIsInNldEltZUFjdGl2ZSIsImdldEltZUFjdGl2ZSIsIm5leHRUeXBlYWhlYWRDaGFyIiwic2V0TmV4dFR5cGVhaGVhZENoYXIiLCJ0eXBlYWhlYWQiLCJzYWZlTGhzIiwiY29tcGFyZSIsIm5vcm1hbGl6ZSIsInNhZmVSaHMiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsZUNvbXBhcmUiLCJpbnNlcnRpbmdDb21wYXJhdG9yIiwidGV4dCIsImNvbXBhcmF0b3JTaGFyZWQiLCJzdWJzdHJpbmciLCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJfZSIsImltZUFjdGl2ZSIsImN0cmxLZXkiLCJyZXZlcnNlIiwidXNlUm92aW5nVGFiSW5kZXgiLCJpbml0aWFsSW5kZXgiLCJvblRhYmJhYmxlSW5kZXhDaGFuZ2UiLCJvblRhYmJhYmxlUmVuZGVyIiwic2V0VGFiYmFibGVJbmRleDIiLCJzZXRUYWJiYWJsZUluZGV4IiwiZnJvbVVzZXJJbnRlcmFjdGlvbiIsInByZXZJbmRleCIsIm5leHRJbmRleCIsImNoYW5nZUluZGV4IiwibmV4dENoaWxkIiwicGFyZW50UmV0dXJuVHlwZSIsImdldEF0IiwiZm9jdXNTZWxmIiwiY29weUFycmF5Iiwic291cmNlIiwiYXJyYXkiLCJuYXRpdmVGbG9vciIsImZsb29yIiwibmF0aXZlUmFuZG9tIiwicmFuZG9tIiwiYmFzZVJhbmRvbSIsImxvd2VyIiwidXBwZXIiLCJzaHVmZmxlU2VsZiIsImxhc3RJbmRleCIsInJhbmQiLCJhcnJheVNodWZmbGUiLCJhcnJheU1hcCIsIml0ZXJhdGVlIiwiYmFzZVZhbHVlcyIsIm9iamVjdCIsImJhc2VUaW1lcyIsImFyZ3NUYWciLCJiYXNlSXNBcmd1bWVudHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzQXJndW1lbnRzIiwic3R1YkZhbHNlIiwiZnJlZUV4cG9ydHMiLCJleHBvcnRzIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsInJlSXNVaW50IiwiaXNJbmRleCIsInRlc3QiLCJpc0xlbmd0aCIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSIsImJhc2VVbmFyeSIsImZ1bmMiLCJmcmVlUHJvY2VzcyIsInByb2Nlc3MiLCJub2RlVXRpbCIsInR5cGVzIiwicmVxdWlyZSIsImJpbmRpbmciLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5IiwiYXJyYXlMaWtlS2V5cyIsImluaGVyaXRlZCIsImlzQXJyIiwiaXNBcmciLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsIlN0cmluZyIsImlzUHJvdG90eXBlIiwiQ3RvciIsImNvbnN0cnVjdG9yIiwicHJvdG8iLCJvdmVyQXJnIiwidHJhbnNmb3JtIiwibmF0aXZlS2V5cyIsImtleXMiLCJiYXNlS2V5cyIsImFzeW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwiaXNBcnJheUxpa2UiLCJiYXNlU2h1ZmZsZSIsImNvbGxlY3Rpb24iLCJzaHVmZmxlIiwic2V0Rm9yY2VVcGRhdGUiLCJyZXR1cm5OdWxsIiwicmVhcnJhbmdlIiwic29ydGVkUm93cyIsImluZGV4QXNTb3J0ZWQiLCJpbmRleEFzVW5zb3J0ZWQiLCJtYW5nbGVNYXAiLCJkZW1hbmdsZU1hcCIsInVzZVJlYXJyYW5nZWFibGVQcm9wcyIsIl9wcmV2IiwibWFuZ2xlZEluZGV4IiwiaW5kZXhNYW5nbGVyIiwiZGVtYW5nbGVkSW5kZXgiLCJzb3J0IiwiaCIsInJlYXJyYW5nZWFibGVDaGlsZHJlbiIsImluZGV4RGVtYW5nbGVyIiwidXNlU29ydGFibGVDaGlsZHJlbiIsInNvcnRhYmxlQ2hpbGRyZW4iLCJ1c2VyQ29tcGFyZSIsImRlZmF1bHRDb21wYXJlIiwidXNlU29ydGFibGVQcm9wcyIsInJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGUiLCJ1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW4iLCJ1c2VMaXN0TmF2aWdhdGlvbiIsIm1jIiwicm92aW5nVGFiSW5kZXgiLCJsaXN0TmF2aWdhdGlvbiIsImlkZW50aXR5IiwibSIsInUiLCJ1c2VSb3ZpbmdUYWJJbmRleENoaWxkIiwiZ2V0VGFiYmFibGVJbmRleCIsIm5hdmlnYXRlVG9JbmRleCIsInRyeU5hdmlnYXRlVG9JbmRleCIsImRlZmF1bHQiLCJzZWFyY2hEaXJlY3Rpb24iLCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQiLCJjIiwidXNlTGlzdE5hdmlnYXRpb25Qcm9wcyIsInVzZUVmZmVjdCIsInVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyIsInRhYmJhYmxlIiwiZ2V0VGFiYmFibGUiLCJoaWRkZW4iLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMiLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkIiwidXNlR3JpZE5hdmlnYXRpb24iLCJydGkiLCJscyIsImxuIiwidG4iLCJncmlkTmF2aWdhdGlvbiIsInJvd0luZGV4RGVtYW5nbGVyIiwicm93SW5kZXhNYW5nbGVyIiwic2V0Q3VycmVudENvbHVtbiIsImdldEN1cnJlbnRDb2x1bW4iLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkQXNHcmlkUm93IiwidXNlTGlzdE5hdmlnYXRpb25Qcm9wc0FzR3JpZFBhcmVudCIsInBhcmVudExzUmV0dXJuVHlwZSIsInVzZUdyaWROYXZpZ2F0aW9uUm93IiwiYXNDaGlsZFJvd09mU2VjdGlvbiIsImFzQ2hpbGQiLCJhc1BhcmVudFJvd09mQ2VsbHMiLCJhc1BhcmVudCIsInVzZVJhbmRvbUlkIiwicmFuZG9tSWQiLCJiYWNrdXBSYW5kb21JZCIsImdldEJhY2t1cFJhbmRvbUlkIiwidXNlZElkIiwic2V0VXNlZElkIiwiZ2V0VXNlZElkIiwibWlzbWF0Y2hFcnJvclJlZiIsInVzZUJ1dHRvbiIsInRhZ0J1dHRvbiIsIm9uUHJlc3MiLCJwcmVzc2VkIiwidXNlQWNjb3JkaW9uIiwiYWNjb3JkaW9uIiwiX2N1cnJlbnRGb2N1c2VkSW5kZXgiLCJzZXRDdXJyZW50Rm9jdXNlZEluZGV4IiwiZ2V0Q3VycmVudEZvY3VzZWRJbmRleCIsIm1jUmV0dXJuVHlwZSIsIm9jbWMyIiwiY2hhbmdlVGFiYmVkSW5kZXgiLCJsaW5lYXJSZXR1cm5UeXBlIiwiY2hhbmdlRXhwYW5kZWRJbmRleCIsImdldEN1cnJlbnRJbmRleCIsIl9nZXRDdXJyZW50RXhwYW5kZWRJbmRleCIsInVzZUNoaWxkcmVuRmxhZyIsIl9nZXRUYWJiZWRJbmRleCIsInJlZXZhbHVhdGVDbG9zZXN0Rml0Iiwib25JbmRleENoYW5nZSIsImRlYnVnTG9nIiwib3BlbkZyb21QYXJlbnQiLCJzZXRPcGVuRnJvbVBhcmVudCIsImdldE9wZW5Gcm9tUGFyZW50IiwidXNlQm9keUFzU291cmNlSWQiLCJ1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50IiwidXNlSGVhZGVyQXNSZWZlcmVuY2VySWQiLCJib2R5SWQiLCJnZXRCb2R5SWQiLCJ1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQiLCJ1c2VIZWFkZXJBc1NvdXJjZUlkIiwidXNlQm9keUFzUmVmZXJlbmNlcklkIiwiaGVhZGVySWQiLCJnZXRIZWFkZXJJZCIsInVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzIiwidXNlQm9keUFzU291cmNlSWRQcm9wcyIsInVzZUJvZHlBc1JlZmVyZW5jZXJJZFByb3BzIiwidXNlSGVhZGVyQXNTb3VyY2VJZFByb3BzIiwidXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIiwidXNlSGVhZGVyQXNSZWZlcmVuY2VySWRQcm9wcyIsIm9wZW4iLCJvcGVuRnJvbVVzZXIiLCJnZXRIZWFkZXJFbGVtZW50IiwidXNlSGVhZGVyUmVmRWxlbWVudFByb3BzIiwiZ2V0Qm9keUVsZW1lbnQiLCJ1c2VCb2R5UmVmRWxlbWVudFByb3BzIiwib3BlblJlZiIsImJvZHlFbGVtZW50IiwiaXNWYWxpZCIsInJldHVyblRydWUiLCJ0YWJiZWRSZWYiLCJ1c2VMYWJlbCIsImxhYmVsIiwicHJlZml4SW5wdXQiLCJwcmVmaXhMYWJlbCIsInRhZ0lucHV0IiwidGFnTGFiZWwiLCJ1c2VMYWJlbEFzU291cmNlSWQiLCJ1c2VMYWJlbEFzUmVmZXJlbmNlcklkIiwibGFiZWxJZCIsImdldExhYmVsSWQiLCJ1c2VJbnB1dEFzU291cmNlSWQiLCJ1c2VJbnB1dEFzUmVmZXJlbmNlcklkIiwiaW5wdXRJZCIsImdldElucHV0SWQiLCJ1c2VMYWJlbEFzU291cmNlSWRQcm9wcyIsInVzZUlucHV0QXNTb3VyY2VJZFByb3BzIiwidXNlTGFiZWxBc1JlZmVyZW5jZXJJZFByb3BzIiwidXNlSW5wdXRBc1JlZmVyZW5jZXJJZFByb3BzIiwiaXNTeW50aGV0aWNMYWJlbCIsInVzZUxhYmVsTGFiZWwiLCJ1c2VMYWJlbExhYmVsUHJvcHMiLCJwcm9wc1dpdGhvdXRGb3IiLCJwcm9wc1dpdGhGb3IiLCJ1c2VMYWJlbElucHV0IiwicHJvcHNXaXRoQXJpYUxhYmVsbGVkQnkiLCJwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeSIsImhhbmRsZXNJbnB1dCIsImxhYmVsUG9zaXRpb24iLCJ3aGljaCIsInVzZUNoZWNrYm94TGlrZSIsImNoZWNrYm94TGlrZSIsImNoZWNrZWQiLCJyb2xlIiwib25DaGVja2VkQ2hhbmdlIiwiaGFzRm9jdXNJbnB1dCIsImhhc0ZvY3VzTGFiZWwiLCJzdGFibGVPbklucHV0IiwidXNlSUxJbnB1dCIsInVzZUlMTGFiZWwiLCJnZXRMYWJlbEVsZW1lbnQiLCJ1c2VMYWJlbFJlZkVsZW1lbnRQcm9wcyIsImxpc3RSZXR1cm5UeXBlIiwiYWxsSWRzIiwic2V0Q29udHJvbHMiLCJ1cGRhdGVJbmRleCIsInNldElkVXBkYXRlSW5kZXgiLCJjaGVja2VkQ291bnQiLCJzZXRDaGVja2VkQ291bnQiLCJnZXRTZWxmSXNDaGVja2VkVW5zdGFibGUiLCJwZXJjZW50YWdlIiwic2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkIiwic2V0UGFyZW50Q2hlY2tib3hDaGVja2VkIiwidXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0IiwiY2hlY2tib3giLCJfdm9pZDIiLCJfdm9pZDMiLCJzZXRDaGVja2VkIiwidXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQiLCJ1c2VDaGVja2JveExhYmVsRWxlbWVudCIsInVzZUNoZWNrYm94Iiwib25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQyIiwidXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyIsInVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMiLCJ1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcyIsImFyaWFDb250cm9scyIsIm9uSW5wdXQiLCJ1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyIsInVzZVNvZnREaXNtaXNzIiwib25DbG9zZSIsImdldEVsZW1lbnRzIiwic3RhYmxlT25DbG9zZSIsInN0YWJsZUdldEVsZW1lbnRzIiwiZ2V0T3BlbiIsIm9uQmFja2Ryb3BDbGljayIsImZvdW5kSW5zaWRlQ2xpY2siLCJuZXdFbGVtZW50IiwidmFsaWRGb2N1c2FibGVFbGVtZW50cyIsImZvY3VzYWJsZSIsIm1vdXNlRG93biIsImtleURvd24iLCJjYXB0dXJlIiwidG91Y2hTdGFydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1c2VTb2Z0RGlzbWlzc1Byb3BzIiwidXNlTW9kYWwiLCJtb2RhbCIsImJvZHlJc09ubHlTZW1hbnRpYyIsImRlc2NyaXB0aXZlIiwic29mdERpc21pc3MiLCJnZXRUaXRsZUVsZW1lbnQiLCJwcmV2ZW50U2Nyb2xsIiwidGl0bGVFbGVtZW50IiwidXNlTW9kYWxJZEFzU291cmNlIiwidXNlTW9kYWxJZEFzUmVmZXJlbmNlckVsZW1lbnQiLCJ1c2VCb2R5SWRBc1NvdXJjZSIsInVzZUJvZHlJZFJlZmVyZW5jZXJFbGVtZW50IiwidXNlVGl0bGVJZFJlZmVyZW5jZXJFbGVtZW50IiwidXNlTW9kYWxSZWZFbGVtZW50IiwiZ2V0TW9kYWxFbGVtZW50IiwidXNlTW9kYWxCYWNrZHJvcCIsInVzZU1vZGFsQmFja2Ryb3BQcm9wcyIsIm9uUG9pbnRlclVwIiwidXNlRHJhd2VyIiwidXNlTGlzdGJveFNpbmdsZSIsInRhZ0xpc3QiLCJvblNlbGVjdCIsIl9sYnMiLCJzaW5nbGVTZWxlY3Rpb24iLCJzZWxlY3RlZEluZGV4Iiwic3MiLCJjaGlsZHJlbkhhdmVGb2N1cyIsImNoZiIsImxhYmVsUmV0dXJuVHlwZSIsIm9uU2VsZWN0ZWRJbmRleENoYW5nZSIsImV2ZW50IiwibmV3SW5kZXgiLCJzdGFibGVPblNlbGVjdCIsImVuaGFuY2VFdmVudCIsInVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQiLCJ1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiIsInVzZUxhYmVsSW5wdXRQcm9wcyIsInVzZUxpc3Rib3hTaW5nbGVJdGVtIiwibGlzdGJveFNpbmdsZUl0ZW0iLCJydGlfcmV0Iiwic3NfcmV0IiwidXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzIiwidXNlTGlzdGJveE11bHRpIiwibGlzdGJveE11bHRpIiwib3BlbmVyIiwidXNlck9uQ2xvc2UiLCJyZWFzb24iLCJzZW5kRm9jdXNUb01lbnUiLCJnZXRJc09wZW4iLCJpbnRlcnNlY3Rpb25PYnNlcnZlciIsImdldFN1cmZhY2VGdWxseVZpc2libGUiLCJzZXRTdXJmYWNlRnVsbHlWaXNpYmxlIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbnRyeSIsImludGVyc2VjdGlvblJhdGlvIiwidGhyZXNob2xkIiwic2V0T3BlbmVyRWxlbWVudCIsImdldE9wZW5lckVsZW1lbnQiLCJnZXRCdXR0b25FbGVtZW50IiwidXNlQnV0dG9uUmVmRWxlbWVudFByb3BzIiwiZ2V0TWVudUVsZW1lbnQiLCJ1c2VNZW51QmFzZVJlZkVsZW1lbnRQcm9wcyIsInNvZnREaXNtaXNzUmV0dXJuIiwidXNlTWVudVN1cmZhY2VQcm9wcyIsInVzZU1lbnVTdXJmYWNlQnV0dG9uUHJvcHMiLCJzZXRUaW1lb3V0Iiwic2Nyb2xsSW50b1ZpZXciLCJ1c2VNZW51U3VyZmFjZUNoaWxkUHJvcHMiLCJ1c2VNZW51U3VyZmFjZVNlbnRpbmVsIiwidXNlU2VudGluZWxQcm9wcyIsInJlc3QiLCJ1c2VGb2N1c1NlbnRpbmVsIiwiZm9jdXNTZW50aW5lbCIsInVzZU1lbnVTZW50aW5lbFByb3BzIiwibWVudVN1cmZhY2UiLCJ1c2VUYWJzIiwidGFiUGFuZWxzIiwib2NtYyIsInRhYlBhbmVsc01hbmFnZWRDaGlsZHJlbiIsImJhc2VJZCIsIm1hbmFnZWRDaGlsZHJlblJldCIsImNoYW5nZVZpc2libGVQYW5lbCIsImdldFZpc2libGVJbmRleCIsImNsb3Nlc3RGaXQiLCJ1c2VUYWJMaXN0TGFiZWwiLCJ1c2VUYWJMaXN0TGFiZWxQcm9wcyIsInVzZVRhYkxpc3QiLCJ0YWJzIiwidGFiTGlzdE1hbmFnZWRDaGlsZHJlbiIsInN0YWJsZU9uU2VsZWN0ZWRJbmRleENoYW5nZSIsInVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMiLCJsaXN0TmF2UmV0MSIsInVzZVRvb2x0aXAiLCJtb3VzZW92ZXJEZWxheSIsIm1vdXNlb3V0VG9sZXJhbmNlRGVsYXkiLCJmb2N1c0RlbGF5IiwiZGVmYXVsdFByZXZlbnRlZCIsInNldE9wZW4iLCJzZXRIb3ZlclN0YXRlIiwic2V0VHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCIsInNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJpc0Zpbml0ZSIsImRlbGF5IiwiY2xlYXJUaW1lb3V0IiwiaGFuZGxlIiwic2V0VG9vbHRpcEZvY3VzZWQiLCJvbkhvdmVyQ2hhbmdlIiwiaG92ZXJpbmciLCJob3ZlclN0YXRlIiwic2V0VG9vbHRpcEhvdmVyIiwidHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCIsInRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJob3ZlckRlbGF5Q29ycmVjdGVkIiwidXNlVG9vbHRpcFRyaWdnZXIiLCJzZXRUcmlnZ2VySG92ZXIiLCJvblRvdWNoRW5kIiwicmFkaW9Hcm91cCIsIm9uU2VsZWN0ZWRWYWx1ZUNoYW5nZSIsInNlbGVjdGVkVmFsdWUiLCJ0YWdHcm91cCIsInRhZ0dyb3VwTGFiZWwiLCJzZWxlY3Rpb25Nb2RlIiwiX2dldFJhZGlvR3JvdXBQYXJlbnRFbGVtZW50Iiwic2V0U2VsZWN0ZWRJbmRleCIsInVzZUdyb3VwTGFiZWxJbnB1dCIsInVzZUdyb3VwTGFiZWxMYWJlbCIsInVzZUdyb3VwTGFiZWxJbnB1dFByb3BzIiwidXNlR3JvdXBMYWJlbExhYmVsUHJvcHMiLCJsaXN0TmF2UmV0IiwidXNlUmFkaW9Hcm91cExhYmVsUHJvcHMiLCJieU5hbWUiLCJ1c2VSYWRpbyIsInVzZVRvYXN0cyIsIm9jbXUiLCJ0b2FzdHMiLCJ2aXNpYmxlQ291bnQiLCJjdXJyZW50SW5kZXhRdWV1ZSIsInBvbGl0ZW5lc3MiLCJzZXRQb2xpdGVuZXNzIiwiZ2V0TWF4VmlzaWJsZUNvdW50IiwiaGlnaGVzdFByaW9yaXR5VG9hc3QiLCJ0b2FzdFF1ZXVlIiwic2hvdyIsIm9uQW55VG9hc3RNb3VudGVkIiwidG9hc3RJbmRleCIsInNldE51bWJlckFoZWFkT2ZNZSIsIl9pbmRleCIsInJlbW92YWxJbmRleCIsInNob3dIaWdoZXN0UHJpb3JpdHlUb2FzdCIsIl9tb3VzZU92ZXIyIiwic2V0TW91c2VPdmVyIiwiX2dldE1vdXNlT3ZlciIsIm1vdXNlT3ZlciIsInRvYXN0IiwibnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMiLCJzZXROdW1iZXJPZlRvYXN0c0FoZWFkT2ZVcyIsIkluZmluaXR5IiwiZGlzbWlzc2VkMiIsInNldERpc21pc3NlZDIiLCJnZXREaXNtaXNzZWQyIiwic2hvd2luZzIiLCJzZXRTaG93aW5nMiIsImdldFNob3dpbmcyIiwiZGlzbWlzcyIsIm9uQW55VG9hc3REaXNtaXNzZWQiLCJzZXRDdXJyZW50U29ydENvbHVtbiIsImJvZHlTb3J0IiwiZ3JpZE5hdlJldDEiLCJtYW5nbGVycyIsInJvd3MiLCJ0YWJsZVJvdyIsImxvY2F0aW9uIiwidGFnVGFibGVSb3ciLCJnZXRDZWxscyIsImNlbGxzIiwidXNlR3JpZE5hdmlnYXRpb25DZWxsIiwidXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyIsImdyaWROYXZSZXQyIiwiYXNQYXJlbnRPZkNlbGxzIiwidXNlVGFibGVDZWxsIiwidGFibGVDZWxsIiwidGFnVGFibGVDZWxsIiwiaGVhZGVyVHlwZSIsInNldE15U29ydERpcmVjdGlvbiIsInVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzIiwiZ3JpZE5hdlJldDMiLCJzb3J0SW5mbyIsImdldEN1cnJlbnRTb3J0Q29sdW1uIiwiZGlyZWN0aW9uIiwiY2VsbEluZGV4IiwiY2VsbCIsInVzZVRhYmxlQ2VsbFByb3BzIiwic2NvcGUiLCJteVNvcnREaXJlY3Rpb24iLCJ1c2VHcmlkbGlzdCIsInVzZUdyaWROYXZpZ2F0aW9uUHJvcHMiLCJ1c2VHcmlkbGlzdFJvdyIsImdyaWRsaXN0Um93IiwibG9jYXRpb25JbmRleCIsInVzZUdyaWRsaXN0Q2hpbGQiLCJ1c2VUb29sYmFyIiwidG9vbGJhciIsIm9yaWVudGF0aW9uIiwiQWNjb3JkaW9uIiwibWVtbyIsImV4cGFuZGVkSW5kZXgiLCJyZW5kZXIiLCJ1c2VBY2NvcmRpb25TZWN0aW9uIiwiZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSIsIm1ha2VJbnB1dFByb3BzIiwibWFrZUxhYmVsUHJvcHMiLCJtb2RpZnlJbnB1dFByb3BzIiwibW9kaWZ5TGFiZWxQcm9wcyIsImlucHV0UHJvcHNCYXNlIiwibGFiZWxQcm9wc0Jhc2UiLCJpbnB1dFByb3BzIiwibGFiZWxQcm9wcyIsImlucHV0IiwiZGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBDaGlsZCIsImRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwIiwiVXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dCIsIkNoZWNrYm94R3JvdXAiLCJwYXJlbnREaXNhYmxlZCIsImRlZmF1bHRSZW5kZXJQb3J0YWwiLCJwb3J0YWxJZCIsInBvcnRhbFJlZiIsImdldEVsZW1lbnRCeUlkIiwiY3JlYXRlUG9ydGFsIiwiZGVmYXVsdFJlbmRlck1vZGFsIiwidGFnRm9jdXNDb250YWluZXIiLCJ0YWdCYWNrZHJvcCIsInRhZ0JvZHkiLCJ0YWdEaWFsb2ciLCJ0YWdUaXRsZSIsIm1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyIiwibWFrZVByb3BzQmFja2Ryb3AiLCJtYWtlUHJvcHNCb2R5IiwibWFrZVByb3BzRGlhbG9nIiwibWFrZVByb3BzVGl0bGUiLCJkaWFsb2dJbmZvIiwibW9kaWZ5Rm9jdXNDb250YWluZXJQcm9wcyIsIm1vZGlmeURpYWxvZ1Byb3BzIiwibW9kaWZ5VGl0bGVQcm9wcyIsIm1vZGlmeUJvZHlQcm9wcyIsIm1vZGlmeUJhY2tkcm9wUHJvcHMiLCJ0aXRsZUNoaWxkcmVuIiwidGl0bGVQcm9wcyIsImJvZHlDaGlsZHJlbiIsImJvZHlQcm9wcyIsImRpYWxvZ0NoaWxkcmVuIiwiZGlhbG9nUHJvcHMiLCJiYWNrZHJvcENoaWxkcmVuIiwiYmFja2Ryb3BQcm9wcyIsImZvY3VzQ29udGFpbmVyQ2hpbGRyZW4iLCJmb2N1c0NvbnRhaW5lclByb3BzIiwidGl0bGUiLCJkaWFsb2ciLCJiYWNrZHJvcCIsIkxpc3Rib3hTaW5nbGVDb250ZXh0Iiwib25BbGxMb3N0Rm9jdXMiLCJvbkFueUdhaW5lZEZvY3VzIiwiTWVudSIsImRlZmF1bHRSZW5kZXJSYWRpb0dyb3VwIiwibWFrZVByb3BzR3JvdXAiLCJtYWtlUHJvcHNMYWJlbCIsIm1vZGlmeUdyb3VwUHJvcHMiLCJTbGlkZXJUaHVtYkNvbnRleHQiLCJTbGlkZXIiLCJtaW4iLCJ1c2VTbGlkZXJUaHVtYiIsIl9zbGlkZXJJbmZvIiwidXNlU2xpZGVyIiwic2xpZGVyIiwiTG9jYXRpb25Db250ZXh0IiwiVGFibGVTZWN0aW9uQ29udGV4dCIsIlRhYmxlQm9keUNvbnRleHQiLCJUYWJsZVJvd0NvbnRleHQiLCJUYWJsZUNlbGxDb250ZXh0IiwiZGVmYXVsdFJlbmRlclRhYmxlIiwidGFnVGFibGUiLCJtYWtlUHJvcHNUYWJsZSIsIm1vZGlmeVByb3BzVGFibGUiLCJkZWZhdWx0UmVuZGVyVGFibGVCb2R5IiwidGFnVGFibGVCb2R5IiwibWFrZVByb3BzVGFibGVCb2R5IiwibW9kaWZ5UHJvcHNUYWJsZUJvZHkiLCJkZWZhdWx0UmVuZGVyVGFibGVIZWFkIiwidGFnVGFibGVIZWFkIiwibWFrZVByb3BzVGFibGVIZWFkIiwibW9kaWZ5UHJvcHNUYWJsZUhlYWQiLCJkZWZhdWx0UmVuZGVyVGFibGVSb3ciLCJtYWtlUHJvcHNUYWJsZVJvdyIsIm1vZGlmeVByb3BzVGFibGVSb3ciLCJtYWtlUHJvcHNUYWJsZUNlbGwiLCJtb2RpZnlQcm9wc1RhYmxlQ2VsbCIsIlRhYkNvbnRleHQiLCJUYWJQYW5lbENvbnRleHQiLCJUYWJzIiwiZGVmYXVsdFJlbmRlclRvb2x0aXAiLCJ0YWdUb29sdGlwIiwibWFrZVRvb2x0aXBQcm9wcyIsIm1ha2VUcmlnZ2VyUHJvcHMiLCJtb2RpZnlQcm9wc1Rvb2x0aXAiLCJtb2RpZnlQcm9wc1RyaWdnZXIiLCJMb2NhdGlvbkluZGV4Q29udGV4dCIsIkdyaWRsaXN0U2VjdGlvbkNvbnRleHQiLCJHcmlkbGlzdFJvd0NvbnRleHQiLCJHcmlkbGlzdENoaWxkQ29udGV4dCIsImRlZmF1bHRSZW5kZXJHcmlkbGlzdCIsInRhZ0dyaWRsaXN0IiwibWFrZVByb3BzR3JpZGxpc3QiLCJtb2RpZnlQcm9wc0dyaWRsaXN0IiwiZGVmYXVsdFJlbmRlckdyaWRsaXN0U2VjdGlvbiIsInRhZ0dyaWRsaXN0U2VjdGlvbiIsIm1ha2VQcm9wc0dyaWRsaXN0U2VjdGlvbiIsIm1vZGlmeVByb3BzR3JpZGxpc3RTZWN0aW9uIiwiVG9vbGJhckNvbnRleHQiLCJCbHVyYiIsIl9GcmFnbWVudCIsIkNvZGUiLCJEZW1vIiwiRGVtb0NoZWNrYm94IiwiRGVtb0xpc3RJdGVtIiwiVG9vbGJhci5EZW1vIiwiRGlhbG9nLkRlbW8iLCJHcmlkbGlzdC5EZW1vIiwiVGFibGUuRGVtbyIsIlRvYXN0LkRlbW8iLCJUb29sdGlwLkRlbW8iLCJUYWJzLkRlbW8iLCJTbGlkZXIuRGVtbyIsIkxpc3Rib3hTaW5nbGUuRGVtbyIsIkFjY29yZGlvbi5EZW1vIiwiQnV0dG9uLkRlbW8iLCJDaGVja2JveC5EZW1vIiwiQ2hlY2tib3hHcm91cC5EZW1vIiwiTGlzdGJveE11bHRpLkRlbW8iLCJNZW51LkRlbW8iLCJSYWRpby5EZW1vIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QUFBZ3RDLGNBQVksSUFBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsYUFBYSxFQUFDLFVBQVUsRUFBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBQyxLQUFLLEVBQUMsUUFBUSxFQUFDLE9BQU8sR0FBRyxFQUNwSWh0QyxHQUFBLENBQUNndEMsY0FBWSxFQUFBLEVBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBQyxVQUFVLEVBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUMsS0FBSyxFQUFDLFFBQVEsRUFBQyxPQUFPLEVBQUEsQ0FBRyxFQUNwSWh0QyxHQUFDLENBQUFndEMsY0FBWSxFQUFDLEVBQUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBQyxVQUFVLEVBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUMsT0FBTyxFQUFDLFFBQVEsRUFBQyxLQUFLLEVBQUcsQ0FBQSxFQUNwSWh0QyxHQUFDLENBQUFndEMsY0FBWSxFQUFDLEVBQUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBQyxVQUFVLEVBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUMsT0FBTyxFQUFDLFFBQVEsRUFBQyxLQUFLLEVBQUEsQ0FBRyxFQUNwSWh0QyxHQUFBLENBQUNndEMsY0FBWSxFQUFDLEVBQUEsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBQyxVQUFVLEVBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUMsS0FBSyxFQUFDLFFBQVEsRUFBQyxLQUFLLEVBQUcsQ0FBQSxFQUNsSWh0QyxHQUFDLENBQUFndEMsY0FBWSxJQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUMsVUFBVSxFQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsUUFB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
