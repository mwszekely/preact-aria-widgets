(function () {
    'use strict';

    var n,
        l$1,
        u$1,
        t,
        o$2,
        r$2,
        f$1 = {},
        e$1 = [],
        c$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function s$1(n, l) {
      for (var u in l) n[u] = l[u];

      return n;
    }

    function a$1(n) {
      var l = n.parentNode;
      l && l.removeChild(n);
    }

    function h$1(l, u, i) {
      var t,
          o,
          r,
          f = {};

      for (r in u) "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];

      if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) void 0 === f[r] && (f[r] = l.defaultProps[r]);
      return v$1(l, f, t, o, null);
    }

    function v$1(n, i, t, o, r) {
      var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u$1 : r
      };
      return null == r && null != l$1.vnode && l$1.vnode(f), f;
    }

    function p$1(n) {
      return n.children;
    }

    function d$1(n, l) {
      this.props = n, this.context = l;
    }

    function _$2(n, l) {
      if (null == l) return n.__ ? _$2(n.__, n.__.__k.indexOf(n) + 1) : null;

      for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;

      return "function" == typeof n.type ? _$2(n) : null;
    }

    function k$1(n) {
      var l, u;

      if (null != (n = n.__) && null != n.__c) {
        for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
          n.__e = n.__c.base = u.__e;
          break;
        }

        return k$1(n);
      }
    }

    function b(n) {
      (!n.__d && (n.__d = !0) && t.push(n) && !g$2.__r++ || o$2 !== l$1.debounceRendering) && ((o$2 = l$1.debounceRendering) || setTimeout)(g$2);
    }

    function g$2() {
      for (var n; g$2.__r = t.length;) n = t.sort(function (n, l) {
        return n.__v.__b - l.__v.__b;
      }), t = [], n.some(function (n) {
        var l, u, i, t, o, r;
        n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = s$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? _$2(t) : o, t.__h), z$2(u, t), t.__e != o && k$1(t)));
      });
    }

    function w$1(n, l, u, i, t, o, r, c, s, a) {
      var h,
          y,
          d,
          k,
          b,
          g,
          w,
          x = i && i.__k || e$1,
          C = x.length;

      for (u.__k = [], h = 0; h < l.length; h++) if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? v$1(null, k, null, null, k) : Array.isArray(k) ? v$1(p$1, {
        children: k
      }, null, null, null) : k.__b > 0 ? v$1(k.type, k.props, k.key, k.ref ? k.ref : null, k.__v) : k)) {
        if (k.__ = u, k.__b = u.__b + 1, null === (d = x[h]) || d && k.key == d.key && k.type === d.type) x[h] = void 0;else for (y = 0; y < C; y++) {
          if ((d = x[y]) && k.key == d.key && k.type === d.type) {
            x[y] = void 0;
            break;
          }

          d = null;
        }
        j$2(n, k, d = d || f$1, t, o, r, c, s, a), b = k.__e, (y = k.ref) && d.ref != y && (w || (w = []), d.ref && w.push(d.ref, null, k), w.push(y, k.__c || b, k)), null != b ? (null == g && (g = b), "function" == typeof k.type && k.__k === d.__k ? k.__d = s = m$1(k, s, n) : s = A$1(n, k, d, x, b, s), "function" == typeof u.type && (u.__d = s)) : s && d.__e == s && s.parentNode != n && (s = _$2(d));
      }

      for (u.__e = g, h = C; h--;) null != x[h] && ("function" == typeof u.type && null != x[h].__e && x[h].__e == u.__d && (u.__d = _$2(i, h + 1)), N$1(x[h], x[h]));

      if (w) for (h = 0; h < w.length; h++) M$2(w[h], w[++h], w[++h]);
    }

    function m$1(n, l, u) {
      for (var i, t = n.__k, o = 0; t && o < t.length; o++) (i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? m$1(i, l, u) : A$1(u, i, i, t, i.__e, l));

      return l;
    }

    function x$2(n, l) {
      return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
        x$2(n, l);
      }) : l.push(n)), l;
    }

    function A$1(n, l, u, i, t, o) {
      var r, f, e;
      if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
        for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) if (f == t) break n;

        n.insertBefore(t, o), r = o;
      }
      return void 0 !== r ? r : t.nextSibling;
    }

    function C$2(n, l, u, i, t) {
      var o;

      for (o in u) "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);

      for (o in l) t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
    }

    function $$1(n, l, u) {
      "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || c$1.test(l) ? u : u + "px";
    }

    function H$1(n, l, u, i, t) {
      var o;

      n: if ("style" === l) {
        if ("string" == typeof u) n.style.cssText = u;else {
          if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || $$1(n.style, l, "");
          if (u) for (l in u) i && u[l] === i[l] || $$1(n.style, l, u[l]);
        }
      } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$2 : I$1, o) : n.removeEventListener(l, o ? T$2 : I$1, o);else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
          n[l] = null == u ? "" : u;
          break n;
        } catch (n) {}
        "function" == typeof u || (null != u && (!1 !== u || "a" === l[0] && "r" === l[1]) ? n.setAttribute(l, u) : n.removeAttribute(l));
      }
    }

    function I$1(n) {
      this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
    }

    function T$2(n) {
      this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
    }

    function j$2(n, u, i, t, o, r, f, e, c) {
      var a,
          h,
          v,
          y,
          _,
          k,
          b,
          g,
          m,
          x,
          A,
          C,
          $,
          H = u.type;

      if (void 0 !== u.constructor) return null;
      null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (a = l$1.__b) && a(u);

      try {
        n: if ("function" == typeof H) {
          if (g = u.props, m = (a = H.contextType) && t[a.__c], x = a ? m ? m.props.value : a.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in H && H.prototype.render ? u.__c = h = new H(g, x) : (u.__c = h = new d$1(g, x), h.constructor = H, h.render = O$1), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != H.getDerivedStateFromProps && (h.__s == h.state && (h.__s = s$1({}, h.__s)), s$1(h.__s, H.getDerivedStateFromProps(g, h.__s))), y = h.props, _ = h.state, v) null == H.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
            if (null == H.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
              h.props = g, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
                n && (n.__ = u);
              }), h.__h.length && f.push(h);
              break n;
            }

            null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
              h.componentDidUpdate(y, _, k);
            });
          }
          if (h.context = x, h.props = g, h.__v = u, h.__P = n, A = l$1.__r, C = 0, "prototype" in H && H.prototype.render) h.state = h.__s, h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context);else do {
            h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
          } while (h.__d && ++C < 25);
          h.state = h.__s, null != h.getChildContext && (t = s$1(s$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, _)), $ = null != a && a.type === p$1 && null == a.key ? a.props.children : a, w$1(n, Array.isArray($) ? $ : [$], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);

        (a = l$1.diffed) && a(u);
      } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
      }
    }

    function z$2(n, u) {
      l$1.__c && l$1.__c(u, n), n.some(function (u) {
        try {
          n = u.__h, u.__h = [], n.some(function (n) {
            n.call(u);
          });
        } catch (n) {
          l$1.__e(n, u.__v);
        }
      });
    }

    function L$1(l, u, i, t, o, r, e, c) {
      var s,
          h,
          v,
          y = i.props,
          p = u.props,
          d = u.type,
          k = 0;
      if ("svg" === d && (o = !0), null != r) for (; k < r.length; k++) if ((s = r[k]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
        l = s, r[k] = null;
        break;
      }

      if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
      }

      if (null === d) y === p || c && l.data === p || (l.data = p);else {
        if (r = r && n.call(l.childNodes), h = (y = i.props || f$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
          if (null != r) for (y = {}, k = 0; k < l.attributes.length; k++) y[l.attributes[k].name] = l.attributes[k].value;
          (v || h) && (v && (h && v.__html == h.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }

        if (C$2(l, p, y, o, c), v) u.__k = [];else if (k = u.props.children, w$1(l, Array.isArray(k) ? k : [k], u, i, t, o && "foreignObject" !== d, r, e, r ? r[0] : i.__k && _$2(i, 0), c), null != r) for (k = r.length; k--;) null != r[k] && a$1(r[k]);
        c || ("value" in p && void 0 !== (k = p.value) && (k !== l.value || "progress" === d && !k || "option" === d && k !== y.value) && H$1(l, "value", k, y.value, !1), "checked" in p && void 0 !== (k = p.checked) && k !== l.checked && H$1(l, "checked", k, y.checked, !1));
      }
      return l;
    }

    function M$2(n, u, i) {
      try {
        "function" == typeof n ? n(u) : n.current = u;
      } catch (n) {
        l$1.__e(n, i);
      }
    }

    function N$1(n, u, i) {
      var t, o;

      if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$2(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
          t.componentWillUnmount();
        } catch (n) {
          l$1.__e(n, u);
        }
        t.base = t.__P = null, n.__c = void 0;
      }

      if (t = n.__k) for (o = 0; o < t.length; o++) t[o] && N$1(t[o], u, "function" != typeof n.type);
      i || null == n.__e || a$1(n.__e), n.__ = n.__e = n.__d = void 0;
    }

    function O$1(n, l, u) {
      return this.constructor(n, u);
    }

    function P$1(u, i, t) {
      var o, r, e;
      l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, e = [], j$2(i, u = (!o && t || i).__k = h$1(p$1, null, [u]), r || f$1, f$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, e, !o && t ? t : r ? r.__e : i.firstChild, o), z$2(e, u);
    }

    function B$2(n, l) {
      var u = {
        __c: l = "__cC" + r$2++,
        __: n,
        Consumer: function (n, l) {
          return n.children(l);
        },
        Provider: function (n) {
          var u, i;
          return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
            return i;
          }, this.shouldComponentUpdate = function (n) {
            this.props.value !== n.value && u.some(b);
          }, this.sub = function (n) {
            u.push(n);
            var l = n.componentWillUnmount;

            n.componentWillUnmount = function () {
              u.splice(u.indexOf(n), 1), l && l.call(n);
            };
          }), n.children;
        }
      };
      return u.Provider.__ = u.Consumer.contextType = u;
    }

    n = e$1.slice, l$1 = {
      __e: function (n, l, u, i) {
        for (var t, o, r; l = l.__;) if ((t = l.__c) && !t.__) try {
          if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), r) return t.__E = t;
        } catch (l) {
          n = l;
        }

        throw n;
      }
    }, u$1 = 0, d$1.prototype.setState = function (n, l) {
      var u;
      u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s$1({}, this.state), "function" == typeof n && (n = n(s$1({}, u), this.props)), n && s$1(u, n), null != n && this.__v && (l && this.__h.push(l), b(this));
    }, d$1.prototype.forceUpdate = function (n) {
      this.__v && (this.__e = !0, n && this.__h.push(n), b(this));
    }, d$1.prototype.render = p$1, t = [], g$2.__r = 0, r$2 = 0;

    var _$1 = 0;

    function o$1(o, e, n, t, f) {
      var l,
          s,
          u = {};

      for (s in e) "ref" == s ? l = e[s] : u[s] = e[s];

      var a = {
        type: o,
        props: u,
        key: n,
        ref: l,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: --_$1,
        __source: f,
        __self: t
      };
      if ("function" == typeof o && (l = o.defaultProps)) for (s in l) void 0 === u[s] && (u[s] = l[s]);
      return l$1.vnode && l$1.vnode(a), a;
    }

    var r$1,
        u,
        i,
        o,
        f = 0,
        c = [],
        e = [],
        a = l$1.__b,
        v = l$1.__r,
        l = l$1.diffed,
        m = l$1.__c,
        d = l$1.unmount;

    function p(t, r) {
      l$1.__h && l$1.__h(u, t, f || r), f = 0;
      var i = u.__H || (u.__H = {
        __: [],
        __h: []
      });
      return t >= i.__.length && i.__.push({
        __V: e
      }), i.__[t];
    }

    function y(n) {
      return f = 1, h(C$1, n);
    }

    function h(n, t, i) {
      var o = p(r$1++, 2);

      if (o.t = n, !o.__c && (o.__ = [i ? i(t) : C$1(void 0, t), function (n) {
        var t = o.__N ? o.__N[0] : o.__[0],
            r = o.t(t, n);
        t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
      }], o.__c = u, !u.u)) {
        u.u = !0;
        var f = u.shouldComponentUpdate;

        u.shouldComponentUpdate = function (n, t, r) {
          if (!o.__c.__H) return !0;

          var u = o.__c.__H.__.filter(function (n) {
            return n.__c;
          });

          if (u.every(function (n) {
            return !n.__N;
          })) return !f || f.call(this, n, t, r);
          var i = !1;
          return u.forEach(function (n) {
            if (n.__N) {
              var t = n.__[0];
              n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
            }
          }), !!i && (!f || f.call(this, n, t, r));
        };
      }

      return o.__N || o.__;
    }

    function s(t, i) {
      var o = p(r$1++, 3);
      !l$1.__s && B$1(o.__H, i) && (o.__ = t, o.i = i, u.__H.__h.push(o));
    }

    function _(t, i) {
      var o = p(r$1++, 4);
      !l$1.__s && B$1(o.__H, i) && (o.__ = t, o.i = i, u.__h.push(o));
    }

    function A(n) {
      return f = 5, T$1(function () {
        return {
          current: n
        };
      }, []);
    }

    function T$1(n, t) {
      var u = p(r$1++, 7);
      return B$1(u.__H, t) ? (u.__V = n(), u.i = t, u.__h = n, u.__V) : u.__;
    }

    function q$1(n, t) {
      return f = 8, T$1(function () {
        return n;
      }, t);
    }

    function x$1(n) {
      var t = u.context[n.__c],
          i = p(r$1++, 9);
      return i.c = n, t ? (null == i.__ && (i.__ = !0, t.sub(u)), t.props.value) : n.__;
    }

    function g$1() {
      for (var t; t = c.shift();) if (t.__P && t.__H) try {
        t.__H.__h.forEach(w), t.__H.__h.forEach(z$1), t.__H.__h = [];
      } catch (r) {
        t.__H.__h = [], l$1.__e(r, t.__v);
      }
    }

    l$1.__b = function (n) {
      "function" != typeof n.type || n.o || n.type === p$1 ? n.o || (n.o = n.__ && n.__.o ? n.__.o : "") : n.o = (n.__ && n.__.o ? n.__.o : "") + (n.__ && n.__.__k ? n.__.__k.indexOf(n) : 0), u = null, a && a(n);
    }, l$1.__r = function (n) {
      v && v(n), r$1 = 0;
      var t = (u = n.__c).__H;
      t && (i === u ? (t.__h = [], u.__h = [], t.__.forEach(function (n) {
        n.__N && (n.__ = n.__N), n.__V = e, n.__N = n.i = void 0;
      })) : (t.__h.forEach(w), t.__h.forEach(z$1), t.__h = [])), i = u;
    }, l$1.diffed = function (t) {
      l && l(t);
      var r = t.__c;
      r && r.__H && (r.__H.__h.length && (1 !== c.push(r) && o === l$1.requestAnimationFrame || ((o = l$1.requestAnimationFrame) || k)(g$1)), r.__H.__.forEach(function (n) {
        n.i && (n.__H = n.i), n.__V !== e && (n.__ = n.__V), n.i = void 0, n.__V = e;
      })), i = u = null;
    }, l$1.__c = function (t, r) {
      r.some(function (t) {
        try {
          t.__h.forEach(w), t.__h = t.__h.filter(function (n) {
            return !n.__ || z$1(n);
          });
        } catch (u) {
          r.some(function (n) {
            n.__h && (n.__h = []);
          }), r = [], l$1.__e(u, t.__v);
        }
      }), m && m(t, r);
    }, l$1.unmount = function (t) {
      d && d(t);
      var r,
          u = t.__c;
      u && u.__H && (u.__H.__.forEach(function (n) {
        try {
          w(n);
        } catch (n) {
          r = n;
        }
      }), u.__H = void 0, r && l$1.__e(r, u.__v));
    };
    var j$1 = "function" == typeof requestAnimationFrame;

    function k(n) {
      var t,
          r = function () {
        clearTimeout(u), j$1 && cancelAnimationFrame(t), setTimeout(n);
      },
          u = setTimeout(r, 100);

      j$1 && (t = requestAnimationFrame(r));
    }

    function w(n) {
      var t = u,
          r = n.__c;
      "function" == typeof r && (n.__c = void 0, r()), u = t;
    }

    function z$1(n) {
      var t = u;
      n.__c = n.__(), u = t;
    }

    function B$1(n, t) {
      return !n || n.length !== t.length || t.some(function (t, r) {
        return t !== n[r];
      });
    }

    function C$1(n, t) {
      return "function" == typeof t ? t(n) : t;
    }

    const EventDetail = Symbol("event-detail");
    function enhanceEvent(e, detail) {
      const event = e;
      event[EventDetail] = detail;
      return event;
    }
    const alreadyWarned = new Set();
    function warnOnOverwrite(componentName, propName, propValue, newValue) {
      const key = `${componentName};${propName}`;

      if (propValue != null) {
        if (!alreadyWarned.has(key)) {
          alreadyWarned.add(key);
          console.warn(`The ${propName} attribute on ${componentName} was given a value of ${propValue} but is being overwritten to ${newValue} for conformance. Consider removing it before passing those props to ${componentName}.`);
        }
      }

      return newValue;
    }
    function debugLog(who) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      console.debug(who + ":", ...args);
    }

    const HeadingLevelContext = B$2(0);
    function Heading(_ref) {
      let {
        children,
        heading,
        ...props
      } = _ref;
      const headingLevelBeforeUs = x$1(HeadingLevelContext);
      const newHeadingLevel = headingLevelBeforeUs + 1;
      let tag;

      if (newHeadingLevel <= 6) {
        tag = `h${newHeadingLevel}`;
      } else {
        tag = 'div';
        props["aria-level"] = warnOnOverwrite("Heading", "aria-level", props["aria-level"], `${newHeadingLevel}`);
      }

      return o$1(p$1, {
        children: o$1(HeadingReset, {
          newLevel: headingLevelBeforeUs + 1,
          children: [h$1(tag, props, heading), children]
        })
      });
    }
    function HeadingReset(_ref2) {
      let {
        newLevel,
        children
      } = _ref2;
      return o$1(HeadingLevelContext.Provider, {
        value: newLevel,
        children: children
      });
    }

    /**
     * Wrap the native `useEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     * @param impl You can choose whether to use `useEffect` or `useLayoutEffect` by
     * passing one of them as this argument. By default, it's `useEffect`.
     */

    function useEffect(effect, inputs) {
      let impl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : s;
      const prevInputs = A(undefined);

      const effect2 = () => {
        const changes = [];

        if (inputs && prevInputs.current) {
          for (let i = 0; i < Math.max(prevInputs.current.length, inputs.length); ++i) {
            if (prevInputs.current[i] != inputs[i]) changes[i] = {
              from: prevInputs.current[i],
              to: inputs[i]
            };
          }
        }

        const ret = effect(prevInputs.current, changes);
        prevInputs.current = inputs;
        return ret;
      };

      impl(effect2, inputs);
    }

    /**
     * Debug hook.
     *
     * Given a value or set of values, emits a console error if any of them change from one render to the next.
     *
     * Eventually, when useEvent lands, we hopefully won't need this.
     */

    function useEnsureStability(parentHookName) {
      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }

      useHelper(values.length, 0);
      values.forEach(useHelper);
      return;

      function useHelper(value, index) {
        // Make sure that the provided functions are perfectly stable across renders
        const helperToEnsureStability = A(value);
        const shownError = A(false);

        if (helperToEnsureStability.current != value) {
          if (!shownError.current) {
            /* eslint-disable no-debugger */
            debugger;
            console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
            shownError.current = true;
          }
        }
      }
    }
    function debounceRendering(f) {
      var _options$debounceRend;

      ((_options$debounceRend = l$1.debounceRendering) !== null && _options$debounceRend !== void 0 ? _options$debounceRend : setTimeout)(f);
    }
    /**
     * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
     *
     * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
     *
     * To summarize, it's like a `useState`-`useEffect` mashup:
     *
     * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
     * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
     * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
     * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
     *
     * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
     *
     * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @returns
     */

    function usePassiveState(onChange, getInitialValue) {
      const key = A(Math.random().toString());
      const valueRef = A(Unset$1);
      const warningRef = A(false);
      const cleanupCallbackRef = A(undefined); // Make sure that the provided functions are perfectly stable across renders

      useEnsureStability("usePassiveState", onChange, getInitialValue); // Shared between "dependency changed" and "component unmounted".

      const onShouldCleanUp = q$1(() => {
        const cleanupCallback = cleanupCallbackRef.current;
        if (cleanupCallback) cleanupCallback();
      }, []); // There are a couple places where we'd like to use our initial
      // value in place of having no value at all yet.
      // This is the shared code for that, used on mount and whenever
      // getValue is called.

      const tryEnsureValue = q$1(() => {
        if (valueRef.current === Unset$1 && getInitialValue != undefined) {
          try {
            var _onChange;

            const initialValue = getInitialValue();
            valueRef.current = initialValue;
            cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
          } catch (ex) {// Exceptions are intentional to allow bailout (without exposing the Unset symbol)
          }
        }
      }, [
        /* getInitialValue and onChange intentionally omitted */
      ]);
      const getValue = q$1(() => {
        if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component."); // The first time we call getValue, if we haven't been given a value yet,
        // (and we were given an initial value to use)
        // return the initial value instead of nothing.

        if (valueRef.current === Unset$1) tryEnsureValue();
        return valueRef.current === Unset$1 ? undefined : valueRef.current;
      }, []);
      _(() => {
        // Make sure we've run our effect at least once on mount.
        // (If we have an initial value, of course)
        tryEnsureValue();
      }, []); // The actual code the user calls to (possibly) run a new effect.

      const prevDep = A(Unset$1);
      const setValue = q$1(arg => {
        console.log(key.current); // Regardless of anything else, figure out what our next value is about to be.

        const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg;

        if (prevDep.current === Unset$1) {
          // This is the first request to change this value.
          // Evaluate the request immediately, then queue up the onChange function
          // Save our current value so that we can compare against it later
          // (if we flip back to this state, then we won't send the onChange function)
          prevDep.current = valueRef.current; // Schedule the actual check and invocation of onChange later to let effects settle

          debounceRendering(() => {
            const nextDep = valueRef.current;

            if (prevDep.current != valueRef.current) {
              warningRef.current = true;

              try {
                var _onChange2;

                // Call any registered cleanup function
                onShouldCleanUp();
                cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep.current === Unset$1 ? undefined : prevDep.current)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
                valueRef.current = nextDep;
              } finally {
                // Allow the user to normally call getValue again
                warningRef.current = false;
              }
            } // We've finished with everything, so mark us as being on a clean slate again.


            prevDep.current = Unset$1;
          });
        } // Update the value immediately.
        // This will be checked against prevDep to see if we should actually call onChange


        valueRef.current = nextValue;
      }, []);
      return [getValue, setValue];
    }
    const Unset$1 = Symbol(); // Easy constants for getInitialValue

    function returnTrue() {
      return true;
    }
    function returnFalse$1() {
      return false;
    }
    function returnNull() {
      return null;
    }

    const activeElementUpdaters = new Map();
    const lastActiveElementUpdaters = new Map();
    const windowFocusedUpdaters = new Map();
    const windowsFocusedUpdaters = new Map();
    const microtasks = new Map(); // The focusin and focusout events often fire syncronously in the middle of running code.
    // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
    // For the purpose of improving stability, we debounce all focus events to the next microtask.

    function forEachUpdater(window, map, value) {
      const updatersKey = map.get(window);

      if (updatersKey) {
        if (!microtasks.has(updatersKey)) {
          debounceRendering(() => {
            const updatersKey = map.get(window);
            const value = microtasks.get(updatersKey);
            microtasks.delete(updatersKey);

            if (updatersKey) {
              for (const updater of updatersKey) {
                updater === null || updater === void 0 ? void 0 : updater(value);
              }
            }
          });
        }

        microtasks.set(updatersKey, value);
      }
    }

    function focusout(e) {
      const window = e.target.ownerDocument.defaultView;

      if (e.relatedTarget == null) {
        forEachUpdater(window, activeElementUpdaters, null);
      }
    }

    function focusin(e) {
      const window = e.target.ownerDocument.defaultView;
      const currentlyFocusedElement = e.target;
      forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
      forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
    }

    function windowFocus(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, true);
      forEachUpdater(window, windowFocusedUpdaters, true);
    }

    function windowBlur(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, false);
      forEachUpdater(window, windowFocusedUpdaters, false);
    }
    /**
     * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
     * * `getActiveElement()`
     * * `getLastActiveElement()`
     * * `getWindowFocused()`
     *
     * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
     *
     * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
     *
     * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
     */


    function useActiveElement(_ref) {
      let {
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        getDocument,
        getWindow
      } = _ref;
      useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, getDocument, getWindow);
      useEffect(() => {
        var _getWindow, _activeElementUpdater, _activeElementUpdater2, _activeElementUpdater3, _lastActiveElementUpd, _windowFocusedUpdater;

        const document = getDocument();
        const window = (_getWindow = getWindow === null || getWindow === void 0 ? void 0 : getWindow(document)) !== null && _getWindow !== void 0 ? _getWindow : document === null || document === void 0 ? void 0 : document.defaultView;

        if (((_activeElementUpdater = (_activeElementUpdater2 = activeElementUpdaters.get(window)) === null || _activeElementUpdater2 === void 0 ? void 0 : _activeElementUpdater2.size) !== null && _activeElementUpdater !== void 0 ? _activeElementUpdater : 0) === 0) {
          document === null || document === void 0 ? void 0 : document.addEventListener("focusin", focusin, {
            passive: true
          });
          document === null || document === void 0 ? void 0 : document.addEventListener("focusout", focusout, {
            passive: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("focus", windowFocus, {
            passive: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("blur", windowBlur, {
            passive: true
          });
        } // Add them even if they're undefined to more easily
        // manage the ">0 means don't add handlers" logic.


        const localActiveElementUpdaters = (_activeElementUpdater3 = activeElementUpdaters.get(window)) !== null && _activeElementUpdater3 !== void 0 ? _activeElementUpdater3 : new Set();
        const localLastActiveElementUpdaters = (_lastActiveElementUpd = lastActiveElementUpdaters.get(window)) !== null && _lastActiveElementUpd !== void 0 ? _lastActiveElementUpd : new Set();
        const localWindowFocusedUpdaters = (_windowFocusedUpdater = windowFocusedUpdaters.get(window)) !== null && _windowFocusedUpdater !== void 0 ? _windowFocusedUpdater : new Set();
        localActiveElementUpdaters.add(setActiveElement);
        localLastActiveElementUpdaters.add(setLastActiveElement);
        localWindowFocusedUpdaters.add(setWindowFocused);
        activeElementUpdaters.set(window, localActiveElementUpdaters);
        lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
        windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
        return () => {
          activeElementUpdaters.get(window).delete(setActiveElement);
          lastActiveElementUpdaters.get(window).delete(setLastActiveElement);
          windowFocusedUpdaters.get(window).delete(setWindowFocused);

          if (activeElementUpdaters.size === 0) {
            document === null || document === void 0 ? void 0 : document.removeEventListener("focusin", focusin);
            document === null || document === void 0 ? void 0 : document.removeEventListener("focusout", focusout);
            window === null || window === void 0 ? void 0 : window.removeEventListener("focus", windowFocus);
            window === null || window === void 0 ? void 0 : window.removeEventListener("blur", windowBlur);
          }
        };
      }, []);
      const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
      const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
      const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
      return {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }

    const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";

    function base64(value) {
      return Table[value];
    }

    function random6Bits() {
      return Math.floor(Math.random() * 0b1000000);
    }

    function random64Bits() {
      return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     *
     *
     * (This is here, in this particular file, to avoid circular dependencies
     * without also making a utilities file.
     * Once we can remove this hook, we can put this function back with useRandomId)
     */


    function generateRandomId(prefix) {
      return `${prefix !== null && prefix !== void 0 ? prefix : "id-"}${random64Bits().map(n => base64(n)).join("")}`;
    }
    const previousInputs = new Map();
    const toRun = new Map(); // TODO: Whether this goes in options.diffed or options._commit
    // is a post-suspense question.
    // Right now, using options._commit has the problem of running
    // *after* refs are applied, but we need to come before even that
    // so `ref={someStableFunction}` works.
    // 
    // Also it's private.
    //
    // ...
    // Well, useEvent or whatever is finally, finally 4 years later finally here
    // which is cool and means we won't need this at all soon.
    // So for now we'll stick with diff to prevent any weirdness with
    // commit being private and all.

    const commitName = "diffed";
    const originalCommit = l$1[commitName];

    const newCommit = function () {
      for (const [id, effectInfo] of toRun) {
        const oldInputs = previousInputs.get(id);

        if (argsChanged(oldInputs, effectInfo.inputs)) {
          var _effectInfo$cleanup;

          (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
          effectInfo.cleanup = effectInfo.effect();
          previousInputs.set(id, effectInfo.inputs);
        }
      }

      toRun.clear();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
    };

    l$1[commitName] = newCommit;
    /**
     * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
     *
     * Every render, we send the arguments to be evaluated after diffing has completed,
     * which happens before.
     *
     * @param effect
     * @param inputs
     */

    function useBeforeLayoutEffect(effect, inputs) {
      /*(() => {
          const cleanup = useRef<void | (() => void) | null>(null);
          const prevArgsRef = useRef<Inputs>(null!);
          if (argsChanged(inputs, prevArgsRef.current)) {
              prevArgsRef.current = inputs!;
              if (cleanup.current)
                  cleanup.current();
              cleanup.current = effect();
          }
      })();*/
      const [id] = y(() => generateRandomId());
      toRun.set(id, {
        effect,
        inputs,
        cleanup: null
      });
      s(() => {
        return () => {
          toRun.delete(id);
          previousInputs.delete(id);
        };
      }, [id]);
    }

    function argsChanged(oldArgs, newArgs) {
      return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
    }

    const Unset = Symbol("unset");
    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * This uses `options.diffed` in order to run before everything, even
     * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
     *
     * @param value
     * @returns
     */

    function useStableGetter(value) {
      const ref = A(Unset);
      useBeforeLayoutEffect(() => {
        ref.current = value;
      }, [value]);
      return q$1(() => {
        if (ref.current === Unset) {
          throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
        }

        return ref.current;
      }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * Do not use during the render phase!  `useLayoutEffect` is fine though.
     */

    function useStableCallback(fn) {
      const currentCallbackGetter = useStableGetter(fn);
      return q$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []);
    }

    B$2(null);

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */

    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();

    /** Built-in value references. */

    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */

    var objectProto$5 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var nativeObjectToString$1 = objectProto$5.toString;
    /** Built-in value references. */

    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */

    function getRawTag(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);

      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }

      return result;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var nativeObjectToString = objectProto$4.toString;
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */

    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /** `Object#toString` result references. */

    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';
    /** Built-in value references. */

    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */

    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }

      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */

    function useState(initialState) {
      // We keep both, but overrride the `setState` functionality
      const [state, setStateP] = y(initialState);
      const ref = A(state); // Hijack the normal setter function 
      // to also set our ref to the new value

      const setState = q$1(value => {
        if (typeof value === "function") {
          const callback = value;
          setStateP(prevValue => {
            const nextValue = callback(prevValue);
            ref.current = nextValue;
            return nextValue;
          });
        } else {
          ref.current = value;
          setStateP(value);
        }
      }, []);

      const getState = () => {
        return ref.current;
      };

      console.assert(ref.current === state || typeof state === "number" && isNaN(state));
      return [state, setState, getState];
    }

    /**
     * Wrap the native `useLayoutEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     */

    function useLayoutEffect(effect, inputs) {
      return useEffect(effect, inputs, _);
    }

    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is designed to be lightweight, in that the parent keeps no state
     * and runs no effects.  Each child *does* run an effect, but with no state
     * changes unless you explicitly request them.
     *
     *
     */


    function useManagedChildren(parentParameters) {
      const {
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters;
      useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
      const getHighestIndex = q$1(() => {
        return managedChildrenArray.current.highestIndex;
      }, []); // All the information we have about our children is stored in this **stable** array.
      // Any mutations to this array **DO NOT** trigger any sort of a re-render.

      const managedChildrenArray = A({
        arr: [],
        rec: {},
        highestIndex: 0,
        lowestIndex: 0
      }); // For indirect access to each child
      // Compare getManagedChildInfo
      // TODO: The primary use for this is flaggable closest fits
      // which need to search all children for that closest fit.
      // It would be nice if there was something better for that.

      const forEachChild = q$1(f => {
        for (const child of managedChildrenArray.current.arr) {
          f(child);
        }

        for (const field in managedChildrenArray.current.rec) {
          const child = managedChildrenArray.current.rec[field];
          if (child) f(child);
        }
      }, []); // Retrieves the information associated with the child with the given index.
      // `undefined` if not child there, or it's unmounted.

      const getManagedChildInfo = q$1(index => {
        if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
      }, []); // tl;dr this is a way to have run useLayoutEffect once after all N children
      // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
      // ourselves because of having a `childCount` state or anything similar.
      //
      // When the child count ref updates, we want the parent to also run an effect
      // to maybe do something with all these children that just mounted.
      // The easiest way would be useEffect(..., [childCount]) but
      // that would require us having a childCount state, then calling
      // setChildCount and re-rendering every time children mount
      // (only one re-render at a time unless children are staggered, but still)
      // 
      // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
      // to emulate running ULE on the parent. Only the first child will actually queue
      // the microtask (by checking hasRemoteULE first) so that the "effect" only
      // runs once. When it's done, hasRemoteULE is reset so it can run again if
      // more children mount/unmount.

      const hasRemoteULEChildMounted = A(null);
      const remoteULEChildChangedCausers = A(new Set());
      const remoteULEChildChanged = q$1(index => {
        if (remoteULEChildChangedCausers.current.size == 0) {
          debounceRendering(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }

        remoteULEChildChangedCausers.current.add(index);
        return () => {};
      }, [
        /* Must remain stable */
      ]);
      const remoteULEChildMounted = q$1((index, mounted) => {
        if (!hasRemoteULEChildMounted.current) {
          hasRemoteULEChildMounted.current = {
            mounts: new Set(),
            unmounts: new Set()
          };
          debounceRendering(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            hasRemoteULEChildMounted.current = null;
          });
        }

        if (mounted) {
          managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
        } else {
          if (typeof index == "number") {
            delete managedChildrenArray.current.arr[index];
            let shave = 0;

            while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) ++shave;

            managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - 1 - shave, shave);
          } else delete managedChildrenArray.current.rec[index];
        }

        hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
      }, [
        /* Must remain stable */
      ]);
      const useManagedChild = q$1(_ref => {
        let {
          managedChild: info
        } = _ref;
        // Any time our child props change, make that information available
        // the parent if they need it.
        // The parent can listen for all updates and only act on the ones it cares about,
        // and multiple children updating in the same tick will all be sent at once.
        useLayoutEffect(() => {
          var _info$flags, _info$flags2;

          // Insert this information in-place
          if (typeof info.index == "number") managedChildrenArray.current.arr[info.index] = {
            index: info.index,
            flags: (_info$flags = info.flags) !== null && _info$flags !== void 0 ? _info$flags : {},
            subInfo: info.subInfo
          };else managedChildrenArray.current.rec[info.index] = {
            index: info.index,
            flags: (_info$flags2 = info.flags) !== null && _info$flags2 !== void 0 ? _info$flags2 : {},
            subInfo: info.subInfo
          };
          return remoteULEChildChanged(info.index);
        }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
        // When we mount, notify the parent via queueMicrotask
        // (every child does this, so everything's coordinated to only queue a single microtask per tick)
        // Do the same on unmount.
        // Note: It's important that this comes AFTER remoteULEChildChanged
        // so that remoteULEChildMounted has access to all the info on mount.

        useLayoutEffect(() => {
          remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, true);
          return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, false);
        }, [info.index]);
      }, [
        /* Must remain stable */
      ]);
      const managedChildren = A({ ...{
          _: managedChildrenArray.current
        },
        forEach: forEachChild,
        getAt: getManagedChildInfo,
        getHighestIndex: getHighestIndex,
        arraySlice: () => {
          return managedChildrenArray.current.arr.slice();
        }
      });
      return {
        useManagedChild,
        managedChildren: {
          children: managedChildren.current
        }
      };
    }
    /**
     * An extension to useManagedChildren that handles the following common case:
     * 1. You have a bunch of children
     * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
     * 3. The parent has control over who is "selected" via a numerical index.
     *
     * This hook allows for much easier control over selection management.
     *
     * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
     * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
     *
     * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
     *
     *
     * @param param0
     * @returns
     */

    function useChildrenFlag(_ref2) {
      let {
        children,
        initialIndex,
        closestFit,
        onIndexChange,
        key
      } = _ref2;
      useEnsureStability("useChildrenFlag", onIndexChange, key);
      const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange, q$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, []));
      const [getRequestedIndex, setRequestedIndex] = usePassiveState(null, q$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, [])); //    const getFitNullToZero = useStableGetter(fitNullToZero);
      // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)

      const getClosestFit = q$1(requestedIndex => {
        let closestDistance = Infinity;
        let closestIndex = null;
        children.forEach(child => {
          var _child$flags, _child$flags$key;

          if ((_child$flags = child.flags) !== null && _child$flags !== void 0 && (_child$flags$key = _child$flags[key]) !== null && _child$flags$key !== void 0 && _child$flags$key.isValid()) {
            const newDistance = Math.abs(child.index - requestedIndex);

            if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
              closestDistance = newDistance;
              closestIndex = child.index;
            }
          }
        });
        return closestIndex;
      }, [
        /* Must remain stable! */
      ]); // Any time a child mounts/unmounts, we need to double-check to see if that affects 
      // the "currently selected" (or whatever) index.  The two cases we're looking for:
      // 1. The currently selected child unmounted
      // 2. A child mounted, and it mounts with the index we're looking for

      const reevaluateClosestFit = useStableCallback(() => {
        var _currentChild$flags, _currentChild$flags$k;

        const requestedIndex = getRequestedIndex();
        const currentIndex = getCurrentIndex();
        const currentChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !((_currentChild$flags = currentChild.flags) !== null && _currentChild$flags !== void 0 && (_currentChild$flags$k = _currentChild$flags[key]) !== null && _currentChild$flags$k !== void 0 && _currentChild$flags$k.isValid()))) {
          var _currentChild$flags2;

          currentChild === null || currentChild === void 0 ? void 0 : (_currentChild$flags2 = currentChild.flags) === null || _currentChild$flags2 === void 0 ? void 0 : _currentChild$flags2[key].set(false);
          const closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex);

          if (closestFitIndex != null) {
            var _closestFitChild$flag;

            const closestFitChild = children.getAt(closestFitIndex);
            console.assert(closestFitChild != null, "Internal logic???");
            (_closestFitChild$flag = closestFitChild.flags) === null || _closestFitChild$flag === void 0 ? void 0 : _closestFitChild$flag[key].set(true);
          }
        }
      });
      const changeIndex = q$1(arg => {
        const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg; //if (requestedIndex == null && getFitNullToZero())
        //    requestedIndex = 0;

        setRequestedIndex(requestedIndex);
        const currentIndex = getCurrentIndex();
        if (currentIndex == requestedIndex) return requestedIndex;
        let newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
        const oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex == null) {
          var _oldMatchingChild$fla;

          // Easy case
          setCurrentIndex(null);
          oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla = oldMatchingChild.flags) === null || _oldMatchingChild$fla === void 0 ? void 0 : _oldMatchingChild$fla[key].set(false);
          return null;
        } else {
          var _newMatchingChild$fla;

          if (newMatchingChild && (_newMatchingChild$fla = newMatchingChild.flags) !== null && _newMatchingChild$fla !== void 0 && _newMatchingChild$fla[key].isValid()) {
            var _oldMatchingChild$fla2, _newMatchingChild$fla2;

            setCurrentIndex(requestedIndex);
            oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla2 = oldMatchingChild.flags) === null || _oldMatchingChild$fla2 === void 0 ? void 0 : _oldMatchingChild$fla2[key].set(false);
            (_newMatchingChild$fla2 = newMatchingChild.flags) === null || _newMatchingChild$fla2 === void 0 ? void 0 : _newMatchingChild$fla2[key].set(true);
            return requestedIndex;
          } else {
            const closestFitIndex = getClosestFit(requestedIndex);
            setCurrentIndex(closestFitIndex);

            if (closestFitIndex != null) {
              var _oldMatchingChild$fla3, _newMatchingChild$fla3;

              newMatchingChild = children.getAt(closestFitIndex);
              console.assert(newMatchingChild != null, "Internal logic???");
              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla3 = oldMatchingChild.flags) === null || _oldMatchingChild$fla3 === void 0 ? void 0 : _oldMatchingChild$fla3[key].set(false);
              (_newMatchingChild$fla3 = newMatchingChild.flags) === null || _newMatchingChild$fla3 === void 0 ? void 0 : _newMatchingChild$fla3[key].set(true);
              return closestFitIndex;
            } else {
              var _oldMatchingChild$fla4;

              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla4 = oldMatchingChild.flags) === null || _oldMatchingChild$fla4 === void 0 ? void 0 : _oldMatchingChild$fla4[key].set(false);
              return null;
            }
          }
        }
      }, []);
      useLayoutEffect(() => {
        var _children$getAt, _children$getAt$flags, _children$getAt$flags2;

        if (initialIndex != null) (_children$getAt = children.getAt(initialIndex)) === null || _children$getAt === void 0 ? void 0 : (_children$getAt$flags = _children$getAt.flags) === null || _children$getAt$flags === void 0 ? void 0 : (_children$getAt$flags2 = _children$getAt$flags[key]) === null || _children$getAt$flags2 === void 0 ? void 0 : _children$getAt$flags2.set(true);
      }, []);
      return {
        changeIndex,
        reevaluateClosestFit,
        getCurrentIndex
      };
    }
    /*export type Spread<A extends {}, B extends {}> = Omit<A, keyof B> & B;
    export function spread<A extends {}, B extends {}>(a: A, b: B): Spread<A, B> {
        return {
            ...a,
            ...b
        }
    }*/

    /*
    function test() {
        type C = { foo: "bar" };
        type K = "flag2";

        const { children, useManagedChild } = useManagedChildren<number, C, K>({ managedChildren: { onChildrenMountChange: useStableCallback<OnChildrenMountChange<number>>((mounted, unmounted) => onChildrenMountChange(mounted, unmounted)) } });
        useManagedChild({ managedChild: { index: 0, info: { foo: "bar" }, flags: {  } } });
        const { changeIndex, getCurrentIndex, onChildrenMountChange } = useChildrenFlag<C, K>({ children, initialIndex: 0, key: "flag2" })
    }*/

    function r(e) {
      var t,
          f,
          n = "";
      if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
      return n;
    }

    function clsx() {
      for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);

      return n;
    }

    function getDocument$6(element) {
      var _ref, _ref2, _element$ownerDocumen;

      return (_ref = (_ref2 = (_element$ownerDocumen = element === null || element === void 0 ? void 0 : element.ownerDocument) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : document) !== null && _ref2 !== void 0 ? _ref2 : window.document) !== null && _ref !== void 0 ? _ref : globalThis.document;
    }

    function useMergedChildren(_ref, _ref2) {
      let {
        children: lhs
      } = _ref;
      let {
        children: rhs
      } = _ref2;

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return h$1(p$1, {}, lhs, rhs);
      }
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */

    function useMergedClasses(_ref, _ref2) {
      let {
        class: lhsClass,
        className: lhsClassName
      } = _ref;
      let {
        class: rhsClass,
        className: rhsClassName
      } = _ref2;

      // Note: For the sake of forward compatibility, this function is labelled as
      // a hook, but as it uses no other hooks it technically isn't one.
      if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
        const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
        const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
        const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
        return Array.from(allClasses).join(" ");
      } else {
        return undefined;
      }
    }

    function processRef(instance, ref) {
      if (typeof ref === "function") {
        ref(instance);
      } else if (ref != null) {
        ref.current = instance;
      } else {
        /* eslint-disable no-debugger */
        debugger;
        console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
      }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */


    function useMergedRefs(_ref, _ref2) {
      let {
        ref: rhs
      } = _ref;
      let {
        ref: lhs
      } = _ref2;
      const combined = q$1(current => {
        processRef(current, lhs);
        processRef(current, rhs);
      }, [lhs, rhs]);

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return combined;
      }
    }

    function styleStringToObject(style) {
      // TODO: This sucks D:
      return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
    }
    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */


    function useMergedStyles(lhs, rhs) {
      var _lhs$style, _rhs$style2;

      // Easy case, when there are no styles to merge return nothing.
      if (!(lhs !== null && lhs !== void 0 && lhs.style) && !(rhs !== null && rhs !== void 0 && rhs.style)) return undefined;

      if (typeof lhs != typeof rhs) {
        // Easy cases, when one is null and the other isn't.
        if (lhs !== null && lhs !== void 0 && lhs.style && !(rhs !== null && rhs !== void 0 && rhs.style)) return lhs.style;
        if (!(lhs !== null && lhs !== void 0 && lhs.style) && rhs !== null && rhs !== void 0 && rhs.style) return rhs.style; // They're both non-null but different types.
        // Convert the string type to an object bag type and run it again.

        if (lhs !== null && lhs !== void 0 && lhs.style && rhs !== null && rhs !== void 0 && rhs.style) {
          // (useMergedStyles isn't a true hook -- this isn't a violation)
          if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") return useMergedStyles({
            style: styleStringToObject(lhs === null || lhs === void 0 ? void 0 : lhs.style)
          }, rhs);
          if (typeof (rhs === null || rhs === void 0 ? void 0 : rhs.style) == "string") return useMergedStyles(lhs, {
            style: styleStringToObject(rhs === null || rhs === void 0 ? void 0 : rhs.style)
          });
        } // Logic???


        return undefined;
      } // They're both strings, just concatenate them.


      if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") {
        var _rhs$style;

        return `${lhs.style};${(_rhs$style = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style !== void 0 ? _rhs$style : ""}`;
      } // They're both objects, just merge them.


      return { ...((_lhs$style = lhs === null || lhs === void 0 ? void 0 : lhs.style) !== null && _lhs$style !== void 0 ? _lhs$style : {}),
        ...((_rhs$style2 = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style2 !== void 0 ? _rhs$style2 : {})
      };
    }

    let log = console.warn;
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */

    function useMergedProps(lhsAll, rhsAll) {
      // First, separate the props we were given into two groups:
      // lhsAll and rhsAll contain all the props we were given, and
      // lhsMisc and rhsMisc contain all props *except* for the easy ones
      // like className and style that we already know how to merge.
      const {
        children: _lhsChildren,
        class: _lhsClass,
        className: _lhsClassName,
        style: _lhsStyle,
        ref: _lhsRef,
        ...lhsMisc
      } = lhsAll;
      const {
        children: _rhsChildren,
        class: _rhsClass,
        className: _rhsClassName,
        style: _rhsStyle,
        ref: _rhsRef,
        ...rhsMisc
      } = rhsAll;
      const ret = { ...lhsMisc,
        ref: useMergedRefs(lhsAll, rhsAll),
        style: useMergedStyles(lhsAll, rhsAll),
        className: useMergedClasses(lhsAll, rhsAll),
        children: useMergedChildren(lhsAll, rhsAll)
      };
      if (ret.ref === undefined) delete ret.ref;
      if (ret.style === undefined) delete ret.style;
      if (ret.className === undefined) delete ret.className;
      if (ret.children === undefined) delete ret.children; // Now, do *everything* else
      // Merge every remaining existing entry in lhs with what we've already put in ret.
      //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];

      const rhsEntries = Object.entries(rhsMisc);

      for (const [rhsKeyU, rhsValue] of rhsEntries) {
        const rhsKey = rhsKeyU;
        const lhsValue = lhsMisc[rhsKey];

        if (typeof lhsValue === "function" || typeof rhsValue === "function") {
          // They're both functions that can be merged (or one's a function and the other's null).
          // Not an *easy* case, but a well-defined one.
          const merged = mergeFunctions(lhsValue, rhsValue);
          ret[rhsKey] = merged;
        } else {
          // Uh...we're here because one of them's null, right?
          if (lhsValue == null && rhsValue == null) {
            if (rhsValue === null && lhsValue === undefined) ret[rhsKey] = rhsValue;else ret[rhsKey] = lhsValue;
          }

          if (lhsValue == null) ret[rhsKey] = rhsValue;else if (rhsValue == null) ret[rhsKey] = lhsValue;else if (rhsValue == lhsValue) ; else {
            var _log;

            // Ugh.
            // No good strategies here, just log it if requested
            (_log = log) === null || _log === void 0 ? void 0 : _log(`The prop "${rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
            ret[rhsKey] = rhsValue;
          }
        }
      }

      return ret;
    }

    function mergeFunctions(lhs, rhs) {
      if (!lhs) return rhs;
      if (!rhs) return lhs;
      return function () {
        const lv = lhs(...arguments);
        const rv = rhs(...arguments);
        if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
      };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */

    function useRefElement(args) {
      const {
        onElementChange,
        onMount,
        onUnmount
      } = args !== null && args !== void 0 ? args : {};
      useEnsureStability("useRefElement", onElementChange, onMount, onUnmount); // Called (indirectly) by the ref that the element receives.

      const handler = q$1((e, prevValue) => {
        const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
        if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
        if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
        return cleanup;
      }, []); // Let us store the actual (reference to) the element we capture

      const [getElement, setElement] = usePassiveState(handler, returnNull);
      const useRefElementProps = q$1(props => useMergedProps({
        ref: setElement
      }, props), []); // Return both the element and the hook that modifies 
      // the props and allows us to actually find the element

      return {
        useRefElementProps,
        getElement
      };
    }

    function useElementSize(_ref) {
      let {
        getObserveBox,
        onSizeChange
      } = _ref;
      useEnsureStability("useElementSize", getObserveBox, onSizeChange);
      const [getSize, setSize] = usePassiveState(onSizeChange, returnNull);
      const currentObserveBox = A(undefined);
      const needANewObserver = q$1((element, observeBox) => {
        if (element) {
          const document = getDocument$6(element);
          const window = document.defaultView;

          const handleUpdate = () => {
            if (element.isConnected) {
              const {
                clientWidth,
                scrollWidth,
                offsetWidth,
                clientHeight,
                scrollHeight,
                offsetHeight,
                clientLeft,
                scrollLeft,
                offsetLeft,
                clientTop,
                scrollTop,
                offsetTop
              } = element;
              setSize({
                clientWidth,
                scrollWidth,
                offsetWidth,
                clientHeight,
                scrollHeight,
                offsetHeight,
                clientLeft,
                scrollLeft,
                offsetLeft,
                clientTop,
                scrollTop,
                offsetTop
              });
            }
          };

          if (window && "ResizeObserver" in window) {
            const observer = new ResizeObserver(_entries => {
              handleUpdate();
            });
            observer.observe(element, {
              box: observeBox
            });
            return () => observer.disconnect();
          } else {
            document.addEventListener("resize", handleUpdate, {
              passive: true
            });
            return () => document.removeEventListener("resize", handleUpdate);
          }
        }
      }, []);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: q$1(e => needANewObserver(e, getObserveBox === null || getObserveBox === void 0 ? void 0 : getObserveBox()), [])
      });
      s(() => {
        if (getObserveBox) {
          if (currentObserveBox.current !== getObserveBox()) needANewObserver(getElement(), getObserveBox());
        }
      });
      return {
        getElement,
        getSize,
        useElementSizeProps: useRefElementProps
      };
    }

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */

    function useGlobalHandler(target, type, handler, options) {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      let stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
      if (handler == null) stableHandler = null;
      s(() => {
        if (stableHandler) {
          target.addEventListener(type, stableHandler, options);
          return () => target.removeEventListener(type, stableHandler, options);
        }
      }, [target, type, stableHandler]);
    }

    /*!
    * tabbable 6.0.0
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var NoElement = typeof Element === 'undefined';
    var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
      return element.getRootNode();
    } : function (element) {
      return element.ownerDocument;
    };

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };


    var isNodeAttached = function isNodeAttached(node) {
      var _nodeRootHost; // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
      //  (but NOT _the_ document; see second 'If' comment below for more).
      // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
      //  is attached, and the one we need to check if it's in the document or not (because the
      //  shadow, and all nodes it contains, is never considered in the document since shadows
      //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
      //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
      //  visibility, including all the nodes it contains). The host could be any normal node,
      //  or a custom element (i.e. web component). Either way, that's the one that is considered
      //  part of the document, not the shadow root, nor any of its children (i.e. the node being
      //  tested).
      // To further complicate things, we have to look all the way up until we find a shadow HOST
      //  that is attached (or find none) because the node might be in nested shadows...
      // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
      //  document (per the docs) and while it's a Document-type object, that document does not
      //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
      //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
      //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
      //  node is actually detached.


      var nodeRootHost = getRootNode(node).host;
      var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));

      while (!attached && nodeRootHost) {
        var _nodeRootHost2; // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
        //  which means we need to get the host's host and check if that parent host is contained
        //  in (i.e. attached to) the document


        nodeRootHost = getRootNode(nodeRootHost).host;
        attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
      }

      return attached;
    };

    var isZeroArea = function isZeroArea(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(),
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      return width === 0 && height === 0;
    };

    var isHidden = function isHidden(node, _ref) {
      var displayCheck = _ref.displayCheck,
          getShadowRoot = _ref.getShadowRoot; // NOTE: visibility will be `undefined` if node is detached from the document
      //  (see notes about this further down), which means we will consider it visible
      //  (this is legacy behavior from a very long way back)
      // NOTE: we check this regardless of `displayCheck="none"` because this is a
      //  _visibility_ check, not a _display_ check

      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      }

      if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
        if (typeof getShadowRoot === 'function') {
          // figure out if we should consider the node to be in an undisclosed shadow and use the
          //  'non-zero-area' fallback
          var originalNode = node;

          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);

            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
            ) {
              // node has an undisclosed shadow which means we can only treat it as a black box, so we
              //  fall back to a non-zero-area test
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              // iterate up slot
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              // cross shadow boundary
              node = rootNode.host;
            } else {
              // iterate up normal dom
              node = parentElement;
            }
          }

          node = originalNode;
        } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.


        if (isNodeAttached(node)) {
          // this works wherever the node is: if there's at least one client rect, it's
          //  somehow displayed; it also covers the CSS 'display: contents' case where the
          //  node itself is hidden in place of its contents; and there's no need to search
          //  up the hierarchy either
          return !node.getClientRects().length;
        } // Else, the node isn't attached to the document, which means the `getClientRects()`
        //  API will __always__ return zero rects (this can happen, for example, if React
        //  is used to render nodes onto a detached tree, as confirmed in this thread:
        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
        //
        // It also means that even window.getComputedStyle(node).display will return `undefined`
        //  because styles are only computed for nodes that are in the document.
        //
        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
        //  somehow. Though it was never stated officially, anyone who has ever used tabbable
        //  APIs on nodes in detached containers has actually implicitly used tabbable in what
        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
        //  considering __everything__ to be visible because of the innability to determine styles.
        //
        // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
        //  nodes as visible with the 'none' fallback.__


        if (displayCheck !== 'legacy-full') {
          return true; // hidden
        } // else, fallback to 'none' mode and consider the node visible

      } else if (displayCheck === 'non-zero-area') {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
      } // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
      //  it's visible


      return false;
    }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset


    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>

        while (parentNode) {
          if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
            // look for the first <legend> among the children of the disabled <fieldset>
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i); // when the first <legend> (in document order) is found

              if (child.tagName === 'LEGEND') {
                // if its parent <fieldset> is not nested in another disabled <fieldset>,
                // return whether `node` is a descendant of its first <legend>
                return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
              }
            } // the disabled <fieldset> containing `node` has no <legend>


            return true;
          }

          parentNode = parentNode.parentElement;
        }
      } // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state


      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    (function (module, exports) {
      (function (global, factory) {
        factory() ;
      })(commonjsGlobal, function () {

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        /**
         * This work is licensed under the W3C Software and Document License
         * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
         */


        (function () {
          // Return early if we're not running inside of the browser.
          if (typeof window === 'undefined') {
            return;
          } // Convenience function for converting NodeLists.

          /** @type {typeof Array.prototype.slice} */


          var slice = Array.prototype.slice;
          /**
           * IE has a non-standard name for "matches".
           * @type {typeof Element.prototype.matches}
           */

          var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
          /** @type {string} */

          var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
          /**
           * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
           * attribute.
           *
           * Its main functions are:
           *
           * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
           *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
           *   each focusable node in the subtree with the singleton `InertManager` which manages all known
           *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
           *   instance exists for each focusable node which has at least one inert root as an ancestor.
           *
           * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
           *   attribute is removed from the root node). This is handled in the destructor, which calls the
           *   `deregister` method on `InertManager` for each managed inert node.
           */


          var InertRoot = function () {
            /**
             * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
             * @param {!InertManager} inertManager The global singleton InertManager object.
             */
            function InertRoot(rootElement, inertManager) {
              _classCallCheck(this, InertRoot);
              /** @type {!InertManager} */


              this._inertManager = inertManager;
              /** @type {!HTMLElement} */

              this._rootElement = rootElement;
              /**
               * @type {!Set<!InertNode>}
               * All managed focusable nodes in this InertRoot's subtree.
               */

              this._managedNodes = new Set(); // Make the subtree hidden from assistive technology

              if (this._rootElement.hasAttribute('aria-hidden')) {
                /** @type {?string} */
                this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
              } else {
                this._savedAriaHidden = null;
              }

              this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes


              this._makeSubtreeUnfocusable(this._rootElement); // Watch for:
              // - any additions in the subtree: make them unfocusable too
              // - any removals from the subtree: remove them from this inert root's managed nodes
              // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
              //   element, make that node a managed node.


              this._observer = new MutationObserver(this._onMutation.bind(this));

              this._observer.observe(this._rootElement, {
                attributes: true,
                childList: true,
                subtree: true
              });
            }
            /**
             * Call this whenever this object is about to become obsolete.  This unwinds all of the state
             * stored in this object and updates the state of all of the managed nodes.
             */


            _createClass(InertRoot, [{
              key: 'destructor',
              value: function destructor() {
                this._observer.disconnect();

                if (this._rootElement) {
                  if (this._savedAriaHidden !== null) {
                    this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                  } else {
                    this._rootElement.removeAttribute('aria-hidden');
                  }
                }

                this._managedNodes.forEach(function (inertNode) {
                  this._unmanageNode(inertNode.node);
                }, this); // Note we cast the nulls to the ANY type here because:
                // 1) We want the class properties to be declared as non-null, or else we
                //    need even more casts throughout this code. All bets are off if an
                //    instance has been destroyed and a method is called.
                // 2) We don't want to cast "this", because we want type-aware optimizations
                //    to know which properties we're setting.


                this._observer =
                /** @type {?} */
                null;
                this._rootElement =
                /** @type {?} */
                null;
                this._managedNodes =
                /** @type {?} */
                null;
                this._inertManager =
                /** @type {?} */
                null;
              }
              /**
               * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
               */

            }, {
              key: '_makeSubtreeUnfocusable',

              /**
               * @param {!Node} startNode
               */
              value: function _makeSubtreeUnfocusable(startNode) {
                var _this2 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this2._visitNode(node);
                });
                var activeElement = document.activeElement;

                if (!document.body.contains(startNode)) {
                  // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                  var node = startNode;
                  /** @type {!ShadowRoot|undefined} */

                  var root = undefined;

                  while (node) {
                    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      root =
                      /** @type {!ShadowRoot} */
                      node;
                      break;
                    }

                    node = node.parentNode;
                  }

                  if (root) {
                    activeElement = root.activeElement;
                  }
                }

                if (startNode.contains(activeElement)) {
                  activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1
                  // calling blur() will not actually move the focus.
                  // To work around this we call focus() on the body instead.

                  if (activeElement === document.activeElement) {
                    document.body.focus();
                  }
                }
              }
              /**
               * @param {!Node} node
               */

            }, {
              key: '_visitNode',
              value: function _visitNode(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of
                // this inert root, so all of its managed nodes need to be adopted by this InertRoot.

                if (element !== this._rootElement && element.hasAttribute('inert')) {
                  this._adoptInertRoot(element);
                }

                if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                  this._manageNode(element);
                }
              }
              /**
               * Register the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_manageNode',
              value: function _manageNode(node) {
                var inertNode = this._inertManager.register(node, this);

                this._managedNodes.add(inertNode);
              }
              /**
               * Unregister the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_unmanageNode',
              value: function _unmanageNode(node) {
                var inertNode = this._inertManager.deregister(node, this);

                if (inertNode) {
                  this._managedNodes['delete'](inertNode);
                }
              }
              /**
               * Unregister the entire subtree starting at `startNode`.
               * @param {!Node} startNode
               */

            }, {
              key: '_unmanageSubtree',
              value: function _unmanageSubtree(startNode) {
                var _this3 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this3._unmanageNode(node);
                });
              }
              /**
               * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
               * @param {!HTMLElement} node
               */

            }, {
              key: '_adoptInertRoot',
              value: function _adoptInertRoot(node) {
                var inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,
                // so register it now if need be.


                if (!inertSubroot) {
                  this._inertManager.setInert(node, true);

                  inertSubroot = this._inertManager.getInertRoot(node);
                }

                inertSubroot.managedNodes.forEach(function (savedInertNode) {
                  this._manageNode(savedInertNode.node);
                }, this);
              }
              /**
               * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_onMutation',
              value: function _onMutation(records, self) {
                records.forEach(function (record) {
                  var target =
                  /** @type {!HTMLElement} */
                  record.target;

                  if (record.type === 'childList') {
                    // Manage added nodes
                    slice.call(record.addedNodes).forEach(function (node) {
                      this._makeSubtreeUnfocusable(node);
                    }, this); // Un-manage removed nodes

                    slice.call(record.removedNodes).forEach(function (node) {
                      this._unmanageSubtree(node);
                    }, this);
                  } else if (record.type === 'attributes') {
                    if (record.attributeName === 'tabindex') {
                      // Re-initialise inert node if tabindex changes
                      this._manageNode(target);
                    } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                      // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                      // already managed nodes from this inert subroot.
                      this._adoptInertRoot(target);

                      var inertSubroot = this._inertManager.getInertRoot(target);

                      this._managedNodes.forEach(function (managedNode) {
                        if (target.contains(managedNode.node)) {
                          inertSubroot._manageNode(managedNode.node);
                        }
                      });
                    }
                  }
                }, this);
              }
            }, {
              key: 'managedNodes',
              get: function get() {
                return new Set(this._managedNodes);
              }
              /** @return {boolean} */

            }, {
              key: 'hasSavedAriaHidden',
              get: function get() {
                return this._savedAriaHidden !== null;
              }
              /** @param {?string} ariaHidden */

            }, {
              key: 'savedAriaHidden',
              set: function set(ariaHidden) {
                this._savedAriaHidden = ariaHidden;
              }
              /** @return {?string} */
              ,
              get: function get() {
                return this._savedAriaHidden;
              }
            }]);

            return InertRoot;
          }();
          /**
           * `InertNode` initialises and manages a single inert node.
           * A node is inert if it is a descendant of one or more inert root elements.
           *
           * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
           * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
           * is intrinsically focusable or not.
           *
           * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
           * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
           * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
           * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
           * or removes the `tabindex` attribute if the element is intrinsically focusable.
           */


          var InertNode = function () {
            /**
             * @param {!Node} node A focusable element to be made inert.
             * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
             */
            function InertNode(node, inertRoot) {
              _classCallCheck(this, InertNode);
              /** @type {!Node} */


              this._node = node;
              /** @type {boolean} */

              this._overrodeFocusMethod = false;
              /**
               * @type {!Set<!InertRoot>} The set of descendant inert roots.
               *    If and only if this set becomes empty, this node is no longer inert.
               */

              this._inertRoots = new Set([inertRoot]);
              /** @type {?number} */

              this._savedTabIndex = null;
              /** @type {boolean} */

              this._destroyed = false; // Save any prior tabindex info and make this node untabbable

              this.ensureUntabbable();
            }
            /**
             * Call this whenever this object is about to become obsolete.
             * This makes the managed node focusable again and deletes all of the previously stored state.
             */


            _createClass(InertNode, [{
              key: 'destructor',
              value: function destructor() {
                this._throwIfDestroyed();

                if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                  var element =
                  /** @type {!HTMLElement} */
                  this._node;

                  if (this._savedTabIndex !== null) {
                    element.setAttribute('tabindex', this._savedTabIndex);
                  } else {
                    element.removeAttribute('tabindex');
                  } // Use `delete` to restore native focus method.


                  if (this._overrodeFocusMethod) {
                    delete element.focus;
                  }
                } // See note in InertRoot.destructor for why we cast these nulls to ANY.


                this._node =
                /** @type {?} */
                null;
                this._inertRoots =
                /** @type {?} */
                null;
                this._destroyed = true;
              }
              /**
               * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
               * If the object has been destroyed, any attempt to access it will cause an exception.
               */

            }, {
              key: '_throwIfDestroyed',

              /**
               * Throw if user tries to access destroyed InertNode.
               */
              value: function _throwIfDestroyed() {
                if (this.destroyed) {
                  throw new Error('Trying to access destroyed InertNode');
                }
              }
              /** @return {boolean} */

            }, {
              key: 'ensureUntabbable',

              /** Save the existing tabindex value and make the node untabbable and unfocusable */
              value: function ensureUntabbable() {
                if (this.node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                this.node;

                if (matches.call(element, _focusableElementsString)) {
                  if (
                  /** @type {!HTMLElement} */
                  element.tabIndex === -1 && this.hasSavedTabIndex) {
                    return;
                  }

                  if (element.hasAttribute('tabindex')) {
                    this._savedTabIndex =
                    /** @type {!HTMLElement} */
                    element.tabIndex;
                  }

                  element.setAttribute('tabindex', '-1');

                  if (element.nodeType === Node.ELEMENT_NODE) {
                    element.focus = function () {};

                    this._overrodeFocusMethod = true;
                  }
                } else if (element.hasAttribute('tabindex')) {
                  this._savedTabIndex =
                  /** @type {!HTMLElement} */
                  element.tabIndex;
                  element.removeAttribute('tabindex');
                }
              }
              /**
               * Add another inert root to this inert node's set of managing inert roots.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'addInertRoot',
              value: function addInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots.add(inertRoot);
              }
              /**
               * Remove the given inert root from this inert node's set of managing inert roots.
               * If the set of managing inert roots becomes empty, this node is no longer inert,
               * so the object should be destroyed.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'removeInertRoot',
              value: function removeInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots['delete'](inertRoot);

                if (this._inertRoots.size === 0) {
                  this.destructor();
                }
              }
            }, {
              key: 'destroyed',
              get: function get() {
                return (
                  /** @type {!InertNode} */
                  this._destroyed
                );
              }
            }, {
              key: 'hasSavedTabIndex',
              get: function get() {
                return this._savedTabIndex !== null;
              }
              /** @return {!Node} */

            }, {
              key: 'node',
              get: function get() {
                this._throwIfDestroyed();

                return this._node;
              }
              /** @param {?number} tabIndex */

            }, {
              key: 'savedTabIndex',
              set: function set(tabIndex) {
                this._throwIfDestroyed();

                this._savedTabIndex = tabIndex;
              }
              /** @return {?number} */
              ,
              get: function get() {
                this._throwIfDestroyed();

                return this._savedTabIndex;
              }
            }]);

            return InertNode;
          }();
          /**
           * InertManager is a per-document singleton object which manages all inert roots and nodes.
           *
           * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
           * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
           * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
           * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
           * is created for each such node, via the `_managedNodes` map.
           */


          var InertManager = function () {
            /**
             * @param {!Document} document
             */
            function InertManager(document) {
              _classCallCheck(this, InertManager);

              if (!document) {
                throw new Error('Missing required argument; InertManager needs to wrap a document.');
              }
              /** @type {!Document} */


              this._document = document;
              /**
               * All managed nodes known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertNode>}
               */

              this._managedNodes = new Map();
              /**
               * All inert roots known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertRoot>}
               */

              this._inertRoots = new Map();
              /**
               * Observer for mutations on `document.body`.
               * @type {!MutationObserver}
               */

              this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.

              addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.

              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
              } else {
                this._onDocumentLoaded();
              }
            }
            /**
             * Set whether the given element should be an inert root or not.
             * @param {!HTMLElement} root
             * @param {boolean} inert
             */


            _createClass(InertManager, [{
              key: 'setInert',
              value: function setInert(root, inert) {
                if (inert) {
                  if (this._inertRoots.has(root)) {
                    // element is already inert
                    return;
                  }

                  var inertRoot = new InertRoot(root, this);
                  root.setAttribute('inert', '');

                  this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.
                  // Ensure inert styles are added there.


                  if (!this._document.body.contains(root)) {
                    var parent = root.parentNode;

                    while (parent) {
                      if (parent.nodeType === 11) {
                        addInertStyle(parent);
                      }

                      parent = parent.parentNode;
                    }
                  }
                } else {
                  if (!this._inertRoots.has(root)) {
                    // element is already non-inert
                    return;
                  }

                  var _inertRoot = this._inertRoots.get(root);

                  _inertRoot.destructor();

                  this._inertRoots['delete'](root);

                  root.removeAttribute('inert');
                }
              }
              /**
               * Get the InertRoot object corresponding to the given inert root element, if any.
               * @param {!Node} element
               * @return {!InertRoot|undefined}
               */

            }, {
              key: 'getInertRoot',
              value: function getInertRoot(element) {
                return this._inertRoots.get(element);
              }
              /**
               * Register the given InertRoot as managing the given node.
               * In the case where the node has a previously existing inert root, this inert root will
               * be added to its set of inert roots.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {!InertNode} inertNode
               */

            }, {
              key: 'register',
              value: function register(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (inertNode !== undefined) {
                  // node was already in an inert subtree
                  inertNode.addInertRoot(inertRoot);
                } else {
                  inertNode = new InertNode(node, inertRoot);
                }

                this._managedNodes.set(node, inertNode);

                return inertNode;
              }
              /**
               * De-register the given InertRoot as managing the given inert node.
               * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
               * node from the InertManager's set of managed nodes if it is destroyed.
               * If the node is not currently managed, this is essentially a no-op.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
               */

            }, {
              key: 'deregister',
              value: function deregister(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (!inertNode) {
                  return null;
                }

                inertNode.removeInertRoot(inertRoot);

                if (inertNode.destroyed) {
                  this._managedNodes['delete'](node);
                }

                return inertNode;
              }
              /**
               * Callback used when document has finished loading.
               */

            }, {
              key: '_onDocumentLoaded',
              value: function _onDocumentLoaded() {
                // Find all inert roots in document and make them actually inert.
                var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
                inertElements.forEach(function (inertElement) {
                  this.setInert(inertElement, true);
                }, this); // Comment this out to use programmatic API only.

                this._observer.observe(this._document.body || this._document.documentElement, {
                  attributes: true,
                  subtree: true,
                  childList: true
                });
              }
              /**
               * Callback used when mutation observer detects attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_watchForInert',
              value: function _watchForInert(records, self) {
                var _this = this;

                records.forEach(function (record) {
                  switch (record.type) {
                    case 'childList':
                      slice.call(record.addedNodes).forEach(function (node) {
                        if (node.nodeType !== Node.ELEMENT_NODE) {
                          return;
                        }

                        var inertElements = slice.call(node.querySelectorAll('[inert]'));

                        if (matches.call(node, '[inert]')) {
                          inertElements.unshift(node);
                        }

                        inertElements.forEach(function (inertElement) {
                          this.setInert(inertElement, true);
                        }, _this);
                      }, _this);
                      break;

                    case 'attributes':
                      if (record.attributeName !== 'inert') {
                        return;
                      }

                      var target =
                      /** @type {!HTMLElement} */
                      record.target;
                      var inert = target.hasAttribute('inert');

                      _this.setInert(target, inert);

                      break;
                  }
                }, this);
              }
            }]);

            return InertManager;
          }();
          /**
           * Recursively walk the composed tree from |node|.
           * @param {!Node} node
           * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
           *     before descending into child nodes.
           * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
           */


          function composedTreeWalk(node, callback, shadowRootAncestor) {
            if (node.nodeType == Node.ELEMENT_NODE) {
              var element =
              /** @type {!HTMLElement} */
              node;

              if (callback) {
                callback(element);
              } // Descend into node:
              // If it has a ShadowRoot, ignore all child elements - these will be picked
              // up by the <content> or <shadow> elements. Descend straight into the
              // ShadowRoot.


              var shadowRoot =
              /** @type {!HTMLElement} */
              element.shadowRoot;

              if (shadowRoot) {
                composedTreeWalk(shadowRoot, callback);
                return;
              } // If it is a <content> element, descend into distributed elements - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'content') {
                var content =
                /** @type {!HTMLContentElement} */
                element; // Verifies if ShadowDom v0 is supported.

                var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];

                for (var i = 0; i < distributedNodes.length; i++) {
                  composedTreeWalk(distributedNodes[i], callback);
                }

                return;
              } // If it is a <slot> element, descend into assigned nodes - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'slot') {
                var slot =
                /** @type {!HTMLSlotElement} */
                element; // Verify if ShadowDom v1 is supported.

                var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                  flatten: true
                }) : [];

                for (var _i = 0; _i < _distributedNodes.length; _i++) {
                  composedTreeWalk(_distributedNodes[_i], callback);
                }

                return;
              }
            } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
            // element, nor a <shadow> element recurse normally.


            var child = node.firstChild;

            while (child != null) {
              composedTreeWalk(child, callback);
              child = child.nextSibling;
            }
          }
          /**
           * Adds a style element to the node containing the inert specific styles
           * @param {!Node} node
           */


          function addInertStyle(node) {
            if (node.querySelector('style#inert-style, link#inert-style')) {
              return;
            }

            var style = document.createElement('style');
            style.setAttribute('id', 'inert-style');
            style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
            node.appendChild(style);
          }

          if (!HTMLElement.prototype.hasOwnProperty('inert')) {
            /** @type {!InertManager} */
            var inertManager = new InertManager(document);
            Object.defineProperty(HTMLElement.prototype, 'inert', {
              enumerable: true,

              /** @this {!HTMLElement} */
              get: function get() {
                return this.hasAttribute('inert');
              },

              /** @this {!HTMLElement} */
              set: function set(inert) {
                inertManager.setInert(this, inert);
              }
            });
          }
        })();
      });
    })();

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
      var _a, _b, _c;
      /* Symbols for private properties */


      const _blockingElements = Symbol();

      const _alreadyInertElements = Symbol();

      const _topElParents = Symbol();

      const _siblingsToRestore = Symbol();

      const _parentMO = Symbol();
      /* Symbols for private static methods */


      const _topChanged = Symbol();

      const _swapInertedSibling = Symbol();

      const _inertSiblings = Symbol();

      const _restoreInertedSiblings = Symbol();

      const _getParents = Symbol();

      const _getDistributedChildren = Symbol();

      const _isInertable = Symbol();

      const _handleMutations = Symbol();

      class BlockingElementsImpl {
        constructor() {
          /**
           * The blocking elements.
           */
          this[_a] = [];
          /**
           * Used to keep track of the parents of the top element, from the element
           * itself up to body. When top changes, the old top might have been removed
           * from the document, so we need to memoize the inerted parents' siblings
           * in order to restore their inerteness when top changes.
           */

          this[_b] = [];
          /**
           * Elements that are already inert before the first blocking element is
           * pushed.
           */

          this[_c] = new Set();
        }

        destructor() {
          // Restore original inertness.
          this[_restoreInertedSiblings](this[_topElParents]); // Note we don't want to make these properties nullable on the class,
          // since then we'd need non-null casts in many places. Calling a method on
          // a BlockingElements instance after calling destructor will result in an
          // exception.


          const nullable = this;
          nullable[_blockingElements] = null;
          nullable[_topElParents] = null;
          nullable[_alreadyInertElements] = null;
        }

        get top() {
          const elems = this[_blockingElements];
          return elems[elems.length - 1] || null;
        }

        push(element) {
          if (!element || element === this.top) {
            return;
          } // Remove it from the stack, we'll bring it to the top.


          this.remove(element);

          this[_topChanged](element);

          this[_blockingElements].push(element);
        }

        remove(element) {
          const i = this[_blockingElements].indexOf(element);

          if (i === -1) {
            return false;
          }

          this[_blockingElements].splice(i, 1); // Top changed only if the removed element was the top element.


          if (i === this[_blockingElements].length) {
            this[_topChanged](this.top);
          }

          return true;
        }

        pop() {
          const top = this.top;
          top && this.remove(top);
          return top;
        }

        has(element) {
          return this[_blockingElements].indexOf(element) !== -1;
        }
        /**
         * Sets `inert` to all document elements except the new top element, its
         * parents, and its distributed content.
         */


        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
          const toKeepInert = this[_alreadyInertElements];
          const oldParents = this[_topElParents]; // No new top, reset old top if any.

          if (!newTop) {
            this[_restoreInertedSiblings](oldParents);

            toKeepInert.clear();
            this[_topElParents] = [];
            return;
          }

          const newParents = this[_getParents](newTop); // New top is not contained in the main document!


          if (newParents[newParents.length - 1].parentNode !== document.body) {
            throw Error('Non-connected element cannot be a blocking element');
          } // Cast here because we know we'll call _inertSiblings on newParents
          // below.


          this[_topElParents] = newParents;

          const toSkip = this[_getDistributedChildren](newTop); // No previous top element.


          if (!oldParents.length) {
            this[_inertSiblings](newParents, toSkip, toKeepInert);

            return;
          }

          let i = oldParents.length - 1;
          let j = newParents.length - 1; // Find common parent. Index 0 is the element itself (so stop before it).

          while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
            i--;
            j--;
          } // If up the parents tree there are 2 elements that are siblings, swap
          // the inerted sibling.


          if (oldParents[i] !== newParents[j]) {
            this[_swapInertedSibling](oldParents[i], newParents[j]);
          } // Restore old parents siblings inertness.


          i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i)); // Make new parents siblings inert.

          j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
        }
        /**
         * Swaps inertness between two sibling elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_swapInertedSibling](oldInert, newInert) {
          const siblingsToRestore = oldInert[_siblingsToRestore]; // oldInert is not contained in siblings to restore, so we have to check
          // if it's inertable and if already inert.

          if (this[_isInertable](oldInert) && !oldInert.inert) {
            oldInert.inert = true;
            siblingsToRestore.add(oldInert);
          } // If newInert was already between the siblings to restore, it means it is
          // inertable and must be restored.


          if (siblingsToRestore.has(newInert)) {
            newInert.inert = false;
            siblingsToRestore.delete(newInert);
          }

          newInert[_parentMO] = oldInert[_parentMO];
          newInert[_siblingsToRestore] = siblingsToRestore;
          oldInert[_parentMO] = undefined;
          oldInert[_siblingsToRestore] = undefined;
        }
        /**
         * Restores original inertness to the siblings of the elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_restoreInertedSiblings](elements) {
          for (const element of elements) {
            const mo = element[_parentMO];
            mo.disconnect();
            element[_parentMO] = undefined;
            const siblings = element[_siblingsToRestore];

            for (const sibling of siblings) {
              sibling.inert = false;
            }

            element[_siblingsToRestore] = undefined;
          }
        }
        /**
         * Inerts the siblings of the elements except the elements to skip. Stores
         * the inerted siblings into the element's symbol `_siblingsToRestore`.
         * Pass `toKeepInert` to collect the already inert elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_inertSiblings](elements, toSkip, toKeepInert) {
          for (const element of elements) {
            // Assume element is not a Document, so it must have a parentNode.
            const parent = element.parentNode;
            const children = parent.children;
            const inertedSiblings = new Set();

            for (let j = 0; j < children.length; j++) {
              const sibling = children[j]; // Skip the input element, if not inertable or to be skipped.

              if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
                continue;
              } // Should be collected since already inerted.


              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            } // Store the siblings that were inerted.


            element[_siblingsToRestore] = inertedSiblings; // Observe only immediate children mutations on the parent.

            const mo = new MutationObserver(this[_handleMutations].bind(this));
            element[_parentMO] = mo;
            let parentToObserve = parent; // If we're using the ShadyDOM polyfill, then our parent could be a
            // shady root, which is an object that acts like a ShadowRoot, but isn't
            // actually a node in the real DOM. Observe the real DOM parent instead.

            const maybeShadyRoot = parentToObserve;

            if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
              parentToObserve = maybeShadyRoot.host;
            }

            mo.observe(parentToObserve, {
              childList: true
            });
          }
        }
        /**
         * Handles newly added/removed nodes by toggling their inertness.
         * It also checks if the current top Blocking Element has been removed,
         * notifying and removing it.
         */


        [_handleMutations](mutations) {
          const parents = this[_topElParents];
          const toKeepInert = this[_alreadyInertElements];

          for (const mutation of mutations) {
            // If the target is a shadowRoot, get its host as we skip shadowRoots when
            // computing _topElParents.
            const target = mutation.target.host || mutation.target;
            const idx = target === document.body ? parents.length : parents.indexOf(target);
            const inertedChild = parents[idx - 1];
            const inertedSiblings = inertedChild[_siblingsToRestore]; // To restore.

            for (let i = 0; i < mutation.removedNodes.length; i++) {
              const sibling = mutation.removedNodes[i];

              if (sibling === inertedChild) {
                console.info('Detected removal of the top Blocking Element.');
                this.pop();
                return;
              }

              if (inertedSiblings.has(sibling)) {
                sibling.inert = false;
                inertedSiblings.delete(sibling);
              }
            } // To inert.


            for (let i = 0; i < mutation.addedNodes.length; i++) {
              const sibling = mutation.addedNodes[i];

              if (!this[_isInertable](sibling)) {
                continue;
              }

              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            }
          }
        }
        /**
         * Returns if the element is inertable.
         */


        [_isInertable](element) {
          return false === /^(style|template|script)$/.test(element.localName);
        }
        /**
         * Returns the list of newParents of an element, starting from element
         * (included) up to `document.body` (excluded).
         */


        [_getParents](element) {
          const parents = [];
          let current = element; // Stop to body.

          while (current && current !== document.body) {
            // Skip shadow roots.
            if (current.nodeType === Node.ELEMENT_NODE) {
              parents.push(current);
            } // ShadowDom v1


            if (current.assignedSlot) {
              // Collect slots from deepest slot to top.
              while (current = current.assignedSlot) {
                parents.push(current);
              } // Continue the search on the top slot.


              current = parents.pop();
              continue;
            }

            current = current.parentNode || current.host;
          }

          return parents;
        }
        /**
         * Returns the distributed children of the element's shadow root.
         * Returns null if the element doesn't have a shadow root.
         */


        [_getDistributedChildren](element) {
          const shadowRoot = element.shadowRoot;

          if (!shadowRoot) {
            return null;
          }

          const result = new Set();
          let i;
          let j;
          let nodes;
          const slots = shadowRoot.querySelectorAll('slot');

          if (slots.length && slots[0].assignedNodes) {
            for (i = 0; i < slots.length; i++) {
              nodes = slots[i].assignedNodes({
                flatten: true
              });

              for (j = 0; j < nodes.length; j++) {
                if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                  result.add(nodes[j]);
                }
              }
            } // No need to search for <content>.

          }

          return result;
        }

      }

      document.$blockingElements = new BlockingElementsImpl();
    })();

    function blockingElements() {
      return getDocument$6().$blockingElements;
    }
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */


    function useBlockingElement(enabled, getTarget) {
      const stableGetTarget = useStableCallback(getTarget);
      /**
       * Push/pop the element from the blockingElements stack.
       */

      _(() => {
        const target = stableGetTarget();

        if (enabled) {
          // Sometimes blockingElements will fail if, for example,
          // the target element isn't connected to document.body.
          // This is rare, but it's better to fail silently with weird tabbing behavior
          // than to crash the entire application.
          try {
            blockingElements().push(target);
            return () => {
              blockingElements().remove(target);
            };
          } catch (ex) {
            // Well, semi-silently.
            console.error(ex);
          }
        }
      }, [enabled]);
    }
    function getTopElement() {
      return blockingElements().top;
    }

    const elementsToRestoreFocusTo = new Map();
    function useFocusTrap(_ref) {
      let {
        trapActive
      } = _ref;
      const handleActiveChange = q$1((trapActive, element) => {
        if (trapActive && element) {
          let rafHandle = requestAnimationFrame(() => {
            // TODO: This extra queueMicrotask is needed for
            // ...reasons?
            queueMicrotask(() => {
              var _findFirstFocusable;

              (_findFirstFocusable = findFirstFocusable(element)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        } else if (element) {
          // Restore the focus to the element
          // that has returned to the top of the stack
          let rafHandle = requestAnimationFrame(() => {
            queueMicrotask(() => {
              var _elementsToRestoreFoc;

              (_elementsToRestoreFoc = elementsToRestoreFocusTo.get(getTopElement())) === null || _elementsToRestoreFoc === void 0 ? void 0 : _elementsToRestoreFoc.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        }
      }, []);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: useStableCallback(element => handleActiveChange(trapActive, element))
      });
      const {
        getLastActiveElement
      } = useActiveElement({
        getDocument: useStableCallback(() => {
          var _getElement;

          return (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.ownerDocument;
        })
      }); // When the trap becomes active, before we let the blockingElements hook run,
      // keep track of whatever's currently focused and save it.

      _(() => {
        const element = getElement();

        if (trapActive && element) {
          var _getLastActiveElement;

          const document = getDocument$6(element); // Save the currently focused element
          // to whatever's currently at the top of the stack

          elementsToRestoreFocusTo.set(getTopElement(), (_getLastActiveElement = getLastActiveElement()) !== null && _getLastActiveElement !== void 0 ? _getLastActiveElement : document.body);
        }
      }, [trapActive]);
      useBlockingElement(trapActive, getElement);
      /**
       * Any time we activate or deactivate the trap,
       * change focus to something else (something in
       * the trap if it's active, or whatever we've
       * tracked in elementsToRestoreFocusTo if not)
       */

      _(() => {
        handleActiveChange(trapActive, getElement());
      }, [trapActive]);

      const useFocusTrapProps = props => {
        const p1 = useRefElementProps(props);
        const p2 = {
          "aria-modal": trapActive ? "true" : undefined
        };
        return useMergedProps(p1, p2);
      };

      return {
        useFocusTrapProps,
        getElement
      };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */

    function findFirstFocusable(element) {
      const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: node => node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      });
      const firstFocusable = treeWalker.firstChild();
      return firstFocusable;
    }

    /**
     * Returns a function that will, when called, force the component
     * that uses this hook to re-render itself.
     *
     * It's a bit smelly, so best to use sparingly.
     */

    function useForceUpdate() {
      const [, set] = y(0);
      return A(() => set(i => ++i)).current;
    }

    function useHasFocus(_ref) {
      let {
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onLastActiveElementChange,
        onActiveElementChange,
        onWindowFocusedChange,
        getDocument,
        getWindow,
        onElementChange,
        onMount,
        onUnmount
      } = _ref;
      useEnsureStability("useHasFocus", onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange);
      const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse$1);
      const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse$1);
      const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse$1);
      const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse$1);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange,
        onMount,
        onUnmount
      });
      const {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      } = useActiveElement({
        getDocument,
        getWindow,
        onActiveElementChange: q$1((activeElement, prevActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == activeElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(activeElement));
          setFocused(focused);
          setFocusedInner(focusedInner);
          onActiveElementChange === null || onActiveElementChange === void 0 ? void 0 : onActiveElementChange(activeElement, prevActiveElement);
        }, []),
        onLastActiveElementChange: q$1((lastActiveElement, prevLastActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == lastActiveElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(lastActiveElement));
          setLastFocused(focused);
          setLastFocusedInner(focusedInner);
          onLastActiveElementChange === null || onLastActiveElementChange === void 0 ? void 0 : onLastActiveElementChange(lastActiveElement, prevLastActiveElement);
        }, []),
        onWindowFocusedChange
      });
      const useHasFocusProps = q$1(props => {
        return useRefElementProps(props);
      }, []);
      return {
        useHasFocusProps,
        getElement,
        getFocused,
        getFocusedInner,
        getLastFocused,
        getLastFocusedInner,
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }
    function useChildrenHaveFocus(_ref2) {
      let {
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref2;
      const {
        managedChildren,
        useManagedChild
      } = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      const allElementsRef = A(new Set());
      const [getFocusCount, setFocusCount] = usePassiveState(useStableCallback((anyFocused, anyPreviouslyFocused) => {
        console.log(`Changing focus count from ${anyPreviouslyFocused} to ${anyFocused}`);
        console.assert(anyFocused >= 0 && anyFocused <= 1);
        if (anyFocused && !anyPreviouslyFocused) onAnyGainedFocus === null || onAnyGainedFocus === void 0 ? void 0 : onAnyGainedFocus();
        if (!anyFocused && anyPreviouslyFocused) onAllLostFocus === null || onAllLostFocus === void 0 ? void 0 : onAllLostFocus();
      }));
      const useChildrenHaveFocusChild = q$1(_ref3 => {
        let {
          onElementChange,
          onMount,
          onUnmount,
          getDocument,
          getWindow,
          onActiveElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onWindowFocusedChange,
          managedChild: {
            index,
            flags
          }
        } = _ref3;
        useManagedChild({
          managedChild: {
            index,
            subInfo: {},
            flags
          }
        });
        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange: q$1((e, prev) => {
            let r = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prev);

            if (e) {
              allElementsRef.current.add(e);
              return () => {
                r === null || r === void 0 ? void 0 : r();
                allElementsRef.current.delete(e);
              };
            }
          }, [onElementChange]),
          onMount,
          onUnmount,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged: useStableCallback((focused, prev) => {
            if (focused) {
              console.log(`Child ${index} is focused`);
              setFocusCount(p => (p !== null && p !== void 0 ? p : 0) + 1);
            } else if (!focused && prev) {
              console.log(`Child ${index} is unfocused`);
              setFocusCount(p => (p !== null && p !== void 0 ? p : 0) - 1);
            }

            onLastFocusedInnerChanged === null || onLastFocusedInnerChanged === void 0 ? void 0 : onLastFocusedInnerChanged(focused, prev);
          }),
          onWindowFocusedChange
        });
        return {
          useChildrenHaveFocusChildProps: useHasFocusProps,
          getElement
        };
      }, []);
      return {
        managedChildren,
        useChildrenHaveFocusChild
      };
    }

    function capitalize(str) {
      return str[0].toUpperCase() + str.substring(1);
    }
    /**
     * Inspects the element's style and determines the logical direction that text flows.
     *
     * Certain CSS properties, like `block-size`, respect the current writing mode and text direction.
     * But `transform`, `clip`, etc. don't.
     *
     * This is provided so that CSS properties can consistently use those logical properties.
     *
     * See https://drafts.csswg.org/css-writing-modes/#logical-to-physical
     *
     * @returns An object containing the following functions:
     * * `getLogicalDirection`: retrieves a `LogicalDirectionInfo` representing the current state of the element. (Function is constant between renders)
     * * `convertElementSize`: When used in conjunction with `useElementSize`, allows you to retrieve the logical size of an element instead of the physical size.
     * * `convertToLogicalOrientation`: Based on the current direction, converts "horizontal" or "vertical" to "inline" or "block".
     * * `convertToPhysicalOrientation`:  Based on the current direction, converts "inline" or "block" to "horizontal" or "vertical".
     */


    function useLogicalDirection(_ref) {
      let {
        onLogicalDirectionChange
      } = _ref;
      useEnsureStability("useLogicalDirection", onLogicalDirectionChange);
      const [getComputedStyles, setComputedStyles] = usePassiveState(null, returnNull);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: q$1(element => {
          if (element) {
            setComputedStyles(window.getComputedStyle(element));
          }
        }, [])
      }); // TODO: There's no way to refresh which writing mode we have once mounted.
      //   A. There's no way to watch for CSS style changes
      //   B. Calling getComputedStyle after every render for every element gets expensive fast and
      //   C. Is not necessary for most use cases that will never switch writing-mode within a single component
      //      (Those that do will need to mount and unmount the component that uses it)
      //
      // As a solution, here's a cheap workaround that checks when the element's size has changed,
      // and if so, tests if the writing mode has changed too.
      //
      // This will work for at least some number of cases, but a better solution is still needed.

      const {
        useElementSizeProps
      } = useElementSize({
        onSizeChange: q$1(_ => onLogicalDirectionChange === null || onLogicalDirectionChange === void 0 ? void 0 : onLogicalDirectionChange(getLogicalDirectionInfo()), [])
      });
      const getLogicalDirectionInfo = q$1(() => {
        const computedStyles = getComputedStyles();

        if (computedStyles) {
          const w = computedStyles.writingMode;
          let d = computedStyles.direction;
          const t = computedStyles.textOrientation;
          if (t == "upright") d = "ltr";
          return { ...WritingModes[w || "horizontal-tb"][d || "ltr"]
          };
        }

        return null;
      }, []); //const [getLogicalDirectionInfo, setLogicalDirectionInfo] = usePassiveState<LogicalDirectionInfo>(onLogicalDirectionChange);

      const convertToLogicalOrientation = q$1((elementOrientation, direction) => {
        var _direction, _direction2;

        (_direction = direction) !== null && _direction !== void 0 ? _direction : direction = getLogicalDirectionInfo();
        if (((_direction2 = direction) === null || _direction2 === void 0 ? void 0 : _direction2.inlineOrientation) === elementOrientation) return "inline";
        return "block";
      }, []);
      const convertToPhysicalSide = q$1((side, direction) => {
        var _direction3, _direction$blockDirec, _direction4, _direction$blockDirec2, _direction5, _direction$inlineDire, _direction6, _direction$inlineDire2, _direction7;

        (_direction3 = direction) !== null && _direction3 !== void 0 ? _direction3 : direction = getLogicalDirectionInfo();

        switch (side) {
          case "block-start":
            return M$1[((_direction$blockDirec = (_direction4 = direction) === null || _direction4 === void 0 ? void 0 : _direction4.blockDirection) !== null && _direction$blockDirec !== void 0 ? _direction$blockDirec : "ttb")[0]];

          case "block-end":
            return M$1[((_direction$blockDirec2 = (_direction5 = direction) === null || _direction5 === void 0 ? void 0 : _direction5.blockDirection) !== null && _direction$blockDirec2 !== void 0 ? _direction$blockDirec2 : "ttb")[2]];

          case "inline-start":
            return M$1[((_direction$inlineDire = (_direction6 = direction) === null || _direction6 === void 0 ? void 0 : _direction6.inlineDirection) !== null && _direction$inlineDire !== void 0 ? _direction$inlineDire : "ltr")[0]];

          case "inline-end":
            return M$1[((_direction$inlineDire2 = (_direction7 = direction) === null || _direction7 === void 0 ? void 0 : _direction7.inlineDirection) !== null && _direction$inlineDire2 !== void 0 ? _direction$inlineDire2 : "ltr")[2]];
        }
      }, []);
      const convertToLogicalSide = q$1((side, direction) => {
        var _direction8, _direction9, _direction10;

        (_direction8 = direction) !== null && _direction8 !== void 0 ? _direction8 : direction = getLogicalDirectionInfo();

        if (((_direction9 = direction) === null || _direction9 === void 0 ? void 0 : _direction9.inlineOrientation) === "vertical") {
          switch (side) {
            case "top":
              return direction.inlineDirection === "ttb" ? "inline-start" : "inline-end";

            case "bottom":
              return direction.inlineDirection === "btt" ? "inline-start" : "inline-end";

            case "left":
              return direction.blockDirection === "ltr" ? "block-start" : "block-end";

            case "right":
              return direction.blockDirection === "rtl" ? "block-start" : "block-end";
          }
        } else if (((_direction10 = direction) === null || _direction10 === void 0 ? void 0 : _direction10.inlineOrientation) === "horizontal") {
          switch (side) {
            case "top":
              return direction.blockDirection === "ttb" ? "block-start" : "block-end";

            case "bottom":
              return direction.blockDirection === "btt" ? "block-start" : "block-end";

            case "left":
              return direction.inlineDirection === "ltr" ? "inline-start" : "inline-end";

            case "right":
              return direction.inlineDirection === "rtl" ? "inline-start" : "inline-end";
          }
        }
        /* eslint-disable no-debugger */


        debugger;
        console.assert(false);
        return "inline-start";
      }, []);
      const convertToPhysicalOrientation = q$1((elementOrientation, direction) => {
        var _direction11;

        (_direction11 = direction) !== null && _direction11 !== void 0 ? _direction11 : direction = getLogicalDirectionInfo();

        if (elementOrientation == "inline") {
          var _direction12;

          if (((_direction12 = direction) === null || _direction12 === void 0 ? void 0 : _direction12.inlineOrientation) == "horizontal") return "horizontal";
          return "vertical";
        } else {
          var _direction13;

          if (((_direction13 = direction) === null || _direction13 === void 0 ? void 0 : _direction13.blockOrientation) == "vertical") return "vertical";
          return "horizontal";
        }
      }, []);
      const convertElementSize = q$1((elementSize, direction) => {
        var _direction14;

        (_direction14 = direction) !== null && _direction14 !== void 0 ? _direction14 : direction = getLogicalDirectionInfo();

        if (direction) {
          const {
            inlineSize,
            blockSize,
            inlineDirection,
            blockDirection
          } = direction; // Size is relatively simple

          const clientInlineSize = elementSize[`client${capitalize(inlineSize)}`];
          const clientBlockSize = elementSize[`client${capitalize(blockSize)}`];
          const offsetInlineSize = elementSize[`offset${capitalize(inlineSize)}`];
          const offsetBlockSize = elementSize[`offset${capitalize(blockSize)}`];
          const scrollInlineSize = elementSize[`scroll${capitalize(inlineSize)}`];
          const scrollBlockSize = elementSize[`scroll${capitalize(blockSize)}`];
          const f1 = getPhysicalLeftTop(inlineDirection);
          const f2 = getPhysicalRightBottom(inlineDirection);
          const f3 = getPhysicalLeftTop(blockDirection);
          const f4 = getPhysicalRightBottom(blockDirection);
          const clientInlineInset = elementSize[`client${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`client${capitalize(f2)}`]);
          const scrollInlineInset = elementSize[`scroll${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`scroll${capitalize(f2)}`]);
          const offsetInlineInset = elementSize[`offset${capitalize(f1)}`] == undefined ? undefined : elementSize[`offset${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`offset${capitalize(f2)}`]);
          const clientBlockInset = elementSize[`client${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`client${capitalize(f4)}`]);
          const scrollBlockInset = elementSize[`scroll${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`scroll${capitalize(f4)}`]);
          const offsetBlockInset = elementSize[`offset${capitalize(f3)}`] == undefined ? undefined : elementSize[`offset${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`offset${capitalize(f4)}`]);
          return {
            clientInlineSize,
            scrollInlineSize,
            offsetInlineSize,
            clientBlockSize,
            scrollBlockSize,
            offsetBlockSize,
            clientInlineInset,
            scrollInlineInset,
            offsetInlineInset,
            clientBlockInset,
            scrollBlockInset,
            offsetBlockInset
          };
        }

        return null;
      }, []);
      return {
        useLogicalDirectionProps: q$1(props => useRefElementProps(useElementSizeProps(props)), []),
        getElement,
        getLogicalDirectionInfo,
        convertToLogicalSize: convertElementSize,
        convertToLogicalOrientation,
        convertToPhysicalOrientation,
        convertToLogicalSide,
        convertToPhysicalSide
      };
    } // Position requires us to sometimes use one property (like `left`)
    // or sometimes two (like `left` + `width`)

    function getPhysicalLeftTop(dir) {
      if (dir === "ltr" || dir == "rtl") return "left";
      return "top";
    }

    function getPhysicalRightBottom(dir) {
      if (dir === "rtl") return "width";
      if (dir === "btt") return "height";
      return null;
    } // Helper for extracting info from "ltr", "ttb", etc.


    const M$1 = {
      t: "top",
      b: "bottom",
      l: "left",
      r: "right"
    };
    const HorizontalTbLtr = {
      inlineDirection: "ltr",
      blockDirection: "ttb",
      inlineOrientation: "horizontal",
      blockOrientation: "vertical",
      inlineSize: "width",
      blockSize: "height",
      leftRightDirection: "ltr",
      overUnderDirection: "ttb"
    };
    const HorizontalTbRtl = { ...HorizontalTbLtr,
      inlineDirection: "rtl"
    };
    const VerticalRlLtr = {
      inlineDirection: "ttb",
      blockDirection: "rtl",
      inlineOrientation: "vertical",
      blockOrientation: "horizontal",
      inlineSize: "height",
      blockSize: "width",
      leftRightDirection: "ttb",
      overUnderDirection: "rtl"
    };
    const VerticalRlRtl = { ...VerticalRlLtr,
      inlineDirection: "btt"
    };
    const SidewaysRlLtr = { ...VerticalRlLtr
    };
    const SidewaysRlRtl = { ...VerticalRlRtl
    };
    const VerticalLrLtr = { ...VerticalRlLtr,
      blockDirection: "ltr"
    };
    const VerticalLrRtl = { ...VerticalRlRtl,
      blockDirection: "ltr"
    };
    const SidewaysLtLtr = { ...VerticalLrLtr,
      inlineDirection: "btt",
      leftRightDirection: "btt",
      overUnderDirection: "ltr"
    };
    const SidewaysLtRtl = { ...SidewaysLtLtr,
      inlineDirection: "ttb"
    };
    const HorizontalTb = {
      ltr: HorizontalTbLtr,
      rtl: HorizontalTbRtl
    };
    const VerticalRl = {
      ltr: VerticalRlLtr,
      rtl: VerticalRlRtl
    };
    const VerticalLr = {
      ltr: VerticalLrLtr,
      rtl: VerticalLrRtl
    };
    const SidewaysRl = {
      ltr: SidewaysRlLtr,
      rtl: SidewaysRlRtl
    };
    const SidewaysLr = {
      ltr: SidewaysLtLtr,
      rtl: SidewaysLtRtl
    };
    const WritingModes = {
      "horizontal-tb": HorizontalTb,
      "vertical-lr": VerticalLr,
      "vertical-rl": VerticalRl,
      "sideways-lr": SidewaysLr,
      "sideways-rl": SidewaysRl
    };

    function useTimeout(_ref) {
      let {
        timeout,
        callback,
        triggerIndex
      } = _ref;
      const stableCallback = useStableCallback(() => {
        startTimeRef.current = null;
        callback();
      });
      const getTimeout = useStableGetter(timeout); // Set any time we start timeout.
      // Unset any time the timeout completes

      const startTimeRef = A(null);
      const timeoutIsNull = timeout == null; // Any time the triggerIndex changes (including on mount)
      // restart the timeout.  The timeout does NOT reset
      // when the duration or callback changes, only triggerIndex.

      s(() => {
        if (!timeoutIsNull) {
          const timeout = getTimeout();
          console.assert(timeoutIsNull == (timeout == null));

          if (timeout != null) {
            startTimeRef.current = +new Date();
            const handle = setTimeout(stableCallback, timeout);
            return () => clearTimeout(handle);
          }
        }
      }, [triggerIndex, timeoutIsNull]);
      const getElapsedTime = q$1(() => {
        var _startTimeRef$current;

        return +new Date() - +((_startTimeRef$current = startTimeRef.current) !== null && _startTimeRef$current !== void 0 ? _startTimeRef$current : new Date());
      }, []);
      const getRemainingTime = q$1(() => {
        const timeout = getTimeout();
        return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
      }, []);
      return {
        getElapsedTime,
        getRemainingTime
      };
    }

    /** Arguments passed to the child 'useLinearNavigationChild` */
    //export interface UseLinearNavigationChildInfo { }

    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useLinearNavigation(_ref) {
      var _nd;

      let {
        linearNavigation: {
          navigateToFirst: ntf,
          navigateToLast: ntl,
          navigateToNext: ntn,
          navigateToPrev: ntp,
          navigationDirection: nd,
          disableArrowKeys: dak,
          disableHomeEndKeys: dhek
        }
      } = _ref;
      (_nd = nd) !== null && _nd !== void 0 ? _nd : nd = "either";
      const {
        getLogicalDirectionInfo,
        useLogicalDirectionProps
      } = useLogicalDirection({});
      const navigateToFirst = useStableCallback(ntf);
      const navigateToLast = useStableCallback(ntl);
      const navigateToNext = useStableCallback(ntn);
      const navigateToPrev = useStableCallback(ntp);
      const getDisableArrowKeys = useStableGetter(dak);
      const getDisableHomeEndKeys = useStableGetter(dhek);
      const getNavigationDirection = useStableGetter(nd);
      return {
        linearNavigation: {},
        useLinearNavigationProps: q$1(props => {
          const onKeyDown = e => {
            // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
            if (e.ctrlKey || e.metaKey) return;
            const info = getLogicalDirectionInfo();
            const navigationDirection = getNavigationDirection();
            const disableArrowKeys = getDisableArrowKeys();
            const disableHomeEndKeys = getDisableHomeEndKeys();
            const allowsBlockNavigation = navigationDirection == "block" || navigationDirection == "either";
            const allowsInlineNavigation = navigationDirection == "inline" || navigationDirection == "either";

            switch (e.key) {
              case "ArrowUp":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowDown":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowLeft":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "rtl") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowRight":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "rtl") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  e.preventDefault();
                  e.stopPropagation();
                  break;
                }

              case "Home":
                if (!disableHomeEndKeys) {
                  navigateToFirst();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;

              case "End":
                if (!disableHomeEndKeys) {
                  navigateToLast();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;
            }
          };

          return useLogicalDirectionProps(useMergedProps({
            onKeyDown
          }, props));
        }, [])
      };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useTypeaheadNavigation(_ref2) {
      let {
        typeaheadNavigation: {
          collator,
          getIndex,
          typeaheadTimeout,
          setIndex,
          noTypeahead
        }
      } = _ref2;
      // For typeahead, keep track of what our current "search" string is (if we have one)
      // and also clear it every 1000 ms since the last time it changed.
      // Next, keep a mapping of typeahead values to indices for faster searching.
      // And, for the user's sake, let them know when their typeahead can't match anything anymore
      const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
      useTimeout({
        timeout: typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000,
        callback: () => {
          setCurrentTypeahead(null);
          setInvalidTypeahead(null);
        },
        triggerIndex: currentTypeahead
      });
      const sortedTypeaheadInfo = A([]);
      const [invalidTypeahead, setInvalidTypeahead] = useState(false); // Handle typeahead for input method editors as well
      // Essentially, when active, ignore further keys 
      // because we're waiting for a CompositionEnd event

      const [, setImeActive, getImeActive] = useState(false); // Because composition events fire *after* keydown events 
      // (but within the same task, which, TODO, could be browser-dependent),
      // we can use this to keep track of which event we're listening for on the first keydown.

      const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
      useLayoutEffect(() => {
        if (nextTypeaheadChar !== null) {
          setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar);
          setNextTypeaheadChar(null);
        }
      }, [nextTypeaheadChar]);
      const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
        var _safeRhs$toLowerCase;

        let compare; // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
        // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.

        safeLhs = safeLhs.normalize("NFD");
        safeRhs = safeRhs.normalize("NFD");
        if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
        return compare;
      });
      const insertingComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          return comparatorShared(lhs, rhs.text);
        }

        return lhs - rhs;
      });
      const typeaheadComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          // During typeahead, all strings longer than ours should be truncated
          // so that they're all considered equally by that point.
          return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
        }

        return lhs - rhs;
      });
      const isDisabled = useStableGetter(noTypeahead);
      const useTypeaheadNavigationProps = q$1(function (_ref3) {
        let { ...props
        } = _ref3;

        const onCompositionStart = _e => {
          setImeActive(true);
        };

        const onCompositionEnd = e => {
          setNextTypeaheadChar(e.data);
          setImeActive(false);
        };

        const onKeyDown = e => {
          if (isDisabled()) return;
          const imeActive = getImeActive();
          const key = e.key; // Not handled by typeahead (i.e. assume this is a keyboard shortcut)

          if (e.ctrlKey || e.metaKey) return;

          if (!imeActive && e.key === "Backspace") {
            // Remove the last character in a way that doesn't split UTF-16 surrogates.
            setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
            e.preventDefault();
            e.stopPropagation();
            return;
          } // The key property represents the typed character OR the "named key attribute" of the key pressed.
          // There's no definite way to tell the difference, but for all intents and purposes
          // there are no one-character names, and there are no non-ASCII-alpha names.
          // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.


          const isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);

          if (isCharacterKey) {
            var _getCurrentTypeahead;

            if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ; else {
              e.preventDefault();
              e.stopPropagation(); // Note: Won't be true for the first keydown
              // but will be overwritten before useLayoutEffect is called
              // to actually apply the change

              if (!imeActive) setNextTypeaheadChar(key);
            }
          }
        };

        return useMergedProps({
          onKeyDown,
          onCompositionStart,
          onCompositionEnd
        }, props);
      }, []); // Handle changes in typeahead that cause changes to the tabbable index

      s(() => {
        if (currentTypeahead && sortedTypeaheadInfo.current.length) {
          const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);

          if (sortedTypeaheadIndex < 0) {
            // The user has typed an entry that doesn't exist in the list
            // (or more specifically "for which there is no entry that starts with that input")
            setInvalidTypeahead(true);
          } else {
            setInvalidTypeahead(false);
            /*
              We know roughly where, in the sorted array of strings, our next typeahead location is.
              But roughly isn't good enough if there are multiple matches.
              To convert our sorted index to the unsorted index we need, we have to find the first
              element that matches us *and* (if any such exist) is *after* our current selection.
                In other words, the only way typeahead moves backwards relative to our current
              position is if the only other option is behind us.
                It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
              Though there's also a case for just going upwards to the nearest to prevent jumpiness.
              But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
              I dunno. Going back to the start is the simplist though.
                Basically what this does: Starting from where we found ourselves after our binary search,
              scan backwards and forwards through all adjacent entries that also compare equally so that
              we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
              (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
                TODO: The binary search starts this off with a solid O(log n), but one-character
              searches are, thanks to pigeonhole principal, eventually guaranteed to become
              O(n*log n). This is annoying but probably not easily solvable? There could be an
              exception for one-character strings, but that's just kicking the can down
              the road. Maybe one or two characters would be good enough though.
            */
            // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.

            let lowestUnsortedIndexAll = null;
            let lowestSortedIndexAll = sortedTypeaheadIndex; // These two are only set for elements that are ahead of us, but the principle's the same otherwise

            let lowestUnsortedIndexNext = null;
            let lowestSortedIndexNext = sortedTypeaheadIndex;

            const updateBestFit = u => {
              var _getIndex;

              if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                lowestUnsortedIndexAll = u;
                lowestSortedIndexAll = i;
              }

              if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > ((_getIndex = getIndex()) !== null && _getIndex !== void 0 ? _getIndex : -Infinity)) {
                lowestUnsortedIndexNext = u;
                lowestSortedIndexNext = i;
              }
            };

            let i = sortedTypeaheadIndex;

            while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              --i;
            }

            i = sortedTypeaheadIndex;

            while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              ++i;
            }

            if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
          }
        }
      }, [currentTypeahead]);
      const useTypeaheadNavigationChild = q$1(_ref4 => {
        let {
          index,
          text
        } = _ref4;
        s(() => {
          if (text) {
            // Find where to insert this item.
            // Because all index values should be unique, the returned sortedIndex
            // should always refer to a new location (i.e. be negative)                
            const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
            console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
              unsortedIndex: index,
              text
            }) == 0);

            if (sortedIndex < 0) {
              sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, {
                text,
                unsortedIndex: index
              });
            } else {
              sortedTypeaheadInfo.current.splice(sortedIndex, 0, {
                text,
                unsortedIndex: index
              });
            }

            return () => {
              // When unmounting, find where we were and remove ourselves.
              // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
              const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
              console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
                unsortedIndex: index,
                text
              }) == 0);

              if (sortedIndex >= 0) {
                sortedTypeaheadInfo.current.splice(sortedIndex, 1);
              }
            };
          }
        }, [text]);
        return;
      }, []);
      return {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
      };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */

    function binarySearch(array, wanted, comparator) {
      let firstIndex = 0;
      let lastIndex = array.length - 1;

      while (firstIndex <= lastIndex) {
        const testIndex = lastIndex + firstIndex >> 1;
        const comparisonResult = comparator(wanted, array[testIndex]);

        if (comparisonResult > 0) {
          firstIndex = testIndex + 1;
        } else if (comparisonResult < 0) {
          lastIndex = testIndex - 1;
        } else {
          return testIndex;
        }
      }

      return -firstIndex - 1;
    }

    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `shouldFocusOnChange` should return true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const [focusedInner, setFocusedInner] = useState(false);
     * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */

    function useRovingTabIndex(parentParameters) {
      var _initialIndex;

      let {
        rovingTabIndex: {
          initialIndex,
          onTabbableRender,
          onTabbableIndexChange
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters;
      (_initialIndex = initialIndex) !== null && _initialIndex !== void 0 ? _initialIndex : initialIndex = 0;
      const stableOnTabbableRender = useStableCallback(onTabbableRender !== null && onTabbableRender !== void 0 ? onTabbableRender : () => {});
      /*const [_getAnyFocused, setAnyFocused] = usePassiveState<number>(useStableCallback((newCount: number, oldCount: number | undefined) => {
          if (oldCount == 0 && newCount > 0) {
              onTabbedInTo?.();
          }
            if (newCount == 0 && (oldCount ?? 0) > 0) {
              onTabbedOutOf?.();
          }
      }), returnZero);*/
      // Keep track of three things related to the currently tabbable element's index:
      // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.

      const [getTabbableIndex, setTabbableIndex2] = usePassiveState(onTabbableIndexChange, q$1(() => {
        var _initialIndex2;

        return (_initialIndex2 = initialIndex) !== null && _initialIndex2 !== void 0 ? _initialIndex2 : 0;
      }, []));
      const setTabbableIndex = q$1((updater, fromUserInteraction) => {
        setTabbableIndex2(prevIndex => {
          let nextIndex = prevIndex;
          if (typeof updater === "function") nextIndex = updater(prevIndex !== null && prevIndex !== void 0 ? prevIndex : null);else nextIndex = updater;
          nextIndex = changeIndex(nextIndex);

          if (prevIndex != nextIndex) {
            const nextChild = nextIndex == null ? null : parentReturnType.managedChildren.children.getAt(nextIndex);
            const prevChild = prevIndex == null ? null : parentReturnType.managedChildren.children.getAt(prevIndex);
            if (prevChild != null) prevChild.subInfo.blurSelf();
            if (nextChild != null && fromUserInteraction) nextChild.subInfo.focusSelf();
          }

          return nextIndex;
        });
      }, []); // Any time the tabbable index changes,
      // notify the previous child that it's no longer tabbable,
      // and notify the next child that is allowed to be tabbed to.

      const parentReturnType = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange: useStableCallback((mounted, unmounted) => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(mounted, unmounted);
            reevaluateClosestFit();
          })
        }
      });
      const {
        useManagedChild
      } = parentReturnType;
      const {
        changeIndex,
        reevaluateClosestFit
      } = useChildrenFlag({
        initialIndex,
        children: parentReturnType.managedChildren.children,
        closestFit: true,
        key: "tabbable"
      });
      const useRovingTabIndexChild = q$1(childParameters => {
        const {
          subInfo,
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            hidden,
            blurSelf: blurSelfOverride,
            focusSelf: focusSelfOverride
          }
        } = childParameters;
        s(() => {
          reevaluateClosestFit();
        }, [!!hidden]);
        const bsOverride = useStableGetter(blurSelfOverride);
        const fsOverride = useStableGetter(focusSelfOverride);
        const focusSelf = q$1(() => {
          const fs = fsOverride();

          if (fs) {
            fs();
          } else {
            var _element$focus;

            const element = getElement();
            if (element) (_element$focus = element.focus) === null || _element$focus === void 0 ? void 0 : _element$focus.call(element);
          }
        }, []);
        const blurSelf = q$1(() => {
          const bs = bsOverride();

          if (bs) {
            bs();
          } else {
            var _element$blur;

            const element = getElement();
            if (element) (_element$blur = element.blur) === null || _element$blur === void 0 ? void 0 : _element$blur.call(element);
          }
        }, []);
        const onFocusedInnerChanged = useStableCallback((focused, _prevFocused) => {
          if (focused) {
            setTabbableIndex(index, true);
          }
        });
        const {
          getElement,
          useHasFocusProps
        } = useHasFocus({
          onFocusedInnerChanged,
          getDocument: q$1(() => {
            var _getElement;

            return (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.ownerDocument;
          }, [])
        });
        const [tabbable, setTabbable, getTabbable] = useState(false);
        const tabbableFlags = A({
          get: getTabbable,
          set: setTabbable,
          isValid: useStableCallback(() => !hidden)
        });

        useManagedChild({
          managedChild: {
            index,
            flags: { ...flags,
              tabbable: tabbableFlags.current
            },
            subInfo: {
              blurSelf,
              focusSelf,
              getElement,
              hidden: !!hidden,
              subInfo
            }
          }
        });

        s(() => {
          if (tabbable) stableOnTabbableRender(index);
        }, [tabbable, index]);

        function useRovingTabIndexChildProps(props) {
          console.assert(props.tabIndex == null);
          return useMergedProps(useHasFocusProps({
            tabIndex: tabbable ? 0 : -1
          }), props);
        }

        return {
          useRovingTabIndexChildProps,
          rovingTabIndex: {
            getElement,
            tabbable,
            getTabbable
          }
        };
      }, [
        /* Must remain stable */
      ]);
      const focusSelf = q$1(() => {
        var _parentReturnType$man, _parentReturnType$man2, _parentReturnType$man3;

        console.log(`useRovingTabIndex.focusSelf`);
        const index = getTabbableIndex();
        if (index != null) (_parentReturnType$man = parentReturnType.managedChildren.children.getAt(index)) === null || _parentReturnType$man === void 0 ? void 0 : (_parentReturnType$man2 = (_parentReturnType$man3 = _parentReturnType$man.subInfo).focusSelf) === null || _parentReturnType$man2 === void 0 ? void 0 : _parentReturnType$man2.call(_parentReturnType$man3);else setTabbableIndex(null, true);
      }, []);
      return {
        useRovingTabIndexChild,
        managedChildren: {
          children: parentReturnType.managedChildren.children
        },
        rovingTabIndex: {
          setTabbableIndex,
          getTabbableIndex,
          focusSelf
        }
      };
    }
    /*function test() {
        const { children, focusSelf, getTabbableIndex, setTabbableIndex, useRovingTabIndexChild, } = useRovingTabIndex<HTMLDivElement, { "foo": "bar" }, "flag2">({ managedChildren: {}, rovingTabIndex: {} });
        const { } = useRovingTabIndexChild({ managedChildren: { index: 0, flags: {} }, rti: { info3: { foo: "bar" } } });
    }*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;
      array || (array = Array(length));

      while (++index < length) {
        array[index] = source[index];
      }

      return array;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor,
        nativeRandom = Math.random;
    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */

    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */

    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;
      size = size === undefined ? length : size;

      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];
        array[rand] = array[index];
        array[index] = value;
      }

      array.length = size;
      return array;
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */

    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }

      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */

    function baseValues(object, props) {
      return arrayMap(props, function (key) {
        return object[key];
      });
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }

    /** `Object#toString` result references. */

    var argsTag$1 = '[object Arguments]';
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */

    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }

    /** Used for built-in method references. */

    var objectProto$3 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    /** Built-in value references. */

    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */

    var isArguments = baseIsArguments(function () {
      return arguments;
    }()) ? baseIsArguments : function (value) {
      return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */

    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    /** Built-in value references. */

    var Buffer = moduleExports$1 ? root.Buffer : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */

    var isBuffer = nativeIsBuffer || stubFalse;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */

    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */

    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /** Used to identify `toStringTag` values of typed arrays. */

    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */

    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */

    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        } // Legacy `process.binding('util')` for Node.js < 10.


        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    /* Node.js helper references. */

    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */

    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */

    var objectProto$2 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
        key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */

    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$1;
      return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */

    var objectProto = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */

    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }

    /** `Object#toString` result references. */

    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */

    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      } // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.


      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */

    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */

    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */

    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */

    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */

    function useRearrangeableChildren(_ref) {
      let {
        rearrangeableChildren: {
          getIndex
        }
      } = _ref;
      // These are used to keep track of a mapping between unsorted index <---> sorted index.
      // These are needed for navigation with the arrow keys.
      const mangleMap = A(new Map());
      const demangleMap = A(new Map());
      const indexMangler = q$1(n => {
        var _mangleMap$current$ge;

        return (_mangleMap$current$ge = mangleMap.current.get(n)) !== null && _mangleMap$current$ge !== void 0 ? _mangleMap$current$ge : n;
      }, []);
      const indexDemangler = q$1(n => {
        var _demangleMap$current$;

        return (_demangleMap$current$ = demangleMap.current.get(n)) !== null && _demangleMap$current$ !== void 0 ? _demangleMap$current$ : n;
      }, []); // The sort function needs to be able to update whoever has all the sortable children.
      // Because that might not be the consumer of *this* hook directly (e.g. a table uses
      // this hook, but it's tbody that actually needs updating), we need to remotely
      // get and set a forceUpdate function.
      //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);

      const [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
      const rearrange = q$1(sortedRows => {
        var _getForceUpdate;

        // Update our sorted <--> unsorted indices map 
        // and rerender the whole table, basically
        for (let indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
          const indexAsUnsorted = sortedRows[indexAsSorted].index;
          mangleMap.current.set(indexAsUnsorted, indexAsSorted);
          demangleMap.current.set(indexAsSorted, indexAsUnsorted);
        }

        (_getForceUpdate = getForceUpdate()) === null || _getForceUpdate === void 0 ? void 0 : _getForceUpdate();
      }, []);
      const useRearrangeableProps = q$1(_ref2 => {
        let {
          children,
          ...props
        } = _ref2;
        const forceUpdate = useForceUpdate();
        _(() => {
          setForceUpdate(_prev => forceUpdate);
        }, [forceUpdate]);
        return useMergedProps({
          children: children.slice().map(child => ({
            child,
            mangledIndex: indexMangler(getIndex(child.props)),
            demangledIndex: getIndex(child.props)
          })).sort((lhs, rhs) => {
            return lhs.mangledIndex - rhs.mangledIndex;
          }).map(_ref3 => {
            let {
              child,
              mangledIndex,
              demangledIndex
            } = _ref3;
            return h$1(child.type, { ...child.props,
              key: demangledIndex,
              "data-mangled-index": mangledIndex,
              "data-unmangled-index": demangledIndex
            });
          })
        }, props);
      }, []);
      return {
        useRearrangeableProps,
        rearrangeableChildren: {
          indexMangler,
          indexDemangler,
          mangleMap,
          demangleMap,
          rearrange
        }
      };
    }
    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */

    function useSortableChildren(_ref4) {
      let {
        rearrangeableChildren: {
          getIndex
        },
        sortableChildren: {
          compare: userCompare,
          getValue
        }
      } = _ref4;
      const compare = userCompare !== null && userCompare !== void 0 ? userCompare : defaultCompare;
      const {
        useRearrangeableProps: useSortableProps,
        ...rearrangeableChildrenReturnType
      } = useRearrangeableChildren({
        rearrangeableChildren: {
          getIndex
        }
      });
      const {
        rearrangeableChildren: {
          rearrange
        }
      } = rearrangeableChildrenReturnType; // The actual sort function.

      const sort = q$1(function (managedRows, direction) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        const sortedRows = managedRows.arraySlice().sort((lhsRow, rhsRow) => {
          const lhsValue = getValue(lhsRow, ...args);
          const rhsValue = getValue(rhsRow, ...args);
          const result = compare(lhsValue, rhsValue); // lhsRow.getManagedCells()?.[column]?.value, rhsRow.getManagedCells()?.[column]?.value);

          if (direction[0] == "d") return -result;
          return result;
        });
        return rearrange(sortedRows);
      }, [
        /* Must remain stable */
      ]);
      const shuffle$1 = q$1(managedRows => {
        const shuffledRows = shuffle(managedRows.arraySlice());
        return rearrange(shuffledRows);
      }, [
        /* Must remain stable */
      ]);
      return {
        useSortableProps,
        sortableChildren: {
          sort,
          shuffle: shuffle$1
        },
        rearrangeableChildren: rearrangeableChildrenReturnType.rearrangeableChildren
      };
    }

    function defaultCompare(lhs, rhs) {
      return compare1(lhs, rhs);

      function compare3(lhs, rhs) {
        // Coerce strings to numbers if they seem to stay the same when serialized
        if (`${+lhs}` === lhs) lhs = +lhs;
        if (`${+rhs}` === rhs) rhs = +rhs; // At this point, if either argument is a string, turn the other one into one too

        if (typeof lhs === "string") rhs = `${rhs}`;
        if (typeof rhs === "string") lhs = `${lhs}`;
        console.assert(typeof lhs === typeof rhs);
        if (typeof lhs === "string") return lhs.localeCompare(rhs);
        if (typeof lhs === "number") return +lhs - +rhs;
        return 0;
      }

      function compare2(lhs, rhs) {
        if (typeof lhs === "boolean" || lhs instanceof Date) lhs = +lhs;
        if (typeof rhs === "boolean" || rhs instanceof Date) rhs = +rhs;
        return compare3(lhs, rhs);
      }

      function compare1(lhs, rhs) {
        if (lhs == null && rhs == null) {
          // They're both null
          return 0;
        } else if (lhs == null || rhs == null) {
          // One of the two is null -- easy case
          return lhs != null ? 1 : -1;
        }

        return compare2(lhs, rhs);
      }
    }

    function identity(t) {
      return t;
    }
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */


    function useListNavigation(_ref) {
      var _indexMangler, _indexDemangler;

      let {
        managedChildren: mc,
        rovingTabIndex,
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        linearNavigation,
        typeaheadNavigation
      } = _ref;
      (_indexMangler = indexMangler) !== null && _indexMangler !== void 0 ? _indexMangler : indexMangler = identity;
      (_indexDemangler = indexDemangler) !== null && _indexDemangler !== void 0 ? _indexDemangler : indexDemangler = identity;
      useEnsureStability("useListNavigation", indexMangler, indexDemangler);
      const parentReturnType = useRovingTabIndex({
        managedChildren: mc,
        rovingTabIndex
      });
      const {
        useRovingTabIndexChild,
        managedChildren: {
          children
        },
        rovingTabIndex: {
          getTabbableIndex,
          setTabbableIndex
        }
      } = parentReturnType;
      const navigateToIndex = q$1((i, fromUserInteraction) => {
        if (i != null) {
          var _indexMangler2, _indexDemangler2;

          const nextIndex = tryNavigateToIndex({
            children: children,
            default: 0,
            target: i,
            searchDirection: 1,
            indexMangler: (_indexMangler2 = indexMangler) !== null && _indexMangler2 !== void 0 ? _indexMangler2 : identity,
            indexDemangler: (_indexDemangler2 = indexDemangler) !== null && _indexDemangler2 !== void 0 ? _indexDemangler2 : identity
          });
          setTabbableIndex(i == null ? null : nextIndex, fromUserInteraction);
        } else {
          setTabbableIndex(null, fromUserInteraction);
        }
      }, []);
      const {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
      } = useTypeaheadNavigation({
        typeaheadNavigation: {
          getIndex: getTabbableIndex,
          setIndex: q$1(index => {
            setTabbableIndex(index, true);
          }, []),
          ...typeaheadNavigation
        }
      });
      const {
        useLinearNavigationProps
      } = useLinearNavigation({
        linearNavigation: {
          navigateToPrev: q$1(() => {
            setTabbableIndex(c => {
              var _indexMangler3, _indexDemangler3;

              return tryNavigateToIndex({
                children,
                default: c !== null && c !== void 0 ? c : 0,
                target: indexDemangler(indexMangler(c !== null && c !== void 0 ? c : 0) - 1),
                searchDirection: -1,
                indexMangler: (_indexMangler3 = indexMangler) !== null && _indexMangler3 !== void 0 ? _indexMangler3 : identity,
                indexDemangler: (_indexDemangler3 = indexDemangler) !== null && _indexDemangler3 !== void 0 ? _indexDemangler3 : identity
              });
            }, true);
          }, []),
          navigateToNext: q$1(() => {
            setTabbableIndex(c => {
              var _indexMangler4, _indexDemangler4;

              return tryNavigateToIndex({
                children,
                default: c !== null && c !== void 0 ? c : 0,
                target: indexDemangler(indexMangler(c !== null && c !== void 0 ? c : 0) + 1),
                searchDirection: 1,
                indexMangler: (_indexMangler4 = indexMangler) !== null && _indexMangler4 !== void 0 ? _indexMangler4 : identity,
                indexDemangler: (_indexDemangler4 = indexDemangler) !== null && _indexDemangler4 !== void 0 ? _indexDemangler4 : identity
              });
            }, true);
          }, []),
          navigateToFirst: q$1(() => {
            navigateToIndex(indexDemangler(0), true);
          }, []),
          navigateToLast: q$1(() => {
            navigateToIndex(indexDemangler(children.getHighestIndex()), true);
          }, []),
          ...linearNavigation
        }
      });
      const useListNavigationProps = q$1(props => {
        return useLinearNavigationProps(useTypeaheadNavigationProps(props));
      }, [useLinearNavigationProps, useTypeaheadNavigationProps]);
      const useListNavigationChild = q$1(_ref2 => {
        let {
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden
          },
          listNavigation: {
            text
          },
          subInfo
        } = _ref2;

        useTypeaheadNavigationChild({
          text,
          index
        });

        const getIndex = useStableGetter(index);
        useEffect(() => {
          return () => {
            if (getTabbableIndex() == getIndex()) {
              navigateToIndex(index, false);
            }
          };
        }, []);
        const {
          useRovingTabIndexChildProps,
          rovingTabIndex: {
            tabbable,
            getTabbable,
            getElement
          }
        } = useRovingTabIndexChild({
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden: !!hidden
          },
          subInfo: {
            text,
            subInfo
          }
        });

        const useListNavigationChildProps = function (_ref3) {
          let { ...props
          } = _ref3;
          return useMergedProps(useRovingTabIndexChildProps({
            inert: hidden
          }), props);
        };

        return {
          useListNavigationChildProps,
          rovingTabIndex: {
            tabbable,
            getTabbable,
            getElement
          }
        };
      }, [useTypeaheadNavigationChild, useRovingTabIndexChild, navigateToIndex]);
      return {
        useListNavigationChild,
        useListNavigationProps,
        listNavigation: {
          navigateToIndex
        },
        managedChildren: parentReturnType.managedChildren,
        rovingTabIndex: parentReturnType.rovingTabIndex,
        linearNavigation: {},
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
        /*listNavigation: { navigateToIndex },
        rovingTabIndex: { focusSelf, getTabbableIndex, setTabbableIndex },
        linearNavigation: {},
        typeaheadNavigation: { currentTypeahead, invalidTypeahead }*/

      };
    }
    /**
     * It's very common to combine a tabbable list of things and "selection" of one of those things.
     *
     * Lists, radio buttons, tabs, etc. etc.
     *
     * This is a shortcut that combines the two with the correct typing.
     * @param param0
     * @returns
     */

    function useListNavigationSingleSelection(_ref4) {
      var _ref5;

      let {
        singleSelection: {
          selectedIndex
        },
        listNavigation,
        managedChildren: {
          /*onChildrenMountChange: ocmc,*/
          ...mc
        },
        rovingTabIndex: {
          initialIndex,
          ...rovingTabIndex
        },
        linearNavigation,
        typeaheadNavigation,
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        }
      } = _ref4;
      const parentReturnType = useListNavigation({
        listNavigation,
        managedChildren: { ...mc
          /*onChildrenMountChange: useStableCallback<OnChildrenMountChange<number>>((mounted, unmounted) => {
              reevaluateClosestFit();
              ocmc?.(mounted, unmounted);
          })*/

        },
        rovingTabIndex: {
          initialIndex: (_ref5 = initialIndex !== null && initialIndex !== void 0 ? initialIndex : selectedIndex) !== null && _ref5 !== void 0 ? _ref5 : undefined,
          //onTabbedOutOf: useStableCallback(() => { onTabbedOutOf?.(); setTabbableIndex(selectedIndex, false) }),
          ...rovingTabIndex
        },
        linearNavigation,
        typeaheadNavigation
      });
      const {
        useChildrenHaveFocusChild
      } = useChildrenHaveFocus({
        childrenHaveFocus: {
          onAllLostFocus: useStableCallback(() => {
            onAllLostFocus === null || onAllLostFocus === void 0 ? void 0 : onAllLostFocus();
            if (selectedIndex != null) setTabbableIndex(selectedIndex, false);
          }),
          onAnyGainedFocus
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useListNavigationChild,
        useListNavigationProps,
        ...listRest
      } = parentReturnType;
      const {
        managedChildren: {
          children
        },
        rovingTabIndex: {
          setTabbableIndex
        }
      } = listRest;
      const {
        changeIndex: changeSelectedIndex,
        getCurrentIndex: getSelectedIndex //reevaluateClosestFit

      } = useChildrenFlag({
        children: children,
        initialIndex: selectedIndex,
        key: "selected",
        closestFit: false
      });
      _(() => {
        changeSelectedIndex(selectedIndex);
      }, [selectedIndex]);
      return {
        useListNavigationSingleSelectionChild: q$1(_ref6 => {
          let {
            managedChild: {
              index,
              flags
            },
            rovingTabIndex: rti,
            listNavigation: ls,
            hasFocus,
            subInfo
          } = _ref6;
          const [isSelected, setIsSelected, getIsSelected] = useState(getSelectedIndex() == index);
          const selectedRef = A({
            get: getIsSelected,
            set: setIsSelected,
            isValid: useStableCallback(() => !rti.hidden)
          });
          const {
            useChildrenHaveFocusChildProps
          } = useChildrenHaveFocusChild({ ...hasFocus,
            managedChild: {
              index
            }
          });
          const {
            rovingTabIndex: rti_ret,
            useListNavigationChildProps
          } = useListNavigationChild({
            managedChild: {
              index,
              flags: {
                selected: selectedRef.current,
                ...flags
              }
            },
            rovingTabIndex: rti,
            listNavigation: ls,
            subInfo
          });
          return {
            useListNavigationSingleSelectionChildProps: props => useListNavigationChildProps(useChildrenHaveFocusChildProps(props)),
            rovingTabIndex: rti_ret,
            singleSelection: {
              selected: isSelected,
              getSelected: getIsSelected
            }
          };
        }, []),
        useListNavigationSingleSelectionProps: q$1(function () {
          return useListNavigationProps(...arguments);
        }, []),
        ...listRest,
        singleSelection: {}
      };
    }
    function tryNavigateToIndex(_ref9) {
      let {
        children,
        searchDirection,
        indexDemangler,
        indexMangler,
        target
      } = _ref9;
      const upper = children.getHighestIndex();
      const lower = 0;

      if (searchDirection === -1) {
        while (target >= lower && children.getAt(target) == null || !!((_children$getAt = children.getAt(target)) !== null && _children$getAt !== void 0 && _children$getAt.subInfo.hidden)) {
          var _children$getAt;

          target = indexDemangler(indexMangler(target) - 1);
        }

        return target < lower ? indexDemangler(lower) : target;
      } else if (searchDirection === 1) {
        while (target <= upper && children.getAt(target) == null || !!((_children$getAt2 = children.getAt(target)) !== null && _children$getAt2 !== void 0 && _children$getAt2.subInfo.hidden)) {
          var _children$getAt2;

          target = indexDemangler(indexMangler(target) + 1);
        }

        return target > upper ? indexDemangler(upper) : target;
      } else {
        return lower;
      }
    }

    function useGridNavigation(_ref) {
      var _rti$initialIndex;

      let {
        managedChildren: mc,
        rovingTabIndex: rti,
        listNavigation: ls,
        linearNavigation: ln,
        typeaheadNavigation: tn
      } = _ref;
      const [currentColumn, setCurrentColumn, getCurrentColumn] = useState((_rti$initialIndex = rti.initialIndex) !== null && _rti$initialIndex !== void 0 ? _rti$initialIndex : 0);
      const {
        useListNavigationChild: useListNavigationChildAsGridRow,
        useListNavigationProps: useListNavigationPropsAsGridParent,
        ...parentLsReturnType
      } = useListNavigation({
        managedChildren: mc,
        rovingTabIndex: rti,
        listNavigation: ls,
        linearNavigation: {
          navigationDirection: "block",
          ...ln
        },
        typeaheadNavigation: tn
      });
      const useGridNavigationRow = q$1(_ref2 => {
        let {
          asChildRowOfSection: asChild,
          asParentRowOfCells: asParent
        } = _ref2;
        // Override the focusSelf that rovingTabIndex does.
        // Instead of focusing the entire row, we ask the cell that corresponds
        // to our current column to focus itself.
        const focusSelf = useStableCallback(() => {
          const c2 = getCurrentColumn();

          if (asChild.rovingTabIndex.focusSelf) {
            asChild.rovingTabIndex.focusSelf();
          } else {
            navigateToIndex(c2 !== null && c2 !== void 0 ? c2 : 0, true);
          }
        });
        const rowLsChildReturnType = useListNavigationChildAsGridRow({
          managedChild: asChild.managedChild,
          listNavigation: { ...asChild.listNavigation
          },
          rovingTabIndex: { ...asChild.rovingTabIndex,
            focusSelf
          },
          subInfo: asChild.subInfo
        });
        const {
          rovingTabIndex: {
            tabbable
          },
          useListNavigationChildProps
        } = rowLsChildReturnType;
        s(() => {
          if (!tabbable) {
            navigateToIndex(null, false);
          }
        }, [tabbable]);
        const rowLsReturnType = useListNavigation({
          managedChildren: { ...asParent.managedChildren
          },
          rovingTabIndex: { ...asParent.rovingTabIndex
          },
          linearNavigation: { ...asParent.linearNavigation,
            navigationDirection: "inline"
          },
          typeaheadNavigation: { ...asParent.typeaheadNavigation,
            noTypeahead: true
          },
          listNavigation: { ...asParent.listNavigation
          }
        });
        const {
          rovingTabIndex: {
            setTabbableIndex
          },
          useListNavigationChild: useGridNavigationColumn2,
          useListNavigationProps: useGridNavigationColumnProps,
          listNavigation: {
            navigateToIndex
          }
        } = rowLsReturnType; //const rowHidden = !!asChild.rovingTabIndex.hidden;

        const useGridNavigationCell = q$1(_ref3 => {
          let {
            subInfo,
            hasFocus: {
              onLastFocusedInnerChanged,
              ...hasFocus
            },
            managedChild,
            listNavigation: ls,
            rovingTabIndex: {
              blurSelf: bs,
              focusSelf: fs,
              ...rti
            }
          } = _ref3;
          //rti.hidden || rowHidden;
          const focusSelf = useStableCallback(() => {
            var _rti_cell_ret$getElem, _rti_cell_ret$getElem2;

            setCurrentColumn(managedChild.index);
            setTabbableIndex(managedChild.index, false);
            if (fs) fs();else (_rti_cell_ret$getElem = rti_cell_ret.getElement()) === null || _rti_cell_ret$getElem === void 0 ? void 0 : (_rti_cell_ret$getElem2 = _rti_cell_ret$getElem.focus) === null || _rti_cell_ret$getElem2 === void 0 ? void 0 : _rti_cell_ret$getElem2.call(_rti_cell_ret$getElem);
          });
          const blurSelf = useStableCallback(() => {
            var _rti_cell_ret$getElem3, _rti_cell_ret$getElem4;

            if (bs) bs();else (_rti_cell_ret$getElem3 = rti_cell_ret.getElement()) === null || _rti_cell_ret$getElem3 === void 0 ? void 0 : (_rti_cell_ret$getElem4 = _rti_cell_ret$getElem3.blur) === null || _rti_cell_ret$getElem4 === void 0 ? void 0 : _rti_cell_ret$getElem4.call(_rti_cell_ret$getElem3);
          });
          const {
            useListNavigationChildProps,
            rovingTabIndex: rti_cell_ret
          } = useGridNavigationColumn2({
            managedChild: managedChild,
            listNavigation: { ...ls
            },
            rovingTabIndex: {
              blurSelf,
              focusSelf,
              ...rti
            },
            subInfo
          });
          const {
            useHasFocusProps
          } = useHasFocus({
            onLastFocusedInnerChanged: useStableCallback((focused, prev) => {
              onLastFocusedInnerChanged === null || onLastFocusedInnerChanged === void 0 ? void 0 : onLastFocusedInnerChanged(focused, prev);

              if (focused) {
                setCurrentColumn(managedChild.index);
                setTabbableIndex(managedChild.index, false);
              }
            }),
            ...hasFocus
          });
          const ret = {
            gridNavigation: {
              getCurrentColumn
            },
            rovingTabIndex: rti_cell_ret,
            useGridNavigationCellProps: function (props) {
              return useListNavigationChildProps(useGridNavigationColumnProps(useHasFocusProps(props)));
            }
          };
          return ret;
        }, []);
        const ret = {
          asParentOfCells: {
            linearNavigation: rowLsReturnType.linearNavigation,
            listNavigation: rowLsReturnType.listNavigation,
            managedChildren: rowLsReturnType.managedChildren,
            rovingTabIndex: rowLsReturnType.rovingTabIndex,
            typeaheadNavigation: rowLsReturnType.typeaheadNavigation
          },
          asChildRow: rowLsChildReturnType,
          useGridNavigationCell,
          useGridNavigationRowProps: function (props) {
            const ret = useListNavigationChildProps(props);
            ret.tabIndex = -1;
            return ret;
          }
        };
        return ret;
      }, []);
      return {
        gridNavigation: {
          getCurrentColumn,
          currentColumn
        },
        linearNavigation: parentLsReturnType.linearNavigation,
        listNavigation: parentLsReturnType.listNavigation,
        rovingTabIndex: parentLsReturnType.rovingTabIndex,
        typeaheadNavigation: parentLsReturnType.typeaheadNavigation,
        managedChildren: parentLsReturnType.managedChildren,
        useGridNavigationRow,
        useGridNavigationProps: useListNavigationPropsAsGridParent
      };
    }

    /**
     * Returns a hook that modifies a set of props to provide a randomly-generated ID if one was not provided.
     *
     * If you'd like to use the ID in a property that's *not* named `id` (like `for` or `aria-labelledby` or whatnot), `useReferencedIdProps` is also provided.
     *
     * And the randomly-generated id itself is also provided in case you want to handle the logic yourself without `useMergedProps`.
     *
     * Unlike most other `use*Props` hooks, these are mostly stable.
     */

    function useRandomId(_ref) {
      let {
        randomId: {
          prefix
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref;
      const [backupRandomId,, getBackupRandomId] = useState(() => generateRandomId(prefix));
      const [usedId, setUsedId, getUsedId] = useState(() => getBackupRandomId());
      const mismatchErrorRef = A(false);
      useEnsureStability("useRandomId", prefix);
      const {
        useManagedChild,
        ...managedChildrenReturnType
      } = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      const {
        managedChildren: {
          children
        }
      } = managedChildrenReturnType;
      const useRandomIdSourceElement = q$1(() => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId());
        const {
          useRefElementProps,
          getElement
        } = useRefElement(); // Every time the source element renders, inspect the ID it actually used
        // (whether it was ours or not isn't up to us, it's up to the component)
        // so this is how we notify the referencer component of changes

        s(() => {
          const element = getElement();

          if (element) {
            children.getAt("referencer").subInfo.setUsedId(element.id);
            setUsedId(element.id);
          }
        });

        useManagedChild({
          managedChild: {
            index: "source",
            subInfo: {
              setUsedId: setUsedIdLocal
            }
          }
        });

        const useRandomIdSourceElementProps = q$1(function (p) {
          p.id || (p.id = backupRandomId);
          return useRefElementProps(p);
        }, []);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdSourceElementProps
        };
      }, []);
      const useRandomIdReferencerElement = q$1(idPropName => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId()); // Whatever ID was most recently used by the actual "id" prop of the source element

        useEnsureStability(idPropName);

        useManagedChild({
          managedChild: {
            index: "referencer",
            subInfo: {
              setUsedId: setUsedIdLocal
            }
          }
        });

        const useRandomIdReferencerElementProps = q$1(function (_ref2) {
          let {
            [idPropName]: givenId,
            ...p
          } = _ref2;

          if (givenId && usedId) {
            if (givenId != usedId) {
              if (!mismatchErrorRef.current) {
                mismatchErrorRef.current = true;
                console.error(`Multiple mis-matched IDs were provided for the ${idPropName} prop: the child explicitly specified ${givenId} in its  ${idPropName} prop, but the parent told this child to use ${usedId} (the parent's ID).`);
              }
            }
          }

          return useMergedProps(p, {
            [idPropName]: usedId
          });
        }, [usedId]);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdReferencerElementProps
        };
      }, []);
      return {
        randomId: {
          usedId,
          getUsedId
        },
        ...managedChildrenReturnType,
        useRandomIdSourceElement,
        useRandomIdReferencerElement
      };
    }

    let pulse = "vibrate" in navigator && navigator.vibrate instanceof Function ? () => navigator.vibrate(10) : () => {};

    function excludes(target, exclude) {
      if (exclude !== null && exclude !== void 0 && exclude[target]) return true;
      return false;
    }
    /**
     * selection.containsNode doesn't account for selection.isCollapsed,
     * so here's a workaround for that.
     *
     * We also only look for the selection end to only catch the
     * essense of a non-existant "selectionstop" event.
     *
     * @param element
     * @returns
     */


    function nodeSelectedTextLength(element) {
      if (element && element instanceof Node) {
        const selection = window.getSelection();

        for (let i = 0; i < ((_selection$rangeCount = selection === null || selection === void 0 ? void 0 : selection.rangeCount) !== null && _selection$rangeCount !== void 0 ? _selection$rangeCount : 0); ++i) {
          var _selection$rangeCount;

          const range = selection.getRangeAt(i);

          if (element.contains(range.endContainer) && !(selection !== null && selection !== void 0 && selection.isCollapsed)) {
            return selection.toString().length;
          }
        }
      }

      return 0;
    }
    /**
     * Adds the necessary event handlers to create a "press"-like event for
     * buttons and anything else that's "click/tap/press/touch"-able.
     *
     * Notably, the following cases are covered:
     * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
     * * Double-clicks won't select text.
     * * Conversely, manually selecting text won't invoke a press.
     * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
     * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClickSync
     * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
     */


    function usePressEventHandlers(onClickSync, exclude) {
      const {
        useRefElementProps,
        getElement
      } = useRefElement({}); // A button can be activated in multiple ways, so on the off chance
      // that multiple are triggered at once, we only *actually* register
      // a press once all of our "on" signals have turned back to "off".
      // We approximate this by just incrementing when active, and
      // decrementing when deactivated.
      //
      // As an emergency failsafe, when the element loses focus,
      // this is reset back to 0.

      const [active, setActive, getActive] = useState(0);
      const forceUpdate = useForceUpdate(); // If we the current text selection changes to include this element
      // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
      // because its only purpose was selecting text, not clicking buttons.
      //
      // To catch this, any time the text selection includes us while in the middle
      // of a click, this flag is set, which cancels the activation of a press.
      // The flag is reset any time the selection is empty or the button is
      // no longer active.

      const [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
      const pseudoActive = active && textSelectedDuringActivationStartTime == null;
      useGlobalHandler(document, "selectionchange", _ => {
        setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
      });
      useEffect(() => {
        if (active == 0) setTextSelectedDuringActivationStartTime(null);
      }, [active == 0]);
      const onActiveStart = useStableCallback(_ => {
        setActive(a => ++a);
      });
      const onActiveStop = useStableCallback(e => {
        setActive(a => Math.max(0, --a));
        const currentTime = new Date();
        const timeDifference = textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime;
        const charactersSelected = nodeSelectedTextLength(getElement()); // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
        // then this isn't a press event.
        // TODO: This should measure glyphs instead of characters.

        if (charactersSelected > 1 || (timeDifference !== null && timeDifference !== void 0 ? timeDifference : 0) > 250 && charactersSelected >= 1) {
          e.preventDefault();
          return;
        }

        if (getActive() <= 0) {
          handlePress(e);
          forceUpdate(); // TODO: Remove when issue resolved https://github.com/preactjs/preact/issues/3731
        }
      });
      const handlePress = useStableCallback(e => {
        if (onClickSync) {
          // Note: The element is focused here because of iOS Safari.
          //
          // It's always iOS Safari.
          //
          // iOS Safari (tested on 12) downright refuses to allow 
          // elements to be manually focused UNLESS it happens within
          // an event handler like this.  It also doesn't focus
          // buttons by default when clicked, tapped, etc.
          //
          // If it becomes problematic that button-likes explicitly become
          // focused when they are pressed, then an alternative solution for
          // the question of "how do menu buttons keep their menus open"
          // and other focus-related nonsense needs to be figured out.
          //
          // For iOS Safari.
          //
          const element = getElement();
          if (element && "focus" in element) element === null || element === void 0 ? void 0 : element.focus(); // Whatever the browser was going to do with this event,
          // forget it. We're turning it into a "press" event.

          e.preventDefault(); // Also stop anyone else from listening to this event,
          // since we're explicitly handling it.
          // (Notably, this allows labels to wrap inputs, with them
          // both having press event handlers, without double-firing)

          e.stopPropagation(); // Haptic feedback for this press event

          try {
            // The default implementation doesn't throw,
            // but we should guard against user implementations that could.
            pulse();
          } finally {
            // Actually call our handler.
            onClickSync(e);
          }
        }
      });
      const onMouseDown = excludes("click", exclude) ? undefined : e => {
        // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
        // but also don't prevent the user from selecting that text manually if they really want to
        // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
        if (e.detail > 1) e.preventDefault();
        if (e.button === 0) onActiveStart(e);
      };
      const onMouseUp = excludes("click", exclude) ? undefined : e => {
        if (e.button === 0 && active > 0) onActiveStop(e);
      };

      const onBlur = _ => {
        setActive(0);
      };

      const onMouseLeave = excludes("click", exclude) ? undefined : onBlur;
      const onKeyDown = excludes("space", exclude) && excludes("enter", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync && !excludes("space", exclude)) {
          // We don't actually activate it on a space keydown
          // but we do preventDefault to stop the page from scrolling.
          onActiveStart(e);
          e.preventDefault();
        }

        if (e.key == "Enter" && !excludes("enter", exclude)) {
          e.preventDefault();
          onActiveStart(e);
          onActiveStop(e);
        }
      };
      const onKeyUp = excludes("space", exclude) ? undefined : e => {
        if (e.key == " " && !excludes("space", exclude)) onActiveStop(e);
      };

      const onClick = e => {
        e.preventDefault();

        if (e.detail > 1) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
      };

      return useRefElementProps({
        onKeyDown,
        onKeyUp,
        onBlur,
        onMouseDown,
        onMouseUp,
        onMouseLeave,
        onClick,
        style: textSelectedDuringActivationStartTime != null ? {
          cursor: "text"
        } : undefined,
        ...{
          "data-pseudo-active": pseudoActive ? "true" : undefined
        }
      });
    }
    function useAriaButton(_ref) {
      let {
        tag,
        pressed,
        onPress,
        disabled
      } = _ref;
      debugLog("useAriaButton");

      function useAriaButtonProps(_ref2) {
        let {
          "aria-pressed": ariaPressed,
          tabIndex,
          role,
          ...p
        } = _ref2;
        const props = useMergedProps(usePressEventHandlers(e => {
          var _ref3;

          return (_ref3 = disabled ? null : onPress) === null || _ref3 === void 0 ? void 0 : _ref3(enhanceEvent(e, {
            pressed: pressed == null ? null : !pressed
          }));
        }, undefined), p);
        const baseProps = {
          role,
          tabIndex,
          "aria-pressed": ariaPressed !== null && ariaPressed !== void 0 ? ariaPressed : pressed === true ? "true" : pressed === false ? "false" : undefined
        };
        const buttonProps = { ...baseProps,
          disabled: disabled && disabled != "soft" ? true : false,
          "aria-disabled": disabled === 'soft' ? 'true' : undefined
        };
        const divProps = { ...baseProps,
          tabIndex: tabIndex !== null && tabIndex !== void 0 ? tabIndex : disabled === "hard" ? -1 : 0,
          role: role !== null && role !== void 0 ? role : "button",
          "aria-disabled": disabled ? "true" : undefined
        };

        switch (tag) {
          case "button":
            return useMergedProps(buttonProps, props);

          default:
            return useMergedProps(divProps, props);
        }
      }

      return {
        useAriaButtonProps
      };
    }

    //export interface UseAriaAccordionSectionHeaderReturnType<E extends Element> { useAriaAccordionSectionHeaderProps: (props: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; }
    //export type UseAriaAccordionSectionBody<E extends Element> = () => UseAriaAccordionSectionBodyReturnType<E>;
    //export interface UseAriaAccordionSectionBodyReturnType<E extends Element> { useAriaAccordionSectionBodyProps: (props: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; }

    function useAriaAccordion(_ref) {
      let {
        accordion: {
          initialIndex
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref;
      debugLog("useAriaAccordian");
      const [_currentFocusedIndex, setCurrentFocusedIndex, getCurrentFocusedIndex] = useState(null);
      const mcReturnType = useManagedChildren({
        managedChildren: {
          onChildrenMountChange: useStableCallback((m, u) => {
            ocmc2();
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(m, u);
          }),
          onAfterChildLayoutEffect
        }
      });
      const {
        useManagedChild,
        managedChildren: {
          children
        }
      } = mcReturnType;
      const navigateToFirst = q$1(() => {
        changeTabbedIndex(0);
      }, []);
      const navigateToLast = q$1(() => {
        changeTabbedIndex(children.getHighestIndex());
      }, []);
      const navigateToPrev = q$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) - 1);
      }, []);
      const navigateToNext = q$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) + 1);
      }, []);
      const linearReturnType = useLinearNavigation({
        linearNavigation: {
          navigateToFirst,
          navigateToLast,
          navigateToNext,
          navigateToPrev,
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection: navigationDirection !== null && navigationDirection !== void 0 ? navigationDirection : "block"
        }
      });
      const {
        useLinearNavigationProps
      } = linearReturnType;
      const {
        changeIndex: changeExpandedIndex,
        getCurrentIndex: _getCurrentExpandedIndex
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "open",
        closestFit: false
      });
      const {
        changeIndex: changeTabbedIndex,
        getCurrentIndex: _getTabbedIndex,
        reevaluateClosestFit: ocmc2
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "tabbed",
        closestFit: true,
        onIndexChange: q$1(i => {
          if (i != null) {
            var _children$getAt;

            (_children$getAt = children.getAt(i)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.focus();
          }
        }, [])
      });
      const useAriaAccordionSection = q$1(_ref2 => {
        var _ref3;

        let {
          button: {
            disabled
          },
          accordionSection: {
            open: openFromUser,
            tagButton
          },
          managedChildren: {
            index
          },
          hasFocus: {
            onFocusedInnerChanged,
            ...hasFocus
          }
        } = _ref2;
        debugLog("useAriaAccordianSection");
        const [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
        const {
          useRandomIdSourceElement: useBodyAsSourceId,
          useRandomIdReferencerElement: useHeaderAsReferencerId,
          randomId: {
            usedId: bodyId,
            getUsedId: getBodyId
          }
        } = useRandomId({
          randomId: {
            prefix: "aria-accordion-section-body-"
          },
          managedChildren: {
            onAfterChildLayoutEffect: null,
            onChildrenMountChange: null
          }
        });
        const {
          useRandomIdSourceElement: useHeaderAsSourceId,
          useRandomIdReferencerElement: useBodyAsReferencerId,
          randomId: {
            usedId: headerId,
            getUsedId: getHeaderId
          }
        } = useRandomId({
          randomId: {
            prefix: "aria-accordion-section-header-"
          },
          managedChildren: {
            onAfterChildLayoutEffect: null,
            onChildrenMountChange: null
          }
        });
        const {
          useRandomIdSourceElementProps: useBodyAsSourceIdProps
        } = useBodyAsSourceId();
        const {
          useRandomIdReferencerElementProps: useBodyAsReferencerIdProps
        } = useBodyAsReferencerId("aria-labelledby");
        const {
          useRandomIdSourceElementProps: useHeaderAsSourceIdProps
        } = useHeaderAsSourceId();
        const {
          useRandomIdReferencerElementProps: useHeaderAsReferencerIdProps
        } = useHeaderAsReferencerId("aria-controls");
        const open = (_ref3 = openFromUser !== null && openFromUser !== void 0 ? openFromUser : openFromParent) !== null && _ref3 !== void 0 ? _ref3 : false; //const getOpen = useStableGetter(!!open);

        const getIndex = useStableGetter(index);
        const {
          getElement: getHeaderElement,
          useRefElementProps: useHeaderRefElementProps
        } = useRefElement({});
        const {
          getElement: getBodyElement,
          useRefElementProps: useBodyRefElementProps
        } = useRefElement({});
        const focus = q$1(() => {
          var _getHeaderElement;

          if (getCurrentFocusedIndex() != null) (_getHeaderElement = getHeaderElement()) === null || _getHeaderElement === void 0 ? void 0 : _getHeaderElement.focus();
        }, []);
        const openRef = A({
          get: () => !!getOpenFromParent(),
          set: open => {
            setOpenFromParent(open);

            if (open) {
              const bodyElement = getBodyElement();
              setCurrentFocusedIndex(getIndex());

              if (bodyElement) {
                queueMicrotask(() => bodyElement.focus());
              }
            }
          },
          isValid: returnTrue
        });
        const tabbedRef = A({
          get: () => getCurrentFocusedIndex() == getIndex(),
          set: open => {
            if (open) setCurrentFocusedIndex(getIndex());
          },
          isValid: returnTrue
        });

        useManagedChild({
          managedChild: {
            index: index,
            flags: {
              open: openRef.current,
              tabbed: tabbedRef.current
            },
            subInfo: {
              focus,
              getOpenFromParent,
              setOpenFromParent
            } // info: { index, setOpenFromParent, getOpenFromParent, focus, flags: { open: openRef.current, tabbed: tabbedRef.current } }

          }
        });

        function useAriaAccordionSectionHeaderProps(_ref4) {
          var _ref5;

          let {
            ["aria-expanded"]: ariaExpanded,
            ["aria-disabled"]: ariaDisabled,
            ...props
          } = _ref4;

          //const onFocus = () => { changeTabbedIndex(index); }
          const onPress = () => {
            if (getOpenFromParent()) changeExpandedIndex(null);else changeExpandedIndex(index);
          };

          props.tabIndex = 0;
          const {
            useAriaButtonProps
          } = useAriaButton({
            tag: tagButton,
            disabled,
            onPress
          });
          const retB = useAriaButtonProps(props); //const retB = useMergedProps<HeaderElement>(usePressEventHandlers<HeaderElement>(onClick, undefined), props);

          const {
            useHasFocusProps
          } = useHasFocus({ ...hasFocus,
            onFocusedInnerChanged: useStableCallback((focused, prev) => {
              onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);
              if (focused) changeTabbedIndex(index);
            })
          }); //const ret3: h.JSX.HTMLAttributes<HeaderElement>
          //    = useMergedProps<HeaderElement>(retD, { onFocus });

          return useHasFocusProps(useLinearNavigationProps(useHeaderAsSourceIdProps(useHeaderAsReferencerIdProps({
            "aria-expanded": ((_ref5 = ariaExpanded !== null && ariaExpanded !== void 0 ? ariaExpanded : open) !== null && _ref5 !== void 0 ? _ref5 : false).toString(),
            "aria-disabled": ariaDisabled !== null && ariaDisabled !== void 0 ? ariaDisabled : open ? "true" : undefined,
            ...useHeaderRefElementProps(retB)
          }))));
        }

        function useAriaAccordionSectionBodyProps(_ref6) {
          var _ret2$tabIndex;

          let {
            role,
            ...props
          } = _ref6;
          const ret1 = useBodyAsReferencerIdProps({
            role: role !== null && role !== void 0 ? role : "region",
            ...props
          });
          const ret2 = useBodyAsSourceIdProps(ret1);
          (_ret2$tabIndex = ret2.tabIndex) !== null && _ret2$tabIndex !== void 0 ? _ret2$tabIndex : ret2.tabIndex = -1;
          return useBodyRefElementProps(ret2);
        }

        return {
          accordionSection: {
            expanded: open,
            focused: getCurrentFocusedIndex() == index,
            bodyId,
            headerId,
            getBodyId,
            getHeaderId
          },
          useAriaAccordionSectionHeaderProps,
          useAriaAccordionSectionBodyProps
        };
      }, []);
      return {
        managedChildren: mcReturnType.managedChildren,
        accordion: {
          changeExpandedIndex
        },
        useAriaAccordionSection
      };
    }

    /**
     * Adds an ID and "aria-labelledby" for two elements, an "input" element and a "label" element.
     *
     * Returns the `useReferencedIdProps` hooks if you need to also add other ID-referencer attributes, like `for`
     *
     * @see useInputLabel
     */

    function useLabel(_ref) {
      let {
        label: {
          prefixInput,
          prefixLabel,
          tagInput,
          tagLabel
        }
      } = _ref;
      const {
        useRandomIdSourceElement: useLabelAsSourceId,
        useRandomIdReferencerElement: useLabelAsReferencerId,
        randomId: {
          usedId: labelId,
          getUsedId: getLabelId
        }
      } = useRandomId({
        randomId: {
          prefix: prefixLabel
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useInputAsSourceId,
        useRandomIdReferencerElement: useInputAsReferencerId,
        randomId: {
          usedId: inputId,
          getUsedId: getInputId
        }
      } = useRandomId({
        randomId: {
          prefix: prefixInput
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElementProps: useLabelAsSourceIdProps
      } = useLabelAsSourceId();
      const {
        useRandomIdSourceElementProps: useInputAsSourceIdProps
      } = useInputAsSourceId();
      const {
        useRandomIdReferencerElementProps: useLabelAsReferencerIdProps
      } = useLabelAsReferencerId("aria-labelledby");
      const {
        useRandomIdReferencerElementProps: useInputAsReferencerIdProps
      } = useInputAsReferencerId("for");
      const isSyntheticLabel = tagInput != "input" || tagLabel != "label";
      const useLabelLabel = q$1(function useLabelLabel() {
        return {
          useLabelLabelProps: props => {
            const propsWithoutFor = useLabelAsSourceIdProps(props);
            const propsWithFor = useInputAsReferencerIdProps(propsWithoutFor);
            if (tagLabel == "label" && tagInput == "input") return propsWithFor;else return propsWithoutFor;
          }
        };
      }, [isSyntheticLabel]);
      const useLabelInput = q$1(function useLabelInput() {
        return {
          useLabelInputProps: _ref2 => {
            let {
              "aria-labelledby": ariaLabelledby,
              ...props
            } = _ref2;
            console.assert(!ariaLabelledby);
            const propsWithoutAriaLabelledBy = useInputAsSourceIdProps(props);
            const propsWithAriaLabelledBy = useLabelAsReferencerIdProps(propsWithoutAriaLabelledBy);
            if (isSyntheticLabel && !props["aria-label"]) return propsWithAriaLabelledBy;else return propsWithoutAriaLabelledBy;
          }
        };
      }, [isSyntheticLabel]);
      return {
        useLabelInput,
        useLabelLabel,
        label: {
          labelId,
          inputId,
          getLabelId,
          getInputId
        }
      };
    }

    const handlesInput = (tag, labelPosition, which) => {
      if (labelPosition === "separate") {
        if (which === "input-element") return true;else if (which === "label-element") return tag != "input";
      } else if (labelPosition === "wrapping") {
        if (which === "input-element") return false;
        if (which == "label-element") return true;
      }
    };
    /**
     * Handles label type (wrapping or separate) for checkboxes, radios, switches, etc.
     *
     * If it's a toggleable click-thing with a label (that can also be clicked), then it's a checkbox-like.
     * @param param0
     * @returns
     */


    function useCheckboxLike(_ref3) {
      let {
        checkboxLike: {
          checked,
          disabled,
          labelPosition,
          role,
          onInput
        },
        label: {
          tagInput,
          tagLabel
        }
      } = _ref3;
      const stableOnInput = useStableCallback(e => {
        e.preventDefault();
        onInput === null || onInput === void 0 ? void 0 : onInput(e);
      });
      const {
        useLabelInput: useILInput,
        useLabelLabel: useILLabel,
        label
      } = useLabel({
        label: {
          prefixLabel: "aria-checkbox-label-",
          prefixInput: "aria-checkbox-input-",
          tagInput: tagInput,
          tagLabel: tagLabel
        }
      });
      const {
        getElement: getLabelElement,
        useRefElementProps: useLabelRefElementProps
      } = useRefElement();
      const {
        getElement: getInputElement,
        useRefElementProps: useInputRefElementProps
      } = useRefElement();
      const useCheckboxLikeInputElement = q$1(function useCheckboxInputElement() {
        const tag = tagInput;
        const {
          useLabelInputProps: useILInputProps
        } = useILInput();
        const {
          useRefElementProps,
          getElement
        } = useRefElement({}); // onClick and onChange are a bit messy, so we need to
        // *always* make sure that the visible state is correct
        // after all the event dust settles.
        // See https://github.com/preactjs/preact/issues/2745,
        // and https://github.com/preactjs/preact/issues/1899#issuecomment-525690194

        s(() => {
          const element = getElement();

          if (element && tag == "input") {
            element.indeterminate = checked === "mixed";
            element.checked = checked === true;
          }
        }, [tag, checked]);
        return {
          getInputElement: getElement,
          useCheckboxLikeInputElementProps
        };

        function useCheckboxLikeInputElementProps(_ref4) {
          let { ...p0
          } = _ref4;
          // For some reason, Chrome won't fire onInput events for radio buttons that are tabIndex=-1??
          // Needs investigating, but onInput works fine in Firefox
          // TODO
          let props = usePressEventHandlers(disabled || !handlesInput(tag, labelPosition, "input-element") ? undefined : stableOnInput, undefined);
          if (tag == "input") props.onInput = e => e.preventDefault();
          props = useRefElementProps(useILInputProps(props));

          if (labelPosition == "wrapping") {
            // Because the wrapped label handles all interactions,
            // we need to make sure this element can't be interacted with
            // even if it's an input element.
            props.inert = true;
            props.tabIndex = -1;
            props.role = "presentation";
            props["aria-hidden"] = "true";

            props.onFocus = _ => {
              var _getLabelElement;

              return (_getLabelElement = getLabelElement()) === null || _getLabelElement === void 0 ? void 0 : _getLabelElement.focus();
            };
          } else {
            if (tag === "input") {
              props.checked = checked === true;
            } else {
              props.role = role;
              props.tabIndex = 0;
              props["aria-checked"] = checked === "mixed" ? "mixed" : checked === true ? "true" : undefined;
            }

            props["aria-disabled"] = disabled.toString();
          } // Make sure that label clicks can't affect the checkbox while it's disabled


          props.onClick = disabled ? e => {
            e.preventDefault();
          } : props.onClick;
          return useInputRefElementProps(useMergedProps(p0, props));
        }
      }, [useILInput, role, labelPosition, disabled, checked, tagInput]);
      const useCheckboxLikeLabelElement = q$1(function useCheckboxLabelElement() {
        const tag = tagLabel;
        const {
          useLabelLabelProps: useILLabelProps
        } = useILLabel();

        function useCheckboxLikeLabelElementProps(_ref5) {
          let { ...p0
          } = _ref5;
          const newProps = usePressEventHandlers(disabled || !handlesInput(tag, labelPosition, "label-element") ? undefined : stableOnInput, undefined);

          if (labelPosition == "wrapping") {
            if (p0.tabIndex == null) newProps.tabIndex = 0;
            if (p0.role == null) newProps.role = role;
            newProps["aria-disabled"] = disabled.toString();
            newProps["aria-checked"] = checked.toString();
          } // Just make sure that label clicks can't affect the checkbox while it's disabled


          newProps.onClick = disabled ? e => {
            e.preventDefault();
          } : newProps.onClick;
          return useLabelRefElementProps(useMergedProps(newProps, useILLabelProps(p0)));
        }

        return {
          useCheckboxLikeLabelElementProps
        };
      }, [useILLabel, disabled, checked, role, labelPosition, tagLabel]);
      return {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        checkboxLike: {
          getLabelElement,
          getInputElement
        },
        label
      };
    }

    function useAriaCheckbox(_ref) {
      let {
        checkboxLike,
        label,
        checkbox
      } = _ref;
      debugLog("useAriaCheckbox");
      const {
        disabled,
        labelPosition,
        checked
      } = checkboxLike;
      const {
        tagInput,
        tagLabel
      } = label;
      const {
        onInput
      } = checkbox;

      const onInputEnhanced = e => onInput === null || onInput === void 0 ? void 0 : onInput(enhanceEvent(e, {
        checked: !checked
      }));

      const {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        ...checkboxLikeRest
      } = useCheckboxLike({
        checkboxLike: {
          role: "checkbox",
          checked,
          onInput: onInputEnhanced,
          disabled,
          labelPosition
        },
        label
      });
      const useCheckboxInputElement = q$1(function useCheckboxInputElement() {
        const tag = tagInput;
        const {
          useCheckboxLikeInputElementProps
        } = useCheckboxLikeInputElement();
        return {
          useCheckboxInputElementProps
        };

        function useCheckboxInputElementProps(_ref2) {
          var _props$checked;

          let { ...p0
          } = _ref2;
          const props = useCheckboxLikeInputElementProps(p0);
          (_props$checked = props.checked) !== null && _props$checked !== void 0 ? _props$checked : props.checked = !!checked;
          if (tag == "input") props.type = "checkbox";
          return props;
        }
      }, [useCheckboxLikeInputElement, checked, labelPosition, disabled, tagInput]);
      const useCheckboxLabelElement = q$1(function useCheckboxLabelElement() {
        const {
          useCheckboxLikeLabelElementProps
        } = useCheckboxLikeLabelElement();

        function useCheckboxLabelElementProps(_ref3) {
          let { ...props
          } = _ref3;
          return useCheckboxLikeLabelElementProps(props);
        }

        return {
          useCheckboxLabelElementProps
        };
      }, [useCheckboxLikeLabelElement, disabled, labelPosition, tagLabel]);
      return {
        useCheckboxInputElement,
        useCheckboxLabelElement,
        ...checkboxLikeRest
      };
    }

    /**
     *
     *
     * @param param0
     * @returns
     */

    function useCheckboxGroup(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      debugLog("useAriaCheckboxGroup"); //const onUpdateChildren = useStableCallback(onUpdateChildrenUnstable ?? (() => {}));

      const {
        useListNavigationChild,
        useListNavigationProps,
        ...listReturnType
      } = useListNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children
        }
      } = listReturnType; //const [uncheckedCount, setUnheckedCount] = useState(0);
      // Keep track of all child IDs, and any time any of them change, 
      // generate a new string with all of them concatenated together
      // (but only once per render);

      const allIds = A(new Set());
      const [ariaControls, setAriaControls] = useState("");
      const [updateIndex, setIdUpdateIndex] = useState(0);
      const [checkedCount, setCheckedCount] = useState(0);
      const checkedIndices = A(new Set()); //const [selfIsChecked, setSelfIsChecked, getSelfIsChecked] = useState<boolean | "mixed">(false);

      const getSelfIsCheckedUnstable = q$1(() => {
        const percentage = checkedCount / (children.getHighestIndex() + 1);
        return percentage <= 0 ? false : percentage >= 1 ? true : "mixed";
      }, [checkedCount]);
      const getSelfIsCheckedStable = useStableCallback(getSelfIsCheckedUnstable);
      const [setParentCheckboxChecked, setSetParentCheckboxChecked] = useState(null);
      useEffect(() => {
        setParentCheckboxChecked === null || setParentCheckboxChecked === void 0 ? void 0 : setParentCheckboxChecked(checkedCount == 0 ? false : checkedCount == children.getHighestIndex() + 1 ? true : "mixed");
      }, [setParentCheckboxChecked, checkedCount]); // If the user has changed the parent checkbox's value, then this ref holds a memory of what values were held before.
      // Otherwise, it's null when the last input was from a child checkbox. 
      //const savedCheckedValues = useRef<Map<number, boolean | "mixed"> | null>(null);

      const useCheckboxGroupParentInput = q$1(_ref2 => {
        let {
          checkbox,
          checkboxLike,
          label
        } = _ref2;
        debugLog("useAriaCheckboxGroupParent");
        const {
          disabled,
          labelPosition
        } = checkboxLike;
        const {
          tagInput,
          tagLabel
        } = label;
        const [checked, setChecked] = useState(false);
        useEffect(() => {
          setSetParentCheckboxChecked(() => setChecked);
        }, []);
        const {
          useCheckboxInputElement,
          useCheckboxLabelElement
        } = useAriaCheckbox({
          checkboxLike: {
            labelPosition,
            checked,
            disabled
          },
          label: {
            tagInput,
            tagLabel
          },
          checkbox: {
            onInput: onCheckboxGroupParentInput2
          }
        });
        const {
          useCheckboxInputElementProps
        } = useCheckboxInputElement();
        const {
          useCheckboxLabelElementProps
        } = useCheckboxLabelElement();
        return {
          useCheckboxGroupParentInputProps: function useCheckboxGroupParentInputProps(props) {
            const ret = useMergedProps(useMergedProps({}, {
              "aria-controls": ariaControls,
              onInput: tagInput == "input" ? e => e.preventDefault() : undefined
            }), props);
            return useCheckboxInputElementProps(labelPosition == "separate" ? ret : props);
          },
          useCheckboxGroupParentLabelProps: function useCheckboxGroupParentLabelProps(props) {
            const ret = useMergedProps(useMergedProps({}, {
              "aria-controls": ariaControls
            }), props);
            return useCheckboxLabelElementProps(labelPosition == "wrapping" ? ret : props);
          }
        };
      }, [ariaControls]);
      const onCheckboxGroupParentInput2 = q$1(e => {
        e.preventDefault();
        const selfIsChecked = getSelfIsCheckedStable();
        const nextChecked = selfIsChecked === false ? "mixed" : selfIsChecked === "mixed" ? true : false;
        let willChangeAny = false;
        children.forEach(child => willChangeAny || (willChangeAny = child.subInfo.subInfo.subInfo.checked != child.subInfo.subInfo.subInfo.getLastUserChecked()));
        children.forEach(child => {
          var _child$subInfo$subInf, _child$subInfo$subInf2;

          let checked;

          if (nextChecked == "mixed") {
            if (willChangeAny) checked = child.subInfo.subInfo.subInfo.getLastUserChecked();else checked = true;
          } else {
            checked = nextChecked;
          }

          (_child$subInfo$subInf = (_child$subInfo$subInf2 = child.subInfo.subInfo.subInfo).onInput) === null || _child$subInfo$subInf === void 0 ? void 0 : _child$subInfo$subInf.call(_child$subInfo$subInf2, enhanceEvent(e, {
            checked
          }));
        });
        /*if (selfIsChecked === true || (selfIsChecked === false && savedCheckedValues.current == null)) {
            return onUpdateChildren(enhanceEvent(e, { childrenChecked: false }));
        }
        else if (selfIsChecked === "mixed") {
              savedCheckedValues.current = new Map();
            children.forEach(child => {
                savedCheckedValues.current!.set(child.index, child.getLastUserChecked());
            })
              return onUpdateChildren(enhanceEvent(e, { childrenChecked: true }));
        }
        else {
            return onUpdateChildren(enhanceEvent(e, { childrenChecked: savedCheckedValues.current ?? true }));
        }*/
      }, []);
      const notifyChecked = q$1((index, checked) => {
        if (checked === true) {
          if (!checkedIndices.current.has(index)) {
            setCheckedCount(c => c + 1);
            checkedIndices.current.add(index);
          }
        } else {
          if (checkedIndices.current.has(index)) {
            setCheckedCount(c => c - 1);
            checkedIndices.current.delete(index);
          }
        }
      }, []);
      /*useEffect(() => {
          let percentage = checkedCount / managedChildren.length;
          setSelfIsChecked(percentage <= 0 ? false : percentage >= 1 ? true : "mixed")
      }, [setSelfIsChecked, managedChildren.length, checkedCount]);*/

      /*const useCheckboxGroupParentProps = useCallback((props: h.JSX.HTMLAttributes<InputElement>) => {
          return
      }, [ariaControls]);*/

      useEffect(() => {
        setAriaControls(Array.from(allIds.current).join(" "));
      }, [updateIndex]);
      const useCheckboxGroupChild = q$1(function (_ref3) {
        let {
          asCheckbox,
          asCheckboxGroupChild
        } = _ref3;
        debugLog("useAriaCheckboxGroupChild", asCheckboxGroupChild.managedChild.index, asCheckbox.checkboxLike.checked);
        const {
          checkbox: {
            onInput
          },
          checkboxLike: {
            checked,
            disabled,
            labelPosition
          },
          label: {
            tagInput,
            tagLabel
          }
        } = asCheckbox;
        const {
          managedChild: {
            index
          }
        } = asCheckboxGroupChild; //labelPosition ??= "separate";

        const [getLastUserChecked, setLastUserChecked] = usePassiveState(null, returnFalse$1);
        const {
          useCheckboxInputElement,
          useCheckboxLabelElement,
          ...checkboxReturnType
        } = useAriaCheckbox({
          checkbox: {
            onInput: useStableCallback(e => {
              setLastUserChecked(e[EventDetail].checked);
              onInput === null || onInput === void 0 ? void 0 : onInput(e);
            })
          },
          checkboxLike: {
            checked,
            labelPosition,
            disabled
          },
          label: {
            tagInput,
            tagLabel
          }
        });
        const {
          label: {
            inputId,
            labelId
          }
        } = checkboxReturnType; //const getChecked = useStableGetter(checked);

        const controlsId = labelPosition == "separate" ? inputId : labelId;
        useEffect(() => {
          allIds.current.add(controlsId);
          setIdUpdateIndex(i => ++i);
          return () => {
            allIds.current.delete(controlsId);
            setIdUpdateIndex(i => ++i);
          };
        }, [controlsId]);
        useEffect(() => {
          notifyChecked(index, checked);
        }, [index, checked]);
        const {
          useListNavigationChildProps,
          ...listNavigationReturnType
        } = useListNavigationChild({
          subInfo: {
            getLastUserChecked,
            onInput,
            checked
          },
          listNavigation: { ...asCheckboxGroupChild.listNavigation
          },
          managedChild: asCheckboxGroupChild.managedChild,
          rovingTabIndex: asCheckboxGroupChild.rovingTabIndex
        });
        return {
          checkboxLike: checkboxReturnType.checkboxLike,
          label: checkboxReturnType.label,
          rovingTabIndex: listNavigationReturnType.rovingTabIndex,
          useCheckboxGroupChildInputProps: props => {
            const {
              useCheckboxInputElementProps
            } = useCheckboxInputElement();
            const ret = useCheckboxInputElementProps(props);
            const ret2 = useListNavigationChildProps(useListNavigationProps(ret));
            return labelPosition == "separate" ? ret2 : ret;
          },
          useCheckboxGroupChildLabelProps: props => {
            const {
              useCheckboxLabelElementProps
            } = useCheckboxLabelElement();
            const ret = useCheckboxLabelElementProps(props);
            const ret2 = useListNavigationChildProps(useListNavigationProps(ret));
            return labelPosition == "wrapping" ? ret2 : ret;
          }
        };
      }, []);
      return {
        useCheckboxGroupChild,
        useCheckboxGroupParentInput,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        managedChildren: listReturnType.managedChildren,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation,
        checkboxGroup: {
          parentIsChecked: getSelfIsCheckedUnstable(),
          parentPercentChecked: checkedCount / (children.getHighestIndex() + 1)
        }
      };
    }

    /**
     * Adds event handlers for a modal-like soft-dismiss interaction.
     *
     * That is, any clicks or taps outside of the given component,
     * or any time the Escape key is pressed within the component,
     * (with various browser oddities regarding clicks on blank or inert areas handled)
     * the component will request to close itself.
     *
     * Of course, if you don't do anything in the `onClose` function,
     * it won't be a soft dismiss anymore.
     *
     * @param param0
     * @returns
     */

    function useSoftDismiss(_ref) {
      let {
        softDismiss: {
          onClose,
          getElements,
          open
        },
        activeElement: {
          onLastActiveElementChange,
          ...activeElement
        }
      } = _ref;
      const stableOnClose = useStableCallback(onClose);
      const stableGetElements = useStableCallback(getElements);
      const getOpen = useStableGetter(open);
      const {
        getDocument
      } = activeElement;
      const onBackdropClick = q$1(function onBackdropClick(e) {
        if (!getOpen()) return;
        const document = getDocument(); // Basically, "was this event fired on the root-most element, or at least an element not contained by the modal?"
        // Either could be how the browser handles these sorts of "interacting with nothing" events.

        if (e.target == (document === null || document === void 0 ? void 0 : document.documentElement)) {
          stableOnClose("backdrop");
        }

        let elements = stableGetElements();

        if (elements && e.target instanceof Element) {
          if (!Array.isArray(elements)) elements = [elements];
          let foundInsideClick = false;

          for (const element of elements) {
            if (element && element.contains(e.target)) {
              foundInsideClick = true;
              break;
            }
          }

          if (!foundInsideClick) {
            onClose("backdrop");
          }
        }
      }, []);
      useActiveElement({ ...activeElement,
        onLastActiveElementChange: q$1((newElement, prev) => {
          onLastActiveElementChange === null || onLastActiveElementChange === void 0 ? void 0 : onLastActiveElementChange(newElement, prev);
          let validFocusableElements = stableGetElements();

          if (validFocusableElements) {
            if (!Array.isArray(validFocusableElements)) validFocusableElements = [validFocusableElements];

            for (const focusable of validFocusableElements) {
              if (focusable !== null && focusable !== void 0 && focusable.contains(newElement)) return;
            }
          }

          onClose("lost-focus");
        }, [])
      });
      const {
        useRefElementProps
      } = useRefElement({
        onElementChange: q$1(e => {
          const document = e === null || e === void 0 ? void 0 : e.ownerDocument;
          const window = document === null || document === void 0 ? void 0 : document.defaultView; // Since everything else is inert, we listen for captured clicks on the window
          // (we don't use onClick since that doesn't fire when clicked on empty/inert areas)
          // Note: We need a *separate* touch event on mobile Safari, because
          // it doesn't let click events bubble or be captured from traditionally non-interactive elements,
          // but touch events work as expected.

          const mouseDown = e => {
            if (getOpen()) onBackdropClick(e);
          };

          const touchStart = e => {
            if (getOpen()) onBackdropClick(e);
          };

          const keyDown = e => {
            if (e.key === "Escape") {
              stableOnClose("escape");
            }
          };

          window === null || window === void 0 ? void 0 : window.addEventListener("mousedown", mouseDown, {
            capture: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("touchstart", touchStart, {
            capture: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("keydown", keyDown);
          return () => {
            window === null || window === void 0 ? void 0 : window.removeEventListener("mousedown", mouseDown);
            window === null || window === void 0 ? void 0 : window.removeEventListener("touchstart", touchStart);
            window === null || window === void 0 ? void 0 : window.removeEventListener("keydown", keyDown);
          };
        }, [])
      });
      return {
        useSoftDismissProps: q$1(props => useRefElementProps(props), []),
        softDismiss: {
          onBackdropClick
        }
      };
    }
    /**
     * A generic modal hook, used by modal dialogs, but can also
     * be used by anything that's modal with a backdrop.
     * @param param0
     * @returns
     */

    function useModal(_ref2) {
      var _focusSelf;

      let {
        modal: {
          bodyIsOnlySemantic: descriptive,
          focusSelf
        },
        softDismiss: {
          onClose,
          open
        },
        activeElement
      } = _ref2;
      const {
        useRefElementProps: useTitleRefElementProps,
        getElement: getTitleElement
      } = useRefElement({});
      const {
        useRefElementProps: useBodyRefElementProps,
        getElement: getBodyElement
      } = useRefElement({});
      (_focusSelf = focusSelf) !== null && _focusSelf !== void 0 ? _focusSelf : focusSelf = () => {
        if (descriptive) {
          var _getBodyElement;

          (_getBodyElement = getBodyElement()) === null || _getBodyElement === void 0 ? void 0 : _getBodyElement.focus();
        } else {
          const titleElement = getTitleElement();
          if (titleElement) titleElement.focus();
        } //const elementToFocus = getTitleElement() ?? getBodyElement()

      };
      const stableOnClose = useStableCallback(onClose);
      const stableFocusSelf = useStableCallback(focusSelf); //const [modalDescribedByBody, setModalDescribedByBody] = useState(false);

      useHideScroll(open);
      const {
        useRandomIdSourceElement: useModalIdAsSource,
        useRandomIdReferencerElement: useModalIdAsReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-modal-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useBodyIdAsSource,
        useRandomIdReferencerElement: useBodyIdReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-modal-body-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useTitleIdAsSource,
        useRandomIdReferencerElement: useTitleIdReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-modal-title-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRefElementProps: useModalRefElement,
        getElement: getModalElement
      } = useRefElement({});
      const {
        softDismiss: {
          onBackdropClick
        },
        useSoftDismissProps
      } = useSoftDismiss({
        softDismiss: {
          onClose: stableOnClose,
          getElements: getModalElement,
          open: !!open
        },
        activeElement
      });
      const useModalBackdrop = q$1(function useModalBackdrop() {
        function useModalBackdropProps(props) {
          return useMergedProps({
            onPointerUp: onBackdropClick
          }, props);
        }

        return {
          useModalBackdropProps
        };
      }, []);

      const useModalFocusContainerProps = function (props) {
        const {
          useFocusTrapProps
        } = useFocusTrap({
          trapActive: open
        });
        return useFocusTrapProps(props);
      };

      const useModalProps = function (_ref3) {
        let {
          "aria-modal": ariaModal,
          role,
          ...p0
        } = _ref3;
        const {
          useRandomIdSourceElementProps: useModalIdAsSourceProps
        } = useModalIdAsSource();
        const {
          useRandomIdReferencerElementProps: useTitleIdReferencerElementProps
        } = useTitleIdReferencerElement("aria-labelledby");
        const {
          useRandomIdReferencerElementProps: useBodyIdReferencerElementProps
        } = useBodyIdReferencerElement("aria-describedby");
        console.assert(!ariaModal);
        const {
          useFocusTrapProps
        } = useFocusTrap({
          trapActive: open
        });
        s(() => {
          if (open) stableFocusSelf();
        }, [open]);
        const p1 = useBodyIdReferencerElementProps(p0);
        const p2 = useModalIdAsSourceProps(p1);
        const pFinal = useTitleIdReferencerElementProps(p2);
        return useFocusTrapProps(useSoftDismissProps(useMergedProps(useModalRefElement({
          role: role || "dialog"
        }), descriptive ? pFinal : p2)));
      };

      const useModalTitle = q$1(function useModalTitle() {
        const {
          useRandomIdSourceElementProps: useTitleIdAsSourceProps
        } = useTitleIdAsSource();

        const useModalTitleProps = function (props) {
          var _props$tabIndex;

          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1;
          return useTitleRefElementProps(useTitleIdAsSourceProps(props));
        };

        return {
          useModalTitleProps
        };
      }, []);
      const useModalBody = q$1(function useModalBody() {
        const {
          useRandomIdSourceElementProps: useBodyIdAsSourceProps
        } = useBodyIdAsSource();
        const {
          useRandomIdReferencerElementProps: useModalIdAsReferencerElementProps
        } = useModalIdAsReferencerElement("data-modal-id");

        const useModalBodyProps = function (props) {
          var _props$tabIndex2;

          (_props$tabIndex2 = props.tabIndex) !== null && _props$tabIndex2 !== void 0 ? _props$tabIndex2 : props.tabIndex = -1;
          return useBodyRefElementProps(useBodyIdAsSourceProps(useModalIdAsReferencerElementProps(props)));
        };

        return {
          useModalBodyProps
        };
      }, []);
      return {
        useModalProps,
        useModalTitle,
        useModalBody,
        useModalBackdrop,
        useModalFocusContainerProps,
        softDismiss: {
          onBackdropClick
        }
      };
    }
    /**
     * Allows for hiding the scroll bar of the root HTML element
     * without shifting the layout of the page more than adding a fow pixels
     * of padding to the root element if necessary.
     * @param hideScroll
     */

    function useHideScroll(hideScroll) {
      const [getScrollbarWidth, setScrollbarWidth] = usePassiveState(null);
      const [getScrollbarHeight, setScrollbarHeight] = usePassiveState(null);
      s(() => {
        if (hideScroll) {
          // When scrolling is resumed, we'll need to restore the original scroll positions
          // so we need to keep this information around
          const originalScrollTop = document.documentElement.scrollTop;
          const originalScrollLeft = document.documentElement.scrollLeft; // Measure the width of the page (minus the scrollbar)

          const widthWithScrollBar = document.documentElement.scrollWidth;
          const heightWithScrollBar = document.documentElement.scrollHeight; // Apply a class that hides the scrollbar.

          document.documentElement.classList.add("document-scroll-hidden"); // In case multiple things are locking scroll, keep track of how many are doing that
          // (just add 1 on enable, subtract 1 on disable)

          document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") + 1).toString(); // Measure the new width without a scrollbar 
          // so we can take the difference as the scrollbar width.

          const widthWithoutScrollBar = document.documentElement.scrollWidth;
          const heightWithoutScrollBar = document.documentElement.scrollHeight;
          let scrollbarWidth = widthWithoutScrollBar - widthWithScrollBar;
          let scrollbarHeight = heightWithoutScrollBar - heightWithScrollBar; // Failsafe -- if this measuring trick does something unexpected, just ignore it

          if (scrollbarWidth > 80) scrollbarWidth = 0;
          if (scrollbarHeight > 80) scrollbarHeight = 0; // Make our measurements available as CSS properties for general use

          document.documentElement.style.setProperty("--root-scrollbar-width", `${scrollbarWidth}px`);
          document.documentElement.style.setProperty("--root-scrollbar-height", `${scrollbarHeight}px`);
          document.documentElement.style.setProperty("--root-scrollstop-top", `${originalScrollTop}px`);
          document.documentElement.style.setProperty("--root-scrollstop-left", `${originalScrollLeft}px`);
          setScrollbarWidth(scrollbarWidth);
          setScrollbarHeight(scrollbarHeight);
          return () => {
            // Undo all the things we just did
            document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") - 1).toString();

            if (document.documentElement.dataset["scrollHiders"] == "0") {
              // If we were the last scroll-locking thing to stop, then remove the class that stops scrolling.
              document.documentElement.removeAttribute("data-scroll-hiders");
              document.documentElement.classList.remove("document-scroll-hidden"); // Also, restore the original scroll position
              // We do this by forcing the scroll behavior to not be smooth
              // (it's instant if nothing is set to smooth, https://www.w3.org/TR/cssom-view/#scrolling),
              // scrolling, then restoring the original scroll behavior 
              // (which was probably already auto anyway, but just to be safe)

              const originalScrollBehavior = document.documentElement.style.scrollBehavior;
              document.documentElement.style.scrollBehavior = "auto";
              document.documentElement.scrollTo({
                top: originalScrollTop,
                left: originalScrollLeft,
                behavior: "auto"
              });
              document.documentElement.style.scrollBehavior = originalScrollBehavior;
            }
          };
        }
      }, [hideScroll]);
      return {
        getScrollbarWidth,
        getScrollbarHeight
      };
    }

    function useAriaDialog(_ref) {
      let {
        softDismiss: {
          open
        },
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        dialog: {
          onClose
        },
        activeElement
      } = _ref;
      debugLog("useAriaDialog"); // TODO: Differences between dialog and modal go here, presumably.
      // Non-modal dialogs need to be able to be repositioned, etc.

      const {
        useModalBackdrop,
        useModalBody,
        useModalProps,
        useModalTitle,
        softDismiss: {
          onBackdropClick
        },
        useModalFocusContainerProps
      } = useModal({
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        softDismiss: {
          onClose,
          open
        },
        activeElement
      });
      const useDialogBackdrop = q$1(() => {
        const {
          useModalBackdropProps
        } = useModalBackdrop();
        return {
          useDialogBackdropProps: useModalBackdropProps
        };
      }, [useModalBackdrop]);
      const useDialogBody = q$1(() => {
        const {
          useModalBodyProps
        } = useModalBody();
        return {
          useDialogBodyProps: useModalBodyProps
        };
      }, [useModalBackdrop]);
      const useDialogProps = useModalProps;
      const useDialogTitle = q$1(() => {
        const {
          useModalTitleProps
        } = useModalTitle();
        return {
          useDialogTitleProps: useModalTitleProps
        };
      }, [useModalTitle]);
      return {
        useDialogProps,
        useDialogTitle,
        useDialogBody,
        useDialogBackdrop,
        useDialogFocusContainerProps: useModalFocusContainerProps,
        softDismiss: {
          onBackdropClick
        }
      };
    }

    function useAriaListboxSingle(_ref) {
      let {
        listboxSingle: {
          selectionMode,
          tagLabel,
          tagList,
          onSelect,
          ..._lbs
        },
        singleSelection: {
          selectedIndex,
          ...ss
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          ...rti
        },
        typeaheadNavigation: { ...tn
        },
        childrenHaveFocus: { ...chf
        }
      } = _ref;
      debugLog("useAriaListboxSingle", selectedIndex);
      const {
        useLabelInput,
        useLabelLabel,
        ...labelReturnType
      } = useLabel({
        label: {
          prefixLabel: "aria-listbox-label-",
          prefixInput: "aria-listbox-",
          tagInput: tagList,
          tagLabel: tagLabel
        }
      });
      const {
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps,
        ...listReturnType
      } = useListNavigationSingleSelection({
        childrenHaveFocus: { ...chf
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti,
          onTabbableIndexChange: useStableCallback(i => {
            onTabbableIndexChange === null || onTabbableIndexChange === void 0 ? void 0 : onTabbableIndexChange(i);

            if (selectionMode == "focus") {
              var _children$getAt;

              const target = (_children$getAt = children.getAt(i)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.getElement();
              if (target) onSelect === null || onSelect === void 0 ? void 0 : onSelect({
                target,
                currentTarget: target,
                [EventDetail]: {
                  selectedIndex: i
                }
              });
            }
          })
        },
        singleSelection: { ...ss,
          selectedIndex
        },
        typeaheadNavigation: tn
      });
      const {
        managedChildren: {
          children
        }
      } = listReturnType;
      const {
        useLabelInputProps
      } = useLabelInput();
      const stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
      const useListboxSingleItem = q$1(_ref2 => {
        let {
          listboxSingleItem: {
            disabled
          },
          listNavigation,
          managedChild,
          rovingTabIndex,
          hasFocus
        } = _ref2;
        debugLog("useAriaListboxSingleItem", managedChild.index);
        const {
          rovingTabIndex: rti_ret,
          singleSelection: ss_ret,
          useListNavigationSingleSelectionChildProps
        } = useListNavigationSingleSelectionChild({
          managedChild,
          listNavigation,
          rovingTabIndex,
          hasFocus,
          subInfo: {}
        });
        const index = managedChild.index;
        s(() => {
          const element = rti_ret.getElement();

          if (element && rti_ret.tabbable && selectionMode == "focus") {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
          }
        }, [rti_ret.tabbable, selectionMode, index]);
        return {
          useListboxSingleItemProps,
          rovingTabIndex: rti_ret,
          singleSelection: ss_ret
        };

        function useListboxSingleItemProps(props) {
          var _ss_ret$selected;

          const newProps = usePressEventHandlers(disabled ? null : e => {
            const element = rti_ret.getElement();
            if (element) stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selectedIndex: index
              }
            });
            e.preventDefault();
          }, undefined);
          props.role = "option"; //props["aria-setsize"] = (children.getHighestIndex() + 1).toString();
          //props["aria-posinset"] = (info.index + 1).toString();

          props["aria-selected"] = ((_ss_ret$selected = ss_ret.selected) !== null && _ss_ret$selected !== void 0 ? _ss_ret$selected : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useListNavigationSingleSelectionChildProps(useMergedProps(newProps, props));
        }
      }, [useListNavigationSingleSelectionChild, selectionMode]);
      const useListboxSingleLabel = q$1(function useListboxSingleLabel() {
        function useListboxSingleLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxSingleLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxSingleItem,
        useListboxSingleProps,
        useListboxSingleLabel,
        ...listReturnType,
        ...labelReturnType
        /*label: labelReturnType.label,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        managedChildren: listReturnType.managedChildren,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation*/

      };

      function useListboxSingleProps(props) {
        props.role = "listbox";
        return useListNavigationSingleSelectionProps(useLabelInputProps(props));
      }
    }
    function useListboxGroup() {
      const {
        useRandomIdReferencerElement,
        useRandomIdSourceElement
      } = useRandomId({
        randomId: {
          prefix: "listbox-multi-group"
        },
        managedChildren: {}
      });
      const {
        useRandomIdSourceElementProps
      } = useRandomIdSourceElement();
      const {
        useRandomIdReferencerElementProps
      } = useRandomIdReferencerElement("aria-labelledby");

      const useListboxGroupHeadingProps = props => {
        return useRandomIdSourceElementProps(props);
      };

      const useListboxGroupContainerProps = _ref3 => {
        let {
          role,
          ...props
        } = _ref3;
        return useRandomIdReferencerElementProps({
          role: warnOnOverwrite("useListboxMultiGroupProps", "role", role, "group"),
          ...props
        });
      };

      return {
        useListboxGroupContainerProps,
        useListboxGroupHeadingProps
      };
    }

    /*export interface UseListboxMultiReturnType<LabelElement extends Element, ListElement extends Element, ListItemElement extends Element> extends Omit<UseListNavigationReturnType<ListElement, ListItemElement, {}, never>, "useListNavigationChild" | "useListNavigationProps"> {
        useListboxMultiItem: UseListboxMultiItem<ListItemElement>;
        useListboxMultiProps: (props: h.JSX.HTMLAttributes<ListElement>) => h.JSX.HTMLAttributes<ListElement>;
        useListboxMultiLabel: () => { useListboxMultiLabelProps: (props: h.JSX.HTMLAttributes<LabelElement>) => h.JSX.HTMLAttributes<LabelElement>; }
    }*/

    function useAriaListboxMulti(_ref) {
      let {
        listboxMulti: {
          tagLabel,
          tagList
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          ...rti
        },
        typeaheadNavigation: { ...tn
        }
      } = _ref;
      debugLog("useAriaListboxMulti"); //const { useHasFocusProps, getFocusedInner } = useHasFocus<ListElement>({});

      const {
        useLabelInput,
        useLabelLabel
      } = useLabel({
        label: {
          prefixLabel: "aria-listbox-label-",
          prefixInput: "aria-listbox-",
          tagLabel: tagLabel,
          tagInput: tagList
        }
      });
      const listReturnType = useListNavigation({
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti,
          onTabbableIndexChange: useStableCallback(i => {
            onTabbableIndexChange === null || onTabbableIndexChange === void 0 ? void 0 : onTabbableIndexChange(i);
            /*if (selectionMode == "focus") {
                const target = (children.getAt(i!)?.subInfo.getElement());
                if (target)
                    onSelect?.({ target, currentTarget: target, [EventDetail]: { selectedIndex: i! } });
            }*/
          })
        },
        typeaheadNavigation: tn
      });
      const {
        useListNavigationChild,
        useListNavigationProps,
        rovingTabIndex: {
          setTabbableIndex
        }
      } = listReturnType;
      const {
        useLabelInputProps
      } = useLabelInput();
      const [getShiftHeld, setShiftHeld] = usePassiveState(null, returnFalse$1);
      const useListboxMultiItem = q$1(_ref2 => {
        let {
          listboxMultiItem: {
            selected,
            disabled,
            onSelect
          },
          managedChild,
          listNavigation: ls,
          rovingTabIndex: rti
        } = _ref2;
        debugLog("useAriaListboxMultiItem", managedChild.index, selected);
        const getSelected = useStableGetter(selected);
        const {
          useRefElementProps,
          getElement
        } = useRefElement({});
        const stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
        const {
          useListNavigationChildProps,
          rovingTabIndex: rti2_ret
        } = useListNavigationChild({
          listNavigation: ls,
          managedChild,
          rovingTabIndex: rti,
          subInfo: {
            selected,
            onSelect
          }
        });
        useLayoutEffect(() => {
          const element = getElement();

          if (element && getShiftHeld()) {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selected: true
              }
            });
          }
        }, [rti2_ret.tabbable]);
        return {
          useListboxMultiItemProps,
          listboxMultiItem: {
            getSelected,
            tabbable: rti2_ret.tabbable
          },
          rovingTabIndex: rti2_ret
        };

        function useListboxMultiItemProps(props) {
          var _rti2_ret$tabbable;

          const newProps = usePressEventHandlers(disabled ? null : e => {
            setTabbableIndex(managedChild.index, false);
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({ ...e,
              [EventDetail]: {
                selected: !getSelected()
              }
            });
            e.preventDefault();
          }, {});
          props.role = "option"; //props["aria-setsize"] = (childCount).toString();
          //props["aria-posinset"] = (info.index + 1).toString();

          props["aria-selected"] = ((_rti2_ret$tabbable = rti2_ret.tabbable) !== null && _rti2_ret$tabbable !== void 0 ? _rti2_ret$tabbable : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useRefElementProps(useListNavigationChildProps(useMergedProps(newProps, props)));
        }
      }, [useListNavigationChild]);
      const useListboxMultiLabel = q$1(function useListboxMultiLabel() {
        function useListboxMultiLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxMultiLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxMultiItem,
        useListboxMultiProps,
        useListboxMultiLabel,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation,
        managedChildren: listReturnType.managedChildren
      };

      function useListboxMultiProps(props) {
        props.role = "listbox";
        props["aria-multiselectable"] = "true";
        return useListNavigationProps(useLabelInputProps(useMergedProps({
          onKeyDown,
          onKeyUp,
          onfocusout: onFocusOut
        }, props)));
      }

      function onKeyDown(e) {
        if (e.key == "Shift") setShiftHeld(true);
      }

      function onKeyUp(e) {
        if (e.key == "Shift") setShiftHeld(false);
      }

      function onFocusOut(_) {
        setShiftHeld(false);
      }
    }

    //export type UseMenuChildParameters<I extends UseMenuChildInfo> = I;

    /**
     * A menu is a popup control that contains a list of menu items, and that's it.
     * It has very well-defined logic for managing those items as the menu's state changes.
     *
     * A MenuBase is just the "popup" part without the "list of menu items" part. It can
     * (really, must) have interactive controls, but these controls are allowed to be more
     * free-form. This means that, like a dialog, you must tell this hook
     * where within the popup to send focus when opened (for a menu it's just the first
     * menu item, but with custom content you'll need to provide this).
     *
     */

    function useMenuSurface(_ref) {
      var _intersectionObserver;

      let {
        softDismiss,
        menuSurface: {
          sendFocusToMenu,
          role
        },
        hasFocusButton,
        hasFocusSurface,
        activeElement
      } = _ref;
      debugLog("useAriaMenuSurface"); //const sendFocusWithinMenu = useStableCallback(sendFocusToMenu);
      //const [focusTrapActive, setFocusTrapActive] = useState<null | boolean>(null);

      const {
        open,
        onClose: userOnClose
      } = softDismiss;
      const onClose = useStableCallback(reason => {
        if (reason != "lost-focus") {
          const opener = getOpenerElement();
          if (opener && "focus" in opener) opener.focus({
            preventScroll: true
          });
        }

        return userOnClose(reason);
      });
      useEnsureStability("useMenuSurface", onClose, role, sendFocusToMenu);
      const getIsOpen = useStableGetter(open);
      const intersectionObserver = A(null);
      const [getSurfaceFullyVisible, setSurfaceFullyVisible] = usePassiveState(null, returnFalse$1);
      (_intersectionObserver = intersectionObserver.current) !== null && _intersectionObserver !== void 0 ? _intersectionObserver : intersectionObserver.current = new IntersectionObserver((entries, observer) => {
        for (const entry of entries) {
          setSurfaceFullyVisible(entry.intersectionRatio >= 1);
        }
      }, {
        root: null,
        threshold: [0, 1]
      });
      const [, setOpenerElement, getOpenerElement] = useState(null);
      const {
        useHasFocusProps: useMenuBaseHasFocusProps,
        ...surfaceHasFocus
      } = useHasFocus({ ...hasFocusSurface
      });
      useRefElement({
        onElementChange: setOpenerElement
      });
      const {
        useHasFocusProps: useButtonHasFocusProps,
        ...buttonHasFocus
      } = useHasFocus({ ...hasFocusButton
      });
      const {
        useRandomIdSourceElement,
        useRandomIdReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-menu-"
        },
        managedChildren: {}
      });
      const {
        useRandomIdSourceElementProps
      } = useRandomIdSourceElement();
      const {
        useRandomIdReferencerElementProps
      } = useRandomIdReferencerElement("aria-controls");
      const {
        getElement: getButtonElement,
        useRefElementProps: useButtonRefElementProps
      } = useRefElement({
        onElementChange: setOpenerElement
      });
      const {
        getElement: getMenuElement,
        useRefElementProps: useMenuBaseRefElementProps
      } = useRefElement({});
      const {
        useSoftDismissProps,
        ...softDismissReturn
      } = useSoftDismiss({
        softDismiss: { ...softDismiss,
          getElements: () => [getButtonElement(), getMenuElement()]
        },
        activeElement
      });

      const useMenuSurfaceProps = props => {
        function onKeyDown(e) {
          const open = getIsOpen();

          if (e.key == "Escape" && open) {
            onClose("escape");
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.preventDefault();
          }
        }

        return useSoftDismissProps(useMenuBaseHasFocusProps(useMenuBaseRefElementProps(useMergedProps({
          onKeyDown
        }, props))));
      };

      const useMenuSurfaceButtonProps = props => {
        props["aria-expanded"] = warnOnOverwrite("useMenuSurfaceButtonProps", "aria-expanded", open, open.toString());
        props["aria-haspopup"] = warnOnOverwrite("useMenuSurfaceButtonProps", "aria-haspopup", role, role);
        return useButtonRefElementProps(useButtonHasFocusProps(useRandomIdReferencerElementProps(props)));
      };

      s(() => {
        if (open === true) {
          sendFocusToMenu === null || sendFocusToMenu === void 0 ? void 0 : sendFocusToMenu();
          setTimeout(() => {
            if (!getSurfaceFullyVisible()) {
              var _getMenuElement;

              (_getMenuElement = getMenuElement()) === null || _getMenuElement === void 0 ? void 0 : _getMenuElement.scrollIntoView();
            }
          });
        }
      }, [open]);

      function useMenuSurfaceChildProps(props) {
        props.role = role;
        return useRandomIdSourceElementProps(props);
      }

      return {
        useMenuSurfaceChildProps,
        useMenuSurfaceSentinel: q$1(() => {
          debugLog("useAriaMenuSurfaceSentinel");
          const {
            useSentinelProps: useMenuSentinelProps,
            ...rest
          } = useFocusSentinel({
            focusSentinel: {
              open: open === true,
              onClose: () => onClose("escape"),
              sendFocusToMenu
            }
          });
          return {
            useMenuSentinelProps,
            ...rest
          };
        }, [open, onClose]),
        useMenuSurfaceProps,
        useMenuSurfaceButtonProps,
        menuSurface: {
          getActiveElement: buttonHasFocus.getActiveElement,
          getLastActiveElement: buttonHasFocus.getLastActiveElement,
          getButtonElement: buttonHasFocus.getElement,
          getButtonFocused: buttonHasFocus.getFocused,
          getButtonFocusedInner: buttonHasFocus.getFocusedInner,
          getButtonLastFocused: buttonHasFocus.getLastFocused,
          getButtonLastFocusedInner: buttonHasFocus.getLastFocusedInner,
          getSurfaceElement: surfaceHasFocus.getElement,
          getSurfaceFocused: surfaceHasFocus.getFocused,
          getSurfaceFocusedInner: surfaceHasFocus.getFocusedInner,
          getSurfaceLastFocused: surfaceHasFocus.getLastFocused,
          getSurfaceLastFocusedInner: surfaceHasFocus.getLastFocusedInner,
          getWindowFocused: buttonHasFocus.getWindowFocused
        },
        ...softDismissReturn //getMenuBaseLastFocusedInner,
        //getMenuBaseButtonLastFocusedInner,
        //open,
        //onOpen,
        //onClose

      };
    } // A focus sentinal is a hidden but focusable element that comes at the start or end 
    // of the out-of-place-focusable component that, when activated or focused over, closes the component
    // (if focused within 100ms of the open prop changing, instead of
    // closing, focusing the sentinel immediately asks it to focus itself).
    // This exists for things like menus which can have focus but also need a way to return
    // to whatever out-of-place parent they came from when naturally tabbed out of (as opposed
    // to dialogs which loop back around when tabbed out of). While mouse users can click out of a menu
    // and keyboard users can escape to close a menu, screen readers and other input methods 
    // that don't use those two would become stuck.

    function useFocusSentinel(_ref2) {
      let {
        focusSentinel: {
          open,
          onClose,
          sendFocusToMenu
        }
      } = _ref2;
      debugLog("useAriaFocusSentinel");
      const getSendFocusWithinMenu = useStableGetter(sendFocusToMenu);
      const stableOnClose = useStableCallback(onClose);
      const [firstSentinelIsActive, setFirstSentinelIsActive] = useState(false);
      useTimeout({
        callback: () => {
          setFirstSentinelIsActive(open);
        },
        timeout: 100,
        triggerIndex: `${open}-${firstSentinelIsActive}`
      });
      const onFocus = firstSentinelIsActive ? () => stableOnClose() : () => {
        var _getSendFocusWithinMe;

        return (_getSendFocusWithinMe = getSendFocusWithinMenu()) === null || _getSendFocusWithinMe === void 0 ? void 0 : _getSendFocusWithinMe();
      };

      const onClick = () => stableOnClose();

      return {
        useSentinelProps: function (_ref3) {
          let {
            tabIndex,
            ...p
          } = _ref3;
          return useMergedProps({
            onFocus,
            onClick,
            tabIndex: warnOnOverwrite("useFocusSentinel", "tabIndex", tabIndex, 0)
          }, p);
        }
      };
    }
    function useAriaMenu(_ref4) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        menuSurface,
        rovingTabIndex,
        softDismiss,
        typeaheadNavigation,
        menu,
        hasFocusButton,
        hasFocusSurface,
        activeElement
      } = _ref4;
      debugLog("useAriaMenu");
      const {
        onOpen
      } = menu;
      const {
        open,
        onClose
      } = softDismiss;
      const {
        useListNavigationChild,
        useListNavigationProps,
        ...useListNavReturn
      } = useListNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children
        }
      } = useListNavReturn;
      const {
        /*useMenuSentinel,
        useMenuBaseButtonProps,
        useMenuBaseProps,
        open,
        onOpen,
        onClose: _onClose,*/
        useMenuSurfaceButtonProps,
        useMenuSurfaceProps,
        useMenuSurfaceSentinel,
        useMenuSurfaceChildProps,
        ...menuRest
      } = useMenuSurface({
        menuSurface: { ...menuSurface,
          role: "menu",
          sendFocusToMenu: q$1(() => {
            var _children$getAt;

            return (_children$getAt = children.getAt(0)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.focusSelf();
          }, [])
        },
        softDismiss,
        hasFocusButton,
        hasFocusSurface,
        activeElement //sendFocusWithinMenu: focusMenu ?? (() => { })

      });

      const useMenuButtonProps = p => {
        const pressProps = usePressEventHandlers(() => {
          if (open) onClose === null || onClose === void 0 ? void 0 : onClose("escape");else onOpen === null || onOpen === void 0 ? void 0 : onOpen();
        }, {});
        const props = useMenuSurfaceButtonProps(p);
        return useMergedProps(pressProps, props);
      };

      const useMenuItem = q$1(_ref5 => {
        let {
          listNavigation,
          managedChild,
          rovingTabIndex
        } = _ref5;
        debugLog("useAriaMenuItem", managedChild.index);
        const {
          useListNavigationChildProps,
          ...listNavRet
        } = useListNavigationChild({
          listNavigation,
          managedChild,
          rovingTabIndex,
          subInfo: {}
        });

        function useMenuItemProps(_ref6) {
          let { ...props
          } = _ref6;
          props.role = "menuitem";
          return useMergedProps({}, useListNavigationChildProps(props));
        }

        return {
          useMenuItemProps,
          ...listNavRet
        };
      }, []);

      function useMenuProps(props) {
        return useListNavigationProps(useMenuSurfaceChildProps(props));
      }

      return {
        useMenuProps,
        useMenuSurfaceProps,
        useMenuButtonProps,
        useMenuItem,
        useMenuSentinel: useMenuSurfaceSentinel,
        //useMenuSubmenuItem,
        ...useListNavReturn,
        ...menuRest
        /*focusMenu,
          currentTypeahead,
        invalidTypeahead,
          managedChildren,*/

      };
    }

    /*
    export function useAriaTabs<TabListElement extends Element, TabElement extends Element, PanelElement extends Element, LabelElement extends Element>({ tabPanels: { managedChildren: { onChildrenMountChange: ocmc, ...tabPanelsManagedChildren } } }: UseAriaTabsParameters): UseAriaTabsReturnTypeWithHooks<TabListElement, TabElement, PanelElement, LabelElement> {
        const {
            useListNavigationSingleSelectionChild,
            useListNavigationSingleSelectionProps
        } = useListNavigationSingleSelection<TabListElement, TabElement, TabInfo, never>({
            childrenHaveFocus: {},
            linearNavigation: {},
            listNavigation: {},
            managedChildren: {},
            rovingTabIndex: {},
            singleSelection: {},
            typeaheadNavigation: {}
         });

        const useTab = useCallback(() => {}, []);
        const useTabPanel = useCallback(() => {});
        function useTabListProps(props: h.JSX.HTMLAttributes<TabListElement>) { return useListNavigationSingleSelectionProps(props); }
        function useTabLabelProps() {}

        return {

        }
        
    }*/

    function useAriaTabs(_ref) {
      let {
        tabPanels: {
          managedChildren: {
            onChildrenMountChange: ocmc,
            ...tabPanelsManagedChildren
          }
        }
      } = _ref;
      debugLog("useAriaTabs");
      const baseId = generateRandomId("aria-tabs-"); //const getTabListId = useCallback(() => { return baseId + "-tab-list"; }, []);

      const getTabId = q$1(index => {
        return baseId + "-tab-" + index;
      }, []);
      const getPanelId = q$1(index => {
        return baseId + "-panel-" + index;
      }, []); // Used for the panels, not the tabs in the tablist.
      // Those are in useAriaTabList itself.

      const {
        useManagedChild,
        ...managedChildrenRet
      } = useManagedChildren({
        managedChildren: { ...tabPanelsManagedChildren,
          onChildrenMountChange: useStableCallback((m, u) => {
            ocmc === null || ocmc === void 0 ? void 0 : ocmc(m, u);
            reevaluateClosestFit();
          })
        }
      });
      const {
        changeIndex,
        getCurrentIndex: getVisibleIndex,
        reevaluateClosestFit
      } = useChildrenFlag({
        children: managedChildrenRet.managedChildren.children,
        closestFit: false,
        initialIndex: null,
        key: "visible"
      }); //const { useRandomIdReferencerElement, useRandomIdSourceElement } = useRandomId({ randomId: { prefix: "aria-tabs-" }, managedChildren: { onAfterChildLayoutEffect: null, onChildrenMountChange: null } });

      const {
        useLabelInput,
        useLabelLabel
      } = useLabel({
        label: {
          prefixInput: "",
          prefixLabel: "",
          tagInput: "div",
          tagLabel: "div"
        }
      });
      const useAriaTabListLabel = q$1(() => {
        const {
          useLabelLabelProps
        } = useLabelLabel();

        function useAriaTabListLabelProps(props) {
          return useLabelLabelProps(props);
        }

        return {
          useAriaTabListLabelProps
        };
      }, [useLabelLabel]);
      const useAriaTabList = q$1(_ref2 => {
        let {
          childrenHaveFocus,
          tabs: {
            onSelectedIndexChange
          },
          linearNavigation,
          listNavigation,
          managedChildren: tabListManagedChildren,
          rovingTabIndex,
          singleSelection,
          typeaheadNavigation
        } = _ref2;
        debugLog("useAriaTabList");
        const stableOnSelectedIndexChange = useStableCallback(onSelectedIndexChange);
        const {
          useListNavigationSingleSelectionChild,
          useListNavigationSingleSelectionProps,
          ...listNavRet1
        } = useListNavigationSingleSelection({
          linearNavigation,
          listNavigation,
          managedChildren: tabListManagedChildren,
          rovingTabIndex,
          singleSelection,
          typeaheadNavigation,
          childrenHaveFocus
        });
        useEffect(() => {
          changeIndex(singleSelection.selectedIndex);
        }, [singleSelection.selectedIndex]);
        const {
          useLabelInputProps
        } = useLabelInput();
        const useAriaTab = q$1(_ref3 => {
          let {
            listNavigation,
            managedChild,
            rovingTabIndex,
            hasFocus
          } = _ref3;
          debugLog("useAriaTab", managedChild.index);
          const {
            useListNavigationSingleSelectionChildProps,
            ...listNavRet2
          } = useListNavigationSingleSelectionChild({
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo: {},
            hasFocus
          });
          const {
            singleSelection: {
              selected
            },
            rovingTabIndex: {
              tabbable
            }
          } = listNavRet2;

          const useAriaTabProps = _ref4 => {
            let {
              role,
              "aria-controls": ariaControls,
              "aria-selected": ariaSelected,
              ...props
            } = _ref4;
            const panelId = getPanelId(managedChild.index);
            const tabId = getTabId(managedChild.index);
            const pressProps = usePressEventHandlers(e => {
              stableOnSelectedIndexChange(enhanceEvent(e, {
                selectedIndex: managedChild.index
              }));
            }, {});
            return useListNavigationSingleSelectionChildProps(useMergedProps({
              role: warnOnOverwrite("useAriaTab", "role", role, "tab"),
              "aria-controls": warnOnOverwrite("useAriaTab", "ariaControls", ariaControls, panelId),
              "aria-selected": warnOnOverwrite("useAriaTab", "ariaSelected", ariaSelected, selected ? "true" : undefined),
              "data-tabbable": tabbable.toString(),
              id: tabId
            }, useMergedProps(pressProps, props)));
          };

          return {
            useAriaTabProps,
            ...listNavRet2
          };
        }, [useLabelInput, useListNavigationSingleSelectionChild]);

        const useAriaTabListProps = _ref5 => {
          let {
            role,
            "aria-orientation": ariaOrientation,
            ...props
          } = _ref5;
          return useListNavigationSingleSelectionProps(useLabelInputProps(useMergedProps({
            role: warnOnOverwrite("useAriaTabList", "role", role, "tablist"),
            "aria-orientation": ariaOrientation !== null && ariaOrientation !== void 0 ? ariaOrientation : "horizontal"
          }, props)));
        };

        return {
          tabList: listNavRet1,
          useAriaTabListProps,
          useAriaTab
        };
      }, [useLabelInput]);
      const useAriaTabPanel = q$1(_ref6 => {
        let {
          managedChild: {
            flags,
            ...managedChild
          }
        } = _ref6;
        debugLog("useAriaTabPanel", managedChild.index); //const [correspondingTabId, setCorrespondingTabId] = useState<string | null>(null);

        const [isVisible, setIsVisible, getIsVisible] = useState(getVisibleIndex() == managedChild.index);
        const visibleRef = A({
          get: getIsVisible,
          set: setIsVisible,
          isValid: returnTrue
        });
        useManagedChild({
          managedChild: { ...managedChild,
            flags: {
              visible: visibleRef.current,
              ...flags
            },
            subInfo: {}
          }
        });
        const panelId = getPanelId(managedChild.index);
        const tabId = getTabId(managedChild.index);

        const useAriaTabPanelProps = _ref7 => {
          let {
            role,
            "aria-labelledby": ariaLabelledBy,
            id,
            ...props
          } = _ref7;
          return useMergedProps({
            role: warnOnOverwrite("useAriaTabPanelProps", "role", role, "tabpanel"),
            "aria-labelledby": warnOnOverwrite("useAriaTabPanelProps", "aria-labelledby", ariaLabelledBy, tabId),
            id: warnOnOverwrite("useAriaTabPanelProps", "id", id, panelId)
          }, props);
        };

        return {
          useAriaTabPanelProps,
          tabPanel: {
            visible: isVisible,
            getVisible: getIsVisible
          }
        };
      }, []);
      return {
        useAriaTabListLabel,
        useAriaTabList,
        useAriaTabPanel,
        tabPanels: managedChildrenRet
      };
    }

    function returnFalse() {
      return false;
    }

    function useAriaTooltip(_ref) {
      var _mouseoverDelay, _mouseoutDelay, _focusDelay;

      let {
        mouseoverDelay,
        mouseoutDelay,
        focusDelay
      } = _ref;
      debugLog("useAriaTooltip");
      (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
      (_mouseoutDelay = mouseoutDelay) !== null && _mouseoutDelay !== void 0 ? _mouseoutDelay : mouseoutDelay = 40;
      (_focusDelay = focusDelay) !== null && _focusDelay !== void 0 ? _focusDelay : focusDelay = 1; // The escape key should close tooltips, but do nothing else.
      // (i.e. closing a tooltip in a dialog MUST NOT close the dialog too)
      // TODO: Tooltips are, effectively, always the topmost component,
      // so we can just have them listen to and swallow all "Escape"
      // key presses before anyone else. For a more general popup,
      // or a tooltip in a tooltip (!!) a different solution would be needed.

      useGlobalHandler(document, "keydown", e => {
        if (getOpen() && e.key === "Escape" && !e.defaultPrevented) {
          e.preventDefault();
          e.stopImmediatePropagation();
          setOpen(false);
          setTriggerHoverDelayCorrected(false);
          setTooltipHoverDelayCorrected(false);
          setTriggerFocusedDelayCorrected(false);
          setTooltipFocusedDelayCorrected(false);
        }
      }, {
        capture: true
      });
      const [open, setOpen, getOpen] = useState(false);
      const {
        useRandomIdSourceElement,
        //: useTooltipIdProps, 
        useRandomIdReferencerElement //: useTooltipIdReferencingProps 

      } = useRandomId({
        randomId: {
          prefix: "aria-tooltip-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const [, setTriggerFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTriggerFocusedDelayCorrected(focused), focused ? focusDelay : 1);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTooltipFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTooltipFocusedDelayCorrected(focused), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTriggerHover] = usePassiveState(useStableCallback(hovering => {
        const delay = hovering ? mouseoverDelay : mouseoutDelay;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTriggerHoverDelayCorrected(hovering), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTooltipHover] = usePassiveState(useStableCallback(hovering => {
        const delay = hovering ? mouseoverDelay : mouseoutDelay;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTooltipHoverDelayCorrected(hovering), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [triggerFocusedDelayCorrected, setTriggerFocusedDelayCorrected] = useState(false);
      const [triggerHoverDelayCorrected, setTriggerHoverDelayCorrected] = useState(false);
      const [tooltipFocusedDelayCorrected, setTooltipFocusedDelayCorrected] = useState(false);
      const [tooltipHoverDelayCorrected, setTooltipHoverDelayCorrected] = useState(false);
      s(() => {
        setOpen(triggerFocusedDelayCorrected || triggerHoverDelayCorrected || tooltipFocusedDelayCorrected || tooltipHoverDelayCorrected);
      }, [triggerFocusedDelayCorrected || triggerHoverDelayCorrected || tooltipFocusedDelayCorrected || tooltipHoverDelayCorrected]);
      const useTooltipTrigger = q$1(function useTooltipTrigger(_ref2) {
        let {
          hasFocus: {
            onFocusedInnerChanged,
            ...hasFocus
          }
        } = _ref2;
        debugLog("useAriaTooltipTrigger");
        useGlobalHandler(document, "pointermove", e => {
          var _getElement;

          const target = e.target;
          setTriggerHover(target == getElement() || !!((_getElement = getElement()) !== null && _getElement !== void 0 && _getElement.contains(target)));
        }, {
          capture: true
        });

        function onTouchEnd(e) {
          e.target.focus();
        }

        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({ ...hasFocus,
          onFocusedInnerChanged: useStableCallback((focused, prev) => {
            onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);
            setTriggerFocused(focused);
          })
        });

        function useTooltipTriggerProps(_ref3) {
          var _props$tabIndex;

          let { ...props
          } = _ref3;
          const {
            useRandomIdReferencerElementProps
          } = useRandomIdReferencerElement("aria-describedby"); // Note: Though it's important to make sure that focusing activates a tooltip,
          // it's perfectly reasonable that a child element will be the one that's focused,
          // not this one, so we don't set tabIndex=0

          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1;
          return useRandomIdReferencerElementProps(useHasFocusProps(useMergedProps({
            onTouchEnd
          }, props)));
        }

        return {
          useTooltipTriggerProps
        };
      }, []);
      const useTooltip = q$1(function useTooltip(_ref4) {
        let {
          hasFocus: {
            onFocusedInnerChanged,
            ...hasFocus
          }
        } = _ref4;
        debugLog("useAriaTooltipTooltip");
        const {
          useRandomIdSourceElementProps
        } = useRandomIdSourceElement();
        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({
          onFocusedInnerChanged: useStableCallback((focused, prev) => {
            onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);
            setTooltipFocused(focused);
          }),
          ...hasFocus
        });
        useGlobalHandler(document, "pointermove", e => {
          var _getElement2;

          const target = e.target;
          setTooltipHover(target == getElement() || !!((_getElement2 = getElement()) !== null && _getElement2 !== void 0 && _getElement2.contains(target)));
        }, {
          capture: true
        });

        function useTooltipProps(_ref5) {
          let { ...props
          } = _ref5;
          return useRandomIdSourceElementProps(useHasFocusProps(useMergedProps({}, props)));
        }

        return {
          useTooltipProps
        };
      }, []);
      return {
        useTooltip,
        useTooltipTrigger,
        isOpen: open,
        getIsOpen: getOpen
      };
    }

    function useAriaRadioGroup(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        radioGroup: {
          name,
          onInput,
          selectedValue,
          tagGroup,
          tagGroupLabel
        },
        rovingTabIndex,
        typeaheadNavigation,
        childrenHaveFocus
      } = _ref;
      debugLog("useAriaRadioGroup", selectedValue);
      const {
        getElement: _getRadioGroupParentElement,
        useRefElementProps
      } = useRefElement({}); //const getSelectedIndex = useCallback((selectedValue: V) => { return byName.current.get(selectedValue) ?? 0 }, [])

      const [selectedIndex, setSelectedIndex] = useState(0);
      const byName = A(new Map());
      const stableOnInput = useStableCallback(onInput); //const [anyRadiosFocused, setAnyRadiosFocused, getAnyRadiosFocused] = useState(false);

      const {
        useLabelInput: useGroupLabelInput,
        useLabelLabel: useGroupLabelLabel
      } = useLabel({
        label: {
          prefixLabel: "aria-radio-group-label-",
          tagInput: tagGroup,
          tagLabel: tagGroupLabel,
          prefixInput: "aria-radio-group-"
        }
      });
      const {
        useLabelInputProps: useGroupLabelInputProps
      } = useGroupLabelInput();
      const {
        useLabelLabelProps: useGroupLabelLabelProps
      } = useGroupLabelLabel();
      const {
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps,
        ...listNavRet
      } = useListNavigationSingleSelection({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        singleSelection: {
          selectedIndex
        },
        typeaheadNavigation,
        childrenHaveFocus
      }); // Track whether the currently focused element is a child of the radio group parent element.
      // When it's not, we reset the tabbable index back to the currently selected element.
      //const { useActiveElementProps } = useActiveElement<G>({ onActiveElementChange: useCallback((activeElement: Node | null) => setAnyRadiosFocused(!!(getRadioGroupParentElement()?.contains(activeElement))), []) });

      /*useEffect(() => {
          if (!anyRadiosFocused)
              navigateToIndex(selectedIndex ?? 0);
      }, [anyRadiosFocused, selectedIndex, navigateToIndex]);*/

      const useRadioGroupProps = q$1(_ref2 => {
        let { ...props
        } = _ref2;
        props.role = "radiogroup";
        return useGroupLabelInputProps(useListNavigationSingleSelectionProps(useRefElementProps(props)));
      }, [useRefElementProps]);
      const useRadioGroupLabelProps = q$1(props => {
        return useGroupLabelLabelProps(props);
      }, [useGroupLabelLabelProps]); //const correctedIndex = (selectedIndex == null || selectedIndex < 0 || selectedIndex >= managedChildren.length) ? null : selectedIndex;

      /*const { onChildrenMountChange } = useChildrenFlag({
          initialIndex: 0,
          children,
          key: "selected"
          //setChildFlag: (i, checked) => managedChildren[i]?.setChecked(checked),
          //getChildFlag: ((i) => managedChildren[i]?.getChecked() ?? false)
      });*/

      s(() => {
        if (selectedValue == null) {
          setSelectedIndex(null);
        } else {
          const selectedIndex = byName.current.get(selectedValue);
          setSelectedIndex(selectedIndex !== null && selectedIndex !== void 0 ? selectedIndex : null);
        }
      }, [byName, selectedValue]);
      const useRadio = q$1(function useAriaRadio(_ref3) {
        let {
          listNavigation,
          managedChild,
          rovingTabIndex,
          hasFocus,
          radio: {
            disabled,
            labelPosition,
            tagInput,
            tagLabel,
            value
          }
        } = _ref3;
        const index = managedChild.index;
        debugLog("useAriaRadio", index); //const [checked, setChecked, getChecked] = useState<boolean | null>(null);

        const onInput = q$1(e => {
          stableOnInput(enhanceEvent(e, {
            selectedValue: value
          }));
        }, [stableOnInput, value, index]);
        const {
          useListNavigationSingleSelectionChildProps,
          ...listNavRet
        } = useListNavigationSingleSelectionChild({
          listNavigation,
          rovingTabIndex,
          managedChild,
          hasFocus,
          subInfo: {}
        });
        const {
          singleSelection: {
            selected: checked
          }
        } = listNavRet;
        const {
          useCheckboxLikeInputElement,
          useCheckboxLikeLabelElement
        } = useCheckboxLike({
          checkboxLike: {
            checked: checked !== null && checked !== void 0 ? checked : false,
            labelPosition,
            disabled,
            onInput,
            role: "radio"
          },
          label: {
            tagInput: tagInput,
            tagLabel: tagLabel
          }
        });
        _(() => {
          byName.current.set(value, index);
          return () => {
            byName.current.delete(value);
          };
        }, [byName, value, index]);

        const useRadioInput = () => {
          const tag = tagInput;

          const useRadioInputProps = props => {
            if (tag == "input") {
              props.name = name;
              props.checked = checked !== null && checked !== void 0 ? checked : false;
              props.type = "radio";
            } else {
              props["aria-checked"] = (checked !== null && checked !== void 0 ? checked : false).toString();
            }

            const propsIfInputHandlesFocus = useListNavigationSingleSelectionChildProps(props);
            const {
              useCheckboxLikeInputElementProps
            } = useCheckboxLikeInputElement();
            return useMergedProps(useCheckboxLikeInputElementProps({}), labelPosition == "separate" ? propsIfInputHandlesFocus : props);
          };

          return {
            useRadioInputProps
          };
        };

        const useRadioLabel = q$1(() => {
          //const tag = tagLabel;
          const useRadioLabelProps = props => {
            const {
              useCheckboxLikeLabelElementProps
            } = useCheckboxLikeLabelElement();
            const propsIfLabelHandlesFocus = useListNavigationSingleSelectionChildProps(props);
            return useCheckboxLikeLabelElementProps(useMergedProps({}, labelPosition == "wrapping" ? propsIfLabelHandlesFocus : props));
          };

          return {
            useRadioLabelProps
          };
        }, [useCheckboxLikeLabelElement]);
        return {
          useRadioInput,
          useRadioLabel,
          ...listNavRet //checked: checked ?? false,
          //tabbable: tabbable ?? false

        };
      }, [byName, useListNavigationSingleSelectionChild]);
      return {
        useRadio,
        useRadioGroupProps,
        useRadioGroupLabelProps,
        ...listNavRet
      };
    }

    function useAriaSlider(_ref) {
      let {
        slider: {
          max: maxParent,
          min: minParent
        },
        managedChildren
      } = _ref;
      debugLog("useAriaSlider");
      const {
        useManagedChild,
        ...childrenInfo
      } = useManagedChildren({
        managedChildren
      });
      const useAriaSliderThumb = q$1(function useAriaSliderThumb(_ref2) {
        let {
          managedChild,
          sliderThumb
        } = _ref2;
        debugLog("useAriaSliderThumb", managedChild.index);
        const [minParentCopy, setMinParentCopy] = y(minParent);
        const [maxParentCopy, setMaxParentCopy] = y(maxParent);

        useManagedChild({
          managedChild: { ...managedChild,
            subInfo: {
              setMax: setMaxParentCopy,
              setMin: setMinParentCopy
            }
          }
        });

        const {
          tag,
          value,
          max: maxOverride,
          min: minOverride,
          onValueChange,
          valueText,
          label
        } = sliderThumb;
        const min = minOverride !== null && minOverride !== void 0 ? minOverride : minParentCopy;
        const max = maxOverride !== null && maxOverride !== void 0 ? maxOverride : maxParentCopy;
        return {
          useAriaSliderThumbProps,
          sliderThumb: {
            min,
            max
          }
        };

        function useAriaSliderThumbProps(props) {
          let newProps = tag == "input" ? {
            min,
            max,
            value,
            type: "range"
          } : {
            "aria-valuemax": `${max}`,
            "aria-valuemin": `${min}`,
            "aria-valuenow": `${value}`
          };
          newProps = { ...newProps,
            "aria-label": label,
            "aria-valuetext": valueText,
            style: {
              "--range-value": `${value}`,
              "--range-value-text": `${valueText}`
            }
          };

          if (tag == "input") {
            newProps.onInput = e => {
              onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange({
                currentTarget: e.currentTarget,
                target: e.target,
                [EventDetail]: {
                  value: e.currentTarget.valueAsNumber
                }
              });
            };
          } else {
            throw new Error("Unimplemented");
          }

          return useMergedProps(newProps, props);
        }
      }, []);
      return {
        useAriaSliderThumb,
        ...childrenInfo
      };
    }

    function useAriaTable(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      debugLog("useAriaTable");
      const [getCurrentSortColumn, setCurrentSortColumn] = usePassiveState(null, returnNull);
      const bodySort = A(null);
      const {
        useGridNavigationProps,
        useGridNavigationRow,
        ...gridNavRet1
      } = useGridNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children: rows
        }
      } = gridNavRet1;
      const useTableRow = q$1(_ref2 => {
        let {
          asChildRowOfSection,
          asParentRowOfCells,
          tableRow: {
            location
          }
        } = _ref2;
        debugLog("useAriaTableRow", asChildRowOfSection.managedChild.index);
        const getCells = q$1(() => {
          return cells;
        }, []);
        const {
          useGridNavigationCell,
          useGridNavigationRowProps,
          ...gridNavRet2
        } = useGridNavigationRow({
          asChildRowOfSection: { ...asChildRowOfSection,
            subInfo: {
              getCells,
              location
            }
          },
          asParentRowOfCells
        });
        const {
          asParentOfCells: {
            managedChildren: {
              children: cells
            }
          }
        } = gridNavRet2;
        const useTableCell = q$1(_ref3 => {
          let {
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo,
            hasFocus
          } = _ref3;
          debugLog("useAriaTableCell", managedChild.index);
          const {
            useGridNavigationCellProps,
            ...gridNavRet3
          } = useGridNavigationCell({
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo,
            hasFocus
          });
          const sort = useStableCallback(() => {
            var _getCurrentSortColumn;

            const sortInfo = (_getCurrentSortColumn = getCurrentSortColumn()) !== null && _getCurrentSortColumn !== void 0 ? _getCurrentSortColumn : {
              index: -1,
              direction: 'ascending'
            };
            const cellIndex = managedChild.index;

            if (sortInfo.index != cellIndex) {
              if (sortInfo.direction[0] == 'a') sortInfo.direction = 'descending';else sortInfo.direction = 'ascending';
            }

            sortInfo.index = managedChild.index;
            setCurrentSortColumn(sortInfo);
            bodySort.current();
          });

          const useTableCellProps = props => props;

          return {
            tableHeaderCell: {
              sort
            },
            useTableCellProps,
            ...gridNavRet3
          };
        }, []);

        const useTableRowProps = props => props;

        return {
          useTableCell,
          useTableRowProps,
          ...gridNavRet2
        };
      }, []);
      const useTableBody = q$1(() => {
        debugLog("useAriaTableBody");
        const getIndex = q$1(i => i.index, []);
        const getValue = q$1(i => {
          var _getCurrentSortColumn2, _getCurrentSortColumn3, _cell$subInfo$subInfo, _cell$subInfo$subInfo2;

          const cells = i.subInfo.subInfo.subInfo.getCells();
          const cell = cells.getAt((_getCurrentSortColumn2 = (_getCurrentSortColumn3 = getCurrentSortColumn()) === null || _getCurrentSortColumn3 === void 0 ? void 0 : _getCurrentSortColumn3.index) !== null && _getCurrentSortColumn2 !== void 0 ? _getCurrentSortColumn2 : 0);
          return {
            location: (_cell$subInfo$subInfo = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.location) !== null && _cell$subInfo$subInfo !== void 0 ? _cell$subInfo$subInfo : "head",
            value: (_cell$subInfo$subInfo2 = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.value) !== null && _cell$subInfo$subInfo2 !== void 0 ? _cell$subInfo$subInfo2 : -1
          }; //return cells.getAt(getCurrentSortColumn()?.index ?? 0)?.subInfo.subInfo.subInfo.value ?? null;
        }, []);

        const compare = (lhs, rhs) => {
          var _lhs$value, _rhs$value;

          if (lhs.location === rhs.location) return +((_lhs$value = lhs.value) !== null && _lhs$value !== void 0 ? _lhs$value : -Infinity) - +((_rhs$value = rhs.value) !== null && _rhs$value !== void 0 ? _rhs$value : -Infinity);
          if (lhs.location == 'head') return -1;
          if (lhs.location == 'body') return rhs.location == 'head' ? -1 : 1;
          return 1;
        };

        const {
          useSortableProps,
          ...sortableRet
        } = useSortableChildren({
          rearrangeableChildren: {
            getIndex
          },
          sortableChildren: {
            compare,
            getValue
          }
        });
        const {
          sortableChildren: {
            sort
          }
        } = sortableRet;
        useLayoutEffect(() => {
          bodySort.current = () => {
            var _getCurrentSortColumn4, _getCurrentSortColumn5;

            sort(rows, (_getCurrentSortColumn4 = (_getCurrentSortColumn5 = getCurrentSortColumn()) === null || _getCurrentSortColumn5 === void 0 ? void 0 : _getCurrentSortColumn5.direction) !== null && _getCurrentSortColumn4 !== void 0 ? _getCurrentSortColumn4 : 'ascending');
          };
        }, [sort]);

        const useTableBodyProps = props => {
          console.assert(props.children != null);
          return useSortableProps(props);
        };

        return {
          useTableBodyProps,
          ...sortableRet
        };
      }, []);
      const useTableProps = useGridNavigationProps;
      return {
        useTableProps,
        useTableBody,
        useTableRow,
        ...gridNavRet1
      };
    }

    const AccordionSectionContext = B$2(null);
    function AriaAccordion(_ref) {
      let {
        disableArrowKeys,
        disableHomeEndKeys,
        expandedIndex,
        initialIndex,
        navigationDirection,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        render
      } = _ref;
      const {
        useAriaAccordionSection,
        ...provider
      } = useAriaAccordion({
        accordion: {
          initialIndex
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      useEffect(() => {
        provider.accordion.changeExpandedIndex(expandedIndex !== null && expandedIndex !== void 0 ? expandedIndex : null);
      }, [expandedIndex]);
      return o$1(AccordionSectionContext.Provider, {
        value: useAriaAccordionSection,
        children: render(provider)
      });
    }
    function AriaAccordionSection(_ref3) {
      let {
        open,
        index,
        tagButton,
        disabled,
        render,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref3;
      const useAriaAccordionSection = x$1(AccordionSectionContext);
      const {
        useAriaAccordionSectionBodyProps,
        useAriaAccordionSectionHeaderProps,
        ...sectionInfo
      } = useAriaAccordionSection({
        button: {
          disabled
        },
        accordionSection: {
          open,
          tagButton
        },
        managedChildren: {
          index
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return render(sectionInfo, useAriaAccordionSectionHeaderProps, useAriaAccordionSectionBodyProps);
    }

    function defaultRenderButton(tag, makeButtonProps) {
      return function (modifyButtonProps) {
        return h$1(tag, modifyButtonProps(makeButtonProps({})));
      };
    }
    function AriaButton(_ref) {
      let {
        tag,
        onPress,
        pressed,
        render,
        disabled
      } = _ref;
      const {
        useAriaButtonProps
      } = useAriaButton({
        tag,
        onPress,
        pressed,
        disabled
      });
      return render(useAriaButtonProps);
    }

    function defaultRenderCheckboxLike(_ref) {
      let {
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      } = _ref;
      return function (info, modifyInputProps, modifyLabelProps) {
        if (labelPosition == "wrapping") {
          const input = h$1(tagInput, modifyInputProps(makeInputProps(info)));
          const {
            children,
            ...labelProps
          } = makeLabelProps(info);
          const label = h$1(tagLabel, modifyLabelProps({ ...labelProps,
            children: o$1(p$1, {
              children: [input, children]
            })
          }));
          return o$1(p$1, {
            children: label
          });
        } else if (labelPosition == "separate") {
          const input = h$1(tagInput, modifyInputProps(makeInputProps(info)));
          const label = h$1(tagLabel, modifyLabelProps(makeLabelProps(info)));
          return o$1(p$1, {
            children: [input, label]
          });
        } else {
          const userProps = makeInputProps(info);
          console.assert(!!userProps["aria-label"]);
          return h$1(tagInput, modifyInputProps(userProps));
        }
      };
    }
    function defaultRenderCheckbox(_ref2) {
      let {
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      } = _ref2;
      return defaultRenderCheckboxLike({
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      });
    }
    function AriaCheckbox(_ref3) {
      let {
        checked,
        disabled,
        tagLabel,
        labelPosition,
        tagInput,
        onInput,
        render
      } = _ref3;
      const {
        useCheckboxInputElement,
        useCheckboxLabelElement,
        ...checkboxInfo
      } = useAriaCheckbox({
        checkbox: {
          onInput
        },
        checkboxLike: {
          checked,
          disabled,
          labelPosition
        },
        label: {
          tagInput,
          tagLabel
        }
      });
      const {
        useCheckboxInputElementProps
      } = useCheckboxInputElement();
      const {
        useCheckboxLabelElementProps
      } = useCheckboxLabelElement();
      return render(checkboxInfo, useCheckboxInputElementProps, useCheckboxLabelElementProps);
    }

    function defaultRenderCheckboxGroupChild(_ref) {
      let {
        tagInput,
        tagLabel,
        labelPosition,
        makeInputProps,
        makeLabelProps
      } = _ref;
      return function (info, modifyInputProps, modifyLabelProps) {
        return defaultRenderCheckboxLike({
          labelPosition,
          tagInput,
          tagLabel,
          makeInputProps,
          makeLabelProps
        })(info, modifyInputProps, modifyLabelProps);
      };
    }
    function defaultRenderCheckboxGroup(_ref2) {
      let {
        children,
        labelPosition,
        makeInputProps,
        makeLabelProps,
        tagInput,
        tagLabel
      } = _ref2;
      return function (info, modifyInputProps, modifyLabelProps) {
        return o$1(p$1, {
          children: [defaultRenderCheckboxLike({
            labelPosition,
            makeInputProps,
            makeLabelProps,
            tagInput,
            tagLabel
          })(info, modifyInputProps, modifyLabelProps), children]
        });
      };
    }
    const UseCheckboxGroupChildContext = B$2(null);
    function CheckboxGroup(_ref3) {
      let {
        disabled: parentDisabled,
        tagInput,
        tagLabel,
        render,
        labelPosition,
        initialIndex,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        indexDemangler,
        indexMangler,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender
      } = _ref3;
      const {
        useCheckboxGroupChild,
        useCheckboxGroupParentInput,
        ...checkboxGroupParentInfo
      } = useCheckboxGroup({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useCheckboxGroupParentInputProps,
        useCheckboxGroupParentLabelProps
      } = useCheckboxGroupParentInput({
        checkbox: {},
        checkboxLike: {
          disabled: parentDisabled,
          labelPosition
        },
        label: {
          tagInput,
          tagLabel
        }
      });
      let wrapping;

      if (labelPosition == "separate") {
        wrapping = render(checkboxGroupParentInfo, useCheckboxGroupParentInputProps, useCheckboxGroupParentLabelProps);
      } else {
        wrapping = render(checkboxGroupParentInfo, useCheckboxGroupParentInputProps, useCheckboxGroupParentLabelProps);
      }

      return o$1(UseCheckboxGroupChildContext.Provider, {
        value: useCheckboxGroupChild,
        children: wrapping
      });
    }
    function CheckboxGroupCheckbox(_ref4) {
      let {
        checked,
        disabled,
        index,
        labelPosition,
        tagInput,
        tagLabel,
        text,
        blurSelf,
        flags,
        focusSelf,
        hidden,
        onInput,
        render
      } = _ref4;
      const {
        useCheckboxGroupChildInputProps,
        useCheckboxGroupChildLabelProps,
        ...checkboxGroupChildInfo
      } = x$1(UseCheckboxGroupChildContext)({
        asCheckbox: {
          checkbox: {
            onInput
          },
          checkboxLike: {
            checked,
            disabled,
            labelPosition
          },
          label: {
            tagInput,
            tagLabel
          }
        },
        asCheckboxGroupChild: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden
          }
        }
      });

      if (labelPosition == "separate") {
        return render(checkboxGroupChildInfo, useCheckboxGroupChildInputProps, useCheckboxGroupChildLabelProps);
      } else {
        return render(checkboxGroupChildInfo, useCheckboxGroupChildInputProps, useCheckboxGroupChildLabelProps);
      }
    }

    function g(n, t) {
      for (var e in t) n[e] = t[e];

      return n;
    }

    function C(n, t) {
      for (var e in n) if ("__source" !== e && !(e in t)) return !0;

      for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;

      return !1;
    }

    function E(n) {
      this.props = n;
    }

    (E.prototype = new d$1()).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function (n, t) {
      return C(this.props, n) || C(this.state, t);
    };
    var R = l$1.__b;

    l$1.__b = function (n) {
      n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), R && R(n);
    };

    var x = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;

    function N(n) {
      function t(t) {
        var e = g({}, t);
        return delete e.ref, n(e, t.ref || null);
      }

      return t.$$typeof = x, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
    }

    var O = l$1.__e;

    l$1.__e = function (n, t, e, r) {
      if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
      O(n, t, e, r);
    };

    var T = l$1.unmount;

    function I(n, t, e) {
      return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
        "function" == typeof n.__c && n.__c();
      }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
        return I(n, t, e);
      })), n;
    }

    function L(n, t, e) {
      return n && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
        return L(n, t, e);
      }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
    }

    function U() {
      this.__u = 0, this.t = null, this.__b = null;
    }

    function D(n) {
      var t = n.__.__c;
      return t && t.__a && t.__a(n);
    }

    function M() {
      this.u = null, this.o = null;
    }

    l$1.unmount = function (n) {
      var t = n.__c;
      t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), T && T(n);
    }, (U.prototype = new d$1()).__c = function (n, t) {
      var e = t.__c,
          r = this;
      null == r.t && (r.t = []), r.t.push(e);

      var u = D(r.__v),
          o = !1,
          i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };

      e.__R = i;

      var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;
            r.__v.__k[0] = L(n, n.__c.__P, n.__c.__O);
          }

          var t;

          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
          c = !0 === t.__h;

      r.__u++ || c || r.setState({
        __a: r.__b = r.__v.__k[0]
      }), n.then(i, i);
    }, U.prototype.componentWillUnmount = function () {
      this.t = [];
    }, U.prototype.render = function (n, e) {
      if (this.__b) {
        if (this.__v.__k) {
          var r = document.createElement("div"),
              o = this.__v.__k[0].__c;
          this.__v.__k[0] = I(this.__b, r, o.__O = o.__P);
        }

        this.__b = null;
      }

      var i = e.__a && h$1(p$1, null, n.fallback);
      return i && (i.__h = null), [h$1(p$1, null, e.__a ? null : n.children), i];
    };

    var V = function (n, t, e) {
      if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
        for (; e.length > 3;) e.pop()();

        if (e[1] < e[0]) break;
        n.u = e = e[2];
      }
    };

    function W(n) {
      return this.getChildContext = function () {
        return n.context;
      }, n.children;
    }

    function P(n) {
      var e = this,
          r = n.i;
      e.componentWillUnmount = function () {
        P$1(null, e.l), e.l = null, e.i = null;
      }, e.i && e.i !== r && e.componentWillUnmount(), n.__v ? (e.l || (e.i = r, e.l = {
        nodeType: 1,
        parentNode: r,
        childNodes: [],
        appendChild: function (n) {
          this.childNodes.push(n), e.i.appendChild(n);
        },
        insertBefore: function (n, t) {
          this.childNodes.push(n), e.i.appendChild(n);
        },
        removeChild: function (n) {
          this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), e.i.removeChild(n);
        }
      }), P$1(h$1(W, {
        context: e.context
      }, n.__v), e.l)) : e.l && e.componentWillUnmount();
    }

    function $(n, e) {
      var r = h$1(P, {
        __v: n,
        i: e
      });
      return r.containerInfo = e, r;
    }

    (M.prototype = new d$1()).__a = function (n) {
      var t = this,
          e = D(t.__v),
          r = t.o.get(n);
      return r[0]++, function (u) {
        var o = function () {
          t.props.revealOrder ? (r.push(u), V(t, n, r)) : u();
        };

        e ? e(o) : o();
      };
    }, M.prototype.render = function (n) {
      this.u = null, this.o = new Map();
      var t = x$2(n.children);
      n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

      for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);

      return n.children;
    }, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function () {
      var n = this;
      this.o.forEach(function (t, e) {
        V(n, e, t);
      });
    };

    var j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        z = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        B = "undefined" != typeof document,
        H = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };

    d$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
      Object.defineProperty(d$1.prototype, t, {
        configurable: !0,
        get: function () {
          return this["UNSAFE_" + t];
        },
        set: function (n) {
          Object.defineProperty(this, t, {
            configurable: !0,
            writable: !0,
            value: n
          });
        }
      });
    });
    var q = l$1.event;

    function G() {}

    function J() {
      return this.cancelBubble;
    }

    function K() {
      return this.defaultPrevented;
    }

    l$1.event = function (n) {
      return q && (n = q(n)), n.persist = G, n.isPropagationStopped = J, n.isDefaultPrevented = K, n.nativeEvent = n;
    };

    var X = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
        nn = l$1.vnode;

    l$1.vnode = function (n) {
      var t = n.type,
          e = n.props,
          u = e;

      if ("string" == typeof t) {
        var o = -1 === t.indexOf("-");

        for (var i in u = {}, e) {
          var l = e[i];
          B && "children" === i && "noscript" === t || "value" === i && "defaultValue" in e && null == l || ("defaultValue" === i && "value" in e && null == e.value ? i = "value" : "download" === i && !0 === l ? l = "" : /ondoubleclick/i.test(i) ? i = "ondblclick" : /^onchange(textarea|input)/i.test(i + t) && !H(e.type) ? i = "oninput" : /^onfocus$/i.test(i) ? i = "onfocusin" : /^onblur$/i.test(i) ? i = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && z.test(i) ? i = i.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = "oninputCapture")), u[i] = l);
        }

        "select" == t && u.multiple && Array.isArray(u.value) && (u.value = x$2(e.children).forEach(function (n) {
          n.props.selected = -1 != u.value.indexOf(n.props.value);
        })), "select" == t && null != u.defaultValue && (u.value = x$2(e.children).forEach(function (n) {
          n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
        })), n.props = u, e.class != e.className && (X.enumerable = "className" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, "className", X));
      }

      n.$$typeof = j, nn && nn(n);
    };

    var tn = l$1.__r;

    l$1.__r = function (n) {
      tn && tn(n), n.__c;
    };

    function defaultRenderPortal(_ref) {
      var _portalRef$current;

      let {
        portalId,
        children
      } = _ref;
      const portalRef = A(null);
      (_portalRef$current = portalRef.current) !== null && _portalRef$current !== void 0 ? _portalRef$current : portalRef.current = document.getElementById(portalId);
      if (portalRef.current) return $(children, portalRef.current);else return children;
    }
    function defaultRenderModal(_ref2) {
      let {
        portalId,
        tagFocusContainer,
        tagBackdrop,
        tagBody,
        tagDialog,
        tagTitle,
        makePropsFocusContainer,
        makePropsBackdrop,
        makePropsBody,
        makePropsDialog,
        makePropsTitle
      } = _ref2;
      return function (dialogInfo, modifyFocusContainerProps, modifyDialogProps, modifyTitleProps, modifyBodyProps, modifyBackdropProps) {
        const {
          children: titleChildren,
          ...titleProps
        } = modifyTitleProps(makePropsTitle(dialogInfo));
        const {
          children: bodyChildren,
          ...bodyProps
        } = modifyBodyProps(makePropsBody(dialogInfo));
        const {
          children: dialogChildren,
          ...dialogProps
        } = modifyDialogProps(makePropsDialog(dialogInfo));
        const {
          children: backdropChildren,
          ...backdropProps
        } = modifyBackdropProps(makePropsBackdrop(dialogInfo));
        const {
          children: focusContainerChildren,
          ...focusContainerProps
        } = modifyFocusContainerProps(makePropsFocusContainer(dialogInfo));
        const title = h$1(tagTitle, titleProps, titleChildren);
        const body = h$1(tagBody, bodyProps, bodyChildren);
        const dialog = h$1(tagDialog, { ...dialogProps,
          children: o$1(p$1, {
            children: [dialogChildren, title, body]
          })
        });
        const backdrop = h$1(tagBackdrop, backdropProps, backdropChildren);
        const focusContainer = h$1(tagFocusContainer, focusContainerProps, o$1(p$1, {
          children: [focusContainerChildren, dialog, backdrop]
        }));
        return defaultRenderPortal({
          portalId,
          children: focusContainer
        });
      };
    }
    function defaultRenderDialog(_ref3) {
      let {
        portalId,
        tagFocusContainer,
        tagBackdrop,
        tagBody,
        tagDialog,
        tagTitle,
        makePropsFocusContainer,
        makePropsBackdrop,
        makePropsBody,
        makePropsDialog,
        makePropsTitle
      } = _ref3;
      return defaultRenderModal({
        portalId,
        tagFocusContainer,
        tagBackdrop,
        tagBody,
        tagDialog,
        tagTitle,
        makePropsFocusContainer,
        makePropsBackdrop,
        makePropsBody,
        makePropsDialog,
        makePropsTitle
      });
    }
    function Dialog(_ref4) {
      let {
        onClose,
        open,
        bodyIsOnlySemantic,
        getDocument,
        getWindow,
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        focusSelf,
        render
      } = _ref4;
      const {
        useDialogBackdrop,
        useDialogBody,
        useDialogProps,
        useDialogTitle,
        useDialogFocusContainerProps,
        ...r
      } = useAriaDialog({
        dialog: {
          onClose
        },
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        softDismiss: {
          open
        },
        activeElement: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onLastActiveElementChange,
          onWindowFocusedChange
        }
      });
      const {
        useDialogTitleProps
      } = useDialogTitle();
      const {
        useDialogBodyProps
      } = useDialogBody();
      const {
        useDialogBackdropProps
      } = useDialogBackdrop();
      return render(r, useDialogFocusContainerProps, useDialogProps, useDialogTitleProps, useDialogBodyProps, useDialogBackdropProps);
    }

    const ListboxSingleContext = B$2(null);

    function ListboxSingleU(_ref) {
      let {
        render,
        selectedIndex,
        tagLabel,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        onAllLostFocus,
        onAnyGainedFocus,
        selectionMode,
        tagList,
        onSelect
      } = _ref;
      const {
        useListboxSingleItem,
        useListboxSingleLabel,
        useListboxSingleProps,
        ...listboxReturnType
      } = useAriaListboxSingle({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listboxSingle: {
          selectionMode,
          tagLabel,
          tagList,
          onSelect
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        singleSelection: {
          selectedIndex
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        },
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        }
      });
      const {
        useListboxSingleLabelProps
      } = useListboxSingleLabel(); //const label = createElement(tagLabel, useListboxSingleLabelProps({}) as any);
      //const list = createElement(tagList, useListboxSingleProps({ children: vnodeChildren, ref }) as any);

      return o$1(ListboxSingleContext.Provider, {
        value: useListboxSingleItem,
        children: render({ ...listboxReturnType
        }, useListboxSingleLabelProps, useListboxSingleProps)
      });
    }

    function defaultRenderListboxSingle(_ref2) {
      let {
        makePropsList,
        makePropsLabel,
        tagLabel,
        tagList
      } = _ref2;
      return defaultRenderList({
        makePropsLabel,
        makePropsList,
        tagLabel,
        tagList
      });
    }
    function defaultRenderListboxSingleItem(_ref3) {
      let {
        makePropsListItem,
        tagListItem
      } = _ref3;
      return defaultRenderListItem({
        makePropsListItem,
        tagListItem
      });
    }

    function ListboxSingleItemU(_ref4) {
      let {
        index,
        blurSelf,
        disabled,
        flags,
        focusSelf,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render,
        text,
        hidden
      } = _ref4;
      const {
        useListboxSingleItemProps,
        rovingTabIndex,
        singleSelection
      } = x$1(ListboxSingleContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        listboxSingleItem: {
          disabled
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return o$1(p$1, {
        children: render({
          rovingTabIndex,
          singleSelection
        }, useListboxSingleItemProps)
      });
    }

    const ListboxSingle = N(ListboxSingleU);
    const ListboxSingleItem = N(ListboxSingleItemU);
    N(ListboxGroupU);

    function ListboxGroupU(_ref5) {
      let {
        render
      } = _ref5;
      const {
        useListboxGroupHeadingProps,
        useListboxGroupContainerProps
      } = useListboxGroup();
      return render(useListboxGroupContainerProps, useListboxGroupHeadingProps);
    }
    function defaultRenderList(_ref7) {
      let {
        makePropsList,
        makePropsLabel,
        tagLabel,
        tagList
      } = _ref7;
      return function (info, modifyPropsLabel, modifyPropsList) {
        const label = h$1(tagLabel, modifyPropsLabel(makePropsLabel(info)));
        const list = h$1(tagList, modifyPropsList(makePropsList(info)));
        return o$1(p$1, {
          children: [label, list]
        });
      };
    }
    function defaultRenderListItem(_ref8) {
      let {
        makePropsListItem,
        tagListItem
      } = _ref8;
      return function (info, modifyPropsListItem) {
        return h$1(tagListItem, modifyPropsListItem(makePropsListItem(info)));
      };
    }

    const ListboxMultiContext = B$2(null);

    function ListboxMultiU(_ref) {
      let {
        render,
        tagLabel,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        tagList
      } = _ref;
      const {
        useListboxMultiItem,
        useListboxMultiLabel,
        useListboxMultiProps,
        ...listboxReturnType
      } = useAriaListboxMulti({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listboxMulti: {
          tagLabel,
          tagList
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useListboxMultiLabelProps
      } = useListboxMultiLabel();
      return o$1(ListboxMultiContext.Provider, {
        value: useListboxMultiItem,
        children: render(listboxReturnType, useListboxMultiLabelProps, useListboxMultiProps)
      });
    }

    function defaultRenderListboxMulti(_ref2) {
      let {
        makePropsList,
        makePropsLabel,
        tagLabel,
        tagList
      } = _ref2;
      return defaultRenderList({
        makePropsLabel,
        makePropsList,
        tagLabel,
        tagList
      });
    }
    function defaultRenderListboxMultiItem(_ref3) {
      let {
        makePropsListItem,
        tagListItem
      } = _ref3;
      return defaultRenderListItem({
        makePropsListItem,
        tagListItem
      });
    }

    function ListboxMultiItemU(_ref4) {
      let {
        index,
        blurSelf,
        disabled,
        flags,
        focusSelf,
        render,
        text,
        hidden,
        selected,
        onSelect
      } = _ref4;
      const {
        useListboxMultiItemProps,
        ...itemReturn
      } = x$1(ListboxMultiContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        listboxMultiItem: {
          disabled,
          selected,
          onSelect
        }
      });
      return o$1(p$1, {
        children: render(itemReturn, useListboxMultiItemProps)
      });
    }

    const ListboxMulti = N(ListboxMultiU);
    const ListboxMultiItem = N(ListboxMultiItemU);

    const MenuItemContext = B$2(null);
    function Menu(_ref) {
      let {
        initialIndex,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        onOpen,
        onClose,
        open,
        openDirection,
        indexDemangler,
        indexMangler,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        getDocument,
        getWindow,
        render
      } = _ref;
      const {
        useMenuButtonProps,
        useMenuItem,
        useMenuProps,
        useMenuSentinel,
        useMenuSurfaceProps,
        ...menuReturn
      } = useAriaMenu({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        menu: {
          onOpen: useStableCallback(onOpen),
          openDirection
        },
        menuSurface: {},
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        softDismiss: {
          onClose: useStableCallback(onClose),
          open
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        },
        activeElement: {
          getDocument,
          getWindow
        },
        hasFocusButton: {
          getDocument,
          getWindow
        },
        hasFocusSurface: {
          getDocument,
          getWindow
        }
      });
      const {
        useMenuSentinelProps: useFirstSentinelProps
      } = useMenuSentinel();
      const {
        useMenuSentinelProps: useLastSentinelProps
      } = useMenuSentinel();
      return o$1(MenuItemContext.Provider, {
        value: useMenuItem,
        children: render(menuReturn, useMenuButtonProps, useMenuSurfaceProps, useMenuProps, useFirstSentinelProps, useLastSentinelProps)
      });
    }
    function MenuItem(_ref2) {
      let {
        render,
        index,
        text,
        hidden,
        blurSelf,
        flags,
        focusSelf
      } = _ref2;
      const {
        useMenuItemProps,
        ...rest
      } = x$1(MenuItemContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        }
      });
      return render(rest, useMenuItemProps);
    }
    function defaultRenderMenu(_ref3) {
      let {
        portalId,
        tagButton,
        tagMenu,
        tagSurface,
        tagSentinel,
        makePropsButton,
        makePropsMenu,
        makePropsSurface,
        makePropsSentinel
      } = _ref3;
      return function (menuInfo, modifyMenuButtonProps, modifyMenuSurfaceProps, modifyMenuProps, modifyFirstSentinelProps, modifyLastSentinelProps) {
        const {
          children: surfaceChildren,
          ...surfaceProps
        } = modifyMenuSurfaceProps(makePropsSurface(menuInfo));
        const {
          children: menuChildren,
          ...menuProps
        } = modifyMenuProps(makePropsMenu(menuInfo));
        return o$1(p$1, {
          children: [h$1(tagButton, modifyMenuButtonProps(makePropsButton(menuInfo))), defaultRenderPortal({
            portalId,
            children: h$1(tagSurface, { ...surfaceProps,
              children: o$1(p$1, {
                children: [h$1(tagSentinel, modifyFirstSentinelProps(makePropsSentinel(menuInfo))), surfaceChildren, h$1(tagMenu, { ...menuProps,
                  children: o$1(p$1, {
                    children: menuChildren
                  })
                }), h$1(tagSentinel, modifyLastSentinelProps(makePropsSentinel(menuInfo)))]
              })
            })
          })]
        });
      };
    }
    function defaultRenderMenuItem(_ref4) {
      let {
        makePropsMenuItem: makePropsMenuItem,
        tagMenuItem
      } = _ref4;
      return function (info, modifyMenuItemProps) {
        return h$1(tagMenuItem, modifyMenuItemProps(makePropsMenuItem(info)));
      };
    }

    function defaultRenderRadioGroup(_ref) {
      let {
        tagGroup,
        tagLabel,
        makePropsGroup,
        makePropsLabel
      } = _ref;
      return function (info, modifyLabelProps, modifyGroupProps) {
        return o$1(p$1, {
          children: [h$1(tagLabel, modifyLabelProps(makePropsLabel(info))), h$1(tagGroup, modifyGroupProps(makePropsGroup(info)))]
        });
      };
    }
    const RadioContext = B$2(null);
    function RadioGroup(_ref2) {
      let {
        render,
        tagGroup,
        tagGroupLabel,
        initialIndex,
        name,
        onInput,
        selectedValue,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        indexDemangler,
        indexMangler,
        onAllLostFocus,
        onAnyGainedFocus,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender
      } = _ref2;
      const {
        useRadio,
        useRadioGroupLabelProps,
        useRadioGroupProps,
        ...radioGroupReturn
      } = useAriaRadioGroup({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        radioGroup: {
          name,
          onInput,
          selectedValue,
          tagGroup,
          tagGroupLabel
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        },
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        }
      });
      return o$1(RadioContext.Provider, {
        value: useRadio,
        children: render(radioGroupReturn, useRadioGroupLabelProps, useRadioGroupProps)
      });
    }
    function defaultRenderRadio(_ref3) {
      let {
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps,
        labelPosition
      } = _ref3;
      return defaultRenderCheckboxLike({
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      });
    }
    function Radio(_ref4) {
      let {
        disabled,
        index,
        text,
        hidden,
        tagInput,
        labelPosition,
        tagLabel,
        value,
        render,
        flags,
        blurSelf,
        focusSelf,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref4;
      const {
        useRadioInput,
        useRadioLabel,
        ...radioReturn
      } = x$1(RadioContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        radio: {
          disabled,
          labelPosition,
          tagInput,
          tagLabel,
          value
        },
        rovingTabIndex: {
          hidden,
          focusSelf,
          blurSelf
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      const {
        useRadioInputProps
      } = useRadioInput({
        tag: tagInput
      });
      const {
        useRadioLabelProps
      } = useRadioLabel({
        tag: tagLabel
      });
      return render(radioReturn, useRadioInputProps, useRadioLabelProps);
    }

    const SliderThumbContext = B$2(null);
    function Slider(_ref) {
      let {
        max,
        min,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        children
      } = _ref;
      const {
        useAriaSliderThumb,
        ..._sliderInfo
      } = useAriaSlider({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        slider: {
          max,
          min
        }
      });
      return o$1(SliderThumbContext.Provider, {
        value: useAriaSliderThumb,
        children: children
      });
    }

    function SliderThumbU(_ref2, ref) {
      let {
        label,
        tag,
        value,
        max,
        min,
        onValueChange,
        index,
        flags,
        render,
        valueText
      } = _ref2;
      const {
        useAriaSliderThumbProps,
        ...sliderInfo
      } = x$1(SliderThumbContext)({
        managedChild: {
          index,
          flags
        },
        sliderThumb: {
          label,
          tag,
          value,
          max,
          min,
          onValueChange,
          valueText
        }
      });
      return render(sliderInfo, useAriaSliderThumbProps);
    }

    function defaultRenderSliderThumb(_ref3) {
      let {
        tagThumb,
        makePropsThumb
      } = _ref3;
      return function (info, modifyThumbProps) {
        return h$1(tagThumb, modifyThumbProps(makePropsThumb(info)));
      };
    }
    const SliderThumb = N(SliderThumbU);

    const LocationContext = B$2(null);
    const TableBodyContext = B$2(null);
    const TableRowContext = B$2(null);
    const TableCellContext = B$2(null);
    function defaultRenderTable(_ref) {
      let {
        tagTable,
        makePropsTable
      } = _ref;
      return function (info, modifyPropsTable) {
        return h$1(tagTable, modifyPropsTable(makePropsTable(info)));
      };
    }
    function defaultRenderTableRow(_ref5) {
      let {
        tagTableRow,
        makePropsTableRow
      } = _ref5;
      return function (info, modifyPropsTableRow) {
        return h$1(tagTableRow, modifyPropsTableRow(makePropsTableRow(info)));
      };
    }
    function defaultRenderTableCell(_ref6) {
      let {
        tagTableCell,
        makePropsTableCell
      } = _ref6;
      return function (info, modifyPropsTableCell) {
        return h$1(tagTableCell, modifyPropsTableCell(makePropsTableCell(info)));
      };
    }

    function TableU(_ref7, ref) {
      let {
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        render
      } = _ref7;
      const {
        useTableBody,
        useTableProps,
        useTableRow,
        ...tableInfo
      } = useAriaTable({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys
        },
        listNavigation: {},
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      return o$1(TableBodyContext.Provider, {
        value: useTableBody,
        children: o$1(TableRowContext.Provider, {
          value: useTableRow,
          children: (render !== null && render !== void 0 ? render : defaultRenderTable)(tableInfo, useTableProps)
        })
      });
    }

    function TableBodyU(_ref8, ref) {
      let {
        render
      } = _ref8;
      const {
        useTableBodyProps,
        ...sectionInfo
      } = x$1(TableBodyContext)({});
      return o$1(LocationContext.Provider, {
        value: "body",
        children: render(sectionInfo, useTableBodyProps)
      });
    }

    function TableHeadU(_ref9, ref) {
      let {
        render
      } = _ref9;
      return o$1(LocationContext.Provider, {
        value: "head",
        children: render()
      });
    }

    function TableFootU(_ref10, ref) {
      let {
        render
      } = _ref10;
      return o$1(LocationContext.Provider, {
        value: "foot",
        children: render()
      });
    }

    function TableRowU(_ref11, ref) {
      let {
        index,
        text,
        blurSelf,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        flags,
        focusSelf,
        hidden,
        indexDemangler,
        indexMangler,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        render
      } = _ref11;
      const {
        useTableCell,
        useTableRowProps,
        ...rowInfo
      } = x$1(TableRowContext)({
        asChildRowOfSection: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden
          },
          subInfo: {}
        },
        asParentRowOfCells: {
          linearNavigation: {
            disableArrowKeys,
            disableHomeEndKeys
          },
          listNavigation: {
            indexDemangler,
            indexMangler
          },
          managedChildren: {
            onAfterChildLayoutEffect,
            onChildrenMountChange
          },
          rovingTabIndex: {
            initialIndex,
            onTabbableIndexChange,
            onTabbableRender
          },
          typeaheadNavigation: {
            collator,
            noTypeahead,
            typeaheadTimeout
          }
        },
        tableRow: {
          location: x$1(LocationContext)
        }
      });
      return o$1(TableCellContext.Provider, {
        value: useTableCell,
        children: (render !== null && render !== void 0 ? render : defaultRenderTableRow)(rowInfo, useTableRowProps({
          ref
        }))
      });
    }

    function TableCellU(_ref12, ref) {
      let {
        index,
        text,
        blurSelf,
        flags,
        focusSelf,
        hidden,
        value,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render
      } = _ref12;
      const {
        useTableCellProps,
        ...cellInfo
      } = x$1(TableCellContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        },
        subInfo: {
          location: x$1(LocationContext),
          value
        }
      });
      return (render !== null && render !== void 0 ? render : defaultRenderTableCell)(cellInfo, useTableCellProps({
        ref
      }));
    }

    N(TableU);
    N(TableBodyU);
    N(TableHeadU);
    N(TableFootU);
    N(TableRowU);
    N(TableCellU);

    const TabContext = B$2(null);
    const TabPanelContext = B$2(null);
    function Tabs(_ref) {
      let {
        selectedIndex,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        onAllLostFocus,
        onAnyGainedFocus,
        onSelectedIndexChange,
        render
      } = _ref;
      const {
        useAriaTabList,
        useAriaTabListLabel,
        useAriaTabPanel,
        ...tabsInfo
      } = useAriaTabs({
        tabPanels: {
          managedChildren: {
            onAfterChildLayoutEffect,
            onChildrenMountChange
          }
        }
      });
      const {
        useAriaTab,
        useAriaTabListProps,
        ...tablistInfo
      } = useAriaTabList({
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        },
        tabs: {
          onSelectedIndexChange
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        singleSelection: {
          selectedIndex
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useAriaTabListLabelProps
      } = useAriaTabListLabel({});
      return o$1(TabContext.Provider, {
        value: useAriaTab,
        children: o$1(TabPanelContext.Provider, {
          value: useAriaTabPanel,
          children: render({ ...tabsInfo,
            ...tablistInfo
          }, useAriaTabListLabelProps, useAriaTabListProps)
        })
      });
    }
    function Tab(_ref2) {
      let {
        index,
        text,
        blurSelf,
        flags,
        focusSelf,
        hidden,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render
      } = _ref2;
      const {
        useAriaTabProps,
        ...tabInfo
      } = x$1(TabContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return render(tabInfo, useAriaTabProps);
    }
    function TabPanel(_ref3) {
      let {
        index,
        flags,
        render
      } = _ref3;
      const {
        useAriaTabPanelProps,
        ...tabPanelInfo
      } = x$1(TabPanelContext)({
        managedChild: {
          index,
          flags
        }
      });
      return render(tabPanelInfo, useAriaTabPanelProps);
    }
    function defaultRenderTabs(_ref4) {
      let {
        tagLabel,
        tagList,
        makePropsLabel,
        makePropsList,
        panels
      } = _ref4;
      return function (tabsInfo, modifyLabelProps, modifyListProps) {
        const label = h$1(tagLabel, modifyLabelProps(makePropsLabel(tabsInfo)));
        const list = h$1(tagList, modifyListProps(makePropsList(tabsInfo)));
        return o$1(p$1, {
          children: [label, list, panels]
        });
      };
    }
    function defaultRenderTab(_ref5) {
      let {
        makePropsTab,
        tagTab
      } = _ref5;
      return function (tabInfo, modifyTabProps) {
        return h$1(tagTab, modifyTabProps(makePropsTab(tabInfo)));
      };
    }
    function defaultRenderTabPanel(_ref6) {
      let {
        makePropsTabPanel,
        tagTabPanel
      } = _ref6;
      return function (tabPanelInfo, modifyTabPanelProps) {
        return h$1(tagTabPanel, modifyTabPanelProps(makePropsTabPanel(tabPanelInfo)));
      };
    }

    B$2(null);

    function defaultRender(info, triggerProps, tooltipProps) {
      return o$1(p$1, {
        children: [o$1("div", { ...triggerProps
        }), o$1("div", { ...tooltipProps
        })]
      });
    }

    function TooltipU(_ref) {
      let {
        focusDelay,
        mouseoutDelay,
        mouseoverDelay,
        getDocument,
        getWindow,
        render
      } = _ref;
      const {
        useTooltip,
        useTooltipTrigger,
        ...info
      } = useAriaTooltip({
        focusDelay,
        mouseoutDelay,
        mouseoverDelay
      });
      const {
        useTooltipTriggerProps
      } = useTooltipTrigger({
        hasFocus: {
          getDocument,
          getWindow
        }
      });
      const {
        useTooltipProps
      } = useTooltip({
        hasFocus: {
          getDocument,
          getWindow
        }
      });
      return o$1(p$1, {
        children: (render !== null && render !== void 0 ? render : defaultRender)(info, useTooltipTriggerProps({}), useTooltipProps({}))
      });
    }

    N(TooltipU);

    function DemoAccordion({ children, ...props }) {
        return o$1(AriaAccordion, { ...props, render: (info) => { return o$1("div", { id: "accordion-demo", children: children }); } });
    }
    function getDocument$5() {
        return window.document;
    }
    function DemoAccordionSection({ index, body, heading, disabled, open }) {
        return o$1(AriaAccordionSection, { index: index, tagButton: "div", open: open, disabled: disabled, getDocument: getDocument$5, render: (info, headerProps, bodyProps) => {
                return (o$1(p$1, { children: o$1(Heading, { heading: o$1("div", { ...headerProps, children: [heading, " (", !info.accordionSection.expanded && "not ", " open), (", !info.accordionSection.focused && "not ", " focused)"] }), children: o$1("div", { ...bodyProps, children: body }) }) }));
            } });
    }
    function Blurb$a() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/accordion/", children: "In accordance with the ARIA guidelines for Accordion patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["Each section's header and body are linked via ID; the body is ", o$1("code", { children: "labelled-by" }), " the header and the header ", o$1("code", { children: "control" }), "s the body."] }), o$1("li", { children: "The header is a button and responds to keyboard, mouse, touch, etc. events, regardless of the element used." }), o$1("li", { children: ["If the header element is not a ", o$1("code", { children: "<button>" }), " element, it is given that ", o$1("code", { children: "role" }), "."] }), o$1("li", { children: "Up/down & Home/End keys navigate through the list, as does Tab and Shift+Tab" }), o$1("li", {})] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["The ", o$1("code", { children: "render" }), " prop each ", o$1("code", { children: "AccordionSection" }), " takes must wrap the header button with a ", o$1("a", { href: "https://w3c.github.io/aria/#heading", children: "heading" }), " (e.g. ", o$1("code", { children: "h3" }), ", or ", o$1("code", { children: "<Heading>" }), "). See the default implementation for an example."] }) })] }));
    }
    function Code$a() {
        return (o$1("code", { children: `<AriaAccordion render={...}>
    <AriaAccordionSection index={0} render={...} />
    <AriaAccordionSection index={1} render={...} />
    <AriaAccordionSection index={2} render={...} />
</AriaAccordion>` }));
    }
    function Demo$a() {
        return (o$1(p$1, { children: [o$1(Blurb$a, {}), o$1(Code$a, {}), o$1(DemoAccordion, { children: [o$1(DemoAccordionSection, { index: 0, heading: "Accordion section #0", body: "Body content #0", disabled: false }), o$1(DemoAccordionSection, { index: 1, heading: "Accordion section #1", body: "Body content #1", disabled: false }), o$1(DemoAccordionSection, { index: 2, heading: "Accordion section #2 (disabled)", body: "Body content #2", disabled: true }), o$1(DemoAccordionSection, { index: 3, heading: "Accordion section #3 (forced open)", body: "Body content #3", disabled: false, open: true }), o$1(DemoAccordionSection, { index: 4, heading: "Accordion section #4 (forced closed)", body: "Body content #4", disabled: false, open: false })] })] }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <AriaButton disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function Blurb$9() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/button/", children: "In accordance with the ARIA guidelines for Button patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["Whether using an actual ", o$1("code", { children: "<button>" }), ", or something else like a ", o$1("code", { children: "<div>" }), ", the proper roles and event handlers will be applied."] }), o$1("li", { children: "Buttons can be toggled (pressed or unpressed)." }), o$1("li", { children: ["The button responds to keyboard, mouse, touch, etc. events, regardless of the element used.", o$1("ul", { children: [o$1("li", { children: "Double-clicks do not select text, but text is still selectable without it counting as a press/click" }), o$1("li", { children: "When Enter is pressed, the button is immediately activated" }), o$1("li", { children: "When Space is pressed, the button is activated once released" }), o$1("li", { children: "iOS Safari properly focuses the button" })] })] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["If your button contains only an icon (or other non-descriptive content, etc.), you must provide an ", o$1("code", { children: "aria-label" }), " manually stating what happens when the button is pressed."] }) })] }));
    }
    function Code$9() {
        return (o$1("code", { children: `<AriaButton tag="button">Button</AriaButton>
    <AriaButton tag="div">Div</AriaButton>` }));
    }
    function Demo$9() {
        const [pressed, setPressed] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$9, {}), o$1(Code$9, {}), o$1(DemoButton, { disabled: false, tag: "button" }), o$1(DemoButton, { disabled: "soft", tag: "button" }), o$1(DemoButton, { disabled: "hard", tag: "button" }), o$1(DemoButton, { disabled: false, tag: "div" }), o$1(DemoButton, { disabled: "soft", tag: "div" }), o$1(DemoButton, { disabled: "hard", tag: "div" }), o$1(AriaButton, { disabled: false, tag: "button", pressed: pressed, onPress: e => setPressed(e[EventDetail].pressed ?? false), render: defaultRenderButton("button", () => ({ children: `Button (${pressed ? "pressed" : "unpressed"})` })) })] }));
    }
    function DemoButton({ tag, disabled }) {
        return (o$1(AriaButton, { tag: tag, render: defaultRenderButton(tag, ({}) => ({ class: "btn", children: `${tag} ${disabled ? ` disabled (${disabled == "soft" ? "soft" : "hard"})` : ""}` })) }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <AriaButton disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function Blurb$8() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/checkbox/", children: "In accordance with the ARIA guidelines for Checkbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: "Toggles between checked and unchecked when pressed (clicked, Enter pressed, Space released, etc.)" }), o$1("li", { children: ["Can be ", o$1("code", { children: "mixed" }), " instead, though ", o$1("code", { children: "onInput" }), " will only ever be called with ", o$1("code", { children: "true" }), " or ", o$1("code", { children: "false" })] }), o$1("li", { children: ["Supports using ", o$1("code", { children: "<input>" }), "s and ", o$1("code", { children: "<label>" }), "s, as well as just plain ol' ", o$1("code", { children: "<div>" }), "s on either/both"] }), o$1("li", { children: "The checkbox and label can be sibling elements, like normal, or the label can wrap the input for a larger hit area. In all cases, the appropriate roles/event handlers will be applied to each element." }), o$1("li", { children: "When selecting the text of a checkbox's label, this does not change the checkbox's state" }), o$1("li", { children: "Double-clicking the label checks & un-checks the checkbox instead of selecting the label's text" }), o$1("li", { children: "Checkbox groups (with a tri-state parent) are a separate component/hook" })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", { children: "render" }), " prop and setting ", o$1("code", { children: "labelPosition" }), " to be \"separate\"), you must pass ", o$1("code", { children: "aria-label" }), " as a prop to the checkbox manually. Not providing one will print an error to the console, but it it not required by the type system."] }) })] }));
    }
    function Code$8() {
        return (o$1("code", { children: `<AriaCheckbox checked={true} labelPosition="separate" tagInput="input" tagLabel="label">Label text</AriaCheckbox>` }));
    }
    function Demo$8() {
        const [checked, setChecked] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$8, {}), o$1(Code$8, {}), o$1(AriaButton, { tag: "button", onPress: () => { setChecked("mixed"); }, render: defaultRenderButton("button", () => ({ children: "Change to mixed" })) }), o$1(DemoCheckbox$1, { labelPosition: "separate", disabled: false, tagInput: "input", tagLabel: "label" }), o$1(DemoCheckbox$1, { labelPosition: "wrapping", disabled: false, tagInput: "input", tagLabel: "label" }), o$1(DemoCheckbox$1, { labelPosition: "separate", disabled: false, tagInput: "div", tagLabel: "label" }), o$1(DemoCheckbox$1, { labelPosition: "wrapping", disabled: false, tagInput: "div", tagLabel: "label" }), o$1(DemoCheckbox$1, { labelPosition: "separate", disabled: false, tagInput: "input", tagLabel: "div" }), o$1(DemoCheckbox$1, { labelPosition: "wrapping", disabled: false, tagInput: "input", tagLabel: "div" }), o$1(DemoCheckbox$1, { labelPosition: "separate", disabled: false, tagInput: "div", tagLabel: "div" }), o$1(DemoCheckbox$1, { labelPosition: "wrapping", disabled: false, tagInput: "div", tagLabel: "div" }), o$1(DemoCheckbox$1, { labelPosition: "hidden", disabled: false, tagInput: "input", tagLabel: "label" })] }));
    }
    function DemoCheckbox$1({ labelPosition, tagInput, tagLabel, disabled }) {
        const [checked, setChecked] = useState(false);
        return (o$1("div", { style: { border: "1px solid black" }, children: [o$1(AriaCheckbox, { disabled: disabled, checked: checked, onInput: e => setChecked(e[EventDetail].checked), labelPosition: labelPosition == "hidden" ? "separate" : labelPosition, tagInput: tagInput, tagLabel: tagLabel, render: defaultRenderCheckbox({
                        labelPosition,
                        tagInput,
                        tagLabel,
                        makeInputProps: () => ({ "aria-label": labelPosition == "hidden" ? `Hidden label (technically separate), ${tagInput} and ${tagLabel} ${checked ? "checked" : "not checked"}` : undefined, }),
                        makeLabelProps: () => ({ children: `${labelPosition}, ${tagInput} and ${tagLabel}, ${checked ? "checked" : "not checked"}` })
                    }) }), labelPosition == "hidden" && o$1("div", { children: ["(This is not a label -- the actual label is via the ", o$1("code", { children: "aria-label" }), " prop)"] })] }));
    }

    function DemoCheckbox({ index }) {
        const [checked, setChecked] = useState(false);
        const labelText = `Checkbox #${index}`;
        return (o$1(CheckboxGroupCheckbox, { render: defaultRenderCheckboxGroupChild({
                labelPosition: "separate",
                tagInput: "input",
                tagLabel: "label",
                makeInputProps: () => ({}),
                makeLabelProps: () => ({ children: labelText })
            }), checked: checked, index: index, disabled: false, labelPosition: "separate", text: labelText, tagInput: "input", tagLabel: "label", onInput: e => setChecked(e[EventDetail].checked) }));
    }
    function Blurb$7() {
        return (o$1(p$1, { children: [o$1("p", { children: ["Checkbox groups are an alternative to multi-select lists. There is no role of ", o$1("code", { children: "checkboxgroup" }), ", but this aims to be an ARIA-compliant implementation of a checkbox group."] }), o$1("ul", { children: [o$1("li", { children: ["All normal ", o$1("code", { children: "AriaCheckbox" }), " functionality is supported on each individual checkbox."] }), o$1("li", { children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"." }), o$1("li", { children: ["The parent checkbox reacts to each child's ", o$1("code", { children: "checked" }), " prop and updates its own internal ", o$1("code", { children: "checked" }), " attribute (be aware of this if they're asyncronous, as you'll want to ensure they all resolve on the same tick with ", o$1("code", { children: "Promise.all" }), " to not clobber the user's inputs)."] }), o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["It is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", { children: "role=group" }), " that references that label by overriding ", o$1("code", { children: "render" }), "."] }), o$1("li", { children: ["See the caveat above for when each child's ", o$1("code", { children: "onInput" }), " takes a variable amount of time to actually update the ", o$1("code", { children: "checked" }), " prop, as it can clobber the user's last input when clicking on the parent"] })] })] }));
    }
    function Code$7() {
        return (o$1("code", { children: `` }));
    }
    function Demo$7() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$7, {}), o$1(Code$7, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of checkboxes"] }), o$1("div", { children: o$1(CheckboxGroup, { disabled: false, labelPosition: "separate", tagInput: "input", tagLabel: "label", render: defaultRenderCheckboxGroup({
                            labelPosition: "separate",
                            tagInput: "input",
                            tagLabel: "label",
                            makeInputProps: () => ({}),
                            makeLabelProps: () => ({}),
                            children: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield o$1("div", { children: o$1(DemoCheckbox, { index: i }, i) });
                                }
                            })())
                        }) }) })] }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <AriaButton disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function DemoListItem$3({ index }) {
        const [selected, setSelected] = useState(false);
        const labelText = `List item #${index}${selected ? " (selected)" : ""}`;
        return (o$1(ListboxMultiItem, { selected: selected, index: index, disabled: false, text: labelText, onSelect: e => { setSelected(e[EventDetail].selected); }, render: defaultRenderListboxMultiItem({ tagListItem: "li", makePropsListItem: () => ({ children: labelText }) }) }));
    }
    function Blurb$6() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"." }), o$1("li", { children: ["The parent checkbox reacts to each child's ", o$1("code", { children: "checked" }), " prop and updates its own internal ", o$1("code", { children: "checked" }), " attribute (be aware of this if they're asyncronous, as you'll want to ensure they all resolve on the same tick with ", o$1("code", { children: "Promise.all" }), " to not clobber the user's inputs)."] }), o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "Grouping is supported" }), o$1("li", { children: "Sorting/reordering is supported, though not provided by default, as it's mutually exclusive with grouping." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["It is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", { children: "role=group" }), " that references that label by overriding ", o$1("code", { children: "render" }), "."] }), o$1("li", { children: ["See the caveat above for when each child's ", o$1("code", { children: "onInput" }), " takes a variable amount of time to actually update the ", o$1("code", { children: "checked" }), " prop, as it can clobber the user's last input when clicking on the parent"] })] })] }));
    }
    function Code$6() {
        return (o$1("code", { children: `` }));
    }
    function Demo$6() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$6, {}), o$1(Code$6, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of list items"] }), o$1("div", { children: o$1(ListboxMulti, { tagLabel: "label", tagList: "ul", render: defaultRenderListboxMulti({
                            tagLabel: "label", tagList: "ul", makePropsLabel: () => ({}), makePropsList: () => ({
                                children: Array.from((function* () {
                                    for (let i = 0; i < count; ++i) {
                                        yield o$1("div", { children: o$1(DemoListItem$3, { index: i }, i) });
                                    }
                                })())
                            })
                        }) }) })] }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <AriaButton disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function getDocument$4() { return window.document; }
    function DemoListItem$2({ index }) {
        return (o$1(ListboxSingleItem, { index: index, getDocument: getDocument$4, disabled: false, text: `List item #${index}`, render: defaultRenderListboxSingleItem({ tagListItem: "li", makePropsListItem: ({ singleSelection: { selected } }) => ({ children: `List item #${index}${selected ? " (selected)" : ""}` }) }) }));
    }
    function Blurb$5() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["In terms of keyboard navigation and tabbing through elements, a Listbox is considered a ", o$1("strong", { children: "single" }), " tab stop; in other words, no matter how many list items there are in a Listbox, it only takes one press of the Tab button to go through it.", o$1("ul", { children: [o$1("li", { children: "When a Listbox is tabbed into, the most recently selected item is given focus" }), o$1("li", { children: "Pressing Tab again navigates out of the listbox; no other list items are tabbable other than the one currently designated." }), o$1("li", { children: "Pressing the arrow keys navigates through the Listbox one item at a time" }), o$1("li", { children: "Pressing the Home/End keys move focus to the first/last items respectively" }), o$1("li", { children: "Typing any sequence of text starts typeahead that navigates to the next item that matches what's being typed" }), o$1("li", { children: "Focus & selection management is as optimized as possible; only two children re-render at a time when focus or selection changes" }), o$1("li", { children: "These apply generally to all composite components with a variable number of children (Tab Lists, Radio Groups, Multi-Select Listboxes etc.)" })] })] }), o$1("li", { children: ["Rather than each individual list item knowing whether it is selected or not (as with multi-select lists), here the parent knows the ", o$1("code", { children: "selectedIndex" }), " and simply notifies the (max two) relevant children any time it changes."] }), o$1("li", { children: "Grouping is supported" }), o$1("li", { children: "Sorting/reordering is supported, though not provided by default, as it's mutually exclusive with grouping." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "Listboxes do not support interactive content within them (e.g. a dropdown menu), as ARIA specifies that this is a different pattern." }) })] }));
    }
    function Code$5() {
        return (o$1("code", { children: `` }));
    }
    function Demo$5() {
        const [selectedIndex, setSelectedIndex] = useState(null);
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$5, {}), o$1(Code$5, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of list items"] }), o$1("div", { children: o$1(ListboxSingle, { render: defaultRenderListboxSingle({
                            tagLabel: "label", tagList: "ol", makePropsLabel: () => ({}), makePropsList: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1("div", { children: o$1(DemoListItem$2, { index: i }, i) });
                                        }
                                    })()) })
                            })
                        }), selectionMode: "activate", tagLabel: "label", tagList: "ol", selectedIndex: selectedIndex, onSelect: e => setSelectedIndex(e[EventDetail].selectedIndex) }) })] }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <AriaButton disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function DemoListItem$1({ index }) {
        return (o$1(MenuItem, { index: index, text: `List item #${index}`, render: defaultRenderMenuItem({ tagMenuItem: "li", makePropsMenuItem: () => ({ children: `Menu item #${index}` }) }) }));
    }
    function getDocument$3() { return window.document; }
    function Blurb$4() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it." }), o$1("li", { children: "When the menu is closed because another element on the page was focused instead, focus will not be modified." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code$4() {
        return (o$1("code", { children: `` }));
    }
    function Demo$4() {
        const [count, setCount] = useState(5);
        const [open, setOpen] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$4, {}), o$1(Code$4, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of menu items"] }), o$1("div", { children: o$1(Menu, { getDocument: getDocument$3, onOpen: () => setOpen(true), onClose: () => setOpen(false), open: open, openDirection: "down", render: defaultRenderMenu({
                            tagButton: "button",
                            tagMenu: "ul",
                            tagSentinel: "div",
                            tagSurface: "div",
                            portalId: "portal",
                            makePropsButton: () => ({ children: "Open menu" + (open ? " (open)" : " (closed)") }),
                            makePropsMenu: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1("div", { children: o$1(DemoListItem$1, { index: i }, i) });
                                        }
                                    })()) })
                            }),
                            makePropsSurface: () => ({ style: { display: !open ? "none" : undefined } }),
                            makePropsSentinel: () => ({}),
                        }) }) })] }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <AriaButton disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function getDocument$2() {
        return window.document;
    }
    function DemoListItem({ index }) {
        const value = `Radio button #${index}`;
        return (o$1(Radio, { index: index, getDocument: getDocument$2, disabled: false, labelPosition: "separate", text: value, value: index, tagInput: "input", tagLabel: "label", render: defaultRenderRadio({ labelPosition: "separate", tagInput: "input", tagLabel: "label", makeInputProps: () => ({}), makeLabelProps: () => ({ children: value }) }) }));
    }
    function Blurb$3() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/radiobutton/", children: "In accordance with the ARIA guidelines for Radio Button patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "The input & label support the same text-selection affordances as Checkboxes (labels can be selected, but double-clicking doesn't select the text and selecting text doesn't count as an input)" }), o$1("li", { children: "Selection state is handled by the parent; instead of specifying whether any given radio button is checked or not, the parent notifies each child of the necessary changes." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", { children: "render" }), " prop and setting ", o$1("code", { children: "labelPosition" }), " to be \"separate\"), you must pass ", o$1("code", { children: "aria-label" }), " as a prop to the checkbox manually. Not providing one will print an error to the console, but it it not required by the type system."] }), o$1("li", { children: ["The above also applies to the radio group as a whole; ARIA requires that all Radio Buttons be contained within an element with a specific role which is labelled either by an element (handled for you) or ", o$1("code", { children: "aria-label" }), " (specified by you manually on the input)."] })] })] }));
    }
    function Code$3() {
        return (o$1("code", { children: `` }));
    }
    function Demo$3() {
        const [selectedIndex, setSelectedIndex] = useState(null);
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$3, {}), o$1(Code$3, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of list items"] }), o$1("div", { children: o$1(RadioGroup, { name: "radio-demo", onInput: e => setSelectedIndex(e[EventDetail].selectedValue), selectedValue: selectedIndex, tagGroupLabel: "label", tagGroup: "div", render: defaultRenderRadioGroup({
                            tagGroup: "div", tagLabel: "label", makePropsGroup: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1(DemoListItem, { index: i }, i);
                                        }
                                    })()) })
                            }),
                            makePropsLabel: () => ({ children: "Listbox example" })
                        }) }) })] }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <AriaButton disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function DemoSliderThumb({ index }) {
        const [value, setValue] = useState(0);
        return (o$1(SliderThumb, { index: index, tag: "input", label: `Slider thumb #${index}`, value: value, onValueChange: e => setValue(e[EventDetail].value), min: 0, max: 10, render: defaultRenderSliderThumb({ tagThumb: "input", makePropsThumb: () => ({}) }) }));
    }
    function Blurb$2() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it." }), o$1("li", { children: "When the menu is closed because another element on the page was focused instead, focus will not be modified." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code$2() {
        return (o$1("code", { children: `` }));
    }
    function Demo$2() {
        const [count, setCount] = useState(5);
        useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$2, {}), o$1(Code$2, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of slider thumbs"] }), o$1("div", { children: o$1(Slider, { min: 0, max: 10, children: o$1(p$1, { children: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield o$1("div", { children: o$1(DemoSliderThumb, { index: i }, i) });
                                }
                            })()) }) }) })] }));
    }

    function getDocument$1() { return window.document; }
    function Blurb$1() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it." }), o$1("li", { children: "When the menu is closed because another element on the page was focused instead, focus will not be modified." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code$1() {
        return (o$1("code", { children: `` }));
    }
    function Demo$1() {
        const [open, setOpen] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$1, {}), o$1(Code$1, {}), o$1("div", { children: [o$1(AriaButton, { tag: "button", onPress: () => setOpen(true), render: defaultRenderButton("button", () => ({ children: "Open dialog " + (open ? "(open)" : "(closed)") })) }), o$1(Dialog, { getDocument: getDocument$1, onClose: () => setOpen(false), open: open, bodyIsOnlySemantic: true, render: defaultRenderDialog({
                                portalId: "portal",
                                makePropsBackdrop: () => ({}),
                                makePropsFocusContainer: () => ({}),
                                makePropsBody: () => ({ children: "Dialog body" }),
                                makePropsDialog: () => ({ style: { display: !open ? "none" : undefined } }),
                                makePropsTitle: () => ({ children: "Dialog title" }),
                                tagBackdrop: "div",
                                tagBody: "div",
                                tagDialog: "div",
                                tagTitle: "div",
                                tagFocusContainer: "div"
                            }) })] })] }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <AriaButton disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function getDocument() { return window.document; }
    function Blurb() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/tabpanel/", children: "In accordance with the ARIA guidelines for Tab and Tab Panel patterns," }), " this widget supports the following:"] }), o$1("ul", { children: o$1("li", { children: ["The tabs are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }) }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code() {
        return (o$1("code", { children: `` }));
    }
    function Demo() {
        const [count, setCount] = useState(5);
        const [selectedIndex, setSelectedIndex] = useState(0);
        return (o$1(p$1, { children: [o$1(Blurb, {}), o$1(Code, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of tabs"] }), o$1("div", { children: o$1(Tabs, { selectedIndex: selectedIndex, onSelectedIndexChange: e => setSelectedIndex(e[EventDetail].selectedIndex), render: defaultRenderTabs({
                            panels: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    const label = `Tab panel #${i}`;
                                    yield o$1(TabPanel, { index: i, render: defaultRenderTabPanel({ tagTabPanel: "div", makePropsTabPanel: ({ tabPanel: { visible } }) => ({ hidden: !visible, children: label }) }) }, i);
                                }
                            })()),
                            tagLabel: "label", tagList: "ul", makePropsLabel: () => ({ children: "Tabs example" }), makePropsList: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            const label = `Tab #${i}`;
                                            yield o$1(Tab, { index: i, getDocument: getDocument, render: defaultRenderTab({ tagTab: "li", makePropsTab: () => ({ children: label }) }), text: label }, i);
                                        }
                                    })()) })
                            })
                        }) }) })] }));
    }

    //import { options } from "preact";
    //options.debounceRendering = queueMicrotask;
    //const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const Component = () => {
        return (o$1(Heading, { heading: "Demos", children: [o$1(Heading, { heading: "Tabs", children: o$1(Demo, {}) }), o$1(Heading, { heading: "Dialog", children: o$1(Demo$1, {}) }), o$1(Heading, { heading: "Slider", children: o$1(Demo$2, {}) }), o$1(Heading, { heading: "Single-select Listbox", children: o$1(Demo$5, {}) }), o$1(Heading, { heading: "Accordion", children: o$1(Demo$a, {}) }), o$1(Heading, { heading: "Button", children: o$1(Demo$9, {}) }), o$1(Heading, { heading: "Checkbox", children: o$1(Demo$8, {}) }), o$1(Heading, { heading: "Checkbox Group", children: o$1(Demo$7, {}) }), o$1(Heading, { heading: "Multi-select Listbox", children: o$1(Demo$6, {}) }), o$1(Heading, { heading: "Menu", children: o$1(Demo$4, {}) }), o$1(Heading, { heading: "Radio", children: o$1(Demo$3, {}) })] }));
    };
    requestAnimationFrame(() => {
        P$1(o$1(Component, {}), document.getElementById("root"));
    });

})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyIuLi9zcmMvcHJvcHMudHMiLCIuLi9zcmMvY29tcG9uZW50L2hlYWRpbmcudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1lZmZlY3QudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1wYXNzaXZlLXN0YXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtYWN0aXZlLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1zdGFibGUtY2FsbGJhY2sudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1hbmltYXRpb24tZnJhbWUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXN0YXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbGF5b3V0LWVmZmVjdC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWNoaWxkLW1hbmFnZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm0uanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWRvY3VtZW50LWNsYXNzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbWVyZ2VkLWNsYXNzZXMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtcmVmcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1zdHlsZXMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtcHJvcHMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1yZWYtZWxlbWVudC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWV2ZW50LWhhbmRsZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3RhYmJhYmxlL3NyYy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy93aWNnLWluZXJ0L2Rpc3QvaW5lcnQuanMiLCIuLi9ub2RlX21vZHVsZXMvYmxvY2tpbmctZWxlbWVudHMvc3JjL2Jsb2NraW5nLWVsZW1lbnRzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1ibG9ja2luZy1lbGVtZW50LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZm9jdXMtdHJhcC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWZvcmNlLXVwZGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWhhcy1mb2N1cy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWxvZ2ljYWwtZGlyZWN0aW9uLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtdGltZW91dC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWtleWJvYXJkLW5hdmlnYXRpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1yb3ZpbmctdGFiaW5kZXgudHN4IiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weUFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJhbmRvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NodWZmbGVTZWxmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTaHVmZmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FyZ3VtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc3R1YkZhbHNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3NodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXNvcnRhYmxlLWNoaWxkcmVuLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbGlzdC1uYXZpZ2F0aW9uLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZ3JpZC1uYXZpZ2F0aW9uLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtcmFuZG9tLWlkLnRzeCIsIi4uL3NyYy91c2UtYnV0dG9uLnRzIiwiLi4vc3JjL3VzZS1hY2NvcmRpb24udHN4IiwiLi4vc3JjL3VzZS1sYWJlbC50cyIsIi4uL3NyYy91c2UtY2hlY2tib3gudHMiLCIuLi9zcmMvdXNlLWNoZWNrYm94LWdyb3VwLnRzIiwiLi4vc3JjL3VzZS1tb2RhbC50cyIsIi4uL3NyYy91c2UtbGlzdGJveC1zaW5nbGUudHMiLCIuLi9zcmMvdXNlLWxpc3Rib3gtbXVsdGkudHMiLCIuLi9zcmMvdXNlLW1lbnUudHMiLCIuLi9zcmMvdXNlLXRhYnMudHMiLCIuLi9zcmMvdXNlLXRvb2x0aXAudHMiLCIuLi9zcmMvdXNlLXJhZGlvLWdyb3VwLnRzeCIsIi4uL3NyYy91c2UtdGFibGUudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9hY2NvcmRpb24udHN4IiwiLi4vc3JjL2NvbXBvbmVudC9idXR0b24udHN4IiwiLi4vc3JjL2NvbXBvbmVudC9jaGVja2JveC50c3giLCIuLi9zcmMvY29tcG9uZW50L2NoZWNrYm94LWdyb3VwLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvZGlhbG9nLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvbGlzdGJveC1zaW5nbGUudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9saXN0Ym94LW11bHRpLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvbWVudS50c3giLCIuLi9zcmMvY29tcG9uZW50L3JhZGlvLWdyb3VwLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvc2xpZGVyLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvdGFibGUudHN4IiwiLi4vc3JjL2NvbXBvbmVudC90YWJzLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvdG9vbHRpcC50c3giLCJkZW1vcy9hY2NvcmRpb24udHN4IiwiZGVtb3MvYnV0dG9uLnRzeCIsImRlbW9zL2NoZWNrYm94LnRzeCIsImRlbW9zL2NoZWNrYm94LWdyb3VwLnRzeCIsImRlbW9zL2xpc3Rib3gtbXVsdGkudHN4IiwiZGVtb3MvbGlzdGJveC1zaW5nbGUudHN4IiwiZGVtb3MvbWVudS50c3giLCJkZW1vcy9yYWRpby50c3giLCJkZW1vcy9zbGlkZXIudHN4IiwiZGVtb3MvZGlhbG9nLnRzeCIsImRlbW9zL3RhYnMudHN4IiwiaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGgsIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbmV4cG9ydCB0eXBlIFJlZkZyb21UYWc8VCBleHRlbmRzIGtleW9mIGguSlNYLkludHJpbnNpY0VsZW1lbnRzPiA9IE5vbk51bGxhYmxlPGguSlNYLkludHJpbnNpY0VsZW1lbnRzW1RdW1wicmVmXCJdPjtcclxuZXhwb3J0IHR5cGUgRWxlbWVudEZyb21SZWY8UiBleHRlbmRzIFJlZjxhbnk+PiA9IFIgZXh0ZW5kcyBSZWY8aW5mZXIgRT4gPyBFIDogRXZlbnRUYXJnZXQ7XHJcbmV4cG9ydCB0eXBlIEVsZW1lbnRGcm9tVGFnPFQgZXh0ZW5kcyBrZXlvZiBoLkpTWC5JbnRyaW5zaWNFbGVtZW50cz4gPSBFbGVtZW50RnJvbVJlZjxSZWZGcm9tVGFnPFQ+PjtcclxuXHJcbmV4cG9ydCB0eXBlIEVsZW1lbnRUb1RhZzxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0ga2V5b2YgU3ViVHlwZTxIVE1MRWxlbWVudFRhZ05hbWVNYXAsIEU+O1xyXG50eXBlIFN1YlR5cGU8QmFzZSwgQ29uZGl0aW9uPiA9IFBpY2s8QmFzZSwge1xyXG4gICAgW0tleSBpbiBrZXlvZiBCYXNlXTogQmFzZVtLZXldIGV4dGVuZHMgQ29uZGl0aW9uID8gS2V5IDogbmV2ZXJcclxufVtrZXlvZiBCYXNlXT47XHJcblxyXG4vKipcclxuICogRm9yIHRpbWVzIHdoZW4gbW9yZSB0aGFuIGp1c3QgdGhlIGFic3RyYWN0IGVsZW1lbnQgdHlwZSBpcyBuZWVkZWQsXHJcbiAqIGJ1dCB0aGUgYWN0dWFsLCBjb25jcmV0ZSwgaW1wbGVtZW50YXRpb24tYWZmZWN0aW5nIFwiZGl2XCIgc3RyaW5nIHR5cGUuXHJcbiAqIFxyXG4gKiBUT0RPOiBTaG91bGQgdGhpcyBiZSB0aGUgc3RhbmRhcmQgZm9yIGFsbCB0aGUgbm9uLUFSSUEgaG9va3M/XHJcbiAqIFRoZXkgKm5ldmVyKiBjYXJlIGFib3V0IHRoZSBzcGVjaWZpYyB0eXBlIGZvciB0aGUgaW1wbGVtZW50YXRpb24sXHJcbiAqIGp1c3QgZm9yIHR5cGluZywgc28gaXQgd291bGRuJ3QgYmUgbmVjZXNzYXJ5LCBcclxuICogYnV0IGl0IHdvdWxkIGJlIGNvbnNpc3RlbnQgd2l0aCB0aGVzZSBBUklBIGhvb2tzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUYWdTZW5zaXRpdmVQcm9wczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcclxuICAgIHRhZzogRWxlbWVudFRvVGFnPEU+O1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgRXZlbnREZXRhaWwgPSBTeW1ib2woXCJldmVudC1kZXRhaWxcIik7XHJcbmV4cG9ydCB0eXBlIEV2ZW50RGV0YWlsID0gdHlwZW9mIEV2ZW50RGV0YWlsO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuaGFuY2VFdmVudDxFIGV4dGVuZHMgRXZlbnQsIERldGFpbCBleHRlbmRzIG9iamVjdD4oZTogRSwgZGV0YWlsOiBEZXRhaWwpOiBFICYgeyBbRXZlbnREZXRhaWxdOiBEZXRhaWwgfSB7XHJcbiAgICBjb25zdCBldmVudCA9IGUgYXMgRSAmIHsgW0V2ZW50RGV0YWlsXTogRGV0YWlsIH07XHJcbiAgICBldmVudFtFdmVudERldGFpbF0gPSBkZXRhaWw7XHJcbiAgICByZXR1cm4gZXZlbnQ7XHJcbn1cclxuXHJcblxyXG5jb25zdCBhbHJlYWR5V2FybmVkID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcblxyXG50eXBlIFdPTyA9IHN0cmluZyB8IG51bWJlciB8IG51bGwgfCBib29sZWFuIHwgdW5kZWZpbmVkO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHdhcm5Pbk92ZXJ3cml0ZTxUIGV4dGVuZHMgV09PPihjb21wb25lbnROYW1lOiBzdHJpbmcsIHByb3BOYW1lOiBzdHJpbmcsIHByb3BWYWx1ZTogV09PLCBuZXdWYWx1ZTogVCk6IFQge1xyXG4gICAgY29uc3Qga2V5ID0gYCR7Y29tcG9uZW50TmFtZX07JHtwcm9wTmFtZX1gO1xyXG4gICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKCFhbHJlYWR5V2FybmVkLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIGFscmVhZHlXYXJuZWQuYWRkKGtleSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhlICR7cHJvcE5hbWV9IGF0dHJpYnV0ZSBvbiAke2NvbXBvbmVudE5hbWV9IHdhcyBnaXZlbiBhIHZhbHVlIG9mICR7cHJvcFZhbHVlfSBidXQgaXMgYmVpbmcgb3ZlcndyaXR0ZW4gdG8gJHtuZXdWYWx1ZX0gZm9yIGNvbmZvcm1hbmNlLiBDb25zaWRlciByZW1vdmluZyBpdCBiZWZvcmUgcGFzc2luZyB0aG9zZSBwcm9wcyB0byAke2NvbXBvbmVudE5hbWV9LmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV3VmFsdWU7XHJcbn1cclxuXHJcbmxldCBkZWJ1ZyA9IHRydWU7XHJcbmV4cG9ydCBmdW5jdGlvbiBzZXREZWJ1Z0xvZ2dpbmcobG9nZ2luZzogYm9vbGVhbikge1xyXG4gICAgZGVidWcgPSBsb2dnaW5nO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBEZWJ1Z0xvZ1R5cGVzID0gXHJcblwidXNlQXJpYUFjY29yZGlhblwiIHwgXCJ1c2VBcmlhQWNjb3JkaWFuU2VjdGlvblwiIHwgXHJcblwidXNlQXJpYUJ1dHRvblwiIHwgXHJcblwidXNlQXJpYUNoZWNrYm94XCIgfFxyXG5cInVzZUFyaWFDaGVja2JveEdyb3VwXCIgfCBcInVzZUFyaWFDaGVja2JveEdyb3VwUGFyZW50XCIgfCBcInVzZUFyaWFDaGVja2JveEdyb3VwQ2hpbGRcIiB8IFxyXG5cInVzZUFyaWFEaWFsb2dcIiB8IFwidXNlQXJpYURyYXdlclwiIHwgXHJcblwidXNlQXJpYUxpc3Rib3hNdWx0aVwiIHwgXCJ1c2VBcmlhTGlzdGJveE11bHRpSXRlbVwiIHwgXHJcblwidXNlQXJpYUxpc3Rib3hTaW5nbGVcIiB8IFwidXNlQXJpYUxpc3Rib3hTaW5nbGVJdGVtXCIgfCBcclxuXCJ1c2VBcmlhTWVudVwiIHwgXCJ1c2VBcmlhTWVudVN1cmZhY2VcIiB8IFwidXNlQXJpYU1lbnVJdGVtXCIgfCBcInVzZUFyaWFGb2N1c1NlbnRpbmVsXCIgfCBcInVzZUFyaWFNZW51U3VyZmFjZVNlbnRpbmVsXCIgfFxyXG5cInVzZUFyaWFSYWRpb0dyb3VwXCIgfCBcInVzZUFyaWFSYWRpb1wiIHwgXHJcblwidXNlQXJpYVNsaWRlclwiIHwgXCJ1c2VBcmlhU2xpZGVyVGh1bWJcIiB8IFxyXG5cInVzZUFyaWFUYWJsZVwiIHwgXCJ1c2VBcmlhVGFibGVSb3dcIiB8IFwidXNlQXJpYVRhYmxlQ2VsbFwiIHwgXCJ1c2VBcmlhVGFibGVCb2R5XCIgfCBcclxuXCJ1c2VBcmlhVGFic1wiIHwgXCJ1c2VBcmlhVGFiTGlzdFwiIHwgXCJ1c2VBcmlhVGFiXCIgfCBcInVzZUFyaWFUYWJQYW5lbFwiIHwgIFxyXG5cInVzZUFyaWFUb2FzdHNcIiB8IFwidXNlQXJpYVRvYXN0XCIgfCBcclxuXCJ1c2VBcmlhVG9vbHRpcFwiIHwgXCJ1c2VBcmlhVG9vbHRpcFRvb2x0aXBcIiB8IFwidXNlQXJpYVRvb2x0aXBUcmlnZ2VyXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVidWdMb2cod2hvOiBEZWJ1Z0xvZ1R5cGVzLCAuLi5hcmdzOiBQYXJhbWV0ZXJzPCh0eXBlb2YgY29uc29sZSlbXCJsb2dcIl0+KSB7XHJcbiAgICBpZiAoZGVidWcpXHJcbiAgICAgICAgY29uc29sZS5kZWJ1Zyh3aG8gKyBcIjpcIiwgLi4uYXJncyk7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFByb3BNb2RpZmllcjxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XHJcbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB3YXJuT25PdmVyd3JpdGUgfSBmcm9tIFwiLi4vcHJvcHNcIjtcclxuXHJcbmNvbnN0IEhlYWRpbmdMZXZlbENvbnRleHQgPSBjcmVhdGVDb250ZXh0KDApO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRpbmcoeyBjaGlsZHJlbiwgaGVhZGluZywgLi4ucHJvcHMgfTogeyBoZWFkaW5nOiBDb21wb25lbnRDaGlsZHJlbiB9ICYgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SFRNTEhlYWRpbmdFbGVtZW50Pikge1xyXG4gICAgY29uc3QgaGVhZGluZ0xldmVsQmVmb3JlVXMgPSB1c2VDb250ZXh0KEhlYWRpbmdMZXZlbENvbnRleHQpO1xyXG4gICAgY29uc3QgbmV3SGVhZGluZ0xldmVsID0gaGVhZGluZ0xldmVsQmVmb3JlVXMgKyAxO1xyXG4gICAgbGV0IHRhZzogc3RyaW5nO1xyXG4gICAgaWYgKG5ld0hlYWRpbmdMZXZlbCA8PSA2KSB7XHJcbiAgICAgICAgdGFnID0gYGgke25ld0hlYWRpbmdMZXZlbH1gO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGFnID0gJ2Rpdic7XHJcbiAgICAgICAgcHJvcHNbXCJhcmlhLWxldmVsXCJdID0gd2Fybk9uT3ZlcndyaXRlKFwiSGVhZGluZ1wiLCBcImFyaWEtbGV2ZWxcIiwgcHJvcHNbXCJhcmlhLWxldmVsXCJdLCBgJHtuZXdIZWFkaW5nTGV2ZWx9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICA8SGVhZGluZ1Jlc2V0IG5ld0xldmVsPXtoZWFkaW5nTGV2ZWxCZWZvcmVVcyArIDF9PlxyXG4gICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWcgYXMgYW55LCBwcm9wcywgaGVhZGluZyl9XHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L0hlYWRpbmdSZXNldD5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRpbmdSZXNldCh7IG5ld0xldmVsLCBjaGlsZHJlbiB9OiB7IG5ld0xldmVsOiBudW1iZXIsIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbiB9KXsgICAgXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxIZWFkaW5nTGV2ZWxDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtuZXdMZXZlbH0+XHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L0hlYWRpbmdMZXZlbENvbnRleHQuUHJvdmlkZXI+XHJcbiAgICApXHJcbn1cclxuIiwiaW1wb3J0IHsgSW5wdXRzLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0TmF0aXZlLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG4vKipcclxuICogV3JhcCB0aGUgbmF0aXZlIGB1c2VFZmZlY3RgIHRvIGFkZCBhcmd1bWVudHMgXHJcbiAqIHRoYXQgYWxsb3cgYWNjZXNzaW5nIHRoZSBwcmV2aW91cyB2YWx1ZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXHJcbiAqIGFzIHdlbGwgYXMgdGhlIGNoYW5nZXMgdGhhdCBjYXVzZWQgdGhlIGhvb2sgdG8gYmUgY2FsbGVkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXHJcbiAqIFxyXG4gKiBAcGFyYW0gZWZmZWN0IFxyXG4gKiBAcGFyYW0gaW5wdXRzIFxyXG4gKiBAcGFyYW0gaW1wbCBZb3UgY2FuIGNob29zZSB3aGV0aGVyIHRvIHVzZSBgdXNlRWZmZWN0YCBvciBgdXNlTGF5b3V0RWZmZWN0YCBieVxyXG4gKiBwYXNzaW5nIG9uZSBvZiB0aGVtIGFzIHRoaXMgYXJndW1lbnQuIEJ5IGRlZmF1bHQsIGl0J3MgYHVzZUVmZmVjdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlRWZmZWN0PEkgZXh0ZW5kcyBJbnB1dHM+KGVmZmVjdDogKHByZXY6IEkgfCB1bmRlZmluZWQsIGNoYW5nZXM6IEVmZmVjdENoYW5nZTxJLCBudW1iZXI+W10pID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSwgaW5wdXRzPzogSSwgaW1wbCA9IHVzZUVmZmVjdE5hdGl2ZSkge1xyXG5cclxuICAgIGNvbnN0IHByZXZJbnB1dHMgPSB1c2VSZWY8dW5kZWZpbmVkIHwgST4odW5kZWZpbmVkKTtcclxuICAgIGNvbnN0IGVmZmVjdDIgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hhbmdlczogeyBmcm9tOiBhbnksIHRvOiBhbnkgfVtdID0gW107XHJcbiAgICAgICAgaWYgKGlucHV0cyAmJiBwcmV2SW5wdXRzLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1heChwcmV2SW5wdXRzLmN1cnJlbnQubGVuZ3RoLCBpbnB1dHMubGVuZ3RoKTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldklucHV0cy5jdXJyZW50W2ldICE9IGlucHV0c1tpXSlcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzW2ldID0geyBmcm9tOiBwcmV2SW5wdXRzLmN1cnJlbnRbaV0sIHRvOiBpbnB1dHNbaV0gfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJldCA9IGVmZmVjdChwcmV2SW5wdXRzLmN1cnJlbnQsIGNoYW5nZXMpO1xyXG4gICAgICAgIHByZXZJbnB1dHMuY3VycmVudCA9IGlucHV0cztcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfTtcclxuXHJcbiAgICBpbXBsKGVmZmVjdDIsIGlucHV0cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRWZmZWN0Q2hhbmdlPEkgZXh0ZW5kcyBJbnB1dHMsIE4gZXh0ZW5kcyBudW1iZXI+IHsgZnJvbTogSVtOXSwgdG86IElbTl0gfVxyXG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBvcHRpb25zIH0gZnJvbSBcInByZWFjdFwiXG5cbmV4cG9ydCB0eXBlIFBhc3NpdmVTdGF0ZVVwZGF0ZXI8Uz4gPSAodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUykpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUPiA9ICgodmFsdWU6IFQsIHByZXZWYWx1ZTogVCB8IHVuZGVmaW5lZCkgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTtcblxuLyoqXG4gKiBEZWJ1ZyBob29rLlxuICogXG4gKiBHaXZlbiBhIHZhbHVlIG9yIHNldCBvZiB2YWx1ZXMsIGVtaXRzIGEgY29uc29sZSBlcnJvciBpZiBhbnkgb2YgdGhlbSBjaGFuZ2UgZnJvbSBvbmUgcmVuZGVyIHRvIHRoZSBuZXh0LlxuICogXG4gKiBFdmVudHVhbGx5LCB3aGVuIHVzZUV2ZW50IGxhbmRzLCB3ZSBob3BlZnVsbHkgd29uJ3QgbmVlZCB0aGlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRW5zdXJlU3RhYmlsaXR5PFQgZXh0ZW5kcyBhbnlbXT4ocGFyZW50SG9va05hbWU6IHN0cmluZywgLi4udmFsdWVzOiBUKSB7XG4gICAgdXNlSGVscGVyKHZhbHVlcy5sZW5ndGgsIDApO1xuICAgIHZhbHVlcy5mb3JFYWNoKHVzZUhlbHBlcik7XG4gICAgcmV0dXJuO1xuXG5cbiAgICBmdW5jdGlvbiB1c2VIZWxwZXI8VT4odmFsdWU6IFUsIGluZGV4OiBudW1iZXIpIHtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgICAgIGNvbnN0IGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5ID0gdXNlUmVmKHZhbHVlKTtcbiAgICAgICAgY29uc3Qgc2hvd25FcnJvciA9IHVzZVJlZihmYWxzZSk7XG4gICAgICAgIGlmIChoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50ICE9IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXNob3duRXJyb3IuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVGhlIGhvb2sgJHtwYXJlbnRIb29rTmFtZX0gcmVxdWlyZXMgc29tZSBvciBhbGwgb2YgaXRzIGFyZ3VtZW50cyByZW1haW4gc3RhYmxlIGFjcm9zcyBlYWNoIHJlbmRlcjsgcGxlYXNlIGNoZWNrIHRoZSAke2luZGV4fS1pbmRleGVkIGFyZ3VtZW50LmApO1xuICAgICAgICAgICAgICAgIHNob3duRXJyb3IuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZVJlbmRlcmluZyhmOiAoKSA9PiB2b2lkKSB7XG4gICAgKG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPz8gc2V0VGltZW91dCkoZik7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBgdXNlU3RhdGVgLCBidXQgZm9yIHZhbHVlcyB0aGF0IGFyZW4ndCBcInJlbmRlci1pbXBvcnRhbnRcIiAmbmRhc2g7IHVwZGF0ZXMgZG9uJ3QgY2F1c2UgYSByZS1yZW5kZXIgYW5kIHNvIHRoZSB2YWx1ZSBzaG91bGRuJ3QgYmUgdXNlZCBkdXJpbmcgcmVuZGVyICh0aG91Z2ggaXQgY2VydGFpbmx5IGNhbiwgYXQgbGVhc3QgYnkgcmUtcmVuZGVyaW5nIGFnYWluKS5cbiAqIFxuICogVG8gY29tcGVuc2F0ZSBmb3IgdGhpcywgeW91IHNob3VsZCBwYXNzIGEgYHVzZUVmZmVjdGAtZXNxdWUgY2FsbGJhY2sgdGhhdCBpcyBydW4gd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMuICBKdXN0IGxpa2UgYHVzZUVmZmVjdGAsIHRoaXMgY2FsbGJhY2sgY2FuIHJldHVybiBhIGNsZWFudXAgZnVuY3Rpb24gdGhhdCdzIHJ1biBiZWZvcmUgdGhlIHZhbHVlIGNoYW5nZXMuICBJZiB5b3Ugd291bGQgbGlrZSB0byByZS1yZW5kZXIgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyAob3IsIHNheSwgd2hlbiB0aGUgdmFsdWUgbWVldHMgc29tZSBjcml0ZXJpYSksIHRoaXMgaXMgd2hlcmUgeW91J2xsIHdhbnQgdG8gcHV0IGluIGEgY2FsbCB0byBhIGBzZXRTdGF0ZWAgZnVuY3Rpb24uXG4gKiBcbiAqIFRvIHN1bW1hcml6ZSwgaXQncyBsaWtlIGEgYHVzZVN0YXRlYC1gdXNlRWZmZWN0YCBtYXNodXA6XG4gKiBcbiAqIDEuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgdGhpcyB2ZXJzaW9uIG9mIGBzZXRTdGF0ZWAgZG9lc24ndCByZS1yZW5kZXIgdGhlIHdob2xlIGNvbXBvbmVudFxuICogMi4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB5b3UgY2FuIHJ1biBhIGZ1bmN0aW9uIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgdGhhdCBvcHRpb25hbGx5IHJldHVybnMgYSBjbGVhbnVwIGZ1bmN0aW9uXG4gKiAzLiBJdCdzIGxpa2UgYHVzZUVmZmVjdGAsIGV4Y2VwdCB5b3UgdHJpZ2dlciB0aGUgZWZmZWN0IGZ1bmN0aW9uIFwicmVtb3RlbHlcIiBpbnN0ZWFkIG9mIGl0IHJ1bm5pbmcgYWZ0ZXIgcmVuZGVyaW5nXG4gKiA0LiBJdCdzIGxpa2UgYHVzZUVmZmVjdGAsIGV4Y2VwdCB0aGUgc2luZ2xlIFwiZGVwZW5kZW5jeVwiIGlzIGJhc2VkIG9uIHlvdXIgY2FsbHMgdG8gYHNldFN0YXRlYFxuICogXG4gKiBOb3RlIHRoYXQgd2hpbGUgY2FsbGluZyBgc2V0U3RhdGVgIGRvZXNuJ3QgY2F1c2UgYW55IHJlLXJlbmRlcnMsIHlvdSBjYW4gZG8gdGhhdCB3aXRoaW4geW91ciBgb25DaGFuZ2VgIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMgdmlhIHRoYXQgYHNldFN0YXRlYC5cbiAqIFxuICogQHBhcmFtIG9uQ2hhbmdlIFRoZSBcImVmZmVjdFwiIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLiBFZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBgdXNlRWZmZWN0YCdzIFwiZWZmZWN0XCIgZnVuY3Rpb24uICBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHBhcmFtIGdldEluaXRpYWxWYWx1ZSBJZiBwcm92aWRlZCwgdGhlIGVmZmVjdCB3aWxsIGJlIGludm9rZWQgb25jZSB3aXRoIHRoaXMgdmFsdWUgb24gbW91bnQuIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhc3NpdmVTdGF0ZTxUPihvbkNoYW5nZTogdW5kZWZpbmVkIHwgbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQ+LCBnZXRJbml0aWFsVmFsdWU/OiAoKSA9PiBUKTogcmVhZG9ubHkgW2dldFN0YXRlU3RhYmxlOiAoKSA9PiBULCBzZXRTdGF0ZVN0YWJsZTogUGFzc2l2ZVN0YXRlVXBkYXRlcjxUPl0ge1xuICAgIGNvbnN0IGtleSA9IHVzZVJlZihNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkpO1xuXG4gICAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWY8VCB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IGNsZWFudXBDYWxsYmFja1JlZiA9IHVzZVJlZjx1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk+KHVuZGVmaW5lZCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUGFzc2l2ZVN0YXRlXCIsIG9uQ2hhbmdlLCBnZXRJbml0aWFsVmFsdWUpO1xuXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gXCJkZXBlbmRlbmN5IGNoYW5nZWRcIiBhbmQgXCJjb21wb25lbnQgdW5tb3VudGVkXCIuXG4gICAgY29uc3Qgb25TaG91bGRDbGVhblVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2sgPSBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNsZWFudXBDYWxsYmFjaylcbiAgICAgICAgICAgIGNsZWFudXBDYWxsYmFjaygpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZXJlIGFyZSBhIGNvdXBsZSBwbGFjZXMgd2hlcmUgd2UnZCBsaWtlIHRvIHVzZSBvdXIgaW5pdGlhbFxuICAgIC8vIHZhbHVlIGluIHBsYWNlIG9mIGhhdmluZyBubyB2YWx1ZSBhdCBhbGwgeWV0LlxuICAgIC8vIFRoaXMgaXMgdGhlIHNoYXJlZCBjb2RlIGZvciB0aGF0LCB1c2VkIG9uIG1vdW50IGFuZCB3aGVuZXZlclxuICAgIC8vIGdldFZhbHVlIGlzIGNhbGxlZC5cbiAgICBjb25zdCB0cnlFbnN1cmVWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ICYmIGdldEluaXRpYWxWYWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFZhbHVlID0gZ2V0SW5pdGlhbFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKGluaXRpYWxWYWx1ZSwgdW5kZWZpbmVkKSA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0aW9ucyBhcmUgaW50ZW50aW9uYWwgdG8gYWxsb3cgYmFpbG91dCAod2l0aG91dCBleHBvc2luZyB0aGUgVW5zZXQgc3ltYm9sKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgWy8qIGdldEluaXRpYWxWYWx1ZSBhbmQgb25DaGFuZ2UgaW50ZW50aW9uYWxseSBvbWl0dGVkICovXSk7XG5cblxuICAgIGNvbnN0IGdldFZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAod2FybmluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVyaW5nIG9uQ2hhbmdlLCBwcmVmZXIgdXNpbmcgdGhlICh2YWx1ZSwgcHJldlZhbHVlKSBhcmd1bWVudHMgaW5zdGVhZCBvZiBnZXRWYWx1ZSAtLSBpdCdzIGFtYmlndW91cyBhcyB0byBpZiB5b3UncmUgYXNraW5nIGZvciB0aGUgb2xkIG9yIG5ldyB2YWx1ZSBhdCB0aGlzIHBvaW50IGluIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50LlwiKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSBjYWxsIGdldFZhbHVlLCBpZiB3ZSBoYXZlbid0IGJlZW4gZ2l2ZW4gYSB2YWx1ZSB5ZXQsXG4gICAgICAgIC8vIChhbmQgd2Ugd2VyZSBnaXZlbiBhbiBpbml0aWFsIHZhbHVlIHRvIHVzZSlcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBpbml0aWFsIHZhbHVlIGluc3RlYWQgb2Ygbm90aGluZy5cbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0KVxuICAgICAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcblxuICAgICAgICByZXR1cm4gKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkISA6IHZhbHVlUmVmLmN1cnJlbnQhKSBhcyBUO1xuICAgIH0sIFtdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBydW4gb3VyIGVmZmVjdCBhdCBsZWFzdCBvbmNlIG9uIG1vdW50LlxuICAgICAgICAvLyAoSWYgd2UgaGF2ZSBhbiBpbml0aWFsIHZhbHVlLCBvZiBjb3Vyc2UpXG4gICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cblxuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZSBhY3R1YWwgY29kZSB0aGUgdXNlciBjYWxscyB0byAocG9zc2libHkpIHJ1biBhIG5ldyBlZmZlY3QuXG4gICAgY29uc3QgcHJldkRlcCA9IHVzZVJlZjxUIHwgKHR5cGVvZiBVbnNldCk+KFVuc2V0KTtcbiAgICBjb25zdCBzZXRWYWx1ZSA9IHVzZUNhbGxiYWNrPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD4+KChhcmcpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coa2V5LmN1cnJlbnQpO1xuXG4gICAgICAgIC8vIFJlZ2FyZGxlc3Mgb2YgYW55dGhpbmcgZWxzZSwgZmlndXJlIG91dCB3aGF0IG91ciBuZXh0IHZhbHVlIGlzIGFib3V0IHRvIGJlLlxuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQgOiB2YWx1ZVJlZi5jdXJyZW50KSA6IGFyZyk7XG5cblxuICAgICAgICBpZiAocHJldkRlcC5jdXJyZW50ID09PSBVbnNldCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcmVxdWVzdCB0byBjaGFuZ2UgdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRoZSByZXF1ZXN0IGltbWVkaWF0ZWx5LCB0aGVuIHF1ZXVlIHVwIHRoZSBvbkNoYW5nZSBmdW5jdGlvblxuXG4gICAgICAgICAgICAvLyBTYXZlIG91ciBjdXJyZW50IHZhbHVlIHNvIHRoYXQgd2UgY2FuIGNvbXBhcmUgYWdhaW5zdCBpdCBsYXRlclxuICAgICAgICAgICAgLy8gKGlmIHdlIGZsaXAgYmFjayB0byB0aGlzIHN0YXRlLCB0aGVuIHdlIHdvbid0IHNlbmQgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgcHJldkRlcC5jdXJyZW50ID0gdmFsdWVSZWYuY3VycmVudDtcblxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIGFjdHVhbCBjaGVjayBhbmQgaW52b2NhdGlvbiBvZiBvbkNoYW5nZSBsYXRlciB0byBsZXQgZWZmZWN0cyBzZXR0bGVcbiAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGVwID0gdmFsdWVSZWYuY3VycmVudCEgYXMgVDtcbiAgICAgICAgICAgICAgICBpZiAocHJldkRlcC5jdXJyZW50ICE9IHZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhbnkgcmVnaXN0ZXJlZCBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNob3VsZENsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4obmV4dERlcCwgcHJldkRlcC5jdXJyZW50ID09PSBVbnNldD8gdW5kZWZpbmVkIDogcHJldkRlcC5jdXJyZW50KSA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHREZXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBub3JtYWxseSBjYWxsIGdldFZhbHVlIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UndmUgZmluaXNoZWQgd2l0aCBldmVyeXRoaW5nLCBzbyBtYXJrIHVzIGFzIGJlaW5nIG9uIGEgY2xlYW4gc2xhdGUgYWdhaW4uXG4gICAgICAgICAgICAgICAgcHJldkRlcC5jdXJyZW50ID0gVW5zZXQ7XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2YWx1ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNoZWNrZWQgYWdhaW5zdCBwcmV2RGVwIHRvIHNlZSBpZiB3ZSBzaG91bGQgYWN0dWFsbHkgY2FsbCBvbkNoYW5nZVxuICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtnZXRWYWx1ZSwgc2V0VmFsdWVdIGFzIGNvbnN0O1xufVxuXG5jb25zdCBVbnNldCA9IFN5bWJvbCgpO1xuXG4vLyBFYXN5IGNvbnN0YW50cyBmb3IgZ2V0SW5pdGlhbFZhbHVlXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHsgcmV0dXJuIHRydWU7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuTnVsbCgpIHsgcmV0dXJuIG51bGw7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5VbmRlZmluZWQoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5aZXJvKCkgeyByZXR1cm4gMDsgfSIsIlxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwiLi91c2UtZWZmZWN0XCI7XG5pbXBvcnQgeyBkZWJvdW5jZVJlbmRlcmluZywgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJldHVyblRydWUsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcblxuXG4vKipcbiAqIFxuICogVGhlcmUgYXJlIHNldmVyYWwgZGlmZmVyZW50IHdheXMgdGhhdCBhIGZvY3VzIGV2ZW50IGNhbiBoYXBwZW4uICBBc3N1bWVcbiAqIHRoZSBmb2xsb3dpbmcgc3RlcHMgaGFwcGVuIGluIG9yZGVyOlxuICogXG4gKiAxLiBUaGUgcGFnZSBsb2Fkcy5cbiAqICAgICogTm90aGluZyBpcyBmb2N1c2VkLCBidXQgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGBib2R5YC4gXG4gKiAgICAqIE5vIGZvY3VzIGV2ZW50cyBhcmUgZmlyZWQuXG4gKiAyLiBUaGUgd2luZG93IGlzIGZvY3VzZWQsIGFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIHJlbWFpbnMgYXMgYGJvZHlgLlxuICogICAgKiBBIGBmb2N1c2AvYGZvY3VzaW5gIGV2ZW50ICpNSUdIVCogYmUgZmlyZWQgZm9yIGBib2R5YC4gRGVwZW5kaW5nIG9uXG4gKiAgICAgIHRoZSBicm93c2VyLCB0aGlzIGRlcGVuZHMgb24gd2hldGhlciB0aGUgaGFuZGxlciB3YXMgYXR0YWNoZWQgdG8gYHdpbmRvd2Agb3IgYGRvY3VtZW50YC5cbiAqICAgICAgUHJvYmFibHkganVzdCBiZXN0IHRvIG5vdCByZWx5IG9uIGl0LCBvciBsaXN0ZW4gdG8gYHdpbmRvd2AgZm9jdXMgZXZlbnRzIGRpcmVjdGx5LlxuICogMy4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBuZXcgZWxlbWVudCBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXG4gKiAgICAqIGBmb2N1c291dGAgYW5kIGBibHVyYCBhcmUgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxuICogICAgKiBgZm9jdXNgIGFuZCBgZm9jdXNpbmAgYXJlIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwuXG4gKiA0LiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cbiAqICAgICogKipUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgYGJvZHlgKiogYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxuICogICAgKiBgYmx1cmAgYW5kIGBmb2N1c291dGAgYXJlIGZpcmVkIG9uIHRoZSBvbGQgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBuZXcgZWxlbWVudC5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBub3cgc2V0IHRvIHRoZSBuZXcgZWxlbWVudC5cbiAqICAgICogYGZvY3VzaW5gIGlzIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBvbGQgZWxlbWVudC5cbiAqIDUuIEFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byBgYm9keWAuXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cbiAqICAgICogYGZvY3VzaW5gIGlzICpub3QqIGZpcmVkIG9uIGBib2R5YC5cbiAqIFxuICogXG4gKiBJbiBzdW1tYXJ5OlxuICogMS4gRm9jdXMgZXZlbnRzICpkbyogbm90aWZ5IHVzIG9mIGFsbCBjaGFuZ2VzIGluIGZvY3VzLCBidXQgdGhlcmUgaXMgbm8gb25lIHNpbmdsZSBjb21wcmVoZW5zaXZlIGV2ZW50IHRoYXQgcHJvdmlkZXMgdXMgd2l0aCBhbGwgYXZhaWxhYmxlIGluZm9ybWF0aW9uLlxuICogMi4gYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgICppcyBub3QqIGFsd2F5cyB0aGUgc2FtZSBhcyB3aGF0J3MgYmVpbmcgcmVmZXJlbmNlZCBieSBhIGZvY3VzIGV2ZW50LiBJbiBwYXJ0aWN1bGFyLCBpdCBtYXkgYmVjb21lIGBib2R5YCBhdCBhbnkgYXJiaXRyYXJ5IHRpbWUuXG4gKiAzLiBBIGBibHVyYCB3aXRob3V0IGEgYGZvY3VzYCBjYW4gYW5kIHdpbGwgb2NjdXIuIFRoaXMgbWVhbnMgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHNvbGVseSB1c2UgYGZvY3VzYCB0byBkZXRlY3QgYWxsIGNoYW5nZXMuXG4gKiA0LiBBIGBibHVyYCBldmVudCB3aG9zZSBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIGZvbGxvd2luZyBgZm9jdXNgIGV2ZW50LlxuICogXG4gKiBcbiAqIEBwYXJhbSBjYWxsYmFjayBcbiAqIEByZXR1cm5zIFxuICovXG5jb25zdCBfZHVtbXkgPSAwO1xuXG5jb25zdCBhY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGU6IE5vZGUgfCBudWxsKSA9PiB2b2lkKT4+KCk7XG5jb25zdCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBOb2RlKSA9PiB2b2lkKT4+KCk7XG5jb25zdCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHZvaWQpPj4oKTtcbmNvbnN0IHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIGJvb2xlYW4+KCk7XG5cbmNvbnN0IG1pY3JvdGFza3MgPSBuZXcgTWFwPFNldDxhbnk+LCBhbnk+KCk7XG5cbi8vIFRoZSBmb2N1c2luIGFuZCBmb2N1c291dCBldmVudHMgb2Z0ZW4gZmlyZSBzeW5jcm9ub3VzbHkgaW4gdGhlIG1pZGRsZSBvZiBydW5uaW5nIGNvZGUuXG4vLyBFLkcuIGNhbGxpbmcgZWxlbWVudC5mb2N1cygpIGNhbiBjYXVzZSBhIGZvY3VzaW4gZXZlbnQgaGFuZGxlciB0byBpbW1lZGlhdGVseSBpbnRlcnJ1cHQgdGhhdCBjb2RlLlxuLy8gRm9yIHRoZSBwdXJwb3NlIG9mIGltcHJvdmluZyBzdGFiaWxpdHksIHdlIGRlYm91bmNlIGFsbCBmb2N1cyBldmVudHMgdG8gdGhlIG5leHQgbWljcm90YXNrLlxuZnVuY3Rpb24gZm9yRWFjaFVwZGF0ZXI8VD4od2luZG93OiBXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBtYXA6IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBUKSA9PiB2b2lkKT4+LCB2YWx1ZTogVCkge1xuICAgIGNvbnN0IHVwZGF0ZXJzS2V5ID0gbWFwLmdldCh3aW5kb3cpO1xuICAgIGlmICh1cGRhdGVyc0tleSkge1xuICAgICAgICBpZiAoIW1pY3JvdGFza3MuaGFzKHVwZGF0ZXJzS2V5KSkge1xuICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXJzS2V5ID0gbWFwLmdldCh3aW5kb3cpITtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1pY3JvdGFza3MuZ2V0KHVwZGF0ZXJzS2V5KTtcbiAgICAgICAgICAgICAgICBtaWNyb3Rhc2tzLmRlbGV0ZSh1cGRhdGVyc0tleSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlcnNLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB1cGRhdGVyIG9mIHVwZGF0ZXJzS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVyPy4odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBtaWNyb3Rhc2tzLnNldCh1cGRhdGVyc0tleSwgdmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9jdXNvdXQoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG4gICAgaWYgKGUucmVsYXRlZFRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBudWxsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEp1c3Qgd2FpdCBmb3IgdGhlIGZvY3VzaW4gZXZlbnQuXG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGZvY3VzaW4oZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIGNvbnN0IGN1cnJlbnRseUZvY3VzZWRFbGVtZW50ID0gZS50YXJnZXQgYXMgKEVsZW1lbnQgJiBIVE1MT3JTVkdFbGVtZW50KTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGFjdGl2ZUVsZW1lbnRVcGRhdGVycywgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycywgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiB3aW5kb3dGb2N1cyhlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS50YXJnZXQgOiBlLmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLmN1cnJlbnRUYXJnZXQgOiAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyk7XG4gICAgd2luZG93c0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCB0cnVlKTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIHdpbmRvd0ZvY3VzZWRVcGRhdGVycywgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHdpbmRvd0JsdXIoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUudGFyZ2V0IDogZS5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS5jdXJyZW50VGFyZ2V0IDogKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgZmFsc2UpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLCBmYWxzZSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMge1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxFbGVtZW50IHwgbnVsbD47XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMgYW5kIGlzIG5vdCBudWxsLiBcbiAgICAgKiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8RWxlbWVudD47XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIHdpbmRvdyBnYWlucy9sb3NlcyBmb2N1cy4gTXVzdCBiZSBzdGFibGUuXG4gICAgICovXG4gICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8Ym9vbGVhbj47XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGRvY3VtZW50IGFzc29jaWF0ZWQgd2l0aCB3aGF0ZXZlciBlbGVtZW50cyB3ZSdyZSBsaXN0ZW5pbmcgdG8uXG4gICAgICogXG4gICAgICogRS5HLiBzb21lRGl2RWxlbWVudC5vd25lckRvY3VtZW50XG4gICAgICogXG4gICAgICogKipNVVNUKiogYmUgc3RhYmxlXG4gICAgICovXG4gICAgZ2V0RG9jdW1lbnQoKTogRG9jdW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCBldmVudCBoYW5kbGVycyBhcmUgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50J3MgZGVmYXVsdFZpZXcgV2luZG93LlxuICAgICAqIElmIHlvdSBuZWVkIHNvbWV0aGluZyBkaWZmZXJlbnQsIG92ZXJyaWRlIGl0IGhlcmUuXG4gICAgICogXG4gICAgICogKipNVVNUKiogYmUgc3RhYmxlXG4gICAgICovXG4gICAgZ2V0V2luZG93Pyhkb2N1bWVudDogRG9jdW1lbnQpOiBXaW5kb3c7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUge1xuICAgIC8qKiBcbiAgICAgKiBSZXR1cm5zIHdoYXRldmVyIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWQsIG9yIGBudWxsYCBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50IHwgbnVsbDtcbiAgICAvKiogXG4gICAgICogUmV0dXJucyB3aGF0ZXZlciBlbGVtZW50IGlzIGN1cnJlbnRseSBmb2N1c2VkLCBvciB3aGF0ZXZlciBlbGVtZW50IHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnRcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQ6ICgpID0+IEVsZW1lbnQ7XG4gICAgLyoqIFxuICAgICAqIFJldHVybnMgaWYgdGhlIHdpbmRvdyBpdHNlbGYgaGFzIGZvY3VzIG9yIG5vdFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBnZXRXaW5kb3dGb2N1c2VkOiAoKSA9PiBib29sZWFuO1xufVxuXG4vKipcbiAqIEFsbG93cyB5b3UgdG8gaW5zcGVjdCB3aGljaCBlbGVtZW50IGluIHRoZSBgZG9jdW1lbnRgIGN1cnJlbnRseSBoYXMgZm9jdXMsIHdoaWNoIHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgbm9uZSBhcmUgY3VycmVudGx5LCBhbmQgd2hldGhlciBvciBub3QgdGhlIHdpbmRvdyBoYXMgZm9jdXMgYnkgcmV0dXJuaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICogKiBgZ2V0QWN0aXZlRWxlbWVudCgpYFxuICogKiBgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQoKWBcbiAqICogYGdldFdpbmRvd0ZvY3VzZWQoKWBcbiAqIFxuICogKFRoZSBkb2N1bWVudCdzIGJvZHkgcmVjZWl2aW5nIGZvY3VzLCBsaWtlIGl0IGRvZXMgd2hlbiB5b3UgY2xpY2sgb24gYW4gZW1wdHkgYXJlYSwgaXMgY291bnRlZCBhcyBubyBlbGVtZW50IGhhdmluZyBmb2N1cyBmb3IgYWxsIGludGVudHMgYW5kIHB1cnBvc2VzKVxuICogXG4gKiBUaGlzIGlzIGEgcGFzc2l2ZSBob29rLCBzbyBieSBkZWZhdWx0IGl0IHJldHVybnMgZ2V0dGVyIGZ1bmN0aW9ucyB0aGF0IHJlcG9ydCB0aGlzIGluZm9ybWF0aW9uIGJ1dCB0aGUgY29tcG9uZW50IHdpbGwgbm90IHJlLXJlbmRlciBieSBkZWZhdWx0IHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMuXG4gKiBcbiAqIElmIHlvdSBuZWVkIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMsIHVzZSB0aGUgYG9uKkNoYW5nZWAgYXJndW1lbnRzIHRvIHNldCBzb21lIHN0YXRlIG9uIHlvdXIgZW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aXZlRWxlbWVudCh7IG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCBnZXREb2N1bWVudCwgZ2V0V2luZG93IH06IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzKTogVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUge1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlQWN0aXZlRWxlbWVudFwiLCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IChnZXRXaW5kb3c/Lihkb2N1bWVudCkgPz8gZG9jdW1lbnQ/LmRlZmF1bHRWaWV3KTtcblxuICAgICAgICBpZiAoKGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KT8uc2l6ZSA/PyAwKSA9PT0gMCkge1xuICAgICAgICAgICAgZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGZvY3VzaW4sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZm9jdXNvdXQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHdpbmRvd0JsdXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGVtIGV2ZW4gaWYgdGhleSdyZSB1bmRlZmluZWQgdG8gbW9yZSBlYXNpbHlcbiAgICAgICAgLy8gbWFuYWdlIHRoZSBcIj4wIG1lYW5zIGRvbid0IGFkZCBoYW5kbGVyc1wiIGxvZ2ljLlxuICAgICAgICBjb25zdCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XG5cbiAgICAgICAgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMuYWRkKHNldEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGUgfCBudWxsPik7XG4gICAgICAgIGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5hZGQoc2V0TGFzdEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGU+KTtcbiAgICAgICAgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMuYWRkKHNldFdpbmRvd0ZvY3VzZWQpO1xuXG4gICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyk7XG4gICAgICAgIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzKTtcbiAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUoc2V0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZSB8IG51bGw+KTtcbiAgICAgICAgICAgIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykhLmRlbGV0ZShzZXRMYXN0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZT4pO1xuICAgICAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUoc2V0V2luZG93Rm9jdXNlZCk7XG5cbiAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0KTtcbiAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cyk7XG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgW2dldEFjdGl2ZUVsZW1lbnQsIHNldEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnQgfCBudWxsPihvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwpO1xuICAgIGNvbnN0IFtnZXRMYXN0QWN0aXZlRWxlbWVudCwgc2V0TGFzdEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnQ+KG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwgYXMgKCkgPT4gbmV2ZXIpO1xuICAgIGNvbnN0IFtnZXRXaW5kb3dGb2N1c2VkLCBzZXRXaW5kb3dGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIHJldHVyblRydWUpO1xuXG4gICAgcmV0dXJuIHsgZ2V0QWN0aXZlRWxlbWVudCwgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsIGdldFdpbmRvd0ZvY3VzZWQgfTtcbn1cbiIsIlxuaW1wb3J0IHsgQ29tcG9uZW50LCBvcHRpb25zLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEVmZmVjdENhbGxiYWNrLCBJbnB1dHMsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cblxuXG5jb25zdCBUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLVwiO1xuXG5mdW5jdGlvbiBiYXNlNjQodmFsdWU6IG51bWJlcikge1xuICAgIHJldHVybiBUYWJsZVt2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTZCaXRzKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAwYjEwMDAwMDApO1xufVxuXG5mdW5jdGlvbiByYW5kb202NEJpdHMoKSB7XG4gICAgcmV0dXJuIFtyYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpXSBhcyBjb25zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIHdpdGggYW4gb3B0aW9uYWwgcHJlZml4LlxuICogTm90ZSB0aGF0IGlmIHRoZSBwcmVmaXggaXMgKmV4cGxpY2l0bHkqIHNldCB0byBcIlwiLCB0aGVuXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxuICogXG4gKiBcbiAqIChUaGlzIGlzIGhlcmUsIGluIHRoaXMgcGFydGljdWxhciBmaWxlLCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbiAqIHdpdGhvdXQgYWxzbyBtYWtpbmcgYSB1dGlsaXRpZXMgZmlsZS5cbiAqIE9uY2Ugd2UgY2FuIHJlbW92ZSB0aGlzIGhvb2ssIHdlIGNhbiBwdXQgdGhpcyBmdW5jdGlvbiBiYWNrIHdpdGggdXNlUmFuZG9tSWQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeD86IHN0cmluZykge1xuICAgIHJldHVybiBgJHtwcmVmaXggPz8gXCJpZC1cIn0ke3JhbmRvbTY0Qml0cygpLm1hcChuID0+IGJhc2U2NChuKSkuam9pbihcIlwiKX1gO1xufVxuXG5jb25zdCBwcmV2aW91c0lucHV0cyA9IG5ldyBNYXA8c3RyaW5nLCBJbnB1dHMgfCB1bmRlZmluZWQ+KCk7XG5jb25zdCB0b1J1biA9IG5ldyBNYXA8c3RyaW5nLCB7IGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cywgY2xlYW51cDogbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWQgfCAoKCkgPT4gdm9pZCkgfT4oKTtcblxuXG4vLyBUT0RPOiBXaGV0aGVyIHRoaXMgZ29lcyBpbiBvcHRpb25zLmRpZmZlZCBvciBvcHRpb25zLl9jb21taXRcbi8vIGlzIGEgcG9zdC1zdXNwZW5zZSBxdWVzdGlvbi5cbi8vIFJpZ2h0IG5vdywgdXNpbmcgb3B0aW9ucy5fY29tbWl0IGhhcyB0aGUgcHJvYmxlbSBvZiBydW5uaW5nXG4vLyAqYWZ0ZXIqIHJlZnMgYXJlIGFwcGxpZWQsIGJ1dCB3ZSBuZWVkIHRvIGNvbWUgYmVmb3JlIGV2ZW4gdGhhdFxuLy8gc28gYHJlZj17c29tZVN0YWJsZUZ1bmN0aW9ufWAgd29ya3MuXG4vLyBcbi8vIEFsc28gaXQncyBwcml2YXRlLlxuLy9cbi8vIC4uLlxuLy8gV2VsbCwgdXNlRXZlbnQgb3Igd2hhdGV2ZXIgaXMgZmluYWxseSwgZmluYWxseSA0IHllYXJzIGxhdGVyIGZpbmFsbHkgaGVyZVxuLy8gd2hpY2ggaXMgY29vbCBhbmQgbWVhbnMgd2Ugd29uJ3QgbmVlZCB0aGlzIGF0IGFsbCBzb29uLlxuLy8gU28gZm9yIG5vdyB3ZSdsbCBzdGljayB3aXRoIGRpZmYgdG8gcHJldmVudCBhbnkgd2VpcmRuZXNzIHdpdGhcbi8vIGNvbW1pdCBiZWluZyBwcml2YXRlIGFuZCBhbGwuXG5jb25zdCBjb21taXROYW1lID0gXCJkaWZmZWRcIjtcblxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdIGFzICh2bm9kZTogVk5vZGUsIGNvbW1pdFF1ZXVlOiBDb21wb25lbnRbXSkgPT4gdm9pZDtcbmNvbnN0IG5ld0NvbW1pdDogdHlwZW9mIG9yaWdpbmFsQ29tbWl0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZWZmZWN0SW5mb10gb2YgdG9SdW4pIHtcbiAgICAgICAgY29uc3Qgb2xkSW5wdXRzID0gcHJldmlvdXNJbnB1dHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKG9sZElucHV0cywgZWZmZWN0SW5mby5pbnB1dHMpKSB7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXA/LigpO1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLnNldChpZCwgZWZmZWN0SW5mby5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUnVuLmNsZWFyKCk7XG4gICAgb3JpZ2luYWxDb21taXQ/LiguLi5hcmdzKTtcbn1cbm9wdGlvbnNbY29tbWl0TmFtZV0gPSBuZXdDb21taXQgYXMgbmV2ZXJcblxuLyoqXG4gKiBTZW1pLXByaXZhdGUgZnVuY3Rpb24gdG8gYWxsb3cgc3RhYmxlIGNhbGxiYWNrcyBldmVuIHdpdGhpbiBgdXNlTGF5b3V0RWZmZWN0YCBhbmQgcmVmIGFzc2lnbm1lbnQuXG4gKiBcbiAqIEV2ZXJ5IHJlbmRlciwgd2Ugc2VuZCB0aGUgYXJndW1lbnRzIHRvIGJlIGV2YWx1YXRlZCBhZnRlciBkaWZmaW5nIGhhcyBjb21wbGV0ZWQsXG4gKiB3aGljaCBoYXBwZW5zIGJlZm9yZS5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgaW5wdXRzPzogSW5wdXRzKSB7XG5cbiAgICAvKigoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSB1c2VSZWY8dm9pZCB8ICgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpO1xuICAgICAgICBjb25zdCBwcmV2QXJnc1JlZiA9IHVzZVJlZjxJbnB1dHM+KG51bGwhKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKGlucHV0cywgcHJldkFyZ3NSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICAgIHByZXZBcmdzUmVmLmN1cnJlbnQgPSBpbnB1dHMhO1xuICAgICAgICAgICAgaWYgKGNsZWFudXAuY3VycmVudClcbiAgICAgICAgICAgICAgICBjbGVhbnVwLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCA9IGVmZmVjdCgpO1xuICAgICAgICB9XG4gICAgfSkoKTsqL1xuXG4gICAgY29uc3QgW2lkXSA9IHVzZVN0YXRlKCgpID0+IGdlbmVyYXRlUmFuZG9tSWQoKSk7XG4gICAgdG9SdW4uc2V0KGlkLCB7IGVmZmVjdCwgaW5wdXRzLCBjbGVhbnVwOiBudWxsIH0pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgfSwgW2lkXSlcbn1cblxuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncz86IElucHV0cywgbmV3QXJncz86IElucHV0cyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhIShcbiAgICAgICAgIW9sZEFyZ3MgfHxcbiAgICAgICAgb2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3M/Lmxlbmd0aCB8fFxuICAgICAgICBuZXdBcmdzPy5zb21lKChhcmcsIGluZGV4KSA9PiBhcmcgIT09IG9sZEFyZ3NbaW5kZXhdKVxuICAgICk7XG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUJlZm9yZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdFwiO1xuXG5jb25zdCBVbnNldCA9IFN5bWJvbChcInVuc2V0XCIpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IHZhbHVlLCByZXR1cm5zIGEgY29uc3RhbnQgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gKiBcbiAqIFRoaXMgdXNlcyBgb3B0aW9ucy5kaWZmZWRgIGluIG9yZGVyIHRvIHJ1biBiZWZvcmUgZXZlcnl0aGluZywgZXZlblxuICogcmVmIGFzc2lnbm1lbnQuIFRoaXMgbWVhbnMgdGhpcyBnZXR0ZXIgaXMgc2FmZSB0byB1c2UgYW55d2hlcmUgKioqZXhjZXB0IHRoZSByZW5kZXIgcGhhc2UqKiouXG4gKiBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlR2V0dGVyPFQ+KHZhbHVlOiBUKTogKCkgPT4gVCB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KFVuc2V0IGFzIHVua25vd24gYXMgVCk7XG4gICAgdXNlQmVmb3JlTGF5b3V0RWZmZWN0KCgpID0+IHsgcmVmLmN1cnJlbnQgPSB2YWx1ZTsgfSwgW3ZhbHVlXSk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50IGFzIHVua25vd24gPT09IFVuc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUdldHRlcigpIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlci4nKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgICB9LCBbXSlcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cblxuLyoqXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXG4gKiBzbyB0aGF0IGl0IGNhbiBiZSBleGNsdWRlZCBmcm9tIHRoZSBkZXBlbmRlbmN5IGFycmF5cyBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcy5cbiAqIFxuICogRG8gbm90IHVzZSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSEgIGB1c2VMYXlvdXRFZmZlY3RgIGlzIGZpbmUgdGhvdWdoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlQ2FsbGJhY2s8VCBleHRlbmRzICguLi5fYXJnczogYW55W10pID0+IGFueT4oZm46IFQpOiBUIHtcbiAgICBjb25zdCBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIgPSB1c2VTdGFibGVHZXR0ZXI8VD4oZm4pO1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KTogUmV0dXJuVHlwZTxUPiA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIoKSguLi5hcmdzKTtcbiAgICB9LCBbXSkgYXMgVDtcbn0iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlQmF0Y2hlZEFuaW1hdGlvbkZyYW1lcyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcblxuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJhZGRDYWxsYmFja1wiXT4oKGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5zZXQoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKTsgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJyZW1vdmVDYWxsYmFja1wiXT4oKGNhbGxiYWNrKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LmRlbGV0ZShjYWxsYmFjayk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnRleHRJbmZvID0gdXNlUmVmPENvbnRleHRUeXBlPihudWxsISk7XG4gICAgaWYgKGNvbnRleHRJbmZvLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgY29udGV4dEluZm8uY3VycmVudCA9IHsgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrIH07XG4gICAgY29uc3QgYWxsQ2FsbGJhY2tzID0gdXNlUmVmPE1hcDxSYWZDYWxsYmFja1R5cGUsIGFueT4+KG51bGwhKTtcbiAgICBpZiAoYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gLTE7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFmV2l0aEJhdGNoZWRDYWxsYmFja3MobXNTaW5jZUxhc3Q6IG51bWJlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hlZFJhZkNhbGxiYWNrLCB0YWddIG9mIGFsbENhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlZFJhZkNhbGxiYWNrKG1zU2luY2VMYXN0LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEluZm8uY3VycmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyPilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdpdGggZWZmZWN0aXZlbHkgdGhlIHNhbWUgcnVsZXMgYXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKiBcbiAgICAgKiBEb2Vzbid0IG5lZWQgdG8gYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiBudWxsIHwgKChtc1NpbmNlTGFzdDogbnVtYmVyKSA9PiB2b2lkKTtcbn1cblxuLyoqXG4gKiBUaGUgKG9wdGlvbmFsbHkgbm9uLXN0YWJsZSkgYGNhbGxiYWNrYCB5b3UgcHJvdmlkZSB3aWxsIHN0YXJ0IHJ1bm5pbmcgZXZlcnkgZnJhbWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gKiBcbiAqIFBhc3NpbmcgYG51bGxgIGlzIGZpbmUgYW5kIHNpbXBseSBzdG9wcyB0aGUgZWZmZWN0IHVudGlsIHlvdSByZXN0YXJ0IGl0IGJ5IHByb3ZpZGluZyBhIG5vbi1udWxsIGNhbGxiYWNrLlxuICogXG4gKiAqKlRoaXMgaG9vayBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXQgYWxsLCBpbmNsdWRpbmcgbm8gcHJvcC1tb2RpZnlpbmcgaG9va3MqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQW5pbWF0aW9uRnJhbWUoeyBjYWxsYmFjayB9OiBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMpOiB2b2lkIHtcbiAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2l2ZW4gY2FsbGJhY2sgdGhhdCdzIHN0YWJsZVxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2sgPz8gbm9vcCk7XG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSAoY2FsbGJhY2sgIT0gbnVsbCk7XG5cbiAgICBjb25zdCBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSB1c2VDb250ZXh0KFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuYWRkQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LnJlbW92ZUNhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFsc28gY2FsbHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgcmFmQ2FsbGJhY2sgPSAobXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVDYWxsYmFjayhtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCwgaGFzQ2FsbGJhY2tdKVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH07XG5cblxuICAgIGNvbnNvbGUuYXNzZXJ0KHJlZi5jdXJyZW50ID09PSBzdGF0ZSB8fCAodHlwZW9mIHN0YXRlID09PSBcIm51bWJlclwiICYmIGlzTmFOKHN0YXRlKSkpO1xuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiaW1wb3J0IHsgSW5wdXRzLCB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0TmF0aXZlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWZmZWN0Q2hhbmdlLCB1c2VFZmZlY3QgfSBmcm9tIFwiLi91c2UtZWZmZWN0XCI7XG5cbi8qKlxuICogV3JhcCB0aGUgbmF0aXZlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGFkZCBhcmd1bWVudHMgXG4gKiB0aGF0IGFsbG93IGFjY2Vzc2luZyB0aGUgcHJldmlvdXMgdmFsdWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYXMgd2VsbCBhcyB0aGUgY2hhbmdlcyB0aGF0IGNhdXNlZCB0aGUgaG9vayB0byBiZSBjYWxsZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3Q8SSBleHRlbmRzIElucHV0cz4oZWZmZWN0OiAocHJldjogSSB8IHVuZGVmaW5lZCwgY2hhbmdlczogRWZmZWN0Q2hhbmdlPEksIG51bWJlcj5bXSkgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpLCBpbnB1dHM/OiBJKSB7XG4gICAgcmV0dXJuIHVzZUVmZmVjdChlZmZlY3QsIGlucHV0cywgdXNlTGF5b3V0RWZmZWN0TmF0aXZlKTtcbn1cbiIsImltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUsIGRlYm91bmNlUmVuZGVyaW5nIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG4vKipcbiAqIFJlbWluZGVyIG9mIG9yZGVyIG9mIGV4ZWN1dGlvbjpcbiAqIFxuICogKiAodHJlZSBtb3VudHMpXG4gKiAqIFBhcmVudCByZW5kZXJzXG4gKiAqIENoaWxkcmVuIHJlbmRlclxuICogKiBDaGlsZHJlbiByZWNlaXZlIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogUGFyZW50IHJlY2VpdmVzIHJlZiAoaWYgYXBwbGljYWJsZSlcbiAqICogQ2hpbGRyZW4gcnVuIGVmZmVjdHNcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0c1xuICogXG4gKiAqICh0cmVlIHVubW91bnRzKVxuICogKiBQYXJlbnQgcnVucyBlZmZlY3QtY2xlYW51cFxuICogKiBQYXJlbnQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkIHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogQ2hpbGQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiBcbiAqIFR3byB0aGluZ3MgdG8gbm90ZSBoZXJlOlxuICogKiBSZW5kZXJpbmcgc3RhcnRzIGF0IHRoZSByb290LCAgYnV0IGVmZmVjdHMgYW5kIHJlZnMgc3RhcnQgYXQgdGhlIGxlYXZlcy5cbiAqICogcmVmcyBhcmUgKnVzdWFsbHkqIGNhbGxlZCBiZWZvcmUgZWZmZWN0cywgYnV0IG9ubHkgd2hlbiB0aGF0IEhUTUxFbGVtZW50IHJlbmRlcnMuIEJhc2ljYWxseSBqdXN0IGEgcmVtaW5kZXIgdGhhdCBhIGNvbXBvbmVudCBjYW4gYmUgbW91bnRlZCB3aXRob3V0IGl0IGV4aXN0aW5nIGluIHRoZSBET00uXG4gKi9cbmNvbnN0IF9jb21tZW50cyA9IHZvaWQgKDApO1xuXG5cbi8qKlxuICogSW5mb3JtYXRpb24gdGhhdCBjaGlsZHJlbiBhbmQgcGFyZW50cyB1c2UgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyLlxuICogXG4gKiAqIGBpbmRleGAgcmVmZXJzIHRvIHdoaWNoIGNoaWxkIHRoaXMgaXMuXG4gKiAqIGBmbGFnc2AgYXJlIHF1aWNrLWFuZC1lYXN5IGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCB5b3UgY2FuIG9wdGlvbmFsbHkgdXNlXG4gKiAqIGBzdWJJbmZvYCBpcyBhbnl0aGluZyB1c2VkIGJ5IGEgZGVyaXZlZCBob29rLiBgdXNlUm92aW5nVGFiSW5kZXhgLCBmb3IgZXhhbXBsZSwgbmVlZHMgdG8ga25vdyBob3cgdG8gZm9jdXMgYW4gYXJiaXRyYXJ5IGNoaWxkLCBzbyB0aGUgY2hpbGQgcG9wdWxhdGVzIGBpbmZvYCB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGEgbWV0aG9kIGNhbGxlZCBgZm9jdXNTZWxmYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRJbmZvPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBpbmRleDogVDtcbiAgICBmbGFncz86IFBhcnRpYWw8UmVjb3JkPEssIENoaWxkRmxhZ09wZXJhdGlvbnM+PjtcbiAgICBzdWJJbmZvOiBDO1xufVxuXG5cblxuZXhwb3J0IHR5cGUgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChtb3VudGVkOiBTZXQ8VD4sIHVubW91bnRlZDogU2V0PFQ+KSA9PiB2b2lkKTtcbmV4cG9ydCB0eXBlIE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgoY2F1c2VyczogSXRlcmFibGU8VD4pID0+IHZvaWQpO1xuXG5pbnRlcmZhY2UgTUNQPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmc+IHtcbiAgICAvKipcbiAgICAgKiBSdW5zIGFmdGVyIG9uZSBvciBtb3JlIGNoaWxkcmVuIGhhdmUgdXBkYXRlZCB0aGVpciBpbmZvcm1hdGlvbiAoaW5kZXgsIGV0Yy4pLlxuICAgICAqIFxuICAgICAqIE9ubHkgb25lIHdpbGwgcnVuIHBlciB0aWNrLCBqdXN0IGxpa2UgbGF5b3V0RWZmZWN0LCBidXQgaXQgaXNuJ3RcbiAgICAgKiAqZ3VhcmFudGVlZCogdG8gaGF2ZSBhY3R1YWxseSBiZWVuIGEgY2hhbmdlLlxuICAgICAqL1xuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdD86IG51bGwgfCB1bmRlZmluZWQgfCBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8VD47XG5cbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIHRoZSBhYm92ZSwgYnV0IG9ubHkgZm9yIG1vdW50L3VubW91bnQgKG9yIHdoZW4gYSBjaGlsZCBjaGFuZ2VzIGl0cyBpbmRleClcbiAgICAgKi9cbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQ+O1xufVxuXG5leHBvcnQgdHlwZSBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyA9IGtleW9mIE1DUDxhbnk+O1xuZXhwb3J0IHR5cGUgTWFuYWdlZENoaWxkT21pdHMgPSBrZXlvZiBNYW5hZ2VkQ2hpbGRJbmZvPGFueSwgYW55LCBhbnk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgT21pdHMgZXh0ZW5kcyBrZXlvZiBNQ1A8VD4+IHtcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IE9taXQ8TUNQPFQ+LCBPbWl0cz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHM+IHtcbiAgICBtYW5hZ2VkQ2hpbGQ6IE9taXQ8TWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPiwgTWNPbWl0cz47XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hpbGQgdGhhdCByZW5kZXJlZCBpdHNlbGYgd2l0aCB0aGUgcmVxdWVzdGVkIGtleS5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqIChldmVuIHRob3VnaCBpdCdzIG5vdCBhIGZ1bmN0aW9uLCB0aGUgaWRlbnRpdHkgb2YgdGhpcyBvYmplY3QgbmV2ZXIgY2hhbmdlcylcbiAgICAgKi9cbiAgICBtYW5hZ2VkQ2hpbGRyZW46IHtcbiAgICAgICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxULCBDLCBLPjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPFQsIEMsIEs+IHtcbiAgICAvKipcbiAgICAgKiBBIGhvb2sgdGhhdCBtdXN0IGJlIGNhbGxlZCBieSBldmVyeSBjaGlsZCBjb21wb25lbnQgdGhhdFxuICAgICAqIGlzIHRvIGJlIG1hbmFnZWQgYnkgdGhpcyBvbmUuIFRoZSBhcmd1bWVudCB0byB0aGUgaG9va1xuICAgICAqIGlzIGp1c3QgdGhlIGJhZyBvZiBwcm9wZXJ0aWVzIHRvIHBhc3MgdG8gdGhlIHBhcmVudCxcbiAgICAgKiBpbmNsdWRpbmcgdGhlIGNoaWxkJ3MgaW5kZXguXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIHVzZU1hbmFnZWRDaGlsZDogVXNlTWFuYWdlZENoaWxkPFQsIEMsIEs+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlID0gdm9pZDtcblxuZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8VCwgQywgSywgbmV2ZXI+KSA9PiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlO1xuXG5cblxuXG5cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBvdmVyIHRoZSBtYW5hZ2VkIGNoaWxkcmVuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkcmVuPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0QXQoaW5kZXg6IFQpOiBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+IHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRIaWdoZXN0SW5kZXgoKTogbnVtYmVyO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBmb3JFYWNoOiAoZjogKGNoaWxkOiBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+KSA9PiB2b2lkKSA9PiB2b2lkO1xuXG4gICAgLyoqICoqVU5TVEFCTEUqKiwgYWxzbyBpbnRlcm5hbC11c2Ugb25seSwgYWxzbyBUT0RPIG5lZWQgYSB3b3JrYXJvdW5kIGZvciB0aGlzIGZvciBzb3J0YWJsZSBjaGlsZHJlbiAqL1xuICAgIGFycmF5U2xpY2U6ICgpID0+IE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz5bXTtcbn1cblxuXG5cblxuLy9leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPEkgZXh0ZW5kcyB7fT4gPSB7IGluZm86IEkgfTtcblxuLyoqXG4gKiBBbGxvd3MgYSBwYXJlbnQgY29tcG9uZW50IHRvIGFjY2VzcyBpbmZvcm1hdGlvbiBhYm91dCBjZXJ0YWluXG4gKiBjaGlsZCBjb21wb25lbnRzIG9uY2UgdGhleSBoYXZlIHJlbmRlcmVkLlxuICogXG4gKiBUaGlzIGhvb2sgaXMgZGVzaWduZWQgdG8gYmUgbGlnaHR3ZWlnaHQsIGluIHRoYXQgdGhlIHBhcmVudCBrZWVwcyBubyBzdGF0ZVxuICogYW5kIHJ1bnMgbm8gZWZmZWN0cy4gIEVhY2ggY2hpbGQgKmRvZXMqIHJ1biBhbiBlZmZlY3QsIGJ1dCB3aXRoIG5vIHN0YXRlXG4gKiBjaGFuZ2VzIHVubGVzcyB5b3UgZXhwbGljaXRseSByZXF1ZXN0IHRoZW0uXG4gKiBcbiAqIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkcmVuPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHBhcmVudFBhcmFtZXRlcnM6IFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8VCwgbmV2ZXI+KTogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxULCBDLCBLPiB7XG4gICAgLy90eXBlIEkgPSBJMyAmIE1hbmFnZWRDaGlsZEluZm9CYXNlPHN0cmluZyB8IG51bWJlcj47XG4gICAgdHlwZSBJbmZvID0gTWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPjtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfSA9IHBhcmVudFBhcmFtZXRlcnM7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UpO1xuXG4gICAgY29uc3QgZ2V0SGlnaGVzdEluZGV4ID0gdXNlQ2FsbGJhY2soKCk6IG51bWJlciA9PiB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleDtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBBbGwgdGhlIGluZm9ybWF0aW9uIHdlIGhhdmUgYWJvdXQgb3VyIGNoaWxkcmVuIGlzIHN0b3JlZCBpbiB0aGlzICoqc3RhYmxlKiogYXJyYXkuXG4gICAgLy8gQW55IG11dGF0aW9ucyB0byB0aGlzIGFycmF5ICoqRE8gTk9UKiogdHJpZ2dlciBhbnkgc29ydCBvZiBhIHJlLXJlbmRlci5cbiAgICBjb25zdCBtYW5hZ2VkQ2hpbGRyZW5BcnJheSA9IHVzZVJlZjx7IGFycjogQXJyYXk8SW5mbz47IHJlYzogUGFydGlhbDxSZWNvcmQ8VCwgSW5mbz4+OyBoaWdoZXN0SW5kZXg6IG51bWJlciwgbG93ZXN0SW5kZXg6IG51bWJlciB9Pih7IGFycjogW10sIHJlYzoge30sIGhpZ2hlc3RJbmRleDogMCwgbG93ZXN0SW5kZXg6IDAgfSk7XG5cbiAgICAvLyBGb3IgaW5kaXJlY3QgYWNjZXNzIHRvIGVhY2ggY2hpbGRcbiAgICAvLyBDb21wYXJlIGdldE1hbmFnZWRDaGlsZEluZm9cbiAgICAvLyBUT0RPOiBUaGUgcHJpbWFyeSB1c2UgZm9yIHRoaXMgaXMgZmxhZ2dhYmxlIGNsb3Nlc3QgZml0c1xuICAgIC8vIHdoaWNoIG5lZWQgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgYmV0dGVyIGZvciB0aGF0LlxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEluZm8pID0+IHZvaWQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikgeyBmKGNoaWxkKTsgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIGluIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZDogSW5mbyB8IHVuZGVmaW5lZCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2ZpZWxkIGFzIGtleW9mIFJlY29yZDxULCBJbmZvPl07XG4gICAgICAgICAgICBpZiAoY2hpbGQpXG4gICAgICAgICAgICAgICAgZihjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIC8vIFJldHJpZXZlcyB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cbiAgICAvLyBgdW5kZWZpbmVkYCBpZiBub3QgY2hpbGQgdGhlcmUsIG9yIGl0J3MgdW5tb3VudGVkLlxuICAgIGNvbnN0IGdldE1hbmFnZWRDaGlsZEluZm8gPSB1c2VDYWxsYmFjazxNYW5hZ2VkQ2hpbGRyZW48VCwgQywgSz5bXCJnZXRBdFwiXT4oKGluZGV4OiBUKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdITtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIFRdITtcbiAgICB9LCBbXSlcblxuICAgIC8vIHRsO2RyIHRoaXMgaXMgYSB3YXkgdG8gaGF2ZSBydW4gdXNlTGF5b3V0RWZmZWN0IG9uY2UgYWZ0ZXIgYWxsIE4gY2hpbGRyZW5cbiAgICAvLyBoYXZlIG1vdW50ZWQgYW5kIHJ1biAqdGhlaXIqIHVzZUxheW91dEVmZmVjdCwgYnV0IGFsc28gKndpdGhvdXQqIHJlLXJlbmRlcmluZ1xuICAgIC8vIG91cnNlbHZlcyBiZWNhdXNlIG9mIGhhdmluZyBhIGBjaGlsZENvdW50YCBzdGF0ZSBvciBhbnl0aGluZyBzaW1pbGFyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgY2hpbGQgY291bnQgcmVmIHVwZGF0ZXMsIHdlIHdhbnQgdGhlIHBhcmVudCB0byBhbHNvIHJ1biBhbiBlZmZlY3RcbiAgICAvLyB0byBtYXliZSBkbyBzb21ldGhpbmcgd2l0aCBhbGwgdGhlc2UgY2hpbGRyZW4gdGhhdCBqdXN0IG1vdW50ZWQuXG4gICAgLy8gVGhlIGVhc2llc3Qgd2F5IHdvdWxkIGJlIHVzZUVmZmVjdCguLi4sIFtjaGlsZENvdW50XSkgYnV0XG4gICAgLy8gdGhhdCB3b3VsZCByZXF1aXJlIHVzIGhhdmluZyBhIGNoaWxkQ291bnQgc3RhdGUsIHRoZW4gY2FsbGluZ1xuICAgIC8vIHNldENoaWxkQ291bnQgYW5kIHJlLXJlbmRlcmluZyBldmVyeSB0aW1lIGNoaWxkcmVuIG1vdW50XG4gICAgLy8gKG9ubHkgb25lIHJlLXJlbmRlciBhdCBhIHRpbWUgdW5sZXNzIGNoaWxkcmVuIGFyZSBzdGFnZ2VyZWQsIGJ1dCBzdGlsbClcbiAgICAvLyBcbiAgICAvLyBBcyBhbiBhbHRlcm5hdGUgc29sdXRpb24sIGFueSB0aW1lIGEgY2hpbGQgdXNlcyBVTEUgb24gbW91bnQsIGl0IHF1ZXVlcyBhIG1pY3JvdGFza1xuICAgIC8vIHRvIGVtdWxhdGUgcnVubmluZyBVTEUgb24gdGhlIHBhcmVudC4gT25seSB0aGUgZmlyc3QgY2hpbGQgd2lsbCBhY3R1YWxseSBxdWV1ZVxuICAgIC8vIHRoZSBtaWNyb3Rhc2sgKGJ5IGNoZWNraW5nIGhhc1JlbW90ZVVMRSBmaXJzdCkgc28gdGhhdCB0aGUgXCJlZmZlY3RcIiBvbmx5XG4gICAgLy8gcnVucyBvbmNlLiBXaGVuIGl0J3MgZG9uZSwgaGFzUmVtb3RlVUxFIGlzIHJlc2V0IHNvIGl0IGNhbiBydW4gYWdhaW4gaWZcbiAgICAvLyBtb3JlIGNoaWxkcmVuIG1vdW50L3VubW91bnQuXG4gICAgY29uc3QgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlUmVmPHsgbW91bnRzOiBTZXQ8VD4sIHVubW91bnRzOiBTZXQ8VD4gfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMgPSB1c2VSZWYobmV3IFNldDxUPigpKTtcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IFQpID0+IHtcblxuICAgICAgICBpZiAocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LnNpemUgPT0gMCkge1xuICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdD8uKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5hZGQoaW5kZXgpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG5cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IFQsIG1vdW50ZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgbW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgdW5tb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4oaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLm1vdW50cywgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLnVubW91bnRzKVxuICAgICAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gTWF0aC5tYXgobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXgsIGluZGV4IGFzIG51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5kZXggYXMgbnVtYmVyXTtcbiAgICAgICAgICAgICAgICBsZXQgc2hhdmUgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzaGF2ZSA8PSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggJiYgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMSAtIHNoYXZlXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICArK3NoYXZlO1xuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLnNwbGljZShtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmUsIHNoYXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgVF07XG4gICAgICAgIH1cblxuICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudFttb3VudGVkID8gXCJtb3VudHNcIiA6IFwidW5tb3VudHNcIl0uYWRkKGluZGV4KTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIGNvbnN0IHVzZU1hbmFnZWRDaGlsZCA9IHVzZUNhbGxiYWNrPFVzZU1hbmFnZWRDaGlsZDxULCBDLCBLPj4oKHsgbWFuYWdlZENoaWxkOiBpbmZvLCB9KSA9PiB7XG4gICAgICAgIC8vIEFueSB0aW1lIG91ciBjaGlsZCBwcm9wcyBjaGFuZ2UsIG1ha2UgdGhhdCBpbmZvcm1hdGlvbiBhdmFpbGFibGVcbiAgICAgICAgLy8gdGhlIHBhcmVudCBpZiB0aGV5IG5lZWQgaXQuXG4gICAgICAgIC8vIFRoZSBwYXJlbnQgY2FuIGxpc3RlbiBmb3IgYWxsIHVwZGF0ZXMgYW5kIG9ubHkgYWN0IG9uIHRoZSBvbmVzIGl0IGNhcmVzIGFib3V0LFxuICAgICAgICAvLyBhbmQgbXVsdGlwbGUgY2hpbGRyZW4gdXBkYXRpbmcgaW4gdGhlIHNhbWUgdGljayB3aWxsIGFsbCBiZSBzZW50IGF0IG9uY2UuXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhpcyBpbmZvcm1hdGlvbiBpbi1wbGFjZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmZvLmluZGV4ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5mby5pbmRleCBhcyBudW1iZXJdID0geyBpbmRleDogaW5mby5pbmRleCwgZmxhZ3M6IGluZm8uZmxhZ3MgPz8ge30sIHN1YkluZm86IGluZm8uc3ViSW5mbyB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZm8uaW5kZXggYXMgVF0gPSB7IGluZGV4OiBpbmZvLmluZGV4LCBmbGFnczogaW5mby5mbGFncyA/PyB7fSwgc3ViSW5mbzogaW5mby5zdWJJbmZvIH07XG4gICAgICAgICAgICByZXR1cm4gcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkKGluZm8uaW5kZXggYXMgVCk7XG4gICAgICAgIH0sIFsuLi5PYmplY3QuZW50cmllcyhpbmZvKS5mbGF0KDkpXSk7ICAvLyA5IGlzIGluZmluaXR5LCByaWdodD8gU3VyZS4gVW5yZWxhdGVkOiBUT0RPLlxuXG4gICAgICAgIC8vIFdoZW4gd2UgbW91bnQsIG5vdGlmeSB0aGUgcGFyZW50IHZpYSBxdWV1ZU1pY3JvdGFza1xuICAgICAgICAvLyAoZXZlcnkgY2hpbGQgZG9lcyB0aGlzLCBzbyBldmVyeXRoaW5nJ3MgY29vcmRpbmF0ZWQgdG8gb25seSBxdWV1ZSBhIHNpbmdsZSBtaWNyb3Rhc2sgcGVyIHRpY2spXG4gICAgICAgIC8vIERvIHRoZSBzYW1lIG9uIHVubW91bnQuXG4gICAgICAgIC8vIE5vdGU6IEl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBjb21lcyBBRlRFUiByZW1vdGVVTEVDaGlsZENoYW5nZWRcbiAgICAgICAgLy8gc28gdGhhdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgaGFzIGFjY2VzcyB0byBhbGwgdGhlIGluZm8gb24gbW91bnQuXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmZvLmluZGV4IGFzIFQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZm8uaW5kZXggYXMgVCwgZmFsc2UpO1xuICAgICAgICB9LCBbaW5mby5pbmRleF0pO1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuID0gdXNlUmVmPE1hbmFnZWRDaGlsZHJlbjxULCBDLCBLPj4oe1xuICAgICAgICAuLi57IF86IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQgfSBhcyB7fSxcbiAgICAgICAgZm9yRWFjaDogZm9yRWFjaENoaWxkLFxuICAgICAgICBnZXRBdDogZ2V0TWFuYWdlZENoaWxkSW5mbyxcbiAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0SW5kZXgsXG4gICAgICAgIGFycmF5U2xpY2U6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zbGljZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VNYW5hZ2VkQ2hpbGQsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLmN1cnJlbnQgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZz4ge1xuXG4gICAgLyoqXG4gICAgICogV2hpY2ggY2hpbGQgaXMgY29uc2lkZXJlZCBhY3RpdmUgb24gbW91bnQuXG4gICAgICogXG4gICAgICogQWZ0ZXIgbW91bnQsIGNoYW5nZSB0aGUgY3VycmVudCBhY3RpdmUgY2hpbGQgd2l0aCBgY2hhbmdlSW5kZXhgLlxuICAgICAqL1xuICAgIGluaXRpYWxJbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gcHJvdmlkZWQsIGlmIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleCBkb2Vzbid0IG1hcCBvbnRvIGFueVxuICAgICAqIHByb3ZpZGVkIGNoaWxkIChlaXRoZXIgYmVjYXVzZSBpdCdzIHRvbyBsYXJnZSBvciB0aGF0IGNoaWxkXG4gICAgICogZG9lc24ndCBleGlzdCksIHRoZSBjbG9zZXN0IGNoaWxkIHRvIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleFxuICAgICAqIHdpbGwgaGF2ZSBpdHMgZmxhZyBzZXQgaW5zdGVhZC5cbiAgICAgKiBcbiAgICAgKiBVc2Ugd2l0aCBjYXV0aW9uLCBhbmQgY29uc2lkZXIgaG93IGEgY2hpbGQgaGF2aW5nIGl0cyBmbGFnIHNldFxuICAgICAqIHdoaWxlIHRoZSBwYXJlbnQgdGhpbmtzIGl0IHNob3VsZG4ndCBiZSBjb3VsZCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gICAgLy9jbG9zZXN0Rml0PzogYm9vbGVhbjtcbiAgICBjbG9zZXN0Rml0OiBib29sZWFuO1xuXG4gICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW5ldmVyIGEgbmV3IGluZGV4IGlzIHNlbGVjdGVkLlxuICAgICAqIFxuICAgICAqIE5vdGFibHksIHRoZSB2YWx1ZSBjYW4gYmUgZGlmZmVyZW50IHRoYW4gd2hhdCB3YXMgY2FsbGVkIHdpdGggY2hhbmdlSW5kZXgoKVxuICAgICAqIGlmIHRoZSByZXF1ZXN0ZWQgaW5kZXggZGlkbid0IGV4aXN0IG9yIHdhcyBoaWRkZW4uXG4gICAgICovXG4gICAgb25JbmRleENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPG51bWJlciB8IG51bGw+O1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBjaGlsZHJlbiBoYXZlIG11bHRpcGxlIGZsYWdzLCB0aGUgYGtleWAgcGFyYW1ldGVyIGNvbnRyb2xzIHdoaWNoIGZsYWcgd2UncmUgY2hlY2tpbmcuXG4gICAgICogXG4gICAgICogVGhpcyBjYW4gYmUgYW55dGhpbmcgeW91IHdhbnQsIGJ1dCBtdXN0IG5vdCBjaGFuZ2UuXG4gICAgICovXG4gICAga2V5OiBLO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hpbGRGbGFnT3BlcmF0aW9ucyB7XG5cbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB3aGV0aGVyIHRoZSBjdXJyZW50IGNoaWxkIGlzIGFjdGl2ZVxuICAgICAqL1xuICAgIGdldDogKCkgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hpbGQgbXVzdCBzZXQgaXRzZWxmIGFzIGFjdGl2ZS9pbmFjdGl2ZSwgd2hhdGV2ZXIgdGhhdCBlbnRhaWxzLlxuICAgICAqIFRoaXMgY291bGQgYmUgYXMgc2ltcGxlIGFzIGEgc2V0U3RhdGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc2V0OiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuIHRydWUgaWYgdGhpcyBjaGlsZCBpcyBhIHZhbGlkIGNhbmRpZGF0ZSB0byBiZSBmbGFnZ2VkLCBhbmQgZmFsc2UgaWYgbm90LlxuICAgICAqIE1vc3QgY2hpbGRyZW4gc2hvdWxkIHJldHVybiB0cnVlLiBSZXR1cm5pbmcgZmFsc2UgaXMgb25seSB1c2VmdWwgdG8gbWFyayBhIGNoaWxkIGFzIFwiaW52YWxpZFwiIGluIHNvbWUgd2F5LlxuICAgICAqIFJlbW92aW5nIGEgY2hpbGQgZnJvbSB0aGUgbGlzdCBkb2VzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nLCBidXQgdGhpcyBsZXRzIHlvdSBrZWVwIHRoZSBjaGlsZCBhcm91bmQuXG4gICAgICovXG4gICAgaXNWYWxpZCgpOiBib29sZWFuO1xufVxuXG5cbi8vZXhwb3J0IGludGVyZmFjZSBGbGFnZ2FibGVDaGlsZEluZm9CPEsgZXh0ZW5kcyBzdHJpbmc+IHsgZmxhZ3M6IFBhcnRpYWw8UmVjb3JkPEssIENoaWxkRmxhZ09wZXJhdGlvbnM+PiB9IFxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZSB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBjaGFuZ2VJbmRleDogKGFyZzogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdKSA9PiBudW1iZXIgfCBudWxsO1xuICAgIC8qKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICogXG4gICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIGEgY2hpbGQgbW91bnRzL3VubW91bnRzLCBvciB3aGVuZXZlciBjYWxsaW5nIGEgY2hpbGQncyBpc1ZhbGlkKCkgd291bGQgY2hhbmdlXG4gICAgICogICovXG4gICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXQ6ICgpID0+IHZvaWQ7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRDdXJyZW50SW5kZXg6ICgpID0+IG51bWJlciB8IG51bGw7XG59XG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIHRvIHVzZU1hbmFnZWRDaGlsZHJlbiB0aGF0IGhhbmRsZXMgdGhlIGZvbGxvd2luZyBjb21tb24gY2FzZTpcbiAqIDEuIFlvdSBoYXZlIGEgYnVuY2ggb2YgY2hpbGRyZW5cbiAqIDIuIEF0IGFueSBnaXZlbiB0aW1lLCBvbmx5IDEgb2YgdGhlbSBpcyBcInNlbGVjdGVkXCIsIFwiYWN0aXZhdGVkXCIsIFwiZm9jdXNhYmxlXCIsIHdoYXRldmVyIChvciAwIG9mIHRoZW0sIHRoYXQncyBjb29sIHRvbywganVzdCAwIG9yIDEgdGhvdWdoKS5cbiAqIDMuIFRoZSBwYXJlbnQgaGFzIGNvbnRyb2wgb3ZlciB3aG8gaXMgXCJzZWxlY3RlZFwiIHZpYSBhIG51bWVyaWNhbCBpbmRleC5cbiAqIFxuICogVGhpcyBob29rIGFsbG93cyBmb3IgbXVjaCBlYXNpZXIgY29udHJvbCBvdmVyIHNlbGVjdGlvbiBtYW5hZ2VtZW50LlxuICogXG4gKiBOb3RlIHRoYXQgYmVjYXVzZSB5b3UgbWF5IHdhbnQgdG8gdXNlIG11bHRpcGxlIGZsYWdzIHdpdGggdGhlIHNhbWUgY2hpbGRyZW4sIHRoaXMgaG9vayAqZG9lcyBub3QqIHVzZSBgdXNlTWFuYWdlZENoaWxkcmVuYCFcbiAqIFlvdSBuZWVkIHRvIHBhc3MgaXQgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLCBhbmQgeW91IG11c3QgcGFzcyB5b3VyIGludm9jYXRpb24gb2YgYHVzZU1hbmFnZWRDaGlsZHJlbmAgdGhlIHJldHVybmVkIGBvbkNoaWxkcmVuTW91bnRDaGFuZ2VgIGhhbmRsZXIhXG4gKiBcbiAqIEFsc28gYmVjYXVzZSBvZiB0aGF0LCB0aGUgdHlwZXMgb2YgdGhpcyBmdW5jdGlvbiBhcmUgcmF0aGVyIG9kZC4gIEl0J3MgYmV0dGVyIHRvIHN0YXJ0IG9mZiB1c2luZyBhIGhvb2sgdGhhdCBhbHJlYWR5IHVzZXMgYSBmbGFnLCBzdWNoIGFzIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGFzIGFuIGV4YW1wbGUuXG4gKiBcbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hpbGRyZW5GbGFnPEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgY2hpbGRyZW4sIGluaXRpYWxJbmRleCwgY2xvc2VzdEZpdCwgb25JbmRleENoYW5nZSwga2V5IH06IFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8QywgSz4pOiBVc2VDaGlsZHJlbkZsYWdSZXR1cm5UeXBlIHtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VDaGlsZHJlbkZsYWdcIiwgb25JbmRleENoYW5nZSwga2V5KTtcblxuICAgIGNvbnN0IFtnZXRDdXJyZW50SW5kZXgsIHNldEN1cnJlbnRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IG51bWJlcj4ob25JbmRleENoYW5nZSwgdXNlQ2FsbGJhY2soKCkgPT4gKGluaXRpYWxJbmRleCA/PyAobnVsbCkpLCBbXSkpO1xuXG4gICAgY29uc3QgW2dldFJlcXVlc3RlZEluZGV4LCBzZXRSZXF1ZXN0ZWRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IG51bWJlcj4obnVsbCwgdXNlQ2FsbGJhY2soKCkgPT4gKGluaXRpYWxJbmRleCA/PyAobnVsbCkpLCBbXSkpO1xuXG4gICAgLy8gICAgY29uc3QgZ2V0Rml0TnVsbFRvWmVybyA9IHVzZVN0YWJsZUdldHRlcihmaXROdWxsVG9aZXJvKTtcblxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSBhbmQgY2hhbmdlSW5kZXgsIG5vdCBwdWJsaWMgKGJ1dCBjb3VsZCBiZSBJIGd1ZXNzKVxuICAgIGNvbnN0IGdldENsb3Nlc3RGaXQgPSB1c2VDYWxsYmFjaygocmVxdWVzdGVkSW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGxldCBjbG9zZXN0SW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcblxuICAgICAgICAgICAgaWYgKGNoaWxkLmZsYWdzPy5ba2V5XT8uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGlzdGFuY2UgPSBNYXRoLmFicyhjaGlsZC5pbmRleCAtIHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UgfHwgKG5ld0Rpc3RhbmNlID09IGNsb3Nlc3REaXN0YW5jZSAmJiBjaGlsZC5pbmRleCA8IHJlcXVlc3RlZEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBuZXdEaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gY2hpbGQuaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RJbmRleDtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlISAqL10pO1xuXG4gICAgLy8gQW55IHRpbWUgYSBjaGlsZCBtb3VudHMvdW5tb3VudHMsIHdlIG5lZWQgdG8gZG91YmxlLWNoZWNrIHRvIHNlZSBpZiB0aGF0IGFmZmVjdHMgXG4gICAgLy8gdGhlIFwiY3VycmVudGx5IHNlbGVjdGVkXCIgKG9yIHdoYXRldmVyKSBpbmRleC4gIFRoZSB0d28gY2FzZXMgd2UncmUgbG9va2luZyBmb3I6XG4gICAgLy8gMS4gVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjaGlsZCB1bm1vdW50ZWRcbiAgICAvLyAyLiBBIGNoaWxkIG1vdW50ZWQsIGFuZCBpdCBtb3VudHMgd2l0aCB0aGUgaW5kZXggd2UncmUgbG9va2luZyBmb3JcbiAgICBjb25zdCByZWV2YWx1YXRlQ2xvc2VzdEZpdCA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSBnZXRSZXF1ZXN0ZWRJbmRleCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudENoaWxkID0gY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KTtcblxuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggIT0gbnVsbCAmJiBjbG9zZXN0Rml0ICYmIChyZXF1ZXN0ZWRJbmRleCAhPSBjdXJyZW50SW5kZXggfHwgY3VycmVudENoaWxkID09IG51bGwgfHwgIWN1cnJlbnRDaGlsZC5mbGFncz8uW2tleV0/LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4KTtcbiAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNsb3Nlc3RGaXRDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RGaXRDaGlsZC5mbGFncz8uW2tleV0hLnNldCh0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSk7XG5cblxuXG5cbiAgICBjb25zdCBjaGFuZ2VJbmRleCA9IHVzZUNhbGxiYWNrKChhcmc6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ZWRJbmRleCA9IGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKGdldFJlcXVlc3RlZEluZGV4KCkpIDogYXJnO1xuICAgICAgICAvL2lmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsICYmIGdldEZpdE51bGxUb1plcm8oKSlcbiAgICAgICAgLy8gICAgcmVxdWVzdGVkSW5kZXggPSAwO1xuXG4gICAgICAgIHNldFJlcXVlc3RlZEluZGV4KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT0gcmVxdWVzdGVkSW5kZXgpXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkSW5kZXg7XG5cbiAgICAgICAgbGV0IG5ld01hdGNoaW5nQ2hpbGQgPSAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChyZXF1ZXN0ZWRJbmRleCkpO1xuICAgICAgICBjb25zdCBvbGRNYXRjaGluZ0NoaWxkID0gKGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCkpO1xuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRWFzeSBjYXNlXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgobnVsbCk7XG4gICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZXdNYXRjaGluZ0NoaWxkICYmIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChjbG9zZXN0Rml0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5ld01hdGNoaW5nQ2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VzdEZpdEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaW5pdGlhbEluZGV4ICE9IG51bGwpXG4gICAgICAgICAgICBjaGlsZHJlbi5nZXRBdChpbml0aWFsSW5kZXgpPy5mbGFncz8uW2tleV0/LnNldCh0cnVlKTtcbiAgICB9LCBbXSlcblxuICAgIHJldHVybiB7IGNoYW5nZUluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdCwgZ2V0Q3VycmVudEluZGV4IH07XG59XG5cblxuXG4vKmV4cG9ydCB0eXBlIFNwcmVhZDxBIGV4dGVuZHMge30sIEIgZXh0ZW5kcyB7fT4gPSBPbWl0PEEsIGtleW9mIEI+ICYgQjtcbmV4cG9ydCBmdW5jdGlvbiBzcHJlYWQ8QSBleHRlbmRzIHt9LCBCIGV4dGVuZHMge30+KGE6IEEsIGI6IEIpOiBTcHJlYWQ8QSwgQj4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmEsXG4gICAgICAgIC4uLmJcbiAgICB9XG59Ki9cblxuLypcbmZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgdHlwZSBDID0geyBmb286IFwiYmFyXCIgfTtcbiAgICB0eXBlIEsgPSBcImZsYWcyXCI7XG5cbiAgICBjb25zdCB7IGNoaWxkcmVuLCB1c2VNYW5hZ2VkQ2hpbGQgfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+KHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25DaGlsZHJlbk1vdW50Q2hhbmdlPG51bWJlcj4+KChtb3VudGVkLCB1bm1vdW50ZWQpID0+IG9uQ2hpbGRyZW5Nb3VudENoYW5nZShtb3VudGVkLCB1bm1vdW50ZWQpKSB9IH0pO1xuICAgIHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleDogMCwgaW5mbzogeyBmb286IFwiYmFyXCIgfSwgZmxhZ3M6IHsgIH0gfSB9KTtcbiAgICBjb25zdCB7IGNoYW5nZUluZGV4LCBnZXRDdXJyZW50SW5kZXgsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9ID0gdXNlQ2hpbGRyZW5GbGFnPEMsIEs+KHsgY2hpbGRyZW4sIGluaXRpYWxJbmRleDogMCwga2V5OiBcImZsYWcyXCIgfSlcbn0qL1xuIiwiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERvY3VtZW50KGVsZW1lbnQ/OiBOb2RlKSB7IHJldHVybiAoZWxlbWVudD8ub3duZXJEb2N1bWVudCA/PyBkb2N1bWVudCA/PyB3aW5kb3cuZG9jdW1lbnQgPz8gZ2xvYmFsVGhpcy5kb2N1bWVudCk7IH1cblxudHlwZSBQID0gUGFyYW1ldGVyczx0eXBlb2YgY2xzeD47XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEb2N1bWVudENsYXNzKGNsYXNzTmFtZTogUFswXSwgYWN0aXZlPzogYm9vbGVhbiwgZWxlbWVudD86IEhUTUxFbGVtZW50KSB7XG4gICAgZWxlbWVudCA/Pz0gZ2V0RG9jdW1lbnQoKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgY2xhc3NOYW1lID0gY2xzeChjbGFzc05hbWUpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlbGVtZW50IS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LCBbY2xhc3NOYW1lLCBhY3RpdmUsIGVsZW1lbnRdKTtcblxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbih7IGNoaWxkcmVuOiBsaHMgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwiY2hpbGRyZW5cIj4sIHsgY2hpbGRyZW46IHJoc306IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcImNoaWxkcmVuXCI+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0ge1xuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCBsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgZGVmYXVsdCBhcyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXHJcbiAqIER1cGxpY2F0ZSBjbGFzc2VzIGFyZSByZW1vdmVkIChvcmRlciBkb2Vzbid0IG1hdHRlciBhbnl3YXkpLlxyXG4gKiBcclxuICogQHBhcmFtIGxocyBDbGFzc2VzIG9mIHRoZSBmaXJzdCBjb21wb25lbnRcclxuICogQHBhcmFtIHJocyBDbGFzc2VzIG9mIHRoZSBzZWNvbmQgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgY29tYmluZWQgY2xhc3NlcyBmcm9tIGJvdGggYXJndW1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENsYXNzZXM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0Pih7IGNsYXNzOiBsaHNDbGFzcywgY2xhc3NOYW1lOiBsaHNDbGFzc05hbWUgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgXCJjbGFzc1wiIHwgXCJjbGFzc05hbWVcIj4sIHsgY2xhc3M6IHJoc0NsYXNzLCBjbGFzc05hbWU6IHJoc0NsYXNzTmFtZX06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHJcbiAgICAvLyBOb3RlOiBGb3IgdGhlIHNha2Ugb2YgZm9yd2FyZCBjb21wYXRpYmlsaXR5LCB0aGlzIGZ1bmN0aW9uIGlzIGxhYmVsbGVkIGFzXHJcbiAgICAvLyBhIGhvb2ssIGJ1dCBhcyBpdCB1c2VzIG5vIG90aGVyIGhvb2tzIGl0IHRlY2huaWNhbGx5IGlzbid0IG9uZS5cclxuXHJcbiAgICBpZiAobGhzQ2xhc3MgfHwgcmhzQ2xhc3MgfHwgbGhzQ2xhc3NOYW1lIHx8IHJoc0NsYXNzTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGxoc0NsYXNzZXMgPSBjbHN4KGxoc0NsYXNzLCBsaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgY29uc3QgYWxsQ2xhc3NlcyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20obGhzQ2xhc3NlcyksIC4uLkFycmF5LmZyb20ocmhzQ2xhc3NlcyldKVxyXG5cclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCwgUmVmLCBSZWZDYWxsYmFjaywgUmVmT2JqZWN0IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUmVmPFQ+KGluc3RhbmNlOiBUIHwgbnVsbCwgcmVmOiBSZWY8VD4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgKHJlZiBhcyBSZWZPYmplY3Q8VCB8IG51bGw+KS5jdXJyZW50ID0gaW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZhbHNlLCBcIlVua25vd24gcmVmIHR5cGUgZm91bmQgdGhhdCB3YXMgbmVpdGhlciBhIFJlZkNhbGxiYWNrIG5vciBhIFJlZk9iamVjdFwiKTtcclxuICAgIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFI8RT4ge1xyXG4gICAgcmVmPzogUmVmPEU+O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxyXG4gKiBAcGFyYW0gbGhzIFxyXG4gKiBAcGFyYW0gcmhzIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRSZWZzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyByZWY6IHJocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgeyByZWY6IGxocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikge1xyXG4gICAgY29uc3QgY29tYmluZWQ6IFJlZkNhbGxiYWNrPEU+ID0gdXNlQ2FsbGJhY2soKGN1cnJlbnQ6IEUgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCBsaHMpO1xyXG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcclxuICAgIH0sIFtsaHMsIHJoc10pO1xyXG5cclxuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQhO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmhzITtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxocyE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbmZ1bmN0aW9uIHN0eWxlU3RyaW5nVG9PYmplY3Qoc3R5bGU6IHN0cmluZyk6IGguSlNYLkNTU1Byb3BlcnRpZXMge1xyXG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhzdHlsZS5zcGxpdChcIjtcIikubWFwKHN0YXRlbWVudCA9PiBzdGF0ZW1lbnQuc3BsaXQoXCI6XCIpKSkgYXMgdW5rbm93biBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2VzIHR3byBzdHlsZSBvYmplY3RzLCByZXR1cm5pbmcgdGhlIHJlc3VsdC5cclxuICogXHJcbiAqIEBwYXJhbSBzdHlsZSBUaGUgdXNlci1naXZlbiBzdHlsZSBwcm9wIGZvciB0aGlzIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gb2JqIFRoZSBDU1MgcHJvcGVydGllcyB5b3Ugd2FudCBhZGRlZCB0byB0aGUgdXNlci1naXZlbiBzdHlsZVxyXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkU3R5bGVzKGxoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4sIHJoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSB7XHJcblxyXG4gICAgLy8gRWFzeSBjYXNlLCB3aGVuIHRoZXJlIGFyZSBubyBzdHlsZXMgdG8gbWVyZ2UgcmV0dXJuIG5vdGhpbmcuXHJcbiAgICBpZiAoIWxocz8uc3R5bGUgJiYgIXJocz8uc3R5bGUpXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XHJcbiAgICAgICAgLy8gRWFzeSBjYXNlcywgd2hlbiBvbmUgaXMgbnVsbCBhbmQgdGhlIG90aGVyIGlzbid0LlxyXG4gICAgICAgIGlmIChsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gbGhzLnN0eWxlO1xyXG4gICAgICAgIGlmICghbGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzLnN0eWxlO1xyXG5cclxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgdHlwZSB0byBhbiBvYmplY3QgYmFnIHR5cGUgYW5kIHJ1biBpdCBhZ2Fpbi5cclxuICAgICAgICBpZiAobGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKSB7XHJcbiAgICAgICAgICAgIC8vICh1c2VNZXJnZWRTdHlsZXMgaXNuJ3QgYSB0cnVlIGhvb2sgLS0gdGhpcyBpc24ndCBhIHZpb2xhdGlvbilcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKHsgc3R5bGU6IHN0eWxlU3RyaW5nVG9PYmplY3QobGhzPy5zdHlsZSBhcyBzdHJpbmcpIH0sIHJocykgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgeyBzdHlsZTogc3R5bGVTdHJpbmdUb09iamVjdChyaHM/LnN0eWxlIGFzIHN0cmluZykgfSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvZ2ljPz8/XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGV5J3JlIGJvdGggc3RyaW5ncywganVzdCBjb25jYXRlbmF0ZSB0aGVtLlxyXG4gICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gYCR7bGhzLnN0eWxlfTske3Jocz8uc3R5bGUgPz8gXCJcIn1gIGFzIHVua25vd24gYXMgc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZXkncmUgYm90aCBvYmplY3RzLCBqdXN0IG1lcmdlIHRoZW0uXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLihsaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgICAgIC4uLihyaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXHJcbiAgICB9IGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW5cIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2xhc3NlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2xhc3Nlc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1yZWZzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzXCI7XHJcblxyXG5sZXQgbG9nID0gY29uc29sZS53YXJuO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdQcm9wQ29uZmxpY3RzKGxvZzI6IHR5cGVvZiBjb25zb2xlW1wibG9nXCJdKSB7XHJcbiAgICBsb2cgPSBsb2cyXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAqIFxyXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxyXG4gKiBAcGFyYW0gbGhzMiBcclxuICogQHBhcmFtIHJoczIgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4obGhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgcmhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcclxuICAgIC8vIEZpcnN0LCBzZXBhcmF0ZSB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiBpbnRvIHR3byBncm91cHM6XHJcbiAgICAvLyBsaHNBbGwgYW5kIHJoc0FsbCBjb250YWluIGFsbCB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiwgYW5kXHJcbiAgICAvLyBsaHNNaXNjIGFuZCByaHNNaXNjIGNvbnRhaW4gYWxsIHByb3BzICpleGNlcHQqIGZvciB0aGUgZWFzeSBvbmVzXHJcbiAgICAvLyBsaWtlIGNsYXNzTmFtZSBhbmQgc3R5bGUgdGhhdCB3ZSBhbHJlYWR5IGtub3cgaG93IHRvIG1lcmdlLlxyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX2xoc0NoaWxkcmVuLCBjbGFzczogX2xoc0NsYXNzLCBjbGFzc05hbWU6IF9saHNDbGFzc05hbWUsIHN0eWxlOiBfbGhzU3R5bGUsIHJlZjogX2xoc1JlZiwgLi4ubGhzTWlzYyB9ID0gbGhzQWxsO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX3Joc0NoaWxkcmVuLCBjbGFzczogX3Joc0NsYXNzLCBjbGFzc05hbWU6IF9yaHNDbGFzc05hbWUsIHN0eWxlOiBfcmhzU3R5bGUsIHJlZjogX3Joc1JlZiwgLi4ucmhzTWlzYyB9ID0gcmhzQWxsO1xyXG5cclxuICAgIGNvbnN0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7XHJcbiAgICAgICAgLi4ubGhzTWlzYyxcclxuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIGNsYXNzTmFtZTogdXNlTWVyZ2VkQ2xhc3NlcyhsaHNBbGwsIHJoc0FsbCksXHJcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbCwgcmhzQWxsKSxcclxuICAgIH0gYXMgYW55O1xyXG5cclxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xyXG4gICAgaWYgKHJldC5zdHlsZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnN0eWxlO1xyXG4gICAgaWYgKHJldC5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jbGFzc05hbWU7XHJcbiAgICBpZiAocmV0LmNoaWxkcmVuID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2hpbGRyZW47XHJcblxyXG4gICAgLy8gTm93LCBkbyAqZXZlcnl0aGluZyogZWxzZVxyXG4gICAgLy8gTWVyZ2UgZXZlcnkgcmVtYWluaW5nIGV4aXN0aW5nIGVudHJ5IGluIGxocyB3aXRoIHdoYXQgd2UndmUgYWxyZWFkeSBwdXQgaW4gcmV0LlxyXG4gICAgLy9jb25zdCBsaHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMobGhzKSBhcyBba2V5b2YgVCwgVFtrZXlvZiBUXV1bXTtcclxuICAgIGNvbnN0IHJoc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhyaHNNaXNjKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtyaHNLZXlVLCByaHNWYWx1ZV0gb2YgcmhzRW50cmllcykge1xyXG4gICAgICAgIGNvbnN0IHJoc0tleSA9IHJoc0tleVUgYXMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcblxyXG4gICAgICAgIGNvbnN0IGxoc1ZhbHVlID0gbGhzTWlzY1tyaHNLZXkgYXMga2V5b2YgdHlwZW9mIGxoc01pc2NdO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGxoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgbWVyZ2VkIChvciBvbmUncyBhIGZ1bmN0aW9uIGFuZCB0aGUgb3RoZXIncyBudWxsKS5cclxuICAgICAgICAgICAgLy8gTm90IGFuICplYXN5KiBjYXNlLCBidXQgYSB3ZWxsLWRlZmluZWQgb25lLlxyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZUZ1bmN0aW9ucyhsaHNWYWx1ZSBhcyBuZXZlciwgcmhzVmFsdWUgYXMgbmV2ZXIpO1xyXG4gICAgICAgICAgICByZXRbcmhzS2V5IGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+XSA9IG1lcmdlZCBhcyBuZXZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XHJcbiAgICAgICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsICYmIHJoc1ZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IGxoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke3Joc0tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZSBhcyBuZXZlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUZ1bmN0aW9uczxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4obGhzOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBVIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG5cclxuICAgIGlmICghbGhzKVxyXG4gICAgICAgIHJldHVybiByaHM7XHJcbiAgICBpZiAoIXJocylcclxuICAgICAgICByZXR1cm4gbGhzO1xyXG5cclxuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHJ2ID0gcmhzKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qXHJcbmZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG5cclxuICAgIGNvbnN0IGlkMDogR2VuZXJpY0dldDx7fSwgXCJpZFwiLCBzdHJpbmc+ID0gXCJcIjtcclxuICAgIGNvbnN0IGlkMzogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ0OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDU6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNjogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgLy9jb25zdCBpZDI6IFppcFNpbmdsZTxzdHJpbmcgfCB1bmRlZmluZWQsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDE6IFppcE9iamVjdDx7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0geyBpZDogdW5kZWZpbmVkIH07XHJcblxyXG4gICAgdHlwZSBNMSA9IEdlbmVyaWNHZXQ8UCwgXCJzdHlsZVwiLCBzdHJpbmc+O1xyXG4gICAgdHlwZSBNMiA9IEdlbmVyaWNHZXQ8e30sIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIGNvbnN0IG0xOiBNMSA9IFwiXCI7XHJcbiAgICBjb25zdCBtMjogTTEgPSB1bmRlZmluZWQ7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xyXG4gICAgY29uc3QgbTM6IE0xID0gMDtcclxuXHJcbiAgICBjb25zdCBtNDogTTIgPSBcIlwiO1xyXG4gICAgY29uc3QgbTU6IE0yID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG02OiBNMiA9IDA7XHJcblxyXG4gICAgY29uc3QgcDE6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDI6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDM6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNDogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHt9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHt9KTtcclxuICAgIGNvbnN0IHA1ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywge30pO1xyXG4gICAgY29uc3QgcDYgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNyA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IFwic3RyaW5nXCIgfSk7XHJcblxyXG5cclxuICAgIHAxLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwMi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcDMuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHA0LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHA1LmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDcuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNy5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDUuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA3LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBpdCB3b3JrcyByZWN1cnNpdmVseVxyXG4gICAgY29uc3QgcjFhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDEpO1xyXG4gICAgY29uc3QgcjFiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDEpO1xyXG4gICAgY29uc3QgcjJhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDIpO1xyXG4gICAgY29uc3QgcjJiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDIpO1xyXG4gICAgY29uc3QgcjNhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDMpO1xyXG4gICAgY29uc3QgcjNiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDMpO1xyXG4gICAgY29uc3QgcjRhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDQpO1xyXG4gICAgY29uc3QgcjRiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDQpO1xyXG4gICAgY29uc3QgcjVhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDUpO1xyXG4gICAgY29uc3QgcjViID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDUpO1xyXG4gICAgY29uc3QgcjZhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDYpO1xyXG4gICAgY29uc3QgcjZiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDYpO1xyXG4gICAgY29uc3QgcjdhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDcpO1xyXG4gICAgY29uc3QgcjdiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDcpO1xyXG5cclxuXHJcbiAgICByMWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIxYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcjNhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByM2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHI0YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjRiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHI1YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjViLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI2Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByN2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNWEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjViLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI2YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmIuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjdhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3Yi5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjVhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjViLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG59XHJcbmZ1bmN0aW9uIGFjY2VwdHNOZXZlcihuOiBuZXZlcikge31cclxuKi8iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGdldEVsZW1lbnQoKTogVCB8IG51bGw7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlUmVmRWxlbWVudFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcclxuICAgIG9uRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsPjtcclxuICAgIG9uTW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcclxuICAgIG9uVW5tb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xyXG59XHJcblxyXG4vKipcclxuICogQWxsb3dzIGFjY2Vzc2luZyB0aGUgZWxlbWVudCBhIHJlZiByZWZlcmVuY2VzIGFzIHNvb24gYXMgaXQgZG9lcyBzby5cclxuICogKlRoaXMgaG9vayBpdHNlbGYgcmV0dXJucyBhIGhvb2sqLS11c2VSZWZFbGVtZW50UHJvcHMgbW9kaWZpZXMgdGhlIHByb3BzIHRoYXQgeW91IHdlcmUgZ29pbmcgdG8gcGFzcyB0byBhbiBIVE1MRWxlbWVudCwgXHJcbiAqIGFkZGluZyBhIFJlZkNhbGxiYWNrIGFuZCBtZXJnaW5nIGl0IHdpdGggYW55IGV4aXN0aW5nIHJlZiB0aGF0IGV4aXN0ZWQgb24gdGhlIHByb3BzLlxyXG4gKiBcclxuICogRG9uJ3QgZm9yZ2V0IHRvIHByb3ZpZGUgdGhlIEVsZW1lbnQgYXMgdGhlIHR5cGUgYXJndW1lbnQhXHJcbiAqIFxyXG4gKiBAcmV0dXJucyBUaGUgZWxlbWVudCwgYW5kIHRoZSBzdWItaG9vayB0aGF0IG1ha2VzIGl0IHJldHJpZXZhYmxlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnQ8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PihhcmdzPzogVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4pOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiB7XHJcbiAgICBjb25zdCB7IG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50IH0gPSAoYXJncyA/PyB7fSk7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUmVmRWxlbWVudFwiLCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCk7XHJcblxyXG4gICAgLy8gQ2FsbGVkIChpbmRpcmVjdGx5KSBieSB0aGUgcmVmIHRoYXQgdGhlIGVsZW1lbnQgcmVjZWl2ZXMuXHJcbiAgICBjb25zdCBoYW5kbGVyID0gdXNlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGw+PigoZSwgcHJldlZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2xlYW51cCA9IG9uRWxlbWVudENoYW5nZT8uKGUsIHByZXZWYWx1ZSk7XHJcbiAgICAgICAgaWYgKHByZXZWYWx1ZSlcclxuICAgICAgICAgICAgb25Vbm1vdW50Py4ocHJldlZhbHVlISk7XHJcblxyXG4gICAgICAgIGlmIChlKVxyXG4gICAgICAgICAgICBvbk1vdW50Py4oZSk7XHJcblxyXG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIC8vIExldCB1cyBzdG9yZSB0aGUgYWN0dWFsIChyZWZlcmVuY2UgdG8pIHRoZSBlbGVtZW50IHdlIGNhcHR1cmVcclxuICAgIGNvbnN0IFtnZXRFbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxUIHwgbnVsbD4oaGFuZGxlciwgcmV0dXJuTnVsbCk7XHJcbiAgICBjb25zdCB1c2VSZWZFbGVtZW50UHJvcHMgPSB1c2VDYWxsYmFjazxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPltcInVzZVJlZkVsZW1lbnRQcm9wc1wiXT4oKHByb3BzKSA9PiB1c2VNZXJnZWRQcm9wczxUPih7IHJlZjogc2V0RWxlbWVudCB9LCBwcm9wcyksIFtdKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcclxuICAgIC8vIHRoZSBwcm9wcyBhbmQgYWxsb3dzIHVzIHRvIGFjdHVhbGx5IGZpbmQgdGhlIGVsZW1lbnRcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlUmVmRWxlbWVudFByb3BzLFxyXG4gICAgICAgIGdldEVsZW1lbnRcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBoLCBQcmVhY3RET01BdHRyaWJ1dGVzIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB1c2VkIHRvIHNlbGVjdCAqanVzdCogdGhlIHR5cGVkIGFkZEV2ZW50TGlzdGVuZXIgXHJcbiAqIGFuZCBub3QgdGhlIGdlbmVyaWMgXCJJJ2xsIGFjY2VwdCBhbnkgc3RyaW5nIGFuZCBhbnkgaGFuZGxlclwiIG9uZS5cclxuICogXHJcbiAqIFRPRE86IFRoaXMgXCJcIlwid29ya3NcIlwiXCIgYnV0IGl0J3Mgbm90IGdyZWF0IGFuZCBpbXBsaWNpdGx5IHJlbGllcyBvblxyXG4gKiBsaWIuZG9tLnRzIGFsd2F5cyBnaXZlaW5nIHRoZSB0d28gb3ZlcmxvYWRzIGluIHRoZSBzYW1lIG9yZGVyLCB3aXRoIHRoZVxyXG4gKiB0eXBlZCBvbmUgZmlyc3QuICpUaGF0KiBwcm9iYWJseSB3b24ndCBjaGFuZ2UsIGJ1dCBpZiBtb3JlIG92ZXJsb2Fkc1xyXG4gKiBhcmUgZXZlciBhZGRlZCB0aGlzIHdpbGwgbmVlZCBhZGp1c3RtZW50LlxyXG4gKiBcclxuICogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mjc2MTE1NiBmb3IgaG93IHNlbGVjdGluZyB0aGUgY29ycmVjdCBvdmVybG9hZCB3b3Jrcy5cclxuICovXHJcbnR5cGUgRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8VD4gPVxyXG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBpbmZlciBSIH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueSB9ID8gUiA6XHJcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55IH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUikgPT4gYW55ID8gUiA6IFtdO1xyXG5cclxuLy8gR2V0IGp1c3QgdGhlIHR5cGVkIHZlcnNpb24gb2YgYWRkRXZlbnRMaXN0ZW5lciwgaWYgaXQgZXhpc3RzXHJcbnR5cGUgVHlwZWRBZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSAoLi4uYXJnczogRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8KFRbXCJhZGRFdmVudExpc3RlbmVyXCJdKT4pID0+IHZvaWQ7XHJcblxyXG4vLyBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBcImFkZEV2ZW50TGlzdGVuZXJcIiAodGhlIGV2ZW50IHR5cGUgYXMgYSBzdHJpbmcpXHJcbnR5cGUgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPiBleHRlbmRzICgodHlwZTogaW5mZXIgSzIsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSzIgOiBzdHJpbmc7XHJcblxyXG5cclxuLy8gVE9ETzogVGhpcyBpc24ndCBxdWl0ZSBhYmxlIHRvIG5hcnJvdyBkb3duIHRoZSBleGFjdCBldmVudCB0eXBlIGZvciB1bmtub3duIHJlYXNvbnMuXHJcbi8vIEluc3RlYWQgaXQgcmV0dXJucyBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgZXZlbnQgdHlwZXMsIHdoaWNoIGlzLi4uZmluZSwgSSBndWVzcy5cclxuLy8gSSBkb24ndCBrbm93IHdoeSBgaW5mZXIgSGAgaXMgZG9pbmcgdGhhdCB3aGVuIHRoZSB0eXBlIHNob3VsZCBiZSBuYXJyb3dlZCBieSBgVGAgdGhvdWdoLi4uXHJcbi8vIE5vdGUgdGhhdCB0aGUgdHlwZSBwYXJhbWV0ZXIgaXMgc3RpbGwgdXNlZCwgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBuYXJyb3cgZG93biB0aGUgdHlwZSxcclxuLy8gYmVjYXVzZSBvdGhlcndpc2UsIGluc3RlYWQgb2YgYmVpbmcgYSB1bmlvbiBvZiBhbGwgdHlwZXMsIGl0J3MganVzdCBgYW55YFxyXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyPEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVCBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPEU+PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxFPiBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogaW5mZXIgSCwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBOb25OdWxsYWJsZTxIPiA6IG5ldmVyO1xyXG4vLygoVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+ICYgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWQsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpKSBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogKGU6IGluZmVyIEgpID0+IGFueSwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBIIDogRnVuY3Rpb24pIC8qJiAoVCBleHRlbmRzIGtleW9mIEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcD8gR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwW1RdIDogKGU6IEV2ZW50KSA9PiB2b2lkKSovO1xyXG5cclxudHlwZSBQYXJhbWV0ZXJzMjxUIGV4dGVuZHMgKEV2ZW50TGlzdGVuZXJPYmplY3QgfCAoKC4uLmFyZ3M6IGFueSkgPT4gYW55KSk+ID1cclxuICAgIFQgZXh0ZW5kcyBFdmVudExpc3RlbmVyT2JqZWN0ID8gUGFyYW1ldGVyczxUW1wiaGFuZGxlRXZlbnRcIl0+IDpcclxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUCkgPT4gYW55ID8gUCA6IG5ldmVyO1xyXG5cclxuXHJcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFQgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFPj4gPSBQYXJhbWV0ZXJzMjxUeXBlZEV2ZW50SGFuZGxlcjxFLCBUPj5bMF07XHJcblxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBhdHRhY2hpbmcgYW4gZXZlbnQgaGFuZGxlciB0byBhbnkgKm5vbi1QcmVhY3QqIGVsZW1lbnQsIGFuZCByZW1vdmluZyBpdCB3aGVuIHRoZSBjb21wb25lbnQgdXNpbmcgdGhlIGhvb2sgdW5tb3VudHMuIFRoZSBjYWxsYmFjayBkb2VzIG5vdCBuZWVkIHRvIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cclxuICogXHJcbiAqIER1ZSB0byB0eXBpbmcgbGltaXRhdGlvbnMsIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgbGlrZSB0aGlzOlxyXG4gKiBcclxuICogYHVzZUV2ZW50SGFuZGxlcihlbGVtZW50LCBcImlucHV0XCIpPElucHV0RXZlbnQ+KGUgPT4ge30pYFxyXG4gKiBcclxuICogVGhlIHR5cGUgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGJ1dCBuYXJyb3dzIGRvd24gdGhlIHR5cGUgZnJvbSBcImEgdW5pb24gb2YgYWxsIGV2ZW50c1wiIHRvIHdoYXRldmVyIHlvdSBzcGVjaWZ5LCBhbmQgZXJyb3JzIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXHJcbiAqIFxyXG4gKiBUaGVyZSBpcyBhIHNlcGFyYXRlIHZlcnNpb24gdGhhdCBhdHRhY2hlcyBldmVudCBoYW5kbGVycyB0byBhIHNldCBvZiBwcm9wcy4gXHJcbiAqIEl0IHRha2VzIGRpZmZlcmVudCBldmVudCBzdHJpbmcgdHlwZXMgKG9uRXZlbnQgdnMgb25ldmVudCkuXHJcbiAqIFxyXG4gKiBAcGFyYW0gdGFyZ2V0IEEgKm5vbi1QcmVhY3QqIG5vZGUgdG8gYXR0YWNoIHRoZSBldmVudCB0by5cclxuICogQHJldHVybnNcclxuICogKlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdsb2JhbEhhbmRsZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPiwgSCBleHRlbmRzIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8VCwgRXZlbnRUeXBlPj4odGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCAoKGU6IEgpID0+IHZvaWQpLCBvcHRpb25zPzogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdKTogdm9pZCB7XHJcblxyXG4gICAgLy8gTm90ZSB0byBzZWxmOiBUaGUgdHlwaW5nIGRvZXNuJ3QgaW1wcm92ZSBldmVuIGlmIHRoaXMgaXMgc3BsaXQgdXAgaW50byBhIHN1Yi1mdW5jdGlvbi5cclxuICAgIC8vIE5vIG1hdHRlciB3aGF0LCBpdCBzZWVtcyBpbXBvc3NpYmxlIHRvIGdldCB0aGUgaGFuZGxlcidzIGV2ZW50IG9iamVjdCB0eXBlZCBwZXJmZWN0bHkuXHJcbiAgICAvLyBJdCBzZWVtcyBsaWtlIGl0J3MgZ3VhcmFudGVlZCB0byBhbHdheXMgYmUgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIHR1cGVzLlxyXG4gICAgLy8gQWdhaW4sIG5vIG1hdHRlciB3aGF0IGNvbWJpbmF0aW9uIG9mIHN1Yi0gb3Igc3ViLXN1Yi1mdW5jdGlvbnMgdXNlZC5cclxuXHJcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjayhoYW5kbGVyID8/ICgoKSA9PiB7IH0pKSBhcyBFdmVudExpc3RlbmVyO1xyXG4gICAgaWYgKGhhbmRsZXIgPT0gbnVsbClcclxuICAgICAgICBzdGFibGVIYW5kbGVyID0gbnVsbDtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChzdGFibGVIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGFsdGVybmF0aXZlIHdheSB0byBhZGQgYW4gZXZlbnQgaGFuZGxlciB0byBhbiBlbGVtZW50LiBVc2VmdWwgcHJpbWFyaWx5IHdoZW4gaW50ZWdyYXRpbmcgM3JkIHBhcnR5IGxpYnJhcmllcyB0aGF0IGV4cGVjdCBhIGdlbmVyaWMgXCJhZGQgZXZlbnQgaGFuZGxlclwiIGZ1bmN0aW9uLlxyXG4gKiBcclxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHlvdSB0byBtb2RpZnkgYSBzZXQgb2YgcHJvcHMgdG8gYXBwbHkgdGhpcyBoYW5kbGVyLlxyXG4gKiBcclxuICogRm9yIHR5cGluZyByZWFzb25zLCB0aGlzIGZ1bmN0aW9uIGlzIHNwbGl0IGludG8gdHdvLiAgVXNhZ2UgaXMgbGlrZSB0aGUgZm9sbG93aW5nOlxyXG4gKiBcclxuICogYGBgXHJcbiAqIGNvbnN0IHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9ID0gdXNlTG9jYWxFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+KCkoXCJvbk1vdXNlRG93blwiLCBlID0+IHsgIH0pO1xyXG4gKiBjb25zdCBkaXZQcm9wcyA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMocHJvcHMpO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbEhhbmRsZXI8RWxlbWVudFR5cGUgZXh0ZW5kcyAoSFRNTEVsZW1lbnRUYWdOYW1lTWFwW2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcF0gfCBTVkdFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcF0pPigpIHtcclxuICAgIHJldHVybiB1c2VDYWxsYmFjayg8RXZlbnRUeXBlIGV4dGVuZHMgRXhjbHVkZTxrZXlvZiBoLkpTWC5ET01BdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPiwga2V5b2YgUHJlYWN0RE9NQXR0cmlidXRlcz4+KHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogTm9uTnVsbGFibGU8aC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT5bRXZlbnRUeXBlXT4pID0+IHtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhYmxlSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIpO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFbGVtZW50VHlwZT4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEVsZW1lbnRUeXBlPih7IFt0eXBlXTogc3RhYmxlSGFuZGxlciB9IGFzIHsgW0sgaW4gRXZlbnRUeXBlXTogdHlwZW9mIGhhbmRsZXIgfSwgcHJvcHMpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPjtcclxuICAgICAgICB9LCBbdHlwZV0pO1xyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH07XHJcblxyXG4gICAgfSwgW10pO1xyXG59XHJcbiIsImNvbnN0IGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFtcbiAgJ2lucHV0JyxcbiAgJ3NlbGVjdCcsXG4gICd0ZXh0YXJlYScsXG4gICdhW2hyZWZdJyxcbiAgJ2J1dHRvbicsXG4gICdbdGFiaW5kZXhdOm5vdChzbG90KScsXG4gICdhdWRpb1tjb250cm9sc10nLFxuICAndmlkZW9bY29udHJvbHNdJyxcbiAgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0pJyxcbiAgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyxcbiAgJ2RldGFpbHMnLFxuXTtcbmNvbnN0IGNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovIGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJyk7XG5cbmNvbnN0IE5vRWxlbWVudCA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJztcblxuY29uc3QgbWF0Y2hlcyA9IE5vRWxlbWVudFxuICA/IGZ1bmN0aW9uICgpIHt9XG4gIDogRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG5jb25zdCBnZXRSb290Tm9kZSA9XG4gICFOb0VsZW1lbnQgJiYgRWxlbWVudC5wcm90b3R5cGUuZ2V0Um9vdE5vZGVcbiAgICA/IChlbGVtZW50KSA9PiBlbGVtZW50LmdldFJvb3ROb2RlKClcbiAgICA6IChlbGVtZW50KSA9PiBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBjb250YWluZXIgdG8gY2hlY2sgaW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIHRvIGNoZWNrXG4gKiBAcGFyYW0geyhub2RlOiBFbGVtZW50KSA9PiBib29sZWFufSBmaWx0ZXIgZmlsdGVyIGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50W119XG4gKi9cbmNvbnN0IGdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoZWwsIGluY2x1ZGVDb250YWluZXIsIGZpbHRlcikge1xuICBsZXQgY2FuZGlkYXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShcbiAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9yKVxuICApO1xuICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gIH1cbiAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgR2V0U2hhZG93Um9vdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrIGZvciBzaGFkb3cgcm9vdFxuICogQHJldHVybnMge1NoYWRvd1Jvb3R8Ym9vbGVhbn0gU2hhZG93Um9vdCBpZiBhdmFpbGFibGUgb3IgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgc2hhZG93Um9vdCBpcyBhdHRhY2hlZCBidXQgbm90IGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTaGFkb3dSb290RmlsdGVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHNoYWRvd0hvc3ROb2RlIHRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHNoYWRvdyBjb250ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIHNoYWRvdyByb290IGNvdWxkIHBvdGVudGlhbGx5IGNvbnRhaW4gdmFsaWQgY2FuZGlkYXRlcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbmRpZGF0ZXNTY29wZVxuICogQHByb3BlcnR5IHtFbGVtZW50fSBzY29wZSBjb250YWlucyBpbm5lciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge0VsZW1lbnRbXX0gY2FuZGlkYXRlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSXRlcmF0aXZlT3B0aW9uc1xuICogQHByb3BlcnR5IHtHZXRTaGFkb3dSb290fGJvb2xlYW59IGdldFNoYWRvd1Jvb3QgdHJ1ZSBpZiBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkOyBmYWxzeSBpZiBub3Q7XG4gKiAgaWYgYSBmdW5jdGlvbiwgaW1wbGllcyBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkIGFuZCBlaXRoZXIgcmV0dXJucyB0aGUgc2hhZG93IHJvb3Qgb2YgYW4gZWxlbWVudFxuICogIG9yIGEgYm9vbGVhbiBzdGF0aW5nIGlmIGl0IGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgcm9vdFxuICogQHByb3BlcnR5IHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZsYXR0ZW4gaWYgdHJ1ZSB0aGVuIHJlc3VsdCB3aWxsIGZsYXR0ZW4gYW55IENhbmRpZGF0ZXNTY29wZSBpbnRvIHRoZSByZXR1cm5lZCBsaXN0XG4gKiBAcHJvcGVydHkge1NoYWRvd1Jvb3RGaWx0ZXJ9IHNoYWRvd1Jvb3RGaWx0ZXIgZmlsdGVyIHNoYWRvdyByb290cztcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50cyBsaXN0IG9mIGVsZW1lbnQgY29udGFpbmVycyB0byBtYXRjaCBjYW5kaWRhdGVzIGZyb21cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIGxpc3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7SXRlcmF0aXZlT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZXNTY29wZT59XG4gKi9cbmNvbnN0IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseSA9IGZ1bmN0aW9uIChcbiAgZWxlbWVudHMsXG4gIGluY2x1ZGVDb250YWluZXIsXG4gIG9wdGlvbnNcbikge1xuICBjb25zdCBjYW5kaWRhdGVzID0gW107XG4gIGNvbnN0IGVsZW1lbnRzVG9DaGVjayA9IEFycmF5LmZyb20oZWxlbWVudHMpO1xuICB3aGlsZSAoZWxlbWVudHNUb0NoZWNrLmxlbmd0aCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1RvQ2hlY2suc2hpZnQoKTtcbiAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnU0xPVCcpIHtcbiAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNsb3Qgc2NvcGUgKHNsb3QgaXRzZWxmIGNhbm5vdCBiZSBmb2N1c2FibGUpXG4gICAgICBjb25zdCBhc3NpZ25lZCA9IGVsZW1lbnQuYXNzaWduZWRFbGVtZW50cygpO1xuICAgICAgY29uc3QgY29udGVudCA9IGFzc2lnbmVkLmxlbmd0aCA/IGFzc2lnbmVkIDogZWxlbWVudC5jaGlsZHJlbjtcbiAgICAgIGNvbnN0IG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoY29udGVudCwgdHJ1ZSwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5uZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgc2NvcGU6IGVsZW1lbnQsXG4gICAgICAgICAgY2FuZGlkYXRlczogbmVzdGVkQ2FuZGlkYXRlcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNoZWNrIGNhbmRpZGF0ZSBlbGVtZW50XG4gICAgICBjb25zdCB2YWxpZENhbmRpZGF0ZSA9IG1hdGNoZXMuY2FsbChlbGVtZW50LCBjYW5kaWRhdGVTZWxlY3Rvcik7XG4gICAgICBpZiAoXG4gICAgICAgIHZhbGlkQ2FuZGlkYXRlICYmXG4gICAgICAgIG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQpICYmXG4gICAgICAgIChpbmNsdWRlQ29udGFpbmVyIHx8ICFlbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSlcbiAgICAgICkge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBzaGFkb3cgY29udGVudCBpZiBwb3NzaWJsZVxuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9XG4gICAgICAgIGVsZW1lbnQuc2hhZG93Um9vdCB8fFxuICAgICAgICAvLyBjaGVjayBmb3IgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICh0eXBlb2Ygb3B0aW9ucy5nZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgb3B0aW9ucy5nZXRTaGFkb3dSb290KGVsZW1lbnQpKTtcblxuICAgICAgY29uc3QgdmFsaWRTaGFkb3dSb290ID1cbiAgICAgICAgIW9wdGlvbnMuc2hhZG93Um9vdEZpbHRlciB8fCBvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIoZWxlbWVudCk7XG5cbiAgICAgIGlmIChzaGFkb3dSb290ICYmIHZhbGlkU2hhZG93Um9vdCkge1xuICAgICAgICAvLyBhZGQgc2hhZG93IGRvbSBzY29wZSBJSUYgYSBzaGFkb3cgcm9vdCBub2RlIHdhcyBnaXZlbjsgb3RoZXJ3aXNlLCBhbiB1bmRpc2Nsb3NlZFxuICAgICAgICAvLyAgc2hhZG93IGV4aXN0cywgc28gbG9vayBhdCBsaWdodCBkb20gY2hpbGRyZW4gYXMgZmFsbGJhY2sgQlVUIGNyZWF0ZSBhIHNjb3BlIGZvciBhbnlcbiAgICAgICAgLy8gIGNoaWxkIGNhbmRpZGF0ZXMgZm91bmQgYmVjYXVzZSB0aGV5J3JlIGxpa2VseSBzbG90dGVkIGVsZW1lbnRzIChlbGVtZW50cyB0aGF0IGFyZVxuICAgICAgICAvLyAgY2hpbGRyZW4gb2YgdGhlIHdlYiBjb21wb25lbnQgZWxlbWVudCAod2hpY2ggaGFzIHRoZSBzaGFkb3cpLCBpbiB0aGUgbGlnaHQgZG9tLCBidXRcbiAgICAgICAgLy8gIHNsb3R0ZWQgc29tZXdoZXJlIF9pbnNpZGVfIHRoZSB1bmRpc2Nsb3NlZCBzaGFkb3cpIC0tIHRoZSBzY29wZSBpcyBjcmVhdGVkIGJlbG93LFxuICAgICAgICAvLyAgX2FmdGVyXyB3ZSByZXR1cm4gZnJvbSB0aGlzIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgIGNvbnN0IG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoXG4gICAgICAgICAgc2hhZG93Um9vdCA9PT0gdHJ1ZSA/IGVsZW1lbnQuY2hpbGRyZW4gOiBzaGFkb3dSb290LmNoaWxkcmVuLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goLi4ubmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3BlOiBlbGVtZW50LFxuICAgICAgICAgICAgY2FuZGlkYXRlczogbmVzdGVkQ2FuZGlkYXRlcyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlcmUncyBub3Qgc2hhZG93IHNvIGp1c3QgZGlnIGludG8gdGhlIGVsZW1lbnQncyAobGlnaHQgZG9tKSBjaGlsZHJlblxuICAgICAgICAvLyAgX193aXRob3V0X18gZ2l2aW5nIHRoZSBlbGVtZW50IHNwZWNpYWwgc2NvcGUgdHJlYXRtZW50XG4gICAgICAgIGVsZW1lbnRzVG9DaGVjay51bnNoaWZ0KC4uLmVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbmNvbnN0IGdldFRhYmluZGV4ID0gZnVuY3Rpb24gKG5vZGUsIGlzU2NvcGUpIHtcbiAgaWYgKG5vZGUudGFiSW5kZXggPCAwKSB7XG4gICAgLy8gaW4gQ2hyb21lLCA8ZGV0YWlscy8+LCA8YXVkaW8gY29udHJvbHMvPiBhbmQgPHZpZGVvIGNvbnRyb2xzLz4gZWxlbWVudHMgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgLTEgd2hlbiB0aGUgJ3RhYmluZGV4JyBhdHRyaWJ1dGUgaXNuJ3Qgc3BlY2lmaWVkIGluIHRoZSBET00sXG4gICAgLy8geWV0IHRoZXkgYXJlIHN0aWxsIHBhcnQgb2YgdGhlIHJlZ3VsYXIgdGFiIG9yZGVyOyBpbiBGRiwgdGhleSBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAwOyBzaW5jZSBDaHJvbWUgc3RpbGwgcHV0cyB0aG9zZSBlbGVtZW50cyBpbiB0aGUgcmVndWxhciB0YWJcbiAgICAvLyBvcmRlciwgY29uc2lkZXIgdGhlaXIgdGFiIGluZGV4IHRvIGJlIDAuXG4gICAgLy8gQWxzbyBicm93c2VycyBkbyBub3QgcmV0dXJuIGB0YWJJbmRleGAgY29ycmVjdGx5IGZvciBjb250ZW50RWRpdGFibGUgbm9kZXM7XG4gICAgLy8gc28gaWYgdGhleSBkb24ndCBoYXZlIGEgdGFiaW5kZXggYXR0cmlidXRlIHNwZWNpZmljYWxseSBzZXQsIGFzc3VtZSBpdCdzIDAuXG4gICAgLy9cbiAgICAvLyBpc1Njb3BlIGlzIHBvc2l0aXZlIGZvciBjdXN0b20gZWxlbWVudCB3aXRoIHNoYWRvdyByb290IG9yIHNsb3QgdGhhdCBieSBkZWZhdWx0XG4gICAgLy8gaGF2ZSB0YWJJbmRleCAtMSwgYnV0IG5lZWQgdG8gYmUgc29ydGVkIGJ5IGRvY3VtZW50IG9yZGVyIGluIG9yZGVyIGZvciB0aGVpclxuICAgIC8vIGNvbnRlbnQgdG8gYmUgaW5zZXJ0ZWQgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb25cbiAgICBpZiAoXG4gICAgICAoaXNTY29wZSB8fFxuICAgICAgICAvXihBVURJT3xWSURFT3xERVRBSUxTKSQvLnRlc3Qobm9kZS50YWdOYW1lKSB8fFxuICAgICAgICBub2RlLmlzQ29udGVudEVkaXRhYmxlKSAmJlxuICAgICAgaXNOYU4ocGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKSlcbiAgICApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlLnRhYkluZGV4O1xufTtcblxuY29uc3Qgc29ydE9yZGVyZWRUYWJiYWJsZXMgPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gYS50YWJJbmRleCA9PT0gYi50YWJJbmRleFxuICAgID8gYS5kb2N1bWVudE9yZGVyIC0gYi5kb2N1bWVudE9yZGVyXG4gICAgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn07XG5cbmNvbnN0IGlzSW5wdXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU5QVVQnO1xufTtcblxuY29uc3QgaXNIaWRkZW5JbnB1dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ2hpZGRlbic7XG59O1xuXG5jb25zdCBpc0RldGFpbHNXaXRoU3VtbWFyeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGNvbnN0IHIgPVxuICAgIG5vZGUudGFnTmFtZSA9PT0gJ0RFVEFJTFMnICYmXG4gICAgQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAuYXBwbHkobm9kZS5jaGlsZHJlbilcbiAgICAgIC5zb21lKChjaGlsZCkgPT4gY2hpbGQudGFnTmFtZSA9PT0gJ1NVTU1BUlknKTtcbiAgcmV0dXJuIHI7XG59O1xuXG5jb25zdCBnZXRDaGVja2VkUmFkaW8gPSBmdW5jdGlvbiAobm9kZXMsIGZvcm0pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkICYmIG5vZGVzW2ldLmZvcm0gPT09IGZvcm0pIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGlzVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghbm9kZS5uYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcmFkaW9TY29wZSA9IG5vZGUuZm9ybSB8fCBnZXRSb290Tm9kZShub2RlKTtcbiAgY29uc3QgcXVlcnlSYWRpb3MgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiByYWRpb1Njb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAnaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCInICsgbmFtZSArICdcIl0nXG4gICAgKTtcbiAgfTtcblxuICBsZXQgcmFkaW9TZXQ7XG4gIGlmIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuQ1NTICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuQ1NTLmVzY2FwZSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKHdpbmRvdy5DU1MuZXNjYXBlKG5vZGUubmFtZSkpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKG5vZGUubmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLFxuICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjaGVja2VkID0gZ2V0Q2hlY2tlZFJhZGlvKHJhZGlvU2V0LCBub2RlLmZvcm0pO1xuICByZXR1cm4gIWNoZWNrZWQgfHwgY2hlY2tlZCA9PT0gbm9kZTtcbn07XG5cbmNvbnN0IGlzUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdyYWRpbyc7XG59O1xuXG5jb25zdCBpc05vblRhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNSYWRpbyhub2RlKSAmJiAhaXNUYWJiYWJsZVJhZGlvKG5vZGUpO1xufTtcblxuLy8gZGV0ZXJtaW5lcyBpZiBhIG5vZGUgaXMgdWx0aW1hdGVseSBhdHRhY2hlZCB0byB0aGUgd2luZG93J3MgZG9jdW1lbnRcbmNvbnN0IGlzTm9kZUF0dGFjaGVkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgLy8gVGhlIHJvb3Qgbm9kZSBpcyB0aGUgc2hhZG93IHJvb3QgaWYgdGhlIG5vZGUgaXMgaW4gYSBzaGFkb3cgRE9NOyBzb21lIGRvY3VtZW50IG90aGVyd2lzZVxuICAvLyAgKGJ1dCBOT1QgX3RoZV8gZG9jdW1lbnQ7IHNlZSBzZWNvbmQgJ0lmJyBjb21tZW50IGJlbG93IGZvciBtb3JlKS5cbiAgLy8gSWYgcm9vdE5vZGUgaXMgc2hhZG93IHJvb3QsIGl0J2xsIGhhdmUgYSBob3N0LCB3aGljaCBpcyB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgc2hhZG93XG4gIC8vICBpcyBhdHRhY2hlZCwgYW5kIHRoZSBvbmUgd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIGluIHRoZSBkb2N1bWVudCBvciBub3QgKGJlY2F1c2UgdGhlXG4gIC8vICBzaGFkb3csIGFuZCBhbGwgbm9kZXMgaXQgY29udGFpbnMsIGlzIG5ldmVyIGNvbnNpZGVyZWQgaW4gdGhlIGRvY3VtZW50IHNpbmNlIHNoYWRvd3NcbiAgLy8gIGJlaGF2ZSBsaWtlIHNlbGYtY29udGFpbmVkIERPTXM7IGJ1dCBpZiB0aGUgc2hhZG93J3MgSE9TVCwgd2hpY2ggaXMgcGFydCBvZiB0aGUgZG9jdW1lbnQsXG4gIC8vICBpcyBoaWRkZW4sIG9yIGlzIG5vdCBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmIGJ1dCBpcyBkZXRhY2hlZCwgaXQgd2lsbCBhZmZlY3QgdGhlIHNoYWRvdydzXG4gIC8vICB2aXNpYmlsaXR5LCBpbmNsdWRpbmcgYWxsIHRoZSBub2RlcyBpdCBjb250YWlucykuIFRoZSBob3N0IGNvdWxkIGJlIGFueSBub3JtYWwgbm9kZSxcbiAgLy8gIG9yIGEgY3VzdG9tIGVsZW1lbnQgKGkuZS4gd2ViIGNvbXBvbmVudCkuIEVpdGhlciB3YXksIHRoYXQncyB0aGUgb25lIHRoYXQgaXMgY29uc2lkZXJlZFxuICAvLyAgcGFydCBvZiB0aGUgZG9jdW1lbnQsIG5vdCB0aGUgc2hhZG93IHJvb3QsIG5vciBhbnkgb2YgaXRzIGNoaWxkcmVuIChpLmUuIHRoZSBub2RlIGJlaW5nXG4gIC8vICB0ZXN0ZWQpLlxuICAvLyBUbyBmdXJ0aGVyIGNvbXBsaWNhdGUgdGhpbmdzLCB3ZSBoYXZlIHRvIGxvb2sgYWxsIHRoZSB3YXkgdXAgdW50aWwgd2UgZmluZCBhIHNoYWRvdyBIT1NUXG4gIC8vICB0aGF0IGlzIGF0dGFjaGVkIChvciBmaW5kIG5vbmUpIGJlY2F1c2UgdGhlIG5vZGUgbWlnaHQgYmUgaW4gbmVzdGVkIHNoYWRvd3MuLi5cbiAgLy8gSWYgcm9vdE5vZGUgaXMgbm90IGEgc2hhZG93IHJvb3QsIGl0IHdvbid0IGhhdmUgYSBob3N0LCBhbmQgc28gcm9vdE5vZGUgc2hvdWxkIGJlIHRoZVxuICAvLyAgZG9jdW1lbnQgKHBlciB0aGUgZG9jcykgYW5kIHdoaWxlIGl0J3MgYSBEb2N1bWVudC10eXBlIG9iamVjdCwgdGhhdCBkb2N1bWVudCBkb2VzIG5vdFxuICAvLyAgYXBwZWFyIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBub2RlJ3MgYG93bmVyRG9jdW1lbnRgIGZvciBzb21lIHJlYXNvbiwgc28gaXQncyBzYWZlclxuICAvLyAgdG8gaWdub3JlIHRoZSByb290Tm9kZSBhdCB0aGlzIHBvaW50LCBhbmQgdXNlIGBub2RlLm93bmVyRG9jdW1lbnRgLiBPdGhlcndpc2UsXG4gIC8vICB1c2luZyBgcm9vdE5vZGUuY29udGFpbnMobm9kZSlgIHdpbGwgX2Fsd2F5c18gYmUgdHJ1ZSB3ZSdsbCBnZXQgZmFsc2UtcG9zaXRpdmVzIHdoZW5cbiAgLy8gIG5vZGUgaXMgYWN0dWFsbHkgZGV0YWNoZWQuXG4gIGxldCBub2RlUm9vdEhvc3QgPSBnZXRSb290Tm9kZShub2RlKS5ob3N0O1xuICBsZXQgYXR0YWNoZWQgPSAhIShcbiAgICBub2RlUm9vdEhvc3Q/Lm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZVJvb3RIb3N0KSB8fFxuICAgIG5vZGUub3duZXJEb2N1bWVudC5jb250YWlucyhub2RlKVxuICApO1xuXG4gIHdoaWxlICghYXR0YWNoZWQgJiYgbm9kZVJvb3RIb3N0KSB7XG4gICAgLy8gc2luY2UgaXQncyBub3QgYXR0YWNoZWQgYW5kIHdlIGhhdmUgYSByb290IGhvc3QsIHRoZSBub2RlIE1VU1QgYmUgaW4gYSBuZXN0ZWQgc2hhZG93IERPTSxcbiAgICAvLyAgd2hpY2ggbWVhbnMgd2UgbmVlZCB0byBnZXQgdGhlIGhvc3QncyBob3N0IGFuZCBjaGVjayBpZiB0aGF0IHBhcmVudCBob3N0IGlzIGNvbnRhaW5lZFxuICAgIC8vICBpbiAoaS5lLiBhdHRhY2hlZCB0bykgdGhlIGRvY3VtZW50XG4gICAgbm9kZVJvb3RIb3N0ID0gZ2V0Um9vdE5vZGUobm9kZVJvb3RIb3N0KS5ob3N0O1xuICAgIGF0dGFjaGVkID0gISFub2RlUm9vdEhvc3Q/Lm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZVJvb3RIb3N0KTtcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hlZDtcbn07XG5cbmNvbnN0IGlzWmVyb0FyZWEgPSBmdW5jdGlvbiAobm9kZSkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDA7XG59O1xuY29uc3QgaXNIaWRkZW4gPSBmdW5jdGlvbiAobm9kZSwgeyBkaXNwbGF5Q2hlY2ssIGdldFNoYWRvd1Jvb3QgfSkge1xuICAvLyBOT1RFOiB2aXNpYmlsaXR5IHdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgbm9kZSBpcyBkZXRhY2hlZCBmcm9tIHRoZSBkb2N1bWVudFxuICAvLyAgKHNlZSBub3RlcyBhYm91dCB0aGlzIGZ1cnRoZXIgZG93biksIHdoaWNoIG1lYW5zIHdlIHdpbGwgY29uc2lkZXIgaXQgdmlzaWJsZVxuICAvLyAgKHRoaXMgaXMgbGVnYWN5IGJlaGF2aW9yIGZyb20gYSB2ZXJ5IGxvbmcgd2F5IGJhY2spXG4gIC8vIE5PVEU6IHdlIGNoZWNrIHRoaXMgcmVnYXJkbGVzcyBvZiBgZGlzcGxheUNoZWNrPVwibm9uZVwiYCBiZWNhdXNlIHRoaXMgaXMgYVxuICAvLyAgX3Zpc2liaWxpdHlfIGNoZWNrLCBub3QgYSBfZGlzcGxheV8gY2hlY2tcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUobm9kZSkudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGlzRGlyZWN0U3VtbWFyeSA9IG1hdGNoZXMuY2FsbChub2RlLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnKTtcbiAgY29uc3Qgbm9kZVVuZGVyRGV0YWlscyA9IGlzRGlyZWN0U3VtbWFyeSA/IG5vZGUucGFyZW50RWxlbWVudCA6IG5vZGU7XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZVVuZGVyRGV0YWlscywgJ2RldGFpbHM6bm90KFtvcGVuXSkgKicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoXG4gICAgIWRpc3BsYXlDaGVjayB8fFxuICAgIGRpc3BsYXlDaGVjayA9PT0gJ2Z1bGwnIHx8XG4gICAgZGlzcGxheUNoZWNrID09PSAnbGVnYWN5LWZ1bGwnXG4gICkge1xuICAgIGlmICh0eXBlb2YgZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gZmlndXJlIG91dCBpZiB3ZSBzaG91bGQgY29uc2lkZXIgdGhlIG5vZGUgdG8gYmUgaW4gYW4gdW5kaXNjbG9zZWQgc2hhZG93IGFuZCB1c2UgdGhlXG4gICAgICAvLyAgJ25vbi16ZXJvLWFyZWEnIGZhbGxiYWNrXG4gICAgICBjb25zdCBvcmlnaW5hbE5vZGUgPSBub2RlO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBnZXRSb290Tm9kZShub2RlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBhcmVudEVsZW1lbnQgJiZcbiAgICAgICAgICAhcGFyZW50RWxlbWVudC5zaGFkb3dSb290ICYmXG4gICAgICAgICAgZ2V0U2hhZG93Um9vdChwYXJlbnRFbGVtZW50KSA9PT0gdHJ1ZSAvLyBjaGVjayBpZiB0aGVyZSdzIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xuICAgICAgICApIHtcbiAgICAgICAgICAvLyBub2RlIGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgd2hpY2ggbWVhbnMgd2UgY2FuIG9ubHkgdHJlYXQgaXQgYXMgYSBibGFjayBib3gsIHNvIHdlXG4gICAgICAgICAgLy8gIGZhbGwgYmFjayB0byBhIG5vbi16ZXJvLWFyZWEgdGVzdFxuICAgICAgICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gaXRlcmF0ZSB1cCBzbG90XG4gICAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90O1xuICAgICAgICB9IGVsc2UgaWYgKCFwYXJlbnRFbGVtZW50ICYmIHJvb3ROb2RlICE9PSBub2RlLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAvLyBjcm9zcyBzaGFkb3cgYm91bmRhcnlcbiAgICAgICAgICBub2RlID0gcm9vdE5vZGUuaG9zdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIG5vcm1hbCBkb21cbiAgICAgICAgICBub2RlID0gcGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlID0gb3JpZ2luYWxOb2RlO1xuICAgIH1cbiAgICAvLyBlbHNlLCBgZ2V0U2hhZG93Um9vdGAgbWlnaHQgYmUgdHJ1ZSwgYnV0IGFsbCB0aGF0IGRvZXMgaXMgZW5hYmxlIHNoYWRvdyBET00gc3VwcG9ydFxuICAgIC8vICAoaS5lLiBpdCBkb2VzIG5vdCBhbHNvIHByZXN1bWUgdGhhdCBhbGwgbm9kZXMgbWlnaHQgaGF2ZSB1bmRpc2Nsb3NlZCBzaGFkb3dzKTsgb3JcbiAgICAvLyAgaXQgbWlnaHQgYmUgYSBmYWxzeSB2YWx1ZSwgd2hpY2ggbWVhbnMgc2hhZG93IERPTSBzdXBwb3J0IGlzIGRpc2FibGVkXG5cbiAgICAvLyBTaW5jZSB3ZSBkaWRuJ3QgZmluZCBpdCBzaXR0aW5nIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyAob3Igc2hhZG93cyBhcmUgZGlzYWJsZWQpXG4gICAgLy8gIG5vdyB3ZSBjYW4ganVzdCB0ZXN0IHRvIHNlZSBpZiBpdCB3b3VsZCBub3JtYWxseSBiZSB2aXNpYmxlIG9yIG5vdCwgcHJvdmlkZWQgaXQnc1xuICAgIC8vICBhdHRhY2hlZCB0byB0aGUgbWFpbiBkb2N1bWVudC5cbiAgICAvLyBOT1RFOiBXZSBtdXN0IGNvbnNpZGVyIGNhc2Ugd2hlcmUgbm9kZSBpcyBpbnNpZGUgYSBzaGFkb3cgRE9NIGFuZCBnaXZlbiBkaXJlY3RseSB0b1xuICAgIC8vICBgaXNUYWJiYWJsZSgpYCBvciBgaXNGb2N1c2FibGUoKWAgLS0gcmVnYXJkbGVzcyBvZiBgZ2V0U2hhZG93Um9vdGAgb3B0aW9uIHNldHRpbmcuXG5cbiAgICBpZiAoaXNOb2RlQXR0YWNoZWQobm9kZSkpIHtcbiAgICAgIC8vIHRoaXMgd29ya3Mgd2hlcmV2ZXIgdGhlIG5vZGUgaXM6IGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGNsaWVudCByZWN0LCBpdCdzXG4gICAgICAvLyAgc29tZWhvdyBkaXNwbGF5ZWQ7IGl0IGFsc28gY292ZXJzIHRoZSBDU1MgJ2Rpc3BsYXk6IGNvbnRlbnRzJyBjYXNlIHdoZXJlIHRoZVxuICAgICAgLy8gIG5vZGUgaXRzZWxmIGlzIGhpZGRlbiBpbiBwbGFjZSBvZiBpdHMgY29udGVudHM7IGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoXG4gICAgICAvLyAgdXAgdGhlIGhpZXJhcmNoeSBlaXRoZXJcbiAgICAgIHJldHVybiAhbm9kZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBFbHNlLCB0aGUgbm9kZSBpc24ndCBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoZSBgZ2V0Q2xpZW50UmVjdHMoKWBcbiAgICAvLyAgQVBJIHdpbGwgX19hbHdheXNfXyByZXR1cm4gemVybyByZWN0cyAodGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgUmVhY3RcbiAgICAvLyAgaXMgdXNlZCB0byByZW5kZXIgbm9kZXMgb250byBhIGRldGFjaGVkIHRyZWUsIGFzIGNvbmZpcm1lZCBpbiB0aGlzIHRocmVhZDpcbiAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy85MTE3I2lzc3VlY29tbWVudC0yODQyMjg4NzApXG4gICAgLy9cbiAgICAvLyBJdCBhbHNvIG1lYW5zIHRoYXQgZXZlbiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgLy8gIGJlY2F1c2Ugc3R5bGVzIGFyZSBvbmx5IGNvbXB1dGVkIGZvciBub2RlcyB0aGF0IGFyZSBpbiB0aGUgZG9jdW1lbnQuXG4gICAgLy9cbiAgICAvLyBOT1RFOiBUSElTIEhBUyBCRUVOIFRIRSBDQVNFIEZPUiBZRUFSUy4gSXQgaXMgbm90IG5ldywgbm9yIGlzIGl0IGNhdXNlZCBieSB0YWJiYWJsZVxuICAgIC8vICBzb21laG93LiBUaG91Z2ggaXQgd2FzIG5ldmVyIHN0YXRlZCBvZmZpY2lhbGx5LCBhbnlvbmUgd2hvIGhhcyBldmVyIHVzZWQgdGFiYmFibGVcbiAgICAvLyAgQVBJcyBvbiBub2RlcyBpbiBkZXRhY2hlZCBjb250YWluZXJzIGhhcyBhY3R1YWxseSBpbXBsaWNpdGx5IHVzZWQgdGFiYmFibGUgaW4gd2hhdFxuICAgIC8vICB3YXMgbGF0ZXIgKGFzIG9mIHY1LjIuMCBvbiBBcHIgOSwgMjAyMSkgY2FsbGVkIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIG1vZGUgLS0gZXNzZW50aWFsbHlcbiAgICAvLyAgY29uc2lkZXJpbmcgX19ldmVyeXRoaW5nX18gdG8gYmUgdmlzaWJsZSBiZWNhdXNlIG9mIHRoZSBpbm5hYmlsaXR5IHRvIGRldGVybWluZSBzdHlsZXMuXG4gICAgLy9cbiAgICAvLyB2Ni4wLjA6IEFzIG9mIHRoaXMgbWFqb3IgcmVsZWFzZSwgdGhlIGRlZmF1bHQgJ2Z1bGwnIG9wdGlvbiBfX25vIGxvbmdlciB0cmVhdHMgZGV0YWNoZWRcbiAgICAvLyAgbm9kZXMgYXMgdmlzaWJsZSB3aXRoIHRoZSAnbm9uZScgZmFsbGJhY2suX19cbiAgICBpZiAoZGlzcGxheUNoZWNrICE9PSAnbGVnYWN5LWZ1bGwnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gaGlkZGVuXG4gICAgfVxuICAgIC8vIGVsc2UsIGZhbGxiYWNrIHRvICdub25lJyBtb2RlIGFuZCBjb25zaWRlciB0aGUgbm9kZSB2aXNpYmxlXG4gIH0gZWxzZSBpZiAoZGlzcGxheUNoZWNrID09PSAnbm9uLXplcm8tYXJlYScpIHtcbiAgICAvLyBOT1RFOiBFdmVuIHRob3VnaCB0aGlzIHRlc3RzIHRoYXQgdGhlIG5vZGUncyBjbGllbnQgcmVjdCBpcyBub24temVybyB0byBkZXRlcm1pbmVcbiAgICAvLyAgd2hldGhlciBpdCdzIGRpc3BsYXllZCwgYW5kIHRoYXQgYSBkZXRhY2hlZCBub2RlIHdpbGwgX19hbHdheXNfXyBoYXZlIGEgemVyby1hcmVhXG4gICAgLy8gIGNsaWVudCByZWN0LCB3ZSBkb24ndCBzcGVjaWFsLWNhc2UgZm9yIHdoZXRoZXIgdGhlIG5vZGUgaXMgYXR0YWNoZWQgb3Igbm90LiBJblxuICAgIC8vICB0aGlzIG1vZGUsIHdlIGRvIHdhbnQgdG8gY29uc2lkZXIgbm9kZXMgdGhhdCBoYXZlIGEgemVybyBhcmVhIHRvIGJlIGhpZGRlbiBhdCBhbGxcbiAgICAvLyAgdGltZXMsIGFuZCB0aGF0IGluY2x1ZGVzIGF0dGFjaGVkIG9yIG5vdC5cbiAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgfVxuXG4gIC8vIHZpc2libGUsIGFzIGZhciBhcyB3ZSBjYW4gdGVsbCwgb3IgcGVyIGN1cnJlbnQgYGRpc3BsYXlDaGVjaz1ub25lYCBtb2RlLCB3ZSBhc3N1bWVcbiAgLy8gIGl0J3MgdmlzaWJsZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBmb3JtIGZpZWxkcyAobmVzdGVkKSBpbnNpZGUgYSBkaXNhYmxlZCBmaWVsZHNldCBhcmUgbm90IGZvY3VzYWJsZS90YWJiYWJsZVxuLy8gIHVubGVzcyB0aGV5IGFyZSBpbiB0aGUgX2ZpcnN0XyA8bGVnZW5kPiBlbGVtZW50IG9mIHRoZSB0b3AtbW9zdCBkaXNhYmxlZFxuLy8gIGZpZWxkc2V0XG5jb25zdCBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKC9eKElOUFVUfEJVVFRPTnxTRUxFQ1R8VEVYVEFSRUEpJC8udGVzdChub2RlLnRhZ05hbWUpKSB7XG4gICAgbGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgLy8gY2hlY2sgaWYgYG5vZGVgIGlzIGNvbnRhaW5lZCBpbiBhIGRpc2FibGVkIDxmaWVsZHNldD5cbiAgICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgICAgaWYgKHBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ0ZJRUxEU0VUJyAmJiBwYXJlbnROb2RlLmRpc2FibGVkKSB7XG4gICAgICAgIC8vIGxvb2sgZm9yIHRoZSBmaXJzdCA8bGVnZW5kPiBhbW9uZyB0aGUgY2hpbGRyZW4gb2YgdGhlIGRpc2FibGVkIDxmaWVsZHNldD5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnROb2RlLmNoaWxkcmVuLml0ZW0oaSk7XG4gICAgICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgPGxlZ2VuZD4gKGluIGRvY3VtZW50IG9yZGVyKSBpcyBmb3VuZFxuICAgICAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnTEVHRU5EJykge1xuICAgICAgICAgICAgLy8gaWYgaXRzIHBhcmVudCA8ZmllbGRzZXQ+IGlzIG5vdCBuZXN0ZWQgaW4gYW5vdGhlciBkaXNhYmxlZCA8ZmllbGRzZXQ+LFxuICAgICAgICAgICAgLy8gcmV0dXJuIHdoZXRoZXIgYG5vZGVgIGlzIGEgZGVzY2VuZGFudCBvZiBpdHMgZmlyc3QgPGxlZ2VuZD5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwocGFyZW50Tm9kZSwgJ2ZpZWxkc2V0W2Rpc2FibGVkXSAqJylcbiAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgIDogIWNoaWxkLmNvbnRhaW5zKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PiBjb250YWluaW5nIGBub2RlYCBoYXMgbm8gPGxlZ2VuZD5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIGVsc2UsIG5vZGUncyB0YWJiYWJsZS9mb2N1c2FibGUgc3RhdGUgc2hvdWxkIG5vdCBiZSBhZmZlY3RlZCBieSBhIGZpZWxkc2V0J3NcbiAgLy8gIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGVcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBub2RlKSB7XG4gIGlmIChcbiAgICBub2RlLmRpc2FibGVkIHx8XG4gICAgaXNIaWRkZW5JbnB1dChub2RlKSB8fFxuICAgIGlzSGlkZGVuKG5vZGUsIG9wdGlvbnMpIHx8XG4gICAgLy8gRm9yIGEgZGV0YWlscyBlbGVtZW50IHdpdGggYSBzdW1tYXJ5LCB0aGUgc3VtbWFyeSBlbGVtZW50IGdldHMgdGhlIGZvY3VzXG4gICAgaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkgfHxcbiAgICBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBub2RlKSB7XG4gIGlmIChcbiAgICBpc05vblRhYmJhYmxlUmFkaW8obm9kZSkgfHxcbiAgICBnZXRUYWJpbmRleChub2RlKSA8IDAgfHxcbiAgICAhaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlID0gZnVuY3Rpb24gKHNoYWRvd0hvc3ROb2RlKSB7XG4gIGNvbnN0IHRhYkluZGV4ID0gcGFyc2VJbnQoc2hhZG93SG9zdE5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG4gIGlmIChpc05hTih0YWJJbmRleCkgfHwgdGFiSW5kZXggPj0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElmIGEgY3VzdG9tIGVsZW1lbnQgaGFzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIHRhYmluZGV4LFxuICAvLyBicm93c2VycyB3aWxsIG5vdCBhbGxvdyB0YWIgdGFyZ2V0aW5nIHNhaWQgZWxlbWVudCdzIGNoaWxkcmVuLlxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlc1Njb3BlPn0gY2FuZGlkYXRlc1xuICogQHJldHVybnMgRWxlbWVudFtdXG4gKi9cbmNvbnN0IHNvcnRCeU9yZGVyID0gZnVuY3Rpb24gKGNhbmRpZGF0ZXMpIHtcbiAgY29uc3QgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICBjb25zdCBvcmRlcmVkVGFiYmFibGVzID0gW107XG4gIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIGNvbnN0IGlzU2NvcGUgPSAhIWl0ZW0uc2NvcGU7XG4gICAgY29uc3QgZWxlbWVudCA9IGlzU2NvcGUgPyBpdGVtLnNjb3BlIDogaXRlbTtcbiAgICBjb25zdCBjYW5kaWRhdGVUYWJpbmRleCA9IGdldFRhYmluZGV4KGVsZW1lbnQsIGlzU2NvcGUpO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gaXNTY29wZSA/IHNvcnRCeU9yZGVyKGl0ZW0uY2FuZGlkYXRlcykgOiBlbGVtZW50O1xuICAgIGlmIChjYW5kaWRhdGVUYWJpbmRleCA9PT0gMCkge1xuICAgICAgaXNTY29wZVxuICAgICAgICA/IHJlZ3VsYXJUYWJiYWJsZXMucHVzaCguLi5lbGVtZW50cylcbiAgICAgICAgOiByZWd1bGFyVGFiYmFibGVzLnB1c2goZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yZGVyZWRUYWJiYWJsZXMucHVzaCh7XG4gICAgICAgIGRvY3VtZW50T3JkZXI6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVUYWJpbmRleCxcbiAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgaXNTY29wZTogaXNTY29wZSxcbiAgICAgICAgY29udGVudDogZWxlbWVudHMsXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvcmRlcmVkVGFiYmFibGVzXG4gICAgLnNvcnQoc29ydE9yZGVyZWRUYWJiYWJsZXMpXG4gICAgLnJlZHVjZSgoYWNjLCBzb3J0YWJsZSkgPT4ge1xuICAgICAgc29ydGFibGUuaXNTY29wZVxuICAgICAgICA/IGFjYy5wdXNoKC4uLnNvcnRhYmxlLmNvbnRlbnQpXG4gICAgICAgIDogYWNjLnB1c2goc29ydGFibGUuY29udGVudCk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKVxuICAgIC5jb25jYXQocmVndWxhclRhYmJhYmxlcyk7XG59O1xuXG5jb25zdCB0YWJiYWJsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBsZXQgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogZmFsc2UsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgICBzaGFkb3dSb290RmlsdGVyOiBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKFxuICAgICAgZWwsXG4gICAgICBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsXG4gICAgICBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNvcnRCeU9yZGVyKGNhbmRpZGF0ZXMpO1xufTtcblxuY29uc3QgZm9jdXNhYmxlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCBjYW5kaWRhdGVzO1xuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShbZWxdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhcbiAgICAgIGVsLFxuICAgICAgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLFxuICAgICAgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuY29uc3QgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmNvbnN0IGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovIGNhbmRpZGF0ZVNlbGVjdG9yc1xuICAuY29uY2F0KCdpZnJhbWUnKVxuICAuam9pbignLCcpO1xuXG5jb25zdCBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5leHBvcnQgeyB0YWJiYWJsZSwgZm9jdXNhYmxlLCBpc1RhYmJhYmxlLCBpc0ZvY3VzYWJsZSB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdpbmVydCcsIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gICAqIChodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsLzIwMTUvY29weXJpZ2h0LXNvZnR3YXJlLWFuZC1kb2N1bWVudCkuXG4gICAqL1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIHdlJ3JlIG5vdCBydW5uaW5nIGluc2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBOb2RlTGlzdHMuXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICAgKiBAdHlwZSB7dHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXN9XG4gICAgICovXG4gICAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdmFyIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZyA9IFsnYVtocmVmXScsICdhcmVhW2hyZWZdJywgJ2lucHV0Om5vdChbZGlzYWJsZWRdKScsICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJywgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKScsICdidXR0b246bm90KFtkaXNhYmxlZF0pJywgJ2RldGFpbHMnLCAnc3VtbWFyeScsICdpZnJhbWUnLCAnb2JqZWN0JywgJ2VtYmVkJywgJ1tjb250ZW50ZWRpdGFibGVdJ10uam9pbignLCcpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Um9vdGAgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBzdWJ0cmVlLCBpLmUuIGEgRE9NIHN1YnRyZWUgd2hvc2Ugcm9vdCBlbGVtZW50IGhhcyBhbiBgaW5lcnRgXG4gICAgICogYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogSXRzIG1haW4gZnVuY3Rpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgICAqICAgc3VidHJlZS4gVGhlIGBtYWtlU3VidHJlZVVuZm9jdXNhYmxlKClgIG1ldGhvZCBoYW5kbGVzIGNvbGxlY3RpbmcgYEluZXJ0Tm9kZWBzIHZpYSByZWdpc3RlcmluZ1xuICAgICAqICAgZWFjaCBmb2N1c2FibGUgbm9kZSBpbiB0aGUgc3VidHJlZSB3aXRoIHRoZSBzaW5nbGV0b24gYEluZXJ0TWFuYWdlcmAgd2hpY2ggbWFuYWdlcyBhbGwga25vd25cbiAgICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgICAqICAgaW5zdGFuY2UgZXhpc3RzIGZvciBlYWNoIGZvY3VzYWJsZSBub2RlIHdoaWNoIGhhcyBhdCBsZWFzdCBvbmUgaW5lcnQgcm9vdCBhcyBhbiBhbmNlc3Rvci5cbiAgICAgKlxuICAgICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAgICogICBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSByb290IG5vZGUpLiBUaGlzIGlzIGhhbmRsZWQgaW4gdGhlIGRlc3RydWN0b3IsIHdoaWNoIGNhbGxzIHRoZVxuICAgICAqICAgYGRlcmVnaXN0ZXJgIG1ldGhvZCBvbiBgSW5lcnRNYW5hZ2VyYCBmb3IgZWFjaCBtYW5hZ2VkIGluZXJ0IG5vZGUuXG4gICAgICovXG5cbiAgICB2YXIgSW5lcnRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRNYW5hZ2VyfSBpbmVydE1hbmFnZXIgVGhlIGdsb2JhbCBzaW5nbGV0b24gSW5lcnRNYW5hZ2VyIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Um9vdCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydE5vZGU+fVxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBmb2N1c2FibGUgbm9kZXMgaW4gdGhpcyBJbmVydFJvb3QncyBzdWJ0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIE1ha2UgdGhlIHN1YnRyZWUgaGlkZGVuIGZyb20gYXNzaXN0aXZlIHRlY2hub2xvZ3lcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSB0aGlzLl9yb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICAvLyBNYWtlIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIHN1YnRyZWUgdW5mb2N1c2FibGUgYW5kIGFkZCB0aGVtIHRvIF9tYW5hZ2VkTm9kZXNcbiAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSh0aGlzLl9yb290RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgICAvLyAtIGFueSBhZGRpdGlvbnMgaW4gdGhlIHN1YnRyZWU6IG1ha2UgdGhlbSB1bmZvY3VzYWJsZSB0b29cbiAgICAgICAgLy8gLSBhbnkgcmVtb3ZhbHMgZnJvbSB0aGUgc3VidHJlZTogcmVtb3ZlIHRoZW0gZnJvbSB0aGlzIGluZXJ0IHJvb3QncyBtYW5hZ2VkIG5vZGVzXG4gICAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgICAvLyAgIGVsZW1lbnQsIG1ha2UgdGhhdCBub2RlIGEgbWFuYWdlZCBub2RlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29uTXV0YXRpb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAgICogc3RvcmVkIGluIHRoaXMgb2JqZWN0IGFuZCB1cGRhdGVzIHRoZSBzdGF0ZSBvZiBhbGwgb2YgdGhlIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBOb3RlIHdlIGNhc3QgdGhlIG51bGxzIHRvIHRoZSBBTlkgdHlwZSBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAgIC8vICAgIG5lZWQgZXZlbiBtb3JlIGNhc3RzIHRocm91Z2hvdXQgdGhpcyBjb2RlLiBBbGwgYmV0cyBhcmUgb2ZmIGlmIGFuXG4gICAgICAgICAgLy8gICAgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkIGFuZCBhIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgICAgLy8gICAgdG8ga25vdyB3aGljaCBwcm9wZXJ0aWVzIHdlJ3JlIHNldHRpbmcuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4geyFTZXQ8IUluZXJ0Tm9kZT59IEEgY29weSBvZiB0aGlzIEluZXJ0Um9vdCdzIG1hbmFnZWQgbm9kZXMgc2V0LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBzdGFydE5vZGUgbWF5IGJlIGluIHNoYWRvdyBET00sIHNvIGZpbmQgaXRzIG5lYXJlc3Qgc2hhZG93Um9vdCB0byBnZXQgdGhlIGFjdGl2ZUVsZW1lbnQuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R9ICovbm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0Tm9kZS5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgICAvLyBjYWxsaW5nIGJsdXIoKSB3aWxsIG5vdCBhY3R1YWxseSBtb3ZlIHRoZSBmb2N1cy5cbiAgICAgICAgICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMgd2UgY2FsbCBmb2N1cygpIG9uIHRoZSBib2R5IGluc3RlYWQuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmlzaXROb2RlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuXG4gICAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAgIC8vIHRoaXMgaW5lcnQgcm9vdCwgc28gYWxsIG9mIGl0cyBtYW5hZ2VkIG5vZGVzIG5lZWQgdG8gYmUgYWRvcHRlZCBieSB0aGlzIEluZXJ0Um9vdC5cbiAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIucmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmFkZChpbmVydE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShpbmVydE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBlbnRpcmUgc3VidHJlZSBzdGFydGluZyBhdCBgc3RhcnROb2RlYC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlU3VidHJlZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fdW5tYW5hZ2VOb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgZGVzY2VuZGFudCBub2RlIGlzIGZvdW5kIHdpdGggYW4gYGluZXJ0YCBhdHRyaWJ1dGUsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fkb3B0SW5lcnRSb290KG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcblxuICAgICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgICAgLy8gc28gcmVnaXN0ZXIgaXQgbm93IGlmIG5lZWQgYmUuXG4gICAgICAgICAgaWYgKCFpbmVydFN1YnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShzYXZlZEluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBzdWJ0cmVlIGFkZGl0aW9ucywgcmVtb3ZhbHMsIG9yIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uTXV0YXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uTXV0YXRpb24ocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAvLyBVbi1tYW5hZ2UgcmVtb3ZlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5yZW1vdmVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlLWluaXRpYWxpc2UgaW5lcnQgbm9kZSBpZiB0YWJpbmRleCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZSh0YXJnZXQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbmV3IGluZXJ0IHJvb3QgaXMgYWRkZWQsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzIGFuZCBtYWtlIHN1cmUgaXQga25vd3MgYWJvdXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBtYW5hZ2VkIG5vZGVzIGZyb20gdGhpcyBpbmVydCBzdWJyb290LlxuICAgICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRTdWJyb290Ll9tYW5hZ2VOb2RlKG1hbmFnZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5fbWFuYWdlZE5vZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/c3RyaW5nfSBhcmlhSGlkZGVuICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXJpYUhpZGRlbikge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IGFyaWFIaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydFJvb3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Tm9kZWAgaW5pdGlhbGlzZXMgYW5kIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgbm9kZS5cbiAgICAgKiBBIG5vZGUgaXMgaW5lcnQgaWYgaXQgaXMgYSBkZXNjZW5kYW50IG9mIG9uZSBvciBtb3JlIGluZXJ0IHJvb3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBPbiBjb25zdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHNhdmVzIHRoZSBleGlzdGluZyBgdGFiaW5kZXhgIHZhbHVlIGZvciB0aGUgbm9kZSwgaWYgYW55LCBhbmRcbiAgICAgKiBlaXRoZXIgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgb3Igc2V0cyBpdCB0byBgLTFgLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZWxlbWVudFxuICAgICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIGBJbmVydE5vZGVgIG1haW50YWlucyBhIHNldCBvZiBgSW5lcnRSb290YHMgd2hpY2ggYXJlIGRlc2NlbmRhbnRzIG9mIHRoaXMgYEluZXJ0Tm9kZWAuIFdoZW4gYW5cbiAgICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICAgKiBgSW5lcnROb2RlYCB2aWEgYHJlbW92ZUluZXJ0Um9vdCgpYCwgd2hpY2ggaW4gdHVybiBkZXN0cm95cyB0aGUgYEluZXJ0Tm9kZWAgaWYgbm8gYEluZXJ0Um9vdGBzXG4gICAgICogcmVtYWluIGluIHRoZSBzZXQuIE9uIGRlc3RydWN0aW9uLCBgSW5lcnROb2RlYCByZWluc3RhdGVzIHRoZSBzdG9yZWQgYHRhYmluZGV4YCBpZiBvbmUgZXhpc3RzLFxuICAgICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIEEgZm9jdXNhYmxlIGVsZW1lbnQgdG8gYmUgbWFkZSBpbmVydC5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290IFRoZSBpbmVydCByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5lcnQgbm9kZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnROb2RlKTtcblxuICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Um9vdD59IFRoZSBzZXQgb2YgZGVzY2VuZGFudCBpbmVydCByb290cy5cbiAgICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgU2V0KFtpbmVydFJvb3RdKTtcblxuICAgICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2F2ZSBhbnkgcHJpb3IgdGFiaW5kZXggaW5mbyBhbmQgbWFrZSB0aGlzIG5vZGUgdW50YWJiYWJsZVxuICAgICAgICB0aGlzLmVuc3VyZVVudGFiYmFibGUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLlxuICAgICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Tm9kZSwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMuX25vZGU7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYGRlbGV0ZWAgdG8gcmVzdG9yZSBuYXRpdmUgZm9jdXMgbWV0aG9kLlxuICAgICAgICAgICAgaWYgKHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgICB0aGlzLl9ub2RlID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQsIGFueSBhdHRlbXB0IHRvIGFjY2VzcyBpdCB3aWxsIGNhdXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Rocm93SWZEZXN0cm95ZWQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Rocm93SWZEZXN0cm95ZWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgICAgLyoqIFNhdmUgdGhlIGV4aXN0aW5nIHRhYmluZGV4IHZhbHVlIGFuZCBtYWtlIHRoZSBub2RlIHVudGFiYmFibGUgYW5kIHVuZm9jdXNhYmxlICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmVVbnRhYmJhYmxlKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSkge1xuICAgICAgICAgICAgaWYgKCAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4ID09PSAtMSAmJiB0aGlzLmhhc1NhdmVkVGFiSW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbm90aGVyIGluZXJ0IHJvb3QgdG8gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdhZGRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLmFkZChpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBmcm9tIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICAgKiBzbyB0aGUgb2JqZWN0IHNob3VsZCBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3llZCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHshSW5lcnROb2RlfSAqL3RoaXMuX2Rlc3Ryb3llZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ25vZGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/bnVtYmVyfSB0YWJJbmRleCAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YWJJbmRleCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P251bWJlcn0gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBXaGVuIGFuIGVsZW1lbnQgYmVjb21lcyBhbiBpbmVydCByb290IGJ5IGhhdmluZyBhbiBgaW5lcnRgIGF0dHJpYnV0ZSBzZXQgYW5kL29yIGl0cyBgaW5lcnRgXG4gICAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICAgKiBUaGUgYEluZXJ0Um9vdGAgaW4gdHVybiByZWdpc3RlcnMgaXRzZWxmIGFzIG1hbmFnaW5nIGFsbCBvZiB0aGUgZWxlbWVudCdzIGZvY3VzYWJsZSBkZXNjZW5kYW50XG4gICAgICogbm9kZXMgdmlhIHRoZSBgcmVnaXN0ZXIoKWAgbWV0aG9kLiBUaGUgYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgIGluc3RhbmNlXG4gICAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshRG9jdW1lbnR9IGRvY3VtZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRNYW5hZ2VyKTtcblxuICAgICAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHshRG9jdW1lbnR9ICovXG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIG5vZGVzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIGluZXJ0IHJvb3RzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnRSb290Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICAgKiBAdHlwZSB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gQWRkIGluZXJ0IHN0eWxlLlxuICAgICAgICBhZGRJbmVydFN0eWxlKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRvY3VtZW50TG9hZGVkLmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZCBiZSBhbiBpbmVydCByb290IG9yIG5vdC5cbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluZXJ0XG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAgICBrZXk6ICdzZXRJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbmVydChyb290LCBpbmVydCkge1xuICAgICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBpbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmVydFJvb3QgPSBuZXcgSW5lcnRSb290KHJvb3QsIHRoaXMpO1xuICAgICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290cy5zZXQocm9vdCwgaW5lcnRSb290KTtcbiAgICAgICAgICAgIC8vIElmIG5vdCBjb250YWluZWQgaW4gdGhlIGRvY3VtZW50LCBpdCBtdXN0IGJlIGluIGEgc2hhZG93Um9vdC5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHJvb3QpKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgYWRkSW5lcnRTdHlsZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgICAgX2luZXJ0Um9vdC5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShyb290KTtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIEluZXJ0Um9vdCBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBlbGVtZW50LCBpZiBhbnkuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmVydFJvb3QoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbmVydFJvb3RzLmdldChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBub2RlLlxuICAgICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgICAqIGJlIGFkZGVkIHRvIGl0cyBzZXQgb2YgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Tm9kZX0gaW5lcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbm9kZSB3YXMgYWxyZWFkeSBpbiBhbiBpbmVydCBzdWJ0cmVlXG4gICAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZXJ0Tm9kZSA9IG5ldyBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuc2V0KG5vZGUsIGluZXJ0Tm9kZSk7XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlLXJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIGluZXJ0IG5vZGUuXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICAgKiBub2RlIGZyb20gdGhlIEluZXJ0TWFuYWdlcidzIHNldCBvZiBtYW5hZ2VkIG5vZGVzIGlmIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICogSWYgdGhlIG5vZGUgaXMgbm90IGN1cnJlbnRseSBtYW5hZ2VkLCB0aGlzIGlzIGVzc2VudGlhbGx5IGEgbm8tb3AuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7P0luZXJ0Tm9kZX0gVGhlIHBvdGVudGlhbGx5IGRlc3Ryb3llZCBJbmVydE5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgaWYgYW55LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXJlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKCFpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0Tm9kZS5yZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9jdW1lbnRMb2FkZWQoKSB7XG4gICAgICAgICAgLy8gRmluZCBhbGwgaW5lcnQgcm9vdHMgaW4gZG9jdW1lbnQgYW5kIG1ha2UgdGhlbSBhY3R1YWxseSBpbmVydC5cbiAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gQ29tbWVudCB0aGlzIG91dCB0byB1c2UgcHJvZ3JhbW1hdGljIEFQSSBvbmx5LlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZG9jdW1lbnQuYm9keSB8fCB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgc3VidHJlZTogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3dhdGNoRm9ySW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhdGNoRm9ySW5lcnQocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0ID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRJbmVydCh0YXJnZXQsIGluZXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRNYW5hZ2VyO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHdhbGsgdGhlIGNvbXBvc2VkIHRyZWUgZnJvbSB8bm9kZXwuXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uICghSFRNTEVsZW1lbnQpKT19IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50IHRyYXZlcnNlZCxcbiAgICAgKiAgICAgYmVmb3JlIGRlc2NlbmRpbmcgaW50byBjaGlsZCBub2Rlcy5cbiAgICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY29tcG9zZWRUcmVlV2Fsayhub2RlLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVzY2VuZCBpbnRvIG5vZGU6XG4gICAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgICAvLyB1cCBieSB0aGUgPGNvbnRlbnQ+IG9yIDxzaGFkb3c+IGVsZW1lbnRzLiBEZXNjZW5kIHN0cmFpZ2h0IGludG8gdGhlXG4gICAgICAgIC8vIFNoYWRvd1Jvb3QuXG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc2hhZG93Um9vdCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBkaXN0cmlidXRlZCBlbGVtZW50cyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnY29udGVudCcpIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmaWVzIGlmIFNoYWRvd0RvbSB2MCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIGRpc3RyaWJ1dGVkTm9kZXMgPSBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMgPyBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhkaXN0cmlidXRlZE5vZGVzW2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8c2xvdD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGFzc2lnbmVkIG5vZGVzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdzbG90Jykge1xuICAgICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZ5IGlmIFNoYWRvd0RvbSB2MSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIF9kaXN0cmlidXRlZE5vZGVzID0gc2xvdC5hc3NpZ25lZE5vZGVzID8gc2xvdC5hc3NpZ25lZE5vZGVzKHsgZmxhdHRlbjogdHJ1ZSB9KSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoX2Rpc3RyaWJ1dGVkTm9kZXNbX2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgICAvLyBlbGVtZW50LCBub3IgYSA8c2hhZG93PiBlbGVtZW50IHJlY3Vyc2Ugbm9ybWFsbHkuXG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGNoaWxkLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgICBpZiAobm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZSNpbmVydC1zdHlsZSwgbGluayNpbmVydC1zdHlsZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2luZXJ0LXN0eWxlJyk7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG5cbiAgICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgdmFyIGluZXJ0TWFuYWdlciA9IG5ldyBJbmVydE1hbmFnZXIoZG9jdW1lbnQpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmVydCkge1xuICAgICAgICAgIGluZXJ0TWFuYWdlci5zZXRJbmVydCh0aGlzLCBpbmVydCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSkoKTtcblxufSkpKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogYEJsb2NraW5nRWxlbWVudHNgIG1hbmFnZXMgYSBzdGFjayBvZiBlbGVtZW50cyB0aGF0IGluZXJ0IHRoZSBpbnRlcmFjdGlvblxuICogb3V0c2lkZSB0aGVtLiBUaGUgdG9wIGVsZW1lbnQgaXMgdGhlIGludGVyYWN0aXZlIHBhcnQgb2YgdGhlIGRvY3VtZW50LlxuICogVGhlIHN0YWNrIGNhbiBiZSB1cGRhdGVkIHdpdGggdGhlIG1ldGhvZHMgYHB1c2gsIHJlbW92ZSwgcG9wYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgLyoqXG4gICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuIFRoaXMgZW1wdGllc1xuICAgKiB0aGUgYmxvY2tpbmcgZWxlbWVudHNcbiAgICovXG4gIGRlc3RydWN0b3IoKTogdm9pZDtcblxuICAvKipcbiAgICogVGhlIHRvcCBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgdG9wOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBlbGVtZW50IHRvIHRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICovXG4gIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nIGVsZW1lbnRzLiBSZXR1cm5zIHRydWUgaWYgdGhlXG4gICAqIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHRvcCBibG9ja2luZyBlbGVtZW50IGFuZCByZXR1cm5zIGl0LlxuICAgKi9cbiAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgYSBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIGV4dGVuZHMgRG9jdW1lbnQge1xuICAkYmxvY2tpbmdFbGVtZW50czogQmxvY2tpbmdFbGVtZW50cztcbn1cblxuKCgpID0+IHtcbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBwcm9wZXJ0aWVzICovXG4gIGNvbnN0IF9ibG9ja2luZ0VsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9hbHJlYWR5SW5lcnRFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfdG9wRWxQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zaWJsaW5nc1RvUmVzdG9yZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfcGFyZW50TU8gPSBTeW1ib2woKTtcblxuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHN0YXRpYyBtZXRob2RzICovXG4gIGNvbnN0IF90b3BDaGFuZ2VkID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zd2FwSW5lcnRlZFNpYmxpbmcgPSBTeW1ib2woKTtcbiAgY29uc3QgX2luZXJ0U2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX3Jlc3RvcmVJbmVydGVkU2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4gPSBTeW1ib2woKTtcbiAgY29uc3QgX2lzSW5lcnRhYmxlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9oYW5kbGVNdXRhdGlvbnMgPSBTeW1ib2woKTtcblxuICBpbnRlcmZhY2UgSW5lcnRhYmxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGluZXJ0PzogYm9vbGVhbjtcbiAgfVxuXG4gIGludGVyZmFjZSBJbnRlcm5hbFN0YXRlIHtcbiAgICBbX3NpYmxpbmdzVG9SZXN0b3JlXTogU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT47XG4gICAgW19wYXJlbnRNT106IE11dGF0aW9uT2JzZXJ2ZXI7XG4gIH1cbiAgaW50ZXJmYWNlIEhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIEludGVybmFsU3RhdGUge31cbiAgaW50ZXJmYWNlIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgUGFydGlhbDxJbnRlcm5hbFN0YXRlPiB7fVxuXG4gIC8qKlxuICAgKiBTaGFkeURPTSBzaGFkeSByb290cyBsb29rIGEgbG90IGxpa2UgcmVhbCBTaGFkb3dSb290cy4gVGhlIF9fc2hhZHkgcHJvcGVydHlcbiAgICogZ2l2ZXMgdGhlbSBhd2F5LCB0aG91Z2guXG4gICAqL1xuICBpbnRlcmZhY2UgTWF5YmVTaGFkeVJvb3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBfX3NoYWR5OiB1bmtub3duO1xuICAgIGhvc3Q6IEVsZW1lbnQ7XG4gIH1cblxuICBjbGFzcyBCbG9ja2luZ0VsZW1lbnRzSW1wbCBpbXBsZW1lbnRzIEJsb2NraW5nRWxlbWVudHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBwcml2YXRlW19ibG9ja2luZ0VsZW1lbnRzXTogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcGFyZW50cyBvZiB0aGUgdG9wIGVsZW1lbnQsIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgKiBpdHNlbGYgdXAgdG8gYm9keS4gV2hlbiB0b3AgY2hhbmdlcywgdGhlIG9sZCB0b3AgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgKiBmcm9tIHRoZSBkb2N1bWVudCwgc28gd2UgbmVlZCB0byBtZW1vaXplIHRoZSBpbmVydGVkIHBhcmVudHMnIHNpYmxpbmdzXG4gICAgICogaW4gb3JkZXIgdG8gcmVzdG9yZSB0aGVpciBpbmVydGVuZXNzIHdoZW4gdG9wIGNoYW5nZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wRWxQYXJlbnRzXTogSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBFbGVtZW50cyB0aGF0IGFyZSBhbHJlYWR5IGluZXJ0IGJlZm9yZSB0aGUgZmlyc3QgYmxvY2tpbmcgZWxlbWVudCBpc1xuICAgICAqIHB1c2hlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBuZXcgU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT4oKTtcblxuICAgIGRlc3RydWN0b3IoKTogdm9pZCB7XG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGluZXJ0bmVzcy5cbiAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKHRoaXNbX3RvcEVsUGFyZW50c10pO1xuICAgICAgLy8gTm90ZSB3ZSBkb24ndCB3YW50IHRvIG1ha2UgdGhlc2UgcHJvcGVydGllcyBudWxsYWJsZSBvbiB0aGUgY2xhc3MsXG4gICAgICAvLyBzaW5jZSB0aGVuIHdlJ2QgbmVlZCBub24tbnVsbCBjYXN0cyBpbiBtYW55IHBsYWNlcy4gQ2FsbGluZyBhIG1ldGhvZCBvblxuICAgICAgLy8gYSBCbG9ja2luZ0VsZW1lbnRzIGluc3RhbmNlIGFmdGVyIGNhbGxpbmcgZGVzdHJ1Y3RvciB3aWxsIHJlc3VsdCBpbiBhblxuICAgICAgLy8gZXhjZXB0aW9uLlxuICAgICAgY29uc3QgbnVsbGFibGUgPSB0aGlzIGFzIHVua25vd24gYXMge1xuICAgICAgICBbX2Jsb2NraW5nRWxlbWVudHNdOiBudWxsO1xuICAgICAgICBbX3RvcEVsUGFyZW50c106IG51bGw7XG4gICAgICAgIFtfYWxyZWFkeUluZXJ0RWxlbWVudHNdOiBudWxsO1xuICAgICAgfTtcbiAgICAgIG51bGxhYmxlW19ibG9ja2luZ0VsZW1lbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfdG9wRWxQYXJlbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgdG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgZWxlbXMgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXTtcbiAgICAgIHJldHVybiBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH1cblxuICAgIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50ID09PSB0aGlzLnRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIHdlJ2xsIGJyaW5nIGl0IHRvIHRoZSB0b3AuXG4gICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICAgIHRoaXNbX3RvcENoYW5nZWRdKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnNwbGljZShpLCAxKTtcbiAgICAgIC8vIFRvcCBjaGFuZ2VkIG9ubHkgaWYgdGhlIHJlbW92ZWQgZWxlbWVudCB3YXMgdGhlIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKGkgPT09IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmxlbmd0aCkge1xuICAgICAgICB0aGlzW190b3BDaGFuZ2VkXSh0aGlzLnRvcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRvcCAmJiB0aGlzLnJlbW92ZSh0b3ApO1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGBpbmVydGAgdG8gYWxsIGRvY3VtZW50IGVsZW1lbnRzIGV4Y2VwdCB0aGUgbmV3IHRvcCBlbGVtZW50LCBpdHNcbiAgICAgKiBwYXJlbnRzLCBhbmQgaXRzIGRpc3RyaWJ1dGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wQ2hhbmdlZF0obmV3VG9wOiBNYXliZUhhc0ludGVybmFsU3RhdGV8bnVsbCk6IHZvaWQge1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBjb25zdCBvbGRQYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIC8vIE5vIG5ldyB0b3AsIHJlc2V0IG9sZCB0b3AgaWYgYW55LlxuICAgICAgaWYgKCFuZXdUb3ApIHtcbiAgICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cyk7XG4gICAgICAgIHRvS2VlcEluZXJ0LmNsZWFyKCk7XG4gICAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBbXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdQYXJlbnRzID0gdGhpc1tfZ2V0UGFyZW50c10obmV3VG9wKTtcbiAgICAgIC8vIE5ldyB0b3AgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgbWFpbiBkb2N1bWVudCFcbiAgICAgIGlmIChuZXdQYXJlbnRzW25ld1BhcmVudHMubGVuZ3RoIC0gMV0ucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm9uLWNvbm5lY3RlZCBlbGVtZW50IGNhbm5vdCBiZSBhIGJsb2NraW5nIGVsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIC8vIENhc3QgaGVyZSBiZWNhdXNlIHdlIGtub3cgd2UnbGwgY2FsbCBfaW5lcnRTaWJsaW5ncyBvbiBuZXdQYXJlbnRzXG4gICAgICAvLyBiZWxvdy5cbiAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBuZXdQYXJlbnRzIGFzIEFycmF5PEhhc0ludGVybmFsU3RhdGU+O1xuXG4gICAgICBjb25zdCB0b1NraXAgPSB0aGlzW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShuZXdUb3ApO1xuXG4gICAgICAvLyBObyBwcmV2aW91cyB0b3AgZWxlbWVudC5cbiAgICAgIGlmICghb2xkUGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cywgdG9Ta2lwLCB0b0tlZXBJbmVydCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSBvbGRQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgaiA9IG5ld1BhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIC8vIEZpbmQgY29tbW9uIHBhcmVudC4gSW5kZXggMCBpcyB0aGUgZWxlbWVudCBpdHNlbGYgKHNvIHN0b3AgYmVmb3JlIGl0KS5cbiAgICAgIHdoaWxlIChpID4gMCAmJiBqID4gMCAmJiBvbGRQYXJlbnRzW2ldID09PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgICAgLy8gSWYgdXAgdGhlIHBhcmVudHMgdHJlZSB0aGVyZSBhcmUgMiBlbGVtZW50cyB0aGF0IGFyZSBzaWJsaW5ncywgc3dhcFxuICAgICAgLy8gdGhlIGluZXJ0ZWQgc2libGluZy5cbiAgICAgIGlmIChvbGRQYXJlbnRzW2ldICE9PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIHRoaXNbX3N3YXBJbmVydGVkU2libGluZ10ob2xkUGFyZW50c1tpXSwgbmV3UGFyZW50c1tqXSk7XG4gICAgICB9XG4gICAgICAvLyBSZXN0b3JlIG9sZCBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0bmVzcy5cbiAgICAgIGkgPiAwICYmIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMuc2xpY2UoMCwgaSkpO1xuICAgICAgLy8gTWFrZSBuZXcgcGFyZW50cyBzaWJsaW5ncyBpbmVydC5cbiAgICAgIGogPiAwICYmIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMuc2xpY2UoMCwgaiksIHRvU2tpcCwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgaW5lcnRuZXNzIGJldHdlZW4gdHdvIHNpYmxpbmcgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfc3dhcEluZXJ0ZWRTaWJsaW5nXShcbiAgICAgICAgb2xkSW5lcnQ6IEhhc0ludGVybmFsU3RhdGUsIG5ld0luZXJ0OiBNYXliZUhhc0ludGVybmFsU3RhdGUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNpYmxpbmdzVG9SZXN0b3JlID0gb2xkSW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgIC8vIG9sZEluZXJ0IGlzIG5vdCBjb250YWluZWQgaW4gc2libGluZ3MgdG8gcmVzdG9yZSwgc28gd2UgaGF2ZSB0byBjaGVja1xuICAgICAgLy8gaWYgaXQncyBpbmVydGFibGUgYW5kIGlmIGFscmVhZHkgaW5lcnQuXG4gICAgICBpZiAodGhpc1tfaXNJbmVydGFibGVdKG9sZEluZXJ0KSAmJiAhb2xkSW5lcnQuaW5lcnQpIHtcbiAgICAgICAgb2xkSW5lcnQuaW5lcnQgPSB0cnVlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5hZGQob2xkSW5lcnQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbmV3SW5lcnQgd2FzIGFscmVhZHkgYmV0d2VlbiB0aGUgc2libGluZ3MgdG8gcmVzdG9yZSwgaXQgbWVhbnMgaXQgaXNcbiAgICAgIC8vIGluZXJ0YWJsZSBhbmQgbXVzdCBiZSByZXN0b3JlZC5cbiAgICAgIGlmIChzaWJsaW5nc1RvUmVzdG9yZS5oYXMobmV3SW5lcnQpKSB7XG4gICAgICAgIG5ld0luZXJ0LmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmRlbGV0ZShuZXdJbmVydCk7XG4gICAgICB9XG4gICAgICBuZXdJbmVydFtfcGFyZW50TU9dID0gb2xkSW5lcnRbX3BhcmVudE1PXTtcbiAgICAgIG5ld0luZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBzaWJsaW5nc1RvUmVzdG9yZTtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIGluZXJ0bmVzcyB0byB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKGVsZW1lbnRzOiBIYXNJbnRlcm5hbFN0YXRlW10pIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBtbyA9IGVsZW1lbnRbX3BhcmVudE1PXTtcbiAgICAgICAgbW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgICBmb3IgKGNvbnN0IHNpYmxpbmcgb2Ygc2libGluZ3MpIHtcbiAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZXJ0cyB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzIGV4Y2VwdCB0aGUgZWxlbWVudHMgdG8gc2tpcC4gU3RvcmVzXG4gICAgICogdGhlIGluZXJ0ZWQgc2libGluZ3MgaW50byB0aGUgZWxlbWVudCdzIHN5bWJvbCBgX3NpYmxpbmdzVG9SZXN0b3JlYC5cbiAgICAgKiBQYXNzIGB0b0tlZXBJbmVydGAgdG8gY29sbGVjdCB0aGUgYWxyZWFkeSBpbmVydCBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19pbmVydFNpYmxpbmdzXShcbiAgICAgICAgZWxlbWVudHM6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdLCB0b1NraXA6IFNldDxIVE1MRWxlbWVudD58bnVsbCxcbiAgICAgICAgdG9LZWVwSW5lcnQ6IFNldDxIVE1MRWxlbWVudD58bnVsbCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIC8vIEFzc3VtZSBlbGVtZW50IGlzIG5vdCBhIERvY3VtZW50LCBzbyBpdCBtdXN0IGhhdmUgYSBwYXJlbnROb2RlLlxuICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUhO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBjaGlsZHJlbltqXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgLy8gU2tpcCB0aGUgaW5wdXQgZWxlbWVudCwgaWYgbm90IGluZXJ0YWJsZSBvciB0byBiZSBza2lwcGVkLlxuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBlbGVtZW50IHx8ICF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykgfHxcbiAgICAgICAgICAgICAgKHRvU2tpcCAmJiB0b1NraXAuaGFzKHNpYmxpbmcpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNob3VsZCBiZSBjb2xsZWN0ZWQgc2luY2UgYWxyZWFkeSBpbmVydGVkLlxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIHNpYmxpbmdzIHRoYXQgd2VyZSBpbmVydGVkLlxuICAgICAgICBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBpbmVydGVkU2libGluZ3M7XG4gICAgICAgIC8vIE9ic2VydmUgb25seSBpbW1lZGlhdGUgY2hpbGRyZW4gbXV0YXRpb25zIG9uIHRoZSBwYXJlbnQuXG4gICAgICAgIGNvbnN0IG1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpc1tfaGFuZGxlTXV0YXRpb25zXS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZWxlbWVudFtfcGFyZW50TU9dID0gbW87XG4gICAgICAgIGxldCBwYXJlbnRUb09ic2VydmUgPSBwYXJlbnQ7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHRoZSBTaGFkeURPTSBwb2x5ZmlsbCwgdGhlbiBvdXIgcGFyZW50IGNvdWxkIGJlIGFcbiAgICAgICAgLy8gc2hhZHkgcm9vdCwgd2hpY2ggaXMgYW4gb2JqZWN0IHRoYXQgYWN0cyBsaWtlIGEgU2hhZG93Um9vdCwgYnV0IGlzbid0XG4gICAgICAgIC8vIGFjdHVhbGx5IGEgbm9kZSBpbiB0aGUgcmVhbCBET00uIE9ic2VydmUgdGhlIHJlYWwgRE9NIHBhcmVudCBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBtYXliZVNoYWR5Um9vdCA9IHBhcmVudFRvT2JzZXJ2ZSBhcyBNYXliZVNoYWR5Um9vdDtcbiAgICAgICAgaWYgKG1heWJlU2hhZHlSb290Ll9fc2hhZHkgJiYgbWF5YmVTaGFkeVJvb3QuaG9zdCkge1xuICAgICAgICAgIHBhcmVudFRvT2JzZXJ2ZSA9IG1heWJlU2hhZHlSb290Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbW8ub2JzZXJ2ZShwYXJlbnRUb09ic2VydmUsIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbmV3bHkgYWRkZWQvcmVtb3ZlZCBub2RlcyBieSB0b2dnbGluZyB0aGVpciBpbmVydG5lc3MuXG4gICAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIGN1cnJlbnQgdG9wIEJsb2NraW5nIEVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgKiBub3RpZnlpbmcgYW5kIHJlbW92aW5nIGl0LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2hhbmRsZU11dGF0aW9uc10obXV0YXRpb25zOiBNdXRhdGlvblJlY29yZFtdKTogdm9pZCB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHNoYWRvd1Jvb3QsIGdldCBpdHMgaG9zdCBhcyB3ZSBza2lwIHNoYWRvd1Jvb3RzIHdoZW5cbiAgICAgICAgLy8gY29tcHV0aW5nIF90b3BFbFBhcmVudHMuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IChtdXRhdGlvbi50YXJnZXQgYXMgU2hhZG93Um9vdCkuaG9zdCB8fCBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSA/XG4gICAgICAgICAgICBwYXJlbnRzLmxlbmd0aCA6XG4gICAgICAgICAgICBwYXJlbnRzLmluZGV4T2YodGFyZ2V0IGFzIEhhc0ludGVybmFsU3RhdGUpO1xuICAgICAgICBjb25zdCBpbmVydGVkQ2hpbGQgPSBwYXJlbnRzW2lkeCAtIDFdO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBpbmVydGVkQ2hpbGRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcblxuICAgICAgICAvLyBUbyByZXN0b3JlLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBpbmVydGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnRGV0ZWN0ZWQgcmVtb3ZhbCBvZiB0aGUgdG9wIEJsb2NraW5nIEVsZW1lbnQuJyk7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5lcnRlZFNpYmxpbmdzLmhhcyhzaWJsaW5nKSkge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmRlbGV0ZShzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBpbmVydC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLmFkZGVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmICghdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgaW5lcnRhYmxlLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2lzSW5lcnRhYmxlXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGZhbHNlID09PSAvXihzdHlsZXx0ZW1wbGF0ZXxzY3JpcHQpJC8udGVzdChlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBuZXdQYXJlbnRzIG9mIGFuIGVsZW1lbnQsIHN0YXJ0aW5nIGZyb20gZWxlbWVudFxuICAgICAqIChpbmNsdWRlZCkgdXAgdG8gYGRvY3VtZW50LmJvZHlgIChleGNsdWRlZCkuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0UGFyZW50c10oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBBcnJheTxIVE1MRWxlbWVudD4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnQ6IEhUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkID0gZWxlbWVudDtcbiAgICAgIC8vIFN0b3AgdG8gYm9keS5cbiAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgLy8gU2tpcCBzaGFkb3cgcm9vdHMuXG4gICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGFkb3dEb20gdjFcbiAgICAgICAgaWYgKGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gQ29sbGVjdCBzbG90cyBmcm9tIGRlZXBlc3Qgc2xvdCB0byB0b3AuXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPSBjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb250aW51ZSB0aGUgc2VhcmNoIG9uIHRoZSB0b3Agc2xvdC5cbiAgICAgICAgICBjdXJyZW50ID0gcGFyZW50cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICAgICAoY3VycmVudCBhcyBOb2RlIGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0cmlidXRlZCBjaGlsZHJlbiBvZiB0aGUgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBzaGFkb3cgcm9vdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShlbGVtZW50OiBIVE1MRWxlbWVudCk6XG4gICAgICAgIFNldDxIVE1MRWxlbWVudD58bnVsbCB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgIGxldCBpO1xuICAgICAgbGV0IGo7XG4gICAgICBsZXQgbm9kZXM7XG4gICAgICBjb25zdCBzbG90cyA9IHNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgICAgaWYgKHNsb3RzLmxlbmd0aCAmJiBzbG90c1swXS5hc3NpZ25lZE5vZGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzID0gc2xvdHNbaV0uYXNzaWduZWROb2Rlcyh7XG4gICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICByZXN1bHQuYWRkKG5vZGVzW2pdIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZWFyY2ggZm9yIDxjb250ZW50Pi5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgKGRvY3VtZW50IGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzID1cbiAgICAgIG5ldyBCbG9ja2luZ0VsZW1lbnRzSW1wbCgpO1xufSkoKTtcbiIsImltcG9ydCBcIndpY2ctaW5lcnRcIjtcbmltcG9ydCBcImJsb2NraW5nLWVsZW1lbnRzXCI7XG5pbXBvcnQgeyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIH0gZnJvbSBcImJsb2NraW5nLWVsZW1lbnRzXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZXREb2N1bWVudCB9IGZyb20gXCIuL3VzZS1kb2N1bWVudC1jbGFzc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5cbmZ1bmN0aW9uIGJsb2NraW5nRWxlbWVudHMoKSB7IHJldHVybiAoZ2V0RG9jdW1lbnQoKSBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyB9XG4vKipcbiAqIEFsbG93cyBhbiBlbGVtZW50IHRvIHRyYXAgZm9jdXMgYnkgYXBwbHlpbmcgdGhlIFwiaW5lcnRcIiBhdHRyaWJ1dGUgdG8gYWxsIHNpYmxpbmcsIGF1bnQsIGFuZCB1bmNsZSBub2Rlcy5cbiAqIFxuICogQXV0b21hdGljYWxseSBoYW5kbGVzIGNvbnNlY3V0aXZlIGNhbGxzIHdpdGggYSBsb29zZWx5IGFwcGxpZWQgc3RhY2sgb3BlcmF0aW9uIFxuICogKHNwZWNpZmljYWxseSB2aWEgYGJsb2NraW5nRWxlbWVudHNgLCB3aXRoIGEgc21hbGwgcG9seWZpbGwgYmVjYXVzZSBJJ20gbm90IHN1cmUgaG93IGxvbmdcbiAqIGl0J2xsIHRha2UgdG8gZmluZCBpdHMgd2F5IGludG8gdGhlIHNwZWMsIGlmIGV2ZXIpXG4gKiBAcGFyYW0gdGFyZ2V0IFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmxvY2tpbmdFbGVtZW50PEUgZXh0ZW5kcyBFbGVtZW50PihlbmFibGVkOiBib29sZWFuLCBnZXRUYXJnZXQ6ICgpID0+IChFIHwgbnVsbCkpIHtcblxuICAgIGNvbnN0IHN0YWJsZUdldFRhcmdldCA9IHVzZVN0YWJsZUNhbGxiYWNrKGdldFRhcmdldCk7XG5cbiAgICAvKipcbiAgICAgKiBQdXNoL3BvcCB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZ0VsZW1lbnRzIHN0YWNrLlxuICAgICAqL1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHN0YWJsZUdldFRhcmdldCgpO1xuXG4gICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgYmxvY2tpbmdFbGVtZW50cyB3aWxsIGZhaWwgaWYsIGZvciBleGFtcGxlLFxuICAgICAgICAgICAgLy8gdGhlIHRhcmdldCBlbGVtZW50IGlzbid0IGNvbm5lY3RlZCB0byBkb2N1bWVudC5ib2R5LlxuICAgICAgICAgICAgLy8gVGhpcyBpcyByYXJlLCBidXQgaXQncyBiZXR0ZXIgdG8gZmFpbCBzaWxlbnRseSB3aXRoIHdlaXJkIHRhYmJpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIHRoYW4gdG8gY3Jhc2ggdGhlIGVudGlyZSBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYmxvY2tpbmdFbGVtZW50cygpLnB1c2godGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NraW5nRWxlbWVudHMoKS5yZW1vdmUodGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBXZWxsLCBzZW1pLXNpbGVudGx5LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2VuYWJsZWRdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGJsb2NraW5nRWxlbWVudHMoKS50b3A7XG59XG5cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBpc0ZvY3VzYWJsZSB9IGZyb20gXCJ0YWJiYWJsZVwiO1xuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCB9IGZyb20gXCIuL3VzZS1hY3RpdmUtZWxlbWVudFwiO1xuaW1wb3J0IHsgZ2V0VG9wRWxlbWVudCwgdXNlQmxvY2tpbmdFbGVtZW50IH0gZnJvbSBcIi4vdXNlLWJsb2NraW5nLWVsZW1lbnRcIjtcbmltcG9ydCB7IGdldERvY3VtZW50IH0gZnJvbSBcIi4vdXNlLWRvY3VtZW50LWNsYXNzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1RyYXBQYXJhbWV0ZXJzIHsgdHJhcEFjdGl2ZTogYm9vbGVhbjsgfVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUZvY3VzVHJhcFJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiwgXCJ1c2VSZWZFbGVtZW50UHJvcHNcIj4ge1xuICAgIC8qKiAqVW5zdGFibGUqIChyZWxpZXMgb24gdGhlIGB0cmFwQWN0aXZlYCBwcm9wKSAqL1xuICAgIHVzZUZvY3VzVHJhcFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbn1cblxuY29uc3QgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvID0gbmV3IE1hcDxFbGVtZW50IHwgbnVsbCwgKE5vZGUgJiBIVE1MT3JTVkdFbGVtZW50KT4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvY3VzVHJhcDxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgdHJhcEFjdGl2ZSB9OiBVc2VGb2N1c1RyYXBQYXJhbWV0ZXJzKTogVXNlRm9jdXNUcmFwUmV0dXJuVHlwZTxFPiB7XG4gICAgXG4gICAgY29uc3QgaGFuZGxlQWN0aXZlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHRyYXBBY3RpdmU6IGJvb2xlYW4sIGVsZW1lbnQ6IEUgfCBudWxsKSA9PiB7XG4gICAgICAgIGlmICh0cmFwQWN0aXZlICYmIGVsZW1lbnQpIHtcblxuICAgICAgICAgICAgbGV0IHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBleHRyYSBxdWV1ZU1pY3JvdGFzayBpcyBuZWVkZWQgZm9yXG4gICAgICAgICAgICAgICAgLy8gLi4ucmVhc29ucz9cbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50KT8uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFmSGFuZGxlID0gMDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGZvY3VzIHRvIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAvLyB0aGF0IGhhcyByZXR1cm5lZCB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAgICAgICAgbGV0IHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8uZ2V0KGdldFRvcEVsZW1lbnQoKSk/LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBcbiAgICBjb25zdCB7IGdldEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxFPih7IG9uRWxlbWVudENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2soKGVsZW1lbnQ6IEUgfCBudWxsKSA9PiBoYW5kbGVBY3RpdmVDaGFuZ2UodHJhcEFjdGl2ZSwgZWxlbWVudCkpIH0pXG4gICAgY29uc3QgeyBnZXRMYXN0QWN0aXZlRWxlbWVudCB9ID0gdXNlQWN0aXZlRWxlbWVudCh7IGdldERvY3VtZW50OiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiBnZXRFbGVtZW50KCk/Lm93bmVyRG9jdW1lbnQhICkgfSk7XG5cblxuICAgIC8vIFdoZW4gdGhlIHRyYXAgYmVjb21lcyBhY3RpdmUsIGJlZm9yZSB3ZSBsZXQgdGhlIGJsb2NraW5nRWxlbWVudHMgaG9vayBydW4sXG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGF0ZXZlcidzIGN1cnJlbnRseSBmb2N1c2VkIGFuZCBzYXZlIGl0LlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgIGlmICh0cmFwQWN0aXZlICYmIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHRvIHdoYXRldmVyJ3MgY3VycmVudGx5IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICAgICAgICBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8uc2V0KGdldFRvcEVsZW1lbnQoKSwgKGdldExhc3RBY3RpdmVFbGVtZW50KCkgYXMgKEVsZW1lbnQgJiBIVE1MT3JTVkdFbGVtZW50KSkgPz8gZG9jdW1lbnQuYm9keSk7XG4gICAgICAgIH1cbiAgICB9LCBbdHJhcEFjdGl2ZV0pO1xuXG4gICAgdXNlQmxvY2tpbmdFbGVtZW50KHRyYXBBY3RpdmUsIGdldEVsZW1lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQW55IHRpbWUgd2UgYWN0aXZhdGUgb3IgZGVhY3RpdmF0ZSB0aGUgdHJhcCxcbiAgICAgKiBjaGFuZ2UgZm9jdXMgdG8gc29tZXRoaW5nIGVsc2UgKHNvbWV0aGluZyBpblxuICAgICAqIHRoZSB0cmFwIGlmIGl0J3MgYWN0aXZlLCBvciB3aGF0ZXZlciB3ZSd2ZVxuICAgICAqIHRyYWNrZWQgaW4gZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvIGlmIG5vdClcbiAgICAgKi9cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBoYW5kbGVBY3RpdmVDaGFuZ2UodHJhcEFjdGl2ZSwgZ2V0RWxlbWVudCgpKTtcbiAgICB9LCBbdHJhcEFjdGl2ZV0pO1xuXG4gICAgY29uc3QgdXNlRm9jdXNUcmFwUHJvcHMgPSAoKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4ge1xuICAgICAgICBjb25zdCBwMSA9IHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wcyk7XG4gICAgICAgIGNvbnN0IHAyID0geyBcImFyaWEtbW9kYWxcIjogdHJhcEFjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPihwMSwgcDIpO1xuICAgIH0pO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VGb2N1c1RyYXBQcm9wcyxcbiAgICAgICAgZ2V0RWxlbWVudFxuICAgIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgY29udGFpbmVkIHdpdGhpbiB0aGUgZ2l2ZW4gbm9kZSwgb3IgbnVsbCBpZiBub25lIGFyZSBmb3VuZC5cbiAqIEBwYXJhbSBlbGVtZW50IFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRmlyc3RGb2N1c2FibGUoZWxlbWVudDogTm9kZSkge1xuICAgIGNvbnN0IHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsZW1lbnQsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7IGFjY2VwdE5vZGU6IChub2RlKSA9PiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgaXNGb2N1c2FibGUobm9kZSkgPyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQKSB9KVxuICAgIGNvbnN0IGZpcnN0Rm9jdXNhYmxlID0gdHJlZVdhbGtlci5maXJzdENoaWxkKCkgYXMgKEVsZW1lbnQgJiBIVE1MT3JTVkdFbGVtZW50KSB8IG51bGw7XG4gICAgcmV0dXJuIGZpcnN0Rm9jdXNhYmxlO1xufVxuXG4iLCJpbXBvcnQgeyB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwsIHdoZW4gY2FsbGVkLCBmb3JjZSB0aGUgY29tcG9uZW50XG4gKiB0aGF0IHVzZXMgdGhpcyBob29rIHRvIHJlLXJlbmRlciBpdHNlbGYuXG4gKiBcbiAqIEl0J3MgYSBiaXQgc21lbGx5LCBzbyBiZXN0IHRvIHVzZSBzcGFyaW5nbHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VGb3JjZVVwZGF0ZSgpIHtcbiAgICBjb25zdCBbLCBzZXRdID0gdXNlU3RhdGUoMCk7XG4gICAgcmV0dXJuIHVzZVJlZigoKSA9PiBzZXQoaSA9PiArK2kpKS5jdXJyZW50O1xufSIsIlxyXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VDaGlsZHJlbkZsYWcsIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCwgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWFjdGl2ZS1lbGVtZW50XCI7XHJcbmltcG9ydCB7IHJldHVybkZhbHNlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgZWxlbWVudCBpdHNlbGYgY3VycmVudGx5IGhhcyBmb2N1cy5cclxuICAgICAqIFxyXG4gICAgICogYHByZXZGb2N1c2VkYCBpcyBnZW5lcmFsbHkgdGhlIG9wcG9zaXRlIG9mIGBmb2N1c2VkYCwgYnV0IG9uIG1vdW50IGl0J3MgYHVuZGVmaW5lZGAgd2hpbGUgYGZvY3VzZWRgIGlzIHByb2JhYmx5IGZhbHNlIChib3RoIGZhbHN5KVxyXG4gICAgICovXHJcbiAgICBvbkZvY3VzZWRDaGFuZ2VkPyhmb2N1c2VkOiBib29sZWFuLCBwcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaWtlIGBvbkZvY3VzZWRDaGFuZ2VkYCwgYnV0IGFsc28gKmFkZGl0aW9uYWxseSogaWYgYW55IGNoaWxkIGVsZW1lbnRzIGFyZSBmb2N1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAc2VlIHRoaXMub25Gb2N1c2VkQ2hhbmdlZFxyXG4gICAgICovXHJcbiAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbWlsYXIgdG8gYG9uRm9jdXNlZENoYW5nZWRgLCBidXQgaWYgdGhlcmUgaXMgbm8gY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCwgaXMgYHRydWVgIGlmIHRoaXMgZWxlbWVudCB0aGF0ICpkaWQqIGhhdmUgZm9jdXMgbGFzdC5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBpcyBhbHdheXMgYHRydWVgIHdoaWxlIGBmb2N1c2VkYCBpcyBgdHJ1ZWAuIElmIGBmb2N1c2VkYCBpcyBgZmFsc2VgLCB0aGlzIG1heSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgb25MYXN0Rm9jdXNlZENoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmVzIHRoZSBpbXBsaWNhdGlvbnMgb2YgYG9uRm9jdXNlZENoYW5nZWRgIGFuZCBgb25Gb2N1c2VkQ2hhbmdlZGAuXHJcbiAgICAgKi9cclxuICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNGb2N1c1JldHVyblR5cGU8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgT21pdDxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiwgXCJ1c2VSZWZFbGVtZW50UHJvcHNcIj4sIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmaWVzIHRoZSBlbGVtZW50IHRvIGJlIGFibGUgdG8gdHJhY2sgaXRzIG93biBmb2N1cyBzdGF0ZVxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIHVzZUhhc0ZvY3VzUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG5cclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEZvY3VzZWRJbm5lcigpOiBib29sZWFuO1xyXG4gICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgZ2V0TGFzdEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldExhc3RGb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhhc0ZvY3VzPFQgZXh0ZW5kcyBOb2RlPih7IG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9OiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VD4pOiBVc2VIYXNGb2N1c1JldHVyblR5cGU8VD4ge1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUhhc0ZvY3VzXCIsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0Rm9jdXNlZCwgc2V0Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25Gb2N1c2VkQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgW2dldEZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbkZvY3VzZWRJbm5lckNoYW5nZWQsIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFtnZXRMYXN0Rm9jdXNlZCwgc2V0TGFzdEZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBbZ2V0TGFzdEZvY3VzZWRJbm5lciwgc2V0TGFzdEZvY3VzZWRJbm5lcl0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfSk7XHJcblxyXG4gICAgY29uc3QgeyBnZXRBY3RpdmVFbGVtZW50LCBnZXRMYXN0QWN0aXZlRWxlbWVudCwgZ2V0V2luZG93Rm9jdXNlZCB9ID0gdXNlQWN0aXZlRWxlbWVudCh7XHJcbiAgICAgICAgZ2V0RG9jdW1lbnQsXHJcbiAgICAgICAgZ2V0V2luZG93LFxyXG4gICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8VXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnNbXCJvbkFjdGl2ZUVsZW1lbnRDaGFuZ2VcIl0+PigoYWN0aXZlRWxlbWVudCwgcHJldkFjdGl2ZUVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZkVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWQgPSAoc2VsZkVsZW1lbnQgIT0gbnVsbCAmJiAoc2VsZkVsZW1lbnQgPT0gYWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkSW5uZXIgPSAoISFzZWxmRWxlbWVudD8uY29udGFpbnMoYWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkKGZvY3VzZWQpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkSW5uZXIoZm9jdXNlZElubmVyKTtcclxuICAgICAgICAgICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlPy4oYWN0aXZlRWxlbWVudCwgcHJldkFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH0sIFtdKSxcclxuICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjazxOb25OdWxsYWJsZTxVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyc1tcIm9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2VcIl0+PigobGFzdEFjdGl2ZUVsZW1lbnQsIHByZXZMYXN0QWN0aXZlRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxmRWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXNlZCA9IChzZWxmRWxlbWVudCAhPSBudWxsICYmIChzZWxmRWxlbWVudCA9PSBsYXN0QWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkSW5uZXIgPSAoISFzZWxmRWxlbWVudD8uY29udGFpbnMobGFzdEFjdGl2ZUVsZW1lbnQgYXMgTm9kZSB8IG51bGwpKTtcclxuICAgICAgICAgICAgc2V0TGFzdEZvY3VzZWQoZm9jdXNlZCk7XHJcbiAgICAgICAgICAgIHNldExhc3RGb2N1c2VkSW5uZXIoZm9jdXNlZElubmVyKTtcclxuICAgICAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZT8uKGxhc3RBY3RpdmVFbGVtZW50LCBwcmV2TGFzdEFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH0sIFtdKSxcclxuICAgICAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2VcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUhhc0ZvY3VzUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KSA9PiB7IHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpOyB9LCBbXSk7XHJcblxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlSGFzRm9jdXNQcm9wcyxcclxuICAgICAgICBnZXRFbGVtZW50LFxyXG4gICAgICAgIGdldEZvY3VzZWQsXHJcbiAgICAgICAgZ2V0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgIGdldExhc3RGb2N1c2VkLFxyXG4gICAgICAgIGdldExhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgZ2V0QWN0aXZlRWxlbWVudCxcclxuICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudCxcclxuICAgICAgICBnZXRXaW5kb3dGb2N1c2VkXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBuZXZlcj4ge1xyXG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IHtcclxuICAgICAgICBvbkFueUdhaW5lZEZvY3VzPygpOiB2b2lkO1xyXG4gICAgICAgIG9uQWxsTG9zdEZvY3VzPygpOiB2b2lkO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxudW1iZXIsIEZvY3VzSW5mbywgbmV2ZXIsIFwic3ViSW5mb1wiPiwgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEU+IHtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+LCBcInVzZVJlZkVsZW1lbnRQcm9wc1wiPiB7XHJcbiAgICB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbn1cclxuXHJcbmludGVyZmFjZSBGb2N1c0luZm8ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88bnVtYmVyLCBGb2N1c0luZm8sIG5ldmVyPiB7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZVdpdGhIb29rcyBleHRlbmRzIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZDogPEUgZXh0ZW5kcyBFbGVtZW50PihwYXJhbWV0ZXJzOiBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczxFPikgPT4gVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFJldHVyblR5cGU8RT47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGlsZHJlbkhhdmVGb2N1cyh7IGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH06IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyk6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZVdpdGhIb29rcyB7XHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbiwgdXNlTWFuYWdlZENoaWxkIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBGb2N1c0luZm8sIG5ldmVyPih7IG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH0pO1xyXG4gICAgY29uc3QgYWxsRWxlbWVudHNSZWYgPSB1c2VSZWY8U2V0PE5vZGU+PihuZXcgU2V0KCkpO1xyXG4gICAgY29uc3QgW2dldEZvY3VzQ291bnQsIHNldEZvY3VzQ291bnRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlcj4odXNlU3RhYmxlQ2FsbGJhY2soKGFueUZvY3VzZWQ6IG51bWJlciwgYW55UHJldmlvdXNseUZvY3VzZWQ6IG51bWJlciB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBDaGFuZ2luZyBmb2N1cyBjb3VudCBmcm9tICR7YW55UHJldmlvdXNseUZvY3VzZWR9IHRvICR7YW55Rm9jdXNlZH1gKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChhbnlGb2N1c2VkID49IDAgJiYgYW55Rm9jdXNlZCA8PSAxKTtcclxuXHJcbiAgICAgICAgaWYgKGFueUZvY3VzZWQgJiYgIWFueVByZXZpb3VzbHlGb2N1c2VkKVxyXG4gICAgICAgICAgICBvbkFueUdhaW5lZEZvY3VzPy4oKTtcclxuICAgICAgICBpZiAoIWFueUZvY3VzZWQgJiYgYW55UHJldmlvdXNseUZvY3VzZWQpXHJcbiAgICAgICAgICAgIG9uQWxsTG9zdEZvY3VzPy4oKTtcclxuICAgIH0pKTtcclxuXHJcbiAgICBjb25zdCB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkID0gdXNlQ2FsbGJhY2soPEUgZXh0ZW5kcyBFbGVtZW50Pih7IG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50LCBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9IH06IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQYXJhbWV0ZXJzPEU+KTogVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFJldHVyblR5cGU8RT4gPT4ge1xyXG4gICAgICAgIHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgc3ViSW5mbzoge30sIGZsYWdzIH0gfSk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VIYXNGb2N1czxFPih7XHJcbiAgICAgICAgICAgIGdldERvY3VtZW50LFxyXG4gICAgICAgICAgICBnZXRXaW5kb3csXHJcbiAgICAgICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZSxcclxuICAgICAgICAgICAgb25FbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoZTogRSB8IG51bGwsIHByZXY6IEUgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgciA9IG9uRWxlbWVudENoYW5nZT8uKGUsIHByZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxFbGVtZW50c1JlZi5jdXJyZW50LmFkZChlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByPy4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRWxlbWVudHNSZWYuY3VycmVudC5kZWxldGUoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBbb25FbGVtZW50Q2hhbmdlXSksXHJcbiAgICAgICAgICAgIG9uTW91bnQsXHJcbiAgICAgICAgICAgIG9uVW5tb3VudCxcclxuICAgICAgICAgICAgb25Gb2N1c2VkQ2hhbmdlZCxcclxuICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLFxyXG4gICAgICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLFxyXG4gICAgICAgICAgICBvbkxhc3RGb2N1c2VkQ2hhbmdlZCxcclxuICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENoaWxkICR7aW5kZXh9IGlzIGZvY3VzZWRgKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRGb2N1c0NvdW50KHAgPT4gKHAgPz8gMCkgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFmb2N1c2VkICYmIHByZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ2hpbGQgJHtpbmRleH0gaXMgdW5mb2N1c2VkYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Rm9jdXNDb3VudChwID0+IChwID8/IDApIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZD8uKGZvY3VzZWQsIHByZXYpO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQcm9wczogdXNlSGFzRm9jdXNQcm9wcyxcclxuICAgICAgICAgICAgZ2V0RWxlbWVudFxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcclxuICAgICAgICB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWxlbWVudFNpemUsIHVzZUVsZW1lbnRTaXplIH0gZnJvbSBcIi4vdXNlLWVsZW1lbnQtc2l6ZVwiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xuXG4vL2V4cG9ydCB0eXBlIEJsb2NrRmxvd0RpcmVjdGlvbiA9IFwiZG93bndhcmRzXCIgfCBcImxlZnR3YXJkc1wiIHwgXCJyaWdodHdhcmRzXCI7XG5leHBvcnQgdHlwZSBQaHlzaWNhbERpcmVjdGlvbiA9IFwibHRyXCIgfCBcInJ0bFwiIHwgXCJ0dGJcIiB8IFwiYnR0XCI7XG5leHBvcnQgdHlwZSBQaHlzaWNhbE9yaWVudGF0aW9uID0gXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCI7XG5leHBvcnQgdHlwZSBQaHlzaWNhbFNpemUgPSBcIndpZHRoXCIgfCBcImhlaWdodFwiO1xuXG5leHBvcnQgdHlwZSBMb2dpY2FsT3JpZW50YXRpb24gPSBcImlubGluZVwiIHwgXCJibG9ja1wiO1xuXG4vL2V4cG9ydCB0eXBlIExpbmVPcmllbnRhdGlvbiA9IFwidXByaWdodFwiIHwgXCJsZWZ0cmlnaHRcIiB8IFwiZG93bnJpZ2h0XCIgfCBcInJpZ2h0cmlnaHRcIjtcblxudHlwZSBXcml0aW5nTW9kZSA9IFwiaG9yaXpvbnRhbC10YlwiIHwgXCJ2ZXJ0aWNhbC1sclwiIHwgXCJzaWRld2F5cy1ybFwiIHwgXCJ2ZXJ0aWNhbC1ybFwiIHwgXCJzaWRld2F5cy1sclwiO1xudHlwZSBEaXJlY3Rpb24gPSBcImx0clwiIHwgXCJydGxcIjtcbnR5cGUgVGV4dE9yaWVudGF0aW9uID0gXCJtaXhlZFwiIHwgXCJ1cHJpZ2h0XCIgfCBcInNpZGV3YXlzXCI7XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemU8VCBleHRlbmRzIHN0cmluZz4oc3RyOiBUKTogQ2FwaXRhbGl6ZTxUPiB7XG4gICAgcmV0dXJuIChzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSkpIGFzIENhcGl0YWxpemU8VD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTG9naWNhbERpcmVjdGlvblBhcmFtZXRlcnMge1xuICAgIG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZT8oaW5mbzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dpY2FsRWxlbWVudFNpemUge1xuICAgIGNsaWVudElubGluZVNpemU6IG51bWJlcjtcbiAgICBzY3JvbGxJbmxpbmVTaXplOiBudW1iZXI7XG4gICAgb2Zmc2V0SW5saW5lU2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNsaWVudEJsb2NrU2l6ZTogbnVtYmVyO1xuICAgIHNjcm9sbEJsb2NrU2l6ZTogbnVtYmVyO1xuICAgIG9mZnNldEJsb2NrU2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNsaWVudElubGluZUluc2V0OiBudW1iZXI7XG4gICAgc2Nyb2xsSW5saW5lSW5zZXQ6IG51bWJlcjtcbiAgICBvZmZzZXRJbmxpbmVJbnNldDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNsaWVudEJsb2NrSW5zZXQ6IG51bWJlcjtcbiAgICBzY3JvbGxCbG9ja0luc2V0OiBudW1iZXI7XG4gICAgb2Zmc2V0QmxvY2tJbnNldDogbnVtYmVyIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEluc3BlY3RzIHRoZSBlbGVtZW50J3Mgc3R5bGUgYW5kIGRldGVybWluZXMgdGhlIGxvZ2ljYWwgZGlyZWN0aW9uIHRoYXQgdGV4dCBmbG93cy5cbiAqIFxuICogQ2VydGFpbiBDU1MgcHJvcGVydGllcywgbGlrZSBgYmxvY2stc2l6ZWAsIHJlc3BlY3QgdGhlIGN1cnJlbnQgd3JpdGluZyBtb2RlIGFuZCB0ZXh0IGRpcmVjdGlvbi5cbiAqIEJ1dCBgdHJhbnNmb3JtYCwgYGNsaXBgLCBldGMuIGRvbid0LlxuICogXG4gKiBUaGlzIGlzIHByb3ZpZGVkIHNvIHRoYXQgQ1NTIHByb3BlcnRpZXMgY2FuIGNvbnNpc3RlbnRseSB1c2UgdGhvc2UgbG9naWNhbCBwcm9wZXJ0aWVzLlxuICogXG4gKiBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy13cml0aW5nLW1vZGVzLyNsb2dpY2FsLXRvLXBoeXNpY2FsXG4gKiBcbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICogKiBgZ2V0TG9naWNhbERpcmVjdGlvbmA6IHJldHJpZXZlcyBhIGBMb2dpY2FsRGlyZWN0aW9uSW5mb2AgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50LiAoRnVuY3Rpb24gaXMgY29uc3RhbnQgYmV0d2VlbiByZW5kZXJzKVxuICogKiBgY29udmVydEVsZW1lbnRTaXplYDogV2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUVsZW1lbnRTaXplYCwgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSB0aGUgbG9naWNhbCBzaXplIG9mIGFuIGVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgcGh5c2ljYWwgc2l6ZS4gXG4gKiAqIGBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb25gOiBCYXNlZCBvbiB0aGUgY3VycmVudCBkaXJlY3Rpb24sIGNvbnZlcnRzIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIiB0byBcImlubGluZVwiIG9yIFwiYmxvY2tcIi5cbiAqICogYGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb25gOiAgQmFzZWQgb24gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBjb252ZXJ0cyBcImlubGluZVwiIG9yIFwiYmxvY2tcIiB0byBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2dpY2FsRGlyZWN0aW9uPFQgZXh0ZW5kcyBFbGVtZW50Pih7IG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZSB9OiBVc2VMb2dpY2FsRGlyZWN0aW9uUGFyYW1ldGVycyk6IFVzZUxvZ2ljYWxEaXJlY3Rpb25SZXR1cm5UeXBlPFQ+IHtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUxvZ2ljYWxEaXJlY3Rpb25cIiwgb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlKTtcblxuICAgIGNvbnN0IFtnZXRDb21wdXRlZFN0eWxlcywgc2V0Q29tcHV0ZWRTdHlsZXNdID0gdXNlUGFzc2l2ZVN0YXRlPENTU1N0eWxlRGVjbGFyYXRpb24gfCBudWxsPihudWxsLCByZXR1cm5OdWxsKTtcblxuXG4gICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8VD4oe1xuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlbGVtZW50OiBUIHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRDb21wdXRlZFN0eWxlcyh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKVxuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gcmVmcmVzaCB3aGljaCB3cml0aW5nIG1vZGUgd2UgaGF2ZSBvbmNlIG1vdW50ZWQuXG4gICAgLy8gICBBLiBUaGVyZSdzIG5vIHdheSB0byB3YXRjaCBmb3IgQ1NTIHN0eWxlIGNoYW5nZXNcbiAgICAvLyAgIEIuIENhbGxpbmcgZ2V0Q29tcHV0ZWRTdHlsZSBhZnRlciBldmVyeSByZW5kZXIgZm9yIGV2ZXJ5IGVsZW1lbnQgZ2V0cyBleHBlbnNpdmUgZmFzdCBhbmRcbiAgICAvLyAgIEMuIElzIG5vdCBuZWNlc3NhcnkgZm9yIG1vc3QgdXNlIGNhc2VzIHRoYXQgd2lsbCBuZXZlciBzd2l0Y2ggd3JpdGluZy1tb2RlIHdpdGhpbiBhIHNpbmdsZSBjb21wb25lbnRcbiAgICAvLyAgICAgIChUaG9zZSB0aGF0IGRvIHdpbGwgbmVlZCB0byBtb3VudCBhbmQgdW5tb3VudCB0aGUgY29tcG9uZW50IHRoYXQgdXNlcyBpdClcbiAgICAvL1xuICAgIC8vIEFzIGEgc29sdXRpb24sIGhlcmUncyBhIGNoZWFwIHdvcmthcm91bmQgdGhhdCBjaGVja3Mgd2hlbiB0aGUgZWxlbWVudCdzIHNpemUgaGFzIGNoYW5nZWQsXG4gICAgLy8gYW5kIGlmIHNvLCB0ZXN0cyBpZiB0aGUgd3JpdGluZyBtb2RlIGhhcyBjaGFuZ2VkIHRvby5cbiAgICAvL1xuICAgIC8vIFRoaXMgd2lsbCB3b3JrIGZvciBhdCBsZWFzdCBzb21lIG51bWJlciBvZiBjYXNlcywgYnV0IGEgYmV0dGVyIHNvbHV0aW9uIGlzIHN0aWxsIG5lZWRlZC5cbiAgICBjb25zdCB7IHVzZUVsZW1lbnRTaXplUHJvcHMgfSA9IHVzZUVsZW1lbnRTaXplPFQ+KHsgb25TaXplQ2hhbmdlOiB1c2VDYWxsYmFjayhfID0+IG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZT8uKGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCkpLCBbXSkgfSlcblxuICAgIGNvbnN0IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGVzKCk7XG4gICAgICAgIGlmIChjb21wdXRlZFN0eWxlcykge1xuICAgICAgICAgICAgY29uc3QgdyA9IGNvbXB1dGVkU3R5bGVzLndyaXRpbmdNb2RlIGFzIFdyaXRpbmdNb2RlO1xuICAgICAgICAgICAgbGV0IGQgPSBjb21wdXRlZFN0eWxlcy5kaXJlY3Rpb24gYXMgRGlyZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgdCA9IGNvbXB1dGVkU3R5bGVzLnRleHRPcmllbnRhdGlvbiBhcyBUZXh0T3JpZW50YXRpb247XG5cbiAgICAgICAgICAgIGlmICh0ID09IFwidXByaWdodFwiKVxuICAgICAgICAgICAgICAgIGQgPSBcImx0clwiO1xuXG4gICAgICAgICAgICByZXR1cm4gKHsgLi4uV3JpdGluZ01vZGVzW3cgfHwgXCJob3Jpem9udGFsLXRiXCJdW2QgfHwgXCJsdHJcIl0gfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCBbXSlcblxuICAgIC8vY29uc3QgW2dldExvZ2ljYWxEaXJlY3Rpb25JbmZvLCBzZXRMb2dpY2FsRGlyZWN0aW9uSW5mb10gPSB1c2VQYXNzaXZlU3RhdGU8TG9naWNhbERpcmVjdGlvbkluZm8+KG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZSk7XG5cbiAgICBjb25zdCBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb24gPSB1c2VDYWxsYmFjaygoZWxlbWVudE9yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gZWxlbWVudE9yaWVudGF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIFwiaW5saW5lXCI7XG4gICAgICAgIHJldHVybiBcImJsb2NrXCI7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgY29udmVydFRvUGh5c2ljYWxTaWRlID0gdXNlQ2FsbGJhY2soKHNpZGU6IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcIiB8IFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIgPT4ge1xuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XG5cbiAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stc3RhcnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5ibG9ja0RpcmVjdGlvbiA/PyBcInR0YlwiKVswXSBhcyBcInRcIiB8IFwiYlwiIHwgXCJsXCIgfCBcInJcIl07XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uYmxvY2tEaXJlY3Rpb24gPz8gXCJ0dGJcIilbMl0gYXMgXCJ0XCIgfCBcImJcIiB8IFwibFwiIHwgXCJyXCJdO1xuXG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uaW5saW5lRGlyZWN0aW9uID8/IFwibHRyXCIpWzBdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uaW5saW5lRGlyZWN0aW9uID8/IFwibHRyXCIpWzJdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgY29udmVydFRvTG9naWNhbFNpZGUgPSB1c2VDYWxsYmFjaygoc2lkZTogXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKTogXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiIHwgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIiA9PiB7XG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJ0dGJcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uaW5saW5lRGlyZWN0aW9uID09PSBcImJ0dFwiID8gXCJpbmxpbmUtc3RhcnRcIiA6IFwiaW5saW5lLWVuZFwiO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uYmxvY2tEaXJlY3Rpb24gPT09IFwicnRsXCIgPyBcImJsb2NrLXN0YXJ0XCIgOiBcImJsb2NrLWVuZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uYmxvY2tEaXJlY3Rpb24gPT09IFwidHRiXCIgPyBcImJsb2NrLXN0YXJ0XCIgOiBcImJsb2NrLWVuZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJidHRcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5pbmxpbmVEaXJlY3Rpb24gPT09IFwicnRsXCIgPyBcImlubGluZS1zdGFydFwiIDogXCJpbmxpbmUtZW5kXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UpO1xuICAgICAgICByZXR1cm4gXCJpbmxpbmUtc3RhcnRcIjtcblxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbiA9IHVzZUNhbGxiYWNrKChlbGVtZW50T3JpZW50YXRpb246IExvZ2ljYWxPcmllbnRhdGlvbiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgaWYgKGVsZW1lbnRPcmllbnRhdGlvbiA9PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PSBcImhvcml6b250YWxcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbj8uYmxvY2tPcmllbnRhdGlvbiA9PSBcInZlcnRpY2FsXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcblxuICAgICAgICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgY29udmVydEVsZW1lbnRTaXplID0gdXNlQ2FsbGJhY2soKGVsZW1lbnRTaXplOiBFbGVtZW50U2l6ZSwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKTogTG9naWNhbEVsZW1lbnRTaXplIHwgbnVsbCA9PiB7XG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgeyBpbmxpbmVTaXplLCBibG9ja1NpemUsIGlubGluZURpcmVjdGlvbiwgYmxvY2tEaXJlY3Rpb24gfSA9IGRpcmVjdGlvbjtcblxuICAgICAgICAgICAgLy8gU2l6ZSBpcyByZWxhdGl2ZWx5IHNpbXBsZVxuICAgICAgICAgICAgY29uc3QgY2xpZW50SW5saW5lU2l6ZSA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoaW5saW5lU2l6ZSl9YF07XG4gICAgICAgICAgICBjb25zdCBjbGllbnRCbG9ja1NpemUgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGJsb2NrU2l6ZSl9YF07XG5cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldElubGluZVNpemUgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGlubGluZVNpemUpfWBdO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0QmxvY2tTaXplID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShibG9ja1NpemUpfWBdO1xuXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxJbmxpbmVTaXplID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShpbmxpbmVTaXplKX1gXTtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEJsb2NrU2l6ZSA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoYmxvY2tTaXplKX1gXTtcblxuXG5cblxuICAgICAgICAgICAgY29uc3QgZjEgPSBnZXRQaHlzaWNhbExlZnRUb3AoaW5saW5lRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGYyID0gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShpbmxpbmVEaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBjb25zdCBmMyA9IGdldFBoeXNpY2FsTGVmdFRvcChibG9ja0RpcmVjdGlvbik7XG4gICAgICAgICAgICBjb25zdCBmNCA9IGdldFBoeXNpY2FsUmlnaHRCb3R0b20oYmxvY2tEaXJlY3Rpb24pO1xuXG5cbiAgICAgICAgICAgY29uc3QgY2xpZW50SW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGYxKX1gXSArICghZjIgPyAwIDogZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmMil9YF0pO1xuICAgICAgICAgICBjb25zdCBzY3JvbGxJbmxpbmVJbnNldCA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjEpfWBdICsgKCFmMiA/IDAgOiBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGYyKX1gXSk7XG4gICAgICAgICAgIGNvbnN0IG9mZnNldElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMSl9YF0gPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogKGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjEpfWBdISArICghZjIgPyAwIDogZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMil9YF0hKSk7XG5cblxuICAgICAgICAgICAgY29uc3QgY2xpZW50QmxvY2tJbnNldCA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjMpfWBdICsgKCFmNCA/IDAgOiBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGY0KX1gXSk7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMyl9YF0gKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjQpfWBdKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldEJsb2NrSW5zZXQgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYzKX1gXSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAoZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMyl9YF0hICsgKCFmNCA/IDAgOiBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGY0KX1gXSEpKTtcblxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsaWVudElubGluZVNpemUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW5saW5lU2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRJbmxpbmVTaXplLFxuICAgICAgICAgICAgICAgIGNsaWVudEJsb2NrU2l6ZSxcbiAgICAgICAgICAgICAgICBzY3JvbGxCbG9ja1NpemUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0QmxvY2tTaXplLFxuICAgICAgICAgICAgICAgIGNsaWVudElubGluZUluc2V0LFxuICAgICAgICAgICAgICAgIHNjcm9sbElubGluZUluc2V0LFxuICAgICAgICAgICAgICAgIG9mZnNldElubGluZUluc2V0LFxuICAgICAgICAgICAgICAgIGNsaWVudEJsb2NrSW5zZXQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsQmxvY2tJbnNldCxcbiAgICAgICAgICAgICAgICBvZmZzZXRCbG9ja0luc2V0LFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHM6IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VFbGVtZW50U2l6ZVByb3BzKHByb3BzKSksIFtdKSxcbiAgICAgICAgZ2V0RWxlbWVudCxcbiAgICAgICAgZ2V0TG9naWNhbERpcmVjdGlvbkluZm8sXG4gICAgICAgIGNvbnZlcnRUb0xvZ2ljYWxTaXplOiBjb252ZXJ0RWxlbWVudFNpemUsXG4gICAgICAgIGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbixcbiAgICAgICAgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbixcbiAgICAgICAgY29udmVydFRvTG9naWNhbFNpZGUsXG4gICAgICAgIGNvbnZlcnRUb1BoeXNpY2FsU2lkZVxuICAgIH07XG59XG5cbi8vIFBvc2l0aW9uIHJlcXVpcmVzIHVzIHRvIHNvbWV0aW1lcyB1c2Ugb25lIHByb3BlcnR5IChsaWtlIGBsZWZ0YClcbi8vIG9yIHNvbWV0aW1lcyB0d28gKGxpa2UgYGxlZnRgICsgYHdpZHRoYClcbmZ1bmN0aW9uIGdldFBoeXNpY2FsTGVmdFRvcChkaXI6IFBoeXNpY2FsRGlyZWN0aW9uKSB7IGlmIChkaXIgPT09IFwibHRyXCIgfHwgZGlyID09IFwicnRsXCIpIHJldHVybiBcImxlZnRcIjsgcmV0dXJuIFwidG9wXCI7IH1cbmZ1bmN0aW9uIGdldFBoeXNpY2FsUmlnaHRCb3R0b20oZGlyOiBQaHlzaWNhbERpcmVjdGlvbikgeyBpZiAoZGlyID09PSBcInJ0bFwiKSByZXR1cm4gXCJ3aWR0aFwiOyBpZiAoZGlyID09PSBcImJ0dFwiKSByZXR1cm4gXCJoZWlnaHRcIjsgcmV0dXJuIG51bGw7IH1cblxuLy8gSGVscGVyIGZvciBleHRyYWN0aW5nIGluZm8gZnJvbSBcImx0clwiLCBcInR0YlwiLCBldGMuXG5jb25zdCBNID0ge1xuICAgIHQ6IFwidG9wXCIsXG4gICAgYjogXCJib3R0b21cIixcbiAgICBsOiBcImxlZnRcIixcbiAgICByOiBcInJpZ2h0XCJcbn0gYXMgY29uc3Q7XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMb2dpY2FsRGlyZWN0aW9uUmV0dXJuVHlwZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRFbGVtZW50OiAoKSA9PiBUIHwgbnVsbDtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvOiAoKSA9PiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgRWxlbWVudFNpemUgaW5mbyBmcm9tIHVzZUVsZW1lbnRTaXplLCBjb252ZXJ0cyBhbGwgdGhvc2UgcGh5c2ljYWwgcHJvcGVydGllcyB0byB0aGVpciBsb2dpY2FsIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgY29udmVydFRvTG9naWNhbFNpemU6IChlbGVtZW50U2l6ZTogRWxlbWVudFNpemUsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gTG9naWNhbEVsZW1lbnRTaXplIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIGBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcImAgaW50byBgXCJpbmxpbmVcIiB8IFwiYmxvY2tcImBcbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uOiAoZWxlbWVudE9yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaW5saW5lXCIgfCBcImJsb2NrXCI7XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBgXCJpbmxpbmVcIiB8IFwiYmxvY2tcImAgaW50byBgXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCJgXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb246IChlbGVtZW50T3JpZW50YXRpb246IExvZ2ljYWxPcmllbnRhdGlvbiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIjtcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIGBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiYCBpbnRvIGBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiIHwgXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiYFxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBjb252ZXJ0VG9Mb2dpY2FsU2lkZTogKHNpZGU6IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiIHwgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIjtcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIGBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiIHwgXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiYCBpbnRvIGBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiYFxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBjb252ZXJ0VG9QaHlzaWNhbFNpZGU6IChzaWRlOiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCI7XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2ljYWxEaXJlY3Rpb25JbmZvIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBkaXJlY3Rpb24gdGV4dCBmbG93cywgZ2x5cGggYnkgZ2x5cGguICBCeSBmYXIgdGhlIG1vc3QgY29tcGxleCBwcm9wZXJ0eS5cbiAgICAgKiBcbiAgICAgKiB8YHdyaXRpbmctbW9kZWB8YGRpcmVjdGlvbmB8UmVzdWx0fFxuICAgICAqIHwtLS0tLXwtLS0tLXwtLS0tLXxcbiAgICAgKiB8YGhvcml6b250YWwtdGJgfGBsdHJgfGBsdHJgfFxuICAgICAqIHxgaG9yaXpvbnRhbC10YmB8YHJ0bGB8YHJ0bGB8XG4gICAgICogfGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgfGBsdHJgfGB0dGJgfFxuICAgICAqIHxgdmVydGljYWwtcmxgICYgYHNpZGV3YXlzLXJsYHxgcnRsYHxgYnR0YHxcbiAgICAgKiB8YHZlcnRpY2FsLWxyYHxgbHRyYHxgdHRiYHxcbiAgICAgKiB8YHZlcnRpY2FsLWxyYHxgcnRsYHxgYnR0YHxcbiAgICAgKiB8YHNpZGV3YXlzLWxyYHxgbHRyYHxgYnR0YHxcbiAgICAgKiB8YHNpZGV3YXlzLWxyYHxgcnRsYHxgdHRiYHxcbiAgICAgKi9cbiAgICBpbmxpbmVEaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU2ltcGxpZmllZCB2ZXJzaW9uIG9mIGBpbmxpbmVEaXJlY3Rpb25gOlxuICAgICAqIFxuICAgICAqICogYGhvcml6b250YWxgIGZvciBgaG9yaXpvbnRhbC10YmBcbiAgICAgKiAqIGB2ZXJ0aWNhbGAgZm9yIGFsbCBvdGhlcnNcbiAgICAgKi9cbiAgICBpbmxpbmVPcmllbnRhdGlvbjogUGh5c2ljYWxPcmllbnRhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGRpcmVjdGlvbiB0ZXh0IGZsb3dzLCBsaW5lIGJ5IGxpbmUuXG4gICAgICogXG4gICAgICogKiBgdHRiYCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYHJ0bGAgZm9yIGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYGx0cmAgZm9yIGB2ZXJ0aWNhbC1scmAgJiBgc2lkZXdheXMtbHJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqL1xuICAgIGJsb2NrRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFNpbXBsaWZpZWQgdmVyc2lvbiBvZiBgYmxvY2tEaXJlY3Rpb25gOlxuICAgICAqIFxuICAgICAqICogYHZlcnRpY2FsYCBmb3IgYGhvcml6b250YWwtdGJgXG4gICAgICogKiBgaG9yaXpvbnRhbGAgZm9yIGFsbCBvdGhlcnNcbiAgICAgKi9cbiAgICBibG9ja09yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBob3cgeW91IGNhbiAqcGh5c2ljYWxseSogcmVmZXIgdG8gdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgaW4gdGhlICppbmxpbmUqIHNpemUuXG4gICAgICogXG4gICAgICogKiBgd2lkdGhgIGZvciBgaG9yaXpvbnRhbC10YmAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXG4gICAgICogKiBgaGVpZ2h0YCBmb3IgYWxsIG90aGVyc1xuICAgICAqL1xuICAgIGlubGluZVNpemU6IFBoeXNpY2FsU2l6ZTtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgaG93IHlvdSBjYW4gKnBoeXNpY2FsbHkqIHJlZmVyIHRvIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IGluIHRoZSAqYmxvY2sqIHNpemUuXG4gICAgICogXG4gICAgICogKiBgaGVpZ2h0YCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYHdpZHRoYCBmb3IgYWxsIG90aGVyc1xuICAgICAqL1xuICAgIGJsb2NrU2l6ZTogUGh5c2ljYWxTaXplO1xuXG4gICAgLyoqXG4gICAgICogRm9yIGVhY2ggZ2x5cGgsIGFzY2VuZGVycyB0byBkZXNjZW5kZXJzICpwaHlzaWNhbGx5KiBnbzpcbiAgICAgKiBcbiAgICAgKiAqIGB0dGJgIGZvciBgaG9yaXpvbnRhbC10YmBcbiAgICAgKiAqIGBydGxgIGZvciBgdmVydGljYWwtcmxgLCBgdmVydGljYWwtbHJgLCAmIGBzaWRld2F5cy1ybGBcbiAgICAgKiAqIGBsdHJgIGZvciBgc2lkZXdheXMtbHJgXG4gICAgICovXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEZvciBlYWNoIGdseXBoLCBpdHMgXCJsZWZ0XCIgc2lkZSAodGhpbmsgb2YgdGhpcyByZWxhdGl2ZSB0byBgd3JpdGluZy1tb2RlYCBidXQgKm5vdCogcmVsYXRpdmUgdG8gYGRpcmVjdGlvbmAsIG9yIGFsdGVybmF0aXZlbHkgd2hhdCBgdGV4dC1hbGlnbjogbGVmdGAgbWVhbnMpIHRvIGl0cyBcInJpZ2h0XCIgc2lkZSAqcGh5c2ljYWxseSogZ29lcyBmcm9tOlxuICAgICAqIFxuICAgICAqICogYGx0cmAgZm9yIGBob3Jpem9udGFsLXRiYFxuICAgICAqICogYHR0YmAgZm9yIGB2ZXJ0aWNhbC1ybGAsIGB2ZXJ0aWNhbC1scmAsICYgYHNpZGV3YXlzLXJsYFxuICAgICAqICogYGJ0dGAgZm9yIGBzaWRld2F5cy1scmBcbiAgICAgKi9cbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xufVxuXG5jb25zdCBIb3Jpem9udGFsVGJMdHI6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIGlubGluZURpcmVjdGlvbjogXCJsdHJcIixcbiAgICBibG9ja0RpcmVjdGlvbjogXCJ0dGJcIixcblxuICAgIGlubGluZU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICBibG9ja09yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXG5cbiAgICBpbmxpbmVTaXplOiBcIndpZHRoXCIsXG4gICAgYmxvY2tTaXplOiBcImhlaWdodFwiLFxuXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcImx0clwiLFxuICAgIG92ZXJVbmRlckRpcmVjdGlvbjogXCJ0dGJcIlxufTtcblxuY29uc3QgSG9yaXpvbnRhbFRiUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5Ib3Jpem9udGFsVGJMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInJ0bFwiLFxufTtcblxuY29uc3QgVmVydGljYWxSbEx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiLFxuICAgIGJsb2NrRGlyZWN0aW9uOiBcInJ0bFwiLFxuXG4gICAgaW5saW5lT3JpZW50YXRpb246IFwidmVydGljYWxcIixcbiAgICBibG9ja09yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcblxuICAgIGlubGluZVNpemU6IFwiaGVpZ2h0XCIsXG4gICAgYmxvY2tTaXplOiBcIndpZHRoXCIsXG5cbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwidHRiXCIsXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcInJ0bFwiXG59O1xuXG5jb25zdCBWZXJ0aWNhbFJsUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5WZXJ0aWNhbFJsTHRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIlxufTtcblxuXG5jb25zdCBTaWRld2F5c1JsTHRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHsgLi4uVmVydGljYWxSbEx0ciB9O1xuY29uc3QgU2lkZXdheXNSbFJ0bDogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7IC4uLlZlcnRpY2FsUmxSdGwgfTtcblxuY29uc3QgVmVydGljYWxMckx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgLi4uVmVydGljYWxSbEx0cixcbiAgICBibG9ja0RpcmVjdGlvbjogXCJsdHJcIixcbn07XG5cbmNvbnN0IFZlcnRpY2FsTHJSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLlZlcnRpY2FsUmxSdGwsXG4gICAgYmxvY2tEaXJlY3Rpb246IFwibHRyXCIsXG59O1xuXG5jb25zdCBTaWRld2F5c0x0THRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5WZXJ0aWNhbExyTHRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIixcblxuICAgIGxlZnRSaWdodERpcmVjdGlvbjogXCJidHRcIixcbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFwibHRyXCJcbn07XG5cbmNvbnN0IFNpZGV3YXlzTHRSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLlNpZGV3YXlzTHRMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiXG59O1xuXG5cblxuY29uc3QgSG9yaXpvbnRhbFRiID0ge1xuICAgIGx0cjogSG9yaXpvbnRhbFRiTHRyLFxuICAgIHJ0bDogSG9yaXpvbnRhbFRiUnRsXG59IGFzIGNvbnN0O1xuXG5jb25zdCBWZXJ0aWNhbFJsID0ge1xuICAgIGx0cjogVmVydGljYWxSbEx0cixcbiAgICBydGw6IFZlcnRpY2FsUmxSdGxcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IFZlcnRpY2FsTHIgPSB7XG4gICAgbHRyOiBWZXJ0aWNhbExyTHRyLFxuICAgIHJ0bDogVmVydGljYWxMclJ0bFxufSBhcyBjb25zdDtcblxuY29uc3QgU2lkZXdheXNSbCA9IHtcbiAgICBsdHI6IFNpZGV3YXlzUmxMdHIsXG4gICAgcnRsOiBTaWRld2F5c1JsUnRsXG59IGFzIGNvbnN0O1xuXG5jb25zdCBTaWRld2F5c0xyID0ge1xuICAgIGx0cjogU2lkZXdheXNMdEx0cixcbiAgICBydGw6IFNpZGV3YXlzTHRSdGxcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IFdyaXRpbmdNb2RlcyA9IHtcbiAgICBcImhvcml6b250YWwtdGJcIjogSG9yaXpvbnRhbFRiLFxuICAgIFwidmVydGljYWwtbHJcIjogVmVydGljYWxMcixcbiAgICBcInZlcnRpY2FsLXJsXCI6IFZlcnRpY2FsUmwsXG4gICAgXCJzaWRld2F5cy1sclwiOiBTaWRld2F5c0xyLFxuICAgIFwic2lkZXdheXMtcmxcIjogU2lkZXdheXNSbFxufSBhcyBjb25zdDtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUaW1lb3V0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2AuICBcbiAgICAgKiBJZiBgbnVsbGAsIGNhbmNlbHMgdGhlIHRpbWVvdXQgaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgdGltZW91dDogbnVtYmVyIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdG8gdGhpcyBwcm9wIGJldHdlZW4gcmVuZGVycyBjYW4gYmUgdXNlZCB0byBjbGVhciB0aGUgY3VycmVudCB0aW1lb3V0IGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqL1xuICAgIHRyaWdnZXJJbmRleD86IHVua25vd247XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYHRpbWVvdXRgIG1zIGFmdGVyIG1vdW50LCBvciB0aGUgbGFzdCBjaGFuZ2UgdG8gYHRyaWdnZXJJbmRleGAuXG4gICAgICogXG4gICAgICogRG9lcyAqbm90KiBuZWVkIHRvIGJlIHN0YWJsZS4gR28gYWhlYWQgYW5kIHBhc3MgYW4gYW5vbnltb3VzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVGltZW91dCh7IHRpbWVvdXQsIGNhbGxiYWNrLCB0cmlnZ2VySW5kZXggfTogVXNlVGltZW91dCkge1xuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBzdGFydFRpbWVSZWYuY3VycmVudCA9IG51bGw7IGNhbGxiYWNrKCk7IH0pO1xuICAgIGNvbnN0IGdldFRpbWVvdXQgPSB1c2VTdGFibGVHZXR0ZXIodGltZW91dCk7XG5cbiAgICAvLyBTZXQgYW55IHRpbWUgd2Ugc3RhcnQgdGltZW91dC5cbiAgICAvLyBVbnNldCBhbnkgdGltZSB0aGUgdGltZW91dCBjb21wbGV0ZXNcbiAgICBjb25zdCBzdGFydFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCB0aW1lb3V0SXNOdWxsID0gKHRpbWVvdXQgPT0gbnVsbCk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgdHJpZ2dlckluZGV4IGNoYW5nZXMgKGluY2x1ZGluZyBvbiBtb3VudClcbiAgICAvLyByZXN0YXJ0IHRoZSB0aW1lb3V0LiAgVGhlIHRpbWVvdXQgZG9lcyBOT1QgcmVzZXRcbiAgICAvLyB3aGVuIHRoZSBkdXJhdGlvbiBvciBjYWxsYmFjayBjaGFuZ2VzLCBvbmx5IHRyaWdnZXJJbmRleC5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRpbWVvdXRJc051bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aW1lb3V0SXNOdWxsID09ICh0aW1lb3V0ID09IG51bGwpKTtcbiAgICBcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVSZWYuY3VycmVudCA9ICsobmV3IERhdGUoKSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChzdGFibGVDYWxsYmFjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sIFt0cmlnZ2VySW5kZXgsIHRpbWVvdXRJc051bGxdKVxuXG4gICAgY29uc3QgZ2V0RWxhcHNlZFRpbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKyhuZXcgRGF0ZSgpKSkgLSAoKyhzdGFydFRpbWVSZWYuY3VycmVudCA/PyBuZXcgRGF0ZSgpKSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0UmVtYWluaW5nVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgcmV0dXJuIHRpbWVvdXQgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1heCgwLCB0aW1lb3V0IC0gZ2V0RWxhcHNlZFRpbWUoKSlcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyBnZXRFbGFwc2VkVGltZSwgZ2V0UmVtYWluaW5nVGltZSB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VMb2dpY2FsRGlyZWN0aW9uIH0gZnJvbSBcIi4vdXNlLWxvZ2ljYWwtZGlyZWN0aW9uXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VUaW1lb3V0IH0gZnJvbSBcIi4vdXNlLXRpbWVvdXRcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIGxpbmVhck5hdmlnYXRpb246IHt9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqIFxuICAgICAqIFRoZXNlIHByb3BzIGNhbiBiZSBhdHRhdGNoZWQgZWl0aGVyIHRvIHRoZSBwYXJlbnQgb3IgdG8gZWFjaCBpbmRpdmlkdWFsIGNoaWxkLlxuICAgICAqIFdoaWNoZXZlciB3b3JrcyBiZXR0ZXIgZm9yIHlvdXIgc2NlbmFyaW8uXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKiBcbiAgICAgKiAqL1xuICAgIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pjtcbn1cblxuaW50ZXJmYWNlIExOUCB7XG4gICAgbmF2aWdhdGVUb05leHQoKTogdm9pZDtcbiAgICBuYXZpZ2F0ZVRvUHJldigpOiB2b2lkO1xuICAgIG5hdmlnYXRlVG9GaXJzdCgpOiB2b2lkO1xuICAgIG5hdmlnYXRlVG9MYXN0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hpY2ggYXJyb3cga2V5cyBhcmUgdXNlZCB0byBuYXZpZ2F0ZSB0aHJvdWdoIHRoZSBjb21wb25lbnQuXG4gICAgICogUmVsYXRpdmUgdG8gdGhlIHdyaXRpbmcgbW9kZSwgc28gaW4gRW5nbGlzaCwgXCJpbmxpbmVcIiBjb3JyZXNwb25kc1xuICAgICAqIHRvIHRoZSBsZWZ0ICYgcmlnaHQgYXJyb3cga2V5cywgYW5kIFwiYmxvY2tcIiB0byB0aGUgdXAgJiBkb3duIGFycm93IGtleXMuXG4gICAgICogXG4gICAgICogVXNlIFwiZWl0aGVyXCIgdG8gYWxsb3cgbmF2aWdhdGlvbiBpbiBlaXRoZXIgZGlyZWN0aW9uLlxuICAgICAqIFxuICAgICAqIFVzZSBcIm5vbmVcIiB0byBkaXNhbGxvdyBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgaW4gYW55IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uPzogXCJpbmxpbmVcIiB8IFwiYmxvY2tcIiB8IFwiZWl0aGVyXCIgfCBcIm5vbmVcIjtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgd2lsbCBiZSBcbiAgICAgKiBkaXNhYmxlZCwgYnV0IG5hdmlnYXRpb24gd2l0aCB0aGUgaG9tZSAmIGVuZCBrZXlzIHdpbGxcbiAgICAgKiBiZSB1bmFmZmVjdGVkLlxuICAgICAqL1xuICAgIGRpc2FibGVBcnJvd0tleXM/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIG5hdmlnYXRpb24gd2l0aCB0aGUgaG9tZSAmIGVuZCBrZXlzIHdpbGxcbiAgICAgKiBiZSBkaXNhYmxlZCwgYnV0IG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlXG4gICAgICogdW5hZmZlY3RlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlSG9tZUVuZEtleXM/OiBib29sZWFuO1xufVxuZXhwb3J0IHR5cGUgTGluZWFyTmF2aWdhdGlvbk9taXRzID0ga2V5b2YgTE5QO1xuXG4vKiogQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgcGFyZW50IGB1c2VMaW5lYXJOYXZpZ2F0aW9uYCAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxPbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cz4ge1xuICAgIGxpbmVhck5hdmlnYXRpb246IE9taXQ8TE5QLCBPbWl0cz5cbn1cblxuXG4vKiogQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgY2hpbGQgJ3VzZUxpbmVhck5hdmlnYXRpb25DaGlsZGAgKi9cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRJbmZvIHsgfVxuXG4vKipcbiAqIFdoZW4gdXNlZCBpbiB0YW5kZW0gd2l0aCBgdXNlUm92aW5nVGFiSW5kZXhgLCBhbGxvd3MgY29udHJvbCBvZlxuICogdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdGhlIGFycm93IGtleXMuXG4gKiBcbiAqIEBzZWUgdXNlTGlzdE5hdmlnYXRpb24sIHdoaWNoIHBhY2thZ2VzIGV2ZXJ5dGhpbmcgdXAgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaW5lYXJOYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBsaW5lYXJOYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9GaXJzdDogbnRmLCBuYXZpZ2F0ZVRvTGFzdDogbnRsLCBuYXZpZ2F0ZVRvTmV4dDogbnRuLCBuYXZpZ2F0ZVRvUHJldjogbnRwLCBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBuZCwgZGlzYWJsZUFycm93S2V5czogZGFrLCBkaXNhYmxlSG9tZUVuZEtleXM6IGRoZWsgfSB9OiBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlcj4pOiBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xuXG4gICAgbmQgPz89IFwiZWl0aGVyXCI7XG5cbiAgICBjb25zdCB7IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvLCB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHMgfSA9IHVzZUxvZ2ljYWxEaXJlY3Rpb248UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHt9KTtcblxuICAgIGNvbnN0IG5hdmlnYXRlVG9GaXJzdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG50Zik7XG4gICAgY29uc3QgbmF2aWdhdGVUb0xhc3QgPSB1c2VTdGFibGVDYWxsYmFjayhudGwpO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9OZXh0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRuKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvUHJldiA9IHVzZVN0YWJsZUNhbGxiYWNrKG50cCk7XG4gICAgY29uc3QgZ2V0RGlzYWJsZUFycm93S2V5cyA9IHVzZVN0YWJsZUdldHRlcihkYWspO1xuICAgIGNvbnN0IGdldERpc2FibGVIb21lRW5kS2V5cyA9IHVzZVN0YWJsZUdldHRlcihkaGVrKTtcbiAgICBjb25zdCBnZXROYXZpZ2F0aW9uRGlyZWN0aW9uID0gdXNlU3RhYmxlR2V0dGVyKG5kKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXG4gICAgICAgIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wczogdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4gPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBvbktleURvd24gPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxuICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuYXZpZ2F0aW9uRGlyZWN0aW9uID0gZ2V0TmF2aWdhdGlvbkRpcmVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FibGVBcnJvd0tleXMgPSBnZXREaXNhYmxlQXJyb3dLZXlzKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzYWJsZUhvbWVFbmRLZXlzID0gZ2V0RGlzYWJsZUhvbWVFbmRLZXlzKCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd3NCbG9ja05hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImJsb2NrXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJpbmxpbmVcIiB8fCBuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiZWl0aGVyXCIpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcImJsb2NrRGlyZWN0aW9uXCIgOiBcImlubGluZURpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IGFsbG93c0Jsb2NrTmF2aWdhdGlvbiA6IGFsbG93c0lubGluZU5hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwiYnR0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcImJsb2NrRGlyZWN0aW9uXCIgOiBcImlubGluZURpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IGFsbG93c0Jsb2NrTmF2aWdhdGlvbiA6IGFsbG93c0lubGluZU5hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwiYnR0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwiaW5saW5lRGlyZWN0aW9uXCIgOiBcImJsb2NrRGlyZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gYWxsb3dzSW5saW5lTmF2aWdhdGlvbiA6IGFsbG93c0Jsb2NrTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJydGxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImlubGluZURpcmVjdGlvblwiIDogXCJibG9ja0RpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IGFsbG93c0lubGluZU5hdmlnYXRpb24gOiBhbGxvd3NCbG9ja05hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwicnRsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVIb21lRW5kS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlSG9tZUVuZEtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHModXNlTWVyZ2VkUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHsgb25LZXlEb3duIH0sIHByb3BzKSlcbiAgICAgICAgfSwgW10pLFxuICAgIH1cblxuXG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcbiAgICAgICAgY3VycmVudFR5cGVhaGVhZDogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZDogYm9vbGVhbiB8IG51bGw7XG4gICAgfVxufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICAvKipcbiAgICAgKiBDYW4gYmUgdXNlZCBvbiBlaXRoZXIgdGhlIHBhcmVudCBvciBlYWNoIGNoaWxkIGVsZW1lbnQuXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzPFBhcmVudE9yQ2hpbGRFbGVtZW50PjtcblxuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ7XG5cbn1cblxuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZSA9IHZvaWQ7XG5cbmludGVyZmFjZSBUTlAge1xuICAgIC8qKlxuICAgICAqIEEgY29sbGF0b3IgdG8gdXNlIHdoZW4gY29tcGFyaW5nLiBJZiBub3QgcHJvdmlkZWQsIHNpbXBseSB1c2VzIGBsb2NhbGVDb21wYXJlYCBhZnRlciB0cmFuc2Zvcm1pbmcgZWFjaCB0byBsb3dlcmNhc2UsIHdoaWNoIHdpbGwsIGF0IGJlc3QsIHdvcmsgb2theSBpbiBFbmdsaXNoLlxuICAgICAqL1xuICAgIGNvbGxhdG9yPzogSW50bC5Db2xsYXRvcjtcblxuICAgIG5vVHlwZWFoZWFkPzogYm9vbGVhbjtcblxuICAgIHR5cGVhaGVhZFRpbWVvdXQ/OiBudW1iZXI7XG4gICAgZ2V0SW5kZXgoKTogbnVtYmVyIHwgbnVsbDtcbiAgICBzZXRJbmRleCh2YWx1ZTogbnVtYmVyIHwgbnVsbCB8ICgocHJldmlvdXNWYWx1ZTogbnVtYmVyIHwgbnVsbCkgPT4gKG51bWJlciB8IG51bGwpKSk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyA9IGtleW9mIFROUDtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxPbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cz4ge1xuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IE9taXQ8VE5QLCBPbWl0cz5cbn1cblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNoaWxkICd1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRgICovXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBJZiBwcm92aWRlZCwgYWxsb3dzIHRoaXMgY29tcG9uZW50IHRvIGJlIG5hdmlnYXRlZCB0byBieSB0eXBpbmcgdGhpcyBzdHJpbmcuIFxuICAgICAqIEl0IHNob3VsZCBiZSB0aGUgc2FtZSB0ZXh0IGNvbnRlbnQgYXMgd2hhdGV2ZXIncyBkaXNwbGF5ZWQsIGlkZWFsbHkuXG4gICAgICovXG4gICAgdGV4dDogc3RyaW5nIHwgbnVsbDtcblxuICAgIGluZGV4OiBudW1iZXI7XG59XG5cbi8qKiBUeXBlIG9mIHRoZSBjaGlsZCdzIHN1Yi1ob29rICovXG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQgPSAoYXJnczogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycykgPT4gVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTtcblxuXG4vKipcbiAqIEFsbG93cyBmb3IgdGhlIHNlbGVjdGlvbiBvZiBhIG1hbmFnZWQgY2hpbGQgYnkgdHlwaW5nIHRoZSBnaXZlbiB0ZXh0IGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAqIFxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVR5cGVhaGVhZE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIGdldEluZGV4LCB0eXBlYWhlYWRUaW1lb3V0LCBzZXRJbmRleCwgbm9UeXBlYWhlYWQgfSB9OiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlcj4pOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xuXG5cbiAgICAvLyBGb3IgdHlwZWFoZWFkLCBrZWVwIHRyYWNrIG9mIHdoYXQgb3VyIGN1cnJlbnQgXCJzZWFyY2hcIiBzdHJpbmcgaXMgKGlmIHdlIGhhdmUgb25lKVxuICAgIC8vIGFuZCBhbHNvIGNsZWFyIGl0IGV2ZXJ5IDEwMDAgbXMgc2luY2UgdGhlIGxhc3QgdGltZSBpdCBjaGFuZ2VkLlxuICAgIC8vIE5leHQsIGtlZXAgYSBtYXBwaW5nIG9mIHR5cGVhaGVhZCB2YWx1ZXMgdG8gaW5kaWNlcyBmb3IgZmFzdGVyIHNlYXJjaGluZy5cbiAgICAvLyBBbmQsIGZvciB0aGUgdXNlcidzIHNha2UsIGxldCB0aGVtIGtub3cgd2hlbiB0aGVpciB0eXBlYWhlYWQgY2FuJ3QgbWF0Y2ggYW55dGhpbmcgYW55bW9yZVxuICAgIGNvbnN0IFtjdXJyZW50VHlwZWFoZWFkLCBzZXRDdXJyZW50VHlwZWFoZWFkLCBnZXRDdXJyZW50VHlwZWFoZWFkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIHVzZVRpbWVvdXQoeyB0aW1lb3V0OiB0eXBlYWhlYWRUaW1lb3V0ID8/IDEwMDAsIGNhbGxiYWNrOiAoKSA9PiB7IHNldEN1cnJlbnRUeXBlYWhlYWQobnVsbCk7IHNldEludmFsaWRUeXBlYWhlYWQobnVsbCk7IH0sIHRyaWdnZXJJbmRleDogY3VycmVudFR5cGVhaGVhZCB9KTtcbiAgICBjb25zdCBzb3J0ZWRUeXBlYWhlYWRJbmZvID0gdXNlUmVmPHsgdGV4dDogc3RyaW5nLCB1bnNvcnRlZEluZGV4OiBudW1iZXIgfVtdPihbXSk7XG4gICAgY29uc3QgW2ludmFsaWRUeXBlYWhlYWQsIHNldEludmFsaWRUeXBlYWhlYWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KGZhbHNlKTtcblxuICAgIC8vIEhhbmRsZSB0eXBlYWhlYWQgZm9yIGlucHV0IG1ldGhvZCBlZGl0b3JzIGFzIHdlbGxcbiAgICAvLyBFc3NlbnRpYWxseSwgd2hlbiBhY3RpdmUsIGlnbm9yZSBmdXJ0aGVyIGtleXMgXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSB3YWl0aW5nIGZvciBhIENvbXBvc2l0aW9uRW5kIGV2ZW50XG4gICAgY29uc3QgWywgc2V0SW1lQWN0aXZlLCBnZXRJbWVBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy8gQmVjYXVzZSBjb21wb3NpdGlvbiBldmVudHMgZmlyZSAqYWZ0ZXIqIGtleWRvd24gZXZlbnRzIFxuICAgIC8vIChidXQgd2l0aGluIHRoZSBzYW1lIHRhc2ssIHdoaWNoLCBUT0RPLCBjb3VsZCBiZSBicm93c2VyLWRlcGVuZGVudCksXG4gICAgLy8gd2UgY2FuIHVzZSB0aGlzIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnQgd2UncmUgbGlzdGVuaW5nIGZvciBvbiB0aGUgZmlyc3Qga2V5ZG93bi5cbiAgICBjb25zdCBbbmV4dFR5cGVhaGVhZENoYXIsIHNldE5leHRUeXBlYWhlYWRDaGFyXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChuZXh0VHlwZWFoZWFkQ2hhciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0Q3VycmVudFR5cGVhaGVhZCh0eXBlYWhlYWQgPT4gKCh0eXBlYWhlYWQgPz8gXCJcIikgKyBuZXh0VHlwZWFoZWFkQ2hhcikpO1xuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIobnVsbCk7XG4gICAgICAgIH1cbiAgICB9LCBbbmV4dFR5cGVhaGVhZENoYXJdKTtcblxuXG4gICAgY29uc3QgY29tcGFyYXRvclNoYXJlZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChzYWZlTGhzOiBzdHJpbmcsIHNhZmVSaHM6IHN0cmluZykgPT4ge1xuICAgICAgICBsZXQgY29tcGFyZTogbnVtYmVyO1xuICAgICAgICAvLyBGb3IgdGhlIHB1cnBvc2VzIG9mIHR5cGVhaGVhZCwgb25seSBjb21wYXJlIGEgc3RyaW5nIG9mIHRoZSBzYW1lIHNpemUgYXMgb3VyIGN1cnJlbnRseSB0eXBlZCBzdHJpbmcuXG4gICAgICAgIC8vIEJ5IG5vcm1hbGl6aW5nIHRoZW0gZmlyc3QsIHdlIGVuc3VyZSB0aGlzIGJ5dGUtYnktYnl0ZSBoYW5kbGluZyBvZiByYXcgY2hhcmFjdGVyIGRhdGEgd29ya3Mgb3V0IG9rYXkuXG4gICAgICAgIHNhZmVMaHMgPSBzYWZlTGhzLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgc2FmZVJocyA9IHNhZmVSaHMubm9ybWFsaXplKFwiTkZEXCIpXG5cbiAgICAgICAgaWYgKGNvbGxhdG9yKVxuICAgICAgICAgICAgY29tcGFyZSA9IGNvbGxhdG9yLmNvbXBhcmUoc2FmZUxocywgc2FmZVJocylcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGFyZSA9IHNhZmVMaHMudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKHNhZmVSaHMudG9Mb3dlckNhc2UoKSA/PyBcIlwiKTtcblxuICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGluc2VydGluZ0NvbXBhcmF0b3IgPSB1c2VTdGFibGVDYWxsYmFjaygobGhzOiBzdHJpbmcsIHJoczogeyB0ZXh0OiBzdHJpbmc7IHVuc29ydGVkSW5kZXg6IG51bWJlcjsgfSkgPT4ge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaHMudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3JTaGFyZWQobGhzLCByaHMudGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGxocyBhcyB1bmtub3duIGFzIG51bWJlcikgLSAocmhzIGFzIHVua25vd24gYXMgbnVtYmVyKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHR5cGVhaGVhZENvbXBhcmF0b3IgPSB1c2VTdGFibGVDYWxsYmFjaygobGhzOiBzdHJpbmcsIHJoczogeyB0ZXh0OiBzdHJpbmc7IHVuc29ydGVkSW5kZXg6IG51bWJlcjsgfSkgPT4ge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaHMudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gRHVyaW5nIHR5cGVhaGVhZCwgYWxsIHN0cmluZ3MgbG9uZ2VyIHRoYW4gb3VycyBzaG91bGQgYmUgdHJ1bmNhdGVkXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZXkncmUgYWxsIGNvbnNpZGVyZWQgZXF1YWxseSBieSB0aGF0IHBvaW50LlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3JTaGFyZWQobGhzLCByaHMudGV4dC5zdWJzdHJpbmcoMCwgbGhzLmxlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChsaHMgYXMgdW5rbm93biBhcyBudW1iZXIpIC0gKHJocyBhcyB1bmtub3duIGFzIG51bWJlcik7XG4gICAgfSk7XG5cbiAgICBjb25zdCBpc0Rpc2FibGVkID0gdXNlU3RhYmxlR2V0dGVyKG5vVHlwZWFoZWFkKTtcblxuXG4gICAgY29uc3QgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcblxuICAgICAgICBjb25zdCBvbkNvbXBvc2l0aW9uU3RhcnQgPSAoX2U6IENvbXBvc2l0aW9uRXZlbnQpID0+IHsgc2V0SW1lQWN0aXZlKHRydWUpIH07XG4gICAgICAgIGNvbnN0IG9uQ29tcG9zaXRpb25FbmQgPSAoZTogQ29tcG9zaXRpb25FdmVudCkgPT4ge1xuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoZS5kYXRhKTtcbiAgICAgICAgICAgIHNldEltZUFjdGl2ZShmYWxzZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBpbWVBY3RpdmUgPSBnZXRJbWVBY3RpdmUoKTtcblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gZS5rZXk7XG5cbiAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxuICAgICAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoIWltZUFjdGl2ZSAmJiBlLmtleSA9PT0gXCJCYWNrc3BhY2VcIikge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gYSB3YXkgdGhhdCBkb2Vzbid0IHNwbGl0IFVURi0xNiBzdXJyb2dhdGVzLlxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlYWhlYWQodCA9PiB0ID09PSBudWxsID8gbnVsbCA6IFsuLi50XS5yZXZlcnNlKCkuc2xpY2UoMSkucmV2ZXJzZSgpLmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGtleSBwcm9wZXJ0eSByZXByZXNlbnRzIHRoZSB0eXBlZCBjaGFyYWN0ZXIgT1IgdGhlIFwibmFtZWQga2V5IGF0dHJpYnV0ZVwiIG9mIHRoZSBrZXkgcHJlc3NlZC5cbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gZGVmaW5pdGUgd2F5IHRvIHRlbGwgdGhlIGRpZmZlcmVuY2UsIGJ1dCBmb3IgYWxsIGludGVudHMgYW5kIHB1cnBvc2VzXG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gb25lLWNoYXJhY3RlciBuYW1lcywgYW5kIHRoZXJlIGFyZSBubyBub24tQVNDSUktYWxwaGEgbmFtZXMuXG4gICAgICAgICAgICAvLyBUaHVzLCBhbnkgb25lLWNoYXJhY3RlciBvciBub24tQVNDSUkgdmFsdWUgZm9yIGBrZXlgIGlzICphbG1vc3QgY2VydGFpbmx5KiBhIHR5cGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGNvbnN0IGlzQ2hhcmFjdGVyS2V5ID0gKGtleS5sZW5ndGggPT09IDEgfHwgIS9eW0EtWmEtel0vLnRlc3Qoa2V5KSk7XG4gICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXJLZXkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gXCIgXCIgJiYgKGdldEN1cnJlbnRUeXBlYWhlYWQoKSA/PyBcIlwiKS50cmltKCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgYmVjYXVzZSBhIHNwYWNlYmFyIGNhbid0IGV2ZXIgXG4gICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIGEgdHlwZWFoZWFkLCBvbmx5IGNvbnRpbnVlIG9uZS5cblxuICAgICAgICAgICAgICAgICAgICAvLyAoU3BlY2lmaWNhbGx5LCBsZXQgdGhlIGV2ZW50IGNvbnRpbnVlIHByb3BhZ2F0aW9uIGluIHRoaXMgY2FzZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdvbid0IGJlIHRydWUgZm9yIHRoZSBmaXJzdCBrZXlkb3duXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJlZm9yZSB1c2VMYXlvdXRFZmZlY3QgaXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGFjdHVhbGx5IGFwcGx5IHRoZSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD4oeyBvbktleURvd24sIG9uQ29tcG9zaXRpb25TdGFydCwgb25Db21wb3NpdGlvbkVuZCwgfSwgcHJvcHMpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIEhhbmRsZSBjaGFuZ2VzIGluIHR5cGVhaGVhZCB0aGF0IGNhdXNlIGNoYW5nZXMgdG8gdGhlIHRhYmJhYmxlIGluZGV4XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnRUeXBlYWhlYWQgJiYgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50Lmxlbmd0aCkge1xuXG5cblxuICAgICAgICAgICAgY29uc3Qgc29ydGVkVHlwZWFoZWFkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCBjdXJyZW50VHlwZWFoZWFkLCB0eXBlYWhlYWRDb21wYXJhdG9yKTtcblxuICAgICAgICAgICAgaWYgKHNvcnRlZFR5cGVhaGVhZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGhhcyB0eXBlZCBhbiBlbnRyeSB0aGF0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAvLyAob3IgbW9yZSBzcGVjaWZpY2FsbHkgXCJmb3Igd2hpY2ggdGhlcmUgaXMgbm8gZW50cnkgdGhhdCBzdGFydHMgd2l0aCB0aGF0IGlucHV0XCIpXG4gICAgICAgICAgICAgICAgc2V0SW52YWxpZFR5cGVhaGVhZCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEludmFsaWRUeXBlYWhlYWQoZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgIFdlIGtub3cgcm91Z2hseSB3aGVyZSwgaW4gdGhlIHNvcnRlZCBhcnJheSBvZiBzdHJpbmdzLCBvdXIgbmV4dCB0eXBlYWhlYWQgbG9jYXRpb24gaXMuXG4gICAgICAgICAgICAgICAgICBCdXQgcm91Z2hseSBpc24ndCBnb29kIGVub3VnaCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgIFRvIGNvbnZlcnQgb3VyIHNvcnRlZCBpbmRleCB0byB0aGUgdW5zb3J0ZWQgaW5kZXggd2UgbmVlZCwgd2UgaGF2ZSB0byBmaW5kIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgZWxlbWVudCB0aGF0IG1hdGNoZXMgdXMgKmFuZCogKGlmIGFueSBzdWNoIGV4aXN0KSBpcyAqYWZ0ZXIqIG91ciBjdXJyZW50IHNlbGVjdGlvbi5cblxuICAgICAgICAgICAgICAgICAgSW4gb3RoZXIgd29yZHMsIHRoZSBvbmx5IHdheSB0eXBlYWhlYWQgbW92ZXMgYmFja3dhcmRzIHJlbGF0aXZlIHRvIG91ciBjdXJyZW50XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiBpcyBpZiB0aGUgb25seSBvdGhlciBvcHRpb24gaXMgYmVoaW5kIHVzLlxuXG4gICAgICAgICAgICAgICAgICBJdCdzIG5vdCBzcGVjaWZpZWQgaW4gV0FJLUFSSUEgd2hhdCB0byBkbyBpbiB0aGF0IGNhc2UuICBJIHN1cHBvc2Ugd3JhcCBiYWNrIHRvIHRoZSBzdGFydD9cbiAgICAgICAgICAgICAgICAgIFRob3VnaCB0aGVyZSdzIGFsc28gYSBjYXNlIGZvciBqdXN0IGdvaW5nIHVwd2FyZHMgdG8gdGhlIG5lYXJlc3QgdG8gcHJldmVudCBqdW1waW5lc3MuXG4gICAgICAgICAgICAgICAgICBCdXQgaWYgeW91J3JlIGFscmVhZHkgZG9pbmcgdHlwZWFoZWFkIG9uIGFuIHVuc29ydGVkIGxpc3QsIGxpa2UsIGp1bXBpbmVzcyBjYW4ndCBiZSBhdm9pZGVkLlxuICAgICAgICAgICAgICAgICAgSSBkdW5uby4gR29pbmcgYmFjayB0byB0aGUgc3RhcnQgaXMgdGhlIHNpbXBsaXN0IHRob3VnaC5cblxuICAgICAgICAgICAgICAgICAgQmFzaWNhbGx5IHdoYXQgdGhpcyBkb2VzOiBTdGFydGluZyBmcm9tIHdoZXJlIHdlIGZvdW5kIG91cnNlbHZlcyBhZnRlciBvdXIgYmluYXJ5IHNlYXJjaCxcbiAgICAgICAgICAgICAgICAgIHNjYW4gYmFja3dhcmRzIGFuZCBmb3J3YXJkcyB0aHJvdWdoIGFsbCBhZGphY2VudCBlbnRyaWVzIHRoYXQgYWxzbyBjb21wYXJlIGVxdWFsbHkgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgd2UgY2FuIGZpbmQgdGhlIG9uZSB3aG9zZSBgdW5zb3J0ZWRJbmRleGAgaXMgdGhlIGxvd2VzdCBhbW9uZ3N0IGFsbCBvdGhlciBlcXVhbCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAoYW5kIGFsc28gdGhlIGxvd2VzdCBgdW5zb3J0ZWRJbmRleGAgeWFkZGEgeWFkZGEgZXhjZXB0IHRoYXQgaXQgY29tZXMgYWZ0ZXIgdXMpLlxuXG4gICAgICAgICAgICAgICAgICBUT0RPOiBUaGUgYmluYXJ5IHNlYXJjaCBzdGFydHMgdGhpcyBvZmYgd2l0aCBhIHNvbGlkIE8obG9nIG4pLCBidXQgb25lLWNoYXJhY3RlciBcbiAgICAgICAgICAgICAgICAgIHNlYXJjaGVzIGFyZSwgdGhhbmtzIHRvIHBpZ2VvbmhvbGUgcHJpbmNpcGFsLCBldmVudHVhbGx5IGd1YXJhbnRlZWQgdG8gYmVjb21lIFxuICAgICAgICAgICAgICAgICAgTyhuKmxvZyBuKS4gVGhpcyBpcyBhbm5veWluZyBidXQgcHJvYmFibHkgbm90IGVhc2lseSBzb2x2YWJsZT8gVGhlcmUgY291bGQgYmUgYW4gXG4gICAgICAgICAgICAgICAgICBleGNlcHRpb24gZm9yIG9uZS1jaGFyYWN0ZXIgc3RyaW5ncywgYnV0IHRoYXQncyBqdXN0IGtpY2tpbmcgdGhlIGNhbiBkb3duIFxuICAgICAgICAgICAgICAgICAgdGhlIHJvYWQuIE1heWJlIG9uZSBvciB0d28gY2hhcmFjdGVycyB3b3VsZCBiZSBnb29kIGVub3VnaCB0aG91Z2guXG4gICAgICAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY2FuZGlkYXRlcycgcG9zaXRpb25zIGluIGJvdGggb3VyIHNvcnRlZCBhcnJheSBhbmQgdGhlIHVuc29ydGVkIERPTS5cbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4QWxsID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSB0d28gYXJlIG9ubHkgc2V0IGZvciBlbGVtZW50cyB0aGF0IGFyZSBhaGVhZCBvZiB1cywgYnV0IHRoZSBwcmluY2lwbGUncyB0aGUgc2FtZSBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUJlc3RGaXQgPSAodTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U29ydGVkSW5kZXhBbGwgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPT0gbnVsbCB8fCB1IDwgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQpICYmIHUgPiAoZ2V0SW5kZXgoKSA/PyAtSW5maW5pdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9IHU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGkgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIHR5cGVhaGVhZENvbXBhcmF0b3IoY3VycmVudFR5cGVhaGVhZCwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50Lmxlbmd0aCAmJiB0eXBlYWhlYWRDb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5kZXgoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2xvd2VzdFNvcnRlZEluZGV4TmV4dF0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleEFsbCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5kZXgoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2xvd2VzdFNvcnRlZEluZGV4QWxsXS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtjdXJyZW50VHlwZWFoZWFkXSk7XG5cbiAgICBjb25zdCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ+KCh7IGluZGV4LCB0ZXh0IH0pID0+IHtcblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRleHQpIHtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgd2hlcmUgdG8gaW5zZXJ0IHRoaXMgaXRlbS5cbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIGFsbCBpbmRleCB2YWx1ZXMgc2hvdWxkIGJlIHVuaXF1ZSwgdGhlIHJldHVybmVkIHNvcnRlZEluZGV4XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGFsd2F5cyByZWZlciB0byBhIG5ldyBsb2NhdGlvbiAoaS5lLiBiZSBuZWdhdGl2ZSkgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCB0ZXh0LCBpbnNlcnRpbmdDb21wYXJhdG9yKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDAgfHwgaW5zZXJ0aW5nQ29tcGFyYXRvcihzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbc29ydGVkSW5kZXhdLnRleHQsIHsgdW5zb3J0ZWRJbmRleDogaW5kZXgsIHRleHQgfSkgPT0gMCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKC1zb3J0ZWRJbmRleCAtIDEsIDAsIHsgdGV4dCwgdW5zb3J0ZWRJbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKHNvcnRlZEluZGV4LCAwLCB7IHRleHQsIHVuc29ydGVkSW5kZXg6IGluZGV4IH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdW5tb3VudGluZywgZmluZCB3aGVyZSB3ZSB3ZXJlIGFuZCByZW1vdmUgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBBZ2Fpbiwgd2Ugc2hvdWxkIGFsd2F5cyBmaW5kIG91cnNlbHZlcyBiZWNhdXNlIHRoZXJlIHNob3VsZCBiZSBubyBkdXBsaWNhdGUgdmFsdWVzIGlmIGVhY2ggaW5kZXggaXMgdW5pcXVlLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIHRleHQsIGluc2VydGluZ0NvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDAgfHwgaW5zZXJ0aW5nQ29tcGFyYXRvcihzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbc29ydGVkSW5kZXhdLnRleHQsIHsgdW5zb3J0ZWRJbmRleDogaW5kZXgsIHRleHQgfSkgPT0gMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2Uoc29ydGVkSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbdGV4dF0pO1xuXG4gICAgICAgIHJldHVybjtcblxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzLFxuXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXG4gICAgICAgICAgICBpbnZhbGlkVHlwZWFoZWFkLFxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogWW91ciB1c3VhbCBiaW5hcnkgc2VhcmNoIGltcGxlbWVudGF0aW9uLlxuICogXG4gKiBJdCdzIHVzZWQgaGVyZSB0byBxdWlja2x5IGZpbmQgYSBnb29kIHNwb3QgdG8gc3RhcnQgc2VhcmNoaW5nIGZvciBvdXIgbmV4dCB0eXBlYWhlYWQgY2FuZGlkYXRlLlxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2ggdGhyb3VnaFxuICogQHBhcmFtIHdhbnRlZCBUaGUgdmFsdWUgeW91J2QgbGlrZSB0byBmaW5kXG4gKiBAcGFyYW0gY29tcGFyYXRvciBDb21wYXJlcyBgd2FudGVkYCB3aXRoIHRoZSBjdXJyZW50IHZhbHVlIGluIGBhcnJheWBcbiAqIEByZXR1cm5zIEEgbm9uLW5lZ2F0aXZlIHZhbHVlIGlmIGB3YW50ZWRgIHdhcyBmb3VuZCwgYW5kIGEgbmVnYXRpdmUgbnVtYmVyIGlmIG5vdC4gXG4gKiBUaGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBudW1iZXIsIG1pbnVzIG9uZSwgaXMgd2hlcmUgYHdhbnRlZGAgKndvdWxkKiBiZSBmb3VuZCBpZiBpdCAqd2FzKiBpbiBgYXJyYXlgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2g8VCwgVSwgRiBleHRlbmRzIChsaHM6IFUsIHJoczogVCkgPT4gbnVtYmVyPihhcnJheTogVFtdLCB3YW50ZWQ6IFUsIGNvbXBhcmF0b3I6IEYpOiBudW1iZXIge1xuICAgIGxldCBmaXJzdEluZGV4ID0gMDtcbiAgICBsZXQgbGFzdEluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoZmlyc3RJbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgdGVzdEluZGV4ID0gKGxhc3RJbmRleCArIGZpcnN0SW5kZXgpID4+IDE7XG4gICAgICAgIGNvbnN0IGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJhdG9yKHdhbnRlZCwgYXJyYXlbdGVzdEluZGV4XSk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgICAgICBmaXJzdEluZGV4ID0gdGVzdEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gdGVzdEluZGV4IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLWZpcnN0SW5kZXggLSAxO1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgQ2hpbGRGbGFnT3BlcmF0aW9ucywgTWFuYWdlZENoaWxkT21pdHMsIE1hbmFnZWRDaGlsZHJlbk9taXRzLCBPbkNoaWxkcmVuTW91bnRDaGFuZ2UsIHVzZUNoaWxkcmVuRmxhZywgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VIYXNGb2N1cyB9IGZyb20gXCIuL3VzZS1oYXMtZm9jdXNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5cbi8vZXhwb3J0IHR5cGUgVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm88SyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvQmFzZTxLPj4gPSBSZXF1aXJlZDxJPiAmIEZsYWdnYWJsZUNoaWxkSW5mbzxcInRhYmJhYmxlXCI+ICYge1xuLy99O1xuXG5leHBvcnQgdHlwZSBPblRhYmJhYmxlSW5kZXhDaGFuZ2UgPSAodGFiYmFibGVJbmRleDogbnVtYmVyIHwgbnVsbCkgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88RSBleHRlbmRzIEVsZW1lbnQsIEM+IHtcbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0LCB0YWJiaW5nIHRocm91Z2ggdGhpcyBjb21wb25lbnQgd2lsbCBjYXVzZSB0aGUgcmVmZXJlbmNlZCBlbGVtZW50IHRvIGJlIGZvY3VzZWQuXG4gICAgICogXG4gICAgICogWW91IGNhbiBvdmVycmlkZSB0aGlzIGJlaGF2aW9yIHRvIGRvIHNvbWV0aGluZyBkaWZmZXJlbnQgaWYgeW91J2QgbGlrZS5cbiAgICAgKi9cbiAgICBmb2N1c1NlbGYoKTogdm9pZDtcblxuICAgIGJsdXJTZWxmKCk6IHZvaWQ7XG5cbiAgICBnZXRFbGVtZW50KCk6IEUgfCBudWxsO1xuXG4gICAgaGlkZGVuOiBib29sZWFuO1xuXG4gICAgc3ViSW5mbzogQztcbn1cblxuaW50ZXJmYWNlIFJUSVAge1xuICAgIC8vIENhbGxlZCBkdXJpbmcgYW4gZWZmZWN0IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIHJlbmRlcmVkIGl0c2VsZiBpbiBhIHRhYmJhYmxlIHN0YXRlXG4gICAgb25UYWJiYWJsZVJlbmRlcj86IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPzogT25UYWJiYWJsZUluZGV4Q2hhbmdlO1xuXG4gICAgLy9vblRhYmJlZEluVG8/OiAoKSA9PiB2b2lkO1xuICAgIC8vb25UYWJiZWRPdXRPZj86ICgpID0+IHZvaWQ7XG5cbiAgICBpbml0aWFsSW5kZXg/OiBudW1iZXI7XG59XG5leHBvcnQgdHlwZSBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cyA9IGtleW9mIFJUSVA7XG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczxSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxudW1iZXIsIE1jT21pdHM+IHtcbiAgICByb3ZpbmdUYWJJbmRleDogT21pdDxSVElQLCBSdGlPbWl0cz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbzxSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPG51bWJlciwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4ge1xuICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXg6ICh1cGRhdGVyOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0sIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHZvaWQ7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldFRhYmJhYmxlSW5kZXg6ICgpID0+IG51bWJlciB8IG51bGw7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGZvY3VzU2VsZjogKCkgPT4gdm9pZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcbiAgICBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVJbmZvPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8+LCBFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiPlxue1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZDogVXNlUm92aW5nVGFiSW5kZXhDaGlsZDxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+O1xufVxuXG5leHBvcnQgdHlwZSBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMgPSBrZXlvZiBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88YW55LCBhbnk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nLCBSdGljT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCIsIE1jT21pdHMgfCBcInN1YkluZm9cIj4ge1xuICAgIHJvdmluZ1RhYkluZGV4OiBPbWl0PFBhcnRpYWw8T21pdDxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88YW55LCBhbnk+LCBcImdldEVsZW1lbnRcIiB8IFwic3ViSW5mb1wiPj4sIFJ0aWNPbWl0cz47XG4gICAgc3ViSW5mbzogU3ViYmVzdEluZm87XG59XG5cbmV4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzLCBuZXZlciwgbmV2ZXIsIFJ0aVN1YkluZm8+KSA9PiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgdGFiYmFibGU6IGJvb2xlYW47XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldFRhYmJhYmxlKCk6IGJvb2xlYW47XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldEVsZW1lbnQoKTogQ2hpbGRFbGVtZW50IHwgbnVsbDtcbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD47XG59XG5cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgcm92aW5nIHRhYmluZGV4IHN5c3RlbSB3aGVyZSBvbmx5IG9uZSBcImZvY3VzYWJsZVwiXG4gKiBjb21wb25lbnQgaW4gYSBzZXQgaXMgYWJsZSB0byByZWNlaXZlIGEgdGFiIGZvY3VzLiAqV2hpY2gqXG4gKiBvZiB0aG9zZSBlbGVtZW50cyByZWNlaXZlcyBmb2N1cyBpcyBkZXRlcm1pbmVkIGJ5IHlvdSwgYnV0IGl0J3NcbiAqIHJlY29tbWVuZGVkIHRvIG9mZmxvYWQgdGhhdCBsb2dpYyB0aGVuIHRvIGFub3RoZXIgaG9vaywgbGlrZVxuICogYHVzZUxpbmVhck5hdmlnYXRpb25gLCB3aGljaCBsZXRzIHlvdSBjaGFuZ2UgdGhlIHRhYmJhYmxlXG4gKiBlbGVtZW50IHdpdGggdGhlIGFycm93IGtleXMsIGB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uYCwgd2hpY2hcbiAqIGxldHMgeW91IGNoYW5nZSB0aGUgdGFiYmFibGUgaW5kZXggd2l0aCB0eXBlYWhlYWQsIG9yXG4gKiBgdXNlTGlzdE5hdmlnYXRpb25gIGlmIHlvdSBqdXN0IHdhbnQgZXZlcnl0aGluZyBidW5kbGVkIHRvZ2V0aGVyLlxuICogXG4gKiBOb3RlIHRoYXQgdGhlIGNoaWxkIGhvb2sgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWRcbiAqIGJ5IGV2ZXJ5IGNoaWxkIHRoYXQgdXNlcyB0aGlzIHJvdmluZyB0YWJpbmRleCBsb2dpYy4gIFRoZVxuICogcHJvcC1tb2RpZnlpbmcgaG9vayAqdGhhdCogaG9vayByZXR1cm5zIHNob3VsZCB0aGVuIGJlIHVzZWRcbiAqIG9uIHRoZSBjaGlsZCdzIGVsZW1lbnQsIGFzIHdlbGwgYXMgYW55IG90aGVyIGVsZW1lbnRzIHlvdSdkIGxpa2VcbiAqIHRvIGJlIGV4cGxpY2l0bHkgbWFkZSB1bnRhYmJhYmxlIHRvby5cbiAqIFxuICogYHNob3VsZEZvY3VzT25DaGFuZ2VgIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiBmb2N1cyBpcyBcbiAqIGNvbnRhaW5lZCB3aXRoaW4gd2hhdGV2ZXIgZWxlbWVudCBjb250YWlucyB0aGUgcm92aW5nIHRhYiBpbmRleC5cbiAqIEdlbmVyYWxseSBhcyBzaW1wbGUgYXMgdGhlIGZvbGxvd2luZzpcbiAqIGBgYFxuICogY29uc3QgW2ZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAqIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8UGFyZW50RWxlbWVudD4oeyBzZXRGb2N1c2VkSW5uZXIgfSk7XG4gKiBjb25zdCBmb2N1c09uQ2hhbmdlID0gKGZvY3VzZWRJbm5lciAhPSBmYWxzZSk7XG4gKiBgYGBcbiAqIEl0J3Mgbm90IGluY2x1ZGVkIGhlcmUgYmVjYXVzZSBgdXNlUm92aW5nVGFiSW5kZXhgIGRvZXNuJ3Qga25vdyBcbiAqIGFueXRoaW5nIGFib3V0IHRoZSBjb250YWluZXIgZWxlbWVudCwgb25seSBjaGlsZHJlbiBlbGVtZW50cy5cbiAqIEFuZCBqdXN0IGFzIHdlbGwhIENoaWxkcmVuIHNob3VsZCBiZSBhbGxvd2VkIGF0IHRoZSByb290LCBcbiAqIHJlZ2FyZGxlc3Mgb2YgaWYgaXQncyB0aGUgd2hvbGUgYXBwIG9yIGp1c3QgYSBnaXZlbiBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPihwYXJlbnRQYXJhbWV0ZXJzOiBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyPik6IFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcblxuICAgIGxldCB7IHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZVJlbmRlciwgb25UYWJiYWJsZUluZGV4Q2hhbmdlIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH0gPSBwYXJlbnRQYXJhbWV0ZXJzO1xuXG4gICAgaW5pdGlhbEluZGV4ID8/PSAwO1xuICAgIGNvbnN0IHN0YWJsZU9uVGFiYmFibGVSZW5kZXIgPSB1c2VTdGFibGVDYWxsYmFjayhvblRhYmJhYmxlUmVuZGVyID8/ICgoKSA9PiB7IH0pKTtcbiAgICAvKmNvbnN0IFtfZ2V0QW55Rm9jdXNlZCwgc2V0QW55Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyPih1c2VTdGFibGVDYWxsYmFjaygobmV3Q291bnQ6IG51bWJlciwgb2xkQ291bnQ6IG51bWJlciB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBpZiAob2xkQ291bnQgPT0gMCAmJiBuZXdDb3VudCA+IDApIHtcbiAgICAgICAgICAgIG9uVGFiYmVkSW5Ubz8uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3Q291bnQgPT0gMCAmJiAob2xkQ291bnQgPz8gMCkgPiAwKSB7XG4gICAgICAgICAgICBvblRhYmJlZE91dE9mPy4oKTtcbiAgICAgICAgfVxuICAgIH0pLCByZXR1cm5aZXJvKTsqL1xuXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aHJlZSB0aGluZ3MgcmVsYXRlZCB0byB0aGUgY3VycmVudGx5IHRhYmJhYmxlIGVsZW1lbnQncyBpbmRleDpcbiAgICAvLyBXaGF0IGl0IGlzLCBhbmQgd2hldGhlciwgd2hlbiB3ZSByZW5kZXIgdGhpcyBjb21wb25lbnQgYW5kIGl0J3MgY2hhbmdlZCwgdG8gYWxzbyBmb2N1cyB0aGUgZWxlbWVudCB0aGF0IHdhcyBtYWRlIHRhYmJhYmxlLlxuICAgIGNvbnN0IFtnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4Ml0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyIHwgbnVsbD4ob25UYWJiYWJsZUluZGV4Q2hhbmdlLCB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiBpbml0aWFsSW5kZXggPz8gMCB9LCBbXSkpO1xuICAgIGNvbnN0IHNldFRhYmJhYmxlSW5kZXggPSB1c2VDYWxsYmFjaygodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7XG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXgyKChwcmV2SW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxldCBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXBkYXRlciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IHVwZGF0ZXIocHJldkluZGV4ID8/IG51bGwpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IHVwZGF0ZXI7XG5cbiAgICAgICAgICAgIG5leHRJbmRleCA9IGNoYW5nZUluZGV4KG5leHRJbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChwcmV2SW5kZXggIT0gbmV4dEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4uZ2V0QXQobmV4dEluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBwcmV2SW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbi5nZXRBdChwcmV2SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZDaGlsZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBwcmV2Q2hpbGQuc3ViSW5mby5ibHVyU2VsZigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZCAhPSBudWxsICYmIGZyb21Vc2VySW50ZXJhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGlsZC5zdWJJbmZvLmZvY3VzU2VsZigpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0SW5kZXg7XG4gICAgICAgIH0pO1xuXG4gICAgfSwgW10pO1xuXG4gICAgLy8gQW55IHRpbWUgdGhlIHRhYmJhYmxlIGluZGV4IGNoYW5nZXMsXG4gICAgLy8gbm90aWZ5IHRoZSBwcmV2aW91cyBjaGlsZCB0aGF0IGl0J3Mgbm8gbG9uZ2VyIHRhYmJhYmxlLFxuICAgIC8vIGFuZCBub3RpZnkgdGhlIG5leHQgY2hpbGQgdGhhdCBpcyBhbGxvd2VkIHRvIGJlIHRhYmJlZCB0by5cbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCI+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7XG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobW91bnRlZCwgdW5tb3VudGVkKSA9PiB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKG1vdW50ZWQsIHVubW91bnRlZCk7IHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7IH0pLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGQgfSA9IHBhcmVudFJldHVyblR5cGU7XG5cbiAgICBjb25zdCB7IGNoYW5nZUluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdCB9ID0gdXNlQ2hpbGRyZW5GbGFnPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8+LCBFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiPih7IGluaXRpYWxJbmRleCwgY2hpbGRyZW46IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLCBjbG9zZXN0Rml0OiB0cnVlLCBrZXk6IFwidGFiYmFibGVcIiB9KTtcblxuICAgIGNvbnN0IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQgPSB1c2VDYWxsYmFjazxVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4+KChjaGlsZFBhcmFtZXRlcnMpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN1YkluZm8sIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHsgaGlkZGVuLCBibHVyU2VsZjogYmx1clNlbGZPdmVycmlkZSwgZm9jdXNTZWxmOiBmb2N1c1NlbGZPdmVycmlkZSB9IH0gPSBjaGlsZFBhcmFtZXRlcnM7XG5cbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7XG4gICAgICAgIH0sIFshIWhpZGRlbl0pXG5cblxuICAgICAgICBjb25zdCBic092ZXJyaWRlID0gdXNlU3RhYmxlR2V0dGVyKGJsdXJTZWxmT3ZlcnJpZGUpO1xuICAgICAgICBjb25zdCBmc092ZXJyaWRlID0gdXNlU3RhYmxlR2V0dGVyKGZvY3VzU2VsZk92ZXJyaWRlKTtcbiAgICAgICAgY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnMgPSBmc092ZXJyaWRlKCk7XG4gICAgICAgICAgICBpZiAoZnMpIHtcbiAgICAgICAgICAgICAgICBmcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKSBhcyAoRWxlbWVudCAmIFBhcnRpYWw8SFRNTEVsZW1lbnQ+KTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5mb2N1cz8uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgY29uc3QgYmx1clNlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBicyA9IGJzT3ZlcnJpZGUoKTtcbiAgICAgICAgICAgIGlmIChicykge1xuICAgICAgICAgICAgICAgIGJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpIGFzIChFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmJsdXI/LigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgY29uc3Qgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkID0gdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIF9wcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8Q2hpbGRFbGVtZW50Pih7IG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgZ2V0RG9jdW1lbnQ6IHVzZUNhbGxiYWNrKCgpOiBEb2N1bWVudCA9PiB7IHJldHVybiBnZXRFbGVtZW50KCk/Lm93bmVyRG9jdW1lbnQhIH0sIFtdKSB9KTtcblxuICAgICAgICBjb25zdCBbdGFiYmFibGUsIHNldFRhYmJhYmxlLCBnZXRUYWJiYWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRhYmJhYmxlRmxhZ3MgPSB1c2VSZWY8Q2hpbGRGbGFnT3BlcmF0aW9ucz4oeyBnZXQ6IGdldFRhYmJhYmxlLCBzZXQ6IHNldFRhYmJhYmxlLCBpc1ZhbGlkOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiAhaGlkZGVuKSB9KTtcblxuICAgICAgICBjb25zdCBfOiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDoge1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGZsYWdzOiB7IC4uLmZsYWdzLCB0YWJiYWJsZTogdGFiYmFibGVGbGFncy5jdXJyZW50IH0gYXMgUGFydGlhbDxSZWNvcmQ8RXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIiwgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+LFxuICAgICAgICAgICAgICAgIHN1YkluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgYmx1clNlbGYsXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzU2VsZixcbiAgICAgICAgICAgICAgICAgICAgZ2V0RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhIWhpZGRlbixcbiAgICAgICAgICAgICAgICAgICAgc3ViSW5mb1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFiYmFibGUpXG4gICAgICAgICAgICAgICAgc3RhYmxlT25UYWJiYWJsZVJlbmRlcihpbmRleCk7XG4gICAgICAgIH0sIFt0YWJiYWJsZSwgaW5kZXhdKVxuICAgICAgICBmdW5jdGlvbiB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHByb3BzLnRhYkluZGV4ID09IG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPENoaWxkRWxlbWVudD4odXNlSGFzRm9jdXNQcm9wcyh7IHRhYkluZGV4OiB0YWJiYWJsZSA/IDAgOiAtMSB9KSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgICAgICAgICAgZ2V0RWxlbWVudCxcbiAgICAgICAgICAgICAgICB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBnZXRUYWJiYWJsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhgdXNlUm92aW5nVGFiSW5kZXguZm9jdXNTZWxmYCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0VGFiYmFibGVJbmRleCgpO1xuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbClcbiAgICAgICAgICAgIHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KGluZGV4KT8uc3ViSW5mby5mb2N1c1NlbGY/LigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG51bGwsIHRydWUpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4gfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgsXG4gICAgICAgICAgICBnZXRUYWJiYWJsZUluZGV4LFxuICAgICAgICAgICAgZm9jdXNTZWxmLFxuICAgICAgICB9XG4gICAgfTtcbn1cblxuLypmdW5jdGlvbiB0ZXN0KCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGZvY3VzU2VsZiwgZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleCwgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgfSA9IHVzZVJvdmluZ1RhYkluZGV4PEhUTUxEaXZFbGVtZW50LCB7IFwiZm9vXCI6IFwiYmFyXCIgfSwgXCJmbGFnMlwiPih7IG1hbmFnZWRDaGlsZHJlbjoge30sIHJvdmluZ1RhYkluZGV4OiB7fSB9KTtcbiAgICBjb25zdCB7IH0gPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkKHsgbWFuYWdlZENoaWxkcmVuOiB7IGluZGV4OiAwLCBmbGFnczoge30gfSwgcnRpOiB7IGluZm8zOiB7IGZvbzogXCJiYXJcIiB9IH0gfSk7XG59Ki9cbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5QXJyYXk7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVJhbmRvbTtcbiIsImltcG9ydCBiYXNlUmFuZG9tIGZyb20gJy4vX2Jhc2VSYW5kb20uanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICB9XG4gIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2h1ZmZsZVNlbGY7XG4iLCJpbXBvcnQgY29weUFycmF5IGZyb20gJy4vX2NvcHlBcnJheS5qcyc7XG5pbXBvcnQgc2h1ZmZsZVNlbGYgZnJvbSAnLi9fc2h1ZmZsZVNlbGYuanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVNodWZmbGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVmFsdWVzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRpbWVzO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzQXJndW1lbnRzO1xuIiwiaW1wb3J0IGJhc2VJc0FyZ3VtZW50cyBmcm9tICcuL19iYXNlSXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViRmFsc2U7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcbmltcG9ydCBzdHViRmFsc2UgZnJvbSAnLi9zdHViRmFsc2UuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnVmZmVyO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0luZGV4O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xlbmd0aDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVVuYXJ5O1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVVdGlsO1xuIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGJhc2VUaW1lcyBmcm9tICcuL19iYXNlVGltZXMuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlMaWtlS2V5cztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXM7XG4iLCJpbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXMgZnJvbSAnLi9fbmF0aXZlS2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXM7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGdW5jdGlvbjtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5TGlrZTtcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzIGZyb20gJy4vX2Jhc2VLZXlzLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXM7XG4iLCJpbXBvcnQgYmFzZVZhbHVlcyBmcm9tICcuL19iYXNlVmFsdWVzLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZXM7XG4iLCJpbXBvcnQgc2h1ZmZsZVNlbGYgZnJvbSAnLi9fc2h1ZmZsZVNlbGYuanMnO1xuaW1wb3J0IHZhbHVlcyBmcm9tICcuL3ZhbHVlcy5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNodWZmbGU7XG4iLCJpbXBvcnQgYXJyYXlTaHVmZmxlIGZyb20gJy4vX2FycmF5U2h1ZmZsZS5qcyc7XG5pbXBvcnQgYmFzZVNodWZmbGUgZnJvbSAnLi9fYmFzZVNodWZmbGUuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2h1ZmZsZSA6IGJhc2VTaHVmZmxlO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2h1ZmZsZTtcbiIsImltcG9ydCAqIGFzIF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBNdXRhYmxlUmVmLCB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBNYW5hZ2VkQ2hpbGRJbmZvLCBNYW5hZ2VkQ2hpbGRyZW4gfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tIFwiLi91c2UtZm9yY2UtdXBkYXRlXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHJldHVybk51bGwsIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgbG9kYXNoU2h1ZmZsZSBmcm9tIFwibG9kYXNoLWVzL3NodWZmbGVcIjtcblxuZXhwb3J0IHR5cGUgR2V0SW5kZXg8QywgSyBleHRlbmRzIHN0cmluZz4gPSAocm93OiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4pID0+IChudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkKTtcbmV4cG9ydCB0eXBlIEdldFZhbHVlPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4gPSAocm93OiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4sIC4uLmFyZ3M6IEcpID0+IFY7XG5leHBvcnQgdHlwZSBDb21wYXJlPFY+ID0gKGxoczogViwgcmhzOiBWKSA9PiBudW1iZXI7XG5cbi8qKlxuICogQWxsIG9mIHRoZXNlIGZ1bmN0aW9ucyAqKk1VU1QqKiBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG5cbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiwgZS5nLiwgdGhlIHJvdyBpbmRleCBvZiB0aGlzIGNoaWxkXG4gICAgICogKFVzdWFsbHkganVzdCBhbiBgaW5kZXhgIHByb3ApXG4gICAgICovXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4OiBHZXRJbmRleDxDLCBLPjsgfVxufVxuXG4vKipcbiAqIEFsbCBvZiB0aGVzZSBmdW5jdGlvbnMgKipNVVNUKiogYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEs+IHtcbiAgICBzb3J0YWJsZUNoaWxkcmVuOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdXN0IHJldHVybiB0aGUgdmFsdWUgdGhpcyBjaGlsZCB1c2VzIFJFOiBzb3J0aW5nLlxuICAgICAgICAgKiBJZiB5b3UgZG9uJ3QgY2FyZSBhYm91dCBzb3J0aW5nICh5b3UganVzdCB1c2UgXG4gICAgICAgICAqIHlvdXIgb3duYXJiaXRyYXJ5IHJlb3JkZXJpbmcpLCB0aGlzIHdpbGwgbmV2ZXJcbiAgICAgICAgICogYmUgdXNlZCwgc28gaXQgY2FuIHJldHVybiBhbnl0aGluZy5cbiAgICAgICAgICogQHBhcmFtIHJvdyBcbiAgICAgICAgICogQHBhcmFtIGFyZ3MgXG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZTogR2V0VmFsdWU8QywgSywgRywgVj47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRyb2xzIGhvdyB2YWx1ZXMgY29tcGFyZSBhZ2FpbnN0IGVhY2ggb3RoZXIuXG4gICAgICAgICAqIEBwYXJhbSBsaHMgXG4gICAgICAgICAqIEBwYXJhbSByaHMgXG4gICAgICAgICAqL1xuICAgICAgICBjb21wYXJlOiBDb21wYXJlPFY+O1xuICAgIH1cbn1cblxuXG5cbi8qKlxuICogSG9vayB0aGF0IGFsbG93cyBmb3IgdGhlICoqZGlyZWN0IGRlc2NlbmRhbnQqKiBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCB0byBiZSByZS1vcmRlcmVkIGFuZCBzb3J0ZWQuXG4gKiBcbiAqICpUaGlzIGlzICoqc2VwYXJhdGUqKiBmcm9tIFwibWFuYWdlZFwiIGNoaWxkcmVuLCB3aGljaCBjYW4gYmUgYW55IGxldmVsIG9mIGNoaWxkIG5lZWRlZCEgU29ydGFibGUvcmVhcnJhbmdlYWJsZSBjaGlsZHJlbiBtdXN0IGJlICoqZGlyZWN0IGRlc2NlbmRhbnRzKiogb2YgdGhlIHBhcmVudCB0aGF0IHVzZXMgdGhpcyBob29rISpcbiAqIFxuICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBpbiBjb25qdW5jdGlvbiB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbmA7IGl0IHRha2VzIHRoZSBzYW1lIGBpbmRleE1hbmdsZXJgIGFuZCBgaW5kZXhEZW1hbmdsZXJgIFxuICogZnVuY3Rpb25zIHRoYXQgdGhpcyBob29rIHJldHVybnMuIGB1c2VMaXN0TmF2aWdhdGlvbmAgZG9lcyBub3QgZGlyZWN0bHkgdXNlIHRoaXMgaG9vayBiZWNhdXNlLCBhcyBtZW50aW9uZWQsIFxuICogdGhpcyBob29rIGltcG9zZXMgc2VyaW91cyByZXN0cmljdGlvbnMgb24gY2hpbGQgc3RydWN0dXJlLCB3aGlsZSBgdXNlTGlzdE5hdmlnYXRpb25gIGFsbG93cyBhbnl0aGluZy5cbiAqIFxuICogQmVzaWRlcyB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayB0aGF0J3MgcmV0dXJuZWQsIHRoZSBgc29ydGAgZnVuY3Rpb24gdGhhdCdzIHJldHVybmVkIHdpbGxcbiAqIHNvcnQgYWxsIGNoaWxkcmVuIGFjY29yZGluZyB0byB0aGVpciB2YWx1ZSBmcm9tIHRoZSBgZ2V0VmFsdWVgIGFyZ3VtZW50IHlvdSBwYXNzIGluLlxuICogXG4gKiBJZiB5b3Ugd2FudCB0byBwZXJmb3JtIHNvbWUgcmUtb3JkZXJpbmcgb3BlcmF0aW9uIHRoYXQncyAqbm90KiBhIHNvcnQsIHlvdSBjYW4gbWFudWFsbHlcbiAqIHJlLW1hcCBlYWNoIGNoaWxkJ3MgcG9zaXRpb24gdXNpbmcgYG1hbmdsZU1hcGAgYW5kIGBkZW1hbmdsZU1hcGAsIHdoaWNoIGNvbnZlcnQgYmV0d2VlblxuICogc29ydGVkIGFuZCB1bnNvcnRlZCBpbmRleCBwb3NpdGlvbnMuXG4gKiBcbiAqIEFnYWluLCB1bmxpa2Ugc29tZSBvdGhlciBob29rcywgKip0aGVzZSBjaGlsZHJlbiBtdXN0IGJlIGRpcmVjdCBkZXNjZW5kYW50cyoqLiBUaGlzIGlzIGJlY2F1c2VcbiAqIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIGluc3BlY3RzIHRoZSBnaXZlbiBjaGlsZHJlbiwgdGhlbiByZS1jcmVhdGVzIHRoZW0gd2l0aCBuZXcgYGtleWBzLlxuICogQmVjYXVzZSBrZXlzIGFyZSBnaXZlbiBzcGVjaWFsIHRyZWF0bWVudCBhbmQgYSBjaGlsZCBoYXMgbm8gd2F5IG9mIG1vZGlmeWluZyBpdHMgb3duIGtleVxuICogdGhlcmUncyBubyBvdGhlciB0aW1lIG9yIHBsYWNlIHRoaXMgY2FuIGhhcHBlbiBvdGhlciB0aGFuIGV4YWN0bHkgd2l0aGluIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleCB9IH06IFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSz4pOiBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQsIEMsIEs+IHtcblxuICAgIC8vIFRoZXNlIGFyZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgYSBtYXBwaW5nIGJldHdlZW4gdW5zb3J0ZWQgaW5kZXggPC0tLT4gc29ydGVkIGluZGV4LlxuICAgIC8vIFRoZXNlIGFyZSBuZWVkZWQgZm9yIG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cy5cbiAgICBjb25zdCBtYW5nbGVNYXAgPSB1c2VSZWYobmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKSk7XG4gICAgY29uc3QgZGVtYW5nbGVNYXAgPSB1c2VSZWYobmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKSk7XG4gICAgY29uc3QgaW5kZXhNYW5nbGVyID0gdXNlQ2FsbGJhY2soKG46IG51bWJlcikgPT4gKG1hbmdsZU1hcC5jdXJyZW50LmdldChuKSA/PyBuKSwgW10pO1xuICAgIGNvbnN0IGluZGV4RGVtYW5nbGVyID0gdXNlQ2FsbGJhY2soKG46IG51bWJlcikgPT4gKGRlbWFuZ2xlTWFwLmN1cnJlbnQuZ2V0KG4pID8/IG4pLCBbXSk7XG5cbiAgICAvLyBUaGUgc29ydCBmdW5jdGlvbiBuZWVkcyB0byBiZSBhYmxlIHRvIHVwZGF0ZSB3aG9ldmVyIGhhcyBhbGwgdGhlIHNvcnRhYmxlIGNoaWxkcmVuLlxuICAgIC8vIEJlY2F1c2UgdGhhdCBtaWdodCBub3QgYmUgdGhlIGNvbnN1bWVyIG9mICp0aGlzKiBob29rIGRpcmVjdGx5IChlLmcuIGEgdGFibGUgdXNlc1xuICAgIC8vIHRoaXMgaG9vaywgYnV0IGl0J3MgdGJvZHkgdGhhdCBhY3R1YWxseSBuZWVkcyB1cGRhdGluZyksIHdlIG5lZWQgdG8gcmVtb3RlbHlcbiAgICAvLyBnZXQgYW5kIHNldCBhIGZvcmNlVXBkYXRlIGZ1bmN0aW9uLlxuICAgIC8vY29uc3QgW2dldEZvcmNlVXBkYXRlLCBzZXRGb3JjZVVwZGF0ZV0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCwgcmV0dXJuTnVsbCk7XG4gICAgY29uc3QgW2dldEZvcmNlVXBkYXRlLCBzZXRGb3JjZVVwZGF0ZV0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCwgcmV0dXJuTnVsbCk7XG5cbiAgICBjb25zdCByZWFycmFuZ2UgPSB1c2VDYWxsYmFjaygoc29ydGVkUm93czogTWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+W10pID0+IHtcblxuICAgICAgICAvLyBVcGRhdGUgb3VyIHNvcnRlZCA8LS0+IHVuc29ydGVkIGluZGljZXMgbWFwIFxuICAgICAgICAvLyBhbmQgcmVyZW5kZXIgdGhlIHdob2xlIHRhYmxlLCBiYXNpY2FsbHlcbiAgICAgICAgZm9yIChsZXQgaW5kZXhBc1NvcnRlZCA9IDA7IGluZGV4QXNTb3J0ZWQgPCBzb3J0ZWRSb3dzLmxlbmd0aDsgKytpbmRleEFzU29ydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleEFzVW5zb3J0ZWQgPSBzb3J0ZWRSb3dzW2luZGV4QXNTb3J0ZWRdLmluZGV4O1xuXG4gICAgICAgICAgICBtYW5nbGVNYXAuY3VycmVudC5zZXQoaW5kZXhBc1Vuc29ydGVkLCBpbmRleEFzU29ydGVkKTtcbiAgICAgICAgICAgIGRlbWFuZ2xlTWFwLmN1cnJlbnQuc2V0KGluZGV4QXNTb3J0ZWQsIGluZGV4QXNVbnNvcnRlZCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGdldEZvcmNlVXBkYXRlKCk/LigpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHVzZVJlYXJyYW5nZWFibGVQcm9wcyA9IHVzZUNhbGxiYWNrKCh7IGNoaWxkcmVuLCAuLi5wcm9wcyB9OiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbj86IFZOb2RlPGFueT5bXSB9KSA9PiB7XG5cbiAgICAgICAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBzZXRGb3JjZVVwZGF0ZShfcHJldiA9PiBmb3JjZVVwZGF0ZSk7IH0sIFtmb3JjZVVwZGF0ZV0pXG5cbiAgICAgICAgcmV0dXJuICh1c2VNZXJnZWRQcm9wczxQYXJlbnRFbGVtZW50Pih7XG4gICAgICAgICAgICBjaGlsZHJlbjpcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4gYXMgVk5vZGU8TWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+PltdKVxuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGNoaWxkID0+ICh7IGNoaWxkLCBtYW5nbGVkSW5kZXg6IGluZGV4TWFuZ2xlcihnZXRJbmRleChjaGlsZC5wcm9wcyEpISksIGRlbWFuZ2xlZEluZGV4OiBnZXRJbmRleChjaGlsZC5wcm9wcykgfSkpXG4gICAgICAgICAgICAgICAgICAgIC5zb3J0KChsaHMsIHJocykgPT4geyByZXR1cm4gbGhzLm1hbmdsZWRJbmRleCAtIHJocy5tYW5nbGVkSW5kZXggfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoeyBjaGlsZCwgbWFuZ2xlZEluZGV4LCBkZW1hbmdsZWRJbmRleCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaChjaGlsZC50eXBlIGFzIGFueSwgeyAuLi5jaGlsZC5wcm9wcywga2V5OiBkZW1hbmdsZWRJbmRleCwgXCJkYXRhLW1hbmdsZWQtaW5kZXhcIjogbWFuZ2xlZEluZGV4LCBcImRhdGEtdW5tYW5nbGVkLWluZGV4XCI6IGRlbWFuZ2xlZEluZGV4IH0pO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LCBwcm9wcykpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7IHVzZVJlYXJyYW5nZWFibGVQcm9wcywgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGluZGV4TWFuZ2xlciwgaW5kZXhEZW1hbmdsZXIsIG1hbmdsZU1hcCwgZGVtYW5nbGVNYXAsIHJlYXJyYW5nZSB9IH07XG59XG5cblxuLyoqXG4gKiBIb29rIHRoYXQgYWxsb3dzIGZvciB0aGUgKipkaXJlY3QgZGVzY2VuZGFudCoqIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IHRvIGJlIHJlLW9yZGVyZWQgYW5kIHNvcnRlZC5cbiAqIFxuICogKlRoaXMgaXMgKipzZXBhcmF0ZSoqIGZyb20gXCJtYW5hZ2VkXCIgY2hpbGRyZW4sIHdoaWNoIGNhbiBiZSBhbnkgbGV2ZWwgb2YgY2hpbGQgbmVlZGVkISBTb3J0YWJsZS9yZWFycmFuZ2VhYmxlIGNoaWxkcmVuIG11c3QgYmUgKipkaXJlY3QgZGVzY2VuZGFudHMqKiBvZiB0aGUgcGFyZW50IHRoYXQgdXNlcyB0aGlzIGhvb2shKiBcbiAqIFxuICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBpbiBjb25qdW5jdGlvbiB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbmA7IGl0IHRha2VzIHRoZSBzYW1lIGBpbmRleE1hbmdsZXJgIGFuZCBgaW5kZXhEZW1hbmdsZXJgIFxuICogZnVuY3Rpb25zIHRoYXQgdGhpcyBob29rIHJldHVybnMuIGB1c2VMaXN0TmF2aWdhdGlvbmAgZG9lcyBub3QgZGlyZWN0bHkgdXNlIHRoaXMgaG9vayBiZWNhdXNlLCBhcyBtZW50aW9uZWQsIFxuICogdGhpcyBob29rIGltcG9zZXMgc2VyaW91cyByZXN0cmljdGlvbnMgb24gY2hpbGQgc3RydWN0dXJlLCB3aGlsZSBgdXNlTGlzdE5hdmlnYXRpb25gIGFsbG93cyBhbnl0aGluZy5cbiAqIFxuICogQmVzaWRlcyB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayB0aGF0J3MgcmV0dXJuZWQsIHRoZSBgc29ydGAgZnVuY3Rpb24gdGhhdCdzIHJldHVybmVkIHdpbGxcbiAqIHNvcnQgYWxsIGNoaWxkcmVuIGFjY29yZGluZyB0byB0aGVpciB2YWx1ZSBmcm9tIHRoZSBgZ2V0VmFsdWVgIGFyZ3VtZW50IHlvdSBwYXNzIGluLlxuICogXG4gKiBJZiB5b3Ugd2FudCB0byBwZXJmb3JtIHNvbWUgcmUtb3JkZXJpbmcgb3BlcmF0aW9uIHRoYXQncyAqbm90KiBhIHNvcnQsIHlvdSBjYW4gbWFudWFsbHlcbiAqIHJlLW1hcCBlYWNoIGNoaWxkJ3MgcG9zaXRpb24gdXNpbmcgYG1hbmdsZU1hcGAgYW5kIGBkZW1hbmdsZU1hcGAsIHdoaWNoIGNvbnZlcnQgYmV0d2VlblxuICogc29ydGVkIGFuZCB1bnNvcnRlZCBpbmRleCBwb3NpdGlvbnMuXG4gKiBcbiAqIEFnYWluLCB1bmxpa2Ugc29tZSBvdGhlciBob29rcywgKip0aGVzZSBjaGlsZHJlbiBtdXN0IGJlIGRpcmVjdCBkZXNjZW5kYW50cyoqLiBUaGlzIGlzIGJlY2F1c2VcbiAqIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIGluc3BlY3RzIHRoZSBnaXZlbiBjaGlsZHJlbiwgdGhlbiByZS1jcmVhdGVzIHRoZW0gd2l0aCBuZXcgYGtleWBzLlxuICogQmVjYXVzZSBrZXlzIGFyZSBnaXZlbiBzcGVjaWFsIHRyZWF0bWVudCBhbmQgYSBjaGlsZCBoYXMgbm8gd2F5IG9mIG1vZGlmeWluZyBpdHMgb3duIGtleVxuICogdGhlcmUncyBubyBvdGhlciB0aW1lIG9yIHBsYWNlIHRoaXMgY2FuIGhhcHBlbiBvdGhlciB0aGFuIGV4YWN0bHkgd2l0aGluIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWPih7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleCB9LCBzb3J0YWJsZUNoaWxkcmVuOiB7IGNvbXBhcmU6IHVzZXJDb21wYXJlLCBnZXRWYWx1ZSB9IH06IFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEssIEcsIFY+KTogVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQywgSywgRz4ge1xuXG4gICAgY29uc3QgY29tcGFyZSA9ICh1c2VyQ29tcGFyZSA/PyBkZWZhdWx0Q29tcGFyZSk7XG5cbiAgICBjb25zdCB7IHVzZVJlYXJyYW5nZWFibGVQcm9wczogdXNlU29ydGFibGVQcm9wcywgLi4ucmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZSB9ID0gdXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQsIEMsIEs+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4IH0gfSk7XG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgcmVhcnJhbmdlIH0gfSA9IHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGU7XG4gICAgLy8gVGhlIGFjdHVhbCBzb3J0IGZ1bmN0aW9uLlxuICAgIGNvbnN0IHNvcnQgPSB1c2VDYWxsYmFjaygobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+LCBkaXJlY3Rpb246IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIiwgLi4uYXJnczogRyk6IFByb21pc2U8dm9pZD4gfCB2b2lkID0+IHtcblxuICAgICAgICBjb25zdCBzb3J0ZWRSb3dzID0gbWFuYWdlZFJvd3MuYXJyYXlTbGljZSgpLnNvcnQoKGxoc1JvdywgcmhzUm93KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGxoc1ZhbHVlID0gZ2V0VmFsdWUobGhzUm93LCAuLi5hcmdzKSBhcyBhbnk7XG4gICAgICAgICAgICBjb25zdCByaHNWYWx1ZSA9IGdldFZhbHVlKHJoc1JvdywgLi4uYXJncykgYXMgYW55O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZShsaHNWYWx1ZSwgcmhzVmFsdWUpIC8vIGxoc1Jvdy5nZXRNYW5hZ2VkQ2VsbHMoKT8uW2NvbHVtbl0/LnZhbHVlLCByaHNSb3cuZ2V0TWFuYWdlZENlbGxzKCk/Lltjb2x1bW5dPy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uWzBdID09IFwiZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiAtcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVhcnJhbmdlKHNvcnRlZFJvd3MpO1xuXG4gICAgfSwgWyAvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuICAgIGNvbnN0IHNodWZmbGUgPSB1c2VDYWxsYmFjaygobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+KTogUHJvbWlzZTx2b2lkPiB8IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBzaHVmZmxlZFJvd3MgPSBsb2Rhc2hTaHVmZmxlKG1hbmFnZWRSb3dzLmFycmF5U2xpY2UoKSlcbiAgICAgICAgcmV0dXJuIHJlYXJyYW5nZShzaHVmZmxlZFJvd3MpO1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW46IHsgc29ydCwgc2h1ZmZsZSB9LFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGUucmVhcnJhbmdlYWJsZUNoaWxkcmVuXG4gICAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXNzIGFuIGFycmF5IG9mIG5vdC1zb3J0ZWQgY2hpbGQgaW5mb3JtYXRpb24gdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICAgKiBhbmQgdGhlIGNoaWxkcmVuIHdpbGwgcmUtYXJyYW5nZSB0aGVtc2VsdmVzIHRvIG1hdGNoLlxuICAgICAgICAgKiAgXG4gICAgICAgICAqICoqU1RBQkxFKipcbiAgICAgICAgICogIFxuICAgICAgICAgKiBcbiAgICAgICAgICovXG4gICAgICAgIHJlYXJyYW5nZTogKHJvd3NJbk9yZGVyOiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz5bXSkgPT4gdm9pZDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgaW5kZXhNYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGluZGV4RGVtYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIG1hbmdsZU1hcDogTXV0YWJsZVJlZjxNYXA8bnVtYmVyLCBudW1iZXI+PjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZGVtYW5nbGVNYXA6IE11dGFibGVSZWY8TWFwPG51bWJlciwgbnVtYmVyPj47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSz4ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlUmVhcnJhbmdlYWJsZVByb3BzOiAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuPzogVk5vZGU8YW55PltdIHwgdW5kZWZpbmVkOyB9KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PjtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSz4ge1xuICAgIHNvcnRhYmxlQ2hpbGRyZW46IHsvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBzb3J0OiAobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+LCBkaXJlY3Rpb246IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIiwgLi4uYXJnczogRykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNodWZmbGU6IChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4pID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAgIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kc1xuICAgIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLLCBHPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VTb3J0YWJsZVByb3BzOiAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuPzogVk5vZGU8YW55PltdIHwgdW5kZWZpbmVkOyB9KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50Pjtcbn1cblxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShsaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29tcGFyZTEobGhzLCByaHMpO1xuXG4gICAgZnVuY3Rpb24gY29tcGFyZTMobGhzOiBzdHJpbmcgfCBudW1iZXIsIHJoczogc3RyaW5nIHwgbnVtYmVyKSB7XG5cbiAgICAgICAgLy8gQ29lcmNlIHN0cmluZ3MgdG8gbnVtYmVycyBpZiB0aGV5IHNlZW0gdG8gc3RheSB0aGUgc2FtZSB3aGVuIHNlcmlhbGl6ZWRcbiAgICAgICAgaWYgKGAkeytsaHN9YCA9PT0gbGhzKVxuICAgICAgICAgICAgbGhzID0gK2xocztcbiAgICAgICAgaWYgKGAkeytyaHN9YCA9PT0gcmhzKVxuICAgICAgICAgICAgcmhzID0gK3JocztcblxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBpZiBlaXRoZXIgYXJndW1lbnQgaXMgYSBzdHJpbmcsIHR1cm4gdGhlIG90aGVyIG9uZSBpbnRvIG9uZSB0b29cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByaHMgPSBgJHtyaHN9YDtcbiAgICAgICAgaWYgKHR5cGVvZiByaHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBsaHMgPSBgJHtsaHN9YDtcblxuICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgbGhzID09PSB0eXBlb2YgcmhzKTtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBsaHMubG9jYWxlQ29tcGFyZShyaHMgYXMgc3RyaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gK2xocyAtICtyaHM7XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUyKGxoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUsIHJoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwiYm9vbGVhblwiIHx8IGxocyBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgICBsaHMgPSArbGhzO1xuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gXCJib29sZWFuXCIgfHwgcmhzIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgIHJocyA9ICtyaHM7XG4gICAgICAgIHJldHVybiBjb21wYXJlMyhsaHMsIHJocyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUxKGxoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkLCByaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBudWxsXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCB8fCByaHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gT25lIG9mIHRoZSB0d28gaXMgbnVsbCAtLSBlYXN5IGNhc2VcbiAgICAgICAgICAgIHJldHVybiBsaHMgIT0gbnVsbCA/IDEgOiAtMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wYXJlMihsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VDaGlsZHJlbkhhdmVGb2N1cywgVXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XG5pbXBvcnQgeyBDaGlsZEZsYWdPcGVyYXRpb25zLCBNYW5hZ2VkQ2hpbGRPbWl0cywgTWFuYWdlZENoaWxkcmVuLCBNYW5hZ2VkQ2hpbGRyZW5PbWl0cywgdXNlQ2hpbGRyZW5GbGFnIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCIuL3VzZS1lZmZlY3RcIjtcbmltcG9ydCB7IExpbmVhck5hdmlnYXRpb25PbWl0cywgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCB1c2VMaW5lYXJOYXZpZ2F0aW9uLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIHVzZVJvdmluZ1RhYkluZGV4LCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycywgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvLCBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm8sIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbyB9IGZyb20gXCIuL3VzZS1yb3ZpbmctdGFiaW5kZXhcIjtcbmltcG9ydCB7IHVzZVNvcnRhYmxlQ2hpbGRyZW4sIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2Utc29ydGFibGUtY2hpbGRyZW5cIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5cblxuLyoqXG4gKiBcbiAqIFRPRE86IFRoaXMgdGFibGUgd2FzIHNjcmFwcGVkIHdoZW4gdGhpcyB3YXMgY2hhbmdlZCB0byBqdXN0IGFjY2VwdCBhIGNvbGxhdG9yIGRpcmVjdGx5LFxuICogYnV0IGl0J3Mgbm90IGJhZCBmb3IgYSBjb2xsYXRpb24gY3Jhc2ggY291cnNlIGFuZCBJIG1pZ2h0IHVzZSBpdCBhZ2Fpbi5cbiAqIEV2ZW4ganVzdCBhcyBhIFwidGhpcyBpcyB3aHkgaXQncyBpbXBvcnRhbnQgYW5kIGdvb2QgdG8gdXNlIHRoZXNlIHRoaW5nc1wiIHRoaW5nLlxuICogXG4gKiB8TGFuZy58VGFyZ2V0fFVzZXIgaW5wdXR8YGJhc2VgfGBhY2NlbnRgfGBjYXNlYHxgdmFyaWFudGB8XG4gKiB8LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXxcbiAqIHxFTnxIaXxCeWV84p2MfOKdjHzinYx84p2MfFxuICogfEVOfEhpfEhpfOKchXzinIV84pyFfOKchXxcbiAqIHxFTnxIaXzvvKjvvYl84pyFfOKchXzinIV84p2MfFxuICogfEVOfEhpfGhpfOKchXzinIV84p2MfOKdjHxcbiAqIHxFTnxIaXxIw6984pyFfOKdjHzinYx84p2MfFxuICogfEVOfMOlfGFhfOKdjHzinYx84p2MfOKdjHxcbiAqIHxEQXzDpXxhYXzinIV84pyFfOKchXzinYx8XG4gKiB8REF8w6V8QUF84pyFfOKchXzinYx84p2MfFxuICogfERBfMOlfEFhfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxhQXzinYx84p2MfOKdjHzinYx8XG4gKiB8RU58w6V8YXzinIV84pyFfOKdjHzinYx8XG4gKiB8REF8w6V8YXzinIV84pyFfOKdjHzinYx8XG4gKiB8SlB876qqfOedgHzinIV84pyFfOKchXzinIV8XG4gKiB8SlB844KrfO+9tnzinIV84pyFfOKchXzinIV8XG4gKiB8SlB844KrfOOBi3zinIV84pyFfOKchXzinYx8XG4gKiB8SlB844KrfOODtXzinIV84pyFfOKchXzinYx8XG4gKiB8SlB844KrfOOLlXzinIV84pyFfOKdjHzinYx8XG4gKiB8SlB844KrfOOCrHzinIV84p2MfOKdjHzinYx8XG4gKiB8SlB844KrfOWKm3zinYx84p2MfOKdjHzinYx8XG4gKiB8Wkh857SFfOe6onzinYx84p2MfOKdjHzinYx8XG4gKiBcbiAqIFxuICogKE5vdGUgdG8gc2VsZjogQXQgc29tZSBwb2ludCwgdGhpcyBmaWxlIHdpbGwgcHJvYmFibHkgYmUgbm9ybWFsaXplZFxuICogYnkgc29tZWJvZHkgYW5kIO+qqiB3aWxsIHR1cm4gYmFjayBpbnRvIOedgC4pXG4gKiBcbiAqL1xuY29uc3QgX2R1bW15OiBhbnkgPSBudWxsO1xuXG5cbmZ1bmN0aW9uIGlkZW50aXR5PFQ+KHQ6IFQpIHsgcmV0dXJuIHQ7IH1cbnR5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+O1xuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88Qz4ge1xuICAgIHRleHQ6IHN0cmluZztcblxuICAgIHN1YkluZm86IEM7XG59XG5cbi8qKlxuICogQHBhcmFtIGZyb21Vc2VySW50ZXJhY3Rpb24gV2hldGhlciB0aGUgdXNlciBpbnRlcmFjdGVkIHdpdGggdGhpcyBjaGlsZCBhcyBhIG1lYW5zIG9mIG5hdmlnYXRpbmcgdG8gaXQuICBJbiB0aGF0IHdhcyB0aGUgY2FzZSwgdGhlIGNoaWxkIGlzIGFsc28gZm9jdXNlZC4gT3RoZXJ3aXNlLCBmb2N1cyBtb3ZlcyBhcyB0aGUgYnJvd3NlciBkZXRlcm1pbmVzLlxuICovXG5leHBvcnQgdHlwZSBOYXZpZ2F0ZVRvSW5kZXggPSAoaTogbnVtYmVyIHwgbnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4gdm9pZDtcblxuXG5pbnRlcmZhY2UgTFNQIHtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgYW5kIGluZGV4RGVtYW5nbGVyIGFyZSB1c2VkIHRvIGFsbG93IGNoaWxkcmVuIHRvIGJlIG5hdmlnYXRlZCBpbiBhbiBvcmRlclxuICAgICAqIHRoYXQgZG9lc24ndCBuZWNlc3NhcmlseSBtYXRjaCB0aGVpciBjaGlsZCBvcmRlciwgbGlrZSBpZiBhIGxpc3QgaXMgc29ydGVkLlxuICAgICAqIFxuICAgICAqIFVzZWQgdG8gdHVybiBhbiBcImFic29sdXRlXCIgaW5kZXggaW50byBhIFwic29ydGVkL2ZpbHRlcmVkL21hbmdsZWRcIiBvbmUuXG4gICAgICogXG4gICAgICogRm9yIGV4YW1wbGUsIG5hdmlnYXRlVG9GaXJzdCBtYW5nbGVzIDAgYW5kIG5hdmlnYXRlcyB0byB0aGF0IHJlc3VsdGluZyByb3cuXG4gICAgICogQHBhcmFtIHJhd0luZGV4IFxuICAgICAqL1xuICAgIGluZGV4TWFuZ2xlcj8ocmF3SW5kZXg6IG51bWJlcik6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gdHVybiBhIFwibWFuZ2xlZFwiIGluZGV4IGludG8gaXQncyBcInVuc29ydGVkXCIgb3IgXCJ1bm1hbmdsZWRcIiBpbmRleC5cbiAgICAgKiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgd2hlbiBpbmNyZW1lbnRpbmcgb3IgZGVjcmVtZW50aW5nIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaW5kZXgsXG4gICAgICogaXQgbmVlZHMgdG8gYmUgZGVtYW5nbGVkIHRvIGRvIFwibm9ybWFsXCIgbWF0aCBvbiBpdCwgYW5kIHRoZW4gcmUtbWFuZ2xlZCAoYWJvdmUpXG4gICAgICogdG8gdHVybiB0aGF0IGFic29sdXRlIHJvdyBpbmRleCBiYWNrIGludG8gYSBtYW5nbGVkIG9uZS5cbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtZWRJbmRleCBcbiAgICAgKi9cbiAgICBpbmRleERlbWFuZ2xlcj8odHJhbnNmb3JtZWRJbmRleDogbnVtYmVyKTogbnVtYmVyO1xufVxuXG5leHBvcnQgdHlwZSBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cyA9IGtleW9mIExTUDtcblxuLy8gKioqIFBhcmFtZXRlcnMgKGxpc3QsIGxpc3Qtc2luZ2xlLCBsaXN0LWNoaWxkLCBsaXN0LXNpbmdsZS1jaGlsZClcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzXG4gICAgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPFJ0aU9taXRzLCBNY09taXRzPixcbiAgICBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxUbk9taXRzIHwgXCJnZXRJbmRleFwiIHwgXCJzZXRJbmRleFwiPixcbiAgICBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxMbk9taXRzIHwgXCJuYXZpZ2F0ZVRvRmlyc3RcIiB8IFwibmF2aWdhdGVUb0xhc3RcIiB8IFwibmF2aWdhdGVUb05leHRcIiB8IFwibmF2aWdhdGVUb1ByZXZcIj4ge1xuICAgIGxpc3ROYXZpZ2F0aW9uOiBPbWl0PExTUCwgTHNPbWl0cz47XG59XG5cbmludGVyZmFjZSBTU1Age1xuICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7XG59XG5leHBvcnQgdHlwZSBTaW5nbGVTZWxlY3Rpb25PbWl0cyA9IGtleW9mIFNTUDtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8U1NPbWl0cyBleHRlbmRzIFNpbmdsZVNlbGVjdGlvbk9taXRzLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cywgTG5PbWl0cywgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IE9taXQ8U1NQLCBTU09taXRzPjtcbiAgICBjaGlsZHJlbkhhdmVGb2N1czogUGFydGlhbDxVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnNbXCJjaGlsZHJlbkhhdmVGb2N1c1wiXT47XG59XG5leHBvcnQgdHlwZSBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMgPSBrZXlvZiBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88YW55PjtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxFLCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cywgUnRpT21pdHMsIE1jT21pdHMsIFN1YmJlc3RJbmZvPiB7XG4gICAgLy9yb3ZpbmdUYWJJbmRleDogT21pdDxVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cywgbmV2ZXI+W1wicm92aW5nVGFiSW5kZXhcIl0sIFwic3ViSW5mb1wiPjtcbiAgICBsaXN0TmF2aWdhdGlvbjogT21pdDxVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgTHNPbWl0cyB8IFwic3ViSW5mb1wiPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8RSwgQywgSyB8IFwic2VsZWN0ZWRcIiwgTHNPbWl0cywgUnRpT21pdHMsIE1jT21pdHMsIFN1YmJlc3RJbmZvPiB7XG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxFPjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPj4sIFwidGFiYmFibGVcIiB8IEV4dHJhRmxhZ0tleXM+LCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4OiBOYXZpZ2F0ZVRvSW5kZXggfTtcbn1cblxuLy8gKioqIFJldHVybiB0eXBlcyAobGlzdCwgbGlzdC1zaW5nbGUsIGxpc3QtY2hpbGQsIGxpc3Qtc2luZ2xlLWNoaWxkKVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcbiAgICBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG5cbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+O1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcbiAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IHt9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz5bXCJ1c2VMaXN0TmF2aWdhdGlvblByb3BzXCJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IHtcbiAgICAgICAgc2VsZWN0ZWQ6IGJvb2xlYW47XG4gICAgICAgIGdldFNlbGVjdGVkKCk6IGJvb2xlYW47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wczogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PltcInVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wc1wiXTtcbn1cblxuXG5leHBvcnQgdHlwZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQz4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5cbmV4cG9ydCB0eXBlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcblxuXG5cbi8qKlxuICogSW1wbGVtZW50cyBwcm9wZXIga2V5Ym9hcmQgbmF2aWdhdGlvbiBmb3IgY29tcG9uZW50cyBsaWtlIGxpc3Rib3hlcywgYnV0dG9uIGdyb3VwcywgbWVudXMsIGV0Yy5cbiAqIFxuICogSW4gdGhlIGRvY3VtZW50IG9yZGVyLCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIFwiZm9jdXNlZFwiIG9yIFwidGFiYmFibGVcIiBlbGVtZW50LCBtYWtpbmcgaXQgYWN0IG1vcmUgbGlrZSBvbmUgY29tcGxldGUgdW5pdCBpbiBjb21wYXJpc29uIHRvIGV2ZXJ5dGhpbmcgYXJvdW5kIGl0LlxuICogTmF2aWdhdGluZyBmb3J3YXJkcy9iYWNrd2FyZHMgY2FuIGJlIGRvbmUgd2l0aCB0aGUgYXJyb3cga2V5cywgSG9tZS9FbmQga2V5cywgb3IgYW55IGFueSB0ZXh0IGZvciB0eXBlYWhlYWQgdG8gZm9jdXMgdGhlIG5leHQgaXRlbSB0aGF0IG1hdGNoZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4oe1xuICAgIG1hbmFnZWRDaGlsZHJlbjogbWMsXG4gICAgcm92aW5nVGFiSW5kZXgsXG4gICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxuICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblxufTogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG4gICAgaW5kZXhNYW5nbGVyID8/PSBpZGVudGl0eTtcbiAgICBpbmRleERlbWFuZ2xlciA/Pz0gaWRlbnRpdHk7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VMaXN0TmF2aWdhdGlvblwiLCBpbmRleE1hbmdsZXIsIGluZGV4RGVtYW5nbGVyKTtcblxuXG4gICAgY29uc3QgcGFyZW50UmV0dXJuVHlwZSA9IHVzZVJvdmluZ1RhYkluZGV4PENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXM+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtYyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0sIHJvdmluZ1RhYkluZGV4OiB7IGdldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXggfSB9ID0gcGFyZW50UmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IG5hdmlnYXRlVG9JbmRleCA9IHVzZUNhbGxiYWNrKChpOiBudW1iZXIgfCBudWxsLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmIChpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRyeU5hdmlnYXRlVG9JbmRleCh7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpLFxuICAgICAgICAgICAgICAgIHNlYXJjaERpcmVjdGlvbjogMSxcbiAgICAgICAgICAgICAgICBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSxcbiAgICAgICAgICAgICAgICBpbmRleERlbWFuZ2xlcjogaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4LCBmcm9tVXNlckludGVyYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxuICAgICAgICAgICAgaW52YWxpZFR5cGVhaGVhZFxuICAgICAgICB9XG4gICAgfSA9IHVzZVR5cGVhaGVhZE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHtcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgZ2V0SW5kZXg6IGdldFRhYmJhYmxlSW5kZXgsXG4gICAgICAgICAgICBzZXRJbmRleDogdXNlQ2FsbGJhY2soKGluZGV4OiAobnVtYmVyIHwgbnVsbCkgfCAoKHByZXY6IG51bWJlciB8IG51bGwpID0+IChudW1iZXIgfCBudWxsKSkpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGluZGV4LCB0cnVlKTtcbiAgICAgICAgICAgIH0sIFtdKSxcbiAgICAgICAgICAgIC4uLnR5cGVhaGVhZE5hdmlnYXRpb25cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHsgdXNlTGluZWFyTmF2aWdhdGlvblByb3BzIH0gPSB1c2VMaW5lYXJOYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2OiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU5hdmlnYXRlVG9JbmRleCh7IGNoaWxkcmVuLCBkZWZhdWx0OiBjID8/IDAsIHRhcmdldDogaW5kZXhEZW1hbmdsZXIhKGluZGV4TWFuZ2xlciEoKGMgPz8gMCkpIC0gMSksIHNlYXJjaERpcmVjdGlvbjogLTEsIGluZGV4TWFuZ2xlcjogaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LCBpbmRleERlbWFuZ2xlcjogaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHkgfSlcbiAgICAgICAgICAgICAgICB9LCB0cnVlKVxuICAgICAgICAgICAgfSwgW10pLFxuICAgICAgICAgICAgbmF2aWdhdGVUb05leHQ6IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5TmF2aWdhdGVUb0luZGV4KHsgY2hpbGRyZW4sIGRlZmF1bHQ6IGMgPz8gMCwgdGFyZ2V0OiBpbmRleERlbWFuZ2xlciEoaW5kZXhNYW5nbGVyIShjID8/IDApICsgMSksIHNlYXJjaERpcmVjdGlvbjogMSwgaW5kZXhNYW5nbGVyOiBpbmRleE1hbmdsZXIgPz8gaWRlbnRpdHksIGluZGV4RGVtYW5nbGVyOiBpbmRleERlbWFuZ2xlciA/PyBpZGVudGl0eSB9KTtcbiAgICAgICAgICAgICAgICB9LCB0cnVlKVxuICAgICAgICAgICAgfSwgW10pLFxuICAgICAgICAgICAgbmF2aWdhdGVUb0ZpcnN0OiB1c2VDYWxsYmFjaygoKSA9PiB7IG5hdmlnYXRlVG9JbmRleChpbmRleERlbWFuZ2xlciEoMCksIHRydWUpOyB9LCBbXSksXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdDogdXNlQ2FsbGJhY2soKCkgPT4geyBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXhEZW1hbmdsZXIhKGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpKSwgdHJ1ZSk7IH0sIFtdKSxcbiAgICAgICAgICAgIC4uLmxpbmVhck5hdmlnYXRpb25cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+ID0+IHtcbiAgICAgICAgcmV0dXJuIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyh1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMocHJvcHMpKTtcbiAgICB9LCBbdXNlTGluZWFyTmF2aWdhdGlvblByb3BzLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHNdKTtcblxuXG4gICAgY29uc3QgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCA9IHVzZUNhbGxiYWNrPFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+PigoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHJvdmluZ1RhYkluZGV4OiB7IGJsdXJTZWxmLCBmb2N1c1NlbGYsIGhpZGRlbiB9LCBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sIHN1YkluZm8gfSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IF92OiB2b2lkID0gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkKHsgdGV4dCwgaW5kZXggfSk7XG4gICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZGV4KTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VGFiYmFibGVJbmRleCgpID09IGdldEluZGV4KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGUsXG4gICAgICAgICAgICAgICAgZ2V0VGFiYmFibGUsXG4gICAgICAgICAgICAgICAgZ2V0RWxlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9ID0gdXNlUm92aW5nVGFiSW5kZXhDaGlsZCh7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW46ICEhaGlkZGVuIH0sXG4gICAgICAgICAgICBzdWJJbmZvOiB7IHRleHQsIHN1YkluZm8gfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+ID0gZnVuY3Rpb24gKHsgLi4ucHJvcHMgfSkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPENoaWxkRWxlbWVudD4odXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzKCgoeyBpbmVydDogaGlkZGVuIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikpKSwgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGUsXG4gICAgICAgICAgICAgICAgZ2V0VGFiYmFibGUsXG4gICAgICAgICAgICAgICAgZ2V0RWxlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3VzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCwgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgbmF2aWdhdGVUb0luZGV4XSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxuXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcGFyZW50UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9XG4gICAgICAgIC8qbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZiwgZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleCB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjdXJyZW50VHlwZWFoZWFkLCBpbnZhbGlkVHlwZWFoZWFkIH0qL1xuICAgIH1cbn1cblxuXG5cblxuXG5cbi8qKlxuICogSXQncyB2ZXJ5IGNvbW1vbiB0byBjb21iaW5lIGEgdGFiYmFibGUgbGlzdCBvZiB0aGluZ3MgYW5kIFwic2VsZWN0aW9uXCIgb2Ygb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqIFxuICogTGlzdHMsIHJhZGlvIGJ1dHRvbnMsIHRhYnMsIGV0Yy4gZXRjLlxuICogXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgdGhhdCBjb21iaW5lcyB0aGUgdHdvIHdpdGggdGhlIGNvcnJlY3QgdHlwaW5nLlxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7XG4gICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXggfSxcbiAgICBsaXN0TmF2aWdhdGlvbixcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLypvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG9jbWMsKi8gLi4ubWMgfSxcbiAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIC4uLnJvdmluZ1RhYkluZGV4IH0sXG4gICAgbGluZWFyTmF2aWdhdGlvbixcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH1cbn06IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPiB7XG4gICAgY29uc3QgcGFyZW50UmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEsgfCBcInNlbGVjdGVkXCI+KHtcbiAgICAgICAgbGlzdE5hdmlnYXRpb24sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjoge1xuICAgICAgICAgICAgLi4ubWMsXG4gICAgICAgICAgICAvKm9uQ2hpbGRyZW5Nb3VudENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25DaGlsZHJlbk1vdW50Q2hhbmdlPG51bWJlcj4+KChtb3VudGVkLCB1bm1vdW50ZWQpID0+IHtcbiAgICAgICAgICAgICAgICByZWV2YWx1YXRlQ2xvc2VzdEZpdCgpO1xuICAgICAgICAgICAgICAgIG9jbWM/Lihtb3VudGVkLCB1bm1vdW50ZWQpO1xuICAgICAgICAgICAgfSkqL1xuICAgICAgICB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgaW5pdGlhbEluZGV4OiAoaW5pdGlhbEluZGV4ID8/IHNlbGVjdGVkSW5kZXggPz8gdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIC8vb25UYWJiZWRPdXRPZjogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBvblRhYmJlZE91dE9mPy4oKTsgc2V0VGFiYmFibGVJbmRleChzZWxlY3RlZEluZGV4LCBmYWxzZSkgfSksXG4gICAgICAgICAgICAuLi5yb3ZpbmdUYWJJbmRleFxuICAgICAgICB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGQgfSA9IHVzZUNoaWxkcmVuSGF2ZUZvY3VzKHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXM6IHtcbiAgICAgICAgICAgIG9uQWxsTG9zdEZvY3VzOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25BbGxMb3N0Rm9jdXM/LigpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoc2VsZWN0ZWRJbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbkFueUdhaW5lZEZvY3VzXG4gICAgICAgIH0sIG1hbmFnZWRDaGlsZHJlbjoge1xuICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLFxuICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgLi4ubGlzdFJlc3RcbiAgICB9ID0gcGFyZW50UmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0sIHJvdmluZ1RhYkluZGV4OiB7IHNldFRhYmJhYmxlSW5kZXggfSB9ID0gbGlzdFJlc3Q7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGNoYW5nZUluZGV4OiBjaGFuZ2VTZWxlY3RlZEluZGV4LFxuICAgICAgICBnZXRDdXJyZW50SW5kZXg6IGdldFNlbGVjdGVkSW5kZXgsXG4gICAgICAgIC8vcmVldmFsdWF0ZUNsb3Nlc3RGaXRcbiAgICB9ID0gdXNlQ2hpbGRyZW5GbGFnPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxDPj4sIEsgfCBcInNlbGVjdGVkXCI+KHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBpbml0aWFsSW5kZXg6IHNlbGVjdGVkSW5kZXgsXG4gICAgICAgIGtleTogXCJzZWxlY3RlZFwiLFxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZVxuICAgIH0pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2hhbmdlU2VsZWN0ZWRJbmRleChzZWxlY3RlZEluZGV4KTtcbiAgICB9LCBbc2VsZWN0ZWRJbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogdXNlQ2FsbGJhY2s8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEsgfCBcInNlbGVjdGVkXCI+PigoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHJvdmluZ1RhYkluZGV4OiBydGksIGxpc3ROYXZpZ2F0aW9uOiBscywgaGFzRm9jdXMsIHN1YkluZm8gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2lzU2VsZWN0ZWQsIHNldElzU2VsZWN0ZWQsIGdldElzU2VsZWN0ZWRdID0gdXNlU3RhdGUoZ2V0U2VsZWN0ZWRJbmRleCgpID09IGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkUmVmID0gdXNlUmVmPENoaWxkRmxhZ09wZXJhdGlvbnM+KHsgZ2V0OiBnZXRJc1NlbGVjdGVkLCBzZXQ6IHNldElzU2VsZWN0ZWQsIGlzVmFsaWQ6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+ICFydGkuaGlkZGVuKSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFByb3BzIH0gPSB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkKHsgLi4uaGFzRm9jdXMsIG1hbmFnZWRDaGlsZDogeyBpbmRleCB9IH0pXG5cbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX3JldCxcbiAgICAgICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHNcbiAgICAgICAgICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZsYWdzXG4gICAgICAgICAgICAgICAgICAgIH0gYXMgUGFydGlhbDxSZWNvcmQ8SyB8IFwic2VsZWN0ZWRcIiB8IFwidGFiYmFibGVcIiwgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxuICAgICAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBscyxcbiAgICAgICAgICAgICAgICBzdWJJbmZvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wczogKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikgPT4gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQcm9wcyhwcm9wcykpKSxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX3JldCxcbiAgICAgICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsIGdldFNlbGVjdGVkOiBnZXRJc1NlbGVjdGVkIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtdKSxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wczogdXNlQ2FsbGJhY2soKC4uLnA6IFBhcmFtZXRlcnM8dHlwZW9mIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM+KSA9PiB7IHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzKC4uLnApIH0sIFtdKSxcbiAgICAgICAgLi4ubGlzdFJlc3QsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjoge31cbiAgICB9XG59XG5cblxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10sIFYsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgfCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiLCBMbk9taXRzLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4sXG4gICAgVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSywgRywgVj4ge1xufVxuXG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHM+ID0gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBMc09taXRzLCBSdGlPbWl0cywgTWNPbWl0cywgQz47XG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXI+KSA9PiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIEMsIEs+LFxuICAgIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLLCBHPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIEMsIEssIEc+IHtcbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD5cbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCB0eXBlYWhlYWROYXZpZ2F0aW9uLCByZWFycmFuZ2VhYmxlQ2hpbGRyZW4sIHNvcnRhYmxlQ2hpbGRyZW4gfTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8QywgSywgRywgViwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSywgRz4ge1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxuICAgICAgICAuLi5zb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVxuICAgIH0gPSB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQsIEMsIEssIEcsIFY+KHtcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuLFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9IH0gPSBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGVcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIC4uLmxpc3ROYXZpZ2F0aW9uIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXg6IHsgc2V0VGFiYmFibGVJbmRleCB9IH0gPSBsaXN0TmF2UmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25Qcm9wcyA9IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4ge1xuICAgICAgICByZXR1cm4gKHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHModXNlU29ydGFibGVQcm9wcyhwcm9wcykpKVxuICAgIH1cbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+ID0gKHApID0+IHtcbiAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQocClcbiAgICB9XG5cbiAgICByZXR1cm4gKHtcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblByb3BzLFxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlLFxuICAgICAgICAuLi5zb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVxuICAgICAgICAvKm1hbmFnZWRDaGlsZHJlbjogbGlzdE5hdlJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogbGlzdE5hdlJldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpc3ROYXZSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBsaXN0TmF2UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogbGlzdE5hdlJldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjogc29ydGFibGVDaGlsZHJlblJldHVyblR5cGUuc29ydGFibGVDaGlsZHJlbixcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZS5yZWFycmFuZ2VhYmxlQ2hpbGRyZW4qL1xuICAgIH0pO1xuXG59XG5cbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhcmdzOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIEM+KSA9PiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFNTT21pdHMgZXh0ZW5kcyBTaW5nbGVTZWxlY3Rpb25PbWl0cywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFNTT21pdHMsIExzT21pdHMgfCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiLCBMbk9taXRzLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSywgRz4sIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzXG4gICAgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSywgRz4ge1xuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PlxuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24sIHR5cGVhaGVhZE5hdmlnYXRpb24sIGNoaWxkcmVuSGF2ZUZvY3VzIH06IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLLCBbXT4ge1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxuICAgICAgICAuLi5zb3J0YWJsZVJldHVyblR5cGVcbiAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50LCBDLCBLLCBbXSwgbnVtYmVyPih7XG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleDogdXNlQ2FsbGJhY2soKHJvdykgPT4gcm93LmluZGV4LCBbXSkgfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjoge1xuICAgICAgICAgICAgZ2V0VmFsdWU6IHVzZUNhbGxiYWNrKChyb3cpID0+IHJvdy5pbmRleCwgW10pLFxuICAgICAgICAgICAgY29tcGFyZTogdXNlQ2FsbGJhY2soKGxocywgcmhzKSA9PiB7IHJldHVybiBsaHMgLSByaHM7IH0sIFtdKSxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9IH0gPSBzb3J0YWJsZVJldHVyblR5cGU7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCAuLi5saXN0TmF2aWdhdGlvbiB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHNpbmdsZVNlbGVjdGlvbixcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXM6IGNoaWxkcmVuSGF2ZUZvY3VzXG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMgPSAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuOiBWTm9kZTxhbnk+W107IH0pID0+IHtcbiAgICAgICAgcmV0dXJuICh1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHVzZVNvcnRhYmxlUHJvcHMocHJvcHMpKSk7XG4gICAgfVxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCA9IChwOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIEM+KSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkKHApO1xuICAgIH1cblxuICAgIHJldHVybiAoe1xuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcbiAgICAgICAgLy9zb3J0YWJsZTogeyBzb3J0LCBzaHVmZmxlLCByZWFycmFuZ2UsIGRlbWFuZ2xlTWFwLCBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCBtYW5nbGVNYXAgfSxcbiAgICAgICAgLi4uc29ydGFibGVSZXR1cm5UeXBlLFxuICAgICAgICAuLi5saXN0TmF2UmV0dXJuVHlwZVxuICAgIH0pO1xuXG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFRyeU5hdmlnYXRlVG9JbmRleFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4ge1xuICAgIGNoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88Qz4+LCBLPjtcbiAgICBkZWZhdWx0OiBudW1iZXI7XG4gICAgdGFyZ2V0OiBudW1iZXI7XG4gICAgc2VhcmNoRGlyZWN0aW9uOiAxIHwgLTE7XG4gICAgaW5kZXhNYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG4gICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJ5TmF2aWdhdGVUb0luZGV4PENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgY2hpbGRyZW4sIHNlYXJjaERpcmVjdGlvbiwgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgdGFyZ2V0IH06IFRyeU5hdmlnYXRlVG9JbmRleFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLPikge1xuICAgIGNvbnN0IHVwcGVyID0gY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCk7XG4gICAgY29uc3QgbG93ZXIgPSAwO1xuXG4gICAgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQgPj0gbG93ZXIgJiYgKGNoaWxkcmVuLmdldEF0KHRhcmdldCkgPT0gbnVsbCkgfHwgISFjaGlsZHJlbi5nZXRBdCh0YXJnZXQpPy5zdWJJbmZvLmhpZGRlbikpXG4gICAgICAgICAgICB0YXJnZXQgPSBpbmRleERlbWFuZ2xlcihpbmRleE1hbmdsZXIodGFyZ2V0KSAtIDEpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQgPCBsb3dlciA/IGluZGV4RGVtYW5nbGVyKGxvd2VyKSA6IHRhcmdldDtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgIHdoaWxlICgodGFyZ2V0IDw9IHVwcGVyICYmIGNoaWxkcmVuLmdldEF0KHRhcmdldCkgPT0gbnVsbCkgfHwgISFjaGlsZHJlbi5nZXRBdCh0YXJnZXQpPy5zdWJJbmZvLmhpZGRlbilcbiAgICAgICAgICAgIHRhcmdldCA9IGluZGV4RGVtYW5nbGVyKGluZGV4TWFuZ2xlcih0YXJnZXQpICsgMSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldCA+IHVwcGVyID8gaW5kZXhEZW1hbmdsZXIodXBwZXIpIDogdGFyZ2V0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvd2VyO1xuICAgIH1cbn1cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBNYW5hZ2VkQ2hpbGRPbWl0cywgTWFuYWdlZENoaWxkcmVuT21pdHMgfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMgfSBmcm9tIFwiLi91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cyB9IGZyb20gXCIuL3VzZS1yb3ZpbmctdGFiaW5kZXhcIjtcbmltcG9ydCB7IHVzZUhhc0ZvY3VzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XG5pbXBvcnQgeyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCB1c2VMaXN0TmF2aWdhdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWxpc3QtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG4vKipcbiAqIEdyaWRzIGFyZSBpbXBsZW1lbnRlZCB1c2luZyB0d28gc2V0cyBvZiBsaXN0IG5hdmlnYXRpb24uXG4gKiBcbiAqIFRoaXMgcmVzdWx0cyBpbiBhIGxvdCBvZiB0aGluZ3Mgd2l0aCB2ZXJ5IHNpbWlsYXIgbmFtZXMgYW5kIGp1c3QgY29uZnVzaW9uIGFsbCBhcm91bmQuIFBsZWFzZSB1c2UgY2F1dGlvbi5cbiAqL1xuXG4vLyBQYXJhbWV0ZXJzIChwYXJlbnQsIHJvdywgY2VsbClcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzIHwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCIsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8XG4gICAgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgQ1IsXG4gICAgS1IgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLFxuICAgIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsXG4gICAgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyxcbiAgICBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLFxuICAgIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyxcblxuICAgIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cyxcbiAgICBSdGlDaGlsZE9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLFxuICAgIE1jQ2hpbGRPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLFxuXG4gICAgU3ViYmVzdEluZm9cbiAgICA+IHtcbiAgICBhc1BhcmVudFJvd09mQ2VsbHM6IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzIHwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCIsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPjtcbiAgICBhc0NoaWxkUm93T2ZTZWN0aW9uOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxSb3dFbGVtZW50LCBDUiwgS1IsIExzQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cywgTWNDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz5cblxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ0MsIEtDIGV4dGVuZHMgc3RyaW5nLCBMc0NoaWxkT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIFJ0aUNoaWxkT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jQ2hpbGRPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4gZXh0ZW5kc1xuICAgIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENlbGxFbGVtZW50LCBDQywgS0MsIExzQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cywgTWNDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4ge1xuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+O1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG4gICAgZ3JpZE5hdmlnYXRpb246IHtcbiAgICAgICAgZ2V0Q3VycmVudENvbHVtbigpOiBudW1iZXIgfCBudWxsO1xuICAgICAgICBjdXJyZW50Q29sdW1uOiBudW1iZXIgfCBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENSLCBDQywgS1IgZXh0ZW5kcyBzdHJpbmcsIEtDIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ1IsIEtSPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25Sb3c6IFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDUiwgQ0MsIEtSLCBLQz47XG4gICAgdXNlR3JpZE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPclJvd0VsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPclJvd0VsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm88Um93IGV4dGVuZHMgRWxlbWVudCwgQ2VsbCBleHRlbmRzIEVsZW1lbnQsIENDLCBLQyBleHRlbmRzIHN0cmluZz4ge1xuICAgIGFzQ2hpbGRSb3c6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxSb3c+O1xuICAgIGFzUGFyZW50T2ZDZWxsczogVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDZWxsLCBDQywgS0M+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3cgZXh0ZW5kcyBFbGVtZW50LCBDZWxsIGV4dGVuZHMgRWxlbWVudCwgQ0MsIEtDIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm88Um93LCBDZWxsLCBDQywgS0M+IHtcbiAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGw6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbDxDZWxsLCBDQywgS0M+O1xuICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2VsbD4ge1xuICAgIGdyaWROYXZpZ2F0aW9uOiB7XG4gICAgICAgIC8vcm93SXNUYWJiYWJsZTogYm9vbGVhbjtcbiAgICAgICAgLy9nZXRSb3dJc1RhYmJhYmxlKCk6IGJvb2xlYW47XG4gICAgICAgIGdldEN1cnJlbnRDb2x1bW4oKTogbnVtYmVyIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGw+O1xufVxuXG5cbmV4cG9ydCB0eXBlIFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvdyBleHRlbmRzIEVsZW1lbnQsIENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDUiwgQ0MsIEtSIGV4dGVuZHMgc3RyaW5nLCBLQyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPFJvdywgQ1IsIEtSLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIENSPikgPT4gVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvdywgQ2VsbCwgQ0MsIEtDPjtcbmV4cG9ydCB0eXBlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbDxDZWxsIGV4dGVuZHMgRWxlbWVudCwgQ0MsIEtDIGV4dGVuZHMgc3RyaW5nPiA9IChwOiBVc2VHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzPENlbGwsIENDLCBLQywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQ0M+KSA9PiBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGw+O1xuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkTmF2aWdhdGlvbjxcbiAgICBQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxuICAgIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxuICAgIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbiAgICBSb3dTdWJJbmZvLFxuICAgIENlbGxTdWJJbmZvLFxuICAgIFJvd0V4dHJhRmxhZ3MgZXh0ZW5kcyBzdHJpbmcsXG4gICAgQ2VsbEV4dHJhRmxhZ3MgZXh0ZW5kcyBzdHJpbmdcbj4oe1xuICAgIG1hbmFnZWRDaGlsZHJlbjogbWMsXG4gICAgcm92aW5nVGFiSW5kZXg6IHJ0aSxcbiAgICBsaXN0TmF2aWdhdGlvbjogbHMsXG4gICAgbGluZWFyTmF2aWdhdGlvbjogbG4sXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdG5cbn06IFVzZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJvd1N1YkluZm8sIENlbGxTdWJJbmZvLCBSb3dFeHRyYUZsYWdzLCBDZWxsRXh0cmFGbGFncz4ge1xuICAgIGNvbnN0IFtjdXJyZW50Q29sdW1uLCBzZXRDdXJyZW50Q29sdW1uLCBnZXRDdXJyZW50Q29sdW1uXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KHJ0aS5pbml0aWFsSW5kZXggPz8gMCk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRBc0dyaWRSb3csXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM6IHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNBc0dyaWRQYXJlbnQsXG4gICAgICAgIC4uLnBhcmVudExzUmV0dXJuVHlwZVxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIFJvd1N1YkluZm8sIFJvd0V4dHJhRmxhZ3M+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtYyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IGxzLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IG5hdmlnYXRpb25EaXJlY3Rpb246IFwiYmxvY2tcIiwgLi4ubG4gfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdG4sXG4gICAgfSk7XG5cblxuICAgIGNvbnN0IHVzZUdyaWROYXZpZ2F0aW9uUm93ID0gdXNlQ2FsbGJhY2s8VXNlR3JpZE5hdmlnYXRpb25Sb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJvd1N1YkluZm8sIENlbGxTdWJJbmZvLCBSb3dFeHRyYUZsYWdzLCBDZWxsRXh0cmFGbGFncz4+KCh7IGFzQ2hpbGRSb3dPZlNlY3Rpb246IGFzQ2hpbGQsIGFzUGFyZW50Um93T2ZDZWxsczogYXNQYXJlbnQgfSkgPT4ge1xuICAgICAgICAvLyBPdmVycmlkZSB0aGUgZm9jdXNTZWxmIHRoYXQgcm92aW5nVGFiSW5kZXggZG9lcy5cbiAgICAgICAgLy8gSW5zdGVhZCBvZiBmb2N1c2luZyB0aGUgZW50aXJlIHJvdywgd2UgYXNrIHRoZSBjZWxsIHRoYXQgY29ycmVzcG9uZHNcbiAgICAgICAgLy8gdG8gb3VyIGN1cnJlbnQgY29sdW1uIHRvIGZvY3VzIGl0c2VsZi5cbiAgICAgICAgY29uc3QgZm9jdXNTZWxmID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYzIgPSBnZXRDdXJyZW50Q29sdW1uKCk7XG4gICAgICAgICAgICBpZiAoYXNDaGlsZC5yb3ZpbmdUYWJJbmRleC5mb2N1c1NlbGYpIHtcbiAgICAgICAgICAgICAgICBhc0NoaWxkLnJvdmluZ1RhYkluZGV4LmZvY3VzU2VsZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGMyID8/IDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCByb3dMc0NoaWxkUmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRBc0dyaWRSb3coe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiBhc0NoaWxkLm1hbmFnZWRDaGlsZCxcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmFzQ2hpbGQubGlzdE5hdmlnYXRpb24gfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IC4uLmFzQ2hpbGQucm92aW5nVGFiSW5kZXgsIGZvY3VzU2VsZiB9LFxuICAgICAgICAgICAgc3ViSW5mbzogYXNDaGlsZC5zdWJJbmZvLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleDogeyB0YWJiYWJsZSB9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMgfSA9IHJvd0xzQ2hpbGRSZXR1cm5UeXBlO1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0YWJiYWJsZSkge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt0YWJiYWJsZV0pO1xuXG4gICAgICAgIGNvbnN0IHJvd0xzUmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uPENlbGxFbGVtZW50LCBDZWxsRWxlbWVudCwgQ2VsbFN1YkluZm8sIENlbGxFeHRyYUZsYWdzPih7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4uYXNQYXJlbnQubWFuYWdlZENoaWxkcmVuIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyAuLi5hc1BhcmVudC5yb3ZpbmdUYWJJbmRleCB9LFxuICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgICAgIC4uLmFzUGFyZW50LmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbjogXCJpbmxpbmVcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IC4uLmFzUGFyZW50LnR5cGVhaGVhZE5hdmlnYXRpb24sIG5vVHlwZWFoZWFkOiB0cnVlIH0sXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5hc1BhcmVudC5saXN0TmF2aWdhdGlvbiB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXg6IHsgc2V0VGFiYmFibGVJbmRleCB9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkOiB1c2VHcmlkTmF2aWdhdGlvbkNvbHVtbjIsIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM6IHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uUHJvcHMsIGxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleCB9IH0gPSByb3dMc1JldHVyblR5cGU7XG5cbiAgICAgICAgLy9jb25zdCByb3dIaWRkZW4gPSAhIWFzQ2hpbGQucm92aW5nVGFiSW5kZXguaGlkZGVuO1xuXG4gICAgICAgIGNvbnN0IHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCA9IHVzZUNhbGxiYWNrPFVzZUdyaWROYXZpZ2F0aW9uQ2VsbDxDZWxsRWxlbWVudCwgQ2VsbFN1YkluZm8sIENlbGxFeHRyYUZsYWdzPj4oKHsgc3ViSW5mbywgaGFzRm9jdXM6IHsgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgLi4uaGFzRm9jdXMgfSwgbWFuYWdlZENoaWxkLCBsaXN0TmF2aWdhdGlvbjogbHMsIHJvdmluZ1RhYkluZGV4OiB7IGJsdXJTZWxmOiBicywgZm9jdXNTZWxmOiBmcywgLi4ucnRpIH0gfSkgPT4ge1xuICAgICAgICAgICAgLy9ydGkuaGlkZGVuIHx8IHJvd0hpZGRlbjtcblxuICAgICAgICAgICAgY29uc3QgZm9jdXNTZWxmID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDb2x1bW4obWFuYWdlZENoaWxkLmluZGV4KTtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG1hbmFnZWRDaGlsZC5pbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChmcylcbiAgICAgICAgICAgICAgICAgICAgZnMoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIChydGlfY2VsbF9yZXQuZ2V0RWxlbWVudCgpIGFzIEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik/LmZvY3VzPy4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYmx1clNlbGYgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGJzKVxuICAgICAgICAgICAgICAgICAgICBicygpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKHJ0aV9jZWxsX3JldC5nZXRFbGVtZW50KCkgYXMgRWxlbWVudCAmIFBhcnRpYWw8SFRNTEVsZW1lbnQ+KT8uYmx1cj8uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9jZWxsX3JldFxuICAgICAgICAgICAgfSA9IHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uMih7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkOiBtYW5hZ2VkQ2hpbGQsXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4ubHMgfSxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCAuLi5ydGkgfSxcbiAgICAgICAgICAgICAgICBzdWJJbmZvXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxDZWxsRWxlbWVudD4oe1xuICAgICAgICAgICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuLCBwcmV2OiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ/Lihmb2N1c2VkLCBwcmV2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDb2x1bW4obWFuYWdlZENoaWxkLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobWFuYWdlZENoaWxkLmluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5oYXNGb2N1c1xuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgY29uc3QgcmV0OiBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGxFbGVtZW50PiA9IHtcbiAgICAgICAgICAgICAgICBncmlkTmF2aWdhdGlvbjogeyBnZXRDdXJyZW50Q29sdW1uIH0sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9jZWxsX3JldCxcbiAgICAgICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wczogZnVuY3Rpb24gPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD4+KHByb3BzOiBQKSB7IHJldHVybiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlR3JpZE5hdmlnYXRpb25Db2x1bW5Qcm9wcyh1c2VIYXNGb2N1c1Byb3BzKHByb3BzKSkpOyB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGNvbnN0IHJldDogVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+ID0ge1xuICAgICAgICAgICAgYXNQYXJlbnRPZkNlbGxzOiB7XG4gICAgICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogcm93THNSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHJvd0xzUmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHJvd0xzUmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJvd0xzUmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiByb3dMc1JldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzQ2hpbGRSb3c6IHJvd0xzQ2hpbGRSZXR1cm5UeXBlLFxuXG4gICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGwsXG4gICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzOiBmdW5jdGlvbiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvd0VsZW1lbnQ+Pihwcm9wczogUCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgcmV0LnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIGdldEN1cnJlbnRDb2x1bW4sXG4gICAgICAgICAgICBjdXJyZW50Q29sdW1uXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHBhcmVudExzUmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogcGFyZW50THNSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcGFyZW50THNSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBwYXJlbnRMc1JldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBwYXJlbnRMc1JldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvdyxcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Qcm9wczogdXNlTGlzdE5hdmlnYXRpb25Qcm9wc0FzR3JpZFBhcmVudCxcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdFwiO1xuaW1wb3J0IHsgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuZXhwb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCB9XG5cbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkUHJvcHNQYXJhbWV0ZXJzID0gVXNlUmVmZXJlbmNlZElkUHJvcHNQYXJhbWV0ZXJzPFwiaWRcIj47XG5leHBvcnQgdHlwZSBVc2VSYW5kb21JZFByb3BzUmV0dXJuVHlwZTxQIGV4dGVuZHMgVXNlUmFuZG9tSWRQcm9wc1BhcmFtZXRlcnM+ID0gVXNlUmVmZXJlbmNlZElkUHJvcHNSZXR1cm5UeXBlPFAsIFwiaWRcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFuZG9tSWRQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxcInJlZmVyZW5jZXJcIiB8IFwic291cmNlXCIsIG5ldmVyPiB7XG4gICAgcmFuZG9tSWQ6IHtcbiAgICAgICAgcHJlZml4Pzogc3RyaW5nO1xuICAgIH1cbn1cblxuXG5leHBvcnQgdHlwZSBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8SyBleHRlbmRzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+ID0gUGFydGlhbDxSZWNvcmQ8SywgYW55Pj47Ly88RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4geyB9O1xuXG5cbmV4cG9ydCB0eXBlIFVzZVJlZmVyZW5jZWRJZFByb3BzUmV0dXJuVHlwZTxQIGV4dGVuZHMgVXNlUmVmZXJlbmNlZElkUHJvcHNQYXJhbWV0ZXJzPGFueT4sIEsgZXh0ZW5kcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+PiA9IE9taXQ8UCwgSz4gJiBSZWNvcmQ8Sywgc3RyaW5nPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFJldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88XCJyZWZlcmVuY2VyXCIgfCBcInNvdXJjZVwiLCB7fSwgbmV2ZXI+IHtcbiAgICByYW5kb21JZDoge1xuICAgICAgICB1c2VkSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0VXNlZElkKCk6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFuZG9tSWRSZXR1cm5UeXBlV2l0aEhvb2tzPFMgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJhbmRvbUlkUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ8Uz47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiBVc2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50O1xufVxuXG5pbnRlcmZhY2UgUmFuZG9tSWRDaGlsZEluZm9CYXNlIHtcbiAgICBzZXRVc2VkSWQoaWQ6IHN0cmluZyk6IHZvaWQ7XG4gICAgLy9zZW5kU291cmNlSWRUb1JlZmVyZW5jZXJFbGVtZW50KHNvdXJjZUlkOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ8UyBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4gVXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UmV0dXJuVHlwZTxTPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnRSZXR1cm5UeXBlPFMgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdXNlZElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRVc2VkSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxTPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uz47XG59XG5cbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQgPSA8UiBleHRlbmRzIEVsZW1lbnQ+KGlkUHJvcE5hbWU6IGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PikgPT4gVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFJldHVyblR5cGU8Uj47XG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRSZXR1cm5UeXBlPFIgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdXNlZElkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRVc2VkSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uj4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFI+O1xufVxuXG5cblxuLyoqXG4gKiBSZXR1cm5zIGEgaG9vayB0aGF0IG1vZGlmaWVzIGEgc2V0IG9mIHByb3BzIHRvIHByb3ZpZGUgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgaWYgb25lIHdhcyBub3QgcHJvdmlkZWQuXG4gKiBcbiAqIElmIHlvdSdkIGxpa2UgdG8gdXNlIHRoZSBJRCBpbiBhIHByb3BlcnR5IHRoYXQncyAqbm90KiBuYW1lZCBgaWRgIChsaWtlIGBmb3JgIG9yIGBhcmlhLWxhYmVsbGVkYnlgIG9yIHdoYXRub3QpLCBgdXNlUmVmZXJlbmNlZElkUHJvcHNgIGlzIGFsc28gcHJvdmlkZWQuXG4gKiBcbiAqIEFuZCB0aGUgcmFuZG9tbHktZ2VuZXJhdGVkIGlkIGl0c2VsZiBpcyBhbHNvIHByb3ZpZGVkIGluIGNhc2UgeW91IHdhbnQgdG8gaGFuZGxlIHRoZSBsb2dpYyB5b3Vyc2VsZiB3aXRob3V0IGB1c2VNZXJnZWRQcm9wc2AuXG4gKiBcbiAqIFVubGlrZSBtb3N0IG90aGVyIGB1c2UqUHJvcHNgIGhvb2tzLCB0aGVzZSBhcmUgbW9zdGx5IHN0YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJhbmRvbUlkPFMgZXh0ZW5kcyBFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeCB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9OiBVc2VSYW5kb21JZFBhcmFtZXRlcnMpOiBVc2VSYW5kb21JZFJldHVyblR5cGVXaXRoSG9va3M8Uz4ge1xuICAgIGNvbnN0IFtiYWNrdXBSYW5kb21JZCwgLCBnZXRCYWNrdXBSYW5kb21JZF0gPSB1c2VTdGF0ZTxzdHJpbmc+KCgpID0+IGdlbmVyYXRlUmFuZG9tSWQocHJlZml4KSk7XG4gICAgY29uc3QgW3VzZWRJZCwgc2V0VXNlZElkLCBnZXRVc2VkSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgdW5kZWZpbmVkPigoKSA9PiBnZXRCYWNrdXBSYW5kb21JZCgpKTtcbiAgICBjb25zdCBtaXNtYXRjaEVycm9yUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VSYW5kb21JZFwiLCBwcmVmaXgpO1xuXG4gICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGQsIC4uLm1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUgfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxcInJlZmVyZW5jZXJcIiB8IFwic291cmNlXCIsIFJhbmRvbUlkQ2hpbGRJbmZvQmFzZSwgbmV2ZXI+KHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfSk7XG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSB9ID0gbWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCA9IHVzZUNhbGxiYWNrPFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTPj4oKCkgPT4ge1xuICAgICAgICBjb25zdCBbdXNlZElkTG9jYWwsIHNldFVzZWRJZExvY2FsLCBnZXRVc2VkSWRMb2NhbF0gPSB1c2VTdGF0ZShnZXRVc2VkSWQoKSk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PFM+KCk7XG4gICAgICAgIC8vIEV2ZXJ5IHRpbWUgdGhlIHNvdXJjZSBlbGVtZW50IHJlbmRlcnMsIGluc3BlY3QgdGhlIElEIGl0IGFjdHVhbGx5IHVzZWRcbiAgICAgICAgLy8gKHdoZXRoZXIgaXQgd2FzIG91cnMgb3Igbm90IGlzbid0IHVwIHRvIHVzLCBpdCdzIHVwIHRvIHRoZSBjb21wb25lbnQpXG4gICAgICAgIC8vIHNvIHRoaXMgaXMgaG93IHdlIG5vdGlmeSB0aGUgcmVmZXJlbmNlciBjb21wb25lbnQgb2YgY2hhbmdlc1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5nZXRBdChcInJlZmVyZW5jZXJcIikhLnN1YkluZm8uc2V0VXNlZElkKGVsZW1lbnQuaWQpO1xuICAgICAgICAgICAgICAgIHNldFVzZWRJZChlbGVtZW50LmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgXzogdm9pZCA9IHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleDogXCJzb3VyY2VcIiwgc3ViSW5mbzogeyBzZXRVc2VkSWQ6IHNldFVzZWRJZExvY2FsIH0gfSB9KTtcblxuICAgICAgICBjb25zdCB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyA9IHVzZUNhbGxiYWNrPFVzZVJhbmRvbUlkU291cmNlRWxlbWVudFJldHVyblR5cGU8Uz5bXCJ1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wc1wiXT4oZnVuY3Rpb24gKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFM+KSB7XG4gICAgICAgICAgICBwLmlkIHx8PSBiYWNrdXBSYW5kb21JZDtcbiAgICAgICAgICAgIHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHMocCk7XG4gICAgICAgIH0sIFtdKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VkSWQ6IHVzZWRJZExvY2FsLFxuICAgICAgICAgICAgZ2V0VXNlZElkOiBnZXRVc2VkSWRMb2NhbCxcbiAgICAgICAgICAgIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCA9IHVzZUNhbGxiYWNrPFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ+KDxSIGV4dGVuZHMgRWxlbWVudD4oaWRQcm9wTmFtZToga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uj4pID0+IHtcbiAgICAgICAgY29uc3QgW3VzZWRJZExvY2FsLCBzZXRVc2VkSWRMb2NhbCwgZ2V0VXNlZElkTG9jYWxdID0gdXNlU3RhdGUoZ2V0VXNlZElkKCkpO1xuICAgICAgICAvLyBXaGF0ZXZlciBJRCB3YXMgbW9zdCByZWNlbnRseSB1c2VkIGJ5IHRoZSBhY3R1YWwgXCJpZFwiIHByb3Agb2YgdGhlIHNvdXJjZSBlbGVtZW50XG4gICAgICAgIHVzZUVuc3VyZVN0YWJpbGl0eShpZFByb3BOYW1lKTtcblxuICAgICAgICBjb25zdCBfdjogdm9pZCA9IHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleDogXCJyZWZlcmVuY2VyXCIsIHN1YkluZm86IHsgc2V0VXNlZElkOiBzZXRVc2VkSWRMb2NhbCB9IH0gfSk7XG5cbiAgICAgICAgY29uc3QgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzID0gdXNlQ2FsbGJhY2s8VXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFJldHVyblR5cGU8Uj5bXCJ1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHNcIl0+KGZ1bmN0aW9uIDxSIGV4dGVuZHMgRWxlbWVudD4oeyBbaWRQcm9wTmFtZV06IGdpdmVuSWQsIC4uLnAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uj4pIHtcbiAgICAgICAgICAgIGlmIChnaXZlbklkICYmIHVzZWRJZCkge1xuICAgICAgICAgICAgICAgIGlmIChnaXZlbklkICE9IHVzZWRJZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1pc21hdGNoRXJyb3JSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlzbWF0Y2hFcnJvclJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYE11bHRpcGxlIG1pcy1tYXRjaGVkIElEcyB3ZXJlIHByb3ZpZGVkIGZvciB0aGUgJHtpZFByb3BOYW1lfSBwcm9wOiB0aGUgY2hpbGQgZXhwbGljaXRseSBzcGVjaWZpZWQgJHtnaXZlbklkfSBpbiBpdHMgICR7aWRQcm9wTmFtZX0gcHJvcCwgYnV0IHRoZSBwYXJlbnQgdG9sZCB0aGlzIGNoaWxkIHRvIHVzZSAke3VzZWRJZH0gKHRoZSBwYXJlbnQncyBJRCkuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Uj4ocCwgeyBbaWRQcm9wTmFtZV06IHVzZWRJZCB9KTtcbiAgICAgICAgfSwgW3VzZWRJZF0pO1xuXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZWRJZDogdXNlZElkTG9jYWwsXG4gICAgICAgICAgICBnZXRVc2VkSWQ6IGdldFVzZWRJZExvY2FsLFxuICAgICAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzXG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByYW5kb21JZDoge1xuICAgICAgICAgICAgdXNlZElkLFxuICAgICAgICAgICAgZ2V0VXNlZElkXG4gICAgICAgIH0sXG4gICAgICAgIC4uLm1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUsXG4gICAgICAgIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCxcbiAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFxuICAgIH07XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUZvcmNlVXBkYXRlLCB1c2VHbG9iYWxIYW5kbGVyLCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgZGVidWdMb2csIEVuaGFuY2VkRXZlbnQsIGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwsIFRhZ1NlbnNpdGl2ZVByb3BzIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuXHJcbmxldCBwdWxzZSA9ICgoXCJ2aWJyYXRlXCIgaW4gbmF2aWdhdG9yKSAmJiAobmF2aWdhdG9yLnZpYnJhdGUgaW5zdGFuY2VvZiBGdW5jdGlvbikpID8gKCgpID0+IG5hdmlnYXRvci52aWJyYXRlKDEwKSkgOiAoKCkgPT4geyB9KTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGVuYWJsZS9kaXNhYmxlIGJ1dHRvbiB2aWJyYXRpb24gcHVsc2VzIG9uIGFuIGFwcC13aWRlIHNjYWxlLlxyXG4gKiBcclxuICogXHJcbiAqIEBwYXJhbSBmdW5jIFRoZSBmdW5jdGlvbiB0byBydW4gd2hlbiBhIGJ1dHRvbiBpcyB0YXBwZWQuXHJcbiAqIChEZWZhdWx0IGlzIGAoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMClgIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdCwgYSBub29wIG90aGVyd2lzZSlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRCdXR0b25WaWJyYXRlKGZ1bmM6ICgpID0+IHZvaWQpIHtcclxuICAgIHB1bHNlID0gZnVuYztcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgQnV0dG9uUHJlc3NFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gRW5oYW5jZWRFdmVudDxFLCBFdmVudCB8IEV2ZW50LCB7IHByZXNzZWQ6IGJvb2xlYW4gfCBudWxsIH0+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQnV0dG9uUGFyYW1ldGVyczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IGV4dGVuZHMgVGFnU2Vuc2l0aXZlUHJvcHM8RT4ge1xyXG4gICAgZGlzYWJsZWQ/OiBib29sZWFuIHwgXCJzb2Z0XCIgfCBcImhhcmRcIjtcclxuICAgIHByZXNzZWQ/OiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuICAgIG9uUHJlc3M/KGV2ZW50OiBCdXR0b25QcmVzc0V2ZW50PEU+KTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQnV0dG9uUmV0dXJuVHlwZTxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcclxuICAgIC8qKiAqVW5zdGFibGUqICovXHJcbiAgICB1c2VBcmlhQnV0dG9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZXhjbHVkZXModGFyZ2V0OiBcImNsaWNrXCIgfCBcInNwYWNlXCIgfCBcImVudGVyXCIsIGV4Y2x1ZGU6IHVuZGVmaW5lZCB8IHsgY2xpY2s/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgc3BhY2U/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgZW50ZXI/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCB9KSB7XHJcbiAgICBpZiAoZXhjbHVkZT8uW3RhcmdldF0pXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG4vKipcclxuICogc2VsZWN0aW9uLmNvbnRhaW5zTm9kZSBkb2Vzbid0IGFjY291bnQgZm9yIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCxcclxuICogc28gaGVyZSdzIGEgd29ya2Fyb3VuZCBmb3IgdGhhdC5cclxuICogXHJcbiAqIFdlIGFsc28gb25seSBsb29rIGZvciB0aGUgc2VsZWN0aW9uIGVuZCB0byBvbmx5IGNhdGNoIHRoZSBcclxuICogZXNzZW5zZSBvZiBhIG5vbi1leGlzdGFudCBcInNlbGVjdGlvbnN0b3BcIiBldmVudC5cclxuICogXHJcbiAqIEBwYXJhbSBlbGVtZW50IFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmZ1bmN0aW9uIG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZWxlbWVudDogRXZlbnRUYXJnZXQgfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50IGluc3RhbmNlb2YgTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAoc2VsZWN0aW9uPy5yYW5nZUNvdW50ID8/IDApOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24hLmdldFJhbmdlQXQoaSkhO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhyYW5nZS5lbmRDb250YWluZXIpICYmICFzZWxlY3Rpb24/LmlzQ29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uIS50b1N0cmluZygpLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZHMgdGhlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyB0byBjcmVhdGUgYSBcInByZXNzXCItbGlrZSBldmVudCBmb3JcclxuICogYnV0dG9ucyBhbmQgYW55dGhpbmcgZWxzZSB0aGF0J3MgXCJjbGljay90YXAvcHJlc3MvdG91Y2hcIi1hYmxlLlxyXG4gKiBcclxuICogTm90YWJseSwgdGhlIGZvbGxvd2luZyBjYXNlcyBhcmUgY292ZXJlZDpcclxuICogKiBUaGUgdGFyZ2V0IGVsZW1lbnQgaXMgcHJvcGVybHkgZm9jdXNlZCwgZXZlbiBvbiBpT1MgU2FmYXJpICgqZXNwZWNpYWxseSogb24gaU9TIFNhZmFyaSlcclxuICogKiBEb3VibGUtY2xpY2tzIHdvbid0IHNlbGVjdCB0ZXh0LiBcclxuICogKiBDb252ZXJzZWx5LCBtYW51YWxseSBzZWxlY3RpbmcgdGV4dCB3b24ndCBpbnZva2UgYSBwcmVzcy5cclxuICogKiBLZXlib2FyZCBldmVudHMgJm1kYXNoOyBgZW50ZXJgIGltbWVkaWF0ZWx5IGludm9rZXMgdGhlIGhhbmRsZXIsIHdoaWxlIGBzcGFjZWAgaW52b2tlcyBpdCBvbiBrZXl1cC5cclxuICogKiBIYXB0aWMgZmVlZGJhY2sgKG9uLCBsaWtlLCB0aGUgb25lIGJyb3dzZXIgY29tYmluYXRpb24gdGhhdCBzdXBwb3J0cyBpdCAmbWRhc2g7IHRoaXMgY2FuIGJlIGRpc2FibGVkIGFwcC13aWRlIHdpdGggYHNldEJ1dHRvblZpYnJhdGVgKVxyXG4gKiBcclxuICogSW4gYWRkaXRpb24sIHdoZW4gdGhlIENTUyBgOmFjdGl2ZWAgcHNldWRvLWNsYXNzIHdvdWxkIGFwcGx5IHRvIGEgbm9ybWFsIGJ1dHRvblxyXG4gKiAoaS5lLiB3aGVuIGhvbGRpbmcgdGhlIHNwYWNlYmFyIG9yIGR1cmluZyBtb3VzZWRvd24pLCBgeyBcImRhdGEtcHNldWRvLWFjdGl2ZVwiOiBcInRydWVcIiB9YFxyXG4gKiBpcyBhZGRlZCB0byB0aGUgcHJvcHMuICBZb3UgY2FuIGVpdGhlciBsZXQgaXQgcGFzcyB0aHJvdWdoIGFuZCBzdHlsZSBpdCB0aHJvdWdoIG5ldyBDU1MsXHJcbiAqIG9yIGluc3BlY3QgdGhlIHJldHVybmVkIHByb3BzIGZvciBpdCBhbmQgYWRkIGUuZy4gYW4gYC5hY3RpdmVgIGNsYXNzIGZvciBleGlzdGluZyBDU1NcclxuICogXHJcbiAqIEBwYXJhbSBvbkNsaWNrU3luYyBcclxuICogQHBhcmFtIGV4Y2x1ZGUgV2hldGhlciB0aGUgcG9seWZpbGwgc2hvdWxkbid0IGFwcGx5IChjYW4gc3BlY2lmeSBmb3Igc3BlY2lmaWMgaW50ZXJhY3Rpb25zKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVByZXNzRXZlbnRIYW5kbGVyczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KG9uQ2xpY2tTeW5jOiAoKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8RT4pID0+IHZvaWQpIHwgbnVsbCB8IHVuZGVmaW5lZCwgZXhjbHVkZTogdW5kZWZpbmVkIHwgeyBjbGljaz86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBzcGFjZT86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBlbnRlcj86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkIH0pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XHJcblxyXG4gICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8RT4oe30pO1xyXG5cclxuICAgIC8vIEEgYnV0dG9uIGNhbiBiZSBhY3RpdmF0ZWQgaW4gbXVsdGlwbGUgd2F5cywgc28gb24gdGhlIG9mZiBjaGFuY2VcclxuICAgIC8vIHRoYXQgbXVsdGlwbGUgYXJlIHRyaWdnZXJlZCBhdCBvbmNlLCB3ZSBvbmx5ICphY3R1YWxseSogcmVnaXN0ZXJcclxuICAgIC8vIGEgcHJlc3Mgb25jZSBhbGwgb2Ygb3VyIFwib25cIiBzaWduYWxzIGhhdmUgdHVybmVkIGJhY2sgdG8gXCJvZmZcIi5cclxuICAgIC8vIFdlIGFwcHJveGltYXRlIHRoaXMgYnkganVzdCBpbmNyZW1lbnRpbmcgd2hlbiBhY3RpdmUsIGFuZFxyXG4gICAgLy8gZGVjcmVtZW50aW5nIHdoZW4gZGVhY3RpdmF0ZWQuXHJcbiAgICAvL1xyXG4gICAgLy8gQXMgYW4gZW1lcmdlbmN5IGZhaWxzYWZlLCB3aGVuIHRoZSBlbGVtZW50IGxvc2VzIGZvY3VzLFxyXG4gICAgLy8gdGhpcyBpcyByZXNldCBiYWNrIHRvIDAuXHJcbiAgICBjb25zdCBbYWN0aXZlLCBzZXRBY3RpdmUsIGdldEFjdGl2ZV0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcclxuXHJcbiAgICAvLyBJZiB3ZSB0aGUgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiBjaGFuZ2VzIHRvIGluY2x1ZGUgdGhpcyBlbGVtZW50XHJcbiAgICAvLyBEVVJJTkcgZS5nLiBhIG1vdXNlZG93biwgdGhlbiB3ZSBkb24ndCB3YW50IHRoZSBtb3VzZXVwIHRvIFwiY291bnRcIiwgYXMgaXQgd2VyZSxcclxuICAgIC8vIGJlY2F1c2UgaXRzIG9ubHkgcHVycG9zZSB3YXMgc2VsZWN0aW5nIHRleHQsIG5vdCBjbGlja2luZyBidXR0b25zLlxyXG4gICAgLy9cclxuICAgIC8vIFRvIGNhdGNoIHRoaXMsIGFueSB0aW1lIHRoZSB0ZXh0IHNlbGVjdGlvbiBpbmNsdWRlcyB1cyB3aGlsZSBpbiB0aGUgbWlkZGxlXHJcbiAgICAvLyBvZiBhIGNsaWNrLCB0aGlzIGZsYWcgaXMgc2V0LCB3aGljaCBjYW5jZWxzIHRoZSBhY3RpdmF0aW9uIG9mIGEgcHJlc3MuXHJcbiAgICAvLyBUaGUgZmxhZyBpcyByZXNldCBhbnkgdGltZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IG9yIHRoZSBidXR0b24gaXNcclxuICAgIC8vIG5vIGxvbmdlciBhY3RpdmUuXHJcbiAgICBjb25zdCBbdGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSwgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxEYXRlIHwgbnVsbD4obnVsbCk7XHJcbiAgICBjb25zdCBwc2V1ZG9BY3RpdmUgPSAoYWN0aXZlICYmICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lID09IG51bGwpKTtcclxuXHJcbiAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInNlbGVjdGlvbmNoYW5nZVwiLCBfID0+IHtcclxuICAgICAgICBzZXRUZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lKHByZXYgPT4gbm9kZVNlbGVjdGVkVGV4dExlbmd0aChnZXRFbGVtZW50KCkpID09IDAgPyBudWxsIDogcHJldiAhPSBudWxsID8gcHJldiA6IG5ldyBEYXRlKCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoYWN0aXZlID09IDApXHJcbiAgICAgICAgICAgIHNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUobnVsbCk7XHJcblxyXG4gICAgfSwgW2FjdGl2ZSA9PSAwXSk7XHJcblxyXG4gICAgY29uc3Qgb25BY3RpdmVTdGFydCA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvbkNsaWNrU3luYz4+KChfKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKGEgPT4gKythKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG9uQWN0aXZlU3RvcCA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvbkNsaWNrU3luYz4+KChlKSA9PiB7XHJcbiAgICAgICAgc2V0QWN0aXZlKGEgPT4gTWF0aC5tYXgoMCwgLS1hKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcclxuICAgICAgICBjb25zdCB0aW1lRGlmZmVyZW5jZSA9ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lID09IG51bGwgPyBudWxsIDogK2N1cnJlbnRUaW1lIC0gK3RleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUpO1xyXG4gICAgICAgIGNvbnN0IGNoYXJhY3RlcnNTZWxlY3RlZCA9IG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZ2V0RWxlbWVudCgpKVxyXG5cclxuICAgICAgICAvLyBJZiB3ZSdyZSBzZWxlY3RpbmcgdGV4dCAoaGV1cmlzdGljYWxseSBkZXRlcm1pbmVkIGJ5IHNlbGVjdGluZyBmb3IgbG9uZ2VyIHRoYW4gMS80IGEgc2Vjb25kLCBvciBtb3JlIHRoYW4gMiBjaGFyYWN0ZXJzKVxyXG4gICAgICAgIC8vIHRoZW4gdGhpcyBpc24ndCBhIHByZXNzIGV2ZW50LlxyXG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG1lYXN1cmUgZ2x5cGhzIGluc3RlYWQgb2YgY2hhcmFjdGVycy5cclxuICAgICAgICBpZiAoY2hhcmFjdGVyc1NlbGVjdGVkID4gMSB8fCAoKHRpbWVEaWZmZXJlbmNlID8/IDApID4gMjUwICYmIGNoYXJhY3RlcnNTZWxlY3RlZCA+PSAxKSkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChnZXRBY3RpdmUoKSA8PSAwKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVByZXNzKGUpO1xyXG4gICAgICAgICAgICBmb3JjZVVwZGF0ZSgpOyAgLy8gVE9ETzogUmVtb3ZlIHdoZW4gaXNzdWUgcmVzb2x2ZWQgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMzczMVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVByZXNzID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2xpY2tTeW5jPj4oKGUpID0+IHtcclxuICAgICAgICBpZiAob25DbGlja1N5bmMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBlbGVtZW50IGlzIGZvY3VzZWQgaGVyZSBiZWNhdXNlIG9mIGlPUyBTYWZhcmkuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIEl0J3MgYWx3YXlzIGlPUyBTYWZhcmkuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIGlPUyBTYWZhcmkgKHRlc3RlZCBvbiAxMikgZG93bnJpZ2h0IHJlZnVzZXMgdG8gYWxsb3cgXHJcbiAgICAgICAgICAgIC8vIGVsZW1lbnRzIHRvIGJlIG1hbnVhbGx5IGZvY3VzZWQgVU5MRVNTIGl0IGhhcHBlbnMgd2l0aGluXHJcbiAgICAgICAgICAgIC8vIGFuIGV2ZW50IGhhbmRsZXIgbGlrZSB0aGlzLiAgSXQgYWxzbyBkb2Vzbid0IGZvY3VzXHJcbiAgICAgICAgICAgIC8vIGJ1dHRvbnMgYnkgZGVmYXVsdCB3aGVuIGNsaWNrZWQsIHRhcHBlZCwgZXRjLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBJZiBpdCBiZWNvbWVzIHByb2JsZW1hdGljIHRoYXQgYnV0dG9uLWxpa2VzIGV4cGxpY2l0bHkgYmVjb21lXHJcbiAgICAgICAgICAgIC8vIGZvY3VzZWQgd2hlbiB0aGV5IGFyZSBwcmVzc2VkLCB0aGVuIGFuIGFsdGVybmF0aXZlIHNvbHV0aW9uIGZvclxyXG4gICAgICAgICAgICAvLyB0aGUgcXVlc3Rpb24gb2YgXCJob3cgZG8gbWVudSBidXR0b25zIGtlZXAgdGhlaXIgbWVudXMgb3BlblwiXHJcbiAgICAgICAgICAgIC8vIGFuZCBvdGhlciBmb2N1cy1yZWxhdGVkIG5vbnNlbnNlIG5lZWRzIHRvIGJlIGZpZ3VyZWQgb3V0LlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBGb3IgaU9TIFNhZmFyaS5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgXCJmb2N1c1wiIGluIChlbGVtZW50IGFzIEV2ZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50KSlcclxuICAgICAgICAgICAgICAgIChlbGVtZW50IGFzIEV2ZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50IHwgbnVsbCk/LmZvY3VzKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBXaGF0ZXZlciB0aGUgYnJvd3NlciB3YXMgZ29pbmcgdG8gZG8gd2l0aCB0aGlzIGV2ZW50LFxyXG4gICAgICAgICAgICAvLyBmb3JnZXQgaXQuIFdlJ3JlIHR1cm5pbmcgaXQgaW50byBhIFwicHJlc3NcIiBldmVudC5cclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWxzbyBzdG9wIGFueW9uZSBlbHNlIGZyb20gbGlzdGVuaW5nIHRvIHRoaXMgZXZlbnQsXHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGV4cGxpY2l0bHkgaGFuZGxpbmcgaXQuXHJcbiAgICAgICAgICAgIC8vIChOb3RhYmx5LCB0aGlzIGFsbG93cyBsYWJlbHMgdG8gd3JhcCBpbnB1dHMsIHdpdGggdGhlbVxyXG4gICAgICAgICAgICAvLyBib3RoIGhhdmluZyBwcmVzcyBldmVudCBoYW5kbGVycywgd2l0aG91dCBkb3VibGUtZmlyaW5nKVxyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgLy8gSGFwdGljIGZlZWRiYWNrIGZvciB0aGlzIHByZXNzIGV2ZW50XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHRocm93LFxyXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIHNob3VsZCBndWFyZCBhZ2FpbnN0IHVzZXIgaW1wbGVtZW50YXRpb25zIHRoYXQgY291bGQuXHJcbiAgICAgICAgICAgICAgICBwdWxzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHkgY2FsbCBvdXIgaGFuZGxlci5cclxuICAgICAgICAgICAgICAgIG9uQ2xpY2tTeW5jKGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG9uTW91c2VEb3duID0gZXhjbHVkZXMoXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcclxuICAgICAgICAvLyBTdG9wIGRvdWJsZSBjbGlja3MgZnJvbSBzZWxlY3RpbmcgdGV4dCBpbiBhbiBjb21wb25lbnQgdGhhdCdzICpzdXBwb3NlZCogdG8gYmUgYWN0aW5nIGxpa2UgYSBidXR0b24sXHJcbiAgICAgICAgLy8gYnV0IGFsc28gZG9uJ3QgcHJldmVudCB0aGUgdXNlciBmcm9tIHNlbGVjdGluZyB0aGF0IHRleHQgbWFudWFsbHkgaWYgdGhleSByZWFsbHkgd2FudCB0b1xyXG4gICAgICAgIC8vICh3aGljaCB1c2VyLXNlbGVjdDogbm9uZSB3b3VsZCBkbywgYnV0IGNhbmNlbGxpbmcgYSBkb3VibGUgY2xpY2sgb24gbW91c2VEb3duIGRvZXNuJ3QpXHJcbiAgICAgICAgaWYgKGUuZGV0YWlsID4gMSlcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKVxyXG4gICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb25Nb3VzZVVwID0gZXhjbHVkZXMoXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcclxuICAgICAgICBpZiAoZS5idXR0b24gPT09IDAgJiYgYWN0aXZlID4gMClcclxuICAgICAgICAgICAgb25BY3RpdmVTdG9wKGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBvbkJsdXIgPSAoXzogaC5KU1guVGFyZ2V0ZWRFdmVudDxFPikgPT4ge1xyXG4gICAgICAgIHNldEFjdGl2ZSgwKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlID0gZXhjbHVkZXMoXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IG9uQmx1cjtcclxuXHJcbiAgICBjb25zdCBvbktleURvd24gPSBleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpICYmIGV4Y2x1ZGVzKFwiZW50ZXJcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PEU+KSA9PiB7XHJcbiAgICAgICAgaWYgKGUua2V5ID09IFwiIFwiICYmIG9uQ2xpY2tTeW5jICYmICFleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGFjdGl2YXRlIGl0IG9uIGEgc3BhY2Uga2V5ZG93blxyXG4gICAgICAgICAgICAvLyBidXQgd2UgZG8gcHJldmVudERlZmF1bHQgdG8gc3RvcCB0aGUgcGFnZSBmcm9tIHNjcm9sbGluZy5cclxuICAgICAgICAgICAgb25BY3RpdmVTdGFydChlKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGUua2V5ID09IFwiRW50ZXJcIiAmJiAhZXhjbHVkZXMoXCJlbnRlclwiLCBleGNsdWRlKSkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XHJcbiAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb25LZXlVcCA9IGV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PEU+KSA9PiB7XHJcbiAgICAgICAgaWYgKGUua2V5ID09IFwiIFwiICYmICFleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpKVxyXG4gICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb25DbGljayA9IChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgaWYgKGUuZGV0YWlsID4gMSkge1xyXG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdXNlUmVmRWxlbWVudFByb3BzKCh7XHJcbiAgICAgICAgb25LZXlEb3duLFxyXG4gICAgICAgIG9uS2V5VXAsXHJcbiAgICAgICAgb25CbHVyLFxyXG4gICAgICAgIG9uTW91c2VEb3duLFxyXG4gICAgICAgIG9uTW91c2VVcCxcclxuICAgICAgICBvbk1vdXNlTGVhdmUsXHJcbiAgICAgICAgb25DbGljayxcclxuICAgICAgICBzdHlsZTogKHRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUgIT0gbnVsbCkgPyB7IGN1cnNvcjogXCJ0ZXh0XCIgfSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAuLi57IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IHBzZXVkb0FjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gYXMge31cclxuICAgIH0pKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFCdXR0b248RSBleHRlbmRzIEV2ZW50VGFyZ2V0Pih7IHRhZywgcHJlc3NlZCwgb25QcmVzcywgZGlzYWJsZWQgfTogVXNlQXJpYUJ1dHRvblBhcmFtZXRlcnM8RT4pOiBVc2VBcmlhQnV0dG9uUmV0dXJuVHlwZTxFPiB7XHJcbiAgICBkZWJ1Z0xvZyhcInVzZUFyaWFCdXR0b25cIik7XHJcblxyXG4gICAgZnVuY3Rpb24gdXNlQXJpYUJ1dHRvblByb3BzKHsgXCJhcmlhLXByZXNzZWRcIjogYXJpYVByZXNzZWQsIHRhYkluZGV4LCByb2xlLCAuLi5wIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4ge1xyXG5cclxuICAgICAgICBjb25zdCBwcm9wcyA9IHVzZU1lcmdlZFByb3BzPEU+KHVzZVByZXNzRXZlbnRIYW5kbGVyczxFPigoZSkgPT4gKGRpc2FibGVkID8gbnVsbCA6IG9uUHJlc3MpPy4oZW5oYW5jZUV2ZW50KGUsIHsgcHJlc3NlZDogcHJlc3NlZCA9PSBudWxsID8gbnVsbCA6ICFwcmVzc2VkIH0pKSwgdW5kZWZpbmVkKSwgcCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhc2VQcm9wcyA9IHsgcm9sZSwgdGFiSW5kZXgsIFwiYXJpYS1wcmVzc2VkXCI6IGFyaWFQcmVzc2VkID8/IChwcmVzc2VkID09PSB0cnVlID8gXCJ0cnVlXCIgOiBwcmVzc2VkID09PSBmYWxzZSA/IFwiZmFsc2VcIiA6IHVuZGVmaW5lZCkgfTtcclxuICAgICAgICBjb25zdCBidXR0b25Qcm9wcyA9IHsgLi4uYmFzZVByb3BzLCBkaXNhYmxlZDogKGRpc2FibGVkICYmIGRpc2FibGVkICE9IFwic29mdFwiKSA/IHRydWUgOiBmYWxzZSwgXCJhcmlhLWRpc2FibGVkXCI6IChkaXNhYmxlZCA9PT0gJ3NvZnQnID8gJ3RydWUnIDogdW5kZWZpbmVkKSB9O1xyXG4gICAgICAgIGNvbnN0IGRpdlByb3BzID0geyAuLi5iYXNlUHJvcHMsIHRhYkluZGV4OiB0YWJJbmRleCA/PyAoZGlzYWJsZWQgPT09IFwiaGFyZFwiID8gLTEgOiAwKSwgcm9sZTogcm9sZSA/PyBcImJ1dHRvblwiLCBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgIHN3aXRjaCAodGFnKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJidXR0b25cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPihidXR0b25Qcm9wcywgcHJvcHMpO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPihkaXZQcm9wcywgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUFyaWFCdXR0b25Qcm9wc1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgT25DaGlsZHJlbk1vdW50Q2hhbmdlLCByZXR1cm5UcnVlLCB1c2VDaGlsZHJlbkZsYWcsIHVzZUhhc0ZvY3VzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIHVzZUxpbmVhck5hdmlnYXRpb24sIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBkZWJ1Z0xvZywgRWxlbWVudFRvVGFnIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQXJpYUJ1dHRvbiwgVXNlQXJpYUJ1dHRvblBhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcblxyXG5leHBvcnQgdHlwZSBVc2VBcmlhQWNjb3JkaW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUFyaWFBY2NvcmRpb25QYXJhbWV0ZXJzKSA9PiBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PikgPT4gVXNlQXJpYUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxcIm5hdmlnYXRlVG9GaXJzdFwiIHwgXCJuYXZpZ2F0ZVRvTGFzdFwiIHwgXCJuYXZpZ2F0ZVRvTmV4dFwiIHwgXCJuYXZpZ2F0ZVRvUHJldlwiPiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxudW1iZXIsIG5ldmVyPiB7XHJcbiAgICBhY2NvcmRpb246IHsgaW5pdGlhbEluZGV4PzogbnVtYmVyIHwgbnVsbDsgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25SZXR1cm5UeXBlSW5mbyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPG51bWJlciwgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25JbmZvQmFzZSwgXCJ0YWJiZWRcIiB8IFwib3BlblwiPiB7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgYWNjb3JkaW9uOiB7IGNoYW5nZUV4cGFuZGVkSW5kZXg6IChhcmc6IG51bWJlciB8ICgocHJldlN0YXRlOiBudW1iZXIgfCBudWxsKSA9PiBudW1iZXIgfCBudWxsKSB8IG51bGwpID0+IG51bWJlciB8IG51bGw7IH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFyaWFBY2NvcmRpb25SZXR1cm5UeXBlSW5mbyB7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb246IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlIHtcclxuICAgIHNldE9wZW5Gcm9tUGFyZW50KG9wZW46IGJvb2xlYW4pOiB2b2lkO1xyXG4gICAgZ2V0T3BlbkZyb21QYXJlbnQoKTogYm9vbGVhbiB8IG51bGw7XHJcbiAgICBmb2N1cygpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgbWFuYWdlZENoaWxkcmVuOiBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPG51bWJlciwgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25JbmZvQmFzZSwgXCJ0YWJiZWRcIiB8IFwib3BlblwiLCBcInN1YkluZm9cIiB8IFwiZmxhZ3NcIj5bXCJtYW5hZ2VkQ2hpbGRcIl07XHJcbiAgICBhY2NvcmRpb25TZWN0aW9uOiB7IG9wZW4/OiBib29sZWFuIHwgdW5kZWZpbmVkOyB0YWdCdXR0b246IEVsZW1lbnRUb1RhZzxIZWFkZXJFbGVtZW50PjsgfVxyXG4gICAgYnV0dG9uOiBQaWNrPFVzZUFyaWFCdXR0b25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+LCBcImRpc2FibGVkXCI+O1xyXG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvIHtcclxuICAgIGFjY29yZGlvblNlY3Rpb246IHtcclxuICAgICAgICBleHBhbmRlZDogYm9vbGVhbjtcclxuICAgICAgICBmb2N1c2VkOiBib29sZWFuO1xyXG4gICAgICAgIGhlYWRlcklkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgYm9keUlkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgZ2V0SGVhZGVySWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGdldEJvZHlJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbyB7XHJcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xyXG4gICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD47XHJcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xyXG4gICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD47XHJcbn1cclxuXHJcblxyXG4vL2V4cG9ydCB0eXBlIFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VBcmlhQnV0dG9uUGFyYW1ldGVyczxFPikgPT4gVXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJSZXR1cm5UeXBlPEU+O1xyXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+OyB9XHJcbi8vZXhwb3J0IHR5cGUgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5PEUgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVJldHVyblR5cGU8RT47XHJcbi8vZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkJvZHlSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFBY2NvcmRpb248SGVhZGVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudD4oeyBhY2NvcmRpb246IHsgaW5pdGlhbEluZGV4IH0sIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH06IFVzZUFyaWFBY2NvcmRpb25QYXJhbWV0ZXJzKTogVXNlQXJpYUFjY29yZGlvblJldHVyblR5cGVXaXRoSG9va3M8SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+IHtcclxuICAgIGRlYnVnTG9nKFwidXNlQXJpYUFjY29yZGlhblwiKTtcclxuICAgIGNvbnN0IFtfY3VycmVudEZvY3VzZWRJbmRleCwgc2V0Q3VycmVudEZvY3VzZWRJbmRleCwgZ2V0Q3VycmVudEZvY3VzZWRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcclxuXHJcbiAgICBjb25zdCBtY1JldHVyblR5cGUgPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlLCBcInRhYmJlZFwiIHwgXCJvcGVuXCI+KHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHtcclxuICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPbkNoaWxkcmVuTW91bnRDaGFuZ2U8bnVtYmVyPj4oKG0sIHUpID0+IHsgb2NtYzIoKTsgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4obSwgdSk7IH0pLFxyXG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3RcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZCwgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0gfSA9IG1jUmV0dXJuVHlwZTtcclxuXHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvRmlyc3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7IGNoYW5nZVRhYmJlZEluZGV4KDApOyB9LCBbXSk7XHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTGFzdCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkpOyB9LCBbXSk7XHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvUHJldiA9IHVzZUNhbGxiYWNrKCgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoaSA9PiAoKGkgPz8gMCkgLSAxKSkgfSwgW10pO1xyXG4gICAgY29uc3QgbmF2aWdhdGVUb05leHQgPSB1c2VDYWxsYmFjaygoKSA9PiB7IGNoYW5nZVRhYmJlZEluZGV4KGkgPT4gKChpID8/IDApICsgMSkpIH0sIFtdKTtcclxuICAgIGNvbnN0IGxpbmVhclJldHVyblR5cGUgPSB1c2VMaW5lYXJOYXZpZ2F0aW9uPEhlYWRlckVsZW1lbnQ+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdCxcclxuICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3QsXHJcbiAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0LFxyXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldixcclxuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5cyxcclxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxyXG4gICAgICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBuYXZpZ2F0aW9uRGlyZWN0aW9uID8/IFwiYmxvY2tcIlxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGluZWFyTmF2aWdhdGlvblByb3BzIH0gPSBsaW5lYXJSZXR1cm5UeXBlO1xyXG5cclxuXHJcbiAgICBjb25zdCB7IGNoYW5nZUluZGV4OiBjaGFuZ2VFeHBhbmRlZEluZGV4LCBnZXRDdXJyZW50SW5kZXg6IF9nZXRDdXJyZW50RXhwYW5kZWRJbmRleCB9ID0gdXNlQ2hpbGRyZW5GbGFnKHtcclxuICAgICAgICBpbml0aWFsSW5kZXgsXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAga2V5OiBcIm9wZW5cIixcclxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleDogY2hhbmdlVGFiYmVkSW5kZXgsIGdldEN1cnJlbnRJbmRleDogX2dldFRhYmJlZEluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdDogb2NtYzIgfSA9IHVzZUNoaWxkcmVuRmxhZyh7XHJcbiAgICAgICAgaW5pdGlhbEluZGV4LFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGtleTogXCJ0YWJiZWRcIixcclxuICAgICAgICBjbG9zZXN0Rml0OiB0cnVlLFxyXG4gICAgICAgIG9uSW5kZXhDaGFuZ2U6IHVzZUNhbGxiYWNrKChpOiBudW1iZXIgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KGkpPy5zdWJJbmZvLmZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbXSlcclxuICAgIH0pXHJcblxyXG4gICAgY29uc3QgdXNlQXJpYUFjY29yZGlvblNlY3Rpb246IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PiA9IHVzZUNhbGxiYWNrPFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50Pj4oKHsgYnV0dG9uOiB7IGRpc2FibGVkIH0sIGFjY29yZGlvblNlY3Rpb246IHsgb3Blbjogb3BlbkZyb21Vc2VyLCB0YWdCdXR0b24gfSwgbWFuYWdlZENoaWxkcmVuOiB7IGluZGV4IH0sIGhhc0ZvY3VzOiB7IG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgLi4uaGFzRm9jdXMgfSB9KSA9PiB7XHJcblxyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlQXJpYUFjY29yZGlhblNlY3Rpb25cIik7XHJcbiAgICAgICAgY29uc3QgW29wZW5Gcm9tUGFyZW50LCBzZXRPcGVuRnJvbVBhcmVudCwgZ2V0T3BlbkZyb21QYXJlbnRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KG51bGwpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VCb2R5QXNTb3VyY2VJZCwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlSGVhZGVyQXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogYm9keUlkLCBnZXRVc2VkSWQ6IGdldEJvZHlJZCB9IH0gPSB1c2VSYW5kb21JZDxCb2R5RWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS1hY2NvcmRpb24tc2VjdGlvbi1ib2R5LVwiIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VIZWFkZXJBc1NvdXJjZUlkLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VCb2R5QXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogaGVhZGVySWQsIGdldFVzZWRJZDogZ2V0SGVhZGVySWQgfSB9ID0gdXNlUmFuZG9tSWQ8SGVhZGVyRWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS1hY2NvcmRpb24tc2VjdGlvbi1oZWFkZXItXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlQm9keUFzU291cmNlSWRQcm9wcyB9ID0gdXNlQm9keUFzU291cmNlSWQoKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlQm9keUFzUmVmZXJlbmNlcklkUHJvcHMgfSA9IHVzZUJvZHlBc1JlZmVyZW5jZXJJZDxCb2R5RWxlbWVudD4oXCJhcmlhLWxhYmVsbGVkYnlcIiBhcyBuZXZlcik7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlSGVhZGVyQXNTb3VyY2VJZFByb3BzIH0gPSB1c2VIZWFkZXJBc1NvdXJjZUlkKCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUhlYWRlckFzUmVmZXJlbmNlcklkUHJvcHMgfSA9IHVzZUhlYWRlckFzUmVmZXJlbmNlcklkPEhlYWRlckVsZW1lbnQ+KFwiYXJpYS1jb250cm9sc1wiIGFzIG5ldmVyKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb3BlbiA9ICgob3BlbkZyb21Vc2VyID8/IG9wZW5Gcm9tUGFyZW50KSA/PyBmYWxzZSk7XHJcbiAgICAgICAgLy9jb25zdCBnZXRPcGVuID0gdXNlU3RhYmxlR2V0dGVyKCEhb3Blbik7XHJcbiAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VTdGFibGVHZXR0ZXIoaW5kZXgpO1xyXG5cclxuICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldEhlYWRlckVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlSGVhZGVyUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PEhlYWRlckVsZW1lbnQ+KHt9KTtcclxuICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldEJvZHlFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUJvZHlSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8Qm9keUVsZW1lbnQ+KHt9KTtcclxuICAgICAgICBjb25zdCBmb2N1cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGdldEN1cnJlbnRGb2N1c2VkSW5kZXgoKSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgKGdldEhlYWRlckVsZW1lbnQoKSBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkKT8uZm9jdXMoKTtcclxuICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgY29uc3Qgb3BlblJlZiA9IHVzZVJlZih7XHJcbiAgICAgICAgICAgIGdldDogKCkgPT4gISFnZXRPcGVuRnJvbVBhcmVudCgpLFxyXG4gICAgICAgICAgICBzZXQ6IChvcGVuOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXRPcGVuRnJvbVBhcmVudChvcGVuKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob3Blbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlFbGVtZW50ID0gZ2V0Qm9keUVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50Rm9jdXNlZEluZGV4KGdldEluZGV4KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5RWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBib2R5RWxlbWVudC5mb2N1cygpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IHJldHVyblRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB0YWJiZWRSZWYgPSB1c2VSZWYoe1xyXG4gICAgICAgICAgICBnZXQ6ICgpID0+IChnZXRDdXJyZW50Rm9jdXNlZEluZGV4KCkgPT0gZ2V0SW5kZXgoKSksXHJcbiAgICAgICAgICAgIHNldDogKG9wZW46IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChvcGVuKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRGb2N1c2VkSW5kZXgoZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IHJldHVyblRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBfXzogdm9pZCA9IHVzZU1hbmFnZWRDaGlsZCh7XHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDoge1xyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVuOiBvcGVuUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgdGFiYmVkOiB0YWJiZWRSZWYuY3VycmVudFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHN1YkluZm86IHtcclxuICAgICAgICAgICAgICAgICAgICBmb2N1cyxcclxuICAgICAgICAgICAgICAgICAgICBnZXRPcGVuRnJvbVBhcmVudCxcclxuICAgICAgICAgICAgICAgICAgICBzZXRPcGVuRnJvbVBhcmVudFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIGluZm86IHsgaW5kZXgsIHNldE9wZW5Gcm9tUGFyZW50LCBnZXRPcGVuRnJvbVBhcmVudCwgZm9jdXMsIGZsYWdzOiB7IG9wZW46IG9wZW5SZWYuY3VycmVudCwgdGFiYmVkOiB0YWJiZWRSZWYuY3VycmVudCB9IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzKHsgW1wiYXJpYS1leHBhbmRlZFwiXTogYXJpYUV4cGFuZGVkLCBbXCJhcmlhLWRpc2FibGVkXCJdOiBhcmlhRGlzYWJsZWQsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4ge1xyXG5cclxuICAgICAgICAgICAgLy9jb25zdCBvbkZvY3VzID0gKCkgPT4geyBjaGFuZ2VUYWJiZWRJbmRleChpbmRleCk7IH1cclxuICAgICAgICAgICAgY29uc3Qgb25QcmVzcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChnZXRPcGVuRnJvbVBhcmVudCgpKVxyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUV4cGFuZGVkSW5kZXgobnVsbCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRXhwYW5kZWRJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBwcm9wcy50YWJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlQXJpYUJ1dHRvblByb3BzIH0gPSB1c2VBcmlhQnV0dG9uPEhlYWRlckVsZW1lbnQ+KHsgdGFnOiB0YWdCdXR0b24sIGRpc2FibGVkLCBvblByZXNzIH0pO1xyXG4gICAgICAgICAgICBjb25zdCByZXRCID0gdXNlQXJpYUJ1dHRvblByb3BzKHByb3BzKTtcclxuICAgICAgICAgICAgLy9jb25zdCByZXRCID0gdXNlTWVyZ2VkUHJvcHM8SGVhZGVyRWxlbWVudD4odXNlUHJlc3NFdmVudEhhbmRsZXJzPEhlYWRlckVsZW1lbnQ+KG9uQ2xpY2ssIHVuZGVmaW5lZCksIHByb3BzKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxIZWFkZXJFbGVtZW50Pih7XHJcbiAgICAgICAgICAgICAgICAuLi5oYXNGb2N1cyxcclxuICAgICAgICAgICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/Lihmb2N1c2VkLCBwcmV2KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlVGFiYmVkSW5kZXgoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIC8vY29uc3QgcmV0MzogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD5cclxuICAgICAgICAgICAgLy8gICAgPSB1c2VNZXJnZWRQcm9wczxIZWFkZXJFbGVtZW50PihyZXRELCB7IG9uRm9jdXMgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZUhhc0ZvY3VzUHJvcHModXNlTGluZWFyTmF2aWdhdGlvblByb3BzKHVzZUhlYWRlckFzU291cmNlSWRQcm9wcyh1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZFByb3BzKHtcclxuICAgICAgICAgICAgICAgIFwiYXJpYS1leHBhbmRlZFwiOiAoYXJpYUV4cGFuZGVkID8/IG9wZW4gPz8gZmFsc2UpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICBcImFyaWEtZGlzYWJsZWRcIjogKGFyaWFEaXNhYmxlZCA/PyAob3BlbiA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkKSksXHJcbiAgICAgICAgICAgICAgICAuLi51c2VIZWFkZXJSZWZFbGVtZW50UHJvcHMocmV0QilcclxuICAgICAgICAgICAgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PikpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHMoeyByb2xlLCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXQxID0gdXNlQm9keUFzUmVmZXJlbmNlcklkUHJvcHMoeyByb2xlOiByb2xlID8/IFwicmVnaW9uXCIsIC4uLnByb3BzIH0pO1xyXG4gICAgICAgICAgICBjb25zdCByZXQyID0gdXNlQm9keUFzU291cmNlSWRQcm9wcyhyZXQxKTtcclxuICAgICAgICAgICAgcmV0Mi50YWJJbmRleCA/Pz0gLTE7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VCb2R5UmVmRWxlbWVudFByb3BzKHJldDIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgYWNjb3JkaW9uU2VjdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgZXhwYW5kZWQ6IG9wZW4sXHJcbiAgICAgICAgICAgICAgICBmb2N1c2VkOiAoZ2V0Q3VycmVudEZvY3VzZWRJbmRleCgpID09IGluZGV4KSxcclxuICAgICAgICAgICAgICAgIGJvZHlJZCxcclxuICAgICAgICAgICAgICAgIGhlYWRlcklkLFxyXG4gICAgICAgICAgICAgICAgZ2V0Qm9keUlkLFxyXG4gICAgICAgICAgICAgICAgZ2V0SGVhZGVySWRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcyxcclxuICAgICAgICAgICAgdXNlQXJpYUFjY29yZGlvblNlY3Rpb25Cb2R5UHJvcHMsXHJcblxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWNSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcclxuICAgICAgICBhY2NvcmRpb246IHsgY2hhbmdlRXhwYW5kZWRJbmRleCB9LFxyXG4gICAgICAgIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uLFxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFbGVtZW50VG9UYWcgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VQcmVzc0V2ZW50SGFuZGxlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcblxyXG5pbnRlcmZhY2UgVUxJPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcclxuICAgIHByZWZpeExhYmVsOiBzdHJpbmc7XHJcbiAgICBwcmVmaXhJbnB1dDogc3RyaW5nO1xyXG4gICAgdGFnSW5wdXQ6IEVsZW1lbnRUb1RhZzxJbnB1dEVsZW1lbnQ+O1xyXG4gICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBMYWJlbE9taXRzID0ga2V5b2YgVUxJPGFueSwgYW55PjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGFiZWxQYXJhbWV0ZXJzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExPbWl0cyBleHRlbmRzIExhYmVsT21pdHM+IHtcclxuICAgIGxhYmVsOiBPbWl0PFVMSTxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIExPbWl0cz5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMYWJlbFJldHVyblR5cGVJbmZvIHtcclxuICAgIGxhYmVsOiB7XHJcbiAgICAgICAgbGFiZWxJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGlucHV0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAvKiogKipTdGFibGUqKiAqL1xyXG4gICAgICAgIGdldExhYmVsSWQ6ICgpID0+IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAvKiogKipTdGFibGUqKiAqL1xyXG4gICAgICAgIGdldElucHV0SWQ6ICgpID0+IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMYWJlbFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMYWJlbFJldHVyblR5cGVJbmZvIHtcclxuICAgIC8qKiAqTm90YWJseSB1bnN0YWJsZSogKi9cclxuICAgIHVzZUxhYmVsSW5wdXQ6ICgpID0+IHsgdXNlTGFiZWxJbnB1dFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47IH07XHJcbiAgICAvKiogKk5vdGFibHkgdW5zdGFibGUqICovXHJcbiAgICB1c2VMYWJlbExhYmVsOiAoKSA9PiB7IHVzZUxhYmVsTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+OyB9O1xyXG59XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBJRCBhbmQgXCJhcmlhLWxhYmVsbGVkYnlcIiBmb3IgdHdvIGVsZW1lbnRzLCBhbiBcImlucHV0XCIgZWxlbWVudCBhbmQgYSBcImxhYmVsXCIgZWxlbWVudC5cclxuICogXHJcbiAqIFJldHVybnMgdGhlIGB1c2VSZWZlcmVuY2VkSWRQcm9wc2AgaG9va3MgaWYgeW91IG5lZWQgdG8gYWxzbyBhZGQgb3RoZXIgSUQtcmVmZXJlbmNlciBhdHRyaWJ1dGVzLCBsaWtlIGBmb3JgXHJcbiAqIFxyXG4gKiBAc2VlIHVzZUlucHV0TGFiZWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMYWJlbDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxhYmVsOiB7IHByZWZpeElucHV0LCBwcmVmaXhMYWJlbCwgdGFnSW5wdXQsIHRhZ0xhYmVsIH0gfTogVXNlTGFiZWxQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBuZXZlcj4pOiBVc2VMYWJlbFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcclxuXHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlTGFiZWxBc1NvdXJjZUlkLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VMYWJlbEFzUmVmZXJlbmNlcklkLCByYW5kb21JZDogeyB1c2VkSWQ6IGxhYmVsSWQsIGdldFVzZWRJZDogZ2V0TGFiZWxJZCB9IH0gPSB1c2VSYW5kb21JZDxMYWJlbEVsZW1lbnQ+KHsgcmFuZG9tSWQ6IHsgcHJlZml4OiBwcmVmaXhMYWJlbCB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VJbnB1dEFzU291cmNlSWQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUlucHV0QXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogaW5wdXRJZCwgZ2V0VXNlZElkOiBnZXRJbnB1dElkIH0gfSA9IHVzZVJhbmRvbUlkPElucHV0RWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IHByZWZpeElucHV0IH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlTGFiZWxBc1NvdXJjZUlkUHJvcHMgfSA9IHVzZUxhYmVsQXNTb3VyY2VJZCgpO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlSW5wdXRBc1NvdXJjZUlkUHJvcHMgfSA9IHVzZUlucHV0QXNTb3VyY2VJZCgpO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUxhYmVsQXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlTGFiZWxBc1JlZmVyZW5jZXJJZDxJbnB1dEVsZW1lbnQ+KFwiYXJpYS1sYWJlbGxlZGJ5XCIgYXMgbmV2ZXIpO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUlucHV0QXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlSW5wdXRBc1JlZmVyZW5jZXJJZDxMYWJlbEVsZW1lbnQ+KFwiZm9yXCIpO1xyXG5cclxuICAgIGNvbnN0IGlzU3ludGhldGljTGFiZWwgPSAodGFnSW5wdXQgIT0gXCJpbnB1dFwiIHx8IHRhZ0xhYmVsICE9IFwibGFiZWxcIik7XHJcblxyXG4gICAgY29uc3QgdXNlTGFiZWxMYWJlbDogKCgpID0+IHsgdXNlTGFiZWxMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47IH0pID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTGFiZWxMYWJlbCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VMYWJlbExhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNXaXRob3V0Rm9yID0gdXNlTGFiZWxBc1NvdXJjZUlkUHJvcHMocHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNXaXRoRm9yID0gdXNlSW5wdXRBc1JlZmVyZW5jZXJJZFByb3BzKHByb3BzV2l0aG91dEZvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnTGFiZWwgPT0gXCJsYWJlbFwiICYmIHRhZ0lucHV0ID09IFwiaW5wdXRcIilcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNXaXRoRm9yO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1dpdGhvdXRGb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbaXNTeW50aGV0aWNMYWJlbF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUxhYmVsSW5wdXQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VMYWJlbElucHV0KCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUxhYmVsSW5wdXRQcm9wczogKHsgXCJhcmlhLWxhYmVsbGVkYnlcIjogYXJpYUxhYmVsbGVkYnksIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCFhcmlhTGFiZWxsZWRieSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNXaXRob3V0QXJpYUxhYmVsbGVkQnkgPSB1c2VJbnB1dEFzU291cmNlSWRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhBcmlhTGFiZWxsZWRCeSA9IHVzZUxhYmVsQXNSZWZlcmVuY2VySWRQcm9wcyhwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTeW50aGV0aWNMYWJlbCAmJiAhcHJvcHNbXCJhcmlhLWxhYmVsXCJdKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1dpdGhBcmlhTGFiZWxsZWRCeTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNXaXRob3V0QXJpYUxhYmVsbGVkQnk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2lzU3ludGhldGljTGFiZWxdKVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTGFiZWxJbnB1dCxcclxuICAgICAgICB1c2VMYWJlbExhYmVsLFxyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIGxhYmVsSWQsXHJcbiAgICAgICAgICAgIGlucHV0SWQsXHJcbiAgICAgICAgICAgIGdldExhYmVsSWQsXHJcbiAgICAgICAgICAgIGdldElucHV0SWRcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgdHlwZSBDaGVja2JveENoZWNrZWRUeXBlID0gYm9vbGVhbiB8IFwibWl4ZWRcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICBsYWJlbDogVXNlTGFiZWxQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlLCBcInByZWZpeExhYmVsXCIgfCBcInByZWZpeElucHV0XCI+W1wibGFiZWxcIl07XHJcbiAgICBjaGVja2JveExpa2U6IHtcclxuICAgICAgICBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCI7XHJcbiAgICAgICAgLyoqIFRoZSByb2xlIGF0dHJpYnV0ZSB0byB1c2UsIHdoZW4gYXBwbGljYWJsZSAqL1xyXG4gICAgICAgIHJvbGU6IHN0cmluZztcclxuICAgICAgICBkaXNhYmxlZDogYm9vbGVhbjtcclxuICAgICAgICBjaGVja2VkOiBDaGVja2JveENoZWNrZWRUeXBlO1xyXG4gICAgICAgIG9uSW5wdXQ/KGV2ZW50OiBoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0VHlwZT4pOiB2b2lkO1xyXG4gICAgICAgIG9uSW5wdXQ/KGV2ZW50OiBoLkpTWC5UYXJnZXRlZEV2ZW50PExhYmVsVHlwZT4pOiB2b2lkO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBoYW5kbGVzSW5wdXQgPSA8RSBleHRlbmRzIEVsZW1lbnQ+KHRhZzogRWxlbWVudFRvVGFnPEU+LCBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCIsIHdoaWNoOiBcImlucHV0LWVsZW1lbnRcIiB8IFwibGFiZWwtZWxlbWVudFwiKSA9PiB7XHJcbiAgICBpZiAobGFiZWxQb3NpdGlvbiA9PT0gXCJzZXBhcmF0ZVwiKSB7XHJcbiAgICAgICAgaWYgKHdoaWNoID09PSBcImlucHV0LWVsZW1lbnRcIilcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgZWxzZSBpZiAod2hpY2ggPT09IFwibGFiZWwtZWxlbWVudFwiKVxyXG4gICAgICAgICAgICByZXR1cm4gdGFnICE9IFwiaW5wdXRcIjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT09IFwid3JhcHBpbmdcIikge1xyXG4gICAgICAgIGlmICh3aGljaCA9PT0gXCJpbnB1dC1lbGVtZW50XCIpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAod2hpY2ggPT0gXCJsYWJlbC1lbGVtZW50XCIpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50PElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4ge1xyXG4gICAgZ2V0SW5wdXRFbGVtZW50OiAoKSA9PiBJbnB1dFR5cGUgfCBudWxsO1xyXG4gICAgLyoqICpVbnN0YWJsZSogKi9cclxuICAgIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzOiAoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQ8TGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7XHJcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xyXG4gICAgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHM6ICh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZUluZm88SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMYWJlbFJldHVyblR5cGVJbmZvIHtcclxuICAgIGNoZWNrYm94TGlrZToge1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgZ2V0TGFiZWxFbGVtZW50OiAoKSA9PiBMYWJlbFR5cGUgfCBudWxsO1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgZ2V0SW5wdXRFbGVtZW50OiAoKSA9PiBJbnB1dFR5cGUgfCBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUsIExhYmVsVHlwZT4ge1xyXG4gICAgLyoqICpOb3RhYmx5IHVuc3RhYmxlKiAqL1xyXG4gICAgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50OiBVc2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQ8SW5wdXRUeXBlPjtcclxuICAgIC8qKiAqTm90YWJseSB1bnN0YWJsZSogKi9cclxuICAgIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudDogKCkgPT4geyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wczogKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPjsgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhhbmRsZXMgbGFiZWwgdHlwZSAod3JhcHBpbmcgb3Igc2VwYXJhdGUpIGZvciBjaGVja2JveGVzLCByYWRpb3MsIHN3aXRjaGVzLCBldGMuXHJcbiAqIFxyXG4gKiBJZiBpdCdzIGEgdG9nZ2xlYWJsZSBjbGljay10aGluZyB3aXRoIGEgbGFiZWwgKHRoYXQgY2FuIGFsc28gYmUgY2xpY2tlZCksIHRoZW4gaXQncyBhIGNoZWNrYm94LWxpa2UuXHJcbiAqIEBwYXJhbSBwYXJhbTAgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoZWNrYm94TGlrZTxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50Pih7IGNoZWNrYm94TGlrZTogeyBjaGVja2VkLCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgcm9sZSwgb25JbnB1dCB9LCBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSB9OiBVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPik6IFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRUeXBlLCBMYWJlbFR5cGU+IHtcclxuXHJcbiAgICBjb25zdCBzdGFibGVPbklucHV0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlPiB8IGguSlNYLlRhcmdldGVkRXZlbnQ8TGFiZWxUeXBlPikgPT4geyBlLnByZXZlbnREZWZhdWx0KCk7IG9uSW5wdXQ/LihlIGFzIGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlPik7IH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dDogdXNlSUxJbnB1dCwgdXNlTGFiZWxMYWJlbDogdXNlSUxMYWJlbCwgbGFiZWwgfSA9IHVzZUxhYmVsPElucHV0VHlwZSwgTGFiZWxUeXBlPih7IGxhYmVsOiB7IHByZWZpeExhYmVsOiBcImFyaWEtY2hlY2tib3gtbGFiZWwtXCIsIHByZWZpeElucHV0OiBcImFyaWEtY2hlY2tib3gtaW5wdXQtXCIsIHRhZ0lucHV0OiB0YWdJbnB1dCwgdGFnTGFiZWw6IHRhZ0xhYmVsIH0gfSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0TGFiZWxFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUxhYmVsUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PExhYmVsVHlwZT4oKTtcclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0SW5wdXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUlucHV0UmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PElucHV0VHlwZT4oKTtcclxuXHJcbiAgICBjb25zdCB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQ6IFVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDxJbnB1dFR5cGU+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKSB7XHJcbiAgICAgICAgY29uc3QgdGFnID0gdGFnSW5wdXQ7XHJcbiAgICAgICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHM6IHVzZUlMSW5wdXRQcm9wcyB9ID0gdXNlSUxJbnB1dCgpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PElucHV0VHlwZT4oe30pO1xyXG5cclxuICAgICAgICAvLyBvbkNsaWNrIGFuZCBvbkNoYW5nZSBhcmUgYSBiaXQgbWVzc3ksIHNvIHdlIG5lZWQgdG9cclxuICAgICAgICAvLyAqYWx3YXlzKiBtYWtlIHN1cmUgdGhhdCB0aGUgdmlzaWJsZSBzdGF0ZSBpcyBjb3JyZWN0XHJcbiAgICAgICAgLy8gYWZ0ZXIgYWxsIHRoZSBldmVudCBkdXN0IHNldHRsZXMuXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzI3NDUsXHJcbiAgICAgICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzE4OTkjaXNzdWVjb21tZW50LTUyNTY5MDE5NFxyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHRhZyA9PSBcImlucHV0XCIpIHtcclxuICAgICAgICAgICAgICAgIChlbGVtZW50IGFzIEVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkuaW5kZXRlcm1pbmF0ZSA9IChjaGVja2VkID09PSBcIm1peGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgKGVsZW1lbnQgYXMgRWxlbWVudCBhcyBIVE1MSW5wdXRFbGVtZW50KS5jaGVja2VkID0gKGNoZWNrZWQgPT09IHRydWUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbdGFnLCBjaGVja2VkXSlcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgZ2V0SW5wdXRFbGVtZW50OiBnZXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyB9O1xyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPiB7XHJcblxyXG4gICAgICAgICAgICAvLyBGb3Igc29tZSByZWFzb24sIENocm9tZSB3b24ndCBmaXJlIG9uSW5wdXQgZXZlbnRzIGZvciByYWRpbyBidXR0b25zIHRoYXQgYXJlIHRhYkluZGV4PS0xPz9cclxuICAgICAgICAgICAgLy8gTmVlZHMgaW52ZXN0aWdhdGluZywgYnV0IG9uSW5wdXQgd29ya3MgZmluZSBpbiBGaXJlZm94XHJcbiAgICAgICAgICAgIC8vIFRPRE9cclxuICAgICAgICAgICAgbGV0IHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+ID0gdXNlUHJlc3NFdmVudEhhbmRsZXJzPElucHV0VHlwZT4oZGlzYWJsZWQgfHwgIWhhbmRsZXNJbnB1dCh0YWcsIGxhYmVsUG9zaXRpb24sIFwiaW5wdXQtZWxlbWVudFwiKSA/IHVuZGVmaW5lZCA6IHN0YWJsZU9uSW5wdXQsIHVuZGVmaW5lZCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGFnID09IFwiaW5wdXRcIilcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uSW5wdXQgPSAoZTogRXZlbnQpID0+IGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIHByb3BzID0gdXNlUmVmRWxlbWVudFByb3BzKHVzZUlMSW5wdXRQcm9wcyhwcm9wcykpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgd3JhcHBlZCBsYWJlbCBoYW5kbGVzIGFsbCBpbnRlcmFjdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGlzIGVsZW1lbnQgY2FuJ3QgYmUgaW50ZXJhY3RlZCB3aXRoXHJcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGl0J3MgYW4gaW5wdXQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgIHByb3BzLmluZXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcclxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1oaWRkZW5cIl0gPSBcInRydWVcIjtcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uRm9jdXMgPSBfID0+IChnZXRMYWJlbEVsZW1lbnQoKSBhcyBIVE1MRWxlbWVudCB8IG51bGwpPy5mb2N1cygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gXCJpbnB1dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCA9IChjaGVja2VkID09PSB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnJvbGUgPSByb2xlO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtY2hlY2tlZFwiXSA9IGNoZWNrZWQgPT09IFwibWl4ZWRcIiA/IFwibWl4ZWRcIiA6IGNoZWNrZWQgPT09IHRydWUgPyBcInRydWVcIiA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IGRpc2FibGVkLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBsYWJlbCBjbGlja3MgY2FuJ3QgYWZmZWN0IHRoZSBjaGVja2JveCB3aGlsZSBpdCdzIGRpc2FibGVkXHJcbiAgICAgICAgICAgIHByb3BzLm9uQ2xpY2sgPSBkaXNhYmxlZCA/ICgoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSkgOiBwcm9wcy5vbkNsaWNrO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZUlucHV0UmVmRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzPElucHV0VHlwZT4ocDAsIHByb3BzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3VzZUlMSW5wdXQsIHJvbGUsIGxhYmVsUG9zaXRpb24sIGRpc2FibGVkLCBjaGVja2VkLCB0YWdJbnB1dF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KCkge1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ0xhYmVsO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlTGFiZWxMYWJlbFByb3BzOiB1c2VJTExhYmVsUHJvcHMgfSA9IHVzZUlMTGFiZWwoKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPiB7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBuZXdQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPiA9IHVzZVByZXNzRXZlbnRIYW5kbGVyczxMYWJlbFR5cGU+KGRpc2FibGVkIHx8ICFoYW5kbGVzSW5wdXQodGFnLCBsYWJlbFBvc2l0aW9uLCBcImxhYmVsLWVsZW1lbnRcIikgPyB1bmRlZmluZWQgOiBzdGFibGVPbklucHV0LCB1bmRlZmluZWQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocDAudGFiSW5kZXggPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcy50YWJJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAocDAucm9sZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLnJvbGUgPSByb2xlO1xyXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbXCJhcmlhLWRpc2FibGVkXCJdID0gZGlzYWJsZWQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1jaGVja2VkXCJdID0gY2hlY2tlZC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIG9uZSBjYXNlIHdoZXJlIHRoZXJlJ3MgYWxtb3N0IG5vdGhpbmcgdG8gZG9cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IG5vcm1hbCBjYXNlIHdoZXJlIGV2ZXJ5dGhpbmcgYWN0cyBhY2NvcmRpbmcgbm9ybWFsIEhUTUwgbWVjaGFuaWNzLlxyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSnVzdCBtYWtlIHN1cmUgdGhhdCBsYWJlbCBjbGlja3MgY2FuJ3QgYWZmZWN0IHRoZSBjaGVja2JveCB3aGlsZSBpdCdzIGRpc2FibGVkXHJcbiAgICAgICAgICAgIG5ld1Byb3BzLm9uQ2xpY2sgPSBkaXNhYmxlZCA/ICgoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSkgOiBuZXdQcm9wcy5vbkNsaWNrO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHVzZUxhYmVsUmVmRWxlbWVudFByb3BzKHVzZU1lcmdlZFByb3BzPExhYmVsVHlwZT4obmV3UHJvcHMsIHVzZUlMTGFiZWxQcm9wcyhwMCkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzIH07XHJcblxyXG4gICAgfSwgW3VzZUlMTGFiZWwsIGRpc2FibGVkLCBjaGVja2VkLCByb2xlLCBsYWJlbFBvc2l0aW9uLCB0YWdMYWJlbF0pO1xyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCxcclxuICAgICAgICB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsXHJcbiAgICAgICAgY2hlY2tib3hMaWtlOiB7XHJcbiAgICAgICAgICAgIGdldExhYmVsRWxlbWVudCxcclxuICAgICAgICAgICAgZ2V0SW5wdXRFbGVtZW50LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFiZWxcclxuICAgIH07XHJcblxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZGVidWdMb2csIEVuaGFuY2VkRXZlbnQsIGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VDaGVja2JveExpa2UsIFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnMsIFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCB0eXBlIENoZWNrYm94Q2hhbmdlRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IEVuaGFuY2VkRXZlbnQ8RSwgRXZlbnQsIHsgY2hlY2tlZDogYm9vbGVhbiB9PjtcclxuXHJcbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94SW5wdXRFbGVtZW50PElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzOiAoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+OyB9XHJcbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94TGFiZWxFbGVtZW50PExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzOiAoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+OyB9XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhQ2hlY2tib3hQYXJhbWV0ZXJzPEkgZXh0ZW5kcyBFbGVtZW50LCBMIGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgY2hlY2tib3hMaWtlOiBPbWl0PFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgTD5bXCJjaGVja2JveExpa2VcIl0sIFwib25JbnB1dFwiIHwgXCJyb2xlXCI+O1xyXG4gICAgbGFiZWw6IFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgTD5bXCJsYWJlbFwiXTtcclxuICAgIGNoZWNrYm94OiB7XHJcbiAgICAgICAgb25JbnB1dD8oZXZlbnQ6IENoZWNrYm94Q2hhbmdlRXZlbnQ8ST4pOiB2b2lkO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFDaGVja2JveFJldHVyblR5cGVJbmZvPElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZUluZm88SW5wdXRUeXBlLCBMYWJlbFR5cGU+IHtcclxuICAgIC8vY2hlY2tib3hMaWtlOiBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlPElucHV0VHlwZSwgTGFiZWxUeXBlPltcImNoZWNrYm94TGlrZVwiXTtcclxuICAgIC8vbGFiZWw6IFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGU8SW5wdXRUeXBlLCBMYWJlbFR5cGU+W1wibGFiZWxcIl07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYUNoZWNrYm94UmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFyaWFDaGVja2JveFJldHVyblR5cGVJbmZvPElucHV0VHlwZSwgTGFiZWxUeXBlPiB7XHJcbiAgICAvKiogKipOb3RhYmx5IHVuc3RhYmxlKiogKi9cclxuICAgIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50OiBVc2VDaGVja2JveElucHV0RWxlbWVudDxJbnB1dFR5cGU+O1xyXG4gICAgLyoqICoqTm90YWJseSB1bnN0YWJsZSoqICovXHJcbiAgICB1c2VDaGVja2JveExhYmVsRWxlbWVudDogVXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQ8TGFiZWxUeXBlPjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFDaGVja2JveDxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50Pih7IGNoZWNrYm94TGlrZSwgbGFiZWwsIGNoZWNrYm94IH06IFVzZUFyaWFDaGVja2JveFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KTogVXNlQXJpYUNoZWNrYm94UmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dFR5cGUsIExhYmVsVHlwZT4ge1xyXG4gICAgZGVidWdMb2coXCJ1c2VBcmlhQ2hlY2tib3hcIik7XHJcblxyXG4gICAgY29uc3QgeyBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgY2hlY2tlZCB9ID0gY2hlY2tib3hMaWtlO1xyXG4gICAgY29uc3QgeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSA9IGxhYmVsO1xyXG4gICAgY29uc3QgeyBvbklucHV0IH0gPSBjaGVja2JveDtcclxuXHJcbiAgICBjb25zdCBvbklucHV0RW5oYW5jZWQgPSAoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxJbnB1dFR5cGU+KSA9PiBvbklucHV0Py4oZW5oYW5jZUV2ZW50PElucHV0VHlwZSwgRXZlbnQsIHsgY2hlY2tlZDogYm9vbGVhbiB9PihlLCB7IGNoZWNrZWQ6ICFjaGVja2VkIH0pKTtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsIC4uLmNoZWNrYm94TGlrZVJlc3QgfSA9IHVzZUNoZWNrYm94TGlrZTxJbnB1dFR5cGUsIExhYmVsVHlwZT4oeyBjaGVja2JveExpa2U6IHsgcm9sZTogXCJjaGVja2JveFwiLCBjaGVja2VkLCBvbklucHV0OiBvbklucHV0RW5oYW5jZWQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCB9LCBsYWJlbCB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VDaGVja2JveElucHV0RWxlbWVudDogVXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQ8SW5wdXRUeXBlPiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCkge1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ0lucHV0O1xyXG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCgpO1xyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzIH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+KSB7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRUeXBlPiA9IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzKHAwKTtcclxuICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCA/Pz0gISFjaGVja2VkO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRhZyA9PSBcImlucHV0XCIpXHJcbiAgICAgICAgICAgICAgICBwcm9wcy50eXBlID0gXCJjaGVja2JveFwiO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQsIGNoZWNrZWQsIGxhYmVsUG9zaXRpb24sIGRpc2FibGVkLCB0YWdJbnB1dF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoKSB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50KCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIH07XHJcbiAgICB9LCBbdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50LCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgdGFnTGFiZWxdKTtcclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VDaGVja2JveElucHV0RWxlbWVudCxcclxuICAgICAgICB1c2VDaGVja2JveExhYmVsRWxlbWVudCxcclxuICAgICAgICAuLi5jaGVja2JveExpa2VSZXN0XHJcbiAgICB9O1xyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyByZXR1cm5GYWxzZSwgdXNlRWZmZWN0LCB1c2VMaXN0TmF2aWdhdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgdXNlTWVyZ2VkUHJvcHMsIHVzZVBhc3NpdmVTdGF0ZSwgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvLCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IENoZWNrYm94Q2hlY2tlZFR5cGUgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcclxuaW1wb3J0IHsgZGVidWdMb2csIGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyBDaGVja2JveENoYW5nZUV2ZW50LCB1c2VBcmlhQ2hlY2tib3gsIFVzZUFyaWFDaGVja2JveFBhcmFtZXRlcnMsIFVzZUFyaWFDaGVja2JveFJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWNoZWNrYm94XCI7XHJcblxyXG5leHBvcnQgdHlwZSBDaGVja2JveEdyb3VwQ2hhbmdlRXZlbnQ8RXZlbnRUeXBlIGV4dGVuZHMgRXZlbnQ+ID0gRXZlbnRUeXBlICYgeyBbRXZlbnREZXRhaWxdOiB7IGNoaWxkcmVuQ2hlY2tlZDogYm9vbGVhbiB8IE1hcDxudW1iZXIsIGJvb2xlYW4gfCBcIm1peGVkXCI+IH0gfTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBwYXJlbnQgY2hlY2tib3ggaXMgY2hhbmdlZCBhbmQgYW4gdXBkYXRlIG9mXHJcbiAgICAgKiBhbGwgdGhlIGNoaWxkcmVuIG5lZWRzIHRvIG9jY3VyLlxyXG4gICAgICogXHJcbiAgICAgKiBgZXZlbnRbRXZlbnREZXRhaWxdLmNoaWxkcmVuQ2hlY2tlZGAgd2lsbCBiZSBcclxuICAgICAqICogdHJ1ZSB3aGVuIGFsbCBjaGlsZHJlbiBuZWVkIHRvIGJlY29tZSBjaGVja2VkXHJcbiAgICAgKiAqIGZhbHNlIHdoZW4gYWxsIGNoaWxkcmVuIG5lZWQgdG8gYmVjb21lIHVuY2hlY2tlZFxyXG4gICAgICogKiBBIGBNYXA8aW5kZXgsY2hlY2tlZD5gIG9mIGVhY2ggY2hpbGQncyBzdGF0dXMgd2hlbiByZXZlcnRpbmcgdG8gXCJtaXhlZFwiLlxyXG4gICAgICogXHJcbiAgICAgKiBCZWNhdXNlIHdlJ3JlIGRlYWxpbmcgd2l0aCBjb250cm9sbGVkIGNvbXBvbmVudHMgaGVyZSwgYW5kIHRoZSBkYXRhIGZvclxyXG4gICAgICogd2hhdCBjaGVja2JveGVzIGFyZSBjaGVja2VkIGxpdmUgKm91dHNpZGUqIG9mIGFueSBvZiB0aGVzZSBob29rcyxcclxuICAgICAqIGl0J3MgeW91IHdobydzIHJlc3BvbnNpYmxlIGZvciBsaXN0ZW5pbmcgZm9yIHRoaXMgZXZlbnQsIG1vZGlmeWluZyB0aGVcclxuICAgICAqIGRhdGEsIGFuZCByZS1yZW5kZXJpbmcgYXBwcm9wcmlhdGVseS5cclxuICAgICAqIFxyXG4gICAgICogSGlnaGx5IHJlY29tbWVuZGVkIHRvLCBmb3IgZXhhbXBsZSwgYWRkIGVhY2ggY2hpbGQncyBgb25JbnB1dGAgZXZlbnQgaGFuZGxlclxyXG4gICAgICogYXZhaWxhYmxlIGluIHRoZSBjaGlsZCBpbmZvIHRoZSBwYXJlbnQgZ2V0cyBzbyBpdCBjYW4gY2FsbCB0aGUgaGFuZGxlclxyXG4gICAgICogcmVtb3RlbHkgZnJvbSBgbWFuYWdlZENoZWNrYm94ZXNgLlxyXG4gICAgICogQHBhcmFtIGV2ZW50IFxyXG4gICAgICovXHJcbiAgICAvL2NoZWNrYm94R3JvdXA6IHt9XHJcbiAgICAvL29uVXBkYXRlQ2hpbGRyZW4oZXZlbnQ6IENoZWNrYm94R3JvdXBDaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+Pik6IHZvaWQ7XHJcbn1cclxuXHJcbi8vZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRJbmZvQmFzZTxLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvQmFzZTxLPiB7XHJcbi8qKlxyXG4gKiBUaGUgaWQgYXR0cmlidXRlIHVzZWQgZm9yIHRoZSBjaGlsZC5cclxuICovXHJcbi8vaWQ6IHN0cmluZztcclxuXHJcbi8qKlxyXG4gKiBUaGUgY3VycmVudCBjaGVja2VkIHN0YXRlIG9mIHRoaXMgY2hpbGQuXHJcbiAqIFxyXG4gKiBUaGlzIGlzIHVzZWQgYnkgdGhlIHBhcmVudCB3aGVuZXZlciBpdCdzIGludGVyYWN0ZWQgd2l0aCBcclxuICogYW5kIGFib3V0IHRvIGZvcmNlIGV2ZXJ5IG9uZSB0byBiZSBzb21ldGhpbmcgZGlmZmVyZW50IC0tIFxyXG4gKiBpdCB3aWxsIHNhdmUgdGhlIHN0YXRlIG9mIGFsbCBjaGlsZCBjaGVja2JveGVzIGZvciBsYXRlclxyXG4gKiBieSBhc2tpbmcgZWFjaCBvbmUgd2hhdCBpdHMgY3VycmVudCBzdGF0ZSBpcyBpbmRpdmlkdWFsbHlcclxuICogYXQgdGhhdCBtb21lbnQuXHJcbiAqIFxyXG4gKiBBbGwgdGhlIGNoZWNrYm94J3Mgc3RhdGVzIGFyZSBjYXB0dXJlZCB3aGVuIHRoZSBwYXJlbnRcclxuICogaXMgaW4gdGhlIFwibWl4ZWRcIiBzdGF0ZSBhbmQgaXMgY2xpY2tlZC4gSXQga2VlcHMgdGhlbVxyXG4gKiB0aGF0IHdheSB1bnRpbCB0aGUgc2FtZSBjb25kaXRpb25zIGFyaXNlIGFnYWluLlxyXG4gKi9cclxuLy8gICAgZ2V0TGFzdFVzZXJDaGVja2VkKCk6IGJvb2xlYW4gfCBcIm1peGVkXCI7XHJcbi8vICAgIG9uSW5wdXQ6IFVzZUFyaWFDaGVja2JveFBhcmFtZXRlcnM8YW55LCBhbnk+W1wib25JbnB1dFwiXTtcclxuLy99XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENCRyB7XHJcbiAgICBjaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiO1xyXG4gICAgZ2V0TGFzdFVzZXJDaGVja2VkKCk6IGJvb2xlYW4gfCBcIm1peGVkXCI7XHJcbiAgICBvbklucHV0OiBVc2VBcmlhQ2hlY2tib3hQYXJhbWV0ZXJzPGFueSwgYW55PltcImNoZWNrYm94XCJdW1wib25JbnB1dFwiXTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICBhc0NoZWNrYm94OiBVc2VBcmlhQ2hlY2tib3hQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PjtcclxuICAgIGFzQ2hlY2tib3hHcm91cENoaWxkOiB7XHJcbiAgICAgICAgbWFuYWdlZENoaWxkOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIENCRywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPltcIm1hbmFnZWRDaGlsZFwiXTtcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogT21pdDxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIENCRywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPltcImxpc3ROYXZpZ2F0aW9uXCJdLCBcInN1YkluZm9cIj47XHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgQ0JHLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+W1wicm92aW5nVGFiSW5kZXhcIl07XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQXJpYUNoZWNrYm94UmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50PiB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4ge1xyXG4gICAgdXNlQ2hlY2tib3hHcm91cENoaWxkSW5wdXRQcm9wczogKHsgdGFiSW5kZXgsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47XHJcbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzOiAoeyB0YWJJbmRleCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hHcm91cENoaWxkPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KSA9PiBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiAvKntcclxuICAgIC8vdGFiYmFibGU6IGJvb2xlYW4gfCBudWxsO1xyXG4gICAgY2hlY2tib3hMaWtlOiBVc2VBcmlhQ2hlY2tib3hSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImNoZWNrYm94TGlrZVwiXTtcclxuICAgIGxhYmVsOiBVc2VBcmlhQ2hlY2tib3hSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImxhYmVsXCJdO1xyXG4gICAgcm92aW5nVGFiSW5kZXg6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPElucHV0RWxlbWVudD5bXCJyb3ZpbmdUYWJJbmRleFwiXTtcclxuICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHM6ICh7IHRhYkluZGV4LCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+O1xyXG4gICAgdXNlQ2hlY2tib3hHcm91cENoaWxkTGFiZWxQcm9wczogKHsgdGFiSW5kZXgsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XHJcbn0qL1xyXG5cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCwgQ0JHLCBuZXZlcj4ge1xyXG4gICAgY2hlY2tib3hHcm91cDoge1xyXG4gICAgICAgIHBhcmVudElzQ2hlY2tlZDogYm9vbGVhbiB8IFwibWl4ZWRcIjtcclxuICAgICAgICBwYXJlbnRQZXJjZW50Q2hlY2tlZDogbnVtYmVyO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4ge1xyXG4gICAgLyoqICoqU1RBQkxFICoqICovXHJcbiAgICAvL2NoZWNrYm94ZXM6IE1hbmFnZWRDaGlsZHJlbjxJPjtcclxuICAgIC8qKlxyXG4gICAgICogRWFjaCBjaGlsZCBjaGVja2JveCBtdXN0IGNhbGwgdGhpcyBob29rLCAqaW4gYWRkaXRpb24gdG8qIGB1c2VBcmlhQ2hlY2tib3hgXHJcbiAgICAgKi9cclxuICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZDogVXNlQ2hlY2tib3hHcm91cENoaWxkPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhcmVudCBjaGVja2JveCBtdXN0IHVzZSB0aGlzIGhvb2tcclxuICAgICAqIFxyXG4gICAgICogKipOb3RhYmx5IHVuc3RhYmxlISoqIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGBhcmlhQ29udHJvbHNgLCBwb3B1bGF0ZWQgYnkgYWxsIGNoaWxkIGNoZWNrYm94ZXNcclxuICAgICAqL1xyXG4gICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0OiBVc2VDaGVja2JveEdyb3VwUGFyZW50PElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICBjaGVja2JveDogT21pdDxVc2VBcmlhQ2hlY2tib3hQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImNoZWNrYm94XCJdLCBcIm9uSW5wdXRcIj47XHJcbiAgICBsYWJlbDogVXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD5bXCJsYWJlbFwiXTtcclxuICAgIGNoZWNrYm94TGlrZTogT21pdDxVc2VBcmlhQ2hlY2tib3hQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImNoZWNrYm94TGlrZVwiXSwgXCJjaGVja2VkXCI+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveEdyb3VwUGFyZW50PElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGE6IFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PikgPT4ge1xyXG4gICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjtcclxuICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFxyXG4gKiBcclxuICogQHBhcmFtIHBhcmFtMCBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hlY2tib3hHcm91cDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCB0eXBlYWhlYWROYXZpZ2F0aW9uIH06IFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzKTogVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcclxuICAgIGRlYnVnTG9nKFwidXNlQXJpYUNoZWNrYm94R3JvdXBcIik7XHJcbiAgICAvL2NvbnN0IG9uVXBkYXRlQ2hpbGRyZW4gPSB1c2VTdGFibGVDYWxsYmFjayhvblVwZGF0ZUNoaWxkcmVuVW5zdGFibGUgPz8gKCgpID0+IHt9KSk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIC4uLmxpc3RSZXR1cm5UeXBlXHJcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb248SW5wdXRFbGVtZW50LCBJbnB1dEVsZW1lbnQsIENCRywgbmV2ZXI+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcclxuICAgICAgICByb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9IH0gPSBsaXN0UmV0dXJuVHlwZTtcclxuXHJcbiAgICAvL2NvbnN0IFt1bmNoZWNrZWRDb3VudCwgc2V0VW5oZWNrZWRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcblxyXG4gICAgLy8gS2VlcCB0cmFjayBvZiBhbGwgY2hpbGQgSURzLCBhbmQgYW55IHRpbWUgYW55IG9mIHRoZW0gY2hhbmdlLCBcclxuICAgIC8vIGdlbmVyYXRlIGEgbmV3IHN0cmluZyB3aXRoIGFsbCBvZiB0aGVtIGNvbmNhdGVuYXRlZCB0b2dldGhlclxyXG4gICAgLy8gKGJ1dCBvbmx5IG9uY2UgcGVyIHJlbmRlcik7XHJcbiAgICBjb25zdCBhbGxJZHMgPSB1c2VSZWYobmV3IFNldDxzdHJpbmc+KCkpO1xyXG4gICAgY29uc3QgW2FyaWFDb250cm9scywgc2V0QXJpYUNvbnRyb2xzXSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gICAgY29uc3QgW3VwZGF0ZUluZGV4LCBzZXRJZFVwZGF0ZUluZGV4XSA9IHVzZVN0YXRlKDApO1xyXG5cclxuXHJcbiAgICBjb25zdCBbY2hlY2tlZENvdW50LCBzZXRDaGVja2VkQ291bnRdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBjaGVja2VkSW5kaWNlcyA9IHVzZVJlZihuZXcgU2V0PG51bWJlcj4oKSk7XHJcbiAgICAvL2NvbnN0IFtzZWxmSXNDaGVja2VkLCBzZXRTZWxmSXNDaGVja2VkLCBnZXRTZWxmSXNDaGVja2VkXSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBcIm1peGVkXCI+KGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCBnZXRTZWxmSXNDaGVja2VkVW5zdGFibGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGNoZWNrZWRDb3VudCAvIChjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSArIDEpO1xyXG4gICAgICAgIHJldHVybiBwZXJjZW50YWdlIDw9IDAgPyBmYWxzZSA6IHBlcmNlbnRhZ2UgPj0gMSA/IHRydWUgOiBcIm1peGVkXCI7XHJcbiAgICB9LCBbY2hlY2tlZENvdW50XSk7XHJcblxyXG4gICAgY29uc3QgZ2V0U2VsZklzQ2hlY2tlZFN0YWJsZSA9IHVzZVN0YWJsZUNhbGxiYWNrKGdldFNlbGZJc0NoZWNrZWRVbnN0YWJsZSk7XHJcbiAgICBjb25zdCBbc2V0UGFyZW50Q2hlY2tib3hDaGVja2VkLCBzZXRTZXRQYXJlbnRDaGVja2JveENoZWNrZWRdID0gdXNlU3RhdGU8U3RhdGVVcGRhdGVyPENoZWNrYm94Q2hlY2tlZFR5cGU+IHwgbnVsbD4obnVsbCk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldFBhcmVudENoZWNrYm94Q2hlY2tlZD8uKGNoZWNrZWRDb3VudCA9PSAwID8gZmFsc2UgOiBjaGVja2VkQ291bnQgPT0gKGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpICsgMSkgPyB0cnVlIDogXCJtaXhlZFwiKTtcclxuICAgIH0sIFtzZXRQYXJlbnRDaGVja2JveENoZWNrZWQsIGNoZWNrZWRDb3VudF0pXHJcblxyXG4gICAgLy8gSWYgdGhlIHVzZXIgaGFzIGNoYW5nZWQgdGhlIHBhcmVudCBjaGVja2JveCdzIHZhbHVlLCB0aGVuIHRoaXMgcmVmIGhvbGRzIGEgbWVtb3J5IG9mIHdoYXQgdmFsdWVzIHdlcmUgaGVsZCBiZWZvcmUuXHJcbiAgICAvLyBPdGhlcndpc2UsIGl0J3MgbnVsbCB3aGVuIHRoZSBsYXN0IGlucHV0IHdhcyBmcm9tIGEgY2hpbGQgY2hlY2tib3guIFxyXG4gICAgLy9jb25zdCBzYXZlZENoZWNrZWRWYWx1ZXMgPSB1c2VSZWY8TWFwPG51bWJlciwgYm9vbGVhbiB8IFwibWl4ZWRcIj4gfCBudWxsPihudWxsKTtcclxuICAgIGNvbnN0IHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dCA9IHVzZUNhbGxiYWNrPFVzZUNoZWNrYm94R3JvdXBQYXJlbnQ8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+PigoeyBjaGVja2JveCwgY2hlY2tib3hMaWtlLCBsYWJlbCB9KSA9PiB7XHJcbiAgICAgICAgZGVidWdMb2coXCJ1c2VBcmlhQ2hlY2tib3hHcm91cFBhcmVudFwiKTtcclxuICAgICAgICBjb25zdCB7IC4uLl92b2lkIH0gPSBjaGVja2JveDtcclxuICAgICAgICBjb25zdCB7IGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uIH0gPSBjaGVja2JveExpa2U7XHJcbiAgICAgICAgY29uc3QgeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSA9IGxhYmVsO1xyXG5cclxuICAgICAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZTxDaGVja2JveENoZWNrZWRUeXBlPihmYWxzZSk7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgc2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkKCgpID0+IHNldENoZWNrZWQpO1xyXG4gICAgICAgIH0sIFtdKVxyXG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50IH0gPSB1c2VBcmlhQ2hlY2tib3g8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHsgY2hlY2tib3hMaWtlOiB7IGxhYmVsUG9zaXRpb24sIGNoZWNrZWQsIGRpc2FibGVkLCB9LCBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSwgY2hlY2tib3g6IHsgb25JbnB1dDogb25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQyIGFzIGFueSwgfSB9KTtcclxuICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExhYmVsRWxlbWVudCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzOiBmdW5jdGlvbiB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gKHVzZU1lcmdlZFByb3BzPElucHV0RWxlbWVudD4odXNlTWVyZ2VkUHJvcHM8SW5wdXRFbGVtZW50Pih7fSwgeyBcImFyaWEtY29udHJvbHNcIjogYXJpYUNvbnRyb2xzLCBvbklucHV0OiB0YWdJbnB1dCA9PSBcImlucHV0XCIgPyAoZSA9PiBlLnByZXZlbnREZWZhdWx0KCkpIDogdW5kZWZpbmVkIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PiksIHByb3BzKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyhsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIiA/IHJldCA6IHByb3BzKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudExhYmVsUHJvcHM6IGZ1bmN0aW9uIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRMYWJlbFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSAodXNlTWVyZ2VkUHJvcHM8TGFiZWxFbGVtZW50Pih1c2VNZXJnZWRQcm9wczxMYWJlbEVsZW1lbnQ+KHt9LCB7IFwiYXJpYS1jb250cm9sc1wiOiBhcmlhQ29udHJvbHMgfSBhcyBhbnkpIGFzIGFueSwgcHJvcHMpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiID8gcmV0IDogcHJvcHMpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbYXJpYUNvbnRyb2xzXSk7XHJcblxyXG4gICAgY29uc3Qgb25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQyID0gdXNlQ2FsbGJhY2soKGU6IENoZWNrYm94Q2hhbmdlRXZlbnQ8aC5KU1guVGFyZ2V0ZWRFdmVudDxJbnB1dEVsZW1lbnQsIEV2ZW50Pj4pID0+IHtcclxuXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBjb25zdCBzZWxmSXNDaGVja2VkID0gZ2V0U2VsZklzQ2hlY2tlZFN0YWJsZSgpO1xyXG4gICAgICAgIGNvbnN0IG5leHRDaGVja2VkID0gKHNlbGZJc0NoZWNrZWQgPT09IGZhbHNlID8gXCJtaXhlZFwiIDogc2VsZklzQ2hlY2tlZCA9PT0gXCJtaXhlZFwiID8gdHJ1ZSA6IGZhbHNlKTtcclxuICAgICAgICBsZXQgd2lsbENoYW5nZUFueSA9IGZhbHNlO1xyXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gd2lsbENoYW5nZUFueSB8fD0gKGNoaWxkLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmNoZWNrZWQgIT0gY2hpbGQuc3ViSW5mby5zdWJJbmZvLnN1YkluZm8uZ2V0TGFzdFVzZXJDaGVja2VkKCkpKTtcclxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcclxuICAgICAgICAgICAgbGV0IGNoZWNrZWQ6IGJvb2xlYW47XHJcbiAgICAgICAgICAgIGlmIChuZXh0Q2hlY2tlZCA9PSBcIm1peGVkXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh3aWxsQ2hhbmdlQW55KSBcclxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gKGNoaWxkLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmdldExhc3RVc2VyQ2hlY2tlZCgpIGFzIGJvb2xlYW4pO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tlZCA9IG5leHRDaGVja2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLm9uSW5wdXQ/LihlbmhhbmNlRXZlbnQoZSwgeyBjaGVja2VkIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKmlmIChzZWxmSXNDaGVja2VkID09PSB0cnVlIHx8IChzZWxmSXNDaGVja2VkID09PSBmYWxzZSAmJiBzYXZlZENoZWNrZWRWYWx1ZXMuY3VycmVudCA9PSBudWxsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb25VcGRhdGVDaGlsZHJlbihlbmhhbmNlRXZlbnQoZSwgeyBjaGlsZHJlbkNoZWNrZWQ6IGZhbHNlIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VsZklzQ2hlY2tlZCA9PT0gXCJtaXhlZFwiKSB7XHJcblxyXG4gICAgICAgICAgICBzYXZlZENoZWNrZWRWYWx1ZXMuY3VycmVudCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XHJcbiAgICAgICAgICAgICAgICBzYXZlZENoZWNrZWRWYWx1ZXMuY3VycmVudCEuc2V0KGNoaWxkLmluZGV4LCBjaGlsZC5nZXRMYXN0VXNlckNoZWNrZWQoKSk7XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb25VcGRhdGVDaGlsZHJlbihlbmhhbmNlRXZlbnQoZSwgeyBjaGlsZHJlbkNoZWNrZWQ6IHRydWUgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9uVXBkYXRlQ2hpbGRyZW4oZW5oYW5jZUV2ZW50KGUsIHsgY2hpbGRyZW5DaGVja2VkOiBzYXZlZENoZWNrZWRWYWx1ZXMuY3VycmVudCA/PyB0cnVlIH0pKTtcclxuICAgICAgICB9Ki9cclxuICAgIH0sIFtdKVxyXG5cclxuICAgIGNvbnN0IG5vdGlmeUNoZWNrZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlciwgY2hlY2tlZDogYm9vbGVhbiB8IFwibWl4ZWRcIikgPT4ge1xyXG4gICAgICAgIGlmIChjaGVja2VkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmICghY2hlY2tlZEluZGljZXMuY3VycmVudC5oYXMoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDaGVja2VkQ291bnQoYyA9PiAoYyArIDEpKTtcclxuICAgICAgICAgICAgICAgIGNoZWNrZWRJbmRpY2VzLmN1cnJlbnQuYWRkKGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGNoZWNrZWRJbmRpY2VzLmN1cnJlbnQuaGFzKGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgc2V0Q2hlY2tlZENvdW50KGMgPT4gKGMgLSAxKSk7XHJcbiAgICAgICAgICAgICAgICBjaGVja2VkSW5kaWNlcy5jdXJyZW50LmRlbGV0ZShpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLyp1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGxldCBwZXJjZW50YWdlID0gY2hlY2tlZENvdW50IC8gbWFuYWdlZENoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICBzZXRTZWxmSXNDaGVja2VkKHBlcmNlbnRhZ2UgPD0gMCA/IGZhbHNlIDogcGVyY2VudGFnZSA+PSAxID8gdHJ1ZSA6IFwibWl4ZWRcIilcclxuICAgIH0sIFtzZXRTZWxmSXNDaGVja2VkLCBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoLCBjaGVja2VkQ291bnRdKTsqL1xyXG5cclxuICAgIC8qY29uc3QgdXNlQ2hlY2tib3hHcm91cFBhcmVudFByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIFxyXG4gICAgfSwgW2FyaWFDb250cm9sc10pOyovXHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBzZXRBcmlhQ29udHJvbHMoQXJyYXkuZnJvbShhbGxJZHMuY3VycmVudCkuam9pbihcIiBcIikpO1xyXG4gICAgfSwgW3VwZGF0ZUluZGV4XSlcclxuXHJcbiAgICBjb25zdCB1c2VDaGVja2JveEdyb3VwQ2hpbGQ6IFVzZUNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4gPSB1c2VDYWxsYmFjazxVc2VDaGVja2JveEdyb3VwQ2hpbGQ8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+PihmdW5jdGlvbiAoeyBhc0NoZWNrYm94LCBhc0NoZWNrYm94R3JvdXBDaGlsZCB9KSB7XHJcbiAgICAgICAgZGVidWdMb2coXCJ1c2VBcmlhQ2hlY2tib3hHcm91cENoaWxkXCIsIGFzQ2hlY2tib3hHcm91cENoaWxkLm1hbmFnZWRDaGlsZC5pbmRleCwgYXNDaGVja2JveC5jaGVja2JveExpa2UuY2hlY2tlZCk7XHJcbiAgICAgICAgY29uc3QgeyBjaGVja2JveDogeyBvbklucHV0IH0sIGNoZWNrYm94TGlrZTogeyBjaGVja2VkLCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiB9LCBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSB9ID0gYXNDaGVja2JveDtcclxuICAgICAgICBjb25zdCB7IG1hbmFnZWRDaGlsZDogeyBpbmRleCB9IH0gPSBhc0NoZWNrYm94R3JvdXBDaGlsZDtcclxuICAgICAgICAvL2xhYmVsUG9zaXRpb24gPz89IFwic2VwYXJhdGVcIjtcclxuICAgICAgICBjb25zdCBbZ2V0TGFzdFVzZXJDaGVja2VkLCBzZXRMYXN0VXNlckNoZWNrZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4gfCBcIm1peGVkXCI+KG51bGwsIHJldHVybkZhbHNlKTtcclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50LFxyXG4gICAgICAgICAgICB1c2VDaGVja2JveExhYmVsRWxlbWVudCxcclxuICAgICAgICAgICAgLi4uY2hlY2tib3hSZXR1cm5UeXBlXHJcbiAgICAgICAgfSA9IHVzZUFyaWFDaGVja2JveDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xyXG4gICAgICAgICAgICBjaGVja2JveDoge1xyXG4gICAgICAgICAgICAgICAgb25JbnB1dDogdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uSW5wdXQ+PihlID0+IHsgc2V0TGFzdFVzZXJDaGVja2VkKGVbRXZlbnREZXRhaWxdLmNoZWNrZWQpOyBvbklucHV0Py4oZSBhcyBhbnkpOyB9KSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY2hlY2tib3hMaWtlOiB7XHJcbiAgICAgICAgICAgICAgICBjaGVja2VkLFxyXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICAgICAgdGFnSW5wdXQsXHJcbiAgICAgICAgICAgICAgICB0YWdMYWJlbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgbGFiZWw6IHsgaW5wdXRJZCwgbGFiZWxJZCB9IH0gPSBjaGVja2JveFJldHVyblR5cGU7XHJcblxyXG4gICAgICAgIC8vY29uc3QgZ2V0Q2hlY2tlZCA9IHVzZVN0YWJsZUdldHRlcihjaGVja2VkKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29udHJvbHNJZCA9IChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIiA/IGlucHV0SWQgOiBsYWJlbElkKSE7XHJcblxyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGFsbElkcy5jdXJyZW50LmFkZChjb250cm9sc0lkKTtcclxuICAgICAgICAgICAgc2V0SWRVcGRhdGVJbmRleChpID0+ICsraSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYWxsSWRzLmN1cnJlbnQuZGVsZXRlKGNvbnRyb2xzSWQpO1xyXG4gICAgICAgICAgICAgICAgc2V0SWRVcGRhdGVJbmRleChpID0+ICsraSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbY29udHJvbHNJZF0pO1xyXG5cclxuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgbm90aWZ5Q2hlY2tlZChpbmRleCwgY2hlY2tlZCk7XHJcbiAgICAgICAgfSwgW2luZGV4LCBjaGVja2VkXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLCAuLi5saXN0TmF2aWdhdGlvblJldHVyblR5cGUgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoe1xyXG4gICAgICAgICAgICBzdWJJbmZvOiB7IGdldExhc3RVc2VyQ2hlY2tlZCwgb25JbnB1dCwgY2hlY2tlZCB9LFxyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5hc0NoZWNrYm94R3JvdXBDaGlsZC5saXN0TmF2aWdhdGlvbiB9LFxyXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IGFzQ2hlY2tib3hHcm91cENoaWxkLm1hbmFnZWRDaGlsZCxcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IGFzQ2hlY2tib3hHcm91cENoaWxkLnJvdmluZ1RhYkluZGV4XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNoZWNrYm94TGlrZTogY2hlY2tib3hSZXR1cm5UeXBlLmNoZWNrYm94TGlrZSxcclxuICAgICAgICAgICAgbGFiZWw6IGNoZWNrYm94UmV0dXJuVHlwZS5sYWJlbCxcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IGxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICAgICAgdXNlQ2hlY2tib3hHcm91cENoaWxkSW5wdXRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PiA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJldDIgPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlTGlzdE5hdmlnYXRpb25Qcm9wcyhyZXQpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIiA/IHJldDIgOiByZXQpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZExhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExhYmVsRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXQyID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMocmV0IGFzIGFueSkgYXMgYW55KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIgPyByZXQyIDogcmV0KSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGQsXHJcbiAgICAgICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0LFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbGlzdFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBsaXN0UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxyXG4gICAgICAgIGNoZWNrYm94R3JvdXA6IHtcclxuICAgICAgICAgICAgcGFyZW50SXNDaGVja2VkOiBnZXRTZWxmSXNDaGVja2VkVW5zdGFibGUoKSBhcyBib29sZWFuIHwgXCJtaXhlZFwiLFxyXG4gICAgICAgICAgICBwYXJlbnRQZXJjZW50Q2hlY2tlZDogKGNoZWNrZWRDb3VudCAvIChjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSArIDEpKSxcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbiIsIlxyXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50LCBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycywgdXNlRm9jdXNUcmFwLCB1c2VNZXJnZWRQcm9wcywgdXNlUGFzc2l2ZVN0YXRlLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG5pbnRlcmZhY2UgU0RQIHtcclxuICAgIC8qKlxyXG4gICAgICogTXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBjb3VudCBhcyBcIndpdGhpblwiIHRoaXMgY29tcG9uZW50LlxyXG4gICAgICogXHJcbiAgICAgKiBVc3VhbGx5IGp1c3QgYSBzaW5nbGUgZWxlbWVudCwgYnV0IGUuZy4gYSBNZW51ICsgTWVudUJ1dHRvbiBjb3VsZCBoYXZlIHR3by5cclxuICAgICAqL1xyXG4gICAgZ2V0RWxlbWVudHM6ICgpID0+IEVsZW1lbnQgfCAoRWxlbWVudCB8IG51bGwpW10gfCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkaXNtaXNzZWRcclxuICAgICAqL1xyXG4gICAgb25DbG9zZShyZWFzb246IFwiYmFja2Ryb3BcIiB8IFwiZXNjYXBlXCIgfCBcImxvc3QtZm9jdXNcIik6IHZvaWQ7XHJcblxyXG4gICAgb3BlbjogYm9vbGVhbjtcclxufVxyXG5cclxuaW50ZXJmYWNlIE1QIHtcclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB0cnVlLCB0aGUgYm9keSBlbGVtZW50IHByb3ZpZGVkIGNvbnRhaW5zIHB1cmVseSBzZW1hbnRpYyBjb250ZW50XHJcbiAgICAgKiB0aGF0IGNhbiBiZSByZWFkIG91dCBieSBhIHNjcmVlbiByZWFkZXIgaW4gb25lIGxvbmcsIHVuaW50ZXJydXB0ZWQgc3RyZXRjaC5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBzaG91bGQgYmUgZmFsc2UgaWYgdGhlIG1vZGFsIGNvbnRhaW5zLCBmb3IgZXhhbXBsZSwgYSBsaXN0IG9yIG90aGVyXHJcbiAgICAgKiBpbnRlcmFjdGl2ZSB3aWRnZXRzLCBhbmQgdHJ1ZSBpZiBpdCdzIG1vc3RseSBzaG9ydC1mb3JtIHRleHQgY29udGVudC5cclxuICAgICAqIFxyXG4gICAgICogVGhlIGRlZmF1bHQgaXMgZmFsc2UgdG8gYmUgb24gdGhlIHNhZmUgc2lkZSwgYnV0IHRoaXMgc2hvdWxkIGJlIHRydWUgd2hlbmV2ZXIgcmVhc29uYWJsZS5cclxuICAgICAqL1xyXG4gICAgYm9keUlzT25seVNlbWFudGljPzogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYW55IG1vZGFsIGRpYWxvZyBvcGVucywgaXQgbXVzdCBzZW5kIGZvY3VzIHRvIHRoYXQgZGlhbG9nLCBpZGVhbGx5IHdoaWNoZXZlciBlbGVtZW50IG1ha2VzIHRoZSBtb3N0IHNlbnNlIGluIGNvbnRleHQuXHJcbiAgICAgKiBcclxuICAgICAqIEZvciBleGFtcGxlLCBpZiBpdCdzIGEgY29uZmlybWF0aW9uIGRpYWxvZyBhYm91dCBkZWxldGluZyBzb21ldGhpbmcsIGl0J3MgYmVzdCB0byBzZW5kIGZvY3VzIHRvIHRoZSBcImNhbmNlbFwiIGJ1dHRvbi5cclxuICAgICAqIFxyXG4gICAgICogSW4gb3RoZXIgY2FzZXMsIGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gZm9jdXMgdGhlIGRpYWxvZydzIHRpdGxlLCBmaXJzdCBpbnRlcmFjdGl2ZSBlbGVtZW50LCBldGMuXHJcbiAgICAgKiBcclxuICAgICAqIEJ5IGRlZmF1bHQsIHdlIHRyeSB0byBwaWNrIGEgc2Vuc2libGUgZGVmYXVsdCAtLSBpZiB0aGUgZGlhbG9nIGNvbnRhaW5zIG9ubHkgZGVzY3JpcHRpdmUgY29udGVudCwgdGhlbiB3ZSBmb2N1cyB0aGUgYm9keS4gT3RoZXJ3aXNlIHdlIGZvY3VzIHRoZSB0aXRsZS5cclxuICAgICAqIFxyXG4gICAgICogKipQTEVBU0UqKiBjb25zaWRlciBvdmVycmlkaW5nIHRoaXMgdG8gcHJvdmlkZSB0aGUgYmVzdCBleHBlcmllbmNlIGZvciB5b3VyIGRpYWxvZy4gIFlvdSBzaG91bGRuJ3QgaGF2ZSB0aGF0IG1hbnkgbW9kYWwgZGlhbG9ncyBhbnl3YXkgLS0gdGFrZSB0aGF0IGJpdCBvZiBleHRyYSB0aW1lIGlmIHlvdSBjYW4uXHJcbiAgICAgKi9cclxuICAgIGZvY3VzU2VsZj8oKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgU29mdERpc21pc3NPbWl0cyA9IGtleW9mIFNEUDtcclxuZXhwb3J0IHR5cGUgTW9kYWxPbWl0cyA9IGtleW9mIE1QO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VTb2Z0RGlzbWlzc1BhcmFtZXRlcnM8T21pdHMgZXh0ZW5kcyBTb2Z0RGlzbWlzc09taXRzPiB7XHJcbiAgICBzb2Z0RGlzbWlzczogT21pdDxTRFAsIE9taXRzPjtcclxuICAgIGFjdGl2ZUVsZW1lbnQ6IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1vZGFsUGFyYW1ldGVyczxNTyBleHRlbmRzIE1vZGFsT21pdHMsIFNETyBleHRlbmRzIFNvZnREaXNtaXNzT21pdHM+IGV4dGVuZHMgVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzPFNETyB8IFwiZ2V0RWxlbWVudHNcIj4ge1xyXG4gICAgbW9kYWw6IE9taXQ8TVAsIE1PPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VTb2Z0RGlzbWlzc1JldHVyblR5cGVJbmZvIHtcclxuICAgIHNvZnREaXNtaXNzOiB7XHJcbiAgICAgICAgb25CYWNrZHJvcENsaWNrOiAoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxhbnk+KSA9PiB2b2lkO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VTb2Z0RGlzbWlzc1JldHVyblR5cGVXaXRoSG9va3M8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICAvKiogVGhpcyBiYXNpY2FsbHkgY2FuIGJlIGFueSBlbGVtZW50IC0tIGl0J3Mgb25seSB1c2VkIHRvIGdldCB0aGUgb3duaW5nIHdpbmRvdy9kb2N1bWVudC4gKi9cclxuICAgIHVzZVNvZnREaXNtaXNzUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG59XHJcblxyXG4vKipcclxuICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgYSBtb2RhbC1saWtlIHNvZnQtZGlzbWlzcyBpbnRlcmFjdGlvbi5cclxuICogXHJcbiAqIFRoYXQgaXMsIGFueSBjbGlja3Mgb3IgdGFwcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBjb21wb25lbnQsIFxyXG4gKiBvciBhbnkgdGltZSB0aGUgRXNjYXBlIGtleSBpcyBwcmVzc2VkIHdpdGhpbiB0aGUgY29tcG9uZW50LFxyXG4gKiAod2l0aCB2YXJpb3VzIGJyb3dzZXIgb2RkaXRpZXMgcmVnYXJkaW5nIGNsaWNrcyBvbiBibGFuayBvciBpbmVydCBhcmVhcyBoYW5kbGVkKVxyXG4gKiB0aGUgY29tcG9uZW50IHdpbGwgcmVxdWVzdCB0byBjbG9zZSBpdHNlbGYuXHJcbiAqIFxyXG4gKiBPZiBjb3Vyc2UsIGlmIHlvdSBkb24ndCBkbyBhbnl0aGluZyBpbiB0aGUgYG9uQ2xvc2VgIGZ1bmN0aW9uLFxyXG4gKiBpdCB3b24ndCBiZSBhIHNvZnQgZGlzbWlzcyBhbnltb3JlLlxyXG4gKiBcclxuICogQHBhcmFtIHBhcmFtMCBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlU29mdERpc21pc3M8VCBleHRlbmRzIE5vZGU+KHsgc29mdERpc21pc3M6IHsgb25DbG9zZSwgZ2V0RWxlbWVudHMsIG9wZW4gfSwgYWN0aXZlRWxlbWVudDogeyBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCAuLi5hY3RpdmVFbGVtZW50IH0gfTogVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzPG5ldmVyPik6IFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZVdpdGhIb29rczxUPiB7XHJcblxyXG4gICAgY29uc3Qgc3RhYmxlT25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UpO1xyXG4gICAgY29uc3Qgc3RhYmxlR2V0RWxlbWVudHMgPSB1c2VTdGFibGVDYWxsYmFjayhnZXRFbGVtZW50cyk7XHJcbiAgICBjb25zdCBnZXRPcGVuID0gdXNlU3RhYmxlR2V0dGVyKG9wZW4pO1xyXG5cclxuICAgIGNvbnN0IHsgZ2V0RG9jdW1lbnQgfSA9IGFjdGl2ZUVsZW1lbnRcclxuXHJcbiAgICBjb25zdCBvbkJhY2tkcm9wQ2xpY2sgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBvbkJhY2tkcm9wQ2xpY2soZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxhbnk+KSB7XHJcbiAgICAgICAgaWYgKCFnZXRPcGVuKCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xyXG5cclxuICAgICAgICAvLyBCYXNpY2FsbHksIFwid2FzIHRoaXMgZXZlbnQgZmlyZWQgb24gdGhlIHJvb3QtbW9zdCBlbGVtZW50LCBvciBhdCBsZWFzdCBhbiBlbGVtZW50IG5vdCBjb250YWluZWQgYnkgdGhlIG1vZGFsP1wiXHJcbiAgICAgICAgLy8gRWl0aGVyIGNvdWxkIGJlIGhvdyB0aGUgYnJvd3NlciBoYW5kbGVzIHRoZXNlIHNvcnRzIG9mIFwiaW50ZXJhY3Rpbmcgd2l0aCBub3RoaW5nXCIgZXZlbnRzLlxyXG4gICAgICAgIGlmIChlLnRhcmdldCA9PSBkb2N1bWVudD8uZG9jdW1lbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHN0YWJsZU9uQ2xvc2UoXCJiYWNrZHJvcFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBlbGVtZW50cyA9IHN0YWJsZUdldEVsZW1lbnRzKCk7XHJcblxyXG4gICAgICAgIGlmIChlbGVtZW50cyAmJiBlLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVsZW1lbnRzKSlcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcclxuXHJcbiAgICAgICAgICAgIGxldCBmb3VuZEluc2lkZUNsaWNrID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuY29udGFpbnMoZS50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm91bmRJbnNpZGVDbGljayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghZm91bmRJbnNpZGVDbGljaykge1xyXG4gICAgICAgICAgICAgICAgb25DbG9zZShcImJhY2tkcm9wXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pXHJcblxyXG4gICAgY29uc3Qgey4uLl91bnVzZWQgfSA9IHVzZUFjdGl2ZUVsZW1lbnQoe1xyXG4gICAgICAgIC4uLmFjdGl2ZUVsZW1lbnQsXHJcblxyXG4gICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChuZXdFbGVtZW50OiBFbGVtZW50LCBwcmV2OiBFbGVtZW50IHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U/LihuZXdFbGVtZW50LCBwcmV2KTtcclxuICAgICAgICAgICAgbGV0IHZhbGlkRm9jdXNhYmxlRWxlbWVudHMgPSBzdGFibGVHZXRFbGVtZW50cygpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHZhbGlkRm9jdXNhYmxlRWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWxpZEZvY3VzYWJsZUVsZW1lbnRzKSlcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZEZvY3VzYWJsZUVsZW1lbnRzID0gW3ZhbGlkRm9jdXNhYmxlRWxlbWVudHNdO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZm9jdXNhYmxlIG9mIHZhbGlkRm9jdXNhYmxlRWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNhYmxlPy5jb250YWlucyhuZXdFbGVtZW50KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBvbkNsb3NlKFwibG9zdC1mb2N1c1wiKTtcclxuICAgICAgICB9LCBbXSlcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxUPih7XHJcbiAgICAgICAgb25FbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoZTogVCB8IG51bGwpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBlPy5vd25lckRvY3VtZW50O1xyXG4gICAgICAgICAgICBjb25zdCB3aW5kb3cgPSBkb2N1bWVudD8uZGVmYXVsdFZpZXc7XHJcblxyXG4gICAgICAgICAgICAvLyBTaW5jZSBldmVyeXRoaW5nIGVsc2UgaXMgaW5lcnQsIHdlIGxpc3RlbiBmb3IgY2FwdHVyZWQgY2xpY2tzIG9uIHRoZSB3aW5kb3dcclxuICAgICAgICAgICAgLy8gKHdlIGRvbid0IHVzZSBvbkNsaWNrIHNpbmNlIHRoYXQgZG9lc24ndCBmaXJlIHdoZW4gY2xpY2tlZCBvbiBlbXB0eS9pbmVydCBhcmVhcylcclxuICAgICAgICAgICAgLy8gTm90ZTogV2UgbmVlZCBhICpzZXBhcmF0ZSogdG91Y2ggZXZlbnQgb24gbW9iaWxlIFNhZmFyaSwgYmVjYXVzZVxyXG4gICAgICAgICAgICAvLyBpdCBkb2Vzbid0IGxldCBjbGljayBldmVudHMgYnViYmxlIG9yIGJlIGNhcHR1cmVkIGZyb20gdHJhZGl0aW9uYWxseSBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsXHJcbiAgICAgICAgICAgIC8vIGJ1dCB0b3VjaCBldmVudHMgd29yayBhcyBleHBlY3RlZC5cclxuICAgICAgICAgICAgY29uc3QgbW91c2VEb3duID0gKGU6IE1vdXNlRXZlbnQpID0+IHsgaWYgKGdldE9wZW4oKSkgb25CYWNrZHJvcENsaWNrKGUpOyB9O1xyXG4gICAgICAgICAgICBjb25zdCB0b3VjaFN0YXJ0ID0gKGU6IFRvdWNoRXZlbnQpID0+IHsgaWYgKGdldE9wZW4oKSkgb25CYWNrZHJvcENsaWNrKGUpOyB9O1xyXG4gICAgICAgICAgICBjb25zdCBrZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHsgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiKSB7IHN0YWJsZU9uQ2xvc2UoXCJlc2NhcGVcIik7IH0gfTtcclxuXHJcbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBtb3VzZURvd24sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0b3VjaFN0YXJ0LCB7IGNhcHR1cmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5RG93bik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG1vdXNlRG93bik7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoU3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlEb3duKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtdKVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VTb2Z0RGlzbWlzc1Byb3BzOiB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4gPT4gKHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wcykpLCBbXSksXHJcbiAgICAgICAgc29mdERpc21pc3M6IHtcclxuICAgICAgICAgICAgb25CYWNrZHJvcENsaWNrLFxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VNb2RhbFJldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1vZGFsUmV0dXJuVHlwZVdpdGhIb29rczxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNb2RhbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTW9kYWxSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB1c2VNb2RhbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1vZGFsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1vZGFsRWxlbWVudD47XHJcbiAgICB1c2VNb2RhbFRpdGxlOiBVc2VNb2RhbFRpdGxlPFRpdGxlRWxlbWVudD47XHJcbiAgICB1c2VNb2RhbEJvZHk6IFVzZU1vZGFsQm9keTxCb2R5RWxlbWVudD5cclxuICAgIHVzZU1vZGFsQmFja2Ryb3A6IFVzZU1vZGFsQmFja2Ryb3A8QmFja2Ryb3BFbGVtZW50PjtcclxuICAgIHVzZU1vZGFsRm9jdXNDb250YWluZXJQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+KVxyXG4gICAgLy9zb2Z0RGlzbWlzczogT21pdDxVc2VTb2Z0RGlzbWlzc1JldHVyblR5cGU8TW9kYWxFbGVtZW50PltcInNvZnREaXNtaXNzXCJdLCBcInVzZVNvZnREaXNtaXNzUHJvcHNcIj47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZU1vZGFsVGl0bGU8VGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZU1vZGFsVGl0bGVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+OyB9O1xyXG5leHBvcnQgdHlwZSBVc2VNb2RhbEJvZHk8Qm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlTW9kYWxCb2R5UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD47IH07XHJcbmV4cG9ydCB0eXBlIFVzZU1vZGFsQmFja2Ryb3A8QmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZU1vZGFsQmFja2Ryb3BQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+OyB9O1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJpYyBtb2RhbCBob29rLCB1c2VkIGJ5IG1vZGFsIGRpYWxvZ3MsIGJ1dCBjYW4gYWxzb1xyXG4gKiBiZSB1c2VkIGJ5IGFueXRoaW5nIHRoYXQncyBtb2RhbCB3aXRoIGEgYmFja2Ryb3AuXHJcbiAqIEBwYXJhbSBwYXJhbTAgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1vZGFsPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEhUTUVsZW1lbnQsIE1vZGFsRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgbW9kYWw6IHsgYm9keUlzT25seVNlbWFudGljOiBkZXNjcmlwdGl2ZSwgZm9jdXNTZWxmIH0sIHNvZnREaXNtaXNzOiB7IG9uQ2xvc2UsIG9wZW4gfSwgYWN0aXZlRWxlbWVudCB9OiBVc2VNb2RhbFBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyPik6IFVzZU1vZGFsUmV0dXJuVHlwZVdpdGhIb29rczxNb2RhbEVsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudD4ge1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VUaXRsZVJlZkVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudDogZ2V0VGl0bGVFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PFRpdGxlRWxlbWVudD4oe30pO1xyXG4gICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUJvZHlSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQ6IGdldEJvZHlFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PEJvZHlFbGVtZW50Pih7fSk7XHJcbiAgICBmb2N1c1NlbGYgPz89ICgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0aXZlKSB7XHJcbiAgICAgICAgICAgIGdldEJvZHlFbGVtZW50KCk/LmZvY3VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0aXRsZUVsZW1lbnQgPSBnZXRUaXRsZUVsZW1lbnQoKTtcclxuICAgICAgICAgICAgaWYgKHRpdGxlRWxlbWVudClcclxuICAgICAgICAgICAgICAgIHRpdGxlRWxlbWVudC5mb2N1cygpO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jb25zdCBlbGVtZW50VG9Gb2N1cyA9IGdldFRpdGxlRWxlbWVudCgpID8/IGdldEJvZHlFbGVtZW50KClcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc3RhYmxlT25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UpO1xyXG4gICAgY29uc3Qgc3RhYmxlRm9jdXNTZWxmID0gdXNlU3RhYmxlQ2FsbGJhY2soZm9jdXNTZWxmKTtcclxuXHJcbiAgICAvL2NvbnN0IFttb2RhbERlc2NyaWJlZEJ5Qm9keSwgc2V0TW9kYWxEZXNjcmliZWRCeUJvZHldID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgdXNlSGlkZVNjcm9sbChvcGVuKTtcclxuXHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlTW9kYWxJZEFzU291cmNlLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudCB9ID0gdXNlUmFuZG9tSWQ8TW9kYWxFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLW1vZGFsLVwiIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZUJvZHlJZEFzU291cmNlLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VCb2R5SWRSZWZlcmVuY2VyRWxlbWVudCB9ID0gdXNlUmFuZG9tSWQ8Qm9keUVsZW1lbnQ+KHsgcmFuZG9tSWQ6IHsgcHJlZml4OiBcImFyaWEtbW9kYWwtYm9keS1cIiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VUaXRsZUlkQXNTb3VyY2UsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZVRpdGxlSWRSZWZlcmVuY2VyRWxlbWVudCB9ID0gdXNlUmFuZG9tSWQ8VGl0bGVFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLW1vZGFsLXRpdGxlLVwiIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xyXG5cclxuXHJcbiAgICBjb25zdCB7IHVzZVJlZkVsZW1lbnRQcm9wczogdXNlTW9kYWxSZWZFbGVtZW50LCBnZXRFbGVtZW50OiBnZXRNb2RhbEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8TW9kYWxFbGVtZW50Pih7fSlcclxuICAgIGNvbnN0IHsgc29mdERpc21pc3M6IHsgb25CYWNrZHJvcENsaWNrIH0sIHVzZVNvZnREaXNtaXNzUHJvcHMgfSA9IHVzZVNvZnREaXNtaXNzPE1vZGFsRWxlbWVudD4oeyBzb2Z0RGlzbWlzczogeyBvbkNsb3NlOiBzdGFibGVPbkNsb3NlLCBnZXRFbGVtZW50czogZ2V0TW9kYWxFbGVtZW50LCBvcGVuOiAhIW9wZW4gfSwgYWN0aXZlRWxlbWVudCB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VNb2RhbEJhY2tkcm9wID0gdXNlQ2FsbGJhY2s8VXNlTW9kYWxCYWNrZHJvcDxCYWNrZHJvcEVsZW1lbnQ+PihmdW5jdGlvbiB1c2VNb2RhbEJhY2tkcm9wKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZU1vZGFsQmFja2Ryb3BQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8QmFja2Ryb3BFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8QmFja2Ryb3BFbGVtZW50Pih7IG9uUG9pbnRlclVwOiBvbkJhY2tkcm9wQ2xpY2sgfSwgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTW9kYWxCYWNrZHJvcFByb3BzIH1cclxuICAgIH0sIFtdKVxyXG5cclxuICAgIGNvbnN0IHVzZU1vZGFsRm9jdXNDb250YWluZXJQcm9wcyA9IGZ1bmN0aW9uIChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rm9jdXNDb250YWluZXJFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD4ge1xyXG4gICAgICAgIGNvbnN0IHsgdXNlRm9jdXNUcmFwUHJvcHMgfSA9IHVzZUZvY3VzVHJhcDxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+KHsgdHJhcEFjdGl2ZTogb3BlbiB9KTtcclxuICAgICAgICByZXR1cm4gdXNlRm9jdXNUcmFwUHJvcHMocHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVzZU1vZGFsUHJvcHMgPSBmdW5jdGlvbiAoeyBcImFyaWEtbW9kYWxcIjogYXJpYU1vZGFsLCByb2xlLCAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxNb2RhbEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TW9kYWxFbGVtZW50PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlTW9kYWxJZEFzU291cmNlUHJvcHMgfSA9IHVzZU1vZGFsSWRBc1NvdXJjZSgpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VUaXRsZUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlVGl0bGVJZFJlZmVyZW5jZXJFbGVtZW50PE1vZGFsRWxlbWVudD4oXCJhcmlhLWxhYmVsbGVkYnlcIiBhcyBuZXZlcik7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUJvZHlJZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgfSA9IHVzZUJvZHlJZFJlZmVyZW5jZXJFbGVtZW50PE1vZGFsRWxlbWVudD4oXCJhcmlhLWRlc2NyaWJlZGJ5XCIgYXMgbmV2ZXIpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KCFhcmlhTW9kYWwpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlRm9jdXNUcmFwUHJvcHMgfSA9IHVzZUZvY3VzVHJhcDxNb2RhbEVsZW1lbnQ+KHsgdHJhcEFjdGl2ZTogb3BlbiB9KTtcclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob3BlbilcclxuICAgICAgICAgICAgICAgIHN0YWJsZUZvY3VzU2VsZigpO1xyXG4gICAgICAgIH0sIFtvcGVuXSlcclxuICAgICAgICBjb25zdCBwMSA9IHVzZUJvZHlJZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMocDApO1xyXG4gICAgICAgIGNvbnN0IHAyID0gdXNlTW9kYWxJZEFzU291cmNlUHJvcHMocDEpO1xyXG4gICAgICAgIGNvbnN0IHBGaW5hbCA9IHVzZVRpdGxlSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKHAyKTtcclxuICAgICAgICByZXR1cm4gdXNlRm9jdXNUcmFwUHJvcHModXNlU29mdERpc21pc3NQcm9wcyh1c2VNZXJnZWRQcm9wczxNb2RhbEVsZW1lbnQ+KHVzZU1vZGFsUmVmRWxlbWVudCh7IHJvbGU6IHJvbGUgfHwgXCJkaWFsb2dcIiB9KSwgZGVzY3JpcHRpdmUgPyBwRmluYWwgOiBwMikpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB1c2VNb2RhbFRpdGxlID0gdXNlQ2FsbGJhY2s8VXNlTW9kYWxUaXRsZTxUaXRsZUVsZW1lbnQ+PihmdW5jdGlvbiB1c2VNb2RhbFRpdGxlKCkge1xyXG5cclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VUaXRsZUlkQXNTb3VyY2VQcm9wcyB9ID0gdXNlVGl0bGVJZEFzU291cmNlKCk7XHJcbiAgICAgICAgY29uc3QgdXNlTW9kYWxUaXRsZVByb3BzID0gZnVuY3Rpb24gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50PiB7XHJcbiAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID8/PSAtMTtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZVRpdGxlUmVmRWxlbWVudFByb3BzKHVzZVRpdGxlSWRBc1NvdXJjZVByb3BzKHByb3BzKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VNb2RhbFRpdGxlUHJvcHMgfTtcclxuICAgIH0sIFtdKVxyXG5cclxuICAgIGNvbnN0IHVzZU1vZGFsQm9keSA9IHVzZUNhbGxiYWNrPFVzZU1vZGFsQm9keTxCb2R5RWxlbWVudD4+KGZ1bmN0aW9uIHVzZU1vZGFsQm9keSgpIHtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VCb2R5SWRBc1NvdXJjZVByb3BzIH0gPSB1c2VCb2R5SWRBc1NvdXJjZSgpO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudFByb3BzIH0gPSB1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudDxCb2R5RWxlbWVudD4oXCJkYXRhLW1vZGFsLWlkXCIgYXMgbmV2ZXIpO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VNb2RhbEJvZHlQcm9wcyA9IGZ1bmN0aW9uIChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+IHtcclxuICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPz89IC0xO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlQm9keVJlZkVsZW1lbnRQcm9wcyh1c2VCb2R5SWRBc1NvdXJjZVByb3BzKHVzZU1vZGFsSWRBc1JlZmVyZW5jZXJFbGVtZW50UHJvcHMocHJvcHMpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VNb2RhbEJvZHlQcm9wcyB9O1xyXG4gICAgfSwgW10pXHJcblxyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZU1vZGFsUHJvcHMsXHJcbiAgICAgICAgdXNlTW9kYWxUaXRsZSxcclxuICAgICAgICB1c2VNb2RhbEJvZHksXHJcbiAgICAgICAgdXNlTW9kYWxCYWNrZHJvcCxcclxuICAgICAgICB1c2VNb2RhbEZvY3VzQ29udGFpbmVyUHJvcHMsXHJcbiAgICAgICAgc29mdERpc21pc3M6IHsgb25CYWNrZHJvcENsaWNrIH1cclxuICAgIH07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQWxsb3dzIGZvciBoaWRpbmcgdGhlIHNjcm9sbCBiYXIgb2YgdGhlIHJvb3QgSFRNTCBlbGVtZW50XHJcbiAqIHdpdGhvdXQgc2hpZnRpbmcgdGhlIGxheW91dCBvZiB0aGUgcGFnZSBtb3JlIHRoYW4gYWRkaW5nIGEgZm93IHBpeGVsc1xyXG4gKiBvZiBwYWRkaW5nIHRvIHRoZSByb290IGVsZW1lbnQgaWYgbmVjZXNzYXJ5LlxyXG4gKiBAcGFyYW0gaGlkZVNjcm9sbCBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VIaWRlU2Nyb2xsKGhpZGVTY3JvbGw6IGJvb2xlYW4pIHtcclxuICAgIGNvbnN0IFtnZXRTY3JvbGxiYXJXaWR0aCwgc2V0U2Nyb2xsYmFyV2lkdGhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG4gICAgY29uc3QgW2dldFNjcm9sbGJhckhlaWdodCwgc2V0U2Nyb2xsYmFySGVpZ2h0XSA9IHVzZVBhc3NpdmVTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChoaWRlU2Nyb2xsKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBXaGVuIHNjcm9sbGluZyBpcyByZXN1bWVkLCB3ZSdsbCBuZWVkIHRvIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHNjcm9sbCBwb3NpdGlvbnNcclxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBrZWVwIHRoaXMgaW5mb3JtYXRpb24gYXJvdW5kXHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU2Nyb2xsVG9wID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTY3JvbGxMZWZ0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBNZWFzdXJlIHRoZSB3aWR0aCBvZiB0aGUgcGFnZSAobWludXMgdGhlIHNjcm9sbGJhcilcclxuICAgICAgICAgICAgY29uc3Qgd2lkdGhXaXRoU2Nyb2xsQmFyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBoZWlnaHRXaXRoU2Nyb2xsQmFyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGEgY2xhc3MgdGhhdCBoaWRlcyB0aGUgc2Nyb2xsYmFyLlxyXG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImRvY3VtZW50LXNjcm9sbC1oaWRkZW5cIik7XHJcblxyXG4gICAgICAgICAgICAvLyBJbiBjYXNlIG11bHRpcGxlIHRoaW5ncyBhcmUgbG9ja2luZyBzY3JvbGwsIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgYXJlIGRvaW5nIHRoYXRcclxuICAgICAgICAgICAgLy8gKGp1c3QgYWRkIDEgb24gZW5hYmxlLCBzdWJ0cmFjdCAxIG9uIGRpc2FibGUpXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdID0gKCsoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gfHwgXCIwXCIpICsgMSkudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIE1lYXN1cmUgdGhlIG5ldyB3aWR0aCB3aXRob3V0IGEgc2Nyb2xsYmFyIFxyXG4gICAgICAgICAgICAvLyBzbyB3ZSBjYW4gdGFrZSB0aGUgZGlmZmVyZW5jZSBhcyB0aGUgc2Nyb2xsYmFyIHdpZHRoLlxyXG4gICAgICAgICAgICBjb25zdCB3aWR0aFdpdGhvdXRTY3JvbGxCYXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodFdpdGhvdXRTY3JvbGxCYXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xyXG4gICAgICAgICAgICBsZXQgc2Nyb2xsYmFyV2lkdGggPSAod2lkdGhXaXRob3V0U2Nyb2xsQmFyIC0gd2lkdGhXaXRoU2Nyb2xsQmFyKTtcclxuICAgICAgICAgICAgbGV0IHNjcm9sbGJhckhlaWdodCA9IChoZWlnaHRXaXRob3V0U2Nyb2xsQmFyIC0gaGVpZ2h0V2l0aFNjcm9sbEJhcik7XHJcblxyXG4gICAgICAgICAgICAvLyBGYWlsc2FmZSAtLSBpZiB0aGlzIG1lYXN1cmluZyB0cmljayBkb2VzIHNvbWV0aGluZyB1bmV4cGVjdGVkLCBqdXN0IGlnbm9yZSBpdFxyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFyV2lkdGggPiA4MClcclxuICAgICAgICAgICAgICAgIHNjcm9sbGJhcldpZHRoID0gMDtcclxuICAgICAgICAgICAgaWYgKHNjcm9sbGJhckhlaWdodCA+IDgwKVxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFySGVpZ2h0ID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIE1ha2Ugb3VyIG1lYXN1cmVtZW50cyBhdmFpbGFibGUgYXMgQ1NTIHByb3BlcnRpZXMgZm9yIGdlbmVyYWwgdXNlXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcm9vdC1zY3JvbGxiYXItd2lkdGhcIiwgYCR7c2Nyb2xsYmFyV2lkdGh9cHhgKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1yb290LXNjcm9sbGJhci1oZWlnaHRcIiwgYCR7c2Nyb2xsYmFySGVpZ2h0fXB4YCk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcm9vdC1zY3JvbGxzdG9wLXRvcFwiLCBgJHtvcmlnaW5hbFNjcm9sbFRvcH1weGApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXJvb3Qtc2Nyb2xsc3RvcC1sZWZ0XCIsIGAke29yaWdpbmFsU2Nyb2xsTGVmdH1weGApO1xyXG5cclxuICAgICAgICAgICAgc2V0U2Nyb2xsYmFyV2lkdGgoc2Nyb2xsYmFyV2lkdGgpO1xyXG4gICAgICAgICAgICBzZXRTY3JvbGxiYXJIZWlnaHQoc2Nyb2xsYmFySGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBVbmRvIGFsbCB0aGUgdGhpbmdzIHdlIGp1c3QgZGlkXHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSA9ICgrKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdIHx8IFwiMFwiKSAtIDEpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXRbXCJzY3JvbGxIaWRlcnNcIl0gPT0gXCIwXCIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSB0aGUgbGFzdCBzY3JvbGwtbG9ja2luZyB0aGluZyB0byBzdG9wLCB0aGVuIHJlbW92ZSB0aGUgY2xhc3MgdGhhdCBzdG9wcyBzY3JvbGxpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtc2Nyb2xsLWhpZGVyc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImRvY3VtZW50LXNjcm9sbC1oaWRkZW5cIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsc28sIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHNjcm9sbCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIHRoaXMgYnkgZm9yY2luZyB0aGUgc2Nyb2xsIGJlaGF2aW9yIHRvIG5vdCBiZSBzbW9vdGhcclxuICAgICAgICAgICAgICAgICAgICAvLyAoaXQncyBpbnN0YW50IGlmIG5vdGhpbmcgaXMgc2V0IHRvIHNtb290aCwgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzc29tLXZpZXcvI3Njcm9sbGluZyksXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsaW5nLCB0aGVuIHJlc3RvcmluZyB0aGUgb3JpZ2luYWwgc2Nyb2xsIGJlaGF2aW9yIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICh3aGljaCB3YXMgcHJvYmFibHkgYWxyZWFkeSBhdXRvIGFueXdheSwgYnV0IGp1c3QgdG8gYmUgc2FmZSlcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNjcm9sbEJlaGF2aW9yID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IFwiYXV0b1wiO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUbyh7IHRvcDogb3JpZ2luYWxTY3JvbGxUb3AsIGxlZnQ6IG9yaWdpbmFsU2Nyb2xsTGVmdCwgYmVoYXZpb3I6IFwiYXV0b1wiIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IG9yaWdpbmFsU2Nyb2xsQmVoYXZpb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2hpZGVTY3JvbGxdKTtcclxuXHJcbiAgICByZXR1cm4geyBnZXRTY3JvbGxiYXJXaWR0aCwgZ2V0U2Nyb2xsYmFySGVpZ2h0IH07XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IE9uVGFiYmFibGVJbmRleENoYW5nZSwgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzLCB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb24sIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZGVidWdMb2csIEVsZW1lbnRUb1RhZywgRXZlbnREZXRhaWwsIHdhcm5Pbk92ZXJ3cml0ZSB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZVByZXNzRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcclxuaW1wb3J0IHsgdXNlTGFiZWwsIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcclxuXHJcbmV4cG9ydCB0eXBlIExpc3Rib3hTaW5nbGVTZWxlY3RFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0geyBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IG51bWJlciB9IH0gJiBQaWNrPGguSlNYLlRhcmdldGVkRXZlbnQ8RT4sIFwidGFyZ2V0XCIgfCBcImN1cnJlbnRUYXJnZXRcIj47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4ge1xyXG4gICAgbGlzdGJveFNpbmdsZToge1xyXG4gICAgICAgIHNlbGVjdGlvbk1vZGU6IFwiZm9jdXNcIiB8IFwiYWN0aXZhdGVcIjtcclxuICAgICAgICBvblNlbGVjdD8oZXZlbnQ6IExpc3Rib3hTaW5nbGVTZWxlY3RFdmVudDxFbGVtZW50Pik6IHZvaWQ7XHJcbiAgICAgICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xyXG4gICAgICAgIHRhZ0xpc3Q6IEVsZW1lbnRUb1RhZzxMaXN0RWxlbWVudD47XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8RSwge30sIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sIFwic3ViSW5mb1wiPiB7XHJcbiAgICBsaXN0Ym94U2luZ2xlSXRlbTogeyBkaXNhYmxlZD86IGJvb2xlYW47IH1cclxuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT47XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IHR5cGUgVXNlTGlzdGJveFNpbmdsZUl0ZW08TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoaW5mbzogVXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzPExpc3RJdGVtRWxlbWVudD4pID0+IFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxMaXN0SXRlbUVsZW1lbnQ+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4ge1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiB7XHJcbiAgICB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RJdGVtRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RJdGVtRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4sIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4ge1xyXG4gICAgdXNlTGlzdGJveFNpbmdsZUl0ZW06IFVzZUxpc3Rib3hTaW5nbGVJdGVtPExpc3RJdGVtRWxlbWVudD47XHJcbiAgICB1c2VMaXN0Ym94U2luZ2xlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD47XHJcbiAgICB1c2VMaXN0Ym94U2luZ2xlTGFiZWw6ICgpID0+IHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXJpYUxpc3Rib3hTaW5nbGU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XHJcbiAgICBsaXN0Ym94U2luZ2xlOiB7IHNlbGVjdGlvbk1vZGUsIHRhZ0xhYmVsLCB0YWdMaXN0LCBvblNlbGVjdCwgLi4uX2xicyB9LFxyXG4gICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXgsIC4uLnNzIH0sXHJcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxuIH0sXHJcbiAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxyXG4gICAgbWFuYWdlZENoaWxkcmVuOiB7IC4uLm1jIH0sXHJcbiAgICByb3ZpbmdUYWJJbmRleDogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIC4uLnJ0aSB9LFxyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyAuLi50biB9LFxyXG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IHsgLi4uY2hmIH1cclxufTogVXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4pOiBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQ+IHtcclxuICAgIGRlYnVnTG9nKFwidXNlQXJpYUxpc3Rib3hTaW5nbGVcIiwgc2VsZWN0ZWRJbmRleCk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0LCB1c2VMYWJlbExhYmVsLCAuLi5sYWJlbFJldHVyblR5cGUgfSA9IHVzZUxhYmVsPExpc3RFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcclxuICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICBwcmVmaXhMYWJlbDogXCJhcmlhLWxpc3Rib3gtbGFiZWwtXCIsXHJcbiAgICAgICAgICAgIHByZWZpeElucHV0OiBcImFyaWEtbGlzdGJveC1cIixcclxuICAgICAgICAgICAgdGFnSW5wdXQ6IHRhZ0xpc3QsXHJcbiAgICAgICAgICAgIHRhZ0xhYmVsOiB0YWdMYWJlbFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCwgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcywgLi4ubGlzdFJldHVyblR5cGUgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4oe1xyXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IC4uLmNoZiB9LFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgLi4ubG4gfSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyAuLi5tYyB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XHJcbiAgICAgICAgICAgIC4uLnJ0aSxcclxuICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPblRhYmJhYmxlSW5kZXhDaGFuZ2U+KChpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U/LihpKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Nb2RlID09IFwiZm9jdXNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChjaGlsZHJlbi5nZXRBdChpISk/LnN1YkluZm8uZ2V0RWxlbWVudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdD8uKHsgdGFyZ2V0LCBjdXJyZW50VGFyZ2V0OiB0YXJnZXQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogaSEgfSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgLi4uc3MsIHNlbGVjdGVkSW5kZXggfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0blxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9IH0gPSBsaXN0UmV0dXJuVHlwZTtcclxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VMYWJlbElucHV0KCk7XHJcbiAgICBjb25zdCBzdGFibGVPblNlbGVjdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uU2VsZWN0ID8/ICgoKSA9PiB7IH0pKTtcclxuXHJcblxyXG4gICAgY29uc3QgdXNlTGlzdGJveFNpbmdsZUl0ZW0gPSB1c2VDYWxsYmFjazxVc2VMaXN0Ym94U2luZ2xlSXRlbTxMaXN0SXRlbUVsZW1lbnQ+PigoeyBsaXN0Ym94U2luZ2xlSXRlbTogeyBkaXNhYmxlZCB9LCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgaGFzRm9jdXMgfSkgPT4ge1xyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlQXJpYUxpc3Rib3hTaW5nbGVJdGVtXCIsIG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcbiAgICAgICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleDogcnRpX3JldCwgc2luZ2xlU2VsZWN0aW9uOiBzc19yZXQsIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcyB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCh7XHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZCxcclxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb24sXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgICAgICBoYXNGb2N1cyxcclxuICAgICAgICAgICAgc3ViSW5mbzoge31cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IG1hbmFnZWRDaGlsZC5pbmRleDtcclxuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHJ0aV9yZXQuZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBydGlfcmV0LnRhYmJhYmxlICYmIHNlbGVjdGlvbk1vZGUgPT0gXCJmb2N1c1wiKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFibGVPblNlbGVjdD8uKHsgdGFyZ2V0OiBlbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBlbGVtZW50LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IGluZGV4IH0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbcnRpX3JldC50YWJiYWJsZSwgc2VsZWN0aW9uTW9kZSwgaW5kZXhdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyxcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9yZXQsXHJcbiAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbjogc3NfcmV0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wczxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEl0ZW1FbGVtZW50Pj4ocHJvcHM6IFApIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RJdGVtRWxlbWVudD4gPSB1c2VQcmVzc0V2ZW50SGFuZGxlcnM8TGlzdEl0ZW1FbGVtZW50PihkaXNhYmxlZCA/IG51bGwgOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHJ0aV9yZXQuZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlT25TZWxlY3Q/Lih7IHRhcmdldDogZWxlbWVudCwgY3VycmVudFRhcmdldDogZWxlbWVudCwgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBpbmRleCB9IH0pO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9LCB1bmRlZmluZWQpO1xyXG5cclxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwib3B0aW9uXCI7XHJcbiAgICAgICAgICAgIC8vcHJvcHNbXCJhcmlhLXNldHNpemVcIl0gPSAoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkgKyAxKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAvL3Byb3BzW1wiYXJpYS1wb3NpbnNldFwiXSA9IChpbmZvLmluZGV4ICsgMSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXNlbGVjdGVkXCJdID0gKHNzX3JldC5zZWxlY3RlZCA/PyBmYWxzZSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxyXG4gICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWRpc2FibGVkXCJdID0gXCJ0cnVlXCI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzKHVzZU1lcmdlZFByb3BzPExpc3RJdGVtRWxlbWVudD4obmV3UHJvcHMsIHByb3BzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsIHNlbGVjdGlvbk1vZGVdKTtcclxuXHJcblxyXG4gICAgY29uc3QgdXNlTGlzdGJveFNpbmdsZUxhYmVsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZUxhYmVsKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlTGFiZWxMYWJlbFByb3BzIH0gPSB1c2VMYWJlbExhYmVsKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VMYWJlbExhYmVsUHJvcHMocHJvcHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHMgfTtcclxuICAgIH0sIFt1c2VMYWJlbExhYmVsXSk7XHJcblxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZUl0ZW0sXHJcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZVByb3BzLFxyXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCxcclxuICAgICAgICAuLi5saXN0UmV0dXJuVHlwZSxcclxuICAgICAgICAuLi5sYWJlbFJldHVyblR5cGVcclxuICAgICAgICAvKmxhYmVsOiBsYWJlbFJldHVyblR5cGUubGFiZWwsXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBsaXN0UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IGxpc3RSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLnR5cGVhaGVhZE5hdmlnYXRpb24qL1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZVByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pIHtcclxuICAgICAgICBwcm9wcy5yb2xlID0gXCJsaXN0Ym94XCI7XHJcbiAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHModXNlTGFiZWxJbnB1dFByb3BzKHByb3BzKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3Rib3hHcm91cDxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSGVhZGluZ0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PigpIHtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCwgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50IH0gPSB1c2VSYW5kb21JZDxIZWFkaW5nRWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwibGlzdGJveC1tdWx0aS1ncm91cFwiIH0sIG1hbmFnZWRDaGlsZHJlbjoge30gfSk7XHJcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzIH0gPSB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQoKTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIH0gPSB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50PENvbnRhaW5lckVsZW1lbnQ+KFwiYXJpYS1sYWJlbGxlZGJ5XCIpO1xyXG4gICAgY29uc3QgdXNlTGlzdGJveEdyb3VwSGVhZGluZ1Byb3BzID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkaW5nRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkaW5nRWxlbWVudD4gPT4ge1xyXG4gICAgICAgIHJldHVybiB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyhwcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgdXNlTGlzdGJveEdyb3VwQ29udGFpbmVyUHJvcHMgPSAoeyByb2xlLCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENvbnRhaW5lckVsZW1lbnQ+ID0+IHtcclxuICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKHtcclxuICAgICAgICAgICAgcm9sZTogd2Fybk9uT3ZlcndyaXRlKFwidXNlTGlzdGJveE11bHRpR3JvdXBQcm9wc1wiLCBcInJvbGVcIiwgcm9sZSwgXCJncm91cFwiKSxcclxuICAgICAgICAgICAgLi4ucHJvcHNcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTGlzdGJveEdyb3VwQ29udGFpbmVyUHJvcHMsXHJcbiAgICAgICAgdXNlTGlzdGJveEdyb3VwSGVhZGluZ1Byb3BzLFxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IE9uVGFiYmFibGVJbmRleENoYW5nZSwgcmV0dXJuRmFsc2UsIHVzZUxheW91dEVmZmVjdCwgdXNlTGlzdE5hdmlnYXRpb24sIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgdXNlTWVyZ2VkUHJvcHMsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBkZWJ1Z0xvZywgRWxlbWVudFRvVGFnLCBFdmVudERldGFpbCB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZVByZXNzRXZlbnRIYW5kbGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcclxuaW1wb3J0IHsgdXNlTGFiZWwgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcclxuXHJcbmV4cG9ydCB0eXBlIExpc3Rib3hNdWx0aVNlbGVjdEV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSB7IFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWQ6IGJvb2xlYW4gfSB9ICYgUGljazxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+LCBcInRhcmdldFwiIHwgXCJjdXJyZW50VGFyZ2V0XCI+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7XHJcbiAgICBsaXN0Ym94TXVsdGk6IHtcclxuICAgICAgICB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD47XHJcbiAgICAgICAgdGFnTGlzdDogRWxlbWVudFRvVGFnPExpc3RFbGVtZW50PlxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aUl0ZW1QYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8RSwgSW5mbywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiwgXCJzdWJJbmZvXCI+IHtcclxuICAgIGxpc3Rib3hNdWx0aUl0ZW06IHsgZGlzYWJsZWQ/OiBib29sZWFuOyB9ICYgSW5mbztcclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgdHlwZSBVc2VMaXN0Ym94TXVsdGlJdGVtPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChpbmZvOiBVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVyczxFPikgPT4gVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVXaXRoSG9va3M8RT47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlSW5mbzxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88RT4ge1xyXG4gICAgbGlzdGJveE11bHRpSXRlbToge1xyXG4gICAgICAgIHRhYmJhYmxlOiBib29sZWFuO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVXaXRoSG9va3M8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVJbmZvPEU+IHtcclxuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCwgSW5mbywgbmV2ZXI+IHtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiB7XHJcbiAgICB1c2VMaXN0Ym94TXVsdGlJdGVtOiBVc2VMaXN0Ym94TXVsdGlJdGVtPExpc3RJdGVtRWxlbWVudD47XHJcbiAgICB1c2VMaXN0Ym94TXVsdGlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PjtcclxuICAgIHVzZUxpc3Rib3hNdWx0aUxhYmVsOiAoKSA9PiB7IHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfVxyXG59XHJcblxyXG5cclxuaW50ZXJmYWNlIEluZm8ge1xyXG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW47XHJcbiAgICBvblNlbGVjdD8oZXZlbnQ6IChMaXN0Ym94TXVsdGlTZWxlY3RFdmVudDxFbGVtZW50PikpOiB2b2lkO1xyXG59XHJcblxyXG5cclxuLypleHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aVJldHVyblR5cGU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4sIFwidXNlTGlzdE5hdmlnYXRpb25DaGlsZFwiIHwgXCJ1c2VMaXN0TmF2aWdhdGlvblByb3BzXCI+IHtcclxuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW06IFVzZUxpc3Rib3hNdWx0aUl0ZW08TGlzdEl0ZW1FbGVtZW50PjtcclxuICAgIHVzZUxpc3Rib3hNdWx0aVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+O1xyXG4gICAgdXNlTGlzdGJveE11bHRpTGFiZWw6ICgpID0+IHsgdXNlTGlzdGJveE11bHRpTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+OyB9XHJcbn0qL1xyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhTGlzdGJveE11bHRpPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgbGlzdGJveE11bHRpOiB7IHRhZ0xhYmVsLCB0YWdMaXN0IH0sXHJcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxuIH0sXHJcbiAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxyXG4gICAgbWFuYWdlZENoaWxkcmVuOiB7IC4uLm1jIH0sXHJcbiAgICByb3ZpbmdUYWJJbmRleDogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIC4uLnJ0aSB9LFxyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyAuLi50biB9XHJcbn06IFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4pOiBVc2VMaXN0Ym94TXVsdGlSZXR1cm5UeXBlV2l0aEhvb2tzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4ge1xyXG5cclxuICAgIGRlYnVnTG9nKFwidXNlQXJpYUxpc3Rib3hNdWx0aVwiKTtcclxuXHJcbiAgICAvL2NvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0Rm9jdXNlZElubmVyIH0gPSB1c2VIYXNGb2N1czxMaXN0RWxlbWVudD4oe30pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dCwgdXNlTGFiZWxMYWJlbCB9ID0gdXNlTGFiZWw8TGlzdEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIHByZWZpeExhYmVsOiBcImFyaWEtbGlzdGJveC1sYWJlbC1cIixcclxuICAgICAgICAgICAgcHJlZml4SW5wdXQ6IFwiYXJpYS1saXN0Ym94LVwiLFxyXG4gICAgICAgICAgICB0YWdMYWJlbDogdGFnTGFiZWwsXHJcbiAgICAgICAgICAgIHRhZ0lucHV0OiB0YWdMaXN0XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbGlzdFJldHVyblR5cGUgPSB1c2VMaXN0TmF2aWdhdGlvbjxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBJbmZvLCBuZXZlcj4oe1xyXG5cclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxuIH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4ubHMgfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4ubWMgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgICAgICAuLi5ydGksXHJcbiAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25UYWJiYWJsZUluZGV4Q2hhbmdlPigoaSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPy4oaSk7XHJcbiAgICAgICAgICAgICAgICAvKmlmIChzZWxlY3Rpb25Nb2RlID09IFwiZm9jdXNcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChjaGlsZHJlbi5nZXRBdChpISk/LnN1YkluZm8uZ2V0RWxlbWVudCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdD8uKHsgdGFyZ2V0LCBjdXJyZW50VGFyZ2V0OiB0YXJnZXQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogaSEgfSB9KTtcclxuICAgICAgICAgICAgICAgIH0qL1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IHNldFRhYmJhYmxlSW5kZXggfVxyXG4gICAgfSA9IGxpc3RSZXR1cm5UeXBlXHJcblxyXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHMgfSA9IHVzZUxhYmVsSW5wdXQoKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0U2hpZnRIZWxkLCBzZXRTaGlmdEhlbGRdID0gdXNlUGFzc2l2ZVN0YXRlKG51bGwsIHJldHVybkZhbHNlKTtcclxuXHJcblxyXG4gICAgY29uc3QgdXNlTGlzdGJveE11bHRpSXRlbSA9IHVzZUNhbGxiYWNrPFVzZUxpc3Rib3hNdWx0aUl0ZW08TGlzdEl0ZW1FbGVtZW50Pj4oKHsgbGlzdGJveE11bHRpSXRlbTogeyBzZWxlY3RlZCwgZGlzYWJsZWQsIG9uU2VsZWN0IH0sIG1hbmFnZWRDaGlsZCwgbGlzdE5hdmlnYXRpb246IGxzLCByb3ZpbmdUYWJJbmRleDogcnRpIH0pID0+IHtcclxuICAgICAgICBkZWJ1Z0xvZyhcInVzZUFyaWFMaXN0Ym94TXVsdGlJdGVtXCIsIG1hbmFnZWRDaGlsZC5pbmRleCwgc2VsZWN0ZWQpO1xyXG4gICAgICAgIHR5cGUgRSA9IExpc3RJdGVtRWxlbWVudDtcclxuICAgICAgICBjb25zdCBnZXRTZWxlY3RlZCA9IHVzZVN0YWJsZUdldHRlcihzZWxlY3RlZCk7XHJcbiAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8RT4oe30pO1xyXG4gICAgICAgIGNvbnN0IHN0YWJsZU9uU2VsZWN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sob25TZWxlY3QgPz8gKCgpID0+IHsgfSkpO1xyXG5cclxuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcywgcm92aW5nVGFiSW5kZXg6IHJ0aTJfcmV0IH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHsgbGlzdE5hdmlnYXRpb246IGxzLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4OiBydGksIHN1YkluZm86IHsgc2VsZWN0ZWQsIG9uU2VsZWN0IH0gfSk7XHJcblxyXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIGdldFNoaWZ0SGVsZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFibGVPblNlbGVjdD8uKHsgdGFyZ2V0OiBlbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBlbGVtZW50LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiB0cnVlIH0gfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbcnRpMl9yZXQudGFiYmFibGVdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTGlzdGJveE11bHRpSXRlbVByb3BzLCBsaXN0Ym94TXVsdGlJdGVtOiB7IGdldFNlbGVjdGVkLCB0YWJiYWJsZTogcnRpMl9yZXQudGFiYmFibGUgfSwgcm92aW5nVGFiSW5kZXg6IHJ0aTJfcmV0IH07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiA9IHVzZVByZXNzRXZlbnRIYW5kbGVyczxFPihkaXNhYmxlZCA/IG51bGwgOiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChtYW5hZ2VkQ2hpbGQuaW5kZXgsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyAuLi5lLCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiAhZ2V0U2VsZWN0ZWQoKSB9IH0pO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9LCB7fSk7XHJcblxyXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJvcHRpb25cIjtcclxuICAgICAgICAgICAgLy9wcm9wc1tcImFyaWEtc2V0c2l6ZVwiXSA9IChjaGlsZENvdW50KS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAvL3Byb3BzW1wiYXJpYS1wb3NpbnNldFwiXSA9IChpbmZvLmluZGV4ICsgMSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgcHJvcHNbXCJhcmlhLXNlbGVjdGVkXCJdID0gKHJ0aTJfcmV0LnRhYmJhYmxlID8/IGZhbHNlKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpXHJcbiAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBcInRydWVcIjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHModXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHVzZU1lcmdlZFByb3BzPEU+KG5ld1Byb3BzLCBwcm9wcykpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRdKTtcclxuXHJcbiAgICBjb25zdCB1c2VMaXN0Ym94TXVsdGlMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUxhYmVsKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+IHtcclxuICAgICAgICAgICAgY29uc3QgeyB1c2VMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUxhYmVsTGFiZWwoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZUxhYmVsTGFiZWxQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VMaXN0Ym94TXVsdGlMYWJlbFByb3BzIH07XHJcbiAgICB9LCBbdXNlTGFiZWxMYWJlbF0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTGlzdGJveE11bHRpSXRlbSxcclxuICAgICAgICB1c2VMaXN0Ym94TXVsdGlQcm9wcyxcclxuICAgICAgICB1c2VMaXN0Ym94TXVsdGlMYWJlbCxcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogbGlzdFJldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IGxpc3RSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlTGlzdGJveE11bHRpUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PiB7XHJcbiAgICAgICAgcHJvcHMucm9sZSA9IFwibGlzdGJveFwiO1xyXG4gICAgICAgIHByb3BzW1wiYXJpYS1tdWx0aXNlbGVjdGFibGVcIl0gPSBcInRydWVcIjtcclxuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyh1c2VMYWJlbElucHV0UHJvcHModXNlTWVyZ2VkUHJvcHM8TGlzdEVsZW1lbnQ+KHsgb25LZXlEb3duLCBvbktleVVwLCBvbmZvY3Vzb3V0OiBvbkZvY3VzT3V0IH0sIHByb3BzKSkpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGU6IEtleWJvYXJkRXZlbnQpIHsgaWYgKGUua2V5ID09IFwiU2hpZnRcIikgc2V0U2hpZnRIZWxkKHRydWUpOyB9XHJcbiAgICBmdW5jdGlvbiBvbktleVVwKGU6IEtleWJvYXJkRXZlbnQpIHsgaWYgKGUua2V5ID09IFwiU2hpZnRcIikgc2V0U2hpZnRIZWxkKGZhbHNlKTsgfVxyXG4gICAgZnVuY3Rpb24gb25Gb2N1c091dChfOiBGb2N1c0V2ZW50KSB7IHNldFNoaWZ0SGVsZChmYWxzZSk7IH1cclxuXHJcbn0iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VIYXNGb2N1cywgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzLCB1c2VMaXN0TmF2aWdhdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCB1c2VNZXJnZWRQcm9wcywgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgcmV0dXJuRmFsc2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBkZWJ1Z0xvZywgd2Fybk9uT3ZlcndyaXRlIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlUHJlc3NFdmVudEhhbmRsZXJzIH0gZnJvbSBcIi4vdXNlLWJ1dHRvblwiO1xyXG5pbXBvcnQgeyB1c2VTb2Z0RGlzbWlzcywgVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzLCBVc2VTb2Z0RGlzbWlzc1JldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLW1vZGFsXCI7XHJcblxyXG5pbnRlcmZhY2UgTVNQIHtcclxuICAgIC8qKlxyXG4gICAgICogV2hhdCByb2xlIHRoZSBzdXJmYWNlIGZ1bGZpbGxzLlxyXG4gICAgICogXHJcbiAgICAgKiBHZW5lcmFsIG1lbnVzIHNob3VsZCB1c2UgXCJtZW51XCIuIFwiZGlhbG9nXCIgY2FuIGJlIHVzZWQgZm9yIGdlbmVyaWMgcG9wLXVwIHRoaW5ncy5cclxuICAgICAqL1xyXG4gICAgcm9sZTogXCJkaWFsb2dcIiB8IFwibWVudVwiIHwgXCJ0cmVlXCIgfCBcImdyaWRcIiB8IFwibGlzdGJveFwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB0aGlzIG1lbnUgc3VyZmFjZSBpcyBvcGVuZWQsIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIGl0IG11c3QgYmUgZm9jdXNlZC5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBjb250cm9scyB3aGF0IGlzIGZvY3VzZWQgKGUuZy4gdGhlIGZpcnN0IG1lbnUgaXRlbSwgdGhlIHdob2xlIHN1cmZhY2UgaXRzZWxmLCBldGMuKVxyXG4gICAgICovXHJcbiAgICBzZW5kRm9jdXNUb01lbnUoKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgTWVudVN1cmZhY2VPbWl0cyA9IGtleW9mIE1TUDtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYU1lbnVTdXJmYWNlUGFyYW1ldGVyczxTIGV4dGVuZHMgRWxlbWVudCwgQiBleHRlbmRzIEVsZW1lbnQsIE1TTyBleHRlbmRzIE1lbnVTdXJmYWNlT21pdHM+IGV4dGVuZHMgVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzPFwiZ2V0RWxlbWVudHNcIj4ge1xyXG4gICAgbWVudVN1cmZhY2U6IE9taXQ8TVNQLCBNU08+O1xyXG4gICAgaGFzRm9jdXNCdXR0b246IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxCPjtcclxuICAgIGhhc0ZvY3VzU3VyZmFjZTogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPFM+O1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYU1lbnVQYXJhbWV0ZXJzPFMgZXh0ZW5kcyBFbGVtZW50LCBCIGV4dGVuZHMgRWxlbWVudCwgTVNPIGV4dGVuZHMgTWVudVN1cmZhY2VPbWl0cz4gZXh0ZW5kcyBVc2VBcmlhTWVudVN1cmZhY2VQYXJhbWV0ZXJzPFMsIEIsIE1TTyB8IFwicm9sZVwiIHwgXCJzZW5kRm9jdXNUb01lbnVcIj4sIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+IHtcclxuICAgIG1lbnU6IHtcclxuICAgICAgICBvbk9wZW4oKTogdm9pZDtcclxuXHJcbiAgICAgICAgLy8gQ29ycmVzcG9uZHMgdG8gd2hhdCBhcnJvdyBrZXkgY2FuIG9wZW4gdGhpcyBtZW51XHJcbiAgICAgICAgb3BlbkRpcmVjdGlvbjogXCJkb3duXCIgfCBcInVwXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiB8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhTWVudUJ1dHRvblBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8RSwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYU1lbnVJdGVtUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEUsIHt9LCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+LCBcInN1YkluZm9cIj4geyB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFNZW51U3VyZmFjZVJldHVyblR5cGVJbmZvPE1lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgbWVudVN1cmZhY2U6IHtcclxuICAgICAgICBnZXRCdXR0b25Gb2N1c2VkKCk6IGJvb2xlYW47XHJcbiAgICAgICAgZ2V0QnV0dG9uRm9jdXNlZElubmVyKCk6IGJvb2xlYW47XHJcbiAgICAgICAgZ2V0QnV0dG9uTGFzdEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgICAgICBnZXRCdXR0b25MYXN0Rm9jdXNlZElubmVyKCk6IGJvb2xlYW47XHJcbiAgICAgICAgZ2V0QnV0dG9uRWxlbWVudDogKCkgPT4gTWVudUJ1dHRvbkVsZW1lbnQgfCBudWxsO1xyXG4gICAgICAgIGdldFN1cmZhY2VGb2N1c2VkKCk6IGJvb2xlYW47XHJcbiAgICAgICAgZ2V0U3VyZmFjZUZvY3VzZWRJbm5lcigpOiBib29sZWFuO1xyXG4gICAgICAgIGdldFN1cmZhY2VMYXN0Rm9jdXNlZCgpOiBib29sZWFuO1xyXG4gICAgICAgIGdldFN1cmZhY2VMYXN0Rm9jdXNlZElubmVyKCk6IGJvb2xlYW47XHJcbiAgICAgICAgZ2V0U3VyZmFjZUVsZW1lbnQ6ICgpID0+IE1lbnVQYXJlbnRFbGVtZW50IHwgbnVsbDtcclxuICAgICAgICBnZXRBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50IHwgbnVsbDtcclxuICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudDogKCkgPT4gRWxlbWVudDtcclxuICAgICAgICBnZXRXaW5kb3dGb2N1c2VkOiAoKSA9PiBib29sZWFuO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYU1lbnVSZXR1cm5UeXBlSW5mbzxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhTWVudVN1cmZhY2VSZXR1cm5UeXBlSW5mbzxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50PiwgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYU1lbnVCdXR0b25SZXR1cm5UeXBlSW5mbyBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxuZXZlcj4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYU1lbnVJdGVtUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50PiB7IH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYU1lbnVTdXJmYWNlUmV0dXJuVHlwZVdpdGhIb29rczxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhTWVudVN1cmZhY2VSZXR1cm5UeXBlSW5mbzxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50PiB7XHJcbiAgICB1c2VNZW51U3VyZmFjZVNlbnRpbmVsOiA8RSBleHRlbmRzIEVsZW1lbnQ+KCkgPT4geyB1c2VNZW51U2VudGluZWxQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjsgfTtcclxuICAgIHVzZU1lbnVTdXJmYWNlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVN1cmZhY2VFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVN1cmZhY2VFbGVtZW50PjtcclxuICAgIHVzZU1lbnVTdXJmYWNlQ2hpbGRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVQYXJlbnRFbGVtZW50PjsgIC8vIE5PVCBhIG1lbnUgaXRlbSEgVGhpcyBpcyB0aGUgbWVudSwgZGlhbG9nLCBwb3B1cCwgd2hhdGV2ZXIgYWN0dWFsbHkgZ2V0cyB0aGUgcm9sZSwgYXMgb3Bwb3NlZCB0byB0aGUgc3VyZmFjZSB0aGF0IGxpc3RlbnMgdG8gbW91c2UgYW5kIGtleWJvYXJkIGV2ZW50c1xyXG4gICAgdXNlTWVudVN1cmZhY2VCdXR0b25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51QnV0dG9uRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT47XHJcblxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYU1lbnVSZXR1cm5UeXBlV2l0aEhvb2tzPE1lbnVTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFyaWFNZW51UmV0dXJuVHlwZUluZm88TWVudVN1cmZhY2VFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudD4ge1xyXG4gICAgdXNlTWVudVNlbnRpbmVsOiA8RSBleHRlbmRzIEVsZW1lbnQ+KCkgPT4geyB1c2VNZW51U2VudGluZWxQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjsgfTtcclxuICAgIHVzZU1lbnVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVQYXJlbnRFbGVtZW50PjtcclxuICAgIHVzZU1lbnVTdXJmYWNlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVN1cmZhY2VFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVN1cmZhY2VFbGVtZW50PjtcclxuICAgIHVzZU1lbnVCdXR0b25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51QnV0dG9uRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PjtcclxuICAgIHVzZU1lbnVJdGVtOiBVc2VNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQ+O1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYU1lbnVCdXR0b25SZXR1cm5UeXBlV2l0aEhvb2tzIGV4dGVuZHMgVXNlQXJpYU1lbnVCdXR0b25SZXR1cm5UeXBlSW5mbyB7IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhTWVudUl0ZW1SZXR1cm5UeXBlV2l0aEhvb2tzPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQXJpYU1lbnVJdGVtUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50PiB7IH1cclxuXHJcbi8vZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+IHt9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFNZW51SXRlbVJldHVyblR5cGVXaXRoSG9va3M8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+IHtcclxuICAgIHVzZU1lbnVJdGVtUHJvcHM6IFVzZU1lbnVJdGVtUHJvcHM8TWVudUl0ZW1FbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlTWVudUl0ZW1Qcm9wczxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUl0ZW1FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUl0ZW1FbGVtZW50PjtcclxuXHJcbmV4cG9ydCB0eXBlIFVzZU1lbnVJdGVtPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUFyaWFNZW51SXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50PikgPT4gVXNlQXJpYU1lbnVJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxNZW51SXRlbUVsZW1lbnQ+O1xyXG5cclxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVDaGlsZEluZm9CYXNlPEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZEluZm9CYXNlPEs+IHt9XHJcblxyXG4vL2V4cG9ydCB0eXBlIFVzZU1lbnVDaGlsZFBhcmFtZXRlcnM8SSBleHRlbmRzIFVzZU1lbnVDaGlsZEluZm8+ID0gSTtcclxuXHJcbi8qKlxyXG4gKiBBIG1lbnUgaXMgYSBwb3B1cCBjb250cm9sIHRoYXQgY29udGFpbnMgYSBsaXN0IG9mIG1lbnUgaXRlbXMsIGFuZCB0aGF0J3MgaXQuXHJcbiAqIEl0IGhhcyB2ZXJ5IHdlbGwtZGVmaW5lZCBsb2dpYyBmb3IgbWFuYWdpbmcgdGhvc2UgaXRlbXMgYXMgdGhlIG1lbnUncyBzdGF0ZSBjaGFuZ2VzLlxyXG4gKiBcclxuICogQSBNZW51QmFzZSBpcyBqdXN0IHRoZSBcInBvcHVwXCIgcGFydCB3aXRob3V0IHRoZSBcImxpc3Qgb2YgbWVudSBpdGVtc1wiIHBhcnQuIEl0IGNhblxyXG4gKiAocmVhbGx5LCBtdXN0KSBoYXZlIGludGVyYWN0aXZlIGNvbnRyb2xzLCBidXQgdGhlc2UgY29udHJvbHMgYXJlIGFsbG93ZWQgdG8gYmUgbW9yZVxyXG4gKiBmcmVlLWZvcm0uIFRoaXMgbWVhbnMgdGhhdCwgbGlrZSBhIGRpYWxvZywgeW91IG11c3QgdGVsbCB0aGlzIGhvb2tcclxuICogd2hlcmUgd2l0aGluIHRoZSBwb3B1cCB0byBzZW5kIGZvY3VzIHdoZW4gb3BlbmVkIChmb3IgYSBtZW51IGl0J3MganVzdCB0aGUgZmlyc3RcclxuICogbWVudSBpdGVtLCBidXQgd2l0aCBjdXN0b20gY29udGVudCB5b3UnbGwgbmVlZCB0byBwcm92aWRlIHRoaXMpLlxyXG4gKiBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW51U3VyZmFjZTxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBzb2Z0RGlzbWlzcywgbWVudVN1cmZhY2U6IHsgc2VuZEZvY3VzVG9NZW51LCByb2xlIH0sIGhhc0ZvY3VzQnV0dG9uLCBoYXNGb2N1c1N1cmZhY2UsIGFjdGl2ZUVsZW1lbnQgfTogVXNlQXJpYU1lbnVTdXJmYWNlUGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBuZXZlcj4pOiBVc2VBcmlhTWVudVN1cmZhY2VSZXR1cm5UeXBlV2l0aEhvb2tzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50PiB7XHJcbiAgICBkZWJ1Z0xvZyhcInVzZUFyaWFNZW51U3VyZmFjZVwiKTtcclxuICAgIC8vY29uc3Qgc2VuZEZvY3VzV2l0aGluTWVudSA9IHVzZVN0YWJsZUNhbGxiYWNrKHNlbmRGb2N1c1RvTWVudSk7XHJcbiAgICAvL2NvbnN0IFtmb2N1c1RyYXBBY3RpdmUsIHNldEZvY3VzVHJhcEFjdGl2ZV0gPSB1c2VTdGF0ZTxudWxsIHwgYm9vbGVhbj4obnVsbCk7XHJcbiAgICBjb25zdCB7IG9wZW4sIG9uQ2xvc2U6IHVzZXJPbkNsb3NlIH0gPSBzb2Z0RGlzbWlzcztcclxuICAgIGNvbnN0IG9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjazx0eXBlb2YgdXNlck9uQ2xvc2U+KChyZWFzb24pID0+IHtcclxuICAgICAgICBpZiAocmVhc29uICE9IFwibG9zdC1mb2N1c1wiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wZW5lciA9IChnZXRPcGVuZXJFbGVtZW50KCkgYXMgSFRNTEVsZW1lbnQgfCBudWxsKTtcclxuICAgICAgICAgICAgaWYgKG9wZW5lciAmJiBcImZvY3VzXCIgaW4gb3BlbmVyKVxyXG4gICAgICAgICAgICAgICAgb3BlbmVyLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVzZXJPbkNsb3NlKHJlYXNvbik7XHJcbiAgICB9KVxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTWVudVN1cmZhY2VcIiwgb25DbG9zZSwgcm9sZSwgc2VuZEZvY3VzVG9NZW51KTtcclxuICAgIGNvbnN0IGdldElzT3BlbiA9IHVzZVN0YWJsZUdldHRlcihvcGVuKTtcclxuICAgIGNvbnN0IGludGVyc2VjdGlvbk9ic2VydmVyID0gdXNlUmVmPEludGVyc2VjdGlvbk9ic2VydmVyPihudWxsISk7XHJcbiAgICBjb25zdCBbZ2V0U3VyZmFjZUZ1bGx5VmlzaWJsZSwgc2V0U3VyZmFjZUZ1bGx5VmlzaWJsZV0gPSB1c2VQYXNzaXZlU3RhdGUobnVsbCwgcmV0dXJuRmFsc2UpO1xyXG4gICAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuY3VycmVudCA/Pz0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzLCBvYnNlcnZlcikgPT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xyXG4gICAgICAgICAgICBzZXRTdXJmYWNlRnVsbHlWaXNpYmxlKGVudHJ5LmludGVyc2VjdGlvblJhdGlvID49IDEpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHsgcm9vdDogbnVsbCwgdGhyZXNob2xkOiBbMCwgMV0gfSk7XHJcblxyXG4gICAgY29uc3QgWywgc2V0T3BlbmVyRWxlbWVudCwgZ2V0T3BlbmVyRWxlbWVudF0gPSB1c2VTdGF0ZTxNZW51QnV0dG9uRWxlbWVudCB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wczogdXNlTWVudUJhc2VIYXNGb2N1c1Byb3BzLCAuLi5zdXJmYWNlSGFzRm9jdXMgfSA9IHVzZUhhc0ZvY3VzPE1lbnVTdXJmYWNlRWxlbWVudD4oeyAuLi5oYXNGb2N1c1N1cmZhY2UgfSk7XHJcbiAgICBjb25zdCB7IH0gPSB1c2VSZWZFbGVtZW50PE1lbnVCdXR0b25FbGVtZW50Pih7IG9uRWxlbWVudENoYW5nZTogc2V0T3BlbmVyRWxlbWVudCB9KTtcclxuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wczogdXNlQnV0dG9uSGFzRm9jdXNQcm9wcywgLi4uYnV0dG9uSGFzRm9jdXMgfSA9IHVzZUhhc0ZvY3VzPE1lbnVCdXR0b25FbGVtZW50Pih7IC4uLmhhc0ZvY3VzQnV0dG9uIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgZ2V0TGFzdEZvY3VzZWRJbm5lcjogZ2V0TWVudUJhc2VMYXN0Rm9jdXNlZElubmVyIH0gPSBzdXJmYWNlSGFzRm9jdXM7XHJcblxyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkPE1lbnVQYXJlbnRFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLW1lbnUtXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7fSB9KTtcclxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHMgfSA9IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCgpO1xyXG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgfSA9IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ8TWVudUJ1dHRvbkVsZW1lbnQ+KFwiYXJpYS1jb250cm9sc1wiIGFzIG5ldmVyKTtcclxuXHJcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldEJ1dHRvbkVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlQnV0dG9uUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PE1lbnVCdXR0b25FbGVtZW50Pih7IG9uRWxlbWVudENoYW5nZTogc2V0T3BlbmVyRWxlbWVudCB9KTtcclxuXHJcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldE1lbnVFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZU1lbnVCYXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PE1lbnVTdXJmYWNlRWxlbWVudD4oe30pO1xyXG4gICAgY29uc3QgeyB1c2VTb2Z0RGlzbWlzc1Byb3BzLCAuLi5zb2Z0RGlzbWlzc1JldHVybiB9ID0gdXNlU29mdERpc21pc3M8YW55Pih7XHJcbiAgICAgICAgc29mdERpc21pc3M6IHtcclxuICAgICAgICAgICAgLi4uc29mdERpc21pc3MsXHJcbiAgICAgICAgICAgIGdldEVsZW1lbnRzOiAoKSA9PiAoW2dldEJ1dHRvbkVsZW1lbnQoKSwgZ2V0TWVudUVsZW1lbnQoKV0pLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWN0aXZlRWxlbWVudFxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZU1lbnVTdXJmYWNlUHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51U3VyZmFjZUVsZW1lbnQ+ID0+IHtcclxuICAgICAgICBmdW5jdGlvbiBvbktleURvd24oZTogS2V5Ym9hcmRFdmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBvcGVuID0gZ2V0SXNPcGVuKCk7XHJcbiAgICAgICAgICAgIGlmIChlLmtleSA9PSBcIkVzY2FwZVwiICYmIG9wZW4pIHtcclxuICAgICAgICAgICAgICAgIG9uQ2xvc2UoXCJlc2NhcGVcIik7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVzZVNvZnREaXNtaXNzUHJvcHModXNlTWVudUJhc2VIYXNGb2N1c1Byb3BzKHVzZU1lbnVCYXNlUmVmRWxlbWVudFByb3BzKCh1c2VNZXJnZWRQcm9wczxNZW51U3VyZmFjZUVsZW1lbnQ+KHsgb25LZXlEb3duIH0sIChwcm9wcykpKSkpKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgdXNlTWVudVN1cmZhY2VCdXR0b25Qcm9wcyA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUJ1dHRvbkVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUJ1dHRvbkVsZW1lbnQ+ID0+IHtcclxuICAgICAgICBwcm9wc1tcImFyaWEtZXhwYW5kZWRcIl0gPSB3YXJuT25PdmVyd3JpdGUoXCJ1c2VNZW51U3VyZmFjZUJ1dHRvblByb3BzXCIsIFwiYXJpYS1leHBhbmRlZFwiLCBvcGVuLCBvcGVuLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHByb3BzW1wiYXJpYS1oYXNwb3B1cFwiXSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZU1lbnVTdXJmYWNlQnV0dG9uUHJvcHNcIiwgXCJhcmlhLWhhc3BvcHVwXCIsIHJvbGUsIHJvbGUpO1xyXG4gICAgICAgIHJldHVybiB1c2VCdXR0b25SZWZFbGVtZW50UHJvcHModXNlQnV0dG9uSGFzRm9jdXNQcm9wcyh1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMocHJvcHMpKSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG5cclxuICAgICAgICBpZiAob3BlbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBzZW5kRm9jdXNUb01lbnU/LigpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghZ2V0U3VyZmFjZUZ1bGx5VmlzaWJsZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0TWVudUVsZW1lbnQoKT8uc2Nyb2xsSW50b1ZpZXcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9LCBbb3Blbl0pO1xyXG5cclxuICAgIGZ1bmN0aW9uIHVzZU1lbnVTdXJmYWNlQ2hpbGRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVBhcmVudEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVBhcmVudEVsZW1lbnQ+IHtcclxuICAgICAgICBwcm9wcy5yb2xlID0gcm9sZTtcclxuICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHMocHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTWVudVN1cmZhY2VDaGlsZFByb3BzLFxyXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlU2VudGluZWw6IHVzZUNhbGxiYWNrKDxFIGV4dGVuZHMgRWxlbWVudD4oKSA9PiB7XHJcbiAgICAgICAgICAgIGRlYnVnTG9nKFwidXNlQXJpYU1lbnVTdXJmYWNlU2VudGluZWxcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgICAgIHVzZVNlbnRpbmVsUHJvcHM6IHVzZU1lbnVTZW50aW5lbFByb3BzLFxyXG4gICAgICAgICAgICAgICAgLi4ucmVzdFxyXG4gICAgICAgICAgICB9ID0gdXNlRm9jdXNTZW50aW5lbDxFPih7XHJcbiAgICAgICAgICAgICAgICBmb2N1c1NlbnRpbmVsOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3Blbjogb3BlbiA9PT0gdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiBvbkNsb3NlKFwiZXNjYXBlXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIHNlbmRGb2N1c1RvTWVudVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdXNlTWVudVNlbnRpbmVsUHJvcHMsIC4uLnJlc3QgfTtcclxuICAgICAgICB9LCBbb3Blbiwgb25DbG9zZV0pLFxyXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlUHJvcHMsXHJcbiAgICAgICAgdXNlTWVudVN1cmZhY2VCdXR0b25Qcm9wcyxcclxuICAgICAgICBtZW51U3VyZmFjZToge1xyXG4gICAgICAgICAgICBnZXRBY3RpdmVFbGVtZW50OiBidXR0b25IYXNGb2N1cy5nZXRBY3RpdmVFbGVtZW50LFxyXG4gICAgICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudDogYnV0dG9uSGFzRm9jdXMuZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsXHJcbiAgICAgICAgICAgIGdldEJ1dHRvbkVsZW1lbnQ6IGJ1dHRvbkhhc0ZvY3VzLmdldEVsZW1lbnQsXHJcbiAgICAgICAgICAgIGdldEJ1dHRvbkZvY3VzZWQ6IGJ1dHRvbkhhc0ZvY3VzLmdldEZvY3VzZWQsXHJcbiAgICAgICAgICAgIGdldEJ1dHRvbkZvY3VzZWRJbm5lcjogYnV0dG9uSGFzRm9jdXMuZ2V0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgICAgICBnZXRCdXR0b25MYXN0Rm9jdXNlZDogYnV0dG9uSGFzRm9jdXMuZ2V0TGFzdEZvY3VzZWQsXHJcbiAgICAgICAgICAgIGdldEJ1dHRvbkxhc3RGb2N1c2VkSW5uZXI6IGJ1dHRvbkhhc0ZvY3VzLmdldExhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgICAgIGdldFN1cmZhY2VFbGVtZW50OiBzdXJmYWNlSGFzRm9jdXMuZ2V0RWxlbWVudCxcclxuICAgICAgICAgICAgZ2V0U3VyZmFjZUZvY3VzZWQ6IHN1cmZhY2VIYXNGb2N1cy5nZXRGb2N1c2VkLFxyXG4gICAgICAgICAgICBnZXRTdXJmYWNlRm9jdXNlZElubmVyOiBzdXJmYWNlSGFzRm9jdXMuZ2V0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgICAgICBnZXRTdXJmYWNlTGFzdEZvY3VzZWQ6IHN1cmZhY2VIYXNGb2N1cy5nZXRMYXN0Rm9jdXNlZCxcclxuICAgICAgICAgICAgZ2V0U3VyZmFjZUxhc3RGb2N1c2VkSW5uZXI6IHN1cmZhY2VIYXNGb2N1cy5nZXRMYXN0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgICAgICBnZXRXaW5kb3dGb2N1c2VkOiBidXR0b25IYXNGb2N1cy5nZXRXaW5kb3dGb2N1c2VkLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLi4uc29mdERpc21pc3NSZXR1cm5cclxuXHJcbiAgICAgICAgLy9nZXRNZW51QmFzZUxhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgLy9nZXRNZW51QmFzZUJ1dHRvbkxhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgLy9vcGVuLFxyXG4gICAgICAgIC8vb25PcGVuLFxyXG4gICAgICAgIC8vb25DbG9zZVxyXG4gICAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgRlNQIGV4dGVuZHMgTVNQIHtcclxuICAgIG9wZW46IGJvb2xlYW47XHJcbiAgICBvbkNsb3NlKCk6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEZvY3VzU2VudGluZWxPbWl0cyA9IGtleW9mIEZTUDtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlRm9jdXNTZW50aW5lbFBhcmFtZXRlcnMge1xyXG4gICAgZm9jdXNTZW50aW5lbDogeyBzZW5kRm9jdXNUb01lbnU6IE1TUFtcInNlbmRGb2N1c1RvTWVudVwiXTsgb3BlbjogYm9vbGVhbjsgb25DbG9zZSgpOiB2b2lkOyB9O1xyXG59XHJcblxyXG5cclxuLy8gQSBmb2N1cyBzZW50aW5hbCBpcyBhIGhpZGRlbiBidXQgZm9jdXNhYmxlIGVsZW1lbnQgdGhhdCBjb21lcyBhdCB0aGUgc3RhcnQgb3IgZW5kIFxyXG4vLyBvZiB0aGUgb3V0LW9mLXBsYWNlLWZvY3VzYWJsZSBjb21wb25lbnQgdGhhdCwgd2hlbiBhY3RpdmF0ZWQgb3IgZm9jdXNlZCBvdmVyLCBjbG9zZXMgdGhlIGNvbXBvbmVudFxyXG4vLyAoaWYgZm9jdXNlZCB3aXRoaW4gMTAwbXMgb2YgdGhlIG9wZW4gcHJvcCBjaGFuZ2luZywgaW5zdGVhZCBvZlxyXG4vLyBjbG9zaW5nLCBmb2N1c2luZyB0aGUgc2VudGluZWwgaW1tZWRpYXRlbHkgYXNrcyBpdCB0byBmb2N1cyBpdHNlbGYpLlxyXG4vLyBUaGlzIGV4aXN0cyBmb3IgdGhpbmdzIGxpa2UgbWVudXMgd2hpY2ggY2FuIGhhdmUgZm9jdXMgYnV0IGFsc28gbmVlZCBhIHdheSB0byByZXR1cm5cclxuLy8gdG8gd2hhdGV2ZXIgb3V0LW9mLXBsYWNlIHBhcmVudCB0aGV5IGNhbWUgZnJvbSB3aGVuIG5hdHVyYWxseSB0YWJiZWQgb3V0IG9mIChhcyBvcHBvc2VkXHJcbi8vIHRvIGRpYWxvZ3Mgd2hpY2ggbG9vcCBiYWNrIGFyb3VuZCB3aGVuIHRhYmJlZCBvdXQgb2YpLiBXaGlsZSBtb3VzZSB1c2VycyBjYW4gY2xpY2sgb3V0IG9mIGEgbWVudVxyXG4vLyBhbmQga2V5Ym9hcmQgdXNlcnMgY2FuIGVzY2FwZSB0byBjbG9zZSBhIG1lbnUsIHNjcmVlbiByZWFkZXJzIGFuZCBvdGhlciBpbnB1dCBtZXRob2RzIFxyXG4vLyB0aGF0IGRvbid0IHVzZSB0aG9zZSB0d28gd291bGQgYmVjb21lIHN0dWNrLlxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9jdXNTZW50aW5lbDxFIGV4dGVuZHMgRWxlbWVudD4oeyBmb2N1c1NlbnRpbmVsOiB7IG9wZW4sIG9uQ2xvc2UsIHNlbmRGb2N1c1RvTWVudSB9IH06IFVzZUZvY3VzU2VudGluZWxQYXJhbWV0ZXJzKSB7XHJcbiAgICBkZWJ1Z0xvZyhcInVzZUFyaWFGb2N1c1NlbnRpbmVsXCIpO1xyXG4gICAgY29uc3QgZ2V0U2VuZEZvY3VzV2l0aGluTWVudSA9IHVzZVN0YWJsZUdldHRlcihzZW5kRm9jdXNUb01lbnUpO1xyXG4gICAgY29uc3Qgc3RhYmxlT25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UpO1xyXG5cclxuICAgIGNvbnN0IFtmaXJzdFNlbnRpbmVsSXNBY3RpdmUsIHNldEZpcnN0U2VudGluZWxJc0FjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICB1c2VUaW1lb3V0KHsgY2FsbGJhY2s6ICgpID0+IHsgc2V0Rmlyc3RTZW50aW5lbElzQWN0aXZlKG9wZW4pOyB9LCB0aW1lb3V0OiAxMDAsIHRyaWdnZXJJbmRleDogYCR7b3Blbn0tJHtmaXJzdFNlbnRpbmVsSXNBY3RpdmV9YCB9KTtcclxuXHJcblxyXG4gICAgY29uc3Qgb25Gb2N1cyA9IGZpcnN0U2VudGluZWxJc0FjdGl2ZSA/ICgoKSA9PiBzdGFibGVPbkNsb3NlKCkpIDogKCgpID0+IGdldFNlbmRGb2N1c1dpdGhpbk1lbnUoKT8uKCkpO1xyXG4gICAgY29uc3Qgb25DbGljayA9ICgpID0+IHN0YWJsZU9uQ2xvc2UoKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVNlbnRpbmVsUHJvcHM6IGZ1bmN0aW9uICh7IHRhYkluZGV4LCAuLi5wIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oeyBvbkZvY3VzLCBvbkNsaWNrLCB0YWJJbmRleDogd2Fybk9uT3ZlcndyaXRlKFwidXNlRm9jdXNTZW50aW5lbFwiLCBcInRhYkluZGV4XCIsIHRhYkluZGV4LCAwKSB9LCBwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhTWVudTxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCBtZW51U3VyZmFjZSwgcm92aW5nVGFiSW5kZXgsIHNvZnREaXNtaXNzLCB0eXBlYWhlYWROYXZpZ2F0aW9uLCBtZW51LCBoYXNGb2N1c0J1dHRvbiwgaGFzRm9jdXNTdXJmYWNlLCBhY3RpdmVFbGVtZW50IH06IFVzZUFyaWFNZW51UGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBuZXZlcj4pOiBVc2VBcmlhTWVudVJldHVyblR5cGVXaXRoSG9va3M8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudD4ge1xyXG5cclxuICAgIGRlYnVnTG9nKFwidXNlQXJpYU1lbnVcIik7XHJcbiAgICBjb25zdCB7IG9uT3BlbiB9ID0gbWVudTtcclxuICAgIGNvbnN0IHsgb3Blbiwgb25DbG9zZSB9ID0gc29mdERpc21pc3M7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcclxuICAgICAgICAuLi51c2VMaXN0TmF2UmV0dXJuXHJcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb248TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwge30sIHN0cmluZz4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb24sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0gfSA9IHVzZUxpc3ROYXZSZXR1cm47XHJcblxyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICAvKnVzZU1lbnVTZW50aW5lbCxcclxuICAgICAgICB1c2VNZW51QmFzZUJ1dHRvblByb3BzLFxyXG4gICAgICAgIHVzZU1lbnVCYXNlUHJvcHMsXHJcbiAgICAgICAgb3BlbixcclxuICAgICAgICBvbk9wZW4sXHJcbiAgICAgICAgb25DbG9zZTogX29uQ2xvc2UsKi9cclxuICAgICAgICB1c2VNZW51U3VyZmFjZUJ1dHRvblByb3BzLFxyXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlUHJvcHMsXHJcbiAgICAgICAgdXNlTWVudVN1cmZhY2VTZW50aW5lbCxcclxuICAgICAgICB1c2VNZW51U3VyZmFjZUNoaWxkUHJvcHMsXHJcbiAgICAgICAgLi4ubWVudVJlc3RcclxuICAgIH0gPSB1c2VNZW51U3VyZmFjZTxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudD4oe1xyXG4gICAgICAgIG1lbnVTdXJmYWNlOiB7XHJcbiAgICAgICAgICAgIC4uLm1lbnVTdXJmYWNlLFxyXG4gICAgICAgICAgICByb2xlOiBcIm1lbnVcIixcclxuICAgICAgICAgICAgc2VuZEZvY3VzVG9NZW51OiB1c2VDYWxsYmFjaygoKSA9PiBjaGlsZHJlbi5nZXRBdCgwKT8uc3ViSW5mby5mb2N1c1NlbGYoKSwgW10pXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzb2Z0RGlzbWlzcyxcclxuICAgICAgICBoYXNGb2N1c0J1dHRvbixcclxuICAgICAgICBoYXNGb2N1c1N1cmZhY2UsXHJcbiAgICAgICAgYWN0aXZlRWxlbWVudFxyXG4gICAgICAgIC8vc2VuZEZvY3VzV2l0aGluTWVudTogZm9jdXNNZW51ID8/ICgoKSA9PiB7IH0pXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VNZW51QnV0dG9uUHJvcHMgPSAoKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHByZXNzUHJvcHMgPSB1c2VQcmVzc0V2ZW50SGFuZGxlcnM8TWVudUJ1dHRvbkVsZW1lbnQ+KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKG9wZW4pXHJcbiAgICAgICAgICAgICAgICBvbkNsb3NlPy4oXCJlc2NhcGVcIik7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG9uT3Blbj8uKCk7XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgICAgIGNvbnN0IHByb3BzID0gdXNlTWVudVN1cmZhY2VCdXR0b25Qcm9wcyhwKTtcclxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8TWVudUJ1dHRvbkVsZW1lbnQ+KHByZXNzUHJvcHMsIHByb3BzKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZU1lbnVJdGVtID0gdXNlQ2FsbGJhY2s8VXNlTWVudUl0ZW08TWVudUl0ZW1FbGVtZW50Pj4oKHsgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXggfSkgPT4ge1xyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlQXJpYU1lbnVJdGVtXCIsIG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcblxyXG4gICAgICAgIHR5cGUgRSA9IE1lbnVJdGVtRWxlbWVudDtcclxuXHJcbiAgICAgICAgY29uc3QgeyB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsIC4uLmxpc3ROYXZSZXQgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgc3ViSW5mbzoge30gfSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZU1lbnVJdGVtUHJvcHM8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+Pih7IC4uLnByb3BzIH06IFApIHtcclxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwibWVudWl0ZW1cIjtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHt9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMocHJvcHMpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZU1lbnVJdGVtUHJvcHMsIC4uLmxpc3ROYXZSZXQgfTtcclxuICAgIH0sIFtdKTtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlTWVudVByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD4pIHtcclxuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyh1c2VNZW51U3VyZmFjZUNoaWxkUHJvcHMocHJvcHMpKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VNZW51UHJvcHMsXHJcbiAgICAgICAgdXNlTWVudVN1cmZhY2VQcm9wcyxcclxuXHJcbiAgICAgICAgdXNlTWVudUJ1dHRvblByb3BzLFxyXG5cclxuICAgICAgICB1c2VNZW51SXRlbSxcclxuICAgICAgICB1c2VNZW51U2VudGluZWw6IHVzZU1lbnVTdXJmYWNlU2VudGluZWwsXHJcbiAgICAgICAgLy91c2VNZW51U3VibWVudUl0ZW0sXHJcbiAgICAgICAgLi4udXNlTGlzdE5hdlJldHVybixcclxuICAgICAgICAuLi5tZW51UmVzdFxyXG5cclxuICAgICAgICAvKmZvY3VzTWVudSxcclxuXHJcbiAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcclxuICAgICAgICBpbnZhbGlkVHlwZWFoZWFkLFxyXG5cclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sKi9cclxuXHJcblxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IGdlbmVyYXRlUmFuZG9tSWQsIHJldHVyblRydWUsIHVzZUVmZmVjdCwgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb24sIHVzZU1hbmFnZWRDaGlsZHJlbiwgdXNlTWVyZ2VkUHJvcHMsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgdXNlQ2hpbGRyZW5GbGFnLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTGFiZWwgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcclxuaW1wb3J0IHsgZGVidWdMb2csIEVuaGFuY2VkRXZlbnQsIGVuaGFuY2VFdmVudCwgRXZlbnREZXRhaWwsIHdhcm5Pbk92ZXJ3cml0ZSB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycywgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWhhcy1mb2N1c1wiO1xyXG5pbXBvcnQgeyB1c2VQcmVzc0V2ZW50SGFuZGxlcnMgfSBmcm9tIFwiLi91c2UtYnV0dG9uXCI7XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgVGFic0NoYW5nZUV2ZW50PEUgZXh0ZW5kcyBFbGVtZW50PiA9IHsgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfSB9ICYgUGljazxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+LCBcInRhcmdldFwiIHwgXCJjdXJyZW50VGFyZ2V0XCI+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFic1BhcmFtZXRlcnMge1xyXG4gICAgdGFiUGFuZWxzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPG51bWJlciwgbmV2ZXI+O1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYlBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxFLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiwgXCJzdWJJbmZvXCI+IHtcclxuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYlBhbmVsUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8bnVtYmVyLCB7fSwgXCJ2aXNpYmxlXCIsIFwic3ViSW5mb1wiPiB7IH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYlJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PiB7IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFiUmV0dXJuVHlwZVdpdGhIb29rczxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhVGFiUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudD4ge1xyXG4gICAgdXNlQXJpYVRhYlByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFUYWJMYWJlbFBhcmFtZXRlcnMgeyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQgZXh0ZW5kcyBFdmVudFRhcmdldD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4ge1xyXG4gICAgdGFiczogeyBvblNlbGVjdGVkSW5kZXhDaGFuZ2UoZTogRW5oYW5jZWRFdmVudDxUYWJFbGVtZW50LCBFdmVudCwgeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfT4pOiB2b2lkOyB9O1xyXG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyc1tcImNoaWxkcmVuSGF2ZUZvY3VzXCJdO1xyXG5cclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFUYWJMaXN0UmV0dXJuVHlwZUluZm88VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcclxuICAgIHRhYkxpc3Q6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudCwgVGFiSW5mbywgbmV2ZXI+O1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYkxpc3RSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYkNvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhVGFiTGlzdFJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+IHtcclxuICAgIHVzZUFyaWFUYWJMaXN0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiQ29udGFpbmVyRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkNvbnRhaW5lckVsZW1lbnQ+O1xyXG4gICAgdXNlQXJpYVRhYjogKHsgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXggfTogVXNlQXJpYVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4pID0+IFVzZUFyaWFUYWJSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYkVsZW1lbnQ+XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFUYWJQYW5lbFJldHVyblR5cGVJbmZvIHtcclxuICAgIHRhYlBhbmVsOiB7IHZpc2libGU6IGJvb2xlYW47IGdldFZpc2libGU6ICgpID0+IGJvb2xlYW47IH07XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFiUGFuZWxSZXR1cm5UeXBlV2l0aEhvb2tzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQXJpYVRhYlBhbmVsUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlQXJpYVRhYlBhbmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYkxpc3RMYWJlbFJldHVyblR5cGVJbmZvIHsgfVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFUYWJMYWJlbFJldHVyblR5cGVXaXRoSG9va3M8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhVGFiTGlzdExhYmVsUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlQXJpYVRhYkxpc3RMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYnNSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB0YWJQYW5lbHM6IFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPG51bWJlciwgVGFiUGFuZWxJbmZvLCBuZXZlcj47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYnNSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYkNvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhVGFic1JldHVyblR5cGVJbmZvIHtcclxuICAgIHVzZUFyaWFUYWJMaXN0OiBVc2VBcmlhVGFiTGlzdDxUYWJDb250YWluZXJFbGVtZW50LCBUYWJFbGVtZW50PjtcclxuICAgIHVzZUFyaWFUYWJQYW5lbDogVXNlQXJpYVRhYlBhbmVsPFBhbmVsRWxlbWVudD47XHJcbiAgICB1c2VBcmlhVGFiTGlzdExhYmVsOiBVc2VBcmlhVGFiTGlzdExhYmVsPExhYmVsRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZUFyaWFUYWI8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUFyaWFUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+KSA9PiBVc2VBcmlhVGFiUmV0dXJuVHlwZVdpdGhIb29rczxUYWJFbGVtZW50PjtcclxuZXhwb3J0IHR5cGUgVXNlQXJpYVRhYkxpc3Q8VGFiQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VBcmlhVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4pID0+IFVzZUFyaWFUYWJMaXN0UmV0dXJuVHlwZVdpdGhIb29rczxUYWJDb250YWluZXJFbGVtZW50LCBUYWJFbGVtZW50PjtcclxuZXhwb3J0IHR5cGUgVXNlQXJpYVRhYlBhbmVsPFBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUFyaWFUYWJQYW5lbFBhcmFtZXRlcnMpID0+IFVzZUFyaWFUYWJQYW5lbFJldHVyblR5cGVXaXRoSG9va3M8UGFuZWxFbGVtZW50PjtcclxuZXhwb3J0IHR5cGUgVXNlQXJpYVRhYkxpc3RMYWJlbDxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VBcmlhVGFiTGFiZWxQYXJhbWV0ZXJzKSA9PiBVc2VBcmlhVGFiTGFiZWxSZXR1cm5UeXBlV2l0aEhvb2tzPExhYmVsRWxlbWVudD47XHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhVGFiczxUYWJMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhYlBhbmVsczogeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY21jLCAuLi50YWJQYW5lbHNNYW5hZ2VkQ2hpbGRyZW4gfSB9IH06IFVzZUFyaWFUYWJzUGFyYW1ldGVycyk6IFVzZUFyaWFUYWJzUmV0dXJuVHlwZVdpdGhIb29rczxUYWJMaXN0RWxlbWVudCwgVGFiRWxlbWVudCwgUGFuZWxFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcclxuICAgIGNvbnN0IHsgXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCwgXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyBcclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxUYWJMaXN0RWxlbWVudCwgVGFiRWxlbWVudCwgVGFiSW5mbywgbmV2ZXI+KHsgXHJcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXM6IHt9LCBcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSwgXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHt9LCBcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHt9LCBcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge30sIFxyXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjoge30sIFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHt9XHJcbiAgICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXNlVGFiID0gdXNlQ2FsbGJhY2soKCkgPT4ge30sIFtdKTtcclxuICAgIGNvbnN0IHVzZVRhYlBhbmVsID0gdXNlQ2FsbGJhY2soKCkgPT4ge30pO1xyXG4gICAgZnVuY3Rpb24gdXNlVGFiTGlzdFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJMaXN0RWxlbWVudD4pIHsgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMocHJvcHMpOyB9XHJcbiAgICBmdW5jdGlvbiB1c2VUYWJMYWJlbFByb3BzKCkge31cclxuXHJcbiAgICByZXR1cm4ge1xyXG5cclxuICAgIH1cclxuICAgIFxyXG59Ki9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhVGFiczxUYWJMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhYlBhbmVsczogeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY21jLCAuLi50YWJQYW5lbHNNYW5hZ2VkQ2hpbGRyZW4gfSB9IH06IFVzZUFyaWFUYWJzUGFyYW1ldGVycyk6IFVzZUFyaWFUYWJzUmV0dXJuVHlwZVdpdGhIb29rczxUYWJMaXN0RWxlbWVudCwgVGFiRWxlbWVudCwgUGFuZWxFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcclxuXHJcbiAgICBkZWJ1Z0xvZyhcInVzZUFyaWFUYWJzXCIpO1xyXG5cclxuXHJcbiAgICBjb25zdCBiYXNlSWQgPSBnZW5lcmF0ZVJhbmRvbUlkKFwiYXJpYS10YWJzLVwiKTtcclxuICAgIC8vY29uc3QgZ2V0VGFiTGlzdElkID0gdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gYmFzZUlkICsgXCItdGFiLWxpc3RcIjsgfSwgW10pO1xyXG4gICAgY29uc3QgZ2V0VGFiSWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4geyByZXR1cm4gYmFzZUlkICsgXCItdGFiLVwiICsgaW5kZXg7IH0sIFtdKTtcclxuICAgIGNvbnN0IGdldFBhbmVsSWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4geyByZXR1cm4gYmFzZUlkICsgXCItcGFuZWwtXCIgKyBpbmRleDsgfSwgW10pO1xyXG5cclxuICAgIC8vIFVzZWQgZm9yIHRoZSBwYW5lbHMsIG5vdCB0aGUgdGFicyBpbiB0aGUgdGFibGlzdC5cclxuICAgIC8vIFRob3NlIGFyZSBpbiB1c2VBcmlhVGFiTGlzdCBpdHNlbGYuXHJcbiAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZCwgLi4ubWFuYWdlZENoaWxkcmVuUmV0IH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBUYWJQYW5lbEluZm8sIFwidmlzaWJsZVwiPih7IG1hbmFnZWRDaGlsZHJlbjogeyAuLi50YWJQYW5lbHNNYW5hZ2VkQ2hpbGRyZW4sIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25DaGlsZHJlbk1vdW50Q2hhbmdlPG51bWJlcj4+KChtLCB1KSA9PiB7IG9jbWM/LihtLCB1KTsgcmVldmFsdWF0ZUNsb3Nlc3RGaXQoKTsgfSkgfSB9KTtcclxuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXgsIGdldEN1cnJlbnRJbmRleDogZ2V0VmlzaWJsZUluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdCB9ID0gdXNlQ2hpbGRyZW5GbGFnKHsgY2hpbGRyZW46IG1hbmFnZWRDaGlsZHJlblJldC5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4sIGNsb3Nlc3RGaXQ6IGZhbHNlLCBpbml0aWFsSW5kZXg6IG51bGwsIGtleTogXCJ2aXNpYmxlXCIgfSk7XHJcblxyXG4gICAgLy9jb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQsIHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCB9ID0gdXNlUmFuZG9tSWQoeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS10YWJzLVwiIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dCwgdXNlTGFiZWxMYWJlbCB9ID0gdXNlTGFiZWw8VGFiTGlzdEVsZW1lbnQsIExhYmVsRWxlbWVudD4oeyBsYWJlbDogeyBwcmVmaXhJbnB1dDogXCJcIiwgcHJlZml4TGFiZWw6IFwiXCIsIHRhZ0lucHV0OiBcImRpdlwiIGFzIGFueSwgdGFnTGFiZWw6IFwiZGl2XCIgYXMgYW55IH0gfSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZUFyaWFUYWJMaXN0TGFiZWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUxhYmVsTGFiZWwoKTtcclxuICAgICAgICBmdW5jdGlvbiB1c2VBcmlhVGFiTGlzdExhYmVsUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pIHsgcmV0dXJuIHVzZUxhYmVsTGFiZWxQcm9wcyhwcm9wcyk7IH1cclxuICAgICAgICByZXR1cm4geyB1c2VBcmlhVGFiTGlzdExhYmVsUHJvcHMgfTtcclxuICAgIH0sIFt1c2VMYWJlbExhYmVsXSk7XHJcblxyXG4gICAgY29uc3QgdXNlQXJpYVRhYkxpc3QgPSB1c2VDYWxsYmFjazxVc2VBcmlhVGFiTGlzdDxUYWJMaXN0RWxlbWVudCwgVGFiRWxlbWVudD4+KCh7IGNoaWxkcmVuSGF2ZUZvY3VzLCB0YWJzOiB7IG9uU2VsZWN0ZWRJbmRleENoYW5nZSB9LCBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuOiB0YWJMaXN0TWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgc2luZ2xlU2VsZWN0aW9uLCB0eXBlYWhlYWROYXZpZ2F0aW9uIH0pID0+IHtcclxuICAgICAgICBkZWJ1Z0xvZyhcInVzZUFyaWFUYWJMaXN0XCIpO1xyXG4gICAgICAgIGNvbnN0IHN0YWJsZU9uU2VsZWN0ZWRJbmRleENoYW5nZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uU2VsZWN0ZWRJbmRleENoYW5nZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcclxuICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcclxuICAgICAgICAgICAgLi4ubGlzdE5hdlJldDFcclxuICAgICAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248VGFiTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkluZm8sIG5ldmVyPih7XHJcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHRhYkxpc3RNYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb24sXHJcbiAgICAgICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNoYW5nZUluZGV4KHNpbmdsZVNlbGVjdGlvbi5zZWxlY3RlZEluZGV4KTtcclxuICAgICAgICB9LCBbc2luZ2xlU2VsZWN0aW9uLnNlbGVjdGVkSW5kZXhdKTtcclxuXHJcbiAgICAgICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHMgfSA9IHVzZUxhYmVsSW5wdXQoKVxyXG5cclxuICAgICAgICBjb25zdCB1c2VBcmlhVGFiID0gdXNlQ2FsbGJhY2s8VXNlQXJpYVRhYjxUYWJFbGVtZW50Pj4oKHsgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXgsIGhhc0ZvY3VzIH06IFVzZUFyaWFUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+KTogVXNlQXJpYVRhYlJldHVyblR5cGVXaXRoSG9va3M8VGFiRWxlbWVudD4gPT4ge1xyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcInVzZUFyaWFUYWJcIiwgbWFuYWdlZENoaWxkLmluZGV4KTtcclxuICAgICAgICAgICAgY29uc3QgeyB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMsIC4uLmxpc3ROYXZSZXQyIH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkKHsgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXgsIHN1YkluZm86IHt9LCBoYXNGb2N1cyB9KTtcclxuICAgICAgICAgICAgY29uc3QgeyBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWQgfSwgcm92aW5nVGFiSW5kZXg6IHsgdGFiYmFibGUgfSB9ID0gbGlzdE5hdlJldDI7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB1c2VBcmlhVGFiUHJvcHMgPSAoeyByb2xlLCBcImFyaWEtY29udHJvbHNcIjogYXJpYUNvbnRyb2xzLCBcImFyaWEtc2VsZWN0ZWRcIjogYXJpYVNlbGVjdGVkLCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJFbGVtZW50PikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZWxJZCA9IGdldFBhbmVsSWQobWFuYWdlZENoaWxkLmluZGV4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYklkID0gZ2V0VGFiSWQobWFuYWdlZENoaWxkLmluZGV4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVzc1Byb3BzID0gdXNlUHJlc3NFdmVudEhhbmRsZXJzPFRhYkVsZW1lbnQ+KChlKSA9PiB7IHN0YWJsZU9uU2VsZWN0ZWRJbmRleENoYW5nZShlbmhhbmNlRXZlbnQoZSwgeyBzZWxlY3RlZEluZGV4OiBtYW5hZ2VkQ2hpbGQuaW5kZXggfSkpIH0sIHt9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzKHVzZU1lcmdlZFByb3BzKHtcclxuICAgICAgICAgICAgICAgICAgICByb2xlOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VBcmlhVGFiXCIsIFwicm9sZVwiLCByb2xlLCBcInRhYlwiKSxcclxuICAgICAgICAgICAgICAgICAgICBcImFyaWEtY29udHJvbHNcIjogd2Fybk9uT3ZlcndyaXRlKFwidXNlQXJpYVRhYlwiLCBcImFyaWFDb250cm9sc1wiLCBhcmlhQ29udHJvbHMsIHBhbmVsSWQpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VBcmlhVGFiXCIsIFwiYXJpYVNlbGVjdGVkXCIsIGFyaWFTZWxlY3RlZCwgc2VsZWN0ZWQgPyBcInRydWVcIiA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXRhYmJhYmxlXCI6IHRhYmJhYmxlLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRhYklkXHJcbiAgICAgICAgICAgICAgICB9IGFzIHt9LCB1c2VNZXJnZWRQcm9wcyhwcmVzc1Byb3BzLCBwcm9wcykpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVzZUFyaWFUYWJQcm9wcyxcclxuICAgICAgICAgICAgICAgIC4uLmxpc3ROYXZSZXQyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbdXNlTGFiZWxJbnB1dCwgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZF0pO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VBcmlhVGFiTGlzdFByb3BzID0gKHsgcm9sZSwgXCJhcmlhLW9yaWVudGF0aW9uXCI6IGFyaWFPcmllbnRhdGlvbiwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiTGlzdEVsZW1lbnQ+KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHVzZUxhYmVsSW5wdXRQcm9wcyh1c2VNZXJnZWRQcm9wcyh7XHJcbiAgICAgICAgICAgICAgICByb2xlOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VBcmlhVGFiTGlzdFwiLCBcInJvbGVcIiwgcm9sZSwgXCJ0YWJsaXN0XCIpLFxyXG4gICAgICAgICAgICAgICAgXCJhcmlhLW9yaWVudGF0aW9uXCI6IGFyaWFPcmllbnRhdGlvbiA/PyBcImhvcml6b250YWxcIixcclxuICAgICAgICAgICAgfSBhcyB7fSxcclxuICAgICAgICAgICAgICAgIHByb3BzKSkpXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdGFiTGlzdDogbGlzdE5hdlJldDEsXHJcbiAgICAgICAgICAgIHVzZUFyaWFUYWJMaXN0UHJvcHMsXHJcbiAgICAgICAgICAgIHVzZUFyaWFUYWJcclxuICAgICAgICB9XHJcbiAgICB9LCBbdXNlTGFiZWxJbnB1dF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUFyaWFUYWJQYW5lbCA9IHVzZUNhbGxiYWNrKCh7IG1hbmFnZWRDaGlsZDogeyBmbGFncywgLi4ubWFuYWdlZENoaWxkIH0gfTogVXNlQXJpYVRhYlBhbmVsUGFyYW1ldGVycykgPT4ge1xyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlQXJpYVRhYlBhbmVsXCIsIG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcbiAgICAgICAgLy9jb25zdCBbY29ycmVzcG9uZGluZ1RhYklkLCBzZXRDb3JyZXNwb25kaW5nVGFiSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgICAgICAgY29uc3QgW2lzVmlzaWJsZSwgc2V0SXNWaXNpYmxlLCBnZXRJc1Zpc2libGVdID0gdXNlU3RhdGUoZ2V0VmlzaWJsZUluZGV4KCkgPT0gbWFuYWdlZENoaWxkLmluZGV4KTtcclxuICAgICAgICBjb25zdCB2aXNpYmxlUmVmID0gdXNlUmVmPENoaWxkRmxhZ09wZXJhdGlvbnM+KHsgZ2V0OiBnZXRJc1Zpc2libGUsIHNldDogc2V0SXNWaXNpYmxlLCBpc1ZhbGlkOiByZXR1cm5UcnVlIH0pO1xyXG4gICAgICAgIHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyAuLi5tYW5hZ2VkQ2hpbGQsIGZsYWdzOiB7IHZpc2libGU6IHZpc2libGVSZWYuY3VycmVudCwgLi4uZmxhZ3MgfSwgc3ViSW5mbzoge30gfSB9KTtcclxuICAgICAgICBjb25zdCBwYW5lbElkID0gZ2V0UGFuZWxJZChtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IHRhYklkID0gZ2V0VGFiSWQobWFuYWdlZENoaWxkLmluZGV4KTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlQXJpYVRhYlBhbmVsUHJvcHMgPSAoeyByb2xlLCBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRCeSwgaWQsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhbmVsRWxlbWVudD4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKHtcclxuICAgICAgICAgICAgICAgIHJvbGU6IHdhcm5Pbk92ZXJ3cml0ZShcInVzZUFyaWFUYWJQYW5lbFByb3BzXCIsIFwicm9sZVwiLCByb2xlLCBcInRhYnBhbmVsXCIpLFxyXG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogd2Fybk9uT3ZlcndyaXRlKFwidXNlQXJpYVRhYlBhbmVsUHJvcHNcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIiwgYXJpYUxhYmVsbGVkQnksIHRhYklkKSxcclxuICAgICAgICAgICAgICAgIGlkOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VBcmlhVGFiUGFuZWxQcm9wc1wiLCBcImlkXCIsIGlkLCBwYW5lbElkKVxyXG4gICAgICAgICAgICB9IGFzIHt9LCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VBcmlhVGFiUGFuZWxQcm9wcyxcclxuICAgICAgICAgICAgdGFiUGFuZWw6IHtcclxuICAgICAgICAgICAgICAgIHZpc2libGU6IGlzVmlzaWJsZSxcclxuICAgICAgICAgICAgICAgIGdldFZpc2libGU6IGdldElzVmlzaWJsZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlQXJpYVRhYkxpc3RMYWJlbCxcclxuICAgICAgICB1c2VBcmlhVGFiTGlzdCxcclxuICAgICAgICB1c2VBcmlhVGFiUGFuZWwsXHJcbiAgICAgICAgdGFiUGFuZWxzOiBtYW5hZ2VkQ2hpbGRyZW5SZXRcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmludGVyZmFjZSBUYWJQYW5lbEluZm8ge1xyXG4gICAgLy9zZXRDb3JyZXNwb25kaW5nVGFiSWQodGFiSWQ6IHN0cmluZyk6IHZvaWQ7XHJcbn1cclxuXHJcbmludGVyZmFjZSBUYWJJbmZvIHtcclxuICAgIC8vc2V0Q29ycmVzcG9uZGluZ1BhbmVsSWQodGFiSWQ6IHN0cmluZyk6IHZvaWQ7XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlR2xvYmFsSGFuZGxlciwgdXNlSGFzRm9jdXMsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycywgdXNlTWVyZ2VkUHJvcHMsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlUmFuZG9tSWQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGRlYnVnTG9nIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuXHJcbmV4cG9ydCB0eXBlIFVzZVRvb2x0aXBUcmlnZ2VyPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogeyBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPFRyaWdnZXJUeXBlPiB9KSA9PiB7IHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHM6ICh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+IH07XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbHRpcFBhcmFtZXRlcnMgeyBtb3VzZW92ZXJEZWxheT86IG51bWJlciwgbW91c2VvdXREZWxheT86IG51bWJlciwgZm9jdXNEZWxheT86IG51bWJlciB9XHJcbmV4cG9ydCB0eXBlIFVzZVRvb2x0aXA8VHJpZ2dlclR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQsIFRvb2x0aXBUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlVG9vbHRpcFBhcmFtZXRlcnMpID0+IFVzZVRvb2x0aXBSZXR1cm5UeXBlV2l0aEhvb2tzPFRyaWdnZXJUeXBlLCBUb29sdGlwVHlwZT47XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbHRpcFJldHVyblR5cGVJbmZvIHtcclxuICAgIGlzT3BlbjogYm9vbGVhbjtcclxuICAgIGdldElzT3BlbjogKCkgPT4gYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sdGlwUmV0dXJuVHlwZVdpdGhIb29rczxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQsIFRvb2x0aXBUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlVG9vbHRpcDogKGFyZ3M6IHsgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxUb29sdGlwVHlwZT4gfSkgPT4ge1xyXG4gICAgICAgIHVzZVRvb2x0aXBQcm9wczogKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VG9vbHRpcFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUb29sdGlwVHlwZT47XHJcbiAgICB9O1xyXG4gICAgdXNlVG9vbHRpcFRyaWdnZXI6IFVzZVRvb2x0aXBUcmlnZ2VyPFRyaWdnZXJUeXBlPjtcclxufVxyXG5cclxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFUb29sdGlwPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudCwgVG9vbHRpcFR5cGUgZXh0ZW5kcyBFbGVtZW50Pih7IG1vdXNlb3ZlckRlbGF5LCBtb3VzZW91dERlbGF5LCBmb2N1c0RlbGF5IH06IFVzZVRvb2x0aXBQYXJhbWV0ZXJzKTogVXNlVG9vbHRpcFJldHVyblR5cGVXaXRoSG9va3M8VHJpZ2dlclR5cGUsIFRvb2x0aXBUeXBlPiB7XHJcbiAgICBkZWJ1Z0xvZyhcInVzZUFyaWFUb29sdGlwXCIpO1xyXG5cclxuICAgIG1vdXNlb3ZlckRlbGF5ID8/PSA0MDA7XHJcbiAgICBtb3VzZW91dERlbGF5ID8/PSA0MDtcclxuICAgIGZvY3VzRGVsYXkgPz89IDE7XHJcblxyXG4gICAgLy8gVGhlIGVzY2FwZSBrZXkgc2hvdWxkIGNsb3NlIHRvb2x0aXBzLCBidXQgZG8gbm90aGluZyBlbHNlLlxyXG4gICAgLy8gKGkuZS4gY2xvc2luZyBhIHRvb2x0aXAgaW4gYSBkaWFsb2cgTVVTVCBOT1QgY2xvc2UgdGhlIGRpYWxvZyB0b28pXHJcbiAgICAvLyBUT0RPOiBUb29sdGlwcyBhcmUsIGVmZmVjdGl2ZWx5LCBhbHdheXMgdGhlIHRvcG1vc3QgY29tcG9uZW50LFxyXG4gICAgLy8gc28gd2UgY2FuIGp1c3QgaGF2ZSB0aGVtIGxpc3RlbiB0byBhbmQgc3dhbGxvdyBhbGwgXCJFc2NhcGVcIlxyXG4gICAgLy8ga2V5IHByZXNzZXMgYmVmb3JlIGFueW9uZSBlbHNlLiBGb3IgYSBtb3JlIGdlbmVyYWwgcG9wdXAsXHJcbiAgICAvLyBvciBhIHRvb2x0aXAgaW4gYSB0b29sdGlwICghISkgYSBkaWZmZXJlbnQgc29sdXRpb24gd291bGQgYmUgbmVlZGVkLlxyXG4gICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJrZXlkb3duXCIsIChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKGdldE9wZW4oKSAmJiBlLmtleSA9PT0gXCJFc2NhcGVcIiAmJiAhZS5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgc2V0T3BlbihmYWxzZSk7XHJcbiAgICAgICAgICAgIHNldFRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkKGZhbHNlKTtcclxuICAgICAgICAgICAgc2V0VG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZhbHNlKTtcclxuICAgICAgICAgICAgc2V0VG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZChmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xyXG5cclxuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuLCBnZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50LC8vOiB1c2VUb29sdGlwSWRQcm9wcywgXHJcbiAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCwvLzogdXNlVG9vbHRpcElkUmVmZXJlbmNpbmdQcm9wcyBcclxuICAgIH0gPSB1c2VSYW5kb21JZDxUb29sdGlwVHlwZT4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS10b29sdGlwLVwiIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xyXG5cclxuICAgIGNvbnN0IFssIHNldFRyaWdnZXJGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gZm9jdXNlZCA/IGZvY3VzRGVsYXkgOiAxO1xyXG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHNldFRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZm9jdXNlZCksIGZvY3VzZWQgPyBmb2N1c0RlbGF5IDogMSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9KSwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgWywgc2V0VG9vbHRpcEZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlKHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGVsYXkgPSBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDE7XHJcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgJiYgaXNGaW5pdGUoZGVsYXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gc2V0VG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZChmb2N1c2VkKSwgZGVsYXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSksIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFssIHNldFRyaWdnZXJIb3Zlcl0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGhvdmVyaW5nOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGVsYXkgPSBob3ZlcmluZyA/IG1vdXNlb3ZlckRlbGF5IDogbW91c2VvdXREZWxheTtcclxuICAgICAgICBpZiAoZGVsYXkgIT0gbnVsbCAmJiBpc0Zpbml0ZShkZWxheSkpIHtcclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUcmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZChob3ZlcmluZyksIGRlbGF5KTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBbLCBzZXRUb29sdGlwSG92ZXJdID0gdXNlUGFzc2l2ZVN0YXRlKHVzZVN0YWJsZUNhbGxiYWNrKChob3ZlcmluZzogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gaG92ZXJpbmcgPyBtb3VzZW92ZXJEZWxheSA6IG1vdXNlb3V0RGVsYXk7XHJcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgJiYgaXNGaW5pdGUoZGVsYXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gc2V0VG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQoaG92ZXJpbmcpLCBkZWxheSk7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICB9KSwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgW3RyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQsIHNldFRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW3RyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkLCBzZXRUcmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCwgc2V0VG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbdG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQsIHNldFRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHNldE9wZW4odHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCB8fCB0cmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZCB8fCB0b29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkIHx8IHRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkKTtcclxuICAgIH0sIFt0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIHx8IHRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkIHx8IHRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWRdKVxyXG5cclxuICAgIGNvbnN0IHVzZVRvb2x0aXBUcmlnZ2VyOiBVc2VUb29sdGlwVHJpZ2dlcjxUcmlnZ2VyVHlwZT4gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VUb29sdGlwVHJpZ2dlcih7IGhhc0ZvY3VzOiB7IG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgLi4uaGFzRm9jdXMgfSB9OiB7IGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VHJpZ2dlclR5cGU+IH0pIHtcclxuICAgICAgICBkZWJ1Z0xvZyhcInVzZUFyaWFUb29sdGlwVHJpZ2dlclwiKTtcclxuXHJcbiAgICAgICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJwb2ludGVybW92ZVwiLCBlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcclxuICAgICAgICAgICAgc2V0VHJpZ2dlckhvdmVyKHRhcmdldCA9PSBnZXRFbGVtZW50KCkgYXMgTm9kZSB8fCAhIWdldEVsZW1lbnQoKT8uY29udGFpbnModGFyZ2V0KSk7XHJcbiAgICAgICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBvblRvdWNoRW5kKGU6IFRvdWNoRXZlbnQpIHtcclxuICAgICAgICAgICAgKGUudGFyZ2V0IGFzIGFueSkuZm9jdXMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlSGFzRm9jdXM8VHJpZ2dlclR5cGU+KHtcclxuICAgICAgICAgICAgLi4uaGFzRm9jdXMsXHJcbiAgICAgICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZm9jdXNlZCwgcHJldik7IHNldFRyaWdnZXJGb2N1c2VkKGZvY3VzZWQpIH0pXHJcbiAgICAgICAgfSlcclxuXHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHMoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDxUcmlnZ2VyVHlwZT4oXCJhcmlhLWRlc2NyaWJlZGJ5XCIgYXMgbmV2ZXIpO1xyXG4gICAgICAgICAgICAvLyBOb3RlOiBUaG91Z2ggaXQncyBpbXBvcnRhbnQgdG8gbWFrZSBzdXJlIHRoYXQgZm9jdXNpbmcgYWN0aXZhdGVzIGEgdG9vbHRpcCxcclxuICAgICAgICAgICAgLy8gaXQncyBwZXJmZWN0bHkgcmVhc29uYWJsZSB0aGF0IGEgY2hpbGQgZWxlbWVudCB3aWxsIGJlIHRoZSBvbmUgdGhhdCdzIGZvY3VzZWQsXHJcbiAgICAgICAgICAgIC8vIG5vdCB0aGlzIG9uZSwgc28gd2UgZG9uJ3Qgc2V0IHRhYkluZGV4PTBcclxuICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPz89IC0xO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKFxyXG4gICAgICAgICAgICAgICAgdXNlSGFzRm9jdXNQcm9wcyhcclxuICAgICAgICAgICAgICAgICAgICB1c2VNZXJnZWRQcm9wczxUcmlnZ2VyVHlwZT4oeyBvblRvdWNoRW5kIH0sIChwcm9wcyBhcyBhbnkpIGFzIHVua25vd24gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+KVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyB9O1xyXG5cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCB1c2VUb29sdGlwID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVG9vbHRpcCh7IGhhc0ZvY3VzOiB7IG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgLi4uaGFzRm9jdXMgfSB9OiB7IGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VG9vbHRpcFR5cGU+IH0pIHtcclxuICAgICAgICBkZWJ1Z0xvZyhcInVzZUFyaWFUb29sdGlwVG9vbHRpcFwiKTtcclxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzIH0gPSB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQoKTtcclxuICAgICAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUhhc0ZvY3VzPFRvb2x0aXBUeXBlPih7IG9uRm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZm9jdXNlZCwgcHJldik7IHNldFRvb2x0aXBGb2N1c2VkKGZvY3VzZWQpOyB9KSwgLi4uaGFzRm9jdXMgfSlcclxuXHJcbiAgICAgICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJwb2ludGVybW92ZVwiLCBlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcclxuICAgICAgICAgICAgc2V0VG9vbHRpcEhvdmVyKHRhcmdldCA9PSBnZXRFbGVtZW50KCkgYXMgTm9kZSB8fCAhIWdldEVsZW1lbnQoKT8uY29udGFpbnModGFyZ2V0KSk7XHJcbiAgICAgICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB1c2VUb29sdGlwUHJvcHMoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxUb29sdGlwVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUb29sdGlwVHlwZT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHModXNlSGFzRm9jdXNQcm9wcyh1c2VNZXJnZWRQcm9wczxUb29sdGlwVHlwZT4oe30sIHByb3BzKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlVG9vbHRpcFByb3BzIH07XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VUb29sdGlwLFxyXG4gICAgICAgIHVzZVRvb2x0aXBUcmlnZ2VyLFxyXG4gICAgICAgIGlzT3Blbjogb3BlbixcclxuICAgICAgICBnZXRJc09wZW46IGdldE9wZW5cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvLCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgVXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtaGFzLWZvY3VzXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBkZWJ1Z0xvZywgRWxlbWVudFRvVGFnLCBFbmhhbmNlZEV2ZW50LCBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsLCBUYWdTZW5zaXRpdmVQcm9wcyB9IGZyb20gXCIuL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZUNoZWNrYm94TGlrZSwgdXNlTGFiZWwgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcclxuXHJcbi8vdHlwZSBPbWl0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFBpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj47XHJcbmV4cG9ydCB0eXBlIFJhZGlvQ2hhbmdlRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBWIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nPiA9IEVuaGFuY2VkRXZlbnQ8RSwgRXZlbnQsIHsgc2VsZWN0ZWRWYWx1ZTogViB9PjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7XHJcbiAgICByYWRpb0dyb3VwOiB7XHJcbiAgICAgICAgbmFtZTogc3RyaW5nO1xyXG5cclxuICAgICAgICBzZWxlY3RlZFZhbHVlOiBWIHwgbnVsbDtcclxuICAgICAgICBvbklucHV0KGV2ZW50OiBSYWRpb0NoYW5nZUV2ZW50PElucHV0RWxlbWVudCwgVj4pOiB2b2lkO1xyXG4gICAgICAgIC8vb25JbnB1dChldmVudDogUmFkaW9DaGFuZ2VFdmVudDxoLkpTWC5UYXJnZXRlZEV2ZW50PExhYmVsRWxlbWVudD4sIFY+KTogdm9pZDtcclxuICAgICAgICB0YWdHcm91cDogRWxlbWVudFRvVGFnPEdyb3VwRWxlbWVudD47XHJcbiAgICAgICAgdGFnR3JvdXBMYWJlbDogRWxlbWVudFRvVGFnPEdyb3VwTGFiZWxFbGVtZW50PjtcclxuICAgIH1cclxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnNbXCJjaGlsZHJlbkhhdmVGb2N1c1wiXTtcclxufVxyXG5cclxuLypleHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFSYWRpb0luZm9CYXNlIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZEluZm9CYXNlPFwidGFiYmFibGVcIiB8IFwic2VsZWN0ZWRcIj4ge1xyXG4gICAgc2V0Q2hlY2tlZChjaGVja2VkOiBib29sZWFuKTogdm9pZDtcclxuICAgIGdldENoZWNrZWQoKTogYm9vbGVhbiB8IG51bGw7XHJcbn0qL1xyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhUmFkaW9QYXJhbWV0ZXJzPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEkgZXh0ZW5kcyBFbGVtZW50LCBJTCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxJLCB7fSwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiwgXCJzdWJJbmZvXCI+IHtcclxuICAgIHJhZGlvOiB7XHJcbiAgICAgICAgbGFiZWxQb3NpdGlvbjogXCJ3cmFwcGluZ1wiIHwgXCJzZXBhcmF0ZVwiO1xyXG4gICAgICAgIHZhbHVlOiBWO1xyXG4gICAgICAgIGRpc2FibGVkOiBib29sZWFuO1xyXG4gICAgICAgIHRhZ0lucHV0OiBFbGVtZW50VG9UYWc8ST47XHJcbiAgICAgICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxJTD47XHJcbiAgICB9XHJcbiAgICBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEk+O1xyXG4gICAgLypPbWl0PFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgSUw+LCBcIm9uSW5wdXRcIiB8IFwicm9sZVwiIHwgXCJjaGVja2VkXCI+ICYge1xyXG4gICAgICAgIGluZm86IE9taXQ8SW5mbywgXCJzZXRDaGVja2VkXCIgfCBcImdldENoZWNrZWRcIiB8IFwiYmx1clNlbGZcIiB8IFwiZ2V0RWxlbWVudFwiIHwgXCJmb2N1c1NlbGZcIj47XHJcbiAgICAgICAgXHJcbiAgICB9Ki9cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhUmFkaW9Hcm91cFJldHVyblR5cGVJbmZvPEkgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88SSwge30sIG5ldmVyPiB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFSYWRpb0dyb3VwUmV0dXJuVHlwZVdpdGhIb29rczxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHIGV4dGVuZHMgRWxlbWVudCwgR0wgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgRWxlbWVudCwgSUwgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhUmFkaW9Hcm91cFJldHVyblR5cGVJbmZvPEk+IHtcclxuICAgIHVzZVJhZGlvR3JvdXBMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdMPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R0w+O1xyXG4gICAgdXNlUmFkaW9Hcm91cFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEc+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHPjtcclxuICAgIHVzZVJhZGlvOiBVc2VSYWRpbzxWLCBJLCBJTD47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBcmlhUmFkaW9Hcm91cDxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHIGV4dGVuZHMgRWxlbWVudCwgR0wgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgRWxlbWVudCwgSUwgZXh0ZW5kcyBIVE1MRWxlbWVudD4oe1xyXG4gICAgbGluZWFyTmF2aWdhdGlvbixcclxuICAgIGxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgcmFkaW9Hcm91cDogeyBuYW1lLCBvbklucHV0LCBzZWxlY3RlZFZhbHVlLCB0YWdHcm91cCwgdGFnR3JvdXBMYWJlbCB9LFxyXG4gICAgcm92aW5nVGFiSW5kZXgsXHJcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uLFxyXG4gICAgY2hpbGRyZW5IYXZlRm9jdXNcclxufTogVXNlQXJpYVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEcsIEdMLCBJLCBJTD4pOiBVc2VBcmlhUmFkaW9Hcm91cFJldHVyblR5cGVXaXRoSG9va3M8ViwgRywgR0wsIEksIElMPiB7XHJcbiAgICBkZWJ1Z0xvZyhcInVzZUFyaWFSYWRpb0dyb3VwXCIsIHNlbGVjdGVkVmFsdWUpO1xyXG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBfZ2V0UmFkaW9Hcm91cFBhcmVudEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxHPih7fSk7XHJcblxyXG4gICAgLy9jb25zdCBnZXRTZWxlY3RlZEluZGV4ID0gdXNlQ2FsbGJhY2soKHNlbGVjdGVkVmFsdWU6IFYpID0+IHsgcmV0dXJuIGJ5TmFtZS5jdXJyZW50LmdldChzZWxlY3RlZFZhbHVlKSA/PyAwIH0sIFtdKVxyXG5cclxuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KDApO1xyXG4gICAgY29uc3QgYnlOYW1lID0gdXNlUmVmKG5ldyBNYXA8ViwgYW55PigpKTtcclxuICAgIGNvbnN0IHN0YWJsZU9uSW5wdXQgPSB1c2VTdGFibGVDYWxsYmFjayhvbklucHV0KTtcclxuXHJcbiAgICAvL2NvbnN0IFthbnlSYWRpb3NGb2N1c2VkLCBzZXRBbnlSYWRpb3NGb2N1c2VkLCBnZXRBbnlSYWRpb3NGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXQ6IHVzZUdyb3VwTGFiZWxJbnB1dCwgdXNlTGFiZWxMYWJlbDogdXNlR3JvdXBMYWJlbExhYmVsIH0gPSB1c2VMYWJlbDxHLCBHTD4oeyBsYWJlbDogeyBwcmVmaXhMYWJlbDogXCJhcmlhLXJhZGlvLWdyb3VwLWxhYmVsLVwiLCB0YWdJbnB1dDogdGFnR3JvdXAgYXMgbmV2ZXIsIHRhZ0xhYmVsOiB0YWdHcm91cExhYmVsIGFzIG5ldmVyLCBwcmVmaXhJbnB1dDogXCJhcmlhLXJhZGlvLWdyb3VwLVwiIH0gfSlcclxuICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dFByb3BzOiB1c2VHcm91cExhYmVsSW5wdXRQcm9wcyB9ID0gdXNlR3JvdXBMYWJlbElucHV0KCk7XHJcbiAgICBjb25zdCB7IHVzZUxhYmVsTGFiZWxQcm9wczogdXNlR3JvdXBMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUdyb3VwTGFiZWxMYWJlbCgpO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXHJcbiAgICAgICAgLi4ubGlzdE5hdlJldFxyXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPEcsIEksIHt9LCBuZXZlcj4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb24sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4IH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbixcclxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVHJhY2sgd2hldGhlciB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHRoZSByYWRpbyBncm91cCBwYXJlbnQgZWxlbWVudC5cclxuICAgIC8vIFdoZW4gaXQncyBub3QsIHdlIHJlc2V0IHRoZSB0YWJiYWJsZSBpbmRleCBiYWNrIHRvIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZWxlbWVudC5cclxuICAgIC8vY29uc3QgeyB1c2VBY3RpdmVFbGVtZW50UHJvcHMgfSA9IHVzZUFjdGl2ZUVsZW1lbnQ8Rz4oeyBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChhY3RpdmVFbGVtZW50OiBOb2RlIHwgbnVsbCkgPT4gc2V0QW55UmFkaW9zRm9jdXNlZCghIShnZXRSYWRpb0dyb3VwUGFyZW50RWxlbWVudCgpPy5jb250YWlucyhhY3RpdmVFbGVtZW50KSkpLCBbXSkgfSk7XHJcbiAgICAvKnVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFhbnlSYWRpb3NGb2N1c2VkKVxyXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoc2VsZWN0ZWRJbmRleCA/PyAwKTtcclxuICAgIH0sIFthbnlSYWRpb3NGb2N1c2VkLCBzZWxlY3RlZEluZGV4LCBuYXZpZ2F0ZVRvSW5kZXhdKTsqL1xyXG5cclxuXHJcbiAgICBjb25zdCB1c2VSYWRpb0dyb3VwUHJvcHMgPSB1c2VDYWxsYmFjaygoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxHPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEc+ID0+IHtcclxuICAgICAgICBwcm9wcy5yb2xlID0gXCJyYWRpb2dyb3VwXCI7XHJcbiAgICAgICAgcmV0dXJuIHVzZUdyb3VwTGFiZWxJbnB1dFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHModXNlUmVmRWxlbWVudFByb3BzKHByb3BzKSkpO1xyXG4gICAgfSwgW3VzZVJlZkVsZW1lbnRQcm9wc10pXHJcblxyXG4gICAgY29uc3QgdXNlUmFkaW9Hcm91cExhYmVsUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdMPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdMPiA9PiB7IHJldHVybiB1c2VHcm91cExhYmVsTGFiZWxQcm9wcyhwcm9wcyk7IH0sIFt1c2VHcm91cExhYmVsTGFiZWxQcm9wc10pO1xyXG5cclxuICAgIC8vY29uc3QgY29ycmVjdGVkSW5kZXggPSAoc2VsZWN0ZWRJbmRleCA9PSBudWxsIHx8IHNlbGVjdGVkSW5kZXggPCAwIHx8IHNlbGVjdGVkSW5kZXggPj0gbWFuYWdlZENoaWxkcmVuLmxlbmd0aCkgPyBudWxsIDogc2VsZWN0ZWRJbmRleDtcclxuICAgIC8qY29uc3QgeyBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSA9IHVzZUNoaWxkcmVuRmxhZyh7XHJcbiAgICAgICAgaW5pdGlhbEluZGV4OiAwLFxyXG4gICAgICAgIGNoaWxkcmVuLFxyXG4gICAgICAgIGtleTogXCJzZWxlY3RlZFwiXHJcbiAgICAgICAgLy9zZXRDaGlsZEZsYWc6IChpLCBjaGVja2VkKSA9PiBtYW5hZ2VkQ2hpbGRyZW5baV0/LnNldENoZWNrZWQoY2hlY2tlZCksXHJcbiAgICAgICAgLy9nZXRDaGlsZEZsYWc6ICgoaSkgPT4gbWFuYWdlZENoaWxkcmVuW2ldPy5nZXRDaGVja2VkKCkgPz8gZmFsc2UpXHJcbiAgICB9KTsqL1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4KG51bGwpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gYnlOYW1lLmN1cnJlbnQuZ2V0KHNlbGVjdGVkVmFsdWUpO1xyXG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4KHNlbGVjdGVkSW5kZXggPz8gbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2J5TmFtZSwgc2VsZWN0ZWRWYWx1ZV0pO1xyXG5cclxuXHJcblxyXG4gICAgY29uc3QgdXNlUmFkaW8gPSB1c2VDYWxsYmFjazxVc2VSYWRpbzxWLCBJLCBJTD4+KGZ1bmN0aW9uIHVzZUFyaWFSYWRpbyh7XHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb24sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIGhhc0ZvY3VzLFxyXG4gICAgICAgIHJhZGlvOiB7IGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIHZhbHVlIH1cclxuICAgIH0pIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IG1hbmFnZWRDaGlsZC5pbmRleDtcclxuICAgICAgICBkZWJ1Z0xvZyhcInVzZUFyaWFSYWRpb1wiLCBpbmRleCk7XHJcbiAgICAgICAgLy9jb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZCwgZ2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZTxib29sZWFuIHwgbnVsbD4obnVsbCk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9uSW5wdXQgPSB1c2VDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxJPikgPT4ge1xyXG4gICAgICAgICAgICBzdGFibGVPbklucHV0KGVuaGFuY2VFdmVudChlLCB7IHNlbGVjdGVkVmFsdWU6IHZhbHVlIH0pKTtcclxuICAgICAgICB9LCBbc3RhYmxlT25JbnB1dCwgdmFsdWUsIGluZGV4XSk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcywgLi4ubGlzdE5hdlJldCB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCh7XHJcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkLFxyXG4gICAgICAgICAgICBoYXNGb2N1cyxcclxuICAgICAgICAgICAgc3ViSW5mbzoge31cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgeyBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWQ6IGNoZWNrZWQgfSB9ID0gbGlzdE5hdlJldDtcclxuXHJcbiAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCB9ID0gdXNlQ2hlY2tib3hMaWtlPEksIElMPih7XHJcbiAgICAgICAgICAgIGNoZWNrYm94TGlrZToge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tlZDogKGNoZWNrZWQgPz8gZmFsc2UpLFxyXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIGRpc2FibGVkLFxyXG4gICAgICAgICAgICAgICAgb25JbnB1dCxcclxuICAgICAgICAgICAgICAgIHJvbGU6IFwicmFkaW9cIlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICAgICAgdGFnSW5wdXQ6IHRhZ0lucHV0IGFzIG5ldmVyLFxyXG4gICAgICAgICAgICAgICAgdGFnTGFiZWw6IHRhZ0xhYmVsIGFzIG5ldmVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGJ5TmFtZS5jdXJyZW50LnNldCh2YWx1ZSwgaW5kZXgpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4geyBieU5hbWUuY3VycmVudC5kZWxldGUodmFsdWUpOyB9XHJcbiAgICAgICAgfSwgW2J5TmFtZSwgdmFsdWUsIGluZGV4XSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZVJhZGlvSW5wdXQ6IFVzZVJhZGlvSW5wdXQ8ST4gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRhZ0lucHV0O1xyXG4gICAgICAgICAgICBjb25zdCB1c2VSYWRpb0lucHV0UHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST4gPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PSBcImlucHV0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jaGVja2VkID0gKGNoZWNrZWQgPz8gZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnR5cGUgPSBcInJhZGlvXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtY2hlY2tlZFwiXSA9IChjaGVja2VkID8/IGZhbHNlKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzSWZJbnB1dEhhbmRsZXNGb2N1cyA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcyhwcm9wcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHVzZU1lcmdlZFByb3BzPEk+KCh1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyh7fSkpLCBsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIiA/IHByb3BzSWZJbnB1dEhhbmRsZXNGb2N1cyA6IHByb3BzKSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdXNlUmFkaW9JbnB1dFByb3BzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCB1c2VSYWRpb0xhYmVsOiBVc2VSYWRpb0xhYmVsPElMPiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgLy9jb25zdCB0YWcgPSB0YWdMYWJlbDtcclxuICAgICAgICAgICAgY29uc3QgdXNlUmFkaW9MYWJlbFByb3BzID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJTD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJTD4gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc0lmTGFiZWxIYW5kbGVzRm9jdXMgPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMocHJvcHMgYXMgYW55KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyh1c2VNZXJnZWRQcm9wczxJTD4oe30gYXMgYW55LCBsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIiA/IHByb3BzSWZMYWJlbEhhbmRsZXNGb2N1cyBhcyBhbnkgOiBwcm9wcyBhcyBhbnkpKVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVzZVJhZGlvTGFiZWxQcm9wc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW3VzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudF0pO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VSYWRpb0lucHV0LFxyXG4gICAgICAgICAgICB1c2VSYWRpb0xhYmVsLFxyXG4gICAgICAgICAgICAuLi5saXN0TmF2UmV0XHJcbiAgICAgICAgICAgIC8vY2hlY2tlZDogY2hlY2tlZCA/PyBmYWxzZSxcclxuICAgICAgICAgICAgLy90YWJiYWJsZTogdGFiYmFibGUgPz8gZmFsc2VcclxuICAgICAgICB9XHJcblxyXG4gICAgfSwgW2J5TmFtZSwgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZF0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlUmFkaW8sXHJcbiAgICAgICAgdXNlUmFkaW9Hcm91cFByb3BzLFxyXG4gICAgICAgIHVzZVJhZGlvR3JvdXBMYWJlbFByb3BzLFxyXG4gICAgICAgIC4uLmxpc3ROYXZSZXRcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb1JldHVyblR5cGVJbmZvPEkgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxJPiB7IH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFkaW9SZXR1cm5UeXBlV2l0aEhvb2tzPEkgZXh0ZW5kcyBFbGVtZW50LCBMIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSYWRpb1JldHVyblR5cGVJbmZvPEk+IHtcclxuICAgIHVzZVJhZGlvSW5wdXQ6IFVzZVJhZGlvSW5wdXQ8ST47XHJcbiAgICB1c2VSYWRpb0xhYmVsOiBVc2VSYWRpb0xhYmVsPEw+O1xyXG59XHJcblxyXG50eXBlIFVzZVJhZGlvSW5wdXQ8SSBleHRlbmRzIEVsZW1lbnQ+ID0gKHsgdGFnIH06IFRhZ1NlbnNpdGl2ZVByb3BzPEk+KSA9PiB7IHVzZVJhZGlvSW5wdXRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST47IH1cclxudHlwZSBVc2VSYWRpb0xhYmVsPEwgZXh0ZW5kcyBFbGVtZW50PiA9ICh7IHRhZyB9OiBUYWdTZW5zaXRpdmVQcm9wczxMPikgPT4geyB1c2VSYWRpb0xhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEw+OyB9XHJcblxyXG5leHBvcnQgdHlwZSBVc2VSYWRpbzxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQ+ID0gKGE6IFVzZUFyaWFSYWRpb1BhcmFtZXRlcnM8ViwgSSwgTD4pID0+IFVzZVJhZGlvUmV0dXJuVHlwZVdpdGhIb29rczxJLCBMPlxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBNYW5hZ2VkQ2hpbGRyZW4sIHJldHVybk51bGwsIHVzZUdyaWROYXZpZ2F0aW9uLCBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycywgdXNlTGF5b3V0RWZmZWN0LCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm8sIHVzZVBhc3NpdmVTdGF0ZSwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvLCB1c2VTb3J0YWJsZUNoaWxkcmVuLCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVJbmZvLCBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm8gfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtZ3JpZC1uYXZpZ2F0aW9uXCI7XHJcbmltcG9ydCB7IENvbXBhcmUsIEdldEluZGV4LCBHZXRWYWx1ZSwgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXNvcnRhYmxlLWNoaWxkcmVuXCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGRlYnVnTG9nIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuXHJcbmV4cG9ydCB0eXBlIFRhYmxlVmFsdWVUeXBlID0gc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IGJvb2xlYW4gfCBEYXRlO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVCb2R5UGFyYW1ldGVycyB7IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgVXNlQXJpYVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4sIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIHt9PiwgXCJzdWJJbmZvXCI+IHtcclxuICAgIHRhYmxlUm93OiBQaWNrPFVzZUFyaWFUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBcImxvY2F0aW9uXCI+O1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIFVzZUFyaWFUYWJsZUNlbGxTdWJJbmZvLCBuZXZlciwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwgVXNlQXJpYVRhYmxlQ2VsbFN1YkluZm8+IHtcclxuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICBsb2NhdGlvbjogXCJoZWFkXCIgfCBcImJvZHlcIiB8IFwiZm9vdFwiO1xyXG4gICAgZ2V0Q2VsbHMoKTogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENlbGxFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlQXJpYVRhYmxlQ2VsbFN1YkluZm8+PiwgXCJ0YWJiYWJsZVwiPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVDZWxsU3ViSW5mbyB7XHJcbiAgICBsb2NhdGlvbjogXCJoZWFkXCIgfCBcImJvZHlcIiB8IFwiZm9vdFwiO1xyXG4gICAgdmFsdWU6IFRhYmxlVmFsdWVUeXBlO1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFUYWJsZUNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+IHsgdGFibGVIZWFkZXJDZWxsOiB7IHNvcnQoKTogdm9pZCB9IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVSb3dSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFVzZUFyaWFUYWJsZUNlbGxTdWJJbmZvLCBuZXZlcj4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXJpYVRhYmxlQm9keVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxSb3dFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlQXJpYVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4+PiwgbmV2ZXIsIFtdPiB7IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgVXNlQXJpYVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4sIG5ldmVyPiB7IH1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFyaWFUYWJsZUNlbGxSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VBcmlhVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+IHsgdXNlVGFibGVDZWxsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD47IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVSb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHsgdXNlVGFibGVDZWxsOiBVc2VBcmlhVGFibGVDZWxsPENlbGxFbGVtZW50PjsgdXNlVGFibGVSb3dQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD47IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVCb2R5UmV0dXJuVHlwZVdpdGhIb29rczxCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFyaWFUYWJsZUJvZHlSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4geyB1c2VUYWJsZUJvZHlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBcmlhVGFibGVSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQXJpYVRhYmxlUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHtcclxuICAgIHVzZVRhYmxlUm93OiBVc2VBcmlhVGFibGVSb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+O1xyXG4gICAgdXNlVGFibGVCb2R5OiBVc2VBcmlhVGFibGVCb2R5PEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+O1xyXG4gICAgdXNlVGFibGVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VBcmlhVGFibGVDZWxsPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAocDogVXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+KSA9PiBVc2VBcmlhVGFibGVDZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsRWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZUFyaWFUYWJsZVJvdzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChwOiBVc2VBcmlhVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PikgPT4gVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZUFyaWFUYWJsZUJvZHk8Qm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAocDogVXNlQXJpYVRhYmxlQm9keVBhcmFtZXRlcnMpID0+IFVzZUFyaWFUYWJsZUJvZHlSZXR1cm5UeXBlV2l0aEhvb2tzPEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFyaWFUYWJsZTxcclxuICAgIFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXHJcbiAgICBCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxyXG4gICAgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXHJcbiAgICBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnRcclxuPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCB0eXBlYWhlYWROYXZpZ2F0aW9uIH06IFVzZUFyaWFUYWJsZVBhcmFtZXRlcnMpOiBVc2VBcmlhVGFibGVSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYmxlRWxlbWVudCwgQm9keVNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4ge1xyXG4gICAgZGVidWdMb2coXCJ1c2VBcmlhVGFibGVcIik7XHJcblxyXG4gICAgY29uc3QgW2dldEN1cnJlbnRTb3J0Q29sdW1uLCBzZXRDdXJyZW50U29ydENvbHVtbl0gPSB1c2VQYXNzaXZlU3RhdGU8eyBpbmRleDogbnVtYmVyLCBkaXJlY3Rpb246IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIiB9IHwgbnVsbD4obnVsbCwgcmV0dXJuTnVsbCk7XHJcbiAgICBjb25zdCBib2R5U29ydCA9IHVzZVJlZjxudWxsIHwgKCgpID0+IHZvaWQpPihudWxsKTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Qcm9wcyxcclxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvdyxcclxuICAgICAgICAuLi5ncmlkTmF2UmV0MVxyXG4gICAgfSA9IHVzZUdyaWROYXZpZ2F0aW9uPFRhYmxlRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFVzZUFyaWFUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBVc2VBcmlhVGFibGVDZWxsU3ViSW5mbywgbmV2ZXIsIG5ldmVyPih7XHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbixcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbixcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXgsXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW46IHJvd3MgfSB9ID0gZ3JpZE5hdlJldDE7XHJcblxyXG4gICAgY29uc3QgdXNlVGFibGVSb3cgPSB1c2VDYWxsYmFjazxVc2VBcmlhVGFibGVSb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+PigoeyBhc0NoaWxkUm93T2ZTZWN0aW9uLCBhc1BhcmVudFJvd09mQ2VsbHMsIHRhYmxlUm93OiB7IGxvY2F0aW9uIH0gfTogVXNlQXJpYVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4pOiBVc2VBcmlhVGFibGVSb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiA9PiB7XHJcbiAgICAgICAgZGVidWdMb2coXCJ1c2VBcmlhVGFibGVSb3dcIiwgYXNDaGlsZFJvd09mU2VjdGlvbi5tYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG5cclxuICAgICAgICBjb25zdCBnZXRDZWxscyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNlbGxzO1xyXG4gICAgICAgIH0sIFtdKVxyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCxcclxuICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyxcclxuICAgICAgICAgICAgLi4uZ3JpZE5hdlJldDJcclxuICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25Sb3coeyBhc0NoaWxkUm93T2ZTZWN0aW9uOiB7IC4uLmFzQ2hpbGRSb3dPZlNlY3Rpb24sIHN1YkluZm86IHsgZ2V0Q2VsbHMsIGxvY2F0aW9uIH0gfSwgYXNQYXJlbnRSb3dPZkNlbGxzIH0pO1xyXG5cclxuICAgICAgICBjb25zdCB7IGFzUGFyZW50T2ZDZWxsczogeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW46IGNlbGxzIH0gfSB9ID0gZ3JpZE5hdlJldDI7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZVRhYmxlQ2VsbCA9IHVzZUNhbGxiYWNrPFVzZUFyaWFUYWJsZUNlbGw8Q2VsbEVsZW1lbnQ+PigoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgc3ViSW5mbywgaGFzRm9jdXMgfSkgPT4ge1xyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcInVzZUFyaWFUYWJsZUNlbGxcIiwgbWFuYWdlZENoaWxkLmluZGV4KTtcclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMsXHJcbiAgICAgICAgICAgICAgICAuLi5ncmlkTmF2UmV0M1xyXG4gICAgICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25DZWxsKHsgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXgsIHN1YkluZm8sIGhhc0ZvY3VzIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc29ydCA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRJbmZvID0gZ2V0Q3VycmVudFNvcnRDb2x1bW4oKSA/PyB7IGluZGV4OiAtMSwgZGlyZWN0aW9uOiAnYXNjZW5kaW5nJyB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbEluZGV4ID0gbWFuYWdlZENoaWxkLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNvcnRJbmZvLmluZGV4ICE9IGNlbGxJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0SW5mby5kaXJlY3Rpb25bMF0gPT0gJ2EnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0SW5mby5kaXJlY3Rpb24gPSAnZGVzY2VuZGluZyc7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0SW5mby5kaXJlY3Rpb24gPSAnYXNjZW5kaW5nJztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzb3J0SW5mby5pbmRleCA9IG1hbmFnZWRDaGlsZC5pbmRleDtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRTb3J0Q29sdW1uKHNvcnRJbmZvKTtcclxuXHJcbiAgICAgICAgICAgICAgICBib2R5U29ydC5jdXJyZW50ISgpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVzZVRhYmxlQ2VsbFByb3BzOiB0eXBlb2YgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMgPSAocHJvcHMpID0+IHByb3BzO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdGFibGVIZWFkZXJDZWxsOiB7IHNvcnQgfSxcclxuICAgICAgICAgICAgICAgIHVzZVRhYmxlQ2VsbFByb3BzLFxyXG4gICAgICAgICAgICAgICAgLi4uZ3JpZE5hdlJldDNcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LCBbXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZVRhYmxlUm93UHJvcHM6IHR5cGVvZiB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzID0gKHByb3BzKSA9PiBwcm9wcztcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlVGFibGVDZWxsLFxyXG4gICAgICAgICAgICB1c2VUYWJsZVJvd1Byb3BzLFxyXG4gICAgICAgICAgICAuLi5ncmlkTmF2UmV0MlxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCB1c2VUYWJsZUJvZHkgPSB1c2VDYWxsYmFjazxVc2VBcmlhVGFibGVCb2R5PEJvZHlTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+PigoKSA9PiB7XHJcbiAgICAgICAgZGVidWdMb2coXCJ1c2VBcmlhVGFibGVCb2R5XCIpO1xyXG4gICAgICAgIHR5cGUgQyA9IFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxSb3dFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlQXJpYVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4+PjtcclxuICAgICAgICB0eXBlIFYgPSB7IGxvY2F0aW9uOiBcImhlYWRcIiB8IFwiYm9keVwiIHwgXCJmb290XCIsIHZhbHVlOiBUYWJsZVZhbHVlVHlwZSB9O1xyXG4gICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlQ2FsbGJhY2s8R2V0SW5kZXg8QywgbmV2ZXI+PigoaSkgPT4gaS5pbmRleCwgW10pO1xyXG4gICAgICAgIGNvbnN0IGdldFZhbHVlID0gdXNlQ2FsbGJhY2s8R2V0VmFsdWU8QywgbmV2ZXIsIFtdLCBWPj4oKGkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VsbHMgPSBpLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmdldENlbGxzKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjZWxscy5nZXRBdChnZXRDdXJyZW50U29ydENvbHVtbigpPy5pbmRleCA/PyAwKTtcclxuICAgICAgICAgICAgcmV0dXJuICh7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogY2VsbD8uc3ViSW5mby5zdWJJbmZvLnN1YkluZm8ubG9jYXRpb24gPz8gXCJoZWFkXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2VsbD8uc3ViSW5mby5zdWJJbmZvLnN1YkluZm8udmFsdWUgPz8gLTFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuIGNlbGxzLmdldEF0KGdldEN1cnJlbnRTb3J0Q29sdW1uKCk/LmluZGV4ID8/IDApPy5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby52YWx1ZSA/PyBudWxsO1xyXG4gICAgICAgIH0sIFtdKTtcclxuXHJcbiAgICAgICAgY29uc3QgY29tcGFyZTogQ29tcGFyZTxWPiA9IChsaHMsIHJocykgPT4ge1xyXG4gICAgICAgICAgICBpZiAobGhzLmxvY2F0aW9uID09PSByaHMubG9jYXRpb24pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKyhsaHMudmFsdWUgPz8gLUluZmluaXR5KSAtICsocmhzLnZhbHVlID8/IC1JbmZpbml0eSk7XHJcbiAgICAgICAgICAgIGlmIChsaHMubG9jYXRpb24gPT0gJ2hlYWQnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICBpZiAobGhzLmxvY2F0aW9uID09ICdib2R5JylcclxuICAgICAgICAgICAgICAgIHJldHVybiByaHMubG9jYXRpb24gPT0gJ2hlYWQnID8gLTEgOiAxO1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcclxuICAgICAgICAgICAgLi4uc29ydGFibGVSZXRcclxuICAgICAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxCb2R5U2VjdGlvbkVsZW1lbnQsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxSb3dFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlQXJpYVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4+PiwgbmV2ZXIsIFtdLCBWPih7XHJcbiAgICAgICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjoge1xyXG4gICAgICAgICAgICAgICAgZ2V0SW5kZXhcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc29ydGFibGVDaGlsZHJlbjoge1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZSxcclxuICAgICAgICAgICAgICAgIGdldFZhbHVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgeyBzb3J0YWJsZUNoaWxkcmVuOiB7IHNvcnQgfSB9ID0gc29ydGFibGVSZXQ7XHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgYm9keVNvcnQuY3VycmVudCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNvcnQocm93cywgZ2V0Q3VycmVudFNvcnRDb2x1bW4oKT8uZGlyZWN0aW9uID8/ICdhc2NlbmRpbmcnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LCBbc29ydF0pXHJcblxyXG4gICAgICAgIGNvbnN0IHVzZVRhYmxlQm9keVByb3BzID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHByb3BzLmNoaWxkcmVuICE9IG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlU29ydGFibGVQcm9wcyhwcm9wcyBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+ICYgeyBjaGlsZHJlbjogYW55IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlVGFibGVCb2R5UHJvcHMsXHJcbiAgICAgICAgICAgIC4uLnNvcnRhYmxlUmV0XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IHVzZVRhYmxlUHJvcHM6IHR5cGVvZiB1c2VHcmlkTmF2aWdhdGlvblByb3BzID0gdXNlR3JpZE5hdmlnYXRpb25Qcm9wcztcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVRhYmxlUHJvcHMsXHJcbiAgICAgICAgdXNlVGFibGVCb2R5LFxyXG4gICAgICAgIHVzZVRhYmxlUm93LFxyXG4gICAgICAgIC4uLmdyaWROYXZSZXQxXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwicHJvcHNcIjtcclxuaW1wb3J0IHsgVXNlQXJpYUJ1dHRvblBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vdXNlLWJ1dHRvblwiO1xyXG5pbXBvcnQgeyB1c2VBcmlhQWNjb3JkaW9uLCBVc2VBcmlhQWNjb3JkaW9uUGFyYW1ldGVycywgVXNlQXJpYUFjY29yZGlvblJldHVyblR5cGVJbmZvLCBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvbiwgVXNlQXJpYUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzLCBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS1hY2NvcmRpb25cIjtcclxuaW1wb3J0IHsgSGVhZGluZyB9IGZyb20gXCIuL2hlYWRpbmdcIjtcclxuXHJcbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFyaWFBY2NvcmRpb25Qcm9wcyBleHRlbmRzXHJcbiAgICBHZXQ8VXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMsIFwiYWNjb3JkaW9uXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFBY2NvcmRpb25QYXJhbWV0ZXJzLCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYUFjY29yZGlvblBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkcmVuXCI+IHtcclxuICAgIGV4cGFuZGVkSW5kZXg/OiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xyXG4gICAgcmVuZGVyKGluZm86IFVzZUFyaWFBY2NvcmRpb25SZXR1cm5UeXBlSW5mbyk6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQXJpYUFjY29yZGlvblNlY3Rpb25Qcm9wczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlQXJpYUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+LCBcImFjY29yZGlvblNlY3Rpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZHJlblwiPixcclxuICAgIFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PixcclxuICAgIEdldDxVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyRWxlbWVudD4sIFwiYnV0dG9uXCI+IHtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvLCBtYWtlSGVhZGVyUHJvcHM6IFByb3BNb2RpZmllcjxIZWFkZXJFbGVtZW50PiwgbWFrZUJvZHlQcm9wczogUHJvcE1vZGlmaWVyPEJvZHlFbGVtZW50Pik6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcblxyXG5jb25zdCBBY2NvcmRpb25TZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQXJpYUFjY29yZGlvblNlY3Rpb248YW55LCBhbnk+PihudWxsISk7XHJcbmV4cG9ydCBmdW5jdGlvbiBBcmlhQWNjb3JkaW9uKHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBleHBhbmRlZEluZGV4LCBpbml0aWFsSW5kZXgsIG5hdmlnYXRpb25EaXJlY3Rpb24sIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlLCByZW5kZXIgfTogQXJpYUFjY29yZGlvblByb3BzKSB7XHJcbiAgICBjb25zdCB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uLCAuLi5wcm92aWRlciB9ID0gdXNlQXJpYUFjY29yZGlvbih7XHJcbiAgICAgICAgYWNjb3JkaW9uOiB7IGluaXRpYWxJbmRleCB9LFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7IHByb3ZpZGVyLmFjY29yZGlvbi5jaGFuZ2VFeHBhbmRlZEluZGV4KGV4cGFuZGVkSW5kZXghID8/IG51bGwpOyB9LCBbZXhwYW5kZWRJbmRleF0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEFjY29yZGlvblNlY3Rpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbn0+e3JlbmRlcihwcm92aWRlcil9PC9BY2NvcmRpb25TZWN0aW9uQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBtYWtlUHJvcHNIZWFkaW5nLCBtYWtlUHJvcHNCb2R5LCB0YWdCb2R5LCB0YWdIZWFkaW5nIH06IHsgdGFnSGVhZGluZzogRWxlbWVudFRvVGFnPEhlYWRlckVsZW1lbnQ+OyB0YWdCb2R5OiBFbGVtZW50VG9UYWc8Qm9keUVsZW1lbnQ+OyBtYWtlUHJvcHNIZWFkaW5nKGluZm86IFVzZUFyaWFBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZUluZm8pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PiwgbWFrZVByb3BzQm9keShpbmZvOiBVc2VBcmlhQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlQXJpYUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbywgbW9kaWZ5SGVhZGluZ1Byb3BzOiBQcm9wTW9kaWZpZXI8SGVhZGVyRWxlbWVudD4sIG1vZGlmeUJvZHlQcm9wczogUHJvcE1vZGlmaWVyPEJvZHlFbGVtZW50Pik6IFZOb2RlPGFueT4ge1xyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgYWNjb3JkaW9uU2VjdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgZm9jdXNlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSA9IGluZm87XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9e2NyZWF0ZUVsZW1lbnQodGFnSGVhZGluZyBhcyBuZXZlciwgbW9kaWZ5SGVhZGluZ1Byb3BzKHsgLi4ubWFrZVByb3BzSGVhZGluZyhpbmZvKSB9KSl9PlxyXG4gICAgICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ0JvZHkgYXMgbmV2ZXIsIG1vZGlmeUJvZHlQcm9wcyhtYWtlUHJvcHNCb2R5KGluZm8pKSl9XHJcbiAgICAgICAgICAgICAgICA8L0hlYWRpbmc+XHJcbiAgICAgICAgICAgIDwvPlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEFyaWFBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcclxuICAgIG9wZW4sXHJcbiAgICBpbmRleCxcclxuICAgIHRhZ0J1dHRvbixcclxuICAgIGRpc2FibGVkLFxyXG4gICAgcmVuZGVyLFxyXG4gICAgZ2V0RG9jdW1lbnQsXHJcbiAgICBnZXRXaW5kb3csXHJcbiAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsXHJcbiAgICBvbkVsZW1lbnRDaGFuZ2UsXHJcbiAgICBvbkZvY3VzZWRDaGFuZ2VkLFxyXG4gICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLFxyXG4gICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSxcclxuICAgIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLFxyXG4gICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCxcclxuICAgIG9uTW91bnQsXHJcbiAgICBvblVubW91bnQsXHJcbiAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2VcclxufTogQXJpYUFjY29yZGlvblNlY3Rpb25Qcm9wczxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uID0gdXNlQ29udGV4dChBY2NvcmRpb25TZWN0aW9uQ29udGV4dCk7XHJcbiAgICBjb25zdCB7IHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzLCB1c2VBcmlhQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzLCAuLi5zZWN0aW9uSW5mbyB9ID0gdXNlQXJpYUFjY29yZGlvblNlY3Rpb24oe1xyXG4gICAgICAgIGJ1dHRvbjogeyBkaXNhYmxlZCB9LFxyXG4gICAgICAgIGFjY29yZGlvblNlY3Rpb246IHsgb3BlbiwgdGFnQnV0dG9uIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IGluZGV4IH0sXHJcbiAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZW5kZXIoc2VjdGlvbkluZm8sIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHMsIHVzZUFyaWFBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzKTtcclxufVxyXG5cclxuXHJcbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBQcm9wTW9kaWZpZXIgfSBmcm9tIFwicHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQXJpYUJ1dHRvbiwgVXNlQXJpYUJ1dHRvblBhcmFtZXRlcnMgfSBmcm9tIFwiLi4vdXNlLWJ1dHRvblwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBcmlhQnV0dG9uUHJvcHM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiBleHRlbmRzIFVzZUFyaWFCdXR0b25QYXJhbWV0ZXJzPEU+IHtcclxuICAgIHJlbmRlcihidXR0b246IFByb3BNb2RpZmllcjxFPik6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyQnV0dG9uKHRhZzogc3RyaW5nLCBtYWtlQnV0dG9uUHJvcHM6IChpbmZvOiB7fSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2RpZnlCdXR0b25Qcm9wczogUHJvcE1vZGlmaWVyPGFueT4pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWcgYXMgYW55LCBtb2RpZnlCdXR0b25Qcm9wcyhtYWtlQnV0dG9uUHJvcHMoe30pKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBBcmlhQnV0dG9uPEUgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZywgb25QcmVzcywgcHJlc3NlZCwgcmVuZGVyLCBkaXNhYmxlZCB9OiBBcmlhQnV0dG9uUHJvcHM8RT4pIHtcclxuICAgIGNvbnN0IHsgdXNlQXJpYUJ1dHRvblByb3BzIH0gPSB1c2VBcmlhQnV0dG9uPEU+KHsgdGFnLCBvblByZXNzLCBwcmVzc2VkLCBkaXNhYmxlZCB9KTtcclxuICAgIHJldHVybiByZW5kZXIodXNlQXJpYUJ1dHRvblByb3BzKTtcclxufSIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlLCBDb21wb25lbnRDaGlsZHJlbiB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwicHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQXJpYUNoZWNrYm94LCBVc2VBcmlhQ2hlY2tib3hQYXJhbWV0ZXJzLCBVc2VBcmlhQ2hlY2tib3hSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtY2hlY2tib3hcIjtcclxuXHJcbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFyaWFDaGVja2JveFByb3BzPEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxJLCBMPiwgXCJjaGVja2JveExpa2VcIj4sXHJcbiAgICBHZXQ8VXNlQXJpYUNoZWNrYm94UGFyYW1ldGVyczxJLCBMPiwgXCJjaGVja2JveFwiPixcclxuICAgIEdldDxVc2VBcmlhQ2hlY2tib3hQYXJhbWV0ZXJzPEksIEw+LCBcImxhYmVsXCI+IHtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VBcmlhQ2hlY2tib3hSZXR1cm5UeXBlSW5mbzxJLCBMPiwgbW9kaWZ5SW5wdXRQcm9wczogUHJvcE1vZGlmaWVyPEk+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TD4pOiBWTm9kZTxhbnk+O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZTxJIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEwgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSW5mb1R5cGU+KHsgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsLCBtYWtlSW5wdXRQcm9wcywgbWFrZUxhYmVsUHJvcHMgfTogRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgTCwgSW5mb1R5cGU+KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IEluZm9UeXBlLCBtb2RpZnlJbnB1dFByb3BzOiBQcm9wTW9kaWZpZXI8ST4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxMPik6IFZOb2RlPGFueT4ge1xyXG5cclxuICAgICAgICBpZiAobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5wdXQgPSBjcmVhdGVFbGVtZW50KHRhZ0lucHV0IGFzIG5ldmVyLCBtb2RpZnlJbnB1dFByb3BzKG1ha2VJbnB1dFByb3BzKGluZm8pKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLmxhYmVsUHJvcHMgfSA9IG1ha2VMYWJlbFByb3BzKGluZm8pO1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwgYXMgbmV2ZXIsIG1vZGlmeUxhYmVsUHJvcHMoeyAuLi5sYWJlbFByb3BzLCBjaGlsZHJlbjogPD57aW5wdXR9e2NoaWxkcmVufTwvPiB9KSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgICAgICB7bGFiZWx9XHJcbiAgICAgICAgICAgICAgICA8Lz5cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIikge1xyXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNyZWF0ZUVsZW1lbnQodGFnSW5wdXQgYXMgbmV2ZXIsIG1vZGlmeUlucHV0UHJvcHMobWFrZUlucHV0UHJvcHMoaW5mbykpKTtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KHRhZ0xhYmVsIGFzIG5ldmVyLCBtb2RpZnlMYWJlbFByb3BzKG1ha2VMYWJlbFByb3BzKGluZm8pKSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgICAgICB7aW5wdXR9XHJcbiAgICAgICAgICAgICAgICAgICAge2xhYmVsfVxyXG4gICAgICAgICAgICAgICAgPC8+XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9wcyA9IG1ha2VJbnB1dFByb3BzKGluZm8pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCghIXVzZXJQcm9wc1tcImFyaWEtbGFiZWxcIl0pO1xyXG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdJbnB1dCBhcyBuZXZlciwgbW9kaWZ5SW5wdXRQcm9wcyh1c2VyUHJvcHMpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSBleHRlbmRzIEhUTUxFbGVtZW50LCBMIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEluZm9UeXBlPiB7IFxyXG4gICAgbGFiZWxQb3NpdGlvbjogXCJ3cmFwcGluZ1wiIHwgXCJzZXBhcmF0ZVwiIHwgXCJoaWRkZW5cIiwgXHJcbiAgICB0YWdJbnB1dDogRWxlbWVudFRvVGFnPEk+LCBcclxuICAgIHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TD4sIFxyXG4gICAgbWFrZUlucHV0UHJvcHM6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST4sIFxyXG4gICAgbWFrZUxhYmVsUHJvcHM6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TD4gXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdFJlbmRlckNoZWNrYm94UGFyYW1ldGVyczxJIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEwgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJLCBMLCBVc2VBcmlhQ2hlY2tib3hSZXR1cm5UeXBlSW5mbzxJLCBMPj4geyB9XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNoZWNrYm94PEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZUlucHV0UHJvcHMsIG1ha2VMYWJlbFByb3BzIH06IERlZmF1bHRSZW5kZXJDaGVja2JveFBhcmFtZXRlcnM8SSwgTD4pIHtcclxuICAgIHJldHVybiBkZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlPEksIEwsIFVzZUFyaWFDaGVja2JveFJldHVyblR5cGVJbmZvPEksIEw+Pih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZUlucHV0UHJvcHMsIG1ha2VMYWJlbFByb3BzIH0pO1xyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBBcmlhQ2hlY2tib3g8SSBleHRlbmRzIEhUTUxFbGVtZW50LCBMIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgY2hlY2tlZCwgZGlzYWJsZWQsIHRhZ0xhYmVsLCBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgb25JbnB1dCwgcmVuZGVyIH06IEFyaWFDaGVja2JveFByb3BzPEksIEw+KSB7XHJcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50LCB1c2VDaGVja2JveExhYmVsRWxlbWVudCwgLi4uY2hlY2tib3hJbmZvIH0gPSB1c2VBcmlhQ2hlY2tib3goeyBjaGVja2JveDogeyBvbklucHV0IH0sIGNoZWNrYm94TGlrZTogeyBjaGVja2VkLCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiB9LCBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSB9KTtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKTtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoKTtcclxuXHJcblxyXG4gICAgcmV0dXJuIHJlbmRlcihjaGVja2JveEluZm8sIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMsIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMpO1xyXG59XHJcbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0LCBoLCBSZW5kZXJhYmxlUHJvcHMsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VDaGVja2JveEdyb3VwLCBVc2VDaGVja2JveEdyb3VwQ2hpbGQsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvLCBVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVycywgVXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtY2hlY2tib3gtZ3JvdXBcIjtcclxuaW1wb3J0IHsgZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSwgRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnMgfSBmcm9tIFwiLi9jaGVja2JveFwiO1xyXG5cclxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcclxudHlwZSBHZXQyPFQsIEsgZXh0ZW5kcyBrZXlvZiBULCBLMiBleHRlbmRzIGtleW9mIFRbS10+ID0gVFtLXVtLMl07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94R3JvdXBQcm9wczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBSZW5kZXJhYmxlUHJvcHM8e30+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkcmVuXCI+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImNoZWNrYm94XCI+LFxyXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJjaGVja2JveExpa2VcIj4sXHJcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImxhYmVsXCI+IHtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBtb2RpZnlJbnB1dFByb3BzOiBQcm9wTW9kaWZpZXI8SW5wdXRFbGVtZW50PiwgbGFiZWw6IFByb3BNb2RpZmllcjxMYWJlbEVsZW1lbnQ+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwQ2hlY2tib3hQcm9wczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQyPFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBcImFzQ2hlY2tib3hcIiwgXCJjaGVja2JveFwiPixcclxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveFwiLCBcImxhYmVsXCI+LFxyXG4gICAgR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgXCJhc0NoZWNrYm94XCIsIFwiY2hlY2tib3hMaWtlXCI+LFxyXG4gICAgR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgXCJhc0NoZWNrYm94R3JvdXBDaGlsZFwiLCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgXCJhc0NoZWNrYm94R3JvdXBDaGlsZFwiLCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgXCJhc0NoZWNrYm94R3JvdXBDaGlsZFwiLCBcIm1hbmFnZWRDaGlsZFwiPiB7XHJcbiAgICByZW5kZXIoaW5mbzogVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBtb2RpZnlJbnB1dFByb3BzOiBQcm9wTW9kaWZpZXI8SW5wdXRUeXBlPiwgbGFiZWw6IFByb3BNb2RpZmllcjxMYWJlbFR5cGU+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IGV4dGVuZHMgRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGUsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvPElucHV0VHlwZSwgTGFiZWxUeXBlPj4geyB9XHJcbmV4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzPElucHV0VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZSwgVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVJbmZvPElucHV0VHlwZSwgTGFiZWxUeXBlPj4ge1xyXG4gICAgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgdGFnSW5wdXQsIHRhZ0xhYmVsLCBsYWJlbFBvc2l0aW9uLCBtYWtlSW5wdXRQcm9wcywgbWFrZUxhYmVsUHJvcHMgfTogRGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgbW9kaWZ5SW5wdXRQcm9wczogUHJvcE1vZGlmaWVyPElucHV0VHlwZT4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxMYWJlbFR5cGU+KTogVk5vZGU8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJDaGVja2JveExpa2UoeyBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcyB9KShpbmZvLCBtb2RpZnlJbnB1dFByb3BzLCBtb2RpZnlMYWJlbFByb3BzKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwPElucHV0VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBjaGlsZHJlbiwgbGFiZWxQb3NpdGlvbiwgbWFrZUlucHV0UHJvcHMsIG1ha2VMYWJlbFByb3BzLCB0YWdJbnB1dCwgdGFnTGFiZWwgfTogRGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZUluZm88YW55LCBhbnk+LCBtb2RpZnlJbnB1dFByb3BzOiBQcm9wTW9kaWZpZXI8SW5wdXRUeXBlPiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsVHlwZT4pOiBWTm9kZTxhbnk+IHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAge2RlZmF1bHRSZW5kZXJDaGVja2JveExpa2UoeyBsYWJlbFBvc2l0aW9uLCBtYWtlSW5wdXRQcm9wcywgbWFrZUxhYmVsUHJvcHMsIHRhZ0lucHV0LCB0YWdMYWJlbCB9KShpbmZvLCBtb2RpZnlJbnB1dFByb3BzLCBtb2RpZnlMYWJlbFByb3BzKX1cclxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgPC8+XHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBVc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VDaGVja2JveEdyb3VwQ2hpbGQ8YW55LCBhbnk+PihudWxsISk7XHJcbmV4cG9ydCBmdW5jdGlvbiBDaGVja2JveEdyb3VwPElucHV0VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oe1xyXG4gICAgZGlzYWJsZWQ6IHBhcmVudERpc2FibGVkLFxyXG4gICAgdGFnSW5wdXQsXHJcbiAgICB0YWdMYWJlbCxcclxuICAgIHJlbmRlcixcclxuICAgIGxhYmVsUG9zaXRpb24sXHJcbiAgICBpbml0aWFsSW5kZXgsXHJcbiAgICBjb2xsYXRvcixcclxuICAgIGRpc2FibGVBcnJvd0tleXMsXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxyXG4gICAgbm9UeXBlYWhlYWQsXHJcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxyXG4gICAgaW5kZXhEZW1hbmdsZXIsXHJcbiAgICBpbmRleE1hbmdsZXIsXHJcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXHJcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlUmVuZGVyXHJcbn06IENoZWNrYm94R3JvdXBQcm9wczxJbnB1dFR5cGUsIExhYmVsVHlwZT4pIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGQsXHJcbiAgICAgICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0LFxyXG4gICAgICAgIC4uLmNoZWNrYm94R3JvdXBQYXJlbnRJbmZvXHJcbiAgICB9ID0gdXNlQ2hlY2tib3hHcm91cDxJbnB1dFR5cGUsIExhYmVsVHlwZT4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0UHJvcHMsIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRMYWJlbFByb3BzIH0gPSB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXQoeyBjaGVja2JveDoge30sIGNoZWNrYm94TGlrZTogeyBkaXNhYmxlZDogcGFyZW50RGlzYWJsZWQsIGxhYmVsUG9zaXRpb24gfSwgbGFiZWw6IHsgdGFnSW5wdXQsIHRhZ0xhYmVsIH0gfSk7XHJcblxyXG5cclxuICAgIGxldCB3cmFwcGluZzogVk5vZGU8YW55PjtcclxuICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIikge1xyXG4gICAgICAgIHdyYXBwaW5nID0gcmVuZGVyKGNoZWNrYm94R3JvdXBQYXJlbnRJbmZvLCB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcywgdXNlQ2hlY2tib3hHcm91cFBhcmVudExhYmVsUHJvcHMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgd3JhcHBpbmcgPSByZW5kZXIoY2hlY2tib3hHcm91cFBhcmVudEluZm8sIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzLCB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8VXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlQ2hlY2tib3hHcm91cENoaWxkfT57d3JhcHBpbmd9PC9Vc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ2hlY2tib3hHcm91cENoZWNrYm94PElucHV0VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oe1xyXG4gICAgY2hlY2tlZCxcclxuICAgIGRpc2FibGVkLFxyXG4gICAgaW5kZXgsXHJcbiAgICBsYWJlbFBvc2l0aW9uLFxyXG4gICAgdGFnSW5wdXQsXHJcbiAgICB0YWdMYWJlbCxcclxuICAgIHRleHQsXHJcbiAgICBibHVyU2VsZixcclxuICAgIGZsYWdzLFxyXG4gICAgZm9jdXNTZWxmLFxyXG4gICAgaGlkZGVuLFxyXG4gICAgb25JbnB1dCxcclxuICAgIHJlbmRlclxyXG59OiBDaGVja2JveEdyb3VwQ2hlY2tib3hQcm9wczxJbnB1dFR5cGUsIExhYmVsVHlwZT4pIHtcclxuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hHcm91cENoaWxkSW5wdXRQcm9wcywgdXNlQ2hlY2tib3hHcm91cENoaWxkTGFiZWxQcm9wcywgLi4uY2hlY2tib3hHcm91cENoaWxkSW5mbyB9ID0gdXNlQ29udGV4dChVc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0KSh7XHJcbiAgICAgICAgYXNDaGVja2JveDoge1xyXG4gICAgICAgICAgICBjaGVja2JveDogeyBvbklucHV0IH0sXHJcbiAgICAgICAgICAgIGNoZWNrYm94TGlrZTogeyBjaGVja2VkLCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiB9LFxyXG4gICAgICAgICAgICBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXNDaGVja2JveEdyb3VwQ2hpbGQ6IHtcclxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgICAgIHRleHRcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgIGZsYWdzXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XHJcbiAgICAgICAgICAgICAgICBibHVyU2VsZixcclxuICAgICAgICAgICAgICAgIGZvY3VzU2VsZixcclxuICAgICAgICAgICAgICAgIGhpZGRlblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcihjaGVja2JveEdyb3VwQ2hpbGRJbmZvLCB1c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzLCB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByZW5kZXIoY2hlY2tib3hHcm91cENoaWxkSW5mbywgdXNlQ2hlY2tib3hHcm91cENoaWxkSW5wdXRQcm9wcywgdXNlQ2hlY2tib3hHcm91cENoaWxkTGFiZWxQcm9wcyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VBcmlhRGlhbG9nLCBVc2VBcmlhRGlhbG9nUGFyYW1ldGVycywgVXNlRGlhbG9nUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLWRpYWxvZ1wiO1xyXG5cclxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGlhbG9nUHJvcHM8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlQXJpYURpYWxvZ1BhcmFtZXRlcnMsIFwic29mdERpc21pc3NcIj4sXHJcbiAgICBHZXQ8VXNlQXJpYURpYWxvZ1BhcmFtZXRlcnMsIFwibW9kYWxcIj4sXHJcbiAgICBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycyxcclxuICAgIEdldDxVc2VBcmlhRGlhbG9nUGFyYW1ldGVycywgXCJkaWFsb2dcIj4ge1xyXG5cclxuICAgIHJlbmRlcihkaWFsb2dJbmZvOiBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbywgbW9kaWZ5Rm9jdXNDb250YWluZXJQcm9wczogUHJvcE1vZGlmaWVyPEZvY3VzQ29udGFpbmVyRWxlbWVudD4sIG1vZGlmeURpYWxvZ1Byb3BzOiBQcm9wTW9kaWZpZXI8RGlhbG9nRWxlbWVudD4sIG1vZGlmeVRpdGxlUHJvcHM6IFByb3BNb2RpZmllcjxUaXRsZUVsZW1lbnQ+LCBtb2RpZnlCb2R5UHJvcHM6IFByb3BNb2RpZmllcjxCb2R5RWxlbWVudD4sIG1vZGlmeUJhY2tkcm9wUHJvcHM6IFByb3BNb2RpZmllcjxCYWNrZHJvcEVsZW1lbnQ+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJQb3J0YWwoeyBwb3J0YWxJZCwgY2hpbGRyZW4gfTogeyBwb3J0YWxJZDogc3RyaW5nLCBjaGlsZHJlbjogVk5vZGUgfSkge1xyXG4gICAgY29uc3QgcG9ydGFsUmVmID0gdXNlUmVmPEhUTUxFbGVtZW50PihudWxsISk7XHJcbiAgICBwb3J0YWxSZWYuY3VycmVudCA/Pz0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocG9ydGFsSWQpITtcclxuICAgIGlmIChwb3J0YWxSZWYuY3VycmVudClcclxuICAgICAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBwb3J0YWxSZWYuY3VycmVudCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlck1vZGFsPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBEaWFsb2dFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSW5mb1R5cGU+KHsgcG9ydGFsSWQsIHRhZ0ZvY3VzQ29udGFpbmVyLCB0YWdCYWNrZHJvcCwgdGFnQm9keSwgdGFnRGlhbG9nLCB0YWdUaXRsZSwgbWFrZVByb3BzRm9jdXNDb250YWluZXIsIG1ha2VQcm9wc0JhY2tkcm9wLCBtYWtlUHJvcHNCb2R5LCBtYWtlUHJvcHNEaWFsb2csIG1ha2VQcm9wc1RpdGxlIH06IHsgcG9ydGFsSWQ6IHN0cmluZywgdGFnRm9jdXNDb250YWluZXI6IEVsZW1lbnRUb1RhZzxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCB0YWdEaWFsb2c6IEVsZW1lbnRUb1RhZzxEaWFsb2dFbGVtZW50PjsgdGFnVGl0bGU6IEVsZW1lbnRUb1RhZzxUaXRsZUVsZW1lbnQ+OyB0YWdCb2R5OiBFbGVtZW50VG9UYWc8Qm9keUVsZW1lbnQ+OyB0YWdCYWNrZHJvcDogRWxlbWVudFRvVGFnPEJhY2tkcm9wRWxlbWVudD4sIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyOiAoaW5mbzogSW5mb1R5cGUpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD4sIG1ha2VQcm9wc0RpYWxvZzogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxEaWFsb2dFbGVtZW50PiwgbWFrZVByb3BzQm9keTogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4sIG1ha2VQcm9wc1RpdGxlOiAoaW5mbzogSW5mb1R5cGUpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD4sIG1ha2VQcm9wc0JhY2tkcm9wOiAoaW5mbzogSW5mb1R5cGUpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkaWFsb2dJbmZvOiBJbmZvVHlwZSwgbW9kaWZ5Rm9jdXNDb250YWluZXJQcm9wczogUHJvcE1vZGlmaWVyPEZvY3VzQ29udGFpbmVyRWxlbWVudD4sIG1vZGlmeURpYWxvZ1Byb3BzOiBQcm9wTW9kaWZpZXI8RGlhbG9nRWxlbWVudD4sIG1vZGlmeVRpdGxlUHJvcHM6IFByb3BNb2RpZmllcjxUaXRsZUVsZW1lbnQ+LCBtb2RpZnlCb2R5UHJvcHM6IFByb3BNb2RpZmllcjxCb2R5RWxlbWVudD4sIG1vZGlmeUJhY2tkcm9wUHJvcHM6IFByb3BNb2RpZmllcjxCYWNrZHJvcEVsZW1lbnQ+KTogVk5vZGU8YW55PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IHRpdGxlQ2hpbGRyZW4sIC4uLnRpdGxlUHJvcHMgfSA9IG1vZGlmeVRpdGxlUHJvcHMobWFrZVByb3BzVGl0bGUoZGlhbG9nSW5mbykpO1xyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IGJvZHlDaGlsZHJlbiwgLi4uYm9keVByb3BzIH0gPSBtb2RpZnlCb2R5UHJvcHMobWFrZVByb3BzQm9keShkaWFsb2dJbmZvKSk7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogZGlhbG9nQ2hpbGRyZW4sIC4uLmRpYWxvZ1Byb3BzIH0gPSBtb2RpZnlEaWFsb2dQcm9wcyhtYWtlUHJvcHNEaWFsb2coZGlhbG9nSW5mbykpO1xyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IGJhY2tkcm9wQ2hpbGRyZW4sIC4uLmJhY2tkcm9wUHJvcHMgfSA9IG1vZGlmeUJhY2tkcm9wUHJvcHMobWFrZVByb3BzQmFja2Ryb3AoZGlhbG9nSW5mbykpO1xyXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IGZvY3VzQ29udGFpbmVyQ2hpbGRyZW4sIC4uLmZvY3VzQ29udGFpbmVyUHJvcHMgfSA9IG1vZGlmeUZvY3VzQ29udGFpbmVyUHJvcHMobWFrZVByb3BzRm9jdXNDb250YWluZXIoZGlhbG9nSW5mbykpO1xyXG5cclxuICAgICAgICBjb25zdCB0aXRsZSA9IGNyZWF0ZUVsZW1lbnQodGFnVGl0bGUgYXMgbmV2ZXIsIHRpdGxlUHJvcHMsIHRpdGxlQ2hpbGRyZW4pO1xyXG4gICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVFbGVtZW50KHRhZ0JvZHkgYXMgbmV2ZXIsIGJvZHlQcm9wcywgYm9keUNoaWxkcmVuKTtcclxuICAgICAgICBjb25zdCBkaWFsb2cgPSBjcmVhdGVFbGVtZW50KHRhZ0RpYWxvZyBhcyBuZXZlciwgeyAuLi5kaWFsb2dQcm9wcywgY2hpbGRyZW46IDw+e2RpYWxvZ0NoaWxkcmVufXt0aXRsZX17Ym9keX08Lz4gfSk7XHJcbiAgICAgICAgY29uc3QgYmFja2Ryb3AgPSBjcmVhdGVFbGVtZW50KHRhZ0JhY2tkcm9wIGFzIG5ldmVyLCBiYWNrZHJvcFByb3BzLCBiYWNrZHJvcENoaWxkcmVuKTtcclxuICAgICAgICBjb25zdCBmb2N1c0NvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQodGFnRm9jdXNDb250YWluZXIgYXMgbmV2ZXIsIGZvY3VzQ29udGFpbmVyUHJvcHMsIDw+e2ZvY3VzQ29udGFpbmVyQ2hpbGRyZW59e2RpYWxvZ317YmFja2Ryb3B9PC8+KVxyXG4gICAgICAgIHJldHVybiBkZWZhdWx0UmVuZGVyUG9ydGFsKHtcclxuICAgICAgICAgICAgcG9ydGFsSWQsXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBmb2N1c0NvbnRhaW5lclxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyRGlhbG9nPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBEaWFsb2dFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBwb3J0YWxJZCwgdGFnRm9jdXNDb250YWluZXIsIHRhZ0JhY2tkcm9wLCB0YWdCb2R5LCB0YWdEaWFsb2csIHRhZ1RpdGxlLCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lciwgbWFrZVByb3BzQmFja2Ryb3AsIG1ha2VQcm9wc0JvZHksIG1ha2VQcm9wc0RpYWxvZywgbWFrZVByb3BzVGl0bGUgfTogeyBwb3J0YWxJZDogc3RyaW5nLCB0YWdGb2N1c0NvbnRhaW5lcjogRWxlbWVudFRvVGFnPEZvY3VzQ29udGFpbmVyRWxlbWVudD4sIHRhZ0RpYWxvZzogRWxlbWVudFRvVGFnPERpYWxvZ0VsZW1lbnQ+OyB0YWdUaXRsZTogRWxlbWVudFRvVGFnPFRpdGxlRWxlbWVudD47IHRhZ0JvZHk6IEVsZW1lbnRUb1RhZzxCb2R5RWxlbWVudD47IHRhZ0JhY2tkcm9wOiBFbGVtZW50VG9UYWc8QmFja2Ryb3BFbGVtZW50PiwgbWFrZVByb3BzRm9jdXNDb250YWluZXI6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rm9jdXNDb250YWluZXJFbGVtZW50PiwgbWFrZVByb3BzRGlhbG9nOiAoaW5mbzogVXNlRGlhbG9nUmV0dXJuVHlwZUluZm8pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPERpYWxvZ0VsZW1lbnQ+LCBtYWtlUHJvcHNCb2R5OiAoaW5mbzogVXNlRGlhbG9nUmV0dXJuVHlwZUluZm8pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PiwgbWFrZVByb3BzVGl0bGU6IChpbmZvOiBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50PiwgbWFrZVByb3BzQmFja2Ryb3A6IChpbmZvOiBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8QmFja2Ryb3BFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlck1vZGFsPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50LCBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbz4oeyBwb3J0YWxJZCwgdGFnRm9jdXNDb250YWluZXIsIHRhZ0JhY2tkcm9wLCB0YWdCb2R5LCB0YWdEaWFsb2csIHRhZ1RpdGxlLCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lciwgbWFrZVByb3BzQmFja2Ryb3AsIG1ha2VQcm9wc0JvZHksIG1ha2VQcm9wc0RpYWxvZywgbWFrZVByb3BzVGl0bGUgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7XHJcbiAgICBvbkNsb3NlLFxyXG4gICAgb3BlbixcclxuICAgIGJvZHlJc09ubHlTZW1hbnRpYyxcclxuICAgIGdldERvY3VtZW50LFxyXG4gICAgZ2V0V2luZG93LFxyXG4gICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlLFxyXG4gICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSxcclxuICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZSxcclxuICAgIGZvY3VzU2VsZixcclxuICAgIHJlbmRlclxyXG59OiBEaWFsb2dQcm9wczxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudCwgQm9keUVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VEaWFsb2dCYWNrZHJvcCxcclxuICAgICAgICB1c2VEaWFsb2dCb2R5LFxyXG4gICAgICAgIHVzZURpYWxvZ1Byb3BzLFxyXG4gICAgICAgIHVzZURpYWxvZ1RpdGxlLFxyXG4gICAgICAgIHVzZURpYWxvZ0ZvY3VzQ29udGFpbmVyUHJvcHMsXHJcbiAgICAgICAgLi4uclxyXG4gICAgfSA9IHVzZUFyaWFEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQsIEJvZHlFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQ+KHsgZGlhbG9nOiB7IG9uQ2xvc2UgfSwgbW9kYWw6IHsgYm9keUlzT25seVNlbWFudGljLCBmb2N1c1NlbGYgfSwgc29mdERpc21pc3M6IHsgb3BlbiB9LCBhY3RpdmVFbGVtZW50OiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH0gfSk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VEaWFsb2dUaXRsZVByb3BzIH0gPSB1c2VEaWFsb2dUaXRsZSgpO1xyXG4gICAgY29uc3QgeyB1c2VEaWFsb2dCb2R5UHJvcHMgfSA9IHVzZURpYWxvZ0JvZHkoKTtcclxuICAgIGNvbnN0IHsgdXNlRGlhbG9nQmFja2Ryb3BQcm9wcyB9ID0gdXNlRGlhbG9nQmFja2Ryb3AoKTtcclxuXHJcbiAgICByZXR1cm4gcmVuZGVyKHIsIHVzZURpYWxvZ0ZvY3VzQ29udGFpbmVyUHJvcHMsIHVzZURpYWxvZ1Byb3BzLCB1c2VEaWFsb2dUaXRsZVByb3BzLCB1c2VEaWFsb2dCb2R5UHJvcHMsIHVzZURpYWxvZ0JhY2tkcm9wUHJvcHMpO1xyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XHJcbi8vaW1wb3J0IHsgRWxlbWVudFRvVGFnIH0gZnJvbSBcIi4uL3Byb3BzXCI7XHJcbmltcG9ydCB7IHVzZUFyaWFMaXN0Ym94U2luZ2xlLCB1c2VMaXN0Ym94R3JvdXAsIFVzZUxpc3Rib3hTaW5nbGVJdGVtLCBVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnMsIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm8sIFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzLCBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLWxpc3Rib3gtc2luZ2xlXCI7XHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94U2luZ2xlUHJvcHM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwic2luZ2xlU2VsZWN0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImxpbmVhck5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwiY2hpbGRyZW5IYXZlRm9jdXNcIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibGlzdGJveFNpbmdsZVwiPiB7XHJcbiAgICAvL3RhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PjtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiwgbW9kaWZ5UHJvcHNMYWJlbDogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4sIG1vZGlmeVByb3BzTGlzdDogUHJvcE1vZGlmaWVyPExpc3RFbGVtZW50Pik6IFZOb2RlPGFueT47XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94U2luZ2xlSXRlbVByb3BzPExpc3Rib3hJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnM8TGlzdGJveEl0ZW1FbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXHJcbiAgICBPbWl0PEdldDxVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnM8TGlzdGJveEl0ZW1FbGVtZW50PiwgXCJsaXN0TmF2aWdhdGlvblwiPiwgXCJzdWJJbmZvXCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVyczxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVyczxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBcImhhc0ZvY3VzXCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVyczxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBcImxpc3Rib3hTaW5nbGVJdGVtXCI+IHtcclxuICAgIC8vdGFnTGlzdEl0ZW06IEVsZW1lbnRUb1RhZzxMaXN0Ym94SXRlbUVsZW1lbnQ+O1xyXG4gICAgcmVuZGVyKGluZm86IFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm88TGlzdGJveEl0ZW1FbGVtZW50PiwgbW9kaWZ5TGlzdEl0ZW1Qcm9wczogUHJvcE1vZGlmaWVyPExpc3Rib3hJdGVtRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xyXG59XHJcblxyXG5jb25zdCBMaXN0Ym94U2luZ2xlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTGlzdGJveFNpbmdsZUl0ZW08YW55Pj4obnVsbCEpO1xyXG5cclxuZnVuY3Rpb24gTGlzdGJveFNpbmdsZVU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcclxuICAgIHJlbmRlcixcclxuXHJcbiAgICBzZWxlY3RlZEluZGV4LFxyXG4gICAgdGFnTGFiZWwsXHJcbiAgICBjb2xsYXRvcixcclxuICAgIGRpc2FibGVBcnJvd0tleXMsXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICBpbmRleERlbWFuZ2xlcixcclxuICAgIGluZGV4TWFuZ2xlcixcclxuICAgIGluaXRpYWxJbmRleCxcclxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXHJcbiAgICBub1R5cGVhaGVhZCxcclxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcclxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVSZW5kZXIsXHJcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxyXG4gICAgb25BbGxMb3N0Rm9jdXMsXHJcbiAgICBvbkFueUdhaW5lZEZvY3VzLFxyXG4gICAgc2VsZWN0aW9uTW9kZSxcclxuICAgIHRhZ0xpc3QsXHJcbiAgICBvblNlbGVjdFxyXG59OiBMaXN0Ym94U2luZ2xlUHJvcHM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50Pikge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVJdGVtLFxyXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCxcclxuICAgICAgICB1c2VMaXN0Ym94U2luZ2xlUHJvcHMsXHJcbiAgICAgICAgLi4ubGlzdGJveFJldHVyblR5cGVcclxuICAgIH0gPSB1c2VBcmlhTGlzdGJveFNpbmdsZTxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQ+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxyXG4gICAgICAgIGxpc3Rib3hTaW5nbGU6IHsgc2VsZWN0aW9uTW9kZSwgdGFnTGFiZWwsIHRhZ0xpc3QsIG9uU2VsZWN0IH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXHJcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXggfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9LFxyXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHMgfSA9IHVzZUxpc3Rib3hTaW5nbGVMYWJlbCgpO1xyXG4gICAgLy9jb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwsIHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzKHt9KSBhcyBhbnkpO1xyXG4gICAgLy9jb25zdCBsaXN0ID0gY3JlYXRlRWxlbWVudCh0YWdMaXN0LCB1c2VMaXN0Ym94U2luZ2xlUHJvcHMoeyBjaGlsZHJlbjogdm5vZGVDaGlsZHJlbiwgcmVmIH0pIGFzIGFueSk7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPExpc3Rib3hTaW5nbGVDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VMaXN0Ym94U2luZ2xlSXRlbX0+XHJcbiAgICAgICAgICAgIHtyZW5kZXIoeyAuLi5saXN0Ym94UmV0dXJuVHlwZSB9LCB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcywgdXNlTGlzdGJveFNpbmdsZVByb3BzKX1cclxuICAgICAgICA8L0xpc3Rib3hTaW5nbGVDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckxpc3Rib3hTaW5nbGU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNMaXN0LCBtYWtlUHJvcHNMYWJlbCwgdGFnTGFiZWwsIHRhZ0xpc3QgfTogeyB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD4sIHRhZ0xpc3Q6IEVsZW1lbnRUb1RhZzxMaXN0RWxlbWVudD4sIG1ha2VQcm9wc0xhYmVsOiAoaW5mbzogVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4sIG1ha2VQcm9wc0xpc3Q6IChpbmZvOiBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBkZWZhdWx0UmVuZGVyTGlzdDxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50Pj4oeyBtYWtlUHJvcHNMYWJlbCwgbWFrZVByb3BzTGlzdCwgdGFnTGFiZWwsIHRhZ0xpc3QgfSlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJMaXN0Ym94U2luZ2xlSXRlbTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBtYWtlUHJvcHNMaXN0SXRlbSwgdGFnTGlzdEl0ZW0gfTogeyB0YWdMaXN0SXRlbTogRWxlbWVudFRvVGFnPExpc3RJdGVtRWxlbWVudD4sIG1ha2VQcm9wc0xpc3RJdGVtOiAoaW5mbzogVXNlTGlzdGJveFNpbmdsZUl0ZW1SZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0SXRlbUVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBkZWZhdWx0UmVuZGVyTGlzdEl0ZW08TGlzdEl0ZW1FbGVtZW50LCBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4+KHsgbWFrZVByb3BzTGlzdEl0ZW0sIHRhZ0xpc3RJdGVtIH0pO1xyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIExpc3Rib3hTaW5nbGVJdGVtVTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGluZGV4LCBibHVyU2VsZiwgZGlzYWJsZWQsIGZsYWdzLCBmb2N1c1NlbGYsIGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmVuZGVyLCB0ZXh0LCBoaWRkZW4gfTogTGlzdGJveFNpbmdsZUl0ZW1Qcm9wczxMaXN0SXRlbUVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZUxpc3Rib3hTaW5nbGVJdGVtUHJvcHMsIHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24gfSA9IHVzZUNvbnRleHQoTGlzdGJveFNpbmdsZUNvbnRleHQpKHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuIH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxyXG4gICAgICAgIGxpc3Rib3hTaW5nbGVJdGVtOiB7IGRpc2FibGVkIH0sXHJcbiAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD57cmVuZGVyKHsgcm92aW5nVGFiSW5kZXgsIHNpbmdsZVNlbGVjdGlvbiB9LCB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzKX08Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IExpc3Rib3hTaW5nbGUgPSBmb3J3YXJkUmVmKExpc3Rib3hTaW5nbGVVKSBhcyB0eXBlb2YgTGlzdGJveFNpbmdsZVU7XHJcbmV4cG9ydCBjb25zdCBMaXN0Ym94U2luZ2xlSXRlbSA9IGZvcndhcmRSZWYoTGlzdGJveFNpbmdsZUl0ZW1VKSBhcyB0eXBlb2YgTGlzdGJveFNpbmdsZUl0ZW1VO1xyXG5leHBvcnQgY29uc3QgTGlzdGJveEdyb3VwID0gZm9yd2FyZFJlZihMaXN0Ym94R3JvdXBVKSBhcyB0eXBlb2YgTGlzdGJveEdyb3VwVTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGJveEdyb3VwUHJvcHM8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcclxuICAgIHJlbmRlcihtb2RpZnlDb250YWluZXJQcm9wczogUHJvcE1vZGlmaWVyPENvbnRhaW5lckVsZW1lbnQ+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50Pik6IFZOb2RlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBMaXN0Ym94R3JvdXBVPENvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHJlbmRlciB9OiBMaXN0Ym94R3JvdXBQcm9wczxDb250YWluZXJFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZUxpc3Rib3hHcm91cEhlYWRpbmdQcm9wcywgdXNlTGlzdGJveEdyb3VwQ29udGFpbmVyUHJvcHMgfSA9IHVzZUxpc3Rib3hHcm91cDxDb250YWluZXJFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KCk7XHJcbiAgICByZXR1cm4gKHJlbmRlcih1c2VMaXN0Ym94R3JvdXBDb250YWluZXJQcm9wcywgdXNlTGlzdGJveEdyb3VwSGVhZGluZ1Byb3BzKSlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRMaXN0Ym94R3JvdXBSZW5kZXI8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnQ29udGFpbmVyLCB0YWdMYWJlbCwgbWFrZVByb3BzQ29udGFpbmVyLCBtYWtlUHJvcHNMYWJlbCB9OiB7IHRhZ0NvbnRhaW5lcjogRWxlbWVudFRvVGFnPENvbnRhaW5lckVsZW1lbnQ+LCB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD4sIG1ha2VQcm9wc0NvbnRhaW5lcjogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyRWxlbWVudD4sIG1ha2VQcm9wc0xhYmVsOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAobW9kaWZ5Q29udGFpbmVyUHJvcHM6IFByb3BNb2RpZmllcjxDb250YWluZXJFbGVtZW50PiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4pIHtcclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5wcm9wc0NvbnRhaW5lciB9ID0gbW9kaWZ5Q29udGFpbmVyUHJvcHMobWFrZVByb3BzQ29udGFpbmVyKCkpO1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0NvbnRhaW5lciBhcyBuZXZlciwgcHJvcHNDb250YWluZXIsIDw+XHJcbiAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ0xhYmVsIGFzIG5ldmVyLCBtb2RpZnlMYWJlbFByb3BzKG1ha2VQcm9wc0xhYmVsKCkpKX1cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvPilcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckxpc3Q8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSW5mb1R5cGU+KHsgbWFrZVByb3BzTGlzdCwgbWFrZVByb3BzTGFiZWwsIHRhZ0xhYmVsLCB0YWdMaXN0IH06IHsgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+LCB0YWdMaXN0OiBFbGVtZW50VG9UYWc8TGlzdEVsZW1lbnQ+LCBtYWtlUHJvcHNMYWJlbDogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+LCBtYWtlUHJvcHNMaXN0OiAoaW5mbzogSW5mb1R5cGUpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IEluZm9UeXBlLCBtb2RpZnlQcm9wc0xhYmVsOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50PiwgbW9kaWZ5UHJvcHNMaXN0OiBQcm9wTW9kaWZpZXI8TGlzdEVsZW1lbnQ+KTogVk5vZGU8YW55PiB7XHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KHRhZ0xhYmVsIGFzIG5ldmVyLCBtb2RpZnlQcm9wc0xhYmVsKG1ha2VQcm9wc0xhYmVsKGluZm8pKSk7XHJcbiAgICAgICAgY29uc3QgbGlzdCA9IGNyZWF0ZUVsZW1lbnQodGFnTGlzdCBhcyBuZXZlciwgbW9kaWZ5UHJvcHNMaXN0KG1ha2VQcm9wc0xpc3QoaW5mbykpKTtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAge2xhYmVsfVxyXG4gICAgICAgICAgICAgICAge2xpc3R9XHJcbiAgICAgICAgICAgIDwvPlxyXG4gICAgICAgIClcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJMaXN0SXRlbTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSW5mb1R5cGU+KHsgbWFrZVByb3BzTGlzdEl0ZW0sIHRhZ0xpc3RJdGVtIH06IHsgdGFnTGlzdEl0ZW06IEVsZW1lbnRUb1RhZzxMaXN0SXRlbUVsZW1lbnQ+LCBtYWtlUHJvcHNMaXN0SXRlbTogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0SXRlbUVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogSW5mb1R5cGUsIG1vZGlmeVByb3BzTGlzdEl0ZW06IFByb3BNb2RpZmllcjxMaXN0SXRlbUVsZW1lbnQ+KTogVk5vZGU8YW55PiB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnTGlzdEl0ZW0gYXMgbmV2ZXIsIG1vZGlmeVByb3BzTGlzdEl0ZW0obWFrZVByb3BzTGlzdEl0ZW0oaW5mbykpKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwicHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlQXJpYUxpc3Rib3hNdWx0aSwgVXNlTGlzdGJveE11bHRpSXRlbSwgVXNlTGlzdGJveE11bHRpSXRlbVBhcmFtZXRlcnMsIFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlSW5mbywgVXNlTGlzdGJveE11bHRpUGFyYW1ldGVycywgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLWxpc3Rib3gtbXVsdGlcIjtcclxuaW1wb3J0IHsgZGVmYXVsdFJlbmRlckxpc3QsIGRlZmF1bHRSZW5kZXJMaXN0SXRlbSB9IGZyb20gXCIuL2xpc3Rib3gtc2luZ2xlXCI7XHJcblxyXG5cclxuXHJcbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIExpc3Rib3hNdWx0aVByb3BzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xyXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibGluZWFyTmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQ8VXNlTGlzdGJveE11bHRpUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibWFuYWdlZENoaWxkcmVuXCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibGlzdGJveE11bHRpXCI+IHtcclxuICAgIC8vdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xyXG4gICAgcmVuZGVyKGluZm86IFVzZUxpc3Rib3hNdWx0aVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4sIG1vZGlmeVByb3BzTGFiZWw6IFByb3BNb2RpZmllcjxMYWJlbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc0xpc3Q6IFByb3BNb2RpZmllcjxMaXN0RWxlbWVudD4pOiBWTm9kZTxhbnk+O1xyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGJveE11bHRpSXRlbVByb3BzPExpc3Rib3hJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVyczxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZFwiPixcclxuICAgIE9taXQ8R2V0PFVzZUxpc3Rib3hNdWx0aUl0ZW1QYXJhbWV0ZXJzPExpc3Rib3hJdGVtRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sIFwic3ViSW5mb1wiPixcclxuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVyczxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aUl0ZW1QYXJhbWV0ZXJzPExpc3Rib3hJdGVtRWxlbWVudD4sIFwibGlzdGJveE11bHRpSXRlbVwiPiB7XHJcbiAgICByZW5kZXIoaW5mbzogVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVJbmZvPExpc3Rib3hJdGVtRWxlbWVudD4sIG1vZGlmeUxpc3RJdGVtUHJvcHM6IFByb3BNb2RpZmllcjxMaXN0Ym94SXRlbUVsZW1lbnQ+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IExpc3Rib3hNdWx0aUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUxpc3Rib3hNdWx0aUl0ZW08YW55Pj4obnVsbCEpO1xyXG5cclxuZnVuY3Rpb24gTGlzdGJveE11bHRpVTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oe1xyXG4gICAgcmVuZGVyLFxyXG4gICAgdGFnTGFiZWwsXHJcbiAgICBjb2xsYXRvcixcclxuICAgIGRpc2FibGVBcnJvd0tleXMsXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICBpbmRleERlbWFuZ2xlcixcclxuICAgIGluZGV4TWFuZ2xlcixcclxuICAgIGluaXRpYWxJbmRleCxcclxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXHJcbiAgICBub1R5cGVhaGVhZCxcclxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcclxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVSZW5kZXIsXHJcblxyXG4gICAgdHlwZWFoZWFkVGltZW91dCxcclxuICAgIHRhZ0xpc3QsXHJcbn06IExpc3Rib3hNdWx0aVByb3BzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VMaXN0Ym94TXVsdGlJdGVtLFxyXG4gICAgICAgIHVzZUxpc3Rib3hNdWx0aUxhYmVsLFxyXG4gICAgICAgIHVzZUxpc3Rib3hNdWx0aVByb3BzLFxyXG4gICAgICAgIC4uLmxpc3Rib3hSZXR1cm5UeXBlXHJcbiAgICB9ID0gdXNlQXJpYUxpc3Rib3hNdWx0aTxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQ+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxyXG4gICAgICAgIGxpc3Rib3hNdWx0aTogeyB0YWdMYWJlbCwgdGFnTGlzdCB9LFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciB9LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTGlzdGJveE11bHRpTGFiZWxQcm9wcyB9ID0gdXNlTGlzdGJveE11bHRpTGFiZWwoKTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPExpc3Rib3hNdWx0aUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUxpc3Rib3hNdWx0aUl0ZW19PlxyXG4gICAgICAgICAgICB7cmVuZGVyKGxpc3Rib3hSZXR1cm5UeXBlLCB1c2VMaXN0Ym94TXVsdGlMYWJlbFByb3BzLCB1c2VMaXN0Ym94TXVsdGlQcm9wcyl9XHJcbiAgICAgICAgPC9MaXN0Ym94TXVsdGlDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJMaXN0Ym94TXVsdGk8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNMaXN0LCBtYWtlUHJvcHNMYWJlbCwgdGFnTGFiZWwsIHRhZ0xpc3QgfTogeyB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD4sIHRhZ0xpc3Q6IEVsZW1lbnRUb1RhZzxMaXN0RWxlbWVudD4sIG1ha2VQcm9wc0xhYmVsOiAoaW5mbzogVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiwgbWFrZVByb3BzTGlzdDogKGluZm86IFVzZUxpc3Rib3hNdWx0aVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlckxpc3Q8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50Pj4oeyBtYWtlUHJvcHNMYWJlbCwgbWFrZVByb3BzTGlzdCwgdGFnTGFiZWwsIHRhZ0xpc3QgfSlcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJMaXN0Ym94TXVsdGlJdGVtPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IG1ha2VQcm9wc0xpc3RJdGVtLCB0YWdMaXN0SXRlbSB9OiB7IHRhZ0xpc3RJdGVtOiBFbGVtZW50VG9UYWc8TGlzdEl0ZW1FbGVtZW50PiwgbWFrZVByb3BzTGlzdEl0ZW06IChpbmZvOiBVc2VMaXN0Ym94TXVsdGlJdGVtUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEl0ZW1FbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlckxpc3RJdGVtPExpc3RJdGVtRWxlbWVudCwgVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4+KHsgbWFrZVByb3BzTGlzdEl0ZW0sIHRhZ0xpc3RJdGVtIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBMaXN0Ym94TXVsdGlJdGVtVTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGluZGV4LCBibHVyU2VsZiwgZGlzYWJsZWQsIGZsYWdzLCBmb2N1c1NlbGYsIHJlbmRlciwgdGV4dCwgaGlkZGVuLCBzZWxlY3RlZCwgb25TZWxlY3QgfTogTGlzdGJveE11bHRpSXRlbVByb3BzPExpc3RJdGVtRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHsgdXNlTGlzdGJveE11bHRpSXRlbVByb3BzLCAuLi5pdGVtUmV0dXJuIH0gPSB1c2VDb250ZXh0KExpc3Rib3hNdWx0aUNvbnRleHQpKHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuIH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxyXG4gICAgICAgIGxpc3Rib3hNdWx0aUl0ZW06IHsgZGlzYWJsZWQsIHNlbGVjdGVkLCBvblNlbGVjdCB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+e3JlbmRlcihpdGVtUmV0dXJuLCB1c2VMaXN0Ym94TXVsdGlJdGVtUHJvcHMpfTwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgTGlzdGJveE11bHRpID0gZm9yd2FyZFJlZihMaXN0Ym94TXVsdGlVKSBhcyB0eXBlb2YgTGlzdGJveE11bHRpVTtcclxuZXhwb3J0IGNvbnN0IExpc3Rib3hNdWx0aUl0ZW0gPSBmb3J3YXJkUmVmKExpc3Rib3hNdWx0aUl0ZW1VKSBhcyB0eXBlb2YgTGlzdGJveE11bHRpSXRlbVU7XHJcbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkLCBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzLCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XHJcbmltcG9ydCB7IHVzZUFyaWFNZW51LCBVc2VBcmlhTWVudUl0ZW1QYXJhbWV0ZXJzLCBVc2VBcmlhTWVudUl0ZW1SZXR1cm5UeXBlSW5mbywgVXNlQXJpYU1lbnVQYXJhbWV0ZXJzLCBVc2VBcmlhTWVudVJldHVyblR5cGVJbmZvLCBVc2VNZW51SXRlbSB9IGZyb20gXCIuLi91c2UtbWVudVwiO1xyXG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyUG9ydGFsIH0gZnJvbSBcIi4vZGlhbG9nXCI7XHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBNZW51UHJvcHM8U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNlbnRpbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIC8vT21pdDxVc2VBcmlhTWVudVBhcmFtZXRlcnM8RSwgSywgST4sIFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIgfCBcIm9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdFwiIHwgXCJvbkNoaWxkcmVuTW91bnRDaGFuZ2VcIiB8IFwib25UYWJiYWJsZUluZGV4Q2hhbmdlXCIgfCBcIm9uVGFiYmFibGVSZW5kZXJcIiB8IFwib25UYWJiZWRJblRvXCIgfCBcIm9uVGFiYmVkT3V0T2ZcIj4gJiB7XHJcbiAgICBHZXQ8VXNlQXJpYU1lbnVQYXJhbWV0ZXJzPFN1cmZhY2VFbGVtZW50LCBCdXR0b25FbGVtZW50LCBuZXZlcj4sIFwibWVudVwiPixcclxuICAgIEdldDxVc2VBcmlhTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJtZW51U3VyZmFjZVwiPixcclxuICAgIEdldDxVc2VBcmlhTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJzb2Z0RGlzbWlzc1wiPixcclxuICAgIEdldDxVc2VBcmlhTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFNZW51UGFyYW1ldGVyczxTdXJmYWNlRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgbmV2ZXI+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFNZW51UGFyYW1ldGVyczxTdXJmYWNlRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgbmV2ZXI+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxyXG4gICAgR2V0PFVzZUFyaWFNZW51UGFyYW1ldGVyczxTdXJmYWNlRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgbmV2ZXI+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXHJcblxyXG4gICAgR2V0PFVzZUFyaWFNZW51UGFyYW1ldGVyczxTdXJmYWNlRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgbmV2ZXI+LCBcIm1hbmFnZWRDaGlsZHJlblwiPiB7XHJcbiAgICAvL3Byb3BzTWVudUJ1dHRvbjogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PjtcclxuICAgIC8vcHJvcHNNZW51U2VudGluZWw6ICh3aGljaDogXCJ0b3BcIiB8IFwiYm90dG9tXCIpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT47XHJcbiAgICAvL3Byb3BzTWVudTogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PjtcclxuXHJcbiAgICAvL3RhZ01lbnVCdXR0b246IGFueTtcclxuICAgIC8vdGFnTWVudTogYW55O1xyXG4gICAgLy90YWdTZW50aW5lbDogYW55O1xyXG5cclxuICAgIGdldERvY3VtZW50OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyc1tcImdldERvY3VtZW50XCJdO1xyXG4gICAgZ2V0V2luZG93PzogVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnNbXCJnZXRXaW5kb3dcIl07XHJcblxyXG4gICAgcmVuZGVyKG1lbnVJbmZvOiBVc2VBcmlhTWVudVJldHVyblR5cGVJbmZvPFN1cmZhY2VFbGVtZW50LCBNZW51RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBCdXR0b25FbGVtZW50PiwgbW9kaWZ5TWVudUJ1dHRvblByb3BzOiBQcm9wTW9kaWZpZXI8QnV0dG9uRWxlbWVudD4sIG1vZGlmeU1lbnVTdXJmYWNlUHJvcHM6IFByb3BNb2RpZmllcjxTdXJmYWNlRWxlbWVudD4sIG1vZGlmeU1lbnVQcm9wczogUHJvcE1vZGlmaWVyPE1lbnVFbGVtZW50PiwgbW9kaWZ5Rmlyc3RTZW50aW5lbFByb3BzOiBQcm9wTW9kaWZpZXI8U2VudGluZWxFbGVtZW50PiwgbW9kaWZ5TGFzdFNlbnRpbmVsUHJvcHM6IFByb3BNb2RpZmllcjxTZW50aW5lbEVsZW1lbnQ+KTogVk5vZGU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWVudUl0ZW1Qcm9wczxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlQXJpYU1lbnVJdGVtUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZFwiPixcclxuICAgIEdldDxVc2VBcmlhTWVudUl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYU1lbnVJdGVtUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+IHtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VBcmlhTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+LCBtb2RpZnlMaXN0SXRlbVByb3BzOiBQcm9wTW9kaWZpZXI8TWVudUl0ZW1FbGVtZW50Pik6IFZOb2RlO1xyXG4gICAgLy90YWdNZW51SXRlbTogYW55O1xyXG4gICAgLy9wcm9wc01lbnVJdGVtOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+XHJcbn1cclxuXHJcbmNvbnN0IE1lbnVJdGVtQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTWVudUl0ZW08YW55Pj4obnVsbCEpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIE1lbnU8U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgU2VudGluZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcclxuICAgIGluaXRpYWxJbmRleCxcclxuICAgIGNvbGxhdG9yLFxyXG4gICAgZGlzYWJsZUFycm93S2V5cyxcclxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcclxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXHJcbiAgICBub1R5cGVhaGVhZCxcclxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXHJcbiAgICBvbk9wZW4sXHJcbiAgICBvbkNsb3NlLFxyXG4gICAgb3BlbixcclxuXHJcbiAgICBvcGVuRGlyZWN0aW9uLFxyXG4gICAgaW5kZXhEZW1hbmdsZXIsXHJcbiAgICBpbmRleE1hbmdsZXIsXHJcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXHJcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxyXG5cclxuICAgIGdldERvY3VtZW50LFxyXG4gICAgZ2V0V2luZG93LFxyXG5cclxuICAgIHJlbmRlclxyXG5cclxufTogTWVudVByb3BzPFN1cmZhY2VFbGVtZW50LCBQYXJlbnRFbGVtZW50LCBTZW50aW5lbEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQnV0dG9uRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VNZW51QnV0dG9uUHJvcHMsXHJcbiAgICAgICAgdXNlTWVudUl0ZW0sXHJcbiAgICAgICAgdXNlTWVudVByb3BzLFxyXG4gICAgICAgIHVzZU1lbnVTZW50aW5lbCxcclxuICAgICAgICB1c2VNZW51U3VyZmFjZVByb3BzLFxyXG4gICAgICAgIC4uLm1lbnVSZXR1cm5cclxuICAgIH0gPSB1c2VBcmlhTWVudTxTdXJmYWNlRWxlbWVudCwgUGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBCdXR0b25FbGVtZW50Pih7XHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXHJcbiAgICAgICAgbWVudTogeyBvbk9wZW46IHVzZVN0YWJsZUNhbGxiYWNrKG9uT3BlbiksIG9wZW5EaXJlY3Rpb24gfSxcclxuICAgICAgICBtZW51U3VyZmFjZToge30sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIgfSxcclxuICAgICAgICBzb2Z0RGlzbWlzczogeyBvbkNsb3NlOiB1c2VTdGFibGVDYWxsYmFjayhvbkNsb3NlKSwgb3BlbiB9LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH0sXHJcbiAgICAgICAgYWN0aXZlRWxlbWVudDogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93IH0sXHJcbiAgICAgICAgaGFzRm9jdXNCdXR0b246IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyB9LFxyXG4gICAgICAgIGhhc0ZvY3VzU3VyZmFjZTogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93IH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZU1lbnVTZW50aW5lbFByb3BzOiB1c2VGaXJzdFNlbnRpbmVsUHJvcHMgfSA9IHVzZU1lbnVTZW50aW5lbDxTZW50aW5lbEVsZW1lbnQ+KCk7XHJcbiAgICBjb25zdCB7IHVzZU1lbnVTZW50aW5lbFByb3BzOiB1c2VMYXN0U2VudGluZWxQcm9wcyB9ID0gdXNlTWVudVNlbnRpbmVsPFNlbnRpbmVsRWxlbWVudD4oKTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPE1lbnVJdGVtQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlTWVudUl0ZW19PlxyXG4gICAgICAgICAgICB7cmVuZGVyKG1lbnVSZXR1cm4sIHVzZU1lbnVCdXR0b25Qcm9wcywgdXNlTWVudVN1cmZhY2VQcm9wcywgdXNlTWVudVByb3BzLCB1c2VGaXJzdFNlbnRpbmVsUHJvcHMsIHVzZUxhc3RTZW50aW5lbFByb3BzKX1cclxuICAgICAgICA8L01lbnVJdGVtQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIClcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHJlbmRlciwgaW5kZXgsIHRleHQsIGhpZGRlbiwgYmx1clNlbGYsIGZsYWdzLCBmb2N1c1NlbGYgfTogTWVudUl0ZW1Qcm9wczxNZW51SXRlbUVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZU1lbnVJdGVtUHJvcHMsIC4uLnJlc3QgfSA9IHVzZUNvbnRleHQoTWVudUl0ZW1Db250ZXh0KSh7XHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW4gfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVuZGVyKHJlc3QsIHVzZU1lbnVJdGVtUHJvcHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlck1lbnU8U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNlbnRpbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHBvcnRhbElkLCB0YWdCdXR0b24sIHRhZ01lbnUsIHRhZ1N1cmZhY2UsIHRhZ1NlbnRpbmVsLCBtYWtlUHJvcHNCdXR0b24sIG1ha2VQcm9wc01lbnUsIG1ha2VQcm9wc1N1cmZhY2UsIG1ha2VQcm9wc1NlbnRpbmVsIH06IHsgcG9ydGFsSWQ6IHN0cmluZywgdGFnU3VyZmFjZTogRWxlbWVudFRvVGFnPFN1cmZhY2VFbGVtZW50PiwgdGFnTWVudTogRWxlbWVudFRvVGFnPE1lbnVFbGVtZW50PiwgdGFnQnV0dG9uOiBFbGVtZW50VG9UYWc8QnV0dG9uRWxlbWVudD4sIHRhZ1NlbnRpbmVsOiBFbGVtZW50VG9UYWc8U2VudGluZWxFbGVtZW50PiwgbWFrZVByb3BzU3VyZmFjZTogKGluZm86IFVzZUFyaWFNZW51UmV0dXJuVHlwZUluZm88U3VyZmFjZUVsZW1lbnQsIE1lbnVFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxTdXJmYWNlRWxlbWVudD4sIG1ha2VQcm9wc01lbnU6IChpbmZvOiBVc2VBcmlhTWVudVJldHVyblR5cGVJbmZvPFN1cmZhY2VFbGVtZW50LCBNZW51RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBCdXR0b25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUVsZW1lbnQ+LCBtYWtlUHJvcHNCdXR0b246IChpbmZvOiBVc2VBcmlhTWVudVJldHVyblR5cGVJbmZvPFN1cmZhY2VFbGVtZW50LCBNZW51RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBCdXR0b25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8QnV0dG9uRWxlbWVudD4sIG1ha2VQcm9wc1NlbnRpbmVsOiAoaW5mbzogVXNlQXJpYU1lbnVSZXR1cm5UeXBlSW5mbzxTdXJmYWNlRWxlbWVudCwgTWVudUVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgQnV0dG9uRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFNlbnRpbmVsRWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZW51SW5mbzogVXNlQXJpYU1lbnVSZXR1cm5UeXBlSW5mbzxTdXJmYWNlRWxlbWVudCwgTWVudUVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgQnV0dG9uRWxlbWVudD4sIG1vZGlmeU1lbnVCdXR0b25Qcm9wczogUHJvcE1vZGlmaWVyPEJ1dHRvbkVsZW1lbnQ+LCBtb2RpZnlNZW51U3VyZmFjZVByb3BzOiBQcm9wTW9kaWZpZXI8U3VyZmFjZUVsZW1lbnQ+LCBtb2RpZnlNZW51UHJvcHM6IFByb3BNb2RpZmllcjxNZW51RWxlbWVudD4sIG1vZGlmeUZpcnN0U2VudGluZWxQcm9wczogUHJvcE1vZGlmaWVyPFNlbnRpbmVsRWxlbWVudD4sIG1vZGlmeUxhc3RTZW50aW5lbFByb3BzOiBQcm9wTW9kaWZpZXI8U2VudGluZWxFbGVtZW50Pikge1xyXG5cclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBzdXJmYWNlQ2hpbGRyZW4sIC4uLnN1cmZhY2VQcm9wcyB9ID0gbW9kaWZ5TWVudVN1cmZhY2VQcm9wcyhtYWtlUHJvcHNTdXJmYWNlKG1lbnVJbmZvKSk7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogbWVudUNoaWxkcmVuLCAuLi5tZW51UHJvcHMgfSA9IG1vZGlmeU1lbnVQcm9wcyhtYWtlUHJvcHNNZW51KG1lbnVJbmZvKSk7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ0J1dHRvbiBhcyBuZXZlciwgbW9kaWZ5TWVudUJ1dHRvblByb3BzKG1ha2VQcm9wc0J1dHRvbihtZW51SW5mbykpKX1cclxuICAgICAgICAgICAgICAgIHtkZWZhdWx0UmVuZGVyUG9ydGFsKHtcclxuICAgICAgICAgICAgICAgICAgICBwb3J0YWxJZCxcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogY3JlYXRlRWxlbWVudCh0YWdTdXJmYWNlIGFzIG5ldmVyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN1cmZhY2VQcm9wcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46ICg8PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnU2VudGluZWwgYXMgbmV2ZXIsIG1vZGlmeUZpcnN0U2VudGluZWxQcm9wcyhtYWtlUHJvcHNTZW50aW5lbChtZW51SW5mbykpKX1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdXJmYWNlQ2hpbGRyZW59XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdNZW51IGFzIG5ldmVyLCB7IC4uLm1lbnVQcm9wcywgY2hpbGRyZW46IDw+e21lbnVDaGlsZHJlbn08Lz4gfSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdTZW50aW5lbCBhcyBuZXZlciwgbW9kaWZ5TGFzdFNlbnRpbmVsUHJvcHMobWFrZVByb3BzU2VudGluZWwobWVudUluZm8pKSl9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvPilcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgIDwvPlxyXG4gICAgICAgIClcclxuXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlck1lbnVJdGVtPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbWFrZVByb3BzTWVudUl0ZW06IG1ha2VQcm9wc01lbnVJdGVtLCB0YWdNZW51SXRlbSB9OiB7IHRhZ01lbnVJdGVtOiBFbGVtZW50VG9UYWc8TWVudUl0ZW1FbGVtZW50PiwgbWFrZVByb3BzTWVudUl0ZW06IChpbmZvOiBVc2VBcmlhTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51SXRlbUVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlQXJpYU1lbnVJdGVtUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50PiwgbW9kaWZ5TWVudUl0ZW1Qcm9wczogUHJvcE1vZGlmaWVyPE1lbnVJdGVtRWxlbWVudD4pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdNZW51SXRlbSBhcyBuZXZlciwgbW9kaWZ5TWVudUl0ZW1Qcm9wcyhtYWtlUHJvcHNNZW51SXRlbShpbmZvKSkpXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XHJcbmltcG9ydCB7IHVzZUFyaWFSYWRpb0dyb3VwLCBVc2VBcmlhUmFkaW9Hcm91cFBhcmFtZXRlcnMsIFVzZUFyaWFSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm8sIFVzZUFyaWFSYWRpb1BhcmFtZXRlcnMsIFVzZVJhZGlvLCBVc2VSYWRpb1JldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS1yYWRpby1ncm91cFwiO1xyXG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlLCBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVycyB9IGZyb20gXCIuL2NoZWNrYm94XCJcclxuXHJcbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvR3JvdXBQcm9wczxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHcm91cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlQXJpYVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJyYWRpb0dyb3VwXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwibGluZWFyTmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VBcmlhUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwibWFuYWdlZENoaWxkcmVuXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJjaGlsZHJlbkhhdmVGb2N1c1wiPixcclxuICAgIEdldDxVc2VBcmlhUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xyXG4gICAgLy9wcm9wc0dyb3VwTGFiZWw6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyb3VwTGFiZWxFbGVtZW50PjtcclxuICAgIC8vcHJvcHNHcm91cDogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JvdXBFbGVtZW50PjtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VBcmlhUmFkaW9Hcm91cFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudD4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxHcm91cExhYmVsRWxlbWVudD4sIG1vZGlmeUdyb3VwUHJvcHM6IFByb3BNb2RpZmllcjxHcm91cEVsZW1lbnQ+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSYWRpb1Byb3BzPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDxVc2VBcmlhUmFkaW9QYXJhbWV0ZXJzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJyYWRpb1wiPixcclxuICAgIEdldDxVc2VBcmlhUmFkaW9QYXJhbWV0ZXJzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VBcmlhUmFkaW9QYXJhbWV0ZXJzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDxVc2VBcmlhUmFkaW9QYXJhbWV0ZXJzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXHJcbiAgICBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8SW5wdXRFbGVtZW50PixcclxuICAgIEdldDxVc2VBcmlhUmFkaW9QYXJhbWV0ZXJzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJyYWRpb1wiPiB7XHJcbiAgICByZW5kZXIoaW5mbzogVXNlUmFkaW9SZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQ+LCBtb2RpZnlJbnB1dFByb3BzOiBQcm9wTW9kaWZpZXI8SW5wdXRFbGVtZW50PiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclJhZGlvR3JvdXA8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdHcm91cCwgdGFnTGFiZWwsIG1ha2VQcm9wc0dyb3VwLCBtYWtlUHJvcHNMYWJlbCB9OiB7IHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PiwgdGFnR3JvdXA6IEVsZW1lbnRUb1RhZzxJbnB1dEVsZW1lbnQ+LCBtYWtlUHJvcHNMYWJlbDogKGluZm86IFVzZUFyaWFSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiwgbWFrZVByb3BzR3JvdXA6IChpbmZvOiBVc2VBcmlhUmFkaW9Hcm91cFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VBcmlhUmFkaW9Hcm91cFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudD4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxMYWJlbEVsZW1lbnQ+LCBtb2RpZnlHcm91cFByb3BzOiBQcm9wTW9kaWZpZXI8SW5wdXRFbGVtZW50Pikge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDw+XHJcbiAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdMYWJlbCBhcyBuZXZlciwgbW9kaWZ5TGFiZWxQcm9wcyhtYWtlUHJvcHNMYWJlbChpbmZvKSkpfVxyXG4gICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnR3JvdXAgYXMgbmV2ZXIsIG1vZGlmeUdyb3VwUHJvcHMobWFrZVByb3BzR3JvdXAoaW5mbykpKX1cclxuICAgICAgICAgICAgPC8+XHJcbiAgICAgICAgKVxyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBSYWRpb0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVJhZGlvPGFueSwgYW55LCBhbnk+PihudWxsISk7XHJcbmV4cG9ydCBmdW5jdGlvbiBSYWRpb0dyb3VwPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcclxuICAgIHJlbmRlcixcclxuICAgIHRhZ0dyb3VwLFxyXG4gICAgdGFnR3JvdXBMYWJlbCxcclxuICAgIGluaXRpYWxJbmRleCxcclxuICAgIG5hbWUsXHJcbiAgICBvbklucHV0LFxyXG4gICAgc2VsZWN0ZWRWYWx1ZSxcclxuICAgIGNvbGxhdG9yLFxyXG4gICAgZGlzYWJsZUFycm93S2V5cyxcclxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcclxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXHJcbiAgICBub1R5cGVhaGVhZCxcclxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXHJcbiAgICBpbmRleERlbWFuZ2xlcixcclxuICAgIGluZGV4TWFuZ2xlcixcclxuICAgIG9uQWxsTG9zdEZvY3VzLFxyXG4gICAgb25BbnlHYWluZWRGb2N1cyxcclxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcclxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVSZW5kZXIsXHJcbn06IFJhZGlvR3JvdXBQcm9wczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VSYWRpbyxcclxuICAgICAgICB1c2VSYWRpb0dyb3VwTGFiZWxQcm9wcyxcclxuICAgICAgICB1c2VSYWRpb0dyb3VwUHJvcHMsXHJcbiAgICAgICAgLi4ucmFkaW9Hcm91cFJldHVyblxyXG4gICAgfSA9IHVzZUFyaWFSYWRpb0dyb3VwPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pih7XHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXHJcbiAgICAgICAgcmFkaW9Hcm91cDogeyBuYW1lLCBvbklucHV0LCBzZWxlY3RlZFZhbHVlLCB0YWdHcm91cCwgdGFnR3JvdXBMYWJlbCB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfSxcclxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1czogeyBvbkFsbExvc3RGb2N1cywgb25BbnlHYWluZWRGb2N1cyB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxSYWRpb0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVJhZGlvfT5cclxuICAgICAgICAgICAge3JlbmRlcihyYWRpb0dyb3VwUmV0dXJuLCB1c2VSYWRpb0dyb3VwTGFiZWxQcm9wcywgdXNlUmFkaW9Hcm91cFByb3BzKX1cclxuICAgICAgICA8L1JhZGlvQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0UmVuZGVyUmFkaW9QYXJhbWV0ZXJzPEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIEwsIFVzZVJhZGlvUmV0dXJuVHlwZUluZm88ST4+IHtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyUmFkaW88SSBleHRlbmRzIEhUTUxFbGVtZW50LCBMIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgdGFnSW5wdXQsIHRhZ0xhYmVsLCBtYWtlSW5wdXRQcm9wcywgbWFrZUxhYmVsUHJvcHMsIGxhYmVsUG9zaXRpb24gfTogRGVmYXVsdFJlbmRlclJhZGlvUGFyYW1ldGVyczxJLCBMPikge1xyXG4gICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJDaGVja2JveExpa2U8SSwgTCwgVXNlUmFkaW9SZXR1cm5UeXBlSW5mbzxJPj4oeyBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcyB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFJhZGlvPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgZGlzYWJsZWQsIGluZGV4LCB0ZXh0LCBoaWRkZW4sIHRhZ0lucHV0LCBsYWJlbFBvc2l0aW9uLCB0YWdMYWJlbCwgdmFsdWUsIHJlbmRlciwgZmxhZ3MsIGJsdXJTZWxmLCBmb2N1c1NlbGYsIGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9OiBSYWRpb1Byb3BzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VSYWRpb0lucHV0LCB1c2VSYWRpb0xhYmVsLCAuLi5yYWRpb1JldHVybiB9ID0gdXNlQ29udGV4dChSYWRpb0NvbnRleHQpKHtcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxyXG4gICAgICAgIHJhZGlvOiB7IGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIHZhbHVlIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaGlkZGVuLCBmb2N1c1NlbGYsIGJsdXJTZWxmIH0sXHJcbiAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUmFkaW9JbnB1dFByb3BzIH0gPSB1c2VSYWRpb0lucHV0KHsgdGFnOiB0YWdJbnB1dCB9KTtcclxuICAgIGNvbnN0IHsgdXNlUmFkaW9MYWJlbFByb3BzIH0gPSB1c2VSYWRpb0xhYmVsKHsgdGFnOiB0YWdMYWJlbCB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVuZGVyKHJhZGlvUmV0dXJuLCB1c2VSYWRpb0lucHV0UHJvcHMsIHVzZVJhZGlvTGFiZWxQcm9wcyk7XHJcbn1cclxuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VBcmlhU2xpZGVyLCBVc2VBcmlhU2xpZGVyUGFyYW1ldGVycywgVXNlQXJpYVNsaWRlclRodW1iLCBVc2VBcmlhU2xpZGVyVGh1bWJQYXJhbWV0ZXJzLCBVc2VBcmlhU2xpZGVyVGh1bWJSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2Utc2xpZGVyXCI7XHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJQcm9wcyBleHRlbmRzIEdldDxVc2VBcmlhU2xpZGVyUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sIEdldDxVc2VBcmlhU2xpZGVyUGFyYW1ldGVycywgXCJzbGlkZXJcIj4ge1xyXG4gICAgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclRodW1iUHJvcHM8VGh1bWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHZXQ8VXNlQXJpYVNsaWRlclRodW1iUGFyYW1ldGVyczxUaHVtYkVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZFwiPiwgR2V0PFVzZUFyaWFTbGlkZXJUaHVtYlBhcmFtZXRlcnM8VGh1bWJFbGVtZW50PiwgXCJzbGlkZXJUaHVtYlwiPiB7XHJcbiAgICByZW5kZXIoaW5mbzogVXNlQXJpYVNsaWRlclRodW1iUmV0dXJuVHlwZUluZm8sIG1vZGlmeVRodW1iUHJvcHM6IFByb3BNb2RpZmllcjxUaHVtYkVsZW1lbnQ+KTogVk5vZGU7XHJcbn1cclxuXHJcbmNvbnN0IFNsaWRlclRodW1iQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQXJpYVNsaWRlclRodW1iPGFueT4+KG51bGwhKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBTbGlkZXIoeyBtYXgsIG1pbiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIGNoaWxkcmVuIH06IFNsaWRlclByb3BzKSB7XHJcbiAgICBjb25zdCB7IHVzZUFyaWFTbGlkZXJUaHVtYiwgLi4uX3NsaWRlckluZm8gfSA9IHVzZUFyaWFTbGlkZXIoe1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxyXG4gICAgICAgIHNsaWRlcjogeyBtYXgsIG1pbiB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxTbGlkZXJUaHVtYkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUFyaWFTbGlkZXJUaHVtYn0+e2NoaWxkcmVufTwvU2xpZGVyVGh1bWJDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gU2xpZGVyVGh1bWJVPFRodW1iRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbGFiZWwsIHRhZywgdmFsdWUsIG1heCwgbWluLCBvblZhbHVlQ2hhbmdlLCBpbmRleCwgZmxhZ3MsIHJlbmRlciwgdmFsdWVUZXh0IH06IFNsaWRlclRodW1iUHJvcHM8VGh1bWJFbGVtZW50PiwgcmVmOiBSZWY8VGh1bWJFbGVtZW50Pikge1xyXG4gICAgY29uc3QgeyB1c2VBcmlhU2xpZGVyVGh1bWJQcm9wcywgLi4uc2xpZGVySW5mbyB9ID0gdXNlQ29udGV4dChTbGlkZXJUaHVtYkNvbnRleHQpKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCBzbGlkZXJUaHVtYjogeyBsYWJlbCwgdGFnLCB2YWx1ZSwgbWF4LCBtaW4sIG9uVmFsdWVDaGFuZ2UsIHZhbHVlVGV4dCB9IH0pO1xyXG5cclxuICAgIHJldHVybiByZW5kZXIoc2xpZGVySW5mbywgdXNlQXJpYVNsaWRlclRodW1iUHJvcHMpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyU2xpZGVyVGh1bWI8RSBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnVGh1bWIsIG1ha2VQcm9wc1RodW1iIH06IHsgdGFnVGh1bWI6IEVsZW1lbnRUb1RhZzxFPiwgbWFrZVByb3BzVGh1bWI6IChpbmZvOiBVc2VBcmlhU2xpZGVyVGh1bWJSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VBcmlhU2xpZGVyVGh1bWJSZXR1cm5UeXBlSW5mbywgbW9kaWZ5VGh1bWJQcm9wczogUHJvcE1vZGlmaWVyPEU+KSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGh1bWIgYXMgbmV2ZXIsIG1vZGlmeVRodW1iUHJvcHMobWFrZVByb3BzVGh1bWIoaW5mbykpKVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgU2xpZGVyVGh1bWIgPSBmb3J3YXJkUmVmKFNsaWRlclRodW1iVSkgYXMgdHlwZW9mIFNsaWRlclRodW1iVTtcclxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XHJcbmltcG9ydCB7IHVzZUFyaWFUYWJsZSwgVXNlQXJpYVRhYmxlQm9keSwgVXNlQXJpYVRhYmxlQm9keVBhcmFtZXRlcnMsIFVzZUFyaWFUYWJsZUJvZHlSZXR1cm5UeXBlSW5mbywgVXNlQXJpYVRhYmxlQ2VsbCwgVXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnMsIFVzZUFyaWFUYWJsZUNlbGxSZXR1cm5UeXBlSW5mbywgVXNlQXJpYVRhYmxlUGFyYW1ldGVycywgVXNlQXJpYVRhYmxlUmV0dXJuVHlwZUluZm8sIFVzZUFyaWFUYWJsZVJvdywgVXNlQXJpYVRhYmxlUm93UGFyYW1ldGVycywgVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLXRhYmxlXCI7XHJcblxyXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xyXG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVQcm9wczxUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXHJcbiAgICBHZXQ8VXNlQXJpYVRhYmxlUGFyYW1ldGVycywgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFUYWJsZVBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVRhYmxlUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVRhYmxlUGFyYW1ldGVycywgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDxVc2VBcmlhVGFibGVQYXJhbWV0ZXJzLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xyXG4gICAgLy90YWdUYWJsZTogRWxlbWVudFRvVGFnPFRhYmxlRWxlbWVudD47XHJcbiAgICAvL3Byb3BzVGFibGUoKTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVFbGVtZW50PjtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VBcmlhVGFibGVSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIG1vZGlmeVRhYmxlUHJvcHM6IFByb3BNb2RpZmllcjxUYWJsZUVsZW1lbnQ+KTogVk5vZGU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVCb2R5UHJvcHM8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFyaWFUYWJsZUJvZHlQYXJhbWV0ZXJzIHtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VBcmlhVGFibGVCb2R5UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlUYWJsZUJvZHlQcm9wczogUHJvcE1vZGlmaWVyPFNlY3Rpb25FbGVtZW50Pik6IFZOb2RlO1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVIZWFkUHJvcHMge1xyXG4gICAgcmVuZGVyKCk6IFZOb2RlO1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVGb290UHJvcHMge1xyXG4gICAgcmVuZGVyKCk6IFZOb2RlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlUm93UHJvcHM8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xyXG4gICAgR2V0MjxVc2VBcmlhVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgXCJhc0NoaWxkUm93T2ZTZWN0aW9uXCIsIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQyPFVzZUFyaWFUYWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBcImFzQ2hpbGRSb3dPZlNlY3Rpb25cIiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXHJcbiAgICBHZXQyPFVzZUFyaWFUYWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBcImFzQ2hpbGRSb3dPZlNlY3Rpb25cIiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDI8VXNlQXJpYVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwibGluZWFyTmF2aWdhdGlvblwiPixcclxuICAgIEdldDI8VXNlQXJpYVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQyPFVzZUFyaWFUYWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcIm1hbmFnZWRDaGlsZHJlblwiPixcclxuICAgIEdldDI8VXNlQXJpYVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQyPFVzZUFyaWFUYWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xyXG4gICAgcmVuZGVyKGluZm86IFVzZUFyaWFUYWJsZVJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgdGFibGVSb3dQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4pOiBWTm9kZTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUNlbGxQcm9wczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcclxuICAgIEdldDxVc2VBcmlhVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZFwiPixcclxuICAgIEdldDxVc2VBcmlhVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFUYWJsZUNlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sXHJcbiAgICBPbWl0PEdldDxVc2VBcmlhVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwic3ViSW5mb1wiPiwgXCJsb2NhdGlvblwiPiB7XHJcbiAgICByZW5kZXIoaW5mbzogVXNlQXJpYVRhYmxlQ2VsbFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PiwgdGFibGVSb3dQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+KTogVk5vZGU7XHJcbn1cclxuXHJcbmNvbnN0IExvY2F0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8XCJoZWFkXCIgfCBcImJvZHlcIiB8IFwiZm9vdFwiPihudWxsISk7XHJcblxyXG5jb25zdCBUYWJsZUJvZHlDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VBcmlhVGFibGVCb2R5PGFueSwgYW55LCBhbnk+PihudWxsISk7XHJcbmNvbnN0IFRhYmxlUm93Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQXJpYVRhYmxlUm93PGFueSwgYW55Pj4obnVsbCEpO1xyXG5jb25zdCBUYWJsZUNlbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VBcmlhVGFibGVDZWxsPGFueT4+KG51bGwhKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGU8VGFibGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUYWJsZSwgbWFrZVByb3BzVGFibGUgfTogeyB0YWdUYWJsZTogRWxlbWVudFRvVGFnPFRhYmxlRWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlOiAoaW5mbzogVXNlQXJpYVRhYmxlUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlQXJpYVRhYmxlUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc1RhYmxlOiBQcm9wTW9kaWZpZXI8VGFibGVFbGVtZW50Pikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlIGFzIG5ldmVyLCBtb2RpZnlQcm9wc1RhYmxlKG1ha2VQcm9wc1RhYmxlKGluZm8pKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGVCb2R5PFRhYmxlQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RhYmxlQm9keSwgbWFrZVByb3BzVGFibGVCb2R5IH06IHsgdGFnVGFibGVCb2R5OiBFbGVtZW50VG9UYWc8VGFibGVCb2R5RWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlQm9keTogKGluZm86IFVzZUFyaWFUYWJsZUJvZHlSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlQm9keUVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlQXJpYVRhYmxlQm9keVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgbW9kaWZ5UHJvcHNUYWJsZUJvZHk6IFByb3BNb2RpZmllcjxUYWJsZUJvZHlFbGVtZW50Pikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlQm9keSBhcyBuZXZlciwgbW9kaWZ5UHJvcHNUYWJsZUJvZHkobWFrZVByb3BzVGFibGVCb2R5KGluZm8pKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGVIZWFkPFRhYmxlSGVhZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RhYmxlSGVhZCwgbWFrZVByb3BzVGFibGVIZWFkIH06IHsgdGFnVGFibGVIZWFkOiBFbGVtZW50VG9UYWc8VGFibGVIZWFkRWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlSGVhZDogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVIZWFkRWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJsZUhlYWQgYXMgbmV2ZXIsIChtYWtlUHJvcHNUYWJsZUhlYWQoKSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlRm9vdDxUYWJsZUZvb3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUYWJsZUZvb3QsIG1ha2VQcm9wc1RhYmxlRm9vdCB9OiB7IHRhZ1RhYmxlRm9vdDogRWxlbWVudFRvVGFnPFRhYmxlRm9vdEVsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZUZvb3Q6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlRm9vdEVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFibGVGb290IGFzIG5ldmVyLCAobWFrZVByb3BzVGFibGVGb290KCkpKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZVJvdzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RhYmxlUm93LCBtYWtlUHJvcHNUYWJsZVJvdyB9OiB7IHRhZ1RhYmxlUm93OiBFbGVtZW50VG9UYWc8Um93RWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlUm93OiAoaW5mbzogVXNlQXJpYVRhYmxlUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PiB9KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUFyaWFUYWJsZVJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgbW9kaWZ5UHJvcHNUYWJsZVJvdzogUHJvcE1vZGlmaWVyPFJvd0VsZW1lbnQ+KSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFibGVSb3cgYXMgbmV2ZXIsIG1vZGlmeVByb3BzVGFibGVSb3cobWFrZVByb3BzVGFibGVSb3coaW5mbykpKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZUNlbGw8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RhYmxlQ2VsbCwgbWFrZVByb3BzVGFibGVDZWxsIH06IHsgdGFnVGFibGVDZWxsOiBFbGVtZW50VG9UYWc8Q2VsbEVsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZUNlbGw6IChpbmZvOiBVc2VBcmlhVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VBcmlhVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc1RhYmxlQ2VsbDogUHJvcE1vZGlmaWVyPENlbGxFbGVtZW50Pikge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlQ2VsbCBhcyBuZXZlciwgbW9kaWZ5UHJvcHNUYWJsZUNlbGwobWFrZVByb3BzVGFibGVDZWxsKGluZm8pKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRhYmxlVTxUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XHJcbiAgICBjb2xsYXRvcixcclxuICAgIGRpc2FibGVBcnJvd0tleXMsXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICBpbml0aWFsSW5kZXgsXHJcbiAgICBub1R5cGVhaGVhZCxcclxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcclxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVSZW5kZXIsXHJcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxyXG4gICAgcmVuZGVyXHJcbn06IFRhYmxlUHJvcHM8VGFibGVFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCByZWY6IFJlZjxUYWJsZUVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZVRhYmxlQm9keSwgdXNlVGFibGVQcm9wcywgdXNlVGFibGVSb3csIC4uLnRhYmxlSW5mbyB9ID0gdXNlQXJpYVRhYmxlPFRhYmxlRWxlbWVudCwgU2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudD4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzIH0sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHt9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8VGFibGVCb2R5Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFibGVCb2R5fT5cclxuICAgICAgICAgICAgPFRhYmxlUm93Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFibGVSb3d9PlxyXG4gICAgICAgICAgICAgICAgeyhyZW5kZXIgPz8gZGVmYXVsdFJlbmRlclRhYmxlKSh0YWJsZUluZm8sIHVzZVRhYmxlUHJvcHMpfVxyXG4gICAgICAgICAgICA8L1RhYmxlUm93Q29udGV4dC5Qcm92aWRlcj5cclxuICAgICAgICA8L1RhYmxlQm9keUNvbnRleHQuUHJvdmlkZXI+XHJcbiAgICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRhYmxlQm9keVU8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgcmVuZGVyXHJcbn06IFRhYmxlQm9keVByb3BzPFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCByZWY6IFJlZjxTZWN0aW9uRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHsgdXNlVGFibGVCb2R5UHJvcHMsIC4uLnNlY3Rpb25JbmZvIH0gPSB1c2VDb250ZXh0KFRhYmxlQm9keUNvbnRleHQpKHt9KTtcclxuICAgIHJldHVybiA8TG9jYXRpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPVwiYm9keVwiPntyZW5kZXIoc2VjdGlvbkluZm8sIHVzZVRhYmxlQm9keVByb3BzKX08L0xvY2F0aW9uQ29udGV4dC5Qcm92aWRlcj5cclxufVxyXG5cclxuZnVuY3Rpb24gVGFibGVIZWFkVTxTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgcmVuZGVyIH06IFRhYmxlSGVhZFByb3BzLCByZWY6IFJlZjxTZWN0aW9uRWxlbWVudD4pIHtcclxuICAgIHJldHVybiA8TG9jYXRpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPVwiaGVhZFwiPnsocmVuZGVyKCkpfTwvTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyPlxyXG59XHJcblxyXG5mdW5jdGlvbiBUYWJsZUZvb3RVPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIgfTogVGFibGVGb290UHJvcHMsIHJlZjogUmVmPFNlY3Rpb25FbGVtZW50Pikge1xyXG4gICAgcmV0dXJuIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9XCJmb290XCI+eyhyZW5kZXIoKSl9PC9Mb2NhdGlvbkNvbnRleHQuUHJvdmlkZXI+XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRhYmxlUm93VTxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xyXG4gICAgaW5kZXgsXHJcbiAgICB0ZXh0LFxyXG4gICAgYmx1clNlbGYsXHJcbiAgICBjb2xsYXRvcixcclxuICAgIGRpc2FibGVBcnJvd0tleXMsXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICBmbGFncyxcclxuICAgIGZvY3VzU2VsZixcclxuICAgIGhpZGRlbixcclxuICAgIGluZGV4RGVtYW5nbGVyLFxyXG4gICAgaW5kZXhNYW5nbGVyLFxyXG4gICAgaW5pdGlhbEluZGV4LFxyXG4gICAgbm9UeXBlYWhlYWQsXHJcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXHJcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXHJcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxyXG4gICAgdHlwZWFoZWFkVGltZW91dCxcclxuICAgIHJlbmRlclxyXG59OiBUYWJsZVJvd1Byb3BzPFJvd0VsZW1lbnQsIENlbGxlbWVudD4sIHJlZjogUmVmPFJvd0VsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZVRhYmxlQ2VsbCwgdXNlVGFibGVSb3dQcm9wcywgLi4ucm93SW5mbyB9ID0gdXNlQ29udGV4dChUYWJsZVJvd0NvbnRleHQpKHtcclxuICAgICAgICBhc0NoaWxkUm93T2ZTZWN0aW9uOiB7XHJcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW4gfSxcclxuICAgICAgICAgICAgc3ViSW5mbzoge31cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFzUGFyZW50Um93T2ZDZWxsczoge1xyXG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cyB9LFxyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciB9LFxyXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0YWJsZVJvdzogeyBsb2NhdGlvbjogdXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIDxUYWJsZUNlbGxDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJsZUNlbGx9PnsocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJUYWJsZVJvdykocm93SW5mbywgdXNlVGFibGVSb3dQcm9wcyh7IHJlZiB9KSl9PC9UYWJsZUNlbGxDb250ZXh0LlByb3ZpZGVyPlxyXG59XHJcblxyXG5mdW5jdGlvbiBUYWJsZUNlbGxVPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBpbmRleCwgdGV4dCwgYmx1clNlbGYsIGZsYWdzLCBmb2N1c1NlbGYsIGhpZGRlbiwgdmFsdWUsIGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmVuZGVyIH06IFRhYmxlQ2VsbFByb3BzPENlbGxFbGVtZW50PiwgcmVmOiBSZWY8Q2VsbEVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZVRhYmxlQ2VsbFByb3BzLCAuLi5jZWxsSW5mbyB9ID0gdXNlQ29udGV4dChUYWJsZUNlbGxDb250ZXh0KSh7XHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW4gfSxcclxuICAgICAgICBoYXNGb2N1czogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UgfSxcclxuICAgICAgICBzdWJJbmZvOiB7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiB1c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCksXHJcbiAgICAgICAgICAgIHZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChyZW5kZXIgPz8gZGVmYXVsdFJlbmRlclRhYmxlQ2VsbCkoY2VsbEluZm8sIHVzZVRhYmxlQ2VsbFByb3BzKHsgcmVmIH0pKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFRhYmxlID0gZm9yd2FyZFJlZihUYWJsZVUpIGFzIHR5cGVvZiBUYWJsZVU7XHJcbmV4cG9ydCBjb25zdCBUYWJsZUJvZHkgPSBmb3J3YXJkUmVmKFRhYmxlQm9keVUpIGFzIHR5cGVvZiBUYWJsZUJvZHlVO1xyXG5leHBvcnQgY29uc3QgVGFibGVIZWFkID0gZm9yd2FyZFJlZihUYWJsZUhlYWRVKSBhcyB0eXBlb2YgVGFibGVIZWFkVTtcclxuZXhwb3J0IGNvbnN0IFRhYmxlRm9vdCA9IGZvcndhcmRSZWYoVGFibGVGb290VSkgYXMgdHlwZW9mIFRhYmxlRm9vdFU7XHJcbmV4cG9ydCBjb25zdCBUYWJsZVJvdyA9IGZvcndhcmRSZWYoVGFibGVSb3dVKSBhcyB0eXBlb2YgVGFibGVSb3dVO1xyXG5leHBvcnQgY29uc3QgVGFibGVDZWxsID0gZm9yd2FyZFJlZihUYWJsZUNlbGxVKSBhcyB0eXBlb2YgVGFibGVDZWxsVTtcclxuXHJcbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xyXG5pbXBvcnQgeyBVc2VBcmlhVGFiLCBVc2VBcmlhVGFiTGlzdFBhcmFtZXRlcnMsIFVzZUFyaWFUYWJMaXN0UmV0dXJuVHlwZUluZm8sIFVzZUFyaWFUYWJQYW5lbCwgVXNlQXJpYVRhYlBhbmVsUGFyYW1ldGVycywgVXNlQXJpYVRhYlBhbmVsUmV0dXJuVHlwZUluZm8sIFVzZUFyaWFUYWJQYXJhbWV0ZXJzLCBVc2VBcmlhVGFiUmV0dXJuVHlwZUluZm8sIHVzZUFyaWFUYWJzLCBVc2VBcmlhVGFic1BhcmFtZXRlcnMsIFVzZUFyaWFUYWJzUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLXRhYnNcIjtcclxuXHJcbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XHJcbnR5cGUgR2V0MjxULCBLIGV4dGVuZHMga2V5b2YgVCwgSzIgZXh0ZW5kcyBrZXlvZiBUW0tdPiA9IFRbS11bSzJdO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUYWJzUHJvcHM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xyXG4gICAgR2V0PFVzZUFyaWFUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJsaXN0TmF2aWdhdGlvblwiPixcclxuICAgIEdldDxVc2VBcmlhVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwibWFuYWdlZENoaWxkcmVuXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcclxuICAgIEdldDxVc2VBcmlhVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwic2luZ2xlU2VsZWN0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+LFxyXG4gICAgR2V0PFVzZUFyaWFUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJjaGlsZHJlbkhhdmVGb2N1c1wiPixcclxuICAgIEdldDxVc2VBcmlhVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwidGFic1wiPixcclxuICAgIEdldDI8VXNlQXJpYVRhYnNQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcInRhYlBhbmVsc1wiLCBcIm1hbmFnZWRDaGlsZHJlblwiPiB7XHJcbiAgICByZW5kZXIodGFic0luZm86IFVzZUFyaWFUYWJzUmV0dXJuVHlwZUluZm8gJiBVc2VBcmlhVGFiTGlzdFJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50PiwgbW9kaWZ5VGFiTGlzdFByb3BzOiBQcm9wTW9kaWZpZXI8TGlzdEVsZW1lbnQ+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUYWJQcm9wczxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHZXQ8VXNlQXJpYVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXHJcbiAgICBHZXQ8VXNlQXJpYVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwibWFuYWdlZENoaWxkXCI+LFxyXG4gICAgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LFxyXG4gICAgR2V0PFVzZUFyaWFUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+IHtcclxuICAgIC8vIHRhZ0xpc3RJdGVtOiBFbGVtZW50VG9UYWc8TGlzdGJveEl0ZW1FbGVtZW50PjtcclxuICAgIC8vIHByb3BzTGlzdEl0ZW06IChhcmdzOiBBcmlhTGlzdGJveFNpbmdsZVByb3BzRGVyaXZlZEZyb20pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3Rib3hJdGVtRWxlbWVudD47XHJcbiAgICByZW5kZXIoaW5mbzogVXNlQXJpYVRhYlJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+LCBtb2RpZnlMaXN0SXRlbTogUHJvcE1vZGlmaWVyPFRhYkVsZW1lbnQ+KTogVk5vZGU8YW55PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUYWJQYW5lbFByb3BzPFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgR2V0PFVzZUFyaWFUYWJQYW5lbFBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkXCI+IHtcclxuICAgIHJlbmRlcihpbmZvOiBVc2VBcmlhVGFiUGFuZWxSZXR1cm5UeXBlSW5mbywgbW9kaWZ5VGFiUGFuZWxQcm9wczogUHJvcE1vZGlmaWVyPFRhYlBhbmVsRWxlbWVudD4pOiBWTm9kZTtcclxufVxyXG5cclxuY29uc3QgVGFiQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQXJpYVRhYjxhbnk+PihudWxsISk7XHJcbmNvbnN0IFRhYlBhbmVsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlQXJpYVRhYlBhbmVsPGFueT4+KG51bGwhKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBUYWJzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcclxuICAgIHNlbGVjdGVkSW5kZXgsXHJcbiAgICBjb2xsYXRvcixcclxuICAgIGRpc2FibGVBcnJvd0tleXMsXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXHJcbiAgICBpbmRleERlbWFuZ2xlcixcclxuICAgIGluZGV4TWFuZ2xlcixcclxuICAgIGluaXRpYWxJbmRleCxcclxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXHJcbiAgICBub1R5cGVhaGVhZCxcclxuICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCxcclxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcclxuICAgIG9uVGFiYmFibGVSZW5kZXIsXHJcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxyXG4gICAgb25BbGxMb3N0Rm9jdXMsXHJcbiAgICBvbkFueUdhaW5lZEZvY3VzLFxyXG4gICAgb25TZWxlY3RlZEluZGV4Q2hhbmdlLFxyXG4gICAgcmVuZGVyXHJcbn06IFRhYnNQcm9wczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBUYWJFbGVtZW50Pikge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUFyaWFUYWJMaXN0LFxyXG4gICAgICAgIHVzZUFyaWFUYWJMaXN0TGFiZWwsXHJcbiAgICAgICAgdXNlQXJpYVRhYlBhbmVsLFxyXG4gICAgICAgIC4uLnRhYnNJbmZvXHJcbiAgICB9ID0gdXNlQXJpYVRhYnM8TGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYlBhbmVsRWxlbWVudCwgTGFiZWxFbGVtZW50Pih7XHJcbiAgICAgICAgdGFiUGFuZWxzOiB7XHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgeyB1c2VBcmlhVGFiLCB1c2VBcmlhVGFiTGlzdFByb3BzLCAuLi50YWJsaXN0SW5mbyB9ID0gdXNlQXJpYVRhYkxpc3Qoe1xyXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH0sXHJcbiAgICAgICAgdGFiczogeyBvblNlbGVjdGVkSW5kZXhDaGFuZ2UgfSxcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciB9LFxyXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4IH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7IHVzZUFyaWFUYWJMaXN0TGFiZWxQcm9wcyB9ID0gdXNlQXJpYVRhYkxpc3RMYWJlbCh7fSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8VGFiQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlQXJpYVRhYn0+XHJcbiAgICAgICAgICAgIDxUYWJQYW5lbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUFyaWFUYWJQYW5lbH0+XHJcbiAgICAgICAgICAgICAgICB7cmVuZGVyKHsgLi4udGFic0luZm8sIC4uLnRhYmxpc3RJbmZvIH0sIHVzZUFyaWFUYWJMaXN0TGFiZWxQcm9wcywgdXNlQXJpYVRhYkxpc3RQcm9wcyl9XHJcbiAgICAgICAgICAgIDwvVGFiUGFuZWxDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgICAgIDwvVGFiQ29udGV4dC5Qcm92aWRlcj5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFRhYjxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBpbmRleCwgdGV4dCwgYmx1clNlbGYsIGZsYWdzLCBmb2N1c1NlbGYsIGhpZGRlbiwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCByZW5kZXIgfTogVGFiUHJvcHM8VGFiRWxlbWVudD4pIHtcclxuICAgIGNvbnN0IHsgdXNlQXJpYVRhYlByb3BzLCAuLi50YWJJbmZvIH0gPSB1c2VDb250ZXh0KFRhYkNvbnRleHQpKHtcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGJsdXJTZWxmLCBmb2N1c1NlbGYsIGhpZGRlbiB9LFxyXG4gICAgICAgIGhhc0ZvY3VzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVuZGVyKHRhYkluZm8sIHVzZUFyaWFUYWJQcm9wcylcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIFRhYlBhbmVsPFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgaW5kZXgsIGZsYWdzLCByZW5kZXIgfTogVGFiUGFuZWxQcm9wczxUYWJQYW5lbEVsZW1lbnQ+KSB7XHJcbiAgICBjb25zdCB7IHVzZUFyaWFUYWJQYW5lbFByb3BzLCAuLi50YWJQYW5lbEluZm8gfSA9IHVzZUNvbnRleHQoVGFiUGFuZWxDb250ZXh0KSh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVuZGVyKHRhYlBhbmVsSW5mbywgdXNlQXJpYVRhYlBhbmVsUHJvcHMpXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFiczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnTGFiZWwsIHRhZ0xpc3QsIG1ha2VQcm9wc0xhYmVsLCBtYWtlUHJvcHNMaXN0LCBwYW5lbHMgfTogeyBwYW5lbHM6IFZOb2RlW10sIHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PiwgdGFnTGlzdDogRWxlbWVudFRvVGFnPExpc3RFbGVtZW50PiwgbWFrZVByb3BzTGFiZWw6IChpbmZvOiBVc2VBcmlhVGFic1JldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+LCBtYWtlUHJvcHNMaXN0OiAoaW5mbzogVXNlQXJpYVRhYnNSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFic0luZm86IFVzZUFyaWFUYWJzUmV0dXJuVHlwZUluZm8gJiBVc2VBcmlhVGFiTGlzdFJldHVyblR5cGVJbmZvPGFueT4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxMYWJlbEVsZW1lbnQ+LCBtb2RpZnlMaXN0UHJvcHM6IFByb3BNb2RpZmllcjxMaXN0RWxlbWVudD4pIHtcclxuICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwgYXMgbmV2ZXIsIG1vZGlmeUxhYmVsUHJvcHMobWFrZVByb3BzTGFiZWwodGFic0luZm8pKSlcclxuICAgICAgICBjb25zdCBsaXN0ID0gY3JlYXRlRWxlbWVudCh0YWdMaXN0IGFzIG5ldmVyLCBtb2RpZnlMaXN0UHJvcHMobWFrZVByb3BzTGlzdCh0YWJzSW5mbykpKTtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8PlxyXG4gICAgICAgICAgICAgICAge2xhYmVsfVxyXG4gICAgICAgICAgICAgICAge2xpc3R9XHJcbiAgICAgICAgICAgICAgICB7cGFuZWxzfVxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFiPFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IG1ha2VQcm9wc1RhYiwgdGFnVGFiIH06IHsgdGFnVGFiOiBFbGVtZW50VG9UYWc8VGFiRWxlbWVudD4sIG1ha2VQcm9wc1RhYjogKGluZm86IFVzZUFyaWFUYWJSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4gfSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YWJJbmZvOiBVc2VBcmlhVGFiUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudD4sIG1vZGlmeVRhYlByb3BzOiBQcm9wTW9kaWZpZXI8VGFiRWxlbWVudD4pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWIgYXMgbmV2ZXIsIG1vZGlmeVRhYlByb3BzKG1ha2VQcm9wc1RhYih0YWJJbmZvKSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYlBhbmVsPFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbWFrZVByb3BzVGFiUGFuZWwsIHRhZ1RhYlBhbmVsIH06IHsgdGFnVGFiUGFuZWw6IEVsZW1lbnRUb1RhZzxUYWJQYW5lbEVsZW1lbnQ+LCBtYWtlUHJvcHNUYWJQYW5lbDogKGluZm86IFVzZUFyaWFUYWJQYW5lbFJldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJQYW5lbEVsZW1lbnQ+IH0pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFiUGFuZWxJbmZvOiBVc2VBcmlhVGFiUGFuZWxSZXR1cm5UeXBlSW5mbywgbW9kaWZ5VGFiUGFuZWxQcm9wczogUHJvcE1vZGlmaWVyPFRhYlBhbmVsRWxlbWVudD4pIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJQYW5lbCBhcyBuZXZlciwgbW9kaWZ5VGFiUGFuZWxQcm9wcyhtYWtlUHJvcHNUYWJQYW5lbCh0YWJQYW5lbEluZm8pKSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUFyaWFUb29sdGlwLCBVc2VUb29sdGlwUGFyYW1ldGVycywgVXNlVG9vbHRpcFJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS10b29sdGlwXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRvb2x0aXBQcm9wczxUVCBleHRlbmRzIEVsZW1lbnQsIFRUVCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVG9vbHRpcFBhcmFtZXRlcnMge1xyXG4gICAgZ2V0RG9jdW1lbnQ6IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzW1wiZ2V0RG9jdW1lbnRcIl07XHJcbiAgICBnZXRXaW5kb3c/OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyc1tcImdldFdpbmRvd1wiXTtcclxuICAgIHJlbmRlcj86IChpbmZvOiBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8sIHRyaWdnZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VFQ+LCB0b29sdGlwUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRUVD4pID0+IFZOb2RlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyKGluZm86IFVzZVRvb2x0aXBSZXR1cm5UeXBlSW5mbywgdHJpZ2dlclByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCB0b29sdGlwUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPGRpdiB7Li4udHJpZ2dlclByb3BzfSAvPlxyXG4gICAgICAgICAgICA8ZGl2IHsuLi50b29sdGlwUHJvcHN9IC8+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIFRvb2x0aXBVPFRUIGV4dGVuZHMgRWxlbWVudCwgVFRUIGV4dGVuZHMgRWxlbWVudD4oeyBmb2N1c0RlbGF5LCBtb3VzZW91dERlbGF5LCBtb3VzZW92ZXJEZWxheSwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgcmVuZGVyIH06IFRvb2x0aXBQcm9wczxUVCwgVFRUPikge1xyXG4gICAgY29uc3QgeyB1c2VUb29sdGlwLCB1c2VUb29sdGlwVHJpZ2dlciwgLi4uaW5mbyB9ID0gdXNlQXJpYVRvb2x0aXA8VFQsIFRUVD4oeyBmb2N1c0RlbGF5LCBtb3VzZW91dERlbGF5LCBtb3VzZW92ZXJEZWxheSB9KTtcclxuICAgIGNvbnN0IHsgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyB9ID0gdXNlVG9vbHRpcFRyaWdnZXIoeyBoYXNGb2N1czogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93IH0gfSk7XHJcbiAgICBjb25zdCB7IHVzZVRvb2x0aXBQcm9wcyB9ID0gdXNlVG9vbHRpcCh7IGhhc0ZvY3VzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3cgfSB9KTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgeyhyZW5kZXIgPz8gZGVmYXVsdFJlbmRlcikoaW5mbywgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyh7fSksIHVzZVRvb2x0aXBQcm9wcyh7fSkgYXMgYW55KX1cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IFRvb2x0aXAgPSBmb3J3YXJkUmVmKFRvb2x0aXBVKSBhcyB1bmtub3duIGFzIHR5cGVvZiBUb29sdGlwVTtcclxuIiwiXHJcbmltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBoLCBSZW5kZXJhYmxlUHJvcHMgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IEFyaWFBY2NvcmRpb24sIEFyaWFBY2NvcmRpb25TZWN0aW9uLCBIZWFkaW5nIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XHJcblxyXG5mdW5jdGlvbiBEZW1vQWNjb3JkaW9uKHsgY2hpbGRyZW4sIC4uLnByb3BzIH06IFJlbmRlcmFibGVQcm9wczx7fT4pIHtcclxuICAgIHJldHVybiA8QXJpYUFjY29yZGlvbiB7Li4ucHJvcHN9IHJlbmRlcj17KGluZm8pID0+IHsgcmV0dXJuIDxkaXYgaWQ9XCJhY2NvcmRpb24tZGVtb1wiPntjaGlsZHJlbn08L2Rpdj4gfX0gLz5cclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XHJcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBEZW1vQWNjb3JkaW9uU2VjdGlvbih7IGluZGV4LCBib2R5LCBoZWFkaW5nLCBkaXNhYmxlZCwgb3BlbiB9OiB7IG9wZW4/OiBib29sZWFuLCBkaXNhYmxlZDogYm9vbGVhbiwgaW5kZXg6IG51bWJlciwgaGVhZGluZzogQ29tcG9uZW50Q2hpbGRyZW4sIGJvZHk6IENvbXBvbmVudENoaWxkcmVuIH0pIHtcclxuICAgIHJldHVybiA8QXJpYUFjY29yZGlvblNlY3Rpb248SFRNTERpdkVsZW1lbnQsIEhUTUxEaXZFbGVtZW50PiBpbmRleD17aW5kZXh9IHRhZ0J1dHRvbj1cImRpdlwiIG9wZW49e29wZW59IGRpc2FibGVkPXtkaXNhYmxlZH0gZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fSByZW5kZXI9eyhpbmZvLCBoZWFkZXJQcm9wcywgYm9keVByb3BzKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9ezxkaXYgey4uLmhlYWRlclByb3BzfT57aGVhZGluZ30gKHshaW5mby5hY2NvcmRpb25TZWN0aW9uLmV4cGFuZGVkICYmIFwibm90IFwifSBvcGVuKSwgKHshaW5mby5hY2NvcmRpb25TZWN0aW9uLmZvY3VzZWQgJiYgXCJub3QgXCJ9IGZvY3VzZWQpPC9kaXY+fT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IHsuLi5ib2R5UHJvcHN9Pntib2R5fTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9IZWFkaW5nPlxyXG4gICAgICAgICAgICA8Lz5cclxuICAgICAgICApXHJcbiAgICB9fT48L0FyaWFBY2NvcmRpb25TZWN0aW9uPlxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2FjY29yZGlvbi9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgQWNjb3JkaW9uIHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5FYWNoIHNlY3Rpb24ncyBoZWFkZXIgYW5kIGJvZHkgYXJlIGxpbmtlZCB2aWEgSUQ7IHRoZSBib2R5IGlzIDxjb2RlPmxhYmVsbGVkLWJ5PC9jb2RlPiB0aGUgaGVhZGVyIGFuZCB0aGUgaGVhZGVyIDxjb2RlPmNvbnRyb2w8L2NvZGU+cyB0aGUgYm9keS48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRoZSBoZWFkZXIgaXMgYSBidXR0b24gYW5kIHJlc3BvbmRzIHRvIGtleWJvYXJkLCBtb3VzZSwgdG91Y2gsIGV0Yy4gZXZlbnRzLCByZWdhcmRsZXNzIG9mIHRoZSBlbGVtZW50IHVzZWQuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5JZiB0aGUgaGVhZGVyIGVsZW1lbnQgaXMgbm90IGEgPGNvZGU+Jmx0O2J1dHRvbiZndDs8L2NvZGU+IGVsZW1lbnQsIGl0IGlzIGdpdmVuIHRoYXQgPGNvZGU+cm9sZTwvY29kZT4uPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5VcC9kb3duICZhbXA7IEhvbWUvRW5kIGtleXMgbmF2aWdhdGUgdGhyb3VnaCB0aGUgbGlzdCwgYXMgZG9lcyBUYWIgYW5kIFNoaWZ0K1RhYjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+PC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIDxjb2RlPnJlbmRlcjwvY29kZT4gcHJvcCBlYWNoIDxjb2RlPkFjY29yZGlvblNlY3Rpb248L2NvZGU+IHRha2VzIG11c3Qgd3JhcCB0aGUgaGVhZGVyIGJ1dHRvbiB3aXRoIGEgPGEgaHJlZj1cImh0dHBzOi8vdzNjLmdpdGh1Yi5pby9hcmlhLyNoZWFkaW5nXCI+aGVhZGluZzwvYT4gKGUuZy4gPGNvZGU+aDM8L2NvZGU+LCBvciA8Y29kZT4mbHQ7SGVhZGluZyZndDs8L2NvZGU+KS4gU2VlIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBhbiBleGFtcGxlLjwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xyXG4gICAgcmV0dXJuICg8Y29kZT57YDxBcmlhQWNjb3JkaW9uIHJlbmRlcj17Li4ufT5cclxuICAgIDxBcmlhQWNjb3JkaW9uU2VjdGlvbiBpbmRleD17MH0gcmVuZGVyPXsuLi59IC8+XHJcbiAgICA8QXJpYUFjY29yZGlvblNlY3Rpb24gaW5kZXg9ezF9IHJlbmRlcj17Li4ufSAvPlxyXG4gICAgPEFyaWFBY2NvcmRpb25TZWN0aW9uIGluZGV4PXsyfSByZW5kZXI9ey4uLn0gLz5cclxuPC9BcmlhQWNjb3JkaW9uPmB9PC9jb2RlPilcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPERlbW9BY2NvcmRpb24+XHJcbiAgICAgICAgICAgICAgICA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezB9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjMFwiIGJvZHk9XCJCb2R5IGNvbnRlbnQgIzBcIiBkaXNhYmxlZD17ZmFsc2V9IC8+XHJcbiAgICAgICAgICAgICAgICA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezF9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjMVwiIGJvZHk9XCJCb2R5IGNvbnRlbnQgIzFcIiBkaXNhYmxlZD17ZmFsc2V9IC8+XHJcbiAgICAgICAgICAgICAgICA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezJ9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjMiAoZGlzYWJsZWQpXCIgYm9keT1cIkJvZHkgY29udGVudCAjMlwiIGRpc2FibGVkPXt0cnVlfSAvPlxyXG4gICAgICAgICAgICAgICAgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXszfSBoZWFkaW5nPVwiQWNjb3JkaW9uIHNlY3Rpb24gIzMgKGZvcmNlZCBvcGVuKVwiIGJvZHk9XCJCb2R5IGNvbnRlbnQgIzNcIiBkaXNhYmxlZD17ZmFsc2V9IG9wZW49e3RydWV9IC8+XHJcbiAgICAgICAgICAgICAgICA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezR9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjNCAoZm9yY2VkIGNsb3NlZClcIiBib2R5PVwiQm9keSBjb250ZW50ICM0XCIgZGlzYWJsZWQ9e2ZhbHNlfSBvcGVuPXtmYWxzZX0gLz5cclxuICAgICAgICAgICAgPC9EZW1vQWNjb3JkaW9uPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59IiwiXHJcbmltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBoLCBSZW5kZXJhYmxlUHJvcHMgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgQXJpYUJ1dHRvbiwgRXZlbnREZXRhaWwsIGRlZmF1bHRSZW5kZXJCdXR0b24gfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcclxuXHJcbi8qZnVuY3Rpb24gRGVtb0J1dHRvbih7IHRhZywgLi4ucHJvcHMgfTogeyB0YWc6IHN0cmluZyB9ICYgUmVuZGVyYWJsZVByb3BzPHt9Pikge1xyXG4gICAgcmV0dXJuIDxBcmlhQnV0dG9uIGRpc2FibGVkPXtkaXNhYmxlZH0gb25QcmVzcz17b25QcmVzc30gcHJlc3NlZD17fSB7Li4ucHJvcHN9IHRhZz17dGFnIGFzIGFueX0gICAvPlxyXG59Ki9cclxuXHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9idXR0b24vXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIEJ1dHRvbiBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+V2hldGhlciB1c2luZyBhbiBhY3R1YWwgPGNvZGU+Jmx0O2J1dHRvbiZndDs8L2NvZGU+LCBvciBzb21ldGhpbmcgZWxzZSBsaWtlIGEgPGNvZGU+Jmx0O2RpdiZndDs8L2NvZGU+LCB0aGUgcHJvcGVyIHJvbGVzIGFuZCBldmVudCBoYW5kbGVycyB3aWxsIGJlIGFwcGxpZWQuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5CdXR0b25zIGNhbiBiZSB0b2dnbGVkIChwcmVzc2VkIG9yIHVucHJlc3NlZCkuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgYnV0dG9uIHJlc3BvbmRzIHRvIGtleWJvYXJkLCBtb3VzZSwgdG91Y2gsIGV0Yy4gZXZlbnRzLCByZWdhcmRsZXNzIG9mIHRoZSBlbGVtZW50IHVzZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+RG91YmxlLWNsaWNrcyBkbyBub3Qgc2VsZWN0IHRleHQsIGJ1dCB0ZXh0IGlzIHN0aWxsIHNlbGVjdGFibGUgd2l0aG91dCBpdCBjb3VudGluZyBhcyBhIHByZXNzL2NsaWNrPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPldoZW4gRW50ZXIgaXMgcHJlc3NlZCwgdGhlIGJ1dHRvbiBpcyBpbW1lZGlhdGVseSBhY3RpdmF0ZWQ8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+V2hlbiBTcGFjZSBpcyBwcmVzc2VkLCB0aGUgYnV0dG9uIGlzIGFjdGl2YXRlZCBvbmNlIHJlbGVhc2VkPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPmlPUyBTYWZhcmkgcHJvcGVybHkgZm9jdXNlcyB0aGUgYnV0dG9uPC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+SWYgeW91ciBidXR0b24gY29udGFpbnMgb25seSBhbiBpY29uIChvciBvdGhlciBub24tZGVzY3JpcHRpdmUgY29udGVudCwgZXRjLiksIHlvdSBtdXN0IHByb3ZpZGUgYW4gPGNvZGU+YXJpYS1sYWJlbDwvY29kZT4gbWFudWFsbHkgc3RhdGluZyB3aGF0IGhhcHBlbnMgd2hlbiB0aGUgYnV0dG9uIGlzIHByZXNzZWQuPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XHJcbiAgICByZXR1cm4gKDxjb2RlPntgPEFyaWFCdXR0b24gdGFnPVwiYnV0dG9uXCI+QnV0dG9uPC9BcmlhQnV0dG9uPlxyXG4gICAgPEFyaWFCdXR0b24gdGFnPVwiZGl2XCI+RGl2PC9BcmlhQnV0dG9uPmB9PC9jb2RlPilcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XHJcblxyXG4gICAgY29uc3Qgb25QcmVzcyA9ICgpID0+IHsgYWxlcnQoXCJCdXR0b24gY2xpY2tlZFwiKSB9XHJcbiAgICBjb25zdCBbcHJlc3NlZCwgc2V0UHJlc3NlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbjtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPEJsdXJiIC8+XHJcbiAgICAgICAgICAgIDxDb2RlIC8+XHJcbiAgICAgICAgICAgIDxEZW1vQnV0dG9uIGRpc2FibGVkPXtmYWxzZX0gdGFnPVwiYnV0dG9uXCIgLz5cclxuICAgICAgICAgICAgPERlbW9CdXR0b24gZGlzYWJsZWQ9XCJzb2Z0XCIgdGFnPVwiYnV0dG9uXCIgLz5cclxuICAgICAgICAgICAgPERlbW9CdXR0b24gZGlzYWJsZWQ9XCJoYXJkXCIgdGFnPVwiYnV0dG9uXCIgLz5cclxuICAgICAgICAgICAgPERlbW9CdXR0b24gZGlzYWJsZWQ9e2ZhbHNlfSB0YWc9XCJkaXZcIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0J1dHRvbiBkaXNhYmxlZD1cInNvZnRcIiB0YWc9XCJkaXZcIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0J1dHRvbiBkaXNhYmxlZD1cImhhcmRcIiB0YWc9XCJkaXZcIiAvPlxyXG4gICAgICAgICAgICA8QXJpYUJ1dHRvbiBkaXNhYmxlZD17ZmFsc2V9IHRhZz1cImJ1dHRvblwiIHByZXNzZWQ9e3ByZXNzZWR9IG9uUHJlc3M9e2UgPT4gc2V0UHJlc3NlZChlW0V2ZW50RGV0YWlsXS5wcmVzc2VkID8/IGZhbHNlKX0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyQnV0dG9uKFwiYnV0dG9uXCIsICgpID0+ICh7IGNoaWxkcmVuOiBgQnV0dG9uICgke3ByZXNzZWQ/IFwicHJlc3NlZFwiIDogXCJ1bnByZXNzZWRcIn0pYH0pKX0gLz5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZnVuY3Rpb24gRGVtb0J1dHRvbih7IHRhZywgZGlzYWJsZWR9OiB7IHRhZzogc3RyaW5nLCBkaXNhYmxlZDogYm9vbGVhbiB8IFwic29mdFwiIHwgXCJoYXJkXCIgfSkge1xyXG4gICAgY29uc3Qgb25QcmVzcyA9ICgpID0+IHsgYWxlcnQoXCJCdXR0b24gY2xpY2tlZFwiKSB9XHJcblxyXG4gICAgcmV0dXJuICggXHJcbiAgICAgICAgPEFyaWFCdXR0b24gdGFnPXt0YWcgYXMgYW55fSByZW5kZXI9e2RlZmF1bHRSZW5kZXJCdXR0b24odGFnLCAoe30pID0+ICh7IGNsYXNzOiBcImJ0blwiLCBjaGlsZHJlbjogYCR7dGFnfSAke2Rpc2FibGVkPyBgIGRpc2FibGVkICgke2Rpc2FibGVkID09IFwic29mdFwiPyBcInNvZnRcIiA6IFwiaGFyZFwifSlgIDogXCJcIn1gIH0pKX0gIC8+XHJcbiAgICApXHJcbn0iLCJcclxuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGgsIFJlbmRlcmFibGVQcm9wcyB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBBcmlhQnV0dG9uLCBBcmlhQ2hlY2tib3gsIEV2ZW50RGV0YWlsLCBkZWZhdWx0UmVuZGVyQnV0dG9uLCBkZWZhdWx0UmVuZGVyQ2hlY2tib3ggfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcclxuXHJcbi8qZnVuY3Rpb24gRGVtb0J1dHRvbih7IHRhZywgLi4ucHJvcHMgfTogeyB0YWc6IHN0cmluZyB9ICYgUmVuZGVyYWJsZVByb3BzPHt9Pikge1xyXG4gICAgcmV0dXJuIDxBcmlhQnV0dG9uIGRpc2FibGVkPXtkaXNhYmxlZH0gb25QcmVzcz17b25QcmVzc30gcHJlc3NlZD17fSB7Li4ucHJvcHN9IHRhZz17dGFnIGFzIGFueX0gICAvPlxyXG59Ki9cclxuXHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9jaGVja2JveC9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgQ2hlY2tib3ggcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRvZ2dsZXMgYmV0d2VlbiBjaGVja2VkIGFuZCB1bmNoZWNrZWQgd2hlbiBwcmVzc2VkIChjbGlja2VkLCBFbnRlciBwcmVzc2VkLCBTcGFjZSByZWxlYXNlZCwgZXRjLik8L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPkNhbiBiZSA8Y29kZT5taXhlZDwvY29kZT4gaW5zdGVhZCwgdGhvdWdoIDxjb2RlPm9uSW5wdXQ8L2NvZGU+IHdpbGwgb25seSBldmVyIGJlIGNhbGxlZCB3aXRoIDxjb2RlPnRydWU8L2NvZGU+IG9yIDxjb2RlPmZhbHNlPC9jb2RlPjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+U3VwcG9ydHMgdXNpbmcgPGNvZGU+Jmx0O2lucHV0Jmd0OzwvY29kZT5zIGFuZCA8Y29kZT4mbHQ7bGFiZWwmZ3Q7PC9jb2RlPnMsIGFzIHdlbGwgYXMganVzdCBwbGFpbiBvbCcgPGNvZGU+Jmx0O2RpdiZndDs8L2NvZGU+cyBvbiBlaXRoZXIvYm90aDwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIGNoZWNrYm94IGFuZCBsYWJlbCBjYW4gYmUgc2libGluZyBlbGVtZW50cywgbGlrZSBub3JtYWwsIG9yIHRoZSBsYWJlbCBjYW4gd3JhcCB0aGUgaW5wdXQgZm9yIGEgbGFyZ2VyIGhpdCBhcmVhLiBJbiBhbGwgY2FzZXMsIHRoZSBhcHByb3ByaWF0ZSByb2xlcy9ldmVudCBoYW5kbGVycyB3aWxsIGJlIGFwcGxpZWQgdG8gZWFjaCBlbGVtZW50LjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+V2hlbiBzZWxlY3RpbmcgdGhlIHRleHQgb2YgYSBjaGVja2JveCdzIGxhYmVsLCB0aGlzIGRvZXMgbm90IGNoYW5nZSB0aGUgY2hlY2tib3gncyBzdGF0ZTwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+RG91YmxlLWNsaWNraW5nIHRoZSBsYWJlbCBjaGVja3MgJmFtcDsgdW4tY2hlY2tzIHRoZSBjaGVja2JveCBpbnN0ZWFkIG9mIHNlbGVjdGluZyB0aGUgbGFiZWwncyB0ZXh0PC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5DaGVja2JveCBncm91cHMgKHdpdGggYSB0cmktc3RhdGUgcGFyZW50KSBhcmUgYSBzZXBhcmF0ZSBjb21wb25lbnQvaG9vazwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpPklmIHlvdXIgY2hlY2tib3ggZG9lcyBub3QgaGF2ZSBhIHZpc2libGUgbGFiZWwgKGFjaGlldmFibGUgYnkgYnkgb3ZlcnJpZGluZyB0aGUgPGNvZGU+cmVuZGVyPC9jb2RlPiBwcm9wIGFuZCBzZXR0aW5nIDxjb2RlPmxhYmVsUG9zaXRpb248L2NvZGU+IHRvIGJlIFwic2VwYXJhdGVcIiksIHlvdSBtdXN0IHBhc3MgPGNvZGU+YXJpYS1sYWJlbDwvY29kZT4gYXMgYSBwcm9wIHRvIHRoZSBjaGVja2JveCBtYW51YWxseS4gTm90IHByb3ZpZGluZyBvbmUgd2lsbCBwcmludCBhbiBlcnJvciB0byB0aGUgY29uc29sZSwgYnV0IGl0IGl0IG5vdCByZXF1aXJlZCBieSB0aGUgdHlwZSBzeXN0ZW0uPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XHJcbiAgICByZXR1cm4gKDxjb2RlPntgPEFyaWFDaGVja2JveCBjaGVja2VkPXt0cnVlfSBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIiB0YWdJbnB1dD1cImlucHV0XCIgdGFnTGFiZWw9XCJsYWJlbFwiPkxhYmVsIHRleHQ8L0FyaWFDaGVja2JveD5gfTwvY29kZT4pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xyXG5cclxuICAgIGNvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPEFyaWFCdXR0b24gdGFnPVwiYnV0dG9uXCIgb25QcmVzcz17KCkgPT4geyBzZXRDaGVja2VkKFwibWl4ZWRcIiBhcyBhbnkpOyB9fSByZW5kZXI9e2RlZmF1bHRSZW5kZXJCdXR0b24oXCJidXR0b25cIiwgKCkgPT4gKHsgY2hpbGRyZW46IFwiQ2hhbmdlIHRvIG1peGVkXCIgfSkpfSAvPlxyXG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwibGFiZWxcIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGxhYmVsUG9zaXRpb249XCJ3cmFwcGluZ1wiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwibGFiZWxcIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJkaXZcIiB0YWdMYWJlbD1cImxhYmVsXCIgLz5cclxuICAgICAgICAgICAgPERlbW9DaGVja2JveCBsYWJlbFBvc2l0aW9uPVwid3JhcHBpbmdcIiBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiZGl2XCIgdGFnTGFiZWw9XCJsYWJlbFwiIC8+XHJcbiAgICAgICAgICAgIDxEZW1vQ2hlY2tib3ggbGFiZWxQb3NpdGlvbj1cInNlcGFyYXRlXCIgZGlzYWJsZWQ9e2ZhbHNlfSB0YWdJbnB1dD1cImlucHV0XCIgdGFnTGFiZWw9XCJkaXZcIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGxhYmVsUG9zaXRpb249XCJ3cmFwcGluZ1wiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwiZGl2XCIgLz5cclxuICAgICAgICAgICAgPERlbW9DaGVja2JveCBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIiBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiZGl2XCIgdGFnTGFiZWw9XCJkaXZcIiAvPlxyXG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGxhYmVsUG9zaXRpb249XCJ3cmFwcGluZ1wiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJkaXZcIiB0YWdMYWJlbD1cImRpdlwiIC8+XHJcbiAgICAgICAgICAgIDxEZW1vQ2hlY2tib3ggbGFiZWxQb3NpdGlvbj1cImhpZGRlblwiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwibGFiZWxcIiAvPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBEZW1vQ2hlY2tib3goeyBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIGRpc2FibGVkIH06IHsgZGlzYWJsZWQ6IGJvb2xlYW4sIGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIiB8IFwid3JhcHBpbmdcIiB8IFwiaGlkZGVuXCIsIHRhZ0lucHV0OiBzdHJpbmcsIHRhZ0xhYmVsOiBzdHJpbmcgfSkge1xyXG4gICAgY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHN0eWxlPXt7IGJvcmRlcjogXCIxcHggc29saWQgYmxhY2tcIiB9fT5cclxuICAgICAgICAgICAgPEFyaWFDaGVja2JveFxyXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxyXG4gICAgICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cclxuICAgICAgICAgICAgICAgIG9uSW5wdXQ9e2UgPT4gc2V0Q2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKX1cclxuICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb249e2xhYmVsUG9zaXRpb24gPT0gXCJoaWRkZW5cIiA/IFwic2VwYXJhdGVcIiA6IGxhYmVsUG9zaXRpb259XHJcbiAgICAgICAgICAgICAgICB0YWdJbnB1dD17dGFnSW5wdXQgYXMgbmV2ZXJ9XHJcbiAgICAgICAgICAgICAgICB0YWdMYWJlbD17dGFnTGFiZWwgYXMgbmV2ZXJ9XHJcbiAgICAgICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJDaGVja2JveCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICB0YWdJbnB1dCxcclxuICAgICAgICAgICAgICAgICAgICB0YWdMYWJlbCxcclxuICAgICAgICAgICAgICAgICAgICBtYWtlSW5wdXRQcm9wczogKCkgPT4gKHsgXCJhcmlhLWxhYmVsXCI6IGxhYmVsUG9zaXRpb24gPT0gXCJoaWRkZW5cIiA/IGBIaWRkZW4gbGFiZWwgKHRlY2huaWNhbGx5IHNlcGFyYXRlKSwgJHt0YWdJbnB1dH0gYW5kICR7dGFnTGFiZWx9ICR7Y2hlY2tlZCA/IFwiY2hlY2tlZFwiIDogXCJub3QgY2hlY2tlZFwifWAgOiB1bmRlZmluZWQsIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIG1ha2VMYWJlbFByb3BzOiAoKSA9PiAoeyBjaGlsZHJlbjogYCR7bGFiZWxQb3NpdGlvbn0sICR7dGFnSW5wdXR9IGFuZCAke3RhZ0xhYmVsfSwgJHtjaGVja2VkID8gXCJjaGVja2VkXCIgOiBcIm5vdCBjaGVja2VkXCJ9YCB9KVxyXG4gICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIHtsYWJlbFBvc2l0aW9uID09IFwiaGlkZGVuXCIgJiYgPGRpdj4oVGhpcyBpcyBub3QgYSBsYWJlbCAtLSB0aGUgYWN0dWFsIGxhYmVsIGlzIHZpYSB0aGUgPGNvZGU+YXJpYS1sYWJlbDwvY29kZT4gcHJvcCk8L2Rpdj59XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApXHJcbn1cclxuIiwiXHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgQ2hlY2tib3hHcm91cCwgQ2hlY2tib3hHcm91cENoZWNrYm94LCBkZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cCwgZGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBDaGlsZCwgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcclxuXHJcbmZ1bmN0aW9uIERlbW9DaGVja2JveCh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XHJcbiAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBsYWJlbFRleHQgPSBgQ2hlY2tib3ggIyR7aW5kZXh9YFxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8Q2hlY2tib3hHcm91cENoZWNrYm94IHJlbmRlcj17ZGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBDaGlsZCh7XHJcbiAgICAgICAgICAgIGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIixcclxuICAgICAgICAgICAgdGFnSW5wdXQ6IFwiaW5wdXRcIixcclxuICAgICAgICAgICAgdGFnTGFiZWw6IFwibGFiZWxcIixcclxuICAgICAgICAgICAgbWFrZUlucHV0UHJvcHM6ICgpID0+ICh7fSksXHJcbiAgICAgICAgICAgIG1ha2VMYWJlbFByb3BzOiAoKSA9PiAoeyBjaGlsZHJlbjogbGFiZWxUZXh0IH0pXHJcbiAgICAgICAgfSl9XHJcbiAgICAgICAgICAgIGNoZWNrZWQ9e2NoZWNrZWR9XHJcbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cclxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZhbHNlfVxyXG4gICAgICAgICAgICBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIlxyXG4gICAgICAgICAgICB0ZXh0PXtsYWJlbFRleHR9XHJcbiAgICAgICAgICAgIHRhZ0lucHV0PVwiaW5wdXRcIlxyXG4gICAgICAgICAgICB0YWdMYWJlbD1cImxhYmVsXCJcclxuICAgICAgICAgICAgb25JbnB1dD17ZSA9PiBzZXRDaGVja2VkKGVbRXZlbnREZXRhaWxdLmNoZWNrZWQpfSAvPlxyXG4gICAgKVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPHA+Q2hlY2tib3ggZ3JvdXBzIGFyZSBhbiBhbHRlcm5hdGl2ZSB0byBtdWx0aS1zZWxlY3QgbGlzdHMuIFRoZXJlIGlzIG5vIHJvbGUgb2YgPGNvZGU+Y2hlY2tib3hncm91cDwvY29kZT4sIGJ1dCB0aGlzIGFpbXMgdG8gYmUgYW4gQVJJQS1jb21wbGlhbnQgaW1wbGVtZW50YXRpb24gb2YgYSBjaGVja2JveCBncm91cC48L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5BbGwgbm9ybWFsIDxjb2RlPkFyaWFDaGVja2JveDwvY29kZT4gZnVuY3Rpb25hbGl0eSBpcyBzdXBwb3J0ZWQgb24gZWFjaCBpbmRpdmlkdWFsIGNoZWNrYm94LjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIHBhcmVudCBjaGVja2JveCBzd2l0Y2hlcyBiZXR3ZWVuIDMgc3RhdGVzLCByZW1lbWJlcmluZyB0aGUgbGFzdCBzdGF0ZSB0aGF0IGNhdXNlZCBpdCB0byBiZSBcIm1peGVkXCIuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgcGFyZW50IGNoZWNrYm94IHJlYWN0cyB0byBlYWNoIGNoaWxkJ3MgPGNvZGU+Y2hlY2tlZDwvY29kZT4gcHJvcCBhbmQgdXBkYXRlcyBpdHMgb3duIGludGVybmFsIDxjb2RlPmNoZWNrZWQ8L2NvZGU+IGF0dHJpYnV0ZSAoYmUgYXdhcmUgb2YgdGhpcyBpZiB0aGV5J3JlIGFzeW5jcm9ub3VzLCBhcyB5b3UnbGwgd2FudCB0byBlbnN1cmUgdGhleSBhbGwgcmVzb2x2ZSBvbiB0aGUgc2FtZSB0aWNrIHdpdGggPGNvZGU+UHJvbWlzZS5hbGw8L2NvZGU+IHRvIG5vdCBjbG9iYmVyIHRoZSB1c2VyJ3MgaW5wdXRzKS48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRoZSBjaGlsZHJlbiBhcmUgdHJlYXRlZCBhcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgd2l0aCBsaXN0IG5hdmlnYXRpb247IHNlZSA8Y29kZT5BaXJhU2luZ2xlU2VsZWN0TGlzdDwvY29kZT4gZm9yIG1vcmUgaW5mb3JtYXRpb248L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5JdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHBhcmVudCBjaGVja2JveCBwcm92aWRlcyBzdWZmaWNpZW50IGxhYmVsbGluZyBmb3IgYWxsIHRoZSBjaGlsZHJlbiwgd2hpY2ggaG93IHRoZSBkZW1vIGV4YW1wbGUgaWRlbnRpZmllcyB0aGVzZSBlbGVtZW50cy4gSWYgeW91IGhhdmUgYSBzZXBhcmF0ZSBsYWJlbCwgeW91IHdpbGwgbmVlZCB0byB3cmFwIHRoZSBjaGlsZHJlbiBpbiBhIDxjb2RlPnJvbGU9Z3JvdXA8L2NvZGU+IHRoYXQgcmVmZXJlbmNlcyB0aGF0IGxhYmVsIGJ5IG92ZXJyaWRpbmcgPGNvZGU+cmVuZGVyPC9jb2RlPi48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlNlZSB0aGUgY2F2ZWF0IGFib3ZlIGZvciB3aGVuIGVhY2ggY2hpbGQncyA8Y29kZT5vbklucHV0PC9jb2RlPiB0YWtlcyBhIHZhcmlhYmxlIGFtb3VudCBvZiB0aW1lIHRvIGFjdHVhbGx5IHVwZGF0ZSB0aGUgPGNvZGU+Y2hlY2tlZDwvY29kZT4gcHJvcCwgYXMgaXQgY2FuIGNsb2JiZXIgdGhlIHVzZXIncyBsYXN0IGlucHV0IHdoZW4gY2xpY2tpbmcgb24gdGhlIHBhcmVudDwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xyXG4gICAgcmV0dXJuICg8Y29kZT57YGB9PC9jb2RlPilcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XHJcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDUpO1xyXG5cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxCbHVyYiAvPlxyXG4gICAgICAgICAgICA8Q29kZSAvPlxyXG4gICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49ezB9IHZhbHVlPXtjb3VudH0gb25JbnB1dD17ZSA9PiBzZXRDb3VudChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+ICMgb2YgY2hlY2tib3hlczwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8Q2hlY2tib3hHcm91cCBkaXNhYmxlZD17ZmFsc2V9IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIHRhZ0lucHV0PVwiaW5wdXRcIiB0YWdMYWJlbD1cImxhYmVsXCIgcmVuZGVyPXtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnSW5wdXQ6IFwiaW5wdXRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTGFiZWw6IFwibGFiZWxcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZUlucHV0UHJvcHM6ICgpID0+ICh7fSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VMYWJlbFByb3BzOiAoKSA9PiAoe30pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogQXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxkaXY+PERlbW9DaGVja2JveCBpbmRleD17aX0ga2V5PXtpfSAvPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufSIsIlxyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IExpc3Rib3hNdWx0aUl0ZW0gfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50L2xpc3Rib3gtbXVsdGlcIjtcclxuaW1wb3J0IHsgRXZlbnREZXRhaWwsIExpc3Rib3hNdWx0aSwgZGVmYXVsdFJlbmRlckxpc3Rib3hNdWx0aSwgZGVmYXVsdFJlbmRlckxpc3Rib3hNdWx0aUl0ZW0gfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcclxuXHJcbi8qZnVuY3Rpb24gRGVtb0J1dHRvbih7IHRhZywgLi4ucHJvcHMgfTogeyB0YWc6IHN0cmluZyB9ICYgUmVuZGVyYWJsZVByb3BzPHt9Pikge1xyXG4gICAgcmV0dXJuIDxBcmlhQnV0dG9uIGRpc2FibGVkPXtkaXNhYmxlZH0gb25QcmVzcz17b25QcmVzc30gcHJlc3NlZD17fSB7Li4ucHJvcHN9IHRhZz17dGFnIGFzIGFueX0gICAvPlxyXG59Ki9cclxuXHJcbmZ1bmN0aW9uIERlbW9MaXN0SXRlbSh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XHJcbiAgICBjb25zdCBbc2VsZWN0ZWQsIHNldFNlbGVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IGxhYmVsVGV4dCA9IGBMaXN0IGl0ZW0gIyR7aW5kZXh9JHtzZWxlY3RlZCA/IFwiIChzZWxlY3RlZClcIiA6IFwiXCJ9YFxyXG5cclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8TGlzdGJveE11bHRpSXRlbSBzZWxlY3RlZD17c2VsZWN0ZWR9IGluZGV4PXtpbmRleH0gZGlzYWJsZWQ9e2ZhbHNlfSB0ZXh0PXtsYWJlbFRleHR9IG9uU2VsZWN0PXtlID0+IHsgc2V0U2VsZWN0ZWQoZVtFdmVudERldGFpbF0uc2VsZWN0ZWQpIH19IHJlbmRlcj17ZGVmYXVsdFJlbmRlckxpc3Rib3hNdWx0aUl0ZW0oeyB0YWdMaXN0SXRlbTogXCJsaVwiLCBtYWtlUHJvcHNMaXN0SXRlbTogKCkgPT4gKHsgY2hpbGRyZW46IGxhYmVsVGV4dCB9KSB9KX0gLz5cclxuICAgIClcclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2xpc3Rib3gvXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIExpc3Rib3ggcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRoZSBjaGlsZHJlbiBhcmUgdHJlYXRlZCBhcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgd2l0aCBsaXN0IG5hdmlnYXRpb247IHNlZSA8Y29kZT5BaXJhU2luZ2xlU2VsZWN0TGlzdDwvY29kZT4gZm9yIG1vcmUgaW5mb3JtYXRpb248L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPlRoZSBwYXJlbnQgY2hlY2tib3ggc3dpdGNoZXMgYmV0d2VlbiAzIHN0YXRlcywgcmVtZW1iZXJpbmcgdGhlIGxhc3Qgc3RhdGUgdGhhdCBjYXVzZWQgaXQgdG8gYmUgXCJtaXhlZFwiLjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIHBhcmVudCBjaGVja2JveCByZWFjdHMgdG8gZWFjaCBjaGlsZCdzIDxjb2RlPmNoZWNrZWQ8L2NvZGU+IHByb3AgYW5kIHVwZGF0ZXMgaXRzIG93biBpbnRlcm5hbCA8Y29kZT5jaGVja2VkPC9jb2RlPiBhdHRyaWJ1dGUgKGJlIGF3YXJlIG9mIHRoaXMgaWYgdGhleSdyZSBhc3luY3Jvbm91cywgYXMgeW91J2xsIHdhbnQgdG8gZW5zdXJlIHRoZXkgYWxsIHJlc29sdmUgb24gdGhlIHNhbWUgdGljayB3aXRoIDxjb2RlPlByb21pc2UuYWxsPC9jb2RlPiB0byBub3QgY2xvYmJlciB0aGUgdXNlcidzIGlucHV0cykuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgY2hpbGRyZW4gYXJlIHRyZWF0ZWQgYXMgYSBjb21wb3NpdGUgY29tcG9uZW50IHdpdGggbGlzdCBuYXZpZ2F0aW9uOyBzZWUgPGNvZGU+QWlyYVNpbmdsZVNlbGVjdExpc3Q8L2NvZGU+IGZvciBtb3JlIGluZm9ybWF0aW9uPC9saT4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICA8bGk+R3JvdXBpbmcgaXMgc3VwcG9ydGVkPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5Tb3J0aW5nL3Jlb3JkZXJpbmcgaXMgc3VwcG9ydGVkLCB0aG91Z2ggbm90IHByb3ZpZGVkIGJ5IGRlZmF1bHQsIGFzIGl0J3MgbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggZ3JvdXBpbmcuPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+SXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBwYXJlbnQgY2hlY2tib3ggcHJvdmlkZXMgc3VmZmljaWVudCBsYWJlbGxpbmcgZm9yIGFsbCB0aGUgY2hpbGRyZW4sIHdoaWNoIGhvdyB0aGUgZGVtbyBleGFtcGxlIGlkZW50aWZpZXMgdGhlc2UgZWxlbWVudHMuIElmIHlvdSBoYXZlIGEgc2VwYXJhdGUgbGFiZWwsIHlvdSB3aWxsIG5lZWQgdG8gd3JhcCB0aGUgY2hpbGRyZW4gaW4gYSA8Y29kZT5yb2xlPWdyb3VwPC9jb2RlPiB0aGF0IHJlZmVyZW5jZXMgdGhhdCBsYWJlbCBieSBvdmVycmlkaW5nIDxjb2RlPnJlbmRlcjwvY29kZT4uPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5TZWUgdGhlIGNhdmVhdCBhYm92ZSBmb3Igd2hlbiBlYWNoIGNoaWxkJ3MgPGNvZGU+b25JbnB1dDwvY29kZT4gdGFrZXMgYSB2YXJpYWJsZSBhbW91bnQgb2YgdGltZSB0byBhY3R1YWxseSB1cGRhdGUgdGhlIDxjb2RlPmNoZWNrZWQ8L2NvZGU+IHByb3AsIGFzIGl0IGNhbiBjbG9iYmVyIHRoZSB1c2VyJ3MgbGFzdCBpbnB1dCB3aGVuIGNsaWNraW5nIG9uIHRoZSBwYXJlbnQ8L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcclxuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xyXG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIGxpc3QgaXRlbXM8L2xhYmVsPlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPExpc3Rib3hNdWx0aSB0YWdMYWJlbD1cImxhYmVsXCIgdGFnTGlzdD1cInVsXCIgcmVuZGVyPXtkZWZhdWx0UmVuZGVyTGlzdGJveE11bHRpKHtcclxuICAgICAgICAgICAgICAgICAgICB0YWdMYWJlbDogXCJsYWJlbFwiLCB0YWdMaXN0OiBcInVsXCIsIG1ha2VQcm9wc0xhYmVsOiAoKSA9PiAoe30pLCBtYWtlUHJvcHNMaXN0OiAoKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogQXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxkaXY+PERlbW9MaXN0SXRlbSBpbmRleD17aX0ga2V5PXtpfSAvPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KX0gLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn0iLCJcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyTGlzdGJveFNpbmdsZUl0ZW0sIExpc3Rib3hTaW5nbGVJdGVtIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC9saXN0Ym94LXNpbmdsZVwiO1xyXG5pbXBvcnQgeyBFdmVudERldGFpbCwgTGlzdGJveFNpbmdsZSwgZGVmYXVsdFJlbmRlckxpc3Rib3hTaW5nbGUgfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcclxuXHJcbi8qZnVuY3Rpb24gRGVtb0J1dHRvbih7IHRhZywgLi4ucHJvcHMgfTogeyB0YWc6IHN0cmluZyB9ICYgUmVuZGVyYWJsZVByb3BzPHt9Pikge1xyXG4gICAgcmV0dXJuIDxBcmlhQnV0dG9uIGRpc2FibGVkPXtkaXNhYmxlZH0gb25QcmVzcz17b25QcmVzc30gcHJlc3NlZD17fSB7Li4ucHJvcHN9IHRhZz17dGFnIGFzIGFueX0gICAvPlxyXG59Ki9cclxuXHJcbmZ1bmN0aW9uIGdldERvY3VtZW50KCkgeyByZXR1cm4gd2luZG93LmRvY3VtZW50OyB9XHJcblxyXG5mdW5jdGlvbiBEZW1vTGlzdEl0ZW0oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPExpc3Rib3hTaW5nbGVJdGVtPEhUTUxMSUVsZW1lbnQ+IGluZGV4PXtpbmRleH0gZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fSBkaXNhYmxlZD17ZmFsc2V9IHRleHQ9e2BMaXN0IGl0ZW0gIyR7aW5kZXh9YH0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyTGlzdGJveFNpbmdsZUl0ZW0oeyB0YWdMaXN0SXRlbTogXCJsaVwiLCBtYWtlUHJvcHNMaXN0SXRlbTogKHsgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkIH0gfSkgPT4gKHsgY2hpbGRyZW46IGBMaXN0IGl0ZW0gIyR7aW5kZXh9JHtzZWxlY3RlZCA/IFwiIChzZWxlY3RlZClcIiA6IFwiXCJ9YCB9KSB9KX0gLz5cclxuICAgIClcclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2xpc3Rib3gvXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIExpc3Rib3ggcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpPkluIHRlcm1zIG9mIGtleWJvYXJkIG5hdmlnYXRpb24gYW5kIHRhYmJpbmcgdGhyb3VnaCBlbGVtZW50cywgYSBMaXN0Ym94IGlzIGNvbnNpZGVyZWQgYSA8c3Ryb25nPnNpbmdsZTwvc3Ryb25nPiB0YWIgc3RvcDsgaW4gb3RoZXIgd29yZHMsIG5vIG1hdHRlciBob3cgbWFueSBsaXN0IGl0ZW1zIHRoZXJlIGFyZSBpbiBhIExpc3Rib3gsIGl0IG9ubHkgdGFrZXMgb25lIHByZXNzIG9mIHRoZSBUYWIgYnV0dG9uIHRvIGdvIHRocm91Z2ggaXQuXHJcbiAgICAgICAgICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+V2hlbiBhIExpc3Rib3ggaXMgdGFiYmVkIGludG8sIHRoZSBtb3N0IHJlY2VudGx5IHNlbGVjdGVkIGl0ZW0gaXMgZ2l2ZW4gZm9jdXM8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+UHJlc3NpbmcgVGFiIGFnYWluIG5hdmlnYXRlcyBvdXQgb2YgdGhlIGxpc3Rib3g7IG5vIG90aGVyIGxpc3QgaXRlbXMgYXJlIHRhYmJhYmxlIG90aGVyIHRoYW4gdGhlIG9uZSBjdXJyZW50bHkgZGVzaWduYXRlZC48L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+UHJlc3NpbmcgdGhlIGFycm93IGtleXMgbmF2aWdhdGVzIHRocm91Z2ggdGhlIExpc3Rib3ggb25lIGl0ZW0gYXQgYSB0aW1lPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlByZXNzaW5nIHRoZSBIb21lL0VuZCBrZXlzIG1vdmUgZm9jdXMgdG8gdGhlIGZpcnN0L2xhc3QgaXRlbXMgcmVzcGVjdGl2ZWx5PC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlR5cGluZyBhbnkgc2VxdWVuY2Ugb2YgdGV4dCBzdGFydHMgdHlwZWFoZWFkIHRoYXQgbmF2aWdhdGVzIHRvIHRoZSBuZXh0IGl0ZW0gdGhhdCBtYXRjaGVzIHdoYXQncyBiZWluZyB0eXBlZDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5Gb2N1cyAmYW1wOyBzZWxlY3Rpb24gbWFuYWdlbWVudCBpcyBhcyBvcHRpbWl6ZWQgYXMgcG9zc2libGU7IG9ubHkgdHdvIGNoaWxkcmVuIHJlLXJlbmRlciBhdCBhIHRpbWUgd2hlbiBmb2N1cyBvciBzZWxlY3Rpb24gY2hhbmdlczwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5UaGVzZSBhcHBseSBnZW5lcmFsbHkgdG8gYWxsIGNvbXBvc2l0ZSBjb21wb25lbnRzIHdpdGggYSB2YXJpYWJsZSBudW1iZXIgb2YgY2hpbGRyZW4gKFRhYiBMaXN0cywgUmFkaW8gR3JvdXBzLCBNdWx0aS1TZWxlY3QgTGlzdGJveGVzIGV0Yy4pPC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5SYXRoZXIgdGhhbiBlYWNoIGluZGl2aWR1YWwgbGlzdCBpdGVtIGtub3dpbmcgd2hldGhlciBpdCBpcyBzZWxlY3RlZCBvciBub3QgKGFzIHdpdGggbXVsdGktc2VsZWN0IGxpc3RzKSwgaGVyZSB0aGUgcGFyZW50IGtub3dzIHRoZSA8Y29kZT5zZWxlY3RlZEluZGV4PC9jb2RlPiBhbmQgc2ltcGx5IG5vdGlmaWVzIHRoZSAobWF4IHR3bykgcmVsZXZhbnQgY2hpbGRyZW4gYW55IHRpbWUgaXQgY2hhbmdlcy48L2xpPlxyXG4gICAgICAgICAgICAgICAgPGxpPkdyb3VwaW5nIGlzIHN1cHBvcnRlZDwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+U29ydGluZy9yZW9yZGVyaW5nIGlzIHN1cHBvcnRlZCwgdGhvdWdoIG5vdCBwcm92aWRlZCBieSBkZWZhdWx0LCBhcyBpdCdzIG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIGdyb3VwaW5nLjwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cclxuICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgPGxpPkxpc3Rib3hlcyBkbyBub3Qgc3VwcG9ydCBpbnRlcmFjdGl2ZSBjb250ZW50IHdpdGhpbiB0aGVtIChlLmcuIGEgZHJvcGRvd24gbWVudSksIGFzIEFSSUEgc3BlY2lmaWVzIHRoYXQgdGhpcyBpcyBhIGRpZmZlcmVudCBwYXR0ZXJuLjwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xyXG4gICAgcmV0dXJuICg8Y29kZT57YGB9PC9jb2RlPilcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XHJcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZTxudWxsIHwgbnVtYmVyPihudWxsKTtcclxuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoNSk7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPEJsdXJiIC8+XHJcbiAgICAgICAgICAgIDxDb2RlIC8+XHJcbiAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cIm51bWJlclwiIG1pbj17MH0gdmFsdWU9e2NvdW50fSBvbklucHV0PXtlID0+IHNldENvdW50KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz4gIyBvZiBsaXN0IGl0ZW1zPC9sYWJlbD5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxMaXN0Ym94U2luZ2xlXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyPXtkZWZhdWx0UmVuZGVyTGlzdGJveFNpbmdsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0xhYmVsOiBcImxhYmVsXCIsIHRhZ0xpc3Q6IFwib2xcIiwgbWFrZVByb3BzTGFiZWw6ICgpID0+ICh7fSksIG1ha2VQcm9wc0xpc3Q6ICgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogPD57QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPGRpdj48RGVtb0xpc3RJdGVtIGluZGV4PXtpfSBrZXk9e2l9IC8+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSl9PC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSl9XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uTW9kZT1cImFjdGl2YXRlXCJcclxuICAgICAgICAgICAgICAgICAgICB0YWdMYWJlbD1cImxhYmVsXCJcclxuICAgICAgICAgICAgICAgICAgICB0YWdMaXN0PVwib2xcIlxyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXg9e3NlbGVjdGVkSW5kZXh9XHJcbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Q9e2UgPT4gc2V0U2VsZWN0ZWRJbmRleChlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZEluZGV4KX0gLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn0iLCJcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBFdmVudERldGFpbCwgTGlzdGJveFNpbmdsZSB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xyXG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyTWVudSwgZGVmYXVsdFJlbmRlck1lbnVJdGVtLCBNZW51LCBNZW51SXRlbSB9IGZyb20gXCIuLi8uLi9jb21wb25lbnQvbWVudVwiXHJcblxyXG4vKmZ1bmN0aW9uIERlbW9CdXR0b24oeyB0YWcsIC4uLnByb3BzIH06IHsgdGFnOiBzdHJpbmcgfSAmIFJlbmRlcmFibGVQcm9wczx7fT4pIHtcclxuICAgIHJldHVybiA8QXJpYUJ1dHRvbiBkaXNhYmxlZD17ZGlzYWJsZWR9IG9uUHJlc3M9e29uUHJlc3N9IHByZXNzZWQ9e30gey4uLnByb3BzfSB0YWc9e3RhZyBhcyBhbnl9ICAgLz5cclxufSovXHJcblxyXG5mdW5jdGlvbiBEZW1vTGlzdEl0ZW0oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPE1lbnVJdGVtPEhUTUxMSUVsZW1lbnQ+IGluZGV4PXtpbmRleH0gdGV4dD17YExpc3QgaXRlbSAjJHtpbmRleH1gfSByZW5kZXI9e2RlZmF1bHRSZW5kZXJNZW51SXRlbSh7IHRhZ01lbnVJdGVtOiBcImxpXCIsIG1ha2VQcm9wc01lbnVJdGVtOiAoKSA9PiAoeyBjaGlsZHJlbjogYE1lbnUgaXRlbSAjJHtpbmRleH1gIH0pIH0pfSAvPlxyXG4gICAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHsgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9saXN0Ym94L1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBMaXN0Ym94IHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgY2hpbGRyZW4gYXJlIHRyZWF0ZWQgYXMgYSBjb21wb3NpdGUgY29tcG9uZW50IHdpdGggbGlzdCBuYXZpZ2F0aW9uOyBzZWUgPGNvZGU+QWlyYVNpbmdsZVNlbGVjdExpc3Q8L2NvZGU+IGZvciBtb3JlIGluZm9ybWF0aW9uPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIG9wZW5lZCwgdGhlIG1lbnUgd2lsbCBmb2N1cyB0aGUgZmlyc3QgZWxlbWVudCB3aXRoaW4gaXQuIFdoZW4gY2xvc2VkIChieSBwcmVzc2luZyBlc2NhcGUsIHByZXNzaW5nIHRoZSBidXR0b24gYWdhaW4sIG9yIHRhYmJpbmcgb3V0IG9mIHRoZSBtZW51KSwgdGhlIGJ1dHRvbiB0aGF0IG9wZW5lZCBpdCB3aWxsIGhhdmUgZm9jdXMgcmVzdG9yZWQgdG8gaXQuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIHRoZSBtZW51IGlzIGNsb3NlZCBiZWNhdXNlIGFub3RoZXIgZWxlbWVudCBvbiB0aGUgcGFnZSB3YXMgZm9jdXNlZCBpbnN0ZWFkLCBmb2N1cyB3aWxsIG5vdCBiZSBtb2RpZmllZC48L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5UT0RPPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XHJcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcclxuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoNSk7XHJcbiAgICBjb25zdCBbb3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPEJsdXJiIC8+XHJcbiAgICAgICAgICAgIDxDb2RlIC8+XHJcbiAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cIm51bWJlclwiIG1pbj17MH0gdmFsdWU9e2NvdW50fSBvbklucHV0PXtlID0+IHNldENvdW50KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz4gIyBvZiBtZW51IGl0ZW1zPC9sYWJlbD5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxNZW51PEhUTUxEaXZFbGVtZW50LCBIVE1MVUxpc3RFbGVtZW50LCBIVE1MRGl2RWxlbWVudCwgSFRNTExJRWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fVxyXG4gICAgICAgICAgICAgICAgICAgIG9uT3Blbj17KCkgPT4gc2V0T3Blbih0cnVlKX1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRPcGVuKGZhbHNlKX1cclxuICAgICAgICAgICAgICAgICAgICBvcGVuPXtvcGVufVxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW5EaXJlY3Rpb249XCJkb3duXCJcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJNZW51KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnQnV0dG9uOiBcImJ1dHRvblwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdNZW51OiBcInVsXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ1NlbnRpbmVsOiBcImRpdlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdTdXJmYWNlOiBcImRpdlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxJZDogXCJwb3J0YWxcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzQnV0dG9uOiAoKSA9PiAoeyBjaGlsZHJlbjogXCJPcGVuIG1lbnVcIiArIChvcGVuPyBcIiAob3BlbilcIiA6IFwiIChjbG9zZWQpXCIpIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNNZW51OiAoKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IDw+e0FycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxkaXY+PERlbW9MaXN0SXRlbSBpbmRleD17aX0ga2V5PXtpfSAvPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpfTwvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzU3VyZmFjZTogKCkgPT4gKHsgc3R5bGU6IHsgZGlzcGxheTogIW9wZW4/IFwibm9uZVwiIDogdW5kZWZpbmVkIH0gfSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc1NlbnRpbmVsOiAoKSA9PiAoe30pLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufSIsIlxyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJSYWRpbywgUmFkaW8sIFJhZGlvR3JvdXAgfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50L3JhZGlvLWdyb3VwXCI7XHJcbmltcG9ydCB7IEV2ZW50RGV0YWlsLCBMaXN0Ym94U2luZ2xlLCBkZWZhdWx0UmVuZGVyUmFkaW9Hcm91cCB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xyXG5cclxuLypmdW5jdGlvbiBEZW1vQnV0dG9uKHsgdGFnLCAuLi5wcm9wcyB9OiB7IHRhZzogc3RyaW5nIH0gJiBSZW5kZXJhYmxlUHJvcHM8e30+KSB7XHJcbiAgICByZXR1cm4gPEFyaWFCdXR0b24gZGlzYWJsZWQ9e2Rpc2FibGVkfSBvblByZXNzPXtvblByZXNzfSBwcmVzc2VkPXt9IHsuLi5wcm9wc30gdGFnPXt0YWcgYXMgYW55fSAgIC8+XHJcbn0qL1xyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XHJcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50O1xyXG59XHJcblxyXG5mdW5jdGlvbiBEZW1vTGlzdEl0ZW0oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xyXG5cclxuICAgIGNvbnN0IHZhbHVlID0gYFJhZGlvIGJ1dHRvbiAjJHtpbmRleH1gO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPFJhZGlvPG51bWJlciwgSFRNTElucHV0RWxlbWVudCwgSFRNTExhYmVsRWxlbWVudD4gaW5kZXg9e2luZGV4fSBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9IGRpc2FibGVkPXtmYWxzZX0gbGFiZWxQb3NpdGlvbj1cInNlcGFyYXRlXCIgdGV4dD17dmFsdWV9IHZhbHVlPXtpbmRleH0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwibGFiZWxcIiByZW5kZXI9e2RlZmF1bHRSZW5kZXJSYWRpbyh7IGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIiwgdGFnSW5wdXQ6IFwiaW5wdXRcIiwgdGFnTGFiZWw6IFwibGFiZWxcIiwgbWFrZUlucHV0UHJvcHM6ICgpID0+ICh7fSksIG1ha2VMYWJlbFByb3BzOiAoKSA9PiAoeyBjaGlsZHJlbjogdmFsdWUgfSkgfSl9IC8+XHJcbiAgICApXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9yYWRpb2J1dHRvbi9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgUmFkaW8gQnV0dG9uIHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgY2hpbGRyZW4gYXJlIHRyZWF0ZWQgYXMgYSBjb21wb3NpdGUgY29tcG9uZW50IHdpdGggbGlzdCBuYXZpZ2F0aW9uOyBzZWUgPGNvZGU+QWlyYVNpbmdsZVNlbGVjdExpc3Q8L2NvZGU+IGZvciBtb3JlIGluZm9ybWF0aW9uPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgaW5wdXQgJmFtcDsgbGFiZWwgc3VwcG9ydCB0aGUgc2FtZSB0ZXh0LXNlbGVjdGlvbiBhZmZvcmRhbmNlcyBhcyBDaGVja2JveGVzIChsYWJlbHMgY2FuIGJlIHNlbGVjdGVkLCBidXQgZG91YmxlLWNsaWNraW5nIGRvZXNuJ3Qgc2VsZWN0IHRoZSB0ZXh0IGFuZCBzZWxlY3RpbmcgdGV4dCBkb2Vzbid0IGNvdW50IGFzIGFuIGlucHV0KTwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+U2VsZWN0aW9uIHN0YXRlIGlzIGhhbmRsZWQgYnkgdGhlIHBhcmVudDsgaW5zdGVhZCBvZiBzcGVjaWZ5aW5nIHdoZXRoZXIgYW55IGdpdmVuIHJhZGlvIGJ1dHRvbiBpcyBjaGVja2VkIG9yIG5vdCwgdGhlIHBhcmVudCBub3RpZmllcyBlYWNoIGNoaWxkIG9mIHRoZSBuZWNlc3NhcnkgY2hhbmdlcy48L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5JZiB5b3VyIGNoZWNrYm94IGRvZXMgbm90IGhhdmUgYSB2aXNpYmxlIGxhYmVsIChhY2hpZXZhYmxlIGJ5IGJ5IG92ZXJyaWRpbmcgdGhlIDxjb2RlPnJlbmRlcjwvY29kZT4gcHJvcCBhbmQgc2V0dGluZyA8Y29kZT5sYWJlbFBvc2l0aW9uPC9jb2RlPiB0byBiZSBcInNlcGFyYXRlXCIpLCB5b3UgbXVzdCBwYXNzIDxjb2RlPmFyaWEtbGFiZWw8L2NvZGU+IGFzIGEgcHJvcCB0byB0aGUgY2hlY2tib3ggbWFudWFsbHkuIE5vdCBwcm92aWRpbmcgb25lIHdpbGwgcHJpbnQgYW4gZXJyb3IgdG8gdGhlIGNvbnNvbGUsIGJ1dCBpdCBpdCBub3QgcmVxdWlyZWQgYnkgdGhlIHR5cGUgc3lzdGVtLjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIGFib3ZlIGFsc28gYXBwbGllcyB0byB0aGUgcmFkaW8gZ3JvdXAgYXMgYSB3aG9sZTsgQVJJQSByZXF1aXJlcyB0aGF0IGFsbCBSYWRpbyBCdXR0b25zIGJlIGNvbnRhaW5lZCB3aXRoaW4gYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWMgcm9sZSB3aGljaCBpcyBsYWJlbGxlZCBlaXRoZXIgYnkgYW4gZWxlbWVudCAoaGFuZGxlZCBmb3IgeW91KSBvciA8Y29kZT5hcmlhLWxhYmVsPC9jb2RlPiAoc3BlY2lmaWVkIGJ5IHlvdSBtYW51YWxseSBvbiB0aGUgaW5wdXQpLjwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xyXG4gICAgcmV0dXJuICg8Y29kZT57YGB9PC9jb2RlPilcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XHJcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZTxudWxsIHwgbnVtYmVyPihudWxsKTtcclxuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoNSk7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPEJsdXJiIC8+XHJcbiAgICAgICAgICAgIDxDb2RlIC8+XHJcbiAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cIm51bWJlclwiIG1pbj17MH0gdmFsdWU9e2NvdW50fSBvbklucHV0PXtlID0+IHNldENvdW50KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz4gIyBvZiBsaXN0IGl0ZW1zPC9sYWJlbD5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxSYWRpb0dyb3VwPG51bWJlciwgSFRNTERpdkVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQsIEhUTUxJbnB1dEVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQ+XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZT1cInJhZGlvLWRlbW9cIlxyXG4gICAgICAgICAgICAgICAgICAgIG9uSW5wdXQ9e2UgPT4gc2V0U2VsZWN0ZWRJbmRleChlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZFZhbHVlKX1cclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFZhbHVlPXtzZWxlY3RlZEluZGV4fVxyXG4gICAgICAgICAgICAgICAgICAgIHRhZ0dyb3VwTGFiZWw9XCJsYWJlbFwiXHJcbiAgICAgICAgICAgICAgICAgICAgdGFnR3JvdXA9XCJkaXZcIlxyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcj17ZGVmYXVsdFJlbmRlclJhZGlvR3JvdXAoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdHcm91cDogXCJkaXZcIiwgdGFnTGFiZWw6IFwibGFiZWxcIiwgbWFrZVByb3BzR3JvdXA6ICgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogPD57QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9MaXN0SXRlbSBpbmRleD17aX0ga2V5PXtpfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpfTwvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzTGFiZWw6ICgpID0+ICh7IGNoaWxkcmVuOiBcIkxpc3Rib3ggZXhhbXBsZVwiIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSl9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59IiwiXHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgRXZlbnREZXRhaWwsIExpc3Rib3hTaW5nbGUgfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcclxuaW1wb3J0IHsgZGVmYXVsdFJlbmRlclNsaWRlclRodW1iLCBTbGlkZXJUaHVtYiwgU2xpZGVyIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC9zbGlkZXJcIlxyXG5cclxuLypmdW5jdGlvbiBEZW1vQnV0dG9uKHsgdGFnLCAuLi5wcm9wcyB9OiB7IHRhZzogc3RyaW5nIH0gJiBSZW5kZXJhYmxlUHJvcHM8e30+KSB7XHJcbiAgICByZXR1cm4gPEFyaWFCdXR0b24gZGlzYWJsZWQ9e2Rpc2FibGVkfSBvblByZXNzPXtvblByZXNzfSBwcmVzc2VkPXt9IHsuLi5wcm9wc30gdGFnPXt0YWcgYXMgYW55fSAgIC8+XHJcbn0qL1xyXG5cclxuZnVuY3Rpb24gRGVtb1NsaWRlclRodW1iKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pIHtcclxuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8U2xpZGVyVGh1bWI8SFRNTElucHV0RWxlbWVudD5cclxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxyXG4gICAgICAgICAgICB0YWc9XCJpbnB1dFwiXHJcbiAgICAgICAgICAgIGxhYmVsPXtgU2xpZGVyIHRodW1iICMke2luZGV4fWB9XHJcbiAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cclxuICAgICAgICAgICAgb25WYWx1ZUNoYW5nZT17ZSA9PiBzZXRWYWx1ZShlW0V2ZW50RGV0YWlsXS52YWx1ZSl9XHJcbiAgICAgICAgICAgIG1pbj17MH1cclxuICAgICAgICAgICAgbWF4PXsxMH1cclxuICAgICAgICAgICAgcmVuZGVyPXtkZWZhdWx0UmVuZGVyU2xpZGVyVGh1bWIoeyB0YWdUaHVtYjogXCJpbnB1dFwiLCBtYWtlUHJvcHNUaHVtYjogKCkgPT4gKHt9KSB9KX0gLz5cclxuICAgIClcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7IHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvbGlzdGJveC9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgTGlzdGJveCBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+VGhlIGNoaWxkcmVuIGFyZSB0cmVhdGVkIGFzIGEgY29tcG9zaXRlIGNvbXBvbmVudCB3aXRoIGxpc3QgbmF2aWdhdGlvbjsgc2VlIDxjb2RlPkFpcmFTaW5nbGVTZWxlY3RMaXN0PC9jb2RlPiBmb3IgbW9yZSBpbmZvcm1hdGlvbjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+V2hlbiBvcGVuZWQsIHRoZSBtZW51IHdpbGwgZm9jdXMgdGhlIGZpcnN0IGVsZW1lbnQgd2l0aGluIGl0LiBXaGVuIGNsb3NlZCAoYnkgcHJlc3NpbmcgZXNjYXBlLCBwcmVzc2luZyB0aGUgYnV0dG9uIGFnYWluLCBvciB0YWJiaW5nIG91dCBvZiB0aGUgbWVudSksIHRoZSBidXR0b24gdGhhdCBvcGVuZWQgaXQgd2lsbCBoYXZlIGZvY3VzIHJlc3RvcmVkIHRvIGl0LjwvbGk+XHJcbiAgICAgICAgICAgICAgICA8bGk+V2hlbiB0aGUgbWVudSBpcyBjbG9zZWQgYmVjYXVzZSBhbm90aGVyIGVsZW1lbnQgb24gdGhlIHBhZ2Ugd2FzIGZvY3VzZWQgaW5zdGVhZCwgZm9jdXMgd2lsbCBub3QgYmUgbW9kaWZpZWQuPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxyXG4gICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICA8bGk+VE9ETzwvbGk+XHJcbiAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgPC8+XHJcbiAgICApXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xyXG4gICAgcmV0dXJuICg8Y29kZT57YGB9PC9jb2RlPilcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XHJcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDUpO1xyXG4gICAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDw+XHJcbiAgICAgICAgICAgIDxCbHVyYiAvPlxyXG4gICAgICAgICAgICA8Q29kZSAvPlxyXG4gICAgICAgICAgICA8bGFiZWw+PGlucHV0IHR5cGU9XCJudW1iZXJcIiBtaW49ezB9IHZhbHVlPXtjb3VudH0gb25JbnB1dD17ZSA9PiBzZXRDb3VudChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+ICMgb2Ygc2xpZGVyIHRodW1iczwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8U2xpZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgbWluPXswfVxyXG4gICAgICAgICAgICAgICAgICAgIG1heD17MTB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW49ezw+e0FycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPGRpdj48RGVtb1NsaWRlclRodW1iIGluZGV4PXtpfSBrZXk9e2l9IC8+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KSgpKX1cclxuICAgICAgICAgICAgICAgICAgICA8Lz59IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59IiwiXHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgZGVmYXVsdFJlbmRlckRpYWxvZywgRGlhbG9nIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC9kaWFsb2dcIjtcclxuaW1wb3J0IHsgQXJpYUJ1dHRvbiwgZGVmYXVsdFJlbmRlckJ1dHRvbiB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHsgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDsgfVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9saXN0Ym94L1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBMaXN0Ym94IHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgY2hpbGRyZW4gYXJlIHRyZWF0ZWQgYXMgYSBjb21wb3NpdGUgY29tcG9uZW50IHdpdGggbGlzdCBuYXZpZ2F0aW9uOyBzZWUgPGNvZGU+QWlyYVNpbmdsZVNlbGVjdExpc3Q8L2NvZGU+IGZvciBtb3JlIGluZm9ybWF0aW9uPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIG9wZW5lZCwgdGhlIG1lbnUgd2lsbCBmb2N1cyB0aGUgZmlyc3QgZWxlbWVudCB3aXRoaW4gaXQuIFdoZW4gY2xvc2VkIChieSBwcmVzc2luZyBlc2NhcGUsIHByZXNzaW5nIHRoZSBidXR0b24gYWdhaW4sIG9yIHRhYmJpbmcgb3V0IG9mIHRoZSBtZW51KSwgdGhlIGJ1dHRvbiB0aGF0IG9wZW5lZCBpdCB3aWxsIGhhdmUgZm9jdXMgcmVzdG9yZWQgdG8gaXQuPC9saT5cclxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIHRoZSBtZW51IGlzIGNsb3NlZCBiZWNhdXNlIGFub3RoZXIgZWxlbWVudCBvbiB0aGUgcGFnZSB3YXMgZm9jdXNlZCBpbnN0ZWFkLCBmb2N1cyB3aWxsIG5vdCBiZSBtb2RpZmllZC48L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5UT0RPPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XHJcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcclxuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxBcmlhQnV0dG9uIHRhZz1cImJ1dHRvblwiIG9uUHJlc3M9eygpID0+IHNldE9wZW4odHJ1ZSl9IHJlbmRlcj17ZGVmYXVsdFJlbmRlckJ1dHRvbihcImJ1dHRvblwiLCAoKSA9PiAoeyBjaGlsZHJlbjogXCJPcGVuIGRpYWxvZyBcIiArIChvcGVuID8gXCIob3BlbilcIiA6IFwiKGNsb3NlZClcIikgfSkpfSAvPlxyXG4gICAgICAgICAgICAgICAgPERpYWxvZ1xyXG4gICAgICAgICAgICAgICAgICAgIGdldERvY3VtZW50PXtnZXREb2N1bWVudH1cclxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRPcGVuKGZhbHNlKX1cclxuICAgICAgICAgICAgICAgICAgICBvcGVuPXtvcGVufVxyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlJc09ubHlTZW1hbnRpYz17dHJ1ZX1cclxuICAgICAgICAgICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJEaWFsb2coe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxJZDogXCJwb3J0YWxcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzQmFja2Ryb3A6ICgpID0+ICh7fSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyOiAoKSA9PiAoe30pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNCb2R5OiAoKSA9PiAoeyBjaGlsZHJlbjogXCJEaWFsb2cgYm9keVwiIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNEaWFsb2c6ICgpID0+ICh7IHN0eWxlOiB7IGRpc3BsYXk6ICFvcGVuID8gXCJub25lXCIgOiB1bmRlZmluZWQgfSB9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzVGl0bGU6ICgpID0+ICh7IGNoaWxkcmVuOiBcIkRpYWxvZyB0aXRsZVwiIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdCYWNrZHJvcDogXCJkaXZcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnQm9keTogXCJkaXZcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnRGlhbG9nOiBcImRpdlwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdUaXRsZTogXCJkaXZcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnRm9jdXNDb250YWluZXI6IFwiZGl2XCJcclxuICAgICAgICAgICAgICAgICAgICB9KX1cclxuICAgICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59IiwiXHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgRXZlbnREZXRhaWwgfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcclxuaW1wb3J0IHsgVGFicywgZGVmYXVsdFJlbmRlclRhYnMsIGRlZmF1bHRSZW5kZXJUYWIsIGRlZmF1bHRSZW5kZXJUYWJQYW5lbCB9IGZyb20gXCIuLi8uLi9cIlxyXG5pbXBvcnQgeyBUYWIsIFRhYlBhbmVsIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudC90YWJzXCI7XHJcblxyXG4vKmZ1bmN0aW9uIERlbW9CdXR0b24oeyB0YWcsIC4uLnByb3BzIH06IHsgdGFnOiBzdHJpbmcgfSAmIFJlbmRlcmFibGVQcm9wczx7fT4pIHtcclxuICAgIHJldHVybiA8QXJpYUJ1dHRvbiBkaXNhYmxlZD17ZGlzYWJsZWR9IG9uUHJlc3M9e29uUHJlc3N9IHByZXNzZWQ9e30gey4uLnByb3BzfSB0YWc9e3RhZyBhcyBhbnl9ICAgLz5cclxufSovXHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7IHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7IH1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvdGFicGFuZWwvXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIFRhYiBhbmQgVGFiIFBhbmVsIHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5UaGUgdGFicyBhcmUgdHJlYXRlZCBhcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgd2l0aCBsaXN0IG5hdmlnYXRpb247IHNlZSA8Y29kZT5BaXJhU2luZ2xlU2VsZWN0TGlzdDwvY29kZT4gZm9yIG1vcmUgaW5mb3JtYXRpb248L2xpPlxyXG4gICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XHJcbiAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgIDxsaT5UT0RPPC9saT5cclxuICAgICAgICAgICAgPC91bD5cclxuICAgICAgICA8Lz5cclxuICAgIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XHJcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcclxuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoNSk7XHJcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8Qmx1cmIgLz5cclxuICAgICAgICAgICAgPENvZGUgLz5cclxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIHRhYnM8L2xhYmVsPlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPFRhYnNcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4PXtzZWxlY3RlZEluZGV4fVxyXG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0ZWRJbmRleENoYW5nZT17ZSA9PiBzZXRTZWxlY3RlZEluZGV4KGVbRXZlbnREZXRhaWxdLnNlbGVjdGVkSW5kZXgpfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJUYWJzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZWxzOiBBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBgVGFiIHBhbmVsICMke2l9YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8VGFiUGFuZWwgaW5kZXg9e2l9IGtleT17aX0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyVGFiUGFuZWwoeyB0YWdUYWJQYW5lbDogXCJkaXZcIiwgbWFrZVByb3BzVGFiUGFuZWw6ICh7IHRhYlBhbmVsOiB7IHZpc2libGUgfSB9KSA9PiAoeyBoaWRkZW46ICF2aXNpYmxlLCBjaGlsZHJlbjogbGFiZWwgfSkgfSl9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdMYWJlbDogXCJsYWJlbFwiLCB0YWdMaXN0OiBcInVsXCIsIG1ha2VQcm9wc0xhYmVsOiAoKSA9PiAoeyBjaGlsZHJlbjogXCJUYWJzIGV4YW1wbGVcIiB9KSwgbWFrZVByb3BzTGlzdDogKCkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiA8PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gYFRhYiAjJHtpfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8VGFiIGtleT17aX0gaW5kZXg9e2l9IGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyVGFiKHsgdGFnVGFiOiBcImxpXCIsIG1ha2VQcm9wc1RhYjogKCkgPT4gKHsgY2hpbGRyZW46IGxhYmVsIH0pIH0pfSB0ZXh0PXtsYWJlbH0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSl9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvPlxyXG4gICAgKVxyXG59IiwiXHJcbmltcG9ydCB7IHJlbmRlciwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgSGVhZGluZyB9IGZyb20gXCIuLi9jb21wb25lbnQvaGVhZGluZ1wiO1xyXG5pbXBvcnQgKiBhcyBBY2NvcmRpb24gZnJvbSBcIi4vZGVtb3MvYWNjb3JkaW9uXCJcclxuaW1wb3J0ICogYXMgQnV0dG9uIGZyb20gXCIuL2RlbW9zL2J1dHRvblwiXHJcbmltcG9ydCAqIGFzIENoZWNrYm94IGZyb20gXCIuL2RlbW9zL2NoZWNrYm94XCJcclxuaW1wb3J0ICogYXMgQ2hlY2tib3hHcm91cCBmcm9tIFwiLi9kZW1vcy9jaGVja2JveC1ncm91cFwiXHJcbmltcG9ydCAqIGFzIExpc3Rib3hNdWx0aSBmcm9tIFwiLi9kZW1vcy9saXN0Ym94LW11bHRpXCJcclxuaW1wb3J0ICogYXMgTGlzdGJveFNpbmdsZSBmcm9tIFwiLi9kZW1vcy9saXN0Ym94LXNpbmdsZVwiXHJcbmltcG9ydCAqIGFzIE1lbnUgZnJvbSBcIi4vZGVtb3MvbWVudVwiXHJcbmltcG9ydCAqIGFzIFJhZGlvIGZyb20gXCIuL2RlbW9zL3JhZGlvXCJcclxuaW1wb3J0ICogYXMgU2xpZGVyIGZyb20gXCIuL2RlbW9zL3NsaWRlclwiXHJcbmltcG9ydCAqIGFzIERpYWxvZyBmcm9tIFwiLi9kZW1vcy9kaWFsb2dcIlxyXG5pbXBvcnQgKiBhcyBUYWJzIGZyb20gXCIuL2RlbW9zL3RhYnNcIlxyXG5cclxuLy9pbXBvcnQgeyBvcHRpb25zIH0gZnJvbSBcInByZWFjdFwiO1xyXG4vL29wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSBxdWV1ZU1pY3JvdGFzaztcclxuXHJcbi8vY29uc3QgUmFuZG9tV29yZHMgPSBcIkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNjaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiBVdCBlbmltIGFkIG1pbmltIHZlbmlhbSwgcXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhIGNvbW1vZG8gY29uc2VxdWF0LiBEdWlzIGF1dGUgaXJ1cmUgZG9sb3IgaW4gcmVwcmVoZW5kZXJpdCBpbiB2b2x1cHRhdGUgdmVsaXQgZXNzZSBjaWxsdW0gZG9sb3JlIGV1IGZ1Z2lhdCBudWxsYSBwYXJpYXR1ci4gRXhjZXB0ZXVyIHNpbnQgb2NjYWVjYXQgY3VwaWRhdGF0IG5vbiBwcm9pZGVudCwgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3QgbGFib3J1bS5cIi5zcGxpdChcIiBcIik7XHJcblxyXG5cclxuY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiRGVtb3NcIj5cclxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIlRhYnNcIj48VGFicy5EZW1vIC8+PC9IZWFkaW5nPlxyXG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiRGlhbG9nXCI+PERpYWxvZy5EZW1vIC8+PC9IZWFkaW5nPlxyXG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiU2xpZGVyXCI+PFNsaWRlci5EZW1vIC8+PC9IZWFkaW5nPlxyXG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiU2luZ2xlLXNlbGVjdCBMaXN0Ym94XCI+PExpc3Rib3hTaW5nbGUuRGVtbyAvPjwvSGVhZGluZz5cclxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkFjY29yZGlvblwiPjxBY2NvcmRpb24uRGVtbyAvPjwvSGVhZGluZz5cclxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkJ1dHRvblwiPjxCdXR0b24uRGVtbyAvPjwvSGVhZGluZz5cclxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkNoZWNrYm94XCI+PENoZWNrYm94LkRlbW8gLz48L0hlYWRpbmc+XHJcbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJDaGVja2JveCBHcm91cFwiPjxDaGVja2JveEdyb3VwLkRlbW8gLz48L0hlYWRpbmc+XHJcbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJNdWx0aS1zZWxlY3QgTGlzdGJveFwiPjxMaXN0Ym94TXVsdGkuRGVtbyAvPjwvSGVhZGluZz5cclxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIk1lbnVcIj48TWVudS5EZW1vIC8+PC9IZWFkaW5nPlxyXG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiUmFkaW9cIj48UmFkaW8uRGVtbyAvPjwvSGVhZGluZz5cclxuICAgICAgICAgICAgey8qXHJcbiAgICAgICBcclxuICAgICAgICA8RGVtb1RhYmxlIC8+XHJcblxyXG5cclxuICAgICAgICA8RGVtb1VzZUZvY3VzVHJhcCAvPlxyXG4gICAgICAgIDxEZW1vVXNlRHJvcHBhYmxlIC8+XHJcbiAgICAgICAgPERlbW9Vc2VEcmFnZ2FibGUgLz5cclxuICAgICAgICA8aW5wdXQgLz4qL31cclxuICAgICAgICA8L0hlYWRpbmc+KVxyXG59XHJcblxyXG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgcmVuZGVyKDxDb21wb25lbnQgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9vdFwiKSEpO1xyXG59KVxyXG4iXSwibmFtZXMiOlsiRXZlbnREZXRhaWwiLCJTeW1ib2wiLCJIZWFkaW5nTGV2ZWxDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImhlYWRpbmciLCJwcm9wcyIsImhlYWRpbmdMZXZlbEJlZm9yZVVzIiwidXNlQ29udGV4dCIsInRhZyIsIm5ld0hlYWRpbmdMZXZlbCIsIndhcm5Pbk92ZXJ3cml0ZSIsIl9qc3giLCJjaGlsZHJlbiIsIl9qc3hzIiwiSGVhZGluZ1Jlc2V0IiwibmV3TGV2ZWwiLCJlZmZlY3QiLCJpbnB1dHMiLCJpbXBsIiwidXNlRWZmZWN0TmF0aXZlIiwicHJldklucHV0cyIsInVzZVJlZiIsInVuZGVmaW5lZCIsImVmZmVjdDIiLCJjaGFuZ2VzIiwiY3VycmVudCIsImkiLCJNYXRoIiwibWF4IiwibGVuZ3RoIiwiZnJvbSIsInRvIiwicmV0IiwidXNlRW5zdXJlU3RhYmlsaXR5IiwicGFyZW50SG9va05hbWUiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwidmFsdWUiLCJpbmRleCIsImhlbHBlclRvRW5zdXJlU3RhYmlsaXR5Iiwic2hvd25FcnJvciIsImNvbnNvbGUiLCJlcnJvciIsInVzZVBhc3NpdmVTdGF0ZSIsIm9uQ2hhbmdlIiwiZ2V0SW5pdGlhbFZhbHVlIiwia2V5IiwicmFuZG9tIiwidG9TdHJpbmciLCJ2YWx1ZVJlZiIsIlVuc2V0Iiwid2FybmluZ1JlZiIsImNsZWFudXBDYWxsYmFja1JlZiIsIm9uU2hvdWxkQ2xlYW5VcCIsInVzZUNhbGxiYWNrIiwiY2xlYW51cENhbGxiYWNrIiwidHJ5RW5zdXJlVmFsdWUiLCJpbml0aWFsVmFsdWUiLCJleCIsImdldFZhbHVlIiwid2FybiIsInByZXZEZXAiLCJzZXRWYWx1ZSIsImFyZyIsIm5leHRWYWx1ZSIsIkZ1bmN0aW9uIiwiZGVib3VuY2VSZW5kZXJpbmciLCJuZXh0RGVwIiwiYWN0aXZlRWxlbWVudFVwZGF0ZXJzIiwiTWFwIiwibGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyIsIndpbmRvd0ZvY3VzZWRVcGRhdGVycyIsIndpbmRvd3NGb2N1c2VkVXBkYXRlcnMiLCJtaWNyb3Rhc2tzIiwiZm9yRWFjaFVwZGF0ZXIiLCJtYXAiLCJ1cGRhdGVyc0tleSIsImdldCIsIndpbmRvdyIsImhhcyIsInVwZGF0ZXIiLCJzZXQiLCJmb2N1c291dCIsImUiLCJ0YXJnZXQiLCJkZWZhdWx0VmlldyIsInJlbGF0ZWRUYXJnZXQiLCJmb2N1c2luIiwib3duZXJEb2N1bWVudCIsImN1cnJlbnRseUZvY3VzZWRFbGVtZW50Iiwid2luZG93Qmx1ciIsIldpbmRvdyIsImN1cnJlbnRUYXJnZXQiLCJUYWJsZSIsImJhc2U2NCIsInJhbmRvbTZCaXRzIiwiZ2VuZXJhdGVSYW5kb21JZCIsInByZWZpeCIsInJhbmRvbTY0Qml0cyIsIm4iLCJqb2luIiwicHJldmlvdXNJbnB1dHMiLCJ0b1J1biIsImNvbW1pdE5hbWUiLCJvcmlnaW5hbENvbW1pdCIsIm9wdGlvbnMiLCJuZXdDb21taXQiLCJpZCIsImVmZmVjdEluZm8iLCJjbGVhciIsImFyZ3MiLCJ1c2VTdGFibGVHZXR0ZXIiLCJyZWYiLCJ1c2VCZWZvcmVMYXlvdXRFZmZlY3QiLCJFcnJvciIsImZuIiwiY3VycmVudENhbGxiYWNrR2V0dGVyIiwiaXNPYmplY3QiLCJ0eXBlIiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsIk9iamVjdCIsImZyZWVTZWxmIiwic2VsZiIsInJvb3QiLCJvYmplY3RQcm90byIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiZ2V0UmF3VGFnIiwiaXNPd24iLCJjYWxsIiwidW5tYXNrZWQiLCJyZXN1bHQiLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJiYXNlR2V0VGFnIiwiaXNPYmplY3RMaWtlIiwidXNlU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJzdGF0ZSIsInNldFN0YXRlUCIsInVzZVN0YXRlUCIsInNldFN0YXRlIiwiY2FsbGJhY2siLCJwcmV2VmFsdWUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3ROYXRpdmUiLCJwYXJlbnRQYXJhbWV0ZXJzIiwibWFuYWdlZENoaWxkcmVuIiwib25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Iiwib25DaGlsZHJlbk1vdW50Q2hhbmdlIiwiZ2V0SGlnaGVzdEluZGV4IiwibWFuYWdlZENoaWxkcmVuQXJyYXkiLCJoaWdoZXN0SW5kZXgiLCJhcnIiLCJyZWMiLCJsb3dlc3RJbmRleCIsImZvckVhY2hDaGlsZCIsImYiLCJjaGlsZCIsImZpZWxkIiwicmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyIsIlNldCIsInJlbW90ZVVMRUNoaWxkQ2hhbmdlZCIsInNpemUiLCJhZGQiLCJyZW1vdGVVTEVDaGlsZE1vdW50ZWQiLCJtb3VudGVkIiwiaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkIiwibW91bnRzIiwidW5tb3VudHMiLCJzaGF2ZSIsInNwbGljZSIsInVzZU1hbmFnZWRDaGlsZCIsIm1hbmFnZWRDaGlsZCIsImluZm8iLCJmbGFncyIsInN1YkluZm8iLCJlbnRyaWVzIiwiZmxhdCIsImFycmF5U2xpY2UiLCJyIiwidCIsIkFycmF5IiwiaXNBcnJheSIsImNsc3giLCJhcmd1bWVudHMiLCJnZXREb2N1bWVudCIsImVsZW1lbnQiLCJkb2N1bWVudCIsImdsb2JhbFRoaXMiLCJ1c2VNZXJnZWRDaGlsZHJlbiIsImxocyIsInJocyIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsInVzZU1lcmdlZENsYXNzZXMiLCJjbGFzcyIsImxoc0NsYXNzIiwiY2xhc3NOYW1lIiwibGhzQ2xhc3NOYW1lIiwicmhzQ2xhc3MiLCJyaHNDbGFzc05hbWUiLCJsaHNDbGFzc2VzIiwic3BsaXQiLCJyaHNDbGFzc2VzIiwiYWxsQ2xhc3NlcyIsInByb2Nlc3NSZWYiLCJpbnN0YW5jZSIsImFzc2VydCIsImNvbWJpbmVkIiwic3R5bGVTdHJpbmdUb09iamVjdCIsInN0eWxlIiwiZnJvbUVudHJpZXMiLCJzdGF0ZW1lbnQiLCJ1c2VNZXJnZWRTdHlsZXMiLCJsb2ciLCJ1c2VNZXJnZWRQcm9wcyIsImxoc0FsbCIsInJoc0FsbCIsIl9saHNDaGlsZHJlbiIsIl9saHNDbGFzc05hbWUiLCJfbGhzU3R5bGUiLCJfbGhzUmVmIiwibGhzTWlzYyIsIl9yaHNDaGlsZHJlbiIsIl9yaHNDbGFzcyIsIl9yaHNDbGFzc05hbWUiLCJfcmhzU3R5bGUiLCJfcmhzUmVmIiwicmhzTWlzYyIsInVzZU1lcmdlZFJlZnMiLCJyaHNFbnRyaWVzIiwicmhzS2V5VSIsInJoc1ZhbHVlIiwicmhzS2V5IiwibGhzVmFsdWUiLCJtZXJnZWQiLCJtZXJnZUZ1bmN0aW9ucyIsInVzZVJlZkVsZW1lbnQiLCJvbkVsZW1lbnRDaGFuZ2UiLCJvbk1vdW50Iiwib25Vbm1vdW50IiwiaGFuZGxlciIsImNhbmRpZGF0ZVNlbGVjdG9ycyIsImNhbmRpZGF0ZVNlbGVjdG9yIiwibWF0Y2hlcyIsIk5vRWxlbWVudCIsIkVsZW1lbnQiLCJnZXRDYW5kaWRhdGVzIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJpbmNsdWRlQ29udGFpbmVyIiwiY2FuZGlkYXRlcyIsInVuc2hpZnQiLCJlbCIsImdldFJvb3ROb2RlIiwiaXNJbnB1dCIsIm5vZGUiLCJpc0hpZGRlbklucHV0IiwicmFkaW9TZXQiLCJlc2NhcGUiLCJ0YWdOYW1lIiwic2xpY2UiLCJhcHBseSIsInNvbWUiLCJ3aWR0aCIsImlzSGlkZGVuIiwibm9kZVVuZGVyRGV0YWlscyIsImhvc3QiLCJub2RlUm9vdEhvc3QiLCJjb250YWlucyIsImF0dGFjaGVkIiwib3JpZ2luYWxOb2RlIiwiaXNaZXJvQXJlYSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImhlaWdodCIsIl9yZWYiLCJnZXRTaGFkb3dSb290IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInZpc2liaWxpdHkiLCJpc0RpcmVjdFN1bW1hcnkiLCJkaXNwbGF5Q2hlY2siLCJpc05vZGVBdHRhY2hlZCIsInBhcmVudEVsZW1lbnQiLCJyb290Tm9kZSIsInNoYWRvd1Jvb3QiLCJhc3NpZ25lZFNsb3QiLCJnZXRDbGllbnRSZWN0cyIsInBhcmVudE5vZGUiLCJpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlIiwiaXNEaXNhYmxlZEZyb21GaWVsZHNldCIsImlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZSIsImRpc2FibGVkIiwiaXRlbSIsInRhYkluZGV4IiwiaXNTY29wZSIsImlzRGV0YWlsc1dpdGhTdW1tYXJ5IiwiY2FuZGlkYXRlVGFiaW5kZXgiLCJyZWd1bGFyVGFiYmFibGVzIiwiZG9jdW1lbnRPcmRlciIsImZhY3RvcnkiLCJ0aGlzIiwiX2NyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsYXNzQ2FsbENoZWNrIiwiVHlwZUVycm9yIiwiX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nIiwiSW5lcnRSb290Iiwicm9vdEVsZW1lbnQiLCJpbmVydE1hbmFnZXIiLCJfaW5lcnRNYW5hZ2VyIiwiX3Jvb3RFbGVtZW50IiwiX21hbmFnZWROb2RlcyIsImhhc0F0dHJpYnV0ZSIsIl9zYXZlZEFyaWFIaWRkZW4iLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSIsIl9vYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJfb25NdXRhdGlvbiIsImJpbmQiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJkZXN0cnVjdG9yIiwiZGlzY29ubmVjdCIsInJlbW92ZUF0dHJpYnV0ZSIsImluZXJ0Tm9kZSIsIl91bm1hbmFnZU5vZGUiLCJzdGFydE5vZGUiLCJfdGhpczIiLCJjb21wb3NlZFRyZWVXYWxrIiwiX3Zpc2l0Tm9kZSIsImFjdGl2ZUVsZW1lbnQiLCJib2R5Iiwibm9kZVR5cGUiLCJOb2RlIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImJsdXIiLCJmb2N1cyIsIkVMRU1FTlRfTk9ERSIsIl9hZG9wdEluZXJ0Um9vdCIsIl9tYW5hZ2VOb2RlIiwicmVnaXN0ZXIiLCJkZXJlZ2lzdGVyIiwiX3VubWFuYWdlU3VidHJlZSIsIl90aGlzMyIsImluZXJ0U3Vicm9vdCIsImdldEluZXJ0Um9vdCIsInNldEluZXJ0IiwibWFuYWdlZE5vZGVzIiwic2F2ZWRJbmVydE5vZGUiLCJyZWNvcmRzIiwicmVjb3JkIiwiYWRkZWROb2RlcyIsInJlbW92ZWROb2RlcyIsImF0dHJpYnV0ZU5hbWUiLCJtYW5hZ2VkTm9kZSIsImFyaWFIaWRkZW4iLCJJbmVydE5vZGUiLCJpbmVydFJvb3QiLCJfbm9kZSIsIl9vdmVycm9kZUZvY3VzTWV0aG9kIiwiX2luZXJ0Um9vdHMiLCJfc2F2ZWRUYWJJbmRleCIsIl9kZXN0cm95ZWQiLCJlbnN1cmVVbnRhYmJhYmxlIiwiX3Rocm93SWZEZXN0cm95ZWQiLCJkZXN0cm95ZWQiLCJoYXNTYXZlZFRhYkluZGV4IiwiYWRkSW5lcnRSb290IiwicmVtb3ZlSW5lcnRSb290IiwiSW5lcnRNYW5hZ2VyIiwiX2RvY3VtZW50IiwiX3dhdGNoRm9ySW5lcnQiLCJhZGRJbmVydFN0eWxlIiwiaGVhZCIsImRvY3VtZW50RWxlbWVudCIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiX29uRG9jdW1lbnRMb2FkZWQiLCJpbmVydCIsInBhcmVudCIsIl9pbmVydFJvb3QiLCJpbmVydEVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImluZXJ0RWxlbWVudCIsIl90aGlzIiwic2hhZG93Um9vdEFuY2VzdG9yIiwibG9jYWxOYW1lIiwiY29udGVudCIsImRpc3RyaWJ1dGVkTm9kZXMiLCJnZXREaXN0cmlidXRlZE5vZGVzIiwic2xvdCIsIl9kaXN0cmlidXRlZE5vZGVzIiwiYXNzaWduZWROb2RlcyIsImZsYXR0ZW4iLCJfaSIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZXh0Q29udGVudCIsImFwcGVuZENoaWxkIiwiSFRNTEVsZW1lbnQiLCJfYmxvY2tpbmdFbGVtZW50cyIsIl9hbHJlYWR5SW5lcnRFbGVtZW50cyIsIl90b3BFbFBhcmVudHMiLCJfc2libGluZ3NUb1Jlc3RvcmUiLCJfaW5lcnRTaWJsaW5ncyIsIl9nZXRQYXJlbnRzIiwiX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4iLCJfaGFuZGxlTXV0YXRpb25zIiwibnVsbGFibGUiLCJ0b3AiLCJlbGVtcyIsInB1c2giLCJpbmRleE9mIiwiX3RvcENoYW5nZWQiLCJwb3AiLCJyZW1vdmUiLCJfYSIsIl9iIiwiX2MiLCJuZXdUb3AiLCJ0b0tlZXBJbmVydCIsIm9sZFBhcmVudHMiLCJfcmVzdG9yZUluZXJ0ZWRTaWJsaW5ncyIsIm5ld1BhcmVudHMiLCJ0b1NraXAiLCJqIiwiX3N3YXBJbmVydGVkU2libGluZyIsIm9sZEluZXJ0IiwibmV3SW5lcnQiLCJzaWJsaW5nc1RvUmVzdG9yZSIsImRlbGV0ZSIsIl9wYXJlbnRNTyIsImVsZW1lbnRzIiwibW8iLCJzaWJsaW5ncyIsInNpYmxpbmciLCJpbmVydGVkU2libGluZ3MiLCJfaXNJbmVydGFibGUiLCJwYXJlbnRUb09ic2VydmUiLCJtYXliZVNoYWR5Um9vdCIsIl9fc2hhZHkiLCJtdXRhdGlvbnMiLCJwYXJlbnRzIiwibXV0YXRpb24iLCJpZHgiLCJpbmVydGVkQ2hpbGQiLCJ1c2VCbG9ja2luZ0VsZW1lbnQiLCJlbmFibGVkIiwiZ2V0VGFyZ2V0Iiwic3RhYmxlR2V0VGFyZ2V0IiwidXNlU3RhYmxlQ2FsbGJhY2siLCJibG9ja2luZ0VsZW1lbnRzIiwidXNlRm9jdXNUcmFwIiwidHJhcEFjdGl2ZSIsImhhbmRsZUFjdGl2ZUNoYW5nZSIsInJhZkhhbmRsZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInF1ZXVlTWljcm90YXNrIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJnZXRUb3BFbGVtZW50IiwiZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvIiwiZ2V0TGFzdEFjdGl2ZUVsZW1lbnQiLCJnZXRFbGVtZW50IiwidXNlRm9yY2VVcGRhdGUiLCJ1c2VIYXNGb2N1cyIsIm9uRm9jdXNlZENoYW5nZWQiLCJvbkZvY3VzZWRJbm5lckNoYW5nZWQiLCJvbkxhc3RGb2N1c2VkQ2hhbmdlZCIsIm9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQiLCJvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlIiwib25BY3RpdmVFbGVtZW50Q2hhbmdlIiwib25XaW5kb3dGb2N1c2VkQ2hhbmdlIiwiZ2V0V2luZG93IiwiZ2V0Rm9jdXNlZCIsInNldEZvY3VzZWQiLCJyZXR1cm5GYWxzZSIsInNldEZvY3VzZWRJbm5lciIsInNldExhc3RGb2N1c2VkIiwic2V0TGFzdEZvY3VzZWRJbm5lciIsInVzZVJlZkVsZW1lbnRQcm9wcyIsImdldEFjdGl2ZUVsZW1lbnQiLCJnZXRXaW5kb3dGb2N1c2VkIiwidXNlQWN0aXZlRWxlbWVudCIsInByZXZBY3RpdmVFbGVtZW50Iiwic2VsZkVsZW1lbnQiLCJmb2N1c2VkIiwiZm9jdXNlZElubmVyIiwibGFzdEFjdGl2ZUVsZW1lbnQiLCJwcmV2TGFzdEFjdGl2ZUVsZW1lbnQiLCJ1c2VIYXNGb2N1c1Byb3BzIiwiZ2V0TGFzdEZvY3VzZWQiLCJnZXRMYXN0Rm9jdXNlZElubmVyIiwidXNlTG9naWNhbERpcmVjdGlvbiIsIm9uTG9naWNhbERpcmVjdGlvbkNoYW5nZSIsImdldENvbXB1dGVkU3R5bGVzIiwic2V0Q29tcHV0ZWRTdHlsZXMiLCJyZXR1cm5OdWxsIiwidXNlRWxlbWVudFNpemVQcm9wcyIsInVzZUVsZW1lbnRTaXplIiwib25TaXplQ2hhbmdlIiwiXyIsImdldExvZ2ljYWxEaXJlY3Rpb25JbmZvIiwiY29tcHV0ZWRTdHlsZXMiLCJ3Iiwid3JpdGluZ01vZGUiLCJkIiwiZGlyZWN0aW9uIiwidGV4dE9yaWVudGF0aW9uIiwiV3JpdGluZ01vZGVzIiwiY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uIiwiZWxlbWVudE9yaWVudGF0aW9uIiwiY29udmVydFRvUGh5c2ljYWxTaWRlIiwic2lkZSIsIk0iLCJibG9ja0RpcmVjdGlvbiIsImlubGluZURpcmVjdGlvbiIsImlubGluZU9yaWVudGF0aW9uIiwiY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbiIsImJsb2NrT3JpZW50YXRpb24iLCJjb252ZXJ0RWxlbWVudFNpemUiLCJlbGVtZW50U2l6ZSIsImlubGluZVNpemUiLCJibG9ja1NpemUiLCJjYXBpdGFsaXplIiwiY2xpZW50QmxvY2tTaXplIiwib2Zmc2V0SW5saW5lU2l6ZSIsIm9mZnNldEJsb2NrU2l6ZSIsInNjcm9sbElubGluZVNpemUiLCJzY3JvbGxCbG9ja1NpemUiLCJmMSIsImdldFBoeXNpY2FsTGVmdFRvcCIsImYyIiwiZ2V0UGh5c2ljYWxSaWdodEJvdHRvbSIsImYzIiwiZjQiLCJjbGllbnRJbmxpbmVJbnNldCIsInNjcm9sbElubGluZUluc2V0Iiwib2Zmc2V0SW5saW5lSW5zZXQiLCJzY3JvbGxCbG9ja0luc2V0Iiwib2Zmc2V0QmxvY2tJbnNldCIsImNsaWVudEJsb2NrSW5zZXQiLCJkaXIiLCJiIiwibCIsInVzZVRpbWVvdXQiLCJ0aW1lb3V0IiwidHJpZ2dlckluZGV4Iiwic3RhYmxlQ2FsbGJhY2siLCJzdGFydFRpbWVSZWYiLCJnZXRUaW1lb3V0IiwidGltZW91dElzTnVsbCIsInVzZUxpbmVhck5hdmlnYXRpb24iLCJsaW5lYXJOYXZpZ2F0aW9uIiwibmF2aWdhdGVUb0ZpcnN0IiwibnRmIiwibmF2aWdhdGVUb0xhc3QiLCJudGwiLCJuYXZpZ2F0ZVRvTmV4dCIsIm50biIsIm5hdmlnYXRlVG9QcmV2IiwibnRwIiwibmF2aWdhdGlvbkRpcmVjdGlvbiIsIm5kIiwiZGlzYWJsZUFycm93S2V5cyIsImRhayIsImRpc2FibGVIb21lRW5kS2V5cyIsImRoZWsiLCJ1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHMiLCJnZXREaXNhYmxlSG9tZUVuZEtleXMiLCJ1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHMiLCJvbktleURvd24iLCJjdHJsS2V5IiwibWV0YUtleSIsImdldE5hdmlnYXRpb25EaXJlY3Rpb24iLCJnZXREaXNhYmxlQXJyb3dLZXlzIiwiYWxsb3dzSW5saW5lTmF2aWdhdGlvbiIsInByb3BOYW1lIiwiZGlyZWN0aW9uQWxsb3dlZCIsImFsbG93c0Jsb2NrTmF2aWdhdGlvbiIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwidXNlVHlwZWFoZWFkTmF2aWdhdGlvbiIsInR5cGVhaGVhZE5hdmlnYXRpb24iLCJjb2xsYXRvciIsImdldEluZGV4IiwidHlwZWFoZWFkVGltZW91dCIsInNldEluZGV4Iiwibm9UeXBlYWhlYWQiLCJjdXJyZW50VHlwZWFoZWFkIiwiZ2V0Q3VycmVudFR5cGVhaGVhZCIsInNldEN1cnJlbnRUeXBlYWhlYWQiLCJzZXRJbnZhbGlkVHlwZWFoZWFkIiwiaW52YWxpZFR5cGVhaGVhZCIsInNldEltZUFjdGl2ZSIsImdldEltZUFjdGl2ZSIsIm5leHRUeXBlYWhlYWRDaGFyIiwic2V0TmV4dFR5cGVhaGVhZENoYXIiLCJ0eXBlYWhlYWQiLCJzYWZlTGhzIiwiY29tcGFyZSIsIm5vcm1hbGl6ZSIsInNhZmVSaHMiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsZUNvbXBhcmUiLCJpbnNlcnRpbmdDb21wYXJhdG9yIiwidGV4dCIsImNvbXBhcmF0b3JTaGFyZWQiLCJzdWJzdHJpbmciLCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJfZSIsImltZUFjdGl2ZSIsInJldmVyc2UiLCJ1c2VSb3ZpbmdUYWJJbmRleCIsImluaXRpYWxJbmRleCIsIm9uVGFiYmFibGVSZW5kZXIiLCJvblRhYmJhYmxlSW5kZXhDaGFuZ2UiLCJzZXRUYWJiYWJsZUluZGV4MiIsImZyb21Vc2VySW50ZXJhY3Rpb24iLCJwcmV2SW5kZXgiLCJuZXh0SW5kZXgiLCJjaGFuZ2VJbmRleCIsIm5leHRDaGlsZCIsInBhcmVudFJldHVyblR5cGUiLCJnZXRBdCIsInByZXZDaGlsZCIsImZvY3VzU2VsZiIsImNvcHlBcnJheSIsInNvdXJjZSIsImFycmF5IiwibmF0aXZlRmxvb3IiLCJmbG9vciIsIm5hdGl2ZVJhbmRvbSIsImJhc2VSYW5kb20iLCJsb3dlciIsInVwcGVyIiwic2h1ZmZsZVNlbGYiLCJsYXN0SW5kZXgiLCJyYW5kIiwiYXJyYXlTaHVmZmxlIiwiYXJyYXlNYXAiLCJpdGVyYXRlZSIsImJhc2VWYWx1ZXMiLCJvYmplY3QiLCJiYXNlVGltZXMiLCJhcmdzVGFnIiwiYmFzZUlzQXJndW1lbnRzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJpc0FyZ3VtZW50cyIsInN0dWJGYWxzZSIsImZyZWVFeHBvcnRzIiwiZXhwb3J0cyIsImZyZWVNb2R1bGUiLCJtb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiQnVmZmVyIiwibmF0aXZlSXNCdWZmZXIiLCJpc0J1ZmZlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJyZUlzVWludCIsImlzSW5kZXgiLCJ0ZXN0IiwiaXNMZW5ndGgiLCJhcnJheVRhZyIsImJvb2xUYWciLCJkYXRlVGFnIiwiZXJyb3JUYWciLCJmdW5jVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwib2JqZWN0VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJ0eXBlZEFycmF5VGFncyIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlVW5hcnkiLCJmdW5jIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNCdWZmIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJTdHJpbmciLCJpc1Byb3RvdHlwZSIsIkN0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvIiwib3ZlckFyZyIsInRyYW5zZm9ybSIsIm5hdGl2ZUtleXMiLCJrZXlzIiwiYmFzZUtleXMiLCJhc3luY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiIsImlzQXJyYXlMaWtlIiwiYmFzZVNodWZmbGUiLCJjb2xsZWN0aW9uIiwic2h1ZmZsZSIsInNldEZvcmNlVXBkYXRlIiwicmVhcnJhbmdlIiwic29ydGVkUm93cyIsImluZGV4QXNTb3J0ZWQiLCJpbmRleEFzVW5zb3J0ZWQiLCJtYW5nbGVNYXAiLCJkZW1hbmdsZU1hcCIsInVzZVJlYXJyYW5nZWFibGVQcm9wcyIsImZvcmNlVXBkYXRlIiwiX3ByZXYiLCJtYW5nbGVkSW5kZXgiLCJpbmRleE1hbmdsZXIiLCJkZW1hbmdsZWRJbmRleCIsInNvcnQiLCJoIiwicmVhcnJhbmdlYWJsZUNoaWxkcmVuIiwiaW5kZXhEZW1hbmdsZXIiLCJ1c2VTb3J0YWJsZUNoaWxkcmVuIiwic29ydGFibGVDaGlsZHJlbiIsInVzZXJDb21wYXJlIiwiZGVmYXVsdENvbXBhcmUiLCJ1c2VTb3J0YWJsZVByb3BzIiwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZSIsInVzZVJlYXJyYW5nZWFibGVDaGlsZHJlbiIsInVzZUxpc3ROYXZpZ2F0aW9uIiwicm92aW5nVGFiSW5kZXgiLCJsaXN0TmF2aWdhdGlvbiIsImlkZW50aXR5IiwibWMiLCJ1c2VSb3ZpbmdUYWJJbmRleENoaWxkIiwiZ2V0VGFiYmFibGVJbmRleCIsInNldFRhYmJhYmxlSW5kZXgiLCJuYXZpZ2F0ZVRvSW5kZXgiLCJ0cnlOYXZpZ2F0ZVRvSW5kZXgiLCJkZWZhdWx0IiwidXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkIiwiYyIsInNlYXJjaERpcmVjdGlvbiIsInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMiLCJ1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMiLCJ0YWJiYWJsZSIsImdldFRhYmJhYmxlIiwiYmx1clNlbGYiLCJoaWRkZW4iLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMiLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkIiwidXNlR3JpZE5hdmlnYXRpb24iLCJydGkiLCJscyIsImxuIiwidG4iLCJjdXJyZW50Q29sdW1uIiwic2V0Q3VycmVudENvbHVtbiIsImdldEN1cnJlbnRDb2x1bW4iLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkQXNHcmlkUm93IiwidXNlTGlzdE5hdmlnYXRpb25Qcm9wc0FzR3JpZFBhcmVudCIsInBhcmVudExzUmV0dXJuVHlwZSIsInVzZUdyaWROYXZpZ2F0aW9uUm93IiwiYXNDaGlsZFJvd09mU2VjdGlvbiIsImFzQ2hpbGQiLCJhc1BhcmVudFJvd09mQ2VsbHMiLCJhc1BhcmVudCIsImMyIiwidXNlUmFuZG9tSWQiLCJyYW5kb21JZCIsImJhY2t1cFJhbmRvbUlkIiwiZ2V0QmFja3VwUmFuZG9tSWQiLCJ1c2VkSWQiLCJzZXRVc2VkSWQiLCJnZXRVc2VkSWQiLCJtaXNtYXRjaEVycm9yUmVmIiwiZXhjbHVkZXMiLCJleGNsdWRlIiwidXNlUHJlc3NFdmVudEhhbmRsZXJzIiwib25DbGlja1N5bmMiLCJhY3RpdmUiLCJnZXRBY3RpdmUiLCJzZXRUZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lIiwicHNldWRvQWN0aXZlIiwidGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSIsInVzZUdsb2JhbEhhbmRsZXIiLCJwcmV2Iiwibm9kZVNlbGVjdGVkVGV4dExlbmd0aCIsIkRhdGUiLCJhIiwiY3VycmVudFRpbWUiLCJ0aW1lRGlmZmVyZW5jZSIsImNoYXJhY3RlcnNTZWxlY3RlZCIsImhhbmRsZVByZXNzIiwicHVsc2UiLCJvbk1vdXNlRG93biIsImRldGFpbCIsIm9uQWN0aXZlU3RhcnQiLCJvbk1vdXNlVXAiLCJidXR0b24iLCJvbkFjdGl2ZVN0b3AiLCJvbkJsdXIiLCJzZXRBY3RpdmUiLCJvbk1vdXNlTGVhdmUiLCJ1c2VBcmlhQWNjb3JkaW9uIiwiYWNjb3JkaW9uIiwiX2N1cnJlbnRGb2N1c2VkSW5kZXgiLCJzZXRDdXJyZW50Rm9jdXNlZEluZGV4IiwiZ2V0Q3VycmVudEZvY3VzZWRJbmRleCIsIm1jUmV0dXJuVHlwZSIsInVzZU1hbmFnZWRDaGlsZHJlbiIsIm0iLCJ1Iiwib2NtYzIiLCJjaGFuZ2VUYWJiZWRJbmRleCIsImxpbmVhclJldHVyblR5cGUiLCJjaGFuZ2VFeHBhbmRlZEluZGV4IiwiZ2V0Q3VycmVudEluZGV4IiwiX2dldEN1cnJlbnRFeHBhbmRlZEluZGV4IiwidXNlQ2hpbGRyZW5GbGFnIiwiX2dldFRhYmJlZEluZGV4IiwicmVldmFsdWF0ZUNsb3Nlc3RGaXQiLCJvbkluZGV4Q2hhbmdlIiwiZGVidWdMb2ciLCJvcGVuRnJvbVBhcmVudCIsInNldE9wZW5Gcm9tUGFyZW50IiwiZ2V0T3BlbkZyb21QYXJlbnQiLCJ1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQiLCJ1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50IiwidXNlSGVhZGVyQXNSZWZlcmVuY2VySWQiLCJib2R5SWQiLCJnZXRCb2R5SWQiLCJ1c2VIZWFkZXJBc1NvdXJjZUlkIiwidXNlQm9keUFzUmVmZXJlbmNlcklkIiwiaGVhZGVySWQiLCJnZXRIZWFkZXJJZCIsInVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzIiwidXNlQm9keUFzU291cmNlSWQiLCJ1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMiLCJ1c2VCb2R5QXNSZWZlcmVuY2VySWRQcm9wcyIsInVzZUhlYWRlckFzU291cmNlSWRQcm9wcyIsInVzZUhlYWRlckFzUmVmZXJlbmNlcklkUHJvcHMiLCJvcGVuIiwib3BlbkZyb21Vc2VyIiwiZ2V0SGVhZGVyRWxlbWVudCIsInVzZUhlYWRlclJlZkVsZW1lbnRQcm9wcyIsImdldEJvZHlFbGVtZW50IiwidXNlQm9keVJlZkVsZW1lbnRQcm9wcyIsIm9wZW5SZWYiLCJib2R5RWxlbWVudCIsImlzVmFsaWQiLCJyZXR1cm5UcnVlIiwidGFiYmVkUmVmIiwidXNlTGFiZWwiLCJsYWJlbCIsInByZWZpeElucHV0IiwicHJlZml4TGFiZWwiLCJ0YWdJbnB1dCIsInRhZ0xhYmVsIiwidXNlTGFiZWxBc1NvdXJjZUlkIiwidXNlTGFiZWxBc1JlZmVyZW5jZXJJZCIsImxhYmVsSWQiLCJnZXRMYWJlbElkIiwidXNlSW5wdXRBc1NvdXJjZUlkIiwidXNlSW5wdXRBc1JlZmVyZW5jZXJJZCIsImlucHV0SWQiLCJnZXRJbnB1dElkIiwidXNlTGFiZWxBc1NvdXJjZUlkUHJvcHMiLCJ1c2VJbnB1dEFzU291cmNlSWRQcm9wcyIsInVzZUxhYmVsQXNSZWZlcmVuY2VySWRQcm9wcyIsInVzZUlucHV0QXNSZWZlcmVuY2VySWRQcm9wcyIsImlzU3ludGhldGljTGFiZWwiLCJ1c2VMYWJlbExhYmVsIiwidXNlTGFiZWxMYWJlbFByb3BzIiwicHJvcHNXaXRob3V0Rm9yIiwicHJvcHNXaXRoRm9yIiwidXNlTGFiZWxJbnB1dCIsInByb3BzV2l0aEFyaWFMYWJlbGxlZEJ5IiwicHJvcHNXaXRob3V0QXJpYUxhYmVsbGVkQnkiLCJoYW5kbGVzSW5wdXQiLCJsYWJlbFBvc2l0aW9uIiwid2hpY2giLCJ1c2VBcmlhQ2hlY2tib3giLCJjaGVja2JveExpa2UiLCJjaGVja2JveCIsInVzZUNoZWNrYm94R3JvdXAiLCJsaXN0UmV0dXJuVHlwZSIsImFsbElkcyIsImFyaWFDb250cm9scyIsInNldEFyaWFDb250cm9scyIsInVwZGF0ZUluZGV4Iiwic2V0SWRVcGRhdGVJbmRleCIsImNoZWNrZWRDb3VudCIsInNldENoZWNrZWRDb3VudCIsImNoZWNrZWRJbmRpY2VzIiwiZ2V0U2VsZklzQ2hlY2tlZFVuc3RhYmxlIiwicGVyY2VudGFnZSIsImdldFNlbGZJc0NoZWNrZWRTdGFibGUiLCJzZXRQYXJlbnRDaGVja2JveENoZWNrZWQiLCJzZXRTZXRQYXJlbnRDaGVja2JveENoZWNrZWQiLCJjaGVja2VkIiwic2V0Q2hlY2tlZCIsInVzZUNoZWNrYm94SW5wdXRFbGVtZW50IiwidXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQiLCJvbklucHV0Iiwib25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQyIiwidXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyIsInVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMiLCJ1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcyIsInVzZUNoZWNrYm94R3JvdXBQYXJlbnRMYWJlbFByb3BzIiwidXNlU29mdERpc21pc3MiLCJvbkNsb3NlIiwiZ2V0RWxlbWVudHMiLCJzdGFibGVPbkNsb3NlIiwic3RhYmxlR2V0RWxlbWVudHMiLCJnZXRPcGVuIiwib25CYWNrZHJvcENsaWNrIiwiZm91bmRJbnNpZGVDbGljayIsIm5ld0VsZW1lbnQiLCJ2YWxpZEZvY3VzYWJsZUVsZW1lbnRzIiwiZm9jdXNhYmxlIiwibW91c2VEb3duIiwia2V5RG93biIsImNhcHR1cmUiLCJ0b3VjaFN0YXJ0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVzZVNvZnREaXNtaXNzUHJvcHMiLCJzb2Z0RGlzbWlzcyIsInVzZU1vZGFsIiwibW9kYWwiLCJib2R5SXNPbmx5U2VtYW50aWMiLCJkZXNjcmlwdGl2ZSIsInVzZVRpdGxlUmVmRWxlbWVudFByb3BzIiwiZ2V0VGl0bGVFbGVtZW50IiwidGl0bGVFbGVtZW50Iiwic3RhYmxlRm9jdXNTZWxmIiwidXNlTW9kYWxJZEFzU291cmNlIiwidXNlTW9kYWxJZEFzUmVmZXJlbmNlckVsZW1lbnQiLCJ1c2VCb2R5SWRBc1NvdXJjZSIsInVzZUJvZHlJZFJlZmVyZW5jZXJFbGVtZW50IiwidXNlVGl0bGVJZEFzU291cmNlIiwidXNlVGl0bGVJZFJlZmVyZW5jZXJFbGVtZW50IiwiZ2V0TW9kYWxFbGVtZW50IiwidXNlTW9kYWxCYWNrZHJvcCIsInVzZU1vZGFsQmFja2Ryb3BQcm9wcyIsIm9uUG9pbnRlclVwIiwidXNlQXJpYUxpc3Rib3hTaW5nbGUiLCJsaXN0Ym94U2luZ2xlIiwic2VsZWN0aW9uTW9kZSIsInRhZ0xpc3QiLCJvblNlbGVjdCIsIl9sYnMiLCJzaW5nbGVTZWxlY3Rpb24iLCJzZWxlY3RlZEluZGV4Iiwic3MiLCJjaGYiLCJsYWJlbFJldHVyblR5cGUiLCJ1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkIiwidXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyIsInVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uIiwidXNlTGFiZWxJbnB1dFByb3BzIiwic3RhYmxlT25TZWxlY3QiLCJoYXNGb2N1cyIsInJ0aV9yZXQiLCJ1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzIiwic3NfcmV0IiwibmV3UHJvcHMiLCJ1c2VBcmlhTGlzdGJveE11bHRpIiwidXNlTWVudVN1cmZhY2UiLCJtZW51U3VyZmFjZSIsInNlbmRGb2N1c1RvTWVudSIsInJvbGUiLCJoYXNGb2N1c0J1dHRvbiIsImhhc0ZvY3VzU3VyZmFjZSIsInVzZXJPbkNsb3NlIiwicmVhc29uIiwib3BlbmVyIiwiZ2V0T3BlbmVyRWxlbWVudCIsInByZXZlbnRTY3JvbGwiLCJnZXRJc09wZW4iLCJpbnRlcnNlY3Rpb25PYnNlcnZlciIsImdldFN1cmZhY2VGdWxseVZpc2libGUiLCJzZXRTdXJmYWNlRnVsbHlWaXNpYmxlIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlciIsImVudHJ5IiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJ0aHJlc2hvbGQiLCJzZXRPcGVuZXJFbGVtZW50IiwidXNlTWVudUJhc2VIYXNGb2N1c1Byb3BzIiwic3VyZmFjZUhhc0ZvY3VzIiwidXNlQnV0dG9uSGFzRm9jdXNQcm9wcyIsImJ1dHRvbkhhc0ZvY3VzIiwiZ2V0QnV0dG9uRWxlbWVudCIsInVzZUJ1dHRvblJlZkVsZW1lbnRQcm9wcyIsInVzZU1lbnVCYXNlUmVmRWxlbWVudFByb3BzIiwic29mdERpc21pc3NSZXR1cm4iLCJnZXRNZW51RWxlbWVudCIsInVzZU1lbnVTdXJmYWNlUHJvcHMiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJzZXRUaW1lb3V0Iiwic2Nyb2xsSW50b1ZpZXciLCJ1c2VNZW51U3VyZmFjZUNoaWxkUHJvcHMiLCJ1c2VNZW51U3VyZmFjZVNlbnRpbmVsIiwidXNlU2VudGluZWxQcm9wcyIsInVzZU1lbnVTZW50aW5lbFByb3BzIiwicmVzdCIsImZvY3VzU2VudGluZWwiLCJ1c2VNZW51U3VyZmFjZUJ1dHRvblByb3BzIiwiZ2V0U3VyZmFjZUVsZW1lbnQiLCJnZXRTdXJmYWNlRm9jdXNlZCIsImdldFN1cmZhY2VGb2N1c2VkSW5uZXIiLCJnZXRGb2N1c2VkSW5uZXIiLCJ1c2VBcmlhVGFicyIsInRhYlBhbmVscyIsIm9jbWMiLCJ0YWJQYW5lbHNNYW5hZ2VkQ2hpbGRyZW4iLCJiYXNlSWQiLCJnZXRUYWJJZCIsImdldFBhbmVsSWQiLCJtYW5hZ2VkQ2hpbGRyZW5SZXQiLCJnZXRWaXNpYmxlSW5kZXgiLCJjbG9zZXN0Rml0IiwidXNlQXJpYVRhYkxpc3RMYWJlbCIsInVzZUFyaWFUYWJMaXN0TGFiZWxQcm9wcyIsInVzZUFyaWFUYWJMaXN0IiwiY2hpbGRyZW5IYXZlRm9jdXMiLCJ0YWJzIiwib25TZWxlY3RlZEluZGV4Q2hhbmdlIiwidGFiTGlzdE1hbmFnZWRDaGlsZHJlbiIsInN0YWJsZU9uU2VsZWN0ZWRJbmRleENoYW5nZSIsInVzZUFyaWFUb29sdGlwIiwibW91c2VvdmVyRGVsYXkiLCJtb3VzZW91dERlbGF5IiwiZm9jdXNEZWxheSIsImRlZmF1bHRQcmV2ZW50ZWQiLCJzZXRPcGVuIiwic2V0VHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQiLCJzZXRUb29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZCIsInNldFRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJzZXRUb29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkIiwic2V0VHJpZ2dlckZvY3VzZWQiLCJkZWxheSIsImlzRmluaXRlIiwiaGFuZGxlIiwiY2xlYXJUaW1lb3V0Iiwic2V0VG9vbHRpcEZvY3VzZWQiLCJzZXRUcmlnZ2VySG92ZXIiLCJob3ZlcmluZyIsInNldFRvb2x0aXBIb3ZlciIsInRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkIiwidG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCIsInRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkIiwidHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCIsInVzZVRvb2x0aXBUcmlnZ2VyIiwib25Ub3VjaEVuZCIsInVzZUFyaWFSYWRpb0dyb3VwIiwidGFnR3JvdXBMYWJlbCIsInNlbGVjdGVkVmFsdWUiLCJfZ2V0UmFkaW9Hcm91cFBhcmVudEVsZW1lbnQiLCJzZXRTZWxlY3RlZEluZGV4IiwidXNlR3JvdXBMYWJlbElucHV0IiwidXNlR3JvdXBMYWJlbExhYmVsIiwidGFnR3JvdXAiLCJ1c2VHcm91cExhYmVsSW5wdXRQcm9wcyIsInVzZUdyb3VwTGFiZWxMYWJlbFByb3BzIiwibGlzdE5hdlJldCIsInVzZVJhZGlvR3JvdXBQcm9wcyIsInVzZVJhZGlvR3JvdXBMYWJlbFByb3BzIiwiYnlOYW1lIiwidXNlQXJpYVRhYmxlIiwiZ2V0Q3VycmVudFNvcnRDb2x1bW4iLCJzZXRDdXJyZW50U29ydENvbHVtbiIsImdyaWROYXZSZXQxIiwidGFibGVSb3ciLCJsb2NhdGlvbiIsImNlbGxzIiwidXNlR3JpZE5hdmlnYXRpb25DZWxsIiwidXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyIsImdldENlbGxzIiwiYXNQYXJlbnRPZkNlbGxzIiwiZ3JpZE5hdlJldDIiLCJ1c2VUYWJsZUNlbGwiLCJ1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyIsImdyaWROYXZSZXQzIiwic29ydEluZm8iLCJjZWxsSW5kZXgiLCJBcmlhQWNjb3JkaW9uIiwiZXhwYW5kZWRJbmRleCIsInJlbmRlciIsInVzZUFyaWFBY2NvcmRpb25TZWN0aW9uIiwicHJvdmlkZXIiLCJkZWZhdWx0UmVuZGVyQnV0dG9uIiwibWFrZUJ1dHRvblByb3BzIiwibW9kaWZ5QnV0dG9uUHJvcHMiLCJkZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlIiwibWFrZUlucHV0UHJvcHMiLCJtYWtlTGFiZWxQcm9wcyIsIm1vZGlmeUlucHV0UHJvcHMiLCJtb2RpZnlMYWJlbFByb3BzIiwiaW5wdXQiLCJsYWJlbFByb3BzIiwiZGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBDaGlsZCIsImRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwIiwiVXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dCIsIkNoZWNrYm94R3JvdXAiLCJwYXJlbnREaXNhYmxlZCIsImRlZmF1bHRSZW5kZXJQb3J0YWwiLCJwb3J0YWxJZCIsInBvcnRhbFJlZiIsImdldEVsZW1lbnRCeUlkIiwiY3JlYXRlUG9ydGFsIiwiZGVmYXVsdFJlbmRlck1vZGFsIiwidGFnRm9jdXNDb250YWluZXIiLCJ0YWdCYWNrZHJvcCIsInRhZ0JvZHkiLCJ0YWdEaWFsb2ciLCJ0YWdUaXRsZSIsIm1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyIiwibWFrZVByb3BzQmFja2Ryb3AiLCJtYWtlUHJvcHNCb2R5IiwibWFrZVByb3BzRGlhbG9nIiwibWFrZVByb3BzVGl0bGUiLCJkaWFsb2dJbmZvIiwibW9kaWZ5Rm9jdXNDb250YWluZXJQcm9wcyIsIm1vZGlmeURpYWxvZ1Byb3BzIiwibW9kaWZ5VGl0bGVQcm9wcyIsIm1vZGlmeUJvZHlQcm9wcyIsIm1vZGlmeUJhY2tkcm9wUHJvcHMiLCJ0aXRsZUNoaWxkcmVuIiwidGl0bGVQcm9wcyIsImJvZHlDaGlsZHJlbiIsImJvZHlQcm9wcyIsImRpYWxvZ0NoaWxkcmVuIiwiZGlhbG9nUHJvcHMiLCJiYWNrZHJvcENoaWxkcmVuIiwiYmFja2Ryb3BQcm9wcyIsImZvY3VzQ29udGFpbmVyUHJvcHMiLCJ0aXRsZSIsImRpYWxvZyIsImJhY2tkcm9wIiwiZm9jdXNDb250YWluZXIiLCJmb2N1c0NvbnRhaW5lckNoaWxkcmVuIiwiTGlzdGJveFNpbmdsZUNvbnRleHQiLCJvbkFsbExvc3RGb2N1cyIsIm9uQW55R2FpbmVkRm9jdXMiLCJMaXN0Ym94TXVsdGlDb250ZXh0IiwiTWVudSIsImRlZmF1bHRSZW5kZXJSYWRpb0dyb3VwIiwibWFrZVByb3BzTGFiZWwiLCJtb2RpZnlHcm91cFByb3BzIiwibWFrZVByb3BzR3JvdXAiLCJTbGlkZXJUaHVtYkNvbnRleHQiLCJTbGlkZXIiLCJtaW4iLCJ1c2VBcmlhU2xpZGVyVGh1bWIiLCJfc2xpZGVySW5mbyIsInVzZUFyaWFTbGlkZXIiLCJzbGlkZXIiLCJMb2NhdGlvbkNvbnRleHQiLCJUYWJsZUJvZHlDb250ZXh0IiwiVGFibGVSb3dDb250ZXh0IiwiVGFibGVDZWxsQ29udGV4dCIsImRlZmF1bHRSZW5kZXJUYWJsZSIsInRhZ1RhYmxlIiwibWFrZVByb3BzVGFibGUiLCJtb2RpZnlQcm9wc1RhYmxlIiwiZGVmYXVsdFJlbmRlclRhYmxlUm93IiwidGFnVGFibGVSb3ciLCJtYWtlUHJvcHNUYWJsZVJvdyIsIm1vZGlmeVByb3BzVGFibGVSb3ciLCJkZWZhdWx0UmVuZGVyVGFibGVDZWxsIiwidGFnVGFibGVDZWxsIiwibWFrZVByb3BzVGFibGVDZWxsIiwibW9kaWZ5UHJvcHNUYWJsZUNlbGwiLCJUYWJDb250ZXh0IiwiVGFiUGFuZWxDb250ZXh0IiwiVGFicyIsImRlZmF1bHRSZW5kZXIiLCJ0cmlnZ2VyUHJvcHMiLCJ0b29sdGlwUHJvcHMiLCJfRnJhZ21lbnQiLCJCbHVyYiIsIkNvZGUiLCJEZW1vIiwiRGVtb0NoZWNrYm94IiwiRGVtb0xpc3RJdGVtIiwiVGFicy5EZW1vIiwiRGlhbG9nLkRlbW8iLCJTbGlkZXIuRGVtbyIsIkxpc3Rib3hTaW5nbGUuRGVtbyIsIkFjY29yZGlvbi5EZW1vIiwiQnV0dG9uLkRlbW8iLCJDaGVja2JveC5EZW1vIiwiQ2hlY2tib3hHcm91cC5EZW1vIiwiTGlzdGJveE11bHRpLkRlbW8iLCJNZW51LkRlbW8iLCJSYWRpby5EZW1vIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEwRUMsTUFBQUEsV0FBQSxHQUFBQyxNQUFBLENBQUEsY0FBQSxDQUFBLENBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQ3RFRCxNQUFNQyxtQkFBbUIsR0FBR0MsR0FBYSxDQUFDLENBQUQsQ0FBekMsQ0FBQTtJQUdJLGdCQUFBLENBQTZELElBQUEsRUFBQTtNQUFBOztRQUFoQ0M7UUFBVyxHQUFBQyxLQUFBQTtPQUFxQixHQUFBLElBQUEsQ0FBQTtJQUM3RCxFQUFBLE1BQU1DLG9CQUFzQyxHQUFBQyxHQUFBLENBQUFMLG1CQUFBLENBQTVDLENBQUE7SUFDQSxFQUFBLHFCQUFnQixHQUFBSSxvQkFBQSxH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
