var _excluded = ["children", "heading", "tag"],
  _excluded2 = ["managedChildrenParameters"],
  _excluded3 = ["onClose", "open", "getWindow", "parentDepth"],
  _excluded4 = ["getElement"],
  _excluded5 = ["getElement"],
  _excluded6 = ["refElementPopupReturn", "refElementSourceReturn", "lostFocusDismiss"],
  _excluded7 = ["getElement"],
  _excluded8 = ["open", "onClose"],
  _excluded9 = ["getElement"],
  _excluded10 = ["backdropDismissParameters", "refElementPopupReturn"],
  _excluded11 = ["onElementChange"],
  _excluded12 = ["collator", "typeaheadTimeout", "noTypeahead", "isValid"],
  _excluded13 = ["getTabbableIndex", "setTabbableIndex"],
  _excluded14 = ["typeaheadNavigationParameters", "rovingTabIndexReturn"],
  _excluded15 = ["index"],
  _excluded16 = ["getText"],
  _excluded17 = ["sortedTypeaheadInfo", "insertingComparator"],
  _excluded18 = ["getElement"],
  _excluded19 = ["managedChildParameters", "textContentParameters", "typeaheadNavigationChildContext", "refElementReturn"],
  _excluded20 = ["managedChildrenReturn", "rovingTabIndexParameters"],
  _excluded21 = ["index"],
  _excluded22 = ["hidden"],
  _excluded23 = ["linearNavigationParameters", "typeaheadNavigationParameters", "rovingTabIndexParameters", "managedChildrenReturn"],
  _excluded24 = ["rovingTabIndexChildParameters", "rovingTabIndexChildContext", "typeaheadNavigationChildContext", "managedChildParameters", "refElementReturn", "textContentParameters"],
  _excluded25 = ["onTabbableColumnChange"],
  _excluded26 = ["onTabbableIndexChange"],
  _excluded27 = ["gridNavigationParameters", "linearNavigationParameters", "rovingTabIndexParameters", "managedChildrenReturn", "typeaheadNavigationParameters"],
  _excluded28 = ["linearNavigationReturn", "rovingTabIndexReturn", "typeaheadNavigationReturn", "managedChildrenParameters", "rovingTabIndexChildContext", "typeaheadNavigationChildContext"],
  _excluded29 = ["gridNavigationRowContext"],
  _excluded30 = ["linearNavigationParameters"],
  _excluded31 = ["asChildRowParameters", "asParentRowParameters"],
  _excluded32 = ["rovingTabIndexChildContext", "typeaheadNavigationChildContext", "rovingTabIndexChildParameters", "managedChildParameters", "refElementReturn", "textContentParameters", "gridNavigationCellParameters", "gridNavigationCellContext"],
  _excluded33 = ["hasCurrentFocusParameters", "rovingTabIndexChildReturn", "textContentReturn"],
  _excluded34 = ["gridNavigationParameters", "linearNavigationParameters", "rovingTabIndexParameters", "managedChildrenReturn", "typeaheadNavigationParameters", "singleSelectionParameters"],
  _excluded35 = ["asChildRowParameters", "asParentRowParameters"],
  _excluded36 = ["onCurrentFocusedInnerChanged"],
  _excluded37 = ["hasCurrentFocusParameters", "gridNavigationRowParameters", "rovingTabIndexChildReturn", "textContentReturn"],
  _excluded38 = ["onCurrentFocusedInnerChanged"],
  _excluded39 = ["children"],
  _excluded40 = ["rearrangeableChildrenParameters", "sortableChildrenParameters", "linearNavigationParameters"],
  _excluded41 = ["linearNavigationParameters", "rovingTabIndexParameters", "typeaheadNavigationParameters", "singleSelectionParameters", "managedChildrenReturn"],
  _excluded42 = ["index"],
  _excluded43 = ["hidden"],
  _excluded44 = ["managedChildParameters", "rovingTabIndexChildParameters", "singleSelectionChildParameters", "singleSelectionContext", "rovingTabIndexChildContext", "typeaheadNavigationChildContext", "refElementReturn", "textContentParameters"],
  _excluded45 = ["hasCurrentFocusParameters"],
  _excluded46 = ["onCurrentFocusedInnerChanged"],
  _excluded47 = ["hasCurrentFocusParameters"],
  _excluded48 = ["onCurrentFocusedInnerChanged"],
  _excluded49 = ["childrenHaveFocusParameters", "managedChildrenParameters", "rovingTabIndexChildContext", "singleSelectionContext", "typeaheadNavigationChildContext", "gridNavigationRowContext"],
  _excluded50 = ["managedChildParameters", "context", "completeGridNavigationRowParameters", "singleSelectionChildParameters", "rovingTabIndexChildParameters"],
  _excluded51 = ["linearNavigationParameters", "rovingTabIndexParameters", "typeaheadNavigationParameters"],
  _excluded52 = ["onPressSync"],
  _excluded53 = ["linearNavigationParameters", "rearrangeableChildrenParameters", "sortableChildrenParameters", "typeaheadNavigationParameters", "rovingTabIndexParameters", "singleSelectionParameters"],
  _excluded54 = ["onPressSync"],
  _excluded55 = ["completeListNavigationChildParameters", "singleSelectionChildParameters", "rovingTabIndexChildParameters", "managedChildParameters", "textContentParameters", "context", "pressParameters", "sortableChildParameters"],
  _excluded56 = ["onPressSync"],
  _excluded57 = ["trapActive"],
  _excluded58 = ["refElementReturn"],
  _excluded59 = ["refElementReturn"],
  _excluded60 = ["getElement", "propsStable"],
  _excluded61 = ["linearNavigationParameters", "toolbarParameters"],
  _excluded62 = ["context", "props"],
  _excluded63 = ["linearNavigationReturn", "childrenHaveFocusReturn", "context", "props", "rearrangeableChildrenReturn", "singleSelectionReturn", "sortableChildrenReturn", "managedChildrenReturn", "rovingTabIndexReturn", "toolbarReturn", "typeaheadNavigationReturn"],
  _excluded64 = ["sliderContext"],
  _excluded65 = ["tableCellParameters"],
  _excluded66 = ["context", "managedChildrenReturn"],
  _excluded67 = ["index"],
  _excluded68 = ["disableArrowKeys", "disableHomeEndKeys", "initialIndex", "navigationDirection", "onAfterChildLayoutEffect", "onChildrenMountChange", "navigatePastEnd", "navigatePastStart", "pageNavigationSize", "render"],
  _excluded69 = ["children"],
  _excluded70 = ["render", "collator", "disableArrowKeys", "disableHomeEndKeys", "navigationDirection", "noTypeahead", "typeaheadTimeout", "onTabbableIndexChange", "compare", "getIndex", "untabbable", "navigatePastEnd", "navigatePastStart", "pageNavigationSize", "children"],
  _excluded71 = ["render", "index", "focusSelf", "exclude", "hidden", "getText", "onPressSync", "getSortValue"],
  _excluded72 = ["index", "exclude", "onPressSync", "render", "checked", "onChangeFromParent", "getSortValue", "hidden", "getText", "focusSelf"],
  _excluded73 = ["listboxContext"],
  _excluded74 = ["children"];
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError("Cannot destructure " + obj); }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
(function () {
  'use strict';

  var n,
    l$1,
    u$1,
    t$1,
    o$2,
    r$2,
    f$1 = {},
    e$1 = [],
    c$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  function s$1(n, l) {
    for (var u in l) {
      n[u] = l[u];
    }
    return n;
  }
  function a$1(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
  }
  function h$1(l, u, i) {
    var t,
      o,
      r,
      f = {};
    for (r in u) {
      "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
    }
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) {
      void 0 === f[r] && (f[r] = l.defaultProps[r]);
    }
    return v$1(l, f, t, o, null);
  }
  function v$1(n, i, t, o, r) {
    var f = {
      type: n,
      props: i,
      key: t,
      ref: o,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: null == r ? ++u$1 : r
    };
    return null == r && null != l$1.vnode && l$1.vnode(f), f;
  }
  function p$1(n) {
    return n.children;
  }
  function d$1(n, l) {
    this.props = n, this.context = l;
  }
  function _$2(n, l) {
    if (null == l) return n.__ ? _$2(n.__, n.__.__k.indexOf(n) + 1) : null;
    for (var u; l < n.__k.length; l++) {
      if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    }
    return "function" == typeof n.type ? _$2(n) : null;
  }
  function k$2(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
      for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {
        if (null != (u = n.__k[l]) && null != u.__e) {
          n.__e = n.__c.base = u.__e;
          break;
        }
      }
      return k$2(n);
    }
  }
  function b$1(n) {
    (!n.__d && (n.__d = !0) && t$1.push(n) && !g$2.__r++ || o$2 !== l$1.debounceRendering) && ((o$2 = l$1.debounceRendering) || setTimeout)(g$2);
  }
  function g$2() {
    for (var n; g$2.__r = t$1.length;) {
      n = t$1.sort(function (n, l) {
        return n.__v.__b - l.__v.__b;
      }), t$1 = [], n.some(function (n) {
        var l, u, i, t, o, r;
        n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = s$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? _$2(t) : o, t.__h), z$2(u, t), t.__e != o && k$2(t)));
      });
    }
  }
  function w$2(n, l, u, i, t, o, r, c, s, a) {
    var h,
      y,
      d,
      k,
      b,
      g,
      w,
      x = i && i.__k || e$1,
      C = x.length;
    for (u.__k = [], h = 0; h < l.length; h++) {
      if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? v$1(null, k, null, null, k) : Array.isArray(k) ? v$1(p$1, {
        children: k
      }, null, null, null) : k.__b > 0 ? v$1(k.type, k.props, k.key, k.ref ? k.ref : null, k.__v) : k)) {
        if (k.__ = u, k.__b = u.__b + 1, null === (d = x[h]) || d && k.key == d.key && k.type === d.type) x[h] = void 0;else for (y = 0; y < C; y++) {
          if ((d = x[y]) && k.key == d.key && k.type === d.type) {
            x[y] = void 0;
            break;
          }
          d = null;
        }
        j$2(n, k, d = d || f$1, t, o, r, c, s, a), b = k.__e, (y = k.ref) && d.ref != y && (w || (w = []), d.ref && w.push(d.ref, null, k), w.push(y, k.__c || b, k)), null != b ? (null == g && (g = b), "function" == typeof k.type && k.__k === d.__k ? k.__d = s = m$1(k, s, n) : s = A$1(n, k, d, x, b, s), "function" == typeof u.type && (u.__d = s)) : s && d.__e == s && s.parentNode != n && (s = _$2(d));
      }
    }
    for (u.__e = g, h = C; h--;) {
      null != x[h] && N$1(x[h], x[h]);
    }
    if (w) for (h = 0; h < w.length; h++) {
      M(w[h], w[++h], w[++h]);
    }
  }
  function m$1(n, l, u) {
    for (var i, t = n.__k, o = 0; t && o < t.length; o++) {
      (i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? m$1(i, l, u) : A$1(u, i, i, t, i.__e, l));
    }
    return l;
  }
  function x$1(n, l) {
    return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
      x$1(n, l);
    }) : l.push(n)), l;
  }
  function A$1(n, l, u, i, t, o) {
    var r, f, e;
    if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
      for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 1) {
        if (f == t) break n;
      }
      n.insertBefore(t, o), r = o;
    }
    return void 0 !== r ? r : t.nextSibling;
  }
  function C$1(n, l, u, i, t) {
    var o;
    for (o in u) {
      "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);
    }
    for (o in l) {
      t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
    }
  }
  function $$1(n, l, u) {
    "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || c$1.test(l) ? u : u + "px";
  }
  function H$1(n, l, u, i, t) {
    var o;
    n: if ("style" === l) {
      if ("string" == typeof u) n.style.cssText = u;else {
        if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) {
          u && l in u || $$1(n.style, l, "");
        }
        if (u) for (l in u) {
          i && u[l] === i[l] || $$1(n.style, l, u[l]);
        }
      }
    } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$2 : I$1, o) : n.removeEventListener(l, o ? T$2 : I$1, o);else if ("dangerouslySetInnerHTML" !== l) {
      if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
        n[l] = null == u ? "" : u;
        break n;
      } catch (n) {}
      "function" == typeof u || (null == u || !1 === u && -1 == l.indexOf("-") ? n.removeAttribute(l) : n.setAttribute(l, u));
    }
  }
  function I$1(n) {
    this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
  }
  function T$2(n) {
    this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
  }
  function j$2(n, u, i, t, o, r, f, e, c) {
    var a,
      h,
      v,
      y,
      _,
      k,
      b,
      g,
      m,
      x,
      A,
      C,
      $,
      H,
      I,
      T = u.type;
    if (void 0 !== u.constructor) return null;
    null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (a = l$1.__b) && a(u);
    try {
      n: if ("function" == typeof T) {
        if (g = u.props, m = (a = T.contextType) && t[a.__c], x = a ? m ? m.props.value : a.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in T && T.prototype.render ? u.__c = h = new T(g, x) : (u.__c = h = new d$1(g, x), h.constructor = T, h.render = O), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = [], h._sb = []), null == h.__s && (h.__s = h.state), null != T.getDerivedStateFromProps && (h.__s == h.state && (h.__s = s$1({}, h.__s)), s$1(h.__s, T.getDerivedStateFromProps(g, h.__s))), y = h.props, _ = h.state, v) null == T.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
          if (null == T.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
            for (h.props = g, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
              n && (n.__ = u);
            }), A = 0; A < h._sb.length; A++) {
              h.__h.push(h._sb[A]);
            }
            h._sb = [], h.__h.length && f.push(h);
            break n;
          }
          null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
            h.componentDidUpdate(y, _, k);
          });
        }
        if (h.context = x, h.props = g, h.__v = u, h.__P = n, C = l$1.__r, $ = 0, "prototype" in T && T.prototype.render) {
          for (h.state = h.__s, h.__d = !1, C && C(u), a = h.render(h.props, h.state, h.context), H = 0; H < h._sb.length; H++) {
            h.__h.push(h._sb[H]);
          }
          h._sb = [];
        } else do {
          h.__d = !1, C && C(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
        } while (h.__d && ++$ < 25);
        h.state = h.__s, null != h.getChildContext && (t = s$1(s$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, _)), I = null != a && a.type === p$1 && null == a.key ? a.props.children : a, w$2(n, Array.isArray(I) ? I : [I], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
      } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);
      (a = l$1.diffed) && a(u);
    } catch (n) {
      u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
    }
  }
  function z$2(n, u) {
    l$1.__c && l$1.__c(u, n), n.some(function (u) {
      try {
        n = u.__h, u.__h = [], n.some(function (n) {
          n.call(u);
        });
      } catch (n) {
        l$1.__e(n, u.__v);
      }
    });
  }
  function L$1(l, u, i, t, o, r, e, c) {
    var s,
      h,
      v,
      y = i.props,
      p = u.props,
      d = u.type,
      k = 0;
    if ("svg" === d && (o = !0), null != r) for (; k < r.length; k++) {
      if ((s = r[k]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
        l = s, r[k] = null;
        break;
      }
    }
    if (null == l) {
      if (null === d) return document.createTextNode(p);
      l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
    }
    if (null === d) y === p || c && l.data === p || (l.data = p);else {
      if (r = r && n.call(l.childNodes), h = (y = i.props || f$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
        if (null != r) for (y = {}, k = 0; k < l.attributes.length; k++) {
          y[l.attributes[k].name] = l.attributes[k].value;
        }
        (v || h) && (v && (h && v.__html == h.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
      }
      if (C$1(l, p, y, o, c), v) u.__k = [];else if (k = u.props.children, w$2(l, Array.isArray(k) ? k : [k], u, i, t, o && "foreignObject" !== d, r, e, r ? r[0] : i.__k && _$2(i, 0), c), null != r) for (k = r.length; k--;) {
        null != r[k] && a$1(r[k]);
      }
      c || ("value" in p && void 0 !== (k = p.value) && (k !== l.value || "progress" === d && !k || "option" === d && k !== y.value) && H$1(l, "value", k, y.value, !1), "checked" in p && void 0 !== (k = p.checked) && k !== l.checked && H$1(l, "checked", k, y.checked, !1));
    }
    return l;
  }
  function M(n, u, i) {
    try {
      "function" == typeof n ? n(u) : n.current = u;
    } catch (n) {
      l$1.__e(n, i);
    }
  }
  function N$1(n, u, i) {
    var t, o;
    if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M(t, null, u)), null != (t = n.__c)) {
      if (t.componentWillUnmount) try {
        t.componentWillUnmount();
      } catch (n) {
        l$1.__e(n, u);
      }
      t.base = t.__P = null, n.__c = void 0;
    }
    if (t = n.__k) for (o = 0; o < t.length; o++) {
      t[o] && N$1(t[o], u, i || "function" != typeof n.type);
    }
    i || null == n.__e || a$1(n.__e), n.__ = n.__e = n.__d = void 0;
  }
  function O(n, l, u) {
    return this.constructor(n, u);
  }
  function P$1(u, i, t) {
    var o, r, e;
    l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, e = [], j$2(i, u = (!o && t || i).__k = h$1(p$1, null, [u]), r || f$1, f$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, e, !o && t ? t : r ? r.__e : i.firstChild, o), z$2(e, u);
  }
  function B$2(n, l) {
    var u = {
      __c: l = "__cC" + r$2++,
      __: n,
      Consumer: function (n, l) {
        return n.children(l);
      },
      Provider: function (n) {
        var u, i;
        return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
          return i;
        }, this.shouldComponentUpdate = function (n) {
          this.props.value !== n.value && u.some(b$1);
        }, this.sub = function (n) {
          u.push(n);
          var l = n.componentWillUnmount;
          n.componentWillUnmount = function () {
            u.splice(u.indexOf(n), 1), l && l.call(n);
          };
        }), n.children;
      }
    };
    return u.Provider.__ = u.Consumer.contextType = u;
  }
  n = e$1.slice, l$1 = {
    __e: function (n, l, u, i) {
      for (var t, o, r; l = l.__;) {
        if ((t = l.__c) && !t.__) try {
          if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), r) return t.__E = t;
        } catch (l) {
          n = l;
        }
      }
      throw n;
    }
  }, u$1 = 0, d$1.prototype.setState = function (n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s$1({}, this.state), "function" == typeof n && (n = n(s$1({}, u), this.props)), n && s$1(u, n), null != n && this.__v && (l && this._sb.push(l), b$1(this));
  }, d$1.prototype.forceUpdate = function (n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), b$1(this));
  }, d$1.prototype.render = p$1, t$1 = [], g$2.__r = 0, r$2 = 0;
  var _$1 = 0;
  function o$1(o, e, n, t, f) {
    var l,
      s,
      u = {};
    for (s in e) {
      "ref" == s ? l = e[s] : u[s] = e[s];
    }
    var a = {
      type: o,
      props: u,
      key: n,
      ref: l,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      __h: null,
      constructor: void 0,
      __v: --_$1,
      __source: f,
      __self: t
    };
    if ("function" == typeof o && (l = o.defaultProps)) for (s in l) {
      void 0 === u[s] && (u[s] = l[s]);
    }
    return l$1.vnode && l$1.vnode(a), a;
  }
  var t,
    r$1,
    u,
    i,
    o = 0,
    f = [],
    c = [],
    e = l$1.__b,
    a = l$1.__r,
    v = l$1.diffed,
    l = l$1.__c,
    m = l$1.unmount;
  function d(t, u) {
    l$1.__h && l$1.__h(r$1, t, o || u), o = 0;
    var i = r$1.__H || (r$1.__H = {
      __: [],
      __h: []
    });
    return t >= i.__.length && i.__.push({
      __V: c
    }), i.__[t];
  }
  function p(n) {
    return o = 1, y(B$1, n);
  }
  function y(n, u, i) {
    var o = d(t++, 2);
    if (o.t = n, !o.__c && (o.__ = [i ? i(u) : B$1(void 0, u), function (n) {
      var t = o.__N ? o.__N[0] : o.__[0],
        r = o.t(t, n);
      t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
    }], o.__c = r$1, !r$1.u)) {
      r$1.u = !0;
      var f = r$1.shouldComponentUpdate;
      r$1.shouldComponentUpdate = function (n, t, r) {
        if (!o.__c.__H) return !0;
        var u = o.__c.__H.__.filter(function (n) {
          return n.__c;
        });
        if (u.every(function (n) {
          return !n.__N;
        })) return !f || f.call(this, n, t, r);
        var i = !1;
        return u.forEach(function (n) {
          if (n.__N) {
            var t = n.__[0];
            n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
          }
        }), !(!i && o.__c.props === n) && (!f || f.call(this, n, t, r));
      };
    }
    return o.__N || o.__;
  }
  function h(u, i) {
    var o = d(t++, 3);
    !l$1.__s && z$1(o.__H, i) && (o.__ = u, o.i = i, r$1.__H.__h.push(o));
  }
  function s(u, i) {
    var o = d(t++, 4);
    !l$1.__s && z$1(o.__H, i) && (o.__ = u, o.i = i, r$1.__h.push(o));
  }
  function _(n) {
    return o = 5, F$1(function () {
      return {
        current: n
      };
    }, []);
  }
  function A(n, t, r) {
    o = 6, s(function () {
      return "function" == typeof n ? (n(t()), function () {
        return n(null);
      }) : n ? (n.current = t(), function () {
        return n.current = null;
      }) : void 0;
    }, null == r ? r : r.concat(n));
  }
  function F$1(n, r) {
    var u = d(t++, 7);
    return z$1(u.__H, r) ? (u.__V = n(), u.i = r, u.__h = n, u.__V) : u.__;
  }
  function T$1(n, t) {
    return o = 8, F$1(function () {
      return n;
    }, t);
  }
  function q(n) {
    var u = r$1.context[n.__c],
      i = d(t++, 9);
    return i.c = n, u ? (null == i.__ && (i.__ = !0, u.sub(r$1)), u.props.value) : n.__;
  }
  function V$1() {
    var n = d(t++, 11);
    if (!n.__) {
      for (var u = r$1.__v; null !== u && !u.__m && null !== u.__;) {
        u = u.__;
      }
      var i = u.__m || (u.__m = [0, 0]);
      n.__ = "P" + i[0] + "-" + i[1]++;
    }
    return n.__;
  }
  function b() {
    for (var t; t = f.shift();) {
      if (t.__P && t.__H) try {
        t.__H.__h.forEach(k$1), t.__H.__h.forEach(w$1), t.__H.__h = [];
      } catch (r) {
        t.__H.__h = [], l$1.__e(r, t.__v);
      }
    }
  }
  l$1.__b = function (n) {
    r$1 = null, e && e(n);
  }, l$1.__r = function (n) {
    a && a(n), t = 0;
    var i = (r$1 = n.__c).__H;
    i && (u === r$1 ? (i.__h = [], r$1.__h = [], i.__.forEach(function (n) {
      n.__N && (n.__ = n.__N), n.__V = c, n.__N = n.i = void 0;
    })) : (i.__h.forEach(k$1), i.__h.forEach(w$1), i.__h = [])), u = r$1;
  }, l$1.diffed = function (t) {
    v && v(t);
    var o = t.__c;
    o && o.__H && (o.__H.__h.length && (1 !== f.push(o) && i === l$1.requestAnimationFrame || ((i = l$1.requestAnimationFrame) || j$1)(b)), o.__H.__.forEach(function (n) {
      n.i && (n.__H = n.i), n.__V !== c && (n.__ = n.__V), n.i = void 0, n.__V = c;
    })), u = r$1 = null;
  }, l$1.__c = function (t, r) {
    r.some(function (t) {
      try {
        t.__h.forEach(k$1), t.__h = t.__h.filter(function (n) {
          return !n.__ || w$1(n);
        });
      } catch (u) {
        r.some(function (n) {
          n.__h && (n.__h = []);
        }), r = [], l$1.__e(u, t.__v);
      }
    }), l && l(t, r);
  }, l$1.unmount = function (t) {
    m && m(t);
    var r,
      u = t.__c;
    u && u.__H && (u.__H.__.forEach(function (n) {
      try {
        k$1(n);
      } catch (n) {
        r = n;
      }
    }), u.__H = void 0, r && l$1.__e(r, u.__v));
  };
  var g$1 = "function" == typeof requestAnimationFrame;
  function j$1(n) {
    var t,
      r = function () {
        clearTimeout(u), g$1 && cancelAnimationFrame(t), setTimeout(n);
      },
      u = setTimeout(r, 100);
    g$1 && (t = requestAnimationFrame(r));
  }
  function k$1(n) {
    var t = r$1,
      u = n.__c;
    "function" == typeof u && (n.__c = void 0, u()), r$1 = t;
  }
  function w$1(n) {
    var t = r$1;
    n.__c = n.__(), r$1 = t;
  }
  function z$1(n, t) {
    return !n || n.length !== t.length || t.some(function (t, r) {
      return t !== n[r];
    });
  }
  function B$1(n, t) {
    return "function" == typeof t ? t(n) : t;
  }
  function g(n, t) {
    for (var e in t) {
      n[e] = t[e];
    }
    return n;
  }
  function C(n, t) {
    for (var e in n) {
      if ("__source" !== e && !(e in t)) return !0;
    }
    for (var r in t) {
      if ("__source" !== r && n[r] !== t[r]) return !0;
    }
    return !1;
  }
  function w(n) {
    this.props = n;
  }
  function R(n, e) {
    function r(n) {
      var t = this.props.ref,
        r = t == n.ref;
      return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : C(this.props, n);
    }
    function u(e) {
      return this.shouldComponentUpdate = r, h$1(n, e);
    }
    return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = !0, u.__f = !0, u;
  }
  (w.prototype = new d$1()).isPureReactComponent = !0, w.prototype.shouldComponentUpdate = function (n, t) {
    return C(this.props, n) || C(this.state, t);
  };
  var x = l$1.__b;
  l$1.__b = function (n) {
    n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), x && x(n);
  };
  var N = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
  function k(n) {
    function t(t) {
      var e = g({}, t);
      return delete e.ref, n(e, t.ref || null);
    }
    return t.$$typeof = N, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
  }
  var T = l$1.__e;
  l$1.__e = function (n, t, e, r) {
    if (n.then) for (var u, o = t; o = o.__;) {
      if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
    }
    T(n, t, e, r);
  };
  var I = l$1.unmount;
  function L(n, t, e) {
    return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
      "function" == typeof n.__c && n.__c();
    }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
      return L(n, t, e);
    })), n;
  }
  function U(n, t, e) {
    return n && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
      return U(n, t, e);
    }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
  }
  function D() {
    this.__u = 0, this.t = null, this.__b = null;
  }
  function F(n) {
    var t = n.__.__c;
    return t && t.__a && t.__a(n);
  }
  function V() {
    this.u = null, this.o = null;
  }
  l$1.unmount = function (n) {
    var t = n.__c;
    t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), I && I(n);
  }, (D.prototype = new d$1()).__c = function (n, t) {
    var e = t.__c,
      r = this;
    null == r.t && (r.t = []), r.t.push(e);
    var u = F(r.__v),
      o = !1,
      i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };
    e.__R = i;
    var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;
            r.__v.__k[0] = U(n, n.__c.__P, n.__c.__O);
          }
          var t;
          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) {
            t.forceUpdate();
          }
        }
      },
      c = !0 === t.__h;
    r.__u++ || c || r.setState({
      __a: r.__b = r.__v.__k[0]
    }), n.then(i, i);
  }, D.prototype.componentWillUnmount = function () {
    this.t = [];
  }, D.prototype.render = function (n, e) {
    if (this.__b) {
      if (this.__v.__k) {
        var r = document.createElement("div"),
          o = this.__v.__k[0].__c;
        this.__v.__k[0] = L(this.__b, r, o.__O = o.__P);
      }
      this.__b = null;
    }
    var i = e.__a && h$1(p$1, null, n.fallback);
    return i && (i.__h = null), [h$1(p$1, null, e.__a ? null : n.children), i];
  };
  var W = function (n, t, e) {
    if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
      for (; e.length > 3;) {
        e.pop()();
      }
      if (e[1] < e[0]) break;
      n.u = e = e[2];
    }
  };
  function P(n) {
    return this.getChildContext = function () {
      return n.context;
    }, n.children;
  }
  function $(n) {
    var e = this,
      r = n.i;
    e.componentWillUnmount = function () {
      P$1(null, e.l), e.l = null, e.i = null;
    }, e.i && e.i !== r && e.componentWillUnmount(), n.__v ? (e.l || (e.i = r, e.l = {
      nodeType: 1,
      parentNode: r,
      childNodes: [],
      appendChild: function (n) {
        this.childNodes.push(n), e.i.appendChild(n);
      },
      insertBefore: function (n, t) {
        this.childNodes.push(n), e.i.appendChild(n);
      },
      removeChild: function (n) {
        this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), e.i.removeChild(n);
      }
    }), P$1(h$1(P, {
      context: e.context
    }, n.__v), e.l)) : e.l && e.componentWillUnmount();
  }
  function j(n, e) {
    var r = h$1($, {
      __v: n,
      i: e
    });
    return r.containerInfo = e, r;
  }
  (V.prototype = new d$1()).__a = function (n) {
    var t = this,
      e = F(t.__v),
      r = t.o.get(n);
    return r[0]++, function (u) {
      var o = function () {
        t.props.revealOrder ? (r.push(u), W(t, n, r)) : u();
      };
      e ? e(o) : o();
    };
  }, V.prototype.render = function (n) {
    this.u = null, this.o = new Map();
    var t = x$1(n.children);
    n.revealOrder && "b" === n.revealOrder[0] && t.reverse();
    for (var e = t.length; e--;) {
      this.o.set(t[e], this.u = [1, 0, this.u]);
    }
    return n.children;
  }, V.prototype.componentDidUpdate = V.prototype.componentDidMount = function () {
    var n = this;
    this.o.forEach(function (t, e) {
      W(n, e, t);
    });
  };
  var z = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
    B = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
    H = "undefined" != typeof document,
    Z = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };
  d$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
    Object.defineProperty(d$1.prototype, t, {
      configurable: !0,
      get: function () {
        return this["UNSAFE_" + t];
      },
      set: function (n) {
        Object.defineProperty(this, t, {
          configurable: !0,
          writable: !0,
          value: n
        });
      }
    });
  });
  var G = l$1.event;
  function J() {}
  function K() {
    return this.cancelBubble;
  }
  function Q() {
    return this.defaultPrevented;
  }
  l$1.event = function (n) {
    return G && (n = G(n)), n.persist = J, n.isPropagationStopped = K, n.isDefaultPrevented = Q, n.nativeEvent = n;
  };
  var nn = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
    tn = l$1.vnode;
  l$1.vnode = function (n) {
    var t = n.type,
      e = n.props,
      u = e;
    if ("string" == typeof t) {
      var o = -1 === t.indexOf("-");
      for (var i in u = {}, e) {
        var l = e[i];
        H && "children" === i && "noscript" === t || "value" === i && "defaultValue" in e && null == l || ("defaultValue" === i && "value" in e && null == e.value ? i = "value" : "download" === i && !0 === l ? l = "" : /ondoubleclick/i.test(i) ? i = "ondblclick" : /^onchange(textarea|input)/i.test(i + t) && !Z(e.type) ? i = "oninput" : /^onfocus$/i.test(i) ? i = "onfocusin" : /^onblur$/i.test(i) ? i = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && B.test(i) ? i = i.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = "oninputCapture")), u[i] = l);
      }
      "select" == t && u.multiple && Array.isArray(u.value) && (u.value = x$1(e.children).forEach(function (n) {
        n.props.selected = -1 != u.value.indexOf(n.props.value);
      })), "select" == t && null != u.defaultValue && (u.value = x$1(e.children).forEach(function (n) {
        n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
      })), n.props = u, e.class != e.className && (nn.enumerable = "className" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, "className", nn));
    }
    n.$$typeof = z, tn && tn(n);
  };
  var en = l$1.__r;
  l$1.__r = function (n) {
    en && en(n), n.__c;
  };
  var EventDetail = Symbol("event-detail");
  function enhanceEvent(e, detail) {
    var event = e;
    event[EventDetail] = detail;
    return event;
  }
  var alreadyWarned = new Set();
  function overwriteWithWarning(componentName, props, propName, newValue) {
    //const key = `${componentName};${propName}`;
    var oldValue = props[propName];
    if (oldValue != null) {
      if (!alreadyWarned.has(String(propName))) {
        alreadyWarned.add(String(propName));
        console.warn("The ".concat(String(propName), " attribute on ").concat(componentName, " was given a value of ").concat(oldValue, " but is being overwritten to ").concat(newValue, " for conformance. Consider removing it before passing those props to ").concat(componentName, "."));
      }
    }
    props[propName] = newValue;
  }
  function debugLog(who) {}
  // (These do not need to be unique)
  var Prefices = {
    accordionSectionHeaderButton: "ashb-",
    accordionSectionBody: "asb-",
    checkboxLikeInput: "cbli-",
    checkboxLikeLabel: "cbll-",
    dialog: "mdl-",
    dialogTitle: "mdlt-",
    drawer: "mdw-",
    drawerTitle: "mdwt-",
    gridlist: "gl-",
    gridlistLabel: "gll-",
    listbox: "lb-",
    listboxLabel: "lbl-",
    menu: "menu-",
    progressIndicator: "pi-",
    progressLabel: "pl-",
    radioGroup: "rg-",
    radioGroupLabel: "rgl-",
    radio: "rb-",
    radioLabel: "rbl-",
    sliderThumb: "st-",
    table: "tb-",
    tableLabel: "tbl-",
    tablist: "tl-",
    tablistLabel: "tll-",
    tooltip: "tt-"
  };
  var HeadingLevelContext = B$2(0);
  var Heading = R(function Heading(_ref2) {
    var {
        children,
        heading,
        tag
      } = _ref2,
      props = _objectWithoutProperties(_ref2, _excluded);
    var headingLevelBeforeUs = q(HeadingLevelContext);
    var newHeadingLevel = headingLevelBeforeUs + 1;
    if (tag == null) {
      if (newHeadingLevel <= 6) {
        tag = "h".concat(newHeadingLevel);
      } else {
        tag = 'div';
        overwriteWithWarning("Heading", props, "aria-level", "".concat(newHeadingLevel));
      }
    }
    return o$1(p$1, {
      children: o$1(HeadingReset, {
        newLevel: headingLevelBeforeUs + 1,
        children: [h$1(tag, props, heading), children]
      })
    });
  });
  var HeadingReset = R(function HeadingReset(_ref3) {
    var {
      newLevel,
      children
    } = _ref3;
    return o$1(HeadingLevelContext.Provider, {
      value: newLevel,
      children: children
    });
  });

  /**
   * Debug hook.
   *
   * Given a value or set of values, emits a console error if any of them change from one render to the next.
   *
   * Eventually, when useEvent lands, we hopefully won't need this.
   */
  function useEnsureStability(parentHookName) {
    for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }
    var helperToEnsureStability = _([]);
    var shownError = _([]);
    useHelper(values.length, -1);
    values.forEach(useHelper);
    return;
    function useHelper(value, i) {
      var index = i + 1;
      // Make sure that the provided functions are perfectly stable across renders
      if (helperToEnsureStability.current[index] === undefined) helperToEnsureStability.current[index] = value;
      if (helperToEnsureStability.current[index] != value) {
        if (!shownError.current[index]) {
          /* eslint-disable no-debugger */
          debugger;
          console.error("The hook ".concat(parentHookName, " requires some or all of its arguments remain stable across each render; please check the ").concat(i, "-indexed argument (").concat(i >= 0 ? JSON.stringify(values[i]) : "the number of supposedly stable elements", ")."));
          shownError.current[index] = true;
        }
      }
    }
  }
  function debounceRendering(f) {
    var _l$1$debounceRenderin;
    ((_l$1$debounceRenderin = l$1.debounceRendering) !== null && _l$1$debounceRenderin !== void 0 ? _l$1$debounceRenderin : setTimeout)(f);
  }
  /**
   * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
   *
   * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
   *
   * To summarize, it's like a `useState`-`useEffect` mashup:
   *
   * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
   * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
   * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
   * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
   *
   * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
   *
   * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
   * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
   * @returns
   */
  function usePassiveState(onChange, getInitialValue, customDebounceRendering) {
    var valueRef = _(Unset$1);
    var reasonRef = _(Unset$1);
    var warningRef = _(false);
    var dependencyToCompareAgainst = _(Unset$1);
    var cleanupCallbackRef = _(undefined);
    // Make sure that the provided functions are perfectly stable across renders
    useEnsureStability("usePassiveState", onChange, getInitialValue, customDebounceRendering);
    // Shared between "dependency changed" and "component unmounted".
    var onShouldCleanUp = T$1(() => {
      var cleanupCallback = cleanupCallbackRef.current;
      if (cleanupCallback) cleanupCallback();
    }, []);
    // There are a couple places where we'd like to use our initial
    // value in place of having no value at all yet.
    // This is the shared code for that, used on mount and whenever
    // getValue is called.
    var tryEnsureValue = T$1(() => {
      if (valueRef.current === Unset$1 && getInitialValue != undefined) {
        try {
          var _onChange;
          var initialValue = getInitialValue();
          valueRef.current = initialValue;
          cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
        } catch (ex) {
          // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
        }
      }
    }, [/* getInitialValue and onChange intentionally omitted */]);
    var getValue = T$1(() => {
      if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
      // The first time we call getValue, if we haven't been given a value yet,
      // (and we were given an initial value to use)
      // return the initial value instead of nothing.
      if (valueRef.current === Unset$1) tryEnsureValue();
      return valueRef.current === Unset$1 ? undefined : valueRef.current;
    }, []);
    s(() => {
      // Make sure we've run our effect at least once on mount.
      // (If we have an initial value, of course)
      tryEnsureValue();
    }, []);
    // The actual code the user calls to (possibly) run a new effect.
    var setValue = T$1((arg, reason) => {
      // Regardless of anything else, figure out what our next value is about to be.
      var nextValue = arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg;
      if (dependencyToCompareAgainst.current === Unset$1 && nextValue !== valueRef.current) {
        // This is the first request to change this value.
        // Evaluate the request immediately, then queue up the onChange function
        // Save our current value so that we can compare against it later
        // (if we flip back to this state, then we won't send the onChange function)
        dependencyToCompareAgainst.current = valueRef.current;
        // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
        valueRef.current = nextValue;
        reasonRef.current = reason;
        // Schedule the actual check and invocation of onChange later to let effects settle
        (customDebounceRendering !== null && customDebounceRendering !== void 0 ? customDebounceRendering : debounceRendering)(() => {
          var nextReason = reasonRef.current;
          var nextDep = valueRef.current;
          var prevDep = dependencyToCompareAgainst.current;
          if (dependencyToCompareAgainst.current != valueRef.current) {
            warningRef.current = true;
            try {
              var _onChange2;
              // Call any registered cleanup function
              onShouldCleanUp();
              cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$1 ? undefined : prevDep, nextReason)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
              valueRef.current = nextDep;
            } finally {
              // Allow the user to normally call getValue again
              warningRef.current = false;
            }
          }
          // We've finished with everything, so mark us as being on a clean slate again.
          dependencyToCompareAgainst.current = Unset$1;
        });
      }
      // Update the value immediately.
      // This will be checked against prevDep to see if we should actually call onChange
      valueRef.current = nextValue;
    }, []);
    return [getValue, setValue];
  }
  var Unset$1 = Symbol();
  // Easy constants for getInitialValue
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function returnNull() {
    return null;
  }
  function returnZero() {
    return 0;
  }
  function identity$1(t) {
    return t;
  } // Kind of an extra, but it's useful in other places anyway
  /**
   * An alternative to use for `customDebounceRendering` that causes `usePassiveState` to run changes without waiting a tick.
   */
  function runImmediately(f) {
    f();
  }

  /*
  const activeElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node | null) => void)>>();
  const lastActiveElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node) => void)>>();
  const windowFocusedUpdaters = new Map<Window | null | undefined, Set<undefined | ((focused: boolean) => void)>>();
  const windowsFocusedUpdaters = new Map<Window | null | undefined, boolean>();*/
  var activeElementUpdaters = new Map();
  var lastActiveElementUpdaters = new Map();
  var windowFocusedUpdaters = new Map();
  var windowsFocusedUpdaters = new Map();
  //const microtasks = new Map<Set<any>, any>();
  // The focusin and focusout events often fire syncronously in the middle of running code.
  // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
  // For the purpose of improving stability, we debounce all focus events to the next microtask.
  function forEachUpdater(window, map, value, reason) {
    var updaters = map.get(window);
    if (updaters) {
      //if (!microtasks.has(updatersKey)) {
      //debounceRendering(() => {
      //const updatersKey = map.get(window)!;
      //const value = microtasks.get(updatersKey);
      //microtasks.delete(updatersKey);
      if (updaters) {
        for (var updater of updaters) {
          var {
            lastSent,
            send
          } = updater;
          if (value !== lastSent) {
            send(value, reason);
            updater.lastSent = value;
          }
        }
      }
      //});
      //}
      //microtasks.set(updatersKey, value);
    }
  }

  function focusout(e) {
    var window = e.target.ownerDocument.defaultView;
    if (e.relatedTarget == null) {
      forEachUpdater(window, activeElementUpdaters, null, e);
    }
  }
  function focusin(e) {
    var window = e.target.ownerDocument.defaultView;
    var currentlyFocusedElement = e.target;
    forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement, e);
    forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement, e);
  }
  function windowFocus(e) {
    var window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
    windowsFocusedUpdaters.set(window, true);
    forEachUpdater(window, windowFocusedUpdaters, true, e);
  }
  function windowBlur(e) {
    var window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
    windowsFocusedUpdaters.set(window, false);
    forEachUpdater(window, windowFocusedUpdaters, false, e);
  }
  /**
   * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
   * * `getActiveElement()`
   * * `getLastActiveElement()`
   * * `getWindowFocused()`
   *
   * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
   *
   * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
   *
   * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
   */
  function useActiveElement(_ref4) {
    var {
      activeElementParameters: {
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        getDocument,
        getWindow
      }
    } = _ref4;
    useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, getDocument, getWindow);
    h(() => {
      var _getWindow, _activeElementUpdater, _activeElementUpdater2, _activeElementUpdater3, _lastActiveElementUpd, _windowFocusedUpdater;
      var document = getDocument();
      var window = (_getWindow = getWindow === null || getWindow === void 0 ? void 0 : getWindow(document)) !== null && _getWindow !== void 0 ? _getWindow : document === null || document === void 0 ? void 0 : document.defaultView;
      if (((_activeElementUpdater = (_activeElementUpdater2 = activeElementUpdaters.get(window)) === null || _activeElementUpdater2 === void 0 ? void 0 : _activeElementUpdater2.size) !== null && _activeElementUpdater !== void 0 ? _activeElementUpdater : 0) === 0) {
        document === null || document === void 0 ? void 0 : document.addEventListener("focusin", focusin, {
          passive: true
        });
        document === null || document === void 0 ? void 0 : document.addEventListener("focusout", focusout, {
          passive: true
        });
        window === null || window === void 0 ? void 0 : window.addEventListener("focus", windowFocus, {
          passive: true
        });
        window === null || window === void 0 ? void 0 : window.addEventListener("blur", windowBlur, {
          passive: true
        });
      }
      // Add them even if they're undefined to more easily
      // manage the ">0 means don't add handlers" logic.
      var localActiveElementUpdaters = (_activeElementUpdater3 = activeElementUpdaters.get(window)) !== null && _activeElementUpdater3 !== void 0 ? _activeElementUpdater3 : new Set();
      var localLastActiveElementUpdaters = (_lastActiveElementUpd = lastActiveElementUpdaters.get(window)) !== null && _lastActiveElementUpd !== void 0 ? _lastActiveElementUpd : new Set();
      var localWindowFocusedUpdaters = (_windowFocusedUpdater = windowFocusedUpdaters.get(window)) !== null && _windowFocusedUpdater !== void 0 ? _windowFocusedUpdater : new Set();
      var laeu = {
        send: setActiveElement,
        lastSent: undefined
      };
      var llaeu = {
        send: setLastActiveElement,
        lastSent: undefined
      };
      var lwfu = {
        send: setWindowFocused,
        lastSent: undefined
      };
      localActiveElementUpdaters.add(laeu);
      localLastActiveElementUpdaters.add(llaeu);
      localWindowFocusedUpdaters.add(lwfu);
      activeElementUpdaters.set(window, localActiveElementUpdaters);
      lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
      windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
      return () => {
        activeElementUpdaters.get(window).delete(laeu);
        lastActiveElementUpdaters.get(window).delete(laeu);
        windowFocusedUpdaters.get(window).delete(lwfu);
        if (activeElementUpdaters.size === 0) {
          document === null || document === void 0 ? void 0 : document.removeEventListener("focusin", focusin);
          document === null || document === void 0 ? void 0 : document.removeEventListener("focusout", focusout);
          window === null || window === void 0 ? void 0 : window.removeEventListener("focus", windowFocus);
          window === null || window === void 0 ? void 0 : window.removeEventListener("blur", windowBlur);
        }
      };
    }, []);
    var [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
    var [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
    var [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
    return {
      activeElementReturn: {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      }
    };
  }
  var Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
  function base64(value) {
    return Table[value];
  }
  function random6Bits() {
    return Math.floor(Math.random() * 0b1000000);
  }
  function random64Bits() {
    return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
  }
  /**
   * Returns a randomly-generated ID with an optional prefix.
   * Note that if the prefix is *explicitly* set to "", then
   * IDs that are not valid under HTML4 may be generated. Oh no.
   *
   *
   * (This is here, in this particular file, to avoid circular dependencies
   * without also making a utilities file.
   * Once we can remove this hook, we can put this function back with useRandomId)
   */
  function generateRandomId(prefix) {
    return "".concat(prefix !== null && prefix !== void 0 ? prefix : "id-").concat(random64Bits().map(n => base64(n)).join(""));
  }
  var previousInputs = new Map();
  var toRun = new Map();
  // TODO: Whether this goes in options.diffed or options._commit
  // is a post-suspense question.
  // Right now, using options._commit has the problem of running
  // *after* refs are applied, but we need to come before even that
  // so `ref={someStableFunction}` works.
  // 
  // Also it's private.
  //
  // ...
  // Well, useEvent or whatever is finally, finally 4 years later finally here
  // which is cool and means we won't need this at all soon.
  // So for now we'll stick with diff to prevent any weirdness with
  // commit being private and all.
  var commitName = "diffed";
  var originalCommit = l$1[commitName];
  var newCommit = function () {
    for (var [id, effectInfo] of toRun) {
      var oldInputs = previousInputs.get(id);
      if (argsChanged(oldInputs, effectInfo.inputs)) {
        var _effectInfo$cleanup;
        (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
        effectInfo.cleanup = effectInfo.effect();
        previousInputs.set(id, effectInfo.inputs);
      }
    }
    toRun.clear();
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
  };
  l$1[commitName] = newCommit;
  /**
   * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
   *
   * Every render, we send the arguments to be evaluated after diffing has completed,
   * which happens before.
   *
   * @param effect
   * @param inputs
   */
  function useBeforeLayoutEffect(effect, inputs) {
    /*(() => {
        const cleanup = useRef<void | (() => void) | null>(null);
        const prevArgsRef = useRef<Inputs>(null!);
        if (argsChanged(inputs, prevArgsRef.current)) {
            prevArgsRef.current = inputs!;
            if (cleanup.current)
                cleanup.current();
            cleanup.current = effect();
        }
    })();*/
    var [id] = p(() => generateRandomId());
    if (effect) toRun.set(id, {
      effect,
      inputs,
      cleanup: null
    });else toRun.delete(id);
    h(() => {
      return () => {
        toRun.delete(id);
        previousInputs.delete(id);
      };
    }, [id]);
  }
  function argsChanged(oldArgs, newArgs) {
    return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
  }
  var Unset = Symbol("unset");
  /**
   * Given an input value, returns a constant getter function that can be used
   * inside of `useEffect` and friends without including it in the dependency array.
   *
   * This uses `options.diffed` in order to run before everything, even
   * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
   *
   * @param value
   * @returns
   */
  function useStableGetter(value) {
    var ref = _(Unset);
    useBeforeLayoutEffect(() => {
      ref.current = value;
    }, [value]);
    return T$1(() => {
      if (ref.current === Unset) {
        throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
      }
      return ref.current;
    }, []);
  }
  /**
   * Like `useStableGetter`, but ***requires*** that everything in the object is also stable,
   * and in turn returns an object that itself is stable.
   * @param t
   * @returns
   */
  function useStableObject(t) {
    var e = Object.entries(t);
    useEnsureStability("useStableObject", e.length, ...e.map(_ref5 => {
      var [_k, v] = _ref5;
      return v;
    }));
    return _(t).current;
  }

  /**
   * We keep track of which callbacks are stable with a WeakMap instead of, say, a symbol because
   * `useCallback` will return a function that's stable across *all* renders, meaning
   * we can't use our funny "`if` only works here because it doesn't break the rules of hooks" trick then.
   */
  var map = new WeakMap();
  function isStableGetter(obj) {
    var _map$get;
    return (_map$get = map.get(obj)) !== null && _map$get !== void 0 ? _map$get : false;
  }
  function setIsStableGetter(obj) {
    map.set(obj, true);
    return obj;
  }
  /**
   * Alternate useCallback() which always returns the same (wrapped) function reference
   * so that it can be excluded from the dependency arrays of `useEffect` and friends.
   *
   * In general, just pass the function you want to be stable (but you can't use it during render,
   * so be careful!).  Alternatively, if you need a stable callback that **can** be used
   * during render, pass an empty dependency array and it'll act like `useCallback` with an
   * empty dependency array, but with the associated stable typing. In this case, you ***must*** ensure that it
   * truly has no dependencies/only stable dependencies!!
   */
  //export function useStableCallback<T extends (..._args: any[]) => any>(fn: T, noDeps: []): Stable<T>;
  //export function useStableCallback<T extends (..._args: any[]) => any>(fn: T): Stable<T>;
  function useStableCallback(fn, noDeps) {
    useEnsureStability("useStableCallback", noDeps == null, noDeps === null || noDeps === void 0 ? void 0 : noDeps.length, isStableGetter(fn));
    if (isStableGetter(fn)) return fn;
    if (noDeps == null) {
      var currentCallbackGetter = useStableGetter(fn);
      return setIsStableGetter(T$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []));
    } else {
      console.assert(noDeps.length === 0);
      return setIsStableGetter(T$1(fn, []));
    }
  }

  /**
   * Allows a parent component to access information about certain
   * child components once they have rendered.
   *
   * This hook is designed to be lightweight, in that the parent keeps no state
   * and runs no effects.  Each child *does* run an effect, but with no state
   * changes unless you explicitly request them.
   *
   *
   */
  function useManagedChildren(parentParameters) {
    var {
        managedChildrenParameters: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters,
      rest = _objectWithoutProperties(parentParameters, _excluded2);
    useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
    var getHighestIndex = T$1(() => {
      return managedChildrenArray.current.highestIndex;
    }, []);
    // All the information we have about our children is stored in this **stable** array.
    // Any mutations to this array **DO NOT** trigger any sort of a re-render.
    var managedChildrenArray = _({
      arr: [],
      rec: {},
      highestIndex: 0,
      lowestIndex: 0
    });
    // For indirect access to each child
    // Compare getManagedChildInfo
    // TODO: The primary use for this is flaggable closest fits
    // which needs to search all children for that closest fit.
    // It would be nice if there was something better for that.
    var forEachChild = T$1(f => {
      for (var child of managedChildrenArray.current.arr) {
        if (child) f(child);
      }
      for (var field in managedChildrenArray.current.rec) {
        var _child = managedChildrenArray.current.rec[field];
        if (_child) f(_child);
      }
    }, []);
    // Retrieves the information associated with the child with the given index.
    // `undefined` if not child there, or it's unmounted.
    var getManagedChildInfo = T$1(index => {
      if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
    }, []);
    // tl;dr this is a way to have run useLayoutEffect once after all N children
    // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
    // ourselves because of having a `childCount` state or anything similar.
    //
    // When the child count ref updates, we want the parent to also run an effect
    // to maybe do something with all these children that just mounted.
    // The easiest way would be useEffect(..., [childCount]) but
    // that would require us having a childCount state, then calling
    // setChildCount and re-rendering every time children mount
    // (only one re-render at a time unless children are staggered, but still)
    // 
    // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
    // to emulate running ULE on the parent. Only the first child will actually queue
    // the microtask (by checking hasRemoteULE first) so that the "effect" only
    // runs once. When it's done, hasRemoteULE is reset so it can run again if
    // more children mount/unmount.
    var hasRemoteULEChildMounted = _(null);
    var remoteULEChildChangedCausers = _(new Set());
    var remoteULEChildChanged = T$1(index => {
      if (remoteULEChildChangedCausers.current.size == 0) {
        debounceRendering(() => {
          onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
          remoteULEChildChangedCausers.current.clear();
        });
      }
      remoteULEChildChangedCausers.current.add(index);
      return () => {};
    }, [/* Must remain stable */]);
    var remoteULEChildMounted = T$1((index, mounted) => {
      if (!hasRemoteULEChildMounted.current) {
        hasRemoteULEChildMounted.current = {
          mounts: new Set(),
          unmounts: new Set()
        };
        debounceRendering(() => {
          onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
          hasRemoteULEChildMounted.current = null;
        });
      }
      if (mounted) {
        if (typeof index == "number") managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
      } else {
        if (typeof index == "number") {
          delete managedChildrenArray.current.arr[index];
          var shave = 0;
          while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
            ++shave;
          }
          managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
        } else delete managedChildrenArray.current.rec[index];
        if (typeof index == "number") managedChildrenArray.current.highestIndex = managedChildrenArray.current.arr.length - 1;
      }
      hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
    }, [/* Must remain stable */]);
    var managedChildren = useStableObject(_objectSpread(_objectSpread({}, {
      _: managedChildrenArray.current
    }), {}, {
      forEach: forEachChild,
      getAt: getManagedChildInfo,
      getHighestIndex: getHighestIndex,
      arraySlice: T$1(() => {
        return managedChildrenArray.current.arr.slice();
      }, [])
    }));
    var getChildren = T$1(() => managedChildren, []);
    return {
      context: useStableObject({
        managedChildContext: useStableObject({
          managedChildrenArray: managedChildrenArray.current,
          remoteULEChildMounted,
          remoteULEChildChanged,
          getChildren
        })
      }),
      managedChildrenReturn: {
        getChildren
      }
    };
  }
  function useManagedChild(info, managedChildParameters) {
    var {
      context: {
        managedChildContext: {
          getChildren,
          managedChildrenArray,
          remoteULEChildMounted,
          remoteULEChildChanged
        }
      }
    } = info;
    var index = managedChildParameters.index;
    // Any time our child props change, make that information available
    // the parent if they need it.
    // The parent can listen for all updates and only act on the ones it cares about,
    // and multiple children updating in the same tick will all be sent at once.
    s(() => {
      // Insert this information in-place
      if (typeof index == "number") {
        managedChildrenArray.arr[index] = _objectSpread({}, managedChildParameters);
      } else {
        managedChildrenArray.rec[index] = _objectSpread({}, managedChildParameters);
      }
      return remoteULEChildChanged(index);
    }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
    // When we mount, notify the parent via queueMicrotask
    // (every child does this, so everything's coordinated to only queue a single microtask per tick)
    // Do the same on unmount.
    // Note: It's important that this comes AFTER remoteULEChildChanged
    // so that remoteULEChildMounted has access to all the info on mount.
    s(() => {
      remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, true);
      return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(index, false);
    }, [index]);
    return {
      managedChildReturn: {
        getChildren
      }
    };
  }
  /**
   * An extension to useManagedChildren that handles the following common case:
   * 1. You have a bunch of children
   * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
   * 3. The parent has control over who is "selected" via a numerical index.
   *
   * This hook allows for much easier control over selection management.
   *
   * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
   * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
   *
   * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
   *
   *
   * @param param0
   * @returns
   */
  function useChildrenFlag(_ref6) {
    var {
      getChildren,
      initialIndex,
      closestFit,
      onIndexChange,
      getAt,
      setAt,
      isValid
    } = _ref6;
    useEnsureStability("useChildrenFlag", onIndexChange, getAt, setAt, isValid);
    // TODO (maybe?): Even if there is an initial index, it's not set until mount. Is that fine?
    var [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange);
    var [getRequestedIndex, setRequestedIndex] = usePassiveState(null);
    //    const getFitNullToZero = useStableGetter(fitNullToZero);
    // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)
    var getClosestFit = T$1(requestedIndex => {
      var children = getChildren();
      var closestDistance = Infinity;
      var closestIndex = null;
      children.forEach(child => {
        if (isValid(child)) {
          var newDistance = Math.abs(child.index - requestedIndex);
          if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
            closestDistance = newDistance;
            closestIndex = child.index;
          }
        }
      });
      return closestIndex;
    }, [/* Must remain stable! */]);
    // Any time a child mounts/unmounts, we need to double-check to see if that affects 
    // the "currently selected" (or whatever) index.  The two cases we're looking for:
    // 1. The currently selected child unmounted
    // 2. A child mounted, and it mounts with the index we're looking for
    var reevaluateClosestFit = useStableCallback(() => {
      var children = getChildren();
      var requestedIndex = getRequestedIndex();
      var currentIndex = getCurrentIndex();
      var currentChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !isValid(currentChild))) {
        if (currentChild) setAt(currentChild, false);
        var closestFitIndex = getClosestFit(requestedIndex);
        setCurrentIndex(closestFitIndex, undefined);
        if (closestFitIndex != null) {
          var closestFitChild = children.getAt(closestFitIndex);
          console.assert(closestFitChild != null, "Internal logic???");
          setAt(closestFitChild, true);
        }
      }
    });
    var changeIndex = T$1((arg, reason) => {
      var children = getChildren();
      var requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
      //if (requestedIndex == null && getFitNullToZero())
      //    requestedIndex = 0;
      setRequestedIndex(requestedIndex, reason);
      var currentIndex = getCurrentIndex();
      if (currentIndex == requestedIndex) return requestedIndex;
      var newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
      var oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);
      if (requestedIndex == null) {
        // Easy case
        setCurrentIndex(null, reason);
        if (oldMatchingChild) setAt(oldMatchingChild, false);
        return null;
      } else {
        if (newMatchingChild && isValid(newMatchingChild)) {
          setCurrentIndex(requestedIndex, reason);
          if (oldMatchingChild) setAt(oldMatchingChild, false);
          setAt(newMatchingChild, true);
          return requestedIndex;
        } else {
          var closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex, reason);
          if (closestFitIndex != null) {
            newMatchingChild = children.getAt(closestFitIndex);
            console.assert(newMatchingChild != null, "Internal logic???");
            if (oldMatchingChild) setAt(oldMatchingChild, false);
            setAt(newMatchingChild, true);
            return closestFitIndex;
          } else {
            if (oldMatchingChild) setAt(oldMatchingChild, false);
            return null;
          }
        }
      }
    }, []);
    // Run once, on mount
    s(() => {
      changeIndex(initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, undefined);
    }, []);
    return {
      changeIndex,
      reevaluateClosestFit,
      getCurrentIndex
    };
  }
  function useMergedChildren(lhs, rhs) {
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return h$1(p$1, {}, lhs, rhs);
    }
  }
  function r(e) {
    var t,
      f,
      n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) {
      e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for (t in e) {
      e[t] && (n && (n += " "), n += t);
    }
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = ""; f < arguments.length;) {
      (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
    }
    return n;
  }

  /**
   * Given two sets of props, merges their `class` and `className` properties.
   * Duplicate classes are removed (order doesn't matter anyway).
   *
   * @param lhs Classes of the first component
   * @param rhs Classes of the second component
   * @returns A string representing all combined classes from both arguments.
   */
  function useMergedClasses(lhsClass, lhsClassName, rhsClass, rhsClassName) {
    // Note: For the sake of forward compatibility, this function is labelled as
    // a hook, but as it uses no other hooks it technically isn't one.
    if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
      var lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
      var rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
      var allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
      return Array.from(allClasses).join(" ");
    } else {
      return undefined;
    }
  }
  function processRef(instance, ref) {
    if (typeof ref === "function") {
      ref(instance);
    } else if (ref != null) {
      ref.current = instance;
    } else {
      /* eslint-disable no-debugger */
      debugger;
      console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
    }
  }
  /**
   * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
   * @param lhs
   * @param rhs
   * @returns
   */
  function useMergedRefs(rhs, lhs) {
    var combined = T$1(current => {
      processRef(current, lhs);
      processRef(current, rhs);
    }, [lhs, rhs]);
    if (lhs == null && rhs == null) {
      return undefined;
    } else if (lhs == null) {
      return rhs;
    } else if (rhs == null) {
      return lhs;
    } else {
      return combined;
    }
  }
  function styleStringToObject(style) {
    // TODO: This sucks D:
    return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
  }
  /**
   * Merges two style objects, returning the result.
   *
   * @param style The user-given style prop for this component
   * @param obj The CSS properties you want added to the user-given style
   * @returns A CSS object containing the properties of both objects.
   */
  function useMergedStyles(lhs, rhs) {
    // Easy case, when there are no styles to merge return nothing.
    if (!lhs && !rhs) return undefined;
    if (typeof lhs != typeof rhs) {
      // Easy cases, when one is null and the other isn't.
      if (lhs && !rhs) return lhs;
      if (!lhs && rhs) return rhs;
      // They're both non-null but different types.
      // Convert the string type to an object bag type and run it again.
      if (lhs && rhs) {
        // (useMergedStyles isn't a true hook -- this isn't a violation)
        if (typeof lhs == "string") return useMergedStyles(styleStringToObject(lhs), rhs);
        if (typeof rhs == "string") return useMergedStyles(lhs, styleStringToObject(rhs));
      }
      // Logic???
      return undefined;
    }
    // They're both strings, just concatenate them.
    if (typeof lhs == "string") {
      return "".concat(lhs, ";").concat(rhs !== null && rhs !== void 0 ? rhs : "");
    }
    // They're both objects, just merge them.
    return _objectSpread(_objectSpread({}, lhs !== null && lhs !== void 0 ? lhs : {}), rhs !== null && rhs !== void 0 ? rhs : {});
  }
  var log = console.warn;
  /**
   * Given two sets of props, merges them and returns the result.
   *
   * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
   * @param lhs2
   * @param rhs2
   * @returns
   */
  function useMergedProps() {
    for (var _len3 = arguments.length, allProps = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      allProps[_key3] = arguments[_key3];
    }
    useEnsureStability("useMergedProps", allProps.length);
    var ret = {};
    for (var nextProps of allProps) {
      ret = useMergedProps2(ret, nextProps);
    }
    return ret;
  }
  var knowns = new Set(["children", "ref", "className", "class", "style"]);
  function mergeUnknown(key, lhsValue, rhsValue) {
    if (typeof lhsValue === "function" || typeof rhsValue === "function") {
      // They're both functions that can be merged (or one's a function and the other's null).
      // Not an *easy* case, but a well-defined one.
      var merged = mergeFunctions(lhsValue, rhsValue);
      return merged;
    } else {
      // Uh...we're here because one of them's null, right?
      if (lhsValue == null && rhsValue == null) {
        if (rhsValue === null && lhsValue === undefined) return rhsValue;else return lhsValue;
      }
      if (lhsValue == null) return rhsValue;else if (rhsValue == null) return lhsValue;else if (rhsValue == lhsValue) ;else {
        // Ugh.
        // No good strategies here, just log it if requested
        log === null || log === void 0 ? void 0 : log("The prop \"".concat(key, "\" cannot simultaneously be the values ").concat(lhsValue, " and ").concat(rhsValue, ". One must be chosen outside of useMergedProps."));
        return rhsValue;
      }
    }
  }
  /**
   * Helper function.
   *
   * This is one of the most commonly called functions in this and consumer libraries,
   * so it trades a bit of readability for speed (i.e. we don't decompose objects and just do regular property access, iterate with `for...in`, instead of `Object.entries`, etc.)
   */
  function useMergedProps2(lhsAll, rhsAll) {
    var ret = {
      ref: useMergedRefs(lhsAll.ref, rhsAll.ref),
      style: useMergedStyles(lhsAll.style, rhsAll.style),
      className: useMergedClasses(lhsAll["class"], lhsAll.className, rhsAll["class"], rhsAll.className),
      children: useMergedChildren(lhsAll.children, rhsAll.children)
    };
    if (ret.ref === undefined) delete ret.ref;
    if (ret.style === undefined) delete ret.style;
    if (ret.className === undefined) delete ret.className;
    if (ret["class"] === undefined) delete ret["class"];
    if (ret.children === undefined) delete ret.children;
    for (var lhsKeyU in lhsAll) {
      var lhsKey = lhsKeyU;
      if (knowns.has(lhsKey)) continue;
      ret[lhsKey] = lhsAll[lhsKey];
    }
    for (var rhsKeyU in rhsAll) {
      var rhsKey = rhsKeyU;
      if (knowns.has(rhsKey)) continue;
      ret[rhsKey] = mergeUnknown(rhsKey, ret[rhsKey], rhsAll[rhsKey]);
    }
    return ret;
  }
  function mergeFunctions(lhs, rhs) {
    if (!lhs) return rhs;
    if (!rhs) return lhs;
    return function () {
      var lv = lhs(...arguments);
      var rv = rhs(...arguments);
      if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
    };
  }
  /*
  function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {
       const id0: GenericGet<{}, "id", string> = "";
      const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
      const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
      const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
      const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
      //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
      const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };
       type M1 = GenericGet<P, "style", string>;
      type M2 = GenericGet<{}, "style", string>;
      const m1: M1 = "";
      const m2: M1 = undefined;
      /// @ts-expect-error    Because number isn't assignable to string
      const m3: M1 = 0;
       const m4: M2 = "";
      const m5: M2 = undefined;
      /// @ts-expect-error    Because number isn't assignable to string
      const m6: M2 = 0;
       const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
      const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
      const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
      const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
      const p5 = useMergedProps<HTMLInputElement>()(props, {});
      const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
      const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });
        p1.id?.concat("");
      p2.id?.concat("");
      /// @ts-expect-error    id can't be anything but undefined
      p3.id?.concat("");
      /// @ts-expect-error    id can't be anything but undefined
      p4.id?.concat("");
        p5.id?.concat("");
      p6.id?.concat("");
      p7.id?.concat("");
       /// @ts-expect-error    id must contain undefined
      p5.id.concat("");
      /// @ts-expect-error    id must contain undefined
      p6.id.concat("");
      /// @ts-expect-error    id must contain undefined
      p7.id.concat("");
        if (p5.allowFullScreen === undefined) {}
      else if (p5.allowFullScreen === false) {}
      else if (p5.allowFullScreen === true) {}
      else {
          acceptsNever(p5.allowFullScreen);
      }
        if (p6.allowFullScreen === undefined) {}
      else if (p6.allowFullScreen === false) {}
      else if (p6.allowFullScreen === true) {}
      else {
          acceptsNever(p6.allowFullScreen);
      }
        if (p7.allowFullScreen === undefined) {}
      else if (p7.allowFullScreen === false) {}
      else if (p7.allowFullScreen === true) {}
      else {
          acceptsNever(p7.allowFullScreen);
      }
        // Make sure it works recursively
      const r1a = useMergedProps<HTMLInputElement>()({}, p1);
      const r1b = useMergedProps<HTMLInputElement>()(props, p1);
      const r2a = useMergedProps<HTMLInputElement>()({}, p2);
      const r2b = useMergedProps<HTMLInputElement>()(props, p2);
      const r3a = useMergedProps<HTMLInputElement>()({}, p3);
      const r3b = useMergedProps<HTMLInputElement>()(props, p3);
      const r4a = useMergedProps<HTMLInputElement>()({}, p4);
      const r4b = useMergedProps<HTMLInputElement>()(props, p4);
      const r5a = useMergedProps<HTMLInputElement>()({}, p5);
      const r5b = useMergedProps<HTMLInputElement>()(props, p5);
      const r6a = useMergedProps<HTMLInputElement>()({}, p6);
      const r6b = useMergedProps<HTMLInputElement>()(props, p6);
      const r7a = useMergedProps<HTMLInputElement>()({}, p7);
      const r7b = useMergedProps<HTMLInputElement>()(props, p7);
        r1a.id?.concat("");
      r1b.id?.concat("");
      r2a.id?.concat("");
      r2b.id?.concat("");
      // @ts-expect-error    id can't be anything but undefined
      r3a.id?.concat("");
      r3b.id?.concat("");
      /// @ts-expect-error    id can't be anything but undefined
      r4a.id?.concat("");
      r4b.id?.concat("");
        r5a.id?.concat("");
      r5b.id?.concat("");
      r6a.id?.concat("");
      r6b.id?.concat("");
      r7a.id?.concat("");
      r7b.id?.concat("");
       /// @ts-expect-error    id must contain undefined
      r5a.id.concat("");
      /// @ts-expect-error    id must contain undefined
      r5b.id.concat("");
      /// @ts-expect-error    id must contain undefined
      r6a.id.concat("");
      /// @ts-expect-error    id must contain undefined
      r6b.id.concat("");
      /// @ts-expect-error    id must contain undefined
      r7a.id.concat("");
      /// @ts-expect-error    id must contain undefined
      r7b.id.concat("");
        if (r5a.allowFullScreen === undefined) {}
      else if (r5a.allowFullScreen === false) {}
      else if (r5a.allowFullScreen === true) {}
      else {
          acceptsNever(r5a.allowFullScreen);
      }
        if (r5b.allowFullScreen === undefined) {}
      else if (r5b.allowFullScreen === false) {}
      else if (r5b.allowFullScreen === true) {}
      else {
          acceptsNever(r5b.allowFullScreen);
      }
        if (r6a.allowFullScreen === undefined) {}
      else if (r6a.allowFullScreen === false) {}
      else if (r6a.allowFullScreen === true) {}
      else {
          acceptsNever(r6a.allowFullScreen);
      }
        if (r6b.allowFullScreen === undefined) {}
      else if (r6b.allowFullScreen === false) {}
      else if (r6b.allowFullScreen === true) {}
      else {
          acceptsNever(r6b.allowFullScreen);
      }
        if (r7a.allowFullScreen === undefined) {}
      else if (r7a.allowFullScreen === false) {}
      else if (r7a.allowFullScreen === true) {}
      else {
          acceptsNever(r7a.allowFullScreen);
      }
        if (r7b.allowFullScreen === undefined) {}
      else if (r7b.allowFullScreen === false) {}
      else if (r7b.allowFullScreen === true) {}
      else {
          acceptsNever(r7b.allowFullScreen);
      }
   }
  function acceptsNever(n: never) {}
  */

  /**
   * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
   *
   * Due to typing limitations, this function must be called like this:
   *
   * `useEventHandler(element, "input")<InputEvent>(e => {})`
   *
   * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
   *
   * There is a separate version that attaches event handlers to a set of props.
   * It takes different event string types (onEvent vs onevent).
   *
   * @param target A *non-Preact* node to attach the event to.
   * @returns
   * *
   */
  function useGlobalHandler(target, type, handler, options) {
    // Note to self: The typing doesn't improve even if this is split up into a sub-function.
    // No matter what, it seems impossible to get the handler's event object typed perfectly.
    // It seems like it's guaranteed to always be a union of all available tupes.
    // Again, no matter what combination of sub- or sub-sub-functions used.
    var stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
    if (handler == null) stableHandler = null;
    h(() => {
      if (stableHandler) {
        target.addEventListener(type, stableHandler, options);
        return () => target.removeEventListener(type, stableHandler, options);
      }
    }, [target, type, stableHandler]);
  }

  /*
  export function useRefElementProps<E extends Element>(r: UseRefElementReturnType<E>, ...otherProps: h.JSX.HTMLAttributes<E>[]): h.JSX.HTMLAttributes<E>[] {
      return [r.refElementReturn.propsStable, ...otherProps];
  }*/
  /**
   * Allows accessing the element a ref references as soon as it does so.
   * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
   * adding a RefCallback and merging it with any existing ref that existed on the props.
   *
   * Don't forget to provide the Element as the type argument!
   *
   * @returns The element, and the sub-hook that makes it retrievable.
   */
  function useRefElement(args) {
    var {
      refElementParameters: {
        onElementChange,
        onMount,
        onUnmount
      }
    } = args;
    useEnsureStability("useRefElement", onElementChange, onMount, onUnmount);
    // Called (indirectly) by the ref that the element receives.
    var handler = T$1((e, prevValue) => {
      var cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
      if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
      if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
      return cleanup;
    }, []);
    // Let us store the actual (reference to) the element we capture
    var [getElement, setElement] = usePassiveState(handler, returnNull, runImmediately);
    var propsStable = _({
      ref: setElement
    });
    // Return both the element and the hook that modifies 
    // the props and allows us to actually find the element
    return {
      refElementReturn: {
        getElement,
        propsStable: propsStable.current
      }
    };
  }
  var MagicWindowKey = "__preact-prop-helpers-escape-key-dismiss__";
  function getElementDepth(element) {
    var depth = 0;
    var parent = element.parentElement;
    while (parent) {
      depth += 1;
      parent = parent.parentElement;
    }
    return depth;
  }
  /**
   * Adds event handlers for a modal-like soft-dismiss interaction.
   *
   * That is, any clicks or taps outside of the given component,
   * or any time the Escape key is pressed within the component,
   * (with various browser oddities regarding clicks on blank or inert areas handled)
   * the component will request to close itself.
   *
   * Of course, if you don't do anything in the `onClose` function,
   * it won't be a soft dismiss anymore.
   *
   * Handles events for pressing the `Escape` key to close the any currently open dialogs, tooltips, menus, popups, etc.
   *
   * One press of the `Escape` key is guaranteed to only call `onClose` for *only one* component, and it is called on the component deepest in the DOM tree, differentiated by passing context information between parent and child.
   *
   * @param param0
   * @returns
   */
  function useEscapeDismiss(_ref7) {
    var {
        escapeDismissParameters: {
          onClose,
          open,
          getWindow: unstableGetWindow,
          parentDepth
        },
        refElementPopupReturn: {
          getElement
        }
      } = _ref7,
      void1 = _objectWithoutProperties(_ref7.escapeDismissParameters, _excluded3),
      void2 = _objectWithoutProperties(_ref7.refElementPopupReturn, _excluded4);
    var stableOnClose = useStableCallback(onClose);
    var getWindow = useStableCallback(unstableGetWindow);
    var getDepth = useStableGetter(parentDepth + 1);
    // When this component opens, add an event listener that finds the deepest open soft dismiss element to actually dismiss.
    // Only opened components will add event handlers, and will remove them once closed.
    // The reason this is so complicated is because:
    // 1. We must only close one soft dismiss component at a time.  If there's a tooltip in a popup, the tooltip must be dismissed.
    // 2. `keydown` events don't just work on arbitrary elements, for our purposes they must be from the `window`. So we can't rely on normal capturing or bubbling behavior on the element itself.
    // 3. Event handlers added to the `window` via `addEventHandler` are called in the order of registration, which is completely at odds with #1.
    //
    // So all soft dismiss components listen for a keydown of Escape, 
    // then the first one to do so will wait for a microtask, 
    // then find the deepest element in the document tree to dismiss of all of those components currently open.
    h(() => {
      var _window$MagicWindowKe;
      var window = getWindow();
      (_window$MagicWindowKe = window[MagicWindowKey]) !== null && _window$MagicWindowKe !== void 0 ? _window$MagicWindowKe : window[MagicWindowKey] = {
        microtaskQueued: false,
        elementQueue: new Map()
      };
      var info = window[MagicWindowKey];
      if (open) {
        console.log("Adding handler for depth=".concat(getDepth()));
        window.addEventListener("keydown", handler, {
          capture: true
        });
        return () => {
          console.log("Removing handler for depth=".concat(getDepth()));
          var element = getElement();
          if (element && info.elementQueue) info.elementQueue.delete(element);
          window.removeEventListener("keydown", handler, {
            capture: true
          });
        };
      }
      function handler(e) {
        if (e.key == "Escape") {
          console.log("Escape key for depth=".concat(getDepth()));
          // We don't know which of the currently active soft dismisses will actually do something,
          // but ONE of them definitely will,
          // so we stop propagation to child nodes, but not to everyone on the window (stopImmediatePropagation).
          e.preventDefault();
          e.stopPropagation();
          // This is what at least one of the elements will call
          var onClose2 = () => {
            stableOnClose("escape");
          };
          var element = getElement();
          if (element) {
            var treeDepth = getElementDepth(element);
            var depth = getDepth();
            info.elementQueue.set(element, {
              depth,
              onClose: onClose2,
              treeDepth
            });
          }
          if (!info.microtaskQueued) {
            info.microtaskQueued = true;
            setTimeout(() => {
              var _deepestOnClose;
              var {
                elementQueue
              } = info;
              info.microtaskQueued = false;
              info.elementQueue = new Map();
              var deepestDepth = -Infinity;
              var deepestTreeDepth = -Infinity;
              var deepestOnClose = null;
              for (var [_element, {
                depth: _depth,
                onClose: _onClose,
                treeDepth: _treeDepth
              }] of elementQueue) {
                var tieBroken = false;
                if (_depth == deepestDepth) {
                  if (_treeDepth > deepestTreeDepth) {
                    tieBroken = true;
                  }
                }
                if (_depth > deepestDepth || _depth == deepestDepth && tieBroken) {
                  deepestDepth = _depth;
                  deepestTreeDepth = _treeDepth;
                  deepestOnClose = _onClose;
                }
              }
              (_deepestOnClose = deepestOnClose) === null || _deepestOnClose === void 0 ? void 0 : _deepestOnClose();
            }, 0);
          }
        }
      }
    }, [open]);
  }
  /**
   * Handles events for dismiss events for things like popup menus or transient dialogs -- things where moving focus to a new area of the page means this component should close itself.
   *
   * @param param0
   * @returns
   */
  function useLostFocusDismiss(_ref8) {
    var {
        refElementPopupReturn: {
          getElement: getPopupElement
        },
        refElementSourceReturn,
        lostFocusDismiss: {
          open,
          onClose
        }
      } = _ref8,
      void3 = _objectWithoutProperties(_ref8.refElementPopupReturn, _excluded5),
      void1 = _objectWithoutProperties(_ref8, _excluded6);
    var _ref9 = refElementSourceReturn !== null && refElementSourceReturn !== void 0 ? refElementSourceReturn : {},
      {
        getElement: getSourceElement
      } = _ref9,
      void2 = _objectWithoutProperties(_ref9, _excluded7);
    var stableOnClose = useStableCallback(onClose);
    var getOpen = useStableGetter(open);
    var onLastActiveElementChange = T$1((newElement, _prevElement, _e) => {
      var open = getOpen();
      var sourceElement = getSourceElement === null || getSourceElement === void 0 ? void 0 : getSourceElement();
      var popupElement = getPopupElement();
      if (!(sourceElement !== null && sourceElement !== void 0 && sourceElement.contains(newElement) || popupElement !== null && popupElement !== void 0 && popupElement.contains(newElement))) {
        if (open) stableOnClose();
      }
    }, [getSourceElement]);
    return {
      activeElementParameters: {
        onLastActiveElementChange
      }
    };
  }
  /**
   * Handles events for a backdrop on a modal dialog -- the kind where the user expects the modal to close when they click/tap outside of it.
   *
   * @param param0
   */
  function useBackdropDismiss(_ref10) {
    var {
        backdropDismissParameters: {
          open,
          onClose: onCloseUnstable
        },
        refElementPopupReturn: {
          getElement
        }
      } = _ref10,
      void1 = _objectWithoutProperties(_ref10.backdropDismissParameters, _excluded8),
      void3 = _objectWithoutProperties(_ref10.refElementPopupReturn, _excluded9),
      void2 = _objectWithoutProperties(_ref10, _excluded10);
    var getOpen = useStableGetter(open);
    var onClose = useStableCallback(onCloseUnstable);
    var onBackdropClick = T$1(function onBackdropClick(e) {
      if (!getOpen()) return;
      // Basically, "was this event fired on an element not contained by the modal?"
      // There are multiple ways browser react to "interacting with nothing", and this takes care of everything.
      var element = getElement();
      var foundInsideClick = false;
      if (e.target && element && element.contains(e.target)) {
        foundInsideClick = true;
      }
      if (!foundInsideClick) {
        onClose();
      }
    }, []);
    useGlobalHandler(window, "mousedown", open ? onBackdropClick : null, {
      capture: true
    });
    useGlobalHandler(window, "touchstart", open ? onBackdropClick : null, {
      capture: true
    });
  }
  /**
   * Combines all the methods of dismissing a modal-ish or popup-ish component into one combined hook.
   *
   * This is similar to the "complete" series of list/grid navigation, in that it's the "outermost" hook of its type.
   */
  function useDismiss(_ref11) {
    var {
      dismissParameters: {
        open: globalOpen,
        onClose: globalOnClose,
        closeOnBackdrop,
        closeOnEscape,
        closeOnLostFocus
      },
      escapeDismissParameters: {
        getWindow,
        parentDepth
      }
    } = _ref11;
    var {
      refElementReturn: refElementSourceReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      refElementReturn: refElementPopupReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var onCloseBackdrop = T$1(() => {
      return globalOnClose === null || globalOnClose === void 0 ? void 0 : globalOnClose("backdrop");
    }, [globalOnClose]);
    var onCloseEscape = T$1(() => {
      return globalOnClose === null || globalOnClose === void 0 ? void 0 : globalOnClose("escape");
    }, [globalOnClose]);
    var onCloseFocus = T$1(() => {
      return globalOnClose === null || globalOnClose === void 0 ? void 0 : globalOnClose("lost-focus");
    }, [globalOnClose]);
    useBackdropDismiss({
      backdropDismissParameters: {
        onClose: onCloseBackdrop,
        open: closeOnBackdrop && globalOpen
      },
      refElementPopupReturn
    });
    useEscapeDismiss({
      escapeDismissParameters: {
        getWindow,
        onClose: onCloseEscape,
        open: closeOnEscape && globalOpen,
        parentDepth
      },
      refElementPopupReturn
    });
    var {
      activeElementParameters
    } = useLostFocusDismiss({
      lostFocusDismiss: {
        onClose: onCloseFocus,
        open: closeOnLostFocus && globalOpen
      },
      refElementPopupReturn,
      refElementSourceReturn
    });
    var getDocument = T$1(() => {
      return getWindow().document;
    }, [getWindow]);
    useActiveElement({
      activeElementParameters: _objectSpread(_objectSpread({}, activeElementParameters), {}, {
        getWindow,
        getDocument
      })
    });
    return {
      refElementSourceReturn,
      refElementPopupReturn
    };
  }

  /*!
  * tabbable 6.0.1
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  */
  var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
  var NoElement = typeof Element === 'undefined';
  var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
    return element.getRootNode();
  } : function (element) {
    return element.ownerDocument;
  };
  var isInput = function isInput(node) {
    return node.tagName === 'INPUT';
  };
  var isHiddenInput = function isHiddenInput(node) {
    return isInput(node) && node.type === 'hidden';
  };
  var isDetailsWithSummary = function isDetailsWithSummary(node) {
    var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
      return child.tagName === 'SUMMARY';
    });
    return r;
  };

  // determines if a node is ultimately attached to the window's document
  var isNodeAttached = function isNodeAttached(node) {
    var _nodeRootHost;
    // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
    //  (but NOT _the_ document; see second 'If' comment below for more).
    // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
    //  is attached, and the one we need to check if it's in the document or not (because the
    //  shadow, and all nodes it contains, is never considered in the document since shadows
    //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
    //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
    //  visibility, including all the nodes it contains). The host could be any normal node,
    //  or a custom element (i.e. web component). Either way, that's the one that is considered
    //  part of the document, not the shadow root, nor any of its children (i.e. the node being
    //  tested).
    // To further complicate things, we have to look all the way up until we find a shadow HOST
    //  that is attached (or find none) because the node might be in nested shadows...
    // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
    //  document (per the docs) and while it's a Document-type object, that document does not
    //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
    //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
    //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
    //  node is actually detached.
    var nodeRootHost = getRootNode(node).host;
    var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRootHost2;
      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
      //  which means we need to get the host's host and check if that parent host is contained
      //  in (i.e. attached to) the document
      nodeRootHost = getRootNode(nodeRootHost).host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
    }
    return attached;
  };
  var isZeroArea = function isZeroArea(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(),
      width = _node$getBoundingClie.width,
      height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
  };
  var isHidden = function isHidden(node, _ref) {
    var displayCheck = _ref.displayCheck,
      getShadowRoot = _ref.getShadowRoot;
    // NOTE: visibility will be `undefined` if node is detached from the document
    //  (see notes about this further down), which means we will consider it visible
    //  (this is legacy behavior from a very long way back)
    // NOTE: we check this regardless of `displayCheck="none"` because this is a
    //  _visibility_ check, not a _display_ check
    if (getComputedStyle(node).visibility === 'hidden') {
      return true;
    }
    var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
      return true;
    }
    if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
      if (typeof getShadowRoot === 'function') {
        // figure out if we should consider the node to be in an undisclosed shadow and use the
        //  'non-zero-area' fallback
        var originalNode = node;
        while (node) {
          var parentElement = node.parentElement;
          var rootNode = getRootNode(node);
          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
          ) {
            // node has an undisclosed shadow which means we can only treat it as a black box, so we
            //  fall back to a non-zero-area test
            return isZeroArea(node);
          } else if (node.assignedSlot) {
            // iterate up slot
            node = node.assignedSlot;
          } else if (!parentElement && rootNode !== node.ownerDocument) {
            // cross shadow boundary
            node = rootNode.host;
          } else {
            // iterate up normal dom
            node = parentElement;
          }
        }
        node = originalNode;
      }
      // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
      //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
      //  it might be a falsy value, which means shadow DOM support is disabled

      // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
      //  now we can just test to see if it would normally be visible or not, provided it's
      //  attached to the main document.
      // NOTE: We must consider case where node is inside a shadow DOM and given directly to
      //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.

      if (isNodeAttached(node)) {
        // this works wherever the node is: if there's at least one client rect, it's
        //  somehow displayed; it also covers the CSS 'display: contents' case where the
        //  node itself is hidden in place of its contents; and there's no need to search
        //  up the hierarchy either
        return !node.getClientRects().length;
      }

      // Else, the node isn't attached to the document, which means the `getClientRects()`
      //  API will __always__ return zero rects (this can happen, for example, if React
      //  is used to render nodes onto a detached tree, as confirmed in this thread:
      //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
      //
      // It also means that even window.getComputedStyle(node).display will return `undefined`
      //  because styles are only computed for nodes that are in the document.
      //
      // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
      //  somehow. Though it was never stated officially, anyone who has ever used tabbable
      //  APIs on nodes in detached containers has actually implicitly used tabbable in what
      //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
      //  considering __everything__ to be visible because of the innability to determine styles.
      //
      // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
      //  nodes as visible with the 'none' fallback.__
      if (displayCheck !== 'legacy-full') {
        return true; // hidden
      }
      // else, fallback to 'none' mode and consider the node visible
    } else if (displayCheck === 'non-zero-area') {
      // NOTE: Even though this tests that the node's client rect is non-zero to determine
      //  whether it's displayed, and that a detached node will __always__ have a zero-area
      //  client rect, we don't special-case for whether the node is attached or not. In
      //  this mode, we do want to consider nodes that have a zero area to be hidden at all
      //  times, and that includes attached or not.
      return isZeroArea(node);
    }

    // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
    //  it's visible
    return false;
  };

  // form fields (nested) inside a disabled fieldset are not focusable/tabbable
  //  unless they are in the _first_ <legend> element of the top-most disabled
  //  fieldset
  var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
      var parentNode = node.parentElement;
      // check if `node` is contained in a disabled <fieldset>
      while (parentNode) {
        if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
          // look for the first <legend> among the children of the disabled <fieldset>
          for (var i = 0; i < parentNode.children.length; i++) {
            var child = parentNode.children.item(i);
            // when the first <legend> (in document order) is found
            if (child.tagName === 'LEGEND') {
              // if its parent <fieldset> is not nested in another disabled <fieldset>,
              // return whether `node` is a descendant of its first <legend>
              return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
            }
          }
          // the disabled <fieldset> containing `node` has no <legend>
          return true;
        }
        parentNode = parentNode.parentElement;
      }
    }

    // else, node's tabbable/focusable state should not be affected by a fieldset's
    //  enabled/disabled state
    return false;
  };
  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node, options) ||
    // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }
    return true;
  };
  var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');
  var isFocusable = function isFocusable(node, options) {
    options = options || {};
    if (!node) {
      throw new Error('No node provided');
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorFocusable(options, node);
  };
  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
  (function (module, exports) {
    (function (global, factory) {
      factory();
    })(commonjsGlobal, function () {
      var _createClass = function () {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function (Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      /**
       * This work is licensed under the W3C Software and Document License
       * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
       */

      (function () {
        // Return early if we're not running inside of the browser.
        if (typeof window === 'undefined') {
          return;
        }

        // Convenience function for converting NodeLists.
        /** @type {typeof Array.prototype.slice} */
        var slice = Array.prototype.slice;

        /**
         * IE has a non-standard name for "matches".
         * @type {typeof Element.prototype.matches}
         */
        var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

        /** @type {string} */
        var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

        /**
         * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
         * attribute.
         *
         * Its main functions are:
         *
         * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
         *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
         *   each focusable node in the subtree with the singleton `InertManager` which manages all known
         *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
         *   instance exists for each focusable node which has at least one inert root as an ancestor.
         *
         * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
         *   attribute is removed from the root node). This is handled in the destructor, which calls the
         *   `deregister` method on `InertManager` for each managed inert node.
         */

        var InertRoot = function () {
          /**
           * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
           * @param {!InertManager} inertManager The global singleton InertManager object.
           */
          function InertRoot(rootElement, inertManager) {
            _classCallCheck(this, InertRoot);

            /** @type {!InertManager} */
            this._inertManager = inertManager;

            /** @type {!HTMLElement} */
            this._rootElement = rootElement;

            /**
             * @type {!Set<!InertNode>}
             * All managed focusable nodes in this InertRoot's subtree.
             */
            this._managedNodes = new Set();

            // Make the subtree hidden from assistive technology
            if (this._rootElement.hasAttribute('aria-hidden')) {
              /** @type {?string} */
              this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
            } else {
              this._savedAriaHidden = null;
            }
            this._rootElement.setAttribute('aria-hidden', 'true');

            // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
            this._makeSubtreeUnfocusable(this._rootElement);

            // Watch for:
            // - any additions in the subtree: make them unfocusable too
            // - any removals from the subtree: remove them from this inert root's managed nodes
            // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
            //   element, make that node a managed node.
            this._observer = new MutationObserver(this._onMutation.bind(this));
            this._observer.observe(this._rootElement, {
              attributes: true,
              childList: true,
              subtree: true
            });
          }

          /**
           * Call this whenever this object is about to become obsolete.  This unwinds all of the state
           * stored in this object and updates the state of all of the managed nodes.
           */

          _createClass(InertRoot, [{
            key: 'destructor',
            value: function destructor() {
              this._observer.disconnect();
              if (this._rootElement) {
                if (this._savedAriaHidden !== null) {
                  this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                } else {
                  this._rootElement.removeAttribute('aria-hidden');
                }
              }
              this._managedNodes.forEach(function (inertNode) {
                this._unmanageNode(inertNode.node);
              }, this);

              // Note we cast the nulls to the ANY type here because:
              // 1) We want the class properties to be declared as non-null, or else we
              //    need even more casts throughout this code. All bets are off if an
              //    instance has been destroyed and a method is called.
              // 2) We don't want to cast "this", because we want type-aware optimizations
              //    to know which properties we're setting.
              this._observer = /** @type {?} */null;
              this._rootElement = /** @type {?} */null;
              this._managedNodes = /** @type {?} */null;
              this._inertManager = /** @type {?} */null;
            }

            /**
             * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
             */
          }, {
            key: '_makeSubtreeUnfocusable',
            /**
             * @param {!Node} startNode
             */
            value: function _makeSubtreeUnfocusable(startNode) {
              var _this2 = this;
              composedTreeWalk(startNode, function (node) {
                return _this2._visitNode(node);
              });
              var activeElement = document.activeElement;
              if (!document.body.contains(startNode)) {
                // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                var node = startNode;
                /** @type {!ShadowRoot|undefined} */
                var root = undefined;
                while (node) {
                  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                    root = /** @type {!ShadowRoot} */node;
                    break;
                  }
                  node = node.parentNode;
                }
                if (root) {
                  activeElement = root.activeElement;
                }
              }
              if (startNode.contains(activeElement)) {
                activeElement.blur();
                // In IE11, if an element is already focused, and then set to tabindex=-1
                // calling blur() will not actually move the focus.
                // To work around this we call focus() on the body instead.
                if (activeElement === document.activeElement) {
                  document.body.focus();
                }
              }
            }

            /**
             * @param {!Node} node
             */
          }, {
            key: '_visitNode',
            value: function _visitNode(node) {
              if (node.nodeType !== Node.ELEMENT_NODE) {
                return;
              }
              var element = /** @type {!HTMLElement} */node;

              // If a descendant inert root becomes un-inert, its descendants will still be inert because of
              // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
              if (element !== this._rootElement && element.hasAttribute('inert')) {
                this._adoptInertRoot(element);
              }
              if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                this._manageNode(element);
              }
            }

            /**
             * Register the given node with this InertRoot and with InertManager.
             * @param {!Node} node
             */
          }, {
            key: '_manageNode',
            value: function _manageNode(node) {
              var inertNode = this._inertManager.register(node, this);
              this._managedNodes.add(inertNode);
            }

            /**
             * Unregister the given node with this InertRoot and with InertManager.
             * @param {!Node} node
             */
          }, {
            key: '_unmanageNode',
            value: function _unmanageNode(node) {
              var inertNode = this._inertManager.deregister(node, this);
              if (inertNode) {
                this._managedNodes['delete'](inertNode);
              }
            }

            /**
             * Unregister the entire subtree starting at `startNode`.
             * @param {!Node} startNode
             */
          }, {
            key: '_unmanageSubtree',
            value: function _unmanageSubtree(startNode) {
              var _this3 = this;
              composedTreeWalk(startNode, function (node) {
                return _this3._unmanageNode(node);
              });
            }

            /**
             * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
             * @param {!HTMLElement} node
             */
          }, {
            key: '_adoptInertRoot',
            value: function _adoptInertRoot(node) {
              var inertSubroot = this._inertManager.getInertRoot(node);

              // During initialisation this inert root may not have been registered yet,
              // so register it now if need be.
              if (!inertSubroot) {
                this._inertManager.setInert(node, true);
                inertSubroot = this._inertManager.getInertRoot(node);
              }
              inertSubroot.managedNodes.forEach(function (savedInertNode) {
                this._manageNode(savedInertNode.node);
              }, this);
            }

            /**
             * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
             * @param {!Array<!MutationRecord>} records
             * @param {!MutationObserver} self
             */
          }, {
            key: '_onMutation',
            value: function _onMutation(records, self) {
              records.forEach(function (record) {
                var target = /** @type {!HTMLElement} */record.target;
                if (record.type === 'childList') {
                  // Manage added nodes
                  slice.call(record.addedNodes).forEach(function (node) {
                    this._makeSubtreeUnfocusable(node);
                  }, this);

                  // Un-manage removed nodes
                  slice.call(record.removedNodes).forEach(function (node) {
                    this._unmanageSubtree(node);
                  }, this);
                } else if (record.type === 'attributes') {
                  if (record.attributeName === 'tabindex') {
                    // Re-initialise inert node if tabindex changes
                    this._manageNode(target);
                  } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                    // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                    // already managed nodes from this inert subroot.
                    this._adoptInertRoot(target);
                    var inertSubroot = this._inertManager.getInertRoot(target);
                    this._managedNodes.forEach(function (managedNode) {
                      if (target.contains(managedNode.node)) {
                        inertSubroot._manageNode(managedNode.node);
                      }
                    });
                  }
                }
              }, this);
            }
          }, {
            key: 'managedNodes',
            get: function get() {
              return new Set(this._managedNodes);
            }

            /** @return {boolean} */
          }, {
            key: 'hasSavedAriaHidden',
            get: function get() {
              return this._savedAriaHidden !== null;
            }

            /** @param {?string} ariaHidden */
          }, {
            key: 'savedAriaHidden',
            set: function set(ariaHidden) {
              this._savedAriaHidden = ariaHidden;
            }

            /** @return {?string} */,

            get: function get() {
              return this._savedAriaHidden;
            }
          }]);
          return InertRoot;
        }();

        /**
         * `InertNode` initialises and manages a single inert node.
         * A node is inert if it is a descendant of one or more inert root elements.
         *
         * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
         * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
         * is intrinsically focusable or not.
         *
         * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
         * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
         * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
         * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
         * or removes the `tabindex` attribute if the element is intrinsically focusable.
         */

        var InertNode = function () {
          /**
           * @param {!Node} node A focusable element to be made inert.
           * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
           */
          function InertNode(node, inertRoot) {
            _classCallCheck(this, InertNode);

            /** @type {!Node} */
            this._node = node;

            /** @type {boolean} */
            this._overrodeFocusMethod = false;

            /**
             * @type {!Set<!InertRoot>} The set of descendant inert roots.
             *    If and only if this set becomes empty, this node is no longer inert.
             */
            this._inertRoots = new Set([inertRoot]);

            /** @type {?number} */
            this._savedTabIndex = null;

            /** @type {boolean} */
            this._destroyed = false;

            // Save any prior tabindex info and make this node untabbable
            this.ensureUntabbable();
          }

          /**
           * Call this whenever this object is about to become obsolete.
           * This makes the managed node focusable again and deletes all of the previously stored state.
           */

          _createClass(InertNode, [{
            key: 'destructor',
            value: function destructor() {
              this._throwIfDestroyed();
              if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                var element = /** @type {!HTMLElement} */this._node;
                if (this._savedTabIndex !== null) {
                  element.setAttribute('tabindex', this._savedTabIndex);
                } else {
                  element.removeAttribute('tabindex');
                }

                // Use `delete` to restore native focus method.
                if (this._overrodeFocusMethod) {
                  delete element.focus;
                }
              }

              // See note in InertRoot.destructor for why we cast these nulls to ANY.
              this._node = /** @type {?} */null;
              this._inertRoots = /** @type {?} */null;
              this._destroyed = true;
            }

            /**
             * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
             * If the object has been destroyed, any attempt to access it will cause an exception.
             */
          }, {
            key: '_throwIfDestroyed',
            /**
             * Throw if user tries to access destroyed InertNode.
             */
            value: function _throwIfDestroyed() {
              if (this.destroyed) {
                throw new Error('Trying to access destroyed InertNode');
              }
            }

            /** @return {boolean} */
          }, {
            key: 'ensureUntabbable',
            /** Save the existing tabindex value and make the node untabbable and unfocusable */
            value: function ensureUntabbable() {
              if (this.node.nodeType !== Node.ELEMENT_NODE) {
                return;
              }
              var element = /** @type {!HTMLElement} */this.node;
              if (matches.call(element, _focusableElementsString)) {
                if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
                  return;
                }
                if (element.hasAttribute('tabindex')) {
                  this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
                }
                element.setAttribute('tabindex', '-1');
                if (element.nodeType === Node.ELEMENT_NODE) {
                  element.focus = function () {};
                  this._overrodeFocusMethod = true;
                }
              } else if (element.hasAttribute('tabindex')) {
                this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
                element.removeAttribute('tabindex');
              }
            }

            /**
             * Add another inert root to this inert node's set of managing inert roots.
             * @param {!InertRoot} inertRoot
             */
          }, {
            key: 'addInertRoot',
            value: function addInertRoot(inertRoot) {
              this._throwIfDestroyed();
              this._inertRoots.add(inertRoot);
            }

            /**
             * Remove the given inert root from this inert node's set of managing inert roots.
             * If the set of managing inert roots becomes empty, this node is no longer inert,
             * so the object should be destroyed.
             * @param {!InertRoot} inertRoot
             */
          }, {
            key: 'removeInertRoot',
            value: function removeInertRoot(inertRoot) {
              this._throwIfDestroyed();
              this._inertRoots['delete'](inertRoot);
              if (this._inertRoots.size === 0) {
                this.destructor();
              }
            }
          }, {
            key: 'destroyed',
            get: function get() {
              return (/** @type {!InertNode} */this._destroyed
              );
            }
          }, {
            key: 'hasSavedTabIndex',
            get: function get() {
              return this._savedTabIndex !== null;
            }

            /** @return {!Node} */
          }, {
            key: 'node',
            get: function get() {
              this._throwIfDestroyed();
              return this._node;
            }

            /** @param {?number} tabIndex */
          }, {
            key: 'savedTabIndex',
            set: function set(tabIndex) {
              this._throwIfDestroyed();
              this._savedTabIndex = tabIndex;
            }

            /** @return {?number} */,

            get: function get() {
              this._throwIfDestroyed();
              return this._savedTabIndex;
            }
          }]);
          return InertNode;
        }();

        /**
         * InertManager is a per-document singleton object which manages all inert roots and nodes.
         *
         * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
         * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
         * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
         * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
         * is created for each such node, via the `_managedNodes` map.
         */

        var InertManager = function () {
          /**
           * @param {!Document} document
           */
          function InertManager(document) {
            _classCallCheck(this, InertManager);
            if (!document) {
              throw new Error('Missing required argument; InertManager needs to wrap a document.');
            }

            /** @type {!Document} */
            this._document = document;

            /**
             * All managed nodes known to this InertManager. In a map to allow looking up by Node.
             * @type {!Map<!Node, !InertNode>}
             */
            this._managedNodes = new Map();

            /**
             * All inert roots known to this InertManager. In a map to allow looking up by Node.
             * @type {!Map<!Node, !InertRoot>}
             */
            this._inertRoots = new Map();

            /**
             * Observer for mutations on `document.body`.
             * @type {!MutationObserver}
             */
            this._observer = new MutationObserver(this._watchForInert.bind(this));

            // Add inert style.
            addInertStyle(document.head || document.body || document.documentElement);

            // Wait for document to be loaded.
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
            } else {
              this._onDocumentLoaded();
            }
          }

          /**
           * Set whether the given element should be an inert root or not.
           * @param {!HTMLElement} root
           * @param {boolean} inert
           */

          _createClass(InertManager, [{
            key: 'setInert',
            value: function setInert(root, inert) {
              if (inert) {
                if (this._inertRoots.has(root)) {
                  // element is already inert
                  return;
                }
                var inertRoot = new InertRoot(root, this);
                root.setAttribute('inert', '');
                this._inertRoots.set(root, inertRoot);
                // If not contained in the document, it must be in a shadowRoot.
                // Ensure inert styles are added there.
                if (!this._document.body.contains(root)) {
                  var parent = root.parentNode;
                  while (parent) {
                    if (parent.nodeType === 11) {
                      addInertStyle(parent);
                    }
                    parent = parent.parentNode;
                  }
                }
              } else {
                if (!this._inertRoots.has(root)) {
                  // element is already non-inert
                  return;
                }
                var _inertRoot = this._inertRoots.get(root);
                _inertRoot.destructor();
                this._inertRoots['delete'](root);
                root.removeAttribute('inert');
              }
            }

            /**
             * Get the InertRoot object corresponding to the given inert root element, if any.
             * @param {!Node} element
             * @return {!InertRoot|undefined}
             */
          }, {
            key: 'getInertRoot',
            value: function getInertRoot(element) {
              return this._inertRoots.get(element);
            }

            /**
             * Register the given InertRoot as managing the given node.
             * In the case where the node has a previously existing inert root, this inert root will
             * be added to its set of inert roots.
             * @param {!Node} node
             * @param {!InertRoot} inertRoot
             * @return {!InertNode} inertNode
             */
          }, {
            key: 'register',
            value: function register(node, inertRoot) {
              var inertNode = this._managedNodes.get(node);
              if (inertNode !== undefined) {
                // node was already in an inert subtree
                inertNode.addInertRoot(inertRoot);
              } else {
                inertNode = new InertNode(node, inertRoot);
              }
              this._managedNodes.set(node, inertNode);
              return inertNode;
            }

            /**
             * De-register the given InertRoot as managing the given inert node.
             * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
             * node from the InertManager's set of managed nodes if it is destroyed.
             * If the node is not currently managed, this is essentially a no-op.
             * @param {!Node} node
             * @param {!InertRoot} inertRoot
             * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
             */
          }, {
            key: 'deregister',
            value: function deregister(node, inertRoot) {
              var inertNode = this._managedNodes.get(node);
              if (!inertNode) {
                return null;
              }
              inertNode.removeInertRoot(inertRoot);
              if (inertNode.destroyed) {
                this._managedNodes['delete'](node);
              }
              return inertNode;
            }

            /**
             * Callback used when document has finished loading.
             */
          }, {
            key: '_onDocumentLoaded',
            value: function _onDocumentLoaded() {
              // Find all inert roots in document and make them actually inert.
              var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
              inertElements.forEach(function (inertElement) {
                this.setInert(inertElement, true);
              }, this);

              // Comment this out to use programmatic API only.
              this._observer.observe(this._document.body || this._document.documentElement, {
                attributes: true,
                subtree: true,
                childList: true
              });
            }

            /**
             * Callback used when mutation observer detects attribute changes.
             * @param {!Array<!MutationRecord>} records
             * @param {!MutationObserver} self
             */
          }, {
            key: '_watchForInert',
            value: function _watchForInert(records, self) {
              var _this = this;
              records.forEach(function (record) {
                switch (record.type) {
                  case 'childList':
                    slice.call(record.addedNodes).forEach(function (node) {
                      if (node.nodeType !== Node.ELEMENT_NODE) {
                        return;
                      }
                      var inertElements = slice.call(node.querySelectorAll('[inert]'));
                      if (matches.call(node, '[inert]')) {
                        inertElements.unshift(node);
                      }
                      inertElements.forEach(function (inertElement) {
                        this.setInert(inertElement, true);
                      }, _this);
                    }, _this);
                    break;
                  case 'attributes':
                    if (record.attributeName !== 'inert') {
                      return;
                    }
                    var target = /** @type {!HTMLElement} */record.target;
                    var inert = target.hasAttribute('inert');
                    _this.setInert(target, inert);
                    break;
                }
              }, this);
            }
          }]);
          return InertManager;
        }();

        /**
         * Recursively walk the composed tree from |node|.
         * @param {!Node} node
         * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
         *     before descending into child nodes.
         * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
         */

        function composedTreeWalk(node, callback, shadowRootAncestor) {
          if (node.nodeType == Node.ELEMENT_NODE) {
            var element = /** @type {!HTMLElement} */node;
            if (callback) {
              callback(element);
            }

            // Descend into node:
            // If it has a ShadowRoot, ignore all child elements - these will be picked
            // up by the <content> or <shadow> elements. Descend straight into the
            // ShadowRoot.
            var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
            if (shadowRoot) {
              composedTreeWalk(shadowRoot, callback);
              return;
            }

            // If it is a <content> element, descend into distributed elements - these
            // are elements from outside the shadow root which are rendered inside the
            // shadow DOM.
            if (element.localName == 'content') {
              var content = /** @type {!HTMLContentElement} */element;
              // Verifies if ShadowDom v0 is supported.
              var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
              for (var i = 0; i < distributedNodes.length; i++) {
                composedTreeWalk(distributedNodes[i], callback);
              }
              return;
            }

            // If it is a <slot> element, descend into assigned nodes - these
            // are elements from outside the shadow root which are rendered inside the
            // shadow DOM.
            if (element.localName == 'slot') {
              var slot = /** @type {!HTMLSlotElement} */element;
              // Verify if ShadowDom v1 is supported.
              var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                flatten: true
              }) : [];
              for (var _i = 0; _i < _distributedNodes.length; _i++) {
                composedTreeWalk(_distributedNodes[_i], callback);
              }
              return;
            }
          }

          // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
          // element, nor a <shadow> element recurse normally.
          var child = node.firstChild;
          while (child != null) {
            composedTreeWalk(child, callback);
            child = child.nextSibling;
          }
        }

        /**
         * Adds a style element to the node containing the inert specific styles
         * @param {!Node} node
         */
        function addInertStyle(node) {
          if (node.querySelector('style#inert-style, link#inert-style')) {
            return;
          }
          var style = document.createElement('style');
          style.setAttribute('id', 'inert-style');
          style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
          node.appendChild(style);
        }
        if (!HTMLElement.prototype.hasOwnProperty('inert')) {
          /** @type {!InertManager} */
          var inertManager = new InertManager(document);
          Object.defineProperty(HTMLElement.prototype, 'inert', {
            enumerable: true,
            /** @this {!HTMLElement} */
            get: function get() {
              return this.hasAttribute('inert');
            },
            /** @this {!HTMLElement} */
            set: function set(inert) {
              inertManager.setInert(this, inert);
            }
          });
        }
      })();
    });
  })();

  /**
   * @license
   * Copyright 2016 Google Inc. All rights reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  (() => {
    var _a, _b, _c;
    /* Symbols for private properties */
    var _blockingElements = Symbol();
    var _alreadyInertElements = Symbol();
    var _topElParents = Symbol();
    var _siblingsToRestore = Symbol();
    var _parentMO = Symbol();
    /* Symbols for private static methods */
    var _topChanged = Symbol();
    var _swapInertedSibling = Symbol();
    var _inertSiblings = Symbol();
    var _restoreInertedSiblings = Symbol();
    var _getParents = Symbol();
    var _getDistributedChildren = Symbol();
    var _isInertable = Symbol();
    var _handleMutations = Symbol();
    class BlockingElementsImpl {
      constructor() {
        /**
         * The blocking elements.
         */
        this[_a] = [];
        /**
         * Used to keep track of the parents of the top element, from the element
         * itself up to body. When top changes, the old top might have been removed
         * from the document, so we need to memoize the inerted parents' siblings
         * in order to restore their inerteness when top changes.
         */
        this[_b] = [];
        /**
         * Elements that are already inert before the first blocking element is
         * pushed.
         */
        this[_c] = new Set();
      }
      destructor() {
        // Restore original inertness.
        this[_restoreInertedSiblings](this[_topElParents]);
        // Note we don't want to make these properties nullable on the class,
        // since then we'd need non-null casts in many places. Calling a method on
        // a BlockingElements instance after calling destructor will result in an
        // exception.
        var nullable = this;
        nullable[_blockingElements] = null;
        nullable[_topElParents] = null;
        nullable[_alreadyInertElements] = null;
      }
      get top() {
        var elems = this[_blockingElements];
        return elems[elems.length - 1] || null;
      }
      push(element) {
        if (!element || element === this.top) {
          return;
        }
        // Remove it from the stack, we'll bring it to the top.
        this.remove(element);
        this[_topChanged](element);
        this[_blockingElements].push(element);
      }
      remove(element) {
        var i = this[_blockingElements].indexOf(element);
        if (i === -1) {
          return false;
        }
        this[_blockingElements].splice(i, 1);
        // Top changed only if the removed element was the top element.
        if (i === this[_blockingElements].length) {
          this[_topChanged](this.top);
        }
        return true;
      }
      pop() {
        var top = this.top;
        top && this.remove(top);
        return top;
      }
      has(element) {
        return this[_blockingElements].indexOf(element) !== -1;
      }
      /**
       * Sets `inert` to all document elements except the new top element, its
       * parents, and its distributed content.
       */
      [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
        var toKeepInert = this[_alreadyInertElements];
        var oldParents = this[_topElParents];
        // No new top, reset old top if any.
        if (!newTop) {
          this[_restoreInertedSiblings](oldParents);
          toKeepInert.clear();
          this[_topElParents] = [];
          return;
        }
        var newParents = this[_getParents](newTop);
        // New top is not contained in the main document!
        if (newParents[newParents.length - 1].parentNode !== document.body) {
          throw Error('Non-connected element cannot be a blocking element');
        }
        // Cast here because we know we'll call _inertSiblings on newParents
        // below.
        this[_topElParents] = newParents;
        var toSkip = this[_getDistributedChildren](newTop);
        // No previous top element.
        if (!oldParents.length) {
          this[_inertSiblings](newParents, toSkip, toKeepInert);
          return;
        }
        var i = oldParents.length - 1;
        var j = newParents.length - 1;
        // Find common parent. Index 0 is the element itself (so stop before it).
        while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
          i--;
          j--;
        }
        // If up the parents tree there are 2 elements that are siblings, swap
        // the inerted sibling.
        if (oldParents[i] !== newParents[j]) {
          this[_swapInertedSibling](oldParents[i], newParents[j]);
        }
        // Restore old parents siblings inertness.
        i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
        // Make new parents siblings inert.
        j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
      }
      /**
       * Swaps inertness between two sibling elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_swapInertedSibling](oldInert, newInert) {
        var siblingsToRestore = oldInert[_siblingsToRestore];
        // oldInert is not contained in siblings to restore, so we have to check
        // if it's inertable and if already inert.
        if (this[_isInertable](oldInert) && !oldInert.inert) {
          oldInert.inert = true;
          siblingsToRestore.add(oldInert);
        }
        // If newInert was already between the siblings to restore, it means it is
        // inertable and must be restored.
        if (siblingsToRestore.has(newInert)) {
          newInert.inert = false;
          siblingsToRestore.delete(newInert);
        }
        newInert[_parentMO] = oldInert[_parentMO];
        newInert[_siblingsToRestore] = siblingsToRestore;
        oldInert[_parentMO] = undefined;
        oldInert[_siblingsToRestore] = undefined;
      }
      /**
       * Restores original inertness to the siblings of the elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_restoreInertedSiblings](elements) {
        for (var element of elements) {
          var mo = element[_parentMO];
          mo.disconnect();
          element[_parentMO] = undefined;
          var siblings = element[_siblingsToRestore];
          for (var sibling of siblings) {
            sibling.inert = false;
          }
          element[_siblingsToRestore] = undefined;
        }
      }
      /**
       * Inerts the siblings of the elements except the elements to skip. Stores
       * the inerted siblings into the element's symbol `_siblingsToRestore`.
       * Pass `toKeepInert` to collect the already inert elements.
       * Sets the property `inert` over the attribute since the inert spec
       * doesn't specify if it should be reflected.
       * https://html.spec.whatwg.org/multipage/interaction.html#inert
       */
      [_inertSiblings](elements, toSkip, toKeepInert) {
        for (var element of elements) {
          // Assume element is not a Document, so it must have a parentNode.
          var parent = element.parentNode;
          var children = parent.children;
          var inertedSiblings = new Set();
          for (var _j = 0; _j < children.length; _j++) {
            var sibling = children[_j];
            // Skip the input element, if not inertable or to be skipped.
            if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
              continue;
            }
            // Should be collected since already inerted.
            if (toKeepInert && sibling.inert) {
              toKeepInert.add(sibling);
            } else {
              sibling.inert = true;
              inertedSiblings.add(sibling);
            }
          }
          // Store the siblings that were inerted.
          element[_siblingsToRestore] = inertedSiblings;
          // Observe only immediate children mutations on the parent.
          var mo = new MutationObserver(this[_handleMutations].bind(this));
          element[_parentMO] = mo;
          var parentToObserve = parent;
          // If we're using the ShadyDOM polyfill, then our parent could be a
          // shady root, which is an object that acts like a ShadowRoot, but isn't
          // actually a node in the real DOM. Observe the real DOM parent instead.
          var maybeShadyRoot = parentToObserve;
          if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
            parentToObserve = maybeShadyRoot.host;
          }
          mo.observe(parentToObserve, {
            childList: true
          });
        }
      }
      /**
       * Handles newly added/removed nodes by toggling their inertness.
       * It also checks if the current top Blocking Element has been removed,
       * notifying and removing it.
       */
      [_handleMutations](mutations) {
        var parents = this[_topElParents];
        var toKeepInert = this[_alreadyInertElements];
        for (var mutation of mutations) {
          // If the target is a shadowRoot, get its host as we skip shadowRoots when
          // computing _topElParents.
          var target = mutation.target.host || mutation.target;
          var idx = target === document.body ? parents.length : parents.indexOf(target);
          var inertedChild = parents[idx - 1];
          var inertedSiblings = inertedChild[_siblingsToRestore];
          // To restore.
          for (var _i2 = 0; _i2 < mutation.removedNodes.length; _i2++) {
            var sibling = mutation.removedNodes[_i2];
            if (sibling === inertedChild) {
              console.info('Detected removal of the top Blocking Element.');
              this.pop();
              return;
            }
            if (inertedSiblings.has(sibling)) {
              sibling.inert = false;
              inertedSiblings.delete(sibling);
            }
          }
          // To inert.
          for (var _i3 = 0; _i3 < mutation.addedNodes.length; _i3++) {
            var _sibling = mutation.addedNodes[_i3];
            if (!this[_isInertable](_sibling)) {
              continue;
            }
            if (toKeepInert && _sibling.inert) {
              toKeepInert.add(_sibling);
            } else {
              _sibling.inert = true;
              inertedSiblings.add(_sibling);
            }
          }
        }
      }
      /**
       * Returns if the element is inertable.
       */
      [_isInertable](element) {
        return false === /^(style|template|script)$/.test(element.localName);
      }
      /**
       * Returns the list of newParents of an element, starting from element
       * (included) up to `document.body` (excluded).
       */
      [_getParents](element) {
        var parents = [];
        var current = element;
        // Stop to body.
        while (current && current !== document.body) {
          // Skip shadow roots.
          if (current.nodeType === Node.ELEMENT_NODE) {
            parents.push(current);
          }
          // ShadowDom v1
          if (current.assignedSlot) {
            // Collect slots from deepest slot to top.
            while (current = current.assignedSlot) {
              parents.push(current);
            }
            // Continue the search on the top slot.
            current = parents.pop();
            continue;
          }
          current = current.parentNode || current.host;
        }
        return parents;
      }
      /**
       * Returns the distributed children of the element's shadow root.
       * Returns null if the element doesn't have a shadow root.
       */
      [_getDistributedChildren](element) {
        var shadowRoot = element.shadowRoot;
        if (!shadowRoot) {
          return null;
        }
        var result = new Set();
        var i;
        var j;
        var nodes;
        var slots = shadowRoot.querySelectorAll('slot');
        if (slots.length && slots[0].assignedNodes) {
          for (i = 0; i < slots.length; i++) {
            nodes = slots[i].assignedNodes({
              flatten: true
            });
            for (j = 0; j < nodes.length; j++) {
              if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                result.add(nodes[j]);
              }
            }
          }
          // No need to search for <content>.
        }

        return result;
      }
    }
    document.$blockingElements = new BlockingElementsImpl();
  })();
  function getDocument(element) {
    var _ref12, _ref13, _element$ownerDocumen;
    return (_ref12 = (_ref13 = (_element$ownerDocumen = element === null || element === void 0 ? void 0 : element.ownerDocument) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : document) !== null && _ref13 !== void 0 ? _ref13 : window.document) !== null && _ref12 !== void 0 ? _ref12 : globalThis.document;
  }
  function blockingElements() {
    return getDocument().$blockingElements;
  }
  /**
   * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
   *
   * Automatically handles consecutive calls with a loosely applied stack operation
   * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
   * it'll take to find its way into the spec, if ever)
   * @param target
   */
  function useBlockingElement(enabled, getTarget) {
    var stableGetTarget = useStableCallback(getTarget);
    var getDocument = useStableCallback(() => {
      var _getTarget$ownerDocum, _getTarget;
      return (_getTarget$ownerDocum = (_getTarget = getTarget()) === null || _getTarget === void 0 ? void 0 : _getTarget.ownerDocument) !== null && _getTarget$ownerDocum !== void 0 ? _getTarget$ownerDocum : globalThis.document;
    });
    useActiveElement({
      activeElementParameters: {
        getDocument,
        onLastActiveElementChange: useStableCallback(e => {
          if (e) {
            if (enabled) setLastActiveWhenOpen(e);else setLastActiveWhenClosed(e);
          }
        })
      }
    });
    var [getTop, setTop] = usePassiveState(null, returnNull);
    var [getLastActiveWhenClosed, setLastActiveWhenClosed] = usePassiveState(null, returnNull);
    var [getLastActiveWhenOpen, setLastActiveWhenOpen] = usePassiveState(null, returnNull);
    /**
     * Push/pop the element from the blockingElements stack.
     */
    s(() => {
      var target = stableGetTarget();
      if (enabled) {
        // Sometimes blockingElements will fail if, for example,
        // the target element isn't connected to document.body.
        // This is rare, but it's better to fail silently with weird tabbing behavior
        // than to crash the entire application.
        try {
          blockingElements().push(target);
          setTop(target);
          return () => {
            blockingElements().remove(target);
          };
        } catch (ex) {
          // Well, semi-silently.
          console.error(ex);
        }
      }
    }, [enabled]);
    return {
      getTop,
      getLastActiveWhenClosed,
      getLastActiveWhenOpen
    };
  }

  //const elementsToRestoreFocusTo = new Map<Element | null, (Node & HTMLOrSVGElement)>();
  function useFocusTrap(_ref14) {
    var {
        focusTrapParameters: {
          onlyMoveFocus,
          trapActive,
          focusPopup: focusSelfUnstable,
          focusOpener: focusOpenerUnstable
        },
        refElementParameters: {
          onElementChange
        }
      } = _ref14,
      refElementParameters = _objectWithoutProperties(_ref14.refElementParameters, _excluded11);
    var focusSelf = useStableCallback(focusSelfUnstable);
    var focusOpener = useStableCallback(focusOpenerUnstable);
    h(() => {
      if (trapActive) {
        var top = getTop();
        getLastActiveWhenOpen();
        {
          console.assert(!!top);
          if (top) focusSelf(top, () => findFirstFocusable(top));
        }
      } else {
        var lastActive = getLastActiveWhenClosed();
        if (lastActive) focusOpener(lastActive);
      }
    }, [trapActive]);
    var {
      refElementReturn
    } = useRefElement({
      refElementParameters: _objectSpread({
        onElementChange
      }, refElementParameters)
    });
    var {
      getElement
    } = refElementReturn;
    var {
      getTop,
      getLastActiveWhenClosed,
      getLastActiveWhenOpen
    } = useBlockingElement(trapActive && !onlyMoveFocus, getElement);
    return {
      refElementReturn,
      focusTrapReturn: {
        propsUnstable: {
          "aria-modal": trapActive ? "true" : undefined
        }
      }
    };
  }
  /**
   * Returns the first focusable element contained within the given node, or null if none are found.
   * @param element
   * @returns
   */
  function findFirstFocusable(element) {
    var treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
      acceptNode: node => node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
    });
    var firstFocusable = treeWalker.firstChild();
    return firstFocusable;
  }
  function useTextContent(_ref15) {
    var {
      refElementReturn: {
        getElement
      },
      textContentParameters: {
        getText,
        onTextContentChange
      }
    } = _ref15;
    var [getTextContent, setTextContent] = usePassiveState(onTextContentChange, returnNull);
    h(() => {
      var element = getElement();
      if (element) {
        var textContent = getText(element);
        if (textContent) {
          setTextContent(textContent);
        }
      }
    });
    return {
      textContentReturn: {
        getTextContent
      }
    };
  }

  /**
   * Slightly enhanced version of `useState` that includes a getter that remains constant
   * (i.e. you can use it in `useEffect` and friends without it being a dependency).
   *
   * @param initialState
   * @returns
   */
  function useState(initialState) {
    // We keep both, but overrride the `setState` functionality
    var [state, setStateP] = p(initialState);
    var ref = _(state);
    // Hijack the normal setter function 
    // to also set our ref to the new value
    var setState = T$1(value => {
      if (typeof value === "function") {
        var callback = value;
        setStateP(prevValue => {
          var nextValue = callback(prevValue);
          ref.current = nextValue;
          return nextValue;
        });
      } else {
        ref.current = value;
        setStateP(value);
      }
    }, []);
    var getState = () => {
      return ref.current;
    };
    console.assert(ref.current === state || typeof state === "number" && isNaN(state));
    return [state, setState, getState];
  }

  /** Arguments passed to the child 'useLinearNavigationChild` */
  //export interface UseLinearNavigationChildInfo { }
  /**
   * When used in tandem with `useRovingTabIndex`, allows control of
   * the tabbable index with the arrow keys.
   *
   * @see useListNavigation, which packages everything up together.
   */
  function useLinearNavigation(_ref16) {
    var {
      rovingTabIndexReturn,
      linearNavigationParameters
    } = _ref16;
    var {
      getHighestIndex,
      indexDemangler,
      indexMangler,
      isValid,
      navigatePastEnd,
      navigatePastStart
    } = linearNavigationParameters;
    var {
      getTabbableIndex,
      setTabbableIndex
    } = rovingTabIndexReturn;
    var navigateAbsolute = T$1((i, e, fromUserInteraction) => {
      var target = indexDemangler(i);
      var {
        value
      } = tryNavigateToIndex({
        isValid,
        highestChildIndex: getHighestIndex(),
        indexDemangler,
        indexMangler,
        searchDirection: -1,
        target
      });
      setTabbableIndex(value, e, fromUserInteraction);
    }, []);
    var navigateToFirst = useStableCallback((e, fromUserInteraction) => {
      navigateAbsolute(0, e, fromUserInteraction);
    });
    var navigateToLast = useStableCallback((e, fromUserInteraction) => {
      navigateAbsolute(getHighestIndex(), e, fromUserInteraction);
    });
    var navigateRelative2 = useStableCallback((e, offset, fromUserInteraction, mode) => {
      var _getTabbableIndex;
      var original = (_getTabbableIndex = getTabbableIndex()) !== null && _getTabbableIndex !== void 0 ? _getTabbableIndex : 0;
      var {
        status,
        value
      } = tryNavigateToIndex({
        isValid,
        highestChildIndex: getHighestIndex(),
        indexDemangler,
        indexMangler,
        searchDirection: Math.sign(offset) || 1,
        target: indexDemangler(indexMangler(original) + offset)
      });
      if (status == "past-end") {
        if (navigatePastEnd == "wrap") {
          if (mode == "single") navigateToFirst(e, fromUserInteraction);else {
            /* eslint-disable no-constant-condition */
            // Uncomment to allow page up/down to wrap after hitting the top/bottom once.
            // It works fine, the problem isn't that -- the problem is it just feels wrong. 
            // Page Up/Down don't feel like they should wrap, even if normally requested. 
            // That's the arrow keys' domain.
            navigateToLast(e, fromUserInteraction);
          }
        } else {
          navigatePastEnd();
        }
      } else if (status == "past-start") {
        if (navigatePastStart == "wrap") {
          if (mode == "single") {
            navigateToLast(e, fromUserInteraction);
          } else {
            /* eslint-disable no-constant-condition */
            // See above. It works fine but just feels wrong to wrap on Page Up/Down.
            navigateToFirst(e, fromUserInteraction);
          }
        } else {
          navigatePastStart();
        }
      } else {
        setTabbableIndex(value, e, fromUserInteraction);
      }
    });
    var navigateToNext = useStableCallback((e, fromUserInteraction) => {
      navigateRelative2(e, 1, fromUserInteraction, "single");
      // setTabbableIndex(navigateRelative((getTabbableIndex() ?? 0), +1), fromUserInteraction)
    });

    var navigateToPrev = useStableCallback((e, fromUserInteraction) => {
      navigateRelative2(e, -1, fromUserInteraction, "single");
      // setTabbableIndex(navigateRelative((getTabbableIndex() ?? 0), +1), fromUserInteraction)
    });

    var getDisableArrowKeys = useStableGetter(linearNavigationParameters.disableArrowKeys);
    var getDisableHomeEndKeys = useStableGetter(linearNavigationParameters.disableHomeEndKeys);
    var getNavigationDirection = useStableGetter(linearNavigationParameters.navigationDirection);
    var getPageNavigationSize = useStableGetter(linearNavigationParameters.pageNavigationSize);
    var stableProps = _({
      onKeyDown: e => {
        // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
        if (e.ctrlKey || e.metaKey) return;
        //const info = getLogicalDirectionInfo();
        var navigationDirection = getNavigationDirection();
        var disableArrowKeys = getDisableArrowKeys();
        var disableHomeEndKeys = getDisableHomeEndKeys();
        var pageNavigationSize = getPageNavigationSize();
        var allowsVerticalNavigation = navigationDirection == "vertical" || navigationDirection == "either";
        var allowsHorizontalNavigation = navigationDirection == "horizontal" || navigationDirection == "either";
        var truePageNavigationSize = pageNavigationSize;
        if (truePageNavigationSize < 1) {
          truePageNavigationSize = Math.round(pageNavigationSize * Math.max(100, getHighestIndex() + 1));
        }
        switch (e.key) {
          case "ArrowUp":
            {
              //const propName = (info?.blockOrientation === "vertical" ? "blockDirection" : "inlineDirection");
              var directionAllowed = !disableArrowKeys && allowsVerticalNavigation;
              if (directionAllowed) {
                navigateToPrev(e, true);
                e.preventDefault();
                e.stopPropagation();
              }
              break;
            }
          case "ArrowDown":
            {
              var _directionAllowed = !disableArrowKeys && allowsVerticalNavigation;
              if (_directionAllowed) {
                navigateToNext(e, true);
                e.preventDefault();
                e.stopPropagation();
              }
              break;
            }
          case "ArrowLeft":
            {
              var _directionAllowed2 = !disableArrowKeys && allowsHorizontalNavigation;
              if (_directionAllowed2) {
                navigateToPrev(e, true);
                e.preventDefault();
                e.stopPropagation();
              }
              break;
            }
          case "ArrowRight":
            {
              var _directionAllowed3 = !disableArrowKeys && allowsHorizontalNavigation;
              if (_directionAllowed3) {
                navigateToNext(e, true);
                e.preventDefault();
                e.stopPropagation();
              }
              break;
            }
          case "PageUp":
            {
              if (truePageNavigationSize > 0) {
                navigateRelative2(e, -truePageNavigationSize, true, "page");
                e.preventDefault();
                e.stopPropagation();
              }
              break;
            }
          case "PageDown":
            {
              if (truePageNavigationSize > 0) {
                navigateRelative2(e, truePageNavigationSize, true, "page");
                e.preventDefault();
                e.stopPropagation();
              }
              break;
            }
          case "Home":
            if (!disableHomeEndKeys) {
              navigateToFirst(e, true);
              e.preventDefault();
              e.stopPropagation();
            }
            break;
          case "End":
            if (!disableHomeEndKeys) {
              navigateToLast(e, true);
              e.preventDefault();
              e.stopPropagation();
            }
            break;
        }
      }
    });
    return {
      linearNavigationReturn: {
        propsStable: stableProps.current
      }
    };
  }
  function tryNavigateToIndex(_ref17) {
    var {
      isValid,
      highestChildIndex: upper,
      searchDirection,
      indexDemangler,
      indexMangler,
      target
    } = _ref17;
    //const upper = children.getHighestIndex();
    var lower = 0;
    if (searchDirection === -1) {
      while (target >= lower && !isValid(target)) {
        target = indexDemangler(indexMangler(target) - 1);
      }
      return target < lower ? {
        value: indexDemangler(lower),
        status: "past-start"
      } : {
        value: target,
        status: "normal"
      };
    } else if (searchDirection === 1) {
      while (target <= upper && !isValid(target)) {
        target = indexDemangler(indexMangler(target) + 1);
      }
      return target > upper ? {
        value: indexDemangler(upper),
        status: "past-end"
      } : {
        value: target,
        status: "normal"
      };
    } else {
      return {
        value: lower,
        status: "normal"
      };
    }
  }
  /**
   * Allows for the selection of a managed child by typing the given text associated with it.
   *
   * @see useListNavigation, which packages everything up together.
   */
  function useTypeaheadNavigation(_ref18) {
    var {
        typeaheadNavigationParameters: {
          collator,
          typeaheadTimeout,
          noTypeahead,
          isValid
        },
        rovingTabIndexReturn: {
          getTabbableIndex: getIndex,
          setTabbableIndex: setIndex
        }
      } = _ref18,
      _void3 = _objectWithoutProperties(_ref18.typeaheadNavigationParameters, _excluded12),
      _void1 = _objectWithoutProperties(_ref18.rovingTabIndexReturn, _excluded13),
      _void2 = _objectWithoutProperties(_ref18, _excluded14);
    // For typeahead, keep track of what our current "search" string is (if we have one)
    // and also clear it every 1000 ms since the last time it changed.
    // Next, keep a mapping of typeahead values to indices for faster searching.
    // And, for the user's sake, let them know when their typeahead can't match anything anymore
    var [getCurrentTypeahead, setCurrentTypeahead] = usePassiveState(useStableCallback((currentTypeahead, prev, reason) => {
      var handle = setTimeout(() => {
        setCurrentTypeahead(null, undefined);
        setInvalidTypeahead(null);
      }, typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000);
      updateBasedOnTypeaheadChange(currentTypeahead, reason);
      return () => clearTimeout(handle);
    }));
    //useTimeout({ timeout: typeaheadTimeout ?? 1000, callback: () => { setCurrentTypeahead(null); setInvalidTypeahead(null); }, triggerIndex: currentTypeahead });
    var sortedTypeaheadInfo = _([]);
    var [invalidTypeahead, setInvalidTypeahead] = useState(false);
    // Handle typeahead for input method editors as well
    // Essentially, when active, ignore further keys 
    // because we're waiting for a CompositionEnd event
    var [, setImeActive, getImeActive] = useState(false);
    // Because composition events fire *after* keydown events 
    // (but within the same task, which, TODO, could be browser-dependent),
    // we can use this to keep track of which event we're listening for on the first keydown.
    var [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
    s(() => {
      if (nextTypeaheadChar !== null) {
        setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar, undefined);
        setNextTypeaheadChar(null);
      }
    }, [nextTypeaheadChar]);
    var comparatorShared = useStableCallback((safeLhs, safeRhs) => {
      var _safeRhs$toLowerCase;
      var compare;
      // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
      // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.
      safeLhs = safeLhs.normalize("NFD");
      safeRhs = safeRhs.normalize("NFD");
      if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
      return compare;
    });
    var insertingComparator = useStableCallback((lhs, rhs) => {
      if (typeof lhs === "string" && typeof rhs.text === "string") {
        return comparatorShared(lhs, rhs.text);
      }
      return lhs - rhs;
    });
    var typeaheadComparator = useStableCallback((lhs, rhs) => {
      if (typeof lhs === "string" && typeof rhs.text === "string") {
        // During typeahead, all strings longer than ours should be truncated
        // so that they're all considered equally by that point.
        return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
      }
      return lhs - rhs;
    });
    var isDisabled = useStableGetter(noTypeahead);
    var propsStable = _({
      onKeyDown: useStableCallback(e => {
        if (isDisabled()) return;
        var imeActive = getImeActive();
        var key = e.key;
        // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
        if (e.ctrlKey || e.metaKey) return;
        if (!imeActive && e.key === "Backspace") {
          // Remove the last character in a way that doesn't split UTF-16 surrogates.
          setCurrentTypeahead(t => t == null ? null : [...t].reverse().slice(1).reverse().join(""), e);
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        // The key property represents the typed character OR the "named key attribute" of the key pressed.
        // There's no definite way to tell the difference, but for all intents and purposes
        // there are no one-character names, and there are no non-ASCII-alpha names.
        // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.
        var isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);
        if (isCharacterKey) {
          var _getCurrentTypeahead;
          if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ;else {
            e.preventDefault();
            e.stopPropagation();
            // Note: Won't be true for the first keydown
            // but will be overwritten before useLayoutEffect is called
            // to actually apply the change
            if (!imeActive) setNextTypeaheadChar(key);
          }
        }
      }),
      onCompositionStart: useStableCallback(e => {
        setNextTypeaheadChar(e.data);
        setImeActive(false);
      }),
      onCompositionEnd: useStableCallback(_e => {
        setImeActive(true);
      })
    });
    // Handle changes in typeahead that cause changes to the tabbable index
    /* useEffect(() => {
         
     }, [currentTypeahead]);*/
    return {
      typeaheadNavigationChildContext: useStableObject({
        typeaheadNavigationChildParameters: useStableObject({
          insertingComparator,
          sortedTypeaheadInfo: sortedTypeaheadInfo.current
        })
      }),
      typeaheadNavigationReturn: {
        getCurrentTypeahead,
        invalidTypeahead,
        propsStable: propsStable.current
      }
    };
    function updateBasedOnTypeaheadChange(currentTypeahead, reason) {
      if (currentTypeahead && sortedTypeaheadInfo.current.length) {
        var sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);
        if (sortedTypeaheadIndex < 0) {
          // The user has typed an entry that doesn't exist in the list
          // (or more specifically "for which there is no entry that starts with that input")
          setInvalidTypeahead(true);
        } else {
          setInvalidTypeahead(false);
          /*
            We know roughly where, in the sorted array of strings, our next typeahead location is.
            But roughly isn't good enough if there are multiple matches.
            To convert our sorted index to the unsorted index we need, we have to find the first
            element that matches us *and* (if any such exist) is *after* our current selection.
                     In other words, the only way typeahead moves backwards relative to our current
            position is if the only other option is behind us.
                     It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
            Though there's also a case for just going upwards to the nearest to prevent jumpiness.
            But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
            I dunno. Going back to the start is the simplist though.
                     Basically what this does: Starting from where we found ourselves after our binary search,
            scan backwards and forwards through all adjacent entries that also compare equally so that
            we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
            (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
                     TODO: The binary search starts this off with a solid O(log n), but one-character
            searches are, thanks to pigeonhole principal, eventually guaranteed to become
            O(n*log n). This is annoying but probably not easily solvable? There could be an
            exception for one-character strings, but that's just kicking the can down
            the road. Maybe one or two characters would be good enough though.
          */
          // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.
          var lowestUnsortedIndexAll = null;
          var lowestSortedIndexAll = sortedTypeaheadIndex;
          // These two are only set for elements that are ahead of us, but the principle's the same otherwise
          var lowestUnsortedIndexNext = null;
          var lowestSortedIndexNext = sortedTypeaheadIndex;
          var updateBestFit = u => {
            var _getIndex;
            if (!isValid(u)) return;
            if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
              lowestUnsortedIndexAll = u;
              lowestSortedIndexAll = _i4;
            }
            if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > ((_getIndex = getIndex()) !== null && _getIndex !== void 0 ? _getIndex : -Infinity)) {
              lowestUnsortedIndexNext = u;
              lowestSortedIndexNext = _i4;
            }
          };
          var _i4 = sortedTypeaheadIndex;
          while (_i4 >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[_i4]) == 0) {
            updateBestFit(sortedTypeaheadInfo.current[_i4].unsortedIndex);
            --_i4;
          }
          _i4 = sortedTypeaheadIndex;
          while (_i4 < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[_i4]) == 0) {
            updateBestFit(sortedTypeaheadInfo.current[_i4].unsortedIndex);
            ++_i4;
          }
          if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex, reason, true);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex, reason, true);
        }
      }
    }
  }
  function useTypeaheadNavigationChild(_ref19) {
    var {
        managedChildParameters: {
          index
        },
        textContentParameters: {
          getText
        },
        typeaheadNavigationChildContext: {
          typeaheadNavigationChildParameters: {
            sortedTypeaheadInfo,
            insertingComparator
          }
        },
        refElementReturn: {
          getElement
        }
      } = _ref19,
      void1 = _objectWithoutProperties(_ref19.managedChildParameters, _excluded15),
      void5 = _objectWithoutProperties(_ref19.textContentParameters, _excluded16),
      void2 = _objectWithoutProperties(_ref19.typeaheadNavigationChildContext.typeaheadNavigationChildParameters, _excluded17),
      void3 = _objectWithoutProperties(_ref19.refElementReturn, _excluded18),
      void4 = _objectWithoutProperties(_ref19, _excluded19);
    var {
      textContentReturn
    } = useTextContent({
      refElementReturn: {
        getElement
      },
      textContentParameters: {
        getText,
        onTextContentChange: T$1(text => {
          if (text) {
            // Find where to insert this item.
            // Because all index values should be unique, the returned sortedIndex
            // should always refer to a new location (i.e. be negative)                
            var sortedIndex = binarySearch(sortedTypeaheadInfo, text, insertingComparator);
            console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo[sortedIndex].text, {
              unsortedIndex: index,
              text
            }) == 0);
            if (sortedIndex < 0) {
              sortedTypeaheadInfo.splice(-sortedIndex - 1, 0, {
                text,
                unsortedIndex: index
              });
            } else {
              sortedTypeaheadInfo.splice(sortedIndex, 0, {
                text,
                unsortedIndex: index
              });
            }
            return () => {
              // When unmounting, find where we were and remove ourselves.
              // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
              var sortedIndex = binarySearch(sortedTypeaheadInfo, text, insertingComparator);
              console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo[sortedIndex].text, {
                unsortedIndex: index,
                text
              }) == 0);
              if (sortedIndex >= 0) {
                sortedTypeaheadInfo.splice(sortedIndex, 1);
              }
            };
          }
        }, [])
      }
    });
    return {
      textContentReturn
    };
  }
  /**
   * Your usual binary search implementation.
   *
   * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
   * @param array The array to search through
   * @param wanted The value you'd like to find
   * @param comparator Compares `wanted` with the current value in `array`
   * @returns A non-negative value if `wanted` was found, and a negative number if not.
   * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
   */
  function binarySearch(array, wanted, comparator) {
    var firstIndex = 0;
    var lastIndex = array.length - 1;
    while (firstIndex <= lastIndex) {
      var testIndex = lastIndex + firstIndex >> 1;
      var comparisonResult = comparator(wanted, array[testIndex]);
      if (comparisonResult > 0) {
        firstIndex = testIndex + 1;
      } else if (comparisonResult < 0) {
        lastIndex = testIndex - 1;
      } else {
        return testIndex;
      }
    }
    return -firstIndex - 1;
  }

  /**
   * Implements a roving tabindex system where only one "focusable"
   * component in a set is able to receive a tab focus. *Which*
   * of those elements receives focus is determined by you, but it's
   * recommended to offload that logic then to another hook, like
   * `useLinearNavigation`, which lets you change the tabbable
   * element with the arrow keys, `useTypeaheadNavigation`, which
   * lets you change the tabbable index with typeahead, or
   * `useListNavigation` if you just want everything bundled together.
   *
   * Note that the child hook returned by this function must be used
   * by every child that uses this roving tabindex logic.  The
   * prop-modifying hook *that* hook returns should then be used
   * on the child's element, as well as any other elements you'd like
   * to be explicitly made untabbable too.
   *
   * `shouldFocusOnChange` should return true if focus is
   * contained within whatever element contains the roving tab index.
   * Generally as simple as the following:
   * ```
   * const [focusedInner, setFocusedInner] = useState(false);
   * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
   * const focusOnChange = (focusedInner != false);
   * ```
   * It's not included here because `useRovingTabIndex` doesn't know
   * anything about the container element, only children elements.
   * And just as well! Children should be allowed at the root,
   * regardless of if it's the whole app or just a given component.
   */
  function useRovingTabIndex(_ref20) {
    var {
        managedChildrenReturn: {
          getChildren
        },
        rovingTabIndexParameters: {
          untabbable,
          initiallyTabbedIndex,
          onTabbableIndexChange
        }
      } = _ref20,
      _void1 = _objectWithoutProperties(_ref20, _excluded20);
    //initiallyTabbedIndex ??= 0;
    // Override the actual setter to include some extra logic related to avoiding hidden children, 
    // what to do when we're untabbable, what to do when we're tabbable but given `null`, etc.
    var setTabbableIndex = useStableCallback((updater, reason, fromUserInteraction) => {
      var children = getChildren();
      // Notify the relevant children that they should become tabbable/untabbable,
      // but also handle focus management when we changed due to user interaction
      return setTabbableIndex3(f, reason);
      function f(prevIndex) {
        var nextIndex = typeof updater === "function" ? updater(prevIndex !== null && prevIndex !== void 0 ? prevIndex : null) : updater;
        if (untabbable) return null;
        if (prevIndex != nextIndex) {
          var nextChild = nextIndex == null ? null : children.getAt(nextIndex);
          if (nextChild !== null && nextChild !== void 0 && nextChild.hidden) {
            return prevIndex !== null && prevIndex !== void 0 ? prevIndex : untabbable ? null : 0;
          }
          if (nextChild != null && fromUserInteraction) {
            var element = nextChild.getElement();
            if (element) {
              if (document.activeElement == null || !element.contains(document.activeElement)) nextChild.focusSelf(element);
            }
          }
        }
        return nextIndex !== null && nextIndex !== void 0 ? nextIndex : untabbable ? null : 0;
      }
    }, []);
    var lastNonNullIndex = _(initiallyTabbedIndex);
    h(() => {
      var t = getTabbableIndex();
      if (t != null) lastNonNullIndex.current = t;
    });
    // Any time we switch to being untabbable, set the current tabbable index accordingly.
    h(() => {
      if (untabbable) setTabbableIndex3(null, undefined);else setTabbableIndex3(lastNonNullIndex.current, undefined);
    }, [untabbable]);
    // Boilerplate related to notifying individual children when they become tabbable/untabbable
    var getTabbableAt = T$1(m => {
      return m.getTabbable();
    }, []);
    var setTabbableAt = T$1((m, t) => {
      m.setTabbable(t);
    }, []);
    var isTabbableValid = T$1(m => {
      return !m.hidden;
    }, []);
    var {
      changeIndex: setTabbableIndex3,
      getCurrentIndex: getTabbableIndex,
      reevaluateClosestFit
    } = useChildrenFlag({
      initialIndex: initiallyTabbedIndex !== null && initiallyTabbedIndex !== void 0 ? initiallyTabbedIndex : untabbable ? null : 0,
      onIndexChange: onTabbableIndexChange,
      getChildren,
      closestFit: true,
      getAt: getTabbableAt,
      isValid: isTabbableValid,
      setAt: setTabbableAt
    });
    var focusSelf = T$1(reason => {
      var children = getChildren();
      var index = getTabbableIndex();
      if (index != null) {
        var _children$getAt, _children$getAt2, _children$getAt2$focu;
        var element = (_children$getAt = children.getAt(index)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.getElement();
        (_children$getAt2 = children.getAt(index)) === null || _children$getAt2 === void 0 ? void 0 : (_children$getAt2$focu = _children$getAt2.focusSelf) === null || _children$getAt2$focu === void 0 ? void 0 : _children$getAt2$focu.call(_children$getAt2, element);
      } else setTabbableIndex(null, reason, true);
    }, []);
    var rovingTabIndexChildContext = useStableObject({
      setTabbableIndex,
      reevaluateClosestFit
    });
    return {
      managedChildrenParameters: {
        onChildrenMountChange: reevaluateClosestFit
      },
      rovingTabIndexReturn: {
        setTabbableIndex,
        getTabbableIndex,
        focusSelf
      },
      rovingTabIndexChildContext
    };
  }
  function useRovingTabIndexChild(_ref21) {
    var {
        managedChildParameters: {
          index
        },
        rovingTabIndexChildContext: {
          reevaluateClosestFit,
          setTabbableIndex
        },
        rovingTabIndexChildParameters
      } = _ref21,
      _void2 = _objectWithoutProperties(_ref21.managedChildParameters, _excluded21);
    var {
        hidden
      } = rovingTabIndexChildParameters,
      _void1 = _objectWithoutProperties(rovingTabIndexChildParameters, _excluded22);
    var [tabbable, setTabbable, getTabbable] = useState(false);
    h(() => {
      reevaluateClosestFit();
    }, [!!hidden]);
    return {
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged: useStableCallback((focused, _prevFocused, e) => {
          if (focused) {
            setTabbableIndex(index, e, false);
          }
        })
      },
      rovingTabIndexChildReturn: {
        propsUnstable: {
          tabIndex: tabbable ? 0 : -1
        },
        tabbable,
        getTabbable,
        setTabbable
      }
    };
  }

  /**
   * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
   *
   * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
   * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any text for typeahead to focus the next item that matches.
   */
  function useListNavigation(_ref22) {
    var {
        linearNavigationParameters,
        typeaheadNavigationParameters,
        rovingTabIndexParameters,
        managedChildrenReturn
      } = _ref22,
      _void1 = _objectWithoutProperties(_ref22, _excluded23);
    var rtir = useRovingTabIndex({
      managedChildrenReturn,
      rovingTabIndexParameters
    });
    var {
      rovingTabIndexReturn
    } = rtir;
    var tnr = useTypeaheadNavigation({
      rovingTabIndexReturn,
      typeaheadNavigationParameters
    });
    var lnr = useLinearNavigation({
      rovingTabIndexReturn,
      linearNavigationParameters
    });
    return _objectSpread(_objectSpread(_objectSpread({}, lnr), tnr), rtir);
  }
  function useListNavigationChild(_ref23) {
    var {
        rovingTabIndexChildParameters,
        rovingTabIndexChildContext,
        typeaheadNavigationChildContext,
        //typeaheadNavigationChildParameters,
        managedChildParameters,
        refElementReturn,
        textContentParameters
      } = _ref23,
      _void2 = _objectWithoutProperties(_ref23, _excluded24);
    var rticr = useRovingTabIndexChild({
      rovingTabIndexChildContext,
      rovingTabIndexChildParameters,
      managedChildParameters
    });
    var {
      textContentReturn
    } = useTypeaheadNavigationChild({
      refElementReturn,
      typeaheadNavigationChildContext,
      managedChildParameters,
      textContentParameters
    });
    //    assertEmptyObject(_void5);
    return _objectSpread({
      textContentReturn
    }, rticr);
  }
  function useGridNavigation(_ref24) {
    var {
        gridNavigationParameters: {
          onTabbableColumnChange
        },
        linearNavigationParameters,
        rovingTabIndexParameters: {
          onTabbableIndexChange
        },
        managedChildrenReturn,
        typeaheadNavigationParameters
      } = _ref24,
      void3 = _objectWithoutProperties(_ref24.gridNavigationParameters, _excluded25),
      rovingTabIndexParameters = _objectWithoutProperties(_ref24.rovingTabIndexParameters, _excluded26),
      _void2 = _objectWithoutProperties(_ref24, _excluded27);
    var {
      getChildren
    } = managedChildrenReturn;
    var {
      initiallyTabbedIndex
    } = rovingTabIndexParameters;
    var [getCurrentTabbableColumn, setCurrentTabbableColumn] = usePassiveState(onTabbableColumnChange, useStableCallback(() => {
      return initiallyTabbedIndex !== null && initiallyTabbedIndex !== void 0 ? initiallyTabbedIndex : 0;
    }));
    var onTabbableIndexChangeOverride = useStableCallback((i, p, reason) => {
      var _children$getAt3, _children$getAt4;
      var children = getChildren();
      onTabbableIndexChange === null || onTabbableIndexChange === void 0 ? void 0 : onTabbableIndexChange(i, p, reason);
      if (p != null) (_children$getAt3 = children.getAt(p)) === null || _children$getAt3 === void 0 ? void 0 : _children$getAt3.setTabbableColumnIndex(null, reason, false);
      if (i != null) (_children$getAt4 = children.getAt(i)) === null || _children$getAt4 === void 0 ? void 0 : _children$getAt4.setTabbableColumnIndex(getCurrentTabbableColumn(), reason, false);
    });
    var _useListNavigation = useListNavigation({
        linearNavigationParameters: _objectSpread({
          navigationDirection: "vertical"
        }, linearNavigationParameters),
        rovingTabIndexParameters: _objectSpread({
          onTabbableIndexChange: onTabbableIndexChangeOverride
        }, rovingTabIndexParameters),
        managedChildrenReturn,
        typeaheadNavigationParameters
      }),
      {
        linearNavigationReturn,
        rovingTabIndexReturn,
        typeaheadNavigationReturn,
        managedChildrenParameters,
        rovingTabIndexChildContext,
        typeaheadNavigationChildContext
      } = _useListNavigation,
      void1 = _objectWithoutProperties(_useListNavigation, _excluded28);
    return {
      managedChildrenParameters,
      rovingTabIndexChildContext,
      typeaheadNavigationChildContext,
      linearNavigationReturn,
      rovingTabIndexReturn,
      typeaheadNavigationReturn,
      gridNavigationRowContext: useStableObject({
        gridNavigationRowParameters: useStableObject({
          setTabbableRow: rovingTabIndexReturn.setTabbableIndex,
          getCurrentTabbableColumn,
          setCurrentTabbableColumn
        })
      })
    };
  }
  function useGridNavigationRow(_ref25) {
    var {
        asChildRowParameters: {
          gridNavigationRowContext: {
            gridNavigationRowParameters: {
              setTabbableRow,
              getCurrentTabbableColumn,
              setCurrentTabbableColumn
            }
          }
        },
        asParentRowParameters: {
          linearNavigationParameters
        }
      } = _ref25,
      asChildRowOfTable = _objectWithoutProperties(_ref25.asChildRowParameters, _excluded29),
      asParentRowOfCellsP = _objectWithoutProperties(_ref25.asParentRowParameters, _excluded30),
      _void1 = _objectWithoutProperties(_ref25, _excluded31);
    var {
      managedChildrenReturn: {
        getChildren
      }
    } = asChildRowOfTable;
    var getIndex = useStableCallback(() => {
      return asChildRowOfTable.managedChildParameters.index;
    });
    var focusSelf = useStableCallback(e => {
      var _getCurrentTabbableCo;
      var index = (_getCurrentTabbableCo = getCurrentTabbableColumn()) !== null && _getCurrentTabbableCo !== void 0 ? _getCurrentTabbableCo : 0;
      var child = getChildren().getAt(index);
      while (!child && index > 0) {
        --index;
        child = getChildren().getAt(index);
      }
      if (child) {
        var _e2 = child.getElement();
        child.focusSelf(_e2);
      } else {
        var _e$focus;
        e === null || e === void 0 ? void 0 : (_e$focus = e.focus) === null || _e$focus === void 0 ? void 0 : _e$focus.call(e);
      }
    }, []);
    var lncr = useListNavigationChild(asChildRowOfTable);
    var lnr = useListNavigation(_objectSpread(_objectSpread({}, asParentRowOfCellsP), {}, {
      linearNavigationParameters: _objectSpread({
        navigationDirection: "horizontal"
      }, linearNavigationParameters)
    }));
    var {
      rovingTabIndexReturn: {
        setTabbableIndex
      },
      rovingTabIndexReturn,
      linearNavigationReturn,
      managedChildrenParameters,
      rovingTabIndexChildContext,
      typeaheadNavigationChildContext,
      typeaheadNavigationReturn
    } = lnr;
    return {
      asChildRowReturn: _objectSpread({
        gridNavigationRowParameters: {
          focusSelf,
          setTabbableColumnIndex: setTabbableIndex
        }
      }, lncr),
      asParentRowReturn: _objectSpread(_objectSpread({}, lnr), {}, {
        gridNavigationCellContext: useStableObject({
          gridNavigationCellParameters: useStableObject({
            setTabbableRow,
            getRowIndex: getIndex,
            getCurrentTabbableColumn,
            setCurrentTabbableColumn,
            setTabbableCell: setTabbableIndex
          })
        }),
        linearNavigationReturn,
        managedChildrenParameters,
        rovingTabIndexChildContext,
        rovingTabIndexReturn,
        typeaheadNavigationChildContext,
        typeaheadNavigationReturn
      })
    };
  }
  function useGridNavigationCell(_ref26) {
    var {
        //    managedChildParameters: { hidden, index, ...void3 },
        rovingTabIndexChildContext,
        typeaheadNavigationChildContext,
        //typeaheadNavigationChildParameters,
        rovingTabIndexChildParameters,
        managedChildParameters,
        refElementReturn,
        textContentParameters,
        gridNavigationCellParameters: {
          colSpan
        },
        gridNavigationCellContext: {
          gridNavigationCellParameters: {
            getRowIndex,
            setTabbableRow,
            getCurrentTabbableColumn: _getCurrentColumn,
            setCurrentTabbableColumn,
            setTabbableCell
          }
        }
      } = _ref26,
      _void1 = _objectWithoutProperties(_ref26, _excluded32);
    var {
      index
    } = managedChildParameters;
    var _useListNavigationChi = useListNavigationChild({
        rovingTabIndexChildParameters,
        managedChildParameters,
        rovingTabIndexChildContext,
        typeaheadNavigationChildContext,
        textContentParameters,
        //typeaheadNavigationChildParameters,
        refElementReturn
      }),
      {
        hasCurrentFocusParameters: {
          onCurrentFocusedInnerChanged: ocfic1
        },
        rovingTabIndexChildReturn,
        textContentReturn
      } = _useListNavigationChi,
      void2 = _objectWithoutProperties(_useListNavigationChi, _excluded33);
    //    assertEmptyObject(void3);
    return {
      rovingTabIndexChildReturn,
      textContentReturn,
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged: useStableCallback((focused, prev, e) => {
          ocfic1 === null || ocfic1 === void 0 ? void 0 : ocfic1(focused, prev, e);
          if (focused) {
            setTabbableRow(getRowIndex(), e, false);
            setCurrentTabbableColumn(index, e);
            setTabbableCell(prev => {
              if (prev != null && (prev < index || prev > index + colSpan)) {
                return prev;
              }
              return index;
            }, e, false);
          }
        })
      }
    };
  }

  //export type UseSingleSelectionChild<E extends Element> = (a: UseSingleSelectionChildParameters<E>) => UseSingleSelectionChildReturnTypeWithHooks<E>;
  function useSingleSelection(_ref27) {
    var {
      managedChildrenReturn: {
        getChildren
      },
      rovingTabIndexReturn: {
        setTabbableIndex
      },
      singleSelectionParameters: {
        setSelectedIndex: setSelectedIndexExternal,
        initiallySelectedIndex
      }
    } = _ref27;
    useEnsureStability("useSingleSelection", setSelectedIndexExternal);
    var getSelectedAt = T$1(m => {
      return m.getSelected();
    }, []);
    var setSelectedAt = T$1((m, t) => {
      if (m.hidden) {
        console.assert(false);
      }
      m.setLocalSelected(t);
    }, []);
    var isSelectedValid = T$1(m => {
      return !m.hidden;
    }, []);
    var {
      changeIndex: setSelectedIndexInternal,
      getCurrentIndex: getSelectedIndex
    } = useChildrenFlag({
      getChildren,
      onIndexChange: null,
      initialIndex: initiallySelectedIndex,
      getAt: getSelectedAt,
      setAt: setSelectedAt,
      isValid: isSelectedValid,
      closestFit: false
    });
    return {
      singleSelectionReturn: useStableObject({
        getSelectedIndex,
        setSelectedIndex: setSelectedIndexInternal
      }),
      singleSelectionContext: useStableObject({
        getSelectedIndex,
        setSelectedIndex: setSelectedIndexExternal
      }),
      childrenHaveFocusParameters: {
        onCompositeFocusChange: useStableCallback((anyFocused, prev, reason) => {
          if (!anyFocused) {
            var selectedIndex = getSelectedIndex();
            if (selectedIndex != null) setTabbableIndex(selectedIndex, reason, false);
          }
        })
      }
    };
  }
  function useSingleSelectionChild(args) {
    var {
      singleSelectionContext: {
        getSelectedIndex,
        setSelectedIndex: setSelectedIndexExternal
      },
      singleSelectionChildParameters: {
        ariaPropName,
        selectionMode,
        disabled
      },
      managedChildParameters: {
        index
      }
    } = args;
    useEnsureStability("useSingleSelectionChild", getSelectedIndex, setSelectedIndexExternal);
    var getDisabled = useStableGetter(disabled);
    var [selected, setSelected, getSelected] = useState(getSelectedIndex() == index);
    // const getIndex = useStableGetter(index);
    var onCurrentFocusedInnerChanged = useStableCallback((focused, _prev, e) => {
      if (selectionMode == 'focus' && focused) {
        setSelectedIndexExternal === null || setSelectedIndexExternal === void 0 ? void 0 : setSelectedIndexExternal(index, e);
      }
    });
    var onPressSync = useStableCallback(e => {
      if (!disabled) setSelectedIndexExternal === null || setSelectedIndexExternal === void 0 ? void 0 : setSelectedIndexExternal(index, e);
    });
    return {
      //managedChildParameters: { selected, setSelected, getSelected, },
      managedChildParameters: {
        setLocalSelected: setSelected
      },
      singleSelectionChildReturn: {
        selected,
        setThisOneSelected: useStableCallback(event => {
          console.assert(!getDisabled());
          setSelectedIndexExternal === null || setSelectedIndexExternal === void 0 ? void 0 : setSelectedIndexExternal(index, event);
        }),
        getSelected,
        propsUnstable: ariaPropName == null ? {} : {
          [ariaPropName]: (selected !== null && selected !== void 0 ? selected : false).toString()
        }
      },
      pressParameters: {
        onPressSync
      },
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged
      }
    };
  }
  /**
   * Let's face it, declarative is nicer to use than imperative, so this is a shortcut.
   */
  function useSingleSelectionDeclarative(_ref28) {
    var {
      singleSelectionReturn: {
        setSelectedIndex: setSelectedIndexInternal
      },
      singleSelectionDeclarativeParameters: {
        selectedIndex
      }
    } = _ref28;
    h(() => {
      setSelectedIndexInternal(selectedIndex);
    }, [selectedIndex]);
  }
  function useGridNavigationSingleSelection(_ref29) {
    var {
        gridNavigationParameters,
        linearNavigationParameters,
        rovingTabIndexParameters,
        managedChildrenReturn,
        typeaheadNavigationParameters,
        singleSelectionParameters
      } = _ref29,
      _void2 = _objectWithoutProperties(_ref29, _excluded34);
    var gnr = useGridNavigation({
      gridNavigationParameters,
      linearNavigationParameters,
      managedChildrenReturn,
      rovingTabIndexParameters,
      typeaheadNavigationParameters
    });
    var {
      rovingTabIndexReturn
    } = gnr;
    var ssr = useSingleSelection({
      managedChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionParameters
    });
    return _objectSpread(_objectSpread({}, gnr), ssr);
  }
  function useGridNavigationSingleSelectionRow(_ref30) {
    var {
        asChildRowParameters,
        asParentRowParameters
      } = _ref30,
      _void1 = _objectWithoutProperties(_ref30, _excluded35);
    var _useSingleSelectionCh = useSingleSelectionChild(asChildRowParameters),
      {
        managedChildParameters,
        hasCurrentFocusParameters: {
          onCurrentFocusedInnerChanged: ocfic2
        },
        pressParameters,
        singleSelectionChildReturn
      } = _useSingleSelectionCh,
      _void3 = _objectWithoutProperties(_useSingleSelectionCh.hasCurrentFocusParameters, _excluded36);
    var _useGridNavigationRow = useGridNavigationRow({
        asChildRowParameters,
        asParentRowParameters
      }),
      {
        asChildRowReturn: {
          hasCurrentFocusParameters: {
            onCurrentFocusedInnerChanged: ocfic1
          },
          gridNavigationRowParameters,
          rovingTabIndexChildReturn,
          textContentReturn
        },
        asParentRowReturn
      } = _useGridNavigationRow,
      _void2 = _objectWithoutProperties(_useGridNavigationRow.asChildRowReturn.hasCurrentFocusParameters, _excluded38),
      void4 = _objectWithoutProperties(_useGridNavigationRow.asChildRowReturn, _excluded37);
    var onCurrentFocusedInnerChanged = useStableCallback((focused, prevFocused, e) => {
      ocfic1 === null || ocfic1 === void 0 ? void 0 : ocfic1(focused, prevFocused, e);
      ocfic2 === null || ocfic2 === void 0 ? void 0 : ocfic2(focused, prevFocused, e);
    });
    return {
      asChildRowReturn: {
        textContentReturn,
        managedChildParameters,
        hasCurrentFocusParameters: {
          onCurrentFocusedInnerChanged
        },
        gridNavigationRowParameters,
        pressParameters,
        rovingTabIndexChildReturn,
        singleSelectionChildReturn
      },
      asParentRowReturn
    };
  }
  // EZ
  function useGridNavigationSingleSelectionCell(p) {
    return useGridNavigationCell(p);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
      length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeFloor = Math.floor,
    nativeRandom = Math.random;

  /**
   * The base implementation of `_.random` without support for returning
   * floating-point numbers.
   *
   * @private
   * @param {number} lower The lower bound.
   * @param {number} upper The upper bound.
   * @returns {number} Returns the random number.
   */
  function baseRandom(lower, upper) {
    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
  }

  /**
   * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
   *
   * @private
   * @param {Array} array The array to shuffle.
   * @param {number} [size=array.length] The size of `array`.
   * @returns {Array} Returns `array`.
   */
  function shuffleSelf(array, size) {
    var index = -1,
      length = array.length,
      lastIndex = length - 1;
    size = size === undefined ? length : size;
    while (++index < size) {
      var rand = baseRandom(index, lastIndex),
        value = array[rand];
      array[rand] = array[index];
      array[index] = value;
    }
    array.length = size;
    return array;
  }

  /**
   * A specialized version of `_.shuffle` for arrays.
   *
   * @private
   * @param {Array} array The array to shuffle.
   * @returns {Array} Returns the new shuffled array.
   */
  function arrayShuffle(array) {
    return shuffleSelf(copyArray(array));
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function (key) {
      return object[key];
    });
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
      result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Built-in value references. */
  var Symbol$1 = root.Symbol;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$5.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$4.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$1;
  }

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function () {
    return arguments;
  }()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /** Detect free variable `exports`. */
  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

  /** Built-in value references. */
  var Buffer = moduleExports$1 ? root.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag$1 = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = function () {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;
      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }();

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && (
      // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' ||
      // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == 'offset' || key == 'parent') ||
      // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
      // Skip index properties.
      isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$1;
    return value === proto;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = overArg(Object.keys, Object);

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */
  function values(object) {
    return object == null ? [] : baseValues(object, keys(object));
  }

  /**
   * The base implementation of `_.shuffle`.
   *
   * @private
   * @param {Array|Object} collection The collection to shuffle.
   * @returns {Array} Returns the new shuffled array.
   */
  function baseShuffle(collection) {
    return shuffleSelf(values(collection));
  }

  /**
   * Creates an array of shuffled values, using a version of the
   * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to shuffle.
   * @returns {Array} Returns the new shuffled array.
   * @example
   *
   * _.shuffle([1, 2, 3, 4]);
   * // => [4, 1, 3, 2]
   */
  function shuffle(collection) {
    var func = isArray(collection) ? arrayShuffle : baseShuffle;
    return func(collection);
  }

  /**
   * Returns a function that will, when called, force the component
   * that uses this hook to re-render itself.
   *
   * It's a bit smelly, so best to use sparingly.
   */
  function useForceUpdate() {
    var [, set] = p(0);
    return _(() => set(i => ++i)).current;
  }

  /**
   * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
   *
   * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
   *
   * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
   * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
   * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
   *
   * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
   * sort all children according to their value from the `getValue` argument you pass in.
   *
   * If you want to perform some re-ordering operation that's *not* a sort, you can manually
   * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
   * sorted and unsorted index positions.
   *
   * Again, unlike some other hooks, **these children must be direct descendants**. This is because
   * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
   * Because keys are given special treatment and a child has no way of modifying its own key
   * there's no other time or place this can happen other than exactly within the parent component's render function.
   */
  function useRearrangeableChildren(_ref31) {
    var {
      rearrangeableChildrenParameters: {
        getIndex
      }
    } = _ref31;
    // These are used to keep track of a mapping between unsorted index <---> sorted index.
    // These are needed for navigation with the arrow keys.
    var mangleMap = _(new Map());
    var demangleMap = _(new Map());
    var indexMangler = T$1(n => {
      var _mangleMap$current$ge;
      return (_mangleMap$current$ge = mangleMap.current.get(n)) !== null && _mangleMap$current$ge !== void 0 ? _mangleMap$current$ge : n;
    }, []);
    var indexDemangler = T$1(n => {
      var _demangleMap$current$;
      return (_demangleMap$current$ = demangleMap.current.get(n)) !== null && _demangleMap$current$ !== void 0 ? _demangleMap$current$ : n;
    }, []);
    //const { setTabbableIndex } = rovingTabIndexReturn;
    var shuffle$1 = T$1(managedRows => {
      var shuffledRows = shuffle(managedRows.arraySlice());
      return rearrange(shuffledRows);
    }, [/* Must remain stable */]);
    // The sort function needs to be able to update whoever has all the sortable children.
    // Because that might not be the consumer of *this* hook directly (e.g. a table uses
    // this hook, but it's tbody that actually needs updating), we need to remotely
    // get and set a forceUpdate function.
    //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);
    var [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
    var rearrange = T$1(sortedRows => {
      var _getForceUpdate;
      mangleMap.current.clear();
      demangleMap.current.clear();
      // Update our sorted <--> unsorted indices map 
      // and rerender the whole table, basically
      for (var indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
        var indexAsUnsorted = sortedRows[indexAsSorted].index;
        mangleMap.current.set(indexAsUnsorted, indexAsSorted);
        demangleMap.current.set(indexAsSorted, indexAsUnsorted);
      }
      (_getForceUpdate = getForceUpdate()) === null || _getForceUpdate === void 0 ? void 0 : _getForceUpdate();
    }, []);
    var useRearrangeableProps = T$1(_ref32 => {
      var {
          children
        } = _ref32,
        props = _objectWithoutProperties(_ref32, _excluded39);
      console.assert(Array.isArray(children));
      var forceUpdate = useForceUpdate();
      s(() => {
        setForceUpdate(_prev => forceUpdate);
      }, [forceUpdate]);
      return useMergedProps({
        children: children.slice().map(child => ({
          child,
          mangledIndex: indexMangler(getIndex(child)),
          demangledIndex: getIndex(child)
        })).sort((lhs, rhs) => {
          return lhs.mangledIndex - rhs.mangledIndex;
        }).map(_ref33 => {
          var {
            child,
            mangledIndex,
            demangledIndex
          } = _ref33;
          return h$1(child.type, _objectSpread(_objectSpread({}, child.props), {}, {
            key: demangledIndex,
            "data-mangled-index": mangledIndex,
            "data-unmangled-index": demangledIndex
          }));
        })
      }, props);
    }, []);
    return {
      //linearNavigationParameters: { navigateAbsolute, navigateRelative },
      rearrangeableChildrenReturn: {
        indexMangler,
        indexDemangler,
        mangleMap,
        demangleMap,
        rearrange,
        shuffle: shuffle$1,
        useRearrangeableProps
      }
    };
  }
  /**
   * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
   *
   * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
   *
   * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
   * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
   * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
   *
   * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
   * sort all children according to their value from the `getValue` argument you pass in.
   *
   * If you want to perform some re-ordering operation that's *not* a sort, you can manually
   * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
   * sorted and unsorted index positions.
   *
   * Again, unlike some other hooks, **these children must be direct descendants**. This is because
   * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
   * Because keys are given special treatment and a child has no way of modifying its own key
   * there's no other time or place this can happen other than exactly within the parent component's render function.
   */
  function useSortableChildren(_ref34) {
    var {
      rearrangeableChildrenParameters,
      sortableChildrenParameters: {
        compare: userCompare
      }
    } = _ref34;
    var getCompare = useStableGetter(userCompare !== null && userCompare !== void 0 ? userCompare : defaultCompare);
    var {
      rearrangeableChildrenReturn
    } = useRearrangeableChildren({
      rearrangeableChildrenParameters
    });
    var {
      rearrange
    } = rearrangeableChildrenReturn;
    // The actual sort function.
    var sort = T$1((managedRows, direction) => {
      var compare = getCompare();
      var sortedRows = compare ? managedRows.arraySlice().sort((lhsRow, rhsRow) => {
        var lhsValue = lhsRow;
        var rhsValue = rhsRow;
        var result = compare(lhsValue, rhsValue);
        if (direction[0] == "d") return -result;
        return result;
      }) : managedRows.arraySlice();
      return rearrange(sortedRows);
    }, [/* Must remain stable */]);
    return {
      sortableChildrenReturn: {
        sort
      },
      rearrangeableChildrenReturn
    };
  }
  /*export interface UseGroupedSortableChildrenParameters<M extends GroupedSortedChildInfo> {
      managedChildrenReturn: UseManagedChildrenReturnType<M>["managedChildrenReturn"]
  }
   export interface UseGroupedSortableChildren {
      linearNavigationParameters: Pick<UseLinearNavigationParameters["linearNavigationParameters"], "indexDemangler" | "indexMangler">
  }*/
  /**
   * It's common enough to have, e.g., a list with multiple sortable groups, a table where the body is sorted independently of the head, etc...
   *
   * A sortable group assumes that the parent (which also calls this hook) handles list navigation (or similar),
   * and that each group element (which can also be the list parent, if there are NO groups) handles sorting (or similar).
   */
  /*export function useGroupedSortableChildren<M extends GroupedSortedChildInfo>({ managedChildrenReturn: { getChildren } }: UseGroupedSortableChildrenParameters<M>): UseGroupedSortableChildren {
      const allIndexManglers = useRef<Map<number, (i: number) => number>>(new Map());
      const allIndexDemanglers = useRef<Map<number, (i: number) => number>>(new Map());
      const indexMangler = useCallback((i: number): number => {
          const child = getChildren().getAt(i);
          if (child) {
              let indexManglerForThisLocation = allIndexManglers.current.get(child.locationIndex);
              return (indexManglerForThisLocation ?? identity)(i);
          }
          return identity(i);
      }, []);
      const indexDemangler = useCallback((i: number): number => {
          const child = getChildren().getAt(i);
          if (child) {
              let indexDemanglerForThisLocation = allIndexDemanglers.current.get(child.locationIndex);
              return (indexDemanglerForThisLocation ?? identity)(i);
          }
          return identity(i);
      }, []);
        return {
          linearNavigationParameters: {
              indexMangler,
              indexDemangler
          }
      }
  }*/
  function defaultCompare(lhs, rhs) {
    return compare1(lhs === null || lhs === void 0 ? void 0 : lhs.getSortValue(), rhs === null || rhs === void 0 ? void 0 : rhs.getSortValue());
    function compare1(lhs, rhs) {
      if (lhs == null || rhs == null) {
        if (lhs == null) return -1;
        if (rhs == null) return 1;
      }
      return lhs - rhs;
    }
  }
  function useGridNavigationSingleSelectionSortable(_ref35) {
    var {
        rearrangeableChildrenParameters,
        sortableChildrenParameters,
        linearNavigationParameters
      } = _ref35,
      gridNavigationSingleSelectionParameters = _objectWithoutProperties(_ref35, _excluded40);
    var _useSortableChildren = useSortableChildren({
        rearrangeableChildrenParameters,
        sortableChildrenParameters
      }),
      scr = _extends({}, (_objectDestructuringEmpty(_useSortableChildren), _useSortableChildren));
    var {
      rearrangeableChildrenReturn: {
        indexDemangler,
        indexMangler
      }
    } = scr;
    var gnr = useGridNavigationSingleSelection(_objectSpread({
      linearNavigationParameters: _objectSpread({
        indexDemangler,
        indexMangler
      }, linearNavigationParameters)
    }, gridNavigationSingleSelectionParameters));
    return _objectSpread(_objectSpread({}, gnr), scr);
  }
  function useListNavigationSingleSelection(_ref36) {
    var {
        linearNavigationParameters,
        rovingTabIndexParameters,
        typeaheadNavigationParameters,
        singleSelectionParameters,
        managedChildrenReturn
      } = _ref36,
      _void3 = _objectWithoutProperties(_ref36, _excluded41);
    var lnr = useListNavigation({
      linearNavigationParameters,
      rovingTabIndexParameters,
      typeaheadNavigationParameters,
      managedChildrenReturn
    });
    var {
      rovingTabIndexReturn
    } = lnr;
    var ssr = useSingleSelection({
      rovingTabIndexReturn,
      managedChildrenReturn,
      singleSelectionParameters
    });
    return _objectSpread(_objectSpread({}, ssr), lnr);
  }
  function useListNavigationSingleSelectionChild(_ref37) {
    var {
        managedChildParameters: {
          index
        },
        rovingTabIndexChildParameters: {
          hidden
        },
        singleSelectionChildParameters,
        singleSelectionContext,
        rovingTabIndexChildContext,
        typeaheadNavigationChildContext,
        refElementReturn,
        textContentParameters
      } = _ref37,
      _void5 = _objectWithoutProperties(_ref37.managedChildParameters, _excluded42),
      void7 = _objectWithoutProperties(_ref37.rovingTabIndexChildParameters, _excluded43),
      _void1 = _objectWithoutProperties(_ref37, _excluded44);
    var _useSingleSelectionCh2 = useSingleSelectionChild({
        managedChildParameters: {
          index
        },
        singleSelectionChildParameters,
        singleSelectionContext
      }),
      {
        hasCurrentFocusParameters: {
          onCurrentFocusedInnerChanged: ocfic2
        }
      } = _useSingleSelectionCh2,
      _void3 = _objectWithoutProperties(_useSingleSelectionCh2.hasCurrentFocusParameters, _excluded46),
      sscr = _objectWithoutProperties(_useSingleSelectionCh2, _excluded45);
    var _useListNavigationChi2 = useListNavigationChild({
        managedChildParameters: {
          index
        },
        rovingTabIndexChildParameters: {
          hidden
        },
        rovingTabIndexChildContext,
        typeaheadNavigationChildContext,
        refElementReturn,
        textContentParameters
      }),
      {
        hasCurrentFocusParameters: {
          onCurrentFocusedInnerChanged: ocfic1
        }
      } = _useListNavigationChi2,
      _void6 = _objectWithoutProperties(_useListNavigationChi2.hasCurrentFocusParameters, _excluded48),
      lncr = _objectWithoutProperties(_useListNavigationChi2, _excluded47);
    return _objectSpread(_objectSpread({
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged: useStableCallback((focused, previouslyFocused, e) => {
          ocfic1 === null || ocfic1 === void 0 ? void 0 : ocfic1(focused, previouslyFocused, e);
          ocfic2 === null || ocfic2 === void 0 ? void 0 : ocfic2(focused, previouslyFocused, e);
        })
      }
    }, sscr), lncr);
  }

  /**
   * Allows a composite component (such as a radio group or listbox) to listen
   * for an "overall focusin/out" event; this hook lets you know when focus has
   * moved in/out of this grouping of children EVEN IF there is no actual parent DOM element.
   *
   * I.E. you can use this without needing a parent `<div>` to listen for a `focusout` event.
   */
  function useChildrenHaveFocus(args) {
    var {
      childrenHaveFocusParameters: {
        onCompositeFocusChange
      }
    } = args;
    var [getAnyFocused, setAnyFocused] = usePassiveState(onCompositeFocusChange, returnFalse, runImmediately);
    var [_getFocusCount, setFocusCount] = usePassiveState(useStableCallback((anyFocused, anyPreviouslyFocused, e) => {
      console.assert(anyFocused >= 0 && anyFocused <= 1);
      setAnyFocused(!!(anyFocused && !anyPreviouslyFocused), e);
    }));
    return {
      childrenHaveFocusReturn: {
        getAnyFocused
      },
      childrenHaveFocusChildContext: useStableObject({
        childrenHaveFocusChildParameters: useStableObject({
          setFocusCount
        })
      })
    };
  }
  function useChildrenHaveFocusChild(_ref38) {
    var {
      childrenHaveFocusChildContext: {
        childrenHaveFocusChildParameters: {
          setFocusCount
        }
      }
    } = _ref38;
    return {
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged: useStableCallback((focused, prev, e) => {
          if (focused) {
            setFocusCount(p => (p !== null && p !== void 0 ? p : 0) + 1, e);
          } else if (!focused && prev) {
            setFocusCount(p => (p !== null && p !== void 0 ? p : 0) - 1, e);
          }
        })
      }
    };
  }
  function useHasCurrentFocus(args) {
    var {
      hasCurrentFocusParameters: {
        onCurrentFocusedChanged: onFocusedChanged,
        onCurrentFocusedInnerChanged: onFocusedInnerChanged
      },
      refElementReturn: {
        getElement
      }
    } = args;
    useEnsureStability("useHasCurrentFocus", onFocusedChanged, onFocusedInnerChanged, getElement);
    var [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse);
    var [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse);
    var onFocusIn = T$1(e => {
      setFocusedInner(true, e);
      setFocused(e.target == getElement(), e);
    }, []);
    var onFocusOut = T$1(e => {
      if (e.target == getElement()) {
        setFocusedInner(false, e);
        setFocused(false, e);
      }
    }, []);
    var propsStable = _({
      onfocusin: onFocusIn,
      onfocusout: onFocusOut
    });
    return {
      hasCurrentFocusReturn: {
        propsStable: propsStable.current,
        getCurrentFocused: getFocused,
        getCurrentFocusedInner: getFocusedInner
      }
    };
  }

  /**
   * Adds the necessary event handlers to create a "press"-like event for
   * any element, whether it's a native <BUTTON> or regular <DIV>.
   *
   * Notably, the following cases are covered:
   * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
   * * Double-clicks won't select text.
   * * Conversely, manually selecting text won't invoke a press.
   * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
   * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
   *
   * In addition, when the CSS `:active` pseudo-class would apply to a normal button
   * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
   * is added to the props.  You can either let it pass through and style it through new CSS,
   * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
   *
   * @param onClickSync
   * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
   */
  function usePress(args) {
    var {
      refElementReturn: {
        getElement
      },
      pressParameters: {
        exclude,
        focusSelf,
        onPressSync
      }
    } = args;
    //const stableOnPseudoActiveStart = useStableCallback(onPseudoActiveStart ?? (() => { }));
    //const stableOnPseudoActiveStop = useStableCallback(onPseudoActiveStop ?? (() => { }));
    // A button can be activated in multiple ways, so on the off chance
    // that multiple are triggered at once, we only *actually* register
    // a press once all of our "on" signals have turned back to "off".
    // We approximate this by just incrementing when active, and
    // decrementing when deactivated.
    //
    // As an emergency failsafe, when the element loses focus,
    // this is reset back to 0.
    var [activeDuringRender, setActive, getActive] = useState(0);
    var forceUpdate = useForceUpdate();
    //const { getElement } = refElementReturn;
    // If we the current text selection changes to include this element
    // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
    // because its only purpose was selecting text, not clicking buttons.
    //
    // To catch this, any time the text selection includes us while in the middle
    // of a click, this flag is set, which cancels the activation of a press.
    // The flag is reset any time the selection is empty or the button is
    // no longer active.
    var [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
    var pseudoActive = activeDuringRender && textSelectedDuringActivationStartTime == null;
    //useEffect(() => { if (pseudoActive) { stableOnPseudoActiveStart(); } else { stableOnPseudoActiveStop(); } return () => { if (pseudoActive) stableOnPseudoActiveStop(); } }, [pseudoActive])
    useGlobalHandler(document, "selectionchange", _ => {
      setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
    });
    h(() => {
      if (activeDuringRender == 0) setTextSelectedDuringActivationStartTime(null);
    }, [activeDuringRender == 0]);
    var onActiveStart = useStableCallback(_ => {
      setActive(a => ++a);
    });
    var onActiveStop = useStableCallback(e => {
      setActive(a => Math.max(0, --a));
      var currentTime = new Date();
      var timeDifference = textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime;
      var charactersSelected = nodeSelectedTextLength(getElement());
      // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
      // then this isn't a press event.
      // TODO: This should measure glyphs instead of characters.
      if (charactersSelected > 1 || (timeDifference !== null && timeDifference !== void 0 ? timeDifference : 0) > 250 && charactersSelected >= 1) {
        e.preventDefault();
        return;
      }
      var active = getActive(); // We query if we're active *after* calling setState because we count a press iff we're now at 0.
      if (active <= 0) {
        handlePress(e);
        forceUpdate(); // TODO: Remove when issue resolved https://github.com/preactjs/preact/issues/3731
      }
    });

    var handlePress = useStableCallback(e => {
      if (onPressSync) {
        // Note: The element is focused here because of iOS Safari.
        //
        // It's always iOS Safari.
        //
        // iOS Safari (tested on 12) downright refuses to allow 
        // elements to be manually focused UNLESS it happens within
        // an event handler like this.  It also doesn't focus
        // buttons by default when clicked, tapped, etc.
        //
        // If it becomes problematic that button-likes explicitly become
        // focused when they are pressed, then an alternative solution for
        // the question of "how do menu buttons keep their menus open"
        // and other focus-related nonsense needs to be figured out.
        //
        // For iOS Safari.
        //
        var element = getElement();
        if (element && "focus" in element) focusSelf(element);
        //(element as EventTarget as HTMLElement | null)?.focus();
        // Whatever the browser was going to do with this event,
        // forget it. We're turning it into a "press" event.
        e.preventDefault();
        // Also stop anyone else from listening to this event,
        // since we're explicitly handling it.
        // (Notably, this allows labels to wrap inputs, with them
        // both having press event handlers, without double-firing)
        e.stopPropagation();
        // Haptic feedback for this press event
        try {
          // The default implementation doesn't throw,
          // but we should guard against user implementations that could.
          pulse();
        } finally {
          // Actually call our handler.
          onPressSync(e);
        }
      }
    });
    var onMouseDown = useStableCallback(e => {
      if (onPressSync && !excludes("click", exclude)) {
        // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
        // but also don't prevent the user from selecting that text manually if they really want to
        // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
        if (e.detail > 1) {
          e.preventDefault();
        }
        if (e.button === 0) {
          onActiveStart(e);
        }
      }
    });
    var onMouseUp = useStableCallback(e => {
      if (onPressSync && !excludes("click", exclude)) {
        if (e.button === 0 && getActive() > 0) {
          onActiveStop(e);
        }
      }
    });
    var onMouseLeave = useStableCallback(() => {
      if (onPressSync && !excludes("click", exclude)) {
        setActive(0);
      }
    });
    var onKeyDown = useStableCallback(e => {
      if (onPressSync) {
        if (e.key == " " && !excludes("space", exclude)) {
          // We don't actually activate it on a space keydown
          // but we do preventDefault to stop the page from scrolling.
          onActiveStart(e);
          e.preventDefault();
        }
        if (e.key == "Enter" && !excludes("enter", exclude)) {
          e.preventDefault();
          onActiveStart(e);
          onActiveStop(e);
        }
      }
    });
    var onKeyUp = useStableCallback(e => {
      if (onPressSync && e.key == " " && !excludes("space", exclude)) onActiveStop(e);
    });
    var onClick = useStableCallback(e => {
      if (onPressSync) {
        e.preventDefault();
        if (e.detail > 1) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
      }
    });
    var onFocusOut = useStableCallback(_e => {
      setActive(0);
    });
    var propsStable2 = _({
      onKeyDown,
      onKeyUp,
      onMouseDown,
      onMouseUp,
      onMouseLeave,
      onClick,
      onfocusout: onFocusOut
    });
    return {
      pressReturn: {
        pseudoActive: pseudoActive || false,
        propsStable: propsStable2.current
        /*propsUnstable: {
            style: (textSelectedDuringActivationStartTime != null) ? { cursor: "text" } : undefined,
            ...{ "data-pseudo-active": pseudoActive ? "true" : undefined } as {}
        },*/
      }
    };
  }
  /**
   * selection.containsNode doesn't account for selection.isCollapsed,
   * so here's a workaround for that.
   *
   * We also only look for the selection end to only catch the
   * essense of a non-existant "selectionstop" event.
   *
   * @param element
   * @returns
   */
  function nodeSelectedTextLength(element) {
    if (element && element instanceof Node) {
      var selection = window.getSelection();
      for (var _i5 = 0; _i5 < ((_selection$rangeCount = selection === null || selection === void 0 ? void 0 : selection.rangeCount) !== null && _selection$rangeCount !== void 0 ? _selection$rangeCount : 0); ++_i5) {
        var _selection$rangeCount;
        var range = selection.getRangeAt(_i5);
        if (element.contains(range.endContainer) && !(selection !== null && selection !== void 0 && selection.isCollapsed)) {
          return selection.toString().length;
        }
      }
    }
    return 0;
  }
  var pulse = "vibrate" in navigator && navigator.vibrate instanceof Function ? () => navigator.vibrate(10) : () => {};
  function excludes(target, exclude) {
    if (exclude === false) return false;
    if (exclude === true || exclude !== null && exclude !== void 0 && exclude[target]) return true;
    return false;
  }
  function useCompleteGridNavigation(_ref39) {
    var {
      gridNavigationParameters,
      linearNavigationParameters,
      rovingTabIndexParameters,
      singleSelectionParameters,
      typeaheadNavigationParameters,
      sortableChildrenParameters,
      rearrangeableChildrenParameters
    } = _ref39;
    var getChildren = T$1(() => managedChildrenReturn.getChildren(), []);
    var getHighestChildIndex = T$1(() => getChildren().getHighestIndex(), []);
    var isValid = useStableCallback(index => {
      var _getChildren$getAt;
      return !((_getChildren$getAt = getChildren().getAt(index)) !== null && _getChildren$getAt !== void 0 && _getChildren$getAt.hidden);
    });
    var _useGridNavigationSin = useGridNavigationSingleSelectionSortable({
        gridNavigationParameters,
        linearNavigationParameters: _objectSpread({
          getHighestIndex: getHighestChildIndex,
          isValid
        }, linearNavigationParameters),
        managedChildrenReturn: {
          getChildren
        },
        rovingTabIndexParameters: _objectSpread({
          initiallyTabbedIndex: singleSelectionParameters.initiallySelectedIndex
        }, rovingTabIndexParameters),
        singleSelectionParameters,
        typeaheadNavigationParameters: _objectSpread({
          isValid
        }, typeaheadNavigationParameters),
        rearrangeableChildrenParameters,
        sortableChildrenParameters
      }),
      {
        childrenHaveFocusParameters,
        managedChildrenParameters,
        rovingTabIndexChildContext,
        singleSelectionContext,
        typeaheadNavigationChildContext,
        gridNavigationRowContext
      } = _useGridNavigationSin,
      gridNavigationSingleSelectionReturn = _objectWithoutProperties(_useGridNavigationSin, _excluded49);
    var {
      linearNavigationReturn,
      typeaheadNavigationReturn
    } = gridNavigationSingleSelectionReturn;
    var {
      childrenHaveFocusChildContext,
      childrenHaveFocusReturn
    } = useChildrenHaveFocus({
      childrenHaveFocusParameters
    });
    var {
      context: {
        managedChildContext
      },
      managedChildrenReturn
    } = useManagedChildren({
      managedChildrenParameters
    });
    var props = useMergedProps(linearNavigationReturn.propsStable, typeaheadNavigationReturn.propsStable);
    var context = useStableObject({
      singleSelectionContext,
      managedChildContext,
      rovingTabIndexChildContext,
      typeaheadNavigationChildContext,
      childrenHaveFocusChildContext,
      gridNavigationRowContext
    });
    return _objectSpread(_objectSpread({
      context,
      props,
      managedChildrenReturn
    }, gridNavigationSingleSelectionReturn), {}, {
      childrenHaveFocusReturn
      //rearrangeableChildrenParameters: { getHighestChildIndex: getHighestChildIndex, getValid },
    });
  }

  function useCompleteGridNavigationRow(_ref40) {
    var {
        asChildRowParameters: {
          managedChildParameters,
          context: {
            childrenHaveFocusChildContext,
            gridNavigationRowContext,
            managedChildContext: mcc1,
            rovingTabIndexChildContext,
            singleSelectionContext,
            typeaheadNavigationChildContext
          },
          completeGridNavigationRowParameters,
          singleSelectionChildParameters,
          rovingTabIndexChildParameters
        },
        asParentRowParameters: {
          linearNavigationParameters,
          rovingTabIndexParameters,
          typeaheadNavigationParameters
        }
      } = _ref40,
      asChildRowParameters = _objectWithoutProperties(_ref40.asChildRowParameters, _excluded50),
      asParentRowParameters = _objectWithoutProperties(_ref40.asParentRowParameters, _excluded51);
    var {
      index
    } = managedChildParameters;
    var getChildren = T$1(() => managedChildrenReturn.getChildren(), []);
    var getHighestChildIndex = T$1(() => getChildren().getHighestIndex(), []);
    var isValid = T$1(i => {
      var child = getChildren().getAt(i);
      if (!child) return false;
      return !child.hidden;
    }, []);
    var {
      refElementReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var r = useGridNavigationSingleSelectionRow({
      asParentRowParameters: _objectSpread(_objectSpread({}, asParentRowParameters), {}, {
        rovingTabIndexParameters: _objectSpread({
          initiallyTabbedIndex: 0
        }, rovingTabIndexParameters),
        typeaheadNavigationParameters: _objectSpread({
          isValid
        }, typeaheadNavigationParameters),
        linearNavigationParameters: _objectSpread({
          isValid,
          getHighestIndex: getHighestChildIndex,
          pageNavigationSize: 0,
          indexDemangler: identity$1,
          indexMangler: identity$1
        }, linearNavigationParameters),
        managedChildrenReturn: {
          getChildren
        }
      }),
      asChildRowParameters: _objectSpread(_objectSpread({}, asChildRowParameters), {}, {
        refElementReturn,
        rovingTabIndexChildParameters,
        gridNavigationRowContext,
        rovingTabIndexChildContext,
        singleSelectionContext,
        typeaheadNavigationChildContext,
        singleSelectionChildParameters,
        managedChildParameters,
        managedChildrenReturn: {
          getChildren
        }
      })
    });
    var {
      asChildRowReturn,
      asParentRowReturn
    } = r;
    var {
      context: {
        managedChildContext
      },
      managedChildrenReturn
    } = useManagedChildren({
      managedChildrenParameters: r.asParentRowReturn.managedChildrenParameters
    });
    var {
      getElement
    } = refElementReturn;
    var baseInfo = {
      getElement,
      setTabbable: r.asChildRowReturn.rovingTabIndexChildReturn.setTabbable,
      getTabbable: r.asChildRowReturn.rovingTabIndexChildReturn.getTabbable,
      tabbable: r.asChildRowReturn.rovingTabIndexChildReturn.tabbable,
      index: managedChildParameters.index,
      hidden: rovingTabIndexChildParameters.hidden,
      selected: r.asChildRowReturn.singleSelectionChildReturn.selected,
      focusSelf: r.asChildRowReturn.gridNavigationRowParameters.focusSelf,
      getSelected: r.asChildRowReturn.singleSelectionChildReturn.getSelected,
      setLocalSelected: r.asChildRowReturn.managedChildParameters.setLocalSelected,
      disabled: singleSelectionChildParameters.disabled,
      setTabbableColumnIndex: r.asChildRowReturn.gridNavigationRowParameters.setTabbableColumnIndex
    };
    var {
      managedChildReturn
    } = useManagedChild({
      context: {
        managedChildContext: mcc1
      },
      managedChildParameters: {
        index
      }
    }, _objectSpread(_objectSpread({}, baseInfo), completeGridNavigationRowParameters));
    var context = useStableObject({
      managedChildContext,
      rovingTabIndexChildContext: r.asParentRowReturn.rovingTabIndexChildContext,
      typeaheadNavigationChildContext: r.asParentRowReturn.typeaheadNavigationChildContext,
      completeGridNavigationContext: useStableObject({
        onPressSync: r.asChildRowReturn.pressParameters.onPressSync
      }),
      gridNavigationCellContext: r.asParentRowReturn.gridNavigationCellContext
    });
    var {
      hasCurrentFocusParameters
    } = useChildrenHaveFocusChild({
      childrenHaveFocusChildContext
    });
    //const { refElementReturn } = useRefElement<RowElement>({ refElementParameters: {} })
    var {
      hasCurrentFocusReturn
    } = useHasCurrentFocus({
      refElementReturn,
      hasCurrentFocusParameters: _objectSpread(_objectSpread({}, hasCurrentFocusParameters), {}, {
        onCurrentFocusedChanged: null
      })
    });
    var props = useMergedProps(refElementReturn.propsStable,
    // TODO: Rows don't use tabIndex, but just excluding props here is...weird.
    //r.asChildRowReturn.rovingTabIndexChildReturn.propsUnstable,
    r.asChildRowReturn.singleSelectionChildReturn.propsUnstable, r.asParentRowReturn.linearNavigationReturn.propsStable, r.asParentRowReturn.typeaheadNavigationReturn.propsStable, hasCurrentFocusReturn.propsStable);
    return {
      context,
      props,
      asParentRowReturn,
      asChildRowReturn,
      managedChildReturn,
      hasCurrentFocusReturn
      //managedChildrenReturn,
      //...gridNavigationSingleSelectionReturn
    };
  }

  function useCompleteGridNavigationCell(_ref41) {
    var {
        gridNavigationCellParameters,
        managedChildParameters,
        context: {
          completeGridNavigationContext,
          gridNavigationCellContext,
          managedChildContext,
          rovingTabIndexChildContext,
          typeaheadNavigationChildContext
        },
        rovingTabIndexChildParameters,
        textContentParameters,
        //managedChildContext,
        completeGridNavigationCellParameters,
        pressParameters: {
          onPressSync
        }
      } = _ref41,
      pressParameters = _objectWithoutProperties(_ref41.pressParameters, _excluded52);
    var {
      index
    } = managedChildParameters;
    var {
      refElementReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      hasCurrentFocusParameters,
      rovingTabIndexChildReturn,
      textContentReturn
    } = useGridNavigationSingleSelectionCell({
      gridNavigationCellContext,
      gridNavigationCellParameters,
      managedChildParameters,
      rovingTabIndexChildContext,
      typeaheadNavigationChildContext,
      rovingTabIndexChildParameters,
      refElementReturn,
      textContentParameters
    });
    var {
      hasCurrentFocusReturn
    } = useHasCurrentFocus({
      hasCurrentFocusParameters: _objectSpread({
        onCurrentFocusedChanged: null
      }, hasCurrentFocusParameters),
      refElementReturn
    });
    var {
      pressReturn
    } = usePress({
      pressParameters: _objectSpread({
        onPressSync: useStableCallback(e => {
          var _completeGridNavigati;
          onPressSync === null || onPressSync === void 0 ? void 0 : onPressSync(e);
          (_completeGridNavigati = completeGridNavigationContext.onPressSync) === null || _completeGridNavigati === void 0 ? void 0 : _completeGridNavigati.call(completeGridNavigationContext, e);
        })
      }, pressParameters),
      refElementReturn
    });
    var baseInfo = {
      focusSelf: pressParameters.focusSelf,
      getElement: refElementReturn.getElement,
      hidden: rovingTabIndexChildParameters.hidden,
      index: managedChildParameters.index,
      getTabbable: rovingTabIndexChildReturn.getTabbable,
      setTabbable: rovingTabIndexChildReturn.setTabbable,
      tabbable: rovingTabIndexChildReturn.tabbable
    };
    var {
      managedChildReturn
    } = useManagedChild({
      context: {
        managedChildContext
      },
      managedChildParameters: {
        index
      }
    }, _objectSpread(_objectSpread({}, baseInfo), completeGridNavigationCellParameters));
    var props = useMergedProps(refElementReturn.propsStable, pressReturn.propsStable, rovingTabIndexChildReturn.propsUnstable, hasCurrentFocusReturn.propsStable);
    return {
      props,
      rovingTabIndexChildReturn,
      pressReturn,
      refElementReturn,
      hasCurrentFocusReturn,
      managedChildReturn,
      textContentReturn
    };
  }

  /**
   * All the list-related hooks combined into one giant hook that encapsulates everything.
   *
   * Unlike most others, this hook assume's it's the final one--the "outermost" hook in the component--so it uses `useManagedChildren` and wraps everything up nicely,
   * combining event handlers that are used in multiple sub-hooks, collecting all the necessary context-related data, and merging all known DOM props together.
   *
   *
   *
   * @returns
   */
  function useCompleteListNavigation(_ref42) {
    var {
        linearNavigationParameters,
        rearrangeableChildrenParameters,
        sortableChildrenParameters,
        typeaheadNavigationParameters,
        rovingTabIndexParameters,
        singleSelectionParameters
      } = _ref42,
      completeListNavigationParameters = _objectWithoutProperties(_ref42, _excluded53);
    //type M = UseListNavigationSingleSelectionChildInfo<ChildElement>;
    var {
      initiallySelectedIndex
    } = singleSelectionParameters;
    var getChildren = T$1(() => managedChildrenReturn.getChildren(), []);
    var getHighestChildIndex = T$1(() => getChildren().getHighestIndex(), []);
    var getValid = T$1(i => {
      var child = getChildren().getAt(i);
      if (!child) return false;
      return !child.hidden;
    }, []);
    var {
      rearrangeableChildrenReturn,
      sortableChildrenReturn
    } = useSortableChildren({
      rearrangeableChildrenParameters,
      sortableChildrenParameters
    });
    var {
      indexDemangler,
      indexMangler
    } = rearrangeableChildrenReturn;
    var {
      childrenHaveFocusParameters,
      managedChildrenParameters,
      rovingTabIndexChildContext,
      typeaheadNavigationChildContext,
      singleSelectionContext,
      linearNavigationReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      typeaheadNavigationReturn
    } = useListNavigationSingleSelection(_objectSpread({
      managedChildrenReturn: {
        getChildren
      },
      linearNavigationParameters: _objectSpread({
        getHighestIndex: getHighestChildIndex,
        isValid: getValid,
        indexDemangler,
        indexMangler
      }, linearNavigationParameters),
      typeaheadNavigationParameters: _objectSpread({
        isValid: getValid
      }, typeaheadNavigationParameters),
      rovingTabIndexParameters: _objectSpread({
        initiallyTabbedIndex: initiallySelectedIndex
      }, rovingTabIndexParameters),
      singleSelectionParameters
    }, completeListNavigationParameters));
    //const { linearNavigationReturn, typeaheadNavigationReturn } = listNavigationSingleSelectionSortableReturn;
    var {
      childrenHaveFocusChildContext,
      childrenHaveFocusReturn
    } = useChildrenHaveFocus({
      childrenHaveFocusParameters
    });
    var {
      context: {
        managedChildContext
      },
      managedChildrenReturn
    } = useManagedChildren({
      managedChildrenParameters
    });
    var props = useMergedProps(linearNavigationReturn.propsStable, typeaheadNavigationReturn.propsStable);
    var context = useStableObject({
      singleSelectionContext,
      managedChildContext,
      rovingTabIndexChildContext,
      typeaheadNavigationChildContext,
      childrenHaveFocusChildContext
    });
    return {
      context,
      props,
      managedChildrenReturn,
      rearrangeableChildrenReturn,
      sortableChildrenReturn,
      linearNavigationReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      typeaheadNavigationReturn,
      childrenHaveFocusReturn
    };
  }
  function useCompleteListNavigationChild(_ref43) {
    var {
        //managedChildParameters: { hidden, disabled, index, getSortValue },
        completeListNavigationChildParameters,
        singleSelectionChildParameters,
        rovingTabIndexChildParameters,
        managedChildParameters,
        textContentParameters,
        context: {
          childrenHaveFocusChildContext,
          managedChildContext,
          rovingTabIndexChildContext,
          singleSelectionContext,
          typeaheadNavigationChildContext
        },
        pressParameters: {
          onPressSync: ops1
        },
        sortableChildParameters: {
          getSortValue
        }
      } = _ref43,
      pressParameters = _objectWithoutProperties(_ref43.pressParameters, _excluded54),
      _void = _objectWithoutProperties(_ref43, _excluded55);
    var {
      hidden
    } = rovingTabIndexChildParameters;
    var {
      index
    } = managedChildParameters;
    var {
      disabled
    } = singleSelectionChildParameters;
    if (hidden) disabled = true;
    var {
      refElementReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      getElement
    } = refElementReturn;
    var {
      focusSelf
    } = pressParameters;
    var _useListNavigationSin = useListNavigationSingleSelectionChild({
        managedChildParameters: {
          index
        },
        rovingTabIndexChildParameters: {
          hidden
        },
        singleSelectionChildParameters: _objectSpread({}, singleSelectionChildParameters),
        rovingTabIndexChildContext,
        singleSelectionContext,
        typeaheadNavigationChildContext,
        refElementReturn,
        textContentParameters
      }),
      {
        hasCurrentFocusParameters: {
          onCurrentFocusedInnerChanged: ocfic1
        },
        pressParameters: {
          onPressSync: ops2
        },
        rovingTabIndexChildReturn,
        singleSelectionChildReturn,
        managedChildParameters: {
          setLocalSelected
        }
      } = _useListNavigationSin,
      p1 = _objectWithoutProperties(_useListNavigationSin.pressParameters, _excluded56);
    var {
      getTabbable,
      setTabbable,
      tabbable
    } = rovingTabIndexChildReturn;
    var {
      pressReturn
    } = usePress({
      pressParameters: _objectSpread(_objectSpread(_objectSpread({}, p1), pressParameters), {}, {
        onPressSync: disabled ? null : e => {
          ops2 === null || ops2 === void 0 ? void 0 : ops2(e);
          ops1 === null || ops1 === void 0 ? void 0 : ops1(e);
        }
      }),
      refElementReturn
    });
    var {
      getSelected,
      selected
    } = singleSelectionChildReturn;
    var mcp1 = {
      disabled,
      focusSelf,
      getElement,
      getSelected,
      getTabbable,
      hidden,
      index,
      selected,
      setLocalSelected,
      setTabbable,
      tabbable,
      getSortValue
    };
    var {
      managedChildReturn
    } = useManagedChild({
      context: {
        managedChildContext
      },
      managedChildParameters: {
        index
      }
    }, _objectSpread(_objectSpread({}, mcp1), completeListNavigationChildParameters));
    var {
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged: ocfic2
      }
    } = useChildrenHaveFocusChild({
      childrenHaveFocusChildContext
    });
    var onCurrentFocusedInnerChanged = useStableCallback((focused, prev, e) => {
      ocfic1 === null || ocfic1 === void 0 ? void 0 : ocfic1(focused, prev, e);
      ocfic2 === null || ocfic2 === void 0 ? void 0 : ocfic2(focused, prev, e);
    });
    var {
      hasCurrentFocusReturn
    } = useHasCurrentFocus({
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged,
        onCurrentFocusedChanged: null
      },
      refElementReturn
    });
    var props = useMergedProps(refElementReturn.propsStable, pressReturn.propsStable, hasCurrentFocusReturn.propsStable, rovingTabIndexChildReturn.propsUnstable, singleSelectionChildReturn.propsUnstable);
    return {
      props,
      pressReturn,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn,
      hasCurrentFocusReturn,
      managedChildReturn
    };
  }
  /*
  function foo<ParentElement extends Element, ChildElement extends Element, M extends UseListNavigationSingleSelectionSortableChildInfo<ChildElement>>(p: UseCompleteListNavigationParameters<ParentElement, ChildElement, M>) {
      const { singleSelectionReturn } = useCompleteListNavigation<ParentElement, ChildElement, M>(p);
      const selectedIndex = 0;
      useSingleSelectionDeclarative({ singleSelectionReturn, singleSelectionDeclarativeParameters: { selectedIndex } })
  }*/

  /**
   * Combines dismissal hooks and focus trap hooks into one.
   *
   * Another in the "complete" series, alongside list/grid navigation and dismissal itself.
   *
   * Use for dialogs, menus, etc.  Anything that can be dismissed and might trap focus, basically.
   *
   * @param param0
   * @returns
   */
  function useModal(_ref44) {
    var {
        dismissParameters,
        escapeDismissParameters,
        focusTrapParameters: {
          trapActive
        }
      } = _ref44,
      focusTrapParameters = _objectWithoutProperties(_ref44.focusTrapParameters, _excluded57);
    var {
      open
    } = dismissParameters;
    //const { getWindow } = escapeDismissParameters;
    //const getDocument = useCallback(() => { return getWindow().document; }, [getWindow]);
    var {
      refElementPopupReturn,
      refElementSourceReturn
    } = useDismiss({
      dismissParameters,
      escapeDismissParameters
    });
    var {
      focusTrapReturn,
      refElementReturn
    } = useFocusTrap({
      focusTrapParameters: _objectSpread({
        trapActive: open && trapActive
      }, focusTrapParameters),
      refElementParameters: {}
    });
    var {
      propsStable: pp1
    } = refElementPopupReturn;
    var {
      propsStable: ps2
    } = refElementSourceReturn;
    var {
      propsUnstable: pp3
    } = focusTrapReturn;
    var {
      propsStable: pp4
    } = refElementReturn;
    return {
      propsPopup: pp1,
      propsFocusContainer: useMergedProps(pp3, pp4),
      propsSource: ps2,
      refElementPopupReturn,
      refElementSourceReturn,
      focusTrapReturn
    };
  }
  function useRandomId(_ref45) {
    var {
      randomIdParameters: {
        prefix,
        otherReferencerProp
      }
    } = _ref45;
    var id = prefix + V$1();
    useEnsureStability("useRandomId", prefix, id);
    var referencerElementProps = _(otherReferencerProp == null ? {} : {
      [otherReferencerProp]: id
    });
    var sourceElementProps = _({
      id
    });
    useEnsureStability("useRandomIdReferencerElement", otherReferencerProp);
    return {
      propsReferencer: referencerElementProps.current,
      propsSource: sourceElementProps.current,
      randomIdReturn: {
        id: id
      }
    };
  }

  /**
   * While `useRandomId` allows the referencer to use the source's ID, sometimes you also want the reverse too (e.g. I `aria-label` you, you `aria-controls` me. That sort of thing).
   */
  function useRandomDualIds(_ref46) {
    var {
      randomIdInputParameters,
      randomIdLabelParameters
    } = _ref46;
    var {
      randomIdReturn: randomIdInputReturn,
      propsReferencer: propsLabelAsReferencer,
      propsSource: propsInputAsSource
    } = useRandomId({
      randomIdParameters: randomIdInputParameters
    });
    var {
      randomIdReturn: randomIdLabelReturn,
      propsReferencer: propsInputAsReferencer,
      propsSource: propsLabelAsSource
    } = useRandomId({
      randomIdParameters: randomIdLabelParameters
    });
    return {
      propsLabel: useMergedProps(propsLabelAsReferencer, propsLabelAsSource),
      propsInput: useMergedProps(propsInputAsReferencer, propsInputAsSource),
      randomIdInputReturn,
      randomIdLabelReturn
    };
  }
  B$2(null);
  function useTimeout(_ref47) {
    var {
      timeout,
      callback,
      triggerIndex
    } = _ref47;
    var stableCallback = useStableCallback(() => {
      startTimeRef.current = null;
      callback();
    });
    var getTimeout = useStableGetter(timeout);
    // Set any time we start timeout.
    // Unset any time the timeout completes
    var startTimeRef = _(null);
    var timeoutIsNull = timeout == null;
    // Any time the triggerIndex changes (including on mount)
    // restart the timeout.  The timeout does NOT reset
    // when the duration or callback changes, only triggerIndex.
    h(() => {
      if (!timeoutIsNull) {
        var _timeout = getTimeout();
        console.assert(timeoutIsNull == (_timeout == null));
        if (_timeout != null) {
          startTimeRef.current = +new Date();
          var handle = setTimeout(stableCallback, _timeout);
          return () => clearTimeout(handle);
        }
      }
    }, [triggerIndex, timeoutIsNull]);
    var getElapsedTime = T$1(() => {
      var _startTimeRef$current;
      return +new Date() - +((_startTimeRef$current = startTimeRef.current) !== null && _startTimeRef$current !== void 0 ? _startTimeRef$current : new Date());
    }, []);
    var getRemainingTime = T$1(() => {
      var timeout = getTimeout();
      return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
    }, []);
    return {
      getElapsedTime,
      getRemainingTime
    };
  }
  function useButton(_ref48) {
    var {
      buttonParameters: {
        tagButton,
        disabled,
        onPress,
        pressed,
        role
      },
      pressParameters,
      refElementParameters
    } = _ref48;
    var refElementReturn = useRefElement({
      refElementParameters
    });
    var focusSelf = T$1(e => {
      var _e$focus2;
      return (_e$focus2 = e.focus) === null || _e$focus2 === void 0 ? void 0 : _e$focus2.call(e);
    }, []);
    var pressReturn = usePress(_objectSpread(_objectSpread({}, refElementReturn), {}, {
      pressParameters: _objectSpread({
        onPressSync: e => {
          var _ref49;
          return (_ref49 = disabled ? null : onPress) === null || _ref49 === void 0 ? void 0 : _ref49(enhanceEvent(e, {
            pressed: pressed == null ? null : !pressed
          }));
        },
        focusSelf
      }, pressParameters)
    }));
    var {
      pressReturn: {
        propsStable: pressProps
      }
    } = pressReturn;
    var {
      refElementReturn: {
        propsStable: refProps
      }
    } = refElementReturn;
    var baseProps = {
      "aria-pressed": pressed === true ? "true" : pressed === false ? "false" : undefined
    };
    var buttonProps = _objectSpread(_objectSpread({}, baseProps), {}, {
      disabled: disabled && disabled != "soft" ? true : false,
      "aria-disabled": disabled === 'soft' ? 'true' : undefined,
      role: role == "button" ? undefined : role
    });
    var divProps = _objectSpread(_objectSpread({}, baseProps), {}, {
      tabIndex: disabled === "hard" ? -1 : 0,
      role,
      "aria-disabled": disabled ? "true" : undefined
    });
    return _objectSpread(_objectSpread(_objectSpread({}, refElementReturn), pressReturn), {}, {
      props: useMergedProps(pressProps, refProps, tagButton == 'button' ? buttonProps : divProps)
    });
  }
  function useAccordion(_ref50) {
    var {
      accordionParameters: {
        initialIndex
      },
      linearNavigationParameters: {
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        navigatePastEnd,
        navigatePastStart,
        pageNavigationSize
      },
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange
      }
    } = _ref50;
    //const [_currentFocusedIndex, setCurrentFocusedIndex, getCurrentFocusedIndex] = useState<number | null>(null);
    var mcReturnType = useManagedChildren({
      managedChildrenParameters: {
        onChildrenMountChange: useStableCallback((m, u) => {
          ocmc2();
          onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(m, u);
        }),
        onAfterChildLayoutEffect
      }
    });
    var {
      managedChildrenReturn: {
        getChildren
      },
      context
    } = mcReturnType;
    var isValid = T$1(c => !c.disabled && !c.hidden, []);
    var isValid2 = T$1(c => {
      var child = getChildren().getAt(c);
      if (child) {
        return isValid(child);
      }
      return false;
    }, []);
    var {
      changeIndex: changeExpandedIndex,
      getCurrentIndex: getCurrentExpandedIndex
    } = useChildrenFlag({
      initialIndex,
      getChildren,
      getAt: T$1(child => {
        var _child$getOpenFromPar;
        return (_child$getOpenFromPar = child.getOpenFromParent()) !== null && _child$getOpenFromPar !== void 0 ? _child$getOpenFromPar : false;
      }, []),
      setAt: T$1((child, open) => {
        return child.setOpenFromParent(open);
      }, []),
      isValid,
      onIndexChange: null,
      //key: "open",
      closestFit: false
    });
    var {
      changeIndex: changeTabbedIndex,
      getCurrentIndex: getTabbedIndex,
      reevaluateClosestFit: ocmc2
    } = useChildrenFlag({
      initialIndex,
      getChildren,
      getAt: T$1(child => {
        var _child$getMostRecentl;
        return (_child$getMostRecentl = child.getMostRecentlyTabbed()) !== null && _child$getMostRecentl !== void 0 ? _child$getMostRecentl : false;
      }, []),
      setAt: T$1((child, tabbed) => {
        return child.setMostRecentlyTabbed(tabbed);
      }, []),
      isValid,
      closestFit: true,
      onIndexChange: T$1(i => {
        if (i != null) {
          var _getChildren$getAt2;
          (_getChildren$getAt2 = getChildren().getAt(i)) === null || _getChildren$getAt2 === void 0 ? void 0 : _getChildren$getAt2.focusSelf();
        }
      }, [])
    });
    //const navigateAbsolute = useCallback((i: number) => { return changeTabbedIndex(i); }, []);
    //const navigateRelative = useCallback((s: number, o: number) => { return changeTabbedIndex(o + s); }, []);
    return {
      context: useStableObject(_objectSpread(_objectSpread({}, context), {}, {
        accordionSectionParameters: useStableObject({
          changeExpandedIndex,
          changeTabbedIndex,
          getExpandedIndex: getCurrentExpandedIndex,
          getTabbedIndex: getTabbedIndex
        }),
        linearNavigationParameters: useStableObject({
          disableArrowKeys,
          disableHomeEndKeys,
          getHighestIndex: T$1(() => getChildren().getHighestIndex(), []),
          indexMangler: identity,
          indexDemangler: identity,
          navigationDirection,
          isValid: isValid2,
          navigatePastEnd,
          navigatePastStart,
          pageNavigationSize
        }),
        rovingTabIndexReturn: useStableObject({
          getTabbableIndex: getTabbedIndex,
          setTabbableIndex: changeTabbedIndex
        })
      })),
      managedChildrenReturn: mcReturnType.managedChildrenReturn,
      accordionReturn: useStableObject({
        changeExpandedIndex
      })
    };
  }
  function identity(t) {
    return t;
  }
  function useAccordionSection(_ref51) {
    var _ref52;
    var {
      buttonParameters,
      pressParameters: {
        exclude
      },
      accordionSectionParameters: {
        open: openFromUser,
        bodyRole
      },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden
      },
      //managedChildContext,
      context,
      context: {
        accordionSectionParameters: {
          changeExpandedIndex,
          changeTabbedIndex: _setCurrentFocusedIndex,
          getTabbedIndex: getCurrentFocusedIndex
        },
        linearNavigationParameters,
        rovingTabIndexReturn
      },
      refElementParameters
    } = _ref51;
    var {
      disabled,
      onPress: userOnPress
    } = buttonParameters;
    var [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
    var [mostRecentlyTabbed, setMostRecentlyTabbed, getMostRecentlyTabbed] = useState(null);
    var {
      randomIdReturn: _bodyIdReturn,
      propsSource: propsBodySource,
      propsReferencer: propsHeadReferencer
    } = useRandomId({
      randomIdParameters: {
        prefix: Prefices.accordionSectionHeaderButton,
        otherReferencerProp: "aria-controls"
      }
    });
    var {
      randomIdReturn: _headIdReturn,
      propsSource: propsHeadSource,
      propsReferencer: propsBodyReferencer
    } = useRandomId({
      randomIdParameters: {
        prefix: Prefices.accordionSectionBody,
        otherReferencerProp: "aria-labelledby"
      }
    });
    //const { randomIdSourceReturn: { propsStable: useBodyAsSourceIdProps } } = useBodyAsSourceId();
    //const { randomIdReferencerReturn: { propsStable: useBodyAsReferencerIdProps } } = useBodyAsReferencerId<BodyElement>({ randomIdReferencerParameters: { otherReferencerProp: "aria-controls" as never } });
    //const { randomIdSourceReturn: { propsStable: useHeaderAsSourceIdProps } } = useHeaderAsSourceId();
    //const { randomIdReferencerReturn: { propsStable: useHeaderAsReferencerIdProps } } = useHeaderAsReferencerId<HeaderElement>({ randomIdReferencerParameters: { otherReferencerProp: "aria-labelledby" as never } });
    var open = (_ref52 = openFromUser !== null && openFromUser !== void 0 ? openFromUser : openFromParent) !== null && _ref52 !== void 0 ? _ref52 : false;
    //const getOpen = useStableGetter(!!open);
    useStableGetter(index);
    var {
      refElementReturn: {
        getElement: getHeaderElement,
        propsStable: headerRefElementProps
      }
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      refElementReturn: {
        getElement: _getBodyElement,
        propsStable: bodyRefElementProps
      }
    } = useRefElement({
      refElementParameters: {}
    });
    var focusSelf = T$1(() => {
      var _getHeaderElement;
      //if (getCurrentFocusedIndex() != null)
      (_getHeaderElement = getHeaderElement()) === null || _getHeaderElement === void 0 ? void 0 : _getHeaderElement.focus();
    }, []);
    /*const openRef = useRef({
            get: () => !!getOpenFromParent(),
            set: (open: boolean) => {
                setOpenFromParent(open);
                 if (open) {
                    const bodyElement = getBodyElement();
                    setCurrentFocusedIndex(getIndex());
                    if (bodyElement) {
                        queueMicrotask(() => bodyElement.focus());
                }
            }
            },
            isValid: returnTrue
        });
        const tabbedRef = useRef({
            get: () => (getCurrentFocusedIndex() == getIndex()),
            set: (open: boolean) => {
                if (open)
                    setCurrentFocusedIndex(getIndex());
            },
            isValid: returnTrue
    });*/
    useManagedChild({
      context,
      managedChildParameters: {
        index: index
      }
    }, {
      index,
      disabled,
      focusSelf,
      getMostRecentlyTabbed,
      getOpenFromParent,
      hidden,
      setMostRecentlyTabbed,
      setOpenFromParent
    });
    //const onFocus = () => { changeTabbedIndex(index); }
    var onPress = e => {
      if (getOpenFromParent()) changeExpandedIndex(null);else changeExpandedIndex(index);
      userOnPress === null || userOnPress === void 0 ? void 0 : userOnPress(e);
    };
    var {
      pressReturn,
      props: buttonProps,
      refElementReturn
    } = useButton({
      buttonParameters: _objectSpread(_objectSpread({}, buttonParameters), {}, {
        pressed: null,
        onPress,
        role: "button"
      }),
      pressParameters: {
        exclude
      },
      refElementParameters
    });
    var linearReturnType = useLinearNavigation({
      linearNavigationParameters,
      rovingTabIndexReturn
    });
    var {
      linearNavigationReturn: {
        propsStable
      }
    } = linearReturnType;
    /*function useAccordionSectionHeaderProps({ ["aria-expanded"]: ariaExpanded, ["aria-disabled"]: ariaDisabled, ...props }: h.JSX.HTMLAttributes<HeaderElement>): h.JSX.HTMLAttributes<HeaderElement> {
             props.tabIndex = 0;
              return useMergedProps(useHeaderAsSourceIdProps, useHeaderAsReferencerIdProps, propsStable, {
                "aria-expanded": (ariaExpanded ?? open ?? false).toString(),
                "aria-disabled": (ariaDisabled ?? (open ? "true" : undefined)),
                ...useMergedProps(headerRefElementProps, useButtonProps(props))
            } as h.JSX.HTMLAttributes<HeaderElement>);
        }
          function useAccordionSectionBodyProps({ role, ...props }: h.JSX.HTMLAttributes<BodyElement>): h.JSX.HTMLAttributes<BodyElement> {
            const ret1 = useMergedProps(useBodyAsReferencerIdProps, { role: role ?? "region", ...props });
            const ret2 = useMergedProps(useBodyAsSourceIdProps, ret1);
            ret2.tabIndex ??= -1;
            return useMergedProps(bodyRefElementProps, ret2);
    }*/
    var headerButtonProps = useMergedProps(buttonProps, headerRefElementProps, propsHeadReferencer, propsHeadSource, propsStable, {
      "aria-expanded": (open !== null && open !== void 0 ? open : false).toString()
    });
    var bodyProps = useMergedProps(bodyRefElementProps, propsBodyReferencer, propsBodySource, {
      role: bodyRole,
      tabIndex: -1
    });
    return {
      pressReturn,
      refElementReturn,
      accordionSectionReturn: {
        mostRecentlyTabbed: !!mostRecentlyTabbed,
        expanded: open,
        focused: getCurrentFocusedIndex() == index
      },
      propsHeaderButton: headerButtonProps,
      propsHeader: {},
      propsBody: bodyProps
    };
  }
  function useLabel(_ref53) {
    var {
      randomIdInputParameters,
      randomIdLabelParameters,
      labelParameters: {
        tagInput,
        tagLabel,
        ariaLabel,
        labelPosition,
        onLabelClick
      }
    } = _ref53;
    var nativeHTMLBehavior = tagInput == "input" && tagLabel == "label" && labelPosition != "wrapping";
    var synthetic = !nativeHTMLBehavior;
    var {
      propsInput,
      propsLabel,
      randomIdInputReturn,
      randomIdLabelReturn
    } = useRandomDualIds({
      randomIdInputParameters: _objectSpread(_objectSpread({}, randomIdInputParameters), {}, {
        otherReferencerProp: !synthetic && labelPosition === "separate" ? "for" : null
      }),
      randomIdLabelParameters: _objectSpread(_objectSpread({}, randomIdLabelParameters), {}, {
        otherReferencerProp: synthetic ? "aria-labelledby" : null
      })
    });
    if (labelPosition == 'none') propsInput["aria-label"] = ariaLabel;
    propsLabel.onClick = onLabelClick !== null && onLabelClick !== void 0 ? onLabelClick : undefined;
    return {
      propsInput,
      propsLabel,
      randomIdInputReturn,
      randomIdLabelReturn
    };
  }
  /**
   * Shortcut for `useLabel` that assumes we're just never working with native HTML `input` and `label` elements. So for labelling guaranteably non-native elements.
   */
  function useLabelSynthetic(_ref54) {
    var {
      labelParameters: {
        ariaLabel,
        onLabelClick
      },
      randomIdInputParameters,
      randomIdLabelParameters
    } = _ref54;
    return useLabel({
      randomIdLabelParameters,
      randomIdInputParameters,
      labelParameters: {
        ariaLabel,
        labelPosition: ariaLabel == null ? "separate" : "none",
        tagInput: "div",
        tagLabel: "div",
        onLabelClick
      }
    });
  }
  function preventDefault(e) {
    e.preventDefault();
  }
  /**
   * Handles any component where there's:
   * 1. Some kind of an on/off binary/trinary input element that needs event handlers
   * 2. Some kind of label for that input element
   *
   * See also `useLabel` for when there's a label for a non-checkbox-like component.
   *
   * @param param0
   * @returns
   */
  function useCheckboxLike(_ref55) {
    var {
      labelParameters,
      randomIdInputParameters,
      randomIdLabelParameters,
      checkboxLikeParameters: {
        checked,
        disabled,
        onInput: onInputSync,
        role
      },
      refElementInputReturn,
      refElementLabelReturn
    } = _ref55;
    var {
      getElement: getInputElement
    } = refElementInputReturn;
    var {
      getElement: getLabelElement
    } = refElementLabelReturn;
    var {
      tagInput,
      tagLabel,
      labelPosition
    } = labelParameters;
    // onClick and onChange are a bit messy, so we need to
    // *always* make sure that the visible state is correct
    // after all the event dust settles.
    // See https://github.com/preactjs/preact/issues/2745,
    // and https://github.com/preactjs/preact/issues/1899#issuecomment-525690194
    h(() => {
      var element = getInputElement();
      if (element && tagInput == "input") {
        element.indeterminate = checked === "mixed";
        element.checked = checked === true;
      }
    }, [tagInput, checked !== null && checked !== void 0 ? checked : false]);
    var {
      randomIdInputReturn,
      randomIdLabelReturn,
      propsInput,
      propsLabel
    } = useLabel({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: useStableCallback(e => {
          if (!disabled && tagInput != "input" && tagLabel != "label" && labelPosition != "separate") {
            focusSelf();
            onInputSync(e);
          }
        })
      }),
      randomIdInputParameters,
      randomIdLabelParameters
    });
    var {
      getElement: getInput
    } = refElementInputReturn;
    var {
      getElement: getLabel
    } = refElementLabelReturn;
    T$1(() => {
      var _getInput;
      (_getInput = getInput()) === null || _getInput === void 0 ? void 0 : _getInput.focus();
    }, []);
    T$1(() => {
      var _getLabel;
      (_getLabel = getLabel()) === null || _getLabel === void 0 ? void 0 : _getLabel.focus();
    }, []);
    var onClickInputSync = labelPosition == "wrapping" ? undefined : onInputSync;
    var onClickLabelSync = onInputSync; //(labelPosition != "wrapping" ? undefined : onInputSync);
    var {
      pressReturn: pressInputReturn
    } = usePress({
      pressParameters: {
        exclude: {},
        focusSelf: useStableCallback(() => {
          debugger;
          focusSelf();
        }),
        onPressSync: disabled ? undefined : onClickInputSync
      },
      refElementReturn: refElementInputReturn
    });
    var {
      pressReturn: pressLabelReturn
    } = usePress({
      pressParameters: {
        exclude: {},
        focusSelf: useStableCallback(() => {
          debugger;
          focusSelf();
        }),
        onPressSync: disabled ? undefined : onClickLabelSync
      },
      refElementReturn: refElementLabelReturn
    });
    var propsUnstableInput = {};
    var propsUnstableLabel = {};
    //const propsUnstableLabel = useRef<h.JSX.HTMLAttributes<LabelType>>({});
    // Make sure that label clicks can't affect the visual state of the checkbox
    propsUnstableInput.onClick = preventDefault;
    propsUnstableLabel.onClick = preventDefault;
    propsUnstableInput.onInput = preventDefault;
    propsUnstableInput.onChange = preventDefault;
    propsUnstableInput.type = role == "radio" ? "radio" : "checkbox";
    switch (labelPosition) {
      case "separate":
        {
          if (tagInput == "input") {
            // Even in the most default input behavior, we still need to handle
            // special abstraction over checked="mixed" and disabled="soft"
            propsUnstableInput.checked = checked === true;
            if (disabled === true || disabled === 'hard') propsUnstableInput.disabled = true;else if (disabled == "soft") propsUnstableInput["aria-disabled"] = "true";
          } else {
            // div inputs need their various ARIA roles and properties
            propsUnstableInput.role = role;
            propsUnstableInput.tabIndex = 0;
            propsUnstableInput["aria-checked"] = (checked !== null && checked !== void 0 ? checked : false).toString();
            propsUnstableInput["aria-disabled"] = (!!disabled).toString();
          }
          break;
        }
      case "wrapping":
        {
          if (tagInput == "input") {
            // For form submission and styling
            propsUnstableInput.checked = checked === true;
            propsUnstableInput.disabled = disabled === true;
            // Because the wrapped label handles all interactions,
            // we need to make sure this element can't be interacted with
            // even if it's an input element.
            propsUnstableInput.inert = true;
            propsUnstableInput.tabIndex = -1;
            propsUnstableInput.role = "presentation";
            propsUnstableInput["aria-hidden"] = "true";
            propsUnstableInput.onFocus = _ => {
              var _getLabelElement, _getLabelElement$focu;
              return getLabelElement === null || getLabelElement === void 0 ? void 0 : (_getLabelElement = getLabelElement()) === null || _getLabelElement === void 0 ? void 0 : (_getLabelElement$focu = _getLabelElement.focus) === null || _getLabelElement$focu === void 0 ? void 0 : _getLabelElement$focu.call(_getLabelElement);
            };
          }
          // Wrapping labels are the actual inputs that are interacted with
          // And are very similar conceptually to div inputs when separated
          propsUnstableLabel.role = role;
          propsUnstableLabel.tabIndex = 0;
          propsUnstableLabel["aria-checked"] = (checked !== null && checked !== void 0 ? checked : false).toString();
          propsUnstableLabel["aria-disabled"] = (!!disabled).toString();
          break;
        }
    }
    var focusSelf = useStableCallback(() => {
      var _elementToFocus;
      var elementToFocus = null;
      if (labelPosition == "wrapping") elementToFocus = getLabelElement();else elementToFocus = getInputElement();
      (_elementToFocus = elementToFocus) === null || _elementToFocus === void 0 ? void 0 : _elementToFocus.focus();
    });
    return {
      randomIdInputReturn,
      randomIdLabelReturn,
      pressInputReturn,
      pressLabelReturn,
      checkboxLikeInputReturn: {
        propsUnstable: propsUnstableInput
      },
      checkboxLikeLabelReturn: {
        propsUnstable: propsUnstableLabel
      },
      propsInput: useMergedProps(propsInput, propsUnstableInput, pressInputReturn.propsStable, refElementInputReturn.propsStable),
      propsLabel: useMergedProps(propsLabel, propsUnstableLabel, pressLabelReturn.propsStable, refElementLabelReturn.propsStable),
      checkboxLikeReturn: {
        focusSelf
      }
    };
  }
  function useCheckbox(_ref56) {
    var {
      checkboxParameters: {
        onCheckedChange
      },
      checkboxLikeParameters,
      labelParameters,
      refElementInputReturn,
      refElementLabelReturn
    } = _ref56;
    var {
      tagInput,
      labelPosition
    } = labelParameters;
    var {
      checked
    } = checkboxLikeParameters;
    var onInputEnhanced = useStableCallback(e => onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(enhanceEvent(e, {
      checked: !checked
    })));
    var {
      pressInputReturn,
      pressLabelReturn,
      randomIdInputReturn,
      randomIdLabelReturn,
      propsInput,
      propsLabel,
      checkboxLikeReturn,
      checkboxLikeInputReturn,
      checkboxLikeLabelReturn
    } = useCheckboxLike({
      randomIdInputParameters: {
        prefix: Prefices.checkboxLikeInput
      },
      randomIdLabelParameters: {
        prefix: Prefices.checkboxLikeLabel
      },
      refElementInputReturn,
      refElementLabelReturn,
      checkboxLikeParameters: _objectSpread({
        role: "checkbox",
        onInput: onInputEnhanced
      }, checkboxLikeParameters),
      labelParameters
    });
    return {
      checkboxReturn: {
        propsUnstable: {
          type: tagInput == "input" && labelPosition != "wrapping" ? "checkbox" : undefined
        }
      },
      checkboxLikeReturn,
      pressInputReturn,
      pressLabelReturn,
      randomIdInputReturn,
      randomIdLabelReturn,
      propsInput,
      propsLabel,
      checkboxLikeInputReturn,
      checkboxLikeLabelReturn
    };
  }

  /**
   *
   *
   * @param param0
   * @returns
   */
  function useCheckboxGroup(_ref57) {
    var {
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      sortableChildrenParameters,
      rovingTabIndexParameters,
      typeaheadNavigationParameters
    } = _ref57;
    //const onUpdateChildren = useStableCallback(onUpdateChildrenUnstable ?? (() => {}));
    var {
      childrenHaveFocusReturn,
      context,
      linearNavigationReturn,
      managedChildrenReturn,
      props,
      rearrangeableChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn
    } = useCompleteListNavigation({
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      singleSelectionParameters: {
        initiallySelectedIndex: null,
        setSelectedIndex: null
      },
      sortableChildrenParameters,
      typeaheadNavigationParameters
    });
    var {
      getChildren
    } = managedChildrenReturn;
    var children = getChildren();
    //const [uncheckedCount, setUnheckedCount] = useState(0);
    // Keep track of all child IDs, and any time any of them change, 
    // generate a new string with all of them concatenated together
    // (but only once per render);
    var allIds = _(new Set());
    var updateParentControlIds = useStableCallback(setter => {
      setter === null || setter === void 0 ? void 0 : setter(Array.from(allIds.current).join(" "));
    });
    var [getSetter, setSetter] = usePassiveState(updateParentControlIds, returnNull);
    var [_getUpdateIndex, setUpdateIndex] = usePassiveState(useStableCallback(() => {
      updateParentControlIds(getSetter());
    }), returnZero);
    // Lots of machenery to track what total percentage of all checkboxes are checked,
    // and notifying the parent checkbox of this information (while re-rendering as little as possible)
    var getSelfIsChecked = T$1(percentChecked => {
      return percentChecked <= 0 ? false : percentChecked >= 1 ? true : "mixed";
    }, []);
    var onAnyChildCheckedUpdate = useStableCallback((setter, percentChecked) => {
      setter === null || setter === void 0 ? void 0 : setter(getSelfIsChecked(percentChecked));
    });
    var [getTotalChildren, setTotalChildren] = usePassiveState(T$1(totalChildren => {
      onAnyChildCheckedUpdate(getSetParentCheckboxChecked(), getPercentChecked(getTotalChecked(), totalChildren));
    }, []), returnZero);
    var [getTotalChecked, setTotalChecked] = usePassiveState(T$1(totalChecked => {
      onAnyChildCheckedUpdate(getSetParentCheckboxChecked(), getPercentChecked(totalChecked, getTotalChildren()));
    }, []), returnZero);
    var getPercentChecked = T$1((totalChecked, totalChildren) => {
      if (totalChildren > 0) return totalChecked / totalChildren;else return totalChecked == 0 ? 0 : 1;
    }, []);
    var [getSetParentCheckboxChecked, setSetParentCheckboxChecked] = usePassiveState(useStableCallback(setter => {
      onAnyChildCheckedUpdate(setter, getPercentChecked(getTotalChecked(), getTotalChildren()));
    }));
    var onCheckboxGroupParentInput = T$1( /*#__PURE__*/function () {
      var _ref58 = _asyncToGenerator(function* (e) {
        e.preventDefault();
        var selfIsChecked = getSelfIsChecked(getPercentChecked(getTotalChecked(), getTotalChildren()));
        var nextChecked = selfIsChecked === false ? "mixed" : selfIsChecked === "mixed" ? true : false;
        var willChangeAny = false;
        var promises = [];
        children.forEach(child => {
          if (child.checkboxInfo.checkboxChildType == "child") willChangeAny || (willChangeAny = child.checkboxInfo.getChecked() != child.checkboxInfo.getLastUserChecked());
        });
        children.forEach(child => {
          if (child.checkboxInfo.checkboxChildType == "child") {
            var prevChecked = child.checkboxInfo.getChecked();
            var checked;
            if (nextChecked == "mixed") {
              if (willChangeAny) checked = child.checkboxInfo.getLastUserChecked();else checked = true;
            } else {
              checked = nextChecked;
            }
            if (checked != prevChecked) {
              var promise = child.checkboxInfo.setCheckedFromParentInput(checked, e);
              if (promise) {
                promises.push(promise);
              }
            }
          }
        });
        yield Promise.all(promises);
      });
      return function (_x) {
        return _ref58.apply(this, arguments);
      };
    }(), []);
    return {
      linearNavigationReturn,
      context: useStableObject(_objectSpread(_objectSpread({}, context), {}, {
        checkboxGroupChildrenContext: useStableObject({
          setUpdateIndex,
          allIds: allIds.current,
          setTotalChecked,
          setTotalChildren
        }),
        checkboxGroupParentContext: useStableObject({
          setSetter,
          setSetParentCheckboxChecked,
          getPercentChecked,
          getTotalChecked,
          getTotalChildren,
          onCheckboxGroupParentInput
        })
      })),
      childrenHaveFocusReturn,
      props,
      rearrangeableChildrenReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      managedChildrenReturn,
      rovingTabIndexReturn,
      typeaheadNavigationReturn
      /*checkboxGroup: {
          parentIsChecked: getSelfIsCheckedUnstable() as boolean | "mixed",
          parentPercentChecked: (checkedCount / (children.getHighestIndex() + 1)),
      }*/
    };
  }
  // If the user has changed the parent checkbox's value, then this ref holds a memory of what values were held before.
  // Otherwise, it's null when the last input was from a child checkbox. 
  //const savedCheckedValues = useRef<Map<number, boolean | "mixed"> | null>(null);
  function useCheckboxGroupParent(_ref59) {
    var {
      completeListNavigationChildParameters,
      context,
      managedChildParameters,
      pressParameters,
      rovingTabIndexChildParameters,
      textContentParameters,
      sortableChildParameters
    } = _ref59;
    var {
      checkboxGroupParentContext: {
        setSetter,
        setSetParentCheckboxChecked,
        getPercentChecked,
        getTotalChecked,
        getTotalChildren,
        onCheckboxGroupParentInput
      }
    } = context;
    //const focusSelf = useCallback((e: any) => (e as Element as HTMLElement).focus?.(), []);
    var {
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      props,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
    } = useCompleteListNavigationChild({
      completeListNavigationChildParameters,
      context,
      managedChildParameters,
      pressParameters,
      rovingTabIndexChildParameters,
      sortableChildParameters,
      textContentParameters,
      // single selection isn't used because checkboxes are multiselect; "disabled" refers only to that.
      singleSelectionChildParameters: {
        ariaPropName: null,
        selectionMode: "disabled",
        disabled: true
      }
    });
    var [ariaControls, setControls] = useState("");
    s(() => {
      setSetter(() => setControls);
    }, [setControls]);
    var [checked, setChecked] = useState(false);
    h(() => {
      setSetParentCheckboxChecked(() => setChecked);
    }, []);
    var checkboxGroupParentReturn = {
      checked,
      onParentCheckedChange: onCheckboxGroupParentInput,
      getPercent: useStableCallback(() => {
        return getPercentChecked(getTotalChecked(), getTotalChildren());
      })
    };
    return {
      checkboxGroupParentReturn,
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      props: useMergedProps({
        "aria-controls": ariaControls
      }, props),
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
      /*checkboxGroupParentReturn,
      hasCurrentFocusParameters,
      rovingTabIndexChildReturn,
      useCheckboxGroupParentProps: function useCheckboxGroupParentInputProps(props: h.JSX.HTMLAttributes<InputElement>): h.JSX.HTMLAttributes<InputElement> {
          return useMergedProps({ "aria-controls": ariaControls } as h.JSX.HTMLAttributes<InputElement>, props);
      }*/
    };
  }

  function useCheckboxGroupChild(_ref60) {
    var {
      checkboxGroupChild,
      completeListNavigationChildParameters,
      context,
      managedChildParameters,
      pressParameters,
      textContentParameters,
      rovingTabIndexChildParameters,
      sortableChildParameters
    } = _ref60;
    var {
      checkboxGroupChildrenContext: {
        allIds,
        setUpdateIndex,
        setTotalChildren,
        setTotalChecked
      }
    } = context;
    debugLog("useCheckboxGroupChild", managedChildParameters.index);
    //const { checkbox: { onCheckedChange }, checkboxLike: { checked, disabled, labelPosition }, label: { tagInput, tagLabel }, hasFocusInput, hasFocusLabel } = asCheckbox;
    //const { subInfo, checkboxGroupChild: { checked, focusSelf, onChangeFromParent } } = asCheckboxGroupChild;
    var {
      checked,
      onChangeFromParent
    } = checkboxGroupChild;
    var getChecked = useStableGetter(checked);
    //labelPosition ??= "separate";
    var [getLastUserChecked, setLastUserChecked] = usePassiveState(null, returnFalse);
    var onChildCheckedChange = useStableCallback(checked => {
      setLastUserChecked(checked);
    });
    var onControlIdChanged = T$1((next, prev) => {
      if (prev) allIds.delete(prev);
      if (next) allIds.add(next);
      if (!!next || !!prev) {
        setUpdateIndex(i => (i !== null && i !== void 0 ? i : 0) + 1);
      }
    }, []);
    h(() => {
      setTotalChildren(c => (c !== null && c !== void 0 ? c : 0) + 1);
      return () => setTotalChildren(c => (c !== null && c !== void 0 ? c : 0) - 1);
    }, []);
    h(() => {
      if (checked) {
        setTotalChecked(c => (c !== null && c !== void 0 ? c : 0) + 1);
        return () => setTotalChecked(c => (c !== null && c !== void 0 ? c : 0) - 1);
      }
    }, [checked]);
    var {
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      props,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
    } = useCompleteListNavigationChild({
      completeListNavigationChildParameters: _objectSpread({
        checkboxInfo: {
          checkboxChildType: "child",
          getLastUserChecked,
          getChecked,
          setCheckedFromParentInput: onChangeFromParent
        }
      }, completeListNavigationChildParameters),
      context,
      managedChildParameters: _objectSpread({}, managedChildParameters),
      pressParameters,
      rovingTabIndexChildParameters,
      textContentParameters,
      sortableChildParameters,
      singleSelectionChildParameters: {
        ariaPropName: null,
        selectionMode: "disabled",
        disabled: true
      }
      //subInfo: { type: "child", getLastUserChecked, setCheckedFromParentInput: onChangeFromParent, getChecked, subInfo },
      /*listNavigationChildParameters: asCheckboxGroupChild.listNavigationChildParameters,
      managedChildParameters: asCheckboxGroupChild.managedChildParameters,
      refElementReturn: asCheckboxGroupChild.refElementReturn,
      rovingTabIndexChildParameters: { ...asCheckboxGroupChild.rovingTabIndexChildParameters, focusSelf }*/
    });

    return {
      checkboxGroupChild: {
        onChildCheckedChange,
        onControlIdChanged
      },
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      props,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
    };
  }
  function useDialog(_ref61) {
    var {
      dismissParameters,
      escapeDismissParameters,
      focusTrapParameters,
      labelParameters
    } = _ref61;
    var {
      focusTrapReturn,
      propsFocusContainer,
      propsPopup,
      propsSource,
      refElementPopupReturn,
      refElementSourceReturn
    } = useModal({
      dismissParameters: _objectSpread({
        closeOnLostFocus: false
      }, dismissParameters),
      escapeDismissParameters,
      focusTrapParameters: _objectSpread({
        trapActive: true,
        onlyMoveFocus: false
      }, focusTrapParameters)
    });
    var {
      propsInput,
      propsLabel
    } = useLabelSynthetic({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: useStableCallback(() => {
          var e = refElementPopupReturn.getElement();
          focusTrapParameters.focusPopup(e, () => findFirstFocusable(e));
        })
      }),
      randomIdInputParameters: {
        prefix: Prefices.dialog
      },
      randomIdLabelParameters: {
        prefix: Prefices.dialogTitle
      }
    });
    return {
      focusTrapReturn,
      propsFocusContainer,
      propsDialog: useMergedProps(propsPopup, propsInput),
      propsSource,
      propsTitle: propsLabel,
      refElementPopupReturn,
      refElementSourceReturn
    };
  }
  function useDrawer(_ref62) {
    var {
      dismissParameters,
      escapeDismissParameters,
      focusTrapParameters,
      labelParameters
    } = _ref62;
    var {
      focusTrapReturn,
      propsFocusContainer,
      propsPopup,
      propsSource,
      refElementPopupReturn,
      refElementSourceReturn
    } = useModal({
      dismissParameters,
      escapeDismissParameters,
      focusTrapParameters: _objectSpread({
        onlyMoveFocus: false
      }, focusTrapParameters)
    });
    var {
      propsInput,
      propsLabel
    } = useLabelSynthetic({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: useStableCallback(() => {
          var e = refElementPopupReturn.getElement();
          focusTrapParameters.focusPopup(e, () => findFirstFocusable(e));
        })
      }),
      randomIdInputParameters: {
        prefix: Prefices.drawer
      },
      randomIdLabelParameters: {
        prefix: Prefices.drawerTitle
      }
    });
    return {
      focusTrapReturn,
      propsFocusContainer,
      propsDrawer: useMergedProps(propsPopup, propsInput),
      propsTitle: propsLabel,
      propsSource,
      refElementPopupReturn,
      refElementSourceReturn
    };
  }
  function useGridlist(_ref63) {
    var {
      linearNavigationParameters,
      rovingTabIndexParameters,
      typeaheadNavigationParameters,
      labelParameters,
      gridlistParameters: {
        selectionLimit,
        groupingType,
        selectedIndex,
        setSelectedIndex
      },
      gridNavigationParameters,
      rearrangeableChildrenParameters,
      sortableChildrenParameters
    } = _ref63;
    var {
      propsInput: propsLabelList,
      propsLabel: propsLabelLabel,
      randomIdInputReturn: {
        id: _gridlistId
      },
      randomIdLabelReturn: {
        id: _labelId
      }
    } = useLabelSynthetic({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: useStableCallback(() => {
          rovingTabIndexReturn.focusSelf();
        })
      }),
      randomIdInputParameters: {
        prefix: Prefices.gridlist
      },
      randomIdLabelParameters: {
        prefix: Prefices.gridlistLabel
      }
    });
    var {
      childrenHaveFocusReturn,
      context,
      linearNavigationReturn,
      managedChildrenReturn,
      props,
      rovingTabIndexReturn,
      singleSelectionReturn,
      typeaheadNavigationReturn,
      rearrangeableChildrenReturn,
      sortableChildrenReturn
    } = useCompleteGridNavigation({
      linearNavigationParameters,
      rovingTabIndexParameters,
      singleSelectionParameters: {
        initiallySelectedIndex: selectedIndex,
        setSelectedIndex
      },
      sortableChildrenParameters,
      typeaheadNavigationParameters,
      gridNavigationParameters,
      rearrangeableChildrenParameters
    });
    useSingleSelectionDeclarative({
      singleSelectionReturn,
      singleSelectionDeclarativeParameters: {
        selectedIndex
      }
    });
    var propsGridlist = useMergedProps(props, propsLabelList, {
      "aria-multiselectable": selectionLimit == "multi" ? "true" : undefined
    });
    var fullContext = useStableObject(_objectSpread(_objectSpread({}, context), {}, {
      gridlistRowContext: useStableObject({
        selectionLimit
      })
    }));
    if (groupingType == "group") propsGridlist.role = "group";else if (groupingType == "with-groups") {
      // Intentionally clobbering all the list navigation stuff.
      propsGridlist = {
        role: "grid"
      };
      // ...actually, context too while we're at it.
      fullContext = null;
    } else {
      propsGridlist.role = "grid";
    }
    if (selectionLimit == "multi") console.assert(singleSelectionReturn.getSelectedIndex() == null);
    return {
      childrenHaveFocusReturn,
      context: fullContext,
      linearNavigationReturn,
      managedChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      rearrangeableChildrenReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn,
      propsGridlist,
      propsGridlistLabel: propsLabelLabel
    };
  }
  function useGridlistRow(_ref64) {
    var {
      asChildRowParameters: {
        managedChildParameters,
        singleSelectionChildParameters,
        completeGridNavigationRowParameters,
        textContentParameters,
        rovingTabIndexChildParameters,
        sortableChildParameters,
        context: cx1,
        gridlistRowParameters: {
          selected
        }
      },
      asParentRowParameters: {
        linearNavigationParameters,
        rovingTabIndexParameters,
        typeaheadNavigationParameters
      }
    } = _ref64;
    var {
      gridlistRowContext: {
        selectionLimit
      }
    } = cx1;
    var {
      asChildRowReturn,
      asParentRowReturn,
      context: cx2,
      managedChildReturn,
      hasCurrentFocusReturn,
      props
    } = useCompleteGridNavigationRow({
      asChildRowParameters: {
        managedChildParameters,
        textContentParameters,
        singleSelectionChildParameters,
        completeGridNavigationRowParameters,
        rovingTabIndexChildParameters,
        sortableChildParameters,
        context: cx1
      },
      asParentRowParameters: {
        linearNavigationParameters: _objectSpread({}, linearNavigationParameters),
        rovingTabIndexParameters,
        typeaheadNavigationParameters: _objectSpread({}, typeaheadNavigationParameters)
      }
    });
    if (selectionLimit == "single") console.assert(selected == null);
    props.role = "option";
    return {
      asChildRowReturn,
      asParentRowReturn,
      context: cx2,
      managedChildReturn,
      hasCurrentFocusReturn,
      props
    };
  }
  function useGridlistCell(p) {
    return useCompleteGridNavigationCell(p);
  }
  /*
  export const useGridlistSection = <BodySectionElement extends Element, RowElement extends Element>({ compareRows }: UseGridlistSectionParameters) => {
      //debugLog("useGridlistSection");
      //type CRFull = UseRovingTabIndexSubInfo<RowElement, UseListNavigationSubInfo<UseGridlistRowSubInfo<CellElement, CR, CC>>>;
      const getIndex = useCallback<GetIndex<any>>((i) => i.props.index, []);
        const {
          linearNavigationParameters,
          rearrangeableChildrenReturn,
          sortableChildrenReturn
      } = useSortableChildren<BodySectionElement, GridlistRowInfo<RowElement>>({
          rearrangeableChildrenParameters: {
              getIndex,
              getHighestChildIndex,
              getValid
          },
          sortableChildrenParameters: {
              compare: (lhs, rhs) => {
                  if (lhs.locationIndex === rhs.locationIndex)
                      return compareRows(lhs.index, rhs.index);
                  return lhs.locationIndex - rhs.locationIndex;
              }
          }
      });
       const useGridlistSectionProps = (props: h.JSX.HTMLAttributes<BodySectionElement>) => {
          console.assert(props.children != null);
          overwriteWithWarning("useGridlistSection", props, "role", "rowgroup");
          return useSortableProps(props as h.JSX.HTMLAttributes<BodySectionElement> & { children: any });
      }
       return {
          useGridlistSectionProps,
          ...sortableRet
      }
  }*/

  //export interface UseMenuButtonReturnTypeInfo extends UseListNavigationChildReturnTypeInfo<never> { }
  /*
  export interface UseMenuSurfaceReturnTypeWithHooks<MenuSurfaceElement extends Element, MenuParentElement extends Element, MenuButtonElement extends Element> extends UseMenuSurfaceReturnTypeInfo<MenuSurfaceElement, MenuButtonElement> {
      useMenuSurfaceSentinel: <E extends Element>() => { useMenuSentinelProps: (p: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; };
      useMenuSurfaceProps: (props: h.JSX.HTMLAttributes<MenuSurfaceElement>) => h.JSX.HTMLAttributes<MenuSurfaceElement>;
      useMenuSurfaceChildProps: (props: h.JSX.HTMLAttributes<MenuParentElement>) => h.JSX.HTMLAttributes<MenuParentElement>;  // NOT a menu item! This is the menu, dialog, popup, whatever actually gets the role, as opposed to the surface that listens to mouse and keyboard events
      useMenuSurfaceButtonProps: (props: h.JSX.HTMLAttributes<MenuButtonElement>) => h.JSX.HTMLAttributes<any>;
   }*/
  //export interface UseMenuButtonReturnTypeWithHooks extends UseMenuButtonReturnTypeInfo { }
  /**
   * A menu surface is what handles user interaction with an interactive but transient surface (like a menu or a popup).
   *
   * The keyboard (etc.) interactions are shared among a lot of widgets, and the opening button has some ARIA properties that need setting.
   *
   * Related to menus, which are a menu contained within a menu surface. Not related to menubars -- menus contain menubars, but not all menubars are contained within a menu or its surface.
   *
   */
  function useMenuSurface(_ref65) {
    var {
      //menuSurface: { sendFocusToMenu, role }, 
      dismissParameters,
      escapeDismissParameters,
      focusTrapParameters,
      menuSurfaceParameters: {
        role
      }
    } = _ref65;
    var {
      propsReferencer: propsIdTrigger,
      propsSource: propsIdTarget
    } = useRandomId({
      randomIdParameters: {
        prefix: Prefices.menu,
        otherReferencerProp: "aria-controls"
      }
    });
    var _useRefElement = useRefElement({
        refElementParameters: {
          onElementChange: undefined
        }
      }),
      {
        refElementReturn: {
          getElement: getButtonElement,
          propsStable: propsRefTrigger
        }
      } = _useRefElement,
      void4 = _objectWithoutProperties(_useRefElement, _excluded58);
    var _useRefElement2 = useRefElement({
        refElementParameters: {
          onElementChange: undefined
        }
      }),
      {
        refElementReturn: {
          getElement: getMenuElement,
          propsStable: propsRefSurface
        }
      } = _useRefElement2,
      void5 = _objectWithoutProperties(_useRefElement2.refElementReturn, _excluded60),
      void6 = _objectWithoutProperties(_useRefElement2, _excluded59);
    var {
      focusTrapReturn,
      // Intentinally ignored for menus, since they don't trap focus like most modals.
      // propsFocusContainer,
      propsPopup,
      propsSource: ps2,
      refElementPopupReturn,
      refElementSourceReturn
    } = useModal({
      dismissParameters,
      escapeDismissParameters,
      focusTrapParameters: _objectSpread(_objectSpread({}, focusTrapParameters), {}, {
        onlyMoveFocus: true,
        trapActive: true,
        focusOpener: useStableCallback(() => {
          var buttonElement = getButtonElement();
          buttonElement === null || buttonElement === void 0 ? void 0 : buttonElement.focus();
        })
      })
    });
    var propsSurface = useMergedProps(propsRefSurface, propsPopup);
    var propsTarget = useMergedProps({
      role
    }, propsIdTarget);
    var propsTrigger = useMergedProps({
      "aria-expanded": dismissParameters.open.toString(),
      "aria-haspopup": role
    }, propsRefTrigger, ps2, propsIdTrigger);
    var propsSentinel = useFocusSentinel({
      focusSentinel: {
        sendFocusToMenu: T$1(() => {
          return focusTrapParameters.focusPopup(getMenuElement(), () => findFirstFocusable(getMenuElement()));
        }, []),
        onClose: T$1(() => {
          dismissParameters.onClose("lost-focus");
        }, [dismissParameters.onClose]),
        open: dismissParameters.open
      }
    });
    return {
      focusTrapReturn,
      propsSentinel,
      propsSurface,
      propsTarget,
      propsTrigger,
      refElementPopupReturn,
      refElementSourceReturn
    };
  }
  // A focus sentinal is a hidden but focusable element that comes at the start or end 
  // of the out-of-place-focusable component that, when activated or focused over, closes the component
  // (if focused within 100ms of the open prop changing, instead of
  // closing, focusing the sentinel immediately asks it to focus itself).
  // This exists for things like menus which can have focus but also need a way to return
  // to whatever out-of-place parent they came from when naturally tabbed out of (as opposed
  // to dialogs which loop back around when tabbed out of). While mouse users can click out of a menu
  // and keyboard users can escape to close a menu, screen readers and other input methods 
  // that don't use those two would become stuck.
  function useFocusSentinel(_ref66) {
    var {
      focusSentinel: {
        open,
        onClose,
        sendFocusToMenu
      }
    } = _ref66;
    var getSendFocusWithinMenu = useStableGetter(sendFocusToMenu);
    var stableOnClose = useStableCallback(onClose);
    var [firstSentinelIsActive, setFirstSentinelIsActive] = useState(false);
    useTimeout({
      callback: () => {
        setFirstSentinelIsActive(open);
      },
      timeout: 100,
      triggerIndex: "".concat(open, "-").concat(firstSentinelIsActive)
    });
    var onFocus = firstSentinelIsActive ? () => stableOnClose() : () => {
      var _getSendFocusWithinMe;
      return (_getSendFocusWithinMe = getSendFocusWithinMenu()) === null || _getSendFocusWithinMe === void 0 ? void 0 : _getSendFocusWithinMe();
    };
    var onClick = () => stableOnClose();
    return {
      tabIndex: firstSentinelIsActive ? 0 : -1,
      onFocus,
      onClick
    };
  }

  //export interface UseToolbarChildReturnTypeWithHooks<ChildElement extends Element, M extends UseToolbarSubInfo<ChildElement>> extends UseToolbarChildReturnTypeInfo<ChildElement, M> {
  //}
  /**
   * A toolbar is just a collection of widgets in an expected order and with the usual keyboard navigation stuff.
   *
   * The main difference between a toolbar and a menubar is that a menubar contains purely static menuitems,
   * but a toolbar is the more general case, being able to contain anything at all.
   * A menubar is implemented as a special case of a toolbar, and a menu is implemented as a specialized menubar
   *
   * Either way, be sure to specify the role and orientation this toolbar has (role=toolbar if you're using this as an actual toolbar).
   *
   * @param param0
   * @returns
   */
  function useToolbar(_ref67) {
    var {
        linearNavigationParameters,
        toolbarParameters: {
          orientation,
          role
        }
      } = _ref67,
      listNavParameters = _objectWithoutProperties(_ref67, _excluded61);
    var _useCompleteListNavig = useCompleteListNavigation(_objectSpread(_objectSpread({}, listNavParameters), {}, {
        linearNavigationParameters: _objectSpread(_objectSpread({}, linearNavigationParameters), {}, {
          navigationDirection: orientation
        })
      })),
      {
        context,
        props
      } = _useCompleteListNavig,
      listNavReturn = _objectWithoutProperties(_useCompleteListNavig, _excluded62);
    return _objectSpread({
      toolbarReturn: {
        propsUnstable: {
          role: role !== null && role !== void 0 ? role : undefined
        }
      },
      context,
      props
    }, listNavReturn);
  }
  function useToolbarChild(_ref68) {
    var listNavChildParameters = _extends({}, (_objectDestructuringEmpty(_ref68), _ref68));
    return useCompleteListNavigationChild(_objectSpread({}, listNavChildParameters));
  }

  //export type UseMenuItemProps<MenuItemElement extends Element> = (props: h.JSX.HTMLAttributes<MenuItemElement>) => h.JSX.HTMLAttributes<MenuItemElement>;
  //export type UseMenuItem<MenuItemElement extends Element, M extends UseMenubarSubInfo<MenuItemElement>> = (args: UseMenuItemParameters<MenuItemElement, M>) => UseMenuItemReturnType<MenuItemElement, M>;
  function useMenubar(_ref69) {
    var {
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      singleSelectionParameters,
      sortableChildrenParameters,
      rovingTabIndexParameters,
      typeaheadNavigationParameters,
      toolbarParameters,
      menubarParameters: {
        role
      }
    } = _ref69;
    var _useToolbar = useToolbar({
        linearNavigationParameters,
        rovingTabIndexParameters,
        rearrangeableChildrenParameters,
        singleSelectionParameters,
        sortableChildrenParameters,
        typeaheadNavigationParameters,
        toolbarParameters: _objectSpread({
          role
        }, toolbarParameters)
      }),
      {
        linearNavigationReturn,
        childrenHaveFocusReturn,
        context,
        props,
        rearrangeableChildrenReturn,
        singleSelectionReturn,
        sortableChildrenReturn,
        managedChildrenReturn,
        rovingTabIndexReturn,
        toolbarReturn,
        typeaheadNavigationReturn
      } = _useToolbar,
      _rest = _objectWithoutProperties(_useToolbar, _excluded63);
    return {
      childrenHaveFocusReturn,
      context,
      props,
      rearrangeableChildrenReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      linearNavigationReturn,
      managedChildrenReturn,
      rovingTabIndexReturn,
      toolbarReturn,
      typeaheadNavigationReturn
    };
  }
  function useMenubarChild(_ref70) {
    var {
        managedChildParameters,
        singleSelectionChildParameters,
        completeListNavigationChildParameters,
        rovingTabIndexChildParameters,
        sortableChildParameters,
        context,
        textContentParameters,
        menuItemParameters: {
          onPress,
          role
        }
      } = _ref70,
      pressParameters = _extends({}, (_objectDestructuringEmpty(_ref70.pressParameters), _ref70.pressParameters));
    debugLog("useMenuItem", managedChildParameters.index);
    var disabled = singleSelectionChildParameters.disabled;
    var focusSelf = T$1(e => {
      var _e$focus3;
      return (_e$focus3 = e.focus) === null || _e$focus3 === void 0 ? void 0 : _e$focus3.call(e);
    }, []);
    var {
      hasCurrentFocusReturn,
      pressReturn,
      props,
      singleSelectionChildReturn,
      rovingTabIndexChildReturn,
      managedChildReturn
    } = useToolbarChild({
      completeListNavigationChildParameters,
      context,
      managedChildParameters,
      rovingTabIndexChildParameters,
      sortableChildParameters,
      textContentParameters,
      pressParameters: _objectSpread({
        focusSelf,
        onPressSync: e => {
          var _ref71;
          return (_ref71 = disabled ? null : onPress) === null || _ref71 === void 0 ? void 0 : _ref71(enhanceEvent(e, {
            index: managedChildParameters.index
          }));
        }
      }, pressParameters),
      singleSelectionChildParameters
      /*listNavigationChildParameters,
      pressParameters: {
          onClickSync: (e) => (disabled ? null : onPress)?.(enhanceEvent(e, { index: managedChildParameters.index })),
          exclude: undefined,
          focusSelf: rovingTabIndexChildParameters.focusSelf
      },
      singleSelectionChildParameters,
      typeaheadNavigationChildParameters,
      completeListNavigationChildParameters,
      managedChildParameters,
      rovingTabIndexChildParameters,
      refElementReturn,
      subInfo: { subInfo }*/
    });
    /*function useMenuItemProps(props: h.JSX.HTMLAttributes<MenuItemElement>) {
        overwriteWithWarning("useMenuItem", props, "role", role);
        return useMergedProps(pressReturn.propsStable, pressReturn.propsUnstable, props);
    }*/
    props.role = role;
    return {
      hasCurrentFocusReturn,
      pressReturn,
      props,
      singleSelectionChildReturn,
      rovingTabIndexChildReturn,
      managedChildReturn
    };
  }

  /*
  export interface UseMenuReturnTypeWithHooks<MenuSurfaceElement extends Element, MenuParentElement extends Element, MenuItemElement extends Element, MenuButtonElement extends Element, C, K extends string> extends UseMenuReturnTypeInfo<MenuSurfaceElement, MenuParentElement, MenuItemElement, MenuButtonElement, C, K> {
      useMenuSentinel: <E extends Element>() => { useMenuSentinelProps: (p: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; };
      useMenuProps: (props: h.JSX.HTMLAttributes<MenuParentElement>) => h.JSX.HTMLAttributes<MenuParentElement>;
      useMenuSurfaceProps: (props: h.JSX.HTMLAttributes<MenuSurfaceElement>) => h.JSX.HTMLAttributes<MenuSurfaceElement>;
      useMenuButtonProps: (props: h.JSX.HTMLAttributes<MenuButtonElement>) => h.JSX.HTMLAttributes<MenuButtonElement>;
      useMenuItem: UseMenuItem<MenuItemElement, C, K>;
  }*/
  function useMenu(_ref72) {
    var {
      dismissParameters,
      escapeDismissParameters,
      linearNavigationParameters,
      menuParameters: {
        openDirection,
        onOpen
      },
      menuSurfaceParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      singleSelectionParameters,
      sortableChildrenParameters,
      toolbarParameters,
      typeaheadNavigationParameters
    } = _ref72;
    var {
      childrenHaveFocusReturn,
      context,
      linearNavigationReturn,
      managedChildrenReturn,
      props: propsMenubar,
      rearrangeableChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      toolbarReturn,
      typeaheadNavigationReturn
    } = useMenubar({
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      singleSelectionParameters,
      sortableChildrenParameters,
      typeaheadNavigationParameters,
      toolbarParameters: _objectSpread({}, toolbarParameters),
      menubarParameters: {
        role: "menu"
      }
    });
    var onKeyDown = useStableCallback(e => {
      var isOpen = dismissParameters.open;
      if (!isOpen) {
        switch (e.key) {
          case "ArrowUp":
            {
              if (openDirection == 'up') {
                onOpen();
                e.preventDefault();
              }
              break;
            }
          case "ArrowDown":
            {
              if (openDirection == 'down') {
                onOpen();
                e.preventDefault();
              }
              break;
            }
          case "ArrowLeft":
            {
              if (openDirection == 'left') {
                onOpen();
                e.preventDefault();
              }
              break;
            }
          case "ArrowRight":
            {
              if (openDirection == 'right') {
                onOpen();
                e.preventDefault();
              }
              break;
            }
        }
      }
    });
    var {
      focusTrapReturn,
      propsSentinel,
      propsSurface,
      propsTarget,
      propsTrigger,
      refElementPopupReturn,
      refElementSourceReturn
    } = useMenuSurface({
      menuSurfaceParameters: _objectSpread(_objectSpread({}, menuSurfaceParameters), {}, {
        role: "menu"
      }),
      dismissParameters,
      escapeDismissParameters,
      focusTrapParameters: {
        focusPopup: () => {
          debugger;
          rovingTabIndexReturn.focusSelf();
        }
      }
    });
    return {
      childrenHaveFocusReturn,
      context,
      focusTrapReturn,
      linearNavigationReturn,
      managedChildrenReturn,
      propsSentinel,
      propsSurface,
      propsTarget: useMergedProps(propsTarget, propsMenubar),
      propsTrigger: useMergedProps({
        onKeyDown
      }, propsTrigger),
      rearrangeableChildrenReturn,
      refElementPopupReturn,
      refElementSourceReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      toolbarReturn,
      typeaheadNavigationReturn
      /*focusMenu,
       currentTypeahead,
      invalidTypeahead,
       managedChildren,*/
    };
  }

  function useMenuItem(p) {
    return useMenubarChild(p);
  }
  function useRadioGroup(_ref73) {
    var {
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      sortableChildrenParameters,
      typeaheadNavigationParameters,
      labelParameters,
      radioGroupParameters: {
        name,
        setSelectedValue: setSelectedValueExternal,
        selectedValue
      }
    } = _ref73;
    //debugLog("useRadioGroup", selectedValue);
    //const { refElementReturn: { getElement: _getGroupElement, propsStable } } = useRefElement<G>({ refElementParameters: {} });
    var [selectedIndex, setSelectedIndex] = useState(null);
    var byName = _(new Map());
    /*const setSelectedValue = useCallback((value: V | null) => {
        if (value == null) {
            setSelectedIndex(null);
            return;
        }
        const newIndex = byName.current.get(value);
        setSelectedIndex(newIndex ?? null);
    }, [])*/
    var {
      propsInput: propsGroup1,
      propsLabel
    } = useLabelSynthetic({
      labelParameters: _objectSpread({
        onLabelClick: useStableCallback(() => {
          rovingTabIndexReturn.focusSelf();
        })
      }, labelParameters),
      randomIdLabelParameters: {
        prefix: Prefices.radioGroupLabel
      },
      randomIdInputParameters: {
        prefix: Prefices.radioGroup
      }
    });
    /*const onSelectedIndexChange = useStableCallback((newIndex: number | null) => {
        if (newIndex != null) {
            const child = managedChildrenReturn.getChildren().getAt(newIndex);
            if (child) {
                onSelectedValueChange(child.getValue2() ?? null)
                return;
            }
        }
        onSelectedValueChange(null);
        //onSelectedValueChange(enhanceEvent<TCE, Event, { selectedValue: V | undefined }>(e, { selectedValue: managedChildrenReturn.getChildren().getAt(newIndex)?.getValue() }));
    });*/
    h(() => {
      var _byName$current$get;
      if (selectedValue != null) singleSelectionReturn.setSelectedIndex((_byName$current$get = byName.current.get(selectedValue)) !== null && _byName$current$get !== void 0 ? _byName$current$get : null);else singleSelectionReturn.setSelectedIndex(null);
    }, [selectedValue]);
    var {
      childrenHaveFocusReturn,
      context,
      props: propsGroup2,
      linearNavigationReturn,
      managedChildrenReturn,
      rearrangeableChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn
    } = useCompleteListNavigation({
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      singleSelectionParameters: {
        initiallySelectedIndex: selectedIndex,
        setSelectedIndex
      },
      sortableChildrenParameters,
      typeaheadNavigationParameters
    });
    useSingleSelectionDeclarative({
      singleSelectionReturn: {
        setSelectedIndex: useStableCallback(s => {
          debugger;
          var next = typeof s == "function" ? s(selectedIndex) : s;
          if (next != null) {
            var _managedChildrenRetur;
            var nextValue = (_managedChildrenRetur = managedChildrenReturn.getChildren().getAt(next)) === null || _managedChildrenRetur === void 0 ? void 0 : _managedChildrenRetur.getValue2();
            setSelectedValueExternal(nextValue);
          } else {
            setSelectedValueExternal(null);
          }
        })
      },
      singleSelectionDeclarativeParameters: {
        selectedIndex
      }
    });
    var propsRadioGroup = useMergedProps(propsGroup1, propsGroup2, {
      role: "radiogroup"
    });
    /*useEffect(() => {
        if (selectedValue == null) {
            setSelectedIndex(null)
        }
        else {
            const selectedIndex = byName.current.get(selectedValue);
            setSelectedIndex(selectedIndex ?? null);
        }
    }, [byName, selectedValue]);*/
    return {
      propsRadioGroup,
      propsRadioGroupLabel: propsLabel,
      childrenHaveFocusReturn,
      context: _objectSpread(_objectSpread({}, context), {}, {
        radioContext: {
          name,
          byName: byName.current
        }
      }),
      linearNavigationReturn,
      managedChildrenReturn,
      radioGroupReturn: {
        selectedIndex
      },
      rearrangeableChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn
    };
  }
  /*export interface UseRadioReturnTypeWithHooks<I extends Element, L extends Element> extends UseRadioReturnTypeInfo<I, L> {
      useRadioInput: UseRadioInput<I>;
      useRadioLabel: UseRadioLabel<L>;
  }*/
  //type UseRadioInput<I extends Element> = ({ tag }: TagSensitiveProps<I>) => { useRadioInputProps: (props: h.JSX.HTMLAttributes<I>) => h.JSX.HTMLAttributes<I>; }
  //type UseRadioLabel<L extends Element> = ({ tag }: TagSensitiveProps<L>) => { useRadioLabelProps: (props: h.JSX.HTMLAttributes<L>) => h.JSX.HTMLAttributes<L>; }
  //export type UseRadio<V extends string | number, I extends Element, L extends Element, C, K extends string> = (a: UseRadioParameters<V, I, L, C, K>) => UseRadioReturnTypeWithHooks<I, L>
  function useRadio(_ref74) {
    var {
      radioParameters: {
        value
      },
      checkboxLikeParameters: {
        disabled
      },
      completeListNavigationChildParameters,
      labelParameters,
      managedChildParameters,
      pressParameters,
      singleSelectionChildParameters,
      context,
      textContentParameters,
      rovingTabIndexChildParameters,
      sortableChildParameters
    } = _ref74;
    var index = managedChildParameters.index;
    var onInput = useStableCallback(e => {
      debugger;
      singleSelectionChildReturn.setThisOneSelected(e);
    });
    var {
      name,
      byName
    } = context.radioContext;
    var {
      tagInput,
      tagLabel,
      labelPosition
    } = labelParameters;
    var getValue = useStableGetter(value);
    var {
      props: listNavigationSingleSelectionChildProps,
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
    } = useCompleteListNavigationChild({
      completeListNavigationChildParameters: {
        getValue2: getValue
      },
      managedChildParameters,
      pressParameters,
      context,
      rovingTabIndexChildParameters,
      sortableChildParameters,
      textContentParameters,
      /*rovingTabIndex,
      managedChild: {
          index: managedChild.index,
          flags: managedChild.flags
      },
      hasFocus,
      subInfo: { getValue, subInfo },*/
      singleSelectionChildParameters: _objectSpread({
        ariaPropName: tagInput == "input" && labelPosition == "separate" ? null : "aria-selected"
      }, singleSelectionChildParameters)
    });
    var {
      selected: checked
    } = singleSelectionChildReturn;
    var {
      refElementReturn: refElementInputReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      refElementReturn: refElementLabelReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      checkboxLikeInputReturn,
      checkboxLikeLabelReturn,
      pressInputReturn,
      pressLabelReturn,
      propsInput,
      propsLabel,
      randomIdInputReturn,
      randomIdLabelReturn,
      checkboxLikeReturn
    } = useCheckboxLike({
      checkboxLikeParameters: {
        checked: checked !== null && checked !== void 0 ? checked : false,
        disabled,
        onInput: onInput,
        role: "radio"
      },
      labelParameters,
      randomIdInputParameters: {
        prefix: Prefices.radio
      },
      randomIdLabelParameters: {
        prefix: Prefices.radioLabel
      },
      refElementInputReturn,
      refElementLabelReturn
    });
    s(() => {
      byName.set(value, index);
      return () => {
        byName.delete(value);
      };
    }, [value, index]);
    //const useRadioInput = () => {
    if (tagInput == "input") {
      propsInput.name = name;
      propsInput.checked = checked !== null && checked !== void 0 ? checked : false;
      propsInput.type = "radio";
    } else {
      propsInput["aria-checked"] = (checked !== null && checked !== void 0 ? checked : false).toString();
    }
    var propsIfInputHandlesFocus = useMergedProps(listNavigationSingleSelectionChildProps, propsInput);
    var propsInput2 = labelPosition == "separate" ? propsIfInputHandlesFocus : propsInput;
    // };
    //const useRadioLabel: UseRadioLabel<IL> = useCallback(() => {
    //const tag = tagLabel;
    //const useRadioLabelProps = (propsLabel: h.JSX.HTMLAttributes<IL>): h.JSX.HTMLAttributes<IL> => {
    //const { useCheckboxLikeLabelElementProps } = useCheckboxLikeLabelElement();
    var propsIfLabelHandlesFocus = useMergedProps(listNavigationSingleSelectionChildProps, propsLabel);
    var propsLabel2 = labelPosition == "wrapping" ? propsIfLabelHandlesFocus : propsLabel;
    //};
    //return {
    //    useRadioLabelProps
    //}
    //}, [useCheckboxLikeLabelElement]);
    return {
      checkboxLikeInputReturn,
      checkboxLikeLabelReturn,
      managedChildReturn,
      pressInputReturn,
      pressLabelReturn,
      propsInput: propsInput2,
      propsLabel: propsLabel2,
      randomIdInputReturn,
      randomIdLabelReturn,
      hasCurrentFocusReturn,
      rovingTabIndexChildReturn,
      pressReturn,
      singleSelectionChildReturn,
      checkboxLikeReturn
    };
  }
  function useSlider(_ref75) {
    var {
      sliderParameters: {
        max,
        min
      },
      managedChildrenParameters
    } = _ref75;
    var {
      context,
      managedChildrenReturn
    } = useManagedChildren({
      managedChildrenParameters
    });
    var baseIdRef = _(null);
    if (baseIdRef.current === null) baseIdRef.current = generateRandomId(Prefices.sliderThumb);
    //const { propsReferencer, propsSource, randomIdReturn: { id: baseId } } = useRandomId<LabelElement, ThumbElement>({ randomIdParameters: { prefix: "aria-thumb-", otherReferencerProp: "aria-labelledby" } })
    /*const {
        propsInput,
        propsLabel,
        randomIdInputReturn,
        randomIdLabelReturn
    } = useLabel<ThumbElement, LabelElement>({ labelParameters: { ariaLabel: null }, randomIdInputParameters, randomIdLabelParameters });*/
    return {
      context: F$1(() => _objectSpread(_objectSpread({}, context), {}, {
        sliderContext: {
          min,
          max,
          baseId: baseIdRef.current
        }
      }), [min, max]),
      managedChildrenReturn
    };
  }
  function useSliderThumb(_ref76) {
    var {
        managedChildParameters,
        context: {
          sliderContext: {
            max: maxParent,
            min: minParent
          }
        },
        sliderThumbParameters
      } = _ref76,
      context = _objectWithoutProperties(_ref76.context, _excluded64);
    var {
      index
    } = managedChildParameters;
    debugLog("useSliderThumb", managedChildParameters.index);
    var {
      managedChildReturn
    } = useManagedChild({
      managedChildParameters,
      context
    }, {
      index
    });
    var {
      tag,
      value,
      max: maxOverride,
      min: minOverride,
      onValueChange,
      valueText,
      label
    } = sliderThumbParameters;
    var min = minOverride !== null && minOverride !== void 0 ? minOverride : minParent;
    var max = maxOverride !== null && maxOverride !== void 0 ? maxOverride : maxParent;
    var newProps = tag == "input" ? {
      min,
      max,
      value,
      type: "range"
    } : {
      "aria-valuemax": "".concat(max),
      "aria-valuemin": "".concat(min),
      "aria-valuenow": "".concat(value)
    };
    newProps = _objectSpread(_objectSpread({}, newProps), {}, {
      "aria-label": label,
      "aria-valuetext": valueText,
      style: {
        "--range-value": "".concat(value),
        "--range-value-text": "".concat(valueText)
      }
    });
    if (tag == "input") {
      newProps.onInput = e => {
        onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange({
          currentTarget: e.currentTarget,
          target: e.target,
          [EventDetail]: {
            value: e.currentTarget.valueAsNumber
          }
        });
      };
    } else {
      throw new Error("Unimplemented");
    }
    return {
      sliderThumbReturn: {
        min,
        max
      },
      managedChildReturn,
      propsSliderThumb: newProps
    };
  }

  // export interface UseTableSectionContext<TableSectionElement extends Element, TableRowElement extends Element, M extends TableRowInfo<TableRowElement>> extends CompleteGridNavigationContext<TableSectionElement, TableRowElement, M> { }
  function useTable(_ref77) {
    var {
      labelParameters,
      tableParameters: {
        selectionLimit,
        tagTable
      }
    } = _ref77;
    //const { tagInput: tagTable } = labelParameters
    var {
      propsInput: propsLabelList,
      propsLabel: propsLabelLabel
    } = useLabelSynthetic({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: null
      }),
      randomIdInputParameters: {
        prefix: Prefices.table
      },
      randomIdLabelParameters: {
        prefix: Prefices.tableLabel
      }
    });
    return {
      propsTable: useMergedProps({
        role: tagTable == "table" ? undefined : "grid",
        "aria-multiselectable": selectionLimit == "multi" ? "true" : undefined
      }, propsLabelList),
      propsLabel: propsLabelLabel
    };
  }
  var naturalSectionTypes = new Set(["thead", "tbody", "tfoot"]);
  function useTableSection(_ref78) {
    var {
      linearNavigationParameters,
      rovingTabIndexParameters,
      singleSelectionParameters,
      typeaheadNavigationParameters,
      gridNavigationParameters,
      rearrangeableChildrenParameters,
      sortableChildrenParameters,
      tableSectionParameters: {
        tagTableSection
      }
    } = _ref78;
    var {
      childrenHaveFocusReturn,
      context,
      linearNavigationReturn,
      managedChildrenReturn,
      props,
      rovingTabIndexReturn,
      singleSelectionReturn,
      typeaheadNavigationReturn,
      rearrangeableChildrenReturn,
      sortableChildrenReturn
    } = useCompleteGridNavigation({
      linearNavigationParameters,
      rovingTabIndexParameters,
      singleSelectionParameters,
      sortableChildrenParameters,
      typeaheadNavigationParameters,
      gridNavigationParameters,
      rearrangeableChildrenParameters
    });
    if (!naturalSectionTypes.has(tagTableSection)) {
      props.role = "rowgroup";
    }
    return {
      childrenHaveFocusReturn,
      context,
      linearNavigationReturn,
      managedChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      rearrangeableChildrenReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn,
      propsTableSection: props
    };
  }
  function useTableRow(_ref79) {
    var _singleSelectionChild;
    var {
      asChildRowParameters: {
        managedChildParameters,
        singleSelectionChildParameters,
        completeGridNavigationRowParameters,
        rovingTabIndexChildParameters,
        sortableChildParameters,
        textContentParameters,
        context: cx1
      },
      asParentRowParameters: {
        linearNavigationParameters,
        rovingTabIndexParameters,
        typeaheadNavigationParameters
      },
      tableRowParameters: {
        selected
      }
    } = _ref79;
    var {
      asChildRowReturn,
      asParentRowReturn,
      context: cx2,
      managedChildReturn,
      hasCurrentFocusReturn,
      props
    } = useCompleteGridNavigationRow({
      asChildRowParameters: {
        textContentParameters,
        context: cx1,
        managedChildParameters,
        singleSelectionChildParameters,
        completeGridNavigationRowParameters,
        rovingTabIndexChildParameters,
        sortableChildParameters
      },
      asParentRowParameters: {
        linearNavigationParameters,
        rovingTabIndexParameters,
        typeaheadNavigationParameters
      }
    });
    props.role = "gridrow";
    if (selected) props[(_singleSelectionChild = singleSelectionChildParameters.ariaPropName) !== null && _singleSelectionChild !== void 0 ? _singleSelectionChild : "aria-selected"] = "true";
    return {
      asChildRowReturn,
      asParentRowReturn,
      context: cx2,
      hasCurrentFocusReturn,
      managedChildReturn,
      props
    };
  }
  function useTableCell(_ref80) {
    var {
        tableCellParameters: {
          tagTableCell
        }
      } = _ref80,
      p = _objectWithoutProperties(_ref80, _excluded65);
    var ret = useCompleteGridNavigationCell(p);
    if (!(tagTableCell == "th" || tagTableCell == "td")) {
      ret.props.role = "gridcell";
    }
    return ret;
  }
  /*
  export interface UseTableSectionSectionParameters {
      gridlistSectionParameters: {
          compareRows: (lhsIndex: number, rhsIndex: number) => number;
      }
      gridlistSectionContext: {
       }
  }*/
  /*
  export const useTableSectionSection = <BodySectionElement extends Element, RowElement extends Element>({ compareRows }: UseTableSectionSectionParameters) => {
      //debugLog("useTableSectionSection");
      //type CRFull = UseRovingTabIndexSubInfo<RowElement, UseListNavigationSubInfo<UseTableRowSubInfo<CellElement, CR, CC>>>;
      const getIndex = useCallback<GetIndex<any>>((i) => i.props.index, []);
        const {
          linearNavigationParameters,
          rearrangeableChildrenReturn,
          sortableChildrenReturn
      } = useSortableChildren<BodySectionElement, TableRowInfo<RowElement>>({
          rearrangeableChildrenParameters: {
              getIndex,
              getHighestChildIndex,
              getValid
          },
          sortableChildrenParameters: {
              compare: (lhs, rhs) => {
                  if (lhs.locationIndex === rhs.locationIndex)
                      return compareRows(lhs.index, rhs.index);
                  return lhs.locationIndex - rhs.locationIndex;
              }
          }
      });
       const useTableSectionSectionProps = (props: h.JSX.HTMLAttributes<BodySectionElement>) => {
          console.assert(props.children != null);
          overwriteWithWarning("useTableSectionSection", props, "role", "rowgroup");
          return useSortableProps(props as h.JSX.HTMLAttributes<BodySectionElement> & { children: any });
      }
       return {
          useTableSectionSectionProps,
          ...sortableRet
      }
  }*/

  function useToasts(_ref81) {
    var {
      managedChildrenParameters: {
        onChildrenMountChange: ocmu,
        onAfterChildLayoutEffect
      },
      toastsParameters: {
        visibleCount
      }
    } = _ref81;
    // Normally, this does just look like [0, 1, 2, 3], etc
    // so it could be just an index to the current toast,
    // but if we dismiss toasts out of order, it's [0, 2, 3] or something.
    // So just keep track of it all in a big ol', there's only one of these on a page anyway,
    // and if you're pusing 10000 toasts at once an Array<number> isn't going to be your bottleneck.
    var currentIndexQueue = _([]);
    var [politeness, setPoliteness] = useState("polite");
    var getMaxVisibleCount = useStableGetter(visibleCount);
    var {
      refElementReturn: {
        getElement,
        propsStable
      }
    } = useRefElement({
      refElementParameters: {}
    });
    var _useManagedChildren = useManagedChildren({
        managedChildrenParameters: {
          onAfterChildLayoutEffect,
          onChildrenMountChange: ocmu
        }
      }),
      {
        context,
        managedChildrenReturn
      } = _useManagedChildren,
      _childInfo = _objectWithoutProperties(_useManagedChildren, _excluded66);
    var {
      getChildren: getToastQueue
    } = managedChildrenReturn;
    var toastQueue = getToastQueue();
    // When a toast is shown or hidden, always make sure that we're showing all the toasts that we should be.
    var showHighestPriorityToast = T$1(() => {
      var max = Math.min(getMaxVisibleCount(), currentIndexQueue.current.length);
      for (var _i6 = 0; _i6 < max; ++_i6) {
        var highestPriorityToast = toastQueue.getAt(currentIndexQueue.current[_i6]);
        console.assert(!!highestPriorityToast);
        highestPriorityToast === null || highestPriorityToast === void 0 ? void 0 : highestPriorityToast.show();
      }
    }, []);
    // Any time a new toast mounts, update our bottommostToastIndex to point to it if necessary
    // ("necessary" just meaning if it's the first toast ever or all prior toasts have been dismissed)
    var onAnyToastMounted = T$1(toastIndex => {
      var _toastQueue$getAt;
      currentIndexQueue.current.push(toastIndex);
      (_toastQueue$getAt = toastQueue.getAt(toastIndex)) === null || _toastQueue$getAt === void 0 ? void 0 : _toastQueue$getAt.setNumberAheadOfMe(currentIndexQueue.current.length - 1);
      showHighestPriorityToast();
    }, []);
    // Any time a toast is dismissed, update our bottommostToastIndex to point to the next toast in the queue, if one exists.
    var onAnyToastDismissed = T$1(_index => {
      var _toastQueue$getAt2;
      // When we dismiss a toast, remove it from the "to-display" queue by actually splicing it out of the array.
      // Then notify each toast of its change in position within that queue to keep the two in sync.
      var removalIndex = currentIndexQueue.current.findIndex(i => i == _index);
      // For all toasts that have already been dismissed, shift them even further back by one to "make space" 
      // (they're removed from the queue but this is the negative index they would have if we kept negatives in the queue)
      // for the newly-dismissed toast.
      toastQueue.forEach(c => {
        c.setNumberAheadOfMe(prev => {
          if (prev < 0) return prev - 1;else return prev;
        });
      });
      // Let this toast know that it's now the most recently dismissed toast
      (_toastQueue$getAt2 = toastQueue.getAt(_index)) === null || _toastQueue$getAt2 === void 0 ? void 0 : _toastQueue$getAt2.setNumberAheadOfMe(-1);
      // Notify all toasts waiting behind this one in the queue that they've moved up one slot
      toastQueue.forEach(c => {
        c.setNumberAheadOfMe(prev => {
          if (prev > removalIndex) return prev - 1;else return prev;
        });
      });
      // Actually modify the queue itself
      currentIndexQueue.current.splice(removalIndex, 1);
      // And after all that, make sure that we're showing any toasts that have been waiting in the queue
      showHighestPriorityToast();
    }, []);
    var [_mouseOver2, setMouseOver, _getMouseOver] = useState(false);
    useGlobalHandler(document, "pointermove", e => {
      var _getElement;
      var mouseOver = e.target != null && e.target instanceof Node && (((_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.contains(e.target)) || getElement() == e.target);
      setMouseOver(mouseOver);
    });
    // Any time the index pointing to the currently-showing toast changes,
    // update the relevant children and let them know that they're now either active or dismissed.
    /*const { changeIndex, reevaluateClosestFit } = useChildrenFlag<ToastInfo, "showing">({
        initialIndex: activeToastIndex,
        children: toastQueue,
        key: "showing",
        closestFit: false,
    });
    useEffect(() => {
        changeIndex(activeToastIndex);
    }, [activeToastIndex]);*/
    var toastContext = {
      onAnyToastDismissed,
      getMaxVisibleCount,
      setPoliteness,
      onAnyToastMounted
    };
    //function useToastContainerProps({ role, "aria-live": ariaLive, "aria-relevant": ariaRelevant, ...props }: h.JSX.HTMLAttributes<ContainerType>): h.JSX.HTMLAttributes<ContainerType> {
    var props = useMergedProps(useMergedProps(propsStable, {
      class: "toasts-container",
      role: "status",
      "aria-live": politeness !== null && politeness !== void 0 ? politeness : "polite",
      "aria-relevant": "additions"
    }));
    //}
    return {
      context: _objectSpread(_objectSpread({}, context), {}, {
        toastContext
      }),
      managedChildrenReturn,
      props
    };
  }
  function useToast(_ref82) {
    var {
        toastParameters: {
          politeness,
          timeout
        },
        managedChildParameters: {
          index
        },
        context
      } = _ref82,
      _managedChildParameters = _objectWithoutProperties(_ref82.managedChildParameters, _excluded67);
    var {
      getMaxVisibleCount,
      onAnyToastDismissed,
      setPoliteness,
      onAnyToastMounted
    } = context.toastContext;
    var [numberOfToastsAheadOfUs, setNumberOfToastsAheadOfUs] = useState(Infinity);
    var getIndex = useStableGetter(index);
    var [dismissed2, setDismissed2, getDismissed2] = useState(false);
    var [showing2, setShowing2, getShowing2] = useState(false);
    //const [dismissed, setDismissed] = useState(false);
    //const [status, setStatus, getStatus] = useState<"pending" | "active" | "dismissed">("pending");
    //const dismissed = (status === "dismissed");
    var dismiss = T$1(() => {
      if (!getDismissed2()) onAnyToastDismissed(getIndex());
      setDismissed2(true);
      setShowing2(false);
    }, []);
    var show = T$1(() => {
      setShowing2(true);
    }, []);
    h(() => {
      if (!getDismissed2() && !getShowing2()) {
        if (numberOfToastsAheadOfUs >= 0 && numberOfToastsAheadOfUs < getMaxVisibleCount()) {
          show();
        }
      }
    }, [numberOfToastsAheadOfUs]);
    //const toastId = generateRandomId("toast-");
    s(() => {
      setPoliteness(politeness !== null && politeness !== void 0 ? politeness : "polite");
    }, [politeness]);
    var focus = T$1(() => {
      var element = getElement();
      if (element) {
        var _firstFocusable$focus;
        var firstFocusable = findFirstFocusable(element);
        firstFocusable === null || firstFocusable === void 0 ? void 0 : (_firstFocusable$focus = firstFocusable.focus) === null || _firstFocusable$focus === void 0 ? void 0 : _firstFocusable$focus.call(firstFocusable);
      }
    }, []);
    useManagedChild({
      managedChildParameters: {
        index
      },
      context
    }, {
      index,
      focus,
      setNumberAheadOfMe: setNumberOfToastsAheadOfUs,
      show
    });
    //const isActive = (status === "active");
    var [triggerIndex, setTriggerIndex] = useState(1);
    var resetDismissTimer = T$1(() => {
      setTriggerIndex(i => ++i);
    }, []);
    h(() => {
      onAnyToastMounted(index);
    }, []);
    /*useEffect(() => {
        if (!showing)
            onAnyToastDismissed(index)
    }, [showing]);*/
    var dismissTimeoutKey = timeout == null || numberOfToastsAheadOfUs != 0 ? null : isFinite(timeout) ? timeout : timeout > 0 ? null : 0;
    useTimeout({
      timeout: dismissTimeoutKey,
      callback: () => {
        if (showing2) dismiss();
      },
      triggerIndex: showing2 ? triggerIndex : false
    });
    var {
      refElementReturn: {
        getElement,
        propsStable
      }
    } = useRefElement({
      refElementParameters: {}
    });
    return {
      toastReturn: {
        dismissed: dismissed2,
        showing: showing2,
        numberOfToastsAheadOfUs,
        dismiss,
        resetDismissTimer
      },
      props: propsStable
    };
  }
  function useTooltip(_ref83) {
    var _mouseoverDelay, _mouseoutToleranceDel, _focusDelay, _propsTrigger$tabInde;
    var {
      mouseoverDelay,
      mouseoutToleranceDelay,
      focusDelay
    } = _ref83;
    (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
    (_mouseoutToleranceDel = mouseoutToleranceDelay) !== null && _mouseoutToleranceDel !== void 0 ? _mouseoutToleranceDel : mouseoutToleranceDelay = 500;
    (_focusDelay = focusDelay) !== null && _focusDelay !== void 0 ? _focusDelay : focusDelay = 1;
    // The escape key should close tooltips, but do nothing else.
    // (i.e. closing a tooltip in a dialog MUST NOT close the dialog too)
    // TODO: Tooltips are, effectively, always the topmost component,
    // so we can just have them listen to and swallow all "Escape"
    // key presses before anyone else. For a more general popup,
    // or a tooltip in a tooltip (!!) a different solution would be needed.
    useGlobalHandler(document, "keydown", e => {
      if (getOpen() && e.key === "Escape" && !e.defaultPrevented) {
        e.preventDefault();
        e.stopImmediatePropagation();
        setOpen(false);
        setHoverState("hidden");
        setTriggerFocusedDelayCorrected(false);
        setTooltipFocusedDelayCorrected(false);
      }
    }, {
      capture: true
    });
    var [open, setOpen, getOpen] = useState(false);
    var {
      propsReferencer: propsTrigger,
      propsSource: propsPopup
    } = useRandomId({
      randomIdParameters: {
        prefix: Prefices.tooltip,
        otherReferencerProp: "aria-describedby"
      }
    });
    var {
      refElementReturn: {
        getElement: getTriggerElement,
        propsStable: triggerRefProps
      }
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      refElementReturn: {
        getElement: getPopupElement,
        propsStable: popupRefProps
      }
    } = useRefElement({
      refElementParameters: {}
    });
    var [, setTriggerFocused] = usePassiveState(useStableCallback(focused => {
      var delay = focused ? focusDelay : 1;
      if (delay != null && isFinite(delay)) {
        var handle = setTimeout(() => setTriggerFocusedDelayCorrected(focused), focused ? focusDelay : 1);
        return () => clearTimeout(handle);
      }
    }), returnFalse);
    var [, setTooltipFocused] = usePassiveState(useStableCallback(focused => {
      var delay = focused ? focusDelay : 1;
      if (delay != null && isFinite(delay)) {
        var handle = setTimeout(() => setTooltipFocusedDelayCorrected(focused), delay);
        return () => clearTimeout(handle);
      }
    }), returnFalse);
    var onHoverChange = useStableCallback(function onHoverChange(hovering) {
      if (hovering) {
        switch (hoverState) {
          case "hiding":
            {
              // We're hoving over the tooltip right after hovering away from it.
              // In this case, we show it again immediately
              setHoverState("shown");
              break;
            }
          case "hidden":
            {
              // The tooltip isn't showing and hasn't for awhile (if ever)
              // Wait for our mouseover delay
              setHoverState("showing2");
              break;
              //const handle = setTimeout(() => { console.log("setHoverState(shown)");  setHoverState("shown") }, mouseoverDelay);
              //return () => clearTimeout(handle);
            }
        }
      } else {
        switch (hoverState) {
          case "shown":
            {
              // The mouse has left the trigger, but delay truly hiding it for a moment
              setHoverState("hiding");
              break;
              //const handle = setTimeout(() => { console.log("setHoverState(hidden)"); setHoverState("hidden");}, mouseoverDelay);
              //return () => clearTimeout(handle);
            }

          case "showing2":
            {
              // During a mouseover delay, when we mouseout,
              // just reset the timer
              setHoverState("hidden");
              break;
            }
        }
      }
    });
    var [, setTriggerHover] = usePassiveState(onHoverChange, returnFalse);
    var [, setTooltipHover] = usePassiveState(onHoverChange, returnFalse);
    var [triggerFocusedDelayCorrected, setTriggerFocusedDelayCorrected] = useState(false);
    var [hoverState, setHoverState] = useState("hidden");
    useTimeout({
      triggerIndex: hoverState,
      timeout: hoverState == "showing2" ? mouseoverDelay : null,
      callback: () => {
        if (hoverState == "showing2") {
          setHoverState("shown");
        }
      }
    });
    useTimeout({
      triggerIndex: hoverState,
      timeout: hoverState == "hiding" ? mouseoutToleranceDelay : null,
      callback: () => {
        if (hoverState == "hiding") {
          setHoverState("hidden");
        }
      }
    });
    //const [triggerHoverDelayCorrected, setTriggerHoverDelayCorrected] = useState(false);
    var [tooltipFocusedDelayCorrected, setTooltipFocusedDelayCorrected] = useState(false);
    //const [tooltipHoverDelayCorrected, setTooltipHoverDelayCorrected] = useState(false);
    var hoverDelayCorrected = hoverState == "shown";
    h(() => {
      setOpen(triggerFocusedDelayCorrected || hoverDelayCorrected || tooltipFocusedDelayCorrected);
    }, [triggerFocusedDelayCorrected || hoverDelayCorrected || tooltipFocusedDelayCorrected]);
    //const { getElement } = refElementReturn;
    useGlobalHandler(document, "pointermove", e => {
      var _getTriggerElement;
      var target = e.target;
      setTriggerHover(target == getTriggerElement() || !!((_getTriggerElement = getTriggerElement()) !== null && _getTriggerElement !== void 0 && _getTriggerElement.contains(target)));
    }, {
      capture: true
    });
    function onTouchEnd(e) {
      var _e$target$focus, _e$target;
      (_e$target$focus = (_e$target = e.target).focus) === null || _e$target$focus === void 0 ? void 0 : _e$target$focus.call(_e$target);
    }
    //function useTooltipTriggerProps({ ...props }: h.JSX.HTMLAttributes<TriggerType>): h.JSX.HTMLAttributes<TriggerType> {
    //const { propsStable } = useRandomIdReferencerElement();
    // Note: Though it's important to make sure that focusing activates a tooltip,
    // it's perfectly reasonable that a child element will be the one that's focused,
    // not this one, so we don't set tabIndex=0
    (_propsTrigger$tabInde = propsTrigger.tabIndex) !== null && _propsTrigger$tabInde !== void 0 ? _propsTrigger$tabInde : propsTrigger.tabIndex = -1;
    //}
    var {
      hasCurrentFocusReturn
    } = useHasCurrentFocus({
      hasCurrentFocusParameters: {
        onCurrentFocusedInnerChanged: setTriggerFocused,
        onCurrentFocusedChanged: null
      },
      refElementReturn: {
        getElement: getTriggerElement
      }
    });
    //const { getElement } = refElementReturn;
    //const { propsStable } = useRandomIdSourceElement();
    var {
      hasCurrentFocusReturn: {
        propsStable: propsFocusPopup
      }
    } = useHasCurrentFocus({
      hasCurrentFocusParameters: {
        onCurrentFocusedChanged: null,
        onCurrentFocusedInnerChanged: useStableCallback(focused => {
          setTooltipFocused(focused);
        })
      },
      refElementReturn: {
        getElement: getPopupElement
      }
    });
    useGlobalHandler(document, "pointermove", e => {
      var _getPopupElement;
      var target = e.target;
      setTooltipHover(target == getPopupElement() || !!((_getPopupElement = getPopupElement()) !== null && _getPopupElement !== void 0 && _getPopupElement.contains(target)));
    }, {
      capture: true
    });
    //function useTooltipPopupProps(props: h.JSX.HTMLAttributes<PopupType>): h.JSX.HTMLAttributes<PopupType> {
    //    return useMergedProps(propsStable, props);
    // }
    //return { useTooltipPopupProps };
    //}, []);
    return {
      propsPopup: useMergedProps(popupRefProps, propsPopup, propsFocusPopup),
      propsTrigger: useMergedProps(triggerRefProps, propsTrigger, hasCurrentFocusReturn.propsStable, {
        onTouchEnd
      }),
      tooltipReturn: {
        isOpen: open,
        getIsOpen: getOpen
      }
    };
  }
  function memoForwardRef(fn) {
    return R(k(fn)); //(props: Parameters<T>[0]) => ReturnType<T>;
  }

  var ContextDefaults = {
    collator: B$2(null),
    pageNavigationSize: B$2(0.1),
    typeaheadTimeout: B$2(1000),
    noTypeahead: B$2(false),
    getIndex: B$2(v => v.props.index),
    disableArrowKeys: B$2(false),
    disableHomeEndKeys: B$2(false),
    getWindow: B$2(() => globalThis.window),
    focusOpener: B$2(e => {
      var _e$focus4;
      return e === null || e === void 0 ? void 0 : (_e$focus4 = e.focus) === null || _e$focus4 === void 0 ? void 0 : _e$focus4.call(e);
    }),
    getText: B$2(e => {
      var _e$textContent;
      return (_e$textContent = e === null || e === void 0 ? void 0 : e.textContent) !== null && _e$textContent !== void 0 ? _e$textContent : "";
    }),
    selectionMode: B$2("activation")
  };
  function useDefault(context, userValue) {
    var defaultValue = q(ContextDefaults[context]);
    return userValue !== null && userValue !== void 0 ? userValue : defaultValue;
  }
  var ParentDepthContext = B$2(0);
  var AccordionSectionContext = B$2(null);
  var Accordion = memoForwardRef(function Accordion(_ref84, ref) {
    var {
        disableArrowKeys,
        disableHomeEndKeys,
        initialIndex,
        navigationDirection,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        navigatePastEnd,
        navigatePastStart,
        pageNavigationSize,
        render
      } = _ref84,
      _rest = _objectWithoutProperties(_ref84, _excluded68);
    var info = useAccordion({
      accordionParameters: {
        initialIndex
      },
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        navigationDirection,
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange
      }
    });
    A(ref, () => info);
    return o$1(AccordionSectionContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  /*
  export function defaultRenderAccordionSection<HeaderContainerElement extends Element, HeaderButtonElement extends Element, BodyElement extends Element>({ makePropsHeadingContainer, makePropsHeadingButton, makePropsBody, tagBody, tagHeadingButton }: { tagHeadingButton: ElementToTag<HeaderButtonElement>; tagBody: ElementToTag<BodyElement>; makePropsHeadingContainer(info: UseAccordionSectionReturnType<HeaderButtonElement, BodyElement>): h.JSX.HTMLAttributes<HeaderContainerElement>, makePropsHeadingButton(info: UseAccordionSectionReturnType<HeaderButtonElement, BodyElement>): h.JSX.HTMLAttributes<HeaderButtonElement>, makePropsBody(info: UseAccordionSectionReturnType<HeaderButtonElement, BodyElement>): h.JSX.HTMLAttributes<BodyElement> }) {
      return function (info: UseAccordionSectionReturnType<HeaderButtonElement, BodyElement>): VNode<any> {
          return (
              <>
                  <Heading<HeaderContainerElement> {...makePropsHeadingContainer(info)} heading={createElement(tagHeadingButton as never, (makePropsHeadingButton(info)))}>
                      {createElement(tagBody as never, (makePropsBody(info)))}
                  </Heading>
              </>
          )
      }
  }*/
  var AccordionSection = memoForwardRef(function AccordionSection(_ref85, ref) {
    var {
      open,
      index,
      tagButton,
      disabled,
      bodyRole,
      onPress,
      exclude,
      hidden,
      render
    } = _ref85;
    var context = q(AccordionSectionContext);
    var info = useAccordionSection({
      buttonParameters: {
        disabled: disabled !== null && disabled !== void 0 ? disabled : false,
        tagButton,
        onPress: onPress !== null && onPress !== void 0 ? onPress : null
      },
      accordionSectionParameters: {
        open,
        bodyRole: bodyRole !== null && bodyRole !== void 0 ? bodyRole : "region"
      },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      pressParameters: {
        exclude
      },
      refElementParameters: {},
      context
    });
    A(ref, () => info);
    return render(info);
  });

  /*
  export function defaultRenderButton<E extends Element>({ tagButton, propsButton }: { tagButton: ElementToTag<E>, propsButton: (info: UseButtonReturnType<E>) => h.JSX.HTMLAttributes<E> }) {
      return function (info: UseButtonReturnType<E>) {
          return createElement(tagButton as any, propsButton(info));
      }
  }*/
  var Button = memoForwardRef(function Button(_ref86, ref) {
    var {
      tagButton,
      onPress,
      pressed,
      render,
      disabled,
      onElementChange,
      onMount,
      onUnmount,
      exclude
    } = _ref86;
    var info = useButton({
      buttonParameters: {
        role: "button",
        tagButton: tagButton,
        onPress: onPress !== null && onPress !== void 0 ? onPress : null,
        pressed,
        disabled: disabled !== null && disabled !== void 0 ? disabled : false
      },
      pressParameters: {
        exclude
      },
      refElementParameters: {
        onElementChange,
        onMount,
        onUnmount
      }
    });
    A(ref, () => info);
    return render(info);
  });
  function defaultRenderCheckboxLike(_ref87) {
    var {
      labelPosition,
      tagInput,
      tagLabel,
      makePropsInput,
      makePropsLabel
    } = _ref87;
    return function (info) {
      var inputProps = makePropsInput(info);
      var _makePropsLabel = makePropsLabel(info),
        {
          children
        } = _makePropsLabel,
        labelProps = _objectWithoutProperties(_makePropsLabel, _excluded69);
      if (labelPosition == "wrapping") {
        //const inputProps = modifyInputProps(makeInputProps(info));
        //const { children, ...labelProps } = modifyLabelProps(makeLabelProps(info));
        var input = h$1(tagInput, inputProps);
        var label = h$1(tagLabel, _objectSpread(_objectSpread({}, labelProps), {}, {
          children: o$1(p$1, {
            children: [input, children]
          })
        }));
        return o$1(p$1, {
          children: label
        });
      } else if (labelPosition == "separate") {
        var _input = h$1(tagInput, inputProps);
        var _label = h$1(tagLabel, _objectSpread({
          children
        }, labelProps));
        return o$1(p$1, {
          children: [_input, _label]
        });
      } else {
        console.assert(!!inputProps["aria-label"]);
        return h$1(tagInput, inputProps);
      }
    };
  }
  /*
  export interface DefaultRenderCheckboxParameters<I extends Element, L extends Element> extends DefaultRenderCheckboxLikeParameters<I, L, UseCheckboxReturnType<I, L>> { }
   export function defaultRenderCheckbox<I extends Element, L extends Element>({ labelPosition, tagInput, tagLabel, makePropsInput, makePropsLabel }: DefaultRenderCheckboxParameters<I, L>) {
      return defaultRenderCheckboxLike<I, L, UseCheckboxReturnType<I, L>>({ labelPosition, tagInput, tagLabel, makePropsInput, makePropsLabel });
  }*/
  var Checkbox = memoForwardRef(function Checkbox(_ref88, ref) {
    var {
      checked,
      disabled,
      tagLabel,
      labelPosition,
      tagInput,
      ariaLabel,
      onCheckedChange,
      render
    } = _ref88;
    var {
      refElementReturn: refElementInputReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var {
      refElementReturn: refElementLabelReturn
    } = useRefElement({
      refElementParameters: {}
    });
    var checkbox = useCheckbox({
      checkboxLikeParameters: {
        checked: checked !== null && checked !== void 0 ? checked : false,
        disabled: disabled !== null && disabled !== void 0 ? disabled : false
      },
      checkboxParameters: {
        onCheckedChange
      },
      labelParameters: {
        ariaLabel: ariaLabel,
        labelPosition,
        tagInput,
        tagLabel
      },
      refElementInputReturn,
      refElementLabelReturn
    });
    A(ref, () => checkbox);
    return render(checkbox);
  });

  /*
  export function defaultRenderCheckboxGroupParent<InputType extends Element, LabelType extends Element>({ render, disabled, getDocument, labelPosition, tagInput, tagLabel, getWindow, onActiveElementChange, onCheckedChangeStart, onCheckedChangeEnd, onElementChange, onFocusedChanged, onFocusedInnerChanged, onLastActiveElementChange, onLastFocusedChanged, onLastFocusedInnerChanged, onMount, onUnmount, onWindowFocusedChange }: Foo<InputType, LabelType>) {
      return function (parentInfo: UseCheckboxGroupParentReturnTypeInfo, modifyControlProps: PropModifier<any>) {
          const { checkboxGroupParent: { checked, onParentCheckedChange } } = parentInfo;
          return (
              <Checkbox<InputType, LabelType>
                  checked={checked}
                  disabled={disabled}
                  getDocument={getDocument}
                  labelPosition={labelPosition}
                  render={(info, modifyInputProps, modifyLabelProps) => {
                      if (labelPosition == "separate")
                          return render(info, (props) => modifyControlProps(modifyInputProps(props)), modifyLabelProps)
                      else
                          return render(info, modifyInputProps, (props) => modifyControlProps(modifyLabelProps(props) as any) as any)
                  }}
                  tagInput={tagInput}
                  tagLabel={tagLabel}
                  getWindow={getWindow}
                  onActiveElementChange={onActiveElementChange}
                  onCheckedChange={e => {
                      let exception: any;
                      onCheckedChangeStart();
                      (async () => {
                           try {
                              await onParentCheckedChange(e);
                          }
                          catch (ex) {
                              exception = ex;
                          }
                          finally {
                              onCheckedChangeEnd(exception);
                          }
                      }
                       )()
                   }}
                  onElementChange={onElementChange}
                  onFocusedChanged={onFocusedChanged}
                  onFocusedInnerChanged={onFocusedInnerChanged}
                  onLastActiveElementChange={onLastActiveElementChange}
                  onLastFocusedChanged={onLastFocusedChanged}
                  onLastFocusedInnerChanged={onLastFocusedInnerChanged}
                  onMount={onMount}
                  onUnmount={onUnmount}
                  onWindowFocusedChange={onWindowFocusedChange}
              />
          )
      }
  }
   export function defaultRenderCheckboxGroup<InputType extends HTMLElement, LabelType extends HTMLElement, C, K extends string>({ children, labelPosition, makeInputProps, makeLabelProps, tagInput, tagLabel }: DefaultRenderCheckboxGroupParameters<InputType, LabelType, C, K>) {
      return function (info: UseCheckboxGroupReturnTypeInfo<InputType, LabelType, C, K>, modifyInputProps: PropModifier<InputType>, modifyLabelProps: PropModifier<LabelType>): VNode<any> {
          return (
              <>
                  {defaultRenderCheckboxLike({ labelPosition, makeInputProps, makeLabelProps, tagInput, tagLabel })(info, modifyInputProps, modifyLabelProps)}
                  {children}
              </>
          )
      }
  }*/
  var UseCheckboxGroupChildContext = B$2(null);
  var CheckboxGroup = memoForwardRef(function CheckboxGroup(_ref89, ref) {
    var {
        render,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        onTabbableIndexChange,
        compare,
        getIndex,
        untabbable,
        navigatePastEnd,
        navigatePastStart,
        pageNavigationSize,
        children
      } = _ref89,
      _rest = _objectWithoutProperties(_ref89, _excluded70);
    var info = useCheckboxGroup({
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        navigationDirection,
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      }
    });
    A(ref, () => info);
    return o$1(UseCheckboxGroupChildContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  var CheckboxGroupParent = memoForwardRef(function CheckboxGroupParent(_ref90, ref) {
    var {
        render,
        index,
        focusSelf,
        exclude,
        hidden,
        getText,
        onPressSync,
        getSortValue
      } = _ref90,
      _rest = _objectWithoutProperties(_ref90, _excluded71);
    var context = q(UseCheckboxGroupChildContext);
    var info = useCheckboxGroupParent({
      completeListNavigationChildParameters: {
        checkboxInfo: {
          checkboxChildType: "parent"
        }
      },
      context,
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue
      },
      pressParameters: {
        exclude,
        onPressSync,
        focusSelf
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      }
    });
    A(ref, () => info);
    return render(info);
  });
  var CheckboxGroupChild = memoForwardRef(function CheckboxGroupChild(_ref91, ref) {
    var {
        index,
        exclude,
        onPressSync,
        render,
        checked,
        onChangeFromParent,
        getSortValue,
        hidden,
        getText,
        focusSelf
      } = _ref91,
      _rest = _objectWithoutProperties(_ref91, _excluded72);
    var context = q(UseCheckboxGroupChildContext);
    var info = useCheckboxGroupChild({
      checkboxGroupChild: {
        checked,
        onChangeFromParent
      },
      completeListNavigationChildParameters: {},
      textContentParameters: {
        getText: useDefault("getText", getText)
      },
      context,
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue
      },
      pressParameters: {
        exclude,
        onPressSync,
        focusSelf
      }
    });
    A(ref, () => info);
    return render(info);
  });
  function defaultRenderPortal(_ref92) {
    var _portalRef$current;
    var {
      portalId,
      children
    } = _ref92;
    var portalRef = _(null);
    (_portalRef$current = portalRef.current) !== null && _portalRef$current !== void 0 ? _portalRef$current : portalRef.current = document.getElementById(portalId);
    if (portalRef.current) return j(children, portalRef.current);else return children;
  }
  /*
  export function defaultRenderModal<FocusContainerElement extends HTMLElement, DialogElement extends HTMLElement, TitleElement extends HTMLElement, BodyElement extends HTMLElement, BackdropElement extends HTMLElement, InfoType>({ portalId, tagFocusContainer, tagBackdrop, tagBody, tagDialog, tagTitle, makePropsFocusContainer, makePropsBackdrop, makePropsBody, makePropsDialog, makePropsTitle }: { portalId: string, tagFocusContainer: ElementToTag<FocusContainerElement>, tagDialog: ElementToTag<DialogElement>; tagTitle: ElementToTag<TitleElement>; tagBody: ElementToTag<BodyElement>; tagBackdrop: ElementToTag<BackdropElement>, makePropsFocusContainer: (info: InfoType) => h.JSX.HTMLAttributes<FocusContainerElement>, makePropsDialog: (info: InfoType) => h.JSX.HTMLAttributes<DialogElement>, makePropsBody: (info: InfoType) => h.JSX.HTMLAttributes<BodyElement>, makePropsTitle: (info: InfoType) => h.JSX.HTMLAttributes<TitleElement>, makePropsBackdrop: (info: InfoType) => h.JSX.HTMLAttributes<BackdropElement> }) {
      return function (dialogInfo: InfoType): VNode<any> {
           const { children: titleChildren, ...titleProps } = (makePropsTitle(dialogInfo));
          const { children: bodyChildren, ...bodyProps } = (makePropsBody(dialogInfo));
          const { children: dialogChildren, ...dialogProps } = (makePropsDialog(dialogInfo));
          const { children: backdropChildren, ...backdropProps } = (makePropsBackdrop(dialogInfo));
          const { children: focusContainerChildren, ...focusContainerProps } = (makePropsFocusContainer(dialogInfo));
           const title = createElement(tagTitle as never, titleProps, titleChildren);
          const body = createElement(tagBody as never, bodyProps, bodyChildren);
          const dialog = createElement(tagDialog as never, dialogProps, dialogChildren, title, body);
           const backdrop = createElement(tagBackdrop as never, backdropProps, backdropChildren);
          const focusContainer = createElement(tagFocusContainer as never, focusContainerProps, <div>{focusContainerChildren}{dialog}{backdrop}</div>);
           return defaultRenderPortal({
              portalId,
              children: focusContainer
          });
      }
  }*/
  /*
  export function defaultRenderDialog<FocusContainerElement extends HTMLElement, DialogElement extends HTMLElement, TitleElement extends HTMLElement, BodyElement extends HTMLElement, BackdropElement extends HTMLElement>({ portalId, tagFocusContainer, tagBackdrop, tagBody, tagDialog, tagTitle, makePropsFocusContainer, makePropsBackdrop, makePropsBody, makePropsDialog, makePropsTitle }: { portalId: string, tagFocusContainer: ElementToTag<FocusContainerElement>, tagDialog: ElementToTag<DialogElement>; tagTitle: ElementToTag<TitleElement>; tagBody: ElementToTag<BodyElement>; tagBackdrop: ElementToTag<BackdropElement>, makePropsFocusContainer: (info: UseDialogReturnType<FocusContainerElement, DialogElement>) => h.JSX.HTMLAttributes<FocusContainerElement>, makePropsDialog: (info: UseDialogReturnType<FocusContainerElement, DialogElement>) => h.JSX.HTMLAttributes<DialogElement>, makePropsBody: (info: UseDialogReturnType<FocusContainerElement, DialogElement>) => h.JSX.HTMLAttributes<BodyElement>, makePropsTitle: (info: UseDialogReturnType<FocusContainerElement, DialogElement>) => h.JSX.HTMLAttributes<TitleElement>, makePropsBackdrop: (info: UseDialogReturnType<FocusContainerElement, DialogElement>) => h.JSX.HTMLAttributes<BackdropElement> }) {
      return defaultRenderModal<FocusContainerElement, DialogElement, TitleElement, BodyElement, BackdropElement, UseDialogReturnType<FocusContainerElement, DialogElement>>({ portalId, tagFocusContainer, tagBackdrop, tagBody, tagDialog, tagTitle, makePropsFocusContainer, makePropsBackdrop, makePropsBody, makePropsDialog, makePropsTitle });
  }*/
  memoForwardRef(function Dialog(_ref93, ref) {
    var {
      onClose,
      open,
      closeOnBackdrop,
      closeOnEscape,
      focusOpener,
      getWindow,
      parentDepth,
      focusPopup,
      ariaLabel,
      render
    } = _ref93;
    var defaultParentDepth = q(ParentDepthContext);
    var myDepth = (parentDepth !== null && parentDepth !== void 0 ? parentDepth : defaultParentDepth) + 1;
    var info = useDialog({
      dismissParameters: {
        closeOnBackdrop: closeOnBackdrop !== null && closeOnBackdrop !== void 0 ? closeOnBackdrop : true,
        closeOnEscape: closeOnEscape !== null && closeOnEscape !== void 0 ? closeOnEscape : true,
        onClose,
        open
      },
      escapeDismissParameters: {
        getWindow: useDefault("getWindow", getWindow),
        parentDepth: parentDepth !== null && parentDepth !== void 0 ? parentDepth : defaultParentDepth
      },
      focusTrapParameters: {
        focusOpener: useDefault("focusOpener", focusOpener),
        focusPopup
      },
      labelParameters: {
        ariaLabel
      }
    });
    A(ref, () => info);
    return o$1(ParentDepthContext.Provider, {
      value: myDepth,
      children: render(info)
    });
  });

  /*
  export function defaultRenderDrawer<FocusContainerElement extends HTMLElement, DrawerElement extends HTMLElement, TitleElement extends HTMLElement, BodyElement extends HTMLElement, BackdropElement extends HTMLElement>({ portalId, tagFocusContainer, tagBackdrop, tagBody, tagDialog, tagTitle, makePropsFocusContainer, makePropsBackdrop, makePropsBody, makePropsDialog, makePropsTitle }: { portalId: string, tagFocusContainer: ElementToTag<FocusContainerElement>, tagDialog: ElementToTag<DrawerElement>; tagTitle: ElementToTag<TitleElement>; tagBody: ElementToTag<BodyElement>; tagBackdrop: ElementToTag<BackdropElement>, makePropsFocusContainer: (info: UseDrawerReturnType<FocusContainerElement, DrawerElement>) => h.JSX.HTMLAttributes<FocusContainerElement>, makePropsDialog: (info: UseDrawerReturnType<FocusContainerElement, DrawerElement>) => h.JSX.HTMLAttributes<DrawerElement>, makePropsBody: (info: UseDrawerReturnType<FocusContainerElement, DrawerElement>) => h.JSX.HTMLAttributes<BodyElement>, makePropsTitle: (info: UseDrawerReturnType<FocusContainerElement, DrawerElement>) => h.JSX.HTMLAttributes<TitleElement>, makePropsBackdrop: (info: UseDrawerReturnType<FocusContainerElement, DrawerElement>) => h.JSX.HTMLAttributes<BackdropElement> }) {
      return defaultRenderModal<FocusContainerElement, DrawerElement, TitleElement, BodyElement, BackdropElement, UseDrawerReturnType<FocusContainerElement, DrawerElement>>({ portalId, makePropsFocusContainer, makePropsBackdrop, makePropsBody, makePropsDialog, makePropsTitle, tagFocusContainer, tagBackdrop, tagBody, tagDialog, tagTitle });
  }*/
  memoForwardRef(function Drawer(_ref94, ref) {
    var {
      closeOnBackdrop,
      closeOnEscape,
      closeOnLostFocus,
      focusOpener,
      focusPopup,
      getWindow,
      onClose,
      open,
      parentDepth,
      render,
      trapActive,
      ariaLabel
    } = _ref94;
    var defaultParentDepth = q(ParentDepthContext);
    var info = useDrawer({
      dismissParameters: {
        closeOnBackdrop: closeOnBackdrop !== null && closeOnBackdrop !== void 0 ? closeOnBackdrop : true,
        closeOnEscape: closeOnEscape !== null && closeOnEscape !== void 0 ? closeOnEscape : true,
        closeOnLostFocus: closeOnLostFocus !== null && closeOnLostFocus !== void 0 ? closeOnLostFocus : true,
        onClose,
        open
      },
      escapeDismissParameters: {
        getWindow: useDefault("getWindow", getWindow),
        parentDepth: parentDepth !== null && parentDepth !== void 0 ? parentDepth : defaultParentDepth
      },
      focusTrapParameters: {
        focusOpener: useDefault("focusOpener", focusOpener),
        focusPopup,
        trapActive: trapActive !== null && trapActive !== void 0 ? trapActive : false
      },
      labelParameters: {
        ariaLabel
      }
    });
    A(ref, () => info);
    return render(info);
  });

  //const LocationIndexContext = createContext(0);
  //const SetManglersContext = createContext<(m: (n: number) => number, d: (n: number) => number) => void>(null!);
  //const GridlistSectionContext = createContext<UseGridlistSection<any, any, any, any, any, any>>(null!);
  var GridlistContext = B$2(null);
  var GridlistRowContext = B$2(null);
  memoForwardRef(function GridlistU(_ref95, ref) {
    var {
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      noTypeahead,
      onTabbableIndexChange,
      groupingType,
      typeaheadTimeout,
      selectedIndex,
      navigatePastEnd,
      navigatePastStart,
      setSelectedIndex,
      pageNavigationSize,
      selectionLimit,
      untabbable,
      compare,
      getIndex,
      onTabbableColumnChange,
      ariaLabel,
      render
    } = _ref95;
    var info = useGridlist({
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      },
      /*singleSelectionParameters: {
          initiallySelectedIndex: initiallySelectedIndex ?? null,
          setSelectedIndex: setSelectedIndex ?? null
      },*/
      gridlistParameters: {
        selectionLimit,
        groupingType,
        selectedIndex,
        setSelectedIndex: setSelectedIndex !== null && setSelectedIndex !== void 0 ? setSelectedIndex : noop$1
      },
      gridNavigationParameters: {
        onTabbableColumnChange: onTabbableColumnChange !== null && onTabbableColumnChange !== void 0 ? onTabbableColumnChange : noop$1
      },
      labelParameters: {
        ariaLabel
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      }
    });
    A(ref, () => info);
    return o$1(GridlistContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  function noop$1() {}
  /*
  export const GridlistSection = memoForwardRef(function GridlistSectionU<SectionElement extends Element, RowElement extends Element, Cellement extends Element, CR = undefined, CC = undefined, KR extends string = never>({ render, compareRows, index }: GridlistSectionProps<SectionElement, RowElement, Cellement, CR, CC, KR>, ref?: Ref<any>) {
      const { useGridlistSectionProps, ...sectionInfo } = useContext(GridlistSectionContext)//({ compareRows });
      useImperativeHandle(ref!, () => sectionInfo);
      return <LocationIndexContext.Provider value={index}>{render(sectionInfo, useGridlistSectionProps)}</LocationIndexContext.Provider>
  })*/
  memoForwardRef(function GridlistRowU(_ref96, ref) {
    var {
      index,
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      ariaPropName,
      disabled,
      hidden,
      navigatePastEnd,
      navigatePastStart,
      noTypeahead,
      onTabbableIndexChange,
      selected,
      selectionMode,
      typeaheadTimeout,
      untabbable,
      getSortValue,
      getText,
      render
    } = _ref96;
    var context = q(GridlistContext);
    var info = useGridlistRow({
      asChildRowParameters: {
        completeGridNavigationRowParameters: {},
        context,
        managedChildParameters: {
          index
        },
        gridlistRowParameters: {
          selected: selected !== null && selected !== void 0 ? selected : null
        },
        rovingTabIndexChildParameters: {
          hidden: hidden !== null && hidden !== void 0 ? hidden : false
        },
        sortableChildParameters: {
          getSortValue
        },
        singleSelectionChildParameters: {
          disabled: disabled !== null && disabled !== void 0 ? disabled : false,
          ariaPropName,
          selectionMode: useDefault("selectionMode", selectionMode)
        },
        textContentParameters: {
          getText: useDefault("getText", getText)
        }
      },
      asParentRowParameters: {
        linearNavigationParameters: {
          disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
          disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
          navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
          navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap"
        },
        rovingTabIndexParameters: {
          onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
          untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
        },
        typeaheadNavigationParameters: {
          collator: useDefault("collator", collator),
          noTypeahead: useDefault("noTypeahead", noTypeahead),
          typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
        }
      }
      // gridlistRowContext,
    });

    A(ref, () => info);
    return o$1(GridlistRowContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  memoForwardRef(function GridlistChild(_ref97, ref) {
    var {
      index,
      colSpan,
      exclude,
      focusSelf,
      hidden,
      onPressSync,
      getText,
      render
    } = _ref97;
    var context = q(GridlistRowContext);
    var info = useGridlistCell({
      completeGridNavigationCellParameters: {},
      context,
      gridNavigationCellParameters: {
        colSpan: colSpan !== null && colSpan !== void 0 ? colSpan : 1
      },
      pressParameters: {
        exclude,
        focusSelf,
        onPressSync
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      }
    });
    A(ref, () => info);
    return render(info);
  });
  function useListbox(_ref98) {
    var {
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      sortableChildrenParameters,
      typeaheadNavigationParameters,
      labelParameters,
      listboxParameters: {
        selectionLimit,
        groupingType,
        selectedIndex,
        setSelectedIndex
      }
    } = _ref98;
    var {
      propsInput: propsLabelList,
      propsLabel: propsLabelLabel,
      randomIdInputReturn: {
        id: _inputId
      },
      randomIdLabelReturn: {
        id: _labelId
      }
    } = useLabelSynthetic({
      labelParameters: _objectSpread(_objectSpread({}, labelParameters), {}, {
        onLabelClick: useStableCallback(() => {
          rovingTabIndexReturn.focusSelf();
        })
      }),
      randomIdInputParameters: {
        prefix: Prefices.listbox
      },
      randomIdLabelParameters: {
        prefix: Prefices.listboxLabel
      }
    });
    var {
      childrenHaveFocusReturn,
      context,
      linearNavigationReturn,
      managedChildrenReturn,
      props,
      rearrangeableChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn
    } = useCompleteListNavigation({
      linearNavigationParameters,
      rearrangeableChildrenParameters,
      rovingTabIndexParameters,
      singleSelectionParameters: {
        initiallySelectedIndex: selectedIndex,
        setSelectedIndex
      },
      sortableChildrenParameters,
      typeaheadNavigationParameters
    });
    useSingleSelectionDeclarative({
      singleSelectionDeclarativeParameters: {
        selectedIndex
      },
      singleSelectionReturn: {
        setSelectedIndex: singleSelectionReturn.setSelectedIndex
      }
    });
    if (groupingType == "group") props.role = "group";else if (groupingType == "with-groups") {
      // Intentionally clobbering all the list navigation stuff.
      props = {
        role: "listbox"
      };
      // ...actually, context too while we're at it.
      context = null;
    } else {
      props.role = "listbox";
    }
    if (selectionLimit == "multi") console.assert(singleSelectionReturn.getSelectedIndex() == null);
    return {
      childrenHaveFocusReturn,
      context: useStableObject(_objectSpread(_objectSpread({}, context), {}, {
        listboxContext: useStableObject({
          selectionLimit
        })
      })),
      linearNavigationReturn,
      managedChildrenReturn,
      rearrangeableChildrenReturn,
      rovingTabIndexReturn,
      singleSelectionReturn,
      sortableChildrenReturn,
      typeaheadNavigationReturn,
      propsListbox: useMergedProps(props, propsLabelList, {
        "aria-multiselectable": selectionLimit == "multi" ? "true" : undefined
      }),
      propsListboxLabel: propsLabelLabel
    };
  }
  function useListboxItem(_ref99) {
    var {
        completeListNavigationChildParameters,
        pressParameters,
        context: {
          listboxContext: {
            selectionLimit
          }
        },
        managedChildParameters,
        singleSelectionChildParameters,
        rovingTabIndexChildParameters,
        sortableChildParameters,
        textContentParameters,
        listboxParameters: {
          selected
        }
      } = _ref99,
      context = _objectWithoutProperties(_ref99.context, _excluded73);
    var {
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      props,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
    } = useCompleteListNavigationChild({
      completeListNavigationChildParameters,
      textContentParameters,
      managedChildParameters,
      pressParameters,
      singleSelectionChildParameters,
      rovingTabIndexChildParameters,
      sortableChildParameters,
      context
    });
    if (selectionLimit == "single") console.assert(selected == null);
    props.role = "option";
    return {
      hasCurrentFocusReturn,
      managedChildReturn,
      pressReturn,
      props,
      rovingTabIndexChildReturn,
      singleSelectionChildReturn
    };
  }
  /*
  export function useListboxGroup<ContainerElement extends Element, HeadingElement extends Element>() {
      const {
          propsReferencer,
          propsSource,
          randomIdReturn
      } = useRandomId<HeadingElement, ContainerElement>({ randomIdParameters: { prefix: "listbox-multi-group-", otherReferencerProp: "aria-labelledby" } });
       propsReferencer.role = "group";
       return {
          propsHeading: propsSource,
          propsContainer: propsReferencer
      }
  }*/

  var ListboxContext = B$2(null);
  function Listbox(_ref100) {
    var {
      ariaLabel,
      collator,
      compare,
      disableArrowKeys,
      disableHomeEndKeys,
      getIndex,
      selectedIndex,
      navigatePastEnd,
      navigatePastStart,
      navigationDirection,
      noTypeahead,
      setSelectedIndex,
      onTabbableIndexChange,
      pageNavigationSize,
      selectionLimit,
      groupingType,
      untabbable,
      typeaheadTimeout,
      render
    } = _ref100;
    var info = useListbox({
      labelParameters: {
        ariaLabel
      },
      linearNavigationParameters: {
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        navigationDirection,
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      listboxParameters: {
        selectionLimit,
        groupingType,
        selectedIndex,
        setSelectedIndex: setSelectedIndex !== null && setSelectedIndex !== void 0 ? setSelectedIndex : noop
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      //singleSelectionParameters: { initiallySelectedIndex: initiallySelectedIndex ?? null, setSelectedIndex: setSelectedIndex ?? null },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      }
    });
    return o$1(ListboxContext.Provider, {
      value: info.context,
      children: render(info)
    });
  }
  function noop() {}
  function ListboxItem(_ref101) {
    var {
      ariaPropName,
      disabled,
      exclude,
      focusSelf,
      getText,
      hidden,
      index,
      onPressSync,
      render,
      selected,
      selectionMode,
      getSortValue
    } = _ref101;
    var context = q(ListboxContext);
    var focusSelfDefault = T$1(e => {
      e === null || e === void 0 ? void 0 : e.focus();
    }, []);
    var info = useListboxItem({
      completeListNavigationChildParameters: {},
      context,
      listboxParameters: {
        selected: selected !== null && selected !== void 0 ? selected : null
      },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue: getSortValue
      },
      pressParameters: {
        exclude,
        focusSelf: focusSelf !== null && focusSelf !== void 0 ? focusSelf : focusSelfDefault,
        onPressSync
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      },
      singleSelectionChildParameters: {
        disabled: disabled !== null && disabled !== void 0 ? disabled : false,
        ariaPropName,
        selectionMode: useDefault("selectionMode", selectionMode)
      }
    });
    return render(info);
  }
  var MenuItemContext = B$2(null);
  memoForwardRef(function MenubarU(_ref102, ref) {
    var {
      render,
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      navigatePastEnd,
      navigatePastStart,
      pageNavigationSize,
      orientation,
      noTypeahead,
      onTabbableIndexChange,
      compare,
      getIndex,
      untabbable,
      initiallySelectedIndex,
      setSelectedIndex,
      typeaheadTimeout,
      role
    } = _ref102;
    var info = useMenubar({
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      toolbarParameters: {
        orientation
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      singleSelectionParameters: {
        initiallySelectedIndex: initiallySelectedIndex !== null && initiallySelectedIndex !== void 0 ? initiallySelectedIndex : null,
        setSelectedIndex: setSelectedIndex !== null && setSelectedIndex !== void 0 ? setSelectedIndex : null
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      menubarParameters: {
        role: role !== null && role !== void 0 ? role : "menubar"
      }
    });
    A(ref, () => info);
    return o$1(MenuItemContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  var MenuItem = memoForwardRef(function MenuItemU(_ref103, ref) {
    var {
      index,
      render,
      ariaPropName,
      exclude,
      selectionMode,
      hidden,
      getText,
      disabled,
      onPress,
      getSortValue,
      role
    } = _ref103;
    var context = q(MenuItemContext); /*<MenuItemElement, C, K>)({
                                      managedChild: { index, flags },
                                      rovingTabIndex: { focusSelf, hidden, noModifyTabIndex },
                                      listNavigation: { text },
                                      hasFocus: { getDocument, getWindow, onActiveElementChange, onElementChange, onFocusedChanged, onFocusedInnerChanged, onLastActiveElementChange, onLastFocusedChanged, onLastFocusedInnerChanged, onMount, onUnmount, onWindowFocusedChange },
                                      menuItem: { disabled, onPress, role },
                                      subInfo
                                      });*/
    var info = useMenuItem({
      completeListNavigationChildParameters: {},
      context,
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      },
      menuItemParameters: {
        onPress: onPress !== null && onPress !== void 0 ? onPress : null,
        role: role !== null && role !== void 0 ? role : "menuitem"
      },
      pressParameters: {
        exclude
      },
      singleSelectionChildParameters: {
        ariaPropName,
        selectionMode,
        disabled: disabled !== null && disabled !== void 0 ? disabled : false
      }
    });
    A(ref, () => info);
    return o$1(p$1, {
      children: render(info)
    });
  });

  //const MenuItemContext = createContext<UseMenuItem<any, any, any>>(null!);
  var Menu = memoForwardRef(function Menu(_ref104, ref) {
    var {
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      noTypeahead,
      typeaheadTimeout,
      orientation,
      onClose,
      open,
      openDirection,
      onTabbableIndexChange,
      closeOnBackdrop,
      closeOnEscape,
      closeOnLostFocus,
      compare,
      getIndex,
      initiallySelectedIndex,
      navigatePastEnd,
      navigatePastStart,
      setSelectedIndex,
      pageNavigationSize,
      parentDepth,
      untabbable,
      onOpen,
      getWindow,
      render
    } = _ref104;
    var defaultParentDepth = q(ParentDepthContext);
    var myDepth = (parentDepth !== null && parentDepth !== void 0 ? parentDepth : defaultParentDepth) + 1;
    var info = useMenu({
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize),
        navigatePastEnd: "wrap",
        navigatePastStart: "wrap"
      },
      dismissParameters: {
        closeOnBackdrop: closeOnBackdrop !== null && closeOnBackdrop !== void 0 ? closeOnBackdrop : true,
        closeOnEscape: closeOnEscape !== null && closeOnEscape !== void 0 ? closeOnEscape : true,
        closeOnLostFocus: closeOnLostFocus !== null && closeOnLostFocus !== void 0 ? closeOnLostFocus : true,
        onClose,
        open
      },
      escapeDismissParameters: {
        getWindow: useDefault("getWindow", getWindow),
        parentDepth: parentDepth !== null && parentDepth !== void 0 ? parentDepth : defaultParentDepth
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      singleSelectionParameters: {
        initiallySelectedIndex: initiallySelectedIndex !== null && initiallySelectedIndex !== void 0 ? initiallySelectedIndex : null,
        setSelectedIndex: setSelectedIndex !== null && setSelectedIndex !== void 0 ? setSelectedIndex : null
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      menuParameters: {
        openDirection,
        onOpen
      },
      menuSurfaceParameters: {},
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      },
      toolbarParameters: {
        orientation
      },
      menubarParameters: {}
    });
    A(ref, () => info);
    //const { useMenuSentinelProps: useFirstSentinelProps } = useMenuSentinel<SentinelElement>();
    //const { useMenuSentinelProps: useLastSentinelProps } = useMenuSentinel<SentinelElement>();
    return o$1(ParentDepthContext.Provider, {
      value: myDepth,
      children: o$1(MenuItemContext.Provider, {
        value: info.context,
        children: render(info)
      })
    });
  });
  var RadioContext = B$2(null);
  var RadioGroup = memoForwardRef(function RadioGroup(_ref105, ref) {
    var {
      render,
      name,
      setSelectedValue,
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      navigationDirection,
      noTypeahead,
      typeaheadTimeout,
      ariaLabel,
      compare,
      getIndex,
      navigatePastEnd,
      navigatePastStart,
      selectedValue,
      untabbable,
      onTabbableIndexChange,
      pageNavigationSize
    } = _ref105;
    var info = useRadioGroup({
      linearNavigationParameters: {
        navigationDirection,
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      labelParameters: {
        ariaLabel
      },
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      radioGroupParameters: {
        name,
        setSelectedValue,
        selectedValue
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      }
      // childrenHaveFocusParameters: {  },
      //        singleSelectionParameters: {  }
    });

    A(ref, () => info);
    return o$1(RadioContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  /*export interface DefaultRenderRadioParameters<LP extends LabelPosition, V extends string | number, I extends Element, IL extends Element, TCE extends Element> extends DefaultRenderCheckboxLikeParameters<I, IL, UseRadioReturnType<LP, V, I, IL, TCE, RadioSubInfo<TCE, V>>> {
   }*/
  /*
  export function defaultRenderRadio<V extends string | number, I extends HTMLElement, IL extends HTMLElement, TCE extends I | IL>({ tagInput, tagLabel, makePropsInput, makePropsLabel, labelPosition }: DefaultRenderRadioParameters<V, I, IL, TCE>) {
      return defaultRenderCheckboxLike<I, IL, UseRadioReturnType<V, I, IL, TCE, RadioSubInfo<TCE, V>>>({ labelPosition, tagInput, tagLabel, makePropsInput, makePropsLabel });
  }
  */
  var Radio = memoForwardRef(function Radio(_ref106, ref) {
    var {
      disabled,
      index,
      render,
      value,
      ariaLabel,
      exclude,
      focusSelf,
      labelPosition,
      onPressSync,
      selectionMode,
      hidden,
      tagInput,
      tagLabel,
      getText
    } = _ref106;
    var context = q(RadioContext);
    var getValue = useStableGetter(value);
    var defaultFocusSelf = () => info.checkboxLikeReturn.focusSelf();
    var info = useRadio({
      //listNavigationParameters: { text },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue: getValue
      },
      radioParameters: {
        value
      },
      checkboxLikeParameters: {
        disabled: disabled !== null && disabled !== void 0 ? disabled : false
      },
      completeListNavigationChildParameters: {
        getValue
      },
      context,
      labelParameters: {
        ariaLabel,
        labelPosition,
        tagInput,
        tagLabel
      },
      pressParameters: {
        exclude,
        focusSelf: focusSelf !== null && focusSelf !== void 0 ? focusSelf : defaultFocusSelf,
        onPressSync
      },
      singleSelectionChildParameters: {
        selectionMode: useDefault("selectionMode", selectionMode),
        disabled: !!disabled
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      }
      //rovingTabIndexParameters: { hidden, focusSelf, noModifyTabIndex },
      //hasFocusParameters: { getDocument, getWindow, onActiveElementChange, onElementChange, onFocusedChanged, onFocusedInnerChanged, onLastActiveElementChange, onLastFocusedChanged, onLastFocusedInnerChanged, onMount, onUnmount, onWindowFocusedChange },
      //subInfoParameters: {  },
      //singleSelectionParameters: { unselectable, focusSelf }
    });

    A(ref, () => info);
    //    const { useRadioInputProps } = useRadioInput({ tag: tagInput });
    //    const { useRadioLabelProps } = useRadioLabel({ tag: tagLabel });
    return render(info);
  });
  var SliderThumbContext = B$2(null);
  var Slider = memoForwardRef(function Slider(_ref107, ref) {
    var {
      max,
      min,
      onAfterChildLayoutEffect,
      onChildrenMountChange,
      children
    } = _ref107;
    var info = useSlider({
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange
      },
      sliderParameters: {
        max,
        min
      }
    });
    A(ref, () => info);
    return o$1(SliderThumbContext.Provider, {
      value: info.context,
      children: children
    });
  });
  var SliderThumb = memoForwardRef(function SliderThumbU(_ref108, ref) {
    var {
      label,
      tag,
      value,
      max,
      min,
      onValueChange,
      index,
      render,
      valueText
    } = _ref108;
    var context = q(SliderThumbContext);
    var info = useSliderThumb({
      context,
      managedChildParameters: {
        index
      },
      sliderThumbParameters: {
        label,
        tag,
        value,
        max,
        min,
        onValueChange,
        valueText
      }
      //subInfo
    });

    A(ref, () => info);
    return render(info);
  });

  //const LocationContext = createContext<"head" | "body" | "foot">(null!);
  var TableSectionContext = B$2(null);
  var TableRowContext = B$2(null);
  memoForwardRef(function TableU(_ref109, ref) {
    var {
      ariaLabel,
      selectionLimit,
      tagTable,
      render
    } = _ref109;
    var info = useTable({
      labelParameters: {
        ariaLabel
      },
      tableParameters: {
        selectionLimit,
        tagTable
      }
    });
    A(ref, () => info);
    return render(info);
  });
  memoForwardRef(function TableSection(_ref110) {
    var {
      collator,
      compare,
      disableArrowKeys,
      disableHomeEndKeys,
      getIndex,
      initiallySelectedIndex,
      untabbable,
      navigatePastEnd,
      navigatePastStart,
      noTypeahead,
      setSelectedIndex,
      onTabbableColumnChange,
      onTabbableIndexChange,
      pageNavigationSize,
      render,
      tagTableSection,
      typeaheadTimeout
    } = _ref110;
    var info = useTableSection({
      gridNavigationParameters: {
        onTabbableColumnChange
      },
      linearNavigationParameters: {
        disableArrowKeys,
        disableHomeEndKeys,
        navigatePastEnd,
        navigatePastStart,
        pageNavigationSize
      },
      rearrangeableChildrenParameters: {
        getIndex
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange,
        untabbable
      },
      singleSelectionParameters: {
        initiallySelectedIndex,
        setSelectedIndex
      },
      sortableChildrenParameters: {
        compare
      },
      tableSectionParameters: {
        tagTableSection
      },
      typeaheadNavigationParameters: {
        collator,
        noTypeahead,
        typeaheadTimeout
      }
    });
    return o$1(TableSectionContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  /*
  export const TableBody = memoForwardRef(function TableBodyU<SectionElement extends Element, RowElement extends Element, Cellement extends Element, CR = undefined, CC = undefined, KR extends string = never>({ render }: TableBodyProps<SectionElement, RowElement, Cellement, CR, CC, KR>, ref?: Ref<any>) {
      const { useTableBodyProps, ...sectionInfo } = useContext(TableBodyContext)({});
       useImperativeHandle(ref!, () => sectionInfo);
       return <LocationContext.Provider value="body">{render(sectionInfo, useTableBodyProps)}</LocationContext.Provider>
  })
   export const TableHead = memoForwardRef(function TableHeadU<T extends Element>({ render, tagTableHead }: TableHeadProps<T>) {
      const useTableSectionPropsBase = useContext(TableSectionContext);
      const useTableSectionProps: PropModifier<T> = (props) => useTableSectionPropsBase(tagTableHead, "head", props);
      return <LocationContext.Provider value="head">{(render(useTableSectionProps))}</LocationContext.Provider>
  })
   export const TableFoot = memoForwardRef(function TableFootU<T extends Element>({ render, tagTableFoot }: TableFootProps<T>) {
      const useTableSectionPropsBase = useContext(TableSectionContext);
      const useTableSectionProps: PropModifier<T> = (props) => useTableSectionPropsBase(tagTableFoot, "foot", props);
      return <LocationContext.Provider value="foot">{(render(useTableSectionProps))}</LocationContext.Provider>
  })*/
  memoForwardRef(function TableRowU(_ref111, ref) {
    var {
      index,
      getText,
      tagTableRow,
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      noTypeahead,
      onTabbableIndexChange,
      typeaheadTimeout,
      ariaPropName,
      disabled,
      untabbable,
      navigatePastEnd,
      navigatePastStart,
      selected,
      selectionMode,
      getSortValue,
      hidden,
      render
    } = _ref111;
    var cx1 = q(TableSectionContext);
    var info = useTableRow({
      asChildRowParameters: {
        completeGridNavigationRowParameters: {},
        context: cx1,
        managedChildParameters: {
          index
        },
        rovingTabIndexChildParameters: {
          hidden: hidden !== null && hidden !== void 0 ? hidden : false
        },
        sortableChildParameters: {
          getSortValue
        },
        singleSelectionChildParameters: {
          ariaPropName,
          selectionMode,
          disabled
        },
        textContentParameters: {
          getText
        }
      },
      asParentRowParameters: {
        linearNavigationParameters: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigatePastEnd,
          navigatePastStart
        },
        rovingTabIndexParameters: {
          onTabbableIndexChange,
          untabbable
        },
        typeaheadNavigationParameters: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      },
      tableRowParameters: {
        selected,
        tagTableRow
      }
    });
    A(ref, () => info);
    return o$1(TableRowContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  memoForwardRef(function TableCell(_ref112, ref) {
    var {
      index,
      getText,
      focusSelf,
      hidden,
      tagTableCell,
      render,
      colSpan,
      exclude,
      onPressSync
    } = _ref112;
    var context = q(TableRowContext);
    var focusSelfDefault = T$1(e => {
      e === null || e === void 0 ? void 0 : e.focus();
    }, []);
    var info = useTableCell({
      completeGridNavigationCellParameters: {},
      context,
      gridNavigationCellParameters: {
        colSpan: colSpan !== null && colSpan !== void 0 ? colSpan : 1
      },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      pressParameters: {
        exclude,
        focusSelf: focusSelf !== null && focusSelf !== void 0 ? focusSelf : focusSelfDefault,
        onPressSync
      },
      tableCellParameters: {
        tagTableCell
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      }
      /* listNavigation: { text },
       managedChild: { index, flags },
       rovingTabIndex: { focusSelf, hidden, noModifyTabIndex },
       hasFocus: { getDocument, getWindow, onActiveElementChange, onElementChange, onFocusedChanged, onFocusedInnerChanged, onLastActiveElementChange, onLastFocusedChanged, onLastFocusedInnerChanged, onMount, onUnmount, onWindowFocusedChange },
       subInfo,
       tableCell: {
           value,
           headerType,
           tagTableCell,
           location: useContext(LocationContext)
       }*/
    });

    A(ref, () => info);
    return render(info);
  });
  B$2(null);
  B$2(null);

  /*export function defaultRenderToasts({}: {}) {
      return function (args: UseToastsReturnTypeInfo, props: h.JSX.HTMLAttributes<ContainerType>) {
          return (
          <div>
           </div>
          )
      }
  }*/
  var ToastContext = B$2(null);
  memoForwardRef(function Toasts(_ref113, ref) {
    var {
      onAfterChildLayoutEffect,
      onChildrenMountChange,
      render,
      visibleCount
    } = _ref113;
    var info = useToasts({
      managedChildrenParameters: {
        onAfterChildLayoutEffect,
        onChildrenMountChange
      },
      toastsParameters: {
        visibleCount
      }
    });
    A(ref, () => info);
    return o$1(ToastContext.Provider, {
      value: info.context,
      children: render(info)
    });
  });
  memoForwardRef(function Toast(_ref114, ref) {
    var {
      render,
      index,
      timeout,
      politeness
    } = _ref114;
    var context = q(ToastContext);
    var info = useToast({
      managedChildParameters: {
        index
      },
      toastParameters: {
        timeout,
        politeness
      },
      context
    });
    A(ref, () => info);
    return render(info);
  });
  var ToolbarContext = B$2(null);
  memoForwardRef(function ToolbarU(_ref115, ref) {
    var {
      render,
      role,
      collator,
      disableArrowKeys,
      disableHomeEndKeys,
      untabbable,
      compare,
      getIndex,
      navigatePastEnd,
      navigatePastStart,
      pageNavigationSize,
      initiallySelectedIndex,
      setSelectedIndex,
      orientation,
      noTypeahead,
      onTabbableIndexChange,
      typeaheadTimeout
    } = _ref115;
    var listboxReturnType = useToolbar({
      rearrangeableChildrenParameters: {
        getIndex: useDefault("getIndex", getIndex)
      },
      singleSelectionParameters: {
        initiallySelectedIndex: initiallySelectedIndex !== null && initiallySelectedIndex !== void 0 ? initiallySelectedIndex : null,
        setSelectedIndex: setSelectedIndex !== null && setSelectedIndex !== void 0 ? setSelectedIndex : null
      },
      sortableChildrenParameters: {
        compare: compare !== null && compare !== void 0 ? compare : null
      },
      linearNavigationParameters: {
        disableArrowKeys: useDefault("disableArrowKeys", disableArrowKeys),
        disableHomeEndKeys: useDefault("disableHomeEndKeys", disableHomeEndKeys),
        navigatePastEnd: navigatePastEnd !== null && navigatePastEnd !== void 0 ? navigatePastEnd : "wrap",
        navigatePastStart: navigatePastStart !== null && navigatePastStart !== void 0 ? navigatePastStart : "wrap",
        pageNavigationSize: useDefault("pageNavigationSize", pageNavigationSize)
      },
      toolbarParameters: {
        orientation,
        role: role !== null && role !== void 0 ? role : "toolbar"
      },
      rovingTabIndexParameters: {
        onTabbableIndexChange: onTabbableIndexChange !== null && onTabbableIndexChange !== void 0 ? onTabbableIndexChange : null,
        untabbable: untabbable !== null && untabbable !== void 0 ? untabbable : false
      },
      typeaheadNavigationParameters: {
        collator: useDefault("collator", collator),
        noTypeahead: useDefault("noTypeahead", noTypeahead),
        typeaheadTimeout: useDefault("typeaheadTimeout", typeaheadTimeout)
      }
    });
    A(ref, () => listboxReturnType);
    return o$1(ToolbarContext.Provider, {
      value: listboxReturnType.context,
      children: render(listboxReturnType)
    });
  });
  memoForwardRef(function ToolbarChildU(_ref116, ref) {
    var {
      index,
      render,
      ariaPropName,
      disabled,
      exclude,
      onPressSync,
      selectionMode,
      focusSelf,
      getSortValue,
      hidden,
      getText
    } = _ref116;
    var context = q(ToolbarContext);
    var focusSelfDefault = T$1(e => {
      e === null || e === void 0 ? void 0 : e.focus();
    }, []);
    var info = useToolbarChild({
      context,
      //completeListNavigationChildParameters: subInfo,
      completeListNavigationChildParameters: {},
      pressParameters: {
        exclude,
        focusSelf: focusSelf !== null && focusSelf !== void 0 ? focusSelf : focusSelfDefault,
        onPressSync
      },
      managedChildParameters: {
        index
      },
      rovingTabIndexChildParameters: {
        hidden: hidden !== null && hidden !== void 0 ? hidden : false
      },
      sortableChildParameters: {
        getSortValue
      },
      singleSelectionChildParameters: {
        ariaPropName,
        selectionMode,
        disabled: disabled !== null && disabled !== void 0 ? disabled : false
      },
      textContentParameters: {
        getText: useDefault("getText", getText)
      }
    });
    A(ref, () => info);
    return o$1(p$1, {
      children: render(info)
    });
  });
  memoForwardRef(function TooltipU(_ref117, ref) {
    var {
      focusDelay,
      mouseoutToleranceDelay,
      mouseoverDelay,
      render
    } = _ref117;
    var info = useTooltip({
      focusDelay,
      mouseoutToleranceDelay,
      mouseoverDelay
    });
    A(ref, () => info);
    return render(info);
  });
  function DemoAccordion(_ref118) {
    var {
        children
      } = _ref118,
      props = _objectWithoutProperties(_ref118, _excluded74);
    return o$1(Accordion, {
      navigationDirection: "vertical",
      render: _info => {
        return o$1("div", {
          id: "accordion-demo",
          children: children
        });
      }
    });
  }
  var DemoAccordionSection = R(function DemoAccordionSection(_ref119) {
    var {
      index,
      body,
      heading,
      disabled,
      open
    } = _ref119;
    return o$1(AccordionSection, {
      index: index,
      tagButton: "button",
      open: open,
      disabled: disabled,
      render: info => o$1(Heading, _objectSpread(_objectSpread({}, info.propsHeader), {}, {
        tag: "div",
        heading: o$1(p$1, {
          children: [o$1("span", {
            children: heading
          }), o$1("button", _objectSpread(_objectSpread({}, info.propsHeaderButton), {}, {
            children: "Toggle open"
          }))]
        }),
        children: o$1("p", _objectSpread(_objectSpread({}, info.propsBody), {}, {
          hidden: !info.accordionSectionReturn.expanded,
          children: body
        }))
      }))
    });
  });
  function Blurb$8() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/accordion/",
          children: "In accordance with the ARIA guidelines for Accordion patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["Each section's header and body are linked via ID; the body is ", o$1("code", {
            children: "labelled-by"
          }), " the header and the header ", o$1("code", {
            children: "control"
          }), "s the body."]
        }), o$1("li", {
          children: "The header is a button and responds to keyboard, mouse, touch, etc. events, regardless of the element used."
        }), o$1("li", {
          children: ["If the header element is not a ", o$1("code", {
            children: "<button>"
          }), " element, it is given that ", o$1("code", {
            children: "role"
          }), "."]
        }), o$1("li", {
          children: "Up/down & Home/End keys navigate through the list, as does Tab and Shift+Tab"
        }), o$1("li", {})]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: ["The ", o$1("code", {
            children: "render"
          }), " prop each ", o$1("code", {
            children: "AccordionSection"
          }), " takes must wrap the header button with a ", o$1("a", {
            href: "https://w3c.github.io/aria/#heading",
            children: "heading"
          }), " (e.g. ", o$1("code", {
            children: "h3"
          }), ", or ", o$1("code", {
            children: "<Heading>"
          }), "). See the default implementation for an example."]
        })
      })]
    });
  }
  function Code$8() {
    return o$1("code", {
      children: "<Accordion render={...}>\n    <AccordionSection index={0} render={...} />\n    <AccordionSection index={1} render={...} />\n    <AccordionSection index={2} render={...} />\n</Accordion>"
    });
  }
  function Demo$8() {
    var [count, setCount] = p(5);
    return o$1(p$1, {
      children: [o$1(Blurb$8, {}), o$1(Code$8, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of accordion sections"]
      }), o$1(DemoAccordion, {
        children: o$1(p$1, {
          children: Array.from(function* () {
            yield o$1(DemoAccordionSection, {
              index: 0,
              heading: "Accordion section #0",
              body: "Body content #0",
              disabled: false
            });
            yield o$1(DemoAccordionSection, {
              index: 1,
              heading: "Accordion section #1",
              body: "Body content #1",
              disabled: false
            });
            yield o$1(DemoAccordionSection, {
              index: 2,
              heading: "Accordion section #2 (disabled)",
              body: "Body content #2",
              disabled: true
            });
            yield o$1(DemoAccordionSection, {
              index: 3,
              heading: "Accordion section #3 (forced open)",
              body: "Body content #3",
              disabled: false,
              open: true
            });
            yield o$1(DemoAccordionSection, {
              index: 4,
              heading: "Accordion section #4 (forced closed)",
              body: "Body content #4",
              disabled: false,
              open: false
            });
            for (var _i7 = 5; _i7 < count; ++_i7) {
              yield o$1(DemoAccordionSection, {
                index: _i7,
                heading: "Accordion section #".concat(_i7),
                body: "BodyContent #".concat(_i7),
                disabled: false
              });
            }
          }()).slice(0, count)
        })
      })]
    });
  }
  function Blurb$7() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/button/",
          children: "In accordance with the ARIA guidelines for Button patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["Whether using an actual ", o$1("code", {
            children: "<button>"
          }), ", or something else like a ", o$1("code", {
            children: "<div>"
          }), ", the proper roles and event handlers will be applied."]
        }), o$1("li", {
          children: "Buttons can be toggled (pressed or unpressed)."
        }), o$1("li", {
          children: ["The button responds to keyboard, mouse, touch, etc. events, regardless of the element used.", o$1("ul", {
            children: [o$1("li", {
              children: "Double-clicks do not select text, but text is still selectable without it counting as a press/click"
            }), o$1("li", {
              children: "When Enter is pressed, the button is immediately activated"
            }), o$1("li", {
              children: "When Space is pressed, the button is activated once released"
            }), o$1("li", {
              children: "iOS Safari properly focuses the button"
            })]
          })]
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: ["If your button contains only an icon (or other non-descriptive content, etc.), you must provide an ", o$1("code", {
            children: "aria-label"
          }), " manually stating what happens when the button is pressed."]
        })
      })]
    });
  }
  function Code$7() {
    return o$1("code", {
      children: "<Button tag=\"button\">Button</Button>\n    <Button tag=\"div\">Div</Button>"
    });
  }
  function Demo$7() {
    var [pressed, setPressed] = useState(false);
    return o$1(p$1, {
      children: [o$1(Blurb$7, {}), o$1(Code$7, {}), o$1(DemoButton, {
        disabled: false,
        tag: "button"
      }), o$1(DemoButton, {
        disabled: "soft",
        tag: "button"
      }), o$1(DemoButton, {
        disabled: "hard",
        tag: "button"
      }), o$1(DemoButton, {
        disabled: false,
        tag: "div"
      }), o$1(DemoButton, {
        disabled: "soft",
        tag: "div"
      }), o$1(DemoButton, {
        disabled: "hard",
        tag: "div"
      }), o$1(Button, {
        exclude: undefined,
        tagButton: "button",
        pressed: pressed,
        onPress: e => {
          var _e$EventDetail$presse;
          return setPressed((_e$EventDetail$presse = e[EventDetail].pressed) !== null && _e$EventDetail$presse !== void 0 ? _e$EventDetail$presse : false);
        },
        render: info => o$1("button", _objectSpread(_objectSpread({}, info.props), {}, {
          children: "Toggle button (".concat(pressed ? "pressed" : "unpressed", ")")
        }))
      })]
    });
  }
  function DemoButton(_ref120) {
    var {
      tag,
      disabled
    } = _ref120;
    var onPress = () => {
      alert("Button clicked");
    };
    return o$1(Button, {
      disabled: disabled,
      tagButton: tag,
      onPress: onPress,
      render: info => o$1("button", _objectSpread(_objectSpread({}, info.props), {}, {
        children: "".concat(tag, " ").concat(disabled ? " disabled (".concat(disabled == "soft" ? "soft" : "hard", ")") : "")
      }))
    });
  }

  /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
      return <Button disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
  }*/
  function Blurb$6() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/checkbox/",
          children: "In accordance with the ARIA guidelines for Checkbox patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: "Toggles between checked and unchecked when pressed (clicked, Enter pressed, Space released, etc.)"
        }), o$1("li", {
          children: ["Can be ", o$1("code", {
            children: "mixed"
          }), " instead, though ", o$1("code", {
            children: "onInput"
          }), " will only ever be called with ", o$1("code", {
            children: "true"
          }), " or ", o$1("code", {
            children: "false"
          })]
        }), o$1("li", {
          children: ["Supports using ", o$1("code", {
            children: "<input>"
          }), "s and ", o$1("code", {
            children: "<label>"
          }), "s, as well as just plain ol' ", o$1("code", {
            children: "<div>"
          }), "s on either/both"]
        }), o$1("li", {
          children: "The checkbox and label can be sibling elements, like normal, or the label can wrap the input for a larger hit area. In all cases, the appropriate roles/event handlers will be applied to each element."
        }), o$1("li", {
          children: "When selecting the text of a checkbox's label, this does not change the checkbox's state"
        }), o$1("li", {
          children: "Double-clicking the label checks & un-checks the checkbox instead of selecting the label's text"
        }), o$1("li", {
          children: "Checkbox groups (with a tri-state parent) are a separate component/hook"
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", {
            children: "render"
          }), " prop and setting ", o$1("code", {
            children: "labelPosition"
          }), " to be \"separate\"), you must pass ", o$1("code", {
            children: "aria-label"
          }), " as a prop to the checkbox manually. Not providing one will print an error to the console, but it it not required by the type system."]
        })
      })]
    });
  }
  function Code$6() {
    return o$1("code", {
      children: "<Checkbox checked={true} labelPosition=\"separate\" tagInput=\"input\" tagLabel=\"label\">Label text</Checkbox>"
    });
  }
  function Demo$6() {
    var [checked, setChecked] = useState(false);
    var [disabled, setDisabled] = useState(false);
    return o$1(p$1, {
      children: [o$1(Blurb$6, {}), o$1(Code$6, {}), o$1(Checkbox, {
        checked: disabled,
        onCheckedChange: e => setDisabled(e[EventDetail].checked),
        ariaLabel: null,
        labelPosition: "separate",
        tagInput: "input",
        tagLabel: "label",
        render: info => o$1(p$1, {
          children: [o$1("input", _objectSpread({}, info.propsInput)), o$1("label", _objectSpread(_objectSpread({}, info.propsLabel), {}, {
            children: "Disabled"
          }))]
        })
      }), o$1(Button, {
        tagButton: "button",
        onPress: () => {
          setChecked("mixed");
        },
        render: info => o$1("button", _objectSpread(_objectSpread({}, info.props), {}, {
          children: "Change to mixed"
        }))
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "separate",
        disabled: disabled,
        tagInput: "input",
        tagLabel: "label"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "wrapping",
        disabled: disabled,
        tagInput: "input",
        tagLabel: "label"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "separate",
        disabled: disabled,
        tagInput: "div",
        tagLabel: "label"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "wrapping",
        disabled: disabled,
        tagInput: "div",
        tagLabel: "label"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "separate",
        disabled: disabled,
        tagInput: "input",
        tagLabel: "div"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "wrapping",
        disabled: disabled,
        tagInput: "input",
        tagLabel: "div"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "separate",
        disabled: disabled,
        tagInput: "div",
        tagLabel: "div"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "wrapping",
        disabled: disabled,
        tagInput: "div",
        tagLabel: "div"
      }), o$1(DemoCheckbox$1, {
        checked: checked,
        setChecked: setChecked,
        labelPosition: "hidden",
        disabled: disabled,
        tagInput: "input",
        tagLabel: "label"
      })]
    });
  }
  function DemoCheckbox$1(_ref121) {
    var {
      labelPosition,
      tagInput,
      tagLabel,
      disabled,
      checked,
      setChecked
    } = _ref121;
    //const [checked, setChecked] = useState(false);
    return o$1("div", {
      style: {
        border: "1px solid black"
      },
      children: [o$1(Checkbox, {
        ariaLabel: null,
        disabled: disabled,
        checked: checked,
        onCheckedChange: e => setChecked(e[EventDetail].checked),
        labelPosition: labelPosition == "hidden" ? "separate" : labelPosition,
        tagInput: tagInput,
        tagLabel: tagLabel,
        render: defaultRenderCheckboxLike({
          labelPosition,
          tagInput: tagInput,
          tagLabel: tagLabel,
          makePropsInput: info => useMergedProps(info.propsInput, {
            "aria-label": labelPosition == "hidden" ? "Hidden label (technically separate), ".concat(tagInput, " and ").concat(tagLabel, " ").concat(checked ? "checked" : "not checked") : undefined
          }),
          makePropsLabel: info => useMergedProps(info.propsLabel, {
            children: "".concat(labelPosition, ", ").concat(tagInput, " and ").concat(tagLabel, ", ").concat(checked ? "checked" : "not checked")
          })
        })
      }), labelPosition == "hidden" && o$1("div", {
        children: ["(This is not a label -- the actual label is via the ", o$1("code", {
          children: "aria-label"
        }), " prop)"]
      })]
    });
  }
  function DemoCheckbox(_ref122) {
    var {
      index
    } = _ref122;
    var [checked, setChecked] = useState(false);
    var ref = _(null);
    return o$1(CheckboxGroupChild, {
      checked: checked,
      index: index,
      focusSelf: () => {
        var _ref$current;
        return (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.checkboxLikeReturn.focusSelf();
      },
      onChangeFromParent: function () {
        var _ref123 = _asyncToGenerator(function* (checked) {
          yield new Promise(resolve => setTimeout(resolve, Math.random() * 2000));
          setChecked(checked);
        });
        return function onChangeFromParent(_x2) {
          return _ref123.apply(this, arguments);
        };
      }(),
      getSortValue: returnNull,
      //focusSelf={useStableCallback((e) => e.focus())}
      render: info => {
        return o$1(Checkbox, {
          ref: ref,
          checked: checked,
          disabled: false,
          ariaLabel: null,
          onCheckedChange: e => {
            setChecked(e[EventDetail].checked);
            info.checkboxGroupChild.onChildCheckedChange(e[EventDetail].checked);
          },
          labelPosition: "separate",
          tagInput: "input",
          tagLabel: "label",
          render: defaultRenderCheckboxLike({
            labelPosition: "separate",
            tagInput: "input",
            tagLabel: "label",
            makePropsInput: info => info.propsInput,
            makePropsLabel: info => _objectSpread({
              children: "Checkbox #".concat(index)
            }, info.propsLabel)
          })
        });
      }
    });
  }
  function Blurb$5() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: ["Checkbox groups are an alternative to multi-select lists. There is no role of ", o$1("code", {
          children: "checkboxgroup"
        }), ", but this aims to be an ARIA-compliant implementation of a checkbox group."]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["All normal ", o$1("code", {
            children: "Checkbox"
          }), " functionality is supported on each individual checkbox."]
        }), o$1("li", {
          children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"."
        }), o$1("li", {
          children: ["The parent's \"mixed\" state changes all children back to whatever state the user had most recently created; the distinction is drawn when a child calls ", o$1("code", {
            children: "onChildCheckedChange"
          }), " during its event handler. This call is what notifies the parent checkbox what to use when switching to that \"mixed\" state."]
        }), o$1("li", {
          children: ["The children are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        }), o$1("li", {
          children: [o$1("code", {
            children: "aria-controls"
          }), " is set on the parent Checkbox to contain the IDs of all child checkboxes. This has no effect on any technology that I am aware of, but it's there just in case."]
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: [o$1("li", {
          children: [o$1("code", {
            children: "CheckboxGroupParent"
          }), " has supports child checkboxes being asyncronous (e.g. if each child's ", o$1("code", {
            children: "onChangeFromParent"
          }), " is async, then the parent's ", o$1("code", {
            children: "onParentCheckedChange"
          }), " will asyncronously wait for all of them), but you must apply any relevant labelling of this circumstance yourself."]
        }), o$1("li", {
          children: ["As mentioned, ", o$1("code", {
            children: "aria-controls"
          }), " basically does nothing. Please ensure you're using good labelling here; it is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", {
            children: "role=group"
          }), " that references that label by overriding ", o$1("code", {
            children: "render"
          }), "."]
        })]
      })]
    });
  }
  function Code$5() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$5() {
    var [count, setCount] = useState(5);
    useState(false);
    return o$1(p$1, {
      children: [o$1(Blurb$5, {}), o$1(Code$5, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of checkboxes"]
      }), o$1("div", {
        children: [o$1("p", {
          children: [o$1("strong", {
            children: "Note:"
          }), " Each checkbox takes a random amount of time to update when modified via the parent checkbox to test async handling."]
        }), o$1(CheckboxGroup, {
          navigationDirection: "vertical",
          render: info => {
            var ref = _(null);
            return o$1("div", _objectSpread(_objectSpread({}, info.props), {
              children: o$1(p$1, {
                children: [o$1(CheckboxGroupParent, {
                  index: 0,
                  focusSelf: () => {
                    var _ref$current2;
                    return (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.checkboxLikeReturn.focusSelf();
                  },
                  getSortValue: returnNull,
                  render: info => o$1(Checkbox, {
                    ref: ref,
                    checked: info.checkboxGroupParentReturn.checked,
                    onCheckedChange: info.checkboxGroupParentReturn.onParentCheckedChange,
                    ariaLabel: "Parent checkbox",
                    labelPosition: "separate",
                    tagInput: "input",
                    tagLabel: "label",
                    render: defaultRenderCheckboxLike({
                      labelPosition: "separate",
                      makePropsInput: info => _objectSpread({}, info.propsInput),
                      makePropsLabel: info => _objectSpread({
                        children: "Parent checkbox"
                      }, info.propsLabel),
                      tagInput: "input",
                      tagLabel: "label"
                    })
                  })
                }), o$1("div", {
                  style: {
                    display: "flex"
                  },
                  children: o$1(p$1, {
                    children: Array.from(function* () {
                      for (var _i8 = 0; _i8 < count; ++_i8) {
                        yield o$1(DemoCheckbox, {
                          index: _i8 + 1
                        }, _i8);
                      }
                    }())
                  })
                })]
              })
            }));
          }
        })]
      })]
    });
  }
  var DemoListItem$2 = R(function DemoListItem(_ref124) {
    var {
      index
    } = _ref124;
    var [selected, setSelected] = useState(false);
    var labelText = "List item #".concat(index).concat(selected ? " (selected)" : "");
    return o$1(ListboxItem, {
      selected: selected,
      index: index,
      disabled: false,
      ariaPropName: "aria-selected",
      getSortValue: returnZero,
      onPressSync: e => {
        setSelected(p => !p);
      },
      render: info => {
        return o$1("li", _objectSpread(_objectSpread({}, info.props), {}, {
          children: labelText
        }));
      }
    });
  });
  function Blurb$4() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/",
          children: "In accordance with the ARIA guidelines for Listbox patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["The children are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        }), o$1("li", {
          children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"."
        }), o$1("li", {
          children: ["The parent checkbox reacts to each child's ", o$1("code", {
            children: "checked"
          }), " prop and updates its own internal ", o$1("code", {
            children: "checked"
          }), " attribute (be aware of this if they're asyncronous, as you'll want to ensure they all resolve on the same tick with ", o$1("code", {
            children: "Promise.all"
          }), " to not clobber the user's inputs)."]
        }), o$1("li", {
          children: ["The children are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        }), o$1("li", {
          children: "Grouping is supported"
        }), o$1("li", {
          children: "Sorting/reordering is supported, though not provided by default, as it's mutually exclusive with grouping."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["It is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", {
            children: "role=group"
          }), " that references that label by overriding ", o$1("code", {
            children: "render"
          }), "."]
        }), o$1("li", {
          children: ["See the caveat above for when each child's ", o$1("code", {
            children: "onInput"
          }), " takes a variable amount of time to actually update the ", o$1("code", {
            children: "checked"
          }), " prop, as it can clobber the user's last input when clicking on the parent"]
        })]
      })]
    });
  }
  function Code$4() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$4() {
    var [count, setCount] = useState(5);
    return o$1(p$1, {
      children: [o$1(Blurb$4, {}), o$1(Code$4, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of list items"]
      }), o$1("div", {
        children: o$1(Listbox, {
          selectedIndex: null,
          ariaLabel: null,
          groupingType: "without-groups",
          navigationDirection: "vertical",
          selectionLimit: "single",
          render: info => {
            return o$1(p$1, {
              children: [o$1("label", _objectSpread({}, info.propsListboxLabel)), o$1("ul", _objectSpread(_objectSpread({}, info.propsListbox), {}, {
                children: Array.from(function* () {
                  for (var _i9 = 0; _i9 < count; ++_i9) {
                    yield o$1(DemoListItem$2, {
                      index: _i9
                    }, _i9);
                  }
                }())
              }))]
            });
          }
        })
      })]
    });
  }
  var DemoListItem$1 = R(function DemoListItem(_ref125) {
    var {
      index
    } = _ref125;
    return o$1(ListboxItem, {
      index: index,
      focusSelf: e => e.focus(),
      ariaPropName: "aria-selected",
      getSortValue: returnZero,
      disabled: false,
      render: info => {
        var selected = info.singleSelectionChildReturn.selected;
        // defaultRenderListboxSingleItem({ tagListItem: "li", makePropsListItem: ({ singleSelection: { selected } }) => ({ children: `List item #${index}${selected ? " (selected)" : ""}` }) })
        return o$1("li", _objectSpread(_objectSpread({}, info.props), {}, {
          children: "List item #".concat(index).concat(selected ? " (selected)" : "")
        }));
      }
    });
  });
  function Blurb$3() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/",
          children: "In accordance with the ARIA guidelines for Listbox patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["In terms of keyboard navigation and tabbing through elements, a Listbox is considered a ", o$1("strong", {
            children: "single"
          }), " tab stop; in other words, no matter how many list items there are in a Listbox, it only takes one press of the Tab button to go through it.", o$1("ul", {
            children: [o$1("li", {
              children: "When a Listbox is tabbed into, the most recently selected item is given focus"
            }), o$1("li", {
              children: "Pressing Tab again navigates out of the listbox; no other list items are tabbable other than the one currently designated."
            }), o$1("li", {
              children: "Pressing the arrow keys navigates through the Listbox one item at a time"
            }), o$1("li", {
              children: "Pressing the Home/End keys move focus to the first/last items respectively"
            }), o$1("li", {
              children: "Typing any sequence of text starts typeahead that navigates to the next item that matches what's being typed"
            }), o$1("li", {
              children: "Focus & selection management is as optimized as possible; only two children re-render at a time when focus or selection changes"
            }), o$1("li", {
              children: "These apply generally to all composite components with a variable number of children (Tab Lists, Radio Groups, Multi-Select Listboxes etc.)"
            })]
          })]
        }), o$1("li", {
          children: ["Rather than each individual list item knowing whether it is selected or not (as with multi-select lists), here the parent knows the ", o$1("code", {
            children: "selectedIndex"
          }), " and simply notifies the (max two) relevant children any time it changes."]
        }), o$1("li", {
          children: "Grouping is supported"
        }), o$1("li", {
          children: "Sorting/reordering is supported, though not provided by default, as it's mutually exclusive with grouping."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: "Listboxes do not support interactive content within them (e.g. a dropdown menu), as ARIA specifies that this is a different pattern."
        })
      })]
    });
  }
  function Code$3() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$3() {
    var [selectedIndex, setSelectedIndex] = useState(null);
    var [count, setCount] = useState(5);
    return o$1(p$1, {
      children: [o$1(Blurb$3, {}), o$1(Code$3, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of list items"]
      }), o$1("div", {
        children: o$1(Listbox, {
          selectedIndex: selectedIndex,
          setSelectedIndex: setSelectedIndex,
          render: info => {
            /*
            defaultRenderListboxSingle({
            tagLabel: "label", tagList: "ol", makePropsLabel: () => ({}), makePropsList: () => ({
                children: <>{Array.from((function* () {
                    for (let i = 0; i < count; ++i) {
                        yield <DemoListItem index={i} key={i} />
                    }
                })())}</>
            })
            })
            */
            return o$1(p$1, {
              children: [o$1("label", _objectSpread(_objectSpread({}, info.propsListboxLabel), {}, {
                children: "Single-select listbox demo"
              })), o$1("ol", _objectSpread(_objectSpread({}, info.propsListbox), {}, {
                children: Array.from(function* () {
                  for (var _i10 = 0; _i10 < count; ++_i10) {
                    yield o$1(DemoListItem$1, {
                      index: _i10
                    }, _i10);
                  }
                }())
              }))]
            });
          },
          ariaLabel: null,
          groupingType: "without-groups",
          navigationDirection: "vertical",
          selectionLimit: "single"
        })
      })]
    });
  }
  function DemoListItem(_ref126) {
    var {
      index
    } = _ref126;
    return o$1(MenuItem, {
      index: index,
      ariaPropName: null,
      getSortValue: returnZero,
      selectionMode: "disabled",
      role: "menuitem",
      onPress: e => alert("Menu item #".concat(e[EventDetail].index, " pressed")),
      disabled: false,
      render: info => o$1("li", _objectSpread(_objectSpread({}, info.props), {}, {
        children: "Menu item #".concat(index)
      }))
    });
  }
  function Blurb$2() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/",
          children: "In accordance with the ARIA guidelines for Listbox patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["The children are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        }), o$1("li", {
          children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it."
        }), o$1("li", {
          children: "When the menu is closed because another element on the page was focused instead, focus will not be modified."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: "TODO"
        })
      })]
    });
  }
  function Code$2() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$2() {
    var [count, setCount] = useState(5);
    var [open, setOpen] = useState(false);
    return o$1(p$1, {
      children: [o$1(Blurb$2, {}), o$1(Code$2, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of menu items"]
      }), o$1("div", {
        children: o$1(Menu, {
          orientation: "vertical",
          onOpen: () => setOpen(true),
          onClose: () => setOpen(false),
          open: open,
          openDirection: "down",
          render: info => {
            return o$1(p$1, {
              children: [o$1("button", _objectSpread(_objectSpread({}, info.propsTrigger), {}, {
                onClick: () => setOpen(o => !o),
                children: "Menu trigger"
              })), defaultRenderPortal({
                portalId: "portal",
                children: o$1("div", _objectSpread(_objectSpread({}, info.propsSurface), {}, {
                  hidden: !open,
                  children: o$1("ul", _objectSpread(_objectSpread({}, info.propsTarget), {}, {
                    children: Array.from(function* () {
                      for (var _i11 = 0; _i11 < count; ++_i11) {
                        yield o$1("div", {
                          children: o$1(DemoListItem, {
                            index: _i11
                          }, _i11)
                        });
                      }
                    }())
                  }))
                }))
              })]
            });
          } /*defaultRenderMenu({
              tagButton: "button",
              tagMenu: "ul",
              tagSentinel: "div",
              tagSurface: "div",
              portalId: "portal",
              makePropsButton: () => ({ children: "Open menu" + (open ? " (open)" : " (closed)") }),
              makePropsMenu: () => ({
                  children: <>{Array.from((function* () {
                      for (let i = 0; i < count; ++i) {
                          yield <div><DemoListItem index={i} key={i} /></div>
                      }
                  })())}</>
              }),
              makePropsSurface: () => ({ style: { display: !open ? "none" : undefined } }),
              makePropsSentinel: () => ({}),
            })*/
        })
      })]
    });
  }

  var DemoRadioButton = R(function DemoRadioButton(_ref127) {
    var {
      index
    } = _ref127;
    return o$1("div", {
      children: o$1(Radio, {
        index: index,
        focusSelf: e => e.focus(),
        disabled: false,
        labelPosition: "separate",
        value: index,
        tagInput: "input",
        tagLabel: "label",
        ariaLabel: null,
        selectionMode: "activation",
        render: info => {
          return o$1(p$1, {
            children: [o$1("input", _objectSpread(_objectSpread({}, info.propsInput), {}, {
              name: "radio-demo"
            })), o$1("label", _objectSpread(_objectSpread({}, info.propsLabel), {}, {
              children: ["Radio #", index]
            }))]
          });
        }
      })
    });
  });
  function Blurb$1() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/radiobutton/",
          children: "In accordance with the ARIA guidelines for Radio Button patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["The children are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        }), o$1("li", {
          children: "The input & label support the same text-selection affordances as Checkboxes (labels can be selected, but double-clicking doesn't select the text and selecting text doesn't count as an input)"
        }), o$1("li", {
          children: "Selection state is handled by the parent; instead of specifying whether any given radio button is checked or not, the parent notifies each child of the necessary changes."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", {
            children: "render"
          }), " prop and setting ", o$1("code", {
            children: "labelPosition"
          }), " to be \"separate\"), you must pass ", o$1("code", {
            children: "aria-label"
          }), " as a prop to the checkbox manually. Not providing one will print an error to the console, but it it not required by the type system."]
        }), o$1("li", {
          children: ["The above also applies to the radio group as a whole; ARIA requires that all Radio Buttons be contained within an element with a specific role which is labelled either by an element (handled for you) or ", o$1("code", {
            children: "aria-label"
          }), " (specified by you manually on the input)."]
        })]
      })]
    });
  }
  function Code$1() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo$1() {
    var [selectedIndex, setSelectedIndex] = useState(null);
    var [count, setCount] = useState(5);
    return o$1(p$1, {
      children: [o$1(Blurb$1, {}), o$1(Code$1, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of radio buttons"]
      }), o$1("div", {
        children: o$1(RadioGroup, {
          name: "radio-demo",
          ariaLabel: null,
          selectedValue: selectedIndex,
          navigationDirection: "vertical",
          setSelectedValue: setSelectedIndex,
          render: info => {
            return o$1(p$1, {
              children: [o$1("label", _objectSpread(_objectSpread({}, info.propsRadioGroupLabel), {}, {
                children: "Radio group demo"
              })), o$1("div", _objectSpread(_objectSpread({}, info.propsRadioGroup), {}, {
                children: Array.from(function* () {
                  for (var _i12 = 0; _i12 < count; ++_i12) {
                    yield o$1(DemoRadioButton, {
                      index: _i12
                    }, _i12);
                  }
                }())
              }))]
            });
          }
        })
      })]
    });
  }
  function DemoSliderThumb(_ref128) {
    var {
      index
    } = _ref128;
    var [value, setValue] = useState(0);
    return o$1(SliderThumb, {
      index: index,
      tag: "input",
      label: "Slider thumb #".concat(index),
      value: value,
      onValueChange: e => setValue(e[EventDetail].value),
      min: 0,
      max: 10,
      render: info => {
        return o$1("input", _objectSpread({}, info.propsSliderThumb));
      }
    });
  }
  function Blurb() {
    return o$1(p$1, {
      children: [o$1("p", {
        children: [o$1("a", {
          href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/",
          children: "In accordance with the ARIA guidelines for Listbox patterns,"
        }), " this widget supports the following:"]
      }), o$1("ul", {
        children: [o$1("li", {
          children: ["The children are treated as a composite component with list navigation; see ", o$1("code", {
            children: "AiraSingleSelectList"
          }), " for more information"]
        }), o$1("li", {
          children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it."
        }), o$1("li", {
          children: "When the menu is closed because another element on the page was focused instead, focus will not be modified."
        })]
      }), o$1("p", {
        children: o$1("strong", {
          children: ["Things ", o$1("em", {
            children: "not"
          }), " handled:"]
        })
      }), o$1("ul", {
        children: o$1("li", {
          children: "TODO"
        })
      })]
    });
  }
  function Code() {
    return o$1("code", {
      children: ""
    });
  }
  function Demo() {
    var [count, setCount] = useState(5);
    return o$1(p$1, {
      children: [o$1(Blurb, {}), o$1(Code, {}), o$1("label", {
        children: [o$1("input", {
          type: "number",
          min: 0,
          value: count,
          onInput: e => setCount(e.currentTarget.valueAsNumber)
        }), " # of slider thumbs"]
      }), o$1("div", {
        children: o$1(Slider, {
          min: 0,
          max: 10,
          children: o$1(p$1, {
            children: Array.from(function* () {
              for (var _i13 = 0; _i13 < count; ++_i13) {
                yield o$1("div", {
                  children: o$1(DemoSliderThumb, {
                    index: _i13
                  }, _i13)
                });
              }
            }())
          })
        })
      })]
    });
  }

  //import { options } from "preact";
  //options.debounceRendering = queueMicrotask;
  //const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
  var Component = () => {
    return o$1(Heading, {
      heading: "Demos",
      children: [o$1(Heading, {
        heading: "Single-select Listbox",
        children: o$1(Demo$3, {})
      }), o$1(Heading, {
        heading: "Slider",
        children: o$1(Demo, {})
      }), o$1(Heading, {
        heading: "Accordion",
        children: o$1(Demo$8, {})
      }), o$1(Heading, {
        heading: "Button",
        children: o$1(Demo$7, {})
      }), o$1(Heading, {
        heading: "Checkbox",
        children: o$1(Demo$6, {})
      }), o$1(Heading, {
        heading: "Checkbox Group",
        children: o$1(Demo$5, {})
      }), o$1(Heading, {
        heading: "Multi-select Listbox",
        children: o$1(Demo$4, {})
      }), o$1(Heading, {
        heading: "Menu",
        children: o$1(Demo$2, {})
      }), o$1(Heading, {
        heading: "Radio",
        children: o$1(Demo$1, {})
      })]
    });
  };
  requestAnimationFrame(() => {
    P$1(o$1(Component, {}), document.getElementById("root"));
  });
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2RpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9yZW5kZXIuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NhdGNoLWVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9qc3gtcnVudGltZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL1B1cmVDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvbWVtby5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9mb3J3YXJkUmVmLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL0NoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLWxpc3QuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcG9ydGFscy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9yZW5kZXIuanMiLCIuLi9zcmMvcHJvcHMudHMiLCIuLi9zcmMvY29tcG9uZW50L2hlYWRpbmcudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9vYnNlcnZlcnMvdXNlLWFjdGl2ZS1lbGVtZW50LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtYmVmb3JlLWxheW91dC1lZmZlY3QudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtZ2V0dGVyLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtY2hpbGQtbWFuYWdlci50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1jaGlsZHJlbi50c3giLCIuLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtbWVyZ2VkLWNsYXNzZXMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtcmVmcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1zdHlsZXMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHMudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1ldmVudC1oYW5kbGVyLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC1kZXRhaWwvdXNlLWRpc21pc3MudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3RhYmJhYmxlL3NyYy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy93aWNnLWluZXJ0L2Rpc3QvaW5lcnQuanMiLCIuLi9ub2RlX21vZHVsZXMvYmxvY2tpbmctZWxlbWVudHMvc3JjL2Jsb2NraW5nLWVsZW1lbnRzLnRzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS1kb2N1bWVudC1jbGFzcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvZG9tLWhlbHBlcnMvdXNlLWJsb2NraW5nLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC1kZXRhaWwvdXNlLWZvY3VzLXRyYXAudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2RvbS1oZWxwZXJzL3VzZS10ZXh0LWNvbnRlbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvY29tcG9uZW50LWRldGFpbC91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvY29tcG9uZW50LWRldGFpbC91c2Utcm92aW5nLXRhYmluZGV4LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9jb21wb25lbnQtZGV0YWlsL3VzZS1saXN0LW5hdmlnYXRpb24tcGFydGlhbC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvY29tcG9uZW50LWRldGFpbC91c2UtZ3JpZC1uYXZpZ2F0aW9uLXBhcnRpYWwudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC1kZXRhaWwvdXNlLXNpbmdsZS1zZWxlY3Rpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC1kZXRhaWwvdXNlLWdyaWQtbmF2aWdhdGlvbi1zaW5nbGUtc2VsZWN0aW9uLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSYW5kb20uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaHVmZmxlU2VsZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5U2h1ZmZsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVZhbHVlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3NodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWZvcmNlLXVwZGF0ZS50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvY29tcG9uZW50LWRldGFpbC91c2Utc29ydGFibGUtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC1kZXRhaWwvdXNlLWdyaWQtbmF2aWdhdGlvbi1zaW5nbGUtc2VsZWN0aW9uLXNvcnRhYmxlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9jb21wb25lbnQtZGV0YWlsL3VzZS1saXN0LW5hdmlnYXRpb24tc2luZ2xlLXNlbGVjdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvb2JzZXJ2ZXJzL3VzZS1jaGlsZHJlbi1oYXZlLWZvY3VzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9vYnNlcnZlcnMvdXNlLWhhcy1jdXJyZW50LWZvY3VzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9jb21wb25lbnQtdXNlL3VzZS1wcmVzcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvY29tcG9uZW50LXVzZS91c2UtZ3JpZC1uYXZpZ2F0aW9uLWNvbXBsZXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9jb21wb25lbnQtdXNlL3VzZS1saXN0LW5hdmlnYXRpb24tY29tcGxldGUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC11c2UvdXNlLW1vZGFsLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy9jb21wb25lbnQtdXNlL3VzZS1yYW5kb20taWQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL2NvbXBvbmVudC11c2UvdXNlLXJhbmRvbS1kdWFsLWlkcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdGltaW5nL3VzZS1hbmltYXRpb24tZnJhbWUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3RpbWluZy91c2UtdGltZW91dC50c3giLCIuLi9zcmMvdXNlLWJ1dHRvbi50cyIsIi4uL3NyYy91c2UtYWNjb3JkaW9uLnRzeCIsIi4uL3NyYy91c2UtbGFiZWwudHMiLCIuLi9zcmMvdXNlLWNoZWNrYm94LnRzIiwiLi4vc3JjL3VzZS1jaGVja2JveC1ncm91cC50cyIsIi4uL3NyYy91c2UtZGlhbG9nLnRzIiwiLi4vc3JjL3VzZS1kcmF3ZXIudHMiLCIuLi9zcmMvdXNlLWdyaWRsaXN0LnRzIiwiLi4vc3JjL3VzZS1tZW51LXN1cmZhY2UudHMiLCIuLi9zcmMvdXNlLXRvb2xiYXIudHN4IiwiLi4vc3JjL3VzZS1tZW51YmFyLnRzIiwiLi4vc3JjL3VzZS1tZW51LnRzIiwiLi4vc3JjL3VzZS1yYWRpby1ncm91cC50c3giLCIuLi9zcmMvdXNlLXNsaWRlci50c3giLCIuLi9zcmMvdXNlLXRhYmxlLnRzIiwiLi4vc3JjL3VzZS10b2FzdHMudHN4IiwiLi4vc3JjL3VzZS10b29sdGlwLnRzIiwiLi4vc3JjL2NvbXBvbmVudC91dGlsLnRzIiwiLi4vc3JjL2NvbXBvbmVudC9hY2NvcmRpb24udHN4IiwiLi4vc3JjL2NvbXBvbmVudC9idXR0b24udHN4IiwiLi4vc3JjL2NvbXBvbmVudC9jaGVja2JveC50c3giLCIuLi9zcmMvY29tcG9uZW50L2NoZWNrYm94LWdyb3VwLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvZGlhbG9nLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvZHJhd2VyLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvZ3JpZGxpc3QudHN4IiwiLi4vc3JjL3VzZS1saXN0Ym94LnRzIiwiLi4vc3JjL2NvbXBvbmVudC9saXN0Ym94LnRzeCIsIi4uL3NyYy9jb21wb25lbnQvbWVudWJhci50c3giLCIuLi9zcmMvY29tcG9uZW50L21lbnUudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9yYWRpby1ncm91cC50c3giLCIuLi9zcmMvY29tcG9uZW50L3NsaWRlci50c3giLCIuLi9zcmMvY29tcG9uZW50L3RhYmxlLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvdGFicy50c3giLCIuLi9zcmMvY29tcG9uZW50L3RvYXN0cy50c3giLCIuLi9zcmMvY29tcG9uZW50L3Rvb2xiYXIudHN4IiwiLi4vc3JjL2NvbXBvbmVudC90b29sdGlwLnRzeCIsImRlbW9zL2FjY29yZGlvbi50c3giLCJkZW1vcy9idXR0b24udHN4IiwiZGVtb3MvY2hlY2tib3gudHN4IiwiZGVtb3MvY2hlY2tib3gtZ3JvdXAudHN4IiwiZGVtb3MvbGlzdGJveC1tdWx0aS50c3giLCJkZW1vcy9saXN0Ym94LXNpbmdsZS50c3giLCJkZW1vcy9tZW51LnRzeCIsImRlbW9zL3JhZGlvLnRzeCIsImRlbW9zL3NsaWRlci50c3giLCJpbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRU1QVFlfQVJSIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Ly8gQHRzLWlnbm9yZSBXZSBjaGFuZ2UgdGhlIHR5cGUgb2YgYG9iamAgdG8gYmUgYE8gJiBQYFxuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSBpdHMgcGFyZW50IGlmIGF0dGFjaGVkLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3JcbiAqIElFMTEgd2hpY2ggZG9lc24ndCBzdXBwb3J0IGBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUoKWAuIFVzaW5nIHRoaXMgZnVuY3Rpb25cbiAqIGlzIHNtYWxsZXIgdGhhbiBpbmNsdWRpbmcgYSBkZWRpY2F0ZWQgcG9seWZpbGwuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSBFTVBUWV9BUlIuc2xpY2U7XG4iLCJpbXBvcnQgeyBfY2F0Y2hFcnJvciB9IGZyb20gJy4vZGlmZi9jYXRjaC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBvcHRpb25gIG9iamVjdCBjYW4gcG90ZW50aWFsbHkgY29udGFpbiBjYWxsYmFjayBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIGNhbGxlZCBkdXJpbmcgdmFyaW91cyBzdGFnZXMgb2Ygb3VyIHJlbmRlcmVyLiBUaGlzIGlzIHRoZVxuICogZm91bmRhdGlvbiBvbiB3aGljaCBhbGwgb3VyIGFkZG9ucyBsaWtlIGBwcmVhY3QvZGVidWdgLCBgcHJlYWN0L2NvbXBhdGAsXG4gKiBhbmQgYHByZWFjdC9ob29rc2AgYXJlIGJhc2VkIG9uLiBTZWUgdGhlIGBPcHRpb25zYCB0eXBlIGluIGBpbnRlcm5hbC5kLnRzYFxuICogZm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb24gaG9va3MgKG1vc3QgZWRpdG9ycy9JREVzIGFsbG93IHlvdSB0b1xuICogY3RybCtjbGljayBvciBjbWQrY2xpY2sgb24gbWFjIHRoZSB0eXBlIGRlZmluaXRpb24gYmVsb3cpLlxuICogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk9wdGlvbnN9XG4gKi9cbmNvbnN0IG9wdGlvbnMgPSB7XG5cdF9jYXRjaEVycm9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBvcHRpb25zO1xuIiwiaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcblxubGV0IHZub2RlSWQgPSAwO1xuXG4vKipcbiAqIENyZWF0ZSBhbiB2aXJ0dWFsIG5vZGUgKHVzZWQgZm9yIEpTWClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBjb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Byb3BzXSBUaGUgcHJvcGVydGllcyBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLicpLkNvbXBvbmVudENoaWxkcmVuPn0gW2NoaWxkcmVuXSBUaGUgY2hpbGRyZW4gb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHt9LFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0aTtcblx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgPT0gJ2tleScpIGtleSA9IHByb3BzW2ldO1xuXHRcdGVsc2UgaWYgKGkgPT0gJ3JlZicpIHJlZiA9IHByb3BzW2ldO1xuXHRcdGVsc2Ugbm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdH1cblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcblx0XHRub3JtYWxpemVkUHJvcHMuY2hpbGRyZW4gPVxuXHRcdFx0YXJndW1lbnRzLmxlbmd0aCA+IDMgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBjaGlsZHJlbjtcblx0fVxuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wc1xuXHQvLyBOb3RlOiB0eXBlIG1heSBiZSB1bmRlZmluZWQgaW4gZGV2ZWxvcG1lbnQsIG11c3QgbmV2ZXIgZXJyb3IgaGVyZS5cblx0aWYgKHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgJiYgdHlwZS5kZWZhdWx0UHJvcHMgIT0gbnVsbCkge1xuXHRcdGZvciAoaSBpbiB0eXBlLmRlZmF1bHRQcm9wcykge1xuXHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHR5cGUuZGVmYXVsdFByb3BzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBub3JtYWxpemVkUHJvcHMsIGtleSwgcmVmLCBudWxsKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBWTm9kZSAodXNlZCBpbnRlcm5hbGx5IGJ5IFByZWFjdClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBDb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgb2YgdGhpcyB2aXJ0dWFsIG5vZGUuXG4gKiBJZiB0aGlzIHZpcnR1YWwgbm9kZSByZXByZXNlbnRzIGEgdGV4dCBub2RlLCB0aGlzIGlzIHRoZSB0ZXh0IG9mIHRoZSBub2RlIChzdHJpbmcgb3IgbnVtYmVyKS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0ga2V5IFRoZSBrZXkgZm9yIHRoaXMgdmlydHVhbCBub2RlLCB1c2VkIHdoZW5cbiAqIGRpZmZpbmcgaXQgYWdhaW5zdCBpdHMgY2hpbGRyZW5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJyZWZcIl19IHJlZiBUaGUgcmVmIHByb3BlcnR5IHRoYXQgd2lsbFxuICogcmVjZWl2ZSBhIHJlZmVyZW5jZSB0byBpdHMgY3JlYXRlZCBjaGlsZFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgcmVmLCBvcmlnaW5hbCkge1xuXHQvLyBWOCBzZWVtcyB0byBiZSBiZXR0ZXIgYXQgZGV0ZWN0aW5nIHR5cGUgc2hhcGVzIGlmIHRoZSBvYmplY3QgaXMgYWxsb2NhdGVkIGZyb20gdGhlIHNhbWUgY2FsbCBzaXRlXG5cdC8vIERvIG5vdCBpbmxpbmUgaW50byBjcmVhdGVFbGVtZW50IGFuZCBjb2VyY2VUb1ZOb2RlIVxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0Ly8gX25leHREb20gbXVzdCBiZSBpbml0aWFsaXplZCB0byB1bmRlZmluZWQgYi9jIGl0IHdpbGwgZXZlbnR1YWxseVxuXHRcdC8vIGJlIHNldCB0byBkb20ubmV4dFNpYmxpbmcgd2hpY2ggY2FuIHJldHVybiBgbnVsbGAgYW5kIGl0IGlzIGltcG9ydGFudFxuXHRcdC8vIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbiB1bmluaXRpYWxpemVkIF9uZXh0RG9tIGFuZFxuXHRcdC8vIGEgX25leHREb20gdGhhdCBoYXMgYmVlbiBzZXQgdG8gYG51bGxgXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdF9oeWRyYXRpbmc6IG51bGwsXG5cdFx0Y29uc3RydWN0b3I6IHVuZGVmaW5lZCxcblx0XHRfb3JpZ2luYWw6IG9yaWdpbmFsID09IG51bGwgPyArK3Zub2RlSWQgOiBvcmlnaW5hbFxuXHR9O1xuXG5cdC8vIE9ubHkgaW52b2tlIHRoZSB2bm9kZSBob29rIGlmIHRoaXMgd2FzICpub3QqIGEgZGlyZWN0IGNvcHk6XG5cdGlmIChvcmlnaW5hbCA9PSBudWxsICYmIG9wdGlvbnMudm5vZGUgIT0gbnVsbCkgb3B0aW9ucy52bm9kZSh2bm9kZSk7XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuXHRyZXR1cm4geyBjdXJyZW50OiBudWxsIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBGcmFnbWVudChwcm9wcykge1xuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCBQcmVhY3QgVk5vZGUuXG4gKiBAcGFyYW0geyp9IHZub2RlXG4gKiBAcmV0dXJucyB7dm5vZGUgaXMgaW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCBpc1ZhbGlkRWxlbWVudCA9IHZub2RlID0+XG5cdHZub2RlICE9IG51bGwgJiYgdm5vZGUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZDtcbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBkaWZmLCBjb21taXRSb290IH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEJhc2UgQ29tcG9uZW50IGNsYXNzLiBQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2hcbiAqIHRyaWdnZXIgcmVuZGVyaW5nXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGluaXRpYWwgY29tcG9uZW50IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBUaGUgaW5pdGlhbCBjb250ZXh0IGZyb20gcGFyZW50IGNvbXBvbmVudHMnXG4gKiBnZXRDaGlsZENvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuXHR0aGlzLnByb3BzID0gcHJvcHM7XG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbi8qKlxuICogVXBkYXRlIGNvbXBvbmVudCBzdGF0ZSBhbmQgc2NoZWR1bGUgYSByZS1yZW5kZXIuXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCAoKHM6IG9iamVjdCwgcDogb2JqZWN0KSA9PiBvYmplY3QpfSB1cGRhdGUgQSBoYXNoIG9mIHN0YXRlXG4gKiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIHRoZSBjdXJyZW50XG4gKiBzdGF0ZSBhbmQgcHJvcHMgcmV0dXJucyBhIG5ldyBwYXJ0aWFsIHN0YXRlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXNcbiAqIHVwZGF0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0Ly8gb25seSBjbG9uZSBzdGF0ZSB3aGVuIGNvcHlpbmcgdG8gbmV4dFN0YXRlIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgcztcblx0aWYgKHRoaXMuX25leHRTdGF0ZSAhPSBudWxsICYmIHRoaXMuX25leHRTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGU7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVwZGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gU29tZSBsaWJyYXJpZXMgbGlrZSBgaW1tZXJgIG1hcmsgdGhlIGN1cnJlbnQgc3RhdGUgYXMgcmVhZG9ubHksXG5cdFx0Ly8gcHJldmVudGluZyB1cyBmcm9tIG11dGF0aW5nIGl0LCBzbyB3ZSBuZWVkIHRvIGNsb25lIGl0LiBTZWUgIzI3MTZcblx0XHR1cGRhdGUgPSB1cGRhdGUoYXNzaWduKHt9LCBzKSwgdGhpcy5wcm9wcyk7XG5cdH1cblxuXHRpZiAodXBkYXRlKSB7XG5cdFx0YXNzaWduKHMsIHVwZGF0ZSk7XG5cdH1cblxuXHQvLyBTa2lwIHVwZGF0ZSBpZiB1cGRhdGVyIGZ1bmN0aW9uIHJldHVybmVkIG51bGxcblx0aWYgKHVwZGF0ZSA9PSBudWxsKSByZXR1cm47XG5cblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLl9zdGF0ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBJbW1lZGlhdGVseSBwZXJmb3JtIGEgc3luY2hyb25vdXMgcmUtcmVuZGVyIG9mIHRoZSBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzXG4gKiByZS1yZW5kZXJlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSB2bm9kZS5fb3JpZ2luYWwgKyAxO1xuXG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdHZub2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRjb21wb25lbnQuX2dsb2JhbENvbnRleHQsXG5cdFx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nICE9IG51bGwgPyBbb2xkRG9tXSA6IG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb20sXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nXG5cdFx0KTtcblx0XHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG5cblx0XHRpZiAodm5vZGUuX2RvbSAhPSBvbGREb20pIHtcblx0XHRcdHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSkge1xuXHRpZiAoKHZub2RlID0gdm5vZGUuX3BhcmVudCkgIT0gbnVsbCAmJiB2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gbnVsbDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBjaGlsZC5fZG9tO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHJlbmRlciBxdWV1ZVxuICogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59XG4gKi9cbmxldCByZXJlbmRlclF1ZXVlID0gW107XG5cbi8qXG4gKiBUaGUgdmFsdWUgb2YgYENvbXBvbmVudC5kZWJvdW5jZWAgbXVzdCBhc3luY2hyb25vdXNseSBpbnZva2UgdGhlIHBhc3NlZCBpbiBjYWxsYmFjay4gSXQgaXNcbiAqIGltcG9ydGFudCB0aGF0IGNvbnRyaWJ1dG9ycyB0byBQcmVhY3QgY2FuIGNvbnNpc3RlbnRseSByZWFzb24gYWJvdXQgd2hhdCBjYWxscyB0byBgc2V0U3RhdGVgLCBldGMuXG4gKiBkbywgYW5kIHdoZW4gdGhlaXIgZWZmZWN0cyB3aWxsIGJlIGFwcGxpZWQuIFNlZSB0aGUgbGlua3MgYmVsb3cgZm9yIHNvbWUgZnVydGhlciByZWFkaW5nIG9uIGRlc2lnbmluZ1xuICogYXN5bmNocm9ub3VzIEFQSXMuXG4gKiAqIFtEZXNpZ25pbmcgQVBJcyBmb3IgQXN5bmNocm9ueV0oaHR0cHM6Ly9ibG9nLml6cy5tZS8yMDEzLzA4L2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICogKiBbQ2FsbGJhY2tzIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXNdKGh0dHBzOi8vYmxvZy5vbWV0ZXIuY29tLzIwMTEvMDcvMjQvY2FsbGJhY2tzLXN5bmNocm9ub3VzLWFuZC1hc3luY2hyb25vdXMvKVxuICovXG5cbmxldCBwcmV2RGVib3VuY2U7XG5cbi8qKlxuICogRW5xdWV1ZSBhIHJlcmVuZGVyIG9mIGEgY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gYyBUaGUgY29tcG9uZW50IHRvIHJlcmVuZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyKGMpIHtcblx0aWYgKFxuXHRcdCghYy5fZGlydHkgJiZcblx0XHRcdChjLl9kaXJ0eSA9IHRydWUpICYmXG5cdFx0XHRyZXJlbmRlclF1ZXVlLnB1c2goYykgJiZcblx0XHRcdCFwcm9jZXNzLl9yZXJlbmRlckNvdW50KyspIHx8XG5cdFx0cHJldkRlYm91bmNlICE9PSBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nXG5cdCkge1xuXHRcdHByZXZEZWJvdW5jZSA9IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmc7XG5cdFx0KHByZXZEZWJvdW5jZSB8fCBzZXRUaW1lb3V0KShwcm9jZXNzKTtcblx0fVxufVxuXG4vKiogRmx1c2ggdGhlIHJlbmRlciBxdWV1ZSBieSByZXJlbmRlcmluZyBhbGwgcXVldWVkIGNvbXBvbmVudHMgKi9cbmZ1bmN0aW9uIHByb2Nlc3MoKSB7XG5cdGxldCBxdWV1ZTtcblx0d2hpbGUgKChwcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gcmVyZW5kZXJRdWV1ZS5sZW5ndGgpKSB7XG5cdFx0cXVldWUgPSByZXJlbmRlclF1ZXVlLnNvcnQoKGEsIGIpID0+IGEuX3Zub2RlLl9kZXB0aCAtIGIuX3Zub2RlLl9kZXB0aCk7XG5cdFx0cmVyZW5kZXJRdWV1ZSA9IFtdO1xuXHRcdC8vIERvbid0IHVwZGF0ZSBgcmVuZGVyQ291bnRgIHlldC4gS2VlcCBpdHMgdmFsdWUgbm9uLXplcm8gdG8gcHJldmVudCB1bm5lY2Vzc2FyeVxuXHRcdC8vIHByb2Nlc3MoKSBjYWxscyBmcm9tIGdldHRpbmcgc2NoZWR1bGVkIHdoaWxlIGBxdWV1ZWAgaXMgc3RpbGwgYmVpbmcgY29uc3VtZWQuXG5cdFx0cXVldWUuc29tZShjID0+IHtcblx0XHRcdGlmIChjLl9kaXJ0eSkgcmVuZGVyQ29tcG9uZW50KGMpO1xuXHRcdH0pO1xuXHR9XG59XG5cbnByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSAwO1xuIiwiaW1wb3J0IHsgZW5xdWV1ZVJlbmRlciB9IGZyb20gJy4vY29tcG9uZW50JztcblxuZXhwb3J0IGxldCBpID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjb250ZXh0SWQpIHtcblx0Y29udGV4dElkID0gJ19fY0MnICsgaSsrO1xuXG5cdGNvbnN0IGNvbnRleHQgPSB7XG5cdFx0X2lkOiBjb250ZXh0SWQsXG5cdFx0X2RlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0Q29uc3VtZXIocHJvcHMsIGNvbnRleHRWYWx1ZSkge1xuXHRcdFx0Ly8gcmV0dXJuIHByb3BzLmNoaWxkcmVuKFxuXHRcdFx0Ly8gXHRjb250ZXh0W2NvbnRleHRJZF0gPyBjb250ZXh0W2NvbnRleHRJZF0ucHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWVcblx0XHRcdC8vICk7XG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW4oY29udGV4dFZhbHVlKTtcblx0XHR9LFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0UHJvdmlkZXIocHJvcHMpIHtcblx0XHRcdGlmICghdGhpcy5nZXRDaGlsZENvbnRleHQpIHtcblx0XHRcdFx0bGV0IHN1YnMgPSBbXTtcblx0XHRcdFx0bGV0IGN0eCA9IHt9O1xuXHRcdFx0XHRjdHhbY29udGV4dElkXSA9IHRoaXM7XG5cblx0XHRcdFx0dGhpcy5nZXRDaGlsZENvbnRleHQgPSAoKSA9PiBjdHg7XG5cblx0XHRcdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihfcHJvcHMpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gX3Byb3BzLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHQvLyBJIHRoaW5rIHRoZSBmb3JjZWQgdmFsdWUgcHJvcGFnYXRpb24gaGVyZSB3YXMgb25seSBuZWVkZWQgd2hlbiBgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZ2Agd2FzIGJlaW5nIGJ5cGFzc2VkOlxuXHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9jb21taXQvNGQzMzlmYjgwM2JlYTA5ZTlmMTk4YWJmMzhjYTFiZjhlYTRiNzc3MSNkaWZmLTU0NjgyY2UzODA5MzVhNzE3ZTQxYjhiZmM1NDczN2Y2UjM1OFxuXHRcdFx0XHRcdFx0Ly8gSW4gdGhvc2UgY2FzZXMgdGhvdWdoLCBldmVuIHdpdGggdGhlIHZhbHVlIGNvcnJlY3RlZCwgd2UncmUgZG91YmxlLXJlbmRlcmluZyBhbGwgbm9kZXMuXG5cdFx0XHRcdFx0XHQvLyBJdCBtaWdodCBiZSBiZXR0ZXIgdG8ganVzdCB0ZWxsIGZvbGtzIG5vdCB0byB1c2UgZm9yY2Utc3luYyBtb2RlLlxuXHRcdFx0XHRcdFx0Ly8gQ3VycmVudGx5LCB1c2luZyBgdXNlQ29udGV4dCgpYCBpbiBhIGNsYXNzIGNvbXBvbmVudCB3aWxsIG92ZXJ3cml0ZSBpdHMgYHRoaXMuY29udGV4dGAgdmFsdWUuXG5cdFx0XHRcdFx0XHQvLyBzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHQvLyBcdGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXG5cdFx0XHRcdFx0XHQvLyBzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHQvLyBcdGMuY29udGV4dFtjb250ZXh0SWRdID0gX3Byb3BzLnZhbHVlO1xuXHRcdFx0XHRcdFx0Ly8gXHRlbnF1ZXVlUmVuZGVyKGMpO1xuXHRcdFx0XHRcdFx0Ly8gfSk7XG5cdFx0XHRcdFx0XHRzdWJzLnNvbWUoZW5xdWV1ZVJlbmRlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMuc3ViID0gYyA9PiB7XG5cdFx0XHRcdFx0c3Vicy5wdXNoKGMpO1xuXHRcdFx0XHRcdGxldCBvbGQgPSBjLmNvbXBvbmVudFdpbGxVbm1vdW50O1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVubW91bnQgPSAoKSA9PiB7XG5cdFx0XHRcdFx0XHRzdWJzLnNwbGljZShzdWJzLmluZGV4T2YoYyksIDEpO1xuXHRcdFx0XHRcdFx0aWYgKG9sZCkgb2xkLmNhbGwoYyk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuXHRcdH1cblx0fTtcblxuXHQvLyBEZXZ0b29scyBuZWVkcyBhY2Nlc3MgdG8gdGhlIGNvbnRleHQgb2JqZWN0IHdoZW4gaXRcblx0Ly8gZW5jb3VudGVycyBhIFByb3ZpZGVyLiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBzdXBwb3J0XG5cdC8vIHNldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiB0aGUgY29udGV4dCBvYmplY3QgaW5zdGVhZFxuXHQvLyBvZiBvbiB0aGUgY29tcG9uZW50IGl0c2VsZi4gU2VlOlxuXHQvLyBodHRwczovL3JlYWN0anMub3JnL2RvY3MvY29udGV4dC5odG1sI2NvbnRleHRkaXNwbGF5bmFtZVxuXG5cdHJldHVybiAoY29udGV4dC5Qcm92aWRlci5fY29udGV4dFJlZiA9IGNvbnRleHQuQ29uc3VtZXIuY29udGV4dFR5cGUgPSBjb250ZXh0KTtcbn1cbiIsImV4cG9ydCBjb25zdCBFTVBUWV9PQkogPSB7fTtcbmV4cG9ydCBjb25zdCBFTVBUWV9BUlIgPSBbXTtcbmV4cG9ydCBjb25zdCBJU19OT05fRElNRU5TSU9OQUwgPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO1xuIiwiaW1wb3J0IHsgZGlmZiwgdW5tb3VudCwgYXBwbHlSZWYgfSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZVZOb2RlLCBGcmFnbWVudCB9IGZyb20gJy4uL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCB7IEVNUFRZX09CSiwgRU1QVFlfQVJSIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuXG4vKipcbiAqIERpZmYgdGhlIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHdob3NlXG4gKiBjaGlsZHJlbiBhcmUgYmVpbmcgZGlmZmVkXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZHJlbltdfSByZW5kZXJSZXN1bHRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdQYXJlbnRWTm9kZSBUaGUgbmV3IHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBvbGRQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFBhcmVudFZOb2RlIFRoZSBvbGQgdmlydHVhbFxuICogbm9kZSB3aG9zZSBjaGlsZHJlbiBzaG91bGQgYmUgZGlmZidlZCBhZ2FpbnN0IG5ld1BhcmVudFZOb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdCAtIG1vZGlmaWVkIGJ5IGdldENoaWxkQ29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQ2hpbGRyZW4oXG5cdHBhcmVudERvbSxcblx0cmVuZGVyUmVzdWx0LFxuXHRuZXdQYXJlbnRWTm9kZSxcblx0b2xkUGFyZW50Vk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdG9sZERvbSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgaSwgaiwgb2xkVk5vZGUsIGNoaWxkVk5vZGUsIG5ld0RvbSwgZmlyc3RDaGlsZERvbSwgcmVmcztcblxuXHQvLyBUaGlzIGlzIGEgY29tcHJlc3Npb24gb2Ygb2xkUGFyZW50Vk5vZGUhPW51bGwgJiYgb2xkUGFyZW50Vk5vZGUgIT0gRU1QVFlfT0JKICYmIG9sZFBhcmVudFZOb2RlLl9jaGlsZHJlbiB8fCBFTVBUWV9BUlJcblx0Ly8gYXMgRU1QVFlfT0JKLl9jaGlsZHJlbiBzaG91bGQgYmUgYHVuZGVmaW5lZGAuXG5cdGxldCBvbGRDaGlsZHJlbiA9IChvbGRQYXJlbnRWTm9kZSAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4pIHx8IEVNUFRZX0FSUjtcblxuXHRsZXQgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cblx0bmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdGZvciAoaSA9IDA7IGkgPCByZW5kZXJSZXN1bHQubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZFZOb2RlID0gcmVuZGVyUmVzdWx0W2ldO1xuXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGRWTm9kZSA9PSAnYm9vbGVhbicpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdH1cblx0XHQvLyBJZiB0aGlzIG5ld1ZOb2RlIGlzIGJlaW5nIHJldXNlZCAoZS5nLiA8ZGl2PntyZXVzZX17cmV1c2V9PC9kaXY+KSBpbiB0aGUgc2FtZSBkaWZmLFxuXHRcdC8vIG9yIHdlIGFyZSByZW5kZXJpbmcgYSBjb21wb25lbnQgKGUuZy4gc2V0U3RhdGUpIGNvcHkgdGhlIG9sZFZOb2RlcyBzbyBpdCBjYW4gaGF2ZVxuXHRcdC8vIGl0J3Mgb3duIERPTSAmIGV0Yy4gcG9pbnRlcnNcblx0XHRlbHNlIGlmIChcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdzdHJpbmcnIHx8XG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnbnVtYmVyJyB8fFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLXR5cGVvZlxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2JpZ2ludCdcblx0XHQpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZVxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRWTm9kZSkpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0RnJhZ21lbnQsXG5cdFx0XHRcdHsgY2hpbGRyZW46IGNoaWxkVk5vZGUgfSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKGNoaWxkVk5vZGUuX2RlcHRoID4gMCkge1xuXHRcdFx0Ly8gVk5vZGUgaXMgYWxyZWFkeSBpbiB1c2UsIGNsb25lIGl0LiBUaGlzIGNhbiBoYXBwZW4gaW4gdGhlIGZvbGxvd2luZ1xuXHRcdFx0Ly8gc2NlbmFyaW86XG5cdFx0XHQvLyAgIGNvbnN0IHJldXNlID0gPGRpdiAvPlxuXHRcdFx0Ly8gICA8ZGl2PntyZXVzZX08c3BhbiAvPntyZXVzZX08L2Rpdj5cblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlLFxuXHRcdFx0XHRjaGlsZFZOb2RlLnByb3BzLFxuXHRcdFx0XHRjaGlsZFZOb2RlLmtleSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5yZWYgPyBjaGlsZFZOb2RlLnJlZiA6IG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY2hpbGRWTm9kZTtcblx0XHR9XG5cblx0XHQvLyBUZXJzZXIgcmVtb3ZlcyB0aGUgYGNvbnRpbnVlYCBoZXJlIGFuZCB3cmFwcyB0aGUgbG9vcCBib2R5XG5cdFx0Ly8gaW4gYSBgaWYgKGNoaWxkVk5vZGUpIHsgLi4uIH0gY29uZGl0aW9uXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y2hpbGRWTm9kZS5fcGFyZW50ID0gbmV3UGFyZW50Vk5vZGU7XG5cdFx0Y2hpbGRWTm9kZS5fZGVwdGggPSBuZXdQYXJlbnRWTm9kZS5fZGVwdGggKyAxO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgZmluZCBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBvbGRDaGlsZHJlbi5cblx0XHQvLyBJZiBmb3VuZCwgZGVsZXRlIHRoZSBhcnJheSBpdGVtIGJ5IHNldHRpbmcgdG8gYHVuZGVmaW5lZGAuXG5cdFx0Ly8gV2UgdXNlIGB1bmRlZmluZWRgLCBhcyBgbnVsbGAgaXMgcmVzZXJ2ZWQgZm9yIGVtcHR5IHBsYWNlaG9sZGVyc1xuXHRcdC8vIChob2xlcykuXG5cdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcblxuXHRcdGlmIChcblx0XHRcdG9sZFZOb2RlID09PSBudWxsIHx8XG5cdFx0XHQob2xkVk5vZGUgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSA9PT0gb2xkVk5vZGUudHlwZSlcblx0XHQpIHtcblx0XHRcdG9sZENoaWxkcmVuW2ldID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFaXRoZXIgb2xkVk5vZGUgPT09IHVuZGVmaW5lZCBvciBvbGRDaGlsZHJlbkxlbmd0aCA+IDAsXG5cdFx0XHQvLyBzbyBhZnRlciB0aGlzIGxvb3Agb2xkVk5vZGUgPT0gbnVsbCBvciBvbGRWTm9kZSBpcyBhIHZhbGlkIHZhbHVlLlxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IG9sZENoaWxkcmVuTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltqXTtcblx0XHRcdFx0Ly8gSWYgY2hpbGRWTm9kZSBpcyB1bmtleWVkLCB3ZSBvbmx5IG1hdGNoIHNpbWlsYXJseSB1bmtleWVkIG5vZGVzLCBvdGhlcndpc2Ugd2UgbWF0Y2ggYnkga2V5LlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgbWF0Y2ggYnkgdHlwZSAoaW4gZWl0aGVyIGNhc2UpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0b2xkVk5vZGUgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGVcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0b2xkQ2hpbGRyZW5bal0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2xkVk5vZGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG9sZFZOb2RlID0gb2xkVk5vZGUgfHwgRU1QVFlfT0JKO1xuXG5cdFx0Ly8gTW9ycGggdGhlIG9sZCBlbGVtZW50IGludG8gdGhlIG5ldyBvbmUsIGJ1dCBkb24ndCBhcHBlbmQgaXQgdG8gdGhlIGRvbSB5ZXRcblx0XHRkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdGlzU3ZnLFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSxcblx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0KTtcblxuXHRcdG5ld0RvbSA9IGNoaWxkVk5vZGUuX2RvbTtcblxuXHRcdGlmICgoaiA9IGNoaWxkVk5vZGUucmVmKSAmJiBvbGRWTm9kZS5yZWYgIT0gaikge1xuXHRcdFx0aWYgKCFyZWZzKSByZWZzID0gW107XG5cdFx0XHRpZiAob2xkVk5vZGUucmVmKSByZWZzLnB1c2gob2xkVk5vZGUucmVmLCBudWxsLCBjaGlsZFZOb2RlKTtcblx0XHRcdHJlZnMucHVzaChqLCBjaGlsZFZOb2RlLl9jb21wb25lbnQgfHwgbmV3RG9tLCBjaGlsZFZOb2RlKTtcblx0XHR9XG5cblx0XHRpZiAobmV3RG9tICE9IG51bGwpIHtcblx0XHRcdGlmIChmaXJzdENoaWxkRG9tID09IG51bGwpIHtcblx0XHRcdFx0Zmlyc3RDaGlsZERvbSA9IG5ld0RvbTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgY2hpbGRWTm9kZS50eXBlID09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5fY2hpbGRyZW4gPT09IG9sZFZOb2RlLl9jaGlsZHJlblxuXHRcdFx0KSB7XG5cdFx0XHRcdGNoaWxkVk5vZGUuX25leHREb20gPSBvbGREb20gPSByZW9yZGVyQ2hpbGRyZW4oXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdFx0cGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKFxuXHRcdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRcdG9sZENoaWxkcmVuLFxuXHRcdFx0XHRcdG5ld0RvbSxcblx0XHRcdFx0XHRvbGREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBuZXdQYXJlbnRWTm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Ly8gQmVjYXVzZSB0aGUgbmV3UGFyZW50Vk5vZGUgaXMgRnJhZ21lbnQtbGlrZSwgd2UgbmVlZCB0byBzZXQgaXQnc1xuXHRcdFx0XHQvLyBfbmV4dERvbSBwcm9wZXJ0eSB0byB0aGUgbmV4dFNpYmxpbmcgb2YgaXRzIGxhc3QgY2hpbGQgRE9NIG5vZGUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIGBvbGREb21gIGNvbnRhaW5zIHRoZSBjb3JyZWN0IHZhbHVlIGhlcmUgYmVjYXVzZSBpZiB0aGUgbGFzdCBjaGlsZFxuXHRcdFx0XHQvLyBpcyBhIEZyYWdtZW50LWxpa2UsIHRoZW4gb2xkRG9tIGhhcyBhbHJlYWR5IGJlZW4gc2V0IHRvIHRoYXQgY2hpbGQncyBfbmV4dERvbS5cblx0XHRcdFx0Ly8gSWYgdGhlIGxhc3QgY2hpbGQgaXMgYSBET00gVk5vZGUsIHRoZW4gb2xkRG9tIHdpbGwgYmUgc2V0IHRvIHRoYXQgRE9NXG5cdFx0XHRcdC8vIG5vZGUncyBuZXh0U2libGluZy5cblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBvbGREb207XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdG9sZERvbSAmJlxuXHRcdFx0b2xkVk5vZGUuX2RvbSA9PSBvbGREb20gJiZcblx0XHRcdG9sZERvbS5wYXJlbnROb2RlICE9IHBhcmVudERvbVxuXHRcdCkge1xuXHRcdFx0Ly8gVGhlIGFib3ZlIGNvbmRpdGlvbiBpcyB0byBoYW5kbGUgbnVsbCBwbGFjZWhvbGRlcnMuIFNlZSB0ZXN0IGluIHBsYWNlaG9sZGVyLnRlc3QuanM6XG5cdFx0XHQvLyBgZWZmaWNpZW50bHkgcmVwbGFjZSBudWxsIHBsYWNlaG9sZGVycyBpbiBwYXJlbnQgcmVyZW5kZXJzYFxuXHRcdFx0b2xkRG9tID0gZ2V0RG9tU2libGluZyhvbGRWTm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0bmV3UGFyZW50Vk5vZGUuX2RvbSA9IGZpcnN0Q2hpbGREb207XG5cblx0Ly8gUmVtb3ZlIHJlbWFpbmluZyBvbGRDaGlsZHJlbiBpZiB0aGVyZSBhcmUgYW55LlxuXHRmb3IgKGkgPSBvbGRDaGlsZHJlbkxlbmd0aDsgaS0tOyApIHtcblx0XHRpZiAob2xkQ2hpbGRyZW5baV0gIT0gbnVsbCkge1xuXHRcdFx0dW5tb3VudChvbGRDaGlsZHJlbltpXSwgb2xkQ2hpbGRyZW5baV0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNldCByZWZzIG9ubHkgYWZ0ZXIgdW5tb3VudFxuXHRpZiAocmVmcykge1xuXHRcdGZvciAoaSA9IDA7IGkgPCByZWZzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcHBseVJlZihyZWZzW2ldLCByZWZzWysraV0sIHJlZnNbKytpXSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlb3JkZXJDaGlsZHJlbihjaGlsZFZOb2RlLCBvbGREb20sIHBhcmVudERvbSkge1xuXHQvLyBOb3RlOiBWTm9kZXMgaW4gbmVzdGVkIHN1c3BlbmRlZCB0cmVlcyBtYXkgYmUgbWlzc2luZyBfY2hpbGRyZW4uXG5cdGxldCBjID0gY2hpbGRWTm9kZS5fY2hpbGRyZW47XG5cdGxldCB0bXAgPSAwO1xuXHRmb3IgKDsgYyAmJiB0bXAgPCBjLmxlbmd0aDsgdG1wKyspIHtcblx0XHRsZXQgdm5vZGUgPSBjW3RtcF07XG5cdFx0aWYgKHZub2RlKSB7XG5cdFx0XHQvLyBXZSB0eXBpY2FsbHkgZW50ZXIgdGhpcyBjb2RlIHBhdGggb24gc0NVIGJhaWxvdXQsIHdoZXJlIHdlIGNvcHlcblx0XHRcdC8vIG9sZFZOb2RlLl9jaGlsZHJlbiB0byBuZXdWTm9kZS5fY2hpbGRyZW4uIElmIHRoYXQgaXMgdGhlIGNhc2UsIHdlIG5lZWRcblx0XHRcdC8vIHRvIHVwZGF0ZSB0aGUgb2xkIGNoaWxkcmVuJ3MgX3BhcmVudCBwb2ludGVyIHRvIHBvaW50IHRvIHRoZSBuZXdWTm9kZVxuXHRcdFx0Ly8gKGNoaWxkVk5vZGUgaGVyZSkuXG5cdFx0XHR2bm9kZS5fcGFyZW50ID0gY2hpbGRWTm9kZTtcblxuXHRcdFx0aWYgKHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0b2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKHZub2RlLCBvbGREb20sIHBhcmVudERvbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKHBhcmVudERvbSwgdm5vZGUsIHZub2RlLCBjLCB2bm9kZS5fZG9tLCBvbGREb20pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG5cbi8qKlxuICogRmxhdHRlbiBhbmQgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW59IGNoaWxkcmVuIFRoZSB1bmZsYXR0ZW5lZFxuICogY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQ2hpbGRBcnJheShjaGlsZHJlbiwgb3V0KSB7XG5cdG91dCA9IG91dCB8fCBbXTtcblx0aWYgKGNoaWxkcmVuID09IG51bGwgfHwgdHlwZW9mIGNoaWxkcmVuID09ICdib29sZWFuJykge1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0Y2hpbGRyZW4uc29tZShjaGlsZCA9PiB7XG5cdFx0XHR0b0NoaWxkQXJyYXkoY2hpbGQsIG91dCk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b3V0LnB1c2goY2hpbGRyZW4pO1xuXHR9XG5cdHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQ2hpbGQoXG5cdHBhcmVudERvbSxcblx0Y2hpbGRWTm9kZSxcblx0b2xkVk5vZGUsXG5cdG9sZENoaWxkcmVuLFxuXHRuZXdEb20sXG5cdG9sZERvbVxuKSB7XG5cdGxldCBuZXh0RG9tO1xuXHRpZiAoY2hpbGRWTm9kZS5fbmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gT25seSBGcmFnbWVudHMgb3IgY29tcG9uZW50cyB0aGF0IHJldHVybiBGcmFnbWVudCBsaWtlIFZOb2RlcyB3aWxsXG5cdFx0Ly8gaGF2ZSBhIG5vbi11bmRlZmluZWQgX25leHREb20uIENvbnRpbnVlIHRoZSBkaWZmIGZyb20gdGhlIHNpYmxpbmdcblx0XHQvLyBvZiBsYXN0IERPTSBjaGlsZCBvZiB0aGlzIGNoaWxkIFZOb2RlXG5cdFx0bmV4dERvbSA9IGNoaWxkVk5vZGUuX25leHREb207XG5cblx0XHQvLyBFYWdlcmx5IGNsZWFudXAgX25leHREb20uIFdlIGRvbid0IG5lZWQgdG8gcGVyc2lzdCB0aGUgdmFsdWUgYmVjYXVzZVxuXHRcdC8vIGl0IGlzIG9ubHkgdXNlZCBieSBgZGlmZkNoaWxkcmVuYCB0byBkZXRlcm1pbmUgd2hlcmUgdG8gcmVzdW1lIHRoZSBkaWZmIGFmdGVyXG5cdFx0Ly8gZGlmZmluZyBDb21wb25lbnRzIGFuZCBGcmFnbWVudHMuIE9uY2Ugd2Ugc3RvcmUgaXQgdGhlIG5leHRET00gbG9jYWwgdmFyLCB3ZVxuXHRcdC8vIGNhbiBjbGVhbiB1cCB0aGUgcHJvcGVydHlcblx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKFxuXHRcdG9sZFZOb2RlID09IG51bGwgfHxcblx0XHRuZXdEb20gIT0gb2xkRG9tIHx8XG5cdFx0bmV3RG9tLnBhcmVudE5vZGUgPT0gbnVsbFxuXHQpIHtcblx0XHRvdXRlcjogaWYgKG9sZERvbSA9PSBudWxsIHx8IG9sZERvbS5wYXJlbnROb2RlICE9PSBwYXJlbnREb20pIHtcblx0XHRcdHBhcmVudERvbS5hcHBlbmRDaGlsZChuZXdEb20pO1xuXHRcdFx0bmV4dERvbSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGBqPG9sZENoaWxkcmVuTGVuZ3RoOyBqKz0yYCBpcyBhbiBhbHRlcm5hdGl2ZSB0byBgaisrPG9sZENoaWxkcmVuTGVuZ3RoLzJgXG5cdFx0XHRmb3IgKFxuXHRcdFx0XHRsZXQgc2liRG9tID0gb2xkRG9tLCBqID0gMDtcblx0XHRcdFx0KHNpYkRvbSA9IHNpYkRvbS5uZXh0U2libGluZykgJiYgaiA8IG9sZENoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0aiArPSAxXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKHNpYkRvbSA9PSBuZXdEb20pIHtcblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyZW50RG9tLmluc2VydEJlZm9yZShuZXdEb20sIG9sZERvbSk7XG5cdFx0XHRuZXh0RG9tID0gb2xkRG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgcHJlLWNhbGN1bGF0ZWQgdGhlIG5leHRET00gbm9kZSwgdXNlIGl0LiBFbHNlIGNhbGN1bGF0ZSBpdCBub3dcblx0Ly8gU3RyaWN0bHkgY2hlY2sgZm9yIGB1bmRlZmluZWRgIGhlcmUgY3V6IGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlIG9mIGBuZXh0RG9tYC5cblx0Ly8gU2VlIG1vcmUgZGV0YWlsIGluIGNyZWF0ZS1lbGVtZW50LmpzOmNyZWF0ZVZOb2RlXG5cdGlmIChuZXh0RG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHRvbGREb20gPSBuZXh0RG9tO1xuXHR9IGVsc2Uge1xuXHRcdG9sZERvbSA9IG5ld0RvbS5uZXh0U2libGluZztcblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG4iLCJpbXBvcnQgeyBJU19OT05fRElNRU5TSU9OQUwgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi4vb3B0aW9ucyc7XG5cbi8qKlxuICogRGlmZiB0aGUgb2xkIGFuZCBuZXcgcHJvcGVydGllcyBvZiBhIFZOb2RlIGFuZCBhcHBseSBjaGFuZ2VzIHRvIHRoZSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBhcHBseVxuICogY2hhbmdlcyB0b1xuICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzIFRoZSBuZXcgcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbGRQcm9wcyBUaGUgb2xkIHByb3BzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBoeWRyYXRlIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb24gbW9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZlByb3BzKGRvbSwgbmV3UHJvcHMsIG9sZFByb3BzLCBpc1N2ZywgaHlkcmF0ZSkge1xuXHRsZXQgaTtcblxuXHRmb3IgKGkgaW4gb2xkUHJvcHMpIHtcblx0XHRpZiAoaSAhPT0gJ2NoaWxkcmVuJyAmJiBpICE9PSAna2V5JyAmJiAhKGkgaW4gbmV3UHJvcHMpKSB7XG5cdFx0XHRzZXRQcm9wZXJ0eShkb20sIGksIG51bGwsIG9sZFByb3BzW2ldLCBpc1N2Zyk7XG5cdFx0fVxuXHR9XG5cblx0Zm9yIChpIGluIG5ld1Byb3BzKSB7XG5cdFx0aWYgKFxuXHRcdFx0KCFoeWRyYXRlIHx8IHR5cGVvZiBuZXdQcm9wc1tpXSA9PSAnZnVuY3Rpb24nKSAmJlxuXHRcdFx0aSAhPT0gJ2NoaWxkcmVuJyAmJlxuXHRcdFx0aSAhPT0gJ2tleScgJiZcblx0XHRcdGkgIT09ICd2YWx1ZScgJiZcblx0XHRcdGkgIT09ICdjaGVja2VkJyAmJlxuXHRcdFx0b2xkUHJvcHNbaV0gIT09IG5ld1Byb3BzW2ldXG5cdFx0KSB7XG5cdFx0XHRzZXRQcm9wZXJ0eShkb20sIGksIG5ld1Byb3BzW2ldLCBvbGRQcm9wc1tpXSwgaXNTdmcpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwga2V5LCB2YWx1ZSkge1xuXHRpZiAoa2V5WzBdID09PSAnLScpIHtcblx0XHRzdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcblx0fSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0c3R5bGVba2V5XSA9ICcnO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnbnVtYmVyJyB8fCBJU19OT05fRElNRU5TSU9OQUwudGVzdChrZXkpKSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlW2tleV0gPSB2YWx1ZSArICdweCc7XG5cdH1cbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSB2YWx1ZSBvbiBhIERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBub2RlIHRvIG1vZGlmeVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBwcm9wZXJ0eSB0b1xuICogQHBhcmFtIHsqfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIHRoZSBwcm9wZXJ0eSBoYWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZSBvciBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFByb3BlcnR5KGRvbSwgbmFtZSwgdmFsdWUsIG9sZFZhbHVlLCBpc1N2Zykge1xuXHRsZXQgdXNlQ2FwdHVyZTtcblxuXHRvOiBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdGRvbS5zdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkVmFsdWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0ZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRWYWx1ZSA9ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob2xkVmFsdWUpIHtcblx0XHRcdFx0Zm9yIChuYW1lIGluIG9sZFZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKCEodmFsdWUgJiYgbmFtZSBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHNldFN0eWxlKGRvbS5zdHlsZSwgbmFtZSwgJycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0Zm9yIChuYW1lIGluIHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKCFvbGRWYWx1ZSB8fCB2YWx1ZVtuYW1lXSAhPT0gb2xkVmFsdWVbbmFtZV0pIHtcblx0XHRcdFx0XHRcdHNldFN0eWxlKGRvbS5zdHlsZSwgbmFtZSwgdmFsdWVbbmFtZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyBCZW5jaG1hcmsgZm9yIGNvbXBhcmlzb246IGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNTc0Yzk1NGJkYjk2NWI5YTAwOTY1YWM2XG5cdGVsc2UgaWYgKG5hbWVbMF0gPT09ICdvJyAmJiBuYW1lWzFdID09PSAnbicpIHtcblx0XHR1c2VDYXB0dXJlID0gbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL0NhcHR1cmUkLywgJycpKTtcblxuXHRcdC8vIEluZmVyIGNvcnJlY3QgY2FzaW5nIGZvciBET00gYnVpbHQtaW4gZXZlbnRzOlxuXHRcdGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgaW4gZG9tKSBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDIpO1xuXHRcdGVsc2UgbmFtZSA9IG5hbWUuc2xpY2UoMik7XG5cblx0XHRpZiAoIWRvbS5fbGlzdGVuZXJzKSBkb20uX2xpc3RlbmVycyA9IHt9O1xuXHRcdGRvbS5fbGlzdGVuZXJzW25hbWUgKyB1c2VDYXB0dXJlXSA9IHZhbHVlO1xuXG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRpZiAoIW9sZFZhbHVlKSB7XG5cdFx0XHRcdGNvbnN0IGhhbmRsZXIgPSB1c2VDYXB0dXJlID8gZXZlbnRQcm94eUNhcHR1cmUgOiBldmVudFByb3h5O1xuXHRcdFx0XHRkb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgaGFuZGxlciA9IHVzZUNhcHR1cmUgPyBldmVudFByb3h5Q2FwdHVyZSA6IGV2ZW50UHJveHk7XG5cdFx0XHRkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSAhPT0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJykge1xuXHRcdGlmIChpc1N2Zykge1xuXHRcdFx0Ly8gTm9ybWFsaXplIGluY29ycmVjdCBwcm9wIHVzYWdlIGZvciBTVkc6XG5cdFx0XHQvLyAtIHhsaW5rOmhyZWYgLyB4bGlua0hyZWYgLS0+IGhyZWYgKHhsaW5rOmhyZWYgd2FzIHJlbW92ZWQgZnJvbSBTVkcgYW5kIGlzbid0IG5lZWRlZClcblx0XHRcdC8vIC0gY2xhc3NOYW1lIC0tPiBjbGFzc1xuXHRcdFx0bmFtZSA9IG5hbWUucmVwbGFjZSgveGxpbmsoSHw6aCkvLCAnaCcpLnJlcGxhY2UoL3NOYW1lJC8sICdzJyk7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdG5hbWUgIT09ICdocmVmJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2xpc3QnICYmXG5cdFx0XHRuYW1lICE9PSAnZm9ybScgJiZcblx0XHRcdC8vIERlZmF1bHQgdmFsdWUgaW4gYnJvd3NlcnMgaXMgYC0xYCBhbmQgYW4gZW1wdHkgc3RyaW5nIGlzXG5cdFx0XHQvLyBjYXN0IHRvIGAwYCBpbnN0ZWFkXG5cdFx0XHRuYW1lICE9PSAndGFiSW5kZXgnICYmXG5cdFx0XHRuYW1lICE9PSAnZG93bmxvYWQnICYmXG5cdFx0XHRuYW1lIGluIGRvbVxuXHRcdCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9tW25hbWVdID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG5cdFx0XHRcdC8vIGxhYmVsbGVkIGJyZWFrIGlzIDFiIHNtYWxsZXIgaGVyZSB0aGFuIGEgcmV0dXJuIHN0YXRlbWVudCAoc29ycnkpXG5cdFx0XHRcdGJyZWFrIG87XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH1cblxuXHRcdC8vIEFSSUEtYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5vdGlvbiBvZiBib29sZWFuIHZhbHVlcy5cblx0XHQvLyBUaGUgdmFsdWUgYGZhbHNlYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYXR0cmlidXRlIG5vdFxuXHRcdC8vIGV4aXN0aW5nIG9uIHRoZSBET00sIHNvIHdlIGNhbid0IHJlbW92ZSBpdC4gRm9yIG5vbi1ib29sZWFuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIHdlIGNvdWxkIHRyZWF0IGZhbHNlIGFzIGEgcmVtb3ZhbCwgYnV0IHRoZVxuXHRcdC8vIGFtb3VudCBvZiBleGNlcHRpb25zIHdvdWxkIGNvc3QgdXMgdG9vIG1hbnkgYnl0ZXMuIE9uIHRvcCBvZlxuXHRcdC8vIHRoYXQgb3RoZXIgVkRPTSBmcmFtZXdvcmtzIGFsc28gYWx3YXlzIHN0cmluZ2lmeSBgZmFsc2VgLlxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gbmV2ZXIgc2VyaWFsaXplIGZ1bmN0aW9ucyBhcyBhdHRyaWJ1dGUgdmFsdWVzXG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSAhPT0gZmFsc2UgfHwgbmFtZS5pbmRleE9mKCctJykgIT0gLTEpKSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBQcm94eSBhbiBldmVudCB0byBob29rZWQgZXZlbnQgaGFuZGxlcnNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBicm93c2VyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBldmVudFByb3h5KGUpIHtcblx0dGhpcy5fbGlzdGVuZXJzW2UudHlwZSArIGZhbHNlXShvcHRpb25zLmV2ZW50ID8gb3B0aW9ucy5ldmVudChlKSA6IGUpO1xufVxuXG5mdW5jdGlvbiBldmVudFByb3h5Q2FwdHVyZShlKSB7XG5cdHRoaXMuX2xpc3RlbmVyc1tlLnR5cGUgKyB0cnVlXShvcHRpb25zLmV2ZW50ID8gb3B0aW9ucy5ldmVudChlKSA6IGUpO1xufVxuIiwiaW1wb3J0IHsgRU1QVFlfT0JKIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IENvbXBvbmVudCwgZ2V0RG9tU2libGluZyB9IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4uL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCB7IGRpZmZDaGlsZHJlbiB9IGZyb20gJy4vY2hpbGRyZW4nO1xuaW1wb3J0IHsgZGlmZlByb3BzLCBzZXRQcm9wZXJ0eSB9IGZyb20gJy4vcHJvcHMnO1xuaW1wb3J0IHsgYXNzaWduLCByZW1vdmVOb2RlLCBzbGljZSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi4vb3B0aW9ucyc7XG5cbi8qKlxuICogRGlmZiB0d28gdmlydHVhbCBub2RlcyBhbmQgYXBwbHkgcHJvcGVyIGNoYW5nZXMgdG8gdGhlIERPTVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBwYXJlbnQgb2YgdGhlIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRWTm9kZSBUaGUgb2xkIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QuIE1vZGlmaWVkIGJ5IGdldENoaWxkQ29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIGVsZW1lbnQgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnQ+fSBleGNlc3NEb21DaGlsZHJlblxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gb2xkRG9tIFRoZSBjdXJyZW50IGF0dGFjaGVkIERPTVxuICogZWxlbWVudCBhbnkgbmV3IGRvbSBlbGVtZW50cyBzaG91bGQgYmUgcGxhY2VkIGFyb3VuZC4gTGlrZWx5IGBudWxsYCBvbiBmaXJzdFxuICogcmVuZGVyIChleGNlcHQgd2hlbiBoeWRyYXRpbmcpLiBDYW4gYmUgYSBzaWJsaW5nIERPTSBlbGVtZW50IHdoZW4gZGlmZmluZ1xuICogRnJhZ21lbnRzIHRoYXQgaGF2ZSBzaWJsaW5ncy4gSW4gbW9zdCBjYXNlcywgaXQgc3RhcnRzIG91dCBhcyBgb2xkQ2hpbGRyZW5bMF0uX2RvbWAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0h5ZHJhdGluZ10gV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZihcblx0cGFyZW50RG9tLFxuXHRuZXdWTm9kZSxcblx0b2xkVk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdG9sZERvbSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgdG1wLFxuXHRcdG5ld1R5cGUgPSBuZXdWTm9kZS50eXBlO1xuXG5cdC8vIFdoZW4gcGFzc2luZyB0aHJvdWdoIGNyZWF0ZUVsZW1lbnQgaXQgYXNzaWducyB0aGUgb2JqZWN0XG5cdC8vIGNvbnN0cnVjdG9yIGFzIHVuZGVmaW5lZC4gVGhpcyB0byBwcmV2ZW50IEpTT04taW5qZWN0aW9uLlxuXHRpZiAobmV3Vk5vZGUuY29uc3RydWN0b3IgIT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG5cblx0Ly8gSWYgdGhlIHByZXZpb3VzIGRpZmYgYmFpbGVkIG91dCwgcmVzdW1lIGNyZWF0aW5nL2h5ZHJhdGluZy5cblx0aWYgKG9sZFZOb2RlLl9oeWRyYXRpbmcgIT0gbnVsbCkge1xuXHRcdGlzSHlkcmF0aW5nID0gb2xkVk5vZGUuX2h5ZHJhdGluZztcblx0XHRvbGREb20gPSBuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHQvLyBpZiB3ZSByZXN1bWUsIHdlIHdhbnQgdGhlIHRyZWUgdG8gYmUgXCJ1bmxvY2tlZFwiXG5cdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9IG51bGw7XG5cdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPSBbb2xkRG9tXTtcblx0fVxuXG5cdGlmICgodG1wID0gb3B0aW9ucy5fZGlmZikpIHRtcChuZXdWTm9kZSk7XG5cblx0dHJ5IHtcblx0XHRvdXRlcjogaWYgKHR5cGVvZiBuZXdUeXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdGxldCBjLCBpc05ldywgb2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCwgY2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uO1xuXHRcdFx0bGV0IG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHM7XG5cblx0XHRcdC8vIE5lY2Vzc2FyeSBmb3IgY3JlYXRlQ29udGV4dCBhcGkuIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB3aWxsIHBhc3Ncblx0XHRcdC8vIHRoZSBjb250ZXh0IHZhbHVlIGFzIGB0aGlzLmNvbnRleHRgIGp1c3QgZm9yIHRoaXMgY29tcG9uZW50LlxuXHRcdFx0dG1wID0gbmV3VHlwZS5jb250ZXh0VHlwZTtcblx0XHRcdGxldCBwcm92aWRlciA9IHRtcCAmJiBnbG9iYWxDb250ZXh0W3RtcC5faWRdO1xuXHRcdFx0bGV0IGNvbXBvbmVudENvbnRleHQgPSB0bXBcblx0XHRcdFx0PyBwcm92aWRlclxuXHRcdFx0XHRcdD8gcHJvdmlkZXIucHJvcHMudmFsdWVcblx0XHRcdFx0XHQ6IHRtcC5fZGVmYXVsdFZhbHVlXG5cdFx0XHRcdDogZ2xvYmFsQ29udGV4dDtcblxuXHRcdFx0Ly8gR2V0IGNvbXBvbmVudCBhbmQgc2V0IGl0IHRvIGBjYFxuXHRcdFx0aWYgKG9sZFZOb2RlLl9jb21wb25lbnQpIHtcblx0XHRcdFx0YyA9IG5ld1ZOb2RlLl9jb21wb25lbnQgPSBvbGRWTm9kZS5fY29tcG9uZW50O1xuXHRcdFx0XHRjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24gPSBjLl9wcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcGVuZGluZ0Vycm9yO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSW5zdGFudGlhdGUgdGhlIG5ldyBjb21wb25lbnRcblx0XHRcdFx0aWYgKCdwcm90b3R5cGUnIGluIG5ld1R5cGUgJiYgbmV3VHlwZS5wcm90b3R5cGUucmVuZGVyKSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBUaGUgY2hlY2sgYWJvdmUgdmVyaWZpZXMgdGhhdCBuZXdUeXBlIGlzIHN1cHBvc2UgdG8gYmUgY29uc3RydWN0ZWRcblx0XHRcdFx0XHRuZXdWTm9kZS5fY29tcG9uZW50ID0gYyA9IG5ldyBuZXdUeXBlKG5ld1Byb3BzLCBjb21wb25lbnRDb250ZXh0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBUcnVzdCBtZSwgQ29tcG9uZW50IGltcGxlbWVudHMgdGhlIGludGVyZmFjZSB3ZSB3YW50XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgQ29tcG9uZW50KG5ld1Byb3BzLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0XHRjLmNvbnN0cnVjdG9yID0gbmV3VHlwZTtcblx0XHRcdFx0XHRjLnJlbmRlciA9IGRvUmVuZGVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcm92aWRlcikgcHJvdmlkZXIuc3ViKGMpO1xuXG5cdFx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdFx0aWYgKCFjLnN0YXRlKSBjLnN0YXRlID0ge307XG5cdFx0XHRcdGMuY29udGV4dCA9IGNvbXBvbmVudENvbnRleHQ7XG5cdFx0XHRcdGMuX2dsb2JhbENvbnRleHQgPSBnbG9iYWxDb250ZXh0O1xuXHRcdFx0XHRpc05ldyA9IGMuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzID0gW107XG5cdFx0XHRcdGMuX3N0YXRlQ2FsbGJhY2tzID0gW107XG5cdFx0XHR9XG5cblx0XHRcdC8vIEludm9rZSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcblx0XHRcdGlmIChjLl9uZXh0U3RhdGUgPT0gbnVsbCkge1xuXHRcdFx0XHRjLl9uZXh0U3RhdGUgPSBjLnN0YXRlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IGMuc3RhdGUpIHtcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUgPSBhc3NpZ24oe30sIGMuX25leHRTdGF0ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhc3NpZ24oXG5cdFx0XHRcdFx0Yy5fbmV4dFN0YXRlLFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5ld1Byb3BzLCBjLl9uZXh0U3RhdGUpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdG9sZFByb3BzID0gYy5wcm9wcztcblx0XHRcdG9sZFN0YXRlID0gYy5zdGF0ZTtcblxuXHRcdFx0Ly8gSW52b2tlIHByZS1yZW5kZXIgbGlmZWN5Y2xlIG1ldGhvZHNcblx0XHRcdGlmIChpc05ldykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbE1vdW50ICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZE1vdW50ICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLmNvbXBvbmVudERpZE1vdW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09IG51bGwgJiZcblx0XHRcdFx0XHRuZXdQcm9wcyAhPT0gb2xkUHJvcHMgJiZcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCghYy5fZm9yY2UgJiZcblx0XHRcdFx0XHRcdGMuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9IG51bGwgJiZcblx0XHRcdFx0XHRcdGMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuXHRcdFx0XHRcdFx0XHRuZXdQcm9wcyxcblx0XHRcdFx0XHRcdFx0Yy5fbmV4dFN0YXRlLFxuXHRcdFx0XHRcdFx0XHRjb21wb25lbnRDb250ZXh0XG5cdFx0XHRcdFx0XHQpID09PSBmYWxzZSkgfHxcblx0XHRcdFx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPT09IG9sZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0XHQvLyBNb3JlIGluZm8gYWJvdXQgdGhpcyBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9Kb3ZpRGVDcm9vY2svYmVjNWYyY2U5MzU0NGQyZTYwNzBlZjhlMDAzNmU0ZThcblx0XHRcdFx0XHRpZiAobmV3Vk5vZGUuX29yaWdpbmFsICE9PSBvbGRWTm9kZS5fb3JpZ2luYWwpIGMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0Yy5fdm5vZGUgPSBuZXdWTm9kZTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuLmZvckVhY2godm5vZGUgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHZub2RlKSB2bm9kZS5fcGFyZW50ID0gbmV3Vk5vZGU7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGMuX3N0YXRlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLl9zdGF0ZUNhbGxiYWNrc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGMuX3N0YXRlQ2FsbGJhY2tzID0gW107XG5cblx0XHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudFdpbGxVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgYy5fbmV4dFN0YXRlLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuXHRcdFx0XHRcdFx0Yy5jb21wb25lbnREaWRVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdGMuX3Zub2RlID0gbmV3Vk5vZGU7XG5cdFx0XHRjLl9wYXJlbnREb20gPSBwYXJlbnREb207XG5cblx0XHRcdGxldCByZW5kZXJIb29rID0gb3B0aW9ucy5fcmVuZGVyLFxuXHRcdFx0XHRjb3VudCA9IDA7XG5cdFx0XHRpZiAoJ3Byb3RvdHlwZScgaW4gbmV3VHlwZSAmJiBuZXdUeXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAocmVuZGVySG9vaykgcmVuZGVySG9vayhuZXdWTm9kZSk7XG5cblx0XHRcdFx0dG1wID0gYy5yZW5kZXIoYy5wcm9wcywgYy5zdGF0ZSwgYy5jb250ZXh0KTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGMuX3N0YXRlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5fc3RhdGVDYWxsYmFja3NbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGMuX3N0YXRlQ2FsbGJhY2tzID0gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAocmVuZGVySG9vaykgcmVuZGVySG9vayhuZXdWTm9kZSk7XG5cblx0XHRcdFx0XHR0bXAgPSBjLnJlbmRlcihjLnByb3BzLCBjLnN0YXRlLCBjLmNvbnRleHQpO1xuXG5cdFx0XHRcdFx0Ly8gSGFuZGxlIHNldFN0YXRlIGNhbGxlZCBpbiByZW5kZXIsIHNlZSAjMjU1M1xuXHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdH0gd2hpbGUgKGMuX2RpcnR5ICYmICsrY291bnQgPCAyNSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBzZXRTdGF0ZSBjYWxsZWQgaW4gcmVuZGVyLCBzZWUgIzI1NTNcblx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cblx0XHRcdGlmIChjLmdldENoaWxkQ29udGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdGdsb2JhbENvbnRleHQgPSBhc3NpZ24oYXNzaWduKHt9LCBnbG9iYWxDb250ZXh0KSwgYy5nZXRDaGlsZENvbnRleHQoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaXNOZXcgJiYgYy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdHNuYXBzaG90ID0gYy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShvbGRQcm9wcywgb2xkU3RhdGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgaXNUb3BMZXZlbEZyYWdtZW50ID1cblx0XHRcdFx0dG1wICE9IG51bGwgJiYgdG1wLnR5cGUgPT09IEZyYWdtZW50ICYmIHRtcC5rZXkgPT0gbnVsbDtcblx0XHRcdGxldCByZW5kZXJSZXN1bHQgPSBpc1RvcExldmVsRnJhZ21lbnQgPyB0bXAucHJvcHMuY2hpbGRyZW4gOiB0bXA7XG5cblx0XHRcdGRpZmZDaGlsZHJlbihcblx0XHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0XHRBcnJheS5pc0FycmF5KHJlbmRlclJlc3VsdCkgPyByZW5kZXJSZXN1bHQgOiBbcmVuZGVyUmVzdWx0XSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0XHQpO1xuXG5cdFx0XHRjLmJhc2UgPSBuZXdWTm9kZS5fZG9tO1xuXG5cdFx0XHQvLyBXZSBzdWNjZXNzZnVsbHkgcmVuZGVyZWQgdGhpcyBWTm9kZSwgdW5zZXQgYW55IHN0b3JlZCBoeWRyYXRpb24vYmFpbG91dCBzdGF0ZTpcblx0XHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSBudWxsO1xuXG5cdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRjb21taXRRdWV1ZS5wdXNoKGMpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uKSB7XG5cdFx0XHRcdGMuX3BlbmRpbmdFcnJvciA9IGMuX3Byb2Nlc3NpbmdFeGNlcHRpb24gPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjLl9mb3JjZSA9IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbiA9PSBudWxsICYmXG5cdFx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPT09IG9sZFZOb2RlLl9vcmlnaW5hbFxuXHRcdCkge1xuXHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBkaWZmRWxlbWVudE5vZGVzKFxuXHRcdFx0XHRvbGRWTm9kZS5fZG9tLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmICgodG1wID0gb3B0aW9ucy5kaWZmZWQpKSB0bXAobmV3Vk5vZGUpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0bmV3Vk5vZGUuX29yaWdpbmFsID0gbnVsbDtcblx0XHQvLyBpZiBoeWRyYXRpbmcgb3IgY3JlYXRpbmcgaW5pdGlhbCB0cmVlLCBiYWlsb3V0IHByZXNlcnZlcyBET006XG5cdFx0aWYgKGlzSHlkcmF0aW5nIHx8IGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGREb207XG5cdFx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gISFpc0h5ZHJhdGluZztcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuW2V4Y2Vzc0RvbUNoaWxkcmVuLmluZGV4T2Yob2xkRG9tKV0gPSBudWxsO1xuXHRcdFx0Ly8gXiBjb3VsZCBwb3NzaWJseSBiZSBzaW1wbGlmaWVkIHRvOlxuXHRcdFx0Ly8gZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoID0gMDtcblx0XHR9XG5cdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBuZXdWTm9kZSwgb2xkVk5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHJvb3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHJvb3QpIHtcblx0aWYgKG9wdGlvbnMuX2NvbW1pdCkgb3B0aW9ucy5fY29tbWl0KHJvb3QsIGNvbW1pdFF1ZXVlKTtcblxuXHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIFJldXNlIHRoZSBjb21taXRRdWV1ZSB2YXJpYWJsZSBoZXJlIHNvIHRoZSB0eXBlIGNoYW5nZXNcblx0XHRcdGNvbW1pdFF1ZXVlID0gYy5fcmVuZGVyQ2FsbGJhY2tzO1xuXHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzID0gW107XG5cdFx0XHRjb21taXRRdWV1ZS5zb21lKGNiID0+IHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBTZWUgYWJvdmUgdHMtaWdub3JlIG9uIGNvbW1pdFF1ZXVlXG5cdFx0XHRcdGNiLmNhbGwoYyk7XG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGMuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgcmVwcmVzZW50aW5nIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZ1xuICogdGhlIHZpcnR1YWwgbm9kZXMgYmVpbmcgZGlmZmVkXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRWTm9kZSBUaGUgb2xkIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHsqfSBleGNlc3NEb21DaGlsZHJlblxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGRpZmZFbGVtZW50Tm9kZXMoXG5cdGRvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCBvbGRQcm9wcyA9IG9sZFZOb2RlLnByb3BzO1xuXHRsZXQgbmV3UHJvcHMgPSBuZXdWTm9kZS5wcm9wcztcblx0bGV0IG5vZGVUeXBlID0gbmV3Vk5vZGUudHlwZTtcblx0bGV0IGkgPSAwO1xuXG5cdC8vIFRyYWNrcyBlbnRlcmluZyBhbmQgZXhpdGluZyBTVkcgbmFtZXNwYWNlIHdoZW4gZGVzY2VuZGluZyB0aHJvdWdoIHRoZSB0cmVlLlxuXHRpZiAobm9kZVR5cGUgPT09ICdzdmcnKSBpc1N2ZyA9IHRydWU7XG5cblx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRmb3IgKDsgaSA8IGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjaGlsZCA9IGV4Y2Vzc0RvbUNoaWxkcmVuW2ldO1xuXG5cdFx0XHQvLyBpZiBuZXdWTm9kZSBtYXRjaGVzIGFuIGVsZW1lbnQgaW4gZXhjZXNzRG9tQ2hpbGRyZW4gb3IgdGhlIGBkb21gXG5cdFx0XHQvLyBhcmd1bWVudCBtYXRjaGVzIGFuIGVsZW1lbnQgaW4gZXhjZXNzRG9tQ2hpbGRyZW4sIHJlbW92ZSBpdCBmcm9tXG5cdFx0XHQvLyBleGNlc3NEb21DaGlsZHJlbiBzbyBpdCBpc24ndCBsYXRlciByZW1vdmVkIGluIGRpZmZDaGlsZHJlblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRjaGlsZCAmJlxuXHRcdFx0XHQnc2V0QXR0cmlidXRlJyBpbiBjaGlsZCA9PT0gISFub2RlVHlwZSAmJlxuXHRcdFx0XHQobm9kZVR5cGUgPyBjaGlsZC5sb2NhbE5hbWUgPT09IG5vZGVUeXBlIDogY2hpbGQubm9kZVR5cGUgPT09IDMpXG5cdFx0XHQpIHtcblx0XHRcdFx0ZG9tID0gY2hpbGQ7XG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuW2ldID0gbnVsbDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKGRvbSA9PSBudWxsKSB7XG5cdFx0aWYgKG5vZGVUeXBlID09PSBudWxsKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlIGNyZWF0ZVRleHROb2RlIHJldHVybnMgVGV4dCwgd2UgZXhwZWN0IFByZWFjdEVsZW1lbnRcblx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShuZXdQcm9wcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzU3ZnKSB7XG5cdFx0XHRkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXG5cdFx0XHRcdCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgV2Uga25vdyBgbmV3Vk5vZGUudHlwZWAgaXMgYSBzdHJpbmdcblx0XHRcdFx0bm9kZVR5cGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgV2Uga25vdyBgbmV3Vk5vZGUudHlwZWAgaXMgYSBzdHJpbmdcblx0XHRcdFx0bm9kZVR5cGUsXG5cdFx0XHRcdG5ld1Byb3BzLmlzICYmIG5ld1Byb3BzXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIHdlIGNyZWF0ZWQgYSBuZXcgcGFyZW50LCBzbyBub25lIG9mIHRoZSBwcmV2aW91c2x5IGF0dGFjaGVkIGNoaWxkcmVuIGNhbiBiZSByZXVzZWQ6XG5cdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPSBudWxsO1xuXHRcdC8vIHdlIGFyZSBjcmVhdGluZyBhIG5ldyBub2RlLCBzbyB3ZSBjYW4gYXNzdW1lIHRoaXMgaXMgYSBuZXcgc3VidHJlZSAoaW4gY2FzZSB3ZSBhcmUgaHlkcmF0aW5nKSwgdGhpcyBkZW9wdHMgdGhlIGh5ZHJhdGVcblx0XHRpc0h5ZHJhdGluZyA9IGZhbHNlO1xuXHR9XG5cblx0aWYgKG5vZGVUeXBlID09PSBudWxsKSB7XG5cdFx0Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgd2Ugc3RpbGwgaGF2ZSB0byBzcGxpdCBtZXJnZWQgdGV4dCBmcm9tIFNTUidkIEhUTUwuXG5cdFx0aWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyAmJiAoIWlzSHlkcmF0aW5nIHx8IGRvbS5kYXRhICE9PSBuZXdQcm9wcykpIHtcblx0XHRcdGRvbS5kYXRhID0gbmV3UHJvcHM7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIElmIGV4Y2Vzc0RvbUNoaWxkcmVuIHdhcyBub3QgbnVsbCwgcmVwb3B1bGF0ZSBpdCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQncyBjaGlsZHJlbjpcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IGV4Y2Vzc0RvbUNoaWxkcmVuICYmIHNsaWNlLmNhbGwoZG9tLmNoaWxkTm9kZXMpO1xuXG5cdFx0b2xkUHJvcHMgPSBvbGRWTm9kZS5wcm9wcyB8fCBFTVBUWV9PQko7XG5cblx0XHRsZXQgb2xkSHRtbCA9IG9sZFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXHRcdGxldCBuZXdIdG1sID0gbmV3UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cblx0XHQvLyBEdXJpbmcgaHlkcmF0aW9uLCBwcm9wcyBhcmUgbm90IGRpZmZlZCBhdCBhbGwgKGluY2x1ZGluZyBkYW5nZXJvdXNseVNldElubmVySFRNTClcblx0XHQvLyBAVE9ETyB3ZSBzaG91bGQgd2FybiBpbiBkZWJ1ZyBtb2RlIHdoZW4gcHJvcHMgZG9uJ3QgbWF0Y2ggaGVyZS5cblx0XHRpZiAoIWlzSHlkcmF0aW5nKSB7XG5cdFx0XHQvLyBCdXQsIGlmIHdlIGFyZSBpbiBhIHNpdHVhdGlvbiB3aGVyZSB3ZSBhcmUgdXNpbmcgZXhpc3RpbmcgRE9NIChlLmcuIHJlcGxhY2VOb2RlKVxuXHRcdFx0Ly8gd2Ugc2hvdWxkIHJlYWQgdGhlIGV4aXN0aW5nIERPTSBhdHRyaWJ1dGVzIHRvIGRpZmYgdGhlbVxuXHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0b2xkUHJvcHMgPSB7fTtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGRvbS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0b2xkUHJvcHNbZG9tLmF0dHJpYnV0ZXNbaV0ubmFtZV0gPSBkb20uYXR0cmlidXRlc1tpXS52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmV3SHRtbCB8fCBvbGRIdG1sKSB7XG5cdFx0XHRcdC8vIEF2b2lkIHJlLWFwcGx5aW5nIHRoZSBzYW1lICdfX2h0bWwnIGlmIGl0IGRpZCBub3QgY2hhbmdlZCBiZXR3ZWVuIHJlLXJlbmRlclxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0IW5ld0h0bWwgfHxcblx0XHRcdFx0XHQoKCFvbGRIdG1sIHx8IG5ld0h0bWwuX19odG1sICE9IG9sZEh0bWwuX19odG1sKSAmJlxuXHRcdFx0XHRcdFx0bmV3SHRtbC5fX2h0bWwgIT09IGRvbS5pbm5lckhUTUwpXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRvbS5pbm5lckhUTUwgPSAobmV3SHRtbCAmJiBuZXdIdG1sLl9faHRtbCkgfHwgJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRkaWZmUHJvcHMoZG9tLCBuZXdQcm9wcywgb2xkUHJvcHMsIGlzU3ZnLCBpc0h5ZHJhdGluZyk7XG5cblx0XHQvLyBJZiB0aGUgbmV3IHZub2RlIGRpZG4ndCBoYXZlIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLCBkaWZmIGl0cyBjaGlsZHJlblxuXHRcdGlmIChuZXdIdG1sKSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBbXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aSA9IG5ld1ZOb2RlLnByb3BzLmNoaWxkcmVuO1xuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRkb20sXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkoaSkgPyBpIDogW2ldLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnICYmIG5vZGVUeXBlICE9PSAnZm9yZWlnbk9iamVjdCcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5cblx0XHRcdFx0XHQ/IGV4Y2Vzc0RvbUNoaWxkcmVuWzBdXG5cdFx0XHRcdFx0OiBvbGRWTm9kZS5fY2hpbGRyZW4gJiYgZ2V0RG9tU2libGluZyhvbGRWTm9kZSwgMCksXG5cdFx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyBSZW1vdmUgY2hpbGRyZW4gdGhhdCBhcmUgbm90IHBhcnQgb2YgYW55IHZub2RlLlxuXHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuICE9IG51bGwpIHtcblx0XHRcdFx0Zm9yIChpID0gZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbltpXSAhPSBudWxsKSByZW1vdmVOb2RlKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIChhcyBhYm92ZSwgZG9uJ3QgZGlmZiBwcm9wcyBkdXJpbmcgaHlkcmF0aW9uKVxuXHRcdGlmICghaXNIeWRyYXRpbmcpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0J3ZhbHVlJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLnZhbHVlKSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdC8vICMyNzU2IEZvciB0aGUgPHByb2dyZXNzPi1lbGVtZW50IHRoZSBpbml0aWFsIHZhbHVlIGlzIDAsXG5cdFx0XHRcdC8vIGRlc3BpdGUgdGhlIGF0dHJpYnV0ZSBub3QgYmVpbmcgcHJlc2VudC4gV2hlbiB0aGUgYXR0cmlidXRlXG5cdFx0XHRcdC8vIGlzIG1pc3NpbmcgdGhlIHByb2dyZXNzIGJhciBpcyB0cmVhdGVkIGFzIGluZGV0ZXJtaW5hdGUuXG5cdFx0XHRcdC8vIFRvIGZpeCB0aGF0IHdlJ2xsIGFsd2F5cyB1cGRhdGUgaXQgd2hlbiBpdCBpcyAwIGZvciBwcm9ncmVzcyBlbGVtZW50c1xuXHRcdFx0XHQoaSAhPT0gZG9tLnZhbHVlIHx8XG5cdFx0XHRcdFx0KG5vZGVUeXBlID09PSAncHJvZ3Jlc3MnICYmICFpKSB8fFxuXHRcdFx0XHRcdC8vIFRoaXMgaXMgb25seSBmb3IgSUUgMTEgdG8gZml4IDxzZWxlY3Q+IHZhbHVlIG5vdCBiZWluZyB1cGRhdGVkLlxuXHRcdFx0XHRcdC8vIFRvIGF2b2lkIGEgc3RhbGUgc2VsZWN0IHZhbHVlIHdlIG5lZWQgdG8gc2V0IHRoZSBvcHRpb24udmFsdWVcblx0XHRcdFx0XHQvLyBhZ2Fpbiwgd2hpY2ggdHJpZ2dlcnMgSUUxMSB0byByZS1ldmFsdWF0ZSB0aGUgc2VsZWN0IHZhbHVlXG5cdFx0XHRcdFx0KG5vZGVUeXBlID09PSAnb3B0aW9uJyAmJiBpICE9PSBvbGRQcm9wcy52YWx1ZSkpXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0UHJvcGVydHkoZG9tLCAndmFsdWUnLCBpLCBvbGRQcm9wcy52YWx1ZSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKFxuXHRcdFx0XHQnY2hlY2tlZCcgaW4gbmV3UHJvcHMgJiZcblx0XHRcdFx0KGkgPSBuZXdQcm9wcy5jaGVja2VkKSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHRcdGkgIT09IGRvbS5jaGVja2VkXG5cdFx0XHQpIHtcblx0XHRcdFx0c2V0UHJvcGVydHkoZG9tLCAnY2hlY2tlZCcsIGksIG9sZFByb3BzLmNoZWNrZWQsIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZG9tO1xufVxuXG4vKipcbiAqIEludm9rZSBvciB1cGRhdGUgYSByZWYsIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0IGlzIGEgZnVuY3Rpb24gb3Igb2JqZWN0IHJlZi5cbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSByZWZcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVJlZihyZWYsIHZhbHVlLCB2bm9kZSkge1xuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHJlZih2YWx1ZSk7XG5cdFx0ZWxzZSByZWYuY3VycmVudCA9IHZhbHVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCB2bm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBVbm1vdW50IGEgdmlydHVhbCBub2RlIGZyb20gdGhlIHRyZWUgYW5kIGFwcGx5IERPTSBjaGFuZ2VzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byB1bm1vdW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gcGFyZW50Vk5vZGUgVGhlIHBhcmVudCBvZiB0aGUgVk5vZGUgdGhhdFxuICogaW5pdGlhdGVkIHRoZSB1bm1vdW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwUmVtb3ZlXSBGbGFnIHRoYXQgaW5kaWNhdGVzIHRoYXQgYSBwYXJlbnQgbm9kZSBvZiB0aGVcbiAqIGN1cnJlbnQgZWxlbWVudCBpcyBhbHJlYWR5IGRldGFjaGVkIGZyb20gdGhlIERPTS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubW91bnQodm5vZGUsIHBhcmVudFZOb2RlLCBza2lwUmVtb3ZlKSB7XG5cdGxldCByO1xuXHRpZiAob3B0aW9ucy51bm1vdW50KSBvcHRpb25zLnVubW91bnQodm5vZGUpO1xuXG5cdGlmICgociA9IHZub2RlLnJlZikpIHtcblx0XHRpZiAoIXIuY3VycmVudCB8fCByLmN1cnJlbnQgPT09IHZub2RlLl9kb20pIHtcblx0XHRcdGFwcGx5UmVmKHIsIG51bGwsIHBhcmVudFZOb2RlKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY29tcG9uZW50KSAhPSBudWxsKSB7XG5cdFx0aWYgKHIuY29tcG9uZW50V2lsbFVubW91bnQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHIuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBwYXJlbnRWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ci5iYXNlID0gci5fcGFyZW50RG9tID0gbnVsbDtcblx0XHR2bm9kZS5fY29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKChyID0gdm5vZGUuX2NoaWxkcmVuKSkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHJbaV0pIHtcblx0XHRcdFx0dW5tb3VudChcblx0XHRcdFx0XHRyW2ldLFxuXHRcdFx0XHRcdHBhcmVudFZOb2RlLFxuXHRcdFx0XHRcdHNraXBSZW1vdmUgfHwgdHlwZW9mIHZub2RlLnR5cGUgIT09ICdmdW5jdGlvbidcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIXNraXBSZW1vdmUgJiYgdm5vZGUuX2RvbSAhPSBudWxsKSB7XG5cdFx0cmVtb3ZlTm9kZSh2bm9kZS5fZG9tKTtcblx0fVxuXG5cdC8vIE11c3QgYmUgc2V0IHRvIGB1bmRlZmluZWRgIHRvIHByb3Blcmx5IGNsZWFuIHVwIGBfbmV4dERvbWBcblx0Ly8gZm9yIHdoaWNoIGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlLiBTZWUgY29tbWVudCBpbiBgY3JlYXRlLWVsZW1lbnQuanNgXG5cdHZub2RlLl9wYXJlbnQgPSB2bm9kZS5fZG9tID0gdm5vZGUuX25leHREb20gPSB1bmRlZmluZWQ7XG59XG5cbi8qKiBUaGUgYC5yZW5kZXIoKWAgbWV0aG9kIGZvciBhIFBGQyBiYWNraW5nIGluc3RhbmNlLiAqL1xuZnVuY3Rpb24gZG9SZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KSB7XG5cdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KTtcbn1cbiIsImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNvbW1pdFJvb3QsIGRpZmYgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogUmVuZGVyIGEgUHJlYWN0IHZpcnR1YWwgbm9kZSBpbnRvIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHJlbmRlciBpbnRvXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnQgfCBvYmplY3R9IFtyZXBsYWNlTm9kZV0gT3B0aW9uYWw6IEF0dGVtcHQgdG8gcmUtdXNlIGFuXG4gKiBleGlzdGluZyBET00gdHJlZSByb290ZWQgYXQgYHJlcGxhY2VOb2RlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnREb20sIHJlcGxhY2VOb2RlKSB7XG5cdGlmIChvcHRpb25zLl9yb290KSBvcHRpb25zLl9yb290KHZub2RlLCBwYXJlbnREb20pO1xuXG5cdC8vIFdlIGFidXNlIHRoZSBgcmVwbGFjZU5vZGVgIHBhcmFtZXRlciBpbiBgaHlkcmF0ZSgpYCB0byBzaWduYWwgaWYgd2UgYXJlIGluXG5cdC8vIGh5ZHJhdGlvbiBtb2RlIG9yIG5vdCBieSBwYXNzaW5nIHRoZSBgaHlkcmF0ZWAgZnVuY3Rpb24gaW5zdGVhZCBvZiBhIERPTVxuXHQvLyBlbGVtZW50Li5cblx0bGV0IGlzSHlkcmF0aW5nID0gdHlwZW9mIHJlcGxhY2VOb2RlID09PSAnZnVuY3Rpb24nO1xuXG5cdC8vIFRvIGJlIGFibGUgdG8gc3VwcG9ydCBjYWxsaW5nIGByZW5kZXIoKWAgbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWVcblx0Ly8gRE9NIG5vZGUsIHdlIG5lZWQgdG8gb2J0YWluIGEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyB0cmVlLiBXZSBkb1xuXHQvLyB0aGlzIGJ5IGFzc2lnbmluZyBhIG5ldyBgX2NoaWxkcmVuYCBwcm9wZXJ0eSB0byBET00gbm9kZXMgd2hpY2ggcG9pbnRzXG5cdC8vIHRvIHRoZSBsYXN0IHJlbmRlcmVkIHRyZWUuIEJ5IGRlZmF1bHQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCwgd2hpY2hcblx0Ly8gbWVhbnMgdGhhdCB3ZSBhcmUgbW91bnRpbmcgYSBuZXcgdHJlZSBmb3IgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBvbGRWTm9kZSA9IGlzSHlkcmF0aW5nXG5cdFx0PyBudWxsXG5cdFx0OiAocmVwbGFjZU5vZGUgJiYgcmVwbGFjZU5vZGUuX2NoaWxkcmVuKSB8fCBwYXJlbnREb20uX2NoaWxkcmVuO1xuXG5cdHZub2RlID0gKFxuXHRcdCghaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGUpIHx8XG5cdFx0cGFyZW50RG9tXG5cdCkuX2NoaWxkcmVuID0gY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgW3Zub2RlXSk7XG5cblx0Ly8gTGlzdCBvZiBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXIgZGlmZmluZy5cblx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdGRpZmYoXG5cdFx0cGFyZW50RG9tLFxuXHRcdC8vIERldGVybWluZSB0aGUgbmV3IHZub2RlIHRyZWUgYW5kIHN0b3JlIGl0IG9uIHRoZSBET00gZWxlbWVudCBvblxuXHRcdC8vIG91ciBjdXN0b20gYF9jaGlsZHJlbmAgcHJvcGVydHkuXG5cdFx0dm5vZGUsXG5cdFx0b2xkVk5vZGUgfHwgRU1QVFlfT0JKLFxuXHRcdEVNUFRZX09CSixcblx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0IWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlXG5cdFx0XHQ/IFtyZXBsYWNlTm9kZV1cblx0XHRcdDogb2xkVk5vZGVcblx0XHRcdD8gbnVsbFxuXHRcdFx0OiBwYXJlbnREb20uZmlyc3RDaGlsZFxuXHRcdFx0PyBzbGljZS5jYWxsKHBhcmVudERvbS5jaGlsZE5vZGVzKVxuXHRcdFx0OiBudWxsLFxuXHRcdGNvbW1pdFF1ZXVlLFxuXHRcdCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZVxuXHRcdFx0PyByZXBsYWNlTm9kZVxuXHRcdFx0OiBvbGRWTm9kZVxuXHRcdFx0PyBvbGRWTm9kZS5fZG9tXG5cdFx0XHQ6IHBhcmVudERvbS5maXJzdENoaWxkLFxuXHRcdGlzSHlkcmF0aW5nXG5cdCk7XG5cblx0Ly8gRmx1c2ggYWxsIHF1ZXVlZCBlZmZlY3RzXG5cdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgRE9NIGVsZW1lbnQgd2l0aCBkYXRhIGZyb20gYSBQcmVhY3QgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHRvXG4gKiB1cGRhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudERvbSkge1xuXHRyZW5kZXIodm5vZGUsIHBhcmVudERvbSwgaHlkcmF0ZSk7XG59XG4iLCIvKipcbiAqIEZpbmQgdGhlIGNsb3Nlc3QgZXJyb3IgYm91bmRhcnkgdG8gYSB0aHJvd24gZXJyb3IgYW5kIGNhbGwgaXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBlcnJvciBUaGUgdGhyb3duIHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRoYXQgdGhyZXdcbiAqIHRoZSBlcnJvciB0aGF0IHdhcyBjYXVnaHQgKGV4Y2VwdCBmb3IgdW5tb3VudGluZyB3aGVuIHRoaXMgcGFyYW1ldGVyXG4gKiBpcyB0aGUgaGlnaGVzdCBwYXJlbnQgdGhhdCB3YXMgYmVpbmcgdW5tb3VudGVkKVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IFtvbGRWTm9kZV1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkVycm9ySW5mb30gW2Vycm9ySW5mb11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXRjaEVycm9yKGVycm9yLCB2bm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQsIGN0b3IsIGhhbmRsZWQ7XG5cblx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmICFjb21wb25lbnQuX3Byb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGN0b3IgPSBjb21wb25lbnQuY29uc3RydWN0b3I7XG5cblx0XHRcdFx0aWYgKGN0b3IgJiYgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5zZXRTdGF0ZShjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikpO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8gfHwge30pO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBhbiBlcnJvciBib3VuZGFyeS4gTWFyayBpdCBhcyBoYXZpbmcgYmFpbGVkIG91dCwgYW5kIHdoZXRoZXIgaXQgd2FzIG1pZC1oeWRyYXRpb24uXG5cdFx0XHRcdGlmIChoYW5kbGVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIChjb21wb25lbnQuX3BlbmRpbmdFcnJvciA9IGNvbXBvbmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRocm93IGVycm9yO1xufVxuIiwiaW1wb3J0IHsgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgncHJlYWN0JykuVk5vZGV9IFZOb2RlICovXG5cbmxldCB2bm9kZUlkID0gMDtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBUaGlzIGZpbGUgZXhwb3J0cyB2YXJpb3VzIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQmFiZWwncyBcImF1dG9tYXRpY1wiIEpTWCBydW50aW1lIEFQSTpcbiAqIC0ganN4KHR5cGUsIHByb3BzLCBrZXkpXG4gKiAtIGpzeHModHlwZSwgcHJvcHMsIGtleSlcbiAqIC0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIF9fc291cmNlLCBfX3NlbGYpXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIGNyZWF0ZVZOb2RlIGhlcmUgaXMgb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZS5cbiAqIEJlbmNobWFya3M6IGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWY2YjU0YTBiNDYzMjEwMGE3ZGNkMmIzXG4gKi9cblxuLyoqXG4gKiBKU1guRWxlbWVudCBmYWN0b3J5IHVzZWQgYnkgQmFiZWwncyB7cnVudGltZTpcImF1dG9tYXRpY1wifSBKU1ggdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1ZOb2RlWyd0eXBlJ119IHR5cGVcbiAqIEBwYXJhbSB7Vk5vZGVbJ3Byb3BzJ119IHByb3BzXG4gKiBAcGFyYW0ge1ZOb2RlWydrZXknXX0gW2tleV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbX19zZWxmXVxuICogQHBhcmFtIHtzdHJpbmd9IFtfX3NvdXJjZV1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgX19zZWxmLCBfX3NvdXJjZSkge1xuXHQvLyBXZSdsbCB3YW50IHRvIHByZXNlcnZlIGByZWZgIGluIHByb3BzIHRvIGdldCByaWQgb2YgdGhlIG5lZWQgZm9yXG5cdC8vIGZvcndhcmRSZWYgY29tcG9uZW50cyBpbiB0aGUgZnV0dXJlLCBidXQgdGhhdCBzaG91bGQgaGFwcGVuIHZpYVxuXHQvLyBhIHNlcGFyYXRlIFBSLlxuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge30sXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdyZWYnKSB7XG5cdFx0XHRyZWYgPSBwcm9wc1tpXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgdm5vZGUgPSB7XG5cdFx0dHlwZSxcblx0XHRwcm9wczogbm9ybWFsaXplZFByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdF9oeWRyYXRpbmc6IG51bGwsXG5cdFx0Y29uc3RydWN0b3I6IHVuZGVmaW5lZCxcblx0XHRfb3JpZ2luYWw6IC0tdm5vZGVJZCxcblx0XHRfX3NvdXJjZSxcblx0XHRfX3NlbGZcblx0fTtcblxuXHQvLyBJZiBhIENvbXBvbmVudCBWTm9kZSwgY2hlY2sgZm9yIGFuZCBhcHBseSBkZWZhdWx0UHJvcHMuXG5cdC8vIE5vdGU6IGB0eXBlYCBpcyBvZnRlbiBhIFN0cmluZywgYW5kIGNhbiBiZSBgdW5kZWZpbmVkYCBpbiBkZXZlbG9wbWVudC5cblx0aWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIChyZWYgPSB0eXBlLmRlZmF1bHRQcm9wcykpIHtcblx0XHRmb3IgKGkgaW4gcmVmKVxuXHRcdFx0aWYgKHR5cGVvZiBub3JtYWxpemVkUHJvcHNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHJlZltpXTtcblx0XHRcdH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnZub2RlKSBvcHRpb25zLnZub2RlKHZub2RlKTtcblx0cmV0dXJuIHZub2RlO1xufVxuXG5leHBvcnQge1xuXHRjcmVhdGVWTm9kZSBhcyBqc3gsXG5cdGNyZWF0ZVZOb2RlIGFzIGpzeHMsXG5cdGNyZWF0ZVZOb2RlIGFzIGpzeERFVixcblx0RnJhZ21lbnRcbn07XG4iLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEluZGV4O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBjdXJyZW50Q29tcG9uZW50O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBwcmV2aW91c0NvbXBvbmVudDtcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEhvb2sgPSAwO1xuXG4vKiogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59ICovXG5sZXQgYWZ0ZXJQYWludEVmZmVjdHMgPSBbXTtcblxubGV0IEVNUFRZID0gW107XG5cbmxldCBvbGRCZWZvcmVEaWZmID0gb3B0aW9ucy5fZGlmZjtcbmxldCBvbGRCZWZvcmVSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5sZXQgb2xkQWZ0ZXJEaWZmID0gb3B0aW9ucy5kaWZmZWQ7XG5sZXQgb2xkQ29tbWl0ID0gb3B0aW9ucy5fY29tbWl0O1xubGV0IG9sZEJlZm9yZVVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5cbmNvbnN0IFJBRl9USU1FT1VUID0gMTAwO1xubGV0IHByZXZSYWY7XG5cbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xuXHRpZiAob2xkQmVmb3JlRGlmZikgb2xkQmVmb3JlRGlmZih2bm9kZSk7XG59O1xuXG5vcHRpb25zLl9yZW5kZXIgPSB2bm9kZSA9PiB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIG9sZEJlZm9yZVJlbmRlcih2bm9kZSk7XG5cblx0Y3VycmVudENvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGN1cnJlbnRJbmRleCA9IDA7XG5cblx0Y29uc3QgaG9va3MgPSBjdXJyZW50Q29tcG9uZW50Ll9faG9va3M7XG5cdGlmIChob29rcykge1xuXHRcdGlmIChwcmV2aW91c0NvbXBvbmVudCA9PT0gY3VycmVudENvbXBvbmVudCkge1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGhvb2tzLl9saXN0LmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0XHRpZiAoaG9va0l0ZW0uX25leHRWYWx1ZSkge1xuXHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdH1cblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG59O1xuXG5vcHRpb25zLmRpZmZlZCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEFmdGVyRGlmZikgb2xkQWZ0ZXJEaWZmKHZub2RlKTtcblxuXHRjb25zdCBjID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGMgJiYgYy5fX2hvb2tzKSB7XG5cdFx0aWYgKGMuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMubGVuZ3RoKSBhZnRlclBhaW50KGFmdGVyUGFpbnRFZmZlY3RzLnB1c2goYykpO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ0FyZ3MpIHtcblx0XHRcdFx0aG9va0l0ZW0uX2FyZ3MgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3M7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSAhPT0gRU1QVFkpIHtcblx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZTtcblx0XHRcdH1cblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nQXJncyA9IHVuZGVmaW5lZDtcblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgPSBFTVBUWTtcblx0XHR9KTtcblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xufTtcblxub3B0aW9ucy5fY29tbWl0ID0gKHZub2RlLCBjb21taXRRdWV1ZSkgPT4ge1xuXHRjb21taXRRdWV1ZS5zb21lKGNvbXBvbmVudCA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZpbHRlcihjYiA9PlxuXHRcdFx0XHRjYi5fdmFsdWUgPyBpbnZva2VFZmZlY3QoY2IpIDogdHJ1ZVxuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzKSBjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdH0pO1xuXHRcdFx0Y29tbWl0UXVldWUgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAob2xkQ29tbWl0KSBvbGRDb21taXQodm5vZGUsIGNvbW1pdFF1ZXVlKTtcbn07XG5cbm9wdGlvbnMudW5tb3VudCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVVubW91bnQpIG9sZEJlZm9yZVVubW91bnQodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRsZXQgaGFzRXJyb3JlZDtcblx0XHRjLl9faG9va3MuX2xpc3QuZm9yRWFjaChzID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGludm9rZUNsZWFudXAocyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGhhc0Vycm9yZWQgPSBlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGMuX19ob29rcyA9IHVuZGVmaW5lZDtcblx0XHRpZiAoaGFzRXJyb3JlZCkgb3B0aW9ucy5fY2F0Y2hFcnJvcihoYXNFcnJvcmVkLCBjLl92bm9kZSk7XG5cdH1cbn07XG5cbi8qKlxuICogR2V0IGEgaG9vaydzIHN0YXRlIGZyb20gdGhlIGN1cnJlbnRDb21wb25lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBUaGUgaW5kZXggb2YgdGhlIGhvb2sgdG8gZ2V0XG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBnZXRIb29rU3RhdGUoaW5kZXgsIHR5cGUpIHtcblx0aWYgKG9wdGlvbnMuX2hvb2spIHtcblx0XHRvcHRpb25zLl9ob29rKGN1cnJlbnRDb21wb25lbnQsIGluZGV4LCBjdXJyZW50SG9vayB8fCB0eXBlKTtcblx0fVxuXHRjdXJyZW50SG9vayA9IDA7XG5cblx0Ly8gTGFyZ2VseSBpbnNwaXJlZCBieTpcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iL2Y2YmU3MzQ2OGU2ZWM0NmIwZmY1YWEzY2M0YzliYWY3MmEyOTAyNWEvc3JjL2hvb2tzL2NvcmVfaG9va3MubWpzXG5cdC8vICogaHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWwta2xlaW4vZnVuY3kuanMvYmxvYi82NTBiZWFhNThjNDNjMzNhNzQ4MjBhM2M5OGIzYzcwNzljZjJlMzMzL3NyYy9yZW5kZXJlci5tanNcblx0Ly8gT3RoZXIgaW1wbGVtZW50YXRpb25zIHRvIGxvb2sgYXQ6XG5cdC8vICogaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL21ub3gwNXFwOFxuXHRjb25zdCBob29rcyA9XG5cdFx0Y3VycmVudENvbXBvbmVudC5fX2hvb2tzIHx8XG5cdFx0KGN1cnJlbnRDb21wb25lbnQuX19ob29rcyA9IHtcblx0XHRcdF9saXN0OiBbXSxcblx0XHRcdF9wZW5kaW5nRWZmZWN0czogW11cblx0XHR9KTtcblxuXHRpZiAoaW5kZXggPj0gaG9va3MuX2xpc3QubGVuZ3RoKSB7XG5cdFx0aG9va3MuX2xpc3QucHVzaCh7IF9wZW5kaW5nVmFsdWU6IEVNUFRZIH0pO1xuXHR9XG5cdHJldHVybiBob29rcy5fbGlzdFtpbmRleF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gW2luaXRpYWxTdGF0ZV1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuXHRjdXJyZW50SG9vayA9IDE7XG5cdHJldHVybiB1c2VSZWR1Y2VyKGludm9rZU9yUmV0dXJuLCBpbml0aWFsU3RhdGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuUmVkdWNlcjxhbnksIGFueT59IHJlZHVjZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuU3RhdGVVcGRhdGVyPGFueT59IGluaXRpYWxTdGF0ZVxuICogQHBhcmFtIHsoaW5pdGlhbFN0YXRlOiBhbnkpID0+IHZvaWR9IFtpbml0XVxuICogQHJldHVybnMge1sgYW55LCAoc3RhdGU6IGFueSkgPT4gdm9pZCBdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsU3RhdGUsIGluaXQpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5SZWR1Y2VySG9va1N0YXRlfSAqL1xuXHRjb25zdCBob29rU3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDIpO1xuXHRob29rU3RhdGUuX3JlZHVjZXIgPSByZWR1Y2VyO1xuXHRpZiAoIWhvb2tTdGF0ZS5fY29tcG9uZW50KSB7XG5cdFx0aG9va1N0YXRlLl92YWx1ZSA9IFtcblx0XHRcdCFpbml0ID8gaW52b2tlT3JSZXR1cm4odW5kZWZpbmVkLCBpbml0aWFsU3RhdGUpIDogaW5pdChpbml0aWFsU3RhdGUpLFxuXG5cdFx0XHRhY3Rpb24gPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSBob29rU3RhdGUuX25leHRWYWx1ZVxuXHRcdFx0XHRcdD8gaG9va1N0YXRlLl9uZXh0VmFsdWVbMF1cblx0XHRcdFx0XHQ6IGhvb2tTdGF0ZS5fdmFsdWVbMF07XG5cdFx0XHRcdGNvbnN0IG5leHRWYWx1ZSA9IGhvb2tTdGF0ZS5fcmVkdWNlcihjdXJyZW50VmFsdWUsIGFjdGlvbik7XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va1N0YXRlLl9uZXh0VmFsdWUgPSBbbmV4dFZhbHVlLCBob29rU3RhdGUuX3ZhbHVlWzFdXTtcblx0XHRcdFx0XHRob29rU3RhdGUuX2NvbXBvbmVudC5zZXRTdGF0ZSh7fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdO1xuXG5cdFx0aG9va1N0YXRlLl9jb21wb25lbnQgPSBjdXJyZW50Q29tcG9uZW50O1xuXG5cdFx0aWYgKCFjdXJyZW50Q29tcG9uZW50Ll9oYXNTY3VGcm9tSG9va3MpIHtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX2hhc1NjdUZyb21Ib29rcyA9IHRydWU7XG5cdFx0XHRjb25zdCBwcmV2U2N1ID0gY3VycmVudENvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGU7XG5cblx0XHRcdC8vIFRoaXMgU0NVIGhhcyB0aGUgcHVycG9zZSBvZiBiYWlsaW5nIG91dCBhZnRlciByZXBlYXRlZCB1cGRhdGVzXG5cdFx0XHQvLyB0byBzdGF0ZWZ1bCBob29rcy5cblx0XHRcdC8vIHdlIHN0b3JlIHRoZSBuZXh0IHZhbHVlIGluIF9uZXh0VmFsdWVbMF0gYW5kIGtlZXAgZG9pbmcgdGhhdCBmb3IgYWxsXG5cdFx0XHQvLyBzdGF0ZSBzZXR0ZXJzLCBpZiB3ZSBoYXZlIG5leHQgc3RhdGVzIGFuZFxuXHRcdFx0Ly8gYWxsIG5leHQgc3RhdGVzIHdpdGhpbiBhIGNvbXBvbmVudCBlbmQgdXAgYmVpbmcgZXF1YWwgdG8gdGhlaXIgb3JpZ2luYWwgc3RhdGVcblx0XHRcdC8vIHdlIGFyZSBzYWZlIHRvIGJhaWwgb3V0IGZvciB0aGlzIHNwZWNpZmljIGNvbXBvbmVudC5cblx0XHRcdGN1cnJlbnRDb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24ocCwgcywgYykge1xuXHRcdFx0XHRpZiAoIWhvb2tTdGF0ZS5fY29tcG9uZW50Ll9faG9va3MpIHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdGNvbnN0IHN0YXRlSG9va3MgPSBob29rU3RhdGUuX2NvbXBvbmVudC5fX2hvb2tzLl9saXN0LmZpbHRlcihcblx0XHRcdFx0XHR4ID0+IHguX2NvbXBvbmVudFxuXHRcdFx0XHQpO1xuXHRcdFx0XHRjb25zdCBhbGxIb29rc0VtcHR5ID0gc3RhdGVIb29rcy5ldmVyeSh4ID0+ICF4Ll9uZXh0VmFsdWUpO1xuXHRcdFx0XHQvLyBXaGVuIHdlIGhhdmUgbm8gdXBkYXRlZCBob29rcyBpbiB0aGUgY29tcG9uZW50IHdlIGludm9rZSB0aGUgcHJldmlvdXMgU0NVIG9yXG5cdFx0XHRcdC8vIHRyYXZlcnNlIHRoZSBWRE9NIHRyZWUgZnVydGhlci5cblx0XHRcdFx0aWYgKGFsbEhvb2tzRW1wdHkpIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJldlNjdSA/IHByZXZTY3UuY2FsbCh0aGlzLCBwLCBzLCBjKSA6IHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSBjaGVjayB3aGV0aGVyIHdlIGhhdmUgY29tcG9uZW50cyB3aXRoIGEgbmV4dFZhbHVlIHNldCB0aGF0XG5cdFx0XHRcdC8vIGhhdmUgdmFsdWVzIHRoYXQgYXJlbid0IGVxdWFsIHRvIG9uZSBhbm90aGVyIHRoaXMgcHVzaGVzXG5cdFx0XHRcdC8vIHVzIHRvIHVwZGF0ZSBmdXJ0aGVyIGRvd24gdGhlIHRyZWVcblx0XHRcdFx0bGV0IHNob3VsZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0XHRzdGF0ZUhvb2tzLmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0XHRcdGlmIChob29rSXRlbS5fbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjdXJyZW50VmFsdWUgPSBob29rSXRlbS5fdmFsdWVbMF07XG5cdFx0XHRcdFx0XHRob29rSXRlbS5fdmFsdWUgPSBob29rSXRlbS5fbmV4dFZhbHVlO1xuXHRcdFx0XHRcdFx0aG9va0l0ZW0uX25leHRWYWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgIT09IGhvb2tJdGVtLl92YWx1ZVswXSkgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiBzaG91bGRVcGRhdGUgfHwgaG9va1N0YXRlLl9jb21wb25lbnQucHJvcHMgIT09IHBcblx0XHRcdFx0XHQ/IHByZXZTY3Vcblx0XHRcdFx0XHRcdD8gcHJldlNjdS5jYWxsKHRoaXMsIHAsIHMsIGMpXG5cdFx0XHRcdFx0XHQ6IHRydWVcblx0XHRcdFx0XHQ6IGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gaG9va1N0YXRlLl9uZXh0VmFsdWUgfHwgaG9va1N0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDMpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLnB1c2goc3RhdGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3R9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY2FsbGJhY2ssIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA0KTtcblx0aWYgKCFvcHRpb25zLl9za2lwRWZmZWN0cyAmJiBhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSBjYWxsYmFjaztcblx0XHRzdGF0ZS5fcGVuZGluZ0FyZ3MgPSBhcmdzO1xuXG5cdFx0Y3VycmVudENvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goc3RhdGUpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG5cdGN1cnJlbnRIb29rID0gNTtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gKHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH0pLCBbXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHJlZlxuICogQHBhcmFtIHsoKSA9PiBvYmplY3R9IGNyZWF0ZUhhbmRsZVxuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZUhhbmRsZSwgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDY7XG5cdHVzZUxheW91dEVmZmVjdChcblx0XHQoKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIHJlZiA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJlZihjcmVhdGVIYW5kbGUoKSk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiByZWYobnVsbCk7XG5cdFx0XHR9IGVsc2UgaWYgKHJlZikge1xuXHRcdFx0XHRyZWYuY3VycmVudCA9IGNyZWF0ZUhhbmRsZSgpO1xuXHRcdFx0XHRyZXR1cm4gKCkgPT4gKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhcmdzID09IG51bGwgPyBhcmdzIDogYXJncy5jb25jYXQocmVmKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmYWN0b3J5XG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW1vKGZhY3RvcnksIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5NZW1vSG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgNyk7XG5cdGlmIChhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fcGVuZGluZ1ZhbHVlID0gZmFjdG9yeSgpO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cdFx0c3RhdGUuX2ZhY3RvcnkgPSBmYWN0b3J5O1xuXHRcdHJldHVybiBzdGF0ZS5fcGVuZGluZ1ZhbHVlO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDg7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+IGNhbGxiYWNrLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdENvbnRleHR9IGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCkge1xuXHRjb25zdCBwcm92aWRlciA9IGN1cnJlbnRDb21wb25lbnQuY29udGV4dFtjb250ZXh0Ll9pZF07XG5cdC8vIFdlIGNvdWxkIHNraXAgdGhpcyBjYWxsIGhlcmUsIGJ1dCB0aGFuIHdlJ2Qgbm90IGNhbGxcblx0Ly8gYG9wdGlvbnMuX2hvb2tgLiBXZSBuZWVkIHRvIGRvIHRoYXQgaW4gb3JkZXIgdG8gbWFrZVxuXHQvLyB0aGUgZGV2dG9vbHMgYXdhcmUgb2YgdGhpcyBob29rLlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbnRleHRIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA5KTtcblx0Ly8gVGhlIGRldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3QgdG9cblx0Ly8gYmUgYWJsZSB0byBwdWxsIG9mIHRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gbm8gcHJvdmlkZXJcblx0Ly8gaXMgcHJlc2VudCBpbiB0aGUgdHJlZS5cblx0c3RhdGUuX2NvbnRleHQgPSBjb250ZXh0O1xuXHRpZiAoIXByb3ZpZGVyKSByZXR1cm4gY29udGV4dC5fZGVmYXVsdFZhbHVlO1xuXHQvLyBUaGlzIGlzIHByb2JhYmx5IG5vdCBzYWZlIHRvIGNvbnZlcnQgdG8gXCIhXCJcblx0aWYgKHN0YXRlLl92YWx1ZSA9PSBudWxsKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gdHJ1ZTtcblx0XHRwcm92aWRlci5zdWIoY3VycmVudENvbXBvbmVudCk7XG5cdH1cblx0cmV0dXJuIHByb3ZpZGVyLnByb3BzLnZhbHVlO1xufVxuXG4vKipcbiAqIERpc3BsYXkgYSBjdXN0b20gbGFiZWwgZm9yIGEgY3VzdG9tIGhvb2sgZm9yIHRoZSBkZXZ0b29scyBwYW5lbFxuICogQHR5cGUgezxUPih2YWx1ZTogVCwgY2I/OiAodmFsdWU6IFQpID0+IHN0cmluZyB8IG51bWJlcikgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlcikge1xuXHRpZiAob3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKSB7XG5cdFx0b3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKGZvcm1hdHRlciA/IGZvcm1hdHRlcih2YWx1ZSkgOiB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyhlcnJvcjogYW55LCBlcnJvckluZm86IGltcG9ydCgncHJlYWN0JykuRXJyb3JJbmZvKSA9PiB2b2lkfSBjYlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRXJyb3JCb3VuZGFyeShjYikge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVycm9yQm91bmRhcnlIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMCk7XG5cdGNvbnN0IGVyclN0YXRlID0gdXNlU3RhdGUoKTtcblx0c3RhdGUuX3ZhbHVlID0gY2I7XG5cdGlmICghY3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCkge1xuXHRcdGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2ggPSAoZXJyLCBlcnJvckluZm8pID0+IHtcblx0XHRcdGlmIChzdGF0ZS5fdmFsdWUpIHN0YXRlLl92YWx1ZShlcnIsIGVycm9ySW5mbyk7XG5cdFx0XHRlcnJTdGF0ZVsxXShlcnIpO1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIFtcblx0XHRlcnJTdGF0ZVswXSxcblx0XHQoKSA9PiB7XG5cdFx0XHRlcnJTdGF0ZVsxXSh1bmRlZmluZWQpO1xuXHRcdH1cblx0XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUlkKCkge1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMTEpO1xuXHRpZiAoIXN0YXRlLl92YWx1ZSkge1xuXHRcdC8vIEdyYWIgZWl0aGVyIHRoZSByb290IG5vZGUgb3IgdGhlIG5lYXJlc3QgYXN5bmMgYm91bmRhcnkgbm9kZS5cblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbC5kJykuVk5vZGV9ICovXG5cdFx0bGV0IHJvb3QgPSBjdXJyZW50Q29tcG9uZW50Ll92bm9kZTtcblx0XHR3aGlsZSAocm9vdCAhPT0gbnVsbCAmJiAhcm9vdC5fbWFzayAmJiByb290Ll9wYXJlbnQgIT09IG51bGwpIHtcblx0XHRcdHJvb3QgPSByb290Ll9wYXJlbnQ7XG5cdFx0fVxuXG5cdFx0bGV0IG1hc2sgPSByb290Ll9tYXNrIHx8IChyb290Ll9tYXNrID0gWzAsIDBdKTtcblx0XHRzdGF0ZS5fdmFsdWUgPSAnUCcgKyBtYXNrWzBdICsgJy0nICsgbWFza1sxXSsrO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlLl92YWx1ZTtcbn1cbi8qKlxuICogQWZ0ZXIgcGFpbnQgZWZmZWN0cyBjb25zdW1lci5cbiAqL1xuZnVuY3Rpb24gZmx1c2hBZnRlclBhaW50RWZmZWN0cygpIHtcblx0bGV0IGNvbXBvbmVudDtcblx0d2hpbGUgKChjb21wb25lbnQgPSBhZnRlclBhaW50RWZmZWN0cy5zaGlmdCgpKSkge1xuXHRcdGlmICghY29tcG9uZW50Ll9wYXJlbnREb20gfHwgIWNvbXBvbmVudC5fX2hvb2tzKSBjb250aW51ZTtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VFZmZlY3QpO1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGNvbXBvbmVudC5fdm5vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5sZXQgSEFTX1JBRiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT0gJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBTY2hlZHVsZSBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGJyb3dzZXIgaGFzIGEgY2hhbmNlIHRvIHBhaW50IGEgbmV3IGZyYW1lLlxuICogRG8gdGhpcyBieSBjb21iaW5pbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChyQUYpICsgc2V0VGltZW91dCB0byBpbnZva2UgYSBjYWxsYmFjayBhZnRlclxuICogdGhlIG5leHQgYnJvd3NlciBmcmFtZS5cbiAqXG4gKiBBbHNvLCBzY2hlZHVsZSBhIHRpbWVvdXQgaW4gcGFyYWxsZWwgdG8gdGhlIHRoZSByQUYgdG8gZW5zdXJlIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkXG4gKiBldmVuIGlmIFJBRiBkb2Vzbid0IGZpcmUgKGZvciBleGFtcGxlIGlmIHRoZSBicm93c2VyIHRhYiBpcyBub3QgdmlzaWJsZSlcbiAqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGFmdGVyTmV4dEZyYW1lKGNhbGxiYWNrKSB7XG5cdGNvbnN0IGRvbmUgPSAoKSA9PiB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdGlmIChIQVNfUkFGKSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuXHRcdHNldFRpbWVvdXQoY2FsbGJhY2spO1xuXHR9O1xuXHRjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChkb25lLCBSQUZfVElNRU9VVCk7XG5cblx0bGV0IHJhZjtcblx0aWYgKEhBU19SQUYpIHtcblx0XHRyYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZG9uZSk7XG5cdH1cbn1cblxuLy8gTm90ZTogaWYgc29tZW9uZSB1c2VkIG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4vLyB0aGVuIGVmZmVjdHMgd2lsbCBBTFdBWVMgcnVuIG9uIHRoZSBORVhUIGZyYW1lIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgb25lLCBpbmN1cnJpbmcgYSB+MTZtcyBkZWxheS5cbi8vIFBlcmhhcHMgdGhpcyBpcyBub3Qgc3VjaCBhIGJpZyBkZWFsLlxuLyoqXG4gKiBTY2hlZHVsZSBhZnRlclBhaW50RWZmZWN0cyBmbHVzaCBhZnRlciB0aGUgYnJvd3NlciBwYWludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdRdWV1ZUxlbmd0aFxuICovXG5mdW5jdGlvbiBhZnRlclBhaW50KG5ld1F1ZXVlTGVuZ3RoKSB7XG5cdGlmIChuZXdRdWV1ZUxlbmd0aCA9PT0gMSB8fCBwcmV2UmFmICE9PSBvcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdHByZXZSYWYgPSBvcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHQocHJldlJhZiB8fCBhZnRlck5leHRGcmFtZSkoZmx1c2hBZnRlclBhaW50RWZmZWN0cyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VDbGVhbnVwKGhvb2spIHtcblx0Ly8gQSBob29rIGNsZWFudXAgY2FuIGludHJvZHVjZSBhIGNhbGwgdG8gcmVuZGVyIHdoaWNoIGNyZWF0ZXMgYSBuZXcgcm9vdCwgdGhpcyB3aWxsIGNhbGwgb3B0aW9ucy52bm9kZVxuXHQvLyBhbmQgbW92ZSB0aGUgY3VycmVudENvbXBvbmVudCBhd2F5LlxuXHRjb25zdCBjb21wID0gY3VycmVudENvbXBvbmVudDtcblx0bGV0IGNsZWFudXAgPSBob29rLl9jbGVhbnVwO1xuXHRpZiAodHlwZW9mIGNsZWFudXAgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdGhvb2suX2NsZWFudXAgPSB1bmRlZmluZWQ7XG5cdFx0Y2xlYW51cCgpO1xuXHR9XG5cblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogSW52b2tlIGEgSG9vaydzIGVmZmVjdFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9IGhvb2tcbiAqL1xuZnVuY3Rpb24gaW52b2tlRWZmZWN0KGhvb2spIHtcblx0Ly8gQSBob29rIGNhbGwgY2FuIGludHJvZHVjZSBhIGNhbGwgdG8gcmVuZGVyIHdoaWNoIGNyZWF0ZXMgYSBuZXcgcm9vdCwgdGhpcyB3aWxsIGNhbGwgb3B0aW9ucy52bm9kZVxuXHQvLyBhbmQgbW92ZSB0aGUgY3VycmVudENvbXBvbmVudCBhd2F5LlxuXHRjb25zdCBjb21wID0gY3VycmVudENvbXBvbmVudDtcblx0aG9vay5fY2xlYW51cCA9IGhvb2suX3ZhbHVlKCk7XG5cdGN1cnJlbnRDb21wb25lbnQgPSBjb21wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55W119IG9sZEFyZ3NcbiAqIEBwYXJhbSB7YW55W119IG5ld0FyZ3NcbiAqL1xuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncywgbmV3QXJncykge1xuXHRyZXR1cm4gKFxuXHRcdCFvbGRBcmdzIHx8XG5cdFx0b2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3MubGVuZ3RoIHx8XG5cdFx0bmV3QXJncy5zb21lKChhcmcsIGluZGV4KSA9PiBhcmcgIT09IG9sZEFyZ3NbaW5kZXhdKVxuXHQpO1xufVxuXG5mdW5jdGlvbiBpbnZva2VPclJldHVybihhcmcsIGYpIHtcblx0cmV0dXJuIHR5cGVvZiBmID09ICdmdW5jdGlvbicgPyBmKGFyZykgOiBmO1xufVxuIiwiLyoqXG4gKiBBc3NpZ24gcHJvcGVydGllcyBmcm9tIGBwcm9wc2AgdG8gYG9iamBcbiAqIEB0ZW1wbGF0ZSBPLCBQIFRoZSBvYmogYW5kIHByb3BzIHR5cGVzXG4gKiBAcGFyYW0ge099IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIHtQfSBwcm9wcyBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJucyB7TyAmIFB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byBvYmplY3RzIGhhdmUgYSBkaWZmZXJlbnQgc2hhcGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBhXG4gKiBAcGFyYW0ge29iamVjdH0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGFsbG93RGlmZmVycyhhLCBiKSB7XG5cdGZvciAobGV0IGkgaW4gYSkgaWYgKGkgIT09ICdfX3NvdXJjZScgJiYgIShpIGluIGIpKSByZXR1cm4gdHJ1ZTtcblx0Zm9yIChsZXQgaSBpbiBiKSBpZiAoaSAhPT0gJ19fc291cmNlJyAmJiBhW2ldICE9PSBiW2ldKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG5cdGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSB0aGUgc2FtZSB2YWx1ZVxuICogQHBhcmFtIHsqfSB4XG4gKiBAcGFyYW0geyp9IHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXMoeCwgeSkge1xuXHRyZXR1cm4gKHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSkgfHwgKHggIT09IHggJiYgeSAhPT0geSk7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0RpZmZlcnMgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIENvbXBvbmVudCBjbGFzcyB3aXRoIGEgcHJlZGVmaW5lZCBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCBpbXBsZW1lbnRhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwKSB7XG5cdHRoaXMucHJvcHMgPSBwO1xufVxuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG4vLyBTb21lIHRoaXJkLXBhcnR5IGxpYnJhcmllcyBjaGVjayBpZiB0aGlzIHByb3BlcnR5IGlzIHByZXNlbnRcblB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRyZXR1cm4gc2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgcHJvcHMpIHx8IHNoYWxsb3dEaWZmZXJzKHRoaXMuc3RhdGUsIHN0YXRlKTtcbn07XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBNZW1vaXplIGEgY29tcG9uZW50LCBzbyB0aGF0IGl0IG9ubHkgdXBkYXRlcyB3aGVuIHRoZSBwcm9wcyBhY3R1YWxseSBoYXZlXG4gKiBjaGFuZ2VkLiBUaGlzIHdhcyBwcmV2aW91c2x5IGtub3duIGFzIGBSZWFjdC5wdXJlYC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9IGMgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAqIEBwYXJhbSB7KHByZXY6IG9iamVjdCwgbmV4dDogb2JqZWN0KSA9PiBib29sZWFufSBbY29tcGFyZXJdIEN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtbyhjLCBjb21wYXJlcikge1xuXHRmdW5jdGlvbiBzaG91bGRVcGRhdGUobmV4dFByb3BzKSB7XG5cdFx0bGV0IHJlZiA9IHRoaXMucHJvcHMucmVmO1xuXHRcdGxldCB1cGRhdGVSZWYgPSByZWYgPT0gbmV4dFByb3BzLnJlZjtcblx0XHRpZiAoIXVwZGF0ZVJlZiAmJiByZWYpIHtcblx0XHRcdHJlZi5jYWxsID8gcmVmKG51bGwpIDogKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFjb21wYXJlcikge1xuXHRcdFx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICFjb21wYXJlcih0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8ICF1cGRhdGVSZWY7XG5cdH1cblxuXHRmdW5jdGlvbiBNZW1vZWQocHJvcHMpIHtcblx0XHR0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHNob3VsZFVwZGF0ZTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjLCBwcm9wcyk7XG5cdH1cblx0TWVtb2VkLmRpc3BsYXlOYW1lID0gJ01lbW8oJyArIChjLmRpc3BsYXlOYW1lIHx8IGMubmFtZSkgKyAnKSc7XG5cdE1lbW9lZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cdE1lbW9lZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIE1lbW9lZDtcbn1cbiIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxubGV0IG9sZERpZmZIb29rID0gb3B0aW9ucy5fZGlmZjtcbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGlmICh2bm9kZS50eXBlICYmIHZub2RlLnR5cGUuX2ZvcndhcmRlZCAmJiB2bm9kZS5yZWYpIHtcblx0XHR2bm9kZS5wcm9wcy5yZWYgPSB2bm9kZS5yZWY7XG5cdFx0dm5vZGUucmVmID0gbnVsbDtcblx0fVxuXHRpZiAob2xkRGlmZkhvb2spIG9sZERpZmZIb29rKHZub2RlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9GT1JXQVJEX1NZTUJPTCA9XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmXG5cdFx0U3ltYm9sLmZvciAmJlxuXHRcdFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykpIHx8XG5cdDB4ZjQ3O1xuXG4vKipcbiAqIFBhc3MgcmVmIGRvd24gdG8gYSBjaGlsZC4gVGhpcyBpcyBtYWlubHkgdXNlZCBpbiBsaWJyYXJpZXMgd2l0aCBIT0NzIHRoYXRcbiAqIHdyYXAgY29tcG9uZW50cy4gVXNpbmcgYGZvcndhcmRSZWZgIHRoZXJlIGlzIGFuIGVhc3kgd2F5IHRvIGdldCBhIHJlZmVyZW5jZVxuICogb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50IGluc3RlYWQgb2Ygb25lIG9mIHRoZSB3cmFwcGVyIGl0c2VsZi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuRm9yd2FyZEZufSBmblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZFJlZihmbikge1xuXHRmdW5jdGlvbiBGb3J3YXJkZWQocHJvcHMpIHtcblx0XHRsZXQgY2xvbmUgPSBhc3NpZ24oe30sIHByb3BzKTtcblx0XHRkZWxldGUgY2xvbmUucmVmO1xuXHRcdHJldHVybiBmbihjbG9uZSwgcHJvcHMucmVmIHx8IG51bGwpO1xuXHR9XG5cblx0Ly8gbW9ieC1yZWFjdCBjaGVja3MgZm9yIHRoaXMgYmVpbmcgcHJlc2VudFxuXHRGb3J3YXJkZWQuJCR0eXBlb2YgPSBSRUFDVF9GT1JXQVJEX1NZTUJPTDtcblx0Ly8gbW9ieC1yZWFjdCBoZWF2aWx5IHJlbGllcyBvbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuXHQvLyBJdCBleHBlY3RzIGFuIG9iamVjdCBoZXJlIHdpdGggYSBgcmVuZGVyYCBwcm9wZXJ0eSxcblx0Ly8gYW5kIHByb3RvdHlwZS5yZW5kZXIgd2lsbCBmYWlsLiBXaXRob3V0IHRoaXNcblx0Ly8gbW9ieC1yZWFjdCB0aHJvd3MuXG5cdEZvcndhcmRlZC5yZW5kZXIgPSBGb3J3YXJkZWQ7XG5cblx0Rm9yd2FyZGVkLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0gRm9yd2FyZGVkLl9mb3J3YXJkZWQgPSB0cnVlO1xuXHRGb3J3YXJkZWQuZGlzcGxheU5hbWUgPSAnRm9yd2FyZFJlZignICsgKGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUpICsgJyknO1xuXHRyZXR1cm4gRm9yd2FyZGVkO1xufVxuIiwiaW1wb3J0IHsgdG9DaGlsZEFycmF5IH0gZnJvbSAncHJlYWN0JztcblxuY29uc3QgbWFwRm4gPSAoY2hpbGRyZW4sIGZuKSA9PiB7XG5cdGlmIChjaGlsZHJlbiA9PSBudWxsKSByZXR1cm4gbnVsbDtcblx0cmV0dXJuIHRvQ2hpbGRBcnJheSh0b0NoaWxkQXJyYXkoY2hpbGRyZW4pLm1hcChmbikpO1xufTtcblxuLy8gVGhpcyBBUEkgaXMgY29tcGxldGVseSB1bm5lY2Vzc2FyeSBmb3IgUHJlYWN0LCBzbyBpdCdzIGJhc2ljYWxseSBwYXNzdGhyb3VnaC5cbmV4cG9ydCBjb25zdCBDaGlsZHJlbiA9IHtcblx0bWFwOiBtYXBGbixcblx0Zm9yRWFjaDogbWFwRm4sXG5cdGNvdW50KGNoaWxkcmVuKSB7XG5cdFx0cmV0dXJuIGNoaWxkcmVuID8gdG9DaGlsZEFycmF5KGNoaWxkcmVuKS5sZW5ndGggOiAwO1xuXHR9LFxuXHRvbmx5KGNoaWxkcmVuKSB7XG5cdFx0Y29uc3Qgbm9ybWFsaXplZCA9IHRvQ2hpbGRBcnJheShjaGlsZHJlbik7XG5cdFx0aWYgKG5vcm1hbGl6ZWQubGVuZ3RoICE9PSAxKSB0aHJvdyAnQ2hpbGRyZW4ub25seSc7XG5cdFx0cmV0dXJuIG5vcm1hbGl6ZWRbMF07XG5cdH0sXG5cdHRvQXJyYXk6IHRvQ2hpbGRBcnJheVxufTtcbiIsImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCwgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3Qgb2xkQ2F0Y2hFcnJvciA9IG9wdGlvbnMuX2NhdGNoRXJyb3I7XG5vcHRpb25zLl9jYXRjaEVycm9yID0gZnVuY3Rpb24oZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdGlmIChlcnJvci50aGVuKSB7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdFx0bGV0IGNvbXBvbmVudDtcblx0XHRsZXQgdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKSB7XG5cdFx0XHRcdGlmIChuZXdWTm9kZS5fZG9tID09IG51bGwpIHtcblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRG9uJ3QgY2FsbCBvbGRDYXRjaEVycm9yIGlmIHdlIGZvdW5kIGEgU3VzcGVuc2Vcblx0XHRcdFx0cmV0dXJuIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKGVycm9yLCBuZXdWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdG9sZENhdGNoRXJyb3IoZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKTtcbn07XG5cbmNvbnN0IG9sZFVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5vcHRpb25zLnVubW91bnQgPSBmdW5jdGlvbih2bm9kZSkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0Y29uc3QgY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQuX29uUmVzb2x2ZSkge1xuXHRcdGNvbXBvbmVudC5fb25SZXNvbHZlKCk7XG5cdH1cblxuXHQvLyBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIGh5ZHJhdGluZ1xuXHQvLyBtb3N0IGxpa2VseSBpdCBpcyBiZWNhdXNlIHRoZSBjb21wb25lbnQgaXMgc3VzcGVuZGVkXG5cdC8vIHdlIHNldCB0aGUgdm5vZGUudHlwZSBhcyBgbnVsbGAgc28gdGhhdCBpdCBpcyBub3QgYSB0eXBlb2YgZnVuY3Rpb25cblx0Ly8gc28gdGhlIHVubW91bnQgd2lsbCByZW1vdmUgdGhlIHZub2RlLl9kb21cblx0aWYgKGNvbXBvbmVudCAmJiB2bm9kZS5faHlkcmF0aW5nID09PSB0cnVlKSB7XG5cdFx0dm5vZGUudHlwZSA9IG51bGw7XG5cdH1cblxuXHRpZiAob2xkVW5tb3VudCkgb2xkVW5tb3VudCh2bm9kZSk7XG59O1xuXG5mdW5jdGlvbiBkZXRhY2hlZENsb25lKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgcGFyZW50RG9tKSB7XG5cdGlmICh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICYmIHZub2RlLl9jb21wb25lbnQuX19ob29rcykge1xuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzLl9saXN0LmZvckVhY2goZWZmZWN0ID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiBlZmZlY3QuX2NsZWFudXAgPT0gJ2Z1bmN0aW9uJykgZWZmZWN0Ll9jbGVhbnVwKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzID0gbnVsbDtcblx0XHR9XG5cblx0XHR2bm9kZSA9IGFzc2lnbih7fSwgdm5vZGUpO1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IHBhcmVudERvbSkge1xuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPSBkZXRhY2hlZFBhcmVudDtcblx0XHRcdH1cblx0XHRcdHZub2RlLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdHZub2RlLl9jaGlsZHJlbiA9XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4gJiZcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5tYXAoY2hpbGQgPT5cblx0XHRcdFx0ZGV0YWNoZWRDbG9uZShjaGlsZCwgZGV0YWNoZWRQYXJlbnQsIHBhcmVudERvbSlcblx0XHRcdCk7XG5cdH1cblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU9yaWdpbmFsKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0dm5vZGUuX29yaWdpbmFsID0gbnVsbDtcblx0XHR2bm9kZS5fY2hpbGRyZW4gPVxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuICYmXG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4ubWFwKGNoaWxkID0+XG5cdFx0XHRcdHJlbW92ZU9yaWdpbmFsKGNoaWxkLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpXG5cdFx0XHQpO1xuXG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IGRldGFjaGVkUGFyZW50KSB7XG5cdFx0XHRcdGlmICh2bm9kZS5fZG9tKSB7XG5cdFx0XHRcdFx0b3JpZ2luYWxQYXJlbnQuaW5zZXJ0QmVmb3JlKHZub2RlLl9kb20sIHZub2RlLl9uZXh0RG9tKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9mb3JjZSA9IHRydWU7XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9IG9yaWdpbmFsUGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuLy8gaGF2aW5nIGN1c3RvbSBpbmhlcml0YW5jZSBpbnN0ZWFkIG9mIGEgY2xhc3MgaGVyZSBzYXZlcyBhIGxvdCBvZiBieXRlc1xuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlKCkge1xuXHQvLyB3ZSBkbyBub3QgY2FsbCBzdXBlciBoZXJlIHRvIGdvbGYgc29tZSBieXRlcy4uLlxuXHR0aGlzLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50ID0gMDtcblx0dGhpcy5fc3VzcGVuZGVycyA9IG51bGw7XG5cdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG59XG5cbi8vIFRoaW5ncyB3ZSBkbyBoZXJlIHRvIHNhdmUgc29tZSBieXRlcyBidXQgYXJlIG5vdCBwcm9wZXIgSlMgaW5oZXJpdGFuY2U6XG4vLyAtIGNhbGwgYG5ldyBDb21wb25lbnQoKWAgYXMgdGhlIHByb3RvdHlwZVxuLy8gLSBkbyBub3Qgc2V0IGBTdXNwZW5zZS5wcm90b3R5cGUuY29uc3RydWN0b3JgIHRvIGBTdXNwZW5zZWBcblN1c3BlbnNlLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9XG4gKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2UgVGhlIHRocm93biBwcm9taXNlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlPGFueSwgYW55Pn0gc3VzcGVuZGluZ1ZOb2RlIFRoZSBzdXNwZW5kaW5nIGNvbXBvbmVudFxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUuX2NoaWxkRGlkU3VzcGVuZCA9IGZ1bmN0aW9uKHByb21pc2UsIHN1c3BlbmRpbmdWTm9kZSkge1xuXHRjb25zdCBzdXNwZW5kaW5nQ29tcG9uZW50ID0gc3VzcGVuZGluZ1ZOb2RlLl9jb21wb25lbnQ7XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH0gKi9cblx0Y29uc3QgYyA9IHRoaXM7XG5cblx0aWYgKGMuX3N1c3BlbmRlcnMgPT0gbnVsbCkge1xuXHRcdGMuX3N1c3BlbmRlcnMgPSBbXTtcblx0fVxuXHRjLl9zdXNwZW5kZXJzLnB1c2goc3VzcGVuZGluZ0NvbXBvbmVudCk7XG5cblx0Y29uc3QgcmVzb2x2ZSA9IHN1c3BlbmRlZChjLl92bm9kZSk7XG5cblx0bGV0IHJlc29sdmVkID0gZmFsc2U7XG5cdGNvbnN0IG9uUmVzb2x2ZWQgPSAoKSA9PiB7XG5cdFx0aWYgKHJlc29sdmVkKSByZXR1cm47XG5cblx0XHRyZXNvbHZlZCA9IHRydWU7XG5cdFx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gbnVsbDtcblxuXHRcdGlmIChyZXNvbHZlKSB7XG5cdFx0XHRyZXNvbHZlKG9uU3VzcGVuc2lvbkNvbXBsZXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b25TdXNwZW5zaW9uQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gb25SZXNvbHZlZDtcblxuXHRjb25zdCBvblN1c3BlbnNpb25Db21wbGV0ZSA9ICgpID0+IHtcblx0XHRpZiAoIS0tYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCkge1xuXHRcdFx0Ly8gSWYgdGhlIHN1c3BlbnNpb24gd2FzIGR1cmluZyBoeWRyYXRpb24gd2UgZG9uJ3QgbmVlZCB0byByZXN0b3JlIHRoZVxuXHRcdFx0Ly8gc3VzcGVuZGVkIGNoaWxkcmVuIGludG8gdGhlIF9jaGlsZHJlbiBhcnJheVxuXHRcdFx0aWYgKGMuc3RhdGUuX3N1c3BlbmRlZCkge1xuXHRcdFx0XHRjb25zdCBzdXNwZW5kZWRWTm9kZSA9IGMuc3RhdGUuX3N1c3BlbmRlZDtcblx0XHRcdFx0Yy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gcmVtb3ZlT3JpZ2luYWwoXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUsXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tLFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLl9jb21wb25lbnQuX29yaWdpbmFsUGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGMuc2V0U3RhdGUoeyBfc3VzcGVuZGVkOiAoYy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbCkgfSk7XG5cblx0XHRcdGxldCBzdXNwZW5kZWQ7XG5cdFx0XHR3aGlsZSAoKHN1c3BlbmRlZCA9IGMuX3N1c3BlbmRlcnMucG9wKCkpKSB7XG5cdFx0XHRcdHN1c3BlbmRlZC5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogV2UgZG8gbm90IHNldCBgc3VzcGVuZGVkOiB0cnVlYCBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2Ugd2Ugd2FudCB0aGUgYWN0dWFsIG1hcmt1cFxuXHQgKiB0byByZW1haW4gb24gc2NyZWVuIGFuZCBoeWRyYXRlIGl0IHdoZW4gdGhlIHN1c3BlbnNlIGFjdHVhbGx5IGdldHMgcmVzb2x2ZWQuXG5cdCAqIFdoaWxlIGluIG5vbi1oeWRyYXRpb24gY2FzZXMgdGhlIHVzdWFsIGZhbGxiYWNrIC0+IGNvbXBvbmVudCBmbG93IHdvdWxkIG9jY291ci5cblx0ICovXG5cdGNvbnN0IHdhc0h5ZHJhdGluZyA9IHN1c3BlbmRpbmdWTm9kZS5faHlkcmF0aW5nID09PSB0cnVlO1xuXHRpZiAoIWMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQrKyAmJiAhd2FzSHlkcmF0aW5nKSB7XG5cdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBjLl92bm9kZS5fY2hpbGRyZW5bMF0pIH0pO1xuXHR9XG5cdHByb21pc2UudGhlbihvblJlc29sdmVkLCBvblJlc29sdmVkKTtcbn07XG5cblN1c3BlbnNlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gW107XG59O1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnRbXCJwcm9wc1wiXX0gcHJvcHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VTdGF0ZX0gc3RhdGVcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRpZiAodGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyKSB7XG5cdFx0Ly8gV2hlbiB0aGUgU3VzcGVuc2UncyBfdm5vZGUgd2FzIGNyZWF0ZWQgYnkgYSBjYWxsIHRvIGNyZWF0ZVZOb2RlXG5cdFx0Ly8gKGkuZS4gZHVlIHRvIGEgc2V0U3RhdGUgZnVydGhlciB1cCBpbiB0aGUgdHJlZSlcblx0XHQvLyBpdCdzIF9jaGlsZHJlbiBwcm9wIGlzIG51bGwsIGluIHRoaXMgY2FzZSB3ZSBcImZvcmdldFwiIGFib3V0IHRoZSBwYXJrZWQgdm5vZGVzIHRvIGRldGFjaFxuXHRcdGlmICh0aGlzLl92bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRcdGNvbnN0IGRldGFjaGVkUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRjb25zdCBkZXRhY2hlZENvbXBvbmVudCA9IHRoaXMuX3Zub2RlLl9jaGlsZHJlblswXS5fY29tcG9uZW50O1xuXHRcdFx0dGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gZGV0YWNoZWRDbG9uZShcblx0XHRcdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyLFxuXHRcdFx0XHRkZXRhY2hlZFBhcmVudCxcblx0XHRcdFx0KGRldGFjaGVkQ29tcG9uZW50Ll9vcmlnaW5hbFBhcmVudERvbSA9IGRldGFjaGVkQ29tcG9uZW50Ll9wYXJlbnREb20pXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG5cdH1cblxuXHQvLyBXcmFwIGZhbGxiYWNrIHRyZWUgaW4gYSBWTm9kZSB0aGF0IHByZXZlbnRzIGl0c2VsZiBmcm9tIGJlaW5nIG1hcmtlZCBhcyBhYm9ydGluZyBtaWQtaHlkcmF0aW9uOlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSAqL1xuXHRjb25zdCBmYWxsYmFjayA9XG5cdFx0c3RhdGUuX3N1c3BlbmRlZCAmJiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBwcm9wcy5mYWxsYmFjayk7XG5cdGlmIChmYWxsYmFjaykgZmFsbGJhY2suX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0cmV0dXJuIFtcblx0XHRjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBzdGF0ZS5fc3VzcGVuZGVkID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuKSxcblx0XHRmYWxsYmFja1xuXHRdO1xufTtcblxuLyoqXG4gKiBDaGVja3MgYW5kIGNhbGxzIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgX3N1c3BlbmRlZCBtZXRob2QsIHBhc3NpbmcgaW4gdGhlXG4gKiBzdXNwZW5kZWQgdm5vZGUuIFRoaXMgaXMgYSB3YXkgZm9yIGEgcGFyZW50IChlLmcuIFN1c3BlbnNlTGlzdCkgdG8gZ2V0IG5vdGlmaWVkXG4gKiB0aGF0IG9uZSBvZiBpdHMgY2hpbGRyZW4vZGVzY2VuZGFudHMgc3VzcGVuZGVkLlxuICpcbiAqIFRoZSBwYXJlbnQgTUFZIHJldHVybiBhIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgd2lsbCBnZXQgY2FsbGVkIHdoZW4gdGhlXG4gKiBzdXNwZW5zaW9uIHJlc29sdmVzLCBub3RpZnlpbmcgdGhlIHBhcmVudCBvZiB0aGUgZmFjdC5cbiAqIE1vcmVvdmVyLCB0aGUgY2FsbGJhY2sgZ2V0cyBmdW5jdGlvbiBgdW5zdXNwZW5kYCBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc29sdmVkXG4gKiBjaGlsZCBkZXNjZW5kYW50IHdpbGwgbm90IGFjdHVhbGx5IGdldCB1bnN1c3BlbmRlZCB1bnRpbCBgdW5zdXNwZW5kYCBnZXRzIGNhbGxlZC5cbiAqIFRoaXMgaXMgYSB3YXkgZm9yIHRoZSBwYXJlbnQgdG8gZGVsYXkgdW5zdXNwZW5kaW5nLlxuICpcbiAqIElmIHRoZSBwYXJlbnQgZG9lcyBub3QgcmV0dXJuIGEgY2FsbGJhY2sgdGhlbiB0aGUgcmVzb2x2ZWQgdm5vZGVcbiAqIGdldHMgdW5zdXNwZW5kZWQgaW1tZWRpYXRlbHkgd2hlbiBpdCByZXNvbHZlcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMgeygodW5zdXNwZW5kOiAoKSA9PiB2b2lkKSA9PiB2b2lkKT99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXNwZW5kZWQodm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQgPSB2bm9kZS5fcGFyZW50Ll9jb21wb25lbnQ7XG5cdHJldHVybiBjb21wb25lbnQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQodm5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGF6eShsb2FkZXIpIHtcblx0bGV0IHByb207XG5cdGxldCBjb21wb25lbnQ7XG5cdGxldCBlcnJvcjtcblxuXHRmdW5jdGlvbiBMYXp5KHByb3BzKSB7XG5cdFx0aWYgKCFwcm9tKSB7XG5cdFx0XHRwcm9tID0gbG9hZGVyKCk7XG5cdFx0XHRwcm9tLnRoZW4oXG5cdFx0XHRcdGV4cG9ydHMgPT4ge1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlID0+IHtcblx0XHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBvbmVudCkge1xuXHRcdFx0dGhyb3cgcHJvbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcblx0fVxuXG5cdExhenkuZGlzcGxheU5hbWUgPSAnTGF6eSc7XG5cdExhenkuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBMYXp5O1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc3VzcGVuZGVkIH0gZnJvbSAnLi9zdXNwZW5zZS5qcyc7XG5cbi8vIEluZGV4ZXMgdG8gbGlua2VkIGxpc3Qgbm9kZXMgKG5vZGVzIGFyZSBzdG9yZWQgYXMgYXJyYXlzIHRvIHNhdmUgYnl0ZXMpLlxuY29uc3QgU1VTUEVOREVEX0NPVU5UID0gMDtcbmNvbnN0IFJFU09MVkVEX0NPVU5UID0gMTtcbmNvbnN0IE5FWFRfTk9ERSA9IDI7XG5cbi8vIEhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXMuXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2VMaXN0KCkge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbnVsbDtcbn1cblxuLy8gTWFyayBvbmUgb2YgY2hpbGQncyBlYXJsaWVyIHN1c3BlbnNpb25zIGFzIHJlc29sdmVkLlxuLy8gU29tZSBwZW5kaW5nIGNhbGxiYWNrcyBtYXkgYmVjb21lIGNhbGxhYmxlIGR1ZSB0byB0aGlzXG4vLyAoZS5nLiB0aGUgbGFzdCBzdXNwZW5kZWQgZGVzY2VuZGFudCBnZXRzIHJlc29sdmVkIHdoZW5cbi8vIHJldmVhbE9yZGVyID09PSAndG9nZXRoZXInKS4gUHJvY2VzcyB0aG9zZSBjYWxsYmFja3MgYXMgd2VsbC5cbmNvbnN0IHJlc29sdmUgPSAobGlzdCwgY2hpbGQsIG5vZGUpID0+IHtcblx0aWYgKCsrbm9kZVtSRVNPTFZFRF9DT1VOVF0gPT09IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdC8vIFRoZSBudW1iZXIgYSBjaGlsZCAob3IgYW55IG9mIGl0cyBkZXNjZW5kYW50cykgaGFzIGJlZW4gc3VzcGVuZGVkXG5cdFx0Ly8gbWF0Y2hlcyB0aGUgbnVtYmVyIG9mIHRpbWVzIGl0J3MgYmVlbiByZXNvbHZlZC4gVGhlcmVmb3JlIHdlXG5cdFx0Ly8gbWFyayB0aGUgY2hpbGQgYXMgY29tcGxldGVseSByZXNvbHZlZCBieSBkZWxldGluZyBpdCBmcm9tIC5fbWFwLlxuXHRcdC8vIFRoaXMgaXMgdXNlZCB0byBmaWd1cmUgb3V0IHdoZW4gKmFsbCogY2hpbGRyZW4gaGF2ZSBiZWVuIGNvbXBsZXRlbHlcblx0XHQvLyByZXNvbHZlZCB3aGVuIHJldmVhbE9yZGVyIGlzICd0b2dldGhlcicuXG5cdFx0bGlzdC5fbWFwLmRlbGV0ZShjaGlsZCk7XG5cdH1cblxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyBmYWxzeSB0aGVuIHdlIGNhbiBkbyBhbiBlYXJseSBleGl0LCBhcyB0aGVcblx0Ly8gY2FsbGJhY2tzIHdvbid0IGdldCBxdWV1ZWQgaW4gdGhlIG5vZGUgYW55d2F5LlxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInIHRoZW4gYWxzbyBkbyBhbiBlYXJseSBleGl0XG5cdC8vIGlmIGFsbCBzdXNwZW5kZWQgZGVzY2VuZGFudHMgaGF2ZSBub3QgeWV0IGJlZW4gcmVzb2x2ZWQuXG5cdGlmIChcblx0XHQhbGlzdC5wcm9wcy5yZXZlYWxPcmRlciB8fFxuXHRcdChsaXN0LnByb3BzLnJldmVhbE9yZGVyWzBdID09PSAndCcgJiYgbGlzdC5fbWFwLnNpemUpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFdhbGsgdGhlIGN1cnJlbnRseSBzdXNwZW5kZWQgY2hpbGRyZW4gaW4gb3JkZXIsIGNhbGxpbmcgdGhlaXJcblx0Ly8gc3RvcmVkIGNhbGxiYWNrcyBvbiB0aGUgd2F5LiBTdG9wIGlmIHdlIGVuY291bnRlciBhIGNoaWxkIHRoYXRcblx0Ly8gaGFzIG5vdCBiZWVuIGNvbXBsZXRlbHkgcmVzb2x2ZWQgeWV0LlxuXHRub2RlID0gbGlzdC5fbmV4dDtcblx0d2hpbGUgKG5vZGUpIHtcblx0XHR3aGlsZSAobm9kZS5sZW5ndGggPiAzKSB7XG5cdFx0XHRub2RlLnBvcCgpKCk7XG5cdFx0fVxuXHRcdGlmIChub2RlW1JFU09MVkVEX0NPVU5UXSA8IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGxpc3QuX25leHQgPSBub2RlID0gbm9kZVtORVhUX05PREVdO1xuXHR9XG59O1xuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLl9zdXNwZW5kZWQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRjb25zdCBsaXN0ID0gdGhpcztcblx0Y29uc3QgZGVsZWdhdGVkID0gc3VzcGVuZGVkKGxpc3QuX3Zub2RlKTtcblxuXHRsZXQgbm9kZSA9IGxpc3QuX21hcC5nZXQoY2hpbGQpO1xuXHRub2RlW1NVU1BFTkRFRF9DT1VOVF0rKztcblxuXHRyZXR1cm4gdW5zdXNwZW5kID0+IHtcblx0XHRjb25zdCB3cmFwcGVkVW5zdXNwZW5kID0gKCkgPT4ge1xuXHRcdFx0aWYgKCFsaXN0LnByb3BzLnJldmVhbE9yZGVyKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0aGUgdW5kZWZpbmVkIChmYWxzeSkgcmV2ZWFsT3JkZXIsIGFzIHRoZXJlXG5cdFx0XHRcdC8vIGlzIG5vIG5lZWQgdG8gY29vcmRpbmF0ZSBhIHNwZWNpZmljIG9yZGVyIG9yIHVuc3VzcGVuZHMuXG5cdFx0XHRcdHVuc3VzcGVuZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5wdXNoKHVuc3VzcGVuZCk7XG5cdFx0XHRcdHJlc29sdmUobGlzdCwgY2hpbGQsIG5vZGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0aWYgKGRlbGVnYXRlZCkge1xuXHRcdFx0ZGVsZWdhdGVkKHdyYXBwZWRVbnN1c3BlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3cmFwcGVkVW5zdXNwZW5kKCk7XG5cdFx0fVxuXHR9O1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwcm9wcykge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuXG5cdGNvbnN0IGNoaWxkcmVuID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKTtcblx0aWYgKHByb3BzLnJldmVhbE9yZGVyICYmIHByb3BzLnJldmVhbE9yZGVyWzBdID09PSAnYicpIHtcblx0XHQvLyBJZiBvcmRlciA9PT0gJ2JhY2t3YXJkcycgKG9yLCB3ZWxsLCBhbnl0aGluZyBzdGFydGluZyB3aXRoIGEgJ2InKVxuXHRcdC8vIHRoZW4gZmxpcCB0aGUgY2hpbGQgbGlzdCBhcm91bmQgc28gdGhhdCB0aGUgbGFzdCBjaGlsZCB3aWxsIGJlXG5cdFx0Ly8gdGhlIGZpcnN0IGluIHRoZSBsaW5rZWQgbGlzdC5cblx0XHRjaGlsZHJlbi5yZXZlcnNlKCk7XG5cdH1cblx0Ly8gQnVpbGQgdGhlIGxpbmtlZCBsaXN0LiBJdGVyYXRlIHRocm91Z2ggdGhlIGNoaWxkcmVuIGluIHJldmVyc2Ugb3JkZXJcblx0Ly8gc28gdGhhdCBgX25leHRgIHBvaW50cyB0byB0aGUgZmlyc3QgbGlua2VkIGxpc3Qgbm9kZSB0byBiZSByZXNvbHZlZC5cblx0Zm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHQvLyBDcmVhdGUgYSBuZXcgbGlua2VkIGxpc3Qgbm9kZSBhcyBhbiBhcnJheSBvZiBmb3JtOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZV1cblx0XHQvLyB3aGVyZSBzdXNwZW5kZWRfY291bnQgYW5kIHJlc29sdmVkX2NvdW50IGFyZSBudW1lcmljIGNvdW50ZXJzIGZvclxuXHRcdC8vIGtlZXBpbmcgdHJhY2sgaG93IG1hbnkgdGltZXMgYSBub2RlIGhhcyBiZWVuIHN1c3BlbmRlZCBhbmQgcmVzb2x2ZWQuXG5cdFx0Ly9cblx0XHQvLyBOb3RlIHRoYXQgc3VzcGVuZGVkX2NvdW50IHN0YXJ0cyBmcm9tIDEgaW5zdGVhZCBvZiAwLCBzbyB3ZSBjYW4gYmxvY2tcblx0XHQvLyBwcm9jZXNzaW5nIGNhbGxiYWNrcyB1bnRpbCBjb21wb25lbnREaWRNb3VudCBoYXMgYmVlbiBjYWxsZWQuIEluIGEgc2Vuc2Vcblx0XHQvLyBub2RlIGlzIHN1c3BlbmRlZCBhdCBsZWFzdCB1bnRpbCBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZCFcblx0XHQvL1xuXHRcdC8vIFBlbmRpbmcgY2FsbGJhY2tzIGFyZSBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBub2RlOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZSwgY2FsbGJhY2tfMCwgY2FsbGJhY2tfMSwgLi4uXVxuXHRcdHRoaXMuX21hcC5zZXQoY2hpbGRyZW5baV0sICh0aGlzLl9uZXh0ID0gWzEsIDAsIHRoaXMuX25leHRdKSk7XG5cdH1cblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBTdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgY2hpbGRyZW4gYWZ0ZXIgbW91bnRpbmcgZm9yIHR3byByZWFzb25zOlxuXHQvLyAxLiBBcyBlYWNoIG5vZGVbU1VTUEVOREVEX0NPVU5UXSBzdGFydHMgZnJvbSAxLCB0aGlzIGl0ZXJhdGlvbiBpbmNyZWFzZXNcblx0Ly8gICAgZWFjaCBub2RlW1JFTEVBU0VEX0NPVU5UXSBieSAxLCB0aGVyZWZvcmUgYmFsYW5jaW5nIHRoZSBjb3VudGVycy5cblx0Ly8gICAgVGhlIG5vZGVzIGNhbiBub3cgYmUgY29tcGxldGVseSBjb25zdW1lZCBmcm9tIHRoZSBsaW5rZWQgbGlzdC5cblx0Ly8gMi4gSGFuZGxlIG5vZGVzIHRoYXQgbWlnaHQgaGF2ZSBnb3R0ZW4gcmVzb2x2ZWQgYmV0d2VlbiByZW5kZXIgYW5kXG5cdC8vICAgIGNvbXBvbmVudERpZE1vdW50LlxuXHR0aGlzLl9tYXAuZm9yRWFjaCgobm9kZSwgY2hpbGQpID0+IHtcblx0XHRyZXNvbHZlKHRoaXMsIGNoaWxkLCBub2RlKTtcblx0fSk7XG59O1xuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgcmVuZGVyIH0gZnJvbSAncHJlYWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vc3JjL2luZGV4JykuUmVuZGVyYWJsZVByb3BzPHsgY29udGV4dDogYW55IH0+fSBwcm9wc1xuICovXG5mdW5jdGlvbiBDb250ZXh0UHJvdmlkZXIocHJvcHMpIHtcblx0dGhpcy5nZXRDaGlsZENvbnRleHQgPSAoKSA9PiBwcm9wcy5jb250ZXh0O1xuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG5cbi8qKlxuICogUG9ydGFsIGNvbXBvbmVudFxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gcHJvcHNcbiAqXG4gKiBUT0RPOiB1c2UgY3JlYXRlUm9vdCgpIGluc3RlYWQgb2YgZmFrZSByb290XG4gKi9cbmZ1bmN0aW9uIFBvcnRhbChwcm9wcykge1xuXHRjb25zdCBfdGhpcyA9IHRoaXM7XG5cdGxldCBjb250YWluZXIgPSBwcm9wcy5fY29udGFpbmVyO1xuXG5cdF90aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmVuZGVyKG51bGwsIF90aGlzLl90ZW1wKTtcblx0XHRfdGhpcy5fdGVtcCA9IG51bGw7XG5cdFx0X3RoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdH07XG5cblx0Ly8gV2hlbiB3ZSBjaGFuZ2UgY29udGFpbmVyIHdlIHNob3VsZCBjbGVhciBvdXIgb2xkIGNvbnRhaW5lciBhbmRcblx0Ly8gaW5kaWNhdGUgYSBuZXcgbW91bnQuXG5cdGlmIChfdGhpcy5fY29udGFpbmVyICYmIF90aGlzLl9jb250YWluZXIgIT09IGNvbnRhaW5lcikge1xuXHRcdF90aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdH1cblxuXHQvLyBXaGVuIHByb3BzLnZub2RlIGlzIHVuZGVmaW5lZC9mYWxzZS9udWxsIHdlIGFyZSBkZWFsaW5nIHdpdGggc29tZSBraW5kIG9mXG5cdC8vIGNvbmRpdGlvbmFsIHZub2RlLiBUaGlzIHNob3VsZCBub3QgdHJpZ2dlciBhIHJlbmRlci5cblx0aWYgKHByb3BzLl92bm9kZSkge1xuXHRcdGlmICghX3RoaXMuX3RlbXApIHtcblx0XHRcdF90aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cblx0XHRcdC8vIENyZWF0ZSBhIGZha2UgRE9NIHBhcmVudCBub2RlIHRoYXQgbWFuYWdlcyBhIHN1YnNldCBvZiBgY29udGFpbmVyYCdzIGNoaWxkcmVuOlxuXHRcdFx0X3RoaXMuX3RlbXAgPSB7XG5cdFx0XHRcdG5vZGVUeXBlOiAxLFxuXHRcdFx0XHRwYXJlbnROb2RlOiBjb250YWluZXIsXG5cdFx0XHRcdGNoaWxkTm9kZXM6IFtdLFxuXHRcdFx0XHRhcHBlbmRDaGlsZChjaGlsZCkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0aW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmUpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlbW92ZUNoaWxkKGNoaWxkKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnNwbGljZSh0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihjaGlsZCkgPj4+IDEsIDEpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFJlbmRlciBvdXIgd3JhcHBpbmcgZWxlbWVudCBpbnRvIHRlbXAuXG5cdFx0cmVuZGVyKFxuXHRcdFx0Y3JlYXRlRWxlbWVudChDb250ZXh0UHJvdmlkZXIsIHsgY29udGV4dDogX3RoaXMuY29udGV4dCB9LCBwcm9wcy5fdm5vZGUpLFxuXHRcdFx0X3RoaXMuX3RlbXBcblx0XHQpO1xuXHR9XG5cdC8vIFdoZW4gd2UgY29tZSBmcm9tIGEgY29uZGl0aW9uYWwgcmVuZGVyLCBvbiBhIG1vdW50ZWRcblx0Ly8gcG9ydGFsIHdlIHNob3VsZCBjbGVhciB0aGUgRE9NLlxuXHRlbHNlIGlmIChfdGhpcy5fdGVtcCkge1xuXHRcdF90aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgUG9ydGFsYCB0byBjb250aW51ZSByZW5kZXJpbmcgdGhlIHZub2RlIHRyZWUgYXQgYSBkaWZmZXJlbnQgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2bm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gY29udGFpbmVyIFRoZSBET00gbm9kZSB0byBjb250aW51ZSByZW5kZXJpbmcgaW4gdG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQb3J0YWwodm5vZGUsIGNvbnRhaW5lcikge1xuXHRjb25zdCBlbCA9IGNyZWF0ZUVsZW1lbnQoUG9ydGFsLCB7IF92bm9kZTogdm5vZGUsIF9jb250YWluZXI6IGNvbnRhaW5lciB9KTtcblx0ZWwuY29udGFpbmVySW5mbyA9IGNvbnRhaW5lcjtcblx0cmV0dXJuIGVsO1xufVxuIiwiaW1wb3J0IHtcblx0cmVuZGVyIGFzIHByZWFjdFJlbmRlcixcblx0aHlkcmF0ZSBhcyBwcmVhY3RIeWRyYXRlLFxuXHRvcHRpb25zLFxuXHR0b0NoaWxkQXJyYXksXG5cdENvbXBvbmVudFxufSBmcm9tICdwcmVhY3QnO1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRUxFTUVOVF9UWVBFID1cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAmJiBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG5cdDB4ZWFjNztcblxuY29uc3QgQ0FNRUxfUFJPUFMgPSAvXig/OmFjY2VudHxhbGlnbm1lbnR8YXJhYmljfGJhc2VsaW5lfGNhcHxjbGlwKD8hUGF0aFUpfGNvbG9yfGRvbWluYW50fGZpbGx8Zmxvb2R8Zm9udHxnbHlwaCg/IVIpfGhvcml6fGltYWdlfGxldHRlcnxsaWdodGluZ3xtYXJrZXIoPyFIfFd8VSl8b3ZlcmxpbmV8cGFpbnR8cG9pbnRlcnxzaGFwZXxzdG9wfHN0cmlrZXRocm91Z2h8c3Ryb2tlfHRleHQoPyFMKXx0cmFuc2Zvcm18dW5kZXJsaW5lfHVuaWNvZGV8dW5pdHN8dnx2ZWN0b3J8dmVydHx3b3JkfHdyaXRpbmd8eCg/IUMpKVtBLVpdLztcblxuY29uc3QgSVNfRE9NID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLy8gSW5wdXQgdHlwZXMgZm9yIHdoaWNoIG9uY2hhbmdlIHNob3VsZCBub3QgYmUgY29udmVydGVkIHRvIG9uaW5wdXQuXG4vLyB0eXBlPVwiZmlsZXxjaGVja2JveHxyYWRpb1wiLCBwbHVzIFwicmFuZ2VcIiBpbiBJRTExLlxuLy8gKElFMTEgZG9lc24ndCBzdXBwb3J0IFN5bWJvbCwgd2hpY2ggd2UgdXNlIGhlcmUgdG8gdHVybiBgcmFkYCBpbnRvIGByYWAgd2hpY2ggbWF0Y2hlcyBcInJhbmdlXCIpXG5jb25zdCBvbkNoYW5nZUlucHV0VHlwZSA9IHR5cGUgPT5cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFN5bWJvbCgpID09ICdzeW1ib2wnXG5cdFx0PyAvZmlsfGNoZXxyYWQvaVxuXHRcdDogL2ZpbHxjaGV8cmEvaVxuXHQpLnRlc3QodHlwZSk7XG5cbi8vIFNvbWUgbGlicmFyaWVzIGxpa2UgYHJlYWN0LXZpcnR1YWxpemVkYCBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGlzLlxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8vIGBVTlNBRkVfKmAgbGlmZWN5Y2xlIGhvb2tzXG4vLyBQcmVhY3Qgb25seSBldmVyIGludm9rZXMgdGhlIHVucHJlZml4ZWQgbWV0aG9kcy5cbi8vIEhlcmUgd2UgcHJvdmlkZSBhIGJhc2UgXCJmYWxsYmFja1wiIGltcGxlbWVudGF0aW9uIHRoYXQgY2FsbHMgYW55IGRlZmluZWQgVU5TQUZFXyBwcmVmaXhlZCBtZXRob2QuXG4vLyAtIElmIGEgY29tcG9uZW50IGRlZmluZXMgaXRzIG93biBgY29tcG9uZW50RGlkTW91bnQoKWAgKGluY2x1ZGluZyB2aWEgZGVmaW5lUHJvcGVydHkpLCB1c2UgdGhhdC5cbi8vIC0gSWYgYSBjb21wb25lbnQgZGVmaW5lcyBgVU5TQUZFX2NvbXBvbmVudERpZE1vdW50KClgLCBgY29tcG9uZW50RGlkTW91bnRgIGlzIHRoZSBhbGlhcyBnZXR0ZXIvc2V0dGVyLlxuLy8gLSBJZiBhbnl0aGluZyBhc3NpZ25zIHRvIGFuIGBVTlNBRkVfKmAgcHJvcGVydHksIHRoZSBhc3NpZ25tZW50IGlzIGZvcndhcmRlZCB0byB0aGUgdW5wcmVmaXhlZCBwcm9wZXJ0eS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8xOTQxXG5bXG5cdCdjb21wb25lbnRXaWxsTW91bnQnLFxuXHQnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG5cdCdjb21wb25lbnRXaWxsVXBkYXRlJ1xuXS5mb3JFYWNoKGtleSA9PiB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBrZXksIHtcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0Z2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbJ1VOU0FGRV8nICsga2V5XTtcblx0XHR9LFxuXHRcdHNldCh2KSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB2XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufSk7XG5cbi8qKlxuICogUHJveHkgcmVuZGVyKCkgc2luY2UgUmVhY3QgcmV0dXJucyBhIENvbXBvbmVudCByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBWTm9kZSB0cmVlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnQgRE9NIG5vZGUgdG8gcmVuZGVyIHZub2RlIHRyZWUgaW50b1xuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50IHwgbnVsbH0gVGhlIHJvb3QgY29tcG9uZW50IHJlZmVyZW5jZSBvciBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0Ly8gUmVhY3QgZGVzdHJveXMgYW55IGV4aXN0aW5nIERPTSBub2Rlcywgc2VlICMxNzI3XG5cdC8vIC4uLmJ1dCBvbmx5IG9uIHRoZSBmaXJzdCByZW5kZXIsIHNlZSAjMTgyOFxuXHRpZiAocGFyZW50Ll9jaGlsZHJlbiA9PSBudWxsKSB7XG5cdFx0cGFyZW50LnRleHRDb250ZW50ID0gJyc7XG5cdH1cblxuXHRwcmVhY3RSZW5kZXIodm5vZGUsIHBhcmVudCk7XG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblxuXHRyZXR1cm4gdm5vZGUgPyB2bm9kZS5fY29tcG9uZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0cHJlYWN0SHlkcmF0ZSh2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5sZXQgb2xkRXZlbnRIb29rID0gb3B0aW9ucy5ldmVudDtcbm9wdGlvbnMuZXZlbnQgPSBlID0+IHtcblx0aWYgKG9sZEV2ZW50SG9vaykgZSA9IG9sZEV2ZW50SG9vayhlKTtcblx0ZS5wZXJzaXN0ID0gZW1wdHk7XG5cdGUuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBpc1Byb3BhZ2F0aW9uU3RvcHBlZDtcblx0ZS5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBpc0RlZmF1bHRQcmV2ZW50ZWQ7XG5cdHJldHVybiAoZS5uYXRpdmVFdmVudCA9IGUpO1xufTtcblxuZnVuY3Rpb24gZW1wdHkoKSB7fVxuXG5mdW5jdGlvbiBpc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHtcblx0cmV0dXJuIHRoaXMuY2FuY2VsQnViYmxlO1xufVxuXG5mdW5jdGlvbiBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG5cdHJldHVybiB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5cbmxldCBjbGFzc05hbWVEZXNjcmlwdG9yID0ge1xuXHRjb25maWd1cmFibGU6IHRydWUsXG5cdGdldCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzcztcblx0fVxufTtcblxubGV0IG9sZFZOb2RlSG9vayA9IG9wdGlvbnMudm5vZGU7XG5vcHRpb25zLnZub2RlID0gdm5vZGUgPT4ge1xuXHRsZXQgdHlwZSA9IHZub2RlLnR5cGU7XG5cdGxldCBwcm9wcyA9IHZub2RlLnByb3BzO1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0gcHJvcHM7XG5cblx0Ly8gb25seSBub3JtYWxpemUgcHJvcHMgb24gRWxlbWVudCBub2Rlc1xuXHRpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0Y29uc3Qgbm9uQ3VzdG9tRWxlbWVudCA9IHR5cGUuaW5kZXhPZignLScpID09PSAtMTtcblx0XHRub3JtYWxpemVkUHJvcHMgPSB7fTtcblxuXHRcdGZvciAobGV0IGkgaW4gcHJvcHMpIHtcblx0XHRcdGxldCB2YWx1ZSA9IHByb3BzW2ldO1xuXG5cdFx0XHRpZiAoSVNfRE9NICYmIGkgPT09ICdjaGlsZHJlbicgJiYgdHlwZSA9PT0gJ25vc2NyaXB0Jykge1xuXHRcdFx0XHQvLyBFbXVsYXRlIFJlYWN0J3MgYmVoYXZpb3Igb2Ygbm90IHJlbmRlcmluZyB0aGUgY29udGVudHMgb2Ygbm9zY3JpcHQgdGFncyBvbiB0aGUgY2xpZW50LlxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gJ3ZhbHVlJyAmJiAnZGVmYXVsdFZhbHVlJyBpbiBwcm9wcyAmJiB2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRcdC8vIFNraXAgYXBwbHlpbmcgdmFsdWUgaWYgaXQgaXMgbnVsbC91bmRlZmluZWQgYW5kIHdlIGFscmVhZHkgc2V0XG5cdFx0XHRcdC8vIGEgZGVmYXVsdCB2YWx1ZVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdGkgPT09ICdkZWZhdWx0VmFsdWUnICYmXG5cdFx0XHRcdCd2YWx1ZScgaW4gcHJvcHMgJiZcblx0XHRcdFx0cHJvcHMudmFsdWUgPT0gbnVsbFxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIGBkZWZhdWx0VmFsdWVgIGlzIHRyZWF0ZWQgYXMgYSBmYWxsYmFjayBgdmFsdWVgIHdoZW4gYSB2YWx1ZSBwcm9wIGlzIHByZXNlbnQgYnV0IG51bGwvdW5kZWZpbmVkLlxuXHRcdFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBmb3IgRWxlbWVudHMgd2l0aCBubyB2YWx1ZSBwcm9wIGlzIHRoZSBzYW1lIGFzIHRoZSBET00gZGVmYXVsdFZhbHVlIHByb3BlcnR5LlxuXHRcdFx0XHRpID0gJ3ZhbHVlJztcblx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gJ2Rvd25sb2FkJyAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHQvLyBDYWxsaW5nIGBzZXRBdHRyaWJ1dGVgIHdpdGggYSB0cnV0aHkgdmFsdWUgd2lsbCBsZWFkIHRvIGl0IGJlaW5nXG5cdFx0XHRcdC8vIHBhc3NlZCBhcyBhIHN0cmluZ2lmaWVkIHZhbHVlLCBlLmcuIGBkb3dubG9hZD1cInRydWVcImAuIFJlYWN0XG5cdFx0XHRcdC8vIGNvbnZlcnRzIGl0IHRvIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkLCBvdGhlcndpc2UgdGhlIGF0dHJpYnV0ZVxuXHRcdFx0XHQvLyB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGZpbGUgbmFtZSBhbmQgdGhlIGZpbGUgd2lsbCBiZSBjYWxsZWRcblx0XHRcdFx0Ly8gXCJ0cnVlXCIgdXBvbiBkb3dubG9hZGluZyBpdC5cblx0XHRcdFx0dmFsdWUgPSAnJztcblx0XHRcdH0gZWxzZSBpZiAoL29uZG91YmxlY2xpY2svaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25kYmxjbGljayc7XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHQvXm9uY2hhbmdlKHRleHRhcmVhfGlucHV0KS9pLnRlc3QoaSArIHR5cGUpICYmXG5cdFx0XHRcdCFvbkNoYW5nZUlucHV0VHlwZShwcm9wcy50eXBlKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGkgPSAnb25pbnB1dCc7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb25mb2N1cyQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25mb2N1c2luJztcblx0XHRcdH0gZWxzZSBpZiAoL15vbmJsdXIkL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gJ29uZm9jdXNvdXQnO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucHxDb21wbykvLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAobm9uQ3VzdG9tRWxlbWVudCAmJiBDQU1FTF9QUk9QUy50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnJlcGxhY2UoL1tBLVowLTldL2csICctJCYnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIG9uSW5wdXQgYW5kIG9uQ2hhbmdlLCBzZWUgIzM1NjFcblx0XHRcdC8vIGlmIHdlIGhhdmUgYW4gb25pbnB1dCBwcm9wIGFscmVhZHkgY2hhbmdlIGl0IHRvIG9uaW5wdXRDYXB0dXJlXG5cdFx0XHRpZiAoL15vbmlucHV0JC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSkge1xuXHRcdFx0XHRcdGkgPSAnb25pbnB1dENhcHR1cmUnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBzdXBwb3J0IGZvciBhcnJheSBzZWxlY3QgdmFsdWVzOiA8c2VsZWN0IG11bHRpcGxlIHZhbHVlPXtbXX0gLz5cblx0XHRpZiAoXG5cdFx0XHR0eXBlID09ICdzZWxlY3QnICYmXG5cdFx0XHRub3JtYWxpemVkUHJvcHMubXVsdGlwbGUgJiZcblx0XHRcdEFycmF5LmlzQXJyYXkobm9ybWFsaXplZFByb3BzLnZhbHVlKVxuXHRcdCkge1xuXHRcdFx0Ly8gZm9yRWFjaCgpIGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCwgd2hpY2ggd2UgYWJ1c2UgaGVyZSB0byB1bnNldCB0aGUgdmFsdWUgcHJvcC5cblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBBZGRpbmcgc3VwcG9ydCBmb3IgZGVmYXVsdFZhbHVlIGluIHNlbGVjdCB0YWdcblx0XHRpZiAodHlwZSA9PSAnc2VsZWN0JyAmJiBub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGlmIChub3JtYWxpemVkUHJvcHMubXVsdGlwbGUpIHtcblx0XHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUgPT0gY2hpbGQucHJvcHMudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZub2RlLnByb3BzID0gbm9ybWFsaXplZFByb3BzO1xuXG5cdFx0aWYgKHByb3BzLmNsYXNzICE9IHByb3BzLmNsYXNzTmFtZSkge1xuXHRcdFx0Y2xhc3NOYW1lRGVzY3JpcHRvci5lbnVtZXJhYmxlID0gJ2NsYXNzTmFtZScgaW4gcHJvcHM7XG5cdFx0XHRpZiAocHJvcHMuY2xhc3NOYW1lICE9IG51bGwpIG5vcm1hbGl6ZWRQcm9wcy5jbGFzcyA9IHByb3BzLmNsYXNzTmFtZTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxpemVkUHJvcHMsICdjbGFzc05hbWUnLCBjbGFzc05hbWVEZXNjcmlwdG9yKTtcblx0XHR9XG5cdH1cblxuXHR2bm9kZS4kJHR5cGVvZiA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXHRpZiAob2xkVk5vZGVIb29rKSBvbGRWTm9kZUhvb2sodm5vZGUpO1xufTtcblxuLy8gT25seSBuZWVkZWQgZm9yIHJlYWN0LXJlbGF5XG5sZXQgY3VycmVudENvbXBvbmVudDtcbmNvbnN0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbm9wdGlvbnMuX3JlbmRlciA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIHtcblx0XHRvbGRCZWZvcmVSZW5kZXIodm5vZGUpO1xuXHR9XG5cdGN1cnJlbnRDb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xufTtcblxuLy8gVGhpcyBpcyBhIHZlcnkgdmVyeSBwcml2YXRlIGludGVybmFsIGZ1bmN0aW9uIGZvciBSZWFjdCBpdFxuLy8gaXMgdXNlZCB0byBzb3J0LW9mIGRvIHJ1bnRpbWUgZGVwZW5kZW5jeSBpbmplY3Rpb24uIFNvIGZhclxuLy8gb25seSBgcmVhY3QtcmVsYXlgIG1ha2VzIHVzZSBvZiBpdC4gSXQgdXNlcyBpdCB0byByZWFkIHRoZVxuLy8gY29udGV4dCB2YWx1ZS5cbmV4cG9ydCBjb25zdCBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IHtcblx0UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjoge1xuXHRcdGN1cnJlbnQ6IHtcblx0XHRcdHJlYWRDb250ZXh0KGNvbnRleHQpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRDb21wb25lbnQuX2dsb2JhbENvbnRleHRbY29udGV4dC5faWRdLnByb3BzLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcbiIsImltcG9ydCB7IENvbXBvbmVudFR5cGUsIGgsIFJlZiB9IGZyb20gXCJwcmVhY3RcIjtcblxuZXhwb3J0IHR5cGUgUmVmRnJvbVRhZzxUIGV4dGVuZHMga2V5b2YgaC5KU1guSW50cmluc2ljRWxlbWVudHM+ID0gTm9uTnVsbGFibGU8aC5KU1guSW50cmluc2ljRWxlbWVudHNbVF1bXCJyZWZcIl0+ICYgUmVmPGFueT47XG5leHBvcnQgdHlwZSBFbGVtZW50RnJvbVJlZjxSIGV4dGVuZHMgUmVmPGFueT4+ID0gUiBleHRlbmRzIFJlZjxpbmZlciBFPiA/IEUgOiBFdmVudFRhcmdldDtcbmV4cG9ydCB0eXBlIEVsZW1lbnRGcm9tVGFnPFQgZXh0ZW5kcyBrZXlvZiBoLkpTWC5JbnRyaW5zaWNFbGVtZW50cz4gPSBFbGVtZW50RnJvbVJlZjxSZWZGcm9tVGFnPFQ+PjtcblxuZXhwb3J0IHR5cGUgRWxlbWVudFRvVGFnPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSAoa2V5b2YgU3ViVHlwZTxIVE1MRWxlbWVudFRhZ05hbWVNYXAsIEU+KTsvLyAmIChrZXlvZiBoLkpTWC5JbnRyaW5zaWNFbGVtZW50cyk7XG50eXBlIFN1YlR5cGU8QmFzZSwgQ29uZGl0aW9uPiA9IFBpY2s8QmFzZSwge1xuICAgIFtLZXkgaW4ga2V5b2YgQmFzZV06IEJhc2VbS2V5XSBleHRlbmRzIENvbmRpdGlvbiA/IEtleSA6IG5ldmVyXG59W2tleW9mIEJhc2VdPjtcblxuZXhwb3J0IHR5cGUgRGlzYWJsZWRUeXBlID0gYm9vbGVhbiB8IFwic29mdFwiIHwgXCJoYXJkXCI7XG5cbmV4cG9ydCB0eXBlIFByb3BzT2ZUeXBlPFQ+ID1cbiAgICBUIGV4dGVuZHMga2V5b2YgaC5KU1guSW50cmluc2ljRWxlbWVudHMgPyBoLkpTWC5JbnRyaW5zaWNFbGVtZW50c1tUXSA6IFxuICAgIFQgZXh0ZW5kcyBDb21wb25lbnRUeXBlPGluZmVyIFA+PyBQIDogbmV2ZXI7XG5cbi8qKlxuICogRm9yIHRpbWVzIHdoZW4gbW9yZSB0aGFuIGp1c3QgdGhlIGFic3RyYWN0IGVsZW1lbnQgdHlwZSBpcyBuZWVkZWQsXG4gKiBidXQgdGhlIGFjdHVhbCwgY29uY3JldGUsIGltcGxlbWVudGF0aW9uLWFmZmVjdGluZyBcImRpdlwiIHN0cmluZyB0eXBlLlxuICogXG4gKiBUT0RPOiBTaG91bGQgdGhpcyBiZSB0aGUgc3RhbmRhcmQgZm9yIGFsbCB0aGUgbm9uLUFSSUEgaG9va3M/XG4gKiBUaGV5ICpuZXZlciogY2FyZSBhYm91dCB0aGUgc3BlY2lmaWMgdHlwZSBmb3IgdGhlIGltcGxlbWVudGF0aW9uLFxuICoganVzdCBmb3IgdHlwaW5nLCBzbyBpdCB3b3VsZG4ndCBiZSBuZWNlc3NhcnksIFxuICogYnV0IGl0IHdvdWxkIGJlIGNvbnNpc3RlbnQgd2l0aCB0aGVzZSBBUklBIGhvb2tzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRhZ1NlbnNpdGl2ZVByb3BzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIHRhZzogRWxlbWVudFRvVGFnPEU+O1xufVxuXG5leHBvcnQgY29uc3QgRXZlbnREZXRhaWwgPSBTeW1ib2woXCJldmVudC1kZXRhaWxcIik7XG5leHBvcnQgdHlwZSBFdmVudERldGFpbCA9IHR5cGVvZiBFdmVudERldGFpbDtcbmV4cG9ydCB0eXBlIEVuaGFuY2VkRXZlbnQ8VGFyZ2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQsIFR5cGVkRXZlbnQgZXh0ZW5kcyBFdmVudCwgRGV0YWlsPiA9IGguSlNYLlRhcmdldGVkRXZlbnQ8VGFyZ2V0LCBUeXBlZEV2ZW50PiAmIHtcbiAgICBbRXZlbnREZXRhaWxdOiBEZXRhaWw7XG59O1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBlbmhhbmNlRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUeXBlZEV2ZW50IGV4dGVuZHMgRXZlbnQsIERldGFpbCBleHRlbmRzIG9iamVjdD4oZTogVHlwZWRFdmVudCB8IGguSlNYLlRhcmdldGVkRXZlbnQ8RSwgVHlwZWRFdmVudD4sIGRldGFpbDogRGV0YWlsKTogRW5oYW5jZWRFdmVudDxFLCBUeXBlZEV2ZW50LCBEZXRhaWw+IHtcbiAgICBjb25zdCBldmVudCA9IGUgYXMgdW5rbm93biBhcyBFbmhhbmNlZEV2ZW50PEUsIFR5cGVkRXZlbnQsIERldGFpbD47XG4gICAgZXZlbnRbRXZlbnREZXRhaWxdID0gZGV0YWlsO1xuICAgIHJldHVybiBldmVudDtcbn1cblxuXG5jb25zdCBhbHJlYWR5V2FybmVkID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBvdmVyd3JpdGVXaXRoV2FybmluZzxQIGV4dGVuZHMge30sIEsgZXh0ZW5kcyBrZXlvZiBQPihjb21wb25lbnROYW1lOiBzdHJpbmcsIHByb3BzOiBQLCBwcm9wTmFtZTogSywgbmV3VmFsdWU6IFBbS10pOiB2b2lkIHtcbiAgICAvL2NvbnN0IGtleSA9IGAke2NvbXBvbmVudE5hbWV9OyR7cHJvcE5hbWV9YDtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAob2xkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIWFscmVhZHlXYXJuZWQuaGFzKFN0cmluZyhwcm9wTmFtZSkpKSB7XG4gICAgICAgICAgICBhbHJlYWR5V2FybmVkLmFkZChTdHJpbmcocHJvcE5hbWUpKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhlICR7U3RyaW5nKHByb3BOYW1lKX0gYXR0cmlidXRlIG9uICR7Y29tcG9uZW50TmFtZX0gd2FzIGdpdmVuIGEgdmFsdWUgb2YgJHtvbGRWYWx1ZX0gYnV0IGlzIGJlaW5nIG92ZXJ3cml0dGVuIHRvICR7bmV3VmFsdWV9IGZvciBjb25mb3JtYW5jZS4gQ29uc2lkZXIgcmVtb3ZpbmcgaXQgYmVmb3JlIHBhc3NpbmcgdGhvc2UgcHJvcHMgdG8gJHtjb21wb25lbnROYW1lfS5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3BzW3Byb3BOYW1lXSA9IG5ld1ZhbHVlO1xufVxuXG5sZXQgZGVidWcgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBzZXREZWJ1Z0xvZ2dpbmcobG9nZ2luZzogYm9vbGVhbikge1xuICAgIGRlYnVnID0gbG9nZ2luZztcbn1cblxuZXhwb3J0IHR5cGUgRGVidWdMb2dUeXBlcyA9XG4gICAgXCJ1c2VBY2NvcmRpYW5cIiB8IFwidXNlQWNjb3JkaWFuU2VjdGlvblwiIHxcbiAgICBcInVzZUJ1dHRvblwiIHxcbiAgICBcInVzZUNoZWNrYm94XCIgfFxuICAgIFwidXNlQ2hlY2tib3hHcm91cFwiIHwgXCJ1c2VDaGVja2JveEdyb3VwUGFyZW50XCIgfCBcInVzZUNoZWNrYm94R3JvdXBDaGlsZFwiIHxcbiAgICBcInVzZURpYWxvZ1wiIHwgXCJ1c2VEcmF3ZXJcIiB8XG4gICAgXCJ1c2VMaXN0Ym94TXVsdGlcIiB8IFwidXNlTGlzdGJveE11bHRpSXRlbVwiIHxcbiAgICBcInVzZUxpc3Rib3hTaW5nbGVcIiB8IFwidXNlTGlzdGJveFNpbmdsZUl0ZW1cIiB8XG4gICAgXCJ1c2VNZW51YmFyXCIgfCBcInVzZU1lbnVcIiB8IFwidXNlTWVudVN1cmZhY2VcIiB8IFwidXNlTWVudUl0ZW1cIiB8IFwidXNlRm9jdXNTZW50aW5lbFwiIHwgXCJ1c2VNZW51U3VyZmFjZVNlbnRpbmVsXCIgfFxuICAgIFwidXNlUmFkaW9Hcm91cFwiIHwgXCJ1c2VSYWRpb1wiIHxcbiAgICBcInVzZVNsaWRlclwiIHwgXCJ1c2VTbGlkZXJUaHVtYlwiIHxcbiAgICBcInVzZVRhYmxlXCIgfCBcInVzZVRhYmxlUm93XCIgfCBcInVzZVRhYmxlQ2VsbFwiIHwgXCJ1c2VUYWJsZUJvZHlcIiB8XG4gICAgXCJ1c2VHcmlkbGlzdFwiIHwgXCJ1c2VHcmlkbGlzdFJvd1wiIHwgXCJ1c2VHcmlkbGlzdENoaWxkXCIgfCBcInVzZUdyaWRsaXN0U2VjdGlvblwiIHxcbiAgICBcInVzZVRhYnNcIiB8IFwidXNlVGFiTGlzdFwiIHwgXCJ1c2VUYWJcIiB8IFwidXNlVGFiUGFuZWxcIiB8XG4gICAgXCJ1c2VUb2FzdHNcIiB8IFwidXNlVG9hc3RcIiB8XG4gICAgXCJ1c2VUb29sdGlwXCIgfCBcInVzZVRvb2x0aXBUb29sdGlwXCIgfCBcInVzZVRvb2x0aXBUcmlnZ2VyXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1Z0xvZyh3aG86IERlYnVnTG9nVHlwZXMsIC4uLmFyZ3M6IFBhcmFtZXRlcnM8KHR5cGVvZiBjb25zb2xlKVtcImxvZ1wiXT4pIHtcbiAgICBpZiAoZGVidWcpXG4gICAgICAgIGNvbnNvbGUuZGVidWcod2hvICsgXCI6XCIsIC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgdHlwZSBQcm9wTW9kaWZpZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xuZXhwb3J0IHR5cGUgUHJvcE1vZGlmaWVyMjxQPiA9IChwcm9wczogUCkgPT4gUDtcbmV4cG9ydCBmdW5jdGlvbiBub29wKCk6IHZvaWQgeyByZXR1cm47IH1cblxuLy8gKFRoZXNlIGRvIG5vdCBuZWVkIHRvIGJlIHVuaXF1ZSlcbmV4cG9ydCBjb25zdCBQcmVmaWNlcyA9IHtcbiAgICBhY2NvcmRpb25TZWN0aW9uSGVhZGVyQnV0dG9uOiBcImFzaGItXCIsXG4gICAgYWNjb3JkaW9uU2VjdGlvbkJvZHk6IFwiYXNiLVwiLFxuICAgIGNoZWNrYm94TGlrZUlucHV0OiBcImNibGktXCIsXG4gICAgY2hlY2tib3hMaWtlTGFiZWw6IFwiY2JsbC1cIixcbiAgICBkaWFsb2c6IFwibWRsLVwiLFxuICAgIGRpYWxvZ1RpdGxlOiBcIm1kbHQtXCIsXG4gICAgZHJhd2VyOiBcIm1kdy1cIixcbiAgICBkcmF3ZXJUaXRsZTogXCJtZHd0LVwiLFxuICAgIGdyaWRsaXN0OiBcImdsLVwiLFxuICAgIGdyaWRsaXN0TGFiZWw6IFwiZ2xsLVwiLFxuICAgIGxpc3Rib3g6IFwibGItXCIsXG4gICAgbGlzdGJveExhYmVsOiBcImxibC1cIixcbiAgICBtZW51OiBcIm1lbnUtXCIsXG4gICAgcHJvZ3Jlc3NJbmRpY2F0b3I6IFwicGktXCIsXG4gICAgcHJvZ3Jlc3NMYWJlbDogXCJwbC1cIixcbiAgICByYWRpb0dyb3VwOiBcInJnLVwiLFxuICAgIHJhZGlvR3JvdXBMYWJlbDogXCJyZ2wtXCIsXG4gICAgcmFkaW86IFwicmItXCIsXG4gICAgcmFkaW9MYWJlbDogXCJyYmwtXCIsXG4gICAgc2xpZGVyVGh1bWI6IFwic3QtXCIsXG4gICAgdGFibGU6IFwidGItXCIsXG4gICAgdGFibGVMYWJlbDogXCJ0YmwtXCIsXG4gICAgdGFibGlzdDogXCJ0bC1cIixcbiAgICB0YWJsaXN0TGFiZWw6IFwidGxsLVwiLFxuICAgIHRvb2x0aXA6IFwidHQtXCJcbn0gYXMgY29uc3RcbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBSZW5kZXJhYmxlUHJvcHMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIG92ZXJ3cml0ZVdpdGhXYXJuaW5nIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5cbmNvbnN0IEhlYWRpbmdMZXZlbENvbnRleHQgPSBjcmVhdGVDb250ZXh0KDApO1xuXG5leHBvcnQgaW50ZXJmYWNlIEhlYWRpbmdQcm9wczxUIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBSZW5kZXJhYmxlUHJvcHM8aC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4+IHtcbiAgICAvKipcbiAgICAgKiBUaGUgY29udGVudHMgb2YgdGhlIGhlYWRpbmcuXG4gICAgICogXG4gICAgICogU2VwYXJhdGUgZnJvbSB0aGUgY2hpbGRyZW4sIHdoaWNoIGJlY29tZSB0aGUgY29udGVudCBkZXNjcmliZWQgYnkgdGhpcyBoZWFkaW5nLlxuICAgICAqL1xuICAgIGhlYWRpbmc6IENvbXBvbmVudENoaWxkcmVuO1xuXG4gICAgdGFnPzogRWxlbWVudFRvVGFnPFQ+O1xufVxuXG5leHBvcnQgY29uc3QgSGVhZGluZyA9IG1lbW8oZnVuY3Rpb24gSGVhZGluZzxUIGV4dGVuZHMgRWxlbWVudD4oeyBjaGlsZHJlbiwgaGVhZGluZywgdGFnLCAuLi5wcm9wcyB9OiBIZWFkaW5nUHJvcHM8VD4pIHtcbiAgICBjb25zdCBoZWFkaW5nTGV2ZWxCZWZvcmVVcyA9IHVzZUNvbnRleHQoSGVhZGluZ0xldmVsQ29udGV4dCk7XG4gICAgY29uc3QgbmV3SGVhZGluZ0xldmVsID0gaGVhZGluZ0xldmVsQmVmb3JlVXMgKyAxO1xuXG4gICAgaWYgKHRhZyA9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXdIZWFkaW5nTGV2ZWwgPD0gNikge1xuICAgICAgICAgICAgdGFnID0gYGgke25ld0hlYWRpbmdMZXZlbH1gIGFzIG5ldmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFnID0gJ2RpdicgYXMgbmV2ZXI7XG4gICAgICAgICAgICBvdmVyd3JpdGVXaXRoV2FybmluZyhcIkhlYWRpbmdcIiwgcHJvcHMsIFwiYXJpYS1sZXZlbFwiLCBgJHtuZXdIZWFkaW5nTGV2ZWx9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEhlYWRpbmdSZXNldCBuZXdMZXZlbD17aGVhZGluZ0xldmVsQmVmb3JlVXMgKyAxfT5cbiAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWcgYXMgYW55LCBwcm9wcywgaGVhZGluZyl9XG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgPC9IZWFkaW5nUmVzZXQ+XG4gICAgICAgIDwvPlxuICAgIClcbn0pXG5cbmV4cG9ydCBjb25zdCBIZWFkaW5nUmVzZXQgPSBtZW1vKGZ1bmN0aW9uIEhlYWRpbmdSZXNldCh7IG5ld0xldmVsLCBjaGlsZHJlbiB9OiB7IG5ld0xldmVsOiBudW1iZXIsIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbiB9KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPEhlYWRpbmdMZXZlbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e25ld0xldmVsfT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9IZWFkaW5nTGV2ZWxDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn0pXG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBvcHRpb25zIH0gZnJvbSBcInByZWFjdFwiXG5cbi8qKiBUYWtlcyBhIG5ldyB2YWx1ZSBvciBhIGZ1bmN0aW9uIHRoYXQgdXBkYXRlcyBhIHZhbHVlLCB1bmxpa2UgYE9uUGFzc2l2ZVN0YXRlQ2hhbmdlYCB3aGljaCByZWFjdHMgdG8gdGhvc2UgdXBkYXRlcyAqL1xuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTLCBSPiA9ICgodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUyksIHJlYXNvbj86IFIpID0+IHZvaWQpOy8vW1JdIGV4dGVuZHMgW25ldmVyXT8gKCh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSwgcmVhc29uPzogUikgPT4gdm9pZCkgOiAoKHZhbHVlOiBTIHwgKChwcmV2U3RhdGU6IFMgfCB1bmRlZmluZWQpID0+IFMpLCByZWFzb246IFIpID0+IHZvaWQpO1xuLyoqIFJlc3BvbmRzIHRvIGEgY2hhbmdlIGluIGEgdmFsdWUsIHVubGlrZSBgUGFzc2l2ZVN0YXRlVXBkYXRlcmAgd2hpY2ggY2F1c2VzIHRoZSB1cGRhdGVzICovXG5leHBvcnQgdHlwZSBPblBhc3NpdmVTdGF0ZUNoYW5nZTxTLCBSPiA9ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uPzogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTsvL1tSXSBleHRlbmRzIFtuZXZlcl0/ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uPzogUikgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKSA6ICgodmFsdWU6IFMsIHByZXZWYWx1ZTogUyB8IHVuZGVmaW5lZCwgcmVhc29uOiBSKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpO1xuXG5cblxuLyoqXG4gKiBEZWJ1ZyBob29rLlxuICogXG4gKiBHaXZlbiBhIHZhbHVlIG9yIHNldCBvZiB2YWx1ZXMsIGVtaXRzIGEgY29uc29sZSBlcnJvciBpZiBhbnkgb2YgdGhlbSBjaGFuZ2UgZnJvbSBvbmUgcmVuZGVyIHRvIHRoZSBuZXh0LlxuICogXG4gKiBFdmVudHVhbGx5LCB3aGVuIHVzZUV2ZW50IGxhbmRzLCB3ZSBob3BlZnVsbHkgd29uJ3QgbmVlZCB0aGlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRW5zdXJlU3RhYmlsaXR5PFQgZXh0ZW5kcyBhbnlbXT4ocGFyZW50SG9va05hbWU6IHN0cmluZywgLi4udmFsdWVzOiBUKSB7XG4gICAgY29uc3QgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkgPSB1c2VSZWY8QXJyYXk8VD4+KFtdKTtcbiAgICBjb25zdCBzaG93bkVycm9yID0gdXNlUmVmPEFycmF5PGJvb2xlYW4+PihbXSk7XG4gICAgdXNlSGVscGVyKHZhbHVlcy5sZW5ndGggYXMgYW55LCAtMSk7XG4gICAgdmFsdWVzLmZvckVhY2godXNlSGVscGVyKTtcbiAgICByZXR1cm47XG5cblxuICAgIGZ1bmN0aW9uIHVzZUhlbHBlcjxVIGV4dGVuZHMgVD4odmFsdWU6IFUsIGk6IG51bWJlcikge1xuICAgICAgICBjb25zdCBpbmRleCA9IGkgKyAxO1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnRbaW5kZXhdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50W2luZGV4XSA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50W2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFzaG93bkVycm9yLmN1cnJlbnRbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBUaGUgaG9vayAke3BhcmVudEhvb2tOYW1lfSByZXF1aXJlcyBzb21lIG9yIGFsbCBvZiBpdHMgYXJndW1lbnRzIHJlbWFpbiBzdGFibGUgYWNyb3NzIGVhY2ggcmVuZGVyOyBwbGVhc2UgY2hlY2sgdGhlICR7aX0taW5kZXhlZCBhcmd1bWVudCAoJHtpID49IDA/IEpTT04uc3RyaW5naWZ5KHZhbHVlc1tpXSkgOiBcInRoZSBudW1iZXIgb2Ygc3VwcG9zZWRseSBzdGFibGUgZWxlbWVudHNcIn0pLmApO1xuICAgICAgICAgICAgICAgIHNob3duRXJyb3IuY3VycmVudFtpbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2VSZW5kZXJpbmcoZjogKCkgPT4gdm9pZCkge1xuICAgIChvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID8/IHNldFRpbWVvdXQpKGYpO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYHVzZVN0YXRlYCwgYnV0IGZvciB2YWx1ZXMgdGhhdCBhcmVuJ3QgXCJyZW5kZXItaW1wb3J0YW50XCIgJm5kYXNoOyB1cGRhdGVzIGRvbid0IGNhdXNlIGEgcmUtcmVuZGVyIGFuZCBzbyB0aGUgdmFsdWUgc2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHJlbmRlciAodGhvdWdoIGl0IGNlcnRhaW5seSBjYW4sIGF0IGxlYXN0IGJ5IHJlLXJlbmRlcmluZyBhZ2FpbikuXG4gKiBcbiAqIFRvIGNvbXBlbnNhdGUgZm9yIHRoaXMsIHlvdSBzaG91bGQgcGFzcyBhIGB1c2VFZmZlY3RgLWVzcXVlIGNhbGxiYWNrIHRoYXQgaXMgcnVuIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSnVzdCBsaWtlIGB1c2VFZmZlY3RgLCB0aGlzIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uIHRoYXQncyBydW4gYmVmb3JlIHRoZSB2YWx1ZSBjaGFuZ2VzLiAgSWYgeW91IHdvdWxkIGxpa2UgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgKG9yLCBzYXksIHdoZW4gdGhlIHZhbHVlIG1lZXRzIHNvbWUgY3JpdGVyaWEpLCB0aGlzIGlzIHdoZXJlIHlvdSdsbCB3YW50IHRvIHB1dCBpbiBhIGNhbGwgdG8gYSBgc2V0U3RhdGVgIGZ1bmN0aW9uLlxuICogXG4gKiBUbyBzdW1tYXJpemUsIGl0J3MgbGlrZSBhIGB1c2VTdGF0ZWAtYHVzZUVmZmVjdGAgbWFzaHVwOlxuICogXG4gKiAxLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHRoaXMgdmVyc2lvbiBvZiBgc2V0U3RhdGVgIGRvZXNuJ3QgcmUtcmVuZGVyIHRoZSB3aG9sZSBjb21wb25lbnRcbiAqIDIuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgeW91IGNhbiBydW4gYSBmdW5jdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIHRoYXQgb3B0aW9uYWxseSByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvblxuICogMy4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgeW91IHRyaWdnZXIgdGhlIGVmZmVjdCBmdW5jdGlvbiBcInJlbW90ZWx5XCIgaW5zdGVhZCBvZiBpdCBydW5uaW5nIGFmdGVyIHJlbmRlcmluZ1xuICogNC4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgdGhlIHNpbmdsZSBcImRlcGVuZGVuY3lcIiBpcyBiYXNlZCBvbiB5b3VyIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAqIFxuICogTm90ZSB0aGF0IHdoaWxlIGNhbGxpbmcgYHNldFN0YXRlYCBkb2Vzbid0IGNhdXNlIGFueSByZS1yZW5kZXJzLCB5b3UgY2FuIGRvIHRoYXQgd2l0aGluIHlvdXIgYG9uQ2hhbmdlYCBmdW5jdGlvbiwgY2FsbGVkIHdoZW5ldmVyIHRoZSB2YWx1ZSBjaGFuZ2VzIHZpYSB0aGF0IGBzZXRTdGF0ZWAuXG4gKiBcbiAqIEBwYXJhbSBvbkNoYW5nZSBUaGUgXCJlZmZlY3RcIiBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYHVzZUVmZmVjdGAncyBcImVmZmVjdFwiIGZ1bmN0aW9uLiAgTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBnZXRJbml0aWFsVmFsdWUgSWYgcHJvdmlkZWQsIHRoZSBlZmZlY3Qgd2lsbCBiZSBpbnZva2VkIG9uY2Ugd2l0aCB0aGlzIHZhbHVlIG9uIG1vdW50LiBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHBhcmFtIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIEJ5IGRlZmF1bHQsIGNoYW5nZXMgdG8gcGFzc2l2ZSBzdGF0ZSBhcmUgZGVsYXllZCBieSBvbmUgdGljayBzbyB0aGF0IHdlIG9ubHkgY2hlY2sgZm9yIGNoYW5nZXMgaW4gYSBzaW1pbGFyIHdheSB0byBQcmVhY3QuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyB0bywgZm9yIGV4YW1wbGUsIGFsd2F5cyBydW4gaW1tZWRpYXRlbHkgaW5zdGVhZC5cbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFzc2l2ZVN0YXRlPFQsIFI+KG9uQ2hhbmdlOiB1bmRlZmluZWQgfCBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VCwgUj4sIGdldEluaXRpYWxWYWx1ZT86ICgpID0+IFQsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nPzogdHlwZW9mIGRlYm91bmNlUmVuZGVyaW5nKTogcmVhZG9ubHkgW2dldFN0YXRlU3RhYmxlOiAoKSA9PiBULCBzZXRTdGF0ZVN0YWJsZTogUGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPl0ge1xuXG4gICAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWY8VCB8IHR5cGVvZiBVbnNldD4oVW5zZXQpO1xuICAgIGNvbnN0IHJlYXNvblJlZiA9IHVzZVJlZjxSIHwgdHlwZW9mIFVuc2V0PihVbnNldCk7XG4gICAgY29uc3Qgd2FybmluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QgPSB1c2VSZWY8VCB8ICh0eXBlb2YgVW5zZXQpPihVbnNldCk7XG4gICAgY29uc3QgY2xlYW51cENhbGxiYWNrUmVmID0gdXNlUmVmPHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKT4odW5kZWZpbmVkKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VQYXNzaXZlU3RhdGVcIiwgb25DaGFuZ2UsIGdldEluaXRpYWxWYWx1ZSwgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcpO1xuXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gXCJkZXBlbmRlbmN5IGNoYW5nZWRcIiBhbmQgXCJjb21wb25lbnQgdW5tb3VudGVkXCIuXG4gICAgY29uc3Qgb25TaG91bGRDbGVhblVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2sgPSBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNsZWFudXBDYWxsYmFjaylcbiAgICAgICAgICAgIGNsZWFudXBDYWxsYmFjaygpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZXJlIGFyZSBhIGNvdXBsZSBwbGFjZXMgd2hlcmUgd2UnZCBsaWtlIHRvIHVzZSBvdXIgaW5pdGlhbFxuICAgIC8vIHZhbHVlIGluIHBsYWNlIG9mIGhhdmluZyBubyB2YWx1ZSBhdCBhbGwgeWV0LlxuICAgIC8vIFRoaXMgaXMgdGhlIHNoYXJlZCBjb2RlIGZvciB0aGF0LCB1c2VkIG9uIG1vdW50IGFuZCB3aGVuZXZlclxuICAgIC8vIGdldFZhbHVlIGlzIGNhbGxlZC5cbiAgICBjb25zdCB0cnlFbnN1cmVWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ICYmIGdldEluaXRpYWxWYWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFZhbHVlID0gZ2V0SW5pdGlhbFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKGluaXRpYWxWYWx1ZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQhKSA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0aW9ucyBhcmUgaW50ZW50aW9uYWwgdG8gYWxsb3cgYmFpbG91dCAod2l0aG91dCBleHBvc2luZyB0aGUgVW5zZXQgc3ltYm9sKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgWy8qIGdldEluaXRpYWxWYWx1ZSBhbmQgb25DaGFuZ2UgaW50ZW50aW9uYWxseSBvbWl0dGVkICovXSk7XG5cblxuICAgIGNvbnN0IGdldFZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAod2FybmluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVyaW5nIG9uQ2hhbmdlLCBwcmVmZXIgdXNpbmcgdGhlICh2YWx1ZSwgcHJldlZhbHVlKSBhcmd1bWVudHMgaW5zdGVhZCBvZiBnZXRWYWx1ZSAtLSBpdCdzIGFtYmlndW91cyBhcyB0byBpZiB5b3UncmUgYXNraW5nIGZvciB0aGUgb2xkIG9yIG5ldyB2YWx1ZSBhdCB0aGlzIHBvaW50IGluIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50LlwiKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSBjYWxsIGdldFZhbHVlLCBpZiB3ZSBoYXZlbid0IGJlZW4gZ2l2ZW4gYSB2YWx1ZSB5ZXQsXG4gICAgICAgIC8vIChhbmQgd2Ugd2VyZSBnaXZlbiBhbiBpbml0aWFsIHZhbHVlIHRvIHVzZSlcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBpbml0aWFsIHZhbHVlIGluc3RlYWQgb2Ygbm90aGluZy5cbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0KVxuICAgICAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcblxuICAgICAgICByZXR1cm4gKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkISA6IHZhbHVlUmVmLmN1cnJlbnQhKSBhcyBUO1xuICAgIH0sIFtdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBydW4gb3VyIGVmZmVjdCBhdCBsZWFzdCBvbmNlIG9uIG1vdW50LlxuICAgICAgICAvLyAoSWYgd2UgaGF2ZSBhbiBpbml0aWFsIHZhbHVlLCBvZiBjb3Vyc2UpXG4gICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cblxuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZSBhY3R1YWwgY29kZSB0aGUgdXNlciBjYWxscyB0byAocG9zc2libHkpIHJ1biBhIG5ldyBlZmZlY3QuXG4gICAgY29uc3Qgc2V0VmFsdWUgPSB1c2VDYWxsYmFjazxQYXNzaXZlU3RhdGVVcGRhdGVyPFQsIFI+PigoYXJnOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VCwgUj4+WzBdLCByZWFzb246IFBhcmFtZXRlcnM8UGFzc2l2ZVN0YXRlVXBkYXRlcjxULCBSPj5bMV0pID0+IHtcblxuICAgICAgICAvLyBSZWdhcmRsZXNzIG9mIGFueXRoaW5nIGVsc2UsIGZpZ3VyZSBvdXQgd2hhdCBvdXIgbmV4dCB2YWx1ZSBpcyBhYm91dCB0byBiZS5cbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gKGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogdmFsdWVSZWYuY3VycmVudCkgOiBhcmcpO1xuXG5cbiAgICAgICAgaWYgKGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPT09IFVuc2V0ICYmIG5leHRWYWx1ZSAhPT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcmVxdWVzdCB0byBjaGFuZ2UgdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRoZSByZXF1ZXN0IGltbWVkaWF0ZWx5LCB0aGVuIHF1ZXVlIHVwIHRoZSBvbkNoYW5nZSBmdW5jdGlvblxuXG4gICAgICAgICAgICAvLyBTYXZlIG91ciBjdXJyZW50IHZhbHVlIHNvIHRoYXQgd2UgY2FuIGNvbXBhcmUgYWdhaW5zdCBpdCBsYXRlclxuICAgICAgICAgICAgLy8gKGlmIHdlIGZsaXAgYmFjayB0byB0aGlzIHN0YXRlLCB0aGVuIHdlIHdvbid0IHNlbmQgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCA9IHZhbHVlUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIHVwZGF0ZSB0aGlzIGhlcmUgKGFzIHdlbGwgYXMgYmVsb3cpIGluIGNhc2UgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgaW52b2tlcyB0aGlzIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuICAgICAgICAgICAgcmVhc29uUmVmLmN1cnJlbnQgPSByZWFzb24gYXMgUjtcblxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIGFjdHVhbCBjaGVjayBhbmQgaW52b2NhdGlvbiBvZiBvbkNoYW5nZSBsYXRlciB0byBsZXQgZWZmZWN0cyBzZXR0bGVcbiAgICAgICAgICAgIChjdXN0b21EZWJvdW5jZVJlbmRlcmluZyA/PyBkZWJvdW5jZVJlbmRlcmluZykoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRSZWFzb24gPSByZWFzb25SZWYuY3VycmVudCEgYXMgUjtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGVwID0gdmFsdWVSZWYuY3VycmVudCEgYXMgVDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2RGVwID0gZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudDtcbiAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeVRvQ29tcGFyZUFnYWluc3QuY3VycmVudCAhPSB2YWx1ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYW55IHJlZ2lzdGVyZWQgY2xlYW51cCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25TaG91bGRDbGVhblVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKG5leHREZXAsIHByZXZEZXAgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogcHJldkRlcCwgbmV4dFJlYXNvbikgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0RGVwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gbm9ybWFsbHkgY2FsbCBnZXRWYWx1ZSBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGZpbmlzaGVkIHdpdGggZXZlcnl0aGluZywgc28gbWFyayB1cyBhcyBiZWluZyBvbiBhIGNsZWFuIHNsYXRlIGFnYWluLlxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lUb0NvbXBhcmVBZ2FpbnN0LmN1cnJlbnQgPSBVbnNldDtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlIGltbWVkaWF0ZWx5LlxuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2hlY2tlZCBhZ2FpbnN0IHByZXZEZXAgdG8gc2VlIGlmIHdlIHNob3VsZCBhY3R1YWxseSBjYWxsIG9uQ2hhbmdlXG4gICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gW2dldFZhbHVlLCBzZXRWYWx1ZV0gYXMgY29uc3Q7XG59XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKCk7XG5cbi8vIEVhc3kgY29uc3RhbnRzIGZvciBnZXRJbml0aWFsVmFsdWVcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5UcnVlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5OdWxsKCkgeyByZXR1cm4gbnVsbDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblVuZGVmaW5lZCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblplcm8oKSB7IHJldHVybiAwOyB9XG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHk8VD4odDogVCkgeyByZXR1cm4gdDsgfSAvLyBLaW5kIG9mIGFuIGV4dHJhLCBidXQgaXQncyB1c2VmdWwgaW4gb3RoZXIgcGxhY2VzIGFueXdheVxuXG4vKiogXG4gKiBBbiBhbHRlcm5hdGl2ZSB0byB1c2UgZm9yIGBjdXN0b21EZWJvdW5jZVJlbmRlcmluZ2AgdGhhdCBjYXVzZXMgYHVzZVBhc3NpdmVTdGF0ZWAgdG8gcnVuIGNoYW5nZXMgd2l0aG91dCB3YWl0aW5nIGEgdGljay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bkltbWVkaWF0ZWx5KGY6ICgpID0+IHZvaWQpIHsgZigpOyB9IiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCByZXR1cm5UcnVlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuXG5cbi8qKlxuICogXG4gKiBUaGVyZSBhcmUgc2V2ZXJhbCBkaWZmZXJlbnQgd2F5cyB0aGF0IGEgZm9jdXMgZXZlbnQgY2FuIGhhcHBlbi4gIEFzc3VtZVxuICogdGhlIGZvbGxvd2luZyBzdGVwcyBoYXBwZW4gaW4gb3JkZXI6XG4gKiBcbiAqIDEuIFRoZSBwYWdlIGxvYWRzLlxuICogICAgKiBOb3RoaW5nIGlzIGZvY3VzZWQsIGJ1dCBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYGJvZHlgLiBcbiAqICAgICogTm8gZm9jdXMgZXZlbnRzIGFyZSBmaXJlZC5cbiAqIDIuIFRoZSB3aW5kb3cgaXMgZm9jdXNlZCwgYW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgcmVtYWlucyBhcyBgYm9keWAuXG4gKiAgICAqIEEgYGZvY3VzYC9gZm9jdXNpbmAgZXZlbnQgKk1JR0hUKiBiZSBmaXJlZCBmb3IgYGJvZHlgLiBEZXBlbmRpbmcgb25cbiAqICAgICAgdGhlIGJyb3dzZXIsIHRoaXMgZGVwZW5kcyBvbiB3aGV0aGVyIHRoZSBoYW5kbGVyIHdhcyBhdHRhY2hlZCB0byBgd2luZG93YCBvciBgZG9jdW1lbnRgLlxuICogICAgICBQcm9iYWJseSBqdXN0IGJlc3QgdG8gbm90IHJlbHkgb24gaXQsIG9yIGxpc3RlbiB0byBgd2luZG93YCBmb2N1cyBldmVudHMgZGlyZWN0bHkuXG4gKiAzLiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gdGhlIG5ldyBlbGVtZW50IGJlZm9yZSBhbnkgZXZlbnQgZXZlbiBmaXJlcy5cbiAqICAgICogYGZvY3Vzb3V0YCBhbmQgYGJsdXJgIGFyZSAqbm90KiBmaXJlZCBvbiBgYm9keWAuXG4gKiAgICAqIGBmb2N1c2AgYW5kIGBmb2N1c2luYCBhcmUgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cbiAqIDQuIEEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgZXRjLlxuICogICAgKiAqKlRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBgYm9keWAqKiBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG5ldyBlbGVtZW50LlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIG5vdyBzZXQgdG8gdGhlIG5ldyBlbGVtZW50LlxuICogICAgKiBgZm9jdXNpbmAgaXMgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG9sZCBlbGVtZW50LlxuICogNS4gQW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIGBib2R5YC5cbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxuICogICAgKiBgZm9jdXNpbmAgaXMgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxuICogXG4gKiBcbiAqIEluIHN1bW1hcnk6XG4gKiAxLiBGb2N1cyBldmVudHMgKmRvKiBub3RpZnkgdXMgb2YgYWxsIGNoYW5nZXMgaW4gZm9jdXMsIGJ1dCB0aGVyZSBpcyBubyBvbmUgc2luZ2xlIGNvbXByZWhlbnNpdmUgZXZlbnQgdGhhdCBwcm92aWRlcyB1cyB3aXRoIGFsbCBhdmFpbGFibGUgaW5mb3JtYXRpb24uXG4gKiAyLiBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgKmlzIG5vdCogYWx3YXlzIHRoZSBzYW1lIGFzIHdoYXQncyBiZWluZyByZWZlcmVuY2VkIGJ5IGEgZm9jdXMgZXZlbnQuIEluIHBhcnRpY3VsYXIsIGl0IG1heSBiZWNvbWUgYGJvZHlgIGF0IGFueSBhcmJpdHJhcnkgdGltZS5cbiAqIDMuIEEgYGJsdXJgIHdpdGhvdXQgYSBgZm9jdXNgIGNhbiBhbmQgd2lsbCBvY2N1ci4gVGhpcyBtZWFucyBpdCBpcyBub3QgcG9zc2libGUgdG8gc29sZWx5IHVzZSBgZm9jdXNgIHRvIGRldGVjdCBhbGwgY2hhbmdlcy5cbiAqIDQuIEEgYGJsdXJgIGV2ZW50IHdob3NlIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsIGluZGljYXRlcyB0aGF0IHRoZXJlIHdpbGwgYmUgbm8gZm9sbG93aW5nIGBmb2N1c2AgZXZlbnQuXG4gKiBcbiAqL1xuY29uc3QgX2R1bW15ID0gMDtcblxuaW50ZXJmYWNlIEZvbzxUPiB7XG4gICAgbGFzdFNlbnQ6IFQgfCB1bmRlZmluZWQ7XG4gICAgc2VuZDogKGU6IFQsIHI6IEZvY3VzRXZlbnQpID0+IHZvaWQ7XG59XG4vKlxuY29uc3QgYWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBOb2RlIHwgbnVsbCkgPT4gdm9pZCk+PigpO1xuY29uc3QgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogTm9kZSkgPT4gdm9pZCk+PigpO1xuY29uc3Qgd2luZG93Rm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChmb2N1c2VkOiBib29sZWFuKSA9PiB2b2lkKT4+KCk7XG5jb25zdCB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBib29sZWFuPigpOyovXG5jb25zdCBhY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDxGb288Tm9kZSB8IG51bGw+Pj4oKTtcbmNvbnN0IGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDxGb288Tm9kZT4+PigpO1xuY29uc3Qgd2luZG93Rm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPGJvb2xlYW4+Pj4oKTtcbmNvbnN0IHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIGJvb2xlYW4+KCk7XG5cbi8vY29uc3QgbWljcm90YXNrcyA9IG5ldyBNYXA8U2V0PGFueT4sIGFueT4oKTtcblxuLy8gVGhlIGZvY3VzaW4gYW5kIGZvY3Vzb3V0IGV2ZW50cyBvZnRlbiBmaXJlIHN5bmNyb25vdXNseSBpbiB0aGUgbWlkZGxlIG9mIHJ1bm5pbmcgY29kZS5cbi8vIEUuRy4gY2FsbGluZyBlbGVtZW50LmZvY3VzKCkgY2FuIGNhdXNlIGEgZm9jdXNpbiBldmVudCBoYW5kbGVyIHRvIGltbWVkaWF0ZWx5IGludGVycnVwdCB0aGF0IGNvZGUuXG4vLyBGb3IgdGhlIHB1cnBvc2Ugb2YgaW1wcm92aW5nIHN0YWJpbGl0eSwgd2UgZGVib3VuY2UgYWxsIGZvY3VzIGV2ZW50cyB0byB0aGUgbmV4dCBtaWNyb3Rhc2suXG5mdW5jdGlvbiBmb3JFYWNoVXBkYXRlcjxUPih3aW5kb3c6IFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIG1hcDogTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDxGb288VD4+PiwgdmFsdWU6IFQsIHJlYXNvbjogYW55KSB7XG4gICAgY29uc3QgdXBkYXRlcnMgPSBtYXAuZ2V0KHdpbmRvdyk7XG4gICAgaWYgKHVwZGF0ZXJzKSB7XG4gICAgICAgIC8vaWYgKCFtaWNyb3Rhc2tzLmhhcyh1cGRhdGVyc0tleSkpIHtcbiAgICAgICAgLy9kZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgIC8vY29uc3QgdXBkYXRlcnNLZXkgPSBtYXAuZ2V0KHdpbmRvdykhO1xuICAgICAgICAvL2NvbnN0IHZhbHVlID0gbWljcm90YXNrcy5nZXQodXBkYXRlcnNLZXkpO1xuICAgICAgICAvL21pY3JvdGFza3MuZGVsZXRlKHVwZGF0ZXJzS2V5KTtcblxuICAgICAgICBpZiAodXBkYXRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlciBvZiB1cGRhdGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGFzdFNlbnQsIHNlbmQgfSA9IHVwZGF0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBsYXN0U2VudCkge1xuICAgICAgICAgICAgICAgICAgICBzZW5kKHZhbHVlLCByZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVyLmxhc3RTZW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy99KTtcbiAgICAgICAgLy99XG5cbiAgICAgICAgLy9taWNyb3Rhc2tzLnNldCh1cGRhdGVyc0tleSwgdmFsdWUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9jdXNvdXQoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG4gICAgaWYgKGUucmVsYXRlZFRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBudWxsLCBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEp1c3Qgd2FpdCBmb3IgdGhlIGZvY3VzaW4gZXZlbnQuXG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGZvY3VzaW4oZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIGNvbnN0IGN1cnJlbnRseUZvY3VzZWRFbGVtZW50ID0gZS50YXJnZXQgYXMgKEVsZW1lbnQgJiBIVE1MT3JTVkdFbGVtZW50KTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGFjdGl2ZUVsZW1lbnRVcGRhdGVycywgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQsIGUpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycywgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQsIGUpO1xufVxuXG5mdW5jdGlvbiB3aW5kb3dGb2N1cyhlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS50YXJnZXQgOiBlLmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLmN1cnJlbnRUYXJnZXQgOiAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyk7XG4gICAgd2luZG93c0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCB0cnVlKTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIHdpbmRvd0ZvY3VzZWRVcGRhdGVycywgdHJ1ZSwgZSk7XG59XG5cbmZ1bmN0aW9uIHdpbmRvd0JsdXIoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUudGFyZ2V0IDogZS5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS5jdXJyZW50VGFyZ2V0IDogKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgZmFsc2UpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLCBmYWxzZSwgZSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMge1xuXG4gICAgYWN0aXZlRWxlbWVudFBhcmFtZXRlcnM6IHsgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMuIE11c3QgYmUgc3RhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8RWxlbWVudCB8IG51bGwsIEZvY3VzRXZlbnQ+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMgYW5kIGlzIG5vdCBudWxsLiBcbiAgICAgICAgICogTXVzdCBiZSBzdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8RWxlbWVudCwgRm9jdXNFdmVudD47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgd2luZG93IGdhaW5zL2xvc2VzIGZvY3VzLiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPGJvb2xlYW4sIEZvY3VzRXZlbnQ+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG11c3QgYmUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGRvY3VtZW50IGFzc29jaWF0ZWQgd2l0aCB3aGF0ZXZlciBlbGVtZW50cyB3ZSdyZSBsaXN0ZW5pbmcgdG8uXG4gICAgICAgICAqIFxuICAgICAgICAgKiBFLkcuIHNvbWVEaXZFbGVtZW50Lm93bmVyRG9jdW1lbnRcbiAgICAgICAgICogXG4gICAgICAgICAqICoqTVVTVCoqIGJlIHN0YWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RG9jdW1lbnQoKTogRG9jdW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIGV2ZW50IGhhbmRsZXJzIGFyZSBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQncyBkZWZhdWx0VmlldyBXaW5kb3cuXG4gICAgICAgICAqIElmIHlvdSBuZWVkIHNvbWV0aGluZyBkaWZmZXJlbnQsIG92ZXJyaWRlIGl0IGhlcmUuXG4gICAgICAgICAqIFxuICAgICAgICAgKiAqKk1VU1QqKiBiZSBzdGFibGVcbiAgICAgICAgICovXG4gICAgICAgIGdldFdpbmRvdz8oZG9jdW1lbnQ6IERvY3VtZW50KTogV2luZG93O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY3RpdmVFbGVtZW50UmV0dXJuVHlwZSB7XG4gICAgYWN0aXZlRWxlbWVudFJldHVybjoge1xuICAgICAgICAvKiogXG4gICAgICAgICAqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3IgYG51bGxgIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50XG4gICAgICAgICAqICoqU1RBQkxFKipcbiAgICAgICAgICovXG4gICAgICAgIGdldEFjdGl2ZUVsZW1lbnQ6ICgpID0+IEVsZW1lbnQgfCBudWxsO1xuICAgICAgICAvKiogXG4gICAgICAgICAqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3Igd2hhdGV2ZXIgZWxlbWVudCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50XG4gICAgICAgICAqICoqU1RBQkxFKipcbiAgICAgICAgICovXG4gICAgICAgIGdldExhc3RBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50O1xuICAgICAgICAvKiogXG4gICAgICAgICAqIFJldHVybnMgaWYgdGhlIHdpbmRvdyBpdHNlbGYgaGFzIGZvY3VzIG9yIG5vdFxuICAgICAgICAgKiAqKlNUQUJMRSoqXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaW5kb3dGb2N1c2VkOiAoKSA9PiBib29sZWFuO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBbGxvd3MgeW91IHRvIGluc3BlY3Qgd2hpY2ggZWxlbWVudCBpbiB0aGUgYGRvY3VtZW50YCBjdXJyZW50bHkgaGFzIGZvY3VzLCB3aGljaCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIG5vbmUgYXJlIGN1cnJlbnRseSwgYW5kIHdoZXRoZXIgb3Igbm90IHRoZSB3aW5kb3cgaGFzIGZvY3VzIGJ5IHJldHVybmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAqICogYGdldEFjdGl2ZUVsZW1lbnQoKWBcbiAqICogYGdldExhc3RBY3RpdmVFbGVtZW50KClgXG4gKiAqIGBnZXRXaW5kb3dGb2N1c2VkKClgXG4gKiBcbiAqIChUaGUgZG9jdW1lbnQncyBib2R5IHJlY2VpdmluZyBmb2N1cywgbGlrZSBpdCBkb2VzIHdoZW4geW91IGNsaWNrIG9uIGFuIGVtcHR5IGFyZWEsIGlzIGNvdW50ZWQgYXMgbm8gZWxlbWVudCBoYXZpbmcgZm9jdXMgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3NlcylcbiAqIFxuICogVGhpcyBpcyBhIHBhc3NpdmUgaG9vaywgc28gYnkgZGVmYXVsdCBpdCByZXR1cm5zIGdldHRlciBmdW5jdGlvbnMgdGhhdCByZXBvcnQgdGhpcyBpbmZvcm1hdGlvbiBidXQgdGhlIGNvbXBvbmVudCB3aWxsIG5vdCByZS1yZW5kZXIgYnkgZGVmYXVsdCB3aGVuIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLlxuICogXG4gKiBJZiB5b3UgbmVlZCB0aGUgY29tcG9uZW50IHRvIHJlLXJlbmRlciB3aGVuIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLCB1c2UgdGhlIGBvbipDaGFuZ2VgIGFyZ3VtZW50cyB0byBzZXQgc29tZSBzdGF0ZSBvbiB5b3VyIGVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGl2ZUVsZW1lbnQoeyBhY3RpdmVFbGVtZW50UGFyYW1ldGVyczogeyBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyB9IH06IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzKTogVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUge1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlQWN0aXZlRWxlbWVudFwiLCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IChnZXRXaW5kb3c/Lihkb2N1bWVudCkgPz8gZG9jdW1lbnQ/LmRlZmF1bHRWaWV3KTtcblxuICAgICAgICBpZiAoKGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KT8uc2l6ZSA/PyAwKSA9PT0gMCkge1xuICAgICAgICAgICAgZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGZvY3VzaW4sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZm9jdXNvdXQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHdpbmRvd0JsdXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCB0aGVtIGV2ZW4gaWYgdGhleSdyZSB1bmRlZmluZWQgdG8gbW9yZSBlYXNpbHlcbiAgICAgICAgLy8gbWFuYWdlIHRoZSBcIj4wIG1lYW5zIGRvbid0IGFkZCBoYW5kbGVyc1wiIGxvZ2ljLlxuICAgICAgICBjb25zdCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XG5cbiAgICAgICAgY29uc3QgbGFldSA9IHsgc2VuZDogc2V0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZSB8IG51bGw+LCBsYXN0U2VudDogdW5kZWZpbmVkIH1cbiAgICAgICAgY29uc3QgbGxhZXUgPSB7IHNlbmQ6IHNldExhc3RBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlPiwgbGFzdFNlbnQ6IHVuZGVmaW5lZCB9O1xuICAgICAgICBjb25zdCBsd2Z1ID0geyBzZW5kOiBzZXRXaW5kb3dGb2N1c2VkLCBsYXN0U2VudDogdW5kZWZpbmVkIH07XG5cbiAgICAgICAgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMuYWRkKGxhZXUpO1xuICAgICAgICBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuYWRkKGxsYWV1KTtcbiAgICAgICAgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMuYWRkKGx3ZnUpO1xuXG4gICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyk7XG4gICAgICAgIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzKTtcbiAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUobGFldSk7XG4gICAgICAgICAgICBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUobGFldSk7XG4gICAgICAgICAgICB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuZ2V0KHdpbmRvdykhLmRlbGV0ZShsd2Z1KTtcblxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGZvY3VzaW4pO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZm9jdXNvdXQpO1xuICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzKTtcbiAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHdpbmRvd0JsdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBbZ2V0QWN0aXZlRWxlbWVudCwgc2V0QWN0aXZlRWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8RWxlbWVudCB8IG51bGwsIEZvY3VzRXZlbnQ+KG9uQWN0aXZlRWxlbWVudENoYW5nZSwgcmV0dXJuTnVsbCk7XG4gICAgY29uc3QgW2dldExhc3RBY3RpdmVFbGVtZW50LCBzZXRMYXN0QWN0aXZlRWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8RWxlbWVudCwgRm9jdXNFdmVudD4ob25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgcmV0dXJuTnVsbCBhcyAoKSA9PiBuZXZlcik7XG4gICAgY29uc3QgW2dldFdpbmRvd0ZvY3VzZWQsIHNldFdpbmRvd0ZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4sIEZvY3VzRXZlbnQ+KG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmV0dXJuVHJ1ZSk7XG5cbiAgICByZXR1cm4geyBhY3RpdmVFbGVtZW50UmV0dXJuOiB7IGdldEFjdGl2ZUVsZW1lbnQsIGdldExhc3RBY3RpdmVFbGVtZW50LCBnZXRXaW5kb3dGb2N1c2VkIH0gfTtcbn1cbiIsIlxuaW1wb3J0IHsgQ29tcG9uZW50LCBvcHRpb25zLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEVmZmVjdENhbGxiYWNrLCBJbnB1dHMsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cblxuXG5jb25zdCBUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfLVwiO1xuXG5mdW5jdGlvbiBiYXNlNjQodmFsdWU6IG51bWJlcikge1xuICAgIHJldHVybiBUYWJsZVt2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIHJhbmRvbTZCaXRzKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAwYjEwMDAwMDApO1xufVxuXG5mdW5jdGlvbiByYW5kb202NEJpdHMoKSB7XG4gICAgcmV0dXJuIFtyYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpXSBhcyBjb25zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tbHktZ2VuZXJhdGVkIElEIHdpdGggYW4gb3B0aW9uYWwgcHJlZml4LlxuICogTm90ZSB0aGF0IGlmIHRoZSBwcmVmaXggaXMgKmV4cGxpY2l0bHkqIHNldCB0byBcIlwiLCB0aGVuXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxuICogXG4gKiBcbiAqIChUaGlzIGlzIGhlcmUsIGluIHRoaXMgcGFydGljdWxhciBmaWxlLCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcbiAqIHdpdGhvdXQgYWxzbyBtYWtpbmcgYSB1dGlsaXRpZXMgZmlsZS5cbiAqIE9uY2Ugd2UgY2FuIHJlbW92ZSB0aGlzIGhvb2ssIHdlIGNhbiBwdXQgdGhpcyBmdW5jdGlvbiBiYWNrIHdpdGggdXNlUmFuZG9tSWQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbUlkKHByZWZpeD86IHN0cmluZykge1xuICAgIHJldHVybiBgJHtwcmVmaXggPz8gXCJpZC1cIn0ke3JhbmRvbTY0Qml0cygpLm1hcChuID0+IGJhc2U2NChuKSkuam9pbihcIlwiKX1gO1xufVxuXG5jb25zdCBwcmV2aW91c0lucHV0cyA9IG5ldyBNYXA8c3RyaW5nLCBJbnB1dHMgfCB1bmRlZmluZWQ+KCk7XG5jb25zdCB0b1J1biA9IG5ldyBNYXA8c3RyaW5nLCB7IGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cywgY2xlYW51cDogbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWQgfCAoKCkgPT4gdm9pZCkgfT4oKTtcblxuXG4vLyBUT0RPOiBXaGV0aGVyIHRoaXMgZ29lcyBpbiBvcHRpb25zLmRpZmZlZCBvciBvcHRpb25zLl9jb21taXRcbi8vIGlzIGEgcG9zdC1zdXNwZW5zZSBxdWVzdGlvbi5cbi8vIFJpZ2h0IG5vdywgdXNpbmcgb3B0aW9ucy5fY29tbWl0IGhhcyB0aGUgcHJvYmxlbSBvZiBydW5uaW5nXG4vLyAqYWZ0ZXIqIHJlZnMgYXJlIGFwcGxpZWQsIGJ1dCB3ZSBuZWVkIHRvIGNvbWUgYmVmb3JlIGV2ZW4gdGhhdFxuLy8gc28gYHJlZj17c29tZVN0YWJsZUZ1bmN0aW9ufWAgd29ya3MuXG4vLyBcbi8vIEFsc28gaXQncyBwcml2YXRlLlxuLy9cbi8vIC4uLlxuLy8gV2VsbCwgdXNlRXZlbnQgb3Igd2hhdGV2ZXIgaXMgZmluYWxseSwgZmluYWxseSA0IHllYXJzIGxhdGVyIGZpbmFsbHkgaGVyZVxuLy8gd2hpY2ggaXMgY29vbCBhbmQgbWVhbnMgd2Ugd29uJ3QgbmVlZCB0aGlzIGF0IGFsbCBzb29uLlxuLy8gU28gZm9yIG5vdyB3ZSdsbCBzdGljayB3aXRoIGRpZmYgdG8gcHJldmVudCBhbnkgd2VpcmRuZXNzIHdpdGhcbi8vIGNvbW1pdCBiZWluZyBwcml2YXRlIGFuZCBhbGwuXG5jb25zdCBjb21taXROYW1lID0gXCJkaWZmZWRcIjtcblxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdIGFzICh2bm9kZTogVk5vZGUsIGNvbW1pdFF1ZXVlOiBDb21wb25lbnRbXSkgPT4gdm9pZDtcbmNvbnN0IG5ld0NvbW1pdDogdHlwZW9mIG9yaWdpbmFsQ29tbWl0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZWZmZWN0SW5mb10gb2YgdG9SdW4pIHtcbiAgICAgICAgY29uc3Qgb2xkSW5wdXRzID0gcHJldmlvdXNJbnB1dHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGFyZ3NDaGFuZ2VkKG9sZElucHV0cywgZWZmZWN0SW5mby5pbnB1dHMpKSB7XG4gICAgICAgICAgICBlZmZlY3RJbmZvLmNsZWFudXA/LigpO1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLnNldChpZCwgZWZmZWN0SW5mby5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUnVuLmNsZWFyKCk7XG4gICAgb3JpZ2luYWxDb21taXQ/LiguLi5hcmdzKTtcbn1cbm9wdGlvbnNbY29tbWl0TmFtZV0gPSBuZXdDb21taXQgYXMgbmV2ZXJcblxuLyoqXG4gKiBTZW1pLXByaXZhdGUgZnVuY3Rpb24gdG8gYWxsb3cgc3RhYmxlIGNhbGxiYWNrcyBldmVuIHdpdGhpbiBgdXNlTGF5b3V0RWZmZWN0YCBhbmQgcmVmIGFzc2lnbm1lbnQuXG4gKiBcbiAqIEV2ZXJ5IHJlbmRlciwgd2Ugc2VuZCB0aGUgYXJndW1lbnRzIHRvIGJlIGV2YWx1YXRlZCBhZnRlciBkaWZmaW5nIGhhcyBjb21wbGV0ZWQsXG4gKiB3aGljaCBoYXBwZW5zIGJlZm9yZS5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoZWZmZWN0OiBFZmZlY3RDYWxsYmFjayB8IG51bGwsIGlucHV0cz86IElucHV0cykge1xuXG4gICAgLyooKCkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gdXNlUmVmPHZvaWQgfCAoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKTtcbiAgICAgICAgY29uc3QgcHJldkFyZ3NSZWYgPSB1c2VSZWY8SW5wdXRzPihudWxsISk7XG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChpbnB1dHMsIHByZXZBcmdzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBwcmV2QXJnc1JlZi5jdXJyZW50ID0gaW5wdXRzITtcbiAgICAgICAgICAgIGlmIChjbGVhbnVwLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgY2xlYW51cC5jdXJyZW50KCk7XG4gICAgICAgICAgICBjbGVhbnVwLmN1cnJlbnQgPSBlZmZlY3QoKTtcbiAgICAgICAgfVxuICAgIH0pKCk7Ki9cblxuICAgIGNvbnN0IFtpZF0gPSB1c2VTdGF0ZSgoKSA9PiBnZW5lcmF0ZVJhbmRvbUlkKCkpO1xuICAgIGlmIChlZmZlY3QpXG4gICAgICAgIHRvUnVuLnNldChpZCwgeyBlZmZlY3QsIGlucHV0cywgY2xlYW51cDogbnVsbCB9KTtcbiAgICBlbHNlXG4gICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdG9SdW4uZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICB9LCBbaWRdKVxufVxuXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzPzogSW5wdXRzLCBuZXdBcmdzPzogSW5wdXRzKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhKFxuICAgICAgICAhb2xkQXJncyB8fFxuICAgICAgICBvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncz8ubGVuZ3RoIHx8XG4gICAgICAgIG5ld0FyZ3M/LnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG4gICAgKTtcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZUJlZm9yZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdFwiO1xuXG5jb25zdCBVbnNldCA9IFN5bWJvbChcInVuc2V0XCIpO1xuXG5cbi8qKlxuICogR2l2ZW4gYW4gaW5wdXQgdmFsdWUsIHJldHVybnMgYSBjb25zdGFudCBnZXR0ZXIgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBcbiAqIGluc2lkZSBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcyB3aXRob3V0IGluY2x1ZGluZyBpdCBpbiB0aGUgZGVwZW5kZW5jeSBhcnJheS5cbiAqIFxuICogVGhpcyB1c2VzIGBvcHRpb25zLmRpZmZlZGAgaW4gb3JkZXIgdG8gcnVuIGJlZm9yZSBldmVyeXRoaW5nLCBldmVuXG4gKiByZWYgYXNzaWdubWVudC4gVGhpcyBtZWFucyB0aGlzIGdldHRlciBpcyBzYWZlIHRvIHVzZSBhbnl3aGVyZSAqKipleGNlcHQgdGhlIHJlbmRlciBwaGFzZSoqKi5cbiAqIFxuICogQHBhcmFtIHZhbHVlIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVHZXR0ZXI8VD4odmFsdWU6IFQpIHtcblxuICAgIGNvbnN0IHJlZiA9IHVzZVJlZjxUPihVbnNldCBhcyB1bmtub3duIGFzIFQpO1xuICAgIHVzZUJlZm9yZUxheW91dEVmZmVjdCgoKCkgPT4geyByZWYuY3VycmVudCA9IHZhbHVlOyB9KSwgW3ZhbHVlXSk7XG5cbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAocmVmLmN1cnJlbnQgYXMgdW5rbm93biA9PT0gVW5zZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgcmV0cmlldmVkIGZyb20gdXNlU3RhYmxlR2V0dGVyKCkgY2Fubm90IGJlIGNhbGxlZCBkdXJpbmcgcmVuZGVyLicpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZi5jdXJyZW50O1xuICAgIH0sIFtdKTtcbn1cblxuXG4vKipcbiAqIExpa2UgYHVzZVN0YWJsZUdldHRlcmAsIGJ1dCAqKipyZXF1aXJlcyoqKiB0aGF0IGV2ZXJ5dGhpbmcgaW4gdGhlIG9iamVjdCBpcyBhbHNvIHN0YWJsZSxcbiAqIGFuZCBpbiB0dXJuIHJldHVybnMgYW4gb2JqZWN0IHRoYXQgaXRzZWxmIGlzIHN0YWJsZS5cbiAqIEBwYXJhbSB0IFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVPYmplY3Q8VCBleHRlbmRzIHt9Pih0OiBUKTogVCB7XG4gICAgY29uc3QgZSA9IE9iamVjdC5lbnRyaWVzKHQpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVN0YWJsZU9iamVjdFwiLCBlLmxlbmd0aCwgLi4uZS5tYXAoKFtfaywgdl0pID0+IHYpKTtcbiAgICByZXR1cm4gdXNlUmVmKHQpLmN1cnJlbnQ7XG59XG5cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrTmF0aXZlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cblxuLy9jb25zdCBfSVNfU1RBQkxFX0dFVFRFUiA9IFN5bWJvbChcIlNUQUJMRVwiKTtcbmV4cG9ydCB0eXBlIFN0YWJsZTxUPiA9IFQ7Ly8gJiB7IFtfU1RBQkxFXTogdHJ1ZSB9O1xuXG4vKipcbiAqIFdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggY2FsbGJhY2tzIGFyZSBzdGFibGUgd2l0aCBhIFdlYWtNYXAgaW5zdGVhZCBvZiwgc2F5LCBhIHN5bWJvbCBiZWNhdXNlXG4gKiBgdXNlQ2FsbGJhY2tgIHdpbGwgcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCdzIHN0YWJsZSBhY3Jvc3MgKmFsbCogcmVuZGVycywgbWVhbmluZ1xuICogd2UgY2FuJ3QgdXNlIG91ciBmdW5ueSBcImBpZmAgb25seSB3b3JrcyBoZXJlIGJlY2F1c2UgaXQgZG9lc24ndCBicmVhayB0aGUgcnVsZXMgb2YgaG9va3NcIiB0cmljayB0aGVuLlxuICovXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcDxGdW5jdGlvbiwgYm9vbGVhbj4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RhYmxlR2V0dGVyPFQgZXh0ZW5kcyBGdW5jdGlvbj4ob2JqOiBUKTogb2JqIGlzIFN0YWJsZTxUPiB7XG4gICAgcmV0dXJuIChtYXAuZ2V0KG9iaikgPz8gZmFsc2UpO1xufVxuZnVuY3Rpb24gc2V0SXNTdGFibGVHZXR0ZXI8VCBleHRlbmRzICguLi5fYXJnczogYW55W10pID0+IGFueT4ob2JqOiBUKTogU3RhYmxlPFQ+IHtcbiAgICBtYXAuc2V0KG9iaiwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iajtcbn1cblxuXG4vKipcbiAqIEFsdGVybmF0ZSB1c2VDYWxsYmFjaygpIHdoaWNoIGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lICh3cmFwcGVkKSBmdW5jdGlvbiByZWZlcmVuY2VcbiAqIHNvIHRoYXQgaXQgY2FuIGJlIGV4Y2x1ZGVkIGZyb20gdGhlIGRlcGVuZGVuY3kgYXJyYXlzIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzLlxuICogXG4gKiBJbiBnZW5lcmFsLCBqdXN0IHBhc3MgdGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGJlIHN0YWJsZSAoYnV0IHlvdSBjYW4ndCB1c2UgaXQgZHVyaW5nIHJlbmRlcixcbiAqIHNvIGJlIGNhcmVmdWwhKS4gIEFsdGVybmF0aXZlbHksIGlmIHlvdSBuZWVkIGEgc3RhYmxlIGNhbGxiYWNrIHRoYXQgKipjYW4qKiBiZSB1c2VkXG4gKiBkdXJpbmcgcmVuZGVyLCBwYXNzIGFuIGVtcHR5IGRlcGVuZGVuY3kgYXJyYXkgYW5kIGl0J2xsIGFjdCBsaWtlIGB1c2VDYWxsYmFja2Agd2l0aCBhblxuICogZW1wdHkgZGVwZW5kZW5jeSBhcnJheSwgYnV0IHdpdGggdGhlIGFzc29jaWF0ZWQgc3RhYmxlIHR5cGluZy4gSW4gdGhpcyBjYXNlLCB5b3UgKioqbXVzdCoqKiBlbnN1cmUgdGhhdCBpdFxuICogdHJ1bHkgaGFzIG5vIGRlcGVuZGVuY2llcy9vbmx5IHN0YWJsZSBkZXBlbmRlbmNpZXMhIVxuICovXG4vL2V4cG9ydCBmdW5jdGlvbiB1c2VTdGFibGVDYWxsYmFjazxUIGV4dGVuZHMgKC4uLl9hcmdzOiBhbnlbXSkgPT4gYW55PihmbjogVCwgbm9EZXBzOiBbXSk6IFN0YWJsZTxUPjtcbi8vZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUNhbGxiYWNrPFQgZXh0ZW5kcyAoLi4uX2FyZ3M6IGFueVtdKSA9PiBhbnk+KGZuOiBUKTogU3RhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUNhbGxiYWNrPFQgZXh0ZW5kcyBGdW5jdGlvbiB8IG51bGwgfCB1bmRlZmluZWQ+KGZuOiBOb25OdWxsYWJsZTxUPiwgbm9EZXBzPzogW10gfCBudWxsIHwgdW5kZWZpbmVkKTogU3RhYmxlPE5vbk51bGxhYmxlPFQ+PiB7XG4gICAgdHlwZSBVID0gKE5vbk51bGxhYmxlPFQ+ICYgKCguLi5hcmdzOiBhbnkpID0+IGFueSkpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVN0YWJsZUNhbGxiYWNrXCIsIG5vRGVwcyA9PSBudWxsLCBub0RlcHM/Lmxlbmd0aCwgaXNTdGFibGVHZXR0ZXI8VT4oZm4gYXMgVSkpO1xuICAgIGlmIChpc1N0YWJsZUdldHRlcihmbikpXG4gICAgICAgIHJldHVybiBmbjtcblxuICAgIGlmIChub0RlcHMgPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIgPSB1c2VTdGFibGVHZXR0ZXI8VT4oZm4pO1xuICAgICAgICByZXR1cm4gc2V0SXNTdGFibGVHZXR0ZXIodXNlQ2FsbGJhY2tOYXRpdmU8VT4oKCguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudENhbGxiYWNrR2V0dGVyKCkoLi4uYXJncyk7XG4gICAgICAgIH0pIGFzIFUsIFtdKSk7XG5cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KG5vRGVwcy5sZW5ndGggPT09IDApO1xuICAgICAgICByZXR1cm4gc2V0SXNTdGFibGVHZXR0ZXIodXNlQ2FsbGJhY2tOYXRpdmU8VT4oZm4sIFtdKSk7XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJvdW5jZVJlbmRlcmluZywgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIFBhc3NpdmVTdGF0ZVVwZGF0ZXIsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlT2JqZWN0IH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuLyoqXG4gKiBSZW1pbmRlciBvZiBvcmRlciBvZiBleGVjdXRpb246XG4gKiBcbiAqICogKHRyZWUgbW91bnRzKVxuICogKiBQYXJlbnQgcmVuZGVyc1xuICogKiBDaGlsZHJlbiByZW5kZXJcbiAqICogQ2hpbGRyZW4gcmVjZWl2ZSByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIFBhcmVudCByZWNlaXZlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdHNcbiAqIFxuICogKiAodHJlZSB1bm1vdW50cylcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogUGFyZW50IGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIENoaWxkIGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcbiAqICogUmVuZGVyaW5nIHN0YXJ0cyBhdCB0aGUgcm9vdCwgIGJ1dCBlZmZlY3RzIGFuZCByZWZzIHN0YXJ0IGF0IHRoZSBsZWF2ZXMuXG4gKiAqIHJlZnMgYXJlICp1c3VhbGx5KiBjYWxsZWQgYmVmb3JlIGVmZmVjdHMsIGJ1dCBvbmx5IHdoZW4gdGhhdCBIVE1MRWxlbWVudCByZW5kZXJzLiBCYXNpY2FsbHkganVzdCBhIHJlbWluZGVyIHRoYXQgYSBjb21wb25lbnQgY2FuIGJlIG1vdW50ZWQgd2l0aG91dCBpdCBleGlzdGluZyBpbiB0aGUgRE9NLlxuICovXG5jb25zdCBfY29tbWVudHMgPSB2b2lkICgwKTtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvL21hbmFnZWRDaGlsZHJlblJldHVybjogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNPltcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiXVxuXG4gICAgbWFuYWdlZENoaWxkQ29udGV4dDoge1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5OiBJbnRlcm5hbENoaWxkSW5mbzxNPjtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkOiAoaW5kZXg6IE1bXCJpbmRleFwiXSwgbW91bnRlZDogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkOiAoaW5kZXg6IE1bXCJpbmRleFwiXSkgPT4gKCgpID0+IHZvaWQpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIERvZXMgbm90aGluZyBhdCBydW50aW1lIC0tIHR5cGUgY2hlY2tpbmcgb25seS5cbiAqIFxuICogVGhyb3dzIGEgKFR5cGVzY3JpcHQgY29tcGlsZXIpIGVycm9yIGlmIHRoZSBwYXNzZWQgb2JqZWN0IGlzIGFueXRoaW5nIGJ1dCB0aGUgZW1wdHkgb2JqZWN0IHt9LlxuICogXG4gKiBVc2UgdGhpcyB0byBlbnN1cmUgdGhhdCB5b3VyIHNwcmVhZCBvcGVyYXRvcnMgd29yayBjb3JyZWN0bHkgYW5kIGNvdmVyIGFsbCBjYXNlcy5cbiAqIFxuICogQHBhcmFtIF9hIFRoZSByZW1haW5pbmcgc3ByZWFkIHBhcmFtZXRlcnMgb2YgYSBnaXZlbiBvYmplY3QgdGhhdCB5b3UgZXhwZWN0IHRvIGJlIGVtcHR5IChiZWNhdXNlIHlvdSBwcm9wZXJseSBhY2NvdW50ZWQgZm9yIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGl0LCBhbmQgd2FudCB0byBlbnN1cmUgaXQgc3RheXMgdGhhdCB3YXkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFbXB0eU9iamVjdDxUIGV4dGVuZHMge30+KF9hOiBba2V5b2YgVF0gZXh0ZW5kcyBbbmV2ZXJdID8gVCA6IGBVbmhhbmRsZWQga2V5cyBpbiB0aGlzIHJlc3Qgc3ByZWFkIG9iamVjdCFgKTogdm9pZCB7IH1cblxuXG5cbi8qKlxuICogSW5mb3JtYXRpb24gdGhhdCBjaGlsZHJlbiBhbmQgcGFyZW50cyB1c2UgdG8gY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyLlxuICogXG4gKiAqIGBpbmRleGAgcmVmZXJzIHRvIHdoaWNoIGNoaWxkIHRoaXMgaXMuXG4gKiAqIGBmbGFnc2AgYXJlIHF1aWNrLWFuZC1lYXN5IGdldHRlcnMgYW5kIHNldHRlcnMgdGhhdCB5b3UgY2FuIG9wdGlvbmFsbHkgdXNlXG4gKiAqIGBzdWJJbmZvYCBpcyBhbnl0aGluZyB1c2VkIGJ5IGEgZGVyaXZlZCBob29rLiBgdXNlUm92aW5nVGFiSW5kZXhgLCBmb3IgZXhhbXBsZSwgbmVlZHMgdG8ga25vdyBob3cgdG8gZm9jdXMgYW4gYXJiaXRyYXJ5IGNoaWxkLCBzbyB0aGUgY2hpbGQgcG9wdWxhdGVzIGBpbmZvYCB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGEgbWV0aG9kIGNhbGxlZCBgZm9jdXNTZWxmYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRJbmZvPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+IHtcbiAgICBpbmRleDogVDtcbiAgICAvL2ZsYWdzOiBQYXJ0aWFsPFJlY29yZDxLLCBDaGlsZEZsYWdPcGVyYXRpb25zPj47XG4gICAgLy9zdWJJbmZvOiBNQ1N1YkluZm87XG59XG5cblxuXG5leHBvcnQgdHlwZSBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKG1vdW50ZWQ6IFNldDxUPiwgdW5tb3VudGVkOiBTZXQ8VD4pID0+IHZvaWQpO1xuZXhwb3J0IHR5cGUgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChjYXVzZXJzOiBJdGVyYWJsZTxUPikgPT4gdm9pZCk7XG5cbmludGVyZmFjZSBNQ1A8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZz4ge1xuICAgIC8qKlxuICAgICAqIFJ1bnMgYWZ0ZXIgb25lIG9yIG1vcmUgY2hpbGRyZW4gaGF2ZSB1cGRhdGVkIHRoZWlyIGluZm9ybWF0aW9uIChpbmRleCwgZXRjLikuXG4gICAgICogXG4gICAgICogT25seSBvbmUgd2lsbCBydW4gcGVyIHRpY2ssIGp1c3QgbGlrZSBsYXlvdXRFZmZlY3QsIGJ1dCBpdCBpc24ndFxuICAgICAqICpndWFyYW50ZWVkKiB0byBoYXZlIGFjdHVhbGx5IGJlZW4gYSBjaGFuZ2UuXG4gICAgICovXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxUPjtcblxuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgdGhlIGFib3ZlLCBidXQgb25seSBmb3IgbW91bnQvdW5tb3VudCAob3Igd2hlbiBhIGNoaWxkIGNoYW5nZXMgaXRzIGluZGV4KVxuICAgICAqL1xuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8VD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogTUNQPE1bXCJpbmRleFwiXT47XG59XG5cbi8vIE1DU3ViSW5mbyBjb250YWlucyB0aGUgZW50aXJldHkgb2YgdGhlIHNhdmVkIGRhdGEgZm9yIHRoaXMgY2hpbGQuICBBbGwgb2YgaXQuIEV2ZW4gdHlwZXMgdGhlIHVzZXIgd2lsbCBuZXZlciBiZSBhYmxlIHRvIHBhc3MgaW4gYmVjYXVzZSB0aGV5J3JlIGludGVybmFsbHkgZGVyaXZlZC5cbi8vIFN1YmJlc3RJbmZvIHJlZmVycyB0byB0aGUgYWN0dWFsIHBhcmFtZXRlcnMgdGhlIHVzZXIgcGFzc2VzIGluIHRoYXQgY291bGQgYmUgdG90YWxseSB1bnJlbGF0ZWQuIFxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHByb3BlcnR5IHNoYXJlZCBhbW9uZyBhbGwgbWFuYWdlZCBjaGlsZHJlbi5cbiAgICAvLyBUZWNobmljYWxseSB0aGlzIGlzIHJlZHVuZGFudCB3aXRoIHRoZSBzZWNvbmQgYXJndW1lbnQsIHdoaWNoIGlzLi4uZWguIEJ1dCB0aGUgdHlwZXMgYXJlIGNsZWFyLlxuICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IFBpY2s8TSwgXCJpbmRleFwiPjtcbiAgICBjb250ZXh0OiBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+O1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hpbGQgdGhhdCByZW5kZXJlZCBpdHNlbGYgd2l0aCB0aGUgcmVxdWVzdGVkIGtleS5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqIChldmVuIHRob3VnaCBpdCdzIG5vdCBhIGZ1bmN0aW9uLCB0aGUgaWRlbnRpdHkgb2YgdGhpcyBvYmplY3QgbmV2ZXIgY2hhbmdlcylcbiAgICAgKi9cbiAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHtcbiAgICAgICAgLyoqIFxuICAgICAgICAgKiAqKipTVEFCTEUqKipcbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0ICoqYm90aCoqIGBnZXRDaGlsZHJlbmAgYW5kIHRoZSBgTWFuYWdlZENoaWxkcmVuYCBvYmplY3QgaXQgcmV0dXJucyBhcmUgc3RhYmxlIVxuICAgICAgICAgKiBcbiAgICAgICAgICogVGhpcyBpcyBhIGdldHRlciBpbnN0ZWFkIG9mIGFuIG9iamVjdCBiZWNhdXNlIHdoZW4gZnVuY3Rpb24gY2FsbHMgaGFwcGVuIG91dCBvZiBvcmRlciBpdCdzIGVhc2llciB0byBqdXN0IGhhdmUgYWx3YXlzIGJlZW4gcGFzc2luZyBhbmQgcmV0dXJuIGdldHRlcnMgZXZlcnl3aGVyZSBcbiAgICAgICAgICovXG4gICAgICAgIGdldENoaWxkcmVuKCk6IE1hbmFnZWRDaGlsZHJlbjxNPjtcblxuICAgIH07XG5cbiAgICBjb250ZXh0OiBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88YW55Pj4ge1xuICAgIG1hbmFnZWRDaGlsZFJldHVybjoge1xuICAgICAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG4gICAgfVxufVxuXG4vL2V4cG9ydCB0eXBlIFVzZU1hbmFnZWRDaGlsZDxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxhbnk+PiA9IChhOiBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPE0+KSA9PiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0+O1xuXG5cblxuXG5cblxuLyoqXG4gKiBBYnN0cmFjdGlvbiBvdmVyIHRoZSBtYW5hZ2VkIGNoaWxkcmVuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkcmVuPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4+IHtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0QXQoaW5kZXg6IE1bXCJpbmRleFwiXSk6IE0gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGdldEhpZ2hlc3RJbmRleCgpOiBudW1iZXI7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGZvckVhY2g6IChmOiAoY2hpbGQ6IE0pID0+IHZvaWQpID0+IHZvaWQ7XG5cbiAgICAvKiogKipVTlNUQUJMRSoqLCBhbHNvIGludGVybmFsLXVzZSBvbmx5LCBhbHNvIFRPRE8gbmVlZCBhIHdvcmthcm91bmQgZm9yIHRoaXMgZm9yIHNvcnRhYmxlIGNoaWxkcmVuICovXG4gICAgYXJyYXlTbGljZTogKCkgPT4gTVtdO1xufVxuXG5pbnRlcmZhY2UgSW50ZXJuYWxDaGlsZEluZm88TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88c3RyaW5nIHwgbnVtYmVyPj4ge1xuICAgIGFycjogQXJyYXk8TT47XG4gICAgcmVjOiBQYXJ0aWFsPFJlY29yZDxNW1wiaW5kZXhcIl0sIE0+PjtcbiAgICBoaWdoZXN0SW5kZXg6IG51bWJlcjtcbiAgICBsb3dlc3RJbmRleDogbnVtYmVyO1xufVxuXG4vKipcbiAqIEFsbG93cyBhIHBhcmVudCBjb21wb25lbnQgdG8gYWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IGNlcnRhaW5cbiAqIGNoaWxkIGNvbXBvbmVudHMgb25jZSB0aGV5IGhhdmUgcmVuZGVyZWQuXG4gKiBcbiAqIFRoaXMgaG9vayBpcyBkZXNpZ25lZCB0byBiZSBsaWdodHdlaWdodCwgaW4gdGhhdCB0aGUgcGFyZW50IGtlZXBzIG5vIHN0YXRlXG4gKiBhbmQgcnVucyBubyBlZmZlY3RzLiAgRWFjaCBjaGlsZCAqZG9lcyogcnVuIGFuIGVmZmVjdCwgYnV0IHdpdGggbm8gc3RhdGVcbiAqIGNoYW5nZXMgdW5sZXNzIHlvdSBleHBsaWNpdGx5IHJlcXVlc3QgdGhlbS5cbiAqIFxuICogXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYW5hZ2VkQ2hpbGRyZW48TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88c3RyaW5nIHwgbnVtYmVyPj4ocGFyZW50UGFyYW1ldGVyczogVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxNPik6IFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8TT4ge1xuICAgIHR5cGUgSW5kZXhUeXBlID0gTVtcImluZGV4XCJdO1xuICAgIHR5cGUgSW5mbyA9IE07XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSwgLi4ucmVzdCB9ID0gcGFyZW50UGFyYW1ldGVycztcbiAgICBhc3NlcnRFbXB0eU9iamVjdChyZXN0KTtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1hbmFnZWRDaGlsZHJlblwiLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSk7XG5cbiAgICBjb25zdCBnZXRIaWdoZXN0SW5kZXggPSB1c2VDYWxsYmFjaygoKTogbnVtYmVyID0+IHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4O1xuICAgIH0sIFtdKTtcblxuICAgIC8vIEFsbCB0aGUgaW5mb3JtYXRpb24gd2UgaGF2ZSBhYm91dCBvdXIgY2hpbGRyZW4gaXMgc3RvcmVkIGluIHRoaXMgKipzdGFibGUqKiBhcnJheS5cbiAgICAvLyBBbnkgbXV0YXRpb25zIHRvIHRoaXMgYXJyYXkgKipETyBOT1QqKiB0cmlnZ2VyIGFueSBzb3J0IG9mIGEgcmUtcmVuZGVyLlxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbkFycmF5ID0gdXNlUmVmPEludGVybmFsQ2hpbGRJbmZvPE0+Pih7IGFycjogW10sIHJlYzoge30sIGhpZ2hlc3RJbmRleDogMCwgbG93ZXN0SW5kZXg6IDAgfSk7XG5cbiAgICAvLyBGb3IgaW5kaXJlY3QgYWNjZXNzIHRvIGVhY2ggY2hpbGRcbiAgICAvLyBDb21wYXJlIGdldE1hbmFnZWRDaGlsZEluZm9cbiAgICAvLyBUT0RPOiBUaGUgcHJpbWFyeSB1c2UgZm9yIHRoaXMgaXMgZmxhZ2dhYmxlIGNsb3Nlc3QgZml0c1xuICAgIC8vIHdoaWNoIG5lZWRzIHRvIHNlYXJjaCBhbGwgY2hpbGRyZW4gZm9yIHRoYXQgY2xvc2VzdCBmaXQuXG4gICAgLy8gSXQgd291bGQgYmUgbmljZSBpZiB0aGVyZSB3YXMgc29tZXRoaW5nIGJldHRlciBmb3IgdGhhdC5cbiAgICBjb25zdCBmb3JFYWNoQ2hpbGQgPSB1c2VDYWxsYmFjaygoZjogKGNoaWxkOiBJbmZvKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZClcbiAgICAgICAgICAgICAgICBmKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIGluIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZDogSW5mbyB8IHVuZGVmaW5lZCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2ZpZWxkIGFzIGtleW9mIFJlY29yZDxJbmRleFR5cGUsIEluZm8+XTtcbiAgICAgICAgICAgIGlmIChjaGlsZClcbiAgICAgICAgICAgICAgICBmKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgLy8gUmV0cmlldmVzIHRoZSBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIGNoaWxkIHdpdGggdGhlIGdpdmVuIGluZGV4LlxuICAgIC8vIGB1bmRlZmluZWRgIGlmIG5vdCBjaGlsZCB0aGVyZSwgb3IgaXQncyB1bm1vdW50ZWQuXG4gICAgY29uc3QgZ2V0TWFuYWdlZENoaWxkSW5mbyA9IHVzZUNhbGxiYWNrPE1hbmFnZWRDaGlsZHJlbjxNPltcImdldEF0XCJdPigoaW5kZXg6IEluZGV4VHlwZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5kZXggYXMgbnVtYmVyXSE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tpbmRleCBhcyBJbmRleFR5cGVdITtcbiAgICB9LCBbXSlcblxuICAgIC8vIHRsO2RyIHRoaXMgaXMgYSB3YXkgdG8gaGF2ZSBydW4gdXNlTGF5b3V0RWZmZWN0IG9uY2UgYWZ0ZXIgYWxsIE4gY2hpbGRyZW5cbiAgICAvLyBoYXZlIG1vdW50ZWQgYW5kIHJ1biAqdGhlaXIqIHVzZUxheW91dEVmZmVjdCwgYnV0IGFsc28gKndpdGhvdXQqIHJlLXJlbmRlcmluZ1xuICAgIC8vIG91cnNlbHZlcyBiZWNhdXNlIG9mIGhhdmluZyBhIGBjaGlsZENvdW50YCBzdGF0ZSBvciBhbnl0aGluZyBzaW1pbGFyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgY2hpbGQgY291bnQgcmVmIHVwZGF0ZXMsIHdlIHdhbnQgdGhlIHBhcmVudCB0byBhbHNvIHJ1biBhbiBlZmZlY3RcbiAgICAvLyB0byBtYXliZSBkbyBzb21ldGhpbmcgd2l0aCBhbGwgdGhlc2UgY2hpbGRyZW4gdGhhdCBqdXN0IG1vdW50ZWQuXG4gICAgLy8gVGhlIGVhc2llc3Qgd2F5IHdvdWxkIGJlIHVzZUVmZmVjdCguLi4sIFtjaGlsZENvdW50XSkgYnV0XG4gICAgLy8gdGhhdCB3b3VsZCByZXF1aXJlIHVzIGhhdmluZyBhIGNoaWxkQ291bnQgc3RhdGUsIHRoZW4gY2FsbGluZ1xuICAgIC8vIHNldENoaWxkQ291bnQgYW5kIHJlLXJlbmRlcmluZyBldmVyeSB0aW1lIGNoaWxkcmVuIG1vdW50XG4gICAgLy8gKG9ubHkgb25lIHJlLXJlbmRlciBhdCBhIHRpbWUgdW5sZXNzIGNoaWxkcmVuIGFyZSBzdGFnZ2VyZWQsIGJ1dCBzdGlsbClcbiAgICAvLyBcbiAgICAvLyBBcyBhbiBhbHRlcm5hdGUgc29sdXRpb24sIGFueSB0aW1lIGEgY2hpbGQgdXNlcyBVTEUgb24gbW91bnQsIGl0IHF1ZXVlcyBhIG1pY3JvdGFza1xuICAgIC8vIHRvIGVtdWxhdGUgcnVubmluZyBVTEUgb24gdGhlIHBhcmVudC4gT25seSB0aGUgZmlyc3QgY2hpbGQgd2lsbCBhY3R1YWxseSBxdWV1ZVxuICAgIC8vIHRoZSBtaWNyb3Rhc2sgKGJ5IGNoZWNraW5nIGhhc1JlbW90ZVVMRSBmaXJzdCkgc28gdGhhdCB0aGUgXCJlZmZlY3RcIiBvbmx5XG4gICAgLy8gcnVucyBvbmNlLiBXaGVuIGl0J3MgZG9uZSwgaGFzUmVtb3RlVUxFIGlzIHJlc2V0IHNvIGl0IGNhbiBydW4gYWdhaW4gaWZcbiAgICAvLyBtb3JlIGNoaWxkcmVuIG1vdW50L3VubW91bnQuXG4gICAgY29uc3QgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlUmVmPHsgbW91bnRzOiBTZXQ8SW5kZXhUeXBlPiwgdW5tb3VudHM6IFNldDxJbmRleFR5cGU+IH0gfCBudWxsPihudWxsKTtcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzID0gdXNlUmVmKG5ldyBTZXQ8SW5kZXhUeXBlPigpKTtcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IEluZGV4VHlwZSkgPT4ge1xuXG4gICAgICAgIGlmIChyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuc2l6ZSA9PSAwKSB7XG4gICAgICAgICAgICBkZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Py4ocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmFkZChpbmRleCk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcblxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkTW91bnRlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogSW5kZXhUeXBlLCBtb3VudGVkOiBib29sZWFuKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICghaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIG1vdW50czogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIHVubW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50IS5tb3VudHMsIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50IS51bm1vdW50cylcbiAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXggPSBNYXRoLm1heChtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl07XG4gICAgICAgICAgICAgICAgbGV0IHNoYXZlID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2hhdmUgPD0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoICYmIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW21hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDEgLSBzaGF2ZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICArK3NoYXZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zcGxpY2UobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gc2hhdmUsIHNoYXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50W21vdW50ZWQgPyBcIm1vdW50c1wiIDogXCJ1bm1vdW50c1wiXS5hZGQoaW5kZXgpO1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuID0gdXNlU3RhYmxlT2JqZWN0PE1hbmFnZWRDaGlsZHJlbjxNPj4oe1xuICAgICAgICAuLi57IF86IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQgfSBhcyB7fSxcbiAgICAgICAgZm9yRWFjaDogZm9yRWFjaENoaWxkLFxuICAgICAgICBnZXRBdDogZ2V0TWFuYWdlZENoaWxkSW5mbyxcbiAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0SW5kZXgsXG4gICAgICAgIGFycmF5U2xpY2U6IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zbGljZSgpO1xuICAgICAgICB9LCBbXSlcbiAgICB9KTtcblxuICAgIGNvbnN0IGdldENoaWxkcmVuID0gdXNlQ2FsbGJhY2soKCkgPT4gbWFuYWdlZENoaWxkcmVuLCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheTogbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudCxcbiAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQsXG4gICAgICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkLFxuICAgICAgICAgICAgICAgIGdldENoaWxkcmVuXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH1cbiAgICB9XG59XG5cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYW5hZ2VkQ2hpbGQ8TSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyIHwgc3RyaW5nPj4oaW5mbzogVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxNPiwgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogTSk6IFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU8TT4ge1xuICAgIHR5cGUgSW5kZXhUeXBlID0gTVtcImluZGV4XCJdO1xuXG4gICAgY29uc3QgeyBjb250ZXh0OiB7IG1hbmFnZWRDaGlsZENvbnRleHQ6IHsgZ2V0Q2hpbGRyZW4sIG1hbmFnZWRDaGlsZHJlbkFycmF5LCByZW1vdGVVTEVDaGlsZE1vdW50ZWQsIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCB9IH0gfSA9IGluZm87XG4gICAgY29uc3QgaW5kZXggPSBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLmluZGV4O1xuICAgIC8vIEFueSB0aW1lIG91ciBjaGlsZCBwcm9wcyBjaGFuZ2UsIG1ha2UgdGhhdCBpbmZvcm1hdGlvbiBhdmFpbGFibGVcbiAgICAvLyB0aGUgcGFyZW50IGlmIHRoZXkgbmVlZCBpdC5cbiAgICAvLyBUaGUgcGFyZW50IGNhbiBsaXN0ZW4gZm9yIGFsbCB1cGRhdGVzIGFuZCBvbmx5IGFjdCBvbiB0aGUgb25lcyBpdCBjYXJlcyBhYm91dCxcbiAgICAvLyBhbmQgbXVsdGlwbGUgY2hpbGRyZW4gdXBkYXRpbmcgaW4gdGhlIHNhbWUgdGljayB3aWxsIGFsbCBiZSBzZW50IGF0IG9uY2UuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gSW5zZXJ0IHRoaXMgaW5mb3JtYXRpb24gaW4tcGxhY2VcbiAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5hcnJbaW5kZXggYXMgbnVtYmVyXSA9IHsgLi4ubWFuYWdlZENoaWxkUGFyYW1ldGVycyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkucmVjW2luZGV4IGFzIEluZGV4VHlwZV0gPSB7IC4uLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkKGluZGV4IGFzIEluZGV4VHlwZSk7XG4gICAgfSwgWy4uLk9iamVjdC5lbnRyaWVzKGluZm8pLmZsYXQoOSldKTsgIC8vIDkgaXMgaW5maW5pdHksIHJpZ2h0PyBTdXJlLiBVbnJlbGF0ZWQ6IFRPRE8uXG5cbiAgICAvLyBXaGVuIHdlIG1vdW50LCBub3RpZnkgdGhlIHBhcmVudCB2aWEgcXVldWVNaWNyb3Rhc2tcbiAgICAvLyAoZXZlcnkgY2hpbGQgZG9lcyB0aGlzLCBzbyBldmVyeXRoaW5nJ3MgY29vcmRpbmF0ZWQgdG8gb25seSBxdWV1ZSBhIHNpbmdsZSBtaWNyb3Rhc2sgcGVyIHRpY2spXG4gICAgLy8gRG8gdGhlIHNhbWUgb24gdW5tb3VudC5cbiAgICAvLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgY29tZXMgQUZURVIgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkXG4gICAgLy8gc28gdGhhdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgaGFzIGFjY2VzcyB0byBhbGwgdGhlIGluZm8gb24gbW91bnQuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5kZXggYXMgSW5kZXhUeXBlLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZGV4IGFzIEluZGV4VHlwZSwgZmFsc2UpO1xuICAgIH0sIFtpbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuOiB7IGdldENoaWxkcmVuIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPGFueT4sIFI+IHtcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIGNoaWxkIGlzIGNvbnNpZGVyZWQgYWN0aXZlIG9uIG1vdW50LlxuICAgICAqIFxuICAgICAqIEFmdGVyIG1vdW50LCBjaGFuZ2UgdGhlIGN1cnJlbnQgYWN0aXZlIGNoaWxkIHdpdGggYGNoYW5nZUluZGV4YC5cbiAgICAgKi9cbiAgICBpbml0aWFsSW5kZXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHByb3ZpZGVkLCBpZiB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXggZG9lc24ndCBtYXAgb250byBhbnlcbiAgICAgKiBwcm92aWRlZCBjaGlsZCAoZWl0aGVyIGJlY2F1c2UgaXQncyB0b28gbGFyZ2Ugb3IgdGhhdCBjaGlsZFxuICAgICAqIGRvZXNuJ3QgZXhpc3QpLCB0aGUgY2xvc2VzdCBjaGlsZCB0byB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXhcbiAgICAgKiB3aWxsIGhhdmUgaXRzIGZsYWcgc2V0IGluc3RlYWQuXG4gICAgICogXG4gICAgICogVXNlIHdpdGggY2F1dGlvbiwgYW5kIGNvbnNpZGVyIGhvdyBhIGNoaWxkIGhhdmluZyBpdHMgZmxhZyBzZXRcbiAgICAgKiB3aGlsZSB0aGUgcGFyZW50IHRoaW5rcyBpdCBzaG91bGRuJ3QgYmUgY291bGQgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICAgIGNsb3Nlc3RGaXQ6IGJvb2xlYW47XG5cbiAgICBnZXRDaGlsZHJlbigpOiBNYW5hZ2VkQ2hpbGRyZW48TT47XG5cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmRleCBpcyBzZWxlY3RlZC5cbiAgICAgKiBcbiAgICAgKiBOb3RhYmx5LCB0aGUgdmFsdWUgY2FuIGJlIGRpZmZlcmVudCB0aGFuIHdoYXQgd2FzIGNhbGxlZCB3aXRoIGNoYW5nZUluZGV4KClcbiAgICAgKiBpZiB0aGUgcmVxdWVzdGVkIGluZGV4IGRpZG4ndCBleGlzdCBvciB3YXMgaGlkZGVuLlxuICAgICAqL1xuICAgIG9uSW5kZXhDaGFuZ2U6IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxudW1iZXIgfCBudWxsLCBSPjtcblxuICAgIHNldEF0KGluZGV4OiBNLCB2YWx1ZTogYm9vbGVhbik6IHZvaWQ7XG4gICAgZ2V0QXQoaW5kZXg6IE0pOiBib29sZWFuO1xuICAgIGlzVmFsaWQoaW5kZXg6IE0pOiBib29sZWFuO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hpbGRGbGFnT3BlcmF0aW9ucyB7XG5cbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB3aGV0aGVyIHRoZSBjdXJyZW50IGNoaWxkIGlzIGFjdGl2ZVxuICAgICAqL1xuICAgIGdldDogKCkgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hpbGQgbXVzdCBzZXQgaXRzZWxmIGFzIGFjdGl2ZS9pbmFjdGl2ZSwgd2hhdGV2ZXIgdGhhdCBlbnRhaWxzLlxuICAgICAqIFRoaXMgY291bGQgYmUgYXMgc2ltcGxlIGFzIGEgc2V0U3RhdGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc2V0OiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuIHRydWUgaWYgdGhpcyBjaGlsZCBpcyBhIHZhbGlkIGNhbmRpZGF0ZSB0byBiZSBmbGFnZ2VkLCBhbmQgZmFsc2UgaWYgbm90LlxuICAgICAqIE1vc3QgY2hpbGRyZW4gc2hvdWxkIHJldHVybiB0cnVlLiBSZXR1cm5pbmcgZmFsc2UgaXMgb25seSB1c2VmdWwgdG8gbWFyayBhIGNoaWxkIGFzIFwiaW52YWxpZFwiIGluIHNvbWUgd2F5LlxuICAgICAqIFJlbW92aW5nIGEgY2hpbGQgZnJvbSB0aGUgbGlzdCBkb2VzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nLCBidXQgdGhpcyBsZXRzIHlvdSBrZWVwIHRoZSBjaGlsZCBhcm91bmQuXG4gICAgICovXG4gICAgaXNWYWxpZCgpOiBib29sZWFuO1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdSZXR1cm5UeXBlPFI+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGNoYW5nZUluZGV4OiBQYXNzaXZlU3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGwsIFI+OyAvLyhhcmc6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSkgPT4gbnVtYmVyIHwgbnVsbDtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxuICAgICAqICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBudW1iZXIgfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB1c2VNYW5hZ2VkQ2hpbGRyZW4gdGhhdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY29tbW9uIGNhc2U6XG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXG4gKiAzLiBUaGUgcGFyZW50IGhhcyBjb250cm9sIG92ZXIgd2hvIGlzIFwic2VsZWN0ZWRcIiB2aWEgYSBudW1lcmljYWwgaW5kZXguXG4gKiBcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cbiAqIFxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxuICogXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXI+LCBSPih7IGdldENoaWxkcmVuLCBpbml0aWFsSW5kZXgsIGNsb3Nlc3RGaXQsIG9uSW5kZXhDaGFuZ2UsIGdldEF0LCBzZXRBdCwgaXNWYWxpZCwgfTogVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxNLCBSPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGU8Uj4ge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUNoaWxkcmVuRmxhZ1wiLCBvbkluZGV4Q2hhbmdlLCBnZXRBdCwgc2V0QXQsIGlzVmFsaWQpO1xuXG4gICAgLy8gVE9ETyAobWF5YmU/KTogRXZlbiBpZiB0aGVyZSBpcyBhbiBpbml0aWFsIGluZGV4LCBpdCdzIG5vdCBzZXQgdW50aWwgbW91bnQuIElzIHRoYXQgZmluZT9cbiAgICBjb25zdCBbZ2V0Q3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBudW1iZXIsIFI+KG9uSW5kZXhDaGFuZ2UpO1xuXG4gICAgY29uc3QgW2dldFJlcXVlc3RlZEluZGV4LCBzZXRSZXF1ZXN0ZWRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IG51bWJlciwgUj4obnVsbCk7XG5cbiAgICAvLyAgICBjb25zdCBnZXRGaXROdWxsVG9aZXJvID0gdXNlU3RhYmxlR2V0dGVyKGZpdE51bGxUb1plcm8pO1xuXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gb25DaGlsZHJlbk1vdW50Q2hhbmdlIGFuZCBjaGFuZ2VJbmRleCwgbm90IHB1YmxpYyAoYnV0IGNvdWxkIGJlIEkgZ3Vlc3MpXG4gICAgY29uc3QgZ2V0Q2xvc2VzdEZpdCA9IHVzZUNhbGxiYWNrKChyZXF1ZXN0ZWRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBsZXQgY2xvc2VzdEluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rpc3RhbmNlID0gTWF0aC5hYnMoY2hpbGQuaW5kZXggLSByZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlIHx8IChuZXdEaXN0YW5jZSA9PSBjbG9zZXN0RGlzdGFuY2UgJiYgY2hpbGQuaW5kZXggPCByZXF1ZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGNoaWxkLmluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9zZXN0SW5kZXg7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSEgKi9dKTtcblxuICAgIC8vIEFueSB0aW1lIGEgY2hpbGQgbW91bnRzL3VubW91bnRzLCB3ZSBuZWVkIHRvIGRvdWJsZS1jaGVjayB0byBzZWUgaWYgdGhhdCBhZmZlY3RzIFxuICAgIC8vIHRoZSBcImN1cnJlbnRseSBzZWxlY3RlZFwiIChvciB3aGF0ZXZlcikgaW5kZXguICBUaGUgdHdvIGNhc2VzIHdlJ3JlIGxvb2tpbmcgZm9yOlxuICAgIC8vIDEuIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2hpbGQgdW5tb3VudGVkXG4gICAgLy8gMi4gQSBjaGlsZCBtb3VudGVkLCBhbmQgaXQgbW91bnRzIHdpdGggdGhlIGluZGV4IHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAgY29uc3QgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSBnZXRSZXF1ZXN0ZWRJbmRleCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudENoaWxkID0gY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KTtcblxuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggIT0gbnVsbCAmJiBjbG9zZXN0Rml0ICYmIChyZXF1ZXN0ZWRJbmRleCAhPSBjdXJyZW50SW5kZXggfHwgY3VycmVudENoaWxkID09IG51bGwgfHwgIWlzVmFsaWQoY3VycmVudENoaWxkKSkpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hpbGQpXG4gICAgICAgICAgICAgICAgc2V0QXQoY3VycmVudENoaWxkLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCwgdW5kZWZpbmVkISk7XG4gICAgICAgICAgICBpZiAoY2xvc2VzdEZpdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0Q2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChjbG9zZXN0Rml0Q2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICBzZXRBdChjbG9zZXN0Rml0Q2hpbGQsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsLCBSPj4oKGFyZzogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGwsIFI+PlswXSwgcmVhc29uOiBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbCwgUj4+WzFdKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcoZ2V0UmVxdWVzdGVkSW5kZXgoKSkgOiBhcmcpIGFzIE1bXCJpbmRleFwiXTtcbiAgICAgICAgLy9pZiAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCAmJiBnZXRGaXROdWxsVG9aZXJvKCkpXG4gICAgICAgIC8vICAgIHJlcXVlc3RlZEluZGV4ID0gMDtcblxuICAgICAgICBzZXRSZXF1ZXN0ZWRJbmRleChyZXF1ZXN0ZWRJbmRleCwgcmVhc29uIGFzIFIpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSByZXF1ZXN0ZWRJbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcblxuICAgICAgICBsZXQgbmV3TWF0Y2hpbmdDaGlsZCA9IChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KHJlcXVlc3RlZEluZGV4KSk7XG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBFYXN5IGNhc2VcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsLCByZWFzb24gYXMgUik7XG4gICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICBzZXRBdChvbGRNYXRjaGluZ0NoaWxkLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZXdNYXRjaGluZ0NoaWxkICYmIGlzVmFsaWQobmV3TWF0Y2hpbmdDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgocmVxdWVzdGVkSW5kZXgsIHJlYXNvbiBhcyBSKTtcbiAgICAgICAgICAgICAgICBpZiAob2xkTWF0Y2hpbmdDaGlsZClcbiAgICAgICAgICAgICAgICAgICAgc2V0QXQob2xkTWF0Y2hpbmdDaGlsZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNldEF0KG5ld01hdGNoaW5nQ2hpbGQsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChjbG9zZXN0Rml0SW5kZXgsIHJlYXNvbiBhcyBSKTtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdEZpdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF0Y2hpbmdDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChuZXdNYXRjaGluZ0NoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXQob2xkTWF0Y2hpbmdDaGlsZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzZXRBdChuZXdNYXRjaGluZ0NoaWxkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3RGaXRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRNYXRjaGluZ0NoaWxkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0QXQob2xkTWF0Y2hpbmdDaGlsZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBSdW4gb25jZSwgb24gbW91bnRcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjaGFuZ2VJbmRleChpbml0aWFsSW5kZXggPz8gbnVsbCwgdW5kZWZpbmVkKTtcbiAgICB9LCBbXSlcblxuICAgIHJldHVybiB7IGNoYW5nZUluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdCwgZ2V0Q3VycmVudEluZGV4IH07XG59XG5cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkQ2hpbGRyZW4obGhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJjaGlsZHJlblwiXSwgcmhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJjaGlsZHJlblwiXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcImNoaWxkcmVuXCJdIHtcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJocztcbiAgICB9XG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxocztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgbGhzLCByaHMpO1xuICAgIH1cbn1cbiIsImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKWZvcih0PTA7dDxlLmxlbmd0aDt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpO2Vsc2UgZm9yKHQgaW4gZSllW3RdJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCI7Zjxhcmd1bWVudHMubGVuZ3RoOykoZT1hcmd1bWVudHNbZisrXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyIsImltcG9ydCB7IGRlZmF1bHQgYXMgY2xzeCB9IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xudHlwZSBDID0gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2xhc3NOYW1lXCJdO1xuLyoqXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXG4gKiBEdXBsaWNhdGUgY2xhc3NlcyBhcmUgcmVtb3ZlZCAob3JkZXIgZG9lc24ndCBtYXR0ZXIgYW55d2F5KS5cbiAqIFxuICogQHBhcmFtIGxocyBDbGFzc2VzIG9mIHRoZSBmaXJzdCBjb21wb25lbnRcbiAqIEBwYXJhbSByaHMgQ2xhc3NlcyBvZiB0aGUgc2Vjb25kIGNvbXBvbmVudFxuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIGFsbCBjb21iaW5lZCBjbGFzc2VzIGZyb20gYm90aCBhcmd1bWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDbGFzc2VzKGxoc0NsYXNzOiBDLCBsaHNDbGFzc05hbWU6IEMsIHJoc0NsYXNzOiBDLCByaHNDbGFzc05hbWU6IEMpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuXG4gICAgLy8gTm90ZTogRm9yIHRoZSBzYWtlIG9mIGZvcndhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmdW5jdGlvbiBpcyBsYWJlbGxlZCBhc1xuICAgIC8vIGEgaG9vaywgYnV0IGFzIGl0IHVzZXMgbm8gb3RoZXIgaG9va3MgaXQgdGVjaG5pY2FsbHkgaXNuJ3Qgb25lLlxuXG4gICAgaWYgKGxoc0NsYXNzIHx8IHJoc0NsYXNzIHx8IGxoc0NsYXNzTmFtZSB8fCByaHNDbGFzc05hbWUpIHtcbiAgICAgICAgY29uc3QgbGhzQ2xhc3NlcyA9IGNsc3gobGhzQ2xhc3MsIGxoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKGxoc0NsYXNzZXMpLCAuLi5BcnJheS5mcm9tKHJoc0NsYXNzZXMpXSlcblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCwgUmVmLCBSZWZDYWxsYmFjaywgUmVmT2JqZWN0IH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZjxUPihpbnN0YW5jZTogVCB8IG51bGwsIHJlZjogUmVmPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVmICE9IG51bGwpIHtcbiAgICAgICAgKHJlZiBhcyBSZWZPYmplY3Q8VCB8IG51bGw+KS5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UsIFwiVW5rbm93biByZWYgdHlwZSBmb3VuZCB0aGF0IHdhcyBuZWl0aGVyIGEgUmVmQ2FsbGJhY2sgbm9yIGEgUmVmT2JqZWN0XCIpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxuICogQHBhcmFtIGxocyBcbiAqIEBwYXJhbSByaHMgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFJlZnM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PihyaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W1wicmVmXCJdLCBsaHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W1wicmVmXCJdKSB7XG4gICAgY29uc3QgY29tYmluZWQ6IFJlZkNhbGxiYWNrPEU+ID0gdXNlQ2FsbGJhY2soKGN1cnJlbnQ6IEUgfCBudWxsKSA9PiB7XG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgbGhzKTtcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCByaHMpO1xuICAgIH0sIFtsaHMsIHJoc10pO1xuXG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQhO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzITtcbiAgICB9XG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxocyE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuZnVuY3Rpb24gc3R5bGVTdHJpbmdUb09iamVjdChzdHlsZTogc3RyaW5nKTogaC5KU1guQ1NTUHJvcGVydGllcyB7XG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoc3R5bGUuc3BsaXQoXCI7XCIpLm1hcChzdGF0ZW1lbnQgPT4gc3RhdGVtZW50LnNwbGl0KFwiOlwiKSkpIGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllcztcbn1cblxuLyoqXG4gKiBNZXJnZXMgdHdvIHN0eWxlIG9iamVjdHMsIHJldHVybmluZyB0aGUgcmVzdWx0LlxuICogXG4gKiBAcGFyYW0gc3R5bGUgVGhlIHVzZXItZ2l2ZW4gc3R5bGUgcHJvcCBmb3IgdGhpcyBjb21wb25lbnRcbiAqIEBwYXJhbSBvYmogVGhlIENTUyBwcm9wZXJ0aWVzIHlvdSB3YW50IGFkZGVkIHRvIHRoZSB1c2VyLWdpdmVuIHN0eWxlXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRTdHlsZXMobGhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSwgcmhzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcInN0eWxlXCJdIHtcblxuICAgIC8vIEVhc3kgY2FzZSwgd2hlbiB0aGVyZSBhcmUgbm8gc3R5bGVzIHRvIG1lcmdlIHJldHVybiBub3RoaW5nLlxuICAgIGlmICghbGhzICYmICFyaHMpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XG4gICAgICAgIC8vIEVhc3kgY2FzZXMsIHdoZW4gb25lIGlzIG51bGwgYW5kIHRoZSBvdGhlciBpc24ndC5cbiAgICAgICAgaWYgKGxocyAmJiAhcmhzKVxuICAgICAgICAgICAgcmV0dXJuIGxocztcbiAgICAgICAgaWYgKCFsaHMgJiYgcmhzKVxuICAgICAgICAgICAgcmV0dXJuIHJocztcblxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIHR5cGUgdG8gYW4gb2JqZWN0IGJhZyB0eXBlIGFuZCBydW4gaXQgYWdhaW4uXG4gICAgICAgIGlmIChsaHMgJiYgcmhzKSB7XG4gICAgICAgICAgICAvLyAodXNlTWVyZ2VkU3R5bGVzIGlzbid0IGEgdHJ1ZSBob29rIC0tIHRoaXMgaXNuJ3QgYSB2aW9sYXRpb24pXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxocyA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRTdHlsZXMoc3R5bGVTdHJpbmdUb09iamVjdChsaHMgYXMgc3RyaW5nKSwgcmhzKSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgc3R5bGVTdHJpbmdUb09iamVjdChyaHMgYXMgc3RyaW5nKSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvZ2ljPz8/XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gVGhleSdyZSBib3RoIHN0cmluZ3MsIGp1c3QgY29uY2F0ZW5hdGUgdGhlbS5cbiAgICBpZiAodHlwZW9mIGxocyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBgJHtsaHN9OyR7cmhzID8/IFwiXCJ9YCBhcyB1bmtub3duIGFzIHN0cmluZztcbiAgICB9XG5cbiAgICAvLyBUaGV5J3JlIGJvdGggb2JqZWN0cywganVzdCBtZXJnZSB0aGVtLlxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLihsaHMgPz8ge30pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXMsXG4gICAgICAgIC4uLihyaHMgPz8ge30pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcbiAgICB9IGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW5cIjtcbmltcG9ydCB7IHVzZU1lcmdlZENsYXNzZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNsYXNzZXNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFJlZnMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXJlZnNcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzXCI7XG5cbmxldCBsb2cgPSBjb25zb2xlLndhcm47XG5cbi8qXG50eXBlIElzRW1wdHlPYmplY3Q8VD4gPSBba2V5b2YgVF0gZXh0ZW5kcyBbbmV2ZXJdPyB0cnVlIDogZmFsc2U7XG5cbmV4cG9ydCB0eXBlIEV4dHJhY3RlZFByb3BzPE8gZXh0ZW5kcyB7fT4gPSB7IFtLIGluIGtleW9mIE9dOiBQaWNrPE9bS10sIChcInByb3BzU3RhYmxlXCIgfCBcInByb3BzVW5zdGFibGVcIikgJiBrZXlvZiBPW0tdPiB9O1xuXG5jb25zdCBvOiBFeHRyYWN0ZWRQcm9wczxVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGU8YW55LCBhbnk+PiA9IHtcbiAgICBhc0NoaWxkUm93T2ZUYWJsZToge1xuXG4gICAgfSxcbiAgICBhc1BhcmVudFJvd09mQ2VsbHM6IHt9XG59Ki9cblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdQcm9wQ29uZmxpY3RzKGxvZzI6IHR5cGVvZiBjb25zb2xlW1wibG9nXCJdKSB7XG4gICAgbG9nID0gbG9nMlxufVxuXG5cbi8qKlxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXG4gKiBcbiAqIFRoZSBob29rIGlzIGF3YXJlIG9mIGFuZCBjYW4gaW50ZWxsaWdlbnRseSBtZXJnZSBgY2xhc3NOYW1lYCwgYGNsYXNzYCwgYHN0eWxlYCwgYHJlZmAsIGFuZCBhbGwgZXZlbnQgaGFuZGxlcnMuXG4gKiBAcGFyYW0gbGhzMiBcbiAqIEBwYXJhbSByaHMyIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRQcm9wczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KC4uLmFsbFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltdKSB7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTWVyZ2VkUHJvcHNcIiwgYWxsUHJvcHMubGVuZ3RoKTtcbiAgICBsZXQgcmV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiA9IHt9O1xuICAgIGZvciAobGV0IG5leHRQcm9wcyBvZiBhbGxQcm9wcykge1xuICAgICAgICByZXQgPSB1c2VNZXJnZWRQcm9wczI8RT4ocmV0LCBuZXh0UHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59XG5cbmNvbnN0IGtub3ducyA9IG5ldyBTZXQ8c3RyaW5nPihbXCJjaGlsZHJlblwiLCBcInJlZlwiLCBcImNsYXNzTmFtZVwiLCBcImNsYXNzXCIsIFwic3R5bGVcIl0pXG5cbmZ1bmN0aW9uIG1lcmdlVW5rbm93bihrZXk6IHN0cmluZywgbGhzVmFsdWU6IHVua25vd24sIHJoc1ZhbHVlOiB1bmtub3duKSB7XG5cbiAgICBpZiAodHlwZW9mIGxoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcblxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggZnVuY3Rpb25zIHRoYXQgY2FuIGJlIG1lcmdlZCAob3Igb25lJ3MgYSBmdW5jdGlvbiBhbmQgdGhlIG90aGVyJ3MgbnVsbCkuXG4gICAgICAgIC8vIE5vdCBhbiAqZWFzeSogY2FzZSwgYnV0IGEgd2VsbC1kZWZpbmVkIG9uZS5cbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VGdW5jdGlvbnMobGhzVmFsdWUgYXMgbmV2ZXIsIHJoc1ZhbHVlIGFzIG5ldmVyKTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZCBhcyBuZXZlcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XG4gICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsICYmIHJoc1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHNWYWx1ZSBhcyBuZXZlcjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbGhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxoc1ZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbGhzVmFsdWUgYXMgbmV2ZXI7XG4gICAgICAgIGVsc2UgaWYgKChyaHNWYWx1ZSBhcyBhbnkpID09IGxoc1ZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJIG1lYW4sIHRoZXkncmUgdGhlIHNhbWUgdmFsdWUgYXQgbGVhc3RcbiAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBOb3QgcmVhbGx5IGlkZWFsIHRob3VnaC5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFVnaC5cbiAgICAgICAgICAgIC8vIE5vIGdvb2Qgc3RyYXRlZ2llcyBoZXJlLCBqdXN0IGxvZyBpdCBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICAgIGxvZz8uKGBUaGUgcHJvcCBcIiR7a2V5fVwiIGNhbm5vdCBzaW11bHRhbmVvdXNseSBiZSB0aGUgdmFsdWVzICR7bGhzVmFsdWV9IGFuZCAke3Joc1ZhbHVlfS4gT25lIG11c3QgYmUgY2hvc2VuIG91dHNpZGUgb2YgdXNlTWVyZ2VkUHJvcHMuYCk7XG4gICAgICAgICAgICByZXR1cm4gcmhzVmFsdWUgYXMgbmV2ZXJcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24uXG4gKiBcbiAqIFRoaXMgaXMgb25lIG9mIHRoZSBtb3N0IGNvbW1vbmx5IGNhbGxlZCBmdW5jdGlvbnMgaW4gdGhpcyBhbmQgY29uc3VtZXIgbGlicmFyaWVzLFxuICogc28gaXQgdHJhZGVzIGEgYml0IG9mIHJlYWRhYmlsaXR5IGZvciBzcGVlZCAoaS5lLiB3ZSBkb24ndCBkZWNvbXBvc2Ugb2JqZWN0cyBhbmQganVzdCBkbyByZWd1bGFyIHByb3BlcnR5IGFjY2VzcywgaXRlcmF0ZSB3aXRoIGBmb3IuLi5pbmAsIGluc3RlYWQgb2YgYE9iamVjdC5lbnRyaWVzYCwgZXRjLilcbiAqL1xuZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHMyPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4obGhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgcmhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcblxuICAgIFxuICAgIGNvbnN0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7XG4gICAgICAgIHJlZjogdXNlTWVyZ2VkUmVmczxFPihsaHNBbGwucmVmLCByaHNBbGwucmVmKSxcbiAgICAgICAgc3R5bGU6IHVzZU1lcmdlZFN0eWxlcyhsaHNBbGwuc3R5bGUsIHJoc0FsbC5zdHlsZSksXG4gICAgICAgIGNsYXNzTmFtZTogdXNlTWVyZ2VkQ2xhc3NlcyhsaHNBbGxbXCJjbGFzc1wiXSwgbGhzQWxsLmNsYXNzTmFtZSwgcmhzQWxsW1wiY2xhc3NcIl0sIHJoc0FsbC5jbGFzc05hbWUpLFxuICAgICAgICBjaGlsZHJlbjogdXNlTWVyZ2VkQ2hpbGRyZW4obGhzQWxsLmNoaWxkcmVuLCByaHNBbGwuY2hpbGRyZW4pLFxuICAgIH0gYXMgYW55O1xuXG4gICAgaWYgKHJldC5yZWYgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5yZWY7XG4gICAgaWYgKHJldC5zdHlsZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnN0eWxlO1xuICAgIGlmIChyZXQuY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2xhc3NOYW1lO1xuICAgIGlmIChyZXRbXCJjbGFzc1wiXSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0W1wiY2xhc3NcIl07XG4gICAgaWYgKHJldC5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNoaWxkcmVuO1xuXG4gICAgZm9yIChjb25zdCBsaHNLZXlVIGluIGxoc0FsbCkge1xuICAgICAgICBjb25zdCBsaHNLZXkgPSBsaHNLZXlVIGFzIGtleW9mIHR5cGVvZiBsaHNBbGw7XG4gICAgICAgIGlmIChrbm93bnMuaGFzKGxoc0tleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmV0W2xoc0tleV0gPSBsaHNBbGxbbGhzS2V5XTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHJoc0tleVUgaW4gcmhzQWxsKSB7XG4gICAgICAgIGNvbnN0IHJoc0tleSA9IHJoc0tleVUgYXMga2V5b2YgdHlwZW9mIHJoc0FsbDtcbiAgICAgICAgaWYgKGtub3ducy5oYXMocmhzS2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXRbcmhzS2V5XSA9IG1lcmdlVW5rbm93bihyaHNLZXksIHJldFtyaHNLZXldLCByaHNBbGxbcmhzS2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcblxufVxuXG5mdW5jdGlvbiBtZXJnZUZ1bmN0aW9uczxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4obGhzOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBVIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuXG4gICAgaWYgKCFsaHMpXG4gICAgICAgIHJldHVybiByaHM7XG4gICAgaWYgKCFyaHMpXG4gICAgICAgIHJldHVybiBsaHM7XG5cbiAgICByZXR1cm4gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pID0+IHtcbiAgICAgICAgY29uc3QgbHYgPSBsaHMoLi4uYXJncyk7XG4gICAgICAgIGNvbnN0IHJ2ID0gcmhzKC4uLmFyZ3MpO1xuXG4gICAgICAgIGlmIChsdiBpbnN0YW5jZW9mIFByb21pc2UgfHwgcnYgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcbiAgICB9O1xufVxuXG4vKlxuZnVuY3Rpb24gdGVzdDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SFRNTElucHV0RWxlbWVudD4+KHByb3BzOiBQKSB7XG5cbiAgICBjb25zdCBpZDA6IEdlbmVyaWNHZXQ8e30sIFwiaWRcIiwgc3RyaW5nPiA9IFwiXCI7XG4gICAgY29uc3QgaWQzOiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaWQ0OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaWQ1OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaWQ2OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XG4gICAgLy9jb25zdCBpZDI6IFppcFNpbmdsZTxzdHJpbmcgfCB1bmRlZmluZWQsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaWQxOiBaaXBPYmplY3Q8eyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IHN0cmluZyB9PiA9IHsgaWQ6IHVuZGVmaW5lZCB9O1xuXG4gICAgdHlwZSBNMSA9IEdlbmVyaWNHZXQ8UCwgXCJzdHlsZVwiLCBzdHJpbmc+O1xuICAgIHR5cGUgTTIgPSBHZW5lcmljR2V0PHt9LCBcInN0eWxlXCIsIHN0cmluZz47XG4gICAgY29uc3QgbTE6IE0xID0gXCJcIjtcbiAgICBjb25zdCBtMjogTTEgPSB1bmRlZmluZWQ7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcbiAgICBjb25zdCBtMzogTTEgPSAwO1xuXG4gICAgY29uc3QgbTQ6IE0yID0gXCJcIjtcbiAgICBjb25zdCBtNTogTTIgPSB1bmRlZmluZWQ7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcbiAgICBjb25zdCBtNjogTTIgPSAwO1xuXG4gICAgY29uc3QgcDE6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xuICAgIGNvbnN0IHAyOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogXCJzdHJpbmdcIiB9KTtcbiAgICBjb25zdCBwMzogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwgeyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IHVuZGVmaW5lZCB9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoeyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IHVuZGVmaW5lZCB9KTtcbiAgICBjb25zdCBwNDogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHt9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHt9KTtcbiAgICBjb25zdCBwNSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHt9KTtcbiAgICBjb25zdCBwNiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IHVuZGVmaW5lZCB9KTtcbiAgICBjb25zdCBwNyA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IFwic3RyaW5nXCIgfSk7XG5cblxuICAgIHAxLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcDIuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXG4gICAgcDMuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXG4gICAgcDQuaWQ/LmNvbmNhdChcIlwiKTtcblxuXG4gICAgcDUuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICBwNi5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHA3LmlkPy5jb25jYXQoXCJcIik7XG5cbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXG4gICAgcDUuaWQuY29uY2F0KFwiXCIpO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcbiAgICBwNi5pZC5jb25jYXQoXCJcIik7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxuICAgIHA3LmlkLmNvbmNhdChcIlwiKTtcblxuXG4gICAgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XG4gICAgZWxzZSBpZiAocDUuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxuICAgIGVsc2Uge1xuICAgICAgICBhY2NlcHRzTmV2ZXIocDUuYWxsb3dGdWxsU2NyZWVuKTtcbiAgICB9XG5cblxuICAgIGlmIChwNi5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cbiAgICBlbHNlIGlmIChwNi5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjZXB0c05ldmVyKHA2LmFsbG93RnVsbFNjcmVlbik7XG4gICAgfVxuXG5cbiAgICBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjY2VwdHNOZXZlcihwNy5hbGxvd0Z1bGxTY3JlZW4pO1xuICAgIH1cblxuXG4gICAgLy8gTWFrZSBzdXJlIGl0IHdvcmtzIHJlY3Vyc2l2ZWx5XG4gICAgY29uc3QgcjFhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDEpO1xuICAgIGNvbnN0IHIxYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAxKTtcbiAgICBjb25zdCByMmEgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwMik7XG4gICAgY29uc3QgcjJiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDIpO1xuICAgIGNvbnN0IHIzYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAzKTtcbiAgICBjb25zdCByM2IgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwMyk7XG4gICAgY29uc3QgcjRhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDQpO1xuICAgIGNvbnN0IHI0YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA0KTtcbiAgICBjb25zdCByNWEgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwNSk7XG4gICAgY29uc3QgcjViID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDUpO1xuICAgIGNvbnN0IHI2YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA2KTtcbiAgICBjb25zdCByNmIgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwNik7XG4gICAgY29uc3QgcjdhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDcpO1xuICAgIGNvbnN0IHI3YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA3KTtcblxuXG4gICAgcjFhLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcjFiLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcjJhLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcjJiLmlkPy5jb25jYXQoXCJcIik7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXG4gICAgcjNhLmlkPy5jb25jYXQoXCJcIik7XG4gICAgcjNiLmlkPy5jb25jYXQoXCJcIik7XG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxuICAgIHI0YS5pZD8uY29uY2F0KFwiXCIpO1xuICAgIHI0Yi5pZD8uY29uY2F0KFwiXCIpO1xuXG5cbiAgICByNWEuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICByNWIuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICByNmEuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICByNmIuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICByN2EuaWQ/LmNvbmNhdChcIlwiKTtcbiAgICByN2IuaWQ/LmNvbmNhdChcIlwiKTtcblxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcbiAgICByNWEuaWQuY29uY2F0KFwiXCIpO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcbiAgICByNWIuaWQuY29uY2F0KFwiXCIpO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcbiAgICByNmEuaWQuY29uY2F0KFwiXCIpO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcbiAgICByNmIuaWQuY29uY2F0KFwiXCIpO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcbiAgICByN2EuaWQuY29uY2F0KFwiXCIpO1xuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcbiAgICByN2IuaWQuY29uY2F0KFwiXCIpO1xuXG5cbiAgICBpZiAocjVhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjY2VwdHNOZXZlcihyNWEuYWxsb3dGdWxsU2NyZWVuKTtcbiAgICB9XG5cblxuICAgIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XG4gICAgZWxzZSBpZiAocjViLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XG4gICAgZWxzZSBpZiAocjViLmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjZXB0c05ldmVyKHI1Yi5hbGxvd0Z1bGxTY3JlZW4pO1xuICAgIH1cblxuXG4gICAgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxuICAgIGVsc2Uge1xuICAgICAgICBhY2NlcHRzTmV2ZXIocjZhLmFsbG93RnVsbFNjcmVlbik7XG4gICAgfVxuXG5cbiAgICBpZiAocjZiLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XG4gICAgZWxzZSB7XG4gICAgICAgIGFjY2VwdHNOZXZlcihyNmIuYWxsb3dGdWxsU2NyZWVuKTtcbiAgICB9XG5cblxuICAgIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XG4gICAgZWxzZSBpZiAocjdhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XG4gICAgZWxzZSBpZiAocjdhLmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cbiAgICBlbHNlIHtcbiAgICAgICAgYWNjZXB0c05ldmVyKHI3YS5hbGxvd0Z1bGxTY3JlZW4pO1xuICAgIH1cblxuXG4gICAgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxuICAgIGVsc2Uge1xuICAgICAgICBhY2NlcHRzTmV2ZXIocjdiLmFsbG93RnVsbFNjcmVlbik7XG4gICAgfVxuXG59XG5mdW5jdGlvbiBhY2NlcHRzTmV2ZXIobjogbmV2ZXIpIHt9XG4qLyIsImltcG9ydCB7IGgsIFByZWFjdERPTUF0dHJpYnV0ZXMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5cbi8qKlxuICogVGhpcyBpcyB1c2VkIHRvIHNlbGVjdCAqanVzdCogdGhlIHR5cGVkIGFkZEV2ZW50TGlzdGVuZXIgXG4gKiBhbmQgbm90IHRoZSBnZW5lcmljIFwiSSdsbCBhY2NlcHQgYW55IHN0cmluZyBhbmQgYW55IGhhbmRsZXJcIiBvbmUuXG4gKiBcbiAqIFRPRE86IFRoaXMgXCJcIlwid29ya3NcIlwiXCIgYnV0IGl0J3Mgbm90IGdyZWF0IGFuZCBpbXBsaWNpdGx5IHJlbGllcyBvblxuICogbGliLmRvbS50cyBhbHdheXMgZ2l2ZWluZyB0aGUgdHdvIG92ZXJsb2FkcyBpbiB0aGUgc2FtZSBvcmRlciwgd2l0aCB0aGVcbiAqIHR5cGVkIG9uZSBmaXJzdC4gKlRoYXQqIHByb2JhYmx5IHdvbid0IGNoYW5nZSwgYnV0IGlmIG1vcmUgb3ZlcmxvYWRzXG4gKiBhcmUgZXZlciBhZGRlZCB0aGlzIHdpbGwgbmVlZCBhZGp1c3RtZW50LlxuICogXG4gKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUyNzYxMTU2IGZvciBob3cgc2VsZWN0aW5nIHRoZSBjb3JyZWN0IG92ZXJsb2FkIHdvcmtzLlxuICovXG50eXBlIEZpcnN0T3ZlcmxvYWRQYXJhbWV0ZXJzPFQ+ID1cbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGluZmVyIFIgfSA/IFIgOlxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueSB9ID8gUiA6XG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueSB9ID8gUiA6XG4gICAgVCBleHRlbmRzICguLi5hcmdzOiBpbmZlciBSKSA9PiBhbnkgPyBSIDogW107XG5cbi8vIEdldCBqdXN0IHRoZSB0eXBlZCB2ZXJzaW9uIG9mIGFkZEV2ZW50TGlzdGVuZXIsIGlmIGl0IGV4aXN0c1xudHlwZSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9ICguLi5hcmdzOiBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczwoVFtcImFkZEV2ZW50TGlzdGVuZXJcIl0pPikgPT4gdm9pZDtcblxuLy8gUmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgXCJhZGRFdmVudExpc3RlbmVyXCIgKHRoZSBldmVudCB0eXBlIGFzIGEgc3RyaW5nKVxudHlwZSBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+IGV4dGVuZHMgKCh0eXBlOiBpbmZlciBLMiwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBLMiA6IHN0cmluZztcblxuXG4vLyBUT0RPOiBUaGlzIGlzbid0IHF1aXRlIGFibGUgdG8gbmFycm93IGRvd24gdGhlIGV4YWN0IGV2ZW50IHR5cGUgZm9yIHVua25vd24gcmVhc29ucy5cbi8vIEluc3RlYWQgaXQgcmV0dXJucyBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgZXZlbnQgdHlwZXMsIHdoaWNoIGlzLi4uZmluZSwgSSBndWVzcy5cbi8vIEkgZG9uJ3Qga25vdyB3aHkgYGluZmVyIEhgIGlzIGRvaW5nIHRoYXQgd2hlbiB0aGUgdHlwZSBzaG91bGQgYmUgbmFycm93ZWQgYnkgYFRgIHRob3VnaC4uLlxuLy8gTm90ZSB0aGF0IHRoZSB0eXBlIHBhcmFtZXRlciBpcyBzdGlsbCB1c2VkLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IG5hcnJvdyBkb3duIHRoZSB0eXBlLFxuLy8gYmVjYXVzZSBvdGhlcndpc2UsIGluc3RlYWQgb2YgYmVpbmcgYSB1bmlvbiBvZiBhbGwgdHlwZXMsIGl0J3MganVzdCBgYW55YFxudHlwZSBUeXBlZEV2ZW50SGFuZGxlcjxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFQgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFPj4gPSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8RT4gZXh0ZW5kcyAoKHR5cGU6IFQsIGhhbmRsZXI6IGluZmVyIEgsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gTm9uTnVsbGFibGU8SD4gOiBuZXZlcjtcbi8vKChUeXBlZEFkZEV2ZW50TGlzdGVuZXI8RT4gJiAoKHR5cGU6IFQsIGhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZCwgLi4uYXJnczogYW55W10pID0+IGFueSkpIGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogaW5mZXIgSCkgPT4gYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IEggOiBGdW5jdGlvbikgLyomIChUIGV4dGVuZHMga2V5b2YgR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwPyBHbG9iYWxFdmVudEhhbmRsZXJzRXZlbnRNYXBbVF0gOiAoZTogRXZlbnQpID0+IHZvaWQpKi87XG5cbnR5cGUgUGFyYW1ldGVyczI8VCBleHRlbmRzIChFdmVudExpc3RlbmVyT2JqZWN0IHwgKCguLi5hcmdzOiBhbnkpID0+IGFueSkpPiA9XG4gICAgVCBleHRlbmRzIEV2ZW50TGlzdGVuZXJPYmplY3QgPyBQYXJhbWV0ZXJzPFRbXCJoYW5kbGVFdmVudFwiXT4gOlxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUCkgPT4gYW55ID8gUCA6IG5ldmVyO1xuXG5cbnR5cGUgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFQgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFPj4gPSBQYXJhbWV0ZXJzMjxUeXBlZEV2ZW50SGFuZGxlcjxFLCBUPj5bMF07XG5cblxuLyoqXG4gKiBBbGxvd3MgYXR0YWNoaW5nIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW55ICpub24tUHJlYWN0KiBlbGVtZW50LCBhbmQgcmVtb3ZpbmcgaXQgd2hlbiB0aGUgY29tcG9uZW50IHVzaW5nIHRoZSBob29rIHVubW91bnRzLiBUaGUgY2FsbGJhY2sgZG9lcyBub3QgbmVlZCB0byBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXG4gKiBcbiAqIER1ZSB0byB0eXBpbmcgbGltaXRhdGlvbnMsIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgbGlrZSB0aGlzOlxuICogXG4gKiBgdXNlRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiaW5wdXRcIik8SW5wdXRFdmVudD4oZSA9PiB7fSlgXG4gKiBcbiAqIFRoZSB0eXBlIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCBidXQgbmFycm93cyBkb3duIHRoZSB0eXBlIGZyb20gXCJhIHVuaW9uIG9mIGFsbCBldmVudHNcIiB0byB3aGF0ZXZlciB5b3Ugc3BlY2lmeSwgYW5kIGVycm9ycyBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICogXG4gKiBUaGVyZSBpcyBhIHNlcGFyYXRlIHZlcnNpb24gdGhhdCBhdHRhY2hlcyBldmVudCBoYW5kbGVycyB0byBhIHNldCBvZiBwcm9wcy4gXG4gKiBJdCB0YWtlcyBkaWZmZXJlbnQgZXZlbnQgc3RyaW5nIHR5cGVzIChvbkV2ZW50IHZzIG9uZXZlbnQpLlxuICogXG4gKiBAcGFyYW0gdGFyZ2V0IEEgKm5vbi1QcmVhY3QqIG5vZGUgdG8gYXR0YWNoIHRoZSBldmVudCB0by5cbiAqIEByZXR1cm5zXG4gKiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VHbG9iYWxIYW5kbGVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4sIEggZXh0ZW5kcyBUeXBlZEV2ZW50SGFuZGxlckV2ZW50PFQsIEV2ZW50VHlwZT4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgKChlOiBIKSA9PiB2b2lkKSwgb3B0aW9ucz86IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xuXG4gICAgLy8gTm90ZSB0byBzZWxmOiBUaGUgdHlwaW5nIGRvZXNuJ3QgaW1wcm92ZSBldmVuIGlmIHRoaXMgaXMgc3BsaXQgdXAgaW50byBhIHN1Yi1mdW5jdGlvbi5cbiAgICAvLyBObyBtYXR0ZXIgd2hhdCwgaXQgc2VlbXMgaW1wb3NzaWJsZSB0byBnZXQgdGhlIGhhbmRsZXIncyBldmVudCBvYmplY3QgdHlwZWQgcGVyZmVjdGx5LlxuICAgIC8vIEl0IHNlZW1zIGxpa2UgaXQncyBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgdHVwZXMuXG4gICAgLy8gQWdhaW4sIG5vIG1hdHRlciB3aGF0IGNvbWJpbmF0aW9uIG9mIHN1Yi0gb3Igc3ViLXN1Yi1mdW5jdGlvbnMgdXNlZC5cblxuICAgIGxldCBzdGFibGVIYW5kbGVyOiBFdmVudExpc3RlbmVyIHwgbnVsbCA9IHVzZVN0YWJsZUNhbGxiYWNrPEV2ZW50TGlzdGVuZXI+KChoYW5kbGVyIGFzIGFueSkgPz8gKCgpID0+IHsgfSkpIGFzIChFdmVudExpc3RlbmVyIHwgbnVsbCk7XG4gICAgaWYgKGhhbmRsZXIgPT0gbnVsbClcbiAgICAgICAgc3RhYmxlSGFuZGxlciA9IG51bGw7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc3RhYmxlSGFuZGxlcikge1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcbn1cblxuLyoqXG4gKiBBbiBhbHRlcm5hdGl2ZSB3YXkgdG8gYWRkIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gZWxlbWVudC4gVXNlZnVsIHByaW1hcmlseSB3aGVuIGludGVncmF0aW5nIDNyZCBwYXJ0eSBsaWJyYXJpZXMgdGhhdCBleHBlY3QgYSBnZW5lcmljIFwiYWRkIGV2ZW50IGhhbmRsZXJcIiBmdW5jdGlvbi5cbiAqIFxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHlvdSB0byBtb2RpZnkgYSBzZXQgb2YgcHJvcHMgdG8gYXBwbHkgdGhpcyBoYW5kbGVyLlxuICogXG4gKiBGb3IgdHlwaW5nIHJlYXNvbnMsIHRoaXMgZnVuY3Rpb24gaXMgc3BsaXQgaW50byB0d28uICBVc2FnZSBpcyBsaWtlIHRoZSBmb2xsb3dpbmc6XG4gKiBcbiAqIGBgYFxuICogY29uc3QgeyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH0gPSB1c2VMb2NhbEV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4oKShcIm9uTW91c2VEb3duXCIsIGUgPT4geyAgfSk7XG4gKiBjb25zdCBkaXZQcm9wcyA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMocHJvcHMpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbEhhbmRsZXI8RWxlbWVudFR5cGUgZXh0ZW5kcyAoSFRNTEVsZW1lbnRUYWdOYW1lTWFwW2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcF0gfCBTVkdFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcF0pPigpIHtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soPEV2ZW50VHlwZSBleHRlbmRzIEV4Y2x1ZGU8a2V5b2YgaC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT4sIGtleW9mIFByZWFjdERPTUF0dHJpYnV0ZXM+Pih0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IE5vbk51bGxhYmxlPGguSlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+W0V2ZW50VHlwZV0+KSA9PiB7XG5cbiAgICAgICAgY29uc3Qgc3RhYmxlSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIpO1xuXG4gICAgICAgIGNvbnN0IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEVsZW1lbnRUeXBlPih7IFt0eXBlXTogc3RhYmxlSGFuZGxlciB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPiwgcHJvcHMpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPjtcbiAgICAgICAgfSwgW3R5cGVdKTtcblxuICAgICAgICByZXR1cm4geyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH07XG5cbiAgICB9LCBbXSk7XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCBydW5JbW1lZGlhdGVseSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcbiAgICByZWZFbGVtZW50UmV0dXJuOiB7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldEVsZW1lbnQoKTogVCB8IG51bGw7XG4gICAgICAgIHByb3BzU3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4ge1xuICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7XG4gICAgICAgIG9uRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsLCBuZXZlcj47XG4gICAgICAgIG9uTW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcbiAgICAgICAgb25Vbm1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XG4gICAgfVxufVxuXG5cbi8qXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmRWxlbWVudFByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PihyOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiwgLi4ub3RoZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W10ge1xuICAgIHJldHVybiBbci5yZWZFbGVtZW50UmV0dXJuLnByb3BzU3RhYmxlLCAuLi5vdGhlclByb3BzXTtcbn0qL1xuXG4vKipcbiAqIEFsbG93cyBhY2Nlc3NpbmcgdGhlIGVsZW1lbnQgYSByZWYgcmVmZXJlbmNlcyBhcyBzb29uIGFzIGl0IGRvZXMgc28uXG4gKiAqVGhpcyBob29rIGl0c2VsZiByZXR1cm5zIGEgaG9vayotLXVzZVJlZkVsZW1lbnRQcm9wcyBtb2RpZmllcyB0aGUgcHJvcHMgdGhhdCB5b3Ugd2VyZSBnb2luZyB0byBwYXNzIHRvIGFuIEhUTUxFbGVtZW50LCBcbiAqIGFkZGluZyBhIFJlZkNhbGxiYWNrIGFuZCBtZXJnaW5nIGl0IHdpdGggYW55IGV4aXN0aW5nIHJlZiB0aGF0IGV4aXN0ZWQgb24gdGhlIHByb3BzLlxuICogXG4gKiBEb24ndCBmb3JnZXQgdG8gcHJvdmlkZSB0aGUgRWxlbWVudCBhcyB0aGUgdHlwZSBhcmd1bWVudCFcbiAqIFxuICogQHJldHVybnMgVGhlIGVsZW1lbnQsIGFuZCB0aGUgc3ViLWhvb2sgdGhhdCBtYWtlcyBpdCByZXRyaWV2YWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZkVsZW1lbnQ8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PihhcmdzOiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcbiAgICBjb25zdCB7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7IG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50IH0gfSA9IGFyZ3M7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUmVmRWxlbWVudFwiLCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCk7XG5cbiAgICAvLyBDYWxsZWQgKGluZGlyZWN0bHkpIGJ5IHRoZSByZWYgdGhhdCB0aGUgZWxlbWVudCByZWNlaXZlcy5cbiAgICBjb25zdCBoYW5kbGVyID0gdXNlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGwsIG5ldmVyPj4oKGUsIHByZXZWYWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gb25FbGVtZW50Q2hhbmdlPy4oZSwgcHJldlZhbHVlKTtcbiAgICAgICAgaWYgKHByZXZWYWx1ZSlcbiAgICAgICAgICAgIG9uVW5tb3VudD8uKHByZXZWYWx1ZSEpO1xuXG4gICAgICAgIGlmIChlKVxuICAgICAgICAgICAgb25Nb3VudD8uKGUpO1xuXG4gICAgICAgIHJldHVybiBjbGVhbnVwO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIExldCB1cyBzdG9yZSB0aGUgYWN0dWFsIChyZWZlcmVuY2UgdG8pIHRoZSBlbGVtZW50IHdlIGNhcHR1cmVcbiAgICBjb25zdCBbZ2V0RWxlbWVudCwgc2V0RWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8VCB8IG51bGwsIG5ldmVyPihoYW5kbGVyLCByZXR1cm5OdWxsLCBydW5JbW1lZGlhdGVseSk7XG4gICAgY29uc3QgcHJvcHNTdGFibGUgPSB1c2VSZWY8aC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4+KHsgcmVmOiBzZXRFbGVtZW50IH0pO1xuXG4gICAgLy8gUmV0dXJuIGJvdGggdGhlIGVsZW1lbnQgYW5kIHRoZSBob29rIHRoYXQgbW9kaWZpZXMgXG4gICAgLy8gdGhlIHByb3BzIGFuZCBhbGxvd3MgdXMgdG8gYWN0dWFsbHkgZmluZCB0aGUgZWxlbWVudFxuICAgIHJldHVybiB7XG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgICAgIGdldEVsZW1lbnQsXG4gICAgICAgICAgICBwcm9wc1N0YWJsZTogcHJvcHNTdGFibGUuY3VycmVudFxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQsIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIH0gZnJvbSBcIi4uL29ic2VydmVycy91c2UtYWN0aXZlLWVsZW1lbnRcIjtcbmltcG9ydCB7IGFzc2VydEVtcHR5T2JqZWN0IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VHbG9iYWxIYW5kbGVyIH0gZnJvbSBcIi4uL2RvbS1oZWxwZXJzL3VzZS1ldmVudC1oYW5kbGVyXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi4vZG9tLWhlbHBlcnMvdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuLyoqXG4gKiBJbiBnZW5lcmFsLCBlYWNoIHNvZnQgZGlzbWlzcyBob29rIHRha2VzIGFuIGBvcGVuYCBhbmQgYW4gYG9uQ2xvc2VgIHByb3AuXG4gKiBcbiAqIGBvcGVuYCBpbiBhbGwgY2FzZXMgcmVmZXJlcyB0byBib3RoIHdoZXRoZXIgb3Igbm90IHRoZSBjb250cm9sbGVkIHN1cmZhY2UgaXMgY3VycmVudGx5IGJlaW5nIHNob3duLFxuICogYnV0IGFsc28gd2hldGhlciB0aGF0IHBhcnRpY3VsYXIgbWV0aG9kIG9mIHNvZnQgZGlzbWlzcyBpcyBlbmFibGVkIG9yIG5vdC5cbiAqIFxuICogRS5HLiBJZiBgZXNjYXBlYCBrZXkgZGlzbWlzc2luZyBpcyBkaXNhYmxlZCwganVzdCBoYXZlIGBvcGVuYCBmYWxzZSBhdCBhbGwgdGltZXMgZm9yIGBlc2NhcGVEaXNtaXNzUGFyYW1ldGVyc2AuXG4gKi9cbmNvbnN0IF9kdW1teSA9IDA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRXNjYXBlRGlzbWlzc1BhcmFtZXRlcnM8UG9wdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybjogUGljazxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxQb3B1cEVsZW1lbnQ+W1wicmVmRWxlbWVudFJldHVyblwiXSwgXCJnZXRFbGVtZW50XCI+O1xuICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGlzbWlzc2VkLlxuICAgICAgICAgKiBcbiAgICAgICAgICogUHJlc3VtYWJseSB5b3UnbGwgc2V0IHNvbWUgc3RhdGUgdGhhdCBjaGFuZ2VzIGBvcGVuYCB0byBmYWxzZSBkdXJpbmcgdGhpcywgb3RoZXJ3aXNlIGl0J3Mgbm90IGEgc29mdCBkaXNtaXNzLCBidXQgeW91IGNhbiBkbyB3aGF0ZXZlciB5b3Ugd2FudCBJIGd1ZXNzLlxuICAgICAgICAgKi9cbiAgICAgICAgb25DbG9zZShyZWFzb246IFwiZXNjYXBlXCIgfCBcImxvc3QtZm9jdXNcIik6IHZvaWQ7XG5cbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzdXJmYWNlIGNvbnRyb2xsZWQgYnkgdGhlIGBFc2NhcGVgIGtleSBpcyBjdXJyZW50bHkgb3Blbi4gXG4gICAgICAgICAqIENhbiBhbHNvIGJlIGBmYWxzZWAgdG8gZm9yY2UgdGhlIGBFc2NhcGVgIGtleSB0byBkbyBub3RoaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgb3BlbjogYm9vbGVhbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVzY2FwZSBrZXkgZXZlbnQgaGFuZGxlciBpcyBhdHRhY2hlZCBvbnRvIHRoZSB3aW5kb3csIHNvIHdlIG5lZWQgdG8ga25vdyB3aGljaCB3aW5kb3cuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaW5kb3coKTogV2luZG93O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhpcyBmcm9tIGNvbnRleHQgc29tZXdoZXJlLCBhbmQgaW5jcmVtZW50IGl0IGluIHRoYXQgY29udGV4dC5cbiAgICAgICAgICogXG4gICAgICAgICAqIElmIG11bHRpcGxlIGluc3RhbmNlcyBvZiBQcmVhY3QgYXJlIG9uIHRoZSBwYWdlLCB0cmVlIGRlcHRoIGlzIHVzZWQgYXMgYSB0aWVicmVha2VyXG4gICAgICAgICAqL1xuICAgICAgICBwYXJlbnREZXB0aDogbnVtYmVyO1xuICAgIH1cbn1cblxuXG5jb25zdCBNYWdpY1dpbmRvd0tleSA9IChcIl9fcHJlYWN0LXByb3AtaGVscGVycy1lc2NhcGUta2V5LWRpc21pc3NfX1wiKSBhcyBrZXlvZiBXaW5kb3c7XG5pbnRlcmZhY2UgV2luZG93RXNjYXBlS2V5SW5mbyB7XG4gICAgbWljcm90YXNrUXVldWVkOiBib29sZWFuO1xuICAgIGVsZW1lbnRRdWV1ZTogTWFwPEVsZW1lbnQsIHsgb25DbG9zZTogKCkgPT4gdm9pZCwgZGVwdGg6IG51bWJlciwgdHJlZURlcHRoOiBudW1iZXIgfT47Ly8oRWxlbWVudCB8IG51bGwpW107XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnREZXB0aChlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgbGV0IGRlcHRoID0gMDtcbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgZGVwdGggKz0gMTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlcHRoO1xufVxuXG4vKipcbiAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIGEgbW9kYWwtbGlrZSBzb2Z0LWRpc21pc3MgaW50ZXJhY3Rpb24uXG4gKiBcbiAqIFRoYXQgaXMsIGFueSBjbGlja3Mgb3IgdGFwcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBjb21wb25lbnQsIFxuICogb3IgYW55IHRpbWUgdGhlIEVzY2FwZSBrZXkgaXMgcHJlc3NlZCB3aXRoaW4gdGhlIGNvbXBvbmVudCxcbiAqICh3aXRoIHZhcmlvdXMgYnJvd3NlciBvZGRpdGllcyByZWdhcmRpbmcgY2xpY2tzIG9uIGJsYW5rIG9yIGluZXJ0IGFyZWFzIGhhbmRsZWQpXG4gKiB0aGUgY29tcG9uZW50IHdpbGwgcmVxdWVzdCB0byBjbG9zZSBpdHNlbGYuXG4gKiBcbiAqIE9mIGNvdXJzZSwgaWYgeW91IGRvbid0IGRvIGFueXRoaW5nIGluIHRoZSBgb25DbG9zZWAgZnVuY3Rpb24sXG4gKiBpdCB3b24ndCBiZSBhIHNvZnQgZGlzbWlzcyBhbnltb3JlLlxuICogXG4gKiBIYW5kbGVzIGV2ZW50cyBmb3IgcHJlc3NpbmcgdGhlIGBFc2NhcGVgIGtleSB0byBjbG9zZSB0aGUgYW55IGN1cnJlbnRseSBvcGVuIGRpYWxvZ3MsIHRvb2x0aXBzLCBtZW51cywgcG9wdXBzLCBldGMuXG4gKiBcbiAqIE9uZSBwcmVzcyBvZiB0aGUgYEVzY2FwZWAga2V5IGlzIGd1YXJhbnRlZWQgdG8gb25seSBjYWxsIGBvbkNsb3NlYCBmb3IgKm9ubHkgb25lKiBjb21wb25lbnQsIGFuZCBpdCBpcyBjYWxsZWQgb24gdGhlIGNvbXBvbmVudCBkZWVwZXN0IGluIHRoZSBET00gdHJlZSwgZGlmZmVyZW50aWF0ZWQgYnkgcGFzc2luZyBjb250ZXh0IGluZm9ybWF0aW9uIGJldHdlZW4gcGFyZW50IGFuZCBjaGlsZC5cbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRXNjYXBlRGlzbWlzczxQb3B1cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzOiB7IG9uQ2xvc2UsIG9wZW4sIGdldFdpbmRvdzogdW5zdGFibGVHZXRXaW5kb3csIHBhcmVudERlcHRoLCAuLi52b2lkMSB9LCByZWZFbGVtZW50UG9wdXBSZXR1cm46IHsgZ2V0RWxlbWVudCwgLi4udm9pZDIgfSB9OiBVc2VFc2NhcGVEaXNtaXNzUGFyYW1ldGVyczxQb3B1cEVsZW1lbnQ+KTogdm9pZCB7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDEpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQyKTtcblxuICAgIGNvbnN0IHN0YWJsZU9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjayhvbkNsb3NlKTtcbiAgICBjb25zdCBnZXRXaW5kb3cgPSB1c2VTdGFibGVDYWxsYmFjayh1bnN0YWJsZUdldFdpbmRvdyk7XG4gICAgY29uc3QgZ2V0RGVwdGggPSB1c2VTdGFibGVHZXR0ZXIocGFyZW50RGVwdGggKyAxKTtcblxuXG4gICAgLy8gV2hlbiB0aGlzIGNvbXBvbmVudCBvcGVucywgYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgZmluZHMgdGhlIGRlZXBlc3Qgb3BlbiBzb2Z0IGRpc21pc3MgZWxlbWVudCB0byBhY3R1YWxseSBkaXNtaXNzLlxuICAgIC8vIE9ubHkgb3BlbmVkIGNvbXBvbmVudHMgd2lsbCBhZGQgZXZlbnQgaGFuZGxlcnMsIGFuZCB3aWxsIHJlbW92ZSB0aGVtIG9uY2UgY2xvc2VkLlxuICAgIC8vIFRoZSByZWFzb24gdGhpcyBpcyBzbyBjb21wbGljYXRlZCBpcyBiZWNhdXNlOlxuICAgIC8vIDEuIFdlIG11c3Qgb25seSBjbG9zZSBvbmUgc29mdCBkaXNtaXNzIGNvbXBvbmVudCBhdCBhIHRpbWUuICBJZiB0aGVyZSdzIGEgdG9vbHRpcCBpbiBhIHBvcHVwLCB0aGUgdG9vbHRpcCBtdXN0IGJlIGRpc21pc3NlZC5cbiAgICAvLyAyLiBga2V5ZG93bmAgZXZlbnRzIGRvbid0IGp1c3Qgd29yayBvbiBhcmJpdHJhcnkgZWxlbWVudHMsIGZvciBvdXIgcHVycG9zZXMgdGhleSBtdXN0IGJlIGZyb20gdGhlIGB3aW5kb3dgLiBTbyB3ZSBjYW4ndCByZWx5IG9uIG5vcm1hbCBjYXB0dXJpbmcgb3IgYnViYmxpbmcgYmVoYXZpb3Igb24gdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgIC8vIDMuIEV2ZW50IGhhbmRsZXJzIGFkZGVkIHRvIHRoZSBgd2luZG93YCB2aWEgYGFkZEV2ZW50SGFuZGxlcmAgYXJlIGNhbGxlZCBpbiB0aGUgb3JkZXIgb2YgcmVnaXN0cmF0aW9uLCB3aGljaCBpcyBjb21wbGV0ZWx5IGF0IG9kZHMgd2l0aCAjMS5cbiAgICAvL1xuICAgIC8vIFNvIGFsbCBzb2Z0IGRpc21pc3MgY29tcG9uZW50cyBsaXN0ZW4gZm9yIGEga2V5ZG93biBvZiBFc2NhcGUsIFxuICAgIC8vIHRoZW4gdGhlIGZpcnN0IG9uZSB0byBkbyBzbyB3aWxsIHdhaXQgZm9yIGEgbWljcm90YXNrLCBcbiAgICAvLyB0aGVuIGZpbmQgdGhlIGRlZXBlc3QgZWxlbWVudCBpbiB0aGUgZG9jdW1lbnQgdHJlZSB0byBkaXNtaXNzIG9mIGFsbCBvZiB0aG9zZSBjb21wb25lbnRzIGN1cnJlbnRseSBvcGVuLlxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IGdldFdpbmRvdygpO1xuICAgICAgICAod2luZG93IGFzIGFueSlbTWFnaWNXaW5kb3dLZXldID8/PSAoeyBtaWNyb3Rhc2tRdWV1ZWQ6IGZhbHNlLCBlbGVtZW50UXVldWU6IG5ldyBNYXAoKSB9IGFzIFdpbmRvd0VzY2FwZUtleUluZm8pXG4gICAgICAgIGNvbnN0IGluZm8gPSB3aW5kb3dbTWFnaWNXaW5kb3dLZXldIGFzIFdpbmRvd0VzY2FwZUtleUluZm87XG5cbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgaGFuZGxlciBmb3IgZGVwdGg9JHtnZXREZXB0aCgpfWApO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVtb3ZpbmcgaGFuZGxlciBmb3IgZGVwdGg9JHtnZXREZXB0aCgpfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgaW5mby5lbGVtZW50UXVldWUpXG4gICAgICAgICAgICAgICAgICAgIGluZm8uZWxlbWVudFF1ZXVlLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlciwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG5cblxuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoZTogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgICAgaWYgKGUua2V5ID09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXNjYXBlIGtleSBmb3IgZGVwdGg9JHtnZXREZXB0aCgpfWApO1xuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB3aGljaCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBzb2Z0IGRpc21pc3NlcyB3aWxsIGFjdHVhbGx5IGRvIHNvbWV0aGluZyxcbiAgICAgICAgICAgICAgICAvLyBidXQgT05FIG9mIHRoZW0gZGVmaW5pdGVseSB3aWxsLFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIHN0b3AgcHJvcGFnYXRpb24gdG8gY2hpbGQgbm9kZXMsIGJ1dCBub3QgdG8gZXZlcnlvbmUgb24gdGhlIHdpbmRvdyAoc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKS5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHdoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZSBlbGVtZW50cyB3aWxsIGNhbGxcbiAgICAgICAgICAgICAgICBjb25zdCBvbkNsb3NlMiA9ICgpID0+IHsgc3RhYmxlT25DbG9zZShcImVzY2FwZVwiKTsgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyZWVEZXB0aCA9IGdldEVsZW1lbnREZXB0aChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVwdGggPSBnZXREZXB0aCgpO1xuICAgICAgICAgICAgICAgICAgICBpbmZvLmVsZW1lbnRRdWV1ZS5zZXQoZWxlbWVudCwgeyBkZXB0aCwgb25DbG9zZTogb25DbG9zZTIsIHRyZWVEZXB0aCB9KTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIGlmICghaW5mby5taWNyb3Rhc2tRdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mby5taWNyb3Rhc2tRdWV1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlbGVtZW50UXVldWUgfSA9IGluZm87XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLm1pY3JvdGFza1F1ZXVlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5lbGVtZW50UXVldWUgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZWVwZXN0RGVwdGggPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVlcGVzdFRyZWVEZXB0aCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBfZGVlcGVzdEVsZW1lbnQ6IEVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZWVwZXN0T25DbG9zZTogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2VsZW1lbnQsIHsgZGVwdGgsIG9uQ2xvc2UsIHRyZWVEZXB0aCB9XSBvZiBlbGVtZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGllQnJva2VuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IGRlZXBlc3REZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJlZURlcHRoID4gZGVlcGVzdFRyZWVEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGllQnJva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA+IGRlZXBlc3REZXB0aCB8fCAoZGVwdGggPT0gZGVlcGVzdERlcHRoICYmIHRpZUJyb2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVlcGVzdERlcHRoID0gZGVwdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZWVwZXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBlc3RUcmVlRGVwdGggPSB0cmVlRGVwdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBlc3RPbkNsb3NlID0gb25DbG9zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWVwZXN0T25DbG9zZT8uKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtvcGVuXSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTG9zdEZvY3VzRGlzbWlzc1BhcmFtZXRlcnM8U291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQgfCBudWxsLCBQb3B1cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgbG9zdEZvY3VzRGlzbWlzczogeyBvcGVuOiBib29sZWFuLCBvbkNsb3NlKCk6IHZvaWQ7IH07XG4gICAgcmVmRWxlbWVudFNvdXJjZVJldHVybjogbnVsbCB8IFBpY2s8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8Tm9uTnVsbGFibGU8U291cmNlRWxlbWVudD4+W1wicmVmRWxlbWVudFJldHVyblwiXSwgXCJnZXRFbGVtZW50XCI+O1xuICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybjogUGljazxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxQb3B1cEVsZW1lbnQ+W1wicmVmRWxlbWVudFJldHVyblwiXSwgXCJnZXRFbGVtZW50XCI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxvc3RGb2N1c0Rpc21pc3NSZXR1cm5UeXBlPF9Tb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB8IG51bGwsIF9Qb3B1cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgYWN0aXZlRWxlbWVudFBhcmFtZXRlcnM6IFBpY2s8VXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnNbXCJhY3RpdmVFbGVtZW50UGFyYW1ldGVyc1wiXSwgXCJvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlXCI+XG59XG5cbi8qKlxuICogSGFuZGxlcyBldmVudHMgZm9yIGRpc21pc3MgZXZlbnRzIGZvciB0aGluZ3MgbGlrZSBwb3B1cCBtZW51cyBvciB0cmFuc2llbnQgZGlhbG9ncyAtLSB0aGluZ3Mgd2hlcmUgbW92aW5nIGZvY3VzIHRvIGEgbmV3IGFyZWEgb2YgdGhlIHBhZ2UgbWVhbnMgdGhpcyBjb21wb25lbnQgc2hvdWxkIGNsb3NlIGl0c2VsZi5cbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9zdEZvY3VzRGlzbWlzczxTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB8IG51bGwsIFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgcmVmRWxlbWVudFBvcHVwUmV0dXJuOiB7IGdldEVsZW1lbnQ6IGdldFBvcHVwRWxlbWVudCwgLi4udm9pZDMgfSwgcmVmRWxlbWVudFNvdXJjZVJldHVybiwgbG9zdEZvY3VzRGlzbWlzczogeyBvcGVuLCBvbkNsb3NlIH0sIC4uLnZvaWQxIH06IFVzZUxvc3RGb2N1c0Rpc21pc3NQYXJhbWV0ZXJzPFNvdXJjZUVsZW1lbnQsIFBvcHVwRWxlbWVudD4pOiBVc2VMb3N0Rm9jdXNEaXNtaXNzUmV0dXJuVHlwZTxTb3VyY2VFbGVtZW50LCBQb3B1cEVsZW1lbnQ+IHtcblxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0U291cmNlRWxlbWVudCwgLi4udm9pZDIgfSA9IChyZWZFbGVtZW50U291cmNlUmV0dXJuID8/IHt9KTtcblxuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQxKTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkMik7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDMpO1xuXG5cbiAgICBjb25zdCBzdGFibGVPbkNsb3NlID0gdXNlU3RhYmxlQ2FsbGJhY2sob25DbG9zZSk7XG4gICAgY29uc3QgZ2V0T3BlbiA9IHVzZVN0YWJsZUdldHRlcihvcGVuKTtcbiAgICBjb25zdCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlID0gdXNlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8RWxlbWVudCB8IG51bGwsIGguSlNYLlRhcmdldGVkRm9jdXNFdmVudDxhbnk+Pj4oKG5ld0VsZW1lbnQsIF9wcmV2RWxlbWVudCwgX2UpID0+IHtcbiAgICAgICAgY29uc3Qgb3BlbiA9IGdldE9wZW4oKTtcbiAgICAgICAgY29uc3Qgc291cmNlRWxlbWVudCA9IGdldFNvdXJjZUVsZW1lbnQ/LigpO1xuICAgICAgICBjb25zdCBwb3B1cEVsZW1lbnQgPSBnZXRQb3B1cEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKCEoc291cmNlRWxlbWVudD8uY29udGFpbnMobmV3RWxlbWVudCkgfHwgcG9wdXBFbGVtZW50Py5jb250YWlucyhuZXdFbGVtZW50KSkpIHtcbiAgICAgICAgICAgIGlmIChvcGVuKVxuICAgICAgICAgICAgICAgIHN0YWJsZU9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH0sIFtnZXRTb3VyY2VFbGVtZW50XSk7XG5cbiAgICByZXR1cm4geyBhY3RpdmVFbGVtZW50UGFyYW1ldGVyczogeyBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlIH0gfVxufVxuXG4vKlxuZXhwb3J0IGludGVyZmFjZSBVc2VTb2Z0RGlzbWlzc1BhcmFtZXRlcnM8U291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTG9zdEZvY3VzRGlzbWlzc1BhcmFtZXRlcnM8U291cmNlRWxlbWVudCwgUG9wdXBFbGVtZW50PiwgVXNlRXNjYXBlRGlzbWlzc1BhcmFtZXRlcnM8U291cmNlRWxlbWVudD4geyB9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb2Z0RGlzbWlzczxTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUG9wdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycywgbG9zdEZvY3VzRGlzbWlzcywgcmVmRWxlbWVudFBvcHVwUmV0dXJuLCByZWZFbGVtZW50UmV0dXJuLCByZWZFbGVtZW50U291cmNlUmV0dXJuLCAuLi5fdm9pZDMgfTogVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzPFNvdXJjZUVsZW1lbnQsIFBvcHVwRWxlbWVudD4pIHtcbiAgICBjb25zdCB7IGFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzLCAuLi52b2lkMiB9ID0gdXNlTG9zdEZvY3VzRGlzbWlzcyh7IGxvc3RGb2N1c0Rpc21pc3MsIHJlZkVsZW1lbnRQb3B1cFJldHVybiwgcmVmRWxlbWVudFNvdXJjZVJldHVybiB9KTtcbiAgICBjb25zdCBfdm9pZDE6IHZvaWQgPSB1c2VFc2NhcGVEaXNtaXNzKHsgZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnMsIHJlZkVsZW1lbnRSZXR1cm4gfSk7XG59Ki9cblxuZXhwb3J0IGludGVyZmFjZSBVc2VCYWNrZHJvcERpc21pc3NQYXJhbWV0ZXJzPFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBiYWNrZHJvcERpc21pc3NQYXJhbWV0ZXJzOiB7IG9wZW46IGJvb2xlYW4sIG9uQ2xvc2UoKTogdm9pZDsgfTtcbiAgICByZWZFbGVtZW50UG9wdXBSZXR1cm46IFBpY2s8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8UG9wdXBFbGVtZW50PltcInJlZkVsZW1lbnRSZXR1cm5cIl0sIFwiZ2V0RWxlbWVudFwiPjtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGV2ZW50cyBmb3IgYSBiYWNrZHJvcCBvbiBhIG1vZGFsIGRpYWxvZyAtLSB0aGUga2luZCB3aGVyZSB0aGUgdXNlciBleHBlY3RzIHRoZSBtb2RhbCB0byBjbG9zZSB3aGVuIHRoZXkgY2xpY2svdGFwIG91dHNpZGUgb2YgaXQuXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCYWNrZHJvcERpc21pc3M8UG9wdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBiYWNrZHJvcERpc21pc3NQYXJhbWV0ZXJzOiB7IG9wZW4sIG9uQ2xvc2U6IG9uQ2xvc2VVbnN0YWJsZSwgLi4udm9pZDEgfSwgcmVmRWxlbWVudFBvcHVwUmV0dXJuOiB7IGdldEVsZW1lbnQsIC4uLnZvaWQzIH0sIC4uLnZvaWQyIH06IFVzZUJhY2tkcm9wRGlzbWlzc1BhcmFtZXRlcnM8UG9wdXBFbGVtZW50Pik6IHZvaWQge1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQxKTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkMik7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDMpO1xuICAgIGNvbnN0IGdldE9wZW4gPSB1c2VTdGFibGVHZXR0ZXIob3Blbik7XG4gICAgY29uc3Qgb25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2VVbnN0YWJsZSk7XG5cbiAgICBjb25zdCBvbkJhY2tkcm9wQ2xpY2sgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiBvbkJhY2tkcm9wQ2xpY2soZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxhbnk+KSB7XG4gICAgICAgIGlmICghZ2V0T3BlbigpKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG5cbiAgICAgICAgLy8gQmFzaWNhbGx5LCBcIndhcyB0aGlzIGV2ZW50IGZpcmVkIG9uIGFuIGVsZW1lbnQgbm90IGNvbnRhaW5lZCBieSB0aGUgbW9kYWw/XCJcbiAgICAgICAgLy8gVGhlcmUgYXJlIG11bHRpcGxlIHdheXMgYnJvd3NlciByZWFjdCB0byBcImludGVyYWN0aW5nIHdpdGggbm90aGluZ1wiLCBhbmQgdGhpcyB0YWtlcyBjYXJlIG9mIGV2ZXJ5dGhpbmcuXG5cbiAgICAgICAgbGV0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG5cbiAgICAgICAgbGV0IGZvdW5kSW5zaWRlQ2xpY2sgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZS50YXJnZXQgJiYgZWxlbWVudCAmJiBlbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0IGFzIE5vZGUpKSB7XG4gICAgICAgICAgICBmb3VuZEluc2lkZUNsaWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZm91bmRJbnNpZGVDbGljaykge1xuICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgdXNlR2xvYmFsSGFuZGxlcih3aW5kb3csIFwibW91c2Vkb3duXCIsIG9wZW4gPyBvbkJhY2tkcm9wQ2xpY2sgOiBudWxsLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgdXNlR2xvYmFsSGFuZGxlcih3aW5kb3csIFwidG91Y2hzdGFydFwiLCBvcGVuID8gb25CYWNrZHJvcENsaWNrIDogbnVsbCwgeyBjYXB0dXJlOiB0cnVlIH0pO1xufVxuXG5leHBvcnQgdHlwZSBEaXNtaXNzTGlzdGVuZXJUeXBlcyA9IFwiYmFja2Ryb3BcIiB8IFwibG9zdC1mb2N1c1wiIHwgXCJlc2NhcGVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VEaXNtaXNzUGFyYW1ldGVyczxMaXN0ZW5lcnMgZXh0ZW5kcyBEaXNtaXNzTGlzdGVuZXJUeXBlcz4ge1xuICAgIGRpc21pc3NQYXJhbWV0ZXJzOiB7XG5cbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvbmVudCBpcyBjdXJyZW50bHkgb3Blbi9zaG93aW5nIGl0c2VsZiwgYXMgb3Bwb3NlZCB0byBoaWRkZW4vY2xvc2VkLlxuICAgICAgICAgKiBFdmVudCBoYW5kbGVycyBhcmUgb25seSBhdHRhY2hlZCB3aGVuIHRoaXMgaXMgYHRydWVgLlxuICAgICAgICAgKi9cbiAgICAgICAgb3BlbjogYm9vbGVhbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSB1c2VyIGhhcyByZXF1ZXN0ZWQgdGhlIGNvbXBvbmVudCBiZSBkaXNtaXNzZWQgZm9yIHRoZSBnaXZlbiByZWFzb24uXG4gICAgICAgICAqIFxuICAgICAgICAgKiBZb3UgY2FuIGNob29zZSB0byBpZ25vcmUgYSByZWFzb24gaWYgeW91IHdhbnQsIGJ1dCBpdCdzIGJldHRlciB0byBzZXQgYGNsb3NlT24ke3JlYXNvbn1gIHRvIGBmYWxzZWAgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIG9uQ2xvc2U6IChyZWFzb246IExpc3RlbmVycykgPT4gdm9pZDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYHRydWVgLCB0aGVuIHRoaXMgY29tcG9uZW50IGNsb3NlcyB3aGVuIGEgY2xpY2sgaXMgZGV0ZWN0ZWQgYW55d2hlcmUgbm90IHdpdGhpbiB0aGUgY29tcG9uZW50XG4gICAgICAgICAqIChkZXRlcm1pbmVkIGJ5IGJlaW5nIGluIGEgZGlmZmVyZW50IGJyYW5jaCBvZiB0aGUgRE9NKVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2VPbkJhY2tkcm9wOiBMaXN0ZW5lcnMgZXh0ZW5kcyBcImJhY2tkcm9wXCIgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGB0cnVlYCwgdGhlbiB0aGlzIGNvbXBvbmVudCBjbG9zZXMgd2hlbiB0aGUgRXNjYXBlIGtleSBpcyBwcmVzc2VkLCBhbmQgbm8gZGVlcGVyIGNvbXBvbmVudFxuICAgICAgICAgKiBpcyBsaXN0ZW5pbmcgZm9yIHRoYXQgc2FtZSBFc2NhcGUgcHJlc3MgKGkuZS4gb25seSBvbmUgRXNjYXBlIGRpc21pc3MgaGFwcGVucyBwZXIga2V5IHByZXNzKVxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2VPbkVzY2FwZTogTGlzdGVuZXJzIGV4dGVuZHMgXCJlc2NhcGVcIiA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYHRydWVgLCB0aGVuIHRoaXMgY29tcG9uZW50IGNsb3NlcyB3aGVuZXZlciBmb2N1cyBpcyBzZW50IHRvIGFuIGVsZW1lbnQgbm90IGNvbnRhaW5lZCBieSB0aGlzIG9uZVxuICAgICAgICAgKiAodXNpbmcgdGhlIHNhbWUgcnVsZXMgYXMgYGNsb3NlT25CYWNrZHJvcGApXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZU9uTG9zdEZvY3VzOiBMaXN0ZW5lcnMgZXh0ZW5kcyBcImxvc3QtZm9jdXNcIiA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnM6IFBpY2s8VXNlRXNjYXBlRGlzbWlzc1BhcmFtZXRlcnM8YW55PltcImVzY2FwZURpc21pc3NQYXJhbWV0ZXJzXCJdLCBcImdldFdpbmRvd1wiIHwgXCJwYXJlbnREZXB0aFwiPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VEaXNtaXNzUmV0dXJuVHlwZTxTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB8IG51bGwsIFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGRpc21pc3NhYmxlIGNvbXBvbmVudCBoYXMgYSBzcGVjaWZpYyBlbGVtZW50IHRoYXQgY2F1c2VkIGl0IHRvIGFwcGVhciAoYSBidXR0b24sIGZvciBleGFtcGxlKSxcbiAgICAgKiBwcm92aWRlIGl0IHdpdGggdGhlc2UgcHJvcHMuXG4gICAgICogXG4gICAgICogKiBSRVFVSVJFRCBmb3IgdGhpbmdzIGxpa2UgbWVudXMgdGhhdCBwb3AgdXAgZnJvbSBhIGJ1dHRvbiBhbmQgZm9yIHdob20gbG9zaW5nIGZvY3VzIGNvdW50cyBhcyByZXF1ZXN0aW5nIGNsb3N1cmUuIFxuICAgICAqICogT1BUSU9OQUwgZm9yIHRoaW5ncyBsaWtlIGRpYWxvZ3MgdGhhdCBjYW4gYXBwZWFyIG91dCBvZiBub3doZXJlIGFuZCBmb3Igd2hvbSBsb3NpbmcgZm9jdXMgaXMgYWN0aXZlbHkgaW1wb3NzaWJsZSAoZHVlIHRvIGZvY3VzIHRyYXBzKS5cbiAgICAgKi9cbiAgICByZWZFbGVtZW50U291cmNlUmV0dXJuOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxOb25OdWxsYWJsZTxTb3VyY2VFbGVtZW50Pj5bXCJyZWZFbGVtZW50UmV0dXJuXCJdO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBvbmUncyBhbHdheXMgcmVxdWlyZWQgdGhvdWdoXG4gICAgICovXG4gICAgcmVmRWxlbWVudFBvcHVwUmV0dXJuOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxQb3B1cEVsZW1lbnQ+W1wicmVmRWxlbWVudFJldHVyblwiXTtcblxufVxuXG4vKipcbiAqIENvbWJpbmVzIGFsbCB0aGUgbWV0aG9kcyBvZiBkaXNtaXNzaW5nIGEgbW9kYWwtaXNoIG9yIHBvcHVwLWlzaCBjb21wb25lbnQgaW50byBvbmUgY29tYmluZWQgaG9vay5cbiAqIFxuICogVGhpcyBpcyBzaW1pbGFyIHRvIHRoZSBcImNvbXBsZXRlXCIgc2VyaWVzIG9mIGxpc3QvZ3JpZCBuYXZpZ2F0aW9uLCBpbiB0aGF0IGl0J3MgdGhlIFwib3V0ZXJtb3N0XCIgaG9vayBvZiBpdHMgdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZURpc21pc3M8TGlzdGVuZXJzIGV4dGVuZHMgRGlzbWlzc0xpc3RlbmVyVHlwZXMsIFNvdXJjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHwgbnVsbCwgUG9wdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBkaXNtaXNzUGFyYW1ldGVyczogeyBvcGVuOiBnbG9iYWxPcGVuLCBvbkNsb3NlOiBnbG9iYWxPbkNsb3NlLCBjbG9zZU9uQmFja2Ryb3AsIGNsb3NlT25Fc2NhcGUsIGNsb3NlT25Mb3N0Rm9jdXMgfSwgZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnM6IHsgZ2V0V2luZG93LCBwYXJlbnREZXB0aCB9IH06IFVzZURpc21pc3NQYXJhbWV0ZXJzPExpc3RlbmVycz4pOiBVc2VEaXNtaXNzUmV0dXJuVHlwZTxTb3VyY2VFbGVtZW50LCBQb3B1cEVsZW1lbnQ+IHtcblxuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybjogcmVmRWxlbWVudFNvdXJjZVJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxOb25OdWxsYWJsZTxTb3VyY2VFbGVtZW50Pj4oeyByZWZFbGVtZW50UGFyYW1ldGVyczoge30gfSk7XG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuOiByZWZFbGVtZW50UG9wdXBSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8UG9wdXBFbGVtZW50Pih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcblxuICAgIGNvbnN0IG9uQ2xvc2VCYWNrZHJvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHsgcmV0dXJuIGdsb2JhbE9uQ2xvc2U/LihcImJhY2tkcm9wXCIgYXMgTGlzdGVuZXJzKTsgfSwgW2dsb2JhbE9uQ2xvc2VdKTtcbiAgICBjb25zdCBvbkNsb3NlRXNjYXBlID0gdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gZ2xvYmFsT25DbG9zZT8uKFwiZXNjYXBlXCIgYXMgTGlzdGVuZXJzKTsgfSwgW2dsb2JhbE9uQ2xvc2VdKTtcbiAgICBjb25zdCBvbkNsb3NlRm9jdXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiBnbG9iYWxPbkNsb3NlPy4oXCJsb3N0LWZvY3VzXCIgYXMgTGlzdGVuZXJzKTsgfSwgW2dsb2JhbE9uQ2xvc2VdKTtcbiAgICBjb25zdCBfdjE6IHZvaWQgPSB1c2VCYWNrZHJvcERpc21pc3M8UG9wdXBFbGVtZW50Pih7IGJhY2tkcm9wRGlzbWlzc1BhcmFtZXRlcnM6IHsgb25DbG9zZTogb25DbG9zZUJhY2tkcm9wLCBvcGVuOiAoY2xvc2VPbkJhY2tkcm9wICYmIGdsb2JhbE9wZW4pIH0sIHJlZkVsZW1lbnRQb3B1cFJldHVybiB9KTtcbiAgICBjb25zdCBfdjI6IHZvaWQgPSB1c2VFc2NhcGVEaXNtaXNzPFBvcHVwRWxlbWVudD4oeyBlc2NhcGVEaXNtaXNzUGFyYW1ldGVyczogeyBnZXRXaW5kb3csIG9uQ2xvc2U6IG9uQ2xvc2VFc2NhcGUsIG9wZW46IChjbG9zZU9uRXNjYXBlICYmIGdsb2JhbE9wZW4pLCBwYXJlbnREZXB0aCB9LCByZWZFbGVtZW50UG9wdXBSZXR1cm4gfSk7XG4gICAgY29uc3QgeyBhY3RpdmVFbGVtZW50UGFyYW1ldGVycyB9ID0gdXNlTG9zdEZvY3VzRGlzbWlzczxTb3VyY2VFbGVtZW50LCBQb3B1cEVsZW1lbnQ+KHsgbG9zdEZvY3VzRGlzbWlzczogeyBvbkNsb3NlOiBvbkNsb3NlRm9jdXMsIG9wZW46IChjbG9zZU9uTG9zdEZvY3VzICYmIGdsb2JhbE9wZW4pIH0sIHJlZkVsZW1lbnRQb3B1cFJldHVybiwgcmVmRWxlbWVudFNvdXJjZVJldHVybiB9KTtcblxuICAgIGNvbnN0IGdldERvY3VtZW50ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICByZXR1cm4gZ2V0V2luZG93KCkuZG9jdW1lbnQ7XG4gICAgfSwgW2dldFdpbmRvd10pXG5cbiAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgICAgIGdldEFjdGl2ZUVsZW1lbnQ6IF9nZXRBY3RpdmVFbGVtZW50LFxuICAgICAgICAgICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQ6IF9nZXRMYXN0QWN0aXZlRWxlbWVudCxcbiAgICAgICAgICAgIGdldFdpbmRvd0ZvY3VzZWQ6IF9nZXRXaW5kb3dGb2N1c2VkXG4gICAgICAgIH1cbiAgICB9ID0gdXNlQWN0aXZlRWxlbWVudCh7IGFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzOiB7IC4uLmFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzLCBnZXRXaW5kb3csIGdldERvY3VtZW50IH0gfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICByZWZFbGVtZW50U291cmNlUmV0dXJuLFxuICAgICAgICByZWZFbGVtZW50UG9wdXBSZXR1cm5cbiAgICB9XG59XG4iLCJjb25zdCBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbXG4gICdpbnB1dCcsXG4gICdzZWxlY3QnLFxuICAndGV4dGFyZWEnLFxuICAnYVtocmVmXScsXG4gICdidXR0b24nLFxuICAnW3RhYmluZGV4XTpub3Qoc2xvdCknLFxuICAnYXVkaW9bY29udHJvbHNdJyxcbiAgJ3ZpZGVvW2NvbnRyb2xzXScsXG4gICdbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdKScsXG4gICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScsXG4gICdkZXRhaWxzJyxcbl07XG5jb25zdCBjYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqLyBjYW5kaWRhdGVTZWxlY3RvcnMuam9pbignLCcpO1xuXG5jb25zdCBOb0VsZW1lbnQgPSB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IG1hdGNoZXMgPSBOb0VsZW1lbnRcbiAgPyBmdW5jdGlvbiAoKSB7fVxuICA6IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHxcbiAgICBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxuY29uc3QgZ2V0Um9vdE5vZGUgPVxuICAhTm9FbGVtZW50ICYmIEVsZW1lbnQucHJvdG90eXBlLmdldFJvb3ROb2RlXG4gICAgPyAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRSb290Tm9kZSgpXG4gICAgOiAoZWxlbWVudCkgPT4gZWxlbWVudC5vd25lckRvY3VtZW50O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgY29udGFpbmVyIHRvIGNoZWNrIGluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciB0byBjaGVja1xuICogQHBhcmFtIHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudFtdfVxuICovXG5jb25zdCBnZXRDYW5kaWRhdGVzID0gZnVuY3Rpb24gKGVsLCBpbmNsdWRlQ29udGFpbmVyLCBmaWx0ZXIpIHtcbiAgbGV0IGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoXG4gICAgZWwucXVlcnlTZWxlY3RvckFsbChjYW5kaWRhdGVTZWxlY3RvcilcbiAgKTtcbiAgaWYgKGluY2x1ZGVDb250YWluZXIgJiYgbWF0Y2hlcy5jYWxsKGVsLCBjYW5kaWRhdGVTZWxlY3RvcikpIHtcbiAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICB9XG4gIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcihmaWx0ZXIpO1xuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIEdldFNoYWRvd1Jvb3RcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCB0byBjaGVjayBmb3Igc2hhZG93IHJvb3RcbiAqIEByZXR1cm5zIHtTaGFkb3dSb290fGJvb2xlYW59IFNoYWRvd1Jvb3QgaWYgYXZhaWxhYmxlIG9yIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHNoYWRvd1Jvb3QgaXMgYXR0YWNoZWQgYnV0IG5vdCBhdmFpbGFibGUuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU2hhZG93Um9vdEZpbHRlclxuICogQHBhcmFtIHtFbGVtZW50fSBzaGFkb3dIb3N0Tm9kZSB0aGUgZWxlbWVudCB3aGljaCBjb250YWlucyBzaGFkb3cgY29udGVudFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgYSBzaGFkb3cgcm9vdCBjb3VsZCBwb3RlbnRpYWxseSBjb250YWluIHZhbGlkIGNhbmRpZGF0ZXMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDYW5kaWRhdGVTY29wZVxuICogQHByb3BlcnR5IHtFbGVtZW50fSBzY29wZVBhcmVudCBjb250YWlucyBpbm5lciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge0VsZW1lbnRbXX0gY2FuZGlkYXRlcyBsaXN0IG9mIGNhbmRpZGF0ZXMgZm91bmQgaW4gdGhlIHNjb3BlIHBhcmVudFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSXRlcmF0aXZlT3B0aW9uc1xuICogQHByb3BlcnR5IHtHZXRTaGFkb3dSb290fGJvb2xlYW59IGdldFNoYWRvd1Jvb3QgdHJ1ZSBpZiBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkOyBmYWxzeSBpZiBub3Q7XG4gKiAgaWYgYSBmdW5jdGlvbiwgaW1wbGllcyBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkIGFuZCBlaXRoZXIgcmV0dXJucyB0aGUgc2hhZG93IHJvb3Qgb2YgYW4gZWxlbWVudFxuICogIG9yIGEgYm9vbGVhbiBzdGF0aW5nIGlmIGl0IGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgcm9vdFxuICogQHByb3BlcnR5IHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZsYXR0ZW4gaWYgdHJ1ZSB0aGVuIHJlc3VsdCB3aWxsIGZsYXR0ZW4gYW55IENhbmRpZGF0ZVNjb3BlIGludG8gdGhlIHJldHVybmVkIGxpc3RcbiAqIEBwcm9wZXJ0eSB7U2hhZG93Um9vdEZpbHRlcn0gc2hhZG93Um9vdEZpbHRlciBmaWx0ZXIgc2hhZG93IHJvb3RzO1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50W119IGVsZW1lbnRzIGxpc3Qgb2YgZWxlbWVudCBjb250YWluZXJzIHRvIG1hdGNoIGNhbmRpZGF0ZXMgZnJvbVxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgbGlzdCB0byBjaGVja1xuICogQHBhcmFtIHtJdGVyYXRpdmVPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlU2NvcGU+fVxuICovXG5jb25zdCBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkgPSBmdW5jdGlvbiAoXG4gIGVsZW1lbnRzLFxuICBpbmNsdWRlQ29udGFpbmVyLFxuICBvcHRpb25zXG4pIHtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IFtdO1xuICBjb25zdCBlbGVtZW50c1RvQ2hlY2sgPSBBcnJheS5mcm9tKGVsZW1lbnRzKTtcbiAgd2hpbGUgKGVsZW1lbnRzVG9DaGVjay5sZW5ndGgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNUb0NoZWNrLnNoaWZ0KCk7XG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ1NMT1QnKSB7XG4gICAgICAvLyBhZGQgc2hhZG93IGRvbSBzbG90IHNjb3BlIChzbG90IGl0c2VsZiBjYW5ub3QgYmUgZm9jdXNhYmxlKVxuICAgICAgY29uc3QgYXNzaWduZWQgPSBlbGVtZW50LmFzc2lnbmVkRWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhc3NpZ25lZC5sZW5ndGggPyBhc3NpZ25lZCA6IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICBjb25zdCBuZXN0ZWRDYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KGNvbnRlbnQsIHRydWUsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goLi4ubmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgIHNjb3BlUGFyZW50OiBlbGVtZW50LFxuICAgICAgICAgIGNhbmRpZGF0ZXM6IG5lc3RlZENhbmRpZGF0ZXMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayBjYW5kaWRhdGUgZWxlbWVudFxuICAgICAgY29uc3QgdmFsaWRDYW5kaWRhdGUgPSBtYXRjaGVzLmNhbGwoZWxlbWVudCwgY2FuZGlkYXRlU2VsZWN0b3IpO1xuICAgICAgaWYgKFxuICAgICAgICB2YWxpZENhbmRpZGF0ZSAmJlxuICAgICAgICBvcHRpb25zLmZpbHRlcihlbGVtZW50KSAmJlxuICAgICAgICAoaW5jbHVkZUNvbnRhaW5lciB8fCAhZWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpXG4gICAgICApIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBpdGVyYXRlIG92ZXIgc2hhZG93IGNvbnRlbnQgaWYgcG9zc2libGVcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPVxuICAgICAgICBlbGVtZW50LnNoYWRvd1Jvb3QgfHxcbiAgICAgICAgLy8gY2hlY2sgZm9yIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xuICAgICAgICAodHlwZW9mIG9wdGlvbnMuZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgIG9wdGlvbnMuZ2V0U2hhZG93Um9vdChlbGVtZW50KSk7XG5cbiAgICAgIGNvbnN0IHZhbGlkU2hhZG93Um9vdCA9XG4gICAgICAgICFvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIgfHwgb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyKGVsZW1lbnQpO1xuXG4gICAgICBpZiAoc2hhZG93Um9vdCAmJiB2YWxpZFNoYWRvd1Jvb3QpIHtcbiAgICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2NvcGUgSUlGIGEgc2hhZG93IHJvb3Qgbm9kZSB3YXMgZ2l2ZW47IG90aGVyd2lzZSwgYW4gdW5kaXNjbG9zZWRcbiAgICAgICAgLy8gIHNoYWRvdyBleGlzdHMsIHNvIGxvb2sgYXQgbGlnaHQgZG9tIGNoaWxkcmVuIGFzIGZhbGxiYWNrIEJVVCBjcmVhdGUgYSBzY29wZSBmb3IgYW55XG4gICAgICAgIC8vICBjaGlsZCBjYW5kaWRhdGVzIGZvdW5kIGJlY2F1c2UgdGhleSdyZSBsaWtlbHkgc2xvdHRlZCBlbGVtZW50cyAoZWxlbWVudHMgdGhhdCBhcmVcbiAgICAgICAgLy8gIGNoaWxkcmVuIG9mIHRoZSB3ZWIgY29tcG9uZW50IGVsZW1lbnQgKHdoaWNoIGhhcyB0aGUgc2hhZG93KSwgaW4gdGhlIGxpZ2h0IGRvbSwgYnV0XG4gICAgICAgIC8vICBzbG90dGVkIHNvbWV3aGVyZSBfaW5zaWRlXyB0aGUgdW5kaXNjbG9zZWQgc2hhZG93KSAtLSB0aGUgc2NvcGUgaXMgY3JlYXRlZCBiZWxvdyxcbiAgICAgICAgLy8gIF9hZnRlcl8gd2UgcmV0dXJuIGZyb20gdGhpcyByZWN1cnNpdmUgY2FsbFxuICAgICAgICBjb25zdCBuZXN0ZWRDYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFxuICAgICAgICAgIHNoYWRvd1Jvb3QgPT09IHRydWUgPyBlbGVtZW50LmNoaWxkcmVuIDogc2hhZG93Um9vdC5jaGlsZHJlbixcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKC4uLm5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICBzY29wZVBhcmVudDogZWxlbWVudCxcbiAgICAgICAgICAgIGNhbmRpZGF0ZXM6IG5lc3RlZENhbmRpZGF0ZXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZXJlJ3Mgbm90IHNoYWRvdyBzbyBqdXN0IGRpZyBpbnRvIHRoZSBlbGVtZW50J3MgKGxpZ2h0IGRvbSkgY2hpbGRyZW5cbiAgICAgICAgLy8gIF9fd2l0aG91dF9fIGdpdmluZyB0aGUgZWxlbWVudCBzcGVjaWFsIHNjb3BlIHRyZWF0bWVudFxuICAgICAgICBlbGVtZW50c1RvQ2hlY2sudW5zaGlmdCguLi5lbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG5jb25zdCBnZXRUYWJpbmRleCA9IGZ1bmN0aW9uIChub2RlLCBpc1Njb3BlKSB7XG4gIGlmIChub2RlLnRhYkluZGV4IDwgMCkge1xuICAgIC8vIGluIENocm9tZSwgPGRldGFpbHMvPiwgPGF1ZGlvIGNvbnRyb2xzLz4gYW5kIDx2aWRlbyBjb250cm9scy8+IGVsZW1lbnRzIGdldCBhIGRlZmF1bHRcbiAgICAvLyBgdGFiSW5kZXhgIG9mIC0xIHdoZW4gdGhlICd0YWJpbmRleCcgYXR0cmlidXRlIGlzbid0IHNwZWNpZmllZCBpbiB0aGUgRE9NLFxuICAgIC8vIHlldCB0aGV5IGFyZSBzdGlsbCBwYXJ0IG9mIHRoZSByZWd1bGFyIHRhYiBvcmRlcjsgaW4gRkYsIHRoZXkgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgMDsgc2luY2UgQ2hyb21lIHN0aWxsIHB1dHMgdGhvc2UgZWxlbWVudHMgaW4gdGhlIHJlZ3VsYXIgdGFiXG4gICAgLy8gb3JkZXIsIGNvbnNpZGVyIHRoZWlyIHRhYiBpbmRleCB0byBiZSAwLlxuICAgIC8vIEFsc28gYnJvd3NlcnMgZG8gbm90IHJldHVybiBgdGFiSW5kZXhgIGNvcnJlY3RseSBmb3IgY29udGVudEVkaXRhYmxlIG5vZGVzO1xuICAgIC8vIHNvIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHRhYmluZGV4IGF0dHJpYnV0ZSBzcGVjaWZpY2FsbHkgc2V0LCBhc3N1bWUgaXQncyAwLlxuICAgIC8vXG4gICAgLy8gaXNTY29wZSBpcyBwb3NpdGl2ZSBmb3IgY3VzdG9tIGVsZW1lbnQgd2l0aCBzaGFkb3cgcm9vdCBvciBzbG90IHRoYXQgYnkgZGVmYXVsdFxuICAgIC8vIGhhdmUgdGFiSW5kZXggLTEsIGJ1dCBuZWVkIHRvIGJlIHNvcnRlZCBieSBkb2N1bWVudCBvcmRlciBpbiBvcmRlciBmb3IgdGhlaXJcbiAgICAvLyBjb250ZW50IHRvIGJlIGluc2VydGVkIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uXG4gICAgaWYgKFxuICAgICAgKGlzU2NvcGUgfHxcbiAgICAgICAgL14oQVVESU98VklERU98REVUQUlMUykkLy50ZXN0KG5vZGUudGFnTmFtZSkgfHxcbiAgICAgICAgbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkgJiZcbiAgICAgIGlzTmFOKHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZS50YWJJbmRleDtcbn07XG5cbmNvbnN0IHNvcnRPcmRlcmVkVGFiYmFibGVzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXhcbiAgICA/IGEuZG9jdW1lbnRPcmRlciAtIGIuZG9jdW1lbnRPcmRlclxuICAgIDogYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XG59O1xuXG5jb25zdCBpc0lucHV0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0lOUFVUJztcbn07XG5cbmNvbnN0IGlzSGlkZGVuSW5wdXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdoaWRkZW4nO1xufTtcblxuY29uc3QgaXNEZXRhaWxzV2l0aFN1bW1hcnkgPSBmdW5jdGlvbiAobm9kZSkge1xuICBjb25zdCByID1cbiAgICBub2RlLnRhZ05hbWUgPT09ICdERVRBSUxTJyAmJlxuICAgIEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgLmFwcGx5KG5vZGUuY2hpbGRyZW4pXG4gICAgICAuc29tZSgoY2hpbGQpID0+IGNoaWxkLnRhZ05hbWUgPT09ICdTVU1NQVJZJyk7XG4gIHJldHVybiByO1xufTtcblxuY29uc3QgZ2V0Q2hlY2tlZFJhZGlvID0gZnVuY3Rpb24gKG5vZGVzLCBmb3JtKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0uY2hlY2tlZCAmJiBub2Rlc1tpXS5mb3JtID09PSBmb3JtKSB7XG4gICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBpc1RhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoIW5vZGUubmFtZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHJhZGlvU2NvcGUgPSBub2RlLmZvcm0gfHwgZ2V0Um9vdE5vZGUobm9kZSk7XG4gIGNvbnN0IHF1ZXJ5UmFkaW9zID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gcmFkaW9TY29wZS5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJ1xuICAgICk7XG4gIH07XG5cbiAgbGV0IHJhZGlvU2V0O1xuICBpZiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LkNTUyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LkNTUy5lc2NhcGUgPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdMb29rcyBsaWtlIHlvdSBoYXZlIGEgcmFkaW8gYnV0dG9uIHdpdGggYSBuYW1lIGF0dHJpYnV0ZSBjb250YWluaW5nIGludmFsaWQgQ1NTIHNlbGVjdG9yIGNoYXJhY3RlcnMgYW5kIG5lZWQgdGhlIENTUy5lc2NhcGUgcG9seWZpbGw6ICVzJyxcbiAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2hlY2tlZCA9IGdldENoZWNrZWRSYWRpbyhyYWRpb1NldCwgbm9kZS5mb3JtKTtcbiAgcmV0dXJuICFjaGVja2VkIHx8IGNoZWNrZWQgPT09IG5vZGU7XG59O1xuXG5jb25zdCBpc1JhZGlvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAncmFkaW8nO1xufTtcblxuY29uc3QgaXNOb25UYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIGlzUmFkaW8obm9kZSkgJiYgIWlzVGFiYmFibGVSYWRpbyhub2RlKTtcbn07XG5cbi8vIGRldGVybWluZXMgaWYgYSBub2RlIGlzIHVsdGltYXRlbHkgYXR0YWNoZWQgdG8gdGhlIHdpbmRvdydzIGRvY3VtZW50XG5jb25zdCBpc05vZGVBdHRhY2hlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIC8vIFRoZSByb290IG5vZGUgaXMgdGhlIHNoYWRvdyByb290IGlmIHRoZSBub2RlIGlzIGluIGEgc2hhZG93IERPTTsgc29tZSBkb2N1bWVudCBvdGhlcndpc2VcbiAgLy8gIChidXQgTk9UIF90aGVfIGRvY3VtZW50OyBzZWUgc2Vjb25kICdJZicgY29tbWVudCBiZWxvdyBmb3IgbW9yZSkuXG4gIC8vIElmIHJvb3ROb2RlIGlzIHNoYWRvdyByb290LCBpdCdsbCBoYXZlIGEgaG9zdCwgd2hpY2ggaXMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHNoYWRvd1xuICAvLyAgaXMgYXR0YWNoZWQsIGFuZCB0aGUgb25lIHdlIG5lZWQgdG8gY2hlY2sgaWYgaXQncyBpbiB0aGUgZG9jdW1lbnQgb3Igbm90IChiZWNhdXNlIHRoZVxuICAvLyAgc2hhZG93LCBhbmQgYWxsIG5vZGVzIGl0IGNvbnRhaW5zLCBpcyBuZXZlciBjb25zaWRlcmVkIGluIHRoZSBkb2N1bWVudCBzaW5jZSBzaGFkb3dzXG4gIC8vICBiZWhhdmUgbGlrZSBzZWxmLWNvbnRhaW5lZCBET01zOyBidXQgaWYgdGhlIHNoYWRvdydzIEhPU1QsIHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50LFxuICAvLyAgaXMgaGlkZGVuLCBvciBpcyBub3QgaW4gdGhlIGRvY3VtZW50IGl0c2VsZiBidXQgaXMgZGV0YWNoZWQsIGl0IHdpbGwgYWZmZWN0IHRoZSBzaGFkb3cnc1xuICAvLyAgdmlzaWJpbGl0eSwgaW5jbHVkaW5nIGFsbCB0aGUgbm9kZXMgaXQgY29udGFpbnMpLiBUaGUgaG9zdCBjb3VsZCBiZSBhbnkgbm9ybWFsIG5vZGUsXG4gIC8vICBvciBhIGN1c3RvbSBlbGVtZW50IChpLmUuIHdlYiBjb21wb25lbnQpLiBFaXRoZXIgd2F5LCB0aGF0J3MgdGhlIG9uZSB0aGF0IGlzIGNvbnNpZGVyZWRcbiAgLy8gIHBhcnQgb2YgdGhlIGRvY3VtZW50LCBub3QgdGhlIHNoYWRvdyByb290LCBub3IgYW55IG9mIGl0cyBjaGlsZHJlbiAoaS5lLiB0aGUgbm9kZSBiZWluZ1xuICAvLyAgdGVzdGVkKS5cbiAgLy8gVG8gZnVydGhlciBjb21wbGljYXRlIHRoaW5ncywgd2UgaGF2ZSB0byBsb29rIGFsbCB0aGUgd2F5IHVwIHVudGlsIHdlIGZpbmQgYSBzaGFkb3cgSE9TVFxuICAvLyAgdGhhdCBpcyBhdHRhY2hlZCAob3IgZmluZCBub25lKSBiZWNhdXNlIHRoZSBub2RlIG1pZ2h0IGJlIGluIG5lc3RlZCBzaGFkb3dzLi4uXG4gIC8vIElmIHJvb3ROb2RlIGlzIG5vdCBhIHNoYWRvdyByb290LCBpdCB3b24ndCBoYXZlIGEgaG9zdCwgYW5kIHNvIHJvb3ROb2RlIHNob3VsZCBiZSB0aGVcbiAgLy8gIGRvY3VtZW50IChwZXIgdGhlIGRvY3MpIGFuZCB3aGlsZSBpdCdzIGEgRG9jdW1lbnQtdHlwZSBvYmplY3QsIHRoYXQgZG9jdW1lbnQgZG9lcyBub3RcbiAgLy8gIGFwcGVhciB0byBiZSB0aGUgc2FtZSBhcyB0aGUgbm9kZSdzIGBvd25lckRvY3VtZW50YCBmb3Igc29tZSByZWFzb24sIHNvIGl0J3Mgc2FmZXJcbiAgLy8gIHRvIGlnbm9yZSB0aGUgcm9vdE5vZGUgYXQgdGhpcyBwb2ludCwgYW5kIHVzZSBgbm9kZS5vd25lckRvY3VtZW50YC4gT3RoZXJ3aXNlLFxuICAvLyAgdXNpbmcgYHJvb3ROb2RlLmNvbnRhaW5zKG5vZGUpYCB3aWxsIF9hbHdheXNfIGJlIHRydWUgd2UnbGwgZ2V0IGZhbHNlLXBvc2l0aXZlcyB3aGVuXG4gIC8vICBub2RlIGlzIGFjdHVhbGx5IGRldGFjaGVkLlxuICBsZXQgbm9kZVJvb3RIb3N0ID0gZ2V0Um9vdE5vZGUobm9kZSkuaG9zdDtcbiAgbGV0IGF0dGFjaGVkID0gISEoXG4gICAgbm9kZVJvb3RIb3N0Py5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGVSb290SG9zdCkgfHxcbiAgICBub2RlLm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZSlcbiAgKTtcblxuICB3aGlsZSAoIWF0dGFjaGVkICYmIG5vZGVSb290SG9zdCkge1xuICAgIC8vIHNpbmNlIGl0J3Mgbm90IGF0dGFjaGVkIGFuZCB3ZSBoYXZlIGEgcm9vdCBob3N0LCB0aGUgbm9kZSBNVVNUIGJlIGluIGEgbmVzdGVkIHNoYWRvdyBET00sXG4gICAgLy8gIHdoaWNoIG1lYW5zIHdlIG5lZWQgdG8gZ2V0IHRoZSBob3N0J3MgaG9zdCBhbmQgY2hlY2sgaWYgdGhhdCBwYXJlbnQgaG9zdCBpcyBjb250YWluZWRcbiAgICAvLyAgaW4gKGkuZS4gYXR0YWNoZWQgdG8pIHRoZSBkb2N1bWVudFxuICAgIG5vZGVSb290SG9zdCA9IGdldFJvb3ROb2RlKG5vZGVSb290SG9zdCkuaG9zdDtcbiAgICBhdHRhY2hlZCA9ICEhbm9kZVJvb3RIb3N0Py5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGVSb290SG9zdCk7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoZWQ7XG59O1xuXG5jb25zdCBpc1plcm9BcmVhID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gd2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwO1xufTtcbmNvbnN0IGlzSGlkZGVuID0gZnVuY3Rpb24gKG5vZGUsIHsgZGlzcGxheUNoZWNrLCBnZXRTaGFkb3dSb290IH0pIHtcbiAgLy8gTk9URTogdmlzaWJpbGl0eSB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIG5vZGUgaXMgZGV0YWNoZWQgZnJvbSB0aGUgZG9jdW1lbnRcbiAgLy8gIChzZWUgbm90ZXMgYWJvdXQgdGhpcyBmdXJ0aGVyIGRvd24pLCB3aGljaCBtZWFucyB3ZSB3aWxsIGNvbnNpZGVyIGl0IHZpc2libGVcbiAgLy8gICh0aGlzIGlzIGxlZ2FjeSBiZWhhdmlvciBmcm9tIGEgdmVyeSBsb25nIHdheSBiYWNrKVxuICAvLyBOT1RFOiB3ZSBjaGVjayB0aGlzIHJlZ2FyZGxlc3Mgb2YgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgYmVjYXVzZSB0aGlzIGlzIGFcbiAgLy8gIF92aXNpYmlsaXR5XyBjaGVjaywgbm90IGEgX2Rpc3BsYXlfIGNoZWNrXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBpc0RpcmVjdFN1bW1hcnkgPSBtYXRjaGVzLmNhbGwobm9kZSwgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyk7XG4gIGNvbnN0IG5vZGVVbmRlckRldGFpbHMgPSBpc0RpcmVjdFN1bW1hcnkgPyBub2RlLnBhcmVudEVsZW1lbnQgOiBub2RlO1xuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGVVbmRlckRldGFpbHMsICdkZXRhaWxzOm5vdChbb3Blbl0pIConKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKFxuICAgICFkaXNwbGF5Q2hlY2sgfHxcbiAgICBkaXNwbGF5Q2hlY2sgPT09ICdmdWxsJyB8fFxuICAgIGRpc3BsYXlDaGVjayA9PT0gJ2xlZ2FjeS1mdWxsJ1xuICApIHtcbiAgICBpZiAodHlwZW9mIGdldFNoYWRvd1Jvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgd2Ugc2hvdWxkIGNvbnNpZGVyIHRoZSBub2RlIHRvIGJlIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyBhbmQgdXNlIHRoZVxuICAgICAgLy8gICdub24temVyby1hcmVhJyBmYWxsYmFja1xuICAgICAgY29uc3Qgb3JpZ2luYWxOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlID0gZ2V0Um9vdE5vZGUobm9kZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYXJlbnRFbGVtZW50ICYmXG4gICAgICAgICAgIXBhcmVudEVsZW1lbnQuc2hhZG93Um9vdCAmJlxuICAgICAgICAgIGdldFNoYWRvd1Jvb3QocGFyZW50RWxlbWVudCkgPT09IHRydWUgLy8gY2hlY2sgaWYgdGhlcmUncyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3dcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gbm9kZSBoYXMgYW4gdW5kaXNjbG9zZWQgc2hhZG93IHdoaWNoIG1lYW5zIHdlIGNhbiBvbmx5IHRyZWF0IGl0IGFzIGEgYmxhY2sgYm94LCBzbyB3ZVxuICAgICAgICAgIC8vICBmYWxsIGJhY2sgdG8gYSBub24temVyby1hcmVhIHRlc3RcbiAgICAgICAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgc2xvdFxuICAgICAgICAgIG5vZGUgPSBub2RlLmFzc2lnbmVkU2xvdDtcbiAgICAgICAgfSBlbHNlIGlmICghcGFyZW50RWxlbWVudCAmJiByb290Tm9kZSAhPT0gbm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgLy8gY3Jvc3Mgc2hhZG93IGJvdW5kYXJ5XG4gICAgICAgICAgbm9kZSA9IHJvb3ROb2RlLmhvc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaXRlcmF0ZSB1cCBub3JtYWwgZG9tXG4gICAgICAgICAgbm9kZSA9IHBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG9yaWdpbmFsTm9kZTtcbiAgICB9XG4gICAgLy8gZWxzZSwgYGdldFNoYWRvd1Jvb3RgIG1pZ2h0IGJlIHRydWUsIGJ1dCBhbGwgdGhhdCBkb2VzIGlzIGVuYWJsZSBzaGFkb3cgRE9NIHN1cHBvcnRcbiAgICAvLyAgKGkuZS4gaXQgZG9lcyBub3QgYWxzbyBwcmVzdW1lIHRoYXQgYWxsIG5vZGVzIG1pZ2h0IGhhdmUgdW5kaXNjbG9zZWQgc2hhZG93cyk7IG9yXG4gICAgLy8gIGl0IG1pZ2h0IGJlIGEgZmFsc3kgdmFsdWUsIHdoaWNoIG1lYW5zIHNoYWRvdyBET00gc3VwcG9ydCBpcyBkaXNhYmxlZFxuXG4gICAgLy8gU2luY2Ugd2UgZGlkbid0IGZpbmQgaXQgc2l0dGluZyBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgKG9yIHNoYWRvd3MgYXJlIGRpc2FibGVkKVxuICAgIC8vICBub3cgd2UgY2FuIGp1c3QgdGVzdCB0byBzZWUgaWYgaXQgd291bGQgbm9ybWFsbHkgYmUgdmlzaWJsZSBvciBub3QsIHByb3ZpZGVkIGl0J3NcbiAgICAvLyAgYXR0YWNoZWQgdG8gdGhlIG1haW4gZG9jdW1lbnQuXG4gICAgLy8gTk9URTogV2UgbXVzdCBjb25zaWRlciBjYXNlIHdoZXJlIG5vZGUgaXMgaW5zaWRlIGEgc2hhZG93IERPTSBhbmQgZ2l2ZW4gZGlyZWN0bHkgdG9cbiAgICAvLyAgYGlzVGFiYmFibGUoKWAgb3IgYGlzRm9jdXNhYmxlKClgIC0tIHJlZ2FyZGxlc3Mgb2YgYGdldFNoYWRvd1Jvb3RgIG9wdGlvbiBzZXR0aW5nLlxuXG4gICAgaWYgKGlzTm9kZUF0dGFjaGVkKG5vZGUpKSB7XG4gICAgICAvLyB0aGlzIHdvcmtzIHdoZXJldmVyIHRoZSBub2RlIGlzOiBpZiB0aGVyZSdzIGF0IGxlYXN0IG9uZSBjbGllbnQgcmVjdCwgaXQnc1xuICAgICAgLy8gIHNvbWVob3cgZGlzcGxheWVkOyBpdCBhbHNvIGNvdmVycyB0aGUgQ1NTICdkaXNwbGF5OiBjb250ZW50cycgY2FzZSB3aGVyZSB0aGVcbiAgICAgIC8vICBub2RlIGl0c2VsZiBpcyBoaWRkZW4gaW4gcGxhY2Ugb2YgaXRzIGNvbnRlbnRzOyBhbmQgdGhlcmUncyBubyBuZWVkIHRvIHNlYXJjaFxuICAgICAgLy8gIHVwIHRoZSBoaWVyYXJjaHkgZWl0aGVyXG4gICAgICByZXR1cm4gIW5vZGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gRWxzZSwgdGhlIG5vZGUgaXNuJ3QgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LCB3aGljaCBtZWFucyB0aGUgYGdldENsaWVudFJlY3RzKClgXG4gICAgLy8gIEFQSSB3aWxsIF9fYWx3YXlzX18gcmV0dXJuIHplcm8gcmVjdHMgKHRoaXMgY2FuIGhhcHBlbiwgZm9yIGV4YW1wbGUsIGlmIFJlYWN0XG4gICAgLy8gIGlzIHVzZWQgdG8gcmVuZGVyIG5vZGVzIG9udG8gYSBkZXRhY2hlZCB0cmVlLCBhcyBjb25maXJtZWQgaW4gdGhpcyB0aHJlYWQ6XG4gICAgLy8gIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvOTExNyNpc3N1ZWNvbW1lbnQtMjg0MjI4ODcwKVxuICAgIC8vXG4gICAgLy8gSXQgYWxzbyBtZWFucyB0aGF0IGV2ZW4gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSkuZGlzcGxheSB3aWxsIHJldHVybiBgdW5kZWZpbmVkYFxuICAgIC8vICBiZWNhdXNlIHN0eWxlcyBhcmUgb25seSBjb21wdXRlZCBmb3Igbm9kZXMgdGhhdCBhcmUgaW4gdGhlIGRvY3VtZW50LlxuICAgIC8vXG4gICAgLy8gTk9URTogVEhJUyBIQVMgQkVFTiBUSEUgQ0FTRSBGT1IgWUVBUlMuIEl0IGlzIG5vdCBuZXcsIG5vciBpcyBpdCBjYXVzZWQgYnkgdGFiYmFibGVcbiAgICAvLyAgc29tZWhvdy4gVGhvdWdoIGl0IHdhcyBuZXZlciBzdGF0ZWQgb2ZmaWNpYWxseSwgYW55b25lIHdobyBoYXMgZXZlciB1c2VkIHRhYmJhYmxlXG4gICAgLy8gIEFQSXMgb24gbm9kZXMgaW4gZGV0YWNoZWQgY29udGFpbmVycyBoYXMgYWN0dWFsbHkgaW1wbGljaXRseSB1c2VkIHRhYmJhYmxlIGluIHdoYXRcbiAgICAvLyAgd2FzIGxhdGVyIChhcyBvZiB2NS4yLjAgb24gQXByIDksIDIwMjEpIGNhbGxlZCBgZGlzcGxheUNoZWNrPVwibm9uZVwiYCBtb2RlIC0tIGVzc2VudGlhbGx5XG4gICAgLy8gIGNvbnNpZGVyaW5nIF9fZXZlcnl0aGluZ19fIHRvIGJlIHZpc2libGUgYmVjYXVzZSBvZiB0aGUgaW5uYWJpbGl0eSB0byBkZXRlcm1pbmUgc3R5bGVzLlxuICAgIC8vXG4gICAgLy8gdjYuMC4wOiBBcyBvZiB0aGlzIG1ham9yIHJlbGVhc2UsIHRoZSBkZWZhdWx0ICdmdWxsJyBvcHRpb24gX19ubyBsb25nZXIgdHJlYXRzIGRldGFjaGVkXG4gICAgLy8gIG5vZGVzIGFzIHZpc2libGUgd2l0aCB0aGUgJ25vbmUnIGZhbGxiYWNrLl9fXG4gICAgaWYgKGRpc3BsYXlDaGVjayAhPT0gJ2xlZ2FjeS1mdWxsJykge1xuICAgICAgcmV0dXJuIHRydWU7IC8vIGhpZGRlblxuICAgIH1cbiAgICAvLyBlbHNlLCBmYWxsYmFjayB0byAnbm9uZScgbW9kZSBhbmQgY29uc2lkZXIgdGhlIG5vZGUgdmlzaWJsZVxuICB9IGVsc2UgaWYgKGRpc3BsYXlDaGVjayA9PT0gJ25vbi16ZXJvLWFyZWEnKSB7XG4gICAgLy8gTk9URTogRXZlbiB0aG91Z2ggdGhpcyB0ZXN0cyB0aGF0IHRoZSBub2RlJ3MgY2xpZW50IHJlY3QgaXMgbm9uLXplcm8gdG8gZGV0ZXJtaW5lXG4gICAgLy8gIHdoZXRoZXIgaXQncyBkaXNwbGF5ZWQsIGFuZCB0aGF0IGEgZGV0YWNoZWQgbm9kZSB3aWxsIF9fYWx3YXlzX18gaGF2ZSBhIHplcm8tYXJlYVxuICAgIC8vICBjbGllbnQgcmVjdCwgd2UgZG9uJ3Qgc3BlY2lhbC1jYXNlIGZvciB3aGV0aGVyIHRoZSBub2RlIGlzIGF0dGFjaGVkIG9yIG5vdC4gSW5cbiAgICAvLyAgdGhpcyBtb2RlLCB3ZSBkbyB3YW50IHRvIGNvbnNpZGVyIG5vZGVzIHRoYXQgaGF2ZSBhIHplcm8gYXJlYSB0byBiZSBoaWRkZW4gYXQgYWxsXG4gICAgLy8gIHRpbWVzLCBhbmQgdGhhdCBpbmNsdWRlcyBhdHRhY2hlZCBvciBub3QuXG4gICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gIH1cblxuICAvLyB2aXNpYmxlLCBhcyBmYXIgYXMgd2UgY2FuIHRlbGwsIG9yIHBlciBjdXJyZW50IGBkaXNwbGF5Q2hlY2s9bm9uZWAgbW9kZSwgd2UgYXNzdW1lXG4gIC8vICBpdCdzIHZpc2libGVcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gZm9ybSBmaWVsZHMgKG5lc3RlZCkgaW5zaWRlIGEgZGlzYWJsZWQgZmllbGRzZXQgYXJlIG5vdCBmb2N1c2FibGUvdGFiYmFibGVcbi8vICB1bmxlc3MgdGhleSBhcmUgaW4gdGhlIF9maXJzdF8gPGxlZ2VuZD4gZWxlbWVudCBvZiB0aGUgdG9wLW1vc3QgZGlzYWJsZWRcbi8vICBmaWVsZHNldFxuY29uc3QgaXNEaXNhYmxlZEZyb21GaWVsZHNldCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICgvXihJTlBVVHxCVVRUT058U0VMRUNUfFRFWFRBUkVBKSQvLnRlc3Qobm9kZS50YWdOYW1lKSkge1xuICAgIGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIC8vIGNoZWNrIGlmIGBub2RlYCBpcyBjb250YWluZWQgaW4gYSBkaXNhYmxlZCA8ZmllbGRzZXQ+XG4gICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChwYXJlbnROb2RlLnRhZ05hbWUgPT09ICdGSUVMRFNFVCcgJiYgcGFyZW50Tm9kZS5kaXNhYmxlZCkge1xuICAgICAgICAvLyBsb29rIGZvciB0aGUgZmlyc3QgPGxlZ2VuZD4gYW1vbmcgdGhlIGNoaWxkcmVuIG9mIHRoZSBkaXNhYmxlZCA8ZmllbGRzZXQ+XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pdGVtKGkpO1xuICAgICAgICAgIC8vIHdoZW4gdGhlIGZpcnN0IDxsZWdlbmQ+IChpbiBkb2N1bWVudCBvcmRlcikgaXMgZm91bmRcbiAgICAgICAgICBpZiAoY2hpbGQudGFnTmFtZSA9PT0gJ0xFR0VORCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0cyBwYXJlbnQgPGZpZWxkc2V0PiBpcyBub3QgbmVzdGVkIGluIGFub3RoZXIgZGlzYWJsZWQgPGZpZWxkc2V0PixcbiAgICAgICAgICAgIC8vIHJldHVybiB3aGV0aGVyIGBub2RlYCBpcyBhIGRlc2NlbmRhbnQgb2YgaXRzIGZpcnN0IDxsZWdlbmQ+XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcy5jYWxsKHBhcmVudE5vZGUsICdmaWVsZHNldFtkaXNhYmxlZF0gKicpXG4gICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICA6ICFjaGlsZC5jb250YWlucyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGRpc2FibGVkIDxmaWVsZHNldD4gY29udGFpbmluZyBgbm9kZWAgaGFzIG5vIDxsZWdlbmQ+XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH1cblxuICAvLyBlbHNlLCBub2RlJ3MgdGFiYmFibGUvZm9jdXNhYmxlIHN0YXRlIHNob3VsZCBub3QgYmUgYWZmZWN0ZWQgYnkgYSBmaWVsZHNldCdzXG4gIC8vICBlbmFibGVkL2Rpc2FibGVkIHN0YXRlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUgPSBmdW5jdGlvbiAob3B0aW9ucywgbm9kZSkge1xuICBpZiAoXG4gICAgbm9kZS5kaXNhYmxlZCB8fFxuICAgIGlzSGlkZGVuSW5wdXQobm9kZSkgfHxcbiAgICBpc0hpZGRlbihub2RlLCBvcHRpb25zKSB8fFxuICAgIC8vIEZvciBhIGRldGFpbHMgZWxlbWVudCB3aXRoIGEgc3VtbWFyeSwgdGhlIHN1bW1hcnkgZWxlbWVudCBnZXRzIHRoZSBmb2N1c1xuICAgIGlzRGV0YWlsc1dpdGhTdW1tYXJ5KG5vZGUpIHx8XG4gICAgaXNEaXNhYmxlZEZyb21GaWVsZHNldChub2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUgPSBmdW5jdGlvbiAob3B0aW9ucywgbm9kZSkge1xuICBpZiAoXG4gICAgaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHx8XG4gICAgZ2V0VGFiaW5kZXgobm9kZSkgPCAwIHx8XG4gICAgIWlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSA9IGZ1bmN0aW9uIChzaGFkb3dIb3N0Tm9kZSkge1xuICBjb25zdCB0YWJJbmRleCA9IHBhcnNlSW50KHNoYWRvd0hvc3ROb2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApO1xuICBpZiAoaXNOYU4odGFiSW5kZXgpIHx8IHRhYkluZGV4ID49IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBJZiBhIGN1c3RvbSBlbGVtZW50IGhhcyBhbiBleHBsaWNpdCBuZWdhdGl2ZSB0YWJpbmRleCxcbiAgLy8gYnJvd3NlcnMgd2lsbCBub3QgYWxsb3cgdGFiIHRhcmdldGluZyBzYWlkIGVsZW1lbnQncyBjaGlsZHJlbi5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZVNjb3BlPn0gY2FuZGlkYXRlc1xuICogQHJldHVybnMgRWxlbWVudFtdXG4gKi9cbmNvbnN0IHNvcnRCeU9yZGVyID0gZnVuY3Rpb24gKGNhbmRpZGF0ZXMpIHtcbiAgY29uc3QgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICBjb25zdCBvcmRlcmVkVGFiYmFibGVzID0gW107XG4gIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIGNvbnN0IGlzU2NvcGUgPSAhIWl0ZW0uc2NvcGVQYXJlbnQ7XG4gICAgY29uc3QgZWxlbWVudCA9IGlzU2NvcGUgPyBpdGVtLnNjb3BlUGFyZW50IDogaXRlbTtcbiAgICBjb25zdCBjYW5kaWRhdGVUYWJpbmRleCA9IGdldFRhYmluZGV4KGVsZW1lbnQsIGlzU2NvcGUpO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gaXNTY29wZSA/IHNvcnRCeU9yZGVyKGl0ZW0uY2FuZGlkYXRlcykgOiBlbGVtZW50O1xuICAgIGlmIChjYW5kaWRhdGVUYWJpbmRleCA9PT0gMCkge1xuICAgICAgaXNTY29wZVxuICAgICAgICA/IHJlZ3VsYXJUYWJiYWJsZXMucHVzaCguLi5lbGVtZW50cylcbiAgICAgICAgOiByZWd1bGFyVGFiYmFibGVzLnB1c2goZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yZGVyZWRUYWJiYWJsZXMucHVzaCh7XG4gICAgICAgIGRvY3VtZW50T3JkZXI6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVUYWJpbmRleCxcbiAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgaXNTY29wZTogaXNTY29wZSxcbiAgICAgICAgY29udGVudDogZWxlbWVudHMsXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvcmRlcmVkVGFiYmFibGVzXG4gICAgLnNvcnQoc29ydE9yZGVyZWRUYWJiYWJsZXMpXG4gICAgLnJlZHVjZSgoYWNjLCBzb3J0YWJsZSkgPT4ge1xuICAgICAgc29ydGFibGUuaXNTY29wZVxuICAgICAgICA/IGFjYy5wdXNoKC4uLnNvcnRhYmxlLmNvbnRlbnQpXG4gICAgICAgIDogYWNjLnB1c2goc29ydGFibGUuY29udGVudCk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKVxuICAgIC5jb25jYXQocmVndWxhclRhYmJhYmxlcyk7XG59O1xuXG5jb25zdCB0YWJiYWJsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBsZXQgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogZmFsc2UsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgICBzaGFkb3dSb290RmlsdGVyOiBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKFxuICAgICAgZWwsXG4gICAgICBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsXG4gICAgICBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNvcnRCeU9yZGVyKGNhbmRpZGF0ZXMpO1xufTtcblxuY29uc3QgZm9jdXNhYmxlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCBjYW5kaWRhdGVzO1xuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShbZWxdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhcbiAgICAgIGVsLFxuICAgICAgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLFxuICAgICAgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuY29uc3QgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmNvbnN0IGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovIGNhbmRpZGF0ZVNlbGVjdG9yc1xuICAuY29uY2F0KCdpZnJhbWUnKVxuICAuam9pbignLCcpO1xuXG5jb25zdCBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5leHBvcnQgeyB0YWJiYWJsZSwgZm9jdXNhYmxlLCBpc1RhYmJhYmxlLCBpc0ZvY3VzYWJsZSB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdpbmVydCcsIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gICAqIChodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsLzIwMTUvY29weXJpZ2h0LXNvZnR3YXJlLWFuZC1kb2N1bWVudCkuXG4gICAqL1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIHdlJ3JlIG5vdCBydW5uaW5nIGluc2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBOb2RlTGlzdHMuXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICAgKiBAdHlwZSB7dHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXN9XG4gICAgICovXG4gICAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdmFyIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZyA9IFsnYVtocmVmXScsICdhcmVhW2hyZWZdJywgJ2lucHV0Om5vdChbZGlzYWJsZWRdKScsICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJywgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKScsICdidXR0b246bm90KFtkaXNhYmxlZF0pJywgJ2RldGFpbHMnLCAnc3VtbWFyeScsICdpZnJhbWUnLCAnb2JqZWN0JywgJ2VtYmVkJywgJ1tjb250ZW50ZWRpdGFibGVdJ10uam9pbignLCcpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Um9vdGAgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBzdWJ0cmVlLCBpLmUuIGEgRE9NIHN1YnRyZWUgd2hvc2Ugcm9vdCBlbGVtZW50IGhhcyBhbiBgaW5lcnRgXG4gICAgICogYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogSXRzIG1haW4gZnVuY3Rpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgICAqICAgc3VidHJlZS4gVGhlIGBtYWtlU3VidHJlZVVuZm9jdXNhYmxlKClgIG1ldGhvZCBoYW5kbGVzIGNvbGxlY3RpbmcgYEluZXJ0Tm9kZWBzIHZpYSByZWdpc3RlcmluZ1xuICAgICAqICAgZWFjaCBmb2N1c2FibGUgbm9kZSBpbiB0aGUgc3VidHJlZSB3aXRoIHRoZSBzaW5nbGV0b24gYEluZXJ0TWFuYWdlcmAgd2hpY2ggbWFuYWdlcyBhbGwga25vd25cbiAgICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgICAqICAgaW5zdGFuY2UgZXhpc3RzIGZvciBlYWNoIGZvY3VzYWJsZSBub2RlIHdoaWNoIGhhcyBhdCBsZWFzdCBvbmUgaW5lcnQgcm9vdCBhcyBhbiBhbmNlc3Rvci5cbiAgICAgKlxuICAgICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAgICogICBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSByb290IG5vZGUpLiBUaGlzIGlzIGhhbmRsZWQgaW4gdGhlIGRlc3RydWN0b3IsIHdoaWNoIGNhbGxzIHRoZVxuICAgICAqICAgYGRlcmVnaXN0ZXJgIG1ldGhvZCBvbiBgSW5lcnRNYW5hZ2VyYCBmb3IgZWFjaCBtYW5hZ2VkIGluZXJ0IG5vZGUuXG4gICAgICovXG5cbiAgICB2YXIgSW5lcnRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRNYW5hZ2VyfSBpbmVydE1hbmFnZXIgVGhlIGdsb2JhbCBzaW5nbGV0b24gSW5lcnRNYW5hZ2VyIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Um9vdCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydE5vZGU+fVxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBmb2N1c2FibGUgbm9kZXMgaW4gdGhpcyBJbmVydFJvb3QncyBzdWJ0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIE1ha2UgdGhlIHN1YnRyZWUgaGlkZGVuIGZyb20gYXNzaXN0aXZlIHRlY2hub2xvZ3lcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSB0aGlzLl9yb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICAvLyBNYWtlIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIHN1YnRyZWUgdW5mb2N1c2FibGUgYW5kIGFkZCB0aGVtIHRvIF9tYW5hZ2VkTm9kZXNcbiAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSh0aGlzLl9yb290RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgICAvLyAtIGFueSBhZGRpdGlvbnMgaW4gdGhlIHN1YnRyZWU6IG1ha2UgdGhlbSB1bmZvY3VzYWJsZSB0b29cbiAgICAgICAgLy8gLSBhbnkgcmVtb3ZhbHMgZnJvbSB0aGUgc3VidHJlZTogcmVtb3ZlIHRoZW0gZnJvbSB0aGlzIGluZXJ0IHJvb3QncyBtYW5hZ2VkIG5vZGVzXG4gICAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgICAvLyAgIGVsZW1lbnQsIG1ha2UgdGhhdCBub2RlIGEgbWFuYWdlZCBub2RlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29uTXV0YXRpb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAgICogc3RvcmVkIGluIHRoaXMgb2JqZWN0IGFuZCB1cGRhdGVzIHRoZSBzdGF0ZSBvZiBhbGwgb2YgdGhlIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBOb3RlIHdlIGNhc3QgdGhlIG51bGxzIHRvIHRoZSBBTlkgdHlwZSBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAgIC8vICAgIG5lZWQgZXZlbiBtb3JlIGNhc3RzIHRocm91Z2hvdXQgdGhpcyBjb2RlLiBBbGwgYmV0cyBhcmUgb2ZmIGlmIGFuXG4gICAgICAgICAgLy8gICAgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkIGFuZCBhIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgICAgLy8gICAgdG8ga25vdyB3aGljaCBwcm9wZXJ0aWVzIHdlJ3JlIHNldHRpbmcuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4geyFTZXQ8IUluZXJ0Tm9kZT59IEEgY29weSBvZiB0aGlzIEluZXJ0Um9vdCdzIG1hbmFnZWQgbm9kZXMgc2V0LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBzdGFydE5vZGUgbWF5IGJlIGluIHNoYWRvdyBET00sIHNvIGZpbmQgaXRzIG5lYXJlc3Qgc2hhZG93Um9vdCB0byBnZXQgdGhlIGFjdGl2ZUVsZW1lbnQuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R9ICovbm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0Tm9kZS5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgICAvLyBjYWxsaW5nIGJsdXIoKSB3aWxsIG5vdCBhY3R1YWxseSBtb3ZlIHRoZSBmb2N1cy5cbiAgICAgICAgICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMgd2UgY2FsbCBmb2N1cygpIG9uIHRoZSBib2R5IGluc3RlYWQuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmlzaXROb2RlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuXG4gICAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAgIC8vIHRoaXMgaW5lcnQgcm9vdCwgc28gYWxsIG9mIGl0cyBtYW5hZ2VkIG5vZGVzIG5lZWQgdG8gYmUgYWRvcHRlZCBieSB0aGlzIEluZXJ0Um9vdC5cbiAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIucmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmFkZChpbmVydE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShpbmVydE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBlbnRpcmUgc3VidHJlZSBzdGFydGluZyBhdCBgc3RhcnROb2RlYC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlU3VidHJlZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fdW5tYW5hZ2VOb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgZGVzY2VuZGFudCBub2RlIGlzIGZvdW5kIHdpdGggYW4gYGluZXJ0YCBhdHRyaWJ1dGUsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fkb3B0SW5lcnRSb290KG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcblxuICAgICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgICAgLy8gc28gcmVnaXN0ZXIgaXQgbm93IGlmIG5lZWQgYmUuXG4gICAgICAgICAgaWYgKCFpbmVydFN1YnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShzYXZlZEluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBzdWJ0cmVlIGFkZGl0aW9ucywgcmVtb3ZhbHMsIG9yIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uTXV0YXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uTXV0YXRpb24ocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAvLyBVbi1tYW5hZ2UgcmVtb3ZlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5yZW1vdmVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlLWluaXRpYWxpc2UgaW5lcnQgbm9kZSBpZiB0YWJpbmRleCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZSh0YXJnZXQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbmV3IGluZXJ0IHJvb3QgaXMgYWRkZWQsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzIGFuZCBtYWtlIHN1cmUgaXQga25vd3MgYWJvdXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBtYW5hZ2VkIG5vZGVzIGZyb20gdGhpcyBpbmVydCBzdWJyb290LlxuICAgICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRTdWJyb290Ll9tYW5hZ2VOb2RlKG1hbmFnZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5fbWFuYWdlZE5vZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/c3RyaW5nfSBhcmlhSGlkZGVuICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXJpYUhpZGRlbikge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IGFyaWFIaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydFJvb3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Tm9kZWAgaW5pdGlhbGlzZXMgYW5kIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgbm9kZS5cbiAgICAgKiBBIG5vZGUgaXMgaW5lcnQgaWYgaXQgaXMgYSBkZXNjZW5kYW50IG9mIG9uZSBvciBtb3JlIGluZXJ0IHJvb3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBPbiBjb25zdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHNhdmVzIHRoZSBleGlzdGluZyBgdGFiaW5kZXhgIHZhbHVlIGZvciB0aGUgbm9kZSwgaWYgYW55LCBhbmRcbiAgICAgKiBlaXRoZXIgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgb3Igc2V0cyBpdCB0byBgLTFgLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZWxlbWVudFxuICAgICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIGBJbmVydE5vZGVgIG1haW50YWlucyBhIHNldCBvZiBgSW5lcnRSb290YHMgd2hpY2ggYXJlIGRlc2NlbmRhbnRzIG9mIHRoaXMgYEluZXJ0Tm9kZWAuIFdoZW4gYW5cbiAgICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICAgKiBgSW5lcnROb2RlYCB2aWEgYHJlbW92ZUluZXJ0Um9vdCgpYCwgd2hpY2ggaW4gdHVybiBkZXN0cm95cyB0aGUgYEluZXJ0Tm9kZWAgaWYgbm8gYEluZXJ0Um9vdGBzXG4gICAgICogcmVtYWluIGluIHRoZSBzZXQuIE9uIGRlc3RydWN0aW9uLCBgSW5lcnROb2RlYCByZWluc3RhdGVzIHRoZSBzdG9yZWQgYHRhYmluZGV4YCBpZiBvbmUgZXhpc3RzLFxuICAgICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIEEgZm9jdXNhYmxlIGVsZW1lbnQgdG8gYmUgbWFkZSBpbmVydC5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290IFRoZSBpbmVydCByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5lcnQgbm9kZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnROb2RlKTtcblxuICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Um9vdD59IFRoZSBzZXQgb2YgZGVzY2VuZGFudCBpbmVydCByb290cy5cbiAgICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgU2V0KFtpbmVydFJvb3RdKTtcblxuICAgICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2F2ZSBhbnkgcHJpb3IgdGFiaW5kZXggaW5mbyBhbmQgbWFrZSB0aGlzIG5vZGUgdW50YWJiYWJsZVxuICAgICAgICB0aGlzLmVuc3VyZVVudGFiYmFibGUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLlxuICAgICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Tm9kZSwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMuX25vZGU7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYGRlbGV0ZWAgdG8gcmVzdG9yZSBuYXRpdmUgZm9jdXMgbWV0aG9kLlxuICAgICAgICAgICAgaWYgKHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgICB0aGlzLl9ub2RlID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQsIGFueSBhdHRlbXB0IHRvIGFjY2VzcyBpdCB3aWxsIGNhdXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Rocm93SWZEZXN0cm95ZWQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Rocm93SWZEZXN0cm95ZWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgICAgLyoqIFNhdmUgdGhlIGV4aXN0aW5nIHRhYmluZGV4IHZhbHVlIGFuZCBtYWtlIHRoZSBub2RlIHVudGFiYmFibGUgYW5kIHVuZm9jdXNhYmxlICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmVVbnRhYmJhYmxlKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSkge1xuICAgICAgICAgICAgaWYgKCAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4ID09PSAtMSAmJiB0aGlzLmhhc1NhdmVkVGFiSW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbm90aGVyIGluZXJ0IHJvb3QgdG8gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdhZGRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLmFkZChpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBmcm9tIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICAgKiBzbyB0aGUgb2JqZWN0IHNob3VsZCBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3llZCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHshSW5lcnROb2RlfSAqL3RoaXMuX2Rlc3Ryb3llZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ25vZGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/bnVtYmVyfSB0YWJJbmRleCAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YWJJbmRleCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P251bWJlcn0gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBXaGVuIGFuIGVsZW1lbnQgYmVjb21lcyBhbiBpbmVydCByb290IGJ5IGhhdmluZyBhbiBgaW5lcnRgIGF0dHJpYnV0ZSBzZXQgYW5kL29yIGl0cyBgaW5lcnRgXG4gICAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICAgKiBUaGUgYEluZXJ0Um9vdGAgaW4gdHVybiByZWdpc3RlcnMgaXRzZWxmIGFzIG1hbmFnaW5nIGFsbCBvZiB0aGUgZWxlbWVudCdzIGZvY3VzYWJsZSBkZXNjZW5kYW50XG4gICAgICogbm9kZXMgdmlhIHRoZSBgcmVnaXN0ZXIoKWAgbWV0aG9kLiBUaGUgYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgIGluc3RhbmNlXG4gICAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshRG9jdW1lbnR9IGRvY3VtZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRNYW5hZ2VyKTtcblxuICAgICAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHshRG9jdW1lbnR9ICovXG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIG5vZGVzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIGluZXJ0IHJvb3RzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnRSb290Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICAgKiBAdHlwZSB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gQWRkIGluZXJ0IHN0eWxlLlxuICAgICAgICBhZGRJbmVydFN0eWxlKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRvY3VtZW50TG9hZGVkLmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZCBiZSBhbiBpbmVydCByb290IG9yIG5vdC5cbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluZXJ0XG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAgICBrZXk6ICdzZXRJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbmVydChyb290LCBpbmVydCkge1xuICAgICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBpbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmVydFJvb3QgPSBuZXcgSW5lcnRSb290KHJvb3QsIHRoaXMpO1xuICAgICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290cy5zZXQocm9vdCwgaW5lcnRSb290KTtcbiAgICAgICAgICAgIC8vIElmIG5vdCBjb250YWluZWQgaW4gdGhlIGRvY3VtZW50LCBpdCBtdXN0IGJlIGluIGEgc2hhZG93Um9vdC5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHJvb3QpKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgYWRkSW5lcnRTdHlsZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgICAgX2luZXJ0Um9vdC5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShyb290KTtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIEluZXJ0Um9vdCBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBlbGVtZW50LCBpZiBhbnkuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmVydFJvb3QoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbmVydFJvb3RzLmdldChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBub2RlLlxuICAgICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgICAqIGJlIGFkZGVkIHRvIGl0cyBzZXQgb2YgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Tm9kZX0gaW5lcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbm9kZSB3YXMgYWxyZWFkeSBpbiBhbiBpbmVydCBzdWJ0cmVlXG4gICAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZXJ0Tm9kZSA9IG5ldyBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuc2V0KG5vZGUsIGluZXJ0Tm9kZSk7XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlLXJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIGluZXJ0IG5vZGUuXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICAgKiBub2RlIGZyb20gdGhlIEluZXJ0TWFuYWdlcidzIHNldCBvZiBtYW5hZ2VkIG5vZGVzIGlmIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICogSWYgdGhlIG5vZGUgaXMgbm90IGN1cnJlbnRseSBtYW5hZ2VkLCB0aGlzIGlzIGVzc2VudGlhbGx5IGEgbm8tb3AuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7P0luZXJ0Tm9kZX0gVGhlIHBvdGVudGlhbGx5IGRlc3Ryb3llZCBJbmVydE5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgaWYgYW55LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXJlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKCFpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0Tm9kZS5yZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9jdW1lbnRMb2FkZWQoKSB7XG4gICAgICAgICAgLy8gRmluZCBhbGwgaW5lcnQgcm9vdHMgaW4gZG9jdW1lbnQgYW5kIG1ha2UgdGhlbSBhY3R1YWxseSBpbmVydC5cbiAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gQ29tbWVudCB0aGlzIG91dCB0byB1c2UgcHJvZ3JhbW1hdGljIEFQSSBvbmx5LlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZG9jdW1lbnQuYm9keSB8fCB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgc3VidHJlZTogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3dhdGNoRm9ySW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhdGNoRm9ySW5lcnQocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0ID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRJbmVydCh0YXJnZXQsIGluZXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRNYW5hZ2VyO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHdhbGsgdGhlIGNvbXBvc2VkIHRyZWUgZnJvbSB8bm9kZXwuXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uICghSFRNTEVsZW1lbnQpKT19IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50IHRyYXZlcnNlZCxcbiAgICAgKiAgICAgYmVmb3JlIGRlc2NlbmRpbmcgaW50byBjaGlsZCBub2Rlcy5cbiAgICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY29tcG9zZWRUcmVlV2Fsayhub2RlLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVzY2VuZCBpbnRvIG5vZGU6XG4gICAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgICAvLyB1cCBieSB0aGUgPGNvbnRlbnQ+IG9yIDxzaGFkb3c+IGVsZW1lbnRzLiBEZXNjZW5kIHN0cmFpZ2h0IGludG8gdGhlXG4gICAgICAgIC8vIFNoYWRvd1Jvb3QuXG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc2hhZG93Um9vdCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBkaXN0cmlidXRlZCBlbGVtZW50cyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnY29udGVudCcpIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmaWVzIGlmIFNoYWRvd0RvbSB2MCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIGRpc3RyaWJ1dGVkTm9kZXMgPSBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMgPyBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhkaXN0cmlidXRlZE5vZGVzW2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8c2xvdD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGFzc2lnbmVkIG5vZGVzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdzbG90Jykge1xuICAgICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZ5IGlmIFNoYWRvd0RvbSB2MSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIF9kaXN0cmlidXRlZE5vZGVzID0gc2xvdC5hc3NpZ25lZE5vZGVzID8gc2xvdC5hc3NpZ25lZE5vZGVzKHsgZmxhdHRlbjogdHJ1ZSB9KSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoX2Rpc3RyaWJ1dGVkTm9kZXNbX2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgICAvLyBlbGVtZW50LCBub3IgYSA8c2hhZG93PiBlbGVtZW50IHJlY3Vyc2Ugbm9ybWFsbHkuXG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGNoaWxkLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgICBpZiAobm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZSNpbmVydC1zdHlsZSwgbGluayNpbmVydC1zdHlsZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2luZXJ0LXN0eWxlJyk7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG5cbiAgICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgdmFyIGluZXJ0TWFuYWdlciA9IG5ldyBJbmVydE1hbmFnZXIoZG9jdW1lbnQpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmVydCkge1xuICAgICAgICAgIGluZXJ0TWFuYWdlci5zZXRJbmVydCh0aGlzLCBpbmVydCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSkoKTtcblxufSkpKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogYEJsb2NraW5nRWxlbWVudHNgIG1hbmFnZXMgYSBzdGFjayBvZiBlbGVtZW50cyB0aGF0IGluZXJ0IHRoZSBpbnRlcmFjdGlvblxuICogb3V0c2lkZSB0aGVtLiBUaGUgdG9wIGVsZW1lbnQgaXMgdGhlIGludGVyYWN0aXZlIHBhcnQgb2YgdGhlIGRvY3VtZW50LlxuICogVGhlIHN0YWNrIGNhbiBiZSB1cGRhdGVkIHdpdGggdGhlIG1ldGhvZHMgYHB1c2gsIHJlbW92ZSwgcG9wYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgLyoqXG4gICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuIFRoaXMgZW1wdGllc1xuICAgKiB0aGUgYmxvY2tpbmcgZWxlbWVudHNcbiAgICovXG4gIGRlc3RydWN0b3IoKTogdm9pZDtcblxuICAvKipcbiAgICogVGhlIHRvcCBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgdG9wOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBlbGVtZW50IHRvIHRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICovXG4gIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nIGVsZW1lbnRzLiBSZXR1cm5zIHRydWUgaWYgdGhlXG4gICAqIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHRvcCBibG9ja2luZyBlbGVtZW50IGFuZCByZXR1cm5zIGl0LlxuICAgKi9cbiAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgYSBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIGV4dGVuZHMgRG9jdW1lbnQge1xuICAkYmxvY2tpbmdFbGVtZW50czogQmxvY2tpbmdFbGVtZW50cztcbn1cblxuKCgpID0+IHtcbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBwcm9wZXJ0aWVzICovXG4gIGNvbnN0IF9ibG9ja2luZ0VsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9hbHJlYWR5SW5lcnRFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfdG9wRWxQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zaWJsaW5nc1RvUmVzdG9yZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfcGFyZW50TU8gPSBTeW1ib2woKTtcblxuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHN0YXRpYyBtZXRob2RzICovXG4gIGNvbnN0IF90b3BDaGFuZ2VkID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zd2FwSW5lcnRlZFNpYmxpbmcgPSBTeW1ib2woKTtcbiAgY29uc3QgX2luZXJ0U2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX3Jlc3RvcmVJbmVydGVkU2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4gPSBTeW1ib2woKTtcbiAgY29uc3QgX2lzSW5lcnRhYmxlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9oYW5kbGVNdXRhdGlvbnMgPSBTeW1ib2woKTtcblxuICBpbnRlcmZhY2UgSW5lcnRhYmxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGluZXJ0PzogYm9vbGVhbjtcbiAgfVxuXG4gIGludGVyZmFjZSBJbnRlcm5hbFN0YXRlIHtcbiAgICBbX3NpYmxpbmdzVG9SZXN0b3JlXTogU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT47XG4gICAgW19wYXJlbnRNT106IE11dGF0aW9uT2JzZXJ2ZXI7XG4gIH1cbiAgaW50ZXJmYWNlIEhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIEludGVybmFsU3RhdGUge31cbiAgaW50ZXJmYWNlIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgUGFydGlhbDxJbnRlcm5hbFN0YXRlPiB7fVxuXG4gIC8qKlxuICAgKiBTaGFkeURPTSBzaGFkeSByb290cyBsb29rIGEgbG90IGxpa2UgcmVhbCBTaGFkb3dSb290cy4gVGhlIF9fc2hhZHkgcHJvcGVydHlcbiAgICogZ2l2ZXMgdGhlbSBhd2F5LCB0aG91Z2guXG4gICAqL1xuICBpbnRlcmZhY2UgTWF5YmVTaGFkeVJvb3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBfX3NoYWR5OiB1bmtub3duO1xuICAgIGhvc3Q6IEVsZW1lbnQ7XG4gIH1cblxuICBjbGFzcyBCbG9ja2luZ0VsZW1lbnRzSW1wbCBpbXBsZW1lbnRzIEJsb2NraW5nRWxlbWVudHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBwcml2YXRlW19ibG9ja2luZ0VsZW1lbnRzXTogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcGFyZW50cyBvZiB0aGUgdG9wIGVsZW1lbnQsIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgKiBpdHNlbGYgdXAgdG8gYm9keS4gV2hlbiB0b3AgY2hhbmdlcywgdGhlIG9sZCB0b3AgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgKiBmcm9tIHRoZSBkb2N1bWVudCwgc28gd2UgbmVlZCB0byBtZW1vaXplIHRoZSBpbmVydGVkIHBhcmVudHMnIHNpYmxpbmdzXG4gICAgICogaW4gb3JkZXIgdG8gcmVzdG9yZSB0aGVpciBpbmVydGVuZXNzIHdoZW4gdG9wIGNoYW5nZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wRWxQYXJlbnRzXTogSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBFbGVtZW50cyB0aGF0IGFyZSBhbHJlYWR5IGluZXJ0IGJlZm9yZSB0aGUgZmlyc3QgYmxvY2tpbmcgZWxlbWVudCBpc1xuICAgICAqIHB1c2hlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBuZXcgU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT4oKTtcblxuICAgIGRlc3RydWN0b3IoKTogdm9pZCB7XG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGluZXJ0bmVzcy5cbiAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKHRoaXNbX3RvcEVsUGFyZW50c10pO1xuICAgICAgLy8gTm90ZSB3ZSBkb24ndCB3YW50IHRvIG1ha2UgdGhlc2UgcHJvcGVydGllcyBudWxsYWJsZSBvbiB0aGUgY2xhc3MsXG4gICAgICAvLyBzaW5jZSB0aGVuIHdlJ2QgbmVlZCBub24tbnVsbCBjYXN0cyBpbiBtYW55IHBsYWNlcy4gQ2FsbGluZyBhIG1ldGhvZCBvblxuICAgICAgLy8gYSBCbG9ja2luZ0VsZW1lbnRzIGluc3RhbmNlIGFmdGVyIGNhbGxpbmcgZGVzdHJ1Y3RvciB3aWxsIHJlc3VsdCBpbiBhblxuICAgICAgLy8gZXhjZXB0aW9uLlxuICAgICAgY29uc3QgbnVsbGFibGUgPSB0aGlzIGFzIHVua25vd24gYXMge1xuICAgICAgICBbX2Jsb2NraW5nRWxlbWVudHNdOiBudWxsO1xuICAgICAgICBbX3RvcEVsUGFyZW50c106IG51bGw7XG4gICAgICAgIFtfYWxyZWFkeUluZXJ0RWxlbWVudHNdOiBudWxsO1xuICAgICAgfTtcbiAgICAgIG51bGxhYmxlW19ibG9ja2luZ0VsZW1lbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfdG9wRWxQYXJlbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgdG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgZWxlbXMgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXTtcbiAgICAgIHJldHVybiBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH1cblxuICAgIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50ID09PSB0aGlzLnRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIHdlJ2xsIGJyaW5nIGl0IHRvIHRoZSB0b3AuXG4gICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICAgIHRoaXNbX3RvcENoYW5nZWRdKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnNwbGljZShpLCAxKTtcbiAgICAgIC8vIFRvcCBjaGFuZ2VkIG9ubHkgaWYgdGhlIHJlbW92ZWQgZWxlbWVudCB3YXMgdGhlIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKGkgPT09IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmxlbmd0aCkge1xuICAgICAgICB0aGlzW190b3BDaGFuZ2VkXSh0aGlzLnRvcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRvcCAmJiB0aGlzLnJlbW92ZSh0b3ApO1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGBpbmVydGAgdG8gYWxsIGRvY3VtZW50IGVsZW1lbnRzIGV4Y2VwdCB0aGUgbmV3IHRvcCBlbGVtZW50LCBpdHNcbiAgICAgKiBwYXJlbnRzLCBhbmQgaXRzIGRpc3RyaWJ1dGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wQ2hhbmdlZF0obmV3VG9wOiBNYXliZUhhc0ludGVybmFsU3RhdGV8bnVsbCk6IHZvaWQge1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBjb25zdCBvbGRQYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIC8vIE5vIG5ldyB0b3AsIHJlc2V0IG9sZCB0b3AgaWYgYW55LlxuICAgICAgaWYgKCFuZXdUb3ApIHtcbiAgICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cyk7XG4gICAgICAgIHRvS2VlcEluZXJ0LmNsZWFyKCk7XG4gICAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBbXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdQYXJlbnRzID0gdGhpc1tfZ2V0UGFyZW50c10obmV3VG9wKTtcbiAgICAgIC8vIE5ldyB0b3AgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgbWFpbiBkb2N1bWVudCFcbiAgICAgIGlmIChuZXdQYXJlbnRzW25ld1BhcmVudHMubGVuZ3RoIC0gMV0ucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm9uLWNvbm5lY3RlZCBlbGVtZW50IGNhbm5vdCBiZSBhIGJsb2NraW5nIGVsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIC8vIENhc3QgaGVyZSBiZWNhdXNlIHdlIGtub3cgd2UnbGwgY2FsbCBfaW5lcnRTaWJsaW5ncyBvbiBuZXdQYXJlbnRzXG4gICAgICAvLyBiZWxvdy5cbiAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBuZXdQYXJlbnRzIGFzIEFycmF5PEhhc0ludGVybmFsU3RhdGU+O1xuXG4gICAgICBjb25zdCB0b1NraXAgPSB0aGlzW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShuZXdUb3ApO1xuXG4gICAgICAvLyBObyBwcmV2aW91cyB0b3AgZWxlbWVudC5cbiAgICAgIGlmICghb2xkUGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cywgdG9Ta2lwLCB0b0tlZXBJbmVydCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSBvbGRQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgaiA9IG5ld1BhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIC8vIEZpbmQgY29tbW9uIHBhcmVudC4gSW5kZXggMCBpcyB0aGUgZWxlbWVudCBpdHNlbGYgKHNvIHN0b3AgYmVmb3JlIGl0KS5cbiAgICAgIHdoaWxlIChpID4gMCAmJiBqID4gMCAmJiBvbGRQYXJlbnRzW2ldID09PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgICAgLy8gSWYgdXAgdGhlIHBhcmVudHMgdHJlZSB0aGVyZSBhcmUgMiBlbGVtZW50cyB0aGF0IGFyZSBzaWJsaW5ncywgc3dhcFxuICAgICAgLy8gdGhlIGluZXJ0ZWQgc2libGluZy5cbiAgICAgIGlmIChvbGRQYXJlbnRzW2ldICE9PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIHRoaXNbX3N3YXBJbmVydGVkU2libGluZ10ob2xkUGFyZW50c1tpXSwgbmV3UGFyZW50c1tqXSk7XG4gICAgICB9XG4gICAgICAvLyBSZXN0b3JlIG9sZCBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0bmVzcy5cbiAgICAgIGkgPiAwICYmIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMuc2xpY2UoMCwgaSkpO1xuICAgICAgLy8gTWFrZSBuZXcgcGFyZW50cyBzaWJsaW5ncyBpbmVydC5cbiAgICAgIGogPiAwICYmIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMuc2xpY2UoMCwgaiksIHRvU2tpcCwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgaW5lcnRuZXNzIGJldHdlZW4gdHdvIHNpYmxpbmcgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfc3dhcEluZXJ0ZWRTaWJsaW5nXShcbiAgICAgICAgb2xkSW5lcnQ6IEhhc0ludGVybmFsU3RhdGUsIG5ld0luZXJ0OiBNYXliZUhhc0ludGVybmFsU3RhdGUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNpYmxpbmdzVG9SZXN0b3JlID0gb2xkSW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgIC8vIG9sZEluZXJ0IGlzIG5vdCBjb250YWluZWQgaW4gc2libGluZ3MgdG8gcmVzdG9yZSwgc28gd2UgaGF2ZSB0byBjaGVja1xuICAgICAgLy8gaWYgaXQncyBpbmVydGFibGUgYW5kIGlmIGFscmVhZHkgaW5lcnQuXG4gICAgICBpZiAodGhpc1tfaXNJbmVydGFibGVdKG9sZEluZXJ0KSAmJiAhb2xkSW5lcnQuaW5lcnQpIHtcbiAgICAgICAgb2xkSW5lcnQuaW5lcnQgPSB0cnVlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5hZGQob2xkSW5lcnQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbmV3SW5lcnQgd2FzIGFscmVhZHkgYmV0d2VlbiB0aGUgc2libGluZ3MgdG8gcmVzdG9yZSwgaXQgbWVhbnMgaXQgaXNcbiAgICAgIC8vIGluZXJ0YWJsZSBhbmQgbXVzdCBiZSByZXN0b3JlZC5cbiAgICAgIGlmIChzaWJsaW5nc1RvUmVzdG9yZS5oYXMobmV3SW5lcnQpKSB7XG4gICAgICAgIG5ld0luZXJ0LmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmRlbGV0ZShuZXdJbmVydCk7XG4gICAgICB9XG4gICAgICBuZXdJbmVydFtfcGFyZW50TU9dID0gb2xkSW5lcnRbX3BhcmVudE1PXTtcbiAgICAgIG5ld0luZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBzaWJsaW5nc1RvUmVzdG9yZTtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIGluZXJ0bmVzcyB0byB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKGVsZW1lbnRzOiBIYXNJbnRlcm5hbFN0YXRlW10pIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBtbyA9IGVsZW1lbnRbX3BhcmVudE1PXTtcbiAgICAgICAgbW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgICBmb3IgKGNvbnN0IHNpYmxpbmcgb2Ygc2libGluZ3MpIHtcbiAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZXJ0cyB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzIGV4Y2VwdCB0aGUgZWxlbWVudHMgdG8gc2tpcC4gU3RvcmVzXG4gICAgICogdGhlIGluZXJ0ZWQgc2libGluZ3MgaW50byB0aGUgZWxlbWVudCdzIHN5bWJvbCBgX3NpYmxpbmdzVG9SZXN0b3JlYC5cbiAgICAgKiBQYXNzIGB0b0tlZXBJbmVydGAgdG8gY29sbGVjdCB0aGUgYWxyZWFkeSBpbmVydCBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19pbmVydFNpYmxpbmdzXShcbiAgICAgICAgZWxlbWVudHM6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdLCB0b1NraXA6IFNldDxIVE1MRWxlbWVudD58bnVsbCxcbiAgICAgICAgdG9LZWVwSW5lcnQ6IFNldDxIVE1MRWxlbWVudD58bnVsbCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIC8vIEFzc3VtZSBlbGVtZW50IGlzIG5vdCBhIERvY3VtZW50LCBzbyBpdCBtdXN0IGhhdmUgYSBwYXJlbnROb2RlLlxuICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUhO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBjaGlsZHJlbltqXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgLy8gU2tpcCB0aGUgaW5wdXQgZWxlbWVudCwgaWYgbm90IGluZXJ0YWJsZSBvciB0byBiZSBza2lwcGVkLlxuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBlbGVtZW50IHx8ICF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykgfHxcbiAgICAgICAgICAgICAgKHRvU2tpcCAmJiB0b1NraXAuaGFzKHNpYmxpbmcpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNob3VsZCBiZSBjb2xsZWN0ZWQgc2luY2UgYWxyZWFkeSBpbmVydGVkLlxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIHNpYmxpbmdzIHRoYXQgd2VyZSBpbmVydGVkLlxuICAgICAgICBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBpbmVydGVkU2libGluZ3M7XG4gICAgICAgIC8vIE9ic2VydmUgb25seSBpbW1lZGlhdGUgY2hpbGRyZW4gbXV0YXRpb25zIG9uIHRoZSBwYXJlbnQuXG4gICAgICAgIGNvbnN0IG1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpc1tfaGFuZGxlTXV0YXRpb25zXS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZWxlbWVudFtfcGFyZW50TU9dID0gbW87XG4gICAgICAgIGxldCBwYXJlbnRUb09ic2VydmUgPSBwYXJlbnQ7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHRoZSBTaGFkeURPTSBwb2x5ZmlsbCwgdGhlbiBvdXIgcGFyZW50IGNvdWxkIGJlIGFcbiAgICAgICAgLy8gc2hhZHkgcm9vdCwgd2hpY2ggaXMgYW4gb2JqZWN0IHRoYXQgYWN0cyBsaWtlIGEgU2hhZG93Um9vdCwgYnV0IGlzbid0XG4gICAgICAgIC8vIGFjdHVhbGx5IGEgbm9kZSBpbiB0aGUgcmVhbCBET00uIE9ic2VydmUgdGhlIHJlYWwgRE9NIHBhcmVudCBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBtYXliZVNoYWR5Um9vdCA9IHBhcmVudFRvT2JzZXJ2ZSBhcyBNYXliZVNoYWR5Um9vdDtcbiAgICAgICAgaWYgKG1heWJlU2hhZHlSb290Ll9fc2hhZHkgJiYgbWF5YmVTaGFkeVJvb3QuaG9zdCkge1xuICAgICAgICAgIHBhcmVudFRvT2JzZXJ2ZSA9IG1heWJlU2hhZHlSb290Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbW8ub2JzZXJ2ZShwYXJlbnRUb09ic2VydmUsIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbmV3bHkgYWRkZWQvcmVtb3ZlZCBub2RlcyBieSB0b2dnbGluZyB0aGVpciBpbmVydG5lc3MuXG4gICAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIGN1cnJlbnQgdG9wIEJsb2NraW5nIEVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgKiBub3RpZnlpbmcgYW5kIHJlbW92aW5nIGl0LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2hhbmRsZU11dGF0aW9uc10obXV0YXRpb25zOiBNdXRhdGlvblJlY29yZFtdKTogdm9pZCB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHNoYWRvd1Jvb3QsIGdldCBpdHMgaG9zdCBhcyB3ZSBza2lwIHNoYWRvd1Jvb3RzIHdoZW5cbiAgICAgICAgLy8gY29tcHV0aW5nIF90b3BFbFBhcmVudHMuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IChtdXRhdGlvbi50YXJnZXQgYXMgU2hhZG93Um9vdCkuaG9zdCB8fCBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSA/XG4gICAgICAgICAgICBwYXJlbnRzLmxlbmd0aCA6XG4gICAgICAgICAgICBwYXJlbnRzLmluZGV4T2YodGFyZ2V0IGFzIEhhc0ludGVybmFsU3RhdGUpO1xuICAgICAgICBjb25zdCBpbmVydGVkQ2hpbGQgPSBwYXJlbnRzW2lkeCAtIDFdO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBpbmVydGVkQ2hpbGRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcblxuICAgICAgICAvLyBUbyByZXN0b3JlLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBpbmVydGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnRGV0ZWN0ZWQgcmVtb3ZhbCBvZiB0aGUgdG9wIEJsb2NraW5nIEVsZW1lbnQuJyk7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5lcnRlZFNpYmxpbmdzLmhhcyhzaWJsaW5nKSkge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmRlbGV0ZShzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBpbmVydC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLmFkZGVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmICghdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgaW5lcnRhYmxlLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2lzSW5lcnRhYmxlXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGZhbHNlID09PSAvXihzdHlsZXx0ZW1wbGF0ZXxzY3JpcHQpJC8udGVzdChlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBuZXdQYXJlbnRzIG9mIGFuIGVsZW1lbnQsIHN0YXJ0aW5nIGZyb20gZWxlbWVudFxuICAgICAqIChpbmNsdWRlZCkgdXAgdG8gYGRvY3VtZW50LmJvZHlgIChleGNsdWRlZCkuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0UGFyZW50c10oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBBcnJheTxIVE1MRWxlbWVudD4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnQ6IEhUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkID0gZWxlbWVudDtcbiAgICAgIC8vIFN0b3AgdG8gYm9keS5cbiAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgLy8gU2tpcCBzaGFkb3cgcm9vdHMuXG4gICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGFkb3dEb20gdjFcbiAgICAgICAgaWYgKGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gQ29sbGVjdCBzbG90cyBmcm9tIGRlZXBlc3Qgc2xvdCB0byB0b3AuXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPSBjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb250aW51ZSB0aGUgc2VhcmNoIG9uIHRoZSB0b3Agc2xvdC5cbiAgICAgICAgICBjdXJyZW50ID0gcGFyZW50cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICAgICAoY3VycmVudCBhcyBOb2RlIGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0cmlidXRlZCBjaGlsZHJlbiBvZiB0aGUgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBzaGFkb3cgcm9vdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShlbGVtZW50OiBIVE1MRWxlbWVudCk6XG4gICAgICAgIFNldDxIVE1MRWxlbWVudD58bnVsbCB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgIGxldCBpO1xuICAgICAgbGV0IGo7XG4gICAgICBsZXQgbm9kZXM7XG4gICAgICBjb25zdCBzbG90cyA9IHNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgICAgaWYgKHNsb3RzLmxlbmd0aCAmJiBzbG90c1swXS5hc3NpZ25lZE5vZGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzID0gc2xvdHNbaV0uYXNzaWduZWROb2Rlcyh7XG4gICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICByZXN1bHQuYWRkKG5vZGVzW2pdIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZWFyY2ggZm9yIDxjb250ZW50Pi5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgKGRvY3VtZW50IGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzID1cbiAgICAgIG5ldyBCbG9ja2luZ0VsZW1lbnRzSW1wbCgpO1xufSkoKTtcbiIsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREb2N1bWVudChlbGVtZW50PzogTm9kZSkgeyByZXR1cm4gKGVsZW1lbnQ/Lm93bmVyRG9jdW1lbnQgPz8gZG9jdW1lbnQgPz8gd2luZG93LmRvY3VtZW50ID8/IGdsb2JhbFRoaXMuZG9jdW1lbnQpOyB9XG5cbnR5cGUgUCA9IFBhcmFtZXRlcnM8dHlwZW9mIGNsc3g+O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlRG9jdW1lbnRDbGFzcyhjbGFzc05hbWU6IFBbMF0sIGFjdGl2ZT86IGJvb2xlYW4sIGVsZW1lbnQ/OiBIVE1MRWxlbWVudCkge1xuICAgIGVsZW1lbnQgPz89IGdldERvY3VtZW50KCkuZG9jdW1lbnRFbGVtZW50O1xuICAgIGNsYXNzTmFtZSA9IGNsc3goY2xhc3NOYW1lKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUgYXMgc3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZWxlbWVudCEuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUgYXMgc3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSwgW2NsYXNzTmFtZSwgYWN0aXZlLCBlbGVtZW50XSk7XG5cbn1cbiIsImltcG9ydCBcIndpY2ctaW5lcnRcIjtcbmltcG9ydCBcImJsb2NraW5nLWVsZW1lbnRzXCI7XG5pbXBvcnQgeyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIH0gZnJvbSBcImJsb2NraW5nLWVsZW1lbnRzXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZXREb2N1bWVudCB9IGZyb20gXCIuL3VzZS1kb2N1bWVudC1jbGFzc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50IH0gZnJvbSBcIi4uL29ic2VydmVycy91c2UtYWN0aXZlLWVsZW1lbnRcIjtcblxuZnVuY3Rpb24gYmxvY2tpbmdFbGVtZW50cygpIHsgcmV0dXJuIChnZXREb2N1bWVudCgpIGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzIH1cbi8qKlxuICogQWxsb3dzIGFuIGVsZW1lbnQgdG8gdHJhcCBmb2N1cyBieSBhcHBseWluZyB0aGUgXCJpbmVydFwiIGF0dHJpYnV0ZSB0byBhbGwgc2libGluZywgYXVudCwgYW5kIHVuY2xlIG5vZGVzLlxuICogXG4gKiBBdXRvbWF0aWNhbGx5IGhhbmRsZXMgY29uc2VjdXRpdmUgY2FsbHMgd2l0aCBhIGxvb3NlbHkgYXBwbGllZCBzdGFjayBvcGVyYXRpb24gXG4gKiAoc3BlY2lmaWNhbGx5IHZpYSBgYmxvY2tpbmdFbGVtZW50c2AsIHdpdGggYSBzbWFsbCBwb2x5ZmlsbCBiZWNhdXNlIEknbSBub3Qgc3VyZSBob3cgbG9uZ1xuICogaXQnbGwgdGFrZSB0byBmaW5kIGl0cyB3YXkgaW50byB0aGUgc3BlYywgaWYgZXZlcilcbiAqIEBwYXJhbSB0YXJnZXQgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCbG9ja2luZ0VsZW1lbnQ8RSBleHRlbmRzIEVsZW1lbnQ+KGVuYWJsZWQ6IGJvb2xlYW4sIGdldFRhcmdldDogKCkgPT4gKEUgfCBudWxsKSkge1xuXG4gICAgY29uc3Qgc3RhYmxlR2V0VGFyZ2V0ID0gdXNlU3RhYmxlQ2FsbGJhY2soZ2V0VGFyZ2V0KTtcblxuICAgIGNvbnN0IGdldERvY3VtZW50ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4gKGdldFRhcmdldCgpPy5vd25lckRvY3VtZW50ID8/IGdsb2JhbFRoaXMuZG9jdW1lbnQpKTtcbiAgICB1c2VBY3RpdmVFbGVtZW50KHtcbiAgICAgICAgYWN0aXZlRWxlbWVudFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGdldERvY3VtZW50LFxuICAgICAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2soKGU6IEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldExhc3RBY3RpdmVXaGVuT3BlbihlIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TGFzdEFjdGl2ZVdoZW5DbG9zZWQoZSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBbZ2V0VG9wLCBzZXRUb3BdID0gdXNlUGFzc2l2ZVN0YXRlPEhUTUxFbGVtZW50IHwgbnVsbCwgbmV2ZXI+KG51bGwsIHJldHVybk51bGwpO1xuICAgIGNvbnN0IFtnZXRMYXN0QWN0aXZlV2hlbkNsb3NlZCwgc2V0TGFzdEFjdGl2ZVdoZW5DbG9zZWRdID0gdXNlUGFzc2l2ZVN0YXRlPEhUTUxFbGVtZW50IHwgbnVsbCwgbmV2ZXI+KG51bGwsIHJldHVybk51bGwpO1xuICAgIGNvbnN0IFtnZXRMYXN0QWN0aXZlV2hlbk9wZW4sIHNldExhc3RBY3RpdmVXaGVuT3Blbl0gPSB1c2VQYXNzaXZlU3RhdGU8SFRNTEVsZW1lbnQgfCBudWxsLCBuZXZlcj4obnVsbCwgcmV0dXJuTnVsbCk7XG5cbiAgICAvKipcbiAgICAgKiBQdXNoL3BvcCB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZ0VsZW1lbnRzIHN0YWNrLlxuICAgICAqL1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHN0YWJsZUdldFRhcmdldCgpO1xuXG4gICAgICAgIGlmIChlbmFibGVkKSB7XG5cbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBibG9ja2luZ0VsZW1lbnRzIHdpbGwgZmFpbCBpZiwgZm9yIGV4YW1wbGUsXG4gICAgICAgICAgICAvLyB0aGUgdGFyZ2V0IGVsZW1lbnQgaXNuJ3QgY29ubmVjdGVkIHRvIGRvY3VtZW50LmJvZHkuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHJhcmUsIGJ1dCBpdCdzIGJldHRlciB0byBmYWlsIHNpbGVudGx5IHdpdGggd2VpcmQgdGFiYmluZyBiZWhhdmlvclxuICAgICAgICAgICAgLy8gdGhhbiB0byBjcmFzaCB0aGUgZW50aXJlIGFwcGxpY2F0aW9uLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBibG9ja2luZ0VsZW1lbnRzKCkucHVzaCh0YXJnZXQgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICBzZXRUb3AodGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NraW5nRWxlbWVudHMoKS5yZW1vdmUodGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBXZWxsLCBzZW1pLXNpbGVudGx5LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2VuYWJsZWRdKTtcblxuICAgIHJldHVybiB7IGdldFRvcCwgZ2V0TGFzdEFjdGl2ZVdoZW5DbG9zZWQsIGdldExhc3RBY3RpdmVXaGVuT3BlbiB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BFbGVtZW50KCkge1xuICAgIHJldHVybiBibG9ja2luZ0VsZW1lbnRzKCkudG9wO1xufVxuXG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBpc0ZvY3VzYWJsZSB9IGZyb20gXCJ0YWJiYWJsZVwiO1xuaW1wb3J0IHsgdXNlQmxvY2tpbmdFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS1oZWxwZXJzL3VzZS1ibG9ja2luZy1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UGFyYW1ldGVycywgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi4vZG9tLWhlbHBlcnMvdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRm9jdXNUcmFwUGFyYW1ldGVyczxTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB8IG51bGwsIFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8UG9wdXBFbGVtZW50PiB7XG4gICAgZm9jdXNUcmFwUGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGZvY3VzIHRyYXAgaXMgY3VycmVudGx5IGFjdGl2ZSAob3IsIHdoZW4gdXNlZCBhcyBwYXJ0IG9mIGEgbGFyZ2VyIGNvbXBvbmVudCwgd2hldGhlciBpdCBpcyBhY3RpdmF0YWJsZSlcbiAgICAgICAgICovXG4gICAgICAgIHRyYXBBY3RpdmU6IGJvb2xlYW47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUsIGZvY3VzIGlzIG5vdCB0cmFwcGVkIGJ1dCBvbmx5IG1vdmVkIHRvIHRoZSBuZXcgZWxlbWVudC4gXG4gICAgICAgICAqL1xuICAgICAgICBvbmx5TW92ZUZvY3VzOiBib29sZWFuO1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYSBtb2RhbCBwb3B1cCBvcGVucywgZm9jdXMgbXVzdCBiZSBzZW50IHRvIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWFrZXMgc2Vuc2UuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgaWYgaXQncyBhIGNvbmZpcm1hdGlvbiBkaWFsb2cgYWJvdXQgZGVsZXRpbmcgc29tZXRoaW5nLCBpdCdzIGJlc3QgdG8gc2VuZCBmb2N1cyB0byB0aGUgXCJjYW5jZWxcIiBidXR0b24uXG4gICAgICAgICAqIFxuICAgICAgICAgKiBJbiBvdGhlciBjYXNlcywgaXQgbWFrZXMgbW9yZSBzZW5zZSB0byBmb2N1cyB0aGUgZGlhbG9nJ3MgdGl0bGUsIGZpcnN0IGludGVyYWN0aXZlIGVsZW1lbnQsIGV0Yy5cbiAgICAgICAgICogXG4gICAgICAgICAqIFRoaXMgaXMgaGlnaGx5IHN1YmplY3RpdmUgYW5kICphbG1vc3QgQUxXQVlTKiBtb3JlIGNvbXBsaWNhdGVkIHRoYW4ganVzdCBcImZvY3VzIHRoZSB3aG9sZSBkaWFsb2cgZWxlbWVudCBpdHNlbGZcIixcbiAgICAgICAgICogYmVjYXVzZSB0aGF0IG9ubHkgd29ya3MgaWYgdGhlIGRpYWxvZyAqKipvbmx5IGNvbnRhaW5zIHRleHQqKiosIHdoaWNoIGlzIHVuY29tbW9uLlxuICAgICAgICAgKiBcbiAgICAgICAgICogSWYgeW91IHJlYWxseSwgcmVhbGx5LCAqKipnZW51aW5lbHkqKiogY2Fubm90IGRldGVybWluZSB3aGF0IHNob3VsZCBiZSBkb25lIGluIHlvdXIgdXNlIGNhc2UsXG4gICAgICAgICAqIGZpcnN0IG9mIGFsbCwga2VlcCB0cnlpbmcsIHJlYWxseSxcbiAgICAgICAgICogdGhlbiBhcyBhIHZlcnkgbGFzdCByZXNvcnQsIHVzZSBgZmluZEZpcnN0Rm9jdXNhYmxlYCwgYW5kIHRoZW4gaWYgbm90aGluZydzIGZvdW5kIGZvY3VzIHRoZSBib2R5LiAgXG4gICAgICAgICAqIEp1c3QgcGxlYXNlLCBwbGVhc2UgbWFrZSBzdXJlIHRoYXQgd2hhdGV2ZXIgdGhhdCBmaXJzdCBmb2N1c2FibGUgaXMgKippc24ndCoqIGEgZGVzdHJ1Y3RpdmUgYWN0aW9uLCBhdCB0aGUgdmVyeSBsZWFzdC4gXG4gICAgICAgICAqL1xuICAgICAgICBmb2N1c1BvcHVwKGU6IFBvcHVwRWxlbWVudCwgZmluZEZpcnN0Rm9jdXNhYmxlOiAoKSA9PiBIVE1MT3JTVkdFbGVtZW50IHwgbnVsbCk6IHZvaWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdGhlIGZvY3VzIHRyYXAgaGFzIGRlYWN0aXZhdGVkLCBmb2N1cyBtdXN0IGJlIHNlbnQgYmFjayB0byB0aGUgZWxlbWVudCB0aGF0IG9wZW5lZCBpdC5cbiAgICAgICAgICogXG4gICAgICAgICAqIFRoaXMgaXMgdHJhY2tlZCBmb3IgeW91OyBieSBkZWZhdWx0LCBqdXN0IGNhbGwgYGxhc3RGb2N1c2VkPy5mb2N1cygpYCwgYnV0IHlvdSBjYW4gYWxzbyBvdmVycmlkZSB0aGlzIGJlaGF2aW9yXG4gICAgICAgICAqIGFuZCBqdXN0IGRvIHdoYXRldmVyIHlvdSB3YW50IHdpdGggYW55IGVsZW1lbnQuICBcbiAgICAgICAgICogQHBhcmFtIGxhc3RGb2N1c2VkIFxuICAgICAgICAgKi9cbiAgICAgICAgZm9jdXNPcGVuZXIobGFzdEZvY3VzZWQ6IFNvdXJjZUVsZW1lbnQgfCBudWxsKTogdm9pZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRm9jdXNUcmFwUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiB7XG4gICAgZm9jdXNUcmFwUmV0dXJuOiB7IHByb3BzVW5zdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IH1cbn1cblxuLy9jb25zdCBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8gPSBuZXcgTWFwPEVsZW1lbnQgfCBudWxsLCAoTm9kZSAmIEhUTUxPclNWR0VsZW1lbnQpPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9jdXNUcmFwPFNvdXJjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHwgbnVsbCwgUG9wdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGZvY3VzVHJhcFBhcmFtZXRlcnM6IHsgb25seU1vdmVGb2N1cywgdHJhcEFjdGl2ZSwgZm9jdXNQb3B1cDogZm9jdXNTZWxmVW5zdGFibGUsIGZvY3VzT3BlbmVyOiBmb2N1c09wZW5lclVuc3RhYmxlIH0sXG4gICAgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHsgb25FbGVtZW50Q2hhbmdlLCAuLi5yZWZFbGVtZW50UGFyYW1ldGVycyB9XG59OiBVc2VGb2N1c1RyYXBQYXJhbWV0ZXJzPFNvdXJjZUVsZW1lbnQsIFBvcHVwRWxlbWVudD4pOiBVc2VGb2N1c1RyYXBSZXR1cm5UeXBlPFBvcHVwRWxlbWVudD4ge1xuXG4gICAgdHlwZSBFID0gUG9wdXBFbGVtZW50O1xuXG4gICAgY29uc3QgZm9jdXNTZWxmID0gdXNlU3RhYmxlQ2FsbGJhY2soZm9jdXNTZWxmVW5zdGFibGUpO1xuICAgIGNvbnN0IGZvY3VzT3BlbmVyID0gdXNlU3RhYmxlQ2FsbGJhY2soZm9jdXNPcGVuZXJVbnN0YWJsZSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHJhcEFjdGl2ZSkge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gZ2V0VG9wKCk7XG4gICAgICAgICAgICBjb25zdCBsYXN0Rm9jdXNlZEluVGhpc0NvbXBvbmVudCA9IGdldExhc3RBY3RpdmVXaGVuT3BlbigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZmFsc2UgJiYgbGFzdEZvY3VzZWRJblRoaXNDb21wb25lbnQgJiYgbGFzdEZvY3VzZWRJblRoaXNDb21wb25lbnQ/LmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgZm9jdXNTZWxmKGxhc3RGb2N1c2VkSW5UaGlzQ29tcG9uZW50IGFzIGFueSBhcyBQb3B1cEVsZW1lbnQsICgpID0+IGxhc3RGb2N1c2VkSW5UaGlzQ29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCEhdG9wKTtcbiAgICAgICAgICAgICAgICBpZiAodG9wKVxuICAgICAgICAgICAgICAgICAgICBmb2N1c1NlbGYodG9wIGFzIGFueSBhcyBQb3B1cEVsZW1lbnQsICgpID0+IGZpbmRGaXJzdEZvY3VzYWJsZSh0b3ApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RBY3RpdmUgPSBnZXRMYXN0QWN0aXZlV2hlbkNsb3NlZCgpO1xuICAgICAgICAgICAgaWYgKGxhc3RBY3RpdmUpXG4gICAgICAgICAgICAgICAgZm9jdXNPcGVuZXIobGFzdEFjdGl2ZSBhcyBhbnkgYXMgU291cmNlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9LCBbdHJhcEFjdGl2ZV0pXG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8RT4oe1xuICAgICAgICByZWZFbGVtZW50UGFyYW1ldGVyczogeyBvbkVsZW1lbnRDaGFuZ2UsIC4uLnJlZkVsZW1lbnRQYXJhbWV0ZXJzIH1cbiAgICB9KVxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCB9ID0gcmVmRWxlbWVudFJldHVybjtcblxuICAgIGNvbnN0IHsgZ2V0VG9wLCBnZXRMYXN0QWN0aXZlV2hlbkNsb3NlZCwgZ2V0TGFzdEFjdGl2ZVdoZW5PcGVuIH0gPSB1c2VCbG9ja2luZ0VsZW1lbnQodHJhcEFjdGl2ZSAmJiAhb25seU1vdmVGb2N1cywgZ2V0RWxlbWVudCk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgIGZvY3VzVHJhcFJldHVybjogeyBwcm9wc1Vuc3RhYmxlOiB7IFwiYXJpYS1tb2RhbFwiOiB0cmFwQWN0aXZlID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB9XG4gICAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBjb250YWluZWQgd2l0aGluIHRoZSBnaXZlbiBub2RlLCBvciBudWxsIGlmIG5vbmUgYXJlIGZvdW5kLlxuICogQHBhcmFtIGVsZW1lbnQgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50OiBOb2RlKSB7XG4gICAgY29uc3QgdHJlZVdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWxlbWVudCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIHsgYWNjZXB0Tm9kZTogKG5vZGUpID0+IChub2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiBpc0ZvY3VzYWJsZShub2RlKSA/IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCA6IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVApIH0pXG4gICAgY29uc3QgZmlyc3RGb2N1c2FibGUgPSB0cmVlV2Fsa2VyLmZpcnN0Q2hpbGQoKSBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpIHwgbnVsbDtcbiAgICByZXR1cm4gZmlyc3RGb2N1c2FibGU7XG59XG5cbiIsImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGV4dENvbnRlbnRQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcmVmRWxlbWVudFJldHVybjogUGljazxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPltcInJlZkVsZW1lbnRSZXR1cm5cIl0sIFwiZ2V0RWxlbWVudFwiPjtcbiAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgdGV4dCBjb250ZW50IG9mIHRoaXMgY29tcG9uZW50LiBCeSBkZWZhdWx0LCBgZSA9PiBlLnRleHRDb250ZW50YCBpcyBwcm9iYWJseSB3aGF0IHlvdSB3YW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGV4dChlOiBFIHwgbnVsbCk6IHN0cmluZyB8IG51bGw7XG4gICAgICAgIG9uVGV4dENvbnRlbnRDaGFuZ2U6IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPHN0cmluZyB8IG51bGwsIG5ldmVyPjtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUZXh0Q29udGVudDxFIGV4dGVuZHMgRWxlbWVudD4oeyByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQgfSwgdGV4dENvbnRlbnRQYXJhbWV0ZXJzOiB7IGdldFRleHQsIG9uVGV4dENvbnRlbnRDaGFuZ2UgfSB9OiBVc2VUZXh0Q29udGVudFBhcmFtZXRlcnM8RT4pIHtcbiAgICBjb25zdCBbZ2V0VGV4dENvbnRlbnQsIHNldFRleHRDb250ZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxzdHJpbmcgfCBudWxsLCBuZXZlcj4ob25UZXh0Q29udGVudENoYW5nZSwgcmV0dXJuTnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gZ2V0VGV4dChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICh0ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgIHNldFRleHRDb250ZW50KHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IHRleHRDb250ZW50UmV0dXJuOiB7IGdldFRleHRDb250ZW50IH0gfVxufVxuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH07XG5cblxuICAgIGNvbnNvbGUuYXNzZXJ0KHJlZi5jdXJyZW50ID09PSBzdGF0ZSB8fCAodHlwZW9mIHN0YXRlID09PSBcIm51bWJlclwiICYmIGlzTmFOKHN0YXRlKSkpO1xuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL2RvbS1oZWxwZXJzL3VzZS1yZWYtZWxlbWVudFwiO1xuaW1wb3J0IHsgdXNlVGV4dENvbnRlbnQsIFVzZVRleHRDb250ZW50UGFyYW1ldGVycyB9IGZyb20gXCIuLi9kb20taGVscGVycy91c2UtdGV4dC1jb250ZW50XCI7XG5pbXBvcnQgeyBhc3NlcnRFbXB0eU9iamVjdCB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyLCB1c2VTdGFibGVPYmplY3QgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGF0ZVwiO1xuaW1wb3J0IHsgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yb3ZpbmctdGFiaW5kZXhcIjtcblxuLypcbmV4cG9ydCBmdW5jdGlvbiB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+KHI6IFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxFPiwgLi4ub3RoZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W10ge1xuICAgIHJldHVybiBbci5saW5lYXJOYXZpZ2F0aW9uUmV0dXJuLnByb3BzU3RhYmxlLCAuLi5vdGhlclByb3BzXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+KHI6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxFPiwgLi4ub3RoZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W10ge1xuICAgIHJldHVybiBbci50eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuLnByb3BzU3RhYmxlLCAuLi5vdGhlclByb3BzXTtcbn0qL1xuXG4vKmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNvbnRleHQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+W1widHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyc1wiXTtcbn0qL1xuXG5leHBvcnQgaW50ZXJmYWNlIExpbmVhck5hdmlnYXRpb25SZXN1bHQge1xuICAgIHZhbHVlOiBudW1iZXIgfCBudWxsO1xuICAgIHN0YXR1czogXCJub3JtYWxcIiB8IFwicGFzdC1zdGFydFwiIHwgXCJwYXN0LWVuZFwiXG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgbGluZWFyTmF2aWdhdGlvblJldHVybjoge1xuICAgICAgICBwcm9wc1N0YWJsZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XG59XG5cbi8qKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpdGggbm8gc29ydGluZyAqL1xuLy9leHBvcnQgZnVuY3Rpb24gbmF2aWdhdGVSZWxhdGl2ZShvcmlnaW5hbDogbnVtYmVyLCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB8IG51bGwgeyByZXR1cm4gb3JpZ2luYWwgKyBvZmZzZXQ7IH1cblxuLyoqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gd2l0aCBubyBzb3J0aW5nICovXG4vL2V4cG9ydCBmdW5jdGlvbiBuYXZpZ2F0ZUFic29sdXRlKGluZGV4OiBudW1iZXIpOiBudW1iZXIgfCBudWxsIHsgcmV0dXJuIGluZGV4OyB9XG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwYXJlbnQgYHVzZUxpbmVhck5hdmlnYXRpb25gICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPF9QYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcblxuICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuOiBQaWNrPFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+W1wicm92aW5nVGFiSW5kZXhSZXR1cm5cIl0sIFwiZ2V0VGFiYmFibGVJbmRleFwiIHwgXCJzZXRUYWJiYWJsZUluZGV4XCI+XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTXVzdCByZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gY2hpbGQgY2FuIGJlIG5hdmlnYXRlZCB0by5cbiAgICAgICAgICogXG4gICAgICAgICAqIEdlbmVyYWxseSBjb3JyZXNwb25kcyB0byBhIGBoaWRkZW5gIG9yIGBkaXNhYmxlZGAgcHJvcC5cbiAgICAgICAgICogQHBhcmFtIGkgXG4gICAgICAgICAqL1xuICAgICAgICBpc1ZhbGlkKGk6IG51bWJlcik6IGJvb2xlYW47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRyb2xzIGhvdyBtYW55IGVsZW1lbnRzIGFyZSBza2lwcGVkIG92ZXIgd2hlbiBwYWdlIHVwL2Rvd24gYXJlIHByZXNzZWQuXG4gICAgICAgICAqIFxuICAgICAgICAgKiAqIFdoZW4gMDogUGFnZSBVcC9Eb3duIGFyZSBkaXNhYmxlZFxuICAgICAgICAgKiAqIFdoZW4gPj0gMTogUGFnZSBVcC9Eb3duIG1vdmVzIHRoYXQgbnVtYmVyIG9mIGVsZW1lbnRzIHVwIG9yIGRvd25cbiAgICAgICAgICogKiBXaGVuIDAgPCB4IDwgMSwgUGFnZSBVcC9Eb3duIG1vdmVzIGJ5IHRoYXQgcGVyY2VudGFnZSBvZiBhbGwgZWxlbWVudHMsIG9yIG9mIDEwMCBlbGVtZW50cywgd2hpY2hldmVyIGlzIGhpZ2hlci4gSW4gb3RoZXIgd29yZHMsIDAuMSBqdW1wcyBieSAxMCBlbGVtZW50cyB3aGVuIHRoZXJlIGFyZSBmZXdlciB0aGVuIDEwMCBlbGVtZW50cywgYW5kIDIwIGVsZW1lbnRzIHdoZW4gdGhlcmUgYXJlIDIwMCBlbGVtZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZTogbnVtYmVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGF0IGhhcHBlbnMgd2hlbiBgdXBgIGlzIHByZXNzZWQgb24gdGhlIGZpcnN0IHZhbGlkIGNoaWxkP1xuICAgICAgICAgKi9cbiAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IFwid3JhcFwiIHwgKCgpID0+IHZvaWQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hhdCBoYXBwZW5zIHdoZW4gYGRvd25gIGlzIHByZXNzZWQgb24gdGhlIGxhc3QgdmFsaWQgY2hpbGQ/XG4gICAgICAgICAqL1xuICAgICAgICBuYXZpZ2F0ZVBhc3RFbmQ6IFwid3JhcFwiIHwgKCgpID0+IHZvaWQpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUdXJuIGEgc29ydGVkIGBpbmRleGAgaW50byBpdHMgb3JpZ2luYWwsIHVuc29ydGVkIGBpbmRleGAuIFVzZSBgaWRlbnRpdHlgIGlmIHlvdSBkb24ndCBjYXJlLlxuICAgICAgICAgKiBcbiAgICAgICAgICogVGhpcyBpcyB3aGF0IGFsbG93cyBvdXIgbGluZWFyIGtleWJvYXJkIG5hdmlnYXRpb24gdG8gc3RpbGwgd29yayBpZiB0aGUgY2hpbGRyZW4gYXJlIHJlLW9yZGVyZWRcbiAgICAgICAgICogKGkuZS4gaG93IHdoZW4gcmV2ZXJzZS1zb3J0ZWQsIHByZXNzaW5nIGBkb3duYCBtb3ZlcyBmcm9tIGl0ZW0gIzkgdG8gaXRlbSAjOCkuXG4gICAgICAgICAqL1xuICAgICAgICBpbmRleE1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFR1cm4gYW4gdW5zb3J0ZWQgYGluZGV4YCBpbnRvIGl0cyB2aXN1YWwgZGlzcGxheSBgaW5kZXhgLiBVc2UgYGlkZW50aXR5YCBpZiB5b3UgZG9uJ3QgY2FyZS5cbiAgICAgICAgICovXG4gICAgICAgIGluZGV4RGVtYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG5cbiAgICAgICAgZ2V0SGlnaGVzdEluZGV4KCk6IG51bWJlcjsgIC8vIFswLCBuXSwgbm90IFswLCBuKVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyB3aGljaCBhcnJvdyBrZXlzIGFyZSB1c2VkIHRvIG5hdmlnYXRlIHRocm91Z2ggdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogTm90IHJlbGF0aXZlIHRvIHRoZSB3cml0aW5nIG1vZGUgLS0gdGhlc2UgYXJlIHRoZSBsaXRlcmFsIGtleXMgdGhhdCBuZWVkIHRvIGJlIHByZXNzZWQuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBVc2UgXCJlaXRoZXJcIiB0byBhbGxvdyBuYXZpZ2F0aW9uIGluIGVpdGhlciBkaXJlY3Rpb24uXG4gICAgICAgICAqIFxuICAgICAgICAgKiBVc2UgXCJub25lXCIgdG8gZGlzYWxsb3cgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIGluIGFueSBkaXJlY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIiB8IFwiZWl0aGVyXCIgfCBcIm5vbmVcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlIFxuICAgICAgICAgKiBkaXNhYmxlZCwgYnV0IG5hdmlnYXRpb24gd2l0aCB0aGUgaG9tZSAmIGVuZCBrZXlzIHdpbGxcbiAgICAgICAgICogYmUgdW5hZmZlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVBcnJvd0tleXM6IGJvb2xlYW47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byB0cnVlLCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXG4gICAgICAgICAqIGJlIGRpc2FibGVkLCBidXQgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIHdpbGwgYmVcbiAgICAgICAgICogdW5hZmZlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIGRpc2FibGVIb21lRW5kS2V5czogYm9vbGVhbjtcbiAgICB9XG59XG5cblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNoaWxkICd1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRgICovXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkSW5mbyB7IH1cblxuLyoqXG4gKiBXaGVuIHVzZWQgaW4gdGFuZGVtIHdpdGggYHVzZVJvdmluZ1RhYkluZGV4YCwgYWxsb3dzIGNvbnRyb2wgb2ZcbiAqIHRoZSB0YWJiYWJsZSBpbmRleCB3aXRoIHRoZSBhcnJvdyBrZXlzLlxuICogXG4gKiBAc2VlIHVzZUxpc3ROYXZpZ2F0aW9uLCB3aGljaCBwYWNrYWdlcyBldmVyeXRoaW5nIHVwIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1xufTogVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudD4pOiBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xuICAgIHR5cGUgUiA9IEV2ZW50Oy8vaC5KU1guVGFyZ2V0ZWRFdmVudDxQYXJlbnRPckNoaWxkRWxlbWVudD47XG4gICAgY29uc3QgeyBnZXRIaWdoZXN0SW5kZXgsIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIGlzVmFsaWQsIG5hdmlnYXRlUGFzdEVuZCwgbmF2aWdhdGVQYXN0U3RhcnQgfSA9IGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzO1xuICAgIGNvbnN0IHsgZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleCB9ID0gcm92aW5nVGFiSW5kZXhSZXR1cm47XG5cbiAgICBjb25zdCBuYXZpZ2F0ZUFic29sdXRlID0gdXNlQ2FsbGJhY2soKGk6IG51bWJlciwgZTogUiwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBpbmRleERlbWFuZ2xlcihpKTtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gdHJ5TmF2aWdhdGVUb0luZGV4KHsgaXNWYWxpZCwgaGlnaGVzdENoaWxkSW5kZXg6IGdldEhpZ2hlc3RJbmRleCgpLCBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCBzZWFyY2hEaXJlY3Rpb246IC0xLCB0YXJnZXQgfSk7XG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXgodmFsdWUsIGUsIGZyb21Vc2VySW50ZXJhY3Rpb24pO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvRmlyc3QgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogUiwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4geyBuYXZpZ2F0ZUFic29sdXRlKDAsIGUsIGZyb21Vc2VySW50ZXJhY3Rpb24pOyB9KTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTGFzdCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBSLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7IG5hdmlnYXRlQWJzb2x1dGUoZ2V0SGlnaGVzdEluZGV4KCksIGUsIGZyb21Vc2VySW50ZXJhY3Rpb24pOyB9KTtcbiAgICBjb25zdCBuYXZpZ2F0ZVJlbGF0aXZlMiA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBSLCBvZmZzZXQ6IG51bWJlciwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbiwgbW9kZTogXCJwYWdlXCIgfCBcInNpbmdsZVwiKSA9PiB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gKGdldFRhYmJhYmxlSW5kZXgoKSA/PyAwKTtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIHZhbHVlIH0gPSB0cnlOYXZpZ2F0ZVRvSW5kZXgoeyBpc1ZhbGlkLCBoaWdoZXN0Q2hpbGRJbmRleDogZ2V0SGlnaGVzdEluZGV4KCksIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIHNlYXJjaERpcmVjdGlvbjogKE1hdGguc2lnbihvZmZzZXQpIHx8IDEpIGFzIDEgfCAtMSwgdGFyZ2V0OiBpbmRleERlbWFuZ2xlcihpbmRleE1hbmdsZXIob3JpZ2luYWwpICsgb2Zmc2V0KSB9KTtcbiAgICAgICAgaWYgKHN0YXR1cyA9PSBcInBhc3QtZW5kXCIpIHtcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0ZVBhc3RFbmQgPT0gXCJ3cmFwXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PSBcInNpbmdsZVwiKVxuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvRmlyc3QoZSwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc3RhbnQtY29uZGl0aW9uICovXG4gICAgICAgICAgICAgICAgICAgIC8vIFVuY29tbWVudCB0byBhbGxvdyBwYWdlIHVwL2Rvd24gdG8gd3JhcCBhZnRlciBoaXR0aW5nIHRoZSB0b3AvYm90dG9tIG9uY2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0IHdvcmtzIGZpbmUsIHRoZSBwcm9ibGVtIGlzbid0IHRoYXQgLS0gdGhlIHByb2JsZW0gaXMgaXQganVzdCBmZWVscyB3cm9uZy4gXG4gICAgICAgICAgICAgICAgICAgIC8vIFBhZ2UgVXAvRG93biBkb24ndCBmZWVsIGxpa2UgdGhleSBzaG91bGQgd3JhcCwgZXZlbiBpZiBub3JtYWxseSByZXF1ZXN0ZWQuIFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGF0J3MgdGhlIGFycm93IGtleXMnIGRvbWFpbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZhbHNlICYmICh2YWx1ZSA9PSBnZXRUYWJiYWJsZUluZGV4KCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0ZpcnN0KGUsIGZyb21Vc2VySW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdChlLCBmcm9tVXNlckludGVyYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVBhc3RFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0dXMgPT0gXCJwYXN0LXN0YXJ0XCIpIHtcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0ZVBhc3RTdGFydCA9PSBcIndyYXBcIikge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlID09IFwic2luZ2xlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3QoZSwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zdGFudC1jb25kaXRpb24gKi9cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGFib3ZlLiBJdCB3b3JrcyBmaW5lIGJ1dCBqdXN0IGZlZWxzIHdyb25nIHRvIHdyYXAgb24gUGFnZSBVcC9Eb3duLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZmFsc2UgJiYgdmFsdWUgPT0gZ2V0VGFiYmFibGVJbmRleCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3QoZSwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdChlLCBmcm9tVXNlckludGVyYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleCh2YWx1ZSwgZSwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XG5cbiAgICAgICAgfVxuICAgIH0pXG4gICAgY29uc3QgbmF2aWdhdGVUb05leHQgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogUiwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xuICAgICAgICBuYXZpZ2F0ZVJlbGF0aXZlMihlLCAxLCBmcm9tVXNlckludGVyYWN0aW9uLCBcInNpbmdsZVwiKTtcbiAgICAgICAgLy8gc2V0VGFiYmFibGVJbmRleChuYXZpZ2F0ZVJlbGF0aXZlKChnZXRUYWJiYWJsZUluZGV4KCkgPz8gMCksICsxKSwgZnJvbVVzZXJJbnRlcmFjdGlvbilcbiAgICB9KTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvUHJldiA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBSLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7XG4gICAgICAgIG5hdmlnYXRlUmVsYXRpdmUyKGUsIC0xLCBmcm9tVXNlckludGVyYWN0aW9uLCBcInNpbmdsZVwiKTtcbiAgICAgICAgLy8gc2V0VGFiYmFibGVJbmRleChuYXZpZ2F0ZVJlbGF0aXZlKChnZXRUYWJiYWJsZUluZGV4KCkgPz8gMCksICsxKSwgZnJvbVVzZXJJbnRlcmFjdGlvbilcbiAgICB9KTtcbiAgICBjb25zdCBnZXREaXNhYmxlQXJyb3dLZXlzID0gdXNlU3RhYmxlR2V0dGVyKGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLmRpc2FibGVBcnJvd0tleXMpO1xuICAgIGNvbnN0IGdldERpc2FibGVIb21lRW5kS2V5cyA9IHVzZVN0YWJsZUdldHRlcihsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycy5kaXNhYmxlSG9tZUVuZEtleXMpO1xuICAgIGNvbnN0IGdldE5hdmlnYXRpb25EaXJlY3Rpb24gPSB1c2VTdGFibGVHZXR0ZXIobGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMubmF2aWdhdGlvbkRpcmVjdGlvbik7XG4gICAgY29uc3QgZ2V0UGFnZU5hdmlnYXRpb25TaXplID0gdXNlU3RhYmxlR2V0dGVyKGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLnBhZ2VOYXZpZ2F0aW9uU2l6ZSk7XG5cblxuICAgIGNvbnN0IHN0YWJsZVByb3BzID0gdXNlUmVmPGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pj4oe1xuICAgICAgICBvbktleURvd246IChlOiBoLkpTWC5UYXJnZXRlZEtleWJvYXJkRXZlbnQ8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KSA9PiB7XG4gICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCBieSB0eXBlYWhlYWQgKGkuZS4gYXNzdW1lIHRoaXMgaXMgYSBrZXlib2FyZCBzaG9ydGN1dClcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgLy9jb25zdCBpbmZvID0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdmlnYXRpb25EaXJlY3Rpb24gPSBnZXROYXZpZ2F0aW9uRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBkaXNhYmxlQXJyb3dLZXlzID0gZ2V0RGlzYWJsZUFycm93S2V5cygpO1xuICAgICAgICAgICAgY29uc3QgZGlzYWJsZUhvbWVFbmRLZXlzID0gZ2V0RGlzYWJsZUhvbWVFbmRLZXlzKCk7XG4gICAgICAgICAgICBjb25zdCBwYWdlTmF2aWdhdGlvblNpemUgPSBnZXRQYWdlTmF2aWdhdGlvblNpemUoKTtcblxuICAgICAgICAgICAgY29uc3QgYWxsb3dzVmVydGljYWxOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJ2ZXJ0aWNhbFwiIHx8IG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJlaXRoZXJcIik7XG4gICAgICAgICAgICBjb25zdCBhbGxvd3NIb3Jpem9udGFsTmF2aWdhdGlvbiA9IChuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiaG9yaXpvbnRhbFwiIHx8IG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJlaXRoZXJcIik7XG5cbiAgICAgICAgICAgIGxldCB0cnVlUGFnZU5hdmlnYXRpb25TaXplID0gcGFnZU5hdmlnYXRpb25TaXplO1xuICAgICAgICAgICAgaWYgKHRydWVQYWdlTmF2aWdhdGlvblNpemUgPCAxKSB7XG4gICAgICAgICAgICAgICAgdHJ1ZVBhZ2VOYXZpZ2F0aW9uU2l6ZSA9IE1hdGgucm91bmQocGFnZU5hdmlnYXRpb25TaXplICogTWF0aC5tYXgoMTAwLCBnZXRIaWdoZXN0SW5kZXgoKSArIDEpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBwcm9wTmFtZSA9IChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcImJsb2NrRGlyZWN0aW9uXCIgOiBcImlubGluZURpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiBhbGxvd3NWZXJ0aWNhbE5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiBhbGxvd3NWZXJ0aWNhbE5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIGFsbG93c0hvcml6b250YWxOYXZpZ2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIGFsbG93c0hvcml6b250YWxOYXZpZ2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIlBhZ2VVcFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnVlUGFnZU5hdmlnYXRpb25TaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVSZWxhdGl2ZTIoZSwgLXRydWVQYWdlTmF2aWdhdGlvblNpemUsIHRydWUsIFwicGFnZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJQYWdlRG93blwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnVlUGFnZU5hdmlnYXRpb25TaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVSZWxhdGl2ZTIoZSwgdHJ1ZVBhZ2VOYXZpZ2F0aW9uU2l6ZSwgdHJ1ZSwgXCJwYWdlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlSG9tZUVuZEtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdChlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZUhvbWVFbmRLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdChlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuOiB7XG4gICAgICAgICAgICBwcm9wc1N0YWJsZTogc3RhYmxlUHJvcHMuY3VycmVudFxuICAgICAgICB9XG4gICAgfVxuXG5cbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJ5TmF2aWdhdGVUb0luZGV4UGFyYW1ldGVycyB7XG4gICAgLy9jaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgdW5rbm93biwgSz47XG4gICAgaGlnaGVzdENoaWxkSW5kZXg6IG51bWJlcjsgLy8gWzAsIG5dLCBub3QgWzAsIG4pXG4gICAgaXNWYWxpZChpbmRleDogbnVtYmVyKTogYm9vbGVhbjtcblxuICAgIC8vZGVmYXVsdDogbnVtYmVyO1xuICAgIHRhcmdldDogbnVtYmVyO1xuICAgIHNlYXJjaERpcmVjdGlvbjogMSB8IC0xO1xuICAgIGluZGV4TWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xuICAgIGluZGV4RGVtYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyeU5hdmlnYXRlVG9JbmRleCh7IGlzVmFsaWQsIGhpZ2hlc3RDaGlsZEluZGV4OiB1cHBlciwgc2VhcmNoRGlyZWN0aW9uLCBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCB0YXJnZXQgfTogVHJ5TmF2aWdhdGVUb0luZGV4UGFyYW1ldGVycyk6IExpbmVhck5hdmlnYXRpb25SZXN1bHQge1xuICAgIC8vY29uc3QgdXBwZXIgPSBjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKTtcbiAgICBjb25zdCBsb3dlciA9IDA7XG5cbiAgICBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICB3aGlsZSAodGFyZ2V0ID49IGxvd2VyICYmICFpc1ZhbGlkKHRhcmdldCkpXG4gICAgICAgICAgICB0YXJnZXQgPSBpbmRleERlbWFuZ2xlcihpbmRleE1hbmdsZXIodGFyZ2V0KSAtIDEpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQgPCBsb3dlciA/IHsgdmFsdWU6IGluZGV4RGVtYW5nbGVyKGxvd2VyKSwgc3RhdHVzOiBcInBhc3Qtc3RhcnRcIiB9IDogeyB2YWx1ZTogdGFyZ2V0LCBzdGF0dXM6IFwibm9ybWFsXCIgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgIHdoaWxlICh0YXJnZXQgPD0gdXBwZXIgJiYgIWlzVmFsaWQodGFyZ2V0KSlcbiAgICAgICAgICAgIHRhcmdldCA9IGluZGV4RGVtYW5nbGVyKGluZGV4TWFuZ2xlcih0YXJnZXQpICsgMSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldCA+IHVwcGVyID8geyB2YWx1ZTogaW5kZXhEZW1hbmdsZXIodXBwZXIpLCBzdGF0dXM6IFwicGFzdC1lbmRcIiB9IDogeyB2YWx1ZTogdGFyZ2V0LCBzdGF0dXM6IFwibm9ybWFsXCIgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBsb3dlciwgc3RhdHVzOiBcIm5vcm1hbFwiIH07XG4gICAgfVxufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuOiB7XG4gICAgICAgIGdldEN1cnJlbnRUeXBlYWhlYWQoKTogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZDogYm9vbGVhbiB8IG51bGw7XG4gICAgICAgIHByb3BzU3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD47XG4gICAgfVxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQ6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+W1widHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dFwiXTtcbn1cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxUYWJiYWJsZUNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11c3QgcmV0dXJuIHRydWUgaWYgdGhlIGdpdmVuIGNoaWxkIGNhbiBiZSBuYXZpZ2F0ZWQgdG8uXG4gICAgICAgICAqIFxuICAgICAgICAgKiBHZW5lcmFsbHkgY29ycmVzcG9uZHMgdG8gYSBgaGlkZGVuYCBvciBgZGlzYWJsZWRgIHByb3AuXG4gICAgICAgICAqIEBwYXJhbSBpIFxuICAgICAgICAgKi9cbiAgICAgICAgaXNWYWxpZChpOiBudW1iZXIpOiBib29sZWFuO1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY29sbGF0b3IgdG8gdXNlIHdoZW4gY29tcGFyaW5nLiBJZiBub3QgcHJvdmlkZWQsIHNpbXBseSB1c2VzIGBsb2NhbGVDb21wYXJlYCBhZnRlciB0cmFuc2Zvcm1pbmcgZWFjaCB0byBsb3dlcmNhc2UsIHdoaWNoIHdpbGwsIGF0IGJlc3QsIHdvcmsgb2theSBpbiBFbmdsaXNoLlxuICAgICAgICAgKi9cbiAgICAgICAgY29sbGF0b3I6IG51bGwgfCBJbnRsLkNvbGxhdG9yO1xuXG4gICAgICAgIG5vVHlwZWFoZWFkOiBib29sZWFuO1xuXG4gICAgICAgIHR5cGVhaGVhZFRpbWVvdXQ6IG51bWJlcjtcbiAgICB9O1xuXG4gICAgcm92aW5nVGFiSW5kZXhSZXR1cm46IFBpY2s8VXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlPFRhYmJhYmxlQ2hpbGRFbGVtZW50PltcInJvdmluZ1RhYkluZGV4UmV0dXJuXCJdLCBcImdldFRhYmJhYmxlSW5kZXhcIiB8IFwic2V0VGFiYmFibGVJbmRleFwiPlxufVxuXG4vKiogQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgY2hpbGQgJ3VzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZGAgKi9cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IFBpY2s8VXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIl0sIFwiaW5kZXhcIj47XG5cbiAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnM6IFBpY2s8VXNlVGV4dENvbnRlbnRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD5bXCJ0ZXh0Q29udGVudFBhcmFtZXRlcnNcIl0sIFwiZ2V0VGV4dFwiPjtcblxuICAgIC8vdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczoge1xuXG4gICAgLy9nZXRUZXh0KGVsZW1lbnQ6IEVsZW1lbnQgfCBudWxsKTogc3RyaW5nO1xuXG4gICAgLy9oaWRkZW46IGJvb2xlYW47XG4gICAgLy99XG5cbiAgICByZWZFbGVtZW50UmV0dXJuOiBQaWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPENoaWxkRWxlbWVudD5bXCJyZWZFbGVtZW50UmV0dXJuXCJdLCBcImdldEVsZW1lbnRcIj47XG5cbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0OiB7XG5cbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mbzogQXJyYXk8VHlwZWFoZWFkSW5mbz47XG4gICAgICAgICAgICBpbnNlcnRpbmdDb21wYXJhdG9yOiAobGhzOiBzdHJpbmcgfCBudWxsLCByaHM6IFR5cGVhaGVhZEluZm8pID0+IG51bWJlcjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlIHtcbiAgICB0ZXh0Q29udGVudFJldHVybjogeyBnZXRUZXh0Q29udGVudCgpOiBzdHJpbmcgfCBudWxsIH1cbn1cblxuaW50ZXJmYWNlIFR5cGVhaGVhZEluZm8geyB0ZXh0OiBzdHJpbmcgfCBudWxsOyB1bnNvcnRlZEluZGV4OiBudW1iZXI7IH1cblxuLyoqIFR5cGUgb2YgdGhlIGNoaWxkJ3Mgc3ViLWhvb2sgKi9cbmV4cG9ydCB0eXBlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD4pID0+IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU7XG5cblxuLyoqXG4gKiBBbGxvd3MgZm9yIHRoZSBzZWxlY3Rpb24gb2YgYSBtYW5hZ2VkIGNoaWxkIGJ5IHR5cGluZyB0aGUgZ2l2ZW4gdGV4dCBhc3NvY2lhdGVkIHdpdGggaXQuXG4gKiBcbiAqIEBzZWUgdXNlTGlzdE5hdmlnYXRpb24sIHdoaWNoIHBhY2thZ2VzIGV2ZXJ5dGhpbmcgdXAgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IGNvbGxhdG9yLCB0eXBlYWhlYWRUaW1lb3V0LCBub1R5cGVhaGVhZCwgaXNWYWxpZCwgLi4uX3ZvaWQzIH0sXG4gICAgcm92aW5nVGFiSW5kZXhSZXR1cm46IHsgZ2V0VGFiYmFibGVJbmRleDogZ2V0SW5kZXgsIHNldFRhYmJhYmxlSW5kZXg6IHNldEluZGV4LCAuLi5fdm9pZDEgfSxcbiAgICAuLi5fdm9pZDJcbn06IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzPENoaWxkRWxlbWVudD4pOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xuXG4gICAgYXNzZXJ0RW1wdHlPYmplY3QoX3ZvaWQxKTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDIpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMyk7XG5cbiAgICAvLyBGb3IgdHlwZWFoZWFkLCBrZWVwIHRyYWNrIG9mIHdoYXQgb3VyIGN1cnJlbnQgXCJzZWFyY2hcIiBzdHJpbmcgaXMgKGlmIHdlIGhhdmUgb25lKVxuICAgIC8vIGFuZCBhbHNvIGNsZWFyIGl0IGV2ZXJ5IDEwMDAgbXMgc2luY2UgdGhlIGxhc3QgdGltZSBpdCBjaGFuZ2VkLlxuICAgIC8vIE5leHQsIGtlZXAgYSBtYXBwaW5nIG9mIHR5cGVhaGVhZCB2YWx1ZXMgdG8gaW5kaWNlcyBmb3IgZmFzdGVyIHNlYXJjaGluZy5cbiAgICAvLyBBbmQsIGZvciB0aGUgdXNlcidzIHNha2UsIGxldCB0aGVtIGtub3cgd2hlbiB0aGVpciB0eXBlYWhlYWQgY2FuJ3QgbWF0Y2ggYW55dGhpbmcgYW55bW9yZVxuICAgIGNvbnN0IFtnZXRDdXJyZW50VHlwZWFoZWFkLCBzZXRDdXJyZW50VHlwZWFoZWFkXSA9IHVzZVBhc3NpdmVTdGF0ZTxzdHJpbmcgfCBudWxsLCBFdmVudD4odXNlU3RhYmxlQ2FsbGJhY2soKGN1cnJlbnRUeXBlYWhlYWQsIHByZXYsIHJlYXNvbikgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHsgc2V0Q3VycmVudFR5cGVhaGVhZChudWxsLCB1bmRlZmluZWQhKTsgc2V0SW52YWxpZFR5cGVhaGVhZChudWxsKTsgfSwgdHlwZWFoZWFkVGltZW91dCA/PyAxMDAwKTtcbiAgICAgICAgdXBkYXRlQmFzZWRPblR5cGVhaGVhZENoYW5nZShjdXJyZW50VHlwZWFoZWFkLCByZWFzb24hKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgIH0pKTtcbiAgICAvL3VzZVRpbWVvdXQoeyB0aW1lb3V0OiB0eXBlYWhlYWRUaW1lb3V0ID8/IDEwMDAsIGNhbGxiYWNrOiAoKSA9PiB7IHNldEN1cnJlbnRUeXBlYWhlYWQobnVsbCk7IHNldEludmFsaWRUeXBlYWhlYWQobnVsbCk7IH0sIHRyaWdnZXJJbmRleDogY3VycmVudFR5cGVhaGVhZCB9KTtcbiAgICBjb25zdCBzb3J0ZWRUeXBlYWhlYWRJbmZvID0gdXNlUmVmPFR5cGVhaGVhZEluZm9bXT4oW10pO1xuICAgIGNvbnN0IFtpbnZhbGlkVHlwZWFoZWFkLCBzZXRJbnZhbGlkVHlwZWFoZWFkXSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBudWxsPihmYWxzZSk7XG5cbiAgICAvLyBIYW5kbGUgdHlwZWFoZWFkIGZvciBpbnB1dCBtZXRob2QgZWRpdG9ycyBhcyB3ZWxsXG4gICAgLy8gRXNzZW50aWFsbHksIHdoZW4gYWN0aXZlLCBpZ25vcmUgZnVydGhlciBrZXlzIFxuICAgIC8vIGJlY2F1c2Ugd2UncmUgd2FpdGluZyBmb3IgYSBDb21wb3NpdGlvbkVuZCBldmVudFxuICAgIGNvbnN0IFssIHNldEltZUFjdGl2ZSwgZ2V0SW1lQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIC8vIEJlY2F1c2UgY29tcG9zaXRpb24gZXZlbnRzIGZpcmUgKmFmdGVyKiBrZXlkb3duIGV2ZW50cyBcbiAgICAvLyAoYnV0IHdpdGhpbiB0aGUgc2FtZSB0YXNrLCB3aGljaCwgVE9ETywgY291bGQgYmUgYnJvd3Nlci1kZXBlbmRlbnQpLFxuICAgIC8vIHdlIGNhbiB1c2UgdGhpcyB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50IHdlJ3JlIGxpc3RlbmluZyBmb3Igb24gdGhlIGZpcnN0IGtleWRvd24uXG4gICAgY29uc3QgW25leHRUeXBlYWhlYWRDaGFyLCBzZXROZXh0VHlwZWFoZWFkQ2hhcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobmV4dFR5cGVhaGVhZENoYXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlYWhlYWQodHlwZWFoZWFkID0+ICgodHlwZWFoZWFkID8/IFwiXCIpICsgbmV4dFR5cGVhaGVhZENoYXIpLCB1bmRlZmluZWQhKTtcbiAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKG51bGwpO1xuICAgICAgICB9XG4gICAgfSwgW25leHRUeXBlYWhlYWRDaGFyXSk7XG5cblxuICAgIGNvbnN0IGNvbXBhcmF0b3JTaGFyZWQgPSB1c2VTdGFibGVDYWxsYmFjaygoc2FmZUxoczogc3RyaW5nLCBzYWZlUmhzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbGV0IGNvbXBhcmU6IG51bWJlcjtcbiAgICAgICAgLy8gRm9yIHRoZSBwdXJwb3NlcyBvZiB0eXBlYWhlYWQsIG9ubHkgY29tcGFyZSBhIHN0cmluZyBvZiB0aGUgc2FtZSBzaXplIGFzIG91ciBjdXJyZW50bHkgdHlwZWQgc3RyaW5nLlxuICAgICAgICAvLyBCeSBub3JtYWxpemluZyB0aGVtIGZpcnN0LCB3ZSBlbnN1cmUgdGhpcyBieXRlLWJ5LWJ5dGUgaGFuZGxpbmcgb2YgcmF3IGNoYXJhY3RlciBkYXRhIHdvcmtzIG91dCBva2F5LlxuICAgICAgICBzYWZlTGhzID0gc2FmZUxocy5ub3JtYWxpemUoXCJORkRcIik7XG4gICAgICAgIHNhZmVSaHMgPSBzYWZlUmhzLm5vcm1hbGl6ZShcIk5GRFwiKVxuXG4gICAgICAgIGlmIChjb2xsYXRvcilcbiAgICAgICAgICAgIGNvbXBhcmUgPSBjb2xsYXRvci5jb21wYXJlKHNhZmVMaHMsIHNhZmVSaHMpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmUgPSBzYWZlTGhzLnRvTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShzYWZlUmhzLnRvTG93ZXJDYXNlKCkgPz8gXCJcIik7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnNlcnRpbmdDb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxoczogc3RyaW5nIHwgbnVsbCwgcmhzOiBUeXBlYWhlYWRJbmZvKSA9PiB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJocy50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvclNoYXJlZChsaHMsIHJocy50ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobGhzIGFzIHVua25vd24gYXMgbnVtYmVyKSAtIChyaHMgYXMgdW5rbm93biBhcyBudW1iZXIpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdHlwZWFoZWFkQ29tcGFyYXRvciA9IHVzZVN0YWJsZUNhbGxiYWNrKChsaHM6IHN0cmluZywgcmhzOiBUeXBlYWhlYWRJbmZvKSA9PiB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJocy50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBEdXJpbmcgdHlwZWFoZWFkLCBhbGwgc3RyaW5ncyBsb25nZXIgdGhhbiBvdXJzIHNob3VsZCBiZSB0cnVuY2F0ZWRcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhleSdyZSBhbGwgY29uc2lkZXJlZCBlcXVhbGx5IGJ5IHRoYXQgcG9pbnQuXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvclNoYXJlZChsaHMsIHJocy50ZXh0LnN1YnN0cmluZygwLCBsaHMubGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGxocyBhcyB1bmtub3duIGFzIG51bWJlcikgLSAocmhzIGFzIHVua25vd24gYXMgbnVtYmVyKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSB1c2VTdGFibGVHZXR0ZXIobm9UeXBlYWhlYWQpO1xuXG5cbiAgICBjb25zdCBwcm9wc1N0YWJsZSA9IHVzZVJlZjxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4+KHtcbiAgICAgICAgb25LZXlEb3duOiB1c2VTdGFibGVDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PFBhcmVudE9yQ2hpbGRFbGVtZW50PikgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGNvbnN0IGltZUFjdGl2ZSA9IGdldEltZUFjdGl2ZSgpO1xuXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBlLmtleTtcblxuICAgICAgICAgICAgLy8gTm90IGhhbmRsZWQgYnkgdHlwZWFoZWFkIChpLmUuIGFzc3VtZSB0aGlzIGlzIGEga2V5Ym9hcmQgc2hvcnRjdXQpXG4gICAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIGlmICghaW1lQWN0aXZlICYmIGUua2V5ID09PSBcIkJhY2tzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsYXN0IGNoYXJhY3RlciBpbiBhIHdheSB0aGF0IGRvZXNuJ3Qgc3BsaXQgVVRGLTE2IHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGVhaGVhZCh0ID0+IHQgPT0gbnVsbCA/IG51bGwgOiBbLi4udF0ucmV2ZXJzZSgpLnNsaWNlKDEpLnJldmVyc2UoKS5qb2luKFwiXCIpLCBlIGFzIGguSlNYLlRhcmdldGVkS2V5Ym9hcmRFdmVudDxhbnk+KTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBrZXkgcHJvcGVydHkgcmVwcmVzZW50cyB0aGUgdHlwZWQgY2hhcmFjdGVyIE9SIHRoZSBcIm5hbWVkIGtleSBhdHRyaWJ1dGVcIiBvZiB0aGUga2V5IHByZXNzZWQuXG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIGRlZmluaXRlIHdheSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlLCBidXQgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3Nlc1xuICAgICAgICAgICAgLy8gdGhlcmUgYXJlIG5vIG9uZS1jaGFyYWN0ZXIgbmFtZXMsIGFuZCB0aGVyZSBhcmUgbm8gbm9uLUFTQ0lJLWFscGhhIG5hbWVzLlxuICAgICAgICAgICAgLy8gVGh1cywgYW55IG9uZS1jaGFyYWN0ZXIgb3Igbm9uLUFTQ0lJIHZhbHVlIGZvciBga2V5YCBpcyAqYWxtb3N0IGNlcnRhaW5seSogYSB0eXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBjb25zdCBpc0NoYXJhY3RlcktleSA9IChrZXkubGVuZ3RoID09PSAxIHx8ICEvXltBLVphLXpdLy50ZXN0KGtleSkpO1xuICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVyS2V5KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwiIFwiICYmIChnZXRDdXJyZW50VHlwZWFoZWFkKCkgPz8gXCJcIikudHJpbSgpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGJlY2F1c2UgYSBzcGFjZWJhciBjYW4ndCBldmVyIFxuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWF0ZSBhIHR5cGVhaGVhZCwgb25seSBjb250aW51ZSBvbmUuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gKFNwZWNpZmljYWxseSwgbGV0IHRoZSBldmVudCBjb250aW51ZSBwcm9wYWdhdGlvbiBpbiB0aGlzIGNhc2UpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBXb24ndCBiZSB0cnVlIGZvciB0aGUgZmlyc3Qga2V5ZG93blxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWZvcmUgdXNlTGF5b3V0RWZmZWN0IGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhY3R1YWxseSBhcHBseSB0aGUgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1lQWN0aXZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSksXG4gICAgICAgIG9uQ29tcG9zaXRpb25TdGFydDogdXNlU3RhYmxlQ2FsbGJhY2soKGU6IENvbXBvc2l0aW9uRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKGUuZGF0YSk7XG4gICAgICAgICAgICBzZXRJbWVBY3RpdmUoZmFsc2UpO1xuICAgICAgICB9KSxcbiAgICAgICAgb25Db21wb3NpdGlvbkVuZDogdXNlU3RhYmxlQ2FsbGJhY2soKF9lOiBDb21wb3NpdGlvbkV2ZW50KSA9PiB7IHNldEltZUFjdGl2ZSh0cnVlKSB9KSxcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSBjaGFuZ2VzIGluIHR5cGVhaGVhZCB0aGF0IGNhdXNlIGNoYW5nZXMgdG8gdGhlIHRhYmJhYmxlIGluZGV4XG4gICAgLyogdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgIFxuICAgICB9LCBbY3VycmVudFR5cGVhaGVhZF0pOyovXG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGluc2VydGluZ0NvbXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mbzogc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICB9KSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybjoge1xuICAgICAgICAgICAgZ2V0Q3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgICAgIGludmFsaWRUeXBlYWhlYWQsXG4gICAgICAgICAgICBwcm9wc1N0YWJsZTogcHJvcHNTdGFibGUuY3VycmVudFxuICAgICAgICB9XG4gICAgfVxuXG5cblxuXG5cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUJhc2VkT25UeXBlYWhlYWRDaGFuZ2UoY3VycmVudFR5cGVhaGVhZDogc3RyaW5nIHwgbnVsbCwgcmVhc29uOiBFdmVudCkge1xuICAgICAgICBpZiAoY3VycmVudFR5cGVhaGVhZCAmJiBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoKSB7XG5cblxuXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRUeXBlYWhlYWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIGN1cnJlbnRUeXBlYWhlYWQsIHR5cGVhaGVhZENvbXBhcmF0b3IpO1xuXG4gICAgICAgICAgICBpZiAoc29ydGVkVHlwZWFoZWFkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgaGFzIHR5cGVkIGFuIGVudHJ5IHRoYXQgZG9lc24ndCBleGlzdCBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIC8vIChvciBtb3JlIHNwZWNpZmljYWxseSBcImZvciB3aGljaCB0aGVyZSBpcyBubyBlbnRyeSB0aGF0IHN0YXJ0cyB3aXRoIHRoYXQgaW5wdXRcIilcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0SW52YWxpZFR5cGVhaGVhZChmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgV2Uga25vdyByb3VnaGx5IHdoZXJlLCBpbiB0aGUgc29ydGVkIGFycmF5IG9mIHN0cmluZ3MsIG91ciBuZXh0IHR5cGVhaGVhZCBsb2NhdGlvbiBpcy5cbiAgICAgICAgICAgICAgICAgIEJ1dCByb3VnaGx5IGlzbid0IGdvb2QgZW5vdWdoIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzLlxuICAgICAgICAgICAgICAgICAgVG8gY29udmVydCBvdXIgc29ydGVkIGluZGV4IHRvIHRoZSB1bnNvcnRlZCBpbmRleCB3ZSBuZWVkLCB3ZSBoYXZlIHRvIGZpbmQgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICBlbGVtZW50IHRoYXQgbWF0Y2hlcyB1cyAqYW5kKiAoaWYgYW55IHN1Y2ggZXhpc3QpIGlzICphZnRlciogb3VyIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgIFxuICAgICAgICAgICAgICAgICAgSW4gb3RoZXIgd29yZHMsIHRoZSBvbmx5IHdheSB0eXBlYWhlYWQgbW92ZXMgYmFja3dhcmRzIHJlbGF0aXZlIHRvIG91ciBjdXJyZW50XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiBpcyBpZiB0aGUgb25seSBvdGhlciBvcHRpb24gaXMgYmVoaW5kIHVzLlxuICAgIFxuICAgICAgICAgICAgICAgICAgSXQncyBub3Qgc3BlY2lmaWVkIGluIFdBSS1BUklBIHdoYXQgdG8gZG8gaW4gdGhhdCBjYXNlLiAgSSBzdXBwb3NlIHdyYXAgYmFjayB0byB0aGUgc3RhcnQ/XG4gICAgICAgICAgICAgICAgICBUaG91Z2ggdGhlcmUncyBhbHNvIGEgY2FzZSBmb3IganVzdCBnb2luZyB1cHdhcmRzIHRvIHRoZSBuZWFyZXN0IHRvIHByZXZlbnQganVtcGluZXNzLlxuICAgICAgICAgICAgICAgICAgQnV0IGlmIHlvdSdyZSBhbHJlYWR5IGRvaW5nIHR5cGVhaGVhZCBvbiBhbiB1bnNvcnRlZCBsaXN0LCBsaWtlLCBqdW1waW5lc3MgY2FuJ3QgYmUgYXZvaWRlZC5cbiAgICAgICAgICAgICAgICAgIEkgZHVubm8uIEdvaW5nIGJhY2sgdG8gdGhlIHN0YXJ0IGlzIHRoZSBzaW1wbGlzdCB0aG91Z2guXG4gICAgXG4gICAgICAgICAgICAgICAgICBCYXNpY2FsbHkgd2hhdCB0aGlzIGRvZXM6IFN0YXJ0aW5nIGZyb20gd2hlcmUgd2UgZm91bmQgb3Vyc2VsdmVzIGFmdGVyIG91ciBiaW5hcnkgc2VhcmNoLFxuICAgICAgICAgICAgICAgICAgc2NhbiBiYWNrd2FyZHMgYW5kIGZvcndhcmRzIHRocm91Z2ggYWxsIGFkamFjZW50IGVudHJpZXMgdGhhdCBhbHNvIGNvbXBhcmUgZXF1YWxseSBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICB3ZSBjYW4gZmluZCB0aGUgb25lIHdob3NlIGB1bnNvcnRlZEluZGV4YCBpcyB0aGUgbG93ZXN0IGFtb25nc3QgYWxsIG90aGVyIGVxdWFsIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgIChhbmQgYWxzbyB0aGUgbG93ZXN0IGB1bnNvcnRlZEluZGV4YCB5YWRkYSB5YWRkYSBleGNlcHQgdGhhdCBpdCBjb21lcyBhZnRlciB1cykuXG4gICAgXG4gICAgICAgICAgICAgICAgICBUT0RPOiBUaGUgYmluYXJ5IHNlYXJjaCBzdGFydHMgdGhpcyBvZmYgd2l0aCBhIHNvbGlkIE8obG9nIG4pLCBidXQgb25lLWNoYXJhY3RlciBcbiAgICAgICAgICAgICAgICAgIHNlYXJjaGVzIGFyZSwgdGhhbmtzIHRvIHBpZ2VvbmhvbGUgcHJpbmNpcGFsLCBldmVudHVhbGx5IGd1YXJhbnRlZWQgdG8gYmVjb21lIFxuICAgICAgICAgICAgICAgICAgTyhuKmxvZyBuKS4gVGhpcyBpcyBhbm5veWluZyBidXQgcHJvYmFibHkgbm90IGVhc2lseSBzb2x2YWJsZT8gVGhlcmUgY291bGQgYmUgYW4gXG4gICAgICAgICAgICAgICAgICBleGNlcHRpb24gZm9yIG9uZS1jaGFyYWN0ZXIgc3RyaW5ncywgYnV0IHRoYXQncyBqdXN0IGtpY2tpbmcgdGhlIGNhbiBkb3duIFxuICAgICAgICAgICAgICAgICAgdGhlIHJvYWQuIE1heWJlIG9uZSBvciB0d28gY2hhcmFjdGVycyB3b3VsZCBiZSBnb29kIGVub3VnaCB0aG91Z2guXG4gICAgICAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY2FuZGlkYXRlcycgcG9zaXRpb25zIGluIGJvdGggb3VyIHNvcnRlZCBhcnJheSBhbmQgdGhlIHVuc29ydGVkIERPTS5cbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4QWxsID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSB0d28gYXJlIG9ubHkgc2V0IGZvciBlbGVtZW50cyB0aGF0IGFyZSBhaGVhZCBvZiB1cywgYnV0IHRoZSBwcmluY2lwbGUncyB0aGUgc2FtZSBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUJlc3RGaXQgPSAodTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZCh1KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9PSBudWxsIHx8IHUgPCBsb3dlc3RVbnNvcnRlZEluZGV4QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RVbnNvcnRlZEluZGV4QWxsID0gdTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNvcnRlZEluZGV4QWxsID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0KSAmJiB1ID4gKGdldEluZGV4KCkgPz8gLUluZmluaXR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U29ydGVkSW5kZXhOZXh0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBpID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiB0eXBlYWhlYWRDb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGggJiYgdHlwZWFoZWFkQ29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQmVzdEZpdChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleE5leHRdLnVuc29ydGVkSW5kZXgsIHJlYXNvbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleEFsbCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5kZXgoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2xvd2VzdFNvcnRlZEluZGV4QWxsXS51bnNvcnRlZEluZGV4LHJlYXNvbiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCwgLi4udm9pZDEgfSxcbiAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnM6IHsgZ2V0VGV4dCwgLi4udm9pZDUgfSxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0OiB7IHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHsgc29ydGVkVHlwZWFoZWFkSW5mbywgaW5zZXJ0aW5nQ29tcGFyYXRvciwgLi4udm9pZDIgfSB9LFxuICAgIHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudCwgLi4udm9pZDMgfSxcbiAgICAvL3R5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHsgLi4udm9pZDUgfSxcbiAgICAuLi52b2lkNFxufTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+KTogUmV0dXJuVHlwZTxVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50Pj4ge1xuXG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDEpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQyKTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkMyk7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDQpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQ1KTtcblxuICAgIGNvbnN0IHsgdGV4dENvbnRlbnRSZXR1cm4gfSA9IHVzZVRleHRDb250ZW50KHtcbiAgICAgICAgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50IH0sXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZ2V0VGV4dCxcbiAgICAgICAgICAgIG9uVGV4dENvbnRlbnRDaGFuZ2U6IHVzZUNhbGxiYWNrPE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPHN0cmluZyB8IG51bGwsIG5ldmVyPj4oKHRleHQ6IHN0cmluZyB8IG51bGwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHdoZXJlIHRvIGluc2VydCB0aGlzIGl0ZW0uXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgYWxsIGluZGV4IHZhbHVlcyBzaG91bGQgYmUgdW5pcXVlLCB0aGUgcmV0dXJuZWQgc29ydGVkSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGFsd2F5cyByZWZlciB0byBhIG5ldyBsb2NhdGlvbiAoaS5lLiBiZSBuZWdhdGl2ZSkgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8sIHRleHQsIGluc2VydGluZ0NvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDAgfHwgaW5zZXJ0aW5nQ29tcGFyYXRvcihzb3J0ZWRUeXBlYWhlYWRJbmZvW3NvcnRlZEluZGV4XS50ZXh0LCB7IHVuc29ydGVkSW5kZXg6IGluZGV4LCB0ZXh0IH0pID09IDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGVkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLnNwbGljZSgtc29ydGVkSW5kZXggLSAxLCAwLCB7IHRleHQsIHVuc29ydGVkSW5kZXg6IGluZGV4IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5zcGxpY2Uoc29ydGVkSW5kZXgsIDAsIHsgdGV4dCwgdW5zb3J0ZWRJbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1bm1vdW50aW5nLCBmaW5kIHdoZXJlIHdlIHdlcmUgYW5kIHJlbW92ZSBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZ2Fpbiwgd2Ugc2hvdWxkIGFsd2F5cyBmaW5kIG91cnNlbHZlcyBiZWNhdXNlIHRoZXJlIHNob3VsZCBiZSBubyBkdXBsaWNhdGUgdmFsdWVzIGlmIGVhY2ggaW5kZXggaXMgdW5pcXVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mbywgdGV4dCwgaW5zZXJ0aW5nQ29tcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDAgfHwgaW5zZXJ0aW5nQ29tcGFyYXRvcihzb3J0ZWRUeXBlYWhlYWRJbmZvW3NvcnRlZEluZGV4XS50ZXh0LCB7IHVuc29ydGVkSW5kZXg6IGluZGV4LCB0ZXh0IH0pID09IDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGVkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uc3BsaWNlKHNvcnRlZEluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSwgW10pXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHsgdGV4dENvbnRlbnRSZXR1cm4gfVxuXG59XG5cbi8qKlxuICogWW91ciB1c3VhbCBiaW5hcnkgc2VhcmNoIGltcGxlbWVudGF0aW9uLlxuICogXG4gKiBJdCdzIHVzZWQgaGVyZSB0byBxdWlja2x5IGZpbmQgYSBnb29kIHNwb3QgdG8gc3RhcnQgc2VhcmNoaW5nIGZvciBvdXIgbmV4dCB0eXBlYWhlYWQgY2FuZGlkYXRlLlxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2ggdGhyb3VnaFxuICogQHBhcmFtIHdhbnRlZCBUaGUgdmFsdWUgeW91J2QgbGlrZSB0byBmaW5kXG4gKiBAcGFyYW0gY29tcGFyYXRvciBDb21wYXJlcyBgd2FudGVkYCB3aXRoIHRoZSBjdXJyZW50IHZhbHVlIGluIGBhcnJheWBcbiAqIEByZXR1cm5zIEEgbm9uLW5lZ2F0aXZlIHZhbHVlIGlmIGB3YW50ZWRgIHdhcyBmb3VuZCwgYW5kIGEgbmVnYXRpdmUgbnVtYmVyIGlmIG5vdC4gXG4gKiBUaGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBudW1iZXIsIG1pbnVzIG9uZSwgaXMgd2hlcmUgYHdhbnRlZGAgKndvdWxkKiBiZSBmb3VuZCBpZiBpdCAqd2FzKiBpbiBgYXJyYXlgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2g8VCwgVSwgRiBleHRlbmRzIChsaHM6IFUsIHJoczogVCkgPT4gbnVtYmVyPihhcnJheTogVFtdLCB3YW50ZWQ6IFUsIGNvbXBhcmF0b3I6IEYpOiBudW1iZXIge1xuICAgIGxldCBmaXJzdEluZGV4ID0gMDtcbiAgICBsZXQgbGFzdEluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoZmlyc3RJbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgdGVzdEluZGV4ID0gKGxhc3RJbmRleCArIGZpcnN0SW5kZXgpID4+IDE7XG4gICAgICAgIGNvbnN0IGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJhdG9yKHdhbnRlZCwgYXJyYXlbdGVzdEluZGV4XSk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgICAgICBmaXJzdEluZGV4ID0gdGVzdEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gdGVzdEluZGV4IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLWZpcnN0SW5kZXggLSAxO1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgYXNzZXJ0RW1wdHlPYmplY3QsIE1hbmFnZWRDaGlsZEluZm8sIHVzZUNoaWxkcmVuRmxhZywgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgVXNlSGFzQ3VycmVudEZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCIuLi9vYnNlcnZlcnMvdXNlLWhhcy1jdXJyZW50LWZvY3VzXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgUGFzc2l2ZVN0YXRlVXBkYXRlciB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlT2JqZWN0IH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhdGVcIjtcblxuXG5cbmV4cG9ydCB0eXBlIE9uVGFiYmFibGVJbmRleENoYW5nZSA9ICh0YWJiYWJsZUluZGV4OiBudW1iZXIgfCBudWxsKSA9PiB2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlcj4ge1xuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgbmF2aWdhdGUgdG8gYSBjaGlsZCBhbmQgZm9jdXMgaXQsIHdlIG5lZWQgdG8ga25vdyBob3cgdGhhdCBjaGlsZCB3YW50cyB0byBiZSBmb2N1c2VkLlxuICAgICAqIEdlbmVyYWxseSwgdGhpcyBpcyBqdXN0IGdldEVsZW1lbnQoKS5mb2N1cygpLCBidXQgeW91J3JlIGFsbG93ZWQgdG8gc3VwcGx5IGFueXRoaW5nIHlvdSB3YW50IGhlcmUuXG4gICAgICogR3JpZCByb3dzLCBmb3IgZXhhbXBsZSwgZG9uJ3QgZGlyZWN0bHkgZm9jdXMgdGhlbXNlbHZlcyBidXQgaW5zdGVhZCBjYWxsIG9uZSBvZiB0aGVpciBjZWxsJ3MgYGZvY3VzU2VsZmAuXG4gICAgICogXG4gICAgICogVGhpcyBpcyB1c2VkIHdoZW4gdGhlIHRhYmJhYmxlIGluZGV4IGNoYW5nZXMgKHdlIGF1dG8tZm9jdXMgdGhlIG5ld2x5IHRhYmJhYmxlIGVsZW1lbnQgaWYgYXBwbGljYWJsZSksXG4gICAgICogYW5kIGFsc28gYnkgdGhlIGBmb2N1c1NlbGZgIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBwYXJlbnQgKGkuZS4gYHBhcmVudC5mb2N1c1NlbGZgIGNhbGxzIG9uZSBjaGlsZCdzIGBmb2N1c1NlbGZgKVxuICAgICAqL1xuICAgIGZvY3VzU2VsZihlOiBUYWJiYWJsZUNoaWxkRWxlbWVudCk6IHZvaWQ7XG5cbiAgICBnZXRFbGVtZW50KCk6IFRhYmJhYmxlQ2hpbGRFbGVtZW50IHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoaXMgY2hpbGQgY2Fubm90IGJlIGdpdmVuIGZvY3VzIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3QsIGlzIG5vdCB2aXNpYmxlLCBpcyBkaXNhYmxlZCwgZXRjLiBBbnkgYXR0ZW1wdCB0byBmb2N1cyB0aGlzIGVsZW1lbnQgd2lsbCBmb2N1cyBpdHMgY2xvc2VzdCBuZWlnaGJvciBpbnN0ZWFkLlxuICAgICAqIFxuICAgICAqIFRoaXMgKioqTVVTVCoqKiBiZSB0cnVlIGlmIHRoZSBjaGlsZCBpcyBgZGlzcGxheTogbm9uZWAsIGB2aXNpYmlsaXR5OiBoaWRkZW5gLCBhbmQgb3RoZXIgY2FzZXMgd2hlcmUgdGhlIGVsZW1lbnQncyBmb2N1c2FiaWxpdHkgaXMgcmVtb3ZlZCBpbiBhIHdheSB0aGF0J3Mgbm90IGRldGVjdGlibGUuXG4gICAgICovXG4gICAgaGlkZGVuOiBib29sZWFuO1xuXG4gICAgc2V0VGFiYmFibGU6IFN0YXRlVXBkYXRlcjxib29sZWFuPjtcbiAgICBnZXRUYWJiYWJsZTogKCkgPT4gYm9vbGVhbjtcbiAgICB0YWJiYWJsZTogYm9vbGVhbjtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczxUYWJiYWJsZUNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudD4+IHtcbiAgICAvKiogV2hlbiBjaGlsZHJlbiBtb3VudC91bm1vdW50LCBSVEkgbmVlZHMgYWNjZXNzIHRvIGFsbCBrbm93biBjaGlsZHJlbiBpbiBjYXNlIHdlIHVubW91bnRlZCB0aGUgY3VycmVudGx5IHRhYmJhYmxlIGNoaWxkICovXG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBQaWNrPFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8TT5bXCJtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5cIl0sIFwiZ2V0Q2hpbGRyZW5cIj47XG5cbiAgICAvKiogVGhlIG9ubHkgcGFyYW1ldGVycyBSVEkgbmVlZHMgZGlyZWN0bHkgaXMgdGhlIGluaXRpYWwgaW5kZXggdG8gYmUgdGFiYmFibGUgKi9cbiAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgaW1wZXJhdGl2ZSwgbm90IGRlY2xhcmF0aXZlOyBcbiAgICAgICAgICogaXQgaXMgYmV0dGVyIGlmIHdlIGNhbiBrZWVwIHJlLXJlbmRlcnMgb24gdGhlIHBhcmVudCB0byBhIG1pbmltdW0gYW55d2F5LlxuICAgICAgICAgKiBcbiAgICAgICAgICogWW91IGNhbiBtYW51YWxseSBjb250cm9sIHRoaXMgd2l0aCBgb25UYWJiYWJsZUluZGV4Q2hhbmdlYCBhbmQgYHNldFRhYmJhYmxlSW5kZXhgIGlmIHlvdSBuZWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGx5VGFiYmVkSW5kZXg6IG51bWJlciB8IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gdHJ1ZSwgbm9uZSBvZiB0aGUgY2hpbGRyZW4gd2lsbCBiZSB0YWJiYWJsZSwgYXMgaWYgdGhlIGVudGlyZSBjb21wb25lbnQgaXMgaGlkZGVuLlxuICAgICAgICAgKiBcbiAgICAgICAgICogVGhpcyBkb2VzIG5vdCBhY3R1YWxseSBjaGFuZ2UgdGhlIGN1cnJlbnRseSB0YWJiYWJsZSBpbmRleDsgaWYgdGhpcyBpcyBzZXQgdG8gYGZhbHNlYCwgdGhlIGxhc3QgdGFiYmFibGUgY2hpbGQgaXMgcmVtZW1iZXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIHVudGFiYmFibGU6IGJvb2xlYW47XG5cbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBJZiB5b3Ugd291bGQgbGlrZSB0byBoYXZlIGFuIGV2ZW50IHJ1biB3aGVuZXZlciBhIG5ldyBpbmRleCBiZWNvbWVzIHRhYmJhYmxlXG4gICAgICAgICAqIChlLmcuIHRvIGNhbGwgYHNldFN0YXRlYCB0byByZW5kZXIgdGhhdCB0YWJiYWJsZSBpbmRleC4uLmZvciBzb21lIHJlYXNvbi4uLilcbiAgICAgICAgICogeW91IGNhbiBkbyB0aGF0IGhlcmUuXG4gICAgICAgICAqIFxuICAgICAgICAgKiAqKk1VU1QqKiBiZSBzdGFibGUhXG4gICAgICAgICAqL1xuICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxudW1iZXIgfCBudWxsLCBFdmVudD47XG4gICAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGU8VGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgLyoqIFJUSSBydW5zIGxvZ2ljIHdoZW4gaXRzIGNoaWxkcmVuIG1vdW50L3VubW91bnQgdGhlbXNlbHZlcyAqL1xuICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IFBpY2s8VXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudD4+W1wibWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyc1wiXSwgXCJvbkNoaWxkcmVuTW91bnRDaGFuZ2VcIj47XG5cbiAgICAvKipcbiAgICAgKiBTVEFCTEVcbiAgICAgKi9cbiAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dDogVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8VGFiYmFibGVDaGlsZEVsZW1lbnQ+W1wicm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHRcIl07XG5cbiAgICAvKiogXG4gICAgICogUmV0dXJuIGluZm9ybWF0aW9uIHRoYXQgbGV0cyB0aGUgdXNlciB1cGRhdGUvcXVlcnkvZm9jdXMgdGhlIGN1cnJlbnRseSB0YWJiYWJsZSBjaGlsZFxuICAgICAqXG4gICAgICogIFxuICAgICAqL1xuICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuOiB7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXg6IFNldFRhYmJhYmxlSW5kZXg7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldFRhYmJhYmxlSW5kZXg6ICgpID0+IG51bWJlciB8IG51bGw7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGZvY3VzU2VsZjogKHJlYXNvbj86IGFueSkgPT4gdm9pZDtcbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIFNldFRhYmJhYmxlSW5kZXggPSAodXBkYXRlcjogUGFyYW1ldGVyczxQYXNzaXZlU3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGwsIEV2ZW50Pj5bMF0sIHJlYXNvbjogRXZlbnQgfCB1bmRlZmluZWQsIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHZvaWQ7XG5cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVXaXRoSG9va3M8VGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQ+IHsgfVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8VGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogUGljazxVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudD4sIFwiaW5kZXhcIj47XG5cbiAgICAvKiogXG4gICAgICogVGhlIGluZm9ybWF0aW9uIHNwZWNpZmljIHRvIFJUSSBmb3IgdGhpcyBjaGlsZCB0aGF0IHlvdSBwcm92aWRlXG4gICAgICovXG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IFBpY2s8VXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQ+LCBcImhpZGRlblwiPjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbmZvcm1hdGlvbiBwcm92aWRlZCBieSB0aGUgcGFyZW50IGhvb2tcbiAgICAgKi9cbiAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dDogUm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQ8VGFiYmFibGVDaGlsZEVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0PFRhYmJhYmxlQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIF9lPzogVGFiYmFibGVDaGlsZEVsZW1lbnQ7XG5cbiAgICBzZXRUYWJiYWJsZUluZGV4OiBTZXRUYWJiYWJsZUluZGV4OyAvL1VzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZTxUYWJiYWJsZUNoaWxkRWxlbWVudD5bXCJyb3ZpbmdUYWJJbmRleFJldHVyblwiXVtcInNldFRhYmJhYmxlSW5kZXhcIl07XG5cbiAgICAvKipcbiAgICAgKiAoVGhpcyBpcyB0ZWNobmljYWxseSB0aGUgc2FtZSBhcyB3aGF0J3MgcGFzc2VkIHRvIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICAgKiBidXQgaXQgc2VydmVzIGEgc2xpZ2h0bHkgZGlmZmVyZW50IHB1cnBvc2UgYW5kIGlzIHNlcGFyYXRlIGZvciBjbGFyaXR5KVxuICAgICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xufVxuXG4vL2V4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoYTogVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBSPikgPT4gVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG5cbiAgICAvKiogXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhIHVzZXIgY2xpY2tzIG9uIGFuIGVsZW1lbnQgb3IgbWFudWFsbHkgZm9jdXNlcyBpdCBpbiBzb21lIG90aGVyIHdheS5cbiAgICAgKiBcbiAgICAgKiBXZSBuZWVkIHRvIGtub3cgaWYgd2UncmUgY3VycmVudGx5IGZvY3VzZWQgc28gdGhhdCB3ZSBjYW4gdGVsbCB0aGUgcGFyZW50IHRvIG1hcmsgdGhpcyBjaGlsZCBhcyB0aGUgY3VycmVudGx5IHRhYmJhYmxlIGNoaWxkLlxuICAgICAqL1xuICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IFJlcXVpcmVkPFBpY2s8VXNlSGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1wiaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyc1wiXSwgXCJvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkXCI+PjtcblxuICAgIC8qKiBSZXR1cm4gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmJhYmxlIHN0YXRlIG9mIHRoaXMgY2hpbGQgKi9cbiAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAqVW5zdGFibGUqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgY2hpbGQsIGluZGl2aWR1YWxseSwgaXMgKnRoZSogY3VycmVudGx5IHRhYmJhYmxlIGNoaWxkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGFiYmFibGU6IGJvb2xlYW47XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldFRhYmJhYmxlKCk6IGJvb2xlYW47XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqXG4gICAgICAgICAqIFxuICAgICAgICAgKiBJbnRlcm5hbCB1c2Ugb25seSwgcGFzcyB0byBgdXNlTWFuYWdlZENoaWxkYFxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VGFiYmFibGU6IFN0YXRlVXBkYXRlcjxib29sZWFuPjtcblxuICAgICAgICAvKiogXG4gICAgICAgICAqICpVbnN0YWJsZSpcbiAgICAgICAgICogXG4gICAgICAgICAqIFRoZSBwcm9wcyB0aGF0IG11c3QgYmUgYXBwbGllZCB0byB0aGlzIGNoaWxkIGluIG9yZGVyIGZvciB0aGlzIGhvb2sgdG8gd29yay5cbiAgICAgICAgICogXG4gICAgICAgICAqIFRoZSBvYmplY3QgaXRzZWxmLCBhcyB3ZWxsIGFzIHRoZSBwcm9wZXJ0aWVzIHdpdGhpbiBpdCwgYXJlIHVuc3RhYmxlIGFuZCBzaG91bGQgYmUgcmVuZGVyZWQgYnkgdGhlIHNhbWUgY29tcG9uZW50IHRoYXQgdXNlcyB0aGlzIGhvb2suXG4gICAgICAgICAqL1xuICAgICAgICBwcm9wc1Vuc3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xuICAgIH1cbn1cblxuXG5cbi8qKlxuICogSW1wbGVtZW50cyBhIHJvdmluZyB0YWJpbmRleCBzeXN0ZW0gd2hlcmUgb25seSBvbmUgXCJmb2N1c2FibGVcIlxuICogY29tcG9uZW50IGluIGEgc2V0IGlzIGFibGUgdG8gcmVjZWl2ZSBhIHRhYiBmb2N1cy4gKldoaWNoKlxuICogb2YgdGhvc2UgZWxlbWVudHMgcmVjZWl2ZXMgZm9jdXMgaXMgZGV0ZXJtaW5lZCBieSB5b3UsIGJ1dCBpdCdzXG4gKiByZWNvbW1lbmRlZCB0byBvZmZsb2FkIHRoYXQgbG9naWMgdGhlbiB0byBhbm90aGVyIGhvb2ssIGxpa2VcbiAqIGB1c2VMaW5lYXJOYXZpZ2F0aW9uYCwgd2hpY2ggbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZVxuICogZWxlbWVudCB3aXRoIHRoZSBhcnJvdyBrZXlzLCBgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbmAsIHdoaWNoXG4gKiBsZXRzIHlvdSBjaGFuZ2UgdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdHlwZWFoZWFkLCBvclxuICogYHVzZUxpc3ROYXZpZ2F0aW9uYCBpZiB5b3UganVzdCB3YW50IGV2ZXJ5dGhpbmcgYnVuZGxlZCB0b2dldGhlci5cbiAqIFxuICogTm90ZSB0aGF0IHRoZSBjaGlsZCBob29rIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkXG4gKiBieSBldmVyeSBjaGlsZCB0aGF0IHVzZXMgdGhpcyByb3ZpbmcgdGFiaW5kZXggbG9naWMuICBUaGVcbiAqIHByb3AtbW9kaWZ5aW5nIGhvb2sgKnRoYXQqIGhvb2sgcmV0dXJucyBzaG91bGQgdGhlbiBiZSB1c2VkXG4gKiBvbiB0aGUgY2hpbGQncyBlbGVtZW50LCBhcyB3ZWxsIGFzIGFueSBvdGhlciBlbGVtZW50cyB5b3UnZCBsaWtlXG4gKiB0byBiZSBleHBsaWNpdGx5IG1hZGUgdW50YWJiYWJsZSB0b28uXG4gKiBcbiAqIGBzaG91bGRGb2N1c09uQ2hhbmdlYCBzaG91bGQgcmV0dXJuIHRydWUgaWYgZm9jdXMgaXMgXG4gKiBjb250YWluZWQgd2l0aGluIHdoYXRldmVyIGVsZW1lbnQgY29udGFpbnMgdGhlIHJvdmluZyB0YWIgaW5kZXguXG4gKiBHZW5lcmFsbHkgYXMgc2ltcGxlIGFzIHRoZSBmb2xsb3dpbmc6XG4gKiBgYGBcbiAqIGNvbnN0IFtmb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gKiBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPFBhcmVudEVsZW1lbnQ+KHsgc2V0Rm9jdXNlZElubmVyIH0pO1xuICogY29uc3QgZm9jdXNPbkNoYW5nZSA9IChmb2N1c2VkSW5uZXIgIT0gZmFsc2UpO1xuICogYGBgXG4gKiBJdCdzIG5vdCBpbmNsdWRlZCBoZXJlIGJlY2F1c2UgYHVzZVJvdmluZ1RhYkluZGV4YCBkb2Vzbid0IGtub3cgXG4gKiBhbnl0aGluZyBhYm91dCB0aGUgY29udGFpbmVyIGVsZW1lbnQsIG9ubHkgY2hpbGRyZW4gZWxlbWVudHMuXG4gKiBBbmQganVzdCBhcyB3ZWxsISBDaGlsZHJlbiBzaG91bGQgYmUgYWxsb3dlZCBhdCB0aGUgcm9vdCwgXG4gKiByZWdhcmRsZXNzIG9mIGlmIGl0J3MgdGhlIHdob2xlIGFwcCBvciBqdXN0IGEgZ2l2ZW4gY29tcG9uZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPENoaWxkRWxlbWVudD4+KHtcbiAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHsgZ2V0Q2hpbGRyZW4gfSxcbiAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHsgdW50YWJiYWJsZSwgaW5pdGlhbGx5VGFiYmVkSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSB9LFxuICAgIC4uLl92b2lkMVxufTogVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgTT4pOiBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGU8Q2hpbGRFbGVtZW50PiB7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QoX3ZvaWQxKTtcblxuICAgIC8vaW5pdGlhbGx5VGFiYmVkSW5kZXggPz89IDA7XG5cbiAgICAvLyBPdmVycmlkZSB0aGUgYWN0dWFsIHNldHRlciB0byBpbmNsdWRlIHNvbWUgZXh0cmEgbG9naWMgcmVsYXRlZCB0byBhdm9pZGluZyBoaWRkZW4gY2hpbGRyZW4sIFxuICAgIC8vIHdoYXQgdG8gZG8gd2hlbiB3ZSdyZSB1bnRhYmJhYmxlLCB3aGF0IHRvIGRvIHdoZW4gd2UncmUgdGFiYmFibGUgYnV0IGdpdmVuIGBudWxsYCwgZXRjLlxuICAgIGNvbnN0IHNldFRhYmJhYmxlSW5kZXggPSB1c2VTdGFibGVDYWxsYmFjazxTZXRUYWJiYWJsZUluZGV4PigodXBkYXRlciwgcmVhc29uLCBmcm9tVXNlckludGVyYWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcblxuICAgICAgICAvLyBOb3RpZnkgdGhlIHJlbGV2YW50IGNoaWxkcmVuIHRoYXQgdGhleSBzaG91bGQgYmVjb21lIHRhYmJhYmxlL3VudGFiYmFibGUsXG4gICAgICAgIC8vIGJ1dCBhbHNvIGhhbmRsZSBmb2N1cyBtYW5hZ2VtZW50IHdoZW4gd2UgY2hhbmdlZCBkdWUgdG8gdXNlciBpbnRlcmFjdGlvblxuICAgICAgICByZXR1cm4gc2V0VGFiYmFibGVJbmRleDMoZiwgcmVhc29uKTtcblxuXG4gICAgICAgIGZ1bmN0aW9uIGYocHJldkluZGV4OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gKCh0eXBlb2YgdXBkYXRlciA9PT0gXCJmdW5jdGlvblwiKSA/IHVwZGF0ZXIocHJldkluZGV4ID8/IG51bGwpIDogdXBkYXRlcikgYXMgTVtcImluZGV4XCJdO1xuXG4gICAgICAgICAgICBpZiAodW50YWJiYWJsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHByZXZJbmRleCAhPSBuZXh0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hpbGQgPSBuZXh0SW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChuZXh0SW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQ/LmhpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkluZGV4ID8/ICh1bnRhYmJhYmxlID8gbnVsbCA6IDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQgIT0gbnVsbCAmJiBmcm9tVXNlckludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBuZXh0Q2hpbGQuZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fCAhZWxlbWVudC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q2hpbGQuZm9jdXNTZWxmKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0SW5kZXggPz8gKHVudGFiYmFibGUgPyBudWxsIDogMCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBsYXN0Tm9uTnVsbEluZGV4ID0gdXNlUmVmPG51bWJlciB8IG51bGw+KGluaXRpYWxseVRhYmJlZEluZGV4KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHQgPSBnZXRUYWJiYWJsZUluZGV4KCk7XG4gICAgICAgIGlmICh0ICE9IG51bGwpXG4gICAgICAgICAgICBsYXN0Tm9uTnVsbEluZGV4LmN1cnJlbnQgPSB0O1xuICAgIH0pO1xuXG4gICAgLy8gQW55IHRpbWUgd2Ugc3dpdGNoIHRvIGJlaW5nIHVudGFiYmFibGUsIHNldCB0aGUgY3VycmVudCB0YWJiYWJsZSBpbmRleCBhY2NvcmRpbmdseS5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodW50YWJiYWJsZSlcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgzKG51bGwsIHVuZGVmaW5lZCEpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4MyhsYXN0Tm9uTnVsbEluZGV4LmN1cnJlbnQsIHVuZGVmaW5lZCEpO1xuICAgIH0sIFt1bnRhYmJhYmxlXSk7XG5cbiAgICAvLyBCb2lsZXJwbGF0ZSByZWxhdGVkIHRvIG5vdGlmeWluZyBpbmRpdmlkdWFsIGNoaWxkcmVuIHdoZW4gdGhleSBiZWNvbWUgdGFiYmFibGUvdW50YWJiYWJsZVxuICAgIGNvbnN0IGdldFRhYmJhYmxlQXQgPSB1c2VDYWxsYmFjaygobTogVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm88Q2hpbGRFbGVtZW50PikgPT4geyByZXR1cm4gbS5nZXRUYWJiYWJsZSgpIH0sIFtdKTtcbiAgICBjb25zdCBzZXRUYWJiYWJsZUF0ID0gdXNlQ2FsbGJhY2soKG06IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPENoaWxkRWxlbWVudD4sIHQ6IGJvb2xlYW4pID0+IHsgbS5zZXRUYWJiYWJsZSh0KTsgfSwgW10pO1xuICAgIGNvbnN0IGlzVGFiYmFibGVWYWxpZCA9IHVzZUNhbGxiYWNrKChtOiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+KSA9PiB7IHJldHVybiAhbS5oaWRkZW4gfSwgW10pO1xuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXg6IHNldFRhYmJhYmxlSW5kZXgzLCBnZXRDdXJyZW50SW5kZXg6IGdldFRhYmJhYmxlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0IH0gPSB1c2VDaGlsZHJlbkZsYWc8VXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm88Q2hpbGRFbGVtZW50PiwgRXZlbnQ+KHtcbiAgICAgICAgaW5pdGlhbEluZGV4OiBpbml0aWFsbHlUYWJiZWRJbmRleCA/PyAodW50YWJiYWJsZT8gbnVsbCA6IDApLFxuICAgICAgICBvbkluZGV4Q2hhbmdlOiBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgICAgIGdldENoaWxkcmVuLFxuICAgICAgICBjbG9zZXN0Rml0OiB0cnVlLFxuICAgICAgICBnZXRBdDogZ2V0VGFiYmFibGVBdCxcbiAgICAgICAgaXNWYWxpZDogaXNUYWJiYWJsZVZhbGlkLFxuICAgICAgICBzZXRBdDogc2V0VGFiYmFibGVBdCxcbiAgICB9KTtcblxuICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKChyZWFzb24/OiB1bmtub3duKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRUYWJiYWJsZUluZGV4KCk7XG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gY2hpbGRyZW4uZ2V0QXQoaW5kZXgpPy5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICBjaGlsZHJlbi5nZXRBdChpbmRleCk/LmZvY3VzU2VsZj8uKGVsZW1lbnQhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG51bGwsIHJlYXNvbiBhcyBhbnksIHRydWUpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0ID0gdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgc2V0VGFiYmFibGVJbmRleCxcbiAgICAgICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXRcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiByZWV2YWx1YXRlQ2xvc2VzdEZpdCwgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm46IHsgc2V0VGFiYmFibGVJbmRleCwgZ2V0VGFiYmFibGVJbmRleCwgZm9jdXNTZWxmIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0XG4gICAgfTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXhDaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCwgLi4uX3ZvaWQyIH0sXG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQ6IHsgcmVldmFsdWF0ZUNsb3Nlc3RGaXQsIHNldFRhYmJhYmxlSW5kZXggfSxcbiAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbn06IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD4pOiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+IHtcbiAgICBjb25zdCB7IGhpZGRlbiwgLi4uX3ZvaWQxIH0gPSByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycztcbiAgICBjb25zdCBbdGFiYmFibGUsIHNldFRhYmJhYmxlLCBnZXRUYWJiYWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZWV2YWx1YXRlQ2xvc2VzdEZpdCgpO1xuICAgIH0sIFshIWhpZGRlbl0pO1xuXG4gICAgYXNzZXJ0RW1wdHlPYmplY3QoX3ZvaWQxKTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIF9wcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCwgZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaW5kZXgsIGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuOiB7XG4gICAgICAgICAgICBwcm9wc1Vuc3RhYmxlOiB7IHRhYkluZGV4OiAodGFiYmFibGUgPyAwIDogLTEpIH0sXG4gICAgICAgICAgICB0YWJiYWJsZSxcbiAgICAgICAgICAgIGdldFRhYmJhYmxlLFxuICAgICAgICAgICAgc2V0VGFiYmFibGVcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBhc3NlcnRFbXB0eU9iamVjdCB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlTGluZWFyTmF2aWdhdGlvbiwgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbiwgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGUgfSBmcm9tIFwiLi91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlUm92aW5nVGFiSW5kZXgsIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvLCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycywgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGUsIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVycywgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJvdmluZy10YWJpbmRleFwiO1xuXG5cbi8qKlxuICogXG4gKiBUT0RPOiBUaGlzIHRhYmxlIHdhcyBzY3JhcHBlZCB3aGVuIHRoaXMgd2FzIGNoYW5nZWQgdG8ganVzdCBhY2NlcHQgYSBjb2xsYXRvciBkaXJlY3RseSxcbiAqIGJ1dCBpdCdzIG5vdCBiYWQgZm9yIGEgY29sbGF0aW9uIGNyYXNoIGNvdXJzZSBhbmQgSSBtaWdodCB1c2UgaXQgYWdhaW4uXG4gKiBFdmVuIGp1c3QgYXMgYSBcInRoaXMgaXMgd2h5IGl0J3MgaW1wb3J0YW50IGFuZCBnb29kIHRvIHVzZSB0aGVzZSB0aGluZ3NcIiB0aGluZy5cbiAqIFxuICogfExhbmcufFRhcmdldHxVc2VyIGlucHV0fGBiYXNlYHxgYWNjZW50YHxgY2FzZWB8YHZhcmlhbnRgfFxuICogfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18XG4gKiB8RU58SGl8QnllfOKdjHzinYx84p2MfOKdjHxcbiAqIHxFTnxIaXxIaXzinIV84pyFfOKchXzinIV8XG4gKiB8RU58SGl877yo772JfOKchXzinIV84pyFfOKdjHxcbiAqIHxFTnxIaXxoaXzinIV84pyFfOKdjHzinYx8XG4gKiB8RU58SGl8SMOvfOKchXzinYx84p2MfOKdjHxcbiAqIHxFTnzDpXxhYXzinYx84p2MfOKdjHzinYx8XG4gKiB8REF8w6V8YWF84pyFfOKchXzinIV84p2MfFxuICogfERBfMOlfEFBfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxBYXzinIV84pyFfOKdjHzinYx8XG4gKiB8REF8w6V8YUF84p2MfOKdjHzinYx84p2MfFxuICogfEVOfMOlfGF84pyFfOKchXzinYx84p2MfFxuICogfERBfMOlfGF84pyFfOKchXzinYx84p2MfFxuICogfEpQfO+qqnznnYB84pyFfOKchXzinIV84pyFfFxuICogfEpQfOOCq3zvvbZ84pyFfOKchXzinIV84pyFfFxuICogfEpQfOOCq3zjgYt84pyFfOKchXzinIV84p2MfFxuICogfEpQfOOCq3zjg7V84pyFfOKchXzinIV84p2MfFxuICogfEpQfOOCq3zji5V84pyFfOKchXzinYx84p2MfFxuICogfEpQfOOCq3zjgqx84pyFfOKdjHzinYx84p2MfFxuICogfEpQfOOCq3zlipt84p2MfOKdjHzinYx84p2MfFxuICogfFpIfOe0hXznuqJ84p2MfOKdjHzinYx84p2MfFxuICogXG4gKiBcbiAqIChOb3RlIHRvIHNlbGY6IEF0IHNvbWUgcG9pbnQsIHRoaXMgZmlsZSB3aWxsIHByb2JhYmx5IGJlIG5vcm1hbGl6ZWRcbiAqIGJ5IHNvbWVib2R5IGFuZCDvqqogd2lsbCB0dXJuIGJhY2sgaW50byDnnYAuKVxuICogXG4gKiBVbnJlbGF0ZWQsIGJ1dCBoZXksIHRoaXMgaXMgZnVuOiB0cnkgaGlnaGxpZ2h0aW5nIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSB0d28gY2hhcmFjdGVycyBpbiBWUyBDb2RlLFxuICogb3IganVzdCB0eXBpbmcgYSBjaGFyYWN0ZXIgaW4gYmV0d2VlbiB0aGVtLiBXaGF0J3MgdXAgd2l0aCB0aGlzP1xuICog76qqIOedgFxuICovXG5jb25zdCBfZHVtbXk6IGFueSA9IG51bGw7XG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25DaGlsZEluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50PiB7XG4gICAgX2U/OiBUYWJiYWJsZUNoaWxkRWxlbWVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0gZnJvbVVzZXJJbnRlcmFjdGlvbiBXaGV0aGVyIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGlzIGNoaWxkIGFzIGEgbWVhbnMgb2YgbmF2aWdhdGluZyB0byBpdC4gIEluIHRoYXQgd2FzIHRoZSBjYXNlLCB0aGUgY2hpbGQgaXMgYWxzbyBmb2N1c2VkLiBPdGhlcndpc2UsIGZvY3VzIG1vdmVzIGFzIHRoZSBicm93c2VyIGRldGVybWluZXMuXG4gKi9cbmV4cG9ydCB0eXBlIE5hdmlnYXRlVG9JbmRleCA9IChpOiBudW1iZXIgfCBudWxsLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xuXG5cblxuXG5cbi8vICoqKiBQYXJhbWV0ZXJzIChsaXN0LCBsaXN0LXNpbmdsZSwgbGlzdC1jaGlsZCwgbGlzdC1zaW5nbGUtY2hpbGQpXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+PiBleHRlbmRzXG4gICAgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgTT4sXG4gICAgT21pdDxVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4UmV0dXJuXCI+LFxuICAgIE9taXQ8VXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhSZXR1cm5cIj4ge1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PiwgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+IHtcbiAgICAvL21hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD5bXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCJdICYgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1wibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiXTtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlPENoaWxkRWxlbWVudD4sIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxQYXJlbnRPckNoaWxkRWxlbWVudD4sIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+LCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlIHsgfVxuZXhwb3J0IHR5cGUgVXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+KSA9PiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+O1xuXG5cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHByb3BlciBrZXlib2FyZCBuYXZpZ2F0aW9uIGZvciBjb21wb25lbnRzIGxpa2UgbGlzdGJveGVzLCBidXR0b24gZ3JvdXBzLCBtZW51cywgZXRjLlxuICogXG4gKiBJbiB0aGUgZG9jdW1lbnQgb3JkZXIsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgXCJmb2N1c2VkXCIgb3IgXCJ0YWJiYWJsZVwiIGVsZW1lbnQsIG1ha2luZyBpdCBhY3QgbW9yZSBsaWtlIG9uZSBjb21wbGV0ZSB1bml0IGluIGNvbXBhcmlzb24gdG8gZXZlcnl0aGluZyBhcm91bmQgaXQuXG4gKiBOYXZpZ2F0aW5nIGZvcndhcmRzL2JhY2t3YXJkcyBjYW4gYmUgZG9uZSB3aXRoIHRoZSBhcnJvdyBrZXlzLCBIb21lL0VuZCBrZXlzLCBvciBhbnkgdGV4dCBmb3IgdHlwZWFoZWFkIHRvIGZvY3VzIHRoZSBuZXh0IGl0ZW0gdGhhdCBtYXRjaGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZEluZm88Q2hpbGRFbGVtZW50Pj4oe1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgLi4uX3ZvaWQxXG59OiBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4pOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudD4ge1xuXG4gICAgY29uc3QgcnRpciA9IHVzZVJvdmluZ1RhYkluZGV4PENoaWxkRWxlbWVudCwgTT4oeyBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyB9KTtcbiAgICBjb25zdCB7IHJvdmluZ1RhYkluZGV4UmV0dXJuIH0gPSBydGlyO1xuICAgIGNvbnN0IHRuciA9IHVzZVR5cGVhaGVhZE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudD4oeyByb3ZpbmdUYWJJbmRleFJldHVybiwgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMsIH0pO1xuICAgIGNvbnN0IGxuciA9IHVzZUxpbmVhck5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudD4oeyByb3ZpbmdUYWJJbmRleFJldHVybiwgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsIH0pO1xuXG4gICAgYXNzZXJ0RW1wdHlPYmplY3QoX3ZvaWQxKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmxucixcbiAgICAgICAgLi4udG5yLFxuICAgICAgICAuLi5ydGlyXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCxcbiAgICAvL3R5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICAuLi5fdm9pZDJcbn06IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD4pOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+IHtcblxuICAgIGNvbnN0IHJ0aWNyID0gdXNlUm92aW5nVGFiSW5kZXhDaGlsZDxDaGlsZEVsZW1lbnQ+KHsgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIH0pO1xuICAgIGNvbnN0IHsgdGV4dENvbnRlbnRSZXR1cm4gfSA9IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQ+KHsgcmVmRWxlbWVudFJldHVybiwgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCwgbWFuYWdlZENoaWxkUGFyYW1ldGVycywgdGV4dENvbnRlbnRQYXJhbWV0ZXJzIH0pO1xuXG4gICAgYXNzZXJ0RW1wdHlPYmplY3QoX3ZvaWQyKTtcbi8vICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkNSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0Q29udGVudFJldHVybixcbiAgICAgICAgLi4ucnRpY3JcbiAgICB9XG59IiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IGFzc2VydEVtcHR5T2JqZWN0LCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgUGFzc2l2ZVN0YXRlVXBkYXRlciwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVPYmplY3QgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IHVzZUxpc3ROYXZpZ2F0aW9uLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1saXN0LW5hdmlnYXRpb24tcGFydGlhbFwiO1xuaW1wb3J0IHsgU2V0VGFiYmFibGVJbmRleCB9IGZyb20gXCIuL3VzZS1yb3ZpbmctdGFiaW5kZXhcIjtcblxuLypcbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkTmF2aWdhdGlvblByb3BzPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PihyOiBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50PiwgLi4ub3RoZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JSb3dFbGVtZW50PltdKSB7XG4gICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50PihyLCAuLi5vdGhlclByb3BzKVxufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHM8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ocjogVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgLi4ub3RoZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD5bXSkge1xuICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PihyLmFzUGFyZW50Um93T2ZDZWxscywgLi4udXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzPFJvd0VsZW1lbnQ+KHIuYXNDaGlsZFJvd09mVGFibGUsIC4uLm90aGVyUHJvcHMpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHI6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQ+LCAuLi5vdGhlclByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD5bXSkge1xuICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHM8Q2VsbEVsZW1lbnQ+KHIsIC4uLm90aGVyUHJvcHMpO1xufSovXG5cblxuZXhwb3J0IGludGVyZmFjZSBHcmlkQ2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRJbmZvPFJvd0VsZW1lbnQ+IHsgc2V0VGFiYmFibGVDb2x1bW5JbmRleDogU2V0VGFiYmFibGVJbmRleCB9XG5leHBvcnQgaW50ZXJmYWNlIEdyaWRDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbzxDZWxsRWxlbWVudD4ge1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBHcmlkQ2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50Pj4gZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxQYXJlbnRPckNoaWxkRWxlbWVudCwgUm93RWxlbWVudCwgTT4sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4ge1xuICAgIGdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICBvblRhYmJhYmxlQ29sdW1uQ2hhbmdlOiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxudW1iZXIgfCBudWxsLCBFdmVudD47XG4gICAgfTtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogT21pdDxVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50T3JDaGlsZEVsZW1lbnQsIFJvd0VsZW1lbnQsIE0+W1wibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIl0sIFwibmF2aWdhdGlvbkRpcmVjdGlvblwiPlxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgIFJNIGV4dGVuZHMgR3JpZENoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZENoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQ+IHtcbiAgICBncmlkTmF2aWdhdGlvblJvd0NvbnRleHQ6IFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPltcImFzQ2hpbGRSb3dQYXJhbWV0ZXJzXCJdW1wiZ3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0XCJdXG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfUk0gZXh0ZW5kcyBHcmlkQ2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkQ2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+IHtcbiAgICBhc0NoaWxkUm93UGFyYW1ldGVyczogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Um93RWxlbWVudD4gJiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogUGljazxVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPENNPltcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiXSwgXCJnZXRDaGlsZHJlblwiPjtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0OiB7XG4gICAgICAgICAgICBfcj86IFJvd0VsZW1lbnQ7XG4gICAgICAgICAgICBfYz86IENlbGxFbGVtZW50O1xuICAgICAgICAgXG4gICAgICAgICAgICBncmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZVJvdzogU2V0VGFiYmFibGVJbmRleDsgLy8gKHVwZGF0ZXI6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAgICAgICAgICAgICBnZXRDdXJyZW50VGFiYmFibGVDb2x1bW46ICgpID0+IChudW1iZXIgfCBudWxsKTtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VGFiYmFibGVDb2x1bW46IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbCwgRXZlbnQ+O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBhc1BhcmVudFJvd1BhcmFtZXRlcnM6IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDTT4sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4gJiB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgQ00+W1wibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIl0sIFwibmF2aWdhdGlvbkRpcmVjdGlvblwiPlxuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZTxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgYXNDaGlsZFJvd1JldHVybjogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU8Um93RWxlbWVudD4gJiB7XG4gICAgICAgIGdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczogUGljazxHcmlkQ2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgXCJmb2N1c1NlbGZcIiB8IFwic2V0VGFiYmFibGVDb2x1bW5JbmRleFwiPjtcbiAgICB9O1xuICAgIGFzUGFyZW50Um93UmV0dXJuOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhSZXR1cm5cIj4gJiB7XG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD5bXCJyb3ZpbmdUYWJJbmRleFJldHVyblwiXSwgXCJmb2N1c1NlbGZcIj47XG4gICAgICAgIGdyaWROYXZpZ2F0aW9uQ2VsbENvbnRleHQ6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+W1wiZ3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dFwiXTtcbiAgICB9O1xufVxuXG5cblxuXG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxfUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDZWxsRWxlbWVudD4ge1xuICAgIGdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM6IHtcbiAgICAgICAgY29sU3BhbjogbnVtYmVyO1xuICAgIH1cbiAgICBncmlkTmF2aWdhdGlvbkNlbGxDb250ZXh0OiB7XG4gICAgICAgIF9jPzogQ2VsbEVsZW1lbnQ7XG4gICAgICAgIGdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGdldFJvd0luZGV4OiAoKSA9PiBudW1iZXI7XG4gICAgICAgICAgICBzZXRUYWJiYWJsZVJvdzogIFNldFRhYmJhYmxlSW5kZXg7IC8vKHU6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAgICAgICAgIGdldEN1cnJlbnRUYWJiYWJsZUNvbHVtbjogKCkgPT4gKG51bWJlciB8IG51bGwpO1xuICAgICAgICAgICAgc2V0Q3VycmVudFRhYmJhYmxlQ29sdW1uOiBQYXNzaXZlU3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGwsIEV2ZW50PjtcbiAgICAgICAgICAgIHNldFRhYmJhYmxlQ2VsbDogU2V0VGFiYmFibGVJbmRleDsgLy8odXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxDZWxsRWxlbWVudD4geyB9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkTmF2aWdhdGlvbjxQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50Pj4oe1xuICAgIGdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBvblRhYmJhYmxlQ29sdW1uQ2hhbmdlLCAuLi52b2lkMyB9LFxuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIC4uLnJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyB9LFxuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAuLi5fdm9pZDJcbn06IFVzZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTT4pOiBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiB7XG4gICAgY29uc3QgeyBnZXRDaGlsZHJlbiB9ID0gbWFuYWdlZENoaWxkcmVuUmV0dXJuO1xuICAgIGNvbnN0IHsgaW5pdGlhbGx5VGFiYmVkSW5kZXggfSA9IHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc1xuXG4gICAgY29uc3QgW2dldEN1cnJlbnRUYWJiYWJsZUNvbHVtbiwgc2V0Q3VycmVudFRhYmJhYmxlQ29sdW1uXSA9IHVzZVBhc3NpdmVTdGF0ZTxudW1iZXIgfCBudWxsLCBFdmVudD4ob25UYWJiYWJsZUNvbHVtbkNoYW5nZSwgdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gKGluaXRpYWxseVRhYmJlZEluZGV4ID8/IDApIH0pKTtcblxuICAgIGNvbnN0IG9uVGFiYmFibGVJbmRleENoYW5nZU92ZXJyaWRlID0gdXNlU3RhYmxlQ2FsbGJhY2soKGk6IG51bWJlciB8IG51bGwsIHA6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQsIHJlYXNvbjogRXZlbnQgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbigpO1xuICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U/LihpLCBwLCByZWFzb24pO1xuICAgICAgICBpZiAocCAhPSBudWxsKVxuICAgICAgICAgICAgY2hpbGRyZW4uZ2V0QXQocCk/LnNldFRhYmJhYmxlQ29sdW1uSW5kZXgobnVsbCwgcmVhc29uLCBmYWxzZSk7XG4gICAgICAgIGlmIChpICE9IG51bGwpXG4gICAgICAgICAgICBjaGlsZHJlbi5nZXRBdChpKT8uc2V0VGFiYmFibGVDb2x1bW5JbmRleChnZXRDdXJyZW50VGFiYmFibGVDb2x1bW4oKSwgcmVhc29uLCBmYWxzZSk7XG5cbiAgICB9KVxuXG4gICAgY29uc3Qge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgIC4uLnZvaWQxXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgUk0+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgbmF2aWdhdGlvbkRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiLCAuLi5saW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHsgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiBvblRhYmJhYmxlSW5kZXhDaGFuZ2VPdmVycmlkZSwgLi4ucm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcbiAgICB9KTtcblxuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQxKTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDIpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQzKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgZ3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzOiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlUm93OiByb3ZpbmdUYWJJbmRleFJldHVybi5zZXRUYWJiYWJsZUluZGV4LFxuICAgICAgICAgICAgICAgIGdldEN1cnJlbnRUYWJiYWJsZUNvbHVtbixcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VGFiYmFibGVDb2x1bW5cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlR3JpZE5hdmlnYXRpb25Sb3c8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkQ2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkQ2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+KHtcbiAgICBhc0NoaWxkUm93UGFyYW1ldGVyczogeyBncmlkTmF2aWdhdGlvblJvd0NvbnRleHQ6IHsgZ3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzOiB7IHNldFRhYmJhYmxlUm93LCBnZXRDdXJyZW50VGFiYmFibGVDb2x1bW4sIHNldEN1cnJlbnRUYWJiYWJsZUNvbHVtbiB9IH0sIC4uLmFzQ2hpbGRSb3dPZlRhYmxlIH0sXG4gICAgYXNQYXJlbnRSb3dQYXJhbWV0ZXJzOiB7IGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLCAuLi5hc1BhcmVudFJvd09mQ2VsbHNQIH0sXG4gICAgLi4uX3ZvaWQxXG59OiBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4pOiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHtcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlblJldHVybjogeyBnZXRDaGlsZHJlbiB9IH0gPSBhc0NoaWxkUm93T2ZUYWJsZTtcbiAgICBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHsgcmV0dXJuIGFzQ2hpbGRSb3dPZlRhYmxlLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMuaW5kZXggfSlcbiAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogUm93RWxlbWVudCkgPT4ge1xuICAgICAgICBsZXQgaW5kZXggPSAoZ2V0Q3VycmVudFRhYmJhYmxlQ29sdW1uKCkgPz8gMCk7XG4gICAgICAgIGxldCBjaGlsZCA9IGdldENoaWxkcmVuKCkuZ2V0QXQoaW5kZXgpO1xuICAgICAgICB3aGlsZSAoKCFjaGlsZCkgJiYgaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAtLWluZGV4O1xuICAgICAgICAgICAgY2hpbGQgPSBnZXRDaGlsZHJlbigpLmdldEF0KGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBjaGlsZC5nZXRFbGVtZW50KCkhO1xuICAgICAgICAgICAgY2hpbGQuZm9jdXNTZWxmKGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKGUgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCk/LmZvY3VzPy4oKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGxuY3IgPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkPFJvd0VsZW1lbnQ+KGFzQ2hpbGRSb3dPZlRhYmxlKTtcbiAgICBjb25zdCBsbnIgPSB1c2VMaXN0TmF2aWdhdGlvbjxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgQ00+KHsgLi4uYXNQYXJlbnRSb3dPZkNlbGxzUCwgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgbmF2aWdhdGlvbkRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIsIC4uLmxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzIH0gfSk7XG5cblxuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMSk7XG5cbiAgICBjb25zdCB7IHJvdmluZ1RhYkluZGV4UmV0dXJuOiB7IHNldFRhYmJhYmxlSW5kZXggfSxyb3ZpbmdUYWJJbmRleFJldHVybiwgbGluZWFyTmF2aWdhdGlvblJldHVybiwgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4gfSA9IGxucjtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXNDaGlsZFJvd1JldHVybjogeyBncmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM6IHsgZm9jdXNTZWxmLCBzZXRUYWJiYWJsZUNvbHVtbkluZGV4OiBzZXRUYWJiYWJsZUluZGV4IH0sIC4uLmxuY3IsIH0sXG4gICAgICAgIGFzUGFyZW50Um93UmV0dXJuOiB7XG4gICAgICAgICAgICAuLi5sbnIgLFxuICAgICAgICAgICAgZ3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dDp1c2VTdGFibGVPYmplY3QgKHtcbiAgICAgICAgICAgICAgICBncmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzOiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZVJvdyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0Um93SW5kZXg6IGdldEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBnZXRDdXJyZW50VGFiYmFibGVDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUYWJiYWJsZUNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVDZWxsOiBzZXRUYWJiYWJsZUluZGV4XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCxcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4sXG5cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4vLyAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbiwgaW5kZXgsIC4uLnZvaWQzIH0sXG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCxcbiAgICAvL3R5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICBncmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzOiB7XG4gICAgICAgIGNvbFNwYW5cbiAgICB9LFxuICAgIGdyaWROYXZpZ2F0aW9uQ2VsbENvbnRleHQ6IHtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZ2V0Um93SW5kZXgsXG4gICAgICAgICAgICBzZXRUYWJiYWJsZVJvdyxcbiAgICAgICAgICAgIGdldEN1cnJlbnRUYWJiYWJsZUNvbHVtbjogX2dldEN1cnJlbnRDb2x1bW4sXG4gICAgICAgICAgICBzZXRDdXJyZW50VGFiYmFibGVDb2x1bW4sXG4gICAgICAgICAgICBzZXRUYWJiYWJsZUNlbGxcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLi4uX3ZvaWQxXG59OiBVc2VHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzPGFueSwgQ2VsbEVsZW1lbnQ+KTogVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZTxDZWxsRWxlbWVudD4ge1xuICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM7XG4gICAgY29uc3Qge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7IG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IG9jZmljMSB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLFxuICAgICAgICB0ZXh0Q29udGVudFJldHVybixcbiAgICAgICAgLi4udm9pZDJcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDZWxsRWxlbWVudD4oe1xuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICAgICAgLy90eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuXG4gICAgfSk7XG5cbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDEpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQyKTtcbi8vICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQzKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4sXG4gICAgICAgIHRleHRDb250ZW50UmV0dXJuLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZCwgcHJldiwgZSkgPT4ge1xuICAgICAgICAgICAgICAgIG9jZmljMT8uKGZvY3VzZWQsIHByZXYsIGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVSb3coZ2V0Um93SW5kZXgoKSwgZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50VGFiYmFibGVDb2x1bW4oaW5kZXgsIGUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUNlbGwoKHByZXYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ICE9IG51bGwgJiYgKHByZXYgPCBpbmRleCB8fCBwcmV2ID4gaW5kZXggKyBjb2xTcGFuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9LCBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICB9XG59IiwiXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFVzZVByZXNzUGFyYW1ldGVycyB9IGZyb20gXCIuLi9jb21wb25lbnQtdXNlL3VzZS1wcmVzc1wiO1xuaW1wb3J0IHsgVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFJldHVyblR5cGUsIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCIuLi9vYnNlcnZlcnMvdXNlLWNoaWxkcmVuLWhhdmUtZm9jdXNcIjtcbmltcG9ydCB7IHVzZUNoaWxkcmVuRmxhZywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIFBhc3NpdmVTdGF0ZVVwZGF0ZXIsIHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm8sIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yb3ZpbmctdGFiaW5kZXhcIjtcbi8vaW1wb3J0IHsgdXNlUHJlc3MsIFVzZVByZXNzUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1wcmVzc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyLCB1c2VTdGFibGVPYmplY3QgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGF0ZVwiO1xuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+KHI6IFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88RT4sIC4uLm90aGVyUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W10pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltdIHtcbiAgICByZXR1cm4gW3Iuc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm4ucHJvcHNVbnN0YWJsZSwgLi4ub3RoZXJQcm9wc107XG59Ki9cblxuLypcbmV4cG9ydCBpbnRlcmZhY2UgVXNlU2luZ2xlU2VsZWN0aW9uQ29udGV4dCB7XG4gICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuOiBVc2VTaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mb1tcInNpbmdsZVNlbGVjdGlvblJldHVyblwiXTtcbn0qL1xuXG4vKiogQW55dGhpbmcgdGhhdCdzIHNlbGVjdGFibGUgbXVzdCBiZSB0YWJiYWJsZSwgc28gd2UgRE8gdXNlIHJvdmluZ3RhYmluZGV4IGluc3RlYWQgb2YganVzdCBtYW5hZ2VkY2hpbGRyZW4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0YWJsZUNoaWxkSW5mbzxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbzxFPiB7XG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW47XG4gICAgZ2V0U2VsZWN0ZWQoKTogYm9vbGVhbjtcbiAgICBzZXRMb2NhbFNlbGVjdGVkKHNlbGVjdGVkOiBib29sZWFuKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgc2ltaWxhciB0byBgaGlkZGVuYCBmb3IgYHVzZVJvdmluZ1RhYkluZGV4YCwgYnV0IGZvciBzZWxlY3Rpb24uXG4gICAgICogXG4gICAgICogRGlzYWJsZXMgc2VsZWN0aW5nIHRoaXMgY2hpbGQuIEJlaW5nIGBoaWRkZW5gIG11c3QgaW1wbHkgYmVpbmcgYGRpc2FibGVkYCwgYnV0IHlvdSBjYW4gb2YgY291cnNlIGhhdmUgc29tZXRoaW5nIHRoYXQncyBkaXNhYmxlZCAodW5zZWxlY3RhYmxlKSBidXQgbm90IGhpZGRlbiAodW50YWJiYWJsZSkuXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IGJvb2xlYW47XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogUGljazxVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPFNlbGVjdGFibGVDaGlsZEluZm88Q2hpbGRFbGVtZW50Pj5bXCJtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5cIl0sIFwiZ2V0Q2hpbGRyZW5cIj47XG4gICAgcm92aW5nVGFiSW5kZXhSZXR1cm46IFBpY2s8VXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlPENoaWxkRWxlbWVudD5bXCJyb3ZpbmdUYWJJbmRleFJldHVyblwiXSwgXCJzZXRUYWJiYWJsZUluZGV4XCI+XG4gICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyBpbXBlcmF0aXZlLCBhcyBvcHBvc2VkIHRvIGRlY2xhcmF0aXZlLCBcbiAgICAgICAgICogdG8gc2F2ZSBvbiByZS1yZW5kZXJpbmcgdGhlIHBhcmVudCB3aGVuZXZlciB0aGUgc2VsZWN0ZWQgaW5kZXggY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxseVNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7XG4gICAgICAgIC8vc2VsZWN0ZWRJbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIGEgY2hpbGQgaXMgc2VsZWN0ZWQgKHZpYSBhIHByZXNzIG9yIG90aGVyIG1ldGhvZCkuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBgc2luZ2xlU2VsZWN0aW9uUmV0dXJuYCByZXR1cm5zIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBuYW1lIHRoYXQgY2FuIGJlIHBsdWdnZWQgaW4gaGVyZVxuICAgICAgICAgKiB0byBtYWtlIHRoaXMgY29tcG9uZW50IGltcGVyYXRpdmUsIG9yIHlvdSBjYW4gdXNlIGB1c2VFZmZlY3RgIHRvIHNldCBzb21lIHN0YXRlXG4gICAgICAgICAqIG9uIHlvdXIgZW5kIHRoYXQgZG9lcyBzb21ldGhpbmcgZWxzZS5cbiAgICAgICAgICogXG4gICAgICAgICAqIEluIGdlbmVyYWwsIHRoaXMgc2hvdWxkIG9ubHkgYmUgYG51bGxgIHdoZW4gc2luZ2xlIHNlbGVjdGlvbiBpcyBlbnRpcmVseSBkaXNhYmxlZC5cbiAgICAgICAgICogXG4gICAgICAgICAqIEluIGFueSBjYXNlLCAqKk1VU1QqKiBiZSBzdGFibGUhIVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U2VsZWN0ZWRJbmRleDogbnVsbCB8IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbCwgRXZlbnQ+O1xuXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIC8vbWFuYWdlZENoaWxkUGFyYW1ldGVyczogUGljazxVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPFNlbGVjdGFibGVDaGlsZEluZm88RT4sIG5ldmVyPltcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIl0sIFwiaW5kZXhcIiB8IFwiZGlzYWJsZWRcIj47XG4gICAgc2luZ2xlU2VsZWN0aW9uQ29udGV4dDogVXNlU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZTxFPltcInNpbmdsZVNlbGVjdGlvbkNvbnRleHRcIl07XG4gICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7XG4gICAgICAgIHNlbGVjdGlvbk1vZGU6IFwiZm9jdXNcIiB8IFwiYWN0aXZhdGlvblwiIHwgXCJkaXNhYmxlZFwiO1xuICAgICAgICBhcmlhUHJvcE5hbWU6IGBhcmlhLSR7XCJwcmVzc2VkXCIgfCBcInNlbGVjdGVkXCIgfCBcImNoZWNrZWRcIn1gIHwgbnVsbDtcbiAgICB9ICYgUGljazxTZWxlY3RhYmxlQ2hpbGRJbmZvPEU+LCBcImRpc2FibGVkXCI+O1xuICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IFBpY2s8U2VsZWN0YWJsZUNoaWxkSW5mbzxFPiwgXCJpbmRleFwiPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFJldHVyblR5cGU8RT4ge1xuICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuOiB7XG4gICAgICAgIC8vIFRoZXNlIHR3byBhcmUgYWxyZWFkeSBhdmFpbGFibGUgYXMgbWFuYWdlZENoaWxkIGluZm8sXG4gICAgICAgIC8vIGJ1dCB3ZSdyZSBrZWVwaW5nIHRoZW0gYmVjYXVzZSBSVEkgZG9lcyB0aGUgc2FtZSB0aGluZywgYW5kIGl0J3MgY29udmVuaWVudC5cbiAgICAgICAgc2VsZWN0ZWQ6IGJvb2xlYW4sXG4gICAgICAgIGdldFNlbGVjdGVkKCk6IGJvb2xlYW47XG4gICAgICAgIC8vIFVzZWQgdG8gcHJvZ3JhbW1hdGljYWxseSBzZXQgdGhpcyBhcyB0aGUgc2VsZWN0ZWQgZWxlbWVudDtcbiAgICAgICAgLy8gaXQgcmVxdWVzdHMgdGhlIHBhcmVudCB0byBhY3R1YWxseSBjaGFuZ2UgdGhlIG51bWVyaWMgaW5kZXggdG8gdGhpcyBvbmUncy5cbiAgICAgICAgc2V0VGhpc09uZVNlbGVjdGVkOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkO1xuICAgICAgICBwcm9wc1Vuc3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbiAgICB9XG4gICAgLy9yZWZFbGVtZW50UGFyYW1ldGVyczogUmVxdWlyZWQ8UGljazxVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxFPltcInJlZkVsZW1lbnRQYXJhbWV0ZXJzXCJdLCBcIm9uRWxlbWVudENoYW5nZVwiPj47XG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogUGljazxTZWxlY3RhYmxlQ2hpbGRJbmZvPEU+LCBcInNldExvY2FsU2VsZWN0ZWRcIj47XG4gICAgLy9tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBQaWNrPFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8U2VsZWN0YWJsZUNoaWxkSW5mbzxFPiwgbmV2ZXI+W1wibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiXSwgXCJzZWxlY3RlZFwiIHwgXCJzZXRTZWxlY3RlZFwiIHwgXCJnZXRTZWxlY3RlZFwiPjtcbiAgICBwcmVzc1BhcmFtZXRlcnM6IFBpY2s8VXNlUHJlc3NQYXJhbWV0ZXJzPEU+W1wicHJlc3NQYXJhbWV0ZXJzXCJdLCBcIm9uUHJlc3NTeW5jXCI+O1xufVxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88RT4ge31cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm46IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludGVybmFsbHkgdXBkYXRlcyB0aGUgc2VsZWN0ZWQgaW5kZXggdG8gdGhlIG9uZSB5b3UgcHJvdmlkZSxcbiAgICAgICAgICogYW5kIHRlbGxzIHRoZSByZWxldmFudCBjaGlsZHJlbiB0aGF0IHRoZXkgYXJlL2FyZSBub3Qgc2VsZWN0ZWQuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBJZiB5b3UgYXJlIGNyZWF0aW5nIGFuIGltcGVyYXRpdmUgY29tcG9uZW50LCB0aGlzIGlzIHdoYXQgaG93IHlvdSBjYW4gZm9yY2UgdGhlIHZhbHVlIHRvIGNoYW5nZSBpbiByZXNwb25zZSB0byBzb21ldGhpbmcuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBJZiB5b3UgYXJlIGNyZWF0aW5nIGEgZGVjbGFyYXRpdmUgY29tcG9uZW50LCB0aGlzIGlzIHdoYXQgeW91IGNhbGwgaW4gYHVzZUVmZmVjdGAgd2hlbiB5b3VyIGBzZWxlY3RlZEluZGV4YCBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0U2VsZWN0ZWRJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsLCBFdmVudD47XG4gICAgICAgIGdldFNlbGVjdGVkSW5kZXgoKTogbnVtYmVyIHwgbnVsbDtcbiAgICB9XG4gICAgc2luZ2xlU2VsZWN0aW9uQ29udGV4dDogeyBzZXRTZWxlY3RlZEluZGV4OiBQYXNzaXZlU3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGwsIEV2ZW50PiB8IG51bGw7IGdldFNlbGVjdGVkSW5kZXgoKTogbnVtYmVyIHwgbnVsbDsgfVxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyczogUGljazxVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcImNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyc1wiXSwgXCJvbkNvbXBvc2l0ZUZvY3VzQ2hhbmdlXCI+XG59XG5cblxuXG4vL2V4cG9ydCB0eXBlIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChhOiBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8RT4pID0+IFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxFPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNpbmdsZVNlbGVjdGlvbjxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH0sXG4gICAgcm92aW5nVGFiSW5kZXhSZXR1cm46IHsgc2V0VGFiYmFibGVJbmRleCB9LFxuICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IHsgc2V0U2VsZWN0ZWRJbmRleDogc2V0U2VsZWN0ZWRJbmRleEV4dGVybmFsLCBpbml0aWFsbHlTZWxlY3RlZEluZGV4IH1cbn06IFVzZVNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50Pik6IFVzZVNpbmdsZVNlbGVjdGlvblJldHVyblR5cGU8Q2hpbGRFbGVtZW50PiB7XG4gICAgdHlwZSBSID0gRXZlbnQ7Ly9oLkpTWC5UYXJnZXRlZEV2ZW50PENoaWxkRWxlbWVudD47XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlU2luZ2xlU2VsZWN0aW9uXCIsIHNldFNlbGVjdGVkSW5kZXhFeHRlcm5hbCk7XG5cbiAgICBjb25zdCBnZXRTZWxlY3RlZEF0ID0gdXNlQ2FsbGJhY2soKG06IFNlbGVjdGFibGVDaGlsZEluZm88Q2hpbGRFbGVtZW50PikgPT4geyByZXR1cm4gbS5nZXRTZWxlY3RlZCgpOyB9LCBbXSk7XG4gICAgY29uc3Qgc2V0U2VsZWN0ZWRBdCA9IHVzZUNhbGxiYWNrKChtOiBTZWxlY3RhYmxlQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4sIHQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgaWYgKG0uaGlkZGVuKSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgbS5zZXRMb2NhbFNlbGVjdGVkKHQpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBpc1NlbGVjdGVkVmFsaWQgPSB1c2VDYWxsYmFjaygobTogU2VsZWN0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+KSA9PiB7IHJldHVybiAhbS5oaWRkZW47IH0sIFtdKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgY2hhbmdlSW5kZXg6IHNldFNlbGVjdGVkSW5kZXhJbnRlcm5hbCxcbiAgICAgICAgZ2V0Q3VycmVudEluZGV4OiBnZXRTZWxlY3RlZEluZGV4XG4gICAgfSA9IHVzZUNoaWxkcmVuRmxhZzxTZWxlY3RhYmxlQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4sIFI+KHtcbiAgICAgICAgZ2V0Q2hpbGRyZW4sXG4gICAgICAgIG9uSW5kZXhDaGFuZ2U6IG51bGwsXG4gICAgICAgIGluaXRpYWxJbmRleDogaW5pdGlhbGx5U2VsZWN0ZWRJbmRleCxcbiAgICAgICAgZ2V0QXQ6IGdldFNlbGVjdGVkQXQsXG4gICAgICAgIHNldEF0OiBzZXRTZWxlY3RlZEF0LFxuICAgICAgICBpc1ZhbGlkOiBpc1NlbGVjdGVkVmFsaWQsXG4gICAgICAgIGNsb3Nlc3RGaXQ6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuOiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgZ2V0U2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXg6IHNldFNlbGVjdGVkSW5kZXhJbnRlcm5hbFxuICAgICAgICB9KSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgIGdldFNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4OiBzZXRTZWxlY3RlZEluZGV4RXh0ZXJuYWxcbiAgICAgICAgfSksXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25Db21wb3NpdGVGb2N1c0NoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2soKGFueUZvY3VzZWQsIHByZXYsIHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghYW55Rm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gZ2V0U2VsZWN0ZWRJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChzZWxlY3RlZEluZGV4LCByZWFzb24sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PihhcmdzOiBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50Pik6IFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+IHtcbiAgICB0eXBlIFIgPSBFdmVudDsvL2guSlNYLlRhcmdldGVkRXZlbnQ8Q2hpbGRFbGVtZW50PjtcbiAgICBjb25zdCB7XG5cbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ29udGV4dDogeyBnZXRTZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4OiBzZXRTZWxlY3RlZEluZGV4RXh0ZXJuYWwgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IGFyaWFQcm9wTmFtZSwgc2VsZWN0aW9uTW9kZSwgZGlzYWJsZWQgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9XG4gICAgfSA9IGFyZ3M7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VTaW5nbGVTZWxlY3Rpb25DaGlsZFwiLCBnZXRTZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4RXh0ZXJuYWwpO1xuICAgIGNvbnN0IGdldERpc2FibGVkID0gdXNlU3RhYmxlR2V0dGVyKGRpc2FibGVkKTtcblxuICAgIGNvbnN0IFtzZWxlY3RlZCwgc2V0U2VsZWN0ZWQsIGdldFNlbGVjdGVkXSA9IHVzZVN0YXRlKGdldFNlbGVjdGVkSW5kZXgoKSA9PSBpbmRleCk7XG5cbiAgIC8vIGNvbnN0IGdldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZGV4KTtcblxuICAgIGNvbnN0IG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQgPSB1c2VTdGFibGVDYWxsYmFjazxPblBhc3NpdmVTdGF0ZUNoYW5nZTxib29sZWFuLCBSPj4oKGZvY3VzZWQsIF9wcmV2LCBlKSA9PiB7XG4gICAgICAgIGlmIChzZWxlY3Rpb25Nb2RlID09ICdmb2N1cycgJiYgZm9jdXNlZCkge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRJbmRleEV4dGVybmFsPy4oaW5kZXgsIGUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBvblByZXNzU3luYyA9IHVzZVN0YWJsZUNhbGxiYWNrKCgoZTogRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFkaXNhYmxlZClcbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXhFeHRlcm5hbD8uKGluZGV4LCBlIGFzIFIpO1xuICAgIH0pKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8vbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBzZWxlY3RlZCwgc2V0U2VsZWN0ZWQsIGdldFNlbGVjdGVkLCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IHNldExvY2FsU2VsZWN0ZWQ6IHNldFNlbGVjdGVkIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuOiB7XG4gICAgICAgICAgICBzZWxlY3RlZCxcbiAgICAgICAgICAgIHNldFRoaXNPbmVTZWxlY3RlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoIWdldERpc2FibGVkKCkpO1xuICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXhFeHRlcm5hbD8uKGluZGV4LCBldmVudCBhcyBSKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ2V0U2VsZWN0ZWQsXG4gICAgICAgICAgICBwcm9wc1Vuc3RhYmxlOiBhcmlhUHJvcE5hbWUgPT0gbnVsbCA/IHt9IDogeyBbYXJpYVByb3BOYW1lIGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT5dOiAoc2VsZWN0ZWQgPz8gZmFsc2UpLnRvU3RyaW5nKCkgfVxuICAgICAgICB9LFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgb25QcmVzc1N5bmMgfSxcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczogeyBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkIH1cbiAgICB9XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlUGFyYW1ldGVycyB7XG4gICAgc2luZ2xlU2VsZWN0aW9uRGVjbGFyYXRpdmVQYXJhbWV0ZXJzOiB7IHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGwgfVxuICAgIHNpbmdsZVNlbGVjdGlvblJldHVybjogUGljazxVc2VTaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlPGFueT5bXCJzaW5nbGVTZWxlY3Rpb25SZXR1cm5cIl0sIFwic2V0U2VsZWN0ZWRJbmRleFwiPjtcbn1cblxuZXhwb3J0IHR5cGUgTWFrZVNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlUGFyYW1ldGVyczxQPiA9IE9taXQ8UCwgXCJzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzXCI+ICYgVXNlU2luZ2xlU2VsZWN0aW9uRGVjbGFyYXRpdmVQYXJhbWV0ZXJzO1xuZXhwb3J0IHR5cGUgTWFrZVNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlUmV0dXJuVHlwZTxSPiA9IE9taXQ8UiwgXCJzaW5nbGVTZWxlY3Rpb25SZXR1cm5cIj47XG5cbi8qKlxuICogTGV0J3MgZmFjZSBpdCwgZGVjbGFyYXRpdmUgaXMgbmljZXIgdG8gdXNlIHRoYW4gaW1wZXJhdGl2ZSwgc28gdGhpcyBpcyBhIHNob3J0Y3V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU2luZ2xlU2VsZWN0aW9uRGVjbGFyYXRpdmUoeyBzaW5nbGVTZWxlY3Rpb25SZXR1cm46IHsgc2V0U2VsZWN0ZWRJbmRleDogc2V0U2VsZWN0ZWRJbmRleEludGVybmFsIH0sIHNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlUGFyYW1ldGVyczogeyBzZWxlY3RlZEluZGV4IH0gfTogVXNlU2luZ2xlU2VsZWN0aW9uRGVjbGFyYXRpdmVQYXJhbWV0ZXJzKSB7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0U2VsZWN0ZWRJbmRleEludGVybmFsKHNlbGVjdGVkSW5kZXgpO1xuICAgIH0sIFtzZWxlY3RlZEluZGV4XSk7XG59XG5cblxuIiwiaW1wb3J0IHsgR3JpZENoaWxkQ2VsbEluZm8gYXMgZ2NjaSwgR3JpZENoaWxkUm93SW5mbyBhcyBnY3JpLCB1c2VHcmlkTmF2aWdhdGlvbiwgdXNlR3JpZE5hdmlnYXRpb25DZWxsLCBVc2VHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzLCBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlLCBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZSwgdXNlR3JpZE5hdmlnYXRpb25Sb3csIFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWdyaWQtbmF2aWdhdGlvbi1wYXJ0aWFsXCI7XG5pbXBvcnQgeyBTZWxlY3RhYmxlQ2hpbGRJbmZvLCB1c2VTaW5nbGVTZWxlY3Rpb24sIHVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkLCBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZSwgVXNlU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycywgVXNlU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1zaW5nbGUtc2VsZWN0aW9uXCI7XG5pbXBvcnQgeyBhc3NlcnRFbXB0eU9iamVjdCB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG4vKipcbiAqIExpc3QgbmF2aWdhdGlvbiBnZXRzIHNpbmdsZSBzZWxlY3Rpb24sIHNvIGdyaWQgbmF2aWdhdGlvbiBkb2VzIHRvby5cbiAqIFxuICogQW55IGdpdmVuIHJvdyBvZiB0aGUgZ3JpZCBjYW4gYmUgc2VsZWN0ZWQsIGFraW4gdG8gaXQgYmVpbmcgYSBzaW5nbGUgc2VsZWN0IGxpc3QgYnV0IHdpdGggb3B0aW9ucyB0aGF0IGNhbiBiZSBsZWZ0L3JpZ2h0IGFycm93ZWQgdG8uXG4gKiBcbiAqIEhpZ2hseSByZWNvbW1lbmRlZCB0byBtYWtlIHRoZSBgc2VsZWN0aW9uTW9kZWAgKm5vdCogYmUgYFwiZm9jdXNcImAsIGJ1dCBpdCdzIHVwIHRvIHlvdSwgdWx0aW1hdGVseS5cbiAqL1xuY29uc3QgX2R1bW15ID0gMDtcblxuZXhwb3J0IGludGVyZmFjZSBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgZ2NyaTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFNlbGVjdGFibGVDaGlsZEluZm88Um93RWxlbWVudD4geyB9XG5leHBvcnQgaW50ZXJmYWNlIEdyaWRTaW5nbGVTZWxlY3RDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBnY2NpPENlbGxFbGVtZW50PiB7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50Pj4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgTT4sIE9taXQ8VXNlU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxSb3dFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFJldHVyblwiPiB7XG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgTT5bXCJtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5cIl0gJiBVc2VTaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFJvd0VsZW1lbnQ+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdO1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGU8UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4sIFVzZVNpbmdsZVNlbGVjdGlvblJldHVyblR5cGU8Um93RWxlbWVudD4ge1xuICAgIC8vIGdyaWROYXZpZ2F0aW9uUm93Q29udGV4dDogVXNlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIGFueSwgYW55LCBhbnk+W1wiYXNDaGlsZFJvd1BhcmFtZXRlcnNcIl1bXCJncmlkTmF2aWdhdGlvblJvd0NvbnRleHRcIl1cbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Sb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIF9STSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50Pj4ge1xuICAgIGFzQ2hpbGRSb3dQYXJhbWV0ZXJzOiBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIF9STSwgQ00+W1wiYXNDaGlsZFJvd1BhcmFtZXRlcnNcIl0gJiBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Um93RWxlbWVudD47XG4gICAgYXNQYXJlbnRSb3dQYXJhbWV0ZXJzOiBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIF9STSwgQ00+W1wiYXNQYXJlbnRSb3dQYXJhbWV0ZXJzXCJdO1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Sb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBhc0NoaWxkUm93UmV0dXJuOiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+W1wiYXNDaGlsZFJvd1JldHVyblwiXSAmIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZTxSb3dFbGVtZW50PjtcbiAgICBhc1BhcmVudFJvd1JldHVybjogVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PltcImFzUGFyZW50Um93UmV0dXJuXCJdXG59XG5cblxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNlbGxQYXJhbWV0ZXJzPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQ+IHsgfVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+KHtcbiAgICBncmlkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLFxuICAgIC4uLl92b2lkMlxufTogVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPik6IFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZTxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+IHtcbiAgICBjb25zdCBnbnIgPSB1c2VHcmlkTmF2aWdhdGlvbjxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+KHtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHJvdmluZ1RhYkluZGV4UmV0dXJuIH0gPSBnbnI7XG5cbiAgICBjb25zdCBzc3IgPSB1c2VTaW5nbGVTZWxlY3Rpb248Um93RWxlbWVudD4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzXG4gICAgfSk7XG5cbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDIpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZ25yLFxuICAgICAgICAuLi5zc3IsXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Sb3c8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+KHtcbiAgICBhc0NoaWxkUm93UGFyYW1ldGVycyxcbiAgICBhc1BhcmVudFJvd1BhcmFtZXRlcnMsXG4gICAgLi4uX3ZvaWQxXG59OiBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4pOiBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHtcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogb2NmaWMyLCAuLi5fdm9pZDMgfSwgcHJlc3NQYXJhbWV0ZXJzLCBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVybiB9ID0gdXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Um93RWxlbWVudD4oYXNDaGlsZFJvd1BhcmFtZXRlcnMpO1xuICAgIGNvbnN0IHsgYXNDaGlsZFJvd1JldHVybjogeyBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7IG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IG9jZmljMSwgLi4uX3ZvaWQyIH0sIGdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycywgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybiwgdGV4dENvbnRlbnRSZXR1cm4sIC4uLnZvaWQ0IH0sIGFzUGFyZW50Um93UmV0dXJuIH0gPSB1c2VHcmlkTmF2aWdhdGlvblJvdzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPih7IGFzQ2hpbGRSb3dQYXJhbWV0ZXJzLCBhc1BhcmVudFJvd1BhcmFtZXRlcnMgfSk7XG4gICAgY29uc3Qgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZCA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvY2ZpYzI+PigoZm9jdXNlZCwgcHJldkZvY3VzZWQsIGUpID0+IHsgb2NmaWMxPy4oZm9jdXNlZCwgcHJldkZvY3VzZWQsIGUpOyBvY2ZpYzI/Lihmb2N1c2VkLCBwcmV2Rm9jdXNlZCwgZSk7IH0pXG5cbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDEpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMik7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QoX3ZvaWQzKTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkNCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhc0NoaWxkUm93UmV0dXJuOiB7IFxuICAgICAgICAgICAgdGV4dENvbnRlbnRSZXR1cm4sXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCBcbiAgICAgICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZCB9LCBcbiAgICAgICAgICAgIGdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycywgXG4gICAgICAgICAgICBwcmVzc1BhcmFtZXRlcnMsIFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybiwgXG4gICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblxuICAgICAgICAgfSxcbiAgICAgICAgYXNQYXJlbnRSb3dSZXR1cm5cbiAgICB9XG5cbn1cblxuLy8gRVpcbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNlbGw8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PihwOiBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNlbGxQYXJhbWV0ZXJzPGFueSwgQ2VsbEVsZW1lbnQ+KTogVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DZWxsUmV0dXJuVHlwZTxDZWxsRWxlbWVudD4ge1xuICAgIHJldHVybiB1c2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbEVsZW1lbnQ+KHApO1xufSIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5QXJyYXk7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVJhbmRvbTtcbiIsImltcG9ydCBiYXNlUmFuZG9tIGZyb20gJy4vX2Jhc2VSYW5kb20uanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICB9XG4gIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2h1ZmZsZVNlbGY7XG4iLCJpbXBvcnQgY29weUFycmF5IGZyb20gJy4vX2NvcHlBcnJheS5qcyc7XG5pbXBvcnQgc2h1ZmZsZVNlbGYgZnJvbSAnLi9fc2h1ZmZsZVNlbGYuanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVNodWZmbGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVmFsdWVzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRpbWVzO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuZXhwb3J0IGRlZmF1bHQgZnJlZUdsb2JhbDtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJvb3Q7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbmV4cG9ydCBkZWZhdWx0IFN5bWJvbDtcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBnZXRSYXdUYWc7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb2JqZWN0VG9TdHJpbmc7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5pbXBvcnQgZ2V0UmF3VGFnIGZyb20gJy4vX2dldFJhd1RhZy5qcyc7XG5pbXBvcnQgb2JqZWN0VG9TdHJpbmcgZnJvbSAnLi9fb2JqZWN0VG9TdHJpbmcuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUdldFRhZztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdExpa2U7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNBcmd1bWVudHM7XG4iLCJpbXBvcnQgYmFzZUlzQXJndW1lbnRzIGZyb20gJy4vX2Jhc2VJc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuaW1wb3J0IHN0dWJGYWxzZSBmcm9tICcuL3N0dWJGYWxzZS5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCdWZmZXI7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSW5kZXg7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5hcnk7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcbiIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcbiIsImltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlcztcbiIsImltcG9ydCBzaHVmZmxlU2VsZiBmcm9tICcuL19zaHVmZmxlU2VsZi5qcyc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJy4vdmFsdWVzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2h1ZmZsZTtcbiIsImltcG9ydCBhcnJheVNodWZmbGUgZnJvbSAnLi9fYXJyYXlTaHVmZmxlLmpzJztcbmltcG9ydCBiYXNlU2h1ZmZsZSBmcm9tICcuL19iYXNlU2h1ZmZsZS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICovXG5mdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaHVmZmxlO1xuIiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsLCB3aGVuIGNhbGxlZCwgZm9yY2UgdGhlIGNvbXBvbmVudFxuICogdGhhdCB1c2VzIHRoaXMgaG9vayB0byByZS1yZW5kZXIgaXRzZWxmLlxuICogXG4gKiBJdCdzIGEgYml0IHNtZWxseSwgc28gYmVzdCB0byB1c2Ugc3BhcmluZ2x5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gICAgY29uc3QgWywgc2V0XSA9IHVzZVN0YXRlKDApO1xuICAgIHJldHVybiB1c2VSZWYoKCkgPT4gc2V0KGkgPT4gKytpKSkuY3VycmVudDtcbn0iLCJpbXBvcnQgbG9kYXNoU2h1ZmZsZSBmcm9tIFwibG9kYXNoLWVzL3NodWZmbGVcIjtcbmltcG9ydCB7IGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgTXV0YWJsZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi4vZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkSW5mbywgTWFuYWdlZENoaWxkcmVuIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VGb3JjZVVwZGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtZm9yY2UtdXBkYXRlXCI7XG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5leHBvcnQgdHlwZSBHZXRJbmRleDxQPiA9IChyb3c6IFZOb2RlPFA+KSA9PiAobnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCk7XG5leHBvcnQgdHlwZSBHZXRWYWxpZCA9IChpbmRleDogbnVtYmVyKSA9PiBib29sZWFuO1xuZXhwb3J0IHR5cGUgR2V0SGlnaGVzdENoaWxkSW5kZXggPSAoKSA9PiBudW1iZXI7XG5leHBvcnQgdHlwZSBDb21wYXJlPE0gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlcj4+ID0gKGxoczogTSwgcmhzOiBNKSA9PiBudW1iZXI7XG5cbi8qKlxuICogQWxsIG9mIHRoZXNlIGZ1bmN0aW9ucyAqKk1VU1QqKiBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyB7XG5cbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiwgZS5nLiwgdGhlIHJvdyBpbmRleCBvZiB0aGlzIGNoaWxkXG4gICAgICogKFVzdWFsbHkganVzdCBhbiBgaW5kZXhgIHByb3ApXG4gICAgICovXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtdXN0IHJldHVybiB0aGUgaW5kZXggb2YgdGhpcyBjaGlsZCByZWxhdGl2ZSB0byBhbGwgaXRzIHNvcnRhYmxlIHNpYmxpbmdzLlxuICAgICAgICAgKiBcbiAgICAgICAgICogSW4gZ2VuZXJhbCwgdGhpcyBjb3JyZXNwb25kcyB0byB0aGUgYGluZGV4YCBwcm9wLCBzbyBzb21ldGhpbmcgbGlrZSBgdm5vZGUgPT4gdm5vZGUucHJvcHMuaW5kZXhgIGlzIHdoYXQgeW91J3JlIHVzdWFsbHkgbG9va2luZyBmb3IuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRJbmRleDogR2V0SW5kZXg8YW55PjtcblxuICAgICAgICAvKiogXG4gICAgICAgICAqIFVzaW5nIHJlYXJyYW5nZWFibGUgY2hpbGRyZW4gbWVhbnMgd2UgbmVlZCB0byBiZSBhYmxlIHRvIG92ZXJyaWRlIGFycm93IGtleSBuYXZpZ2F0aW9uLFxuICAgICAgICAgKiB3aGljaCBhbHNvIG1lYW5zIHRoYXQsIHNvbWV3aGVyZSBkb3duIHRoZSByb2FkLCB3ZSBuZWVkIHRvIGtub3cgd2hpY2ggY2hpbGRyZW4gYXJlIGFycm93LWtleS1hYmxlLFxuICAgICAgICAgKiBqdXN0IGxpa2UgaW4gbm9ybWFsIGxpbmVhciBuYXZpZ2F0aW9uLlxuICAgICAgICAgKiBcbiAgICAgICAgICogXG4gICAgICAgICAqIFBTWUNIRSEhIExpbmVhck5hdmlnYXRpb24gc2hvdWxkIGJlIHRoZSBvbmUgdG8gZGVhbCB3aXRoIGluZGV4IG1hbmdsZXJzIGFuZCBkZW1hbmdsZXJzLCBhbmQgbm93IGl0IGRvZXMuXG4gICAgICAgICAqL1xuICAgICAgICAvL2dldFZhbGlkOiBHZXRWYWxpZDtcbiAgICAgICAgLy8gZ2V0SGlnaGVzdENoaWxkSW5kZXg6IEdldEhpZ2hlc3RDaGlsZEluZGV4O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBbGwgb2YgdGhlc2UgZnVuY3Rpb25zICoqTVVTVCoqIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczxNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXI+PiBleHRlbmRzIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnMge1xuICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyBob3cgdmFsdWVzIGNvbXBhcmUgYWdhaW5zdCBlYWNoIG90aGVyIHdoZW4gYHNvcnRgIGlzIGNhbGxlZC5cbiAgICAgICAgICogXG4gICAgICAgICAqIElmIG51bGwsIGEgZGVmYXVsdCBzb3J0IGlzIHVzZWQgdGhhdCBhc3N1bWVzIGBnZXRTb3J0VmFsdWVgIHJldHVybnMgYSB2YWx1ZSB0aGF0IHdvcmtzIHdlbGwgd2l0aCB0aGUgYC1gIG9wZXJhdG9yIChzbywgbGlrZSwgYSBudW1iZXIsIHN0cmluZywgYERhdGVgLCBgbnVsbGAsIGV0Yy4pXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAcGFyYW0gbGhzIFxuICAgICAgICAgKiBAcGFyYW0gcmhzIFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcGFyZTogbnVsbCB8IENvbXBhcmU8TT47XG4gICAgfVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIE1hbmFnZWRDaGlsZEluZm88bnVtYmVyPj4ge1xuICAgIC8vbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IFBpY2s8VXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNbXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJuYXZpZ2F0ZVJlbGF0aXZlXCIgfCBcIm5hdmlnYXRlQWJzb2x1dGVcIj47XG5cbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm46IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFzcyBhbiBhcnJheSBvZiBub3Qtc29ydGVkIGNoaWxkIGluZm9ybWF0aW9uIHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICogYW5kIHRoZSBjaGlsZHJlbiB3aWxsIHJlLWFycmFuZ2UgdGhlbXNlbHZlcyB0byBtYXRjaC5cbiAgICAgICAgICogIFxuICAgICAgICAgKiAqKlNUQUJMRSoqXG4gICAgICAgICAqICBcbiAgICAgICAgICogXG4gICAgICAgICAqL1xuICAgICAgICByZWFycmFuZ2U6IChyb3dzSW5PcmRlcjogTVtdKSA9PiB2b2lkO1xuXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNodWZmbGU6IChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPE0+KSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcblxuICAgICAgICAvKiogXG4gICAgICAgICAqICoqU1RBQkxFKipcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGNvbXBvbmVudCdzIG9yaWdpbmFsIGBpbmRleGAgcHJvcCBhbmQgb3V0cHV0cyBhIG5ldyBpbmRleCB0aGF0IHJlcHJlc2VudHMgaXRzIHJlLWFycmFuZ2VkIHBvc2l0aW9uLlxuICAgICAgICAgKiBJbiBjb25qdW5jdGlvbiB3aXRoIGBpbmRleERlbWFuZ2xlcmAsIHRoaXMgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBtYXRoIG9uIGluZGljZXMgKGluY3JlbWVudGluZywgZGVjcmVtZW50aW5nLCBldGMuKVxuICAgICAgICAgKiAgXG4gICAgICAgICAqIEUuRy4gdG8gZGVjcmVtZW50IGEgY29tcG9uZW50J3MgaW5kZXggXCJjXCI6IGluZGV4RGVtYW5nbGVyKGluZGV4TWFuZ2xlcihjKSAtIDEpXG4gICAgICAgICAqL1xuICAgICAgICBpbmRleE1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgbWFuZ2xlTWFwOiBNdXRhYmxlUmVmPE1hcDxudW1iZXIsIG51bWJlcj4+O1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBkZW1hbmdsZU1hcDogTXV0YWJsZVJlZjxNYXA8bnVtYmVyLCBudW1iZXI+PjtcblxuICAgICAgICAvKiogXG4gICAgICAgICAqICoqU1RBQkxFKipcbiAgICAgICAgICogXG4gICAgICAgICAqIENhbGwgdGhpcyBvbiB5b3VyIHByb3BzICh0aGF0IGNvbnRhaW4gdGhlIGNoaWxkcmVuIHRvIHNvcnQhISkgdG8gYWxsb3cgdGhlbSB0byBiZSBzb3J0YWJsZS5cbiAgICAgICAgICogXG4gICAgICAgICAqL1xuICAgICAgICB1c2VSZWFycmFuZ2VhYmxlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+O1xuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXI+PiBleHRlbmRzIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGU8UGFyZW50RWxlbWVudCwgTT4ge1xuICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm46IHtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgc29ydDogKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48TT4sIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVDaGlsZEluZm8gZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlcj4ge1xuICAgIGdldFNvcnRWYWx1ZSgpOiB1bmtub3duO1xufVxuXG5cbi8qKlxuICogSG9vayB0aGF0IGFsbG93cyBmb3IgdGhlICoqZGlyZWN0IGRlc2NlbmRhbnQqKiBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCB0byBiZSByZS1vcmRlcmVkIGFuZCBzb3J0ZWQuXG4gKiBcbiAqICpUaGlzIGlzICoqc2VwYXJhdGUqKiBmcm9tIFwibWFuYWdlZFwiIGNoaWxkcmVuLCB3aGljaCBjYW4gYmUgYW55IGxldmVsIG9mIGNoaWxkIG5lZWRlZCEgU29ydGFibGUvcmVhcnJhbmdlYWJsZSBjaGlsZHJlbiBtdXN0IGJlICoqZGlyZWN0IGRlc2NlbmRhbnRzKiogb2YgdGhlIHBhcmVudCB0aGF0IHVzZXMgdGhpcyBob29rISpcbiAqIFxuICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBpbiBjb25qdW5jdGlvbiB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbmA7IGl0IHRha2VzIHRoZSBzYW1lIGBpbmRleE1hbmdsZXJgIGFuZCBgaW5kZXhEZW1hbmdsZXJgIFxuICogZnVuY3Rpb25zIHRoYXQgdGhpcyBob29rIHJldHVybnMuIGB1c2VMaXN0TmF2aWdhdGlvbmAgZG9lcyBub3QgZGlyZWN0bHkgdXNlIHRoaXMgaG9vayBiZWNhdXNlLCBhcyBtZW50aW9uZWQsIFxuICogdGhpcyBob29rIGltcG9zZXMgc2VyaW91cyByZXN0cmljdGlvbnMgb24gY2hpbGQgc3RydWN0dXJlLCB3aGlsZSBgdXNlTGlzdE5hdmlnYXRpb25gIGFsbG93cyBhbnl0aGluZy5cbiAqIFxuICogQmVzaWRlcyB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayB0aGF0J3MgcmV0dXJuZWQsIHRoZSBgc29ydGAgZnVuY3Rpb24gdGhhdCdzIHJldHVybmVkIHdpbGxcbiAqIHNvcnQgYWxsIGNoaWxkcmVuIGFjY29yZGluZyB0byB0aGVpciB2YWx1ZSBmcm9tIHRoZSBgZ2V0VmFsdWVgIGFyZ3VtZW50IHlvdSBwYXNzIGluLlxuICogXG4gKiBJZiB5b3Ugd2FudCB0byBwZXJmb3JtIHNvbWUgcmUtb3JkZXJpbmcgb3BlcmF0aW9uIHRoYXQncyAqbm90KiBhIHNvcnQsIHlvdSBjYW4gbWFudWFsbHlcbiAqIHJlLW1hcCBlYWNoIGNoaWxkJ3MgcG9zaXRpb24gdXNpbmcgYG1hbmdsZU1hcGAgYW5kIGBkZW1hbmdsZU1hcGAsIHdoaWNoIGNvbnZlcnQgYmV0d2VlblxuICogc29ydGVkIGFuZCB1bnNvcnRlZCBpbmRleCBwb3NpdGlvbnMuXG4gKiBcbiAqIEFnYWluLCB1bmxpa2Ugc29tZSBvdGhlciBob29rcywgKip0aGVzZSBjaGlsZHJlbiBtdXN0IGJlIGRpcmVjdCBkZXNjZW5kYW50cyoqLiBUaGlzIGlzIGJlY2F1c2VcbiAqIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIGluc3BlY3RzIHRoZSBnaXZlbiBjaGlsZHJlbiwgdGhlbiByZS1jcmVhdGVzIHRoZW0gd2l0aCBuZXcgYGtleWBzLlxuICogQmVjYXVzZSBrZXlzIGFyZSBnaXZlbiBzcGVjaWFsIHRyZWF0bWVudCBhbmQgYSBjaGlsZCBoYXMgbm8gd2F5IG9mIG1vZGlmeWluZyBpdHMgb3duIGtleVxuICogdGhlcmUncyBubyBvdGhlciB0aW1lIG9yIHBsYWNlIHRoaXMgY2FuIGhhcHBlbiBvdGhlciB0aGFuIGV4YWN0bHkgd2l0aGluIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlU29ydGFibGVDaGlsZEluZm8+KHtcbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IGdldEluZGV4IH1cbn06IFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnMpOiBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQsIE0+IHtcblxuICAgIC8vIFRoZXNlIGFyZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgYSBtYXBwaW5nIGJldHdlZW4gdW5zb3J0ZWQgaW5kZXggPC0tLT4gc29ydGVkIGluZGV4LlxuICAgIC8vIFRoZXNlIGFyZSBuZWVkZWQgZm9yIG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cy5cbiAgICBjb25zdCBtYW5nbGVNYXAgPSB1c2VSZWYobmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKSk7XG4gICAgY29uc3QgZGVtYW5nbGVNYXAgPSB1c2VSZWYobmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKSk7XG4gICAgY29uc3QgaW5kZXhNYW5nbGVyID0gdXNlQ2FsbGJhY2soKG46IG51bWJlcikgPT4gKG1hbmdsZU1hcC5jdXJyZW50LmdldChuKSA/PyBuKSwgW10pO1xuICAgIGNvbnN0IGluZGV4RGVtYW5nbGVyID0gdXNlQ2FsbGJhY2soKG46IG51bWJlcikgPT4gKGRlbWFuZ2xlTWFwLmN1cnJlbnQuZ2V0KG4pID8/IG4pLCBbXSk7XG4gICAgLy9jb25zdCB7IHNldFRhYmJhYmxlSW5kZXggfSA9IHJvdmluZ1RhYkluZGV4UmV0dXJuO1xuXG5cblxuICAgIGNvbnN0IHNodWZmbGUgPSB1c2VDYWxsYmFjaygobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxNPik6IFByb21pc2U8dm9pZD4gfCB2b2lkID0+IHtcbiAgICAgICAgY29uc3Qgc2h1ZmZsZWRSb3dzID0gbG9kYXNoU2h1ZmZsZShtYW5hZ2VkUm93cy5hcnJheVNsaWNlKCkpXG4gICAgICAgIHJldHVybiByZWFycmFuZ2Uoc2h1ZmZsZWRSb3dzKTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIC8vIFRoZSBzb3J0IGZ1bmN0aW9uIG5lZWRzIHRvIGJlIGFibGUgdG8gdXBkYXRlIHdob2V2ZXIgaGFzIGFsbCB0aGUgc29ydGFibGUgY2hpbGRyZW4uXG4gICAgLy8gQmVjYXVzZSB0aGF0IG1pZ2h0IG5vdCBiZSB0aGUgY29uc3VtZXIgb2YgKnRoaXMqIGhvb2sgZGlyZWN0bHkgKGUuZy4gYSB0YWJsZSB1c2VzXG4gICAgLy8gdGhpcyBob29rLCBidXQgaXQncyB0Ym9keSB0aGF0IGFjdHVhbGx5IG5lZWRzIHVwZGF0aW5nKSwgd2UgbmVlZCB0byByZW1vdGVseVxuICAgIC8vIGdldCBhbmQgc2V0IGEgZm9yY2VVcGRhdGUgZnVuY3Rpb24uXG4gICAgLy9jb25zdCBbZ2V0Rm9yY2VVcGRhdGUsIHNldEZvcmNlVXBkYXRlXSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgKCgpID0+IHZvaWQpPihudWxsLCByZXR1cm5OdWxsKTtcbiAgICBjb25zdCBbZ2V0Rm9yY2VVcGRhdGUsIHNldEZvcmNlVXBkYXRlXSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgKCgpID0+IHZvaWQpLCBuZXZlcj4obnVsbCwgcmV0dXJuTnVsbCk7XG5cbiAgICBjb25zdCByZWFycmFuZ2UgPSB1c2VDYWxsYmFjaygoc29ydGVkUm93czogTVtdKSA9PiB7XG5cbiAgICAgICAgbWFuZ2xlTWFwLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgZGVtYW5nbGVNYXAuY3VycmVudC5jbGVhcigpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBvdXIgc29ydGVkIDwtLT4gdW5zb3J0ZWQgaW5kaWNlcyBtYXAgXG4gICAgICAgIC8vIGFuZCByZXJlbmRlciB0aGUgd2hvbGUgdGFibGUsIGJhc2ljYWxseVxuICAgICAgICBmb3IgKGxldCBpbmRleEFzU29ydGVkID0gMDsgaW5kZXhBc1NvcnRlZCA8IHNvcnRlZFJvd3MubGVuZ3RoOyArK2luZGV4QXNTb3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4QXNVbnNvcnRlZCA9IHNvcnRlZFJvd3NbaW5kZXhBc1NvcnRlZF0uaW5kZXg7XG5cbiAgICAgICAgICAgIG1hbmdsZU1hcC5jdXJyZW50LnNldChpbmRleEFzVW5zb3J0ZWQsIGluZGV4QXNTb3J0ZWQpO1xuICAgICAgICAgICAgZGVtYW5nbGVNYXAuY3VycmVudC5zZXQoaW5kZXhBc1NvcnRlZCwgaW5kZXhBc1Vuc29ydGVkKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgZ2V0Rm9yY2VVcGRhdGUoKT8uKCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgdXNlUmVhcnJhbmdlYWJsZVByb3BzID0gdXNlQ2FsbGJhY2soKHsgY2hpbGRyZW4sIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKTtcblxuICAgICAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHNldEZvcmNlVXBkYXRlKF9wcmV2ID0+IGZvcmNlVXBkYXRlKTsgfSwgW2ZvcmNlVXBkYXRlXSlcblxuICAgICAgICByZXR1cm4gKHVzZU1lcmdlZFByb3BzPFBhcmVudEVsZW1lbnQ+KHtcbiAgICAgICAgICAgIGNoaWxkcmVuOlxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiBhcyBWTm9kZTxhbnk+W10pXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoY2hpbGQgPT4gKHsgY2hpbGQsIG1hbmdsZWRJbmRleDogaW5kZXhNYW5nbGVyKGdldEluZGV4KGNoaWxkKSEpLCBkZW1hbmdsZWRJbmRleDogZ2V0SW5kZXgoY2hpbGQpIH0pKVxuICAgICAgICAgICAgICAgICAgICAuc29ydCgobGhzLCByaHMpID0+IHsgcmV0dXJuIGxocy5tYW5nbGVkSW5kZXggLSByaHMubWFuZ2xlZEluZGV4IH0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHsgY2hpbGQsIG1hbmdsZWRJbmRleCwgZGVtYW5nbGVkSW5kZXggfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgoY2hpbGQudHlwZSBhcyBhbnksIHsgLi4uY2hpbGQucHJvcHMsIGtleTogZGVtYW5nbGVkSW5kZXgsIFwiZGF0YS1tYW5nbGVkLWluZGV4XCI6IG1hbmdsZWRJbmRleCwgXCJkYXRhLXVubWFuZ2xlZC1pbmRleFwiOiBkZW1hbmdsZWRJbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgcHJvcHMpKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvL2xpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IG5hdmlnYXRlQWJzb2x1dGUsIG5hdmlnYXRlUmVsYXRpdmUgfSxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuOiB7IGluZGV4TWFuZ2xlciwgaW5kZXhEZW1hbmdsZXIsIG1hbmdsZU1hcCwgZGVtYW5nbGVNYXAsIHJlYXJyYW5nZSwgc2h1ZmZsZSwgdXNlUmVhcnJhbmdlYWJsZVByb3BzLCB9XG4gICAgfTtcbn1cblxuXG4vKipcbiAqIEhvb2sgdGhhdCBhbGxvd3MgZm9yIHRoZSAqKmRpcmVjdCBkZXNjZW5kYW50KiogY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgdG8gYmUgcmUtb3JkZXJlZCBhbmQgc29ydGVkLlxuICogXG4gKiAqVGhpcyBpcyAqKnNlcGFyYXRlKiogZnJvbSBcIm1hbmFnZWRcIiBjaGlsZHJlbiwgd2hpY2ggY2FuIGJlIGFueSBsZXZlbCBvZiBjaGlsZCBuZWVkZWQhIFNvcnRhYmxlL3JlYXJyYW5nZWFibGUgY2hpbGRyZW4gbXVzdCBiZSAqKmRpcmVjdCBkZXNjZW5kYW50cyoqIG9mIHRoZSBwYXJlbnQgdGhhdCB1c2VzIHRoaXMgaG9vayEqIFxuICogXG4gKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uYDsgaXQgdGFrZXMgdGhlIHNhbWUgYGluZGV4TWFuZ2xlcmAgYW5kIGBpbmRleERlbWFuZ2xlcmAgXG4gKiBmdW5jdGlvbnMgdGhhdCB0aGlzIGhvb2sgcmV0dXJucy4gYHVzZUxpc3ROYXZpZ2F0aW9uYCBkb2VzIG5vdCBkaXJlY3RseSB1c2UgdGhpcyBob29rIGJlY2F1c2UsIGFzIG1lbnRpb25lZCwgXG4gKiB0aGlzIGhvb2sgaW1wb3NlcyBzZXJpb3VzIHJlc3RyaWN0aW9ucyBvbiBjaGlsZCBzdHJ1Y3R1cmUsIHdoaWxlIGB1c2VMaXN0TmF2aWdhdGlvbmAgYWxsb3dzIGFueXRoaW5nLlxuICogXG4gKiBCZXNpZGVzIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIHRoYXQncyByZXR1cm5lZCwgdGhlIGBzb3J0YCBmdW5jdGlvbiB0aGF0J3MgcmV0dXJuZWQgd2lsbFxuICogc29ydCBhbGwgY2hpbGRyZW4gYWNjb3JkaW5nIHRvIHRoZWlyIHZhbHVlIGZyb20gdGhlIGBnZXRWYWx1ZWAgYXJndW1lbnQgeW91IHBhc3MgaW4uXG4gKiBcbiAqIElmIHlvdSB3YW50IHRvIHBlcmZvcm0gc29tZSByZS1vcmRlcmluZyBvcGVyYXRpb24gdGhhdCdzICpub3QqIGEgc29ydCwgeW91IGNhbiBtYW51YWxseVxuICogcmUtbWFwIGVhY2ggY2hpbGQncyBwb3NpdGlvbiB1c2luZyBgbWFuZ2xlTWFwYCBhbmQgYGRlbWFuZ2xlTWFwYCwgd2hpY2ggY29udmVydCBiZXR3ZWVuXG4gKiBzb3J0ZWQgYW5kIHVuc29ydGVkIGluZGV4IHBvc2l0aW9ucy5cbiAqIFxuICogQWdhaW4sIHVubGlrZSBzb21lIG90aGVyIGhvb2tzLCAqKnRoZXNlIGNoaWxkcmVuIG11c3QgYmUgZGlyZWN0IGRlc2NlbmRhbnRzKiouIFRoaXMgaXMgYmVjYXVzZVxuICogdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgaW5zcGVjdHMgdGhlIGdpdmVuIGNoaWxkcmVuLCB0aGVuIHJlLWNyZWF0ZXMgdGhlbSB3aXRoIG5ldyBga2V5YHMuXG4gKiBCZWNhdXNlIGtleXMgYXJlIGdpdmVuIHNwZWNpYWwgdHJlYXRtZW50IGFuZCBhIGNoaWxkIGhhcyBubyB3YXkgb2YgbW9kaWZ5aW5nIGl0cyBvd24ga2V5XG4gKiB0aGVyZSdzIG5vIG90aGVyIHRpbWUgb3IgcGxhY2UgdGhpcyBjYW4gaGFwcGVuIG90aGVyIHRoYW4gZXhhY3RseSB3aXRoaW4gdGhlIHBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlU29ydGFibGVDaGlsZEluZm8+KHtcbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IGNvbXBhcmU6IHVzZXJDb21wYXJlIH1cbn06IFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPE0+KTogVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGU8UGFyZW50RWxlbWVudCwgTT4ge1xuXG4gICAgY29uc3QgZ2V0Q29tcGFyZSA9IHVzZVN0YWJsZUdldHRlcjxDb21wYXJlPE0+Pih1c2VyQ29tcGFyZSA/PyBkZWZhdWx0Q29tcGFyZSk7XG5cbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybiB9ID0gdXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQsIE0+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyB9KTtcbiAgICBjb25zdCB7IHJlYXJyYW5nZSB9ID0gcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuO1xuICAgIC8vIFRoZSBhY3R1YWwgc29ydCBmdW5jdGlvbi5cbiAgICBjb25zdCBzb3J0ID0gdXNlQ2FsbGJhY2soKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48TT4sIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiKTogUHJvbWlzZTx2b2lkPiB8IHZvaWQgPT4ge1xuICAgICAgICBjb25zdCBjb21wYXJlID0gZ2V0Q29tcGFyZSgpO1xuXG4gICAgICAgIGNvbnN0IHNvcnRlZFJvd3MgPSBjb21wYXJlID8gbWFuYWdlZFJvd3MuYXJyYXlTbGljZSgpLnNvcnQoKGxoc1JvdywgcmhzUm93KSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGxoc1ZhbHVlID0gbGhzUm93O1xuICAgICAgICAgICAgY29uc3QgcmhzVmFsdWUgPSByaHNSb3c7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJlKGxoc1ZhbHVlLCByaHNWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uWzBdID09IFwiZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiAtcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB9KSA6IG1hbmFnZWRSb3dzLmFycmF5U2xpY2UoKTtcblxuICAgICAgICByZXR1cm4gcmVhcnJhbmdlKHNvcnRlZFJvd3MpO1xuXG4gICAgfSwgWyAvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm46IHsgc29ydCB9LFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5cbiAgICB9O1xufVxuXG4vKmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JvdXBlZFNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPE0gZXh0ZW5kcyBHcm91cGVkU29ydGVkQ2hpbGRJbmZvPiB7XG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JvdXBlZFNvcnRhYmxlQ2hpbGRyZW4ge1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBQaWNrPFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzW1wibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIl0sIFwiaW5kZXhEZW1hbmdsZXJcIiB8IFwiaW5kZXhNYW5nbGVyXCI+XG59Ki9cblxuLyoqXG4gKiBJdCdzIGNvbW1vbiBlbm91Z2ggdG8gaGF2ZSwgZS5nLiwgYSBsaXN0IHdpdGggbXVsdGlwbGUgc29ydGFibGUgZ3JvdXBzLCBhIHRhYmxlIHdoZXJlIHRoZSBib2R5IGlzIHNvcnRlZCBpbmRlcGVuZGVudGx5IG9mIHRoZSBoZWFkLCBldGMuLi5cbiAqIFxuICogQSBzb3J0YWJsZSBncm91cCBhc3N1bWVzIHRoYXQgdGhlIHBhcmVudCAod2hpY2ggYWxzbyBjYWxscyB0aGlzIGhvb2spIGhhbmRsZXMgbGlzdCBuYXZpZ2F0aW9uIChvciBzaW1pbGFyKSxcbiAqIGFuZCB0aGF0IGVhY2ggZ3JvdXAgZWxlbWVudCAod2hpY2ggY2FuIGFsc28gYmUgdGhlIGxpc3QgcGFyZW50LCBpZiB0aGVyZSBhcmUgTk8gZ3JvdXBzKSBoYW5kbGVzIHNvcnRpbmcgKG9yIHNpbWlsYXIpLlxuICovXG4vKmV4cG9ydCBmdW5jdGlvbiB1c2VHcm91cGVkU29ydGFibGVDaGlsZHJlbjxNIGV4dGVuZHMgR3JvdXBlZFNvcnRlZENoaWxkSW5mbz4oeyBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHsgZ2V0Q2hpbGRyZW4gfSB9OiBVc2VHcm91cGVkU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8TT4pOiBVc2VHcm91cGVkU29ydGFibGVDaGlsZHJlbiB7XG4gICAgY29uc3QgYWxsSW5kZXhNYW5nbGVycyA9IHVzZVJlZjxNYXA8bnVtYmVyLCAoaTogbnVtYmVyKSA9PiBudW1iZXI+PihuZXcgTWFwKCkpO1xuICAgIGNvbnN0IGFsbEluZGV4RGVtYW5nbGVycyA9IHVzZVJlZjxNYXA8bnVtYmVyLCAoaTogbnVtYmVyKSA9PiBudW1iZXI+PihuZXcgTWFwKCkpO1xuICAgIGNvbnN0IGluZGV4TWFuZ2xlciA9IHVzZUNhbGxiYWNrKChpOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGdldENoaWxkcmVuKCkuZ2V0QXQoaSk7XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgbGV0IGluZGV4TWFuZ2xlckZvclRoaXNMb2NhdGlvbiA9IGFsbEluZGV4TWFuZ2xlcnMuY3VycmVudC5nZXQoY2hpbGQubG9jYXRpb25JbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gKGluZGV4TWFuZ2xlckZvclRoaXNMb2NhdGlvbiA/PyBpZGVudGl0eSkoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KGkpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBpbmRleERlbWFuZ2xlciA9IHVzZUNhbGxiYWNrKChpOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGdldENoaWxkcmVuKCkuZ2V0QXQoaSk7XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgbGV0IGluZGV4RGVtYW5nbGVyRm9yVGhpc0xvY2F0aW9uID0gYWxsSW5kZXhEZW1hbmdsZXJzLmN1cnJlbnQuZ2V0KGNoaWxkLmxvY2F0aW9uSW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIChpbmRleERlbWFuZ2xlckZvclRoaXNMb2NhdGlvbiA/PyBpZGVudGl0eSkoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KGkpO1xuICAgIH0sIFtdKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGluZGV4TWFuZ2xlcixcbiAgICAgICAgICAgIGluZGV4RGVtYW5nbGVyXG4gICAgICAgIH1cbiAgICB9XG59Ki9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGxoczogVXNlU29ydGFibGVDaGlsZEluZm8gfCB1bmRlZmluZWQsIHJoczogVXNlU29ydGFibGVDaGlsZEluZm8gfCB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29tcGFyZTEobGhzPy5nZXRTb3J0VmFsdWUoKSwgcmhzPy5nZXRTb3J0VmFsdWUoKSk7XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlMShsaHM6IHVua25vd24gfCB1bmRlZmluZWQsIHJoczogdW5rbm93biB8IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobGhzID09IG51bGwgfHwgcmhzID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsaHMgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAocmhzID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGxocyBhcyBhbnkpIC0gKHJocyBhcyBhbnkpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCwgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1ncmlkLW5hdmlnYXRpb24tcGFydGlhbFwiO1xuaW1wb3J0IHsgR3JpZFNpbmdsZVNlbGVjdENoaWxkQ2VsbEluZm8sIEdyaWRTaW5nbGVTZWxlY3RDaGlsZFJvd0luZm8sIHVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uLCBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZSwgdXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Sb3csIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUm93UGFyYW1ldGVycywgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Sb3dSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWdyaWQtbmF2aWdhdGlvbi1zaW5nbGUtc2VsZWN0aW9uXCI7XG4vL2ltcG9ydCB7IFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycywgVXNlU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2Utc2luZ2xlLXNlbGVjdGlvblwiO1xuaW1wb3J0IHsgVXNlU29ydGFibGVDaGlsZEluZm8sIHVzZVNvcnRhYmxlQ2hpbGRyZW4sIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1zb3J0YWJsZS1jaGlsZHJlblwiO1xuXG4vKipcbiAqIExpa2UgbGlzdCBuYXZpZ2F0aW9uIHNpbmdsZSBzZWxlY3Rpb24gc29ydGFibGUgZXRjLiBldGMuIGV0Yy5cbiAqIFxuICogVGhlIGNvbWJpbmF0aW9ucyBhcmUgZ2V0dGluZyBhIGJpdCBzaWxseSBidXQgSSBzd2VhciB0aGlzIGlzIHRoZSBsYXN0IG9uZS5cbiAqL1xuY29uc3QgX2R1bW15ID0gMDtcblxuZXhwb3J0IGludGVyZmFjZSBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgVXNlU29ydGFibGVDaGlsZEluZm8geyB9XG5leHBvcnQgaW50ZXJmYWNlIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50PiB7IH1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUGFyYW1ldGVyczxQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdENoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4+IGV4dGVuZHMgT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgTT4sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPE0+IHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgTT5bXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIj5cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVJldHVyblR5cGU8UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZTxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+LCBPbWl0PFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlPFBhcmVudE9yUm93RWxlbWVudCwgUk0+LCBcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Sb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBfUk0sIENNPiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVJvd1JldHVyblR5cGU8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2VsbFBhcmFtZXRlcnM8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50PiB7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGU8UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pih7XG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAuLi5ncmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNcbn06IFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVQYXJhbWV0ZXJzPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPik6IFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSZXR1cm5UeXBlPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4ge1xuICAgIGNvbnN0IHsgLi4uc2NyIH0gPSB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudE9yUm93RWxlbWVudCwgUk0+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycywgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMgfSk7XG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm46IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9IH0gPSBzY3I7XG4gICAgY29uc3QgZ25yID0gdXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIC4uLmxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzIH0sXG4gICAgICAgIC4uLmdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHsgLi4uZ25yLCAuLi5zY3IsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSb3c8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PihwOiBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPik6IFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7XG4gICAgcmV0dXJuIHVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+KHApO1xufVxuXG4vLyBFWlxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDZWxsPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ocDogVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNlbGxQYXJhbWV0ZXJzPGFueSwgQ2VsbEVsZW1lbnQ+KTogVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50PiB7XG4gICAgcmV0dXJuIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbDxDZWxsRWxlbWVudD4ocCk7XG59IiwiaW1wb3J0IHsgYXNzZXJ0RW1wdHlPYmplY3QgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZUxpc3ROYXZpZ2F0aW9uLCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1saXN0LW5hdmlnYXRpb24tcGFydGlhbFwiO1xuaW1wb3J0IHsgU2VsZWN0YWJsZUNoaWxkSW5mbywgdXNlU2luZ2xlU2VsZWN0aW9uLCB1c2VTaW5nbGVTZWxlY3Rpb25DaGlsZCwgVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGUsIFVzZVNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsIFVzZVNpbmdsZVNlbGVjdGlvblJldHVyblR5cGUgfSBmcm9tIFwiLi91c2Utc2luZ2xlLXNlbGVjdGlvblwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuLyoqXG4gKiBXZSdyZSBqdXN0IGdsdWluZyB0b2dldGhlciB0aGUgbGlzdCBuYXZpZ2F0aW9uIGFuZCBzaW5nbGUgc2VsZWN0aW9uIGhvb2tzLFxuICogc2luY2UgdGhleSdyZSBzbyBjb21tb25seSBwYWlyZWQgdG9nZXRoZXIuIEFsc28gc2VlIHRoZSBvbmUgdGhhdCBpbmNsdWRlcyBzb3J0aW5nLlxuICovXG5jb25zdCBfZHVtbXkgPSAwO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudD4sIFNlbGVjdGFibGVDaGlsZEluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQ+IHsgfVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4+IGV4dGVuZHNcbiAgICBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4sXG4gICAgT21pdDxVc2VTaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPENoaWxkRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhSZXR1cm5cIj4ge1xuICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdICYgVXNlU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQ+LCBVc2VTaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlPENoaWxkRWxlbWVudD4geyB9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+Pih7XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsXG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgIC4uLl92b2lkM1xufTogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+KTogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQ+IHtcbiAgICBjb25zdCBsbnIgPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPih7IGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLCByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4gfSk7XG4gICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleFJldHVybiB9ID0gbG5yO1xuICAgIGNvbnN0IHNzciA9IHVzZVNpbmdsZVNlbGVjdGlvbjxDaGlsZEVsZW1lbnQ+KHsgcm92aW5nVGFiSW5kZXhSZXR1cm4sIG1hbmFnZWRDaGlsZHJlblJldHVybiwgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyB9KTtcblxuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5zc3IsXG4gICAgICAgIC4uLmxucixcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+LCBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PiB7XG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIl0gJiBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIl07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+LCBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50PiB7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXgsIC4uLl92b2lkNSB9LFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbiwgLi4udm9pZDcgfSxcbiAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgc2luZ2xlU2VsZWN0aW9uQ29udGV4dCxcbiAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0LFxuICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgIC4uLl92b2lkMVxufTogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50Pik6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudD4ge1xuXG4gICAgY29uc3Qge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7IG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IG9jZmljMiwgLi4uX3ZvaWQzIH0sXG4gICAgICAgIC4uLnNzY3JcbiAgICB9ID0gdXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50Pih7XG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25Db250ZXh0XG4gICAgfSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogb2NmaWMxLCAuLi5fdm9pZDYgfSxcbiAgICAgICAgLi4ubG5jclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudD4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbiB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCxcbiAgICAgICAgcmVmRWxlbWVudFJldHVybixcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzXG4gICAgfSk7XG5cbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDEpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KF92b2lkMyk7XG4gICAgYXNzZXJ0RW1wdHlPYmplY3QoX3ZvaWQ1KTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdChfdm9pZDYpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQ3KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkLCBwcmV2aW91c2x5Rm9jdXNlZCwgZSkgPT4ge1xuICAgICAgICAgICAgICAgIG9jZmljMT8uKGZvY3VzZWQsIHByZXZpb3VzbHlGb2N1c2VkLCBlKTtcbiAgICAgICAgICAgICAgICBvY2ZpYzI/Lihmb2N1c2VkLCBwcmV2aW91c2x5Rm9jdXNlZCwgZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAuLi5zc2NyLFxuICAgICAgICAuLi5sbmNyXG4gICAgfVxufVxuIiwiXG5pbXBvcnQgeyB1c2VTdGFibGVPYmplY3QgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1nZXR0ZXJcIjtcbmltcG9ydCB7IFVzZUhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtaGFzLWN1cnJlbnQtZm9jdXNcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCBQYXNzaXZlU3RhdGVVcGRhdGVyLCByZXR1cm5GYWxzZSwgcnVuSW1tZWRpYXRlbHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyczxUIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyczoge1xuICAgICAgICAvKiogKi9cbiAgICAgICAgb25Db21wb3NpdGVGb2N1c0NoYW5nZTogbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPGJvb2xlYW4sIGguSlNYLlRhcmdldGVkRXZlbnQ8VD4+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IFJlcXVpcmVkPFBpY2s8VXNlSGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczxFPltcImhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnNcIl0sIFwib25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZFwiPj47XG4gICAgLy9yZWZFbGVtZW50UGFyYW1ldGVyczogUmVxdWlyZWQ8UGljazxVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxFPltcInJlZkVsZW1lbnRQYXJhbWV0ZXJzXCJdLCBcIm9uRWxlbWVudENoYW5nZVwiPj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5UeXBlPFQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm46IHsgZ2V0QW55Rm9jdXNlZCgpOiBib29sZWFuOyB9XG4gICAgY2hpbGRyZW5IYXZlRm9jdXNDaGlsZENvbnRleHQ6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQYXJhbWV0ZXJzPFQ+W1wiY2hpbGRyZW5IYXZlRm9jdXNDaGlsZENvbnRleHRcIl07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnM8VCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dDoge1xuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgICAgIHNldEZvY3VzQ291bnQ6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyLCBoLkpTWC5UYXJnZXRlZEV2ZW50PFQ+PjtcblxuICAgICAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgICAgIC8vYWxsRWxlbWVudHM6IFNldDxOb2RlPlxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuXG4vKipcbiAqIEFsbG93cyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgKHN1Y2ggYXMgYSByYWRpbyBncm91cCBvciBsaXN0Ym94KSB0byBsaXN0ZW5cbiAqIGZvciBhbiBcIm92ZXJhbGwgZm9jdXNpbi9vdXRcIiBldmVudDsgdGhpcyBob29rIGxldHMgeW91IGtub3cgd2hlbiBmb2N1cyBoYXMgXG4gKiBtb3ZlZCBpbi9vdXQgb2YgdGhpcyBncm91cGluZyBvZiBjaGlsZHJlbiBFVkVOIElGIHRoZXJlIGlzIG5vIGFjdHVhbCBwYXJlbnQgRE9NIGVsZW1lbnQuXG4gKiBcbiAqIEkuRS4geW91IGNhbiB1c2UgdGhpcyB3aXRob3V0IG5lZWRpbmcgYSBwYXJlbnQgYDxkaXY+YCB0byBsaXN0ZW4gZm9yIGEgYGZvY3Vzb3V0YCBldmVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuSGF2ZUZvY3VzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KGFyZ3M6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+KTogVXNlQ2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5UeXBlPENoaWxkRWxlbWVudD4ge1xuICAgIHR5cGUgUiA9IGguSlNYLlRhcmdldGVkRXZlbnQ8Q2hpbGRFbGVtZW50PjtcbiAgICBjb25zdCB7IGNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyczogeyBvbkNvbXBvc2l0ZUZvY3VzQ2hhbmdlIH0gfSA9IGFyZ3M7XG5cbiAgICBjb25zdCBbZ2V0QW55Rm9jdXNlZCwgc2V0QW55Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbiwgUj4ob25Db21wb3NpdGVGb2N1c0NoYW5nZSwgcmV0dXJuRmFsc2UsIHJ1bkltbWVkaWF0ZWx5KTtcbiAgICBjb25zdCBbX2dldEZvY3VzQ291bnQsIHNldEZvY3VzQ291bnRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciwgUj4odXNlU3RhYmxlQ2FsbGJhY2s8T25QYXNzaXZlU3RhdGVDaGFuZ2U8bnVtYmVyLCBSPj4oKGFueUZvY3VzZWQsIGFueVByZXZpb3VzbHlGb2N1c2VkLCBlKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGFueUZvY3VzZWQgPj0gMCAmJiBhbnlGb2N1c2VkIDw9IDEpO1xuICAgICAgICBzZXRBbnlGb2N1c2VkKCEhKGFueUZvY3VzZWQgJiYgIWFueVByZXZpb3VzbHlGb2N1c2VkKSwgZSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm46IHsgZ2V0QW55Rm9jdXNlZCB9LFxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHsgY2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnM6IHVzZVN0YWJsZU9iamVjdCh7IHNldEZvY3VzQ291bnQgfSkgfSksXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZDxFIGV4dGVuZHMgRWxlbWVudD4oeyBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dDogeyBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczogeyBzZXRGb2N1c0NvdW50IH0gfSB9OiBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczxFPik6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlPEU+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZCwgcHJldiwgZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEZvY3VzQ291bnQocCA9PiAocCA/PyAwKSArIDEsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZm9jdXNlZCAmJiBwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEZvY3VzQ291bnQocCA9PiAocCA/PyAwKSAtIDEsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9XG4gICAgfTtcbn0iLCJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuLy9pbXBvcnQgeyBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL2RvbS1oZWxwZXJzL3VzZS1yZWYtZWxlbWVudFwiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybkZhbHNlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhhc0N1cnJlbnRGb2N1c1Byb3BzPEUgZXh0ZW5kcyBFbGVtZW50PihyOiBVc2VIYXNDdXJyZW50Rm9jdXNSZXR1cm5UeXBlPEU+LCAuLi5vdGhlclByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPltdKSB7XG4gICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHIuaGFzQ3VycmVudEZvY3VzUmV0dXJuLnByb3BzU3RhYmxlLCAuLi5vdGhlclByb3BzKTtcbn0qL1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM8VCBleHRlbmRzIE5vZGU+IHtcbiAgICByZWZFbGVtZW50UmV0dXJuOiBSZXF1aXJlZDxQaWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+W1wicmVmRWxlbWVudFJldHVyblwiXSwgXCJnZXRFbGVtZW50XCI+PjtcblxuICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgZWxlbWVudCBpdHNlbGYgY3VycmVudGx5IGhhcyBmb2N1cy5cbiAgICAgICAgICogXG4gICAgICAgICAqIGBwcmV2Rm9jdXNlZGAgaXMgZ2VuZXJhbGx5IHRoZSBvcHBvc2l0ZSBvZiBgZm9jdXNlZGAsIGJ1dCBvbiBtb3VudCBpdCdzIGB1bmRlZmluZWRgIHdoaWxlIGBmb2N1c2VkYCBpcyBwcm9iYWJseSBmYWxzZSAoYm90aCBmYWxzeSlcbiAgICAgICAgICovXG4gICAgICAgIG9uQ3VycmVudEZvY3VzZWRDaGFuZ2VkOiBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8Ym9vbGVhbiwgaC5KU1guVGFyZ2V0ZWRFdmVudDxUPj47IC8vKChmb2N1c2VkOiBib29sZWFuLCBwcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4gdm9pZCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpa2UgYG9uRm9jdXNlZENoYW5nZWRgLCBidXQgYWxzbyAqYWRkaXRpb25hbGx5KiBpZiBhbnkgY2hpbGQgZWxlbWVudHMgYXJlIGZvY3VzZWQuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBAc2VlIHRoaXMub25Gb2N1c2VkQ2hhbmdlZFxuICAgICAgICAgKi9cbiAgICAgICAgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPGJvb2xlYW4sIGguSlNYLlRhcmdldGVkRXZlbnQ8VD4+OyAvLygoZm9jdXNlZDogYm9vbGVhbiwgcHJldkZvY3VzZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHZvaWQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNDdXJyZW50Rm9jdXNSZXR1cm5UeXBlPEUgZXh0ZW5kcyBOb2RlPiB7XG4gICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuOiB7XG4gICAgICAgIHByb3BzU3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPlxuICAgICAgICAvKipcbiAgICAgICAgICogTW9kaWZpZXMgdGhlIGVsZW1lbnQgdG8gYmUgYWJsZSB0byB0cmFjayBpdHMgb3duIGZvY3VzIHN0YXRlXG4gICAgICAgICAqL1xuICAgICAgICAvL3Byb3BzU3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcblxuICAgICAgICAvKiogU1RBQkxFICovXG4gICAgICAgIGdldEN1cnJlbnRGb2N1c2VkKCk6IGJvb2xlYW47XG4gICAgICAgIC8qKiBTVEFCTEUgKi9cbiAgICAgICAgZ2V0Q3VycmVudEZvY3VzZWRJbm5lcigpOiBib29sZWFuO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhhc0N1cnJlbnRGb2N1czxUIGV4dGVuZHMgTm9kZT4oYXJnczogVXNlSGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczxUPik6IFVzZUhhc0N1cnJlbnRGb2N1c1JldHVyblR5cGU8VD4ge1xuICAgIHR5cGUgUiA9IGguSlNYLlRhcmdldGVkRm9jdXNFdmVudDxUPjtcbiAgICBjb25zdCB7XG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZENoYW5nZWQ6IG9uRm9jdXNlZENoYW5nZWQsIG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IG9uRm9jdXNlZElubmVyQ2hhbmdlZCB9LFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQgfVxuICAgIH0gPSBhcmdzO1xuXG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VIYXNDdXJyZW50Rm9jdXNcIiwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBnZXRFbGVtZW50KTtcblxuICAgIGNvbnN0IFtnZXRGb2N1c2VkLCBzZXRGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuLCAgUj4ob25Gb2N1c2VkQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xuICAgIGNvbnN0IFtnZXRGb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbiwgIFI+KG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xuXG4gICAgY29uc3Qgb25Gb2N1c0luID0gdXNlQ2FsbGJhY2s8aC5KU1guRXZlbnRIYW5kbGVyPGguSlNYLlRhcmdldGVkRm9jdXNFdmVudDxUPj4+KChlKSA9PiB7XG4gICAgICAgIHNldEZvY3VzZWRJbm5lcih0cnVlLCBlIGFzIFIpO1xuICAgICAgICBzZXRGb2N1c2VkKGUudGFyZ2V0ID09IGdldEVsZW1lbnQoKSwgZSBhcyBSKVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IG9uRm9jdXNPdXQgPSB1c2VDYWxsYmFjazxoLkpTWC5FdmVudEhhbmRsZXI8aC5KU1guVGFyZ2V0ZWRGb2N1c0V2ZW50PFQ+Pj4oKGUpID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09IGdldEVsZW1lbnQoKSkge1xuICAgICAgICAgICAgc2V0Rm9jdXNlZElubmVyKGZhbHNlLCBlIGFzIFIpO1xuICAgICAgICAgICAgc2V0Rm9jdXNlZChmYWxzZSwgZSBhcyBSKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHByb3BzU3RhYmxlID0gdXNlUmVmPGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+Pih7XG4gICAgICAgIG9uZm9jdXNpbjogb25Gb2N1c0luLFxuICAgICAgICBvbmZvY3Vzb3V0OiBvbkZvY3VzT3V0XG4gICAgfSlcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybjoge1xuICAgICAgICAgICAgcHJvcHNTdGFibGU6IHByb3BzU3RhYmxlLmN1cnJlbnQsXG4gICAgICAgICAgICBnZXRDdXJyZW50Rm9jdXNlZDogZ2V0Rm9jdXNlZCxcbiAgICAgICAgICAgIGdldEN1cnJlbnRGb2N1c2VkSW5uZXI6IGdldEZvY3VzZWRJbm5lcixcbiAgICAgICAgfVxuICAgIH07XG59XG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL2RvbS1oZWxwZXJzL3VzZS1yZWYtZWxlbWVudFwiO1xuaW1wb3J0IHsgdXNlR2xvYmFsSGFuZGxlciB9IGZyb20gXCIuLi9kb20taGVscGVycy91c2UtZXZlbnQtaGFuZGxlclwiO1xuaW1wb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWZvcmNlLXVwZGF0ZVwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YXRlXCI7XG4vKlxuZXhwb3J0IGZ1bmN0aW9uIHVzZVByZXNzUHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+KHI6IFVzZVByZXNzUmV0dXJuVHlwZTxFPiwgLi4ub3RoZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+W10ge1xuICAgIHJldHVybiBbci5wcmVzc1JldHVybi5wcm9wc1N0YWJsZSwgLi4ub3RoZXJQcm9wc107XG59Ki9cblxuZXhwb3J0IGludGVyZmFjZSBVc2VQcmVzc1BhcmFtZXRlcnM8RSBleHRlbmRzIE5vZGU+IHtcbiAgICByZWZFbGVtZW50UmV0dXJuOiBSZXF1aXJlZDxQaWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+W1wicmVmRWxlbWVudFJldHVyblwiXSwgXCJnZXRFbGVtZW50XCI+PjtcbiAgICBwcmVzc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoYXQgc2hvdWxkIGhhcHBlbiB3aGVuIHRoaXMgd2lkZ2V0IGhhcyBiZWVuIFwicHJlc3NlZFwiLlxuICAgICAgICAgKiBcbiAgICAgICAgICogVGhpcyBtdXN0IGJlIGEgc3luYyBldmVudCBoYW5kbGVyOyBhc3luYyBoYW5kbGVycyBtdXN0IGJlIHRha2VuIGNhcmUgb2YgZXh0ZXJuYWxseS5cbiAgICAgICAgICogXG4gICAgICAgICAqIFNldHRpbmcgdG8gYG51bGxgIG9yIGB1bmRlZmluZWRgIGVmZmVjdGl2ZWx5IGRpc2FibGVzIHRoZSBwcmVzcyBldmVudCBoYW5kbGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgb25QcmVzc1N5bmM6ICgoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxFPikgPT4gdm9pZCkgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIGNlcnRhaW4gbWV0aG9kcyBvZiBwcmVzc2luZyB0aGlzIGNvbXBvbmVudCBzaG91bGQgYmUgZGVhY3RpdmF0ZWQuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgZHVyaW5nIHR5cGVhaGVhZCwgdGhlIHNwYWNlIGtleSBzaG91bGRuJ3QgY291bnQgYXMgYSBwcmVzcywgaXQgc2hvdWxkIGp1c3QgY291bnQgZm9yIHRoZSBzZWFyY2guXG4gICAgICAgICAqIFxuICAgICAgICAgKiBJZiB0cnVlLCB0aGVuIGFsbCBwcmVzc2VzIGFyZSBkaXNhYmxlZC4gIElmIGZhbHNlL3VuZGVmaW5lZC9udWxsLCBubyBwcmVzc2VzIGFyZSBkaXNhYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIGV4Y2x1ZGU6IHVuZGVmaW5lZCB8IGJvb2xlYW4gfCB7IGNsaWNrPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIHNwYWNlPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIGVudGVyPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQgfTtcbiAgICAgICAgZm9jdXNTZWxmKGVsZW1lbnQ6IEUpOiB2b2lkO1xuICAgICAgICAvL29uUHNldWRvQWN0aXZlU3RhcnQ6IG51bGwgfCB1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk7XG4gICAgICAgIC8vb25Qc2V1ZG9BY3RpdmVTdG9wOiBudWxsIHwgdW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VQcmVzc1JldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBwcmVzc1JldHVybjoge1xuICAgICAgICAvKiogXG4gICAgICAgICAqIFNvcnQgb2YgbGlrZSB3aGVuIHRoZSBDU1MgYDphY3RpdmVgIHBzZXVkby1lbGVtZW50IHdvdWxkIGFwcGx5LFxuICAgICAgICAgKiBidXQgc3BlY2lmaWNhbGx5IGZvciBwcmVzc2VzIG9ubHkuIFVzZWZ1bCBmb3Igc3R5bGluZyBtb3N0bHkuXG4gICAgICAgICAqL1xuICAgICAgICBwc2V1ZG9BY3RpdmU6IGJvb2xlYW47XG4gICAgICAgIHByb3BzU3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbiAgICB9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIHRvIGNyZWF0ZSBhIFwicHJlc3NcIi1saWtlIGV2ZW50IGZvclxuICogYW55IGVsZW1lbnQsIHdoZXRoZXIgaXQncyBhIG5hdGl2ZSA8QlVUVE9OPiBvciByZWd1bGFyIDxESVY+LlxuICogXG4gKiBOb3RhYmx5LCB0aGUgZm9sbG93aW5nIGNhc2VzIGFyZSBjb3ZlcmVkOlxuICogKiBUaGUgdGFyZ2V0IGVsZW1lbnQgaXMgcHJvcGVybHkgZm9jdXNlZCwgZXZlbiBvbiBpT1MgU2FmYXJpICgqZXNwZWNpYWxseSogb24gaU9TIFNhZmFyaSlcbiAqICogRG91YmxlLWNsaWNrcyB3b24ndCBzZWxlY3QgdGV4dC4gXG4gKiAqIENvbnZlcnNlbHksIG1hbnVhbGx5IHNlbGVjdGluZyB0ZXh0IHdvbid0IGludm9rZSBhIHByZXNzLlxuICogKiBLZXlib2FyZCBldmVudHMgJm1kYXNoOyBgZW50ZXJgIGltbWVkaWF0ZWx5IGludm9rZXMgdGhlIGhhbmRsZXIsIHdoaWxlIGBzcGFjZWAgaW52b2tlcyBpdCBvbiBrZXl1cC5cbiAqICogSGFwdGljIGZlZWRiYWNrIChvbiwgbGlrZSwgdGhlIG9uZSBicm93c2VyIGNvbWJpbmF0aW9uIHRoYXQgc3VwcG9ydHMgaXQgJm1kYXNoOyB0aGlzIGNhbiBiZSBkaXNhYmxlZCBhcHAtd2lkZSB3aXRoIGBzZXRCdXR0b25WaWJyYXRlYClcbiAqIFxuICogSW4gYWRkaXRpb24sIHdoZW4gdGhlIENTUyBgOmFjdGl2ZWAgcHNldWRvLWNsYXNzIHdvdWxkIGFwcGx5IHRvIGEgbm9ybWFsIGJ1dHRvblxuICogKGkuZS4gd2hlbiBob2xkaW5nIHRoZSBzcGFjZWJhciBvciBkdXJpbmcgbW91c2Vkb3duKSwgYHsgXCJkYXRhLXBzZXVkby1hY3RpdmVcIjogXCJ0cnVlXCIgfWBcbiAqIGlzIGFkZGVkIHRvIHRoZSBwcm9wcy4gIFlvdSBjYW4gZWl0aGVyIGxldCBpdCBwYXNzIHRocm91Z2ggYW5kIHN0eWxlIGl0IHRocm91Z2ggbmV3IENTUyxcbiAqIG9yIGluc3BlY3QgdGhlIHJldHVybmVkIHByb3BzIGZvciBpdCBhbmQgYWRkIGUuZy4gYW4gYC5hY3RpdmVgIGNsYXNzIGZvciBleGlzdGluZyBDU1NcbiAqIFxuICogQHBhcmFtIG9uQ2xpY2tTeW5jIFxuICogQHBhcmFtIGV4Y2x1ZGUgV2hldGhlciB0aGUgcG9seWZpbGwgc2hvdWxkbid0IGFwcGx5IChjYW4gc3BlY2lmeSBmb3Igc3BlY2lmaWMgaW50ZXJhY3Rpb25zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlc3M8RSBleHRlbmRzIEVsZW1lbnQ+KGFyZ3M6IFVzZVByZXNzUGFyYW1ldGVyczxFPik6IFVzZVByZXNzUmV0dXJuVHlwZTxFPiB7XG4gICAgY29uc3Qge1xuICAgICAgICByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQgfSxcbiAgICAgICAgcHJlc3NQYXJhbWV0ZXJzOiB7IGV4Y2x1ZGUsIGZvY3VzU2VsZiwgb25QcmVzc1N5bmMgfVxuICAgIH0gPSBhcmdzO1xuXG4gICAgLy9jb25zdCBzdGFibGVPblBzZXVkb0FjdGl2ZVN0YXJ0ID0gdXNlU3RhYmxlQ2FsbGJhY2sob25Qc2V1ZG9BY3RpdmVTdGFydCA/PyAoKCkgPT4geyB9KSk7XG4gICAgLy9jb25zdCBzdGFibGVPblBzZXVkb0FjdGl2ZVN0b3AgPSB1c2VTdGFibGVDYWxsYmFjayhvblBzZXVkb0FjdGl2ZVN0b3AgPz8gKCgpID0+IHsgfSkpO1xuXG4gICAgLy8gQSBidXR0b24gY2FuIGJlIGFjdGl2YXRlZCBpbiBtdWx0aXBsZSB3YXlzLCBzbyBvbiB0aGUgb2ZmIGNoYW5jZVxuICAgIC8vIHRoYXQgbXVsdGlwbGUgYXJlIHRyaWdnZXJlZCBhdCBvbmNlLCB3ZSBvbmx5ICphY3R1YWxseSogcmVnaXN0ZXJcbiAgICAvLyBhIHByZXNzIG9uY2UgYWxsIG9mIG91ciBcIm9uXCIgc2lnbmFscyBoYXZlIHR1cm5lZCBiYWNrIHRvIFwib2ZmXCIuXG4gICAgLy8gV2UgYXBwcm94aW1hdGUgdGhpcyBieSBqdXN0IGluY3JlbWVudGluZyB3aGVuIGFjdGl2ZSwgYW5kXG4gICAgLy8gZGVjcmVtZW50aW5nIHdoZW4gZGVhY3RpdmF0ZWQuXG4gICAgLy9cbiAgICAvLyBBcyBhbiBlbWVyZ2VuY3kgZmFpbHNhZmUsIHdoZW4gdGhlIGVsZW1lbnQgbG9zZXMgZm9jdXMsXG4gICAgLy8gdGhpcyBpcyByZXNldCBiYWNrIHRvIDAuXG4gICAgY29uc3QgW2FjdGl2ZUR1cmluZ1JlbmRlciwgc2V0QWN0aXZlLCBnZXRBY3RpdmVdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuXG4gICAgLy9jb25zdCB7IGdldEVsZW1lbnQgfSA9IHJlZkVsZW1lbnRSZXR1cm47XG5cbiAgICAvLyBJZiB3ZSB0aGUgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiBjaGFuZ2VzIHRvIGluY2x1ZGUgdGhpcyBlbGVtZW50XG4gICAgLy8gRFVSSU5HIGUuZy4gYSBtb3VzZWRvd24sIHRoZW4gd2UgZG9uJ3Qgd2FudCB0aGUgbW91c2V1cCB0byBcImNvdW50XCIsIGFzIGl0IHdlcmUsXG4gICAgLy8gYmVjYXVzZSBpdHMgb25seSBwdXJwb3NlIHdhcyBzZWxlY3RpbmcgdGV4dCwgbm90IGNsaWNraW5nIGJ1dHRvbnMuXG4gICAgLy9cbiAgICAvLyBUbyBjYXRjaCB0aGlzLCBhbnkgdGltZSB0aGUgdGV4dCBzZWxlY3Rpb24gaW5jbHVkZXMgdXMgd2hpbGUgaW4gdGhlIG1pZGRsZVxuICAgIC8vIG9mIGEgY2xpY2ssIHRoaXMgZmxhZyBpcyBzZXQsIHdoaWNoIGNhbmNlbHMgdGhlIGFjdGl2YXRpb24gb2YgYSBwcmVzcy5cbiAgICAvLyBUaGUgZmxhZyBpcyByZXNldCBhbnkgdGltZSB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IG9yIHRoZSBidXR0b24gaXNcbiAgICAvLyBubyBsb25nZXIgYWN0aXZlLlxuICAgIGNvbnN0IFt0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lLCBzZXRUZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lXSA9IHVzZVN0YXRlPERhdGUgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBwc2V1ZG9BY3RpdmUgPSAoYWN0aXZlRHVyaW5nUmVuZGVyICYmICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lID09IG51bGwpKTtcbiAgICAvL3VzZUVmZmVjdCgoKSA9PiB7IGlmIChwc2V1ZG9BY3RpdmUpIHsgc3RhYmxlT25Qc2V1ZG9BY3RpdmVTdGFydCgpOyB9IGVsc2UgeyBzdGFibGVPblBzZXVkb0FjdGl2ZVN0b3AoKTsgfSByZXR1cm4gKCkgPT4geyBpZiAocHNldWRvQWN0aXZlKSBzdGFibGVPblBzZXVkb0FjdGl2ZVN0b3AoKTsgfSB9LCBbcHNldWRvQWN0aXZlXSlcblxuICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwic2VsZWN0aW9uY2hhbmdlXCIsIF8gPT4ge1xuICAgICAgICBzZXRUZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lKHByZXYgPT4gbm9kZVNlbGVjdGVkVGV4dExlbmd0aChnZXRFbGVtZW50KCkpID09IDAgPyBudWxsIDogcHJldiAhPSBudWxsID8gcHJldiA6IG5ldyBEYXRlKCkpO1xuICAgIH0pO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZUR1cmluZ1JlbmRlciA9PSAwKVxuICAgICAgICAgICAgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZShudWxsKTtcblxuICAgIH0sIFthY3RpdmVEdXJpbmdSZW5kZXIgPT0gMF0pO1xuXG4gICAgY29uc3Qgb25BY3RpdmVTdGFydCA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvblByZXNzU3luYz4+KChfKSA9PiB7XG4gICAgICAgIHNldEFjdGl2ZShhID0+ICsrYSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBvbkFjdGl2ZVN0b3AgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25QcmVzc1N5bmM+PigoZSkgPT4ge1xuICAgICAgICBzZXRBY3RpdmUoYSA9PiBNYXRoLm1heCgwLCAtLWEpKTtcblxuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHRpbWVEaWZmZXJlbmNlID0gKHRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUgPT0gbnVsbCA/IG51bGwgOiArY3VycmVudFRpbWUgLSArdGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSk7XG4gICAgICAgIGNvbnN0IGNoYXJhY3RlcnNTZWxlY3RlZCA9IG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZ2V0RWxlbWVudCgpKVxuXG4gICAgICAgIC8vIElmIHdlJ3JlIHNlbGVjdGluZyB0ZXh0IChoZXVyaXN0aWNhbGx5IGRldGVybWluZWQgYnkgc2VsZWN0aW5nIGZvciBsb25nZXIgdGhhbiAxLzQgYSBzZWNvbmQsIG9yIG1vcmUgdGhhbiAyIGNoYXJhY3RlcnMpXG4gICAgICAgIC8vIHRoZW4gdGhpcyBpc24ndCBhIHByZXNzIGV2ZW50LlxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBtZWFzdXJlIGdseXBocyBpbnN0ZWFkIG9mIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChjaGFyYWN0ZXJzU2VsZWN0ZWQgPiAxIHx8ICgodGltZURpZmZlcmVuY2UgPz8gMCkgPiAyNTAgJiYgY2hhcmFjdGVyc1NlbGVjdGVkID49IDEpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYWN0aXZlID0gZ2V0QWN0aXZlKCk7ICAgLy8gV2UgcXVlcnkgaWYgd2UncmUgYWN0aXZlICphZnRlciogY2FsbGluZyBzZXRTdGF0ZSBiZWNhdXNlIHdlIGNvdW50IGEgcHJlc3MgaWZmIHdlJ3JlIG5vdyBhdCAwLlxuICAgICAgICBpZiAoYWN0aXZlIDw9IDApIHtcbiAgICAgICAgICAgIGhhbmRsZVByZXNzKGUpO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTsgIC8vIFRPRE86IFJlbW92ZSB3aGVuIGlzc3VlIHJlc29sdmVkIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzM3MzFcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgaGFuZGxlUHJlc3MgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25QcmVzc1N5bmM+PigoZSkgPT4ge1xuICAgICAgICBpZiAob25QcmVzc1N5bmMpIHtcblxuICAgICAgICAgICAgLy8gTm90ZTogVGhlIGVsZW1lbnQgaXMgZm9jdXNlZCBoZXJlIGJlY2F1c2Ugb2YgaU9TIFNhZmFyaS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJdCdzIGFsd2F5cyBpT1MgU2FmYXJpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlPUyBTYWZhcmkgKHRlc3RlZCBvbiAxMikgZG93bnJpZ2h0IHJlZnVzZXMgdG8gYWxsb3cgXG4gICAgICAgICAgICAvLyBlbGVtZW50cyB0byBiZSBtYW51YWxseSBmb2N1c2VkIFVOTEVTUyBpdCBoYXBwZW5zIHdpdGhpblxuICAgICAgICAgICAgLy8gYW4gZXZlbnQgaGFuZGxlciBsaWtlIHRoaXMuICBJdCBhbHNvIGRvZXNuJ3QgZm9jdXNcbiAgICAgICAgICAgIC8vIGJ1dHRvbnMgYnkgZGVmYXVsdCB3aGVuIGNsaWNrZWQsIHRhcHBlZCwgZXRjLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIElmIGl0IGJlY29tZXMgcHJvYmxlbWF0aWMgdGhhdCBidXR0b24tbGlrZXMgZXhwbGljaXRseSBiZWNvbWVcbiAgICAgICAgICAgIC8vIGZvY3VzZWQgd2hlbiB0aGV5IGFyZSBwcmVzc2VkLCB0aGVuIGFuIGFsdGVybmF0aXZlIHNvbHV0aW9uIGZvclxuICAgICAgICAgICAgLy8gdGhlIHF1ZXN0aW9uIG9mIFwiaG93IGRvIG1lbnUgYnV0dG9ucyBrZWVwIHRoZWlyIG1lbnVzIG9wZW5cIlxuICAgICAgICAgICAgLy8gYW5kIG90aGVyIGZvY3VzLXJlbGF0ZWQgbm9uc2Vuc2UgbmVlZHMgdG8gYmUgZmlndXJlZCBvdXQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRm9yIGlPUyBTYWZhcmkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIFwiZm9jdXNcIiBpbiAoZWxlbWVudCBhcyBFdmVudFRhcmdldCBhcyBIVE1MRWxlbWVudCkpXG4gICAgICAgICAgICAgICAgZm9jdXNTZWxmKGVsZW1lbnQgYXMgRXZlbnRUYXJnZXQgYXMgRSk7XG4gICAgICAgICAgICAvLyhlbGVtZW50IGFzIEV2ZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50IHwgbnVsbCk/LmZvY3VzKCk7XG5cbiAgICAgICAgICAgIC8vIFdoYXRldmVyIHRoZSBicm93c2VyIHdhcyBnb2luZyB0byBkbyB3aXRoIHRoaXMgZXZlbnQsXG4gICAgICAgICAgICAvLyBmb3JnZXQgaXQuIFdlJ3JlIHR1cm5pbmcgaXQgaW50byBhIFwicHJlc3NcIiBldmVudC5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgLy8gQWxzbyBzdG9wIGFueW9uZSBlbHNlIGZyb20gbGlzdGVuaW5nIHRvIHRoaXMgZXZlbnQsXG4gICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBleHBsaWNpdGx5IGhhbmRsaW5nIGl0LlxuICAgICAgICAgICAgLy8gKE5vdGFibHksIHRoaXMgYWxsb3dzIGxhYmVscyB0byB3cmFwIGlucHV0cywgd2l0aCB0aGVtXG4gICAgICAgICAgICAvLyBib3RoIGhhdmluZyBwcmVzcyBldmVudCBoYW5kbGVycywgd2l0aG91dCBkb3VibGUtZmlyaW5nKVxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgLy8gSGFwdGljIGZlZWRiYWNrIGZvciB0aGlzIHByZXNzIGV2ZW50XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgdGhyb3csXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIHNob3VsZCBndWFyZCBhZ2FpbnN0IHVzZXIgaW1wbGVtZW50YXRpb25zIHRoYXQgY291bGQuXG4gICAgICAgICAgICAgICAgcHVsc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGx5IGNhbGwgb3VyIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgb25QcmVzc1N5bmMoZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSB1c2VTdGFibGVDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGlmIChvblByZXNzU3luYyAmJiAhZXhjbHVkZXMoXCJjbGlja1wiLCBleGNsdWRlKSkge1xuICAgICAgICAgICAgLy8gU3RvcCBkb3VibGUgY2xpY2tzIGZyb20gc2VsZWN0aW5nIHRleHQgaW4gYW4gY29tcG9uZW50IHRoYXQncyAqc3VwcG9zZWQqIHRvIGJlIGFjdGluZyBsaWtlIGEgYnV0dG9uLFxuICAgICAgICAgICAgLy8gYnV0IGFsc28gZG9uJ3QgcHJldmVudCB0aGUgdXNlciBmcm9tIHNlbGVjdGluZyB0aGF0IHRleHQgbWFudWFsbHkgaWYgdGhleSByZWFsbHkgd2FudCB0b1xuICAgICAgICAgICAgLy8gKHdoaWNoIHVzZXItc2VsZWN0OiBub25lIHdvdWxkIGRvLCBidXQgY2FuY2VsbGluZyBhIGRvdWJsZSBjbGljayBvbiBtb3VzZURvd24gZG9lc24ndClcbiAgICAgICAgICAgIGlmIChlLmRldGFpbCA+IDEpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgb25BY3RpdmVTdGFydChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG4gICAgY29uc3Qgb25Nb3VzZVVwID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xuICAgICAgICBpZiAob25QcmVzc1N5bmMgJiYgIWV4Y2x1ZGVzKFwiY2xpY2tcIiwgZXhjbHVkZSkpIHtcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCAmJiBnZXRBY3RpdmUoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAob25QcmVzc1N5bmMgJiYgIWV4Y2x1ZGVzKFwiY2xpY2tcIiwgZXhjbHVkZSkpIHtcbiAgICAgICAgICAgIHNldEFjdGl2ZSgwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25LZXlEb3duID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkS2V5Ym9hcmRFdmVudDxFPikgPT4ge1xuICAgICAgICBpZiAob25QcmVzc1N5bmMpIHtcbiAgICAgICAgICAgIGlmIChlLmtleSA9PSBcIiBcIiAmJiAhZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGFjdGl2YXRlIGl0IG9uIGEgc3BhY2Uga2V5ZG93blxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBkbyBwcmV2ZW50RGVmYXVsdCB0byBzdG9wIHRoZSBwYWdlIGZyb20gc2Nyb2xsaW5nLlxuICAgICAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZS5rZXkgPT0gXCJFbnRlclwiICYmICFleGNsdWRlcyhcImVudGVyXCIsIGV4Y2x1ZGUpKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XG4gICAgICAgICAgICAgICAgb25BY3RpdmVTdG9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IG9uS2V5VXAgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGlmIChvblByZXNzU3luYyAmJiBlLmtleSA9PSBcIiBcIiAmJiAhZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSlcbiAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcbiAgICB9KVxuXG4gICAgY29uc3Qgb25DbGljayA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKG9uUHJlc3NTeW5jKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoZS5kZXRhaWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBvbkZvY3VzT3V0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKF9lOiBoLkpTWC5UYXJnZXRlZEZvY3VzRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgc2V0QWN0aXZlKDApO1xuICAgIH0pXG5cblxuICAgIGNvbnN0IHByb3BzU3RhYmxlMiA9IHVzZVJlZjxoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4oe1xuICAgICAgICBvbktleURvd24sXG4gICAgICAgIG9uS2V5VXAsXG4gICAgICAgIG9uTW91c2VEb3duLFxuICAgICAgICBvbk1vdXNlVXAsXG4gICAgICAgIG9uTW91c2VMZWF2ZSxcbiAgICAgICAgb25DbGljayxcbiAgICAgICAgb25mb2N1c291dDogb25Gb2N1c091dFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlc3NSZXR1cm46IHtcbiAgICAgICAgICAgIHBzZXVkb0FjdGl2ZTogKHBzZXVkb0FjdGl2ZSB8fCBmYWxzZSksXG4gICAgICAgICAgICBwcm9wc1N0YWJsZTogcHJvcHNTdGFibGUyLmN1cnJlbnQsXG4gICAgICAgICAgICAvKnByb3BzVW5zdGFibGU6IHtcbiAgICAgICAgICAgICAgICBzdHlsZTogKHRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUgIT0gbnVsbCkgPyB7IGN1cnNvcjogXCJ0ZXh0XCIgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAuLi57IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IHBzZXVkb0FjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gYXMge31cbiAgICAgICAgICAgIH0sKi9cbiAgICAgICAgfVxuICAgIH07XG59XG5cblxuXG5cbi8qKlxuICogc2VsZWN0aW9uLmNvbnRhaW5zTm9kZSBkb2Vzbid0IGFjY291bnQgZm9yIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCxcbiAqIHNvIGhlcmUncyBhIHdvcmthcm91bmQgZm9yIHRoYXQuXG4gKiBcbiAqIFdlIGFsc28gb25seSBsb29rIGZvciB0aGUgc2VsZWN0aW9uIGVuZCB0byBvbmx5IGNhdGNoIHRoZSBcbiAqIGVzc2Vuc2Ugb2YgYSBub24tZXhpc3RhbnQgXCJzZWxlY3Rpb25zdG9wXCIgZXZlbnQuXG4gKiBcbiAqIEBwYXJhbSBlbGVtZW50IFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZWxlbWVudDogRXZlbnRUYXJnZXQgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHNlbGVjdGlvbj8ucmFuZ2VDb3VudCA/PyAwKTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbiEuZ2V0UmFuZ2VBdChpKSE7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhyYW5nZS5lbmRDb250YWluZXIpICYmICFzZWxlY3Rpb24/LmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbiEudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn1cblxuXG5sZXQgcHVsc2UgPSAoKFwidmlicmF0ZVwiIGluIG5hdmlnYXRvcikgJiYgKG5hdmlnYXRvci52aWJyYXRlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSA/ICgoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMCkpIDogKCgpID0+IHsgfSk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBlbmFibGUvZGlzYWJsZSBidXR0b24gdmlicmF0aW9uIHB1bHNlcyBvbiBhbiBhcHAtd2lkZSBzY2FsZS5cbiAqIFxuICogXG4gKiBAcGFyYW0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcnVuIHdoZW4gYSBidXR0b24gaXMgdGFwcGVkLlxuICogKERlZmF1bHQgaXMgYCgpID0+IG5hdmlnYXRvci52aWJyYXRlKDEwKWAgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LCBhIG5vb3Agb3RoZXJ3aXNlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJlc3NWaWJyYXRlKGZ1bmM6ICgpID0+IHZvaWQpIHtcbiAgICBwdWxzZSA9IGZ1bmM7XG59XG5cblxuXG5mdW5jdGlvbiBleGNsdWRlcyh0YXJnZXQ6IFwiY2xpY2tcIiB8IFwic3BhY2VcIiB8IFwiZW50ZXJcIiwgZXhjbHVkZTogdW5kZWZpbmVkIHwgYm9vbGVhbiB8IHsgY2xpY2s/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgc3BhY2U/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgZW50ZXI/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCB9KSB7XG4gICAgaWYgKGV4Y2x1ZGUgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoZXhjbHVkZSA9PT0gdHJ1ZSB8fCBleGNsdWRlPy5bdGFyZ2V0XSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG4iLCJpbXBvcnQgeyBVc2VTb3J0YWJsZUNoaWxkSW5mbyB9IGZyb20gXCJjb21wb25lbnQtZGV0YWlsL3VzZS1zb3J0YWJsZS1jaGlsZHJlblwiO1xuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL2NvbXBvbmVudC1kZXRhaWwvdXNlLWdyaWQtbmF2aWdhdGlvbi1wYXJ0aWFsXCI7XG5pbXBvcnQgeyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRDZWxsSW5mbywgR3JpZFNpbmdsZVNlbGVjdENoaWxkUm93SW5mbywgdXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DZWxsLCBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNlbGxQYXJhbWV0ZXJzLCBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZSwgdXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Sb3csIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUm93UmV0dXJuVHlwZSB9IGZyb20gXCIuLi9jb21wb25lbnQtZGV0YWlsL3VzZS1ncmlkLW5hdmlnYXRpb24tc2luZ2xlLXNlbGVjdGlvblwiO1xuaW1wb3J0IHsgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRDZWxsSW5mbywgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRSb3dJbmZvLCB1c2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlLCBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2VsbFJldHVyblR5cGUsIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVQYXJhbWV0ZXJzLCBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUmV0dXJuVHlwZSwgVXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVJvd1BhcmFtZXRlcnMsIFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSb3dSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL2NvbXBvbmVudC1kZXRhaWwvdXNlLWdyaWQtbmF2aWdhdGlvbi1zaW5nbGUtc2VsZWN0aW9uLXNvcnRhYmxlXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuLi9kb20taGVscGVycy91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuLi9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZUNoaWxkcmVuSGF2ZUZvY3VzLCB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkLCBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGUgfSBmcm9tIFwiLi4vb2JzZXJ2ZXJzL3VzZS1jaGlsZHJlbi1oYXZlLWZvY3VzXCI7XG5pbXBvcnQgeyB1c2VIYXNDdXJyZW50Rm9jdXMsIFVzZUhhc0N1cnJlbnRGb2N1c1JldHVyblR5cGUgfSBmcm9tIFwiLi4vb2JzZXJ2ZXJzL3VzZS1oYXMtY3VycmVudC1mb2N1c1wiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkcmVuLCB1c2VNYW5hZ2VkQ2hpbGQsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dCwgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSwgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZSB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZU9iamVjdCB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlUHJlc3MsIFVzZVByZXNzUGFyYW1ldGVycywgVXNlUHJlc3NSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXByZXNzXCI7XG5cbi8qZXhwb3J0IGludGVyZmFjZSBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2hpbGRJbmZvPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7XG4gICAgXG59Ki9cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+PiBleHRlbmRzXG4gICAgT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUGFyYW1ldGVyczxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBNPiwgXCJtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5cIiB8IFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIiB8IFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIiB8IFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiIHwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4ge1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBNPltcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCJdLCBcImdldEhpZ2hlc3RJbmRleFwiIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiB8IFwiaXNWYWxpZFwiPjtcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczogT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgTT5bXCJ0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJnZXRIaWdoZXN0SW5kZXhcIiB8IFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIgfCBcImlzVmFsaWRcIj47XG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUGFyYW1ldGVyczxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBNPltcInJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnNcIl0sIFwiZ2V0SGlnaGVzdENoaWxkSW5kZXhcIiB8IFwiaXNWYWxpZFwiPjtcbiAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IE9taXQ8VXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVBhcmFtZXRlcnM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgTT5bXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIl0sIFwiaW5pdGlhbGx5VGFiYmVkSW5kZXhcIj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50Pj4ge1xuICAgIGFzQ2hpbGRSb3dQYXJhbWV0ZXJzOiBPbWl0PFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+W1wiYXNDaGlsZFJvd1BhcmFtZXRlcnNcIl0sIFwibWFuYWdlZENoaWxkcmVuUmV0dXJuXCIgfCBcInNpbmdsZVNlbGVjdGlvbkNvbnRleHRcIiB8IFwiZ3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0XCIgfCBcInJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0XCIgfCBcInR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHRcIiB8IFwicmVmRWxlbWVudFJldHVyblwiPiAmIHtcbiAgICAgICAgY29udGV4dDogQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQ8YW55LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPjsgLy9Vc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPFJNPltcImNvbnRleHRcIl07XG4gICAgICAgIC8vbWFuYWdlZENoaWxkUmV0dXJuOiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPFJNPltcIm1hbmFnZWRDaGlsZFJldHVyblwiXTtcbiAgICAgICAgY29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM6IE9taXQ8Uk0sIGtleW9mIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4+O1xuICAgICAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVyczogUGljazxVc2VTb3J0YWJsZUNoaWxkSW5mbywgXCJnZXRTb3J0VmFsdWVcIj47XG4gICAgfTtcbiAgICBhc1BhcmVudFJvd1BhcmFtZXRlcnM6IE9taXQ8VXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT5bXCJhc1BhcmVudFJvd1BhcmFtZXRlcnNcIl0sIFwicm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzXCIgfCBcIm1hbmFnZWRDaGlsZHJlblJldHVyblwiIHwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiIHwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPiAmIHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IE9taXQ8VXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT5bXCJhc1BhcmVudFJvd1BhcmFtZXRlcnNcIl1bXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJnZXRIaWdoZXN0SW5kZXhcIiB8IFwicGFnZU5hdmlnYXRpb25TaXplXCIgfCBcImlzVmFsaWRcIiB8IFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCI+O1xuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczogT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPltcImFzUGFyZW50Um93UGFyYW1ldGVyc1wiXVtcInR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXCJdLCBcImlzVmFsaWRcIj47XG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPltcImFzUGFyZW50Um93UGFyYW1ldGVyc1wiXVtcInJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc1wiXSwgXCJpbml0aWFsbHlUYWJiZWRJbmRleFwiPjtcbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+IGV4dGVuZHNcbiAgICBPbWl0PFVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2VsbFBhcmFtZXRlcnM8YW55LCBDZWxsRWxlbWVudD4sIFwidHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dFwiIHwgXCJyb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dFwiIHwgXCJncmlkTmF2aWdhdGlvbkNlbGxDb250ZXh0XCIgfCBcInJlZkVsZW1lbnRSZXR1cm5cIj4ge1xuICAgIHByZXNzUGFyYW1ldGVyczogVXNlUHJlc3NQYXJhbWV0ZXJzPENlbGxFbGVtZW50PltcInByZXNzUGFyYW1ldGVyc1wiXTtcbiAgICAvL21hbmFnZWRDaGlsZENvbnRleHQ6IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT5bXCJtYW5hZ2VkQ2hpbGRDb250ZXh0XCJdO1xuICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczogT21pdDxNLCBrZXlvZiBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+O1xuICAgIGNvbnRleHQ6IENvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0PGFueSwgQ2VsbEVsZW1lbnQsIE0+O1xuICAgIC8vbWFuYWdlZENoaWxkUmV0dXJuOiBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0+W1wibWFuYWdlZENoaWxkUmV0dXJuXCJdO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQ8UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8Uk0+LFxuICAgIFBpY2s8VXNlQ2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5UeXBlPFJvd0VsZW1lbnQ+LCBcImNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRDb250ZXh0XCI+LFxuICAgIFBpY2s8VXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwic2luZ2xlU2VsZWN0aW9uQ29udGV4dFwiIHwgXCJyb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dFwiIHwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0XCIgfCBcImdyaWROYXZpZ2F0aW9uUm93Q29udGV4dFwiPiB7XG5cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0PFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdENoaWxkQ2VsbEluZm88Q2hpbGRFbGVtZW50Pj4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+LFxuICAgIFBpY2s8VXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudD5bXCJhc1BhcmVudFJvd1JldHVyblwiXSwgXCJyb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dFwiIHwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0XCIgfCBcImdyaWROYXZpZ2F0aW9uQ2VsbENvbnRleHRcIj4ge1xuICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25Db250ZXh0OiB7XG4gICAgICAgIG9uUHJlc3NTeW5jOiBVc2VQcmVzc1BhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcInByZXNzUGFyYW1ldGVyc1wiXVtcIm9uUHJlc3NTeW5jXCJdXG4gICAgfVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PlxuICAgIGV4dGVuZHMgT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUmV0dXJuVHlwZTxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHRcIiB8IFwic2luZ2xlU2VsZWN0aW9uQ29udGV4dFwiIHwgXCJyb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dFwiIHwgXCJncmlkTmF2aWdhdGlvblJvd0NvbnRleHRcIiB8IFwiY2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzXCIgfCBcIm1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnNcIj4ge1xuICAgIHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPclJvd0VsZW1lbnQ+O1xuICAgIGNvbnRleHQ6IENvbXBsZXRlR3JpZE5hdmlnYXRpb25Db250ZXh0PFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT47XG5cbiAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8Uk0+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdO1xuICAgIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuOiBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGU8Um93RWxlbWVudD5bXCJjaGlsZHJlbkhhdmVGb2N1c1JldHVyblwiXTtcbiAgICAvL3JlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM6IFBpY2s8VXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1tcInJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnNcIl0sIFwiZ2V0SGlnaGVzdENoaWxkSW5kZXhcIiB8IFwiZ2V0VmFsaWRcIj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGU8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RDaGlsZENlbGxJbmZvPENlbGxFbGVtZW50Pj4ge1xuICAgIGNvbnRleHQ6IENvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDTT47XG4gICAgcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvd0VsZW1lbnQ+O1xuICAgIGFzUGFyZW50Um93UmV0dXJuOiBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUm93UmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD5bXCJhc1BhcmVudFJvd1JldHVyblwiXTtcbiAgICBhc0NoaWxkUm93UmV0dXJuOiBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUm93UmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD5bXCJhc0NoaWxkUm93UmV0dXJuXCJdO1xuICAgIG1hbmFnZWRDaGlsZFJldHVybjogVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxSTT5bXCJtYW5hZ2VkQ2hpbGRSZXR1cm5cIl07XG4gICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuOiBVc2VIYXNDdXJyZW50Rm9jdXNSZXR1cm5UeXBlPFJvd0VsZW1lbnQ+W1wiaGFzQ3VycmVudEZvY3VzUmV0dXJuXCJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZTxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdENoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzXG4gICAgT21pdDxVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQ+LCBcImhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnNcIj4sXG4gICAgVXNlUHJlc3NSZXR1cm5UeXBlPENlbGxFbGVtZW50PiwgVXNlUmVmRWxlbWVudFJldHVyblR5cGU8Q2VsbEVsZW1lbnQ+LCBVc2VIYXNDdXJyZW50Rm9jdXNSZXR1cm5UeXBlPENlbGxFbGVtZW50PiwgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxDTT4ge1xuICAgIHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD47XG5cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbjxQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRTaW5nbGVTZWxlY3RTb3J0YWJsZUNoaWxkUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+KHtcbiAgICBncmlkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1xufTogVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0+KTogVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiB7XG5cbiAgICBjb25zdCBnZXRDaGlsZHJlbjogKCkgPT4gTWFuYWdlZENoaWxkcmVuPFJNPiA9IHVzZUNhbGxiYWNrPCgpID0+IE1hbmFnZWRDaGlsZHJlbjxSTT4+KCgpID0+IG1hbmFnZWRDaGlsZHJlblJldHVybi5nZXRDaGlsZHJlbigpLCBbXSk7XG4gICAgY29uc3QgZ2V0SGlnaGVzdENoaWxkSW5kZXg6ICgoKSA9PiBudW1iZXIpID0gdXNlQ2FsbGJhY2s8KCkgPT4gbnVtYmVyPigoKSA9PiBnZXRDaGlsZHJlbigpLmdldEhpZ2hlc3RJbmRleCgpLCBbXSk7XG5cbiAgICBjb25zdCBpc1ZhbGlkID0gdXNlU3RhYmxlQ2FsbGJhY2soKGluZGV4OiBudW1iZXIpOiBib29sZWFuID0+IHsgcmV0dXJuICEoZ2V0Q2hpbGRyZW4oKS5nZXRBdChpbmRleCk/LmhpZGRlbikgfSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNvbnRleHQsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgIGdyaWROYXZpZ2F0aW9uUm93Q29udGV4dCxcbiAgICAgICAgLi4uZ3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5cbiAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZTxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+KHtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBnZXRIaWdoZXN0SW5kZXg6IGdldEhpZ2hlc3RDaGlsZEluZGV4LCBpc1ZhbGlkLCAuLi5saW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHsgZ2V0Q2hpbGRyZW4gfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IGluaXRpYWxseVRhYmJlZEluZGV4OiBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLmluaXRpYWxseVNlbGVjdGVkSW5kZXgsIC4uLnJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBpc1ZhbGlkLCAuLi50eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyB9LFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1xuICAgIH0pO1xuXG4gICAgY29uc3QgeyBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLCB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuIH0gPSBncmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVybjtcblxuICAgIGNvbnN0IHsgY2hpbGRyZW5IYXZlRm9jdXNDaGlsZENvbnRleHQsIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuIH0gPSB1c2VDaGlsZHJlbkhhdmVGb2N1czxSb3dFbGVtZW50Pih7IGNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyB9KTtcbiAgICBjb25zdCB7IGNvbnRleHQ6IHsgbWFuYWdlZENoaWxkQ29udGV4dCB9LCBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxSTT4oeyBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzIH0pO1xuICAgIGNvbnN0IHByb3BzID0gdXNlTWVyZ2VkUHJvcHMobGluZWFyTmF2aWdhdGlvblJldHVybi5wcm9wc1N0YWJsZSwgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybi5wcm9wc1N0YWJsZSk7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZVN0YWJsZU9iamVjdDxDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ29udGV4dDxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+Pih7XG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNvbnRleHQsXG4gICAgICAgIG1hbmFnZWRDaGlsZENvbnRleHQsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0LFxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dCxcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgcHJvcHMsXG5cbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICAuLi5ncmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVybixcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIC8vcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBnZXRIaWdoZXN0Q2hpbGRJbmRleDogZ2V0SGlnaGVzdENoaWxkSW5kZXgsIGdldFZhbGlkIH0sXG4gICAgfVxuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93PFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRDZWxsSW5mbzxDZWxsRWxlbWVudD4+KHtcbiAgICBhc0NoaWxkUm93UGFyYW1ldGVyczoge1xuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBjb250ZXh0OiB7IGNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRDb250ZXh0LCBncmlkTmF2aWdhdGlvblJvd0NvbnRleHQsIG1hbmFnZWRDaGlsZENvbnRleHQ6IG1jYzEsIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0LCBzaW5nbGVTZWxlY3Rpb25Db250ZXh0LCB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0IH0sXG4gICAgICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICAuLi5hc0NoaWxkUm93UGFyYW1ldGVyc1xuICAgIH0sXG4gICAgYXNQYXJlbnRSb3dQYXJhbWV0ZXJzOiB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICAuLi5hc1BhcmVudFJvd1BhcmFtZXRlcnNcbiAgICB9XG59OiBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPik6IFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+IHtcblxuICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM7XG5cbiAgICBjb25zdCBnZXRDaGlsZHJlbiA9IHVzZUNhbGxiYWNrKCgpID0+IG1hbmFnZWRDaGlsZHJlblJldHVybi5nZXRDaGlsZHJlbigpLCBbXSk7XG4gICAgY29uc3QgZ2V0SGlnaGVzdENoaWxkSW5kZXg6ICgoKSA9PiBudW1iZXIpID0gdXNlQ2FsbGJhY2s8KCkgPT4gbnVtYmVyPigoKSA9PiBnZXRDaGlsZHJlbigpLmdldEhpZ2hlc3RJbmRleCgpLCBbXSk7XG4gICAgY29uc3QgaXNWYWxpZCA9IHVzZUNhbGxiYWNrKChpOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBnZXRDaGlsZHJlbigpLmdldEF0KGkpO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gIWNoaWxkLmhpZGRlbjtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8Um93RWxlbWVudD4oeyByZWZFbGVtZW50UGFyYW1ldGVyczoge30gfSk7XG5cbiAgICBjb25zdCByOiBVc2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+ID0gdXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Sb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4oe1xuICAgICAgICBhc1BhcmVudFJvd1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIC4uLmFzUGFyZW50Um93UGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogeyBpbml0aWFsbHlUYWJiZWRJbmRleDogMCwgLi4ucm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzIH0sXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBpc1ZhbGlkLCAuLi50eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyB9LFxuICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgaXNWYWxpZCwgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0Q2hpbGRJbmRleCwgcGFnZU5hdmlnYXRpb25TaXplOiAwLCBpbmRleERlbWFuZ2xlcjogaWRlbnRpdHksIGluZGV4TWFuZ2xlcjogaWRlbnRpdHksIC4uLmxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzIH0sXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHsgZ2V0Q2hpbGRyZW4gfSxcbiAgICAgICAgfSxcbiAgICAgICAgYXNDaGlsZFJvd1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIC4uLmFzQ2hpbGRSb3dQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcmVmRWxlbWVudFJldHVybixcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgZ3JpZE5hdmlnYXRpb25Sb3dDb250ZXh0LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb25Db250ZXh0LFxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCxcbiAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHsgZ2V0Q2hpbGRyZW4gfSxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBhc0NoaWxkUm93UmV0dXJuLCBhc1BhcmVudFJvd1JldHVybiB9ID0gcjtcblxuXG4gICAgY29uc3QgeyBjb250ZXh0OiB7IG1hbmFnZWRDaGlsZENvbnRleHQgfSwgbWFuYWdlZENoaWxkcmVuUmV0dXJuIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48Q00+KHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogci5hc1BhcmVudFJvd1JldHVybi5tYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzIH0pO1xuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCB9ID0gcmVmRWxlbWVudFJldHVybjtcblxuICAgIGNvbnN0IGJhc2VJbmZvOiBHcmlkU2luZ2xlU2VsZWN0Q2hpbGRSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiA9IHtcbiAgICAgICAgZ2V0RWxlbWVudCxcbiAgICAgICAgc2V0VGFiYmFibGU6IHIuYXNDaGlsZFJvd1JldHVybi5yb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLnNldFRhYmJhYmxlLFxuICAgICAgICBnZXRUYWJiYWJsZTogci5hc0NoaWxkUm93UmV0dXJuLnJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4uZ2V0VGFiYmFibGUsXG4gICAgICAgIHRhYmJhYmxlOiByLmFzQ2hpbGRSb3dSZXR1cm4ucm92aW5nVGFiSW5kZXhDaGlsZFJldHVybi50YWJiYWJsZSxcbiAgICAgICAgaW5kZXg6IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMuaW5kZXgsXG4gICAgICAgIGhpZGRlbjogcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMuaGlkZGVuLFxuICAgICAgICBzZWxlY3RlZDogci5hc0NoaWxkUm93UmV0dXJuLnNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuLnNlbGVjdGVkLFxuICAgICAgICBmb2N1c1NlbGY6IHIuYXNDaGlsZFJvd1JldHVybi5ncmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMuZm9jdXNTZWxmLFxuICAgICAgICBnZXRTZWxlY3RlZDogci5hc0NoaWxkUm93UmV0dXJuLnNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuLmdldFNlbGVjdGVkLFxuICAgICAgICBzZXRMb2NhbFNlbGVjdGVkOiByLmFzQ2hpbGRSb3dSZXR1cm4ubWFuYWdlZENoaWxkUGFyYW1ldGVycy5zZXRMb2NhbFNlbGVjdGVkLFxuICAgICAgICBkaXNhYmxlZDogc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLmRpc2FibGVkLFxuICAgICAgICBzZXRUYWJiYWJsZUNvbHVtbkluZGV4OiByLmFzQ2hpbGRSb3dSZXR1cm4uZ3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzLnNldFRhYmJhYmxlQ29sdW1uSW5kZXhcbiAgICB9XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZFJldHVybiB9ID0gdXNlTWFuYWdlZENoaWxkPFJNPih7IGNvbnRleHQ6IHsgbWFuYWdlZENoaWxkQ29udGV4dDogbWNjMSB9LCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0gfSwgeyAuLi5iYXNlSW5mbywgLi4uY29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMgfSBhcyBSTSlcblxuXG4gICAgY29uc3QgY29udGV4dCA9IHVzZVN0YWJsZU9iamVjdDxDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93Q29udGV4dDxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgQ00+Pih7XG4gICAgICAgIG1hbmFnZWRDaGlsZENvbnRleHQsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0OiByLmFzUGFyZW50Um93UmV0dXJuLnJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0OiByLmFzUGFyZW50Um93UmV0dXJuLnR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25Db250ZXh0OiB1c2VTdGFibGVPYmplY3QoeyBvblByZXNzU3luYzogci5hc0NoaWxkUm93UmV0dXJuLnByZXNzUGFyYW1ldGVycy5vblByZXNzU3luYyBhcyBhbnkgfSksXG4gICAgICAgIGdyaWROYXZpZ2F0aW9uQ2VsbENvbnRleHQ6IHIuYXNQYXJlbnRSb3dSZXR1cm4uZ3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dCxcbiAgICB9KTtcbiAgICBjb25zdCB7IGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMgfSA9IHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGQoeyBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dCB9KTtcbiAgICAvL2NvbnN0IHsgcmVmRWxlbWVudFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxSb3dFbGVtZW50Pih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KVxuICAgIGNvbnN0IHsgaGFzQ3VycmVudEZvY3VzUmV0dXJuIH0gPSB1c2VIYXNDdXJyZW50Rm9jdXMoeyByZWZFbGVtZW50UmV0dXJuLCBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7IC4uLmhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMsIG9uQ3VycmVudEZvY3VzZWRDaGFuZ2VkOiBudWxsIH0gfSk7XG4gICAgY29uc3QgcHJvcHMgPSB1c2VNZXJnZWRQcm9wcyhcbiAgICAgICAgcmVmRWxlbWVudFJldHVybi5wcm9wc1N0YWJsZSxcbiAgICAgICAgLy8gVE9ETzogUm93cyBkb24ndCB1c2UgdGFiSW5kZXgsIGJ1dCBqdXN0IGV4Y2x1ZGluZyBwcm9wcyBoZXJlIGlzLi4ud2VpcmQuXG4gICAgICAgIC8vci5hc0NoaWxkUm93UmV0dXJuLnJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4ucHJvcHNVbnN0YWJsZSxcbiAgICAgICAgci5hc0NoaWxkUm93UmV0dXJuLnNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuLnByb3BzVW5zdGFibGUsXG4gICAgICAgIHIuYXNQYXJlbnRSb3dSZXR1cm4ubGluZWFyTmF2aWdhdGlvblJldHVybi5wcm9wc1N0YWJsZSxcbiAgICAgICAgci5hc1BhcmVudFJvd1JldHVybi50eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuLnByb3BzU3RhYmxlLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4ucHJvcHNTdGFibGVcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBhc1BhcmVudFJvd1JldHVybixcbiAgICAgICAgYXNDaGlsZFJvd1JldHVybixcblxuICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm4sXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVyblxuXG4gICAgICAgIC8vbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICAvLy4uLmdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdENoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pih7XG4gICAgZ3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVycyxcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIGNvbnRleHQ6IHsgY29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQsIGdyaWROYXZpZ2F0aW9uQ2VsbENvbnRleHQsIG1hbmFnZWRDaGlsZENvbnRleHQsIHJvdmluZ1RhYkluZGV4Q2hpbGRDb250ZXh0LCB0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0IH0sXG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgIC8vbWFuYWdlZENoaWxkQ29udGV4dCxcbiAgICBjb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnMsXG4gICAgcHJlc3NQYXJhbWV0ZXJzOiB7IG9uUHJlc3NTeW5jLCAuLi5wcmVzc1BhcmFtZXRlcnMgfSxcbn06IFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgTT4pOiBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQsIE0+IHtcblxuICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM7XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8Q2VsbEVsZW1lbnQ+KHsgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9IH0pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLFxuICAgICAgICB0ZXh0Q29udGVudFJldHVyblxuICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNlbGw8Q2VsbEVsZW1lbnQ+KHtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dCxcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVycyxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnNcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgaGFzQ3VycmVudEZvY3VzUmV0dXJuIH0gPSB1c2VIYXNDdXJyZW50Rm9jdXM8Q2VsbEVsZW1lbnQ+KHsgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczogeyBvbkN1cnJlbnRGb2N1c2VkQ2hhbmdlZDogbnVsbCwgLi4uaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVycyB9LCByZWZFbGVtZW50UmV0dXJuIH0pO1xuXG5cblxuICAgIGNvbnN0IHsgcHJlc3NSZXR1cm4gfSA9IHVzZVByZXNzPENlbGxFbGVtZW50Pih7XG4gICAgICAgIHByZXNzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25QcmVzc1N5bmM6IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvblByZXNzU3luYz4+KGUgPT4ge1xuICAgICAgICAgICAgICAgIG9uUHJlc3NTeW5jPy4oZSk7XG4gICAgICAgICAgICAgICAgY29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQub25QcmVzc1N5bmM/LihlKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLi4ucHJlc3NQYXJhbWV0ZXJzXG4gICAgICAgIH0sXG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm5cbiAgICB9KTtcblxuXG5cbiAgICBjb25zdCBiYXNlSW5mbzogR3JpZFNpbmdsZVNlbGVjdENoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+ID0ge1xuICAgICAgICBmb2N1c1NlbGY6IHByZXNzUGFyYW1ldGVycy5mb2N1c1NlbGYsXG4gICAgICAgIGdldEVsZW1lbnQ6IHJlZkVsZW1lbnRSZXR1cm4uZ2V0RWxlbWVudCxcbiAgICAgICAgaGlkZGVuOiByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycy5oaWRkZW4sXG4gICAgICAgIGluZGV4OiBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLmluZGV4LFxuICAgICAgICBnZXRUYWJiYWJsZTogcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybi5nZXRUYWJiYWJsZSxcbiAgICAgICAgc2V0VGFiYmFibGU6IHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4uc2V0VGFiYmFibGUsXG4gICAgICAgIHRhYmJhYmxlOiByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLnRhYmJhYmxlXG4gICAgfVxuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRSZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZDxNPih7XG4gICAgICAgIGNvbnRleHQ6IHsgbWFuYWdlZENoaWxkQ29udGV4dCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH1cbiAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAuLi5iYXNlSW5mbyxcbiAgICAgICAgICAgIC4uLmNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyc1xuICAgICAgICB9IGFzIE0pXG5cbiAgICBjb25zdCBwcm9wcyA9IHVzZU1lcmdlZFByb3BzKFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuLnByb3BzU3RhYmxlLFxuICAgICAgICBwcmVzc1JldHVybi5wcm9wc1N0YWJsZSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybi5wcm9wc1Vuc3RhYmxlLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4ucHJvcHNTdGFibGVcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4sXG4gICAgICAgIHByZXNzUmV0dXJuLFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgdGV4dENvbnRlbnRSZXR1cm5cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiwgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCB9IGZyb20gXCIuLi9jb21wb25lbnQtZGV0YWlsL3VzZS1saXN0LW5hdmlnYXRpb24tc2luZ2xlLXNlbGVjdGlvblwiO1xuaW1wb3J0IHsgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkUmV0dXJuVHlwZSwgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL2NvbXBvbmVudC1kZXRhaWwvdXNlLWxpc3QtbmF2aWdhdGlvbi1zaW5nbGUtc2VsZWN0aW9uLXNvcnRhYmxlXCI7XG5pbXBvcnQgeyBVc2VTb3J0YWJsZUNoaWxkSW5mbywgdXNlU29ydGFibGVDaGlsZHJlbiB9IGZyb20gXCIuLi9jb21wb25lbnQtZGV0YWlsL3VzZS1zb3J0YWJsZS1jaGlsZHJlblwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi4vZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCIuLi9kb20taGVscGVycy91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZUNoaWxkcmVuSGF2ZUZvY3VzLCB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkLCBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVycywgVXNlQ2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL29ic2VydmVycy91c2UtY2hpbGRyZW4taGF2ZS1mb2N1c1wiO1xuaW1wb3J0IHsgdXNlSGFzQ3VycmVudEZvY3VzLCBVc2VIYXNDdXJyZW50Rm9jdXNSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL29ic2VydmVycy91c2UtaGFzLWN1cnJlbnQtZm9jdXNcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZHJlbiwgdXNlTWFuYWdlZENoaWxkLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUsIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGUgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZU9iamVjdCB9IGZyb20gXCIuLi9wcmVhY3QtZXh0ZW5zaW9ucy91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlUHJlc3MsIFVzZVByZXNzUGFyYW1ldGVycywgVXNlUHJlc3NSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXByZXNzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4+IGV4dGVuZHMgUGljazxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUGFyYW1ldGVyczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+LCBcInNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNcIj4ge1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVQYXJhbWV0ZXJzPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT5bXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJnZXRIaWdoZXN0SW5kZXhcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiB8IFwiaW5kZXhNYW5nbGVyXCIgfCBcImlzVmFsaWRcIj47XG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPltcInR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXCJdLCBcImlzVmFsaWRcIj47XG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogT21pdDxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUGFyYW1ldGVyczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+W1wicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiXSwgXCJnZXRIaWdoZXN0Q2hpbGRJbmRleFwiIHwgXCJnZXRWYWxpZFwiPjtcbiAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPltcInNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXCJdO1xuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogT21pdDxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUGFyYW1ldGVyczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+W1wicm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzXCJdLCBcImluaXRpYWxseVRhYmJlZEluZGV4XCI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+PlxuICAgIGV4dGVuZHMgUGljazxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+LCBcInJvdmluZ1RhYkluZGV4UmV0dXJuXCIgfCBcInNpbmdsZVNlbGVjdGlvblJldHVyblwiIHwgXCJsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuXCIgfCBcInR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5cIiB8IFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuXCIgfCBcInNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5cIj4ge1xuICAgIHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PjtcbiAgICBjb250ZXh0OiBDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ29udGV4dDxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+O1xuXG4gICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0+W1wibWFuYWdlZENoaWxkcmVuUmV0dXJuXCJdO1xuICAgIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuOiBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGU8Q2hpbGRFbGVtZW50PltcImNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuXCJdO1xuICAgIC8vcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogUGljazxVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzW1wicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiXSwgXCJnZXRIaWdoZXN0Q2hpbGRJbmRleFwiIHwgXCJnZXRWYWxpZFwiPjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0PFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+PiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TT4sXG4gICAgUGljazxVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGU8Q2hpbGRFbGVtZW50PiwgXCJjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dFwiPixcbiAgICBQaWNrPFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVSZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4sIFwic2luZ2xlU2VsZWN0aW9uQ29udGV4dFwiIHwgXCJyb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dFwiIHwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRDb250ZXh0XCI+IHtcbiAgICBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dDogVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcImNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRDb250ZXh0XCJdO1xufVxuXG4vKipcbiAqIEFsbCB0aGUgbGlzdC1yZWxhdGVkIGhvb2tzIGNvbWJpbmVkIGludG8gb25lIGdpYW50IGhvb2sgdGhhdCBlbmNhcHN1bGF0ZXMgZXZlcnl0aGluZy5cbiAqIFxuICogVW5saWtlIG1vc3Qgb3RoZXJzLCB0aGlzIGhvb2sgYXNzdW1lJ3MgaXQncyB0aGUgZmluYWwgb25lLS10aGUgXCJvdXRlcm1vc3RcIiBob29rIGluIHRoZSBjb21wb25lbnQtLXNvIGl0IHVzZXMgYHVzZU1hbmFnZWRDaGlsZHJlbmAgYW5kIHdyYXBzIGV2ZXJ5dGhpbmcgdXAgbmljZWx5LFxuICogY29tYmluaW5nIGV2ZW50IGhhbmRsZXJzIHRoYXQgYXJlIHVzZWQgaW4gbXVsdGlwbGUgc3ViLWhvb2tzLCBjb2xsZWN0aW5nIGFsbCB0aGUgbmVjZXNzYXJ5IGNvbnRleHQtcmVsYXRlZCBkYXRhLCBhbmQgbWVyZ2luZyBhbGwga25vd24gRE9NIHByb3BzIHRvZ2V0aGVyLlxuICogXG4gKiBcbiAqIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+Pih7XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyxcbiAgICAuLi5jb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc1xufTogVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPik6IFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4ge1xuICAgIC8vdHlwZSBNID0gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZEluZm88Q2hpbGRFbGVtZW50PjtcbiAgICBjb25zdCB7IGluaXRpYWxseVNlbGVjdGVkSW5kZXggfSA9IHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM7XG4gICAgY29uc3QgZ2V0Q2hpbGRyZW46ICgpID0+IE1hbmFnZWRDaGlsZHJlbjxNPiA9IHVzZUNhbGxiYWNrKCgpID0+IG1hbmFnZWRDaGlsZHJlblJldHVybi5nZXRDaGlsZHJlbigpLCBbXSk7XG4gICAgY29uc3QgZ2V0SGlnaGVzdENoaWxkSW5kZXg6ICgoKSA9PiBudW1iZXIpID0gdXNlQ2FsbGJhY2s8KCkgPT4gbnVtYmVyPigoKSA9PiBnZXRDaGlsZHJlbigpLmdldEhpZ2hlc3RJbmRleCgpLCBbXSk7XG4gICAgY29uc3QgZ2V0VmFsaWQgPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gZ2V0Q2hpbGRyZW4oKS5nZXRBdChpKTtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuICFjaGlsZC5oaWRkZW47XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm4gfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgTT4oe1xuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9ID0gcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ29udGV4dCxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IGdldENoaWxkcmVuIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdENoaWxkSW5kZXgsIGlzVmFsaWQ6IGdldFZhbGlkLCBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCAuLi5saW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBpc1ZhbGlkOiBnZXRWYWxpZCwgLi4udHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IGluaXRpYWxseVRhYmJlZEluZGV4OiBpbml0aWFsbHlTZWxlY3RlZEluZGV4LCAuLi5yb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgLi4uY29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgfSk7XG5cbiAgICAvL2NvbnN0IHsgbGluZWFyTmF2aWdhdGlvblJldHVybiwgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybiB9ID0gbGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZVJldHVybjtcblxuICAgIGNvbnN0IHsgY2hpbGRyZW5IYXZlRm9jdXNDaGlsZENvbnRleHQsIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuIH0gPSB1c2VDaGlsZHJlbkhhdmVGb2N1cyh7IGNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyB9KTtcbiAgICBjb25zdCB7IGNvbnRleHQ6IHsgbWFuYWdlZENoaWxkQ29udGV4dCB9LCBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxNPih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMgfSk7XG4gICAgY29uc3QgcHJvcHMgPSB1c2VNZXJnZWRQcm9wczxQYXJlbnRFbGVtZW50PihsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLnByb3BzU3RhYmxlLCB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuLnByb3BzU3RhYmxlKTtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlU3RhYmxlT2JqZWN0PENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0PFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4+KHtcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ29udGV4dCxcbiAgICAgICAgbWFuYWdlZENoaWxkQ29udGV4dCxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRDb250ZXh0XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBwcm9wcyxcblxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+LCBFeHRyYU9taXRzIGV4dGVuZHMga2V5b2YgTT4ge1xuICAgIGNvbnRleHQ6IENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0PGFueSwgQ2hpbGRFbGVtZW50LCBNPjtcbiAgICBwcmVzc1BhcmFtZXRlcnM6IFVzZVByZXNzUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1wicHJlc3NQYXJhbWV0ZXJzXCJdO1xuICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1wic2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzXCJdO1xuICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1widGV4dENvbnRlbnRQYXJhbWV0ZXJzXCJdO1xuICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IE9taXQ8TSwga2V5b2YgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+IHwgRXh0cmFPbWl0cz47XG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcInJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzXCJdO1xuICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIl07XG4gICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnM6IFBpY2s8VXNlU29ydGFibGVDaGlsZEluZm8sIFwiZ2V0U29ydFZhbHVlXCI+O1xuICAgIC8vc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiBQaWNrPFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiXSwgXCJkaXNhYmxlZFwiPjtcbiAgICAvL21hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+LCBcImdldEVsZW1lbnRcIiB8IFwiZ2V0U2VsZWN0ZWRcIiB8IFwic2V0U2VsZWN0ZWRcIiB8IFwiZ2V0VGFiYmFibGVcIiB8IFwic2V0VGFiYmFibGVcIiB8IFwidGFiYmFibGVcIiB8IFwic2VsZWN0ZWRcIiB8IFwiZm9jdXNTZWxmXCI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm88Q2hpbGRFbGVtZW50Pj5cbiAgICBleHRlbmRzIFBpY2s8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+LCBcInNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuXCIgfCBcInJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5cIj4ge1xuICAgIHByZXNzUmV0dXJuOiBVc2VQcmVzc1JldHVyblR5cGU8Q2hpbGRFbGVtZW50PltcInByZXNzUmV0dXJuXCJdO1xuICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybjogVXNlSGFzQ3VycmVudEZvY3VzUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+W1wiaGFzQ3VycmVudEZvY3VzUmV0dXJuXCJdO1xuICAgIG1hbmFnZWRDaGlsZFJldHVybjogVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTxNPltcIm1hbmFnZWRDaGlsZFJldHVyblwiXTtcbiAgICBwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbzxDaGlsZEVsZW1lbnQ+LCBFeHRyYU9taXRzIGV4dGVuZHMgRXhjbHVkZTxrZXlvZiBNLCBrZXlvZiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4+Pih7XG4gICAgLy9tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbiwgZGlzYWJsZWQsIGluZGV4LCBnZXRTb3J0VmFsdWUgfSxcbiAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICBjb250ZXh0OiB7IGNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRDb250ZXh0LCBtYW5hZ2VkQ2hpbGRDb250ZXh0LCByb3ZpbmdUYWJJbmRleENoaWxkQ29udGV4dCwgc2luZ2xlU2VsZWN0aW9uQ29udGV4dCwgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCB9LFxuICAgIHByZXNzUGFyYW1ldGVyczogeyBvblByZXNzU3luYzogb3BzMSwgLi4ucHJlc3NQYXJhbWV0ZXJzIH0sXG4gICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnM6IHsgZ2V0U29ydFZhbHVlIH0sXG4gICAgLi4uX3ZvaWRcbn06IFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBNLCBFeHRyYU9taXRzPik6IFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50LCBNPiB7XG4gICAgY29uc3QgeyBoaWRkZW4gfSA9IHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzO1xuICAgIGNvbnN0IHsgaW5kZXggfSA9IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM7XG4gICAgbGV0IHsgZGlzYWJsZWQgfSA9IHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycztcbiAgICBpZiAoaGlkZGVuKVxuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8Q2hpbGRFbGVtZW50Pih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcbiAgICBjb25zdCB7IGdldEVsZW1lbnQgfSA9IHJlZkVsZW1lbnRSZXR1cm47XG4gICAgY29uc3QgeyBmb2N1c1NlbGYgfSA9IHByZXNzUGFyYW1ldGVycztcbiAgICBjb25zdCB7XG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogb2NmaWMxIH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczogeyBvblByZXNzU3luYzogb3BzMiwgLi4ucDEgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgc2V0TG9jYWxTZWxlY3RlZCB9XG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50Pih7XG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IHsgaGlkZGVuIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczogeyAuLi5zaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNvbnRleHQsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZENvbnRleHQsXG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHsgZ2V0VGFiYmFibGUsIHNldFRhYmJhYmxlLCB0YWJiYWJsZSB9ID0gcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybjtcblxuICAgIGNvbnN0IHsgcHJlc3NSZXR1cm4gfSA9IHVzZVByZXNzPENoaWxkRWxlbWVudD4oe1xuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIC4uLnAxLFxuICAgICAgICAgICAgLi4ucHJlc3NQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgb25QcmVzc1N5bmM6IGRpc2FibGVkID8gbnVsbCA6ICgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIG9wczI/LihlKTtcbiAgICAgICAgICAgICAgICBvcHMxPy4oZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LCByZWZFbGVtZW50UmV0dXJuXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IGdldFNlbGVjdGVkLCBzZWxlY3RlZCB9ID0gc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm47XG5cbiAgICBjb25zdCBtY3AxOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlQ2hpbGRJbmZvPENoaWxkRWxlbWVudD4gPSB7XG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICBmb2N1c1NlbGYsXG4gICAgICAgIGdldEVsZW1lbnQsXG4gICAgICAgIGdldFNlbGVjdGVkLFxuICAgICAgICBnZXRUYWJiYWJsZSxcbiAgICAgICAgaGlkZGVuLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgc2VsZWN0ZWQsXG4gICAgICAgIHNldExvY2FsU2VsZWN0ZWQsXG4gICAgICAgIHNldFRhYmJhYmxlLFxuICAgICAgICB0YWJiYWJsZSxcbiAgICAgICAgZ2V0U29ydFZhbHVlXG4gICAgfVxuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRSZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZDxNPih7IGNvbnRleHQ6IHsgbWFuYWdlZENoaWxkQ29udGV4dCB9LCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0gfSwgeyAuLi5tY3AxLCAuLi5jb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzIH0gYXMgTSk7XG5cbiAgICBjb25zdCB7IGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogb2NmaWMyIH0gfSA9IHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGQoeyBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkQ29udGV4dCB9KTtcbiAgICBjb25zdCBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9jZmljMT4+KChmb2N1c2VkLCBwcmV2LCBlKSA9PiB7XG4gICAgICAgIG9jZmljMT8uKGZvY3VzZWQsIHByZXYsIGUpO1xuICAgICAgICBvY2ZpYzI/Lihmb2N1c2VkLCBwcmV2LCBlKTtcbiAgICB9KVxuICAgIGNvbnN0IHsgaGFzQ3VycmVudEZvY3VzUmV0dXJuIH0gPSB1c2VIYXNDdXJyZW50Rm9jdXM8Q2hpbGRFbGVtZW50Pih7IGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25DdXJyZW50Rm9jdXNlZENoYW5nZWQ6IG51bGwgfSwgcmVmRWxlbWVudFJldHVybiB9KTtcblxuXG4gICAgY29uc3QgcHJvcHMgPSB1c2VNZXJnZWRQcm9wczxDaGlsZEVsZW1lbnQ+KFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuLnByb3BzU3RhYmxlLFxuICAgICAgICBwcmVzc1JldHVybi5wcm9wc1N0YWJsZSxcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuLnByb3BzU3RhYmxlLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLnByb3BzVW5zdGFibGUsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuLnByb3BzVW5zdGFibGVcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHByZXNzUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVybixcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm5cbiAgICB9XG5cbn1cblxuLypcbmZ1bmN0aW9uIGZvbzxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm88Q2hpbGRFbGVtZW50Pj4ocDogVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPikge1xuICAgIGNvbnN0IHsgc2luZ2xlU2VsZWN0aW9uUmV0dXJuIH0gPSB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4ocCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgdXNlU2luZ2xlU2VsZWN0aW9uRGVjbGFyYXRpdmUoeyBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sIHNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlUGFyYW1ldGVyczogeyBzZWxlY3RlZEluZGV4IH0gfSlcbn0qL1xuIiwiaW1wb3J0IHsgRGlzbWlzc0xpc3RlbmVyVHlwZXMsIHVzZURpc21pc3MsIFVzZURpc21pc3NQYXJhbWV0ZXJzLCBVc2VEaXNtaXNzUmV0dXJuVHlwZSB9IGZyb20gXCIuLi9jb21wb25lbnQtZGV0YWlsL3VzZS1kaXNtaXNzXCI7XG5pbXBvcnQgeyB1c2VGb2N1c1RyYXAsIFVzZUZvY3VzVHJhcFBhcmFtZXRlcnMsIFVzZUZvY3VzVHJhcFJldHVyblR5cGUgfSBmcm9tIFwiLi4vY29tcG9uZW50LWRldGFpbC91c2UtZm9jdXMtdHJhcFwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi4vZG9tLWhlbHBlcnMvdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VNb2RhbFBhcmFtZXRlcnM8TGlzdGVuZXJzIGV4dGVuZHMgRGlzbWlzc0xpc3RlbmVyVHlwZXM+IGV4dGVuZHMgVXNlRGlzbWlzc1BhcmFtZXRlcnM8TGlzdGVuZXJzPiB7XG4gICAgZm9jdXNUcmFwUGFyYW1ldGVyczogVXNlRm9jdXNUcmFwUGFyYW1ldGVyczxhbnksIGFueT5bXCJmb2N1c1RyYXBQYXJhbWV0ZXJzXCJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1vZGFsUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHwgbnVsbCwgU291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQgfCBudWxsLCBQb3B1cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZURpc21pc3NSZXR1cm5UeXBlPFNvdXJjZUVsZW1lbnQsIFBvcHVwRWxlbWVudD4ge1xuICAgIHByb3BzRm9jdXNDb250YWluZXI6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE5vbk51bGxhYmxlPEZvY3VzQ29udGFpbmVyRWxlbWVudD4+O1xuICAgIHByb3BzUG9wdXA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwRWxlbWVudD47XG4gICAgcHJvcHNTb3VyY2U6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE5vbk51bGxhYmxlPFNvdXJjZUVsZW1lbnQ+PjtcbiAgICBmb2N1c1RyYXBSZXR1cm46IE9taXQ8VXNlRm9jdXNUcmFwUmV0dXJuVHlwZTxOb25OdWxsYWJsZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+PltcImZvY3VzVHJhcFJldHVyblwiXSwgXCJwcm9wc1Vuc3RhYmxlXCI+O1xufVxuXG4vKipcbiAqIENvbWJpbmVzIGRpc21pc3NhbCBob29rcyBhbmQgZm9jdXMgdHJhcCBob29rcyBpbnRvIG9uZS5cbiAqIFxuICogQW5vdGhlciBpbiB0aGUgXCJjb21wbGV0ZVwiIHNlcmllcywgYWxvbmdzaWRlIGxpc3QvZ3JpZCBuYXZpZ2F0aW9uIGFuZCBkaXNtaXNzYWwgaXRzZWxmLlxuICogXG4gKiBVc2UgZm9yIGRpYWxvZ3MsIG1lbnVzLCBldGMuICBBbnl0aGluZyB0aGF0IGNhbiBiZSBkaXNtaXNzZWQgYW5kIG1pZ2h0IHRyYXAgZm9jdXMsIGJhc2ljYWxseS5cbiAqIFxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTW9kYWw8TGlzdGVuZXJzIGV4dGVuZHMgRGlzbWlzc0xpc3RlbmVyVHlwZXMsIEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQgfCBudWxsLCBTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB8IG51bGwsIFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBkaXNtaXNzUGFyYW1ldGVycyxcbiAgICBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycyxcbiAgICBmb2N1c1RyYXBQYXJhbWV0ZXJzOiB7IHRyYXBBY3RpdmUsIC4uLmZvY3VzVHJhcFBhcmFtZXRlcnMgfVxufTogVXNlTW9kYWxQYXJhbWV0ZXJzPExpc3RlbmVycz4pOiBVc2VNb2RhbFJldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBQb3B1cEVsZW1lbnQ+IHtcbiAgICBjb25zdCB7IG9wZW4gfSA9IGRpc21pc3NQYXJhbWV0ZXJzO1xuICAgIC8vY29uc3QgeyBnZXRXaW5kb3cgfSA9IGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzO1xuICAgIC8vY29uc3QgZ2V0RG9jdW1lbnQgPSB1c2VDYWxsYmFjaygoKSA9PiB7IHJldHVybiBnZXRXaW5kb3coKS5kb2N1bWVudDsgfSwgW2dldFdpbmRvd10pO1xuICAgIGNvbnN0IHsgcmVmRWxlbWVudFBvcHVwUmV0dXJuLCByZWZFbGVtZW50U291cmNlUmV0dXJuIH0gPSB1c2VEaXNtaXNzPExpc3RlbmVycywgU291cmNlRWxlbWVudCwgUG9wdXBFbGVtZW50Pih7IGRpc21pc3NQYXJhbWV0ZXJzLCBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycyB9KTtcbiAgICBjb25zdCB7IGZvY3VzVHJhcFJldHVybiwgcmVmRWxlbWVudFJldHVybiB9ID0gdXNlRm9jdXNUcmFwPFNvdXJjZUVsZW1lbnQsIE5vbk51bGxhYmxlPEZvY3VzQ29udGFpbmVyRWxlbWVudD4+KHtcbiAgICAgICAgZm9jdXNUcmFwUGFyYW1ldGVyczogeyB0cmFwQWN0aXZlOiBvcGVuICYmIHRyYXBBY3RpdmUsIC4uLmZvY3VzVHJhcFBhcmFtZXRlcnMgfSxcbiAgICAgICAgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHByb3BzU3RhYmxlOiBwcDEgfSA9IHJlZkVsZW1lbnRQb3B1cFJldHVybjtcbiAgICBjb25zdCB7IHByb3BzU3RhYmxlOiBwczIgfSA9IHJlZkVsZW1lbnRTb3VyY2VSZXR1cm47XG4gICAgY29uc3QgeyBwcm9wc1Vuc3RhYmxlOiBwcDMgfSA9IGZvY3VzVHJhcFJldHVybjtcbiAgICBjb25zdCB7IHByb3BzU3RhYmxlOiBwcDQgfSA9IHJlZkVsZW1lbnRSZXR1cm5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzUG9wdXA6IHBwMSxcbiAgICAgICAgcHJvcHNGb2N1c0NvbnRhaW5lcjogdXNlTWVyZ2VkUHJvcHMocHAzLCBwcDQpLFxuICAgICAgICBwcm9wc1NvdXJjZTogcHMyLFxuICAgICAgICByZWZFbGVtZW50UG9wdXBSZXR1cm4sXG4gICAgICAgIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm4sXG4gICAgICAgIGZvY3VzVHJhcFJldHVybixcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlSWQsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGdlbmVyYXRlUmFuZG9tSWQgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmV4cG9ydCB7IGdlbmVyYXRlUmFuZG9tSWQgfTtcblxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkUmV0dXJuVHlwZTxTIGV4dGVuZHMgRWxlbWVudCwgVCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBwcm9wc1NvdXJjZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uz47XG4gICAgcHJvcHNSZWZlcmVuY2VyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcblxuICAgIC8qKlxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBUaGUgZWxlbWVudCB0aGF0IG5lZWRzIGEgY3VzdG9tIGBpZGAgcHJvcCBtdXN0IHVzZSB0aGlzIGhvb2suXG4gICAgICovXG4gICAgLy91c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTPjtcblxuICAgIC8qKlxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKiBcbiAgICAgKiBBbnkgZWxlbWVudCB0aGF0IHJlZmVyZW5jZXMgdGhlIGlkIHZpYSBgZm9yYCBvciBgYXJpYS1sYWJlbGxlZGJ5YCwgZXRjLiBtdXN0IHVzZSB0aGlzIGhvb2suXG4gICAgICogXG4gICAgICogVGhpcyBob29rIGNhbiBiZSB1c2VkIG11bHRpcGxlIHRpbWVzIG9uIGRpZmZlcmVudCBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIC8vdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDtcbiAgICByYW5kb21JZFJldHVybjogeyBpZDogc3RyaW5nOyB9O1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFBhcmFtZXRlcnMge1xuICAgIHJhbmRvbUlkUGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hpbGUgYWxsIElEcyBhcmUgdW5pcXVlLCB0aGlzIGNhbiBiZSB1c2VkIHRvIG1vcmUgZWFzaWx5IGRpZmZlcmVudGlhdGUgdGhlbS5cbiAgICAgICAgICogXG4gICAgICAgICAqIElmIHRoaXMgaXMgc3RhYmxlLCB0aGVuIHlvdXIgcHJvcHMgYXJlIHN0YWJsZS4gU2ltcGxlIGFzIHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBwcmVmaXg6IHN0cmluZztcbiAgICBcbiAgICAgICAgLyoqIFRoaXMgaXMgdGhlIHByb3Agb24gdGhlICoqT1RIRVIqKiBlbGVtZW50IHRoYXQgd2lsbCB1c2Ugb3VyIElELiAgRS5HLiBUaGUgYGlucHV0YCBjYWxscyBgdXNlUmFuZG9tSWRgIGFuZCBwYXNzZXMgYGZvcmAgYXMgYHJlZmVyZW5jZXJQcm9wYC4gKi9cbiAgICAgICAgb3RoZXJSZWZlcmVuY2VyUHJvcDoga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiB8IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUmFuZG9tSWQ8UyBleHRlbmRzIEVsZW1lbnQsIFQgZXh0ZW5kcyBFbGVtZW50Pih7IHJhbmRvbUlkUGFyYW1ldGVyczogeyBwcmVmaXgsIG90aGVyUmVmZXJlbmNlclByb3AgfSB9OiBVc2VSYW5kb21JZFBhcmFtZXRlcnMpOiBVc2VSYW5kb21JZFJldHVyblR5cGU8UywgVD4ge1xuICAgIGNvbnN0IGlkID0gKHByZWZpeCArIHVzZUlkKCkpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVJhbmRvbUlkXCIsIHByZWZpeCwgaWQpO1xuXG4gICAgY29uc3QgcmVmZXJlbmNlckVsZW1lbnRQcm9wcyA9IHVzZVJlZjxoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+PihvdGhlclJlZmVyZW5jZXJQcm9wID09IG51bGwgPyB7fSA6IHsgW290aGVyUmVmZXJlbmNlclByb3BdOiBpZCB9KTtcbiAgICBjb25zdCBzb3VyY2VFbGVtZW50UHJvcHMgPSB1c2VSZWY8aC5KU1guSFRNTEF0dHJpYnV0ZXM8Uz4+KHsgaWQgfSk7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFwiLCBvdGhlclJlZmVyZW5jZXJQcm9wKTtcbiAgICBcblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzUmVmZXJlbmNlcjogcmVmZXJlbmNlckVsZW1lbnRQcm9wcy5jdXJyZW50LFxuICAgICAgICBwcm9wc1NvdXJjZTogc291cmNlRWxlbWVudFByb3BzLmN1cnJlbnQsXG4gICAgICAgIHJhbmRvbUlkUmV0dXJuOiB7XG4gICAgICAgICAgICBpZDogaWRcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4uL2RvbS1oZWxwZXJzL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VSYW5kb21JZCwgVXNlUmFuZG9tSWRQYXJhbWV0ZXJzLCBVc2VSYW5kb21JZFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmFuZG9tLWlkXCI7XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21EdWFsSWRzUGFyYW1ldGVycyB7XG4gICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IFVzZVJhbmRvbUlkUGFyYW1ldGVyc1tcInJhbmRvbUlkUGFyYW1ldGVyc1wiXTtcbiAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogVXNlUmFuZG9tSWRQYXJhbWV0ZXJzW1wicmFuZG9tSWRQYXJhbWV0ZXJzXCJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUR1YWxJZHNSZXR1cm5UeXBlPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBwcm9wc0lucHV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+O1xuICAgIHByb3BzTGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XG4gICAgcmFuZG9tSWRJbnB1dFJldHVybjogVXNlUmFuZG9tSWRSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcInJhbmRvbUlkUmV0dXJuXCJdO1xuICAgIHJhbmRvbUlkTGFiZWxSZXR1cm46IFVzZVJhbmRvbUlkUmV0dXJuVHlwZTxMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudD5bXCJyYW5kb21JZFJldHVyblwiXTtcbn1cblxuLyoqXG4gKiBXaGlsZSBgdXNlUmFuZG9tSWRgIGFsbG93cyB0aGUgcmVmZXJlbmNlciB0byB1c2UgdGhlIHNvdXJjZSdzIElELCBzb21ldGltZXMgeW91IGFsc28gd2FudCB0aGUgcmV2ZXJzZSB0b28gKGUuZy4gSSBgYXJpYS1sYWJlbGAgeW91LCB5b3UgYGFyaWEtY29udHJvbHNgIG1lLiBUaGF0IHNvcnQgb2YgdGhpbmcpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmFuZG9tRHVhbElkczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMsXG4gICAgcmFuZG9tSWRMYWJlbFBhcmFtZXRlcnMsXG59OiBVc2VSYW5kb21EdWFsSWRzUGFyYW1ldGVycyk6IFVzZVJhbmRvbUR1YWxJZHNSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XG5cbiAgICBjb25zdCB7IHJhbmRvbUlkUmV0dXJuOiByYW5kb21JZElucHV0UmV0dXJuLCBwcm9wc1JlZmVyZW5jZXI6IHByb3BzTGFiZWxBc1JlZmVyZW5jZXIsIHByb3BzU291cmNlOiBwcm9wc0lucHV0QXNTb3VyY2UgfSA9IHVzZVJhbmRvbUlkPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50Pih7IHJhbmRvbUlkUGFyYW1ldGVyczogcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMgfSk7XG4gICAgY29uc3QgeyByYW5kb21JZFJldHVybjogcmFuZG9tSWRMYWJlbFJldHVybiwgcHJvcHNSZWZlcmVuY2VyOiBwcm9wc0lucHV0QXNSZWZlcmVuY2VyLCBwcm9wc1NvdXJjZTogcHJvcHNMYWJlbEFzU291cmNlIH0gPSB1c2VSYW5kb21JZDxMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudD4oeyByYW5kb21JZFBhcmFtZXRlcnM6IHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHNMYWJlbDogdXNlTWVyZ2VkUHJvcHM8TGFiZWxFbGVtZW50Pihwcm9wc0xhYmVsQXNSZWZlcmVuY2VyLCBwcm9wc0xhYmVsQXNTb3VyY2UpLFxuICAgICAgICBwcm9wc0lucHV0OiB1c2VNZXJnZWRQcm9wczxJbnB1dEVsZW1lbnQ+KHByb3BzSW5wdXRBc1JlZmVyZW5jZXIsIHByb3BzSW5wdXRBc1NvdXJjZSksXG4gICAgICAgIHJhbmRvbUlkSW5wdXRSZXR1cm4sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxSZXR1cm5cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxudHlwZSBSYWZDYWxsYmFja1R5cGUgPSAobXNTaW5jZUxhc3Q6IG51bWJlciwgdGFnPzogYW55KSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgQ29udGV4dFR5cGUge1xuICAgIGFkZENhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSwgdGFnPzogYW55KSA9PiB2b2lkO1xuICAgIHJlbW92ZUNhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxudWxsIHwgQ29udGV4dFR5cGU+KG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gUHJvdmlkZUJhdGNoZWRBbmltYXRpb25GcmFtZXMoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbiB9KSB7XG5cbiAgICBjb25zdCBhZGRDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wiYWRkQ2FsbGJhY2tcIl0+KChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuc2V0KGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZyk7IH0sIFtdKTtcbiAgICBjb25zdCByZW1vdmVDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wicmVtb3ZlQ2FsbGJhY2tcIl0+KChjYWxsYmFjaykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5kZWxldGUoY2FsbGJhY2spOyB9LCBbXSk7XG5cbiAgICBjb25zdCBjb250ZXh0SW5mbyA9IHVzZVJlZjxDb250ZXh0VHlwZT4obnVsbCEpO1xuICAgIGlmIChjb250ZXh0SW5mby5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGNvbnRleHRJbmZvLmN1cnJlbnQgPSB7IGFkZENhbGxiYWNrLCByZW1vdmVDYWxsYmFjayB9O1xuICAgIGNvbnN0IGFsbENhbGxiYWNrcyA9IHVzZVJlZjxNYXA8UmFmQ2FsbGJhY2tUeXBlLCBhbnk+PihudWxsISk7XG4gICAgaWYgKGFsbENhbGxiYWNrcy5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGFsbENhbGxiYWNrcy5jdXJyZW50ID0gbmV3IE1hcCgpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZSA9IC0xO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKG1zU2luY2VMYXN0OiBudW1iZXIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2JhdGNoZWRSYWZDYWxsYmFjaywgdGFnXSBvZiBhbGxDYWxsYmFja3MuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGJhdGNoZWRSYWZDYWxsYmFjayhtc1NpbmNlTGFzdCwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRJbmZvLmN1cnJlbnR9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L1NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlcj4pXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB3aXRoIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHJ1bGVzIGFzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXG4gICAgICogXG4gICAgICogRG9lc24ndCBuZWVkIHRvIGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBjYWxsYmFjazogbnVsbCB8ICgobXNTaW5jZUxhc3Q6IG51bWJlcikgPT4gdm9pZCk7XG59XG5cbi8qKlxuICogVGhlIChvcHRpb25hbGx5IG5vbi1zdGFibGUpIGBjYWxsYmFja2AgeW91IHByb3ZpZGUgd2lsbCBzdGFydCBydW5uaW5nIGV2ZXJ5IGZyYW1lIGFmdGVyIHRoZSBjb21wb25lbnQgbW91bnRzLlxuICogXG4gKiBQYXNzaW5nIGBudWxsYCBpcyBmaW5lIGFuZCBzaW1wbHkgc3RvcHMgdGhlIGVmZmVjdCB1bnRpbCB5b3UgcmVzdGFydCBpdCBieSBwcm92aWRpbmcgYSBub24tbnVsbCBjYWxsYmFjay5cbiAqIFxuICogKipUaGlzIGhvb2sgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGF0IGFsbCwgaW5jbHVkaW5nIG5vIHByb3AtbW9kaWZ5aW5nIGhvb2tzKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFuaW1hdGlvbkZyYW1lKHsgY2FsbGJhY2sgfTogVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIGdpdmVuIGNhbGxiYWNrIHRoYXQncyBzdGFibGVcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKGNhbGxiYWNrID8/IG5vb3ApO1xuICAgIGNvbnN0IGhhc0NhbGxiYWNrID0gKGNhbGxiYWNrICE9IG51bGwpO1xuXG4gICAgY29uc3Qgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gdXNlQ29udGV4dChTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LmFkZENhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5yZW1vdmVDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgd3JhcHBlciBhcm91bmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbHNvIGNhbGxzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFnYWluLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZkNhbGxiYWNrID0gKG1zOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlQ2FsbGJhY2sobXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQsIGhhc0NhbGxiYWNrXSlcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHsgfVxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vcHJlYWN0LWV4dGVuc2lvbnMvdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4uL3ByZWFjdC1leHRlbnNpb25zL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGltZW91dFBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbXMgdG8gd2FpdCBiZWZvcmUgaW52b2tpbmcgYGNhbGxiYWNrYC4gIFxuICAgICAqIElmIGBudWxsYCwgY2FuY2VscyB0aGUgdGltZW91dCBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICB0aW1lb3V0OiBudW1iZXIgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0byB0aGlzIHByb3AgYmV0d2VlbiByZW5kZXJzIGNhbiBiZSB1c2VkIHRvIGNsZWFyIHRoZSBjdXJyZW50IHRpbWVvdXQgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICovXG4gICAgdHJpZ2dlckluZGV4PzogdW5rbm93bjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBgdGltZW91dGAgbXMgYWZ0ZXIgbW91bnQsIG9yIHRoZSBsYXN0IGNoYW5nZSB0byBgdHJpZ2dlckluZGV4YC5cbiAgICAgKiBcbiAgICAgKiBEb2VzICpub3QqIG5lZWQgdG8gYmUgc3RhYmxlLiBHbyBhaGVhZCBhbmQgcGFzcyBhbiBhbm9ueW1vdXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUaW1lb3V0KHsgdGltZW91dCwgY2FsbGJhY2ssIHRyaWdnZXJJbmRleCB9OiBVc2VUaW1lb3V0UGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBzdGFydFRpbWVSZWYuY3VycmVudCA9IG51bGw7IGNhbGxiYWNrKCk7IH0pO1xuICAgIGNvbnN0IGdldFRpbWVvdXQgPSB1c2VTdGFibGVHZXR0ZXIodGltZW91dCk7XG5cbiAgICAvLyBTZXQgYW55IHRpbWUgd2Ugc3RhcnQgdGltZW91dC5cbiAgICAvLyBVbnNldCBhbnkgdGltZSB0aGUgdGltZW91dCBjb21wbGV0ZXNcbiAgICBjb25zdCBzdGFydFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCB0aW1lb3V0SXNOdWxsID0gKHRpbWVvdXQgPT0gbnVsbCk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgdHJpZ2dlckluZGV4IGNoYW5nZXMgKGluY2x1ZGluZyBvbiBtb3VudClcbiAgICAvLyByZXN0YXJ0IHRoZSB0aW1lb3V0LiAgVGhlIHRpbWVvdXQgZG9lcyBOT1QgcmVzZXRcbiAgICAvLyB3aGVuIHRoZSBkdXJhdGlvbiBvciBjYWxsYmFjayBjaGFuZ2VzLCBvbmx5IHRyaWdnZXJJbmRleC5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRpbWVvdXRJc051bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aW1lb3V0SXNOdWxsID09ICh0aW1lb3V0ID09IG51bGwpKTtcbiAgICBcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVSZWYuY3VycmVudCA9ICsobmV3IERhdGUoKSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChzdGFibGVDYWxsYmFjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sIFt0cmlnZ2VySW5kZXgsIHRpbWVvdXRJc051bGxdKVxuXG4gICAgY29uc3QgZ2V0RWxhcHNlZFRpbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKyhuZXcgRGF0ZSgpKSkgLSAoKyhzdGFydFRpbWVSZWYuY3VycmVudCA/PyBuZXcgRGF0ZSgpKSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0UmVtYWluaW5nVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgcmV0dXJuIHRpbWVvdXQgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1heCgwLCB0aW1lb3V0IC0gZ2V0RWxhcHNlZFRpbWUoKSlcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyBnZXRFbGFwc2VkVGltZSwgZ2V0UmVtYWluaW5nVGltZSB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzLCB1c2VQcmVzcywgVXNlUHJlc3NQYXJhbWV0ZXJzLCBVc2VQcmVzc1JldHVyblR5cGUsIHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBEaXNhYmxlZFR5cGUsIEVsZW1lbnRUb1RhZywgRW5oYW5jZWRFdmVudCwgZW5oYW5jZUV2ZW50IH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuXG5leHBvcnQgdHlwZSBCdXR0b25QcmVzc0V2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSBFbmhhbmNlZEV2ZW50PEUsIEV2ZW50IHwgRXZlbnQsIHsgcHJlc3NlZDogYm9vbGVhbiB8IG51bGwgfT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQnV0dG9uUGFyYW1ldGVyczxFIGV4dGVuZHMgTm9kZT4gZXh0ZW5kcyBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxFPiB7XG4gICAgYnV0dG9uUGFyYW1ldGVyczoge1xuICAgICAgICB0YWdCdXR0b246IEVsZW1lbnRUb1RhZzxFPjtcbiAgICAgICAgZGlzYWJsZWQ6IERpc2FibGVkVHlwZTtcbiAgICAgICAgcHJlc3NlZDogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgICAgIG9uUHJlc3M6IG51bGwgfCAoKGV2ZW50OiBCdXR0b25QcmVzc0V2ZW50PEU+KSA9PiB2b2lkKTtcbiAgICAgICAgcm9sZTogc3RyaW5nO1xuICAgIH1cbiAgICBwcmVzc1BhcmFtZXRlcnM6IE9taXQ8VXNlUHJlc3NQYXJhbWV0ZXJzPEU+W1wicHJlc3NQYXJhbWV0ZXJzXCJdLCBcIm9uUHJlc3NTeW5jXCIgfCBcImZvY3VzU2VsZlwiPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJ1dHRvblJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUHJlc3NSZXR1cm5UeXBlPEU+LCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiB7XG4gICAgcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUJ1dHRvbjxFIGV4dGVuZHMgRWxlbWVudD4oeyBidXR0b25QYXJhbWV0ZXJzOiB7IHRhZ0J1dHRvbiwgZGlzYWJsZWQsIG9uUHJlc3MsIHByZXNzZWQsIHJvbGUgfSwgcHJlc3NQYXJhbWV0ZXJzLCByZWZFbGVtZW50UGFyYW1ldGVycyB9OiBVc2VCdXR0b25QYXJhbWV0ZXJzPEU+KTogVXNlQnV0dG9uUmV0dXJuVHlwZTxFPiB7XG4gICAgZGVidWdMb2coXCJ1c2VCdXR0b25cIik7XG5cbiAgICBjb25zdCByZWZFbGVtZW50UmV0dXJuID0gdXNlUmVmRWxlbWVudDxFPih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzIH0pO1xuICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKChlOiBhbnkpID0+IChlIGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLmZvY3VzPy4oKSwgW10pXG4gICAgY29uc3QgcHJlc3NSZXR1cm4gPSB1c2VQcmVzczxFPih7XG4gICAgICAgIC4uLnJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25QcmVzc1N5bmM6IChlKSA9PiAoZGlzYWJsZWQgPyBudWxsIDogb25QcmVzcyk/LihlbmhhbmNlRXZlbnQoZSwgeyBwcmVzc2VkOiBwcmVzc2VkID09IG51bGwgPyBudWxsIDogIXByZXNzZWQgfSkpLFxuICAgICAgICAgICAgZm9jdXNTZWxmLFxuICAgICAgICAgICAgLi4ucHJlc3NQYXJhbWV0ZXJzXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHByZXNzUmV0dXJuOiB7IHByb3BzU3RhYmxlOiBwcmVzc1Byb3BzIH0gfSA9IHByZXNzUmV0dXJuO1xuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybjogeyBwcm9wc1N0YWJsZTogcmVmUHJvcHMgfSB9ID0gcmVmRWxlbWVudFJldHVybjtcblxuICAgIGNvbnN0IGJhc2VQcm9wcyA9IHsgXCJhcmlhLXByZXNzZWRcIjogKHByZXNzZWQgPT09IHRydWUgPyBcInRydWVcIiA6IHByZXNzZWQgPT09IGZhbHNlID8gXCJmYWxzZVwiIDogdW5kZWZpbmVkKSB9O1xuICAgIGNvbnN0IGJ1dHRvblByb3BzID0geyAuLi5iYXNlUHJvcHMsIGRpc2FibGVkOiAoZGlzYWJsZWQgJiYgZGlzYWJsZWQgIT0gXCJzb2Z0XCIpID8gdHJ1ZSA6IGZhbHNlLCBcImFyaWEtZGlzYWJsZWRcIjogKGRpc2FibGVkID09PSAnc29mdCcgPyAndHJ1ZScgOiB1bmRlZmluZWQpLCByb2xlOiByb2xlID09IFwiYnV0dG9uXCIgPyB1bmRlZmluZWQgOiByb2xlIH07XG4gICAgY29uc3QgZGl2UHJvcHMgPSB7IC4uLmJhc2VQcm9wcywgdGFiSW5kZXg6IChkaXNhYmxlZCA9PT0gXCJoYXJkXCIgPyAtMSA6IDApLCByb2xlLCBcImFyaWEtZGlzYWJsZWRcIjogZGlzYWJsZWQgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9O1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICAuLi5wcmVzc1JldHVybixcbiAgICAgICAgcHJvcHM6IHVzZU1lcmdlZFByb3BzPEU+KHByZXNzUHJvcHMsIHJlZlByb3BzLCAodGFnQnV0dG9uID09ICdidXR0b24nID8gYnV0dG9uUHJvcHMgOiBkaXZQcm9wcykpLFxuICAgIH1cbn1cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkSW5mbywgT25DaGlsZHJlbk1vdW50Q2hhbmdlLCBQYXNzaXZlU3RhdGVVcGRhdGVyLCB1c2VDaGlsZHJlbkZsYWcsIHVzZUxpbmVhck5hdmlnYXRpb24sIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGQsIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuQ29udGV4dCwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSwgdXNlTWVyZ2VkUHJvcHMsIFVzZVByZXNzUmV0dXJuVHlwZSwgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSwgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YWJsZU9iamVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBEaXNhYmxlZFR5cGUsIFByZWZpY2VzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IEJ1dHRvblByZXNzRXZlbnQsIHVzZUJ1dHRvbiwgVXNlQnV0dG9uUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1idXR0b25cIjtcblxuLy9leHBvcnQgdHlwZSBVc2VBY2NvcmRpb248TSBleHRlbmRzIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvPiA9IChhcmdzOiBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzPE0+KSA9PiBVc2VBY2NvcmRpb25SZXR1cm5UeXBlPE0+O1xuLy9leHBvcnQgdHlwZSBVc2VBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4gPSAoYXJnczogVXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyRWxlbWVudCwgTT4pID0+IFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxNPiB7XG4gICAgYWNjb3JkaW9uUGFyYW1ldGVyczogeyBpbml0aWFsSW5kZXg/OiBudW1iZXIgfCBudWxsOyB9XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IE9taXQ8VXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudD5bXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJuYXZpZ2F0ZVJlbGF0aXZlXCIgfCBcIm5hdmlnYXRlQWJzb2x1dGVcIiB8IFwiZ2V0SGlnaGVzdEluZGV4XCIgfCBcImlzVmFsaWRcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiB8IFwiaW5kZXhNYW5nbGVyXCI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblJldHVyblR5cGU8SGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlPE0+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGFjY29yZGlvblJldHVybjogeyBjaGFuZ2VFeHBhbmRlZEluZGV4OiBQYXNzaXZlU3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGwsIEV2ZW50PiB9XG4gICAgY29udGV4dDogVXNlQWNjb3JkaW9uQ29udGV4dDxIZWFkZXJCdXR0b25FbGVtZW50LCBNPjtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXI+IHtcbiAgICBzZXRPcGVuRnJvbVBhcmVudChvcGVuOiBib29sZWFuKTogdm9pZDtcbiAgICBnZXRPcGVuRnJvbVBhcmVudCgpOiBib29sZWFuIHwgbnVsbDtcbiAgICBzZXRNb3N0UmVjZW50bHlUYWJiZWQodGFiYmVkOiBib29sZWFuKTogdm9pZDtcbiAgICBnZXRNb3N0UmVjZW50bHlUYWJiZWQoKTogYm9vbGVhbiB8IG51bGw7XG4gICAgZm9jdXNTZWxmKCk6IHZvaWQ7XG4gICAgZGlzYWJsZWQ6IERpc2FibGVkVHlwZTtcbiAgICBoaWRkZW46IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4gZXh0ZW5kc1xuICAgIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQ+IHtcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBPbWl0PFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT5bXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCJdLCBcInNldE9wZW5Gcm9tUGFyZW50XCIgfCBcImdldE9wZW5Gcm9tUGFyZW50XCIgfCBcInNldE1vc3RSZWNlbnRseVRhYmJlZFwiIHwgXCJnZXRNb3N0UmVjZW50bHlUYWJiZWRcIiB8IFwiZm9jdXNTZWxmXCIgfCBcImRpc2FibGVkXCI+O1xuICAgIGNvbnRleHQ6IFVzZUFjY29yZGlvbkNvbnRleHQ8SGVhZGVyQnV0dG9uRWxlbWVudCwgTT47XG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IFBpY2s8VXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8YW55PltcInJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzXCJdLCBcImhpZGRlblwiPjtcbiAgICBhY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAvKiogXG4gICAgICAgICAqIElmIHRoaXMgcHJvcCBpcyBgdHJ1ZWAgb3IgYGZhbHNlYCBpc24ndCBudWxsLCB0aGVuIHRoaXMgc2VjdGlvblxuICAgICAgICAgKiB3aWxsIGJlIG9wZW4vY2xvc2VkIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGUgcGFyZW50J3Mgc2luZ3VsYXIgb3BlbiBpbmRleCBpcy5cbiAgICAgICAgICogXG4gICAgICAgICAqIEluIG90aGVyIHdvcmRzLCBsZWF2ZSBudWxsIHRvIG9ubHkgYWxsb3cgb25lIHNlY3Rpb24gdG8gYmUgb3BlbiBhdCBhIHRpbWUsXG4gICAgICAgICAqIG9yIHRvIGFsbG93IG11bHRpcGxlIHNlY3Rpb25zIHRvIGJlIG9wZW4gYXQgb25jZSwgXG4gICAgICAgICAqIHNldCB0aGUgcGFyZW50J3MgaW5kZXggdG8gbnVsbCBhbmQgdG9nZ2xlIHRoaXMgYHRydWVgL2BmYWxzZWAgd2hlbiB0aGUgYnV0dG9uJ3MgcHJlc3NlZFxuICAgICAgICAgKi9cbiAgICAgICAgb3BlbjogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqIEdlbmVyYWxseSBgXCJyZWdpb25cImAgKi9cbiAgICAgICAgYm9keVJvbGU6IHN0cmluZztcbiAgICB9XG4gICAgYnV0dG9uUGFyYW1ldGVyczogT21pdDxVc2VCdXR0b25QYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQ+W1wiYnV0dG9uUGFyYW1ldGVyc1wiXSwgXCJwcmVzc2VkXCIgfCBcInJvbGVcIj47XG4gICAgcHJlc3NQYXJhbWV0ZXJzOiBPbWl0PFVzZUJ1dHRvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudD5bXCJwcmVzc1BhcmFtZXRlcnNcIl0sIFwib25QcmVzc1N5bmNcIj47XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZTxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VQcmVzc1JldHVyblR5cGU8SGVhZGVyQnV0dG9uRWxlbWVudD4sIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEhlYWRlckJ1dHRvbkVsZW1lbnQ+IHtcbiAgICBhY2NvcmRpb25TZWN0aW9uUmV0dXJuOiB7XG4gICAgICAgIGV4cGFuZGVkOiBib29sZWFuO1xuICAgICAgICBmb2N1c2VkOiBib29sZWFuO1xuICAgICAgICBtb3N0UmVjZW50bHlUYWJiZWQ6IGJvb2xlYW47XG4gICAgfVxuXG4gICAgcHJvcHNIZWFkZXJCdXR0b246IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckJ1dHRvbkVsZW1lbnQ+O1xuICAgIHByb3BzSGVhZGVyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PjtcbiAgICBwcm9wc0JvZHk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvbkNvbnRleHQ8SGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+IHtcbiAgICBhY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICBjaGFuZ2VUYWJiZWRJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsLCBFdmVudD47XG4gICAgICAgIGNoYW5nZUV4cGFuZGVkSW5kZXg6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbCwgRXZlbnQ+O1xuICAgICAgICBnZXRFeHBhbmRlZEluZGV4OiAoKSA9PiAobnVtYmVyIHwgbnVsbCk7XG4gICAgICAgIGdldFRhYmJlZEluZGV4OiAoKSA9PiAobnVtYmVyIHwgbnVsbCk7XG4gICAgfVxuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxIZWFkZXJCdXR0b25FbGVtZW50LCBIZWFkZXJCdXR0b25FbGVtZW50PltcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCJdO1xuICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuOiBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxIZWFkZXJCdXR0b25FbGVtZW50LCBIZWFkZXJCdXR0b25FbGVtZW50PltcInJvdmluZ1RhYkluZGV4UmV0dXJuXCJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQWNjb3JkaW9uPEhlYWRlckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+KHtcbiAgICBhY2NvcmRpb25QYXJhbWV0ZXJzOiB7IGluaXRpYWxJbmRleCB9LFxuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiwgbmF2aWdhdGVQYXN0RW5kLCBuYXZpZ2F0ZVBhc3RTdGFydCwgcGFnZU5hdmlnYXRpb25TaXplIH0sXG4gICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9XG59OiBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQsIE0+KTogVXNlQWNjb3JkaW9uUmV0dXJuVHlwZTxIZWFkZXJCdXR0b25FbGVtZW50LCBNPiB7XG4gICAgZGVidWdMb2coXCJ1c2VBY2NvcmRpYW5cIik7XG4gICAgLy9jb25zdCBbX2N1cnJlbnRGb2N1c2VkSW5kZXgsIHNldEN1cnJlbnRGb2N1c2VkSW5kZXgsIGdldEN1cnJlbnRGb2N1c2VkSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCBtY1JldHVyblR5cGUgPSB1c2VNYW5hZ2VkQ2hpbGRyZW48TT4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobSwgdSkgPT4geyBvY21jMigpOyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihtLCB1KTsgfSksXG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3RcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHsgZ2V0Q2hpbGRyZW4gfSwgY29udGV4dCB9ID0gbWNSZXR1cm5UeXBlO1xuXG4gICAgY29uc3QgaXNWYWxpZCA9IHVzZUNhbGxiYWNrKChjOiBNKSA9PiAoIWMuZGlzYWJsZWQgJiYgIWMuaGlkZGVuKSwgW10pO1xuICAgIGNvbnN0IGlzVmFsaWQyID0gdXNlQ2FsbGJhY2soKGM6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGdldENoaWxkcmVuKCkuZ2V0QXQoYyk7XG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBbXSk7XG5cblxuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXg6IGNoYW5nZUV4cGFuZGVkSW5kZXgsIGdldEN1cnJlbnRJbmRleDogZ2V0Q3VycmVudEV4cGFuZGVkSW5kZXggfSA9IHVzZUNoaWxkcmVuRmxhZzxNLCBFdmVudD4oe1xuICAgICAgICBpbml0aWFsSW5kZXgsXG4gICAgICAgIGdldENoaWxkcmVuLFxuICAgICAgICBnZXRBdDogdXNlQ2FsbGJhY2soKGNoaWxkKSA9PiB7IHJldHVybiBjaGlsZC5nZXRPcGVuRnJvbVBhcmVudCgpID8/IGZhbHNlOyB9LCBbXSksXG4gICAgICAgIHNldEF0OiB1c2VDYWxsYmFjaygoY2hpbGQsIG9wZW4pID0+IHsgcmV0dXJuIGNoaWxkLnNldE9wZW5Gcm9tUGFyZW50KG9wZW4pOyB9LCBbXSksXG4gICAgICAgIGlzVmFsaWQsXG4gICAgICAgIG9uSW5kZXhDaGFuZ2U6IG51bGwsXG4gICAgICAgIC8va2V5OiBcIm9wZW5cIixcbiAgICAgICAgY2xvc2VzdEZpdDogZmFsc2VcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXg6IGNoYW5nZVRhYmJlZEluZGV4LCBnZXRDdXJyZW50SW5kZXg6IGdldFRhYmJlZEluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdDogb2NtYzIgfSA9IHVzZUNoaWxkcmVuRmxhZzxNLCBFdmVudD4oe1xuICAgICAgICBpbml0aWFsSW5kZXgsXG4gICAgICAgIGdldENoaWxkcmVuLFxuICAgICAgICBnZXRBdDogdXNlQ2FsbGJhY2soKGNoaWxkKSA9PiB7IHJldHVybiBjaGlsZC5nZXRNb3N0UmVjZW50bHlUYWJiZWQoKSA/PyBmYWxzZTsgfSwgW10pLFxuICAgICAgICBzZXRBdDogdXNlQ2FsbGJhY2soKGNoaWxkLCB0YWJiZWQpID0+IHsgcmV0dXJuIGNoaWxkLnNldE1vc3RSZWNlbnRseVRhYmJlZCh0YWJiZWQpOyB9LCBbXSksXG4gICAgICAgIGlzVmFsaWQsXG4gICAgICAgIGNsb3Nlc3RGaXQ6IHRydWUsXG4gICAgICAgIG9uSW5kZXhDaGFuZ2U6IHVzZUNhbGxiYWNrKChpOiBudW1iZXIgfCBudWxsKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ2V0Q2hpbGRyZW4oKS5nZXRBdChpKT8uZm9jdXNTZWxmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKVxuICAgIH0pXG5cbiAgICAvL2NvbnN0IG5hdmlnYXRlQWJzb2x1dGUgPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyKSA9PiB7IHJldHVybiBjaGFuZ2VUYWJiZWRJbmRleChpKTsgfSwgW10pO1xuICAgIC8vY29uc3QgbmF2aWdhdGVSZWxhdGl2ZSA9IHVzZUNhbGxiYWNrKChzOiBudW1iZXIsIG86IG51bWJlcikgPT4geyByZXR1cm4gY2hhbmdlVGFiYmVkSW5kZXgobyArIHMpOyB9LCBbXSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdDxVc2VBY2NvcmRpb25Db250ZXh0PEhlYWRlckJ1dHRvbkVsZW1lbnQsIE0+Pih7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgYWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgY2hhbmdlRXhwYW5kZWRJbmRleCxcbiAgICAgICAgICAgICAgICBjaGFuZ2VUYWJiZWRJbmRleCxcbiAgICAgICAgICAgICAgICBnZXRFeHBhbmRlZEluZGV4OiBnZXRDdXJyZW50RXhwYW5kZWRJbmRleCxcbiAgICAgICAgICAgICAgICBnZXRUYWJiZWRJbmRleDogZ2V0VGFiYmVkSW5kZXhcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICAgICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgICAgICAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiB1c2VDYWxsYmFjaygoKSA9PiBnZXRDaGlsZHJlbigpLmdldEhpZ2hlc3RJbmRleCgpLCBbXSksXG4gICAgICAgICAgICAgICAgaW5kZXhNYW5nbGVyOiBpZGVudGl0eSxcbiAgICAgICAgICAgICAgICBpbmRleERlbWFuZ2xlcjogaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICBpc1ZhbGlkOiBpc1ZhbGlkMixcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVBhc3RFbmQsXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQsXG4gICAgICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuOiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlSW5kZXg6IGdldFRhYmJlZEluZGV4LFxuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXg6IGNoYW5nZVRhYmJlZEluZGV4XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBtY1JldHVyblR5cGUubWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICBhY2NvcmRpb25SZXR1cm46IHVzZVN0YWJsZU9iamVjdCh7IGNoYW5nZUV4cGFuZGVkSW5kZXggfSlcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eTxUPih0OiBUKSB7IHJldHVybiB0OyB9XG5cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY2NvcmRpb25TZWN0aW9uPF9IZWFkZXJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGJ1dHRvblBhcmFtZXRlcnMsXG4gICAgcHJlc3NQYXJhbWV0ZXJzOiB7IGV4Y2x1ZGUgfSxcbiAgICBhY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczogeyBvcGVuOiBvcGVuRnJvbVVzZXIsIGJvZHlSb2xlIH0sXG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbiB9LFxuICAgIC8vbWFuYWdlZENoaWxkQ29udGV4dCxcbiAgICBjb250ZXh0LFxuICAgIGNvbnRleHQ6IHtcbiAgICAgICAgYWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM6IHsgY2hhbmdlRXhwYW5kZWRJbmRleCwgY2hhbmdlVGFiYmVkSW5kZXg6IF9zZXRDdXJyZW50Rm9jdXNlZEluZGV4LCBnZXRUYWJiZWRJbmRleDogZ2V0Q3VycmVudEZvY3VzZWRJbmRleCB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm5cbiAgICB9LFxuICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzLFxufTogVXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudCwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+KTogVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGU8X0hlYWRlckNvbnRhaW5lckVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQsIEJvZHlFbGVtZW50PiB7XG5cbiAgICBjb25zdCB7IGRpc2FibGVkLCBvblByZXNzOiB1c2VyT25QcmVzcyB9ID0gYnV0dG9uUGFyYW1ldGVycztcblxuICAgIGRlYnVnTG9nKFwidXNlQWNjb3JkaWFuU2VjdGlvblwiKTtcbiAgICBjb25zdCBbb3BlbkZyb21QYXJlbnQsIHNldE9wZW5Gcm9tUGFyZW50LCBnZXRPcGVuRnJvbVBhcmVudF0gPSB1c2VTdGF0ZTxib29sZWFuIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW21vc3RSZWNlbnRseVRhYmJlZCwgc2V0TW9zdFJlY2VudGx5VGFiYmVkLCBnZXRNb3N0UmVjZW50bHlUYWJiZWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KG51bGwpO1xuXG4gICAgdHlwZSBNID0gVXNlQWNjb3JkaW9uU2VjdGlvbkluZm87XG5cblxuICAgIGNvbnN0IHsgcmFuZG9tSWRSZXR1cm46IF9ib2R5SWRSZXR1cm4sIHByb3BzU291cmNlOiBwcm9wc0JvZHlTb3VyY2UsIHByb3BzUmVmZXJlbmNlcjogcHJvcHNIZWFkUmVmZXJlbmNlciB9ID0gdXNlUmFuZG9tSWQ8Qm9keUVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQ+KHsgcmFuZG9tSWRQYXJhbWV0ZXJzOiB7IHByZWZpeDogUHJlZmljZXMuYWNjb3JkaW9uU2VjdGlvbkhlYWRlckJ1dHRvbiwgb3RoZXJSZWZlcmVuY2VyUHJvcDogXCJhcmlhLWNvbnRyb2xzXCIgfSB9KTtcbiAgICBjb25zdCB7IHJhbmRvbUlkUmV0dXJuOiBfaGVhZElkUmV0dXJuLCBwcm9wc1NvdXJjZTogcHJvcHNIZWFkU291cmNlLCBwcm9wc1JlZmVyZW5jZXI6IHByb3BzQm9keVJlZmVyZW5jZXIgfSA9IHVzZVJhbmRvbUlkPEhlYWRlckJ1dHRvbkVsZW1lbnQsIEJvZHlFbGVtZW50Pih7IHJhbmRvbUlkUGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLmFjY29yZGlvblNlY3Rpb25Cb2R5LCBvdGhlclJlZmVyZW5jZXJQcm9wOiBcImFyaWEtbGFiZWxsZWRieVwiIH0gfSk7XG4gICAgLy9jb25zdCB7IHJhbmRvbUlkU291cmNlUmV0dXJuOiB7IHByb3BzU3RhYmxlOiB1c2VCb2R5QXNTb3VyY2VJZFByb3BzIH0gfSA9IHVzZUJvZHlBc1NvdXJjZUlkKCk7XG4gICAgLy9jb25zdCB7IHJhbmRvbUlkUmVmZXJlbmNlclJldHVybjogeyBwcm9wc1N0YWJsZTogdXNlQm9keUFzUmVmZXJlbmNlcklkUHJvcHMgfSB9ID0gdXNlQm9keUFzUmVmZXJlbmNlcklkPEJvZHlFbGVtZW50Pih7IHJhbmRvbUlkUmVmZXJlbmNlclBhcmFtZXRlcnM6IHsgb3RoZXJSZWZlcmVuY2VyUHJvcDogXCJhcmlhLWNvbnRyb2xzXCIgYXMgbmV2ZXIgfSB9KTtcbiAgICAvL2NvbnN0IHsgcmFuZG9tSWRTb3VyY2VSZXR1cm46IHsgcHJvcHNTdGFibGU6IHVzZUhlYWRlckFzU291cmNlSWRQcm9wcyB9IH0gPSB1c2VIZWFkZXJBc1NvdXJjZUlkKCk7XG4gICAgLy9jb25zdCB7IHJhbmRvbUlkUmVmZXJlbmNlclJldHVybjogeyBwcm9wc1N0YWJsZTogdXNlSGVhZGVyQXNSZWZlcmVuY2VySWRQcm9wcyB9IH0gPSB1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZDxIZWFkZXJFbGVtZW50Pih7IHJhbmRvbUlkUmVmZXJlbmNlclBhcmFtZXRlcnM6IHsgb3RoZXJSZWZlcmVuY2VyUHJvcDogXCJhcmlhLWxhYmVsbGVkYnlcIiBhcyBuZXZlciB9IH0pO1xuXG4gICAgY29uc3Qgb3BlbiA9ICgob3BlbkZyb21Vc2VyID8/IG9wZW5Gcm9tUGFyZW50KSA/PyBmYWxzZSk7XG4gICAgLy9jb25zdCBnZXRPcGVuID0gdXNlU3RhYmxlR2V0dGVyKCEhb3Blbik7XG4gICAgY29uc3QgX2dldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZGV4KTtcblxuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50OiBnZXRIZWFkZXJFbGVtZW50LCBwcm9wc1N0YWJsZTogaGVhZGVyUmVmRWxlbWVudFByb3BzIH0gfSA9IHVzZVJlZkVsZW1lbnQ8SGVhZGVyQnV0dG9uRWxlbWVudD4oeyByZWZFbGVtZW50UGFyYW1ldGVyczoge30gfSk7XG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQ6IF9nZXRCb2R5RWxlbWVudCwgcHJvcHNTdGFibGU6IGJvZHlSZWZFbGVtZW50UHJvcHMgfSB9ID0gdXNlUmVmRWxlbWVudDxCb2R5RWxlbWVudD4oeyByZWZFbGVtZW50UGFyYW1ldGVyczoge30gfSk7XG4gICAgY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAvL2lmIChnZXRDdXJyZW50Rm9jdXNlZEluZGV4KCkgIT0gbnVsbClcbiAgICAgICAgICAgIChnZXRIZWFkZXJFbGVtZW50KCkgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCB8IHVuZGVmaW5lZCk/LmZvY3VzKCk7XG4gICAgfSwgW10pO1xuICAgIC8qY29uc3Qgb3BlblJlZiA9IHVzZVJlZih7XG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0T3BlbkZyb21QYXJlbnQoKSxcbiAgICAgICAgICAgIHNldDogKG9wZW46IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgICAgICBzZXRPcGVuRnJvbVBhcmVudChvcGVuKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlFbGVtZW50ID0gZ2V0Qm9keUVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudEZvY3VzZWRJbmRleChnZXRJbmRleCgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBib2R5RWxlbWVudC5mb2N1cygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNWYWxpZDogcmV0dXJuVHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdGFiYmVkUmVmID0gdXNlUmVmKHtcbiAgICAgICAgICAgIGdldDogKCkgPT4gKGdldEN1cnJlbnRGb2N1c2VkSW5kZXgoKSA9PSBnZXRJbmRleCgpKSxcbiAgICAgICAgICAgIHNldDogKG9wZW46IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3BlbilcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudEZvY3VzZWRJbmRleChnZXRJbmRleCgpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1ZhbGlkOiByZXR1cm5UcnVlXG4gICAgfSk7Ki9cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZFJldHVybjogeyBnZXRDaGlsZHJlbjogX2dldFNlY3Rpb25zIH0gfSA9IHVzZU1hbmFnZWRDaGlsZDxNPih7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICBmb2N1c1NlbGYsXG4gICAgICAgIGdldE1vc3RSZWNlbnRseVRhYmJlZCxcbiAgICAgICAgZ2V0T3BlbkZyb21QYXJlbnQsXG4gICAgICAgIGhpZGRlbixcbiAgICAgICAgc2V0TW9zdFJlY2VudGx5VGFiYmVkLFxuICAgICAgICBzZXRPcGVuRnJvbVBhcmVudCxcbiAgICB9KTtcblxuICAgIC8vY29uc3Qgb25Gb2N1cyA9ICgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoaW5kZXgpOyB9XG4gICAgY29uc3Qgb25QcmVzcyA9IChlOiBCdXR0b25QcmVzc0V2ZW50PEhlYWRlckJ1dHRvbkVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIGlmIChnZXRPcGVuRnJvbVBhcmVudCgpKVxuICAgICAgICAgICAgY2hhbmdlRXhwYW5kZWRJbmRleChudWxsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2hhbmdlRXhwYW5kZWRJbmRleChpbmRleCk7XG5cbiAgICAgICAgdXNlck9uUHJlc3M/LihlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgeyBwcmVzc1JldHVybiwgcHJvcHM6IGJ1dHRvblByb3BzLCByZWZFbGVtZW50UmV0dXJuIH0gPSB1c2VCdXR0b248SGVhZGVyQnV0dG9uRWxlbWVudD4oe1xuICAgICAgICBidXR0b25QYXJhbWV0ZXJzOiB7IC4uLmJ1dHRvblBhcmFtZXRlcnMsIHByZXNzZWQ6IG51bGwsIG9uUHJlc3MsIHJvbGU6IFwiYnV0dG9uXCIgfSxcbiAgICAgICAgcHJlc3NQYXJhbWV0ZXJzOiB7IGV4Y2x1ZGUgfSxcbiAgICAgICAgcmVmRWxlbWVudFBhcmFtZXRlcnNcbiAgICB9KTtcblxuXG4gICAgY29uc3QgbGluZWFyUmV0dXJuVHlwZSA9IHVzZUxpbmVhck5hdmlnYXRpb248SGVhZGVyQnV0dG9uRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudD4oeyBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgcm92aW5nVGFiSW5kZXhSZXR1cm4gfSk7XG5cbiAgICBjb25zdCB7IGxpbmVhck5hdmlnYXRpb25SZXR1cm46IHsgcHJvcHNTdGFibGUgfSB9ID0gbGluZWFyUmV0dXJuVHlwZTtcblxuICAgIC8qZnVuY3Rpb24gdXNlQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzKHsgW1wiYXJpYS1leHBhbmRlZFwiXTogYXJpYUV4cGFuZGVkLCBbXCJhcmlhLWRpc2FibGVkXCJdOiBhcmlhRGlzYWJsZWQsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4ge1xuXG4gICAgICAgICAgICBwcm9wcy50YWJJbmRleCA9IDA7XG5cblxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKHVzZUhlYWRlckFzU291cmNlSWRQcm9wcywgdXNlSGVhZGVyQXNSZWZlcmVuY2VySWRQcm9wcywgcHJvcHNTdGFibGUsIHtcbiAgICAgICAgICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogKGFyaWFFeHBhbmRlZCA/PyBvcGVuID8/IGZhbHNlKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiAoYXJpYURpc2FibGVkID8/IChvcGVuID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQpKSxcbiAgICAgICAgICAgICAgICAuLi51c2VNZXJnZWRQcm9wcyhoZWFkZXJSZWZFbGVtZW50UHJvcHMsIHVzZUJ1dHRvblByb3BzKHByb3BzKSlcbiAgICAgICAgICAgIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4pO1xuICAgICAgICB9XG5cblxuICAgICAgICBmdW5jdGlvbiB1c2VBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzKHsgcm9sZSwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+IHtcbiAgICAgICAgICAgIGNvbnN0IHJldDEgPSB1c2VNZXJnZWRQcm9wcyh1c2VCb2R5QXNSZWZlcmVuY2VySWRQcm9wcywgeyByb2xlOiByb2xlID8/IFwicmVnaW9uXCIsIC4uLnByb3BzIH0pO1xuICAgICAgICAgICAgY29uc3QgcmV0MiA9IHVzZU1lcmdlZFByb3BzKHVzZUJvZHlBc1NvdXJjZUlkUHJvcHMsIHJldDEpO1xuICAgICAgICAgICAgcmV0Mi50YWJJbmRleCA/Pz0gLTE7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoYm9keVJlZkVsZW1lbnRQcm9wcywgcmV0Mik7XG4gICAgfSovXG5cbiAgICBjb25zdCBoZWFkZXJCdXR0b25Qcm9wcyA9IHVzZU1lcmdlZFByb3BzPEhlYWRlckJ1dHRvbkVsZW1lbnQ+KFxuICAgICAgICBidXR0b25Qcm9wcyxcbiAgICAgICAgaGVhZGVyUmVmRWxlbWVudFByb3BzLFxuICAgICAgICBwcm9wc0hlYWRSZWZlcmVuY2VyLFxuICAgICAgICBwcm9wc0hlYWRTb3VyY2UsXG4gICAgICAgIHByb3BzU3RhYmxlLFxuICAgICAgICB7IFwiYXJpYS1leHBhbmRlZFwiOiAob3BlbiA/PyBmYWxzZSkudG9TdHJpbmcoKSwgfVxuICAgICk7XG5cbiAgICBjb25zdCBib2R5UHJvcHMgPSB1c2VNZXJnZWRQcm9wczxCb2R5RWxlbWVudD4oXG4gICAgICAgIGJvZHlSZWZFbGVtZW50UHJvcHMsXG4gICAgICAgIHByb3BzQm9keVJlZmVyZW5jZXIsXG4gICAgICAgIHByb3BzQm9keVNvdXJjZSxcbiAgICAgICAge1xuICAgICAgICAgICAgcm9sZTogYm9keVJvbGUsXG4gICAgICAgICAgICB0YWJJbmRleDogLTFcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVzc1JldHVybixcbiAgICAgICAgcmVmRWxlbWVudFJldHVybixcbiAgICAgICAgYWNjb3JkaW9uU2VjdGlvblJldHVybjoge1xuICAgICAgICAgICAgbW9zdFJlY2VudGx5VGFiYmVkOiAhIW1vc3RSZWNlbnRseVRhYmJlZCxcbiAgICAgICAgICAgIGV4cGFuZGVkOiBvcGVuLFxuICAgICAgICAgICAgZm9jdXNlZDogKGdldEN1cnJlbnRGb2N1c2VkSW5kZXgoKSA9PSBpbmRleClcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHNIZWFkZXJCdXR0b246IGhlYWRlckJ1dHRvblByb3BzLFxuICAgICAgICBwcm9wc0hlYWRlcjoge30sICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBlbXB0eSwgaXQncyBqdXN0IGEgcmVtaW5kZXIgdGhhdCB0aGVyZSAqZG9lcyogbmVlZCB0byBiZSBhIGhlYWRlciB0aGF0IGNvbnRhaW5zIHRoZSBidXR0b24uXG4gICAgICAgIHByb3BzQm9keTogYm9keVByb3BzXG4gICAgfTtcbn0iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMsIHVzZVByZXNzLCBVc2VQcmVzc1JldHVyblR5cGUsIHVzZVJhbmRvbUR1YWxJZHMsIFVzZVJhbmRvbUR1YWxJZHNQYXJhbWV0ZXJzLCBVc2VSYW5kb21EdWFsSWRzUmV0dXJuVHlwZSwgVXNlUmVmRWxlbWVudFJldHVyblR5cGUsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBEaXNhYmxlZFR5cGUsIEVsZW1lbnRUb1RhZyB9IGZyb20gXCIuL3Byb3BzXCI7XG5cbmV4cG9ydCB0eXBlIExhYmVsUG9zaXRpb24gPSBcInNlcGFyYXRlXCIgfCBcIndyYXBwaW5nXCIgfCBcIm5vbmVcIjtcbmV4cG9ydCB0eXBlIEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCBleHRlbmRzIExhYmVsUG9zaXRpb24sIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gTFAgZXh0ZW5kcyBcIndyYXBwaW5nXCIgPyBMYWJlbEVsZW1lbnQgOiBJbnB1dEVsZW1lbnQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGFiZWxQYXJhbWV0ZXJzPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHJhbmRvbUlkSW5wdXRQYXJhbWV0ZXJzOiBPbWl0PFVzZVJhbmRvbUR1YWxJZHNQYXJhbWV0ZXJzW1wicmFuZG9tSWRJbnB1dFBhcmFtZXRlcnNcIl0sIFwib3RoZXJSZWZlcmVuY2VyUHJvcFwiPjtcbiAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogT21pdDxVc2VSYW5kb21EdWFsSWRzUGFyYW1ldGVyc1tcInJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzXCJdLCBcIm90aGVyUmVmZXJlbmNlclByb3BcIj47XG5cbiAgICBsYWJlbFBhcmFtZXRlcnM6IHtcbiAgICAgICAgb25MYWJlbENsaWNrOiBudWxsIHwgKChlOiBFdmVudCkgPT4gdm9pZCk7XG4gICAgICAgIHRhZ0lucHV0OiBFbGVtZW50VG9UYWc8SW5wdXRFbGVtZW50PjtcbiAgICAgICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlcmUgaXMgdGhpcyBjb21wb25lbnQncyBsYWJlbCByZWxhdGl2ZSB0byB0aGUgY29tcG9uZW50IGl0c2VsZj9cbiAgICAgICAgICogXG4gICAgICAgICAqICogYFwic2VwYXJhdGVcImA6IGA8bGFiZWwgLz48aW5wdXQgLz5gXG4gICAgICAgICAqICogYFwid3JhcHBpbmdcImA6IGA8bGFiZWw+PGlucHV0IC8+PC9sYWJlbD5gXG4gICAgICAgICAqICogYFwibm9uZVwiYDogYDxpbnB1dCBhcmlhLWxhYmVsPVwiLi4uXCIgLz5gXG4gICAgICAgICAqIFxuICAgICAgICAgKiBJbiBjYXNlcyB3aGVyZSB5b3UncmUgdXNpbmcgbm9uLWBpbnB1dGAgYW5kIGBsYWJlbGAgZWxlbWVudHMsIGBcInNlcGFyYXRlXCJgIGFuZCBgXCJ3cmFwcGluZ1wiYCBhcmUgaWRlbnRpY2FsOyBcbiAgICAgICAgICogdGhpcyBpcyBtb3N0IGltcG9ydGFudCBmb3IgbmF0aXZlIGBsYWJlbGAgYW5kIGBpbnB1dGAgZWxlbWVudHMsIGFzIHRoZXkgb25seSBuZWVkIGEgYGZvcmAgcHJvcCB3aGVuIHRoZSBsYWJlbCBkb2Vzbid0IHdyYXAgdGhlIGlucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgbGFiZWxQb3NpdGlvbjogTFA7XG5cbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBXaGVuIGBudWxsYCwgdGhpcyBjb3JyZXNwb25kcyB0byBoYXZpbmcgYSB2aXNpYmxlIGxhYmVsICh3aXRoIGBsYWJlbFBvc2l0aW9uYCA9PSBgXCJzZXBhcmF0ZVwiYCBvciBgXCJ3cmFwcGluZ1wiYCkuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBXaGVuIGEgc3RyaW5nLCB0aGlzIGNvcnJlc3BvbmRzIHRvIGBsYWJlbFBvc2l0aW9uYCA9PSBgXCJub25lXCJgOyB0aGlzIGxhYmVsIGlzIG9ubHkgdmlzaWJsZSB0byBhc3Npc3RpdmUgdGVjaG5vbG9naWVzIGFuZCAqbm90KiB2aXNpYmxlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIGFyaWFMYWJlbDogTFAgZXh0ZW5kcyBcIm5vbmVcIiA/IHN0cmluZyA6IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxhYmVsUmV0dXJuVHlwZTxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJhbmRvbUR1YWxJZHNSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiB7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxhYmVsPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIHJhbmRvbUlkSW5wdXRQYXJhbWV0ZXJzLFxuICAgIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzLFxuICAgIGxhYmVsUGFyYW1ldGVyczogeyB0YWdJbnB1dCwgdGFnTGFiZWwsIGFyaWFMYWJlbCwgbGFiZWxQb3NpdGlvbiwgb25MYWJlbENsaWNrIH1cbn06IFVzZUxhYmVsUGFyYW1ldGVyczxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KTogVXNlTGFiZWxSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XG4gICAgY29uc3QgbmF0aXZlSFRNTEJlaGF2aW9yID0gKHRhZ0lucHV0ID09IFwiaW5wdXRcIiAmJiB0YWdMYWJlbCA9PSBcImxhYmVsXCIgJiYgbGFiZWxQb3NpdGlvbiAhPSBcIndyYXBwaW5nXCIpO1xuICAgIGNvbnN0IHN5bnRoZXRpYyA9ICFuYXRpdmVIVE1MQmVoYXZpb3I7XG5cbiAgICAvKipcbiAgICAgKiB8U3ludGhldGljP3xQb3NpdGlvbiAgICB8SW5wdXQgUHJvcCAgIHxMYWJlbCBQcm9wfFxuICAgICAqIHwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS18XG4gICAgICogfE4gICAgICAgICB8YFwic2VwYXJhdGVcImB8LSAgICAgICAgICAgIHxgZm9yYCAgICAgfFxuICAgICAqIHxOICAgICAgICAgfGBcIndyYXBwaW5nXCJgfC0gICAgICAgICAgICB8LSAgICAgICAgIHxcbiAgICAgKiB8WSAgICAgICAgIHxgXCJzZXBhcmF0ZVwiYHxgbGFiZWxsZWQtYnlgfC0gICAgICAgICB8XG4gICAgICogfFkgICAgICAgICB8YFwid3JhcHBpbmdcImB8YGxhYmVsbGVkLWJ5YHwtICAgICAgICAgfFxuICAgICAqIFxuICAgICAqL1xuICAgIGxldCBfY29tbWVudDogYW55O1xuXG4gICAgY29uc3Qge1xuICAgICAgICBwcm9wc0lucHV0LFxuICAgICAgICBwcm9wc0xhYmVsLFxuICAgICAgICByYW5kb21JZElucHV0UmV0dXJuLFxuICAgICAgICByYW5kb21JZExhYmVsUmV0dXJuXG4gICAgfSA9IHVzZVJhbmRvbUR1YWxJZHM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IHsgLi4ucmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMsIG90aGVyUmVmZXJlbmNlclByb3A6ICFzeW50aGV0aWMgJiYgbGFiZWxQb3NpdGlvbiA9PT0gXCJzZXBhcmF0ZVwiID8gXCJmb3JcIiA6IG51bGwgfSxcbiAgICAgICAgcmFuZG9tSWRMYWJlbFBhcmFtZXRlcnM6IHsgLi4ucmFuZG9tSWRMYWJlbFBhcmFtZXRlcnMsIG90aGVyUmVmZXJlbmNlclByb3A6IHN5bnRoZXRpYyA/IFwiYXJpYS1sYWJlbGxlZGJ5XCIgOiBudWxsIH0sXG4gICAgfSk7XG5cbiAgICBpZiAobGFiZWxQb3NpdGlvbiA9PSAnbm9uZScpXG4gICAgICAgIHByb3BzSW5wdXRbXCJhcmlhLWxhYmVsXCJdID0gKGFyaWFMYWJlbCEpO1xuXG4gICAgcHJvcHNMYWJlbC5vbkNsaWNrID0gb25MYWJlbENsaWNrID8/IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzSW5wdXQsXG4gICAgICAgIHByb3BzTGFiZWwsXG4gICAgICAgIHJhbmRvbUlkSW5wdXRSZXR1cm4sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxSZXR1cm4sXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxhYmVsU3ludGhldGljUGFyYW1ldGVycyB7XG4gICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IE9taXQ8VXNlUmFuZG9tRHVhbElkc1BhcmFtZXRlcnNbXCJyYW5kb21JZElucHV0UGFyYW1ldGVyc1wiXSwgXCJvdGhlclJlZmVyZW5jZXJQcm9wXCI+O1xuICAgIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzOiBPbWl0PFVzZVJhbmRvbUR1YWxJZHNQYXJhbWV0ZXJzW1wicmFuZG9tSWRMYWJlbFBhcmFtZXRlcnNcIl0sIFwib3RoZXJSZWZlcmVuY2VyUHJvcFwiPjtcbiAgICBsYWJlbFBhcmFtZXRlcnM6IFBpY2s8VXNlTGFiZWxQYXJhbWV0ZXJzPExhYmVsUG9zaXRpb24sIGFueSwgYW55PltcImxhYmVsUGFyYW1ldGVyc1wiXSwgXCJhcmlhTGFiZWxcIiB8IFwib25MYWJlbENsaWNrXCI+XG59XG5cbi8qKlxuICogU2hvcnRjdXQgZm9yIGB1c2VMYWJlbGAgdGhhdCBhc3N1bWVzIHdlJ3JlIGp1c3QgbmV2ZXIgd29ya2luZyB3aXRoIG5hdGl2ZSBIVE1MIGBpbnB1dGAgYW5kIGBsYWJlbGAgZWxlbWVudHMuIFNvIGZvciBsYWJlbGxpbmcgZ3VhcmFudGVhYmx5IG5vbi1uYXRpdmUgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYWJlbFN5bnRoZXRpYzxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbGFiZWxQYXJhbWV0ZXJzOiB7IGFyaWFMYWJlbCwgb25MYWJlbENsaWNrIH0sXG4gICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMsXG4gICAgcmFuZG9tSWRMYWJlbFBhcmFtZXRlcnNcbn06IFVzZUxhYmVsU3ludGhldGljUGFyYW1ldGVycykge1xuICAgIHJldHVybiB1c2VMYWJlbDxMYWJlbFBvc2l0aW9uLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xuICAgICAgICByYW5kb21JZExhYmVsUGFyYW1ldGVycyxcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMsXG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgYXJpYUxhYmVsLFxuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogYXJpYUxhYmVsID09IG51bGwgPyBcInNlcGFyYXRlXCIgOiBcIm5vbmVcIixcbiAgICAgICAgICAgIHRhZ0lucHV0OiBcImRpdlwiIGFzIG5ldmVyLFxuICAgICAgICAgICAgdGFnTGFiZWw6IFwiZGl2XCIgYXMgbmV2ZXIsXG4gICAgICAgICAgICBvbkxhYmVsQ2xpY2tcbiAgICAgICAgfVxuICAgIH0pXG5cbn1cblxuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChlOiBFdmVudCkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbn1cblxuXG5leHBvcnQgdHlwZSBDaGVja2JveENoZWNrZWRUeXBlID0gYm9vbGVhbiB8IFwibWl4ZWRcIjtcbi8vZXhwb3J0IHR5cGUgTGFiZWxQb3NpdGlvbiA9IFwid3JhcHBpbmdcIiB8IFwic2VwYXJhdGVcIiB8IFwiZHVhbFwiIHwgXCJub25lXCI7XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8TFAgZXh0ZW5kcyBMYWJlbFBvc2l0aW9uLCBJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTGFiZWxQYXJhbWV0ZXJzPExQLCBJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwibGFiZWxQYXJhbWV0ZXJzXCI+IHtcbiAgICBjaGVja2JveExpa2VQYXJhbWV0ZXJzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVyZSB0aGUgbGFiZWwgZWxlbWVudCBpcyBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAgICAgKiAqIGB3cmFwcGluZ2A6IFRoZSBsYWJlbCB3cmFwcyB0aGUgaW5wdXQgYW5kIG5vIGBpZGAgb3IgYGZvcmAgcHJvcHMgYXJlIG5lZWRlZCwgYXMgaW4gYDxsYWJlbD48aW5wdXQgLz4gbGFiZWwgY29udGVudDwvbGFiZWw+YFxuICAgICAgICAgKiAqIGBzZXBhcmF0ZWA6IFRoZSBsYWJlbCBhbmQgaW5wdXQgYXJlIGluIHNlcGFyYXRlIGJyYW5jaGVzLCBhcyBpbiBgPGlucHV0IC8+PGxhYmVsPmxhYmVsIGNvbnRlbnQ8L2xhYmVsPmBcbiAgICAgICAgICogKiBgZHVhbGA6IE9uZSBlbGVtZW50IHNlcnZlcyBpbiBib3RoIHJvbGVzIGF0IG9uY2UsIGFzIGluIGA8ZGl2IHJvbGU9XCJjaGVja2JveFwiPmxhYmVsIGNvbnRlbnQ8L2Rpdj4gYFxuICAgICAgICAgKiAqIGBub25lYDogVGhlcmUgaXMgbm8gdmlzaWJsZSBsYWJlbCBlbGVtZW50LCBhcyBpbiBgPGlucHV0IGFyaWEtbGFiZWw9XCJsYWJlbCBjb250ZW50XCIgLz5gXG4gICAgICAgICAqIFxuICAgICAgICAgKiBJbiBjb21iaW5hdGlvbiB3aXRoIGB0YWdJbnB1dGAgYW5kIGB0YWdMYWJlbGAsIGBsYWJlbFBvc2l0aW9uYCBkZXRlcm1pbmVzIHdoaWNoIGVsZW1lbnQgcmVjZWl2ZXMgd2hpY2ggcHJvcHMgYW5kIGV2ZW50IGhhbmRsZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgLy9sYWJlbFBvc2l0aW9uOiBMYWJlbFBvc2l0aW9uO1xuICAgICAgICAvKiogVGhlIHJvbGUgYXR0cmlidXRlIHRvIHVzZSwgd2hlbiBhcHBsaWNhYmxlICovXG4gICAgICAgIHJvbGU6IHN0cmluZztcbiAgICAgICAgZGlzYWJsZWQ6IERpc2FibGVkVHlwZTtcbiAgICAgICAgY2hlY2tlZDogQ2hlY2tib3hDaGVja2VkVHlwZTtcbiAgICAgICAgb25JbnB1dChldmVudDogRXZlbnQpOiB2b2lkO1xuICAgICAgICAvL3R5cGU6IFwiY2hlY2tib3hcIiB8IFwicmFkaW9cIjtcbiAgICB9O1xuXG4gICAgbGFiZWxQYXJhbWV0ZXJzOiBPbWl0PFVzZUxhYmVsUGFyYW1ldGVyczxMUCwgSW5wdXRUeXBlLCBMYWJlbFR5cGU+W1wibGFiZWxQYXJhbWV0ZXJzXCJdLCBcIm9uTGFiZWxDbGlja1wiPjtcblxuICAgIHJlZkVsZW1lbnRMYWJlbFJldHVybjogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8TGFiZWxUeXBlPltcInJlZkVsZW1lbnRSZXR1cm5cIl07XG4gICAgcmVmRWxlbWVudElucHV0UmV0dXJuOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxJbnB1dFR5cGU+W1wicmVmRWxlbWVudFJldHVyblwiXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlPElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGFiZWxSZXR1cm5UeXBlPElucHV0VHlwZSwgTGFiZWxUeXBlPiB7XG4gICAgcHJlc3NMYWJlbFJldHVybjogVXNlUHJlc3NSZXR1cm5UeXBlPExhYmVsVHlwZT5bXCJwcmVzc1JldHVyblwiXTtcbiAgICBwcmVzc0lucHV0UmV0dXJuOiBVc2VQcmVzc1JldHVyblR5cGU8SW5wdXRUeXBlPltcInByZXNzUmV0dXJuXCJdO1xuICAgIGNoZWNrYm94TGlrZUlucHV0UmV0dXJuOiB7IHByb3BzVW5zdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4gfVxuICAgIGNoZWNrYm94TGlrZUxhYmVsUmV0dXJuOiB7IHByb3BzVW5zdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT4gfVxuICAgIGNoZWNrYm94TGlrZVJldHVybjoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbCB0aGlzIHRvIGZvY3VzIHdoaWNoZXZlciBlbGVtZW50IGhhbmRsZXMgdGhlIGZvY3VzIGJhc2VkIG9uIGBsYWJlbFBvc2l0aW9uYC5cbiAgICAgICAgICovXG4gICAgICAgIGZvY3VzU2VsZigpOiB2b2lkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFueSBjb21wb25lbnQgd2hlcmUgdGhlcmUnczpcbiAqIDEuIFNvbWUga2luZCBvZiBhbiBvbi9vZmYgYmluYXJ5L3RyaW5hcnkgaW5wdXQgZWxlbWVudCB0aGF0IG5lZWRzIGV2ZW50IGhhbmRsZXJzXG4gKiAyLiBTb21lIGtpbmQgb2YgbGFiZWwgZm9yIHRoYXQgaW5wdXQgZWxlbWVudFxuICogXG4gKiBTZWUgYWxzbyBgdXNlTGFiZWxgIGZvciB3aGVuIHRoZXJlJ3MgYSBsYWJlbCBmb3IgYSBub24tY2hlY2tib3gtbGlrZSBjb21wb25lbnQuXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoZWNrYm94TGlrZTxMUCBleHRlbmRzIExhYmVsUG9zaXRpb24sIElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBsYWJlbFBhcmFtZXRlcnMsXG4gICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMsXG4gICAgcmFuZG9tSWRMYWJlbFBhcmFtZXRlcnMsXG4gICAgY2hlY2tib3hMaWtlUGFyYW1ldGVyczogeyBjaGVja2VkLCBkaXNhYmxlZCwgb25JbnB1dDogb25JbnB1dFN5bmMsIHJvbGUgfSxcbiAgICByZWZFbGVtZW50SW5wdXRSZXR1cm4sXG4gICAgcmVmRWxlbWVudExhYmVsUmV0dXJuLFxufTogVXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxMUCwgSW5wdXRUeXBlLCBMYWJlbFR5cGU+KTogVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZTxJbnB1dFR5cGUsIExhYmVsVHlwZT4ge1xuXG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRJbnB1dEVsZW1lbnQgfSA9IHJlZkVsZW1lbnRJbnB1dFJldHVybjtcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldExhYmVsRWxlbWVudCB9ID0gcmVmRWxlbWVudExhYmVsUmV0dXJuO1xuICAgIGNvbnN0IHsgdGFnSW5wdXQsIHRhZ0xhYmVsLCBsYWJlbFBvc2l0aW9uIH0gPSBsYWJlbFBhcmFtZXRlcnM7XG5cbiAgICAvLyBvbkNsaWNrIGFuZCBvbkNoYW5nZSBhcmUgYSBiaXQgbWVzc3ksIHNvIHdlIG5lZWQgdG9cbiAgICAvLyAqYWx3YXlzKiBtYWtlIHN1cmUgdGhhdCB0aGUgdmlzaWJsZSBzdGF0ZSBpcyBjb3JyZWN0XG4gICAgLy8gYWZ0ZXIgYWxsIHRoZSBldmVudCBkdXN0IHNldHRsZXMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzI3NDUsXG4gICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzE4OTkjaXNzdWVjb21tZW50LTUyNTY5MDE5NFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRJbnB1dEVsZW1lbnQhKCk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIHRhZ0lucHV0ID09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgKGVsZW1lbnQgYXMgRWxlbWVudCBhcyBIVE1MSW5wdXRFbGVtZW50KS5pbmRldGVybWluYXRlID0gKGNoZWNrZWQgPT09IFwibWl4ZWRcIik7XG4gICAgICAgICAgICAoZWxlbWVudCBhcyBFbGVtZW50IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSAoY2hlY2tlZCA9PT0gdHJ1ZSlcbiAgICAgICAgfVxuICAgIH0sIFt0YWdJbnB1dCwgKGNoZWNrZWQgPz8gZmFsc2UpXSlcblxuICAgIGNvbnN0IHtcbiAgICAgICAgcmFuZG9tSWRJbnB1dFJldHVybixcbiAgICAgICAgcmFuZG9tSWRMYWJlbFJldHVybixcbiAgICAgICAgcHJvcHNJbnB1dCxcbiAgICAgICAgcHJvcHNMYWJlbFxuICAgIH0gPSB1c2VMYWJlbDxMUCwgSW5wdXRUeXBlLCBMYWJlbFR5cGU+KHtcbiAgICAgICAgbGFiZWxQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAuLi5sYWJlbFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBvbkxhYmVsQ2xpY2s6IHVzZVN0YWJsZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlZCAmJiB0YWdJbnB1dCAhPSBcImlucHV0XCIgJiYgdGFnTGFiZWwgIT0gXCJsYWJlbFwiICYmIGxhYmVsUG9zaXRpb24gIT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvY3VzU2VsZigpO1xuICAgICAgICAgICAgICAgICAgICBvbklucHV0U3luYyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICByYW5kb21JZElucHV0UGFyYW1ldGVycyxcbiAgICAgICAgcmFuZG9tSWRMYWJlbFBhcmFtZXRlcnMsXG4gICAgfSk7XG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRJbnB1dCB9ID0gcmVmRWxlbWVudElucHV0UmV0dXJuO1xuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0TGFiZWwgfSA9IHJlZkVsZW1lbnRMYWJlbFJldHVybjtcbiAgICBjb25zdCBmb2N1c0lucHV0ID0gdXNlQ2FsbGJhY2soKCkgPT4geyAoZ2V0SW5wdXQoKSBhcyAoSFRNTEVsZW1lbnQgfCBudWxsKSk/LmZvY3VzKCk7IH0sIFtdKTtcbiAgICBjb25zdCBmb2N1c0xhYmVsID0gdXNlQ2FsbGJhY2soKCkgPT4geyAoZ2V0TGFiZWwoKSBhcyAoSFRNTEVsZW1lbnQgfCBudWxsKSk/LmZvY3VzKCk7IH0sIFtdKTtcbiAgICBjb25zdCBvbkNsaWNrSW5wdXRTeW5jID0gKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiID8gdW5kZWZpbmVkIDogb25JbnB1dFN5bmMpO1xuICAgIGNvbnN0IG9uQ2xpY2tMYWJlbFN5bmMgPSBvbklucHV0U3luYzsvLyhsYWJlbFBvc2l0aW9uICE9IFwid3JhcHBpbmdcIiA/IHVuZGVmaW5lZCA6IG9uSW5wdXRTeW5jKTtcbiAgICBjb25zdCB7IHByZXNzUmV0dXJuOiBwcmVzc0lucHV0UmV0dXJuIH0gPSB1c2VQcmVzczxJbnB1dFR5cGU+KHsgcHJlc3NQYXJhbWV0ZXJzOiB7IGV4Y2x1ZGU6IHt9LCBmb2N1c1NlbGY6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtkZWJ1Z2dlcjtmb2N1c1NlbGYoKX0pLCBvblByZXNzU3luYzogKGRpc2FibGVkKSA/IHVuZGVmaW5lZCA6IG9uQ2xpY2tJbnB1dFN5bmMgfSwgcmVmRWxlbWVudFJldHVybjogcmVmRWxlbWVudElucHV0UmV0dXJuIH0pO1xuICAgIGNvbnN0IHsgcHJlc3NSZXR1cm46IHByZXNzTGFiZWxSZXR1cm4gfSA9IHVzZVByZXNzPExhYmVsVHlwZT4oeyBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZToge30sIGZvY3VzU2VsZjogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge2RlYnVnZ2VyO2ZvY3VzU2VsZigpfSksIG9uUHJlc3NTeW5jOiAoZGlzYWJsZWQpID8gdW5kZWZpbmVkIDogb25DbGlja0xhYmVsU3luYyB9LCByZWZFbGVtZW50UmV0dXJuOiByZWZFbGVtZW50TGFiZWxSZXR1cm4gfSk7XG4gICAgY29uc3QgcHJvcHNVbnN0YWJsZUlucHV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+ID0ge307XG4gICAgY29uc3QgcHJvcHNVbnN0YWJsZUxhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+ID0ge307XG4gICAgLy9jb25zdCBwcm9wc1Vuc3RhYmxlTGFiZWwgPSB1c2VSZWY8aC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPj4oe30pO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgbGFiZWwgY2xpY2tzIGNhbid0IGFmZmVjdCB0aGUgdmlzdWFsIHN0YXRlIG9mIHRoZSBjaGVja2JveFxuICAgIHByb3BzVW5zdGFibGVJbnB1dC5vbkNsaWNrID0gcHJldmVudERlZmF1bHQ7XG4gICAgcHJvcHNVbnN0YWJsZUxhYmVsLm9uQ2xpY2sgPSBwcmV2ZW50RGVmYXVsdDtcblxuICAgIHByb3BzVW5zdGFibGVJbnB1dC5vbklucHV0ID0gcHJldmVudERlZmF1bHQ7XG4gICAgcHJvcHNVbnN0YWJsZUlucHV0Lm9uQ2hhbmdlID0gcHJldmVudERlZmF1bHQ7XG5cbiAgICBwcm9wc1Vuc3RhYmxlSW5wdXQudHlwZSA9IHJvbGUgPT0gXCJyYWRpb1wiID8gXCJyYWRpb1wiIDogXCJjaGVja2JveFwiO1xuXG4gICAgc3dpdGNoIChsYWJlbFBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJzZXBhcmF0ZVwiOiB7XG4gICAgICAgICAgICBpZiAodGFnSW5wdXQgPT0gXCJpbnB1dFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRXZlbiBpbiB0aGUgbW9zdCBkZWZhdWx0IGlucHV0IGJlaGF2aW9yLCB3ZSBzdGlsbCBuZWVkIHRvIGhhbmRsZVxuICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgYWJzdHJhY3Rpb24gb3ZlciBjaGVja2VkPVwibWl4ZWRcIiBhbmQgZGlzYWJsZWQ9XCJzb2Z0XCJcbiAgICAgICAgICAgICAgICBwcm9wc1Vuc3RhYmxlSW5wdXQuY2hlY2tlZCA9IChjaGVja2VkID09PSB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZWQgPT09IHRydWUgfHwgZGlzYWJsZWQgPT09ICdoYXJkJylcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNVbnN0YWJsZUlucHV0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXNhYmxlZCA9PSBcInNvZnRcIilcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNVbnN0YWJsZUlucHV0W1wiYXJpYS1kaXNhYmxlZFwiXSA9IFwidHJ1ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGl2IGlucHV0cyBuZWVkIHRoZWlyIHZhcmlvdXMgQVJJQSByb2xlcyBhbmQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIHByb3BzVW5zdGFibGVJbnB1dC5yb2xlID0gcm9sZTtcbiAgICAgICAgICAgICAgICBwcm9wc1Vuc3RhYmxlSW5wdXQudGFiSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHByb3BzVW5zdGFibGVJbnB1dFtcImFyaWEtY2hlY2tlZFwiXSA9IChjaGVja2VkID8/IGZhbHNlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHByb3BzVW5zdGFibGVJbnB1dFtcImFyaWEtZGlzYWJsZWRcIl0gPSAoISFkaXNhYmxlZCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhZ0xhYmVsICE9IFwibGFiZWxcIikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgc3BlY2lhbCBmb3IgcmVndWxhciBsYWJlbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzcGVjaWFsIGhhbmRsaW5nIGZvciBkaXYgbGFiZWxzIGlzIGFscmVhZHkgY292ZXJlZCBieSB1c2VMYWJlbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIndyYXBwaW5nXCI6IHtcbiAgICAgICAgICAgIGlmICh0YWdJbnB1dCA9PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgZm9ybSBzdWJtaXNzaW9uIGFuZCBzdHlsaW5nXG4gICAgICAgICAgICAgICAgcHJvcHNVbnN0YWJsZUlucHV0LmNoZWNrZWQgPSAoY2hlY2tlZCA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcHJvcHNVbnN0YWJsZUlucHV0LmRpc2FibGVkID0gKGRpc2FibGVkID09PSB0cnVlKTtcblxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgdGhlIHdyYXBwZWQgbGFiZWwgaGFuZGxlcyBhbGwgaW50ZXJhY3Rpb25zLFxuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoaXMgZWxlbWVudCBjYW4ndCBiZSBpbnRlcmFjdGVkIHdpdGhcbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGl0J3MgYW4gaW5wdXQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICBwcm9wc1Vuc3RhYmxlSW5wdXQuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb3BzVW5zdGFibGVJbnB1dC50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIHByb3BzVW5zdGFibGVJbnB1dC5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICAgICAgICAgICAgICBwcm9wc1Vuc3RhYmxlSW5wdXRbXCJhcmlhLWhpZGRlblwiXSA9IFwidHJ1ZVwiO1xuICAgICAgICAgICAgICAgIHByb3BzVW5zdGFibGVJbnB1dC5vbkZvY3VzID0gXyA9PiAoZ2V0TGFiZWxFbGVtZW50Py4oKSBhcyBIVE1MRWxlbWVudCB8IG51bGwpPy5mb2N1cz8uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXaXRoIGEgd3JhcHBpbmcgbGFiZWwsIHdlJ3JlIGp1c3QgdXNpbmcgdGhlIGlucHV0IGZvciB2aXN1YWwgc3R5bGluZyBhbmQgaWdub3JpbmcgYWxsIGludGVyYWN0aW9uLlxuICAgICAgICAgICAgICAgIC8vIFdpdGggYSBkaXYsIHdlIGdldCB0aGF0IGZvciBmcmVlIGFuZCBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGhlcmUuXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gV3JhcHBpbmcgbGFiZWxzIGFyZSB0aGUgYWN0dWFsIGlucHV0cyB0aGF0IGFyZSBpbnRlcmFjdGVkIHdpdGhcbiAgICAgICAgICAgIC8vIEFuZCBhcmUgdmVyeSBzaW1pbGFyIGNvbmNlcHR1YWxseSB0byBkaXYgaW5wdXRzIHdoZW4gc2VwYXJhdGVkXG4gICAgICAgICAgICBwcm9wc1Vuc3RhYmxlTGFiZWwucm9sZSA9IHJvbGU7XG4gICAgICAgICAgICBwcm9wc1Vuc3RhYmxlTGFiZWwudGFiSW5kZXggPSAwO1xuICAgICAgICAgICAgcHJvcHNVbnN0YWJsZUxhYmVsW1wiYXJpYS1jaGVja2VkXCJdID0gKGNoZWNrZWQgPz8gZmFsc2UpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBwcm9wc1Vuc3RhYmxlTGFiZWxbXCJhcmlhLWRpc2FibGVkXCJdID0gKCEhZGlzYWJsZWQpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZm9jdXNTZWxmID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBsZXQgZWxlbWVudFRvRm9jdXM6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIilcbiAgICAgICAgICAgIGVsZW1lbnRUb0ZvY3VzID0gZ2V0TGFiZWxFbGVtZW50KCkgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZWxlbWVudFRvRm9jdXMgPSBnZXRJbnB1dEVsZW1lbnQoKSBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAgIGVsZW1lbnRUb0ZvY3VzPy5mb2N1cygpO1xuICAgIH0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgICByYW5kb21JZElucHV0UmV0dXJuLFxuICAgICAgICByYW5kb21JZExhYmVsUmV0dXJuLFxuICAgICAgICBwcmVzc0lucHV0UmV0dXJuLFxuICAgICAgICBwcmVzc0xhYmVsUmV0dXJuLFxuICAgICAgICBjaGVja2JveExpa2VJbnB1dFJldHVybjogeyBwcm9wc1Vuc3RhYmxlOiBwcm9wc1Vuc3RhYmxlSW5wdXQgfSxcbiAgICAgICAgY2hlY2tib3hMaWtlTGFiZWxSZXR1cm46IHsgcHJvcHNVbnN0YWJsZTogcHJvcHNVbnN0YWJsZUxhYmVsIH0sXG4gICAgICAgIHByb3BzSW5wdXQ6IHVzZU1lcmdlZFByb3BzKHByb3BzSW5wdXQsIHByb3BzVW5zdGFibGVJbnB1dCwgcHJlc3NJbnB1dFJldHVybi5wcm9wc1N0YWJsZSwgcmVmRWxlbWVudElucHV0UmV0dXJuLnByb3BzU3RhYmxlKSxcbiAgICAgICAgcHJvcHNMYWJlbDogdXNlTWVyZ2VkUHJvcHMocHJvcHNMYWJlbCwgcHJvcHNVbnN0YWJsZUxhYmVsLCBwcmVzc0xhYmVsUmV0dXJuLnByb3BzU3RhYmxlLCByZWZFbGVtZW50TGFiZWxSZXR1cm4ucHJvcHNTdGFibGUpLFxuICAgICAgICBjaGVja2JveExpa2VSZXR1cm46IHsgZm9jdXNTZWxmIH1cbiAgICB9XG59XG5cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIEVuaGFuY2VkRXZlbnQsIGVuaGFuY2VFdmVudCwgUHJlZmljZXMgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgTGFiZWxQb3NpdGlvbiwgdXNlQ2hlY2tib3hMaWtlLCBVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzLCBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XG5cblxuXG5leHBvcnQgdHlwZSBDaGVja2JveENoYW5nZUV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSBFbmhhbmNlZEV2ZW50PEUsIEV2ZW50LCB7IGNoZWNrZWQ6IGJvb2xlYW4gfT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hQYXJhbWV0ZXJzPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgSSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxMUCwgSSwgTD4sIFwiY2hlY2tib3hMaWtlUGFyYW1ldGVyc1wiIHwgXCJyYW5kb21JZElucHV0UGFyYW1ldGVyc1wiIHwgXCJyYW5kb21JZExhYmVsUGFyYW1ldGVyc1wiPiB7XG4gICAgY2hlY2tib3hMaWtlUGFyYW1ldGVyczogT21pdDxVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzPExQLCBJLCBMPltcImNoZWNrYm94TGlrZVBhcmFtZXRlcnNcIl0sIFwib25JbnB1dFwiIHwgXCJyb2xlXCIgfCBcInByZWZpeFwiPjtcbiAgICBjaGVja2JveFBhcmFtZXRlcnM6IHtcbiAgICAgICAgb25DaGVja2VkQ2hhbmdlKGV2ZW50OiBDaGVja2JveENoYW5nZUV2ZW50PEk+KTogdm9pZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hSZXR1cm5UeXBlPElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZTxJbnB1dFR5cGUsIExhYmVsVHlwZT4ge1xuICAgIGNoZWNrYm94UmV0dXJuOiB7IHByb3BzVW5zdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4gfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hlY2tib3g8TFAgZXh0ZW5kcyBMYWJlbFBvc2l0aW9uLCBJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgY2hlY2tib3hQYXJhbWV0ZXJzOiB7IG9uQ2hlY2tlZENoYW5nZSB9LFxuICAgIGNoZWNrYm94TGlrZVBhcmFtZXRlcnMsXG4gICAgbGFiZWxQYXJhbWV0ZXJzLFxuICAgIHJlZkVsZW1lbnRJbnB1dFJldHVybixcbiAgICByZWZFbGVtZW50TGFiZWxSZXR1cm5cbn06IFVzZUNoZWNrYm94UGFyYW1ldGVyczxMUCwgSW5wdXRUeXBlLCBMYWJlbFR5cGU+KTogVXNlQ2hlY2tib3hSZXR1cm5UeXBlPElucHV0VHlwZSwgTGFiZWxUeXBlPiB7XG4gICAgZGVidWdMb2coXCJ1c2VDaGVja2JveFwiKTtcblxuICAgIGNvbnN0IHsgdGFnSW5wdXQsIGxhYmVsUG9zaXRpb24gfSA9IGxhYmVsUGFyYW1ldGVycztcbiAgICBjb25zdCB7IGNoZWNrZWQgfSA9IGNoZWNrYm94TGlrZVBhcmFtZXRlcnM7XG5cbiAgICBjb25zdCBvbklucHV0RW5oYW5jZWQgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogRXZlbnQpID0+IG9uQ2hlY2tlZENoYW5nZT8uKGVuaGFuY2VFdmVudDxJbnB1dFR5cGUsIEV2ZW50LCB7IGNoZWNrZWQ6IGJvb2xlYW4gfT4oZSwgeyBjaGVja2VkOiAhY2hlY2tlZCB9KSkpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgcHJlc3NJbnB1dFJldHVybixcbiAgICAgICAgcHJlc3NMYWJlbFJldHVybixcbiAgICAgICAgcmFuZG9tSWRJbnB1dFJldHVybixcbiAgICAgICAgcmFuZG9tSWRMYWJlbFJldHVybixcbiAgICAgICAgcHJvcHNJbnB1dCxcbiAgICAgICAgcHJvcHNMYWJlbCxcbiAgICAgICAgY2hlY2tib3hMaWtlUmV0dXJuLFxuICAgICAgICBjaGVja2JveExpa2VJbnB1dFJldHVybixcbiAgICAgICAgY2hlY2tib3hMaWtlTGFiZWxSZXR1cm5cbiAgICB9ID0gdXNlQ2hlY2tib3hMaWtlPExQLCBJbnB1dFR5cGUsIExhYmVsVHlwZT4oe1xuICAgICAgICByYW5kb21JZElucHV0UGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLmNoZWNrYm94TGlrZUlucHV0IH0sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzOiB7IHByZWZpeDogUHJlZmljZXMuY2hlY2tib3hMaWtlTGFiZWwgfSxcbiAgICAgICAgcmVmRWxlbWVudElucHV0UmV0dXJuLFxuICAgICAgICByZWZFbGVtZW50TGFiZWxSZXR1cm4sXG4gICAgICAgIGNoZWNrYm94TGlrZVBhcmFtZXRlcnM6IHsgcm9sZTogXCJjaGVja2JveFwiLCBvbklucHV0OiBvbklucHV0RW5oYW5jZWQsICAuLi5jaGVja2JveExpa2VQYXJhbWV0ZXJzIH0sXG4gICAgICAgIGxhYmVsUGFyYW1ldGVyc1xuICAgIH0pO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGVja2JveFJldHVybjogeyBwcm9wc1Vuc3RhYmxlOiB7IHR5cGU6ICh0YWdJbnB1dCA9PSBcImlucHV0XCIgJiYgbGFiZWxQb3NpdGlvbiAhPSBcIndyYXBwaW5nXCIgPyBcImNoZWNrYm94XCIgOiB1bmRlZmluZWQpIH0gfSxcbiAgICAgICAgY2hlY2tib3hMaWtlUmV0dXJuLFxuICAgICAgICBwcmVzc0lucHV0UmV0dXJuLFxuICAgICAgICBwcmVzc0xhYmVsUmV0dXJuLFxuICAgICAgICByYW5kb21JZElucHV0UmV0dXJuLFxuICAgICAgICByYW5kb21JZExhYmVsUmV0dXJuLFxuICAgICAgICBwcm9wc0lucHV0LFxuICAgICAgICBwcm9wc0xhYmVsLFxuICAgICAgICBjaGVja2JveExpa2VJbnB1dFJldHVybixcbiAgICAgICAgY2hlY2tib3hMaWtlTGFiZWxSZXR1cm5cbiAgICB9O1xuXG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNvbnRleHQsIFBhc3NpdmVTdGF0ZVVwZGF0ZXIsIHJldHVybkZhbHNlLCByZXR1cm5OdWxsLCByZXR1cm5aZXJvLCB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uLCB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGUsIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZSwgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbywgdXNlTWVyZ2VkUHJvcHMsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciwgdXNlU3RhYmxlT2JqZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIEVuaGFuY2VkRXZlbnQsIG5vb3AgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgQ2hlY2tib3hDaGVja2VkVHlwZSB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xuXG5leHBvcnQgdHlwZSBDaGVja2JveEdyb3VwQ2hhbmdlRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IEVuaGFuY2VkRXZlbnQ8RSwgRXZlbnQsIHsgY2hpbGRyZW5DaGVja2VkOiBib29sZWFuIHwgTWFwPG51bWJlciwgYm9vbGVhbiB8IFwibWl4ZWRcIj4gfT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIENoZWNrYm94R3JvdXBJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50Pj4gZXh0ZW5kcyBPbWl0PFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPFBhcmVudEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50LCBNPiwgXCJzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzXCI+IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgcGFyZW50IGNoZWNrYm94IGlzIGNoYW5nZWQgYW5kIGFuIHVwZGF0ZSBvZlxuICAgICAqIGFsbCB0aGUgY2hpbGRyZW4gbmVlZHMgdG8gb2NjdXIuXG4gICAgICogXG4gICAgICogYGV2ZW50W0V2ZW50RGV0YWlsXS5jaGlsZHJlbkNoZWNrZWRgIHdpbGwgYmUgXG4gICAgICogKiB0cnVlIHdoZW4gYWxsIGNoaWxkcmVuIG5lZWQgdG8gYmVjb21lIGNoZWNrZWRcbiAgICAgKiAqIGZhbHNlIHdoZW4gYWxsIGNoaWxkcmVuIG5lZWQgdG8gYmVjb21lIHVuY2hlY2tlZFxuICAgICAqICogQSBgTWFwPGluZGV4LGNoZWNrZWQ+YCBvZiBlYWNoIGNoaWxkJ3Mgc3RhdHVzIHdoZW4gcmV2ZXJ0aW5nIHRvIFwibWl4ZWRcIi5cbiAgICAgKiBcbiAgICAgKiBCZWNhdXNlIHdlJ3JlIGRlYWxpbmcgd2l0aCBjb250cm9sbGVkIGNvbXBvbmVudHMgaGVyZSwgYW5kIHRoZSBkYXRhIGZvclxuICAgICAqIHdoYXQgY2hlY2tib3hlcyBhcmUgY2hlY2tlZCBsaXZlICpvdXRzaWRlKiBvZiBhbnkgb2YgdGhlc2UgaG9va3MsXG4gICAgICogaXQncyB5b3Ugd2hvJ3MgcmVzcG9uc2libGUgZm9yIGxpc3RlbmluZyBmb3IgdGhpcyBldmVudCwgbW9kaWZ5aW5nIHRoZVxuICAgICAqIGRhdGEsIGFuZCByZS1yZW5kZXJpbmcgYXBwcm9wcmlhdGVseS5cbiAgICAgKiBcbiAgICAgKiBIaWdobHkgcmVjb21tZW5kZWQgdG8sIGZvciBleGFtcGxlLCBhZGQgZWFjaCBjaGlsZCdzIGBvbklucHV0YCBldmVudCBoYW5kbGVyXG4gICAgICogYXZhaWxhYmxlIGluIHRoZSBjaGlsZCBpbmZvIHRoZSBwYXJlbnQgZ2V0cyBzbyBpdCBjYW4gY2FsbCB0aGUgaGFuZGxlclxuICAgICAqIHJlbW90ZWx5IGZyb20gYG1hbmFnZWRDaGVja2JveGVzYC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgXG4gICAgICovXG4gICAgLy9jaGVja2JveEdyb3VwOiB7fVxuICAgIC8vb25VcGRhdGVDaGlsZHJlbihldmVudDogQ2hlY2tib3hHcm91cENoYW5nZUV2ZW50PGguSlNYLlRhcmdldGVkRXZlbnQ8RT4+KTogdm9pZDtcbn1cblxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBDaGlsZEluZm9CYXNlPEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZEluZm9CYXNlPEs+IHtcbi8qKlxuICogVGhlIGlkIGF0dHJpYnV0ZSB1c2VkIGZvciB0aGUgY2hpbGQuXG4gKi9cbi8vaWQ6IHN0cmluZztcblxuLyoqXG4gKiBUaGUgY3VycmVudCBjaGVja2VkIHN0YXRlIG9mIHRoaXMgY2hpbGQuXG4gKiBcbiAqIFRoaXMgaXMgdXNlZCBieSB0aGUgcGFyZW50IHdoZW5ldmVyIGl0J3MgaW50ZXJhY3RlZCB3aXRoIFxuICogYW5kIGFib3V0IHRvIGZvcmNlIGV2ZXJ5IG9uZSB0byBiZSBzb21ldGhpbmcgZGlmZmVyZW50IC0tIFxuICogaXQgd2lsbCBzYXZlIHRoZSBzdGF0ZSBvZiBhbGwgY2hpbGQgY2hlY2tib3hlcyBmb3IgbGF0ZXJcbiAqIGJ5IGFza2luZyBlYWNoIG9uZSB3aGF0IGl0cyBjdXJyZW50IHN0YXRlIGlzIGluZGl2aWR1YWxseVxuICogYXQgdGhhdCBtb21lbnQuXG4gKiBcbiAqIEFsbCB0aGUgY2hlY2tib3gncyBzdGF0ZXMgYXJlIGNhcHR1cmVkIHdoZW4gdGhlIHBhcmVudFxuICogaXMgaW4gdGhlIFwibWl4ZWRcIiBzdGF0ZSBhbmQgaXMgY2xpY2tlZC4gSXQga2VlcHMgdGhlbVxuICogdGhhdCB3YXkgdW50aWwgdGhlIHNhbWUgY29uZGl0aW9ucyBhcmlzZSBhZ2Fpbi5cbiAqL1xuLy8gICAgZ2V0TGFzdFVzZXJDaGVja2VkKCk6IGJvb2xlYW4gfCBcIm1peGVkXCI7XG4vLyAgICBvbklucHV0OiBVc2VDaGVja2JveFBhcmFtZXRlcnM8YW55LCBhbnk+W1wib25JbnB1dFwiXTtcbi8vfVxuXG5pbnRlcmZhY2UgQ2hlY2tib3hHcm91cEluZm9CYXNlQmFzZTxUQ0UgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgX2U/OiBUQ0U7XG59XG5cbmludGVyZmFjZSBDaGVja2JveEdyb3VwSW5mb0Jhc2UxPFRDRSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgQ2hlY2tib3hHcm91cEluZm9CYXNlQmFzZTxUQ0U+IHtcbiAgICBjaGVja2JveENoaWxkVHlwZTogXCJwYXJlbnRcIjtcbn1cblxuaW50ZXJmYWNlIENoZWNrYm94R3JvdXBJbmZvQmFzZTI8VENFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBDaGVja2JveEdyb3VwSW5mb0Jhc2VCYXNlPFRDRT4ge1xuICAgIGNoZWNrYm94Q2hpbGRUeXBlOiBcImNoaWxkXCI7XG4gICAgZ2V0Q2hlY2tlZCgpOiBib29sZWFuIHwgXCJtaXhlZFwiO1xuICAgIGdldExhc3RVc2VyQ2hlY2tlZCgpOiBib29sZWFuIHwgXCJtaXhlZFwiO1xuICAgIHNldENoZWNrZWRGcm9tUGFyZW50SW5wdXQobmV3Q2hlY2tlZDogQ2hlY2tib3hDaGVja2VkVHlwZSwgZTogRXZlbnQpOiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwSW5mbzxUQ0UgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm88VENFPiB7XG4gICAgY2hlY2tib3hJbmZvOiAoQ2hlY2tib3hHcm91cEluZm9CYXNlMTxUQ0U+IHwgQ2hlY2tib3hHcm91cEluZm9CYXNlMjxUQ0U+KTtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8VENFIGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgTSwgXCJjaGVja2JveEluZm9cIj4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiIHwgXCJwcmVzc1BhcmFtZXRlcnNcIiB8IFwic2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzXCI+IHtcbiAgICBjb250ZXh0OiBDaGVja2JveEdyb3VwQ29udGV4dDxhbnksIFRDRSwgTT47XG4gICAgY2hlY2tib3hHcm91cENoaWxkOiB7XG4gICAgICAgIC8vZm9jdXNTZWxmKGU6IFRDRSk6IHZvaWQ7XG4gICAgICAgIGNoZWNrZWQ6IENoZWNrYm94Q2hlY2tlZFR5cGU7XG4gICAgICAgIG9uQ2hhbmdlRnJvbVBhcmVudChjaGVja2VkOiBDaGVja2JveENoZWNrZWRUeXBlLCBlOiBFdmVudCk6IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuICAgIH1cbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBPbWl0PFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8VENFLCBNLCBuZXZlcj5bXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCJdLCBcImNoZWNrYm94Q2hpbGRUeXBlXCI+XG4gICAgcHJlc3NQYXJhbWV0ZXJzOiBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgTSwgbmV2ZXI+W1wicHJlc3NQYXJhbWV0ZXJzXCJdO1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlPFRDRSBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBDaGVja2JveEdyb3VwSW5mbzxUQ0U+PiBleHRlbmRzIE9taXQ8VXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxUQ0UsIE0+LCBcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiPiB7XG4gICAgY2hlY2tib3hHcm91cENoaWxkOiB7XG4gICAgICAgIG9uQ29udHJvbElkQ2hhbmdlZDogKG5leHQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgcHJldjogc3RyaW5nIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICAgICAgICBvbkNoaWxkQ2hlY2tlZENoYW5nZTogKGNoZWNrZWQ6IENoZWNrYm94Q2hlY2tlZFR5cGUpID0+IHZvaWQ7XG4gICAgfVxufVxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XG4vLyBUaGlzIGlzIGp1c3Qgd2hpY2hldmVyIG9mIHRoZSB0d28gc2hvdWxkIHJlY2VpdmUgbGlzdC1uYXYtcmVsYXRlZCBwcm9wcyAoc28gYmFzZWQgb24gYGxhYmVsUG9zaXRpb25gIGZvciBjaGVja2JveGVzKS5cbi8vIEFsdGVybmF0aXZlbHksIGRvbid0IHVzZSB0aGlzIGlmIHlvdSBleHBsaWNpdGx5IGRvbid0IHdhbnQgdGhpcyBncm91cCdzIGxpc3QgbmF2aWdhdGlvblxuLy9saXN0TmF2aWdhdGlvbkNoaWxkUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4gfCBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xuLy99XG5cblxuZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hHcm91cENoaWxkPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRDRSBleHRlbmRzIElucHV0RWxlbWVudCB8IExhYmVsRWxlbWVudCwgTSBleHRlbmRzIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+ID0gKGFyZ3M6IFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8VENFLCBNPikgPT4gVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZTxUQ0UsIE0+IC8qe1xuICAgIC8vdGFiYmFibGU6IGJvb2xlYW4gfCBudWxsO1xuICAgIGNoZWNrYm94TGlrZTogVXNlQ2hlY2tib3hSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImNoZWNrYm94TGlrZVwiXTtcbiAgICBsYWJlbDogVXNlQ2hlY2tib3hSZXR1cm5UeXBlPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PltcImxhYmVsXCJdO1xuICAgIHJvdmluZ1RhYkluZGV4OiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxJbnB1dEVsZW1lbnQ+W1wicm92aW5nVGFiSW5kZXhcIl07XG4gICAgdXNlQ2hlY2tib3hHcm91cENoaWxkSW5wdXRQcm9wczogKHsgdGFiSW5kZXgsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47XG4gICAgdXNlQ2hlY2tib3hHcm91cENoaWxkTGFiZWxQcm9wczogKHsgdGFiSW5kZXgsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XG59Ki9cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGU8R3JvdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVENFIGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+IGV4dGVuZHMgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGU8R3JvdXBFbGVtZW50LCBUQ0UsIE0+IHtcbiAgICBjb250ZXh0OiBDaGVja2JveEdyb3VwQ29udGV4dDxHcm91cEVsZW1lbnQsIFRDRSwgTT47XG59XG5cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZVdpdGhIb29rczxHcm91cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDQkdTdWJJbmZvLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxHcm91cEVsZW1lbnQsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBDQkdTdWJJbmZvLCBLPiB7XG4vKiogKipTVEFCTEUgKiogKi9cbi8vY2hlY2tib3hlczogTWFuYWdlZENoaWxkcmVuPEk+O1xuLyoqXG4gKiBFYWNoIGNoaWxkIGNoZWNrYm94IG11c3QgY2FsbCB0aGlzIGhvb2ssICppbiBhZGRpdGlvbiB0byogYHVzZUNoZWNrYm94YFxuICovXG4vLyAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGQ6IFVzZUNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgQ0JHU3ViSW5mbywgSz47XG4vKipcbiAqICoqU1RBQkxFKipcbiAqIFxuICogVGhlIHBhcmVudCBjaGVja2JveCBtdXN0IHVzZSB0aGlzIGhvb2tcbiAqL1xuLy8gICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudDogVXNlQ2hlY2tib3hHcm91cFBhcmVudDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgQ0JHU3ViSW5mbywgSz47XG5cbi8vIFVzZSBvbiBlaXRoZXIgZS5nLiB0aGUgZGl2IGNvbnRhaW5pbmcgdGhlIGNoaWxkcmVuLCBvciBlYWNoIGluZGl2aWR1YWwgY2hpbGRcbi8vbGlzdE5hdmlnYXRpb25Qcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pjtcbi8vfVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktaW50ZXJmYWNlICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzPFRDRSBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBDaGVja2JveEdyb3VwSW5mbzxUQ0U+PiBleHRlbmRzIE9taXQ8VXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxUQ0UsIE0sIG5ldmVyPiwgXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCIgfCBcInByZXNzUGFyYW1ldGVyc1wiIHwgXCJzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnNcIj4ge1xuICAgIGNvbnRleHQ6IENoZWNrYm94R3JvdXBDb250ZXh0PGFueSwgVENFLCBNPjtcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBPbWl0PFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8VENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+LCBuZXZlcj5bXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCJdLCBcImdldENoZWNrZWRcIiB8IFwiZ2V0TGFzdFVzZXJDaGVja2VkXCIgfCBcInNldENoZWNrZWRGcm9tUGFyZW50SW5wdXRcIiB8IFwiY2hlY2tib3hDaGlsZFR5cGVcIj5cbiAgICBwcmVzc1BhcmFtZXRlcnM6IFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8VENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+LCBuZXZlcj5bXCJwcmVzc1BhcmFtZXRlcnNcIl07XG59XG5cbi8vZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hHcm91cFBhcmVudDxUQ0UgZXh0ZW5kcyBFbGVtZW50PiA9IChhOiBVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0U+KSA9PiBVc2VDaGVja2JveEdyb3VwUGFyZW50UmV0dXJuVHlwZTxUQ0U+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBQYXJlbnRSZXR1cm5UeXBlPFRDRSBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBDaGVja2JveEdyb3VwSW5mbzxUQ0U+PiBleHRlbmRzIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU8VENFLCBNPiB7XG4gICAgY2hlY2tib3hHcm91cFBhcmVudFJldHVybjoge1xuICAgICAgICBjaGVja2VkOiBDaGVja2JveENoZWNrZWRUeXBlO1xuICAgICAgICBnZXRQZXJjZW50KCk6IG51bWJlcjtcbiAgICAgICAgb25QYXJlbnRDaGVja2VkQ2hhbmdlOiAoZTogRXZlbnQpID0+IFByb21pc2U8dm9pZD47XG4gICAgfVxufVxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cFBhcmVudFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgX0xhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQ2hlY2tib3hHcm91cFBhcmVudFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudD4ge1xuLy8gICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47XG4vL31cblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwQ29udGV4dDxHcm91cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUQ0UgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgQ2hlY2tib3hHcm91cEluZm88VENFPj4gZXh0ZW5kcyBDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ29udGV4dDxHcm91cEVsZW1lbnQsIFRDRSwgTT4ge1xuICAgIC8vIHBhcmVudFxuICAgIGNoZWNrYm94R3JvdXBQYXJlbnRDb250ZXh0OiB7XG5cbiAgICAgICAgLy8gV2hhdCBhIGhvcnJpZnlpbmcgdHlwZS4gIE5hbWUgdGhpcyBiZXR0ZXIgcGxlYXNlLlxuICAgICAgICBzZXRTZXR0ZXI6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8U3RhdGVVcGRhdGVyPHN0cmluZz4gfCBudWxsLCBFdmVudD47XG5cbiAgICAgICAgLy8gd2h5eXl5eVxuICAgICAgICBzZXRTZXRQYXJlbnRDaGVja2JveENoZWNrZWQ6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8U3RhdGVVcGRhdGVyPENoZWNrYm94Q2hlY2tlZFR5cGU+IHwgbnVsbCwgRXZlbnQ+O1xuXG4gICAgICAgIGdldFBlcmNlbnRDaGVja2VkOiAodG90YWxDaGVja2VkOiBudW1iZXIsIHRvdGFsQ2hpbGRyZW46IG51bWJlcikgPT4gbnVtYmVyO1xuXG4gICAgICAgIGdldFRvdGFsQ2hlY2tlZDogKCkgPT4gbnVtYmVyO1xuICAgICAgICBnZXRUb3RhbENoaWxkcmVuOiAoKSA9PiBudW1iZXI7XG5cbiAgICAgICAgb25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQ6IChlOiBFdmVudCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgICB9XG4gICAgY2hlY2tib3hHcm91cENoaWxkcmVuQ29udGV4dDoge1xuXG4gICAgICAgIC8vIGNoaWxkcmVuXG4gICAgICAgIHNldFVwZGF0ZUluZGV4OiBQYXNzaXZlU3RhdGVVcGRhdGVyPG51bWJlciwgRXZlbnQ+O1xuICAgICAgICBhbGxJZHM6IFNldDxzdHJpbmc+O1xuICAgICAgICBzZXRUb3RhbENoaWxkcmVuOiBQYXNzaXZlU3RhdGVVcGRhdGVyPG51bWJlciwgRXZlbnQ+O1xuICAgICAgICBzZXRUb3RhbENoZWNrZWQ6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8bnVtYmVyLCBFdmVudD47XG4gICAgfVxuXG59XG5cbi8qKlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoZWNrYm94R3JvdXA8R3JvdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVENFIGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXG59OiBVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVyczxHcm91cEVsZW1lbnQsIFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4pOiBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZTxHcm91cEVsZW1lbnQsIFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4ge1xuICAgIGRlYnVnTG9nKFwidXNlQ2hlY2tib3hHcm91cFwiKTtcbiAgICAvL2NvbnN0IG9uVXBkYXRlQ2hpbGRyZW4gPSB1c2VTdGFibGVDYWxsYmFjayhvblVwZGF0ZUNoaWxkcmVuVW5zdGFibGUgPz8gKCgpID0+IHt9KSk7XG4gICAgY29uc3Qge1xuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c1JldHVybixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuXG4gICAgfSA9IHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb248R3JvdXBFbGVtZW50LCBUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogeyBpbml0aWFsbHlTZWxlY3RlZEluZGV4OiBudWxsLCBzZXRTZWxlY3RlZEluZGV4OiBudWxsIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1xuICAgIH0pO1xuXG4gICAgY29uc3QgeyBnZXRDaGlsZHJlbiB9ID0gbWFuYWdlZENoaWxkcmVuUmV0dXJuO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oKTtcblxuICAgIC8vY29uc3QgW3VuY2hlY2tlZENvdW50LCBzZXRVbmhlY2tlZENvdW50XSA9IHVzZVN0YXRlKDApO1xuXG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCBjaGlsZCBJRHMsIGFuZCBhbnkgdGltZSBhbnkgb2YgdGhlbSBjaGFuZ2UsIFxuICAgIC8vIGdlbmVyYXRlIGEgbmV3IHN0cmluZyB3aXRoIGFsbCBvZiB0aGVtIGNvbmNhdGVuYXRlZCB0b2dldGhlclxuICAgIC8vIChidXQgb25seSBvbmNlIHBlciByZW5kZXIpO1xuICAgIGNvbnN0IGFsbElkcyA9IHVzZVJlZihuZXcgU2V0PHN0cmluZz4oKSk7XG4gICAgY29uc3QgdXBkYXRlUGFyZW50Q29udHJvbElkcyA9IHVzZVN0YWJsZUNhbGxiYWNrKChzZXR0ZXI6IFN0YXRlVXBkYXRlcjxzdHJpbmc+IHwgbnVsbCkgPT4geyBzZXR0ZXI/LihBcnJheS5mcm9tKGFsbElkcy5jdXJyZW50KS5qb2luKFwiIFwiKSkgfSk7XG4gICAgY29uc3QgW2dldFNldHRlciwgc2V0U2V0dGVyXSA9IHVzZVBhc3NpdmVTdGF0ZTxTdGF0ZVVwZGF0ZXI8c3RyaW5nPiB8IG51bGwsIEV2ZW50Pih1cGRhdGVQYXJlbnRDb250cm9sSWRzLCByZXR1cm5OdWxsKTtcbiAgICBjb25zdCBbX2dldFVwZGF0ZUluZGV4LCBzZXRVcGRhdGVJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyLCBFdmVudD4odXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyB1cGRhdGVQYXJlbnRDb250cm9sSWRzKGdldFNldHRlcigpKSB9KSwgcmV0dXJuWmVybyk7XG5cbiAgICAvLyBMb3RzIG9mIG1hY2hlbmVyeSB0byB0cmFjayB3aGF0IHRvdGFsIHBlcmNlbnRhZ2Ugb2YgYWxsIGNoZWNrYm94ZXMgYXJlIGNoZWNrZWQsXG4gICAgLy8gYW5kIG5vdGlmeWluZyB0aGUgcGFyZW50IGNoZWNrYm94IG9mIHRoaXMgaW5mb3JtYXRpb24gKHdoaWxlIHJlLXJlbmRlcmluZyBhcyBsaXR0bGUgYXMgcG9zc2libGUpXG4gICAgY29uc3QgZ2V0U2VsZklzQ2hlY2tlZCA9IHVzZUNhbGxiYWNrKChwZXJjZW50Q2hlY2tlZDogbnVtYmVyKTogQ2hlY2tib3hDaGVja2VkVHlwZSA9PiB7IHJldHVybiBwZXJjZW50Q2hlY2tlZCA8PSAwID8gZmFsc2UgOiBwZXJjZW50Q2hlY2tlZCA+PSAxID8gdHJ1ZSA6IFwibWl4ZWRcIjsgfSwgW10pO1xuICAgIGNvbnN0IG9uQW55Q2hpbGRDaGVja2VkVXBkYXRlID0gdXNlU3RhYmxlQ2FsbGJhY2soKHNldHRlcjogU3RhdGVVcGRhdGVyPENoZWNrYm94Q2hlY2tlZFR5cGU+IHwgbnVsbCwgcGVyY2VudENoZWNrZWQ6IG51bWJlcikgPT4geyBzZXR0ZXI/LihnZXRTZWxmSXNDaGVja2VkKHBlcmNlbnRDaGVja2VkKSk7IH0pXG4gICAgY29uc3QgW2dldFRvdGFsQ2hpbGRyZW4sIHNldFRvdGFsQ2hpbGRyZW5dID0gdXNlUGFzc2l2ZVN0YXRlKHVzZUNhbGxiYWNrKCh0b3RhbENoaWxkcmVuOiBudW1iZXIpID0+IHsgb25BbnlDaGlsZENoZWNrZWRVcGRhdGUoZ2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkKCksIGdldFBlcmNlbnRDaGVja2VkKGdldFRvdGFsQ2hlY2tlZCgpLCB0b3RhbENoaWxkcmVuKSkgfSwgW10pLCByZXR1cm5aZXJvKTtcbiAgICBjb25zdCBbZ2V0VG90YWxDaGVja2VkLCBzZXRUb3RhbENoZWNrZWRdID0gdXNlUGFzc2l2ZVN0YXRlKHVzZUNhbGxiYWNrKCh0b3RhbENoZWNrZWQ6IG51bWJlcikgPT4geyBvbkFueUNoaWxkQ2hlY2tlZFVwZGF0ZShnZXRTZXRQYXJlbnRDaGVja2JveENoZWNrZWQoKSwgZ2V0UGVyY2VudENoZWNrZWQodG90YWxDaGVja2VkLCBnZXRUb3RhbENoaWxkcmVuKCkpKSB9LCBbXSksIHJldHVyblplcm8pO1xuICAgIGNvbnN0IGdldFBlcmNlbnRDaGVja2VkID0gdXNlQ2FsbGJhY2soKHRvdGFsQ2hlY2tlZDogbnVtYmVyLCB0b3RhbENoaWxkcmVuOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgICBpZiAodG90YWxDaGlsZHJlbiA+IDApXG4gICAgICAgICAgICByZXR1cm4gdG90YWxDaGVja2VkIC8gdG90YWxDaGlsZHJlbjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICh0b3RhbENoZWNrZWQgPT0gMCA/IDAgOiAxKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBbZ2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkLCBzZXRTZXRQYXJlbnRDaGVja2JveENoZWNrZWRdID0gdXNlUGFzc2l2ZVN0YXRlPFN0YXRlVXBkYXRlcjxDaGVja2JveENoZWNrZWRUeXBlPiB8IG51bGwsIEV2ZW50Pih1c2VTdGFibGVDYWxsYmFjaygoc2V0dGVyOiBTdGF0ZVVwZGF0ZXI8Q2hlY2tib3hDaGVja2VkVHlwZT4gfCBudWxsKSA9PiB7XG4gICAgICAgIG9uQW55Q2hpbGRDaGVja2VkVXBkYXRlKHNldHRlciwgZ2V0UGVyY2VudENoZWNrZWQoZ2V0VG90YWxDaGVja2VkKCksIGdldFRvdGFsQ2hpbGRyZW4oKSkpXG4gICAgfSkpO1xuXG5cbiAgICBjb25zdCBvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dCA9IHVzZUNhbGxiYWNrKGFzeW5jIChlOiBFdmVudCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgY29uc3Qgc2VsZklzQ2hlY2tlZCA9IGdldFNlbGZJc0NoZWNrZWQoZ2V0UGVyY2VudENoZWNrZWQoZ2V0VG90YWxDaGVja2VkKCksIGdldFRvdGFsQ2hpbGRyZW4oKSkpO1xuICAgICAgICBjb25zdCBuZXh0Q2hlY2tlZCA9IChzZWxmSXNDaGVja2VkID09PSBmYWxzZSA/IFwibWl4ZWRcIiA6IHNlbGZJc0NoZWNrZWQgPT09IFwibWl4ZWRcIiA/IHRydWUgOiBmYWxzZSk7XG4gICAgICAgIGxldCB3aWxsQ2hhbmdlQW55ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHByb21pc2VzOiBQcm9taXNlPGFueT5bXSA9IFtdO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5jaGVja2JveEluZm8uY2hlY2tib3hDaGlsZFR5cGUgPT0gXCJjaGlsZFwiKVxuICAgICAgICAgICAgICAgIHdpbGxDaGFuZ2VBbnkgfHw9IChjaGlsZC5jaGVja2JveEluZm8uZ2V0Q2hlY2tlZCgpICE9IGNoaWxkLmNoZWNrYm94SW5mby5nZXRMYXN0VXNlckNoZWNrZWQoKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkLmNoZWNrYm94SW5mby5jaGVja2JveENoaWxkVHlwZSA9PSBcImNoaWxkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hlY2tlZCA9IGNoaWxkLmNoZWNrYm94SW5mby5nZXRDaGVja2VkKCk7XG4gICAgICAgICAgICAgICAgbGV0IGNoZWNrZWQ6IENoZWNrYm94Q2hlY2tlZFR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGVja2VkID09IFwibWl4ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2lsbENoYW5nZUFueSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSAoY2hpbGQuY2hlY2tib3hJbmZvLmdldExhc3RVc2VyQ2hlY2tlZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gbmV4dENoZWNrZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja2VkICE9IHByZXZDaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBjaGlsZC5jaGVja2JveEluZm8uc2V0Q2hlY2tlZEZyb21QYXJlbnRJbnB1dChjaGVja2VkLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9LCBbXSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIGNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgY2hlY2tib3hHcm91cENoaWxkcmVuQ29udGV4dDogdXNlU3RhYmxlT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBzZXRVcGRhdGVJbmRleCxcbiAgICAgICAgICAgICAgICBhbGxJZHM6IGFsbElkcy5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHNldFRvdGFsQ2hlY2tlZCxcbiAgICAgICAgICAgICAgICBzZXRUb3RhbENoaWxkcmVuXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNoZWNrYm94R3JvdXBQYXJlbnRDb250ZXh0OiB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAgICAgICAgIHNldFNldHRlcixcbiAgICAgICAgICAgICAgICBzZXRTZXRQYXJlbnRDaGVja2JveENoZWNrZWQsXG4gICAgICAgICAgICAgICAgZ2V0UGVyY2VudENoZWNrZWQsXG4gICAgICAgICAgICAgICAgZ2V0VG90YWxDaGVja2VkLFxuICAgICAgICAgICAgICAgIGdldFRvdGFsQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgb25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KSxcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIHByb3BzLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblxuICAgICAgICAvKmNoZWNrYm94R3JvdXA6IHtcbiAgICAgICAgICAgIHBhcmVudElzQ2hlY2tlZDogZ2V0U2VsZklzQ2hlY2tlZFVuc3RhYmxlKCkgYXMgYm9vbGVhbiB8IFwibWl4ZWRcIixcbiAgICAgICAgICAgIHBhcmVudFBlcmNlbnRDaGVja2VkOiAoY2hlY2tlZENvdW50IC8gKGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpICsgMSkpLFxuICAgICAgICB9Ki9cbiAgICB9O1xufVxuXG5cbi8vIElmIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSBwYXJlbnQgY2hlY2tib3gncyB2YWx1ZSwgdGhlbiB0aGlzIHJlZiBob2xkcyBhIG1lbW9yeSBvZiB3aGF0IHZhbHVlcyB3ZXJlIGhlbGQgYmVmb3JlLlxuLy8gT3RoZXJ3aXNlLCBpdCdzIG51bGwgd2hlbiB0aGUgbGFzdCBpbnB1dCB3YXMgZnJvbSBhIGNoaWxkIGNoZWNrYm94LiBcbi8vY29uc3Qgc2F2ZWRDaGVja2VkVmFsdWVzID0gdXNlUmVmPE1hcDxudW1iZXIsIGJvb2xlYW4gfCBcIm1peGVkXCI+IHwgbnVsbD4obnVsbCk7XG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hlY2tib3hHcm91cFBhcmVudDxUQ0UgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICBjb250ZXh0LFxuICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgcHJlc3NQYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVycyxcbn06IFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4pOiBVc2VDaGVja2JveEdyb3VwUGFyZW50UmV0dXJuVHlwZTxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+IHtcbiAgICBjb25zdCB7IGNoZWNrYm94R3JvdXBQYXJlbnRDb250ZXh0OiB7IHNldFNldHRlciwgc2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkLCBnZXRQZXJjZW50Q2hlY2tlZCwgZ2V0VG90YWxDaGVja2VkLCBnZXRUb3RhbENoaWxkcmVuLCBvbkNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dCB9IH0gPSBjb250ZXh0O1xuICAgIC8vY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKGU6IGFueSkgPT4gKGUgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuZm9jdXM/LigpLCBbXSk7XG4gICAgY29uc3Qge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgcHJlc3NSZXR1cm4sXG4gICAgICAgIHByb3BzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVybixcbiAgICB9ID0gdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPiwgbmV2ZXI+KHtcbiAgICAgICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgcHJlc3NQYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICAgICAgLy8gc2luZ2xlIHNlbGVjdGlvbiBpc24ndCB1c2VkIGJlY2F1c2UgY2hlY2tib3hlcyBhcmUgbXVsdGlzZWxlY3Q7IFwiZGlzYWJsZWRcIiByZWZlcnMgb25seSB0byB0aGF0LlxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IHsgYXJpYVByb3BOYW1lOiBudWxsLCBzZWxlY3Rpb25Nb2RlOiBcImRpc2FibGVkXCIsIGRpc2FibGVkOiB0cnVlIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBbYXJpYUNvbnRyb2xzLCBzZXRDb250cm9sc10gPSB1c2VTdGF0ZShcIlwiKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRTZXR0ZXIoKCkgPT4gc2V0Q29udHJvbHMpO1xuICAgIH0sIFtzZXRDb250cm9sc10pO1xuICAgIGRlYnVnTG9nKFwidXNlQ2hlY2tib3hHcm91cFBhcmVudFwiKTtcblxuICAgIGNvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkXSA9IHVzZVN0YXRlPENoZWNrYm94Q2hlY2tlZFR5cGU+KGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRTZXRQYXJlbnRDaGVja2JveENoZWNrZWQoKCkgPT4gc2V0Q2hlY2tlZCk7XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCBjaGVja2JveEdyb3VwUGFyZW50UmV0dXJuID0geyBjaGVja2VkLCBvblBhcmVudENoZWNrZWRDaGFuZ2U6IG9uQ2hlY2tib3hHcm91cFBhcmVudElucHV0LCBnZXRQZXJjZW50OiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7IHJldHVybiBnZXRQZXJjZW50Q2hlY2tlZChnZXRUb3RhbENoZWNrZWQoKSwgZ2V0VG90YWxDaGlsZHJlbigpKSB9KSB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoZWNrYm94R3JvdXBQYXJlbnRSZXR1cm4sXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuLFxuICAgICAgICBwcmVzc1JldHVybixcbiAgICAgICAgcHJvcHM6IHVzZU1lcmdlZFByb3BzKHsgXCJhcmlhLWNvbnRyb2xzXCI6IGFyaWFDb250cm9scyB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRDRT4sIHByb3BzKSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm4sXG4gICAgICAgIC8qY2hlY2tib3hHcm91cFBhcmVudFJldHVybixcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybixcbiAgICAgICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudFByb3BzOiBmdW5jdGlvbiB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4ge1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKHsgXCJhcmlhLWNvbnRyb2xzXCI6IGFyaWFDb250cm9scyB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4sIHByb3BzKTtcbiAgICAgICAgfSovXG4gICAgfVxufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoZWNrYm94R3JvdXBDaGlsZDxUQ0UgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgY2hlY2tib3hHcm91cENoaWxkLFxuICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgY29udGV4dCxcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHByZXNzUGFyYW1ldGVycyxcbiAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnMsXG59OiBVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4pOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4ge1xuICAgIGNvbnN0IHsgY2hlY2tib3hHcm91cENoaWxkcmVuQ29udGV4dDogeyBhbGxJZHMsIHNldFVwZGF0ZUluZGV4LCBzZXRUb3RhbENoaWxkcmVuLCBzZXRUb3RhbENoZWNrZWQsIH0gfSA9IGNvbnRleHQ7XG5cbiAgICBkZWJ1Z0xvZyhcInVzZUNoZWNrYm94R3JvdXBDaGlsZFwiLCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLmluZGV4KTtcbiAgICAvL2NvbnN0IHsgY2hlY2tib3g6IHsgb25DaGVja2VkQ2hhbmdlIH0sIGNoZWNrYm94TGlrZTogeyBjaGVja2VkLCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiB9LCBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSwgaGFzRm9jdXNJbnB1dCwgaGFzRm9jdXNMYWJlbCB9ID0gYXNDaGVja2JveDtcbiAgICAvL2NvbnN0IHsgc3ViSW5mbywgY2hlY2tib3hHcm91cENoaWxkOiB7IGNoZWNrZWQsIGZvY3VzU2VsZiwgb25DaGFuZ2VGcm9tUGFyZW50IH0gfSA9IGFzQ2hlY2tib3hHcm91cENoaWxkO1xuXG4gICAgY29uc3QgeyBjaGVja2VkLCBvbkNoYW5nZUZyb21QYXJlbnQgfSA9IGNoZWNrYm94R3JvdXBDaGlsZDtcbiAgICBjb25zdCBnZXRDaGVja2VkID0gdXNlU3RhYmxlR2V0dGVyKGNoZWNrZWQpO1xuICAgIC8vbGFiZWxQb3NpdGlvbiA/Pz0gXCJzZXBhcmF0ZVwiO1xuICAgIGNvbnN0IFtnZXRMYXN0VXNlckNoZWNrZWQsIHNldExhc3RVc2VyQ2hlY2tlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbiB8IFwibWl4ZWRcIiwgRXZlbnQ+KG51bGwsIHJldHVybkZhbHNlKTtcbiAgICBjb25zdCBvbkNoaWxkQ2hlY2tlZENoYW5nZSA9IHVzZVN0YWJsZUNhbGxiYWNrKChjaGVja2VkOiBDaGVja2JveENoZWNrZWRUeXBlKSA9PiB7XG4gICAgICAgIHNldExhc3RVc2VyQ2hlY2tlZChjaGVja2VkKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uQ29udHJvbElkQ2hhbmdlZCA9IHVzZUNhbGxiYWNrKChuZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQsIHByZXY6IHN0cmluZyB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBpZiAocHJldilcbiAgICAgICAgICAgIGFsbElkcy5kZWxldGUocHJldik7XG5cbiAgICAgICAgaWYgKG5leHQpXG4gICAgICAgICAgICBhbGxJZHMuYWRkKG5leHQpO1xuXG4gICAgICAgIGlmICghIW5leHQgfHwgISFwcmV2KSB7XG4gICAgICAgICAgICBzZXRVcGRhdGVJbmRleChpID0+ICgoaSA/PyAwKSArIDEpKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldFRvdGFsQ2hpbGRyZW4oYyA9PiAoKGMgPz8gMCkgKyAxKSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBzZXRUb3RhbENoaWxkcmVuKGMgPT4gKChjID8/IDApIC0gMSkpO1xuICAgIH0sIFtdKVxuXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgc2V0VG90YWxDaGVja2VkKGMgPT4gKChjID8/IDApICsgMSkpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHNldFRvdGFsQ2hlY2tlZChjID0+ICgoYyA/PyAwKSAtIDEpKTtcbiAgICAgICAgfVxuICAgIH0sIFtjaGVja2VkXSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuLFxuICAgICAgICBwcmVzc1JldHVybixcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuXG4gICAgfSA9IHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZDxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4sIG5ldmVyPih7XG4gICAgICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHsgY2hlY2tib3hJbmZvOiB7IGNoZWNrYm94Q2hpbGRUeXBlOiBcImNoaWxkXCIsIGdldExhc3RVc2VyQ2hlY2tlZCwgZ2V0Q2hlY2tlZCwgc2V0Q2hlY2tlZEZyb21QYXJlbnRJbnB1dDogb25DaGFuZ2VGcm9tUGFyZW50IH0sIC4uLmNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMgfSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyAuLi5tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICAgICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczogeyBhcmlhUHJvcE5hbWU6IG51bGwsIHNlbGVjdGlvbk1vZGU6IFwiZGlzYWJsZWRcIiwgZGlzYWJsZWQ6IHRydWUgfSxcbiAgICAgICAgLy9zdWJJbmZvOiB7IHR5cGU6IFwiY2hpbGRcIiwgZ2V0TGFzdFVzZXJDaGVja2VkLCBzZXRDaGVja2VkRnJvbVBhcmVudElucHV0OiBvbkNoYW5nZUZyb21QYXJlbnQsIGdldENoZWNrZWQsIHN1YkluZm8gfSxcbiAgICAgICAgLypsaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczogYXNDaGVja2JveEdyb3VwQ2hpbGQubGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IGFzQ2hlY2tib3hHcm91cENoaWxkLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm46IGFzQ2hlY2tib3hHcm91cENoaWxkLnJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IC4uLmFzQ2hlY2tib3hHcm91cENoaWxkLnJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLCBmb2N1c1NlbGYgfSovXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGVja2JveEdyb3VwQ2hpbGQ6IHtcbiAgICAgICAgICAgIG9uQ2hpbGRDaGVja2VkQ2hhbmdlLFxuICAgICAgICAgICAgb25Db250cm9sSWRDaGFuZ2VkXG4gICAgICAgIH0sXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuLFxuICAgICAgICBwcmVzc1JldHVybixcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuXG5cbiAgICB9XG5cblxuXG59XG5cbiIsIlxyXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBmaW5kRmlyc3RGb2N1c2FibGUsIHVzZU1lcmdlZFByb3BzLCB1c2VNb2RhbCwgVXNlTW9kYWxQYXJhbWV0ZXJzLCBVc2VNb2RhbFJldHVyblR5cGUsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcclxuaW1wb3J0IHsgUHJlZmljZXMgfSBmcm9tIFwiLi9wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VMYWJlbFN5bnRoZXRpYywgVXNlTGFiZWxTeW50aGV0aWNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XHJcblxyXG4vKlxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZURpYWxvZ1JldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VEaWFsb2dUaXRsZTxUaXRsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlRGlhbG9nVGl0bGVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+OyB9O1xyXG5leHBvcnQgdHlwZSBVc2VEaWFsb2dCb2R5PEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZURpYWxvZ0JvZHlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PjsgfTtcclxuZXhwb3J0IHR5cGUgVXNlRGlhbG9nQmFja2Ryb3A8QmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZURpYWxvZ0JhY2tkcm9wUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8QmFja2Ryb3BFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8QmFja2Ryb3BFbGVtZW50PjsgfTtcclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZURpYWxvZ1JldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIFVzZU1vZGFsUmV0dXJuVHlwZSB7XHJcbiAgICB1c2VEaWFsb2dQcm9wczogVXNlTW9kYWxSZXR1cm5UeXBlV2l0aEhvb2tzPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50PltcInVzZU1vZGFsUHJvcHNcIl07XHJcbiAgICB1c2VEaWFsb2dUaXRsZTogVXNlRGlhbG9nVGl0bGU8VGl0bGVFbGVtZW50PjtcclxuICAgIHVzZURpYWxvZ0JvZHk6IFVzZURpYWxvZ0JvZHk8Qm9keUVsZW1lbnQ+O1xyXG4gICAgdXNlRGlhbG9nQmFja2Ryb3A6IFVzZURpYWxvZ0JhY2tkcm9wPEJhY2tkcm9wRWxlbWVudD47XHJcbiAgICB1c2VEaWFsb2dGb2N1c0NvbnRhaW5lclByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rm9jdXNDb250YWluZXJFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VEaWFsb2dQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTW9kYWxQYXJhbWV0ZXJzPFwiYmFja2Ryb3BcIiB8IFwiZXNjYXBlXCI+IHtcclxuICAgIC8vZGlhbG9nOiB7IG9uQ2xvc2U6IChyZWFzb246IFwiZXNjYXBlXCIgfCBcImJhY2tkcm9wXCIpID0+IHZvaWQ7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZURpYWxvZzxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcclxuICAgIGRpc21pc3NQYXJhbWV0ZXJzLFxyXG4gICAgZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnMsXHJcbiAgICBmb2N1c1RyYXBQYXJhbWV0ZXJzXHJcbn06IFVzZURpYWxvZ1BhcmFtZXRlcnMpOiBVc2VEaWFsb2dSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50PiB7XHJcblxyXG4gICAgZGVidWdMb2coXCJ1c2VEaWFsb2dcIik7XHJcblxyXG4gICAgLy8gVE9ETzogRGlmZmVyZW5jZXMgYmV0d2VlbiBkaWFsb2cgYW5kIG1vZGFsIGdvIGhlcmUsIHByZXN1bWFibHkuXHJcbiAgICAvLyBOb24tbW9kYWwgZGlhbG9ncyBuZWVkIHRvIGJlIGFibGUgdG8gYmUgcmVwb3NpdGlvbmVkLCBldGMuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgZm9jdXNUcmFwUmV0dXJuLFxyXG4gICAgICAgIHByb3BzUG9wdXAsXHJcbiAgICAgICAgcHJvcHNTb3VyY2UsXHJcbiAgICAgICAgcmVmRWxlbWVudFBvcHVwUmV0dXJuLFxyXG4gICAgICAgIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm5cclxuICAgIH0gPSB1c2VNb2RhbDxcImJhY2tkcm9wXCIgfCBcImVzY2FwZVwiLCBGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERpYWxvZ0VsZW1lbnQ+KHtcclxuICAgICAgICBkaXNtaXNzUGFyYW1ldGVycyxcclxuICAgICAgICBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycyxcclxuICAgICAgICBmb2N1c1RyYXBQYXJhbWV0ZXJzXHJcbiAgICB9KTtcclxuICAgIHR5cGUgUiA9IFVzZURpYWxvZ1JldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQsIEJvZHlFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQ+O1xyXG4gICAgY29uc3QgdXNlRGlhbG9nQmFja2Ryb3AgPSB1c2VDYWxsYmFjazxSW1widXNlRGlhbG9nQmFja2Ryb3BcIl0+KCgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9ID0gdXNlTW9kYWxCYWNrZHJvcCgpO1xyXG4gICAgICAgIHJldHVybiB7IHVzZURpYWxvZ0JhY2tkcm9wUHJvcHM6IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9O1xyXG4gICAgfSwgW3VzZU1vZGFsQmFja2Ryb3BdKTtcclxuXHJcbiAgICBjb25zdCB1c2VEaWFsb2dCb2R5ID0gdXNlQ2FsbGJhY2s8UltcInVzZURpYWxvZ0JvZHlcIl0+KCgpID0+IHtcclxuICAgICAgICBjb25zdCB7IHVzZU1vZGFsQm9keVByb3BzIH0gPSB1c2VNb2RhbEJvZHkoKTtcclxuICAgICAgICByZXR1cm4geyB1c2VEaWFsb2dCb2R5UHJvcHM6IHVzZU1vZGFsQm9keVByb3BzIH07XHJcbiAgICB9LCBbdXNlTW9kYWxCYWNrZHJvcF0pO1xyXG4gICAgY29uc3QgdXNlRGlhbG9nUHJvcHMgPSB1c2VNb2RhbFByb3BzO1xyXG5cclxuICAgIGNvbnN0IHVzZURpYWxvZ1RpdGxlID0gdXNlQ2FsbGJhY2s8UltcInVzZURpYWxvZ1RpdGxlXCJdPigoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VNb2RhbFRpdGxlUHJvcHMgfSA9IHVzZU1vZGFsVGl0bGUoKTtcclxuICAgICAgICByZXR1cm4geyB1c2VEaWFsb2dUaXRsZVByb3BzOiB1c2VNb2RhbFRpdGxlUHJvcHMgfTtcclxuICAgIH0sIFt1c2VNb2RhbFRpdGxlXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VEaWFsb2dQcm9wcyxcclxuICAgICAgICB1c2VEaWFsb2dUaXRsZSxcclxuICAgICAgICB1c2VEaWFsb2dCb2R5LFxyXG4gICAgICAgIHVzZURpYWxvZ0JhY2tkcm9wLFxyXG4gICAgICAgIHVzZURpYWxvZ0ZvY3VzQ29udGFpbmVyUHJvcHM6IHVzZU1vZGFsRm9jdXNDb250YWluZXJQcm9wcyxcclxuICAgICAgICBzb2Z0RGlzbWlzczogeyBvbkJhY2tkcm9wQ2xpY2sgfSxcclxuICAgIH1cclxufSovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZURpYWxvZ1BhcmFtZXRlcnM8X0RpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZU1vZGFsUGFyYW1ldGVyczxcImVzY2FwZVwiIHwgXCJiYWNrZHJvcFwiPiwgXCJmb2N1c1RyYXBQYXJhbWV0ZXJzXCIgfCBcImRpc21pc3NQYXJhbWV0ZXJzXCI+IHtcclxuICAgIGZvY3VzVHJhcFBhcmFtZXRlcnM6IE9taXQ8VXNlTW9kYWxQYXJhbWV0ZXJzPFwiZXNjYXBlXCIgfCBcImJhY2tkcm9wXCI+W1wiZm9jdXNUcmFwUGFyYW1ldGVyc1wiXSwgXCJ0cmFwQWN0aXZlXCIgfCBcIm9ubHlNb3ZlRm9jdXNcIj47XHJcbiAgICBkaXNtaXNzUGFyYW1ldGVyczogT21pdDxVc2VNb2RhbFBhcmFtZXRlcnM8XCJlc2NhcGVcIiB8IFwiYmFja2Ryb3BcIj5bXCJkaXNtaXNzUGFyYW1ldGVyc1wiXSwgXCJjbG9zZU9uTG9zdEZvY3VzXCI+O1xyXG4gICAgbGFiZWxQYXJhbWV0ZXJzOiBPbWl0PFVzZUxhYmVsU3ludGhldGljUGFyYW1ldGVyc1tcImxhYmVsUGFyYW1ldGVyc1wiXSwgXCJvbkxhYmVsQ2xpY2tcIj47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlRGlhbG9nUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUG9wdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZU1vZGFsUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIFBvcHVwRWxlbWVudD4sIFwicHJvcHNQb3B1cFwiPiB7XHJcbiAgICBwcm9wc0RpYWxvZzogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UG9wdXBFbGVtZW50PjtcclxuICAgIHByb3BzVGl0bGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgU291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGRpc21pc3NQYXJhbWV0ZXJzLCBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycywgZm9jdXNUcmFwUGFyYW1ldGVycywgbGFiZWxQYXJhbWV0ZXJzIH06IFVzZURpYWxvZ1BhcmFtZXRlcnM8RGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50Pik6IFVzZURpYWxvZ1JldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQ+IHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICBmb2N1c1RyYXBSZXR1cm4sXHJcbiAgICAgICAgcHJvcHNGb2N1c0NvbnRhaW5lcixcclxuICAgICAgICBwcm9wc1BvcHVwLFxyXG4gICAgICAgIHByb3BzU291cmNlLFxyXG4gICAgICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybixcclxuICAgICAgICByZWZFbGVtZW50U291cmNlUmV0dXJuXHJcbiAgICB9ID0gdXNlTW9kYWw8XCJlc2NhcGVcIiB8IFwiYmFja2Ryb3BcIiwgRm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBEaWFsb2dFbGVtZW50Pih7XHJcbiAgICAgICAgZGlzbWlzc1BhcmFtZXRlcnM6IHsgY2xvc2VPbkxvc3RGb2N1czogZmFsc2UsIC4uLmRpc21pc3NQYXJhbWV0ZXJzIH0sXHJcbiAgICAgICAgZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnMsXHJcbiAgICAgICAgZm9jdXNUcmFwUGFyYW1ldGVyczogeyB0cmFwQWN0aXZlOiB0cnVlLCBvbmx5TW92ZUZvY3VzOiBmYWxzZSwgLi4uZm9jdXNUcmFwUGFyYW1ldGVycyB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgcHJvcHNJbnB1dCxcclxuICAgICAgICBwcm9wc0xhYmVsXHJcbiAgICB9ID0gdXNlTGFiZWxTeW50aGV0aWM8RGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50Pih7XHJcbiAgICAgICAgbGFiZWxQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgIC4uLmxhYmVsUGFyYW1ldGVycywgb25MYWJlbENsaWNrOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gcmVmRWxlbWVudFBvcHVwUmV0dXJuLmdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgIGZvY3VzVHJhcFBhcmFtZXRlcnMuZm9jdXNQb3B1cChlLCAoKSA9PiBmaW5kRmlyc3RGb2N1c2FibGUoZSEpKTtcclxuXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSxcclxuICAgICAgICByYW5kb21JZElucHV0UGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLmRpYWxvZyB9LFxyXG4gICAgICAgIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzOiB7IHByZWZpeDogUHJlZmljZXMuZGlhbG9nVGl0bGUgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmb2N1c1RyYXBSZXR1cm4sXHJcbiAgICAgICAgcHJvcHNGb2N1c0NvbnRhaW5lcixcclxuICAgICAgICBwcm9wc0RpYWxvZzogdXNlTWVyZ2VkUHJvcHM8RGlhbG9nRWxlbWVudD4ocHJvcHNQb3B1cCwgcHJvcHNJbnB1dCksXHJcbiAgICAgICAgcHJvcHNTb3VyY2UsXHJcbiAgICAgICAgcHJvcHNUaXRsZTogcHJvcHNMYWJlbCxcclxuICAgICAgICByZWZFbGVtZW50UG9wdXBSZXR1cm4sXHJcbiAgICAgICAgcmVmRWxlbWVudFNvdXJjZVJldHVyblxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBmaW5kRmlyc3RGb2N1c2FibGUsIHVzZU1lcmdlZFByb3BzLCB1c2VNb2RhbCwgVXNlTW9kYWxQYXJhbWV0ZXJzLCBVc2VNb2RhbFJldHVyblR5cGUsIHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IFByZWZpY2VzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUxhYmVsU3ludGhldGljLCBVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcbi8qaW1wb3J0IHsgdXNlTW9kYWwsIFVzZU1vZGFsUGFyYW1ldGVycywgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1tb2RhbFwiO1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRHJhd2VyUmV0dXJuVHlwZUluZm8gZXh0ZW5kcyBVc2VTb2Z0RGlzbWlzc1JldHVyblR5cGVJbmZvIHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyYXdlclJldHVyblR5cGVXaXRoSG9va3M8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTW9kYWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZURyYXdlclJldHVyblR5cGVJbmZvIHtcbiAgICB1c2VEcmF3ZXJQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNb2RhbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNb2RhbEVsZW1lbnQ+O1xuICAgIHVzZURyYXdlclRpdGxlOiBVc2VEcmF3ZXJUaXRsZTxUaXRsZUVsZW1lbnQ+O1xuICAgIHVzZURyYXdlckJvZHk6IFVzZURyYXdlckJvZHk8Qm9keUVsZW1lbnQ+XG4gICAgdXNlRHJhd2VyQmFja2Ryb3A6IFVzZURyYXdlckJhY2tkcm9wPEJhY2tkcm9wRWxlbWVudD47XG4gICAgdXNlRHJhd2VyRm9jdXNDb250YWluZXJQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rm9jdXNDb250YWluZXJFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD47XG59XG5cbmV4cG9ydCB0eXBlIFVzZURyYXdlclRpdGxlPFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VEcmF3ZXJUaXRsZVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD47IH07XG5leHBvcnQgdHlwZSBVc2VEcmF3ZXJCb2R5PEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZURyYXdlckJvZHlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PjsgfTtcbmV4cG9ydCB0eXBlIFVzZURyYXdlckJhY2tkcm9wPEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VEcmF3ZXJCYWNrZHJvcFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD47IH07XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VEcmF3ZXJQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTW9kYWxQYXJhbWV0ZXJzPG5ldmVyLCBuZXZlcj4ge1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRHJhd2VyPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBEcmF3ZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBzb2Z0RGlzbWlzczogeyBvcGVuLCBvbkNsb3NlIH0sIGFjdGl2ZUVsZW1lbnQsIG1vZGFsOiB7IGJvZHlJc09ubHlTZW1hbnRpYywgZm9jdXNTZWxmIH0gfTogVXNlRHJhd2VyUGFyYW1ldGVycyk6IFVzZURyYXdlclJldHVyblR5cGVXaXRoSG9va3M8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEcmF3ZXJFbGVtZW50LCBUaXRsZUVsZW1lbnQsIEJvZHlFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQ+IHtcblxuICAgIGRlYnVnTG9nKFwidXNlRHJhd2VyXCIpO1xuXG4gICAgLy8gVE9ETzogRHJhd2VycyBhcmUgbm90IGFsd2F5cyBtb2RhbC5cblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTW9kYWxCYWNrZHJvcCxcbiAgICAgICAgdXNlTW9kYWxCb2R5LFxuICAgICAgICB1c2VNb2RhbFByb3BzLFxuICAgICAgICB1c2VNb2RhbFRpdGxlLFxuICAgICAgICB1c2VNb2RhbEZvY3VzQ29udGFpbmVyUHJvcHMsXG4gICAgICAgIHNvZnREaXNtaXNzOiB7IG9uQmFja2Ryb3BDbGljayB9XG4gICAgfSA9IHVzZU1vZGFsPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50Pih7IG1vZGFsOiB7IGJvZHlJc09ubHlTZW1hbnRpYzogKGJvZHlJc09ubHlTZW1hbnRpYyA/PyBmYWxzZSksIGZvY3VzU2VsZiB9LCBzb2Z0RGlzbWlzczogeyBvbkNsb3NlLCBvcGVuIH0sIGFjdGl2ZUVsZW1lbnQgfSk7XG5cbiAgICBjb25zdCB1c2VEcmF3ZXJCYWNrZHJvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyB1c2VNb2RhbEJhY2tkcm9wUHJvcHMgfSA9IHVzZU1vZGFsQmFja2Ryb3AoKTtcbiAgICAgICAgcmV0dXJuIHsgdXNlRHJhd2VyQmFja2Ryb3BQcm9wczogdXNlTW9kYWxCYWNrZHJvcFByb3BzIH07XG4gICAgfSwgW3VzZU1vZGFsQmFja2Ryb3BdKTtcblxuICAgIGNvbnN0IHVzZURyYXdlckJvZHkgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlTW9kYWxCb2R5UHJvcHMgfSA9IHVzZU1vZGFsQm9keSgpO1xuICAgICAgICByZXR1cm4geyB1c2VEcmF3ZXJCb2R5UHJvcHM6IHVzZU1vZGFsQm9keVByb3BzIH07XG4gICAgfSwgW3VzZU1vZGFsQmFja2Ryb3BdKTtcbiAgICBjb25zdCB1c2VEcmF3ZXJQcm9wcyA9IHVzZU1vZGFsUHJvcHM7XG5cbiAgICBjb25zdCB1c2VEcmF3ZXJUaXRsZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyB1c2VNb2RhbFRpdGxlUHJvcHMgfSA9IHVzZU1vZGFsVGl0bGUoKTtcbiAgICAgICAgcmV0dXJuIHsgdXNlRHJhd2VyVGl0bGVQcm9wczogdXNlTW9kYWxUaXRsZVByb3BzIH07XG4gICAgfSwgW3VzZU1vZGFsVGl0bGVdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZURyYXdlclByb3BzLFxuICAgICAgICB1c2VEcmF3ZXJUaXRsZSxcbiAgICAgICAgdXNlRHJhd2VyQm9keSxcbiAgICAgICAgdXNlRHJhd2VyQmFja2Ryb3AsXG4gICAgICAgIHVzZURyYXdlckZvY3VzQ29udGFpbmVyUHJvcHM6IHVzZU1vZGFsRm9jdXNDb250YWluZXJQcm9wcyxcbiAgICAgICAgc29mdERpc21pc3M6IHsgb25CYWNrZHJvcENsaWNrIH1cbiAgICB9XG59Ki9cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRHJhd2VyUGFyYW1ldGVyczxfRGlhbG9nRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIF9UaXRsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTW9kYWxQYXJhbWV0ZXJzPFwiZXNjYXBlXCIgfCBcImJhY2tkcm9wXCIgfCBcImxvc3QtZm9jdXNcIj4sIFwiZm9jdXNUcmFwUGFyYW1ldGVyc1wiPiB7XG4gICAgbGFiZWxQYXJhbWV0ZXJzOiBPbWl0PFVzZUxhYmVsU3ludGhldGljUGFyYW1ldGVyc1tcImxhYmVsUGFyYW1ldGVyc1wiXSwgXCJvbkxhYmVsQ2xpY2tcIj47XG4gICAgZm9jdXNUcmFwUGFyYW1ldGVyczogT21pdDxVc2VNb2RhbFBhcmFtZXRlcnM8XCJlc2NhcGVcIiB8IFwiYmFja2Ryb3BcIiB8IFwibG9zdC1mb2N1c1wiPltcImZvY3VzVHJhcFBhcmFtZXRlcnNcIl0sIFwib25seU1vdmVGb2N1c1wiPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyYXdlclJldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgU291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIERyYXdlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTW9kYWxSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgU291cmNlRWxlbWVudCwgRHJhd2VyRWxlbWVudD4sIFwicHJvcHNQb3B1cFwiPiB7XG4gICAgcHJvcHNEcmF3ZXI6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPERyYXdlckVsZW1lbnQ+O1xuICAgIHByb3BzVGl0bGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEcmF3ZXI8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgU291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFBvcHVwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgZGlzbWlzc1BhcmFtZXRlcnMsIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzLCBmb2N1c1RyYXBQYXJhbWV0ZXJzLCBsYWJlbFBhcmFtZXRlcnMgfTogVXNlRHJhd2VyUGFyYW1ldGVyczxQb3B1cEVsZW1lbnQsIFRpdGxlRWxlbWVudD4pOiBVc2VEcmF3ZXJSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgU291cmNlRWxlbWVudCwgUG9wdXBFbGVtZW50LCBUaXRsZUVsZW1lbnQ+IHtcbiAgICBjb25zdCB7XG4gICAgICAgIGZvY3VzVHJhcFJldHVybixcbiAgICAgICAgcHJvcHNGb2N1c0NvbnRhaW5lcixcbiAgICAgICAgcHJvcHNQb3B1cCxcbiAgICAgICAgcHJvcHNTb3VyY2UsXG4gICAgICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybixcbiAgICAgICAgcmVmRWxlbWVudFNvdXJjZVJldHVyblxuICAgIH0gPSB1c2VNb2RhbDxcImVzY2FwZVwiIHwgXCJiYWNrZHJvcFwiIHwgXCJsb3N0LWZvY3VzXCIsIEZvY3VzQ29udGFpbmVyRWxlbWVudCwgU291cmNlRWxlbWVudCwgUG9wdXBFbGVtZW50Pih7XG4gICAgICAgIGRpc21pc3NQYXJhbWV0ZXJzLFxuICAgICAgICBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycyxcbiAgICAgICAgZm9jdXNUcmFwUGFyYW1ldGVyczogeyBvbmx5TW92ZUZvY3VzOiBmYWxzZSwgIC4uLmZvY3VzVHJhcFBhcmFtZXRlcnMgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICBwcm9wc0lucHV0LFxuICAgICAgICBwcm9wc0xhYmVsLFxuICAgIH0gPSB1c2VMYWJlbFN5bnRoZXRpYzxQb3B1cEVsZW1lbnQsIFRpdGxlRWxlbWVudD4oe1xuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIC4uLmxhYmVsUGFyYW1ldGVycywgb25MYWJlbENsaWNrOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHJlZkVsZW1lbnRQb3B1cFJldHVybi5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgZm9jdXNUcmFwUGFyYW1ldGVycy5mb2N1c1BvcHVwKGUsICgpID0+IGZpbmRGaXJzdEZvY3VzYWJsZShlISkpO1xuXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICByYW5kb21JZElucHV0UGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLmRyYXdlciB9LFxuICAgICAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLmRyYXdlclRpdGxlIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGZvY3VzVHJhcFJldHVybixcbiAgICAgICAgcHJvcHNGb2N1c0NvbnRhaW5lcixcbiAgICAgICAgcHJvcHNEcmF3ZXI6IHVzZU1lcmdlZFByb3BzPFBvcHVwRWxlbWVudD4ocHJvcHNQb3B1cCwgcHJvcHNJbnB1dCksXG4gICAgICAgIHByb3BzVGl0bGU6IHByb3BzTGFiZWwsXG4gICAgICAgIHByb3BzU291cmNlLFxuICAgICAgICByZWZFbGVtZW50UG9wdXBSZXR1cm4sXG4gICAgICAgIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm5cbiAgICB9XG59XG5cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7XG4gICAgQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQsXG4gICAgQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd0NvbnRleHQsXG4gICAgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRDZWxsSW5mbyxcbiAgICBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm8sXG4gICAgdXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbixcbiAgICB1c2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbCxcbiAgICBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnMsXG4gICAgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlLFxuICAgIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlLFxuICAgIHVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3csXG4gICAgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMsXG4gICAgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGUsXG4gICAgdXNlTWVyZ2VkUHJvcHMsXG4gICAgdXNlU2luZ2xlU2VsZWN0aW9uRGVjbGFyYXRpdmUsXG4gICAgdXNlU3RhYmxlQ2FsbGJhY2ssXG4gICAgdXNlU3RhYmxlT2JqZWN0XG59IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBQcmVmaWNlcyB9IGZyb20gXCIuL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VMYWJlbFN5bnRoZXRpYywgVXNlTGFiZWxTeW50aGV0aWNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XG5pbXBvcnQgeyBVc2VMaXN0Ym94UGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1saXN0Ym94XCI7XG5cbi8vdHlwZSBMaXN0Ym94U2luZ2xlU2VsZWN0RXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IHsgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfSB9ICYgUGljazxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+LCBcInRhcmdldFwiIHwgXCJjdXJyZW50VGFyZ2V0XCI+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0Q29udGV4dDxHcmlkbGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcmlkbGlzdFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkbGlzdFJvd0luZm88R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPEdyaWRsaXN0Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIENvbXBsZXRlR3JpZE5hdmlnYXRpb25Db250ZXh0PEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+IHtcbiAgICBncmlkbGlzdFJvd0NvbnRleHQ6IHsgc2VsZWN0aW9uTGltaXQ6IFwic2luZ2xlXCIgfCBcIm11bHRpXCIgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0Um93Q29udGV4dDxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88Q2hpbGRFbGVtZW50Pj4gZXh0ZW5kcyBDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93Q29udGV4dDxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIE0+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0UGFyYW1ldGVyczxHcmlkbGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcmlkbGlzdFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkbGlzdFJvd0luZm88R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50Pj4gZXh0ZW5kcyBPbWl0PFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTT4sIFwic2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyc1wiPiB7XG4gICAgbGFiZWxQYXJhbWV0ZXJzOiBPbWl0PFVzZUxhYmVsU3ludGhldGljUGFyYW1ldGVyc1tcImxhYmVsUGFyYW1ldGVyc1wiXSwgXCJvbkxhYmVsQ2xpY2tcIj47XG4gICAgZ3JpZGxpc3RQYXJhbWV0ZXJzOiBVc2VMaXN0Ym94UGFyYW1ldGVyczxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTT5bXCJsaXN0Ym94UGFyYW1ldGVyc1wiXTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RSZXR1cm5UeXBlPEdyaWRsaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRsaXN0Um93SW5mbzxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88R3JpZGxpc3RDZWxsRWxlbWVudD4+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJwcm9wc1wiPiB7XG4gICAgcHJvcHNHcmlkbGlzdDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JpZGxpc3RFbGVtZW50PjtcbiAgICBwcm9wc0dyaWRsaXN0TGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XG4gICAgY29udGV4dDogVXNlR3JpZGxpc3RDb250ZXh0PEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+O1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkbGlzdFJvd1JldHVyblR5cGU8R3JpZGxpc3RSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgR3JpZGxpc3RSb3dJbmZvPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZGxpc3RDZWxsSW5mbzxHcmlkbGlzdENlbGxFbGVtZW50Pj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZTxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkbGlzdFJvd0luZm88R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPEdyaWRsaXN0Q2VsbEVsZW1lbnQ+PiB7Ly8gZXh0ZW5kcyBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4ge1xuXG4gICAgYXNDaGlsZFJvd1BhcmFtZXRlcnM6IFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPltcImFzQ2hpbGRSb3dQYXJhbWV0ZXJzXCJdICYge1xuICAgICAgICBjb250ZXh0OiBVc2VHcmlkbGlzdENvbnRleHQ8YW55LCBHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT47XG4gICAgICAgIGdyaWRsaXN0Um93UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBgc2VsZWN0aW9uTGltaXRgIGlzIGBcInNpbmdsZVwiYCwgdGhpcyBtdXN0IGJlIGBudWxsYC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VsZWN0ZWQ6IGJvb2xlYW4gfCBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzUGFyZW50Um93UGFyYW1ldGVyczogT21pdDxVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT5bXCJhc1BhcmVudFJvd1BhcmFtZXRlcnNcIl0sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4gJiB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPltcImFzUGFyZW50Um93UGFyYW1ldGVyc1wiXVtcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCJdLCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiIHwgXCJpc1ZhbGlkXCI+XG4gICAgICAgIC8vdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IE9taXQ8VXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+W1wiYXNQYXJlbnRSb3dQYXJhbWV0ZXJzXCJdW1widHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIl0sIFwiaXNWYWxpZFwiPlxuICAgICAgICAvL3JvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogT21pdDxVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT5bXCJhc1BhcmVudFJvd1BhcmFtZXRlcnNcIl1bXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIl0sIFwiaW5pdGlhbGx5VGFiYmVkSW5kZXhcIj47XG4gICAgfVxuICAgIC8vY29udGV4dDogIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPltcIlwiXVxuICAgIC8vY29udGV4dDogVXNlR3JpZGxpc3RDb250ZXh0PGFueSwgR3JpZGxpc3RSb3dFbGVtZW50LCBSTT47XG4gICAgLy9ncmlkbGlzdFJvd0NvbnRleHQ6IFVzZUdyaWRsaXN0Q29udGV4dDxhbnksIEdyaWRsaXN0Um93RWxlbWVudCwgUk0+W1wiZ3JpZGxpc3RSb3dDb250ZXh0XCJdO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RDZWxsUmV0dXJuVHlwZTxHcmlkbGlzdENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ00gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPEdyaWRsaXN0Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZTxHcmlkbGlzdENlbGxFbGVtZW50LCBDTT4geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnM8R3JpZGxpc3RDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENNIGV4dGVuZHMgR3JpZGxpc3RDZWxsSW5mbzxHcmlkbGlzdENlbGxFbGVtZW50Pj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8R3JpZGxpc3RDZWxsRWxlbWVudCwgQ00+IHsgfVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyaWRsaXN0Um93SW5mbzxHcmlkbGlzdFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50PiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgR3JpZGxpc3RDZWxsSW5mbzxHcmlkbGlzdENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZENlbGxJbmZvPEdyaWRsaXN0Q2VsbEVsZW1lbnQ+IHsgfVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlR3JpZGxpc3Q8R3JpZGxpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgR3JpZGxpc3RSb3dJbmZvPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgR3JpZGxpc3RDZWxsSW5mbzxHcmlkbGlzdENlbGxFbGVtZW50Pj4oe1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICBsYWJlbFBhcmFtZXRlcnMsXG4gICAgZ3JpZGxpc3RQYXJhbWV0ZXJzOiB7IHNlbGVjdGlvbkxpbWl0LCBncm91cGluZ1R5cGUsIHNlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXggfSxcbiAgICBncmlkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1xufTogVXNlR3JpZGxpc3RQYXJhbWV0ZXJzPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJNPik6IFVzZUdyaWRsaXN0UmV0dXJuVHlwZTxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTSwgQ00+IHtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgcHJvcHNJbnB1dDogcHJvcHNMYWJlbExpc3QsXG4gICAgICAgIHByb3BzTGFiZWw6IHByb3BzTGFiZWxMYWJlbCxcbiAgICAgICAgcmFuZG9tSWRJbnB1dFJldHVybjogeyBpZDogX2dyaWRsaXN0SWQgfSxcbiAgICAgICAgcmFuZG9tSWRMYWJlbFJldHVybjogeyBpZDogX2xhYmVsSWQgfVxuICAgIH0gPSB1c2VMYWJlbFN5bnRoZXRpYzxHcmlkbGlzdEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIC4uLmxhYmVsUGFyYW1ldGVycyxcbiAgICAgICAgICAgIG9uTGFiZWxDbGljazogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLmZvY3VzU2VsZigpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5ncmlkbGlzdCB9LFxuICAgICAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLmdyaWRsaXN0TGFiZWwgfVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVyblxuICAgIH0gPSB1c2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogeyBpbml0aWFsbHlTZWxlY3RlZEluZGV4OiBzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4IH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXG4gICAgfSk7XG5cbiAgICBjb25zdCBfdjogdm9pZCA9IHVzZVNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlKHsgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLCBzaW5nbGVTZWxlY3Rpb25EZWNsYXJhdGl2ZVBhcmFtZXRlcnM6IHsgc2VsZWN0ZWRJbmRleCB9IH0pO1xuXG4gICAgbGV0IHByb3BzR3JpZGxpc3QgPSB1c2VNZXJnZWRQcm9wcyhwcm9wcywgcHJvcHNMYWJlbExpc3QsIHsgXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiOiAoc2VsZWN0aW9uTGltaXQgPT0gXCJtdWx0aVwiID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQpIH0pO1xuXG5cbiAgICBsZXQgZnVsbENvbnRleHQgPSB1c2VTdGFibGVPYmplY3Qoe1xuICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICBncmlkbGlzdFJvd0NvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICBzZWxlY3Rpb25MaW1pdFxuICAgICAgICB9KVxuICAgIH0pO1xuICAgIGlmIChncm91cGluZ1R5cGUgPT0gXCJncm91cFwiKVxuICAgICAgICBwcm9wc0dyaWRsaXN0LnJvbGUgPSBcImdyb3VwXCI7XG4gICAgZWxzZSBpZiAoZ3JvdXBpbmdUeXBlID09IFwid2l0aC1ncm91cHNcIikge1xuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGNsb2JiZXJpbmcgYWxsIHRoZSBsaXN0IG5hdmlnYXRpb24gc3R1ZmYuXG4gICAgICAgIHByb3BzR3JpZGxpc3QgPSB7IHJvbGU6IFwiZ3JpZFwiIH07XG4gICAgICAgIC8vIC4uLmFjdHVhbGx5LCBjb250ZXh0IHRvbyB3aGlsZSB3ZSdyZSBhdCBpdC5cbiAgICAgICAgZnVsbENvbnRleHQgPSBudWxsIVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvcHNHcmlkbGlzdC5yb2xlID0gXCJncmlkXCI7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGlvbkxpbWl0ID09IFwibXVsdGlcIilcbiAgICAgICAgY29uc29sZS5hc3NlcnQoc2luZ2xlU2VsZWN0aW9uUmV0dXJuLmdldFNlbGVjdGVkSW5kZXgoKSA9PSBudWxsKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQ6IGZ1bGxDb250ZXh0LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgcHJvcHNHcmlkbGlzdCxcbiAgICAgICAgcHJvcHNHcmlkbGlzdExhYmVsOiBwcm9wc0xhYmVsTGFiZWxcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkbGlzdFJvdzxHcmlkbGlzdFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkbGlzdFJvd0luZm88R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPEdyaWRsaXN0Q2VsbEVsZW1lbnQ+Pih7XG4gICAgYXNDaGlsZFJvd1BhcmFtZXRlcnM6IHtcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBjb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVycyxcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIGNvbnRleHQ6IGN4MSxcbiAgICAgICAgZ3JpZGxpc3RSb3dQYXJhbWV0ZXJzOiB7IHNlbGVjdGVkIH1cbiAgICB9LFxuICAgIGFzUGFyZW50Um93UGFyYW1ldGVyczoge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1xuICAgIH1cbn06IFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4pOiBVc2VHcmlkbGlzdFJvd1JldHVyblR5cGU8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+IHtcbiAgICBjb25zdCB7IGdyaWRsaXN0Um93Q29udGV4dDogeyBzZWxlY3Rpb25MaW1pdCB9IH0gPSBjeDE7XG4gICAgY29uc3Qge1xuICAgICAgICBhc0NoaWxkUm93UmV0dXJuLFxuICAgICAgICBhc1BhcmVudFJvd1JldHVybixcbiAgICAgICAgY29udGV4dDogY3gyLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRSZXR1cm4sXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybixcbiAgICAgICAgcHJvcHNcbiAgICB9ID0gdXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJvdzxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4oe1xuICAgICAgICBhc0NoaWxkUm93UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvbnRleHQ6IGN4MVxuICAgICAgICB9LFxuICAgICAgICBhc1BhcmVudFJvd1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IC4uLmxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyAuLi50eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChzZWxlY3Rpb25MaW1pdCA9PSBcInNpbmdsZVwiKVxuICAgICAgICBjb25zb2xlLmFzc2VydChzZWxlY3RlZCA9PSBudWxsKTtcblxuICAgIHByb3BzLnJvbGUgPSBcIm9wdGlvblwiO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXNDaGlsZFJvd1JldHVybixcbiAgICAgICAgYXNQYXJlbnRSb3dSZXR1cm4sXG4gICAgICAgIGNvbnRleHQ6IGN4MixcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIHByb3BzXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlR3JpZGxpc3RDZWxsPEdyaWRsaXN0Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88R3JpZGxpc3RDZWxsRWxlbWVudD4+KHA6IFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnM8R3JpZGxpc3RDZWxsRWxlbWVudCwgQ00+KTogVXNlR3JpZGxpc3RDZWxsUmV0dXJuVHlwZTxHcmlkbGlzdENlbGxFbGVtZW50LCBDTT4ge1xuICAgIHJldHVybiB1c2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbDxHcmlkbGlzdENlbGxFbGVtZW50LCBDTT4ocCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZGxpc3RTZWN0aW9uUGFyYW1ldGVycyB7XG4gICAgZ3JpZGxpc3RTZWN0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICBjb21wYXJlUm93czogKGxoc0luZGV4OiBudW1iZXIsIHJoc0luZGV4OiBudW1iZXIpID0+IG51bWJlcjtcbiAgICB9XG4gICAgZ3JpZGxpc3RTZWN0aW9uQ29udGV4dDoge1xuXG4gICAgfVxufVxuLypcbmV4cG9ydCBjb25zdCB1c2VHcmlkbGlzdFNlY3Rpb24gPSA8Qm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgY29tcGFyZVJvd3MgfTogVXNlR3JpZGxpc3RTZWN0aW9uUGFyYW1ldGVycykgPT4ge1xuICAgIC8vZGVidWdMb2coXCJ1c2VHcmlkbGlzdFNlY3Rpb25cIik7XG4gICAgLy90eXBlIENSRnVsbCA9IFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxSb3dFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlR3JpZGxpc3RSb3dTdWJJbmZvPENlbGxFbGVtZW50LCBDUiwgQ0M+Pj47XG4gICAgY29uc3QgZ2V0SW5kZXggPSB1c2VDYWxsYmFjazxHZXRJbmRleDxhbnk+PigoaSkgPT4gaS5wcm9wcy5pbmRleCwgW10pO1xuXG5cbiAgICBjb25zdCB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5cbiAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxCb2R5U2VjdGlvbkVsZW1lbnQsIEdyaWRsaXN0Um93SW5mbzxSb3dFbGVtZW50Pj4oe1xuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBnZXRJbmRleCxcbiAgICAgICAgICAgIGdldEhpZ2hlc3RDaGlsZEluZGV4LFxuICAgICAgICAgICAgZ2V0VmFsaWRcbiAgICAgICAgfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGNvbXBhcmU6IChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsaHMubG9jYXRpb25JbmRleCA9PT0gcmhzLmxvY2F0aW9uSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wYXJlUm93cyhsaHMuaW5kZXgsIHJocy5pbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxocy5sb2NhdGlvbkluZGV4IC0gcmhzLmxvY2F0aW9uSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZUdyaWRsaXN0U2VjdGlvblByb3BzID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5U2VjdGlvbkVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHByb3BzLmNoaWxkcmVuICE9IG51bGwpO1xuICAgICAgICBvdmVyd3JpdGVXaXRoV2FybmluZyhcInVzZUdyaWRsaXN0U2VjdGlvblwiLCBwcm9wcywgXCJyb2xlXCIsIFwicm93Z3JvdXBcIik7XG4gICAgICAgIHJldHVybiB1c2VTb3J0YWJsZVByb3BzKHByb3BzIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4gJiB7IGNoaWxkcmVuOiBhbnkgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlR3JpZGxpc3RTZWN0aW9uUHJvcHMsXG4gICAgICAgIC4uLnNvcnRhYmxlUmV0XG4gICAgfVxufSovXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgYXNzZXJ0RW1wdHlPYmplY3QsIGZpbmRGaXJzdEZvY3VzYWJsZSwgdXNlTWVyZ2VkUHJvcHMsIHVzZU1vZGFsLCBVc2VNb2RhbFBhcmFtZXRlcnMsIFVzZU1vZGFsUmV0dXJuVHlwZSwgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIFByZWZpY2VzIH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuaW50ZXJmYWNlIE1TUCB7XG4gICAgLyoqXG4gICAgICogV2hhdCByb2xlIHRoZSBzdXJmYWNlIGZ1bGZpbGxzLlxuICAgICAqIFxuICAgICAqIEdlbmVyYWwgbWVudXMgc2hvdWxkIHVzZSBcIm1lbnVcIi4gXCJkaWFsb2dcIiBjYW4gYmUgdXNlZCBmb3IgZ2VuZXJpYyBwb3AtdXAgdGhpbmdzLlxuICAgICAqL1xuICAgIHJvbGU6IFwiZGlhbG9nXCIgfCBcIm1lbnVcIiB8IFwidHJlZVwiIHwgXCJncmlkXCIgfCBcImxpc3Rib3hcIjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhpcyBtZW51IHN1cmZhY2UgaXMgb3BlbmVkLCBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiBpdCBtdXN0IGJlIGZvY3VzZWQuXG4gICAgICogXG4gICAgICogVGhpcyBjb250cm9scyB3aGF0IGlzIGZvY3VzZWQgKGUuZy4gdGhlIGZpcnN0IG1lbnUgaXRlbSwgdGhlIHdob2xlIHN1cmZhY2UgaXRzZWxmLCBldGMuKVxuICAgICAqL1xuICAgIC8vc2VuZEZvY3VzVG9NZW51KCk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIE1lbnVTdXJmYWNlT21pdHMgPSBrZXlvZiBNU1A7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVN1cmZhY2VQYXJhbWV0ZXJzPF9TIGV4dGVuZHMgRWxlbWVudCwgX0IgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTW9kYWxQYXJhbWV0ZXJzPFwiZXNjYXBlXCIgfCBcImxvc3QtZm9jdXNcIiB8IFwiYmFja2Ryb3BcIj4sIFwiZm9jdXNUcmFwUGFyYW1ldGVyc1wiPiB7XG4gICAgZm9jdXNUcmFwUGFyYW1ldGVyczogT21pdDxVc2VNb2RhbFBhcmFtZXRlcnM8XCJlc2NhcGVcIiB8IFwibG9zdC1mb2N1c1wiIHwgXCJiYWNrZHJvcFwiPltcImZvY3VzVHJhcFBhcmFtZXRlcnNcIl0sIFwidHJhcEFjdGl2ZVwiIHwgXCJmb2N1c09wZW5lclwiIHwgXCJvbmx5TW92ZUZvY3VzXCI+XG4gICAgbWVudVN1cmZhY2VQYXJhbWV0ZXJzOiBNU1A7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51U3VyZmFjZVJldHVyblR5cGU8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVRhcmdldEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51VHJpZ2dlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcHJvcHNTdXJmYWNlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51U3VyZmFjZUVsZW1lbnQ+O1xuICAgIHByb3BzVGFyZ2V0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51VGFyZ2V0RWxlbWVudD47XG4gICAgcHJvcHNUcmlnZ2VyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51VHJpZ2dlckVsZW1lbnQ+O1xuICAgIHByb3BzU2VudGluZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT47XG4gICAgZm9jdXNUcmFwUmV0dXJuOiBVc2VNb2RhbFJldHVyblR5cGU8bnVsbCwgTWVudVRyaWdnZXJFbGVtZW50LCBNZW51U3VyZmFjZUVsZW1lbnQ+W1wiZm9jdXNUcmFwUmV0dXJuXCJdO1xuICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybjogVXNlTW9kYWxSZXR1cm5UeXBlPG51bGwsIE1lbnVUcmlnZ2VyRWxlbWVudCwgTWVudVN1cmZhY2VFbGVtZW50PltcInJlZkVsZW1lbnRQb3B1cFJldHVyblwiXTtcbiAgICByZWZFbGVtZW50U291cmNlUmV0dXJuOiBVc2VNb2RhbFJldHVyblR5cGU8bnVsbCwgTWVudVRyaWdnZXJFbGVtZW50LCBNZW51U3VyZmFjZUVsZW1lbnQ+W1wicmVmRWxlbWVudFNvdXJjZVJldHVyblwiXTtcbn1cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VNZW51QnV0dG9uUmV0dXJuVHlwZUluZm8gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88bmV2ZXI+IHsgfVxuLypcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVN1cmZhY2VSZXR1cm5UeXBlV2l0aEhvb2tzPE1lbnVTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZU1lbnVTdXJmYWNlUmV0dXJuVHlwZUluZm88TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudD4ge1xuICAgIHVzZU1lbnVTdXJmYWNlU2VudGluZWw6IDxFIGV4dGVuZHMgRWxlbWVudD4oKSA9PiB7IHVzZU1lbnVTZW50aW5lbFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+OyB9O1xuICAgIHVzZU1lbnVTdXJmYWNlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVN1cmZhY2VFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVN1cmZhY2VFbGVtZW50PjtcbiAgICB1c2VNZW51U3VyZmFjZUNoaWxkUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVBhcmVudEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD47ICAvLyBOT1QgYSBtZW51IGl0ZW0hIFRoaXMgaXMgdGhlIG1lbnUsIGRpYWxvZywgcG9wdXAsIHdoYXRldmVyIGFjdHVhbGx5IGdldHMgdGhlIHJvbGUsIGFzIG9wcG9zZWQgdG8gdGhlIHN1cmZhY2UgdGhhdCBsaXN0ZW5zIHRvIG1vdXNlIGFuZCBrZXlib2FyZCBldmVudHNcbiAgICB1c2VNZW51U3VyZmFjZUJ1dHRvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PjtcblxufSovXG5cbi8vZXhwb3J0IGludGVyZmFjZSBVc2VNZW51QnV0dG9uUmV0dXJuVHlwZVdpdGhIb29rcyBleHRlbmRzIFVzZU1lbnVCdXR0b25SZXR1cm5UeXBlSW5mbyB7IH1cblxuXG4vKipcbiAqIEEgbWVudSBzdXJmYWNlIGlzIHdoYXQgaGFuZGxlcyB1c2VyIGludGVyYWN0aW9uIHdpdGggYW4gaW50ZXJhY3RpdmUgYnV0IHRyYW5zaWVudCBzdXJmYWNlIChsaWtlIGEgbWVudSBvciBhIHBvcHVwKS5cbiAqIFxuICogVGhlIGtleWJvYXJkIChldGMuKSBpbnRlcmFjdGlvbnMgYXJlIHNoYXJlZCBhbW9uZyBhIGxvdCBvZiB3aWRnZXRzLCBhbmQgdGhlIG9wZW5pbmcgYnV0dG9uIGhhcyBzb21lIEFSSUEgcHJvcGVydGllcyB0aGF0IG5lZWQgc2V0dGluZy5cbiAqIFxuICogUmVsYXRlZCB0byBtZW51cywgd2hpY2ggYXJlIGEgbWVudSBjb250YWluZWQgd2l0aGluIGEgbWVudSBzdXJmYWNlLiBOb3QgcmVsYXRlZCB0byBtZW51YmFycyAtLSBtZW51cyBjb250YWluIG1lbnViYXJzLCBidXQgbm90IGFsbCBtZW51YmFycyBhcmUgY29udGFpbmVkIHdpdGhpbiBhIG1lbnUgb3IgaXRzIHN1cmZhY2UuXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbnVTdXJmYWNlPE1lbnVTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVUYXJnZXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVRyaWdnZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIC8vbWVudVN1cmZhY2U6IHsgc2VuZEZvY3VzVG9NZW51LCByb2xlIH0sIFxuICAgIGRpc21pc3NQYXJhbWV0ZXJzLFxuICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzLFxuICAgIGZvY3VzVHJhcFBhcmFtZXRlcnMsXG4gICAgbWVudVN1cmZhY2VQYXJhbWV0ZXJzOiB7IHJvbGUgfVxufTogVXNlTWVudVN1cmZhY2VQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVRyaWdnZXJFbGVtZW50Pik6IFVzZU1lbnVTdXJmYWNlUmV0dXJuVHlwZTxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVUYXJnZXRFbGVtZW50LCBNZW51VHJpZ2dlckVsZW1lbnQ+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZU1lbnVTdXJmYWNlXCIpO1xuXG4gICAgY29uc3QgeyBwcm9wc1JlZmVyZW5jZXI6IHByb3BzSWRUcmlnZ2VyLCBwcm9wc1NvdXJjZTogcHJvcHNJZFRhcmdldCB9ID0gdXNlUmFuZG9tSWQ8TWVudVRhcmdldEVsZW1lbnQsIE1lbnVUcmlnZ2VyRWxlbWVudD4oeyByYW5kb21JZFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5tZW51LCBvdGhlclJlZmVyZW5jZXJQcm9wOiBcImFyaWEtY29udHJvbHNcIiB9IH0pO1xuXG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQ6IGdldEJ1dHRvbkVsZW1lbnQsIHByb3BzU3RhYmxlOiBwcm9wc1JlZlRyaWdnZXIgfSwgLi4udm9pZDQgfSA9IHVzZVJlZkVsZW1lbnQ8TWVudVRyaWdnZXJFbGVtZW50Pih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7IG9uRWxlbWVudENoYW5nZTogdW5kZWZpbmVkIH0gfSk7XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudDogZ2V0TWVudUVsZW1lbnQsIHByb3BzU3RhYmxlOiBwcm9wc1JlZlN1cmZhY2UsIC4uLnZvaWQ1IH0sIC4uLnZvaWQ2IH0gPSB1c2VSZWZFbGVtZW50PE1lbnVTdXJmYWNlRWxlbWVudD4oeyByZWZFbGVtZW50UGFyYW1ldGVyczogeyBvbkVsZW1lbnRDaGFuZ2U6IHVuZGVmaW5lZCB9IH0pO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZm9jdXNUcmFwUmV0dXJuLFxuICAgICAgICAvLyBJbnRlbnRpbmFsbHkgaWdub3JlZCBmb3IgbWVudXMsIHNpbmNlIHRoZXkgZG9uJ3QgdHJhcCBmb2N1cyBsaWtlIG1vc3QgbW9kYWxzLlxuICAgICAgIC8vIHByb3BzRm9jdXNDb250YWluZXIsXG4gICAgICAgIHByb3BzUG9wdXAsXG4gICAgICAgIHByb3BzU291cmNlOiBwczIsXG4gICAgICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybixcbiAgICAgICAgcmVmRWxlbWVudFNvdXJjZVJldHVyblxuICAgIH0gPSB1c2VNb2RhbDxcImVzY2FwZVwiIHwgXCJsb3N0LWZvY3VzXCIgfCBcImJhY2tkcm9wXCIsIG51bGwsIE1lbnVUcmlnZ2VyRWxlbWVudCwgTWVudVN1cmZhY2VFbGVtZW50Pih7XG4gICAgICAgIGRpc21pc3NQYXJhbWV0ZXJzLFxuICAgICAgICBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycyxcbiAgICAgICAgZm9jdXNUcmFwUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgLi4uZm9jdXNUcmFwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIG9ubHlNb3ZlRm9jdXM6IHRydWUsXG4gICAgICAgICAgICB0cmFwQWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgZm9jdXNPcGVuZXI6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBidXR0b25FbGVtZW50ID0gZ2V0QnV0dG9uRWxlbWVudCgpIGFzIEhUTUxFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgICAgICAgICBidXR0b25FbGVtZW50Py5mb2N1cygpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYXNzZXJ0RW1wdHlPYmplY3Qodm9pZDQpO1xuICAgIGFzc2VydEVtcHR5T2JqZWN0KHZvaWQ1KTtcbiAgICBhc3NlcnRFbXB0eU9iamVjdCh2b2lkNik7XG5cbiAgICBjb25zdCBwcm9wc1N1cmZhY2U6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD4gPSB1c2VNZXJnZWRQcm9wcyhwcm9wc1JlZlN1cmZhY2UsIHByb3BzUG9wdXApO1xuXG4gICAgY29uc3QgcHJvcHNUYXJnZXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVUYXJnZXRFbGVtZW50PiA9IHVzZU1lcmdlZFByb3BzKHtcbiAgICAgICAgcm9sZVxuICAgIH0sIHByb3BzSWRUYXJnZXQpO1xuXG4gICAgY29uc3QgcHJvcHNUcmlnZ2VyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51VHJpZ2dlckVsZW1lbnQ+ID0gdXNlTWVyZ2VkUHJvcHMoe1xuICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogKGRpc21pc3NQYXJhbWV0ZXJzLm9wZW4pLnRvU3RyaW5nKCksXG4gICAgICAgIFwiYXJpYS1oYXNwb3B1cFwiOiByb2xlLFxuICAgIH0sIHByb3BzUmVmVHJpZ2dlciwgcHMyLCBwcm9wc0lkVHJpZ2dlcik7XG5cbiAgICBjb25zdCBwcm9wc1NlbnRpbmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+ID0gdXNlRm9jdXNTZW50aW5lbCh7XG4gICAgICAgIGZvY3VzU2VudGluZWw6IHtcbiAgICAgICAgICAgIHNlbmRGb2N1c1RvTWVudTogdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gZm9jdXNUcmFwUGFyYW1ldGVycy5mb2N1c1BvcHVwKGdldE1lbnVFbGVtZW50KCksICgpID0+IGZpbmRGaXJzdEZvY3VzYWJsZShnZXRNZW51RWxlbWVudCgpISkpIH0sIFtdKSxcbiAgICAgICAgICAgIG9uQ2xvc2U6IHVzZUNhbGxiYWNrKCgpID0+IHsgZGlzbWlzc1BhcmFtZXRlcnMub25DbG9zZShcImxvc3QtZm9jdXNcIikgfSwgW2Rpc21pc3NQYXJhbWV0ZXJzLm9uQ2xvc2VdKSxcbiAgICAgICAgICAgIG9wZW46IGRpc21pc3NQYXJhbWV0ZXJzLm9wZW5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9jdXNUcmFwUmV0dXJuLFxuICAgICAgICBwcm9wc1NlbnRpbmVsLFxuICAgICAgICBwcm9wc1N1cmZhY2UsXG4gICAgICAgIHByb3BzVGFyZ2V0LFxuICAgICAgICBwcm9wc1RyaWdnZXIsXG4gICAgICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybixcbiAgICAgICAgcmVmRWxlbWVudFNvdXJjZVJldHVyblxuICAgIH1cbn1cblxuaW50ZXJmYWNlIEZTUCBleHRlbmRzIE1TUCB7XG4gICAgb3BlbjogYm9vbGVhbjtcbiAgICBvbkNsb3NlKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIEZvY3VzU2VudGluZWxPbWl0cyA9IGtleW9mIEZTUDtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1NlbnRpbmVsUGFyYW1ldGVycyB7XG4gICAgZm9jdXNTZW50aW5lbDogeyBzZW5kRm9jdXNUb01lbnU6ICgpID0+IHZvaWQ7IG9wZW46IGJvb2xlYW47IG9uQ2xvc2UoKTogdm9pZDsgfTtcbn1cblxuXG4vLyBBIGZvY3VzIHNlbnRpbmFsIGlzIGEgaGlkZGVuIGJ1dCBmb2N1c2FibGUgZWxlbWVudCB0aGF0IGNvbWVzIGF0IHRoZSBzdGFydCBvciBlbmQgXG4vLyBvZiB0aGUgb3V0LW9mLXBsYWNlLWZvY3VzYWJsZSBjb21wb25lbnQgdGhhdCwgd2hlbiBhY3RpdmF0ZWQgb3IgZm9jdXNlZCBvdmVyLCBjbG9zZXMgdGhlIGNvbXBvbmVudFxuLy8gKGlmIGZvY3VzZWQgd2l0aGluIDEwMG1zIG9mIHRoZSBvcGVuIHByb3AgY2hhbmdpbmcsIGluc3RlYWQgb2Zcbi8vIGNsb3NpbmcsIGZvY3VzaW5nIHRoZSBzZW50aW5lbCBpbW1lZGlhdGVseSBhc2tzIGl0IHRvIGZvY3VzIGl0c2VsZikuXG4vLyBUaGlzIGV4aXN0cyBmb3IgdGhpbmdzIGxpa2UgbWVudXMgd2hpY2ggY2FuIGhhdmUgZm9jdXMgYnV0IGFsc28gbmVlZCBhIHdheSB0byByZXR1cm5cbi8vIHRvIHdoYXRldmVyIG91dC1vZi1wbGFjZSBwYXJlbnQgdGhleSBjYW1lIGZyb20gd2hlbiBuYXR1cmFsbHkgdGFiYmVkIG91dCBvZiAoYXMgb3Bwb3NlZFxuLy8gdG8gZGlhbG9ncyB3aGljaCBsb29wIGJhY2sgYXJvdW5kIHdoZW4gdGFiYmVkIG91dCBvZikuIFdoaWxlIG1vdXNlIHVzZXJzIGNhbiBjbGljayBvdXQgb2YgYSBtZW51XG4vLyBhbmQga2V5Ym9hcmQgdXNlcnMgY2FuIGVzY2FwZSB0byBjbG9zZSBhIG1lbnUsIHNjcmVlbiByZWFkZXJzIGFuZCBvdGhlciBpbnB1dCBtZXRob2RzIFxuLy8gdGhhdCBkb24ndCB1c2UgdGhvc2UgdHdvIHdvdWxkIGJlY29tZSBzdHVjay5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGb2N1c1NlbnRpbmVsPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGZvY3VzU2VudGluZWw6IHsgb3Blbiwgb25DbG9zZSwgc2VuZEZvY3VzVG9NZW51IH0gfTogVXNlRm9jdXNTZW50aW5lbFBhcmFtZXRlcnMpOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XG4gICAgZGVidWdMb2coXCJ1c2VGb2N1c1NlbnRpbmVsXCIpO1xuICAgIGNvbnN0IGdldFNlbmRGb2N1c1dpdGhpbk1lbnUgPSB1c2VTdGFibGVHZXR0ZXIoc2VuZEZvY3VzVG9NZW51KTtcbiAgICBjb25zdCBzdGFibGVPbkNsb3NlID0gdXNlU3RhYmxlQ2FsbGJhY2sob25DbG9zZSk7XG5cbiAgICBjb25zdCBbZmlyc3RTZW50aW5lbElzQWN0aXZlLCBzZXRGaXJzdFNlbnRpbmVsSXNBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHVzZVRpbWVvdXQoeyBjYWxsYmFjazogKCkgPT4geyBzZXRGaXJzdFNlbnRpbmVsSXNBY3RpdmUob3Blbik7IH0sIHRpbWVvdXQ6IDEwMCwgdHJpZ2dlckluZGV4OiBgJHtvcGVufS0ke2ZpcnN0U2VudGluZWxJc0FjdGl2ZX1gIH0pO1xuXG5cbiAgICBjb25zdCBvbkZvY3VzID0gZmlyc3RTZW50aW5lbElzQWN0aXZlID8gKCgpID0+IHN0YWJsZU9uQ2xvc2UoKSkgOiAoKCkgPT4gZ2V0U2VuZEZvY3VzV2l0aGluTWVudSgpPy4oKSk7XG4gICAgY29uc3Qgb25DbGljayA9ICgpID0+IHN0YWJsZU9uQ2xvc2UoKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiBmaXJzdFNlbnRpbmVsSXNBY3RpdmUgPyAwIDogLTEsXG4gICAgICAgIG9uRm9jdXMsXG4gICAgICAgIG9uQ2xpY2tcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb24sIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZSwgdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkLCBDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ29udGV4dCwgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZSwgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Tb3J0YWJsZUNoaWxkSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbGJhclBhcmFtZXRlcnM8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PiBleHRlbmRzIE9taXQ8VXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8Q29udGFpbmVyRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBNPiwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPiB7XG4gICAgdG9vbGJhclBhcmFtZXRlcnM6IHtcbiAgICAgICAgb3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiO1xuXG4gICAgICAgIC8vIFNob3VsZCBiZSBcInRvb2xiYXJcIiBmb3IgdG9vbGJhcnMsIG51bGwgaWYgc29tZW9uZSBlbHNlIHRha2VzIGNhcmUgb2YgdGhlIHJvbGUsIGFuZCB3aGF0ZXZlciBzdHJpbmcgaXMgYXBwbGljYWJsZSBvdGhlcndpc2VcbiAgICAgICAgcm9sZTogc3RyaW5nIHwgbnVsbDtcbiAgICB9O1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT5bXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXSwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCI+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbGJhclJldHVyblR5cGU8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PiBleHRlbmRzIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4ge1xuICAgIHRvb2xiYXJSZXR1cm46IHsgcHJvcHNVbnN0YWJsZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyRWxlbWVudD4gfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm88Q2hpbGRFbGVtZW50PiB7XG5cbn1cblxuZXhwb3J0IHR5cGUgVXNlVG9vbGJhckNvbnRleHQ8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PiA9IENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0PENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT47XG5cblxuLy9leHBvcnQgdHlwZSBVc2VUb29sYmFyQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAoaTogVXNlVG9vbGJhckNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIEM+KSA9PiBVc2VUb29sYmFyQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxFPj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEUsIE0sIG5ldmVyPiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbGJhckNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlVG9vbGJhclN1YkluZm88Q2hpbGRFbGVtZW50Pj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudCwgTT4geyB9XG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbGJhckNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlVG9vbGJhclN1YkluZm88Q2hpbGRFbGVtZW50Pj4gZXh0ZW5kcyBVc2VUb29sYmFyQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIE0+IHtcbi8vfVxuXG4vKipcbiAqIEEgdG9vbGJhciBpcyBqdXN0IGEgY29sbGVjdGlvbiBvZiB3aWRnZXRzIGluIGFuIGV4cGVjdGVkIG9yZGVyIGFuZCB3aXRoIHRoZSB1c3VhbCBrZXlib2FyZCBuYXZpZ2F0aW9uIHN0dWZmLlxuICogXG4gKiBUaGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYSB0b29sYmFyIGFuZCBhIG1lbnViYXIgaXMgdGhhdCBhIG1lbnViYXIgY29udGFpbnMgcHVyZWx5IHN0YXRpYyBtZW51aXRlbXMsIFxuICogYnV0IGEgdG9vbGJhciBpcyB0aGUgbW9yZSBnZW5lcmFsIGNhc2UsIGJlaW5nIGFibGUgdG8gY29udGFpbiBhbnl0aGluZyBhdCBhbGwuIFxuICogQSBtZW51YmFyIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIG9mIGEgdG9vbGJhciwgYW5kIGEgbWVudSBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWxpemVkIG1lbnViYXJcbiAqIFxuICogRWl0aGVyIHdheSwgYmUgc3VyZSB0byBzcGVjaWZ5IHRoZSByb2xlIGFuZCBvcmllbnRhdGlvbiB0aGlzIHRvb2xiYXIgaGFzIChyb2xlPXRvb2xiYXIgaWYgeW91J3JlIHVzaW5nIHRoaXMgYXMgYW4gYWN0dWFsIHRvb2xiYXIpLlxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VUb29sYmFyPENvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgdG9vbGJhclBhcmFtZXRlcnM6IHsgb3JpZW50YXRpb24sIHJvbGUgfSxcbiAgICAuLi5saXN0TmF2UGFyYW1ldGVyc1xufTogVXNlVG9vbGJhclBhcmFtZXRlcnM8Q29udGFpbmVyRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+Pik6IFVzZVRvb2xiYXJSZXR1cm5UeXBlPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgVXNlVG9vbGJhclN1YkluZm88Q2hpbGRFbGVtZW50Pj4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIFxuICAgICAgICAuLi5saXN0TmF2UmV0dXJuXG4gICAgfSA9IHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb248Q29udGFpbmVyRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+Pih7XG4gICAgICAgIC4uLmxpc3ROYXZQYXJhbWV0ZXJzLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogeyAuLi5saW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgbmF2aWdhdGlvbkRpcmVjdGlvbjogb3JpZW50YXRpb24gfSxcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvb2xiYXJSZXR1cm46IHsgcHJvcHNVbnN0YWJsZTogeyByb2xlOiByb2xlID8/IHVuZGVmaW5lZCB9IH0sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHByb3BzLFxuICAgICAgICAuLi5saXN0TmF2UmV0dXJuXG4gICAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUb29sYmFyQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIC4uLmxpc3ROYXZDaGlsZFBhcmFtZXRlcnNcbn06IFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+Pik6IFVzZVRvb2xiYXJDaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50LCBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PiB7XG4gICAgcmV0dXJuIHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIFVzZVRvb2xiYXJTdWJJbmZvPENoaWxkRWxlbWVudD4sIG5ldmVyPih7XG4gICAgICAgIC4uLmxpc3ROYXZDaGlsZFBhcmFtZXRlcnNcbiAgICB9KTtcbn0iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZywgRW5oYW5jZWRFdmVudCwgZW5oYW5jZUV2ZW50IH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZVRvb2xiYXIsIHVzZVRvb2xiYXJDaGlsZCwgVXNlVG9vbGJhckNoaWxkUGFyYW1ldGVycywgVXNlVG9vbGJhckNoaWxkUmV0dXJuVHlwZSwgVXNlVG9vbGJhclBhcmFtZXRlcnMsIFVzZVRvb2xiYXJSZXR1cm5UeXBlLCBVc2VUb29sYmFyU3ViSW5mbyB9IGZyb20gXCIuL3VzZS10b29sYmFyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudWJhclN1YkluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+IHtcblxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudWJhclBhcmFtZXRlcnM8TWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBPbWl0PFVzZVRvb2xiYXJQYXJhbWV0ZXJzPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+LCBcInRvb2xiYXJQYXJhbWV0ZXJzXCI+IHtcbiAgICB0b29sYmFyUGFyYW1ldGVyczogT21pdDxVc2VUb29sYmFyUGFyYW1ldGVyczxNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPltcInRvb2xiYXJQYXJhbWV0ZXJzXCJdLCBcInJvbGVcIj47XG4gICAgbWVudWJhclBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYWxseSBcIm1lbnVcIi4gQ2FuIGJlIG51bGwgaWYgdGhlIHJvbGUgaXMgcHJvdmlkZWQgZWxzZXdoZXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgcm9sZTogc3RyaW5nIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudWJhckl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiBleHRlbmRzIE9taXQ8VXNlVG9vbGJhckNoaWxkUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQsIE0+LCBcInByZXNzUGFyYW1ldGVyc1wiPiB7XG4gICAgLy9oYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudD47XG4gICAgcHJlc3NQYXJhbWV0ZXJzOiBPbWl0PFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50LCBNPltcInByZXNzUGFyYW1ldGVyc1wiXSwgXCJvblByZXNzU3luY1wiIHwgXCJmb2N1c1NlbGZcIj47XG4gICAgbWVudUl0ZW1QYXJhbWV0ZXJzOiB7XG4gICAgICAgIHJvbGU6IFwibWVudWl0ZW1cIiB8IFwibWVudWl0ZW1jaGVja2JveFwiIHwgXCJtZW51aXRlbXJhZGlvXCI7XG4gICAgICAgIC8vZGlzYWJsZWQ6IERpc2FibGVkVHlwZTtcbiAgICAgICAgb25QcmVzczogbnVsbCB8ICgoZTogRW5oYW5jZWRFdmVudDxNZW51SXRlbUVsZW1lbnQsIGguSlNYLlRhcmdldGVkRXZlbnQ8TWVudUl0ZW1FbGVtZW50PiwgeyBpbmRleDogbnVtYmVyIH0+KSA9PiB2b2lkKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudWJhclJldHVyblR5cGU8TWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBVc2VUb29sYmFyUmV0dXJuVHlwZTxNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudWJhckl0ZW1SZXR1cm5UeXBlPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiBleHRlbmRzIFVzZVRvb2xiYXJDaGlsZFJldHVyblR5cGU8TWVudUl0ZW1FbGVtZW50LCBNPiB7IH1cblxuXG5cblxuLy9leHBvcnQgdHlwZSBVc2VNZW51SXRlbVByb3BzPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51SXRlbUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51SXRlbUVsZW1lbnQ+O1xuLy9leHBvcnQgdHlwZSBVc2VNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gPSAoYXJnczogVXNlTWVudUl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCwgTT4pID0+IFVzZU1lbnVJdGVtUmV0dXJuVHlwZTxNZW51SXRlbUVsZW1lbnQsIE0+O1xuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbnViYXI8TWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICB0b29sYmFyUGFyYW1ldGVycyxcbiAgICBtZW51YmFyUGFyYW1ldGVyczogeyByb2xlIH1cbn06IFVzZU1lbnViYXJQYXJhbWV0ZXJzPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+KTogVXNlTWVudWJhclJldHVyblR5cGU8TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4ge1xuXG4gICAgZGVidWdMb2coXCJ1c2VNZW51YmFyXCIpO1xuXG4gICAgY29uc3Qge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c1JldHVybixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICB0b29sYmFyUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICAuLi5fcmVzdFxuICAgIH0gPSB1c2VUb29sYmFyPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQ+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICB0b29sYmFyUGFyYW1ldGVyczogeyByb2xlLCAuLi50b29sYmFyUGFyYW1ldGVycyB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c1JldHVybixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICB0b29sYmFyUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuXG4gICAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW51YmFyQ2hpbGQ8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIHByZXNzUGFyYW1ldGVyczogeyAuLi5wcmVzc1BhcmFtZXRlcnMgfSxcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIGNvbnRleHQsXG4gICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgIG1lbnVJdGVtUGFyYW1ldGVyczogeyBvblByZXNzLCByb2xlIH1cbn06IFVzZU1lbnViYXJJdGVtUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+KTogVXNlTWVudWJhckl0ZW1SZXR1cm5UeXBlPE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4ge1xuICAgIGRlYnVnTG9nKFwidXNlTWVudUl0ZW1cIiwgbWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleCk7XG4gICAgY29uc3QgZGlzYWJsZWQgPSBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMuZGlzYWJsZWQ7XG5cbiAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoZTogYW55KSA9PiAoZSBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50KS5mb2N1cz8uKCksIFtdKVxuXG4gICAgY29uc3Qge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIHByZXNzUmV0dXJuLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVyblxuICAgIH0gPSB1c2VUb29sYmFyQ2hpbGQ8TWVudUl0ZW1FbGVtZW50Pih7XG4gICAgICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGZvY3VzU2VsZixcbiAgICAgICAgICAgIG9uUHJlc3NTeW5jOiAoZSkgPT4gKGRpc2FibGVkID8gbnVsbCA6IG9uUHJlc3MpPy4oZW5oYW5jZUV2ZW50KGUsIHsgaW5kZXg6IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMuaW5kZXggfSkpLFxuICAgICAgICAgICAgLi4ucHJlc3NQYXJhbWV0ZXJzXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgLypsaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgcHJlc3NQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkNsaWNrU3luYzogKGUpID0+IChkaXNhYmxlZCA/IG51bGwgOiBvblByZXNzKT8uKGVuaGFuY2VFdmVudChlLCB7IGluZGV4OiBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLmluZGV4IH0pKSxcbiAgICAgICAgICAgIGV4Y2x1ZGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZvY3VzU2VsZjogcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMuZm9jdXNTZWxmXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgIHN1YkluZm86IHsgc3ViSW5mbyB9Ki9cbiAgICB9KTtcblxuICAgIC8qZnVuY3Rpb24gdXNlTWVudUl0ZW1Qcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUl0ZW1FbGVtZW50Pikge1xuICAgICAgICBvdmVyd3JpdGVXaXRoV2FybmluZyhcInVzZU1lbnVJdGVtXCIsIHByb3BzLCBcInJvbGVcIiwgcm9sZSk7XG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcyhwcmVzc1JldHVybi5wcm9wc1N0YWJsZSwgcHJlc3NSZXR1cm4ucHJvcHNVbnN0YWJsZSwgcHJvcHMpO1xuICAgIH0qL1xuXG4gICAgcHJvcHMucm9sZSA9IHJvbGU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIHByZXNzUmV0dXJuLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVyblxuICAgIH07XG59XG4iLCJpbXBvcnQgeyB1c2VNZXJnZWRQcm9wcywgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgVXNlVG9vbGJhckNvbnRleHQgfSBmcm9tIFwiLi91c2UtdG9vbGJhclwiO1xuaW1wb3J0IHsgZGVidWdMb2cgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlTWVudVN1cmZhY2UsIFVzZU1lbnVTdXJmYWNlUGFyYW1ldGVycywgVXNlTWVudVN1cmZhY2VSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLW1lbnUtc3VyZmFjZVwiO1xuaW1wb3J0IHsgdXNlTWVudWJhciwgdXNlTWVudWJhckNoaWxkLCBVc2VNZW51YmFySXRlbVBhcmFtZXRlcnMsIFVzZU1lbnViYXJJdGVtUmV0dXJuVHlwZSwgVXNlTWVudWJhclBhcmFtZXRlcnMsIFVzZU1lbnViYXJSZXR1cm5UeXBlLCBVc2VNZW51YmFyU3ViSW5mbyB9IGZyb20gXCIuL3VzZS1tZW51YmFyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUNvbnRleHQ8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VNZW51YmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PiBleHRlbmRzIFVzZVRvb2xiYXJDb250ZXh0PENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBPbWl0PFVzZU1lbnViYXJQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPiwgXCJ0b29sYmFyUGFyYW1ldGVyc1wiIHwgXCJtZW51YmFyUGFyYW1ldGVyc1wiPiB7XG4gICAgZGlzbWlzc1BhcmFtZXRlcnM6IFVzZU1lbnVTdXJmYWNlUGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50PltcImRpc21pc3NQYXJhbWV0ZXJzXCJdO1xuICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzOiBVc2VNZW51U3VyZmFjZVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudD5bXCJlc2NhcGVEaXNtaXNzUGFyYW1ldGVyc1wiXTtcbiAgICBtZW51U3VyZmFjZVBhcmFtZXRlcnM6IE9taXQ8VXNlTWVudVN1cmZhY2VQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+W1wibWVudVN1cmZhY2VQYXJhbWV0ZXJzXCJdLCBcInJvbGVcIj47XG4gICAgdG9vbGJhclBhcmFtZXRlcnM6IE9taXQ8VXNlTWVudWJhclBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+W1widG9vbGJhclBhcmFtZXRlcnNcIl0sIFwicm9sZVwiPlxuICAgIG1lbnViYXJQYXJhbWV0ZXJzOiBPbWl0PFVzZU1lbnViYXJQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPltcIm1lbnViYXJQYXJhbWV0ZXJzXCJdLCBcInJvbGVcIj5cblxuICAgIG1lbnVQYXJhbWV0ZXJzOiB7XG4gICAgICAgIC8qKiBUaGlzIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgY29ycmVzcG9uZGluZyBhcnJvdyBrZXkgaXMgcHJlc3NlZCBvbiB0aGUgdHJpZ2dlcmluZyBidXR0b24uICovXG4gICAgICAgIG9uT3BlbigpOiB2b2lkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSAqKnBoeXNpY2FsKiogZGlyZWN0aW9uIHRoYXQgaXMgcHJlc3NlZFxuICAgICAgICAgKiB1c2luZyB0aGUgKiphcnJvdyBrZXlzKiogb24geW91ciBrZXlib2FyZC5cbiAgICAgICAgICogXG4gICAgICAgICAqIEl0IGhhcyBubyBlZmZlY3Qgb24gZGlzcGxheSwgbGlzdCBuYXZpZ2F0aW9uIGRpcmVjdGlvbiwgZXRjLlxuICAgICAgICAgKiBJdCBzb2xlbHkgY29udHJvbHMgdGhlIGFycm93IGtleSB0aGF0J3MgbGlzdGVuZWQgZm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgb3BlbkRpcmVjdGlvbjogXCJkb3duXCIgfCBcInVwXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiB8IG51bGw7XG4gICAgfVxuICAgIC8vbWVudUJ1dHRvbkhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8TWVudUJ1dHRvbkVsZW1lbnQ+O1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51SXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+IGV4dGVuZHMgVXNlTWVudWJhckl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCwgTT4ge1xuICAgIC8vaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQ+O1xuICAgIC8vbWVudUl0ZW06IHsgZGlzYWJsZWQ6IERpc2FibGVkVHlwZTsgb25QcmVzczogKGU6IEVuaGFuY2VkRXZlbnQ8TWVudUl0ZW1FbGVtZW50LCBoLkpTWC5UYXJnZXRlZEV2ZW50PE1lbnVJdGVtRWxlbWVudD4sIHsgaW5kZXg6IG51bWJlciB9PikgPT4gdm9pZDsgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVSZXR1cm5UeXBlPE1lbnVTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBVc2VNZW51U3VyZmFjZVJldHVyblR5cGU8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+LCBPbWl0PFVzZU1lbnViYXJSZXR1cm5UeXBlPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+LCBcInByb3BzXCI+IHtcblxufVxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUJ1dHRvblJldHVyblR5cGVJbmZvIGV4dGVuZHMgeyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtUmV0dXJuVHlwZTxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBVc2VNZW51YmFySXRlbVJldHVyblR5cGU8TWVudUl0ZW1FbGVtZW50LCBNPiB7IH1cblxuLypcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVJldHVyblR5cGVXaXRoSG9va3M8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlTWVudVJldHVyblR5cGVJbmZvPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIEMsIEs+IHtcbiAgICB1c2VNZW51U2VudGluZWw6IDxFIGV4dGVuZHMgRWxlbWVudD4oKSA9PiB7IHVzZU1lbnVTZW50aW5lbFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+OyB9O1xuICAgIHVzZU1lbnVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVQYXJlbnRFbGVtZW50PjtcbiAgICB1c2VNZW51U3VyZmFjZVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD47XG4gICAgdXNlTWVudUJ1dHRvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUJ1dHRvbkVsZW1lbnQ+O1xuICAgIHVzZU1lbnVJdGVtOiBVc2VNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQsIEMsIEs+O1xufSovXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbnU8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBkaXNtaXNzUGFyYW1ldGVycyxcbiAgICBlc2NhcGVEaXNtaXNzUGFyYW1ldGVycyxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICBtZW51UGFyYW1ldGVyczogeyBvcGVuRGlyZWN0aW9uLCBvbk9wZW4gfSxcbiAgICBtZW51U3VyZmFjZVBhcmFtZXRlcnMsXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyxcbiAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICB0b29sYmFyUGFyYW1ldGVycyxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1xufTogVXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+Pik6IFVzZU1lbnVSZXR1cm5UeXBlPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+IHtcblxuICAgIGRlYnVnTG9nKFwidXNlTWVudVwiKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgcHJvcHM6IHByb3BzTWVudWJhcixcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICB0b29sYmFyUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuXG4gICAgfSA9IHVzZU1lbnViYXI8TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIHRvb2xiYXJQYXJhbWV0ZXJzOiB7IC4uLnRvb2xiYXJQYXJhbWV0ZXJzIH0sXG4gICAgICAgIG1lbnViYXJQYXJhbWV0ZXJzOiB7IHJvbGU6IFwibWVudVwiIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG9uS2V5RG93biA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGlzT3BlbiA9IGRpc21pc3NQYXJhbWV0ZXJzLm9wZW47XG4gICAgICAgIGlmICghaXNPcGVuKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjoge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbkRpcmVjdGlvbiA9PSAndXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbk9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuRGlyZWN0aW9uID09ICdkb3duJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25PcGVuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjoge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlbkRpcmVjdGlvbiA9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uT3BlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuRGlyZWN0aW9uID09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uT3BlbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBjb25zdCB7XG4gICAgICAgIGZvY3VzVHJhcFJldHVybixcbiAgICAgICAgcHJvcHNTZW50aW5lbCxcbiAgICAgICAgcHJvcHNTdXJmYWNlLFxuICAgICAgICBwcm9wc1RhcmdldCxcbiAgICAgICAgcHJvcHNUcmlnZ2VyLFxuICAgICAgICByZWZFbGVtZW50UG9wdXBSZXR1cm4sXG4gICAgICAgIHJlZkVsZW1lbnRTb3VyY2VSZXR1cm5cbiAgICB9ID0gdXNlTWVudVN1cmZhY2U8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+KHtcbiAgICAgICAgbWVudVN1cmZhY2VQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAuLi5tZW51U3VyZmFjZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICByb2xlOiBcIm1lbnVcIixcbiAgICAgICAgfSxcbiAgICAgICAgZGlzbWlzc1BhcmFtZXRlcnMsXG4gICAgICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzLFxuICAgICAgICBmb2N1c1RyYXBQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBmb2N1c1BvcHVwOiAoKSA9PiB7IGRlYnVnZ2VyOyByb3ZpbmdUYWJJbmRleFJldHVybi5mb2N1c1NlbGYoKSB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGZvY3VzVHJhcFJldHVybixcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICBwcm9wc1NlbnRpbmVsLFxuICAgICAgICBwcm9wc1N1cmZhY2UsXG4gICAgICAgIHByb3BzVGFyZ2V0OiB1c2VNZXJnZWRQcm9wcyhwcm9wc1RhcmdldCwgcHJvcHNNZW51YmFyKSxcbiAgICAgICAgcHJvcHNUcmlnZ2VyOiB1c2VNZXJnZWRQcm9wcyh7IG9uS2V5RG93biB9LCBwcm9wc1RyaWdnZXIpLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJlZkVsZW1lbnRQb3B1cFJldHVybixcbiAgICAgICAgcmVmRWxlbWVudFNvdXJjZVJldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgdG9vbGJhclJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblxuXG4gICAgICAgIC8qZm9jdXNNZW51LFxuXG4gICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQsXG5cbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLCovXG5cblxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51SXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+IGV4dGVuZHMgVXNlTWVudWJhckl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCwgTT4ge1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PihwOiBVc2VNZW51SXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+Pikge1xuICAgIHJldHVybiB1c2VNZW51YmFyQ2hpbGQ8TWVudUl0ZW1FbGVtZW50PihwKTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ29udGV4dCwgdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbiwgdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlLCBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGUsIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm8sIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTaW5nbGVTZWxlY3Rpb25EZWNsYXJhdGl2ZSwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZywgRW5oYW5jZWRFdmVudCwgUHJlZmljZXMgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgRm9jdXNhYmxlTGFiZWxFbGVtZW50LCBMYWJlbFBvc2l0aW9uLCB1c2VDaGVja2JveExpa2UsIFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnMsIFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGUsIHVzZUxhYmVsU3ludGhldGljLCBVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcblxuLy90eXBlIE9taXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gUGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+PjtcbmV4cG9ydCB0eXBlIFJhZGlvQ2hhbmdlRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBWIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nPiA9IEVuaGFuY2VkRXZlbnQ8RSwgRXZlbnQsIHsgc2VsZWN0ZWRWYWx1ZTogViB8IHVuZGVmaW5lZCB9PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHcm91cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfR3JvdXBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxHcm91cEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50LCBSYWRpb1N1YkluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQsIFY+PiwgXCJwcm9wc1wiIHwgXCJzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzXCI+IHtcbiAgICByYWRpb0dyb3VwUGFyYW1ldGVyczoge1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG5cbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogViB8IG51bGw7XG4gICAgICAgIHNldFNlbGVjdGVkVmFsdWUodmFsdWU6IFYgfCBudWxsIC8qZXZlbnQ6IFJhZGlvQ2hhbmdlRXZlbnQ8VGFiYmFibGVDaGlsZEVsZW1lbnQsIFY+Ki8pOiB2b2lkO1xuICAgICAgICAvL3RhZ0dyb3VwOiBFbGVtZW50VG9UYWc8R3JvdXBFbGVtZW50PjtcbiAgICAgICAgLy90YWdHcm91cExhYmVsOiBFbGVtZW50VG9UYWc8R3JvdXBMYWJlbEVsZW1lbnQ+O1xuICAgIH1cbiAgICBsYWJlbFBhcmFtZXRlcnM6IE9taXQ8VXNlTGFiZWxTeW50aGV0aWNQYXJhbWV0ZXJzW1wibGFiZWxQYXJhbWV0ZXJzXCJdLCBcIm9uTGFiZWxDbGlja1wiPjtcbiAgICAvL3NpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IFBpY2s8VXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8R3JvdXBFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgUmFkaW9TdWJJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50LCBWPj5bXCJzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzXCJdLCBcIm9uU2VsZWN0ZWRJbmRleENoYW5nZVwiPjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFkaW9QYXJhbWV0ZXJzPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFJhZGlvU3ViSW5mbzxGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgVj4+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBNLCBcImdldFZhbHVlMlwiPiwgXCJzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnNcIj4ge1xuICAgIHJhZGlvUGFyYW1ldGVyczoge1xuICAgICAgICB2YWx1ZTogVjtcbiAgICB9XG4gICAgY29udGV4dDogUmFkaW9Db250ZXh0PFYsIGFueSwgRm9jdXNhYmxlTGFiZWxFbGVtZW50PExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIE0+O1xuICAgIGNoZWNrYm94TGlrZVBhcmFtZXRlcnM6IE9taXQ8VXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+W1wiY2hlY2tib3hMaWtlUGFyYW1ldGVyc1wiXSwgXCJjaGVja2VkXCIgfCBcIm9uSW5wdXRcIiB8IFwicm9sZVwiPjtcbiAgICBsYWJlbFBhcmFtZXRlcnM6IE9taXQ8VXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+W1wibGFiZWxQYXJhbWV0ZXJzXCJdLCBcIm9uTGFiZWxDbGlja1wiPjtcbiAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IE9taXQ8VXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgTSwgbmV2ZXI+W1wic2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzXCJdLCBcImFyaWFQcm9wTmFtZVwiPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvQ29udGV4dDxWIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFJhZGlvU3ViSW5mbzxDaGlsZEVsZW1lbnQsIFY+PiBleHRlbmRzIENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0PFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4ge1xuICAgIHJhZGlvQ29udGV4dDoge1xuICAgICAgICAvLyBvblNlbGVjdGVkSW5kZXhDaGFuZ2U6IChlOiBFdmVudCwgbmV3SW5kZXg6IG51bWJlcikgPT4gdm9pZDtcbiAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgICBieU5hbWU6IE1hcDxWLCBudW1iZXI+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZTxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHcm91cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPEdyb3VwRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQsIFJhZGlvU3ViSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudCwgVj4+LCBcInByb3BzXCI+IHtcbiAgICByYWRpb0dyb3VwUmV0dXJuOiB7XG4gICAgICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7XG4gICAgICAgIC8vc2VsZWN0ZWRWYWx1ZTogViB8IG51bGw7XG4gICAgICAgIC8vc2V0U2VsZWN0ZWRWYWx1ZSh2YWx1ZTogViB8IG51bGwpOiB2b2lkO1xuICAgICAgICAvL3NldFNlbGVjdGVkSW5kZXgoaW5kZXg6IG51bWJlciB8IG51bGwpOiB2b2lkO1xuICAgIH1cbiAgICBwcm9wc1JhZGlvR3JvdXA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyb3VwRWxlbWVudD47XG4gICAgcHJvcHNSYWRpb0dyb3VwTGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdyb3VwTGFiZWxFbGVtZW50PjtcblxuICAgIC8vIG92ZXJyaWRlXG4gICAgY29udGV4dDogUmFkaW9Db250ZXh0PFYsIEdyb3VwRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQsIFJhZGlvU3ViSW5mbzxUYWJiYWJsZUNoaWxkRWxlbWVudCwgVj4+O1xufVxuLypcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFkaW9Hcm91cFJldHVyblR5cGVXaXRoSG9va3M8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgRyBleHRlbmRzIEVsZW1lbnQsIEdMIGV4dGVuZHMgRWxlbWVudCwgSSBleHRlbmRzIEVsZW1lbnQsIElMIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlUmFkaW9Hcm91cFJldHVyblR5cGVJbmZvPFYsIEksIEMsIEs+IHtcbiAgICB1c2VSYWRpb0dyb3VwTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxHTD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdMPjtcbiAgICB1c2VSYWRpb0dyb3VwUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rz4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEc+O1xuICAgIHVzZVJhZGlvOiBVc2VSYWRpbzxWLCBJLCBJTCwgQywgSz47XG59Ki9cblxuZXhwb3J0IGludGVyZmFjZSBSYWRpb1N1YkluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQ+IHtcbiAgICBnZXRWYWx1ZTIoKTogVjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJhZGlvR3JvdXA8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgRyBleHRlbmRzIEVsZW1lbnQsIEdMIGV4dGVuZHMgRWxlbWVudCwgVENFIGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIGxhYmVsUGFyYW1ldGVycyxcbiAgICByYWRpb0dyb3VwUGFyYW1ldGVyczogeyBuYW1lLCBzZXRTZWxlY3RlZFZhbHVlOiBzZXRTZWxlY3RlZFZhbHVlRXh0ZXJuYWwsIHNlbGVjdGVkVmFsdWUgfSxcbn06IFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEcsIEdMLCBUQ0U+KTogVXNlUmFkaW9Hcm91cFJldHVyblR5cGU8ViwgRywgR0wsIFRDRT4ge1xuXG4gICAgLy9kZWJ1Z0xvZyhcInVzZVJhZGlvR3JvdXBcIiwgc2VsZWN0ZWRWYWx1ZSk7XG4gICAgLy9jb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudDogX2dldEdyb3VwRWxlbWVudCwgcHJvcHNTdGFibGUgfSB9ID0gdXNlUmVmRWxlbWVudDxHPih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcblxuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IGJ5TmFtZSA9IHVzZVJlZihuZXcgTWFwPFYsIG51bWJlcj4oKSk7XG4gICAgLypjb25zdCBzZXRTZWxlY3RlZFZhbHVlID0gdXNlQ2FsbGJhY2soKHZhbHVlOiBWIHwgbnVsbCkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRJbmRleChudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdJbmRleCA9IGJ5TmFtZS5jdXJyZW50LmdldCh2YWx1ZSk7XG4gICAgICAgIHNldFNlbGVjdGVkSW5kZXgobmV3SW5kZXggPz8gbnVsbCk7XG4gICAgfSwgW10pKi9cblxuICAgIGNvbnN0IHsgcHJvcHNJbnB1dDogcHJvcHNHcm91cDEsIHByb3BzTGFiZWwgfSA9IHVzZUxhYmVsU3ludGhldGljPEcsIEdMPih7XG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25MYWJlbENsaWNrOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4uZm9jdXNTZWxmKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC4uLmxhYmVsUGFyYW1ldGVyc1xuICAgICAgICB9LFxuICAgICAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLnJhZGlvR3JvdXBMYWJlbCwgfSxcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5yYWRpb0dyb3VwIH1cbiAgICB9KVxuXG5cbiAgICAvKmNvbnN0IG9uU2VsZWN0ZWRJbmRleENoYW5nZSA9IHVzZVN0YWJsZUNhbGxiYWNrKChuZXdJbmRleDogbnVtYmVyIHwgbnVsbCkgPT4ge1xuICAgICAgICBpZiAobmV3SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4uZ2V0Q2hpbGRyZW4oKS5nZXRBdChuZXdJbmRleCk7XG4gICAgICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBvblNlbGVjdGVkVmFsdWVDaGFuZ2UoY2hpbGQuZ2V0VmFsdWUyKCkgPz8gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25TZWxlY3RlZFZhbHVlQ2hhbmdlKG51bGwpO1xuICAgICAgICAvL29uU2VsZWN0ZWRWYWx1ZUNoYW5nZShlbmhhbmNlRXZlbnQ8VENFLCBFdmVudCwgeyBzZWxlY3RlZFZhbHVlOiBWIHwgdW5kZWZpbmVkIH0+KGUsIHsgc2VsZWN0ZWRWYWx1ZTogbWFuYWdlZENoaWxkcmVuUmV0dXJuLmdldENoaWxkcmVuKCkuZ2V0QXQobmV3SW5kZXgpPy5nZXRWYWx1ZSgpIH0pKTtcbiAgICB9KTsqL1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybi5zZXRTZWxlY3RlZEluZGV4KGJ5TmFtZS5jdXJyZW50LmdldChzZWxlY3RlZFZhbHVlKSA/PyBudWxsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4uc2V0U2VsZWN0ZWRJbmRleChudWxsKTtcbiAgICB9LCBbc2VsZWN0ZWRWYWx1ZV0pXG5cbiAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBwcm9wczogcHJvcHNHcm91cDIsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuXG4gICAgfSA9IHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb248RywgVENFLCBSYWRpb1N1YkluZm88VENFLCBWPj4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzOiB7IGluaXRpYWxseVNlbGVjdGVkSW5kZXg6IHNlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXggfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXG4gICAgfSk7XG5cbiAgICBjb25zdCBfdjogdm9pZCA9IHVzZVNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlKHtcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuOiB7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4OiB1c2VTdGFibGVDYWxsYmFjaygocykgPT4ge1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiID8gcyhzZWxlY3RlZEluZGV4KSA6IHM7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4uZ2V0Q2hpbGRyZW4oKS5nZXRBdChuZXh0KT8uZ2V0VmFsdWUyKCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkVmFsdWVFeHRlcm5hbChuZXh0VmFsdWUgYXMgVik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZFZhbHVlRXh0ZXJuYWwobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgc2luZ2xlU2VsZWN0aW9uRGVjbGFyYXRpdmVQYXJhbWV0ZXJzOiB7IHNlbGVjdGVkSW5kZXggfVxuICAgIH0pXG5cblxuICAgIGNvbnN0IHByb3BzUmFkaW9Hcm91cCA9IHVzZU1lcmdlZFByb3BzKHByb3BzR3JvdXAxLCBwcm9wc0dyb3VwMiwgeyByb2xlOiBcInJhZGlvZ3JvdXBcIiB9KTtcblxuICAgIC8qdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNlbGVjdGVkVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWRJbmRleChudWxsKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRJbmRleCA9IGJ5TmFtZS5jdXJyZW50LmdldChzZWxlY3RlZFZhbHVlKTtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXgoc2VsZWN0ZWRJbmRleCA/PyBudWxsKTtcbiAgICAgICAgfVxuICAgIH0sIFtieU5hbWUsIHNlbGVjdGVkVmFsdWVdKTsqL1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHNSYWRpb0dyb3VwLFxuICAgICAgICBwcm9wc1JhZGlvR3JvdXBMYWJlbDogcHJvcHNMYWJlbCxcblxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c1JldHVybixcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICAgIHJhZGlvQ29udGV4dDogeyBuYW1lLCBieU5hbWU6IGJ5TmFtZS5jdXJyZW50IH1cbiAgICAgICAgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICByYWRpb0dyb3VwUmV0dXJuOiB7IHNlbGVjdGVkSW5kZXggfSxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuXG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhZGlvUmV0dXJuVHlwZTxMUCBleHRlbmRzIExhYmVsUG9zaXRpb24sIFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEkgZXh0ZW5kcyBFbGVtZW50LCBJTCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBSYWRpb1N1YkluZm88Rm9jdXNhYmxlTGFiZWxFbGVtZW50PExQLCBJLCBJTD4sIFY+PiBleHRlbmRzIE9taXQ8VXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIEksIElMPiwgTT4sIFwicHJvcHNcIj4sIFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGU8SSwgSUw+IHtcbiAgICBwcm9wc0lucHV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJPjtcbiAgICBwcm9wc0xhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJTD47XG59XG5cbi8qZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb1JldHVyblR5cGVXaXRoSG9va3M8SSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJhZGlvUmV0dXJuVHlwZUluZm88SSwgTD4ge1xuICAgIHVzZVJhZGlvSW5wdXQ6IFVzZVJhZGlvSW5wdXQ8ST47XG4gICAgdXNlUmFkaW9MYWJlbDogVXNlUmFkaW9MYWJlbDxMPjtcbn0qL1xuXG4vL3R5cGUgVXNlUmFkaW9JbnB1dDxJIGV4dGVuZHMgRWxlbWVudD4gPSAoeyB0YWcgfTogVGFnU2Vuc2l0aXZlUHJvcHM8ST4pID0+IHsgdXNlUmFkaW9JbnB1dFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJPjsgfVxuLy90eXBlIFVzZVJhZGlvTGFiZWw8TCBleHRlbmRzIEVsZW1lbnQ+ID0gKHsgdGFnIH06IFRhZ1NlbnNpdGl2ZVByb3BzPEw+KSA9PiB7IHVzZVJhZGlvTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TD47IH1cblxuLy9leHBvcnQgdHlwZSBVc2VSYWRpbzxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZVJhZGlvUGFyYW1ldGVyczxWLCBJLCBMLCBDLCBLPikgPT4gVXNlUmFkaW9SZXR1cm5UeXBlV2l0aEhvb2tzPEksIEw+XG5cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSYWRpbzxMUCBleHRlbmRzIExhYmVsUG9zaXRpb24sIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+KHtcbiAgICByYWRpb1BhcmFtZXRlcnM6IHsgdmFsdWUgfSxcbiAgICBjaGVja2JveExpa2VQYXJhbWV0ZXJzOiB7IGRpc2FibGVkIH0sXG4gICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICBsYWJlbFBhcmFtZXRlcnMsXG4gICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICBwcmVzc1BhcmFtZXRlcnMsXG4gICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIGNvbnRleHQsXG4gICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzXG5cbn06IFVzZVJhZGlvUGFyYW1ldGVyczxMUCwgViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJhZGlvU3ViSW5mbzxGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgVj4+KTogVXNlUmFkaW9SZXR1cm5UeXBlPExQLCBWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgUmFkaW9TdWJJbmZvPEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBWPj4ge1xuICAgIHR5cGUgVGFiYmFibGVDaGlsZEVsZW1lbnQgPSBGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PjtcbiAgICBjb25zdCBpbmRleCA9IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMuaW5kZXg7XG4gICAgZGVidWdMb2coXCJ1c2VSYWRpb1wiLCBpbmRleCk7XG4gICAgY29uc3Qgb25JbnB1dCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PElucHV0RWxlbWVudD4pID0+IHtcbiAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuLnNldFRoaXNPbmVTZWxlY3RlZChlKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgbmFtZSwgYnlOYW1lIH0gPSBjb250ZXh0LnJhZGlvQ29udGV4dFxuXG4gICAgY29uc3QgeyB0YWdJbnB1dCwgdGFnTGFiZWwsIGxhYmVsUG9zaXRpb24gfSA9IGxhYmVsUGFyYW1ldGVycztcblxuICAgIGNvbnN0IGdldFZhbHVlID0gdXNlU3RhYmxlR2V0dGVyKHZhbHVlKTtcbiAgICBjb25zdCB7XG4gICAgICAgIHByb3BzOiBsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMsXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuLFxuICAgICAgICBwcmVzc1JldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5cbiAgICB9ID0gdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkPFRhYmJhYmxlQ2hpbGRFbGVtZW50LCBSYWRpb1N1YkluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQsIFY+LCBuZXZlcj4oe1xuICAgICAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IGdldFZhbHVlMjogZ2V0VmFsdWUgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgcHJlc3NQYXJhbWV0ZXJzLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVycyxcbiAgICAgICAgLypyb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7XG4gICAgICAgICAgICBpbmRleDogbWFuYWdlZENoaWxkLmluZGV4LFxuICAgICAgICAgICAgZmxhZ3M6IG1hbmFnZWRDaGlsZC5mbGFnc1xuICAgICAgICB9LFxuICAgICAgICBoYXNGb2N1cyxcbiAgICAgICAgc3ViSW5mbzogeyBnZXRWYWx1ZSwgc3ViSW5mbyB9LCovXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczogeyBhcmlhUHJvcE5hbWU6IHRhZ0lucHV0ID09IFwiaW5wdXRcIiAmJiBsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIiA/IG51bGwgOiBcImFyaWEtc2VsZWN0ZWRcIiwgLi4uc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgc2VsZWN0ZWQ6IGNoZWNrZWQgfSA9IHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuO1xuXG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuOiByZWZFbGVtZW50SW5wdXRSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8SW5wdXRFbGVtZW50Pih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHJlZkVsZW1lbnRMYWJlbFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxMYWJlbEVsZW1lbnQ+KHsgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9IH0pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICBjaGVja2JveExpa2VJbnB1dFJldHVybixcbiAgICAgICAgY2hlY2tib3hMaWtlTGFiZWxSZXR1cm4sXG4gICAgICAgIHByZXNzSW5wdXRSZXR1cm4sXG4gICAgICAgIHByZXNzTGFiZWxSZXR1cm4sXG4gICAgICAgIHByb3BzSW5wdXQsXG4gICAgICAgIHByb3BzTGFiZWwsXG4gICAgICAgIHJhbmRvbUlkSW5wdXRSZXR1cm4sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxSZXR1cm4sXG4gICAgICAgIGNoZWNrYm94TGlrZVJldHVyblxuICAgIH0gPSB1c2VDaGVja2JveExpa2U8TGFiZWxQb3NpdGlvbiwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgY2hlY2tib3hMaWtlUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY2hlY2tlZDogKGNoZWNrZWQgPz8gZmFsc2UpLFxuICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICBvbklucHV0OiBvbklucHV0LFxuICAgICAgICAgICAgcm9sZTogXCJyYWRpb1wiXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsUGFyYW1ldGVycyxcbiAgICAgICAgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5yYWRpbyB9LFxuICAgICAgICByYW5kb21JZExhYmVsUGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLnJhZGlvTGFiZWwgfSxcbiAgICAgICAgcmVmRWxlbWVudElucHV0UmV0dXJuLFxuICAgICAgICByZWZFbGVtZW50TGFiZWxSZXR1cm5cbiAgICB9KTtcblxuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgYnlOYW1lLnNldCh2YWx1ZSwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gKCkgPT4geyBieU5hbWUuZGVsZXRlKHZhbHVlKTsgfVxuICAgIH0sIFt2YWx1ZSwgaW5kZXhdKTtcblxuICAgIC8vY29uc3QgdXNlUmFkaW9JbnB1dCA9ICgpID0+IHtcbiAgICBpZiAodGFnSW5wdXQgPT0gXCJpbnB1dFwiKSB7XG4gICAgICAgIHByb3BzSW5wdXQubmFtZSA9IG5hbWU7XG4gICAgICAgIHByb3BzSW5wdXQuY2hlY2tlZCA9IChjaGVja2VkID8/IGZhbHNlKTtcbiAgICAgICAgcHJvcHNJbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJvcHNJbnB1dFtcImFyaWEtY2hlY2tlZFwiXSA9IChjaGVja2VkID8/IGZhbHNlKS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3BzSWZJbnB1dEhhbmRsZXNGb2N1cyA9IHVzZU1lcmdlZFByb3BzPElucHV0RWxlbWVudD4obGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4sIHByb3BzSW5wdXQpO1xuICAgIGNvbnN0IHByb3BzSW5wdXQyOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+ID0gbGFiZWxQb3NpdGlvbiA9PSBcInNlcGFyYXRlXCIgPyBwcm9wc0lmSW5wdXRIYW5kbGVzRm9jdXMgOiBwcm9wc0lucHV0O1xuXG4gICAgLy8gfTtcblxuICAgIC8vY29uc3QgdXNlUmFkaW9MYWJlbDogVXNlUmFkaW9MYWJlbDxJTD4gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy9jb25zdCB0YWcgPSB0YWdMYWJlbDtcbiAgICAvL2NvbnN0IHVzZVJhZGlvTGFiZWxQcm9wcyA9IChwcm9wc0xhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJTD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJTD4gPT4ge1xuICAgIC8vY29uc3QgeyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50KCk7XG4gICAgY29uc3QgcHJvcHNJZkxhYmVsSGFuZGxlc0ZvY3VzID0gdXNlTWVyZ2VkUHJvcHM8TGFiZWxFbGVtZW50PihsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55PiwgcHJvcHNMYWJlbCk7XG4gICAgY29uc3QgcHJvcHNMYWJlbDI6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4gPSBsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIiA/IHByb3BzSWZMYWJlbEhhbmRsZXNGb2N1cyBhcyBhbnkgOiBwcm9wc0xhYmVsIGFzIGFueVxuICAgIC8vfTtcblxuICAgIC8vcmV0dXJuIHtcbiAgICAvLyAgICB1c2VSYWRpb0xhYmVsUHJvcHNcbiAgICAvL31cbiAgICAvL30sIFt1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNoZWNrYm94TGlrZUlucHV0UmV0dXJuLFxuICAgICAgICBjaGVja2JveExpa2VMYWJlbFJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuLFxuICAgICAgICBwcmVzc0lucHV0UmV0dXJuLFxuICAgICAgICBwcmVzc0xhYmVsUmV0dXJuLFxuICAgICAgICBwcm9wc0lucHV0OiBwcm9wc0lucHV0MixcbiAgICAgICAgcHJvcHNMYWJlbDogcHJvcHNMYWJlbDIsXG4gICAgICAgIHJhbmRvbUlkSW5wdXRSZXR1cm4sXG4gICAgICAgIHJhbmRvbUlkTGFiZWxSZXR1cm4sXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybixcbiAgICAgICAgcHJlc3NSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuLFxuICAgICAgICBjaGVja2JveExpa2VSZXR1cm5cbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgZ2VuZXJhdGVSYW5kb21JZCwgTWFuYWdlZENoaWxkSW5mbywgdXNlTWFuYWdlZENoaWxkLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQsIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUsIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIEV2ZW50RGV0YWlsLCBQcmVmaWNlcywgVGFnU2Vuc2l0aXZlUHJvcHMgfSBmcm9tIFwiLi9wcm9wc1wiO1xuXG5cblxuXG5leHBvcnQgdHlwZSBSYW5nZUNoYW5nZUV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSB7IFtFdmVudERldGFpbF06IHsgdmFsdWU6IG51bWJlciB9IH0gJiBQaWNrPGguSlNYLlRhcmdldGVkRXZlbnQ8RT4sIFwidGFyZ2V0XCIgfCBcImN1cnJlbnRUYXJnZXRcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGh1bWJJbmZvIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXI+IHtcbiAgICAvL3NldE1pbjogU3RhdGVVcGRhdGVyPG51bWJlcj47XG4gICAgLy9zZXRNYXg6IFN0YXRlVXBkYXRlcjxudW1iZXI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNsaWRlclRodW1iUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFNsaWRlclRodW1iSW5mbz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPE0+IHtcbiAgICBzbGlkZXJUaHVtYlBhcmFtZXRlcnM6IFRhZ1NlbnNpdGl2ZVByb3BzPEU+ICYge1xuICAgICAgICB2YWx1ZTogbnVtYmVyO1xuICAgICAgICB2YWx1ZVRleHQ/OiBzdHJpbmc7XG4gICAgICAgIG9uVmFsdWVDaGFuZ2U/OiAoZTogUmFuZ2VDaGFuZ2VFdmVudDxFPikgPT4gdm9pZDtcbiAgICAgICAgbWluPzogbnVtYmVyO1xuICAgICAgICBtYXg/OiBudW1iZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZXJlJ3Mgbm8sIGxpa2UsIFwic2xpZGVyIGNvbnRhaW5lclwiIGZvciBtdWx0aS10aHVtYiBzbGlkZXJzIGRlZmluZWQsXG4gICAgICAgICAqIHNvIGVhY2ggaW5kaXZpZHVhbCBzbGlkZXIgbmVlZHMgaXRzIG93biBsYWJlbC5cbiAgICAgICAgICogVE9ETzogVGhpcyBpcyBsaWtlIGEgdGFiL3RhYnBhbmVsIGxpbmtpbmcgdGhpbmcgd2hlcmUgZWFjaCBsYWJlbCBpcyBvdXRzaWRlXG4gICAgICAgICAqIG9mIHRoZSBjb250YWluZXIuIEZvciBub3csIGl0J3MgZWFzaWVyIHRvIGp1c3QgXG4gICAgICAgICAqIGFzc3VtZSBhIHN0cmluZy1iYXNlZCBsYWJlbCBpbnN0ZWFkIG9mIGFuIGVsZW1lbnQtYmFzZWQgb25lLlxuICAgICAgICAgKiBcbiAgICAgICAgICovXG4gICAgICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgfVxuICAgIGNvbnRleHQ6IFNsaWRlckNvbnRleHQ8TT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU2xpZGVyVGh1bWJQcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTbGlkZXJQYXJhbWV0ZXJzPE0gZXh0ZW5kcyBTbGlkZXJUaHVtYkluZm8+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxNPiB7XG4gICAgc2xpZGVyUGFyYW1ldGVyczoge1xuICAgICAgICBtaW46IG51bWJlcjtcbiAgICAgICAgbWF4OiBudW1iZXI7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNsaWRlclRodW1iUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFNsaWRlclRodW1iSW5mbz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlPE0+IHtcbiAgICBzbGlkZXJUaHVtYlJldHVybjoge1xuICAgICAgICBtaW46IG51bWJlcjtcbiAgICAgICAgbWF4OiBudW1iZXI7XG4gICAgfVxuICAgIHByb3BzU2xpZGVyVGh1bWI6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xufVxuXG5cbmV4cG9ydCB0eXBlIFVzZVNsaWRlclRodW1iPFRodW1iRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBTbGlkZXJUaHVtYkluZm8+ID0gKHByb3BzOiBVc2VTbGlkZXJUaHVtYlBhcmFtZXRlcnM8VGh1bWJFbGVtZW50LCBNPikgPT4gVXNlU2xpZGVyVGh1bWJSZXR1cm5UeXBlPFRodW1iRWxlbWVudCwgTT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU2xpZGVyUmV0dXJuVHlwZTxNIGV4dGVuZHMgU2xpZGVyVGh1bWJJbmZvPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8TT4ge1xuICAgIGNvbnRleHQ6IFNsaWRlckNvbnRleHQ8TT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyQ29udGV4dDxNIGV4dGVuZHMgU2xpZGVyVGh1bWJJbmZvPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQ8TT4ge1xuICAgIHNsaWRlckNvbnRleHQ6IHtcbiAgICAgICAgbWluOiBudW1iZXI7XG4gICAgICAgIG1heDogbnVtYmVyO1xuICAgICAgICBiYXNlSWQ6IHN0cmluZztcbiAgICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNsaWRlcih7IHNsaWRlclBhcmFtZXRlcnM6IHsgbWF4LCBtaW4gfSwgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyB9OiBVc2VTbGlkZXJQYXJhbWV0ZXJzPFNsaWRlclRodW1iSW5mbz4pOiBVc2VTbGlkZXJSZXR1cm5UeXBlPFNsaWRlclRodW1iSW5mbz4ge1xuICAgIGRlYnVnTG9nKFwidXNlU2xpZGVyXCIpO1xuICAgIGNvbnN0IHsgY29udGV4dCwgbWFuYWdlZENoaWxkcmVuUmV0dXJuIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48U2xpZGVyVGh1bWJJbmZvPih7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMgfSk7XG5cbiAgICBjb25zdCBiYXNlSWRSZWYgPSB1c2VSZWY8c3RyaW5nPihudWxsISBhcyBcIlwiKTtcbiAgICBpZiAoYmFzZUlkUmVmLmN1cnJlbnQgPT09IG51bGwpXG4gICAgICAgIGJhc2VJZFJlZi5jdXJyZW50ID0gZ2VuZXJhdGVSYW5kb21JZChQcmVmaWNlcy5zbGlkZXJUaHVtYik7XG4gICAgLy9jb25zdCB7IHByb3BzUmVmZXJlbmNlciwgcHJvcHNTb3VyY2UsIHJhbmRvbUlkUmV0dXJuOiB7IGlkOiBiYXNlSWQgfSB9ID0gdXNlUmFuZG9tSWQ8TGFiZWxFbGVtZW50LCBUaHVtYkVsZW1lbnQ+KHsgcmFuZG9tSWRQYXJhbWV0ZXJzOiB7IHByZWZpeDogXCJhcmlhLXRodW1iLVwiLCBvdGhlclJlZmVyZW5jZXJQcm9wOiBcImFyaWEtbGFiZWxsZWRieVwiIH0gfSlcblxuICAgIC8qY29uc3Qge1xuICAgICAgICBwcm9wc0lucHV0LFxuICAgICAgICBwcm9wc0xhYmVsLFxuICAgICAgICByYW5kb21JZElucHV0UmV0dXJuLFxuICAgICAgICByYW5kb21JZExhYmVsUmV0dXJuXG4gICAgfSA9IHVzZUxhYmVsPFRodW1iRWxlbWVudCwgTGFiZWxFbGVtZW50Pih7IGxhYmVsUGFyYW1ldGVyczogeyBhcmlhTGFiZWw6IG51bGwgfSwgcmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMsIHJhbmRvbUlkTGFiZWxQYXJhbWV0ZXJzIH0pOyovXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgc2xpZGVyQ29udGV4dDoge1xuICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICAgICAgYmFzZUlkOiBiYXNlSWRSZWYuY3VycmVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgW21pbiwgbWF4XSksXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVyblxuICAgIH07XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNsaWRlclRodW1iPFRodW1iRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBTbGlkZXJUaHVtYkluZm8+KHtcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIGNvbnRleHQ6IHsgc2xpZGVyQ29udGV4dDogeyBtYXg6IG1heFBhcmVudCwgbWluOiBtaW5QYXJlbnQgfSwgLi4uY29udGV4dCB9LFxuICAgIHNsaWRlclRodW1iUGFyYW1ldGVyc1xufTogVXNlU2xpZGVyVGh1bWJQYXJhbWV0ZXJzPFRodW1iRWxlbWVudCwgTT4pOiBVc2VTbGlkZXJUaHVtYlJldHVyblR5cGU8VGh1bWJFbGVtZW50LCBTbGlkZXJUaHVtYkluZm8+IHtcbiAgICBjb25zdCB7IGluZGV4IH0gPSBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzO1xuICAgIGRlYnVnTG9nKFwidXNlU2xpZGVyVGh1bWJcIiwgbWFuYWdlZENoaWxkUGFyYW1ldGVycy5pbmRleCk7XG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRSZXR1cm4gfSA9IHVzZU1hbmFnZWRDaGlsZDxTbGlkZXJUaHVtYkluZm8+KHsgbWFuYWdlZENoaWxkUGFyYW1ldGVycywgY29udGV4dCB9LCB7IGluZGV4IH0pO1xuICAgIGNvbnN0IHsgZ2V0Q2hpbGRyZW46IF9nZXRUaHVtYnMgfSA9IG1hbmFnZWRDaGlsZFJldHVybjtcblxuICAgIGNvbnN0IHsgdGFnLCB2YWx1ZSwgbWF4OiBtYXhPdmVycmlkZSwgbWluOiBtaW5PdmVycmlkZSwgb25WYWx1ZUNoYW5nZSwgdmFsdWVUZXh0LCBsYWJlbCB9ID0gc2xpZGVyVGh1bWJQYXJhbWV0ZXJzO1xuXG4gICAgY29uc3QgbWluID0gKG1pbk92ZXJyaWRlID8/IG1pblBhcmVudCk7XG4gICAgY29uc3QgbWF4ID0gKG1heE92ZXJyaWRlID8/IG1heFBhcmVudCk7XG5cbiAgICBsZXQgbmV3UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRodW1iRWxlbWVudD4gPSAoXG4gICAgICAgIHRhZyA9PSBcImlucHV0XCIgP1xuICAgICAgICAgICAgeyBtaW4sIG1heCwgdmFsdWUsIHR5cGU6IFwicmFuZ2VcIiB9IDpcbiAgICAgICAgICAgIHsgXCJhcmlhLXZhbHVlbWF4XCI6IGAke21heH1gLCBcImFyaWEtdmFsdWVtaW5cIjogYCR7bWlufWAsIFwiYXJpYS12YWx1ZW5vd1wiOiBgJHt2YWx1ZX1gIH1cbiAgICApO1xuICAgIG5ld1Byb3BzID0geyAuLi5uZXdQcm9wcywgXCJhcmlhLWxhYmVsXCI6IGxhYmVsLCBcImFyaWEtdmFsdWV0ZXh0XCI6IHZhbHVlVGV4dCwgc3R5bGU6IHsgXCItLXJhbmdlLXZhbHVlXCI6IGAke3ZhbHVlfWAsIFwiLS1yYW5nZS12YWx1ZS10ZXh0XCI6IGAke3ZhbHVlVGV4dH1gIH0gfTtcbiAgICBpZiAodGFnID09IFwiaW5wdXRcIikge1xuICAgICAgICBuZXdQcm9wcy5vbklucHV0ID0gZSA9PiB7XG4gICAgICAgICAgICBvblZhbHVlQ2hhbmdlPy4oeyBjdXJyZW50VGFyZ2V0OiBlLmN1cnJlbnRUYXJnZXQsIHRhcmdldDogZS50YXJnZXQsIFtFdmVudERldGFpbF06IHsgdmFsdWU6IChlLmN1cnJlbnRUYXJnZXQgYXMgRWxlbWVudCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZUFzTnVtYmVyIH0gfSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzbGlkZXJUaHVtYlJldHVybjoge1xuICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgbWF4XG4gICAgICAgIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgcHJvcHNTbGlkZXJUaHVtYjogbmV3UHJvcHNcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHtcbiAgICBDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ29udGV4dCxcbiAgICBDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93Q29udGV4dCwgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRDZWxsSW5mbywgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRSb3dJbmZvLCB1c2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uLFxuICAgIHVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsLCBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnMsIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZSwgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJldHVyblR5cGUsIHVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3csIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzLCBVc2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZSwgdXNlTWVyZ2VkUHJvcHMsIHVzZVN0YWJsZUNhbGxiYWNrXG59IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByZWZpY2VzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUxhYmVsU3ludGhldGljLCBVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcbmltcG9ydCB7IFVzZUxpc3Rib3hQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWxpc3Rib3hcIjtcblxuLy9leHBvcnQgdHlwZSBMaXN0Ym94U2luZ2xlU2VsZWN0RXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IHsgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfSB9ICYgUGljazxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+LCBcInRhcmdldFwiIHwgXCJjdXJyZW50VGFyZ2V0XCI+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlU2VjdGlvbkNvbnRleHQ8VGFibGVTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIFRhYmxlUm93SW5mbzxUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88VGFibGVDZWxsRWxlbWVudD4+IGV4dGVuZHMgQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNvbnRleHQ8VGFibGVTZWN0aW9uRWxlbWVudCwgVGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50LCBSTSwgQ00+IHt9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVTZWN0aW9uUGFyYW1ldGVyczxUYWJsZVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFibGVSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgVGFibGVSb3dJbmZvPFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudD4+IGV4dGVuZHMgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnM8VGFibGVTZWN0aW9uRWxlbWVudCwgVGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50LCBSTT4ge1xuICAgIHRhYmxlU2VjdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgdGFnVGFibGVTZWN0aW9uOiBFbGVtZW50VG9UYWc8VGFibGVTZWN0aW9uRWxlbWVudD47XG4gICAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVNlY3Rpb25SZXR1cm5UeXBlPFRhYmxlU2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJsZVJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBUYWJsZVJvd0luZm88VGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBUYWJsZUNlbGxJbmZvPFRhYmxlQ2VsbEVsZW1lbnQ+PiBleHRlbmRzIE9taXQ8VXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvblJldHVyblR5cGU8VGFibGVTZWN0aW9uRWxlbWVudCwgVGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50LCBSTSwgQ00+LCBcInByb3BzXCI+IHtcbiAgICBwcm9wc1RhYmxlU2VjdGlvbjogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVTZWN0aW9uRWxlbWVudD47XG4gICAgY29udGV4dDogVXNlVGFibGVTZWN0aW9uQ29udGV4dDxUYWJsZVNlY3Rpb25FbGVtZW50LCBUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQsIFJNLCBDTT47XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlUm93UmV0dXJuVHlwZTxUYWJsZVJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBUYWJsZVJvd0luZm88VGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBUYWJsZUNlbGxJbmZvPFRhYmxlQ2VsbEVsZW1lbnQ+PiBleHRlbmRzIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlPFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCwgUk0sIENNPiB7XG5cbiAgICBjb250ZXh0OiBVc2VUYWJsZVJvd0NvbnRleHQ8YW55LCBUYWJsZUNlbGxFbGVtZW50LCBDTT47XG5cbiB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlUm93UGFyYW1ldGVyczxUYWJsZVJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBUYWJsZVJvd0luZm88VGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBUYWJsZUNlbGxJbmZvPFRhYmxlQ2VsbEVsZW1lbnQ+PiBleHRlbmRzIFVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzPFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCwgUk0sIENNPiB7XG4gICAgdGFibGVSb3dQYXJhbWV0ZXJzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRoZSBgc2VsZWN0aW9uTGltaXRgIGlzIGBcInNpbmdsZVwiYCwgdGhpcyBtdXN0IGJlIGBudWxsYC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkOiBib29sZWFuIHwgbnVsbDtcbiAgICAgICAgdGFnVGFibGVSb3c6IEVsZW1lbnRUb1RhZzxUYWJsZVJvd0VsZW1lbnQ+O1xuICAgIH1cbn1cblxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlUm93Q29udGV4dDxUYWJsZVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFibGVSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFRhYmxlUm93SW5mbzxUYWJsZVJvd0VsZW1lbnQ+PiBleHRlbmRzIENvbXBsZXRlR3JpZE5hdmlnYXRpb25Db250ZXh0PFRhYmxlU2VjdGlvbkVsZW1lbnQsIFRhYmxlUm93RWxlbWVudCwgTT4ge31cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVSb3dDb250ZXh0PFRhYmxlUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxUYWJsZUNlbGxFbGVtZW50Pj4gZXh0ZW5kcyBDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93Q29udGV4dDxUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQsIE0+IHt9XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlPFRhYmxlQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88VGFibGVDZWxsRWxlbWVudD4+IGV4dGVuZHMgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlPFRhYmxlQ2VsbEVsZW1lbnQsIENNPiB7XG4gfVxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZUNlbGxQYXJhbWV0ZXJzPFRhYmxlQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88VGFibGVDZWxsRWxlbWVudD4+IGV4dGVuZHMgVXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzPFRhYmxlQ2VsbEVsZW1lbnQsIENNPiB7XG4gICAgdGFibGVDZWxsUGFyYW1ldGVyczoge1xuICAgICAgICB0YWdUYWJsZUNlbGw6IEVsZW1lbnRUb1RhZzxUYWJsZUNlbGxFbGVtZW50PjtcbiAgICB9XG4gICAgY29udGV4dDogVXNlVGFibGVSb3dDb250ZXh0PGFueSwgVGFibGVDZWxsRWxlbWVudCwgQ00+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlUm93SW5mbzxUYWJsZVJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHcmlkU2luZ2xlU2VsZWN0U29ydGFibGVDaGlsZFJvd0luZm88VGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50PiB7ICB9XG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlQ2VsbEluZm88VGFibGVDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgR3JpZFNpbmdsZVNlbGVjdFNvcnRhYmxlQ2hpbGRDZWxsSW5mbzxUYWJsZUNlbGxFbGVtZW50PiB7IH1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVBhcmFtZXRlcnM8VGFibGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGxhYmVsUGFyYW1ldGVyczogT21pdDxVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnNbXCJsYWJlbFBhcmFtZXRlcnNcIl0sIFwib25MYWJlbENsaWNrXCI+O1xuICAgIHRhYmxlUGFyYW1ldGVyczogUGljazxVc2VMaXN0Ym94UGFyYW1ldGVyczxUYWJsZUVsZW1lbnQsIGFueSwgTGFiZWxFbGVtZW50LCBhbnk+W1wibGlzdGJveFBhcmFtZXRlcnNcIl0sIFwic2VsZWN0aW9uTGltaXRcIj4gJiB7XG4gICAgICAgdGFnVGFibGU6IEVsZW1lbnRUb1RhZzxUYWJsZUVsZW1lbnQ+O1xuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVSZXR1cm5UeXBlPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHsgXG4gICAgcHJvcHNUYWJsZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVFbGVtZW50PjtcbiAgICBwcm9wc0xhYmVsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xuIH0gXG5cbi8vIGV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVTZWN0aW9uQ29udGV4dDxUYWJsZVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFibGVSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFRhYmxlUm93SW5mbzxUYWJsZVJvd0VsZW1lbnQ+PiBleHRlbmRzIENvbXBsZXRlR3JpZE5hdmlnYXRpb25Db250ZXh0PFRhYmxlU2VjdGlvbkVsZW1lbnQsIFRhYmxlUm93RWxlbWVudCwgTT4geyB9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUYWJsZTxUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbGFiZWxQYXJhbWV0ZXJzLFxuICAgIHRhYmxlUGFyYW1ldGVyczogeyBzZWxlY3Rpb25MaW1pdCwgdGFnVGFibGUgfSxcbn06IFVzZVRhYmxlUGFyYW1ldGVyczxUYWJsZUVsZW1lbnQsIExhYmVsRWxlbWVudD4pOiBVc2VUYWJsZVJldHVyblR5cGU8VGFibGVFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcbiAgICAvL2NvbnN0IHsgdGFnSW5wdXQ6IHRhZ1RhYmxlIH0gPSBsYWJlbFBhcmFtZXRlcnNcbiAgICBjb25zdCB7XG4gICAgICAgIHByb3BzSW5wdXQ6IHByb3BzTGFiZWxMaXN0LFxuICAgICAgICBwcm9wc0xhYmVsOiBwcm9wc0xhYmVsTGFiZWxcbiAgICB9ID0gdXNlTGFiZWxTeW50aGV0aWM8VGFibGVFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgbGFiZWxQYXJhbWV0ZXJzOiB7IC4uLmxhYmVsUGFyYW1ldGVycywgb25MYWJlbENsaWNrOiBudWxsIH0sXG4gICAgICAgIHJhbmRvbUlkSW5wdXRQYXJhbWV0ZXJzOiB7IHByZWZpeDogUHJlZmljZXMudGFibGUgfSxcbiAgICAgICAgcmFuZG9tSWRMYWJlbFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy50YWJsZUxhYmVsIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzVGFibGU6IHVzZU1lcmdlZFByb3BzKHsgcm9sZTogdGFnVGFibGUgPT0gXCJ0YWJsZVwiID8gdW5kZWZpbmVkIDogXCJncmlkXCIsIFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIjogKHNlbGVjdGlvbkxpbWl0ID09IFwibXVsdGlcIiA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkKSB9LCBwcm9wc0xhYmVsTGlzdCksXG4gICAgICAgIHByb3BzTGFiZWw6IHByb3BzTGFiZWxMYWJlbFxuICAgIH1cbn1cbmNvbnN0IG5hdHVyYWxTZWN0aW9uVHlwZXMgPSBuZXcgU2V0PGtleW9mIGguSlNYLkludHJpbnNpY0VsZW1lbnRzPihbXCJ0aGVhZFwiLCBcInRib2R5XCIsIFwidGZvb3RcIl0pO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVRhYmxlU2VjdGlvbjxUYWJsZVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFibGVSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgVGFibGVSb3dJbmZvPFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxUYWJsZUNlbGxFbGVtZW50Pj4oe1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIGdyaWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgIHRhYmxlU2VjdGlvblBhcmFtZXRlcnM6IHsgdGFnVGFibGVTZWN0aW9uIH1cbn06IFVzZVRhYmxlU2VjdGlvblBhcmFtZXRlcnM8VGFibGVTZWN0aW9uRWxlbWVudCwgVGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50LCBSTT4pOiBVc2VUYWJsZVNlY3Rpb25SZXR1cm5UeXBlPFRhYmxlU2VjdGlvbkVsZW1lbnQsIFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCwgUk0sIENNPiB7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHByb3BzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5cbiAgICB9ID0gdXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbjxUYWJsZVNlY3Rpb25FbGVtZW50LCBUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQsIFJNLCBDTT4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIGdyaWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1xuICAgIH0pO1xuXG4gICAgaWYgKCFuYXR1cmFsU2VjdGlvblR5cGVzLmhhcyh0YWdUYWJsZVNlY3Rpb24gYXMgYW55KSkge1xuICAgICAgICBwcm9wcy5yb2xlID0gXCJyb3dncm91cFwiO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgcHJvcHNUYWJsZVNlY3Rpb246IHByb3BzXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVGFibGVSb3c8VGFibGVSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgVGFibGVSb3dJbmZvPFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxUYWJsZUNlbGxFbGVtZW50Pj4oe1xuICAgIGFzQ2hpbGRSb3dQYXJhbWV0ZXJzOiB7XG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgY29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgdGV4dENvbnRlbnRQYXJhbWV0ZXJzLFxuICAgICAgICBjb250ZXh0OiBjeDFcbiAgICB9LFxuICAgIGFzUGFyZW50Um93UGFyYW1ldGVyczoge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1xuICAgIH0sXG4gICAgdGFibGVSb3dQYXJhbWV0ZXJzOiB7IHNlbGVjdGVkIH1cbn06IFVzZVRhYmxlUm93UGFyYW1ldGVyczxUYWJsZVJvd0VsZW1lbnQsIFRhYmxlQ2VsbEVsZW1lbnQsIFJNLCBDTT4pOiBVc2VUYWJsZVJvd1JldHVyblR5cGU8VGFibGVSb3dFbGVtZW50LCBUYWJsZUNlbGxFbGVtZW50LCBSTSwgQ00+IHtcbiAgICBjb25zdCB7XG4gICAgICAgIGFzQ2hpbGRSb3dSZXR1cm4sXG4gICAgICAgIGFzUGFyZW50Um93UmV0dXJuLFxuICAgICAgICBjb250ZXh0OiBjeDIsXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuLFxuICAgICAgICBwcm9wc1xuICAgIH0gPSB1c2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uUm93PFRhYmxlUm93RWxlbWVudCwgVGFibGVDZWxsRWxlbWVudCwgUk0sIENNPih7XG4gICAgICAgIGFzQ2hpbGRSb3dQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBjb250ZXh0OiBjeDEsXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycywgXG4gICAgICAgICAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVyc1xuICAgICAgICB9LFxuICAgICAgICBhc1BhcmVudFJvd1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcHJvcHMucm9sZSA9IFwiZ3JpZHJvd1wiO1xuICAgIGlmIChzZWxlY3RlZClcbiAgICAgICAgcHJvcHNbc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLmFyaWFQcm9wTmFtZSA/PyBcImFyaWEtc2VsZWN0ZWRcIl0gPSBcInRydWVcIjtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGFzQ2hpbGRSb3dSZXR1cm4sXG4gICAgICAgIGFzUGFyZW50Um93UmV0dXJuLFxuICAgICAgICBjb250ZXh0OiBjeDIsXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkUmV0dXJuLFxuICAgICAgICBwcm9wc1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRhYmxlQ2VsbDxUYWJsZUNlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ00gZXh0ZW5kcyBUYWJsZUNlbGxJbmZvPFRhYmxlQ2VsbEVsZW1lbnQ+Pih7IHRhYmxlQ2VsbFBhcmFtZXRlcnM6IHsgdGFnVGFibGVDZWxsIH0sIC4uLnAgfTogVXNlVGFibGVDZWxsUGFyYW1ldGVyczxUYWJsZUNlbGxFbGVtZW50LCBDTT4pOiBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlPFRhYmxlQ2VsbEVsZW1lbnQsIENNPiB7XG4gICAgY29uc3QgcmV0ID0gdXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGw8VGFibGVDZWxsRWxlbWVudCwgQ00+KHApO1xuICAgIGlmICghKHRhZ1RhYmxlQ2VsbCA9PSBcInRoXCIgfHwgdGFnVGFibGVDZWxsID09IFwidGRcIikpIHtcbiAgICAgICAgcmV0LnByb3BzLnJvbGUgPSBcImdyaWRjZWxsXCJcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8qXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlU2VjdGlvblNlY3Rpb25QYXJhbWV0ZXJzIHtcbiAgICBncmlkbGlzdFNlY3Rpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgIGNvbXBhcmVSb3dzOiAobGhzSW5kZXg6IG51bWJlciwgcmhzSW5kZXg6IG51bWJlcikgPT4gbnVtYmVyO1xuICAgIH1cbiAgICBncmlkbGlzdFNlY3Rpb25Db250ZXh0OiB7XG5cbiAgICB9XG59Ki9cbi8qXG5leHBvcnQgY29uc3QgdXNlVGFibGVTZWN0aW9uU2VjdGlvbiA9IDxCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBjb21wYXJlUm93cyB9OiBVc2VUYWJsZVNlY3Rpb25TZWN0aW9uUGFyYW1ldGVycykgPT4ge1xuICAgIC8vZGVidWdMb2coXCJ1c2VUYWJsZVNlY3Rpb25TZWN0aW9uXCIpO1xuICAgIC8vdHlwZSBDUkZ1bGwgPSBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Um93RWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPFVzZVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudCwgQ1IsIENDPj4+O1xuICAgIGNvbnN0IGdldEluZGV4ID0gdXNlQ2FsbGJhY2s8R2V0SW5kZXg8YW55Pj4oKGkpID0+IGkucHJvcHMuaW5kZXgsIFtdKTtcblxuXG4gICAgY29uc3Qge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuXG4gICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48Qm9keVNlY3Rpb25FbGVtZW50LCBUYWJsZVJvd0luZm88Um93RWxlbWVudD4+KHtcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZ2V0SW5kZXgsXG4gICAgICAgICAgICBnZXRIaWdoZXN0Q2hpbGRJbmRleCxcbiAgICAgICAgICAgIGdldFZhbGlkXG4gICAgICAgIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBjb21wYXJlOiAobGhzLCByaHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobGhzLmxvY2F0aW9uSW5kZXggPT09IHJocy5sb2NhdGlvbkluZGV4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZVJvd3MobGhzLmluZGV4LCByaHMuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaHMubG9jYXRpb25JbmRleCAtIHJocy5sb2NhdGlvbkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VUYWJsZVNlY3Rpb25TZWN0aW9uUHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4pID0+IHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQocHJvcHMuY2hpbGRyZW4gIT0gbnVsbCk7XG4gICAgICAgIG92ZXJ3cml0ZVdpdGhXYXJuaW5nKFwidXNlVGFibGVTZWN0aW9uU2VjdGlvblwiLCBwcm9wcywgXCJyb2xlXCIsIFwicm93Z3JvdXBcIik7XG4gICAgICAgIHJldHVybiB1c2VTb3J0YWJsZVByb3BzKHByb3BzIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4gJiB7IGNoaWxkcmVuOiBhbnkgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlVGFibGVTZWN0aW9uU2VjdGlvblByb3BzLFxuICAgICAgICAuLi5zb3J0YWJsZVJldFxuICAgIH1cbn0qL1xuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IGZpbmRGaXJzdEZvY3VzYWJsZSwgTWFuYWdlZENoaWxkSW5mbywgdXNlR2xvYmFsSGFuZGxlciwgdXNlTWFuYWdlZENoaWxkLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlbkNvbnRleHQsIHVzZU1lcmdlZFByb3BzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlLCB1c2VUaW1lb3V0IH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nIH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9hc3RzUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8VG9hc3RJbmZvPiB7XG4gICAgdG9hc3RzUGFyYW1ldGVyczoge1xuICAgICAgICB2aXNpYmxlQ291bnQ6IG51bWJlcjsgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgdG9hc3RzIHRoYXQgYXJlIHNob3duIGF0IG9uZSB0aW1lICh1c2VkIGZvciBhdXRvbWF0aWMgbWFuYWdlbWVudCBvZiB3aGVuIHRvIHNob3cgdG9hc3RzLCBpLmUuIGRvbid0IHNob3cgdGhpcyB0b2FzdCBpZiAyIGFyZSBhbHJlYWR5IG9uLXNjcmVlbiAtLSAxIGlzIGEgZ29vZCBkZWZhdWx0KVxuICAgIH1cbn1cblxuLy8gXCJmb2N1c1wiIHwgXCJzZXROdW1iZXJBaGVhZE9mTWVcIiB8IFwic2hvd1wiXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvYXN0UGFyYW1ldGVyczxNIGV4dGVuZHMgVG9hc3RJbmZvPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8TT4ge1xuICAgIHRvYXN0UGFyYW1ldGVyczoge1xuICAgICAgICBwb2xpdGVuZXNzPzogXCJwb2xpdGVcIiB8IFwiYXNzZXJ0aXZlXCI7XG4gICAgICAgIHRpbWVvdXQ6IG51bWJlciB8IG51bGw7XG4gICAgfVxuICAgIGNvbnRleHQ6IFRvYXN0c0NvbnRleHQ8TT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9hc3RJbmZvIGV4dGVuZHMgTWFuYWdlZENoaWxkSW5mbzxudW1iZXI+IHtcbiAgICBzZXROdW1iZXJBaGVhZE9mTWU6IFN0YXRlVXBkYXRlcjxudW1iZXI+O1xuICAgIGZvY3VzKCk6IHZvaWQ7XG4gICAgc2hvdygpOiB2b2lkO1xufVxuXG4vL2V4cG9ydCB0eXBlIFVzZVRvYXN0PEUgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VUb2FzdFBhcmFtZXRlcnMpID0+IFVzZVRvYXN0UmV0dXJuVHlwZTxFPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUb2FzdFJldHVyblR5cGU8VG9hc3RUeXBlIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHRvYXN0UmV0dXJuOiB7XG4gICAgICAgIG51bWJlck9mVG9hc3RzQWhlYWRPZlVzOiBudW1iZXI7XG4gICAgICAgIGRpc21pc3M6ICgpID0+IHZvaWQ7XG4gICAgICAgIGRpc21pc3NlZDogYm9vbGVhbjtcbiAgICAgICAgc2hvd2luZzogYm9vbGVhbjtcbiAgICAgICAgcmVzZXREaXNtaXNzVGltZXI6ICgpID0+IHZvaWQ7XG4gICAgfVxuICAgIHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUb2FzdFR5cGU+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvYXN0c1JldHVyblR5cGU8Q29udGFpbmVyVHlwZSBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBUb2FzdEluZm8+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxUb2FzdEluZm8+IHtcbiAgICBjb250ZXh0OiBUb2FzdHNDb250ZXh0PE0+XG4gICAgcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENvbnRhaW5lclR5cGU+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRvYXN0c0NvbnRleHQ8TSBleHRlbmRzIFRvYXN0SW5mbz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5Db250ZXh0PE0+IHtcbiAgICB0b2FzdENvbnRleHQ6IHtcbiAgICAgICAgb25BbnlUb2FzdERpc21pc3NlZDogKF9pbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuICAgICAgICBnZXRNYXhWaXNpYmxlQ291bnQ6ICgpID0+IG51bWJlcjtcbiAgICAgICAgc2V0UG9saXRlbmVzczogU3RhdGVVcGRhdGVyPFwicG9saXRlXCIgfCBcImFzc2VydGl2ZVwiPjtcbiAgICAgICAgb25BbnlUb2FzdE1vdW50ZWQ6ICh0b2FzdEluZGV4OiBudW1iZXIpID0+IHZvaWQ7XG4gICAgfTtcbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUb2FzdHM8Q29udGFpbmVyVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG9jbXUsIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCB9LCB0b2FzdHNQYXJhbWV0ZXJzOiB7IHZpc2libGVDb3VudCB9IH06IFVzZVRvYXN0c1BhcmFtZXRlcnMpOiBVc2VUb2FzdHNSZXR1cm5UeXBlPENvbnRhaW5lclR5cGUsIFRvYXN0SW5mbz4ge1xuICAgIGRlYnVnTG9nKFwidXNlVG9hc3RzXCIpO1xuXG4gICAgLy8gTm9ybWFsbHksIHRoaXMgZG9lcyBqdXN0IGxvb2sgbGlrZSBbMCwgMSwgMiwgM10sIGV0Y1xuICAgIC8vIHNvIGl0IGNvdWxkIGJlIGp1c3QgYW4gaW5kZXggdG8gdGhlIGN1cnJlbnQgdG9hc3QsXG4gICAgLy8gYnV0IGlmIHdlIGRpc21pc3MgdG9hc3RzIG91dCBvZiBvcmRlciwgaXQncyBbMCwgMiwgM10gb3Igc29tZXRoaW5nLlxuICAgIC8vIFNvIGp1c3Qga2VlcCB0cmFjayBvZiBpdCBhbGwgaW4gYSBiaWcgb2wnLCB0aGVyZSdzIG9ubHkgb25lIG9mIHRoZXNlIG9uIGEgcGFnZSBhbnl3YXksXG4gICAgLy8gYW5kIGlmIHlvdSdyZSBwdXNpbmcgMTAwMDAgdG9hc3RzIGF0IG9uY2UgYW4gQXJyYXk8bnVtYmVyPiBpc24ndCBnb2luZyB0byBiZSB5b3VyIGJvdHRsZW5lY2suXG4gICAgY29uc3QgY3VycmVudEluZGV4UXVldWUgPSB1c2VSZWY8bnVtYmVyW10+KFtdKTtcblxuICAgIGNvbnN0IFtwb2xpdGVuZXNzLCBzZXRQb2xpdGVuZXNzXSA9IHVzZVN0YXRlPFwicG9saXRlXCIgfCBcImFzc2VydGl2ZVwiPihcInBvbGl0ZVwiKTtcblxuICAgIGNvbnN0IGdldE1heFZpc2libGVDb3VudCA9IHVzZVN0YWJsZUdldHRlcih2aXNpYmxlQ291bnQpO1xuXG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQsIHByb3BzU3RhYmxlIH0gfSA9IHVzZVJlZkVsZW1lbnQ8Q29udGFpbmVyVHlwZT4oeyByZWZFbGVtZW50UGFyYW1ldGVyczoge30gfSk7XG4gICAgY29uc3QgeyBjb250ZXh0LCBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sIC4uLl9jaGlsZEluZm8gfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxUb2FzdEluZm8+KHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogb2NtdSB9IH0pO1xuXG4gICAgY29uc3QgeyBnZXRDaGlsZHJlbjogZ2V0VG9hc3RRdWV1ZSB9ID0gbWFuYWdlZENoaWxkcmVuUmV0dXJuO1xuICAgIGNvbnN0IHRvYXN0UXVldWUgPSBnZXRUb2FzdFF1ZXVlKCk7XG5cbiAgICAvLyBXaGVuIGEgdG9hc3QgaXMgc2hvd24gb3IgaGlkZGVuLCBhbHdheXMgbWFrZSBzdXJlIHRoYXQgd2UncmUgc2hvd2luZyBhbGwgdGhlIHRvYXN0cyB0aGF0IHdlIHNob3VsZCBiZS5cbiAgICBjb25zdCBzaG93SGlnaGVzdFByaW9yaXR5VG9hc3QgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWluKGdldE1heFZpc2libGVDb3VudCgpLCBjdXJyZW50SW5kZXhRdWV1ZS5jdXJyZW50Lmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXg7ICsraSkge1xuXG4gICAgICAgICAgICBjb25zdCBoaWdoZXN0UHJpb3JpdHlUb2FzdCA9IHRvYXN0UXVldWUuZ2V0QXQoY3VycmVudEluZGV4UXVldWUuY3VycmVudFtpXSk7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCghIWhpZ2hlc3RQcmlvcml0eVRvYXN0KTtcbiAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVRvYXN0Py5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIC8vIEFueSB0aW1lIGEgbmV3IHRvYXN0IG1vdW50cywgdXBkYXRlIG91ciBib3R0b21tb3N0VG9hc3RJbmRleCB0byBwb2ludCB0byBpdCBpZiBuZWNlc3NhcnlcbiAgICAvLyAoXCJuZWNlc3NhcnlcIiBqdXN0IG1lYW5pbmcgaWYgaXQncyB0aGUgZmlyc3QgdG9hc3QgZXZlciBvciBhbGwgcHJpb3IgdG9hc3RzIGhhdmUgYmVlbiBkaXNtaXNzZWQpXG4gICAgY29uc3Qgb25BbnlUb2FzdE1vdW50ZWQgPSB1c2VDYWxsYmFjaygodG9hc3RJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGN1cnJlbnRJbmRleFF1ZXVlLmN1cnJlbnQucHVzaCh0b2FzdEluZGV4KTtcbiAgICAgICAgdG9hc3RRdWV1ZS5nZXRBdCh0b2FzdEluZGV4KT8uc2V0TnVtYmVyQWhlYWRPZk1lKGN1cnJlbnRJbmRleFF1ZXVlLmN1cnJlbnQubGVuZ3RoIC0gMSk7XG4gICAgICAgIHNob3dIaWdoZXN0UHJpb3JpdHlUb2FzdCgpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIEFueSB0aW1lIGEgdG9hc3QgaXMgZGlzbWlzc2VkLCB1cGRhdGUgb3VyIGJvdHRvbW1vc3RUb2FzdEluZGV4IHRvIHBvaW50IHRvIHRoZSBuZXh0IHRvYXN0IGluIHRoZSBxdWV1ZSwgaWYgb25lIGV4aXN0cy5cbiAgICBjb25zdCBvbkFueVRvYXN0RGlzbWlzc2VkID0gdXNlQ2FsbGJhY2soKF9pbmRleDogbnVtYmVyKSA9PiB7XG5cbiAgICAgICAgLy8gV2hlbiB3ZSBkaXNtaXNzIGEgdG9hc3QsIHJlbW92ZSBpdCBmcm9tIHRoZSBcInRvLWRpc3BsYXlcIiBxdWV1ZSBieSBhY3R1YWxseSBzcGxpY2luZyBpdCBvdXQgb2YgdGhlIGFycmF5LlxuICAgICAgICAvLyBUaGVuIG5vdGlmeSBlYWNoIHRvYXN0IG9mIGl0cyBjaGFuZ2UgaW4gcG9zaXRpb24gd2l0aGluIHRoYXQgcXVldWUgdG8ga2VlcCB0aGUgdHdvIGluIHN5bmMuXG4gICAgICAgIGNvbnN0IHJlbW92YWxJbmRleCA9IGN1cnJlbnRJbmRleFF1ZXVlLmN1cnJlbnQuZmluZEluZGV4KGkgPT4gaSA9PSBfaW5kZXgpO1xuXG5cbiAgICAgICAgLy8gRm9yIGFsbCB0b2FzdHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkaXNtaXNzZWQsIHNoaWZ0IHRoZW0gZXZlbiBmdXJ0aGVyIGJhY2sgYnkgb25lIHRvIFwibWFrZSBzcGFjZVwiIFxuICAgICAgICAvLyAodGhleSdyZSByZW1vdmVkIGZyb20gdGhlIHF1ZXVlIGJ1dCB0aGlzIGlzIHRoZSBuZWdhdGl2ZSBpbmRleCB0aGV5IHdvdWxkIGhhdmUgaWYgd2Uga2VwdCBuZWdhdGl2ZXMgaW4gdGhlIHF1ZXVlKVxuICAgICAgICAvLyBmb3IgdGhlIG5ld2x5LWRpc21pc3NlZCB0b2FzdC5cbiAgICAgICAgdG9hc3RRdWV1ZS5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgYy5zZXROdW1iZXJBaGVhZE9mTWUocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldiAtIDE7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTGV0IHRoaXMgdG9hc3Qga25vdyB0aGF0IGl0J3Mgbm93IHRoZSBtb3N0IHJlY2VudGx5IGRpc21pc3NlZCB0b2FzdFxuICAgICAgICB0b2FzdFF1ZXVlLmdldEF0KF9pbmRleCk/LnNldE51bWJlckFoZWFkT2ZNZSgtMSk7XG5cbiAgICAgICAgLy8gTm90aWZ5IGFsbCB0b2FzdHMgd2FpdGluZyBiZWhpbmQgdGhpcyBvbmUgaW4gdGhlIHF1ZXVlIHRoYXQgdGhleSd2ZSBtb3ZlZCB1cCBvbmUgc2xvdFxuICAgICAgICB0b2FzdFF1ZXVlLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICBjLnNldE51bWJlckFoZWFkT2ZNZShwcmV2ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJldiA+IHJlbW92YWxJbmRleClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXYgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWN0dWFsbHkgbW9kaWZ5IHRoZSBxdWV1ZSBpdHNlbGZcbiAgICAgICAgY3VycmVudEluZGV4UXVldWUuY3VycmVudC5zcGxpY2UocmVtb3ZhbEluZGV4LCAxKTtcblxuICAgICAgICAvLyBBbmQgYWZ0ZXIgYWxsIHRoYXQsIG1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHNob3dpbmcgYW55IHRvYXN0cyB0aGF0IGhhdmUgYmVlbiB3YWl0aW5nIGluIHRoZSBxdWV1ZVxuICAgICAgICBzaG93SGlnaGVzdFByaW9yaXR5VG9hc3QoKTtcbiAgICB9LCBbXSk7XG5cblxuXG4gICAgY29uc3QgW19tb3VzZU92ZXIyLCBzZXRNb3VzZU92ZXIsIF9nZXRNb3VzZU92ZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJwb2ludGVybW92ZVwiLCBlID0+IHtcbiAgICAgICAgY29uc3QgbW91c2VPdmVyID0gKGUudGFyZ2V0ICE9IG51bGwgJiYgZS50YXJnZXQgaW5zdGFuY2VvZiBOb2RlICYmIChnZXRFbGVtZW50KCk/LmNvbnRhaW5zKGUudGFyZ2V0KSB8fCBnZXRFbGVtZW50KCkgPT0gZS50YXJnZXQpKTtcbiAgICAgICAgc2V0TW91c2VPdmVyKG1vdXNlT3Zlcik7XG4gICAgfSk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgaW5kZXggcG9pbnRpbmcgdG8gdGhlIGN1cnJlbnRseS1zaG93aW5nIHRvYXN0IGNoYW5nZXMsXG4gICAgLy8gdXBkYXRlIHRoZSByZWxldmFudCBjaGlsZHJlbiBhbmQgbGV0IHRoZW0ga25vdyB0aGF0IHRoZXkncmUgbm93IGVpdGhlciBhY3RpdmUgb3IgZGlzbWlzc2VkLlxuICAgIC8qY29uc3QgeyBjaGFuZ2VJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgfSA9IHVzZUNoaWxkcmVuRmxhZzxUb2FzdEluZm8sIFwic2hvd2luZ1wiPih7XG4gICAgICAgIGluaXRpYWxJbmRleDogYWN0aXZlVG9hc3RJbmRleCxcbiAgICAgICAgY2hpbGRyZW46IHRvYXN0UXVldWUsXG4gICAgICAgIGtleTogXCJzaG93aW5nXCIsXG4gICAgICAgIGNsb3Nlc3RGaXQ6IGZhbHNlLFxuICAgIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNoYW5nZUluZGV4KGFjdGl2ZVRvYXN0SW5kZXgpO1xuICAgIH0sIFthY3RpdmVUb2FzdEluZGV4XSk7Ki9cblxuICAgIGNvbnN0IHRvYXN0Q29udGV4dCA9IHtcbiAgICAgICAgb25BbnlUb2FzdERpc21pc3NlZCxcbiAgICAgICAgZ2V0TWF4VmlzaWJsZUNvdW50LFxuICAgICAgICBzZXRQb2xpdGVuZXNzLFxuICAgICAgICBvbkFueVRvYXN0TW91bnRlZFxuICAgIH1cbiAgICBcbiAgICAvL2Z1bmN0aW9uIHVzZVRvYXN0Q29udGFpbmVyUHJvcHMoeyByb2xlLCBcImFyaWEtbGl2ZVwiOiBhcmlhTGl2ZSwgXCJhcmlhLXJlbGV2YW50XCI6IGFyaWFSZWxldmFudCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyVHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJUeXBlPiB7XG4gICAgY29uc3QgcHJvcHMgPSB1c2VNZXJnZWRQcm9wczxDb250YWluZXJUeXBlPih1c2VNZXJnZWRQcm9wcyhwcm9wc1N0YWJsZSwgeyBjbGFzczogXCJ0b2FzdHMtY29udGFpbmVyXCIsIHJvbGU6IFwic3RhdHVzXCIsIFwiYXJpYS1saXZlXCI6IHBvbGl0ZW5lc3MgPz8gXCJwb2xpdGVcIiwgXCJhcmlhLXJlbGV2YW50XCI6IFwiYWRkaXRpb25zXCIgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJUeXBlPikpO1xuICAgIC8vfVxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgdG9hc3RDb250ZXh0XG4gICAgICAgIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgcHJvcHNcblxuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUb2FzdDxFIGV4dGVuZHMgRWxlbWVudD4oeyB0b2FzdFBhcmFtZXRlcnM6IHsgcG9saXRlbmVzcywgdGltZW91dCB9LCBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4LCAuLi5fbWFuYWdlZENoaWxkUGFyYW1ldGVycyB9LCBjb250ZXh0IH06IFVzZVRvYXN0UGFyYW1ldGVyczxUb2FzdEluZm8+KTogVXNlVG9hc3RSZXR1cm5UeXBlPEU+IHtcbiAgICBjb25zdCB7IGdldE1heFZpc2libGVDb3VudCwgb25BbnlUb2FzdERpc21pc3NlZCwgc2V0UG9saXRlbmVzcywgb25BbnlUb2FzdE1vdW50ZWQgfSA9IGNvbnRleHQudG9hc3RDb250ZXh0O1xuICAgIGRlYnVnTG9nKFwidXNlVG9hc3RcIiwgaW5kZXgpO1xuICAgIGNvbnN0IFtudW1iZXJPZlRvYXN0c0FoZWFkT2ZVcywgc2V0TnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXNdID0gdXNlU3RhdGUoSW5maW5pdHkpO1xuICAgIGNvbnN0IGdldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZGV4KTtcbiAgICBjb25zdCBbZGlzbWlzc2VkMiwgc2V0RGlzbWlzc2VkMiwgZ2V0RGlzbWlzc2VkMl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3Nob3dpbmcyLCBzZXRTaG93aW5nMiwgZ2V0U2hvd2luZzJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vY29uc3QgW2Rpc21pc3NlZCwgc2V0RGlzbWlzc2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvL2NvbnN0IFtzdGF0dXMsIHNldFN0YXR1cywgZ2V0U3RhdHVzXSA9IHVzZVN0YXRlPFwicGVuZGluZ1wiIHwgXCJhY3RpdmVcIiB8IFwiZGlzbWlzc2VkXCI+KFwicGVuZGluZ1wiKTtcbiAgICAvL2NvbnN0IGRpc21pc3NlZCA9IChzdGF0dXMgPT09IFwiZGlzbWlzc2VkXCIpO1xuICAgIGNvbnN0IGRpc21pc3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICghZ2V0RGlzbWlzc2VkMigpKVxuICAgICAgICAgICAgb25BbnlUb2FzdERpc21pc3NlZChnZXRJbmRleCgpKTtcblxuICAgICAgICBzZXREaXNtaXNzZWQyKHRydWUpO1xuICAgICAgICBzZXRTaG93aW5nMihmYWxzZSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qgc2hvdyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0U2hvd2luZzIodHJ1ZSk7XG4gICAgfSwgW10pXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWdldERpc21pc3NlZDIoKSAmJiAhZ2V0U2hvd2luZzIoKSkge1xuICAgICAgICAgICAgaWYgKG51bWJlck9mVG9hc3RzQWhlYWRPZlVzID49IDAgJiYgbnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMgPCBnZXRNYXhWaXNpYmxlQ291bnQoKSkge1xuICAgICAgICAgICAgICAgIHNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtudW1iZXJPZlRvYXN0c0FoZWFkT2ZVc10pXG5cbiAgICAvL2NvbnN0IHRvYXN0SWQgPSBnZW5lcmF0ZVJhbmRvbUlkKFwidG9hc3QtXCIpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHNldFBvbGl0ZW5lc3MocG9saXRlbmVzcyA/PyBcInBvbGl0ZVwiKTsgfSwgW3BvbGl0ZW5lc3NdKTtcblxuXG4gICAgY29uc3QgZm9jdXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEZvY3VzYWJsZSA9IGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50KTtcbiAgICAgICAgICAgIGZpcnN0Rm9jdXNhYmxlPy5mb2N1cz8uKCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZFJldHVybjogeyBnZXRDaGlsZHJlbjogX2dldFRvYXN0cyB9IH0gPSB1c2VNYW5hZ2VkQ2hpbGQ8VG9hc3RJbmZvPih7IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfSwgY29udGV4dCB9LCB7IGluZGV4LCBmb2N1cywgc2V0TnVtYmVyQWhlYWRPZk1lOiBzZXROdW1iZXJPZlRvYXN0c0FoZWFkT2ZVcywgc2hvdyB9KTtcblxuICAgIC8vY29uc3QgaXNBY3RpdmUgPSAoc3RhdHVzID09PSBcImFjdGl2ZVwiKTtcbiAgICBjb25zdCBbdHJpZ2dlckluZGV4LCBzZXRUcmlnZ2VySW5kZXhdID0gdXNlU3RhdGUoMSk7XG5cbiAgICBjb25zdCByZXNldERpc21pc3NUaW1lciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0VHJpZ2dlckluZGV4KGkgPT4gKytpKTtcbiAgICB9LCBbXSlcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIG9uQW55VG9hc3RNb3VudGVkKGluZGV4KTtcbiAgICB9LCBbXSk7XG5cbiAgICAvKnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghc2hvd2luZylcbiAgICAgICAgICAgIG9uQW55VG9hc3REaXNtaXNzZWQoaW5kZXgpXG4gICAgfSwgW3Nob3dpbmddKTsqL1xuXG4gICAgY29uc3QgZGlzbWlzc1RpbWVvdXRLZXkgPSAodGltZW91dCA9PSBudWxsIHx8IG51bWJlck9mVG9hc3RzQWhlYWRPZlVzICE9IDApID8gbnVsbCA6IGlzRmluaXRlKHRpbWVvdXQpID8gdGltZW91dCA6IHRpbWVvdXQgPiAwID8gbnVsbCA6IDA7XG5cbiAgICB1c2VUaW1lb3V0KHtcbiAgICAgICAgdGltZW91dDogZGlzbWlzc1RpbWVvdXRLZXksXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hvd2luZzIpXG4gICAgICAgICAgICAgICAgZGlzbWlzcygpO1xuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VySW5kZXg6IHNob3dpbmcyID8gdHJpZ2dlckluZGV4IDogZmFsc2VcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50LCBwcm9wc1N0YWJsZSB9IH0gPSB1c2VSZWZFbGVtZW50PEU+KHsgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9IH0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0b2FzdFJldHVybjoge1xuICAgICAgICAgICAgZGlzbWlzc2VkOiBkaXNtaXNzZWQyLFxuICAgICAgICAgICAgc2hvd2luZzogc2hvd2luZzIsXG4gICAgICAgICAgICBudW1iZXJPZlRvYXN0c0FoZWFkT2ZVcyxcbiAgICAgICAgICAgIGRpc21pc3MsXG4gICAgICAgICAgICByZXNldERpc21pc3NUaW1lclxuICAgICAgICB9LFxuICAgICAgICBwcm9wczogcHJvcHNTdGFibGVcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgcmV0dXJuRmFsc2UsIHVzZUdsb2JhbEhhbmRsZXIsIHVzZUhhc0N1cnJlbnRGb2N1cywgVXNlSGFzQ3VycmVudEZvY3VzUGFyYW1ldGVycywgdXNlTWVyZ2VkUHJvcHMsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlLCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhdGUsIHVzZVRpbWVvdXQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIFByZWZpY2VzIH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sdGlwVHJpZ2dlclBhcmFtZXRlcnM8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcmVmRWxlbWVudFJldHVybjogUmVxdWlyZWQ8UGljazxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUcmlnZ2VyVHlwZT5bXCJyZWZFbGVtZW50UmV0dXJuXCJdLCBcImdldEVsZW1lbnRcIj4+XG59XG5leHBvcnQgdHlwZSBVc2VUb29sdGlwVHJpZ2dlcjxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZVRvb2x0aXBUcmlnZ2VyUGFyYW1ldGVyczxUcmlnZ2VyVHlwZT4pID0+IHtcbiAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm5UeXBlOiBSZXF1aXJlZDxQaWNrPFVzZUhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM8VHJpZ2dlclR5cGU+W1wiaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyc1wiXSwgXCJvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkXCI+PlxuXG4gICAgdXNlVG9vbHRpcFRyaWdnZXJQcm9wczogKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT5cbn07XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvb2x0aXBQYXJhbWV0ZXJzIHsgbW91c2VvdmVyRGVsYXk/OiBudW1iZXIsIG1vdXNlb3V0VG9sZXJhbmNlRGVsYXk/OiBudW1iZXIsIGZvY3VzRGVsYXk/OiBudW1iZXIgfVxuZXhwb3J0IHR5cGUgVXNlVG9vbHRpcDxUcmlnZ2VyVHlwZSBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgVG9vbHRpcFR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VUb29sdGlwUGFyYW1ldGVycykgPT4gVXNlVG9vbHRpcFJldHVyblR5cGU8VHJpZ2dlclR5cGUsIFRvb2x0aXBUeXBlPjtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbHRpcFJldHVyblR5cGU8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50LCBQb3B1cFR5cGUgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgdG9vbHRpcFJldHVybjoge1xuICAgICAgICBpc09wZW46IGJvb2xlYW47XG4gICAgICAgIGdldElzT3BlbjogKCkgPT4gYm9vbGVhbjtcbiAgICB9XG4gICAgcHJvcHNQb3B1cDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UG9wdXBUeXBlPjtcbiAgICBwcm9wc1RyaWdnZXI6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPjtcbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUb29sdGlwPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudCwgUG9wdXBUeXBlIGV4dGVuZHMgRWxlbWVudD4oeyBtb3VzZW92ZXJEZWxheSwgbW91c2VvdXRUb2xlcmFuY2VEZWxheSwgZm9jdXNEZWxheSB9OiBVc2VUb29sdGlwUGFyYW1ldGVycyk6IFVzZVRvb2x0aXBSZXR1cm5UeXBlPFRyaWdnZXJUeXBlLCBQb3B1cFR5cGU+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZVRvb2x0aXBcIik7XG5cbiAgICBtb3VzZW92ZXJEZWxheSA/Pz0gNDAwO1xuICAgIG1vdXNlb3V0VG9sZXJhbmNlRGVsYXkgPz89IDUwMDtcbiAgICBmb2N1c0RlbGF5ID8/PSAxO1xuXG4gICAgLy8gVGhlIGVzY2FwZSBrZXkgc2hvdWxkIGNsb3NlIHRvb2x0aXBzLCBidXQgZG8gbm90aGluZyBlbHNlLlxuICAgIC8vIChpLmUuIGNsb3NpbmcgYSB0b29sdGlwIGluIGEgZGlhbG9nIE1VU1QgTk9UIGNsb3NlIHRoZSBkaWFsb2cgdG9vKVxuICAgIC8vIFRPRE86IFRvb2x0aXBzIGFyZSwgZWZmZWN0aXZlbHksIGFsd2F5cyB0aGUgdG9wbW9zdCBjb21wb25lbnQsXG4gICAgLy8gc28gd2UgY2FuIGp1c3QgaGF2ZSB0aGVtIGxpc3RlbiB0byBhbmQgc3dhbGxvdyBhbGwgXCJFc2NhcGVcIlxuICAgIC8vIGtleSBwcmVzc2VzIGJlZm9yZSBhbnlvbmUgZWxzZS4gRm9yIGEgbW9yZSBnZW5lcmFsIHBvcHVwLFxuICAgIC8vIG9yIGEgdG9vbHRpcCBpbiBhIHRvb2x0aXAgKCEhKSBhIGRpZmZlcmVudCBzb2x1dGlvbiB3b3VsZCBiZSBuZWVkZWQuXG4gICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJrZXlkb3duXCIsIChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChnZXRPcGVuKCkgJiYgZS5rZXkgPT09IFwiRXNjYXBlXCIgJiYgIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHNldE9wZW4oZmFsc2UpO1xuICAgICAgICAgICAgc2V0SG92ZXJTdGF0ZShcImhpZGRlblwiKTtcbiAgICAgICAgICAgIHNldFRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgc2V0VG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LCB7IGNhcHR1cmU6IHRydWUgfSk7XG5cbiAgICBjb25zdCBbb3Blbiwgc2V0T3BlbiwgZ2V0T3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBsZXQge1xuICAgICAgICBwcm9wc1JlZmVyZW5jZXI6IHByb3BzVHJpZ2dlcixcbiAgICAgICAgcHJvcHNTb3VyY2U6IHByb3BzUG9wdXBcbiAgICB9ID0gdXNlUmFuZG9tSWQ8UG9wdXBUeXBlLCBUcmlnZ2VyVHlwZT4oeyByYW5kb21JZFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy50b29sdGlwLCBvdGhlclJlZmVyZW5jZXJQcm9wOiBcImFyaWEtZGVzY3JpYmVkYnlcIiBhcyBuZXZlciB9IH0pO1xuXG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQ6IGdldFRyaWdnZXJFbGVtZW50LCBwcm9wc1N0YWJsZTogdHJpZ2dlclJlZlByb3BzIH0gfSA9IHVzZVJlZkVsZW1lbnQ8VHJpZ2dlclR5cGU+KHsgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9IH0pO1xuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50OiBnZXRQb3B1cEVsZW1lbnQsIHByb3BzU3RhYmxlOiBwb3B1cFJlZlByb3BzIH0gfSA9IHVzZVJlZkVsZW1lbnQ8UG9wdXBUeXBlPih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcblxuICAgIGNvbnN0IFssIHNldFRyaWdnZXJGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xuICAgICAgICBjb25zdCBkZWxheSA9IGZvY3VzZWQgPyBmb2N1c0RlbGF5IDogMTtcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgJiYgaXNGaW5pdGUoZGVsYXkpKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHNldFRyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZm9jdXNlZCksIGZvY3VzZWQgPyBmb2N1c0RlbGF5IDogMSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9KSwgcmV0dXJuRmFsc2UpO1xuICAgIGNvbnN0IFssIHNldFRvb2x0aXBGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xuICAgICAgICBjb25zdCBkZWxheSA9IGZvY3VzZWQgPyBmb2N1c0RlbGF5IDogMTtcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgJiYgaXNGaW5pdGUoZGVsYXkpKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZm9jdXNlZCksIGRlbGF5KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH0pLCByZXR1cm5GYWxzZSk7XG4gICAgY29uc3Qgb25Ib3ZlckNoYW5nZSA9IHVzZVN0YWJsZUNhbGxiYWNrKGZ1bmN0aW9uIG9uSG92ZXJDaGFuZ2UoaG92ZXJpbmc6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKGhvdmVyaW5nKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGhvdmVyU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaGlkaW5nXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgaG92aW5nIG92ZXIgdGhlIHRvb2x0aXAgcmlnaHQgYWZ0ZXIgaG92ZXJpbmcgYXdheSBmcm9tIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIHNob3cgaXQgYWdhaW4gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgc2V0SG92ZXJTdGF0ZShcInNob3duXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImhpZGRlblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0b29sdGlwIGlzbid0IHNob3dpbmcgYW5kIGhhc24ndCBmb3IgYXdoaWxlIChpZiBldmVyKVxuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciBvdXIgbW91c2VvdmVyIGRlbGF5XG4gICAgICAgICAgICAgICAgICAgIHNldEhvdmVyU3RhdGUoXCJzaG93aW5nMlwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7IGNvbnNvbGUubG9nKFwic2V0SG92ZXJTdGF0ZShzaG93bilcIik7ICBzZXRIb3ZlclN0YXRlKFwic2hvd25cIikgfSwgbW91c2VvdmVyRGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGhvdmVyU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwic2hvd25cIjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW91c2UgaGFzIGxlZnQgdGhlIHRyaWdnZXIsIGJ1dCBkZWxheSB0cnVseSBoaWRpbmcgaXQgZm9yIGEgbW9tZW50XG4gICAgICAgICAgICAgICAgICAgIHNldEhvdmVyU3RhdGUoXCJoaWRpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4geyBjb25zb2xlLmxvZyhcInNldEhvdmVyU3RhdGUoaGlkZGVuKVwiKTsgc2V0SG92ZXJTdGF0ZShcImhpZGRlblwiKTt9LCBtb3VzZW92ZXJEZWxheSk7XG4gICAgICAgICAgICAgICAgICAgIC8vcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwic2hvd2luZzJcIjoge1xuICAgICAgICAgICAgICAgICAgICAvLyBEdXJpbmcgYSBtb3VzZW92ZXIgZGVsYXksIHdoZW4gd2UgbW91c2VvdXQsXG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgcmVzZXQgdGhlIHRpbWVyXG4gICAgICAgICAgICAgICAgICAgIHNldEhvdmVyU3RhdGUoXCJoaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBbLCBzZXRUcmlnZ2VySG92ZXJdID0gdXNlUGFzc2l2ZVN0YXRlKG9uSG92ZXJDaGFuZ2UsIHJldHVybkZhbHNlKTtcbiAgICBjb25zdCBbLCBzZXRUb29sdGlwSG92ZXJdID0gdXNlUGFzc2l2ZVN0YXRlKG9uSG92ZXJDaGFuZ2UsIHJldHVybkZhbHNlKTtcbiAgICBjb25zdCBbdHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCwgc2V0VHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2hvdmVyU3RhdGUsIHNldEhvdmVyU3RhdGVdID0gdXNlU3RhdGU8XCJoaWRkZW5cIiB8IFwic2hvd2luZzJcIiB8IFwic2hvd25cIiB8IFwiaGlkaW5nXCI+KFwiaGlkZGVuXCIpO1xuXG5cblxuICAgIHVzZVRpbWVvdXQoe1xuICAgICAgICB0cmlnZ2VySW5kZXg6IGhvdmVyU3RhdGUsXG4gICAgICAgIHRpbWVvdXQ6IChob3ZlclN0YXRlID09IFwic2hvd2luZzJcIikgPyBtb3VzZW92ZXJEZWxheSA6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaG92ZXJTdGF0ZSA9PSBcInNob3dpbmcyXCIpIHtcbiAgICAgICAgICAgICAgICBzZXRIb3ZlclN0YXRlKFwic2hvd25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG5cblxuICAgIHVzZVRpbWVvdXQoe1xuICAgICAgICB0cmlnZ2VySW5kZXg6IGhvdmVyU3RhdGUsXG4gICAgICAgIHRpbWVvdXQ6IChob3ZlclN0YXRlID09IFwiaGlkaW5nXCIpID8gbW91c2VvdXRUb2xlcmFuY2VEZWxheSA6IG51bGwsXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaG92ZXJTdGF0ZSA9PSBcImhpZGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgc2V0SG92ZXJTdGF0ZShcImhpZGRlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICAvL2NvbnN0IFt0cmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZCwgc2V0VHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFt0b29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkLCBzZXRUb29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAvL2NvbnN0IFt0b29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZCwgc2V0VG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3QgaG92ZXJEZWxheUNvcnJlY3RlZCA9IChob3ZlclN0YXRlID09IFwic2hvd25cIik7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0T3Blbih0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIHx8IGhvdmVyRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEZvY3VzZWREZWxheUNvcnJlY3RlZCk7XG4gICAgfSwgW3RyaWdnZXJGb2N1c2VkRGVsYXlDb3JyZWN0ZWQgfHwgaG92ZXJEZWxheUNvcnJlY3RlZCB8fCB0b29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkXSk7XG5cblxuXG4gICAgLy9jb25zdCB1c2VUb29sdGlwVHJpZ2dlcjogVXNlVG9vbHRpcFRyaWdnZXI8VHJpZ2dlclR5cGU+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVG9vbHRpcFRyaWdnZXIoe1xuICAgIC8vICAgIHJlZkVsZW1lbnRSZXR1cm5cbiAgICAvL30pOiBSZXR1cm5UeXBlPFVzZVRvb2x0aXBUcmlnZ2VyPFRyaWdnZXJUeXBlPj4ge1xuICAgIGRlYnVnTG9nKFwidXNlVG9vbHRpcFRyaWdnZXJcIik7XG4gICAgLy9jb25zdCB7IGdldEVsZW1lbnQgfSA9IHJlZkVsZW1lbnRSZXR1cm47XG5cbiAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInBvaW50ZXJtb3ZlXCIsIGUgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSAoZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICBzZXRUcmlnZ2VySG92ZXIodGFyZ2V0ID09IGdldFRyaWdnZXJFbGVtZW50KCkgYXMgTm9kZSB8fCAhIWdldFRyaWdnZXJFbGVtZW50KCk/LmNvbnRhaW5zKHRhcmdldCkpO1xuICAgIH0sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcblxuICAgIGZ1bmN0aW9uIG9uVG91Y2hFbmQoZTogVG91Y2hFdmVudCkge1xuICAgICAgICAoZS50YXJnZXQgYXMgYW55KS5mb2N1cz8uKCk7XG4gICAgfVxuXG4gICAgLy9mdW5jdGlvbiB1c2VUb29sdGlwVHJpZ2dlclByb3BzKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+IHtcbiAgICAvL2NvbnN0IHsgcHJvcHNTdGFibGUgfSA9IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQoKTtcbiAgICAvLyBOb3RlOiBUaG91Z2ggaXQncyBpbXBvcnRhbnQgdG8gbWFrZSBzdXJlIHRoYXQgZm9jdXNpbmcgYWN0aXZhdGVzIGEgdG9vbHRpcCxcbiAgICAvLyBpdCdzIHBlcmZlY3RseSByZWFzb25hYmxlIHRoYXQgYSBjaGlsZCBlbGVtZW50IHdpbGwgYmUgdGhlIG9uZSB0aGF0J3MgZm9jdXNlZCxcbiAgICAvLyBub3QgdGhpcyBvbmUsIHNvIHdlIGRvbid0IHNldCB0YWJJbmRleD0wXG4gICAgcHJvcHNUcmlnZ2VyLnRhYkluZGV4ID8/PSAtMTtcbiAgICBcbiAgICAvL31cblxuICAgIGNvbnN0IHsgaGFzQ3VycmVudEZvY3VzUmV0dXJuIH0gPSB1c2VIYXNDdXJyZW50Rm9jdXM8VHJpZ2dlclR5cGU+KHsgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczogeyBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkOiBzZXRUcmlnZ2VyRm9jdXNlZCwgb25DdXJyZW50Rm9jdXNlZENoYW5nZWQ6IG51bGwgfSwgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50OiBnZXRUcmlnZ2VyRWxlbWVudCB9IH0pXG5cbiAgICAvL3JldHVybiB7XG4gICAgLy8gICAgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyxcbiAgICAvLyAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm5UeXBlOiB7IG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IHNldFRyaWdnZXJGb2N1c2VkIH1cbiAgICAvL307XG5cbiAgICAvL30sIFtdKTtcblxuICAgIC8vY29uc3QgdXNlVG9vbHRpcFBvcHVwID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlVG9vbHRpcCh7IHJlZkVsZW1lbnRSZXR1cm4gfTogVXNlVG9vbHRpcFBvcHVwUGFyYW1ldGVyczxQb3B1cFR5cGU+KSB7XG4gICAgZGVidWdMb2coXCJ1c2VUb29sdGlwVG9vbHRpcFwiKTtcbiAgICAvL2NvbnN0IHsgZ2V0RWxlbWVudCB9ID0gcmVmRWxlbWVudFJldHVybjtcbiAgICAvL2NvbnN0IHsgcHJvcHNTdGFibGUgfSA9IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudCgpO1xuICAgIGNvbnN0IHsgaGFzQ3VycmVudEZvY3VzUmV0dXJuOiB7IHByb3BzU3RhYmxlOiBwcm9wc0ZvY3VzUG9wdXAgfSB9ID0gdXNlSGFzQ3VycmVudEZvY3VzPFBvcHVwVHlwZT4oe1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7IG9uQ3VycmVudEZvY3VzZWRDaGFuZ2VkOiBudWxsLCBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZCkgPT4geyBzZXRUb29sdGlwRm9jdXNlZChmb2N1c2VkKTsgfSkgfSxcbiAgICAgICAgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50OiBnZXRQb3B1cEVsZW1lbnQgfVxuICAgIH0pXG5cbiAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInBvaW50ZXJtb3ZlXCIsIGUgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSAoZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICBzZXRUb29sdGlwSG92ZXIodGFyZ2V0ID09IGdldFBvcHVwRWxlbWVudCgpIGFzIE5vZGUgfHwgISFnZXRQb3B1cEVsZW1lbnQoKT8uY29udGFpbnModGFyZ2V0KSk7XG4gICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuXG4gICAgLy9mdW5jdGlvbiB1c2VUb29sdGlwUG9wdXBQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UG9wdXBUeXBlPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwVHlwZT4ge1xuICAgIC8vICAgIHJldHVybiB1c2VNZXJnZWRQcm9wcyhwcm9wc1N0YWJsZSwgcHJvcHMpO1xuICAgIC8vIH1cblxuICAgIC8vcmV0dXJuIHsgdXNlVG9vbHRpcFBvcHVwUHJvcHMgfTtcbiAgICAvL30sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzUG9wdXA6IHVzZU1lcmdlZFByb3BzKHBvcHVwUmVmUHJvcHMsIHByb3BzUG9wdXAsIHByb3BzRm9jdXNQb3B1cCksXG4gICAgICAgIHByb3BzVHJpZ2dlcjogdXNlTWVyZ2VkUHJvcHModHJpZ2dlclJlZlByb3BzLCBwcm9wc1RyaWdnZXIsIGhhc0N1cnJlbnRGb2N1c1JldHVybi5wcm9wc1N0YWJsZSwgeyBvblRvdWNoRW5kIH0pLFxuICAgICAgICB0b29sdGlwUmV0dXJuOiB7XG4gICAgICAgICAgICBpc09wZW46IG9wZW4sXG4gICAgICAgICAgICBnZXRJc09wZW46IGdldE9wZW5cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUb29sdGlwUG9wdXBQYXJhbWV0ZXJzPFBvcHVwVHlwZSBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICByZWZFbGVtZW50UmV0dXJuOiBSZXF1aXJlZDxQaWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFBvcHVwVHlwZT5bXCJyZWZFbGVtZW50UmV0dXJuXCJdLCBcImdldEVsZW1lbnRcIj4+XG59XG4iLCJpbXBvcnQgeyBDb250ZXh0LCBjcmVhdGVDb250ZXh0LCBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgR2V0SW5kZXgsIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBGb3J3YXJkRm4sIGZvcndhcmRSZWYsIG1lbW8sIHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbWVtb0ZvcndhcmRSZWY8VCBleHRlbmRzIEZvcndhcmRGbjxhbnksIGFueT4+KGZuOiBUKTogVCB7XG4gICAgcmV0dXJuIG1lbW8oZm9yd2FyZFJlZihmbikpIGFzIFQ7Ly8ocHJvcHM6IFBhcmFtZXRlcnM8VD5bMF0pID0+IFJldHVyblR5cGU8VD47XG59XG5cbmV4cG9ydCBjb25zdCBDb250ZXh0RGVmYXVsdHMgPSB7XG4gICAgY29sbGF0b3I6IGNyZWF0ZUNvbnRleHQ8SW50bC5Db2xsYXRvciB8IG51bGw+KG51bGwpLFxuICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZTogY3JlYXRlQ29udGV4dDxudW1iZXI+KDAuMSksXG4gICAgdHlwZWFoZWFkVGltZW91dDogY3JlYXRlQ29udGV4dCgxMDAwKSxcbiAgICBub1R5cGVhaGVhZDogY3JlYXRlQ29udGV4dChmYWxzZSksXG4gICAgZ2V0SW5kZXg6IGNyZWF0ZUNvbnRleHQ8R2V0SW5kZXg8YW55Pj4odiA9PiB2LnByb3BzLmluZGV4KSxcbiAgICBkaXNhYmxlQXJyb3dLZXlzOiBjcmVhdGVDb250ZXh0KGZhbHNlKSxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXM6IGNyZWF0ZUNvbnRleHQoZmFsc2UpLFxuICAgIGdldFdpbmRvdzogY3JlYXRlQ29udGV4dCgoKSA9PiBnbG9iYWxUaGlzLndpbmRvdyBhcyBXaW5kb3cpLFxuICAgIGZvY3VzT3BlbmVyOiBjcmVhdGVDb250ZXh0KChlOiBhbnkpID0+IGU/LmZvY3VzPy4oKSksXG4gICAgZ2V0VGV4dDogY3JlYXRlQ29udGV4dCgoZTogYW55KSA9PiAoZT8udGV4dENvbnRlbnQgPz8gXCJcIikgYXMgc3RyaW5nIHwgbnVsbCksXG4gICAgc2VsZWN0aW9uTW9kZTogY3JlYXRlQ29udGV4dDxVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8YW55PltcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiXVtcInNlbGVjdGlvbk1vZGVcIl0+KFwiYWN0aXZhdGlvblwiKSxcbn1cblxudHlwZSBEZWZhdWx0RXhjZXB0cyA9IGtleW9mIHR5cGVvZiBDb250ZXh0RGVmYXVsdHM7XG5cbnR5cGUgQ29udGV4dFR5cGU8VCBleHRlbmRzIENvbnRleHQ8YW55Pj4gPSBUIGV4dGVuZHMgQ29udGV4dDxpbmZlciBDPj8gQyA6IHVua25vd247XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEZWZhdWx0PEsgZXh0ZW5kcyBEZWZhdWx0RXhjZXB0cz4oY29udGV4dDogSywgdXNlclZhbHVlOiB1bmRlZmluZWQgfCBDb250ZXh0VHlwZTwodHlwZW9mIENvbnRleHREZWZhdWx0cylbS10+KTogQ29udGV4dFR5cGU8KHR5cGVvZiBDb250ZXh0RGVmYXVsdHMpW0tdPiB7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdXNlQ29udGV4dDxDb250ZXh0VHlwZTwodHlwZW9mIENvbnRleHREZWZhdWx0cylbS10+PihDb250ZXh0RGVmYXVsdHNbY29udGV4dF0gYXMgQ29udGV4dDxhbnk+KTtcbiAgICByZXR1cm4gdXNlclZhbHVlID8/IGRlZmF1bHRWYWx1ZTtcbn1cblxuZXhwb3J0IGNvbnN0IFBhcmVudERlcHRoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoMCk7XG5cbnR5cGUgUGFydGlhbEV4Y2VwdEQ8VCwgS2VlcFJlcXVpcmVkIGV4dGVuZHMga2V5b2YgVD4gPSBQYXJ0aWFsPFBpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLZWVwUmVxdWlyZWQ+Pj4gJiBQaWNrPFQsIEtlZXBSZXF1aXJlZD47XG5leHBvcnQgdHlwZSBQYXJ0aWFsRXhjZXB0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFBhcnRpYWxFeGNlcHREPFQsIEs+OyIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlQWNjb3JkaW9uLCBVc2VBY2NvcmRpb25Db250ZXh0LCBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzLCBVc2VBY2NvcmRpb25SZXR1cm5UeXBlLCB1c2VBY2NvcmRpb25TZWN0aW9uLCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbywgVXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnMsIFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlIH0gZnJvbSBcIi4uL3VzZS1hY2NvcmRpb25cIjtcbmltcG9ydCB7IEhlYWRpbmcgfSBmcm9tIFwiLi9oZWFkaW5nXCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiwgUGFydGlhbEV4Y2VwdCwgdXNlRGVmYXVsdCB9IGZyb20gXCIuL3V0aWxcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuaW50ZXJmYWNlIEFjY29yZGlvblByb3BzQmFzZTxIZWFkZXJCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VBY2NvcmRpb25QYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQsIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvPiwgXCJhY2NvcmRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VBY2NvcmRpb25QYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQsIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvPiwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlQWNjb3JkaW9uUGFyYW1ldGVyczxIZWFkZXJCdXR0b25FbGVtZW50LCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4sIFwibWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZUFjY29yZGlvblJldHVyblR5cGU8SGVhZGVyQnV0dG9uRWxlbWVudCwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+Pjtcbn1cblxuaW50ZXJmYWNlIEFjY29yZGlvblNlY3Rpb25Qcm9wc0Jhc2U8SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudCwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+LCBcImFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VBY2NvcmRpb25TZWN0aW9uUGFyYW1ldGVyczxIZWFkZXJCdXR0b25FbGVtZW50LCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudCwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+LCBcImJ1dHRvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzPEhlYWRlckJ1dHRvbkVsZW1lbnQsIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvPiwgXCJyb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyQnV0dG9uRWxlbWVudCwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm8+LCBcInByZXNzUGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlPEhlYWRlckVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQsIEJvZHlFbGVtZW50Pj47XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBBY2NvcmRpb25Qcm9wczxIZWFkZXJCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PEFjY29yZGlvblByb3BzQmFzZTxIZWFkZXJCdXR0b25FbGVtZW50PiwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlQWNjb3JkaW9uUmV0dXJuVHlwZTxIZWFkZXJCdXR0b25FbGVtZW50LCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFjY29yZGlvblNlY3Rpb25Qcm9wczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PEFjY29yZGlvblNlY3Rpb25Qcm9wc0Jhc2U8SGVhZGVyRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCwgQm9keUVsZW1lbnQ+LCBcImluZGV4XCIgfCBcInRhZ0J1dHRvblwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlPEhlYWRlckVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQsIEJvZHlFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cblxuY29uc3QgQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUFjY29yZGlvbkNvbnRleHQ8YW55LCBhbnk+PihudWxsISk7XG5leHBvcnQgY29uc3QgQWNjb3JkaW9uID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gQWNjb3JkaW9uPEhlYWRlckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBuYXZpZ2F0ZVBhc3RFbmQsXG4gICAgbmF2aWdhdGVQYXN0U3RhcnQsXG4gICAgcGFnZU5hdmlnYXRpb25TaXplLFxuICAgIHJlbmRlcixcbiAgICAuLi5fcmVzdFxufTogQWNjb3JkaW9uUHJvcHM8SGVhZGVyQnV0dG9uRWxlbWVudD4sIHJlZj86IFJlZjxhbnk+KSB7XG5cbiAgICBjb25zdCBpbmZvID0gdXNlQWNjb3JkaW9uPEhlYWRlckJ1dHRvbkVsZW1lbnQsIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvPih7XG4gICAgICAgIGFjY29yZGlvblBhcmFtZXRlcnM6IHsgaW5pdGlhbEluZGV4IH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUFycm93S2V5c1wiLCBkaXNhYmxlQXJyb3dLZXlzKSxcbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5czogdXNlRGVmYXVsdChcImRpc2FibGVIb21lRW5kS2V5c1wiLCBkaXNhYmxlSG9tZUVuZEtleXMpLFxuICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZDogbmF2aWdhdGVQYXN0RW5kID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IG5hdmlnYXRlUGFzdFN0YXJ0ID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplOiB1c2VEZWZhdWx0KFwicGFnZU5hdmlnYXRpb25TaXplXCIsIHBhZ2VOYXZpZ2F0aW9uU2l6ZSlcbiAgICAgICAgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9XG4gICAgfSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxBY2NvcmRpb25TZWN0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17aW5mby5jb250ZXh0fT57cmVuZGVyKGluZm8pfTwvQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufSlcbi8qXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckFjY29yZGlvblNlY3Rpb248SGVhZGVyQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbWFrZVByb3BzSGVhZGluZ0NvbnRhaW5lciwgbWFrZVByb3BzSGVhZGluZ0J1dHRvbiwgbWFrZVByb3BzQm9keSwgdGFnQm9keSwgdGFnSGVhZGluZ0J1dHRvbiB9OiB7IHRhZ0hlYWRpbmdCdXR0b246IEVsZW1lbnRUb1RhZzxIZWFkZXJCdXR0b25FbGVtZW50PjsgdGFnQm9keTogRWxlbWVudFRvVGFnPEJvZHlFbGVtZW50PjsgbWFrZVByb3BzSGVhZGluZ0NvbnRhaW5lcihpbmZvOiBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZTxIZWFkZXJCdXR0b25FbGVtZW50LCBCb2R5RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJDb250YWluZXJFbGVtZW50PiwgbWFrZVByb3BzSGVhZGluZ0J1dHRvbihpbmZvOiBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZTxIZWFkZXJCdXR0b25FbGVtZW50LCBCb2R5RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJCdXR0b25FbGVtZW50PiwgbWFrZVByb3BzQm9keShpbmZvOiBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZTxIZWFkZXJCdXR0b25FbGVtZW50LCBCb2R5RWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGU8SGVhZGVyQnV0dG9uRWxlbWVudCwgQm9keUVsZW1lbnQ+KTogVk5vZGU8YW55PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIDxIZWFkaW5nPEhlYWRlckNvbnRhaW5lckVsZW1lbnQ+IHsuLi5tYWtlUHJvcHNIZWFkaW5nQ29udGFpbmVyKGluZm8pfSBoZWFkaW5nPXtjcmVhdGVFbGVtZW50KHRhZ0hlYWRpbmdCdXR0b24gYXMgbmV2ZXIsIChtYWtlUHJvcHNIZWFkaW5nQnV0dG9uKGluZm8pKSl9PlxuICAgICAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdCb2R5IGFzIG5ldmVyLCAobWFrZVByb3BzQm9keShpbmZvKSkpfVxuICAgICAgICAgICAgICAgIDwvSGVhZGluZz5cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufSovXG5cbmV4cG9ydCBjb25zdCBBY2NvcmRpb25TZWN0aW9uID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gQWNjb3JkaW9uU2VjdGlvbjxIZWFkZXJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIG9wZW4sXG4gICAgaW5kZXgsXG4gICAgdGFnQnV0dG9uLFxuICAgIGRpc2FibGVkLFxuICAgIGJvZHlSb2xlLFxuICAgIG9uUHJlc3MsXG4gICAgZXhjbHVkZSxcbiAgICBoaWRkZW4sXG4gICAgcmVuZGVyLFxufTogQWNjb3JkaW9uU2VjdGlvblByb3BzPEhlYWRlckNvbnRhaW5lckVsZW1lbnQsIEhlYWRlckJ1dHRvbkVsZW1lbnQsIEJvZHlFbGVtZW50PiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBY2NvcmRpb25TZWN0aW9uQ29udGV4dCkgYXMgVXNlQWNjb3JkaW9uQ29udGV4dDxIZWFkZXJCdXR0b25FbGVtZW50LCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mbz47XG4gICAgY29uc3QgaW5mbyA9IHVzZUFjY29yZGlvblNlY3Rpb248SGVhZGVyQ29udGFpbmVyRWxlbWVudCwgSGVhZGVyQnV0dG9uRWxlbWVudCwgQm9keUVsZW1lbnQ+KHtcbiAgICAgICAgYnV0dG9uUGFyYW1ldGVyczogeyBkaXNhYmxlZDogZGlzYWJsZWQgPz8gZmFsc2UsIHRhZ0J1dHRvbiwgb25QcmVzczogb25QcmVzcyA/PyBudWxsIH0sXG4gICAgICAgIGFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzOiB7IG9wZW4sIGJvZHlSb2xlOiBib2R5Um9sZSA/PyBcInJlZ2lvblwiIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXgsIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczogeyBleGNsdWRlIH0sXG4gICAgICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgY29udGV4dFxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiByZW5kZXIoaW5mbyk7XG59KVxuXG5leHBvcnQgZnVuY3Rpb24gQWNjb3JkaW9uRGVtbygpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8QWNjb3JkaW9uXG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzPXtmYWxzZX1cbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5cz17ZmFsc2V9XG4gICAgICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uPVwidmVydGljYWxcIlxuICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplPXswLjF9XG4gICAgICAgICAgICByZW5kZXI9e2luZm8gPT5cbiAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxBY2NvcmRpb25TZWN0aW9uRGVtbyBpbmRleD17MH0gLz47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kPVwid3JhcFwiXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydD1cIndyYXBcIiAvPlxuICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBBY2NvcmRpb25TZWN0aW9uRGVtbyh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPEFjY29yZGlvblNlY3Rpb248YW55LCBIVE1MQnV0dG9uRWxlbWVudCwgSFRNTFBhcmFncmFwaEVsZW1lbnQ+XG4gICAgICAgICAgICBib2R5Um9sZT1cInJlZ2lvblwiXG4gICAgICAgICAgICBkaXNhYmxlZD17ZmFsc2V9XG4gICAgICAgICAgICBleGNsdWRlPXt1bmRlZmluZWR9XG4gICAgICAgICAgICBoaWRkZW49e2ZhbHNlfVxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgb25QcmVzcz17bnVsbH1cbiAgICAgICAgICAgIG9wZW49e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIHJlbmRlcj17aW5mbyA9PiAoXG4gICAgICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz17PD48c3Bhbj5BY2NvcmRpb24gc2VjdGlvbiAke2luZGV4fTwvc3Bhbj48YnV0dG9uIHsuLi5pbmZvLnByb3BzSGVhZGVyQnV0dG9ufT5Ub2dnbGUgb3BlbjwvYnV0dG9uPjwvPn0+XG4gICAgICAgICAgICAgICAgICAgIDxwIHsuLi5pbmZvLnByb3BzQm9keX0gaGlkZGVuPXtpbmZvLmFjY29yZGlvblNlY3Rpb25SZXR1cm4uZXhwYW5kZWR9PlxuICAgICAgICAgICAgICAgICAgICAgICAgQWNjb3JkaW9uIGJvZHkgY29udGVudFxuICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPC9IZWFkaW5nPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHRhZ0J1dHRvbj1cImJ1dHRvblwiXG4gICAgICAgIC8+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VCdXR0b24sIFVzZUJ1dHRvblBhcmFtZXRlcnMsIFVzZUJ1dHRvblJldHVyblR5cGUgfSBmcm9tIFwiLi4vdXNlLWJ1dHRvblwiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcnRpYWxFeGNlcHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmludGVyZmFjZSBCdXR0b25Qcm9wc0Jhc2U8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBPbWl0PEdldDxVc2VCdXR0b25QYXJhbWV0ZXJzPEU+LCBcImJ1dHRvblBhcmFtZXRlcnNcIj4sIFwicm9sZVwiPixcbiAgICBHZXQ8VXNlQnV0dG9uUGFyYW1ldGVyczxFPiwgXCJwcmVzc1BhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUJ1dHRvblBhcmFtZXRlcnM8RT4sIFwicmVmRWxlbWVudFBhcmFtZXRlcnNcIj4ge1xuICAgIHJlZj86IFJlZjxVc2VCdXR0b25SZXR1cm5UeXBlPEU+Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCdXR0b25Qcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PEJ1dHRvblByb3BzQmFzZTxFPiwgXCJ0YWdCdXR0b25cIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VCdXR0b25SZXR1cm5UeXBlPEU+KTogVk5vZGU8YW55Pjtcbn1cbi8qXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckJ1dHRvbjxFIGV4dGVuZHMgRWxlbWVudD4oeyB0YWdCdXR0b24sIHByb3BzQnV0dG9uIH06IHsgdGFnQnV0dG9uOiBFbGVtZW50VG9UYWc8RT4sIHByb3BzQnV0dG9uOiAoaW5mbzogVXNlQnV0dG9uUmV0dXJuVHlwZTxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlQnV0dG9uUmV0dXJuVHlwZTxFPikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdCdXR0b24gYXMgYW55LCBwcm9wc0J1dHRvbihpbmZvKSk7XG4gICAgfVxufSovXG5cbmV4cG9ydCBjb25zdCBCdXR0b24gPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBCdXR0b248RSBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnQnV0dG9uLCBvblByZXNzLCBwcmVzc2VkLCByZW5kZXIsIGRpc2FibGVkLCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCwgZXhjbHVkZSB9OiBCdXR0b25Qcm9wczxFPiwgcmVmOiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGluZm8gPSB1c2VCdXR0b248RT4oe1xuICAgICAgICBidXR0b25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgdGFnQnV0dG9uOiB0YWdCdXR0b24sXG4gICAgICAgICAgICBvblByZXNzOiBvblByZXNzID8/IG51bGwsXG4gICAgICAgICAgICBwcmVzc2VkLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlXG4gICAgICAgIH0sIFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZSB9LCBcbiAgICAgICAgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfVxuICAgIH0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vQnV0dG9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxCdXR0b248SFRNTEJ1dHRvbkVsZW1lbnQ+IGRpc2FibGVkPXtmYWxzZX0gZXhjbHVkZT17dW5kZWZpbmVkfSBwcmVzc2VkPXtudWxsfSB0YWdCdXR0b249XCJidXR0b25cIiBvblByZXNzPXtudWxsfSByZW5kZXI9e2luZm8gPT4gKDxidXR0b24gey4uLmluZm8ucHJvcHN9PkJ1dHRvbjwvYnV0dG9uPil9IC8+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VDaGVja2JveCwgVXNlQ2hlY2tib3hQYXJhbWV0ZXJzLCBVc2VDaGVja2JveFJldHVyblR5cGUgfSBmcm9tIFwiLi4vdXNlLWNoZWNrYm94XCI7XG5pbXBvcnQgeyBMYWJlbFBvc2l0aW9uIH0gZnJvbSBcIi4uL3VzZS1sYWJlbFwiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcnRpYWxFeGNlcHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmludGVyZmFjZSBDaGVja2JveFByb3BzQmFzZTxJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlQ2hlY2tib3hQYXJhbWV0ZXJzPExhYmVsUG9zaXRpb24sIEksIEw+LCBcImNoZWNrYm94TGlrZVBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94UGFyYW1ldGVyczxMYWJlbFBvc2l0aW9uLCBJLCBMPiwgXCJjaGVja2JveFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94UGFyYW1ldGVyczxMYWJlbFBvc2l0aW9uLCBJLCBMPiwgXCJsYWJlbFBhcmFtZXRlcnNcIj4ge1xuICAgIHJlZj86IFJlZjxVc2VDaGVja2JveFJldHVyblR5cGU8SSwgTD4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94UHJvcHM8SSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFBhcnRpYWxFeGNlcHQ8Q2hlY2tib3hQcm9wc0Jhc2U8SSwgTD4sIFwidGFnSW5wdXRcIiB8IFwidGFnTGFiZWxcIiB8IFwibGFiZWxQb3NpdGlvblwiIHwgXCJhcmlhTGFiZWxcIiB8IFwiY2hlY2tlZFwiIHwgXCJvbkNoZWNrZWRDaGFuZ2VcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VDaGVja2JveFJldHVyblR5cGU8SSwgTD4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZTxJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQsIEluZm9UeXBlPih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZVByb3BzSW5wdXQsIG1ha2VQcm9wc0xhYmVsIH06IERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIEwsIEluZm9UeXBlPikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogSW5mb1R5cGUpOiBWTm9kZTxhbnk+IHtcblxuICAgICAgICBjb25zdCBpbnB1dFByb3BzID0gKG1ha2VQcm9wc0lucHV0KGluZm8pKVxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5sYWJlbFByb3BzIH0gPSAobWFrZVByb3BzTGFiZWwoaW5mbykpXG4gICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIikge1xuXG4gICAgICAgICAgICAvL2NvbnN0IGlucHV0UHJvcHMgPSBtb2RpZnlJbnB1dFByb3BzKG1ha2VJbnB1dFByb3BzKGluZm8pKTtcbiAgICAgICAgICAgIC8vY29uc3QgeyBjaGlsZHJlbiwgLi4ubGFiZWxQcm9wcyB9ID0gbW9kaWZ5TGFiZWxQcm9wcyhtYWtlTGFiZWxQcm9wcyhpbmZvKSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gY3JlYXRlRWxlbWVudCh0YWdJbnB1dCBhcyBuZXZlciwgaW5wdXRQcm9wcyk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwgYXMgbmV2ZXIsIHsgLi4ubGFiZWxQcm9wcywgY2hpbGRyZW46IDw+e2lucHV0fXtjaGlsZHJlbn08Lz4gfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gY3JlYXRlRWxlbWVudCh0YWdJbnB1dCBhcyBuZXZlciwgaW5wdXRQcm9wcyk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwgYXMgbmV2ZXIsIHsgY2hpbGRyZW4sIC4uLmxhYmVsUHJvcHMgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAge2lucHV0fVxuICAgICAgICAgICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCghIWlucHV0UHJvcHNbXCJhcmlhLWxhYmVsXCJdKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0lucHV0IGFzIG5ldmVyLCBpbnB1dFByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJIGV4dGVuZHMgRWxlbWVudCwgTCBleHRlbmRzIEVsZW1lbnQsIEluZm9UeXBlPiB7XG4gICAgbGFiZWxQb3NpdGlvbjogXCJ3cmFwcGluZ1wiIHwgXCJzZXBhcmF0ZVwiIHwgXCJoaWRkZW5cIixcbiAgICB0YWdJbnB1dDogRWxlbWVudFRvVGFnPEk+LFxuICAgIHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TD4sXG4gICAgbWFrZVByb3BzSW5wdXQ6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST4sXG4gICAgbWFrZVByb3BzTGFiZWw6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TD5cbn1cbi8qXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRSZW5kZXJDaGVja2JveFBhcmFtZXRlcnM8SSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIEwsIFVzZUNoZWNrYm94UmV0dXJuVHlwZTxJLCBMPj4geyB9XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyQ2hlY2tib3g8SSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50Pih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZVByb3BzSW5wdXQsIG1ha2VQcm9wc0xhYmVsIH06IERlZmF1bHRSZW5kZXJDaGVja2JveFBhcmFtZXRlcnM8SSwgTD4pIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZTxJLCBMLCBVc2VDaGVja2JveFJldHVyblR5cGU8SSwgTD4+KHsgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsLCBtYWtlUHJvcHNJbnB1dCwgbWFrZVByb3BzTGFiZWwgfSk7XG59Ki9cblxuZXhwb3J0IGNvbnN0IENoZWNrYm94ID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gQ2hlY2tib3g8SSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgY2hlY2tlZCxcbiAgICBkaXNhYmxlZCxcbiAgICB0YWdMYWJlbCxcbiAgICBsYWJlbFBvc2l0aW9uLFxuICAgIHRhZ0lucHV0LFxuICAgIGFyaWFMYWJlbCxcbiAgICBvbkNoZWNrZWRDaGFuZ2UsXG4gICAgcmVuZGVyXG59OiBDaGVja2JveFByb3BzPEksIEw+LCByZWY6IFJlZjxhbnk+KSB7XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHJlZkVsZW1lbnRJbnB1dFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxJPih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm46IHJlZkVsZW1lbnRMYWJlbFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxMPih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KTtcblxuICAgIGNvbnN0IGNoZWNrYm94ID0gdXNlQ2hlY2tib3g8TGFiZWxQb3NpdGlvbiwgSSwgTD4oe1xuICAgICAgICBjaGVja2JveExpa2VQYXJhbWV0ZXJzOiB7IGNoZWNrZWQ6IGNoZWNrZWQgPz8gZmFsc2UsIGRpc2FibGVkOiBkaXNhYmxlZCA/PyBmYWxzZSB9LFxuICAgICAgICBjaGVja2JveFBhcmFtZXRlcnM6IHsgb25DaGVja2VkQ2hhbmdlIH0sXG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczogeyBhcmlhTGFiZWw6IGFyaWFMYWJlbCwgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsIH0sXG4gICAgICAgIHJlZkVsZW1lbnRJbnB1dFJldHVybixcbiAgICAgICAgcmVmRWxlbWVudExhYmVsUmV0dXJuXG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGNoZWNrYm94KTtcblxuXG4gICAgcmV0dXJuIHJlbmRlcihjaGVja2JveCk7XG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIERlbW9DaGVja2JveCgpIHtcbiAgICBjb25zdCBbY2hlY2tlZCwgc2V0Q2hlY2tlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPENoZWNrYm94PEhUTUxJbnB1dEVsZW1lbnQsIEhUTUxMYWJlbEVsZW1lbnQ+IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIGNoZWNrZWQ9e2NoZWNrZWR9IGRpc2FibGVkPXtmYWxzZX0gb25DaGVja2VkQ2hhbmdlPXsoZSkgPT4gc2V0Q2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKX0gcmVuZGVyPXtcbiAgICAgICAgICAgIGluZm8gPT4gKFxuICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB7Li4uaW5mby5wcm9wc0lucHV0fSAvPjxsYWJlbCB7Li4uaW5mby5wcm9wc0xhYmVsfSAvPlxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHRhZ0lucHV0PVwiaW5wdXRcIlxuICAgICAgICAgICAgdGFnTGFiZWw9XCJsYWJlbFwiXG4gICAgICAgICAgICBhcmlhTGFiZWw9e251bGx9XG4gICAgICAgIC8+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgUmVmLCBSZW5kZXJhYmxlUHJvcHMsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFVzZUNoZWNrYm94UmV0dXJuVHlwZSB9IGZyb20gXCIuLi91c2UtY2hlY2tib3hcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyBDaGVja2JveEdyb3VwQ29udGV4dCwgQ2hlY2tib3hHcm91cEluZm8sIHVzZUNoZWNrYm94R3JvdXAsIHVzZUNoZWNrYm94R3JvdXBDaGlsZCwgVXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVycywgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZSwgVXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIHVzZUNoZWNrYm94R3JvdXBQYXJlbnQsIFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzLCBVc2VDaGVja2JveEdyb3VwUGFyZW50UmV0dXJuVHlwZSwgVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGUgfSBmcm9tIFwiLi4vdXNlLWNoZWNrYm94LWdyb3VwXCI7XG5pbXBvcnQgeyBDaGVja2JveCwgQ2hlY2tib3hQcm9wcywgZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSB9IGZyb20gXCIuL2NoZWNrYm94XCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiwgUGFydGlhbEV4Y2VwdCwgdXNlRGVmYXVsdCB9IGZyb20gXCIuL3V0aWxcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcbi8vdHlwZSBHZXQyPFQsIEsgZXh0ZW5kcyBrZXlvZiBULCBLMiBleHRlbmRzIGtleW9mIFRbS10+ID0gVFtLXVtLMl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tib3hHcm91cFByb3BzQmFzZTxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgQ2hlY2tib3hHcm91cEluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQ+PiBleHRlbmRzXG4gICAgUmVuZGVyYWJsZVByb3BzPHt9PixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQsIE0+LCBcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVyczxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgTT4sIFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnM8UGFyZW50RWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQsIE0+LCBcInNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVyczxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgTT4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzPFBhcmVudEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50LCBNPiwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4ge1xuICAgIHJlZj86IFJlZjxVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgTT4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94R3JvdXBQYXJlbnRQcm9wc0Jhc2U8VENFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4sIFwicHJlc3NQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+LCBcInJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+LCBcInNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+LCBcInRleHRDb250ZW50UGFyYW1ldGVyc1wiPixcbiAgICBPbWl0PEdldDxVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+LCBcImNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnNcIj4sIFwiY2hlY2tib3hJbmZvXCI+IHtcbiAgICAvL3N1YkluZm86IEdldDxVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIEMsIEssIEM+LCBcInN1YkluZm9cIj47XG4gICAgcmVmPzogUmVmPFVzZUNoZWNrYm94R3JvdXBQYXJlbnRSZXR1cm5UeXBlPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94R3JvdXBDaGlsZFByb3BzQmFzZTxUQ0UgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgLy8gR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPENCR1N1YkluZm8sIEssIENCR1N1YkluZm8+LCBcImFzQ2hlY2tib3hcIiwgXCJjaGVja2JveFwiPixcbiAgICAvLyBHZXQyPFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8Q0JHU3ViSW5mbywgSywgQ0JHU3ViSW5mbz4sIFwiYXNDaGVja2JveFwiLCBcImxhYmVsXCI+LFxuICAgIC8vIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxDQkdTdWJJbmZvLCBLLCBDQkdTdWJJbmZvPiwgXCJhc0NoZWNrYm94XCIsIFwiY2hlY2tib3hMaWtlXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4sIFwiY2hlY2tib3hHcm91cENoaWxkXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+LCBcInJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4sIFwic29ydGFibGVDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8VENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+PiwgXCJ0ZXh0Q29udGVudFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8VENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+PiwgXCJwcmVzc1BhcmFtZXRlcnNcIj4ge1xuICAgIC8vc3ViSW5mbzogR2V0PFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBDQkdTdWJJbmZvLCBLLCBDQkdTdWJJbmZvPiwgXCJzdWJJbmZvXCI+O1xuICAgIHJlZj86IFJlZjxVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4+O1xufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwUHJvcHM8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIENoZWNrYm94R3JvdXBJbmZvPFRhYmJhYmxlQ2hpbGRFbGVtZW50Pj4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PENoZWNrYm94R3JvdXBQcm9wc0Jhc2U8UGFyZW50RWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQsIE0+LCBcIm5hdmlnYXRpb25EaXJlY3Rpb25cIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgTT4pOiBWTm9kZTxhbnk+O1xufVxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveEdyb3VwUGFyZW50UHJvcHM8VENFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PENoZWNrYm94R3JvdXBQYXJlbnRQcm9wc0Jhc2U8VENFPiwgXCJpbmRleFwiIHwgXCJnZXRTb3J0VmFsdWVcIiB8IFwiZm9jdXNTZWxmXCI+IHtcbiAgICByZW5kZXIocGFyZW50Q2hlY2tib3hJbmZvOiBVc2VDaGVja2JveEdyb3VwUGFyZW50UmV0dXJuVHlwZTxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+KTogVk5vZGU8YW55Pjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tib3hHcm91cENoaWxkUHJvcHM8VENFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PENoZWNrYm94R3JvdXBDaGlsZFByb3BzQmFzZTxUQ0U+LCBcImluZGV4XCIgfCBcImNoZWNrZWRcIiB8IFwib25DaGFuZ2VGcm9tUGFyZW50XCIgfCBcImdldFNvcnRWYWx1ZVwiIHwgXCJmb2N1c1NlbGZcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4pOiBWTm9kZTxhbnk+O1xufVxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVENFIGV4dGVuZHMgSW5wdXRFbGVtZW50IHwgTGFiZWxFbGVtZW50PiBleHRlbmRzIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlPFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4+IHsgfVxuLy9leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwUGFyYW1ldGVyczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBUQ0UgZXh0ZW5kcyBJbnB1dFR5cGUgfCBMYWJlbFR5cGU+IGV4dGVuZHMgRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGUsIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlPGFueSwgVENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+Pj4ge1xuLy8gICAgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuO1xuLy99XG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGQ8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudCwgVENFIGV4dGVuZHMgSW5wdXRUeXBlIHwgTGFiZWxUeXBlPih7IHRhZ0lucHV0LCB0YWdMYWJlbCwgbGFiZWxQb3NpdGlvbiwgbWFrZVByb3BzSW5wdXQsIG1ha2VQcm9wc0xhYmVsIH06IERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlLCBUQ0U+KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChncm91cEluZm86IFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGU8VENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+Pik6IFZOb2RlPGFueT4ge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZTxJbnB1dFR5cGUsIExhYmVsVHlwZSwgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZTxUQ0UsIENoZWNrYm94R3JvdXBJbmZvPFRDRT4+Pih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZVByb3BzSW5wdXQsIG1ha2VQcm9wc0xhYmVsIH0pKGdyb3VwSW5mbyk7XG4gICAgfVxufSovXG5cbmludGVyZmFjZSBGb288SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PENoZWNrYm94UHJvcHM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBcImNoZWNrZWRcIiB8IFwib25DaGVja2VkQ2hhbmdlXCI+IHtcbiAgICBvbkNoZWNrZWRDaGFuZ2VTdGFydCgpOiB2b2lkO1xuICAgIG9uQ2hlY2tlZENoYW5nZUVuZChleD86IGFueSk6IHZvaWQ7XG59XG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwUGFyZW50PElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgcmVuZGVyLCBkaXNhYmxlZCwgZ2V0RG9jdW1lbnQsIGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQ2hlY2tlZENoYW5nZVN0YXJ0LCBvbkNoZWNrZWRDaGFuZ2VFbmQsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UgfTogRm9vPElucHV0VHlwZSwgTGFiZWxUeXBlPikge1xuICAgIHJldHVybiBmdW5jdGlvbiAocGFyZW50SW5mbzogVXNlQ2hlY2tib3hHcm91cFBhcmVudFJldHVyblR5cGVJbmZvLCBtb2RpZnlDb250cm9sUHJvcHM6IFByb3BNb2RpZmllcjxhbnk+KSB7XG4gICAgICAgIGNvbnN0IHsgY2hlY2tib3hHcm91cFBhcmVudDogeyBjaGVja2VkLCBvblBhcmVudENoZWNrZWRDaGFuZ2UgfSB9ID0gcGFyZW50SW5mbztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxDaGVja2JveDxJbnB1dFR5cGUsIExhYmVsVHlwZT5cbiAgICAgICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9XG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbj17bGFiZWxQb3NpdGlvbn1cbiAgICAgICAgICAgICAgICByZW5kZXI9eyhpbmZvLCBtb2RpZnlJbnB1dFByb3BzLCBtb2RpZnlMYWJlbFByb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXIoaW5mbywgKHByb3BzKSA9PiBtb2RpZnlDb250cm9sUHJvcHMobW9kaWZ5SW5wdXRQcm9wcyhwcm9wcykpLCBtb2RpZnlMYWJlbFByb3BzKVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyKGluZm8sIG1vZGlmeUlucHV0UHJvcHMsIChwcm9wcykgPT4gbW9kaWZ5Q29udHJvbFByb3BzKG1vZGlmeUxhYmVsUHJvcHMocHJvcHMpIGFzIGFueSkgYXMgYW55KVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgdGFnSW5wdXQ9e3RhZ0lucHV0fVxuICAgICAgICAgICAgICAgIHRhZ0xhYmVsPXt0YWdMYWJlbH1cbiAgICAgICAgICAgICAgICBnZXRXaW5kb3c9e2dldFdpbmRvd31cbiAgICAgICAgICAgICAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U9e29uQWN0aXZlRWxlbWVudENoYW5nZX1cbiAgICAgICAgICAgICAgICBvbkNoZWNrZWRDaGFuZ2U9e2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhjZXB0aW9uOiBhbnk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hlY2tlZENoYW5nZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgb25QYXJlbnRDaGVja2VkQ2hhbmdlKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uID0gZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoZWNrZWRDaGFuZ2VFbmQoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICkoKVxuXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICBvbkVsZW1lbnRDaGFuZ2U9e29uRWxlbWVudENoYW5nZX1cbiAgICAgICAgICAgICAgICBvbkZvY3VzZWRDaGFuZ2VkPXtvbkZvY3VzZWRDaGFuZ2VkfVxuICAgICAgICAgICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZD17b25Gb2N1c2VkSW5uZXJDaGFuZ2VkfVxuICAgICAgICAgICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U9e29uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZENoYW5nZWQ9e29uTGFzdEZvY3VzZWRDaGFuZ2VkfVxuICAgICAgICAgICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ9e29uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWR9XG4gICAgICAgICAgICAgICAgb25Nb3VudD17b25Nb3VudH1cbiAgICAgICAgICAgICAgICBvblVubW91bnQ9e29uVW5tb3VudH1cbiAgICAgICAgICAgICAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2U9e29uV2luZG93Rm9jdXNlZENoYW5nZX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cDxJbnB1dFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgY2hpbGRyZW4sIGxhYmVsUG9zaXRpb24sIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcywgdGFnSW5wdXQsIHRhZ0xhYmVsIH06IERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZSwgQywgSz4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUsIExhYmVsVHlwZSwgQywgSz4sIG1vZGlmeUlucHV0UHJvcHM6IFByb3BNb2RpZmllcjxJbnB1dFR5cGU+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxUeXBlPik6IFZOb2RlPGFueT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7ZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSh7IGxhYmVsUG9zaXRpb24sIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcywgdGFnSW5wdXQsIHRhZ0xhYmVsIH0pKGluZm8sIG1vZGlmeUlucHV0UHJvcHMsIG1vZGlmeUxhYmVsUHJvcHMpfVxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufSovXG5cbmNvbnN0IFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQgPSBjcmVhdGVDb250ZXh0PENoZWNrYm94R3JvdXBDb250ZXh0PGFueSwgYW55LCBhbnk+PihudWxsISk7XG5cbmV4cG9ydCBjb25zdCBDaGVja2JveEdyb3VwID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gQ2hlY2tib3hHcm91cDxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgcmVuZGVyLFxuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgY29tcGFyZSxcbiAgICBnZXRJbmRleCxcbiAgICB1bnRhYmJhYmxlLFxuICAgIG5hdmlnYXRlUGFzdEVuZCxcbiAgICBuYXZpZ2F0ZVBhc3RTdGFydCxcbiAgICBwYWdlTmF2aWdhdGlvblNpemUsXG4gICAgY2hpbGRyZW4sXG4gICAgLi4uX3Jlc3Rcbn06IENoZWNrYm94R3JvdXBQcm9wczxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCwgQ2hlY2tib3hHcm91cEluZm88VGFiYmFibGVDaGlsZEVsZW1lbnQ+PiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBpbmZvID0gdXNlQ2hlY2tib3hHcm91cDxQYXJlbnRFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5czogdXNlRGVmYXVsdChcImRpc2FibGVBcnJvd0tleXNcIiwgZGlzYWJsZUFycm93S2V5cyksXG4gICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlSG9tZUVuZEtleXNcIiwgZGlzYWJsZUhvbWVFbmRLZXlzKSxcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZDogbmF2aWdhdGVQYXN0RW5kID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IG5hdmlnYXRlUGFzdFN0YXJ0ID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICAgICAgICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZTogdXNlRGVmYXVsdChcInBhZ2VOYXZpZ2F0aW9uU2l6ZVwiLCBwYWdlTmF2aWdhdGlvblNpemUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgZ2V0SW5kZXg6IHVzZURlZmF1bHQoXCJnZXRJbmRleFwiLCBnZXRJbmRleCkgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IG9uVGFiYmFibGVJbmRleENoYW5nZTogb25UYWJiYWJsZUluZGV4Q2hhbmdlID8/IG51bGwsIHVudGFiYmFibGU6IHVudGFiYmFibGUgPz8gZmFsc2UgfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgY29tcGFyZTogY29tcGFyZSA/PyBudWxsIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBjb2xsYXRvcjogdXNlRGVmYXVsdChcImNvbGxhdG9yXCIsIGNvbGxhdG9yKSxcbiAgICAgICAgICAgIG5vVHlwZWFoZWFkOiB1c2VEZWZhdWx0KFwibm9UeXBlYWhlYWRcIiwgbm9UeXBlYWhlYWQpLFxuICAgICAgICAgICAgdHlwZWFoZWFkVGltZW91dDogdXNlRGVmYXVsdChcInR5cGVhaGVhZFRpbWVvdXRcIiwgdHlwZWFoZWFkVGltZW91dClcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxVc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PlxuICAgICAgICAgICAge3JlbmRlcihpbmZvKX1cbiAgICAgICAgPC9Vc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn0pO1xuXG5leHBvcnQgY29uc3QgQ2hlY2tib3hHcm91cFBhcmVudCA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIENoZWNrYm94R3JvdXBQYXJlbnQ8VENFIGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIsICBpbmRleCwgZm9jdXNTZWxmLCBleGNsdWRlLCBoaWRkZW4sIGdldFRleHQsIG9uUHJlc3NTeW5jLCBnZXRTb3J0VmFsdWUsIC4uLl9yZXN0IH06IENoZWNrYm94R3JvdXBQYXJlbnRQcm9wczxUQ0U+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGNvbnRleHQgPSAodXNlQ29udGV4dChVc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0KSBhcyBDaGVja2JveEdyb3VwQ29udGV4dDxhbnksIFRDRSwgQ2hlY2tib3hHcm91cEluZm88VENFPj4pO1xuXG4gICAgY29uc3QgaW5mbyA9IHVzZUNoZWNrYm94R3JvdXBQYXJlbnQ8VENFPih7XG5cbiAgICAgICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczogeyBjaGVja2JveEluZm86IHsgY2hlY2tib3hDaGlsZFR5cGU6IFwicGFyZW50XCIgfSB9LFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiB7IGdldFNvcnRWYWx1ZSB9LFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZSwgb25QcmVzc1N5bmMsIGZvY3VzU2VsZiB9LFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnM6IHsgZ2V0VGV4dDogdXNlRGVmYXVsdChcImdldFRleHRcIiwgZ2V0VGV4dCkgfVxuICAgIH0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcbn0pXG5cbmV4cG9ydCBjb25zdCBDaGVja2JveEdyb3VwQ2hpbGQgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBDaGVja2JveEdyb3VwQ2hpbGQ8VENFIGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluZGV4LFxuICAgIGV4Y2x1ZGUsXG4gICAgb25QcmVzc1N5bmMsXG4gICAgcmVuZGVyLFxuICAgIGNoZWNrZWQsXG4gICAgb25DaGFuZ2VGcm9tUGFyZW50LFxuICAgIGdldFNvcnRWYWx1ZSxcbiAgICBoaWRkZW4sXG4gICAgZ2V0VGV4dCxcbiAgICBmb2N1c1NlbGYsXG4gICAgLi4uX3Jlc3Rcbn06IENoZWNrYm94R3JvdXBDaGlsZFByb3BzPFRDRT4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgY29udGV4dCA9ICh1c2VDb250ZXh0KFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQpIGFzIENoZWNrYm94R3JvdXBDb250ZXh0PGFueSwgVENFLCBDaGVja2JveEdyb3VwSW5mbzxUQ0U+Pik7XG4gICAgY29uc3QgaW5mbyA9IHVzZUNoZWNrYm94R3JvdXBDaGlsZCh7XG4gICAgICAgIGNoZWNrYm94R3JvdXBDaGlsZDogeyBjaGVja2VkLCBvbkNoYW5nZUZyb21QYXJlbnQgfSxcbiAgICAgICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczoge30sXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogeyBnZXRUZXh0OiB1c2VEZWZhdWx0KFwiZ2V0VGV4dFwiLCBnZXRUZXh0KSB9LFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiB7IGdldFNvcnRWYWx1ZSB9LFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZSwgb25QcmVzc1N5bmMsIGZvY3VzU2VsZiB9XG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gQ2hlY2tib3hHcm91cERlbW8oKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPENoZWNrYm94R3JvdXA8SFRNTERpdkVsZW1lbnQsIEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICAgICAgICBjb2xsYXRvcj17bnVsbH1cbiAgICAgICAgICAgIGRpc2FibGVBcnJvd0tleXM9e2ZhbHNlfVxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzPXtmYWxzZX1cbiAgICAgICAgICAgIHVudGFiYmFibGU9e2ZhbHNlfVxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kPVwid3JhcFwiXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydD1cIndyYXBcIlxuICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbj1cInZlcnRpY2FsXCJcbiAgICAgICAgICAgIG5vVHlwZWFoZWFkPXtmYWxzZX1cbiAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZT17bnVsbH1cbiAgICAgICAgICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZT17MC4xfVxuICAgICAgICAgICAgdHlwZWFoZWFkVGltZW91dD17MTAwMH1cbiAgICAgICAgICAgIGNvbXBhcmU9eyhsaHMsIHJocykgPT4geyByZXR1cm4gbGhzLmluZGV4IC0gcmhzLmluZGV4OyB9fVxuICAgICAgICAgICAgZ2V0SW5kZXg9e3Zub2RlID0+IHZub2RlLnByb3BzLmluZGV4fVxuICAgICAgICAgICAgcmVuZGVyPXtpbmZvID0+XG4gICAgICAgICAgICAgICAgPGRpdiB7Li4uaW5mby5wcm9wc30+XG5cbiAgICAgICAgICAgICAgICA8L2Rpdj59XG4gICAgICAgIC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2hlY2tib3hHcm91cFBhcmVudERlbW8oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZjxVc2VDaGVja2JveFJldHVyblR5cGU8YW55LCBhbnk+PihudWxsKTtcbiAgICByZXR1cm4gKFxuICAgICAgICA8Q2hlY2tib3hHcm91cFBhcmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgaGlkZGVuPXtmYWxzZX1cbiAgICAgICAgICAgIGV4Y2x1ZGU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uUHJlc3NTeW5jPXtudWxsfVxuICAgICAgICAgICAgZm9jdXNTZWxmPXtlID0+IHJlZi5jdXJyZW50Py5jaGVja2JveExpa2VSZXR1cm4uZm9jdXNTZWxmKCl9XG4gICAgICAgICAgICBnZXRTb3J0VmFsdWU9e3JldHVybk51bGx9XG4gICAgICAgICAgICByZW5kZXI9e2kgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDxDaGVja2JveDxIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50PlxuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYUxhYmVsPXtudWxsfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17aS5jaGVja2JveEdyb3VwUGFyZW50UmV0dXJuLmNoZWNrZWR9XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoZWNrZWRDaGFuZ2U9e2kuY2hlY2tib3hHcm91cFBhcmVudFJldHVybi5vblBhcmVudENoZWNrZWRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXI9e2kgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgey4uLmkucHJvcHNJbnB1dH0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCB7Li4uaS5wcm9wc0xhYmVsfT5QYXJlbnQ8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTGFiZWw9XCJsYWJlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdJbnB1dD1cImlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENoZWNrYm94R3JvdXBDaGlsZERlbW8oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xuICAgIGNvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkXSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBcIm1peGVkXCI+KGZhbHNlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWY8VXNlQ2hlY2tib3hSZXR1cm5UeXBlPGFueSwgYW55Pj4obnVsbCk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPENoZWNrYm94R3JvdXBDaGlsZDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgaGlkZGVuPXtmYWxzZX1cbiAgICAgICAgICAgIG9uQ2hhbmdlRnJvbVBhcmVudD17c2V0Q2hlY2tlZH1cbiAgICAgICAgICAgIGV4Y2x1ZGU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIG9uUHJlc3NTeW5jPXtudWxsfVxuICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgIGZvY3VzU2VsZj17ZSA9PiByZWYuY3VycmVudD8uY2hlY2tib3hMaWtlUmV0dXJuLmZvY3VzU2VsZigpfVxuICAgICAgICAgICAgZ2V0U29ydFZhbHVlPXtyZXR1cm5OdWxsfVxuICAgICAgICAgICAgcmVuZGVyPXtpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8Q2hlY2tib3g8SFRNTElucHV0RWxlbWVudCwgSFRNTExhYmVsRWxlbWVudD5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWFMYWJlbD17bnVsbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZj17cmVmfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtmYWxzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoZWNrZWRDaGFuZ2U9e2UgPT4gc2V0Q2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcj17ZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0lucHV0OiBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTGFiZWw6IFwibGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNJbnB1dDogaW5mbyA9PiB1c2VNZXJnZWRQcm9wcyhpbmZvLnByb3BzSW5wdXQsIHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNMYWJlbDogaW5mbyA9PiB1c2VNZXJnZWRQcm9wcyhpbmZvLnByb3BzTGFiZWwsIHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdMYWJlbD1cImxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0lucHV0PVwiaW5wdXRcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VEaWFsb2csIFVzZURpYWxvZ1BhcmFtZXRlcnMsIFVzZURpYWxvZ1JldHVyblR5cGUgfSBmcm9tIFwiLi4vdXNlLWRpYWxvZ1wiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcmVudERlcHRoQ29udGV4dCwgUGFydGlhbEV4Y2VwdCwgdXNlRGVmYXVsdCB9IGZyb20gXCIuL3V0aWxcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuaW50ZXJmYWNlIERpYWxvZ1Byb3BzQmFzZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlRGlhbG9nUGFyYW1ldGVyczxEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQ+LCBcImRpc21pc3NQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VEaWFsb2dQYXJhbWV0ZXJzPERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudD4sIFwiZXNjYXBlRGlzbWlzc1BhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZURpYWxvZ1BhcmFtZXRlcnM8RGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50PiwgXCJsYWJlbFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZURpYWxvZ1BhcmFtZXRlcnM8RGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50PiwgXCJmb2N1c1RyYXBQYXJhbWV0ZXJzXCI+IHtcbiAgICByZWY/OiBSZWY8VXNlRGlhbG9nUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudD4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERpYWxvZ1Byb3BzPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNvdXJjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBEaWFsb2dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PERpYWxvZ1Byb3BzQmFzZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudD4sIFwiYXJpYUxhYmVsXCIgfCBcIm9uQ2xvc2VcIiB8IFwib3BlblwiIHwgXCJmb2N1c1BvcHVwXCI+IHtcblxuICAgIHJlbmRlcihkaWFsb2dJbmZvOiBVc2VEaWFsb2dSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgU291cmNlRWxlbWVudCwgRGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyUG9ydGFsKHsgcG9ydGFsSWQsIGNoaWxkcmVuIH06IHsgcG9ydGFsSWQ6IHN0cmluZywgY2hpbGRyZW46IFZOb2RlIH0pOiBWTm9kZSB7XG4gICAgY29uc3QgcG9ydGFsUmVmID0gdXNlUmVmPEhUTUxFbGVtZW50PihudWxsISk7XG4gICAgcG9ydGFsUmVmLmN1cnJlbnQgPz89IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBvcnRhbElkKSE7XG4gICAgaWYgKHBvcnRhbFJlZi5jdXJyZW50KVxuICAgICAgICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBwb3J0YWxSZWYuY3VycmVudCk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG59XG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJNb2RhbDxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQmFja2Ryb3BFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEluZm9UeXBlPih7IHBvcnRhbElkLCB0YWdGb2N1c0NvbnRhaW5lciwgdGFnQmFja2Ryb3AsIHRhZ0JvZHksIHRhZ0RpYWxvZywgdGFnVGl0bGUsIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyLCBtYWtlUHJvcHNCYWNrZHJvcCwgbWFrZVByb3BzQm9keSwgbWFrZVByb3BzRGlhbG9nLCBtYWtlUHJvcHNUaXRsZSB9OiB7IHBvcnRhbElkOiBzdHJpbmcsIHRhZ0ZvY3VzQ29udGFpbmVyOiBFbGVtZW50VG9UYWc8Rm9jdXNDb250YWluZXJFbGVtZW50PiwgdGFnRGlhbG9nOiBFbGVtZW50VG9UYWc8RGlhbG9nRWxlbWVudD47IHRhZ1RpdGxlOiBFbGVtZW50VG9UYWc8VGl0bGVFbGVtZW50PjsgdGFnQm9keTogRWxlbWVudFRvVGFnPEJvZHlFbGVtZW50PjsgdGFnQmFja2Ryb3A6IEVsZW1lbnRUb1RhZzxCYWNrZHJvcEVsZW1lbnQ+LCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lcjogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCBtYWtlUHJvcHNEaWFsb2c6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RGlhbG9nRWxlbWVudD4sIG1ha2VQcm9wc0JvZHk6IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+LCBtYWtlUHJvcHNUaXRsZTogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+LCBtYWtlUHJvcHNCYWNrZHJvcDogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRpYWxvZ0luZm86IEluZm9UeXBlKTogVk5vZGU8YW55PiB7XG5cbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogdGl0bGVDaGlsZHJlbiwgLi4udGl0bGVQcm9wcyB9ID0gKG1ha2VQcm9wc1RpdGxlKGRpYWxvZ0luZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogYm9keUNoaWxkcmVuLCAuLi5ib2R5UHJvcHMgfSA9IChtYWtlUHJvcHNCb2R5KGRpYWxvZ0luZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogZGlhbG9nQ2hpbGRyZW4sIC4uLmRpYWxvZ1Byb3BzIH0gPSAobWFrZVByb3BzRGlhbG9nKGRpYWxvZ0luZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogYmFja2Ryb3BDaGlsZHJlbiwgLi4uYmFja2Ryb3BQcm9wcyB9ID0gKG1ha2VQcm9wc0JhY2tkcm9wKGRpYWxvZ0luZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogZm9jdXNDb250YWluZXJDaGlsZHJlbiwgLi4uZm9jdXNDb250YWluZXJQcm9wcyB9ID0gKG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyKGRpYWxvZ0luZm8pKTtcblxuICAgICAgICBjb25zdCB0aXRsZSA9IGNyZWF0ZUVsZW1lbnQodGFnVGl0bGUgYXMgbmV2ZXIsIHRpdGxlUHJvcHMsIHRpdGxlQ2hpbGRyZW4pO1xuICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRWxlbWVudCh0YWdCb2R5IGFzIG5ldmVyLCBib2R5UHJvcHMsIGJvZHlDaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IGRpYWxvZyA9IGNyZWF0ZUVsZW1lbnQodGFnRGlhbG9nIGFzIG5ldmVyLCBkaWFsb2dQcm9wcywgZGlhbG9nQ2hpbGRyZW4sIHRpdGxlLCBib2R5KTtcblxuICAgICAgICBjb25zdCBiYWNrZHJvcCA9IGNyZWF0ZUVsZW1lbnQodGFnQmFja2Ryb3AgYXMgbmV2ZXIsIGJhY2tkcm9wUHJvcHMsIGJhY2tkcm9wQ2hpbGRyZW4pO1xuICAgICAgICBjb25zdCBmb2N1c0NvbnRhaW5lciA9IGNyZWF0ZUVsZW1lbnQodGFnRm9jdXNDb250YWluZXIgYXMgbmV2ZXIsIGZvY3VzQ29udGFpbmVyUHJvcHMsIDxkaXY+e2ZvY3VzQ29udGFpbmVyQ2hpbGRyZW59e2RpYWxvZ317YmFja2Ryb3B9PC9kaXY+KTtcblxuICAgICAgICByZXR1cm4gZGVmYXVsdFJlbmRlclBvcnRhbCh7XG4gICAgICAgICAgICBwb3J0YWxJZCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBmb2N1c0NvbnRhaW5lclxuICAgICAgICB9KTtcbiAgICB9XG59Ki9cblxuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHBvcnRhbElkLCB0YWdGb2N1c0NvbnRhaW5lciwgdGFnQmFja2Ryb3AsIHRhZ0JvZHksIHRhZ0RpYWxvZywgdGFnVGl0bGUsIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyLCBtYWtlUHJvcHNCYWNrZHJvcCwgbWFrZVByb3BzQm9keSwgbWFrZVByb3BzRGlhbG9nLCBtYWtlUHJvcHNUaXRsZSB9OiB7IHBvcnRhbElkOiBzdHJpbmcsIHRhZ0ZvY3VzQ29udGFpbmVyOiBFbGVtZW50VG9UYWc8Rm9jdXNDb250YWluZXJFbGVtZW50PiwgdGFnRGlhbG9nOiBFbGVtZW50VG9UYWc8RGlhbG9nRWxlbWVudD47IHRhZ1RpdGxlOiBFbGVtZW50VG9UYWc8VGl0bGVFbGVtZW50PjsgdGFnQm9keTogRWxlbWVudFRvVGFnPEJvZHlFbGVtZW50PjsgdGFnQmFja2Ryb3A6IEVsZW1lbnRUb1RhZzxCYWNrZHJvcEVsZW1lbnQ+LCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lcjogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rm9jdXNDb250YWluZXJFbGVtZW50PiwgbWFrZVByb3BzRGlhbG9nOiAoaW5mbzogVXNlRGlhbG9nUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERpYWxvZ0VsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxEaWFsb2dFbGVtZW50PiwgbWFrZVByb3BzQm9keTogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+LCBtYWtlUHJvcHNUaXRsZTogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50PiwgbWFrZVByb3BzQmFja2Ryb3A6IChpbmZvOiBVc2VEaWFsb2dSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRGlhbG9nRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBkZWZhdWx0UmVuZGVyTW9kYWw8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQsIEJvZHlFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQsIFVzZURpYWxvZ1JldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50Pj4oeyBwb3J0YWxJZCwgdGFnRm9jdXNDb250YWluZXIsIHRhZ0JhY2tkcm9wLCB0YWdCb2R5LCB0YWdEaWFsb2csIHRhZ1RpdGxlLCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lciwgbWFrZVByb3BzQmFja2Ryb3AsIG1ha2VQcm9wc0JvZHksIG1ha2VQcm9wc0RpYWxvZywgbWFrZVByb3BzVGl0bGUgfSk7XG59Ki9cblxuZXhwb3J0IGNvbnN0IERpYWxvZyA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIERpYWxvZzxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBvbkNsb3NlLFxuICAgIG9wZW4sXG4gICAgY2xvc2VPbkJhY2tkcm9wLFxuICAgIGNsb3NlT25Fc2NhcGUsXG4gICAgZm9jdXNPcGVuZXIsXG4gICAgZ2V0V2luZG93LFxuICAgIHBhcmVudERlcHRoLFxuICAgIGZvY3VzUG9wdXAsXG4gICAgYXJpYUxhYmVsLFxuICAgIHJlbmRlclxufTogRGlhbG9nUHJvcHM8Rm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQ+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGRlZmF1bHRQYXJlbnREZXB0aCA9IHVzZUNvbnRleHQoUGFyZW50RGVwdGhDb250ZXh0KTtcbiAgICBsZXQgbXlEZXB0aCA9IChwYXJlbnREZXB0aCA/PyBkZWZhdWx0UGFyZW50RGVwdGgpICsgMTtcblxuICAgIGNvbnN0IGluZm8gPSB1c2VEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQ+KHtcbiAgICAgICAgZGlzbWlzc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGNsb3NlT25CYWNrZHJvcDogY2xvc2VPbkJhY2tkcm9wID8/IHRydWUsXG4gICAgICAgICAgICBjbG9zZU9uRXNjYXBlOiBjbG9zZU9uRXNjYXBlID8/IHRydWUsXG4gICAgICAgICAgICBvbkNsb3NlLFxuICAgICAgICAgICAgb3BlblxuICAgICAgICB9LFxuICAgICAgICBlc2NhcGVEaXNtaXNzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZ2V0V2luZG93OiB1c2VEZWZhdWx0KFwiZ2V0V2luZG93XCIsIGdldFdpbmRvdyksXG4gICAgICAgICAgICBwYXJlbnREZXB0aDogcGFyZW50RGVwdGggPz8gZGVmYXVsdFBhcmVudERlcHRoXG4gICAgICAgIH0sXG4gICAgICAgIGZvY3VzVHJhcFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGZvY3VzT3BlbmVyOiB1c2VEZWZhdWx0KFwiZm9jdXNPcGVuZXJcIiwgZm9jdXNPcGVuZXIpLFxuICAgICAgICAgICAgZm9jdXNQb3B1cFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHsgYXJpYUxhYmVsIH1cbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8UGFyZW50RGVwdGhDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtteURlcHRofT5cbiAgICAgICAgICAgIHtyZW5kZXIoaW5mbyl9XG4gICAgICAgIDwvUGFyZW50RGVwdGhDb250ZXh0LlByb3ZpZGVyPilcblxufSk7XG5cbmZ1bmN0aW9uIGdldFdpbmRvdygpIHsgcmV0dXJuIGdsb2JhbFRoaXMud2luZG93IH1cbmV4cG9ydCBmdW5jdGlvbiBEaWFsb2dEZW1vKCkge1xuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxEaWFsb2c8SFRNTERpdkVsZW1lbnQsIEhUTUxCdXR0b25FbGVtZW50LCBIVE1MRGl2RWxlbWVudCwgSFRNTERpdkVsZW1lbnQ+XG4gICAgICAgICAgICBvcGVuPXtvcGVufVxuICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0T3BlbihmYWxzZSl9XG4gICAgICAgICAgICBjbG9zZU9uQmFja2Ryb3A9e3RydWV9XG4gICAgICAgICAgICBjbG9zZU9uRXNjYXBlPXt0cnVlfVxuICAgICAgICAgICAgZm9jdXNPcGVuZXI9e2UgPT4gZS5mb2N1cygpfVxuICAgICAgICAgICAgcGFyZW50RGVwdGg9ezB9XG4gICAgICAgICAgICBmb2N1c1BvcHVwPXsoZSwgZikgPT4ge2YoKT8uZm9jdXMoKX19XG4gICAgICAgICAgICBhcmlhTGFiZWw9e251bGx9XG4gICAgICAgICAgICByZW5kZXI9e2luZm8gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHsuLi5pbmZvLnByb3BzU291cmNlfT5PcGVuIGRpYWxvZzwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAge2RlZmF1bHRSZW5kZXJQb3J0YWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbElkOiBcInBvcnRhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiA8ZGl2IHsuLi5pbmZvLnByb3BzRm9jdXNDb250YWluZXJ9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHsuLi5pbmZvLnByb3BzRGlhbG9nfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgey4uLmluZm8ucHJvcHNUaXRsZX0+RGlhbG9nIHRpdGxlPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PkRpYWxvZyBib2R5PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldE9wZW4oZmFsc2UpfT5DbG9zZSBkaWFsb2c8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICApXG59XG4iLCJpbXBvcnQgeyBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZURyYXdlciwgVXNlRHJhd2VyUGFyYW1ldGVycywgVXNlRHJhd2VyUmV0dXJuVHlwZSB9IGZyb20gXCIuLi91c2UtZHJhd2VyXCI7XG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyUG9ydGFsIH0gZnJvbSBcIi4vZGlhbG9nXCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiwgUGFyZW50RGVwdGhDb250ZXh0LCBQYXJ0aWFsRXhjZXB0LCB1c2VEZWZhdWx0IH0gZnJvbSBcIi4vdXRpbFwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5pbnRlcmZhY2UgRHJhd2VyUHJvcHNCYXNlPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNvdXJjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBEcmF3ZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VEcmF3ZXJQYXJhbWV0ZXJzPERyYXdlckVsZW1lbnQsIFRpdGxlRWxlbWVudD4sIFwiZGlzbWlzc1BhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZURyYXdlclBhcmFtZXRlcnM8RHJhd2VyRWxlbWVudCwgVGl0bGVFbGVtZW50PiwgXCJlc2NhcGVEaXNtaXNzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlRHJhd2VyUGFyYW1ldGVyczxEcmF3ZXJFbGVtZW50LCBUaXRsZUVsZW1lbnQ+LCBcImxhYmVsUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlRHJhd2VyUGFyYW1ldGVyczxEcmF3ZXJFbGVtZW50LCBUaXRsZUVsZW1lbnQ+LCBcImZvY3VzVHJhcFBhcmFtZXRlcnNcIj4ge1xuICAgIHJlZj86IFJlZjxVc2VEcmF3ZXJSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgU291cmNlRWxlbWVudCwgRHJhd2VyRWxlbWVudCwgVGl0bGVFbGVtZW50Pj47XG4gICAgcmVuZGVyKGRyYXdlckluZm86IFVzZURyYXdlclJldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBEcmF3ZXJFbGVtZW50LCBUaXRsZUVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEcmF3ZXJQcm9wczxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTb3VyY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgRGlhbG9nRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxEcmF3ZXJQcm9wc0Jhc2U8Rm9jdXNDb250YWluZXJFbGVtZW50LCBTb3VyY2VFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQ+LCBcImFyaWFMYWJlbFwiIHwgXCJvbkNsb3NlXCIgfCBcIm9wZW5cIiB8IFwiZm9jdXNQb3B1cFwiPiB7XG5cbiAgICByZW5kZXIoZGlhbG9nSW5mbzogVXNlRHJhd2VyUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIERpYWxvZ0VsZW1lbnQsIFRpdGxlRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuLypcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyRHJhd2VyPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBEcmF3ZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBwb3J0YWxJZCwgdGFnRm9jdXNDb250YWluZXIsIHRhZ0JhY2tkcm9wLCB0YWdCb2R5LCB0YWdEaWFsb2csIHRhZ1RpdGxlLCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lciwgbWFrZVByb3BzQmFja2Ryb3AsIG1ha2VQcm9wc0JvZHksIG1ha2VQcm9wc0RpYWxvZywgbWFrZVByb3BzVGl0bGUgfTogeyBwb3J0YWxJZDogc3RyaW5nLCB0YWdGb2N1c0NvbnRhaW5lcjogRWxlbWVudFRvVGFnPEZvY3VzQ29udGFpbmVyRWxlbWVudD4sIHRhZ0RpYWxvZzogRWxlbWVudFRvVGFnPERyYXdlckVsZW1lbnQ+OyB0YWdUaXRsZTogRWxlbWVudFRvVGFnPFRpdGxlRWxlbWVudD47IHRhZ0JvZHk6IEVsZW1lbnRUb1RhZzxCb2R5RWxlbWVudD47IHRhZ0JhY2tkcm9wOiBFbGVtZW50VG9UYWc8QmFja2Ryb3BFbGVtZW50PiwgbWFrZVByb3BzRm9jdXNDb250YWluZXI6IChpbmZvOiBVc2VEcmF3ZXJSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD4sIG1ha2VQcm9wc0RpYWxvZzogKGluZm86IFVzZURyYXdlclJldHVyblR5cGU8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEcmF3ZXJFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RHJhd2VyRWxlbWVudD4sIG1ha2VQcm9wc0JvZHk6IChpbmZvOiBVc2VEcmF3ZXJSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PiwgbWFrZVByb3BzVGl0bGU6IChpbmZvOiBVc2VEcmF3ZXJSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD4sIG1ha2VQcm9wc0JhY2tkcm9wOiAoaW5mbzogVXNlRHJhd2VyUmV0dXJuVHlwZTxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIERyYXdlckVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlck1vZGFsPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50LCBVc2VEcmF3ZXJSZXR1cm5UeXBlPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRHJhd2VyRWxlbWVudD4+KHsgcG9ydGFsSWQsIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyLCBtYWtlUHJvcHNCYWNrZHJvcCwgbWFrZVByb3BzQm9keSwgbWFrZVByb3BzRGlhbG9nLCBtYWtlUHJvcHNUaXRsZSwgdGFnRm9jdXNDb250YWluZXIsIHRhZ0JhY2tkcm9wLCB0YWdCb2R5LCB0YWdEaWFsb2csIHRhZ1RpdGxlIH0pO1xufSovXG5cbmV4cG9ydCBjb25zdCBEcmF3ZXIgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBEcmF3ZXI8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgU291cmNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIERyYXdlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUaXRsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG5cbiAgICBjbG9zZU9uQmFja2Ryb3AsXG4gICAgY2xvc2VPbkVzY2FwZSxcbiAgICBjbG9zZU9uTG9zdEZvY3VzLFxuICAgIGZvY3VzT3BlbmVyLFxuICAgIGZvY3VzUG9wdXAsXG4gICAgZ2V0V2luZG93LFxuICAgIG9uQ2xvc2UsXG4gICAgb3BlbixcbiAgICBwYXJlbnREZXB0aCxcbiAgICByZW5kZXIsXG4gICAgdHJhcEFjdGl2ZSxcbiAgICBhcmlhTGFiZWwsXG59OiBEcmF3ZXJQcm9wczxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIERyYXdlckVsZW1lbnQsIFRpdGxlRWxlbWVudD4sIHJlZjogUmVmPGFueT4pIHtcbiAgICBjb25zdCBkZWZhdWx0UGFyZW50RGVwdGggPSB1c2VDb250ZXh0KFBhcmVudERlcHRoQ29udGV4dCk7XG4gICAgbGV0IG15RGVwdGggPSAocGFyZW50RGVwdGggPz8gZGVmYXVsdFBhcmVudERlcHRoKSArIDE7XG4gICAgXG4gICAgY29uc3QgaW5mbyA9IHVzZURyYXdlcjxGb2N1c0NvbnRhaW5lckVsZW1lbnQsIFNvdXJjZUVsZW1lbnQsIERyYXdlckVsZW1lbnQsIFRpdGxlRWxlbWVudD4oe1xuICAgICAgICBkaXNtaXNzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY2xvc2VPbkJhY2tkcm9wOiBjbG9zZU9uQmFja2Ryb3AgPz8gdHJ1ZSxcbiAgICAgICAgICAgIGNsb3NlT25Fc2NhcGU6IGNsb3NlT25Fc2NhcGUgPz8gdHJ1ZSxcbiAgICAgICAgICAgIGNsb3NlT25Mb3N0Rm9jdXM6IGNsb3NlT25Mb3N0Rm9jdXMgPz8gdHJ1ZSxcbiAgICAgICAgICAgIG9uQ2xvc2UsXG4gICAgICAgICAgICBvcGVuXG4gICAgICAgIH0sXG4gICAgICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBnZXRXaW5kb3c6IHVzZURlZmF1bHQoXCJnZXRXaW5kb3dcIiwgZ2V0V2luZG93KSxcbiAgICAgICAgICAgIHBhcmVudERlcHRoOiBwYXJlbnREZXB0aCA/PyBkZWZhdWx0UGFyZW50RGVwdGhcbiAgICAgICAgfSxcbiAgICAgICAgZm9jdXNUcmFwUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZm9jdXNPcGVuZXI6IHVzZURlZmF1bHQoXCJmb2N1c09wZW5lclwiLCBmb2N1c09wZW5lciksXG4gICAgICAgICAgICBmb2N1c1BvcHVwLFxuICAgICAgICAgICAgdHJhcEFjdGl2ZTogdHJhcEFjdGl2ZSA/PyBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHsgYXJpYUxhYmVsIH1cbiAgICB9KTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcblxufSlcblxuZXhwb3J0IGZ1bmN0aW9uIERyYXdlckRlbW8oKSB7XG4gICAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPERyYXdlcjxIVE1MRGl2RWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnQsIEhUTUxEaXZFbGVtZW50LCBIVE1MRGl2RWxlbWVudD5cbiAgICAgICAgICAgIG9wZW49e29wZW59XG4gICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRPcGVuKGZhbHNlKX1cbiAgICAgICAgICAgIGNsb3NlT25CYWNrZHJvcD17dHJ1ZX1cbiAgICAgICAgICAgIGNsb3NlT25Fc2NhcGU9e3RydWV9XG4gICAgICAgICAgICBmb2N1c09wZW5lcj17ZSA9PiBlLmZvY3VzKCl9XG4gICAgICAgICAgICBwYXJlbnREZXB0aD17MH1cbiAgICAgICAgICAgIGNsb3NlT25Mb3N0Rm9jdXM9e3RydWV9XG4gICAgICAgICAgICB0cmFwQWN0aXZlPXt0cnVlfVxuICAgICAgICAgICAgZm9jdXNQb3B1cD17KGUsIGYpID0+IGYoKT8uZm9jdXMoKX1cbiAgICAgICAgICAgIGFyaWFMYWJlbD17bnVsbH1cbiAgICAgICAgICAgIHJlbmRlcj17aW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB7Li4uaW5mby5wcm9wc1NvdXJjZX0+T3BlbiBkcmF3ZXI8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtkZWZhdWx0UmVuZGVyUG9ydGFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxJZDogXCJwb3J0YWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogPGRpdiB7Li4uaW5mby5wcm9wc0ZvY3VzQ29udGFpbmVyfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiB7Li4uaW5mby5wcm9wc0RyYXdlcn0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHsuLi5pbmZvLnByb3BzVGl0bGV9PkRyYXdlciB0aXRsZTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5EcmF3ZXIgYm9keTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRPcGVuKGZhbHNlKX0+Q2xvc2UgZHJhd2VyPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEdyaWRDaGlsZENlbGxJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBUYWJsZUNlbGxJbmZvIH0gZnJvbSBcIi4uL3VzZS10YWJsZVwiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyBHcmlkbGlzdENlbGxJbmZvLCBHcmlkbGlzdFJvd0luZm8sIHVzZUdyaWRsaXN0LCB1c2VHcmlkbGlzdENlbGwsIFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnMsIFVzZUdyaWRsaXN0Q2VsbFJldHVyblR5cGUsIFVzZUdyaWRsaXN0Q29udGV4dCwgVXNlR3JpZGxpc3RQYXJhbWV0ZXJzLCBVc2VHcmlkbGlzdFJldHVyblR5cGUsIHVzZUdyaWRsaXN0Um93LCBVc2VHcmlkbGlzdFJvd0NvbnRleHQsIFVzZUdyaWRsaXN0Um93UGFyYW1ldGVycywgVXNlR3JpZGxpc3RSb3dSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL3VzZS1ncmlkbGlzdFwiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcnRpYWxFeGNlcHQsIHVzZURlZmF1bHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcblxuaW50ZXJmYWNlIEdyaWRsaXN0UHJvcHNCYXNlPEdyaWRsaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRsaXN0Um93SW5mbzxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88R3JpZGxpc3RDZWxsRWxlbWVudD4+IGV4dGVuZHNcbiAgICBHZXQ8VXNlR3JpZGxpc3RQYXJhbWV0ZXJzPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJNPiwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlR3JpZGxpc3RQYXJhbWV0ZXJzPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJNPiwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVyczxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTT4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVyczxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTT4sIFwiZ3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VHcmlkbGlzdFBhcmFtZXRlcnM8R3JpZGxpc3RFbGVtZW50LCBHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIExhYmVsRWxlbWVudCwgUk0+LCBcInJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVyczxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTT4sIFwic29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0UGFyYW1ldGVyczxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTT4sIFwibGFiZWxQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VHcmlkbGlzdFBhcmFtZXRlcnM8R3JpZGxpc3RFbGVtZW50LCBHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIExhYmVsRWxlbWVudCwgUk0+LCBcImdyaWRsaXN0UGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZUdyaWRsaXN0UmV0dXJuVHlwZTxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTSwgQ00+Pjtcbn1cblxuaW50ZXJmYWNlIEdyaWRsaXN0Um93UHJvcHNCYXNlPEdyaWRsaXN0Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRsaXN0Um93SW5mbzxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88R3JpZGxpc3RDZWxsRWxlbWVudD4+IGV4dGVuZHNcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwiYXNDaGlsZFJvd1BhcmFtZXRlcnNcIiwgXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDI8VXNlR3JpZGxpc3RSb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJhc0NoaWxkUm93UGFyYW1ldGVyc1wiLCBcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQyPFVzZUdyaWRsaXN0Um93UGFyYW1ldGVyczxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwiYXNDaGlsZFJvd1BhcmFtZXRlcnNcIiwgXCJ0ZXh0Q29udGVudFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+LCBcImFzQ2hpbGRSb3dQYXJhbWV0ZXJzXCIsIFwicm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+LCBcImFzQ2hpbGRSb3dQYXJhbWV0ZXJzXCIsIFwic29ydGFibGVDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+LCBcImFzUGFyZW50Um93UGFyYW1ldGVyc1wiLCBcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDI8VXNlR3JpZGxpc3RSb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJhc1BhcmVudFJvd1BhcmFtZXRlcnNcIiwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+LCBcImFzUGFyZW50Um93UGFyYW1ldGVyc1wiLCBcInR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDI8VXNlR3JpZGxpc3RSb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJhc0NoaWxkUm93UGFyYW1ldGVyc1wiLCBcImdyaWRsaXN0Um93UGFyYW1ldGVyc1wiPiB7XG4gICAgLy8gICAgc3ViSW5mbzogR2V0MjxVc2VHcmlkbGlzdFJvd1BhcmFtZXRlcnM8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+LCBcImFzQ2hpbGRSb3dQYXJhbWV0ZXJzXCIsIFwiY29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnNcIj47XG4gICAgcmVmPzogUmVmPFVzZUdyaWRsaXN0Um93UmV0dXJuVHlwZTxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4+O1xufVxuXG5pbnRlcmZhY2UgR3JpZGxpc3RDaGlsZFByb3BzQmFzZTxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPENlbGxFbGVtZW50Pj4gZXh0ZW5kc1xuICAgIEdldDxVc2VHcmlkbGlzdENlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50LCBNPiwgXCJncmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VHcmlkbGlzdENlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50LCBNPiwgXCJ0ZXh0Q29udGVudFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIE0+LCBcInByZXNzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlR3JpZGxpc3RDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgTT4sIFwicm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIE0+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4ge1xuICAgIHJlZj86IFJlZjxVc2VHcmlkbGlzdENlbGxSZXR1cm5UeXBlPENlbGxFbGVtZW50LCBNPj47XG4gICAgLy8gICAgc3ViSW5mbzogR2V0PFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIE0+LCBcImNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyc1wiPjtcbn1cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBHcmlkbGlzdFByb3BzPEdyaWRsaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRsaXN0Um93SW5mbzxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88R3JpZGxpc3RDZWxsRWxlbWVudD4+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxHcmlkbGlzdFByb3BzQmFzZTxHcmlkbGlzdEVsZW1lbnQsIEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBSTSwgQ00+LCBcInNlbGVjdGlvbkxpbWl0XCIgfCBcImdyb3VwaW5nVHlwZVwiIHwgXCJhcmlhTGFiZWxcIiB8IFwic2VsZWN0ZWRJbmRleFwiPiB7XG4gICAgLy9yZWY/OiBSZWY8VXNlR3JpZGxpc3RSZXR1cm5UeXBlPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBMYWJlbEVsZW1lbnQsIE0+PjtcbiAgICByZW5kZXIoaW5mbzogVXNlR3JpZGxpc3RSZXR1cm5UeXBlPEdyaWRsaXN0RWxlbWVudCwgR3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJNLCBDTT4pOiBWTm9kZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHcmlkbGlzdFJvd1Byb3BzPEdyaWRsaXN0Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIEdyaWRsaXN0Um93SW5mbzxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88R3JpZGxpc3RDZWxsRWxlbWVudD4+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxHcmlkbGlzdFJvd1Byb3BzQmFzZTxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwiaW5kZXhcIiB8IFwiYXJpYVByb3BOYW1lXCI+IHtcbiAgICAvL3N1YkluZm86IEdldDI8VXNlR3JpZGxpc3RSb3dQYXJhbWV0ZXJzPEdyaWRsaXN0Um93RWxlbWVudCwgR3JpZGxpc3RDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJhc0NoaWxkUm93UGFyYW1ldGVyc1wiLCBcImNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzXCI+O1xuICAgIC8vcmVmPzogUmVmPFVzZUdyaWRsaXN0Um93UmV0dXJuVHlwZTxHcmlkbGlzdFJvd0VsZW1lbnQsIEdyaWRsaXN0Q2VsbEVsZW1lbnQsIFJNLCBDTT4+O1xuICAgIHJlbmRlcihpbmZvOiBVc2VHcmlkbGlzdFJvd1JldHVyblR5cGU8R3JpZGxpc3RSb3dFbGVtZW50LCBHcmlkbGlzdENlbGxFbGVtZW50LCBSTSwgQ00+KTogVk5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JpZGxpc3RDaGlsZFByb3BzPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIFBhcnRpYWxFeGNlcHQ8R3JpZGxpc3RDaGlsZFByb3BzQmFzZTxDZWxsRWxlbWVudCwgTT4sICBcImluZGV4XCIgfCBcImZvY3VzU2VsZlwiPiB7XG4gICAgLy9yZWY/OiBSZWY8VXNlR3JpZGxpc3RDZWxsUmV0dXJuVHlwZTxDZWxsRWxlbWVudCwgTT4+O1xuICAgIC8vc3ViSW5mbzogR2V0PFVzZUdyaWRsaXN0Q2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIE0+LCBcImNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyc1wiPjtcbiAgICByZW5kZXIoaW5mbzogVXNlR3JpZGxpc3RDZWxsUmV0dXJuVHlwZTxDZWxsRWxlbWVudCwgTT4pOiBWTm9kZTtcbn1cblxuLy9jb25zdCBMb2NhdGlvbkluZGV4Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoMCk7XG5cbi8vY29uc3QgU2V0TWFuZ2xlcnNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDwobTogKG46IG51bWJlcikgPT4gbnVtYmVyLCBkOiAobjogbnVtYmVyKSA9PiBudW1iZXIpID0+IHZvaWQ+KG51bGwhKTtcbi8vY29uc3QgR3JpZGxpc3RTZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlR3JpZGxpc3RTZWN0aW9uPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+PihudWxsISk7XG5jb25zdCBHcmlkbGlzdENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUdyaWRsaXN0Q29udGV4dDxhbnksIGFueSwgYW55LCBhbnksIGFueT4+KG51bGwhKTtcbmNvbnN0IEdyaWRsaXN0Um93Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlR3JpZGxpc3RSb3dDb250ZXh0PGFueSwgYW55LCBhbnk+PihudWxsISk7XG5cbi8qXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckdyaWRsaXN0PEdyaWRsaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgR3JpZGxpc3RSb3dJbmZvPFJvd0VsZW1lbnQ+Pih7IHRhZ0dyaWRsaXN0LCBtYWtlUHJvcHNHcmlkbGlzdCB9OiB7IHRhZ0dyaWRsaXN0OiBFbGVtZW50VG9UYWc8R3JpZGxpc3RFbGVtZW50PiwgbWFrZVByb3BzR3JpZGxpc3Q6IChpbmZvOiBVc2VHcmlkbGlzdFJldHVyblR5cGU8R3JpZGxpc3RFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcmlkbGlzdEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUdyaWRsaXN0UmV0dXJuVHlwZTxHcmlkbGlzdEVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTT4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnR3JpZGxpc3QgYXMgbmV2ZXIsIChtYWtlUHJvcHNHcmlkbGlzdChpbmZvKSkpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyR3JpZGxpc3RTZWN0aW9uPEdyaWRsaXN0U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDUiwgQ0MsIEtSIGV4dGVuZHMgc3RyaW5nPih7IHRhZ0dyaWRsaXN0U2VjdGlvbiwgbWFrZVByb3BzR3JpZGxpc3RTZWN0aW9uIH06IHsgdGFnR3JpZGxpc3RTZWN0aW9uOiBFbGVtZW50VG9UYWc8R3JpZGxpc3RTZWN0aW9uRWxlbWVudD4sIG1ha2VQcm9wc0dyaWRsaXN0U2VjdGlvbjogKGluZm86IFVzZUdyaWRsaXN0U2VjdGlvblJldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIENSLCBDQywgS1I+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcmlkbGlzdFNlY3Rpb25FbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VHcmlkbGlzdFNlY3Rpb25SZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDUiwgQ0MsIEtSPiwgbW9kaWZ5UHJvcHNHcmlkbGlzdFNlY3Rpb246IFByb3BNb2RpZmllcjxHcmlkbGlzdFNlY3Rpb25FbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdHcmlkbGlzdFNlY3Rpb24gYXMgbmV2ZXIsIG1vZGlmeVByb3BzR3JpZGxpc3RTZWN0aW9uKG1ha2VQcm9wc0dyaWRsaXN0U2VjdGlvbihpbmZvKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJHcmlkbGlzdEhlYWQ8R3JpZGxpc3RIZWFkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnR3JpZGxpc3RIZWFkLCBtYWtlUHJvcHNHcmlkbGlzdEhlYWQgfTogeyB0YWdHcmlkbGlzdEhlYWQ6IEVsZW1lbnRUb1RhZzxHcmlkbGlzdEhlYWRFbGVtZW50PiwgbWFrZVByb3BzR3JpZGxpc3RIZWFkOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcmlkbGlzdEhlYWRFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnR3JpZGxpc3RIZWFkIGFzIG5ldmVyLCAobWFrZVByb3BzR3JpZGxpc3RIZWFkKCkpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyR3JpZGxpc3RGb290PEdyaWRsaXN0Rm9vdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ0dyaWRsaXN0Rm9vdCwgbWFrZVByb3BzR3JpZGxpc3RGb290IH06IHsgdGFnR3JpZGxpc3RGb290OiBFbGVtZW50VG9UYWc8R3JpZGxpc3RGb290RWxlbWVudD4sIG1ha2VQcm9wc0dyaWRsaXN0Rm9vdDogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R3JpZGxpc3RGb290RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0dyaWRsaXN0Rm9vdCBhcyBuZXZlciwgKG1ha2VQcm9wc0dyaWRsaXN0Rm9vdCgpKSk7XG4gICAgfVxufSovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyR3JpZGxpc3RSb3c8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBHcmlkbGlzdFJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIEdyaWRsaXN0Q2VsbEluZm88Q2VsbEVsZW1lbnQ+Pih7IHRhZ0dyaWRsaXN0Um93LCBtYWtlUHJvcHNHcmlkbGlzdFJvdyB9OiB7IHRhZ0dyaWRsaXN0Um93OiBFbGVtZW50VG9UYWc8Um93RWxlbWVudD4sIG1ha2VQcm9wc0dyaWRsaXN0Um93OiAoaW5mbzogVXNlR3JpZGxpc3RSb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VHcmlkbGlzdFJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnR3JpZGxpc3RSb3cgYXMgbmV2ZXIsIChtYWtlUHJvcHNHcmlkbGlzdFJvdyhpbmZvKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJHcmlkbGlzdENoaWxkPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ00gZXh0ZW5kcyBHcmlkbGlzdENlbGxJbmZvPENlbGxFbGVtZW50Pj4oeyB0YWdHcmlkbGlzdENoaWxkLCBtYWtlUHJvcHNHcmlkbGlzdENoaWxkIH06IHsgdGFnR3JpZGxpc3RDaGlsZDogRWxlbWVudFRvVGFnPENlbGxFbGVtZW50PiwgbWFrZVByb3BzR3JpZGxpc3RDaGlsZDogKGluZm86IFVzZUdyaWRsaXN0Q2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQsIENNPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUdyaWRsaXN0Q2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQsIENNPikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdHcmlkbGlzdENoaWxkIGFzIG5ldmVyLCAobWFrZVByb3BzR3JpZGxpc3RDaGlsZChpbmZvKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IEdyaWRsaXN0ID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gR3JpZGxpc3RVPEdyaWRsaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIGdyb3VwaW5nVHlwZSxcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgbmF2aWdhdGVQYXN0RW5kLFxuICAgIG5hdmlnYXRlUGFzdFN0YXJ0LFxuICAgIHNldFNlbGVjdGVkSW5kZXgsXG4gICAgcGFnZU5hdmlnYXRpb25TaXplLFxuICAgIHNlbGVjdGlvbkxpbWl0LFxuICAgIHVudGFiYmFibGUsXG4gICAgY29tcGFyZSxcbiAgICBnZXRJbmRleCxcbiAgICBvblRhYmJhYmxlQ29sdW1uQ2hhbmdlLFxuICAgIGFyaWFMYWJlbCxcbiAgICByZW5kZXJcbn06IEdyaWRsaXN0UHJvcHM8R3JpZGxpc3RFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsZW1lbnQsIExhYmVsRWxlbWVudCwgR3JpZGxpc3RSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxlbWVudD4sIEdyaWRsaXN0Q2VsbEluZm88Q2VsbGVtZW50Pj4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgaW5mbyA9IHVzZUdyaWRsaXN0PEdyaWRsaXN0RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbGVtZW50LCBMYWJlbEVsZW1lbnQsIEdyaWRsaXN0Um93SW5mbzxSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCBHcmlkbGlzdENlbGxJbmZvPENlbGxlbWVudD4+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGRpc2FibGVBcnJvd0tleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlQXJyb3dLZXlzXCIsIGRpc2FibGVBcnJvd0tleXMpLFxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUhvbWVFbmRLZXlzXCIsIGRpc2FibGVIb21lRW5kS2V5cyksXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RFbmQ6IChuYXZpZ2F0ZVBhc3RFbmQgPz8gXCJ3cmFwXCIpLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IChuYXZpZ2F0ZVBhc3RTdGFydCA/PyBcIndyYXBcIiksXG4gICAgICAgICAgICBwYWdlTmF2aWdhdGlvblNpemU6IHVzZURlZmF1bHQoXCJwYWdlTmF2aWdhdGlvblNpemVcIiwgcGFnZU5hdmlnYXRpb25TaXplKSxcbiAgICAgICAgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IG9uVGFiYmFibGVJbmRleENoYW5nZSA/PyBudWxsLFxuICAgICAgICAgICAgdW50YWJiYWJsZTogdW50YWJiYWJsZSA/PyBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY29sbGF0b3I6IHVzZURlZmF1bHQoXCJjb2xsYXRvclwiLCBjb2xsYXRvciksXG4gICAgICAgICAgICBub1R5cGVhaGVhZDogdXNlRGVmYXVsdChcIm5vVHlwZWFoZWFkXCIsIG5vVHlwZWFoZWFkKSxcbiAgICAgICAgICAgIHR5cGVhaGVhZFRpbWVvdXQ6IHVzZURlZmF1bHQoXCJ0eXBlYWhlYWRUaW1lb3V0XCIsIHR5cGVhaGVhZFRpbWVvdXQpLFxuICAgICAgICB9LFxuICAgICAgICAvKnNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGluaXRpYWxseVNlbGVjdGVkSW5kZXg6IGluaXRpYWxseVNlbGVjdGVkSW5kZXggPz8gbnVsbCxcbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXg6IHNldFNlbGVjdGVkSW5kZXggPz8gbnVsbFxuICAgICAgICB9LCovXG4gICAgICAgIGdyaWRsaXN0UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgc2VsZWN0aW9uTGltaXQsXG4gICAgICAgICAgICBncm91cGluZ1R5cGUsXG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgc2V0U2VsZWN0ZWRJbmRleDogc2V0U2VsZWN0ZWRJbmRleCA/PyBub29wXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25UYWJiYWJsZUNvbHVtbkNoYW5nZTogb25UYWJiYWJsZUNvbHVtbkNoYW5nZSA/PyBub29wXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgYXJpYUxhYmVsXG4gICAgICAgIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGdldEluZGV4OiB1c2VEZWZhdWx0KFwiZ2V0SW5kZXhcIiwgZ2V0SW5kZXgpXG4gICAgICAgIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBjb21wYXJlOiBjb21wYXJlID8/IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxHcmlkbGlzdENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2luZm8uY29udGV4dH0+XG4gICAgICAgICAgICB7cmVuZGVyKGluZm8pfVxuICAgICAgICA8L0dyaWRsaXN0Q29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59KVxuXG5mdW5jdGlvbiBub29wKCkgeyB9XG5cbi8qXG5leHBvcnQgY29uc3QgR3JpZGxpc3RTZWN0aW9uID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gR3JpZGxpc3RTZWN0aW9uVTxTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDUiA9IHVuZGVmaW5lZCwgQ0MgPSB1bmRlZmluZWQsIEtSIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KHsgcmVuZGVyLCBjb21wYXJlUm93cywgaW5kZXggfTogR3JpZGxpc3RTZWN0aW9uUHJvcHM8U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudCwgQ1IsIENDLCBLUj4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgeyB1c2VHcmlkbGlzdFNlY3Rpb25Qcm9wcywgLi4uc2VjdGlvbkluZm8gfSA9IHVzZUNvbnRleHQoR3JpZGxpc3RTZWN0aW9uQ29udGV4dCkvLyh7IGNvbXBhcmVSb3dzIH0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gc2VjdGlvbkluZm8pO1xuICAgIHJldHVybiA8TG9jYXRpb25JbmRleENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2luZGV4fT57cmVuZGVyKHNlY3Rpb25JbmZvLCB1c2VHcmlkbGlzdFNlY3Rpb25Qcm9wcyl9PC9Mb2NhdGlvbkluZGV4Q29udGV4dC5Qcm92aWRlcj5cbn0pKi9cblxuZXhwb3J0IGNvbnN0IEdyaWRsaXN0Um93ID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gR3JpZGxpc3RSb3dVPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgaW5kZXgsXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgYXJpYVByb3BOYW1lLFxuICAgIGRpc2FibGVkLFxuICAgIGhpZGRlbixcbiAgICBuYXZpZ2F0ZVBhc3RFbmQsXG4gICAgbmF2aWdhdGVQYXN0U3RhcnQsXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIHNlbGVjdGVkLFxuICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICB1bnRhYmJhYmxlLFxuICAgIGdldFNvcnRWYWx1ZSxcbiAgICBnZXRUZXh0LFxuICAgIHJlbmRlclxufTogR3JpZGxpc3RSb3dQcm9wczxSb3dFbGVtZW50LCBDZWxsZW1lbnQsIEdyaWRsaXN0Um93SW5mbzxSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCBHcmlkbGlzdENlbGxJbmZvPENlbGxlbWVudD4+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGNvbnRleHQgPSAodXNlQ29udGV4dChHcmlkbGlzdENvbnRleHQpIGFzIFVzZUdyaWRsaXN0Q29udGV4dDxhbnksIFJvd0VsZW1lbnQsIENlbGxlbWVudCwgR3JpZGxpc3RSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxlbWVudD4sIEdyaWRsaXN0Q2VsbEluZm88Q2VsbGVtZW50Pj4pO1xuICAgIGNvbnN0IGluZm8gPSB1c2VHcmlkbGlzdFJvdzxSb3dFbGVtZW50LCBDZWxsZW1lbnQsIEdyaWRsaXN0Um93SW5mbzxSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCBHcmlkbGlzdENlbGxJbmZvPENlbGxlbWVudD4+KHtcbiAgICAgICAgYXNDaGlsZFJvd1BhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgICAgICBncmlkbGlzdFJvd1BhcmFtZXRlcnM6IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkID8/IG51bGwgfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH0sXG4gICAgICAgICAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVyczogeyBnZXRTb3J0VmFsdWUgfSxcbiAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczogeyBkaXNhYmxlZDogZGlzYWJsZWQgPz8gZmFsc2UsIGFyaWFQcm9wTmFtZSwgc2VsZWN0aW9uTW9kZTogdXNlRGVmYXVsdChcInNlbGVjdGlvbk1vZGVcIiwgc2VsZWN0aW9uTW9kZSkgfSxcbiAgICAgICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogeyBnZXRUZXh0OiB1c2VEZWZhdWx0KFwiZ2V0VGV4dFwiLCBnZXRUZXh0KSB9XG4gICAgICAgIH0sXG4gICAgICAgIGFzUGFyZW50Um93UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUFycm93S2V5c1wiLCBkaXNhYmxlQXJyb3dLZXlzKSxcbiAgICAgICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlSG9tZUVuZEtleXNcIiwgZGlzYWJsZUhvbWVFbmRLZXlzKSxcblxuICAgICAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZDogbmF2aWdhdGVQYXN0RW5kID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgICAgIG5hdmlnYXRlUGFzdFN0YXJ0OiBuYXZpZ2F0ZVBhc3RTdGFydCA/PyBcIndyYXBcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZTogb25UYWJiYWJsZUluZGV4Q2hhbmdlID8/IG51bGwsXG4gICAgICAgICAgICAgICAgdW50YWJiYWJsZTogdW50YWJiYWJsZSA/PyBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIGNvbGxhdG9yOiB1c2VEZWZhdWx0KFwiY29sbGF0b3JcIiwgY29sbGF0b3IpLFxuICAgICAgICAgICAgICAgIG5vVHlwZWFoZWFkOiB1c2VEZWZhdWx0KFwibm9UeXBlYWhlYWRcIiwgbm9UeXBlYWhlYWQpLFxuICAgICAgICAgICAgICAgIHR5cGVhaGVhZFRpbWVvdXQ6IHVzZURlZmF1bHQoXCJ0eXBlYWhlYWRUaW1lb3V0XCIsIHR5cGVhaGVhZFRpbWVvdXQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGdyaWRsaXN0Um93Q29udGV4dCxcbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG5cbiAgICByZXR1cm4gPEdyaWRsaXN0Um93Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17aW5mby5jb250ZXh0fT57cmVuZGVyKGluZm8pfTwvR3JpZGxpc3RSb3dDb250ZXh0LlByb3ZpZGVyPlxufSlcblxuZXhwb3J0IGNvbnN0IEdyaWRsaXN0Q2hpbGQgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBHcmlkbGlzdENoaWxkPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluZGV4LFxuICAgIGNvbFNwYW4sXG4gICAgZXhjbHVkZSxcbiAgICBmb2N1c1NlbGYsXG4gICAgaGlkZGVuLFxuICAgIG9uUHJlc3NTeW5jLFxuICAgIGdldFRleHQsXG4gICAgcmVuZGVyLFxuXG59OiBHcmlkbGlzdENoaWxkUHJvcHM8Q2VsbEVsZW1lbnQsIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKHVzZUNvbnRleHQoR3JpZGxpc3RSb3dDb250ZXh0KSBhcyBVc2VHcmlkbGlzdFJvd0NvbnRleHQ8YW55LCBDZWxsRWxlbWVudCwgR3JpZENoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pik7XG4gICAgY29uc3QgaW5mbyA9IHVzZUdyaWRsaXN0Q2VsbDxDZWxsRWxlbWVudCwgR3JpZENoaWxkQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pih7XG4gICAgICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczoge30sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM6IHsgY29sU3BhbjogY29sU3BhbiA/PyAxIH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczogeyBleGNsdWRlLCBmb2N1c1NlbGYsIG9uUHJlc3NTeW5jIH0sXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogeyBnZXRUZXh0OiB1c2VEZWZhdWx0KFwiZ2V0VGV4dFwiLCBnZXRUZXh0KSB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH1cbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG5cbiAgICByZXR1cm4gcmVuZGVyKGluZm8pO1xufSk7XG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQge1xuICAgIENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0LCBQYXNzaXZlU3RhdGVVcGRhdGVyLCB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uLFxuICAgIHVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIFVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGUsXG4gICAgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgVXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGUsIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm8sIHVzZU1lcmdlZFByb3BzLCB1c2VTaW5nbGVTZWxlY3Rpb25EZWNsYXJhdGl2ZSwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZU9iamVjdFxufSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgRXZlbnREZXRhaWwsIFByZWZpY2VzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUxhYmVsU3ludGhldGljLCBVc2VMYWJlbFN5bnRoZXRpY1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcblxuZXhwb3J0IHR5cGUgTGlzdGJveFNpbmdsZVNlbGVjdEV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSB7IFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogbnVtYmVyIH0gfSAmIFBpY2s8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPiwgXCJ0YXJnZXRcIiB8IFwiY3VycmVudFRhcmdldFwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94Q29udGV4dDxMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQ+PiBleHRlbmRzIENvbXBsZXRlTGlzdE5hdmlnYXRpb25Db250ZXh0PExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIE0+IHtcbiAgICBsaXN0Ym94Q29udGV4dDogeyBzZWxlY3Rpb25MaW1pdDogXCJzaW5nbGVcIiB8IFwibXVsdGlcIiB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFBhcmFtZXRlcnM8TGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBNPiwgXCJzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzXCI+IHtcbiAgICBsYWJlbFBhcmFtZXRlcnM6IE9taXQ8VXNlTGFiZWxTeW50aGV0aWNQYXJhbWV0ZXJzW1wibGFiZWxQYXJhbWV0ZXJzXCJdLCBcIm9uTGFiZWxDbGlja1wiPjtcbiAgICBsaXN0Ym94UGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgXCJzaW5nbGVcImAsIHRoZSBzZWxlY3RlZCBpdGVtIGlzIGNvbnRyb2xsZWRcbiAgICAgICAgICogdmlhIGBzZWxlY3RlZEluZGV4YC4gV2hlbiBgXCJtdWx0aVwiYCwgdGhlIHNlbGVjdGVkXG4gICAgICAgICAqIGl0ZW1zIGFyZSBjb250cm9sbGVkIGJ5IHRoZWlyIGluZGl2aWR1YWwgYHNlbGVjdGVkYCBwcm9wcy5cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGlvbkxpbWl0OiBcInNpbmdsZVwiIHwgXCJtdWx0aVwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IHVzZWQgd2hlbiBgZ3JvdXBpbmdUeXBlYCBpcyBgXCJ3aXRob3V0LWdyb3Vwc1wiYCBvciBgXCJncm91cFwiYFxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRJbmRleDogbnVtYmVyIHwgbnVsbDtcbiAgICAgICAgc2V0U2VsZWN0ZWRJbmRleDogUGFzc2l2ZVN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsLCBFdmVudD47XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqICogYFwid2l0aG91dC1ncm91cHNcImA6IFRoaXMgaXMgYSBsaXN0Ym94IHdpdGggbm8gZ3JvdXBzXG4gICAgICAgICAqICogYFwid2l0aC1ncm91cHNcImA6IFRoaXMgaXMgYSBsaXN0Ym94IHRoYXQgaXMgZ3JvdXBlZCBpbnRvIDIgb3IgbW9yZSBsYWJlbGxlZCBzZWN0aW9ucy4gSW4gdGhpcyBjYXNlLCAqKmFsbCBuYXZpZ2F0aW9uIGFuZCBzZWxlY3Rpb24gaXMgZGlzYWJsZWQqKiAobWVhbmluZyB5b3UgY2FuIHBhc3Mgd2hhdGV2ZXIgeW91J2QgbGlrZSB0byB0aGVtLCBpdCdzIGFsbCBpZ25vcmVkKSBhbmQgZGVsZWdhdGVkIHRvIHRoZSBjaGlsZCBgZ3JvdXBgcy5cbiAgICAgICAgICogKiBgXCJncm91cFwiYDogVGhpcyBpcyBhIGdyb3VwLCBjb250YWluZWQgd2l0aGluIGEgbGlzdGJveCB3aXRoIGB0eXBlPT1cIndpdGgtZ3JvdXBzXCJgXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gc3VwcG9ydCBmb3IgYSBtaXggb2YgZ3JvdXBlZCBhbmQgdW5ncm91cGVkIG9wdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBncm91cGluZ1R5cGU6IFwid2l0aC1ncm91cHNcIiB8IFwid2l0aG91dC1ncm91cHNcIiB8IFwiZ3JvdXBcIjtcbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hSZXR1cm5UeXBlPExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+IGV4dGVuZHMgT21pdDxVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBNPiwgXCJwcm9wc1wiPiB7XG4gICAgcHJvcHNMaXN0Ym94OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD47XG4gICAgcHJvcHNMaXN0Ym94TGFiZWw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XG4gICAgY29udGV4dDogVXNlTGlzdGJveENvbnRleHQ8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgTT47XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hJdGVtUmV0dXJuVHlwZTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPExpc3RJdGVtRWxlbWVudCwgTT4geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hJdGVtUGFyYW1ldGVyczxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBVc2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPExpc3RJdGVtRWxlbWVudCwgTSwgbmV2ZXI+IHtcbiAgICBsaXN0Ym94UGFyYW1ldGVyczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0aGUgYHNlbGVjdGlvbkxpbWl0YCBpcyBgXCJzaW5nbGVcImAsIHRoaXMgbXVzdCBiZSBgbnVsbGAuXG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RlZDogYm9vbGVhbiB8IG51bGw7XG4gICAgfVxuICAgIGNvbnRleHQ6IFVzZUxpc3Rib3hDb250ZXh0PGFueSwgTGlzdEl0ZW1FbGVtZW50LCBNPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uU29ydGFibGVDaGlsZEluZm88TGlzdEl0ZW1FbGVtZW50PiB7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3Rib3g8TGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4oe1xuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIGxhYmVsUGFyYW1ldGVycyxcbiAgICBsaXN0Ym94UGFyYW1ldGVyczogeyBzZWxlY3Rpb25MaW1pdCwgZ3JvdXBpbmdUeXBlLCBzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4IH1cbn06IFVzZUxpc3Rib3hQYXJhbWV0ZXJzPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIExhYmVsRWxlbWVudCwgTT4pOiBVc2VMaXN0Ym94UmV0dXJuVHlwZTxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBMYWJlbEVsZW1lbnQsIE0+IHtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgcHJvcHNJbnB1dDogcHJvcHNMYWJlbExpc3QsXG4gICAgICAgIHByb3BzTGFiZWw6IHByb3BzTGFiZWxMYWJlbCxcbiAgICAgICAgcmFuZG9tSWRJbnB1dFJldHVybjogeyBpZDogX2lucHV0SWQgfSxcbiAgICAgICAgcmFuZG9tSWRMYWJlbFJldHVybjogeyBpZDogX2xhYmVsSWQgfVxuICAgIH0gPSB1c2VMYWJlbFN5bnRoZXRpYzxMaXN0RWxlbWVudCwgTGFiZWxFbGVtZW50Pih7XG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgLi4ubGFiZWxQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgb25MYWJlbENsaWNrOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4uZm9jdXNTZWxmKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICByYW5kb21JZElucHV0UGFyYW1ldGVyczogeyBwcmVmaXg6IFByZWZpY2VzLmxpc3Rib3ggfSxcbiAgICAgICAgcmFuZG9tSWRMYWJlbFBhcmFtZXRlcnM6IHsgcHJlZml4OiBQcmVmaWNlcy5saXN0Ym94TGFiZWwgfVxuICAgIH0pO1xuICAgIGxldCB7XG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHByb3BzLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5cbiAgICB9ID0gdXNlQ29tcGxldGVMaXN0TmF2aWdhdGlvbjxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBNPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IHsgaW5pdGlhbGx5U2VsZWN0ZWRJbmRleDogc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleCB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcbiAgICB9KTtcblxuICAgIGNvbnN0IF92OiB2b2lkID0gdXNlU2luZ2xlU2VsZWN0aW9uRGVjbGFyYXRpdmUoeyBcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uRGVjbGFyYXRpdmVQYXJhbWV0ZXJzOiB7IHNlbGVjdGVkSW5kZXggfSwgXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybjogeyBzZXRTZWxlY3RlZEluZGV4OiBzaW5nbGVTZWxlY3Rpb25SZXR1cm4uc2V0U2VsZWN0ZWRJbmRleCB9XG4gICAgIH0pXG5cbiAgICBpZiAoZ3JvdXBpbmdUeXBlID09IFwiZ3JvdXBcIilcbiAgICAgICAgcHJvcHMucm9sZSA9IFwiZ3JvdXBcIjtcbiAgICBlbHNlIGlmIChncm91cGluZ1R5cGUgPT0gXCJ3aXRoLWdyb3Vwc1wiKSB7XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgY2xvYmJlcmluZyBhbGwgdGhlIGxpc3QgbmF2aWdhdGlvbiBzdHVmZi5cbiAgICAgICAgcHJvcHMgPSB7IHJvbGU6IFwibGlzdGJveFwiIH07XG4gICAgICAgIC8vIC4uLmFjdHVhbGx5LCBjb250ZXh0IHRvbyB3aGlsZSB3ZSdyZSBhdCBpdC5cbiAgICAgICAgY29udGV4dCA9IG51bGwhXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcm9wcy5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdGlvbkxpbWl0ID09IFwibXVsdGlcIilcbiAgICAgICAgY29uc29sZS5hc3NlcnQoc2luZ2xlU2VsZWN0aW9uUmV0dXJuLmdldFNlbGVjdGVkSW5kZXgoKSA9PSBudWxsKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNSZXR1cm4sXG4gICAgICAgIGNvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAuLi5jb250ZXh0LFxuICAgICAgICAgICAgbGlzdGJveENvbnRleHQ6IHVzZVN0YWJsZU9iamVjdCh7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uTGltaXRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblJldHVybixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgcHJvcHNMaXN0Ym94OiB1c2VNZXJnZWRQcm9wcyhwcm9wcywgcHJvcHNMYWJlbExpc3QsIHsgXCJhcmlhLW11bHRpc2VsZWN0YWJsZVwiOiAoc2VsZWN0aW9uTGltaXQgPT0gXCJtdWx0aVwiID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQpIH0pLFxuICAgICAgICBwcm9wc0xpc3Rib3hMYWJlbDogcHJvcHNMYWJlbExhYmVsXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdGJveEl0ZW08TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+KHtcbiAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHByZXNzUGFyYW1ldGVycyxcbiAgICBjb250ZXh0OiB7IGxpc3Rib3hDb250ZXh0OiB7IHNlbGVjdGlvbkxpbWl0IH0sIC4uLmNvbnRleHQgfSxcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLFxuICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICBzb3J0YWJsZUNoaWxkUGFyYW1ldGVycyxcbiAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnMsXG4gICAgbGlzdGJveFBhcmFtZXRlcnM6IHsgc2VsZWN0ZWQgfVxufTogVXNlTGlzdGJveEl0ZW1QYXJhbWV0ZXJzPExpc3RJdGVtRWxlbWVudCwgTT4pOiBVc2VMaXN0Ym94SXRlbVJldHVyblR5cGU8TGlzdEl0ZW1FbGVtZW50LCBNPiB7XG4gICAgY29uc3Qge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgcHJlc3NSZXR1cm4sXG4gICAgICAgIHByb3BzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblxuICAgIH0gPSB1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8TGlzdEl0ZW1FbGVtZW50LCBNLCBuZXZlcj4oe1xuICAgICAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnMsXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIHByZXNzUGFyYW1ldGVycyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgIGNvbnRleHRcbiAgICB9KTtcblxuXG4gICAgaWYgKHNlbGVjdGlvbkxpbWl0ID09IFwic2luZ2xlXCIpXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNlbGVjdGVkID09IG51bGwpO1xuXG4gICAgcHJvcHMucm9sZSA9IFwib3B0aW9uXCI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm4sXG4gICAgICAgIG1hbmFnZWRDaGlsZFJldHVybixcbiAgICAgICAgcHJlc3NSZXR1cm4sXG4gICAgICAgIHByb3BzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblxuICAgIH1cbn1cbi8qXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdGJveEdyb3VwPENvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBIZWFkaW5nRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KCkge1xuICAgIGNvbnN0IHtcbiAgICAgICAgcHJvcHNSZWZlcmVuY2VyLFxuICAgICAgICBwcm9wc1NvdXJjZSxcbiAgICAgICAgcmFuZG9tSWRSZXR1cm5cbiAgICB9ID0gdXNlUmFuZG9tSWQ8SGVhZGluZ0VsZW1lbnQsIENvbnRhaW5lckVsZW1lbnQ+KHsgcmFuZG9tSWRQYXJhbWV0ZXJzOiB7IHByZWZpeDogXCJsaXN0Ym94LW11bHRpLWdyb3VwLVwiLCBvdGhlclJlZmVyZW5jZXJQcm9wOiBcImFyaWEtbGFiZWxsZWRieVwiIH0gfSk7XG5cbiAgICBwcm9wc1JlZmVyZW5jZXIucm9sZSA9IFwiZ3JvdXBcIjtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzSGVhZGluZzogcHJvcHNTb3VyY2UsXG4gICAgICAgIHByb3BzQ29udGFpbmVyOiBwcm9wc1JlZmVyZW5jZXJcbiAgICB9XG59Ki9cbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyByZXR1cm5OdWxsIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyBMaXN0Ym94SW5mbywgdXNlTGlzdGJveCwgVXNlTGlzdGJveFBhcmFtZXRlcnMsIFVzZUxpc3Rib3hDb250ZXh0LCBVc2VMaXN0Ym94UmV0dXJuVHlwZSwgVXNlTGlzdGJveEl0ZW1QYXJhbWV0ZXJzLCBMaXN0Ym94U2luZ2xlU2VsZWN0RXZlbnQsIFVzZUxpc3Rib3hJdGVtUmV0dXJuVHlwZSwgdXNlTGlzdGJveEl0ZW0gfSBmcm9tIFwiLi4vdXNlLWxpc3Rib3hcIjtcbmltcG9ydCB7IFBhcnRpYWxFeGNlcHQsIHVzZURlZmF1bHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcblxuaW50ZXJmYWNlIExpc3Rib3hQcm9wc0Jhc2U8TGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4gZXh0ZW5kc1xuICAgIEdldDxVc2VMaXN0Ym94UGFyYW1ldGVyczxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBMYWJlbEVsZW1lbnQsIE0+LCBcImxhYmVsUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTGlzdGJveFBhcmFtZXRlcnM8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgTGFiZWxFbGVtZW50LCBNPiwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTGlzdGJveFBhcmFtZXRlcnM8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgTGFiZWxFbGVtZW50LCBNPiwgXCJsaXN0Ym94UGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTGlzdGJveFBhcmFtZXRlcnM8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgTGFiZWxFbGVtZW50LCBNPiwgXCJyZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94UGFyYW1ldGVyczxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBMYWJlbEVsZW1lbnQsIE0+LCBcInJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTGlzdGJveFBhcmFtZXRlcnM8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgTGFiZWxFbGVtZW50LCBNPiwgXCJzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTGlzdGJveFBhcmFtZXRlcnM8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgTGFiZWxFbGVtZW50LCBNPiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZUxpc3Rib3hSZXR1cm5UeXBlPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIExhYmVsRWxlbWVudCwgTT4+O1xufVxuXG5pbnRlcmZhY2UgTGlzdGJveEl0ZW1Qcm9wc0Jhc2U8TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+IGV4dGVuZHNcbiAgICBHZXQ8VXNlTGlzdGJveEl0ZW1QYXJhbWV0ZXJzPExpc3RJdGVtRWxlbWVudCwgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4sIFwibGlzdGJveFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hJdGVtUGFyYW1ldGVyczxMaXN0SXRlbUVsZW1lbnQsIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hJdGVtUGFyYW1ldGVyczxMaXN0SXRlbUVsZW1lbnQsIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+LCBcInByZXNzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTGlzdGJveEl0ZW1QYXJhbWV0ZXJzPExpc3RJdGVtRWxlbWVudCwgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4sIFwic29ydGFibGVDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hJdGVtUGFyYW1ldGVyczxMaXN0SXRlbUVsZW1lbnQsIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+LCBcInJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94SXRlbVBhcmFtZXRlcnM8TGlzdEl0ZW1FbGVtZW50LCBMaXN0Ym94SW5mbzxMaXN0SXRlbUVsZW1lbnQ+PiwgXCJzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hJdGVtUGFyYW1ldGVyczxMaXN0SXRlbUVsZW1lbnQsIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+LCBcInRleHRDb250ZW50UGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZUxpc3Rib3hJdGVtUmV0dXJuVHlwZTxMaXN0SXRlbUVsZW1lbnQsIE0+Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMaXN0Ym94UHJvcHM8TGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PExpc3Rib3hQcm9wc0Jhc2U8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwgTGFiZWxFbGVtZW50LCBNPiwgXCJhcmlhTGFiZWxcIiB8IFwiZ3JvdXBpbmdUeXBlXCIgfCBcIm5hdmlnYXRpb25EaXJlY3Rpb25cIiB8IFwic2VsZWN0aW9uTGltaXRcIiB8IFwic2VsZWN0ZWRJbmRleFwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZUxpc3Rib3hSZXR1cm5UeXBlPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIExhYmVsRWxlbWVudCwgTT4pOiBWTm9kZTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGJveEl0ZW1Qcm9wczxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PExpc3Rib3hJdGVtUHJvcHNCYXNlPExpc3RJdGVtRWxlbWVudCwgTT4sIFwiYXJpYVByb3BOYW1lXCIgfCBcImluZGV4XCIgfCBcImdldFNvcnRWYWx1ZVwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZUxpc3Rib3hJdGVtUmV0dXJuVHlwZTxMaXN0SXRlbUVsZW1lbnQsIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+KTogVk5vZGU7XG59XG5cbmNvbnN0IExpc3Rib3hDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VMaXN0Ym94Q29udGV4dDxhbnksIGFueSwgYW55Pj4obnVsbCEpO1xuXG5leHBvcnQgZnVuY3Rpb24gTGlzdGJveDxMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBhcmlhTGFiZWwsXG4gICAgY29sbGF0b3IsXG4gICAgY29tcGFyZSxcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBnZXRJbmRleCxcbiAgICBzZWxlY3RlZEluZGV4LFxuICAgIG5hdmlnYXRlUGFzdEVuZCxcbiAgICBuYXZpZ2F0ZVBhc3RTdGFydCxcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIHNldFNlbGVjdGVkSW5kZXgsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZSxcbiAgICBzZWxlY3Rpb25MaW1pdCxcbiAgICBncm91cGluZ1R5cGUsXG4gICAgdW50YWJiYWJsZSxcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIHJlbmRlclxufTogTGlzdGJveFByb3BzPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIExhYmVsRWxlbWVudCwgTGlzdGJveEluZm88TGlzdEl0ZW1FbGVtZW50Pj4pIHtcbiAgICBjb25zdCBpbmZvID0gdXNlTGlzdGJveDxMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50LCBMYWJlbEVsZW1lbnQsIExpc3Rib3hJbmZvPExpc3RJdGVtRWxlbWVudD4+KHtcbiAgICAgICAgbGFiZWxQYXJhbWV0ZXJzOiB7IGFyaWFMYWJlbCB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kOiBuYXZpZ2F0ZVBhc3RFbmQgPz8gXCJ3cmFwXCIsXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydDogbmF2aWdhdGVQYXN0U3RhcnQgPz8gXCJ3cmFwXCIsXG4gICAgICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxuXG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUFycm93S2V5c1wiLCBkaXNhYmxlQXJyb3dLZXlzKSxcbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5czogdXNlRGVmYXVsdChcImRpc2FibGVIb21lRW5kS2V5c1wiLCBkaXNhYmxlSG9tZUVuZEtleXMpLFxuICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplOiB1c2VEZWZhdWx0KFwicGFnZU5hdmlnYXRpb25TaXplXCIsIHBhZ2VOYXZpZ2F0aW9uU2l6ZSlcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdGJveFBhcmFtZXRlcnM6IHsgc2VsZWN0aW9uTGltaXQsIGdyb3VwaW5nVHlwZSwgc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleDogc2V0U2VsZWN0ZWRJbmRleCA/PyBub29wIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgZ2V0SW5kZXg6IHVzZURlZmF1bHQoXCJnZXRJbmRleFwiLCBnZXRJbmRleCkgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IG9uVGFiYmFibGVJbmRleENoYW5nZTogb25UYWJiYWJsZUluZGV4Q2hhbmdlID8/IG51bGwsIHVudGFiYmFibGU6IHVudGFiYmFibGUgPz8gZmFsc2UgfSxcbiAgICAgICAgLy9zaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzOiB7IGluaXRpYWxseVNlbGVjdGVkSW5kZXg6IGluaXRpYWxseVNlbGVjdGVkSW5kZXggPz8gbnVsbCwgc2V0U2VsZWN0ZWRJbmRleDogc2V0U2VsZWN0ZWRJbmRleCA/PyBudWxsIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IGNvbXBhcmU6IGNvbXBhcmUgPz8gbnVsbCB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY29sbGF0b3I6IHVzZURlZmF1bHQoXCJjb2xsYXRvclwiLCBjb2xsYXRvciksXG4gICAgICAgICAgICBub1R5cGVhaGVhZDogdXNlRGVmYXVsdChcIm5vVHlwZWFoZWFkXCIsIG5vVHlwZWFoZWFkKSxcbiAgICAgICAgICAgIHR5cGVhaGVhZFRpbWVvdXQ6IHVzZURlZmF1bHQoXCJ0eXBlYWhlYWRUaW1lb3V0XCIsIHR5cGVhaGVhZFRpbWVvdXQpXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxMaXN0Ym94Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17aW5mby5jb250ZXh0fT57cmVuZGVyKGluZm8pfTwvTGlzdGJveENvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHsgfVxuXG5leHBvcnQgZnVuY3Rpb24gTGlzdGJveEl0ZW08TGlzdGJveEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBhcmlhUHJvcE5hbWUsIGRpc2FibGVkLCBleGNsdWRlLCBmb2N1c1NlbGYsIGdldFRleHQsIGhpZGRlbiwgaW5kZXgsIG9uUHJlc3NTeW5jLCByZW5kZXIsIHNlbGVjdGVkLCBzZWxlY3Rpb25Nb2RlLCBnZXRTb3J0VmFsdWUgfTogTGlzdGJveEl0ZW1Qcm9wczxMaXN0Ym94SXRlbUVsZW1lbnQsIExpc3Rib3hJbmZvPExpc3Rib3hJdGVtRWxlbWVudD4+KSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoTGlzdGJveENvbnRleHQpIGFzIFVzZUxpc3Rib3hDb250ZXh0PGFueSwgTGlzdGJveEl0ZW1FbGVtZW50LCBMaXN0Ym94SW5mbzxMaXN0Ym94SXRlbUVsZW1lbnQ+PjtcbiAgICBjb25zdCBmb2N1c1NlbGZEZWZhdWx0ID0gdXNlQ2FsbGJhY2soKGU6IGFueSkgPT4geyBlPy5mb2N1cygpOyB9LCBbXSk7XG4gICAgY29uc3QgaW5mbyA9IHVzZUxpc3Rib3hJdGVtKHtcbiAgICAgICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczoge30sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGxpc3Rib3hQYXJhbWV0ZXJzOiB7IHNlbGVjdGVkOiBzZWxlY3RlZCA/PyBudWxsLCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiB7IGdldFNvcnRWYWx1ZTogZ2V0U29ydFZhbHVlIH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczogeyBleGNsdWRlLCBmb2N1c1NlbGY6IGZvY3VzU2VsZiA/PyBmb2N1c1NlbGZEZWZhdWx0LCBvblByZXNzU3luYyB9LFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnM6IHsgZ2V0VGV4dDogdXNlRGVmYXVsdChcImdldFRleHRcIiwgZ2V0VGV4dCkgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQgPz8gZmFsc2UsXG4gICAgICAgICAgICBhcmlhUHJvcE5hbWUsXG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlOiB1c2VEZWZhdWx0KFwic2VsZWN0aW9uTW9kZVwiLCBzZWxlY3Rpb25Nb2RlKVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVuZGVyKGluZm8pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtb0xpc3Rib3goKSB7XG4gICAgY29uc3QgW3NlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXhdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4oMCk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8TGlzdGJveDxIVE1MT0xpc3RFbGVtZW50LCBIVE1MTElFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50PlxuICAgICAgICAgICAgYXJpYUxhYmVsPXtudWxsfVxuICAgICAgICAgICAgY29sbGF0b3I9e251bGx9XG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzPXtmYWxzZX1cbiAgICAgICAgICAgIGRpc2FibGVIb21lRW5kS2V5cz17ZmFsc2V9XG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RFbmQ9XCJ3cmFwXCJcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdFN0YXJ0PVwid3JhcFwiXG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4PXtzZWxlY3RlZEluZGV4fVxuICAgICAgICAgICAgc2V0U2VsZWN0ZWRJbmRleD17ZSA9PiBzZXRTZWxlY3RlZEluZGV4KGUpfVxuICAgICAgICAgICAgZ2V0SW5kZXg9e3YgPT4gdi5wcm9wcy5pbmRleH1cbiAgICAgICAgICAgIG5vVHlwZWFoZWFkPXtmYWxzZX1cbiAgICAgICAgICAgIG5hdmlnYXRpb25EaXJlY3Rpb249XCJ2ZXJ0aWNhbFwiXG4gICAgICAgICAgICBzZWxlY3Rpb25MaW1pdD1cInNpbmdsZVwiXG4gICAgICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U9e251bGx9XG4gICAgICAgICAgICBwYWdlTmF2aWdhdGlvblNpemU9ezAuMX1cbiAgICAgICAgICAgIGdyb3VwaW5nVHlwZT1cIndpdGhvdXQtZ3JvdXBzXCJcbiAgICAgICAgICAgIHR5cGVhaGVhZFRpbWVvdXQ9ezEwMDB9XG4gICAgICAgICAgICBjb21wYXJlPXsoKGxocywgcmhzKSA9PiBsaHMuaW5kZXggLSByaHMuaW5kZXgpfVxuICAgICAgICAgICAgcmVuZGVyPXtpbmZvID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIHsuLi5pbmZvLnByb3BzTGlzdGJveExhYmVsfT5MaXN0Ym94PC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxvbCB7Li4uaW5mby5wcm9wc0xpc3Rib3h9Pjwvb2w+XG4gICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtb0xpc3Rib3hJdGVtKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8TGlzdGJveEl0ZW08SFRNTExJRWxlbWVudD5cbiAgICAgICAgICAgIGFyaWFQcm9wTmFtZT1cImFyaWEtc2VsZWN0ZWRcIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZhbHNlfVxuICAgICAgICAgICAgZXhjbHVkZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgZ2V0U29ydFZhbHVlPXtyZXR1cm5OdWxsfVxuICAgICAgICAgICAgZm9jdXNTZWxmPXtlID0+IGUuZm9jdXMoKX1cbiAgICAgICAgICAgIGhpZGRlbj17ZmFsc2V9XG4gICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICBvblByZXNzU3luYz17bnVsbH1cbiAgICAgICAgICAgIHNlbGVjdGVkPXtudWxsfVxuICAgICAgICAgICAgc2VsZWN0aW9uTW9kZT1cImFjdGl2YXRpb25cIlxuICAgICAgICAgICAgcmVuZGVyPXtpbmZvID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8bGkgey4uLmluZm8ucHJvcHN9Pkxpc3QgaXRlbSAoaW5kZXggI3tpbmRleH0pPC9saT5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgIClcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyByZXR1cm5OdWxsIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBVc2VNZW51Q29udGV4dCwgdXNlTWVudUl0ZW0sIFVzZU1lbnVJdGVtUmV0dXJuVHlwZSB9IGZyb20gXCIuLi91c2UtbWVudVwiO1xuaW1wb3J0IHsgVXNlVG9vbGJhckNvbnRleHQgfSBmcm9tIFwiLi4vdXNlLXRvb2xiYXJcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG4vL2ltcG9ydCB7IEVsZW1lbnRUb1RhZyB9IGZyb20gXCIuLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlTWVudWJhciwgVXNlTWVudWJhclBhcmFtZXRlcnMsIFVzZU1lbnViYXJJdGVtUGFyYW1ldGVycywgVXNlTWVudWJhclN1YkluZm8sIFVzZU1lbnViYXJSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL3VzZS1tZW51YmFyXCI7XG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyUG9ydGFsIH0gZnJvbSBcIi4vZGlhbG9nXCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiwgUGFydGlhbEV4Y2VwdCwgdXNlRGVmYXVsdCB9IGZyb20gXCIuL3V0aWxcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuaW50ZXJmYWNlIE1lbnViYXJQcm9wc0Jhc2U8TWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4gZXh0ZW5kc1xuICAgIEdldDxVc2VNZW51YmFyUGFyYW1ldGVyczxNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPiwgXCJsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudWJhclBhcmFtZXRlcnM8TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTT4sIFwicm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51YmFyUGFyYW1ldGVyczxNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudWJhclBhcmFtZXRlcnM8TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTT4sIFwic2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudWJhclBhcmFtZXRlcnM8TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTT4sIFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudWJhclBhcmFtZXRlcnM8TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTT4sIFwic29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnViYXJQYXJhbWV0ZXJzPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+LCBcIm1lbnViYXJQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51YmFyUGFyYW1ldGVyczxNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNPiwgXCJ0b29sYmFyUGFyYW1ldGVyc1wiPiB7XG4gICAgLy90YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD47XG4gICAgcmVmPzogUmVmPFVzZU1lbnViYXJSZXR1cm5UeXBlPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+Pjtcbn1cblxuXG5cblxuXG5pbnRlcmZhY2UgTWVudUl0ZW1Qcm9wc0Jhc2U8TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIC8vR2V0PFVzZU1lbnViYXJJdGVtUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQsIE0+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnViYXJJdGVtUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcIm1lbnVJdGVtUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudWJhckl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4sIFwicHJlc3NQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51YmFySXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJyb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudWJhckl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4sIFwic29ydGFibGVDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnViYXJJdGVtUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnViYXJJdGVtUGFyYW1ldGVyczxNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudWJhckl0ZW1QYXJhbWV0ZXJzPE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4sIFwidGV4dENvbnRlbnRQYXJhbWV0ZXJzXCI+IHtcbiAgICAvL3RhZ0xpc3RJdGVtOiBFbGVtZW50VG9UYWc8TGlzdGJveEl0ZW1FbGVtZW50PjtcbiAgICAvL3N1YkluZm86IEdldDxVc2VNZW51YmFySXRlbVBhcmFtZXRlcnM8TWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzXCI+O1xuICAgIHJlZj86IFJlZjxVc2VNZW51SXRlbVJldHVyblR5cGU8TWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+Pj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVudWJhclByb3BzPE1lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTSBleHRlbmRzIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxNZW51YmFyUHJvcHNCYXNlPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE0+LCBcIm9yaWVudGF0aW9uXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlTWVudWJhclJldHVyblR5cGU8TWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTT4pOiBWTm9kZTxhbnk+O1xufVxuZXhwb3J0IGludGVyZmFjZSBNZW51SXRlbVByb3BzPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxNZW51SXRlbVByb3BzQmFzZTxNZW51SXRlbUVsZW1lbnQ+LCBcImFyaWFQcm9wTmFtZVwiIHwgXCJpbmRleFwiIHwgXCJzZWxlY3Rpb25Nb2RlXCIgfCBcImdldFNvcnRWYWx1ZVwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZU1lbnVJdGVtUmV0dXJuVHlwZTxNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+KTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGNvbnN0IE1lbnVJdGVtQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTWVudUNvbnRleHQ8YW55LCBhbnksIGFueT4+KG51bGwhKTtcblxuZXhwb3J0IGNvbnN0IE1lbnViYXIgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBNZW51YmFyVTxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIHJlbmRlcixcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBuYXZpZ2F0ZVBhc3RFbmQsXG4gICAgbmF2aWdhdGVQYXN0U3RhcnQsXG4gICAgcGFnZU5hdmlnYXRpb25TaXplLFxuICAgIG9yaWVudGF0aW9uLFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBjb21wYXJlLFxuICAgIGdldEluZGV4LFxuICAgIHVudGFiYmFibGUsXG4gICAgaW5pdGlhbGx5U2VsZWN0ZWRJbmRleCxcbiAgICBzZXRTZWxlY3RlZEluZGV4LFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgcm9sZVxufTogTWVudWJhclByb3BzPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88Q2hpbGRFbGVtZW50Pj4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgaW5mbyA9IHVzZU1lbnViYXI8Q29udGFpbmVyRWxlbWVudCwgQ2hpbGRFbGVtZW50Pih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IFxuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5czogdXNlRGVmYXVsdChcImRpc2FibGVBcnJvd0tleXNcIiwgZGlzYWJsZUFycm93S2V5cyksIFxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUhvbWVFbmRLZXlzXCIsIGRpc2FibGVIb21lRW5kS2V5cyksIFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kOiBuYXZpZ2F0ZVBhc3RFbmQgPz8gXCJ3cmFwXCIsXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RTdGFydDogbmF2aWdhdGVQYXN0U3RhcnQgPz8gXCJ3cmFwXCIsXG4gICAgICAgICAgICBwYWdlTmF2aWdhdGlvblNpemU6IHVzZURlZmF1bHQoXCJwYWdlTmF2aWdhdGlvblNpemVcIiwgcGFnZU5hdmlnYXRpb25TaXplKVxuICAgICAgICAgfSxcbiAgICAgICAgdG9vbGJhclBhcmFtZXRlcnM6IHsgb3JpZW50YXRpb24gfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IG9uVGFiYmFibGVJbmRleENoYW5nZTogb25UYWJiYWJsZUluZGV4Q2hhbmdlID8/IG51bGwsIHVudGFiYmFibGU6IHVudGFiYmFibGUgPz8gZmFsc2UgfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgXG4gICAgICAgICAgICBjb2xsYXRvcjogdXNlRGVmYXVsdChcImNvbGxhdG9yXCIsIGNvbGxhdG9yKSwgXG4gICAgICAgICAgICBub1R5cGVhaGVhZDogdXNlRGVmYXVsdChcIm5vVHlwZWFoZWFkXCIsIG5vVHlwZWFoZWFkKSwgXG4gICAgICAgICAgICB0eXBlYWhlYWRUaW1lb3V0OiB1c2VEZWZhdWx0KFwidHlwZWFoZWFkVGltZW91dFwiLCB0eXBlYWhlYWRUaW1lb3V0KVxuICAgICAgICAgfSxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBnZXRJbmRleDogdXNlRGVmYXVsdChcImdldEluZGV4XCIsIGdldEluZGV4KSB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzOiB7IGluaXRpYWxseVNlbGVjdGVkSW5kZXg6IGluaXRpYWxseVNlbGVjdGVkSW5kZXggPz8gbnVsbCwgc2V0U2VsZWN0ZWRJbmRleDogc2V0U2VsZWN0ZWRJbmRleCA/PyBudWxsIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IGNvbXBhcmU6IGNvbXBhcmUgPz8gbnVsbCB9LFxuICAgICAgICBtZW51YmFyUGFyYW1ldGVyczogeyByb2xlOiByb2xlID8/IFwibWVudWJhclwiIH1cbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbylcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxNZW51SXRlbUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2luZm8uY29udGV4dH0+XG4gICAgICAgICAgICB7cmVuZGVyKGluZm8pfVxuICAgICAgICA8L01lbnVJdGVtQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59KVxuXG5cbmV4cG9ydCBjb25zdCBNZW51SXRlbSA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIE1lbnVJdGVtVTxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgaW5kZXgsXG4gICAgcmVuZGVyLFxuICAgIGFyaWFQcm9wTmFtZSxcbiAgICBleGNsdWRlLFxuICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgaGlkZGVuLFxuICAgIGdldFRleHQsXG4gICAgZGlzYWJsZWQsXG4gICAgb25QcmVzcyxcbiAgICBnZXRTb3J0VmFsdWUsXG4gICAgcm9sZSxcbn06IE1lbnVJdGVtUHJvcHM8TWVudUl0ZW1FbGVtZW50PiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKHVzZUNvbnRleHQoTWVudUl0ZW1Db250ZXh0KSk7IC8qPE1lbnVJdGVtRWxlbWVudCwgQywgSz4pKHtcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbiwgbm9Nb2RpZnlUYWJJbmRleCB9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXG4gICAgICAgIGhhc0ZvY3VzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9LFxuICAgICAgICBtZW51SXRlbTogeyBkaXNhYmxlZCwgb25QcmVzcywgcm9sZSB9LFxuICAgICAgICBzdWJJbmZvXG4gICAgfSk7Ki9cblxuICAgIGNvbnN0IGluZm8gPSB1c2VNZW51SXRlbSh7XG4gICAgICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHt9LFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiB7IGdldFNvcnRWYWx1ZSB9LFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnM6IHsgZ2V0VGV4dDogdXNlRGVmYXVsdChcImdldFRleHRcIiwgZ2V0VGV4dCkgfSxcbiAgICAgICAgbWVudUl0ZW1QYXJhbWV0ZXJzOiB7IG9uUHJlc3M6IG9uUHJlc3MgPz8gbnVsbCwgcm9sZTogcm9sZSA/PyBcIm1lbnVpdGVtXCIgfSxcbiAgICAgICAgcHJlc3NQYXJhbWV0ZXJzOiB7IGV4Y2x1ZGUgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IGFyaWFQcm9wTmFtZSwgc2VsZWN0aW9uTW9kZSwgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlIH1cbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PntyZW5kZXIoaW5mbyl9PC8+XG4gICAgKVxufSlcblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vTWVudWJhcigpIHtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxNZW51YmFyPEhUTUxVTGlzdEVsZW1lbnQsIEhUTUxMSUVsZW1lbnQ+XG4gICAgICAgICAgICBjb2xsYXRvcj17bnVsbH1cbiAgICAgICAgICAgIGRpc2FibGVBcnJvd0tleXM9e2ZhbHNlfVxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzPXtmYWxzZX1cbiAgICAgICAgICAgIGdldEluZGV4PXt2ID0+IHYucHJvcHMuaW5kZXh9XG4gICAgICAgICAgICBjb21wYXJlPXsobGhzLCByaHMpID0+IGxocy5pbmRleCAtIHJocy5pbmRleH1cbiAgICAgICAgICAgIGluaXRpYWxseVNlbGVjdGVkSW5kZXg9e251bGx9XG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RFbmQ9XCJ3cmFwXCJcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdFN0YXJ0PVwid3JhcFwiXG4gICAgICAgICAgICBub1R5cGVhaGVhZD17ZmFsc2V9XG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4PXtudWxsfVxuICAgICAgICAgICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPXtudWxsfVxuICAgICAgICAgICAgb3JpZW50YXRpb249XCJ2ZXJ0aWNhbFwiXG4gICAgICAgICAgICBwYWdlTmF2aWdhdGlvblNpemU9ezAuMX1cbiAgICAgICAgICAgIHR5cGVhaGVhZFRpbWVvdXQ9ezEwMDB9XG4gICAgICAgICAgICByb2xlPXtcIm1lbnVcIn1cbiAgICAgICAgICAgIHJlbmRlcj17aW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx1bCB7Li4uaW5mby5wcm9wc30+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH19XG4gICAgICAgIC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtb01lbnViYXJJdGVtKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8TWVudUl0ZW08SFRNTExJRWxlbWVudD5cbiAgICAgICAgICAgIGV4Y2x1ZGU9e3VuZGVmaW5lZH1cbiAgICAgICAgICAgIGhpZGRlbj17ZmFsc2V9XG4gICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICBzZWxlY3Rpb25Nb2RlPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgb25QcmVzcz17bm9vcH1cbiAgICAgICAgICAgIGdldFNvcnRWYWx1ZT17cmV0dXJuTnVsbH1cbiAgICAgICAgICAgIHJlbmRlcj17aW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSB7Li4uaW5mby5wcm9wc30+TGlzdCBpdGVtIChpbmRleCAje2luZGV4fSk8L2xpPlxuICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgICAgIGFyaWFQcm9wTmFtZT1cImFyaWEtc2VsZWN0ZWRcIlxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZhbHNlfVxuXG4gICAgICAgIC8+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBub29wKCkgeyB9XG5cblxuLypcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyTWVudWJhcjxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNDb250YWluZXIsIHRhZ0NvbnRhaW5lciB9OiB7IHRhZ0NvbnRhaW5lcjogRWxlbWVudFRvVGFnPENvbnRhaW5lckVsZW1lbnQ+LCBtYWtlUHJvcHNDb250YWluZXI6IChpbmZvOiBVc2VNZW51YmFyUmV0dXJuVHlwZTxDb250YWluZXJFbGVtZW50LCBDaGlsZEVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPENoaWxkRWxlbWVudD4+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VNZW51YmFyUmV0dXJuVHlwZTxDb250YWluZXJFbGVtZW50LCBDaGlsZEVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPENoaWxkRWxlbWVudD4+KTogVk5vZGU8YW55PiB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBjcmVhdGVFbGVtZW50KHRhZ0NvbnRhaW5lciBhcyBuZXZlciwgbWFrZVByb3BzQ29udGFpbmVyKGluZm8pKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAge2xpc3R9XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJNZW51SXRlbTxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IG1ha2VQcm9wc0NoaWxkLCB0YWdDaGlsZCB9OiB7IHRhZ0NoaWxkOiBFbGVtZW50VG9UYWc8Q2hpbGRFbGVtZW50PiwgbWFrZVByb3BzQ2hpbGQ6IChpbmZvOiBVc2VNZW51SXRlbVJldHVyblR5cGU8Q2hpbGRFbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VNZW51SXRlbVJldHVyblR5cGU8Q2hpbGRFbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+PiwgbW9kaWZ5UHJvcHNMaXN0SXRlbTogUHJvcE1vZGlmaWVyPENoaWxkRWxlbWVudD4pOiBWTm9kZTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnQ2hpbGQgYXMgbmV2ZXIsIG1vZGlmeVByb3BzTGlzdEl0ZW0obWFrZVByb3BzQ2hpbGQoaW5mbykpKTtcbiAgICB9XG59Ki9cblxuIiwiaW1wb3J0IHsgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHJldHVybk51bGwsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUltcGVyYXRpdmVIYW5kbGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VNZW51LCB1c2VNZW51SXRlbSwgVXNlTWVudVBhcmFtZXRlcnMsIFVzZU1lbnVSZXR1cm5UeXBlIH0gZnJvbSBcIi4uL3VzZS1tZW51XCI7XG5pbXBvcnQgeyBVc2VNZW51YmFyU3ViSW5mbyB9IGZyb20gXCIuLi91c2UtbWVudWJhclwiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlclBvcnRhbCB9IGZyb20gXCIuL2RpYWxvZ1wiO1xuaW1wb3J0IHsgTWVudUl0ZW0sIE1lbnVJdGVtQ29udGV4dCB9IGZyb20gXCIuL21lbnViYXJcIjtcbmltcG9ydCB7IG1lbW9Gb3J3YXJkUmVmLCBQYXJlbnREZXB0aENvbnRleHQsIFBhcnRpYWxFeGNlcHQsIHVzZURlZmF1bHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuXG5pbnRlcmZhY2UgTWVudVByb3BzQmFzZTxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyAvL09taXQ8VXNlTWVudVBhcmFtZXRlcnM8RSwgSywgST4sIFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIgfCBcIm9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdFwiIHwgXCJvbkNoaWxkcmVuTW91bnRDaGFuZ2VcIiB8IFwib25UYWJiYWJsZUluZGV4Q2hhbmdlXCIgfCBcIm9uVGFiYmFibGVSZW5kZXJcIiB8IFwib25UYWJiZWRJblRvXCIgfCBcIm9uVGFiYmVkT3V0T2ZcIj4gJiB7XG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4sIFwibWVudVBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4sIFwibWVudVN1cmZhY2VQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcInJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJkaXNtaXNzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJlc2NhcGVEaXNtaXNzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+PiwgXCJyZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcInNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+LCBcInNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4sIFwidG9vbGJhclBhcmFtZXRlcnNcIj4ge1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lbnVQcm9wczxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PE1lbnVQcm9wc0Jhc2U8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudD4sIFwib3BlblwiIHwgXCJvbkNsb3NlXCIgfCBcIm9uT3BlblwiIHwgXCJvcGVuRGlyZWN0aW9uXCIgfCBcIm9yaWVudGF0aW9uXCI+IHtcbiAgICByZW5kZXIobWVudUluZm86IFVzZU1lbnVSZXR1cm5UeXBlPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+KTogVk5vZGU7XG59XG5cbi8vY29uc3QgTWVudUl0ZW1Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VNZW51SXRlbTxhbnksIGFueSwgYW55Pj4obnVsbCEpO1xuXG5leHBvcnQgY29uc3QgTWVudSA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIE1lbnU8U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgU2VudGluZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMgPSB1bmRlZmluZWQsIEsgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oe1xuXG5cbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBub1R5cGVhaGVhZCxcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIG9yaWVudGF0aW9uLFxuXG4gICAgb25DbG9zZSxcbiAgICBvcGVuLFxuXG4gICAgb3BlbkRpcmVjdGlvbixcblxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBjbG9zZU9uQmFja2Ryb3AsXG4gICAgY2xvc2VPbkVzY2FwZSxcbiAgICBjbG9zZU9uTG9zdEZvY3VzLFxuICAgIGNvbXBhcmUsXG4gICAgZ2V0SW5kZXgsXG4gICAgaW5pdGlhbGx5U2VsZWN0ZWRJbmRleCxcbiAgICBuYXZpZ2F0ZVBhc3RFbmQsXG4gICAgbmF2aWdhdGVQYXN0U3RhcnQsXG4gICAgc2V0U2VsZWN0ZWRJbmRleCxcbiAgICBwYWdlTmF2aWdhdGlvblNpemUsXG4gICAgcGFyZW50RGVwdGgsXG4gICAgdW50YWJiYWJsZSxcbiAgICBvbk9wZW4sXG5cbiAgICBnZXRXaW5kb3csXG5cbiAgICByZW5kZXJcblxufTogTWVudVByb3BzPFN1cmZhY2VFbGVtZW50LCBQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQ+LCByZWY/OiBSZWY8YW55Pikge1xuXG4gICAgY29uc3QgZGVmYXVsdFBhcmVudERlcHRoID0gdXNlQ29udGV4dChQYXJlbnREZXB0aENvbnRleHQpO1xuICAgIGxldCBteURlcHRoID0gKHBhcmVudERlcHRoID8/IGRlZmF1bHRQYXJlbnREZXB0aCkgKyAxO1xuXG4gICAgY29uc3QgaW5mbyA9IHVzZU1lbnU8U3VyZmFjZUVsZW1lbnQsIFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQnV0dG9uRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5czogdXNlRGVmYXVsdChcImRpc2FibGVBcnJvd0tleXNcIiwgZGlzYWJsZUFycm93S2V5cyksXG4gICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlSG9tZUVuZEtleXNcIiwgZGlzYWJsZUhvbWVFbmRLZXlzKSxcbiAgICAgICAgICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZTogdXNlRGVmYXVsdChcInBhZ2VOYXZpZ2F0aW9uU2l6ZVwiLCBwYWdlTmF2aWdhdGlvblNpemUpLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0RW5kOiBcIndyYXBcIixcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdFN0YXJ0OiBcIndyYXBcIlxuICAgICAgICB9LFxuICAgICAgICBkaXNtaXNzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY2xvc2VPbkJhY2tkcm9wOiBjbG9zZU9uQmFja2Ryb3AgPz8gdHJ1ZSxcbiAgICAgICAgICAgIGNsb3NlT25Fc2NhcGU6IGNsb3NlT25Fc2NhcGUgPz8gdHJ1ZSxcbiAgICAgICAgICAgIGNsb3NlT25Mb3N0Rm9jdXM6IGNsb3NlT25Mb3N0Rm9jdXMgPz8gdHJ1ZSxcbiAgICAgICAgICAgIG9uQ2xvc2UsXG4gICAgICAgICAgICBvcGVuXG4gICAgICAgIH0sXG4gICAgICAgIGVzY2FwZURpc21pc3NQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBnZXRXaW5kb3c6IHVzZURlZmF1bHQoXCJnZXRXaW5kb3dcIiwgZ2V0V2luZG93KSxcbiAgICAgICAgICAgIHBhcmVudERlcHRoOiBwYXJlbnREZXB0aCA/PyBkZWZhdWx0UGFyZW50RGVwdGhcbiAgICAgICAgfSxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBnZXRJbmRleDogdXNlRGVmYXVsdChcImdldEluZGV4XCIsIGdldEluZGV4KSB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzOiB7IGluaXRpYWxseVNlbGVjdGVkSW5kZXg6IGluaXRpYWxseVNlbGVjdGVkSW5kZXggPz8gbnVsbCwgc2V0U2VsZWN0ZWRJbmRleDogc2V0U2VsZWN0ZWRJbmRleCA/PyBudWxsIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IGNvbXBhcmU6IGNvbXBhcmUgPz8gbnVsbCB9LFxuICAgICAgICBtZW51UGFyYW1ldGVyczogeyBvcGVuRGlyZWN0aW9uLCBvbk9wZW4gfSxcbiAgICAgICAgbWVudVN1cmZhY2VQYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IG9uVGFiYmFibGVJbmRleENoYW5nZSA/PyBudWxsLFxuICAgICAgICAgICAgdW50YWJiYWJsZTogdW50YWJiYWJsZSA/PyBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY29sbGF0b3I6IHVzZURlZmF1bHQoXCJjb2xsYXRvclwiLCBjb2xsYXRvciksXG4gICAgICAgICAgICBub1R5cGVhaGVhZDogdXNlRGVmYXVsdChcIm5vVHlwZWFoZWFkXCIsIG5vVHlwZWFoZWFkKSxcbiAgICAgICAgICAgIHR5cGVhaGVhZFRpbWVvdXQ6IHVzZURlZmF1bHQoXCJ0eXBlYWhlYWRUaW1lb3V0XCIsIHR5cGVhaGVhZFRpbWVvdXQpXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2xiYXJQYXJhbWV0ZXJzOiB7IG9yaWVudGF0aW9uIH0sXG4gICAgICAgIG1lbnViYXJQYXJhbWV0ZXJzOiB7fVxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIC8vY29uc3QgeyB1c2VNZW51U2VudGluZWxQcm9wczogdXNlRmlyc3RTZW50aW5lbFByb3BzIH0gPSB1c2VNZW51U2VudGluZWw8U2VudGluZWxFbGVtZW50PigpO1xuICAgIC8vY29uc3QgeyB1c2VNZW51U2VudGluZWxQcm9wczogdXNlTGFzdFNlbnRpbmVsUHJvcHMgfSA9IHVzZU1lbnVTZW50aW5lbDxTZW50aW5lbEVsZW1lbnQ+KCk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPFBhcmVudERlcHRoQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17bXlEZXB0aH0+XG4gICAgICAgICAgICA8TWVudUl0ZW1Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PlxuICAgICAgICAgICAgICAgIHtyZW5kZXIoaW5mbyl9XG4gICAgICAgICAgICA8L01lbnVJdGVtQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9QYXJlbnREZXB0aENvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufSlcblxuLypcbmV4cG9ydCBmdW5jdGlvbiBNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7fTogTWVudUl0ZW1Qcm9wcykge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KE1lbnVJdGVtQ29udGV4dCk7XG5cbiAgICBjb25zdCBpbmZvID0gdXNlTWVudUl0ZW08TWVudUl0ZW1FbGVtZW50Pih7XG4gICAgICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHt9LFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGRpc2FibGVkLCBoaWRkZW4sIGluZGV4IH0sXG4gICAgICAgIG1lbnVJdGVtUGFyYW1ldGVyczogeyBkaXNhYmxlZCwgb25QcmVzcywgcm9sZSB9LFxuICAgICAgICBwcmVzc1BhcmFtZXRlcnM6IHsgZXhjbHVkZSwgZm9jdXNTZWxmIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczogeyBhcmlhUHJvcE5hbWUsIHNlbGVjdGlvbk1vZGUgfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczogeyB0ZXh0IH0sXG4gICAgfSlcbn0qL1xuXG5leHBvcnQgZnVuY3Rpb24gRGVtb01lbnUoKSB7XG4gICAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPE1lbnU8SFRNTERpdkVsZW1lbnQsIEhUTUxVTGlzdEVsZW1lbnQsIEhUTUxMSUVsZW1lbnQsIEhUTUxMSUVsZW1lbnQsIEhUTUxCdXR0b25FbGVtZW50PlxuICAgICAgICAgICAgY2xvc2VPbkJhY2tkcm9wPXt0cnVlfVxuICAgICAgICAgICAgY2xvc2VPbkVzY2FwZT17dHJ1ZX1cbiAgICAgICAgICAgIGNsb3NlT25Mb3N0Rm9jdXM9e3RydWV9XG4gICAgICAgICAgICBjb2xsYXRvcj17bnVsbH1cbiAgICAgICAgICAgIGRpc2FibGVBcnJvd0tleXM9e2ZhbHNlfVxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzPXtmYWxzZX1cbiAgICAgICAgICAgIGdldEluZGV4PXt2ID0+IHYucHJvcHMuaW5kZXh9XG4gICAgICAgICAgICBjb21wYXJlPXsobGhzLCByaHMpID0+IGxocy5pbmRleCAtIHJocy5pbmRleH1cbiAgICAgICAgICAgIGluaXRpYWxseVNlbGVjdGVkSW5kZXg9e251bGx9XG4gICAgICAgICAgICB1bnRhYmJhYmxlPXtmYWxzZX1cbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZD1cIndyYXBcIlxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ9XCJ3cmFwXCJcbiAgICAgICAgICAgIG5vVHlwZWFoZWFkPXtmYWxzZX1cbiAgICAgICAgICAgIG9wZW49e29wZW59XG4gICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRPcGVuKGZhbHNlKX1cbiAgICAgICAgICAgIG9uT3Blbj17KCkgPT4gc2V0T3Blbih0cnVlKX1cbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXg9e251bGx9XG4gICAgICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U9e251bGx9XG4gICAgICAgICAgICBvcGVuRGlyZWN0aW9uPVwiZG93blwiXG4gICAgICAgICAgICBvcmllbnRhdGlvbj1cInZlcnRpY2FsXCJcbiAgICAgICAgICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZT17MC4xfVxuICAgICAgICAgICAgcGFyZW50RGVwdGg9ezB9XG4gICAgICAgICAgICB0eXBlYWhlYWRUaW1lb3V0PXsxMDAwfVxuICAgICAgICAgICAgcmVuZGVyPXtpbmZvID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB7Li4uaW5mby5wcm9wc1RyaWdnZXJ9Pk9wZW4gbWVudTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAge2RlZmF1bHRSZW5kZXJQb3J0YWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcnRhbElkOiBcInBvcnRhbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiA8PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgey4uLmluZm8ucHJvcHNUYXJnZXR9PlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vTWVudUl0ZW0oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxNZW51SXRlbTxIVE1MTElFbGVtZW50PlxuICAgICAgICAgICAgZXhjbHVkZT17dW5kZWZpbmVkfVxuICAgICAgICAgICAgaGlkZGVuPXtmYWxzZX1cbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGU9XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICBvblByZXNzPXtub29wfVxuICAgICAgICAgICAgZ2V0U29ydFZhbHVlPXtyZXR1cm5OdWxsfVxuICAgICAgICAgICAgcmVuZGVyPXtpbmZvID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpIHsuLi5pbmZvLnByb3BzfT5MaXN0IGl0ZW0gKGluZGV4ICN7aW5kZXh9KTwvbGk+XG4gICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICByb2xlPVwibWVudWl0ZW1cIlxuICAgICAgICAgICAgYXJpYVByb3BOYW1lPVwiYXJpYS1zZWxlY3RlZFwiXG4gICAgICAgICAgICBkaXNhYmxlZD17ZmFsc2V9XG5cbiAgICAgICAgLz5cbiAgICApXG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cblxuLypcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyTWVudTxTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgU2VudGluZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgcG9ydGFsSWQsIHRhZ0J1dHRvbiwgdGFnTWVudSwgdGFnU3VyZmFjZSwgdGFnU2VudGluZWwsIG1ha2VQcm9wc0J1dHRvbiwgbWFrZVByb3BzTWVudSwgbWFrZVByb3BzU3VyZmFjZSwgbWFrZVByb3BzU2VudGluZWwgfTogeyBwb3J0YWxJZDogc3RyaW5nLCB0YWdTdXJmYWNlOiBFbGVtZW50VG9UYWc8U3VyZmFjZUVsZW1lbnQ+LCB0YWdNZW51OiBFbGVtZW50VG9UYWc8TWVudUVsZW1lbnQ+LCB0YWdCdXR0b246IEVsZW1lbnRUb1RhZzxCdXR0b25FbGVtZW50PiwgdGFnU2VudGluZWw6IEVsZW1lbnRUb1RhZzxTZW50aW5lbEVsZW1lbnQ+LCBtYWtlUHJvcHNTdXJmYWNlOiAoaW5mbzogVXNlTWVudVJldHVyblR5cGU8U3VyZmFjZUVsZW1lbnQsIE1lbnVFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxTdXJmYWNlRWxlbWVudD4sIG1ha2VQcm9wc01lbnU6IChpbmZvOiBVc2VNZW51UmV0dXJuVHlwZTxTdXJmYWNlRWxlbWVudCwgTWVudUVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVFbGVtZW50PiwgbWFrZVByb3BzQnV0dG9uOiAoaW5mbzogVXNlTWVudVJldHVyblR5cGU8U3VyZmFjZUVsZW1lbnQsIE1lbnVFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIFVzZU1lbnViYXJTdWJJbmZvPE1lbnVJdGVtRWxlbWVudD4+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCdXR0b25FbGVtZW50PiwgbWFrZVByb3BzU2VudGluZWw6IChpbmZvOiBVc2VNZW51UmV0dXJuVHlwZTxTdXJmYWNlRWxlbWVudCwgTWVudUVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgVXNlTWVudWJhclN1YkluZm88TWVudUl0ZW1FbGVtZW50Pj4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFNlbnRpbmVsRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWVudUluZm86IFVzZU1lbnVSZXR1cm5UeXBlPFN1cmZhY2VFbGVtZW50LCBNZW51RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBCdXR0b25FbGVtZW50LCBVc2VNZW51YmFyU3ViSW5mbzxNZW51SXRlbUVsZW1lbnQ+Pikge1xuXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IHN1cmZhY2VDaGlsZHJlbiwgLi4uc3VyZmFjZVByb3BzIH0gPSAobWFrZVByb3BzU3VyZmFjZShtZW51SW5mbykpO1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBtZW51Q2hpbGRyZW4sIC4uLm1lbnVQcm9wcyB9ID0gKG1ha2VQcm9wc01lbnUobWVudUluZm8pKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnQnV0dG9uIGFzIG5ldmVyLCAobWFrZVByb3BzQnV0dG9uKG1lbnVJbmZvKSkpfVxuICAgICAgICAgICAgICAgIHtkZWZhdWx0UmVuZGVyUG9ydGFsKHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydGFsSWQsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjcmVhdGVFbGVtZW50KHRhZ1N1cmZhY2UgYXMgbmV2ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN1cmZhY2VQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAoPD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdTZW50aW5lbCBhcyBuZXZlciwgKG1ha2VQcm9wc1NlbnRpbmVsKG1lbnVJbmZvKSkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdXJmYWNlQ2hpbGRyZW59XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnTWVudSBhcyBuZXZlciwgeyAuLi5tZW51UHJvcHMsIGNoaWxkcmVuOiA8PnttZW51Q2hpbGRyZW59PC8+IH0pfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ1NlbnRpbmVsIGFzIG5ldmVyLCAobWFrZVByb3BzU2VudGluZWwobWVudUluZm8pKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8Lz4pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgKVxuXG4gICAgfVxufSovXG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRm9jdXNhYmxlTGFiZWxFbGVtZW50LCBMYWJlbFBvc2l0aW9uIH0gZnJvbSBcInVzZS1sYWJlbFwiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyBSYWRpb0NvbnRleHQsIFJhZGlvU3ViSW5mbywgdXNlUmFkaW8sIHVzZVJhZGlvR3JvdXAsIFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzLCBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZSwgVXNlUmFkaW9QYXJhbWV0ZXJzLCBVc2VSYWRpb1JldHVyblR5cGUgfSBmcm9tIFwiLi4vdXNlLXJhZGlvLWdyb3VwXCI7XG5pbXBvcnQgeyBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVycyB9IGZyb20gXCIuL2NoZWNrYm94XCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiwgUGFydGlhbEV4Y2VwdCwgdXNlRGVmYXVsdCB9IGZyb20gXCIuL3V0aWxcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuaW50ZXJmYWNlIFJhZGlvR3JvdXBQcm9wc0Jhc2U8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgR3JvdXBFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQ+LCBcInJhZGlvR3JvdXBQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudD4sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50PiwgXCJsYWJlbFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50PiwgXCJyYWRpb0dyb3VwUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQ+LCBcInJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50PiwgXCJzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQ+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+IHtcbiAgICByZWY/OiBSZWY8VXNlUmFkaW9Hcm91cFJldHVyblR5cGU8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQ+Pjtcbn1cblxuaW50ZXJmYWNlIFJhZGlvUHJvcHNCYXNlPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgViBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gZXh0ZW5kc1xuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8TFAsIFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBSYWRpb1N1YkluZm88Rm9jdXNhYmxlTGFiZWxFbGVtZW50PExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFY+PiwgXCJyYWRpb1BhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVJhZGlvUGFyYW1ldGVyczxMUCwgViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJhZGlvU3ViSW5mbzxGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgVj4+LCBcImNoZWNrYm94TGlrZVBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVJhZGlvUGFyYW1ldGVyczxMUCwgViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJhZGlvU3ViSW5mbzxGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgVj4+LCBcImxhYmVsUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlUmFkaW9QYXJhbWV0ZXJzPExQLCBWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgUmFkaW9TdWJJbmZvPEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBWPj4sIFwicm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVJhZGlvUGFyYW1ldGVyczxMUCwgViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJhZGlvU3ViSW5mbzxGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgVj4+LCBcInByZXNzUGFyYW1ldGVyc1wiPixcbiAgICBPbWl0PEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8TFAsIFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBSYWRpb1N1YkluZm88Rm9jdXNhYmxlTGFiZWxFbGVtZW50PExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFY+PiwgXCJzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnNcIj4sIFwiZGlzYWJsZWRcIj4sXG4gICAgR2V0PFVzZVJhZGlvUGFyYW1ldGVyczxMUCwgViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFJhZGlvU3ViSW5mbzxGb2N1c2FibGVMYWJlbEVsZW1lbnQ8TFAsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgVj4+LCBcInRleHRDb250ZW50UGFyYW1ldGVyc1wiPixcbiAgICBPbWl0PEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8TFAsIFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBSYWRpb1N1YkluZm88Rm9jdXNhYmxlTGFiZWxFbGVtZW50PExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFY+PiwgXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCI+LCBcImRpc2FibGVkXCIgfCBcImdldFNvcnRWYWx1ZVwiPiB7XG4gICAgLy9yZWY/OiBSZWY8VXNlUmFkaW9SZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4+O1xuICAgIC8vc3ViSW5mbzogQztcblxufVxuXG5pbnRlcmZhY2UgUmFkaW9Hcm91cFByb3BzPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFBhcnRpYWxFeGNlcHQ8UmFkaW9Hcm91cFByb3BzQmFzZTxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudD4sIFwibmF2aWdhdGlvbkRpcmVjdGlvblwiIHwgXCJhcmlhTGFiZWxcIiB8IFwibmFtZVwiIHwgXCJzZWxlY3RlZFZhbHVlXCIgfCBcInNldFNlbGVjdGVkVmFsdWVcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZTxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuaW50ZXJmYWNlIFJhZGlvUHJvcHM8TFAgZXh0ZW5kcyBMYWJlbFBvc2l0aW9uLCBJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiBleHRlbmRzIFBhcnRpYWxFeGNlcHQ8UmFkaW9Qcm9wc0Jhc2U8TFAsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBWPiwgXCJpbmRleFwiIHwgXCJ2YWx1ZVwiIHwgXCJhcmlhTGFiZWxcIiB8IFwic2VsZWN0aW9uTW9kZVwiIHwgXCJsYWJlbFBvc2l0aW9uXCIgfCBcInRhZ0lucHV0XCIgfCBcInRhZ0xhYmVsXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlUmFkaW9SZXR1cm5UeXBlPExQLCBWLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgUmFkaW9TdWJJbmZvPEZvY3VzYWJsZUxhYmVsRWxlbWVudDxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBWPj4pOiBWTm9kZTxhbnk+O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyUmFkaW9Hcm91cDxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHcm91cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdHcm91cCwgdGFnTGFiZWwsIG1ha2VQcm9wc0dyb3VwLCBtYWtlUHJvcHNMYWJlbCB9OiB7IHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8R3JvdXBMYWJlbEVsZW1lbnQ+LCB0YWdHcm91cDogRWxlbWVudFRvVGFnPEdyb3VwRWxlbWVudD4sIG1ha2VQcm9wc0xhYmVsOiAoaW5mbzogVXNlUmFkaW9Hcm91cFJldHVyblR5cGU8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcm91cExhYmVsRWxlbWVudD4sIG1ha2VQcm9wc0dyb3VwOiAoaW5mbzogVXNlUmFkaW9Hcm91cFJldHVyblR5cGU8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcm91cEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVJhZGlvR3JvdXBSZXR1cm5UeXBlPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIFRhYmJhYmxlQ2hpbGRFbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdMYWJlbCBhcyBuZXZlciwgKG1ha2VQcm9wc0xhYmVsKGluZm8pKSl9XG4gICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnR3JvdXAgYXMgbmV2ZXIsIChtYWtlUHJvcHNHcm91cChpbmZvKSkpfVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmNvbnN0IFJhZGlvQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8UmFkaW9Db250ZXh0PGFueSwgYW55LCBhbnksIGFueT4+KG51bGwhKTtcbmV4cG9ydCBjb25zdCBSYWRpb0dyb3VwID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gUmFkaW9Hcm91cDxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHcm91cEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oe1xuICAgIHJlbmRlcixcbiAgICBuYW1lLFxuICAgIHNldFNlbGVjdGVkVmFsdWUsXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbixcbiAgICBub1R5cGVhaGVhZCxcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIGFyaWFMYWJlbCxcbiAgICBjb21wYXJlLFxuICAgIGdldEluZGV4LFxuICAgIG5hdmlnYXRlUGFzdEVuZCxcbiAgICBuYXZpZ2F0ZVBhc3RTdGFydCxcbiAgICBzZWxlY3RlZFZhbHVlLFxuICAgIHVudGFiYmFibGUsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZSxcbn06IFJhZGlvR3JvdXBQcm9wczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBUYWJiYWJsZUNoaWxkRWxlbWVudD4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgaW5mbyA9IHVzZVJhZGlvR3JvdXA8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgVGFiYmFibGVDaGlsZEVsZW1lbnQ+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RFbmQ6IG5hdmlnYXRlUGFzdEVuZCA/PyBcIndyYXBcIixcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdFN0YXJ0OiBuYXZpZ2F0ZVBhc3RTdGFydCA/PyBcIndyYXBcIixcbiAgICAgICAgICAgIGRpc2FibGVBcnJvd0tleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlQXJyb3dLZXlzXCIsIGRpc2FibGVBcnJvd0tleXMpLFxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUhvbWVFbmRLZXlzXCIsIGRpc2FibGVIb21lRW5kS2V5cyksXG4gICAgICAgICAgICBwYWdlTmF2aWdhdGlvblNpemU6IHVzZURlZmF1bHQoXCJwYWdlTmF2aWdhdGlvblNpemVcIiwgcGFnZU5hdmlnYXRpb25TaXplKVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbFBhcmFtZXRlcnM6IHsgYXJpYUxhYmVsIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgZ2V0SW5kZXg6IHVzZURlZmF1bHQoXCJnZXRJbmRleFwiLCBnZXRJbmRleCkgfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgY29tcGFyZTogY29tcGFyZSA/PyBudWxsIH0sXG4gICAgICAgIHJhZGlvR3JvdXBQYXJhbWV0ZXJzOiB7IG5hbWUsIHNldFNlbGVjdGVkVmFsdWUsIHNlbGVjdGVkVmFsdWUgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IG9uVGFiYmFibGVJbmRleENoYW5nZSA/PyBudWxsLFxuICAgICAgICAgICAgdW50YWJiYWJsZTogdW50YWJiYWJsZSA/PyBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY29sbGF0b3I6IHVzZURlZmF1bHQoXCJjb2xsYXRvclwiLCBjb2xsYXRvciksXG4gICAgICAgICAgICBub1R5cGVhaGVhZDogdXNlRGVmYXVsdChcIm5vVHlwZWFoZWFkXCIsIG5vVHlwZWFoZWFkKSxcbiAgICAgICAgICAgIHR5cGVhaGVhZFRpbWVvdXQ6IHVzZURlZmF1bHQoXCJ0eXBlYWhlYWRUaW1lb3V0XCIsIHR5cGVhaGVhZFRpbWVvdXQpXG4gICAgICAgIH0sXG4gICAgICAgIC8vIGNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyczogeyAgfSxcbiAgICAgICAgLy8gICAgICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IHsgIH1cbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8UmFkaW9Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PlxuICAgICAgICAgICAge3JlbmRlcihpbmZvKX1cbiAgICAgICAgPC9SYWRpb0NvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufSlcblxuLypleHBvcnQgaW50ZXJmYWNlIERlZmF1bHRSZW5kZXJSYWRpb1BhcmFtZXRlcnM8TFAgZXh0ZW5kcyBMYWJlbFBvc2l0aW9uLCBWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBJIGV4dGVuZHMgRWxlbWVudCwgSUwgZXh0ZW5kcyBFbGVtZW50LCBUQ0UgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIElMLCBVc2VSYWRpb1JldHVyblR5cGU8TFAsIFYsIEksIElMLCBUQ0UsIFJhZGlvU3ViSW5mbzxUQ0UsIFY+Pj4ge1xuXG59Ki9cbi8qXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclJhZGlvPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSUwgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVENFIGV4dGVuZHMgSSB8IElMPih7IHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZVByb3BzSW5wdXQsIG1ha2VQcm9wc0xhYmVsLCBsYWJlbFBvc2l0aW9uIH06IERlZmF1bHRSZW5kZXJSYWRpb1BhcmFtZXRlcnM8ViwgSSwgSUwsIFRDRT4pIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZTxJLCBJTCwgVXNlUmFkaW9SZXR1cm5UeXBlPFYsIEksIElMLCBUQ0UsIFJhZGlvU3ViSW5mbzxUQ0UsIFY+Pj4oeyBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIG1ha2VQcm9wc0lucHV0LCBtYWtlUHJvcHNMYWJlbCB9KTtcbn1cbiovXG5cbmV4cG9ydCBjb25zdCBSYWRpbyA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIFJhZGlvPExQIGV4dGVuZHMgTGFiZWxQb3NpdGlvbiwgViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGRpc2FibGVkLFxuICAgIGluZGV4LFxuICAgIHJlbmRlcixcbiAgICB2YWx1ZSxcbiAgICBhcmlhTGFiZWwsXG4gICAgZXhjbHVkZSxcbiAgICBmb2N1c1NlbGYsXG4gICAgbGFiZWxQb3NpdGlvbixcbiAgICBvblByZXNzU3luYyxcbiAgICBzZWxlY3Rpb25Nb2RlLFxuICAgIGhpZGRlbixcbiAgICB0YWdJbnB1dCxcbiAgICB0YWdMYWJlbCxcbiAgICBnZXRUZXh0XG59OiBSYWRpb1Byb3BzPExQLCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudCwgVj4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoUmFkaW9Db250ZXh0KTtcbiAgICBjb25zdCBnZXRWYWx1ZSA9IHVzZVN0YWJsZUdldHRlcih2YWx1ZSk7XG4gICAgY29uc3QgZGVmYXVsdEZvY3VzU2VsZiA9ICgpID0+IGluZm8uY2hlY2tib3hMaWtlUmV0dXJuLmZvY3VzU2VsZigpO1xuICAgIGNvbnN0IGluZm8gPSB1c2VSYWRpbzxMUCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQsIFY+KHtcbiAgICAgICAgLy9saXN0TmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgdGV4dCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiB7IGdldFNvcnRWYWx1ZTogZ2V0VmFsdWUgfSxcbiAgICAgICAgcmFkaW9QYXJhbWV0ZXJzOiB7IHZhbHVlIH0sXG4gICAgICAgIGNoZWNrYm94TGlrZVBhcmFtZXRlcnM6IHsgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlIH0sXG4gICAgICAgIGNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM6IHsgZ2V0VmFsdWUgfSxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgbGFiZWxQYXJhbWV0ZXJzOiB7IGFyaWFMYWJlbCwgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsIH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczogeyBleGNsdWRlLCBmb2N1c1NlbGY6IGZvY3VzU2VsZiA/PyBkZWZhdWx0Rm9jdXNTZWxmLCBvblByZXNzU3luYyB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IHsgc2VsZWN0aW9uTW9kZTogdXNlRGVmYXVsdChcInNlbGVjdGlvbk1vZGVcIiwgc2VsZWN0aW9uTW9kZSksIGRpc2FibGVkOiAhIWRpc2FibGVkIH0sXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogeyBnZXRUZXh0OiB1c2VEZWZhdWx0KFwiZ2V0VGV4dFwiLCBnZXRUZXh0KSB9XG4gICAgICAgIC8vcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IGhpZGRlbiwgZm9jdXNTZWxmLCBub01vZGlmeVRhYkluZGV4IH0sXG4gICAgICAgIC8vaGFzRm9jdXNQYXJhbWV0ZXJzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9LFxuICAgICAgICAvL3N1YkluZm9QYXJhbWV0ZXJzOiB7ICB9LFxuICAgICAgICAvL3NpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IHsgdW5zZWxlY3RhYmxlLCBmb2N1c1NlbGYgfVxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIC8vICAgIGNvbnN0IHsgdXNlUmFkaW9JbnB1dFByb3BzIH0gPSB1c2VSYWRpb0lucHV0KHsgdGFnOiB0YWdJbnB1dCB9KTtcbiAgICAvLyAgICBjb25zdCB7IHVzZVJhZGlvTGFiZWxQcm9wcyB9ID0gdXNlUmFkaW9MYWJlbCh7IHRhZzogdGFnTGFiZWwgfSk7XG5cbiAgICByZXR1cm4gcmVuZGVyKGluZm8pO1xufSlcblxuZXhwb3J0IGZ1bmN0aW9uIERlbW9SYWRpb0dyb3VwKHsgbmFtZSB9OiB7IG5hbWU6IHN0cmluZyB9KSB7XG4gICAgY29uc3QgW3NlbGVjdGVkVmFsdWUsIHNldFNlbGVjdGVkVmFsdWVdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbClcbiAgICByZXR1cm4gKFxuICAgICAgICA8UmFkaW9Hcm91cDxzdHJpbmcsIEhUTUxEaXZFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50LCBIVE1MSW5wdXRFbGVtZW50PlxuXG4gICAgICAgICAgICBhcmlhTGFiZWw9e251bGx9XG4gICAgICAgICAgICBjb2xsYXRvcj17bnVsbH1cbiAgICAgICAgICAgIGNvbXBhcmU9eygobGhzLCByaHMpID0+IGxocy5pbmRleCAtIHJocy5pbmRleCl9XG4gICAgICAgICAgICBnZXRJbmRleD17diA9PiB2LnByb3BzLmluZGV4fVxuICAgICAgICAgICAgbmFtZT17bmFtZX1cbiAgICAgICAgICAgIG5vVHlwZWFoZWFkPXtmYWxzZX1cbiAgICAgICAgICAgIGRpc2FibGVBcnJvd0tleXM9e2ZhbHNlfVxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzPXtmYWxzZX1cbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZD1cIndyYXBcIlxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ9XCJ3cmFwXCJcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWU9XCJhXCJcbiAgICAgICAgICAgIG5hdmlnYXRpb25EaXJlY3Rpb249XCJ2ZXJ0aWNhbFwiXG4gICAgICAgICAgICBzZXRTZWxlY3RlZFZhbHVlPXtlID0+IHNldFNlbGVjdGVkVmFsdWUoZSl9XG4gICAgICAgICAgICByZW5kZXI9e2luZm8gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCB7Li4uaW5mby5wcm9wc1JhZGlvR3JvdXBMYWJlbH0+UmFkaW8gZ3JvdXA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgey4uLmluZm8ucHJvcHNSYWRpb0dyb3VwfT5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH19XG5cblxuICAgICAgICAvPlxuICAgIClcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyBTbGlkZXJDb250ZXh0LCBTbGlkZXJUaHVtYkluZm8sIHVzZVNsaWRlciwgVXNlU2xpZGVyUGFyYW1ldGVycywgVXNlU2xpZGVyUmV0dXJuVHlwZSwgdXNlU2xpZGVyVGh1bWIsIFVzZVNsaWRlclRodW1iLCBVc2VTbGlkZXJUaHVtYlBhcmFtZXRlcnMsIFVzZVNsaWRlclRodW1iUmV0dXJuVHlwZSB9IGZyb20gXCIuLi91c2Utc2xpZGVyXCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiB9IGZyb20gXCIuL3V0aWxcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJQcm9wcyBleHRlbmRzIEdldDxVc2VTbGlkZXJQYXJhbWV0ZXJzPFNsaWRlclRodW1iSW5mbz4sIFwibWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyc1wiPiwgR2V0PFVzZVNsaWRlclBhcmFtZXRlcnM8U2xpZGVyVGh1bWJJbmZvPiwgXCJzbGlkZXJQYXJhbWV0ZXJzXCI+IHtcbiAgICBjaGlsZHJlbjogQ29tcG9uZW50Q2hpbGRyZW47XG4gICAgcmVmPzogUmVmPFVzZVNsaWRlclJldHVyblR5cGU8U2xpZGVyVGh1bWJJbmZvPj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGh1bWJQcm9wczxUaHVtYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIEdldDxVc2VTbGlkZXJUaHVtYlBhcmFtZXRlcnM8VGh1bWJFbGVtZW50LCBTbGlkZXJUaHVtYkluZm8+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4sIEdldDxVc2VTbGlkZXJUaHVtYlBhcmFtZXRlcnM8VGh1bWJFbGVtZW50LCBTbGlkZXJUaHVtYkluZm8+LCBcInNsaWRlclRodW1iUGFyYW1ldGVyc1wiPiB7XG4gICAgLy9zdWJJbmZvOiBHZXQ8VXNlU2xpZGVyVGh1bWJQYXJhbWV0ZXJzPFRodW1iRWxlbWVudCwgU2xpZGVyVGh1bWJJbmZvPiwgXCJzdWJJbmZvXCI+O1xuICAgIC8vcmVmPzogUmVmPFVzZVNsaWRlclRodW1iUmV0dXJuVHlwZTxUaHVtYkVsZW1lbnQsIFNsaWRlclRodW1iSW5mbz4+O1xuICAgIHJlbmRlcihpbmZvOiBVc2VTbGlkZXJUaHVtYlJldHVyblR5cGU8VGh1bWJFbGVtZW50LCBTbGlkZXJUaHVtYkluZm8+KTogVk5vZGU7XG59XG5cbmNvbnN0IFNsaWRlclRodW1iQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8U2xpZGVyQ29udGV4dDxhbnk+PihudWxsISk7XG5cbmV4cG9ydCBjb25zdCBTbGlkZXIgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBTbGlkZXI8U2xpZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbWF4LCBtaW4sIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlLCBjaGlsZHJlbiB9OiBTbGlkZXJQcm9wcywgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBpbmZvID0gdXNlU2xpZGVyKHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxuICAgICAgICBzbGlkZXJQYXJhbWV0ZXJzOiB7IG1heCwgbWluIH1cbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8U2xpZGVyVGh1bWJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PntjaGlsZHJlbn08L1NsaWRlclRodW1iQ29udGV4dC5Qcm92aWRlcj5cbiAgICApO1xufSlcblxuZXhwb3J0IGNvbnN0IFNsaWRlclRodW1iID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gU2xpZGVyVGh1bWJVPFRodW1iRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbGFiZWwsIHRhZywgdmFsdWUsIG1heCwgbWluLCBvblZhbHVlQ2hhbmdlLCBpbmRleCwgcmVuZGVyLCB2YWx1ZVRleHQgfTogU2xpZGVyVGh1bWJQcm9wczxUaHVtYkVsZW1lbnQ+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGNvbnRleHQgPSAodXNlQ29udGV4dChTbGlkZXJUaHVtYkNvbnRleHQpIGFzIFNsaWRlckNvbnRleHQ8U2xpZGVyVGh1bWJJbmZvPilcbiAgICBcbiAgICBjb25zdCBpbmZvID0gdXNlU2xpZGVyVGh1bWIoe1xuICAgICAgICBjb250ZXh0LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHNsaWRlclRodW1iUGFyYW1ldGVyczogeyBsYWJlbCwgdGFnLCB2YWx1ZSwgbWF4LCBtaW4sIG9uVmFsdWVDaGFuZ2UsIHZhbHVlVGV4dCB9LFxuICAgICAgICAvL3N1YkluZm9cbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG5cbiAgICByZXR1cm4gcmVuZGVyKGluZm8pO1xufSlcblxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclNsaWRlclRodW1iPEUgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RodW1iLCBtYWtlUHJvcHNUaHVtYiB9OiB7IHRhZ1RodW1iOiBFbGVtZW50VG9UYWc8RT4sIG1ha2VQcm9wc1RodW1iOiAoaW5mbzogVXNlU2xpZGVyVGh1bWJSZXR1cm5UeXBlPEUsIFNsaWRlclRodW1iSW5mbz4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVNsaWRlclRodW1iUmV0dXJuVHlwZTxFLCBTbGlkZXJUaHVtYkluZm8+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RodW1iIGFzIG5ldmVyLCAobWFrZVByb3BzVGh1bWIoaW5mbykpKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlSW1wZXJhdGl2ZUhhbmRsZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VUYWJsZSwgVXNlVGFibGVDZWxsUGFyYW1ldGVycywgVXNlVGFibGVSb3dQYXJhbWV0ZXJzLCBVc2VUYWJsZVNlY3Rpb25Db250ZXh0LCB1c2VUYWJsZUNlbGwsIHVzZVRhYmxlUm93LCB1c2VUYWJsZVNlY3Rpb24sIFVzZVRhYmxlU2VjdGlvblBhcmFtZXRlcnMsIFVzZVRhYmxlUGFyYW1ldGVycywgVGFibGVSb3dJbmZvLCBVc2VUYWJsZVJvd1JldHVyblR5cGUsIFVzZVRhYmxlQ2VsbFJldHVyblR5cGUsIFVzZVRhYmxlU2VjdGlvblJldHVyblR5cGUsIFVzZVRhYmxlUmV0dXJuVHlwZSwgVGFibGVDZWxsSW5mbywgVXNlVGFibGVSb3dDb250ZXh0IH0gZnJvbSBcIi4uL3VzZS10YWJsZVwiO1xuaW1wb3J0IHsgbWVtb0ZvcndhcmRSZWYsIFBhcnRpYWxFeGNlcHQsIHVzZURlZmF1bHQgfSBmcm9tIFwiLi91dGlsXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcblxuaW50ZXJmYWNlIFRhYmxlUHJvcHNCYXNlPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlVGFibGVQYXJhbWV0ZXJzPFRhYmxlRWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJsYWJlbFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYmxlUGFyYW1ldGVyczxUYWJsZUVsZW1lbnQsIExhYmVsRWxlbWVudD4sIFwidGFibGVQYXJhbWV0ZXJzXCI+IHtcbiAgICByZWY/OiBSZWY8VXNlVGFibGVSZXR1cm5UeXBlPFRhYmxlRWxlbWVudCwgTGFiZWxFbGVtZW50Pj47XG59XG5cbmludGVyZmFjZSBUYWJsZVNlY3Rpb25Qcm9wc0Jhc2U8U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSTSBleHRlbmRzIFRhYmxlUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIENNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxDZWxsRWxlbWVudD4+IGV4dGVuZHNcbiAgICBHZXQ8VXNlVGFibGVTZWN0aW9uUGFyYW1ldGVyczxTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPiwgXCJncmlkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYmxlU2VjdGlvblBhcmFtZXRlcnM8U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTT4sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYmxlU2VjdGlvblBhcmFtZXRlcnM8U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTT4sIFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFibGVTZWN0aW9uUGFyYW1ldGVyczxTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPiwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYmxlU2VjdGlvblBhcmFtZXRlcnM8U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTT4sIFwic2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFibGVTZWN0aW9uUGFyYW1ldGVyczxTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPiwgXCJzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFibGVTZWN0aW9uUGFyYW1ldGVyczxTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNPiwgXCJ0YWJsZVNlY3Rpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUYWJsZVNlY3Rpb25QYXJhbWV0ZXJzPFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+IHtcbiAgICByZWY/OiBSZWY8VXNlVGFibGVTZWN0aW9uUmV0dXJuVHlwZTxTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4+O1xufVxuXG5pbnRlcmZhY2UgVGFibGVSb3dQcm9wc0Jhc2U8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBUYWJsZVJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzXG4gICAgT21pdDxHZXQ8VXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+LCBcInRhYmxlUm93UGFyYW1ldGVyc1wiPiwgXCJsb2NhdGlvblwiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJhc0NoaWxkUm93UGFyYW1ldGVyc1wiLCBcInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJhc0NoaWxkUm93UGFyYW1ldGVyc1wiLCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0MjxVc2VUYWJsZVJvd1BhcmFtZXRlcnM8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4sIFwiYXNDaGlsZFJvd1BhcmFtZXRlcnNcIiwgXCJzb3J0YWJsZUNoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJhc0NoaWxkUm93UGFyYW1ldGVyc1wiLCBcInJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDI8VXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+LCBcImFzQ2hpbGRSb3dQYXJhbWV0ZXJzXCIsIFwidGV4dENvbnRlbnRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDI8VXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+LCBcImFzUGFyZW50Um93UGFyYW1ldGVyc1wiLCBcImxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDI8VXNlVGFibGVSb3dQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+LCBcImFzUGFyZW50Um93UGFyYW1ldGVyc1wiLCBcInJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc1wiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPiwgXCJhc1BhcmVudFJvd1BhcmFtZXRlcnNcIiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZVRhYmxlUm93UmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPj47XG59XG5cbmludGVyZmFjZSBUYWJsZUNlbGxQcm9wc0Jhc2U8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzXG4gICAgR2V0PFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIENNPiwgXCJ0YWJsZUNlbGxQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUYWJsZUNlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50LCBDTT4sIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgQ00+LCBcImdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIENNPiwgXCJyb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgQ00+LCBcInByZXNzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgQ00+LCBcInRleHRDb250ZW50UGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZVRhYmxlQ2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQsIENNPj47XG59XG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVByb3BzPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVGFibGVQcm9wc0Jhc2U8VGFibGVFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlVGFibGVSZXR1cm5UeXBlPFRhYmxlRWxlbWVudCwgTGFiZWxFbGVtZW50Pik6IFZOb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlU2VjdGlvblByb3BzPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBUYWJsZVJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIFRhYmxlU2VjdGlvblByb3BzQmFzZTxTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VUYWJsZVNlY3Rpb25SZXR1cm5UeXBlPFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUk0sIENNPik6IFZOb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlUm93UHJvcHM8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBUYWJsZVJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIFRhYmxlUm93UHJvcHNCYXNlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlVGFibGVSb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+KTogVk5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVDZWxsUHJvcHM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+PiBleHRlbmRzIFBhcnRpYWxFeGNlcHQ8VGFibGVDZWxsUHJvcHNCYXNlPENlbGxFbGVtZW50LCBDTT4sIFwidGFnVGFibGVDZWxsXCIgfCBcImluZGV4XCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlVGFibGVDZWxsUmV0dXJuVHlwZTxDZWxsRWxlbWVudCwgQ00+KTogVk5vZGU7XG59XG5cbi8vY29uc3QgTG9jYXRpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxcImhlYWRcIiB8IFwiYm9keVwiIHwgXCJmb290XCI+KG51bGwhKTtcblxuY29uc3QgVGFibGVTZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVGFibGVTZWN0aW9uQ29udGV4dDxhbnksIGFueSwgYW55LCBUYWJsZVJvd0luZm88YW55LCBhbnk+LCBUYWJsZUNlbGxJbmZvPGFueT4+PihudWxsISk7XG5jb25zdCBUYWJsZVJvd0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRhYmxlUm93Q29udGV4dDxhbnksIGFueSwgVGFibGVDZWxsSW5mbzxhbnk+Pj4obnVsbCEpO1xuLy9jb25zdCBUYWJsZVJvd0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRhYmxlUm93PGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+PihudWxsISk7XG4vL2NvbnN0IFRhYmxlQ2VsbENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRhYmxlQ2VsbDxhbnksIGFueSwgYW55Pj4obnVsbCEpO1xuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGU8VGFibGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUYWJsZSwgbWFrZVByb3BzVGFibGUgfTogeyB0YWdUYWJsZTogRWxlbWVudFRvVGFnPFRhYmxlRWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlOiAoaW5mbzogVXNlVGFibGVSZXR1cm5UeXBlPFRhYmxlRWxlbWVudCwgTGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUYWJsZVJldHVyblR5cGU8VGFibGVFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlIGFzIG5ldmVyLCAobWFrZVByb3BzVGFibGUoaW5mbykpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZVNlY3Rpb248VGFibGVCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJNIGV4dGVuZHMgVGFibGVSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgQ00gZXh0ZW5kcyBUYWJsZUNlbGxJbmZvPENlbGxFbGVtZW50Pj4oeyB0YWdUYWJsZUJvZHksIG1ha2VQcm9wc1RhYmxlQm9keSB9OiB7IHRhZ1RhYmxlQm9keTogRWxlbWVudFRvVGFnPFRhYmxlQm9keUVsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZUJvZHk6IChpbmZvOiBVc2VUYWJsZVNlY3Rpb25SZXR1cm5UeXBlPFRhYmxlQm9keUVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUJvZHlFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUYWJsZVNlY3Rpb25SZXR1cm5UeXBlPFRhYmxlQm9keUVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+LCBtb2RpZnlQcm9wc1RhYmxlQm9keTogUHJvcE1vZGlmaWVyPFRhYmxlQm9keUVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlQm9keSBhcyBuZXZlciwgbW9kaWZ5UHJvcHNUYWJsZUJvZHkobWFrZVByb3BzVGFibGVCb2R5KGluZm8pKSk7XG4gICAgfVxufVxuLypcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGVIZWFkPFRhYmxlSGVhZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RhYmxlSGVhZCwgbWFrZVByb3BzVGFibGVIZWFkIH06IHsgdGFnVGFibGVIZWFkOiBFbGVtZW50VG9UYWc8VGFibGVIZWFkRWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlSGVhZDogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVIZWFkRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kaWZ5UHJvcHNUYWJsZUhlYWQ6IFByb3BNb2RpZmllcjxUYWJsZUhlYWRFbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJsZUhlYWQgYXMgbmV2ZXIsIG1vZGlmeVByb3BzVGFibGVIZWFkKG1ha2VQcm9wc1RhYmxlSGVhZCgpKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlRm9vdDxUYWJsZUZvb3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUYWJsZUZvb3QsIG1ha2VQcm9wc1RhYmxlRm9vdCB9OiB7IHRhZ1RhYmxlRm9vdDogRWxlbWVudFRvVGFnPFRhYmxlRm9vdEVsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZUZvb3Q6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlRm9vdEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZGlmeVByb3BzVGFibGVGb290OiBQcm9wTW9kaWZpZXI8VGFibGVGb290RWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFibGVGb290IGFzIG5ldmVyLCBtb2RpZnlQcm9wc1RhYmxlRm9vdChtYWtlUHJvcHNUYWJsZUZvb3QoKSkpO1xuICAgIH1cbn0qL1xuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGVSb3c8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUk0gZXh0ZW5kcyBUYWJsZVJvd0luZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBDTSBleHRlbmRzIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pih7IHRhZ1RhYmxlUm93LCBtYWtlUHJvcHNUYWJsZVJvdyB9OiB7IHRhZ1RhYmxlUm93OiBFbGVtZW50VG9UYWc8Um93RWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlUm93OiAoaW5mbzogVXNlVGFibGVSb3dSZXR1cm5UeXBlPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSTSwgQ00+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUYWJsZVJvd1JldHVyblR5cGU8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJNLCBDTT4sIG1vZGlmeVByb3BzVGFibGVSb3c6IFByb3BNb2RpZmllcjxSb3dFbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJsZVJvdyBhcyBuZXZlciwgbW9kaWZ5UHJvcHNUYWJsZVJvdyhtYWtlUHJvcHNUYWJsZVJvdyhpbmZvKSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlQ2VsbDxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENNIGV4dGVuZHMgVGFibGVDZWxsSW5mbzxDZWxsRWxlbWVudD4+KHsgdGFnVGFibGVDZWxsLCBtYWtlUHJvcHNUYWJsZUNlbGwgfTogeyB0YWdUYWJsZUNlbGw6IEVsZW1lbnRUb1RhZzxDZWxsRWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlQ2VsbDogKGluZm86IFVzZVRhYmxlQ2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQsIENNPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVRhYmxlQ2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQsIENNPikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJsZUNlbGwgYXMgbmV2ZXIsIChtYWtlUHJvcHNUYWJsZUNlbGwoaW5mbykpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBUYWJsZSA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIFRhYmxlVTxUYWJsZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgYXJpYUxhYmVsLFxuICAgIHNlbGVjdGlvbkxpbWl0LFxuICAgIHRhZ1RhYmxlLFxuICAgIHJlbmRlclxufTogVGFibGVQcm9wczxUYWJsZUVsZW1lbnQsIExhYmVsRWxlbWVudD4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgaW5mbyA9IHVzZVRhYmxlPFRhYmxlRWxlbWVudCwgTGFiZWxFbGVtZW50Pih7XG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczogeyBhcmlhTGFiZWwgfSxcbiAgICAgICAgdGFibGVQYXJhbWV0ZXJzOiB7IHNlbGVjdGlvbkxpbWl0LCB0YWdUYWJsZSB9XG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pO1xuXG4gICAgcmV0dXJuIChyZW5kZXIoaW5mbykpXG59KVxuXG5leHBvcnQgY29uc3QgVGFibGVTZWN0aW9uID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gVGFibGVTZWN0aW9uPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGNvbGxhdG9yLFxuICAgIGNvbXBhcmUsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgZ2V0SW5kZXgsXG4gICAgaW5pdGlhbGx5U2VsZWN0ZWRJbmRleCxcbiAgICB1bnRhYmJhYmxlLFxuICAgIG5hdmlnYXRlUGFzdEVuZCxcbiAgICBuYXZpZ2F0ZVBhc3RTdGFydCxcbiAgICBub1R5cGVhaGVhZCxcbiAgICBzZXRTZWxlY3RlZEluZGV4LFxuICAgIG9uVGFiYmFibGVDb2x1bW5DaGFuZ2UsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZSxcbiAgICByZW5kZXIsXG4gICAgdGFnVGFibGVTZWN0aW9uLFxuICAgIHR5cGVhaGVhZFRpbWVvdXRcbn06IFRhYmxlU2VjdGlvblByb3BzPFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgVGFibGVSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgVGFibGVDZWxsSW5mbzxDZWxsRWxlbWVudD4+KSB7XG4gICAgY29uc3QgaW5mbyA9IHVzZVRhYmxlU2VjdGlvbjxTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFRhYmxlUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pih7XG4gICAgICAgIGdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBvblRhYmJhYmxlQ29sdW1uQ2hhbmdlIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGVQYXN0RW5kLCBuYXZpZ2F0ZVBhc3RTdGFydCwgcGFnZU5hdmlnYXRpb25TaXplIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgZ2V0SW5kZXggfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IG9uVGFiYmFibGVJbmRleENoYW5nZSwgdW50YWJiYWJsZSB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzOiB7IGluaXRpYWxseVNlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXggfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgY29tcGFyZSB9LFxuICAgICAgICB0YWJsZVNlY3Rpb25QYXJhbWV0ZXJzOiB7IHRhZ1RhYmxlU2VjdGlvbiB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8VGFibGVTZWN0aW9uQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17aW5mby5jb250ZXh0fT5cbiAgICAgICAgICAgIHtyZW5kZXIoaW5mbyl9XG4gICAgICAgIDwvVGFibGVTZWN0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59KTtcbi8qXG5leHBvcnQgY29uc3QgVGFibGVCb2R5ID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gVGFibGVCb2R5VTxTZWN0aW9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDUiA9IHVuZGVmaW5lZCwgQ0MgPSB1bmRlZmluZWQsIEtSIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KHsgcmVuZGVyIH06IFRhYmxlQm9keVByb3BzPFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsZW1lbnQsIENSLCBDQywgS1I+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IHsgdXNlVGFibGVCb2R5UHJvcHMsIC4uLnNlY3Rpb25JbmZvIH0gPSB1c2VDb250ZXh0KFRhYmxlQm9keUNvbnRleHQpKHt9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gc2VjdGlvbkluZm8pO1xuXG4gICAgcmV0dXJuIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9XCJib2R5XCI+e3JlbmRlcihzZWN0aW9uSW5mbywgdXNlVGFibGVCb2R5UHJvcHMpfTwvTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyPlxufSlcblxuZXhwb3J0IGNvbnN0IFRhYmxlSGVhZCA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIFRhYmxlSGVhZFU8VCBleHRlbmRzIEVsZW1lbnQ+KHsgcmVuZGVyLCB0YWdUYWJsZUhlYWQgfTogVGFibGVIZWFkUHJvcHM8VD4pIHtcbiAgICBjb25zdCB1c2VUYWJsZVNlY3Rpb25Qcm9wc0Jhc2UgPSB1c2VDb250ZXh0KFRhYmxlU2VjdGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IHVzZVRhYmxlU2VjdGlvblByb3BzOiBQcm9wTW9kaWZpZXI8VD4gPSAocHJvcHMpID0+IHVzZVRhYmxlU2VjdGlvblByb3BzQmFzZSh0YWdUYWJsZUhlYWQsIFwiaGVhZFwiLCBwcm9wcyk7XG4gICAgcmV0dXJuIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9XCJoZWFkXCI+eyhyZW5kZXIodXNlVGFibGVTZWN0aW9uUHJvcHMpKX08L0xvY2F0aW9uQ29udGV4dC5Qcm92aWRlcj5cbn0pXG5cbmV4cG9ydCBjb25zdCBUYWJsZUZvb3QgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBUYWJsZUZvb3RVPFQgZXh0ZW5kcyBFbGVtZW50Pih7IHJlbmRlciwgdGFnVGFibGVGb290IH06IFRhYmxlRm9vdFByb3BzPFQ+KSB7XG4gICAgY29uc3QgdXNlVGFibGVTZWN0aW9uUHJvcHNCYXNlID0gdXNlQ29udGV4dChUYWJsZVNlY3Rpb25Db250ZXh0KTtcbiAgICBjb25zdCB1c2VUYWJsZVNlY3Rpb25Qcm9wczogUHJvcE1vZGlmaWVyPFQ+ID0gKHByb3BzKSA9PiB1c2VUYWJsZVNlY3Rpb25Qcm9wc0Jhc2UodGFnVGFibGVGb290LCBcImZvb3RcIiwgcHJvcHMpO1xuICAgIHJldHVybiA8TG9jYXRpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPVwiZm9vdFwiPnsocmVuZGVyKHVzZVRhYmxlU2VjdGlvblByb3BzKSl9PC9Mb2NhdGlvbkNvbnRleHQuUHJvdmlkZXI+XG59KSovXG5cbmV4cG9ydCBjb25zdCBUYWJsZVJvdyA9IG1lbW9Gb3J3YXJkUmVmKGZ1bmN0aW9uIFRhYmxlUm93VTxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluZGV4LFxuICAgIGdldFRleHQsXG4gICAgdGFnVGFibGVSb3csXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgYXJpYVByb3BOYW1lLFxuICAgIGRpc2FibGVkLFxuICAgIHVudGFiYmFibGUsXG4gICAgbmF2aWdhdGVQYXN0RW5kLFxuICAgIG5hdmlnYXRlUGFzdFN0YXJ0LFxuICAgIHNlbGVjdGVkLFxuICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgZ2V0U29ydFZhbHVlLFxuICAgIGhpZGRlbixcblxuICAgIHJlbmRlclxufTogVGFibGVSb3dQcm9wczxSb3dFbGVtZW50LCBDZWxsZW1lbnQsIFRhYmxlUm93SW5mbzxSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCBUYWJsZUNlbGxJbmZvPENlbGxlbWVudD4+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGN4MSA9IHVzZUNvbnRleHQoVGFibGVTZWN0aW9uQ29udGV4dCk7XG4gICAgY29uc3QgaW5mbyA9IHVzZVRhYmxlUm93PFJvd0VsZW1lbnQsIENlbGxlbWVudCwgVGFibGVSb3dJbmZvPFJvd0VsZW1lbnQsIENlbGxlbWVudD4sIFRhYmxlQ2VsbEluZm88Q2VsbGVtZW50Pj4oe1xuICAgICAgICBhc0NoaWxkUm93UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM6IHt9LFxuICAgICAgICAgICAgY29udGV4dDogY3gxLFxuICAgICAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IHsgaGlkZGVuOiBoaWRkZW4gPz8gZmFsc2UgfSxcbiAgICAgICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiB7IGdldFNvcnRWYWx1ZSB9LFxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IGFyaWFQcm9wTmFtZSwgc2VsZWN0aW9uTW9kZSwgZGlzYWJsZWQgfSxcbiAgICAgICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogeyBnZXRUZXh0IH1cbiAgICAgICAgfSxcbiAgICAgICAgYXNQYXJlbnRSb3dQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRlUGFzdEVuZCwgbmF2aWdhdGVQYXN0U3RhcnQgfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIHVudGFiYmFibGUgfSxcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9XG4gICAgICAgIH0sXG4gICAgICAgIHRhYmxlUm93UGFyYW1ldGVyczogeyBzZWxlY3RlZCwgdGFnVGFibGVSb3cgfVxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiA8VGFibGVSb3dDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtpbmZvLmNvbnRleHR9PntyZW5kZXIoaW5mbyl9PC9UYWJsZVJvd0NvbnRleHQuUHJvdmlkZXI+XG59KVxuXG5leHBvcnQgY29uc3QgVGFibGVDZWxsID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gVGFibGVDZWxsPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluZGV4LFxuICAgIGdldFRleHQsXG4gICAgZm9jdXNTZWxmLFxuICAgIGhpZGRlbixcbiAgICB0YWdUYWJsZUNlbGwsXG4gICAgcmVuZGVyLFxuICAgIGNvbFNwYW4sXG4gICAgZXhjbHVkZSxcbiAgICBvblByZXNzU3luYyxcbn06IFRhYmxlQ2VsbFByb3BzPENlbGxFbGVtZW50LCBUYWJsZUNlbGxJbmZvPENlbGxFbGVtZW50Pj4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgY29udGV4dCA9ICh1c2VDb250ZXh0KFRhYmxlUm93Q29udGV4dCkgYXMgVXNlVGFibGVSb3dDb250ZXh0PGFueSwgQ2VsbEVsZW1lbnQsIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pik7XG4gICAgY29uc3QgZm9jdXNTZWxmRGVmYXVsdCA9IHVzZUNhbGxiYWNrKChlOiBhbnkpID0+IHsgZT8uZm9jdXMoKTsgfSwgW10pO1xuICAgIGNvbnN0IGluZm8gPSB1c2VUYWJsZUNlbGw8Q2VsbEVsZW1lbnQsIFRhYmxlQ2VsbEluZm88Q2VsbEVsZW1lbnQ+Pih7XG4gICAgICAgIGNvbXBsZXRlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczoge30sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM6IHsgY29sU3BhbjogY29sU3BhbiA/PyAxIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IHsgaGlkZGVuOiBoaWRkZW4gPz8gZmFsc2UgfSxcbiAgICAgICAgcHJlc3NQYXJhbWV0ZXJzOiB7IGV4Y2x1ZGUsIGZvY3VzU2VsZjogZm9jdXNTZWxmID8/IGZvY3VzU2VsZkRlZmF1bHQsIG9uUHJlc3NTeW5jIH0sXG4gICAgICAgIHRhYmxlQ2VsbFBhcmFtZXRlcnM6IHsgdGFnVGFibGVDZWxsIH0sXG4gICAgICAgIHRleHRDb250ZW50UGFyYW1ldGVyczogeyBnZXRUZXh0OiB1c2VEZWZhdWx0KFwiZ2V0VGV4dFwiLCBnZXRUZXh0KSB9LFxuICAgICAgICAvKiBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXG4gICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXG4gICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbiwgbm9Nb2RpZnlUYWJJbmRleCB9LFxuICAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH0sXG4gICAgICAgICBzdWJJbmZvLFxuICAgICAgICAgdGFibGVDZWxsOiB7XG4gICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgaGVhZGVyVHlwZSxcbiAgICAgICAgICAgICB0YWdUYWJsZUNlbGwsXG4gICAgICAgICAgICAgbG9jYXRpb246IHVzZUNvbnRleHQoTG9jYXRpb25Db250ZXh0KVxuICAgICAgICAgfSovXG4gICAgfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pO1xuXG4gICAgcmV0dXJuIHJlbmRlcihpbmZvKTtcbn0pXG5cbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFJlZiwgcmVuZGVyLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwiLi4vcHJvcHNcIjtcbmltcG9ydCB7IFRhYnNDb250ZXh0LCBVc2VUYWIsIFVzZVRhYlBhbmVsLCBVc2VUYWJQYW5lbFBhcmFtZXRlcnMsIFVzZVRhYlBhcmFtZXRlcnMsIHVzZVRhYnMsIFVzZVRhYnNQYXJhbWV0ZXJzLCBUYWJQYW5lbHNDb250ZXh0LCBVc2VUYWJzUmV0dXJuVHlwZSwgdXNlVGFiLCBVc2VUYWJSZXR1cm5UeXBlLCBVc2VUYWJQYW5lbFJldHVyblR5cGUsIHVzZVRhYlBhbmVsIH0gZnJvbSBcIi4uL3VzZS10YWJzXCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiwgUGFydGlhbEV4Y2VwdCwgdXNlRGVmYXVsdCB9IGZyb20gXCIuL3V0aWxcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcbnR5cGUgR2V0MjxULCBLIGV4dGVuZHMga2V5b2YgVCwgSzIgZXh0ZW5kcyBrZXlvZiBUW0tdPiA9IFRbS11bSzJdO1xuXG5pbnRlcmZhY2UgVGFic1Byb3BzQmFzZTxUYWJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlVGFic1BhcmFtZXRlcnM8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudCwgVGFiTGFiZWxFbGVtZW50PiwgXCJsYWJlbFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYnNQYXJhbWV0ZXJzPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudD4sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYnNQYXJhbWV0ZXJzPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudD4sIFwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFic1BhcmFtZXRlcnM8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudCwgVGFiTGFiZWxFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYnNQYXJhbWV0ZXJzPFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkxhYmVsRWxlbWVudD4sIFwic2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFic1BhcmFtZXRlcnM8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudCwgVGFiTGFiZWxFbGVtZW50PiwgXCJzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFic1BhcmFtZXRlcnM8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudCwgVGFiTGFiZWxFbGVtZW50PiwgXCJ0YWJzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFic1BhcmFtZXRlcnM8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudCwgVGFiTGFiZWxFbGVtZW50PiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiPiB7XG59XG5cbmludGVyZmFjZSBUYWJQcm9wc0Jhc2U8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcInByZXNzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwic29ydGFibGVDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwidGV4dENvbnRlbnRQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcImNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnNcIj4ge1xufVxuXG5pbnRlcmZhY2UgVGFiUGFuZWxQcm9wc0Jhc2U8UGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VUYWJQYW5lbFBhcmFtZXRlcnMsIFwibWFuYWdlZENoaWxkUGFyYW1ldGVyc1wiPiB7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFic1Byb3BzPFRhYkNvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PFRhYnNQcm9wc0Jhc2U8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudCwgVGFiTGFiZWxFbGVtZW50PiwgXCJvcmllbnRhdGlvblwiIHwgXCJncm91cGluZ1R5cGVcIiB8IFwiYXJpYUxhYmVsXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlVGFic1JldHVyblR5cGU8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudCwgVGFiTGFiZWxFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFiUHJvcHM8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxUYWJQcm9wc0Jhc2U8VGFiRWxlbWVudD4sIFwiaW5kZXhcIiB8IFwiZ2V0U29ydFZhbHVlXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlVGFiUmV0dXJuVHlwZTxUYWJFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFiUGFuZWxQcm9wczxQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFBhcnRpYWxFeGNlcHQ8VGFiUGFuZWxQcm9wc0Jhc2U8UGFuZWxFbGVtZW50PiwgXCJpbmRleFwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZVRhYlBhbmVsUmV0dXJuVHlwZTxQYW5lbEVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuY29uc3QgVGFic0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFRhYnNDb250ZXh0PGFueSwgYW55LCBhbnk+PihudWxsISk7XG5jb25zdCBUYWJQYW5lbHNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxUYWJQYW5lbHNDb250ZXh0PGFueT4+KG51bGwhKTtcblxuZXhwb3J0IGZ1bmN0aW9uIFRhYnM8VGFiQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgYXJpYUxhYmVsLFxuICAgIGNvbGxhdG9yLFxuICAgIGNvbXBhcmUsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgZ2V0SW5kZXgsXG4gICAgaW5pdGlhbGx5U2VsZWN0ZWRJbmRleCxcbiAgICBuYXZpZ2F0ZVBhc3RFbmQsXG4gICAgbmF2aWdhdGVQYXN0U3RhcnQsXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgc2V0U2VsZWN0ZWRJbmRleCxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb3JpZW50YXRpb24sXG4gICAgcGFnZU5hdmlnYXRpb25TaXplLFxuICAgIGdyb3VwaW5nVHlwZSxcbiAgICB1bnRhYmJhYmxlLFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgcm9sZSxcbiAgICByZW5kZXJcbn06IFRhYnNQcm9wczxUYWJDb250YWluZXJFbGVtZW50LCBUYWJFbGVtZW50LCBUYWJMYWJlbEVsZW1lbnQ+KSB7XG4gICAgY29uc3QgaW5mbyA9IHVzZVRhYnM8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudCwgVGFiTGFiZWxFbGVtZW50Pih7XG4gICAgICAgIGxhYmVsUGFyYW1ldGVyczogeyBhcmlhTGFiZWwgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGRpc2FibGVBcnJvd0tleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlQXJyb3dLZXlzXCIsIGRpc2FibGVBcnJvd0tleXMpLFxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzOiB1c2VEZWZhdWx0KFwiZGlzYWJsZUhvbWVFbmRLZXlzXCIsIGRpc2FibGVIb21lRW5kS2V5cyksXG4gICAgICAgICAgICBuYXZpZ2F0ZVBhc3RFbmQ6IG5hdmlnYXRlUGFzdEVuZCA/PyBcIndyYXBcIixcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdFN0YXJ0OiBuYXZpZ2F0ZVBhc3RTdGFydCA/PyBcIndyYXBcIixcbiAgICAgICAgICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZTogdXNlRGVmYXVsdChcInBhZ2VOYXZpZ2F0aW9uU2l6ZVwiLCBwYWdlTmF2aWdhdGlvblNpemUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgZ2V0SW5kZXg6IHVzZURlZmF1bHQoXCJnZXRJbmRleFwiLCBnZXRJbmRleCkgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IG9uVGFiYmFibGVJbmRleENoYW5nZSA/PyBudWxsLFxuICAgICAgICAgICAgdW50YWJiYWJsZTogdW50YWJiYWJsZSA/PyBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzOiB7IGluaXRpYWxseVNlbGVjdGVkSW5kZXg6IGluaXRpYWxseVNlbGVjdGVkSW5kZXggPz8gMCwgc2V0U2VsZWN0ZWRJbmRleDogc2V0U2VsZWN0ZWRJbmRleCA/PyBudWxsIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IGNvbXBhcmU6IGNvbXBhcmUgPz8gbnVsbCB9LFxuICAgICAgICB0YWJzUGFyYW1ldGVyczogeyBvcmllbnRhdGlvbiwgZ3JvdXBpbmdUeXBlLCByb2xlIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBjb2xsYXRvcjogdXNlRGVmYXVsdChcImNvbGxhdG9yXCIsIGNvbGxhdG9yKSxcbiAgICAgICAgICAgIG5vVHlwZWFoZWFkOiB1c2VEZWZhdWx0KFwibm9UeXBlYWhlYWRcIiwgbm9UeXBlYWhlYWQpLFxuICAgICAgICAgICAgdHlwZWFoZWFkVGltZW91dDogdXNlRGVmYXVsdChcInR5cGVhaGVhZFRpbWVvdXRcIiwgdHlwZWFoZWFkVGltZW91dClcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBjb250ZXh0UGFuZWxzLCBjb250ZXh0VGFicyB9ID0gaW5mbztcblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFRhYnNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0VGFic30+XG4gICAgICAgICAgICA8VGFiUGFuZWxzQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFBhbmVsc30+XG4gICAgICAgICAgICAgICAge3JlbmRlcihpbmZvKX1cbiAgICAgICAgICAgIDwvVGFiUGFuZWxzQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9UYWJzQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUYWI8RSBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBkaXNhYmxlZCxcbiAgICBleGNsdWRlLFxuICAgIGZvY3VzU2VsZixcbiAgICBoaWRkZW4sXG4gICAgaW5kZXgsXG4gICAgb25QcmVzc1N5bmMsXG4gICAgc2VsZWN0aW9uTW9kZSxcbiAgICBnZXRUZXh0LFxuICAgIGdldFNvcnRWYWx1ZSxcbiAgICByZW5kZXJcbn06IFRhYlByb3BzPEU+KSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoVGFic0NvbnRleHQpO1xuICAgIGNvbnN0IGZvY3VzU2VsZkRlZmF1bHQgPSB1c2VDYWxsYmFjaygoZTogYW55KSA9PiB7IGU/LmZvY3VzKCk7IH0sIFtdKTtcbiAgICBjb25zdCBpbmZvID0gdXNlVGFiPEU+KHtcbiAgICAgICAgY29tcGxldGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczoge30sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaGlkZGVuID8/IGZhbHNlIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRQYXJhbWV0ZXJzOiB7IGdldFNvcnRWYWx1ZSB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4IH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczogeyBleGNsdWRlLCBmb2N1c1NlbGY6IGZvY3VzU2VsZiA/PyBmb2N1c1NlbGZEZWZhdWx0LCBvblByZXNzU3luYyB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IHsgZGlzYWJsZWQ6IGRpc2FibGVkID8/IGZhbHNlLCBzZWxlY3Rpb25Nb2RlOiB1c2VEZWZhdWx0KFwic2VsZWN0aW9uTW9kZVwiLCBzZWxlY3Rpb25Nb2RlKSB9LFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnM6IHsgZ2V0VGV4dDogdXNlRGVmYXVsdChcImdldFRleHRcIiwgZ2V0VGV4dCkgfVxuICAgIH0pO1xuICAgIHJldHVybiByZW5kZXIoaW5mbyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUYWJQYW5lbDxFIGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluZGV4LFxuICAgIHJlbmRlclxufTogVGFiUGFuZWxQcm9wczxFPikge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFRhYlBhbmVsc0NvbnRleHQpO1xuICAgIGNvbnN0IGluZm8gPSB1c2VUYWJQYW5lbDxFPih7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfVxuICAgIH0pO1xuICAgIHJldHVybiByZW5kZXIoaW5mbyk7XG59XG5cblxuLypcblxuZXhwb3J0IGludGVyZmFjZSBUYWJzUHJvcHM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVEMsIFBDLCBUSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIEdldDxVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50LCBUQywgVEs+LCBcImxpbmVhck5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIFRDLCBUSz4sIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIFRDLCBUSz4sIFwibWFuYWdlZENoaWxkcmVuXCI+LFxuICAgIEdldDxVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50LCBUQywgVEs+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50LCBUQywgVEs+LCBcInNpbmdsZVNlbGVjdGlvblwiPixcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudCwgVEMsIFRLPiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50LCBUQywgVEs+LCBcImNoaWxkcmVuSGF2ZUZvY3VzXCI+LFxuICAgIC8vR2V0PFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIFRDLCBUSz4sID4sXG4gICAgR2V0MjxVc2VUYWJzUGFyYW1ldGVycywgXCJ0YWJQYW5lbHNcIiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4ge1xuICAgIHJlZj86IFJlZjxVc2VUYWJzUmV0dXJuVHlwZUluZm88UEM+PjtcbiAgICByZW5kZXIodGFiTGlzdEluZm86IFVzZVRhYkxpc3RSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50LCBUQz4sIHRhYnNJbmZvOiBVc2VUYWJzUmV0dXJuVHlwZUluZm88UEM+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50PiwgbW9kaWZ5VGFiTGlzdFByb3BzOiBQcm9wTW9kaWZpZXI8TGlzdEVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJQcm9wczxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVEMsIFRLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIEdldDxVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIFRDLCBUSywgVEM+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQsIFRDLCBUSywgVEM+LCBcIm1hbmFnZWRDaGlsZFwiPixcbiAgICBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VGFiRWxlbWVudD4sXG4gICAgR2V0PFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudCwgVEMsIFRLLCBUQz4sIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0PFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudCwgVEMsIFRLLCBUQz4sIFwic2luZ2xlU2VsZWN0aW9uXCI+IHtcbiAgICBzdWJJbmZvOiBHZXQ8VXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50LCBUQywgVEssIFRDPiwgXCJzdWJJbmZvXCI+O1xuICAgIHJlZj86IFJlZjxVc2VUYWJSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50Pj47XG4gICAgcmVuZGVyKGluZm86IFVzZVRhYlJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+LCBtb2RpZnlMaXN0SXRlbTogUHJvcE1vZGlmaWVyPFRhYkVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJQYW5lbFByb3BzPFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFBDLCBQSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBHZXQ8VXNlVGFiUGFuZWxQYXJhbWV0ZXJzPFBDLCBQSywgUEM+LCBcIm1hbmFnZWRDaGlsZFwiPiB7XG4gICAgc3ViSW5mbzogR2V0PFVzZVRhYlBhbmVsUGFyYW1ldGVyczxQQywgUEssIFBDPiwgXCJzdWJJbmZvXCI+O1xuICAgIHJlZj86IFJlZjxVc2VUYWJQYW5lbFJldHVyblR5cGVJbmZvPjtcbiAgICByZW5kZXIoaW5mbzogVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbywgbW9kaWZ5VGFiUGFuZWxQcm9wczogUHJvcE1vZGlmaWVyPFRhYlBhbmVsRWxlbWVudD4pOiBWTm9kZTtcbn1cblxuY29uc3QgVGFiQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVGFiPGFueSwgYW55LCBhbnk+PihudWxsISk7XG5jb25zdCBUYWJQYW5lbENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRhYlBhbmVsPGFueSwgYW55LCBhbnk+PihudWxsISk7XG5cbmV4cG9ydCBjb25zdCBUYWJzID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gVGFiczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUQyA9IHVuZGVmaW5lZCwgUEMgPSB1bmRlZmluZWQsIFRLIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXIsIFBLIGV4dGVuZHMgc3RyaW5nID0gbmV2ZXI+KHtcbiAgICBzZWxlY3RlZEluZGV4LFxuICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgaW5kZXhEZW1hbmdsZXIsXG4gICAgaW5kZXhNYW5nbGVyLFxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb25UYWJiYWJsZVJlbmRlcixcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIG9uQWxsTG9zdEZvY3VzLFxuICAgIG9uQW55R2FpbmVkRm9jdXMsXG4gICAgc2V0U2VsZWN0ZWRJbmRleCxcbiAgICByZW5kZXJcbn06IFRhYnNQcm9wczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBUYWJFbGVtZW50LCBUQywgUEMsIFRLPiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHVzZVRhYkxpc3QsXG4gICAgICAgIHVzZVRhYkxpc3RMYWJlbCxcbiAgICAgICAgdXNlVGFiUGFuZWwsXG4gICAgICAgIC4uLnRhYnNJbmZvXG4gICAgfSA9IHVzZVRhYnM8TGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYlBhbmVsRWxlbWVudCwgTGFiZWxFbGVtZW50LCBUQywgUEMsIFRLLCBQSz4oe1xuICAgICAgICB0YWJQYW5lbHM6IHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gdGFic0luZm8pO1xuXG4gICAgY29uc3QgeyB1c2VUYWIsIHVzZVRhYkxpc3RQcm9wcywgLi4udGFibGlzdEluZm8gfSA9IHVzZVRhYkxpc3Qoe1xuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1czogeyBvbkFsbExvc3RGb2N1cywgb25BbnlHYWluZWRGb2N1cyB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXgsIHNlbGVjdGlvbk1vZGUsIHNldFNlbGVjdGVkSW5kZXggfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxuICAgIH0pO1xuICAgIGNvbnN0IHsgdXNlVGFiTGlzdExhYmVsUHJvcHMgfSA9IHVzZVRhYkxpc3RMYWJlbCh7fSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8VGFiQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFifT5cbiAgICAgICAgICAgIDxUYWJQYW5lbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVRhYlBhbmVsfT5cbiAgICAgICAgICAgICAgICB7cmVuZGVyKHRhYmxpc3RJbmZvLCB0YWJzSW5mbywgdXNlVGFiTGlzdExhYmVsUHJvcHMsIHVzZVRhYkxpc3RQcm9wcyl9XG4gICAgICAgICAgICA8L1RhYlBhbmVsQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9UYWJDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn0pXG5cbmV4cG9ydCBjb25zdCBUYWIgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBUYWI8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRDID0gdW5kZWZpbmVkLCBUSyBleHRlbmRzIHN0cmluZyA9IG5ldmVyPih7IGluZGV4LCB0ZXh0LCBmbGFncywgZm9jdXNTZWxmLCBoaWRkZW4sIGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmVuZGVyLCBzdWJJbmZvLCBub01vZGlmeVRhYkluZGV4LCB1bnNlbGVjdGFibGUgfTogVGFiUHJvcHM8VGFiRWxlbWVudCwgVEMsIFRLPiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCB7IHVzZVRhYlByb3BzLCAuLi50YWJJbmZvIH0gPSB1c2VDb250ZXh0KFRhYkNvbnRleHQpKHtcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgdW5zZWxlY3RhYmxlLCBmb2N1c1NlbGYgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbiwgbm9Nb2RpZnlUYWJJbmRleCB9LFxuICAgICAgICBoYXNGb2N1czogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UgfSxcbiAgICAgICAgc3ViSW5mb1xuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiB0YWJJbmZvKTtcblxuICAgIHJldHVybiByZW5kZXIodGFiSW5mbywgdXNlVGFiUHJvcHMpXG59KVxuXG5leHBvcnQgY29uc3QgVGFiUGFuZWwgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBUYWJQYW5lbDxUYWJQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQQyA9IHVuZGVmaW5lZCwgUEsgZXh0ZW5kcyBzdHJpbmcgPSBuZXZlcj4oeyBpbmRleCwgZmxhZ3MsIHJlbmRlciwgc3ViSW5mbyB9OiBUYWJQYW5lbFByb3BzPFRhYlBhbmVsRWxlbWVudCwgUEMsIFBLPiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCB7IHVzZVRhYlBhbmVsUHJvcHMsIC4uLnRhYlBhbmVsSW5mbyB9ID0gKHVzZUNvbnRleHQoVGFiUGFuZWxDb250ZXh0KSBhcyBVc2VUYWJQYW5lbDxUYWJQYW5lbEVsZW1lbnQsIFBDLCBQSz4pKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCBzdWJJbmZvIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiB0YWJQYW5lbEluZm8pO1xuXG4gICAgcmV0dXJuIHJlbmRlcih0YWJQYW5lbEluZm8sIHVzZVRhYlBhbmVsUHJvcHMpXG59KVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYnM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVEMsIFBDPih7IHRhZ0xhYmVsLCB0YWdMaXN0LCBtYWtlUHJvcHNMYWJlbCwgbWFrZVByb3BzTGlzdCwgcGFuZWxzIH06IHsgcGFuZWxzOiBWTm9kZVtdLCB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD4sIHRhZ0xpc3Q6IEVsZW1lbnRUb1RhZzxMaXN0RWxlbWVudD4sIG1ha2VQcm9wc0xhYmVsOiAoaW5mb1RhYnM6IFVzZVRhYnNSZXR1cm5UeXBlSW5mbzxQQz4sIGluZm9MaXN0OiBVc2VUYWJMaXN0UmV0dXJuVHlwZUluZm88VGFiRWxlbWVudCwgVEM+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+LCBtYWtlUHJvcHNMaXN0OiAoaW5mb1RhYnM6IFVzZVRhYnNSZXR1cm5UeXBlSW5mbzxQQz4sIGluZm9MaXN0OiBVc2VUYWJMaXN0UmV0dXJuVHlwZUluZm88VGFiRWxlbWVudCwgVEM+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFibGlzdEluZm86IFVzZVRhYkxpc3RSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50LCBUQz4sIHRhYnNJbmZvOiBVc2VUYWJzUmV0dXJuVHlwZUluZm88UEM+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50PiwgbW9kaWZ5TGlzdFByb3BzOiBQcm9wTW9kaWZpZXI8TGlzdEVsZW1lbnQ+KSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY3JlYXRlRWxlbWVudCh0YWdMYWJlbCBhcyBuZXZlciwgbW9kaWZ5TGFiZWxQcm9wcyhtYWtlUHJvcHNMYWJlbCh0YWJzSW5mbywgdGFibGlzdEluZm8pKSlcbiAgICAgICAgY29uc3QgbGlzdCA9IGNyZWF0ZUVsZW1lbnQodGFnTGlzdCBhcyBuZXZlciwgbW9kaWZ5TGlzdFByb3BzKG1ha2VQcm9wc0xpc3QodGFic0luZm8sIHRhYmxpc3RJbmZvKSkpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgICAgICAge2xpc3R9XG4gICAgICAgICAgICAgICAge3BhbmVsc31cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYjxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNUYWIsIHRhZ1RhYiB9OiB7IHRhZ1RhYjogRWxlbWVudFRvVGFnPFRhYkVsZW1lbnQ+LCBtYWtlUHJvcHNUYWI6IChpbmZvOiBVc2VUYWJSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFiSW5mbzogVXNlVGFiUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudD4sIG1vZGlmeVRhYlByb3BzOiBQcm9wTW9kaWZpZXI8VGFiRWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFiIGFzIG5ldmVyLCBtb2RpZnlUYWJQcm9wcyhtYWtlUHJvcHNUYWIodGFiSW5mbykpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFiUGFuZWw8VGFiUGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNUYWJQYW5lbCwgdGFnVGFiUGFuZWwgfTogeyB0YWdUYWJQYW5lbDogRWxlbWVudFRvVGFnPFRhYlBhbmVsRWxlbWVudD4sIG1ha2VQcm9wc1RhYlBhbmVsOiAoaW5mbzogVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiUGFuZWxFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YWJQYW5lbEluZm86IFVzZVRhYlBhbmVsUmV0dXJuVHlwZUluZm8sIG1vZGlmeVRhYlBhbmVsUHJvcHM6IFByb3BNb2RpZmllcjxUYWJQYW5lbEVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYlBhbmVsIGFzIG5ldmVyLCBtb2RpZnlUYWJQYW5lbFByb3BzKG1ha2VQcm9wc1RhYlBhbmVsKHRhYlBhbmVsSW5mbykpKTtcbiAgICB9XG59XG4qLyIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgVG9hc3RJbmZvLCBUb2FzdHNDb250ZXh0LCB1c2VUb2FzdCwgVXNlVG9hc3RQYXJhbWV0ZXJzLCBVc2VUb2FzdFJldHVyblR5cGUsIHVzZVRvYXN0cywgVXNlVG9hc3RzUGFyYW1ldGVycywgVXNlVG9hc3RzUmV0dXJuVHlwZSB9IGZyb20gXCIuLi91c2UtdG9hc3RzXCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiB9IGZyb20gXCIuL3V0aWxcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuZXhwb3J0IGludGVyZmFjZSBUb2FzdHNQcm9wczxDb250YWluZXJUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHZXQ8VXNlVG9hc3RzUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzXCI+LCBHZXQ8VXNlVG9hc3RzUGFyYW1ldGVycywgXCJ0b2FzdHNQYXJhbWV0ZXJzXCI+IHtcbiAgICAvL3RhZ0NvbnRhaW5lcjogRWxlbWVudFRvVGFnPENvbnRhaW5lckVsZW1lbnQ+O1xuICAgIC8vY2hpbGRyZW46IFZOb2RlW107XG4gICAgcmVmPzogUmVmPFVzZVRvYXN0c1JldHVyblR5cGU8Q29udGFpbmVyVHlwZSwgVG9hc3RJbmZvPj47XG4gICAgcmVuZGVyKGluZm86IFVzZVRvYXN0c1JldHVyblR5cGU8Q29udGFpbmVyVHlwZSwgVG9hc3RJbmZvPik6IFZOb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRvYXN0UHJvcHM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgR2V0PFVzZVRvYXN0UGFyYW1ldGVyczxUb2FzdEluZm8+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4sIEdldDxVc2VUb2FzdFBhcmFtZXRlcnM8VG9hc3RJbmZvPiwgXCJ0b2FzdFBhcmFtZXRlcnNcIj4ge1xuICAgIC8vc3ViSW5mbzogR2V0PFVzZVRvYXN0UGFyYW1ldGVyLCBcInN1YkluZm9cIj47XG4gICAgcmVmPzogUmVmPFVzZVRvYXN0UmV0dXJuVHlwZTxFPj47XG4gICAgcmVuZGVyKGFyZ3M6IFVzZVRvYXN0UmV0dXJuVHlwZTxFPik6IFZOb2RlO1xufVxuXG4vKmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVG9hc3RzKHt9OiB7fSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnczogVXNlVG9hc3RzUmV0dXJuVHlwZUluZm8sIHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDb250YWluZXJUeXBlPikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2PlxuXG4gICAgICAgIDwvZGl2PlxuICAgICAgICApXG4gICAgfVxufSovXG5cbmNvbnN0IFRvYXN0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VG9hc3RzQ29udGV4dDxUb2FzdEluZm8+PihudWxsISk7XG5cbmV4cG9ydCBjb25zdCBUb2FzdHMgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBUb2FzdHM8Q29udGFpbmVyVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIHJlbmRlciwgdmlzaWJsZUNvdW50IH06IFRvYXN0c1Byb3BzPENvbnRhaW5lclR5cGU+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGluZm8gPSB1c2VUb2FzdHM8Q29udGFpbmVyVHlwZT4oeyBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sIHRvYXN0c1BhcmFtZXRlcnM6IHsgdmlzaWJsZUNvdW50IH0gfSk7XG5cbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiEsICgpID0+IGluZm8pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFRvYXN0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17aW5mby5jb250ZXh0fT5cbiAgICAgICAgICAgIHtyZW5kZXIoaW5mbyl9XG4gICAgICAgIDwvVG9hc3RDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG59KVxuXG5leHBvcnQgY29uc3QgVG9hc3QgPSBtZW1vRm9yd2FyZFJlZihmdW5jdGlvbiBUb2FzdDxFIGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIsIGluZGV4LCB0aW1lb3V0LCBwb2xpdGVuZXNzIH06IFRvYXN0UHJvcHM8RT4sIHJlZj86IFJlZjxhbnk+KSB7XG4gICAgY29uc3QgY29udGV4dCA9ICh1c2VDb250ZXh0KFRvYXN0Q29udGV4dCkgYXMgVG9hc3RzQ29udGV4dDxUb2FzdEluZm8+KVxuICAgIGNvbnN0IGluZm8gPSB1c2VUb2FzdDxFPih7XG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfSxcbiAgICAgICAgdG9hc3RQYXJhbWV0ZXJzOiB7IHRpbWVvdXQsIHBvbGl0ZW5lc3MgfSxcbiAgICAgICAgY29udGV4dFxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcblxuICAgIHJldHVybiByZW5kZXIoaW5mbyk7XG59KVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgUmVmLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwiLi4vcHJvcHNcIjtcbi8vaW1wb3J0IHsgRWxlbWVudFRvVGFnIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VUb29sYmFyLCB1c2VUb29sYmFyQ2hpbGQsIFVzZVRvb2xiYXJSZXR1cm5UeXBlLCBVc2VUb29sYmFyQ2hpbGRSZXR1cm5UeXBlLCBVc2VUb29sYmFyQ2hpbGRQYXJhbWV0ZXJzLCBVc2VUb29sYmFyUGFyYW1ldGVycywgVXNlVG9vbGJhclN1YkluZm8sIFVzZVRvb2xiYXJDb250ZXh0IH0gZnJvbSBcIi4uL3VzZS10b29sYmFyXCI7XG5pbXBvcnQgeyBtZW1vRm9yd2FyZFJlZiwgUGFydGlhbEV4Y2VwdCwgdXNlRGVmYXVsdCB9IGZyb20gXCIuL3V0aWxcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuZXhwb3J0IGludGVyZmFjZSBUb29sYmFyUHJvcHNCYXNlPFRvb2xiYXJDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVG9vbGJhckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxUb29sYmFyQ2hpbGRFbGVtZW50Pj4gZXh0ZW5kc1xuICAgIEdldDxVc2VUb29sYmFyUGFyYW1ldGVyczxUb29sYmFyQ29udGFpbmVyRWxlbWVudCwgVG9vbGJhckNoaWxkRWxlbWVudCwgTT4sIFwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRvb2xiYXJQYXJhbWV0ZXJzPFRvb2xiYXJDb250YWluZXJFbGVtZW50LCBUb29sYmFyQ2hpbGRFbGVtZW50LCBNPiwgXCJzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUb29sYmFyUGFyYW1ldGVyczxUb29sYmFyQ29udGFpbmVyRWxlbWVudCwgVG9vbGJhckNoaWxkRWxlbWVudCwgTT4sIFwicm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzXCI+LFxuICAgIEdldDxVc2VUb29sYmFyUGFyYW1ldGVyczxUb29sYmFyQ29udGFpbmVyRWxlbWVudCwgVG9vbGJhckNoaWxkRWxlbWVudCwgTT4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRvb2xiYXJQYXJhbWV0ZXJzPFRvb2xiYXJDb250YWluZXJFbGVtZW50LCBUb29sYmFyQ2hpbGRFbGVtZW50LCBNPiwgXCJzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVG9vbGJhclBhcmFtZXRlcnM8VG9vbGJhckNvbnRhaW5lckVsZW1lbnQsIFRvb2xiYXJDaGlsZEVsZW1lbnQsIE0+LCBcInJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRvb2xiYXJQYXJhbWV0ZXJzPFRvb2xiYXJDb250YWluZXJFbGVtZW50LCBUb29sYmFyQ2hpbGRFbGVtZW50LCBNPiwgXCJ0b29sYmFyUGFyYW1ldGVyc1wiPiB7XG4gICAgcmVmPzogUmVmPFVzZVRvb2xiYXJSZXR1cm5UeXBlPFRvb2xiYXJDb250YWluZXJFbGVtZW50LCBUb29sYmFyQ2hpbGRFbGVtZW50LCBNPj47XG59XG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBUb29sYmFyQ2hpbGRQcm9wc0Jhc2U8VG9vbGJhckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxUb29sYmFyQ2hpbGRFbGVtZW50Pj4gZXh0ZW5kc1xuICAgIEdldDxVc2VUb29sYmFyQ2hpbGRQYXJhbWV0ZXJzPFRvb2xiYXJDaGlsZEVsZW1lbnQsIE0+LCBcInByZXNzUGFyYW1ldGVyc1wiPixcbiAgICBHZXQ8VXNlVG9vbGJhckNoaWxkUGFyYW1ldGVyczxUb29sYmFyQ2hpbGRFbGVtZW50LCBNPiwgXCJzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnM8VG9vbGJhckNoaWxkRWxlbWVudCwgTT4sIFwicm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnM8VG9vbGJhckNoaWxkRWxlbWVudCwgTT4sIFwic29ydGFibGVDaGlsZFBhcmFtZXRlcnNcIj4sXG4gICAgR2V0PFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnM8VG9vbGJhckNoaWxkRWxlbWVudCwgTT4sIFwidGV4dENvbnRlbnRQYXJhbWV0ZXJzXCI+LFxuICAgIFBpY2s8R2V0PFVzZVRvb2xiYXJDaGlsZFBhcmFtZXRlcnM8YW55LCBhbnk+LCBcIm1hbmFnZWRDaGlsZFBhcmFtZXRlcnNcIj4sIFwiaW5kZXhcIj4ge1xuLy8gICAgc3ViSW5mbzogVXNlVG9vbGJhckNoaWxkUGFyYW1ldGVyczxUb29sYmFyQ2hpbGRFbGVtZW50LCBNPltcImNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnNcIl07XG4gICAgcmVmPzogUmVmPFVzZVRvb2xiYXJDaGlsZFJldHVyblR5cGU8VG9vbGJhckNoaWxkRWxlbWVudCwgTT4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xiYXJQcm9wczxUb29sYmFyQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRvb2xiYXJDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNIGV4dGVuZHMgVXNlVG9vbGJhclN1YkluZm88VG9vbGJhckNoaWxkRWxlbWVudD4+IGV4dGVuZHMgUGFydGlhbEV4Y2VwdDxUb29sYmFyUHJvcHNCYXNlPFRvb2xiYXJDb250YWluZXJFbGVtZW50LCBUb29sYmFyQ2hpbGRFbGVtZW50LCBNPiwgXCJvcmllbnRhdGlvblwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZVRvb2xiYXJSZXR1cm5UeXBlPFRvb2xiYXJDb250YWluZXJFbGVtZW50LCBUb29sYmFyQ2hpbGRFbGVtZW50LCBNPik6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbGJhckNoaWxkUHJvcHM8VG9vbGJhckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxUb29sYmFyQ2hpbGRFbGVtZW50Pj4gZXh0ZW5kcyBQYXJ0aWFsRXhjZXB0PFRvb2xiYXJDaGlsZFByb3BzQmFzZTxUb29sYmFyQ2hpbGRFbGVtZW50LCBNPiwgXCJnZXRTb3J0VmFsdWVcIiB8IFwiYXJpYVByb3BOYW1lXCIgfCBcImluZGV4XCIgfCBcInNlbGVjdGlvbk1vZGVcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VUb29sYmFyQ2hpbGRSZXR1cm5UeXBlPFRvb2xiYXJDaGlsZEVsZW1lbnQsIE0+KTogVk5vZGU8YW55Pjtcbn1cblxuY29uc3QgVG9vbGJhckNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVRvb2xiYXJDb250ZXh0PGFueSwgYW55LCBhbnk+PihudWxsISk7XG5cbmV4cG9ydCBjb25zdCBUb29sYmFyID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gVG9vbGJhclU8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICByZW5kZXIsXG4gICAgcm9sZSxcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICB1bnRhYmJhYmxlLFxuICAgIGNvbXBhcmUsXG4gICAgZ2V0SW5kZXgsXG4gICAgbmF2aWdhdGVQYXN0RW5kLFxuICAgIG5hdmlnYXRlUGFzdFN0YXJ0LFxuICAgIHBhZ2VOYXZpZ2F0aW9uU2l6ZSxcbiAgICBpbml0aWFsbHlTZWxlY3RlZEluZGV4LFxuICAgIHNldFNlbGVjdGVkSW5kZXgsXG4gICAgb3JpZW50YXRpb24sXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlLFxuICAgIHR5cGVhaGVhZFRpbWVvdXRcbn06IFRvb2xiYXJQcm9wczxDb250YWluZXJFbGVtZW50LCBDaGlsZEVsZW1lbnQsIFVzZVRvb2xiYXJTdWJJbmZvPENoaWxkRWxlbWVudD4+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGxpc3Rib3hSZXR1cm5UeXBlID0gdXNlVG9vbGJhcjxDb250YWluZXJFbGVtZW50LCBDaGlsZEVsZW1lbnQ+KHtcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBnZXRJbmRleDogdXNlRGVmYXVsdChcImdldEluZGV4XCIsIGdldEluZGV4KSB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzOiB7IGluaXRpYWxseVNlbGVjdGVkSW5kZXg6IGluaXRpYWxseVNlbGVjdGVkSW5kZXggPz8gbnVsbCwgc2V0U2VsZWN0ZWRJbmRleDogc2V0U2VsZWN0ZWRJbmRleCA/PyBudWxsIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IGNvbXBhcmU6IGNvbXBhcmUgPz8gbnVsbCB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZGlzYWJsZUFycm93S2V5czogdXNlRGVmYXVsdChcImRpc2FibGVBcnJvd0tleXNcIiwgZGlzYWJsZUFycm93S2V5cyksXG4gICAgICAgICAgICBkaXNhYmxlSG9tZUVuZEtleXM6IHVzZURlZmF1bHQoXCJkaXNhYmxlSG9tZUVuZEtleXNcIiwgZGlzYWJsZUhvbWVFbmRLZXlzKSxcbiAgICAgICAgICAgIG5hdmlnYXRlUGFzdEVuZDogbmF2aWdhdGVQYXN0RW5kID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgbmF2aWdhdGVQYXN0U3RhcnQ6IG5hdmlnYXRlUGFzdFN0YXJ0ID8/IFwid3JhcFwiLFxuICAgICAgICAgICAgcGFnZU5hdmlnYXRpb25TaXplOiB1c2VEZWZhdWx0KFwicGFnZU5hdmlnYXRpb25TaXplXCIsIHBhZ2VOYXZpZ2F0aW9uU2l6ZSlcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbGJhclBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uLFxuICAgICAgICAgICAgcm9sZTogcm9sZSA/PyBcInRvb2xiYXJcIlxuICAgICAgICB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHsgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiBvblRhYmJhYmxlSW5kZXhDaGFuZ2UgPz8gbnVsbCwgdW50YWJiYWJsZTogdW50YWJiYWJsZSA/PyBmYWxzZSB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBcbiAgICAgICAgICAgIGNvbGxhdG9yOiB1c2VEZWZhdWx0KFwiY29sbGF0b3JcIiwgY29sbGF0b3IpLCBcbiAgICAgICAgICAgIG5vVHlwZWFoZWFkOiB1c2VEZWZhdWx0KFwibm9UeXBlYWhlYWRcIiwgbm9UeXBlYWhlYWQpLCBcbiAgICAgICAgICAgIHR5cGVhaGVhZFRpbWVvdXQ6IHVzZURlZmF1bHQoXCJ0eXBlYWhlYWRUaW1lb3V0XCIsIHR5cGVhaGVhZFRpbWVvdXQpXG4gICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBsaXN0Ym94UmV0dXJuVHlwZSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8VG9vbGJhckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2xpc3Rib3hSZXR1cm5UeXBlLmNvbnRleHR9PlxuICAgICAgICAgICAge3JlbmRlcihsaXN0Ym94UmV0dXJuVHlwZSl9XG4gICAgICAgIDwvVG9vbGJhckNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufSlcblxuXG5leHBvcnQgY29uc3QgVG9vbGJhckNoaWxkID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gVG9vbGJhckNoaWxkVTxUb29sYmFyQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIGluZGV4LFxuICAgIHJlbmRlcixcbiAgICBhcmlhUHJvcE5hbWUsXG4gICAgZGlzYWJsZWQsXG4gICAgZXhjbHVkZSxcbiAgICBvblByZXNzU3luYyxcbiAgICBzZWxlY3Rpb25Nb2RlLFxuICAgIGZvY3VzU2VsZixcbiAgICBnZXRTb3J0VmFsdWUsXG4gICAgaGlkZGVuLFxuICAgIGdldFRleHRcbn06IFRvb2xiYXJDaGlsZFByb3BzPFRvb2xiYXJDaGlsZEVsZW1lbnQsIFVzZVRvb2xiYXJTdWJJbmZvPFRvb2xiYXJDaGlsZEVsZW1lbnQ+PiwgcmVmPzogUmVmPGFueT4pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKHVzZUNvbnRleHQoVG9vbGJhckNvbnRleHQpIGFzIFVzZVRvb2xiYXJDb250ZXh0PGFueSwgVG9vbGJhckNoaWxkRWxlbWVudCwgVXNlVG9vbGJhclN1YkluZm88VG9vbGJhckNoaWxkRWxlbWVudD4+KTtcbiAgICBjb25zdCBmb2N1c1NlbGZEZWZhdWx0ID0gdXNlQ2FsbGJhY2soKGU6IGFueSkgPT4geyBlPy5mb2N1cygpOyB9LCBbXSk7XG5cbiAgICBjb25zdCBpbmZvID0gdXNlVG9vbGJhckNoaWxkPFRvb2xiYXJDaGlsZEVsZW1lbnQ+KHtcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgLy9jb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiBzdWJJbmZvLFxuICAgICAgICBjb21wbGV0ZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgcHJlc3NQYXJhbWV0ZXJzOiB7IGV4Y2x1ZGUsIGZvY3VzU2VsZjogZm9jdXNTZWxmID8/IGZvY3VzU2VsZkRlZmF1bHQsIG9uUHJlc3NTeW5jIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXggfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IHsgaGlkZGVuOiBoaWRkZW4gPz8gZmFsc2UgfSxcbiAgICAgICAgc29ydGFibGVDaGlsZFBhcmFtZXRlcnM6IHsgZ2V0U29ydFZhbHVlIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczogeyBhcmlhUHJvcE5hbWUsIHNlbGVjdGlvbk1vZGUsIGRpc2FibGVkOiBkaXNhYmxlZCA/PyBmYWxzZSB9LFxuICAgICAgICB0ZXh0Q29udGVudFBhcmFtZXRlcnM6IHsgZ2V0VGV4dDogdXNlRGVmYXVsdChcImdldFRleHRcIiwgZ2V0VGV4dCkgfSxcbiAgICB9KTtcblxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmISwgKCkgPT4gaW5mbyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PntyZW5kZXIoaW5mbyl9PC8+XG4gICAgKVxufSlcblxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRvb2xiYXI8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+Pih7IG1ha2VQcm9wc0NvbnRhaW5lciwgdGFnQ29udGFpbmVyIH06IHsgdGFnQ29udGFpbmVyOiBFbGVtZW50VG9UYWc8Q29udGFpbmVyRWxlbWVudD4sIG1ha2VQcm9wc0NvbnRhaW5lcjogKGluZm86IFVzZVRvb2xiYXJSZXR1cm5UeXBlPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENvbnRhaW5lckVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVRvb2xiYXJSZXR1cm5UeXBlPENvbnRhaW5lckVsZW1lbnQsIENoaWxkRWxlbWVudCwgTT4pOiBWTm9kZTxhbnk+IHtcbiAgICAgICAgY29uc3QgbGlzdCA9IGNyZWF0ZUVsZW1lbnQodGFnQ29udGFpbmVyIGFzIG5ldmVyLCBtYWtlUHJvcHNDb250YWluZXIoaW5mbykpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7bGlzdH1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyVG9vbGJhckNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE0gZXh0ZW5kcyBVc2VUb29sYmFyU3ViSW5mbzxDaGlsZEVsZW1lbnQ+Pih7IG1ha2VQcm9wc0NoaWxkLCB0YWdDaGlsZCB9OiB7IHRhZ0NoaWxkOiBFbGVtZW50VG9UYWc8Q2hpbGRFbGVtZW50PiwgbWFrZVByb3BzQ2hpbGQ6IChpbmZvOiBVc2VUb29sYmFyQ2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudCwgTT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlVG9vbGJhckNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQsIE0+KTogVk5vZGU8YW55PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0NoaWxkIGFzIG5ldmVyLCBtYWtlUHJvcHNDaGlsZChpbmZvKSk7XG4gICAgfVxufSIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VJbXBlcmF0aXZlSGFuZGxlIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VUb29sdGlwLCBVc2VUb29sdGlwUGFyYW1ldGVycywgVXNlVG9vbHRpcFJldHVyblR5cGUgfSBmcm9tIFwiLi4vdXNlLXRvb2x0aXBcIjtcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJQb3J0YWwgfSBmcm9tIFwiLi9kaWFsb2dcIjtcbmltcG9ydCB7IG1lbW9Gb3J3YXJkUmVmIH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2x0aXBQcm9wczxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQsIFBvcHVwVHlwZSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVG9vbHRpcFBhcmFtZXRlcnMge1xuICAgIHJlbmRlcihpbmZvOiBVc2VUb29sdGlwUmV0dXJuVHlwZTxUcmlnZ2VyVHlwZSwgUG9wdXBUeXBlPik6IFZOb2RlO1xuICAgIHJlZj86IFJlZjxVc2VUb29sdGlwUmV0dXJuVHlwZTxUcmlnZ2VyVHlwZSwgUG9wdXBUeXBlPj47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVG9vbHRpcDxUcmlnZ2VyVHlwZSBleHRlbmRzIEVsZW1lbnQsIFBvcHVwVHlwZSBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnVG9vbHRpcCwgdGFnVHJpZ2dlciwgbWFrZVRvb2x0aXBQcm9wcywgbWFrZVRyaWdnZXJQcm9wcywgcG9ydGFsSWQgfTogeyBwb3J0YWxJZDogc3RyaW5nLCB0YWdUcmlnZ2VyOiBFbGVtZW50VG9UYWc8VHJpZ2dlclR5cGU+LCB0YWdUb29sdGlwOiBFbGVtZW50VG9UYWc8UG9wdXBUeXBlPiwgbWFrZVRyaWdnZXJQcm9wczogKGluZm86IFVzZVRvb2x0aXBSZXR1cm5UeXBlPFRyaWdnZXJUeXBlLCBQb3B1cFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUcmlnZ2VyVHlwZT4sIG1ha2VUb29sdGlwUHJvcHM6IChpbmZvOiBVc2VUb29sdGlwUmV0dXJuVHlwZTxUcmlnZ2VyVHlwZSwgUG9wdXBUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UG9wdXBUeXBlPiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUb29sdGlwUmV0dXJuVHlwZTxUcmlnZ2VyVHlwZSwgUG9wdXBUeXBlPikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdUcmlnZ2VyIGFzIG5ldmVyLCBtYWtlVHJpZ2dlclByb3BzKGluZm8pKX1cbiAgICAgICAgICAgICAgICB7ZGVmYXVsdFJlbmRlclBvcnRhbCh7XG4gICAgICAgICAgICAgICAgICAgIHBvcnRhbElkLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogY3JlYXRlRWxlbWVudCh0YWdUb29sdGlwIGFzIG5ldmVyLCBtYWtlVG9vbHRpcFByb3BzKGluZm8pKVxuICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBUb29sdGlwID0gbWVtb0ZvcndhcmRSZWYoZnVuY3Rpb24gVG9vbHRpcFU8VHJpZ2dlclR5cGUgZXh0ZW5kcyBFbGVtZW50LCBQb3B1cFR5cGUgZXh0ZW5kcyBFbGVtZW50Pih7IGZvY3VzRGVsYXksIG1vdXNlb3V0VG9sZXJhbmNlRGVsYXksIG1vdXNlb3ZlckRlbGF5LCByZW5kZXIgfTogVG9vbHRpcFByb3BzPFRyaWdnZXJUeXBlLCBQb3B1cFR5cGU+LCByZWY/OiBSZWY8YW55Pikge1xuICAgIGNvbnN0IGluZm8gPSB1c2VUb29sdGlwPFRyaWdnZXJUeXBlLCBQb3B1cFR5cGU+KHsgZm9jdXNEZWxheSwgbW91c2VvdXRUb2xlcmFuY2VEZWxheSwgbW91c2VvdmVyRGVsYXkgfSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYhLCAoKSA9PiBpbmZvKTtcbiAgICByZXR1cm4gcmVuZGVyKGluZm8pO1xufSlcblxuIixudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsLG51bGwsbnVsbCxudWxsXSwibmFtZXMiOlsic2xpY2UiLCJvcHRpb25zIiwidm5vZGVJZCIsInJlcmVuZGVyUXVldWUiLCJwcmV2RGVib3VuY2UiLCJpIiwiRU1QVFlfT0JKIiwiRU1QVFlfQVJSIiwiSVNfTk9OX0RJTUVOU0lPTkFMIiwiYXNzaWduIiwib2JqIiwicHJvcHMiLCJyZW1vdmVOb2RlIiwibm9kZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwiY2hpbGRyZW4iLCJrZXkiLCJyZWYiLCJub3JtYWxpemVkUHJvcHMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjYWxsIiwiZGVmYXVsdFByb3BzIiwidW5kZWZpbmVkIiwiY3JlYXRlVk5vZGUiLCJvcmlnaW5hbCIsInZub2RlIiwiX19rIiwiX18iLCJfX2IiLCJfX2UiLCJfX2QiLCJfX2MiLCJfX2giLCJjb25zdHJ1Y3RvciIsIl9fdiIsIkZyYWdtZW50IiwiQ29tcG9uZW50IiwiY29udGV4dCIsInRoaXMiLCJnZXREb21TaWJsaW5nIiwiY2hpbGRJbmRleCIsImluZGV4T2YiLCJzaWJsaW5nIiwidXBkYXRlUGFyZW50RG9tUG9pbnRlcnMiLCJjaGlsZCIsImJhc2UiLCJlbnF1ZXVlUmVuZGVyIiwiYyIsInB1c2giLCJwcm9jZXNzIiwiZGVib3VuY2VSZW5kZXJpbmciLCJzZXRUaW1lb3V0IiwicXVldWUiLCJfX3IiLCJzb3J0IiwiYSIsImIiLCJzb21lIiwiY29tcG9uZW50IiwiY29tbWl0UXVldWUiLCJvbGRWTm9kZSIsIm9sZERvbSIsInBhcmVudERvbSIsIl9fUCIsImRpZmYiLCJvd25lclNWR0VsZW1lbnQiLCJjb21taXRSb290IiwiZGlmZkNoaWxkcmVuIiwicmVuZGVyUmVzdWx0IiwibmV3UGFyZW50Vk5vZGUiLCJvbGRQYXJlbnRWTm9kZSIsImdsb2JhbENvbnRleHQiLCJpc1N2ZyIsImV4Y2Vzc0RvbUNoaWxkcmVuIiwiaXNIeWRyYXRpbmciLCJqIiwiY2hpbGRWTm9kZSIsIm5ld0RvbSIsImZpcnN0Q2hpbGREb20iLCJyZWZzIiwib2xkQ2hpbGRyZW4iLCJvbGRDaGlsZHJlbkxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsInJlb3JkZXJDaGlsZHJlbiIsInBsYWNlQ2hpbGQiLCJ1bm1vdW50IiwiYXBwbHlSZWYiLCJ0bXAiLCJ0b0NoaWxkQXJyYXkiLCJvdXQiLCJuZXh0RG9tIiwic2liRG9tIiwib3V0ZXIiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0QmVmb3JlIiwiZGlmZlByb3BzIiwiZG9tIiwibmV3UHJvcHMiLCJvbGRQcm9wcyIsImh5ZHJhdGUiLCJzZXRQcm9wZXJ0eSIsInNldFN0eWxlIiwic3R5bGUiLCJ2YWx1ZSIsInRlc3QiLCJuYW1lIiwib2xkVmFsdWUiLCJ1c2VDYXB0dXJlIiwibyIsImNzc1RleHQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50UHJveHlDYXB0dXJlIiwiZXZlbnRQcm94eSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiZXZlbnQiLCJuZXdWTm9kZSIsImlzTmV3Iiwib2xkU3RhdGUiLCJzbmFwc2hvdCIsImNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiIsInByb3ZpZGVyIiwiY29tcG9uZW50Q29udGV4dCIsInJlbmRlckhvb2siLCJjb3VudCIsIm5ld1R5cGUiLCJjb250ZXh0VHlwZSIsIl9fRSIsInByb3RvdHlwZSIsInJlbmRlciIsImRvUmVuZGVyIiwic3ViIiwic3RhdGUiLCJfc2IiLCJfX3MiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJmb3JFYWNoIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldENoaWxkQ29udGV4dCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiZGlmZkVsZW1lbnROb2RlcyIsImRpZmZlZCIsInJvb3QiLCJjYiIsIm9sZEh0bWwiLCJuZXdIdG1sIiwibm9kZVR5cGUiLCJsb2NhbE5hbWUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlRWxlbWVudE5TIiwiaXMiLCJkYXRhIiwiY2hpbGROb2RlcyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiYXR0cmlidXRlcyIsIl9faHRtbCIsImlubmVySFRNTCIsImNoZWNrZWQiLCJjdXJyZW50IiwicGFyZW50Vk5vZGUiLCJza2lwUmVtb3ZlIiwiciIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVwbGFjZU5vZGUiLCJmaXJzdENoaWxkIiwiY3JlYXRlQ29udGV4dCIsImRlZmF1bHRWYWx1ZSIsImNvbnRleHRJZCIsIkNvbnN1bWVyIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJzdWJzIiwiY3R4IiwiX3Byb3BzIiwib2xkIiwic3BsaWNlIiwiZXJyb3IiLCJlcnJvckluZm8iLCJjdG9yIiwiaGFuZGxlZCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsInNldFN0YXRlIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJ1cGRhdGUiLCJjYWxsYmFjayIsInMiLCJmb3JjZVVwZGF0ZSIsIl9fc2VsZiIsIl9fc291cmNlIiwiY3VycmVudEluZGV4IiwiY3VycmVudENvbXBvbmVudCIsInByZXZpb3VzQ29tcG9uZW50IiwicHJldlJhZiIsImN1cnJlbnRIb29rIiwiYWZ0ZXJQYWludEVmZmVjdHMiLCJFTVBUWSIsIm9sZEJlZm9yZURpZmYiLCJvbGRCZWZvcmVSZW5kZXIiLCJvbGRBZnRlckRpZmYiLCJvbGRDb21taXQiLCJvbGRCZWZvcmVVbm1vdW50IiwiZ2V0SG9va1N0YXRlIiwiaW5kZXgiLCJob29rcyIsIl9fSCIsIl9fViIsInVzZVN0YXRlIiwiaW5pdGlhbFN0YXRlIiwidXNlUmVkdWNlciIsImludm9rZU9yUmV0dXJuIiwicmVkdWNlciIsImluaXQiLCJob29rU3RhdGUiLCJfcmVkdWNlciIsImFjdGlvbiIsImN1cnJlbnRWYWx1ZSIsIl9fTiIsIm5leHRWYWx1ZSIsIl9oYXNTY3VGcm9tSG9va3MiLCJwcmV2U2N1IiwicCIsInN0YXRlSG9va3MiLCJmaWx0ZXIiLCJ4IiwiZXZlcnkiLCJzaG91bGRVcGRhdGUiLCJob29rSXRlbSIsInVzZUVmZmVjdCIsImFyZ3MiLCJhcmdzQ2hhbmdlZCIsIl9wZW5kaW5nQXJncyIsInVzZUxheW91dEVmZmVjdCIsInVzZVJlZiIsImluaXRpYWxWYWx1ZSIsInVzZU1lbW8iLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwiY3JlYXRlSGFuZGxlIiwiY29uY2F0IiwiZmFjdG9yeSIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUlkIiwiX19tIiwibWFzayIsImZsdXNoQWZ0ZXJQYWludEVmZmVjdHMiLCJzaGlmdCIsImludm9rZUNsZWFudXAiLCJpbnZva2VFZmZlY3QiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhZnRlck5leHRGcmFtZSIsImhhc0Vycm9yZWQiLCJIQVNfUkFGIiwicmFmIiwiZG9uZSIsImNsZWFyVGltZW91dCIsInRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImhvb2siLCJjb21wIiwiY2xlYW51cCIsIm9sZEFyZ3MiLCJuZXdBcmdzIiwiYXJnIiwiZiIsInNoYWxsb3dEaWZmZXJzIiwiUHVyZUNvbXBvbmVudCIsIm1lbW8iLCJjb21wYXJlciIsIm5leHRQcm9wcyIsInVwZGF0ZVJlZiIsIk1lbW9lZCIsImRpc3BsYXlOYW1lIiwiaXNSZWFjdENvbXBvbmVudCIsImlzUHVyZVJlYWN0Q29tcG9uZW50Iiwib2xkRGlmZkhvb2siLCJfX2YiLCJSRUFDVF9GT1JXQVJEX1NZTUJPTCIsIlN5bWJvbCIsImZvciIsImZvcndhcmRSZWYiLCJmbiIsIkZvcndhcmRlZCIsImNsb25lIiwiJCR0eXBlb2YiLCJvbGRDYXRjaEVycm9yIiwidGhlbiIsIm9sZFVubW91bnQiLCJkZXRhY2hlZENsb25lIiwiZGV0YWNoZWRQYXJlbnQiLCJlZmZlY3QiLCJtYXAiLCJyZW1vdmVPcmlnaW5hbCIsIm9yaWdpbmFsUGFyZW50IiwiU3VzcGVuc2UiLCJfX3UiLCJfc3VzcGVuZGVycyIsInN1c3BlbmRlZCIsIl9fYSIsIlN1c3BlbnNlTGlzdCIsIl9uZXh0IiwiX21hcCIsIl9fUiIsInByb21pc2UiLCJzdXNwZW5kaW5nVk5vZGUiLCJzdXNwZW5kaW5nQ29tcG9uZW50IiwicmVzb2x2ZSIsInJlc29sdmVkIiwib25SZXNvbHZlZCIsIm9uU3VzcGVuc2lvbkNvbXBsZXRlIiwic3VzcGVuZGVkVk5vZGUiLCJwb3AiLCJ3YXNIeWRyYXRpbmciLCJkZXRhY2hlZENvbXBvbmVudCIsIl9fTyIsImZhbGxiYWNrIiwibGlzdCIsImRlbGV0ZSIsInJldmVhbE9yZGVyIiwic2l6ZSIsIkNvbnRleHRQcm92aWRlciIsIlBvcnRhbCIsIl90aGlzIiwiY29udGFpbmVyIiwiX2NvbnRhaW5lciIsIl90ZW1wIiwiYmVmb3JlIiwiY3JlYXRlUG9ydGFsIiwiZWwiLCJjb250YWluZXJJbmZvIiwiZGVsZWdhdGVkIiwiZ2V0IiwidW5zdXNwZW5kIiwid3JhcHBlZFVuc3VzcGVuZCIsIk1hcCIsInJldmVyc2UiLCJzZXQiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJDQU1FTF9QUk9QUyIsIklTX0RPTSIsIm9uQ2hhbmdlSW5wdXRUeXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJ2Iiwid3JpdGFibGUiLCJvbGRFdmVudEhvb2siLCJlbXB0eSIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiY2FuY2VsQnViYmxlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsInBlcnNpc3QiLCJuYXRpdmVFdmVudCIsImNsYXNzTmFtZURlc2NyaXB0b3IiLCJjbGFzcyIsIm9sZFZOb2RlSG9vayIsIm5vbkN1c3RvbUVsZW1lbnQiLCJtdWx0aXBsZSIsInNlbGVjdGVkIiwiY2xhc3NOYW1lIiwiZW51bWVyYWJsZSIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiRXZlbnREZXRhaWwiLCJlbmhhbmNlRXZlbnQiLCJkZXRhaWwiLCJhbHJlYWR5V2FybmVkIiwiU2V0Iiwib3ZlcndyaXRlV2l0aFdhcm5pbmciLCJjb21wb25lbnROYW1lIiwicHJvcE5hbWUiLCJuZXdWYWx1ZSIsImhhcyIsIlN0cmluZyIsImFkZCIsImNvbnNvbGUiLCJ3YXJuIiwiZGVidWdMb2ciLCJ3aG8iLCJQcmVmaWNlcyIsImFjY29yZGlvblNlY3Rpb25IZWFkZXJCdXR0b24iLCJhY2NvcmRpb25TZWN0aW9uQm9keSIsImNoZWNrYm94TGlrZUlucHV0IiwiY2hlY2tib3hMaWtlTGFiZWwiLCJkaWFsb2ciLCJkaWFsb2dUaXRsZSIsImRyYXdlciIsImRyYXdlclRpdGxlIiwiZ3JpZGxpc3QiLCJncmlkbGlzdExhYmVsIiwibGlzdGJveCIsImxpc3Rib3hMYWJlbCIsIm1lbnUiLCJwcm9ncmVzc0luZGljYXRvciIsInByb2dyZXNzTGFiZWwiLCJyYWRpb0dyb3VwIiwicmFkaW9Hcm91cExhYmVsIiwicmFkaW8iLCJyYWRpb0xhYmVsIiwic2xpZGVyVGh1bWIiLCJ0YWJsZSIsInRhYmxlTGFiZWwiLCJ0YWJsaXN0IiwidGFibGlzdExhYmVsIiwidG9vbHRpcCIsIkhlYWRpbmdMZXZlbENvbnRleHQiLCJIZWFkaW5nIiwiaGVhZGluZyIsInRhZyIsImhlYWRpbmdMZXZlbEJlZm9yZVVzIiwibmV3SGVhZGluZ0xldmVsIiwiX2pzeCIsIl9GcmFnbWVudCIsIl9qc3hzIiwiSGVhZGluZ1Jlc2V0IiwibmV3TGV2ZWwiLCJ1c2VFbnN1cmVTdGFiaWxpdHkiLCJwYXJlbnRIb29rTmFtZSIsInZhbHVlcyIsImhlbHBlclRvRW5zdXJlU3RhYmlsaXR5Iiwic2hvd25FcnJvciIsInVzZUhlbHBlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1c2VQYXNzaXZlU3RhdGUiLCJvbkNoYW5nZSIsImdldEluaXRpYWxWYWx1ZSIsImN1c3RvbURlYm91bmNlUmVuZGVyaW5nIiwidmFsdWVSZWYiLCJVbnNldCIsInJlYXNvblJlZiIsIndhcm5pbmdSZWYiLCJkZXBlbmRlbmN5VG9Db21wYXJlQWdhaW5zdCIsImNsZWFudXBDYWxsYmFja1JlZiIsIm9uU2hvdWxkQ2xlYW5VcCIsImNsZWFudXBDYWxsYmFjayIsInRyeUVuc3VyZVZhbHVlIiwiZXgiLCJnZXRWYWx1ZSIsInNldFZhbHVlIiwicmVhc29uIiwiRnVuY3Rpb24iLCJuZXh0UmVhc29uIiwibmV4dERlcCIsInByZXZEZXAiLCJyZXR1cm5UcnVlIiwicmV0dXJuRmFsc2UiLCJyZXR1cm5OdWxsIiwicmV0dXJuWmVybyIsImlkZW50aXR5IiwidCIsInJ1bkltbWVkaWF0ZWx5IiwiYWN0aXZlRWxlbWVudFVwZGF0ZXJzIiwibGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyIsIndpbmRvd0ZvY3VzZWRVcGRhdGVycyIsIndpbmRvd3NGb2N1c2VkVXBkYXRlcnMiLCJmb3JFYWNoVXBkYXRlciIsIndpbmRvdyIsInVwZGF0ZXJzIiwidXBkYXRlciIsImxhc3RTZW50Iiwic2VuZCIsImZvY3Vzb3V0IiwidGFyZ2V0Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwicmVsYXRlZFRhcmdldCIsImZvY3VzaW4iLCJjdXJyZW50bHlGb2N1c2VkRWxlbWVudCIsIndpbmRvd0ZvY3VzIiwiV2luZG93IiwiY3VycmVudFRhcmdldCIsIndpbmRvd0JsdXIiLCJ1c2VBY3RpdmVFbGVtZW50IiwiYWN0aXZlRWxlbWVudFBhcmFtZXRlcnMiLCJvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UiLCJvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlIiwib25XaW5kb3dGb2N1c2VkQ2hhbmdlIiwiZ2V0RG9jdW1lbnQiLCJnZXRXaW5kb3ciLCJwYXNzaXZlIiwibG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMiLCJsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMiLCJsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyIsImxhZXUiLCJzZXRBY3RpdmVFbGVtZW50IiwibGxhZXUiLCJzZXRMYXN0QWN0aXZlRWxlbWVudCIsImx3ZnUiLCJzZXRXaW5kb3dGb2N1c2VkIiwiZ2V0QWN0aXZlRWxlbWVudCIsImdldExhc3RBY3RpdmVFbGVtZW50IiwiZ2V0V2luZG93Rm9jdXNlZCIsImFjdGl2ZUVsZW1lbnRSZXR1cm4iLCJUYWJsZSIsImJhc2U2NCIsInJhbmRvbTZCaXRzIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicmFuZG9tNjRCaXRzIiwiZ2VuZXJhdGVSYW5kb21JZCIsInByZWZpeCIsIm4iLCJqb2luIiwicHJldmlvdXNJbnB1dHMiLCJ0b1J1biIsImNvbW1pdE5hbWUiLCJvcmlnaW5hbENvbW1pdCIsIm5ld0NvbW1pdCIsImlkIiwiZWZmZWN0SW5mbyIsIm9sZElucHV0cyIsImlucHV0cyIsImNsZWFyIiwidXNlQmVmb3JlTGF5b3V0RWZmZWN0IiwidXNlU3RhYmxlR2V0dGVyIiwiRXJyb3IiLCJ1c2VTdGFibGVPYmplY3QiLCJlbnRyaWVzIiwiX2siLCJXZWFrTWFwIiwiaXNTdGFibGVHZXR0ZXIiLCJzZXRJc1N0YWJsZUdldHRlciIsInVzZVN0YWJsZUNhbGxiYWNrIiwibm9EZXBzIiwiY3VycmVudENhbGxiYWNrR2V0dGVyIiwidXNlQ2FsbGJhY2tOYXRpdmUiLCJhc3NlcnQiLCJ1c2VNYW5hZ2VkQ2hpbGRyZW4iLCJwYXJlbnRQYXJhbWV0ZXJzIiwibWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyIsIm9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCIsIm9uQ2hpbGRyZW5Nb3VudENoYW5nZSIsInJlc3QiLCJnZXRIaWdoZXN0SW5kZXgiLCJtYW5hZ2VkQ2hpbGRyZW5BcnJheSIsImhpZ2hlc3RJbmRleCIsImFyciIsInJlYyIsImxvd2VzdEluZGV4IiwiZm9yRWFjaENoaWxkIiwiZmllbGQiLCJnZXRNYW5hZ2VkQ2hpbGRJbmZvIiwiaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkIiwicmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyIsInJlbW90ZVVMRUNoaWxkQ2hhbmdlZCIsInJlbW90ZVVMRUNoaWxkTW91bnRlZCIsIm1vdW50ZWQiLCJtb3VudHMiLCJ1bm1vdW50cyIsIm1heCIsInNoYXZlIiwibWFuYWdlZENoaWxkcmVuIiwiXyIsImdldEF0IiwiYXJyYXlTbGljZSIsImdldENoaWxkcmVuIiwibWFuYWdlZENoaWxkQ29udGV4dCIsIm1hbmFnZWRDaGlsZHJlblJldHVybiIsInVzZU1hbmFnZWRDaGlsZCIsImluZm8iLCJtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIiwiZmxhdCIsIm1hbmFnZWRDaGlsZFJldHVybiIsInVzZUNoaWxkcmVuRmxhZyIsImluaXRpYWxJbmRleCIsImNsb3Nlc3RGaXQiLCJvbkluZGV4Q2hhbmdlIiwic2V0QXQiLCJpc1ZhbGlkIiwiZ2V0Q3VycmVudEluZGV4Iiwic2V0Q3VycmVudEluZGV4IiwiZ2V0UmVxdWVzdGVkSW5kZXgiLCJzZXRSZXF1ZXN0ZWRJbmRleCIsImdldENsb3Nlc3RGaXQiLCJyZXF1ZXN0ZWRJbmRleCIsImNsb3Nlc3REaXN0YW5jZSIsIkluZmluaXR5IiwiY2xvc2VzdEluZGV4IiwibmV3RGlzdGFuY2UiLCJhYnMiLCJyZWV2YWx1YXRlQ2xvc2VzdEZpdCIsImN1cnJlbnRDaGlsZCIsImNsb3Nlc3RGaXRJbmRleCIsImNsb3Nlc3RGaXRDaGlsZCIsImNoYW5nZUluZGV4IiwibmV3TWF0Y2hpbmdDaGlsZCIsIm9sZE1hdGNoaW5nQ2hpbGQiLCJ1c2VNZXJnZWRDaGlsZHJlbiIsImxocyIsInJocyIsImNsc3giLCJ1c2VNZXJnZWRDbGFzc2VzIiwibGhzQ2xhc3MiLCJsaHNDbGFzc05hbWUiLCJyaHNDbGFzcyIsInJoc0NsYXNzTmFtZSIsImxoc0NsYXNzZXMiLCJzcGxpdCIsInJoc0NsYXNzZXMiLCJhbGxDbGFzc2VzIiwiZnJvbSIsInByb2Nlc3NSZWYiLCJpbnN0YW5jZSIsInVzZU1lcmdlZFJlZnMiLCJjb21iaW5lZCIsInN0eWxlU3RyaW5nVG9PYmplY3QiLCJmcm9tRW50cmllcyIsInN0YXRlbWVudCIsInVzZU1lcmdlZFN0eWxlcyIsImxvZyIsInVzZU1lcmdlZFByb3BzIiwiYWxsUHJvcHMiLCJyZXQiLCJ1c2VNZXJnZWRQcm9wczIiLCJrbm93bnMiLCJtZXJnZVVua25vd24iLCJsaHNWYWx1ZSIsInJoc1ZhbHVlIiwibWVyZ2VkIiwibWVyZ2VGdW5jdGlvbnMiLCJsaHNBbGwiLCJyaHNBbGwiLCJsaHNLZXlVIiwibGhzS2V5IiwicmhzS2V5VSIsInJoc0tleSIsImx2IiwicnYiLCJQcm9taXNlIiwiYWxsIiwidXNlR2xvYmFsSGFuZGxlciIsImhhbmRsZXIiLCJzdGFibGVIYW5kbGVyIiwidXNlUmVmRWxlbWVudCIsInJlZkVsZW1lbnRQYXJhbWV0ZXJzIiwib25FbGVtZW50Q2hhbmdlIiwib25Nb3VudCIsIm9uVW5tb3VudCIsInByZXZWYWx1ZSIsImdldEVsZW1lbnQiLCJzZXRFbGVtZW50IiwicHJvcHNTdGFibGUiLCJyZWZFbGVtZW50UmV0dXJuIiwiTWFnaWNXaW5kb3dLZXkiLCJnZXRFbGVtZW50RGVwdGgiLCJlbGVtZW50IiwiZGVwdGgiLCJwYXJlbnQiLCJwYXJlbnRFbGVtZW50IiwidXNlRXNjYXBlRGlzbWlzcyIsImVzY2FwZURpc21pc3NQYXJhbWV0ZXJzIiwib25DbG9zZSIsIm9wZW4iLCJ1bnN0YWJsZUdldFdpbmRvdyIsInBhcmVudERlcHRoIiwicmVmRWxlbWVudFBvcHVwUmV0dXJuIiwidm9pZDEiLCJ2b2lkMiIsInN0YWJsZU9uQ2xvc2UiLCJnZXREZXB0aCIsIm1pY3JvdGFza1F1ZXVlZCIsImVsZW1lbnRRdWV1ZSIsImNhcHR1cmUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIm9uQ2xvc2UyIiwidHJlZURlcHRoIiwiZGVlcGVzdERlcHRoIiwiZGVlcGVzdFRyZWVEZXB0aCIsImRlZXBlc3RPbkNsb3NlIiwidGllQnJva2VuIiwidXNlTG9zdEZvY3VzRGlzbWlzcyIsImdldFBvcHVwRWxlbWVudCIsInJlZkVsZW1lbnRTb3VyY2VSZXR1cm4iLCJsb3N0Rm9jdXNEaXNtaXNzIiwidm9pZDMiLCJnZXRTb3VyY2VFbGVtZW50IiwiZ2V0T3BlbiIsIm5ld0VsZW1lbnQiLCJfcHJldkVsZW1lbnQiLCJfZSIsInNvdXJjZUVsZW1lbnQiLCJwb3B1cEVsZW1lbnQiLCJjb250YWlucyIsInVzZUJhY2tkcm9wRGlzbWlzcyIsImJhY2tkcm9wRGlzbWlzc1BhcmFtZXRlcnMiLCJvbkNsb3NlVW5zdGFibGUiLCJvbkJhY2tkcm9wQ2xpY2siLCJmb3VuZEluc2lkZUNsaWNrIiwidXNlRGlzbWlzcyIsImRpc21pc3NQYXJhbWV0ZXJzIiwiZ2xvYmFsT3BlbiIsImdsb2JhbE9uQ2xvc2UiLCJjbG9zZU9uQmFja2Ryb3AiLCJjbG9zZU9uRXNjYXBlIiwiY2xvc2VPbkxvc3RGb2N1cyIsIm9uQ2xvc2VCYWNrZHJvcCIsIm9uQ2xvc2VFc2NhcGUiLCJvbkNsb3NlRm9jdXMiLCJjYW5kaWRhdGVTZWxlY3RvcnMiLCJOb0VsZW1lbnQiLCJFbGVtZW50IiwibWF0Y2hlcyIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiZ2V0Um9vdE5vZGUiLCJpc0lucHV0IiwidGFnTmFtZSIsImlzSGlkZGVuSW5wdXQiLCJpc0RldGFpbHNXaXRoU3VtbWFyeSIsImFwcGx5IiwiaXNOb2RlQXR0YWNoZWQiLCJfbm9kZVJvb3RIb3N0Iiwibm9kZVJvb3RIb3N0IiwiaG9zdCIsImF0dGFjaGVkIiwiX25vZGVSb290SG9zdDIiLCJpc1plcm9BcmVhIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJpc0hpZGRlbiIsIl9yZWYiLCJkaXNwbGF5Q2hlY2siLCJnZXRTaGFkb3dSb290IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInZpc2liaWxpdHkiLCJpc0RpcmVjdFN1bW1hcnkiLCJub2RlVW5kZXJEZXRhaWxzIiwib3JpZ2luYWxOb2RlIiwicm9vdE5vZGUiLCJzaGFkb3dSb290IiwiYXNzaWduZWRTbG90IiwiZ2V0Q2xpZW50UmVjdHMiLCJpc0Rpc2FibGVkRnJvbUZpZWxkc2V0IiwiZGlzYWJsZWQiLCJpdGVtIiwiaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSIsImZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yIiwiaXNGb2N1c2FibGUiLCJnbG9iYWwiLCJfY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVzY3JpcHRvciIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsYXNzQ2FsbENoZWNrIiwiVHlwZUVycm9yIiwiX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nIiwiSW5lcnRSb290Iiwicm9vdEVsZW1lbnQiLCJpbmVydE1hbmFnZXIiLCJfaW5lcnRNYW5hZ2VyIiwiX3Jvb3RFbGVtZW50IiwiX21hbmFnZWROb2RlcyIsImhhc0F0dHJpYnV0ZSIsIl9zYXZlZEFyaWFIaWRkZW4iLCJnZXRBdHRyaWJ1dGUiLCJfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSIsIl9vYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJfb25NdXRhdGlvbiIsImJpbmQiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsImRlc3RydWN0b3IiLCJkaXNjb25uZWN0IiwiaW5lcnROb2RlIiwiX3VubWFuYWdlTm9kZSIsInN0YXJ0Tm9kZSIsIl90aGlzMiIsImNvbXBvc2VkVHJlZVdhbGsiLCJfdmlzaXROb2RlIiwiYWN0aXZlRWxlbWVudCIsImJvZHkiLCJOb2RlIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImJsdXIiLCJmb2N1cyIsIkVMRU1FTlRfTk9ERSIsIl9hZG9wdEluZXJ0Um9vdCIsIl9tYW5hZ2VOb2RlIiwicmVnaXN0ZXIiLCJkZXJlZ2lzdGVyIiwiX3VubWFuYWdlU3VidHJlZSIsIl90aGlzMyIsImluZXJ0U3Vicm9vdCIsImdldEluZXJ0Um9vdCIsInNldEluZXJ0IiwibWFuYWdlZE5vZGVzIiwic2F2ZWRJbmVydE5vZGUiLCJyZWNvcmRzIiwic2VsZiIsInJlY29yZCIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJhdHRyaWJ1dGVOYW1lIiwibWFuYWdlZE5vZGUiLCJhcmlhSGlkZGVuIiwiSW5lcnROb2RlIiwiaW5lcnRSb290IiwiX25vZGUiLCJfb3ZlcnJvZGVGb2N1c01ldGhvZCIsIl9pbmVydFJvb3RzIiwiX3NhdmVkVGFiSW5kZXgiLCJfZGVzdHJveWVkIiwiZW5zdXJlVW50YWJiYWJsZSIsIl90aHJvd0lmRGVzdHJveWVkIiwiZGVzdHJveWVkIiwidGFiSW5kZXgiLCJoYXNTYXZlZFRhYkluZGV4IiwiYWRkSW5lcnRSb290IiwicmVtb3ZlSW5lcnRSb290IiwiSW5lcnRNYW5hZ2VyIiwiX2RvY3VtZW50IiwiX3dhdGNoRm9ySW5lcnQiLCJhZGRJbmVydFN0eWxlIiwiaGVhZCIsImRvY3VtZW50RWxlbWVudCIsInJlYWR5U3RhdGUiLCJfb25Eb2N1bWVudExvYWRlZCIsImluZXJ0IiwiX2luZXJ0Um9vdCIsImluZXJ0RWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5lcnRFbGVtZW50IiwidW5zaGlmdCIsInNoYWRvd1Jvb3RBbmNlc3RvciIsImNvbnRlbnQiLCJkaXN0cmlidXRlZE5vZGVzIiwiZ2V0RGlzdHJpYnV0ZWROb2RlcyIsInNsb3QiLCJfZGlzdHJpYnV0ZWROb2RlcyIsImFzc2lnbmVkTm9kZXMiLCJmbGF0dGVuIiwiX2kiLCJxdWVyeVNlbGVjdG9yIiwidGV4dENvbnRlbnQiLCJIVE1MRWxlbWVudCIsImhhc093blByb3BlcnR5IiwiX2Jsb2NraW5nRWxlbWVudHMiLCJfYWxyZWFkeUluZXJ0RWxlbWVudHMiLCJfdG9wRWxQYXJlbnRzIiwiX3NpYmxpbmdzVG9SZXN0b3JlIiwiX3BhcmVudE1PIiwiX3RvcENoYW5nZWQiLCJfc3dhcEluZXJ0ZWRTaWJsaW5nIiwiX2luZXJ0U2libGluZ3MiLCJfcmVzdG9yZUluZXJ0ZWRTaWJsaW5ncyIsIl9nZXRQYXJlbnRzIiwiX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4iLCJfaXNJbmVydGFibGUiLCJfaGFuZGxlTXV0YXRpb25zIiwiQmxvY2tpbmdFbGVtZW50c0ltcGwiLCJfYSIsIl9iIiwiX2MiLCJudWxsYWJsZSIsInRvcCIsImVsZW1zIiwicmVtb3ZlIiwibmV3VG9wIiwidG9LZWVwSW5lcnQiLCJvbGRQYXJlbnRzIiwibmV3UGFyZW50cyIsInRvU2tpcCIsIm9sZEluZXJ0IiwibmV3SW5lcnQiLCJzaWJsaW5nc1RvUmVzdG9yZSIsImVsZW1lbnRzIiwibW8iLCJzaWJsaW5ncyIsImluZXJ0ZWRTaWJsaW5ncyIsInBhcmVudFRvT2JzZXJ2ZSIsIm1heWJlU2hhZHlSb290IiwiX19zaGFkeSIsIm11dGF0aW9ucyIsInBhcmVudHMiLCJtdXRhdGlvbiIsImlkeCIsImluZXJ0ZWRDaGlsZCIsInJlc3VsdCIsIm5vZGVzIiwic2xvdHMiLCIkYmxvY2tpbmdFbGVtZW50cyIsImdsb2JhbFRoaXMiLCJibG9ja2luZ0VsZW1lbnRzIiwidXNlQmxvY2tpbmdFbGVtZW50IiwiZW5hYmxlZCIsImdldFRhcmdldCIsInN0YWJsZUdldFRhcmdldCIsInNldExhc3RBY3RpdmVXaGVuT3BlbiIsInNldExhc3RBY3RpdmVXaGVuQ2xvc2VkIiwiZ2V0VG9wIiwic2V0VG9wIiwiZ2V0TGFzdEFjdGl2ZVdoZW5DbG9zZWQiLCJnZXRMYXN0QWN0aXZlV2hlbk9wZW4iLCJ1c2VGb2N1c1RyYXAiLCJmb2N1c1RyYXBQYXJhbWV0ZXJzIiwib25seU1vdmVGb2N1cyIsInRyYXBBY3RpdmUiLCJmb2N1c1BvcHVwIiwiZm9jdXNTZWxmVW5zdGFibGUiLCJmb2N1c09wZW5lciIsImZvY3VzT3BlbmVyVW5zdGFibGUiLCJmb2N1c1NlbGYiLCJmaW5kRmlyc3RGb2N1c2FibGUiLCJsYXN0QWN0aXZlIiwiZm9jdXNUcmFwUmV0dXJuIiwicHJvcHNVbnN0YWJsZSIsInRyZWVXYWxrZXIiLCJjcmVhdGVUcmVlV2Fsa2VyIiwiTm9kZUZpbHRlciIsIlNIT1dfRUxFTUVOVCIsImFjY2VwdE5vZGUiLCJGSUxURVJfQUNDRVBUIiwiRklMVEVSX1NLSVAiLCJmaXJzdEZvY3VzYWJsZSIsInVzZVRleHRDb250ZW50IiwidGV4dENvbnRlbnRQYXJhbWV0ZXJzIiwiZ2V0VGV4dCIsIm9uVGV4dENvbnRlbnRDaGFuZ2UiLCJnZXRUZXh0Q29udGVudCIsInNldFRleHRDb250ZW50IiwidGV4dENvbnRlbnRSZXR1cm4iLCJzZXRTdGF0ZVAiLCJ1c2VTdGF0ZVAiLCJnZXRTdGF0ZSIsImlzTmFOIiwidXNlTGluZWFyTmF2aWdhdGlvbiIsInJvdmluZ1RhYkluZGV4UmV0dXJuIiwibGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMiLCJpbmRleERlbWFuZ2xlciIsImluZGV4TWFuZ2xlciIsIm5hdmlnYXRlUGFzdEVuZCIsIm5hdmlnYXRlUGFzdFN0YXJ0IiwiZ2V0VGFiYmFibGVJbmRleCIsInNldFRhYmJhYmxlSW5kZXgiLCJuYXZpZ2F0ZUFic29sdXRlIiwiZnJvbVVzZXJJbnRlcmFjdGlvbiIsInRyeU5hdmlnYXRlVG9JbmRleCIsImhpZ2hlc3RDaGlsZEluZGV4Iiwic2VhcmNoRGlyZWN0aW9uIiwibmF2aWdhdGVUb0ZpcnN0IiwibmF2aWdhdGVUb0xhc3QiLCJuYXZpZ2F0ZVJlbGF0aXZlMiIsIm9mZnNldCIsIm1vZGUiLCJzdGF0dXMiLCJzaWduIiwibmF2aWdhdGVUb05leHQiLCJuYXZpZ2F0ZVRvUHJldiIsImdldERpc2FibGVBcnJvd0tleXMiLCJkaXNhYmxlQXJyb3dLZXlzIiwiZ2V0RGlzYWJsZUhvbWVFbmRLZXlzIiwiZGlzYWJsZUhvbWVFbmRLZXlzIiwiZ2V0TmF2aWdhdGlvbkRpcmVjdGlvbiIsIm5hdmlnYXRpb25EaXJlY3Rpb24iLCJnZXRQYWdlTmF2aWdhdGlvblNpemUiLCJwYWdlTmF2aWdhdGlvblNpemUiLCJzdGFibGVQcm9wcyIsIm9uS2V5RG93biIsImN0cmxLZXkiLCJtZXRhS2V5IiwiYWxsb3dzVmVydGljYWxOYXZpZ2F0aW9uIiwiYWxsb3dzSG9yaXpvbnRhbE5hdmlnYXRpb24iLCJ0cnVlUGFnZU5hdmlnYXRpb25TaXplIiwicm91bmQiLCJkaXJlY3Rpb25BbGxvd2VkIiwibGluZWFyTmF2aWdhdGlvblJldHVybiIsInVwcGVyIiwibG93ZXIiLCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uIiwidHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMiLCJjb2xsYXRvciIsInR5cGVhaGVhZFRpbWVvdXQiLCJub1R5cGVhaGVhZCIsImdldEluZGV4Iiwic2V0SW5kZXgiLCJfdm9pZDMiLCJfdm9pZDEiLCJfdm9pZDIiLCJnZXRDdXJyZW50VHlwZWFoZWFkIiwic2V0Q3VycmVudFR5cGVhaGVhZCIsImN1cnJlbnRUeXBlYWhlYWQiLCJwcmV2IiwiaGFuZGxlIiwic2V0SW52YWxpZFR5cGVhaGVhZCIsInVwZGF0ZUJhc2VkT25UeXBlYWhlYWRDaGFuZ2UiLCJzb3J0ZWRUeXBlYWhlYWRJbmZvIiwiaW52YWxpZFR5cGVhaGVhZCIsInNldEltZUFjdGl2ZSIsImdldEltZUFjdGl2ZSIsIm5leHRUeXBlYWhlYWRDaGFyIiwic2V0TmV4dFR5cGVhaGVhZENoYXIiLCJ0eXBlYWhlYWQiLCJjb21wYXJhdG9yU2hhcmVkIiwic2FmZUxocyIsInNhZmVSaHMiLCJjb21wYXJlIiwibm9ybWFsaXplIiwibG9jYWxlQ29tcGFyZSIsImluc2VydGluZ0NvbXBhcmF0b3IiLCJ0ZXh0IiwidHlwZWFoZWFkQ29tcGFyYXRvciIsInN1YnN0cmluZyIsImlzRGlzYWJsZWQiLCJpbWVBY3RpdmUiLCJpc0NoYXJhY3RlcktleSIsInRyaW0iLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJvbkNvbXBvc2l0aW9uRW5kIiwidHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkQ29udGV4dCIsInR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMiLCJ0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuIiwic29ydGVkVHlwZWFoZWFkSW5kZXgiLCJiaW5hcnlTZWFyY2giLCJsb3dlc3RVbnNvcnRlZEluZGV4QWxsIiwibG93ZXN0U29ydGVkSW5kZXhBbGwiLCJsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCIsImxvd2VzdFNvcnRlZEluZGV4TmV4dCIsInVwZGF0ZUJlc3RGaXQiLCJ1IiwidW5zb3J0ZWRJbmRleCIsInVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCIsInZvaWQ1Iiwidm9pZDQiLCJzb3J0ZWRJbmRleCIsImFycmF5Iiwid2FudGVkIiwiY29tcGFyYXRvciIsImZpcnN0SW5kZXgiLCJsYXN0SW5kZXgiLCJ0ZXN0SW5kZXgiLCJjb21wYXJpc29uUmVzdWx0IiwidXNlUm92aW5nVGFiSW5kZXgiLCJyb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMiLCJ1bnRhYmJhYmxlIiwiaW5pdGlhbGx5VGFiYmVkSW5kZXgiLCJvblRhYmJhYmxlSW5kZXhDaGFuZ2UiLCJzZXRUYWJiYWJsZUluZGV4MyIsInByZXZJbmRleCIsIm5leHRJbmRleCIsIm5leHRDaGlsZCIsImhpZGRlbiIsImxhc3ROb25OdWxsSW5kZXgiLCJnZXRUYWJiYWJsZUF0IiwibSIsImdldFRhYmJhYmxlIiwic2V0VGFiYmFibGVBdCIsInNldFRhYmJhYmxlIiwiaXNUYWJiYWJsZVZhbGlkIiwicm92aW5nVGFiSW5kZXhDaGlsZENvbnRleHQiLCJ1c2VSb3ZpbmdUYWJJbmRleENoaWxkIiwicm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMiLCJ0YWJiYWJsZSIsImhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMiLCJvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkIiwiZm9jdXNlZCIsIl9wcmV2Rm9jdXNlZCIsInJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm4iLCJ1c2VMaXN0TmF2aWdhdGlvbiIsInJ0aXIiLCJ0bnIiLCJsbnIiLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkIiwicnRpY3IiLCJ1c2VHcmlkTmF2aWdhdGlvbiIsImdyaWROYXZpZ2F0aW9uUGFyYW1ldGVycyIsIm9uVGFiYmFibGVDb2x1bW5DaGFuZ2UiLCJnZXRDdXJyZW50VGFiYmFibGVDb2x1bW4iLCJzZXRDdXJyZW50VGFiYmFibGVDb2x1bW4iLCJvblRhYmJhYmxlSW5kZXhDaGFuZ2VPdmVycmlkZSIsInNldFRhYmJhYmxlQ29sdW1uSW5kZXgiLCJncmlkTmF2aWdhdGlvblJvd0NvbnRleHQiLCJncmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMiLCJzZXRUYWJiYWJsZVJvdyIsInVzZUdyaWROYXZpZ2F0aW9uUm93IiwiYXNDaGlsZFJvd1BhcmFtZXRlcnMiLCJhc1BhcmVudFJvd1BhcmFtZXRlcnMiLCJhc0NoaWxkUm93T2ZUYWJsZSIsImFzUGFyZW50Um93T2ZDZWxsc1AiLCJsbmNyIiwiYXNDaGlsZFJvd1JldHVybiIsImFzUGFyZW50Um93UmV0dXJuIiwiZ3JpZE5hdmlnYXRpb25DZWxsQ29udGV4dCIsImdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnMiLCJnZXRSb3dJbmRleCIsInNldFRhYmJhYmxlQ2VsbCIsInVzZUdyaWROYXZpZ2F0aW9uQ2VsbCIsImNvbFNwYW4iLCJfZ2V0Q3VycmVudENvbHVtbiIsIm9jZmljMSIsInVzZVNpbmdsZVNlbGVjdGlvbiIsInNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMiLCJzZXRTZWxlY3RlZEluZGV4Iiwic2V0U2VsZWN0ZWRJbmRleEV4dGVybmFsIiwiaW5pdGlhbGx5U2VsZWN0ZWRJbmRleCIsImdldFNlbGVjdGVkQXQiLCJnZXRTZWxlY3RlZCIsInNldFNlbGVjdGVkQXQiLCJzZXRMb2NhbFNlbGVjdGVkIiwiaXNTZWxlY3RlZFZhbGlkIiwic2V0U2VsZWN0ZWRJbmRleEludGVybmFsIiwiZ2V0U2VsZWN0ZWRJbmRleCIsInNpbmdsZVNlbGVjdGlvblJldHVybiIsInNpbmdsZVNlbGVjdGlvbkNvbnRleHQiLCJjaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnMiLCJvbkNvbXBvc2l0ZUZvY3VzQ2hhbmdlIiwiYW55Rm9jdXNlZCIsInNlbGVjdGVkSW5kZXgiLCJ1c2VTaW5nbGVTZWxlY3Rpb25DaGlsZCIsInNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVycyIsImFyaWFQcm9wTmFtZSIsInNlbGVjdGlvbk1vZGUiLCJnZXREaXNhYmxlZCIsInNldFNlbGVjdGVkIiwiX3ByZXYiLCJvblByZXNzU3luYyIsInNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuIiwic2V0VGhpc09uZVNlbGVjdGVkIiwidG9TdHJpbmciLCJwcmVzc1BhcmFtZXRlcnMiLCJ1c2VTaW5nbGVTZWxlY3Rpb25EZWNsYXJhdGl2ZSIsInNpbmdsZVNlbGVjdGlvbkRlY2xhcmF0aXZlUGFyYW1ldGVycyIsInVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uIiwiZ25yIiwic3NyIiwidXNlR3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Sb3ciLCJvY2ZpYzIiLCJwcmV2Rm9jdXNlZCIsInVzZUdyaWROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2VsbCIsImNvcHlBcnJheSIsInNvdXJjZSIsIm5hdGl2ZUZsb29yIiwibmF0aXZlUmFuZG9tIiwiYmFzZVJhbmRvbSIsInNodWZmbGVTZWxmIiwicmFuZCIsImFycmF5U2h1ZmZsZSIsImFycmF5TWFwIiwiaXRlcmF0ZWUiLCJiYXNlVmFsdWVzIiwib2JqZWN0IiwiYmFzZVRpbWVzIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwib2JqZWN0UHJvdG8iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJnZXRSYXdUYWciLCJpc093biIsInVubWFza2VkIiwib2JqZWN0VG9TdHJpbmciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwiYmFzZUdldFRhZyIsImlzT2JqZWN0TGlrZSIsImFyZ3NUYWciLCJiYXNlSXNBcmd1bWVudHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzQXJndW1lbnRzIiwic3R1YkZhbHNlIiwiZnJlZUV4cG9ydHMiLCJleHBvcnRzIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsInJlSXNVaW50IiwiaXNJbmRleCIsImlzTGVuZ3RoIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJiYXNlSXNUeXBlZEFycmF5IiwiYmFzZVVuYXJ5IiwiZnVuYyIsImZyZWVQcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNCdWZmIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJpc1Byb3RvdHlwZSIsIkN0b3IiLCJwcm90byIsIm92ZXJBcmciLCJ0cmFuc2Zvcm0iLCJuYXRpdmVLZXlzIiwia2V5cyIsImJhc2VLZXlzIiwiaXNPYmplY3QiLCJhc3luY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiaXNGdW5jdGlvbiIsImlzQXJyYXlMaWtlIiwiYmFzZVNodWZmbGUiLCJjb2xsZWN0aW9uIiwic2h1ZmZsZSIsInVzZUZvcmNlVXBkYXRlIiwidXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuIiwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVycyIsIm1hbmdsZU1hcCIsImRlbWFuZ2xlTWFwIiwibWFuYWdlZFJvd3MiLCJzaHVmZmxlZFJvd3MiLCJsb2Rhc2hTaHVmZmxlIiwicmVhcnJhbmdlIiwiZ2V0Rm9yY2VVcGRhdGUiLCJzZXRGb3JjZVVwZGF0ZSIsInNvcnRlZFJvd3MiLCJpbmRleEFzU29ydGVkIiwiaW5kZXhBc1Vuc29ydGVkIiwidXNlUmVhcnJhbmdlYWJsZVByb3BzIiwibWFuZ2xlZEluZGV4IiwiZGVtYW5nbGVkSW5kZXgiLCJoIiwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuIiwidXNlU29ydGFibGVDaGlsZHJlbiIsInNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzIiwidXNlckNvbXBhcmUiLCJnZXRDb21wYXJlIiwiZGVmYXVsdENvbXBhcmUiLCJkaXJlY3Rpb24iLCJsaHNSb3ciLCJyaHNSb3ciLCJzb3J0YWJsZUNoaWxkcmVuUmV0dXJuIiwiY29tcGFyZTEiLCJnZXRTb3J0VmFsdWUiLCJ1c2VHcmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblNvcnRhYmxlIiwiZ3JpZE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzIiwic2NyIiwidXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb24iLCJ1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkIiwiX3ZvaWQ1Iiwidm9pZDciLCJzc2NyIiwiX3ZvaWQ2IiwicHJldmlvdXNseUZvY3VzZWQiLCJ1c2VDaGlsZHJlbkhhdmVGb2N1cyIsImdldEFueUZvY3VzZWQiLCJzZXRBbnlGb2N1c2VkIiwiX2dldEZvY3VzQ291bnQiLCJzZXRGb2N1c0NvdW50IiwiYW55UHJldmlvdXNseUZvY3VzZWQiLCJjaGlsZHJlbkhhdmVGb2N1c1JldHVybiIsImNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRDb250ZXh0IiwiY2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnMiLCJ1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkIiwidXNlSGFzQ3VycmVudEZvY3VzIiwib25DdXJyZW50Rm9jdXNlZENoYW5nZWQiLCJvbkZvY3VzZWRDaGFuZ2VkIiwib25Gb2N1c2VkSW5uZXJDaGFuZ2VkIiwiZ2V0Rm9jdXNlZCIsInNldEZvY3VzZWQiLCJnZXRGb2N1c2VkSW5uZXIiLCJzZXRGb2N1c2VkSW5uZXIiLCJvbkZvY3VzSW4iLCJvbkZvY3VzT3V0Iiwib25mb2N1c2luIiwib25mb2N1c291dCIsImhhc0N1cnJlbnRGb2N1c1JldHVybiIsImdldEN1cnJlbnRGb2N1c2VkIiwiZ2V0Q3VycmVudEZvY3VzZWRJbm5lciIsInVzZVByZXNzIiwiZXhjbHVkZSIsImFjdGl2ZUR1cmluZ1JlbmRlciIsInNldEFjdGl2ZSIsImdldEFjdGl2ZSIsInRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUiLCJzZXRUZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lIiwicHNldWRvQWN0aXZlIiwibm9kZVNlbGVjdGVkVGV4dExlbmd0aCIsIkRhdGUiLCJvbkFjdGl2ZVN0YXJ0Iiwib25BY3RpdmVTdG9wIiwiY3VycmVudFRpbWUiLCJ0aW1lRGlmZmVyZW5jZSIsImNoYXJhY3RlcnNTZWxlY3RlZCIsImFjdGl2ZSIsImhhbmRsZVByZXNzIiwicHVsc2UiLCJvbk1vdXNlRG93biIsImV4Y2x1ZGVzIiwiYnV0dG9uIiwib25Nb3VzZVVwIiwib25Nb3VzZUxlYXZlIiwib25LZXlVcCIsIm9uQ2xpY2siLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJwcm9wc1N0YWJsZTIiLCJwcmVzc1JldHVybiIsInNlbGVjdGlvbiIsImdldFNlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJyYW5nZSIsImdldFJhbmdlQXQiLCJlbmRDb250YWluZXIiLCJpc0NvbGxhcHNlZCIsIm5hdmlnYXRvciIsInZpYnJhdGUiLCJ1c2VDb21wbGV0ZUdyaWROYXZpZ2F0aW9uIiwiZ2V0SGlnaGVzdENoaWxkSW5kZXgiLCJncmlkTmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVybiIsInVzZUNvbXBsZXRlR3JpZE5hdmlnYXRpb25Sb3ciLCJtY2MxIiwiY29tcGxldGVHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnMiLCJiYXNlSW5mbyIsImNvbXBsZXRlR3JpZE5hdmlnYXRpb25Db250ZXh0IiwidXNlQ29tcGxldGVHcmlkTmF2aWdhdGlvbkNlbGwiLCJjb21wbGV0ZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnMiLCJ1c2VDb21wbGV0ZUxpc3ROYXZpZ2F0aW9uIiwiY29tcGxldGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMiLCJnZXRWYWxpZCIsInVzZUNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZCIsImNvbXBsZXRlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMiLCJvcHMxIiwic29ydGFibGVDaGlsZFBhcmFtZXRlcnMiLCJfdm9pZCIsIm9wczIiLCJwMSIsIm1jcDEiLCJ1c2VNb2RhbCIsInBwMSIsInBzMiIsInBwMyIsInBwNCIsInByb3BzUG9wdXAiLCJwcm9wc0ZvY3VzQ29udGFpbmVyIiwicHJvcHNTb3VyY2UiLCJ1c2VSYW5kb21JZCIsInJhbmRvbUlkUGFyYW1ldGVycyIsIm90aGVyUmVmZXJlbmNlclByb3AiLCJyZWZlcmVuY2VyRWxlbWVudFByb3BzIiwic291cmNlRWxlbWVudFByb3BzIiwicHJvcHNSZWZlcmVuY2VyIiwicmFuZG9tSWRSZXR1cm4iLCJ1c2VSYW5kb21EdWFsSWRzIiwicmFuZG9tSWRJbnB1dFBhcmFtZXRlcnMiLCJyYW5kb21JZExhYmVsUGFyYW1ldGVycyIsInJhbmRvbUlkSW5wdXRSZXR1cm4iLCJwcm9wc0xhYmVsQXNSZWZlcmVuY2VyIiwicHJvcHNJbnB1dEFzU291cmNlIiwicmFuZG9tSWRMYWJlbFJldHVybiIsInByb3BzSW5wdXRBc1JlZmVyZW5jZXIiLCJwcm9wc0xhYmVsQXNTb3VyY2UiLCJwcm9wc0xhYmVsIiwicHJvcHNJbnB1dCIsInVzZVRpbWVvdXQiLCJ0cmlnZ2VySW5kZXgiLCJzdGFibGVDYWxsYmFjayIsInN0YXJ0VGltZVJlZiIsImdldFRpbWVvdXQiLCJ0aW1lb3V0SXNOdWxsIiwiZ2V0RWxhcHNlZFRpbWUiLCJnZXRSZW1haW5pbmdUaW1lIiwidXNlQnV0dG9uIiwiYnV0dG9uUGFyYW1ldGVycyIsInRhZ0J1dHRvbiIsIm9uUHJlc3MiLCJwcmVzc2VkIiwicm9sZSIsInByZXNzUHJvcHMiLCJyZWZQcm9wcyIsImJhc2VQcm9wcyIsImJ1dHRvblByb3BzIiwiZGl2UHJvcHMiLCJ1c2VBY2NvcmRpb24iLCJhY2NvcmRpb25QYXJhbWV0ZXJzIiwibWNSZXR1cm5UeXBlIiwib2NtYzIiLCJpc1ZhbGlkMiIsImNoYW5nZUV4cGFuZGVkSW5kZXgiLCJnZXRDdXJyZW50RXhwYW5kZWRJbmRleCIsImdldE9wZW5Gcm9tUGFyZW50Iiwic2V0T3BlbkZyb21QYXJlbnQiLCJjaGFuZ2VUYWJiZWRJbmRleCIsImdldFRhYmJlZEluZGV4IiwiZ2V0TW9zdFJlY2VudGx5VGFiYmVkIiwidGFiYmVkIiwic2V0TW9zdFJlY2VudGx5VGFiYmVkIiwiYWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnMiLCJnZXRFeHBhbmRlZEluZGV4IiwiYWNjb3JkaW9uUmV0dXJuIiwidXNlQWNjb3JkaW9uU2VjdGlvbiIsIm9wZW5Gcm9tVXNlciIsImJvZHlSb2xlIiwiX3NldEN1cnJlbnRGb2N1c2VkSW5kZXgiLCJnZXRDdXJyZW50Rm9jdXNlZEluZGV4IiwidXNlck9uUHJlc3MiLCJvcGVuRnJvbVBhcmVudCIsIm1vc3RSZWNlbnRseVRhYmJlZCIsIl9ib2R5SWRSZXR1cm4iLCJwcm9wc0JvZHlTb3VyY2UiLCJwcm9wc0hlYWRSZWZlcmVuY2VyIiwiX2hlYWRJZFJldHVybiIsInByb3BzSGVhZFNvdXJjZSIsInByb3BzQm9keVJlZmVyZW5jZXIiLCJnZXRIZWFkZXJFbGVtZW50IiwiaGVhZGVyUmVmRWxlbWVudFByb3BzIiwiX2dldEJvZHlFbGVtZW50IiwiYm9keVJlZkVsZW1lbnRQcm9wcyIsImxpbmVhclJldHVyblR5cGUiLCJoZWFkZXJCdXR0b25Qcm9wcyIsImJvZHlQcm9wcyIsImFjY29yZGlvblNlY3Rpb25SZXR1cm4iLCJleHBhbmRlZCIsInByb3BzSGVhZGVyQnV0dG9uIiwicHJvcHNIZWFkZXIiLCJwcm9wc0JvZHkiLCJ1c2VMYWJlbCIsImxhYmVsUGFyYW1ldGVycyIsInRhZ0lucHV0IiwidGFnTGFiZWwiLCJhcmlhTGFiZWwiLCJsYWJlbFBvc2l0aW9uIiwib25MYWJlbENsaWNrIiwibmF0aXZlSFRNTEJlaGF2aW9yIiwic3ludGhldGljIiwidXNlTGFiZWxTeW50aGV0aWMiLCJ1c2VDaGVja2JveExpa2UiLCJjaGVja2JveExpa2VQYXJhbWV0ZXJzIiwib25JbnB1dCIsIm9uSW5wdXRTeW5jIiwicmVmRWxlbWVudElucHV0UmV0dXJuIiwicmVmRWxlbWVudExhYmVsUmV0dXJuIiwiZ2V0SW5wdXRFbGVtZW50IiwiZ2V0TGFiZWxFbGVtZW50IiwiaW5kZXRlcm1pbmF0ZSIsImdldElucHV0IiwiZ2V0TGFiZWwiLCJvbkNsaWNrSW5wdXRTeW5jIiwib25DbGlja0xhYmVsU3luYyIsInByZXNzSW5wdXRSZXR1cm4iLCJwcmVzc0xhYmVsUmV0dXJuIiwicHJvcHNVbnN0YWJsZUlucHV0IiwicHJvcHNVbnN0YWJsZUxhYmVsIiwib25Gb2N1cyIsImVsZW1lbnRUb0ZvY3VzIiwiY2hlY2tib3hMaWtlSW5wdXRSZXR1cm4iLCJjaGVja2JveExpa2VMYWJlbFJldHVybiIsImNoZWNrYm94TGlrZVJldHVybiIsInVzZUNoZWNrYm94IiwiY2hlY2tib3hQYXJhbWV0ZXJzIiwib25DaGVja2VkQ2hhbmdlIiwib25JbnB1dEVuaGFuY2VkIiwiY2hlY2tib3hSZXR1cm4iLCJ1c2VDaGVja2JveEdyb3VwIiwiYWxsSWRzIiwidXBkYXRlUGFyZW50Q29udHJvbElkcyIsInNldHRlciIsImdldFNldHRlciIsInNldFNldHRlciIsIl9nZXRVcGRhdGVJbmRleCIsInNldFVwZGF0ZUluZGV4IiwiZ2V0U2VsZklzQ2hlY2tlZCIsInBlcmNlbnRDaGVja2VkIiwib25BbnlDaGlsZENoZWNrZWRVcGRhdGUiLCJnZXRUb3RhbENoaWxkcmVuIiwic2V0VG90YWxDaGlsZHJlbiIsInRvdGFsQ2hpbGRyZW4iLCJnZXRTZXRQYXJlbnRDaGVja2JveENoZWNrZWQiLCJnZXRQZXJjZW50Q2hlY2tlZCIsImdldFRvdGFsQ2hlY2tlZCIsInNldFRvdGFsQ2hlY2tlZCIsInRvdGFsQ2hlY2tlZCIsInNldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZCIsIm9uQ2hlY2tib3hHcm91cFBhcmVudElucHV0Iiwic2VsZklzQ2hlY2tlZCIsIm5leHRDaGVja2VkIiwid2lsbENoYW5nZUFueSIsInByb21pc2VzIiwiY2hlY2tib3hJbmZvIiwiY2hlY2tib3hDaGlsZFR5cGUiLCJnZXRDaGVja2VkIiwiZ2V0TGFzdFVzZXJDaGVja2VkIiwicHJldkNoZWNrZWQiLCJzZXRDaGVja2VkRnJvbVBhcmVudElucHV0IiwiY2hlY2tib3hHcm91cENoaWxkcmVuQ29udGV4dCIsImNoZWNrYm94R3JvdXBQYXJlbnRDb250ZXh0IiwidXNlQ2hlY2tib3hHcm91cFBhcmVudCIsImFyaWFDb250cm9scyIsInNldENvbnRyb2xzIiwic2V0Q2hlY2tlZCIsImNoZWNrYm94R3JvdXBQYXJlbnRSZXR1cm4iLCJvblBhcmVudENoZWNrZWRDaGFuZ2UiLCJnZXRQZXJjZW50IiwidXNlQ2hlY2tib3hHcm91cENoaWxkIiwiY2hlY2tib3hHcm91cENoaWxkIiwib25DaGFuZ2VGcm9tUGFyZW50Iiwic2V0TGFzdFVzZXJDaGVja2VkIiwib25DaGlsZENoZWNrZWRDaGFuZ2UiLCJvbkNvbnRyb2xJZENoYW5nZWQiLCJuZXh0IiwidXNlRGlhbG9nIiwicHJvcHNEaWFsb2ciLCJwcm9wc1RpdGxlIiwidXNlRHJhd2VyIiwicHJvcHNEcmF3ZXIiLCJ1c2VHcmlkbGlzdCIsImdyaWRsaXN0UGFyYW1ldGVycyIsInNlbGVjdGlvbkxpbWl0IiwiZ3JvdXBpbmdUeXBlIiwicHJvcHNMYWJlbExpc3QiLCJwcm9wc0xhYmVsTGFiZWwiLCJfZ3JpZGxpc3RJZCIsIl9sYWJlbElkIiwicHJvcHNHcmlkbGlzdCIsImZ1bGxDb250ZXh0IiwiZ3JpZGxpc3RSb3dDb250ZXh0IiwicHJvcHNHcmlkbGlzdExhYmVsIiwidXNlR3JpZGxpc3RSb3ciLCJjeDEiLCJncmlkbGlzdFJvd1BhcmFtZXRlcnMiLCJjeDIiLCJ1c2VHcmlkbGlzdENlbGwiLCJ1c2VNZW51U3VyZmFjZSIsIm1lbnVTdXJmYWNlUGFyYW1ldGVycyIsInByb3BzSWRUcmlnZ2VyIiwicHJvcHNJZFRhcmdldCIsImdldEJ1dHRvbkVsZW1lbnQiLCJwcm9wc1JlZlRyaWdnZXIiLCJnZXRNZW51RWxlbWVudCIsInByb3BzUmVmU3VyZmFjZSIsInZvaWQ2IiwiYnV0dG9uRWxlbWVudCIsInByb3BzU3VyZmFjZSIsInByb3BzVGFyZ2V0IiwicHJvcHNUcmlnZ2VyIiwicHJvcHNTZW50aW5lbCIsInVzZUZvY3VzU2VudGluZWwiLCJmb2N1c1NlbnRpbmVsIiwic2VuZEZvY3VzVG9NZW51IiwiZ2V0U2VuZEZvY3VzV2l0aGluTWVudSIsImZpcnN0U2VudGluZWxJc0FjdGl2ZSIsInNldEZpcnN0U2VudGluZWxJc0FjdGl2ZSIsInVzZVRvb2xiYXIiLCJ0b29sYmFyUGFyYW1ldGVycyIsIm9yaWVudGF0aW9uIiwibGlzdE5hdlBhcmFtZXRlcnMiLCJsaXN0TmF2UmV0dXJuIiwidG9vbGJhclJldHVybiIsInVzZVRvb2xiYXJDaGlsZCIsImxpc3ROYXZDaGlsZFBhcmFtZXRlcnMiLCJ1c2VNZW51YmFyIiwibWVudWJhclBhcmFtZXRlcnMiLCJfcmVzdCIsInVzZU1lbnViYXJDaGlsZCIsIm1lbnVJdGVtUGFyYW1ldGVycyIsInVzZU1lbnUiLCJtZW51UGFyYW1ldGVycyIsIm9wZW5EaXJlY3Rpb24iLCJvbk9wZW4iLCJwcm9wc01lbnViYXIiLCJpc09wZW4iLCJ1c2VNZW51SXRlbSIsInVzZVJhZGlvR3JvdXAiLCJyYWRpb0dyb3VwUGFyYW1ldGVycyIsInNldFNlbGVjdGVkVmFsdWUiLCJzZXRTZWxlY3RlZFZhbHVlRXh0ZXJuYWwiLCJzZWxlY3RlZFZhbHVlIiwiYnlOYW1lIiwicHJvcHNHcm91cDEiLCJwcm9wc0dyb3VwMiIsImdldFZhbHVlMiIsInByb3BzUmFkaW9Hcm91cCIsInByb3BzUmFkaW9Hcm91cExhYmVsIiwicmFkaW9Db250ZXh0IiwicmFkaW9Hcm91cFJldHVybiIsInVzZVJhZGlvIiwicmFkaW9QYXJhbWV0ZXJzIiwibGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzIiwicHJvcHNJZklucHV0SGFuZGxlc0ZvY3VzIiwicHJvcHNJbnB1dDIiLCJwcm9wc0lmTGFiZWxIYW5kbGVzRm9jdXMiLCJwcm9wc0xhYmVsMiIsInVzZVNsaWRlciIsInNsaWRlclBhcmFtZXRlcnMiLCJtaW4iLCJiYXNlSWRSZWYiLCJzbGlkZXJDb250ZXh0IiwiYmFzZUlkIiwidXNlU2xpZGVyVGh1bWIiLCJtYXhQYXJlbnQiLCJtaW5QYXJlbnQiLCJzbGlkZXJUaHVtYlBhcmFtZXRlcnMiLCJtYXhPdmVycmlkZSIsIm1pbk92ZXJyaWRlIiwib25WYWx1ZUNoYW5nZSIsInZhbHVlVGV4dCIsImxhYmVsIiwidmFsdWVBc051bWJlciIsInNsaWRlclRodW1iUmV0dXJuIiwicHJvcHNTbGlkZXJUaHVtYiIsInVzZVRhYmxlIiwidGFibGVQYXJhbWV0ZXJzIiwidGFnVGFibGUiLCJwcm9wc1RhYmxlIiwibmF0dXJhbFNlY3Rpb25UeXBlcyIsInVzZVRhYmxlU2VjdGlvbiIsInRhYmxlU2VjdGlvblBhcmFtZXRlcnMiLCJ0YWdUYWJsZVNlY3Rpb24iLCJwcm9wc1RhYmxlU2VjdGlvbiIsInVzZVRhYmxlUm93IiwidGFibGVSb3dQYXJhbWV0ZXJzIiwidXNlVGFibGVDZWxsIiwidGFibGVDZWxsUGFyYW1ldGVycyIsInRhZ1RhYmxlQ2VsbCIsInVzZVRvYXN0cyIsIm9jbXUiLCJ0b2FzdHNQYXJhbWV0ZXJzIiwidmlzaWJsZUNvdW50IiwiY3VycmVudEluZGV4UXVldWUiLCJwb2xpdGVuZXNzIiwic2V0UG9saXRlbmVzcyIsImdldE1heFZpc2libGVDb3VudCIsIl9jaGlsZEluZm8iLCJnZXRUb2FzdFF1ZXVlIiwidG9hc3RRdWV1ZSIsInNob3dIaWdoZXN0UHJpb3JpdHlUb2FzdCIsImhpZ2hlc3RQcmlvcml0eVRvYXN0Iiwic2hvdyIsIm9uQW55VG9hc3RNb3VudGVkIiwidG9hc3RJbmRleCIsInNldE51bWJlckFoZWFkT2ZNZSIsIm9uQW55VG9hc3REaXNtaXNzZWQiLCJfaW5kZXgiLCJyZW1vdmFsSW5kZXgiLCJmaW5kSW5kZXgiLCJfbW91c2VPdmVyMiIsInNldE1vdXNlT3ZlciIsIl9nZXRNb3VzZU92ZXIiLCJtb3VzZU92ZXIiLCJ0b2FzdENvbnRleHQiLCJ1c2VUb2FzdCIsInRvYXN0UGFyYW1ldGVycyIsIl9tYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIiwibnVtYmVyT2ZUb2FzdHNBaGVhZE9mVXMiLCJzZXROdW1iZXJPZlRvYXN0c0FoZWFkT2ZVcyIsImRpc21pc3NlZDIiLCJzZXREaXNtaXNzZWQyIiwiZ2V0RGlzbWlzc2VkMiIsInNob3dpbmcyIiwic2V0U2hvd2luZzIiLCJnZXRTaG93aW5nMiIsImRpc21pc3MiLCJzZXRUcmlnZ2VySW5kZXgiLCJyZXNldERpc21pc3NUaW1lciIsImRpc21pc3NUaW1lb3V0S2V5IiwiaXNGaW5pdGUiLCJ0b2FzdFJldHVybiIsImRpc21pc3NlZCIsInNob3dpbmciLCJ1c2VUb29sdGlwIiwibW91c2VvdmVyRGVsYXkiLCJtb3VzZW91dFRvbGVyYW5jZURlbGF5IiwiZm9jdXNEZWxheSIsInNldE9wZW4iLCJzZXRIb3ZlclN0YXRlIiwic2V0VHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCIsInNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJnZXRUcmlnZ2VyRWxlbWVudCIsInRyaWdnZXJSZWZQcm9wcyIsInBvcHVwUmVmUHJvcHMiLCJzZXRUcmlnZ2VyRm9jdXNlZCIsImRlbGF5Iiwic2V0VG9vbHRpcEZvY3VzZWQiLCJvbkhvdmVyQ2hhbmdlIiwiaG92ZXJpbmciLCJob3ZlclN0YXRlIiwic2V0VHJpZ2dlckhvdmVyIiwic2V0VG9vbHRpcEhvdmVyIiwidHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCIsInRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJob3ZlckRlbGF5Q29ycmVjdGVkIiwib25Ub3VjaEVuZCIsInByb3BzRm9jdXNQb3B1cCIsInRvb2x0aXBSZXR1cm4iLCJnZXRJc09wZW4iLCJtZW1vRm9yd2FyZFJlZiIsIkNvbnRleHREZWZhdWx0cyIsInVzZURlZmF1bHQiLCJ1c2VyVmFsdWUiLCJQYXJlbnREZXB0aENvbnRleHQiLCJBY2NvcmRpb25TZWN0aW9uQ29udGV4dCIsIkFjY29yZGlvbiIsIkFjY29yZGlvblNlY3Rpb24iLCJCdXR0b24iLCJkZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlIiwibWFrZVByb3BzSW5wdXQiLCJtYWtlUHJvcHNMYWJlbCIsImlucHV0UHJvcHMiLCJsYWJlbFByb3BzIiwiaW5wdXQiLCJDaGVja2JveCIsImNoZWNrYm94IiwiVXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dCIsIkNoZWNrYm94R3JvdXAiLCJDaGVja2JveEdyb3VwUGFyZW50IiwiQ2hlY2tib3hHcm91cENoaWxkIiwiZGVmYXVsdFJlbmRlclBvcnRhbCIsInBvcnRhbElkIiwicG9ydGFsUmVmIiwiZ2V0RWxlbWVudEJ5SWQiLCJEaWFsb2ciLCJkZWZhdWx0UGFyZW50RGVwdGgiLCJteURlcHRoIiwiRHJhd2VyIiwiR3JpZGxpc3RDb250ZXh0IiwiR3JpZGxpc3RSb3dDb250ZXh0IiwiR3JpZGxpc3RVIiwibm9vcCIsIkdyaWRsaXN0Um93VSIsIkdyaWRsaXN0Q2hpbGQiLCJ1c2VMaXN0Ym94IiwibGlzdGJveFBhcmFtZXRlcnMiLCJfaW5wdXRJZCIsImxpc3Rib3hDb250ZXh0IiwicHJvcHNMaXN0Ym94IiwicHJvcHNMaXN0Ym94TGFiZWwiLCJ1c2VMaXN0Ym94SXRlbSIsIkxpc3Rib3hDb250ZXh0IiwiTGlzdGJveCIsIkxpc3Rib3hJdGVtIiwiZm9jdXNTZWxmRGVmYXVsdCIsIk1lbnVJdGVtQ29udGV4dCIsIk1lbnViYXJVIiwiTWVudUl0ZW0iLCJNZW51SXRlbVUiLCJNZW51IiwiUmFkaW9Db250ZXh0IiwiUmFkaW9Hcm91cCIsIlJhZGlvIiwiZGVmYXVsdEZvY3VzU2VsZiIsIlNsaWRlclRodW1iQ29udGV4dCIsIlNsaWRlciIsIlNsaWRlclRodW1iIiwiU2xpZGVyVGh1bWJVIiwiVGFibGVTZWN0aW9uQ29udGV4dCIsIlRhYmxlUm93Q29udGV4dCIsIlRhYmxlVSIsIlRhYmxlU2VjdGlvbiIsIlRhYmxlUm93VSIsInRhZ1RhYmxlUm93IiwiVGFibGVDZWxsIiwiQiQyIiwiVG9hc3RDb250ZXh0IiwiVG9hc3RzIiwiVG9hc3QiLCJUb29sYmFyQ29udGV4dCIsIlRvb2xiYXJVIiwibGlzdGJveFJldHVyblR5cGUiLCJUb29sYmFyQ2hpbGRVIiwiVG9vbHRpcFUiLCJEZW1vQWNjb3JkaW9uIiwiX2luZm8iLCJEZW1vQWNjb3JkaW9uU2VjdGlvbiIsIkJsdXJiIiwiaHJlZiIsIkNvZGUiLCJEZW1vIiwic2V0Q291bnQiLCJzZXRQcmVzc2VkIiwiRGVtb0J1dHRvbiIsImFsZXJ0Iiwic2V0RGlzYWJsZWQiLCJEZW1vQ2hlY2tib3giLCJib3JkZXIiLCJkaXNwbGF5IiwiRGVtb0xpc3RJdGVtIiwibGFiZWxUZXh0IiwiRGVtb1JhZGlvQnV0dG9uIiwiRGVtb1NsaWRlclRodW1iIiwiTGlzdGJveFNpbmdsZS5EZW1vIiwiU2xpZGVyLkRlbW8iLCJBY2NvcmRpb24uRGVtbyIsIkJ1dHRvbi5EZW1vIiwiQ2hlY2tib3guRGVtbyIsIkNoZWNrYm94R3JvdXAuRGVtbyIsIkxpc3Rib3hNdWx0aS5EZW1vIiwiTWVudS5EZW1vIiwiUmFkaW8uRGVtbyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTBCYUEsSUFBQUEsQ0FBQUE7SUNmUEMsR0NSRkM7SUFBQUEsR0FBQUE7SUN5S0FDLEdBQUFBO0lBV0FDO0lDckxPQyxHQ0ZFQztJQUFBQSxHQUFBQSxHQUFZLENBQWxCLENBQUE7SUFDTUMsR0FBWSxHQUFBLEVBQUE7SUFDWkMsR0FBcUIsR0FBQTtFTE9sQkMsU0FBQUEsR0FBT0MsQ0FBQUEsQ0FBQUEsRUFBS0MsQ0FFM0IsRUFBQTtJQUFBLEtBQUssSUFBSU4sQ0FBQUEsSUFBS00sQ0FBT0Q7TUFBQUEsQ0FBQUEsQ0FBSUwsS0FBS00sQ0FBTU4sQ0FBQUEsQ0FBQUEsQ0FBQUE7SUFDcEM7SUFBQSxPQUE2QkssQ0FDN0I7RUFBQTtFQVFNLFNBQVNFLEdBQUFBLENBQVdDLENBQzFCLEVBQUE7SUFBQSxJQUFJQyxJQUFhRCxDQUFLQyxDQUFBQSxVQUFBQTtJQUNsQkEsQ0FBWUEsSUFBQUEsQ0FBQUEsQ0FBV0MsV0FBWUYsQ0FBQUEsQ0FBQUEsQ0FDdkM7RUFBQTtFRVhNLFNBQVNHLElBQWNDLENBQU1OLEVBQUFBLENBQUFBLEVBQU9PLENBQzFDLEVBQUE7SUFBQSxJQUNDQztNQUNBQyxDQUNBZjtNQUFBQSxDQUFBQTtNQUhHZ0IsQ0FBa0IsR0FBQSxDQUFBO0lBSXRCLEtBQUtoQixDQUFBQSxJQUFLTSxDQUNBO01BQUEsS0FBQSxJQUFMTixDQUFZYyxHQUFBQSxDQUFBQSxHQUFNUixDQUFNTixDQUFBQSxDQUFBQSxDQUFBQSxHQUNkLFNBQUxBLENBQVllLEdBQUFBLENBQUFBLEdBQU1ULENBQU1OLENBQUFBLENBQUFBLENBQUFBLEdBQzVCZ0IsRUFBZ0JoQixDQUFLTSxDQUFBQSxHQUFB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
