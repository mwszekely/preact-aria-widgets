(function () {
    'use strict';

    var n,
        l$1,
        u$1,
        t,
        o$2,
        r$2,
        f$1 = {},
        e$1 = [],
        c$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

    function s$1(n, l) {
      for (var u in l) n[u] = l[u];

      return n;
    }

    function a$1(n) {
      var l = n.parentNode;
      l && l.removeChild(n);
    }

    function h$1(l, u, i) {
      var t,
          o,
          r,
          f = {};

      for (r in u) "key" == r ? t = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];

      if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : i), "function" == typeof l && null != l.defaultProps) for (r in l.defaultProps) void 0 === f[r] && (f[r] = l.defaultProps[r]);
      return v$1(l, f, t, o, null);
    }

    function v$1(n, i, t, o, r) {
      var f = {
        type: n,
        props: i,
        key: t,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u$1 : r
      };
      return null == r && null != l$1.vnode && l$1.vnode(f), f;
    }

    function p$1(n) {
      return n.children;
    }

    function d$1(n, l) {
      this.props = n, this.context = l;
    }

    function _$2(n, l) {
      if (null == l) return n.__ ? _$2(n.__, n.__.__k.indexOf(n) + 1) : null;

      for (var u; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) return u.__e;

      return "function" == typeof n.type ? _$2(n) : null;
    }

    function k$1(n) {
      var l, u;

      if (null != (n = n.__) && null != n.__c) {
        for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) if (null != (u = n.__k[l]) && null != u.__e) {
          n.__e = n.__c.base = u.__e;
          break;
        }

        return k$1(n);
      }
    }

    function b(n) {
      (!n.__d && (n.__d = !0) && t.push(n) && !g$2.__r++ || o$2 !== l$1.debounceRendering) && ((o$2 = l$1.debounceRendering) || setTimeout)(g$2);
    }

    function g$2() {
      for (var n; g$2.__r = t.length;) n = t.sort(function (n, l) {
        return n.__v.__b - l.__v.__b;
      }), t = [], n.some(function (n) {
        var l, u, i, t, o, r;
        n.__d && (o = (t = (l = n).__v).__e, (r = l.__P) && (u = [], (i = s$1({}, t)).__v = t.__v + 1, j$2(r, t, i, l.__n, void 0 !== r.ownerSVGElement, null != t.__h ? [o] : null, u, null == o ? _$2(t) : o, t.__h), z$2(u, t), t.__e != o && k$1(t)));
      });
    }

    function w$2(n, l, u, i, t, o, r, c, s, a) {
      var h,
          y,
          d,
          k,
          b,
          g,
          w,
          x = i && i.__k || e$1,
          C = x.length;

      for (u.__k = [], h = 0; h < l.length; h++) if (null != (k = u.__k[h] = null == (k = l[h]) || "boolean" == typeof k ? null : "string" == typeof k || "number" == typeof k || "bigint" == typeof k ? v$1(null, k, null, null, k) : Array.isArray(k) ? v$1(p$1, {
        children: k
      }, null, null, null) : k.__b > 0 ? v$1(k.type, k.props, k.key, k.ref ? k.ref : null, k.__v) : k)) {
        if (k.__ = u, k.__b = u.__b + 1, null === (d = x[h]) || d && k.key == d.key && k.type === d.type) x[h] = void 0;else for (y = 0; y < C; y++) {
          if ((d = x[y]) && k.key == d.key && k.type === d.type) {
            x[y] = void 0;
            break;
          }

          d = null;
        }
        j$2(n, k, d = d || f$1, t, o, r, c, s, a), b = k.__e, (y = k.ref) && d.ref != y && (w || (w = []), d.ref && w.push(d.ref, null, k), w.push(y, k.__c || b, k)), null != b ? (null == g && (g = b), "function" == typeof k.type && k.__k === d.__k ? k.__d = s = m$1(k, s, n) : s = A$1(n, k, d, x, b, s), "function" == typeof u.type && (u.__d = s)) : s && d.__e == s && s.parentNode != n && (s = _$2(d));
      }

      for (u.__e = g, h = C; h--;) null != x[h] && ("function" == typeof u.type && null != x[h].__e && x[h].__e == u.__d && (u.__d = _$2(i, h + 1)), N$1(x[h], x[h]));

      if (w) for (h = 0; h < w.length; h++) M$2(w[h], w[++h], w[++h]);
    }

    function m$1(n, l, u) {
      for (var i, t = n.__k, o = 0; t && o < t.length; o++) (i = t[o]) && (i.__ = n, l = "function" == typeof i.type ? m$1(i, l, u) : A$1(u, i, i, t, i.__e, l));

      return l;
    }

    function x$2(n, l) {
      return l = l || [], null == n || "boolean" == typeof n || (Array.isArray(n) ? n.some(function (n) {
        x$2(n, l);
      }) : l.push(n)), l;
    }

    function A$1(n, l, u, i, t, o) {
      var r, f, e;
      if (void 0 !== l.__d) r = l.__d, l.__d = void 0;else if (null == u || t != o || null == t.parentNode) n: if (null == o || o.parentNode !== n) n.appendChild(t), r = null;else {
        for (f = o, e = 0; (f = f.nextSibling) && e < i.length; e += 2) if (f == t) break n;

        n.insertBefore(t, o), r = o;
      }
      return void 0 !== r ? r : t.nextSibling;
    }

    function C$2(n, l, u, i, t) {
      var o;

      for (o in u) "children" === o || "key" === o || o in l || H$1(n, o, null, u[o], i);

      for (o in l) t && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H$1(n, o, l[o], u[o], i);
    }

    function $$1(n, l, u) {
      "-" === l[0] ? n.setProperty(l, u) : n[l] = null == u ? "" : "number" != typeof u || c$1.test(l) ? u : u + "px";
    }

    function H$1(n, l, u, i, t) {
      var o;

      n: if ("style" === l) {
        if ("string" == typeof u) n.style.cssText = u;else {
          if ("string" == typeof i && (n.style.cssText = i = ""), i) for (l in i) u && l in u || $$1(n.style, l, "");
          if (u) for (l in u) i && u[l] === i[l] || $$1(n.style, l, u[l]);
        }
      } else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/Capture$/, "")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? i || n.addEventListener(l, o ? T$2 : I$1, o) : n.removeEventListener(l, o ? T$2 : I$1, o);else if ("dangerouslySetInnerHTML" !== l) {
        if (t) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");else if ("href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && l in n) try {
          n[l] = null == u ? "" : u;
          break n;
        } catch (n) {}
        "function" == typeof u || (null == u || !1 === u && -1 == l.indexOf("-") ? n.removeAttribute(l) : n.setAttribute(l, u));
      }
    }

    function I$1(n) {
      this.l[n.type + !1](l$1.event ? l$1.event(n) : n);
    }

    function T$2(n) {
      this.l[n.type + !0](l$1.event ? l$1.event(n) : n);
    }

    function j$2(n, u, i, t, o, r, f, e, c) {
      var a,
          h,
          v,
          y,
          _,
          k,
          b,
          g,
          m,
          x,
          A,
          C,
          $,
          H = u.type;

      if (void 0 !== u.constructor) return null;
      null != i.__h && (c = i.__h, e = u.__e = i.__e, u.__h = null, r = [e]), (a = l$1.__b) && a(u);

      try {
        n: if ("function" == typeof H) {
          if (g = u.props, m = (a = H.contextType) && t[a.__c], x = a ? m ? m.props.value : a.__ : t, i.__c ? b = (h = u.__c = i.__c).__ = h.__E : ("prototype" in H && H.prototype.render ? u.__c = h = new H(g, x) : (u.__c = h = new d$1(g, x), h.constructor = H, h.render = O$1), m && m.sub(h), h.props = g, h.state || (h.state = {}), h.context = x, h.__n = t, v = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != H.getDerivedStateFromProps && (h.__s == h.state && (h.__s = s$1({}, h.__s)), s$1(h.__s, H.getDerivedStateFromProps(g, h.__s))), y = h.props, _ = h.state, v) null == H.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);else {
            if (null == H.getDerivedStateFromProps && g !== y && null != h.componentWillReceiveProps && h.componentWillReceiveProps(g, x), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(g, h.__s, x) || u.__v === i.__v) {
              h.props = g, h.state = h.__s, u.__v !== i.__v && (h.__d = !1), h.__v = u, u.__e = i.__e, u.__k = i.__k, u.__k.forEach(function (n) {
                n && (n.__ = u);
              }), h.__h.length && f.push(h);
              break n;
            }

            null != h.componentWillUpdate && h.componentWillUpdate(g, h.__s, x), null != h.componentDidUpdate && h.__h.push(function () {
              h.componentDidUpdate(y, _, k);
            });
          }
          if (h.context = x, h.props = g, h.__v = u, h.__P = n, A = l$1.__r, C = 0, "prototype" in H && H.prototype.render) h.state = h.__s, h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context);else do {
            h.__d = !1, A && A(u), a = h.render(h.props, h.state, h.context), h.state = h.__s;
          } while (h.__d && ++C < 25);
          h.state = h.__s, null != h.getChildContext && (t = s$1(s$1({}, t), h.getChildContext())), v || null == h.getSnapshotBeforeUpdate || (k = h.getSnapshotBeforeUpdate(y, _)), $ = null != a && a.type === p$1 && null == a.key ? a.props.children : a, w$2(n, Array.isArray($) ? $ : [$], u, i, t, o, r, f, e, c), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), b && (h.__E = h.__ = null), h.__e = !1;
        } else null == r && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = L$1(i.__e, u, i, t, o, r, f, c);

        (a = l$1.diffed) && a(u);
      } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l$1.__e(n, u, i);
      }
    }

    function z$2(n, u) {
      l$1.__c && l$1.__c(u, n), n.some(function (u) {
        try {
          n = u.__h, u.__h = [], n.some(function (n) {
            n.call(u);
          });
        } catch (n) {
          l$1.__e(n, u.__v);
        }
      });
    }

    function L$1(l, u, i, t, o, r, e, c) {
      var s,
          h,
          v,
          y = i.props,
          p = u.props,
          d = u.type,
          k = 0;
      if ("svg" === d && (o = !0), null != r) for (; k < r.length; k++) if ((s = r[k]) && "setAttribute" in s == !!d && (d ? s.localName === d : 3 === s.nodeType)) {
        l = s, r[k] = null;
        break;
      }

      if (null == l) {
        if (null === d) return document.createTextNode(p);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", d) : document.createElement(d, p.is && p), r = null, c = !1;
      }

      if (null === d) y === p || c && l.data === p || (l.data = p);else {
        if (r = r && n.call(l.childNodes), h = (y = i.props || f$1).dangerouslySetInnerHTML, v = p.dangerouslySetInnerHTML, !c) {
          if (null != r) for (y = {}, k = 0; k < l.attributes.length; k++) y[l.attributes[k].name] = l.attributes[k].value;
          (v || h) && (v && (h && v.__html == h.__html || v.__html === l.innerHTML) || (l.innerHTML = v && v.__html || ""));
        }

        if (C$2(l, p, y, o, c), v) u.__k = [];else if (k = u.props.children, w$2(l, Array.isArray(k) ? k : [k], u, i, t, o && "foreignObject" !== d, r, e, r ? r[0] : i.__k && _$2(i, 0), c), null != r) for (k = r.length; k--;) null != r[k] && a$1(r[k]);
        c || ("value" in p && void 0 !== (k = p.value) && (k !== l.value || "progress" === d && !k || "option" === d && k !== y.value) && H$1(l, "value", k, y.value, !1), "checked" in p && void 0 !== (k = p.checked) && k !== l.checked && H$1(l, "checked", k, y.checked, !1));
      }
      return l;
    }

    function M$2(n, u, i) {
      try {
        "function" == typeof n ? n(u) : n.current = u;
      } catch (n) {
        l$1.__e(n, i);
      }
    }

    function N$1(n, u, i) {
      var t, o;

      if (l$1.unmount && l$1.unmount(n), (t = n.ref) && (t.current && t.current !== n.__e || M$2(t, null, u)), null != (t = n.__c)) {
        if (t.componentWillUnmount) try {
          t.componentWillUnmount();
        } catch (n) {
          l$1.__e(n, u);
        }
        t.base = t.__P = null, n.__c = void 0;
      }

      if (t = n.__k) for (o = 0; o < t.length; o++) t[o] && N$1(t[o], u, "function" != typeof n.type);
      i || null == n.__e || a$1(n.__e), n.__ = n.__e = n.__d = void 0;
    }

    function O$1(n, l, u) {
      return this.constructor(n, u);
    }

    function P$1(u, i, t) {
      var o, r, e;
      l$1.__ && l$1.__(u, i), r = (o = "function" == typeof t) ? null : t && t.__k || i.__k, e = [], j$2(i, u = (!o && t || i).__k = h$1(p$1, null, [u]), r || f$1, f$1, void 0 !== i.ownerSVGElement, !o && t ? [t] : r ? null : i.firstChild ? n.call(i.childNodes) : null, e, !o && t ? t : r ? r.__e : i.firstChild, o), z$2(e, u);
    }

    function B$2(n, l) {
      var u = {
        __c: l = "__cC" + r$2++,
        __: n,
        Consumer: function (n, l) {
          return n.children(l);
        },
        Provider: function (n) {
          var u, i;
          return this.getChildContext || (u = [], (i = {})[l] = this, this.getChildContext = function () {
            return i;
          }, this.shouldComponentUpdate = function (n) {
            this.props.value !== n.value && u.some(b);
          }, this.sub = function (n) {
            u.push(n);
            var l = n.componentWillUnmount;

            n.componentWillUnmount = function () {
              u.splice(u.indexOf(n), 1), l && l.call(n);
            };
          }), n.children;
        }
      };
      return u.Provider.__ = u.Consumer.contextType = u;
    }

    n = e$1.slice, l$1 = {
      __e: function (n, l, u, i) {
        for (var t, o, r; l = l.__;) if ((t = l.__c) && !t.__) try {
          if ((o = t.constructor) && null != o.getDerivedStateFromError && (t.setState(o.getDerivedStateFromError(n)), r = t.__d), null != t.componentDidCatch && (t.componentDidCatch(n, i || {}), r = t.__d), r) return t.__E = t;
        } catch (l) {
          n = l;
        }

        throw n;
      }
    }, u$1 = 0, d$1.prototype.setState = function (n, l) {
      var u;
      u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = s$1({}, this.state), "function" == typeof n && (n = n(s$1({}, u), this.props)), n && s$1(u, n), null != n && this.__v && (l && this.__h.push(l), b(this));
    }, d$1.prototype.forceUpdate = function (n) {
      this.__v && (this.__e = !0, n && this.__h.push(n), b(this));
    }, d$1.prototype.render = p$1, t = [], g$2.__r = 0, r$2 = 0;

    var _$1 = 0;

    function o$1(o, e, n, t, f) {
      var l,
          s,
          u = {};

      for (s in e) "ref" == s ? l = e[s] : u[s] = e[s];

      var a = {
        type: o,
        props: u,
        key: n,
        ref: l,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: --_$1,
        __source: f,
        __self: t
      };
      if ("function" == typeof o && (l = o.defaultProps)) for (s in l) void 0 === u[s] && (u[s] = l[s]);
      return l$1.vnode && l$1.vnode(a), a;
    }

    var r$1,
        u,
        i,
        o,
        f = 0,
        c = [],
        e = [],
        a = l$1.__b,
        v = l$1.__r,
        l = l$1.diffed,
        m = l$1.__c,
        d = l$1.unmount;

    function p(t, r) {
      l$1.__h && l$1.__h(u, t, f || r), f = 0;
      var i = u.__H || (u.__H = {
        __: [],
        __h: []
      });
      return t >= i.__.length && i.__.push({
        __V: e
      }), i.__[t];
    }

    function y(n) {
      return f = 1, h(C$1, n);
    }

    function h(n, t, i) {
      var o = p(r$1++, 2);

      if (o.t = n, !o.__c && (o.__ = [i ? i(t) : C$1(void 0, t), function (n) {
        var t = o.__N ? o.__N[0] : o.__[0],
            r = o.t(t, n);
        t !== r && (o.__N = [r, o.__[1]], o.__c.setState({}));
      }], o.__c = u, !u.u)) {
        u.u = !0;
        var f = u.shouldComponentUpdate;

        u.shouldComponentUpdate = function (n, t, r) {
          if (!o.__c.__H) return !0;

          var u = o.__c.__H.__.filter(function (n) {
            return n.__c;
          });

          if (u.every(function (n) {
            return !n.__N;
          })) return !f || f.call(this, n, t, r);
          var i = !1;
          return u.forEach(function (n) {
            if (n.__N) {
              var t = n.__[0];
              n.__ = n.__N, n.__N = void 0, t !== n.__[0] && (i = !0);
            }
          }), !(!i && o.__c.props === n) && (!f || f.call(this, n, t, r));
        };
      }

      return o.__N || o.__;
    }

    function s(t, i) {
      var o = p(r$1++, 3);
      !l$1.__s && B$1(o.__H, i) && (o.__ = t, o.i = i, u.__H.__h.push(o));
    }

    function _(t, i) {
      var o = p(r$1++, 4);
      !l$1.__s && B$1(o.__H, i) && (o.__ = t, o.i = i, u.__h.push(o));
    }

    function A(n) {
      return f = 5, T$1(function () {
        return {
          current: n
        };
      }, []);
    }

    function T$1(n, t) {
      var u = p(r$1++, 7);
      return B$1(u.__H, t) ? (u.__V = n(), u.i = t, u.__h = n, u.__V) : u.__;
    }

    function q$1(n, t) {
      return f = 8, T$1(function () {
        return n;
      }, t);
    }

    function x$1(n) {
      var t = u.context[n.__c],
          i = p(r$1++, 9);
      return i.c = n, t ? (null == i.__ && (i.__ = !0, t.sub(u)), t.props.value) : n.__;
    }

    function g$1() {
      for (var t; t = c.shift();) if (t.__P && t.__H) try {
        t.__H.__h.forEach(w$1), t.__H.__h.forEach(z$1), t.__H.__h = [];
      } catch (r) {
        t.__H.__h = [], l$1.__e(r, t.__v);
      }
    }

    l$1.__b = function (n) {
      "function" != typeof n.type || n.__m || n.type === p$1 ? n.__m || (n.__m = n.__ && n.__.__m ? n.__.__m : "") : n.__m = (n.__ && n.__.__m ? n.__.__m : "") + (n.__ && n.__.__k ? n.__.__k.indexOf(n) : 0), u = null, a && a(n);
    }, l$1.__r = function (n) {
      v && v(n), r$1 = 0;
      var t = (u = n.__c).__H;
      t && (i === u ? (t.__h = [], u.__h = [], t.__.forEach(function (n) {
        n.__N && (n.__ = n.__N), n.__V = e, n.__N = n.i = void 0;
      })) : (t.__h.forEach(w$1), t.__h.forEach(z$1), t.__h = [])), i = u;
    }, l$1.diffed = function (t) {
      l && l(t);
      var r = t.__c;
      r && r.__H && (r.__H.__h.length && (1 !== c.push(r) && o === l$1.requestAnimationFrame || ((o = l$1.requestAnimationFrame) || k)(g$1)), r.__H.__.forEach(function (n) {
        n.i && (n.__H = n.i), n.__V !== e && (n.__ = n.__V), n.i = void 0, n.__V = e;
      })), i = u = null;
    }, l$1.__c = function (t, r) {
      r.some(function (t) {
        try {
          t.__h.forEach(w$1), t.__h = t.__h.filter(function (n) {
            return !n.__ || z$1(n);
          });
        } catch (u) {
          r.some(function (n) {
            n.__h && (n.__h = []);
          }), r = [], l$1.__e(u, t.__v);
        }
      }), m && m(t, r);
    }, l$1.unmount = function (t) {
      d && d(t);
      var r,
          u = t.__c;
      u && u.__H && (u.__H.__.forEach(function (n) {
        try {
          w$1(n);
        } catch (n) {
          r = n;
        }
      }), u.__H = void 0, r && l$1.__e(r, u.__v));
    };
    var j$1 = "function" == typeof requestAnimationFrame;

    function k(n) {
      var t,
          r = function () {
        clearTimeout(u), j$1 && cancelAnimationFrame(t), setTimeout(n);
      },
          u = setTimeout(r, 100);

      j$1 && (t = requestAnimationFrame(r));
    }

    function w$1(n) {
      var t = u,
          r = n.__c;
      "function" == typeof r && (n.__c = void 0, r()), u = t;
    }

    function z$1(n) {
      var t = u;
      n.__c = n.__(), u = t;
    }

    function B$1(n, t) {
      return !n || n.length !== t.length || t.some(function (t, r) {
        return t !== n[r];
      });
    }

    function C$1(n, t) {
      return "function" == typeof t ? t(n) : t;
    }

    const EventDetail = Symbol("event-detail");
    function enhanceEvent(e, detail) {
      const event = e;
      event[EventDetail] = detail;
      return event;
    }
    const alreadyWarned = new Set();
    function warnOnOverwrite(componentName, propName, propValue, newValue) {
      const key = `${componentName};${propName}`;

      if (propValue != null) {
        if (!alreadyWarned.has(key)) {
          alreadyWarned.add(key);
          console.warn(`The ${propName} attribute on ${componentName} was given a value of ${propValue} but is being overwritten to ${newValue} for conformance. Consider removing it before passing those props to ${componentName}.`);
        }
      }

      return newValue;
    }
    function debugLog(who) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      console.debug(who + ":", ...args);
    }

    const HeadingLevelContext = B$2(0);
    function Heading(_ref) {
      let {
        children,
        heading,
        ...props
      } = _ref;
      const headingLevelBeforeUs = x$1(HeadingLevelContext);
      const newHeadingLevel = headingLevelBeforeUs + 1;
      let tag;

      if (newHeadingLevel <= 6) {
        tag = `h${newHeadingLevel}`;
      } else {
        tag = 'div';
        props["aria-level"] = warnOnOverwrite("Heading", "aria-level", props["aria-level"], `${newHeadingLevel}`);
      }

      return o$1(p$1, {
        children: o$1(HeadingReset, {
          newLevel: headingLevelBeforeUs + 1,
          children: [h$1(tag, props, heading), children]
        })
      });
    }
    function HeadingReset(_ref2) {
      let {
        newLevel,
        children
      } = _ref2;
      return o$1(HeadingLevelContext.Provider, {
        value: newLevel,
        children: children
      });
    }

    /**
     * Debug hook.
     *
     * Given a value or set of values, emits a console error if any of them change from one render to the next.
     *
     * Eventually, when useEvent lands, we hopefully won't need this.
     */

    function useEnsureStability(parentHookName) {
      for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        values[_key - 1] = arguments[_key];
      }

      useHelper(values.length, 0);
      values.forEach(useHelper);
      return;

      function useHelper(value, index) {
        // Make sure that the provided functions are perfectly stable across renders
        const helperToEnsureStability = A(value);
        const shownError = A(false);

        if (helperToEnsureStability.current != value) {
          if (!shownError.current) {
            /* eslint-disable no-debugger */
            debugger;
            console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
            shownError.current = true;
          }
        }
      }
    }
    function debounceRendering(f) {
      var _options$debounceRend;

      ((_options$debounceRend = l$1.debounceRendering) !== null && _options$debounceRend !== void 0 ? _options$debounceRend : setTimeout)(f);
    }
    /**
     * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
     *
     * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
     *
     * To summarize, it's like a `useState`-`useEffect` mashup:
     *
     * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
     * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
     * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
     * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
     *
     * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
     *
     * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @returns
     */

    function usePassiveState(onChange, getInitialValue) {
      const valueRef = A(Unset$1);
      const warningRef = A(false);
      const cleanupCallbackRef = A(undefined); // Make sure that the provided functions are perfectly stable across renders

      useEnsureStability("usePassiveState", onChange, getInitialValue); // Shared between "dependency changed" and "component unmounted".

      const onShouldCleanUp = q$1(() => {
        const cleanupCallback = cleanupCallbackRef.current;
        if (cleanupCallback) cleanupCallback();
      }, []); // There are a couple places where we'd like to use our initial
      // value in place of having no value at all yet.
      // This is the shared code for that, used on mount and whenever
      // getValue is called.

      const tryEnsureValue = q$1(() => {
        if (valueRef.current === Unset$1 && getInitialValue != undefined) {
          try {
            var _onChange;

            const initialValue = getInitialValue();
            valueRef.current = initialValue;
            cleanupCallbackRef.current = (_onChange = onChange === null || onChange === void 0 ? void 0 : onChange(initialValue, undefined)) !== null && _onChange !== void 0 ? _onChange : undefined;
          } catch (ex) {// Exceptions are intentional to allow bailout (without exposing the Unset symbol)
          }
        }
      }, [
        /* getInitialValue and onChange intentionally omitted */
      ]);
      const getValue = q$1(() => {
        if (warningRef.current) console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component."); // The first time we call getValue, if we haven't been given a value yet,
        // (and we were given an initial value to use)
        // return the initial value instead of nothing.

        if (valueRef.current === Unset$1) tryEnsureValue();
        return valueRef.current === Unset$1 ? undefined : valueRef.current;
      }, []);
      _(() => {
        // Make sure we've run our effect at least once on mount.
        // (If we have an initial value, of course)
        tryEnsureValue();
      }, []); // The actual code the user calls to (possibly) run a new effect.

      const r = A({
        prevDep: Unset$1
      });
      const setValue = q$1(arg => {
        // Regardless of anything else, figure out what our next value is about to be.
        const nextValue = arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg;

        if (r.current.prevDep === Unset$1) {
          // This is the first request to change this value.
          // Evaluate the request immediately, then queue up the onChange function
          // Save our current value so that we can compare against it later
          // (if we flip back to this state, then we won't send the onChange function)
          r.current.prevDep = valueRef.current; // Schedule the actual check and invocation of onChange later to let effects settle

          debounceRendering(() => {
            const nextDep = valueRef.current;
            const prevDep = r.current.prevDep;

            if (r.current.prevDep != valueRef.current) {
              warningRef.current = true;

              try {
                var _onChange2;

                // Call any registered cleanup function
                onShouldCleanUp();
                cleanupCallbackRef.current = (_onChange2 = onChange === null || onChange === void 0 ? void 0 : onChange(nextDep, prevDep === Unset$1 ? undefined : prevDep)) !== null && _onChange2 !== void 0 ? _onChange2 : undefined;
                valueRef.current = nextDep;
              } finally {
                // Allow the user to normally call getValue again
                warningRef.current = false;
              }
            } // We've finished with everything, so mark us as being on a clean slate again.


            r.current.prevDep = Unset$1;
          });
        } // Update the value immediately.
        // This will be checked against prevDep to see if we should actually call onChange


        valueRef.current = nextValue;
      }, []);
      return [getValue, setValue];
    }
    const Unset$1 = Symbol(); // Easy constants for getInitialValue

    function returnTrue() {
      return true;
    }
    function returnFalse$1() {
      return false;
    }
    function returnNull() {
      return null;
    }

    const activeElementUpdaters = new Map();
    const lastActiveElementUpdaters = new Map();
    const windowFocusedUpdaters = new Map();
    const windowsFocusedUpdaters = new Map();
    const microtasks = new Map(); // The focusin and focusout events often fire syncronously in the middle of running code.
    // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
    // For the purpose of improving stability, we debounce all focus events to the next microtask.

    function forEachUpdater(window, map, value) {
      const updatersKey = map.get(window);

      if (updatersKey) {
        if (!microtasks.has(updatersKey)) {
          debounceRendering(() => {
            const updatersKey = map.get(window);
            const value = microtasks.get(updatersKey);
            microtasks.delete(updatersKey);

            if (updatersKey) {
              for (const updater of updatersKey) {
                updater === null || updater === void 0 ? void 0 : updater(value);
              }
            }
          });
        }

        microtasks.set(updatersKey, value);
      }
    }

    function focusout(e) {
      const window = e.target.ownerDocument.defaultView;

      if (e.relatedTarget == null) {
        forEachUpdater(window, activeElementUpdaters, null);
      }
    }

    function focusin(e) {
      const window = e.target.ownerDocument.defaultView;
      const currentlyFocusedElement = e.target;
      forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
      forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
    }

    function windowFocus(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, true);
      forEachUpdater(window, windowFocusedUpdaters, true);
    }

    function windowBlur(e) {
      const window = e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView;
      windowsFocusedUpdaters.set(window, false);
      forEachUpdater(window, windowFocusedUpdaters, false);
    }
    /**
     * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
     * * `getActiveElement()`
     * * `getLastActiveElement()`
     * * `getWindowFocused()`
     *
     * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
     *
     * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
     *
     * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
     */


    function useActiveElement(_ref) {
      let {
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        getDocument,
        getWindow
      } = _ref;
      useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, getDocument, getWindow);
      s(() => {
        var _getWindow, _activeElementUpdater, _activeElementUpdater2, _activeElementUpdater3, _lastActiveElementUpd, _windowFocusedUpdater;

        const document = getDocument();
        const window = (_getWindow = getWindow === null || getWindow === void 0 ? void 0 : getWindow(document)) !== null && _getWindow !== void 0 ? _getWindow : document === null || document === void 0 ? void 0 : document.defaultView;

        if (((_activeElementUpdater = (_activeElementUpdater2 = activeElementUpdaters.get(window)) === null || _activeElementUpdater2 === void 0 ? void 0 : _activeElementUpdater2.size) !== null && _activeElementUpdater !== void 0 ? _activeElementUpdater : 0) === 0) {
          document === null || document === void 0 ? void 0 : document.addEventListener("focusin", focusin, {
            passive: true
          });
          document === null || document === void 0 ? void 0 : document.addEventListener("focusout", focusout, {
            passive: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("focus", windowFocus, {
            passive: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("blur", windowBlur, {
            passive: true
          });
        } // Add them even if they're undefined to more easily
        // manage the ">0 means don't add handlers" logic.


        const localActiveElementUpdaters = (_activeElementUpdater3 = activeElementUpdaters.get(window)) !== null && _activeElementUpdater3 !== void 0 ? _activeElementUpdater3 : new Set();
        const localLastActiveElementUpdaters = (_lastActiveElementUpd = lastActiveElementUpdaters.get(window)) !== null && _lastActiveElementUpd !== void 0 ? _lastActiveElementUpd : new Set();
        const localWindowFocusedUpdaters = (_windowFocusedUpdater = windowFocusedUpdaters.get(window)) !== null && _windowFocusedUpdater !== void 0 ? _windowFocusedUpdater : new Set();
        localActiveElementUpdaters.add(setActiveElement);
        localLastActiveElementUpdaters.add(setLastActiveElement);
        localWindowFocusedUpdaters.add(setWindowFocused);
        activeElementUpdaters.set(window, localActiveElementUpdaters);
        lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
        windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
        return () => {
          activeElementUpdaters.get(window).delete(setActiveElement);
          lastActiveElementUpdaters.get(window).delete(setLastActiveElement);
          windowFocusedUpdaters.get(window).delete(setWindowFocused);

          if (activeElementUpdaters.size === 0) {
            document === null || document === void 0 ? void 0 : document.removeEventListener("focusin", focusin);
            document === null || document === void 0 ? void 0 : document.removeEventListener("focusout", focusout);
            window === null || window === void 0 ? void 0 : window.removeEventListener("focus", windowFocus);
            window === null || window === void 0 ? void 0 : window.removeEventListener("blur", windowBlur);
          }
        };
      }, []);
      const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
      const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
      const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
      return {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }

    const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";

    function base64(value) {
      return Table[value];
    }

    function random6Bits() {
      return Math.floor(Math.random() * 0b1000000);
    }

    function random64Bits() {
      return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     *
     *
     * (This is here, in this particular file, to avoid circular dependencies
     * without also making a utilities file.
     * Once we can remove this hook, we can put this function back with useRandomId)
     */


    function generateRandomId(prefix) {
      return `${prefix !== null && prefix !== void 0 ? prefix : "id-"}${random64Bits().map(n => base64(n)).join("")}`;
    }
    const previousInputs = new Map();
    const toRun = new Map(); // TODO: Whether this goes in options.diffed or options._commit
    // is a post-suspense question.
    // Right now, using options._commit has the problem of running
    // *after* refs are applied, but we need to come before even that
    // so `ref={someStableFunction}` works.
    // 
    // Also it's private.
    //
    // ...
    // Well, useEvent or whatever is finally, finally 4 years later finally here
    // which is cool and means we won't need this at all soon.
    // So for now we'll stick with diff to prevent any weirdness with
    // commit being private and all.

    const commitName = "diffed";
    const originalCommit = l$1[commitName];

    const newCommit = function () {
      for (const [id, effectInfo] of toRun) {
        const oldInputs = previousInputs.get(id);

        if (argsChanged(oldInputs, effectInfo.inputs)) {
          var _effectInfo$cleanup;

          (_effectInfo$cleanup = effectInfo.cleanup) === null || _effectInfo$cleanup === void 0 ? void 0 : _effectInfo$cleanup.call(effectInfo);
          effectInfo.cleanup = effectInfo.effect();
          previousInputs.set(id, effectInfo.inputs);
        }
      }

      toRun.clear();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      originalCommit === null || originalCommit === void 0 ? void 0 : originalCommit(...args);
    };

    l$1[commitName] = newCommit;
    /**
     * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
     *
     * Every render, we send the arguments to be evaluated after diffing has completed,
     * which happens before.
     *
     * @param effect
     * @param inputs
     */

    function useBeforeLayoutEffect(effect, inputs) {
      /*(() => {
          const cleanup = useRef<void | (() => void) | null>(null);
          const prevArgsRef = useRef<Inputs>(null!);
          if (argsChanged(inputs, prevArgsRef.current)) {
              prevArgsRef.current = inputs!;
              if (cleanup.current)
                  cleanup.current();
              cleanup.current = effect();
          }
      })();*/
      const [id] = y(() => generateRandomId());
      toRun.set(id, {
        effect,
        inputs,
        cleanup: null
      });
      s(() => {
        return () => {
          toRun.delete(id);
          previousInputs.delete(id);
        };
      }, [id]);
    }

    function argsChanged(oldArgs, newArgs) {
      return !!(!oldArgs || oldArgs.length !== (newArgs === null || newArgs === void 0 ? void 0 : newArgs.length) || newArgs !== null && newArgs !== void 0 && newArgs.some((arg, index) => arg !== oldArgs[index]));
    }

    const Unset = Symbol("unset");
    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * This uses `options.diffed` in order to run before everything, even
     * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
     *
     * @param value
     * @returns
     */

    function useStableGetter(value) {
      const ref = A(Unset);
      useBeforeLayoutEffect(() => {
        ref.current = value;
      }, [value]);
      return q$1(() => {
        if (ref.current === Unset) {
          throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
        }

        return ref.current;
      }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * Do not use during the render phase!  `useLayoutEffect` is fine though.
     */

    function useStableCallback(fn) {
      const currentCallbackGetter = useStableGetter(fn);
      return q$1(function () {
        return currentCallbackGetter()(...arguments);
      }, []);
    }

    B$2(null);

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */

    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();

    /** Built-in value references. */

    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */

    var objectProto$5 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var nativeObjectToString$1 = objectProto$5.toString;
    /** Built-in value references. */

    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */

    function getRawTag(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);

      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }

      return result;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */

    var nativeObjectToString = objectProto$4.toString;
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */

    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /** `Object#toString` result references. */

    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';
    /** Built-in value references. */

    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */

    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }

      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */

    function useState(initialState) {
      // We keep both, but overrride the `setState` functionality
      const [state, setStateP] = y(initialState);
      const ref = A(state); // Hijack the normal setter function 
      // to also set our ref to the new value

      const setState = q$1(value => {
        if (typeof value === "function") {
          const callback = value;
          setStateP(prevValue => {
            const nextValue = callback(prevValue);
            ref.current = nextValue;
            return nextValue;
          });
        } else {
          ref.current = value;
          setStateP(value);
        }
      }, []);

      const getState = () => {
        return ref.current;
      };

      console.assert(ref.current === state || typeof state === "number" && isNaN(state));
      return [state, setState, getState];
    }

    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is designed to be lightweight, in that the parent keeps no state
     * and runs no effects.  Each child *does* run an effect, but with no state
     * changes unless you explicitly request them.
     *
     *
     */


    function useManagedChildren(parentParameters) {
      const {
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters;
      useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
      const getHighestIndex = q$1(() => {
        return managedChildrenArray.current.highestIndex;
      }, []); // All the information we have about our children is stored in this **stable** array.
      // Any mutations to this array **DO NOT** trigger any sort of a re-render.

      const managedChildrenArray = A({
        arr: [],
        rec: {},
        highestIndex: 0,
        lowestIndex: 0
      }); // For indirect access to each child
      // Compare getManagedChildInfo
      // TODO: The primary use for this is flaggable closest fits
      // which need to search all children for that closest fit.
      // It would be nice if there was something better for that.

      const forEachChild = q$1(f => {
        for (const child of managedChildrenArray.current.arr) {
          f(child);
        }

        for (const field in managedChildrenArray.current.rec) {
          const child = managedChildrenArray.current.rec[field];
          if (child) f(child);
        }
      }, []); // Retrieves the information associated with the child with the given index.
      // `undefined` if not child there, or it's unmounted.

      const getManagedChildInfo = q$1(index => {
        if (typeof index == "number") return managedChildrenArray.current.arr[index];else return managedChildrenArray.current.rec[index];
      }, []); // tl;dr this is a way to have run useLayoutEffect once after all N children
      // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
      // ourselves because of having a `childCount` state or anything similar.
      //
      // When the child count ref updates, we want the parent to also run an effect
      // to maybe do something with all these children that just mounted.
      // The easiest way would be useEffect(..., [childCount]) but
      // that would require us having a childCount state, then calling
      // setChildCount and re-rendering every time children mount
      // (only one re-render at a time unless children are staggered, but still)
      // 
      // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
      // to emulate running ULE on the parent. Only the first child will actually queue
      // the microtask (by checking hasRemoteULE first) so that the "effect" only
      // runs once. When it's done, hasRemoteULE is reset so it can run again if
      // more children mount/unmount.

      const hasRemoteULEChildMounted = A(null);
      const remoteULEChildChangedCausers = A(new Set());
      const remoteULEChildChanged = q$1(index => {
        if (remoteULEChildChangedCausers.current.size == 0) {
          debounceRendering(() => {
            onAfterChildLayoutEffect === null || onAfterChildLayoutEffect === void 0 ? void 0 : onAfterChildLayoutEffect(remoteULEChildChangedCausers.current);
            remoteULEChildChangedCausers.current.clear();
          });
        }

        remoteULEChildChangedCausers.current.add(index);
        return () => {};
      }, [
        /* Must remain stable */
      ]);
      const remoteULEChildMounted = q$1((index, mounted) => {
        if (!hasRemoteULEChildMounted.current) {
          hasRemoteULEChildMounted.current = {
            mounts: new Set(),
            unmounts: new Set()
          };
          debounceRendering(() => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
            hasRemoteULEChildMounted.current = null;
          });
        }

        if (mounted) {
          managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
        } else {
          if (typeof index == "number") {
            delete managedChildrenArray.current.arr[index];
            let shave = 0;

            while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) ++shave;

            managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - 1 - shave, shave);
          } else delete managedChildrenArray.current.rec[index];
        }

        hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
      }, [
        /* Must remain stable */
      ]);
      const useManagedChild = q$1(_ref => {
        let {
          managedChild: info
        } = _ref;
        // Any time our child props change, make that information available
        // the parent if they need it.
        // The parent can listen for all updates and only act on the ones it cares about,
        // and multiple children updating in the same tick will all be sent at once.
        _(() => {
          var _info$flags, _info$flags2;

          // Insert this information in-place
          if (typeof info.index == "number") managedChildrenArray.current.arr[info.index] = {
            index: info.index,
            flags: (_info$flags = info.flags) !== null && _info$flags !== void 0 ? _info$flags : {},
            subInfo: info.subInfo
          };else managedChildrenArray.current.rec[info.index] = {
            index: info.index,
            flags: (_info$flags2 = info.flags) !== null && _info$flags2 !== void 0 ? _info$flags2 : {},
            subInfo: info.subInfo
          };
          return remoteULEChildChanged(info.index);
        }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
        // When we mount, notify the parent via queueMicrotask
        // (every child does this, so everything's coordinated to only queue a single microtask per tick)
        // Do the same on unmount.
        // Note: It's important that this comes AFTER remoteULEChildChanged
        // so that remoteULEChildMounted has access to all the info on mount.

        _(() => {
          remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, true);
          return () => remoteULEChildMounted === null || remoteULEChildMounted === void 0 ? void 0 : remoteULEChildMounted(info.index, false);
        }, [info.index]);
      }, [
        /* Must remain stable */
      ]);
      const managedChildren = A({ ...{
          _: managedChildrenArray.current
        },
        forEach: forEachChild,
        getAt: getManagedChildInfo,
        getHighestIndex: getHighestIndex,
        arraySlice: () => {
          return managedChildrenArray.current.arr.slice();
        }
      });
      return {
        useManagedChild,
        managedChildren: {
          children: managedChildren.current
        }
      };
    }
    /**
     * An extension to useManagedChildren that handles the following common case:
     * 1. You have a bunch of children
     * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
     * 3. The parent has control over who is "selected" via a numerical index.
     *
     * This hook allows for much easier control over selection management.
     *
     * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
     * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
     *
     * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
     *
     *
     * @param param0
     * @returns
     */

    function useChildrenFlag(_ref2) {
      let {
        children,
        initialIndex,
        closestFit,
        onIndexChange,
        key
      } = _ref2;
      useEnsureStability("useChildrenFlag", onIndexChange, key);
      const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange, q$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, []));
      const [getRequestedIndex, setRequestedIndex] = usePassiveState(null, q$1(() => initialIndex !== null && initialIndex !== void 0 ? initialIndex : null, [])); //    const getFitNullToZero = useStableGetter(fitNullToZero);
      // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)

      const getClosestFit = q$1(requestedIndex => {
        let closestDistance = Infinity;
        let closestIndex = null;
        children.forEach(child => {
          var _child$flags, _child$flags$key;

          if ((_child$flags = child.flags) !== null && _child$flags !== void 0 && (_child$flags$key = _child$flags[key]) !== null && _child$flags$key !== void 0 && _child$flags$key.isValid()) {
            const newDistance = Math.abs(child.index - requestedIndex);

            if (newDistance < closestDistance || newDistance == closestDistance && child.index < requestedIndex) {
              closestDistance = newDistance;
              closestIndex = child.index;
            }
          }
        });
        return closestIndex;
      }, [
        /* Must remain stable! */
      ]); // Any time a child mounts/unmounts, we need to double-check to see if that affects 
      // the "currently selected" (or whatever) index.  The two cases we're looking for:
      // 1. The currently selected child unmounted
      // 2. A child mounted, and it mounts with the index we're looking for

      const reevaluateClosestFit = useStableCallback(() => {
        var _currentChild$flags, _currentChild$flags$k;

        const requestedIndex = getRequestedIndex();
        const currentIndex = getCurrentIndex();
        const currentChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !((_currentChild$flags = currentChild.flags) !== null && _currentChild$flags !== void 0 && (_currentChild$flags$k = _currentChild$flags[key]) !== null && _currentChild$flags$k !== void 0 && _currentChild$flags$k.isValid()))) {
          var _currentChild$flags2;

          currentChild === null || currentChild === void 0 ? void 0 : (_currentChild$flags2 = currentChild.flags) === null || _currentChild$flags2 === void 0 ? void 0 : _currentChild$flags2[key].set(false);
          const closestFitIndex = getClosestFit(requestedIndex);
          setCurrentIndex(closestFitIndex);

          if (closestFitIndex != null) {
            var _closestFitChild$flag;

            const closestFitChild = children.getAt(closestFitIndex);
            console.assert(closestFitChild != null, "Internal logic???");
            (_closestFitChild$flag = closestFitChild.flags) === null || _closestFitChild$flag === void 0 ? void 0 : _closestFitChild$flag[key].set(true);
          }
        }
      });
      const changeIndex = q$1(arg => {
        const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg; //if (requestedIndex == null && getFitNullToZero())
        //    requestedIndex = 0;

        setRequestedIndex(requestedIndex);
        const currentIndex = getCurrentIndex();
        if (currentIndex == requestedIndex) return requestedIndex;
        let newMatchingChild = requestedIndex == null ? null : children.getAt(requestedIndex);
        const oldMatchingChild = currentIndex == null ? null : children.getAt(currentIndex);

        if (requestedIndex == null) {
          var _oldMatchingChild$fla;

          // Easy case
          setCurrentIndex(null);
          oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla = oldMatchingChild.flags) === null || _oldMatchingChild$fla === void 0 ? void 0 : _oldMatchingChild$fla[key].set(false);
          return null;
        } else {
          var _newMatchingChild$fla;

          if (newMatchingChild && (_newMatchingChild$fla = newMatchingChild.flags) !== null && _newMatchingChild$fla !== void 0 && _newMatchingChild$fla[key].isValid()) {
            var _oldMatchingChild$fla2, _newMatchingChild$fla2;

            setCurrentIndex(requestedIndex);
            oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla2 = oldMatchingChild.flags) === null || _oldMatchingChild$fla2 === void 0 ? void 0 : _oldMatchingChild$fla2[key].set(false);
            (_newMatchingChild$fla2 = newMatchingChild.flags) === null || _newMatchingChild$fla2 === void 0 ? void 0 : _newMatchingChild$fla2[key].set(true);
            return requestedIndex;
          } else {
            const closestFitIndex = getClosestFit(requestedIndex);
            setCurrentIndex(closestFitIndex);

            if (closestFitIndex != null) {
              var _oldMatchingChild$fla3, _newMatchingChild$fla3;

              newMatchingChild = children.getAt(closestFitIndex);
              console.assert(newMatchingChild != null, "Internal logic???");
              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla3 = oldMatchingChild.flags) === null || _oldMatchingChild$fla3 === void 0 ? void 0 : _oldMatchingChild$fla3[key].set(false);
              (_newMatchingChild$fla3 = newMatchingChild.flags) === null || _newMatchingChild$fla3 === void 0 ? void 0 : _newMatchingChild$fla3[key].set(true);
              return closestFitIndex;
            } else {
              var _oldMatchingChild$fla4;

              oldMatchingChild === null || oldMatchingChild === void 0 ? void 0 : (_oldMatchingChild$fla4 = oldMatchingChild.flags) === null || _oldMatchingChild$fla4 === void 0 ? void 0 : _oldMatchingChild$fla4[key].set(false);
              return null;
            }
          }
        }
      }, []);
      _(() => {
        var _children$getAt, _children$getAt$flags, _children$getAt$flags2;

        if (initialIndex != null) (_children$getAt = children.getAt(initialIndex)) === null || _children$getAt === void 0 ? void 0 : (_children$getAt$flags = _children$getAt.flags) === null || _children$getAt$flags === void 0 ? void 0 : (_children$getAt$flags2 = _children$getAt$flags[key]) === null || _children$getAt$flags2 === void 0 ? void 0 : _children$getAt$flags2.set(true);
      }, []);
      return {
        changeIndex,
        reevaluateClosestFit,
        getCurrentIndex
      };
    }

    function r(e) {
      var t,
          f,
          n = "";
      if ("string" == typeof e || "number" == typeof e) n += e;else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);else for (t in e) e[t] && (n && (n += " "), n += t);
      return n;
    }

    function clsx() {
      for (var e, t, f = 0, n = ""; f < arguments.length;) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);

      return n;
    }

    function getDocument$6(element) {
      var _ref, _ref2, _element$ownerDocumen;

      return (_ref = (_ref2 = (_element$ownerDocumen = element === null || element === void 0 ? void 0 : element.ownerDocument) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : document) !== null && _ref2 !== void 0 ? _ref2 : window.document) !== null && _ref !== void 0 ? _ref : globalThis.document;
    }

    function useMergedChildren(_ref, _ref2) {
      let {
        children: lhs
      } = _ref;
      let {
        children: rhs
      } = _ref2;

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return h$1(p$1, {}, lhs, rhs);
      }
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */

    function useMergedClasses(_ref, _ref2) {
      let {
        class: lhsClass,
        className: lhsClassName
      } = _ref;
      let {
        class: rhsClass,
        className: rhsClassName
      } = _ref2;

      // Note: For the sake of forward compatibility, this function is labelled as
      // a hook, but as it uses no other hooks it technically isn't one.
      if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
        const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
        const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
        const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
        return Array.from(allClasses).join(" ");
      } else {
        return undefined;
      }
    }

    function processRef(instance, ref) {
      if (typeof ref === "function") {
        ref(instance);
      } else if (ref != null) {
        ref.current = instance;
      } else {
        /* eslint-disable no-debugger */
        debugger;
        console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
      }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */


    function useMergedRefs(_ref, _ref2) {
      let {
        ref: rhs
      } = _ref;
      let {
        ref: lhs
      } = _ref2;
      const combined = q$1(current => {
        processRef(current, lhs);
        processRef(current, rhs);
      }, [lhs, rhs]);

      if (lhs == null && rhs == null) {
        return undefined;
      } else if (lhs == null) {
        return rhs;
      } else if (rhs == null) {
        return lhs;
      } else {
        return combined;
      }
    }

    function styleStringToObject(style) {
      // TODO: This sucks D:
      return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
    }
    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */


    function useMergedStyles(lhs, rhs) {
      var _lhs$style, _rhs$style2;

      // Easy case, when there are no styles to merge return nothing.
      if (!(lhs !== null && lhs !== void 0 && lhs.style) && !(rhs !== null && rhs !== void 0 && rhs.style)) return undefined;

      if (typeof lhs != typeof rhs) {
        // Easy cases, when one is null and the other isn't.
        if (lhs !== null && lhs !== void 0 && lhs.style && !(rhs !== null && rhs !== void 0 && rhs.style)) return lhs.style;
        if (!(lhs !== null && lhs !== void 0 && lhs.style) && rhs !== null && rhs !== void 0 && rhs.style) return rhs.style; // They're both non-null but different types.
        // Convert the string type to an object bag type and run it again.

        if (lhs !== null && lhs !== void 0 && lhs.style && rhs !== null && rhs !== void 0 && rhs.style) {
          // (useMergedStyles isn't a true hook -- this isn't a violation)
          if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") return useMergedStyles({
            style: styleStringToObject(lhs === null || lhs === void 0 ? void 0 : lhs.style)
          }, rhs);
          if (typeof (rhs === null || rhs === void 0 ? void 0 : rhs.style) == "string") return useMergedStyles(lhs, {
            style: styleStringToObject(rhs === null || rhs === void 0 ? void 0 : rhs.style)
          });
        } // Logic???


        return undefined;
      } // They're both strings, just concatenate them.


      if (typeof (lhs === null || lhs === void 0 ? void 0 : lhs.style) == "string") {
        var _rhs$style;

        return `${lhs.style};${(_rhs$style = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style !== void 0 ? _rhs$style : ""}`;
      } // They're both objects, just merge them.


      return { ...((_lhs$style = lhs === null || lhs === void 0 ? void 0 : lhs.style) !== null && _lhs$style !== void 0 ? _lhs$style : {}),
        ...((_rhs$style2 = rhs === null || rhs === void 0 ? void 0 : rhs.style) !== null && _rhs$style2 !== void 0 ? _rhs$style2 : {})
      };
    }

    let log = console.warn;
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */

    function useMergedProps(lhsAll, rhsAll) {
      // First, separate the props we were given into two groups:
      // lhsAll and rhsAll contain all the props we were given, and
      // lhsMisc and rhsMisc contain all props *except* for the easy ones
      // like className and style that we already know how to merge.
      const {
        children: _lhsChildren,
        class: _lhsClass,
        className: _lhsClassName,
        style: _lhsStyle,
        ref: _lhsRef,
        ...lhsMisc
      } = lhsAll;
      const {
        children: _rhsChildren,
        class: _rhsClass,
        className: _rhsClassName,
        style: _rhsStyle,
        ref: _rhsRef,
        ...rhsMisc
      } = rhsAll;
      const ret = { ...lhsMisc,
        ref: useMergedRefs(lhsAll, rhsAll),
        style: useMergedStyles(lhsAll, rhsAll),
        className: useMergedClasses(lhsAll, rhsAll),
        children: useMergedChildren(lhsAll, rhsAll)
      };
      if (ret.ref === undefined) delete ret.ref;
      if (ret.style === undefined) delete ret.style;
      if (ret.className === undefined) delete ret.className;
      if (ret.children === undefined) delete ret.children; // Now, do *everything* else
      // Merge every remaining existing entry in lhs with what we've already put in ret.
      //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];

      const rhsEntries = Object.entries(rhsMisc);

      for (const [rhsKeyU, rhsValue] of rhsEntries) {
        const rhsKey = rhsKeyU;
        const lhsValue = lhsMisc[rhsKey];

        if (typeof lhsValue === "function" || typeof rhsValue === "function") {
          // They're both functions that can be merged (or one's a function and the other's null).
          // Not an *easy* case, but a well-defined one.
          const merged = mergeFunctions(lhsValue, rhsValue);
          ret[rhsKey] = merged;
        } else {
          // Uh...we're here because one of them's null, right?
          if (lhsValue == null && rhsValue == null) {
            if (rhsValue === null && lhsValue === undefined) ret[rhsKey] = rhsValue;else ret[rhsKey] = lhsValue;
          }

          if (lhsValue == null) ret[rhsKey] = rhsValue;else if (rhsValue == null) ret[rhsKey] = lhsValue;else if (rhsValue == lhsValue) ; else {
            var _log;

            // Ugh.
            // No good strategies here, just log it if requested
            (_log = log) === null || _log === void 0 ? void 0 : _log(`The prop "${rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
            ret[rhsKey] = rhsValue;
          }
        }
      }

      return ret;
    }

    function mergeFunctions(lhs, rhs) {
      if (!lhs) return rhs;
      if (!rhs) return lhs;
      return function () {
        const lv = lhs(...arguments);
        const rv = rhs(...arguments);
        if (lv instanceof Promise || rv instanceof Promise) return Promise.all([lv, rv]);
      };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */

    function useRefElement(args) {
      const {
        onElementChange,
        onMount,
        onUnmount
      } = args !== null && args !== void 0 ? args : {};
      useEnsureStability("useRefElement", onElementChange, onMount, onUnmount); // Called (indirectly) by the ref that the element receives.

      const handler = q$1((e, prevValue) => {
        const cleanup = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prevValue);
        if (prevValue) onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(prevValue);
        if (e) onMount === null || onMount === void 0 ? void 0 : onMount(e);
        return cleanup;
      }, []); // Let us store the actual (reference to) the element we capture

      const [getElement, setElement] = usePassiveState(handler, returnNull);
      const useRefElementProps = q$1(props => useMergedProps({
        ref: setElement
      }, props), []); // Return both the element and the hook that modifies 
      // the props and allows us to actually find the element

      return {
        useRefElementProps,
        getElement
      };
    }

    function useElementSize(_ref) {
      let {
        getObserveBox,
        onSizeChange
      } = _ref;
      useEnsureStability("useElementSize", getObserveBox, onSizeChange);
      const [getSize, setSize] = usePassiveState(onSizeChange, returnNull);
      const currentObserveBox = A(undefined);
      const needANewObserver = q$1((element, observeBox) => {
        if (element) {
          const document = getDocument$6(element);
          const window = document.defaultView;

          const handleUpdate = () => {
            if (element.isConnected) {
              const {
                clientWidth,
                scrollWidth,
                offsetWidth,
                clientHeight,
                scrollHeight,
                offsetHeight,
                clientLeft,
                scrollLeft,
                offsetLeft,
                clientTop,
                scrollTop,
                offsetTop
              } = element;
              setSize({
                clientWidth,
                scrollWidth,
                offsetWidth,
                clientHeight,
                scrollHeight,
                offsetHeight,
                clientLeft,
                scrollLeft,
                offsetLeft,
                clientTop,
                scrollTop,
                offsetTop
              });
            }
          };

          if (window && "ResizeObserver" in window) {
            const observer = new ResizeObserver(_entries => {
              handleUpdate();
            });
            observer.observe(element, {
              box: observeBox
            });
            return () => observer.disconnect();
          } else {
            document.addEventListener("resize", handleUpdate, {
              passive: true
            });
            return () => document.removeEventListener("resize", handleUpdate);
          }
        }
      }, []);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: q$1(e => needANewObserver(e, getObserveBox === null || getObserveBox === void 0 ? void 0 : getObserveBox()), [])
      });
      s(() => {
        if (getObserveBox) {
          if (currentObserveBox.current !== getObserveBox()) needANewObserver(getElement(), getObserveBox());
        }
      });
      return {
        getElement,
        getSize,
        useElementSizeProps: useRefElementProps
      };
    }

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */

    function useGlobalHandler(target, type, handler, options) {
      // Note to self: The typing doesn't improve even if this is split up into a sub-function.
      // No matter what, it seems impossible to get the handler's event object typed perfectly.
      // It seems like it's guaranteed to always be a union of all available tupes.
      // Again, no matter what combination of sub- or sub-sub-functions used.
      let stableHandler = useStableCallback(handler !== null && handler !== void 0 ? handler : () => {});
      if (handler == null) stableHandler = null;
      s(() => {
        if (stableHandler) {
          target.addEventListener(type, stableHandler, options);
          return () => target.removeEventListener(type, stableHandler, options);
        }
      }, [target, type, stableHandler]);
    }

    /*!
    * tabbable 6.0.0
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var NoElement = typeof Element === 'undefined';
    var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
      return element.getRootNode();
    } : function (element) {
      return element.ownerDocument;
    };

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };


    var isNodeAttached = function isNodeAttached(node) {
      var _nodeRootHost; // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
      //  (but NOT _the_ document; see second 'If' comment below for more).
      // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
      //  is attached, and the one we need to check if it's in the document or not (because the
      //  shadow, and all nodes it contains, is never considered in the document since shadows
      //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
      //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
      //  visibility, including all the nodes it contains). The host could be any normal node,
      //  or a custom element (i.e. web component). Either way, that's the one that is considered
      //  part of the document, not the shadow root, nor any of its children (i.e. the node being
      //  tested).
      // To further complicate things, we have to look all the way up until we find a shadow HOST
      //  that is attached (or find none) because the node might be in nested shadows...
      // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
      //  document (per the docs) and while it's a Document-type object, that document does not
      //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
      //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
      //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
      //  node is actually detached.


      var nodeRootHost = getRootNode(node).host;
      var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));

      while (!attached && nodeRootHost) {
        var _nodeRootHost2; // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
        //  which means we need to get the host's host and check if that parent host is contained
        //  in (i.e. attached to) the document


        nodeRootHost = getRootNode(nodeRootHost).host;
        attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
      }

      return attached;
    };

    var isZeroArea = function isZeroArea(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(),
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      return width === 0 && height === 0;
    };

    var isHidden = function isHidden(node, _ref) {
      var displayCheck = _ref.displayCheck,
          getShadowRoot = _ref.getShadowRoot; // NOTE: visibility will be `undefined` if node is detached from the document
      //  (see notes about this further down), which means we will consider it visible
      //  (this is legacy behavior from a very long way back)
      // NOTE: we check this regardless of `displayCheck="none"` because this is a
      //  _visibility_ check, not a _display_ check

      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      }

      if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
        if (typeof getShadowRoot === 'function') {
          // figure out if we should consider the node to be in an undisclosed shadow and use the
          //  'non-zero-area' fallback
          var originalNode = node;

          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);

            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
            ) {
              // node has an undisclosed shadow which means we can only treat it as a black box, so we
              //  fall back to a non-zero-area test
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              // iterate up slot
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              // cross shadow boundary
              node = rootNode.host;
            } else {
              // iterate up normal dom
              node = parentElement;
            }
          }

          node = originalNode;
        } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.


        if (isNodeAttached(node)) {
          // this works wherever the node is: if there's at least one client rect, it's
          //  somehow displayed; it also covers the CSS 'display: contents' case where the
          //  node itself is hidden in place of its contents; and there's no need to search
          //  up the hierarchy either
          return !node.getClientRects().length;
        } // Else, the node isn't attached to the document, which means the `getClientRects()`
        //  API will __always__ return zero rects (this can happen, for example, if React
        //  is used to render nodes onto a detached tree, as confirmed in this thread:
        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
        //
        // It also means that even window.getComputedStyle(node).display will return `undefined`
        //  because styles are only computed for nodes that are in the document.
        //
        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
        //  somehow. Though it was never stated officially, anyone who has ever used tabbable
        //  APIs on nodes in detached containers has actually implicitly used tabbable in what
        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
        //  considering __everything__ to be visible because of the innability to determine styles.
        //
        // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
        //  nodes as visible with the 'none' fallback.__


        if (displayCheck !== 'legacy-full') {
          return true; // hidden
        } // else, fallback to 'none' mode and consider the node visible

      } else if (displayCheck === 'non-zero-area') {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
      } // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
      //  it's visible


      return false;
    }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset


    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>

        while (parentNode) {
          if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
            // look for the first <legend> among the children of the disabled <fieldset>
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i); // when the first <legend> (in document order) is found

              if (child.tagName === 'LEGEND') {
                // if its parent <fieldset> is not nested in another disabled <fieldset>,
                // return whether `node` is a descendant of its first <legend>
                return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
              }
            } // the disabled <fieldset> containing `node` has no <legend>


            return true;
          }

          parentNode = parentNode.parentElement;
        }
      } // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state


      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    (function (module, exports) {
      (function (global, factory) {
        factory() ;
      })(commonjsGlobal, function () {

        var _createClass = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        /**
         * This work is licensed under the W3C Software and Document License
         * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
         */


        (function () {
          // Return early if we're not running inside of the browser.
          if (typeof window === 'undefined') {
            return;
          } // Convenience function for converting NodeLists.

          /** @type {typeof Array.prototype.slice} */


          var slice = Array.prototype.slice;
          /**
           * IE has a non-standard name for "matches".
           * @type {typeof Element.prototype.matches}
           */

          var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
          /** @type {string} */

          var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
          /**
           * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
           * attribute.
           *
           * Its main functions are:
           *
           * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
           *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
           *   each focusable node in the subtree with the singleton `InertManager` which manages all known
           *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
           *   instance exists for each focusable node which has at least one inert root as an ancestor.
           *
           * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
           *   attribute is removed from the root node). This is handled in the destructor, which calls the
           *   `deregister` method on `InertManager` for each managed inert node.
           */


          var InertRoot = function () {
            /**
             * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
             * @param {!InertManager} inertManager The global singleton InertManager object.
             */
            function InertRoot(rootElement, inertManager) {
              _classCallCheck(this, InertRoot);
              /** @type {!InertManager} */


              this._inertManager = inertManager;
              /** @type {!HTMLElement} */

              this._rootElement = rootElement;
              /**
               * @type {!Set<!InertNode>}
               * All managed focusable nodes in this InertRoot's subtree.
               */

              this._managedNodes = new Set(); // Make the subtree hidden from assistive technology

              if (this._rootElement.hasAttribute('aria-hidden')) {
                /** @type {?string} */
                this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
              } else {
                this._savedAriaHidden = null;
              }

              this._rootElement.setAttribute('aria-hidden', 'true'); // Make all focusable elements in the subtree unfocusable and add them to _managedNodes


              this._makeSubtreeUnfocusable(this._rootElement); // Watch for:
              // - any additions in the subtree: make them unfocusable too
              // - any removals from the subtree: remove them from this inert root's managed nodes
              // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
              //   element, make that node a managed node.


              this._observer = new MutationObserver(this._onMutation.bind(this));

              this._observer.observe(this._rootElement, {
                attributes: true,
                childList: true,
                subtree: true
              });
            }
            /**
             * Call this whenever this object is about to become obsolete.  This unwinds all of the state
             * stored in this object and updates the state of all of the managed nodes.
             */


            _createClass(InertRoot, [{
              key: 'destructor',
              value: function destructor() {
                this._observer.disconnect();

                if (this._rootElement) {
                  if (this._savedAriaHidden !== null) {
                    this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                  } else {
                    this._rootElement.removeAttribute('aria-hidden');
                  }
                }

                this._managedNodes.forEach(function (inertNode) {
                  this._unmanageNode(inertNode.node);
                }, this); // Note we cast the nulls to the ANY type here because:
                // 1) We want the class properties to be declared as non-null, or else we
                //    need even more casts throughout this code. All bets are off if an
                //    instance has been destroyed and a method is called.
                // 2) We don't want to cast "this", because we want type-aware optimizations
                //    to know which properties we're setting.


                this._observer =
                /** @type {?} */
                null;
                this._rootElement =
                /** @type {?} */
                null;
                this._managedNodes =
                /** @type {?} */
                null;
                this._inertManager =
                /** @type {?} */
                null;
              }
              /**
               * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
               */

            }, {
              key: '_makeSubtreeUnfocusable',

              /**
               * @param {!Node} startNode
               */
              value: function _makeSubtreeUnfocusable(startNode) {
                var _this2 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this2._visitNode(node);
                });
                var activeElement = document.activeElement;

                if (!document.body.contains(startNode)) {
                  // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                  var node = startNode;
                  /** @type {!ShadowRoot|undefined} */

                  var root = undefined;

                  while (node) {
                    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      root =
                      /** @type {!ShadowRoot} */
                      node;
                      break;
                    }

                    node = node.parentNode;
                  }

                  if (root) {
                    activeElement = root.activeElement;
                  }
                }

                if (startNode.contains(activeElement)) {
                  activeElement.blur(); // In IE11, if an element is already focused, and then set to tabindex=-1
                  // calling blur() will not actually move the focus.
                  // To work around this we call focus() on the body instead.

                  if (activeElement === document.activeElement) {
                    document.body.focus();
                  }
                }
              }
              /**
               * @param {!Node} node
               */

            }, {
              key: '_visitNode',
              value: function _visitNode(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                node; // If a descendant inert root becomes un-inert, its descendants will still be inert because of
                // this inert root, so all of its managed nodes need to be adopted by this InertRoot.

                if (element !== this._rootElement && element.hasAttribute('inert')) {
                  this._adoptInertRoot(element);
                }

                if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                  this._manageNode(element);
                }
              }
              /**
               * Register the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_manageNode',
              value: function _manageNode(node) {
                var inertNode = this._inertManager.register(node, this);

                this._managedNodes.add(inertNode);
              }
              /**
               * Unregister the given node with this InertRoot and with InertManager.
               * @param {!Node} node
               */

            }, {
              key: '_unmanageNode',
              value: function _unmanageNode(node) {
                var inertNode = this._inertManager.deregister(node, this);

                if (inertNode) {
                  this._managedNodes['delete'](inertNode);
                }
              }
              /**
               * Unregister the entire subtree starting at `startNode`.
               * @param {!Node} startNode
               */

            }, {
              key: '_unmanageSubtree',
              value: function _unmanageSubtree(startNode) {
                var _this3 = this;

                composedTreeWalk(startNode, function (node) {
                  return _this3._unmanageNode(node);
                });
              }
              /**
               * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
               * @param {!HTMLElement} node
               */

            }, {
              key: '_adoptInertRoot',
              value: function _adoptInertRoot(node) {
                var inertSubroot = this._inertManager.getInertRoot(node); // During initialisation this inert root may not have been registered yet,
                // so register it now if need be.


                if (!inertSubroot) {
                  this._inertManager.setInert(node, true);

                  inertSubroot = this._inertManager.getInertRoot(node);
                }

                inertSubroot.managedNodes.forEach(function (savedInertNode) {
                  this._manageNode(savedInertNode.node);
                }, this);
              }
              /**
               * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_onMutation',
              value: function _onMutation(records, self) {
                records.forEach(function (record) {
                  var target =
                  /** @type {!HTMLElement} */
                  record.target;

                  if (record.type === 'childList') {
                    // Manage added nodes
                    slice.call(record.addedNodes).forEach(function (node) {
                      this._makeSubtreeUnfocusable(node);
                    }, this); // Un-manage removed nodes

                    slice.call(record.removedNodes).forEach(function (node) {
                      this._unmanageSubtree(node);
                    }, this);
                  } else if (record.type === 'attributes') {
                    if (record.attributeName === 'tabindex') {
                      // Re-initialise inert node if tabindex changes
                      this._manageNode(target);
                    } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                      // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                      // already managed nodes from this inert subroot.
                      this._adoptInertRoot(target);

                      var inertSubroot = this._inertManager.getInertRoot(target);

                      this._managedNodes.forEach(function (managedNode) {
                        if (target.contains(managedNode.node)) {
                          inertSubroot._manageNode(managedNode.node);
                        }
                      });
                    }
                  }
                }, this);
              }
            }, {
              key: 'managedNodes',
              get: function get() {
                return new Set(this._managedNodes);
              }
              /** @return {boolean} */

            }, {
              key: 'hasSavedAriaHidden',
              get: function get() {
                return this._savedAriaHidden !== null;
              }
              /** @param {?string} ariaHidden */

            }, {
              key: 'savedAriaHidden',
              set: function set(ariaHidden) {
                this._savedAriaHidden = ariaHidden;
              }
              /** @return {?string} */
              ,
              get: function get() {
                return this._savedAriaHidden;
              }
            }]);

            return InertRoot;
          }();
          /**
           * `InertNode` initialises and manages a single inert node.
           * A node is inert if it is a descendant of one or more inert root elements.
           *
           * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
           * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
           * is intrinsically focusable or not.
           *
           * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
           * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
           * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
           * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
           * or removes the `tabindex` attribute if the element is intrinsically focusable.
           */


          var InertNode = function () {
            /**
             * @param {!Node} node A focusable element to be made inert.
             * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
             */
            function InertNode(node, inertRoot) {
              _classCallCheck(this, InertNode);
              /** @type {!Node} */


              this._node = node;
              /** @type {boolean} */

              this._overrodeFocusMethod = false;
              /**
               * @type {!Set<!InertRoot>} The set of descendant inert roots.
               *    If and only if this set becomes empty, this node is no longer inert.
               */

              this._inertRoots = new Set([inertRoot]);
              /** @type {?number} */

              this._savedTabIndex = null;
              /** @type {boolean} */

              this._destroyed = false; // Save any prior tabindex info and make this node untabbable

              this.ensureUntabbable();
            }
            /**
             * Call this whenever this object is about to become obsolete.
             * This makes the managed node focusable again and deletes all of the previously stored state.
             */


            _createClass(InertNode, [{
              key: 'destructor',
              value: function destructor() {
                this._throwIfDestroyed();

                if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                  var element =
                  /** @type {!HTMLElement} */
                  this._node;

                  if (this._savedTabIndex !== null) {
                    element.setAttribute('tabindex', this._savedTabIndex);
                  } else {
                    element.removeAttribute('tabindex');
                  } // Use `delete` to restore native focus method.


                  if (this._overrodeFocusMethod) {
                    delete element.focus;
                  }
                } // See note in InertRoot.destructor for why we cast these nulls to ANY.


                this._node =
                /** @type {?} */
                null;
                this._inertRoots =
                /** @type {?} */
                null;
                this._destroyed = true;
              }
              /**
               * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
               * If the object has been destroyed, any attempt to access it will cause an exception.
               */

            }, {
              key: '_throwIfDestroyed',

              /**
               * Throw if user tries to access destroyed InertNode.
               */
              value: function _throwIfDestroyed() {
                if (this.destroyed) {
                  throw new Error('Trying to access destroyed InertNode');
                }
              }
              /** @return {boolean} */

            }, {
              key: 'ensureUntabbable',

              /** Save the existing tabindex value and make the node untabbable and unfocusable */
              value: function ensureUntabbable() {
                if (this.node.nodeType !== Node.ELEMENT_NODE) {
                  return;
                }

                var element =
                /** @type {!HTMLElement} */
                this.node;

                if (matches.call(element, _focusableElementsString)) {
                  if (
                  /** @type {!HTMLElement} */
                  element.tabIndex === -1 && this.hasSavedTabIndex) {
                    return;
                  }

                  if (element.hasAttribute('tabindex')) {
                    this._savedTabIndex =
                    /** @type {!HTMLElement} */
                    element.tabIndex;
                  }

                  element.setAttribute('tabindex', '-1');

                  if (element.nodeType === Node.ELEMENT_NODE) {
                    element.focus = function () {};

                    this._overrodeFocusMethod = true;
                  }
                } else if (element.hasAttribute('tabindex')) {
                  this._savedTabIndex =
                  /** @type {!HTMLElement} */
                  element.tabIndex;
                  element.removeAttribute('tabindex');
                }
              }
              /**
               * Add another inert root to this inert node's set of managing inert roots.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'addInertRoot',
              value: function addInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots.add(inertRoot);
              }
              /**
               * Remove the given inert root from this inert node's set of managing inert roots.
               * If the set of managing inert roots becomes empty, this node is no longer inert,
               * so the object should be destroyed.
               * @param {!InertRoot} inertRoot
               */

            }, {
              key: 'removeInertRoot',
              value: function removeInertRoot(inertRoot) {
                this._throwIfDestroyed();

                this._inertRoots['delete'](inertRoot);

                if (this._inertRoots.size === 0) {
                  this.destructor();
                }
              }
            }, {
              key: 'destroyed',
              get: function get() {
                return (
                  /** @type {!InertNode} */
                  this._destroyed
                );
              }
            }, {
              key: 'hasSavedTabIndex',
              get: function get() {
                return this._savedTabIndex !== null;
              }
              /** @return {!Node} */

            }, {
              key: 'node',
              get: function get() {
                this._throwIfDestroyed();

                return this._node;
              }
              /** @param {?number} tabIndex */

            }, {
              key: 'savedTabIndex',
              set: function set(tabIndex) {
                this._throwIfDestroyed();

                this._savedTabIndex = tabIndex;
              }
              /** @return {?number} */
              ,
              get: function get() {
                this._throwIfDestroyed();

                return this._savedTabIndex;
              }
            }]);

            return InertNode;
          }();
          /**
           * InertManager is a per-document singleton object which manages all inert roots and nodes.
           *
           * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
           * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
           * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
           * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
           * is created for each such node, via the `_managedNodes` map.
           */


          var InertManager = function () {
            /**
             * @param {!Document} document
             */
            function InertManager(document) {
              _classCallCheck(this, InertManager);

              if (!document) {
                throw new Error('Missing required argument; InertManager needs to wrap a document.');
              }
              /** @type {!Document} */


              this._document = document;
              /**
               * All managed nodes known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertNode>}
               */

              this._managedNodes = new Map();
              /**
               * All inert roots known to this InertManager. In a map to allow looking up by Node.
               * @type {!Map<!Node, !InertRoot>}
               */

              this._inertRoots = new Map();
              /**
               * Observer for mutations on `document.body`.
               * @type {!MutationObserver}
               */

              this._observer = new MutationObserver(this._watchForInert.bind(this)); // Add inert style.

              addInertStyle(document.head || document.body || document.documentElement); // Wait for document to be loaded.

              if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
              } else {
                this._onDocumentLoaded();
              }
            }
            /**
             * Set whether the given element should be an inert root or not.
             * @param {!HTMLElement} root
             * @param {boolean} inert
             */


            _createClass(InertManager, [{
              key: 'setInert',
              value: function setInert(root, inert) {
                if (inert) {
                  if (this._inertRoots.has(root)) {
                    // element is already inert
                    return;
                  }

                  var inertRoot = new InertRoot(root, this);
                  root.setAttribute('inert', '');

                  this._inertRoots.set(root, inertRoot); // If not contained in the document, it must be in a shadowRoot.
                  // Ensure inert styles are added there.


                  if (!this._document.body.contains(root)) {
                    var parent = root.parentNode;

                    while (parent) {
                      if (parent.nodeType === 11) {
                        addInertStyle(parent);
                      }

                      parent = parent.parentNode;
                    }
                  }
                } else {
                  if (!this._inertRoots.has(root)) {
                    // element is already non-inert
                    return;
                  }

                  var _inertRoot = this._inertRoots.get(root);

                  _inertRoot.destructor();

                  this._inertRoots['delete'](root);

                  root.removeAttribute('inert');
                }
              }
              /**
               * Get the InertRoot object corresponding to the given inert root element, if any.
               * @param {!Node} element
               * @return {!InertRoot|undefined}
               */

            }, {
              key: 'getInertRoot',
              value: function getInertRoot(element) {
                return this._inertRoots.get(element);
              }
              /**
               * Register the given InertRoot as managing the given node.
               * In the case where the node has a previously existing inert root, this inert root will
               * be added to its set of inert roots.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {!InertNode} inertNode
               */

            }, {
              key: 'register',
              value: function register(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (inertNode !== undefined) {
                  // node was already in an inert subtree
                  inertNode.addInertRoot(inertRoot);
                } else {
                  inertNode = new InertNode(node, inertRoot);
                }

                this._managedNodes.set(node, inertNode);

                return inertNode;
              }
              /**
               * De-register the given InertRoot as managing the given inert node.
               * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
               * node from the InertManager's set of managed nodes if it is destroyed.
               * If the node is not currently managed, this is essentially a no-op.
               * @param {!Node} node
               * @param {!InertRoot} inertRoot
               * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
               */

            }, {
              key: 'deregister',
              value: function deregister(node, inertRoot) {
                var inertNode = this._managedNodes.get(node);

                if (!inertNode) {
                  return null;
                }

                inertNode.removeInertRoot(inertRoot);

                if (inertNode.destroyed) {
                  this._managedNodes['delete'](node);
                }

                return inertNode;
              }
              /**
               * Callback used when document has finished loading.
               */

            }, {
              key: '_onDocumentLoaded',
              value: function _onDocumentLoaded() {
                // Find all inert roots in document and make them actually inert.
                var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
                inertElements.forEach(function (inertElement) {
                  this.setInert(inertElement, true);
                }, this); // Comment this out to use programmatic API only.

                this._observer.observe(this._document.body || this._document.documentElement, {
                  attributes: true,
                  subtree: true,
                  childList: true
                });
              }
              /**
               * Callback used when mutation observer detects attribute changes.
               * @param {!Array<!MutationRecord>} records
               * @param {!MutationObserver} self
               */

            }, {
              key: '_watchForInert',
              value: function _watchForInert(records, self) {
                var _this = this;

                records.forEach(function (record) {
                  switch (record.type) {
                    case 'childList':
                      slice.call(record.addedNodes).forEach(function (node) {
                        if (node.nodeType !== Node.ELEMENT_NODE) {
                          return;
                        }

                        var inertElements = slice.call(node.querySelectorAll('[inert]'));

                        if (matches.call(node, '[inert]')) {
                          inertElements.unshift(node);
                        }

                        inertElements.forEach(function (inertElement) {
                          this.setInert(inertElement, true);
                        }, _this);
                      }, _this);
                      break;

                    case 'attributes':
                      if (record.attributeName !== 'inert') {
                        return;
                      }

                      var target =
                      /** @type {!HTMLElement} */
                      record.target;
                      var inert = target.hasAttribute('inert');

                      _this.setInert(target, inert);

                      break;
                  }
                }, this);
              }
            }]);

            return InertManager;
          }();
          /**
           * Recursively walk the composed tree from |node|.
           * @param {!Node} node
           * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
           *     before descending into child nodes.
           * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
           */


          function composedTreeWalk(node, callback, shadowRootAncestor) {
            if (node.nodeType == Node.ELEMENT_NODE) {
              var element =
              /** @type {!HTMLElement} */
              node;

              if (callback) {
                callback(element);
              } // Descend into node:
              // If it has a ShadowRoot, ignore all child elements - these will be picked
              // up by the <content> or <shadow> elements. Descend straight into the
              // ShadowRoot.


              var shadowRoot =
              /** @type {!HTMLElement} */
              element.shadowRoot;

              if (shadowRoot) {
                composedTreeWalk(shadowRoot, callback);
                return;
              } // If it is a <content> element, descend into distributed elements - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'content') {
                var content =
                /** @type {!HTMLContentElement} */
                element; // Verifies if ShadowDom v0 is supported.

                var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];

                for (var i = 0; i < distributedNodes.length; i++) {
                  composedTreeWalk(distributedNodes[i], callback);
                }

                return;
              } // If it is a <slot> element, descend into assigned nodes - these
              // are elements from outside the shadow root which are rendered inside the
              // shadow DOM.


              if (element.localName == 'slot') {
                var slot =
                /** @type {!HTMLSlotElement} */
                element; // Verify if ShadowDom v1 is supported.

                var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                  flatten: true
                }) : [];

                for (var _i = 0; _i < _distributedNodes.length; _i++) {
                  composedTreeWalk(_distributedNodes[_i], callback);
                }

                return;
              }
            } // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
            // element, nor a <shadow> element recurse normally.


            var child = node.firstChild;

            while (child != null) {
              composedTreeWalk(child, callback);
              child = child.nextSibling;
            }
          }
          /**
           * Adds a style element to the node containing the inert specific styles
           * @param {!Node} node
           */


          function addInertStyle(node) {
            if (node.querySelector('style#inert-style, link#inert-style')) {
              return;
            }

            var style = document.createElement('style');
            style.setAttribute('id', 'inert-style');
            style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
            node.appendChild(style);
          }

          if (!HTMLElement.prototype.hasOwnProperty('inert')) {
            /** @type {!InertManager} */
            var inertManager = new InertManager(document);
            Object.defineProperty(HTMLElement.prototype, 'inert', {
              enumerable: true,

              /** @this {!HTMLElement} */
              get: function get() {
                return this.hasAttribute('inert');
              },

              /** @this {!HTMLElement} */
              set: function set(inert) {
                inertManager.setInert(this, inert);
              }
            });
          }
        })();
      });
    })();

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
      var _a, _b, _c;
      /* Symbols for private properties */


      const _blockingElements = Symbol();

      const _alreadyInertElements = Symbol();

      const _topElParents = Symbol();

      const _siblingsToRestore = Symbol();

      const _parentMO = Symbol();
      /* Symbols for private static methods */


      const _topChanged = Symbol();

      const _swapInertedSibling = Symbol();

      const _inertSiblings = Symbol();

      const _restoreInertedSiblings = Symbol();

      const _getParents = Symbol();

      const _getDistributedChildren = Symbol();

      const _isInertable = Symbol();

      const _handleMutations = Symbol();

      class BlockingElementsImpl {
        constructor() {
          /**
           * The blocking elements.
           */
          this[_a] = [];
          /**
           * Used to keep track of the parents of the top element, from the element
           * itself up to body. When top changes, the old top might have been removed
           * from the document, so we need to memoize the inerted parents' siblings
           * in order to restore their inerteness when top changes.
           */

          this[_b] = [];
          /**
           * Elements that are already inert before the first blocking element is
           * pushed.
           */

          this[_c] = new Set();
        }

        destructor() {
          // Restore original inertness.
          this[_restoreInertedSiblings](this[_topElParents]); // Note we don't want to make these properties nullable on the class,
          // since then we'd need non-null casts in many places. Calling a method on
          // a BlockingElements instance after calling destructor will result in an
          // exception.


          const nullable = this;
          nullable[_blockingElements] = null;
          nullable[_topElParents] = null;
          nullable[_alreadyInertElements] = null;
        }

        get top() {
          const elems = this[_blockingElements];
          return elems[elems.length - 1] || null;
        }

        push(element) {
          if (!element || element === this.top) {
            return;
          } // Remove it from the stack, we'll bring it to the top.


          this.remove(element);

          this[_topChanged](element);

          this[_blockingElements].push(element);
        }

        remove(element) {
          const i = this[_blockingElements].indexOf(element);

          if (i === -1) {
            return false;
          }

          this[_blockingElements].splice(i, 1); // Top changed only if the removed element was the top element.


          if (i === this[_blockingElements].length) {
            this[_topChanged](this.top);
          }

          return true;
        }

        pop() {
          const top = this.top;
          top && this.remove(top);
          return top;
        }

        has(element) {
          return this[_blockingElements].indexOf(element) !== -1;
        }
        /**
         * Sets `inert` to all document elements except the new top element, its
         * parents, and its distributed content.
         */


        [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
          const toKeepInert = this[_alreadyInertElements];
          const oldParents = this[_topElParents]; // No new top, reset old top if any.

          if (!newTop) {
            this[_restoreInertedSiblings](oldParents);

            toKeepInert.clear();
            this[_topElParents] = [];
            return;
          }

          const newParents = this[_getParents](newTop); // New top is not contained in the main document!


          if (newParents[newParents.length - 1].parentNode !== document.body) {
            throw Error('Non-connected element cannot be a blocking element');
          } // Cast here because we know we'll call _inertSiblings on newParents
          // below.


          this[_topElParents] = newParents;

          const toSkip = this[_getDistributedChildren](newTop); // No previous top element.


          if (!oldParents.length) {
            this[_inertSiblings](newParents, toSkip, toKeepInert);

            return;
          }

          let i = oldParents.length - 1;
          let j = newParents.length - 1; // Find common parent. Index 0 is the element itself (so stop before it).

          while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
            i--;
            j--;
          } // If up the parents tree there are 2 elements that are siblings, swap
          // the inerted sibling.


          if (oldParents[i] !== newParents[j]) {
            this[_swapInertedSibling](oldParents[i], newParents[j]);
          } // Restore old parents siblings inertness.


          i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i)); // Make new parents siblings inert.

          j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
        }
        /**
         * Swaps inertness between two sibling elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_swapInertedSibling](oldInert, newInert) {
          const siblingsToRestore = oldInert[_siblingsToRestore]; // oldInert is not contained in siblings to restore, so we have to check
          // if it's inertable and if already inert.

          if (this[_isInertable](oldInert) && !oldInert.inert) {
            oldInert.inert = true;
            siblingsToRestore.add(oldInert);
          } // If newInert was already between the siblings to restore, it means it is
          // inertable and must be restored.


          if (siblingsToRestore.has(newInert)) {
            newInert.inert = false;
            siblingsToRestore.delete(newInert);
          }

          newInert[_parentMO] = oldInert[_parentMO];
          newInert[_siblingsToRestore] = siblingsToRestore;
          oldInert[_parentMO] = undefined;
          oldInert[_siblingsToRestore] = undefined;
        }
        /**
         * Restores original inertness to the siblings of the elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_restoreInertedSiblings](elements) {
          for (const element of elements) {
            const mo = element[_parentMO];
            mo.disconnect();
            element[_parentMO] = undefined;
            const siblings = element[_siblingsToRestore];

            for (const sibling of siblings) {
              sibling.inert = false;
            }

            element[_siblingsToRestore] = undefined;
          }
        }
        /**
         * Inerts the siblings of the elements except the elements to skip. Stores
         * the inerted siblings into the element's symbol `_siblingsToRestore`.
         * Pass `toKeepInert` to collect the already inert elements.
         * Sets the property `inert` over the attribute since the inert spec
         * doesn't specify if it should be reflected.
         * https://html.spec.whatwg.org/multipage/interaction.html#inert
         */


        [_inertSiblings](elements, toSkip, toKeepInert) {
          for (const element of elements) {
            // Assume element is not a Document, so it must have a parentNode.
            const parent = element.parentNode;
            const children = parent.children;
            const inertedSiblings = new Set();

            for (let j = 0; j < children.length; j++) {
              const sibling = children[j]; // Skip the input element, if not inertable or to be skipped.

              if (sibling === element || !this[_isInertable](sibling) || toSkip && toSkip.has(sibling)) {
                continue;
              } // Should be collected since already inerted.


              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            } // Store the siblings that were inerted.


            element[_siblingsToRestore] = inertedSiblings; // Observe only immediate children mutations on the parent.

            const mo = new MutationObserver(this[_handleMutations].bind(this));
            element[_parentMO] = mo;
            let parentToObserve = parent; // If we're using the ShadyDOM polyfill, then our parent could be a
            // shady root, which is an object that acts like a ShadowRoot, but isn't
            // actually a node in the real DOM. Observe the real DOM parent instead.

            const maybeShadyRoot = parentToObserve;

            if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
              parentToObserve = maybeShadyRoot.host;
            }

            mo.observe(parentToObserve, {
              childList: true
            });
          }
        }
        /**
         * Handles newly added/removed nodes by toggling their inertness.
         * It also checks if the current top Blocking Element has been removed,
         * notifying and removing it.
         */


        [_handleMutations](mutations) {
          const parents = this[_topElParents];
          const toKeepInert = this[_alreadyInertElements];

          for (const mutation of mutations) {
            // If the target is a shadowRoot, get its host as we skip shadowRoots when
            // computing _topElParents.
            const target = mutation.target.host || mutation.target;
            const idx = target === document.body ? parents.length : parents.indexOf(target);
            const inertedChild = parents[idx - 1];
            const inertedSiblings = inertedChild[_siblingsToRestore]; // To restore.

            for (let i = 0; i < mutation.removedNodes.length; i++) {
              const sibling = mutation.removedNodes[i];

              if (sibling === inertedChild) {
                console.info('Detected removal of the top Blocking Element.');
                this.pop();
                return;
              }

              if (inertedSiblings.has(sibling)) {
                sibling.inert = false;
                inertedSiblings.delete(sibling);
              }
            } // To inert.


            for (let i = 0; i < mutation.addedNodes.length; i++) {
              const sibling = mutation.addedNodes[i];

              if (!this[_isInertable](sibling)) {
                continue;
              }

              if (toKeepInert && sibling.inert) {
                toKeepInert.add(sibling);
              } else {
                sibling.inert = true;
                inertedSiblings.add(sibling);
              }
            }
          }
        }
        /**
         * Returns if the element is inertable.
         */


        [_isInertable](element) {
          return false === /^(style|template|script)$/.test(element.localName);
        }
        /**
         * Returns the list of newParents of an element, starting from element
         * (included) up to `document.body` (excluded).
         */


        [_getParents](element) {
          const parents = [];
          let current = element; // Stop to body.

          while (current && current !== document.body) {
            // Skip shadow roots.
            if (current.nodeType === Node.ELEMENT_NODE) {
              parents.push(current);
            } // ShadowDom v1


            if (current.assignedSlot) {
              // Collect slots from deepest slot to top.
              while (current = current.assignedSlot) {
                parents.push(current);
              } // Continue the search on the top slot.


              current = parents.pop();
              continue;
            }

            current = current.parentNode || current.host;
          }

          return parents;
        }
        /**
         * Returns the distributed children of the element's shadow root.
         * Returns null if the element doesn't have a shadow root.
         */


        [_getDistributedChildren](element) {
          const shadowRoot = element.shadowRoot;

          if (!shadowRoot) {
            return null;
          }

          const result = new Set();
          let i;
          let j;
          let nodes;
          const slots = shadowRoot.querySelectorAll('slot');

          if (slots.length && slots[0].assignedNodes) {
            for (i = 0; i < slots.length; i++) {
              nodes = slots[i].assignedNodes({
                flatten: true
              });

              for (j = 0; j < nodes.length; j++) {
                if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                  result.add(nodes[j]);
                }
              }
            } // No need to search for <content>.

          }

          return result;
        }

      }

      document.$blockingElements = new BlockingElementsImpl();
    })();

    function blockingElements() {
      return getDocument$6().$blockingElements;
    }
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */


    function useBlockingElement(enabled, getTarget) {
      const stableGetTarget = useStableCallback(getTarget);
      /**
       * Push/pop the element from the blockingElements stack.
       */

      _(() => {
        const target = stableGetTarget();

        if (enabled) {
          // Sometimes blockingElements will fail if, for example,
          // the target element isn't connected to document.body.
          // This is rare, but it's better to fail silently with weird tabbing behavior
          // than to crash the entire application.
          try {
            blockingElements().push(target);
            return () => {
              blockingElements().remove(target);
            };
          } catch (ex) {
            // Well, semi-silently.
            console.error(ex);
          }
        }
      }, [enabled]);
    }
    function getTopElement() {
      return blockingElements().top;
    }

    const elementsToRestoreFocusTo = new Map();
    function useFocusTrap(_ref) {
      let {
        trapActive
      } = _ref;
      const handleActiveChange = q$1((trapActive, element) => {
        if (trapActive && element) {
          let rafHandle = requestAnimationFrame(() => {
            // TODO: This extra queueMicrotask is needed for
            // ...reasons?
            queueMicrotask(() => {
              var _findFirstFocusable;

              (_findFirstFocusable = findFirstFocusable(element)) === null || _findFirstFocusable === void 0 ? void 0 : _findFirstFocusable.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        } else if (element) {
          // Restore the focus to the element
          // that has returned to the top of the stack
          let rafHandle = requestAnimationFrame(() => {
            queueMicrotask(() => {
              var _elementsToRestoreFoc;

              (_elementsToRestoreFoc = elementsToRestoreFocusTo.get(getTopElement())) === null || _elementsToRestoreFoc === void 0 ? void 0 : _elementsToRestoreFoc.focus();
              rafHandle = 0;
            });
          });
          return () => {
            if (rafHandle) cancelAnimationFrame(rafHandle);
          };
        }
      }, []);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: useStableCallback(element => handleActiveChange(trapActive, element))
      });
      const {
        getLastActiveElement
      } = useActiveElement({
        getDocument: useStableCallback(() => {
          var _getElement;

          return (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.ownerDocument;
        })
      }); // When the trap becomes active, before we let the blockingElements hook run,
      // keep track of whatever's currently focused and save it.

      _(() => {
        const element = getElement();

        if (trapActive && element) {
          var _getLastActiveElement;

          const document = getDocument$6(element); // Save the currently focused element
          // to whatever's currently at the top of the stack

          elementsToRestoreFocusTo.set(getTopElement(), (_getLastActiveElement = getLastActiveElement()) !== null && _getLastActiveElement !== void 0 ? _getLastActiveElement : document.body);
        }
      }, [trapActive]);
      useBlockingElement(trapActive, getElement);
      /**
       * Any time we activate or deactivate the trap,
       * change focus to something else (something in
       * the trap if it's active, or whatever we've
       * tracked in elementsToRestoreFocusTo if not)
       */

      _(() => {
        handleActiveChange(trapActive, getElement());
      }, [trapActive]);

      const useFocusTrapProps = props => {
        const p1 = useRefElementProps(props);
        const p2 = {
          "aria-modal": trapActive ? "true" : undefined
        };
        return useMergedProps(p1, p2);
      };

      return {
        useFocusTrapProps,
        getElement
      };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */

    function findFirstFocusable(element) {
      const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
        acceptNode: node => node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      });
      const firstFocusable = treeWalker.firstChild();
      return firstFocusable;
    }

    /**
     * Returns a function that will, when called, force the component
     * that uses this hook to re-render itself.
     *
     * It's a bit smelly, so best to use sparingly.
     */

    function useForceUpdate() {
      const [, set] = y(0);
      return A(() => set(i => ++i)).current;
    }

    function useHasFocus(_ref) {
      let {
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onLastActiveElementChange,
        onActiveElementChange,
        onWindowFocusedChange,
        getDocument,
        getWindow,
        onElementChange,
        onMount,
        onUnmount
      } = _ref;
      useEnsureStability("useHasFocus", onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange);
      const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse$1);
      const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse$1);
      const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse$1);
      const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse$1);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange,
        onMount,
        onUnmount
      });
      const {
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      } = useActiveElement({
        getDocument,
        getWindow,
        onActiveElementChange: q$1((activeElement, prevActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == activeElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(activeElement));
          setFocused(focused);
          setFocusedInner(focusedInner);
          onActiveElementChange === null || onActiveElementChange === void 0 ? void 0 : onActiveElementChange(activeElement, prevActiveElement);
        }, []),
        onLastActiveElementChange: q$1((lastActiveElement, prevLastActiveElement) => {
          const selfElement = getElement();
          const focused = selfElement != null && selfElement == lastActiveElement;
          const focusedInner = !!(selfElement !== null && selfElement !== void 0 && selfElement.contains(lastActiveElement));
          setLastFocused(focused);
          setLastFocusedInner(focusedInner);
          onLastActiveElementChange === null || onLastActiveElementChange === void 0 ? void 0 : onLastActiveElementChange(lastActiveElement, prevLastActiveElement);
        }, []),
        onWindowFocusedChange
      });
      const useHasFocusProps = q$1(props => {
        return useRefElementProps(props);
      }, []);
      return {
        useHasFocusProps,
        getElement,
        getFocused,
        getFocusedInner,
        getLastFocused,
        getLastFocusedInner,
        getActiveElement,
        getLastActiveElement,
        getWindowFocused
      };
    }
    function useChildrenHaveFocus(_ref2) {
      let {
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref2;
      const {
        managedChildren,
        useManagedChild
      } = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      const allElementsRef = A(new Set());
      const [_getFocusCount, setFocusCount] = usePassiveState(useStableCallback((anyFocused, anyPreviouslyFocused) => {
        console.log(`Changing focus count from ${anyPreviouslyFocused} to ${anyFocused}`);
        console.assert(anyFocused >= 0 && anyFocused <= 1);
        if (anyFocused && !anyPreviouslyFocused) onAnyGainedFocus === null || onAnyGainedFocus === void 0 ? void 0 : onAnyGainedFocus();
        if (!anyFocused && anyPreviouslyFocused) onAllLostFocus === null || onAllLostFocus === void 0 ? void 0 : onAllLostFocus();
      }));
      const useChildrenHaveFocusChild = q$1(_ref3 => {
        let {
          onElementChange,
          onMount,
          onUnmount,
          getDocument,
          getWindow,
          onActiveElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onWindowFocusedChange,
          managedChild: {
            index,
            flags
          }
        } = _ref3;
        useManagedChild({
          managedChild: {
            index,
            subInfo: {},
            flags
          }
        });
        const {
          useHasFocusProps,
          ...hasFocus
        } = useHasFocus({
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange: q$1((e, prev) => {
            let r = onElementChange === null || onElementChange === void 0 ? void 0 : onElementChange(e, prev);

            if (e) {
              allElementsRef.current.add(e);
              return () => {
                r === null || r === void 0 ? void 0 : r();
                allElementsRef.current.delete(e);
              };
            }
          }, [onElementChange]),
          onMount,
          onUnmount,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged: useStableCallback((focused, prev) => {
            if (focused) {
              console.log(`Child ${index} is focused`);
              setFocusCount(p => (p !== null && p !== void 0 ? p : 0) + 1);
            } else if (!focused && prev) {
              console.log(`Child ${index} is unfocused`);
              setFocusCount(p => (p !== null && p !== void 0 ? p : 0) - 1);
            }

            onLastFocusedInnerChanged === null || onLastFocusedInnerChanged === void 0 ? void 0 : onLastFocusedInnerChanged(focused, prev);
          }),
          onWindowFocusedChange
        });
        return {
          useChildrenHaveFocusChildProps: useHasFocusProps,
          ...hasFocus
        };
      }, []);
      return {
        managedChildren,
        useChildrenHaveFocusChild
      };
    }

    /**
     * Adds the necessary event handlers to create a "press"-like event for
     * any element, whether it's a native <BUTTON> or regular <DIV>.
     *
     * Notably, the following cases are covered:
     * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
     * * Double-clicks won't select text.
     * * Conversely, manually selecting text won't invoke a press.
     * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
     * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClickSync
     * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
     */

    function usePress(onClickSync, exclude) {
      const {
        useRefElementProps,
        getElement
      } = useRefElement({}); // A button can be activated in multiple ways, so on the off chance
      // that multiple are triggered at once, we only *actually* register
      // a press once all of our "on" signals have turned back to "off".
      // We approximate this by just incrementing when active, and
      // decrementing when deactivated.
      //
      // As an emergency failsafe, when the element loses focus,
      // this is reset back to 0.

      const [active, setActive, getActive] = useState(0);
      const forceUpdate = useForceUpdate(); // If we the current text selection changes to include this element
      // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
      // because its only purpose was selecting text, not clicking buttons.
      //
      // To catch this, any time the text selection includes us while in the middle
      // of a click, this flag is set, which cancels the activation of a press.
      // The flag is reset any time the selection is empty or the button is
      // no longer active.

      const [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
      const pseudoActive = active && textSelectedDuringActivationStartTime == null;
      useGlobalHandler(document, "selectionchange", _ => {
        setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
      });
      s(() => {
        if (active == 0) setTextSelectedDuringActivationStartTime(null);
      }, [active == 0]);
      const onActiveStart = useStableCallback(_ => {
        setActive(a => ++a);
      });
      const onActiveStop = useStableCallback(e => {
        setActive(a => Math.max(0, --a));
        const currentTime = new Date();
        const timeDifference = textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime;
        const charactersSelected = nodeSelectedTextLength(getElement()); // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
        // then this isn't a press event.
        // TODO: This should measure glyphs instead of characters.

        if (charactersSelected > 1 || (timeDifference !== null && timeDifference !== void 0 ? timeDifference : 0) > 250 && charactersSelected >= 1) {
          e.preventDefault();
          return;
        }

        if (getActive() <= 0) {
          handlePress(e);
          forceUpdate(); // TODO: Remove when issue resolved https://github.com/preactjs/preact/issues/3731
        }
      });
      const handlePress = useStableCallback(e => {
        if (onClickSync) {
          // Note: The element is focused here because of iOS Safari.
          //
          // It's always iOS Safari.
          //
          // iOS Safari (tested on 12) downright refuses to allow 
          // elements to be manually focused UNLESS it happens within
          // an event handler like this.  It also doesn't focus
          // buttons by default when clicked, tapped, etc.
          //
          // If it becomes problematic that button-likes explicitly become
          // focused when they are pressed, then an alternative solution for
          // the question of "how do menu buttons keep their menus open"
          // and other focus-related nonsense needs to be figured out.
          //
          // For iOS Safari.
          //
          const element = getElement();
          if (element && "focus" in element) element === null || element === void 0 ? void 0 : element.focus(); // Whatever the browser was going to do with this event,
          // forget it. We're turning it into a "press" event.

          e.preventDefault(); // Also stop anyone else from listening to this event,
          // since we're explicitly handling it.
          // (Notably, this allows labels to wrap inputs, with them
          // both having press event handlers, without double-firing)

          e.stopPropagation(); // Haptic feedback for this press event

          try {
            // The default implementation doesn't throw,
            // but we should guard against user implementations that could.
            pulse();
          } finally {
            // Actually call our handler.
            onClickSync(e);
          }
        }
      });
      const onMouseDown = excludes("click", exclude) ? undefined : e => {
        // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
        // but also don't prevent the user from selecting that text manually if they really want to
        // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
        if (e.detail > 1) e.preventDefault();
        if (e.button === 0) onActiveStart(e);
      };
      const onMouseUp = excludes("click", exclude) ? undefined : e => {
        if (e.button === 0 && active > 0) onActiveStop(e);
      };

      const onBlur = _ => {
        setActive(0);
      };

      const onMouseLeave = excludes("click", exclude) ? undefined : onBlur;
      const onKeyDown = excludes("space", exclude) && excludes("enter", exclude) ? undefined : e => {
        if (e.key == " " && onClickSync && !excludes("space", exclude)) {
          // We don't actually activate it on a space keydown
          // but we do preventDefault to stop the page from scrolling.
          onActiveStart(e);
          e.preventDefault();
        }

        if (e.key == "Enter" && !excludes("enter", exclude)) {
          e.preventDefault();
          onActiveStart(e);
          onActiveStop(e);
        }
      };
      const onKeyUp = excludes("space", exclude) ? undefined : e => {
        if (e.key == " " && !excludes("space", exclude)) onActiveStop(e);
      };

      const onClick = e => {
        e.preventDefault();

        if (e.detail > 1) {
          e.stopImmediatePropagation();
          e.stopPropagation();
        }
      };

      return function usePressProps(props) {
        return useMergedProps(props, useRefElementProps({
          onKeyDown,
          onKeyUp,
          onBlur,
          onMouseDown,
          onMouseUp,
          onMouseLeave,
          onClick,
          style: textSelectedDuringActivationStartTime != null ? {
            cursor: "text"
          } : undefined,
          ...{
            "data-pseudo-active": pseudoActive ? "true" : undefined
          }
        }));
      };
    }
    /**
     * selection.containsNode doesn't account for selection.isCollapsed,
     * so here's a workaround for that.
     *
     * We also only look for the selection end to only catch the
     * essense of a non-existant "selectionstop" event.
     *
     * @param element
     * @returns
     */

    function nodeSelectedTextLength(element) {
      if (element && element instanceof Node) {
        const selection = window.getSelection();

        for (let i = 0; i < ((_selection$rangeCount = selection === null || selection === void 0 ? void 0 : selection.rangeCount) !== null && _selection$rangeCount !== void 0 ? _selection$rangeCount : 0); ++i) {
          var _selection$rangeCount;

          const range = selection.getRangeAt(i);

          if (element.contains(range.endContainer) && !(selection !== null && selection !== void 0 && selection.isCollapsed)) {
            return selection.toString().length;
          }
        }
      }

      return 0;
    }

    let pulse = "vibrate" in navigator && navigator.vibrate instanceof Function ? () => navigator.vibrate(10) : () => {};

    function excludes(target, exclude) {
      if (exclude !== null && exclude !== void 0 && exclude[target]) return true;
      return false;
    }

    function capitalize(str) {
      return str[0].toUpperCase() + str.substring(1);
    }
    /**
     * Inspects the element's style and determines the logical direction that text flows.
     *
     * Certain CSS properties, like `block-size`, respect the current writing mode and text direction.
     * But `transform`, `clip`, etc. don't.
     *
     * This is provided so that CSS properties can consistently use those logical properties.
     *
     * See https://drafts.csswg.org/css-writing-modes/#logical-to-physical
     *
     * @returns An object containing the following functions:
     * * `getLogicalDirection`: retrieves a `LogicalDirectionInfo` representing the current state of the element. (Function is constant between renders)
     * * `convertElementSize`: When used in conjunction with `useElementSize`, allows you to retrieve the logical size of an element instead of the physical size.
     * * `convertToLogicalOrientation`: Based on the current direction, converts "horizontal" or "vertical" to "inline" or "block".
     * * `convertToPhysicalOrientation`:  Based on the current direction, converts "inline" or "block" to "horizontal" or "vertical".
     */


    function useLogicalDirection(_ref) {
      let {
        onLogicalDirectionChange
      } = _ref;
      useEnsureStability("useLogicalDirection", onLogicalDirectionChange);
      const [getComputedStyles, setComputedStyles] = usePassiveState(null, returnNull);
      const {
        getElement,
        useRefElementProps
      } = useRefElement({
        onElementChange: q$1(element => {
          if (element) {
            setComputedStyles(window.getComputedStyle(element));
          }
        }, [])
      }); // TODO: There's no way to refresh which writing mode we have once mounted.
      //   A. There's no way to watch for CSS style changes
      //   B. Calling getComputedStyle after every render for every element gets expensive fast and
      //   C. Is not necessary for most use cases that will never switch writing-mode within a single component
      //      (Those that do will need to mount and unmount the component that uses it)
      //
      // As a solution, here's a cheap workaround that checks when the element's size has changed,
      // and if so, tests if the writing mode has changed too.
      //
      // This will work for at least some number of cases, but a better solution is still needed.

      const {
        useElementSizeProps
      } = useElementSize({
        onSizeChange: q$1(_ => onLogicalDirectionChange === null || onLogicalDirectionChange === void 0 ? void 0 : onLogicalDirectionChange(getLogicalDirectionInfo()), [])
      });
      const getLogicalDirectionInfo = q$1(() => {
        const computedStyles = getComputedStyles();

        if (computedStyles) {
          const w = computedStyles.writingMode;
          let d = computedStyles.direction;
          const t = computedStyles.textOrientation;
          if (t == "upright") d = "ltr";
          return { ...WritingModes[w || "horizontal-tb"][d || "ltr"]
          };
        }

        return null;
      }, []); //const [getLogicalDirectionInfo, setLogicalDirectionInfo] = usePassiveState<LogicalDirectionInfo>(onLogicalDirectionChange);

      const convertToLogicalOrientation = q$1((elementOrientation, direction) => {
        var _direction, _direction2;

        (_direction = direction) !== null && _direction !== void 0 ? _direction : direction = getLogicalDirectionInfo();
        if (((_direction2 = direction) === null || _direction2 === void 0 ? void 0 : _direction2.inlineOrientation) === elementOrientation) return "inline";
        return "block";
      }, []);
      const convertToPhysicalSide = q$1((side, direction) => {
        var _direction3, _direction$blockDirec, _direction4, _direction$blockDirec2, _direction5, _direction$inlineDire, _direction6, _direction$inlineDire2, _direction7;

        (_direction3 = direction) !== null && _direction3 !== void 0 ? _direction3 : direction = getLogicalDirectionInfo();

        switch (side) {
          case "block-start":
            return M$1[((_direction$blockDirec = (_direction4 = direction) === null || _direction4 === void 0 ? void 0 : _direction4.blockDirection) !== null && _direction$blockDirec !== void 0 ? _direction$blockDirec : "ttb")[0]];

          case "block-end":
            return M$1[((_direction$blockDirec2 = (_direction5 = direction) === null || _direction5 === void 0 ? void 0 : _direction5.blockDirection) !== null && _direction$blockDirec2 !== void 0 ? _direction$blockDirec2 : "ttb")[2]];

          case "inline-start":
            return M$1[((_direction$inlineDire = (_direction6 = direction) === null || _direction6 === void 0 ? void 0 : _direction6.inlineDirection) !== null && _direction$inlineDire !== void 0 ? _direction$inlineDire : "ltr")[0]];

          case "inline-end":
            return M$1[((_direction$inlineDire2 = (_direction7 = direction) === null || _direction7 === void 0 ? void 0 : _direction7.inlineDirection) !== null && _direction$inlineDire2 !== void 0 ? _direction$inlineDire2 : "ltr")[2]];
        }
      }, []);
      const convertToLogicalSide = q$1((side, direction) => {
        var _direction8, _direction9, _direction10;

        (_direction8 = direction) !== null && _direction8 !== void 0 ? _direction8 : direction = getLogicalDirectionInfo();

        if (((_direction9 = direction) === null || _direction9 === void 0 ? void 0 : _direction9.inlineOrientation) === "vertical") {
          switch (side) {
            case "top":
              return direction.inlineDirection === "ttb" ? "inline-start" : "inline-end";

            case "bottom":
              return direction.inlineDirection === "btt" ? "inline-start" : "inline-end";

            case "left":
              return direction.blockDirection === "ltr" ? "block-start" : "block-end";

            case "right":
              return direction.blockDirection === "rtl" ? "block-start" : "block-end";
          }
        } else if (((_direction10 = direction) === null || _direction10 === void 0 ? void 0 : _direction10.inlineOrientation) === "horizontal") {
          switch (side) {
            case "top":
              return direction.blockDirection === "ttb" ? "block-start" : "block-end";

            case "bottom":
              return direction.blockDirection === "btt" ? "block-start" : "block-end";

            case "left":
              return direction.inlineDirection === "ltr" ? "inline-start" : "inline-end";

            case "right":
              return direction.inlineDirection === "rtl" ? "inline-start" : "inline-end";
          }
        }
        /* eslint-disable no-debugger */


        debugger;
        console.assert(false);
        return "inline-start";
      }, []);
      const convertToPhysicalOrientation = q$1((elementOrientation, direction) => {
        var _direction11;

        (_direction11 = direction) !== null && _direction11 !== void 0 ? _direction11 : direction = getLogicalDirectionInfo();

        if (elementOrientation == "inline") {
          var _direction12;

          if (((_direction12 = direction) === null || _direction12 === void 0 ? void 0 : _direction12.inlineOrientation) == "horizontal") return "horizontal";
          return "vertical";
        } else {
          var _direction13;

          if (((_direction13 = direction) === null || _direction13 === void 0 ? void 0 : _direction13.blockOrientation) == "vertical") return "vertical";
          return "horizontal";
        }
      }, []);
      const convertElementSize = q$1((elementSize, direction) => {
        var _direction14;

        (_direction14 = direction) !== null && _direction14 !== void 0 ? _direction14 : direction = getLogicalDirectionInfo();

        if (direction) {
          const {
            inlineSize,
            blockSize,
            inlineDirection,
            blockDirection
          } = direction; // Size is relatively simple

          const clientInlineSize = elementSize[`client${capitalize(inlineSize)}`];
          const clientBlockSize = elementSize[`client${capitalize(blockSize)}`];
          const offsetInlineSize = elementSize[`offset${capitalize(inlineSize)}`];
          const offsetBlockSize = elementSize[`offset${capitalize(blockSize)}`];
          const scrollInlineSize = elementSize[`scroll${capitalize(inlineSize)}`];
          const scrollBlockSize = elementSize[`scroll${capitalize(blockSize)}`];
          const f1 = getPhysicalLeftTop(inlineDirection);
          const f2 = getPhysicalRightBottom(inlineDirection);
          const f3 = getPhysicalLeftTop(blockDirection);
          const f4 = getPhysicalRightBottom(blockDirection);
          const clientInlineInset = elementSize[`client${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`client${capitalize(f2)}`]);
          const scrollInlineInset = elementSize[`scroll${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`scroll${capitalize(f2)}`]);
          const offsetInlineInset = elementSize[`offset${capitalize(f1)}`] == undefined ? undefined : elementSize[`offset${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`offset${capitalize(f2)}`]);
          const clientBlockInset = elementSize[`client${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`client${capitalize(f4)}`]);
          const scrollBlockInset = elementSize[`scroll${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`scroll${capitalize(f4)}`]);
          const offsetBlockInset = elementSize[`offset${capitalize(f3)}`] == undefined ? undefined : elementSize[`offset${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`offset${capitalize(f4)}`]);
          return {
            clientInlineSize,
            scrollInlineSize,
            offsetInlineSize,
            clientBlockSize,
            scrollBlockSize,
            offsetBlockSize,
            clientInlineInset,
            scrollInlineInset,
            offsetInlineInset,
            clientBlockInset,
            scrollBlockInset,
            offsetBlockInset
          };
        }

        return null;
      }, []);
      return {
        useLogicalDirectionProps: q$1(props => useRefElementProps(useElementSizeProps(props)), []),
        getElement,
        getLogicalDirectionInfo,
        convertToLogicalSize: convertElementSize,
        convertToLogicalOrientation,
        convertToPhysicalOrientation,
        convertToLogicalSide,
        convertToPhysicalSide
      };
    } // Position requires us to sometimes use one property (like `left`)
    // or sometimes two (like `left` + `width`)

    function getPhysicalLeftTop(dir) {
      if (dir === "ltr" || dir == "rtl") return "left";
      return "top";
    }

    function getPhysicalRightBottom(dir) {
      if (dir === "rtl") return "width";
      if (dir === "btt") return "height";
      return null;
    } // Helper for extracting info from "ltr", "ttb", etc.


    const M$1 = {
      t: "top",
      b: "bottom",
      l: "left",
      r: "right"
    };
    const HorizontalTbLtr = {
      inlineDirection: "ltr",
      blockDirection: "ttb",
      inlineOrientation: "horizontal",
      blockOrientation: "vertical",
      inlineSize: "width",
      blockSize: "height",
      leftRightDirection: "ltr",
      overUnderDirection: "ttb"
    };
    const HorizontalTbRtl = { ...HorizontalTbLtr,
      inlineDirection: "rtl"
    };
    const VerticalRlLtr = {
      inlineDirection: "ttb",
      blockDirection: "rtl",
      inlineOrientation: "vertical",
      blockOrientation: "horizontal",
      inlineSize: "height",
      blockSize: "width",
      leftRightDirection: "ttb",
      overUnderDirection: "rtl"
    };
    const VerticalRlRtl = { ...VerticalRlLtr,
      inlineDirection: "btt"
    };
    const SidewaysRlLtr = { ...VerticalRlLtr
    };
    const SidewaysRlRtl = { ...VerticalRlRtl
    };
    const VerticalLrLtr = { ...VerticalRlLtr,
      blockDirection: "ltr"
    };
    const VerticalLrRtl = { ...VerticalRlRtl,
      blockDirection: "ltr"
    };
    const SidewaysLtLtr = { ...VerticalLrLtr,
      inlineDirection: "btt",
      leftRightDirection: "btt",
      overUnderDirection: "ltr"
    };
    const SidewaysLtRtl = { ...SidewaysLtLtr,
      inlineDirection: "ttb"
    };
    const HorizontalTb = {
      ltr: HorizontalTbLtr,
      rtl: HorizontalTbRtl
    };
    const VerticalRl = {
      ltr: VerticalRlLtr,
      rtl: VerticalRlRtl
    };
    const VerticalLr = {
      ltr: VerticalLrLtr,
      rtl: VerticalLrRtl
    };
    const SidewaysRl = {
      ltr: SidewaysRlLtr,
      rtl: SidewaysRlRtl
    };
    const SidewaysLr = {
      ltr: SidewaysLtLtr,
      rtl: SidewaysLtRtl
    };
    const WritingModes = {
      "horizontal-tb": HorizontalTb,
      "vertical-lr": VerticalLr,
      "vertical-rl": VerticalRl,
      "sideways-lr": SidewaysLr,
      "sideways-rl": SidewaysRl
    };

    function useTimeout(_ref) {
      let {
        timeout,
        callback,
        triggerIndex
      } = _ref;
      const stableCallback = useStableCallback(() => {
        startTimeRef.current = null;
        callback();
      });
      const getTimeout = useStableGetter(timeout); // Set any time we start timeout.
      // Unset any time the timeout completes

      const startTimeRef = A(null);
      const timeoutIsNull = timeout == null; // Any time the triggerIndex changes (including on mount)
      // restart the timeout.  The timeout does NOT reset
      // when the duration or callback changes, only triggerIndex.

      s(() => {
        if (!timeoutIsNull) {
          const timeout = getTimeout();
          console.assert(timeoutIsNull == (timeout == null));

          if (timeout != null) {
            startTimeRef.current = +new Date();
            const handle = setTimeout(stableCallback, timeout);
            return () => clearTimeout(handle);
          }
        }
      }, [triggerIndex, timeoutIsNull]);
      const getElapsedTime = q$1(() => {
        var _startTimeRef$current;

        return +new Date() - +((_startTimeRef$current = startTimeRef.current) !== null && _startTimeRef$current !== void 0 ? _startTimeRef$current : new Date());
      }, []);
      const getRemainingTime = q$1(() => {
        const timeout = getTimeout();
        return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
      }, []);
      return {
        getElapsedTime,
        getRemainingTime
      };
    }

    /** Arguments passed to the child 'useLinearNavigationChild` */
    //export interface UseLinearNavigationChildInfo { }

    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useLinearNavigation(_ref) {
      var _nd;

      let {
        linearNavigation: {
          navigateToFirst: ntf,
          navigateToLast: ntl,
          navigateToNext: ntn,
          navigateToPrev: ntp,
          navigationDirection: nd,
          disableArrowKeys: dak,
          disableHomeEndKeys: dhek
        }
      } = _ref;
      (_nd = nd) !== null && _nd !== void 0 ? _nd : nd = "either";
      const {
        getLogicalDirectionInfo,
        useLogicalDirectionProps
      } = useLogicalDirection({});
      const navigateToFirst = useStableCallback(ntf);
      const navigateToLast = useStableCallback(ntl);
      const navigateToNext = useStableCallback(ntn);
      const navigateToPrev = useStableCallback(ntp);
      const getDisableArrowKeys = useStableGetter(dak);
      const getDisableHomeEndKeys = useStableGetter(dhek);
      const getNavigationDirection = useStableGetter(nd);
      return {
        linearNavigation: {},
        useLinearNavigationProps: q$1(props => {
          const onKeyDown = e => {
            // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
            if (e.ctrlKey || e.metaKey) return;
            const info = getLogicalDirectionInfo();
            const navigationDirection = getNavigationDirection();
            const disableArrowKeys = getDisableArrowKeys();
            const disableHomeEndKeys = getDisableHomeEndKeys();
            const allowsBlockNavigation = navigationDirection == "block" || navigationDirection == "either";
            const allowsInlineNavigation = navigationDirection == "inline" || navigationDirection == "either";

            switch (e.key) {
              case "ArrowUp":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowDown":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? "blockDirection" : "inlineDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.blockOrientation) === "vertical" ? allowsBlockNavigation : allowsInlineNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "btt") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowLeft":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "rtl") {
                      navigateToNext();
                    } else {
                      navigateToPrev();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  break;
                }

              case "ArrowRight":
                {
                  const propName = (info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? "inlineDirection" : "blockDirection";
                  const directionAllowed = !disableArrowKeys && ((info === null || info === void 0 ? void 0 : info.inlineOrientation) === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation);

                  if (directionAllowed) {
                    if ((info === null || info === void 0 ? void 0 : info[propName]) === "rtl") {
                      navigateToPrev();
                    } else {
                      navigateToNext();
                    }

                    e.preventDefault();
                    e.stopPropagation();
                  }

                  e.preventDefault();
                  e.stopPropagation();
                  break;
                }

              case "Home":
                if (!disableHomeEndKeys) {
                  navigateToFirst();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;

              case "End":
                if (!disableHomeEndKeys) {
                  navigateToLast();
                  e.preventDefault();
                  e.stopPropagation();
                }

                break;
            }
          };

          return useLogicalDirectionProps(useMergedProps({
            onKeyDown
          }, props));
        }, [])
      };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */

    function useTypeaheadNavigation(_ref2) {
      let {
        typeaheadNavigation: {
          collator,
          getIndex,
          typeaheadTimeout,
          setIndex,
          noTypeahead
        }
      } = _ref2;
      // For typeahead, keep track of what our current "search" string is (if we have one)
      // and also clear it every 1000 ms since the last time it changed.
      // Next, keep a mapping of typeahead values to indices for faster searching.
      // And, for the user's sake, let them know when their typeahead can't match anything anymore
      const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
      useTimeout({
        timeout: typeaheadTimeout !== null && typeaheadTimeout !== void 0 ? typeaheadTimeout : 1000,
        callback: () => {
          setCurrentTypeahead(null);
          setInvalidTypeahead(null);
        },
        triggerIndex: currentTypeahead
      });
      const sortedTypeaheadInfo = A([]);
      const [invalidTypeahead, setInvalidTypeahead] = useState(false); // Handle typeahead for input method editors as well
      // Essentially, when active, ignore further keys 
      // because we're waiting for a CompositionEnd event

      const [, setImeActive, getImeActive] = useState(false); // Because composition events fire *after* keydown events 
      // (but within the same task, which, TODO, could be browser-dependent),
      // we can use this to keep track of which event we're listening for on the first keydown.

      const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
      _(() => {
        if (nextTypeaheadChar !== null) {
          setCurrentTypeahead(typeahead => (typeahead !== null && typeahead !== void 0 ? typeahead : "") + nextTypeaheadChar);
          setNextTypeaheadChar(null);
        }
      }, [nextTypeaheadChar]);
      const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
        var _safeRhs$toLowerCase;

        let compare; // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
        // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.

        safeLhs = safeLhs.normalize("NFD");
        safeRhs = safeRhs.normalize("NFD");
        if (collator) compare = collator.compare(safeLhs, safeRhs);else compare = safeLhs.toLowerCase().localeCompare((_safeRhs$toLowerCase = safeRhs.toLowerCase()) !== null && _safeRhs$toLowerCase !== void 0 ? _safeRhs$toLowerCase : "");
        return compare;
      });
      const insertingComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          return comparatorShared(lhs, rhs.text);
        }

        return lhs - rhs;
      });
      const typeaheadComparator = useStableCallback((lhs, rhs) => {
        if (typeof lhs === "string" && typeof rhs.text === "string") {
          // During typeahead, all strings longer than ours should be truncated
          // so that they're all considered equally by that point.
          return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
        }

        return lhs - rhs;
      });
      const isDisabled = useStableGetter(noTypeahead);
      const useTypeaheadNavigationProps = q$1(function (_ref3) {
        let { ...props
        } = _ref3;

        const onCompositionStart = _e => {
          setImeActive(true);
        };

        const onCompositionEnd = e => {
          setNextTypeaheadChar(e.data);
          setImeActive(false);
        };

        const onKeyDown = e => {
          if (isDisabled()) return;
          const imeActive = getImeActive();
          const key = e.key; // Not handled by typeahead (i.e. assume this is a keyboard shortcut)

          if (e.ctrlKey || e.metaKey) return;

          if (!imeActive && e.key === "Backspace") {
            // Remove the last character in a way that doesn't split UTF-16 surrogates.
            setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
            e.preventDefault();
            e.stopPropagation();
            return;
          } // The key property represents the typed character OR the "named key attribute" of the key pressed.
          // There's no definite way to tell the difference, but for all intents and purposes
          // there are no one-character names, and there are no non-ASCII-alpha names.
          // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.


          const isCharacterKey = key.length === 1 || !/^[A-Za-z]/.test(key);

          if (isCharacterKey) {
            var _getCurrentTypeahead;

            if (key == " " && ((_getCurrentTypeahead = getCurrentTypeahead()) !== null && _getCurrentTypeahead !== void 0 ? _getCurrentTypeahead : "").trim().length == 0) ; else {
              e.preventDefault();
              e.stopPropagation(); // Note: Won't be true for the first keydown
              // but will be overwritten before useLayoutEffect is called
              // to actually apply the change

              if (!imeActive) setNextTypeaheadChar(key);
            }
          }
        };

        return useMergedProps({
          onKeyDown,
          onCompositionStart,
          onCompositionEnd
        }, props);
      }, []); // Handle changes in typeahead that cause changes to the tabbable index

      s(() => {
        if (currentTypeahead && sortedTypeaheadInfo.current.length) {
          const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);

          if (sortedTypeaheadIndex < 0) {
            // The user has typed an entry that doesn't exist in the list
            // (or more specifically "for which there is no entry that starts with that input")
            setInvalidTypeahead(true);
          } else {
            setInvalidTypeahead(false);
            /*
              We know roughly where, in the sorted array of strings, our next typeahead location is.
              But roughly isn't good enough if there are multiple matches.
              To convert our sorted index to the unsorted index we need, we have to find the first
              element that matches us *and* (if any such exist) is *after* our current selection.
               In other words, the only way typeahead moves backwards relative to our current
              position is if the only other option is behind us.
               It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
              Though there's also a case for just going upwards to the nearest to prevent jumpiness.
              But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
              I dunno. Going back to the start is the simplist though.
               Basically what this does: Starting from where we found ourselves after our binary search,
              scan backwards and forwards through all adjacent entries that also compare equally so that
              we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
              (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).
               TODO: The binary search starts this off with a solid O(log n), but one-character
              searches are, thanks to pigeonhole principal, eventually guaranteed to become
              O(n*log n). This is annoying but probably not easily solvable? There could be an
              exception for one-character strings, but that's just kicking the can down
              the road. Maybe one or two characters would be good enough though.
            */
            // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.

            let lowestUnsortedIndexAll = null;
            let lowestSortedIndexAll = sortedTypeaheadIndex; // These two are only set for elements that are ahead of us, but the principle's the same otherwise

            let lowestUnsortedIndexNext = null;
            let lowestSortedIndexNext = sortedTypeaheadIndex;

            const updateBestFit = u => {
              var _getIndex;

              if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                lowestUnsortedIndexAll = u;
                lowestSortedIndexAll = i;
              }

              if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > ((_getIndex = getIndex()) !== null && _getIndex !== void 0 ? _getIndex : -Infinity)) {
                lowestUnsortedIndexNext = u;
                lowestSortedIndexNext = i;
              }
            };

            let i = sortedTypeaheadIndex;

            while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              --i;
            }

            i = sortedTypeaheadIndex;

            while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
              updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
              ++i;
            }

            if (lowestUnsortedIndexNext !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);else if (lowestUnsortedIndexAll !== null) setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
          }
        }
      }, [currentTypeahead]);
      const useTypeaheadNavigationChild = q$1(_ref4 => {
        let {
          index,
          text
        } = _ref4;
        s(() => {
          if (text) {
            // Find where to insert this item.
            // Because all index values should be unique, the returned sortedIndex
            // should always refer to a new location (i.e. be negative)                
            const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
            console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
              unsortedIndex: index,
              text
            }) == 0);

            if (sortedIndex < 0) {
              sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, {
                text,
                unsortedIndex: index
              });
            } else {
              sortedTypeaheadInfo.current.splice(sortedIndex, 0, {
                text,
                unsortedIndex: index
              });
            }

            return () => {
              // When unmounting, find where we were and remove ourselves.
              // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
              const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
              console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, {
                unsortedIndex: index,
                text
              }) == 0);

              if (sortedIndex >= 0) {
                sortedTypeaheadInfo.current.splice(sortedIndex, 1);
              }
            };
          }
        }, [text]);
        return;
      }, []);
      return {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
      };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */

    function binarySearch(array, wanted, comparator) {
      let firstIndex = 0;
      let lastIndex = array.length - 1;

      while (firstIndex <= lastIndex) {
        const testIndex = lastIndex + firstIndex >> 1;
        const comparisonResult = comparator(wanted, array[testIndex]);

        if (comparisonResult > 0) {
          firstIndex = testIndex + 1;
        } else if (comparisonResult < 0) {
          lastIndex = testIndex - 1;
        } else {
          return testIndex;
        }
      }

      return -firstIndex - 1;
    }

    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `shouldFocusOnChange` should return true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const [focusedInner, setFocusedInner] = useState(false);
     * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */

    function useRovingTabIndex(parentParameters) {
      var _initialIndex;

      let {
        rovingTabIndex: {
          initialIndex,
          onTabbableRender,
          onTabbableIndexChange
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = parentParameters;
      (_initialIndex = initialIndex) !== null && _initialIndex !== void 0 ? _initialIndex : initialIndex = 0;
      const stableOnTabbableRender = useStableCallback(onTabbableRender !== null && onTabbableRender !== void 0 ? onTabbableRender : () => {});
      /*const [_getAnyFocused, setAnyFocused] = usePassiveState<number>(useStableCallback((newCount: number, oldCount: number | undefined) => {
          if (oldCount == 0 && newCount > 0) {
              onTabbedInTo?.();
          }
           if (newCount == 0 && (oldCount ?? 0) > 0) {
              onTabbedOutOf?.();
          }
      }), returnZero);*/
      // Keep track of three things related to the currently tabbable element's index:
      // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.

      const [getTabbableIndex, setTabbableIndex2] = usePassiveState(onTabbableIndexChange, q$1(() => {
        var _initialIndex2;

        return (_initialIndex2 = initialIndex) !== null && _initialIndex2 !== void 0 ? _initialIndex2 : 0;
      }, []));
      const setTabbableIndex = q$1((updater, fromUserInteraction) => {
        setTabbableIndex2(prevIndex => {
          let nextIndex = prevIndex;
          if (typeof updater === "function") nextIndex = updater(prevIndex !== null && prevIndex !== void 0 ? prevIndex : null);else nextIndex = updater;
          nextIndex = changeIndex(nextIndex);

          if (prevIndex != nextIndex) {
            const nextChild = nextIndex == null ? null : parentReturnType.managedChildren.children.getAt(nextIndex);
            const prevChild = prevIndex == null ? null : parentReturnType.managedChildren.children.getAt(prevIndex);
            if (prevChild != null) prevChild.subInfo.blurSelf();
            if (nextChild != null && fromUserInteraction) nextChild.subInfo.focusSelf();
          }

          return nextIndex;
        });
      }, []); // Any time the tabbable index changes,
      // notify the previous child that it's no longer tabbable,
      // and notify the next child that is allowed to be tabbed to.

      const parentReturnType = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange: useStableCallback((mounted, unmounted) => {
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(mounted, unmounted);
            reevaluateClosestFit();
          })
        }
      });
      const {
        useManagedChild
      } = parentReturnType;
      const {
        changeIndex,
        reevaluateClosestFit
      } = useChildrenFlag({
        initialIndex,
        children: parentReturnType.managedChildren.children,
        closestFit: true,
        key: "tabbable"
      });
      const useRovingTabIndexChild = q$1(childParameters => {
        const {
          subInfo,
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            hidden,
            blurSelf: blurSelfOverride,
            focusSelf: focusSelfOverride
          }
        } = childParameters;
        s(() => {
          reevaluateClosestFit();
        }, [!!hidden]);
        const bsOverride = useStableGetter(blurSelfOverride);
        const fsOverride = useStableGetter(focusSelfOverride);
        const focusSelf = q$1(() => {
          const fs = fsOverride();

          if (fs) {
            fs();
          } else {
            var _element$focus;

            const element = getElement();
            if (element) (_element$focus = element.focus) === null || _element$focus === void 0 ? void 0 : _element$focus.call(element);
          }
        }, []);
        const blurSelf = q$1(() => {
          const bs = bsOverride();

          if (bs) {
            bs();
          } else {
            var _element$blur;

            const element = getElement();
            if (element) (_element$blur = element.blur) === null || _element$blur === void 0 ? void 0 : _element$blur.call(element);
          }
        }, []);
        const onFocusedInnerChanged = useStableCallback((focused, _prevFocused) => {
          if (focused) {
            setTabbableIndex(index, true);
          }
        });
        const {
          getElement,
          useHasFocusProps
        } = useHasFocus({
          onFocusedInnerChanged,
          getDocument: q$1(() => {
            var _getElement$ownerDocu, _getElement;

            return (_getElement$ownerDocu = (_getElement = getElement()) === null || _getElement === void 0 ? void 0 : _getElement.ownerDocument) !== null && _getElement$ownerDocu !== void 0 ? _getElement$ownerDocu : window.document;
          }, [])
        });
        const [tabbable, setTabbable, getTabbable] = useState(false);
        const tabbableFlags = A({
          get: getTabbable,
          set: setTabbable,
          isValid: useStableCallback(() => !hidden)
        });

        useManagedChild({
          managedChild: {
            index,
            flags: { ...flags,
              tabbable: tabbableFlags.current
            },
            subInfo: {
              blurSelf,
              focusSelf,
              getElement,
              hidden: !!hidden,
              subInfo
            }
          }
        });

        s(() => {
          if (tabbable) stableOnTabbableRender(index);
        }, [tabbable, index]);

        function useRovingTabIndexChildProps(props) {
          console.assert(props.tabIndex == null);
          return useMergedProps(useHasFocusProps({
            tabIndex: tabbable ? 0 : -1
          }), props);
        }

        return {
          useRovingTabIndexChildProps,
          rovingTabIndex: {
            getElement,
            tabbable,
            getTabbable
          }
        };
      }, [
        /* Must remain stable */
      ]);
      const focusSelf = q$1(() => {
        var _parentReturnType$man, _parentReturnType$man2, _parentReturnType$man3;

        console.log(`useRovingTabIndex.focusSelf`);
        const index = getTabbableIndex();
        if (index != null) (_parentReturnType$man = parentReturnType.managedChildren.children.getAt(index)) === null || _parentReturnType$man === void 0 ? void 0 : (_parentReturnType$man2 = (_parentReturnType$man3 = _parentReturnType$man.subInfo).focusSelf) === null || _parentReturnType$man2 === void 0 ? void 0 : _parentReturnType$man2.call(_parentReturnType$man3);else setTabbableIndex(null, true);
      }, []);
      return {
        useRovingTabIndexChild,
        managedChildren: {
          children: parentReturnType.managedChildren.children
        },
        rovingTabIndex: {
          setTabbableIndex,
          getTabbableIndex,
          focusSelf
        }
      };
    }
    /*function test() {
        const { children, focusSelf, getTabbableIndex, setTabbableIndex, useRovingTabIndexChild, } = useRovingTabIndex<HTMLDivElement, { "foo": "bar" }, "flag2">({ managedChildren: {}, rovingTabIndex: {} });
        const { } = useRovingTabIndexChild({ managedChildren: { index: 0, flags: {} }, rti: { info3: { foo: "bar" } } });
    }*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;
      array || (array = Array(length));

      while (++index < length) {
        array[index] = source[index];
      }

      return array;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor,
        nativeRandom = Math.random;
    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */

    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */

    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;
      size = size === undefined ? length : size;

      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];
        array[rand] = array[index];
        array[index] = value;
      }

      array.length = size;
      return array;
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */

    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }

      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */

    function baseValues(object, props) {
      return arrayMap(props, function (key) {
        return object[key];
      });
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }

    /** `Object#toString` result references. */

    var argsTag$1 = '[object Arguments]';
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */

    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }

    /** Used for built-in method references. */

    var objectProto$3 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    /** Built-in value references. */

    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */

    var isArguments = baseIsArguments(function () {
      return arguments;
    }()) ? baseIsArguments : function (value) {
      return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */

    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    /** Built-in value references. */

    var Buffer = moduleExports$1 ? root.Buffer : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */

    var isBuffer = nativeIsBuffer || stubFalse;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */

    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */

    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /** Used to identify `toStringTag` values of typed arrays. */

    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */

    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */

    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        } // Legacy `process.binding('util')` for Node.js < 10.


        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    /* Node.js helper references. */

    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */

    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */

    var objectProto$2 = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
        key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */

    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$1;
      return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */

    var objectProto = Object.prototype;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */

    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }

    /** `Object#toString` result references. */

    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */

    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      } // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.


      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */

    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */

    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */

    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */

    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */

    function useRearrangeableChildren(_ref) {
      let {
        rearrangeableChildren: {
          getIndex
        }
      } = _ref;
      // These are used to keep track of a mapping between unsorted index <---> sorted index.
      // These are needed for navigation with the arrow keys.
      const mangleMap = A(new Map());
      const demangleMap = A(new Map());
      const indexMangler = q$1(n => {
        var _mangleMap$current$ge;

        return (_mangleMap$current$ge = mangleMap.current.get(n)) !== null && _mangleMap$current$ge !== void 0 ? _mangleMap$current$ge : n;
      }, []);
      const indexDemangler = q$1(n => {
        var _demangleMap$current$;

        return (_demangleMap$current$ = demangleMap.current.get(n)) !== null && _demangleMap$current$ !== void 0 ? _demangleMap$current$ : n;
      }, []); // The sort function needs to be able to update whoever has all the sortable children.
      // Because that might not be the consumer of *this* hook directly (e.g. a table uses
      // this hook, but it's tbody that actually needs updating), we need to remotely
      // get and set a forceUpdate function.
      //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);

      const [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
      const rearrange = q$1(sortedRows => {
        var _getForceUpdate;

        // Update our sorted <--> unsorted indices map 
        // and rerender the whole table, basically
        for (let indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
          const indexAsUnsorted = sortedRows[indexAsSorted].index;
          mangleMap.current.set(indexAsUnsorted, indexAsSorted);
          demangleMap.current.set(indexAsSorted, indexAsUnsorted);
        }

        (_getForceUpdate = getForceUpdate()) === null || _getForceUpdate === void 0 ? void 0 : _getForceUpdate();
      }, []);
      const useRearrangeableProps = q$1(_ref2 => {
        let {
          children,
          ...props
        } = _ref2;
        const forceUpdate = useForceUpdate();
        _(() => {
          setForceUpdate(_prev => forceUpdate);
        }, [forceUpdate]);
        return useMergedProps({
          children: children.slice().map(child => ({
            child,
            mangledIndex: indexMangler(getIndex(child.props)),
            demangledIndex: getIndex(child.props)
          })).sort((lhs, rhs) => {
            return lhs.mangledIndex - rhs.mangledIndex;
          }).map(_ref3 => {
            let {
              child,
              mangledIndex,
              demangledIndex
            } = _ref3;
            return h$1(child.type, { ...child.props,
              key: demangledIndex,
              "data-mangled-index": mangledIndex,
              "data-unmangled-index": demangledIndex
            });
          })
        }, props);
      }, []);
      return {
        useRearrangeableProps,
        rearrangeableChildren: {
          indexMangler,
          indexDemangler,
          mangleMap,
          demangleMap,
          rearrange
        }
      };
    }
    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */

    function useSortableChildren(_ref4) {
      let {
        rearrangeableChildren: {
          getIndex
        },
        sortableChildren: {
          compare: userCompare,
          getValue
        }
      } = _ref4;
      const compare = userCompare !== null && userCompare !== void 0 ? userCompare : defaultCompare;
      const {
        useRearrangeableProps: useSortableProps,
        ...rearrangeableChildrenReturnType
      } = useRearrangeableChildren({
        rearrangeableChildren: {
          getIndex
        }
      });
      const {
        rearrangeableChildren: {
          rearrange
        }
      } = rearrangeableChildrenReturnType; // The actual sort function.

      const sort = q$1(function (managedRows, direction) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        const sortedRows = managedRows.arraySlice().sort((lhsRow, rhsRow) => {
          const lhsValue = getValue(lhsRow, ...args);
          const rhsValue = getValue(rhsRow, ...args);
          const result = compare(lhsValue, rhsValue); // lhsRow.getManagedCells()?.[column]?.value, rhsRow.getManagedCells()?.[column]?.value);

          if (direction[0] == "d") return -result;
          return result;
        });
        return rearrange(sortedRows);
      }, [
        /* Must remain stable */
      ]);
      const shuffle$1 = q$1(managedRows => {
        const shuffledRows = shuffle(managedRows.arraySlice());
        return rearrange(shuffledRows);
      }, [
        /* Must remain stable */
      ]);
      return {
        useSortableProps,
        sortableChildren: {
          sort,
          shuffle: shuffle$1
        },
        rearrangeableChildren: rearrangeableChildrenReturnType.rearrangeableChildren
      };
    }

    function defaultCompare(lhs, rhs) {
      return compare1(lhs, rhs);

      function compare3(lhs, rhs) {
        // Coerce strings to numbers if they seem to stay the same when serialized
        if (`${+lhs}` === lhs) lhs = +lhs;
        if (`${+rhs}` === rhs) rhs = +rhs; // At this point, if either argument is a string, turn the other one into one too

        if (typeof lhs === "string") rhs = `${rhs}`;
        if (typeof rhs === "string") lhs = `${lhs}`;
        console.assert(typeof lhs === typeof rhs);
        if (typeof lhs === "string") return lhs.localeCompare(rhs);
        if (typeof lhs === "number") return +lhs - +rhs;
        return 0;
      }

      function compare2(lhs, rhs) {
        if (typeof lhs === "boolean" || lhs instanceof Date) lhs = +lhs;
        if (typeof rhs === "boolean" || rhs instanceof Date) rhs = +rhs;
        return compare3(lhs, rhs);
      }

      function compare1(lhs, rhs) {
        if (lhs == null && rhs == null) {
          // They're both null
          return 0;
        } else if (lhs == null || rhs == null) {
          // One of the two is null -- easy case
          return lhs != null ? 1 : -1;
        }

        return compare2(lhs, rhs);
      }
    }

    function identity(t) {
      return t;
    }
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */


    function useListNavigation(_ref) {
      var _indexMangler, _indexDemangler;

      let {
        managedChildren: mc,
        rovingTabIndex,
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        linearNavigation,
        typeaheadNavigation
      } = _ref;
      (_indexMangler = indexMangler) !== null && _indexMangler !== void 0 ? _indexMangler : indexMangler = identity;
      (_indexDemangler = indexDemangler) !== null && _indexDemangler !== void 0 ? _indexDemangler : indexDemangler = identity;
      useEnsureStability("useListNavigation", indexMangler, indexDemangler);
      const parentReturnType = useRovingTabIndex({
        managedChildren: mc,
        rovingTabIndex
      });
      const {
        useRovingTabIndexChild,
        managedChildren: {
          children
        },
        rovingTabIndex: {
          getTabbableIndex,
          setTabbableIndex
        }
      } = parentReturnType;
      const navigateToIndex = q$1((i, fromUserInteraction) => {
        if (i != null) {
          var _indexMangler2, _indexDemangler2;

          const nextIndex = tryNavigateToIndex({
            children: children,
            default: 0,
            target: i,
            searchDirection: 1,
            indexMangler: (_indexMangler2 = indexMangler) !== null && _indexMangler2 !== void 0 ? _indexMangler2 : identity,
            indexDemangler: (_indexDemangler2 = indexDemangler) !== null && _indexDemangler2 !== void 0 ? _indexDemangler2 : identity
          });
          setTabbableIndex(i == null ? null : nextIndex, fromUserInteraction);
        } else {
          setTabbableIndex(null, fromUserInteraction);
        }
      }, []);
      const {
        useTypeaheadNavigationChild,
        useTypeaheadNavigationProps,
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
      } = useTypeaheadNavigation({
        typeaheadNavigation: {
          getIndex: getTabbableIndex,
          setIndex: q$1(index => {
            setTabbableIndex(index, true);
          }, []),
          ...typeaheadNavigation
        }
      });
      const {
        useLinearNavigationProps
      } = useLinearNavigation({
        linearNavigation: {
          navigateToPrev: q$1(() => {
            setTabbableIndex(c => {
              var _indexMangler3, _indexDemangler3;

              return tryNavigateToIndex({
                children,
                default: c !== null && c !== void 0 ? c : 0,
                target: indexDemangler(indexMangler(c !== null && c !== void 0 ? c : 0) - 1),
                searchDirection: -1,
                indexMangler: (_indexMangler3 = indexMangler) !== null && _indexMangler3 !== void 0 ? _indexMangler3 : identity,
                indexDemangler: (_indexDemangler3 = indexDemangler) !== null && _indexDemangler3 !== void 0 ? _indexDemangler3 : identity
              });
            }, true);
          }, []),
          navigateToNext: q$1(() => {
            setTabbableIndex(c => {
              var _indexMangler4, _indexDemangler4;

              return tryNavigateToIndex({
                children,
                default: c !== null && c !== void 0 ? c : 0,
                target: indexDemangler(indexMangler(c !== null && c !== void 0 ? c : 0) + 1),
                searchDirection: 1,
                indexMangler: (_indexMangler4 = indexMangler) !== null && _indexMangler4 !== void 0 ? _indexMangler4 : identity,
                indexDemangler: (_indexDemangler4 = indexDemangler) !== null && _indexDemangler4 !== void 0 ? _indexDemangler4 : identity
              });
            }, true);
          }, []),
          navigateToFirst: q$1(() => {
            navigateToIndex(indexDemangler(0), true);
          }, []),
          navigateToLast: q$1(() => {
            navigateToIndex(indexDemangler(children.getHighestIndex()), true);
          }, []),
          ...linearNavigation
        }
      });
      const useListNavigationProps = q$1(props => {
        return useLinearNavigationProps(useTypeaheadNavigationProps(props));
      }, [useLinearNavigationProps, useTypeaheadNavigationProps]);
      const useListNavigationChild = q$1(_ref2 => {
        let {
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden
          },
          listNavigation: {
            text
          },
          subInfo
        } = _ref2;

        useTypeaheadNavigationChild({
          text,
          index
        });

        const getIndex = useStableGetter(index);
        s(() => {
          return () => {
            if (getTabbableIndex() == getIndex()) {
              navigateToIndex(index, false);
            }
          };
        }, []);
        const {
          useRovingTabIndexChildProps,
          rovingTabIndex: {
            tabbable,
            getTabbable,
            getElement
          }
        } = useRovingTabIndexChild({
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden: !!hidden
          },
          subInfo: {
            text,
            subInfo
          }
        });

        const useListNavigationChildProps = function (_ref3) {
          let { ...props
          } = _ref3;
          return useMergedProps(useRovingTabIndexChildProps({
            inert: hidden
          }), props);
        };

        return {
          useListNavigationChildProps,
          rovingTabIndex: {
            tabbable,
            getTabbable,
            getElement
          }
        };
      }, [useTypeaheadNavigationChild, useRovingTabIndexChild, navigateToIndex]);
      return {
        useListNavigationChild,
        useListNavigationProps,
        listNavigation: {
          navigateToIndex
        },
        managedChildren: parentReturnType.managedChildren,
        rovingTabIndex: parentReturnType.rovingTabIndex,
        linearNavigation: {},
        typeaheadNavigation: {
          currentTypeahead,
          invalidTypeahead
        }
        /*listNavigation: { navigateToIndex },
        rovingTabIndex: { focusSelf, getTabbableIndex, setTabbableIndex },
        linearNavigation: {},
        typeaheadNavigation: { currentTypeahead, invalidTypeahead }*/

      };
    }
    /**
     * It's very common to combine a tabbable list of things and "selection" of one of those things.
     *
     * Lists, radio buttons, tabs, etc. etc.
     *
     * This is a shortcut that combines the two with the correct typing.
     * @param param0
     * @returns
     */

    function useListNavigationSingleSelection(_ref4) {
      let {
        singleSelection: {
          selectedIndex,
          selectionMode,
          onSelectedIndexChange
        },
        listNavigation,
        managedChildren,
        rovingTabIndex: { ...rovingTabIndex
        },
        linearNavigation,
        typeaheadNavigation,
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        }
      } = _ref4;
      const parentReturnType = useListNavigation({
        listNavigation,
        managedChildren,
        rovingTabIndex: {
          initialIndex: selectedIndex !== null && selectedIndex !== void 0 ? selectedIndex : undefined,
          ...rovingTabIndex
        },
        linearNavigation,
        typeaheadNavigation
      });
      const {
        useChildrenHaveFocusChild
      } = useChildrenHaveFocus({
        childrenHaveFocus: {
          onAllLostFocus: useStableCallback(() => {
            onAllLostFocus === null || onAllLostFocus === void 0 ? void 0 : onAllLostFocus();
            if (selectedIndex != null) setTabbableIndex(selectedIndex, false);
          }),
          onAnyGainedFocus
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const stableOnChange = useStableCallback(onSelectedIndexChange);
      const {
        useListNavigationChild,
        useListNavigationProps,
        ...listRest
      } = parentReturnType;
      const {
        managedChildren: {
          children
        },
        rovingTabIndex: {
          setTabbableIndex
        }
      } = listRest;
      const {
        changeIndex: changeSelectedIndex,
        getCurrentIndex: getSelectedIndex //reevaluateClosestFit

      } = useChildrenFlag({
        children: children,
        initialIndex: selectedIndex,
        key: "selected",
        closestFit: false
      });
      _(() => {
        changeSelectedIndex(selectedIndex);
      }, [selectedIndex]);
      return {
        useListNavigationSingleSelectionChild: q$1(_ref5 => {
          let {
            managedChild: {
              index,
              flags
            },
            rovingTabIndex: rti,
            listNavigation: ls,
            hasFocus: {
              onFocusedInnerChanged,
              ...hasFocus
            },
            subInfo
          } = _ref5;
          const [isSelected, setIsSelected, getIsSelected] = useState(getSelectedIndex() == index);
          const selectedRef = A({
            get: getIsSelected,
            set: setIsSelected,
            isValid: useStableCallback(() => !rti.hidden)
          });
          const {
            useChildrenHaveFocusChildProps,
            getElement
          } = useChildrenHaveFocusChild({
            onFocusedInnerChanged: useStableCallback((focused, prev) => {
              onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);

              if (selectionMode == 'focus' && focused) {
                stableOnChange({
                  target: getElement(),
                  currentTarget: getElement()
                }, getIndex());
              }
            }),
            ...hasFocus,
            managedChild: {
              index
            }
          });
          const {
            rovingTabIndex: rti_ret,
            useListNavigationChildProps
          } = useListNavigationChild({
            managedChild: {
              index,
              flags: {
                selected: selectedRef.current,
                ...flags
              }
            },
            rovingTabIndex: rti,
            listNavigation: ls,
            subInfo
          });
          const getIndex = useStableGetter(index);
          const usePressProps = usePress(e => {
            stableOnChange(e, getIndex());
          }, {});
          return {
            useListNavigationSingleSelectionChildProps: props => usePressProps(useChildrenHaveFocusChildProps(useListNavigationChildProps(props))),
            rovingTabIndex: rti_ret,
            singleSelection: {
              selected: isSelected,
              getSelected: getIsSelected
            }
          };
        }, [selectionMode]),
        useListNavigationSingleSelectionProps: q$1(function () {
          return useListNavigationProps(...arguments);
        }, []),
        ...listRest,
        singleSelection: {}
      };
    }
    function tryNavigateToIndex(_ref8) {
      let {
        children,
        searchDirection,
        indexDemangler,
        indexMangler,
        target
      } = _ref8;
      const upper = children.getHighestIndex();
      const lower = 0;

      if (searchDirection === -1) {
        while (target >= lower && children.getAt(target) == null || !!((_children$getAt = children.getAt(target)) !== null && _children$getAt !== void 0 && _children$getAt.subInfo.hidden)) {
          var _children$getAt;

          target = indexDemangler(indexMangler(target) - 1);
        }

        return target < lower ? indexDemangler(lower) : target;
      } else if (searchDirection === 1) {
        while (target <= upper && children.getAt(target) == null || !!((_children$getAt2 = children.getAt(target)) !== null && _children$getAt2 !== void 0 && _children$getAt2.subInfo.hidden)) {
          var _children$getAt2;

          target = indexDemangler(indexMangler(target) + 1);
        }

        return target > upper ? indexDemangler(upper) : target;
      } else {
        return lower;
      }
    }

    function useGridNavigation(_ref) {
      var _rti$initialIndex;

      let {
        managedChildren: mc,
        rovingTabIndex: rti,
        listNavigation: ls,
        linearNavigation: ln,
        typeaheadNavigation: tn
      } = _ref;
      const [currentColumn, setCurrentColumn, getCurrentColumn] = useState((_rti$initialIndex = rti.initialIndex) !== null && _rti$initialIndex !== void 0 ? _rti$initialIndex : 0);
      const {
        useListNavigationChild: useListNavigationChildAsGridRow,
        useListNavigationProps: useListNavigationPropsAsGridParent,
        ...parentLsReturnType
      } = useListNavigation({
        managedChildren: mc,
        rovingTabIndex: rti,
        listNavigation: ls,
        linearNavigation: {
          navigationDirection: "block",
          ...ln
        },
        typeaheadNavigation: tn
      });
      const useGridNavigationRow = q$1(_ref2 => {
        let {
          asChildRowOfSection: asChild,
          asParentRowOfCells: asParent
        } = _ref2;
        // Override the focusSelf that rovingTabIndex does.
        // Instead of focusing the entire row, we ask the cell that corresponds
        // to our current column to focus itself.
        const focusSelf = useStableCallback(() => {
          const c2 = getCurrentColumn();

          if (asChild.rovingTabIndex.focusSelf) {
            asChild.rovingTabIndex.focusSelf();
          } else {
            navigateToIndex(c2 !== null && c2 !== void 0 ? c2 : 0, true);
          }
        });
        const rowLsChildReturnType = useListNavigationChildAsGridRow({
          managedChild: asChild.managedChild,
          listNavigation: { ...asChild.listNavigation
          },
          rovingTabIndex: { ...asChild.rovingTabIndex,
            focusSelf
          },
          subInfo: asChild.subInfo
        });
        const {
          rovingTabIndex: {
            tabbable
          },
          useListNavigationChildProps
        } = rowLsChildReturnType;
        s(() => {
          if (!tabbable) {
            navigateToIndex(null, false);
          }
        }, [tabbable]);
        const rowLsReturnType = useListNavigation({
          managedChildren: { ...asParent.managedChildren
          },
          rovingTabIndex: { ...asParent.rovingTabIndex
          },
          linearNavigation: { ...asParent.linearNavigation,
            navigationDirection: "inline"
          },
          typeaheadNavigation: { ...asParent.typeaheadNavigation,
            noTypeahead: true
          },
          listNavigation: { ...asParent.listNavigation
          }
        });
        const {
          rovingTabIndex: {
            setTabbableIndex
          },
          useListNavigationChild: useGridNavigationColumn2,
          useListNavigationProps: useGridNavigationColumnProps,
          listNavigation: {
            navigateToIndex
          }
        } = rowLsReturnType; //const rowHidden = !!asChild.rovingTabIndex.hidden;

        const useGridNavigationCell = q$1(_ref3 => {
          let {
            subInfo,
            hasFocus: {
              onLastFocusedInnerChanged,
              ...hasFocus
            },
            managedChild,
            listNavigation: ls,
            rovingTabIndex: {
              blurSelf: bs,
              focusSelf: fs,
              ...rti
            }
          } = _ref3;
          //rti.hidden || rowHidden;
          const focusSelf = useStableCallback(() => {
            var _rti_cell_ret$getElem, _rti_cell_ret$getElem2;

            setCurrentColumn(managedChild.index);
            setTabbableIndex(managedChild.index, false);
            if (fs) fs();else (_rti_cell_ret$getElem = rti_cell_ret.getElement()) === null || _rti_cell_ret$getElem === void 0 ? void 0 : (_rti_cell_ret$getElem2 = _rti_cell_ret$getElem.focus) === null || _rti_cell_ret$getElem2 === void 0 ? void 0 : _rti_cell_ret$getElem2.call(_rti_cell_ret$getElem);
          });
          const blurSelf = useStableCallback(() => {
            var _rti_cell_ret$getElem3, _rti_cell_ret$getElem4;

            if (bs) bs();else (_rti_cell_ret$getElem3 = rti_cell_ret.getElement()) === null || _rti_cell_ret$getElem3 === void 0 ? void 0 : (_rti_cell_ret$getElem4 = _rti_cell_ret$getElem3.blur) === null || _rti_cell_ret$getElem4 === void 0 ? void 0 : _rti_cell_ret$getElem4.call(_rti_cell_ret$getElem3);
          });
          const {
            useListNavigationChildProps,
            rovingTabIndex: rti_cell_ret
          } = useGridNavigationColumn2({
            managedChild: managedChild,
            listNavigation: { ...ls
            },
            rovingTabIndex: {
              blurSelf,
              focusSelf,
              ...rti
            },
            subInfo
          });
          const {
            useHasFocusProps
          } = useHasFocus({
            onLastFocusedInnerChanged: useStableCallback((focused, prev) => {
              onLastFocusedInnerChanged === null || onLastFocusedInnerChanged === void 0 ? void 0 : onLastFocusedInnerChanged(focused, prev);

              if (focused) {
                setCurrentColumn(managedChild.index);
                setTabbableIndex(managedChild.index, false);
              }
            }),
            ...hasFocus
          });
          const ret = {
            gridNavigation: {
              getCurrentColumn
            },
            rovingTabIndex: rti_cell_ret,
            useGridNavigationCellProps: function (props) {
              return useListNavigationChildProps(useGridNavigationColumnProps(useHasFocusProps(props)));
            }
          };
          return ret;
        }, []);
        const ret = {
          asParentOfCells: {
            linearNavigation: rowLsReturnType.linearNavigation,
            listNavigation: rowLsReturnType.listNavigation,
            managedChildren: rowLsReturnType.managedChildren,
            rovingTabIndex: rowLsReturnType.rovingTabIndex,
            typeaheadNavigation: rowLsReturnType.typeaheadNavigation
          },
          asChildRow: rowLsChildReturnType,
          useGridNavigationCell,
          useGridNavigationRowProps: function (props) {
            const ret = useListNavigationChildProps(props);
            ret.tabIndex = -1;
            return ret;
          }
        };
        return ret;
      }, []);
      return {
        gridNavigation: {
          getCurrentColumn,
          currentColumn
        },
        linearNavigation: parentLsReturnType.linearNavigation,
        listNavigation: parentLsReturnType.listNavigation,
        rovingTabIndex: parentLsReturnType.rovingTabIndex,
        typeaheadNavigation: parentLsReturnType.typeaheadNavigation,
        managedChildren: parentLsReturnType.managedChildren,
        useGridNavigationRow,
        useGridNavigationProps: useListNavigationPropsAsGridParent
      };
    }

    /**
     * Returns a hook that modifies a set of props to provide a randomly-generated ID if one was not provided.
     *
     * If you'd like to use the ID in a property that's *not* named `id` (like `for` or `aria-labelledby` or whatnot), `useReferencedIdProps` is also provided.
     *
     * And the randomly-generated id itself is also provided in case you want to handle the logic yourself without `useMergedProps`.
     *
     * Unlike most other `use*Props` hooks, these are mostly stable.
     */

    function useRandomId(_ref) {
      let {
        randomId: {
          prefix
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref;
      const [backupRandomId,, getBackupRandomId] = useState(() => generateRandomId(prefix));
      const [usedId, setUsedId, getUsedId] = useState(() => getBackupRandomId());
      const mismatchErrorRef = A(false);
      useEnsureStability("useRandomId", prefix);
      const {
        useManagedChild,
        ...managedChildrenReturnType
      } = useManagedChildren({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      const {
        managedChildren: {
          children
        }
      } = managedChildrenReturnType;
      const useRandomIdSourceElement = q$1(() => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId());
        const {
          useRefElementProps,
          getElement
        } = useRefElement(); // Every time the source element renders, inspect the ID it actually used
        // (whether it was ours or not isn't up to us, it's up to the component)
        // so this is how we notify the referencer component of changes

        s(() => {
          const element = getElement();

          if (element) {
            children.getAt("referencer").subInfo.setUsedId(element.id);
            setUsedId(element.id);
          }
        });

        useManagedChild({
          managedChild: {
            index: "source",
            subInfo: {
              setUsedId: setUsedIdLocal
            }
          }
        });

        const useRandomIdSourceElementProps = q$1(function (p) {
          p.id || (p.id = backupRandomId);
          return useRefElementProps(p);
        }, []);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdSourceElementProps
        };
      }, []);
      const useRandomIdReferencerElement = q$1(idPropName => {
        const [usedIdLocal, setUsedIdLocal, getUsedIdLocal] = useState(getUsedId()); // Whatever ID was most recently used by the actual "id" prop of the source element

        useEnsureStability(idPropName);

        useManagedChild({
          managedChild: {
            index: "referencer",
            subInfo: {
              setUsedId: setUsedIdLocal
            }
          }
        });

        const useRandomIdReferencerElementProps = q$1(function (_ref2) {
          let {
            [idPropName]: givenId,
            ...p
          } = _ref2;

          if (givenId && usedId) {
            if (givenId != usedId) {
              if (!mismatchErrorRef.current) {
                mismatchErrorRef.current = true;
                console.error(`Multiple mis-matched IDs were provided for the ${idPropName} prop: the child explicitly specified ${givenId} in its  ${idPropName} prop, but the parent told this child to use ${usedId} (the parent's ID).`);
              }
            }
          }

          return useMergedProps(p, {
            [idPropName]: usedId
          });
        }, [usedId]);
        return {
          usedId: usedIdLocal,
          getUsedId: getUsedIdLocal,
          useRandomIdReferencerElementProps
        };
      }, []);
      return {
        randomId: {
          usedId,
          getUsedId
        },
        ...managedChildrenReturnType,
        useRandomIdSourceElement,
        useRandomIdReferencerElement
      };
    }

    function useButton(_ref) {
      let {
        tag,
        pressed,
        onPress,
        disabled
      } = _ref;
      debugLog("useButton");

      function useButtonProps(_ref2) {
        let {
          "aria-pressed": ariaPressed,
          tabIndex,
          role,
          ...p
        } = _ref2;
        const usePressProps = usePress(e => {
          var _ref3;

          return (_ref3 = disabled ? null : onPress) === null || _ref3 === void 0 ? void 0 : _ref3(enhanceEvent(e, {
            pressed: pressed == null ? null : !pressed
          }));
        }, undefined);
        const props = usePressProps(p);
        const baseProps = {
          role,
          tabIndex,
          "aria-pressed": ariaPressed !== null && ariaPressed !== void 0 ? ariaPressed : pressed === true ? "true" : pressed === false ? "false" : undefined
        };
        const buttonProps = { ...baseProps,
          disabled: disabled && disabled != "soft" ? true : false,
          "aria-disabled": disabled === 'soft' ? 'true' : undefined
        };
        const divProps = { ...baseProps,
          tabIndex: tabIndex !== null && tabIndex !== void 0 ? tabIndex : disabled === "hard" ? -1 : 0,
          role: role !== null && role !== void 0 ? role : "button",
          "aria-disabled": disabled ? "true" : undefined
        };

        switch (tag) {
          case "button":
            return useMergedProps(buttonProps, props);

          default:
            return useMergedProps(divProps, props);
        }
      }

      return {
        useButtonProps
      };
    }

    //export interface UseAccordionSectionHeaderReturnType<E extends Element> { useAccordionSectionHeaderProps: (props: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; }
    //export type UseAccordionSectionBody<E extends Element> = () => UseAccordionSectionBodyReturnType<E>;
    //export interface UseAccordionSectionBodyReturnType<E extends Element> { useAccordionSectionBodyProps: (props: h.JSX.HTMLAttributes<E>) => h.JSX.HTMLAttributes<E>; }

    function useAccordion(_ref) {
      let {
        accordion: {
          initialIndex
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      } = _ref;
      debugLog("useAccordian");
      const [_currentFocusedIndex, setCurrentFocusedIndex, getCurrentFocusedIndex] = useState(null);
      const mcReturnType = useManagedChildren({
        managedChildren: {
          onChildrenMountChange: useStableCallback((m, u) => {
            ocmc2();
            onChildrenMountChange === null || onChildrenMountChange === void 0 ? void 0 : onChildrenMountChange(m, u);
          }),
          onAfterChildLayoutEffect
        }
      });
      const {
        useManagedChild,
        managedChildren: {
          children
        }
      } = mcReturnType;
      const navigateToFirst = q$1(() => {
        changeTabbedIndex(0);
      }, []);
      const navigateToLast = q$1(() => {
        changeTabbedIndex(children.getHighestIndex());
      }, []);
      const navigateToPrev = q$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) - 1);
      }, []);
      const navigateToNext = q$1(() => {
        changeTabbedIndex(i => (i !== null && i !== void 0 ? i : 0) + 1);
      }, []);
      const linearReturnType = useLinearNavigation({
        linearNavigation: {
          navigateToFirst,
          navigateToLast,
          navigateToNext,
          navigateToPrev,
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection: navigationDirection !== null && navigationDirection !== void 0 ? navigationDirection : "block"
        }
      });
      const {
        useLinearNavigationProps
      } = linearReturnType;
      const {
        changeIndex: changeExpandedIndex,
        getCurrentIndex: _getCurrentExpandedIndex
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "open",
        closestFit: false
      });
      const {
        changeIndex: changeTabbedIndex,
        getCurrentIndex: _getTabbedIndex,
        reevaluateClosestFit: ocmc2
      } = useChildrenFlag({
        initialIndex,
        children,
        key: "tabbed",
        closestFit: true,
        onIndexChange: q$1(i => {
          if (i != null) {
            var _children$getAt;

            (_children$getAt = children.getAt(i)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.focus();
          }
        }, [])
      });
      const useAccordionSection = q$1(_ref2 => {
        var _ref3;

        let {
          button: {
            disabled
          },
          accordionSection: {
            open: openFromUser,
            tagButton
          },
          managedChildren: {
            index
          },
          hasFocus: {
            onFocusedInnerChanged,
            ...hasFocus
          }
        } = _ref2;
        debugLog("useAccordianSection");
        const [openFromParent, setOpenFromParent, getOpenFromParent] = useState(null);
        const {
          useRandomIdSourceElement: useBodyAsSourceId,
          useRandomIdReferencerElement: useHeaderAsReferencerId,
          randomId: {
            usedId: bodyId,
            getUsedId: getBodyId
          }
        } = useRandomId({
          randomId: {
            prefix: "aria-accordion-section-body-"
          },
          managedChildren: {
            onAfterChildLayoutEffect: null,
            onChildrenMountChange: null
          }
        });
        const {
          useRandomIdSourceElement: useHeaderAsSourceId,
          useRandomIdReferencerElement: useBodyAsReferencerId,
          randomId: {
            usedId: headerId,
            getUsedId: getHeaderId
          }
        } = useRandomId({
          randomId: {
            prefix: "aria-accordion-section-header-"
          },
          managedChildren: {
            onAfterChildLayoutEffect: null,
            onChildrenMountChange: null
          }
        });
        const {
          useRandomIdSourceElementProps: useBodyAsSourceIdProps
        } = useBodyAsSourceId();
        const {
          useRandomIdReferencerElementProps: useBodyAsReferencerIdProps
        } = useBodyAsReferencerId("aria-labelledby");
        const {
          useRandomIdSourceElementProps: useHeaderAsSourceIdProps
        } = useHeaderAsSourceId();
        const {
          useRandomIdReferencerElementProps: useHeaderAsReferencerIdProps
        } = useHeaderAsReferencerId("aria-controls");
        const open = (_ref3 = openFromUser !== null && openFromUser !== void 0 ? openFromUser : openFromParent) !== null && _ref3 !== void 0 ? _ref3 : false; //const getOpen = useStableGetter(!!open);

        const getIndex = useStableGetter(index);
        const {
          getElement: getHeaderElement,
          useRefElementProps: useHeaderRefElementProps
        } = useRefElement({});
        const {
          getElement: getBodyElement,
          useRefElementProps: useBodyRefElementProps
        } = useRefElement({});
        const focus = q$1(() => {
          var _getHeaderElement;

          if (getCurrentFocusedIndex() != null) (_getHeaderElement = getHeaderElement()) === null || _getHeaderElement === void 0 ? void 0 : _getHeaderElement.focus();
        }, []);
        const openRef = A({
          get: () => !!getOpenFromParent(),
          set: open => {
            setOpenFromParent(open);

            if (open) {
              const bodyElement = getBodyElement();
              setCurrentFocusedIndex(getIndex());

              if (bodyElement) {
                queueMicrotask(() => bodyElement.focus());
              }
            }
          },
          isValid: returnTrue
        });
        const tabbedRef = A({
          get: () => getCurrentFocusedIndex() == getIndex(),
          set: open => {
            if (open) setCurrentFocusedIndex(getIndex());
          },
          isValid: returnTrue
        });

        useManagedChild({
          managedChild: {
            index: index,
            flags: {
              open: openRef.current,
              tabbed: tabbedRef.current
            },
            subInfo: {
              focus,
              getOpenFromParent,
              setOpenFromParent
            } // info: { index, setOpenFromParent, getOpenFromParent, focus, flags: { open: openRef.current, tabbed: tabbedRef.current } }

          }
        });

        function useAccordionSectionHeaderProps(_ref4) {
          var _ref5;

          let {
            ["aria-expanded"]: ariaExpanded,
            ["aria-disabled"]: ariaDisabled,
            ...props
          } = _ref4;

          //const onFocus = () => { changeTabbedIndex(index); }
          const onPress = () => {
            if (getOpenFromParent()) changeExpandedIndex(null);else changeExpandedIndex(index);
          };

          props.tabIndex = 0;
          const {
            useButtonProps
          } = useButton({
            tag: tagButton,
            disabled,
            onPress
          });
          const retB = useButtonProps(props); //const retB = useMergedProps<HeaderElement>(usePressEventHandlers<HeaderElement>(onClick, undefined), props);

          const {
            useHasFocusProps
          } = useHasFocus({ ...hasFocus,
            onFocusedInnerChanged: useStableCallback((focused, prev) => {
              onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);
              if (focused) changeTabbedIndex(index);
            })
          }); //const ret3: h.JSX.HTMLAttributes<HeaderElement>
          //    = useMergedProps<HeaderElement>(retD, { onFocus });

          return useHasFocusProps(useLinearNavigationProps(useHeaderAsSourceIdProps(useHeaderAsReferencerIdProps({
            "aria-expanded": ((_ref5 = ariaExpanded !== null && ariaExpanded !== void 0 ? ariaExpanded : open) !== null && _ref5 !== void 0 ? _ref5 : false).toString(),
            "aria-disabled": ariaDisabled !== null && ariaDisabled !== void 0 ? ariaDisabled : open ? "true" : undefined,
            ...useHeaderRefElementProps(retB)
          }))));
        }

        function useAccordionSectionBodyProps(_ref6) {
          var _ret2$tabIndex;

          let {
            role,
            ...props
          } = _ref6;
          const ret1 = useBodyAsReferencerIdProps({
            role: role !== null && role !== void 0 ? role : "region",
            ...props
          });
          const ret2 = useBodyAsSourceIdProps(ret1);
          (_ret2$tabIndex = ret2.tabIndex) !== null && _ret2$tabIndex !== void 0 ? _ret2$tabIndex : ret2.tabIndex = -1;
          return useBodyRefElementProps(ret2);
        }

        return {
          accordionSection: {
            expanded: open,
            focused: getCurrentFocusedIndex() == index,
            bodyId,
            headerId,
            getBodyId,
            getHeaderId
          },
          useAccordionSectionHeaderProps,
          useAccordionSectionBodyProps
        };
      }, []);
      return {
        managedChildren: mcReturnType.managedChildren,
        accordion: {
          changeExpandedIndex
        },
        useAccordionSection
      };
    }

    /**
     * Adds an ID and "aria-labelledby" for two elements, an "input" element and a "label" element.
     *
     * Returns the `useReferencedIdProps` hooks if you need to also add other ID-referencer attributes, like `for`
     *
     * @see useInputLabel
     */

    function useLabel(_ref) {
      let {
        label: {
          prefixInput,
          prefixLabel,
          tagInput,
          tagLabel
        }
      } = _ref;
      const {
        useRandomIdSourceElement: useLabelAsSourceId,
        useRandomIdReferencerElement: useLabelAsReferencerId,
        randomId: {
          usedId: labelId,
          getUsedId: getLabelId
        }
      } = useRandomId({
        randomId: {
          prefix: prefixLabel
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useInputAsSourceId,
        useRandomIdReferencerElement: useInputAsReferencerId,
        randomId: {
          usedId: inputId,
          getUsedId: getInputId
        }
      } = useRandomId({
        randomId: {
          prefix: prefixInput
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElementProps: useLabelAsSourceIdProps
      } = useLabelAsSourceId();
      const {
        useRandomIdSourceElementProps: useInputAsSourceIdProps
      } = useInputAsSourceId();
      const {
        useRandomIdReferencerElementProps: useLabelAsReferencerIdProps
      } = useLabelAsReferencerId("aria-labelledby");
      const {
        useRandomIdReferencerElementProps: useInputAsReferencerIdProps
      } = useInputAsReferencerId("for");
      const isSyntheticLabel = tagInput != "input" || tagLabel != "label";
      const useLabelLabel = q$1(function useLabelLabel() {
        return {
          useLabelLabelProps: props => {
            const propsWithoutFor = useLabelAsSourceIdProps(props);
            const propsWithFor = useInputAsReferencerIdProps(propsWithoutFor);
            if (tagLabel == "label" && tagInput == "input") return propsWithFor;else return propsWithoutFor;
          }
        };
      }, [isSyntheticLabel]);
      const useLabelInput = q$1(function useLabelInput() {
        return {
          useLabelInputProps: _ref2 => {
            let {
              "aria-labelledby": ariaLabelledby,
              ...props
            } = _ref2;
            console.assert(!ariaLabelledby);
            const propsWithoutAriaLabelledBy = useInputAsSourceIdProps(props);
            const propsWithAriaLabelledBy = useLabelAsReferencerIdProps(propsWithoutAriaLabelledBy);
            if (isSyntheticLabel && !props["aria-label"]) return propsWithAriaLabelledBy;else return propsWithoutAriaLabelledBy;
          }
        };
      }, [isSyntheticLabel]);
      return {
        useLabelInput,
        useLabelLabel,
        label: {
          labelId,
          inputId,
          getLabelId,
          getInputId
        }
      };
    }

    const handlesInput = (tag, labelPosition, which) => {
      if (labelPosition === "separate") {
        if (which === "input-element") return true;else if (which === "label-element") return tag != "input";
      } else if (labelPosition === "wrapping") {
        if (which === "input-element") return false;
        if (which == "label-element") return true;
      }
    };
    /**
     * Handles label type (wrapping or separate) for checkboxes, radios, switches, etc.
     *
     * If it's a toggleable click-thing with a label (that can also be clicked), then it's a checkbox-like.
     * @param param0
     * @returns
     */


    function useCheckboxLike(_ref3) {
      let {
        checkboxLike: {
          checked,
          disabled,
          labelPosition,
          role,
          onCheckedChange
        },
        label: {
          tagInput,
          tagLabel
        }
      } = _ref3;
      const stableOnInput = useStableCallback(e => {
        e.preventDefault();
        onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(e);
      });
      const {
        useLabelInput: useILInput,
        useLabelLabel: useILLabel,
        label
      } = useLabel({
        label: {
          prefixLabel: "aria-checkbox-label-",
          prefixInput: "aria-checkbox-input-",
          tagInput: tagInput,
          tagLabel: tagLabel
        }
      });
      const {
        getElement: getLabelElement,
        useRefElementProps: useLabelRefElementProps
      } = useRefElement();
      const {
        getElement: getInputElement,
        useRefElementProps: useInputRefElementProps
      } = useRefElement();
      const useCheckboxLikeInputElement = q$1(function useCheckboxInputElement() {
        const tag = tagInput;
        const {
          useLabelInputProps: useILInputProps
        } = useILInput();
        const {
          useRefElementProps,
          getElement
        } = useRefElement({}); // onClick and onChange are a bit messy, so we need to
        // *always* make sure that the visible state is correct
        // after all the event dust settles.
        // See https://github.com/preactjs/preact/issues/2745,
        // and https://github.com/preactjs/preact/issues/1899#issuecomment-525690194

        s(() => {
          const element = getElement();

          if (element && tag == "input") {
            element.indeterminate = checked === "mixed";
            element.checked = checked === true;
          }
        }, [tag, checked]);
        return {
          getInputElement: getElement,
          useCheckboxLikeInputElementProps
        };

        function useCheckboxLikeInputElementProps(_ref4) {
          let { ...p0
          } = _ref4;
          // For some reason, Chrome won't fire onInput events for radio buttons that are tabIndex=-1??
          // Needs investigating, but onInput works fine in Firefox
          // TODO
          const usePressProps = usePress(disabled || !handlesInput(tag, labelPosition, "input-element") ? undefined : stableOnInput, undefined);
          let props = usePressProps(p0);
          if (tag == "input") props.onInput = e => e.preventDefault();
          props = useRefElementProps(useILInputProps(props));

          if (labelPosition == "wrapping") {
            // Because the wrapped label handles all interactions,
            // we need to make sure this element can't be interacted with
            // even if it's an input element.
            props.inert = true;
            props.tabIndex = -1;
            props.role = "presentation";
            props["aria-hidden"] = "true";

            props.onFocus = _ => {
              var _getLabelElement;

              return (_getLabelElement = getLabelElement()) === null || _getLabelElement === void 0 ? void 0 : _getLabelElement.focus();
            };
          } else {
            if (tag === "input") {
              props.checked = checked === true;
            } else {
              props.role = role;
              props.tabIndex = 0;
              props["aria-checked"] = checked === "mixed" ? "mixed" : checked === true ? "true" : undefined;
            }

            props["aria-disabled"] = disabled.toString();
          } // Make sure that label clicks can't affect the checkbox while it's disabled


          props.onClick = disabled ? e => {
            e.preventDefault();
          } : props.onClick;
          return useInputRefElementProps(useMergedProps(p0, props));
        }
      }, [useILInput, role, labelPosition, disabled, checked, tagInput]);
      const useCheckboxLikeLabelElement = q$1(function useCheckboxLabelElement() {
        const tag = tagLabel;
        const {
          useLabelLabelProps: useILLabelProps
        } = useILLabel();

        function useCheckboxLikeLabelElementProps(_ref5) {
          let { ...p0
          } = _ref5;
          const usePressProps = usePress(disabled || !handlesInput(tag, labelPosition, "label-element") ? undefined : stableOnInput, undefined);
          const newProps = usePressProps(p0);

          if (labelPosition == "wrapping") {
            if (newProps.tabIndex == null) newProps.tabIndex = 0;
            if (newProps.role == null) newProps.role = role;
            newProps["aria-disabled"] = disabled.toString();
            newProps["aria-checked"] = checked.toString();
          } // Just make sure that label clicks can't affect the checkbox while it's disabled


          newProps.onClick = disabled ? e => {
            e.preventDefault();
          } : newProps.onClick;
          return useILLabelProps(useLabelRefElementProps(newProps));
        }

        return {
          useCheckboxLikeLabelElementProps
        };
      }, [useILLabel, disabled, checked, role, labelPosition, tagLabel]);
      return {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        checkboxLike: {
          getLabelElement,
          getInputElement
        },
        label
      };
    }

    function useCheckbox(_ref) {
      let {
        checkboxLike,
        label,
        checkbox
      } = _ref;
      debugLog("useCheckbox");
      const {
        disabled,
        labelPosition,
        checked
      } = checkboxLike;
      const {
        tagInput,
        tagLabel
      } = label;
      const {
        onCheckedChange: onInput
      } = checkbox;

      const onInputEnhanced = e => onInput === null || onInput === void 0 ? void 0 : onInput(enhanceEvent(e, {
        checked: !checked
      }));

      const {
        useCheckboxLikeInputElement,
        useCheckboxLikeLabelElement,
        ...checkboxLikeRest
      } = useCheckboxLike({
        checkboxLike: {
          role: "checkbox",
          checked,
          onCheckedChange: onInputEnhanced,
          disabled,
          labelPosition
        },
        label
      });
      const useCheckboxInputElement = q$1(function useCheckboxInputElement() {
        const tag = tagInput;
        const {
          useCheckboxLikeInputElementProps
        } = useCheckboxLikeInputElement();
        return {
          useCheckboxInputElementProps
        };

        function useCheckboxInputElementProps(_ref2) {
          var _props$checked;

          let { ...p0
          } = _ref2;
          const props = useCheckboxLikeInputElementProps(p0);
          (_props$checked = props.checked) !== null && _props$checked !== void 0 ? _props$checked : props.checked = !!checked;
          if (tag == "input") props.type = "checkbox";
          return props;
        }
      }, [useCheckboxLikeInputElement, checked, labelPosition, disabled, tagInput]);
      const useCheckboxLabelElement = q$1(function useCheckboxLabelElement() {
        const {
          useCheckboxLikeLabelElementProps
        } = useCheckboxLikeLabelElement();

        function useCheckboxLabelElementProps(_ref3) {
          let { ...props
          } = _ref3;
          return useCheckboxLikeLabelElementProps(props);
        }

        return {
          useCheckboxLabelElementProps
        };
      }, [useCheckboxLikeLabelElement, disabled, labelPosition, tagLabel]);
      return {
        useCheckboxInputElement,
        useCheckboxLabelElement,
        ...checkboxLikeRest
      };
    }

    /**
     *
     *
     * @param param0
     * @returns
     */

    function useCheckboxGroup(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      debugLog("useCheckboxGroup"); //const onUpdateChildren = useStableCallback(onUpdateChildrenUnstable ?? (() => {}));

      const {
        useListNavigationChild,
        useListNavigationProps,
        ...listReturnType
      } = useListNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children
        }
      } = listReturnType; //const [uncheckedCount, setUnheckedCount] = useState(0);
      // Keep track of all child IDs, and any time any of them change, 
      // generate a new string with all of them concatenated together
      // (but only once per render);

      const allIds = A(new Set());
      const [ariaControls, setControls] = useState("");
      const [updateIndex, setIdUpdateIndex] = useState(0);
      const [checkedCount, setCheckedCount] = useState(0);
      const checkedIndices = A(new Set()); //const [selfIsChecked, setSelfIsChecked, getSelfIsChecked] = useState<boolean | "mixed">(false);

      const getSelfIsCheckedUnstable = q$1(() => {
        const percentage = checkedCount / (children.getHighestIndex() + 1);
        return percentage <= 0 ? false : percentage >= 1 ? true : "mixed";
      }, [checkedCount]);
      const getSelfIsCheckedStable = useStableCallback(getSelfIsCheckedUnstable);
      const [setParentCheckboxChecked, setSetParentCheckboxChecked] = useState(null);
      s(() => {
        setParentCheckboxChecked === null || setParentCheckboxChecked === void 0 ? void 0 : setParentCheckboxChecked(checkedCount == 0 ? false : checkedCount == children.getHighestIndex() + 1 ? true : "mixed");
      }, [setParentCheckboxChecked, checkedCount]); // If the user has changed the parent checkbox's value, then this ref holds a memory of what values were held before.
      // Otherwise, it's null when the last input was from a child checkbox. 
      //const savedCheckedValues = useRef<Map<number, boolean | "mixed"> | null>(null);

      const useCheckboxGroupParentInput = q$1(_ref2 => {
        let {
          checkbox,
          checkboxLike,
          label
        } = _ref2;
        debugLog("useCheckboxGroupParent");
        const {
          disabled,
          labelPosition
        } = checkboxLike;
        const {
          tagInput,
          tagLabel
        } = label;
        const [checked, setChecked] = useState(false);
        s(() => {
          setSetParentCheckboxChecked(() => setChecked);
        }, []);
        const {
          useCheckboxInputElement,
          useCheckboxLabelElement
        } = useCheckbox({
          checkboxLike: {
            labelPosition,
            checked,
            disabled
          },
          label: {
            tagInput,
            tagLabel
          },
          checkbox: {
            onCheckedChange: onCheckboxGroupParentInput2
          }
        });
        const {
          useCheckboxInputElementProps
        } = useCheckboxInputElement();
        const {
          useCheckboxLabelElementProps
        } = useCheckboxLabelElement();
        return {
          useCheckboxGroupParentInputProps: function useCheckboxGroupParentInputProps(props) {
            const ret = useMergedProps(useMergedProps({}, {
              "aria-controls": ariaControls,
              onInput: tagInput == "input" ? e => e.preventDefault() : undefined
            }), props);
            return useCheckboxInputElementProps(labelPosition == "separate" ? ret : props);
          },
          useCheckboxGroupParentLabelProps: function useCheckboxGroupParentLabelProps(props) {
            const ret = useMergedProps(useMergedProps({}, {
              "aria-controls": ariaControls
            }), props);
            return useCheckboxLabelElementProps(labelPosition == "wrapping" ? ret : props);
          }
        };
      }, [ariaControls]);
      const onCheckboxGroupParentInput2 = q$1(e => {
        e.preventDefault();
        const selfIsChecked = getSelfIsCheckedStable();
        const nextChecked = selfIsChecked === false ? "mixed" : selfIsChecked === "mixed" ? true : false;
        let willChangeAny = false;
        children.forEach(child => willChangeAny || (willChangeAny = child.subInfo.subInfo.subInfo.checked != child.subInfo.subInfo.subInfo.getLastUserChecked()));
        children.forEach(child => {
          var _child$subInfo$subInf, _child$subInfo$subInf2;

          let checked;

          if (nextChecked == "mixed") {
            if (willChangeAny) checked = child.subInfo.subInfo.subInfo.getLastUserChecked();else checked = true;
          } else {
            checked = nextChecked;
          }

          (_child$subInfo$subInf = (_child$subInfo$subInf2 = child.subInfo.subInfo.subInfo).onCheckedChange) === null || _child$subInfo$subInf === void 0 ? void 0 : _child$subInfo$subInf.call(_child$subInfo$subInf2, enhanceEvent(e, {
            checked
          }));
        });
        /*if (selfIsChecked === true || (selfIsChecked === false && savedCheckedValues.current == null)) {
            return onUpdateChildren(enhanceEvent(e, { childrenChecked: false }));
        }
        else if (selfIsChecked === "mixed") {
             savedCheckedValues.current = new Map();
            children.forEach(child => {
                savedCheckedValues.current!.set(child.index, child.getLastUserChecked());
            })
             return onUpdateChildren(enhanceEvent(e, { childrenChecked: true }));
        }
        else {
            return onUpdateChildren(enhanceEvent(e, { childrenChecked: savedCheckedValues.current ?? true }));
        }*/
      }, []);
      const notifyChecked = q$1((index, checked) => {
        if (checked === true) {
          if (!checkedIndices.current.has(index)) {
            setCheckedCount(c => c + 1);
            checkedIndices.current.add(index);
          }
        } else {
          if (checkedIndices.current.has(index)) {
            setCheckedCount(c => c - 1);
            checkedIndices.current.delete(index);
          }
        }
      }, []);
      /*useEffect(() => {
          let percentage = checkedCount / managedChildren.length;
          setSelfIsChecked(percentage <= 0 ? false : percentage >= 1 ? true : "mixed")
      }, [setSelfIsChecked, managedChildren.length, checkedCount]);*/

      /*const useCheckboxGroupParentProps = useCallback((props: h.JSX.HTMLAttributes<InputElement>) => {
          return
      }, [ariaControls]);*/

      s(() => {
        setControls(Array.from(allIds.current).join(" "));
      }, [updateIndex]);
      const useCheckboxGroupChild = q$1(function (_ref3) {
        let {
          asCheckbox,
          asCheckboxGroupChild
        } = _ref3;
        debugLog("useCheckboxGroupChild", asCheckboxGroupChild.managedChild.index, asCheckbox.checkboxLike.checked);
        const {
          checkbox: {
            onCheckedChange
          },
          checkboxLike: {
            checked,
            disabled,
            labelPosition
          },
          label: {
            tagInput,
            tagLabel
          }
        } = asCheckbox;
        const {
          managedChild: {
            index
          }
        } = asCheckboxGroupChild; //labelPosition ??= "separate";

        const [getLastUserChecked, setLastUserChecked] = usePassiveState(null, returnFalse$1);
        const {
          useCheckboxInputElement,
          useCheckboxLabelElement,
          ...checkboxReturnType
        } = useCheckbox({
          checkbox: {
            onCheckedChange: useStableCallback(e => {
              setLastUserChecked(e[EventDetail].checked);
              onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange(e);
            })
          },
          checkboxLike: {
            checked,
            labelPosition,
            disabled
          },
          label: {
            tagInput,
            tagLabel
          }
        });
        const {
          label: {
            inputId,
            labelId
          }
        } = checkboxReturnType; //const getChecked = useStableGetter(checked);

        const controlsId = labelPosition == "separate" ? inputId : labelId;
        s(() => {
          allIds.current.add(controlsId);
          setIdUpdateIndex(i => ++i);
          return () => {
            allIds.current.delete(controlsId);
            setIdUpdateIndex(i => ++i);
          };
        }, [controlsId]);
        s(() => {
          notifyChecked(index, checked);
        }, [index, checked]);
        const {
          useListNavigationChildProps,
          ...listNavigationReturnType
        } = useListNavigationChild({
          subInfo: {
            getLastUserChecked,
            onCheckedChange,
            checked
          },
          listNavigation: { ...asCheckboxGroupChild.listNavigation
          },
          managedChild: asCheckboxGroupChild.managedChild,
          rovingTabIndex: asCheckboxGroupChild.rovingTabIndex
        });
        return {
          checkboxLike: checkboxReturnType.checkboxLike,
          label: checkboxReturnType.label,
          rovingTabIndex: listNavigationReturnType.rovingTabIndex,
          useCheckboxGroupChildInputProps: props => {
            const {
              useCheckboxInputElementProps
            } = useCheckboxInputElement();
            const ret = useCheckboxInputElementProps(props);
            const ret2 = useListNavigationChildProps(useListNavigationProps(ret));
            return labelPosition == "separate" ? ret2 : ret;
          },
          useCheckboxGroupChildLabelProps: props => {
            const {
              useCheckboxLabelElementProps
            } = useCheckboxLabelElement();
            const ret = useCheckboxLabelElementProps(props);
            const ret2 = useListNavigationChildProps(useListNavigationProps(ret));
            return labelPosition == "wrapping" ? ret2 : ret;
          }
        };
      }, []);
      return {
        useCheckboxGroupChild,
        useCheckboxGroupParentInput,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        managedChildren: listReturnType.managedChildren,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation,
        checkboxGroup: {
          parentIsChecked: getSelfIsCheckedUnstable(),
          parentPercentChecked: checkedCount / (children.getHighestIndex() + 1)
        }
      };
    }

    /**
     * Adds event handlers for a modal-like soft-dismiss interaction.
     *
     * That is, any clicks or taps outside of the given component,
     * or any time the Escape key is pressed within the component,
     * (with various browser oddities regarding clicks on blank or inert areas handled)
     * the component will request to close itself.
     *
     * Of course, if you don't do anything in the `onClose` function,
     * it won't be a soft dismiss anymore.
     *
     * @param param0
     * @returns
     */

    function useSoftDismiss(_ref) {
      let {
        softDismiss: {
          onClose,
          getElements,
          open
        },
        activeElement: {
          onLastActiveElementChange,
          ...activeElement
        }
      } = _ref;
      const stableOnClose = useStableCallback(onClose);
      const stableGetElements = useStableCallback(getElements);
      const getOpen = useStableGetter(open);
      const {
        getDocument
      } = activeElement;
      const onBackdropClick = q$1(function onBackdropClick(e) {
        if (!getOpen()) return;
        const document = getDocument(); // Basically, "was this event fired on the root-most element, or at least an element not contained by the modal?"
        // Either could be how the browser handles these sorts of "interacting with nothing" events.

        if (e.target == (document === null || document === void 0 ? void 0 : document.documentElement)) {
          stableOnClose("backdrop");
        }

        let elements = stableGetElements();

        if (elements && e.target instanceof Element) {
          if (!Array.isArray(elements)) elements = [elements];
          let foundInsideClick = false;

          for (const element of elements) {
            if (element && element.contains(e.target)) {
              foundInsideClick = true;
              break;
            }
          }

          if (!foundInsideClick) {
            onClose("backdrop");
          }
        }
      }, []);
      useActiveElement({ ...activeElement,
        onLastActiveElementChange: q$1((newElement, prev) => {
          onLastActiveElementChange === null || onLastActiveElementChange === void 0 ? void 0 : onLastActiveElementChange(newElement, prev);
          let validFocusableElements = stableGetElements();

          if (validFocusableElements) {
            if (!Array.isArray(validFocusableElements)) validFocusableElements = [validFocusableElements];

            for (const focusable of validFocusableElements) {
              if (focusable !== null && focusable !== void 0 && focusable.contains(newElement)) return;
            }
          }

          onClose("lost-focus");
        }, [])
      });
      const {
        useRefElementProps
      } = useRefElement({
        onElementChange: q$1(e => {
          const document = e === null || e === void 0 ? void 0 : e.ownerDocument;
          const window = document === null || document === void 0 ? void 0 : document.defaultView; // Since everything else is inert, we listen for captured clicks on the window
          // (we don't use onClick since that doesn't fire when clicked on empty/inert areas)
          // Note: We need a *separate* touch event on mobile Safari, because
          // it doesn't let click events bubble or be captured from traditionally non-interactive elements,
          // but touch events work as expected.

          const mouseDown = e => {
            if (getOpen()) onBackdropClick(e);
          };

          const touchStart = e => {
            if (getOpen()) onBackdropClick(e);
          };

          const keyDown = e => {
            if (e.key === "Escape") {
              stableOnClose("escape");
            }
          };

          window === null || window === void 0 ? void 0 : window.addEventListener("mousedown", mouseDown, {
            capture: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("touchstart", touchStart, {
            capture: true
          });
          window === null || window === void 0 ? void 0 : window.addEventListener("keydown", keyDown);
          return () => {
            window === null || window === void 0 ? void 0 : window.removeEventListener("mousedown", mouseDown);
            window === null || window === void 0 ? void 0 : window.removeEventListener("touchstart", touchStart);
            window === null || window === void 0 ? void 0 : window.removeEventListener("keydown", keyDown);
          };
        }, [])
      });
      return {
        useSoftDismissProps: q$1(props => useRefElementProps(props), []),
        softDismiss: {
          onBackdropClick
        }
      };
    }
    /**
     * A generic modal hook, used by modal dialogs, but can also
     * be used by anything that's modal with a backdrop.
     * @param param0
     * @returns
     */

    function useModal(_ref2) {
      var _focusSelf;

      let {
        modal: {
          bodyIsOnlySemantic: descriptive,
          focusSelf
        },
        softDismiss: {
          onClose,
          open
        },
        activeElement
      } = _ref2;
      const {
        useRefElementProps: useTitleRefElementProps,
        getElement: getTitleElement
      } = useRefElement({});
      const {
        useRefElementProps: useBodyRefElementProps,
        getElement: getBodyElement
      } = useRefElement({});
      (_focusSelf = focusSelf) !== null && _focusSelf !== void 0 ? _focusSelf : focusSelf = () => {
        if (descriptive) {
          var _getBodyElement;

          (_getBodyElement = getBodyElement()) === null || _getBodyElement === void 0 ? void 0 : _getBodyElement.focus({
            preventScroll: true
          });
        } else {
          const titleElement = getTitleElement();
          if (titleElement) titleElement.focus({
            preventScroll: true
          });
        } //const elementToFocus = getTitleElement() ?? getBodyElement()

      };
      const stableOnClose = useStableCallback(onClose);
      const stableFocusSelf = useStableCallback(focusSelf); //const [modalDescribedByBody, setModalDescribedByBody] = useState(false);

      useHideScroll(open);
      const {
        useRandomIdSourceElement: useModalIdAsSource,
        useRandomIdReferencerElement: useModalIdAsReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-modal-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useBodyIdAsSource,
        useRandomIdReferencerElement: useBodyIdReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-modal-body-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRandomIdSourceElement: useTitleIdAsSource,
        useRandomIdReferencerElement: useTitleIdReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-modal-title-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const {
        useRefElementProps: useModalRefElement,
        getElement: getModalElement
      } = useRefElement({});
      const {
        softDismiss: {
          onBackdropClick
        },
        useSoftDismissProps
      } = useSoftDismiss({
        softDismiss: {
          onClose: stableOnClose,
          getElements: getModalElement,
          open: !!open
        },
        activeElement
      });
      const useModalBackdrop = q$1(function useModalBackdrop() {
        function useModalBackdropProps(props) {
          return useMergedProps({
            onPointerUp: onBackdropClick
          }, props);
        }

        return {
          useModalBackdropProps
        };
      }, []);

      const useModalFocusContainerProps = function (props) {
        const {
          useFocusTrapProps
        } = useFocusTrap({
          trapActive: open
        });
        return useFocusTrapProps(props);
      };

      const useModalProps = function (_ref3) {
        let {
          "aria-modal": ariaModal,
          role,
          ...p0
        } = _ref3;
        const {
          useRandomIdSourceElementProps: useModalIdAsSourceProps
        } = useModalIdAsSource();
        const {
          useRandomIdReferencerElementProps: useTitleIdReferencerElementProps
        } = useTitleIdReferencerElement("aria-labelledby");
        const {
          useRandomIdReferencerElementProps: useBodyIdReferencerElementProps
        } = useBodyIdReferencerElement("aria-describedby");
        console.assert(!ariaModal);
        const {
          useFocusTrapProps
        } = useFocusTrap({
          trapActive: open
        });
        s(() => {
          if (open) stableFocusSelf();
        }, [open]);
        const p1 = useBodyIdReferencerElementProps(p0);
        const p2 = useModalIdAsSourceProps(p1);
        const pFinal = useTitleIdReferencerElementProps(p2);
        return useFocusTrapProps(useSoftDismissProps(useMergedProps(useModalRefElement({
          role: role || "dialog"
        }), descriptive ? pFinal : p2)));
      };

      const useModalTitle = q$1(function useModalTitle() {
        const {
          useRandomIdSourceElementProps: useTitleIdAsSourceProps
        } = useTitleIdAsSource();

        const useModalTitleProps = function (props) {
          var _props$tabIndex;

          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1;
          return useTitleRefElementProps(useTitleIdAsSourceProps(props));
        };

        return {
          useModalTitleProps
        };
      }, []);
      const useModalBody = q$1(function useModalBody() {
        const {
          useRandomIdSourceElementProps: useBodyIdAsSourceProps
        } = useBodyIdAsSource();
        const {
          useRandomIdReferencerElementProps: useModalIdAsReferencerElementProps
        } = useModalIdAsReferencerElement("data-modal-id");

        const useModalBodyProps = function (props) {
          var _props$tabIndex2;

          (_props$tabIndex2 = props.tabIndex) !== null && _props$tabIndex2 !== void 0 ? _props$tabIndex2 : props.tabIndex = -1;
          return useBodyRefElementProps(useBodyIdAsSourceProps(useModalIdAsReferencerElementProps(props)));
        };

        return {
          useModalBodyProps
        };
      }, []);
      return {
        useModalProps,
        useModalTitle,
        useModalBody,
        useModalBackdrop,
        useModalFocusContainerProps,
        softDismiss: {
          onBackdropClick
        }
      };
    }
    /**
     * Allows for hiding the scroll bar of the root HTML element
     * without shifting the layout of the page more than adding a fow pixels
     * of padding to the root element if necessary.
     * @param hideScroll
     */

    function useHideScroll(hideScroll) {
      const [getScrollbarWidth, setScrollbarWidth] = usePassiveState(null);
      const [getScrollbarHeight, setScrollbarHeight] = usePassiveState(null);
      s(() => {
        if (hideScroll) {
          // When scrolling is resumed, we'll need to restore the original scroll positions
          // so we need to keep this information around
          const originalScrollTop = document.documentElement.scrollTop;
          const originalScrollLeft = document.documentElement.scrollLeft; // Measure the width of the page (minus the scrollbar)

          const widthWithScrollBar = document.documentElement.scrollWidth;
          const heightWithScrollBar = document.documentElement.scrollHeight; // Apply a class that hides the scrollbar.

          document.documentElement.classList.add("document-scroll-hidden"); // In case multiple things are locking scroll, keep track of how many are doing that
          // (just add 1 on enable, subtract 1 on disable)

          document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") + 1).toString(); // Measure the new width without a scrollbar 
          // so we can take the difference as the scrollbar width.

          const widthWithoutScrollBar = document.documentElement.scrollWidth;
          const heightWithoutScrollBar = document.documentElement.scrollHeight;
          let scrollbarWidth = widthWithoutScrollBar - widthWithScrollBar;
          let scrollbarHeight = heightWithoutScrollBar - heightWithScrollBar; // Failsafe -- if this measuring trick does something unexpected, just ignore it

          if (scrollbarWidth > 80) scrollbarWidth = 0;
          if (scrollbarHeight > 80) scrollbarHeight = 0; // Make our measurements available as CSS properties for general use

          document.documentElement.style.setProperty("--root-scrollbar-width", `${scrollbarWidth}px`);
          document.documentElement.style.setProperty("--root-scrollbar-height", `${scrollbarHeight}px`);
          document.documentElement.style.setProperty("--root-scrollstop-top", `${originalScrollTop}px`);
          document.documentElement.style.setProperty("--root-scrollstop-left", `${originalScrollLeft}px`);
          setScrollbarWidth(scrollbarWidth);
          setScrollbarHeight(scrollbarHeight);
          return () => {
            // Undo all the things we just did
            document.documentElement.dataset["scrollHiders"] = (+(document.documentElement.dataset["scrollHiders"] || "0") - 1).toString();

            if (document.documentElement.dataset["scrollHiders"] == "0") {
              // If we were the last scroll-locking thing to stop, then remove the class that stops scrolling.
              document.documentElement.removeAttribute("data-scroll-hiders");
              document.documentElement.classList.remove("document-scroll-hidden"); // Also, restore the original scroll position
              // We do this by forcing the scroll behavior to not be smooth
              // (it's instant if nothing is set to smooth, https://www.w3.org/TR/cssom-view/#scrolling),
              // scrolling, then restoring the original scroll behavior 
              // (which was probably already auto anyway, but just to be safe)

              const originalScrollBehavior = document.documentElement.style.scrollBehavior;
              document.documentElement.style.scrollBehavior = "auto";
              document.documentElement.scrollTo({
                top: originalScrollTop,
                left: originalScrollLeft,
                behavior: "auto"
              });
              document.documentElement.style.scrollBehavior = originalScrollBehavior;
            }
          };
        }
      }, [hideScroll]);
      return {
        getScrollbarWidth,
        getScrollbarHeight
      };
    }

    function useDialog(_ref) {
      let {
        softDismiss: {
          open
        },
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        dialog: {
          onClose
        },
        activeElement
      } = _ref;
      debugLog("useDialog"); // TODO: Differences between dialog and modal go here, presumably.
      // Non-modal dialogs need to be able to be repositioned, etc.

      const {
        useModalBackdrop,
        useModalBody,
        useModalProps,
        useModalTitle,
        softDismiss: {
          onBackdropClick
        },
        useModalFocusContainerProps
      } = useModal({
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        softDismiss: {
          onClose,
          open
        },
        activeElement
      });
      const useDialogBackdrop = q$1(() => {
        const {
          useModalBackdropProps
        } = useModalBackdrop();
        return {
          useDialogBackdropProps: useModalBackdropProps
        };
      }, [useModalBackdrop]);
      const useDialogBody = q$1(() => {
        const {
          useModalBodyProps
        } = useModalBody();
        return {
          useDialogBodyProps: useModalBodyProps
        };
      }, [useModalBackdrop]);
      const useDialogProps = useModalProps;
      const useDialogTitle = q$1(() => {
        const {
          useModalTitleProps
        } = useModalTitle();
        return {
          useDialogTitleProps: useModalTitleProps
        };
      }, [useModalTitle]);
      return {
        useDialogProps,
        useDialogTitle,
        useDialogBody,
        useDialogBackdrop,
        useDialogFocusContainerProps: useModalFocusContainerProps,
        softDismiss: {
          onBackdropClick
        }
      };
    }

    function useListboxSingle(_ref) {
      let {
        listboxSingle: {
          tagLabel,
          tagList,
          onSelect,
          ..._lbs
        },
        singleSelection: {
          selectedIndex,
          ...ss
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti
        },
        typeaheadNavigation: { ...tn
        },
        childrenHaveFocus: { ...chf
        }
      } = _ref;
      debugLog("useListboxSingle", selectedIndex);
      const {
        useLabelInput,
        useLabelLabel,
        ...labelReturnType
      } = useLabel({
        label: {
          prefixLabel: "aria-listbox-label-",
          prefixInput: "aria-listbox-",
          tagInput: tagList,
          tagLabel: tagLabel
        }
      });
      const onSelectedIndexChange = useStableCallback((event, newIndex) => {
        stableOnSelect(enhanceEvent(event, {
          selectedIndex: newIndex
        }));
      });
      const {
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps,
        ...listReturnType
      } = useListNavigationSingleSelection({
        childrenHaveFocus: { ...chf
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti
        },
        singleSelection: { ...ss,
          onSelectedIndexChange,
          selectedIndex
        },
        typeaheadNavigation: tn
      });
      const {
        useLabelInputProps
      } = useLabelInput();
      const stableOnSelect = useStableCallback(onSelect !== null && onSelect !== void 0 ? onSelect : () => {});
      const useListboxSingleItem = q$1(_ref2 => {
        let {
          listboxSingleItem: {
            disabled
          },
          listNavigation,
          managedChild,
          rovingTabIndex,
          hasFocus
        } = _ref2;
        debugLog("useListboxSingleItem", managedChild.index);
        const {
          rovingTabIndex: rti_ret,
          singleSelection: ss_ret,
          useListNavigationSingleSelectionChildProps
        } = useListNavigationSingleSelectionChild({
          managedChild,
          listNavigation,
          rovingTabIndex,
          hasFocus,
          subInfo: {}
        }); //const index = managedChild.index;

        /*useEffect(() => {
            const element = rti_ret.getElement();
            if (element && rti_ret.tabbable && selectionMode == "focus") {
                stableOnSelect?.({ target: element, currentTarget: element, [EventDetail]: { selectedIndex: index } });
            }
        }, [rti_ret.tabbable, selectionMode, index]);*/

        return {
          useListboxSingleItemProps,
          rovingTabIndex: rti_ret,
          singleSelection: ss_ret
        };

        function useListboxSingleItemProps(props) {
          var _ss_ret$selected;

          /*const newProps: h.JSX.HTMLAttributes<ListItemElement> = usePressEventHandlers<ListItemElement>(disabled ? null : (e) => {
              const element = rti_ret.getElement();
              if (element)
                  stableOnSelect?.({ target: element, currentTarget: element, [EventDetail]: { selectedIndex: index } });
              e.preventDefault();
          }, undefined);*/
          props.role = "option"; //props["aria-setsize"] = (children.getHighestIndex() + 1).toString();
          //props["aria-posinset"] = (info.index + 1).toString();

          props["aria-selected"] = ((_ss_ret$selected = ss_ret.selected) !== null && _ss_ret$selected !== void 0 ? _ss_ret$selected : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useListNavigationSingleSelectionChildProps(props);
        }
      }, [useListNavigationSingleSelectionChild]);
      const useListboxSingleLabel = q$1(function useListboxSingleLabel() {
        function useListboxSingleLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxSingleLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxSingleItem,
        useListboxSingleProps,
        useListboxSingleLabel,
        ...listReturnType,
        ...labelReturnType
        /*label: labelReturnType.label,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        managedChildren: listReturnType.managedChildren,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation*/

      };

      function useListboxSingleProps(props) {
        props.role = "listbox";
        return useListNavigationSingleSelectionProps(useLabelInputProps(props));
      }
    }
    function useListboxGroup() {
      const {
        useRandomIdReferencerElement,
        useRandomIdSourceElement
      } = useRandomId({
        randomId: {
          prefix: "listbox-multi-group"
        },
        managedChildren: {}
      });
      const {
        useRandomIdSourceElementProps
      } = useRandomIdSourceElement();
      const {
        useRandomIdReferencerElementProps
      } = useRandomIdReferencerElement("aria-labelledby");

      const useListboxGroupHeadingProps = props => {
        return useRandomIdSourceElementProps(props);
      };

      const useListboxGroupContainerProps = _ref3 => {
        let {
          role,
          ...props
        } = _ref3;
        return useRandomIdReferencerElementProps({
          role: warnOnOverwrite("useListboxMultiGroupProps", "role", role, "group"),
          ...props
        });
      };

      return {
        useListboxGroupContainerProps,
        useListboxGroupHeadingProps
      };
    }

    /*export interface UseListboxMultiReturnType<LabelElement extends Element, ListElement extends Element, ListItemElement extends Element> extends Omit<UseListNavigationReturnType<ListElement, ListItemElement, {}, never>, "useListNavigationChild" | "useListNavigationProps"> {
        useListboxMultiItem: UseListboxMultiItem<ListItemElement>;
        useListboxMultiProps: (props: h.JSX.HTMLAttributes<ListElement>) => h.JSX.HTMLAttributes<ListElement>;
        useListboxMultiLabel: () => { useListboxMultiLabelProps: (props: h.JSX.HTMLAttributes<LabelElement>) => h.JSX.HTMLAttributes<LabelElement>; }
    }*/

    function useListboxMulti(_ref) {
      let {
        listboxMulti: {
          tagLabel,
          tagList
        },
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          ...rti
        },
        typeaheadNavigation: { ...tn
        }
      } = _ref;
      debugLog("useListboxMulti"); //const { useHasFocusProps, getFocusedInner } = useHasFocus<ListElement>({});

      const {
        useLabelInput,
        useLabelLabel
      } = useLabel({
        label: {
          prefixLabel: "aria-listbox-label-",
          prefixInput: "aria-listbox-",
          tagLabel: tagLabel,
          tagInput: tagList
        }
      });
      const listReturnType = useListNavigation({
        linearNavigation: { ...ln
        },
        listNavigation: { ...ls
        },
        managedChildren: { ...mc
        },
        rovingTabIndex: { ...rti,
          onTabbableIndexChange: useStableCallback(i => {
            onTabbableIndexChange === null || onTabbableIndexChange === void 0 ? void 0 : onTabbableIndexChange(i);
            /*if (selectionMode == "focus") {
                const target = (children.getAt(i!)?.subInfo.getElement());
                if (target)
                    onSelect?.({ target, currentTarget: target, [EventDetail]: { selectedIndex: i! } });
            }*/
          })
        },
        typeaheadNavigation: tn
      });
      const {
        useListNavigationChild,
        useListNavigationProps,
        rovingTabIndex: {
          setTabbableIndex
        }
      } = listReturnType;
      const {
        useLabelInputProps
      } = useLabelInput();
      const [getShiftHeld, setShiftHeld] = usePassiveState(null, returnFalse$1);
      const useListboxMultiItem = q$1(_ref2 => {
        let {
          listboxMultiItem: {
            selected,
            disabled,
            onSelectedChange
          },
          managedChild,
          listNavigation: ls,
          rovingTabIndex: rti
        } = _ref2;
        debugLog("useListboxMultiItem", managedChild.index, selected);
        const getSelected = useStableGetter(selected);
        const {
          useRefElementProps,
          getElement
        } = useRefElement({});
        const stableOnSelect = useStableCallback(onSelectedChange !== null && onSelectedChange !== void 0 ? onSelectedChange : () => {});
        const {
          useListNavigationChildProps,
          rovingTabIndex: rti2_ret
        } = useListNavigationChild({
          listNavigation: ls,
          managedChild,
          rovingTabIndex: rti,
          subInfo: {
            selected,
            onSelect: stableOnSelect
          }
        });
        _(() => {
          const element = getElement();

          if (element && getShiftHeld()) {
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({
              target: element,
              currentTarget: element,
              [EventDetail]: {
                selected: true
              }
            });
          }
        }, [rti2_ret.tabbable]);
        return {
          useListboxMultiItemProps,
          listboxMultiItem: {
            getSelected,
            tabbable: rti2_ret.tabbable
          },
          rovingTabIndex: rti2_ret
        };

        function useListboxMultiItemProps(props) {
          var _rti2_ret$tabbable;

          const usePressProps = usePress(disabled ? null : e => {
            setTabbableIndex(managedChild.index, false);
            stableOnSelect === null || stableOnSelect === void 0 ? void 0 : stableOnSelect({ ...e,
              [EventDetail]: {
                selected: !getSelected()
              }
            });
            e.preventDefault();
          }, {});
          props.role = "option"; //props["aria-setsize"] = (childCount).toString();
          //props["aria-posinset"] = (info.index + 1).toString();

          props["aria-selected"] = ((_rti2_ret$tabbable = rti2_ret.tabbable) !== null && _rti2_ret$tabbable !== void 0 ? _rti2_ret$tabbable : false).toString();
          if (disabled) props["aria-disabled"] = "true";
          return useRefElementProps(useListNavigationChildProps(usePressProps(props)));
        }
      }, [useListNavigationChild]);
      const useListboxMultiLabel = q$1(function useListboxMultiLabel() {
        function useListboxMultiLabelProps(props) {
          const {
            useLabelLabelProps
          } = useLabelLabel();
          return useLabelLabelProps(props);
        }

        return {
          useListboxMultiLabelProps
        };
      }, [useLabelLabel]);
      return {
        useListboxMultiItem,
        useListboxMultiProps,
        useListboxMultiLabel,
        linearNavigation: listReturnType.linearNavigation,
        listNavigation: listReturnType.listNavigation,
        rovingTabIndex: listReturnType.rovingTabIndex,
        typeaheadNavigation: listReturnType.typeaheadNavigation,
        managedChildren: listReturnType.managedChildren
      };

      function useListboxMultiProps(props) {
        props.role = "listbox";
        props["aria-multiselectable"] = "true";
        return useListNavigationProps(useLabelInputProps(useMergedProps({
          onKeyDown,
          onKeyUp,
          onfocusout: onFocusOut
        }, props)));
      }

      function onKeyDown(e) {
        if (e.key == "Shift") setShiftHeld(true);
      }

      function onKeyUp(e) {
        if (e.key == "Shift") setShiftHeld(false);
      }

      function onFocusOut(_) {
        setShiftHeld(false);
      }
    }

    //export type UseMenuChildParameters<I extends UseMenuChildInfo> = I;

    /**
     * A menu is a popup control that contains a list of menu items, and that's it.
     * It has very well-defined logic for managing those items as the menu's state changes.
     *
     * A MenuBase is just the "popup" part without the "list of menu items" part. It can
     * (really, must) have interactive controls, but these controls are allowed to be more
     * free-form. This means that, like a dialog, you must tell this hook
     * where within the popup to send focus when opened (for a menu it's just the first
     * menu item, but with custom content you'll need to provide this).
     *
     */

    function useMenuSurface(_ref) {
      var _intersectionObserver;

      let {
        softDismiss,
        menuSurface: {
          sendFocusToMenu,
          role
        },
        activeElement
      } = _ref;
      debugLog("useMenuSurface"); //const sendFocusWithinMenu = useStableCallback(sendFocusToMenu);
      //const [focusTrapActive, setFocusTrapActive] = useState<null | boolean>(null);

      const {
        open,
        onClose: userOnClose
      } = softDismiss;
      const onClose = useStableCallback(reason => {
        if (reason != "lost-focus") {
          const opener = getOpenerElement();
          if (opener && "focus" in opener) opener.focus({
            preventScroll: true
          });
        }

        return userOnClose(reason);
      });
      useEnsureStability("useMenuSurface", onClose, role, sendFocusToMenu);
      const getIsOpen = useStableGetter(open);
      const intersectionObserver = A(null);
      const [getSurfaceFullyVisible, setSurfaceFullyVisible] = usePassiveState(null, returnFalse$1);
      (_intersectionObserver = intersectionObserver.current) !== null && _intersectionObserver !== void 0 ? _intersectionObserver : intersectionObserver.current = new IntersectionObserver((entries, _observer) => {
        for (const entry of entries) {
          setSurfaceFullyVisible(entry.intersectionRatio >= 1);
        }
      }, {
        root: null,
        threshold: [0, 1]
      });
      const [, setOpenerElement, getOpenerElement] = useState(null); //const { useHasFocusProps: useMenuBaseHasFocusProps, ...surfaceHasFocus } = useHasFocus<MenuSurfaceElement>({ ...hasFocusSurface });
      //const { useHasFocusProps: useButtonHasFocusProps, ...buttonHasFocus } = useHasFocus<MenuButtonElement>({ ...hasFocusButton });
      //const { getLastFocusedInner: getMenuBaseLastFocusedInner } = surfaceHasFocus;

      const {
        useRandomIdSourceElement,
        useRandomIdReferencerElement
      } = useRandomId({
        randomId: {
          prefix: "aria-menu-"
        },
        managedChildren: {}
      });
      const {
        useRandomIdSourceElementProps
      } = useRandomIdSourceElement();
      const {
        useRandomIdReferencerElementProps
      } = useRandomIdReferencerElement("aria-controls");
      const {
        getElement: getButtonElement,
        useRefElementProps: useButtonRefElementProps
      } = useRefElement({
        onElementChange: setOpenerElement
      });
      const {
        getElement: getMenuElement,
        useRefElementProps: useMenuBaseRefElementProps
      } = useRefElement({});
      const {
        useSoftDismissProps,
        ...softDismissReturn
      } = useSoftDismiss({
        softDismiss: { ...softDismiss,
          getElements: () => [getButtonElement(), getMenuElement()]
        },
        activeElement
      });

      const useMenuSurfaceProps = props => {
        function onKeyDown(e) {
          const open = getIsOpen();

          if (e.key == "Escape" && open) {
            onClose("escape");
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.preventDefault();
          }
        }

        return useSoftDismissProps(useMenuBaseRefElementProps(useMergedProps({
          onKeyDown
        }, props)));
      };

      const useMenuSurfaceButtonProps = props => {
        props["aria-expanded"] = warnOnOverwrite("useMenuSurfaceButtonProps", "aria-expanded", open, open.toString());
        props["aria-haspopup"] = warnOnOverwrite("useMenuSurfaceButtonProps", "aria-haspopup", role, role);
        return useButtonRefElementProps(useRandomIdReferencerElementProps(props));
      };

      s(() => {
        if (open === true) {
          sendFocusToMenu === null || sendFocusToMenu === void 0 ? void 0 : sendFocusToMenu();
          setTimeout(() => {
            if (!getSurfaceFullyVisible()) {
              var _getMenuElement;

              (_getMenuElement = getMenuElement()) === null || _getMenuElement === void 0 ? void 0 : _getMenuElement.scrollIntoView();
            }
          });
        }
      }, [open]);

      function useMenuSurfaceChildProps(props) {
        props.role = role;
        return useRandomIdSourceElementProps(props);
      }

      return {
        useMenuSurfaceChildProps,
        useMenuSurfaceSentinel: q$1(() => {
          debugLog("useMenuSurfaceSentinel");
          const {
            useSentinelProps: useMenuSentinelProps,
            ...rest
          } = useFocusSentinel({
            focusSentinel: {
              open: open === true,
              onClose: () => onClose("escape"),
              sendFocusToMenu
            }
          });
          return {
            useMenuSentinelProps,
            ...rest
          };
        }, [open, onClose]),
        useMenuSurfaceProps,
        useMenuSurfaceButtonProps,
        menuSurface: {
          /*getActiveElement: buttonHasFocus.getActiveElement,
          getLastActiveElement: buttonHasFocus.getLastActiveElement,
          getButtonElement: buttonHasFocus.getElement,
          getButtonFocused: buttonHasFocus.getFocused,
          getButtonFocusedInner: buttonHasFocus.getFocusedInner,
          getButtonLastFocused: buttonHasFocus.getLastFocused,
          getButtonLastFocusedInner: buttonHasFocus.getLastFocusedInner,
          getSurfaceElement: surfaceHasFocus.getElement,
          getSurfaceFocused: surfaceHasFocus.getFocused,
          getSurfaceFocusedInner: surfaceHasFocus.getFocusedInner,
          getSurfaceLastFocused: surfaceHasFocus.getLastFocused,
          getSurfaceLastFocusedInner: surfaceHasFocus.getLastFocusedInner,
          getWindowFocused: buttonHasFocus.getWindowFocused,*/
        },
        ...softDismissReturn //getMenuBaseLastFocusedInner,
        //getMenuBaseButtonLastFocusedInner,
        //open,
        //onOpen,
        //onClose

      };
    } // A focus sentinal is a hidden but focusable element that comes at the start or end 
    // of the out-of-place-focusable component that, when activated or focused over, closes the component
    // (if focused within 100ms of the open prop changing, instead of
    // closing, focusing the sentinel immediately asks it to focus itself).
    // This exists for things like menus which can have focus but also need a way to return
    // to whatever out-of-place parent they came from when naturally tabbed out of (as opposed
    // to dialogs which loop back around when tabbed out of). While mouse users can click out of a menu
    // and keyboard users can escape to close a menu, screen readers and other input methods 
    // that don't use those two would become stuck.

    function useFocusSentinel(_ref2) {
      let {
        focusSentinel: {
          open,
          onClose,
          sendFocusToMenu
        }
      } = _ref2;
      debugLog("useFocusSentinel");
      const getSendFocusWithinMenu = useStableGetter(sendFocusToMenu);
      const stableOnClose = useStableCallback(onClose);
      const [firstSentinelIsActive, setFirstSentinelIsActive] = useState(false);
      useTimeout({
        callback: () => {
          setFirstSentinelIsActive(open);
        },
        timeout: 100,
        triggerIndex: `${open}-${firstSentinelIsActive}`
      });
      const onFocus = firstSentinelIsActive ? () => stableOnClose() : () => {
        var _getSendFocusWithinMe;

        return (_getSendFocusWithinMe = getSendFocusWithinMenu()) === null || _getSendFocusWithinMe === void 0 ? void 0 : _getSendFocusWithinMe();
      };

      const onClick = () => stableOnClose();

      return {
        useSentinelProps: function (_ref3) {
          let {
            tabIndex,
            ...p
          } = _ref3;
          return useMergedProps({
            onFocus,
            onClick,
            tabIndex: warnOnOverwrite("useFocusSentinel", "tabIndex", tabIndex, 0)
          }, p);
        }
      };
    }
    function useMenu(_ref4) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        menuSurface,
        rovingTabIndex,
        softDismiss,
        typeaheadNavigation,
        menu,
        activeElement
      } = _ref4;
      debugLog("useMenu");
      const {
        onOpen
      } = menu;
      const {
        open,
        onClose
      } = softDismiss;
      const {
        useListNavigationChild,
        useListNavigationProps,
        ...useListNavReturn
      } = useListNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children
        }
      } = useListNavReturn;
      const {
        /*useMenuSentinel,
        useMenuBaseButtonProps,
        useMenuBaseProps,
        open,
        onOpen,
        onClose: _onClose,*/
        useMenuSurfaceButtonProps,
        useMenuSurfaceProps,
        useMenuSurfaceSentinel,
        useMenuSurfaceChildProps,
        ...menuRest
      } = useMenuSurface({
        menuSurface: { ...menuSurface,
          role: "menu",
          sendFocusToMenu: q$1(() => {
            var _children$getAt;

            return (_children$getAt = children.getAt(0)) === null || _children$getAt === void 0 ? void 0 : _children$getAt.subInfo.focusSelf();
          }, [])
        },
        softDismiss,
        //hasFocusButton,
        //hasFocusSurface,
        activeElement //sendFocusWithinMenu: focusMenu ?? (() => { })

      });

      const useMenuButtonProps = p => {
        const usePressProps = usePress(() => {
          if (open) onClose === null || onClose === void 0 ? void 0 : onClose("escape");else onOpen === null || onOpen === void 0 ? void 0 : onOpen();
        }, {});
        const props = useMenuSurfaceButtonProps(p);
        return usePressProps(props);
      };

      const useMenuItem = q$1(_ref5 => {
        let {
          listNavigation,
          managedChild,
          rovingTabIndex
        } = _ref5;
        debugLog("useMenuItem", managedChild.index);
        const {
          useListNavigationChildProps,
          ...listNavRet
        } = useListNavigationChild({
          listNavigation,
          managedChild,
          rovingTabIndex,
          subInfo: {}
        });

        function useMenuItemProps(_ref6) {
          let { ...props
          } = _ref6;
          props.role = "menuitem";
          return useMergedProps({}, useListNavigationChildProps(props));
        }

        return {
          useMenuItemProps,
          ...listNavRet
        };
      }, []);

      function useMenuProps(props) {
        return useListNavigationProps(useMenuSurfaceChildProps(props));
      }

      return {
        useMenuProps,
        useMenuSurfaceProps,
        useMenuButtonProps,
        useMenuItem,
        useMenuSentinel: useMenuSurfaceSentinel,
        //useMenuSubmenuItem,
        ...useListNavReturn,
        ...menuRest
        /*focusMenu,
         currentTypeahead,
        invalidTypeahead,
         managedChildren,*/

      };
    }

    /*
    export function useTabs<TabListElement extends Element, TabElement extends Element, PanelElement extends Element, LabelElement extends Element>({ tabPanels: { managedChildren: { onChildrenMountChange: ocmc, ...tabPanelsManagedChildren } } }: UseTabsParameters): UseTabsReturnTypeWithHooks<TabListElement, TabElement, PanelElement, LabelElement> {
        const {
            useListNavigationSingleSelectionChild,
            useListNavigationSingleSelectionProps
        } = useListNavigationSingleSelection<TabListElement, TabElement, TabInfo, never>({
            childrenHaveFocus: {},
            linearNavigation: {},
            listNavigation: {},
            managedChildren: {},
            rovingTabIndex: {},
            singleSelection: {},
            typeaheadNavigation: {}
         });

        const useTab = useCallback(() => {}, []);
        const useTabPanel = useCallback(() => {});
        function useTabListProps(props: h.JSX.HTMLAttributes<TabListElement>) { return useListNavigationSingleSelectionProps(props); }
        function useTabLabelProps() {}

        return {

        }
        
    }*/

    function useTabs(_ref) {
      let {
        tabPanels: {
          managedChildren: {
            onChildrenMountChange: ocmc,
            ...tabPanelsManagedChildren
          }
        }
      } = _ref;
      debugLog("useTabs");
      const baseId = generateRandomId("aria-tabs-"); //const getTabListId = useCallback(() => { return baseId + "-tab-list"; }, []);

      const getTabId = q$1(index => {
        return baseId + "-tab-" + index;
      }, []);
      const getPanelId = q$1(index => {
        return baseId + "-panel-" + index;
      }, []); // Used for the panels, not the tabs in the tablist.
      // Those are in useTabList itself.

      const {
        useManagedChild,
        ...managedChildrenRet
      } = useManagedChildren({
        managedChildren: { ...tabPanelsManagedChildren,
          onChildrenMountChange: useStableCallback((m, u) => {
            ocmc === null || ocmc === void 0 ? void 0 : ocmc(m, u);
            reevaluateClosestFit();
          })
        }
      });
      const {
        changeIndex: changeVisiblePanel,
        getCurrentIndex: getVisibleIndex,
        reevaluateClosestFit
      } = useChildrenFlag({
        children: managedChildrenRet.managedChildren.children,
        closestFit: false,
        initialIndex: null,
        key: "visible"
      }); //const { useRandomIdReferencerElement, useRandomIdSourceElement } = useRandomId({ randomId: { prefix: "aria-tabs-" }, managedChildren: { onAfterChildLayoutEffect: null, onChildrenMountChange: null } });

      const {
        useLabelInput,
        useLabelLabel
      } = useLabel({
        label: {
          prefixInput: "",
          prefixLabel: "",
          tagInput: "div",
          tagLabel: "div"
        }
      });
      const useTabListLabel = q$1(() => {
        const {
          useLabelLabelProps
        } = useLabelLabel();

        function useTabListLabelProps(props) {
          return useLabelLabelProps(props);
        }

        return {
          useTabListLabelProps
        };
      }, [useLabelLabel]);
      const useTabList = q$1(_ref2 => {
        let {
          childrenHaveFocus,
          tabs: {
            onSelectedIndexChange
          },
          linearNavigation,
          listNavigation,
          managedChildren: tabListManagedChildren,
          rovingTabIndex,
          singleSelection,
          typeaheadNavigation
        } = _ref2;
        debugLog("useTabList");
        const stableOnSelectedIndexChange = useStableCallback(onSelectedIndexChange);
        const {
          useListNavigationSingleSelectionChild,
          useListNavigationSingleSelectionProps,
          ...listNavRet1
        } = useListNavigationSingleSelection({
          linearNavigation,
          listNavigation,
          managedChildren: tabListManagedChildren,
          rovingTabIndex,
          singleSelection: { ...singleSelection,
            onSelectedIndexChange: q$1((event, index) => {
              onSelectedIndexChange === null || onSelectedIndexChange === void 0 ? void 0 : onSelectedIndexChange(enhanceEvent(event, {
                selectedIndex: index
              }));
            }, [])
          },
          typeaheadNavigation,
          childrenHaveFocus
        });
        s(() => {
          changeVisiblePanel(singleSelection.selectedIndex);
        }, [singleSelection.selectedIndex]);
        const {
          useLabelInputProps
        } = useLabelInput();
        const useTab = q$1(_ref3 => {
          let {
            listNavigation,
            managedChild,
            rovingTabIndex,
            hasFocus
          } = _ref3;
          debugLog("useTab", managedChild.index);
          const {
            useListNavigationSingleSelectionChildProps,
            ...listNavRet2
          } = useListNavigationSingleSelectionChild({
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo: {},
            hasFocus
          });
          const {
            singleSelection: {
              selected
            },
            rovingTabIndex: {
              tabbable
            }
          } = listNavRet2;

          const useTabProps = _ref4 => {
            let {
              role,
              "aria-controls": ariaControls,
              "aria-selected": ariaSelected,
              ...props
            } = _ref4;
            const panelId = getPanelId(managedChild.index);
            const tabId = getTabId(managedChild.index);
            const usePressProps = usePress(e => {
              stableOnSelectedIndexChange(enhanceEvent(e, {
                selectedIndex: managedChild.index
              }));
            }, {});
            return useListNavigationSingleSelectionChildProps(useMergedProps({
              role: warnOnOverwrite("useTab", "role", role, "tab"),
              "aria-controls": warnOnOverwrite("useTab", "ariaControls", ariaControls, panelId),
              "aria-selected": warnOnOverwrite("useTab", "ariaSelected", ariaSelected, selected ? "true" : undefined),
              "data-tabbable": tabbable.toString(),
              id: tabId
            }, usePressProps(props)));
          };

          return {
            useTabProps,
            ...listNavRet2
          };
        }, [useLabelInput, useListNavigationSingleSelectionChild]);

        const useTabListProps = _ref5 => {
          let {
            role,
            "aria-orientation": ariaOrientation,
            ...props
          } = _ref5;
          return useListNavigationSingleSelectionProps(useLabelInputProps(useMergedProps({
            role: warnOnOverwrite("useTabList", "role", role, "tablist"),
            "aria-orientation": ariaOrientation !== null && ariaOrientation !== void 0 ? ariaOrientation : "horizontal"
          }, props)));
        };

        return {
          tabList: listNavRet1,
          useTabListProps,
          useTab
        };
      }, [useLabelInput]);
      const useTabPanel = q$1(_ref6 => {
        let {
          managedChild: {
            flags,
            ...managedChild
          }
        } = _ref6;
        debugLog("useTabPanel", managedChild.index); //const [correspondingTabId, setCorrespondingTabId] = useState<string | null>(null);

        const [isVisible, setIsVisible, getIsVisible] = useState(getVisibleIndex() == managedChild.index);
        const visibleRef = A({
          get: getIsVisible,
          set: setIsVisible,
          isValid: returnTrue
        });
        useManagedChild({
          managedChild: { ...managedChild,
            flags: {
              visible: visibleRef.current,
              ...flags
            },
            subInfo: {}
          }
        });
        const panelId = getPanelId(managedChild.index);
        const tabId = getTabId(managedChild.index);

        const useTabPanelProps = _ref7 => {
          let {
            role,
            "aria-labelledby": ariaLabelledBy,
            id,
            ...props
          } = _ref7;
          return useMergedProps({
            role: warnOnOverwrite("useTabPanelProps", "role", role, "tabpanel"),
            "aria-labelledby": warnOnOverwrite("useTabPanelProps", "aria-labelledby", ariaLabelledBy, tabId),
            id: warnOnOverwrite("useTabPanelProps", "id", id, panelId)
          }, props);
        };

        return {
          useTabPanelProps,
          tabPanel: {
            visible: isVisible,
            getVisible: getIsVisible
          }
        };
      }, []);
      return {
        useTabListLabel,
        useTabList,
        useTabPanel,
        tabPanels: managedChildrenRet
      };
    }

    function returnFalse() {
      return false;
    }

    function useTooltip(_ref) {
      var _mouseoverDelay, _mouseoutDelay, _focusDelay;

      let {
        mouseoverDelay,
        mouseoutDelay,
        focusDelay
      } = _ref;
      debugLog("useTooltip");
      (_mouseoverDelay = mouseoverDelay) !== null && _mouseoverDelay !== void 0 ? _mouseoverDelay : mouseoverDelay = 400;
      (_mouseoutDelay = mouseoutDelay) !== null && _mouseoutDelay !== void 0 ? _mouseoutDelay : mouseoutDelay = 40;
      (_focusDelay = focusDelay) !== null && _focusDelay !== void 0 ? _focusDelay : focusDelay = 1; // The escape key should close tooltips, but do nothing else.
      // (i.e. closing a tooltip in a dialog MUST NOT close the dialog too)
      // TODO: Tooltips are, effectively, always the topmost component,
      // so we can just have them listen to and swallow all "Escape"
      // key presses before anyone else. For a more general popup,
      // or a tooltip in a tooltip (!!) a different solution would be needed.

      useGlobalHandler(document, "keydown", e => {
        if (getOpen() && e.key === "Escape" && !e.defaultPrevented) {
          e.preventDefault();
          e.stopImmediatePropagation();
          setOpen(false);
          setTriggerHoverDelayCorrected(false);
          setTooltipHoverDelayCorrected(false);
          setTriggerFocusedDelayCorrected(false);
          setTooltipFocusedDelayCorrected(false);
        }
      }, {
        capture: true
      });
      const [open, setOpen, getOpen] = useState(false);
      const {
        useRandomIdSourceElement,
        //: useTooltipIdProps, 
        useRandomIdReferencerElement //: useTooltipIdReferencingProps 

      } = useRandomId({
        randomId: {
          prefix: "aria-tooltip-"
        },
        managedChildren: {
          onAfterChildLayoutEffect: null,
          onChildrenMountChange: null
        }
      });
      const [, setTriggerFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTriggerFocusedDelayCorrected(focused), focused ? focusDelay : 1);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTooltipFocused] = usePassiveState(useStableCallback(focused => {
        const delay = focused ? focusDelay : 1;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTooltipFocusedDelayCorrected(focused), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTriggerHover] = usePassiveState(useStableCallback(hovering => {
        const delay = hovering ? mouseoverDelay : mouseoutDelay;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTriggerHoverDelayCorrected(hovering), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [, setTooltipHover] = usePassiveState(useStableCallback(hovering => {
        const delay = hovering ? mouseoverDelay : mouseoutDelay;

        if (delay != null && isFinite(delay)) {
          const handle = setTimeout(() => setTooltipHoverDelayCorrected(hovering), delay);
          return () => clearTimeout(handle);
        }
      }), returnFalse);
      const [triggerFocusedDelayCorrected, setTriggerFocusedDelayCorrected] = useState(false);
      const [triggerHoverDelayCorrected, setTriggerHoverDelayCorrected] = useState(false);
      const [tooltipFocusedDelayCorrected, setTooltipFocusedDelayCorrected] = useState(false);
      const [tooltipHoverDelayCorrected, setTooltipHoverDelayCorrected] = useState(false);
      s(() => {
        setOpen(triggerFocusedDelayCorrected || triggerHoverDelayCorrected || tooltipFocusedDelayCorrected || tooltipHoverDelayCorrected);
      }, [triggerFocusedDelayCorrected || triggerHoverDelayCorrected || tooltipFocusedDelayCorrected || tooltipHoverDelayCorrected]);
      const useTooltipTrigger = q$1(function useTooltipTrigger(_ref2) {
        let {
          hasFocus: {
            onFocusedInnerChanged,
            ...hasFocus
          }
        } = _ref2;
        debugLog("useTooltipTrigger");
        useGlobalHandler(document, "pointermove", e => {
          var _getElement;

          const target = e.target;
          setTriggerHover(target == getElement() || !!((_getElement = getElement()) !== null && _getElement !== void 0 && _getElement.contains(target)));
        }, {
          capture: true
        });

        function onTouchEnd(e) {
          e.target.focus();
        }

        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({ ...hasFocus,
          onFocusedInnerChanged: useStableCallback((focused, prev) => {
            onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);
            setTriggerFocused(focused);
          })
        });

        function useTooltipTriggerProps(_ref3) {
          var _props$tabIndex;

          let { ...props
          } = _ref3;
          const {
            useRandomIdReferencerElementProps
          } = useRandomIdReferencerElement("aria-describedby"); // Note: Though it's important to make sure that focusing activates a tooltip,
          // it's perfectly reasonable that a child element will be the one that's focused,
          // not this one, so we don't set tabIndex=0

          (_props$tabIndex = props.tabIndex) !== null && _props$tabIndex !== void 0 ? _props$tabIndex : props.tabIndex = -1;
          return useRandomIdReferencerElementProps(useHasFocusProps(useMergedProps({
            onTouchEnd
          }, props)));
        }

        return {
          useTooltipTriggerProps
        };
      }, []);
      const useTooltipPopup = q$1(function useTooltip(_ref4) {
        let {
          hasFocus: {
            onFocusedInnerChanged,
            ...hasFocus
          }
        } = _ref4;
        debugLog("useTooltipTooltip");
        const {
          useRandomIdSourceElementProps
        } = useRandomIdSourceElement();
        const {
          useHasFocusProps,
          getElement
        } = useHasFocus({
          onFocusedInnerChanged: useStableCallback((focused, prev) => {
            onFocusedInnerChanged === null || onFocusedInnerChanged === void 0 ? void 0 : onFocusedInnerChanged(focused, prev);
            setTooltipFocused(focused);
          }),
          ...hasFocus
        });
        useGlobalHandler(document, "pointermove", e => {
          var _getElement2;

          const target = e.target;
          setTooltipHover(target == getElement() || !!((_getElement2 = getElement()) !== null && _getElement2 !== void 0 && _getElement2.contains(target)));
        }, {
          capture: true
        });

        function useTooltipPopupProps(_ref5) {
          let { ...props
          } = _ref5;
          return useRandomIdSourceElementProps(useHasFocusProps(useMergedProps({}, props)));
        }

        return {
          useTooltipPopupProps
        };
      }, []);
      return {
        useTooltipPopup,
        useTooltipTrigger,
        isOpen: open,
        getIsOpen: getOpen
      };
    }

    function useRadioGroup(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        radioGroup: {
          name,
          onSelectedValueChange,
          selectedValue,
          tagGroup,
          tagGroupLabel
        },
        rovingTabIndex,
        typeaheadNavigation,
        childrenHaveFocus,
        singleSelection: {
          selectionMode
        }
      } = _ref;
      debugLog("useRadioGroup", selectedValue);
      const {
        getElement: _getRadioGroupParentElement,
        useRefElementProps
      } = useRefElement({}); //const getSelectedIndex = useCallback((selectedValue: V) => { return byName.current.get(selectedValue) ?? 0 }, [])

      const [selectedIndex, setSelectedIndex] = useState(0);
      const byName = A(new Map()); //const stableOnInput = useStableCallback(onSelectedValueChange);
      //const [anyRadiosFocused, setAnyRadiosFocused, getAnyRadiosFocused] = useState(false);

      const {
        useLabelInput: useGroupLabelInput,
        useLabelLabel: useGroupLabelLabel
      } = useLabel({
        label: {
          prefixLabel: "aria-radio-group-label-",
          tagInput: tagGroup,
          tagLabel: tagGroupLabel,
          prefixInput: "aria-radio-group-"
        }
      });
      const {
        useLabelInputProps: useGroupLabelInputProps
      } = useGroupLabelInput();
      const {
        useLabelLabelProps: useGroupLabelLabelProps
      } = useGroupLabelLabel();
      const onSelectedIndexChange = useStableCallback((e, newIndex) => {
        var _listNavRet$managedCh;

        onSelectedValueChange(enhanceEvent(e, {
          selectedValue: (_listNavRet$managedCh = listNavRet.managedChildren.children.getAt(newIndex)) === null || _listNavRet$managedCh === void 0 ? void 0 : _listNavRet$managedCh.subInfo.subInfo.subInfo.getValue()
        }));
      });
      const {
        useListNavigationSingleSelectionChild,
        useListNavigationSingleSelectionProps,
        ...listNavRet
      } = useListNavigationSingleSelection({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        singleSelection: {
          selectedIndex,
          onSelectedIndexChange,
          selectionMode
        },
        typeaheadNavigation,
        childrenHaveFocus
      }); // Track whether the currently focused element is a child of the radio group parent element.
      // When it's not, we reset the tabbable index back to the currently selected element.
      //const { useActiveElementProps } = useActiveElement<G>({ onActiveElementChange: useCallback((activeElement: Node | null) => setAnyRadiosFocused(!!(getRadioGroupParentElement()?.contains(activeElement))), []) });

      /*useEffect(() => {
          if (!anyRadiosFocused)
              navigateToIndex(selectedIndex ?? 0);
      }, [anyRadiosFocused, selectedIndex, navigateToIndex]);*/

      const useRadioGroupProps = q$1(_ref2 => {
        let { ...props
        } = _ref2;
        props.role = "radiogroup";
        return useGroupLabelInputProps(useListNavigationSingleSelectionProps(useRefElementProps(props)));
      }, [useRefElementProps]);
      const useRadioGroupLabelProps = q$1(props => {
        return useGroupLabelLabelProps(props);
      }, [useGroupLabelLabelProps]); //const correctedIndex = (selectedIndex == null || selectedIndex < 0 || selectedIndex >= managedChildren.length) ? null : selectedIndex;

      /*const { onChildrenMountChange } = useChildrenFlag({
          initialIndex: 0,
          children,
          key: "selected"
          //setChildFlag: (i, checked) => managedChildren[i]?.setChecked(checked),
          //getChildFlag: ((i) => managedChildren[i]?.getChecked() ?? false)
      });*/

      s(() => {
        if (selectedValue == null) {
          setSelectedIndex(null);
        } else {
          const selectedIndex = byName.current.get(selectedValue);
          setSelectedIndex(selectedIndex !== null && selectedIndex !== void 0 ? selectedIndex : null);
        }
      }, [byName, selectedValue]);
      const useRadio = q$1(function useRadio(_ref3) {
        let {
          listNavigation,
          managedChild,
          rovingTabIndex,
          hasFocus,
          radio: {
            disabled,
            labelPosition,
            tagInput,
            tagLabel,
            value
          }
        } = _ref3;
        const index = managedChild.index;
        debugLog("useRadio", index); //const [checked, setChecked, getChecked] = useState<boolean | null>(null);

        const onInput = useStableCallback(e => {
          e.preventDefault();
          onSelectedIndexChange(e, index);
        });
        const getValue = useStableGetter(value);
        const {
          useListNavigationSingleSelectionChildProps,
          ...listNavRet
        } = useListNavigationSingleSelectionChild({
          listNavigation,
          rovingTabIndex,
          managedChild,
          hasFocus,
          subInfo: {
            getValue
          }
        });
        const {
          singleSelection: {
            selected: checked
          }
        } = listNavRet;
        const {
          useCheckboxLikeInputElement,
          useCheckboxLikeLabelElement
        } = useCheckboxLike({
          checkboxLike: {
            checked: checked !== null && checked !== void 0 ? checked : false,
            labelPosition,
            disabled,
            onCheckedChange: onInput,
            role: "radio"
          },
          label: {
            tagInput: tagInput,
            tagLabel: tagLabel
          }
        });
        _(() => {
          byName.current.set(value, index);
          return () => {
            byName.current.delete(value);
          };
        }, [byName, value, index]);

        const useRadioInput = () => {
          const tag = tagInput;

          const useRadioInputProps = props => {
            if (tag == "input") {
              props.name = name;
              props.checked = checked !== null && checked !== void 0 ? checked : false;
              props.type = "radio";
            } else {
              props["aria-checked"] = (checked !== null && checked !== void 0 ? checked : false).toString();
            }

            const propsIfInputHandlesFocus = useListNavigationSingleSelectionChildProps(props);
            const {
              useCheckboxLikeInputElementProps
            } = useCheckboxLikeInputElement();
            return useMergedProps(useCheckboxLikeInputElementProps({}), labelPosition == "separate" ? propsIfInputHandlesFocus : props);
          };

          return {
            useRadioInputProps
          };
        };

        const useRadioLabel = q$1(() => {
          //const tag = tagLabel;
          const useRadioLabelProps = props => {
            const {
              useCheckboxLikeLabelElementProps
            } = useCheckboxLikeLabelElement();
            const propsIfLabelHandlesFocus = useListNavigationSingleSelectionChildProps(props);
            return useCheckboxLikeLabelElementProps(useMergedProps({}, labelPosition == "wrapping" ? propsIfLabelHandlesFocus : props));
          };

          return {
            useRadioLabelProps
          };
        }, [useCheckboxLikeLabelElement]);
        return {
          useRadioInput,
          useRadioLabel,
          ...listNavRet //checked: checked ?? false,
          //tabbable: tabbable ?? false

        };
      }, [byName, useListNavigationSingleSelectionChild]);
      return {
        useRadio,
        useRadioGroupProps,
        useRadioGroupLabelProps,
        radioGroup: {
          selectedIndex,
          selectedValue
        },
        ...listNavRet
      };
    }

    function useSlider(_ref) {
      let {
        slider: {
          max: maxParent,
          min: minParent
        },
        managedChildren
      } = _ref;
      debugLog("useSlider");
      const {
        useManagedChild,
        ...childrenInfo
      } = useManagedChildren({
        managedChildren
      });
      const useSliderThumb = q$1(function useSliderThumb(_ref2) {
        let {
          managedChild,
          sliderThumb
        } = _ref2;
        debugLog("useSliderThumb", managedChild.index);
        const [minParentCopy, setMinParentCopy] = y(minParent);
        const [maxParentCopy, setMaxParentCopy] = y(maxParent);

        useManagedChild({
          managedChild: { ...managedChild,
            subInfo: {
              setMax: setMaxParentCopy,
              setMin: setMinParentCopy
            }
          }
        });

        const {
          tag,
          value,
          max: maxOverride,
          min: minOverride,
          onValueChange,
          valueText,
          label
        } = sliderThumb;
        const min = minOverride !== null && minOverride !== void 0 ? minOverride : minParentCopy;
        const max = maxOverride !== null && maxOverride !== void 0 ? maxOverride : maxParentCopy;
        return {
          useSliderThumbProps,
          sliderThumb: {
            min,
            max
          }
        };

        function useSliderThumbProps(props) {
          let newProps = tag == "input" ? {
            min,
            max,
            value,
            type: "range"
          } : {
            "aria-valuemax": `${max}`,
            "aria-valuemin": `${min}`,
            "aria-valuenow": `${value}`
          };
          newProps = { ...newProps,
            "aria-label": label,
            "aria-valuetext": valueText,
            style: {
              "--range-value": `${value}`,
              "--range-value-text": `${valueText}`
            }
          };

          if (tag == "input") {
            newProps.onInput = e => {
              onValueChange === null || onValueChange === void 0 ? void 0 : onValueChange({
                currentTarget: e.currentTarget,
                target: e.target,
                [EventDetail]: {
                  value: e.currentTarget.valueAsNumber
                }
              });
            };
          } else {
            throw new Error("Unimplemented");
          }

          return useMergedProps(newProps, props);
        }
      }, []);
      return {
        useSliderThumb,
        ...childrenInfo
      };
    }

    function useTable(_ref) {
      let {
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      } = _ref;
      debugLog("useTable");
      const [getCurrentSortColumn, setCurrentSortColumn] = usePassiveState(null, returnNull);
      const bodySort = A(null);
      const {
        useGridNavigationProps,
        useGridNavigationRow,
        ...gridNavRet1
      } = useGridNavigation({
        linearNavigation,
        listNavigation,
        managedChildren,
        rovingTabIndex,
        typeaheadNavigation
      });
      const {
        managedChildren: {
          children: rows
        }
      } = gridNavRet1;
      const useTableRow = q$1(_ref2 => {
        let {
          asChildRowOfSection,
          asParentRowOfCells,
          tableRow: {
            location
          }
        } = _ref2;
        debugLog("useTableRow", asChildRowOfSection.managedChild.index);
        const getCells = q$1(() => {
          return cells;
        }, []);
        const {
          useGridNavigationCell,
          useGridNavigationRowProps,
          ...gridNavRet2
        } = useGridNavigationRow({
          asChildRowOfSection: { ...asChildRowOfSection,
            subInfo: {
              getCells,
              location
            }
          },
          asParentRowOfCells
        });
        const {
          asParentOfCells: {
            managedChildren: {
              children: cells
            }
          }
        } = gridNavRet2;
        const useTableCell = q$1(_ref3 => {
          let {
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo,
            hasFocus
          } = _ref3;
          debugLog("useTableCell", managedChild.index);
          const {
            useGridNavigationCellProps,
            ...gridNavRet3
          } = useGridNavigationCell({
            listNavigation,
            managedChild,
            rovingTabIndex,
            subInfo,
            hasFocus
          });
          const sort = useStableCallback(() => {
            var _getCurrentSortColumn;

            const sortInfo = (_getCurrentSortColumn = getCurrentSortColumn()) !== null && _getCurrentSortColumn !== void 0 ? _getCurrentSortColumn : {
              index: -1,
              direction: 'ascending'
            };
            const cellIndex = managedChild.index;

            if (sortInfo.index != cellIndex) {
              if (sortInfo.direction[0] == 'a') sortInfo.direction = 'descending';else sortInfo.direction = 'ascending';
            }

            sortInfo.index = managedChild.index;
            setCurrentSortColumn(sortInfo);
            bodySort.current();
          });

          const useTableCellProps = props => props;

          return {
            tableHeaderCell: {
              sort
            },
            useTableCellProps,
            ...gridNavRet3
          };
        }, []);

        const useTableRowProps = props => props;

        return {
          useTableCell,
          useTableRowProps,
          ...gridNavRet2
        };
      }, []);
      const useTableBody = q$1(() => {
        debugLog("useTableBody");
        const getIndex = q$1(i => i.index, []);
        const getValue = q$1(i => {
          var _getCurrentSortColumn2, _getCurrentSortColumn3, _cell$subInfo$subInfo, _cell$subInfo$subInfo2;

          const cells = i.subInfo.subInfo.subInfo.getCells();
          const cell = cells.getAt((_getCurrentSortColumn2 = (_getCurrentSortColumn3 = getCurrentSortColumn()) === null || _getCurrentSortColumn3 === void 0 ? void 0 : _getCurrentSortColumn3.index) !== null && _getCurrentSortColumn2 !== void 0 ? _getCurrentSortColumn2 : 0);
          return {
            location: (_cell$subInfo$subInfo = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.location) !== null && _cell$subInfo$subInfo !== void 0 ? _cell$subInfo$subInfo : "head",
            value: (_cell$subInfo$subInfo2 = cell === null || cell === void 0 ? void 0 : cell.subInfo.subInfo.subInfo.value) !== null && _cell$subInfo$subInfo2 !== void 0 ? _cell$subInfo$subInfo2 : -1
          }; //return cells.getAt(getCurrentSortColumn()?.index ?? 0)?.subInfo.subInfo.subInfo.value ?? null;
        }, []);

        const compare = (lhs, rhs) => {
          var _lhs$value, _rhs$value;

          if (lhs.location === rhs.location) return +((_lhs$value = lhs.value) !== null && _lhs$value !== void 0 ? _lhs$value : -Infinity) - +((_rhs$value = rhs.value) !== null && _rhs$value !== void 0 ? _rhs$value : -Infinity);
          if (lhs.location == 'head') return -1;
          if (lhs.location == 'body') return rhs.location == 'head' ? -1 : 1;
          return 1;
        };

        const {
          useSortableProps,
          ...sortableRet
        } = useSortableChildren({
          rearrangeableChildren: {
            getIndex
          },
          sortableChildren: {
            compare,
            getValue
          }
        });
        const {
          sortableChildren: {
            sort
          }
        } = sortableRet;
        _(() => {
          bodySort.current = () => {
            var _getCurrentSortColumn4, _getCurrentSortColumn5;

            sort(rows, (_getCurrentSortColumn4 = (_getCurrentSortColumn5 = getCurrentSortColumn()) === null || _getCurrentSortColumn5 === void 0 ? void 0 : _getCurrentSortColumn5.direction) !== null && _getCurrentSortColumn4 !== void 0 ? _getCurrentSortColumn4 : 'ascending');
          };
        }, [sort]);

        const useTableBodyProps = props => {
          console.assert(props.children != null);
          return useSortableProps(props);
        };

        return {
          useTableBodyProps,
          ...sortableRet
        };
      }, []);
      const useTableProps = useGridNavigationProps;
      return {
        useTableProps,
        useTableBody,
        useTableRow,
        ...gridNavRet1
      };
    }

    function g(n, t) {
      for (var e in t) n[e] = t[e];

      return n;
    }

    function C(n, t) {
      for (var e in n) if ("__source" !== e && !(e in t)) return !0;

      for (var r in t) if ("__source" !== r && n[r] !== t[r]) return !0;

      return !1;
    }

    function E(n) {
      this.props = n;
    }

    function w(n, e) {
      function r(n) {
        var t = this.props.ref,
            r = t == n.ref;
        return !r && t && (t.call ? t(null) : t.current = null), e ? !e(this.props, n) || !r : C(this.props, n);
      }

      function u(e) {
        return this.shouldComponentUpdate = r, h$1(n, e);
      }

      return u.displayName = "Memo(" + (n.displayName || n.name) + ")", u.prototype.isReactComponent = !0, u.__f = !0, u;
    }

    (E.prototype = new d$1()).isPureReactComponent = !0, E.prototype.shouldComponentUpdate = function (n, t) {
      return C(this.props, n) || C(this.state, t);
    };
    var R = l$1.__b;

    l$1.__b = function (n) {
      n.type && n.type.__f && n.ref && (n.props.ref = n.ref, n.ref = null), R && R(n);
    };

    var x = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;

    function N(n) {
      function t(t) {
        var e = g({}, t);
        return delete e.ref, n(e, t.ref || null);
      }

      return t.$$typeof = x, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
    }

    var O = l$1.__e;

    l$1.__e = function (n, t, e, r) {
      if (n.then) for (var u, o = t; o = o.__;) if ((u = o.__c) && u.__c) return null == t.__e && (t.__e = e.__e, t.__k = e.__k), u.__c(n, t);
      O(n, t, e, r);
    };

    var T = l$1.unmount;

    function I(n, t, e) {
      return n && (n.__c && n.__c.__H && (n.__c.__H.__.forEach(function (n) {
        "function" == typeof n.__c && n.__c();
      }), n.__c.__H = null), null != (n = g({}, n)).__c && (n.__c.__P === e && (n.__c.__P = t), n.__c = null), n.__k = n.__k && n.__k.map(function (n) {
        return I(n, t, e);
      })), n;
    }

    function L(n, t, e) {
      return n && (n.__v = null, n.__k = n.__k && n.__k.map(function (n) {
        return L(n, t, e);
      }), n.__c && n.__c.__P === t && (n.__e && e.insertBefore(n.__e, n.__d), n.__c.__e = !0, n.__c.__P = e)), n;
    }

    function U() {
      this.__u = 0, this.t = null, this.__b = null;
    }

    function D(n) {
      var t = n.__.__c;
      return t && t.__a && t.__a(n);
    }

    function M() {
      this.u = null, this.o = null;
    }

    l$1.unmount = function (n) {
      var t = n.__c;
      t && t.__R && t.__R(), t && !0 === n.__h && (n.type = null), T && T(n);
    }, (U.prototype = new d$1()).__c = function (n, t) {
      var e = t.__c,
          r = this;
      null == r.t && (r.t = []), r.t.push(e);

      var u = D(r.__v),
          o = !1,
          i = function () {
        o || (o = !0, e.__R = null, u ? u(l) : l());
      };

      e.__R = i;

      var l = function () {
        if (! --r.__u) {
          if (r.state.__a) {
            var n = r.state.__a;
            r.__v.__k[0] = L(n, n.__c.__P, n.__c.__O);
          }

          var t;

          for (r.setState({
            __a: r.__b = null
          }); t = r.t.pop();) t.forceUpdate();
        }
      },
          c = !0 === t.__h;

      r.__u++ || c || r.setState({
        __a: r.__b = r.__v.__k[0]
      }), n.then(i, i);
    }, U.prototype.componentWillUnmount = function () {
      this.t = [];
    }, U.prototype.render = function (n, e) {
      if (this.__b) {
        if (this.__v.__k) {
          var r = document.createElement("div"),
              o = this.__v.__k[0].__c;
          this.__v.__k[0] = I(this.__b, r, o.__O = o.__P);
        }

        this.__b = null;
      }

      var i = e.__a && h$1(p$1, null, n.fallback);
      return i && (i.__h = null), [h$1(p$1, null, e.__a ? null : n.children), i];
    };

    var V = function (n, t, e) {
      if (++e[1] === e[0] && n.o.delete(t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.o.size)) for (e = n.u; e;) {
        for (; e.length > 3;) e.pop()();

        if (e[1] < e[0]) break;
        n.u = e = e[2];
      }
    };

    function W(n) {
      return this.getChildContext = function () {
        return n.context;
      }, n.children;
    }

    function P(n) {
      var e = this,
          r = n.i;
      e.componentWillUnmount = function () {
        P$1(null, e.l), e.l = null, e.i = null;
      }, e.i && e.i !== r && e.componentWillUnmount(), n.__v ? (e.l || (e.i = r, e.l = {
        nodeType: 1,
        parentNode: r,
        childNodes: [],
        appendChild: function (n) {
          this.childNodes.push(n), e.i.appendChild(n);
        },
        insertBefore: function (n, t) {
          this.childNodes.push(n), e.i.appendChild(n);
        },
        removeChild: function (n) {
          this.childNodes.splice(this.childNodes.indexOf(n) >>> 1, 1), e.i.removeChild(n);
        }
      }), P$1(h$1(W, {
        context: e.context
      }, n.__v), e.l)) : e.l && e.componentWillUnmount();
    }

    function $(n, e) {
      var r = h$1(P, {
        __v: n,
        i: e
      });
      return r.containerInfo = e, r;
    }

    (M.prototype = new d$1()).__a = function (n) {
      var t = this,
          e = D(t.__v),
          r = t.o.get(n);
      return r[0]++, function (u) {
        var o = function () {
          t.props.revealOrder ? (r.push(u), V(t, n, r)) : u();
        };

        e ? e(o) : o();
      };
    }, M.prototype.render = function (n) {
      this.u = null, this.o = new Map();
      var t = x$2(n.children);
      n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

      for (var e = t.length; e--;) this.o.set(t[e], this.u = [1, 0, this.u]);

      return n.children;
    }, M.prototype.componentDidUpdate = M.prototype.componentDidMount = function () {
      var n = this;
      this.o.forEach(function (t, e) {
        V(n, e, t);
      });
    };

    var j = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103,
        z = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,
        B = "undefined" != typeof document,
        H = function (n) {
      return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n);
    };

    d$1.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function (t) {
      Object.defineProperty(d$1.prototype, t, {
        configurable: !0,
        get: function () {
          return this["UNSAFE_" + t];
        },
        set: function (n) {
          Object.defineProperty(this, t, {
            configurable: !0,
            writable: !0,
            value: n
          });
        }
      });
    });
    var q = l$1.event;

    function G() {}

    function J() {
      return this.cancelBubble;
    }

    function K() {
      return this.defaultPrevented;
    }

    l$1.event = function (n) {
      return q && (n = q(n)), n.persist = G, n.isPropagationStopped = J, n.isDefaultPrevented = K, n.nativeEvent = n;
    };

    var X = {
      configurable: !0,
      get: function () {
        return this.class;
      }
    },
        nn = l$1.vnode;

    l$1.vnode = function (n) {
      var t = n.type,
          e = n.props,
          u = e;

      if ("string" == typeof t) {
        var o = -1 === t.indexOf("-");

        for (var i in u = {}, e) {
          var l = e[i];
          B && "children" === i && "noscript" === t || "value" === i && "defaultValue" in e && null == l || ("defaultValue" === i && "value" in e && null == e.value ? i = "value" : "download" === i && !0 === l ? l = "" : /ondoubleclick/i.test(i) ? i = "ondblclick" : /^onchange(textarea|input)/i.test(i + t) && !H(e.type) ? i = "oninput" : /^onfocus$/i.test(i) ? i = "onfocusin" : /^onblur$/i.test(i) ? i = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i) ? i = i.toLowerCase() : o && z.test(i) ? i = i.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l && (l = void 0), /^oninput$/i.test(i) && (i = i.toLowerCase(), u[i] && (i = "oninputCapture")), u[i] = l);
        }

        "select" == t && u.multiple && Array.isArray(u.value) && (u.value = x$2(e.children).forEach(function (n) {
          n.props.selected = -1 != u.value.indexOf(n.props.value);
        })), "select" == t && null != u.defaultValue && (u.value = x$2(e.children).forEach(function (n) {
          n.props.selected = u.multiple ? -1 != u.defaultValue.indexOf(n.props.value) : u.defaultValue == n.props.value;
        })), n.props = u, e.class != e.className && (X.enumerable = "className" in e, null != e.className && (u.class = e.className), Object.defineProperty(u, "className", X));
      }

      n.$$typeof = j, nn && nn(n);
    };

    var tn = l$1.__r;

    l$1.__r = function (n) {
      tn && tn(n), n.__c;
    };

    const AccordionSectionContext = B$2(null);
    const Accordion = w(function Accordion(_ref) {
      let {
        disableArrowKeys,
        disableHomeEndKeys,
        expandedIndex,
        initialIndex,
        navigationDirection,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        render
      } = _ref;
      const {
        useAccordionSection,
        ...provider
      } = useAccordion({
        accordion: {
          initialIndex
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        }
      });
      s(() => {
        provider.accordion.changeExpandedIndex(expandedIndex !== null && expandedIndex !== void 0 ? expandedIndex : null);
      }, [expandedIndex]);
      return o$1(AccordionSectionContext.Provider, {
        value: useAccordionSection,
        children: render(provider)
      });
    });
    const AccordionSection = w(function AccordionSection(_ref3) {
      let {
        open,
        index,
        tagButton,
        disabled,
        render,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref3;
      const useAccordionSection = x$1(AccordionSectionContext);
      const {
        useAccordionSectionBodyProps,
        useAccordionSectionHeaderProps,
        ...sectionInfo
      } = useAccordionSection({
        button: {
          disabled
        },
        accordionSection: {
          open,
          tagButton
        },
        managedChildren: {
          index
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return render(sectionInfo, useAccordionSectionHeaderProps, useAccordionSectionBodyProps);
    });

    function defaultRenderButton(tag, makeButtonProps) {
      return function (modifyButtonProps) {
        return h$1(tag, modifyButtonProps(makeButtonProps({})));
      };
    }
    const Button = w(function Button(_ref) {
      let {
        tag,
        onPress,
        pressed,
        render,
        disabled
      } = _ref;
      const {
        useButtonProps
      } = useButton({
        tag,
        onPress,
        pressed,
        disabled
      });
      return render(useButtonProps);
    });

    function defaultRenderCheckboxLike(_ref) {
      let {
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      } = _ref;
      return function (info, modifyInputProps, modifyLabelProps) {
        if (labelPosition == "wrapping") {
          const inputPropsBase = makeInputProps(info);
          const labelPropsBase = makeLabelProps(info);
          const inputProps = modifyInputProps(inputPropsBase);
          const {
            children,
            ...labelProps
          } = modifyLabelProps(labelPropsBase);
          const input = h$1(tagInput, inputProps);
          const label = h$1(tagLabel, { ...labelProps,
            children: o$1(p$1, {
              children: [input, children]
            })
          });
          return o$1(p$1, {
            children: label
          });
        } else if (labelPosition == "separate") {
          const inputProps = modifyInputProps(makeInputProps(info));
          const labelProps = modifyLabelProps(makeLabelProps(info));
          const input = h$1(tagInput, inputProps);
          const label = h$1(tagLabel, labelProps);
          return o$1(p$1, {
            children: [input, label]
          });
        } else {
          const userProps = makeInputProps(info);
          console.assert(!!userProps["aria-label"]);
          return h$1(tagInput, modifyInputProps(userProps));
        }
      };
    }
    function defaultRenderCheckbox(_ref2) {
      let {
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      } = _ref2;
      return defaultRenderCheckboxLike({
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      });
    }
    function Checkbox(_ref3) {
      let {
        checked,
        disabled,
        tagLabel,
        labelPosition,
        tagInput,
        onCheckedChange,
        render
      } = _ref3;
      const {
        useCheckboxInputElement,
        useCheckboxLabelElement,
        ...checkboxInfo
      } = useCheckbox({
        checkbox: {
          onCheckedChange
        },
        checkboxLike: {
          checked,
          disabled,
          labelPosition
        },
        label: {
          tagInput,
          tagLabel
        }
      });
      const {
        useCheckboxInputElementProps
      } = useCheckboxInputElement();
      const {
        useCheckboxLabelElementProps
      } = useCheckboxLabelElement();
      return render(checkboxInfo, useCheckboxInputElementProps, useCheckboxLabelElementProps);
    }

    function defaultRenderCheckboxGroupChild(_ref) {
      let {
        tagInput,
        tagLabel,
        labelPosition,
        makeInputProps,
        makeLabelProps
      } = _ref;
      return function (info, modifyInputProps, modifyLabelProps) {
        return defaultRenderCheckboxLike({
          labelPosition,
          tagInput,
          tagLabel,
          makeInputProps,
          makeLabelProps
        })(info, modifyInputProps, modifyLabelProps);
      };
    }
    function defaultRenderCheckboxGroup(_ref2) {
      let {
        children,
        labelPosition,
        makeInputProps,
        makeLabelProps,
        tagInput,
        tagLabel
      } = _ref2;
      return function (info, modifyInputProps, modifyLabelProps) {
        return o$1(p$1, {
          children: [defaultRenderCheckboxLike({
            labelPosition,
            makeInputProps,
            makeLabelProps,
            tagInput,
            tagLabel
          })(info, modifyInputProps, modifyLabelProps), children]
        });
      };
    }
    const UseCheckboxGroupChildContext = B$2(null);
    function CheckboxGroup(_ref3) {
      let {
        disabled: parentDisabled,
        tagInput,
        tagLabel,
        render,
        labelPosition,
        initialIndex,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        indexDemangler,
        indexMangler,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender
      } = _ref3;
      const {
        useCheckboxGroupChild,
        useCheckboxGroupParentInput,
        ...checkboxGroupParentInfo
      } = useCheckboxGroup({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useCheckboxGroupParentInputProps,
        useCheckboxGroupParentLabelProps
      } = useCheckboxGroupParentInput({
        checkbox: {},
        checkboxLike: {
          disabled: parentDisabled,
          labelPosition
        },
        label: {
          tagInput,
          tagLabel
        }
      });
      let wrapping;

      if (labelPosition == "separate") {
        wrapping = render(checkboxGroupParentInfo, useCheckboxGroupParentInputProps, useCheckboxGroupParentLabelProps);
      } else {
        wrapping = render(checkboxGroupParentInfo, useCheckboxGroupParentInputProps, useCheckboxGroupParentLabelProps);
      }

      return o$1(UseCheckboxGroupChildContext.Provider, {
        value: useCheckboxGroupChild,
        children: wrapping
      });
    }
    function CheckboxGroupCheckbox(_ref4) {
      let {
        checked,
        disabled,
        index,
        labelPosition,
        tagInput,
        tagLabel,
        text,
        blurSelf,
        flags,
        focusSelf,
        hidden,
        onCheckedChange,
        render
      } = _ref4;
      const {
        useCheckboxGroupChildInputProps,
        useCheckboxGroupChildLabelProps,
        ...checkboxGroupChildInfo
      } = x$1(UseCheckboxGroupChildContext)({
        asCheckbox: {
          checkbox: {
            onCheckedChange
          },
          checkboxLike: {
            checked,
            disabled,
            labelPosition
          },
          label: {
            tagInput,
            tagLabel
          }
        },
        asCheckboxGroupChild: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden
          }
        }
      });

      if (labelPosition == "separate") {
        return render(checkboxGroupChildInfo, useCheckboxGroupChildInputProps, useCheckboxGroupChildLabelProps);
      } else {
        return render(checkboxGroupChildInfo, useCheckboxGroupChildInputProps, useCheckboxGroupChildLabelProps);
      }
    }

    function defaultRenderPortal(_ref) {
      var _portalRef$current;

      let {
        portalId,
        children
      } = _ref;
      const portalRef = A(null);
      (_portalRef$current = portalRef.current) !== null && _portalRef$current !== void 0 ? _portalRef$current : portalRef.current = document.getElementById(portalId);
      if (portalRef.current) return $(children, portalRef.current);else return children;
    }
    function defaultRenderModal(_ref2) {
      let {
        portalId,
        tagFocusContainer,
        tagBackdrop,
        tagBody,
        tagDialog,
        tagTitle,
        makePropsFocusContainer,
        makePropsBackdrop,
        makePropsBody,
        makePropsDialog,
        makePropsTitle
      } = _ref2;
      return function (dialogInfo, modifyFocusContainerProps, modifyDialogProps, modifyTitleProps, modifyBodyProps, modifyBackdropProps) {
        const {
          children: titleChildren,
          ...titleProps
        } = modifyTitleProps(makePropsTitle(dialogInfo));
        const {
          children: bodyChildren,
          ...bodyProps
        } = modifyBodyProps(makePropsBody(dialogInfo));
        const {
          children: dialogChildren,
          ...dialogProps
        } = modifyDialogProps(makePropsDialog(dialogInfo));
        const {
          children: backdropChildren,
          ...backdropProps
        } = modifyBackdropProps(makePropsBackdrop(dialogInfo));
        const {
          children: focusContainerChildren,
          ...focusContainerProps
        } = modifyFocusContainerProps(makePropsFocusContainer(dialogInfo));
        const title = h$1(tagTitle, titleProps, titleChildren);
        const body = h$1(tagBody, bodyProps, bodyChildren);
        const dialog = h$1(tagDialog, { ...dialogProps,
          children: o$1(p$1, {
            children: [dialogChildren, title, body]
          })
        });
        const backdrop = h$1(tagBackdrop, backdropProps, backdropChildren);
        const focusContainer = h$1(tagFocusContainer, focusContainerProps, o$1(p$1, {
          children: [focusContainerChildren, dialog, backdrop]
        }));
        return defaultRenderPortal({
          portalId,
          children: focusContainer
        });
      };
    }
    function defaultRenderDialog(_ref3) {
      let {
        portalId,
        tagFocusContainer,
        tagBackdrop,
        tagBody,
        tagDialog,
        tagTitle,
        makePropsFocusContainer,
        makePropsBackdrop,
        makePropsBody,
        makePropsDialog,
        makePropsTitle
      } = _ref3;
      return defaultRenderModal({
        portalId,
        tagFocusContainer,
        tagBackdrop,
        tagBody,
        tagDialog,
        tagTitle,
        makePropsFocusContainer,
        makePropsBackdrop,
        makePropsBody,
        makePropsDialog,
        makePropsTitle
      });
    }
    function Dialog(_ref4) {
      let {
        onClose,
        open,
        bodyIsOnlySemantic,
        getDocument,
        getWindow,
        onActiveElementChange,
        onLastActiveElementChange,
        onWindowFocusedChange,
        focusSelf,
        render
      } = _ref4;
      const {
        useDialogBackdrop,
        useDialogBody,
        useDialogProps,
        useDialogTitle,
        useDialogFocusContainerProps,
        ...r
      } = useDialog({
        dialog: {
          onClose
        },
        modal: {
          bodyIsOnlySemantic,
          focusSelf
        },
        softDismiss: {
          open
        },
        activeElement: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onLastActiveElementChange,
          onWindowFocusedChange
        }
      });
      const {
        useDialogTitleProps
      } = useDialogTitle();
      const {
        useDialogBodyProps
      } = useDialogBody();
      const {
        useDialogBackdropProps
      } = useDialogBackdrop();
      return render(r, useDialogFocusContainerProps, useDialogProps, useDialogTitleProps, useDialogBodyProps, useDialogBackdropProps);
    }

    const ListboxSingleContext = B$2(null);

    function ListboxSingleU(_ref) {
      let {
        render,
        selectedIndex,
        tagLabel,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        onAllLostFocus,
        onAnyGainedFocus,
        selectionMode,
        tagList,
        onSelect
      } = _ref;
      const {
        useListboxSingleItem,
        useListboxSingleLabel,
        useListboxSingleProps,
        ...listboxReturnType
      } = useListboxSingle({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listboxSingle: {
          tagLabel,
          tagList,
          onSelect
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          onTabbableRender
        },
        singleSelection: {
          selectedIndex,
          selectionMode
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        },
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        }
      });
      const {
        useListboxSingleLabelProps
      } = useListboxSingleLabel(); //const label = createElement(tagLabel, useListboxSingleLabelProps({}) as any);
      //const list = createElement(tagList, useListboxSingleProps({ children: vnodeChildren, ref }) as any);

      return o$1(ListboxSingleContext.Provider, {
        value: useListboxSingleItem,
        children: render({ ...listboxReturnType
        }, useListboxSingleLabelProps, useListboxSingleProps)
      });
    }

    function defaultRenderListboxSingle(_ref2) {
      let {
        makePropsList,
        makePropsLabel,
        tagLabel,
        tagList
      } = _ref2;
      return defaultRenderList({
        makePropsLabel,
        makePropsList,
        tagLabel,
        tagList
      });
    }
    function defaultRenderListboxSingleItem(_ref3) {
      let {
        makePropsListItem,
        tagListItem
      } = _ref3;
      return defaultRenderListItem({
        makePropsListItem,
        tagListItem
      });
    }

    function ListboxSingleItemU(_ref4) {
      let {
        index,
        blurSelf,
        disabled,
        flags,
        focusSelf,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render,
        text,
        hidden
      } = _ref4;
      const {
        useListboxSingleItemProps,
        rovingTabIndex,
        singleSelection
      } = x$1(ListboxSingleContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        listboxSingleItem: {
          disabled
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return o$1(p$1, {
        children: render({
          rovingTabIndex,
          singleSelection
        }, useListboxSingleItemProps)
      });
    }

    const ListboxSingle = N(ListboxSingleU);
    const ListboxSingleItem = N(ListboxSingleItemU);
    N(ListboxGroupU);

    function ListboxGroupU(_ref5) {
      let {
        render
      } = _ref5;
      const {
        useListboxGroupHeadingProps,
        useListboxGroupContainerProps
      } = useListboxGroup();
      return render(useListboxGroupContainerProps, useListboxGroupHeadingProps);
    }
    function defaultRenderList(_ref7) {
      let {
        makePropsList,
        makePropsLabel,
        tagLabel,
        tagList
      } = _ref7;
      return function (info, modifyPropsLabel, modifyPropsList) {
        const label = h$1(tagLabel, modifyPropsLabel(makePropsLabel(info)));
        const list = h$1(tagList, modifyPropsList(makePropsList(info)));
        return o$1(p$1, {
          children: [label, list]
        });
      };
    }
    function defaultRenderListItem(_ref8) {
      let {
        makePropsListItem,
        tagListItem
      } = _ref8;
      return function (info, modifyPropsListItem) {
        return h$1(tagListItem, modifyPropsListItem(makePropsListItem(info)));
      };
    }

    const ListboxMultiContext = B$2(null);

    function ListboxMultiU(_ref) {
      let {
        render,
        tagLabel,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        initialIndex,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        tagList
      } = _ref;
      const {
        useListboxMultiItem,
        useListboxMultiLabel,
        useListboxMultiProps,
        ...listboxReturnType
      } = useListboxMulti({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listboxMulti: {
          tagLabel,
          tagList
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useListboxMultiLabelProps
      } = useListboxMultiLabel();
      return o$1(ListboxMultiContext.Provider, {
        value: useListboxMultiItem,
        children: render(listboxReturnType, useListboxMultiLabelProps, useListboxMultiProps)
      });
    }

    function defaultRenderListboxMulti(_ref2) {
      let {
        makePropsList,
        makePropsLabel,
        tagLabel,
        tagList
      } = _ref2;
      return defaultRenderList({
        makePropsLabel,
        makePropsList,
        tagLabel,
        tagList
      });
    }
    function defaultRenderListboxMultiItem(_ref3) {
      let {
        makePropsListItem,
        tagListItem
      } = _ref3;
      return defaultRenderListItem({
        makePropsListItem,
        tagListItem
      });
    }

    function ListboxMultiItemU(_ref4) {
      let {
        index,
        blurSelf,
        disabled,
        flags,
        focusSelf,
        render,
        text,
        hidden,
        selected,
        onSelectedChange
      } = _ref4;
      const {
        useListboxMultiItemProps,
        ...itemReturn
      } = x$1(ListboxMultiContext)({
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        listNavigation: {
          text
        },
        listboxMultiItem: {
          disabled,
          selected,
          onSelectedChange
        }
      });
      return o$1(p$1, {
        children: render(itemReturn, useListboxMultiItemProps)
      });
    }

    const ListboxMulti = N(ListboxMultiU);
    const ListboxMultiItem = N(ListboxMultiItemU);

    const MenuItemContext = B$2(null);
    function Menu(_ref) {
      let {
        initialIndex,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        onOpen,
        onClose,
        open,
        openDirection,
        indexDemangler,
        indexMangler,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        getDocument,
        getWindow,
        render
      } = _ref;
      const {
        useMenuButtonProps,
        useMenuItem,
        useMenuProps,
        useMenuSentinel,
        useMenuSurfaceProps,
        ...menuReturn
      } = useMenu({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        menu: {
          onOpen: useStableCallback(onOpen),
          openDirection
        },
        menuSurface: {},
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        softDismiss: {
          onClose: useStableCallback(onClose),
          open
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        },
        activeElement: {
          getDocument,
          getWindow
        }
      });
      const {
        useMenuSentinelProps: useFirstSentinelProps
      } = useMenuSentinel();
      const {
        useMenuSentinelProps: useLastSentinelProps
      } = useMenuSentinel();
      return o$1(MenuItemContext.Provider, {
        value: useMenuItem,
        children: render(menuReturn, useMenuButtonProps, useMenuSurfaceProps, useMenuProps, useFirstSentinelProps, useLastSentinelProps)
      });
    }
    function MenuItem(_ref2) {
      let {
        render,
        index,
        text,
        hidden,
        blurSelf,
        flags,
        focusSelf
      } = _ref2;
      const {
        useMenuItemProps,
        ...rest
      } = x$1(MenuItemContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        }
      });
      return render(rest, useMenuItemProps);
    }
    function defaultRenderMenu(_ref3) {
      let {
        portalId,
        tagButton,
        tagMenu,
        tagSurface,
        tagSentinel,
        makePropsButton,
        makePropsMenu,
        makePropsSurface,
        makePropsSentinel
      } = _ref3;
      return function (menuInfo, modifyMenuButtonProps, modifyMenuSurfaceProps, modifyMenuProps, modifyFirstSentinelProps, modifyLastSentinelProps) {
        const {
          children: surfaceChildren,
          ...surfaceProps
        } = modifyMenuSurfaceProps(makePropsSurface(menuInfo));
        const {
          children: menuChildren,
          ...menuProps
        } = modifyMenuProps(makePropsMenu(menuInfo));
        return o$1(p$1, {
          children: [h$1(tagButton, modifyMenuButtonProps(makePropsButton(menuInfo))), defaultRenderPortal({
            portalId,
            children: h$1(tagSurface, { ...surfaceProps,
              children: o$1(p$1, {
                children: [h$1(tagSentinel, modifyFirstSentinelProps(makePropsSentinel(menuInfo))), surfaceChildren, h$1(tagMenu, { ...menuProps,
                  children: o$1(p$1, {
                    children: menuChildren
                  })
                }), h$1(tagSentinel, modifyLastSentinelProps(makePropsSentinel(menuInfo)))]
              })
            })
          })]
        });
      };
    }
    function defaultRenderMenuItem(_ref4) {
      let {
        makePropsMenuItem: makePropsMenuItem,
        tagMenuItem
      } = _ref4;
      return function (info, modifyMenuItemProps) {
        return h$1(tagMenuItem, modifyMenuItemProps(makePropsMenuItem(info)));
      };
    }

    function defaultRenderRadioGroup(_ref) {
      let {
        tagGroup,
        tagLabel,
        makePropsGroup,
        makePropsLabel
      } = _ref;
      return function (info, modifyLabelProps, modifyGroupProps) {
        return o$1(p$1, {
          children: [h$1(tagLabel, modifyLabelProps(makePropsLabel(info))), h$1(tagGroup, modifyGroupProps(makePropsGroup(info)))]
        });
      };
    }
    const RadioContext = B$2(null);
    function RadioGroup(_ref2) {
      let {
        render,
        tagGroup,
        tagGroupLabel,
        name,
        onSelectedValueChange,
        selectedValue,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        navigationDirection,
        noTypeahead,
        typeaheadTimeout,
        indexDemangler,
        indexMangler,
        onAllLostFocus,
        onAnyGainedFocus,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender
      } = _ref2;
      const {
        useRadio,
        useRadioGroupLabelProps,
        useRadioGroupProps,
        ...radioGroupReturn
      } = useRadioGroup({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        radioGroup: {
          name,
          onSelectedValueChange,
          selectedValue,
          tagGroup,
          tagGroupLabel
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        },
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        },
        singleSelection: {
          selectionMode: "focus"
        }
      });
      return o$1(RadioContext.Provider, {
        value: useRadio,
        children: render(radioGroupReturn, useRadioGroupLabelProps, useRadioGroupProps)
      });
    }
    function defaultRenderRadio(_ref3) {
      let {
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps,
        labelPosition
      } = _ref3;
      return defaultRenderCheckboxLike({
        labelPosition,
        tagInput,
        tagLabel,
        makeInputProps,
        makeLabelProps
      });
    }
    function Radio(_ref4) {
      let {
        disabled,
        index,
        text,
        hidden,
        tagInput,
        labelPosition,
        tagLabel,
        value,
        render,
        flags,
        blurSelf,
        focusSelf,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange
      } = _ref4;
      const {
        useRadioInput,
        useRadioLabel,
        ...radioReturn
      } = x$1(RadioContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        radio: {
          disabled,
          labelPosition,
          tagInput,
          tagLabel,
          value
        },
        rovingTabIndex: {
          hidden,
          focusSelf,
          blurSelf
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      const {
        useRadioInputProps
      } = useRadioInput({
        tag: tagInput
      });
      const {
        useRadioLabelProps
      } = useRadioLabel({
        tag: tagLabel
      });
      return render(radioReturn, useRadioInputProps, useRadioLabelProps);
    }

    const SliderThumbContext = B$2(null);
    function Slider(_ref) {
      let {
        max,
        min,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        children
      } = _ref;
      const {
        useSliderThumb,
        ..._sliderInfo
      } = useSlider({
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        slider: {
          max,
          min
        }
      });
      return o$1(SliderThumbContext.Provider, {
        value: useSliderThumb,
        children: children
      });
    }

    function SliderThumbU(_ref2, ref) {
      let {
        label,
        tag,
        value,
        max,
        min,
        onValueChange,
        index,
        flags,
        render,
        valueText
      } = _ref2;
      const {
        useSliderThumbProps,
        ...sliderInfo
      } = x$1(SliderThumbContext)({
        managedChild: {
          index,
          flags
        },
        sliderThumb: {
          label,
          tag,
          value,
          max,
          min,
          onValueChange,
          valueText
        }
      });
      return render(sliderInfo, useSliderThumbProps);
    }

    function defaultRenderSliderThumb(_ref3) {
      let {
        tagThumb,
        makePropsThumb
      } = _ref3;
      return function (info, modifyThumbProps) {
        return h$1(tagThumb, modifyThumbProps(makePropsThumb(info)));
      };
    }
    const SliderThumb = N(SliderThumbU);

    const LocationContext = B$2(null);
    const TableBodyContext = B$2(null);
    const TableRowContext = B$2(null);
    const TableCellContext = B$2(null);
    function defaultRenderTable(_ref) {
      let {
        tagTable,
        makePropsTable
      } = _ref;
      return function (info, modifyPropsTable) {
        return h$1(tagTable, modifyPropsTable(makePropsTable(info)));
      };
    }
    function defaultRenderTableRow(_ref5) {
      let {
        tagTableRow,
        makePropsTableRow
      } = _ref5;
      return function (info, modifyPropsTableRow) {
        return h$1(tagTableRow, modifyPropsTableRow(makePropsTableRow(info)));
      };
    }
    function defaultRenderTableCell(_ref6) {
      let {
        tagTableCell,
        makePropsTableCell
      } = _ref6;
      return function (info, modifyPropsTableCell) {
        return h$1(tagTableCell, modifyPropsTableCell(makePropsTableCell(info)));
      };
    }

    function TableU(_ref7, ref) {
      let {
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        render
      } = _ref7;
      const {
        useTableBody,
        useTableProps,
        useTableRow,
        ...tableInfo
      } = useTable({
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys
        },
        listNavigation: {},
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          initialIndex,
          onTabbableIndexChange,
          onTabbableRender
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      return o$1(TableBodyContext.Provider, {
        value: useTableBody,
        children: o$1(TableRowContext.Provider, {
          value: useTableRow,
          children: (render !== null && render !== void 0 ? render : defaultRenderTable)(tableInfo, useTableProps)
        })
      });
    }

    function TableBodyU(_ref8, ref) {
      let {
        render
      } = _ref8;
      const {
        useTableBodyProps,
        ...sectionInfo
      } = x$1(TableBodyContext)({});
      return o$1(LocationContext.Provider, {
        value: "body",
        children: render(sectionInfo, useTableBodyProps)
      });
    }

    function TableHeadU(_ref9, ref) {
      let {
        render
      } = _ref9;
      return o$1(LocationContext.Provider, {
        value: "head",
        children: render()
      });
    }

    function TableFootU(_ref10, ref) {
      let {
        render
      } = _ref10;
      return o$1(LocationContext.Provider, {
        value: "foot",
        children: render()
      });
    }

    function TableRowU(_ref11, ref) {
      let {
        index,
        text,
        blurSelf,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        flags,
        focusSelf,
        hidden,
        indexDemangler,
        indexMangler,
        initialIndex,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        render
      } = _ref11;
      const {
        useTableCell,
        useTableRowProps,
        ...rowInfo
      } = x$1(TableRowContext)({
        asChildRowOfSection: {
          listNavigation: {
            text
          },
          managedChild: {
            index,
            flags
          },
          rovingTabIndex: {
            blurSelf,
            focusSelf,
            hidden
          },
          subInfo: {}
        },
        asParentRowOfCells: {
          linearNavigation: {
            disableArrowKeys,
            disableHomeEndKeys
          },
          listNavigation: {
            indexDemangler,
            indexMangler
          },
          managedChildren: {
            onAfterChildLayoutEffect,
            onChildrenMountChange
          },
          rovingTabIndex: {
            initialIndex,
            onTabbableIndexChange,
            onTabbableRender
          },
          typeaheadNavigation: {
            collator,
            noTypeahead,
            typeaheadTimeout
          }
        },
        tableRow: {
          location: x$1(LocationContext)
        }
      });
      return o$1(TableCellContext.Provider, {
        value: useTableCell,
        children: (render !== null && render !== void 0 ? render : defaultRenderTableRow)(rowInfo, useTableRowProps({
          ref
        }))
      });
    }

    function TableCellU(_ref12, ref) {
      let {
        index,
        text,
        blurSelf,
        flags,
        focusSelf,
        hidden,
        value,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render
      } = _ref12;
      const {
        useTableCellProps,
        ...cellInfo
      } = x$1(TableCellContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        },
        subInfo: {
          location: x$1(LocationContext),
          value
        }
      });
      return (render !== null && render !== void 0 ? render : defaultRenderTableCell)(cellInfo, useTableCellProps({
        ref
      }));
    }

    N(TableU);
    N(TableBodyU);
    N(TableHeadU);
    N(TableFootU);
    N(TableRowU);
    N(TableCellU);

    const TabContext = B$2(null);
    const TabPanelContext = B$2(null);
    const Tabs = w(function Tabs(_ref) {
      let {
        selectedIndex,
        selectionMode,
        collator,
        disableArrowKeys,
        disableHomeEndKeys,
        indexDemangler,
        indexMangler,
        navigationDirection,
        noTypeahead,
        onAfterChildLayoutEffect,
        onChildrenMountChange,
        onTabbableIndexChange,
        onTabbableRender,
        typeaheadTimeout,
        onAllLostFocus,
        onAnyGainedFocus,
        onSelectedIndexChange,
        render
      } = _ref;
      const {
        useTabList,
        useTabListLabel,
        useTabPanel,
        ...tabsInfo
      } = useTabs({
        tabPanels: {
          managedChildren: {
            onAfterChildLayoutEffect,
            onChildrenMountChange
          }
        }
      });
      const {
        useTab,
        useTabListProps,
        ...tablistInfo
      } = useTabList({
        childrenHaveFocus: {
          onAllLostFocus,
          onAnyGainedFocus
        },
        tabs: {
          onSelectedIndexChange
        },
        linearNavigation: {
          disableArrowKeys,
          disableHomeEndKeys,
          navigationDirection
        },
        listNavigation: {
          indexDemangler,
          indexMangler
        },
        managedChildren: {
          onAfterChildLayoutEffect,
          onChildrenMountChange
        },
        rovingTabIndex: {
          onTabbableIndexChange,
          onTabbableRender
        },
        singleSelection: {
          selectedIndex,
          selectionMode
        },
        typeaheadNavigation: {
          collator,
          noTypeahead,
          typeaheadTimeout
        }
      });
      const {
        useTabListLabelProps
      } = useTabListLabel({});
      return o$1(TabContext.Provider, {
        value: useTab,
        children: o$1(TabPanelContext.Provider, {
          value: useTabPanel,
          children: render({ ...tabsInfo,
            ...tablistInfo
          }, useTabListLabelProps, useTabListProps)
        })
      });
    });
    const Tab = w(function Tab(_ref2) {
      let {
        index,
        text,
        blurSelf,
        flags,
        focusSelf,
        hidden,
        getDocument,
        getWindow,
        onActiveElementChange,
        onElementChange,
        onFocusedChanged,
        onFocusedInnerChanged,
        onLastActiveElementChange,
        onLastFocusedChanged,
        onLastFocusedInnerChanged,
        onMount,
        onUnmount,
        onWindowFocusedChange,
        render
      } = _ref2;
      const {
        useTabProps,
        ...tabInfo
      } = x$1(TabContext)({
        listNavigation: {
          text
        },
        managedChild: {
          index,
          flags
        },
        rovingTabIndex: {
          blurSelf,
          focusSelf,
          hidden
        },
        hasFocus: {
          getDocument,
          getWindow,
          onActiveElementChange,
          onElementChange,
          onFocusedChanged,
          onFocusedInnerChanged,
          onLastActiveElementChange,
          onLastFocusedChanged,
          onLastFocusedInnerChanged,
          onMount,
          onUnmount,
          onWindowFocusedChange
        }
      });
      return render(tabInfo, useTabProps);
    });
    const TabPanel = w(function TabPanel(_ref3) {
      let {
        index,
        flags,
        render
      } = _ref3;
      const {
        useTabPanelProps,
        ...tabPanelInfo
      } = x$1(TabPanelContext)({
        managedChild: {
          index,
          flags
        }
      });
      return render(tabPanelInfo, useTabPanelProps);
    });
    function defaultRenderTabs(_ref4) {
      let {
        tagLabel,
        tagList,
        makePropsLabel,
        makePropsList,
        panels
      } = _ref4;
      return function (tabsInfo, modifyLabelProps, modifyListProps) {
        const label = h$1(tagLabel, modifyLabelProps(makePropsLabel(tabsInfo)));
        const list = h$1(tagList, modifyListProps(makePropsList(tabsInfo)));
        return o$1(p$1, {
          children: [label, list, panels]
        });
      };
    }
    function defaultRenderTab(_ref5) {
      let {
        makePropsTab,
        tagTab
      } = _ref5;
      return function (tabInfo, modifyTabProps) {
        return h$1(tagTab, modifyTabProps(makePropsTab(tabInfo)));
      };
    }
    function defaultRenderTabPanel(_ref6) {
      let {
        makePropsTabPanel,
        tagTabPanel
      } = _ref6;
      return function (tabPanelInfo, modifyTabPanelProps) {
        return h$1(tagTabPanel, modifyTabPanelProps(makePropsTabPanel(tabPanelInfo)));
      };
    }

    B$2(null);

    function defaultRender(info, triggerProps, tooltipProps) {
      return o$1(p$1, {
        children: [o$1("div", { ...triggerProps
        }), o$1("div", { ...tooltipProps
        })]
      });
    }

    function TooltipU(_ref) {
      let {
        focusDelay,
        mouseoutDelay,
        mouseoverDelay,
        getDocument,
        getWindow,
        render
      } = _ref;
      const {
        useTooltipPopup,
        useTooltipTrigger,
        ...info
      } = useTooltip({
        focusDelay,
        mouseoutDelay,
        mouseoverDelay
      });
      const {
        useTooltipTriggerProps
      } = useTooltipTrigger({
        hasFocus: {
          getDocument,
          getWindow
        }
      });
      const {
        useTooltipPopupProps
      } = useTooltipPopup({
        hasFocus: {
          getDocument,
          getWindow
        }
      });
      return o$1(p$1, {
        children: (render !== null && render !== void 0 ? render : defaultRender)(info, useTooltipTriggerProps({}), useTooltipPopupProps({}))
      });
    }

    N(TooltipU);

    function DemoAccordion({ children, ...props }) {
        return o$1(Accordion, { ...props, render: (info) => { return o$1("div", { id: "accordion-demo", children: children }); } });
    }
    function getDocument$5() {
        return window.document;
    }
    function DemoAccordionSection({ index, body, heading, disabled, open }) {
        return o$1(AccordionSection, { index: index, tagButton: "div", open: open, disabled: disabled, getDocument: getDocument$5, render: (info, headerProps, bodyProps) => {
                return (o$1(p$1, { children: o$1(Heading, { heading: o$1("div", { ...headerProps, children: [heading, " (", !info.accordionSection.expanded && "not ", " open), (", !info.accordionSection.focused && "not ", " focused)"] }), children: o$1("div", { ...bodyProps, children: body }) }) }));
            } });
    }
    function Blurb$a() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/accordion/", children: "In accordance with the ARIA guidelines for Accordion patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["Each section's header and body are linked via ID; the body is ", o$1("code", { children: "labelled-by" }), " the header and the header ", o$1("code", { children: "control" }), "s the body."] }), o$1("li", { children: "The header is a button and responds to keyboard, mouse, touch, etc. events, regardless of the element used." }), o$1("li", { children: ["If the header element is not a ", o$1("code", { children: "<button>" }), " element, it is given that ", o$1("code", { children: "role" }), "."] }), o$1("li", { children: "Up/down & Home/End keys navigate through the list, as does Tab and Shift+Tab" }), o$1("li", {})] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["The ", o$1("code", { children: "render" }), " prop each ", o$1("code", { children: "AccordionSection" }), " takes must wrap the header button with a ", o$1("a", { href: "https://w3c.github.io/aria/#heading", children: "heading" }), " (e.g. ", o$1("code", { children: "h3" }), ", or ", o$1("code", { children: "<Heading>" }), "). See the default implementation for an example."] }) })] }));
    }
    function Code$a() {
        return (o$1("code", { children: `<Accordion render={...}>
    <AccordionSection index={0} render={...} />
    <AccordionSection index={1} render={...} />
    <AccordionSection index={2} render={...} />
</Accordion>` }));
    }
    function Demo$a() {
        return (o$1(p$1, { children: [o$1(Blurb$a, {}), o$1(Code$a, {}), o$1(DemoAccordion, { children: [o$1(DemoAccordionSection, { index: 0, heading: "Accordion section #0", body: "Body content #0", disabled: false }), o$1(DemoAccordionSection, { index: 1, heading: "Accordion section #1", body: "Body content #1", disabled: false }), o$1(DemoAccordionSection, { index: 2, heading: "Accordion section #2 (disabled)", body: "Body content #2", disabled: true }), o$1(DemoAccordionSection, { index: 3, heading: "Accordion section #3 (forced open)", body: "Body content #3", disabled: false, open: true }), o$1(DemoAccordionSection, { index: 4, heading: "Accordion section #4 (forced closed)", body: "Body content #4", disabled: false, open: false })] })] }));
    }

    function Blurb$9() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/button/", children: "In accordance with the ARIA guidelines for Button patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["Whether using an actual ", o$1("code", { children: "<button>" }), ", or something else like a ", o$1("code", { children: "<div>" }), ", the proper roles and event handlers will be applied."] }), o$1("li", { children: "Buttons can be toggled (pressed or unpressed)." }), o$1("li", { children: ["The button responds to keyboard, mouse, touch, etc. events, regardless of the element used.", o$1("ul", { children: [o$1("li", { children: "Double-clicks do not select text, but text is still selectable without it counting as a press/click" }), o$1("li", { children: "When Enter is pressed, the button is immediately activated" }), o$1("li", { children: "When Space is pressed, the button is activated once released" }), o$1("li", { children: "iOS Safari properly focuses the button" })] })] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["If your button contains only an icon (or other non-descriptive content, etc.), you must provide an ", o$1("code", { children: "aria-label" }), " manually stating what happens when the button is pressed."] }) })] }));
    }
    function Code$9() {
        return (o$1("code", { children: `<Button tag="button">Button</Button>
    <Button tag="div">Div</Button>` }));
    }
    function Demo$9() {
        const [pressed, setPressed] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$9, {}), o$1(Code$9, {}), o$1(DemoButton, { disabled: false, tag: "button" }), o$1(DemoButton, { disabled: "soft", tag: "button" }), o$1(DemoButton, { disabled: "hard", tag: "button" }), o$1(DemoButton, { disabled: false, tag: "div" }), o$1(DemoButton, { disabled: "soft", tag: "div" }), o$1(DemoButton, { disabled: "hard", tag: "div" }), o$1(Button, { disabled: false, tag: "button", pressed: pressed, onPress: e => setPressed(e[EventDetail].pressed ?? false), render: defaultRenderButton("button", () => ({ children: `Button (${pressed ? "pressed" : "unpressed"})` })) })] }));
    }
    function DemoButton({ tag, disabled }) {
        return (o$1(Button, { tag: tag, render: defaultRenderButton(tag, ({}) => ({ class: "btn", children: `${tag} ${disabled ? ` disabled (${disabled == "soft" ? "soft" : "hard"})` : ""}` })) }));
    }

    /*function DemoButton({ tag, ...props }: { tag: string } & RenderableProps<{}>) {
        return <Button disabled={disabled} onPress={onPress} pressed={} {...props} tag={tag as any}   />
    }*/
    function Blurb$8() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/checkbox/", children: "In accordance with the ARIA guidelines for Checkbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: "Toggles between checked and unchecked when pressed (clicked, Enter pressed, Space released, etc.)" }), o$1("li", { children: ["Can be ", o$1("code", { children: "mixed" }), " instead, though ", o$1("code", { children: "onInput" }), " will only ever be called with ", o$1("code", { children: "true" }), " or ", o$1("code", { children: "false" })] }), o$1("li", { children: ["Supports using ", o$1("code", { children: "<input>" }), "s and ", o$1("code", { children: "<label>" }), "s, as well as just plain ol' ", o$1("code", { children: "<div>" }), "s on either/both"] }), o$1("li", { children: "The checkbox and label can be sibling elements, like normal, or the label can wrap the input for a larger hit area. In all cases, the appropriate roles/event handlers will be applied to each element." }), o$1("li", { children: "When selecting the text of a checkbox's label, this does not change the checkbox's state" }), o$1("li", { children: "Double-clicking the label checks & un-checks the checkbox instead of selecting the label's text" }), o$1("li", { children: "Checkbox groups (with a tri-state parent) are a separate component/hook" })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", { children: "render" }), " prop and setting ", o$1("code", { children: "labelPosition" }), " to be \"separate\"), you must pass ", o$1("code", { children: "aria-label" }), " as a prop to the checkbox manually. Not providing one will print an error to the console, but it it not required by the type system."] }) })] }));
    }
    function Code$8() {
        return (o$1("code", { children: `<Checkbox checked={true} labelPosition="separate" tagInput="input" tagLabel="label">Label text</Checkbox>` }));
    }
    function Demo$8() {
        const [checked, setChecked] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$8, {}), o$1(Code$8, {}), o$1(Button, { tag: "button", onPress: () => { setChecked("mixed"); }, render: defaultRenderButton("button", () => ({ children: "Change to mixed" })) }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "separate", disabled: false, tagInput: "input", tagLabel: "label" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "wrapping", disabled: false, tagInput: "input", tagLabel: "label" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "separate", disabled: false, tagInput: "div", tagLabel: "label" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "wrapping", disabled: false, tagInput: "div", tagLabel: "label" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "separate", disabled: false, tagInput: "input", tagLabel: "div" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "wrapping", disabled: false, tagInput: "input", tagLabel: "div" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "separate", disabled: false, tagInput: "div", tagLabel: "div" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "wrapping", disabled: false, tagInput: "div", tagLabel: "div" }), o$1(DemoCheckbox$1, { checked: checked, setChecked: setChecked, labelPosition: "hidden", disabled: false, tagInput: "input", tagLabel: "label" })] }));
    }
    function DemoCheckbox$1({ labelPosition, tagInput, tagLabel, disabled, checked, setChecked }) {
        //const [checked, setChecked] = useState(false);
        return (o$1("div", { style: { border: "1px solid black" }, children: [o$1(Checkbox, { disabled: disabled, checked: checked, onCheckedChange: e => setChecked(e[EventDetail].checked), labelPosition: labelPosition == "hidden" ? "separate" : labelPosition, tagInput: tagInput, tagLabel: tagLabel, render: defaultRenderCheckbox({
                        labelPosition,
                        tagInput,
                        tagLabel,
                        makeInputProps: () => ({ "aria-label": labelPosition == "hidden" ? `Hidden label (technically separate), ${tagInput} and ${tagLabel} ${checked ? "checked" : "not checked"}` : undefined, }),
                        makeLabelProps: () => ({ children: `${labelPosition}, ${tagInput} and ${tagLabel}, ${checked ? "checked" : "not checked"}` })
                    }) }), labelPosition == "hidden" && o$1("div", { children: ["(This is not a label -- the actual label is via the ", o$1("code", { children: "aria-label" }), " prop)"] })] }));
    }

    function DemoCheckbox({ index }) {
        const [checked, setChecked] = useState(false);
        const labelText = `Checkbox #${index}`;
        return (o$1(CheckboxGroupCheckbox, { render: defaultRenderCheckboxGroupChild({
                labelPosition: "separate",
                tagInput: "input",
                tagLabel: "label",
                makeInputProps: () => ({}),
                makeLabelProps: () => ({ children: labelText })
            }), checked: checked, index: index, disabled: false, labelPosition: "separate", text: labelText, tagInput: "input", tagLabel: "label", onCheckedChange: e => setChecked(e[EventDetail].checked) }));
    }
    function Blurb$7() {
        return (o$1(p$1, { children: [o$1("p", { children: ["Checkbox groups are an alternative to multi-select lists. There is no role of ", o$1("code", { children: "checkboxgroup" }), ", but this aims to be an ARIA-compliant implementation of a checkbox group."] }), o$1("ul", { children: [o$1("li", { children: ["All normal ", o$1("code", { children: "Checkbox" }), " functionality is supported on each individual checkbox."] }), o$1("li", { children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"." }), o$1("li", { children: ["The parent checkbox reacts to each child's ", o$1("code", { children: "checked" }), " prop and updates its own internal ", o$1("code", { children: "checked" }), " attribute (be aware of this if they're asyncronous, as you'll want to ensure they all resolve on the same tick with ", o$1("code", { children: "Promise.all" }), " to not clobber the user's inputs)."] }), o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["It is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", { children: "role=group" }), " that references that label by overriding ", o$1("code", { children: "render" }), "."] }), o$1("li", { children: ["See the caveat above for when each child's ", o$1("code", { children: "onInput" }), " takes a variable amount of time to actually update the ", o$1("code", { children: "checked" }), " prop, as it can clobber the user's last input when clicking on the parent"] })] })] }));
    }
    function Code$7() {
        return (o$1("code", { children: `` }));
    }
    function Demo$7() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$7, {}), o$1(Code$7, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of checkboxes"] }), o$1("div", { children: o$1(CheckboxGroup, { disabled: false, labelPosition: "separate", tagInput: "input", tagLabel: "label", render: defaultRenderCheckboxGroup({
                            labelPosition: "separate",
                            tagInput: "input",
                            tagLabel: "label",
                            makeInputProps: () => ({}),
                            makeLabelProps: () => ({ children: "Group checkbox parent" }),
                            children: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield o$1("div", { children: o$1(DemoCheckbox, { index: i }, i) });
                                }
                            })())
                        }) }) })] }));
    }

    function DemoListItem$3({ index }) {
        const [selected, setSelected] = useState(false);
        const labelText = `List item #${index}${selected ? " (selected)" : ""}`;
        return (o$1(ListboxMultiItem, { selected: selected, index: index, disabled: false, text: labelText, onSelectedChange: e => { setSelected(e[EventDetail].selected); }, render: defaultRenderListboxMultiItem({ tagListItem: "li", makePropsListItem: () => ({ children: labelText }) }) }));
    }
    function Blurb$6() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "The parent checkbox switches between 3 states, remembering the last state that caused it to be \"mixed\"." }), o$1("li", { children: ["The parent checkbox reacts to each child's ", o$1("code", { children: "checked" }), " prop and updates its own internal ", o$1("code", { children: "checked" }), " attribute (be aware of this if they're asyncronous, as you'll want to ensure they all resolve on the same tick with ", o$1("code", { children: "Promise.all" }), " to not clobber the user's inputs)."] }), o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "Grouping is supported" }), o$1("li", { children: "Sorting/reordering is supported, though not provided by default, as it's mutually exclusive with grouping." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["It is assumed that the parent checkbox provides sufficient labelling for all the children, which how the demo example identifies these elements. If you have a separate label, you will need to wrap the children in a ", o$1("code", { children: "role=group" }), " that references that label by overriding ", o$1("code", { children: "render" }), "."] }), o$1("li", { children: ["See the caveat above for when each child's ", o$1("code", { children: "onInput" }), " takes a variable amount of time to actually update the ", o$1("code", { children: "checked" }), " prop, as it can clobber the user's last input when clicking on the parent"] })] })] }));
    }
    function Code$6() {
        return (o$1("code", { children: `` }));
    }
    function Demo$6() {
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$6, {}), o$1(Code$6, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of list items"] }), o$1("div", { children: o$1(ListboxMulti, { tagLabel: "label", tagList: "ul", render: defaultRenderListboxMulti({
                            tagLabel: "label", tagList: "ul", makePropsLabel: () => ({}), makePropsList: () => ({
                                children: Array.from((function* () {
                                    for (let i = 0; i < count; ++i) {
                                        yield o$1("div", { children: o$1(DemoListItem$3, { index: i }, i) });
                                    }
                                })())
                            })
                        }) }) })] }));
    }

    function getDocument$4() { return window.document; }
    function DemoListItem$2({ index }) {
        return (o$1(ListboxSingleItem, { index: index, getDocument: getDocument$4, disabled: false, text: `List item #${index}`, render: defaultRenderListboxSingleItem({ tagListItem: "li", makePropsListItem: ({ singleSelection: { selected } }) => ({ children: `List item #${index}${selected ? " (selected)" : ""}` }) }) }));
    }
    function Blurb$5() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["In terms of keyboard navigation and tabbing through elements, a Listbox is considered a ", o$1("strong", { children: "single" }), " tab stop; in other words, no matter how many list items there are in a Listbox, it only takes one press of the Tab button to go through it.", o$1("ul", { children: [o$1("li", { children: "When a Listbox is tabbed into, the most recently selected item is given focus" }), o$1("li", { children: "Pressing Tab again navigates out of the listbox; no other list items are tabbable other than the one currently designated." }), o$1("li", { children: "Pressing the arrow keys navigates through the Listbox one item at a time" }), o$1("li", { children: "Pressing the Home/End keys move focus to the first/last items respectively" }), o$1("li", { children: "Typing any sequence of text starts typeahead that navigates to the next item that matches what's being typed" }), o$1("li", { children: "Focus & selection management is as optimized as possible; only two children re-render at a time when focus or selection changes" }), o$1("li", { children: "These apply generally to all composite components with a variable number of children (Tab Lists, Radio Groups, Multi-Select Listboxes etc.)" })] })] }), o$1("li", { children: ["Rather than each individual list item knowing whether it is selected or not (as with multi-select lists), here the parent knows the ", o$1("code", { children: "selectedIndex" }), " and simply notifies the (max two) relevant children any time it changes."] }), o$1("li", { children: "Grouping is supported" }), o$1("li", { children: "Sorting/reordering is supported, though not provided by default, as it's mutually exclusive with grouping." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "Listboxes do not support interactive content within them (e.g. a dropdown menu), as ARIA specifies that this is a different pattern." }) })] }));
    }
    function Code$5() {
        return (o$1("code", { children: `` }));
    }
    function Demo$5() {
        const [selectedIndex, setSelectedIndex] = useState(null);
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$5, {}), o$1(Code$5, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of list items"] }), o$1("div", { children: o$1(ListboxSingle, { render: defaultRenderListboxSingle({
                            tagLabel: "label", tagList: "ol", makePropsLabel: () => ({}), makePropsList: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1("div", { children: o$1(DemoListItem$2, { index: i }, i) });
                                        }
                                    })()) })
                            })
                        }), selectionMode: "activation", tagLabel: "label", tagList: "ol", selectedIndex: selectedIndex, onSelect: e => setSelectedIndex(e[EventDetail].selectedIndex) }) })] }));
    }

    function DemoListItem$1({ index }) {
        return (o$1(MenuItem, { index: index, text: `List item #${index}`, render: defaultRenderMenuItem({ tagMenuItem: "li", makePropsMenuItem: () => ({ children: `Menu item #${index}` }) }) }));
    }
    function getDocument$3() { return window.document; }
    function Blurb$4() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it." }), o$1("li", { children: "When the menu is closed because another element on the page was focused instead, focus will not be modified." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code$4() {
        return (o$1("code", { children: `` }));
    }
    function Demo$4() {
        const [count, setCount] = useState(5);
        const [open, setOpen] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$4, {}), o$1(Code$4, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of menu items"] }), o$1("div", { children: o$1(Menu, { getDocument: getDocument$3, onOpen: () => setOpen(true), onClose: () => setOpen(false), open: open, openDirection: "down", render: defaultRenderMenu({
                            tagButton: "button",
                            tagMenu: "ul",
                            tagSentinel: "div",
                            tagSurface: "div",
                            portalId: "portal",
                            makePropsButton: () => ({ children: "Open menu" + (open ? " (open)" : " (closed)") }),
                            makePropsMenu: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1("div", { children: o$1(DemoListItem$1, { index: i }, i) });
                                        }
                                    })()) })
                            }),
                            makePropsSurface: () => ({ style: { display: !open ? "none" : undefined } }),
                            makePropsSentinel: () => ({}),
                        }) }) })] }));
    }

    function getDocument$2() {
        return window.document;
    }
    function DemoListItem({ index }) {
        const value = `Radio button #${index}`;
        return (o$1(Radio, { index: index, getDocument: getDocument$2, disabled: false, labelPosition: "separate", text: value, value: index, tagInput: "input", tagLabel: "label", render: defaultRenderRadio({
                labelPosition: "separate",
                tagInput: "input",
                tagLabel: "label",
                makeInputProps: () => ({ name: "radio-demo" }),
                makeLabelProps: () => ({ children: value })
            }) }));
    }
    function Blurb$3() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/radiobutton/", children: "In accordance with the ARIA guidelines for Radio Button patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "The input & label support the same text-selection affordances as Checkboxes (labels can be selected, but double-clicking doesn't select the text and selecting text doesn't count as an input)" }), o$1("li", { children: "Selection state is handled by the parent; instead of specifying whether any given radio button is checked or not, the parent notifies each child of the necessary changes." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["If your checkbox does not have a visible label (achievable by by overriding the ", o$1("code", { children: "render" }), " prop and setting ", o$1("code", { children: "labelPosition" }), " to be \"separate\"), you must pass ", o$1("code", { children: "aria-label" }), " as a prop to the checkbox manually. Not providing one will print an error to the console, but it it not required by the type system."] }), o$1("li", { children: ["The above also applies to the radio group as a whole; ARIA requires that all Radio Buttons be contained within an element with a specific role which is labelled either by an element (handled for you) or ", o$1("code", { children: "aria-label" }), " (specified by you manually on the input)."] })] })] }));
    }
    function Code$3() {
        return (o$1("code", { children: `` }));
    }
    function Demo$3() {
        const [selectedIndex, setSelectedIndex] = useState(null);
        const [count, setCount] = useState(5);
        return (o$1(p$1, { children: [o$1(Blurb$3, {}), o$1(Code$3, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of radio buttons"] }), o$1("div", { children: o$1(RadioGroup, { name: "radio-demo", onSelectedValueChange: e => setSelectedIndex(e[EventDetail].selectedValue ?? 0), selectedValue: selectedIndex, tagGroupLabel: "label", tagGroup: "div", render: defaultRenderRadioGroup({
                            tagGroup: "div",
                            tagLabel: "label",
                            makePropsGroup: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1(DemoListItem, { index: i }, i);
                                        }
                                    })()) })
                            }),
                            makePropsLabel: (info) => ({ children: "Radio group example " + "(" + info.radioGroup.selectedIndex?.toString() + ")" })
                        }) }) })] }));
    }

    function DemoSliderThumb({ index }) {
        const [value, setValue] = useState(0);
        return (o$1(SliderThumb, { index: index, tag: "input", label: `Slider thumb #${index}`, value: value, onValueChange: e => setValue(e[EventDetail].value), min: 0, max: 10, render: defaultRenderSliderThumb({ tagThumb: "input", makePropsThumb: () => ({}) }) }));
    }
    function Blurb$2() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/listbox/", children: "In accordance with the ARIA guidelines for Listbox patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: ["The children are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }), o$1("li", { children: "When opened, the menu will focus the first element within it. When closed (by pressing escape, pressing the button again, or tabbing out of the menu), the button that opened it will have focus restored to it." }), o$1("li", { children: "When the menu is closed because another element on the page was focused instead, focus will not be modified." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code$2() {
        return (o$1("code", { children: `` }));
    }
    function Demo$2() {
        const [count, setCount] = useState(5);
        useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$2, {}), o$1(Code$2, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of slider thumbs"] }), o$1("div", { children: o$1(Slider, { min: 0, max: 10, children: o$1(p$1, { children: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield o$1("div", { children: o$1(DemoSliderThumb, { index: i }, i) });
                                }
                            })()) }) }) })] }));
    }

    function getDocument$1() { return window.document; }
    function Blurb$1() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/dialogmodal/", children: "In accordance with the ARIA guidelines for Modal Dialog patterns," }), " this widget supports the following:"] }), o$1("ul", { children: [o$1("li", { children: "Dialogs block all other elements on the page from receiving focus/interaction and being perceivable to screen readers." }), o$1("li", { children: "Dialogs can be dismissed by pressing Escape or clicking the element designated as the backdrop, both of which can be cancelled/ignored if you need" }), o$1("li", { children: "When opened, the dialog will focus its title or body content as appropriate, however read below under Things Not Handled for caveats." }), o$1("li", { children: "When closed for any reason, the element that was responsible for opening the dialog will be focused." })] }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: [o$1("li", { children: ["By default, when opened, a dialog will focus its body content or title content depending on ", o$1("code", { children: "bodyIsOnlySemantic" }), ", which indicates that the dialog's body contains no interactive elements. This may not be suitable for all situations."] }), o$1("li", { children: ["It is ", o$1("em", { children: "hightly" }), " recommended to override ", o$1("code", { children: "focusSelf" }), " for all dialogs you create, and have it focus whatever element makes the most sense for your particular dialog.", o$1("ul", { children: [o$1("li", { children: "Dialogs that act like a form should focus the first interactive element" }), o$1("li", { children: "Dialogs that perform destructive actions should focus the \"Cancel\" button" }), o$1("li", { children: "In some cases, it's best to focus the first paragraph of the body." })] }), "In all cases, consider that the first focused element will both be how keyboard users interact with the dialog, but also the first thing a screen reader will read aloud."] })] })] }));
    }
    function Code$1() {
        return (o$1("code", { children: `` }));
    }
    function Demo$1() {
        const [open, setOpen] = useState(false);
        return (o$1(p$1, { children: [o$1(Blurb$1, {}), o$1(Code$1, {}), o$1("div", { children: [o$1(Button, { tag: "button", onPress: () => setOpen(true), render: defaultRenderButton("button", () => ({ children: "Open dialog " + (open ? "(open)" : "(closed)") })) }), o$1(Dialog, { getDocument: getDocument$1, onClose: () => setOpen(false), open: open, bodyIsOnlySemantic: true, render: defaultRenderDialog({
                                portalId: "portal",
                                makePropsBackdrop: () => ({}),
                                makePropsFocusContainer: () => ({}),
                                makePropsBody: () => ({ children: "Dialog body" }),
                                makePropsDialog: () => ({ style: { display: !open ? "none" : undefined } }),
                                makePropsTitle: () => ({ children: "Dialog title" }),
                                tagBackdrop: "div",
                                tagBody: "div",
                                tagDialog: "div",
                                tagTitle: "div",
                                tagFocusContainer: "div"
                            }) })] })] }));
    }

    function getDocument() { return window.document; }
    function Blurb() {
        return (o$1(p$1, { children: [o$1("p", { children: [o$1("a", { href: "https://www.w3.org/WAI/ARIA/apg/patterns/tabpanel/", children: "In accordance with the ARIA guidelines for Tab and Tab Panel patterns," }), " this widget supports the following:"] }), o$1("ul", { children: o$1("li", { children: ["The tabs are treated as a composite component with list navigation; see ", o$1("code", { children: "AiraSingleSelectList" }), " for more information"] }) }), o$1("p", { children: o$1("strong", { children: ["Things ", o$1("em", { children: "not" }), " handled:"] }) }), o$1("ul", { children: o$1("li", { children: "TODO" }) })] }));
    }
    function Code() {
        return (o$1("code", { children: `` }));
    }
    function Demo() {
        const [count, setCount] = useState(5);
        const [selectedIndex, setSelectedIndex] = useState(0);
        return (o$1(p$1, { children: [o$1(Blurb, {}), o$1(Code, {}), o$1("label", { children: [o$1("input", { type: "number", min: 0, value: count, onInput: e => setCount(e.currentTarget.valueAsNumber) }), " # of tabs"] }), o$1("div", { children: o$1(Tabs, { selectedIndex: selectedIndex, selectionMode: "focus", onSelectedIndexChange: e => setSelectedIndex(e[EventDetail].selectedIndex), render: defaultRenderTabs({
                            panels: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield o$1(DemoTabPanel, { i: i });
                                }
                            })()),
                            tagLabel: "label",
                            tagList: "ul",
                            makePropsLabel: () => ({ children: "Tabs example" }),
                            makePropsList: () => ({
                                children: o$1(p$1, { children: Array.from((function* () {
                                        for (let i = 0; i < count; ++i) {
                                            yield o$1(DemoTab, { i: i });
                                        }
                                    })()) })
                            })
                        }) }) })] }));
    }
    const DemoTab = w(function DemoTab({ i }) {
        const label = `Tab #${i}`;
        return o$1(Tab, { index: i, getDocument: getDocument, render: defaultRenderTab({ tagTab: "li", makePropsTab: () => ({ children: label }) }), text: label }, i);
    });
    const DemoTabPanel = w(function DemoTabPanel({ i }) {
        const label = `Tab panel #${i}`;
        return o$1(TabPanel, { index: i, render: defaultRenderTabPanel({ tagTabPanel: "div", makePropsTabPanel: ({ tabPanel: { visible } }) => ({ hidden: !visible, children: label }) }) }, i);
    });

    //import { options } from "preact";
    //options.debounceRendering = queueMicrotask;
    //const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const Component = () => {
        return (o$1(Heading, { heading: "Demos", children: [o$1(Heading, { heading: "Tabs", children: o$1(Demo, {}) }), o$1(Heading, { heading: "Dialog", children: o$1(Demo$1, {}) }), o$1(Heading, { heading: "Slider", children: o$1(Demo$2, {}) }), o$1(Heading, { heading: "Single-select Listbox", children: o$1(Demo$5, {}) }), o$1(Heading, { heading: "Accordion", children: o$1(Demo$a, {}) }), o$1(Heading, { heading: "Button", children: o$1(Demo$9, {}) }), o$1(Heading, { heading: "Checkbox", children: o$1(Demo$8, {}) }), o$1(Heading, { heading: "Checkbox Group", children: o$1(Demo$7, {}) }), o$1(Heading, { heading: "Multi-select Listbox", children: o$1(Demo$6, {}) }), o$1(Heading, { heading: "Menu", children: o$1(Demo$4, {}) }), o$1(Heading, { heading: "Radio", children: o$1(Demo$3, {}) })] }));
    };
    requestAnimationFrame(() => {
        P$1(o$1(Component, {}), document.getElementById("root"));
    });

})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyIuLi9zcmMvcHJvcHMudHMiLCIuLi9zcmMvY29tcG9uZW50L2hlYWRpbmcudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1wYXNzaXZlLXN0YXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtYWN0aXZlLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1zdGFibGUtY2FsbGJhY2sudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1hbmltYXRpb24tZnJhbWUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXN0YXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtY2hpbGQtbWFuYWdlci50c3giLCIuLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZG9jdW1lbnQtY2xhc3MudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtY2hpbGRyZW4udHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1tZXJnZWQtY2xhc3Nlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1yZWZzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtbWVyZ2VkLXN0eWxlcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLW1lcmdlZC1wcm9wcy50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXJlZi1lbGVtZW50LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZXZlbnQtaGFuZGxlci50c3giLCIuLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvc3JjL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3dpY2ctaW5lcnQvZGlzdC9pbmVydC5qcyIsIi4uL25vZGVfbW9kdWxlcy9ibG9ja2luZy1lbGVtZW50cy9zcmMvYmxvY2tpbmctZWxlbWVudHMudHMiLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWJsb2NraW5nLWVsZW1lbnQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1mb2N1cy10cmFwLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtZm9yY2UtdXBkYXRlLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtaGFzLWZvY3VzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2UtcHJlc3MudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1sb2dpY2FsLWRpcmVjdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXRpbWVvdXQudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9wcmVhY3QtcHJvcC1oZWxwZXJzL3NyYy91c2Utcm92aW5nLXRhYmluZGV4LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSYW5kb20uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaHVmZmxlU2VsZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5U2h1ZmZsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVZhbHVlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0xlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5hcnkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19ub2RlVXRpbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzUHJvdG90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3ZhbHVlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTaHVmZmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zaHVmZmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3ByZWFjdC1wcm9wLWhlbHBlcnMvc3JjL3VzZS1zb3J0YWJsZS1jaGlsZHJlbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWxpc3QtbmF2aWdhdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLWdyaWQtbmF2aWdhdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvcHJlYWN0LXByb3AtaGVscGVycy9zcmMvdXNlLXJhbmRvbS1pZC50c3giLCIuLi9zcmMvdXNlLWJ1dHRvbi50cyIsIi4uL3NyYy91c2UtYWNjb3JkaW9uLnRzeCIsIi4uL3NyYy91c2UtbGFiZWwudHMiLCIuLi9zcmMvdXNlLWNoZWNrYm94LnRzIiwiLi4vc3JjL3VzZS1jaGVja2JveC1ncm91cC50cyIsIi4uL3NyYy91c2UtbW9kYWwudHMiLCIuLi9zcmMvdXNlLWxpc3Rib3gtc2luZ2xlLnRzIiwiLi4vc3JjL3VzZS1saXN0Ym94LW11bHRpLnRzIiwiLi4vc3JjL3VzZS1tZW51LnRzIiwiLi4vc3JjL3VzZS10YWJzLnRzIiwiLi4vc3JjL3VzZS10b29sdGlwLnRzIiwiLi4vc3JjL3VzZS1yYWRpby1ncm91cC50c3giLCIuLi9zcmMvdXNlLXRhYmxlLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvYWNjb3JkaW9uLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvYnV0dG9uLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvY2hlY2tib3gudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9jaGVja2JveC1ncm91cC50c3giLCIuLi9zcmMvY29tcG9uZW50L2RpYWxvZy50c3giLCIuLi9zcmMvY29tcG9uZW50L2xpc3Rib3gtc2luZ2xlLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvbGlzdGJveC1tdWx0aS50c3giLCIuLi9zcmMvY29tcG9uZW50L21lbnUudHN4IiwiLi4vc3JjL2NvbXBvbmVudC9yYWRpby1ncm91cC50c3giLCIuLi9zcmMvY29tcG9uZW50L3NsaWRlci50c3giLCIuLi9zcmMvY29tcG9uZW50L3RhYmxlLnRzeCIsIi4uL3NyYy9jb21wb25lbnQvdGFicy50c3giLCIuLi9zcmMvY29tcG9uZW50L3Rvb2x0aXAudHN4IiwiZGVtb3MvYWNjb3JkaW9uLnRzeCIsImRlbW9zL2J1dHRvbi50c3giLCJkZW1vcy9jaGVja2JveC50c3giLCJkZW1vcy9jaGVja2JveC1ncm91cC50c3giLCJkZW1vcy9saXN0Ym94LW11bHRpLnRzeCIsImRlbW9zL2xpc3Rib3gtc2luZ2xlLnRzeCIsImRlbW9zL21lbnUudHN4IiwiZGVtb3MvcmFkaW8udHN4IiwiZGVtb3Mvc2xpZGVyLnRzeCIsImRlbW9zL2RpYWxvZy50c3giLCJkZW1vcy90YWJzLnRzeCIsImluZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoLCBSZWYgfSBmcm9tIFwicHJlYWN0XCI7XG5cbmV4cG9ydCB0eXBlIFJlZkZyb21UYWc8VCBleHRlbmRzIGtleW9mIGguSlNYLkludHJpbnNpY0VsZW1lbnRzPiA9IE5vbk51bGxhYmxlPGguSlNYLkludHJpbnNpY0VsZW1lbnRzW1RdW1wicmVmXCJdPiAmIFJlZjxhbnk+O1xuZXhwb3J0IHR5cGUgRWxlbWVudEZyb21SZWY8UiBleHRlbmRzIFJlZjxhbnk+PiA9IFIgZXh0ZW5kcyBSZWY8aW5mZXIgRT4gPyBFIDogRXZlbnRUYXJnZXQ7XG5leHBvcnQgdHlwZSBFbGVtZW50RnJvbVRhZzxUIGV4dGVuZHMga2V5b2YgaC5KU1guSW50cmluc2ljRWxlbWVudHM+ID0gRWxlbWVudEZyb21SZWY8UmVmRnJvbVRhZzxUPj47XG5cbmV4cG9ydCB0eXBlIEVsZW1lbnRUb1RhZzxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0ga2V5b2YgU3ViVHlwZTxIVE1MRWxlbWVudFRhZ05hbWVNYXAsIEU+O1xudHlwZSBTdWJUeXBlPEJhc2UsIENvbmRpdGlvbj4gPSBQaWNrPEJhc2UsIHtcbiAgICBbS2V5IGluIGtleW9mIEJhc2VdOiBCYXNlW0tleV0gZXh0ZW5kcyBDb25kaXRpb24gPyBLZXkgOiBuZXZlclxufVtrZXlvZiBCYXNlXT47XG5cbi8qKlxuICogRm9yIHRpbWVzIHdoZW4gbW9yZSB0aGFuIGp1c3QgdGhlIGFic3RyYWN0IGVsZW1lbnQgdHlwZSBpcyBuZWVkZWQsXG4gKiBidXQgdGhlIGFjdHVhbCwgY29uY3JldGUsIGltcGxlbWVudGF0aW9uLWFmZmVjdGluZyBcImRpdlwiIHN0cmluZyB0eXBlLlxuICogXG4gKiBUT0RPOiBTaG91bGQgdGhpcyBiZSB0aGUgc3RhbmRhcmQgZm9yIGFsbCB0aGUgbm9uLUFSSUEgaG9va3M/XG4gKiBUaGV5ICpuZXZlciogY2FyZSBhYm91dCB0aGUgc3BlY2lmaWMgdHlwZSBmb3IgdGhlIGltcGxlbWVudGF0aW9uLFxuICoganVzdCBmb3IgdHlwaW5nLCBzbyBpdCB3b3VsZG4ndCBiZSBuZWNlc3NhcnksIFxuICogYnV0IGl0IHdvdWxkIGJlIGNvbnNpc3RlbnQgd2l0aCB0aGVzZSBBUklBIGhvb2tzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRhZ1NlbnNpdGl2ZVByb3BzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIHRhZzogRWxlbWVudFRvVGFnPEU+O1xufVxuXG5leHBvcnQgY29uc3QgRXZlbnREZXRhaWwgPSBTeW1ib2woXCJldmVudC1kZXRhaWxcIik7XG5leHBvcnQgdHlwZSBFdmVudERldGFpbCA9IHR5cGVvZiBFdmVudERldGFpbDtcbmV4cG9ydCB0eXBlIEVuaGFuY2VkRXZlbnQ8VGFyZ2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQsIFR5cGVkRXZlbnQgZXh0ZW5kcyBFdmVudCwgRGV0YWlsPiA9IGguSlNYLlRhcmdldGVkRXZlbnQ8VGFyZ2V0LCBUeXBlZEV2ZW50PiAmIHtcbiAgICBbRXZlbnREZXRhaWxdOiBEZXRhaWw7XG59O1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBlbmhhbmNlRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUeXBlZEV2ZW50IGV4dGVuZHMgRXZlbnQsIERldGFpbCBleHRlbmRzIG9iamVjdD4oZTogVHlwZWRFdmVudCB8IGguSlNYLlRhcmdldGVkRXZlbnQ8RSwgVHlwZWRFdmVudD4sIGRldGFpbDogRGV0YWlsKTogRW5oYW5jZWRFdmVudDxFLCBUeXBlZEV2ZW50LCBEZXRhaWw+IHtcbiAgICBjb25zdCBldmVudCA9IGUgYXMgdW5rbm93biBhcyBFbmhhbmNlZEV2ZW50PEUsIFR5cGVkRXZlbnQsIERldGFpbD47XG4gICAgZXZlbnRbRXZlbnREZXRhaWxdID0gZGV0YWlsO1xuICAgIHJldHVybiBldmVudDtcbn1cblxuXG5jb25zdCBhbHJlYWR5V2FybmVkID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbnR5cGUgV09PID0gc3RyaW5nIHwgbnVtYmVyIHwgbnVsbCB8IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuT25PdmVyd3JpdGU8VCBleHRlbmRzIFdPTz4oY29tcG9uZW50TmFtZTogc3RyaW5nLCBwcm9wTmFtZTogc3RyaW5nLCBwcm9wVmFsdWU6IFdPTywgbmV3VmFsdWU6IFQpOiBUIHtcbiAgICBjb25zdCBrZXkgPSBgJHtjb21wb25lbnROYW1lfTske3Byb3BOYW1lfWA7XG4gICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGlmICghYWxyZWFkeVdhcm5lZC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgYWxyZWFkeVdhcm5lZC5hZGQoa2V5KTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhlICR7cHJvcE5hbWV9IGF0dHJpYnV0ZSBvbiAke2NvbXBvbmVudE5hbWV9IHdhcyBnaXZlbiBhIHZhbHVlIG9mICR7cHJvcFZhbHVlfSBidXQgaXMgYmVpbmcgb3ZlcndyaXR0ZW4gdG8gJHtuZXdWYWx1ZX0gZm9yIGNvbmZvcm1hbmNlLiBDb25zaWRlciByZW1vdmluZyBpdCBiZWZvcmUgcGFzc2luZyB0aG9zZSBwcm9wcyB0byAke2NvbXBvbmVudE5hbWV9LmApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufVxuXG5sZXQgZGVidWcgPSB0cnVlO1xuZXhwb3J0IGZ1bmN0aW9uIHNldERlYnVnTG9nZ2luZyhsb2dnaW5nOiBib29sZWFuKSB7XG4gICAgZGVidWcgPSBsb2dnaW5nO1xufVxuXG5leHBvcnQgdHlwZSBEZWJ1Z0xvZ1R5cGVzID1cbiAgICBcInVzZUFyaWFBY2NvcmRpYW5cIiB8IFwidXNlQXJpYUFjY29yZGlhblNlY3Rpb25cIiB8XG4gICAgXCJ1c2VBcmlhQnV0dG9uXCIgfFxuICAgIFwidXNlQXJpYUNoZWNrYm94XCIgfFxuICAgIFwidXNlQXJpYUNoZWNrYm94R3JvdXBcIiB8IFwidXNlQXJpYUNoZWNrYm94R3JvdXBQYXJlbnRcIiB8IFwidXNlQXJpYUNoZWNrYm94R3JvdXBDaGlsZFwiIHxcbiAgICBcInVzZUFyaWFEaWFsb2dcIiB8IFwidXNlQXJpYURyYXdlclwiIHxcbiAgICBcInVzZUFyaWFMaXN0Ym94TXVsdGlcIiB8IFwidXNlQXJpYUxpc3Rib3hNdWx0aUl0ZW1cIiB8XG4gICAgXCJ1c2VBcmlhTGlzdGJveFNpbmdsZVwiIHwgXCJ1c2VBcmlhTGlzdGJveFNpbmdsZUl0ZW1cIiB8XG4gICAgXCJ1c2VBcmlhTWVudVwiIHwgXCJ1c2VBcmlhTWVudVN1cmZhY2VcIiB8IFwidXNlQXJpYU1lbnVJdGVtXCIgfCBcInVzZUFyaWFGb2N1c1NlbnRpbmVsXCIgfCBcInVzZUFyaWFNZW51U3VyZmFjZVNlbnRpbmVsXCIgfFxuICAgIFwidXNlQXJpYVJhZGlvR3JvdXBcIiB8IFwidXNlQXJpYVJhZGlvXCIgfFxuICAgIFwidXNlQXJpYVNsaWRlclwiIHwgXCJ1c2VBcmlhU2xpZGVyVGh1bWJcIiB8XG4gICAgXCJ1c2VBcmlhVGFibGVcIiB8IFwidXNlQXJpYVRhYmxlUm93XCIgfCBcInVzZUFyaWFUYWJsZUNlbGxcIiB8IFwidXNlQXJpYVRhYmxlQm9keVwiIHxcbiAgICBcInVzZUFyaWFUYWJzXCIgfCBcInVzZUFyaWFUYWJMaXN0XCIgfCBcInVzZUFyaWFUYWJcIiB8IFwidXNlQXJpYVRhYlBhbmVsXCIgfFxuICAgIFwidXNlQXJpYVRvYXN0c1wiIHwgXCJ1c2VBcmlhVG9hc3RcIiB8XG4gICAgXCJ1c2VBcmlhVG9vbHRpcFwiIHwgXCJ1c2VBcmlhVG9vbHRpcFRvb2x0aXBcIiB8IFwidXNlQXJpYVRvb2x0aXBUcmlnZ2VyXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1Z0xvZyh3aG86IERlYnVnTG9nVHlwZXMsIC4uLmFyZ3M6IFBhcmFtZXRlcnM8KHR5cGVvZiBjb25zb2xlKVtcImxvZ1wiXT4pIHtcbiAgICBpZiAoZGVidWcpXG4gICAgICAgIGNvbnNvbGUuZGVidWcod2hvICsgXCI6XCIsIC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgdHlwZSBQcm9wTW9kaWZpZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xuIiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgd2Fybk9uT3ZlcndyaXRlIH0gZnJvbSBcIi4uL3Byb3BzXCI7XG5cbmNvbnN0IEhlYWRpbmdMZXZlbENvbnRleHQgPSBjcmVhdGVDb250ZXh0KDApO1xuXG5leHBvcnQgZnVuY3Rpb24gSGVhZGluZyh7IGNoaWxkcmVuLCBoZWFkaW5nLCAuLi5wcm9wcyB9OiB7IGhlYWRpbmc6IENvbXBvbmVudENoaWxkcmVuIH0gJiBoLkpTWC5IVE1MQXR0cmlidXRlczxIVE1MSGVhZGluZ0VsZW1lbnQ+KSB7XG4gICAgY29uc3QgaGVhZGluZ0xldmVsQmVmb3JlVXMgPSB1c2VDb250ZXh0KEhlYWRpbmdMZXZlbENvbnRleHQpO1xuICAgIGNvbnN0IG5ld0hlYWRpbmdMZXZlbCA9IGhlYWRpbmdMZXZlbEJlZm9yZVVzICsgMTtcbiAgICBsZXQgdGFnOiBzdHJpbmc7XG4gICAgaWYgKG5ld0hlYWRpbmdMZXZlbCA8PSA2KSB7XG4gICAgICAgIHRhZyA9IGBoJHtuZXdIZWFkaW5nTGV2ZWx9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhZyA9ICdkaXYnO1xuICAgICAgICBwcm9wc1tcImFyaWEtbGV2ZWxcIl0gPSB3YXJuT25PdmVyd3JpdGUoXCJIZWFkaW5nXCIsIFwiYXJpYS1sZXZlbFwiLCBwcm9wc1tcImFyaWEtbGV2ZWxcIl0sIGAke25ld0hlYWRpbmdMZXZlbH1gKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgPEhlYWRpbmdSZXNldCBuZXdMZXZlbD17aGVhZGluZ0xldmVsQmVmb3JlVXMgKyAxfT5cbiAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZyBhcyBhbnksIHByb3BzLCBoZWFkaW5nKX1cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9IZWFkaW5nUmVzZXQ+XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhlYWRpbmdSZXNldCh7IG5ld0xldmVsLCBjaGlsZHJlbiB9OiB7IG5ld0xldmVsOiBudW1iZXIsIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbiB9KXsgICAgXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEhlYWRpbmdMZXZlbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e25ld0xldmVsfT5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9IZWFkaW5nTGV2ZWxDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn1cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IG9wdGlvbnMgfSBmcm9tIFwicHJlYWN0XCJcblxuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTPiA9ICh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQ+ID0gKCh2YWx1ZTogVCwgcHJldlZhbHVlOiBUIHwgdW5kZWZpbmVkKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpO1xuXG4vKipcbiAqIERlYnVnIGhvb2suXG4gKiBcbiAqIEdpdmVuIGEgdmFsdWUgb3Igc2V0IG9mIHZhbHVlcywgZW1pdHMgYSBjb25zb2xlIGVycm9yIGlmIGFueSBvZiB0aGVtIGNoYW5nZSBmcm9tIG9uZSByZW5kZXIgdG8gdGhlIG5leHQuXG4gKiBcbiAqIEV2ZW50dWFsbHksIHdoZW4gdXNlRXZlbnQgbGFuZHMsIHdlIGhvcGVmdWxseSB3b24ndCBuZWVkIHRoaXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFbnN1cmVTdGFiaWxpdHk8VCBleHRlbmRzIGFueVtdPihwYXJlbnRIb29rTmFtZTogc3RyaW5nLCAuLi52YWx1ZXM6IFQpIHtcbiAgICB1c2VIZWxwZXIodmFsdWVzLmxlbmd0aCwgMCk7XG4gICAgdmFsdWVzLmZvckVhY2godXNlSGVscGVyKTtcbiAgICByZXR1cm47XG5cblxuICAgIGZ1bmN0aW9uIHVzZUhlbHBlcjxVPih2YWx1ZTogVSwgaW5kZXg6IG51bWJlcikge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICAgICAgY29uc3QgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkgPSB1c2VSZWYodmFsdWUpO1xuICAgICAgICBjb25zdCBzaG93bkVycm9yID0gdXNlUmVmKGZhbHNlKTtcbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnQgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghc2hvd25FcnJvci5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBUaGUgaG9vayAke3BhcmVudEhvb2tOYW1lfSByZXF1aXJlcyBzb21lIG9yIGFsbCBvZiBpdHMgYXJndW1lbnRzIHJlbWFpbiBzdGFibGUgYWNyb3NzIGVhY2ggcmVuZGVyOyBwbGVhc2UgY2hlY2sgdGhlICR7aW5kZXh9LWluZGV4ZWQgYXJndW1lbnQuYCk7XG4gICAgICAgICAgICAgICAgc2hvd25FcnJvci5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlUmVuZGVyaW5nKGY6ICgpID0+IHZvaWQpIHtcbiAgICAob3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA/PyBzZXRUaW1lb3V0KShmKTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGB1c2VTdGF0ZWAsIGJ1dCBmb3IgdmFsdWVzIHRoYXQgYXJlbid0IFwicmVuZGVyLWltcG9ydGFudFwiICZuZGFzaDsgdXBkYXRlcyBkb24ndCBjYXVzZSBhIHJlLXJlbmRlciBhbmQgc28gdGhlIHZhbHVlIHNob3VsZG4ndCBiZSB1c2VkIGR1cmluZyByZW5kZXIgKHRob3VnaCBpdCBjZXJ0YWlubHkgY2FuLCBhdCBsZWFzdCBieSByZS1yZW5kZXJpbmcgYWdhaW4pLlxuICogXG4gKiBUbyBjb21wZW5zYXRlIGZvciB0aGlzLCB5b3Ugc2hvdWxkIHBhc3MgYSBgdXNlRWZmZWN0YC1lc3F1ZSBjYWxsYmFjayB0aGF0IGlzIHJ1biB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcy4gIEp1c3QgbGlrZSBgdXNlRWZmZWN0YCwgdGhpcyBjYWxsYmFjayBjYW4gcmV0dXJuIGEgY2xlYW51cCBmdW5jdGlvbiB0aGF0J3MgcnVuIGJlZm9yZSB0aGUgdmFsdWUgY2hhbmdlcy4gIElmIHlvdSB3b3VsZCBsaWtlIHRvIHJlLXJlbmRlciB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIChvciwgc2F5LCB3aGVuIHRoZSB2YWx1ZSBtZWV0cyBzb21lIGNyaXRlcmlhKSwgdGhpcyBpcyB3aGVyZSB5b3UnbGwgd2FudCB0byBwdXQgaW4gYSBjYWxsIHRvIGEgYHNldFN0YXRlYCBmdW5jdGlvbi5cbiAqIFxuICogVG8gc3VtbWFyaXplLCBpdCdzIGxpa2UgYSBgdXNlU3RhdGVgLWB1c2VFZmZlY3RgIG1hc2h1cDpcbiAqIFxuICogMS4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB0aGlzIHZlcnNpb24gb2YgYHNldFN0YXRlYCBkb2Vzbid0IHJlLXJlbmRlciB0aGUgd2hvbGUgY29tcG9uZW50XG4gKiAyLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHlvdSBjYW4gcnVuIGEgZnVuY3Rpb24gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyB0aGF0IG9wdGlvbmFsbHkgcmV0dXJucyBhIGNsZWFudXAgZnVuY3Rpb25cbiAqIDMuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHlvdSB0cmlnZ2VyIHRoZSBlZmZlY3QgZnVuY3Rpb24gXCJyZW1vdGVseVwiIGluc3RlYWQgb2YgaXQgcnVubmluZyBhZnRlciByZW5kZXJpbmdcbiAqIDQuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHRoZSBzaW5nbGUgXCJkZXBlbmRlbmN5XCIgaXMgYmFzZWQgb24geW91ciBjYWxscyB0byBgc2V0U3RhdGVgXG4gKiBcbiAqIE5vdGUgdGhhdCB3aGlsZSBjYWxsaW5nIGBzZXRTdGF0ZWAgZG9lc24ndCBjYXVzZSBhbnkgcmUtcmVuZGVycywgeW91IGNhbiBkbyB0aGF0IHdpdGhpbiB5b3VyIGBvbkNoYW5nZWAgZnVuY3Rpb24sIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcyB2aWEgdGhhdCBgc2V0U3RhdGVgLlxuICogXG4gKiBAcGFyYW0gb25DaGFuZ2UgVGhlIFwiZWZmZWN0XCIgZnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuIEVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIGB1c2VFZmZlY3RgJ3MgXCJlZmZlY3RcIiBmdW5jdGlvbi4gIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXG4gKiBAcGFyYW0gZ2V0SW5pdGlhbFZhbHVlIElmIHByb3ZpZGVkLCB0aGUgZWZmZWN0IHdpbGwgYmUgaW52b2tlZCBvbmNlIHdpdGggdGhpcyB2YWx1ZSBvbiBtb3VudC4gTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFzc2l2ZVN0YXRlPFQ+KG9uQ2hhbmdlOiB1bmRlZmluZWQgfCBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VD4sIGdldEluaXRpYWxWYWx1ZT86ICgpID0+IFQpOiByZWFkb25seSBbZ2V0U3RhdGVTdGFibGU6ICgpID0+IFQsIHNldFN0YXRlU3RhYmxlOiBQYXNzaXZlU3RhdGVVcGRhdGVyPFQ+XSB7XG5cbiAgICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZjxUIHwgdHlwZW9mIFVuc2V0PihVbnNldCk7XG4gICAgY29uc3Qgd2FybmluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgY2xlYW51cENhbGxiYWNrUmVmID0gdXNlUmVmPHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKT4odW5kZWZpbmVkKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VQYXNzaXZlU3RhdGVcIiwgb25DaGFuZ2UsIGdldEluaXRpYWxWYWx1ZSk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBcImRlcGVuZGVuY3kgY2hhbmdlZFwiIGFuZCBcImNvbXBvbmVudCB1bm1vdW50ZWRcIi5cbiAgICBjb25zdCBvblNob3VsZENsZWFuVXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXBDYWxsYmFjayA9IGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50O1xuICAgICAgICBpZiAoY2xlYW51cENhbGxiYWNrKVxuICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrKCk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlcmUgYXJlIGEgY291cGxlIHBsYWNlcyB3aGVyZSB3ZSdkIGxpa2UgdG8gdXNlIG91ciBpbml0aWFsXG4gICAgLy8gdmFsdWUgaW4gcGxhY2Ugb2YgaGF2aW5nIG5vIHZhbHVlIGF0IGFsbCB5ZXQuXG4gICAgLy8gVGhpcyBpcyB0aGUgc2hhcmVkIGNvZGUgZm9yIHRoYXQsIHVzZWQgb24gbW91bnQgYW5kIHdoZW5ldmVyXG4gICAgLy8gZ2V0VmFsdWUgaXMgY2FsbGVkLlxuICAgIGNvbnN0IHRyeUVuc3VyZVZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgJiYgZ2V0SW5pdGlhbFZhbHVlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsVmFsdWUgPSBnZXRJbml0aWFsVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4oaW5pdGlhbFZhbHVlLCB1bmRlZmluZWQpID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHRpb25zIGFyZSBpbnRlbnRpb25hbCB0byBhbGxvdyBiYWlsb3V0ICh3aXRob3V0IGV4cG9zaW5nIHRoZSBVbnNldCBzeW1ib2wpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbLyogZ2V0SW5pdGlhbFZhbHVlIGFuZCBvbkNoYW5nZSBpbnRlbnRpb25hbGx5IG9taXR0ZWQgKi9dKTtcblxuXG4gICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh3YXJuaW5nUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEdXJpbmcgb25DaGFuZ2UsIHByZWZlciB1c2luZyB0aGUgKHZhbHVlLCBwcmV2VmFsdWUpIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIGdldFZhbHVlIC0tIGl0J3MgYW1iaWd1b3VzIGFzIHRvIGlmIHlvdSdyZSBhc2tpbmcgZm9yIHRoZSBvbGQgb3IgbmV3IHZhbHVlIGF0IHRoaXMgcG9pbnQgaW4gdGltZSBmb3IgdGhpcyBjb21wb25lbnQuXCIpO1xuXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIGNhbGwgZ2V0VmFsdWUsIGlmIHdlIGhhdmVuJ3QgYmVlbiBnaXZlbiBhIHZhbHVlIHlldCxcbiAgICAgICAgLy8gKGFuZCB3ZSB3ZXJlIGdpdmVuIGFuIGluaXRpYWwgdmFsdWUgdG8gdXNlKVxuICAgICAgICAvLyByZXR1cm4gdGhlIGluaXRpYWwgdmFsdWUgaW5zdGVhZCBvZiBub3RoaW5nLlxuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQpXG4gICAgICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuXG4gICAgICAgIHJldHVybiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQhIDogdmFsdWVSZWYuY3VycmVudCEpIGFzIFQ7XG4gICAgfSwgW10pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3ZlIHJ1biBvdXIgZWZmZWN0IGF0IGxlYXN0IG9uY2Ugb24gbW91bnQuXG4gICAgICAgIC8vIChJZiB3ZSBoYXZlIGFuIGluaXRpYWwgdmFsdWUsIG9mIGNvdXJzZSlcbiAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcblxuXG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlIGFjdHVhbCBjb2RlIHRoZSB1c2VyIGNhbGxzIHRvIChwb3NzaWJseSkgcnVuIGEgbmV3IGVmZmVjdC5cbiAgICBjb25zdCByID0gdXNlUmVmKHsgcHJldkRlcDogVW5zZXQgYXMgVCB8ICh0eXBlb2YgVW5zZXQpIH0pO1xuICAgIGNvbnN0IHNldFZhbHVlID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxUPj4oKGFyZykgPT4ge1xuXG4gICAgICAgIC8vIFJlZ2FyZGxlc3Mgb2YgYW55dGhpbmcgZWxzZSwgZmlndXJlIG91dCB3aGF0IG91ciBuZXh0IHZhbHVlIGlzIGFib3V0IHRvIGJlLlxuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQgOiB2YWx1ZVJlZi5jdXJyZW50KSA6IGFyZyk7XG5cblxuICAgICAgICBpZiAoci5jdXJyZW50LnByZXZEZXAgPT09IFVuc2V0KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByZXF1ZXN0IHRvIGNoYW5nZSB0aGlzIHZhbHVlLlxuICAgICAgICAgICAgLy8gRXZhbHVhdGUgdGhlIHJlcXVlc3QgaW1tZWRpYXRlbHksIHRoZW4gcXVldWUgdXAgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uXG5cbiAgICAgICAgICAgIC8vIFNhdmUgb3VyIGN1cnJlbnQgdmFsdWUgc28gdGhhdCB3ZSBjYW4gY29tcGFyZSBhZ2FpbnN0IGl0IGxhdGVyXG4gICAgICAgICAgICAvLyAoaWYgd2UgZmxpcCBiYWNrIHRvIHRoaXMgc3RhdGUsIHRoZW4gd2Ugd29uJ3Qgc2VuZCB0aGUgb25DaGFuZ2UgZnVuY3Rpb24pXG4gICAgICAgICAgICByLmN1cnJlbnQucHJldkRlcCA9IHZhbHVlUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBhY3R1YWwgY2hlY2sgYW5kIGludm9jYXRpb24gb2Ygb25DaGFuZ2UgbGF0ZXIgdG8gbGV0IGVmZmVjdHMgc2V0dGxlXG4gICAgICAgICAgICBkZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dERlcCA9IHZhbHVlUmVmLmN1cnJlbnQhIGFzIFQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkRlcCA9IHIuY3VycmVudC5wcmV2RGVwIDtcbiAgICAgICAgICAgICAgICBpZiAoci5jdXJyZW50LnByZXZEZXAgIT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIGFueSByZWdpc3RlcmVkIGNsZWFudXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvdWxkQ2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/LihuZXh0RGVwLCBwcmV2RGVwID09PSBVbnNldD8gdW5kZWZpbmVkIDogcHJldkRlcCkgPz8gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0RGVwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gbm9ybWFsbHkgY2FsbCBnZXRWYWx1ZSBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGZpbmlzaGVkIHdpdGggZXZlcnl0aGluZywgc28gbWFyayB1cyBhcyBiZWluZyBvbiBhIGNsZWFuIHNsYXRlIGFnYWluLlxuICAgICAgICAgICAgICAgIHIuY3VycmVudC5wcmV2RGVwID0gVW5zZXQ7XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB2YWx1ZSBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNoZWNrZWQgYWdhaW5zdCBwcmV2RGVwIHRvIHNlZSBpZiB3ZSBzaG91bGQgYWN0dWFsbHkgY2FsbCBvbkNoYW5nZVxuICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dFZhbHVlO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIFtnZXRWYWx1ZSwgc2V0VmFsdWVdIGFzIGNvbnN0O1xufVxuXG5jb25zdCBVbnNldCA9IFN5bWJvbCgpO1xuXG4vLyBFYXN5IGNvbnN0YW50cyBmb3IgZ2V0SW5pdGlhbFZhbHVlXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHsgcmV0dXJuIHRydWU7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuTnVsbCgpIHsgcmV0dXJuIG51bGw7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5VbmRlZmluZWQoKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5aZXJvKCkgeyByZXR1cm4gMDsgfSIsIlxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVib3VuY2VSZW5kZXJpbmcsIE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCByZXR1cm5UcnVlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5cblxuLyoqXG4gKiBcbiAqIFRoZXJlIGFyZSBzZXZlcmFsIGRpZmZlcmVudCB3YXlzIHRoYXQgYSBmb2N1cyBldmVudCBjYW4gaGFwcGVuLiAgQXNzdW1lXG4gKiB0aGUgZm9sbG93aW5nIHN0ZXBzIGhhcHBlbiBpbiBvcmRlcjpcbiAqIFxuICogMS4gVGhlIHBhZ2UgbG9hZHMuXG4gKiAgICAqIE5vdGhpbmcgaXMgZm9jdXNlZCwgYnV0IGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBgYm9keWAuIFxuICogICAgKiBObyBmb2N1cyBldmVudHMgYXJlIGZpcmVkLlxuICogMi4gVGhlIHdpbmRvdyBpcyBmb2N1c2VkLCBhbiB1bmZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIHRleHQgaXMgc2VsZWN0ZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCByZW1haW5zIGFzIGBib2R5YC5cbiAqICAgICogQSBgZm9jdXNgL2Bmb2N1c2luYCBldmVudCAqTUlHSFQqIGJlIGZpcmVkIGZvciBgYm9keWAuIERlcGVuZGluZyBvblxuICogICAgICB0aGUgYnJvd3NlciwgdGhpcyBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlIGhhbmRsZXIgd2FzIGF0dGFjaGVkIHRvIGB3aW5kb3dgIG9yIGBkb2N1bWVudGAuXG4gKiAgICAgIFByb2JhYmx5IGp1c3QgYmVzdCB0byBub3QgcmVseSBvbiBpdCwgb3IgbGlzdGVuIHRvIGB3aW5kb3dgIGZvY3VzIGV2ZW50cyBkaXJlY3RseS5cbiAqIDMuIEEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgbmV3IGVsZW1lbnQgYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxuICogICAgKiBgZm9jdXNvdXRgIGFuZCBgYmx1cmAgYXJlICpub3QqIGZpcmVkIG9uIGBib2R5YC5cbiAqICAgICogYGZvY3VzYCBhbmQgYGZvY3VzaW5gIGFyZSBmaXJlZCBvbiB0aGUgbmV3IGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxuICogNC4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXG4gKiAgICAqICoqVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gdGhlIGBib2R5YCoqIGJlZm9yZSBhbnkgZXZlbnQgZXZlbiBmaXJlcy5cbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyB0aGUgbmV3IGVsZW1lbnQuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgbm93IHNldCB0byB0aGUgbmV3IGVsZW1lbnQuXG4gKiAgICAqIGBmb2N1c2luYCBpcyBmaXJlZCBvbiB0aGUgbmV3IGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyB0aGUgb2xkIGVsZW1lbnQuXG4gKiA1LiBBbiB1bmZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIHRleHQgaXMgc2VsZWN0ZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gYGJvZHlgLlxuICogICAgKiBgYmx1cmAgYW5kIGBmb2N1c291dGAgYXJlIGZpcmVkIG9uIHRoZSBvbGQgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwuXG4gKiAgICAqIGBmb2N1c2luYCBpcyAqbm90KiBmaXJlZCBvbiBgYm9keWAuXG4gKiBcbiAqIFxuICogSW4gc3VtbWFyeTpcbiAqIDEuIEZvY3VzIGV2ZW50cyAqZG8qIG5vdGlmeSB1cyBvZiBhbGwgY2hhbmdlcyBpbiBmb2N1cywgYnV0IHRoZXJlIGlzIG5vIG9uZSBzaW5nbGUgY29tcHJlaGVuc2l2ZSBldmVudCB0aGF0IHByb3ZpZGVzIHVzIHdpdGggYWxsIGF2YWlsYWJsZSBpbmZvcm1hdGlvbi5cbiAqIDIuIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCAqaXMgbm90KiBhbHdheXMgdGhlIHNhbWUgYXMgd2hhdCdzIGJlaW5nIHJlZmVyZW5jZWQgYnkgYSBmb2N1cyBldmVudC4gSW4gcGFydGljdWxhciwgaXQgbWF5IGJlY29tZSBgYm9keWAgYXQgYW55IGFyYml0cmFyeSB0aW1lLlxuICogMy4gQSBgYmx1cmAgd2l0aG91dCBhIGBmb2N1c2AgY2FuIGFuZCB3aWxsIG9jY3VyLiBUaGlzIG1lYW5zIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBzb2xlbHkgdXNlIGBmb2N1c2AgdG8gZGV0ZWN0IGFsbCBjaGFuZ2VzLlxuICogNC4gQSBgYmx1cmAgZXZlbnQgd2hvc2UgYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwgaW5kaWNhdGVzIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBmb2xsb3dpbmcgYGZvY3VzYCBldmVudC5cbiAqIFxuICogXG4gKiBAcGFyYW0gY2FsbGJhY2sgXG4gKiBAcmV0dXJucyBcbiAqL1xuY29uc3QgX2R1bW15ID0gMDtcblxuY29uc3QgYWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBOb2RlIHwgbnVsbCkgPT4gdm9pZCk+PigpO1xuY29uc3QgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogTm9kZSkgPT4gdm9pZCk+PigpO1xuY29uc3Qgd2luZG93Rm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChmb2N1c2VkOiBib29sZWFuKSA9PiB2b2lkKT4+KCk7XG5jb25zdCB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBib29sZWFuPigpO1xuXG5jb25zdCBtaWNyb3Rhc2tzID0gbmV3IE1hcDxTZXQ8YW55PiwgYW55PigpO1xuXG4vLyBUaGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgZXZlbnRzIG9mdGVuIGZpcmUgc3luY3Jvbm91c2x5IGluIHRoZSBtaWRkbGUgb2YgcnVubmluZyBjb2RlLlxuLy8gRS5HLiBjYWxsaW5nIGVsZW1lbnQuZm9jdXMoKSBjYW4gY2F1c2UgYSBmb2N1c2luIGV2ZW50IGhhbmRsZXIgdG8gaW1tZWRpYXRlbHkgaW50ZXJydXB0IHRoYXQgY29kZS5cbi8vIEZvciB0aGUgcHVycG9zZSBvZiBpbXByb3Zpbmcgc3RhYmlsaXR5LCB3ZSBkZWJvdW5jZSBhbGwgZm9jdXMgZXZlbnRzIHRvIHRoZSBuZXh0IG1pY3JvdGFzay5cbmZ1bmN0aW9uIGZvckVhY2hVcGRhdGVyPFQ+KHdpbmRvdzogV2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgbWFwOiBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogVCkgPT4gdm9pZCk+PiwgdmFsdWU6IFQpIHtcbiAgICBjb25zdCB1cGRhdGVyc0tleSA9IG1hcC5nZXQod2luZG93KTtcbiAgICBpZiAodXBkYXRlcnNLZXkpIHtcbiAgICAgICAgaWYgKCFtaWNyb3Rhc2tzLmhhcyh1cGRhdGVyc0tleSkpIHtcbiAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVyc0tleSA9IG1hcC5nZXQod2luZG93KSE7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtaWNyb3Rhc2tzLmdldCh1cGRhdGVyc0tleSk7XG4gICAgICAgICAgICAgICAgbWljcm90YXNrcy5kZWxldGUodXBkYXRlcnNLZXkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZXJzS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlciBvZiB1cGRhdGVyc0tleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlcj8uKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbWljcm90YXNrcy5zZXQodXBkYXRlcnNLZXksIHZhbHVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvY3Vzb3V0KGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGFjdGl2ZUVsZW1lbnRVcGRhdGVycywgbnVsbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBKdXN0IHdhaXQgZm9yIHRoZSBmb2N1c2luIGV2ZW50LlxuICAgIH1cblxufVxuXG5mdW5jdGlvbiBmb2N1c2luKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICBjb25zdCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCA9IGUudGFyZ2V0IGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50KTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gd2luZG93Rm9jdXMoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUudGFyZ2V0IDogZS5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS5jdXJyZW50VGFyZ2V0IDogKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgdHJ1ZSk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMsIHRydWUpO1xufVxuXG5mdW5jdGlvbiB3aW5kb3dCbHVyKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGZhbHNlKTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIHdpbmRvd0ZvY3VzZWRVcGRhdGVycywgZmFsc2UpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIHtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcy4gTXVzdCBiZSBzdGFibGUuXG4gICAgICovXG4gICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8RWxlbWVudCB8IG51bGw+O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzIGFuZCBpcyBub3QgbnVsbC4gXG4gICAgICogTXVzdCBiZSBzdGFibGUuXG4gICAgICovXG4gICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnQ+O1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSB3aW5kb3cgZ2FpbnMvbG9zZXMgZm9jdXMuIE11c3QgYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPGJvb2xlYW4+O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkb2N1bWVudCBhc3NvY2lhdGVkIHdpdGggd2hhdGV2ZXIgZWxlbWVudHMgd2UncmUgbGlzdGVuaW5nIHRvLlxuICAgICAqIFxuICAgICAqIEUuRy4gc29tZURpdkVsZW1lbnQub3duZXJEb2N1bWVudFxuICAgICAqIFxuICAgICAqICoqTVVTVCoqIGJlIHN0YWJsZVxuICAgICAqL1xuICAgIGdldERvY3VtZW50KCk6IERvY3VtZW50O1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgZXZlbnQgaGFuZGxlcnMgYXJlIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCdzIGRlZmF1bHRWaWV3IFdpbmRvdy5cbiAgICAgKiBJZiB5b3UgbmVlZCBzb21ldGhpbmcgZGlmZmVyZW50LCBvdmVycmlkZSBpdCBoZXJlLlxuICAgICAqIFxuICAgICAqICoqTVVTVCoqIGJlIHN0YWJsZVxuICAgICAqL1xuICAgIGdldFdpbmRvdz8oZG9jdW1lbnQ6IERvY3VtZW50KTogV2luZG93O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcbiAgICAvKiogXG4gICAgICogUmV0dXJucyB3aGF0ZXZlciBlbGVtZW50IGlzIGN1cnJlbnRseSBmb2N1c2VkLCBvciBgbnVsbGAgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnRcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgZ2V0QWN0aXZlRWxlbWVudDogKCkgPT4gRWxlbWVudCB8IG51bGw7XG4gICAgLyoqIFxuICAgICAqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3Igd2hhdGV2ZXIgZWxlbWVudCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50XG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIGdldExhc3RBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50O1xuICAgIC8qKiBcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSB3aW5kb3cgaXRzZWxmIGhhcyBmb2N1cyBvciBub3RcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgZ2V0V2luZG93Rm9jdXNlZDogKCkgPT4gYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgeW91IHRvIGluc3BlY3Qgd2hpY2ggZWxlbWVudCBpbiB0aGUgYGRvY3VtZW50YCBjdXJyZW50bHkgaGFzIGZvY3VzLCB3aGljaCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIG5vbmUgYXJlIGN1cnJlbnRseSwgYW5kIHdoZXRoZXIgb3Igbm90IHRoZSB3aW5kb3cgaGFzIGZvY3VzIGJ5IHJldHVybmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcbiAqICogYGdldEFjdGl2ZUVsZW1lbnQoKWBcbiAqICogYGdldExhc3RBY3RpdmVFbGVtZW50KClgXG4gKiAqIGBnZXRXaW5kb3dGb2N1c2VkKClgXG4gKiBcbiAqIChUaGUgZG9jdW1lbnQncyBib2R5IHJlY2VpdmluZyBmb2N1cywgbGlrZSBpdCBkb2VzIHdoZW4geW91IGNsaWNrIG9uIGFuIGVtcHR5IGFyZWEsIGlzIGNvdW50ZWQgYXMgbm8gZWxlbWVudCBoYXZpbmcgZm9jdXMgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3NlcylcbiAqIFxuICogVGhpcyBpcyBhIHBhc3NpdmUgaG9vaywgc28gYnkgZGVmYXVsdCBpdCByZXR1cm5zIGdldHRlciBmdW5jdGlvbnMgdGhhdCByZXBvcnQgdGhpcyBpbmZvcm1hdGlvbiBidXQgdGhlIGNvbXBvbmVudCB3aWxsIG5vdCByZS1yZW5kZXIgYnkgZGVmYXVsdCB3aGVuIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLlxuICogXG4gKiBJZiB5b3UgbmVlZCB0aGUgY29tcG9uZW50IHRvIHJlLXJlbmRlciB3aGVuIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLCB1c2UgdGhlIGBvbipDaGFuZ2VgIGFyZ3VtZW50cyB0byBzZXQgc29tZSBzdGF0ZSBvbiB5b3VyIGVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGl2ZUVsZW1lbnQoeyBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyB9OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycyk6IFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUFjdGl2ZUVsZW1lbnRcIiwgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIGdldERvY3VtZW50LCBnZXRXaW5kb3cpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICBjb25zdCB3aW5kb3cgPSAoZ2V0V2luZG93Py4oZG9jdW1lbnQpID8/IGRvY3VtZW50Py5kZWZhdWx0Vmlldyk7XG5cbiAgICAgICAgaWYgKChhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdyk/LnNpemUgPz8gMCkgPT09IDApIHtcbiAgICAgICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhlbSBldmVuIGlmIHRoZXkncmUgdW5kZWZpbmVkIHRvIG1vcmUgZWFzaWx5XG4gICAgICAgIC8vIG1hbmFnZSB0aGUgXCI+MCBtZWFucyBkb24ndCBhZGQgaGFuZGxlcnNcIiBsb2dpYy5cbiAgICAgICAgY29uc3QgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMgPSB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuXG4gICAgICAgIGxvY2FsQWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChzZXRBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlIHwgbnVsbD4pO1xuICAgICAgICBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuYWRkKHNldExhc3RBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlPik7XG4gICAgICAgIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzLmFkZChzZXRXaW5kb3dGb2N1c2VkKTtcblxuICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xuICAgICAgICBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLnNldCh3aW5kb3csIGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyk7XG4gICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKHNldEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGUgfCBudWxsPik7XG4gICAgICAgICAgICBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUoc2V0TGFzdEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGU+KTtcbiAgICAgICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKHNldFdpbmRvd0ZvY3VzZWQpO1xuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudFVwZGF0ZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbik7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBmb2N1c291dCk7XG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgd2luZG93Rm9jdXMpO1xuICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IFtnZXRBY3RpdmVFbGVtZW50LCBzZXRBY3RpdmVFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxFbGVtZW50IHwgbnVsbD4ob25BY3RpdmVFbGVtZW50Q2hhbmdlLCByZXR1cm5OdWxsKTtcbiAgICBjb25zdCBbZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsIHNldExhc3RBY3RpdmVFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxFbGVtZW50Pihvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCByZXR1cm5OdWxsIGFzICgpID0+IG5ldmVyKTtcbiAgICBjb25zdCBbZ2V0V2luZG93Rm9jdXNlZCwgc2V0V2luZG93Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25XaW5kb3dGb2N1c2VkQ2hhbmdlLCByZXR1cm5UcnVlKTtcblxuICAgIHJldHVybiB7IGdldEFjdGl2ZUVsZW1lbnQsIGdldExhc3RBY3RpdmVFbGVtZW50LCBnZXRXaW5kb3dGb2N1c2VkIH07XG59XG4iLCJcbmltcG9ydCB7IENvbXBvbmVudCwgb3B0aW9ucywgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBFZmZlY3RDYWxsYmFjaywgSW5wdXRzLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG5cblxuY29uc3QgVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Xy1cIjtcblxuZnVuY3Rpb24gYmFzZTY0KHZhbHVlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gVGFibGVbdmFsdWVdO1xufVxuXG5mdW5jdGlvbiByYW5kb202Qml0cygpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMGIxMDAwMDAwKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tNjRCaXRzKCkge1xuICAgIHJldHVybiBbcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKV0gYXMgY29uc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbWx5LWdlbmVyYXRlZCBJRCB3aXRoIGFuIG9wdGlvbmFsIHByZWZpeC5cbiAqIE5vdGUgdGhhdCBpZiB0aGUgcHJlZml4IGlzICpleHBsaWNpdGx5KiBzZXQgdG8gXCJcIiwgdGhlblxuICogSURzIHRoYXQgYXJlIG5vdCB2YWxpZCB1bmRlciBIVE1MNCBtYXkgYmUgZ2VuZXJhdGVkLiBPaCBuby5cbiAqIFxuICogXG4gKiAoVGhpcyBpcyBoZXJlLCBpbiB0aGlzIHBhcnRpY3VsYXIgZmlsZSwgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gKiB3aXRob3V0IGFsc28gbWFraW5nIGEgdXRpbGl0aWVzIGZpbGUuXG4gKiBPbmNlIHdlIGNhbiByZW1vdmUgdGhpcyBob29rLCB3ZSBjYW4gcHV0IHRoaXMgZnVuY3Rpb24gYmFjayB3aXRoIHVzZVJhbmRvbUlkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JZChwcmVmaXg/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7cHJlZml4ID8/IFwiaWQtXCJ9JHtyYW5kb202NEJpdHMoKS5tYXAobiA9PiBiYXNlNjQobikpLmpvaW4oXCJcIil9YDtcbn1cblxuY29uc3QgcHJldmlvdXNJbnB1dHMgPSBuZXcgTWFwPHN0cmluZywgSW5wdXRzIHwgdW5kZWZpbmVkPigpO1xuY29uc3QgdG9SdW4gPSBuZXcgTWFwPHN0cmluZywgeyBlZmZlY3Q6IEVmZmVjdENhbGxiYWNrLCBpbnB1dHM/OiBJbnB1dHMsIGNsZWFudXA6IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkIHwgKCgpID0+IHZvaWQpIH0+KCk7XG5cblxuLy8gVE9ETzogV2hldGhlciB0aGlzIGdvZXMgaW4gb3B0aW9ucy5kaWZmZWQgb3Igb3B0aW9ucy5fY29tbWl0XG4vLyBpcyBhIHBvc3Qtc3VzcGVuc2UgcXVlc3Rpb24uXG4vLyBSaWdodCBub3csIHVzaW5nIG9wdGlvbnMuX2NvbW1pdCBoYXMgdGhlIHByb2JsZW0gb2YgcnVubmluZ1xuLy8gKmFmdGVyKiByZWZzIGFyZSBhcHBsaWVkLCBidXQgd2UgbmVlZCB0byBjb21lIGJlZm9yZSBldmVuIHRoYXRcbi8vIHNvIGByZWY9e3NvbWVTdGFibGVGdW5jdGlvbn1gIHdvcmtzLlxuLy8gXG4vLyBBbHNvIGl0J3MgcHJpdmF0ZS5cbi8vXG4vLyAuLi5cbi8vIFdlbGwsIHVzZUV2ZW50IG9yIHdoYXRldmVyIGlzIGZpbmFsbHksIGZpbmFsbHkgNCB5ZWFycyBsYXRlciBmaW5hbGx5IGhlcmVcbi8vIHdoaWNoIGlzIGNvb2wgYW5kIG1lYW5zIHdlIHdvbid0IG5lZWQgdGhpcyBhdCBhbGwgc29vbi5cbi8vIFNvIGZvciBub3cgd2UnbGwgc3RpY2sgd2l0aCBkaWZmIHRvIHByZXZlbnQgYW55IHdlaXJkbmVzcyB3aXRoXG4vLyBjb21taXQgYmVpbmcgcHJpdmF0ZSBhbmQgYWxsLlxuY29uc3QgY29tbWl0TmFtZSA9IFwiZGlmZmVkXCI7XG5cbmNvbnN0IG9yaWdpbmFsQ29tbWl0ID0gb3B0aW9uc1tjb21taXROYW1lXSBhcyAodm5vZGU6IFZOb2RlLCBjb21taXRRdWV1ZTogQ29tcG9uZW50W10pID0+IHZvaWQ7XG5jb25zdCBuZXdDb21taXQ6IHR5cGVvZiBvcmlnaW5hbENvbW1pdCA9ICguLi5hcmdzKSA9PiB7XG4gICAgZm9yIChjb25zdCBbaWQsIGVmZmVjdEluZm9dIG9mIHRvUnVuKSB7XG4gICAgICAgIGNvbnN0IG9sZElucHV0cyA9IHByZXZpb3VzSW5wdXRzLmdldChpZCk7XG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChvbGRJbnB1dHMsIGVmZmVjdEluZm8uaW5wdXRzKSkge1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwPy4oKTtcbiAgICAgICAgICAgIGVmZmVjdEluZm8uY2xlYW51cCA9IGVmZmVjdEluZm8uZWZmZWN0KCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5zZXQoaWQsIGVmZmVjdEluZm8uaW5wdXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1J1bi5jbGVhcigpO1xuICAgIG9yaWdpbmFsQ29tbWl0Py4oLi4uYXJncyk7XG59XG5vcHRpb25zW2NvbW1pdE5hbWVdID0gbmV3Q29tbWl0IGFzIG5ldmVyXG5cbi8qKlxuICogU2VtaS1wcml2YXRlIGZ1bmN0aW9uIHRvIGFsbG93IHN0YWJsZSBjYWxsYmFja3MgZXZlbiB3aXRoaW4gYHVzZUxheW91dEVmZmVjdGAgYW5kIHJlZiBhc3NpZ25tZW50LlxuICogXG4gKiBFdmVyeSByZW5kZXIsIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyB0byBiZSBldmFsdWF0ZWQgYWZ0ZXIgZGlmZmluZyBoYXMgY29tcGxldGVkLFxuICogd2hpY2ggaGFwcGVucyBiZWZvcmUuXG4gKiBcbiAqIEBwYXJhbSBlZmZlY3QgXG4gKiBAcGFyYW0gaW5wdXRzIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmVmb3JlTGF5b3V0RWZmZWN0KGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cykge1xuXG4gICAgLyooKCkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gdXNlUmVmPHZvaWQgfCAoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKTtcbiAgICAgICAgY29uc3QgcHJldkFyZ3NSZWYgPSB1c2VSZWY8SW5wdXRzPihudWxsISk7XG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChpbnB1dHMsIHByZXZBcmdzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBwcmV2QXJnc1JlZi5jdXJyZW50ID0gaW5wdXRzITtcbiAgICAgICAgICAgIGlmIChjbGVhbnVwLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgY2xlYW51cC5jdXJyZW50KCk7XG4gICAgICAgICAgICBjbGVhbnVwLmN1cnJlbnQgPSBlZmZlY3QoKTtcbiAgICAgICAgfVxuICAgIH0pKCk7Ki9cblxuICAgIGNvbnN0IFtpZF0gPSB1c2VTdGF0ZSgoKSA9PiBnZW5lcmF0ZVJhbmRvbUlkKCkpO1xuICAgIHRvUnVuLnNldChpZCwgeyBlZmZlY3QsIGlucHV0cywgY2xlYW51cDogbnVsbCB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH0sIFtpZF0pXG59XG5cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3M/OiBJbnB1dHMsIG5ld0FyZ3M/OiBJbnB1dHMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoXG4gICAgICAgICFvbGRBcmdzIHx8XG4gICAgICAgIG9sZEFyZ3MubGVuZ3RoICE9PSBuZXdBcmdzPy5sZW5ndGggfHxcbiAgICAgICAgbmV3QXJncz8uc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSlcbiAgICApO1xufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VCZWZvcmVMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtYmVmb3JlLWxheW91dC1lZmZlY3RcIjtcblxuY29uc3QgVW5zZXQgPSBTeW1ib2woXCJ1bnNldFwiKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCB2YWx1ZSwgcmV0dXJucyBhIGNvbnN0YW50IGdldHRlciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIFxuICogaW5zaWRlIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaW5jbHVkaW5nIGl0IGluIHRoZSBkZXBlbmRlbmN5IGFycmF5LlxuICogXG4gKiBUaGlzIHVzZXMgYG9wdGlvbnMuZGlmZmVkYCBpbiBvcmRlciB0byBydW4gYmVmb3JlIGV2ZXJ5dGhpbmcsIGV2ZW5cbiAqIHJlZiBhc3NpZ25tZW50LiBUaGlzIG1lYW5zIHRoaXMgZ2V0dGVyIGlzIHNhZmUgdG8gdXNlIGFueXdoZXJlICoqKmV4Y2VwdCB0aGUgcmVuZGVyIHBoYXNlKioqLlxuICogXG4gKiBAcGFyYW0gdmFsdWUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUdldHRlcjxUPih2YWx1ZTogVCk6ICgpID0+IFQge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZjxUPihVbnNldCBhcyB1bmtub3duIGFzIFQpO1xuICAgIHVzZUJlZm9yZUxheW91dEVmZmVjdCgoKSA9PiB7IHJlZi5jdXJyZW50ID0gdmFsdWU7IH0sIFt2YWx1ZV0pO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCBhcyB1bmtub3duID09PSBVbnNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSByZXRyaWV2ZWQgZnJvbSB1c2VTdGFibGVHZXR0ZXIoKSBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyByZW5kZXIuJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gICAgfSwgW10pXG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5cbi8qKlxuICogQWx0ZXJuYXRlIHVzZUNhbGxiYWNrKCkgd2hpY2ggYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgKHdyYXBwZWQpIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICogc28gdGhhdCBpdCBjYW4gYmUgZXhjbHVkZWQgZnJvbSB0aGUgZGVwZW5kZW5jeSBhcnJheXMgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMuXG4gKiBcbiAqIERvIG5vdCB1c2UgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UhICBgdXNlTGF5b3V0RWZmZWN0YCBpcyBmaW5lIHRob3VnaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUNhbGxiYWNrPFQgZXh0ZW5kcyAoLi4uX2FyZ3M6IGFueVtdKSA9PiBhbnk+KGZuOiBUKTogVCB7XG4gICAgY29uc3QgY3VycmVudENhbGxiYWNrR2V0dGVyID0gdXNlU3RhYmxlR2V0dGVyPFQ+KGZuKTtcblxuICAgIHJldHVybiB1c2VDYWxsYmFjaygoLi4uYXJnczogUGFyYW1ldGVyczxUPik6IFJldHVyblR5cGU8VD4gPT4ge1xuICAgICAgICByZXR1cm4gY3VycmVudENhbGxiYWNrR2V0dGVyKCkoLi4uYXJncyk7XG4gICAgfSwgW10pIGFzIFQ7XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxudHlwZSBSYWZDYWxsYmFja1R5cGUgPSAobXNTaW5jZUxhc3Q6IG51bWJlciwgdGFnPzogYW55KSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgQ29udGV4dFR5cGUge1xuICAgIGFkZENhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSwgdGFnPzogYW55KSA9PiB2b2lkO1xuICAgIHJlbW92ZUNhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxudWxsIHwgQ29udGV4dFR5cGU+KG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gUHJvdmlkZUJhdGNoZWRBbmltYXRpb25GcmFtZXMoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbiB9KSB7XG5cbiAgICBjb25zdCBhZGRDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wiYWRkQ2FsbGJhY2tcIl0+KChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuc2V0KGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZyk7IH0sIFtdKTtcbiAgICBjb25zdCByZW1vdmVDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wicmVtb3ZlQ2FsbGJhY2tcIl0+KChjYWxsYmFjaykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5kZWxldGUoY2FsbGJhY2spOyB9LCBbXSk7XG5cbiAgICBjb25zdCBjb250ZXh0SW5mbyA9IHVzZVJlZjxDb250ZXh0VHlwZT4obnVsbCEpO1xuICAgIGlmIChjb250ZXh0SW5mby5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGNvbnRleHRJbmZvLmN1cnJlbnQgPSB7IGFkZENhbGxiYWNrLCByZW1vdmVDYWxsYmFjayB9O1xuICAgIGNvbnN0IGFsbENhbGxiYWNrcyA9IHVzZVJlZjxNYXA8UmFmQ2FsbGJhY2tUeXBlLCBhbnk+PihudWxsISk7XG4gICAgaWYgKGFsbENhbGxiYWNrcy5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGFsbENhbGxiYWNrcy5jdXJyZW50ID0gbmV3IE1hcCgpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZSA9IC0xO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKG1zU2luY2VMYXN0OiBudW1iZXIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2JhdGNoZWRSYWZDYWxsYmFjaywgdGFnXSBvZiBhbGxDYWxsYmFja3MuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGJhdGNoZWRSYWZDYWxsYmFjayhtc1NpbmNlTGFzdCwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRJbmZvLmN1cnJlbnR9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L1NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlcj4pXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB3aXRoIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHJ1bGVzIGFzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXG4gICAgICogXG4gICAgICogRG9lc24ndCBuZWVkIHRvIGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBjYWxsYmFjazogbnVsbCB8ICgobXNTaW5jZUxhc3Q6IG51bWJlcikgPT4gdm9pZCk7XG59XG5cbi8qKlxuICogVGhlIChvcHRpb25hbGx5IG5vbi1zdGFibGUpIGBjYWxsYmFja2AgeW91IHByb3ZpZGUgd2lsbCBzdGFydCBydW5uaW5nIGV2ZXJ5IGZyYW1lIGFmdGVyIHRoZSBjb21wb25lbnQgbW91bnRzLlxuICogXG4gKiBQYXNzaW5nIGBudWxsYCBpcyBmaW5lIGFuZCBzaW1wbHkgc3RvcHMgdGhlIGVmZmVjdCB1bnRpbCB5b3UgcmVzdGFydCBpdCBieSBwcm92aWRpbmcgYSBub24tbnVsbCBjYWxsYmFjay5cbiAqIFxuICogKipUaGlzIGhvb2sgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGF0IGFsbCwgaW5jbHVkaW5nIG5vIHByb3AtbW9kaWZ5aW5nIGhvb2tzKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFuaW1hdGlvbkZyYW1lKHsgY2FsbGJhY2sgfTogVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIGdpdmVuIGNhbGxiYWNrIHRoYXQncyBzdGFibGVcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKGNhbGxiYWNrID8/IG5vb3ApO1xuICAgIGNvbnN0IGhhc0NhbGxiYWNrID0gKGNhbGxiYWNrICE9IG51bGwpO1xuXG4gICAgY29uc3Qgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gdXNlQ29udGV4dChTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LmFkZENhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5yZW1vdmVDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgd3JhcHBlciBhcm91bmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbHNvIGNhbGxzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFnYWluLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZkNhbGxiYWNrID0gKG1zOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlQ2FsbGJhY2sobXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQsIGhhc0NhbGxiYWNrXSlcbn1cblxuLy8gZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5mdW5jdGlvbiBub29wKCkgeyB9XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3Q7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsIlxuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZVAgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbi8qKlxuICogU2xpZ2h0bHkgZW5oYW5jZWQgdmVyc2lvbiBvZiBgdXNlU3RhdGVgIHRoYXQgaW5jbHVkZXMgYSBnZXR0ZXIgdGhhdCByZW1haW5zIGNvbnN0YW50XG4gKiAoaS5lLiB5b3UgY2FuIHVzZSBpdCBpbiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcyB3aXRob3V0IGl0IGJlaW5nIGEgZGVwZW5kZW5jeSkuXG4gKiBcbiAqIEBwYXJhbSBpbml0aWFsU3RhdGUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlPFQ+KGluaXRpYWxTdGF0ZTogVCB8ICgoKSA9PiBUKSk6IHJlYWRvbmx5IFt2YWx1ZTogVCwgc2V0VmFsdWU6IFN0YXRlVXBkYXRlcjxUPiwgZ2V0VmFsdWU6ICgpID0+IFRdIHtcblxuICAgIC8vIFdlIGtlZXAgYm90aCwgYnV0IG92ZXJycmlkZSB0aGUgYHNldFN0YXRlYCBmdW5jdGlvbmFsaXR5XG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZVBdID0gdXNlU3RhdGVQKGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKHN0YXRlKTtcblxuICAgIC8vIEhpamFjayB0aGUgbm9ybWFsIHNldHRlciBmdW5jdGlvbiBcbiAgICAvLyB0byBhbHNvIHNldCBvdXIgcmVmIHRvIHRoZSBuZXcgdmFsdWVcbiAgICBjb25zdCBzZXRTdGF0ZSA9IHVzZUNhbGxiYWNrPFN0YXRlVXBkYXRlcjxUPj4odmFsdWUgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdmFsdWUgYXMgKChfcHJldlZhbHVlOiBUKSA9PiBUKTtcbiAgICAgICAgICAgIHNldFN0YXRlUChwcmV2VmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IGNhbGxiYWNrKHByZXZWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldFN0YXRlUCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRTdGF0ZSA9ICgpID0+IHsgcmV0dXJuIHJlZi5jdXJyZW50OyB9O1xuXG5cbiAgICBjb25zb2xlLmFzc2VydChyZWYuY3VycmVudCA9PT0gc3RhdGUgfHwgKHR5cGVvZiBzdGF0ZSA9PT0gXCJudW1iZXJcIiAmJiBpc05hTihzdGF0ZSkpKTtcbiAgICByZXR1cm4gW3N0YXRlLCBzZXRTdGF0ZSwgZ2V0U3RhdGVdIGFzIGNvbnN0O1xufSIsImltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlLCBkZWJvdW5jZVJlbmRlcmluZyB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuLyoqXG4gKiBSZW1pbmRlciBvZiBvcmRlciBvZiBleGVjdXRpb246XG4gKiBcbiAqICogKHRyZWUgbW91bnRzKVxuICogKiBQYXJlbnQgcmVuZGVyc1xuICogKiBDaGlsZHJlbiByZW5kZXJcbiAqICogQ2hpbGRyZW4gcmVjZWl2ZSByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIFBhcmVudCByZWNlaXZlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdHNcbiAqIFxuICogKiAodHJlZSB1bm1vdW50cylcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogUGFyZW50IGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIENoaWxkIGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcbiAqICogUmVuZGVyaW5nIHN0YXJ0cyBhdCB0aGUgcm9vdCwgIGJ1dCBlZmZlY3RzIGFuZCByZWZzIHN0YXJ0IGF0IHRoZSBsZWF2ZXMuXG4gKiAqIHJlZnMgYXJlICp1c3VhbGx5KiBjYWxsZWQgYmVmb3JlIGVmZmVjdHMsIGJ1dCBvbmx5IHdoZW4gdGhhdCBIVE1MRWxlbWVudCByZW5kZXJzLiBCYXNpY2FsbHkganVzdCBhIHJlbWluZGVyIHRoYXQgYSBjb21wb25lbnQgY2FuIGJlIG1vdW50ZWQgd2l0aG91dCBpdCBleGlzdGluZyBpbiB0aGUgRE9NLlxuICovXG5jb25zdCBfY29tbWVudHMgPSB2b2lkICgwKTtcblxuXG4vKipcbiAqIEluZm9ybWF0aW9uIHRoYXQgY2hpbGRyZW4gYW5kIHBhcmVudHMgdXNlIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cbiAqIFxuICogKiBgaW5kZXhgIHJlZmVycyB0byB3aGljaCBjaGlsZCB0aGlzIGlzLlxuICogKiBgZmxhZ3NgIGFyZSBxdWljay1hbmQtZWFzeSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgeW91IGNhbiBvcHRpb25hbGx5IHVzZVxuICogKiBgc3ViSW5mb2AgaXMgYW55dGhpbmcgdXNlZCBieSBhIGRlcml2ZWQgaG9vay4gYHVzZVJvdmluZ1RhYkluZGV4YCwgZm9yIGV4YW1wbGUsIG5lZWRzIHRvIGtub3cgaG93IHRvIGZvY3VzIGFuIGFyYml0cmFyeSBjaGlsZCwgc28gdGhlIGNoaWxkIHBvcHVsYXRlcyBgaW5mb2Agd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyBhIG1ldGhvZCBjYWxsZWQgYGZvY3VzU2VsZmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkSW5mbzxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgaW5kZXg6IFQ7XG4gICAgZmxhZ3M/OiBQYXJ0aWFsPFJlY29yZDxLLCBDaGlsZEZsYWdPcGVyYXRpb25zPj47XG4gICAgc3ViSW5mbzogQztcbn1cblxuXG5cbmV4cG9ydCB0eXBlIE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgobW91bnRlZDogU2V0PFQ+LCB1bm1vdW50ZWQ6IFNldDxUPikgPT4gdm9pZCk7XG5leHBvcnQgdHlwZSBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKGNhdXNlcnM6IEl0ZXJhYmxlPFQ+KSA9PiB2b2lkKTtcblxuaW50ZXJmYWNlIE1DUDxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nPiB7XG4gICAgLyoqXG4gICAgICogUnVucyBhZnRlciBvbmUgb3IgbW9yZSBjaGlsZHJlbiBoYXZlIHVwZGF0ZWQgdGhlaXIgaW5mb3JtYXRpb24gKGluZGV4LCBldGMuKS5cbiAgICAgKiBcbiAgICAgKiBPbmx5IG9uZSB3aWxsIHJ1biBwZXIgdGljaywganVzdCBsaWtlIGxheW91dEVmZmVjdCwgYnV0IGl0IGlzbid0XG4gICAgICogKmd1YXJhbnRlZWQqIHRvIGhhdmUgYWN0dWFsbHkgYmVlbiBhIGNoYW5nZS5cbiAgICAgKi9cbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PFQ+O1xuXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyB0aGUgYWJvdmUsIGJ1dCBvbmx5IGZvciBtb3VudC91bm1vdW50IChvciB3aGVuIGEgY2hpbGQgY2hhbmdlcyBpdHMgaW5kZXgpXG4gICAgICovXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxUPjtcbn1cblxuZXhwb3J0IHR5cGUgTWFuYWdlZENoaWxkcmVuT21pdHMgPSBrZXlvZiBNQ1A8YW55PjtcbmV4cG9ydCB0eXBlIE1hbmFnZWRDaGlsZE9taXRzID0ga2V5b2YgTWFuYWdlZENoaWxkSW5mbzxhbnksIGFueSwgYW55PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIE9taXRzIGV4dGVuZHMga2V5b2YgTUNQPFQ+PiB7XG4gICAgbWFuYWdlZENoaWxkcmVuOiBPbWl0PE1DUDxUPiwgT21pdHM+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgQywgSyBleHRlbmRzIHN0cmluZywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzPiB7XG4gICAgbWFuYWdlZENoaWxkOiBPbWl0PE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz4sIE1jT21pdHM+O1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgQywgSyBleHRlbmRzIHN0cmluZz4ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNoaWxkIHRoYXQgcmVuZGVyZWQgaXRzZWxmIHdpdGggdGhlIHJlcXVlc3RlZCBrZXkuXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKiAoZXZlbiB0aG91Z2ggaXQncyBub3QgYSBmdW5jdGlvbiwgdGhlIGlkZW50aXR5IG9mIHRoaXMgb2JqZWN0IG5ldmVyIGNoYW5nZXMpXG4gICAgICovXG4gICAgbWFuYWdlZENoaWxkcmVuOiB7XG4gICAgICAgIGNoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48VCwgQywgSz47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxULCBDLCBLPiB7XG4gICAgLyoqXG4gICAgICogQSBob29rIHRoYXQgbXVzdCBiZSBjYWxsZWQgYnkgZXZlcnkgY2hpbGQgY29tcG9uZW50IHRoYXRcbiAgICAgKiBpcyB0byBiZSBtYW5hZ2VkIGJ5IHRoaXMgb25lLiBUaGUgYXJndW1lbnQgdG8gdGhlIGhvb2tcbiAgICAgKiBpcyBqdXN0IHRoZSBiYWcgb2YgcHJvcGVydGllcyB0byBwYXNzIHRvIHRoZSBwYXJlbnQsXG4gICAgICogaW5jbHVkaW5nIHRoZSBjaGlsZCdzIGluZGV4LlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICB1c2VNYW5hZ2VkQ2hpbGQ6IFVzZU1hbmFnZWRDaGlsZDxULCBDLCBLPjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZSA9IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIFVzZU1hbmFnZWRDaGlsZDxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPFQsIEMsIEssIG5ldmVyPikgPT4gVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTtcblxuXG5cblxuXG5cbi8qKlxuICogQWJzdHJhY3Rpb24gb3ZlciB0aGUgbWFuYWdlZCBjaGlsZHJlblxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZHJlbjxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGdldEF0KGluZGV4OiBUKTogTWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPiB8IHVuZGVmaW5lZDtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0SGlnaGVzdEluZGV4KCk6IG51bWJlcjtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZm9yRWFjaDogKGY6IChjaGlsZDogTWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPikgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAgIC8qKiAqKlVOU1RBQkxFKiosIGFsc28gaW50ZXJuYWwtdXNlIG9ubHksIGFsc28gVE9ETyBuZWVkIGEgd29ya2Fyb3VuZCBmb3IgdGhpcyBmb3Igc29ydGFibGUgY2hpbGRyZW4gKi9cbiAgICBhcnJheVNsaWNlOiAoKSA9PiBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+W107XG59XG5cblxuXG5cbi8vZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxJIGV4dGVuZHMge30+ID0geyBpbmZvOiBJIH07XG5cbi8qKlxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxuICogY2hpbGQgY29tcG9uZW50cyBvbmNlIHRoZXkgaGF2ZSByZW5kZXJlZC5cbiAqIFxuICogVGhpcyBob29rIGlzIGRlc2lnbmVkIHRvIGJlIGxpZ2h0d2VpZ2h0LCBpbiB0aGF0IHRoZSBwYXJlbnQga2VlcHMgbm8gc3RhdGVcbiAqIGFuZCBydW5zIG5vIGVmZmVjdHMuICBFYWNoIGNoaWxkICpkb2VzKiBydW4gYW4gZWZmZWN0LCBidXQgd2l0aCBubyBzdGF0ZVxuICogY2hhbmdlcyB1bmxlc3MgeW91IGV4cGxpY2l0bHkgcmVxdWVzdCB0aGVtLlxuICogXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hbmFnZWRDaGlsZHJlbjxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPihwYXJlbnRQYXJhbWV0ZXJzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFQsIG5ldmVyPik6IFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8VCwgQywgSz4ge1xuICAgIC8vdHlwZSBJID0gSTMgJiBNYW5hZ2VkQ2hpbGRJbmZvQmFzZTxzdHJpbmcgfCBudW1iZXI+O1xuICAgIHR5cGUgSW5mbyA9IE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz47XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH0gPSBwYXJlbnRQYXJhbWV0ZXJzO1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTWFuYWdlZENoaWxkcmVuXCIsIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlKTtcblxuICAgIGNvbnN0IGdldEhpZ2hlc3RJbmRleCA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xuICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXg7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gQWxsIHRoZSBpbmZvcm1hdGlvbiB3ZSBoYXZlIGFib3V0IG91ciBjaGlsZHJlbiBpcyBzdG9yZWQgaW4gdGhpcyAqKnN0YWJsZSoqIGFycmF5LlxuICAgIC8vIEFueSBtdXRhdGlvbnMgdG8gdGhpcyBhcnJheSAqKkRPIE5PVCoqIHRyaWdnZXIgYW55IHNvcnQgb2YgYSByZS1yZW5kZXIuXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuQXJyYXkgPSB1c2VSZWY8eyBhcnI6IEFycmF5PEluZm8+OyByZWM6IFBhcnRpYWw8UmVjb3JkPFQsIEluZm8+PjsgaGlnaGVzdEluZGV4OiBudW1iZXIsIGxvd2VzdEluZGV4OiBudW1iZXIgfT4oeyBhcnI6IFtdLCByZWM6IHt9LCBoaWdoZXN0SW5kZXg6IDAsIGxvd2VzdEluZGV4OiAwIH0pO1xuXG4gICAgLy8gRm9yIGluZGlyZWN0IGFjY2VzcyB0byBlYWNoIGNoaWxkXG4gICAgLy8gQ29tcGFyZSBnZXRNYW5hZ2VkQ2hpbGRJbmZvXG4gICAgLy8gVE9ETzogVGhlIHByaW1hcnkgdXNlIGZvciB0aGlzIGlzIGZsYWdnYWJsZSBjbG9zZXN0IGZpdHNcbiAgICAvLyB3aGljaCBuZWVkIHRvIHNlYXJjaCBhbGwgY2hpbGRyZW4gZm9yIHRoYXQgY2xvc2VzdCBmaXQuXG4gICAgLy8gSXQgd291bGQgYmUgbmljZSBpZiB0aGVyZSB3YXMgc29tZXRoaW5nIGJldHRlciBmb3IgdGhhdC5cbiAgICBjb25zdCBmb3JFYWNoQ2hpbGQgPSB1c2VDYWxsYmFjaygoZjogKGNoaWxkOiBJbmZvKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIpIHsgZihjaGlsZCk7IH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlYykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQ6IEluZm8gfCB1bmRlZmluZWQgPSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tmaWVsZCBhcyBrZXlvZiBSZWNvcmQ8VCwgSW5mbz5dO1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICAvLyBSZXRyaWV2ZXMgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hpbGQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgLy8gYHVuZGVmaW5lZGAgaWYgbm90IGNoaWxkIHRoZXJlLCBvciBpdCdzIHVubW91bnRlZC5cbiAgICBjb25zdCBnZXRNYW5hZ2VkQ2hpbGRJbmZvID0gdXNlQ2FsbGJhY2s8TWFuYWdlZENoaWxkcmVuPFQsIEMsIEs+W1wiZ2V0QXRcIl0+KChpbmRleDogVCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5kZXggYXMgbnVtYmVyXSE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tpbmRleCBhcyBUXSE7XG4gICAgfSwgW10pXG5cbiAgICAvLyB0bDtkciB0aGlzIGlzIGEgd2F5IHRvIGhhdmUgcnVuIHVzZUxheW91dEVmZmVjdCBvbmNlIGFmdGVyIGFsbCBOIGNoaWxkcmVuXG4gICAgLy8gaGF2ZSBtb3VudGVkIGFuZCBydW4gKnRoZWlyKiB1c2VMYXlvdXRFZmZlY3QsIGJ1dCBhbHNvICp3aXRob3V0KiByZS1yZW5kZXJpbmdcbiAgICAvLyBvdXJzZWx2ZXMgYmVjYXVzZSBvZiBoYXZpbmcgYSBgY2hpbGRDb3VudGAgc3RhdGUgb3IgYW55dGhpbmcgc2ltaWxhci5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIGNoaWxkIGNvdW50IHJlZiB1cGRhdGVzLCB3ZSB3YW50IHRoZSBwYXJlbnQgdG8gYWxzbyBydW4gYW4gZWZmZWN0XG4gICAgLy8gdG8gbWF5YmUgZG8gc29tZXRoaW5nIHdpdGggYWxsIHRoZXNlIGNoaWxkcmVuIHRoYXQganVzdCBtb3VudGVkLlxuICAgIC8vIFRoZSBlYXNpZXN0IHdheSB3b3VsZCBiZSB1c2VFZmZlY3QoLi4uLCBbY2hpbGRDb3VudF0pIGJ1dFxuICAgIC8vIHRoYXQgd291bGQgcmVxdWlyZSB1cyBoYXZpbmcgYSBjaGlsZENvdW50IHN0YXRlLCB0aGVuIGNhbGxpbmdcbiAgICAvLyBzZXRDaGlsZENvdW50IGFuZCByZS1yZW5kZXJpbmcgZXZlcnkgdGltZSBjaGlsZHJlbiBtb3VudFxuICAgIC8vIChvbmx5IG9uZSByZS1yZW5kZXIgYXQgYSB0aW1lIHVubGVzcyBjaGlsZHJlbiBhcmUgc3RhZ2dlcmVkLCBidXQgc3RpbGwpXG4gICAgLy8gXG4gICAgLy8gQXMgYW4gYWx0ZXJuYXRlIHNvbHV0aW9uLCBhbnkgdGltZSBhIGNoaWxkIHVzZXMgVUxFIG9uIG1vdW50LCBpdCBxdWV1ZXMgYSBtaWNyb3Rhc2tcbiAgICAvLyB0byBlbXVsYXRlIHJ1bm5pbmcgVUxFIG9uIHRoZSBwYXJlbnQuIE9ubHkgdGhlIGZpcnN0IGNoaWxkIHdpbGwgYWN0dWFsbHkgcXVldWVcbiAgICAvLyB0aGUgbWljcm90YXNrIChieSBjaGVja2luZyBoYXNSZW1vdGVVTEUgZmlyc3QpIHNvIHRoYXQgdGhlIFwiZWZmZWN0XCIgb25seVxuICAgIC8vIHJ1bnMgb25jZS4gV2hlbiBpdCdzIGRvbmUsIGhhc1JlbW90ZVVMRSBpcyByZXNldCBzbyBpdCBjYW4gcnVuIGFnYWluIGlmXG4gICAgLy8gbW9yZSBjaGlsZHJlbiBtb3VudC91bm1vdW50LlxuICAgIGNvbnN0IGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZCA9IHVzZVJlZjx7IG1vdW50czogU2V0PFQ+LCB1bm1vdW50czogU2V0PFQ+IH0gfCBudWxsPihudWxsKTtcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzID0gdXNlUmVmKG5ldyBTZXQ8VD4oKSk7XG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBUKSA9PiB7XG5cbiAgICAgICAgaWYgKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5zaXplID09IDApIHtcbiAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/LihyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuYWRkKGluZGV4KTtcblxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBULCBtb3VudGVkOiBib29sZWFuKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICghaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIG1vdW50czogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIHVubW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50IS5tb3VudHMsIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50IS51bm1vdW50cylcbiAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCA9IE1hdGgubWF4KG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4LCBpbmRleCBhcyBudW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl07XG4gICAgICAgICAgICAgICAgbGV0IHNoYXZlID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2hhdmUgPD0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoICYmIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW21hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDEgLSBzaGF2ZV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgKytzaGF2ZTtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zcGxpY2UobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMSAtIHNoYXZlLCBzaGF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIFRdO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnRbbW91bnRlZCA/IFwibW91bnRzXCIgOiBcInVubW91bnRzXCJdLmFkZChpbmRleCk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG5cbiAgICBjb25zdCB1c2VNYW5hZ2VkQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VNYW5hZ2VkQ2hpbGQ8VCwgQywgSz4+KCh7IG1hbmFnZWRDaGlsZDogaW5mbywgfSkgPT4ge1xuICAgICAgICAvLyBBbnkgdGltZSBvdXIgY2hpbGQgcHJvcHMgY2hhbmdlLCBtYWtlIHRoYXQgaW5mb3JtYXRpb24gYXZhaWxhYmxlXG4gICAgICAgIC8vIHRoZSBwYXJlbnQgaWYgdGhleSBuZWVkIGl0LlxuICAgICAgICAvLyBUaGUgcGFyZW50IGNhbiBsaXN0ZW4gZm9yIGFsbCB1cGRhdGVzIGFuZCBvbmx5IGFjdCBvbiB0aGUgb25lcyBpdCBjYXJlcyBhYm91dCxcbiAgICAgICAgLy8gYW5kIG11bHRpcGxlIGNoaWxkcmVuIHVwZGF0aW5nIGluIHRoZSBzYW1lIHRpY2sgd2lsbCBhbGwgYmUgc2VudCBhdCBvbmNlLlxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoaXMgaW5mb3JtYXRpb24gaW4tcGxhY2VcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5mby5pbmRleCA9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZm8uaW5kZXggYXMgbnVtYmVyXSA9IHsgaW5kZXg6IGluZm8uaW5kZXgsIGZsYWdzOiBpbmZvLmZsYWdzID8/IHt9LCBzdWJJbmZvOiBpbmZvLnN1YkluZm8gfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tpbmZvLmluZGV4IGFzIFRdID0geyBpbmRleDogaW5mby5pbmRleCwgZmxhZ3M6IGluZm8uZmxhZ3MgPz8ge30sIHN1YkluZm86IGluZm8uc3ViSW5mbyB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZChpbmZvLmluZGV4IGFzIFQpO1xuICAgICAgICB9LCBbLi4uT2JqZWN0LmVudHJpZXMoaW5mbykuZmxhdCg5KV0pOyAgLy8gOSBpcyBpbmZpbml0eSwgcmlnaHQ/IFN1cmUuIFVucmVsYXRlZDogVE9ETy5cblxuICAgICAgICAvLyBXaGVuIHdlIG1vdW50LCBub3RpZnkgdGhlIHBhcmVudCB2aWEgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgLy8gKGV2ZXJ5IGNoaWxkIGRvZXMgdGhpcywgc28gZXZlcnl0aGluZydzIGNvb3JkaW5hdGVkIHRvIG9ubHkgcXVldWUgYSBzaW5nbGUgbWljcm90YXNrIHBlciB0aWNrKVxuICAgICAgICAvLyBEbyB0aGUgc2FtZSBvbiB1bm1vdW50LlxuICAgICAgICAvLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgY29tZXMgQUZURVIgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkXG4gICAgICAgIC8vIHNvIHRoYXQgcmVtb3RlVUxFQ2hpbGRNb3VudGVkIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSBpbmZvIG9uIG1vdW50LlxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5mby5pbmRleCBhcyBULCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmZvLmluZGV4IGFzIFQsIGZhbHNlKTtcbiAgICAgICAgfSwgW2luZm8uaW5kZXhdKTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cblxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbiA9IHVzZVJlZjxNYW5hZ2VkQ2hpbGRyZW48VCwgQywgSz4+KHtcbiAgICAgICAgLi4ueyBfOiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50IH0gYXMge30sXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZCxcbiAgICAgICAgZ2V0QXQ6IGdldE1hbmFnZWRDaGlsZEluZm8sXG4gICAgICAgIGdldEhpZ2hlc3RJbmRleDogZ2V0SGlnaGVzdEluZGV4LFxuICAgICAgICBhcnJheVNsaWNlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc2xpY2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTWFuYWdlZENoaWxkLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW46IG1hbmFnZWRDaGlsZHJlbi5jdXJyZW50IH1cbiAgICB9XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIGNoaWxkIGlzIGNvbnNpZGVyZWQgYWN0aXZlIG9uIG1vdW50LlxuICAgICAqIFxuICAgICAqIEFmdGVyIG1vdW50LCBjaGFuZ2UgdGhlIGN1cnJlbnQgYWN0aXZlIGNoaWxkIHdpdGggYGNoYW5nZUluZGV4YC5cbiAgICAgKi9cbiAgICBpbml0aWFsSW5kZXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHByb3ZpZGVkLCBpZiB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXggZG9lc24ndCBtYXAgb250byBhbnlcbiAgICAgKiBwcm92aWRlZCBjaGlsZCAoZWl0aGVyIGJlY2F1c2UgaXQncyB0b28gbGFyZ2Ugb3IgdGhhdCBjaGlsZFxuICAgICAqIGRvZXNuJ3QgZXhpc3QpLCB0aGUgY2xvc2VzdCBjaGlsZCB0byB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXhcbiAgICAgKiB3aWxsIGhhdmUgaXRzIGZsYWcgc2V0IGluc3RlYWQuXG4gICAgICogXG4gICAgICogVXNlIHdpdGggY2F1dGlvbiwgYW5kIGNvbnNpZGVyIGhvdyBhIGNoaWxkIGhhdmluZyBpdHMgZmxhZyBzZXRcbiAgICAgKiB3aGlsZSB0aGUgcGFyZW50IHRoaW5rcyBpdCBzaG91bGRuJ3QgYmUgY291bGQgY2F1c2UgaXNzdWVzLlxuICAgICAqL1xuICAgIC8vY2xvc2VzdEZpdD86IGJvb2xlYW47XG4gICAgY2xvc2VzdEZpdDogYm9vbGVhbjtcblxuICAgIGNoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmRleCBpcyBzZWxlY3RlZC5cbiAgICAgKiBcbiAgICAgKiBOb3RhYmx5LCB0aGUgdmFsdWUgY2FuIGJlIGRpZmZlcmVudCB0aGFuIHdoYXQgd2FzIGNhbGxlZCB3aXRoIGNoYW5nZUluZGV4KClcbiAgICAgKiBpZiB0aGUgcmVxdWVzdGVkIGluZGV4IGRpZG4ndCBleGlzdCBvciB3YXMgaGlkZGVuLlxuICAgICAqL1xuICAgIG9uSW5kZXhDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxudW1iZXIgfCBudWxsPjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2hpbGRyZW4gaGF2ZSBtdWx0aXBsZSBmbGFncywgdGhlIGBrZXlgIHBhcmFtZXRlciBjb250cm9scyB3aGljaCBmbGFnIHdlJ3JlIGNoZWNraW5nLlxuICAgICAqIFxuICAgICAqIFRoaXMgY2FuIGJlIGFueXRoaW5nIHlvdSB3YW50LCBidXQgbXVzdCBub3QgY2hhbmdlLlxuICAgICAqL1xuICAgIGtleTogSztcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkRmxhZ09wZXJhdGlvbnMge1xuXG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4gd2hldGhlciB0aGUgY3VycmVudCBjaGlsZCBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBnZXQ6ICgpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIGNoaWxkIG11c3Qgc2V0IGl0c2VsZiBhcyBhY3RpdmUvaW5hY3RpdmUsIHdoYXRldmVyIHRoYXQgZW50YWlscy5cbiAgICAgKiBUaGlzIGNvdWxkIGJlIGFzIHNpbXBsZSBhcyBhIHNldFN0YXRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHNldDogKGFjdGl2ZTogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAvKipcbiAgICAgKiBNdXN0IHJldHVybiB0cnVlIGlmIHRoaXMgY2hpbGQgaXMgYSB2YWxpZCBjYW5kaWRhdGUgdG8gYmUgZmxhZ2dlZCwgYW5kIGZhbHNlIGlmIG5vdC5cbiAgICAgKiBNb3N0IGNoaWxkcmVuIHNob3VsZCByZXR1cm4gdHJ1ZS4gUmV0dXJuaW5nIGZhbHNlIGlzIG9ubHkgdXNlZnVsIHRvIG1hcmsgYSBjaGlsZCBhcyBcImludmFsaWRcIiBpbiBzb21lIHdheS5cbiAgICAgKiBSZW1vdmluZyBhIGNoaWxkIGZyb20gdGhlIGxpc3QgZG9lcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZywgYnV0IHRoaXMgbGV0cyB5b3Uga2VlcCB0aGUgY2hpbGQgYXJvdW5kLlxuICAgICAqL1xuICAgIGlzVmFsaWQoKTogYm9vbGVhbjtcbn1cblxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgRmxhZ2dhYmxlQ2hpbGRJbmZvQjxLIGV4dGVuZHMgc3RyaW5nPiB7IGZsYWdzOiBQYXJ0aWFsPFJlY29yZDxLLCBDaGlsZEZsYWdPcGVyYXRpb25zPj4gfSBcblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGUge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgY2hhbmdlSW5kZXg6IChhcmc6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSkgPT4gbnVtYmVyIHwgbnVsbDtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxuICAgICAqICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBudW1iZXIgfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB1c2VNYW5hZ2VkQ2hpbGRyZW4gdGhhdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY29tbW9uIGNhc2U6XG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXG4gKiAzLiBUaGUgcGFyZW50IGhhcyBjb250cm9sIG92ZXIgd2hvIGlzIFwic2VsZWN0ZWRcIiB2aWEgYSBudW1lcmljYWwgaW5kZXguXG4gKiBcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cbiAqIFxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxuICogXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGNoaWxkcmVuLCBpbml0aWFsSW5kZXgsIGNsb3Nlc3RGaXQsIG9uSW5kZXhDaGFuZ2UsIGtleSB9OiBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPEMsIEs+KTogVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZSB7XG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlQ2hpbGRyZW5GbGFnXCIsIG9uSW5kZXhDaGFuZ2UsIGtleSk7XG5cbiAgICBjb25zdCBbZ2V0Q3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBudW1iZXI+KG9uSW5kZXhDaGFuZ2UsIHVzZUNhbGxiYWNrKCgpID0+IChpbml0aWFsSW5kZXggPz8gKG51bGwpKSwgW10pKTtcblxuICAgIGNvbnN0IFtnZXRSZXF1ZXN0ZWRJbmRleCwgc2V0UmVxdWVzdGVkSW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBudW1iZXI+KG51bGwsIHVzZUNhbGxiYWNrKCgpID0+IChpbml0aWFsSW5kZXggPz8gKG51bGwpKSwgW10pKTtcblxuICAgIC8vICAgIGNvbnN0IGdldEZpdE51bGxUb1plcm8gPSB1c2VTdGFibGVHZXR0ZXIoZml0TnVsbFRvWmVybyk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgYW5kIGNoYW5nZUluZGV4LCBub3QgcHVibGljIChidXQgY291bGQgYmUgSSBndWVzcylcbiAgICBjb25zdCBnZXRDbG9zZXN0Rml0ID0gdXNlQ2FsbGJhY2soKHJlcXVlc3RlZEluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBsZXQgY2xvc2VzdEluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZC5mbGFncz8uW2tleV0/LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rpc3RhbmNlID0gTWF0aC5hYnMoY2hpbGQuaW5kZXggLSByZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0Rpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlIHx8IChuZXdEaXN0YW5jZSA9PSBjbG9zZXN0RGlzdGFuY2UgJiYgY2hpbGQuaW5kZXggPCByZXF1ZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGNoaWxkLmluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjbG9zZXN0SW5kZXg7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSEgKi9dKTtcblxuICAgIC8vIEFueSB0aW1lIGEgY2hpbGQgbW91bnRzL3VubW91bnRzLCB3ZSBuZWVkIHRvIGRvdWJsZS1jaGVjayB0byBzZWUgaWYgdGhhdCBhZmZlY3RzIFxuICAgIC8vIHRoZSBcImN1cnJlbnRseSBzZWxlY3RlZFwiIChvciB3aGF0ZXZlcikgaW5kZXguICBUaGUgdHdvIGNhc2VzIHdlJ3JlIGxvb2tpbmcgZm9yOlxuICAgIC8vIDEuIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2hpbGQgdW5tb3VudGVkXG4gICAgLy8gMi4gQSBjaGlsZCBtb3VudGVkLCBhbmQgaXQgbW91bnRzIHdpdGggdGhlIGluZGV4IHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAgY29uc3QgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gZ2V0UmVxdWVzdGVkSW5kZXgoKTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gZ2V0Q3VycmVudEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XG5cbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ICE9IG51bGwgJiYgY2xvc2VzdEZpdCAmJiAocmVxdWVzdGVkSW5kZXggIT0gY3VycmVudEluZGV4IHx8IGN1cnJlbnRDaGlsZCA9PSBudWxsIHx8ICFjdXJyZW50Q2hpbGQuZmxhZ3M/LltrZXldPy5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICBjdXJyZW50Q2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCk7XG4gICAgICAgICAgICBpZiAoY2xvc2VzdEZpdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0Q2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChjbG9zZXN0Rml0Q2hpbGQgIT0gbnVsbCwgXCJJbnRlcm5hbCBsb2dpYz8/P1wiKTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0Rml0Q2hpbGQuZmxhZ3M/LltrZXldIS5zZXQodHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cblxuXG4gICAgY29uc3QgY2hhbmdlSW5kZXggPSB1c2VDYWxsYmFjaygoYXJnOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0pID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSBhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyhnZXRSZXF1ZXN0ZWRJbmRleCgpKSA6IGFyZztcbiAgICAgICAgLy9pZiAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCAmJiBnZXRGaXROdWxsVG9aZXJvKCkpXG4gICAgICAgIC8vICAgIHJlcXVlc3RlZEluZGV4ID0gMDtcblxuICAgICAgICBzZXRSZXF1ZXN0ZWRJbmRleChyZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xuICAgICAgICBpZiAoY3VycmVudEluZGV4ID09IHJlcXVlc3RlZEluZGV4KVxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuXG4gICAgICAgIGxldCBuZXdNYXRjaGluZ0NoaWxkID0gKHJlcXVlc3RlZEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQocmVxdWVzdGVkSW5kZXgpKTtcbiAgICAgICAgY29uc3Qgb2xkTWF0Y2hpbmdDaGlsZCA9IChjdXJyZW50SW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChjdXJyZW50SW5kZXgpKTtcbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEVhc3kgY2FzZVxuICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KG51bGwpO1xuICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobmV3TWF0Y2hpbmdDaGlsZCAmJiBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzPy5ba2V5XSEuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgbmV3TWF0Y2hpbmdDaGlsZC5mbGFncz8uW2tleV0hLnNldCh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdEZpdEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF0Y2hpbmdDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChuZXdNYXRjaGluZ0NoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XG4gICAgICAgICAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF0Y2hpbmdDaGlsZC5mbGFncz8uW2tleV0hLnNldCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3RGaXRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGluaXRpYWxJbmRleCAhPSBudWxsKVxuICAgICAgICAgICAgY2hpbGRyZW4uZ2V0QXQoaW5pdGlhbEluZGV4KT8uZmxhZ3M/LltrZXldPy5zZXQodHJ1ZSk7XG4gICAgfSwgW10pXG5cbiAgICByZXR1cm4geyBjaGFuZ2VJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQsIGdldEN1cnJlbnRJbmRleCB9O1xufVxuXG4iLCJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSlmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtlbHNlIGZvcih0IGluIGUpZVt0XSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiO2Y8YXJndW1lbnRzLmxlbmd0aDspKGU9YXJndW1lbnRzW2YrK10pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9jdW1lbnQoZWxlbWVudD86IE5vZGUpIHsgcmV0dXJuIChlbGVtZW50Py5vd25lckRvY3VtZW50ID8/IGRvY3VtZW50ID8/IHdpbmRvdy5kb2N1bWVudCA/PyBnbG9iYWxUaGlzLmRvY3VtZW50KTsgfVxuXG50eXBlIFAgPSBQYXJhbWV0ZXJzPHR5cGVvZiBjbHN4PjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURvY3VtZW50Q2xhc3MoY2xhc3NOYW1lOiBQWzBdLCBhY3RpdmU/OiBib29sZWFuLCBlbGVtZW50PzogSFRNTEVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID8/PSBnZXREb2N1bWVudCgpLmRvY3VtZW50RWxlbWVudDtcbiAgICBjbGFzc05hbWUgPSBjbHN4KGNsYXNzTmFtZSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lIGFzIHN0cmluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGVsZW1lbnQhLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lIGFzIHN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sIFtjbGFzc05hbWUsIGFjdGl2ZSwgZWxlbWVudF0pO1xuXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENoaWxkcmVuKHsgY2hpbGRyZW46IGxocyB9OiBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PiwgXCJjaGlsZHJlblwiPiwgeyBjaGlsZHJlbjogcmhzfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwiY2hpbGRyZW5cIj4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJjaGlsZHJlblwiXSB7XG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByaHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsaHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwge30sIGxocywgcmhzKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBkZWZhdWx0IGFzIGNsc3ggfSBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlaXIgYGNsYXNzYCBhbmQgYGNsYXNzTmFtZWAgcHJvcGVydGllcy5cclxuICogRHVwbGljYXRlIGNsYXNzZXMgYXJlIHJlbW92ZWQgKG9yZGVyIGRvZXNuJ3QgbWF0dGVyIGFueXdheSkuXHJcbiAqIFxyXG4gKiBAcGFyYW0gbGhzIENsYXNzZXMgb2YgdGhlIGZpcnN0IGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gcmhzIENsYXNzZXMgb2YgdGhlIHNlY29uZCBjb21wb25lbnRcclxuICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIGFsbCBjb21iaW5lZCBjbGFzc2VzIGZyb20gYm90aCBhcmd1bWVudHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkQ2xhc3NlczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KHsgY2xhc3M6IGxoc0NsYXNzLCBjbGFzc05hbWU6IGxoc0NsYXNzTmFtZSB9OiBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+LCBcImNsYXNzXCIgfCBcImNsYXNzTmFtZVwiPiwgeyBjbGFzczogcmhzQ2xhc3MsIGNsYXNzTmFtZTogcmhzQ2xhc3NOYW1lfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgXCJjbGFzc1wiIHwgXCJjbGFzc05hbWVcIj4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG5cclxuICAgIC8vIE5vdGU6IEZvciB0aGUgc2FrZSBvZiBmb3J3YXJkIGNvbXBhdGliaWxpdHksIHRoaXMgZnVuY3Rpb24gaXMgbGFiZWxsZWQgYXNcclxuICAgIC8vIGEgaG9vaywgYnV0IGFzIGl0IHVzZXMgbm8gb3RoZXIgaG9va3MgaXQgdGVjaG5pY2FsbHkgaXNuJ3Qgb25lLlxyXG5cclxuICAgIGlmIChsaHNDbGFzcyB8fCByaHNDbGFzcyB8fCBsaHNDbGFzc05hbWUgfHwgcmhzQ2xhc3NOYW1lKSB7XHJcbiAgICAgICAgY29uc3QgbGhzQ2xhc3NlcyA9IGNsc3gobGhzQ2xhc3MsIGxoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgIGNvbnN0IHJoc0NsYXNzZXMgPSBjbHN4KHJoc0NsYXNzLCByaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBjb25zdCBhbGxDbGFzc2VzID0gbmV3IFNldChbLi4uQXJyYXkuZnJvbShsaHNDbGFzc2VzKSwgLi4uQXJyYXkuZnJvbShyaHNDbGFzc2VzKV0pXHJcblxyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGFsbENsYXNzZXMpLmpvaW4oXCIgXCIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBoLCBSZWYsIFJlZkNhbGxiYWNrLCBSZWZPYmplY3QgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5cclxuXHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWY8VD4oaW5zdGFuY2U6IFQgfCBudWxsLCByZWY6IFJlZjxUPiB8IG51bGwgfCB1bmRlZmluZWQpIHtcclxuICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICByZWYoaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVmICE9IG51bGwpIHtcclxuICAgICAgICAocmVmIGFzIFJlZk9iamVjdDxUIHwgbnVsbD4pLmN1cnJlbnQgPSBpbnN0YW5jZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXHJcbiAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UsIFwiVW5rbm93biByZWYgdHlwZSBmb3VuZCB0aGF0IHdhcyBuZWl0aGVyIGEgUmVmQ2FsbGJhY2sgbm9yIGEgUmVmT2JqZWN0XCIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgUjxFPiB7XHJcbiAgICByZWY/OiBSZWY8RT47XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogQ29tYmluZXMgdHdvIHJlZnMgaW50byBvbmUuIFRoaXMgYWxsb3dzIGEgY29tcG9uZW50IHRvIGJvdGggdXNlIGl0cyBvd24gcmVmICphbmQqIGZvcndhcmQgYSByZWYgdGhhdCB3YXMgZ2l2ZW4gdG8gaXQuXHJcbiAqIEBwYXJhbSBsaHMgXHJcbiAqIEBwYXJhbSByaHMgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFJlZnM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0Pih7IHJlZjogcmhzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+LCB7IHJlZjogbGhzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSB7XHJcbiAgICBjb25zdCBjb21iaW5lZDogUmVmQ2FsbGJhY2s8RT4gPSB1c2VDYWxsYmFjaygoY3VycmVudDogRSB8IG51bGwpID0+IHtcclxuICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIGxocyk7XHJcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCByaHMpO1xyXG4gICAgfSwgW2xocywgcmhzXSk7XHJcblxyXG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZCE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiByaHMhO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbGhzITtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBjb21iaW5lZDtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5cclxuZnVuY3Rpb24gc3R5bGVTdHJpbmdUb09iamVjdChzdHlsZTogc3RyaW5nKTogaC5KU1guQ1NTUHJvcGVydGllcyB7XHJcbiAgICAvLyBUT0RPOiBUaGlzIHN1Y2tzIEQ6XHJcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHN0eWxlLnNwbGl0KFwiO1wiKS5tYXAoc3RhdGVtZW50ID0+IHN0YXRlbWVudC5zcGxpdChcIjpcIikpKSBhcyB1bmtub3duIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNZXJnZXMgdHdvIHN0eWxlIG9iamVjdHMsIHJldHVybmluZyB0aGUgcmVzdWx0LlxyXG4gKiBcclxuICogQHBhcmFtIHN0eWxlIFRoZSB1c2VyLWdpdmVuIHN0eWxlIHByb3AgZm9yIHRoaXMgY29tcG9uZW50XHJcbiAqIEBwYXJhbSBvYmogVGhlIENTUyBwcm9wZXJ0aWVzIHlvdSB3YW50IGFkZGVkIHRvIHRoZSB1c2VyLWdpdmVuIHN0eWxlXHJcbiAqIEByZXR1cm5zIEEgQ1NTIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIGJvdGggb2JqZWN0cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRTdHlsZXMobGhzOiBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PiwgXCJzdHlsZVwiPiwgcmhzOiBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PiwgXCJzdHlsZVwiPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcInN0eWxlXCJdIHtcclxuXHJcbiAgICAvLyBFYXN5IGNhc2UsIHdoZW4gdGhlcmUgYXJlIG5vIHN0eWxlcyB0byBtZXJnZSByZXR1cm4gbm90aGluZy5cclxuICAgIGlmICghbGhzPy5zdHlsZSAmJiAhcmhzPy5zdHlsZSlcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuICAgIGlmICh0eXBlb2YgbGhzICE9IHR5cGVvZiByaHMpIHtcclxuICAgICAgICAvLyBFYXN5IGNhc2VzLCB3aGVuIG9uZSBpcyBudWxsIGFuZCB0aGUgb3RoZXIgaXNuJ3QuXHJcbiAgICAgICAgaWYgKGxocz8uc3R5bGUgJiYgIXJocz8uc3R5bGUpXHJcbiAgICAgICAgICAgIHJldHVybiBsaHMuc3R5bGU7XHJcbiAgICAgICAgaWYgKCFsaHM/LnN0eWxlICYmIHJocz8uc3R5bGUpXHJcbiAgICAgICAgICAgIHJldHVybiByaHMuc3R5bGU7XHJcblxyXG4gICAgICAgIC8vIFRoZXkncmUgYm90aCBub24tbnVsbCBidXQgZGlmZmVyZW50IHR5cGVzLlxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZyB0eXBlIHRvIGFuIG9iamVjdCBiYWcgdHlwZSBhbmQgcnVuIGl0IGFnYWluLlxyXG4gICAgICAgIGlmIChsaHM/LnN0eWxlICYmIHJocz8uc3R5bGUpIHtcclxuICAgICAgICAgICAgLy8gKHVzZU1lcmdlZFN0eWxlcyBpc24ndCBhIHRydWUgaG9vayAtLSB0aGlzIGlzbid0IGEgdmlvbGF0aW9uKVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxocz8uc3R5bGUgPT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRTdHlsZXMoeyBzdHlsZTogc3R5bGVTdHJpbmdUb09iamVjdChsaHM/LnN0eWxlIGFzIHN0cmluZykgfSwgcmhzKSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJocz8uc3R5bGUgPT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRTdHlsZXMobGhzLCB7IHN0eWxlOiBzdHlsZVN0cmluZ1RvT2JqZWN0KHJocz8uc3R5bGUgYXMgc3RyaW5nKSB9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTG9naWM/Pz9cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZXkncmUgYm90aCBzdHJpbmdzLCBqdXN0IGNvbmNhdGVuYXRlIHRoZW0uXHJcbiAgICBpZiAodHlwZW9mIGxocz8uc3R5bGUgPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIHJldHVybiBgJHtsaHMuc3R5bGV9OyR7cmhzPy5zdHlsZSA/PyBcIlwifWAgYXMgdW5rbm93biBhcyBzdHJpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhleSdyZSBib3RoIG9iamVjdHMsIGp1c3QgbWVyZ2UgdGhlbS5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uKGxocz8uc3R5bGUgPz8ge30pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXMsXHJcbiAgICAgICAgLi4uKHJocz8uc3R5bGUgPz8ge30pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcclxuICAgIH0gYXMgdW5rbm93biBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXHJcbn1cclxuXHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZENoaWxkcmVuIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1jaGlsZHJlblwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRDbGFzc2VzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1jbGFzc2VzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFJlZnMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXJlZnNcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkU3R5bGVzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1zdHlsZXNcIjtcclxuXHJcbmxldCBsb2cgPSBjb25zb2xlLndhcm47XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1Byb3BDb25mbGljdHMobG9nMjogdHlwZW9mIGNvbnNvbGVbXCJsb2dcIl0pIHtcclxuICAgIGxvZyA9IGxvZzJcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZW0gYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICogXHJcbiAqIFRoZSBob29rIGlzIGF3YXJlIG9mIGFuZCBjYW4gaW50ZWxsaWdlbnRseSBtZXJnZSBgY2xhc3NOYW1lYCwgYGNsYXNzYCwgYHN0eWxlYCwgYHJlZmAsIGFuZCBhbGwgZXZlbnQgaGFuZGxlcnMuXHJcbiAqIEBwYXJhbSBsaHMyIFxyXG4gKiBAcGFyYW0gcmhzMiBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PihsaHNBbGw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+LCByaHNBbGw6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4ge1xyXG4gICAgLy8gRmlyc3QsIHNlcGFyYXRlIHRoZSBwcm9wcyB3ZSB3ZXJlIGdpdmVuIGludG8gdHdvIGdyb3VwczpcclxuICAgIC8vIGxoc0FsbCBhbmQgcmhzQWxsIGNvbnRhaW4gYWxsIHRoZSBwcm9wcyB3ZSB3ZXJlIGdpdmVuLCBhbmRcclxuICAgIC8vIGxoc01pc2MgYW5kIHJoc01pc2MgY29udGFpbiBhbGwgcHJvcHMgKmV4Y2VwdCogZm9yIHRoZSBlYXN5IG9uZXNcclxuICAgIC8vIGxpa2UgY2xhc3NOYW1lIGFuZCBzdHlsZSB0aGF0IHdlIGFscmVhZHkga25vdyBob3cgdG8gbWVyZ2UuXHJcbiAgICBjb25zdCB7IGNoaWxkcmVuOiBfbGhzQ2hpbGRyZW4sIGNsYXNzOiBfbGhzQ2xhc3MsIGNsYXNzTmFtZTogX2xoc0NsYXNzTmFtZSwgc3R5bGU6IF9saHNTdHlsZSwgcmVmOiBfbGhzUmVmLCAuLi5saHNNaXNjIH0gPSBsaHNBbGw7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuOiBfcmhzQ2hpbGRyZW4sIGNsYXNzOiBfcmhzQ2xhc3MsIGNsYXNzTmFtZTogX3Joc0NsYXNzTmFtZSwgc3R5bGU6IF9yaHNTdHlsZSwgcmVmOiBfcmhzUmVmLCAuLi5yaHNNaXNjIH0gPSByaHNBbGw7XHJcblxyXG4gICAgY29uc3QgcmV0OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiA9IHtcclxuICAgICAgICAuLi5saHNNaXNjLFxyXG4gICAgICAgIHJlZjogdXNlTWVyZ2VkUmVmczxFPihsaHNBbGwsIHJoc0FsbCksXHJcbiAgICAgICAgc3R5bGU6IHVzZU1lcmdlZFN0eWxlcyhsaHNBbGwsIHJoc0FsbCksXHJcbiAgICAgICAgY2xhc3NOYW1lOiB1c2VNZXJnZWRDbGFzc2VzKGxoc0FsbCwgcmhzQWxsKSxcclxuICAgICAgICBjaGlsZHJlbjogdXNlTWVyZ2VkQ2hpbGRyZW4obGhzQWxsLCByaHNBbGwpLFxyXG4gICAgfSBhcyBhbnk7XHJcblxyXG4gICAgaWYgKHJldC5yZWYgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5yZWY7XHJcbiAgICBpZiAocmV0LnN0eWxlID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuc3R5bGU7XHJcbiAgICBpZiAocmV0LmNsYXNzTmFtZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNsYXNzTmFtZTtcclxuICAgIGlmIChyZXQuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jaGlsZHJlbjtcclxuXHJcbiAgICAvLyBOb3csIGRvICpldmVyeXRoaW5nKiBlbHNlXHJcbiAgICAvLyBNZXJnZSBldmVyeSByZW1haW5pbmcgZXhpc3RpbmcgZW50cnkgaW4gbGhzIHdpdGggd2hhdCB3ZSd2ZSBhbHJlYWR5IHB1dCBpbiByZXQuXHJcbiAgICAvL2NvbnN0IGxoc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhsaHMpIGFzIFtrZXlvZiBULCBUW2tleW9mIFRdXVtdO1xyXG4gICAgY29uc3QgcmhzRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHJoc01pc2MpO1xyXG5cclxuICAgIGZvciAoY29uc3QgW3Joc0tleVUsIHJoc1ZhbHVlXSBvZiByaHNFbnRyaWVzKSB7XHJcbiAgICAgICAgY29uc3QgcmhzS2V5ID0gcmhzS2V5VSBhcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcclxuXHJcbiAgICAgICAgY29uc3QgbGhzVmFsdWUgPSBsaHNNaXNjW3Joc0tleSBhcyBrZXlvZiB0eXBlb2YgbGhzTWlzY107XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgbGhzVmFsdWUgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmhzVmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhleSdyZSBib3RoIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBtZXJnZWQgKG9yIG9uZSdzIGEgZnVuY3Rpb24gYW5kIHRoZSBvdGhlcidzIG51bGwpLlxyXG4gICAgICAgICAgICAvLyBOb3QgYW4gKmVhc3kqIGNhc2UsIGJ1dCBhIHdlbGwtZGVmaW5lZCBvbmUuXHJcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlRnVuY3Rpb25zKGxoc1ZhbHVlIGFzIG5ldmVyLCByaHNWYWx1ZSBhcyBuZXZlcik7XHJcbiAgICAgICAgICAgIHJldFtyaHNLZXkgYXMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5dID0gbWVyZ2VkIGFzIG5ldmVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVWguLi53ZSdyZSBoZXJlIGJlY2F1c2Ugb25lIG9mIHRoZW0ncyBudWxsLCByaWdodD9cclxuICAgICAgICAgICAgaWYgKGxoc1ZhbHVlID09IG51bGwgJiYgcmhzVmFsdWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJoc1ZhbHVlID09PSBudWxsICYmIGxoc1ZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IGxoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgZWxzZSBpZiAocmhzVmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gbGhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChyaHNWYWx1ZSBhcyBhbnkpID09IGxoc1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJIG1lYW4sIHRoZXkncmUgdGhlIHNhbWUgdmFsdWUgYXQgbGVhc3RcclxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3QgcmVhbGx5IGlkZWFsIHRob3VnaC5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFVnaC5cclxuICAgICAgICAgICAgICAgIC8vIE5vIGdvb2Qgc3RyYXRlZ2llcyBoZXJlLCBqdXN0IGxvZyBpdCBpZiByZXF1ZXN0ZWRcclxuICAgICAgICAgICAgICAgIGxvZz8uKGBUaGUgcHJvcCBcIiR7cmhzS2V5fVwiIGNhbm5vdCBzaW11bHRhbmVvdXNseSBiZSB0aGUgdmFsdWVzICR7bGhzVmFsdWV9IGFuZCAke3Joc1ZhbHVlfS4gT25lIG11c3QgYmUgY2hvc2VuIG91dHNpZGUgb2YgdXNlTWVyZ2VkUHJvcHMuYCk7XHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IHJoc1ZhbHVlIGFzIG5ldmVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJldDtcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1lcmdlRnVuY3Rpb25zPFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueSwgVSBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihsaHM6IFQgfCBudWxsIHwgdW5kZWZpbmVkLCByaHM6IFUgfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgaWYgKCFsaHMpXHJcbiAgICAgICAgcmV0dXJuIHJocztcclxuICAgIGlmICghcmhzKVxyXG4gICAgICAgIHJldHVybiBsaHM7XHJcblxyXG4gICAgcmV0dXJuICguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KSA9PiB7XHJcbiAgICAgICAgY29uc3QgbHYgPSBsaHMoLi4uYXJncyk7XHJcbiAgICAgICAgY29uc3QgcnYgPSByaHMoLi4uYXJncyk7XHJcblxyXG4gICAgICAgIGlmIChsdiBpbnN0YW5jZW9mIFByb21pc2UgfHwgcnYgaW5zdGFuY2VvZiBQcm9taXNlKVxyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2x2LCBydl0pO1xyXG4gICAgfTtcclxufVxyXG5cclxuLypcclxuZnVuY3Rpb24gdGVzdDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SFRNTElucHV0RWxlbWVudD4+KHByb3BzOiBQKSB7XHJcblxyXG4gICAgY29uc3QgaWQwOiBHZW5lcmljR2V0PHt9LCBcImlkXCIsIHN0cmluZz4gPSBcIlwiO1xyXG4gICAgY29uc3QgaWQzOiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDQ6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNTogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ2OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICAvL2NvbnN0IGlkMjogWmlwU2luZ2xlPHN0cmluZyB8IHVuZGVmaW5lZCwgc3RyaW5nIHwgdW5kZWZpbmVkPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkMTogWmlwT2JqZWN0PHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB7IGlkOiB1bmRlZmluZWQgfTtcclxuXHJcbiAgICB0eXBlIE0xID0gR2VuZXJpY0dldDxQLCBcInN0eWxlXCIsIHN0cmluZz47XHJcbiAgICB0eXBlIE0yID0gR2VuZXJpY0dldDx7fSwgXCJzdHlsZVwiLCBzdHJpbmc+O1xyXG4gICAgY29uc3QgbTE6IE0xID0gXCJcIjtcclxuICAgIGNvbnN0IG0yOiBNMSA9IHVuZGVmaW5lZDtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIEJlY2F1c2UgbnVtYmVyIGlzbid0IGFzc2lnbmFibGUgdG8gc3RyaW5nXHJcbiAgICBjb25zdCBtMzogTTEgPSAwO1xyXG5cclxuICAgIGNvbnN0IG00OiBNMiA9IFwiXCI7XHJcbiAgICBjb25zdCBtNTogTTIgPSB1bmRlZmluZWQ7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xyXG4gICAgY29uc3QgbTY6IE0yID0gMDtcclxuXHJcbiAgICBjb25zdCBwMTogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHsgaWQ6IHN0cmluZyB9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHsgaWQ6IFwic3RyaW5nXCIgfSk7XHJcbiAgICBjb25zdCBwMjogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwgeyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IHN0cmluZyB9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoeyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IFwic3RyaW5nXCIgfSk7XHJcbiAgICBjb25zdCBwMzogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwgeyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IHVuZGVmaW5lZCB9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoeyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IHVuZGVmaW5lZCB9KTtcclxuICAgIGNvbnN0IHA0OiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7fSwge30+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwge30pO1xyXG4gICAgY29uc3QgcDUgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7fSk7XHJcbiAgICBjb25zdCBwNiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IHVuZGVmaW5lZCB9KTtcclxuICAgIGNvbnN0IHA3ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgeyBpZDogXCJzdHJpbmdcIiB9KTtcclxuXHJcblxyXG4gICAgcDEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHAyLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXHJcbiAgICBwMy5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcDQuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcblxyXG4gICAgcDUuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHA2LmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNy5pZD8uY29uY2F0KFwiXCIpO1xyXG5cclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHA1LmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHA2LmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHA3LmlkLmNvbmNhdChcIlwiKTtcclxuXHJcblxyXG4gICAgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDUuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNi5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA2LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA3LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDcuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gTWFrZSBzdXJlIGl0IHdvcmtzIHJlY3Vyc2l2ZWx5XHJcbiAgICBjb25zdCByMWEgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwMSk7XHJcbiAgICBjb25zdCByMWIgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwMSk7XHJcbiAgICBjb25zdCByMmEgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwMik7XHJcbiAgICBjb25zdCByMmIgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwMik7XHJcbiAgICBjb25zdCByM2EgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwMyk7XHJcbiAgICBjb25zdCByM2IgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwMyk7XHJcbiAgICBjb25zdCByNGEgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwNCk7XHJcbiAgICBjb25zdCByNGIgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwNCk7XHJcbiAgICBjb25zdCByNWEgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwNSk7XHJcbiAgICBjb25zdCByNWIgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwNSk7XHJcbiAgICBjb25zdCByNmEgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwNik7XHJcbiAgICBjb25zdCByNmIgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwNik7XHJcbiAgICBjb25zdCByN2EgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCBwNyk7XHJcbiAgICBjb25zdCByN2IgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCBwNyk7XHJcblxyXG5cclxuICAgIHIxYS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjFiLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMmEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIyYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXHJcbiAgICByM2EuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIzYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcjRhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNGIuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcblxyXG4gICAgcjVhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNWIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI2YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjZiLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByN2EuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI3Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG5cclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI1YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNWIuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjZhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI2Yi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByN2EuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjdiLmlkLmNvbmNhdChcIlwiKTtcclxuXHJcblxyXG4gICAgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocjVhLmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihyNWEuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocjViLmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihyNWIuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocjZhLmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihyNmEuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocjZiLmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihyNmIuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocjdhLmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihyN2EuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocjdiLmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihyN2IuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcbn1cclxuZnVuY3Rpb24gYWNjZXB0c05ldmVyKG46IG5ldmVyKSB7fVxyXG4qLyIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFJldHVyblR5cGU8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgZ2V0RWxlbWVudCgpOiBUIHwgbnVsbDtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4ge1xyXG4gICAgb25FbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGw+O1xyXG4gICAgb25Nb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xyXG4gICAgb25Vbm1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgYWNjZXNzaW5nIHRoZSBlbGVtZW50IGEgcmVmIHJlZmVyZW5jZXMgYXMgc29vbiBhcyBpdCBkb2VzIHNvLlxyXG4gKiAqVGhpcyBob29rIGl0c2VsZiByZXR1cm5zIGEgaG9vayotLXVzZVJlZkVsZW1lbnRQcm9wcyBtb2RpZmllcyB0aGUgcHJvcHMgdGhhdCB5b3Ugd2VyZSBnb2luZyB0byBwYXNzIHRvIGFuIEhUTUxFbGVtZW50LCBcclxuICogYWRkaW5nIGEgUmVmQ2FsbGJhY2sgYW5kIG1lcmdpbmcgaXQgd2l0aCBhbnkgZXhpc3RpbmcgcmVmIHRoYXQgZXhpc3RlZCBvbiB0aGUgcHJvcHMuXHJcbiAqIFxyXG4gKiBEb24ndCBmb3JnZXQgdG8gcHJvdmlkZSB0aGUgRWxlbWVudCBhcyB0aGUgdHlwZSBhcmd1bWVudCFcclxuICogXHJcbiAqIEByZXR1cm5zIFRoZSBlbGVtZW50LCBhbmQgdGhlIHN1Yi1ob29rIHRoYXQgbWFrZXMgaXQgcmV0cmlldmFibGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmRWxlbWVudDxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGFyZ3M/OiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcclxuICAgIGNvbnN0IHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfSA9IChhcmdzID8/IHt9KTtcclxuXHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VSZWZFbGVtZW50XCIsIG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50KTtcclxuXHJcbiAgICAvLyBDYWxsZWQgKGluZGlyZWN0bHkpIGJ5IHRoZSByZWYgdGhhdCB0aGUgZWxlbWVudCByZWNlaXZlcy5cclxuICAgIGNvbnN0IGhhbmRsZXIgPSB1c2VDYWxsYmFjazxPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbD4+KChlLCBwcmV2VmFsdWUpID0+IHtcclxuICAgICAgICBjb25zdCBjbGVhbnVwID0gb25FbGVtZW50Q2hhbmdlPy4oZSwgcHJldlZhbHVlKTtcclxuICAgICAgICBpZiAocHJldlZhbHVlKVxyXG4gICAgICAgICAgICBvblVubW91bnQ/LihwcmV2VmFsdWUhKTtcclxuXHJcbiAgICAgICAgaWYgKGUpXHJcbiAgICAgICAgICAgIG9uTW91bnQ/LihlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNsZWFudXA7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gTGV0IHVzIHN0b3JlIHRoZSBhY3R1YWwgKHJlZmVyZW5jZSB0bykgdGhlIGVsZW1lbnQgd2UgY2FwdHVyZVxyXG4gICAgY29uc3QgW2dldEVsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPFQgfCBudWxsPihoYW5kbGVyLCByZXR1cm5OdWxsKTtcclxuICAgIGNvbnN0IHVzZVJlZkVsZW1lbnRQcm9wcyA9IHVzZUNhbGxiYWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+W1widXNlUmVmRWxlbWVudFByb3BzXCJdPigocHJvcHMpID0+IHVzZU1lcmdlZFByb3BzPFQ+KHsgcmVmOiBzZXRFbGVtZW50IH0sIHByb3BzKSwgW10pO1xyXG5cclxuICAgIC8vIFJldHVybiBib3RoIHRoZSBlbGVtZW50IGFuZCB0aGUgaG9vayB0aGF0IG1vZGlmaWVzIFxyXG4gICAgLy8gdGhlIHByb3BzIGFuZCBhbGxvd3MgdXMgdG8gYWN0dWFsbHkgZmluZCB0aGUgZWxlbWVudFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VSZWZFbGVtZW50UHJvcHMsXHJcbiAgICAgICAgZ2V0RWxlbWVudFxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGgsIFByZWFjdERPTUF0dHJpYnV0ZXMgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHVzZWQgdG8gc2VsZWN0ICpqdXN0KiB0aGUgdHlwZWQgYWRkRXZlbnRMaXN0ZW5lciBcclxuICogYW5kIG5vdCB0aGUgZ2VuZXJpYyBcIkknbGwgYWNjZXB0IGFueSBzdHJpbmcgYW5kIGFueSBoYW5kbGVyXCIgb25lLlxyXG4gKiBcclxuICogVE9ETzogVGhpcyBcIlwiXCJ3b3Jrc1wiXCJcIiBidXQgaXQncyBub3QgZ3JlYXQgYW5kIGltcGxpY2l0bHkgcmVsaWVzIG9uXHJcbiAqIGxpYi5kb20udHMgYWx3YXlzIGdpdmVpbmcgdGhlIHR3byBvdmVybG9hZHMgaW4gdGhlIHNhbWUgb3JkZXIsIHdpdGggdGhlXHJcbiAqIHR5cGVkIG9uZSBmaXJzdC4gKlRoYXQqIHByb2JhYmx5IHdvbid0IGNoYW5nZSwgYnV0IGlmIG1vcmUgb3ZlcmxvYWRzXHJcbiAqIGFyZSBldmVyIGFkZGVkIHRoaXMgd2lsbCBuZWVkIGFkanVzdG1lbnQuXHJcbiAqIFxyXG4gKiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUyNzYxMTU2IGZvciBob3cgc2VsZWN0aW5nIHRoZSBjb3JyZWN0IG92ZXJsb2FkIHdvcmtzLlxyXG4gKi9cclxudHlwZSBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczxUPiA9XHJcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGluZmVyIFIgfSA/IFIgOlxyXG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55IH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxyXG4gICAgVCBleHRlbmRzICguLi5hcmdzOiBpbmZlciBSKSA9PiBhbnkgPyBSIDogW107XHJcblxyXG4vLyBHZXQganVzdCB0aGUgdHlwZWQgdmVyc2lvbiBvZiBhZGRFdmVudExpc3RlbmVyLCBpZiBpdCBleGlzdHNcclxudHlwZSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9ICguLi5hcmdzOiBGaXJzdE92ZXJsb2FkUGFyYW1ldGVyczwoVFtcImFkZEV2ZW50TGlzdGVuZXJcIl0pPikgPT4gdm9pZDtcclxuXHJcbi8vIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIFwiYWRkRXZlbnRMaXN0ZW5lclwiICh0aGUgZXZlbnQgdHlwZSBhcyBhIHN0cmluZylcclxudHlwZSBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+IGV4dGVuZHMgKCh0eXBlOiBpbmZlciBLMiwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBLMiA6IHN0cmluZztcclxuXHJcblxyXG4vLyBUT0RPOiBUaGlzIGlzbid0IHF1aXRlIGFibGUgdG8gbmFycm93IGRvd24gdGhlIGV4YWN0IGV2ZW50IHR5cGUgZm9yIHVua25vd24gcmVhc29ucy5cclxuLy8gSW5zdGVhZCBpdCByZXR1cm5zIGEgdW5pb24gb2YgYWxsIGF2YWlsYWJsZSBldmVudCB0eXBlcywgd2hpY2ggaXMuLi5maW5lLCBJIGd1ZXNzLlxyXG4vLyBJIGRvbid0IGtub3cgd2h5IGBpbmZlciBIYCBpcyBkb2luZyB0aGF0IHdoZW4gdGhlIHR5cGUgc2hvdWxkIGJlIG5hcnJvd2VkIGJ5IGBUYCB0aG91Z2guLi5cclxuLy8gTm90ZSB0aGF0IHRoZSB0eXBlIHBhcmFtZXRlciBpcyBzdGlsbCB1c2VkLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IG5hcnJvdyBkb3duIHRoZSB0eXBlLFxyXG4vLyBiZWNhdXNlIG90aGVyd2lzZSwgaW5zdGVhZCBvZiBiZWluZyBhIHVuaW9uIG9mIGFsbCB0eXBlcywgaXQncyBqdXN0IGBhbnlgXHJcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXI8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+IGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiBpbmZlciBILCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IE5vbk51bGxhYmxlPEg+IDogbmV2ZXI7XHJcbi8vKChUeXBlZEFkZEV2ZW50TGlzdGVuZXI8RT4gJiAoKHR5cGU6IFQsIGhhbmRsZXI6IChlOiBFdmVudCkgPT4gdm9pZCwgLi4uYXJnczogYW55W10pID0+IGFueSkpIGV4dGVuZHMgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogaW5mZXIgSCkgPT4gYW55LCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IEggOiBGdW5jdGlvbikgLyomIChUIGV4dGVuZHMga2V5b2YgR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwPyBHbG9iYWxFdmVudEhhbmRsZXJzRXZlbnRNYXBbVF0gOiAoZTogRXZlbnQpID0+IHZvaWQpKi87XHJcblxyXG50eXBlIFBhcmFtZXRlcnMyPFQgZXh0ZW5kcyAoRXZlbnRMaXN0ZW5lck9iamVjdCB8ICgoLi4uYXJnczogYW55KSA9PiBhbnkpKT4gPVxyXG4gICAgVCBleHRlbmRzIEV2ZW50TGlzdGVuZXJPYmplY3QgPyBQYXJhbWV0ZXJzPFRbXCJoYW5kbGVFdmVudFwiXT4gOlxyXG4gICAgVCBleHRlbmRzICguLi5hcmdzOiBpbmZlciBQKSA9PiBhbnkgPyBQIDogbmV2ZXI7XHJcblxyXG5cclxudHlwZSBUeXBlZEV2ZW50SGFuZGxlckV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVCBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPEU+PiA9IFBhcmFtZXRlcnMyPFR5cGVkRXZlbnRIYW5kbGVyPEUsIFQ+PlswXTtcclxuXHJcblxyXG4vKipcclxuICogQWxsb3dzIGF0dGFjaGluZyBhbiBldmVudCBoYW5kbGVyIHRvIGFueSAqbm9uLVByZWFjdCogZWxlbWVudCwgYW5kIHJlbW92aW5nIGl0IHdoZW4gdGhlIGNvbXBvbmVudCB1c2luZyB0aGUgaG9vayB1bm1vdW50cy4gVGhlIGNhbGxiYWNrIGRvZXMgbm90IG5lZWQgdG8gYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxyXG4gKiBcclxuICogRHVlIHRvIHR5cGluZyBsaW1pdGF0aW9ucywgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBsaWtlIHRoaXM6XHJcbiAqIFxyXG4gKiBgdXNlRXZlbnRIYW5kbGVyKGVsZW1lbnQsIFwiaW5wdXRcIik8SW5wdXRFdmVudD4oZSA9PiB7fSlgXHJcbiAqIFxyXG4gKiBUaGUgdHlwZSBhcmd1bWVudCBpcyBvcHRpb25hbCwgYnV0IG5hcnJvd3MgZG93biB0aGUgdHlwZSBmcm9tIFwiYSB1bmlvbiBvZiBhbGwgZXZlbnRzXCIgdG8gd2hhdGV2ZXIgeW91IHNwZWNpZnksIGFuZCBlcnJvcnMgaWYgaXQgZG9lc24ndCBleGlzdC5cclxuICogXHJcbiAqIFRoZXJlIGlzIGEgc2VwYXJhdGUgdmVyc2lvbiB0aGF0IGF0dGFjaGVzIGV2ZW50IGhhbmRsZXJzIHRvIGEgc2V0IG9mIHByb3BzLiBcclxuICogSXQgdGFrZXMgZGlmZmVyZW50IGV2ZW50IHN0cmluZyB0eXBlcyAob25FdmVudCB2cyBvbmV2ZW50KS5cclxuICogXHJcbiAqIEBwYXJhbSB0YXJnZXQgQSAqbm9uLVByZWFjdCogbm9kZSB0byBhdHRhY2ggdGhlIGV2ZW50IHRvLlxyXG4gKiBAcmV0dXJuc1xyXG4gKiAqXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlR2xvYmFsSGFuZGxlcjxUIGV4dGVuZHMgRXZlbnRUYXJnZXQsIEV2ZW50VHlwZSBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQ+LCBIIGV4dGVuZHMgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxULCBFdmVudFR5cGU+Pih0YXJnZXQ6IFQsIHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogbnVsbCB8ICgoZTogSCkgPT4gdm9pZCksIG9wdGlvbnM/OiBQYXJhbWV0ZXJzPFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPj5bMl0pOiB2b2lkIHtcclxuXHJcbiAgICAvLyBOb3RlIHRvIHNlbGY6IFRoZSB0eXBpbmcgZG9lc24ndCBpbXByb3ZlIGV2ZW4gaWYgdGhpcyBpcyBzcGxpdCB1cCBpbnRvIGEgc3ViLWZ1bmN0aW9uLlxyXG4gICAgLy8gTm8gbWF0dGVyIHdoYXQsIGl0IHNlZW1zIGltcG9zc2libGUgdG8gZ2V0IHRoZSBoYW5kbGVyJ3MgZXZlbnQgb2JqZWN0IHR5cGVkIHBlcmZlY3RseS5cclxuICAgIC8vIEl0IHNlZW1zIGxpa2UgaXQncyBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgdHVwZXMuXHJcbiAgICAvLyBBZ2Fpbiwgbm8gbWF0dGVyIHdoYXQgY29tYmluYXRpb24gb2Ygc3ViLSBvciBzdWItc3ViLWZ1bmN0aW9ucyB1c2VkLlxyXG5cclxuICAgIGxldCBzdGFibGVIYW5kbGVyOiBFdmVudExpc3RlbmVyIHwgbnVsbCA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIgPz8gKCgpID0+IHsgfSkpIGFzIEV2ZW50TGlzdGVuZXI7XHJcbiAgICBpZiAoaGFuZGxlciA9PSBudWxsKVxyXG4gICAgICAgIHN0YWJsZUhhbmRsZXIgPSBudWxsO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YWJsZUhhbmRsZXIpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgc3RhYmxlSGFuZGxlciwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3RhcmdldCwgdHlwZSwgc3RhYmxlSGFuZGxlcl0pO1xyXG59XHJcblxyXG4vKipcclxuICogQW4gYWx0ZXJuYXRpdmUgd2F5IHRvIGFkZCBhbiBldmVudCBoYW5kbGVyIHRvIGFuIGVsZW1lbnQuIFVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpbnRlZ3JhdGluZyAzcmQgcGFydHkgbGlicmFyaWVzIHRoYXQgZXhwZWN0IGEgZ2VuZXJpYyBcImFkZCBldmVudCBoYW5kbGVyXCIgZnVuY3Rpb24uXHJcbiAqIFxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgeW91IHRvIG1vZGlmeSBhIHNldCBvZiBwcm9wcyB0byBhcHBseSB0aGlzIGhhbmRsZXIuXHJcbiAqIFxyXG4gKiBGb3IgdHlwaW5nIHJlYXNvbnMsIHRoaXMgZnVuY3Rpb24gaXMgc3BsaXQgaW50byB0d28uICBVc2FnZSBpcyBsaWtlIHRoZSBmb2xsb3dpbmc6XHJcbiAqIFxyXG4gKiBgYGBcclxuICogY29uc3QgeyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH0gPSB1c2VMb2NhbEV2ZW50SGFuZGxlcjxIVE1MRGl2RWxlbWVudD4oKShcIm9uTW91c2VEb3duXCIsIGUgPT4geyAgfSk7XHJcbiAqIGNvbnN0IGRpdlByb3BzID0gdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyhwcm9wcyk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvY2FsSGFuZGxlcjxFbGVtZW50VHlwZSBleHRlbmRzIChIVE1MRWxlbWVudFRhZ05hbWVNYXBba2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwXSB8IFNWR0VsZW1lbnRUYWdOYW1lTWFwW2tleW9mIFNWR0VsZW1lbnRUYWdOYW1lTWFwXSk+KCkge1xyXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKDxFdmVudFR5cGUgZXh0ZW5kcyBFeGNsdWRlPGtleW9mIGguSlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+LCBrZXlvZiBQcmVhY3RET01BdHRyaWJ1dGVzPj4odHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBOb25OdWxsYWJsZTxoLkpTWC5ET01BdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPltFdmVudFR5cGVdPikgPT4ge1xyXG5cclxuICAgICAgICBjb25zdCBzdGFibGVIYW5kbGVyID0gdXNlU3RhYmxlQ2FsbGJhY2soaGFuZGxlcik7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RWxlbWVudFR5cGU+KHsgW3R5cGVdOiBzdGFibGVIYW5kbGVyIH0gYXMgeyBbSyBpbiBFdmVudFR5cGVdOiB0eXBlb2YgaGFuZGxlciB9LCBwcm9wcykgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+O1xyXG4gICAgICAgIH0sIFt0eXBlXSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgfTtcclxuXHJcbiAgICB9LCBbXSk7XHJcbn1cclxuIiwiY29uc3QgY2FuZGlkYXRlU2VsZWN0b3JzID0gW1xuICAnaW5wdXQnLFxuICAnc2VsZWN0JyxcbiAgJ3RleHRhcmVhJyxcbiAgJ2FbaHJlZl0nLFxuICAnYnV0dG9uJyxcbiAgJ1t0YWJpbmRleF06bm90KHNsb3QpJyxcbiAgJ2F1ZGlvW2NvbnRyb2xzXScsXG4gICd2aWRlb1tjb250cm9sc10nLFxuICAnW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSknLFxuICAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnLFxuICAnZGV0YWlscycsXG5dO1xuY29uc3QgY2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi8gY2FuZGlkYXRlU2VsZWN0b3JzLmpvaW4oJywnKTtcblxuY29uc3QgTm9FbGVtZW50ID0gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnO1xuXG5jb25zdCBtYXRjaGVzID0gTm9FbGVtZW50XG4gID8gZnVuY3Rpb24gKCkge31cbiAgOiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cbmNvbnN0IGdldFJvb3ROb2RlID1cbiAgIU5vRWxlbWVudCAmJiBFbGVtZW50LnByb3RvdHlwZS5nZXRSb290Tm9kZVxuICAgID8gKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKVxuICAgIDogKGVsZW1lbnQpID0+IGVsZW1lbnQub3duZXJEb2N1bWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIGNvbnRhaW5lciB0byBjaGVjayBpblxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgdG8gY2hlY2tcbiAqIEBwYXJhbSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xuICogQHJldHVybnMge0VsZW1lbnRbXX1cbiAqL1xuY29uc3QgZ2V0Q2FuZGlkYXRlcyA9IGZ1bmN0aW9uIChlbCwgaW5jbHVkZUNvbnRhaW5lciwgZmlsdGVyKSB7XG4gIGxldCBjYW5kaWRhdGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KFxuICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2FuZGlkYXRlU2VsZWN0b3IpXG4gICk7XG4gIGlmIChpbmNsdWRlQ29udGFpbmVyICYmIG1hdGNoZXMuY2FsbChlbCwgY2FuZGlkYXRlU2VsZWN0b3IpKSB7XG4gICAgY2FuZGlkYXRlcy51bnNoaWZ0KGVsKTtcbiAgfVxuICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5maWx0ZXIoZmlsdGVyKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBHZXRTaGFkb3dSb290XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdG8gY2hlY2sgZm9yIHNoYWRvdyByb290XG4gKiBAcmV0dXJucyB7U2hhZG93Um9vdHxib29sZWFufSBTaGFkb3dSb290IGlmIGF2YWlsYWJsZSBvciBib29sZWFuIGluZGljYXRpbmcgaWYgYSBzaGFkb3dSb290IGlzIGF0dGFjaGVkIGJ1dCBub3QgYXZhaWxhYmxlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFNoYWRvd1Jvb3RGaWx0ZXJcbiAqIEBwYXJhbSB7RWxlbWVudH0gc2hhZG93SG9zdE5vZGUgdGhlIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgc2hhZG93IGNvbnRlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGEgc2hhZG93IHJvb3QgY291bGQgcG90ZW50aWFsbHkgY29udGFpbiB2YWxpZCBjYW5kaWRhdGVzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2FuZGlkYXRlc1Njb3BlXG4gKiBAcHJvcGVydHkge0VsZW1lbnR9IHNjb3BlIGNvbnRhaW5zIGlubmVyIGNhbmRpZGF0ZXNcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudFtdfSBjYW5kaWRhdGVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJdGVyYXRpdmVPcHRpb25zXG4gKiBAcHJvcGVydHkge0dldFNoYWRvd1Jvb3R8Ym9vbGVhbn0gZ2V0U2hhZG93Um9vdCB0cnVlIGlmIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQ7IGZhbHN5IGlmIG5vdDtcbiAqICBpZiBhIGZ1bmN0aW9uLCBpbXBsaWVzIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQgYW5kIGVpdGhlciByZXR1cm5zIHRoZSBzaGFkb3cgcm9vdCBvZiBhbiBlbGVtZW50XG4gKiAgb3IgYSBib29sZWFuIHN0YXRpbmcgaWYgaXQgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyByb290XG4gKiBAcHJvcGVydHkgeyhub2RlOiBFbGVtZW50KSA9PiBib29sZWFufSBmaWx0ZXIgZmlsdGVyIGNhbmRpZGF0ZXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmxhdHRlbiBpZiB0cnVlIHRoZW4gcmVzdWx0IHdpbGwgZmxhdHRlbiBhbnkgQ2FuZGlkYXRlc1Njb3BlIGludG8gdGhlIHJldHVybmVkIGxpc3RcbiAqIEBwcm9wZXJ0eSB7U2hhZG93Um9vdEZpbHRlcn0gc2hhZG93Um9vdEZpbHRlciBmaWx0ZXIgc2hhZG93IHJvb3RzO1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50W119IGVsZW1lbnRzIGxpc3Qgb2YgZWxlbWVudCBjb250YWluZXJzIHRvIG1hdGNoIGNhbmRpZGF0ZXMgZnJvbVxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgbGlzdCB0byBjaGVja1xuICogQHBhcmFtIHtJdGVyYXRpdmVPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlc1Njb3BlPn1cbiAqL1xuY29uc3QgZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5ID0gZnVuY3Rpb24gKFxuICBlbGVtZW50cyxcbiAgaW5jbHVkZUNvbnRhaW5lcixcbiAgb3B0aW9uc1xuKSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbXTtcbiAgY29uc3QgZWxlbWVudHNUb0NoZWNrID0gQXJyYXkuZnJvbShlbGVtZW50cyk7XG4gIHdoaWxlIChlbGVtZW50c1RvQ2hlY2subGVuZ3RoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzVG9DaGVjay5zaGlmdCgpO1xuICAgIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdTTE9UJykge1xuICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2xvdCBzY29wZSAoc2xvdCBpdHNlbGYgY2Fubm90IGJlIGZvY3VzYWJsZSlcbiAgICAgIGNvbnN0IGFzc2lnbmVkID0gZWxlbWVudC5hc3NpZ25lZEVsZW1lbnRzKCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gYXNzaWduZWQubGVuZ3RoID8gYXNzaWduZWQgOiBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgY29uc3QgbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShjb250ZW50LCB0cnVlLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKC4uLm5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBzY29wZTogZWxlbWVudCxcbiAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2hlY2sgY2FuZGlkYXRlIGVsZW1lbnRcbiAgICAgIGNvbnN0IHZhbGlkQ2FuZGlkYXRlID0gbWF0Y2hlcy5jYWxsKGVsZW1lbnQsIGNhbmRpZGF0ZVNlbGVjdG9yKTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsaWRDYW5kaWRhdGUgJiZcbiAgICAgICAgb3B0aW9ucy5maWx0ZXIoZWxlbWVudCkgJiZcbiAgICAgICAgKGluY2x1ZGVDb250YWluZXIgfHwgIWVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKVxuICAgICAgKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gaXRlcmF0ZSBvdmVyIHNoYWRvdyBjb250ZW50IGlmIHBvc3NpYmxlXG4gICAgICBjb25zdCBzaGFkb3dSb290ID1cbiAgICAgICAgZWxlbWVudC5zaGFkb3dSb290IHx8XG4gICAgICAgIC8vIGNoZWNrIGZvciBhbiB1bmRpc2Nsb3NlZCBzaGFkb3dcbiAgICAgICAgKHR5cGVvZiBvcHRpb25zLmdldFNoYWRvd1Jvb3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICBvcHRpb25zLmdldFNoYWRvd1Jvb3QoZWxlbWVudCkpO1xuXG4gICAgICBjb25zdCB2YWxpZFNoYWRvd1Jvb3QgPVxuICAgICAgICAhb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyIHx8IG9wdGlvbnMuc2hhZG93Um9vdEZpbHRlcihlbGVtZW50KTtcblxuICAgICAgaWYgKHNoYWRvd1Jvb3QgJiYgdmFsaWRTaGFkb3dSb290KSB7XG4gICAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNjb3BlIElJRiBhIHNoYWRvdyByb290IG5vZGUgd2FzIGdpdmVuOyBvdGhlcndpc2UsIGFuIHVuZGlzY2xvc2VkXG4gICAgICAgIC8vICBzaGFkb3cgZXhpc3RzLCBzbyBsb29rIGF0IGxpZ2h0IGRvbSBjaGlsZHJlbiBhcyBmYWxsYmFjayBCVVQgY3JlYXRlIGEgc2NvcGUgZm9yIGFueVxuICAgICAgICAvLyAgY2hpbGQgY2FuZGlkYXRlcyBmb3VuZCBiZWNhdXNlIHRoZXkncmUgbGlrZWx5IHNsb3R0ZWQgZWxlbWVudHMgKGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgICAgIC8vICBjaGlsZHJlbiBvZiB0aGUgd2ViIGNvbXBvbmVudCBlbGVtZW50ICh3aGljaCBoYXMgdGhlIHNoYWRvdyksIGluIHRoZSBsaWdodCBkb20sIGJ1dFxuICAgICAgICAvLyAgc2xvdHRlZCBzb21ld2hlcmUgX2luc2lkZV8gdGhlIHVuZGlzY2xvc2VkIHNoYWRvdykgLS0gdGhlIHNjb3BlIGlzIGNyZWF0ZWQgYmVsb3csXG4gICAgICAgIC8vICBfYWZ0ZXJfIHdlIHJldHVybiBmcm9tIHRoaXMgcmVjdXJzaXZlIGNhbGxcbiAgICAgICAgY29uc3QgbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShcbiAgICAgICAgICBzaGFkb3dSb290ID09PSB0cnVlID8gZWxlbWVudC5jaGlsZHJlbiA6IHNoYWRvd1Jvb3QuY2hpbGRyZW4sXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5uZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgICAgc2NvcGU6IGVsZW1lbnQsXG4gICAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVyZSdzIG5vdCBzaGFkb3cgc28ganVzdCBkaWcgaW50byB0aGUgZWxlbWVudCdzIChsaWdodCBkb20pIGNoaWxkcmVuXG4gICAgICAgIC8vICBfX3dpdGhvdXRfXyBnaXZpbmcgdGhlIGVsZW1lbnQgc3BlY2lhbCBzY29wZSB0cmVhdG1lbnRcbiAgICAgICAgZWxlbWVudHNUb0NoZWNrLnVuc2hpZnQoLi4uZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuY29uc3QgZ2V0VGFiaW5kZXggPSBmdW5jdGlvbiAobm9kZSwgaXNTY29wZSkge1xuICBpZiAobm9kZS50YWJJbmRleCA8IDApIHtcbiAgICAvLyBpbiBDaHJvbWUsIDxkZXRhaWxzLz4sIDxhdWRpbyBjb250cm9scy8+IGFuZCA8dmlkZW8gY29udHJvbHMvPiBlbGVtZW50cyBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAtMSB3aGVuIHRoZSAndGFiaW5kZXgnIGF0dHJpYnV0ZSBpc24ndCBzcGVjaWZpZWQgaW4gdGhlIERPTSxcbiAgICAvLyB5ZXQgdGhleSBhcmUgc3RpbGwgcGFydCBvZiB0aGUgcmVndWxhciB0YWIgb3JkZXI7IGluIEZGLCB0aGV5IGdldCBhIGRlZmF1bHRcbiAgICAvLyBgdGFiSW5kZXhgIG9mIDA7IHNpbmNlIENocm9tZSBzdGlsbCBwdXRzIHRob3NlIGVsZW1lbnRzIGluIHRoZSByZWd1bGFyIHRhYlxuICAgIC8vIG9yZGVyLCBjb25zaWRlciB0aGVpciB0YWIgaW5kZXggdG8gYmUgMC5cbiAgICAvLyBBbHNvIGJyb3dzZXJzIGRvIG5vdCByZXR1cm4gYHRhYkluZGV4YCBjb3JyZWN0bHkgZm9yIGNvbnRlbnRFZGl0YWJsZSBub2RlcztcbiAgICAvLyBzbyBpZiB0aGV5IGRvbid0IGhhdmUgYSB0YWJpbmRleCBhdHRyaWJ1dGUgc3BlY2lmaWNhbGx5IHNldCwgYXNzdW1lIGl0J3MgMC5cbiAgICAvL1xuICAgIC8vIGlzU2NvcGUgaXMgcG9zaXRpdmUgZm9yIGN1c3RvbSBlbGVtZW50IHdpdGggc2hhZG93IHJvb3Qgb3Igc2xvdCB0aGF0IGJ5IGRlZmF1bHRcbiAgICAvLyBoYXZlIHRhYkluZGV4IC0xLCBidXQgbmVlZCB0byBiZSBzb3J0ZWQgYnkgZG9jdW1lbnQgb3JkZXIgaW4gb3JkZXIgZm9yIHRoZWlyXG4gICAgLy8gY29udGVudCB0byBiZSBpbnNlcnRlZCBpbiB0aGUgY29ycmVjdCBwb3NpdGlvblxuICAgIGlmIChcbiAgICAgIChpc1Njb3BlIHx8XG4gICAgICAgIC9eKEFVRElPfFZJREVPfERFVEFJTFMpJC8udGVzdChub2RlLnRhZ05hbWUpIHx8XG4gICAgICAgIG5vZGUuaXNDb250ZW50RWRpdGFibGUpICYmXG4gICAgICBpc05hTihwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApKVxuICAgICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGUudGFiSW5kZXg7XG59O1xuXG5jb25zdCBzb3J0T3JkZXJlZFRhYmJhYmxlcyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBhLnRhYkluZGV4ID09PSBiLnRhYkluZGV4XG4gICAgPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXJcbiAgICA6IGEudGFiSW5kZXggLSBiLnRhYkluZGV4O1xufTtcblxuY29uc3QgaXNJbnB1dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdJTlBVVCc7XG59O1xuXG5jb25zdCBpc0hpZGRlbklucHV0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAnaGlkZGVuJztcbn07XG5cbmNvbnN0IGlzRGV0YWlsc1dpdGhTdW1tYXJ5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgY29uc3QgciA9XG4gICAgbm9kZS50YWdOYW1lID09PSAnREVUQUlMUycgJiZcbiAgICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgIC5hcHBseShub2RlLmNoaWxkcmVuKVxuICAgICAgLnNvbWUoKGNoaWxkKSA9PiBjaGlsZC50YWdOYW1lID09PSAnU1VNTUFSWScpO1xuICByZXR1cm4gcjtcbn07XG5cbmNvbnN0IGdldENoZWNrZWRSYWRpbyA9IGZ1bmN0aW9uIChub2RlcywgZm9ybSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldLmNoZWNrZWQgJiYgbm9kZXNbaV0uZm9ybSA9PT0gZm9ybSkge1xuICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgaXNUYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKCFub2RlLm5hbWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCByYWRpb1Njb3BlID0gbm9kZS5mb3JtIHx8IGdldFJvb3ROb2RlKG5vZGUpO1xuICBjb25zdCBxdWVyeVJhZGlvcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHJhZGlvU2NvcGUucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBuYW1lICsgJ1wiXSdcbiAgICApO1xuICB9O1xuXG4gIGxldCByYWRpb1NldDtcbiAgaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5DU1MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJhZGlvU2V0ID0gcXVlcnlSYWRpb3Mod2luZG93LkNTUy5lc2NhcGUobm9kZS5uYW1lKSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHJhZGlvU2V0ID0gcXVlcnlSYWRpb3Mobm9kZS5uYW1lKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnTG9va3MgbGlrZSB5b3UgaGF2ZSBhIHJhZGlvIGJ1dHRvbiB3aXRoIGEgbmFtZSBhdHRyaWJ1dGUgY29udGFpbmluZyBpbnZhbGlkIENTUyBzZWxlY3RvciBjaGFyYWN0ZXJzIGFuZCBuZWVkIHRoZSBDU1MuZXNjYXBlIHBvbHlmaWxsOiAlcycsXG4gICAgICAgIGVyci5tZXNzYWdlXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNoZWNrZWQgPSBnZXRDaGVja2VkUmFkaW8ocmFkaW9TZXQsIG5vZGUuZm9ybSk7XG4gIHJldHVybiAhY2hlY2tlZCB8fCBjaGVja2VkID09PSBub2RlO1xufTtcblxuY29uc3QgaXNSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ3JhZGlvJztcbn07XG5cbmNvbnN0IGlzTm9uVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc1JhZGlvKG5vZGUpICYmICFpc1RhYmJhYmxlUmFkaW8obm9kZSk7XG59O1xuXG4vLyBkZXRlcm1pbmVzIGlmIGEgbm9kZSBpcyB1bHRpbWF0ZWx5IGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cncyBkb2N1bWVudFxuY29uc3QgaXNOb2RlQXR0YWNoZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAvLyBUaGUgcm9vdCBub2RlIGlzIHRoZSBzaGFkb3cgcm9vdCBpZiB0aGUgbm9kZSBpcyBpbiBhIHNoYWRvdyBET007IHNvbWUgZG9jdW1lbnQgb3RoZXJ3aXNlXG4gIC8vICAoYnV0IE5PVCBfdGhlXyBkb2N1bWVudDsgc2VlIHNlY29uZCAnSWYnIGNvbW1lbnQgYmVsb3cgZm9yIG1vcmUpLlxuICAvLyBJZiByb290Tm9kZSBpcyBzaGFkb3cgcm9vdCwgaXQnbGwgaGF2ZSBhIGhvc3QsIHdoaWNoIGlzIHRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBzaGFkb3dcbiAgLy8gIGlzIGF0dGFjaGVkLCBhbmQgdGhlIG9uZSB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgaW4gdGhlIGRvY3VtZW50IG9yIG5vdCAoYmVjYXVzZSB0aGVcbiAgLy8gIHNoYWRvdywgYW5kIGFsbCBub2RlcyBpdCBjb250YWlucywgaXMgbmV2ZXIgY29uc2lkZXJlZCBpbiB0aGUgZG9jdW1lbnQgc2luY2Ugc2hhZG93c1xuICAvLyAgYmVoYXZlIGxpa2Ugc2VsZi1jb250YWluZWQgRE9NczsgYnV0IGlmIHRoZSBzaGFkb3cncyBIT1NULCB3aGljaCBpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudCxcbiAgLy8gIGlzIGhpZGRlbiwgb3IgaXMgbm90IGluIHRoZSBkb2N1bWVudCBpdHNlbGYgYnV0IGlzIGRldGFjaGVkLCBpdCB3aWxsIGFmZmVjdCB0aGUgc2hhZG93J3NcbiAgLy8gIHZpc2liaWxpdHksIGluY2x1ZGluZyBhbGwgdGhlIG5vZGVzIGl0IGNvbnRhaW5zKS4gVGhlIGhvc3QgY291bGQgYmUgYW55IG5vcm1hbCBub2RlLFxuICAvLyAgb3IgYSBjdXN0b20gZWxlbWVudCAoaS5lLiB3ZWIgY29tcG9uZW50KS4gRWl0aGVyIHdheSwgdGhhdCdzIHRoZSBvbmUgdGhhdCBpcyBjb25zaWRlcmVkXG4gIC8vICBwYXJ0IG9mIHRoZSBkb2N1bWVudCwgbm90IHRoZSBzaGFkb3cgcm9vdCwgbm9yIGFueSBvZiBpdHMgY2hpbGRyZW4gKGkuZS4gdGhlIG5vZGUgYmVpbmdcbiAgLy8gIHRlc3RlZCkuXG4gIC8vIFRvIGZ1cnRoZXIgY29tcGxpY2F0ZSB0aGluZ3MsIHdlIGhhdmUgdG8gbG9vayBhbGwgdGhlIHdheSB1cCB1bnRpbCB3ZSBmaW5kIGEgc2hhZG93IEhPU1RcbiAgLy8gIHRoYXQgaXMgYXR0YWNoZWQgKG9yIGZpbmQgbm9uZSkgYmVjYXVzZSB0aGUgbm9kZSBtaWdodCBiZSBpbiBuZXN0ZWQgc2hhZG93cy4uLlxuICAvLyBJZiByb290Tm9kZSBpcyBub3QgYSBzaGFkb3cgcm9vdCwgaXQgd29uJ3QgaGF2ZSBhIGhvc3QsIGFuZCBzbyByb290Tm9kZSBzaG91bGQgYmUgdGhlXG4gIC8vICBkb2N1bWVudCAocGVyIHRoZSBkb2NzKSBhbmQgd2hpbGUgaXQncyBhIERvY3VtZW50LXR5cGUgb2JqZWN0LCB0aGF0IGRvY3VtZW50IGRvZXMgbm90XG4gIC8vICBhcHBlYXIgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG5vZGUncyBgb3duZXJEb2N1bWVudGAgZm9yIHNvbWUgcmVhc29uLCBzbyBpdCdzIHNhZmVyXG4gIC8vICB0byBpZ25vcmUgdGhlIHJvb3ROb2RlIGF0IHRoaXMgcG9pbnQsIGFuZCB1c2UgYG5vZGUub3duZXJEb2N1bWVudGAuIE90aGVyd2lzZSxcbiAgLy8gIHVzaW5nIGByb290Tm9kZS5jb250YWlucyhub2RlKWAgd2lsbCBfYWx3YXlzXyBiZSB0cnVlIHdlJ2xsIGdldCBmYWxzZS1wb3NpdGl2ZXMgd2hlblxuICAvLyAgbm9kZSBpcyBhY3R1YWxseSBkZXRhY2hlZC5cbiAgbGV0IG5vZGVSb290SG9zdCA9IGdldFJvb3ROb2RlKG5vZGUpLmhvc3Q7XG4gIGxldCBhdHRhY2hlZCA9ICEhKFxuICAgIG5vZGVSb290SG9zdD8ub3duZXJEb2N1bWVudC5jb250YWlucyhub2RlUm9vdEhvc3QpIHx8XG4gICAgbm9kZS5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGUpXG4gICk7XG5cbiAgd2hpbGUgKCFhdHRhY2hlZCAmJiBub2RlUm9vdEhvc3QpIHtcbiAgICAvLyBzaW5jZSBpdCdzIG5vdCBhdHRhY2hlZCBhbmQgd2UgaGF2ZSBhIHJvb3QgaG9zdCwgdGhlIG5vZGUgTVVTVCBiZSBpbiBhIG5lc3RlZCBzaGFkb3cgRE9NLFxuICAgIC8vICB3aGljaCBtZWFucyB3ZSBuZWVkIHRvIGdldCB0aGUgaG9zdCdzIGhvc3QgYW5kIGNoZWNrIGlmIHRoYXQgcGFyZW50IGhvc3QgaXMgY29udGFpbmVkXG4gICAgLy8gIGluIChpLmUuIGF0dGFjaGVkIHRvKSB0aGUgZG9jdW1lbnRcbiAgICBub2RlUm9vdEhvc3QgPSBnZXRSb290Tm9kZShub2RlUm9vdEhvc3QpLmhvc3Q7XG4gICAgYXR0YWNoZWQgPSAhIW5vZGVSb290SG9zdD8ub3duZXJEb2N1bWVudC5jb250YWlucyhub2RlUm9vdEhvc3QpO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaGVkO1xufTtcblxuY29uc3QgaXNaZXJvQXJlYSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMDtcbn07XG5jb25zdCBpc0hpZGRlbiA9IGZ1bmN0aW9uIChub2RlLCB7IGRpc3BsYXlDaGVjaywgZ2V0U2hhZG93Um9vdCB9KSB7XG4gIC8vIE5PVEU6IHZpc2liaWxpdHkgd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBub2RlIGlzIGRldGFjaGVkIGZyb20gdGhlIGRvY3VtZW50XG4gIC8vICAoc2VlIG5vdGVzIGFib3V0IHRoaXMgZnVydGhlciBkb3duKSwgd2hpY2ggbWVhbnMgd2Ugd2lsbCBjb25zaWRlciBpdCB2aXNpYmxlXG4gIC8vICAodGhpcyBpcyBsZWdhY3kgYmVoYXZpb3IgZnJvbSBhIHZlcnkgbG9uZyB3YXkgYmFjaylcbiAgLy8gTk9URTogd2UgY2hlY2sgdGhpcyByZWdhcmRsZXNzIG9mIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIGJlY2F1c2UgdGhpcyBpcyBhXG4gIC8vICBfdmlzaWJpbGl0eV8gY2hlY2ssIG5vdCBhIF9kaXNwbGF5XyBjaGVja1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgaXNEaXJlY3RTdW1tYXJ5ID0gbWF0Y2hlcy5jYWxsKG5vZGUsICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScpO1xuICBjb25zdCBub2RlVW5kZXJEZXRhaWxzID0gaXNEaXJlY3RTdW1tYXJ5ID8gbm9kZS5wYXJlbnRFbGVtZW50IDogbm9kZTtcbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlVW5kZXJEZXRhaWxzLCAnZGV0YWlsczpub3QoW29wZW5dKSAqJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChcbiAgICAhZGlzcGxheUNoZWNrIHx8XG4gICAgZGlzcGxheUNoZWNrID09PSAnZnVsbCcgfHxcbiAgICBkaXNwbGF5Q2hlY2sgPT09ICdsZWdhY3ktZnVsbCdcbiAgKSB7XG4gICAgaWYgKHR5cGVvZiBnZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBmaWd1cmUgb3V0IGlmIHdlIHNob3VsZCBjb25zaWRlciB0aGUgbm9kZSB0byBiZSBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgYW5kIHVzZSB0aGVcbiAgICAgIC8vICAnbm9uLXplcm8tYXJlYScgZmFsbGJhY2tcbiAgICAgIGNvbnN0IG9yaWdpbmFsTm9kZSA9IG5vZGU7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICBjb25zdCByb290Tm9kZSA9IGdldFJvb3ROb2RlKG5vZGUpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcGFyZW50RWxlbWVudCAmJlxuICAgICAgICAgICFwYXJlbnRFbGVtZW50LnNoYWRvd1Jvb3QgJiZcbiAgICAgICAgICBnZXRTaGFkb3dSb290KHBhcmVudEVsZW1lbnQpID09PSB0cnVlIC8vIGNoZWNrIGlmIHRoZXJlJ3MgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5vZGUgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyB3aGljaCBtZWFucyB3ZSBjYW4gb25seSB0cmVhdCBpdCBhcyBhIGJsYWNrIGJveCwgc28gd2VcbiAgICAgICAgICAvLyAgZmFsbCBiYWNrIHRvIGEgbm9uLXplcm8tYXJlYSB0ZXN0XG4gICAgICAgICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIHNsb3RcbiAgICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmVudEVsZW1lbnQgJiYgcm9vdE5vZGUgIT09IG5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgIC8vIGNyb3NzIHNoYWRvdyBib3VuZGFyeVxuICAgICAgICAgIG5vZGUgPSByb290Tm9kZS5ob3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgbm9ybWFsIGRvbVxuICAgICAgICAgIG5vZGUgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBvcmlnaW5hbE5vZGU7XG4gICAgfVxuICAgIC8vIGVsc2UsIGBnZXRTaGFkb3dSb290YCBtaWdodCBiZSB0cnVlLCBidXQgYWxsIHRoYXQgZG9lcyBpcyBlbmFibGUgc2hhZG93IERPTSBzdXBwb3J0XG4gICAgLy8gIChpLmUuIGl0IGRvZXMgbm90IGFsc28gcHJlc3VtZSB0aGF0IGFsbCBub2RlcyBtaWdodCBoYXZlIHVuZGlzY2xvc2VkIHNoYWRvd3MpOyBvclxuICAgIC8vICBpdCBtaWdodCBiZSBhIGZhbHN5IHZhbHVlLCB3aGljaCBtZWFucyBzaGFkb3cgRE9NIHN1cHBvcnQgaXMgZGlzYWJsZWRcblxuICAgIC8vIFNpbmNlIHdlIGRpZG4ndCBmaW5kIGl0IHNpdHRpbmcgaW4gYW4gdW5kaXNjbG9zZWQgc2hhZG93IChvciBzaGFkb3dzIGFyZSBkaXNhYmxlZClcbiAgICAvLyAgbm93IHdlIGNhbiBqdXN0IHRlc3QgdG8gc2VlIGlmIGl0IHdvdWxkIG5vcm1hbGx5IGJlIHZpc2libGUgb3Igbm90LCBwcm92aWRlZCBpdCdzXG4gICAgLy8gIGF0dGFjaGVkIHRvIHRoZSBtYWluIGRvY3VtZW50LlxuICAgIC8vIE5PVEU6IFdlIG11c3QgY29uc2lkZXIgY2FzZSB3aGVyZSBub2RlIGlzIGluc2lkZSBhIHNoYWRvdyBET00gYW5kIGdpdmVuIGRpcmVjdGx5IHRvXG4gICAgLy8gIGBpc1RhYmJhYmxlKClgIG9yIGBpc0ZvY3VzYWJsZSgpYCAtLSByZWdhcmRsZXNzIG9mIGBnZXRTaGFkb3dSb290YCBvcHRpb24gc2V0dGluZy5cblxuICAgIGlmIChpc05vZGVBdHRhY2hlZChub2RlKSkge1xuICAgICAgLy8gdGhpcyB3b3JrcyB3aGVyZXZlciB0aGUgbm9kZSBpczogaWYgdGhlcmUncyBhdCBsZWFzdCBvbmUgY2xpZW50IHJlY3QsIGl0J3NcbiAgICAgIC8vICBzb21laG93IGRpc3BsYXllZDsgaXQgYWxzbyBjb3ZlcnMgdGhlIENTUyAnZGlzcGxheTogY29udGVudHMnIGNhc2Ugd2hlcmUgdGhlXG4gICAgICAvLyAgbm9kZSBpdHNlbGYgaXMgaGlkZGVuIGluIHBsYWNlIG9mIGl0cyBjb250ZW50czsgYW5kIHRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2hcbiAgICAgIC8vICB1cCB0aGUgaGllcmFyY2h5IGVpdGhlclxuICAgICAgcmV0dXJuICFub2RlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIEVsc2UsIHRoZSBub2RlIGlzbid0IGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhlIGBnZXRDbGllbnRSZWN0cygpYFxuICAgIC8vICBBUEkgd2lsbCBfX2Fsd2F5c19fIHJldHVybiB6ZXJvIHJlY3RzICh0aGlzIGNhbiBoYXBwZW4sIGZvciBleGFtcGxlLCBpZiBSZWFjdFxuICAgIC8vICBpcyB1c2VkIHRvIHJlbmRlciBub2RlcyBvbnRvIGEgZGV0YWNoZWQgdHJlZSwgYXMgY29uZmlybWVkIGluIHRoaXMgdGhyZWFkOlxuICAgIC8vICBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzkxMTcjaXNzdWVjb21tZW50LTI4NDIyODg3MClcbiAgICAvL1xuICAgIC8vIEl0IGFsc28gbWVhbnMgdGhhdCBldmVuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLmRpc3BsYXkgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAvLyAgYmVjYXVzZSBzdHlsZXMgYXJlIG9ubHkgY29tcHV0ZWQgZm9yIG5vZGVzIHRoYXQgYXJlIGluIHRoZSBkb2N1bWVudC5cbiAgICAvL1xuICAgIC8vIE5PVEU6IFRISVMgSEFTIEJFRU4gVEhFIENBU0UgRk9SIFlFQVJTLiBJdCBpcyBub3QgbmV3LCBub3IgaXMgaXQgY2F1c2VkIGJ5IHRhYmJhYmxlXG4gICAgLy8gIHNvbWVob3cuIFRob3VnaCBpdCB3YXMgbmV2ZXIgc3RhdGVkIG9mZmljaWFsbHksIGFueW9uZSB3aG8gaGFzIGV2ZXIgdXNlZCB0YWJiYWJsZVxuICAgIC8vICBBUElzIG9uIG5vZGVzIGluIGRldGFjaGVkIGNvbnRhaW5lcnMgaGFzIGFjdHVhbGx5IGltcGxpY2l0bHkgdXNlZCB0YWJiYWJsZSBpbiB3aGF0XG4gICAgLy8gIHdhcyBsYXRlciAoYXMgb2YgdjUuMi4wIG9uIEFwciA5LCAyMDIxKSBjYWxsZWQgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgbW9kZSAtLSBlc3NlbnRpYWxseVxuICAgIC8vICBjb25zaWRlcmluZyBfX2V2ZXJ5dGhpbmdfXyB0byBiZSB2aXNpYmxlIGJlY2F1c2Ugb2YgdGhlIGlubmFiaWxpdHkgdG8gZGV0ZXJtaW5lIHN0eWxlcy5cbiAgICAvL1xuICAgIC8vIHY2LjAuMDogQXMgb2YgdGhpcyBtYWpvciByZWxlYXNlLCB0aGUgZGVmYXVsdCAnZnVsbCcgb3B0aW9uIF9fbm8gbG9uZ2VyIHRyZWF0cyBkZXRhY2hlZFxuICAgIC8vICBub2RlcyBhcyB2aXNpYmxlIHdpdGggdGhlICdub25lJyBmYWxsYmFjay5fX1xuICAgIGlmIChkaXNwbGF5Q2hlY2sgIT09ICdsZWdhY3ktZnVsbCcpIHtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBoaWRkZW5cbiAgICB9XG4gICAgLy8gZWxzZSwgZmFsbGJhY2sgdG8gJ25vbmUnIG1vZGUgYW5kIGNvbnNpZGVyIHRoZSBub2RlIHZpc2libGVcbiAgfSBlbHNlIGlmIChkaXNwbGF5Q2hlY2sgPT09ICdub24temVyby1hcmVhJykge1xuICAgIC8vIE5PVEU6IEV2ZW4gdGhvdWdoIHRoaXMgdGVzdHMgdGhhdCB0aGUgbm9kZSdzIGNsaWVudCByZWN0IGlzIG5vbi16ZXJvIHRvIGRldGVybWluZVxuICAgIC8vICB3aGV0aGVyIGl0J3MgZGlzcGxheWVkLCBhbmQgdGhhdCBhIGRldGFjaGVkIG5vZGUgd2lsbCBfX2Fsd2F5c19fIGhhdmUgYSB6ZXJvLWFyZWFcbiAgICAvLyAgY2xpZW50IHJlY3QsIHdlIGRvbid0IHNwZWNpYWwtY2FzZSBmb3Igd2hldGhlciB0aGUgbm9kZSBpcyBhdHRhY2hlZCBvciBub3QuIEluXG4gICAgLy8gIHRoaXMgbW9kZSwgd2UgZG8gd2FudCB0byBjb25zaWRlciBub2RlcyB0aGF0IGhhdmUgYSB6ZXJvIGFyZWEgdG8gYmUgaGlkZGVuIGF0IGFsbFxuICAgIC8vICB0aW1lcywgYW5kIHRoYXQgaW5jbHVkZXMgYXR0YWNoZWQgb3Igbm90LlxuICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xuICB9XG5cbiAgLy8gdmlzaWJsZSwgYXMgZmFyIGFzIHdlIGNhbiB0ZWxsLCBvciBwZXIgY3VycmVudCBgZGlzcGxheUNoZWNrPW5vbmVgIG1vZGUsIHdlIGFzc3VtZVxuICAvLyAgaXQncyB2aXNpYmxlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIGZvcm0gZmllbGRzIChuZXN0ZWQpIGluc2lkZSBhIGRpc2FibGVkIGZpZWxkc2V0IGFyZSBub3QgZm9jdXNhYmxlL3RhYmJhYmxlXG4vLyAgdW5sZXNzIHRoZXkgYXJlIGluIHRoZSBfZmlyc3RfIDxsZWdlbmQ+IGVsZW1lbnQgb2YgdGhlIHRvcC1tb3N0IGRpc2FibGVkXG4vLyAgZmllbGRzZXRcbmNvbnN0IGlzRGlzYWJsZWRGcm9tRmllbGRzZXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoL14oSU5QVVR8QlVUVE9OfFNFTEVDVHxURVhUQVJFQSkkLy50ZXN0KG5vZGUudGFnTmFtZSkpIHtcbiAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAvLyBjaGVjayBpZiBgbm9kZWAgaXMgY29udGFpbmVkIGluIGEgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS50YWdOYW1lID09PSAnRklFTERTRVQnICYmIHBhcmVudE5vZGUuZGlzYWJsZWQpIHtcbiAgICAgICAgLy8gbG9vayBmb3IgdGhlIGZpcnN0IDxsZWdlbmQ+IGFtb25nIHRoZSBjaGlsZHJlbiBvZiB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHBhcmVudE5vZGUuY2hpbGRyZW4uaXRlbShpKTtcbiAgICAgICAgICAvLyB3aGVuIHRoZSBmaXJzdCA8bGVnZW5kPiAoaW4gZG9jdW1lbnQgb3JkZXIpIGlzIGZvdW5kXG4gICAgICAgICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09ICdMRUdFTkQnKSB7XG4gICAgICAgICAgICAvLyBpZiBpdHMgcGFyZW50IDxmaWVsZHNldD4gaXMgbm90IG5lc3RlZCBpbiBhbm90aGVyIGRpc2FibGVkIDxmaWVsZHNldD4sXG4gICAgICAgICAgICAvLyByZXR1cm4gd2hldGhlciBgbm9kZWAgaXMgYSBkZXNjZW5kYW50IG9mIGl0cyBmaXJzdCA8bGVnZW5kPlxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChwYXJlbnROb2RlLCAnZmllbGRzZXRbZGlzYWJsZWRdIConKVxuICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgOiAhY2hpbGQuY29udGFpbnMobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkaXNhYmxlZCA8ZmllbGRzZXQ+IGNvbnRhaW5pbmcgYG5vZGVgIGhhcyBubyA8bGVnZW5kPlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gZWxzZSwgbm9kZSdzIHRhYmJhYmxlL2ZvY3VzYWJsZSBzdGF0ZSBzaG91bGQgbm90IGJlIGFmZmVjdGVkIGJ5IGEgZmllbGRzZXQnc1xuICAvLyAgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIG5vZGUpIHtcbiAgaWYgKFxuICAgIG5vZGUuZGlzYWJsZWQgfHxcbiAgICBpc0hpZGRlbklucHV0KG5vZGUpIHx8XG4gICAgaXNIaWRkZW4obm9kZSwgb3B0aW9ucykgfHxcbiAgICAvLyBGb3IgYSBkZXRhaWxzIGVsZW1lbnQgd2l0aCBhIHN1bW1hcnksIHRoZSBzdW1tYXJ5IGVsZW1lbnQgZ2V0cyB0aGUgZm9jdXNcbiAgICBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB8fFxuICAgIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQobm9kZSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIG5vZGUpIHtcbiAgaWYgKFxuICAgIGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB8fFxuICAgIGdldFRhYmluZGV4KG5vZGUpIDwgMCB8fFxuICAgICFpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUgPSBmdW5jdGlvbiAoc2hhZG93SG9zdE5vZGUpIHtcbiAgY29uc3QgdGFiSW5kZXggPSBwYXJzZUludChzaGFkb3dIb3N0Tm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKTtcbiAgaWYgKGlzTmFOKHRhYkluZGV4KSB8fCB0YWJJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSWYgYSBjdXN0b20gZWxlbWVudCBoYXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgdGFiaW5kZXgsXG4gIC8vIGJyb3dzZXJzIHdpbGwgbm90IGFsbG93IHRhYiB0YXJnZXRpbmcgc2FpZCBlbGVtZW50J3MgY2hpbGRyZW4uXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48RWxlbWVudHxDYW5kaWRhdGVzU2NvcGU+fSBjYW5kaWRhdGVzXG4gKiBAcmV0dXJucyBFbGVtZW50W11cbiAqL1xuY29uc3Qgc29ydEJ5T3JkZXIgPSBmdW5jdGlvbiAoY2FuZGlkYXRlcykge1xuICBjb25zdCByZWd1bGFyVGFiYmFibGVzID0gW107XG4gIGNvbnN0IG9yZGVyZWRUYWJiYWJsZXMgPSBbXTtcbiAgY2FuZGlkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgY29uc3QgaXNTY29wZSA9ICEhaXRlbS5zY29wZTtcbiAgICBjb25zdCBlbGVtZW50ID0gaXNTY29wZSA/IGl0ZW0uc2NvcGUgOiBpdGVtO1xuICAgIGNvbnN0IGNhbmRpZGF0ZVRhYmluZGV4ID0gZ2V0VGFiaW5kZXgoZWxlbWVudCwgaXNTY29wZSk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBpc1Njb3BlID8gc29ydEJ5T3JkZXIoaXRlbS5jYW5kaWRhdGVzKSA6IGVsZW1lbnQ7XG4gICAgaWYgKGNhbmRpZGF0ZVRhYmluZGV4ID09PSAwKSB7XG4gICAgICBpc1Njb3BlXG4gICAgICAgID8gcmVndWxhclRhYmJhYmxlcy5wdXNoKC4uLmVsZW1lbnRzKVxuICAgICAgICA6IHJlZ3VsYXJUYWJiYWJsZXMucHVzaChlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgZG9jdW1lbnRPcmRlcjogaSxcbiAgICAgICAgdGFiSW5kZXg6IGNhbmRpZGF0ZVRhYmluZGV4LFxuICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICBpc1Njb3BlOiBpc1Njb3BlLFxuICAgICAgICBjb250ZW50OiBlbGVtZW50cyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG9yZGVyZWRUYWJiYWJsZXNcbiAgICAuc29ydChzb3J0T3JkZXJlZFRhYmJhYmxlcylcbiAgICAucmVkdWNlKChhY2MsIHNvcnRhYmxlKSA9PiB7XG4gICAgICBzb3J0YWJsZS5pc1Njb3BlXG4gICAgICAgID8gYWNjLnB1c2goLi4uc29ydGFibGUuY29udGVudClcbiAgICAgICAgOiBhY2MucHVzaChzb3J0YWJsZS5jb250ZW50KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pXG4gICAgLmNvbmNhdChyZWd1bGFyVGFiYmFibGVzKTtcbn07XG5cbmNvbnN0IHRhYmJhYmxlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCBjYW5kaWRhdGVzO1xuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShbZWxdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucyksXG4gICAgICBmbGF0dGVuOiBmYWxzZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcbiAgICAgIHNoYWRvd1Jvb3RGaWx0ZXI6IGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoXG4gICAgICBlbCxcbiAgICAgIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lcixcbiAgICAgIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc29ydEJ5T3JkZXIoY2FuZGlkYXRlcyk7XG59O1xuXG5jb25zdCBmb2N1c2FibGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgbGV0IGNhbmRpZGF0ZXM7XG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtlbF0sIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwge1xuICAgICAgZmlsdGVyOiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucyksXG4gICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgZ2V0U2hhZG93Um9vdDogb3B0aW9ucy5nZXRTaGFkb3dSb290LFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKFxuICAgICAgZWwsXG4gICAgICBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsXG4gICAgICBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucylcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG5jb25zdCBpc1RhYmJhYmxlID0gZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICB9XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgY2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlKG9wdGlvbnMsIG5vZGUpO1xufTtcblxuY29uc3QgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi8gY2FuZGlkYXRlU2VsZWN0b3JzXG4gIC5jb25jYXQoJ2lmcmFtZScpXG4gIC5qb2luKCcsJyk7XG5cbmNvbnN0IGlzRm9jdXNhYmxlID0gZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICB9XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmV4cG9ydCB7IHRhYmJhYmxlLCBmb2N1c2FibGUsIGlzVGFiYmFibGUsIGlzRm9jdXNhYmxlIH07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ2luZXJ0JywgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICAvKipcbiAgICogVGhpcyB3b3JrIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBXM0MgU29mdHdhcmUgYW5kIERvY3VtZW50IExpY2Vuc2VcbiAgICogKGh0dHA6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvMjAxNS9jb3B5cmlnaHQtc29mdHdhcmUtYW5kLWRvY3VtZW50KS5cbiAgICovXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZXR1cm4gZWFybHkgaWYgd2UncmUgbm90IHJ1bm5pbmcgaW5zaWRlIG9mIHRoZSBicm93c2VyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgICAvKiogQHR5cGUge3R5cGVvZiBBcnJheS5wcm90b3R5cGUuc2xpY2V9ICovXG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgLyoqXG4gICAgICogSUUgaGFzIGEgbm9uLXN0YW5kYXJkIG5hbWUgZm9yIFwibWF0Y2hlc1wiLlxuICAgICAqIEB0eXBlIHt0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc31cbiAgICAgKi9cbiAgICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XG5cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgICAvKipcbiAgICAgKiBgSW5lcnRSb290YCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IHN1YnRyZWUsIGkuZS4gYSBET00gc3VidHJlZSB3aG9zZSByb290IGVsZW1lbnQgaGFzIGFuIGBpbmVydGBcbiAgICAgKiBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBJdHMgbWFpbiBmdW5jdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogLSB0byBjcmVhdGUgYW5kIG1haW50YWluIGEgc2V0IG9mIG1hbmFnZWQgYEluZXJ0Tm9kZWBzLCBpbmNsdWRpbmcgd2hlbiBtdXRhdGlvbnMgb2NjdXIgaW4gdGhlXG4gICAgICogICBzdWJ0cmVlLiBUaGUgYG1ha2VTdWJ0cmVlVW5mb2N1c2FibGUoKWAgbWV0aG9kIGhhbmRsZXMgY29sbGVjdGluZyBgSW5lcnROb2RlYHMgdmlhIHJlZ2lzdGVyaW5nXG4gICAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgICAqICAgZm9jdXNhYmxlIG5vZGVzIHdpdGhpbiBpbmVydCBzdWJ0cmVlcy4gYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgXG4gICAgICogICBpbnN0YW5jZSBleGlzdHMgZm9yIGVhY2ggZm9jdXNhYmxlIG5vZGUgd2hpY2ggaGFzIGF0IGxlYXN0IG9uZSBpbmVydCByb290IGFzIGFuIGFuY2VzdG9yLlxuICAgICAqXG4gICAgICogLSB0byBub3RpZnkgYWxsIG1hbmFnZWQgYEluZXJ0Tm9kZWBzIHdoZW4gdGhpcyBzdWJ0cmVlIHN0b3BzIGJlaW5nIGluZXJ0IChpLmUuIHdoZW4gdGhlIGBpbmVydGBcbiAgICAgKiAgIGF0dHJpYnV0ZSBpcyByZW1vdmVkIGZyb20gdGhlIHJvb3Qgbm9kZSkuIFRoaXMgaXMgaGFuZGxlZCBpbiB0aGUgZGVzdHJ1Y3Rvciwgd2hpY2ggY2FsbHMgdGhlXG4gICAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICAgKi9cblxuICAgIHZhciBJbmVydFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290RWxlbWVudCBUaGUgSFRNTEVsZW1lbnQgYXQgdGhlIHJvb3Qgb2YgdGhlIGluZXJ0IHN1YnRyZWUuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydE1hbmFnZXJ9IGluZXJ0TWFuYWdlciBUaGUgZ2xvYmFsIHNpbmdsZXRvbiBJbmVydE1hbmFnZXIgb2JqZWN0LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydFJvb3Qocm9vdEVsZW1lbnQsIGluZXJ0TWFuYWdlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRSb290KTtcblxuICAgICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IGluZXJ0TWFuYWdlcjtcblxuICAgICAgICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Tm9kZT59XG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHs/c3RyaW5nfSAqL1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIC8vIE1ha2UgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0aGUgc3VidHJlZSB1bmZvY3VzYWJsZSBhbmQgYWRkIHRoZW0gdG8gX21hbmFnZWROb2Rlc1xuICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgICAvLyBXYXRjaCBmb3I6XG4gICAgICAgIC8vIC0gYW55IGFkZGl0aW9ucyBpbiB0aGUgc3VidHJlZTogbWFrZSB0aGVtIHVuZm9jdXNhYmxlIHRvb1xuICAgICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgICAgLy8gLSBhdHRyaWJ1dGUgY2hhbmdlczogaWYgYHRhYmluZGV4YCBpcyBhZGRlZCwgb3IgcmVtb3ZlZCBmcm9tIGFuIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlXG4gICAgICAgIC8vICAgZWxlbWVudCwgbWFrZSB0aGF0IG5vZGUgYSBtYW5hZ2VkIG5vZGUuXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9yb290RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS4gIFRoaXMgdW53aW5kcyBhbGwgb2YgdGhlIHN0YXRlXG4gICAgICAgKiBzdG9yZWQgaW4gdGhpcyBvYmplY3QgYW5kIHVwZGF0ZXMgdGhlIHN0YXRlIG9mIGFsbCBvZiB0aGUgbWFuYWdlZCBub2Rlcy5cbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydFJvb3QsIFt7XG4gICAgICAgIGtleTogJ2Rlc3RydWN0b3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRoaXMuX3NhdmVkQXJpYUhpZGRlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5tYW5hZ2VOb2RlKGluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgICAvLyAxKSBXZSB3YW50IHRoZSBjbGFzcyBwcm9wZXJ0aWVzIHRvIGJlIGRlY2xhcmVkIGFzIG5vbi1udWxsLCBvciBlbHNlIHdlXG4gICAgICAgICAgLy8gICAgbmVlZCBldmVuIG1vcmUgY2FzdHMgdGhyb3VnaG91dCB0aGlzIGNvZGUuIEFsbCBiZXRzIGFyZSBvZmYgaWYgYW5cbiAgICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgICAvLyAyKSBXZSBkb24ndCB3YW50IHRvIGNhc3QgXCJ0aGlzXCIsIGJlY2F1c2Ugd2Ugd2FudCB0eXBlLWF3YXJlIG9wdGltaXphdGlvbnNcbiAgICAgICAgICAvLyAgICB0byBrbm93IHdoaWNoIHByb3BlcnRpZXMgd2UncmUgc2V0dGluZy5cbiAgICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5fdmlzaXROb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0Tm9kZSBtYXkgYmUgaW4gc2hhZG93IERPTSwgc28gZmluZCBpdHMgbmVhcmVzdCBzaGFkb3dSb290IHRvIGdldCB0aGUgYWN0aXZlRWxlbWVudC5cbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHshU2hhZG93Um9vdHx1bmRlZmluZWR9ICovXG4gICAgICAgICAgICB2YXIgcm9vdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICByb290ID0gLyoqIEB0eXBlIHshU2hhZG93Um9vdH0gKi9ub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gcm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnROb2RlLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAgIC8vIEluIElFMTEsIGlmIGFuIGVsZW1lbnQgaXMgYWxyZWFkeSBmb2N1c2VkLCBhbmQgdGhlbiBzZXQgdG8gdGFiaW5kZXg9LTFcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgYmx1cigpIHdpbGwgbm90IGFjdHVhbGx5IG1vdmUgdGhlIGZvY3VzLlxuICAgICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdmlzaXROb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF92aXNpdE5vZGUobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgICAvLyBJZiBhIGRlc2NlbmRhbnQgaW5lcnQgcm9vdCBiZWNvbWVzIHVuLWluZXJ0LCBpdHMgZGVzY2VuZGFudHMgd2lsbCBzdGlsbCBiZSBpbmVydCBiZWNhdXNlIG9mXG4gICAgICAgICAgLy8gdGhpcyBpbmVydCByb290LCBzbyBhbGwgb2YgaXRzIG1hbmFnZWQgbm9kZXMgbmVlZCB0byBiZSBhZG9wdGVkIGJ5IHRoaXMgSW5lcnRSb290LlxuICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QoZWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5yZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdW5tYW5hZ2VOb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXNbJ2RlbGV0ZSddKGluZXJ0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlU3VidHJlZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VTdWJ0cmVlKHN0YXJ0Tm9kZSkge1xuICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLl91bm1hbmFnZU5vZGUobm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19hZG9wdEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRvcHRJbmVydFJvb3Qobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgICAgLy8gRHVyaW5nIGluaXRpYWxpc2F0aW9uIHRoaXMgaW5lcnQgcm9vdCBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIHlldCxcbiAgICAgICAgICAvLyBzbyByZWdpc3RlciBpdCBub3cgaWYgbmVlZCBiZS5cbiAgICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyLnNldEluZXJ0KG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmVydFN1YnJvb3QubWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHNhdmVkSW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHNhdmVkSW5lcnROb2RlLm5vZGUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gc2VsZlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfb25NdXRhdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9yZWNvcmQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgICAvLyBNYW5hZ2UgYWRkZWQgbm9kZXNcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgIC8vIFVuLW1hbmFnZSByZW1vdmVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlU3VidHJlZShub2RlKTtcbiAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAndGFiaW5kZXgnKSB7XG4gICAgICAgICAgICAgICAgLy8gUmUtaW5pdGlhbGlzZSBpbmVydCBub2RlIGlmIHRhYmluZGV4IGNoYW5nZXNcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiByZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ2luZXJ0JyAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBuZXcgaW5lcnQgcm9vdCBpcyBhZGRlZCwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMgYW5kIG1ha2Ugc3VyZSBpdCBrbm93cyBhYm91dCB0aGVcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5jb250YWlucyhtYW5hZ2VkTm9kZS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydFN1YnJvb3QuX21hbmFnZU5vZGUobWFuYWdlZE5vZGUubm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdtYW5hZ2VkTm9kZXMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcGFyYW0gez9zdHJpbmd9IGFyaWFIaWRkZW4gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhcmlhSGlkZGVuKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHs/c3RyaW5nfSAqL1xuICAgICAgICAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW47XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Um9vdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBgSW5lcnROb2RlYCBpbml0aWFsaXNlcyBhbmQgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBub2RlLlxuICAgICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIE9uIGNvbnN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgc2F2ZXMgdGhlIGV4aXN0aW5nIGB0YWJpbmRleGAgdmFsdWUgZm9yIHRoZSBub2RlLCBpZiBhbnksIGFuZFxuICAgICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAgICogaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUgb3Igbm90LlxuICAgICAqXG4gICAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgICAqIGBJbmVydFJvb3RgIGlzIGRlc3Ryb3llZCwgYW5kIGNhbGxzIGBJbmVydE1hbmFnZXIuZGVyZWdpc3RlcigpYCwgdGhlIGBJbmVydE1hbmFnZXJgIG5vdGlmaWVzIHRoZVxuICAgICAqIGBJbmVydE5vZGVgIHZpYSBgcmVtb3ZlSW5lcnRSb290KClgLCB3aGljaCBpbiB0dXJuIGRlc3Ryb3lzIHRoZSBgSW5lcnROb2RlYCBpZiBubyBgSW5lcnRSb290YHNcbiAgICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAgICogb3IgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgaWYgdGhlIGVsZW1lbnQgaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUuXG4gICAgICovXG5cblxuICAgIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgQSBmb2N1c2FibGUgZWxlbWVudCB0byBiZSBtYWRlIGluZXJ0LlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IU5vZGV9ICovXG4gICAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiAgICBJZiBhbmQgb25seSBpZiB0aGlzIHNldCBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IG51bGw7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBTYXZlIGFueSBwcmlvciB0YWJpbmRleCBpbmZvIGFuZCBtYWtlIHRoaXMgbm9kZSB1bnRhYmJhYmxlXG4gICAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICAgKiBUaGlzIG1ha2VzIHRoZSBtYW5hZ2VkIG5vZGUgZm9jdXNhYmxlIGFnYWluIGFuZCBkZWxldGVzIGFsbCBvZiB0aGUgcHJldmlvdXNseSBzdG9yZWQgc3RhdGUuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX25vZGUgJiYgdGhpcy5fbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5fbm9kZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRoaXMuX3NhdmVkVGFiSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBgZGVsZXRlYCB0byByZXN0b3JlIG5hdGl2ZSBmb2N1cyBtZXRob2QuXG4gICAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudC5mb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZWUgbm90ZSBpbiBJbmVydFJvb3QuZGVzdHJ1Y3RvciBmb3Igd2h5IHdlIGNhc3QgdGhlc2UgbnVsbHMgdG8gQU5ZLlxuICAgICAgICAgIHRoaXMuX25vZGUgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG9iamVjdCBpcyBvYnNvbGV0ZSBiZWNhdXNlIHRoZSBtYW5hZ2VkIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICAgKiBJZiB0aGUgb2JqZWN0IGhhcyBiZWVuIGRlc3Ryb3llZCwgYW55IGF0dGVtcHQgdG8gYWNjZXNzIGl0IHdpbGwgY2F1c2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdGhyb3dJZkRlc3Ryb3llZCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhyb3cgaWYgdXNlciB0cmllcyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBkZXN0cm95ZWQgSW5lcnROb2RlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZW5zdXJlVW50YWJiYWJsZScsXG5cblxuICAgICAgICAvKiogU2F2ZSB0aGUgZXhpc3RpbmcgdGFiaW5kZXggdmFsdWUgYW5kIG1ha2UgdGhlIG5vZGUgdW50YWJiYWJsZSBhbmQgdW5mb2N1c2FibGUgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMubm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLm5vZGU7XG4gICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpKSB7XG4gICAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGFub3RoZXIgaW5lcnQgcm9vdCB0byB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBJZiB0aGUgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzIGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQsXG4gICAgICAgICAqIHNvIHRoZSBvYmplY3Qgc2hvdWxkIGJlIGRlc3Ryb3llZC5cbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RydWN0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgeyFJbmVydE5vZGV9ICovdGhpcy5fZGVzdHJveWVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7IU5vZGV9ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbm9kZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcGFyYW0gez9udW1iZXJ9IHRhYkluZGV4ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRhYkluZGV4KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSB0YWJJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgICAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleDtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnROb2RlO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEluZXJ0TWFuYWdlciBpcyBhIHBlci1kb2N1bWVudCBzaW5nbGV0b24gb2JqZWN0IHdoaWNoIG1hbmFnZXMgYWxsIGluZXJ0IHJvb3RzIGFuZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICAgKiBwcm9wZXJ0eSBzZXQgdG8gYHRydWVgLCB0aGUgYHNldEluZXJ0YCBtZXRob2QgY3JlYXRlcyBhbiBgSW5lcnRSb290YCBvYmplY3QgZm9yIHRoZSBlbGVtZW50LlxuICAgICAqIFRoZSBgSW5lcnRSb290YCBpbiB0dXJuIHJlZ2lzdGVycyBpdHNlbGYgYXMgbWFuYWdpbmcgYWxsIG9mIHRoZSBlbGVtZW50J3MgZm9jdXNhYmxlIGRlc2NlbmRhbnRcbiAgICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICAgKiBpcyBjcmVhdGVkIGZvciBlYWNoIHN1Y2ggbm9kZSwgdmlhIHRoZSBgX21hbmFnZWROb2Rlc2AgbWFwLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFEb2N1bWVudH0gZG9jdW1lbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRNYW5hZ2VyKGRvY3VtZW50KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE1hbmFnZXIpO1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ7IEluZXJ0TWFuYWdlciBuZWVkcyB0byB3cmFwIGEgZG9jdW1lbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydE5vZGU+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgaW5lcnQgcm9vdHMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT2JzZXJ2ZXIgZm9yIG11dGF0aW9ucyBvbiBgZG9jdW1lbnQuYm9keWAuXG4gICAgICAgICAqIEB0eXBlIHshTXV0YXRpb25PYnNlcnZlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fd2F0Y2hGb3JJbmVydC5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBBZGQgaW5lcnQgc3R5bGUuXG4gICAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgZG9jdW1lbnQgdG8gYmUgbG9hZGVkLlxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fb25Eb2N1bWVudExvYWRlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IHJvb3RcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5lcnRcbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydE1hbmFnZXIsIFt7XG4gICAgICAgIGtleTogJ3NldEluZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgICAgaWYgKGluZXJ0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgICByb290LnNldEF0dHJpYnV0ZSgnaW5lcnQnLCAnJyk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLnNldChyb290LCBpbmVydFJvb3QpO1xuICAgICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgICAgLy8gRW5zdXJlIGluZXJ0IHN0eWxlcyBhcmUgYWRkZWQgdGhlcmUuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RvY3VtZW50LmJvZHkuY29udGFpbnMocm9vdCkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IG5vbi1pbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfaW5lcnRSb290ID0gdGhpcy5faW5lcnRSb290cy5nZXQocm9vdCk7XG4gICAgICAgICAgICBfaW5lcnRSb290LmRlc3RydWN0b3IoKTtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgSW5lcnRSb290IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmVydCByb290IGVsZW1lbnQsIGlmIGFueS5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJuIHshSW5lcnRSb290fHVuZGVmaW5lZH1cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0SW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluZXJ0Um9vdChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgICAqIEluIHRoZSBjYXNlIHdoZXJlIHRoZSBub2RlIGhhcyBhIHByZXZpb3VzbHkgZXhpc3RpbmcgaW5lcnQgcm9vdCwgdGhpcyBpbmVydCByb290IHdpbGxcbiAgICAgICAgICogYmUgYWRkZWQgdG8gaXRzIHNldCBvZiBpbmVydCByb290cy5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKiBAcmV0dXJuIHshSW5lcnROb2RlfSBpbmVydE5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVnaXN0ZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICAgIGluZXJ0Tm9kZS5hZGRJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5zZXQobm9kZSwgaW5lcnROb2RlKTtcblxuICAgICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAgICogUmVtb3ZlcyB0aGUgaW5lcnQgcm9vdCBmcm9tIHRoZSBJbmVydE5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMsIGFuZCByZW1vdmUgdGhlIGluZXJ0XG4gICAgICAgICAqIG5vZGUgZnJvbSB0aGUgSW5lcnRNYW5hZ2VyJ3Mgc2V0IG9mIG1hbmFnZWQgbm9kZXMgaWYgaXQgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVyZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5fbWFuYWdlZE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXNbJ2RlbGV0ZSddKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIGRvY3VtZW50IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfb25Eb2N1bWVudExvYWRlZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Eb2N1bWVudExvYWRlZCgpIHtcbiAgICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbCh0aGlzLl9kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBDb21tZW50IHRoaXMgb3V0IHRvIHVzZSBwcm9ncmFtbWF0aWMgQVBJIG9ubHkuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gc2VsZlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfd2F0Y2hGb3JJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICdjaGlsZExpc3QnOlxuICAgICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCAnW2luZXJ0XScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMudW5zaGlmdChub2RlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSAhPT0gJ2luZXJ0Jykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgICAgICB2YXIgaW5lcnQgPSB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb24gKCFIVE1MRWxlbWVudCkpPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBlYWNoIGVsZW1lbnQgdHJhdmVyc2VkLFxuICAgICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7P1NoYWRvd1Jvb3Q9fSBzaGFkb3dSb290QW5jZXN0b3IgVGhlIG5lYXJlc3QgU2hhZG93Um9vdCBhbmNlc3RvciwgaWYgYW55LlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovbm9kZTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgICAgLy8gSWYgaXQgaGFzIGEgU2hhZG93Um9vdCwgaWdub3JlIGFsbCBjaGlsZCBlbGVtZW50cyAtIHRoZXNlIHdpbGwgYmUgcGlja2VkXG4gICAgICAgIC8vIHVwIGJ5IHRoZSA8Y29udGVudD4gb3IgPHNoYWRvdz4gZWxlbWVudHMuIERlc2NlbmQgc3RyYWlnaHQgaW50byB0aGVcbiAgICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgICAgdmFyIHNoYWRvd1Jvb3QgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICAgIHZhciBjb250ZW50ID0gLyoqIEB0eXBlIHshSFRNTENvbnRlbnRFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZpZXMgaWYgU2hhZG93RG9tIHYwIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGRpc3RyaWJ1dGVkTm9kZXNbaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgdmFyIHNsb3QgPSAvKiogQHR5cGUgeyFIVE1MU2xvdEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgICAvLyBWZXJpZnkgaWYgU2hhZG93RG9tIHYxIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9kaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhfZGlzdHJpYnV0ZWROb2Rlc1tfaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgbmVpdGhlciB0aGUgcGFyZW50IG9mIGEgU2hhZG93Um9vdCwgYSA8Y29udGVudD4gZWxlbWVudCwgYSA8c2xvdD5cbiAgICAgIC8vIGVsZW1lbnQsIG5vciBhIDxzaGFkb3c+IGVsZW1lbnQgcmVjdXJzZSBub3JtYWxseS5cbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoY2hpbGQsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdHlsZSBlbGVtZW50IHRvIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIGluZXJ0IHNwZWNpZmljIHN0eWxlc1xuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRJbmVydFN0eWxlKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlI2luZXJ0LXN0eWxlLCBsaW5rI2luZXJ0LXN0eWxlJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gJ1xcbicgKyAnW2luZXJ0XSB7XFxuJyArICcgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbicgKyAnICBjdXJzb3I6IGRlZmF1bHQ7XFxuJyArICd9XFxuJyArICdcXG4nICsgJ1tpbmVydF0sIFtpbmVydF0gKiB7XFxuJyArICcgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICd9XFxuJztcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cblxuICAgIGlmICghSFRNTEVsZW1lbnQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdpbmVydCcpKSB7XG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUsICdpbmVydCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGluZXJ0KSB7XG4gICAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KSgpO1xuXG59KSkpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBgQmxvY2tpbmdFbGVtZW50c2AgbWFuYWdlcyBhIHN0YWNrIG9mIGVsZW1lbnRzIHRoYXQgaW5lcnQgdGhlIGludGVyYWN0aW9uXG4gKiBvdXRzaWRlIHRoZW0uIFRoZSB0b3AgZWxlbWVudCBpcyB0aGUgaW50ZXJhY3RpdmUgcGFydCBvZiB0aGUgZG9jdW1lbnQuXG4gKiBUaGUgc3RhY2sgY2FuIGJlIHVwZGF0ZWQgd2l0aCB0aGUgbWV0aG9kcyBgcHVzaCwgcmVtb3ZlLCBwb3BgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJsb2NraW5nRWxlbWVudHMge1xuICAvKipcbiAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS4gVGhpcyBlbXB0aWVzXG4gICAqIHRoZSBibG9ja2luZyBlbGVtZW50c1xuICAgKi9cbiAgZGVzdHJ1Y3RvcigpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgdG9wIGJsb2NraW5nIGVsZW1lbnQuXG4gICAqL1xuICB0b3A6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGVsZW1lbnQgdG8gdGhlIGJsb2NraW5nIGVsZW1lbnRzLlxuICAgKi9cbiAgcHVzaChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVsZW1lbnQgZnJvbSB0aGUgYmxvY2tpbmcgZWxlbWVudHMuIFJldHVybnMgdHJ1ZSBpZiB0aGVcbiAgICogZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgdG9wIGJsb2NraW5nIGVsZW1lbnQgYW5kIHJldHVybnMgaXQuXG4gICAqL1xuICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgZWxlbWVudCBpcyBhIGJsb2NraW5nIGVsZW1lbnQuXG4gICAqL1xuICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMgZXh0ZW5kcyBEb2N1bWVudCB7XG4gICRibG9ja2luZ0VsZW1lbnRzOiBCbG9ja2luZ0VsZW1lbnRzO1xufVxuXG4oKCkgPT4ge1xuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHByb3BlcnRpZXMgKi9cbiAgY29uc3QgX2Jsb2NraW5nRWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2FscmVhZHlJbmVydEVsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF90b3BFbFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3NpYmxpbmdzVG9SZXN0b3JlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9wYXJlbnRNTyA9IFN5bWJvbCgpO1xuXG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgc3RhdGljIG1ldGhvZHMgKi9cbiAgY29uc3QgX3RvcENoYW5nZWQgPSBTeW1ib2woKTtcbiAgY29uc3QgX3N3YXBJbmVydGVkU2libGluZyA9IFN5bWJvbCgpO1xuICBjb25zdCBfaW5lcnRTaWJsaW5ncyA9IFN5bWJvbCgpO1xuICBjb25zdCBfcmVzdG9yZUluZXJ0ZWRTaWJsaW5ncyA9IFN5bWJvbCgpO1xuICBjb25zdCBfZ2V0UGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbiA9IFN5bWJvbCgpO1xuICBjb25zdCBfaXNJbmVydGFibGUgPSBTeW1ib2woKTtcbiAgY29uc3QgX2hhbmRsZU11dGF0aW9ucyA9IFN5bWJvbCgpO1xuXG4gIGludGVyZmFjZSBJbmVydGFibGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgaW5lcnQ/OiBib29sZWFuO1xuICB9XG5cbiAgaW50ZXJmYWNlIEludGVybmFsU3RhdGUge1xuICAgIFtfc2libGluZ3NUb1Jlc3RvcmVdOiBTZXQ8TWF5YmVIYXNJbnRlcm5hbFN0YXRlPjtcbiAgICBbX3BhcmVudE1PXTogTXV0YXRpb25PYnNlcnZlcjtcbiAgfVxuICBpbnRlcmZhY2UgSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgSW50ZXJuYWxTdGF0ZSB7fVxuICBpbnRlcmZhY2UgTWF5YmVIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBQYXJ0aWFsPEludGVybmFsU3RhdGU+IHt9XG5cbiAgLyoqXG4gICAqIFNoYWR5RE9NIHNoYWR5IHJvb3RzIGxvb2sgYSBsb3QgbGlrZSByZWFsIFNoYWRvd1Jvb3RzLiBUaGUgX19zaGFkeSBwcm9wZXJ0eVxuICAgKiBnaXZlcyB0aGVtIGF3YXksIHRob3VnaC5cbiAgICovXG4gIGludGVyZmFjZSBNYXliZVNoYWR5Um9vdCBleHRlbmRzIEVsZW1lbnQge1xuICAgIF9fc2hhZHk6IHVua25vd247XG4gICAgaG9zdDogRWxlbWVudDtcbiAgfVxuXG4gIGNsYXNzIEJsb2NraW5nRWxlbWVudHNJbXBsIGltcGxlbWVudHMgQmxvY2tpbmdFbGVtZW50cyB7XG4gICAgLyoqXG4gICAgICogVGhlIGJsb2NraW5nIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2Jsb2NraW5nRWxlbWVudHNdOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBwYXJlbnRzIG9mIHRoZSB0b3AgZWxlbWVudCwgZnJvbSB0aGUgZWxlbWVudFxuICAgICAqIGl0c2VsZiB1cCB0byBib2R5LiBXaGVuIHRvcCBjaGFuZ2VzLCB0aGUgb2xkIHRvcCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAqIGZyb20gdGhlIGRvY3VtZW50LCBzbyB3ZSBuZWVkIHRvIG1lbW9pemUgdGhlIGluZXJ0ZWQgcGFyZW50cycgc2libGluZ3NcbiAgICAgKiBpbiBvcmRlciB0byByZXN0b3JlIHRoZWlyIGluZXJ0ZW5lc3Mgd2hlbiB0b3AgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBwcml2YXRlW190b3BFbFBhcmVudHNdOiBIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEVsZW1lbnRzIHRoYXQgYXJlIGFscmVhZHkgaW5lcnQgYmVmb3JlIHRoZSBmaXJzdCBibG9ja2luZyBlbGVtZW50IGlzXG4gICAgICogcHVzaGVkLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG5ldyBTZXQ8TWF5YmVIYXNJbnRlcm5hbFN0YXRlPigpO1xuXG4gICAgZGVzdHJ1Y3RvcigpOiB2b2lkIHtcbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgaW5lcnRuZXNzLlxuICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10odGhpc1tfdG9wRWxQYXJlbnRzXSk7XG4gICAgICAvLyBOb3RlIHdlIGRvbid0IHdhbnQgdG8gbWFrZSB0aGVzZSBwcm9wZXJ0aWVzIG51bGxhYmxlIG9uIHRoZSBjbGFzcyxcbiAgICAgIC8vIHNpbmNlIHRoZW4gd2UnZCBuZWVkIG5vbi1udWxsIGNhc3RzIGluIG1hbnkgcGxhY2VzLiBDYWxsaW5nIGEgbWV0aG9kIG9uXG4gICAgICAvLyBhIEJsb2NraW5nRWxlbWVudHMgaW5zdGFuY2UgYWZ0ZXIgY2FsbGluZyBkZXN0cnVjdG9yIHdpbGwgcmVzdWx0IGluIGFuXG4gICAgICAvLyBleGNlcHRpb24uXG4gICAgICBjb25zdCBudWxsYWJsZSA9IHRoaXMgYXMgdW5rbm93biBhcyB7XG4gICAgICAgIFtfYmxvY2tpbmdFbGVtZW50c106IG51bGw7XG4gICAgICAgIFtfdG9wRWxQYXJlbnRzXTogbnVsbDtcbiAgICAgICAgW19hbHJlYWR5SW5lcnRFbGVtZW50c106IG51bGw7XG4gICAgICB9O1xuICAgICAgbnVsbGFibGVbX2Jsb2NraW5nRWxlbWVudHNdID0gbnVsbDtcbiAgICAgIG51bGxhYmxlW190b3BFbFBhcmVudHNdID0gbnVsbDtcbiAgICAgIG51bGxhYmxlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBudWxsO1xuICAgIH1cblxuICAgIGdldCB0b3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCBlbGVtcyA9IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdO1xuICAgICAgcmV0dXJuIGVsZW1zW2VsZW1zLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gICAgfVxuXG4gICAgcHVzaChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQgPT09IHRoaXMudG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgd2UnbGwgYnJpbmcgaXQgdG8gdGhlIHRvcC5cbiAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0oZWxlbWVudCk7XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5wdXNoKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJlbW92ZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgY29uc3QgaSA9IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uc3BsaWNlKGksIDEpO1xuICAgICAgLy8gVG9wIGNoYW5nZWQgb25seSBpZiB0aGUgcmVtb3ZlZCBlbGVtZW50IHdhcyB0aGUgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoaSA9PT0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX3RvcENoYW5nZWRdKHRoaXMudG9wKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgdG9wICYmIHRoaXMucmVtb3ZlKHRvcCk7XG4gICAgICByZXR1cm4gdG9wO1xuICAgIH1cblxuICAgIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmluZGV4T2YoZWxlbWVudCkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYGluZXJ0YCB0byBhbGwgZG9jdW1lbnQgZWxlbWVudHMgZXhjZXB0IHRoZSBuZXcgdG9wIGVsZW1lbnQsIGl0c1xuICAgICAqIHBhcmVudHMsIGFuZCBpdHMgZGlzdHJpYnV0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBwcml2YXRlW190b3BDaGFuZ2VkXShuZXdUb3A6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZXxudWxsKTogdm9pZCB7XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGNvbnN0IG9sZFBhcmVudHMgPSB0aGlzW190b3BFbFBhcmVudHNdO1xuICAgICAgLy8gTm8gbmV3IHRvcCwgcmVzZXQgb2xkIHRvcCBpZiBhbnkuXG4gICAgICBpZiAoIW5ld1RvcCkge1xuICAgICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzKTtcbiAgICAgICAgdG9LZWVwSW5lcnQuY2xlYXIoKTtcbiAgICAgICAgdGhpc1tfdG9wRWxQYXJlbnRzXSA9IFtdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1BhcmVudHMgPSB0aGlzW19nZXRQYXJlbnRzXShuZXdUb3ApO1xuICAgICAgLy8gTmV3IHRvcCBpcyBub3QgY29udGFpbmVkIGluIHRoZSBtYWluIGRvY3VtZW50IVxuICAgICAgaWYgKG5ld1BhcmVudHNbbmV3UGFyZW50cy5sZW5ndGggLSAxXS5wYXJlbnROb2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb24tY29ubmVjdGVkIGVsZW1lbnQgY2Fubm90IGJlIGEgYmxvY2tpbmcgZWxlbWVudCcpO1xuICAgICAgfVxuICAgICAgLy8gQ2FzdCBoZXJlIGJlY2F1c2Ugd2Uga25vdyB3ZSdsbCBjYWxsIF9pbmVydFNpYmxpbmdzIG9uIG5ld1BhcmVudHNcbiAgICAgIC8vIGJlbG93LlxuICAgICAgdGhpc1tfdG9wRWxQYXJlbnRzXSA9IG5ld1BhcmVudHMgYXMgQXJyYXk8SGFzSW50ZXJuYWxTdGF0ZT47XG5cbiAgICAgIGNvbnN0IHRvU2tpcCA9IHRoaXNbX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW5dKG5ld1RvcCk7XG5cbiAgICAgIC8vIE5vIHByZXZpb3VzIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKCFvbGRQYXJlbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLCB0b1NraXAsIHRvS2VlcEluZXJ0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSA9IG9sZFBhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBqID0gbmV3UGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgLy8gRmluZCBjb21tb24gcGFyZW50LiBJbmRleCAwIGlzIHRoZSBlbGVtZW50IGl0c2VsZiAoc28gc3RvcCBiZWZvcmUgaXQpLlxuICAgICAgd2hpbGUgKGkgPiAwICYmIGogPiAwICYmIG9sZFBhcmVudHNbaV0gPT09IG5ld1BhcmVudHNbal0pIHtcbiAgICAgICAgaS0tO1xuICAgICAgICBqLS07XG4gICAgICB9XG4gICAgICAvLyBJZiB1cCB0aGUgcGFyZW50cyB0cmVlIHRoZXJlIGFyZSAyIGVsZW1lbnRzIHRoYXQgYXJlIHNpYmxpbmdzLCBzd2FwXG4gICAgICAvLyB0aGUgaW5lcnRlZCBzaWJsaW5nLlxuICAgICAgaWYgKG9sZFBhcmVudHNbaV0gIT09IG5ld1BhcmVudHNbal0pIHtcbiAgICAgICAgdGhpc1tfc3dhcEluZXJ0ZWRTaWJsaW5nXShvbGRQYXJlbnRzW2ldLCBuZXdQYXJlbnRzW2pdKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlc3RvcmUgb2xkIHBhcmVudHMgc2libGluZ3MgaW5lcnRuZXNzLlxuICAgICAgaSA+IDAgJiYgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cy5zbGljZSgwLCBpKSk7XG4gICAgICAvLyBNYWtlIG5ldyBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0LlxuICAgICAgaiA+IDAgJiYgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cy5zbGljZSgwLCBqKSwgdG9Ta2lwLCBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyBpbmVydG5lc3MgYmV0d2VlbiB0d28gc2libGluZyBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19zd2FwSW5lcnRlZFNpYmxpbmddKFxuICAgICAgICBvbGRJbmVydDogSGFzSW50ZXJuYWxTdGF0ZSwgbmV3SW5lcnQ6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZSk6IHZvaWQge1xuICAgICAgY29uc3Qgc2libGluZ3NUb1Jlc3RvcmUgPSBvbGRJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgLy8gb2xkSW5lcnQgaXMgbm90IGNvbnRhaW5lZCBpbiBzaWJsaW5ncyB0byByZXN0b3JlLCBzbyB3ZSBoYXZlIHRvIGNoZWNrXG4gICAgICAvLyBpZiBpdCdzIGluZXJ0YWJsZSBhbmQgaWYgYWxyZWFkeSBpbmVydC5cbiAgICAgIGlmICh0aGlzW19pc0luZXJ0YWJsZV0ob2xkSW5lcnQpICYmICFvbGRJbmVydC5pbmVydCkge1xuICAgICAgICBvbGRJbmVydC5pbmVydCA9IHRydWU7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmFkZChvbGRJbmVydCk7XG4gICAgICB9XG4gICAgICAvLyBJZiBuZXdJbmVydCB3YXMgYWxyZWFkeSBiZXR3ZWVuIHRoZSBzaWJsaW5ncyB0byByZXN0b3JlLCBpdCBtZWFucyBpdCBpc1xuICAgICAgLy8gaW5lcnRhYmxlIGFuZCBtdXN0IGJlIHJlc3RvcmVkLlxuICAgICAgaWYgKHNpYmxpbmdzVG9SZXN0b3JlLmhhcyhuZXdJbmVydCkpIHtcbiAgICAgICAgbmV3SW5lcnQuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuZGVsZXRlKG5ld0luZXJ0KTtcbiAgICAgIH1cbiAgICAgIG5ld0luZXJ0W19wYXJlbnRNT10gPSBvbGRJbmVydFtfcGFyZW50TU9dO1xuICAgICAgbmV3SW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHNpYmxpbmdzVG9SZXN0b3JlO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3BhcmVudE1PXSA9IHVuZGVmaW5lZDtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19zaWJsaW5nc1RvUmVzdG9yZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgb3JpZ2luYWwgaW5lcnRuZXNzIHRvIHRoZSBzaWJsaW5ncyBvZiB0aGUgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10oZWxlbWVudHM6IEhhc0ludGVybmFsU3RhdGVbXSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IG1vID0gZWxlbWVudFtfcGFyZW50TU9dO1xuICAgICAgICBtby5kaXNjb25uZWN0KCk7XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3BhcmVudE1PXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAgIGZvciAoY29uc3Qgc2libGluZyBvZiBzaWJsaW5ncykge1xuICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19zaWJsaW5nc1RvUmVzdG9yZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5lcnRzIHRoZSBzaWJsaW5ncyBvZiB0aGUgZWxlbWVudHMgZXhjZXB0IHRoZSBlbGVtZW50cyB0byBza2lwLiBTdG9yZXNcbiAgICAgKiB0aGUgaW5lcnRlZCBzaWJsaW5ncyBpbnRvIHRoZSBlbGVtZW50J3Mgc3ltYm9sIGBfc2libGluZ3NUb1Jlc3RvcmVgLlxuICAgICAqIFBhc3MgYHRvS2VlcEluZXJ0YCB0byBjb2xsZWN0IHRoZSBhbHJlYWR5IGluZXJ0IGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX2luZXJ0U2libGluZ3NdKFxuICAgICAgICBlbGVtZW50czogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10sIHRvU2tpcDogU2V0PEhUTUxFbGVtZW50PnxudWxsLFxuICAgICAgICB0b0tlZXBJbmVydDogU2V0PEhUTUxFbGVtZW50PnxudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgLy8gQXNzdW1lIGVsZW1lbnQgaXMgbm90IGEgRG9jdW1lbnQsIHNvIGl0IG11c3QgaGF2ZSBhIHBhcmVudE5vZGUuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSE7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBuZXcgU2V0PEhUTUxFbGVtZW50PigpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IGNoaWxkcmVuW2pdIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICAvLyBTa2lwIHRoZSBpbnB1dCBlbGVtZW50LCBpZiBub3QgaW5lcnRhYmxlIG9yIHRvIGJlIHNraXBwZWQuXG4gICAgICAgICAgaWYgKHNpYmxpbmcgPT09IGVsZW1lbnQgfHwgIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSB8fFxuICAgICAgICAgICAgICAodG9Ta2lwICYmIHRvU2tpcC5oYXMoc2libGluZykpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2hvdWxkIGJlIGNvbGxlY3RlZCBzaW5jZSBhbHJlYWR5IGluZXJ0ZWQuXG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9yZSB0aGUgc2libGluZ3MgdGhhdCB3ZXJlIGluZXJ0ZWQuXG4gICAgICAgIGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IGluZXJ0ZWRTaWJsaW5ncztcbiAgICAgICAgLy8gT2JzZXJ2ZSBvbmx5IGltbWVkaWF0ZSBjaGlsZHJlbiBtdXRhdGlvbnMgb24gdGhlIHBhcmVudC5cbiAgICAgICAgY29uc3QgbW8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzW19oYW5kbGVNdXRhdGlvbnNdLmJpbmQodGhpcykpO1xuICAgICAgICBlbGVtZW50W19wYXJlbnRNT10gPSBtbztcbiAgICAgICAgbGV0IHBhcmVudFRvT2JzZXJ2ZSA9IHBhcmVudDtcbiAgICAgICAgLy8gSWYgd2UncmUgdXNpbmcgdGhlIFNoYWR5RE9NIHBvbHlmaWxsLCB0aGVuIG91ciBwYXJlbnQgY291bGQgYmUgYVxuICAgICAgICAvLyBzaGFkeSByb290LCB3aGljaCBpcyBhbiBvYmplY3QgdGhhdCBhY3RzIGxpa2UgYSBTaGFkb3dSb290LCBidXQgaXNuJ3RcbiAgICAgICAgLy8gYWN0dWFsbHkgYSBub2RlIGluIHRoZSByZWFsIERPTS4gT2JzZXJ2ZSB0aGUgcmVhbCBET00gcGFyZW50IGluc3RlYWQuXG4gICAgICAgIGNvbnN0IG1heWJlU2hhZHlSb290ID0gcGFyZW50VG9PYnNlcnZlIGFzIE1heWJlU2hhZHlSb290O1xuICAgICAgICBpZiAobWF5YmVTaGFkeVJvb3QuX19zaGFkeSAmJiBtYXliZVNoYWR5Um9vdC5ob3N0KSB7XG4gICAgICAgICAgcGFyZW50VG9PYnNlcnZlID0gbWF5YmVTaGFkeVJvb3QuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBtby5vYnNlcnZlKHBhcmVudFRvT2JzZXJ2ZSwge1xuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBuZXdseSBhZGRlZC9yZW1vdmVkIG5vZGVzIGJ5IHRvZ2dsaW5nIHRoZWlyIGluZXJ0bmVzcy5cbiAgICAgKiBJdCBhbHNvIGNoZWNrcyBpZiB0aGUgY3VycmVudCB0b3AgQmxvY2tpbmcgRWxlbWVudCBoYXMgYmVlbiByZW1vdmVkLFxuICAgICAqIG5vdGlmeWluZyBhbmQgcmVtb3ZpbmcgaXQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfaGFuZGxlTXV0YXRpb25zXShtdXRhdGlvbnM6IE11dGF0aW9uUmVjb3JkW10pOiB2b2lkIHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSB0aGlzW190b3BFbFBhcmVudHNdO1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgc2hhZG93Um9vdCwgZ2V0IGl0cyBob3N0IGFzIHdlIHNraXAgc2hhZG93Um9vdHMgd2hlblxuICAgICAgICAvLyBjb21wdXRpbmcgX3RvcEVsUGFyZW50cy5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG11dGF0aW9uLnRhcmdldCBhcyBTaGFkb3dSb290KS5ob3N0IHx8IG11dGF0aW9uLnRhcmdldDtcbiAgICAgICAgY29uc3QgaWR4ID0gdGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5ID9cbiAgICAgICAgICAgIHBhcmVudHMubGVuZ3RoIDpcbiAgICAgICAgICAgIHBhcmVudHMuaW5kZXhPZih0YXJnZXQgYXMgSGFzSW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRDaGlsZCA9IHBhcmVudHNbaWR4IC0gMV07XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IGluZXJ0ZWRDaGlsZFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuXG4gICAgICAgIC8vIFRvIHJlc3RvcmUuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLnJlbW92ZWROb2Rlc1tpXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgaWYgKHNpYmxpbmcgPT09IGluZXJ0ZWRDaGlsZCkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdEZXRlY3RlZCByZW1vdmFsIG9mIHRoZSB0b3AgQmxvY2tpbmcgRWxlbWVudC4nKTtcbiAgICAgICAgICAgIHRoaXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmVydGVkU2libGluZ3MuaGFzKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuZGVsZXRlKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvIGluZXJ0LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24uYWRkZWROb2Rlc1tpXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgaWYgKCF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgZWxlbWVudCBpcyBpbmVydGFibGUuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfaXNJbmVydGFibGVdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gZmFsc2UgPT09IC9eKHN0eWxlfHRlbXBsYXRlfHNjcmlwdCkkLy50ZXN0KGVsZW1lbnQubG9jYWxOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIG5ld1BhcmVudHMgb2YgYW4gZWxlbWVudCwgc3RhcnRpbmcgZnJvbSBlbGVtZW50XG4gICAgICogKGluY2x1ZGVkKSB1cCB0byBgZG9jdW1lbnQuYm9keWAgKGV4Y2x1ZGVkKS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXRQYXJlbnRzXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IEFycmF5PEhUTUxFbGVtZW50PiB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgICBsZXQgY3VycmVudDogSFRNTEVsZW1lbnR8bnVsbHx1bmRlZmluZWQgPSBlbGVtZW50O1xuICAgICAgLy8gU3RvcCB0byBib2R5LlxuICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAvLyBTa2lwIHNoYWRvdyByb290cy5cbiAgICAgICAgaWYgKGN1cnJlbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNoYWRvd0RvbSB2MVxuICAgICAgICBpZiAoY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBDb2xsZWN0IHNsb3RzIGZyb20gZGVlcGVzdCBzbG90IHRvIHRvcC5cbiAgICAgICAgICB3aGlsZSAoY3VycmVudCA9IGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENvbnRpbnVlIHRoZSBzZWFyY2ggb24gdGhlIHRvcCBzbG90LlxuICAgICAgICAgIGN1cnJlbnQgPSBwYXJlbnRzLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnQgfHxcbiAgICAgICAgICAgIChjdXJyZW50IGFzIE5vZGUgYXMgU2hhZG93Um9vdCkuaG9zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpc3RyaWJ1dGVkIGNoaWxkcmVuIG9mIHRoZSBlbGVtZW50J3Mgc2hhZG93IHJvb3QuXG4gICAgICogUmV0dXJucyBudWxsIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhIHNoYWRvdyByb290LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW5dKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTpcbiAgICAgICAgU2V0PEhUTUxFbGVtZW50PnxudWxsIHtcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBlbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICBpZiAoIXNoYWRvd1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0PEhUTUxFbGVtZW50PigpO1xuICAgICAgbGV0IGk7XG4gICAgICBsZXQgajtcbiAgICAgIGxldCBub2RlcztcbiAgICAgIGNvbnN0IHNsb3RzID0gc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdzbG90Jyk7XG4gICAgICBpZiAoc2xvdHMubGVuZ3RoICYmIHNsb3RzWzBdLmFzc2lnbmVkTm9kZXMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZXMgPSBzbG90c1tpXS5hc3NpZ25lZE5vZGVzKHtcbiAgICAgICAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNbal0ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5hZGQobm9kZXNbal0gYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBObyBuZWVkIHRvIHNlYXJjaCBmb3IgPGNvbnRlbnQ+LlxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAoZG9jdW1lbnQgYXMgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cykuJGJsb2NraW5nRWxlbWVudHMgPVxuICAgICAgbmV3IEJsb2NraW5nRWxlbWVudHNJbXBsKCk7XG59KSgpO1xuIiwiaW1wb3J0IFwid2ljZy1pbmVydFwiO1xuaW1wb3J0IFwiYmxvY2tpbmctZWxlbWVudHNcIjtcbmltcG9ydCB7IERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMgfSBmcm9tIFwiYmxvY2tpbmctZWxlbWVudHNcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGdldERvY3VtZW50IH0gZnJvbSBcIi4vdXNlLWRvY3VtZW50LWNsYXNzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuZnVuY3Rpb24gYmxvY2tpbmdFbGVtZW50cygpIHsgcmV0dXJuIChnZXREb2N1bWVudCgpIGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzIH1cbi8qKlxuICogQWxsb3dzIGFuIGVsZW1lbnQgdG8gdHJhcCBmb2N1cyBieSBhcHBseWluZyB0aGUgXCJpbmVydFwiIGF0dHJpYnV0ZSB0byBhbGwgc2libGluZywgYXVudCwgYW5kIHVuY2xlIG5vZGVzLlxuICogXG4gKiBBdXRvbWF0aWNhbGx5IGhhbmRsZXMgY29uc2VjdXRpdmUgY2FsbHMgd2l0aCBhIGxvb3NlbHkgYXBwbGllZCBzdGFjayBvcGVyYXRpb24gXG4gKiAoc3BlY2lmaWNhbGx5IHZpYSBgYmxvY2tpbmdFbGVtZW50c2AsIHdpdGggYSBzbWFsbCBwb2x5ZmlsbCBiZWNhdXNlIEknbSBub3Qgc3VyZSBob3cgbG9uZ1xuICogaXQnbGwgdGFrZSB0byBmaW5kIGl0cyB3YXkgaW50byB0aGUgc3BlYywgaWYgZXZlcilcbiAqIEBwYXJhbSB0YXJnZXQgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCbG9ja2luZ0VsZW1lbnQ8RSBleHRlbmRzIEVsZW1lbnQ+KGVuYWJsZWQ6IGJvb2xlYW4sIGdldFRhcmdldDogKCkgPT4gKEUgfCBudWxsKSkge1xuXG4gICAgY29uc3Qgc3RhYmxlR2V0VGFyZ2V0ID0gdXNlU3RhYmxlQ2FsbGJhY2soZ2V0VGFyZ2V0KTtcblxuICAgIC8qKlxuICAgICAqIFB1c2gvcG9wIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nRWxlbWVudHMgc3RhY2suXG4gICAgICovXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gc3RhYmxlR2V0VGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBibG9ja2luZ0VsZW1lbnRzIHdpbGwgZmFpbCBpZiwgZm9yIGV4YW1wbGUsXG4gICAgICAgICAgICAvLyB0aGUgdGFyZ2V0IGVsZW1lbnQgaXNuJ3QgY29ubmVjdGVkIHRvIGRvY3VtZW50LmJvZHkuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHJhcmUsIGJ1dCBpdCdzIGJldHRlciB0byBmYWlsIHNpbGVudGx5IHdpdGggd2VpcmQgdGFiYmluZyBiZWhhdmlvclxuICAgICAgICAgICAgLy8gdGhhbiB0byBjcmFzaCB0aGUgZW50aXJlIGFwcGxpY2F0aW9uLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBibG9ja2luZ0VsZW1lbnRzKCkucHVzaCh0YXJnZXQgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tpbmdFbGVtZW50cygpLnJlbW92ZSh0YXJnZXQgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIC8vIFdlbGwsIHNlbWktc2lsZW50bHkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbZW5hYmxlZF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wRWxlbWVudCgpIHtcbiAgICByZXR1cm4gYmxvY2tpbmdFbGVtZW50cygpLnRvcDtcbn1cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGlzRm9jdXNhYmxlIH0gZnJvbSBcInRhYmJhYmxlXCI7XG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50IH0gZnJvbSBcIi4vdXNlLWFjdGl2ZS1lbGVtZW50XCI7XG5pbXBvcnQgeyBnZXRUb3BFbGVtZW50LCB1c2VCbG9ja2luZ0VsZW1lbnQgfSBmcm9tIFwiLi91c2UtYmxvY2tpbmctZWxlbWVudFwiO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tIFwiLi91c2UtZG9jdW1lbnQtY2xhc3NcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUZvY3VzVHJhcFBhcmFtZXRlcnMgeyB0cmFwQWN0aXZlOiBib29sZWFuOyB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRm9jdXNUcmFwUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+LCBcInVzZVJlZkVsZW1lbnRQcm9wc1wiPiB7XG4gICAgLyoqICpVbnN0YWJsZSogKHJlbGllcyBvbiB0aGUgYHRyYXBBY3RpdmVgIHByb3ApICovXG4gICAgdXNlRm9jdXNUcmFwUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xufVxuXG5jb25zdCBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8gPSBuZXcgTWFwPEVsZW1lbnQgfCBudWxsLCAoTm9kZSAmIEhUTUxPclNWR0VsZW1lbnQpPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9jdXNUcmFwPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyB0cmFwQWN0aXZlIH06IFVzZUZvY3VzVHJhcFBhcmFtZXRlcnMpOiBVc2VGb2N1c1RyYXBSZXR1cm5UeXBlPEU+IHtcbiAgICBcbiAgICBjb25zdCBoYW5kbGVBY3RpdmVDaGFuZ2UgPSB1c2VDYWxsYmFjaygodHJhcEFjdGl2ZTogYm9vbGVhbiwgZWxlbWVudDogRSB8IG51bGwpID0+IHtcbiAgICAgICAgaWYgKHRyYXBBY3RpdmUgJiYgZWxlbWVudCkge1xuXG4gICAgICAgICAgICBsZXQgcmFmSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGV4dHJhIHF1ZXVlTWljcm90YXNrIGlzIG5lZWRlZCBmb3JcbiAgICAgICAgICAgICAgICAvLyAuLi5yZWFzb25zP1xuICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmluZEZpcnN0Rm9jdXNhYmxlKGVsZW1lbnQpPy5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICByYWZIYW5kbGUgPSAwO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyYWZIYW5kbGUpXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZkhhbmRsZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnQpIHtcblxuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgZm9jdXMgdG8gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHRoYXQgaGFzIHJldHVybmVkIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICAgICAgICBsZXQgcmFmSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUby5nZXQoZ2V0VG9wRWxlbWVudCgpKT8uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFmSGFuZGxlID0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyYWZIYW5kbGUpXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZkhhbmRsZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIFxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PEU+KHsgb25FbGVtZW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjaygoZWxlbWVudDogRSB8IG51bGwpID0+IGhhbmRsZUFjdGl2ZUNoYW5nZSh0cmFwQWN0aXZlLCBlbGVtZW50KSkgfSlcbiAgICBjb25zdCB7IGdldExhc3RBY3RpdmVFbGVtZW50IH0gPSB1c2VBY3RpdmVFbGVtZW50KHsgZ2V0RG9jdW1lbnQ6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IGdldEVsZW1lbnQoKT8ub3duZXJEb2N1bWVudCEgKSB9KTtcblxuXG4gICAgLy8gV2hlbiB0aGUgdHJhcCBiZWNvbWVzIGFjdGl2ZSwgYmVmb3JlIHdlIGxldCB0aGUgYmxvY2tpbmdFbGVtZW50cyBob29rIHJ1bixcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoYXRldmVyJ3MgY3VycmVudGx5IGZvY3VzZWQgYW5kIHNhdmUgaXQuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHRyYXBBY3RpdmUgJiYgZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudChlbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAgICAgLy8gdG8gd2hhdGV2ZXIncyBjdXJyZW50bHkgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgICAgIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUby5zZXQoZ2V0VG9wRWxlbWVudCgpLCAoZ2V0TGFzdEFjdGl2ZUVsZW1lbnQoKSBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpKSA/PyBkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgfVxuICAgIH0sIFt0cmFwQWN0aXZlXSk7XG5cbiAgICB1c2VCbG9ja2luZ0VsZW1lbnQodHJhcEFjdGl2ZSwgZ2V0RWxlbWVudCk7XG5cbiAgICAvKipcbiAgICAgKiBBbnkgdGltZSB3ZSBhY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHRoZSB0cmFwLFxuICAgICAqIGNoYW5nZSBmb2N1cyB0byBzb21ldGhpbmcgZWxzZSAoc29tZXRoaW5nIGluXG4gICAgICogdGhlIHRyYXAgaWYgaXQncyBhY3RpdmUsIG9yIHdoYXRldmVyIHdlJ3ZlXG4gICAgICogdHJhY2tlZCBpbiBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8gaWYgbm90KVxuICAgICAqL1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGhhbmRsZUFjdGl2ZUNoYW5nZSh0cmFwQWN0aXZlLCBnZXRFbGVtZW50KCkpO1xuICAgIH0sIFt0cmFwQWN0aXZlXSk7XG5cbiAgICBjb25zdCB1c2VGb2N1c1RyYXBQcm9wcyA9ICgocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiB7XG4gICAgICAgIGNvbnN0IHAxID0gdXNlUmVmRWxlbWVudFByb3BzKHByb3BzKTtcbiAgICAgICAgY29uc3QgcDIgPSB7IFwiYXJpYS1tb2RhbFwiOiB0cmFwQWN0aXZlID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHAxLCBwMik7XG4gICAgfSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUZvY3VzVHJhcFByb3BzLFxuICAgICAgICBnZXRFbGVtZW50XG4gICAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBjb250YWluZWQgd2l0aGluIHRoZSBnaXZlbiBub2RlLCBvciBudWxsIGlmIG5vbmUgYXJlIGZvdW5kLlxuICogQHBhcmFtIGVsZW1lbnQgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50OiBOb2RlKSB7XG4gICAgY29uc3QgdHJlZVdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWxlbWVudCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIHsgYWNjZXB0Tm9kZTogKG5vZGUpID0+IChub2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiBpc0ZvY3VzYWJsZShub2RlKSA/IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCA6IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVApIH0pXG4gICAgY29uc3QgZmlyc3RGb2N1c2FibGUgPSB0cmVlV2Fsa2VyLmZpcnN0Q2hpbGQoKSBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpIHwgbnVsbDtcbiAgICByZXR1cm4gZmlyc3RGb2N1c2FibGU7XG59XG5cbiIsImltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCwgd2hlbiBjYWxsZWQsIGZvcmNlIHRoZSBjb21wb25lbnRcbiAqIHRoYXQgdXNlcyB0aGlzIGhvb2sgdG8gcmUtcmVuZGVyIGl0c2VsZi5cbiAqIFxuICogSXQncyBhIGJpdCBzbWVsbHksIHNvIGJlc3QgdG8gdXNlIHNwYXJpbmdseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICAgIGNvbnN0IFssIHNldF0gPSB1c2VTdGF0ZSgwKTtcbiAgICByZXR1cm4gdXNlUmVmKCgpID0+IHNldChpID0+ICsraSkpLmN1cnJlbnQ7XG59IiwiXHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCwgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWFjdGl2ZS1lbGVtZW50XCI7XHJcbmltcG9ydCB7IHJldHVybkZhbHNlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgZWxlbWVudCBpdHNlbGYgY3VycmVudGx5IGhhcyBmb2N1cy5cclxuICAgICAqIFxyXG4gICAgICogYHByZXZGb2N1c2VkYCBpcyBnZW5lcmFsbHkgdGhlIG9wcG9zaXRlIG9mIGBmb2N1c2VkYCwgYnV0IG9uIG1vdW50IGl0J3MgYHVuZGVmaW5lZGAgd2hpbGUgYGZvY3VzZWRgIGlzIHByb2JhYmx5IGZhbHNlIChib3RoIGZhbHN5KVxyXG4gICAgICovXHJcbiAgICBvbkZvY3VzZWRDaGFuZ2VkPyhmb2N1c2VkOiBib29sZWFuLCBwcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaWtlIGBvbkZvY3VzZWRDaGFuZ2VkYCwgYnV0IGFsc28gKmFkZGl0aW9uYWxseSogaWYgYW55IGNoaWxkIGVsZW1lbnRzIGFyZSBmb2N1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAc2VlIHRoaXMub25Gb2N1c2VkQ2hhbmdlZFxyXG4gICAgICovXHJcbiAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbWlsYXIgdG8gYG9uRm9jdXNlZENoYW5nZWRgLCBidXQgaWYgdGhlcmUgaXMgbm8gY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCwgaXMgYHRydWVgIGlmIHRoaXMgZWxlbWVudCB0aGF0ICpkaWQqIGhhdmUgZm9jdXMgbGFzdC5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBpcyBhbHdheXMgYHRydWVgIHdoaWxlIGBmb2N1c2VkYCBpcyBgdHJ1ZWAuIElmIGBmb2N1c2VkYCBpcyBgZmFsc2VgLCB0aGlzIG1heSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgb25MYXN0Rm9jdXNlZENoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmVzIHRoZSBpbXBsaWNhdGlvbnMgb2YgYG9uRm9jdXNlZENoYW5nZWRgIGFuZCBgb25Gb2N1c2VkQ2hhbmdlZGAuXHJcbiAgICAgKi9cclxuICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNGb2N1c1JldHVyblR5cGU8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgT21pdDxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiwgXCJ1c2VSZWZFbGVtZW50UHJvcHNcIj4sIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmaWVzIHRoZSBlbGVtZW50IHRvIGJlIGFibGUgdG8gdHJhY2sgaXRzIG93biBmb2N1cyBzdGF0ZVxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIHVzZUhhc0ZvY3VzUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG5cclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEZvY3VzZWRJbm5lcigpOiBib29sZWFuO1xyXG4gICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgZ2V0TGFzdEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldExhc3RGb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhhc0ZvY3VzPFQgZXh0ZW5kcyBOb2RlPih7IG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9OiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VD4pOiBVc2VIYXNGb2N1c1JldHVyblR5cGU8VD4ge1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUhhc0ZvY3VzXCIsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0Rm9jdXNlZCwgc2V0Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25Gb2N1c2VkQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgW2dldEZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbkZvY3VzZWRJbm5lckNoYW5nZWQsIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFtnZXRMYXN0Rm9jdXNlZCwgc2V0TGFzdEZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBbZ2V0TGFzdEZvY3VzZWRJbm5lciwgc2V0TGFzdEZvY3VzZWRJbm5lcl0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfSk7XHJcblxyXG4gICAgY29uc3QgeyBnZXRBY3RpdmVFbGVtZW50LCBnZXRMYXN0QWN0aXZlRWxlbWVudCwgZ2V0V2luZG93Rm9jdXNlZCB9ID0gdXNlQWN0aXZlRWxlbWVudCh7XHJcbiAgICAgICAgZ2V0RG9jdW1lbnQsXHJcbiAgICAgICAgZ2V0V2luZG93LFxyXG4gICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8VXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnNbXCJvbkFjdGl2ZUVsZW1lbnRDaGFuZ2VcIl0+PigoYWN0aXZlRWxlbWVudCwgcHJldkFjdGl2ZUVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZkVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWQgPSAoc2VsZkVsZW1lbnQgIT0gbnVsbCAmJiAoc2VsZkVsZW1lbnQgPT0gYWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkSW5uZXIgPSAoISFzZWxmRWxlbWVudD8uY29udGFpbnMoYWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkKGZvY3VzZWQpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkSW5uZXIoZm9jdXNlZElubmVyKTtcclxuICAgICAgICAgICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlPy4oYWN0aXZlRWxlbWVudCwgcHJldkFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH0sIFtdKSxcclxuICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjazxOb25OdWxsYWJsZTxVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyc1tcIm9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2VcIl0+PigobGFzdEFjdGl2ZUVsZW1lbnQsIHByZXZMYXN0QWN0aXZlRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxmRWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXNlZCA9IChzZWxmRWxlbWVudCAhPSBudWxsICYmIChzZWxmRWxlbWVudCA9PSBsYXN0QWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkSW5uZXIgPSAoISFzZWxmRWxlbWVudD8uY29udGFpbnMobGFzdEFjdGl2ZUVsZW1lbnQgYXMgTm9kZSB8IG51bGwpKTtcclxuICAgICAgICAgICAgc2V0TGFzdEZvY3VzZWQoZm9jdXNlZCk7XHJcbiAgICAgICAgICAgIHNldExhc3RGb2N1c2VkSW5uZXIoZm9jdXNlZElubmVyKTtcclxuICAgICAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZT8uKGxhc3RBY3RpdmVFbGVtZW50LCBwcmV2TGFzdEFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH0sIFtdKSxcclxuICAgICAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2VcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUhhc0ZvY3VzUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KSA9PiB7IHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpOyB9LCBbXSk7XHJcblxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlSGFzRm9jdXNQcm9wcyxcclxuICAgICAgICBnZXRFbGVtZW50LFxyXG4gICAgICAgIGdldEZvY3VzZWQsXHJcbiAgICAgICAgZ2V0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgIGdldExhc3RGb2N1c2VkLFxyXG4gICAgICAgIGdldExhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgZ2V0QWN0aXZlRWxlbWVudCxcclxuICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudCxcclxuICAgICAgICBnZXRXaW5kb3dGb2N1c2VkXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBuZXZlcj4ge1xyXG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IHtcclxuICAgICAgICBvbkFueUdhaW5lZEZvY3VzPygpOiB2b2lkO1xyXG4gICAgICAgIG9uQWxsTG9zdEZvY3VzPygpOiB2b2lkO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxudW1iZXIsIEZvY3VzSW5mbywgbmV2ZXIsIFwic3ViSW5mb1wiPiwgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEU+IHtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+LCBcInVzZVJlZkVsZW1lbnRQcm9wc1wiPiwgT21pdDxVc2VIYXNGb2N1c1JldHVyblR5cGU8RT4sIFwidXNlSGFzRm9jdXNQcm9wc1wiPiB7XHJcbiAgICB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbn1cclxuXHJcbmludGVyZmFjZSBGb2N1c0luZm8ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88bnVtYmVyLCBGb2N1c0luZm8sIG5ldmVyPiB7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZVdpdGhIb29rcyBleHRlbmRzIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZDogPEUgZXh0ZW5kcyBFbGVtZW50PihwYXJhbWV0ZXJzOiBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczxFPikgPT4gVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFJldHVyblR5cGU8RT47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGlsZHJlbkhhdmVGb2N1cyh7IGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH06IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyk6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZVdpdGhIb29rcyB7XHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbiwgdXNlTWFuYWdlZENoaWxkIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBGb2N1c0luZm8sIG5ldmVyPih7IG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH0pO1xyXG4gICAgY29uc3QgYWxsRWxlbWVudHNSZWYgPSB1c2VSZWY8U2V0PE5vZGU+PihuZXcgU2V0KCkpO1xyXG4gICAgY29uc3QgW19nZXRGb2N1c0NvdW50LCBzZXRGb2N1c0NvdW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxudW1iZXI+KHVzZVN0YWJsZUNhbGxiYWNrKChhbnlGb2N1c2VkOiBudW1iZXIsIGFueVByZXZpb3VzbHlGb2N1c2VkOiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgQ2hhbmdpbmcgZm9jdXMgY291bnQgZnJvbSAke2FueVByZXZpb3VzbHlGb2N1c2VkfSB0byAke2FueUZvY3VzZWR9YCk7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoYW55Rm9jdXNlZCA+PSAwICYmIGFueUZvY3VzZWQgPD0gMSk7XHJcblxyXG4gICAgICAgIGlmIChhbnlGb2N1c2VkICYmICFhbnlQcmV2aW91c2x5Rm9jdXNlZClcclxuICAgICAgICAgICAgb25BbnlHYWluZWRGb2N1cz8uKCk7XHJcbiAgICAgICAgaWYgKCFhbnlGb2N1c2VkICYmIGFueVByZXZpb3VzbHlGb2N1c2VkKVxyXG4gICAgICAgICAgICBvbkFsbExvc3RGb2N1cz8uKCk7XHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc3QgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZCA9IHVzZUNhbGxiYWNrKDxFIGV4dGVuZHMgRWxlbWVudD4oeyBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSB9OiBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczxFPik6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlPEU+ID0+IHtcclxuICAgICAgICB1c2VNYW5hZ2VkQ2hpbGQoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIHN1YkluZm86IHt9LCBmbGFncyB9IH0pO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgLi4uaGFzRm9jdXMgIH0gPSB1c2VIYXNGb2N1czxFPih7XHJcbiAgICAgICAgICAgIGdldERvY3VtZW50LFxyXG4gICAgICAgICAgICBnZXRXaW5kb3csXHJcbiAgICAgICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZSxcclxuICAgICAgICAgICAgb25FbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoZTogRSB8IG51bGwsIHByZXY6IEUgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgciA9IG9uRWxlbWVudENoYW5nZT8uKGUsIHByZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxFbGVtZW50c1JlZi5jdXJyZW50LmFkZChlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByPy4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRWxlbWVudHNSZWYuY3VycmVudC5kZWxldGUoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBbb25FbGVtZW50Q2hhbmdlXSksXHJcbiAgICAgICAgICAgIG9uTW91bnQsXHJcbiAgICAgICAgICAgIG9uVW5tb3VudCxcclxuICAgICAgICAgICAgb25Gb2N1c2VkQ2hhbmdlZCxcclxuICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLFxyXG4gICAgICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLFxyXG4gICAgICAgICAgICBvbkxhc3RGb2N1c2VkQ2hhbmdlZCxcclxuICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENoaWxkICR7aW5kZXh9IGlzIGZvY3VzZWRgKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRGb2N1c0NvdW50KHAgPT4gKHAgPz8gMCkgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFmb2N1c2VkICYmIHByZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ2hpbGQgJHtpbmRleH0gaXMgdW5mb2N1c2VkYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Rm9jdXNDb3VudChwID0+IChwID8/IDApIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZD8uKGZvY3VzZWQsIHByZXYpO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQcm9wczogdXNlSGFzRm9jdXNQcm9wcyxcclxuICAgICAgICAgICAgLi4uaGFzRm9jdXNcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlR2xvYmFsSGFuZGxlciB9IGZyb20gXCIuL3VzZS1ldmVudC1oYW5kbGVyXCI7XG5pbXBvcnQgeyB1c2VGb3JjZVVwZGF0ZSB9IGZyb20gXCIuL3VzZS1mb3JjZS11cGRhdGVcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5cblxuXG4vKipcbiAqIEFkZHMgdGhlIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyB0byBjcmVhdGUgYSBcInByZXNzXCItbGlrZSBldmVudCBmb3JcbiAqIGFueSBlbGVtZW50LCB3aGV0aGVyIGl0J3MgYSBuYXRpdmUgPEJVVFRPTj4gb3IgcmVndWxhciA8RElWPi5cbiAqIFxuICogTm90YWJseSwgdGhlIGZvbGxvd2luZyBjYXNlcyBhcmUgY292ZXJlZDpcbiAqICogVGhlIHRhcmdldCBlbGVtZW50IGlzIHByb3Blcmx5IGZvY3VzZWQsIGV2ZW4gb24gaU9TIFNhZmFyaSAoKmVzcGVjaWFsbHkqIG9uIGlPUyBTYWZhcmkpXG4gKiAqIERvdWJsZS1jbGlja3Mgd29uJ3Qgc2VsZWN0IHRleHQuIFxuICogKiBDb252ZXJzZWx5LCBtYW51YWxseSBzZWxlY3RpbmcgdGV4dCB3b24ndCBpbnZva2UgYSBwcmVzcy5cbiAqICogS2V5Ym9hcmQgZXZlbnRzICZtZGFzaDsgYGVudGVyYCBpbW1lZGlhdGVseSBpbnZva2VzIHRoZSBoYW5kbGVyLCB3aGlsZSBgc3BhY2VgIGludm9rZXMgaXQgb24ga2V5dXAuXG4gKiAqIEhhcHRpYyBmZWVkYmFjayAob24sIGxpa2UsIHRoZSBvbmUgYnJvd3NlciBjb21iaW5hdGlvbiB0aGF0IHN1cHBvcnRzIGl0ICZtZGFzaDsgdGhpcyBjYW4gYmUgZGlzYWJsZWQgYXBwLXdpZGUgd2l0aCBgc2V0QnV0dG9uVmlicmF0ZWApXG4gKiBcbiAqIEluIGFkZGl0aW9uLCB3aGVuIHRoZSBDU1MgYDphY3RpdmVgIHBzZXVkby1jbGFzcyB3b3VsZCBhcHBseSB0byBhIG5vcm1hbCBidXR0b25cbiAqIChpLmUuIHdoZW4gaG9sZGluZyB0aGUgc3BhY2ViYXIgb3IgZHVyaW5nIG1vdXNlZG93biksIGB7IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IFwidHJ1ZVwiIH1gXG4gKiBpcyBhZGRlZCB0byB0aGUgcHJvcHMuICBZb3UgY2FuIGVpdGhlciBsZXQgaXQgcGFzcyB0aHJvdWdoIGFuZCBzdHlsZSBpdCB0aHJvdWdoIG5ldyBDU1MsXG4gKiBvciBpbnNwZWN0IHRoZSByZXR1cm5lZCBwcm9wcyBmb3IgaXQgYW5kIGFkZCBlLmcuIGFuIGAuYWN0aXZlYCBjbGFzcyBmb3IgZXhpc3RpbmcgQ1NTXG4gKiBcbiAqIEBwYXJhbSBvbkNsaWNrU3luYyBcbiAqIEBwYXJhbSBleGNsdWRlIFdoZXRoZXIgdGhlIHBvbHlmaWxsIHNob3VsZG4ndCBhcHBseSAoY2FuIHNwZWNpZnkgZm9yIHNwZWNpZmljIGludGVyYWN0aW9ucylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVByZXNzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4ob25DbGlja1N5bmM6ICgoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxFPikgPT4gdm9pZCkgfCBudWxsIHwgdW5kZWZpbmVkLCBleGNsdWRlOiB1bmRlZmluZWQgfCB7IGNsaWNrPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIHNwYWNlPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIGVudGVyPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQgfSkge1xuXG4gICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8RT4oe30pO1xuXG4gICAgLy8gQSBidXR0b24gY2FuIGJlIGFjdGl2YXRlZCBpbiBtdWx0aXBsZSB3YXlzLCBzbyBvbiB0aGUgb2ZmIGNoYW5jZVxuICAgIC8vIHRoYXQgbXVsdGlwbGUgYXJlIHRyaWdnZXJlZCBhdCBvbmNlLCB3ZSBvbmx5ICphY3R1YWxseSogcmVnaXN0ZXJcbiAgICAvLyBhIHByZXNzIG9uY2UgYWxsIG9mIG91ciBcIm9uXCIgc2lnbmFscyBoYXZlIHR1cm5lZCBiYWNrIHRvIFwib2ZmXCIuXG4gICAgLy8gV2UgYXBwcm94aW1hdGUgdGhpcyBieSBqdXN0IGluY3JlbWVudGluZyB3aGVuIGFjdGl2ZSwgYW5kXG4gICAgLy8gZGVjcmVtZW50aW5nIHdoZW4gZGVhY3RpdmF0ZWQuXG4gICAgLy9cbiAgICAvLyBBcyBhbiBlbWVyZ2VuY3kgZmFpbHNhZmUsIHdoZW4gdGhlIGVsZW1lbnQgbG9zZXMgZm9jdXMsXG4gICAgLy8gdGhpcyBpcyByZXNldCBiYWNrIHRvIDAuXG4gICAgY29uc3QgW2FjdGl2ZSwgc2V0QWN0aXZlLCBnZXRBY3RpdmVdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgZm9yY2VVcGRhdGUgPSB1c2VGb3JjZVVwZGF0ZSgpO1xuXG4gICAgLy8gSWYgd2UgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gY2hhbmdlcyB0byBpbmNsdWRlIHRoaXMgZWxlbWVudFxuICAgIC8vIERVUklORyBlLmcuIGEgbW91c2Vkb3duLCB0aGVuIHdlIGRvbid0IHdhbnQgdGhlIG1vdXNldXAgdG8gXCJjb3VudFwiLCBhcyBpdCB3ZXJlLFxuICAgIC8vIGJlY2F1c2UgaXRzIG9ubHkgcHVycG9zZSB3YXMgc2VsZWN0aW5nIHRleHQsIG5vdCBjbGlja2luZyBidXR0b25zLlxuICAgIC8vXG4gICAgLy8gVG8gY2F0Y2ggdGhpcywgYW55IHRpbWUgdGhlIHRleHQgc2VsZWN0aW9uIGluY2x1ZGVzIHVzIHdoaWxlIGluIHRoZSBtaWRkbGVcbiAgICAvLyBvZiBhIGNsaWNrLCB0aGlzIGZsYWcgaXMgc2V0LCB3aGljaCBjYW5jZWxzIHRoZSBhY3RpdmF0aW9uIG9mIGEgcHJlc3MuXG4gICAgLy8gVGhlIGZsYWcgaXMgcmVzZXQgYW55IHRpbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBvciB0aGUgYnV0dG9uIGlzXG4gICAgLy8gbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICBjb25zdCBbdGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSwgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxEYXRlIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgcHNldWRvQWN0aXZlID0gKGFjdGl2ZSAmJiAodGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSA9PSBudWxsKSk7XG5cbiAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInNlbGVjdGlvbmNoYW5nZVwiLCBfID0+IHtcbiAgICAgICAgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZShwcmV2ID0+IG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZ2V0RWxlbWVudCgpKSA9PSAwID8gbnVsbCA6IHByZXYgIT0gbnVsbCA/IHByZXYgOiBuZXcgRGF0ZSgpKTtcbiAgICB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmUgPT0gMClcbiAgICAgICAgICAgIHNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUobnVsbCk7XG5cbiAgICB9LCBbYWN0aXZlID09IDBdKTtcblxuICAgIGNvbnN0IG9uQWN0aXZlU3RhcnQgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25DbGlja1N5bmM+PigoXykgPT4ge1xuICAgICAgICBzZXRBY3RpdmUoYSA9PiArK2EpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb25BY3RpdmVTdG9wID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2xpY2tTeW5jPj4oKGUpID0+IHtcbiAgICAgICAgc2V0QWN0aXZlKGEgPT4gTWF0aC5tYXgoMCwgLS1hKSk7XG5cbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB0aW1lRGlmZmVyZW5jZSA9ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lID09IG51bGwgPyBudWxsIDogK2N1cnJlbnRUaW1lIC0gK3RleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUpO1xuICAgICAgICBjb25zdCBjaGFyYWN0ZXJzU2VsZWN0ZWQgPSBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGdldEVsZW1lbnQoKSlcblxuICAgICAgICAvLyBJZiB3ZSdyZSBzZWxlY3RpbmcgdGV4dCAoaGV1cmlzdGljYWxseSBkZXRlcm1pbmVkIGJ5IHNlbGVjdGluZyBmb3IgbG9uZ2VyIHRoYW4gMS80IGEgc2Vjb25kLCBvciBtb3JlIHRoYW4gMiBjaGFyYWN0ZXJzKVxuICAgICAgICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBwcmVzcyBldmVudC5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbWVhc3VyZSBnbHlwaHMgaW5zdGVhZCBvZiBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY2hhcmFjdGVyc1NlbGVjdGVkID4gMSB8fCAoKHRpbWVEaWZmZXJlbmNlID8/IDApID4gMjUwICYmIGNoYXJhY3RlcnNTZWxlY3RlZCA+PSAxKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdldEFjdGl2ZSgpIDw9IDApIHtcbiAgICAgICAgICAgIGhhbmRsZVByZXNzKGUpO1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUoKTsgIC8vIFRPRE86IFJlbW92ZSB3aGVuIGlzc3VlIHJlc29sdmVkIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzM3MzFcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgaGFuZGxlUHJlc3MgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25DbGlja1N5bmM+PigoZSkgPT4ge1xuICAgICAgICBpZiAob25DbGlja1N5bmMpIHtcblxuICAgICAgICAgICAgLy8gTm90ZTogVGhlIGVsZW1lbnQgaXMgZm9jdXNlZCBoZXJlIGJlY2F1c2Ugb2YgaU9TIFNhZmFyaS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJdCdzIGFsd2F5cyBpT1MgU2FmYXJpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGlPUyBTYWZhcmkgKHRlc3RlZCBvbiAxMikgZG93bnJpZ2h0IHJlZnVzZXMgdG8gYWxsb3cgXG4gICAgICAgICAgICAvLyBlbGVtZW50cyB0byBiZSBtYW51YWxseSBmb2N1c2VkIFVOTEVTUyBpdCBoYXBwZW5zIHdpdGhpblxuICAgICAgICAgICAgLy8gYW4gZXZlbnQgaGFuZGxlciBsaWtlIHRoaXMuICBJdCBhbHNvIGRvZXNuJ3QgZm9jdXNcbiAgICAgICAgICAgIC8vIGJ1dHRvbnMgYnkgZGVmYXVsdCB3aGVuIGNsaWNrZWQsIHRhcHBlZCwgZXRjLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIElmIGl0IGJlY29tZXMgcHJvYmxlbWF0aWMgdGhhdCBidXR0b24tbGlrZXMgZXhwbGljaXRseSBiZWNvbWVcbiAgICAgICAgICAgIC8vIGZvY3VzZWQgd2hlbiB0aGV5IGFyZSBwcmVzc2VkLCB0aGVuIGFuIGFsdGVybmF0aXZlIHNvbHV0aW9uIGZvclxuICAgICAgICAgICAgLy8gdGhlIHF1ZXN0aW9uIG9mIFwiaG93IGRvIG1lbnUgYnV0dG9ucyBrZWVwIHRoZWlyIG1lbnVzIG9wZW5cIlxuICAgICAgICAgICAgLy8gYW5kIG90aGVyIGZvY3VzLXJlbGF0ZWQgbm9uc2Vuc2UgbmVlZHMgdG8gYmUgZmlndXJlZCBvdXQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRm9yIGlPUyBTYWZhcmkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIFwiZm9jdXNcIiBpbiAoZWxlbWVudCBhcyBFdmVudFRhcmdldCBhcyBIVE1MRWxlbWVudCkpXG4gICAgICAgICAgICAgICAgKGVsZW1lbnQgYXMgRXZlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQgfCBudWxsKT8uZm9jdXMoKTtcblxuICAgICAgICAgICAgLy8gV2hhdGV2ZXIgdGhlIGJyb3dzZXIgd2FzIGdvaW5nIHRvIGRvIHdpdGggdGhpcyBldmVudCxcbiAgICAgICAgICAgIC8vIGZvcmdldCBpdC4gV2UncmUgdHVybmluZyBpdCBpbnRvIGEgXCJwcmVzc1wiIGV2ZW50LlxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAvLyBBbHNvIHN0b3AgYW55b25lIGVsc2UgZnJvbSBsaXN0ZW5pbmcgdG8gdGhpcyBldmVudCxcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGV4cGxpY2l0bHkgaGFuZGxpbmcgaXQuXG4gICAgICAgICAgICAvLyAoTm90YWJseSwgdGhpcyBhbGxvd3MgbGFiZWxzIHRvIHdyYXAgaW5wdXRzLCB3aXRoIHRoZW1cbiAgICAgICAgICAgIC8vIGJvdGggaGF2aW5nIHByZXNzIGV2ZW50IGhhbmRsZXJzLCB3aXRob3V0IGRvdWJsZS1maXJpbmcpXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBIYXB0aWMgZmVlZGJhY2sgZm9yIHRoaXMgcHJlc3MgZXZlbnRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZG9lc24ndCB0aHJvdyxcbiAgICAgICAgICAgICAgICAvLyBidXQgd2Ugc2hvdWxkIGd1YXJkIGFnYWluc3QgdXNlciBpbXBsZW1lbnRhdGlvbnMgdGhhdCBjb3VsZC5cbiAgICAgICAgICAgICAgICBwdWxzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHkgY2FsbCBvdXIgaGFuZGxlci5cbiAgICAgICAgICAgICAgICBvbkNsaWNrU3luYyhlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBvbk1vdXNlRG93biA9IGV4Y2x1ZGVzKFwiY2xpY2tcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+KSA9PiB7XG4gICAgICAgIC8vIFN0b3AgZG91YmxlIGNsaWNrcyBmcm9tIHNlbGVjdGluZyB0ZXh0IGluIGFuIGNvbXBvbmVudCB0aGF0J3MgKnN1cHBvc2VkKiB0byBiZSBhY3RpbmcgbGlrZSBhIGJ1dHRvbixcbiAgICAgICAgLy8gYnV0IGFsc28gZG9uJ3QgcHJldmVudCB0aGUgdXNlciBmcm9tIHNlbGVjdGluZyB0aGF0IHRleHQgbWFudWFsbHkgaWYgdGhleSByZWFsbHkgd2FudCB0b1xuICAgICAgICAvLyAod2hpY2ggdXNlci1zZWxlY3Q6IG5vbmUgd291bGQgZG8sIGJ1dCBjYW5jZWxsaW5nIGEgZG91YmxlIGNsaWNrIG9uIG1vdXNlRG93biBkb2Vzbid0KVxuICAgICAgICBpZiAoZS5kZXRhaWwgPiAxKVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cbiAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwKVxuICAgICAgICAgICAgb25BY3RpdmVTdGFydChlKTtcbiAgICB9XG4gICAgY29uc3Qgb25Nb3VzZVVwID0gZXhjbHVkZXMoXCJjbGlja1wiLCBleGNsdWRlKSA/IHVuZGVmaW5lZCA6IChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwICYmIGFjdGl2ZSA+IDApXG4gICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uQmx1ciA9IChfOiBoLkpTWC5UYXJnZXRlZEV2ZW50PEU+KSA9PiB7XG4gICAgICAgIHNldEFjdGl2ZSgwKTtcbiAgICB9XG5cblxuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9IGV4Y2x1ZGVzKFwiY2xpY2tcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiBvbkJsdXI7XG5cbiAgICBjb25zdCBvbktleURvd24gPSBleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpICYmIGV4Y2x1ZGVzKFwiZW50ZXJcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGlmIChlLmtleSA9PSBcIiBcIiAmJiBvbkNsaWNrU3luYyAmJiAhZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgYWN0aXZhdGUgaXQgb24gYSBzcGFjZSBrZXlkb3duXG4gICAgICAgICAgICAvLyBidXQgd2UgZG8gcHJldmVudERlZmF1bHQgdG8gc3RvcCB0aGUgcGFnZSBmcm9tIHNjcm9sbGluZy5cbiAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZS5rZXkgPT0gXCJFbnRlclwiICYmICFleGNsdWRlcyhcImVudGVyXCIsIGV4Y2x1ZGUpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xuICAgICAgICAgICAgb25BY3RpdmVTdG9wKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb25LZXlVcCA9IGV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGlmIChlLmtleSA9PSBcIiBcIiAmJiAhZXhjbHVkZXMoXCJzcGFjZVwiLCBleGNsdWRlKSlcbiAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbkNsaWNrID0gKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChlLmRldGFpbCA+IDEpIHtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVzZVByZXNzUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSB7XG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPihwcm9wcywgdXNlUmVmRWxlbWVudFByb3BzKCh7XG4gICAgICAgICAgICBvbktleURvd24sXG4gICAgICAgICAgICBvbktleVVwLFxuICAgICAgICAgICAgb25CbHVyLFxuICAgICAgICAgICAgb25Nb3VzZURvd24sXG4gICAgICAgICAgICBvbk1vdXNlVXAsXG4gICAgICAgICAgICBvbk1vdXNlTGVhdmUsXG4gICAgICAgICAgICBvbkNsaWNrLFxuICAgICAgICAgICAgc3R5bGU6ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lICE9IG51bGwpID8geyBjdXJzb3I6IFwidGV4dFwiIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAuLi57IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IHBzZXVkb0FjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gYXMge31cbiAgICAgICAgfSkpKTtcbiAgICB9XG59XG5cblxuXG5cbi8qKlxuICogc2VsZWN0aW9uLmNvbnRhaW5zTm9kZSBkb2Vzbid0IGFjY291bnQgZm9yIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCxcbiAqIHNvIGhlcmUncyBhIHdvcmthcm91bmQgZm9yIHRoYXQuXG4gKiBcbiAqIFdlIGFsc28gb25seSBsb29rIGZvciB0aGUgc2VsZWN0aW9uIGVuZCB0byBvbmx5IGNhdGNoIHRoZSBcbiAqIGVzc2Vuc2Ugb2YgYSBub24tZXhpc3RhbnQgXCJzZWxlY3Rpb25zdG9wXCIgZXZlbnQuXG4gKiBcbiAqIEBwYXJhbSBlbGVtZW50IFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZWxlbWVudDogRXZlbnRUYXJnZXQgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHNlbGVjdGlvbj8ucmFuZ2VDb3VudCA/PyAwKTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbiEuZ2V0UmFuZ2VBdChpKSE7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhyYW5nZS5lbmRDb250YWluZXIpICYmICFzZWxlY3Rpb24/LmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbiEudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn1cblxuXG5sZXQgcHVsc2UgPSAoKFwidmlicmF0ZVwiIGluIG5hdmlnYXRvcikgJiYgKG5hdmlnYXRvci52aWJyYXRlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSA/ICgoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMCkpIDogKCgpID0+IHsgfSk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBlbmFibGUvZGlzYWJsZSBidXR0b24gdmlicmF0aW9uIHB1bHNlcyBvbiBhbiBhcHAtd2lkZSBzY2FsZS5cbiAqIFxuICogXG4gKiBAcGFyYW0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcnVuIHdoZW4gYSBidXR0b24gaXMgdGFwcGVkLlxuICogKERlZmF1bHQgaXMgYCgpID0+IG5hdmlnYXRvci52aWJyYXRlKDEwKWAgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LCBhIG5vb3Agb3RoZXJ3aXNlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJlc3NWaWJyYXRlKGZ1bmM6ICgpID0+IHZvaWQpIHtcbiAgICBwdWxzZSA9IGZ1bmM7XG59XG5cblxuXG5mdW5jdGlvbiBleGNsdWRlcyh0YXJnZXQ6IFwiY2xpY2tcIiB8IFwic3BhY2VcIiB8IFwiZW50ZXJcIiwgZXhjbHVkZTogdW5kZWZpbmVkIHwgeyBjbGljaz86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBzcGFjZT86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBlbnRlcj86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkIH0pIHtcbiAgICBpZiAoZXhjbHVkZT8uW3RhcmdldF0pXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWxlbWVudFNpemUsIHVzZUVsZW1lbnRTaXplIH0gZnJvbSBcIi4vdXNlLWVsZW1lbnQtc2l6ZVwiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xuXG4vL2V4cG9ydCB0eXBlIEJsb2NrRmxvd0RpcmVjdGlvbiA9IFwiZG93bndhcmRzXCIgfCBcImxlZnR3YXJkc1wiIHwgXCJyaWdodHdhcmRzXCI7XG5leHBvcnQgdHlwZSBQaHlzaWNhbERpcmVjdGlvbiA9IFwibHRyXCIgfCBcInJ0bFwiIHwgXCJ0dGJcIiB8IFwiYnR0XCI7XG5leHBvcnQgdHlwZSBQaHlzaWNhbE9yaWVudGF0aW9uID0gXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCI7XG5leHBvcnQgdHlwZSBQaHlzaWNhbFNpemUgPSBcIndpZHRoXCIgfCBcImhlaWdodFwiO1xuXG5leHBvcnQgdHlwZSBMb2dpY2FsT3JpZW50YXRpb24gPSBcImlubGluZVwiIHwgXCJibG9ja1wiO1xuXG4vL2V4cG9ydCB0eXBlIExpbmVPcmllbnRhdGlvbiA9IFwidXByaWdodFwiIHwgXCJsZWZ0cmlnaHRcIiB8IFwiZG93bnJpZ2h0XCIgfCBcInJpZ2h0cmlnaHRcIjtcblxudHlwZSBXcml0aW5nTW9kZSA9IFwiaG9yaXpvbnRhbC10YlwiIHwgXCJ2ZXJ0aWNhbC1sclwiIHwgXCJzaWRld2F5cy1ybFwiIHwgXCJ2ZXJ0aWNhbC1ybFwiIHwgXCJzaWRld2F5cy1sclwiO1xudHlwZSBEaXJlY3Rpb24gPSBcImx0clwiIHwgXCJydGxcIjtcbnR5cGUgVGV4dE9yaWVudGF0aW9uID0gXCJtaXhlZFwiIHwgXCJ1cHJpZ2h0XCIgfCBcInNpZGV3YXlzXCI7XG5cbmZ1bmN0aW9uIGNhcGl0YWxpemU8VCBleHRlbmRzIHN0cmluZz4oc3RyOiBUKTogQ2FwaXRhbGl6ZTxUPiB7XG4gICAgcmV0dXJuIChzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSkpIGFzIENhcGl0YWxpemU8VD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTG9naWNhbERpcmVjdGlvblBhcmFtZXRlcnMge1xuICAgIG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZT8oaW5mbzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dpY2FsRWxlbWVudFNpemUge1xuICAgIGNsaWVudElubGluZVNpemU6IG51bWJlcjtcbiAgICBzY3JvbGxJbmxpbmVTaXplOiBudW1iZXI7XG4gICAgb2Zmc2V0SW5saW5lU2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNsaWVudEJsb2NrU2l6ZTogbnVtYmVyO1xuICAgIHNjcm9sbEJsb2NrU2l6ZTogbnVtYmVyO1xuICAgIG9mZnNldEJsb2NrU2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNsaWVudElubGluZUluc2V0OiBudW1iZXI7XG4gICAgc2Nyb2xsSW5saW5lSW5zZXQ6IG51bWJlcjtcbiAgICBvZmZzZXRJbmxpbmVJbnNldDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGNsaWVudEJsb2NrSW5zZXQ6IG51bWJlcjtcbiAgICBzY3JvbGxCbG9ja0luc2V0OiBudW1iZXI7XG4gICAgb2Zmc2V0QmxvY2tJbnNldDogbnVtYmVyIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEluc3BlY3RzIHRoZSBlbGVtZW50J3Mgc3R5bGUgYW5kIGRldGVybWluZXMgdGhlIGxvZ2ljYWwgZGlyZWN0aW9uIHRoYXQgdGV4dCBmbG93cy5cbiAqIFxuICogQ2VydGFpbiBDU1MgcHJvcGVydGllcywgbGlrZSBgYmxvY2stc2l6ZWAsIHJlc3BlY3QgdGhlIGN1cnJlbnQgd3JpdGluZyBtb2RlIGFuZCB0ZXh0IGRpcmVjdGlvbi5cbiAqIEJ1dCBgdHJhbnNmb3JtYCwgYGNsaXBgLCBldGMuIGRvbid0LlxuICogXG4gKiBUaGlzIGlzIHByb3ZpZGVkIHNvIHRoYXQgQ1NTIHByb3BlcnRpZXMgY2FuIGNvbnNpc3RlbnRseSB1c2UgdGhvc2UgbG9naWNhbCBwcm9wZXJ0aWVzLlxuICogXG4gKiBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy13cml0aW5nLW1vZGVzLyNsb2dpY2FsLXRvLXBoeXNpY2FsXG4gKiBcbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxuICogKiBgZ2V0TG9naWNhbERpcmVjdGlvbmA6IHJldHJpZXZlcyBhIGBMb2dpY2FsRGlyZWN0aW9uSW5mb2AgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50LiAoRnVuY3Rpb24gaXMgY29uc3RhbnQgYmV0d2VlbiByZW5kZXJzKVxuICogKiBgY29udmVydEVsZW1lbnRTaXplYDogV2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUVsZW1lbnRTaXplYCwgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSB0aGUgbG9naWNhbCBzaXplIG9mIGFuIGVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgcGh5c2ljYWwgc2l6ZS4gXG4gKiAqIGBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb25gOiBCYXNlZCBvbiB0aGUgY3VycmVudCBkaXJlY3Rpb24sIGNvbnZlcnRzIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIiB0byBcImlubGluZVwiIG9yIFwiYmxvY2tcIi5cbiAqICogYGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb25gOiAgQmFzZWQgb24gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBjb252ZXJ0cyBcImlubGluZVwiIG9yIFwiYmxvY2tcIiB0byBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2dpY2FsRGlyZWN0aW9uPFQgZXh0ZW5kcyBFbGVtZW50Pih7IG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZSB9OiBVc2VMb2dpY2FsRGlyZWN0aW9uUGFyYW1ldGVycyk6IFVzZUxvZ2ljYWxEaXJlY3Rpb25SZXR1cm5UeXBlPFQ+IHtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUxvZ2ljYWxEaXJlY3Rpb25cIiwgb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlKTtcblxuICAgIGNvbnN0IFtnZXRDb21wdXRlZFN0eWxlcywgc2V0Q29tcHV0ZWRTdHlsZXNdID0gdXNlUGFzc2l2ZVN0YXRlPENTU1N0eWxlRGVjbGFyYXRpb24gfCBudWxsPihudWxsLCByZXR1cm5OdWxsKTtcblxuXG4gICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8VD4oe1xuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlbGVtZW50OiBUIHwgbnVsbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRDb21wdXRlZFN0eWxlcyh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtdKVxuICAgIH0pO1xuXG4gICAgLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gcmVmcmVzaCB3aGljaCB3cml0aW5nIG1vZGUgd2UgaGF2ZSBvbmNlIG1vdW50ZWQuXG4gICAgLy8gICBBLiBUaGVyZSdzIG5vIHdheSB0byB3YXRjaCBmb3IgQ1NTIHN0eWxlIGNoYW5nZXNcbiAgICAvLyAgIEIuIENhbGxpbmcgZ2V0Q29tcHV0ZWRTdHlsZSBhZnRlciBldmVyeSByZW5kZXIgZm9yIGV2ZXJ5IGVsZW1lbnQgZ2V0cyBleHBlbnNpdmUgZmFzdCBhbmRcbiAgICAvLyAgIEMuIElzIG5vdCBuZWNlc3NhcnkgZm9yIG1vc3QgdXNlIGNhc2VzIHRoYXQgd2lsbCBuZXZlciBzd2l0Y2ggd3JpdGluZy1tb2RlIHdpdGhpbiBhIHNpbmdsZSBjb21wb25lbnRcbiAgICAvLyAgICAgIChUaG9zZSB0aGF0IGRvIHdpbGwgbmVlZCB0byBtb3VudCBhbmQgdW5tb3VudCB0aGUgY29tcG9uZW50IHRoYXQgdXNlcyBpdClcbiAgICAvL1xuICAgIC8vIEFzIGEgc29sdXRpb24sIGhlcmUncyBhIGNoZWFwIHdvcmthcm91bmQgdGhhdCBjaGVja3Mgd2hlbiB0aGUgZWxlbWVudCdzIHNpemUgaGFzIGNoYW5nZWQsXG4gICAgLy8gYW5kIGlmIHNvLCB0ZXN0cyBpZiB0aGUgd3JpdGluZyBtb2RlIGhhcyBjaGFuZ2VkIHRvby5cbiAgICAvL1xuICAgIC8vIFRoaXMgd2lsbCB3b3JrIGZvciBhdCBsZWFzdCBzb21lIG51bWJlciBvZiBjYXNlcywgYnV0IGEgYmV0dGVyIHNvbHV0aW9uIGlzIHN0aWxsIG5lZWRlZC5cbiAgICBjb25zdCB7IHVzZUVsZW1lbnRTaXplUHJvcHMgfSA9IHVzZUVsZW1lbnRTaXplPFQ+KHsgb25TaXplQ2hhbmdlOiB1c2VDYWxsYmFjayhfID0+IG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZT8uKGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCkpLCBbXSkgfSlcblxuICAgIGNvbnN0IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGVzKCk7XG4gICAgICAgIGlmIChjb21wdXRlZFN0eWxlcykge1xuICAgICAgICAgICAgY29uc3QgdyA9IGNvbXB1dGVkU3R5bGVzLndyaXRpbmdNb2RlIGFzIFdyaXRpbmdNb2RlO1xuICAgICAgICAgICAgbGV0IGQgPSBjb21wdXRlZFN0eWxlcy5kaXJlY3Rpb24gYXMgRGlyZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgdCA9IGNvbXB1dGVkU3R5bGVzLnRleHRPcmllbnRhdGlvbiBhcyBUZXh0T3JpZW50YXRpb247XG5cbiAgICAgICAgICAgIGlmICh0ID09IFwidXByaWdodFwiKVxuICAgICAgICAgICAgICAgIGQgPSBcImx0clwiO1xuXG4gICAgICAgICAgICByZXR1cm4gKHsgLi4uV3JpdGluZ01vZGVzW3cgfHwgXCJob3Jpem9udGFsLXRiXCJdW2QgfHwgXCJsdHJcIl0gfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCBbXSlcblxuICAgIC8vY29uc3QgW2dldExvZ2ljYWxEaXJlY3Rpb25JbmZvLCBzZXRMb2dpY2FsRGlyZWN0aW9uSW5mb10gPSB1c2VQYXNzaXZlU3RhdGU8TG9naWNhbERpcmVjdGlvbkluZm8+KG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZSk7XG5cbiAgICBjb25zdCBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb24gPSB1c2VDYWxsYmFjaygoZWxlbWVudE9yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gZWxlbWVudE9yaWVudGF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIFwiaW5saW5lXCI7XG4gICAgICAgIHJldHVybiBcImJsb2NrXCI7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgY29udmVydFRvUGh5c2ljYWxTaWRlID0gdXNlQ2FsbGJhY2soKHNpZGU6IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcIiB8IFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIgPT4ge1xuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XG5cbiAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stc3RhcnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5ibG9ja0RpcmVjdGlvbiA/PyBcInR0YlwiKVswXSBhcyBcInRcIiB8IFwiYlwiIHwgXCJsXCIgfCBcInJcIl07XG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uYmxvY2tEaXJlY3Rpb24gPz8gXCJ0dGJcIilbMl0gYXMgXCJ0XCIgfCBcImJcIiB8IFwibFwiIHwgXCJyXCJdO1xuXG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uaW5saW5lRGlyZWN0aW9uID8/IFwibHRyXCIpWzBdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uaW5saW5lRGlyZWN0aW9uID8/IFwibHRyXCIpWzJdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgY29udmVydFRvTG9naWNhbFNpZGUgPSB1c2VDYWxsYmFjaygoc2lkZTogXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKTogXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiIHwgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIiA9PiB7XG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xuICAgICAgICAgICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJ0dGJcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uaW5saW5lRGlyZWN0aW9uID09PSBcImJ0dFwiID8gXCJpbmxpbmUtc3RhcnRcIiA6IFwiaW5saW5lLWVuZFwiO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uYmxvY2tEaXJlY3Rpb24gPT09IFwicnRsXCIgPyBcImJsb2NrLXN0YXJ0XCIgOiBcImJsb2NrLWVuZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uYmxvY2tEaXJlY3Rpb24gPT09IFwidHRiXCIgPyBcImJsb2NrLXN0YXJ0XCIgOiBcImJsb2NrLWVuZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJidHRcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5pbmxpbmVEaXJlY3Rpb24gPT09IFwicnRsXCIgPyBcImlubGluZS1zdGFydFwiIDogXCJpbmxpbmUtZW5kXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xuICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UpO1xuICAgICAgICByZXR1cm4gXCJpbmxpbmUtc3RhcnRcIjtcblxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbiA9IHVzZUNhbGxiYWNrKChlbGVtZW50T3JpZW50YXRpb246IExvZ2ljYWxPcmllbnRhdGlvbiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgaWYgKGVsZW1lbnRPcmllbnRhdGlvbiA9PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PSBcImhvcml6b250YWxcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XG4gICAgICAgICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbj8uYmxvY2tPcmllbnRhdGlvbiA9PSBcInZlcnRpY2FsXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcblxuICAgICAgICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgY29udmVydEVsZW1lbnRTaXplID0gdXNlQ2FsbGJhY2soKGVsZW1lbnRTaXplOiBFbGVtZW50U2l6ZSwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKTogTG9naWNhbEVsZW1lbnRTaXplIHwgbnVsbCA9PiB7XG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgeyBpbmxpbmVTaXplLCBibG9ja1NpemUsIGlubGluZURpcmVjdGlvbiwgYmxvY2tEaXJlY3Rpb24gfSA9IGRpcmVjdGlvbjtcblxuICAgICAgICAgICAgLy8gU2l6ZSBpcyByZWxhdGl2ZWx5IHNpbXBsZVxuICAgICAgICAgICAgY29uc3QgY2xpZW50SW5saW5lU2l6ZSA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoaW5saW5lU2l6ZSl9YF07XG4gICAgICAgICAgICBjb25zdCBjbGllbnRCbG9ja1NpemUgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGJsb2NrU2l6ZSl9YF07XG5cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldElubGluZVNpemUgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGlubGluZVNpemUpfWBdO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0QmxvY2tTaXplID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShibG9ja1NpemUpfWBdO1xuXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxJbmxpbmVTaXplID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShpbmxpbmVTaXplKX1gXTtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEJsb2NrU2l6ZSA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoYmxvY2tTaXplKX1gXTtcblxuXG5cblxuICAgICAgICAgICAgY29uc3QgZjEgPSBnZXRQaHlzaWNhbExlZnRUb3AoaW5saW5lRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGYyID0gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShpbmxpbmVEaXJlY3Rpb24pO1xuXG4gICAgICAgICAgICBjb25zdCBmMyA9IGdldFBoeXNpY2FsTGVmdFRvcChibG9ja0RpcmVjdGlvbik7XG4gICAgICAgICAgICBjb25zdCBmNCA9IGdldFBoeXNpY2FsUmlnaHRCb3R0b20oYmxvY2tEaXJlY3Rpb24pO1xuXG5cbiAgICAgICAgICAgY29uc3QgY2xpZW50SW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGYxKX1gXSArICghZjIgPyAwIDogZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmMil9YF0pO1xuICAgICAgICAgICBjb25zdCBzY3JvbGxJbmxpbmVJbnNldCA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjEpfWBdICsgKCFmMiA/IDAgOiBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGYyKX1gXSk7XG4gICAgICAgICAgIGNvbnN0IG9mZnNldElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMSl9YF0gPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogKGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjEpfWBdISArICghZjIgPyAwIDogZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMil9YF0hKSk7XG5cblxuICAgICAgICAgICAgY29uc3QgY2xpZW50QmxvY2tJbnNldCA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjMpfWBdICsgKCFmNCA/IDAgOiBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGY0KX1gXSk7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMyl9YF0gKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjQpfWBdKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldEJsb2NrSW5zZXQgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYzKX1gXSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAoZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMyl9YF0hICsgKCFmNCA/IDAgOiBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGY0KX1gXSEpKTtcblxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsaWVudElubGluZVNpemUsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW5saW5lU2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRJbmxpbmVTaXplLFxuICAgICAgICAgICAgICAgIGNsaWVudEJsb2NrU2l6ZSxcbiAgICAgICAgICAgICAgICBzY3JvbGxCbG9ja1NpemUsXG4gICAgICAgICAgICAgICAgb2Zmc2V0QmxvY2tTaXplLFxuICAgICAgICAgICAgICAgIGNsaWVudElubGluZUluc2V0LFxuICAgICAgICAgICAgICAgIHNjcm9sbElubGluZUluc2V0LFxuICAgICAgICAgICAgICAgIG9mZnNldElubGluZUluc2V0LFxuICAgICAgICAgICAgICAgIGNsaWVudEJsb2NrSW5zZXQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsQmxvY2tJbnNldCxcbiAgICAgICAgICAgICAgICBvZmZzZXRCbG9ja0luc2V0LFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHM6IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VFbGVtZW50U2l6ZVByb3BzKHByb3BzKSksIFtdKSxcbiAgICAgICAgZ2V0RWxlbWVudCxcbiAgICAgICAgZ2V0TG9naWNhbERpcmVjdGlvbkluZm8sXG4gICAgICAgIGNvbnZlcnRUb0xvZ2ljYWxTaXplOiBjb252ZXJ0RWxlbWVudFNpemUsXG4gICAgICAgIGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbixcbiAgICAgICAgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbixcbiAgICAgICAgY29udmVydFRvTG9naWNhbFNpZGUsXG4gICAgICAgIGNvbnZlcnRUb1BoeXNpY2FsU2lkZVxuICAgIH07XG59XG5cbi8vIFBvc2l0aW9uIHJlcXVpcmVzIHVzIHRvIHNvbWV0aW1lcyB1c2Ugb25lIHByb3BlcnR5IChsaWtlIGBsZWZ0YClcbi8vIG9yIHNvbWV0aW1lcyB0d28gKGxpa2UgYGxlZnRgICsgYHdpZHRoYClcbmZ1bmN0aW9uIGdldFBoeXNpY2FsTGVmdFRvcChkaXI6IFBoeXNpY2FsRGlyZWN0aW9uKSB7IGlmIChkaXIgPT09IFwibHRyXCIgfHwgZGlyID09IFwicnRsXCIpIHJldHVybiBcImxlZnRcIjsgcmV0dXJuIFwidG9wXCI7IH1cbmZ1bmN0aW9uIGdldFBoeXNpY2FsUmlnaHRCb3R0b20oZGlyOiBQaHlzaWNhbERpcmVjdGlvbikgeyBpZiAoZGlyID09PSBcInJ0bFwiKSByZXR1cm4gXCJ3aWR0aFwiOyBpZiAoZGlyID09PSBcImJ0dFwiKSByZXR1cm4gXCJoZWlnaHRcIjsgcmV0dXJuIG51bGw7IH1cblxuLy8gSGVscGVyIGZvciBleHRyYWN0aW5nIGluZm8gZnJvbSBcImx0clwiLCBcInR0YlwiLCBldGMuXG5jb25zdCBNID0ge1xuICAgIHQ6IFwidG9wXCIsXG4gICAgYjogXCJib3R0b21cIixcbiAgICBsOiBcImxlZnRcIixcbiAgICByOiBcInJpZ2h0XCJcbn0gYXMgY29uc3Q7XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMb2dpY2FsRGlyZWN0aW9uUmV0dXJuVHlwZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRFbGVtZW50OiAoKSA9PiBUIHwgbnVsbDtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvOiAoKSA9PiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiB0aGUgRWxlbWVudFNpemUgaW5mbyBmcm9tIHVzZUVsZW1lbnRTaXplLCBjb252ZXJ0cyBhbGwgdGhvc2UgcGh5c2ljYWwgcHJvcGVydGllcyB0byB0aGVpciBsb2dpY2FsIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgY29udmVydFRvTG9naWNhbFNpemU6IChlbGVtZW50U2l6ZTogRWxlbWVudFNpemUsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gTG9naWNhbEVsZW1lbnRTaXplIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIGBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcImAgaW50byBgXCJpbmxpbmVcIiB8IFwiYmxvY2tcImBcbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uOiAoZWxlbWVudE9yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaW5saW5lXCIgfCBcImJsb2NrXCI7XG5cbiAgICAvKipcbiAgICAgKiBUdXJucyBgXCJpbmxpbmVcIiB8IFwiYmxvY2tcImAgaW50byBgXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCJgXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb246IChlbGVtZW50T3JpZW50YXRpb246IExvZ2ljYWxPcmllbnRhdGlvbiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIjtcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIGBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiYCBpbnRvIGBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiIHwgXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiYFxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBjb252ZXJ0VG9Mb2dpY2FsU2lkZTogKHNpZGU6IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiIHwgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIjtcblxuICAgIC8qKlxuICAgICAqIFR1cm5zIGBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiIHwgXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiYCBpbnRvIGBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiYFxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBjb252ZXJ0VG9QaHlzaWNhbFNpZGU6IChzaWRlOiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCI7XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2ljYWxEaXJlY3Rpb25JbmZvIHtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBkaXJlY3Rpb24gdGV4dCBmbG93cywgZ2x5cGggYnkgZ2x5cGguICBCeSBmYXIgdGhlIG1vc3QgY29tcGxleCBwcm9wZXJ0eS5cbiAgICAgKiBcbiAgICAgKiB8YHdyaXRpbmctbW9kZWB8YGRpcmVjdGlvbmB8UmVzdWx0fFxuICAgICAqIHwtLS0tLXwtLS0tLXwtLS0tLXxcbiAgICAgKiB8YGhvcml6b250YWwtdGJgfGBsdHJgfGBsdHJgfFxuICAgICAqIHxgaG9yaXpvbnRhbC10YmB8YHJ0bGB8YHJ0bGB8XG4gICAgICogfGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgfGBsdHJgfGB0dGJgfFxuICAgICAqIHxgdmVydGljYWwtcmxgICYgYHNpZGV3YXlzLXJsYHxgcnRsYHxgYnR0YHxcbiAgICAgKiB8YHZlcnRpY2FsLWxyYHxgbHRyYHxgdHRiYHxcbiAgICAgKiB8YHZlcnRpY2FsLWxyYHxgcnRsYHxgYnR0YHxcbiAgICAgKiB8YHNpZGV3YXlzLWxyYHxgbHRyYHxgYnR0YHxcbiAgICAgKiB8YHNpZGV3YXlzLWxyYHxgcnRsYHxgdHRiYHxcbiAgICAgKi9cbiAgICBpbmxpbmVEaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU2ltcGxpZmllZCB2ZXJzaW9uIG9mIGBpbmxpbmVEaXJlY3Rpb25gOlxuICAgICAqIFxuICAgICAqICogYGhvcml6b250YWxgIGZvciBgaG9yaXpvbnRhbC10YmBcbiAgICAgKiAqIGB2ZXJ0aWNhbGAgZm9yIGFsbCBvdGhlcnNcbiAgICAgKi9cbiAgICBpbmxpbmVPcmllbnRhdGlvbjogUGh5c2ljYWxPcmllbnRhdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGRpcmVjdGlvbiB0ZXh0IGZsb3dzLCBsaW5lIGJ5IGxpbmUuXG4gICAgICogXG4gICAgICogKiBgdHRiYCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYHJ0bGAgZm9yIGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYGx0cmAgZm9yIGB2ZXJ0aWNhbC1scmAgJiBgc2lkZXdheXMtbHJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqL1xuICAgIGJsb2NrRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFNpbXBsaWZpZWQgdmVyc2lvbiBvZiBgYmxvY2tEaXJlY3Rpb25gOlxuICAgICAqIFxuICAgICAqICogYHZlcnRpY2FsYCBmb3IgYGhvcml6b250YWwtdGJgXG4gICAgICogKiBgaG9yaXpvbnRhbGAgZm9yIGFsbCBvdGhlcnNcbiAgICAgKi9cbiAgICBibG9ja09yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBob3cgeW91IGNhbiAqcGh5c2ljYWxseSogcmVmZXIgdG8gdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgaW4gdGhlICppbmxpbmUqIHNpemUuXG4gICAgICogXG4gICAgICogKiBgd2lkdGhgIGZvciBgaG9yaXpvbnRhbC10YmAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXG4gICAgICogKiBgaGVpZ2h0YCBmb3IgYWxsIG90aGVyc1xuICAgICAqL1xuICAgIGlubGluZVNpemU6IFBoeXNpY2FsU2l6ZTtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgaG93IHlvdSBjYW4gKnBoeXNpY2FsbHkqIHJlZmVyIHRvIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IGluIHRoZSAqYmxvY2sqIHNpemUuXG4gICAgICogXG4gICAgICogKiBgaGVpZ2h0YCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxuICAgICAqICogYHdpZHRoYCBmb3IgYWxsIG90aGVyc1xuICAgICAqL1xuICAgIGJsb2NrU2l6ZTogUGh5c2ljYWxTaXplO1xuXG4gICAgLyoqXG4gICAgICogRm9yIGVhY2ggZ2x5cGgsIGFzY2VuZGVycyB0byBkZXNjZW5kZXJzICpwaHlzaWNhbGx5KiBnbzpcbiAgICAgKiBcbiAgICAgKiAqIGB0dGJgIGZvciBgaG9yaXpvbnRhbC10YmBcbiAgICAgKiAqIGBydGxgIGZvciBgdmVydGljYWwtcmxgLCBgdmVydGljYWwtbHJgLCAmIGBzaWRld2F5cy1ybGBcbiAgICAgKiAqIGBsdHJgIGZvciBgc2lkZXdheXMtbHJgXG4gICAgICovXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEZvciBlYWNoIGdseXBoLCBpdHMgXCJsZWZ0XCIgc2lkZSAodGhpbmsgb2YgdGhpcyByZWxhdGl2ZSB0byBgd3JpdGluZy1tb2RlYCBidXQgKm5vdCogcmVsYXRpdmUgdG8gYGRpcmVjdGlvbmAsIG9yIGFsdGVybmF0aXZlbHkgd2hhdCBgdGV4dC1hbGlnbjogbGVmdGAgbWVhbnMpIHRvIGl0cyBcInJpZ2h0XCIgc2lkZSAqcGh5c2ljYWxseSogZ29lcyBmcm9tOlxuICAgICAqIFxuICAgICAqICogYGx0cmAgZm9yIGBob3Jpem9udGFsLXRiYFxuICAgICAqICogYHR0YmAgZm9yIGB2ZXJ0aWNhbC1ybGAsIGB2ZXJ0aWNhbC1scmAsICYgYHNpZGV3YXlzLXJsYFxuICAgICAqICogYGJ0dGAgZm9yIGBzaWRld2F5cy1scmBcbiAgICAgKi9cbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xufVxuXG5jb25zdCBIb3Jpem9udGFsVGJMdHI6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIGlubGluZURpcmVjdGlvbjogXCJsdHJcIixcbiAgICBibG9ja0RpcmVjdGlvbjogXCJ0dGJcIixcblxuICAgIGlubGluZU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcbiAgICBibG9ja09yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXG5cbiAgICBpbmxpbmVTaXplOiBcIndpZHRoXCIsXG4gICAgYmxvY2tTaXplOiBcImhlaWdodFwiLFxuXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcImx0clwiLFxuICAgIG92ZXJVbmRlckRpcmVjdGlvbjogXCJ0dGJcIlxufTtcblxuY29uc3QgSG9yaXpvbnRhbFRiUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5Ib3Jpem9udGFsVGJMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInJ0bFwiLFxufTtcblxuY29uc3QgVmVydGljYWxSbEx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiLFxuICAgIGJsb2NrRGlyZWN0aW9uOiBcInJ0bFwiLFxuXG4gICAgaW5saW5lT3JpZW50YXRpb246IFwidmVydGljYWxcIixcbiAgICBibG9ja09yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcblxuICAgIGlubGluZVNpemU6IFwiaGVpZ2h0XCIsXG4gICAgYmxvY2tTaXplOiBcIndpZHRoXCIsXG5cbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwidHRiXCIsXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcInJ0bFwiXG59O1xuXG5jb25zdCBWZXJ0aWNhbFJsUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5WZXJ0aWNhbFJsTHRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIlxufTtcblxuXG5jb25zdCBTaWRld2F5c1JsTHRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHsgLi4uVmVydGljYWxSbEx0ciB9O1xuY29uc3QgU2lkZXdheXNSbFJ0bDogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7IC4uLlZlcnRpY2FsUmxSdGwgfTtcblxuY29uc3QgVmVydGljYWxMckx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XG4gICAgLi4uVmVydGljYWxSbEx0cixcbiAgICBibG9ja0RpcmVjdGlvbjogXCJsdHJcIixcbn07XG5cbmNvbnN0IFZlcnRpY2FsTHJSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLlZlcnRpY2FsUmxSdGwsXG4gICAgYmxvY2tEaXJlY3Rpb246IFwibHRyXCIsXG59O1xuXG5jb25zdCBTaWRld2F5c0x0THRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcbiAgICAuLi5WZXJ0aWNhbExyTHRyLFxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIixcblxuICAgIGxlZnRSaWdodERpcmVjdGlvbjogXCJidHRcIixcbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFwibHRyXCJcbn07XG5cbmNvbnN0IFNpZGV3YXlzTHRSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xuICAgIC4uLlNpZGV3YXlzTHRMdHIsXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiXG59O1xuXG5cblxuY29uc3QgSG9yaXpvbnRhbFRiID0ge1xuICAgIGx0cjogSG9yaXpvbnRhbFRiTHRyLFxuICAgIHJ0bDogSG9yaXpvbnRhbFRiUnRsXG59IGFzIGNvbnN0O1xuXG5jb25zdCBWZXJ0aWNhbFJsID0ge1xuICAgIGx0cjogVmVydGljYWxSbEx0cixcbiAgICBydGw6IFZlcnRpY2FsUmxSdGxcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IFZlcnRpY2FsTHIgPSB7XG4gICAgbHRyOiBWZXJ0aWNhbExyTHRyLFxuICAgIHJ0bDogVmVydGljYWxMclJ0bFxufSBhcyBjb25zdDtcblxuY29uc3QgU2lkZXdheXNSbCA9IHtcbiAgICBsdHI6IFNpZGV3YXlzUmxMdHIsXG4gICAgcnRsOiBTaWRld2F5c1JsUnRsXG59IGFzIGNvbnN0O1xuXG5jb25zdCBTaWRld2F5c0xyID0ge1xuICAgIGx0cjogU2lkZXdheXNMdEx0cixcbiAgICBydGw6IFNpZGV3YXlzTHRSdGxcbn0gYXMgY29uc3Q7XG5cbmNvbnN0IFdyaXRpbmdNb2RlcyA9IHtcbiAgICBcImhvcml6b250YWwtdGJcIjogSG9yaXpvbnRhbFRiLFxuICAgIFwidmVydGljYWwtbHJcIjogVmVydGljYWxMcixcbiAgICBcInZlcnRpY2FsLXJsXCI6IFZlcnRpY2FsUmwsXG4gICAgXCJzaWRld2F5cy1sclwiOiBTaWRld2F5c0xyLFxuICAgIFwic2lkZXdheXMtcmxcIjogU2lkZXdheXNSbFxufSBhcyBjb25zdDtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUaW1lb3V0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2AuICBcbiAgICAgKiBJZiBgbnVsbGAsIGNhbmNlbHMgdGhlIHRpbWVvdXQgaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgdGltZW91dDogbnVtYmVyIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdG8gdGhpcyBwcm9wIGJldHdlZW4gcmVuZGVycyBjYW4gYmUgdXNlZCB0byBjbGVhciB0aGUgY3VycmVudCB0aW1lb3V0IGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqL1xuICAgIHRyaWdnZXJJbmRleD86IHVua25vd247XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYHRpbWVvdXRgIG1zIGFmdGVyIG1vdW50LCBvciB0aGUgbGFzdCBjaGFuZ2UgdG8gYHRyaWdnZXJJbmRleGAuXG4gICAgICogXG4gICAgICogRG9lcyAqbm90KiBuZWVkIHRvIGJlIHN0YWJsZS4gR28gYWhlYWQgYW5kIHBhc3MgYW4gYW5vbnltb3VzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVGltZW91dCh7IHRpbWVvdXQsIGNhbGxiYWNrLCB0cmlnZ2VySW5kZXggfTogVXNlVGltZW91dCkge1xuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBzdGFydFRpbWVSZWYuY3VycmVudCA9IG51bGw7IGNhbGxiYWNrKCk7IH0pO1xuICAgIGNvbnN0IGdldFRpbWVvdXQgPSB1c2VTdGFibGVHZXR0ZXIodGltZW91dCk7XG5cbiAgICAvLyBTZXQgYW55IHRpbWUgd2Ugc3RhcnQgdGltZW91dC5cbiAgICAvLyBVbnNldCBhbnkgdGltZSB0aGUgdGltZW91dCBjb21wbGV0ZXNcbiAgICBjb25zdCBzdGFydFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCB0aW1lb3V0SXNOdWxsID0gKHRpbWVvdXQgPT0gbnVsbCk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgdHJpZ2dlckluZGV4IGNoYW5nZXMgKGluY2x1ZGluZyBvbiBtb3VudClcbiAgICAvLyByZXN0YXJ0IHRoZSB0aW1lb3V0LiAgVGhlIHRpbWVvdXQgZG9lcyBOT1QgcmVzZXRcbiAgICAvLyB3aGVuIHRoZSBkdXJhdGlvbiBvciBjYWxsYmFjayBjaGFuZ2VzLCBvbmx5IHRyaWdnZXJJbmRleC5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRpbWVvdXRJc051bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aW1lb3V0SXNOdWxsID09ICh0aW1lb3V0ID09IG51bGwpKTtcbiAgICBcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVSZWYuY3VycmVudCA9ICsobmV3IERhdGUoKSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChzdGFibGVDYWxsYmFjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sIFt0cmlnZ2VySW5kZXgsIHRpbWVvdXRJc051bGxdKVxuXG4gICAgY29uc3QgZ2V0RWxhcHNlZFRpbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKyhuZXcgRGF0ZSgpKSkgLSAoKyhzdGFydFRpbWVSZWYuY3VycmVudCA/PyBuZXcgRGF0ZSgpKSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0UmVtYWluaW5nVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgcmV0dXJuIHRpbWVvdXQgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1heCgwLCB0aW1lb3V0IC0gZ2V0RWxhcHNlZFRpbWUoKSlcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyBnZXRFbGFwc2VkVGltZSwgZ2V0UmVtYWluaW5nVGltZSB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTG9naWNhbERpcmVjdGlvbiB9IGZyb20gXCIuL3VzZS1sb2dpY2FsLWRpcmVjdGlvblwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlVGltZW91dCB9IGZyb20gXCIuL3VzZS10aW1lb3V0XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKiBcbiAgICAgKiBUaGVzZSBwcm9wcyBjYW4gYmUgYXR0YXRjaGVkIGVpdGhlciB0byB0aGUgcGFyZW50IG9yIHRvIGVhY2ggaW5kaXZpZHVhbCBjaGlsZC5cbiAgICAgKiBXaGljaGV2ZXIgd29ya3MgYmV0dGVyIGZvciB5b3VyIHNjZW5hcmlvLlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKiogXG4gICAgICogKi9cbiAgICB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD47XG59XG5cbmludGVyZmFjZSBMTlAge1xuICAgIG5hdmlnYXRlVG9OZXh0KCk6IHZvaWQ7XG4gICAgbmF2aWdhdGVUb1ByZXYoKTogdm9pZDtcbiAgICBuYXZpZ2F0ZVRvRmlyc3QoKTogdm9pZDtcbiAgICBuYXZpZ2F0ZVRvTGFzdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIHdoaWNoIGFycm93IGtleXMgYXJlIHVzZWQgdG8gbmF2aWdhdGUgdGhyb3VnaCB0aGUgY29tcG9uZW50LlxuICAgICAqIFJlbGF0aXZlIHRvIHRoZSB3cml0aW5nIG1vZGUsIHNvIGluIEVuZ2xpc2gsIFwiaW5saW5lXCIgY29ycmVzcG9uZHNcbiAgICAgKiB0byB0aGUgbGVmdCAmIHJpZ2h0IGFycm93IGtleXMsIGFuZCBcImJsb2NrXCIgdG8gdGhlIHVwICYgZG93biBhcnJvdyBrZXlzLlxuICAgICAqIFxuICAgICAqIFVzZSBcImVpdGhlclwiIHRvIGFsbG93IG5hdmlnYXRpb24gaW4gZWl0aGVyIGRpcmVjdGlvbi5cbiAgICAgKiBcbiAgICAgKiBVc2UgXCJub25lXCIgdG8gZGlzYWxsb3cgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIGluIGFueSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgbmF2aWdhdGlvbkRpcmVjdGlvbj86IFwiaW5saW5lXCIgfCBcImJsb2NrXCIgfCBcImVpdGhlclwiIHwgXCJub25lXCI7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIHdpbGwgYmUgXG4gICAgICogZGlzYWJsZWQsIGJ1dCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXG4gICAgICogYmUgdW5hZmZlY3RlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlQXJyb3dLZXlzPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXG4gICAgICogYmUgZGlzYWJsZWQsIGJ1dCBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgd2lsbCBiZVxuICAgICAqIHVuYWZmZWN0ZWQuXG4gICAgICovXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzPzogYm9vbGVhbjtcbn1cbmV4cG9ydCB0eXBlIExpbmVhck5hdmlnYXRpb25PbWl0cyA9IGtleW9mIExOUDtcblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHBhcmVudCBgdXNlTGluZWFyTmF2aWdhdGlvbmAgKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8T21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHM+IHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiBPbWl0PExOUCwgT21pdHM+XG59XG5cblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNoaWxkICd1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRgICovXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkSW5mbyB7IH1cblxuLyoqXG4gKiBXaGVuIHVzZWQgaW4gdGFuZGVtIHdpdGggYHVzZVJvdmluZ1RhYkluZGV4YCwgYWxsb3dzIGNvbnRyb2wgb2ZcbiAqIHRoZSB0YWJiYWJsZSBpbmRleCB3aXRoIHRoZSBhcnJvdyBrZXlzLlxuICogXG4gKiBAc2VlIHVzZUxpc3ROYXZpZ2F0aW9uLCB3aGljaCBwYWNrYWdlcyBldmVyeXRoaW5nIHVwIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbGluZWFyTmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvRmlyc3Q6IG50ZiwgbmF2aWdhdGVUb0xhc3Q6IG50bCwgbmF2aWdhdGVUb05leHQ6IG50biwgbmF2aWdhdGVUb1ByZXY6IG50cCwgbmF2aWdhdGlvbkRpcmVjdGlvbjogbmQsIGRpc2FibGVBcnJvd0tleXM6IGRhaywgZGlzYWJsZUhvbWVFbmRLZXlzOiBkaGVrIH0gfTogVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXI+KTogVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcblxuICAgIG5kID8/PSBcImVpdGhlclwiO1xuXG4gICAgY29uc3QgeyBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbywgdXNlTG9naWNhbERpcmVjdGlvblByb3BzIH0gPSB1c2VMb2dpY2FsRGlyZWN0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7fSk7XG5cbiAgICBjb25zdCBuYXZpZ2F0ZVRvRmlyc3QgPSB1c2VTdGFibGVDYWxsYmFjayhudGYpO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9MYXN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRsKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTmV4dCA9IHVzZVN0YWJsZUNhbGxiYWNrKG50bik7XG4gICAgY29uc3QgbmF2aWdhdGVUb1ByZXYgPSB1c2VTdGFibGVDYWxsYmFjayhudHApO1xuICAgIGNvbnN0IGdldERpc2FibGVBcnJvd0tleXMgPSB1c2VTdGFibGVHZXR0ZXIoZGFrKTtcbiAgICBjb25zdCBnZXREaXNhYmxlSG9tZUVuZEtleXMgPSB1c2VTdGFibGVHZXR0ZXIoZGhlayk7XG4gICAgY29uc3QgZ2V0TmF2aWdhdGlvbkRpcmVjdGlvbiA9IHVzZVN0YWJsZUdldHRlcihuZCk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxuICAgICAgICB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHM6IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+ID0+IHtcblxuICAgICAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCBieSB0eXBlYWhlYWQgKGkuZS4gYXNzdW1lIHRoaXMgaXMgYSBrZXlib2FyZCBzaG9ydGN1dClcbiAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmF2aWdhdGlvbkRpcmVjdGlvbiA9IGdldE5hdmlnYXRpb25EaXJlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNhYmxlQXJyb3dLZXlzID0gZ2V0RGlzYWJsZUFycm93S2V5cygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FibGVIb21lRW5kS2V5cyA9IGdldERpc2FibGVIb21lRW5kS2V5cygpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsb3dzQmxvY2tOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJibG9ja1wiIHx8IG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJlaXRoZXJcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsb3dzSW5saW5lTmF2aWdhdGlvbiA9IChuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiaW5saW5lXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBhbGxvd3NCbG9ja05hdmlnYXRpb24gOiBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcImJ0dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBhbGxvd3NCbG9ja05hdmlnYXRpb24gOiBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcImJ0dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImlubGluZURpcmVjdGlvblwiIDogXCJibG9ja0RpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IGFsbG93c0lubGluZU5hdmlnYXRpb24gOiBhbGxvd3NCbG9ja05hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwicnRsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJpbmxpbmVEaXJlY3Rpb25cIiA6IFwiYmxvY2tEaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uIDogYWxsb3dzQmxvY2tOYXZpZ2F0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcInJ0bFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlSG9tZUVuZEtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvRmlyc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJFbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZUhvbWVFbmRLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdXNlTG9naWNhbERpcmVjdGlvblByb3BzKHVzZU1lcmdlZFByb3BzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7IG9uS2V5RG93biB9LCBwcm9wcykpXG4gICAgICAgIH0sIFtdKSxcbiAgICB9XG5cblxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7XG4gICAgICAgIGN1cnJlbnRUeXBlYWhlYWQ6IHN0cmluZyB8IG51bGw7XG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQ6IGJvb2xlYW4gfCBudWxsO1xuICAgIH1cbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHVzZWQgb24gZWl0aGVyIHRoZSBwYXJlbnQgb3IgZWFjaCBjaGlsZCBlbGVtZW50LlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD47XG5cbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkO1xuXG59XG5cbmV4cG9ydCB0eXBlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbmV4cG9ydCB0eXBlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGUgPSB2b2lkO1xuXG5pbnRlcmZhY2UgVE5QIHtcbiAgICAvKipcbiAgICAgKiBBIGNvbGxhdG9yIHRvIHVzZSB3aGVuIGNvbXBhcmluZy4gSWYgbm90IHByb3ZpZGVkLCBzaW1wbHkgdXNlcyBgbG9jYWxlQ29tcGFyZWAgYWZ0ZXIgdHJhbnNmb3JtaW5nIGVhY2ggdG8gbG93ZXJjYXNlLCB3aGljaCB3aWxsLCBhdCBiZXN0LCB3b3JrIG9rYXkgaW4gRW5nbGlzaC5cbiAgICAgKi9cbiAgICBjb2xsYXRvcj86IEludGwuQ29sbGF0b3I7XG5cbiAgICBub1R5cGVhaGVhZD86IGJvb2xlYW47XG5cbiAgICB0eXBlYWhlYWRUaW1lb3V0PzogbnVtYmVyO1xuICAgIGdldEluZGV4KCk6IG51bWJlciB8IG51bGw7XG4gICAgc2V0SW5kZXgodmFsdWU6IG51bWJlciB8IG51bGwgfCAoKHByZXZpb3VzVmFsdWU6IG51bWJlciB8IG51bGwpID0+IChudW1iZXIgfCBudWxsKSkpOiB2b2lkO1xufVxuXG5leHBvcnQgdHlwZSBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMgPSBrZXlvZiBUTlA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM8T21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHM+IHtcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBPbWl0PFROUCwgT21pdHM+XG59XG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjaGlsZCAndXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkYCAqL1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogSWYgcHJvdmlkZWQsIGFsbG93cyB0aGlzIGNvbXBvbmVudCB0byBiZSBuYXZpZ2F0ZWQgdG8gYnkgdHlwaW5nIHRoaXMgc3RyaW5nLiBcbiAgICAgKiBJdCBzaG91bGQgYmUgdGhlIHNhbWUgdGV4dCBjb250ZW50IGFzIHdoYXRldmVyJ3MgZGlzcGxheWVkLCBpZGVhbGx5LlxuICAgICAqL1xuICAgIHRleHQ6IHN0cmluZyB8IG51bGw7XG5cbiAgICBpbmRleDogbnVtYmVyO1xufVxuXG4vKiogVHlwZSBvZiB0aGUgY2hpbGQncyBzdWItaG9vayAqL1xuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkID0gKGFyZ3M6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMpID0+IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU7XG5cblxuLyoqXG4gKiBBbGxvd3MgZm9yIHRoZSBzZWxlY3Rpb24gb2YgYSBtYW5hZ2VkIGNoaWxkIGJ5IHR5cGluZyB0aGUgZ2l2ZW4gdGV4dCBhc3NvY2lhdGVkIHdpdGggaXQuXG4gKiBcbiAqIEBzZWUgdXNlTGlzdE5hdmlnYXRpb24sIHdoaWNoIHBhY2thZ2VzIGV2ZXJ5dGhpbmcgdXAgdG9nZXRoZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBnZXRJbmRleCwgdHlwZWFoZWFkVGltZW91dCwgc2V0SW5kZXgsIG5vVHlwZWFoZWFkIH0gfTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXI+KTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcblxuXG4gICAgLy8gRm9yIHR5cGVhaGVhZCwga2VlcCB0cmFjayBvZiB3aGF0IG91ciBjdXJyZW50IFwic2VhcmNoXCIgc3RyaW5nIGlzIChpZiB3ZSBoYXZlIG9uZSlcbiAgICAvLyBhbmQgYWxzbyBjbGVhciBpdCBldmVyeSAxMDAwIG1zIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgY2hhbmdlZC5cbiAgICAvLyBOZXh0LCBrZWVwIGEgbWFwcGluZyBvZiB0eXBlYWhlYWQgdmFsdWVzIHRvIGluZGljZXMgZm9yIGZhc3RlciBzZWFyY2hpbmcuXG4gICAgLy8gQW5kLCBmb3IgdGhlIHVzZXIncyBzYWtlLCBsZXQgdGhlbSBrbm93IHdoZW4gdGhlaXIgdHlwZWFoZWFkIGNhbid0IG1hdGNoIGFueXRoaW5nIGFueW1vcmVcbiAgICBjb25zdCBbY3VycmVudFR5cGVhaGVhZCwgc2V0Q3VycmVudFR5cGVhaGVhZCwgZ2V0Q3VycmVudFR5cGVhaGVhZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICB1c2VUaW1lb3V0KHsgdGltZW91dDogdHlwZWFoZWFkVGltZW91dCA/PyAxMDAwLCBjYWxsYmFjazogKCkgPT4geyBzZXRDdXJyZW50VHlwZWFoZWFkKG51bGwpOyBzZXRJbnZhbGlkVHlwZWFoZWFkKG51bGwpOyB9LCB0cmlnZ2VySW5kZXg6IGN1cnJlbnRUeXBlYWhlYWQgfSk7XG4gICAgY29uc3Qgc29ydGVkVHlwZWFoZWFkSW5mbyA9IHVzZVJlZjx7IHRleHQ6IHN0cmluZywgdW5zb3J0ZWRJbmRleDogbnVtYmVyIH1bXT4oW10pO1xuICAgIGNvbnN0IFtpbnZhbGlkVHlwZWFoZWFkLCBzZXRJbnZhbGlkVHlwZWFoZWFkXSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBudWxsPihmYWxzZSk7XG5cbiAgICAvLyBIYW5kbGUgdHlwZWFoZWFkIGZvciBpbnB1dCBtZXRob2QgZWRpdG9ycyBhcyB3ZWxsXG4gICAgLy8gRXNzZW50aWFsbHksIHdoZW4gYWN0aXZlLCBpZ25vcmUgZnVydGhlciBrZXlzIFxuICAgIC8vIGJlY2F1c2Ugd2UncmUgd2FpdGluZyBmb3IgYSBDb21wb3NpdGlvbkVuZCBldmVudFxuICAgIGNvbnN0IFssIHNldEltZUFjdGl2ZSwgZ2V0SW1lQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIC8vIEJlY2F1c2UgY29tcG9zaXRpb24gZXZlbnRzIGZpcmUgKmFmdGVyKiBrZXlkb3duIGV2ZW50cyBcbiAgICAvLyAoYnV0IHdpdGhpbiB0aGUgc2FtZSB0YXNrLCB3aGljaCwgVE9ETywgY291bGQgYmUgYnJvd3Nlci1kZXBlbmRlbnQpLFxuICAgIC8vIHdlIGNhbiB1c2UgdGhpcyB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50IHdlJ3JlIGxpc3RlbmluZyBmb3Igb24gdGhlIGZpcnN0IGtleWRvd24uXG4gICAgY29uc3QgW25leHRUeXBlYWhlYWRDaGFyLCBzZXROZXh0VHlwZWFoZWFkQ2hhcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobmV4dFR5cGVhaGVhZENoYXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlYWhlYWQodHlwZWFoZWFkID0+ICgodHlwZWFoZWFkID8/IFwiXCIpICsgbmV4dFR5cGVhaGVhZENoYXIpKTtcbiAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKG51bGwpO1xuICAgICAgICB9XG4gICAgfSwgW25leHRUeXBlYWhlYWRDaGFyXSk7XG5cblxuICAgIGNvbnN0IGNvbXBhcmF0b3JTaGFyZWQgPSB1c2VTdGFibGVDYWxsYmFjaygoc2FmZUxoczogc3RyaW5nLCBzYWZlUmhzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbGV0IGNvbXBhcmU6IG51bWJlcjtcbiAgICAgICAgLy8gRm9yIHRoZSBwdXJwb3NlcyBvZiB0eXBlYWhlYWQsIG9ubHkgY29tcGFyZSBhIHN0cmluZyBvZiB0aGUgc2FtZSBzaXplIGFzIG91ciBjdXJyZW50bHkgdHlwZWQgc3RyaW5nLlxuICAgICAgICAvLyBCeSBub3JtYWxpemluZyB0aGVtIGZpcnN0LCB3ZSBlbnN1cmUgdGhpcyBieXRlLWJ5LWJ5dGUgaGFuZGxpbmcgb2YgcmF3IGNoYXJhY3RlciBkYXRhIHdvcmtzIG91dCBva2F5LlxuICAgICAgICBzYWZlTGhzID0gc2FmZUxocy5ub3JtYWxpemUoXCJORkRcIik7XG4gICAgICAgIHNhZmVSaHMgPSBzYWZlUmhzLm5vcm1hbGl6ZShcIk5GRFwiKVxuXG4gICAgICAgIGlmIChjb2xsYXRvcilcbiAgICAgICAgICAgIGNvbXBhcmUgPSBjb2xsYXRvci5jb21wYXJlKHNhZmVMaHMsIHNhZmVSaHMpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmUgPSBzYWZlTGhzLnRvTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShzYWZlUmhzLnRvTG93ZXJDYXNlKCkgPz8gXCJcIik7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnNlcnRpbmdDb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxoczogc3RyaW5nLCByaHM6IHsgdGV4dDogc3RyaW5nOyB1bnNvcnRlZEluZGV4OiBudW1iZXI7IH0pID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmhzLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yU2hhcmVkKGxocywgcmhzLnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChsaHMgYXMgdW5rbm93biBhcyBudW1iZXIpIC0gKHJocyBhcyB1bmtub3duIGFzIG51bWJlcik7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0eXBlYWhlYWRDb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxoczogc3RyaW5nLCByaHM6IHsgdGV4dDogc3RyaW5nOyB1bnNvcnRlZEluZGV4OiBudW1iZXI7IH0pID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmhzLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIER1cmluZyB0eXBlYWhlYWQsIGFsbCBzdHJpbmdzIGxvbmdlciB0aGFuIG91cnMgc2hvdWxkIGJlIHRydW5jYXRlZFxuICAgICAgICAgICAgLy8gc28gdGhhdCB0aGV5J3JlIGFsbCBjb25zaWRlcmVkIGVxdWFsbHkgYnkgdGhhdCBwb2ludC5cbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yU2hhcmVkKGxocywgcmhzLnRleHQuc3Vic3RyaW5nKDAsIGxocy5sZW5ndGgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobGhzIGFzIHVua25vd24gYXMgbnVtYmVyKSAtIChyaHMgYXMgdW5rbm93biBhcyBudW1iZXIpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IHVzZVN0YWJsZUdldHRlcihub1R5cGVhaGVhZCk7XG5cblxuICAgIGNvbnN0IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XG5cbiAgICAgICAgY29uc3Qgb25Db21wb3NpdGlvblN0YXJ0ID0gKF9lOiBDb21wb3NpdGlvbkV2ZW50KSA9PiB7IHNldEltZUFjdGl2ZSh0cnVlKSB9O1xuICAgICAgICBjb25zdCBvbkNvbXBvc2l0aW9uRW5kID0gKGU6IENvbXBvc2l0aW9uRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKGUuZGF0YSk7XG4gICAgICAgICAgICBzZXRJbWVBY3RpdmUoZmFsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3QgaW1lQWN0aXZlID0gZ2V0SW1lQWN0aXZlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGUua2V5O1xuXG4gICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCBieSB0eXBlYWhlYWQgKGkuZS4gYXNzdW1lIHRoaXMgaXMgYSBrZXlib2FyZCBzaG9ydGN1dClcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUgJiYgZS5rZXkgPT09IFwiQmFja3NwYWNlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgY2hhcmFjdGVyIGluIGEgd2F5IHRoYXQgZG9lc24ndCBzcGxpdCBVVEYtMTYgc3Vycm9nYXRlcy5cbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHQgPT4gdCA9PT0gbnVsbCA/IG51bGwgOiBbLi4udF0ucmV2ZXJzZSgpLnNsaWNlKDEpLnJldmVyc2UoKS5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBrZXkgcHJvcGVydHkgcmVwcmVzZW50cyB0aGUgdHlwZWQgY2hhcmFjdGVyIE9SIHRoZSBcIm5hbWVkIGtleSBhdHRyaWJ1dGVcIiBvZiB0aGUga2V5IHByZXNzZWQuXG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIGRlZmluaXRlIHdheSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlLCBidXQgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3Nlc1xuICAgICAgICAgICAgLy8gdGhlcmUgYXJlIG5vIG9uZS1jaGFyYWN0ZXIgbmFtZXMsIGFuZCB0aGVyZSBhcmUgbm8gbm9uLUFTQ0lJLWFscGhhIG5hbWVzLlxuICAgICAgICAgICAgLy8gVGh1cywgYW55IG9uZS1jaGFyYWN0ZXIgb3Igbm9uLUFTQ0lJIHZhbHVlIGZvciBga2V5YCBpcyAqYWxtb3N0IGNlcnRhaW5seSogYSB0eXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBjb25zdCBpc0NoYXJhY3RlcktleSA9IChrZXkubGVuZ3RoID09PSAxIHx8ICEvXltBLVphLXpdLy50ZXN0KGtleSkpO1xuICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVyS2V5KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwiIFwiICYmIChnZXRDdXJyZW50VHlwZWFoZWFkKCkgPz8gXCJcIikudHJpbSgpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGJlY2F1c2UgYSBzcGFjZWJhciBjYW4ndCBldmVyIFxuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWF0ZSBhIHR5cGVhaGVhZCwgb25seSBjb250aW51ZSBvbmUuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gKFNwZWNpZmljYWxseSwgbGV0IHRoZSBldmVudCBjb250aW51ZSBwcm9wYWdhdGlvbiBpbiB0aGlzIGNhc2UpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBXb24ndCBiZSB0cnVlIGZvciB0aGUgZmlyc3Qga2V5ZG93blxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWZvcmUgdXNlTGF5b3V0RWZmZWN0IGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhY3R1YWxseSBhcHBseSB0aGUgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1lQWN0aXZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHsgb25LZXlEb3duLCBvbkNvbXBvc2l0aW9uU3RhcnQsIG9uQ29tcG9zaXRpb25FbmQsIH0sIHByb3BzKTtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBIYW5kbGUgY2hhbmdlcyBpbiB0eXBlYWhlYWQgdGhhdCBjYXVzZSBjaGFuZ2VzIHRvIHRoZSB0YWJiYWJsZSBpbmRleFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50VHlwZWFoZWFkICYmIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGgpIHtcblxuXG5cbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZFR5cGVhaGVhZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgdHlwZWFoZWFkQ29tcGFyYXRvcik7XG5cbiAgICAgICAgICAgIGlmIChzb3J0ZWRUeXBlYWhlYWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBoYXMgdHlwZWQgYW4gZW50cnkgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgLy8gKG9yIG1vcmUgc3BlY2lmaWNhbGx5IFwiZm9yIHdoaWNoIHRoZXJlIGlzIG5vIGVudHJ5IHRoYXQgc3RhcnRzIHdpdGggdGhhdCBpbnB1dFwiKVxuICAgICAgICAgICAgICAgIHNldEludmFsaWRUeXBlYWhlYWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICBXZSBrbm93IHJvdWdobHkgd2hlcmUsIGluIHRoZSBzb3J0ZWQgYXJyYXkgb2Ygc3RyaW5ncywgb3VyIG5leHQgdHlwZWFoZWFkIGxvY2F0aW9uIGlzLlxuICAgICAgICAgICAgICAgICAgQnV0IHJvdWdobHkgaXNuJ3QgZ29vZCBlbm91Z2ggaWYgdGhlcmUgYXJlIG11bHRpcGxlIG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgICBUbyBjb252ZXJ0IG91ciBzb3J0ZWQgaW5kZXggdG8gdGhlIHVuc29ydGVkIGluZGV4IHdlIG5lZWQsIHdlIGhhdmUgdG8gZmluZCB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHVzICphbmQqIChpZiBhbnkgc3VjaCBleGlzdCkgaXMgKmFmdGVyKiBvdXIgY3VycmVudCBzZWxlY3Rpb24uXG5cbiAgICAgICAgICAgICAgICAgIEluIG90aGVyIHdvcmRzLCB0aGUgb25seSB3YXkgdHlwZWFoZWFkIG1vdmVzIGJhY2t3YXJkcyByZWxhdGl2ZSB0byBvdXIgY3VycmVudFxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gaXMgaWYgdGhlIG9ubHkgb3RoZXIgb3B0aW9uIGlzIGJlaGluZCB1cy5cblxuICAgICAgICAgICAgICAgICAgSXQncyBub3Qgc3BlY2lmaWVkIGluIFdBSS1BUklBIHdoYXQgdG8gZG8gaW4gdGhhdCBjYXNlLiAgSSBzdXBwb3NlIHdyYXAgYmFjayB0byB0aGUgc3RhcnQ/XG4gICAgICAgICAgICAgICAgICBUaG91Z2ggdGhlcmUncyBhbHNvIGEgY2FzZSBmb3IganVzdCBnb2luZyB1cHdhcmRzIHRvIHRoZSBuZWFyZXN0IHRvIHByZXZlbnQganVtcGluZXNzLlxuICAgICAgICAgICAgICAgICAgQnV0IGlmIHlvdSdyZSBhbHJlYWR5IGRvaW5nIHR5cGVhaGVhZCBvbiBhbiB1bnNvcnRlZCBsaXN0LCBsaWtlLCBqdW1waW5lc3MgY2FuJ3QgYmUgYXZvaWRlZC5cbiAgICAgICAgICAgICAgICAgIEkgZHVubm8uIEdvaW5nIGJhY2sgdG8gdGhlIHN0YXJ0IGlzIHRoZSBzaW1wbGlzdCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgICAgIEJhc2ljYWxseSB3aGF0IHRoaXMgZG9lczogU3RhcnRpbmcgZnJvbSB3aGVyZSB3ZSBmb3VuZCBvdXJzZWx2ZXMgYWZ0ZXIgb3VyIGJpbmFyeSBzZWFyY2gsXG4gICAgICAgICAgICAgICAgICBzY2FuIGJhY2t3YXJkcyBhbmQgZm9yd2FyZHMgdGhyb3VnaCBhbGwgYWRqYWNlbnQgZW50cmllcyB0aGF0IGFsc28gY29tcGFyZSBlcXVhbGx5IHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgIHdlIGNhbiBmaW5kIHRoZSBvbmUgd2hvc2UgYHVuc29ydGVkSW5kZXhgIGlzIHRoZSBsb3dlc3QgYW1vbmdzdCBhbGwgb3RoZXIgZXF1YWwgc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgKGFuZCBhbHNvIHRoZSBsb3dlc3QgYHVuc29ydGVkSW5kZXhgIHlhZGRhIHlhZGRhIGV4Y2VwdCB0aGF0IGl0IGNvbWVzIGFmdGVyIHVzKS5cblxuICAgICAgICAgICAgICAgICAgVE9ETzogVGhlIGJpbmFyeSBzZWFyY2ggc3RhcnRzIHRoaXMgb2ZmIHdpdGggYSBzb2xpZCBPKGxvZyBuKSwgYnV0IG9uZS1jaGFyYWN0ZXIgXG4gICAgICAgICAgICAgICAgICBzZWFyY2hlcyBhcmUsIHRoYW5rcyB0byBwaWdlb25ob2xlIHByaW5jaXBhbCwgZXZlbnR1YWxseSBndWFyYW50ZWVkIHRvIGJlY29tZSBcbiAgICAgICAgICAgICAgICAgIE8obipsb2cgbikuIFRoaXMgaXMgYW5ub3lpbmcgYnV0IHByb2JhYmx5IG5vdCBlYXNpbHkgc29sdmFibGU/IFRoZXJlIGNvdWxkIGJlIGFuIFxuICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uIGZvciBvbmUtY2hhcmFjdGVyIHN0cmluZ3MsIGJ1dCB0aGF0J3MganVzdCBraWNraW5nIHRoZSBjYW4gZG93biBcbiAgICAgICAgICAgICAgICAgIHRoZSByb2FkLiBNYXliZSBvbmUgb3IgdHdvIGNoYXJhY3RlcnMgd291bGQgYmUgZ29vZCBlbm91Z2ggdGhvdWdoLlxuICAgICAgICAgICAgICAgICovXG5cblxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIGFyZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGNhbmRpZGF0ZXMnIHBvc2l0aW9ucyBpbiBib3RoIG91ciBzb3J0ZWQgYXJyYXkgYW5kIHRoZSB1bnNvcnRlZCBET00uXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFVuc29ydGVkSW5kZXhBbGw6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RTb3J0ZWRJbmRleEFsbCA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgdHdvIGFyZSBvbmx5IHNldCBmb3IgZWxlbWVudHMgdGhhdCBhcmUgYWhlYWQgb2YgdXMsIGJ1dCB0aGUgcHJpbmNpcGxlJ3MgdGhlIHNhbWUgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0U29ydGVkSW5kZXhOZXh0ID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVCZXN0Rml0ID0gKHU6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9PSBudWxsIHx8IHUgPCBsb3dlc3RVbnNvcnRlZEluZGV4QWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RVbnNvcnRlZEluZGV4QWxsID0gdTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNvcnRlZEluZGV4QWxsID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0KSAmJiB1ID4gKGdldEluZGV4KCkgPz8gLUluZmluaXR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U29ydGVkSW5kZXhOZXh0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBpID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiB0eXBlYWhlYWRDb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGggJiYgdHlwZWFoZWFkQ29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQmVzdEZpdChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleE5leHRdLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleEFsbF0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbY3VycmVudFR5cGVhaGVhZF0pO1xuXG4gICAgY29uc3QgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkID0gdXNlQ2FsbGJhY2s8VXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkPigoeyBpbmRleCwgdGV4dCB9KSA9PiB7XG5cbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIHdoZXJlIHRvIGluc2VydCB0aGlzIGl0ZW0uXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBhbGwgaW5kZXggdmFsdWVzIHNob3VsZCBiZSB1bmlxdWUsIHRoZSByZXR1cm5lZCBzb3J0ZWRJbmRleFxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBhbHdheXMgcmVmZXIgdG8gYSBuZXcgbG9jYXRpb24gKGkuZS4gYmUgbmVnYXRpdmUpICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgdGV4dCwgaW5zZXJ0aW5nQ29tcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoc29ydGVkSW5kZXggPCAwIHx8IGluc2VydGluZ0NvbXBhcmF0b3Ioc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W3NvcnRlZEluZGV4XS50ZXh0LCB7IHVuc29ydGVkSW5kZXg6IGluZGV4LCB0ZXh0IH0pID09IDApO1xuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZSgtc29ydGVkSW5kZXggLSAxLCAwLCB7IHRleHQsIHVuc29ydGVkSW5kZXg6IGluZGV4IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZShzb3J0ZWRJbmRleCwgMCwgeyB0ZXh0LCB1bnNvcnRlZEluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVubW91bnRpbmcsIGZpbmQgd2hlcmUgd2Ugd2VyZSBhbmQgcmVtb3ZlIG91cnNlbHZlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWdhaW4sIHdlIHNob3VsZCBhbHdheXMgZmluZCBvdXJzZWx2ZXMgYmVjYXVzZSB0aGVyZSBzaG91bGQgYmUgbm8gZHVwbGljYXRlIHZhbHVlcyBpZiBlYWNoIGluZGV4IGlzIHVuaXF1ZS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCB0ZXh0LCBpbnNlcnRpbmdDb21wYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoc29ydGVkSW5kZXggPCAwIHx8IGluc2VydGluZ0NvbXBhcmF0b3Ioc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W3NvcnRlZEluZGV4XS50ZXh0LCB7IHVuc29ydGVkSW5kZXg6IGluZGV4LCB0ZXh0IH0pID09IDApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKHNvcnRlZEluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3RleHRdKTtcblxuICAgICAgICByZXR1cm47XG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyxcblxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxuICAgICAgICAgICAgaW52YWxpZFR5cGVhaGVhZCxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vKipcbiAqIFlvdXIgdXN1YWwgYmluYXJ5IHNlYXJjaCBpbXBsZW1lbnRhdGlvbi5cbiAqIFxuICogSXQncyB1c2VkIGhlcmUgdG8gcXVpY2tseSBmaW5kIGEgZ29vZCBzcG90IHRvIHN0YXJ0IHNlYXJjaGluZyBmb3Igb3VyIG5leHQgdHlwZWFoZWFkIGNhbmRpZGF0ZS5cbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoIHRocm91Z2hcbiAqIEBwYXJhbSB3YW50ZWQgVGhlIHZhbHVlIHlvdSdkIGxpa2UgdG8gZmluZFxuICogQHBhcmFtIGNvbXBhcmF0b3IgQ29tcGFyZXMgYHdhbnRlZGAgd2l0aCB0aGUgY3VycmVudCB2YWx1ZSBpbiBgYXJyYXlgXG4gKiBAcmV0dXJucyBBIG5vbi1uZWdhdGl2ZSB2YWx1ZSBpZiBgd2FudGVkYCB3YXMgZm91bmQsIGFuZCBhIG5lZ2F0aXZlIG51bWJlciBpZiBub3QuIFxuICogVGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgbnVtYmVyLCBtaW51cyBvbmUsIGlzIHdoZXJlIGB3YW50ZWRgICp3b3VsZCogYmUgZm91bmQgaWYgaXQgKndhcyogaW4gYGFycmF5YFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoPFQsIFUsIEYgZXh0ZW5kcyAobGhzOiBVLCByaHM6IFQpID0+IG51bWJlcj4oYXJyYXk6IFRbXSwgd2FudGVkOiBVLCBjb21wYXJhdG9yOiBGKTogbnVtYmVyIHtcbiAgICBsZXQgZmlyc3RJbmRleCA9IDA7XG4gICAgbGV0IGxhc3RJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGZpcnN0SW5kZXggPD0gbGFzdEluZGV4KSB7XG4gICAgICAgIGNvbnN0IHRlc3RJbmRleCA9IChsYXN0SW5kZXggKyBmaXJzdEluZGV4KSA+PiAxO1xuICAgICAgICBjb25zdCBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyYXRvcih3YW50ZWQsIGFycmF5W3Rlc3RJbmRleF0pO1xuXG4gICAgICAgIGlmIChjb21wYXJpc29uUmVzdWx0ID4gMCkge1xuICAgICAgICAgICAgZmlyc3RJbmRleCA9IHRlc3RJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcGFyaXNvblJlc3VsdCA8IDApIHtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IHRlc3RJbmRleCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGVzdEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC1maXJzdEluZGV4IC0gMTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW5PbWl0cywgT25DaGlsZHJlbk1vdW50Q2hhbmdlLCB1c2VDaGlsZHJlbkZsYWcsIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlSGFzRm9jdXMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG4vL2V4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkSW5mb0Jhc2U8Sz4+ID0gUmVxdWlyZWQ8ST4gJiBGbGFnZ2FibGVDaGlsZEluZm88XCJ0YWJiYWJsZVwiPiAmIHtcbi8vfTtcblxuZXhwb3J0IHR5cGUgT25UYWJiYWJsZUluZGV4Q2hhbmdlID0gKHRhYmJhYmxlSW5kZXg6IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPEUgZXh0ZW5kcyBFbGVtZW50LCBDPiB7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGFiYmluZyB0aHJvdWdoIHRoaXMgY29tcG9uZW50IHdpbGwgY2F1c2UgdGhlIHJlZmVyZW5jZWQgZWxlbWVudCB0byBiZSBmb2N1c2VkLlxuICAgICAqIFxuICAgICAqIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvciB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50IGlmIHlvdSdkIGxpa2UuXG4gICAgICovXG4gICAgZm9jdXNTZWxmKCk6IHZvaWQ7XG5cbiAgICBibHVyU2VsZigpOiB2b2lkO1xuXG4gICAgZ2V0RWxlbWVudCgpOiBFIHwgbnVsbDtcblxuICAgIGhpZGRlbjogYm9vbGVhbjtcblxuICAgIHN1YkluZm86IEM7XG59XG5cbmludGVyZmFjZSBSVElQIHtcbiAgICAvLyBDYWxsZWQgZHVyaW5nIGFuIGVmZmVjdCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyByZW5kZXJlZCBpdHNlbGYgaW4gYSB0YWJiYWJsZSBzdGF0ZVxuICAgIG9uVGFiYmFibGVSZW5kZXI/OiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcblxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZT86IE9uVGFiYmFibGVJbmRleENoYW5nZTtcblxuICAgIC8vb25UYWJiZWRJblRvPzogKCkgPT4gdm9pZDtcbiAgICAvL29uVGFiYmVkT3V0T2Y/OiAoKSA9PiB2b2lkO1xuXG4gICAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xufVxuZXhwb3J0IHR5cGUgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMgPSBrZXlvZiBSVElQO1xuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8UnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBNY09taXRzPiB7XG4gICAgcm92aW5nVGFiSW5kZXg6IE9taXQ8UlRJUCwgUnRpT21pdHM+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxudW1iZXIsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcbiAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBzZXRUYWJiYWJsZUluZGV4OiAodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRUYWJiYWJsZUluZGV4OiAoKSA9PiBudW1iZXIgfCBudWxsO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBmb2N1c1NlbGY6ICgpID0+IHZvaWQ7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzXG4gICAgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj5cbntcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPjtcbn1cblxuZXhwb3J0IHR5cGUgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzID0ga2V5b2YgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgYW55PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nLCBSdGljT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCIsIE1jT21pdHMgfCBcInN1YkluZm9cIj4ge1xuICAgIHJvdmluZ1RhYkluZGV4OiBPbWl0PFBhcnRpYWw8T21pdDxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88YW55LCBhbnk+LCBcImdldEVsZW1lbnRcIiB8IFwic3ViSW5mb1wiPj4sIFJ0aWNPbWl0cz47XG4gICAgc3ViSW5mbzogU3ViYmVzdEluZm87XG59XG5cbmV4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cywgbmV2ZXIsIG5ldmVyLCBSdGlTdWJJbmZvPikgPT4gVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgIHRhYmJhYmxlOiBib29sZWFuO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRUYWJiYWJsZSgpOiBib29sZWFuO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRFbGVtZW50KCk6IENoaWxkRWxlbWVudCB8IG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xufVxuXG5cbi8qKlxuICogSW1wbGVtZW50cyBhIHJvdmluZyB0YWJpbmRleCBzeXN0ZW0gd2hlcmUgb25seSBvbmUgXCJmb2N1c2FibGVcIlxuICogY29tcG9uZW50IGluIGEgc2V0IGlzIGFibGUgdG8gcmVjZWl2ZSBhIHRhYiBmb2N1cy4gKldoaWNoKlxuICogb2YgdGhvc2UgZWxlbWVudHMgcmVjZWl2ZXMgZm9jdXMgaXMgZGV0ZXJtaW5lZCBieSB5b3UsIGJ1dCBpdCdzXG4gKiByZWNvbW1lbmRlZCB0byBvZmZsb2FkIHRoYXQgbG9naWMgdGhlbiB0byBhbm90aGVyIGhvb2ssIGxpa2VcbiAqIGB1c2VMaW5lYXJOYXZpZ2F0aW9uYCwgd2hpY2ggbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZVxuICogZWxlbWVudCB3aXRoIHRoZSBhcnJvdyBrZXlzLCBgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbmAsIHdoaWNoXG4gKiBsZXRzIHlvdSBjaGFuZ2UgdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdHlwZWFoZWFkLCBvclxuICogYHVzZUxpc3ROYXZpZ2F0aW9uYCBpZiB5b3UganVzdCB3YW50IGV2ZXJ5dGhpbmcgYnVuZGxlZCB0b2dldGhlci5cbiAqIFxuICogTm90ZSB0aGF0IHRoZSBjaGlsZCBob29rIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkXG4gKiBieSBldmVyeSBjaGlsZCB0aGF0IHVzZXMgdGhpcyByb3ZpbmcgdGFiaW5kZXggbG9naWMuICBUaGVcbiAqIHByb3AtbW9kaWZ5aW5nIGhvb2sgKnRoYXQqIGhvb2sgcmV0dXJucyBzaG91bGQgdGhlbiBiZSB1c2VkXG4gKiBvbiB0aGUgY2hpbGQncyBlbGVtZW50LCBhcyB3ZWxsIGFzIGFueSBvdGhlciBlbGVtZW50cyB5b3UnZCBsaWtlXG4gKiB0byBiZSBleHBsaWNpdGx5IG1hZGUgdW50YWJiYWJsZSB0b28uXG4gKiBcbiAqIGBzaG91bGRGb2N1c09uQ2hhbmdlYCBzaG91bGQgcmV0dXJuIHRydWUgaWYgZm9jdXMgaXMgXG4gKiBjb250YWluZWQgd2l0aGluIHdoYXRldmVyIGVsZW1lbnQgY29udGFpbnMgdGhlIHJvdmluZyB0YWIgaW5kZXguXG4gKiBHZW5lcmFsbHkgYXMgc2ltcGxlIGFzIHRoZSBmb2xsb3dpbmc6XG4gKiBgYGBcbiAqIGNvbnN0IFtmb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gKiBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPFBhcmVudEVsZW1lbnQ+KHsgc2V0Rm9jdXNlZElubmVyIH0pO1xuICogY29uc3QgZm9jdXNPbkNoYW5nZSA9IChmb2N1c2VkSW5uZXIgIT0gZmFsc2UpO1xuICogYGBgXG4gKiBJdCdzIG5vdCBpbmNsdWRlZCBoZXJlIGJlY2F1c2UgYHVzZVJvdmluZ1RhYkluZGV4YCBkb2Vzbid0IGtub3cgXG4gKiBhbnl0aGluZyBhYm91dCB0aGUgY29udGFpbmVyIGVsZW1lbnQsIG9ubHkgY2hpbGRyZW4gZWxlbWVudHMuXG4gKiBBbmQganVzdCBhcyB3ZWxsISBDaGlsZHJlbiBzaG91bGQgYmUgYWxsb3dlZCBhdCB0aGUgcm9vdCwgXG4gKiByZWdhcmRsZXNzIG9mIGlmIGl0J3MgdGhlIHdob2xlIGFwcCBvciBqdXN0IGEgZ2l2ZW4gY29tcG9uZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4ocGFyZW50UGFyYW1ldGVyczogVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPG5ldmVyLCBuZXZlcj4pOiBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG5cbiAgICBsZXQgeyByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVSZW5kZXIsIG9uVGFiYmFibGVJbmRleENoYW5nZSB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9ID0gcGFyZW50UGFyYW1ldGVycztcblxuICAgIGluaXRpYWxJbmRleCA/Pz0gMDtcbiAgICBjb25zdCBzdGFibGVPblRhYmJhYmxlUmVuZGVyID0gdXNlU3RhYmxlQ2FsbGJhY2sob25UYWJiYWJsZVJlbmRlciA/PyAoKCkgPT4geyB9KSk7XG4gICAgLypjb25zdCBbX2dldEFueUZvY3VzZWQsIHNldEFueUZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlcj4odXNlU3RhYmxlQ2FsbGJhY2soKG5ld0NvdW50OiBudW1iZXIsIG9sZENvdW50OiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKG9sZENvdW50ID09IDAgJiYgbmV3Q291bnQgPiAwKSB7XG4gICAgICAgICAgICBvblRhYmJlZEluVG8/LigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0NvdW50ID09IDAgJiYgKG9sZENvdW50ID8/IDApID4gMCkge1xuICAgICAgICAgICAgb25UYWJiZWRPdXRPZj8uKCk7XG4gICAgICAgIH1cbiAgICB9KSwgcmV0dXJuWmVybyk7Ki9cblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhyZWUgdGhpbmdzIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnRseSB0YWJiYWJsZSBlbGVtZW50J3MgaW5kZXg6XG4gICAgLy8gV2hhdCBpdCBpcywgYW5kIHdoZXRoZXIsIHdoZW4gd2UgcmVuZGVyIHRoaXMgY29tcG9uZW50IGFuZCBpdCdzIGNoYW5nZWQsIHRvIGFsc28gZm9jdXMgdGhlIGVsZW1lbnQgdGhhdCB3YXMgbWFkZSB0YWJiYWJsZS5cbiAgICBjb25zdCBbZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleDJdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGw+KG9uVGFiYmFibGVJbmRleENoYW5nZSwgdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gaW5pdGlhbEluZGV4ID8/IDAgfSwgW10pKTtcbiAgICBjb25zdCBzZXRUYWJiYWJsZUluZGV4ID0gdXNlQ2FsbGJhY2soKHVwZGF0ZXI6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xuICAgICAgICBzZXRUYWJiYWJsZUluZGV4MigocHJldkluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSB1cGRhdGVyKHByZXZJbmRleCA/PyBudWxsKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSB1cGRhdGVyO1xuXG4gICAgICAgICAgICBuZXh0SW5kZXggPSBjaGFuZ2VJbmRleChuZXh0SW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAocHJldkluZGV4ICE9IG5leHRJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IG5leHRJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KG5leHRJbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNoaWxkID0gcHJldkluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4uZ2V0QXQocHJldkluZGV4KTtcblxuICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hpbGQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcHJldkNoaWxkLnN1YkluZm8uYmx1clNlbGYoKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQgIT0gbnVsbCAmJiBmcm9tVXNlckludGVyYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hpbGQuc3ViSW5mby5mb2N1c1NlbGYoKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4O1xuICAgICAgICB9KTtcblxuICAgIH0sIFtdKTtcblxuICAgIC8vIEFueSB0aW1lIHRoZSB0YWJiYWJsZSBpbmRleCBjaGFuZ2VzLFxuICAgIC8vIG5vdGlmeSB0aGUgcHJldmlvdXMgY2hpbGQgdGhhdCBpdCdzIG5vIGxvbmdlciB0YWJiYWJsZSxcbiAgICAvLyBhbmQgbm90aWZ5IHRoZSBuZXh0IGNoaWxkIHRoYXQgaXMgYWxsb3dlZCB0byBiZSB0YWJiZWQgdG8uXG4gICAgY29uc3QgcGFyZW50UmV0dXJuVHlwZSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8+LCBFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiPih7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjoge1xuICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPbkNoaWxkcmVuTW91bnRDaGFuZ2U8bnVtYmVyPj4oKG1vdW50ZWQsIHVubW91bnRlZCkgPT4geyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/Lihtb3VudGVkLCB1bm1vdW50ZWQpOyByZWV2YWx1YXRlQ2xvc2VzdEZpdCgpOyB9KSxcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgdXNlTWFuYWdlZENoaWxkIH0gPSBwYXJlbnRSZXR1cm5UeXBlO1xuXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgfSA9IHVzZUNoaWxkcmVuRmxhZzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj4oeyBpbml0aWFsSW5kZXgsIGNoaWxkcmVuOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbiwgY2xvc2VzdEZpdDogdHJ1ZSwga2V5OiBcInRhYmJhYmxlXCIgfSk7XG5cbiAgICBjb25zdCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkID0gdXNlQ2FsbGJhY2s8VXNlUm92aW5nVGFiSW5kZXhDaGlsZDxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+PigoY2hpbGRQYXJhbWV0ZXJzKSA9PiB7XG5cbiAgICAgICAgY29uc3QgeyBzdWJJbmZvLCBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHJvdmluZ1RhYkluZGV4OiB7IGhpZGRlbiwgYmx1clNlbGY6IGJsdXJTZWxmT3ZlcnJpZGUsIGZvY3VzU2VsZjogZm9jdXNTZWxmT3ZlcnJpZGUgfSB9ID0gY2hpbGRQYXJhbWV0ZXJzO1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICByZWV2YWx1YXRlQ2xvc2VzdEZpdCgpO1xuICAgICAgICB9LCBbISFoaWRkZW5dKVxuXG5cbiAgICAgICAgY29uc3QgYnNPdmVycmlkZSA9IHVzZVN0YWJsZUdldHRlcihibHVyU2VsZk92ZXJyaWRlKTtcbiAgICAgICAgY29uc3QgZnNPdmVycmlkZSA9IHVzZVN0YWJsZUdldHRlcihmb2N1c1NlbGZPdmVycmlkZSk7XG4gICAgICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZzID0gZnNPdmVycmlkZSgpO1xuICAgICAgICAgICAgaWYgKGZzKSB7XG4gICAgICAgICAgICAgICAgZnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCkgYXMgKEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXM/LigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSk7XG4gICAgICAgIGNvbnN0IGJsdXJTZWxmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYnMgPSBic092ZXJyaWRlKCk7XG4gICAgICAgICAgICBpZiAoYnMpIHtcbiAgICAgICAgICAgICAgICBicygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKSBhcyAoRWxlbWVudCAmIFBhcnRpYWw8SFRNTEVsZW1lbnQ+KTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5ibHVyPy4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGNvbnN0IG9uRm9jdXNlZElubmVyQ2hhbmdlZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuLCBfcHJldkZvY3VzZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQsIHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPENoaWxkRWxlbWVudD4oeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIGdldERvY3VtZW50OiB1c2VDYWxsYmFjaygoKTogRG9jdW1lbnQgPT4geyByZXR1cm4gKGdldEVsZW1lbnQoKT8ub3duZXJEb2N1bWVudCkgPz8gKHdpbmRvdy5kb2N1bWVudCkgfSwgW10pIH0pO1xuXG4gICAgICAgIGNvbnN0IFt0YWJiYWJsZSwgc2V0VGFiYmFibGUsIGdldFRhYmJhYmxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAgICAgY29uc3QgdGFiYmFibGVGbGFncyA9IHVzZVJlZjxDaGlsZEZsYWdPcGVyYXRpb25zPih7IGdldDogZ2V0VGFiYmFibGUsIHNldDogc2V0VGFiYmFibGUsIGlzVmFsaWQ6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+ICFoaWRkZW4pIH0pO1xuXG4gICAgICAgIGNvbnN0IF86IHZvaWQgPSB1c2VNYW5hZ2VkQ2hpbGQoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHsgLi4uZmxhZ3MsIHRhYmJhYmxlOiB0YWJiYWJsZUZsYWdzLmN1cnJlbnQgfSBhcyBQYXJ0aWFsPFJlY29yZDxFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiLCBDaGlsZEZsYWdPcGVyYXRpb25zPj4sXG4gICAgICAgICAgICAgICAgc3ViSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICBibHVyU2VsZixcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNTZWxmLFxuICAgICAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46ICEhaGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICBzdWJJbmZvXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWJiYWJsZSlcbiAgICAgICAgICAgICAgICBzdGFibGVPblRhYmJhYmxlUmVuZGVyKGluZGV4KTtcbiAgICAgICAgfSwgW3RhYmJhYmxlLCBpbmRleF0pXG4gICAgICAgIGZ1bmN0aW9uIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4ge1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQocHJvcHMudGFiSW5kZXggPT0gbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50Pih1c2VIYXNGb2N1c1Byb3BzKHsgdGFiSW5kZXg6IHRhYmJhYmxlID8gMCA6IC0xIH0pLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGB1c2VSb3ZpbmdUYWJJbmRleC5mb2N1c1NlbGZgKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRUYWJiYWJsZUluZGV4KCk7XG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKVxuICAgICAgICAgICAgcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4uZ2V0QXQoaW5kZXgpPy5zdWJJbmZvLmZvY3VzU2VsZj8uKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobnVsbCwgdHJ1ZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbiB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleCxcbiAgICAgICAgICAgIGdldFRhYmJhYmxlSW5kZXgsXG4gICAgICAgICAgICBmb2N1c1NlbGYsXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKmZ1bmN0aW9uIHRlc3QoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgZm9jdXNTZWxmLCBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4LCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCB9ID0gdXNlUm92aW5nVGFiSW5kZXg8SFRNTERpdkVsZW1lbnQsIHsgXCJmb29cIjogXCJiYXJcIiB9LCBcImZsYWcyXCI+KHsgbWFuYWdlZENoaWxkcmVuOiB7fSwgcm92aW5nVGFiSW5kZXg6IHt9IH0pO1xuICAgIGNvbnN0IHsgfSA9IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQoeyBtYW5hZ2VkQ2hpbGRyZW46IHsgaW5kZXg6IDAsIGZsYWdzOiB7fSB9LCBydGk6IHsgaW5mbzM6IHsgZm9vOiBcImJhclwiIH0gfSB9KTtcbn0qL1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlBcnJheTtcbiIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUmFuZG9tO1xuIiwiaW1wb3J0IGJhc2VSYW5kb20gZnJvbSAnLi9fYmFzZVJhbmRvbS5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gIH1cbiAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaHVmZmxlU2VsZjtcbiIsImltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBzaHVmZmxlU2VsZiBmcm9tICcuL19zaHVmZmxlU2VsZi5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5U2h1ZmZsZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TWFwO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VWYWx1ZXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVGltZXM7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNBcmd1bWVudHM7XG4iLCJpbXBvcnQgYmFzZUlzQXJndW1lbnRzIGZyb20gJy4vX2Jhc2VJc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuaW1wb3J0IHN0dWJGYWxzZSBmcm9tICcuL3N0dWJGYWxzZS5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCdWZmZXI7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSW5kZXg7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5hcnk7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcbiIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcbiIsImltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlcztcbiIsImltcG9ydCBzaHVmZmxlU2VsZiBmcm9tICcuL19zaHVmZmxlU2VsZi5qcyc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJy4vdmFsdWVzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2h1ZmZsZTtcbiIsImltcG9ydCBhcnJheVNodWZmbGUgZnJvbSAnLi9fYXJyYXlTaHVmZmxlLmpzJztcbmltcG9ydCBiYXNlU2h1ZmZsZSBmcm9tICcuL19iYXNlU2h1ZmZsZS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICovXG5mdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaHVmZmxlO1xuIiwiaW1wb3J0ICogYXMgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE11dGFibGVSZWYsIHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZEluZm8sIE1hbmFnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VGb3JjZVVwZGF0ZSB9IGZyb20gXCIuL3VzZS1mb3JjZS11cGRhdGVcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCBsb2Rhc2hTaHVmZmxlIGZyb20gXCJsb2Rhc2gtZXMvc2h1ZmZsZVwiO1xuXG5leHBvcnQgdHlwZSBHZXRJbmRleDxDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChyb3c6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPikgPT4gKG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQpO1xuZXhwb3J0IHR5cGUgR2V0VmFsdWU8QywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWPiA9IChyb3c6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPiwgLi4uYXJnczogRykgPT4gVjtcbmV4cG9ydCB0eXBlIENvbXBhcmU8Vj4gPSAobGhzOiBWLCByaHM6IFYpID0+IG51bWJlcjtcblxuLyoqXG4gKiBBbGwgb2YgdGhlc2UgZnVuY3Rpb25zICoqTVVTVCoqIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcblxuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuLCBlLmcuLCB0aGUgcm93IGluZGV4IG9mIHRoaXMgY2hpbGRcbiAgICAgKiAoVXN1YWxseSBqdXN0IGFuIGBpbmRleGAgcHJvcClcbiAgICAgKi9cbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXg6IEdldEluZGV4PEMsIEs+OyB9XG59XG5cbi8qKlxuICogQWxsIG9mIHRoZXNlIGZ1bmN0aW9ucyAqKk1VU1QqKiBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWPiBleHRlbmRzIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSz4ge1xuICAgIHNvcnRhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11c3QgcmV0dXJuIHRoZSB2YWx1ZSB0aGlzIGNoaWxkIHVzZXMgUkU6IHNvcnRpbmcuXG4gICAgICAgICAqIElmIHlvdSBkb24ndCBjYXJlIGFib3V0IHNvcnRpbmcgKHlvdSBqdXN0IHVzZSBcbiAgICAgICAgICogeW91ciBvd25hcmJpdHJhcnkgcmVvcmRlcmluZyksIHRoaXMgd2lsbCBuZXZlclxuICAgICAgICAgKiBiZSB1c2VkLCBzbyBpdCBjYW4gcmV0dXJuIGFueXRoaW5nLlxuICAgICAgICAgKiBAcGFyYW0gcm93IFxuICAgICAgICAgKiBAcGFyYW0gYXJncyBcbiAgICAgICAgICovXG4gICAgICAgIGdldFZhbHVlOiBHZXRWYWx1ZTxDLCBLLCBHLCBWPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udHJvbHMgaG93IHZhbHVlcyBjb21wYXJlIGFnYWluc3QgZWFjaCBvdGhlci5cbiAgICAgICAgICogQHBhcmFtIGxocyBcbiAgICAgICAgICogQHBhcmFtIHJocyBcbiAgICAgICAgICovXG4gICAgICAgIGNvbXBhcmU6IENvbXBhcmU8Vj47XG4gICAgfVxufVxuXG5cblxuLyoqXG4gKiBIb29rIHRoYXQgYWxsb3dzIGZvciB0aGUgKipkaXJlY3QgZGVzY2VuZGFudCoqIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IHRvIGJlIHJlLW9yZGVyZWQgYW5kIHNvcnRlZC5cbiAqIFxuICogKlRoaXMgaXMgKipzZXBhcmF0ZSoqIGZyb20gXCJtYW5hZ2VkXCIgY2hpbGRyZW4sIHdoaWNoIGNhbiBiZSBhbnkgbGV2ZWwgb2YgY2hpbGQgbmVlZGVkISBTb3J0YWJsZS9yZWFycmFuZ2VhYmxlIGNoaWxkcmVuIG11c3QgYmUgKipkaXJlY3QgZGVzY2VuZGFudHMqKiBvZiB0aGUgcGFyZW50IHRoYXQgdXNlcyB0aGlzIGhvb2shKlxuICogXG4gKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uYDsgaXQgdGFrZXMgdGhlIHNhbWUgYGluZGV4TWFuZ2xlcmAgYW5kIGBpbmRleERlbWFuZ2xlcmAgXG4gKiBmdW5jdGlvbnMgdGhhdCB0aGlzIGhvb2sgcmV0dXJucy4gYHVzZUxpc3ROYXZpZ2F0aW9uYCBkb2VzIG5vdCBkaXJlY3RseSB1c2UgdGhpcyBob29rIGJlY2F1c2UsIGFzIG1lbnRpb25lZCwgXG4gKiB0aGlzIGhvb2sgaW1wb3NlcyBzZXJpb3VzIHJlc3RyaWN0aW9ucyBvbiBjaGlsZCBzdHJ1Y3R1cmUsIHdoaWxlIGB1c2VMaXN0TmF2aWdhdGlvbmAgYWxsb3dzIGFueXRoaW5nLlxuICogXG4gKiBCZXNpZGVzIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIHRoYXQncyByZXR1cm5lZCwgdGhlIGBzb3J0YCBmdW5jdGlvbiB0aGF0J3MgcmV0dXJuZWQgd2lsbFxuICogc29ydCBhbGwgY2hpbGRyZW4gYWNjb3JkaW5nIHRvIHRoZWlyIHZhbHVlIGZyb20gdGhlIGBnZXRWYWx1ZWAgYXJndW1lbnQgeW91IHBhc3MgaW4uXG4gKiBcbiAqIElmIHlvdSB3YW50IHRvIHBlcmZvcm0gc29tZSByZS1vcmRlcmluZyBvcGVyYXRpb24gdGhhdCdzICpub3QqIGEgc29ydCwgeW91IGNhbiBtYW51YWxseVxuICogcmUtbWFwIGVhY2ggY2hpbGQncyBwb3NpdGlvbiB1c2luZyBgbWFuZ2xlTWFwYCBhbmQgYGRlbWFuZ2xlTWFwYCwgd2hpY2ggY29udmVydCBiZXR3ZWVuXG4gKiBzb3J0ZWQgYW5kIHVuc29ydGVkIGluZGV4IHBvc2l0aW9ucy5cbiAqIFxuICogQWdhaW4sIHVubGlrZSBzb21lIG90aGVyIGhvb2tzLCAqKnRoZXNlIGNoaWxkcmVuIG11c3QgYmUgZGlyZWN0IGRlc2NlbmRhbnRzKiouIFRoaXMgaXMgYmVjYXVzZVxuICogdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgaW5zcGVjdHMgdGhlIGdpdmVuIGNoaWxkcmVuLCB0aGVuIHJlLWNyZWF0ZXMgdGhlbSB3aXRoIG5ldyBga2V5YHMuXG4gKiBCZWNhdXNlIGtleXMgYXJlIGdpdmVuIHNwZWNpYWwgdHJlYXRtZW50IGFuZCBhIGNoaWxkIGhhcyBubyB3YXkgb2YgbW9kaWZ5aW5nIGl0cyBvd24ga2V5XG4gKiB0aGVyZSdzIG5vIG90aGVyIHRpbWUgb3IgcGxhY2UgdGhpcyBjYW4gaGFwcGVuIG90aGVyIHRoYW4gZXhhY3RseSB3aXRoaW4gdGhlIHBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4IH0gfTogVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLPik6IFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQywgSz4ge1xuXG4gICAgLy8gVGhlc2UgYXJlIHVzZWQgdG8ga2VlcCB0cmFjayBvZiBhIG1hcHBpbmcgYmV0d2VlbiB1bnNvcnRlZCBpbmRleCA8LS0tPiBzb3J0ZWQgaW5kZXguXG4gICAgLy8gVGhlc2UgYXJlIG5lZWRlZCBmb3IgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzLlxuICAgIGNvbnN0IG1hbmdsZU1hcCA9IHVzZVJlZihuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpKTtcbiAgICBjb25zdCBkZW1hbmdsZU1hcCA9IHVzZVJlZihuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpKTtcbiAgICBjb25zdCBpbmRleE1hbmdsZXIgPSB1c2VDYWxsYmFjaygobjogbnVtYmVyKSA9PiAobWFuZ2xlTWFwLmN1cnJlbnQuZ2V0KG4pID8/IG4pLCBbXSk7XG4gICAgY29uc3QgaW5kZXhEZW1hbmdsZXIgPSB1c2VDYWxsYmFjaygobjogbnVtYmVyKSA9PiAoZGVtYW5nbGVNYXAuY3VycmVudC5nZXQobikgPz8gbiksIFtdKTtcblxuICAgIC8vIFRoZSBzb3J0IGZ1bmN0aW9uIG5lZWRzIHRvIGJlIGFibGUgdG8gdXBkYXRlIHdob2V2ZXIgaGFzIGFsbCB0aGUgc29ydGFibGUgY2hpbGRyZW4uXG4gICAgLy8gQmVjYXVzZSB0aGF0IG1pZ2h0IG5vdCBiZSB0aGUgY29uc3VtZXIgb2YgKnRoaXMqIGhvb2sgZGlyZWN0bHkgKGUuZy4gYSB0YWJsZSB1c2VzXG4gICAgLy8gdGhpcyBob29rLCBidXQgaXQncyB0Ym9keSB0aGF0IGFjdHVhbGx5IG5lZWRzIHVwZGF0aW5nKSwgd2UgbmVlZCB0byByZW1vdGVseVxuICAgIC8vIGdldCBhbmQgc2V0IGEgZm9yY2VVcGRhdGUgZnVuY3Rpb24uXG4gICAgLy9jb25zdCBbZ2V0Rm9yY2VVcGRhdGUsIHNldEZvcmNlVXBkYXRlXSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgKCgpID0+IHZvaWQpPihudWxsLCByZXR1cm5OdWxsKTtcbiAgICBjb25zdCBbZ2V0Rm9yY2VVcGRhdGUsIHNldEZvcmNlVXBkYXRlXSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgKCgpID0+IHZvaWQpPihudWxsLCByZXR1cm5OdWxsKTtcblxuICAgIGNvbnN0IHJlYXJyYW5nZSA9IHVzZUNhbGxiYWNrKChzb3J0ZWRSb3dzOiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz5bXSkgPT4ge1xuXG4gICAgICAgIC8vIFVwZGF0ZSBvdXIgc29ydGVkIDwtLT4gdW5zb3J0ZWQgaW5kaWNlcyBtYXAgXG4gICAgICAgIC8vIGFuZCByZXJlbmRlciB0aGUgd2hvbGUgdGFibGUsIGJhc2ljYWxseVxuICAgICAgICBmb3IgKGxldCBpbmRleEFzU29ydGVkID0gMDsgaW5kZXhBc1NvcnRlZCA8IHNvcnRlZFJvd3MubGVuZ3RoOyArK2luZGV4QXNTb3J0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4QXNVbnNvcnRlZCA9IHNvcnRlZFJvd3NbaW5kZXhBc1NvcnRlZF0uaW5kZXg7XG5cbiAgICAgICAgICAgIG1hbmdsZU1hcC5jdXJyZW50LnNldChpbmRleEFzVW5zb3J0ZWQsIGluZGV4QXNTb3J0ZWQpO1xuICAgICAgICAgICAgZGVtYW5nbGVNYXAuY3VycmVudC5zZXQoaW5kZXhBc1NvcnRlZCwgaW5kZXhBc1Vuc29ydGVkKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgZ2V0Rm9yY2VVcGRhdGUoKT8uKCk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgdXNlUmVhcnJhbmdlYWJsZVByb3BzID0gdXNlQ2FsbGJhY2soKHsgY2hpbGRyZW4sIC4uLnByb3BzIH06IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuPzogVk5vZGU8YW55PltdIH0pID0+IHtcblxuICAgICAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHNldEZvcmNlVXBkYXRlKF9wcmV2ID0+IGZvcmNlVXBkYXRlKTsgfSwgW2ZvcmNlVXBkYXRlXSlcblxuICAgICAgICByZXR1cm4gKHVzZU1lcmdlZFByb3BzPFBhcmVudEVsZW1lbnQ+KHtcbiAgICAgICAgICAgIGNoaWxkcmVuOlxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiBhcyBWTm9kZTxNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4+W10pXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoY2hpbGQgPT4gKHsgY2hpbGQsIG1hbmdsZWRJbmRleDogaW5kZXhNYW5nbGVyKGdldEluZGV4KGNoaWxkLnByb3BzISkhKSwgZGVtYW5nbGVkSW5kZXg6IGdldEluZGV4KGNoaWxkLnByb3BzKSB9KSlcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGxocywgcmhzKSA9PiB7IHJldHVybiBsaHMubWFuZ2xlZEluZGV4IC0gcmhzLm1hbmdsZWRJbmRleCB9KVxuICAgICAgICAgICAgICAgICAgICAubWFwKCh7IGNoaWxkLCBtYW5nbGVkSW5kZXgsIGRlbWFuZ2xlZEluZGV4IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoKGNoaWxkLnR5cGUgYXMgYW55LCB7IC4uLmNoaWxkLnByb3BzLCBrZXk6IGRlbWFuZ2xlZEluZGV4LCBcImRhdGEtbWFuZ2xlZC1pbmRleFwiOiBtYW5nbGVkSW5kZXgsIFwiZGF0YS11bm1hbmdsZWQtaW5kZXhcIjogZGVtYW5nbGVkSW5kZXggfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIHByb3BzKSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHsgdXNlUmVhcnJhbmdlYWJsZVByb3BzLCByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgaW5kZXhNYW5nbGVyLCBpbmRleERlbWFuZ2xlciwgbWFuZ2xlTWFwLCBkZW1hbmdsZU1hcCwgcmVhcnJhbmdlIH0gfTtcbn1cblxuXG4vKipcbiAqIEhvb2sgdGhhdCBhbGxvd3MgZm9yIHRoZSAqKmRpcmVjdCBkZXNjZW5kYW50KiogY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgdG8gYmUgcmUtb3JkZXJlZCBhbmQgc29ydGVkLlxuICogXG4gKiAqVGhpcyBpcyAqKnNlcGFyYXRlKiogZnJvbSBcIm1hbmFnZWRcIiBjaGlsZHJlbiwgd2hpY2ggY2FuIGJlIGFueSBsZXZlbCBvZiBjaGlsZCBuZWVkZWQhIFNvcnRhYmxlL3JlYXJyYW5nZWFibGUgY2hpbGRyZW4gbXVzdCBiZSAqKmRpcmVjdCBkZXNjZW5kYW50cyoqIG9mIHRoZSBwYXJlbnQgdGhhdCB1c2VzIHRoaXMgaG9vayEqIFxuICogXG4gKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uYDsgaXQgdGFrZXMgdGhlIHNhbWUgYGluZGV4TWFuZ2xlcmAgYW5kIGBpbmRleERlbWFuZ2xlcmAgXG4gKiBmdW5jdGlvbnMgdGhhdCB0aGlzIGhvb2sgcmV0dXJucy4gYHVzZUxpc3ROYXZpZ2F0aW9uYCBkb2VzIG5vdCBkaXJlY3RseSB1c2UgdGhpcyBob29rIGJlY2F1c2UsIGFzIG1lbnRpb25lZCwgXG4gKiB0aGlzIGhvb2sgaW1wb3NlcyBzZXJpb3VzIHJlc3RyaWN0aW9ucyBvbiBjaGlsZCBzdHJ1Y3R1cmUsIHdoaWxlIGB1c2VMaXN0TmF2aWdhdGlvbmAgYWxsb3dzIGFueXRoaW5nLlxuICogXG4gKiBCZXNpZGVzIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIHRoYXQncyByZXR1cm5lZCwgdGhlIGBzb3J0YCBmdW5jdGlvbiB0aGF0J3MgcmV0dXJuZWQgd2lsbFxuICogc29ydCBhbGwgY2hpbGRyZW4gYWNjb3JkaW5nIHRvIHRoZWlyIHZhbHVlIGZyb20gdGhlIGBnZXRWYWx1ZWAgYXJndW1lbnQgeW91IHBhc3MgaW4uXG4gKiBcbiAqIElmIHlvdSB3YW50IHRvIHBlcmZvcm0gc29tZSByZS1vcmRlcmluZyBvcGVyYXRpb24gdGhhdCdzICpub3QqIGEgc29ydCwgeW91IGNhbiBtYW51YWxseVxuICogcmUtbWFwIGVhY2ggY2hpbGQncyBwb3NpdGlvbiB1c2luZyBgbWFuZ2xlTWFwYCBhbmQgYGRlbWFuZ2xlTWFwYCwgd2hpY2ggY29udmVydCBiZXR3ZWVuXG4gKiBzb3J0ZWQgYW5kIHVuc29ydGVkIGluZGV4IHBvc2l0aW9ucy5cbiAqIFxuICogQWdhaW4sIHVubGlrZSBzb21lIG90aGVyIGhvb2tzLCAqKnRoZXNlIGNoaWxkcmVuIG11c3QgYmUgZGlyZWN0IGRlc2NlbmRhbnRzKiouIFRoaXMgaXMgYmVjYXVzZVxuICogdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgaW5zcGVjdHMgdGhlIGdpdmVuIGNoaWxkcmVuLCB0aGVuIHJlLWNyZWF0ZXMgdGhlbSB3aXRoIG5ldyBga2V5YHMuXG4gKiBCZWNhdXNlIGtleXMgYXJlIGdpdmVuIHNwZWNpYWwgdHJlYXRtZW50IGFuZCBhIGNoaWxkIGhhcyBubyB3YXkgb2YgbW9kaWZ5aW5nIGl0cyBvd24ga2V5XG4gKiB0aGVyZSdzIG5vIG90aGVyIHRpbWUgb3IgcGxhY2UgdGhpcyBjYW4gaGFwcGVuIG90aGVyIHRoYW4gZXhhY3RseSB3aXRoaW4gdGhlIHBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10sIFY+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4IH0sIHNvcnRhYmxlQ2hpbGRyZW46IHsgY29tcGFyZTogdXNlckNvbXBhcmUsIGdldFZhbHVlIH0gfTogVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSywgRywgVj4pOiBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDLCBLLCBHPiB7XG5cbiAgICBjb25zdCBjb21wYXJlID0gKHVzZXJDb21wYXJlID8/IGRlZmF1bHRDb21wYXJlKTtcblxuICAgIGNvbnN0IHsgdXNlUmVhcnJhbmdlYWJsZVByb3BzOiB1c2VTb3J0YWJsZVByb3BzLCAuLi5yZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlIH0gPSB1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgQywgSz4oeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXggfSB9KTtcbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyByZWFycmFuZ2UgfSB9ID0gcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZTtcbiAgICAvLyBUaGUgYWN0dWFsIHNvcnQgZnVuY3Rpb24uXG4gICAgY29uc3Qgc29ydCA9IHVzZUNhbGxiYWNrKChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4sIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiLCAuLi5hcmdzOiBHKTogUHJvbWlzZTx2b2lkPiB8IHZvaWQgPT4ge1xuXG4gICAgICAgIGNvbnN0IHNvcnRlZFJvd3MgPSBtYW5hZ2VkUm93cy5hcnJheVNsaWNlKCkuc29ydCgobGhzUm93LCByaHNSb3cpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgbGhzVmFsdWUgPSBnZXRWYWx1ZShsaHNSb3csIC4uLmFyZ3MpIGFzIGFueTtcbiAgICAgICAgICAgIGNvbnN0IHJoc1ZhbHVlID0gZ2V0VmFsdWUocmhzUm93LCAuLi5hcmdzKSBhcyBhbnk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJlKGxoc1ZhbHVlLCByaHNWYWx1ZSkgLy8gbGhzUm93LmdldE1hbmFnZWRDZWxscygpPy5bY29sdW1uXT8udmFsdWUsIHJoc1Jvdy5nZXRNYW5hZ2VkQ2VsbHMoKT8uW2NvbHVtbl0/LnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb25bMF0gPT0gXCJkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC1yZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWFycmFuZ2Uoc29ydGVkUm93cyk7XG5cbiAgICB9LCBbIC8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3Qgc2h1ZmZsZSA9IHVzZUNhbGxiYWNrKChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4pOiBQcm9taXNlPHZvaWQ+IHwgdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IHNodWZmbGVkUm93cyA9IGxvZGFzaFNodWZmbGUobWFuYWdlZFJvd3MuYXJyYXlTbGljZSgpKVxuICAgICAgICByZXR1cm4gcmVhcnJhbmdlKHNodWZmbGVkUm93cyk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjogeyBzb3J0LCBzaHVmZmxlIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZS5yZWFycmFuZ2VhYmxlQ2hpbGRyZW5cbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3MgYW4gYXJyYXkgb2Ygbm90LXNvcnRlZCBjaGlsZCBpbmZvcm1hdGlvbiB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAqIGFuZCB0aGUgY2hpbGRyZW4gd2lsbCByZS1hcnJhbmdlIHRoZW1zZWx2ZXMgdG8gbWF0Y2guXG4gICAgICAgICAqICBcbiAgICAgICAgICogKipTVEFCTEUqKlxuICAgICAgICAgKiAgXG4gICAgICAgICAqIFxuICAgICAgICAgKi9cbiAgICAgICAgcmVhcnJhbmdlOiAocm93c0luT3JkZXI6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPltdKSA9PiB2b2lkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBpbmRleE1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgbWFuZ2xlTWFwOiBNdXRhYmxlUmVmPE1hcDxudW1iZXIsIG51bWJlcj4+O1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBkZW1hbmdsZU1hcDogTXV0YWJsZVJlZjxNYXA8bnVtYmVyLCBudW1iZXI+PjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VSZWFycmFuZ2VhYmxlUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW4/OiBWTm9kZTxhbnk+W10gfCB1bmRlZmluZWQ7IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+O1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLPiB7XG4gICAgc29ydGFibGVDaGlsZHJlbjogey8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNvcnQ6IChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4sIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiLCAuLi5hcmdzOiBHKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgc2h1ZmZsZTogKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPikgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gICAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzXG4gICAgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEssIEc+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVNvcnRhYmxlUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW4/OiBWTm9kZTxhbnk+W10gfCB1bmRlZmluZWQ7IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGxoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkLCByaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjb21wYXJlMShsaHMsIHJocyk7XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlMyhsaHM6IHN0cmluZyB8IG51bWJlciwgcmhzOiBzdHJpbmcgfCBudW1iZXIpIHtcblxuICAgICAgICAvLyBDb2VyY2Ugc3RyaW5ncyB0byBudW1iZXJzIGlmIHRoZXkgc2VlbSB0byBzdGF5IHRoZSBzYW1lIHdoZW4gc2VyaWFsaXplZFxuICAgICAgICBpZiAoYCR7K2xoc31gID09PSBsaHMpXG4gICAgICAgICAgICBsaHMgPSArbGhzO1xuICAgICAgICBpZiAoYCR7K3Joc31gID09PSByaHMpXG4gICAgICAgICAgICByaHMgPSArcmhzO1xuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGlmIGVpdGhlciBhcmd1bWVudCBpcyBhIHN0cmluZywgdHVybiB0aGUgb3RoZXIgb25lIGludG8gb25lIHRvb1xuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJocyA9IGAke3Joc31gO1xuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGxocyA9IGAke2xoc31gO1xuXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBsaHMgPT09IHR5cGVvZiByaHMpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGxocy5sb2NhbGVDb21wYXJlKHJocyBhcyBzdHJpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiArbGhzIC0gK3JocztcblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZTIobGhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSwgcmhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJib29sZWFuXCIgfHwgbGhzIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgIGxocyA9ICtsaHM7XG4gICAgICAgIGlmICh0eXBlb2YgcmhzID09PSBcImJvb2xlYW5cIiB8fCByaHMgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICAgICAgcmhzID0gK3JocztcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUzKGxocywgcmhzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZTEobGhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhleSdyZSBib3RoIG51bGxcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxocyA9PSBudWxsIHx8IHJocyA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBPbmUgb2YgdGhlIHR3byBpcyBudWxsIC0tIGVhc3kgY2FzZVxuICAgICAgICAgICAgcmV0dXJuIGxocyAhPSBudWxsID8gMSA6IC0xXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBhcmUyKGxocywgcmhzKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlUHJlc3MgfSBmcm9tIFwiLi91c2UtcHJlc3NcIjtcbmltcG9ydCB7IHVzZUNoaWxkcmVuSGF2ZUZvY3VzLCBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnMsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1oYXMtZm9jdXNcIjtcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW4sIE1hbmFnZWRDaGlsZHJlbk9taXRzLCB1c2VDaGlsZHJlbkZsYWcgfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIHVzZUxpbmVhck5hdmlnYXRpb24sIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIHVzZVR5cGVhaGVhZE5hdmlnYXRpb24sIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VFbnN1cmVTdGFiaWxpdHkgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgdXNlUm92aW5nVGFiSW5kZXgsIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm8sIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVycywgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbywgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvIH0gZnJvbSBcIi4vdXNlLXJvdmluZy10YWJpbmRleFwiO1xuaW1wb3J0IHsgdXNlU29ydGFibGVDaGlsZHJlbiwgVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMsIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1zb3J0YWJsZS1jaGlsZHJlblwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcblxuXG4vKipcbiAqIFxuICogVE9ETzogVGhpcyB0YWJsZSB3YXMgc2NyYXBwZWQgd2hlbiB0aGlzIHdhcyBjaGFuZ2VkIHRvIGp1c3QgYWNjZXB0IGEgY29sbGF0b3IgZGlyZWN0bHksXG4gKiBidXQgaXQncyBub3QgYmFkIGZvciBhIGNvbGxhdGlvbiBjcmFzaCBjb3Vyc2UgYW5kIEkgbWlnaHQgdXNlIGl0IGFnYWluLlxuICogRXZlbiBqdXN0IGFzIGEgXCJ0aGlzIGlzIHdoeSBpdCdzIGltcG9ydGFudCBhbmQgZ29vZCB0byB1c2UgdGhlc2UgdGhpbmdzXCIgdGhpbmcuXG4gKiBcbiAqIHxMYW5nLnxUYXJnZXR8VXNlciBpbnB1dHxgYmFzZWB8YGFjY2VudGB8YGNhc2VgfGB2YXJpYW50YHxcbiAqIHwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfFxuICogfEVOfEhpfEJ5ZXzinYx84p2MfOKdjHzinYx8XG4gKiB8RU58SGl8SGl84pyFfOKchXzinIV84pyFfFxuICogfEVOfEhpfO+8qO+9iXzinIV84pyFfOKchXzinYx8XG4gKiB8RU58SGl8aGl84pyFfOKchXzinYx84p2MfFxuICogfEVOfEhpfEjDr3zinIV84p2MfOKdjHzinYx8XG4gKiB8RU58w6V8YWF84p2MfOKdjHzinYx84p2MfFxuICogfERBfMOlfGFhfOKchXzinIV84pyFfOKdjHxcbiAqIHxEQXzDpXxBQXzinIV84pyFfOKdjHzinYx8XG4gKiB8REF8w6V8QWF84pyFfOKchXzinYx84p2MfFxuICogfERBfMOlfGFBfOKdjHzinYx84p2MfOKdjHxcbiAqIHxFTnzDpXxhfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxhfOKchXzinIV84p2MfOKdjHxcbiAqIHxKUHzvqqp8552AfOKchXzinIV84pyFfOKchXxcbiAqIHxKUHzjgqt87722fOKchXzinIV84pyFfOKchXxcbiAqIHxKUHzjgqt844GLfOKchXzinIV84pyFfOKdjHxcbiAqIHxKUHzjgqt844O1fOKchXzinIV84pyFfOKdjHxcbiAqIHxKUHzjgqt844uVfOKchXzinIV84p2MfOKdjHxcbiAqIHxKUHzjgqt844KsfOKchXzinYx84p2MfOKdjHxcbiAqIHxKUHzjgqt85YqbfOKdjHzinYx84p2MfOKdjHxcbiAqIHxaSHzntIV857qifOKdjHzinYx84p2MfOKdjHxcbiAqIFxuICogXG4gKiAoTm90ZSB0byBzZWxmOiBBdCBzb21lIHBvaW50LCB0aGlzIGZpbGUgd2lsbCBwcm9iYWJseSBiZSBub3JtYWxpemVkXG4gKiBieSBzb21lYm9keSBhbmQg76qqIHdpbGwgdHVybiBiYWNrIGludG8g552ALilcbiAqIFxuICovXG5jb25zdCBfZHVtbXk6IGFueSA9IG51bGw7XG5cblxuZnVuY3Rpb24gaWRlbnRpdHk8VD4odDogVCkgeyByZXR1cm4gdDsgfVxudHlwZSBPbWl0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFBpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLPj47XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxDPiB7XG4gICAgdGV4dDogc3RyaW5nO1xuXG4gICAgc3ViSW5mbzogQztcbn1cblxuLyoqXG4gKiBAcGFyYW0gZnJvbVVzZXJJbnRlcmFjdGlvbiBXaGV0aGVyIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGlzIGNoaWxkIGFzIGEgbWVhbnMgb2YgbmF2aWdhdGluZyB0byBpdC4gIEluIHRoYXQgd2FzIHRoZSBjYXNlLCB0aGUgY2hpbGQgaXMgYWxzbyBmb2N1c2VkLiBPdGhlcndpc2UsIGZvY3VzIG1vdmVzIGFzIHRoZSBicm93c2VyIGRldGVybWluZXMuXG4gKi9cbmV4cG9ydCB0eXBlIE5hdmlnYXRlVG9JbmRleCA9IChpOiBudW1iZXIgfCBudWxsLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xuXG5cbmludGVyZmFjZSBMU1Age1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBhbmQgaW5kZXhEZW1hbmdsZXIgYXJlIHVzZWQgdG8gYWxsb3cgY2hpbGRyZW4gdG8gYmUgbmF2aWdhdGVkIGluIGFuIG9yZGVyXG4gICAgICogdGhhdCBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1hdGNoIHRoZWlyIGNoaWxkIG9yZGVyLCBsaWtlIGlmIGEgbGlzdCBpcyBzb3J0ZWQuXG4gICAgICogXG4gICAgICogVXNlZCB0byB0dXJuIGFuIFwiYWJzb2x1dGVcIiBpbmRleCBpbnRvIGEgXCJzb3J0ZWQvZmlsdGVyZWQvbWFuZ2xlZFwiIG9uZS5cbiAgICAgKiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgbmF2aWdhdGVUb0ZpcnN0IG1hbmdsZXMgMCBhbmQgbmF2aWdhdGVzIHRvIHRoYXQgcmVzdWx0aW5nIHJvdy5cbiAgICAgKiBAcGFyYW0gcmF3SW5kZXggXG4gICAgICovXG4gICAgaW5kZXhNYW5nbGVyPyhyYXdJbmRleDogbnVtYmVyKTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byB0dXJuIGEgXCJtYW5nbGVkXCIgaW5kZXggaW50byBpdCdzIFwidW5zb3J0ZWRcIiBvciBcInVubWFuZ2xlZFwiIGluZGV4LlxuICAgICAqIFxuICAgICAqIEZvciBleGFtcGxlLCB3aGVuIGluY3JlbWVudGluZyBvciBkZWNyZW1lbnRpbmcgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpbmRleCxcbiAgICAgKiBpdCBuZWVkcyB0byBiZSBkZW1hbmdsZWQgdG8gZG8gXCJub3JtYWxcIiBtYXRoIG9uIGl0LCBhbmQgdGhlbiByZS1tYW5nbGVkIChhYm92ZSlcbiAgICAgKiB0byB0dXJuIHRoYXQgYWJzb2x1dGUgcm93IGluZGV4IGJhY2sgaW50byBhIG1hbmdsZWQgb25lLlxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1lZEluZGV4IFxuICAgICAqL1xuICAgIGluZGV4RGVtYW5nbGVyPyh0cmFuc2Zvcm1lZEluZGV4OiBudW1iZXIpOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzID0ga2V5b2YgTFNQO1xuXG4vLyAqKiogUGFyYW1ldGVycyAobGlzdCwgbGlzdC1zaW5nbGUsIGxpc3QtY2hpbGQsIGxpc3Qtc2luZ2xlLWNoaWxkKVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHNcbiAgICBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8UnRpT21pdHMsIE1jT21pdHM+LFxuICAgIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFRuT21pdHMgfCBcImdldEluZGV4XCIgfCBcInNldEluZGV4XCI+LFxuICAgIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPExuT21pdHMgfCBcIm5hdmlnYXRlVG9GaXJzdFwiIHwgXCJuYXZpZ2F0ZVRvTGFzdFwiIHwgXCJuYXZpZ2F0ZVRvTmV4dFwiIHwgXCJuYXZpZ2F0ZVRvUHJldlwiPiB7XG4gICAgbGlzdE5hdmlnYXRpb246IE9taXQ8TFNQLCBMc09taXRzPjtcbn1cblxuaW50ZXJmYWNlIFNTUCB7XG4gICAgc2VsZWN0ZWRJbmRleDogbnVtYmVyIHwgbnVsbDtcbiAgICBvblNlbGVjdGVkSW5kZXhDaGFuZ2U6IChldmVudDogRXZlbnQsIG5ld0luZGV4OiBudW1iZXIpID0+IHZvaWQ7XG4gICAgc2VsZWN0aW9uTW9kZTogXCJmb2N1c1wiIHwgXCJhY3RpdmF0aW9uXCI7XG59XG5leHBvcnQgdHlwZSBTaW5nbGVTZWxlY3Rpb25PbWl0cyA9IGtleW9mIFNTUDtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8U1NPbWl0cyBleHRlbmRzIFNpbmdsZVNlbGVjdGlvbk9taXRzLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cywgTG5PbWl0cywgVG5PbWl0cywgUnRpT21pdHMgfCBcImluaXRpYWxJbmRleFwiLCBNY09taXRzPiB7XG4gICAgc2luZ2xlU2VsZWN0aW9uOiBPbWl0PFNTUCwgU1NPbWl0cz47XG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IFBhcnRpYWw8VXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzW1wiY2hpbGRyZW5IYXZlRm9jdXNcIl0+O1xufVxuZXhwb3J0IHR5cGUgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzID0ga2V5b2YgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPGFueT47XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cywgUnRpT21pdHMsIE1jT21pdHMsIFN1YmJlc3RJbmZvPiB7XG4gICAgLy9yb3ZpbmdUYWJJbmRleDogT21pdDxVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cywgbmV2ZXI+W1wicm92aW5nVGFiSW5kZXhcIl0sIFwic3ViSW5mb1wiPjtcbiAgICBsaXN0TmF2aWdhdGlvbjogT21pdDxVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgTHNPbWl0cyB8IFwic3ViSW5mb1wiPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSyB8IFwic2VsZWN0ZWRcIiwgTHNPbWl0cywgUnRpT21pdHMsIE1jT21pdHMsIFN1YmJlc3RJbmZvPiB7XG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxFPjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPj4sIFwidGFiYmFibGVcIiB8IEV4dHJhRmxhZ0tleXM+LCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4OiBOYXZpZ2F0ZVRvSW5kZXggfTtcbn1cblxuLy8gKioqIFJldHVybiB0eXBlcyAobGlzdCwgbGlzdC1zaW5nbGUsIGxpc3QtY2hpbGQsIGxpc3Qtc2luZ2xlLWNoaWxkKVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcbiAgICBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG5cbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+O1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcbiAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IHt9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz5bXCJ1c2VMaXN0TmF2aWdhdGlvblByb3BzXCJdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IHtcbiAgICAgICAgc2VsZWN0ZWQ6IGJvb2xlYW47XG4gICAgICAgIGdldFNlbGVjdGVkKCk6IGJvb2xlYW47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wczogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PltcInVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wc1wiXTtcbn1cblxuXG5leHBvcnQgdHlwZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIEM+KSA9PiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5leHBvcnQgdHlwZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKHA6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQz4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5cblxuXG4vKipcbiAqIEltcGxlbWVudHMgcHJvcGVyIGtleWJvYXJkIG5hdmlnYXRpb24gZm9yIGNvbXBvbmVudHMgbGlrZSBsaXN0Ym94ZXMsIGJ1dHRvbiBncm91cHMsIG1lbnVzLCBldGMuXG4gKiBcbiAqIEluIHRoZSBkb2N1bWVudCBvcmRlciwgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSBcImZvY3VzZWRcIiBvciBcInRhYmJhYmxlXCIgZWxlbWVudCwgbWFraW5nIGl0IGFjdCBtb3JlIGxpa2Ugb25lIGNvbXBsZXRlIHVuaXQgaW4gY29tcGFyaXNvbiB0byBldmVyeXRoaW5nIGFyb3VuZCBpdC5cbiAqIE5hdmlnYXRpbmcgZm9yd2FyZHMvYmFja3dhcmRzIGNhbiBiZSBkb25lIHdpdGggdGhlIGFycm93IGtleXMsIEhvbWUvRW5kIGtleXMsIG9yIGFueSBhbnkgdGV4dCBmb3IgdHlwZWFoZWFkIHRvIGZvY3VzIHRoZSBuZXh0IGl0ZW0gdGhhdCBtYXRjaGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+KHtcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IG1jLFxuICAgIHJvdmluZ1RhYkluZGV4LFxuICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25cbn06IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4ge1xuICAgIGluZGV4TWFuZ2xlciA/Pz0gaWRlbnRpdHk7XG4gICAgaW5kZXhEZW1hbmdsZXIgPz89IGlkZW50aXR5O1xuXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTGlzdE5hdmlnYXRpb25cIiwgaW5kZXhNYW5nbGVyLCBpbmRleERlbWFuZ2xlcik7XG5cblxuICAgIGNvbnN0IHBhcmVudFJldHVyblR5cGUgPSB1c2VSb3ZpbmdUYWJJbmRleDxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+LCBFeHRyYUZsYWdLZXlzPih7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9LCByb3ZpbmdUYWJJbmRleDogeyBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4IH0gfSA9IHBhcmVudFJldHVyblR5cGU7XG5cbiAgICBjb25zdCBuYXZpZ2F0ZVRvSW5kZXggPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyIHwgbnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoaSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0cnlOYXZpZ2F0ZVRvSW5kZXgoe1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgICAgIHRhcmdldDogaSxcbiAgICAgICAgICAgICAgICBzZWFyY2hEaXJlY3Rpb246IDEsXG4gICAgICAgICAgICAgICAgaW5kZXhNYW5nbGVyOiBpbmRleE1hbmdsZXIgPz8gaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgaW5kZXhEZW1hbmdsZXI6IGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaSA9PSBudWxsID8gbnVsbCA6IG5leHRJbmRleCwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG51bGwsIGZyb21Vc2VySW50ZXJhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgICAgIGludmFsaWRUeXBlYWhlYWRcbiAgICAgICAgfVxuICAgIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7XG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIGdldEluZGV4OiBnZXRUYWJiYWJsZUluZGV4LFxuICAgICAgICAgICAgc2V0SW5kZXg6IHVzZUNhbGxiYWNrKChpbmRleDogKG51bWJlciB8IG51bGwpIHwgKChwcmV2OiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICAuLi50eXBlYWhlYWROYXZpZ2F0aW9uXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCB7IHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyB9ID0gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldjogdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlOYXZpZ2F0ZVRvSW5kZXgoeyBjaGlsZHJlbiwgZGVmYXVsdDogYyA/PyAwLCB0YXJnZXQ6IGluZGV4RGVtYW5nbGVyIShpbmRleE1hbmdsZXIhKChjID8/IDApKSAtIDEpLCBzZWFyY2hEaXJlY3Rpb246IC0xLCBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSwgaW5kZXhEZW1hbmdsZXI6IGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5IH0pXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSlcbiAgICAgICAgICAgIH0sIFtdKSxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0OiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU5hdmlnYXRlVG9JbmRleCh7IGNoaWxkcmVuLCBkZWZhdWx0OiBjID8/IDAsIHRhcmdldDogaW5kZXhEZW1hbmdsZXIhKGluZGV4TWFuZ2xlciEoYyA/PyAwKSArIDEpLCBzZWFyY2hEaXJlY3Rpb246IDEsIGluZGV4TWFuZ2xlcjogaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LCBpbmRleERlbWFuZ2xlcjogaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHkgfSk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSlcbiAgICAgICAgICAgIH0sIFtdKSxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdDogdXNlQ2FsbGJhY2soKCkgPT4geyBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXhEZW1hbmdsZXIhKDApLCB0cnVlKTsgfSwgW10pLFxuICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3Q6IHVzZUNhbGxiYWNrKCgpID0+IHsgbmF2aWdhdGVUb0luZGV4KGluZGV4RGVtYW5nbGVyIShjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSksIHRydWUpOyB9LCBbXSksXG4gICAgICAgICAgICAuLi5saW5lYXJOYXZpZ2F0aW9uXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiA9PiB7XG4gICAgICAgIHJldHVybiB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHModXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzKHByb3BzKSk7XG4gICAgfSwgW3VzZUxpbmVhck5hdmlnYXRpb25Qcm9wcywgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzXSk7XG5cblxuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPj4oKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW4gfSwgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LCBzdWJJbmZvIH0pID0+IHtcblxuICAgICAgICBjb25zdCBfdjogdm9pZCA9IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCh7IHRleHQsIGluZGV4IH0pO1xuICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUdldHRlcihpbmRleCk7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGdldFRhYmJhYmxlSW5kZXgoKSA9PSBnZXRJbmRleCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChpbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldEVsZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSA9IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuOiAhIWhpZGRlbiB9LFxuICAgICAgICAgICAgc3ViSW5mbzogeyB0ZXh0LCBzdWJJbmZvIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PiA9IGZ1bmN0aW9uICh7IC4uLnByb3BzIH0pIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxDaGlsZEVsZW1lbnQ+KHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcygoKHsgaW5lcnQ6IGhpZGRlbiB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pKSksIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldEVsZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFt1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIG5hdmlnYXRlVG9JbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcblxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvSW5kZXggfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHBhcmVudFJldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQgfVxuICAgICAgICAvKmxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleCB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGdldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXggfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9Ki9cbiAgICB9XG59XG5cblxuXG5cblxuXG4vKipcbiAqIEl0J3MgdmVyeSBjb21tb24gdG8gY29tYmluZSBhIHRhYmJhYmxlIGxpc3Qgb2YgdGhpbmdzIGFuZCBcInNlbGVjdGlvblwiIG9mIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKiBcbiAqIExpc3RzLCByYWRpbyBidXR0b25zLCB0YWJzLCBldGMuIGV0Yy5cbiAqIFxuICogVGhpcyBpcyBhIHNob3J0Y3V0IHRoYXQgY29tYmluZXMgdGhlIHR3byB3aXRoIHRoZSBjb3JyZWN0IHR5cGluZy5cbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oe1xuICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4LCBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGVkSW5kZXhDaGFuZ2UgfSxcbiAgICBsaXN0TmF2aWdhdGlvbixcbiAgICBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgcm92aW5nVGFiSW5kZXg6IHsgLi4ucm92aW5nVGFiSW5kZXggfSxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb24sXG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IHsgb25BbGxMb3N0Rm9jdXMsIG9uQW55R2FpbmVkRm9jdXMgfVxufTogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+IHtcbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSyB8IFwic2VsZWN0ZWRcIj4oe1xuICAgICAgICBsaXN0TmF2aWdhdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgaW5pdGlhbEluZGV4OiAoc2VsZWN0ZWRJbmRleCA/PyB1bmRlZmluZWQpLFxuICAgICAgICAgICAgLi4ucm92aW5nVGFiSW5kZXhcbiAgICAgICAgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkIH0gPSB1c2VDaGlsZHJlbkhhdmVGb2N1cyh7XG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7XG4gICAgICAgICAgICBvbkFsbExvc3RGb2N1czogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQWxsTG9zdEZvY3VzPy4oKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KHNlbGVjdGVkSW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgb25BbnlHYWluZWRGb2N1c1xuICAgICAgICB9LCBtYW5hZ2VkQ2hpbGRyZW46IHtcbiAgICAgICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCxcbiAgICAgICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBzdGFibGVPbkNoYW5nZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uU2VsZWN0ZWRJbmRleENoYW5nZSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIC4uLmxpc3RSZXN0XG4gICAgfSA9IHBhcmVudFJldHVyblR5cGU7XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9LCByb3ZpbmdUYWJJbmRleDogeyBzZXRUYWJiYWJsZUluZGV4IH0gfSA9IGxpc3RSZXN0O1xuXG4gICAgY29uc3Qge1xuICAgICAgICBjaGFuZ2VJbmRleDogY2hhbmdlU2VsZWN0ZWRJbmRleCxcbiAgICAgICAgZ2V0Q3VycmVudEluZGV4OiBnZXRTZWxlY3RlZEluZGV4LFxuICAgICAgICAvL3JlZXZhbHVhdGVDbG9zZXN0Rml0XG4gICAgfSA9IHVzZUNoaWxkcmVuRmxhZzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88Qz4+LCBLIHwgXCJzZWxlY3RlZFwiPih7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgaW5pdGlhbEluZGV4OiBzZWxlY3RlZEluZGV4LFxuICAgICAgICBrZXk6IFwic2VsZWN0ZWRcIixcbiAgICAgICAgY2xvc2VzdEZpdDogZmFsc2VcbiAgICB9KTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNoYW5nZVNlbGVjdGVkSW5kZXgoc2VsZWN0ZWRJbmRleCk7XG4gICAgfSwgW3NlbGVjdGVkSW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ6IHVzZUNhbGxiYWNrPFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLIHwgXCJzZWxlY3RlZFwiPj4oKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCByb3ZpbmdUYWJJbmRleDogcnRpLCBsaXN0TmF2aWdhdGlvbjogbHMsIGhhc0ZvY3VzOiB7IG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgLi4uaGFzRm9jdXMgfSwgc3ViSW5mbyB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbaXNTZWxlY3RlZCwgc2V0SXNTZWxlY3RlZCwgZ2V0SXNTZWxlY3RlZF0gPSB1c2VTdGF0ZShnZXRTZWxlY3RlZEluZGV4KCkgPT0gaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRSZWYgPSB1c2VSZWY8Q2hpbGRGbGFnT3BlcmF0aW9ucz4oeyBnZXQ6IGdldElzU2VsZWN0ZWQsIHNldDogc2V0SXNTZWxlY3RlZCwgaXNWYWxpZDogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4gIXJ0aS5oaWRkZW4pIH0pO1xuICAgICAgICAgICAgY29uc3QgeyB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGQoe1xuICAgICAgICAgICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZm9jdXNlZCwgcHJldik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Nb2RlID09ICdmb2N1cycgJiYgZm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWJsZU9uQ2hhbmdlKHsgdGFyZ2V0OiBnZXRFbGVtZW50KCksIGN1cnJlbnRUYXJnZXQ6IGdldEVsZW1lbnQoKSB9IGFzIEV2ZW50LCBnZXRJbmRleCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uaGFzRm9jdXMsXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4IH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9yZXQsXG4gICAgICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzXG4gICAgICAgICAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5mbGFnc1xuICAgICAgICAgICAgICAgICAgICB9IGFzIFBhcnRpYWw8UmVjb3JkPEsgfCBcInNlbGVjdGVkXCIgfCBcInRhYmJhYmxlXCIsIENoaWxkRmxhZ09wZXJhdGlvbnM+PlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aSxcbiAgICAgICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogbHMsXG4gICAgICAgICAgICAgICAgc3ViSW5mbyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VTdGFibGVHZXR0ZXIoaW5kZXgpO1xuXG4gICAgICAgICAgICBjb25zdCB1c2VQcmVzc1Byb3BzID0gdXNlUHJlc3M8Q2hpbGRFbGVtZW50PigoZSkgPT4geyBzdGFibGVPbkNoYW5nZShlLCBnZXRJbmRleCgpKTsgfSwge30pO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSA9PiB1c2VQcmVzc1Byb3BzKHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMocHJvcHMpKSksXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9yZXQsXG4gICAgICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkOiBpc1NlbGVjdGVkLCBnZXRTZWxlY3RlZDogZ2V0SXNTZWxlY3RlZCB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbc2VsZWN0aW9uTW9kZV0pLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiB1c2VDYWxsYmFjaygoLi4ucDogUGFyYW1ldGVyczx0eXBlb2YgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcz4pID0+IHsgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMoLi4ucCkgfSwgW10pLFxuICAgICAgICAuLi5saXN0UmVzdCxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7fVxuICAgIH1cbn1cblxuXG5cblxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgViwgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHNcbiAgICBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cyB8IFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIsIExuT21pdHMsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPixcbiAgICBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLLCBHLCBWPiB7XG59XG5cbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cz4gPSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBMc09taXRzLCBSdGlPbWl0cywgTWNPbWl0cywgQz47XG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyPikgPT4gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLPixcbiAgICBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSywgRz4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLLCBHPiB7XG4gICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblByb3BzOiAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuOiBWTm9kZTxhbnk+W107IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+XG4gICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb248UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgdHlwZWFoZWFkTmF2aWdhdGlvbiwgcmVhcnJhbmdlYWJsZUNoaWxkcmVuLCBzb3J0YWJsZUNoaWxkcmVuIH06IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPEMsIEssIEcsIFYsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEssIEc+IHtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcbiAgICAgICAgLi4uc29ydGFibGVDaGlsZHJlblJldHVyblR5cGVcbiAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50LCBDLCBLLCBHLCBWPih7XG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbixcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbixcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSB9ID0gc29ydGFibGVDaGlsZHJlblJldHVyblR5cGU7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCAuLi5saXN0TmF2aWdhdGlvbiB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXgsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHR5cGVhaGVhZE5hdmlnYXRpb24sXG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUHJvcHMgPSAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuOiBWTm9kZTxhbnk+W107IH0pID0+IHtcbiAgICAgICAgcmV0dXJuICh1c2VMaXN0TmF2aWdhdGlvblByb3BzKHVzZVNvcnRhYmxlUHJvcHMocHJvcHMpKSlcbiAgICB9XG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLPiA9IChwKSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHApXG4gICAgfVxuXG4gICAgcmV0dXJuICh7XG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICAuLi5saXN0TmF2UmV0dXJuVHlwZSxcbiAgICAgICAgLi4uc29ydGFibGVDaGlsZHJlblJldHVyblR5cGVcbiAgICAgICAgLyptYW5hZ2VkQ2hpbGRyZW46IGxpc3ROYXZSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IGxpc3ROYXZSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaXN0TmF2UmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogbGlzdE5hdlJldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IGxpc3ROYXZSZXR1cm5UeXBlLnR5cGVhaGVhZE5hdmlnYXRpb24sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW46IHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlLnNvcnRhYmxlQ2hpbGRyZW4sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogc29ydGFibGVDaGlsZHJlblJldHVyblR5cGUucmVhcnJhbmdlYWJsZUNoaWxkcmVuKi9cbiAgICB9KTtcblxufVxuXG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAoYXJnczogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxTU09taXRzIGV4dGVuZHMgU2luZ2xlU2VsZWN0aW9uT21pdHMsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxTU09taXRzLCBMc09taXRzIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiwgTG5PbWl0cywgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEssIEc+LCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSz4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kc1xuICAgIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIEMsIEssIEc+IHtcbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD5cbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgc2luZ2xlU2VsZWN0aW9uLCB0eXBlYWhlYWROYXZpZ2F0aW9uLCBjaGlsZHJlbkhhdmVGb2N1cyB9OiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSywgW10+IHtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcbiAgICAgICAgLi4uc29ydGFibGVSZXR1cm5UeXBlXG4gICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgQywgSywgW10sIG51bWJlcj4oe1xuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXg6IHVzZUNhbGxiYWNrKChyb3cpID0+IHJvdy5pbmRleCwgW10pIH0sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgICAgIGdldFZhbHVlOiB1c2VDYWxsYmFjaygocm93KSA9PiByb3cuaW5kZXgsIFtdKSxcbiAgICAgICAgICAgIGNvbXBhcmU6IHVzZUNhbGxiYWNrKChsaHMsIHJocykgPT4geyByZXR1cm4gbGhzIC0gcmhzOyB9LCBbXSksXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSB9ID0gc29ydGFibGVSZXR1cm5UeXBlO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzLFxuICAgICAgICAuLi5saXN0TmF2UmV0dXJuVHlwZVxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgLi4ubGlzdE5hdmlnYXRpb24gfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiByb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiBzaW5nbGVTZWxlY3Rpb24sXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiBjaGlsZHJlbkhhdmVGb2N1c1xuICAgIH0pO1xuXG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzID0gKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiB7XG4gICAgICAgIHJldHVybiAodXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyh1c2VTb3J0YWJsZVByb3BzKHByb3BzKSkpO1xuICAgIH1cbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQgPSAocDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4ge1xuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHtcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLFxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXG4gICAgICAgIC8vc29ydGFibGU6IHsgc29ydCwgc2h1ZmZsZSwgcmVhcnJhbmdlLCBkZW1hbmdsZU1hcCwgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgbWFuZ2xlTWFwIH0sXG4gICAgICAgIC4uLnNvcnRhYmxlUmV0dXJuVHlwZSxcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGVcbiAgICB9KTtcblxufVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBUcnlOYXZpZ2F0ZVRvSW5kZXhQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBjaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPEM+PiwgSz47XG4gICAgZGVmYXVsdDogbnVtYmVyO1xuICAgIHRhcmdldDogbnVtYmVyO1xuICAgIHNlYXJjaERpcmVjdGlvbjogMSB8IC0xO1xuICAgIGluZGV4TWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xuICAgIGluZGV4RGVtYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyeU5hdmlnYXRlVG9JbmRleDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGNoaWxkcmVuLCBzZWFyY2hEaXJlY3Rpb24sIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIHRhcmdldCB9OiBUcnlOYXZpZ2F0ZVRvSW5kZXhQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSz4pIHtcbiAgICBjb25zdCB1cHBlciA9IGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpO1xuICAgIGNvbnN0IGxvd2VyID0gMDtcblxuICAgIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgIHdoaWxlICgodGFyZ2V0ID49IGxvd2VyICYmIChjaGlsZHJlbi5nZXRBdCh0YXJnZXQpID09IG51bGwpIHx8ICEhY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KT8uc3ViSW5mby5oaWRkZW4pKVxuICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXhEZW1hbmdsZXIoaW5kZXhNYW5nbGVyKHRhcmdldCkgLSAxKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0IDwgbG93ZXIgPyBpbmRleERlbWFuZ2xlcihsb3dlcikgOiB0YXJnZXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gMSkge1xuICAgICAgICB3aGlsZSAoKHRhcmdldCA8PSB1cHBlciAmJiBjaGlsZHJlbi5nZXRBdCh0YXJnZXQpID09IG51bGwpIHx8ICEhY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KT8uc3ViSW5mby5oaWRkZW4pXG4gICAgICAgICAgICB0YXJnZXQgPSBpbmRleERlbWFuZ2xlcihpbmRleE1hbmdsZXIodGFyZ2V0KSArIDEpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQgPiB1cHBlciA/IGluZGV4RGVtYW5nbGVyKHVwcGVyKSA6IHRhcmdldDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBsb3dlcjtcbiAgICB9XG59XG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkT21pdHMsIE1hbmFnZWRDaGlsZHJlbk9taXRzIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IExpbmVhck5hdmlnYXRpb25PbWl0cywgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMgfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XG5pbXBvcnQgeyB1c2VIYXNGb2N1cywgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWhhcy1mb2N1c1wiO1xuaW1wb3J0IHsgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgdXNlTGlzdE5hdmlnYXRpb24sIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcblxuLyoqXG4gKiBHcmlkcyBhcmUgaW1wbGVtZW50ZWQgdXNpbmcgdHdvIHNldHMgb2YgbGlzdCBuYXZpZ2F0aW9uLlxuICogXG4gKiBUaGlzIHJlc3VsdHMgaW4gYSBsb3Qgb2YgdGhpbmdzIHdpdGggdmVyeSBzaW1pbGFyIG5hbWVzIGFuZCBqdXN0IGNvbmZ1c2lvbiBhbGwgYXJvdW5kLiBQbGVhc2UgdXNlIGNhdXRpb24uXG4gKi9cblxuLy8gUGFyYW1ldGVycyAocGFyZW50LCByb3csIGNlbGwpXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cyB8IFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIsIExuT21pdHMgfCBcIm5hdmlnYXRpb25EaXJlY3Rpb25cIiwgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxcbiAgICBDUixcbiAgICBLUiBleHRlbmRzIHN0cmluZyxcbiAgICBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsXG4gICAgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cyxcbiAgICBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLFxuICAgIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsXG4gICAgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzLFxuXG4gICAgTHNDaGlsZE9taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLFxuICAgIFJ0aUNoaWxkT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsXG4gICAgTWNDaGlsZE9taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsXG5cbiAgICBTdWJiZXN0SW5mb1xuICAgID4ge1xuICAgIGFzUGFyZW50Um93T2ZDZWxsczogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMsIExuT21pdHMgfCBcIm5hdmlnYXRpb25EaXJlY3Rpb25cIiwgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+O1xuICAgIGFzQ2hpbGRSb3dPZlNlY3Rpb246IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENSLCBLUiwgTHNDaGlsZE9taXRzLCBSdGlDaGlsZE9taXRzLCBNY0NoaWxkT21pdHMsIFN1YmJlc3RJbmZvPlxuXG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmcsIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNDaGlsZE9taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q0MsIEtDLCBMc0NoaWxkT21pdHMsIFJ0aUNoaWxkT21pdHMsIE1jQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IHtcbiAgICBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPENlbGxFbGVtZW50Pjtcbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4ge1xuICAgIGdyaWROYXZpZ2F0aW9uOiB7XG4gICAgICAgIGdldEN1cnJlbnRDb2x1bW4oKTogbnVtYmVyIHwgbnVsbDtcbiAgICAgICAgY3VycmVudENvbHVtbjogbnVtYmVyIHwgbnVsbDtcbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDUiwgQ0MsIEtSIGV4dGVuZHMgc3RyaW5nLCBLQyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENSLCBLUj4ge1xuICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93OiBVc2VHcmlkTmF2aWdhdGlvblJvdzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgQ1IsIENDLCBLUiwgS0M+O1xuICAgIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JSb3dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JSb3dFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvdyBleHRlbmRzIEVsZW1lbnQsIENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBhc0NoaWxkUm93OiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Um93PjtcbiAgICBhc1BhcmVudE9mQ2VsbHM6IFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2VsbCwgQ0MsIEtDPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93IGV4dGVuZHMgRWxlbWVudCwgQ2VsbCBleHRlbmRzIEVsZW1lbnQsIENDLCBLQyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvdywgQ2VsbCwgQ0MsIEtDPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsOiBVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbCwgQ0MsIEtDPjtcbiAgICB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvdz4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvdz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm88Q2VsbCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENlbGw+IHtcbiAgICBncmlkTmF2aWdhdGlvbjoge1xuICAgICAgICAvL3Jvd0lzVGFiYmFibGU6IGJvb2xlYW47XG4gICAgICAgIC8vZ2V0Um93SXNUYWJiYWJsZSgpOiBib29sZWFuO1xuICAgICAgICBnZXRDdXJyZW50Q29sdW1uKCk6IG51bWJlciB8IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm88Q2VsbD4ge1xuICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGw+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsPjtcbn1cblxuXG5leHBvcnQgdHlwZSBVc2VHcmlkTmF2aWdhdGlvblJvdzxSb3cgZXh0ZW5kcyBFbGVtZW50LCBDZWxsIGV4dGVuZHMgRWxlbWVudCwgQ1IsIENDLCBLUiBleHRlbmRzIHN0cmluZywgS0MgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxDUiwgS1IsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQ1I+KSA9PiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93LCBDZWxsLCBDQywgS0M+O1xuZXhwb3J0IHR5cGUgVXNlR3JpZE5hdmlnYXRpb25DZWxsPENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmc+ID0gKHA6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbCwgQ0MsIEtDLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDQz4pID0+IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbD47XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uPFxuICAgIFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxuICAgIFJvd1N1YkluZm8sXG4gICAgQ2VsbFN1YkluZm8sXG4gICAgUm93RXh0cmFGbGFncyBleHRlbmRzIHN0cmluZyxcbiAgICBDZWxsRXh0cmFGbGFncyBleHRlbmRzIHN0cmluZ1xuPih7XG4gICAgbWFuYWdlZENoaWxkcmVuOiBtYyxcbiAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxuICAgIGxpc3ROYXZpZ2F0aW9uOiBscyxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsbixcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0blxufTogVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUm93U3ViSW5mbywgQ2VsbFN1YkluZm8sIFJvd0V4dHJhRmxhZ3MsIENlbGxFeHRyYUZsYWdzPiB7XG4gICAgY29uc3QgW2N1cnJlbnRDb2x1bW4sIHNldEN1cnJlbnRDb2x1bW4sIGdldEN1cnJlbnRDb2x1bW5dID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4ocnRpLmluaXRpYWxJbmRleCA/PyAwKTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogdXNlTGlzdE5hdmlnYXRpb25DaGlsZEFzR3JpZFJvdyxcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wczogdXNlTGlzdE5hdmlnYXRpb25Qcm9wc0FzR3JpZFBhcmVudCxcbiAgICAgICAgLi4ucGFyZW50THNSZXR1cm5UeXBlXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgUm93U3ViSW5mbywgUm93RXh0cmFGbGFncz4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1jLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogbHMsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgbmF2aWdhdGlvbkRpcmVjdGlvbjogXCJibG9ja1wiLCAuLi5sbiB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0bixcbiAgICB9KTtcblxuXG4gICAgY29uc3QgdXNlR3JpZE5hdmlnYXRpb25Sb3cgPSB1c2VDYWxsYmFjazxVc2VHcmlkTmF2aWdhdGlvblJvdzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUm93U3ViSW5mbywgQ2VsbFN1YkluZm8sIFJvd0V4dHJhRmxhZ3MsIENlbGxFeHRyYUZsYWdzPj4oKHsgYXNDaGlsZFJvd09mU2VjdGlvbjogYXNDaGlsZCwgYXNQYXJlbnRSb3dPZkNlbGxzOiBhc1BhcmVudCB9KSA9PiB7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoZSBmb2N1c1NlbGYgdGhhdCByb3ZpbmdUYWJJbmRleCBkb2VzLlxuICAgICAgICAvLyBJbnN0ZWFkIG9mIGZvY3VzaW5nIHRoZSBlbnRpcmUgcm93LCB3ZSBhc2sgdGhlIGNlbGwgdGhhdCBjb3JyZXNwb25kc1xuICAgICAgICAvLyB0byBvdXIgY3VycmVudCBjb2x1bW4gdG8gZm9jdXMgaXRzZWxmLlxuICAgICAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGdldEN1cnJlbnRDb2x1bW4oKTtcbiAgICAgICAgICAgIGlmIChhc0NoaWxkLnJvdmluZ1RhYkluZGV4LmZvY3VzU2VsZikge1xuICAgICAgICAgICAgICAgIGFzQ2hpbGQucm92aW5nVGFiSW5kZXguZm9jdXNTZWxmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoYzIgPz8gMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJvd0xzQ2hpbGRSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZEFzR3JpZFJvdyh7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IGFzQ2hpbGQubWFuYWdlZENoaWxkLFxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4uYXNDaGlsZC5saXN0TmF2aWdhdGlvbiB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgLi4uYXNDaGlsZC5yb3ZpbmdUYWJJbmRleCwgZm9jdXNTZWxmIH0sXG4gICAgICAgICAgICBzdWJJbmZvOiBhc0NoaWxkLnN1YkluZm8sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHJvdmluZ1RhYkluZGV4OiB7IHRhYmJhYmxlIH0sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gcm93THNDaGlsZFJldHVyblR5cGU7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRhYmJhYmxlKSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3RhYmJhYmxlXSk7XG5cbiAgICAgICAgY29uc3Qgcm93THNSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb248Q2VsbEVsZW1lbnQsIENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+KHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyAuLi5hc1BhcmVudC5tYW5hZ2VkQ2hpbGRyZW4gfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IC4uLmFzUGFyZW50LnJvdmluZ1RhYkluZGV4IH0sXG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNQYXJlbnQubGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcImlubGluZVwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgLi4uYXNQYXJlbnQudHlwZWFoZWFkTmF2aWdhdGlvbiwgbm9UeXBlYWhlYWQ6IHRydWUgfSxcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmFzUGFyZW50Lmxpc3ROYXZpZ2F0aW9uIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleDogeyBzZXRUYWJiYWJsZUluZGV4IH0sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uMiwgdXNlTGlzdE5hdmlnYXRpb25Qcm9wczogdXNlR3JpZE5hdmlnYXRpb25Db2x1bW5Qcm9wcywgbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4IH0gfSA9IHJvd0xzUmV0dXJuVHlwZTtcblxuICAgICAgICAvL2NvbnN0IHJvd0hpZGRlbiA9ICEhYXNDaGlsZC5yb3ZpbmdUYWJJbmRleC5oaWRkZW47XG5cbiAgICAgICAgY29uc3QgdXNlR3JpZE5hdmlnYXRpb25DZWxsID0gdXNlQ2FsbGJhY2s8VXNlR3JpZE5hdmlnYXRpb25DZWxsPENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+PigoeyBzdWJJbmZvLCBoYXNGb2N1czogeyBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCAuLi5oYXNGb2N1cyB9LCBtYW5hZ2VkQ2hpbGQsIGxpc3ROYXZpZ2F0aW9uOiBscywgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGY6IGJzLCBmb2N1c1NlbGY6IGZzLCAuLi5ydGkgfSB9KSA9PiB7XG4gICAgICAgICAgICAvL3J0aS5oaWRkZW4gfHwgcm93SGlkZGVuO1xuXG4gICAgICAgICAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudENvbHVtbihtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobWFuYWdlZENoaWxkLmluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZzKVxuICAgICAgICAgICAgICAgICAgICBmcygpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgKHJ0aV9jZWxsX3JldC5nZXRFbGVtZW50KCkgYXMgRWxlbWVudCAmIFBhcnRpYWw8SFRNTEVsZW1lbnQ+KT8uZm9jdXM/LigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBibHVyU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYnMpXG4gICAgICAgICAgICAgICAgICAgIGJzKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAocnRpX2NlbGxfcmV0LmdldEVsZW1lbnQoKSBhcyBFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pPy5ibHVyPy4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX2NlbGxfcmV0XG4gICAgICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25Db2x1bW4yKHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IG1hbmFnZWRDaGlsZCxcbiAgICAgICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGJsdXJTZWxmLCBmb2N1c1NlbGYsIC4uLnJ0aSB9LFxuICAgICAgICAgICAgICAgIHN1YkluZm9cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPENlbGxFbGVtZW50Pih7XG4gICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZD8uKGZvY3VzZWQsIHByZXYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudENvbHVtbihtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChtYW5hZ2VkQ2hpbGQuaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmhhc0ZvY3VzXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBjb25zdCByZXQ6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbEVsZW1lbnQ+ID0ge1xuICAgICAgICAgICAgICAgIGdyaWROYXZpZ2F0aW9uOiB7IGdldEN1cnJlbnRDb2x1bW4gfSxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX2NlbGxfcmV0LFxuICAgICAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzOiBmdW5jdGlvbiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGxFbGVtZW50Pj4ocHJvcHM6IFApIHsgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VHcmlkTmF2aWdhdGlvbkNvbHVtblByb3BzKHVzZUhhc0ZvY3VzUHJvcHMocHJvcHMpKSk7IH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcblxuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgY29uc3QgcmV0OiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIENlbGxTdWJJbmZvLCBDZWxsRXh0cmFGbGFncz4gPSB7XG4gICAgICAgICAgICBhc1BhcmVudE9mQ2VsbHM6IHtcbiAgICAgICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiByb3dMc1JldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogcm93THNSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbjogcm93THNSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcm93THNSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxuICAgICAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHJvd0xzUmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXNDaGlsZFJvdzogcm93THNDaGlsZFJldHVyblR5cGUsXG5cbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCxcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHM6IGZ1bmN0aW9uIDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4+KHByb3BzOiBQKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHByb3BzKTtcbiAgICAgICAgICAgICAgICByZXQudGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBncmlkTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgZ2V0Q3VycmVudENvbHVtbixcbiAgICAgICAgICAgIGN1cnJlbnRDb2x1bW5cbiAgICAgICAgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogcGFyZW50THNSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBwYXJlbnRMc1JldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBwYXJlbnRMc1JldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHBhcmVudExzUmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHBhcmVudExzUmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93LFxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblByb3BzOiB1c2VMaXN0TmF2aWdhdGlvblByb3BzQXNHcmlkUGFyZW50LFxuICAgIH1cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZVJhbmRvbUlkIH0gZnJvbSBcIi4vdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0XCI7XG5pbXBvcnQgeyB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5leHBvcnQgeyBnZW5lcmF0ZVJhbmRvbUlkIH1cblxuZXhwb3J0IHR5cGUgVXNlUmFuZG9tSWRQcm9wc1BhcmFtZXRlcnMgPSBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8XCJpZFwiPjtcbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkUHJvcHNSZXR1cm5UeXBlPFAgZXh0ZW5kcyBVc2VSYW5kb21JZFByb3BzUGFyYW1ldGVycz4gPSBVc2VSZWZlcmVuY2VkSWRQcm9wc1JldHVyblR5cGU8UCwgXCJpZFwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFwicmVmZXJlbmNlclwiIHwgXCJzb3VyY2VcIiwgbmV2ZXI+IHtcbiAgICByYW5kb21JZDoge1xuICAgICAgICBwcmVmaXg/OiBzdHJpbmc7XG4gICAgfVxufVxuXG5cbmV4cG9ydCB0eXBlIFVzZVJlZmVyZW5jZWRJZFByb3BzUGFyYW1ldGVyczxLIGV4dGVuZHMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pj4gPSBQYXJ0aWFsPFJlY29yZDxLLCBhbnk+PjsvLzxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7IH07XG5cblxuZXhwb3J0IHR5cGUgVXNlUmVmZXJlbmNlZElkUHJvcHNSZXR1cm5UeXBlPFAgZXh0ZW5kcyBVc2VSZWZlcmVuY2VkSWRQcm9wc1BhcmFtZXRlcnM8YW55PiwgSyBleHRlbmRzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4+ID0gT21pdDxQLCBLPiAmIFJlY29yZDxLLCBzdHJpbmc+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkUmV0dXJuVHlwZUluZm8gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxcInJlZmVyZW5jZXJcIiB8IFwic291cmNlXCIsIHt9LCBuZXZlcj4ge1xuICAgIHJhbmRvbUlkOiB7XG4gICAgICAgIHVzZWRJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRVc2VkSWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYW5kb21JZFJldHVyblR5cGVXaXRoSG9va3M8UyBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUmFuZG9tSWRSZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTPjtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IFVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ7XG59XG5cbmludGVyZmFjZSBSYW5kb21JZENoaWxkSW5mb0Jhc2Uge1xuICAgIHNldFVzZWRJZChpZDogc3RyaW5nKTogdm9pZDtcbiAgICAvL3NlbmRTb3VyY2VJZFRvUmVmZXJlbmNlckVsZW1lbnQoc291cmNlSWQ6IHN0cmluZyk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIFVzZVJhbmRvbUlkU291cmNlRWxlbWVudDxTIGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiBVc2VSYW5kb21JZFNvdXJjZUVsZW1lbnRSZXR1cm5UeXBlPFM+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJhbmRvbUlkU291cmNlRWxlbWVudFJldHVyblR5cGU8UyBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICB1c2VkSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldFVzZWRJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFM+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxTPjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCA9IDxSIGV4dGVuZHMgRWxlbWVudD4oaWRQcm9wTmFtZToga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+KSA9PiBVc2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UmV0dXJuVHlwZTxSPjtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFJldHVyblR5cGU8UiBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICB1c2VkSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldFVzZWRJZCgpOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxSPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uj47XG59XG5cblxuXG4vKipcbiAqIFJldHVybnMgYSBob29rIHRoYXQgbW9kaWZpZXMgYSBzZXQgb2YgcHJvcHMgdG8gcHJvdmlkZSBhIHJhbmRvbWx5LWdlbmVyYXRlZCBJRCBpZiBvbmUgd2FzIG5vdCBwcm92aWRlZC5cbiAqIFxuICogSWYgeW91J2QgbGlrZSB0byB1c2UgdGhlIElEIGluIGEgcHJvcGVydHkgdGhhdCdzICpub3QqIG5hbWVkIGBpZGAgKGxpa2UgYGZvcmAgb3IgYGFyaWEtbGFiZWxsZWRieWAgb3Igd2hhdG5vdCksIGB1c2VSZWZlcmVuY2VkSWRQcm9wc2AgaXMgYWxzbyBwcm92aWRlZC5cbiAqIFxuICogQW5kIHRoZSByYW5kb21seS1nZW5lcmF0ZWQgaWQgaXRzZWxmIGlzIGFsc28gcHJvdmlkZWQgaW4gY2FzZSB5b3Ugd2FudCB0byBoYW5kbGUgdGhlIGxvZ2ljIHlvdXJzZWxmIHdpdGhvdXQgYHVzZU1lcmdlZFByb3BzYC5cbiAqIFxuICogVW5saWtlIG1vc3Qgb3RoZXIgYHVzZSpQcm9wc2AgaG9va3MsIHRoZXNlIGFyZSBtb3N0bHkgc3RhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmFuZG9tSWQ8UyBleHRlbmRzIEVsZW1lbnQ+KHsgcmFuZG9tSWQ6IHsgcHJlZml4IH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH06IFVzZVJhbmRvbUlkUGFyYW1ldGVycyk6IFVzZVJhbmRvbUlkUmV0dXJuVHlwZVdpdGhIb29rczxTPiB7XG4gICAgY29uc3QgW2JhY2t1cFJhbmRvbUlkLCAsIGdldEJhY2t1cFJhbmRvbUlkXSA9IHVzZVN0YXRlPHN0cmluZz4oKCkgPT4gZ2VuZXJhdGVSYW5kb21JZChwcmVmaXgpKTtcbiAgICBjb25zdCBbdXNlZElkLCBzZXRVc2VkSWQsIGdldFVzZWRJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCB1bmRlZmluZWQ+KCgpID0+IGdldEJhY2t1cFJhbmRvbUlkKCkpO1xuICAgIGNvbnN0IG1pc21hdGNoRXJyb3JSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVJhbmRvbUlkXCIsIHByZWZpeCk7XG5cbiAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZCwgLi4ubWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSB9ID0gdXNlTWFuYWdlZENoaWxkcmVuPFwicmVmZXJlbmNlclwiIHwgXCJzb3VyY2VcIiwgUmFuZG9tSWRDaGlsZEluZm9CYXNlLCBuZXZlcj4oeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9KTtcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9IH0gPSBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlO1xuXG4gICAgY29uc3QgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50ID0gdXNlQ2FsbGJhY2s8VXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50PFM+PigoKSA9PiB7XG4gICAgICAgIGNvbnN0IFt1c2VkSWRMb2NhbCwgc2V0VXNlZElkTG9jYWwsIGdldFVzZWRJZExvY2FsXSA9IHVzZVN0YXRlKGdldFVzZWRJZCgpKTtcbiAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8Uz4oKTtcbiAgICAgICAgLy8gRXZlcnkgdGltZSB0aGUgc291cmNlIGVsZW1lbnQgcmVuZGVycywgaW5zcGVjdCB0aGUgSUQgaXQgYWN0dWFsbHkgdXNlZFxuICAgICAgICAvLyAod2hldGhlciBpdCB3YXMgb3VycyBvciBub3QgaXNuJ3QgdXAgdG8gdXMsIGl0J3MgdXAgdG8gdGhlIGNvbXBvbmVudClcbiAgICAgICAgLy8gc28gdGhpcyBpcyBob3cgd2Ugbm90aWZ5IHRoZSByZWZlcmVuY2VyIGNvbXBvbmVudCBvZiBjaGFuZ2VzXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KFwicmVmZXJlbmNlclwiKSEuc3ViSW5mby5zZXRVc2VkSWQoZWxlbWVudC5pZCk7XG4gICAgICAgICAgICAgICAgc2V0VXNlZElkKGVsZW1lbnQuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBfOiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4OiBcInNvdXJjZVwiLCBzdWJJbmZvOiB7IHNldFVzZWRJZDogc2V0VXNlZElkTG9jYWwgfSB9IH0pO1xuXG4gICAgICAgIGNvbnN0IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzID0gdXNlQ2FsbGJhY2s8VXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UmV0dXJuVHlwZTxTPltcInVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzXCJdPihmdW5jdGlvbiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Uz4pIHtcbiAgICAgICAgICAgIHAuaWQgfHw9IGJhY2t1cFJhbmRvbUlkO1xuICAgICAgICAgICAgcmV0dXJuIHVzZVJlZkVsZW1lbnRQcm9wcyhwKTtcbiAgICAgICAgfSwgW10pXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZWRJZDogdXNlZElkTG9jYWwsXG4gICAgICAgICAgICBnZXRVc2VkSWQ6IGdldFVzZWRJZExvY2FsLFxuICAgICAgICAgICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHNcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50ID0gdXNlQ2FsbGJhY2s8VXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudD4oPFIgZXh0ZW5kcyBFbGVtZW50PihpZFByb3BOYW1lOiBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxSPikgPT4ge1xuICAgICAgICBjb25zdCBbdXNlZElkTG9jYWwsIHNldFVzZWRJZExvY2FsLCBnZXRVc2VkSWRMb2NhbF0gPSB1c2VTdGF0ZShnZXRVc2VkSWQoKSk7XG4gICAgICAgIC8vIFdoYXRldmVyIElEIHdhcyBtb3N0IHJlY2VudGx5IHVzZWQgYnkgdGhlIGFjdHVhbCBcImlkXCIgcHJvcCBvZiB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgdXNlRW5zdXJlU3RhYmlsaXR5KGlkUHJvcE5hbWUpO1xuXG4gICAgICAgIGNvbnN0IF92OiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4OiBcInJlZmVyZW5jZXJcIiwgc3ViSW5mbzogeyBzZXRVc2VkSWQ6IHNldFVzZWRJZExvY2FsIH0gfSB9KTtcblxuICAgICAgICBjb25zdCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgPSB1c2VDYWxsYmFjazxVc2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UmV0dXJuVHlwZTxSPltcInVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wc1wiXT4oZnVuY3Rpb24gPFIgZXh0ZW5kcyBFbGVtZW50Pih7IFtpZFByb3BOYW1lXTogZ2l2ZW5JZCwgLi4ucCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxSPikge1xuICAgICAgICAgICAgaWYgKGdpdmVuSWQgJiYgdXNlZElkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdpdmVuSWQgIT0gdXNlZElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWlzbWF0Y2hFcnJvclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNtYXRjaEVycm9yUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTXVsdGlwbGUgbWlzLW1hdGNoZWQgSURzIHdlcmUgcHJvdmlkZWQgZm9yIHRoZSAke2lkUHJvcE5hbWV9IHByb3A6IHRoZSBjaGlsZCBleHBsaWNpdGx5IHNwZWNpZmllZCAke2dpdmVuSWR9IGluIGl0cyAgJHtpZFByb3BOYW1lfSBwcm9wLCBidXQgdGhlIHBhcmVudCB0b2xkIHRoaXMgY2hpbGQgdG8gdXNlICR7dXNlZElkfSAodGhlIHBhcmVudCdzIElEKS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxSPihwLCB7IFtpZFByb3BOYW1lXTogdXNlZElkIH0pO1xuICAgICAgICB9LCBbdXNlZElkXSk7XG5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlZElkOiB1c2VkSWRMb2NhbCxcbiAgICAgICAgICAgIGdldFVzZWRJZDogZ2V0VXNlZElkTG9jYWwsXG4gICAgICAgICAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHNcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHJhbmRvbUlkOiB7XG4gICAgICAgICAgICB1c2VkSWQsXG4gICAgICAgICAgICBnZXRVc2VkSWRcbiAgICAgICAgfSxcbiAgICAgICAgLi4ubWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZSxcbiAgICAgICAgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50LFxuICAgICAgICB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcywgdXNlUHJlc3MgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIEVuaGFuY2VkRXZlbnQsIGVuaGFuY2VFdmVudCwgVGFnU2Vuc2l0aXZlUHJvcHMgfSBmcm9tIFwiLi9wcm9wc1wiO1xuXG5cbmV4cG9ydCB0eXBlIEJ1dHRvblByZXNzRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IEVuaGFuY2VkRXZlbnQ8RSwgRXZlbnQgfCBFdmVudCwgeyBwcmVzc2VkOiBib29sZWFuIHwgbnVsbCB9PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VCdXR0b25QYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gZXh0ZW5kcyBUYWdTZW5zaXRpdmVQcm9wczxFPiB7XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuIHwgXCJzb2Z0XCIgfCBcImhhcmRcIjtcbiAgICBwcmVzc2VkPzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgb25QcmVzcz8oZXZlbnQ6IEJ1dHRvblByZXNzRXZlbnQ8RT4pOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUJ1dHRvblJldHVyblR5cGU8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VCdXR0b25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG59XG5cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQnV0dG9uPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyB0YWcsIHByZXNzZWQsIG9uUHJlc3MsIGRpc2FibGVkIH06IFVzZUJ1dHRvblBhcmFtZXRlcnM8RT4pOiBVc2VCdXR0b25SZXR1cm5UeXBlPEU+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZUJ1dHRvblwiKTtcblxuICAgIGZ1bmN0aW9uIHVzZUJ1dHRvblByb3BzKHsgXCJhcmlhLXByZXNzZWRcIjogYXJpYVByZXNzZWQsIHRhYkluZGV4LCByb2xlLCAuLi5wIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4ge1xuXG4gICAgICAgIGNvbnN0IHVzZVByZXNzUHJvcHMgPSB1c2VQcmVzczxFPigoZSkgPT4gKGRpc2FibGVkID8gbnVsbCA6IG9uUHJlc3MpPy4oZW5oYW5jZUV2ZW50KGUsIHsgcHJlc3NlZDogcHJlc3NlZCA9PSBudWxsID8gbnVsbCA6ICFwcmVzc2VkIH0pKSwgdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB1c2VQcmVzc1Byb3BzKHApO1xuXG4gICAgICAgIGNvbnN0IGJhc2VQcm9wcyA9IHsgcm9sZSwgdGFiSW5kZXgsIFwiYXJpYS1wcmVzc2VkXCI6IGFyaWFQcmVzc2VkID8/IChwcmVzc2VkID09PSB0cnVlID8gXCJ0cnVlXCIgOiBwcmVzc2VkID09PSBmYWxzZSA/IFwiZmFsc2VcIiA6IHVuZGVmaW5lZCkgfTtcbiAgICAgICAgY29uc3QgYnV0dG9uUHJvcHMgPSB7IC4uLmJhc2VQcm9wcywgZGlzYWJsZWQ6IChkaXNhYmxlZCAmJiBkaXNhYmxlZCAhPSBcInNvZnRcIikgPyB0cnVlIDogZmFsc2UsIFwiYXJpYS1kaXNhYmxlZFwiOiAoZGlzYWJsZWQgPT09ICdzb2Z0JyA/ICd0cnVlJyA6IHVuZGVmaW5lZCkgfTtcbiAgICAgICAgY29uc3QgZGl2UHJvcHMgPSB7IC4uLmJhc2VQcm9wcywgdGFiSW5kZXg6IHRhYkluZGV4ID8/IChkaXNhYmxlZCA9PT0gXCJoYXJkXCIgPyAtMSA6IDApLCByb2xlOiByb2xlID8/IFwiYnV0dG9uXCIsIFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH07XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgICBjYXNlIFwiYnV0dG9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KGJ1dHRvblByb3BzLCBwcm9wcyk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KGRpdlByb3BzLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VCdXR0b25Qcm9wc1xuICAgIH1cbn1cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgT25DaGlsZHJlbk1vdW50Q2hhbmdlLCByZXR1cm5UcnVlLCB1c2VDaGlsZHJlbkZsYWcsIHVzZUhhc0ZvY3VzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMsIHVzZUxpbmVhck5hdmlnYXRpb24sIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvLCB1c2VSYW5kb21JZCwgdXNlUmVmRWxlbWVudCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YWJsZUdldHRlciwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBFbGVtZW50VG9UYWcgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlQnV0dG9uLCBVc2VCdXR0b25QYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWJ1dHRvblwiO1xuXG5leHBvcnQgdHlwZSBVc2VBY2NvcmRpb248SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogVXNlQWNjb3JkaW9uUGFyYW1ldGVycykgPT4gVXNlQWNjb3JkaW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD47XG5leHBvcnQgdHlwZSBVc2VBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+KSA9PiBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWNjb3JkaW9uUGFyYW1ldGVycyBleHRlbmRzIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPFwibmF2aWdhdGVUb0ZpcnN0XCIgfCBcIm5hdmlnYXRlVG9MYXN0XCIgfCBcIm5hdmlnYXRlVG9OZXh0XCIgfCBcIm5hdmlnYXRlVG9QcmV2XCI+LCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPG51bWJlciwgbmV2ZXI+IHtcbiAgICBhY2NvcmRpb246IHsgaW5pdGlhbEluZGV4PzogbnVtYmVyIHwgbnVsbDsgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblJldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88bnVtYmVyLCBVc2VBY2NvcmRpb25TZWN0aW9uSW5mb0Jhc2UsIFwidGFiYmVkXCIgfCBcIm9wZW5cIj4ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgYWNjb3JkaW9uOiB7IGNoYW5nZUV4cGFuZGVkSW5kZXg6IChhcmc6IG51bWJlciB8ICgocHJldlN0YXRlOiBudW1iZXIgfCBudWxsKSA9PiBudW1iZXIgfCBudWxsKSB8IG51bGwpID0+IG51bWJlciB8IG51bGw7IH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQWNjb3JkaW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlQWNjb3JkaW9uU2VjdGlvbjogVXNlQWNjb3JkaW9uU2VjdGlvbjxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlIHtcbiAgICBzZXRPcGVuRnJvbVBhcmVudChvcGVuOiBib29sZWFuKTogdm9pZDtcbiAgICBnZXRPcGVuRnJvbVBhcmVudCgpOiBib29sZWFuIHwgbnVsbDtcbiAgICBmb2N1cygpOiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgbWFuYWdlZENoaWxkcmVuOiBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPG51bWJlciwgVXNlQWNjb3JkaW9uU2VjdGlvbkluZm9CYXNlLCBcInRhYmJlZFwiIHwgXCJvcGVuXCIsIFwic3ViSW5mb1wiIHwgXCJmbGFnc1wiPltcIm1hbmFnZWRDaGlsZFwiXTtcbiAgICBhY2NvcmRpb25TZWN0aW9uOiB7IG9wZW4/OiBib29sZWFuIHwgdW5kZWZpbmVkOyB0YWdCdXR0b246IEVsZW1lbnRUb1RhZzxIZWFkZXJFbGVtZW50PjsgfVxuICAgIGJ1dHRvbjogUGljazxVc2VCdXR0b25QYXJhbWV0ZXJzPEhlYWRlckVsZW1lbnQ+LCBcImRpc2FibGVkXCI+O1xuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8SGVhZGVyRWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICBhY2NvcmRpb25TZWN0aW9uOiB7XG4gICAgICAgIGV4cGFuZGVkOiBib29sZWFuO1xuICAgICAgICBmb2N1c2VkOiBib29sZWFuO1xuICAgICAgICBoZWFkZXJJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICBib2R5SWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgZ2V0SGVhZGVySWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICBnZXRCb2R5SWQoKTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUFjY29yZGlvblNlY3Rpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VBY2NvcmRpb25TZWN0aW9uSGVhZGVyUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+O1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50Pjtcbn1cblxuXG4vL2V4cG9ydCB0eXBlIFVzZUFjY29yZGlvblNlY3Rpb25IZWFkZXI8RSBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZUJ1dHRvblBhcmFtZXRlcnM8RT4pID0+IFVzZUFjY29yZGlvblNlY3Rpb25IZWFkZXJSZXR1cm5UeXBlPEU+O1xuLy9leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblNlY3Rpb25IZWFkZXJSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiB7IHVzZUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47IH1cbi8vZXhwb3J0IHR5cGUgVXNlQWNjb3JkaW9uU2VjdGlvbkJvZHk8RSBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4gVXNlQWNjb3JkaW9uU2VjdGlvbkJvZHlSZXR1cm5UeXBlPEU+O1xuLy9leHBvcnQgaW50ZXJmYWNlIFVzZUFjY29yZGlvblNlY3Rpb25Cb2R5UmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4geyB1c2VBY2NvcmRpb25TZWN0aW9uQm9keVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjsgfVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQWNjb3JkaW9uPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnQ+KHsgYWNjb3JkaW9uOiB7IGluaXRpYWxJbmRleCB9LCBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9OiBVc2VBY2NvcmRpb25QYXJhbWV0ZXJzKTogVXNlQWNjb3JkaW9uUmV0dXJuVHlwZVdpdGhIb29rczxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD4ge1xuICAgIGRlYnVnTG9nKFwidXNlQWNjb3JkaWFuXCIpO1xuICAgIGNvbnN0IFtfY3VycmVudEZvY3VzZWRJbmRleCwgc2V0Q3VycmVudEZvY3VzZWRJbmRleCwgZ2V0Q3VycmVudEZvY3VzZWRJbmRleF0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcblxuICAgIGNvbnN0IG1jUmV0dXJuVHlwZSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIFVzZUFjY29yZGlvblNlY3Rpb25JbmZvQmFzZSwgXCJ0YWJiZWRcIiB8IFwib3BlblwiPih7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjoge1xuICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPbkNoaWxkcmVuTW91bnRDaGFuZ2U8bnVtYmVyPj4oKG0sIHUpID0+IHsgb2NtYzIoKTsgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4obSwgdSk7IH0pLFxuICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgdXNlTWFuYWdlZENoaWxkLCBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSB9ID0gbWNSZXR1cm5UeXBlO1xuXG4gICAgY29uc3QgbmF2aWdhdGVUb0ZpcnN0ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBjaGFuZ2VUYWJiZWRJbmRleCgwKTsgfSwgW10pO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9MYXN0ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBjaGFuZ2VUYWJiZWRJbmRleChjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSk7IH0sIFtdKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvUHJldiA9IHVzZUNhbGxiYWNrKCgpID0+IHsgY2hhbmdlVGFiYmVkSW5kZXgoaSA9PiAoKGkgPz8gMCkgLSAxKSkgfSwgW10pO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9OZXh0ID0gdXNlQ2FsbGJhY2soKCkgPT4geyBjaGFuZ2VUYWJiZWRJbmRleChpID0+ICgoaSA/PyAwKSArIDEpKSB9LCBbXSk7XG4gICAgY29uc3QgbGluZWFyUmV0dXJuVHlwZSA9IHVzZUxpbmVhck5hdmlnYXRpb248SGVhZGVyRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICBuYXZpZ2F0ZVRvRmlyc3QsXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdCxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0LFxuICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYsXG4gICAgICAgICAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgICAgICAgICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbjogbmF2aWdhdGlvbkRpcmVjdGlvbiA/PyBcImJsb2NrXCJcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHMgfSA9IGxpbmVhclJldHVyblR5cGU7XG5cblxuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXg6IGNoYW5nZUV4cGFuZGVkSW5kZXgsIGdldEN1cnJlbnRJbmRleDogX2dldEN1cnJlbnRFeHBhbmRlZEluZGV4IH0gPSB1c2VDaGlsZHJlbkZsYWcoe1xuICAgICAgICBpbml0aWFsSW5kZXgsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBrZXk6IFwib3BlblwiLFxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleDogY2hhbmdlVGFiYmVkSW5kZXgsIGdldEN1cnJlbnRJbmRleDogX2dldFRhYmJlZEluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdDogb2NtYzIgfSA9IHVzZUNoaWxkcmVuRmxhZyh7XG4gICAgICAgIGluaXRpYWxJbmRleCxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGtleTogXCJ0YWJiZWRcIixcbiAgICAgICAgY2xvc2VzdEZpdDogdHJ1ZSxcbiAgICAgICAgb25JbmRleENoYW5nZTogdXNlQ2FsbGJhY2soKGk6IG51bWJlciB8IG51bGwpID0+IHtcbiAgICAgICAgICAgIGlmIChpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5nZXRBdChpKT8uc3ViSW5mby5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSlcbiAgICB9KVxuXG4gICAgY29uc3QgdXNlQWNjb3JkaW9uU2VjdGlvbjogVXNlQWNjb3JkaW9uU2VjdGlvbjxIZWFkZXJFbGVtZW50LCBCb2R5RWxlbWVudD4gPSB1c2VDYWxsYmFjazxVc2VBY2NvcmRpb25TZWN0aW9uPEhlYWRlckVsZW1lbnQsIEJvZHlFbGVtZW50Pj4oKHsgYnV0dG9uOiB7IGRpc2FibGVkIH0sIGFjY29yZGlvblNlY3Rpb246IHsgb3Blbjogb3BlbkZyb21Vc2VyLCB0YWdCdXR0b24gfSwgbWFuYWdlZENoaWxkcmVuOiB7IGluZGV4IH0sIGhhc0ZvY3VzOiB7IG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgLi4uaGFzRm9jdXMgfSB9KSA9PiB7XG5cbiAgICAgICAgZGVidWdMb2coXCJ1c2VBY2NvcmRpYW5TZWN0aW9uXCIpO1xuICAgICAgICBjb25zdCBbb3BlbkZyb21QYXJlbnQsIHNldE9wZW5Gcm9tUGFyZW50LCBnZXRPcGVuRnJvbVBhcmVudF0gPSB1c2VTdGF0ZTxib29sZWFuIHwgbnVsbD4obnVsbCk7XG5cblxuXG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VCb2R5QXNTb3VyY2VJZCwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlSGVhZGVyQXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogYm9keUlkLCBnZXRVc2VkSWQ6IGdldEJvZHlJZCB9IH0gPSB1c2VSYW5kb21JZDxCb2R5RWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS1hY2NvcmRpb24tc2VjdGlvbi1ib2R5LVwiIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlSGVhZGVyQXNTb3VyY2VJZCwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlQm9keUFzUmVmZXJlbmNlcklkLCByYW5kb21JZDogeyB1c2VkSWQ6IGhlYWRlcklkLCBnZXRVc2VkSWQ6IGdldEhlYWRlcklkIH0gfSA9IHVzZVJhbmRvbUlkPEhlYWRlckVsZW1lbnQ+KHsgcmFuZG9tSWQ6IHsgcHJlZml4OiBcImFyaWEtYWNjb3JkaW9uLXNlY3Rpb24taGVhZGVyLVwiIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VCb2R5QXNTb3VyY2VJZFByb3BzIH0gPSB1c2VCb2R5QXNTb3VyY2VJZCgpO1xuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlQm9keUFzUmVmZXJlbmNlcklkUHJvcHMgfSA9IHVzZUJvZHlBc1JlZmVyZW5jZXJJZDxCb2R5RWxlbWVudD4oXCJhcmlhLWxhYmVsbGVkYnlcIiBhcyBuZXZlcik7XG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZUhlYWRlckFzU291cmNlSWRQcm9wcyB9ID0gdXNlSGVhZGVyQXNTb3VyY2VJZCgpO1xuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wczogdXNlSGVhZGVyQXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlSGVhZGVyQXNSZWZlcmVuY2VySWQ8SGVhZGVyRWxlbWVudD4oXCJhcmlhLWNvbnRyb2xzXCIgYXMgbmV2ZXIpO1xuXG4gICAgICAgIGNvbnN0IG9wZW4gPSAoKG9wZW5Gcm9tVXNlciA/PyBvcGVuRnJvbVBhcmVudCkgPz8gZmFsc2UpO1xuICAgICAgICAvL2NvbnN0IGdldE9wZW4gPSB1c2VTdGFibGVHZXR0ZXIoISFvcGVuKTtcbiAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VTdGFibGVHZXR0ZXIoaW5kZXgpO1xuXG4gICAgICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0SGVhZGVyRWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VIZWFkZXJSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8SGVhZGVyRWxlbWVudD4oe30pO1xuICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQ6IGdldEJvZHlFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUJvZHlSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8Qm9keUVsZW1lbnQ+KHt9KTtcbiAgICAgICAgY29uc3QgZm9jdXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZ2V0Q3VycmVudEZvY3VzZWRJbmRleCgpICE9IG51bGwpXG4gICAgICAgICAgICAgICAgKGdldEhlYWRlckVsZW1lbnQoKSBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkKT8uZm9jdXMoKTtcbiAgICAgICAgfSwgW10pO1xuICAgICAgICBjb25zdCBvcGVuUmVmID0gdXNlUmVmKHtcbiAgICAgICAgICAgIGdldDogKCkgPT4gISFnZXRPcGVuRnJvbVBhcmVudCgpLFxuICAgICAgICAgICAgc2V0OiAob3BlbjogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgICAgIHNldE9wZW5Gcm9tUGFyZW50KG9wZW4pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keUVsZW1lbnQgPSBnZXRCb2R5RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50Rm9jdXNlZEluZGV4KGdldEluZGV4KCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGJvZHlFbGVtZW50LmZvY3VzKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzVmFsaWQ6IHJldHVyblRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRhYmJlZFJlZiA9IHVzZVJlZih7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IChnZXRDdXJyZW50Rm9jdXNlZEluZGV4KCkgPT0gZ2V0SW5kZXgoKSksXG4gICAgICAgICAgICBzZXQ6IChvcGVuOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW4pXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRGb2N1c2VkSW5kZXgoZ2V0SW5kZXgoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNWYWxpZDogcmV0dXJuVHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX186IHZvaWQgPSB1c2VNYW5hZ2VkQ2hpbGQoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW46IG9wZW5SZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgdGFiYmVkOiB0YWJiZWRSZWYuY3VycmVudFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3ViSW5mbzoge1xuICAgICAgICAgICAgICAgICAgICBmb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0T3BlbkZyb21QYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIHNldE9wZW5Gcm9tUGFyZW50XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBpbmZvOiB7IGluZGV4LCBzZXRPcGVuRnJvbVBhcmVudCwgZ2V0T3BlbkZyb21QYXJlbnQsIGZvY3VzLCBmbGFnczogeyBvcGVuOiBvcGVuUmVmLmN1cnJlbnQsIHRhYmJlZDogdGFiYmVkUmVmLmN1cnJlbnQgfSB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcyh7IFtcImFyaWEtZXhwYW5kZWRcIl06IGFyaWFFeHBhbmRlZCwgW1wiYXJpYS1kaXNhYmxlZFwiXTogYXJpYURpc2FibGVkLCAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+IHtcblxuICAgICAgICAgICAgLy9jb25zdCBvbkZvY3VzID0gKCkgPT4geyBjaGFuZ2VUYWJiZWRJbmRleChpbmRleCk7IH1cbiAgICAgICAgICAgIGNvbnN0IG9uUHJlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGdldE9wZW5Gcm9tUGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUV4cGFuZGVkSW5kZXgobnVsbCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VFeHBhbmRlZEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlQnV0dG9uUHJvcHMgfSA9IHVzZUJ1dHRvbjxIZWFkZXJFbGVtZW50Pih7IHRhZzogdGFnQnV0dG9uLCBkaXNhYmxlZCwgb25QcmVzcyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJldEIgPSB1c2VCdXR0b25Qcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICAvL2NvbnN0IHJldEIgPSB1c2VNZXJnZWRQcm9wczxIZWFkZXJFbGVtZW50Pih1c2VQcmVzc0V2ZW50SGFuZGxlcnM8SGVhZGVyRWxlbWVudD4ob25DbGljaywgdW5kZWZpbmVkKSwgcHJvcHMpO1xuXG5cblxuICAgICAgICAgICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxIZWFkZXJFbGVtZW50Pih7XG4gICAgICAgICAgICAgICAgLi4uaGFzRm9jdXMsXG4gICAgICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbiwgcHJldjogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/Lihmb2N1c2VkLCBwcmV2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUYWJiZWRJbmRleChpbmRleCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vY29uc3QgcmV0MzogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SGVhZGVyRWxlbWVudD5cbiAgICAgICAgICAgIC8vICAgID0gdXNlTWVyZ2VkUHJvcHM8SGVhZGVyRWxlbWVudD4ocmV0RCwgeyBvbkZvY3VzIH0pO1xuXG5cbiAgICAgICAgICAgIHJldHVybiB1c2VIYXNGb2N1c1Byb3BzKHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyh1c2VIZWFkZXJBc1NvdXJjZUlkUHJvcHModXNlSGVhZGVyQXNSZWZlcmVuY2VySWRQcm9wcyh7XG4gICAgICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IChhcmlhRXhwYW5kZWQgPz8gb3BlbiA/PyBmYWxzZSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBcImFyaWEtZGlzYWJsZWRcIjogKGFyaWFEaXNhYmxlZCA/PyAob3BlbiA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkKSksXG4gICAgICAgICAgICAgICAgLi4udXNlSGVhZGVyUmVmRWxlbWVudFByb3BzKHJldEIpXG4gICAgICAgICAgICB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRlckVsZW1lbnQ+KSkpKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgZnVuY3Rpb24gdXNlQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyh7IHJvbGUsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PiB7XG4gICAgICAgICAgICBjb25zdCByZXQxID0gdXNlQm9keUFzUmVmZXJlbmNlcklkUHJvcHMoeyByb2xlOiByb2xlID8/IFwicmVnaW9uXCIsIC4uLnByb3BzIH0pO1xuICAgICAgICAgICAgY29uc3QgcmV0MiA9IHVzZUJvZHlBc1NvdXJjZUlkUHJvcHMocmV0MSk7XG4gICAgICAgICAgICByZXQyLnRhYkluZGV4ID8/PSAtMTtcbiAgICAgICAgICAgIHJldHVybiB1c2VCb2R5UmVmRWxlbWVudFByb3BzKHJldDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY29yZGlvblNlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBleHBhbmRlZDogb3BlbixcbiAgICAgICAgICAgICAgICBmb2N1c2VkOiAoZ2V0Q3VycmVudEZvY3VzZWRJbmRleCgpID09IGluZGV4KSxcbiAgICAgICAgICAgICAgICBib2R5SWQsXG4gICAgICAgICAgICAgICAgaGVhZGVySWQsXG4gICAgICAgICAgICAgICAgZ2V0Qm9keUlkLFxuICAgICAgICAgICAgICAgIGdldEhlYWRlcklkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXNlQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzLFxuICAgICAgICAgICAgdXNlQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyxcblxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtY1JldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxuICAgICAgICBhY2NvcmRpb246IHsgY2hhbmdlRXhwYW5kZWRJbmRleCB9LFxuICAgICAgICB1c2VBY2NvcmRpb25TZWN0aW9uLFxuICAgIH1cbn1cblxuXG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcywgdXNlUHJlc3MsIHVzZVJhbmRvbUlkLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnIH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuaW50ZXJmYWNlIFVMSTxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcHJlZml4TGFiZWw6IHN0cmluZztcbiAgICBwcmVmaXhJbnB1dDogc3RyaW5nO1xuICAgIHRhZ0lucHV0OiBFbGVtZW50VG9UYWc8SW5wdXRFbGVtZW50PjtcbiAgICB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD47XG59XG5cbmV4cG9ydCB0eXBlIExhYmVsT21pdHMgPSBrZXlvZiBVTEk8YW55LCBhbnk+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxhYmVsUGFyYW1ldGVyczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMT21pdHMgZXh0ZW5kcyBMYWJlbE9taXRzPiB7XG4gICAgbGFiZWw6IE9taXQ8VUxJPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgTE9taXRzPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8ge1xuICAgIGxhYmVsOiB7XG4gICAgICAgIGxhYmVsSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgaW5wdXRJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgICAvKiogKipTdGFibGUqKiAqL1xuICAgICAgICBnZXRMYWJlbElkOiAoKSA9PiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgIC8qKiAqKlN0YWJsZSoqICovXG4gICAgICAgIGdldElucHV0SWQ6ICgpID0+IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGFiZWxSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGFiZWxSZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqICpOb3RhYmx5IHVuc3RhYmxlKiAqL1xuICAgIHVzZUxhYmVsSW5wdXQ6ICgpID0+IHsgdXNlTGFiZWxJbnB1dFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47IH07XG4gICAgLyoqICpOb3RhYmx5IHVuc3RhYmxlKiAqL1xuICAgIHVzZUxhYmVsTGFiZWw6ICgpID0+IHsgdXNlTGFiZWxMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47IH07XG59XG5cbi8qKlxuICogQWRkcyBhbiBJRCBhbmQgXCJhcmlhLWxhYmVsbGVkYnlcIiBmb3IgdHdvIGVsZW1lbnRzLCBhbiBcImlucHV0XCIgZWxlbWVudCBhbmQgYSBcImxhYmVsXCIgZWxlbWVudC5cbiAqIFxuICogUmV0dXJucyB0aGUgYHVzZVJlZmVyZW5jZWRJZFByb3BzYCBob29rcyBpZiB5b3UgbmVlZCB0byBhbHNvIGFkZCBvdGhlciBJRC1yZWZlcmVuY2VyIGF0dHJpYnV0ZXMsIGxpa2UgYGZvcmBcbiAqIFxuICogQHNlZSB1c2VJbnB1dExhYmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYWJlbDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxhYmVsOiB7IHByZWZpeElucHV0LCBwcmVmaXhMYWJlbCwgdGFnSW5wdXQsIHRhZ0xhYmVsIH0gfTogVXNlTGFiZWxQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50LCBuZXZlcj4pOiBVc2VMYWJlbFJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+IHtcblxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VMYWJlbEFzU291cmNlSWQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUxhYmVsQXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogbGFiZWxJZCwgZ2V0VXNlZElkOiBnZXRMYWJlbElkIH0gfSA9IHVzZVJhbmRvbUlkPExhYmVsRWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IHByZWZpeExhYmVsIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VJbnB1dEFzU291cmNlSWQsIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ6IHVzZUlucHV0QXNSZWZlcmVuY2VySWQsIHJhbmRvbUlkOiB7IHVzZWRJZDogaW5wdXRJZCwgZ2V0VXNlZElkOiBnZXRJbnB1dElkIH0gfSA9IHVzZVJhbmRvbUlkPElucHV0RWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IHByZWZpeElucHV0IH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZUxhYmVsQXNTb3VyY2VJZFByb3BzIH0gPSB1c2VMYWJlbEFzU291cmNlSWQoKTtcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VJbnB1dEFzU291cmNlSWRQcm9wcyB9ID0gdXNlSW5wdXRBc1NvdXJjZUlkKCk7XG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUxhYmVsQXNSZWZlcmVuY2VySWRQcm9wcyB9ID0gdXNlTGFiZWxBc1JlZmVyZW5jZXJJZDxJbnB1dEVsZW1lbnQ+KFwiYXJpYS1sYWJlbGxlZGJ5XCIgYXMgbmV2ZXIpO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzOiB1c2VJbnB1dEFzUmVmZXJlbmNlcklkUHJvcHMgfSA9IHVzZUlucHV0QXNSZWZlcmVuY2VySWQ8TGFiZWxFbGVtZW50PihcImZvclwiKTtcblxuICAgIGNvbnN0IGlzU3ludGhldGljTGFiZWwgPSAodGFnSW5wdXQgIT0gXCJpbnB1dFwiIHx8IHRhZ0xhYmVsICE9IFwibGFiZWxcIik7XG5cbiAgICBjb25zdCB1c2VMYWJlbExhYmVsOiAoKCkgPT4geyB1c2VMYWJlbExhYmVsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PjsgfSkgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VMYWJlbExhYmVsKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlTGFiZWxMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhvdXRGb3IgPSB1c2VMYWJlbEFzU291cmNlSWRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcHNXaXRoRm9yID0gdXNlSW5wdXRBc1JlZmVyZW5jZXJJZFByb3BzKHByb3BzV2l0aG91dEZvcik7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ0xhYmVsID09IFwibGFiZWxcIiAmJiB0YWdJbnB1dCA9PSBcImlucHV0XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wc1dpdGhGb3I7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHNXaXRob3V0Rm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2lzU3ludGhldGljTGFiZWxdKTtcblxuICAgIGNvbnN0IHVzZUxhYmVsSW5wdXQgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VMYWJlbElucHV0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlTGFiZWxJbnB1dFByb3BzOiAoeyBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRieSwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KCFhcmlhTGFiZWxsZWRieSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeSA9IHVzZUlucHV0QXNTb3VyY2VJZFByb3BzKHByb3BzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc1dpdGhBcmlhTGFiZWxsZWRCeSA9IHVzZUxhYmVsQXNSZWZlcmVuY2VySWRQcm9wcyhwcm9wc1dpdGhvdXRBcmlhTGFiZWxsZWRCeSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3ludGhldGljTGFiZWwgJiYgIXByb3BzW1wiYXJpYS1sYWJlbFwiXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzV2l0aEFyaWFMYWJlbGxlZEJ5O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzV2l0aG91dEFyaWFMYWJlbGxlZEJ5O1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbaXNTeW50aGV0aWNMYWJlbF0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMYWJlbElucHV0LFxuICAgICAgICB1c2VMYWJlbExhYmVsLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgbGFiZWxJZCxcbiAgICAgICAgICAgIGlucHV0SWQsXG4gICAgICAgICAgICBnZXRMYWJlbElkLFxuICAgICAgICAgICAgZ2V0SW5wdXRJZFxuICAgICAgICB9XG4gICAgfVxuXG59XG5cblxuXG5cbmV4cG9ydCB0eXBlIENoZWNrYm94Q2hlY2tlZFR5cGUgPSBib29sZWFuIHwgXCJtaXhlZFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGxhYmVsOiBVc2VMYWJlbFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGUsIFwicHJlZml4TGFiZWxcIiB8IFwicHJlZml4SW5wdXRcIj5bXCJsYWJlbFwiXTtcbiAgICBjaGVja2JveExpa2U6IHtcbiAgICAgICAgbGFiZWxQb3NpdGlvbjogXCJ3cmFwcGluZ1wiIHwgXCJzZXBhcmF0ZVwiO1xuICAgICAgICAvKiogVGhlIHJvbGUgYXR0cmlidXRlIHRvIHVzZSwgd2hlbiBhcHBsaWNhYmxlICovXG4gICAgICAgIHJvbGU6IHN0cmluZztcbiAgICAgICAgZGlzYWJsZWQ6IGJvb2xlYW47XG4gICAgICAgIGNoZWNrZWQ6IENoZWNrYm94Q2hlY2tlZFR5cGU7XG4gICAgICAgIG9uQ2hlY2tlZENoYW5nZT8oZXZlbnQ6IGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlPik6IHZvaWQ7XG4gICAgICAgIC8vb25JbnB1dD8oZXZlbnQ6IGguSlNYLlRhcmdldGVkRXZlbnQ8TGFiZWxUeXBlPik6IHZvaWQ7XG4gICAgfVxufVxuXG5jb25zdCBoYW5kbGVzSW5wdXQgPSA8RSBleHRlbmRzIEVsZW1lbnQ+KHRhZzogRWxlbWVudFRvVGFnPEU+LCBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCIsIHdoaWNoOiBcImlucHV0LWVsZW1lbnRcIiB8IFwibGFiZWwtZWxlbWVudFwiKSA9PiB7XG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT09IFwic2VwYXJhdGVcIikge1xuICAgICAgICBpZiAod2hpY2ggPT09IFwiaW5wdXQtZWxlbWVudFwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGVsc2UgaWYgKHdoaWNoID09PSBcImxhYmVsLWVsZW1lbnRcIilcbiAgICAgICAgICAgIHJldHVybiB0YWcgIT0gXCJpbnB1dFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChsYWJlbFBvc2l0aW9uID09PSBcIndyYXBwaW5nXCIpIHtcbiAgICAgICAgaWYgKHdoaWNoID09PSBcImlucHV0LWVsZW1lbnRcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHdoaWNoID09IFwibGFiZWwtZWxlbWVudFwiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufTtcblxuZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50PElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4ge1xuICAgIGdldElucHV0RWxlbWVudDogKCkgPT4gSW5wdXRUeXBlIHwgbnVsbDtcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xuICAgIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzOiAoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQ8TGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wczogKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveExpa2VSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8ge1xuICAgIGNoZWNrYm94TGlrZToge1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRMYWJlbEVsZW1lbnQ6ICgpID0+IExhYmVsVHlwZSB8IG51bGw7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldElucHV0RWxlbWVudDogKCkgPT4gSW5wdXRUeXBlIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGVJbmZvPElucHV0VHlwZSwgTGFiZWxUeXBlPiB7XG4gICAgLyoqICpOb3RhYmx5IHVuc3RhYmxlKiAqL1xuICAgIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDogVXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50PElucHV0VHlwZT47XG4gICAgLyoqICpOb3RhYmx5IHVuc3RhYmxlKiAqL1xuICAgIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudDogKCkgPT4geyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wczogKHsgLi4ucDAgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPjsgfTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGxhYmVsIHR5cGUgKHdyYXBwaW5nIG9yIHNlcGFyYXRlKSBmb3IgY2hlY2tib3hlcywgcmFkaW9zLCBzd2l0Y2hlcywgZXRjLlxuICogXG4gKiBJZiBpdCdzIGEgdG9nZ2xlYWJsZSBjbGljay10aGluZyB3aXRoIGEgbGFiZWwgKHRoYXQgY2FuIGFsc28gYmUgY2xpY2tlZCksIHRoZW4gaXQncyBhIGNoZWNrYm94LWxpa2UuXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGVja2JveExpa2U8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4oeyBjaGVja2JveExpa2U6IHsgY2hlY2tlZCwgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24sIHJvbGUsIG9uQ2hlY2tlZENoYW5nZSB9LCBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSB9OiBVc2VDaGVja2JveExpa2VQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPik6IFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGVXaXRoSG9va3M8SW5wdXRUeXBlLCBMYWJlbFR5cGU+IHtcblxuICAgIGNvbnN0IHN0YWJsZU9uSW5wdXQgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxJbnB1dFR5cGU+IHwgaC5KU1guVGFyZ2V0ZWRFdmVudDxMYWJlbFR5cGU+KSA9PiB7IFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IFxuICAgICAgICBvbkNoZWNrZWRDaGFuZ2U/LihlIGFzIGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlPik7IFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0OiB1c2VJTElucHV0LCB1c2VMYWJlbExhYmVsOiB1c2VJTExhYmVsLCBsYWJlbCB9ID0gdXNlTGFiZWw8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KHsgbGFiZWw6IHsgcHJlZml4TGFiZWw6IFwiYXJpYS1jaGVja2JveC1sYWJlbC1cIiwgcHJlZml4SW5wdXQ6IFwiYXJpYS1jaGVja2JveC1pbnB1dC1cIiwgdGFnSW5wdXQ6IHRhZ0lucHV0LCB0YWdMYWJlbDogdGFnTGFiZWwgfSB9KTtcblxuXG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRMYWJlbEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wczogdXNlTGFiZWxSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8TGFiZWxUeXBlPigpO1xuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0SW5wdXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHM6IHVzZUlucHV0UmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PElucHV0VHlwZT4oKTtcblxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudDogVXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50PElucHV0VHlwZT4gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VDaGVja2JveElucHV0RWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgdGFnID0gdGFnSW5wdXQ7XG4gICAgICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dFByb3BzOiB1c2VJTElucHV0UHJvcHMgfSA9IHVzZUlMSW5wdXQoKTtcbiAgICAgICAgY29uc3QgeyB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZVJlZkVsZW1lbnQ8SW5wdXRUeXBlPih7fSk7XG5cbiAgICAgICAgLy8gb25DbGljayBhbmQgb25DaGFuZ2UgYXJlIGEgYml0IG1lc3N5LCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vICphbHdheXMqIG1ha2Ugc3VyZSB0aGF0IHRoZSB2aXNpYmxlIHN0YXRlIGlzIGNvcnJlY3RcbiAgICAgICAgLy8gYWZ0ZXIgYWxsIHRoZSBldmVudCBkdXN0IHNldHRsZXMuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8yNzQ1LFxuICAgICAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMTg5OSNpc3N1ZWNvbW1lbnQtNTI1NjkwMTk0XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgdGFnID09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgICAgIChlbGVtZW50IGFzIEVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkuaW5kZXRlcm1pbmF0ZSA9IChjaGVja2VkID09PSBcIm1peGVkXCIpO1xuICAgICAgICAgICAgICAgIChlbGVtZW50IGFzIEVsZW1lbnQgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZCA9IChjaGVja2VkID09PSB0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbdGFnLCBjaGVja2VkXSlcblxuICAgICAgICByZXR1cm4geyBnZXRJbnB1dEVsZW1lbnQ6IGdldEVsZW1lbnQsIHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzIH07XG5cblxuICAgICAgICBmdW5jdGlvbiB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+IHtcblxuICAgICAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBDaHJvbWUgd29uJ3QgZmlyZSBvbklucHV0IGV2ZW50cyBmb3IgcmFkaW8gYnV0dG9ucyB0aGF0IGFyZSB0YWJJbmRleD0tMT8/XG4gICAgICAgICAgICAvLyBOZWVkcyBpbnZlc3RpZ2F0aW5nLCBidXQgb25JbnB1dCB3b3JrcyBmaW5lIGluIEZpcmVmb3hcbiAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIGNvbnN0IHVzZVByZXNzUHJvcHMgPSB1c2VQcmVzczxJbnB1dFR5cGU+KGRpc2FibGVkIHx8ICFoYW5kbGVzSW5wdXQodGFnLCBsYWJlbFBvc2l0aW9uLCBcImlucHV0LWVsZW1lbnRcIikgPyB1bmRlZmluZWQgOiBzdGFibGVPbklucHV0LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgbGV0IHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+ID0gdXNlUHJlc3NQcm9wcyhwMCk7XG5cbiAgICAgICAgICAgIGlmICh0YWcgPT0gXCJpbnB1dFwiKVxuICAgICAgICAgICAgICAgIHByb3BzLm9uSW5wdXQgPSAoZTogRXZlbnQpID0+IGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgcHJvcHMgPSB1c2VSZWZFbGVtZW50UHJvcHModXNlSUxJbnB1dFByb3BzKHByb3BzKSk7XG5cblxuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgd3JhcHBlZCBsYWJlbCBoYW5kbGVzIGFsbCBpbnRlcmFjdGlvbnMsXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhpcyBlbGVtZW50IGNhbid0IGJlIGludGVyYWN0ZWQgd2l0aFxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gaWYgaXQncyBhbiBpbnB1dCBlbGVtZW50LlxuICAgICAgICAgICAgICAgIHByb3BzLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9wcy50YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIHByb3BzLnJvbGUgPSBcInByZXNlbnRhdGlvblwiO1xuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1oaWRkZW5cIl0gPSBcInRydWVcIjtcbiAgICAgICAgICAgICAgICBwcm9wcy5vbkZvY3VzID0gXyA9PiAoZ2V0TGFiZWxFbGVtZW50KCkgYXMgSFRNTEVsZW1lbnQgfCBudWxsKT8uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0YWcgPT09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jaGVja2VkID0gKGNoZWNrZWQgPT09IHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMucm9sZSA9IHJvbGU7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbXCJhcmlhLWNoZWNrZWRcIl0gPSBjaGVja2VkID09PSBcIm1peGVkXCIgPyBcIm1peGVkXCIgOiBjaGVja2VkID09PSB0cnVlID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IGRpc2FibGVkLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgbGFiZWwgY2xpY2tzIGNhbid0IGFmZmVjdCB0aGUgY2hlY2tib3ggd2hpbGUgaXQncyBkaXNhYmxlZFxuICAgICAgICAgICAgcHJvcHMub25DbGljayA9IGRpc2FibGVkID8gKChlKSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9KSA6IHByb3BzLm9uQ2xpY2s7XG5cbiAgICAgICAgICAgIHJldHVybiB1c2VJbnB1dFJlZkVsZW1lbnRQcm9wcyh1c2VNZXJnZWRQcm9wczxJbnB1dFR5cGU+KHAwLCBwcm9wcykpO1xuICAgICAgICB9XG4gICAgfSwgW3VzZUlMSW5wdXQsIHJvbGUsIGxhYmVsUG9zaXRpb24sIGRpc2FibGVkLCBjaGVja2VkLCB0YWdJbnB1dF0pO1xuXG4gICAgY29uc3QgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHRhZ0xhYmVsO1xuICAgICAgICBjb25zdCB7IHVzZUxhYmVsTGFiZWxQcm9wczogdXNlSUxMYWJlbFByb3BzIH0gPSB1c2VJTExhYmVsKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxUeXBlPiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHVzZVByZXNzUHJvcHMgPSB1c2VQcmVzczxMYWJlbFR5cGU+KGRpc2FibGVkIHx8ICFoYW5kbGVzSW5wdXQodGFnLCBsYWJlbFBvc2l0aW9uLCBcImxhYmVsLWVsZW1lbnRcIikgPyB1bmRlZmluZWQgOiBzdGFibGVPbklucHV0LCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsVHlwZT4gPSB1c2VQcmVzc1Byb3BzKHAwKTtcblxuICAgICAgICAgICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJ3cmFwcGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1Byb3BzLnRhYkluZGV4ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIG5ld1Byb3BzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAobmV3UHJvcHMucm9sZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBuZXdQcm9wcy5yb2xlID0gcm9sZTtcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBkaXNhYmxlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiYXJpYS1jaGVja2VkXCJdID0gY2hlY2tlZC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9uZSBjYXNlIHdoZXJlIHRoZXJlJ3MgYWxtb3N0IG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBub3JtYWwgY2FzZSB3aGVyZSBldmVyeXRoaW5nIGFjdHMgYWNjb3JkaW5nIG5vcm1hbCBIVE1MIG1lY2hhbmljcy5cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBKdXN0IG1ha2Ugc3VyZSB0aGF0IGxhYmVsIGNsaWNrcyBjYW4ndCBhZmZlY3QgdGhlIGNoZWNrYm94IHdoaWxlIGl0J3MgZGlzYWJsZWRcbiAgICAgICAgICAgIG5ld1Byb3BzLm9uQ2xpY2sgPSBkaXNhYmxlZCA/ICgoZSkgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSkgOiBuZXdQcm9wcy5vbkNsaWNrO1xuXG4gICAgICAgICAgICByZXR1cm4gdXNlSUxMYWJlbFByb3BzKHVzZUxhYmVsUmVmRWxlbWVudFByb3BzKG5ld1Byb3BzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRQcm9wcyB9O1xuXG4gICAgfSwgW3VzZUlMTGFiZWwsIGRpc2FibGVkLCBjaGVja2VkLCByb2xlLCBsYWJlbFBvc2l0aW9uLCB0YWdMYWJlbF0pO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQsXG4gICAgICAgIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCxcbiAgICAgICAgY2hlY2tib3hMaWtlOiB7XG4gICAgICAgICAgICBnZXRMYWJlbEVsZW1lbnQsXG4gICAgICAgICAgICBnZXRJbnB1dEVsZW1lbnQsXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsXG4gICAgfTtcblxuXG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZywgRW5oYW5jZWRFdmVudCwgZW5oYW5jZUV2ZW50IH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUNoZWNrYm94TGlrZSwgVXNlQ2hlY2tib3hMaWtlUGFyYW1ldGVycywgVXNlQ2hlY2tib3hMaWtlUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcblxuXG5cbmV4cG9ydCB0eXBlIENoZWNrYm94Q2hhbmdlRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IEVuaGFuY2VkRXZlbnQ8RSwgRXZlbnQsIHsgY2hlY2tlZDogYm9vbGVhbiB9PjtcblxuZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQ8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHM6ICh7IC4uLnAwIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0VHlwZT47IH1cbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94TGFiZWxFbGVtZW50PExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+ID0gKCkgPT4geyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzOiAoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+OyB9XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveFBhcmFtZXRlcnM8SSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgY2hlY2tib3hMaWtlOiBPbWl0PFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgTD5bXCJjaGVja2JveExpa2VcIl0sIFwib25DaGVja2VkQ2hhbmdlXCIgfCBcInJvbGVcIj47XG4gICAgbGFiZWw6IFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgTD5bXCJsYWJlbFwiXTtcbiAgICBjaGVja2JveDoge1xuICAgICAgICBvbkNoZWNrZWRDaGFuZ2U/KGV2ZW50OiBDaGVja2JveENoYW5nZUV2ZW50PEk+KTogdm9pZDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGVJbmZvPElucHV0VHlwZSwgTGFiZWxUeXBlPiB7XG4gICAgLy9jaGVja2JveExpa2U6IFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGU8SW5wdXRUeXBlLCBMYWJlbFR5cGU+W1wiY2hlY2tib3hMaWtlXCJdO1xuICAgIC8vbGFiZWw6IFVzZUNoZWNrYm94TGlrZVJldHVyblR5cGU8SW5wdXRUeXBlLCBMYWJlbFR5cGU+W1wibGFiZWxcIl07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0VHlwZSBleHRlbmRzIEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQ2hlY2tib3hSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUsIExhYmVsVHlwZT4ge1xuICAgIC8qKiAqKk5vdGFibHkgdW5zdGFibGUqKiAqL1xuICAgIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50OiBVc2VDaGVja2JveElucHV0RWxlbWVudDxJbnB1dFR5cGU+O1xuICAgIC8qKiAqKk5vdGFibHkgdW5zdGFibGUqKiAqL1xuICAgIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50OiBVc2VDaGVja2JveExhYmVsRWxlbWVudDxMYWJlbFR5cGU+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hlY2tib3g8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4oeyBjaGVja2JveExpa2UsIGxhYmVsLCBjaGVja2JveCB9OiBVc2VDaGVja2JveFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KTogVXNlQ2hlY2tib3hSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0VHlwZSwgTGFiZWxUeXBlPiB7XG4gICAgZGVidWdMb2coXCJ1c2VDaGVja2JveFwiKTtcblxuICAgIGNvbnN0IHsgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24sIGNoZWNrZWQgfSA9IGNoZWNrYm94TGlrZTtcbiAgICBjb25zdCB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9ID0gbGFiZWw7XG4gICAgY29uc3QgeyBvbkNoZWNrZWRDaGFuZ2U6IG9uSW5wdXQgfSA9IGNoZWNrYm94O1xuXG4gICAgY29uc3Qgb25JbnB1dEVuaGFuY2VkID0gKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8SW5wdXRUeXBlPikgPT4gb25JbnB1dD8uKGVuaGFuY2VFdmVudDxJbnB1dFR5cGUsIEV2ZW50LCB7IGNoZWNrZWQ6IGJvb2xlYW4gfT4oZSwgeyBjaGVja2VkOiAhY2hlY2tlZCB9KSk7XG4gICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCwgLi4uY2hlY2tib3hMaWtlUmVzdCB9ID0gdXNlQ2hlY2tib3hMaWtlPElucHV0VHlwZSwgTGFiZWxUeXBlPih7IGNoZWNrYm94TGlrZTogeyByb2xlOiBcImNoZWNrYm94XCIsIGNoZWNrZWQsIG9uQ2hlY2tlZENoYW5nZTogb25JbnB1dEVuaGFuY2VkLCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgfSwgbGFiZWwgfSk7XG5cbiAgICBjb25zdCB1c2VDaGVja2JveElucHV0RWxlbWVudDogVXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQ8SW5wdXRUeXBlPiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50KCkge1xuICAgICAgICBjb25zdCB0YWcgPSB0YWdJbnB1dDtcbiAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50KCk7XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMoeyAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+KSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dFR5cGU+ID0gdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50UHJvcHMocDApO1xuICAgICAgICAgICAgcHJvcHMuY2hlY2tlZCA/Pz0gISFjaGVja2VkO1xuXG4gICAgICAgICAgICBpZiAodGFnID09IFwiaW5wdXRcIilcbiAgICAgICAgICAgICAgICBwcm9wcy50eXBlID0gXCJjaGVja2JveFwiO1xuXG4gICAgICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICAgIH1cbiAgICB9LCBbdXNlQ2hlY2tib3hMaWtlSW5wdXRFbGVtZW50LCBjaGVja2VkLCBsYWJlbFBvc2l0aW9uLCBkaXNhYmxlZCwgdGFnSW5wdXRdKTtcblxuICAgIGNvbnN0IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbFR5cGU+KSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHMocHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyB9O1xuICAgIH0sIFt1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCB0YWdMYWJlbF0pO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VDaGVja2JveElucHV0RWxlbWVudCxcbiAgICAgICAgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQsXG4gICAgICAgIC4uLmNoZWNrYm94TGlrZVJlc3RcbiAgICB9O1xuXG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgcmV0dXJuRmFsc2UsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCB1c2VNZXJnZWRQcm9wcywgdXNlUGFzc2l2ZVN0YXRlLCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm8sIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IENoZWNrYm94Q2hlY2tlZFR5cGUgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCBFbmhhbmNlZEV2ZW50LCBlbmhhbmNlRXZlbnQsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IENoZWNrYm94Q2hhbmdlRXZlbnQsIHVzZUNoZWNrYm94LCBVc2VDaGVja2JveFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94UmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtY2hlY2tib3hcIjtcblxuZXhwb3J0IHR5cGUgQ2hlY2tib3hHcm91cENoYW5nZUV2ZW50PEUgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSBFbmhhbmNlZEV2ZW50PEUsIEV2ZW50LCB7IGNoaWxkcmVuQ2hlY2tlZDogYm9vbGVhbiB8IE1hcDxudW1iZXIsIGJvb2xlYW4gfCBcIm1peGVkXCI+IH0+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4ge1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBwYXJlbnQgY2hlY2tib3ggaXMgY2hhbmdlZCBhbmQgYW4gdXBkYXRlIG9mXG4gICAgICogYWxsIHRoZSBjaGlsZHJlbiBuZWVkcyB0byBvY2N1ci5cbiAgICAgKiBcbiAgICAgKiBgZXZlbnRbRXZlbnREZXRhaWxdLmNoaWxkcmVuQ2hlY2tlZGAgd2lsbCBiZSBcbiAgICAgKiAqIHRydWUgd2hlbiBhbGwgY2hpbGRyZW4gbmVlZCB0byBiZWNvbWUgY2hlY2tlZFxuICAgICAqICogZmFsc2Ugd2hlbiBhbGwgY2hpbGRyZW4gbmVlZCB0byBiZWNvbWUgdW5jaGVja2VkXG4gICAgICogKiBBIGBNYXA8aW5kZXgsY2hlY2tlZD5gIG9mIGVhY2ggY2hpbGQncyBzdGF0dXMgd2hlbiByZXZlcnRpbmcgdG8gXCJtaXhlZFwiLlxuICAgICAqIFxuICAgICAqIEJlY2F1c2Ugd2UncmUgZGVhbGluZyB3aXRoIGNvbnRyb2xsZWQgY29tcG9uZW50cyBoZXJlLCBhbmQgdGhlIGRhdGEgZm9yXG4gICAgICogd2hhdCBjaGVja2JveGVzIGFyZSBjaGVja2VkIGxpdmUgKm91dHNpZGUqIG9mIGFueSBvZiB0aGVzZSBob29rcyxcbiAgICAgKiBpdCdzIHlvdSB3aG8ncyByZXNwb25zaWJsZSBmb3IgbGlzdGVuaW5nIGZvciB0aGlzIGV2ZW50LCBtb2RpZnlpbmcgdGhlXG4gICAgICogZGF0YSwgYW5kIHJlLXJlbmRlcmluZyBhcHByb3ByaWF0ZWx5LlxuICAgICAqIFxuICAgICAqIEhpZ2hseSByZWNvbW1lbmRlZCB0bywgZm9yIGV4YW1wbGUsIGFkZCBlYWNoIGNoaWxkJ3MgYG9uSW5wdXRgIGV2ZW50IGhhbmRsZXJcbiAgICAgKiBhdmFpbGFibGUgaW4gdGhlIGNoaWxkIGluZm8gdGhlIHBhcmVudCBnZXRzIHNvIGl0IGNhbiBjYWxsIHRoZSBoYW5kbGVyXG4gICAgICogcmVtb3RlbHkgZnJvbSBgbWFuYWdlZENoZWNrYm94ZXNgLlxuICAgICAqIEBwYXJhbSBldmVudCBcbiAgICAgKi9cbiAgICAvL2NoZWNrYm94R3JvdXA6IHt9XG4gICAgLy9vblVwZGF0ZUNoaWxkcmVuKGV2ZW50OiBDaGVja2JveEdyb3VwQ2hhbmdlRXZlbnQ8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPj4pOiB2b2lkO1xufVxuXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cENoaWxkSW5mb0Jhc2U8SyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkSW5mb0Jhc2U8Sz4ge1xuLyoqXG4gKiBUaGUgaWQgYXR0cmlidXRlIHVzZWQgZm9yIHRoZSBjaGlsZC5cbiAqL1xuLy9pZDogc3RyaW5nO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50IGNoZWNrZWQgc3RhdGUgb2YgdGhpcyBjaGlsZC5cbiAqIFxuICogVGhpcyBpcyB1c2VkIGJ5IHRoZSBwYXJlbnQgd2hlbmV2ZXIgaXQncyBpbnRlcmFjdGVkIHdpdGggXG4gKiBhbmQgYWJvdXQgdG8gZm9yY2UgZXZlcnkgb25lIHRvIGJlIHNvbWV0aGluZyBkaWZmZXJlbnQgLS0gXG4gKiBpdCB3aWxsIHNhdmUgdGhlIHN0YXRlIG9mIGFsbCBjaGlsZCBjaGVja2JveGVzIGZvciBsYXRlclxuICogYnkgYXNraW5nIGVhY2ggb25lIHdoYXQgaXRzIGN1cnJlbnQgc3RhdGUgaXMgaW5kaXZpZHVhbGx5XG4gKiBhdCB0aGF0IG1vbWVudC5cbiAqIFxuICogQWxsIHRoZSBjaGVja2JveCdzIHN0YXRlcyBhcmUgY2FwdHVyZWQgd2hlbiB0aGUgcGFyZW50XG4gKiBpcyBpbiB0aGUgXCJtaXhlZFwiIHN0YXRlIGFuZCBpcyBjbGlja2VkLiBJdCBrZWVwcyB0aGVtXG4gKiB0aGF0IHdheSB1bnRpbCB0aGUgc2FtZSBjb25kaXRpb25zIGFyaXNlIGFnYWluLlxuICovXG4vLyAgICBnZXRMYXN0VXNlckNoZWNrZWQoKTogYm9vbGVhbiB8IFwibWl4ZWRcIjtcbi8vICAgIG9uSW5wdXQ6IFVzZUNoZWNrYm94UGFyYW1ldGVyczxhbnksIGFueT5bXCJvbklucHV0XCJdO1xuLy99XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ0JHIHtcbiAgICBjaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiO1xuICAgIGdldExhc3RVc2VyQ2hlY2tlZCgpOiBib29sZWFuIHwgXCJtaXhlZFwiO1xuICAgIG9uQ2hlY2tlZENoYW5nZTogVXNlQ2hlY2tib3hQYXJhbWV0ZXJzPGFueSwgYW55PltcImNoZWNrYm94XCJdW1wib25DaGVja2VkQ2hhbmdlXCJdO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgYXNDaGVja2JveDogVXNlQ2hlY2tib3hQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PjtcbiAgICBhc0NoZWNrYm94R3JvdXBDaGlsZDoge1xuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENCRywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPltcIm1hbmFnZWRDaGlsZFwiXTtcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q0JHLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+W1wibGlzdE5hdmlnYXRpb25cIl0sIFwic3ViSW5mb1wiPjtcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENCRywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPltcInJvdmluZ1RhYkluZGV4XCJdO1xuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VDaGVja2JveFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudD4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XG4gICAgdXNlQ2hlY2tib3hHcm91cENoaWxkSW5wdXRQcm9wczogKHsgdGFiSW5kZXgsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD47XG4gICAgdXNlQ2hlY2tib3hHcm91cENoaWxkTGFiZWxQcm9wczogKHsgdGFiSW5kZXgsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XG59XG5cbmV4cG9ydCB0eXBlIFVzZUNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PikgPT4gVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4gLyp7XG4gICAgLy90YWJiYWJsZTogYm9vbGVhbiB8IG51bGw7XG4gICAgY2hlY2tib3hMaWtlOiBVc2VDaGVja2JveFJldHVyblR5cGU8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+W1wiY2hlY2tib3hMaWtlXCJdO1xuICAgIGxhYmVsOiBVc2VDaGVja2JveFJldHVyblR5cGU8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+W1wibGFiZWxcIl07XG4gICAgcm92aW5nVGFiSW5kZXg6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPElucHV0RWxlbWVudD5bXCJyb3ZpbmdUYWJJbmRleFwiXTtcbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzOiAoeyB0YWJJbmRleCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjtcbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzOiAoeyB0YWJJbmRleCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50Pjtcbn0qL1xuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGVja2JveEdyb3VwUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgX0xhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxJbnB1dEVsZW1lbnQsIENCRywgbmV2ZXI+IHtcbiAgICBjaGVja2JveEdyb3VwOiB7XG4gICAgICAgIHBhcmVudElzQ2hlY2tlZDogYm9vbGVhbiB8IFwibWl4ZWRcIjtcbiAgICAgICAgcGFyZW50UGVyY2VudENoZWNrZWQ6IG51bWJlcjtcbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XG4gICAgLyoqICoqU1RBQkxFICoqICovXG4gICAgLy9jaGVja2JveGVzOiBNYW5hZ2VkQ2hpbGRyZW48ST47XG4gICAgLyoqXG4gICAgICogRWFjaCBjaGlsZCBjaGVja2JveCBtdXN0IGNhbGwgdGhpcyBob29rLCAqaW4gYWRkaXRpb24gdG8qIGB1c2VDaGVja2JveGBcbiAgICAgKi9cbiAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGQ6IFVzZUNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD47XG4gICAgLyoqXG4gICAgICogVGhlIHBhcmVudCBjaGVja2JveCBtdXN0IHVzZSB0aGlzIGhvb2tcbiAgICAgKiBcbiAgICAgKiAqKk5vdGFibHkgdW5zdGFibGUhKiogYmVjYXVzZSBpdCByZWxpZXMgb24gYGFyaWFDb250cm9sc2AsIHBvcHVsYXRlZCBieSBhbGwgY2hpbGQgY2hlY2tib3hlc1xuICAgICAqL1xuICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dDogVXNlQ2hlY2tib3hHcm91cFBhcmVudDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGNoZWNrYm94OiBPbWl0PFVzZUNoZWNrYm94UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD5bXCJjaGVja2JveFwiXSwgXCJvbklucHV0XCI+O1xuICAgIGxhYmVsOiBVc2VDaGVja2JveFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+W1wibGFiZWxcIl07XG4gICAgY2hlY2tib3hMaWtlOiBPbWl0PFVzZUNoZWNrYm94UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD5bXCJjaGVja2JveExpa2VcIl0sIFwiY2hlY2tlZFwiPjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlQ2hlY2tib3hHcm91cFBhcmVudDxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhOiBVc2VDaGVja2JveEdyb3VwUGFyZW50UGFyYW1ldGVyczxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4pID0+IHtcbiAgICB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+O1xuICAgIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XG59O1xuXG5cbi8qKlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoZWNrYm94R3JvdXA8SW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgdHlwZWFoZWFkTmF2aWdhdGlvbiB9OiBVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVycyk6IFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlV2l0aEhvb2tzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XG4gICAgZGVidWdMb2coXCJ1c2VDaGVja2JveEdyb3VwXCIpO1xuICAgIC8vY29uc3Qgb25VcGRhdGVDaGlsZHJlbiA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uVXBkYXRlQ2hpbGRyZW5VbnN0YWJsZSA/PyAoKCkgPT4ge30pKTtcbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIC4uLmxpc3RSZXR1cm5UeXBlXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uPElucHV0RWxlbWVudCwgSW5wdXRFbGVtZW50LCBDQkcsIG5ldmVyPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9IH0gPSBsaXN0UmV0dXJuVHlwZTtcblxuICAgIC8vY29uc3QgW3VuY2hlY2tlZENvdW50LCBzZXRVbmhlY2tlZENvdW50XSA9IHVzZVN0YXRlKDApO1xuXG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCBjaGlsZCBJRHMsIGFuZCBhbnkgdGltZSBhbnkgb2YgdGhlbSBjaGFuZ2UsIFxuICAgIC8vIGdlbmVyYXRlIGEgbmV3IHN0cmluZyB3aXRoIGFsbCBvZiB0aGVtIGNvbmNhdGVuYXRlZCB0b2dldGhlclxuICAgIC8vIChidXQgb25seSBvbmNlIHBlciByZW5kZXIpO1xuICAgIGNvbnN0IGFsbElkcyA9IHVzZVJlZihuZXcgU2V0PHN0cmluZz4oKSk7XG4gICAgY29uc3QgW2FyaWFDb250cm9scywgc2V0Q29udHJvbHNdID0gdXNlU3RhdGUoXCJcIik7XG4gICAgY29uc3QgW3VwZGF0ZUluZGV4LCBzZXRJZFVwZGF0ZUluZGV4XSA9IHVzZVN0YXRlKDApO1xuXG5cbiAgICBjb25zdCBbY2hlY2tlZENvdW50LCBzZXRDaGVja2VkQ291bnRdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgY2hlY2tlZEluZGljZXMgPSB1c2VSZWYobmV3IFNldDxudW1iZXI+KCkpO1xuICAgIC8vY29uc3QgW3NlbGZJc0NoZWNrZWQsIHNldFNlbGZJc0NoZWNrZWQsIGdldFNlbGZJc0NoZWNrZWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IFwibWl4ZWRcIj4oZmFsc2UpO1xuXG4gICAgY29uc3QgZ2V0U2VsZklzQ2hlY2tlZFVuc3RhYmxlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gY2hlY2tlZENvdW50IC8gKGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpICsgMSk7XG4gICAgICAgIHJldHVybiBwZXJjZW50YWdlIDw9IDAgPyBmYWxzZSA6IHBlcmNlbnRhZ2UgPj0gMSA/IHRydWUgOiBcIm1peGVkXCI7XG4gICAgfSwgW2NoZWNrZWRDb3VudF0pO1xuXG4gICAgY29uc3QgZ2V0U2VsZklzQ2hlY2tlZFN0YWJsZSA9IHVzZVN0YWJsZUNhbGxiYWNrKGdldFNlbGZJc0NoZWNrZWRVbnN0YWJsZSk7XG4gICAgY29uc3QgW3NldFBhcmVudENoZWNrYm94Q2hlY2tlZCwgc2V0U2V0UGFyZW50Q2hlY2tib3hDaGVja2VkXSA9IHVzZVN0YXRlPFN0YXRlVXBkYXRlcjxDaGVja2JveENoZWNrZWRUeXBlPiB8IG51bGw+KG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldFBhcmVudENoZWNrYm94Q2hlY2tlZD8uKGNoZWNrZWRDb3VudCA9PSAwID8gZmFsc2UgOiBjaGVja2VkQ291bnQgPT0gKGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpICsgMSkgPyB0cnVlIDogXCJtaXhlZFwiKTtcbiAgICB9LCBbc2V0UGFyZW50Q2hlY2tib3hDaGVja2VkLCBjaGVja2VkQ291bnRdKVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgaGFzIGNoYW5nZWQgdGhlIHBhcmVudCBjaGVja2JveCdzIHZhbHVlLCB0aGVuIHRoaXMgcmVmIGhvbGRzIGEgbWVtb3J5IG9mIHdoYXQgdmFsdWVzIHdlcmUgaGVsZCBiZWZvcmUuXG4gICAgLy8gT3RoZXJ3aXNlLCBpdCdzIG51bGwgd2hlbiB0aGUgbGFzdCBpbnB1dCB3YXMgZnJvbSBhIGNoaWxkIGNoZWNrYm94LiBcbiAgICAvL2NvbnN0IHNhdmVkQ2hlY2tlZFZhbHVlcyA9IHVzZVJlZjxNYXA8bnVtYmVyLCBib29sZWFuIHwgXCJtaXhlZFwiPiB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dCA9IHVzZUNhbGxiYWNrPFVzZUNoZWNrYm94R3JvdXBQYXJlbnQ8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+PigoeyBjaGVja2JveCwgY2hlY2tib3hMaWtlLCBsYWJlbCB9KSA9PiB7XG4gICAgICAgIGRlYnVnTG9nKFwidXNlQ2hlY2tib3hHcm91cFBhcmVudFwiKTtcbiAgICAgICAgY29uc3QgeyAuLi5fdm9pZCB9ID0gY2hlY2tib3g7XG4gICAgICAgIGNvbnN0IHsgZGlzYWJsZWQsIGxhYmVsUG9zaXRpb24gfSA9IGNoZWNrYm94TGlrZTtcbiAgICAgICAgY29uc3QgeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSA9IGxhYmVsO1xuXG4gICAgICAgIGNvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkXSA9IHVzZVN0YXRlPENoZWNrYm94Q2hlY2tlZFR5cGU+KGZhbHNlKTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHNldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZCgoKSA9PiBzZXRDaGVja2VkKTtcbiAgICAgICAgfSwgW10pXG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQsIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50IH0gPSB1c2VDaGVja2JveDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4oeyBjaGVja2JveExpa2U6IHsgbGFiZWxQb3NpdGlvbiwgY2hlY2tlZCwgZGlzYWJsZWQsIH0sIGxhYmVsOiB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9LCBjaGVja2JveDogeyBvbkNoZWNrZWRDaGFuZ2U6IG9uQ2hlY2tib3hHcm91cFBhcmVudElucHV0MiBhcyBhbnksIH0gfSk7XG4gICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgeyB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExhYmVsRWxlbWVudCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0UHJvcHM6IGZ1bmN0aW9uIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gKHVzZU1lcmdlZFByb3BzPElucHV0RWxlbWVudD4odXNlTWVyZ2VkUHJvcHM8SW5wdXRFbGVtZW50Pih7fSwgeyBcImFyaWEtY29udHJvbHNcIjogYXJpYUNvbnRyb2xzLCBvbklucHV0OiB0YWdJbnB1dCA9PSBcImlucHV0XCIgPyAoZSA9PiBlLnByZXZlbnREZWZhdWx0KCkpIDogdW5kZWZpbmVkIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PiksIHByb3BzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUNoZWNrYm94SW5wdXRFbGVtZW50UHJvcHMobGFiZWxQb3NpdGlvbiA9PSBcInNlcGFyYXRlXCIgPyByZXQgOiBwcm9wcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXNlQ2hlY2tib3hHcm91cFBhcmVudExhYmVsUHJvcHM6IGZ1bmN0aW9uIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRMYWJlbFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gKHVzZU1lcmdlZFByb3BzPExhYmVsRWxlbWVudD4odXNlTWVyZ2VkUHJvcHM8TGFiZWxFbGVtZW50Pih7fSwgeyBcImFyaWEtY29udHJvbHNcIjogYXJpYUNvbnRyb2xzIH0gYXMgYW55KSBhcyBhbnksIHByb3BzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIgPyByZXQgOiBwcm9wcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFthcmlhQ29udHJvbHNdKTtcblxuICAgIGNvbnN0IG9uQ2hlY2tib3hHcm91cFBhcmVudElucHV0MiA9IHVzZUNhbGxiYWNrKChlOiBDaGVja2JveENoYW5nZUV2ZW50PElucHV0RWxlbWVudD4pID0+IHtcblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgY29uc3Qgc2VsZklzQ2hlY2tlZCA9IGdldFNlbGZJc0NoZWNrZWRTdGFibGUoKTtcbiAgICAgICAgY29uc3QgbmV4dENoZWNrZWQgPSAoc2VsZklzQ2hlY2tlZCA9PT0gZmFsc2UgPyBcIm1peGVkXCIgOiBzZWxmSXNDaGVja2VkID09PSBcIm1peGVkXCIgPyB0cnVlIDogZmFsc2UpO1xuICAgICAgICBsZXQgd2lsbENoYW5nZUFueSA9IGZhbHNlO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHdpbGxDaGFuZ2VBbnkgfHw9IChjaGlsZC5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby5jaGVja2VkICE9IGNoaWxkLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmdldExhc3RVc2VyQ2hlY2tlZCgpKSk7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgbGV0IGNoZWNrZWQ6IGJvb2xlYW47XG4gICAgICAgICAgICBpZiAobmV4dENoZWNrZWQgPT0gXCJtaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbGxDaGFuZ2VBbnkpXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSAoY2hpbGQuc3ViSW5mby5zdWJJbmZvLnN1YkluZm8uZ2V0TGFzdFVzZXJDaGVja2VkKCkgYXMgYm9vbGVhbik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQgPSBuZXh0Q2hlY2tlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLm9uQ2hlY2tlZENoYW5nZT8uKGVuaGFuY2VFdmVudChlLCB7IGNoZWNrZWQgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLyppZiAoc2VsZklzQ2hlY2tlZCA9PT0gdHJ1ZSB8fCAoc2VsZklzQ2hlY2tlZCA9PT0gZmFsc2UgJiYgc2F2ZWRDaGVja2VkVmFsdWVzLmN1cnJlbnQgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvblVwZGF0ZUNoaWxkcmVuKGVuaGFuY2VFdmVudChlLCB7IGNoaWxkcmVuQ2hlY2tlZDogZmFsc2UgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGZJc0NoZWNrZWQgPT09IFwibWl4ZWRcIikge1xuXG4gICAgICAgICAgICBzYXZlZENoZWNrZWRWYWx1ZXMuY3VycmVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgIHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50IS5zZXQoY2hpbGQuaW5kZXgsIGNoaWxkLmdldExhc3RVc2VyQ2hlY2tlZCgpKTtcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVybiBvblVwZGF0ZUNoaWxkcmVuKGVuaGFuY2VFdmVudChlLCB7IGNoaWxkcmVuQ2hlY2tlZDogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb25VcGRhdGVDaGlsZHJlbihlbmhhbmNlRXZlbnQoZSwgeyBjaGlsZHJlbkNoZWNrZWQ6IHNhdmVkQ2hlY2tlZFZhbHVlcy5jdXJyZW50ID8/IHRydWUgfSkpO1xuICAgICAgICB9Ki9cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IG5vdGlmeUNoZWNrZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlciwgY2hlY2tlZDogYm9vbGVhbiB8IFwibWl4ZWRcIikgPT4ge1xuICAgICAgICBpZiAoY2hlY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCFjaGVja2VkSW5kaWNlcy5jdXJyZW50LmhhcyhpbmRleCkpIHtcbiAgICAgICAgICAgICAgICBzZXRDaGVja2VkQ291bnQoYyA9PiAoYyArIDEpKTtcbiAgICAgICAgICAgICAgICBjaGVja2VkSW5kaWNlcy5jdXJyZW50LmFkZChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlZEluZGljZXMuY3VycmVudC5oYXMoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2hlY2tlZENvdW50KGMgPT4gKGMgLSAxKSk7XG4gICAgICAgICAgICAgICAgY2hlY2tlZEluZGljZXMuY3VycmVudC5kZWxldGUoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLyp1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgcGVyY2VudGFnZSA9IGNoZWNrZWRDb3VudCAvIG1hbmFnZWRDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHNldFNlbGZJc0NoZWNrZWQocGVyY2VudGFnZSA8PSAwID8gZmFsc2UgOiBwZXJjZW50YWdlID49IDEgPyB0cnVlIDogXCJtaXhlZFwiKVxuICAgIH0sIFtzZXRTZWxmSXNDaGVja2VkLCBtYW5hZ2VkQ2hpbGRyZW4ubGVuZ3RoLCBjaGVja2VkQ291bnRdKTsqL1xuXG4gICAgLypjb25zdCB1c2VDaGVja2JveEdyb3VwUGFyZW50UHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4pID0+IHtcbiAgICAgICAgcmV0dXJuIFxuICAgIH0sIFthcmlhQ29udHJvbHNdKTsqL1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0Q29udHJvbHMoQXJyYXkuZnJvbShhbGxJZHMuY3VycmVudCkuam9pbihcIiBcIikpO1xuICAgIH0sIFt1cGRhdGVJbmRleF0pXG5cbiAgICBjb25zdCB1c2VDaGVja2JveEdyb3VwQ2hpbGQ6IFVzZUNoZWNrYm94R3JvdXBDaGlsZDxJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4gPSB1c2VDYWxsYmFjazxVc2VDaGVja2JveEdyb3VwQ2hpbGQ8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+PihmdW5jdGlvbiAoeyBhc0NoZWNrYm94LCBhc0NoZWNrYm94R3JvdXBDaGlsZCB9KSB7XG4gICAgICAgIGRlYnVnTG9nKFwidXNlQ2hlY2tib3hHcm91cENoaWxkXCIsIGFzQ2hlY2tib3hHcm91cENoaWxkLm1hbmFnZWRDaGlsZC5pbmRleCwgYXNDaGVja2JveC5jaGVja2JveExpa2UuY2hlY2tlZCk7XG4gICAgICAgIGNvbnN0IHsgY2hlY2tib3g6IHsgb25DaGVja2VkQ2hhbmdlIH0sIGNoZWNrYm94TGlrZTogeyBjaGVja2VkLCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiB9LCBsYWJlbDogeyB0YWdJbnB1dCwgdGFnTGFiZWwgfSB9ID0gYXNDaGVja2JveDtcbiAgICAgICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXggfSB9ID0gYXNDaGVja2JveEdyb3VwQ2hpbGQ7XG4gICAgICAgIC8vbGFiZWxQb3NpdGlvbiA/Pz0gXCJzZXBhcmF0ZVwiO1xuICAgICAgICBjb25zdCBbZ2V0TGFzdFVzZXJDaGVja2VkLCBzZXRMYXN0VXNlckNoZWNrZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4gfCBcIm1peGVkXCI+KG51bGwsIHJldHVybkZhbHNlKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQsXG4gICAgICAgICAgICB1c2VDaGVja2JveExhYmVsRWxlbWVudCxcbiAgICAgICAgICAgIC4uLmNoZWNrYm94UmV0dXJuVHlwZVxuICAgICAgICB9ID0gdXNlQ2hlY2tib3g8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgICAgIGNoZWNrYm94OiB7XG4gICAgICAgICAgICAgICAgb25DaGVja2VkQ2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25DaGVja2VkQ2hhbmdlPj4oZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldExhc3RVc2VyQ2hlY2tlZChlW0V2ZW50RGV0YWlsXS5jaGVja2VkKTtcbiAgICAgICAgICAgICAgICAgICAgb25DaGVja2VkQ2hhbmdlPy4oZSBhcyBhbnkpO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoZWNrYm94TGlrZToge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIHRhZ0lucHV0LFxuICAgICAgICAgICAgICAgIHRhZ0xhYmVsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgbGFiZWw6IHsgaW5wdXRJZCwgbGFiZWxJZCB9IH0gPSBjaGVja2JveFJldHVyblR5cGU7XG5cbiAgICAgICAgLy9jb25zdCBnZXRDaGVja2VkID0gdXNlU3RhYmxlR2V0dGVyKGNoZWNrZWQpO1xuXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzSWQgPSAobGFiZWxQb3NpdGlvbiA9PSBcInNlcGFyYXRlXCIgPyBpbnB1dElkIDogbGFiZWxJZCkhO1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBhbGxJZHMuY3VycmVudC5hZGQoY29udHJvbHNJZCk7XG4gICAgICAgICAgICBzZXRJZFVwZGF0ZUluZGV4KGkgPT4gKytpKTtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBhbGxJZHMuY3VycmVudC5kZWxldGUoY29udHJvbHNJZCk7XG4gICAgICAgICAgICAgICAgc2V0SWRVcGRhdGVJbmRleChpID0+ICsraSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtjb250cm9sc0lkXSk7XG5cblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgbm90aWZ5Q2hlY2tlZChpbmRleCwgY2hlY2tlZCk7XG4gICAgICAgIH0sIFtpbmRleCwgY2hlY2tlZF0pO1xuXG4gICAgICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLCAuLi5saXN0TmF2aWdhdGlvblJldHVyblR5cGUgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoe1xuICAgICAgICAgICAgc3ViSW5mbzogeyBnZXRMYXN0VXNlckNoZWNrZWQsIG9uQ2hlY2tlZENoYW5nZSwgY2hlY2tlZCB9LFxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4uYXNDaGVja2JveEdyb3VwQ2hpbGQubGlzdE5hdmlnYXRpb24gfSxcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogYXNDaGVja2JveEdyb3VwQ2hpbGQubWFuYWdlZENoaWxkLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IGFzQ2hlY2tib3hHcm91cENoaWxkLnJvdmluZ1RhYkluZGV4XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGVja2JveExpa2U6IGNoZWNrYm94UmV0dXJuVHlwZS5jaGVja2JveExpa2UsXG4gICAgICAgICAgICBsYWJlbDogY2hlY2tib3hSZXR1cm5UeXBlLmxhYmVsLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IGxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgICAgIHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPElucHV0RWxlbWVudD4gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzKHByb3BzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQyID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMocmV0KSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxJbnB1dEVsZW1lbnQ+KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiID8gcmV0MiA6IHJldCkgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnRQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0MiA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvblByb3BzKHJldCBhcyBhbnkpIGFzIGFueSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChsYWJlbFBvc2l0aW9uID09IFwid3JhcHBpbmdcIiA/IHJldDIgOiByZXQpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlQ2hlY2tib3hHcm91cENoaWxkLFxuICAgICAgICB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXQsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBsaXN0UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBsaXN0UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICAgICAgY2hlY2tib3hHcm91cDoge1xuICAgICAgICAgICAgcGFyZW50SXNDaGVja2VkOiBnZXRTZWxmSXNDaGVja2VkVW5zdGFibGUoKSBhcyBib29sZWFuIHwgXCJtaXhlZFwiLFxuICAgICAgICAgICAgcGFyZW50UGVyY2VudENoZWNrZWQ6IChjaGVja2VkQ291bnQgLyAoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkgKyAxKSksXG4gICAgICAgIH1cbiAgICB9O1xufVxuIiwiXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCwgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIHVzZUZvY3VzVHJhcCwgdXNlTWVyZ2VkUHJvcHMsIHVzZVBhc3NpdmVTdGF0ZSwgdXNlUmFuZG9tSWQsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuaW50ZXJmYWNlIFNEUCB7XG4gICAgLyoqXG4gICAgICogTXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbGwgZWxlbWVudHMgdGhhdCBjb3VudCBhcyBcIndpdGhpblwiIHRoaXMgY29tcG9uZW50LlxuICAgICAqIFxuICAgICAqIFVzdWFsbHkganVzdCBhIHNpbmdsZSBlbGVtZW50LCBidXQgZS5nLiBhIE1lbnUgKyBNZW51QnV0dG9uIGNvdWxkIGhhdmUgdHdvLlxuICAgICAqL1xuICAgIGdldEVsZW1lbnRzOiAoKSA9PiBFbGVtZW50IHwgKEVsZW1lbnQgfCBudWxsKVtdIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGlzbWlzc2VkXG4gICAgICovXG4gICAgb25DbG9zZShyZWFzb246IFwiYmFja2Ryb3BcIiB8IFwiZXNjYXBlXCIgfCBcImxvc3QtZm9jdXNcIik6IHZvaWQ7XG5cbiAgICBvcGVuOiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgTVAge1xuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgdGhlIGJvZHkgZWxlbWVudCBwcm92aWRlZCBjb250YWlucyBwdXJlbHkgc2VtYW50aWMgY29udGVudFxuICAgICAqIHRoYXQgY2FuIGJlIHJlYWQgb3V0IGJ5IGEgc2NyZWVuIHJlYWRlciBpbiBvbmUgbG9uZywgdW5pbnRlcnJ1cHRlZCBzdHJldGNoLlxuICAgICAqIFxuICAgICAqIFRoaXMgc2hvdWxkIGJlIGZhbHNlIGlmIHRoZSBtb2RhbCBjb250YWlucywgZm9yIGV4YW1wbGUsIGEgbGlzdCBvciBvdGhlclxuICAgICAqIGludGVyYWN0aXZlIHdpZGdldHMsIGFuZCB0cnVlIGlmIGl0J3MgbW9zdGx5IHNob3J0LWZvcm0gdGV4dCBjb250ZW50LlxuICAgICAqIFxuICAgICAqIFRoZSBkZWZhdWx0IGlzIGZhbHNlIHRvIGJlIG9uIHRoZSBzYWZlIHNpZGUsIGJ1dCB0aGlzIHNob3VsZCBiZSB0cnVlIHdoZW5ldmVyIHJlYXNvbmFibGUuXG4gICAgICovXG4gICAgYm9keUlzT25seVNlbWFudGljPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYW55IG1vZGFsIGRpYWxvZyBvcGVucywgaXQgbXVzdCBzZW5kIGZvY3VzIHRvIHRoYXQgZGlhbG9nLCBpZGVhbGx5IHdoaWNoZXZlciBlbGVtZW50IG1ha2VzIHRoZSBtb3N0IHNlbnNlIGluIGNvbnRleHQuXG4gICAgICogXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIGl0J3MgYSBjb25maXJtYXRpb24gZGlhbG9nIGFib3V0IGRlbGV0aW5nIHNvbWV0aGluZywgaXQncyBiZXN0IHRvIHNlbmQgZm9jdXMgdG8gdGhlIFwiY2FuY2VsXCIgYnV0dG9uLlxuICAgICAqIFxuICAgICAqIEluIG90aGVyIGNhc2VzLCBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIGZvY3VzIHRoZSBkaWFsb2cncyB0aXRsZSwgZmlyc3QgaW50ZXJhY3RpdmUgZWxlbWVudCwgZXRjLlxuICAgICAqIFxuICAgICAqIEJ5IGRlZmF1bHQsIHdlIHRyeSB0byBwaWNrIGEgc2Vuc2libGUgZGVmYXVsdCAtLSBpZiB0aGUgZGlhbG9nIGNvbnRhaW5zIG9ubHkgZGVzY3JpcHRpdmUgY29udGVudCwgdGhlbiB3ZSBmb2N1cyB0aGUgYm9keS4gT3RoZXJ3aXNlIHdlIGZvY3VzIHRoZSB0aXRsZS5cbiAgICAgKiBcbiAgICAgKiAqKlBMRUFTRSoqIGNvbnNpZGVyIG92ZXJyaWRpbmcgdGhpcyB0byBwcm92aWRlIHRoZSBiZXN0IGV4cGVyaWVuY2UgZm9yIHlvdXIgZGlhbG9nLiAgWW91IHNob3VsZG4ndCBoYXZlIHRoYXQgbWFueSBtb2RhbCBkaWFsb2dzIGFueXdheSAtLSB0YWtlIHRoYXQgYml0IG9mIGV4dHJhIHRpbWUgaWYgeW91IGNhbi5cbiAgICAgKi9cbiAgICBmb2N1c1NlbGY/KCk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIFNvZnREaXNtaXNzT21pdHMgPSBrZXlvZiBTRFA7XG5leHBvcnQgdHlwZSBNb2RhbE9taXRzID0ga2V5b2YgTVA7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzPE9taXRzIGV4dGVuZHMgU29mdERpc21pc3NPbWl0cz4ge1xuICAgIHNvZnREaXNtaXNzOiBPbWl0PFNEUCwgT21pdHM+O1xuICAgIGFjdGl2ZUVsZW1lbnQ6IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1vZGFsUGFyYW1ldGVyczxNTyBleHRlbmRzIE1vZGFsT21pdHMsIFNETyBleHRlbmRzIFNvZnREaXNtaXNzT21pdHM+IGV4dGVuZHMgVXNlU29mdERpc21pc3NQYXJhbWV0ZXJzPFNETyB8IFwiZ2V0RWxlbWVudHNcIj4ge1xuICAgIG1vZGFsOiBPbWl0PE1QLCBNTz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB7XG4gICAgc29mdERpc21pc3M6IHtcbiAgICAgICAgb25CYWNrZHJvcENsaWNrOiAoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxhbnk+KSA9PiB2b2lkO1xuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlV2l0aEhvb2tzPFQgZXh0ZW5kcyBOb2RlPiBleHRlbmRzIFVzZVNvZnREaXNtaXNzUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKiBUaGlzIGJhc2ljYWxseSBjYW4gYmUgYW55IGVsZW1lbnQgLS0gaXQncyBvbmx5IHVzZWQgdG8gZ2V0IHRoZSBvd25pbmcgd2luZG93L2RvY3VtZW50LiAqL1xuICAgIHVzZVNvZnREaXNtaXNzUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xufVxuXG4vKipcbiAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIGEgbW9kYWwtbGlrZSBzb2Z0LWRpc21pc3MgaW50ZXJhY3Rpb24uXG4gKiBcbiAqIFRoYXQgaXMsIGFueSBjbGlja3Mgb3IgdGFwcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBjb21wb25lbnQsIFxuICogb3IgYW55IHRpbWUgdGhlIEVzY2FwZSBrZXkgaXMgcHJlc3NlZCB3aXRoaW4gdGhlIGNvbXBvbmVudCxcbiAqICh3aXRoIHZhcmlvdXMgYnJvd3NlciBvZGRpdGllcyByZWdhcmRpbmcgY2xpY2tzIG9uIGJsYW5rIG9yIGluZXJ0IGFyZWFzIGhhbmRsZWQpXG4gKiB0aGUgY29tcG9uZW50IHdpbGwgcmVxdWVzdCB0byBjbG9zZSBpdHNlbGYuXG4gKiBcbiAqIE9mIGNvdXJzZSwgaWYgeW91IGRvbid0IGRvIGFueXRoaW5nIGluIHRoZSBgb25DbG9zZWAgZnVuY3Rpb24sXG4gKiBpdCB3b24ndCBiZSBhIHNvZnQgZGlzbWlzcyBhbnltb3JlLlxuICogXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb2Z0RGlzbWlzczxUIGV4dGVuZHMgTm9kZT4oeyBzb2Z0RGlzbWlzczogeyBvbkNsb3NlLCBnZXRFbGVtZW50cywgb3BlbiB9LCBhY3RpdmVFbGVtZW50OiB7IG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIC4uLmFjdGl2ZUVsZW1lbnQgfSB9OiBVc2VTb2Z0RGlzbWlzc1BhcmFtZXRlcnM8bmV2ZXI+KTogVXNlU29mdERpc21pc3NSZXR1cm5UeXBlV2l0aEhvb2tzPFQ+IHtcblxuICAgIGNvbnN0IHN0YWJsZU9uQ2xvc2UgPSB1c2VTdGFibGVDYWxsYmFjayhvbkNsb3NlKTtcbiAgICBjb25zdCBzdGFibGVHZXRFbGVtZW50cyA9IHVzZVN0YWJsZUNhbGxiYWNrKGdldEVsZW1lbnRzKTtcbiAgICBjb25zdCBnZXRPcGVuID0gdXNlU3RhYmxlR2V0dGVyKG9wZW4pO1xuXG4gICAgY29uc3QgeyBnZXREb2N1bWVudCB9ID0gYWN0aXZlRWxlbWVudFxuXG4gICAgY29uc3Qgb25CYWNrZHJvcENsaWNrID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gb25CYWNrZHJvcENsaWNrKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8YW55Pikge1xuICAgICAgICBpZiAoIWdldE9wZW4oKSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XG5cbiAgICAgICAgLy8gQmFzaWNhbGx5LCBcIndhcyB0aGlzIGV2ZW50IGZpcmVkIG9uIHRoZSByb290LW1vc3QgZWxlbWVudCwgb3IgYXQgbGVhc3QgYW4gZWxlbWVudCBub3QgY29udGFpbmVkIGJ5IHRoZSBtb2RhbD9cIlxuICAgICAgICAvLyBFaXRoZXIgY291bGQgYmUgaG93IHRoZSBicm93c2VyIGhhbmRsZXMgdGhlc2Ugc29ydHMgb2YgXCJpbnRlcmFjdGluZyB3aXRoIG5vdGhpbmdcIiBldmVudHMuXG4gICAgICAgIGlmIChlLnRhcmdldCA9PSBkb2N1bWVudD8uZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBzdGFibGVPbkNsb3NlKFwiYmFja2Ryb3BcIik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZWxlbWVudHMgPSBzdGFibGVHZXRFbGVtZW50cygpO1xuXG4gICAgICAgIGlmIChlbGVtZW50cyAmJiBlLnRhcmdldCBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbGVtZW50cykpXG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuXG4gICAgICAgICAgICBsZXQgZm91bmRJbnNpZGVDbGljayA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZEluc2lkZUNsaWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWZvdW5kSW5zaWRlQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKFwiYmFja2Ryb3BcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IHsuLi5fdW51c2VkIH0gPSB1c2VBY3RpdmVFbGVtZW50KHtcbiAgICAgICAgLi4uYWN0aXZlRWxlbWVudCxcblxuICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygobmV3RWxlbWVudDogRWxlbWVudCwgcHJldjogRWxlbWVudCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZT8uKG5ld0VsZW1lbnQsIHByZXYpO1xuICAgICAgICAgICAgbGV0IHZhbGlkRm9jdXNhYmxlRWxlbWVudHMgPSBzdGFibGVHZXRFbGVtZW50cygpO1xuXG4gICAgICAgICAgICBpZiAodmFsaWRGb2N1c2FibGVFbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWxpZEZvY3VzYWJsZUVsZW1lbnRzKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRGb2N1c2FibGVFbGVtZW50cyA9IFt2YWxpZEZvY3VzYWJsZUVsZW1lbnRzXTtcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZm9jdXNhYmxlIG9mIHZhbGlkRm9jdXNhYmxlRWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzYWJsZT8uY29udGFpbnMobmV3RWxlbWVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvbkNsb3NlKFwibG9zdC1mb2N1c1wiKTtcbiAgICAgICAgfSwgW10pXG4gICAgfSk7XG5cblxuICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHtcbiAgICAgICAgb25FbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoZTogVCB8IG51bGwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZT8ub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIGNvbnN0IHdpbmRvdyA9IGRvY3VtZW50Py5kZWZhdWx0VmlldztcblxuICAgICAgICAgICAgLy8gU2luY2UgZXZlcnl0aGluZyBlbHNlIGlzIGluZXJ0LCB3ZSBsaXN0ZW4gZm9yIGNhcHR1cmVkIGNsaWNrcyBvbiB0aGUgd2luZG93XG4gICAgICAgICAgICAvLyAod2UgZG9uJ3QgdXNlIG9uQ2xpY2sgc2luY2UgdGhhdCBkb2Vzbid0IGZpcmUgd2hlbiBjbGlja2VkIG9uIGVtcHR5L2luZXJ0IGFyZWFzKVxuICAgICAgICAgICAgLy8gTm90ZTogV2UgbmVlZCBhICpzZXBhcmF0ZSogdG91Y2ggZXZlbnQgb24gbW9iaWxlIFNhZmFyaSwgYmVjYXVzZVxuICAgICAgICAgICAgLy8gaXQgZG9lc24ndCBsZXQgY2xpY2sgZXZlbnRzIGJ1YmJsZSBvciBiZSBjYXB0dXJlZCBmcm9tIHRyYWRpdGlvbmFsbHkgbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLFxuICAgICAgICAgICAgLy8gYnV0IHRvdWNoIGV2ZW50cyB3b3JrIGFzIGV4cGVjdGVkLlxuICAgICAgICAgICAgY29uc3QgbW91c2VEb3duID0gKGU6IE1vdXNlRXZlbnQpID0+IHsgaWYgKGdldE9wZW4oKSkgb25CYWNrZHJvcENsaWNrKGUpOyB9O1xuICAgICAgICAgICAgY29uc3QgdG91Y2hTdGFydCA9IChlOiBUb3VjaEV2ZW50KSA9PiB7IGlmIChnZXRPcGVuKCkpIG9uQmFja2Ryb3BDbGljayhlKTsgfTtcbiAgICAgICAgICAgIGNvbnN0IGtleURvd24gPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4geyBpZiAoZS5rZXkgPT09IFwiRXNjYXBlXCIpIHsgc3RhYmxlT25DbG9zZShcImVzY2FwZVwiKTsgfSB9O1xuXG4gICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VEb3duLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRvdWNoU3RhcnQsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5RG93bik7XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG1vdXNlRG93bik7XG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0b3VjaFN0YXJ0KTtcbiAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtleURvd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSlcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVNvZnREaXNtaXNzUHJvcHM6IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPiA9PiAodXNlUmVmRWxlbWVudFByb3BzKHByb3BzKSksIFtdKSxcbiAgICAgICAgc29mdERpc21pc3M6IHtcbiAgICAgICAgICAgIG9uQmFja2Ryb3BDbGljayxcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNb2RhbFJldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB7XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNb2RhbFJldHVyblR5cGVXaXRoSG9va3M8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTW9kYWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZU1vZGFsUmV0dXJuVHlwZUluZm8ge1xuICAgIHVzZU1vZGFsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TW9kYWxFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TW9kYWxFbGVtZW50PjtcbiAgICB1c2VNb2RhbFRpdGxlOiBVc2VNb2RhbFRpdGxlPFRpdGxlRWxlbWVudD47XG4gICAgdXNlTW9kYWxCb2R5OiBVc2VNb2RhbEJvZHk8Qm9keUVsZW1lbnQ+XG4gICAgdXNlTW9kYWxCYWNrZHJvcDogVXNlTW9kYWxCYWNrZHJvcDxCYWNrZHJvcEVsZW1lbnQ+O1xuICAgIHVzZU1vZGFsRm9jdXNDb250YWluZXJQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rm9jdXNDb250YWluZXJFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD47XG4gICAgLy9zb2Z0RGlzbWlzczogT21pdDxVc2VTb2Z0RGlzbWlzc1JldHVyblR5cGU8TW9kYWxFbGVtZW50PltcInNvZnREaXNtaXNzXCJdLCBcInVzZVNvZnREaXNtaXNzUHJvcHNcIj47XG59XG5cbmV4cG9ydCB0eXBlIFVzZU1vZGFsVGl0bGU8VGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZU1vZGFsVGl0bGVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+OyB9O1xuZXhwb3J0IHR5cGUgVXNlTW9kYWxCb2R5PEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoKSA9PiB7IHVzZU1vZGFsQm9keVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+OyB9O1xuZXhwb3J0IHR5cGUgVXNlTW9kYWxCYWNrZHJvcDxCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9ICgpID0+IHsgdXNlTW9kYWxCYWNrZHJvcFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD47IH07XG5cbi8qKlxuICogQSBnZW5lcmljIG1vZGFsIGhvb2ssIHVzZWQgYnkgbW9kYWwgZGlhbG9ncywgYnV0IGNhbiBhbHNvXG4gKiBiZSB1c2VkIGJ5IGFueXRoaW5nIHRoYXQncyBtb2RhbCB3aXRoIGEgYmFja2Ryb3AuXG4gKiBAcGFyYW0gcGFyYW0wIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNb2RhbDxGb2N1c0NvbnRhaW5lckVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTW9kYWxFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBtb2RhbDogeyBib2R5SXNPbmx5U2VtYW50aWM6IGRlc2NyaXB0aXZlLCBmb2N1c1NlbGYgfSwgc29mdERpc21pc3M6IHsgb25DbG9zZSwgb3BlbiB9LCBhY3RpdmVFbGVtZW50IH06IFVzZU1vZGFsUGFyYW1ldGVyczxuZXZlciwgbmV2ZXI+KTogVXNlTW9kYWxSZXR1cm5UeXBlV2l0aEhvb2tzPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgTW9kYWxFbGVtZW50LCBUaXRsZUVsZW1lbnQsIEJvZHlFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQ+IHtcblxuICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VUaXRsZVJlZkVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudDogZ2V0VGl0bGVFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PFRpdGxlRWxlbWVudD4oe30pO1xuICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VCb2R5UmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50OiBnZXRCb2R5RWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudDxCb2R5RWxlbWVudD4oe30pO1xuICAgIGZvY3VzU2VsZiA/Pz0gKCgpID0+IHtcbiAgICAgICAgaWYgKGRlc2NyaXB0aXZlKSB7XG4gICAgICAgICAgICBnZXRCb2R5RWxlbWVudCgpPy5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0aXRsZUVsZW1lbnQgPSBnZXRUaXRsZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aXRsZUVsZW1lbnQpXG4gICAgICAgICAgICAgICAgdGl0bGVFbGVtZW50LmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcblxuICAgICAgICB9XG4gICAgICAgIC8vY29uc3QgZWxlbWVudFRvRm9jdXMgPSBnZXRUaXRsZUVsZW1lbnQoKSA/PyBnZXRCb2R5RWxlbWVudCgpXG4gICAgfSk7XG4gICAgY29uc3Qgc3RhYmxlT25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UpO1xuICAgIGNvbnN0IHN0YWJsZUZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKGZvY3VzU2VsZik7XG5cbiAgICAvL2NvbnN0IFttb2RhbERlc2NyaWJlZEJ5Qm9keSwgc2V0TW9kYWxEZXNjcmliZWRCeUJvZHldID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHVzZUhpZGVTY3JvbGwob3Blbik7XG5cbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudDogdXNlTW9kYWxJZEFzU291cmNlLCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50OiB1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudCB9ID0gdXNlUmFuZG9tSWQ8TW9kYWxFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLW1vZGFsLVwiIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogbnVsbCB9IH0pO1xuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50OiB1c2VCb2R5SWRBc1NvdXJjZSwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlQm9keUlkUmVmZXJlbmNlckVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkPEJvZHlFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLW1vZGFsLWJvZHktXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQ6IHVzZVRpdGxlSWRBc1NvdXJjZSwgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDogdXNlVGl0bGVJZFJlZmVyZW5jZXJFbGVtZW50IH0gPSB1c2VSYW5kb21JZDxUaXRsZUVsZW1lbnQ+KHsgcmFuZG9tSWQ6IHsgcHJlZml4OiBcImFyaWEtbW9kYWwtdGl0bGUtXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XG5cblxuICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VNb2RhbFJlZkVsZW1lbnQsIGdldEVsZW1lbnQ6IGdldE1vZGFsRWxlbWVudCB9ID0gdXNlUmVmRWxlbWVudDxNb2RhbEVsZW1lbnQ+KHt9KVxuICAgIGNvbnN0IHsgc29mdERpc21pc3M6IHsgb25CYWNrZHJvcENsaWNrIH0sIHVzZVNvZnREaXNtaXNzUHJvcHMgfSA9IHVzZVNvZnREaXNtaXNzPE1vZGFsRWxlbWVudD4oeyBzb2Z0RGlzbWlzczogeyBvbkNsb3NlOiBzdGFibGVPbkNsb3NlLCBnZXRFbGVtZW50czogZ2V0TW9kYWxFbGVtZW50LCBvcGVuOiAhIW9wZW4gfSwgYWN0aXZlRWxlbWVudCB9KTtcblxuICAgIGNvbnN0IHVzZU1vZGFsQmFja2Ryb3AgPSB1c2VDYWxsYmFjazxVc2VNb2RhbEJhY2tkcm9wPEJhY2tkcm9wRWxlbWVudD4+KGZ1bmN0aW9uIHVzZU1vZGFsQmFja2Ryb3AoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHVzZU1vZGFsQmFja2Ryb3BQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8QmFja2Ryb3BFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4ge1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEJhY2tkcm9wRWxlbWVudD4oeyBvblBvaW50ZXJVcDogb25CYWNrZHJvcENsaWNrIH0sIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZU1vZGFsQmFja2Ryb3BQcm9wcyB9XG4gICAgfSwgW10pXG5cbiAgICBjb25zdCB1c2VNb2RhbEZvY3VzQ29udGFpbmVyUHJvcHMgPSBmdW5jdGlvbiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+IHtcbiAgICAgICAgY29uc3QgeyB1c2VGb2N1c1RyYXBQcm9wcyB9ID0gdXNlRm9jdXNUcmFwPEZvY3VzQ29udGFpbmVyRWxlbWVudD4oeyB0cmFwQWN0aXZlOiBvcGVuIH0pO1xuICAgICAgICByZXR1cm4gdXNlRm9jdXNUcmFwUHJvcHMocHJvcHMpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZU1vZGFsUHJvcHMgPSBmdW5jdGlvbiAoeyBcImFyaWEtbW9kYWxcIjogYXJpYU1vZGFsLCByb2xlLCAuLi5wMCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxNb2RhbEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TW9kYWxFbGVtZW50PiB7XG4gICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHM6IHVzZU1vZGFsSWRBc1NvdXJjZVByb3BzIH0gPSB1c2VNb2RhbElkQXNTb3VyY2UoKTtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZVRpdGxlSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIH0gPSB1c2VUaXRsZUlkUmVmZXJlbmNlckVsZW1lbnQ8TW9kYWxFbGVtZW50PihcImFyaWEtbGFiZWxsZWRieVwiIGFzIG5ldmVyKTtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZUJvZHlJZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgfSA9IHVzZUJvZHlJZFJlZmVyZW5jZXJFbGVtZW50PE1vZGFsRWxlbWVudD4oXCJhcmlhLWRlc2NyaWJlZGJ5XCIgYXMgbmV2ZXIpO1xuICAgICAgICBjb25zb2xlLmFzc2VydCghYXJpYU1vZGFsKTtcbiAgICAgICAgY29uc3QgeyB1c2VGb2N1c1RyYXBQcm9wcyB9ID0gdXNlRm9jdXNUcmFwPE1vZGFsRWxlbWVudD4oeyB0cmFwQWN0aXZlOiBvcGVuIH0pO1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9wZW4pXG4gICAgICAgICAgICAgICAgc3RhYmxlRm9jdXNTZWxmKCk7XG4gICAgICAgIH0sIFtvcGVuXSlcbiAgICAgICAgY29uc3QgcDEgPSB1c2VCb2R5SWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKHAwKTtcbiAgICAgICAgY29uc3QgcDIgPSB1c2VNb2RhbElkQXNTb3VyY2VQcm9wcyhwMSk7XG4gICAgICAgIGNvbnN0IHBGaW5hbCA9IHVzZVRpdGxlSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKHAyKTtcbiAgICAgICAgcmV0dXJuIHVzZUZvY3VzVHJhcFByb3BzKHVzZVNvZnREaXNtaXNzUHJvcHModXNlTWVyZ2VkUHJvcHM8TW9kYWxFbGVtZW50Pih1c2VNb2RhbFJlZkVsZW1lbnQoeyByb2xlOiByb2xlIHx8IFwiZGlhbG9nXCIgfSksIGRlc2NyaXB0aXZlID8gcEZpbmFsIDogcDIpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlTW9kYWxUaXRsZSA9IHVzZUNhbGxiYWNrPFVzZU1vZGFsVGl0bGU8VGl0bGVFbGVtZW50Pj4oZnVuY3Rpb24gdXNlTW9kYWxUaXRsZSgpIHtcblxuICAgICAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzOiB1c2VUaXRsZUlkQXNTb3VyY2VQcm9wcyB9ID0gdXNlVGl0bGVJZEFzU291cmNlKCk7XG4gICAgICAgIGNvbnN0IHVzZU1vZGFsVGl0bGVQcm9wcyA9IGZ1bmN0aW9uIChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGl0bGVFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD4ge1xuICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPz89IC0xO1xuICAgICAgICAgICAgcmV0dXJuIHVzZVRpdGxlUmVmRWxlbWVudFByb3BzKHVzZVRpdGxlSWRBc1NvdXJjZVByb3BzKHByb3BzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB1c2VNb2RhbFRpdGxlUHJvcHMgfTtcbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IHVzZU1vZGFsQm9keSA9IHVzZUNhbGxiYWNrPFVzZU1vZGFsQm9keTxCb2R5RWxlbWVudD4+KGZ1bmN0aW9uIHVzZU1vZGFsQm9keSgpIHtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wczogdXNlQm9keUlkQXNTb3VyY2VQcm9wcyB9ID0gdXNlQm9keUlkQXNTb3VyY2UoKTtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHM6IHVzZU1vZGFsSWRBc1JlZmVyZW5jZXJFbGVtZW50UHJvcHMgfSA9IHVzZU1vZGFsSWRBc1JlZmVyZW5jZXJFbGVtZW50PEJvZHlFbGVtZW50PihcImRhdGEtbW9kYWwtaWRcIiBhcyBuZXZlcik7XG5cbiAgICAgICAgY29uc3QgdXNlTW9kYWxCb2R5UHJvcHMgPSBmdW5jdGlvbiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlFbGVtZW50PiB7XG4gICAgICAgICAgICBwcm9wcy50YWJJbmRleCA/Pz0gLTE7XG4gICAgICAgICAgICByZXR1cm4gdXNlQm9keVJlZkVsZW1lbnRQcm9wcyh1c2VCb2R5SWRBc1NvdXJjZVByb3BzKHVzZU1vZGFsSWRBc1JlZmVyZW5jZXJFbGVtZW50UHJvcHMocHJvcHMpKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB1c2VNb2RhbEJvZHlQcm9wcyB9O1xuICAgIH0sIFtdKVxuXG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZU1vZGFsUHJvcHMsXG4gICAgICAgIHVzZU1vZGFsVGl0bGUsXG4gICAgICAgIHVzZU1vZGFsQm9keSxcbiAgICAgICAgdXNlTW9kYWxCYWNrZHJvcCxcbiAgICAgICAgdXNlTW9kYWxGb2N1c0NvbnRhaW5lclByb3BzLFxuICAgICAgICBzb2Z0RGlzbWlzczogeyBvbkJhY2tkcm9wQ2xpY2sgfVxuICAgIH07XG59XG5cblxuLyoqXG4gKiBBbGxvd3MgZm9yIGhpZGluZyB0aGUgc2Nyb2xsIGJhciBvZiB0aGUgcm9vdCBIVE1MIGVsZW1lbnRcbiAqIHdpdGhvdXQgc2hpZnRpbmcgdGhlIGxheW91dCBvZiB0aGUgcGFnZSBtb3JlIHRoYW4gYWRkaW5nIGEgZm93IHBpeGVsc1xuICogb2YgcGFkZGluZyB0byB0aGUgcm9vdCBlbGVtZW50IGlmIG5lY2Vzc2FyeS5cbiAqIEBwYXJhbSBoaWRlU2Nyb2xsIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSGlkZVNjcm9sbChoaWRlU2Nyb2xsOiBib29sZWFuKSB7XG4gICAgY29uc3QgW2dldFNjcm9sbGJhcldpZHRoLCBzZXRTY3JvbGxiYXJXaWR0aF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW2dldFNjcm9sbGJhckhlaWdodCwgc2V0U2Nyb2xsYmFySGVpZ2h0XSA9IHVzZVBhc3NpdmVTdGF0ZTxudW1iZXIgfCBudWxsPihudWxsKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChoaWRlU2Nyb2xsKSB7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIGlzIHJlc3VtZWQsIHdlJ2xsIG5lZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgc2Nyb2xsIHBvc2l0aW9uc1xuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBrZWVwIHRoaXMgaW5mb3JtYXRpb24gYXJvdW5kXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNjcm9sbFRvcCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNjcm9sbExlZnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgLy8gTWVhc3VyZSB0aGUgd2lkdGggb2YgdGhlIHBhZ2UgKG1pbnVzIHRoZSBzY3JvbGxiYXIpXG4gICAgICAgICAgICBjb25zdCB3aWR0aFdpdGhTY3JvbGxCYXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHRXaXRoU2Nyb2xsQmFyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodDtcblxuICAgICAgICAgICAgLy8gQXBwbHkgYSBjbGFzcyB0aGF0IGhpZGVzIHRoZSBzY3JvbGxiYXIuXG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImRvY3VtZW50LXNjcm9sbC1oaWRkZW5cIik7XG5cbiAgICAgICAgICAgIC8vIEluIGNhc2UgbXVsdGlwbGUgdGhpbmdzIGFyZSBsb2NraW5nIHNjcm9sbCwga2VlcCB0cmFjayBvZiBob3cgbWFueSBhcmUgZG9pbmcgdGhhdFxuICAgICAgICAgICAgLy8gKGp1c3QgYWRkIDEgb24gZW5hYmxlLCBzdWJ0cmFjdCAxIG9uIGRpc2FibGUpXG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSA9ICgrKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdIHx8IFwiMFwiKSArIDEpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIC8vIE1lYXN1cmUgdGhlIG5ldyB3aWR0aCB3aXRob3V0IGEgc2Nyb2xsYmFyIFxuICAgICAgICAgICAgLy8gc28gd2UgY2FuIHRha2UgdGhlIGRpZmZlcmVuY2UgYXMgdGhlIHNjcm9sbGJhciB3aWR0aC5cbiAgICAgICAgICAgIGNvbnN0IHdpZHRoV2l0aG91dFNjcm9sbEJhciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodFdpdGhvdXRTY3JvbGxCYXIgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgbGV0IHNjcm9sbGJhcldpZHRoID0gKHdpZHRoV2l0aG91dFNjcm9sbEJhciAtIHdpZHRoV2l0aFNjcm9sbEJhcik7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsYmFySGVpZ2h0ID0gKGhlaWdodFdpdGhvdXRTY3JvbGxCYXIgLSBoZWlnaHRXaXRoU2Nyb2xsQmFyKTtcblxuICAgICAgICAgICAgLy8gRmFpbHNhZmUgLS0gaWYgdGhpcyBtZWFzdXJpbmcgdHJpY2sgZG9lcyBzb21ldGhpbmcgdW5leHBlY3RlZCwganVzdCBpZ25vcmUgaXRcbiAgICAgICAgICAgIGlmIChzY3JvbGxiYXJXaWR0aCA+IDgwKVxuICAgICAgICAgICAgICAgIHNjcm9sbGJhcldpZHRoID0gMDtcbiAgICAgICAgICAgIGlmIChzY3JvbGxiYXJIZWlnaHQgPiA4MClcbiAgICAgICAgICAgICAgICBzY3JvbGxiYXJIZWlnaHQgPSAwO1xuXG4gICAgICAgICAgICAvLyBNYWtlIG91ciBtZWFzdXJlbWVudHMgYXZhaWxhYmxlIGFzIENTUyBwcm9wZXJ0aWVzIGZvciBnZW5lcmFsIHVzZVxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1yb290LXNjcm9sbGJhci13aWR0aFwiLCBgJHtzY3JvbGxiYXJXaWR0aH1weGApO1xuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KFwiLS1yb290LXNjcm9sbGJhci1oZWlnaHRcIiwgYCR7c2Nyb2xsYmFySGVpZ2h0fXB4YCk7XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoXCItLXJvb3Qtc2Nyb2xsc3RvcC10b3BcIiwgYCR7b3JpZ2luYWxTY3JvbGxUb3B9cHhgKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcm9vdC1zY3JvbGxzdG9wLWxlZnRcIiwgYCR7b3JpZ2luYWxTY3JvbGxMZWZ0fXB4YCk7XG5cbiAgICAgICAgICAgIHNldFNjcm9sbGJhcldpZHRoKHNjcm9sbGJhcldpZHRoKTtcbiAgICAgICAgICAgIHNldFNjcm9sbGJhckhlaWdodChzY3JvbGxiYXJIZWlnaHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFVuZG8gYWxsIHRoZSB0aGluZ3Mgd2UganVzdCBkaWRcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldFtcInNjcm9sbEhpZGVyc1wiXSA9ICgrKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdIHx8IFwiMFwiKSAtIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0W1wic2Nyb2xsSGlkZXJzXCJdID09IFwiMFwiKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSB0aGUgbGFzdCBzY3JvbGwtbG9ja2luZyB0aGluZyB0byBzdG9wLCB0aGVuIHJlbW92ZSB0aGUgY2xhc3MgdGhhdCBzdG9wcyBzY3JvbGxpbmcuXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXNjcm9sbC1oaWRlcnNcIik7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKFwiZG9jdW1lbnQtc2Nyb2xsLWhpZGRlblwiKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBbHNvLCByZXN0b3JlIHRoZSBvcmlnaW5hbCBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBieSBmb3JjaW5nIHRoZSBzY3JvbGwgYmVoYXZpb3IgdG8gbm90IGJlIHNtb290aFxuICAgICAgICAgICAgICAgICAgICAvLyAoaXQncyBpbnN0YW50IGlmIG5vdGhpbmcgaXMgc2V0IHRvIHNtb290aCwgaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzc29tLXZpZXcvI3Njcm9sbGluZyksXG4gICAgICAgICAgICAgICAgICAgIC8vIHNjcm9sbGluZywgdGhlbiByZXN0b3JpbmcgdGhlIG9yaWdpbmFsIHNjcm9sbCBiZWhhdmlvciBcbiAgICAgICAgICAgICAgICAgICAgLy8gKHdoaWNoIHdhcyBwcm9iYWJseSBhbHJlYWR5IGF1dG8gYW55d2F5LCBidXQganVzdCB0byBiZSBzYWZlKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNjcm9sbEJlaGF2aW9yID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBcImF1dG9cIjtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvKHsgdG9wOiBvcmlnaW5hbFNjcm9sbFRvcCwgbGVmdDogb3JpZ2luYWxTY3JvbGxMZWZ0LCBiZWhhdmlvcjogXCJhdXRvXCIgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9IG9yaWdpbmFsU2Nyb2xsQmVoYXZpb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9LCBbaGlkZVNjcm9sbF0pO1xuXG4gICAgcmV0dXJuIHsgZ2V0U2Nyb2xsYmFyV2lkdGgsIGdldFNjcm9sbGJhckhlaWdodCB9O1xufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzLCB1c2VSYW5kb21JZCwgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb24sIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZGVidWdMb2csIEVsZW1lbnRUb1RhZywgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCwgd2Fybk9uT3ZlcndyaXRlIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUxhYmVsLCBVc2VMYWJlbFJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWxhYmVsXCI7XG5cbmV4cG9ydCB0eXBlIExpc3Rib3hTaW5nbGVTZWxlY3RFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0geyBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IG51bWJlciB9IH0gJiBQaWNrPGguSlNYLlRhcmdldGVkRXZlbnQ8RT4sIFwidGFyZ2V0XCIgfCBcImN1cnJlbnRUYXJnZXRcIj47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxuZXZlciB8IFwib25TZWxlY3RlZEluZGV4Q2hhbmdlXCIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4ge1xuICAgIGxpc3Rib3hTaW5nbGU6IHtcbiAgICAgICAgLy9zZWxlY3Rpb25Nb2RlOiBcImZvY3VzXCIgfCBcImFjdGl2YXRlXCI7XG4gICAgICAgIG9uU2VsZWN0PyhldmVudDogTGlzdGJveFNpbmdsZVNlbGVjdEV2ZW50PEVsZW1lbnQ+KTogdm9pZDtcbiAgICAgICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xuICAgICAgICB0YWdMaXN0OiBFbGVtZW50VG9UYWc8TGlzdEVsZW1lbnQ+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxFLCB7fSwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiwgXCJzdWJJbmZvXCI+IHtcbiAgICBsaXN0Ym94U2luZ2xlSXRlbTogeyBkaXNhYmxlZD86IGJvb2xlYW47IH1cbiAgICBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEU+O1xufVxuXG5cblxuZXhwb3J0IHR5cGUgVXNlTGlzdGJveFNpbmdsZUl0ZW08TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAoaW5mbzogVXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzPExpc3RJdGVtRWxlbWVudD4pID0+IFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxMaXN0SXRlbUVsZW1lbnQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiB7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZUl0ZW1SZXR1cm5UeXBlV2l0aEhvb2tzPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdGJveFNpbmdsZUl0ZW1SZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+IHtcbiAgICB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RJdGVtRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RJdGVtRWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4sIFVzZUxhYmVsUmV0dXJuVHlwZUluZm8ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVXaXRoSG9va3M8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3Rib3hTaW5nbGVSZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+IHtcbiAgICB1c2VMaXN0Ym94U2luZ2xlSXRlbTogVXNlTGlzdGJveFNpbmdsZUl0ZW08TGlzdEl0ZW1FbGVtZW50PjtcbiAgICB1c2VMaXN0Ym94U2luZ2xlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD47XG4gICAgdXNlTGlzdGJveFNpbmdsZUxhYmVsOiAoKSA9PiB7IHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGU8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbGlzdGJveFNpbmdsZTogeyB0YWdMYWJlbCwgdGFnTGlzdCwgb25TZWxlY3QsIC4uLl9sYnMgfSxcbiAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWRJbmRleCwgLi4uc3MgfSxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxuIH0sXG4gICAgbGlzdE5hdmlnYXRpb246IHsgLi4ubHMgfSxcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4ubWMgfSxcbiAgICByb3ZpbmdUYWJJbmRleDogeyAuLi5ydGkgfSxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IC4uLnRuIH0sXG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IHsgLi4uY2hmIH1cbn06IFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+KTogVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVXaXRoSG9va3M8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50PiB7XG4gICAgZGVidWdMb2coXCJ1c2VMaXN0Ym94U2luZ2xlXCIsIHNlbGVjdGVkSW5kZXgpO1xuXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0LCB1c2VMYWJlbExhYmVsLCAuLi5sYWJlbFJldHVyblR5cGUgfSA9IHVzZUxhYmVsPExpc3RFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICAgIHByZWZpeExhYmVsOiBcImFyaWEtbGlzdGJveC1sYWJlbC1cIixcbiAgICAgICAgICAgIHByZWZpeElucHV0OiBcImFyaWEtbGlzdGJveC1cIixcbiAgICAgICAgICAgIHRhZ0lucHV0OiB0YWdMaXN0LFxuICAgICAgICAgICAgdGFnTGFiZWw6IHRhZ0xhYmVsXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG9uU2VsZWN0ZWRJbmRleENoYW5nZSA9IHVzZVN0YWJsZUNhbGxiYWNrKChldmVudDogRXZlbnQsIG5ld0luZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgc3RhYmxlT25TZWxlY3QoZW5oYW5jZUV2ZW50PExpc3RJdGVtRWxlbWVudCwgRXZlbnQsIHsgc2VsZWN0ZWRJbmRleDogbnVtYmVyIH0+KGV2ZW50LCB7IHNlbGVjdGVkSW5kZXg6IG5ld0luZGV4IH0pKVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzLCAuLi5saXN0UmV0dXJuVHlwZSB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwge30sIG5ldmVyPih7XG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IC4uLmNoZiB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IC4uLmxuIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmxzIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyAuLi5tYyB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgLi4ucnRpXG4gICAgICAgIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyAuLi5zcywgb25TZWxlY3RlZEluZGV4Q2hhbmdlLCBzZWxlY3RlZEluZGV4IH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuXG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHMgfSA9IHVzZUxhYmVsSW5wdXQoKTtcbiAgICBjb25zdCBzdGFibGVPblNlbGVjdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uU2VsZWN0ID8/ICgoKSA9PiB7IH0pKTtcblxuXG4gICAgY29uc3QgdXNlTGlzdGJveFNpbmdsZUl0ZW0gPSB1c2VDYWxsYmFjazxVc2VMaXN0Ym94U2luZ2xlSXRlbTxMaXN0SXRlbUVsZW1lbnQ+PigoeyBsaXN0Ym94U2luZ2xlSXRlbTogeyBkaXNhYmxlZCB9LCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgaGFzRm9jdXMgfSkgPT4ge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZUxpc3Rib3hTaW5nbGVJdGVtXCIsIG1hbmFnZWRDaGlsZC5pbmRleCk7XG4gICAgICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXg6IHJ0aV9yZXQsIHNpbmdsZVNlbGVjdGlvbjogc3NfcmV0LCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkLFxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb24sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgICAgIGhhc0ZvY3VzLFxuICAgICAgICAgICAgc3ViSW5mbzoge31cbiAgICAgICAgfSk7XG4gICAgICAgIC8vY29uc3QgaW5kZXggPSBtYW5hZ2VkQ2hpbGQuaW5kZXg7XG5cbiAgICAgICAgLyp1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHJ0aV9yZXQuZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgcnRpX3JldC50YWJiYWJsZSAmJiBzZWxlY3Rpb25Nb2RlID09IFwiZm9jdXNcIikge1xuICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyB0YXJnZXQ6IGVsZW1lbnQsIGN1cnJlbnRUYXJnZXQ6IGVsZW1lbnQsIFtFdmVudERldGFpbF06IHsgc2VsZWN0ZWRJbmRleDogaW5kZXggfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3J0aV9yZXQudGFiYmFibGUsIHNlbGVjdGlvbk1vZGUsIGluZGV4XSk7Ki9cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfcmV0LFxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiBzc19yZXRcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0SXRlbUVsZW1lbnQ+Pihwcm9wczogUCkge1xuICAgICAgICAgICAgLypjb25zdCBuZXdQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEl0ZW1FbGVtZW50PiA9IHVzZVByZXNzRXZlbnRIYW5kbGVyczxMaXN0SXRlbUVsZW1lbnQ+KGRpc2FibGVkID8gbnVsbCA6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHJ0aV9yZXQuZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBzdGFibGVPblNlbGVjdD8uKHsgdGFyZ2V0OiBlbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBlbGVtZW50LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkSW5kZXg6IGluZGV4IH0gfSk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSwgdW5kZWZpbmVkKTsqL1xuXG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJvcHRpb25cIjtcbiAgICAgICAgICAgIC8vcHJvcHNbXCJhcmlhLXNldHNpemVcIl0gPSAoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkgKyAxKS50b1N0cmluZygpO1xuICAgICAgICAgICAgLy9wcm9wc1tcImFyaWEtcG9zaW5zZXRcIl0gPSAoaW5mby5pbmRleCArIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBwcm9wc1tcImFyaWEtc2VsZWN0ZWRcIl0gPSAoc3NfcmV0LnNlbGVjdGVkID8/IGZhbHNlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHByb3BzW1wiYXJpYS1kaXNhYmxlZFwiXSA9IFwidHJ1ZVwiO1xuXG4gICAgICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzKHByb3BzKTtcbiAgICAgICAgfVxuICAgIH0sIFt1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkXSk7XG5cblxuICAgIGNvbnN0IHVzZUxpc3Rib3hTaW5nbGVMYWJlbCA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCgpIHtcbiAgICAgICAgZnVuY3Rpb24gdXNlTGlzdGJveFNpbmdsZUxhYmVsUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlTGFiZWxMYWJlbFByb3BzIH0gPSB1c2VMYWJlbExhYmVsKCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlTGFiZWxMYWJlbFByb3BzKHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzIH07XG4gICAgfSwgW3VzZUxhYmVsTGFiZWxdKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZUl0ZW0sXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVQcm9wcyxcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZUxhYmVsLFxuICAgICAgICAuLi5saXN0UmV0dXJuVHlwZSxcbiAgICAgICAgLi4ubGFiZWxSZXR1cm5UeXBlXG4gICAgICAgIC8qbGFiZWw6IGxhYmVsUmV0dXJuVHlwZS5sYWJlbCxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IGxpc3RSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IGxpc3RSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IGxpc3RSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uKi9cbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiB1c2VMaXN0Ym94U2luZ2xlUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50Pikge1xuICAgICAgICBwcm9wcy5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHVzZUxhYmVsSW5wdXRQcm9wcyhwcm9wcykpO1xuICAgIH1cbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0Ym94R3JvdXA8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEhlYWRpbmdFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oKSB7XG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50LCB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkPEhlYWRpbmdFbGVtZW50Pih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJsaXN0Ym94LW11bHRpLWdyb3VwXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7fSB9KTtcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkU291cmNlRWxlbWVudFByb3BzIH0gPSB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQoKTtcbiAgICBjb25zdCB7IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudDxDb250YWluZXJFbGVtZW50PihcImFyaWEtbGFiZWxsZWRieVwiKTtcbiAgICBjb25zdCB1c2VMaXN0Ym94R3JvdXBIZWFkaW5nUHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRpbmdFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhlYWRpbmdFbGVtZW50PiA9PiB7XG4gICAgICAgIHJldHVybiB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyhwcm9wcyk7XG4gICAgfTtcbiAgICBjb25zdCB1c2VMaXN0Ym94R3JvdXBDb250YWluZXJQcm9wcyA9ICh7IHJvbGUsIC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENvbnRhaW5lckVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyRWxlbWVudD4gPT4ge1xuICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzKHtcbiAgICAgICAgICAgIHJvbGU6IHdhcm5Pbk92ZXJ3cml0ZShcInVzZUxpc3Rib3hNdWx0aUdyb3VwUHJvcHNcIiwgXCJyb2xlXCIsIHJvbGUsIFwiZ3JvdXBcIiksXG4gICAgICAgICAgICAuLi5wcm9wc1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZUxpc3Rib3hHcm91cENvbnRhaW5lclByb3BzLFxuICAgICAgICB1c2VMaXN0Ym94R3JvdXBIZWFkaW5nUHJvcHMsXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE9uVGFiYmFibGVJbmRleENoYW5nZSwgcmV0dXJuRmFsc2UsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8sIHVzZU1lcmdlZFByb3BzLCB1c2VQYXNzaXZlU3RhdGUsIHVzZVByZXNzLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZywgRWxlbWVudFRvVGFnLCBFdmVudERldGFpbCB9IGZyb20gXCIuL3Byb3BzXCI7XG5pbXBvcnQgeyB1c2VMYWJlbCB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xuXG5leHBvcnQgdHlwZSBMaXN0Ym94TXVsdGlTZWxlY3RFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0geyBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiBib29sZWFuIH0gfSAmIFBpY2s8aC5KU1guVGFyZ2V0ZWRFdmVudDxFPiwgXCJ0YXJnZXRcIiB8IFwiY3VycmVudFRhcmdldFwiPjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7XG4gICAgbGlzdGJveE11bHRpOiB7XG4gICAgICAgIHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PjtcbiAgICAgICAgdGFnTGlzdDogRWxlbWVudFRvVGFnPExpc3RFbGVtZW50PlxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVycyBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8SW5mbywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiwgXCJzdWJJbmZvXCI+IHtcbiAgICBsaXN0Ym94TXVsdGlJdGVtOiB7XG4gICAgICAgIGRpc2FibGVkPzogYm9vbGVhbjtcbiAgICAgICAgc2VsZWN0ZWQ6IGJvb2xlYW47XG4gICAgICAgIG9uU2VsZWN0ZWRDaGFuZ2U/KGV2ZW50OiAoTGlzdGJveE11bHRpU2VsZWN0RXZlbnQ8RWxlbWVudD4pKTogdm9pZDtcbiAgICB9O1xufVxuXG5cblxuZXhwb3J0IHR5cGUgVXNlTGlzdGJveE11bHRpSXRlbTxFIGV4dGVuZHMgRWxlbWVudD4gPSAoaW5mbzogVXNlTGlzdGJveE11bHRpSXRlbVBhcmFtZXRlcnMpID0+IFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlV2l0aEhvb2tzPEU+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlSW5mbzxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88RT4ge1xuICAgIGxpc3Rib3hNdWx0aUl0ZW06IHtcbiAgICAgICAgdGFiYmFibGU6IGJvb2xlYW47XG4gICAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0Ym94TXVsdGlJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0Ym94TXVsdGlJdGVtUmV0dXJuVHlwZUluZm88RT4ge1xuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudCwgSW5mbywgbmV2ZXI+IHtcblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3Rib3hNdWx0aVJldHVyblR5cGVXaXRoSG9va3M8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3Rib3hNdWx0aVJldHVyblR5cGVJbmZvPExpc3RJdGVtRWxlbWVudD4ge1xuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW06IFVzZUxpc3Rib3hNdWx0aUl0ZW08TGlzdEl0ZW1FbGVtZW50PjtcbiAgICB1c2VMaXN0Ym94TXVsdGlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PjtcbiAgICB1c2VMaXN0Ym94TXVsdGlMYWJlbDogKCkgPT4geyB1c2VMaXN0Ym94TXVsdGlMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47IH1cbn1cblxuXG5pbnRlcmZhY2UgSW5mbyB7XG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW47XG4gICAgb25TZWxlY3Q/KGV2ZW50OiAoTGlzdGJveE11bHRpU2VsZWN0RXZlbnQ8RWxlbWVudD4pKTogdm9pZDtcbn1cblxuXG4vKmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGU8TGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCwge30sIG5ldmVyPiwgXCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkXCIgfCBcInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNcIj4ge1xuICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW06IFVzZUxpc3Rib3hNdWx0aUl0ZW08TGlzdEl0ZW1FbGVtZW50PjtcbiAgICB1c2VMaXN0Ym94TXVsdGlQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PjtcbiAgICB1c2VMaXN0Ym94TXVsdGlMYWJlbDogKCkgPT4geyB1c2VMaXN0Ym94TXVsdGlMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD47IH1cbn0qL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0Ym94TXVsdGk8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgbGlzdGJveE11bHRpOiB7IHRhZ0xhYmVsLCB0YWdMaXN0IH0sXG4gICAgbGluZWFyTmF2aWdhdGlvbjogeyAuLi5sbiB9LFxuICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmxzIH0sXG4gICAgbWFuYWdlZENoaWxkcmVuOiB7IC4uLm1jIH0sXG4gICAgcm92aW5nVGFiSW5kZXg6IHsgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCAuLi5ydGkgfSxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IC4uLnRuIH1cbn06IFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4pOiBVc2VMaXN0Ym94TXVsdGlSZXR1cm5UeXBlV2l0aEhvb2tzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4ge1xuXG4gICAgZGVidWdMb2coXCJ1c2VMaXN0Ym94TXVsdGlcIik7XG5cbiAgICAvL2NvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0Rm9jdXNlZElubmVyIH0gPSB1c2VIYXNGb2N1czxMaXN0RWxlbWVudD4oe30pO1xuXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0LCB1c2VMYWJlbExhYmVsIH0gPSB1c2VMYWJlbDxMaXN0RWxlbWVudCwgTGFiZWxFbGVtZW50Pih7XG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICBwcmVmaXhMYWJlbDogXCJhcmlhLWxpc3Rib3gtbGFiZWwtXCIsXG4gICAgICAgICAgICBwcmVmaXhJbnB1dDogXCJhcmlhLWxpc3Rib3gtXCIsXG4gICAgICAgICAgICB0YWdMYWJlbDogdGFnTGFiZWwsXG4gICAgICAgICAgICB0YWdJbnB1dDogdGFnTGlzdFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBsaXN0UmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uPExpc3RFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQsIEluZm8sIG5ldmVyPih7XG5cbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyAuLi5sbiB9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4ubWMgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgIC4uLnJ0aSxcbiAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25UYWJiYWJsZUluZGV4Q2hhbmdlPigoaSkgPT4ge1xuICAgICAgICAgICAgICAgIG9uVGFiYmFibGVJbmRleENoYW5nZT8uKGkpO1xuICAgICAgICAgICAgICAgIC8qaWYgKHNlbGVjdGlvbk1vZGUgPT0gXCJmb2N1c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IChjaGlsZHJlbi5nZXRBdChpISk/LnN1YkluZm8uZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0Py4oeyB0YXJnZXQsIGN1cnJlbnRUYXJnZXQ6IHRhcmdldCwgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBpISB9IH0pO1xuICAgICAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgfSksXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuXG4gICAgfSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IHNldFRhYmJhYmxlSW5kZXggfVxuICAgIH0gPSBsaXN0UmV0dXJuVHlwZVxuXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHMgfSA9IHVzZUxhYmVsSW5wdXQoKTtcblxuICAgIGNvbnN0IFtnZXRTaGlmdEhlbGQsIHNldFNoaWZ0SGVsZF0gPSB1c2VQYXNzaXZlU3RhdGUobnVsbCwgcmV0dXJuRmFsc2UpO1xuXG5cbiAgICBjb25zdCB1c2VMaXN0Ym94TXVsdGlJdGVtID0gdXNlQ2FsbGJhY2s8VXNlTGlzdGJveE11bHRpSXRlbTxMaXN0SXRlbUVsZW1lbnQ+PigoeyBsaXN0Ym94TXVsdGlJdGVtOiB7IHNlbGVjdGVkLCBkaXNhYmxlZCwgb25TZWxlY3RlZENoYW5nZSB9LCBtYW5hZ2VkQ2hpbGQsIGxpc3ROYXZpZ2F0aW9uOiBscywgcm92aW5nVGFiSW5kZXg6IHJ0aSB9KSA9PiB7XG4gICAgICAgIGRlYnVnTG9nKFwidXNlTGlzdGJveE11bHRpSXRlbVwiLCBtYW5hZ2VkQ2hpbGQuaW5kZXgsIHNlbGVjdGVkKTtcbiAgICAgICAgdHlwZSBFID0gTGlzdEl0ZW1FbGVtZW50O1xuICAgICAgICBjb25zdCBnZXRTZWxlY3RlZCA9IHVzZVN0YWJsZUdldHRlcihzZWxlY3RlZCk7XG4gICAgICAgIGNvbnN0IHsgdXNlUmVmRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VSZWZFbGVtZW50PEU+KHt9KTtcbiAgICAgICAgY29uc3Qgc3RhYmxlT25TZWxlY3QgPSB1c2VTdGFibGVDYWxsYmFjayhvblNlbGVjdGVkQ2hhbmdlID8/ICgoKSA9PiB7IH0pKTtcblxuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcywgcm92aW5nVGFiSW5kZXg6IHJ0aTJfcmV0IH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHsgbGlzdE5hdmlnYXRpb246IGxzLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4OiBydGksIHN1YkluZm86IHsgc2VsZWN0ZWQsIG9uU2VsZWN0OiBzdGFibGVPblNlbGVjdCB9IH0pO1xuXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZ2V0U2hpZnRIZWxkKCkpIHtcbiAgICAgICAgICAgICAgICBzdGFibGVPblNlbGVjdD8uKHsgdGFyZ2V0OiBlbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBlbGVtZW50LCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiB0cnVlIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtydGkyX3JldC50YWJiYWJsZV0pO1xuXG4gICAgICAgIHJldHVybiB7IHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcywgbGlzdGJveE11bHRpSXRlbTogeyBnZXRTZWxlY3RlZCwgdGFiYmFibGU6IHJ0aTJfcmV0LnRhYmJhYmxlIH0sIHJvdmluZ1RhYkluZGV4OiBydGkyX3JldCB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XG4gICAgICAgICAgICBjb25zdCB1c2VQcmVzc1Byb3BzID0gdXNlUHJlc3M8RT4oZGlzYWJsZWQgPyBudWxsIDogKGUpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG1hbmFnZWRDaGlsZC5pbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN0YWJsZU9uU2VsZWN0Py4oeyAuLi5lLCBbRXZlbnREZXRhaWxdOiB7IHNlbGVjdGVkOiAhZ2V0U2VsZWN0ZWQoKSB9IH0pO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0sIHt9KTtcblxuICAgICAgICAgICAgcHJvcHMucm9sZSA9IFwib3B0aW9uXCI7XG4gICAgICAgICAgICAvL3Byb3BzW1wiYXJpYS1zZXRzaXplXCJdID0gKGNoaWxkQ291bnQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvL3Byb3BzW1wiYXJpYS1wb3NpbnNldFwiXSA9IChpbmZvLmluZGV4ICsgMSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHByb3BzW1wiYXJpYS1zZWxlY3RlZFwiXSA9IChydGkyX3JldC50YWJiYWJsZSA/PyBmYWxzZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZClcbiAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtZGlzYWJsZWRcIl0gPSBcInRydWVcIjtcblxuICAgICAgICAgICAgcmV0dXJuIHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlUHJlc3NQcm9wcyhwcm9wcykpKTtcbiAgICAgICAgfVxuXG4gICAgfSwgW3VzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRdKTtcblxuICAgIGNvbnN0IHVzZUxpc3Rib3hNdWx0aUxhYmVsID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gdXNlTGlzdGJveE11bHRpTGFiZWwoKSB7XG4gICAgICAgIGZ1bmN0aW9uIHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlTGFiZWxMYWJlbFByb3BzIH0gPSB1c2VMYWJlbExhYmVsKCk7XG4gICAgICAgICAgICByZXR1cm4gdXNlTGFiZWxMYWJlbFByb3BzKHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHMgfTtcbiAgICB9LCBbdXNlTGFiZWxMYWJlbF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTGlzdGJveE11bHRpSXRlbSxcbiAgICAgICAgdXNlTGlzdGJveE11bHRpUHJvcHMsXG4gICAgICAgIHVzZUxpc3Rib3hNdWx0aUxhYmVsLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaXN0UmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBsaXN0UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogbGlzdFJldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBsaXN0UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW5cbiAgICB9O1xuXG5cbiAgICBmdW5jdGlvbiB1c2VMaXN0Ym94TXVsdGlQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IHtcbiAgICAgICAgcHJvcHMucm9sZSA9IFwibGlzdGJveFwiO1xuICAgICAgICBwcm9wc1tcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCJdID0gXCJ0cnVlXCI7XG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzKHVzZUxhYmVsSW5wdXRQcm9wcyh1c2VNZXJnZWRQcm9wczxMaXN0RWxlbWVudD4oeyBvbktleURvd24sIG9uS2V5VXAsIG9uZm9jdXNvdXQ6IG9uRm9jdXNPdXQgfSwgcHJvcHMpKSk7XG4gICAgfVxuXG5cblxuICAgIGZ1bmN0aW9uIG9uS2V5RG93bihlOiBLZXlib2FyZEV2ZW50KSB7IGlmIChlLmtleSA9PSBcIlNoaWZ0XCIpIHNldFNoaWZ0SGVsZCh0cnVlKTsgfVxuICAgIGZ1bmN0aW9uIG9uS2V5VXAoZTogS2V5Ym9hcmRFdmVudCkgeyBpZiAoZS5rZXkgPT0gXCJTaGlmdFwiKSBzZXRTaGlmdEhlbGQoZmFsc2UpOyB9XG4gICAgZnVuY3Rpb24gb25Gb2N1c091dChfOiBGb2N1c0V2ZW50KSB7IHNldFNoaWZ0SGVsZChmYWxzZSk7IH1cblxufSIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VMaXN0TmF2aWdhdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCB1c2VNZXJnZWRQcm9wcywgdXNlUHJlc3MsIHVzZVJhbmRvbUlkLCB1c2VSZWZFbGVtZW50LCB1c2VTdGFibGVDYWxsYmFjaywgdXNlU3RhYmxlR2V0dGVyLCB1c2VTdGF0ZSwgdXNlVGltZW91dCB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWxpc3QtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgcmV0dXJuRmFsc2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nLCB3YXJuT25PdmVyd3JpdGUgfSBmcm9tIFwiLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlU29mdERpc21pc3MsIFVzZVNvZnREaXNtaXNzUGFyYW1ldGVycywgVXNlU29mdERpc21pc3NSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1tb2RhbFwiO1xuXG5pbnRlcmZhY2UgTVNQIHtcbiAgICAvKipcbiAgICAgKiBXaGF0IHJvbGUgdGhlIHN1cmZhY2UgZnVsZmlsbHMuXG4gICAgICogXG4gICAgICogR2VuZXJhbCBtZW51cyBzaG91bGQgdXNlIFwibWVudVwiLiBcImRpYWxvZ1wiIGNhbiBiZSB1c2VkIGZvciBnZW5lcmljIHBvcC11cCB0aGluZ3MuXG4gICAgICovXG4gICAgcm9sZTogXCJkaWFsb2dcIiB8IFwibWVudVwiIHwgXCJ0cmVlXCIgfCBcImdyaWRcIiB8IFwibGlzdGJveFwiO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGlzIG1lbnUgc3VyZmFjZSBpcyBvcGVuZWQsIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIGl0IG11c3QgYmUgZm9jdXNlZC5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGNvbnRyb2xzIHdoYXQgaXMgZm9jdXNlZCAoZS5nLiB0aGUgZmlyc3QgbWVudSBpdGVtLCB0aGUgd2hvbGUgc3VyZmFjZSBpdHNlbGYsIGV0Yy4pXG4gICAgICovXG4gICAgc2VuZEZvY3VzVG9NZW51KCk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIE1lbnVTdXJmYWNlT21pdHMgPSBrZXlvZiBNU1A7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudVN1cmZhY2VQYXJhbWV0ZXJzPF9TIGV4dGVuZHMgRWxlbWVudCwgX0IgZXh0ZW5kcyBFbGVtZW50LCBNU08gZXh0ZW5kcyBNZW51U3VyZmFjZU9taXRzPiBleHRlbmRzIFVzZVNvZnREaXNtaXNzUGFyYW1ldGVyczxcImdldEVsZW1lbnRzXCI+IHtcbiAgICBtZW51U3VyZmFjZTogT21pdDxNU1AsIE1TTz47XG4gICAgLy9oYXNGb2N1c0J1dHRvbjogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEI+O1xuICAgIC8vaGFzRm9jdXNTdXJmYWNlOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8Uz47XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVQYXJhbWV0ZXJzPFMgZXh0ZW5kcyBFbGVtZW50LCBCIGV4dGVuZHMgRWxlbWVudCwgTVNPIGV4dGVuZHMgTWVudVN1cmZhY2VPbWl0cz4gZXh0ZW5kcyBVc2VNZW51U3VyZmFjZVBhcmFtZXRlcnM8UywgQiwgTVNPIHwgXCJyb2xlXCIgfCBcInNlbmRGb2N1c1RvTWVudVwiPiwgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4ge1xuICAgIG1lbnU6IHtcbiAgICAgICAgb25PcGVuKCk6IHZvaWQ7XG5cbiAgICAgICAgLy8gQ29ycmVzcG9uZHMgdG8gd2hhdCBhcnJvdyBrZXkgY2FuIG9wZW4gdGhpcyBtZW51XG4gICAgICAgIG9wZW5EaXJlY3Rpb246IFwiZG93blwiIHwgXCJ1cFwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIgfCBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUJ1dHRvblBhcmFtZXRlcnMgZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUl0ZW1QYXJhbWV0ZXJzIGV4dGVuZHMgT21pdDxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczx7fSwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiwgXCJzdWJJbmZvXCI+IHsgfVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVTdXJmYWNlUmV0dXJuVHlwZUluZm88X01lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgX01lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VTb2Z0RGlzbWlzc1JldHVyblR5cGVJbmZvIHtcbiAgICBtZW51U3VyZmFjZToge1xuICAgICAgICAvKmdldEJ1dHRvbkZvY3VzZWQoKTogYm9vbGVhbjtcbiAgICAgICAgZ2V0QnV0dG9uRm9jdXNlZElubmVyKCk6IGJvb2xlYW47XG4gICAgICAgIGdldEJ1dHRvbkxhc3RGb2N1c2VkKCk6IGJvb2xlYW47XG4gICAgICAgIGdldEJ1dHRvbkxhc3RGb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcbiAgICAgICAgZ2V0QnV0dG9uRWxlbWVudDogKCkgPT4gTWVudUJ1dHRvbkVsZW1lbnQgfCBudWxsO1xuICAgICAgICBnZXRTdXJmYWNlRm9jdXNlZCgpOiBib29sZWFuO1xuICAgICAgICBnZXRTdXJmYWNlRm9jdXNlZElubmVyKCk6IGJvb2xlYW47XG4gICAgICAgIGdldFN1cmZhY2VMYXN0Rm9jdXNlZCgpOiBib29sZWFuO1xuICAgICAgICBnZXRTdXJmYWNlTGFzdEZvY3VzZWRJbm5lcigpOiBib29sZWFuO1xuICAgICAgICBnZXRTdXJmYWNlRWxlbWVudDogKCkgPT4gTWVudVBhcmVudEVsZW1lbnQgfCBudWxsO1xuICAgICAgICBnZXRBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQ6ICgpID0+IEVsZW1lbnQ7XG4gICAgICAgIGdldFdpbmRvd0ZvY3VzZWQ6ICgpID0+IGJvb2xlYW47Ki9cbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVSZXR1cm5UeXBlSW5mbzxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBfTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTWVudVN1cmZhY2VSZXR1cm5UeXBlSW5mbzxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50PiwgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQsIHt9LCBuZXZlcj4geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVCdXR0b25SZXR1cm5UeXBlSW5mbyBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxuZXZlcj4geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50PiB7IH1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNZW51U3VyZmFjZVJldHVyblR5cGVXaXRoSG9va3M8TWVudVN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTWVudVN1cmZhY2VSZXR1cm5UeXBlSW5mbzxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50PiB7XG4gICAgdXNlTWVudVN1cmZhY2VTZW50aW5lbDogPEUgZXh0ZW5kcyBFbGVtZW50PigpID0+IHsgdXNlTWVudVNlbnRpbmVsUHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47IH07XG4gICAgdXNlTWVudVN1cmZhY2VQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51U3VyZmFjZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51U3VyZmFjZUVsZW1lbnQ+O1xuICAgIHVzZU1lbnVTdXJmYWNlQ2hpbGRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVQYXJlbnRFbGVtZW50PjsgIC8vIE5PVCBhIG1lbnUgaXRlbSEgVGhpcyBpcyB0aGUgbWVudSwgZGlhbG9nLCBwb3B1cCwgd2hhdGV2ZXIgYWN0dWFsbHkgZ2V0cyB0aGUgcm9sZSwgYXMgb3Bwb3NlZCB0byB0aGUgc3VyZmFjZSB0aGF0IGxpc3RlbnMgdG8gbW91c2UgYW5kIGtleWJvYXJkIGV2ZW50c1xuICAgIHVzZU1lbnVTdXJmYWNlQnV0dG9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUJ1dHRvbkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+O1xuXG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVSZXR1cm5UeXBlV2l0aEhvb2tzPE1lbnVTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZU1lbnVSZXR1cm5UeXBlSW5mbzxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50PiB7XG4gICAgdXNlTWVudVNlbnRpbmVsOiA8RSBleHRlbmRzIEVsZW1lbnQ+KCkgPT4geyB1c2VNZW51U2VudGluZWxQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjsgfTtcbiAgICB1c2VNZW51UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVBhcmVudEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51UGFyZW50RWxlbWVudD47XG4gICAgdXNlTWVudVN1cmZhY2VQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51U3VyZmFjZUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51U3VyZmFjZUVsZW1lbnQ+O1xuICAgIHVzZU1lbnVCdXR0b25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51QnV0dG9uRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PjtcbiAgICB1c2VNZW51SXRlbTogVXNlTWVudUl0ZW08TWVudUl0ZW1FbGVtZW50Pjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUJ1dHRvblJldHVyblR5cGVXaXRoSG9va3MgZXh0ZW5kcyBVc2VNZW51QnV0dG9uUmV0dXJuVHlwZUluZm8geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZU1lbnVJdGVtUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50PiB7IH1cblxuLy9leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50PiB7fVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1lbnVJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZU1lbnVJdGVtUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50PiB7XG4gICAgdXNlTWVudUl0ZW1Qcm9wczogVXNlTWVudUl0ZW1Qcm9wczxNZW51SXRlbUVsZW1lbnQ+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VNZW51SXRlbVByb3BzPE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51SXRlbUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51SXRlbUVsZW1lbnQ+O1xuXG5leHBvcnQgdHlwZSBVc2VNZW51SXRlbTxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VNZW51SXRlbVBhcmFtZXRlcnMpID0+IFVzZU1lbnVJdGVtUmV0dXJuVHlwZVdpdGhIb29rczxNZW51SXRlbUVsZW1lbnQ+O1xuXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlTWVudUNoaWxkSW5mb0Jhc2U8SyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkSW5mb0Jhc2U8Sz4ge31cblxuLy9leHBvcnQgdHlwZSBVc2VNZW51Q2hpbGRQYXJhbWV0ZXJzPEkgZXh0ZW5kcyBVc2VNZW51Q2hpbGRJbmZvPiA9IEk7XG5cbi8qKlxuICogQSBtZW51IGlzIGEgcG9wdXAgY29udHJvbCB0aGF0IGNvbnRhaW5zIGEgbGlzdCBvZiBtZW51IGl0ZW1zLCBhbmQgdGhhdCdzIGl0LlxuICogSXQgaGFzIHZlcnkgd2VsbC1kZWZpbmVkIGxvZ2ljIGZvciBtYW5hZ2luZyB0aG9zZSBpdGVtcyBhcyB0aGUgbWVudSdzIHN0YXRlIGNoYW5nZXMuXG4gKiBcbiAqIEEgTWVudUJhc2UgaXMganVzdCB0aGUgXCJwb3B1cFwiIHBhcnQgd2l0aG91dCB0aGUgXCJsaXN0IG9mIG1lbnUgaXRlbXNcIiBwYXJ0LiBJdCBjYW5cbiAqIChyZWFsbHksIG11c3QpIGhhdmUgaW50ZXJhY3RpdmUgY29udHJvbHMsIGJ1dCB0aGVzZSBjb250cm9scyBhcmUgYWxsb3dlZCB0byBiZSBtb3JlXG4gKiBmcmVlLWZvcm0uIFRoaXMgbWVhbnMgdGhhdCwgbGlrZSBhIGRpYWxvZywgeW91IG11c3QgdGVsbCB0aGlzIGhvb2tcbiAqIHdoZXJlIHdpdGhpbiB0aGUgcG9wdXAgdG8gc2VuZCBmb2N1cyB3aGVuIG9wZW5lZCAoZm9yIGEgbWVudSBpdCdzIGp1c3QgdGhlIGZpcnN0XG4gKiBtZW51IGl0ZW0sIGJ1dCB3aXRoIGN1c3RvbSBjb250ZW50IHlvdSdsbCBuZWVkIHRvIHByb3ZpZGUgdGhpcykuXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbnVTdXJmYWNlPE1lbnVTdXJmYWNlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHNvZnREaXNtaXNzLCBtZW51U3VyZmFjZTogeyBzZW5kRm9jdXNUb01lbnUsIHJvbGUgfSwgYWN0aXZlRWxlbWVudCB9OiBVc2VNZW51U3VyZmFjZVBhcmFtZXRlcnM8TWVudVN1cmZhY2VFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudCwgbmV2ZXI+KTogVXNlTWVudVN1cmZhY2VSZXR1cm5UeXBlV2l0aEhvb2tzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50PiB7XG4gICAgZGVidWdMb2coXCJ1c2VNZW51U3VyZmFjZVwiKTtcbiAgICAvL2NvbnN0IHNlbmRGb2N1c1dpdGhpbk1lbnUgPSB1c2VTdGFibGVDYWxsYmFjayhzZW5kRm9jdXNUb01lbnUpO1xuICAgIC8vY29uc3QgW2ZvY3VzVHJhcEFjdGl2ZSwgc2V0Rm9jdXNUcmFwQWN0aXZlXSA9IHVzZVN0YXRlPG51bGwgfCBib29sZWFuPihudWxsKTtcbiAgICBjb25zdCB7IG9wZW4sIG9uQ2xvc2U6IHVzZXJPbkNsb3NlIH0gPSBzb2Z0RGlzbWlzcztcbiAgICBjb25zdCBvbkNsb3NlID0gdXNlU3RhYmxlQ2FsbGJhY2s8dHlwZW9mIHVzZXJPbkNsb3NlPigocmVhc29uKSA9PiB7XG4gICAgICAgIGlmIChyZWFzb24gIT0gXCJsb3N0LWZvY3VzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5lciA9IChnZXRPcGVuZXJFbGVtZW50KCkgYXMgSFRNTEVsZW1lbnQgfCBudWxsKTtcbiAgICAgICAgICAgIGlmIChvcGVuZXIgJiYgXCJmb2N1c1wiIGluIG9wZW5lcilcbiAgICAgICAgICAgICAgICBvcGVuZXIuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2VyT25DbG9zZShyZWFzb24pO1xuICAgIH0pXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTWVudVN1cmZhY2VcIiwgb25DbG9zZSwgcm9sZSwgc2VuZEZvY3VzVG9NZW51KTtcbiAgICBjb25zdCBnZXRJc09wZW4gPSB1c2VTdGFibGVHZXR0ZXIob3Blbik7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB1c2VSZWY8SW50ZXJzZWN0aW9uT2JzZXJ2ZXI+KG51bGwhKTtcbiAgICBjb25zdCBbZ2V0U3VyZmFjZUZ1bGx5VmlzaWJsZSwgc2V0U3VyZmFjZUZ1bGx5VmlzaWJsZV0gPSB1c2VQYXNzaXZlU3RhdGUobnVsbCwgcmV0dXJuRmFsc2UpO1xuICAgIGludGVyc2VjdGlvbk9ic2VydmVyLmN1cnJlbnQgPz89IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcywgX29ic2VydmVyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgc2V0U3VyZmFjZUZ1bGx5VmlzaWJsZShlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+PSAxKTtcbiAgICAgICAgfVxuICAgIH0sIHsgcm9vdDogbnVsbCwgdGhyZXNob2xkOiBbMCwgMV0gfSk7XG5cbiAgICBjb25zdCBbLCBzZXRPcGVuZXJFbGVtZW50LCBnZXRPcGVuZXJFbGVtZW50XSA9IHVzZVN0YXRlPE1lbnVCdXR0b25FbGVtZW50IHwgbnVsbD4obnVsbCk7XG5cbiAgICAvL2NvbnN0IHsgdXNlSGFzRm9jdXNQcm9wczogdXNlTWVudUJhc2VIYXNGb2N1c1Byb3BzLCAuLi5zdXJmYWNlSGFzRm9jdXMgfSA9IHVzZUhhc0ZvY3VzPE1lbnVTdXJmYWNlRWxlbWVudD4oeyAuLi5oYXNGb2N1c1N1cmZhY2UgfSk7XG4gICAgLy9jb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHM6IHVzZUJ1dHRvbkhhc0ZvY3VzUHJvcHMsIC4uLmJ1dHRvbkhhc0ZvY3VzIH0gPSB1c2VIYXNGb2N1czxNZW51QnV0dG9uRWxlbWVudD4oeyAuLi5oYXNGb2N1c0J1dHRvbiB9KTtcblxuICAgIC8vY29uc3QgeyBnZXRMYXN0Rm9jdXNlZElubmVyOiBnZXRNZW51QmFzZUxhc3RGb2N1c2VkSW5uZXIgfSA9IHN1cmZhY2VIYXNGb2N1cztcblxuICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50LCB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50IH0gPSB1c2VSYW5kb21JZDxNZW51UGFyZW50RWxlbWVudD4oeyByYW5kb21JZDogeyBwcmVmaXg6IFwiYXJpYS1tZW51LVwiIH0sIG1hbmFnZWRDaGlsZHJlbjoge30gfSk7XG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50KCk7XG4gICAgY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMgfSA9IHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnQ8TWVudUJ1dHRvbkVsZW1lbnQ+KFwiYXJpYS1jb250cm9sc1wiIGFzIG5ldmVyKTtcblxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudDogZ2V0QnV0dG9uRWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VCdXR0b25SZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8TWVudUJ1dHRvbkVsZW1lbnQ+KHsgb25FbGVtZW50Q2hhbmdlOiBzZXRPcGVuZXJFbGVtZW50IH0pO1xuXG4gICAgY29uc3QgeyBnZXRFbGVtZW50OiBnZXRNZW51RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzOiB1c2VNZW51QmFzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxNZW51U3VyZmFjZUVsZW1lbnQ+KHt9KTtcbiAgICBjb25zdCB7IHVzZVNvZnREaXNtaXNzUHJvcHMsIC4uLnNvZnREaXNtaXNzUmV0dXJuIH0gPSB1c2VTb2Z0RGlzbWlzczxhbnk+KHtcbiAgICAgICAgc29mdERpc21pc3M6IHtcbiAgICAgICAgICAgIC4uLnNvZnREaXNtaXNzLFxuICAgICAgICAgICAgZ2V0RWxlbWVudHM6ICgpID0+IChbZ2V0QnV0dG9uRWxlbWVudCgpLCBnZXRNZW51RWxlbWVudCgpXSksXG4gICAgICAgIH0sXG4gICAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9KTtcblxuXG4gICAgY29uc3QgdXNlTWVudVN1cmZhY2VQcm9wcyA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVN1cmZhY2VFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVTdXJmYWNlRWxlbWVudD4gPT4ge1xuICAgICAgICBmdW5jdGlvbiBvbktleURvd24oZTogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgICAgY29uc3Qgb3BlbiA9IGdldElzT3BlbigpO1xuICAgICAgICAgICAgaWYgKGUua2V5ID09IFwiRXNjYXBlXCIgJiYgb3Blbikge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2UoXCJlc2NhcGVcIik7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1c2VTb2Z0RGlzbWlzc1Byb3BzKCh1c2VNZW51QmFzZVJlZkVsZW1lbnRQcm9wcygodXNlTWVyZ2VkUHJvcHM8TWVudVN1cmZhY2VFbGVtZW50Pih7IG9uS2V5RG93biB9LCAocHJvcHMpKSkpKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHVzZU1lbnVTdXJmYWNlQnV0dG9uUHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVCdXR0b25FbGVtZW50PiA9PiB7XG4gICAgICAgIHByb3BzW1wiYXJpYS1leHBhbmRlZFwiXSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZU1lbnVTdXJmYWNlQnV0dG9uUHJvcHNcIiwgXCJhcmlhLWV4cGFuZGVkXCIsIG9wZW4sIG9wZW4udG9TdHJpbmcoKSk7XG4gICAgICAgIHByb3BzW1wiYXJpYS1oYXNwb3B1cFwiXSA9IHdhcm5Pbk92ZXJ3cml0ZShcInVzZU1lbnVTdXJmYWNlQnV0dG9uUHJvcHNcIiwgXCJhcmlhLWhhc3BvcHVwXCIsIHJvbGUsIHJvbGUpO1xuICAgICAgICByZXR1cm4gdXNlQnV0dG9uUmVmRWxlbWVudFByb3BzKCh1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50UHJvcHMocHJvcHMpKSk7XG4gICAgfTtcblxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICBpZiAob3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc2VuZEZvY3VzVG9NZW51Py4oKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZ2V0U3VyZmFjZUZ1bGx5VmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldE1lbnVFbGVtZW50KCk/LnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0sIFtvcGVuXSk7XG5cbiAgICBmdW5jdGlvbiB1c2VNZW51U3VyZmFjZUNoaWxkUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVQYXJlbnRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPE1lbnVQYXJlbnRFbGVtZW50PiB7XG4gICAgICAgIHByb3BzLnJvbGUgPSByb2xlO1xuICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHMocHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZU1lbnVTdXJmYWNlQ2hpbGRQcm9wcyxcbiAgICAgICAgdXNlTWVudVN1cmZhY2VTZW50aW5lbDogdXNlQ2FsbGJhY2soPEUgZXh0ZW5kcyBFbGVtZW50PigpID0+IHtcbiAgICAgICAgICAgIGRlYnVnTG9nKFwidXNlTWVudVN1cmZhY2VTZW50aW5lbFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICB1c2VTZW50aW5lbFByb3BzOiB1c2VNZW51U2VudGluZWxQcm9wcyxcbiAgICAgICAgICAgICAgICAuLi5yZXN0XG4gICAgICAgICAgICB9ID0gdXNlRm9jdXNTZW50aW5lbDxFPih7XG4gICAgICAgICAgICAgICAgZm9jdXNTZW50aW5lbDoge1xuICAgICAgICAgICAgICAgICAgICBvcGVuOiBvcGVuID09PSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiBvbkNsb3NlKFwiZXNjYXBlXCIpLFxuICAgICAgICAgICAgICAgICAgICBzZW5kRm9jdXNUb01lbnVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IHVzZU1lbnVTZW50aW5lbFByb3BzLCAuLi5yZXN0IH07XG4gICAgICAgIH0sIFtvcGVuLCBvbkNsb3NlXSksXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlUHJvcHMsXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlQnV0dG9uUHJvcHMsXG4gICAgICAgIG1lbnVTdXJmYWNlOiB7XG4gICAgICAgICAgICAvKmdldEFjdGl2ZUVsZW1lbnQ6IGJ1dHRvbkhhc0ZvY3VzLmdldEFjdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudDogYnV0dG9uSGFzRm9jdXMuZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICBnZXRCdXR0b25FbGVtZW50OiBidXR0b25IYXNGb2N1cy5nZXRFbGVtZW50LFxuICAgICAgICAgICAgZ2V0QnV0dG9uRm9jdXNlZDogYnV0dG9uSGFzRm9jdXMuZ2V0Rm9jdXNlZCxcbiAgICAgICAgICAgIGdldEJ1dHRvbkZvY3VzZWRJbm5lcjogYnV0dG9uSGFzRm9jdXMuZ2V0Rm9jdXNlZElubmVyLFxuICAgICAgICAgICAgZ2V0QnV0dG9uTGFzdEZvY3VzZWQ6IGJ1dHRvbkhhc0ZvY3VzLmdldExhc3RGb2N1c2VkLFxuICAgICAgICAgICAgZ2V0QnV0dG9uTGFzdEZvY3VzZWRJbm5lcjogYnV0dG9uSGFzRm9jdXMuZ2V0TGFzdEZvY3VzZWRJbm5lcixcbiAgICAgICAgICAgIGdldFN1cmZhY2VFbGVtZW50OiBzdXJmYWNlSGFzRm9jdXMuZ2V0RWxlbWVudCxcbiAgICAgICAgICAgIGdldFN1cmZhY2VGb2N1c2VkOiBzdXJmYWNlSGFzRm9jdXMuZ2V0Rm9jdXNlZCxcbiAgICAgICAgICAgIGdldFN1cmZhY2VGb2N1c2VkSW5uZXI6IHN1cmZhY2VIYXNGb2N1cy5nZXRGb2N1c2VkSW5uZXIsXG4gICAgICAgICAgICBnZXRTdXJmYWNlTGFzdEZvY3VzZWQ6IHN1cmZhY2VIYXNGb2N1cy5nZXRMYXN0Rm9jdXNlZCxcbiAgICAgICAgICAgIGdldFN1cmZhY2VMYXN0Rm9jdXNlZElubmVyOiBzdXJmYWNlSGFzRm9jdXMuZ2V0TGFzdEZvY3VzZWRJbm5lcixcbiAgICAgICAgICAgIGdldFdpbmRvd0ZvY3VzZWQ6IGJ1dHRvbkhhc0ZvY3VzLmdldFdpbmRvd0ZvY3VzZWQsKi9cbiAgICAgICAgfSxcbiAgICAgICAgLi4uc29mdERpc21pc3NSZXR1cm5cblxuICAgICAgICAvL2dldE1lbnVCYXNlTGFzdEZvY3VzZWRJbm5lcixcbiAgICAgICAgLy9nZXRNZW51QmFzZUJ1dHRvbkxhc3RGb2N1c2VkSW5uZXIsXG4gICAgICAgIC8vb3BlbixcbiAgICAgICAgLy9vbk9wZW4sXG4gICAgICAgIC8vb25DbG9zZVxuICAgIH1cbn1cblxuaW50ZXJmYWNlIEZTUCBleHRlbmRzIE1TUCB7XG4gICAgb3BlbjogYm9vbGVhbjtcbiAgICBvbkNsb3NlKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIEZvY3VzU2VudGluZWxPbWl0cyA9IGtleW9mIEZTUDtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1NlbnRpbmVsUGFyYW1ldGVycyB7XG4gICAgZm9jdXNTZW50aW5lbDogeyBzZW5kRm9jdXNUb01lbnU6IE1TUFtcInNlbmRGb2N1c1RvTWVudVwiXTsgb3BlbjogYm9vbGVhbjsgb25DbG9zZSgpOiB2b2lkOyB9O1xufVxuXG5cbi8vIEEgZm9jdXMgc2VudGluYWwgaXMgYSBoaWRkZW4gYnV0IGZvY3VzYWJsZSBlbGVtZW50IHRoYXQgY29tZXMgYXQgdGhlIHN0YXJ0IG9yIGVuZCBcbi8vIG9mIHRoZSBvdXQtb2YtcGxhY2UtZm9jdXNhYmxlIGNvbXBvbmVudCB0aGF0LCB3aGVuIGFjdGl2YXRlZCBvciBmb2N1c2VkIG92ZXIsIGNsb3NlcyB0aGUgY29tcG9uZW50XG4vLyAoaWYgZm9jdXNlZCB3aXRoaW4gMTAwbXMgb2YgdGhlIG9wZW4gcHJvcCBjaGFuZ2luZywgaW5zdGVhZCBvZlxuLy8gY2xvc2luZywgZm9jdXNpbmcgdGhlIHNlbnRpbmVsIGltbWVkaWF0ZWx5IGFza3MgaXQgdG8gZm9jdXMgaXRzZWxmKS5cbi8vIFRoaXMgZXhpc3RzIGZvciB0aGluZ3MgbGlrZSBtZW51cyB3aGljaCBjYW4gaGF2ZSBmb2N1cyBidXQgYWxzbyBuZWVkIGEgd2F5IHRvIHJldHVyblxuLy8gdG8gd2hhdGV2ZXIgb3V0LW9mLXBsYWNlIHBhcmVudCB0aGV5IGNhbWUgZnJvbSB3aGVuIG5hdHVyYWxseSB0YWJiZWQgb3V0IG9mIChhcyBvcHBvc2VkXG4vLyB0byBkaWFsb2dzIHdoaWNoIGxvb3AgYmFjayBhcm91bmQgd2hlbiB0YWJiZWQgb3V0IG9mKS4gV2hpbGUgbW91c2UgdXNlcnMgY2FuIGNsaWNrIG91dCBvZiBhIG1lbnVcbi8vIGFuZCBrZXlib2FyZCB1c2VycyBjYW4gZXNjYXBlIHRvIGNsb3NlIGEgbWVudSwgc2NyZWVuIHJlYWRlcnMgYW5kIG90aGVyIGlucHV0IG1ldGhvZHMgXG4vLyB0aGF0IGRvbid0IHVzZSB0aG9zZSB0d28gd291bGQgYmVjb21lIHN0dWNrLlxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvY3VzU2VudGluZWw8RSBleHRlbmRzIEVsZW1lbnQ+KHsgZm9jdXNTZW50aW5lbDogeyBvcGVuLCBvbkNsb3NlLCBzZW5kRm9jdXNUb01lbnUgfSB9OiBVc2VGb2N1c1NlbnRpbmVsUGFyYW1ldGVycykge1xuICAgIGRlYnVnTG9nKFwidXNlRm9jdXNTZW50aW5lbFwiKTtcbiAgICBjb25zdCBnZXRTZW5kRm9jdXNXaXRoaW5NZW51ID0gdXNlU3RhYmxlR2V0dGVyKHNlbmRGb2N1c1RvTWVudSk7XG4gICAgY29uc3Qgc3RhYmxlT25DbG9zZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uQ2xvc2UpO1xuXG4gICAgY29uc3QgW2ZpcnN0U2VudGluZWxJc0FjdGl2ZSwgc2V0Rmlyc3RTZW50aW5lbElzQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICB1c2VUaW1lb3V0KHsgY2FsbGJhY2s6ICgpID0+IHsgc2V0Rmlyc3RTZW50aW5lbElzQWN0aXZlKG9wZW4pOyB9LCB0aW1lb3V0OiAxMDAsIHRyaWdnZXJJbmRleDogYCR7b3Blbn0tJHtmaXJzdFNlbnRpbmVsSXNBY3RpdmV9YCB9KTtcblxuXG4gICAgY29uc3Qgb25Gb2N1cyA9IGZpcnN0U2VudGluZWxJc0FjdGl2ZSA/ICgoKSA9PiBzdGFibGVPbkNsb3NlKCkpIDogKCgpID0+IGdldFNlbmRGb2N1c1dpdGhpbk1lbnUoKT8uKCkpO1xuICAgIGNvbnN0IG9uQ2xpY2sgPSAoKSA9PiBzdGFibGVPbkNsb3NlKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VTZW50aW5lbFByb3BzOiBmdW5jdGlvbiAoeyB0YWJJbmRleCwgLi4ucCB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPih7IG9uRm9jdXMsIG9uQ2xpY2ssIHRhYkluZGV4OiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VGb2N1c1NlbnRpbmVsXCIsIFwidGFiSW5kZXhcIiwgdGFiSW5kZXgsIDApIH0sIHApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVudTxNZW51U3VyZmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIE1lbnVCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCBtZW51U3VyZmFjZSwgcm92aW5nVGFiSW5kZXgsIHNvZnREaXNtaXNzLCB0eXBlYWhlYWROYXZpZ2F0aW9uLCBtZW51LCBhY3RpdmVFbGVtZW50IH06IFVzZU1lbnVQYXJhbWV0ZXJzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQsIG5ldmVyPik6IFVzZU1lbnVSZXR1cm5UeXBlV2l0aEhvb2tzPE1lbnVTdXJmYWNlRWxlbWVudCwgTWVudVBhcmVudEVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgTWVudUJ1dHRvbkVsZW1lbnQ+IHtcblxuICAgIGRlYnVnTG9nKFwidXNlTWVudVwiKTtcbiAgICBjb25zdCB7IG9uT3BlbiB9ID0gbWVudTtcbiAgICBjb25zdCB7IG9wZW4sIG9uQ2xvc2UgfSA9IHNvZnREaXNtaXNzO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxuICAgICAgICAuLi51c2VMaXN0TmF2UmV0dXJuXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uPE1lbnVQYXJlbnRFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIHt9LCBzdHJpbmc+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgbGlzdE5hdmlnYXRpb24sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXgsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0gfSA9IHVzZUxpc3ROYXZSZXR1cm47XG5cblxuICAgIGNvbnN0IHtcbiAgICAgICAgLyp1c2VNZW51U2VudGluZWwsXG4gICAgICAgIHVzZU1lbnVCYXNlQnV0dG9uUHJvcHMsXG4gICAgICAgIHVzZU1lbnVCYXNlUHJvcHMsXG4gICAgICAgIG9wZW4sXG4gICAgICAgIG9uT3BlbixcbiAgICAgICAgb25DbG9zZTogX29uQ2xvc2UsKi9cbiAgICAgICAgdXNlTWVudVN1cmZhY2VCdXR0b25Qcm9wcyxcbiAgICAgICAgdXNlTWVudVN1cmZhY2VQcm9wcyxcbiAgICAgICAgdXNlTWVudVN1cmZhY2VTZW50aW5lbCxcbiAgICAgICAgdXNlTWVudVN1cmZhY2VDaGlsZFByb3BzLFxuICAgICAgICAuLi5tZW51UmVzdFxuICAgIH0gPSB1c2VNZW51U3VyZmFjZTxNZW51U3VyZmFjZUVsZW1lbnQsIE1lbnVQYXJlbnRFbGVtZW50LCBNZW51QnV0dG9uRWxlbWVudD4oe1xuICAgICAgICBtZW51U3VyZmFjZToge1xuICAgICAgICAgICAgLi4ubWVudVN1cmZhY2UsXG4gICAgICAgICAgICByb2xlOiBcIm1lbnVcIixcbiAgICAgICAgICAgIHNlbmRGb2N1c1RvTWVudTogdXNlQ2FsbGJhY2soKCkgPT4gY2hpbGRyZW4uZ2V0QXQoMCk/LnN1YkluZm8uZm9jdXNTZWxmKCksIFtdKVxuICAgICAgICB9LFxuICAgICAgICBzb2Z0RGlzbWlzcyxcbiAgICAgICAgLy9oYXNGb2N1c0J1dHRvbixcbiAgICAgICAgLy9oYXNGb2N1c1N1cmZhY2UsXG4gICAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICAgICAgLy9zZW5kRm9jdXNXaXRoaW5NZW51OiBmb2N1c01lbnUgPz8gKCgpID0+IHsgfSlcbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZU1lbnVCdXR0b25Qcm9wcyA9ICgocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUJ1dHRvbkVsZW1lbnQ+KSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZVByZXNzUHJvcHMgPSB1c2VQcmVzczxNZW51QnV0dG9uRWxlbWVudD4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9wZW4pXG4gICAgICAgICAgICAgICAgb25DbG9zZT8uKFwiZXNjYXBlXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9uT3Blbj8uKCk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB1c2VNZW51U3VyZmFjZUJ1dHRvblByb3BzKHApO1xuICAgICAgICByZXR1cm4gdXNlUHJlc3NQcm9wcyhwcm9wcyk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VNZW51SXRlbSA9IHVzZUNhbGxiYWNrPFVzZU1lbnVJdGVtPE1lbnVJdGVtRWxlbWVudD4+KCh7IGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4IH0pID0+IHtcbiAgICAgICAgZGVidWdMb2coXCJ1c2VNZW51SXRlbVwiLCBtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xuXG4gICAgICAgIHR5cGUgRSA9IE1lbnVJdGVtRWxlbWVudDtcblxuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcywgLi4ubGlzdE5hdlJldCB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7IGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4LCBzdWJJbmZvOiB7fSB9KTtcblxuICAgICAgICBmdW5jdGlvbiB1c2VNZW51SXRlbVByb3BzPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4oeyAuLi5wcm9wcyB9OiBQKSB7XG4gICAgICAgICAgICBwcm9wcy5yb2xlID0gXCJtZW51aXRlbVwiO1xuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHt9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMocHJvcHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZU1lbnVJdGVtUHJvcHMsIC4uLmxpc3ROYXZSZXQgfTtcbiAgICB9LCBbXSk7XG5cblxuICAgIGZ1bmN0aW9uIHVzZU1lbnVQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudVBhcmVudEVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzKHVzZU1lbnVTdXJmYWNlQ2hpbGRQcm9wcyhwcm9wcykpO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTWVudVByb3BzLFxuICAgICAgICB1c2VNZW51U3VyZmFjZVByb3BzLFxuXG4gICAgICAgIHVzZU1lbnVCdXR0b25Qcm9wcyxcblxuICAgICAgICB1c2VNZW51SXRlbSxcbiAgICAgICAgdXNlTWVudVNlbnRpbmVsOiB1c2VNZW51U3VyZmFjZVNlbnRpbmVsLFxuICAgICAgICAvL3VzZU1lbnVTdWJtZW51SXRlbSxcbiAgICAgICAgLi4udXNlTGlzdE5hdlJldHVybixcbiAgICAgICAgLi4ubWVudVJlc3RcblxuICAgICAgICAvKmZvY3VzTWVudSxcblxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkLFxuICAgICAgICBpbnZhbGlkVHlwZWFoZWFkLFxuXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbiwqL1xuXG5cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBnZW5lcmF0ZVJhbmRvbUlkLCByZXR1cm5UcnVlLCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiwgdXNlTWFuYWdlZENoaWxkcmVuLCB1c2VNZXJnZWRQcm9wcywgdXNlUHJlc3MsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XHJcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgdXNlQ2hpbGRyZW5GbGFnLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VMYWJlbCB9IGZyb20gXCIuL3VzZS1sYWJlbFwiO1xyXG5pbXBvcnQgeyBkZWJ1Z0xvZywgRW5oYW5jZWRFdmVudCwgZW5oYW5jZUV2ZW50LCBFdmVudERldGFpbCwgd2Fybk9uT3ZlcndyaXRlIH0gZnJvbSBcIi4vcHJvcHNcIjtcclxuaW1wb3J0IHsgVXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2UtaGFzLWZvY3VzXCI7XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgVGFic0NoYW5nZUV2ZW50PEUgZXh0ZW5kcyBFbGVtZW50PiA9IHsgW0V2ZW50RGV0YWlsXTogeyBzZWxlY3RlZEluZGV4OiBudW1iZXIgfSB9ICYgUGljazxoLkpTWC5UYXJnZXRlZEV2ZW50PEU+LCBcInRhcmdldFwiIHwgXCJjdXJyZW50VGFyZ2V0XCI+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJzUGFyYW1ldGVycyB7XHJcbiAgICB0YWJQYW5lbHM6IFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBuZXZlcj47XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8RSwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4sIFwic3ViSW5mb1wiPiB7XHJcbiAgICBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEU+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlBhbmVsUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8bnVtYmVyLCB7fSwgXCJ2aXNpYmxlXCIsIFwic3ViSW5mb1wiPiB7IH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+IHsgfVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlJldHVyblR5cGVXaXRoSG9va3M8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVGFiUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudD4ge1xyXG4gICAgdXNlVGFiUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiTGFiZWxQYXJhbWV0ZXJzIHsgfVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYkxpc3RQYXJhbWV0ZXJzPFRhYkVsZW1lbnQgZXh0ZW5kcyBFdmVudFRhcmdldD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8bmV2ZXIgfCBcIm9uU2VsZWN0ZWRJbmRleENoYW5nZVwiLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+IHtcclxuICAgIHRhYnM6IHsgb25TZWxlY3RlZEluZGV4Q2hhbmdlKGU6IEVuaGFuY2VkRXZlbnQ8VGFiRWxlbWVudCwgRXZlbnQsIHsgc2VsZWN0ZWRJbmRleDogbnVtYmVyIH0+KTogdm9pZDsgfTtcclxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnNbXCJjaGlsZHJlbkhhdmVGb2N1c1wiXTtcclxuXHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJMaXN0UmV0dXJuVHlwZUluZm88VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcclxuICAgIHRhYkxpc3Q6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudCwgVGFiSW5mbywgbmV2ZXI+O1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFiTGlzdFJldHVyblR5cGVXaXRoSG9va3M8VGFiQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRhYkxpc3RSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PiB7XHJcbiAgICB1c2VUYWJMaXN0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiQ29udGFpbmVyRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYkNvbnRhaW5lckVsZW1lbnQ+O1xyXG4gICAgdXNlVGFiOiAoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCB9OiBVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+KSA9PiBVc2VUYWJSZXR1cm5UeXBlV2l0aEhvb2tzPFRhYkVsZW1lbnQ+XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlBhbmVsUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdGFiUGFuZWw6IHsgdmlzaWJsZTogYm9vbGVhbjsgZ2V0VmlzaWJsZTogKCkgPT4gYm9vbGVhbjsgfTtcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYlBhbmVsUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRhYlBhbmVsUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlVGFiUGFuZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJMaXN0TGFiZWxSZXR1cm5UeXBlSW5mbyB7IH1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJMYWJlbFJldHVyblR5cGVXaXRoSG9va3M8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUYWJMaXN0TGFiZWxSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB1c2VUYWJMaXN0TGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYnNSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB0YWJQYW5lbHM6IFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPG51bWJlciwgVGFiUGFuZWxJbmZvLCBuZXZlcj47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFic1JldHVyblR5cGVXaXRoSG9va3M8VGFiQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRhYnNSZXR1cm5UeXBlSW5mbyB7XHJcbiAgICB1c2VUYWJMaXN0OiBVc2VUYWJMaXN0PFRhYkNvbnRhaW5lckVsZW1lbnQsIFRhYkVsZW1lbnQ+O1xyXG4gICAgdXNlVGFiUGFuZWw6IFVzZVRhYlBhbmVsPFBhbmVsRWxlbWVudD47XHJcbiAgICB1c2VUYWJMaXN0TGFiZWw6IFVzZVRhYkxpc3RMYWJlbDxMYWJlbEVsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VUYWI8VGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4pID0+IFVzZVRhYlJldHVyblR5cGVXaXRoSG9va3M8VGFiRWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZVRhYkxpc3Q8VGFiQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PikgPT4gVXNlVGFiTGlzdFJldHVyblR5cGVXaXRoSG9va3M8VGFiQ29udGFpbmVyRWxlbWVudCwgVGFiRWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZVRhYlBhbmVsPFBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKGFyZ3M6IFVzZVRhYlBhbmVsUGFyYW1ldGVycykgPT4gVXNlVGFiUGFuZWxSZXR1cm5UeXBlV2l0aEhvb2tzPFBhbmVsRWxlbWVudD47XHJcbmV4cG9ydCB0eXBlIFVzZVRhYkxpc3RMYWJlbDxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VUYWJMYWJlbFBhcmFtZXRlcnMpID0+IFVzZVRhYkxhYmVsUmV0dXJuVHlwZVdpdGhIb29rczxMYWJlbEVsZW1lbnQ+O1xyXG4vKlxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGFiczxUYWJMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhYlBhbmVsczogeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY21jLCAuLi50YWJQYW5lbHNNYW5hZ2VkQ2hpbGRyZW4gfSB9IH06IFVzZVRhYnNQYXJhbWV0ZXJzKTogVXNlVGFic1JldHVyblR5cGVXaXRoSG9va3M8VGFiTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFBhbmVsRWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XHJcbiAgICBjb25zdCB7IFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsIFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMgXHJcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248VGFiTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFRhYkluZm8sIG5ldmVyPih7IFxyXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7fSwgXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sIFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7fSwgXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7fSwgXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHt9LCBcclxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHt9LCBcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7fVxyXG4gICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZVRhYiA9IHVzZUNhbGxiYWNrKCgpID0+IHt9LCBbXSk7XHJcbiAgICBjb25zdCB1c2VUYWJQYW5lbCA9IHVzZUNhbGxiYWNrKCgpID0+IHt9KTtcclxuICAgIGZ1bmN0aW9uIHVzZVRhYkxpc3RQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiTGlzdEVsZW1lbnQ+KSB7IHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHByb3BzKTsgfVxyXG4gICAgZnVuY3Rpb24gdXNlVGFiTGFiZWxQcm9wcygpIHt9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuXHJcbiAgICB9XHJcbiAgICBcclxufSovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGFiczxUYWJMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhYlBhbmVsczogeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY21jLCAuLi50YWJQYW5lbHNNYW5hZ2VkQ2hpbGRyZW4gfSB9IH06IFVzZVRhYnNQYXJhbWV0ZXJzKTogVXNlVGFic1JldHVyblR5cGVXaXRoSG9va3M8VGFiTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQsIFBhbmVsRWxlbWVudCwgTGFiZWxFbGVtZW50PiB7XHJcblxyXG4gICAgZGVidWdMb2coXCJ1c2VUYWJzXCIpO1xyXG5cclxuXHJcbiAgICBjb25zdCBiYXNlSWQgPSBnZW5lcmF0ZVJhbmRvbUlkKFwiYXJpYS10YWJzLVwiKTtcclxuICAgIC8vY29uc3QgZ2V0VGFiTGlzdElkID0gdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gYmFzZUlkICsgXCItdGFiLWxpc3RcIjsgfSwgW10pO1xyXG4gICAgY29uc3QgZ2V0VGFiSWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4geyByZXR1cm4gYmFzZUlkICsgXCItdGFiLVwiICsgaW5kZXg7IH0sIFtdKTtcclxuICAgIGNvbnN0IGdldFBhbmVsSWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlcikgPT4geyByZXR1cm4gYmFzZUlkICsgXCItcGFuZWwtXCIgKyBpbmRleDsgfSwgW10pO1xyXG5cclxuICAgIC8vIFVzZWQgZm9yIHRoZSBwYW5lbHMsIG5vdCB0aGUgdGFicyBpbiB0aGUgdGFibGlzdC5cclxuICAgIC8vIFRob3NlIGFyZSBpbiB1c2VUYWJMaXN0IGl0c2VsZi5cclxuICAgIGNvbnN0IHsgdXNlTWFuYWdlZENoaWxkLCAuLi5tYW5hZ2VkQ2hpbGRyZW5SZXQgfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIFRhYlBhbmVsSW5mbywgXCJ2aXNpYmxlXCI+KHsgbWFuYWdlZENoaWxkcmVuOiB7IC4uLnRhYlBhbmVsc01hbmFnZWRDaGlsZHJlbiwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPbkNoaWxkcmVuTW91bnRDaGFuZ2U8bnVtYmVyPj4oKG0sIHUpID0+IHsgb2NtYz8uKG0sIHUpOyByZWV2YWx1YXRlQ2xvc2VzdEZpdCgpOyB9KSB9IH0pO1xyXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleDogY2hhbmdlVmlzaWJsZVBhbmVsLCBnZXRDdXJyZW50SW5kZXg6IGdldFZpc2libGVJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgfSA9IHVzZUNoaWxkcmVuRmxhZyh7IGNoaWxkcmVuOiBtYW5hZ2VkQ2hpbGRyZW5SZXQubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLCBjbG9zZXN0Rml0OiBmYWxzZSwgaW5pdGlhbEluZGV4OiBudWxsLCBrZXk6IFwidmlzaWJsZVwiIH0pO1xyXG5cclxuICAgIC8vY29uc3QgeyB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50LCB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQgfSA9IHVzZVJhbmRvbUlkKHsgcmFuZG9tSWQ6IHsgcHJlZml4OiBcImFyaWEtdGFicy1cIiB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGwgfSB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZUxhYmVsSW5wdXQsIHVzZUxhYmVsTGFiZWwgfSA9IHVzZUxhYmVsPFRhYkxpc3RFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHsgbGFiZWw6IHsgcHJlZml4SW5wdXQ6IFwiXCIsIHByZWZpeExhYmVsOiBcIlwiLCB0YWdJbnB1dDogXCJkaXZcIiBhcyBhbnksIHRhZ0xhYmVsOiBcImRpdlwiIGFzIGFueSB9IH0pO1xyXG5cclxuXHJcbiAgICBjb25zdCB1c2VUYWJMaXN0TGFiZWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyB1c2VMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUxhYmVsTGFiZWwoKTtcclxuICAgICAgICBmdW5jdGlvbiB1c2VUYWJMaXN0TGFiZWxQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PikgeyByZXR1cm4gdXNlTGFiZWxMYWJlbFByb3BzKHByb3BzKTsgfVxyXG4gICAgICAgIHJldHVybiB7IHVzZVRhYkxpc3RMYWJlbFByb3BzIH07XHJcbiAgICB9LCBbdXNlTGFiZWxMYWJlbF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZVRhYkxpc3QgPSB1c2VDYWxsYmFjazxVc2VUYWJMaXN0PFRhYkxpc3RFbGVtZW50LCBUYWJFbGVtZW50Pj4oKHsgY2hpbGRyZW5IYXZlRm9jdXMsIHRhYnM6IHsgb25TZWxlY3RlZEluZGV4Q2hhbmdlIH0sIGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW46IHRhYkxpc3RNYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24sIHR5cGVhaGVhZE5hdmlnYXRpb24gfSkgPT4ge1xyXG4gICAgICAgIGRlYnVnTG9nKFwidXNlVGFiTGlzdFwiKTtcclxuICAgICAgICBjb25zdCBzdGFibGVPblNlbGVjdGVkSW5kZXhDaGFuZ2UgPSB1c2VTdGFibGVDYWxsYmFjayhvblNlbGVjdGVkSW5kZXhDaGFuZ2UpO1xyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXHJcbiAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXHJcbiAgICAgICAgICAgIC4uLmxpc3ROYXZSZXQxXHJcbiAgICAgICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFRhYkxpc3RFbGVtZW50LCBUYWJFbGVtZW50LCBUYWJJbmZvLCBuZXZlcj4oe1xyXG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbixcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB0YWJMaXN0TWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5zaW5nbGVTZWxlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBvblNlbGVjdGVkSW5kZXhDaGFuZ2U6IHVzZUNhbGxiYWNrKChldmVudDogRXZlbnQsIGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGVkSW5kZXhDaGFuZ2U/LihlbmhhbmNlRXZlbnQ8VGFiRWxlbWVudCwgRXZlbnQsIHsgc2VsZWN0ZWRJbmRleDogbnVtYmVyIH0+KGV2ZW50LCB7IHNlbGVjdGVkSW5kZXg6IGluZGV4IH0pKVxyXG4gICAgICAgICAgICAgICAgfSwgW10pXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb24sXHJcbiAgICAgICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGNoYW5nZVZpc2libGVQYW5lbChzaW5nbGVTZWxlY3Rpb24uc2VsZWN0ZWRJbmRleCk7XHJcbiAgICAgICAgfSwgW3NpbmdsZVNlbGVjdGlvbi5zZWxlY3RlZEluZGV4XSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgdXNlTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VMYWJlbElucHV0KClcclxuXHJcbiAgICAgICAgY29uc3QgdXNlVGFiID0gdXNlQ2FsbGJhY2s8VXNlVGFiPFRhYkVsZW1lbnQ+PigoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgaGFzRm9jdXMgfTogVXNlVGFiUGFyYW1ldGVyczxUYWJFbGVtZW50Pik6IFVzZVRhYlJldHVyblR5cGVXaXRoSG9va3M8VGFiRWxlbWVudD4gPT4ge1xyXG4gICAgICAgICAgICBkZWJ1Z0xvZyhcInVzZVRhYlwiLCBtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG4gICAgICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcywgLi4ubGlzdE5hdlJldDIgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQoeyBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkLCByb3ZpbmdUYWJJbmRleCwgc3ViSW5mbzoge30sIGhhc0ZvY3VzIH0pO1xyXG4gICAgICAgICAgICBjb25zdCB7IHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZCB9LCByb3ZpbmdUYWJJbmRleDogeyB0YWJiYWJsZSB9IH0gPSBsaXN0TmF2UmV0MjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVzZVRhYlByb3BzID0gKHsgcm9sZSwgXCJhcmlhLWNvbnRyb2xzXCI6IGFyaWFDb250cm9scywgXCJhcmlhLXNlbGVjdGVkXCI6IGFyaWFTZWxlY3RlZCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4pID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmVsSWQgPSBnZXRQYW5lbElkKG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJJZCA9IGdldFRhYklkKG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlUHJlc3NQcm9wcyA9IHVzZVByZXNzPFRhYkVsZW1lbnQ+KChlKSA9PiB7IHN0YWJsZU9uU2VsZWN0ZWRJbmRleENoYW5nZShlbmhhbmNlRXZlbnQoZSwgeyBzZWxlY3RlZEluZGV4OiBtYW5hZ2VkQ2hpbGQuaW5kZXggfSkpIH0sIHt9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzKHVzZU1lcmdlZFByb3BzKHtcclxuICAgICAgICAgICAgICAgICAgICByb2xlOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJcIiwgXCJyb2xlXCIsIHJvbGUsIFwidGFiXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJcIiwgXCJhcmlhQ29udHJvbHNcIiwgYXJpYUNvbnRyb2xzLCBwYW5lbElkKSxcclxuICAgICAgICAgICAgICAgICAgICBcImFyaWEtc2VsZWN0ZWRcIjogd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFiXCIsIFwiYXJpYVNlbGVjdGVkXCIsIGFyaWFTZWxlY3RlZCwgc2VsZWN0ZWQgPyBcInRydWVcIiA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXRhYmJhYmxlXCI6IHRhYmJhYmxlLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRhYklkXHJcbiAgICAgICAgICAgICAgICB9IGFzIHt9LCB1c2VQcmVzc1Byb3BzKHByb3BzKSkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdXNlVGFiUHJvcHMsXHJcbiAgICAgICAgICAgICAgICAuLi5saXN0TmF2UmV0MlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW3VzZUxhYmVsSW5wdXQsIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRdKTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlVGFiTGlzdFByb3BzID0gKHsgcm9sZSwgXCJhcmlhLW9yaWVudGF0aW9uXCI6IGFyaWFPcmllbnRhdGlvbiwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiTGlzdEVsZW1lbnQ+KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHVzZUxhYmVsSW5wdXRQcm9wcyh1c2VNZXJnZWRQcm9wcyh7XHJcbiAgICAgICAgICAgICAgICByb2xlOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJMaXN0XCIsIFwicm9sZVwiLCByb2xlLCBcInRhYmxpc3RcIiksXHJcbiAgICAgICAgICAgICAgICBcImFyaWEtb3JpZW50YXRpb25cIjogYXJpYU9yaWVudGF0aW9uID8/IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICB9IGFzIHt9LFxyXG4gICAgICAgICAgICAgICAgcHJvcHMpKSlcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0YWJMaXN0OiBsaXN0TmF2UmV0MSxcclxuICAgICAgICAgICAgdXNlVGFiTGlzdFByb3BzLFxyXG4gICAgICAgICAgICB1c2VUYWJcclxuICAgICAgICB9XHJcbiAgICB9LCBbdXNlTGFiZWxJbnB1dF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZVRhYlBhbmVsID0gdXNlQ2FsbGJhY2soKHsgbWFuYWdlZENoaWxkOiB7IGZsYWdzLCAuLi5tYW5hZ2VkQ2hpbGQgfSB9OiBVc2VUYWJQYW5lbFBhcmFtZXRlcnMpID0+IHtcclxuICAgICAgICBkZWJ1Z0xvZyhcInVzZVRhYlBhbmVsXCIsIG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcbiAgICAgICAgLy9jb25zdCBbY29ycmVzcG9uZGluZ1RhYklkLCBzZXRDb3JyZXNwb25kaW5nVGFiSWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgICAgICAgY29uc3QgW2lzVmlzaWJsZSwgc2V0SXNWaXNpYmxlLCBnZXRJc1Zpc2libGVdID0gdXNlU3RhdGUoZ2V0VmlzaWJsZUluZGV4KCkgPT0gbWFuYWdlZENoaWxkLmluZGV4KTtcclxuICAgICAgICBjb25zdCB2aXNpYmxlUmVmID0gdXNlUmVmPENoaWxkRmxhZ09wZXJhdGlvbnM+KHsgZ2V0OiBnZXRJc1Zpc2libGUsIHNldDogc2V0SXNWaXNpYmxlLCBpc1ZhbGlkOiByZXR1cm5UcnVlIH0pO1xyXG4gICAgICAgIHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyAuLi5tYW5hZ2VkQ2hpbGQsIGZsYWdzOiB7IHZpc2libGU6IHZpc2libGVSZWYuY3VycmVudCwgLi4uZmxhZ3MgfSwgc3ViSW5mbzoge30gfSB9KTtcclxuICAgICAgICBjb25zdCBwYW5lbElkID0gZ2V0UGFuZWxJZChtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IHRhYklkID0gZ2V0VGFiSWQobWFuYWdlZENoaWxkLmluZGV4KTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlVGFiUGFuZWxQcm9wcyA9ICh7IHJvbGUsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZEJ5LCBpZCwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFuZWxFbGVtZW50PikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHMoe1xyXG4gICAgICAgICAgICAgICAgcm9sZTogd2Fybk9uT3ZlcndyaXRlKFwidXNlVGFiUGFuZWxQcm9wc1wiLCBcInJvbGVcIiwgcm9sZSwgXCJ0YWJwYW5lbFwiKSxcclxuICAgICAgICAgICAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHdhcm5Pbk92ZXJ3cml0ZShcInVzZVRhYlBhbmVsUHJvcHNcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIiwgYXJpYUxhYmVsbGVkQnksIHRhYklkKSxcclxuICAgICAgICAgICAgICAgIGlkOiB3YXJuT25PdmVyd3JpdGUoXCJ1c2VUYWJQYW5lbFByb3BzXCIsIFwiaWRcIiwgaWQsIHBhbmVsSWQpXHJcbiAgICAgICAgICAgIH0gYXMge30sIHByb3BzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZVRhYlBhbmVsUHJvcHMsXHJcbiAgICAgICAgICAgIHRhYlBhbmVsOiB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiBpc1Zpc2libGUsXHJcbiAgICAgICAgICAgICAgICBnZXRWaXNpYmxlOiBnZXRJc1Zpc2libGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVRhYkxpc3RMYWJlbCxcclxuICAgICAgICB1c2VUYWJMaXN0LFxyXG4gICAgICAgIHVzZVRhYlBhbmVsLFxyXG4gICAgICAgIHRhYlBhbmVsczogbWFuYWdlZENoaWxkcmVuUmV0XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5pbnRlcmZhY2UgVGFiUGFuZWxJbmZvIHtcclxuICAgIC8vc2V0Q29ycmVzcG9uZGluZ1RhYklkKHRhYklkOiBzdHJpbmcpOiB2b2lkO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVGFiSW5mbyB7XHJcbiAgICAvL3NldENvcnJlc3BvbmRpbmdQYW5lbElkKHRhYklkOiBzdHJpbmcpOiB2b2lkO1xyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VHbG9iYWxIYW5kbGVyLCB1c2VIYXNGb2N1cywgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzLCB1c2VNZXJnZWRQcm9wcywgdXNlUGFzc2l2ZVN0YXRlLCB1c2VSYW5kb21JZCwgdXNlU3RhYmxlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZyB9IGZyb20gXCIuL3Byb3BzXCI7XG5cbmV4cG9ydCB0eXBlIFVzZVRvb2x0aXBUcmlnZ2VyPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudD4gPSAoYXJnczogeyBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPFRyaWdnZXJUeXBlPiB9KSA9PiB7IHVzZVRvb2x0aXBUcmlnZ2VyUHJvcHM6ICh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRyaWdnZXJUeXBlPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+IH07XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvb2x0aXBQYXJhbWV0ZXJzIHsgbW91c2VvdmVyRGVsYXk/OiBudW1iZXIsIG1vdXNlb3V0RGVsYXk/OiBudW1iZXIsIGZvY3VzRGVsYXk/OiBudW1iZXIgfVxuZXhwb3J0IHR5cGUgVXNlVG9vbHRpcDxUcmlnZ2VyVHlwZSBleHRlbmRzIEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudCwgVG9vbHRpcFR5cGUgZXh0ZW5kcyBFbGVtZW50PiA9IChhcmdzOiBVc2VUb29sdGlwUGFyYW1ldGVycykgPT4gVXNlVG9vbHRpcFJldHVyblR5cGVXaXRoSG9va3M8VHJpZ2dlclR5cGUsIFRvb2x0aXBUeXBlPjtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVG9vbHRpcFJldHVyblR5cGVJbmZvIHtcbiAgICBpc09wZW46IGJvb2xlYW47XG4gICAgZ2V0SXNPcGVuOiAoKSA9PiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRvb2x0aXBSZXR1cm5UeXBlV2l0aEhvb2tzPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudCwgUG9wdXBUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8ge1xuICAgIHVzZVRvb2x0aXBQb3B1cDogKGFyZ3M6IHsgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxQb3B1cFR5cGU+IH0pID0+IHtcbiAgICAgICAgdXNlVG9vbHRpcFBvcHVwUHJvcHM6ICh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwVHlwZT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBvcHVwVHlwZT47XG4gICAgfTtcbiAgICB1c2VUb29sdGlwVHJpZ2dlcjogVXNlVG9vbHRpcFRyaWdnZXI8VHJpZ2dlclR5cGU+O1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUb29sdGlwPFRyaWdnZXJUeXBlIGV4dGVuZHMgRWxlbWVudCwgUG9wdXBUeXBlIGV4dGVuZHMgRWxlbWVudD4oeyBtb3VzZW92ZXJEZWxheSwgbW91c2VvdXREZWxheSwgZm9jdXNEZWxheSB9OiBVc2VUb29sdGlwUGFyYW1ldGVycyk6IFVzZVRvb2x0aXBSZXR1cm5UeXBlV2l0aEhvb2tzPFRyaWdnZXJUeXBlLCBQb3B1cFR5cGU+IHtcbiAgICBkZWJ1Z0xvZyhcInVzZVRvb2x0aXBcIik7XG5cbiAgICBtb3VzZW92ZXJEZWxheSA/Pz0gNDAwO1xuICAgIG1vdXNlb3V0RGVsYXkgPz89IDQwO1xuICAgIGZvY3VzRGVsYXkgPz89IDE7XG5cbiAgICAvLyBUaGUgZXNjYXBlIGtleSBzaG91bGQgY2xvc2UgdG9vbHRpcHMsIGJ1dCBkbyBub3RoaW5nIGVsc2UuXG4gICAgLy8gKGkuZS4gY2xvc2luZyBhIHRvb2x0aXAgaW4gYSBkaWFsb2cgTVVTVCBOT1QgY2xvc2UgdGhlIGRpYWxvZyB0b28pXG4gICAgLy8gVE9ETzogVG9vbHRpcHMgYXJlLCBlZmZlY3RpdmVseSwgYWx3YXlzIHRoZSB0b3Btb3N0IGNvbXBvbmVudCxcbiAgICAvLyBzbyB3ZSBjYW4ganVzdCBoYXZlIHRoZW0gbGlzdGVuIHRvIGFuZCBzd2FsbG93IGFsbCBcIkVzY2FwZVwiXG4gICAgLy8ga2V5IHByZXNzZXMgYmVmb3JlIGFueW9uZSBlbHNlLiBGb3IgYSBtb3JlIGdlbmVyYWwgcG9wdXAsXG4gICAgLy8gb3IgYSB0b29sdGlwIGluIGEgdG9vbHRpcCAoISEpIGEgZGlmZmVyZW50IHNvbHV0aW9uIHdvdWxkIGJlIG5lZWRlZC5cbiAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcImtleWRvd25cIiwgKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGdldE9wZW4oKSAmJiBlLmtleSA9PT0gXCJFc2NhcGVcIiAmJiAhZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgc2V0T3BlbihmYWxzZSk7XG4gICAgICAgICAgICBzZXRUcmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICBzZXRUb29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuXG4gICAgY29uc3QgW29wZW4sIHNldE9wZW4sIGdldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnQsLy86IHVzZVRvb2x0aXBJZFByb3BzLCBcbiAgICAgICAgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCwvLzogdXNlVG9vbHRpcElkUmVmZXJlbmNpbmdQcm9wcyBcbiAgICB9ID0gdXNlUmFuZG9tSWQ8UG9wdXBUeXBlPih7IHJhbmRvbUlkOiB7IHByZWZpeDogXCJhcmlhLXRvb2x0aXAtXCIgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDogbnVsbCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBudWxsIH0gfSk7XG5cbiAgICBjb25zdCBbLCBzZXRUcmlnZ2VyRm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDE7XG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUcmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZvY3VzZWQpLCBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDEpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgfSksIHJldHVybkZhbHNlKTtcbiAgICBjb25zdCBbLCBzZXRUb29sdGlwRm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBmb2N1c2VkID8gZm9jdXNEZWxheSA6IDE7XG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUb29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkKGZvY3VzZWQpLCBkZWxheSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgIH1cbiAgICB9KSwgcmV0dXJuRmFsc2UpO1xuICAgIGNvbnN0IFssIHNldFRyaWdnZXJIb3Zlcl0gPSB1c2VQYXNzaXZlU3RhdGUodXNlU3RhYmxlQ2FsbGJhY2soKGhvdmVyaW5nOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gaG92ZXJpbmcgPyBtb3VzZW92ZXJEZWxheSA6IG1vdXNlb3V0RGVsYXk7XG4gICAgICAgIGlmIChkZWxheSAhPSBudWxsICYmIGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiBzZXRUcmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZChob3ZlcmluZyksIGRlbGF5KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH0pLCByZXR1cm5GYWxzZSk7XG4gICAgY29uc3QgWywgc2V0VG9vbHRpcEhvdmVyXSA9IHVzZVBhc3NpdmVTdGF0ZSh1c2VTdGFibGVDYWxsYmFjaygoaG92ZXJpbmc6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSBob3ZlcmluZyA/IG1vdXNlb3ZlckRlbGF5IDogbW91c2VvdXREZWxheTtcbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgJiYgaXNGaW5pdGUoZGVsYXkpKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHNldFRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkKGhvdmVyaW5nKSwgZGVsYXkpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgfSksIHJldHVybkZhbHNlKTtcbiAgICBjb25zdCBbdHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCwgc2V0VHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3RyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkLCBzZXRUcmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3Rvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQsIHNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFt0b29sdGlwSG92ZXJEZWxheUNvcnJlY3RlZCwgc2V0VG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0T3Blbih0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIHx8IHRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkIHx8IHRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQpO1xuICAgIH0sIFt0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIHx8IHRyaWdnZXJIb3ZlckRlbGF5Q29ycmVjdGVkIHx8IHRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQgfHwgdG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWRdKVxuXG4gICAgY29uc3QgdXNlVG9vbHRpcFRyaWdnZXI6IFVzZVRvb2x0aXBUcmlnZ2VyPFRyaWdnZXJUeXBlPiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIHVzZVRvb2x0aXBUcmlnZ2VyKHsgaGFzRm9jdXM6IHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCAuLi5oYXNGb2N1cyB9IH06IHsgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxUcmlnZ2VyVHlwZT4gfSkge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZVRvb2x0aXBUcmlnZ2VyXCIpO1xuXG4gICAgICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwicG9pbnRlcm1vdmVcIiwgZSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0VHJpZ2dlckhvdmVyKHRhcmdldCA9PSBnZXRFbGVtZW50KCkgYXMgTm9kZSB8fCAhIWdldEVsZW1lbnQoKT8uY29udGFpbnModGFyZ2V0KSk7XG4gICAgICAgIH0sIHsgY2FwdHVyZTogdHJ1ZSB9KTtcblxuICAgICAgICBmdW5jdGlvbiBvblRvdWNoRW5kKGU6IFRvdWNoRXZlbnQpIHtcbiAgICAgICAgICAgIChlLnRhcmdldCBhcyBhbnkpLmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUhhc0ZvY3VzPFRyaWdnZXJUeXBlPih7XG4gICAgICAgICAgICAuLi5oYXNGb2N1cyxcbiAgICAgICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZm9jdXNlZCwgcHJldik7IHNldFRyaWdnZXJGb2N1c2VkKGZvY3VzZWQpIH0pXG4gICAgICAgIH0pXG5cblxuICAgICAgICBmdW5jdGlvbiB1c2VUb29sdGlwVHJpZ2dlclByb3BzKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIH0gPSB1c2VSYW5kb21JZFJlZmVyZW5jZXJFbGVtZW50PFRyaWdnZXJUeXBlPihcImFyaWEtZGVzY3JpYmVkYnlcIiBhcyBuZXZlcik7XG4gICAgICAgICAgICAvLyBOb3RlOiBUaG91Z2ggaXQncyBpbXBvcnRhbnQgdG8gbWFrZSBzdXJlIHRoYXQgZm9jdXNpbmcgYWN0aXZhdGVzIGEgdG9vbHRpcCxcbiAgICAgICAgICAgIC8vIGl0J3MgcGVyZmVjdGx5IHJlYXNvbmFibGUgdGhhdCBhIGNoaWxkIGVsZW1lbnQgd2lsbCBiZSB0aGUgb25lIHRoYXQncyBmb2N1c2VkLFxuICAgICAgICAgICAgLy8gbm90IHRoaXMgb25lLCBzbyB3ZSBkb24ndCBzZXQgdGFiSW5kZXg9MFxuICAgICAgICAgICAgcHJvcHMudGFiSW5kZXggPz89IC0xO1xuICAgICAgICAgICAgcmV0dXJuIHVzZVJhbmRvbUlkUmVmZXJlbmNlckVsZW1lbnRQcm9wcyhcbiAgICAgICAgICAgICAgICB1c2VIYXNGb2N1c1Byb3BzKFxuICAgICAgICAgICAgICAgICAgICB1c2VNZXJnZWRQcm9wczxUcmlnZ2VyVHlwZT4oeyBvblRvdWNoRW5kIH0sIChwcm9wcyBhcyBhbnkpIGFzIHVua25vd24gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8VHJpZ2dlclR5cGU+KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB1c2VUb29sdGlwVHJpZ2dlclByb3BzIH07XG5cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB1c2VUb29sdGlwUG9wdXAgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiB1c2VUb29sdGlwKHsgaGFzRm9jdXM6IHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCAuLi5oYXNGb2N1cyB9IH06IHsgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxQb3B1cFR5cGU+IH0pIHtcbiAgICAgICAgZGVidWdMb2coXCJ1c2VUb29sdGlwVG9vbHRpcFwiKTtcbiAgICAgICAgY29uc3QgeyB1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyB9ID0gdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlSGFzRm9jdXM8UG9wdXBUeXBlPih7IG9uRm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZm9jdXNlZCwgcHJldik7IHNldFRvb2x0aXBGb2N1c2VkKGZvY3VzZWQpOyB9KSwgLi4uaGFzRm9jdXMgfSlcblxuICAgICAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInBvaW50ZXJtb3ZlXCIsIGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIHNldFRvb2x0aXBIb3Zlcih0YXJnZXQgPT0gZ2V0RWxlbWVudCgpIGFzIE5vZGUgfHwgISFnZXRFbGVtZW50KCk/LmNvbnRhaW5zKHRhcmdldCkpO1xuICAgICAgICB9LCB7IGNhcHR1cmU6IHRydWUgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gdXNlVG9vbHRpcFBvcHVwUHJvcHMoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxQb3B1cFR5cGU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UG9wdXBUeXBlPiB7XG4gICAgICAgICAgICByZXR1cm4gdXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50UHJvcHModXNlSGFzRm9jdXNQcm9wcyh1c2VNZXJnZWRQcm9wczxQb3B1cFR5cGU+KHt9LCBwcm9wcykpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHVzZVRvb2x0aXBQb3B1cFByb3BzIH07XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlVG9vbHRpcFBvcHVwLFxuICAgICAgICB1c2VUb29sdGlwVHJpZ2dlcixcbiAgICAgICAgaXNPcGVuOiBvcGVuLFxuICAgICAgICBnZXRJc09wZW46IGdldE9wZW5cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uLCBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbywgdXNlTWVyZ2VkUHJvcHMsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YWJsZUNhbGxiYWNrLCB1c2VTdGFibGVHZXR0ZXIsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycywgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWhhcy1mb2N1c1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBkZWJ1Z0xvZywgRWxlbWVudFRvVGFnLCBFbmhhbmNlZEV2ZW50LCBlbmhhbmNlRXZlbnQsIFRhZ1NlbnNpdGl2ZVByb3BzIH0gZnJvbSBcIi4vcHJvcHNcIjtcbmltcG9ydCB7IHVzZUNoZWNrYm94TGlrZSwgdXNlTGFiZWwgfSBmcm9tIFwiLi91c2UtbGFiZWxcIjtcblxuLy90eXBlIE9taXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gUGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+PjtcbmV4cG9ydCB0eXBlIFJhZGlvQ2hhbmdlRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBWIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nPiA9IEVuaGFuY2VkRXZlbnQ8RSwgRXZlbnQsIHsgc2VsZWN0ZWRWYWx1ZTogViB8IHVuZGVmaW5lZCB9PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHcm91cEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFwic2VsZWN0ZWRJbmRleFwiIHwgXCJvblNlbGVjdGVkSW5kZXhDaGFuZ2VcIiwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7XG4gICAgcmFkaW9Hcm91cDoge1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG5cbiAgICAgICAgc2VsZWN0ZWRWYWx1ZTogViB8IG51bGw7XG4gICAgICAgIG9uU2VsZWN0ZWRWYWx1ZUNoYW5nZShldmVudDogUmFkaW9DaGFuZ2VFdmVudDxJbnB1dEVsZW1lbnQsIFY+KTogdm9pZDtcbiAgICAgICAgLy9vbklucHV0KGV2ZW50OiBSYWRpb0NoYW5nZUV2ZW50PGguSlNYLlRhcmdldGVkRXZlbnQ8TGFiZWxFbGVtZW50PiwgVj4pOiB2b2lkO1xuICAgICAgICB0YWdHcm91cDogRWxlbWVudFRvVGFnPEdyb3VwRWxlbWVudD47XG4gICAgICAgIHRhZ0dyb3VwTGFiZWw6IEVsZW1lbnRUb1RhZzxHcm91cExhYmVsRWxlbWVudD47XG4gICAgfVxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnNbXCJjaGlsZHJlbkhhdmVGb2N1c1wiXTtcbn1cblxuLypleHBvcnQgaW50ZXJmYWNlIFVzZVJhZGlvSW5mb0Jhc2UgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkSW5mb0Jhc2U8XCJ0YWJiYWJsZVwiIHwgXCJzZWxlY3RlZFwiPiB7XG4gICAgc2V0Q2hlY2tlZChjaGVja2VkOiBib29sZWFuKTogdm9pZDtcbiAgICBnZXRDaGVja2VkKCk6IGJvb2xlYW4gfCBudWxsO1xufSovXG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmFkaW9QYXJhbWV0ZXJzPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEkgZXh0ZW5kcyBFbGVtZW50LCBJTCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczx7fSwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiwgXCJzdWJJbmZvXCI+IHtcbiAgICByYWRpbzoge1xuICAgICAgICBsYWJlbFBvc2l0aW9uOiBcIndyYXBwaW5nXCIgfCBcInNlcGFyYXRlXCI7XG4gICAgICAgIHZhbHVlOiBWO1xuICAgICAgICBkaXNhYmxlZDogYm9vbGVhbjtcbiAgICAgICAgdGFnSW5wdXQ6IEVsZW1lbnRUb1RhZzxJPjtcbiAgICAgICAgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxJTD47XG4gICAgfVxuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8ST47XG4gICAgLypPbWl0PFVzZUNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgSUw+LCBcIm9uSW5wdXRcIiB8IFwicm9sZVwiIHwgXCJjaGVja2VkXCI+ICYge1xuICAgICAgICBpbmZvOiBPbWl0PEluZm8sIFwic2V0Q2hlY2tlZFwiIHwgXCJnZXRDaGVja2VkXCIgfCBcImJsdXJTZWxmXCIgfCBcImdldEVsZW1lbnRcIiB8IFwiZm9jdXNTZWxmXCI+O1xuICAgICAgICBcbiAgICB9Ki9cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxJLCB7fSwgbmV2ZXI+IHtcbiAgICByYWRpb0dyb3VwOiB7XG4gICAgICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7XG4gICAgICAgIHNlbGVjdGVkVmFsdWU6IFYgfCBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZVdpdGhIb29rczxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHIGV4dGVuZHMgRWxlbWVudCwgR0wgZXh0ZW5kcyBFbGVtZW50LCBJIGV4dGVuZHMgRWxlbWVudCwgSUwgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88ViwgST4ge1xuICAgIHVzZVJhZGlvR3JvdXBMYWJlbFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEdMPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8R0w+O1xuICAgIHVzZVJhZGlvR3JvdXBQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxHPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rz47XG4gICAgdXNlUmFkaW86IFVzZVJhZGlvPFYsIEksIElMPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJhZGlvR3JvdXA8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgRyBleHRlbmRzIEVsZW1lbnQsIEdMIGV4dGVuZHMgRWxlbWVudCwgSSBleHRlbmRzIEVsZW1lbnQsIElMIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uLFxuICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgIG1hbmFnZWRDaGlsZHJlbixcbiAgICByYWRpb0dyb3VwOiB7IG5hbWUsIG9uU2VsZWN0ZWRWYWx1ZUNoYW5nZSwgc2VsZWN0ZWRWYWx1ZSwgdGFnR3JvdXAsIHRhZ0dyb3VwTGFiZWwgfSxcbiAgICByb3ZpbmdUYWJJbmRleCxcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzLFxuICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3Rpb25Nb2RlIH1cbn06IFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEcsIEdMLCBJPik6IFVzZVJhZGlvR3JvdXBSZXR1cm5UeXBlV2l0aEhvb2tzPFYsIEcsIEdMLCBJLCBJTD4ge1xuICAgIGRlYnVnTG9nKFwidXNlUmFkaW9Hcm91cFwiLCBzZWxlY3RlZFZhbHVlKTtcbiAgICBjb25zdCB7IGdldEVsZW1lbnQ6IF9nZXRSYWRpb0dyb3VwUGFyZW50RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PEc+KHt9KTtcblxuICAgIC8vY29uc3QgZ2V0U2VsZWN0ZWRJbmRleCA9IHVzZUNhbGxiYWNrKChzZWxlY3RlZFZhbHVlOiBWKSA9PiB7IHJldHVybiBieU5hbWUuY3VycmVudC5nZXQoc2VsZWN0ZWRWYWx1ZSkgPz8gMCB9LCBbXSlcblxuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KDApO1xuICAgIGNvbnN0IGJ5TmFtZSA9IHVzZVJlZihuZXcgTWFwPFYsIGFueT4oKSk7XG4gICAgLy9jb25zdCBzdGFibGVPbklucHV0ID0gdXNlU3RhYmxlQ2FsbGJhY2sob25TZWxlY3RlZFZhbHVlQ2hhbmdlKTtcblxuICAgIC8vY29uc3QgW2FueVJhZGlvc0ZvY3VzZWQsIHNldEFueVJhZGlvc0ZvY3VzZWQsIGdldEFueVJhZGlvc0ZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0OiB1c2VHcm91cExhYmVsSW5wdXQsIHVzZUxhYmVsTGFiZWw6IHVzZUdyb3VwTGFiZWxMYWJlbCB9ID0gdXNlTGFiZWw8RywgR0w+KHsgbGFiZWw6IHsgcHJlZml4TGFiZWw6IFwiYXJpYS1yYWRpby1ncm91cC1sYWJlbC1cIiwgdGFnSW5wdXQ6IHRhZ0dyb3VwIGFzIG5ldmVyLCB0YWdMYWJlbDogdGFnR3JvdXBMYWJlbCBhcyBuZXZlciwgcHJlZml4SW5wdXQ6IFwiYXJpYS1yYWRpby1ncm91cC1cIiB9IH0pXG4gICAgY29uc3QgeyB1c2VMYWJlbElucHV0UHJvcHM6IHVzZUdyb3VwTGFiZWxJbnB1dFByb3BzIH0gPSB1c2VHcm91cExhYmVsSW5wdXQoKTtcbiAgICBjb25zdCB7IHVzZUxhYmVsTGFiZWxQcm9wczogdXNlR3JvdXBMYWJlbExhYmVsUHJvcHMgfSA9IHVzZUdyb3VwTGFiZWxMYWJlbCgpO1xuXG4gICAgY29uc3Qgb25TZWxlY3RlZEluZGV4Q2hhbmdlID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IEV2ZW50LCBuZXdJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIG9uU2VsZWN0ZWRWYWx1ZUNoYW5nZShlbmhhbmNlRXZlbnQ8SSwgRXZlbnQsIHsgc2VsZWN0ZWRWYWx1ZTogViB8IHVuZGVmaW5lZCB9PihlLCB7IHNlbGVjdGVkVmFsdWU6IGxpc3ROYXZSZXQubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KG5ld0luZGV4KT8uc3ViSW5mby5zdWJJbmZvLnN1YkluZm8uZ2V0VmFsdWUoKSB9KSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXG4gICAgICAgIC4uLmxpc3ROYXZSZXRcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248RywgSSwgeyBnZXRWYWx1ZSgpOiBWIH0sIG5ldmVyPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWRJbmRleCwgb25TZWxlY3RlZEluZGV4Q2hhbmdlLCBzZWxlY3Rpb25Nb2RlIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb24sXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzXG4gICAgfSk7XG5cbiAgICAvLyBUcmFjayB3aGV0aGVyIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgdGhlIHJhZGlvIGdyb3VwIHBhcmVudCBlbGVtZW50LlxuICAgIC8vIFdoZW4gaXQncyBub3QsIHdlIHJlc2V0IHRoZSB0YWJiYWJsZSBpbmRleCBiYWNrIHRvIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZWxlbWVudC5cbiAgICAvL2NvbnN0IHsgdXNlQWN0aXZlRWxlbWVudFByb3BzIH0gPSB1c2VBY3RpdmVFbGVtZW50PEc+KHsgb25BY3RpdmVFbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoYWN0aXZlRWxlbWVudDogTm9kZSB8IG51bGwpID0+IHNldEFueVJhZGlvc0ZvY3VzZWQoISEoZ2V0UmFkaW9Hcm91cFBhcmVudEVsZW1lbnQoKT8uY29udGFpbnMoYWN0aXZlRWxlbWVudCkpKSwgW10pIH0pO1xuICAgIC8qdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFhbnlSYWRpb3NGb2N1c2VkKVxuICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KHNlbGVjdGVkSW5kZXggPz8gMCk7XG4gICAgfSwgW2FueVJhZGlvc0ZvY3VzZWQsIHNlbGVjdGVkSW5kZXgsIG5hdmlnYXRlVG9JbmRleF0pOyovXG5cblxuICAgIGNvbnN0IHVzZVJhZGlvR3JvdXBQcm9wcyA9IHVzZUNhbGxiYWNrKCh7IC4uLnByb3BzIH06IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEc+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Rz4gPT4ge1xuICAgICAgICBwcm9wcy5yb2xlID0gXCJyYWRpb2dyb3VwXCI7XG4gICAgICAgIHJldHVybiB1c2VHcm91cExhYmVsSW5wdXRQcm9wcyh1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wcykpKTtcbiAgICB9LCBbdXNlUmVmRWxlbWVudFByb3BzXSlcblxuICAgIGNvbnN0IHVzZVJhZGlvR3JvdXBMYWJlbFByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxHTD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxHTD4gPT4geyByZXR1cm4gdXNlR3JvdXBMYWJlbExhYmVsUHJvcHMocHJvcHMpOyB9LCBbdXNlR3JvdXBMYWJlbExhYmVsUHJvcHNdKTtcblxuICAgIC8vY29uc3QgY29ycmVjdGVkSW5kZXggPSAoc2VsZWN0ZWRJbmRleCA9PSBudWxsIHx8IHNlbGVjdGVkSW5kZXggPCAwIHx8IHNlbGVjdGVkSW5kZXggPj0gbWFuYWdlZENoaWxkcmVuLmxlbmd0aCkgPyBudWxsIDogc2VsZWN0ZWRJbmRleDtcbiAgICAvKmNvbnN0IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gPSB1c2VDaGlsZHJlbkZsYWcoe1xuICAgICAgICBpbml0aWFsSW5kZXg6IDAsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBrZXk6IFwic2VsZWN0ZWRcIlxuICAgICAgICAvL3NldENoaWxkRmxhZzogKGksIGNoZWNrZWQpID0+IG1hbmFnZWRDaGlsZHJlbltpXT8uc2V0Q2hlY2tlZChjaGVja2VkKSxcbiAgICAgICAgLy9nZXRDaGlsZEZsYWc6ICgoaSkgPT4gbWFuYWdlZENoaWxkcmVuW2ldPy5nZXRDaGVja2VkKCkgPz8gZmFsc2UpXG4gICAgfSk7Ki9cblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzZWxlY3RlZFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW5kZXgobnVsbClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSBieU5hbWUuY3VycmVudC5nZXQoc2VsZWN0ZWRWYWx1ZSk7XG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4KHNlbGVjdGVkSW5kZXggPz8gbnVsbCk7XG4gICAgICAgIH1cbiAgICB9LCBbYnlOYW1lLCBzZWxlY3RlZFZhbHVlXSk7XG5cblxuXG4gICAgY29uc3QgdXNlUmFkaW8gPSB1c2VDYWxsYmFjazxVc2VSYWRpbzxWLCBJLCBJTD4+KGZ1bmN0aW9uIHVzZVJhZGlvKHtcbiAgICAgICAgbGlzdE5hdmlnYXRpb24sXG4gICAgICAgIG1hbmFnZWRDaGlsZCxcbiAgICAgICAgcm92aW5nVGFiSW5kZXgsXG4gICAgICAgIGhhc0ZvY3VzLFxuICAgICAgICByYWRpbzogeyBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsLCB2YWx1ZSB9XG4gICAgfSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IG1hbmFnZWRDaGlsZC5pbmRleDtcbiAgICAgICAgZGVidWdMb2coXCJ1c2VSYWRpb1wiLCBpbmRleCk7XG4gICAgICAgIC8vY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWQsIGdldENoZWNrZWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KG51bGwpO1xuXG4gICAgICAgIGNvbnN0IG9uSW5wdXQgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxJPikgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgb25TZWxlY3RlZEluZGV4Q2hhbmdlKGUsIGluZGV4KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VTdGFibGVHZXR0ZXIodmFsdWUpO1xuICAgICAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcywgLi4ubGlzdE5hdlJldCB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCh7XG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbixcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4LFxuICAgICAgICAgICAgbWFuYWdlZENoaWxkLFxuICAgICAgICAgICAgaGFzRm9jdXMsXG4gICAgICAgICAgICBzdWJJbmZvOiB7IGdldFZhbHVlIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgeyBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWQ6IGNoZWNrZWQgfSB9ID0gbGlzdE5hdlJldDtcblxuICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50IH0gPSB1c2VDaGVja2JveExpa2U8SSwgSUw+KHtcbiAgICAgICAgICAgIGNoZWNrYm94TGlrZToge1xuICAgICAgICAgICAgICAgIGNoZWNrZWQ6IChjaGVja2VkID8/IGZhbHNlKSxcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgICAgIG9uQ2hlY2tlZENoYW5nZTogb25JbnB1dCxcbiAgICAgICAgICAgICAgICByb2xlOiBcInJhZGlvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDoge1xuICAgICAgICAgICAgICAgIHRhZ0lucHV0OiB0YWdJbnB1dCBhcyBuZXZlcixcbiAgICAgICAgICAgICAgICB0YWdMYWJlbDogdGFnTGFiZWwgYXMgbmV2ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgYnlOYW1lLmN1cnJlbnQuc2V0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4geyBieU5hbWUuY3VycmVudC5kZWxldGUodmFsdWUpOyB9XG4gICAgICAgIH0sIFtieU5hbWUsIHZhbHVlLCBpbmRleF0pO1xuXG4gICAgICAgIGNvbnN0IHVzZVJhZGlvSW5wdXQ6IFVzZVJhZGlvSW5wdXQ8ST4gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSB0YWdJbnB1dDtcbiAgICAgICAgICAgIGNvbnN0IHVzZVJhZGlvSW5wdXRQcm9wcyA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxJPiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyA9PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNoZWNrZWQgPSAoY2hlY2tlZCA/PyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnR5cGUgPSBcInJhZGlvXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9wc1tcImFyaWEtY2hlY2tlZFwiXSA9IChjaGVja2VkID8/IGZhbHNlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzSWZJbnB1dEhhbmRsZXNGb2N1cyA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcyhwcm9wcyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGlrZUlucHV0RWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHVzZU1lcmdlZFByb3BzPEk+KCh1c2VDaGVja2JveExpa2VJbnB1dEVsZW1lbnRQcm9wcyh7fSkpLCBsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIiA/IHByb3BzSWZJbnB1dEhhbmRsZXNGb2N1cyA6IHByb3BzKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVzZVJhZGlvSW5wdXRQcm9wc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHVzZVJhZGlvTGFiZWw6IFVzZVJhZGlvTGFiZWw8SUw+ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgLy9jb25zdCB0YWcgPSB0YWdMYWJlbDtcbiAgICAgICAgICAgIGNvbnN0IHVzZVJhZGlvTGFiZWxQcm9wcyA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SUw+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8SUw+ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHVzZUNoZWNrYm94TGlrZUxhYmVsRWxlbWVudFByb3BzIH0gPSB1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wc0lmTGFiZWxIYW5kbGVzRm9jdXMgPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMocHJvcHMgYXMgYW55KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlQ2hlY2tib3hMaWtlTGFiZWxFbGVtZW50UHJvcHModXNlTWVyZ2VkUHJvcHM8SUw+KHt9IGFzIGFueSwgbGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIgPyBwcm9wc0lmTGFiZWxIYW5kbGVzRm9jdXMgYXMgYW55IDogcHJvcHMgYXMgYW55KSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXNlUmFkaW9MYWJlbFByb3BzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt1c2VDaGVja2JveExpa2VMYWJlbEVsZW1lbnRdKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlUmFkaW9JbnB1dCxcbiAgICAgICAgICAgIHVzZVJhZGlvTGFiZWwsXG4gICAgICAgICAgICAuLi5saXN0TmF2UmV0XG4gICAgICAgICAgICAvL2NoZWNrZWQ6IGNoZWNrZWQgPz8gZmFsc2UsXG4gICAgICAgICAgICAvL3RhYmJhYmxlOiB0YWJiYWJsZSA/PyBmYWxzZVxuICAgICAgICB9XG5cbiAgICB9LCBbYnlOYW1lLCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VSYWRpbyxcbiAgICAgICAgdXNlUmFkaW9Hcm91cFByb3BzLFxuICAgICAgICB1c2VSYWRpb0dyb3VwTGFiZWxQcm9wcyxcbiAgICAgICAgcmFkaW9Hcm91cDoge1xuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgLi4ubGlzdE5hdlJldFxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb1JldHVyblR5cGVJbmZvPEkgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxJPiB7IH1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSYWRpb1JldHVyblR5cGVXaXRoSG9va3M8SSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJhZGlvUmV0dXJuVHlwZUluZm88ST4ge1xuICAgIHVzZVJhZGlvSW5wdXQ6IFVzZVJhZGlvSW5wdXQ8ST47XG4gICAgdXNlUmFkaW9MYWJlbDogVXNlUmFkaW9MYWJlbDxMPjtcbn1cblxudHlwZSBVc2VSYWRpb0lucHV0PEkgZXh0ZW5kcyBFbGVtZW50PiA9ICh7IHRhZyB9OiBUYWdTZW5zaXRpdmVQcm9wczxJPikgPT4geyB1c2VSYWRpb0lucHV0UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8ST4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+OyB9XG50eXBlIFVzZVJhZGlvTGFiZWw8TCBleHRlbmRzIEVsZW1lbnQ+ID0gKHsgdGFnIH06IFRhZ1NlbnNpdGl2ZVByb3BzPEw+KSA9PiB7IHVzZVJhZGlvTGFiZWxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxMPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TD47IH1cblxuZXhwb3J0IHR5cGUgVXNlUmFkaW88ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSSBleHRlbmRzIEVsZW1lbnQsIEwgZXh0ZW5kcyBFbGVtZW50PiA9IChhOiBVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSSwgTD4pID0+IFVzZVJhZGlvUmV0dXJuVHlwZVdpdGhIb29rczxJLCBMPlxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZHJlbiwgcmV0dXJuTnVsbCwgdXNlR3JpZE5hdmlnYXRpb24sIFVzZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm8sIHVzZVBhc3NpdmVTdGF0ZSwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvLCB1c2VTb3J0YWJsZUNoaWxkcmVuLCB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBVc2VHcmlkTmF2aWdhdGlvbkNlbGxQYXJhbWV0ZXJzLCBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbywgVXNlR3JpZE5hdmlnYXRpb25Sb3dQYXJhbWV0ZXJzLCBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnMvdXNlLWdyaWQtbmF2aWdhdGlvblwiO1xuaW1wb3J0IHsgQ29tcGFyZSwgR2V0SW5kZXgsIEdldFZhbHVlLCBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVycy91c2Utc29ydGFibGUtY2hpbGRyZW5cIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGRlYnVnTG9nIH0gZnJvbSBcIi4vcHJvcHNcIjtcblxuZXhwb3J0IHR5cGUgVGFibGVWYWx1ZVR5cGUgPSBzdHJpbmcgfCBudW1iZXIgfCBudWxsIHwgYm9vbGVhbiB8IERhdGU7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVQYXJhbWV0ZXJzIGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVCb2R5UGFyYW1ldGVycyB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxVc2VUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIFwic3ViSW5mb1wiLCB7fT4sIFwic3ViSW5mb1wiPiB7XG4gICAgdGFibGVSb3c6IFBpY2s8VXNlVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50PiwgXCJsb2NhdGlvblwiPjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudCwgVXNlVGFibGVDZWxsU3ViSW5mbywgbmV2ZXIsIFwic3ViSW5mb1wiLCBcInN1YkluZm9cIiwgXCJzdWJJbmZvXCIsIFVzZVRhYmxlQ2VsbFN1YkluZm8+IHtcbiAgICBoYXNGb2N1czogVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPENlbGxFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgbG9jYXRpb246IFwiaGVhZFwiIHwgXCJib2R5XCIgfCBcImZvb3RcIjtcbiAgICBnZXRDZWxscygpOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2VsbEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxVc2VUYWJsZUNlbGxTdWJJbmZvPj4sIFwidGFiYmFibGVcIj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVDZWxsU3ViSW5mbyB7XG4gICAgbG9jYXRpb246IFwiaGVhZFwiIHwgXCJib2R5XCIgfCBcImZvb3RcIjtcbiAgICB2YWx1ZTogVGFibGVWYWx1ZVR5cGU7XG59XG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVJbmZvPENlbGxFbGVtZW50PiB7IHRhYmxlSGVhZGVyQ2VsbDogeyBzb3J0KCk6IHZvaWQgfSB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBVc2VUYWJsZUNlbGxTdWJJbmZvLCBuZXZlcj4geyB9XG5leHBvcnQgaW50ZXJmYWNlIFVzZVRhYmxlQm9keVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxSb3dFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50Pj4+LCBuZXZlciwgW10+IHsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBVc2VUYWJsZVJvd1N1YkluZm88Q2VsbEVsZW1lbnQ+LCBuZXZlcj4geyB9XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsRWxlbWVudD4geyB1c2VUYWJsZUNlbGxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGxFbGVtZW50PjsgfVxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUYWJsZVJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7IHVzZVRhYmxlQ2VsbDogVXNlVGFibGVDZWxsPENlbGxFbGVtZW50PjsgdXNlVGFibGVSb3dQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD47IH1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGFibGVCb2R5UmV0dXJuVHlwZVdpdGhIb29rczxCb2R5U2VjdGlvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVRhYmxlQm9keVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7IHVzZVRhYmxlQm9keVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4gfVxuZXhwb3J0IGludGVyZmFjZSBVc2VUYWJsZVJldHVyblR5cGVXaXRoSG9va3M8VGFibGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUYWJsZVJldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7XG4gICAgdXNlVGFibGVSb3c6IFVzZVRhYmxlUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PjtcbiAgICB1c2VUYWJsZUJvZHk6IFVzZVRhYmxlQm9keTxCb2R5U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PjtcbiAgICB1c2VUYWJsZVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlRWxlbWVudD47XG59XG5cbmV4cG9ydCB0eXBlIFVzZVRhYmxlQ2VsbDxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKHA6IFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+KSA9PiBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGxFbGVtZW50PjtcbmV4cG9ydCB0eXBlIFVzZVRhYmxlUm93PFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+ID0gKHA6IFVzZVRhYmxlUm93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4pID0+IFVzZVRhYmxlUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD47XG5leHBvcnQgdHlwZSBVc2VUYWJsZUJvZHk8Qm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gPSAocDogVXNlVGFibGVCb2R5UGFyYW1ldGVycykgPT4gVXNlVGFibGVCb2R5UmV0dXJuVHlwZVdpdGhIb29rczxCb2R5U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PjtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRhYmxlPFxuICAgIFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgQm9keVNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbiAgICBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcbiAgICBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnRcbj4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgdHlwZWFoZWFkTmF2aWdhdGlvbiB9OiBVc2VUYWJsZVBhcmFtZXRlcnMpOiBVc2VUYWJsZVJldHVyblR5cGVXaXRoSG9va3M8VGFibGVFbGVtZW50LCBCb2R5U2VjdGlvbkVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiB7XG4gICAgZGVidWdMb2coXCJ1c2VUYWJsZVwiKTtcblxuICAgIGNvbnN0IFtnZXRDdXJyZW50U29ydENvbHVtbiwgc2V0Q3VycmVudFNvcnRDb2x1bW5dID0gdXNlUGFzc2l2ZVN0YXRlPHsgaW5kZXg6IG51bWJlciwgZGlyZWN0aW9uOiBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCIgfSB8IG51bGw+KG51bGwsIHJldHVybk51bGwpO1xuICAgIGNvbnN0IGJvZHlTb3J0ID0gdXNlUmVmPG51bGwgfCAoKCkgPT4gdm9pZCk+KG51bGwpO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblByb3BzLFxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvdyxcbiAgICAgICAgLi4uZ3JpZE5hdlJldDFcbiAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb248VGFibGVFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgVXNlVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50PiwgVXNlVGFibGVDZWxsU3ViSW5mbywgbmV2ZXIsIG5ldmVyPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogcm93cyB9IH0gPSBncmlkTmF2UmV0MTtcblxuICAgIGNvbnN0IHVzZVRhYmxlUm93ID0gdXNlQ2FsbGJhY2s8VXNlVGFibGVSb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+PigoeyBhc0NoaWxkUm93T2ZTZWN0aW9uLCBhc1BhcmVudFJvd09mQ2VsbHMsIHRhYmxlUm93OiB7IGxvY2F0aW9uIH0gfTogVXNlVGFibGVSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50Pik6IFVzZVRhYmxlUm93UmV0dXJuVHlwZVdpdGhIb29rczxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4gPT4ge1xuICAgICAgICBkZWJ1Z0xvZyhcInVzZVRhYmxlUm93XCIsIGFzQ2hpbGRSb3dPZlNlY3Rpb24ubWFuYWdlZENoaWxkLmluZGV4KTtcblxuICAgICAgICBjb25zdCBnZXRDZWxscyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjZWxscztcbiAgICAgICAgfSwgW10pXG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsLFxuICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyxcbiAgICAgICAgICAgIC4uLmdyaWROYXZSZXQyXG4gICAgICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvblJvdyh7IGFzQ2hpbGRSb3dPZlNlY3Rpb246IHsgLi4uYXNDaGlsZFJvd09mU2VjdGlvbiwgc3ViSW5mbzogeyBnZXRDZWxscywgbG9jYXRpb24gfSB9LCBhc1BhcmVudFJvd09mQ2VsbHMgfSk7XG5cbiAgICAgICAgY29uc3QgeyBhc1BhcmVudE9mQ2VsbHM6IHsgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuOiBjZWxscyB9IH0gfSA9IGdyaWROYXZSZXQyO1xuXG4gICAgICAgIGNvbnN0IHVzZVRhYmxlQ2VsbCA9IHVzZUNhbGxiYWNrPFVzZVRhYmxlQ2VsbDxDZWxsRWxlbWVudD4+KCh7IGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGQsIHJvdmluZ1RhYkluZGV4LCBzdWJJbmZvLCBoYXNGb2N1cyB9KSA9PiB7XG4gICAgICAgICAgICBkZWJ1Z0xvZyhcInVzZVRhYmxlQ2VsbFwiLCBtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzLFxuICAgICAgICAgICAgICAgIC4uLmdyaWROYXZSZXQzXG4gICAgICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25DZWxsKHsgbGlzdE5hdmlnYXRpb24sIG1hbmFnZWRDaGlsZCwgcm92aW5nVGFiSW5kZXgsIHN1YkluZm8sIGhhc0ZvY3VzIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBzb3J0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRJbmZvID0gZ2V0Q3VycmVudFNvcnRDb2x1bW4oKSA/PyB7IGluZGV4OiAtMSwgZGlyZWN0aW9uOiAnYXNjZW5kaW5nJyB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxJbmRleCA9IG1hbmFnZWRDaGlsZC5pbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoc29ydEluZm8uaW5kZXggIT0gY2VsbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0SW5mby5kaXJlY3Rpb25bMF0gPT0gJ2EnKVxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydEluZm8uZGlyZWN0aW9uID0gJ2Rlc2NlbmRpbmcnO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0SW5mby5kaXJlY3Rpb24gPSAnYXNjZW5kaW5nJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzb3J0SW5mby5pbmRleCA9IG1hbmFnZWRDaGlsZC5pbmRleDtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50U29ydENvbHVtbihzb3J0SW5mbyk7XG5cbiAgICAgICAgICAgICAgICBib2R5U29ydC5jdXJyZW50ISgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHVzZVRhYmxlQ2VsbFByb3BzOiB0eXBlb2YgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMgPSAocHJvcHMpID0+IHByb3BzO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWJsZUhlYWRlckNlbGw6IHsgc29ydCB9LFxuICAgICAgICAgICAgICAgIHVzZVRhYmxlQ2VsbFByb3BzLFxuICAgICAgICAgICAgICAgIC4uLmdyaWROYXZSZXQzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGNvbnN0IHVzZVRhYmxlUm93UHJvcHM6IHR5cGVvZiB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzID0gKHByb3BzKSA9PiBwcm9wcztcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlVGFibGVDZWxsLFxuICAgICAgICAgICAgdXNlVGFibGVSb3dQcm9wcyxcbiAgICAgICAgICAgIC4uLmdyaWROYXZSZXQyXG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB1c2VUYWJsZUJvZHkgPSB1c2VDYWxsYmFjazxVc2VUYWJsZUJvZHk8Qm9keVNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4+KCgpID0+IHtcbiAgICAgICAgZGVidWdMb2coXCJ1c2VUYWJsZUJvZHlcIik7XG4gICAgICAgIHR5cGUgQyA9IFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxSb3dFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88VXNlVGFibGVSb3dTdWJJbmZvPENlbGxFbGVtZW50Pj4+O1xuICAgICAgICB0eXBlIFYgPSB7IGxvY2F0aW9uOiBcImhlYWRcIiB8IFwiYm9keVwiIHwgXCJmb290XCIsIHZhbHVlOiBUYWJsZVZhbHVlVHlwZSB9O1xuICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZUNhbGxiYWNrPEdldEluZGV4PEMsIG5ldmVyPj4oKGkpID0+IGkuaW5kZXgsIFtdKTtcbiAgICAgICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjazxHZXRWYWx1ZTxDLCBuZXZlciwgW10sIFY+PigoaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2VsbHMgPSBpLnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLmdldENlbGxzKCk7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gY2VsbHMuZ2V0QXQoZ2V0Q3VycmVudFNvcnRDb2x1bW4oKT8uaW5kZXggPz8gMCk7XG4gICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogY2VsbD8uc3ViSW5mby5zdWJJbmZvLnN1YkluZm8ubG9jYXRpb24gPz8gXCJoZWFkXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGNlbGw/LnN1YkluZm8uc3ViSW5mby5zdWJJbmZvLnZhbHVlID8/IC0xXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vcmV0dXJuIGNlbGxzLmdldEF0KGdldEN1cnJlbnRTb3J0Q29sdW1uKCk/LmluZGV4ID8/IDApPy5zdWJJbmZvLnN1YkluZm8uc3ViSW5mby52YWx1ZSA/PyBudWxsO1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgY29uc3QgY29tcGFyZTogQ29tcGFyZTxWPiA9IChsaHMsIHJocykgPT4ge1xuICAgICAgICAgICAgaWYgKGxocy5sb2NhdGlvbiA9PT0gcmhzLmxvY2F0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiArKGxocy52YWx1ZSA/PyAtSW5maW5pdHkpIC0gKyhyaHMudmFsdWUgPz8gLUluZmluaXR5KTtcbiAgICAgICAgICAgIGlmIChsaHMubG9jYXRpb24gPT0gJ2hlYWQnKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChsaHMubG9jYXRpb24gPT0gJ2JvZHknKVxuICAgICAgICAgICAgICAgIHJldHVybiByaHMubG9jYXRpb24gPT0gJ2hlYWQnID8gLTEgOiAxO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxuICAgICAgICAgICAgLi4uc29ydGFibGVSZXRcbiAgICAgICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48Qm9keVNlY3Rpb25FbGVtZW50LCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Um93RWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPFVzZVRhYmxlUm93U3ViSW5mbzxDZWxsRWxlbWVudD4+PiwgbmV2ZXIsIFtdLCBWPih7XG4gICAgICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgICAgICAgICBnZXRJbmRleFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNvcnRhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgICAgICAgICBjb21wYXJlLFxuICAgICAgICAgICAgICAgIGdldFZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgc29ydGFibGVDaGlsZHJlbjogeyBzb3J0IH0gfSA9IHNvcnRhYmxlUmV0O1xuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgYm9keVNvcnQuY3VycmVudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzb3J0KHJvd3MsIGdldEN1cnJlbnRTb3J0Q29sdW1uKCk/LmRpcmVjdGlvbiA/PyAnYXNjZW5kaW5nJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbc29ydF0pXG5cbiAgICAgICAgY29uc3QgdXNlVGFibGVCb2R5UHJvcHMgPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJvZHlTZWN0aW9uRWxlbWVudD4pID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHByb3BzLmNoaWxkcmVuICE9IG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHVzZVNvcnRhYmxlUHJvcHMocHJvcHMgYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keVNlY3Rpb25FbGVtZW50PiAmIHsgY2hpbGRyZW46IGFueSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VUYWJsZUJvZHlQcm9wcyxcbiAgICAgICAgICAgIC4uLnNvcnRhYmxlUmV0XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB1c2VUYWJsZVByb3BzOiB0eXBlb2YgdXNlR3JpZE5hdmlnYXRpb25Qcm9wcyA9IHVzZUdyaWROYXZpZ2F0aW9uUHJvcHM7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VUYWJsZVByb3BzLFxuICAgICAgICB1c2VUYWJsZUJvZHksXG4gICAgICAgIHVzZVRhYmxlUm93LFxuICAgICAgICAuLi5ncmlkTmF2UmV0MVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XG5pbXBvcnQgeyBVc2VCdXR0b25QYXJhbWV0ZXJzIH0gZnJvbSBcIi4uL3VzZS1idXR0b25cIjtcbmltcG9ydCB7IHVzZUFjY29yZGlvbiwgVXNlQWNjb3JkaW9uUGFyYW1ldGVycywgVXNlQWNjb3JkaW9uUmV0dXJuVHlwZUluZm8sIFVzZUFjY29yZGlvblNlY3Rpb24sIFVzZUFjY29yZGlvblNlY3Rpb25QYXJhbWV0ZXJzLCBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLWFjY29yZGlvblwiO1xuaW1wb3J0IHsgSGVhZGluZyB9IGZyb20gXCIuL2hlYWRpbmdcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFjY29yZGlvblByb3BzIGV4dGVuZHNcbiAgICBHZXQ8VXNlQWNjb3JkaW9uUGFyYW1ldGVycywgXCJhY2NvcmRpb25cIj4sXG4gICAgR2V0PFVzZUFjY29yZGlvblBhcmFtZXRlcnMsIFwibGluZWFyTmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlQWNjb3JkaW9uUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4ge1xuICAgIGV4cGFuZGVkSW5kZXg/OiBudW1iZXIgfCB1bmRlZmluZWQgfCBudWxsO1xuICAgIHJlbmRlcihpbmZvOiBVc2VBY2NvcmRpb25SZXR1cm5UeXBlSW5mbyk6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWNjb3JkaW9uU2VjdGlvblByb3BzPEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyRWxlbWVudD4sIFwiYWNjb3JkaW9uU2VjdGlvblwiPixcbiAgICBHZXQ8VXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyRWxlbWVudD4sIFwibWFuYWdlZENoaWxkcmVuXCI+LFxuICAgIFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxIZWFkZXJFbGVtZW50PixcbiAgICBHZXQ8VXNlQWNjb3JkaW9uU2VjdGlvblBhcmFtZXRlcnM8SGVhZGVyRWxlbWVudD4sIFwiYnV0dG9uXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvLCBtYWtlSGVhZGVyUHJvcHM6IFByb3BNb2RpZmllcjxIZWFkZXJFbGVtZW50PiwgbWFrZUJvZHlQcm9wczogUHJvcE1vZGlmaWVyPEJvZHlFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cblxuY29uc3QgQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUFjY29yZGlvblNlY3Rpb248YW55LCBhbnk+PihudWxsISk7XG5leHBvcnQgY29uc3QgQWNjb3JkaW9uID0gbWVtbyhmdW5jdGlvbiBBY2NvcmRpb24oeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIGV4cGFuZGVkSW5kZXgsIGluaXRpYWxJbmRleCwgbmF2aWdhdGlvbkRpcmVjdGlvbiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UsIHJlbmRlciB9OiBBY2NvcmRpb25Qcm9wcykge1xuICAgIGNvbnN0IHsgdXNlQWNjb3JkaW9uU2VjdGlvbiwgLi4ucHJvdmlkZXIgfSA9IHVzZUFjY29yZGlvbih7XG4gICAgICAgIGFjY29yZGlvbjogeyBpbml0aWFsSW5kZXggfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH1cbiAgICB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7IHByb3ZpZGVyLmFjY29yZGlvbi5jaGFuZ2VFeHBhbmRlZEluZGV4KGV4cGFuZGVkSW5kZXghID8/IG51bGwpOyB9LCBbZXhwYW5kZWRJbmRleF0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPEFjY29yZGlvblNlY3Rpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VBY2NvcmRpb25TZWN0aW9ufT57cmVuZGVyKHByb3ZpZGVyKX08L0FjY29yZGlvblNlY3Rpb25Db250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyQWNjb3JkaW9uU2VjdGlvbjxIZWFkZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgbWFrZVByb3BzSGVhZGluZywgbWFrZVByb3BzQm9keSwgdGFnQm9keSwgdGFnSGVhZGluZyB9OiB7IHRhZ0hlYWRpbmc6IEVsZW1lbnRUb1RhZzxIZWFkZXJFbGVtZW50PjsgdGFnQm9keTogRWxlbWVudFRvVGFnPEJvZHlFbGVtZW50PjsgbWFrZVByb3BzSGVhZGluZyhpbmZvOiBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZUluZm8pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxIZWFkZXJFbGVtZW50PiwgbWFrZVByb3BzQm9keShpbmZvOiBVc2VBY2NvcmRpb25TZWN0aW9uUmV0dXJuVHlwZUluZm8pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlQWNjb3JkaW9uU2VjdGlvblJldHVyblR5cGVJbmZvLCBtb2RpZnlIZWFkaW5nUHJvcHM6IFByb3BNb2RpZmllcjxIZWFkZXJFbGVtZW50PiwgbW9kaWZ5Qm9keVByb3BzOiBQcm9wTW9kaWZpZXI8Qm9keUVsZW1lbnQ+KTogVk5vZGU8YW55PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGFjY29yZGlvblNlY3Rpb246IHtcbiAgICAgICAgICAgICAgICBmb2N1c2VkXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gPSBpbmZvO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPXtjcmVhdGVFbGVtZW50KHRhZ0hlYWRpbmcgYXMgbmV2ZXIsIG1vZGlmeUhlYWRpbmdQcm9wcyh7IC4uLm1ha2VQcm9wc0hlYWRpbmcoaW5mbykgfSkpfT5cbiAgICAgICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnQm9keSBhcyBuZXZlciwgbW9kaWZ5Qm9keVByb3BzKG1ha2VQcm9wc0JvZHkoaW5mbykpKX1cbiAgICAgICAgICAgICAgICA8L0hlYWRpbmc+XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IEFjY29yZGlvblNlY3Rpb24gPSBtZW1vKGZ1bmN0aW9uIEFjY29yZGlvblNlY3Rpb248SGVhZGVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oe1xuICAgIG9wZW4sXG4gICAgaW5kZXgsXG4gICAgdGFnQnV0dG9uLFxuICAgIGRpc2FibGVkLFxuICAgIHJlbmRlcixcbiAgICBnZXREb2N1bWVudCxcbiAgICBnZXRXaW5kb3csXG4gICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlLFxuICAgIG9uRWxlbWVudENoYW5nZSxcbiAgICBvbkZvY3VzZWRDaGFuZ2VkLFxuICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZCxcbiAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLFxuICAgIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLFxuICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsXG4gICAgb25Nb3VudCxcbiAgICBvblVubW91bnQsXG4gICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlXG59OiBBY2NvcmRpb25TZWN0aW9uUHJvcHM8SGVhZGVyRWxlbWVudCwgQm9keUVsZW1lbnQ+KSB7XG4gICAgY29uc3QgdXNlQWNjb3JkaW9uU2VjdGlvbiA9IHVzZUNvbnRleHQoQWNjb3JkaW9uU2VjdGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IHsgdXNlQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcywgdXNlQWNjb3JkaW9uU2VjdGlvbkhlYWRlclByb3BzLCAuLi5zZWN0aW9uSW5mbyB9ID0gdXNlQWNjb3JkaW9uU2VjdGlvbih7XG4gICAgICAgIGJ1dHRvbjogeyBkaXNhYmxlZCB9LFxuICAgICAgICBhY2NvcmRpb25TZWN0aW9uOiB7IG9wZW4sIHRhZ0J1dHRvbiB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgaW5kZXggfSxcbiAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZW5kZXIoc2VjdGlvbkluZm8sIHVzZUFjY29yZGlvblNlY3Rpb25IZWFkZXJQcm9wcywgdXNlQWNjb3JkaW9uU2VjdGlvbkJvZHlQcm9wcyk7XG59KVxuXG5cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyBQcm9wTW9kaWZpZXIgfSBmcm9tIFwicHJvcHNcIjtcbmltcG9ydCB7IHVzZUJ1dHRvbiwgVXNlQnV0dG9uUGFyYW1ldGVycyB9IGZyb20gXCIuLi91c2UtYnV0dG9uXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnV0dG9uUHJvcHM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiBleHRlbmRzIFVzZUJ1dHRvblBhcmFtZXRlcnM8RT4ge1xuICAgIHJlbmRlcihidXR0b246IFByb3BNb2RpZmllcjxFPik6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyQnV0dG9uKHRhZzogc3RyaW5nLCBtYWtlQnV0dG9uUHJvcHM6IChpbmZvOiB7fSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8YW55Pikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kaWZ5QnV0dG9uUHJvcHM6IFByb3BNb2RpZmllcjxhbnk+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZyBhcyBhbnksIG1vZGlmeUJ1dHRvblByb3BzKG1ha2VCdXR0b25Qcm9wcyh7fSkpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBCdXR0b24gPSBtZW1vKGZ1bmN0aW9uIEJ1dHRvbjxFIGV4dGVuZHMgRWxlbWVudD4oeyB0YWcsIG9uUHJlc3MsIHByZXNzZWQsIHJlbmRlciwgZGlzYWJsZWQgfTogQnV0dG9uUHJvcHM8RT4pIHtcbiAgICBjb25zdCB7IHVzZUJ1dHRvblByb3BzIH0gPSB1c2VCdXR0b248RT4oeyB0YWcsIG9uUHJlc3MsIHByZXNzZWQsIGRpc2FibGVkIH0pO1xuICAgIHJldHVybiByZW5kZXIodXNlQnV0dG9uUHJvcHMpO1xufSkiLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSwgQ29tcG9uZW50Q2hpbGRyZW4gfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xuaW1wb3J0IHsgdXNlQ2hlY2tib3gsIFVzZUNoZWNrYm94UGFyYW1ldGVycywgVXNlQ2hlY2tib3hSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtY2hlY2tib3hcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcblxuZXhwb3J0IGludGVyZmFjZSBDaGVja2JveFByb3BzPEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZUNoZWNrYm94UGFyYW1ldGVyczxJLCBMPiwgXCJjaGVja2JveExpa2VcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94UGFyYW1ldGVyczxJLCBMPiwgXCJjaGVja2JveFwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hQYXJhbWV0ZXJzPEksIEw+LCBcImxhYmVsXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlQ2hlY2tib3hSZXR1cm5UeXBlSW5mbzxJLCBMPiwgbW9kaWZ5SW5wdXRQcm9wczogUHJvcE1vZGlmaWVyPEk+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TD4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZTxJIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEwgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSW5mb1R5cGU+KHsgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsLCBtYWtlSW5wdXRQcm9wcywgbWFrZUxhYmVsUHJvcHMgfTogRGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZVBhcmFtZXRlcnM8SSwgTCwgSW5mb1R5cGU+KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBJbmZvVHlwZSwgbW9kaWZ5SW5wdXRQcm9wczogUHJvcE1vZGlmaWVyPEk+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TD4pOiBWTm9kZTxhbnk+IHtcblxuICAgICAgICBpZiAobGFiZWxQb3NpdGlvbiA9PSBcIndyYXBwaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0UHJvcHNCYXNlID0gbWFrZUlucHV0UHJvcHMoaW5mbyk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbFByb3BzQmFzZSA9IG1ha2VMYWJlbFByb3BzKGluZm8pO1xuXG4gICAgICAgICAgICBjb25zdCBpbnB1dFByb3BzID0gbW9kaWZ5SW5wdXRQcm9wcyhpbnB1dFByb3BzQmFzZSk7XG4gICAgICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCAuLi5sYWJlbFByb3BzIH0gPSBtb2RpZnlMYWJlbFByb3BzKGxhYmVsUHJvcHNCYXNlKTtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gY3JlYXRlRWxlbWVudCh0YWdJbnB1dCBhcyBuZXZlciwgaW5wdXRQcm9wcyk7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwgYXMgbmV2ZXIsIHsgLi4ubGFiZWxQcm9wcywgY2hpbGRyZW46IDw+e2lucHV0fXtjaGlsZHJlbn08Lz4gfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCBpbnB1dFByb3BzID0gbW9kaWZ5SW5wdXRQcm9wcyhtYWtlSW5wdXRQcm9wcyhpbmZvKSlcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsUHJvcHMgPSBtb2RpZnlMYWJlbFByb3BzKG1ha2VMYWJlbFByb3BzKGluZm8pKVxuXG4gICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNyZWF0ZUVsZW1lbnQodGFnSW5wdXQgYXMgbmV2ZXIsIGlucHV0UHJvcHMpO1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KHRhZ0xhYmVsIGFzIG5ldmVyLCBsYWJlbFByb3BzKTtcblxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICB7aW5wdXR9XG4gICAgICAgICAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9wcyA9IG1ha2VJbnB1dFByb3BzKGluZm8pO1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoISF1c2VyUHJvcHNbXCJhcmlhLWxhYmVsXCJdKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0lucHV0IGFzIG5ldmVyLCBtb2RpZnlJbnB1dFByb3BzKHVzZXJQcm9wcykpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50LCBJbmZvVHlwZT4ge1xuICAgIGxhYmVsUG9zaXRpb246IFwid3JhcHBpbmdcIiB8IFwic2VwYXJhdGVcIiB8IFwiaGlkZGVuXCIsXG4gICAgdGFnSW5wdXQ6IEVsZW1lbnRUb1RhZzxJPixcbiAgICB0YWdMYWJlbDogRWxlbWVudFRvVGFnPEw+LFxuICAgIG1ha2VJbnB1dFByb3BzOiAoaW5mbzogSW5mb1R5cGUpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEk+LFxuICAgIG1ha2VMYWJlbFByb3BzOiAoaW5mbzogSW5mb1R5cGUpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEw+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdFJlbmRlckNoZWNrYm94UGFyYW1ldGVyczxJIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEwgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJLCBMLCBVc2VDaGVja2JveFJldHVyblR5cGVJbmZvPEksIEw+PiB7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDaGVja2JveDxJIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEwgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcyB9OiBEZWZhdWx0UmVuZGVyQ2hlY2tib3hQYXJhbWV0ZXJzPEksIEw+KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJDaGVja2JveExpa2U8SSwgTCwgVXNlQ2hlY2tib3hSZXR1cm5UeXBlSW5mbzxJLCBMPj4oeyBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcyB9KTtcbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiBDaGVja2JveDxJIGV4dGVuZHMgSFRNTEVsZW1lbnQsIEwgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBjaGVja2VkLCBkaXNhYmxlZCwgdGFnTGFiZWwsIGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCBvbkNoZWNrZWRDaGFuZ2UsIHJlbmRlciB9OiBDaGVja2JveFByb3BzPEksIEw+KSB7XG4gICAgY29uc3QgeyB1c2VDaGVja2JveElucHV0RWxlbWVudCwgdXNlQ2hlY2tib3hMYWJlbEVsZW1lbnQsIC4uLmNoZWNrYm94SW5mbyB9ID0gdXNlQ2hlY2tib3goeyBjaGVja2JveDogeyBvbkNoZWNrZWRDaGFuZ2UgfSwgY2hlY2tib3hMaWtlOiB7IGNoZWNrZWQsIGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uIH0sIGxhYmVsOiB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9IH0pO1xuICAgIGNvbnN0IHsgdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyB9ID0gdXNlQ2hlY2tib3hJbnB1dEVsZW1lbnQoKTtcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMgfSA9IHVzZUNoZWNrYm94TGFiZWxFbGVtZW50KCk7XG5cblxuICAgIHJldHVybiByZW5kZXIoY2hlY2tib3hJbmZvLCB1c2VDaGVja2JveElucHV0RWxlbWVudFByb3BzLCB1c2VDaGVja2JveExhYmVsRWxlbWVudFByb3BzKTtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0LCBoLCBSZW5kZXJhYmxlUHJvcHMsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XG5pbXBvcnQgeyB1c2VDaGVja2JveEdyb3VwLCBVc2VDaGVja2JveEdyb3VwQ2hpbGQsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94R3JvdXBDaGlsZFJldHVyblR5cGVJbmZvLCBVc2VDaGVja2JveEdyb3VwUGFyYW1ldGVycywgVXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnMsIFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtY2hlY2tib3gtZ3JvdXBcIjtcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJDaGVja2JveExpa2UsIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vY2hlY2tib3hcIjtcblxudHlwZSBHZXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gVFtLXTtcbnR5cGUgR2V0MjxULCBLIGV4dGVuZHMga2V5b2YgVCwgSzIgZXh0ZW5kcyBrZXlvZiBUW0tdPiA9IFRbS11bSzJdO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrYm94R3JvdXBQcm9wczxJbnB1dEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgUmVuZGVyYWJsZVByb3BzPHt9PixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwibGluZWFyTmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmFtZXRlcnMsIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUNoZWNrYm94R3JvdXBQYXJlbnRQYXJhbWV0ZXJzPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJjaGVja2JveFwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImNoZWNrYm94TGlrZVwiPixcbiAgICBHZXQ8VXNlQ2hlY2tib3hHcm91cFBhcmVudFBhcmFtZXRlcnM8SW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImxhYmVsXCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVJbmZvPElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgbW9kaWZ5SW5wdXRQcm9wczogUHJvcE1vZGlmaWVyPElucHV0RWxlbWVudD4sIGxhYmVsOiBQcm9wTW9kaWZpZXI8TGFiZWxFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hlY2tib3hHcm91cENoZWNrYm94UHJvcHM8SW5wdXRUeXBlIGV4dGVuZHMgRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveFwiLCBcImNoZWNrYm94XCI+LFxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveFwiLCBcImxhYmVsXCI+LFxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveFwiLCBcImNoZWNrYm94TGlrZVwiPixcbiAgICBHZXQyPFVzZUNoZWNrYm94R3JvdXBDaGlsZFBhcmFtZXRlcnM8SW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBcImFzQ2hlY2tib3hHcm91cENoaWxkXCIsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0MjxVc2VDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPiwgXCJhc0NoZWNrYm94R3JvdXBDaGlsZFwiLCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDI8VXNlQ2hlY2tib3hHcm91cENoaWxkUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIFwiYXNDaGVja2JveEdyb3VwQ2hpbGRcIiwgXCJtYW5hZ2VkQ2hpbGRcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VDaGVja2JveEdyb3VwQ2hpbGRSZXR1cm5UeXBlSW5mbzxJbnB1dFR5cGUsIExhYmVsVHlwZT4sIG1vZGlmeUlucHV0UHJvcHM6IFByb3BNb2RpZmllcjxJbnB1dFR5cGU+LCBsYWJlbDogUHJvcE1vZGlmaWVyPExhYmVsVHlwZT4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZSwgVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRUeXBlLCBMYWJlbFR5cGU+PiB7IH1cbmV4cG9ydCBpbnRlcmZhY2UgRGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBQYXJhbWV0ZXJzPElucHV0VHlwZSBleHRlbmRzIEhUTUxFbGVtZW50LCBMYWJlbFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudD4gZXh0ZW5kcyBEZWZhdWx0UmVuZGVyQ2hlY2tib3hMaWtlUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZSwgVXNlQ2hlY2tib3hHcm91cFJldHVyblR5cGVJbmZvPElucHV0VHlwZSwgTGFiZWxUeXBlPj4ge1xuICAgIGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGQ8SW5wdXRUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHRhZ0lucHV0LCB0YWdMYWJlbCwgbGFiZWxQb3NpdGlvbiwgbWFrZUlucHV0UHJvcHMsIG1ha2VMYWJlbFByb3BzIH06IERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGRQYXJhbWV0ZXJzPElucHV0VHlwZSwgTGFiZWxUeXBlPikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlQ2hlY2tib3hHcm91cENoaWxkUmV0dXJuVHlwZUluZm88SW5wdXRUeXBlLCBMYWJlbFR5cGU+LCBtb2RpZnlJbnB1dFByb3BzOiBQcm9wTW9kaWZpZXI8SW5wdXRUeXBlPiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsVHlwZT4pOiBWTm9kZTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJDaGVja2JveExpa2UoeyBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcyB9KShpbmZvLCBtb2RpZnlJbnB1dFByb3BzLCBtb2RpZnlMYWJlbFByb3BzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyQ2hlY2tib3hHcm91cDxJbnB1dFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgY2hpbGRyZW4sIGxhYmVsUG9zaXRpb24sIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcywgdGFnSW5wdXQsIHRhZ0xhYmVsIH06IERlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwUGFyYW1ldGVyczxJbnB1dFR5cGUsIExhYmVsVHlwZT4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZUNoZWNrYm94R3JvdXBSZXR1cm5UeXBlSW5mbzxhbnksIGFueT4sIG1vZGlmeUlucHV0UHJvcHM6IFByb3BNb2RpZmllcjxJbnB1dFR5cGU+LCBtb2RpZnlMYWJlbFByb3BzOiBQcm9wTW9kaWZpZXI8TGFiZWxUeXBlPik6IFZOb2RlPGFueT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7ZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSh7IGxhYmVsUG9zaXRpb24sIG1ha2VJbnB1dFByb3BzLCBtYWtlTGFiZWxQcm9wcywgdGFnSW5wdXQsIHRhZ0xhYmVsIH0pKGluZm8sIG1vZGlmeUlucHV0UHJvcHMsIG1vZGlmeUxhYmVsUHJvcHMpfVxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufVxuXG5jb25zdCBVc2VDaGVja2JveEdyb3VwQ2hpbGRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VDaGVja2JveEdyb3VwQ2hpbGQ8YW55LCBhbnk+PihudWxsISk7XG5leHBvcnQgZnVuY3Rpb24gQ2hlY2tib3hHcm91cDxJbnB1dFR5cGUgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTGFiZWxUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHtcbiAgICBkaXNhYmxlZDogcGFyZW50RGlzYWJsZWQsXG4gICAgdGFnSW5wdXQsXG4gICAgdGFnTGFiZWwsXG4gICAgcmVuZGVyLFxuICAgIGxhYmVsUG9zaXRpb24sXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICBpbmRleERlbWFuZ2xlcixcbiAgICBpbmRleE1hbmdsZXIsXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb25UYWJiYWJsZVJlbmRlclxufTogQ2hlY2tib3hHcm91cFByb3BzPElucHV0VHlwZSwgTGFiZWxUeXBlPikge1xuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlQ2hlY2tib3hHcm91cENoaWxkLFxuICAgICAgICB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXQsXG4gICAgICAgIC4uLmNoZWNrYm94R3JvdXBQYXJlbnRJbmZvXG4gICAgfSA9IHVzZUNoZWNrYm94R3JvdXA8SW5wdXRUeXBlLCBMYWJlbFR5cGU+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIgfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxuICAgIH0pO1xuXG5cbiAgICBjb25zdCB7IHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzLCB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyB9ID0gdXNlQ2hlY2tib3hHcm91cFBhcmVudElucHV0KHsgY2hlY2tib3g6IHt9LCBjaGVja2JveExpa2U6IHsgZGlzYWJsZWQ6IHBhcmVudERpc2FibGVkLCBsYWJlbFBvc2l0aW9uIH0sIGxhYmVsOiB7IHRhZ0lucHV0LCB0YWdMYWJlbCB9IH0pO1xuXG5cbiAgICBsZXQgd3JhcHBpbmc6IFZOb2RlPGFueT47XG4gICAgaWYgKGxhYmVsUG9zaXRpb24gPT0gXCJzZXBhcmF0ZVwiKSB7XG4gICAgICAgIHdyYXBwaW5nID0gcmVuZGVyKGNoZWNrYm94R3JvdXBQYXJlbnRJbmZvLCB1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcywgdXNlQ2hlY2tib3hHcm91cFBhcmVudExhYmVsUHJvcHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd3JhcHBpbmcgPSByZW5kZXIoY2hlY2tib3hHcm91cFBhcmVudEluZm8sIHVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dFByb3BzLCB1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFVzZUNoZWNrYm94R3JvdXBDaGlsZENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUNoZWNrYm94R3JvdXBDaGlsZH0+e3dyYXBwaW5nfTwvVXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDaGVja2JveEdyb3VwQ2hlY2tib3g8SW5wdXRUeXBlIGV4dGVuZHMgSFRNTEVsZW1lbnQsIExhYmVsVHlwZSBleHRlbmRzIEhUTUxFbGVtZW50Pih7XG4gICAgY2hlY2tlZCxcbiAgICBkaXNhYmxlZCxcbiAgICBpbmRleCxcbiAgICBsYWJlbFBvc2l0aW9uLFxuICAgIHRhZ0lucHV0LFxuICAgIHRhZ0xhYmVsLFxuICAgIHRleHQsXG4gICAgYmx1clNlbGYsXG4gICAgZmxhZ3MsXG4gICAgZm9jdXNTZWxmLFxuICAgIGhpZGRlbixcbiAgICBvbkNoZWNrZWRDaGFuZ2UsXG4gICAgcmVuZGVyXG59OiBDaGVja2JveEdyb3VwQ2hlY2tib3hQcm9wczxJbnB1dFR5cGUsIExhYmVsVHlwZT4pIHtcbiAgICBjb25zdCB7IHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHMsIHVzZUNoZWNrYm94R3JvdXBDaGlsZExhYmVsUHJvcHMsIC4uLmNoZWNrYm94R3JvdXBDaGlsZEluZm8gfSA9IHVzZUNvbnRleHQoVXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dCkoe1xuICAgICAgICBhc0NoZWNrYm94OiB7XG4gICAgICAgICAgICBjaGVja2JveDogeyBvbkNoZWNrZWRDaGFuZ2UgfSxcbiAgICAgICAgICAgIGNoZWNrYm94TGlrZTogeyBjaGVja2VkLCBkaXNhYmxlZCwgbGFiZWxQb3NpdGlvbiB9LFxuICAgICAgICAgICAgbGFiZWw6IHsgdGFnSW5wdXQsIHRhZ0xhYmVsIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXNDaGVja2JveEdyb3VwQ2hpbGQ6IHtcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDoge1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGZsYWdzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgICAgICBibHVyU2VsZixcbiAgICAgICAgICAgICAgICBmb2N1c1NlbGYsXG4gICAgICAgICAgICAgICAgaGlkZGVuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChsYWJlbFBvc2l0aW9uID09IFwic2VwYXJhdGVcIikge1xuICAgICAgICByZXR1cm4gcmVuZGVyKGNoZWNrYm94R3JvdXBDaGlsZEluZm8sIHVzZUNoZWNrYm94R3JvdXBDaGlsZElucHV0UHJvcHMsIHVzZUNoZWNrYm94R3JvdXBDaGlsZExhYmVsUHJvcHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcihjaGVja2JveEdyb3VwQ2hpbGRJbmZvLCB1c2VDaGVja2JveEdyb3VwQ2hpbGRJbnB1dFByb3BzLCB1c2VDaGVja2JveEdyb3VwQ2hpbGRMYWJlbFByb3BzKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xuaW1wb3J0IHsgdXNlRGlhbG9nLCBVc2VEaWFsb2dQYXJhbWV0ZXJzLCBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtZGlhbG9nXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlhbG9nUHJvcHM8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZURpYWxvZ1BhcmFtZXRlcnMsIFwic29mdERpc21pc3NcIj4sXG4gICAgR2V0PFVzZURpYWxvZ1BhcmFtZXRlcnMsIFwibW9kYWxcIj4sXG4gICAgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsXG4gICAgR2V0PFVzZURpYWxvZ1BhcmFtZXRlcnMsIFwiZGlhbG9nXCI+IHtcblxuICAgIHJlbmRlcihkaWFsb2dJbmZvOiBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbywgbW9kaWZ5Rm9jdXNDb250YWluZXJQcm9wczogUHJvcE1vZGlmaWVyPEZvY3VzQ29udGFpbmVyRWxlbWVudD4sIG1vZGlmeURpYWxvZ1Byb3BzOiBQcm9wTW9kaWZpZXI8RGlhbG9nRWxlbWVudD4sIG1vZGlmeVRpdGxlUHJvcHM6IFByb3BNb2RpZmllcjxUaXRsZUVsZW1lbnQ+LCBtb2RpZnlCb2R5UHJvcHM6IFByb3BNb2RpZmllcjxCb2R5RWxlbWVudD4sIG1vZGlmeUJhY2tkcm9wUHJvcHM6IFByb3BNb2RpZmllcjxCYWNrZHJvcEVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJQb3J0YWwoeyBwb3J0YWxJZCwgY2hpbGRyZW4gfTogeyBwb3J0YWxJZDogc3RyaW5nLCBjaGlsZHJlbjogVk5vZGUgfSkge1xuICAgIGNvbnN0IHBvcnRhbFJlZiA9IHVzZVJlZjxIVE1MRWxlbWVudD4obnVsbCEpO1xuICAgIHBvcnRhbFJlZi5jdXJyZW50ID8/PSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwb3J0YWxJZCkhO1xuICAgIGlmIChwb3J0YWxSZWYuY3VycmVudClcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgcG9ydGFsUmVmLmN1cnJlbnQpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlck1vZGFsPEZvY3VzQ29udGFpbmVyRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBEaWFsb2dFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRpdGxlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCb2R5RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSW5mb1R5cGU+KHsgcG9ydGFsSWQsIHRhZ0ZvY3VzQ29udGFpbmVyLCB0YWdCYWNrZHJvcCwgdGFnQm9keSwgdGFnRGlhbG9nLCB0YWdUaXRsZSwgbWFrZVByb3BzRm9jdXNDb250YWluZXIsIG1ha2VQcm9wc0JhY2tkcm9wLCBtYWtlUHJvcHNCb2R5LCBtYWtlUHJvcHNEaWFsb2csIG1ha2VQcm9wc1RpdGxlIH06IHsgcG9ydGFsSWQ6IHN0cmluZywgdGFnRm9jdXNDb250YWluZXI6IEVsZW1lbnRUb1RhZzxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCB0YWdEaWFsb2c6IEVsZW1lbnRUb1RhZzxEaWFsb2dFbGVtZW50PjsgdGFnVGl0bGU6IEVsZW1lbnRUb1RhZzxUaXRsZUVsZW1lbnQ+OyB0YWdCb2R5OiBFbGVtZW50VG9UYWc8Qm9keUVsZW1lbnQ+OyB0YWdCYWNrZHJvcDogRWxlbWVudFRvVGFnPEJhY2tkcm9wRWxlbWVudD4sIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyOiAoaW5mbzogSW5mb1R5cGUpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEZvY3VzQ29udGFpbmVyRWxlbWVudD4sIG1ha2VQcm9wc0RpYWxvZzogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxEaWFsb2dFbGVtZW50PiwgbWFrZVByb3BzQm9keTogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCb2R5RWxlbWVudD4sIG1ha2VQcm9wc1RpdGxlOiAoaW5mbzogSW5mb1R5cGUpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRpdGxlRWxlbWVudD4sIG1ha2VQcm9wc0JhY2tkcm9wOiAoaW5mbzogSW5mb1R5cGUpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJhY2tkcm9wRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGlhbG9nSW5mbzogSW5mb1R5cGUsIG1vZGlmeUZvY3VzQ29udGFpbmVyUHJvcHM6IFByb3BNb2RpZmllcjxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCBtb2RpZnlEaWFsb2dQcm9wczogUHJvcE1vZGlmaWVyPERpYWxvZ0VsZW1lbnQ+LCBtb2RpZnlUaXRsZVByb3BzOiBQcm9wTW9kaWZpZXI8VGl0bGVFbGVtZW50PiwgbW9kaWZ5Qm9keVByb3BzOiBQcm9wTW9kaWZpZXI8Qm9keUVsZW1lbnQ+LCBtb2RpZnlCYWNrZHJvcFByb3BzOiBQcm9wTW9kaWZpZXI8QmFja2Ryb3BFbGVtZW50Pik6IFZOb2RlPGFueT4ge1xuXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IHRpdGxlQ2hpbGRyZW4sIC4uLnRpdGxlUHJvcHMgfSA9IG1vZGlmeVRpdGxlUHJvcHMobWFrZVByb3BzVGl0bGUoZGlhbG9nSW5mbykpO1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBib2R5Q2hpbGRyZW4sIC4uLmJvZHlQcm9wcyB9ID0gbW9kaWZ5Qm9keVByb3BzKG1ha2VQcm9wc0JvZHkoZGlhbG9nSW5mbykpO1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBkaWFsb2dDaGlsZHJlbiwgLi4uZGlhbG9nUHJvcHMgfSA9IG1vZGlmeURpYWxvZ1Byb3BzKG1ha2VQcm9wc0RpYWxvZyhkaWFsb2dJbmZvKSk7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IGJhY2tkcm9wQ2hpbGRyZW4sIC4uLmJhY2tkcm9wUHJvcHMgfSA9IG1vZGlmeUJhY2tkcm9wUHJvcHMobWFrZVByb3BzQmFja2Ryb3AoZGlhbG9nSW5mbykpO1xuICAgICAgICBjb25zdCB7IGNoaWxkcmVuOiBmb2N1c0NvbnRhaW5lckNoaWxkcmVuLCAuLi5mb2N1c0NvbnRhaW5lclByb3BzIH0gPSBtb2RpZnlGb2N1c0NvbnRhaW5lclByb3BzKG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyKGRpYWxvZ0luZm8pKTtcblxuICAgICAgICBjb25zdCB0aXRsZSA9IGNyZWF0ZUVsZW1lbnQodGFnVGl0bGUgYXMgbmV2ZXIsIHRpdGxlUHJvcHMsIHRpdGxlQ2hpbGRyZW4pO1xuICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlRWxlbWVudCh0YWdCb2R5IGFzIG5ldmVyLCBib2R5UHJvcHMsIGJvZHlDaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IGRpYWxvZyA9IGNyZWF0ZUVsZW1lbnQodGFnRGlhbG9nIGFzIG5ldmVyLCB7IC4uLmRpYWxvZ1Byb3BzLCBjaGlsZHJlbjogPD57ZGlhbG9nQ2hpbGRyZW59e3RpdGxlfXtib2R5fTwvPiB9KTtcbiAgICAgICAgY29uc3QgYmFja2Ryb3AgPSBjcmVhdGVFbGVtZW50KHRhZ0JhY2tkcm9wIGFzIG5ldmVyLCBiYWNrZHJvcFByb3BzLCBiYWNrZHJvcENoaWxkcmVuKTtcbiAgICAgICAgY29uc3QgZm9jdXNDb250YWluZXIgPSBjcmVhdGVFbGVtZW50KHRhZ0ZvY3VzQ29udGFpbmVyIGFzIG5ldmVyLCBmb2N1c0NvbnRhaW5lclByb3BzLCA8Pntmb2N1c0NvbnRhaW5lckNoaWxkcmVufXtkaWFsb2d9e2JhY2tkcm9wfTwvPilcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJQb3J0YWwoe1xuICAgICAgICAgICAgcG9ydGFsSWQsXG4gICAgICAgICAgICBjaGlsZHJlbjogZm9jdXNDb250YWluZXJcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHBvcnRhbElkLCB0YWdGb2N1c0NvbnRhaW5lciwgdGFnQmFja2Ryb3AsIHRhZ0JvZHksIHRhZ0RpYWxvZywgdGFnVGl0bGUsIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyLCBtYWtlUHJvcHNCYWNrZHJvcCwgbWFrZVByb3BzQm9keSwgbWFrZVByb3BzRGlhbG9nLCBtYWtlUHJvcHNUaXRsZSB9OiB7IHBvcnRhbElkOiBzdHJpbmcsIHRhZ0ZvY3VzQ29udGFpbmVyOiBFbGVtZW50VG9UYWc8Rm9jdXNDb250YWluZXJFbGVtZW50PiwgdGFnRGlhbG9nOiBFbGVtZW50VG9UYWc8RGlhbG9nRWxlbWVudD47IHRhZ1RpdGxlOiBFbGVtZW50VG9UYWc8VGl0bGVFbGVtZW50PjsgdGFnQm9keTogRWxlbWVudFRvVGFnPEJvZHlFbGVtZW50PjsgdGFnQmFja2Ryb3A6IEVsZW1lbnRUb1RhZzxCYWNrZHJvcEVsZW1lbnQ+LCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lcjogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxGb2N1c0NvbnRhaW5lckVsZW1lbnQ+LCBtYWtlUHJvcHNEaWFsb2c6IChpbmZvOiBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RGlhbG9nRWxlbWVudD4sIG1ha2VQcm9wc0JvZHk6IChpbmZvOiBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Qm9keUVsZW1lbnQ+LCBtYWtlUHJvcHNUaXRsZTogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUaXRsZUVsZW1lbnQ+LCBtYWtlUHJvcHNCYWNrZHJvcDogKGluZm86IFVzZURpYWxvZ1JldHVyblR5cGVJbmZvKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxCYWNrZHJvcEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlck1vZGFsPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50LCBVc2VEaWFsb2dSZXR1cm5UeXBlSW5mbz4oeyBwb3J0YWxJZCwgdGFnRm9jdXNDb250YWluZXIsIHRhZ0JhY2tkcm9wLCB0YWdCb2R5LCB0YWdEaWFsb2csIHRhZ1RpdGxlLCBtYWtlUHJvcHNGb2N1c0NvbnRhaW5lciwgbWFrZVByb3BzQmFja2Ryb3AsIG1ha2VQcm9wc0JvZHksIG1ha2VQcm9wc0RpYWxvZywgbWFrZVByb3BzVGl0bGUgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgVGl0bGVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJvZHlFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEJhY2tkcm9wRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7XG4gICAgb25DbG9zZSxcbiAgICBvcGVuLFxuICAgIGJvZHlJc09ubHlTZW1hbnRpYyxcbiAgICBnZXREb2N1bWVudCxcbiAgICBnZXRXaW5kb3csXG4gICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlLFxuICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsXG4gICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLFxuICAgIGZvY3VzU2VsZixcbiAgICByZW5kZXJcbn06IERpYWxvZ1Byb3BzPEZvY3VzQ29udGFpbmVyRWxlbWVudCwgRGlhbG9nRWxlbWVudCwgVGl0bGVFbGVtZW50LCBCb2R5RWxlbWVudCwgQmFja2Ryb3BFbGVtZW50Pikge1xuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlRGlhbG9nQmFja2Ryb3AsXG4gICAgICAgIHVzZURpYWxvZ0JvZHksXG4gICAgICAgIHVzZURpYWxvZ1Byb3BzLFxuICAgICAgICB1c2VEaWFsb2dUaXRsZSxcbiAgICAgICAgdXNlRGlhbG9nRm9jdXNDb250YWluZXJQcm9wcyxcbiAgICAgICAgLi4uclxuICAgIH0gPSB1c2VEaWFsb2c8Rm9jdXNDb250YWluZXJFbGVtZW50LCBEaWFsb2dFbGVtZW50LCBUaXRsZUVsZW1lbnQsIEJvZHlFbGVtZW50LCBCYWNrZHJvcEVsZW1lbnQ+KHsgZGlhbG9nOiB7IG9uQ2xvc2UgfSwgbW9kYWw6IHsgYm9keUlzT25seVNlbWFudGljLCBmb2N1c1NlbGYgfSwgc29mdERpc21pc3M6IHsgb3BlbiB9LCBhY3RpdmVFbGVtZW50OiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH0gfSk7XG5cbiAgICBjb25zdCB7IHVzZURpYWxvZ1RpdGxlUHJvcHMgfSA9IHVzZURpYWxvZ1RpdGxlKCk7XG4gICAgY29uc3QgeyB1c2VEaWFsb2dCb2R5UHJvcHMgfSA9IHVzZURpYWxvZ0JvZHkoKTtcbiAgICBjb25zdCB7IHVzZURpYWxvZ0JhY2tkcm9wUHJvcHMgfSA9IHVzZURpYWxvZ0JhY2tkcm9wKCk7XG5cbiAgICByZXR1cm4gcmVuZGVyKHIsIHVzZURpYWxvZ0ZvY3VzQ29udGFpbmVyUHJvcHMsIHVzZURpYWxvZ1Byb3BzLCB1c2VEaWFsb2dUaXRsZVByb3BzLCB1c2VEaWFsb2dCb2R5UHJvcHMsIHVzZURpYWxvZ0JhY2tkcm9wUHJvcHMpO1xuXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XG4vL2ltcG9ydCB7IEVsZW1lbnRUb1RhZyB9IGZyb20gXCIuLi9wcm9wc1wiO1xuaW1wb3J0IHsgdXNlTGlzdGJveFNpbmdsZSwgdXNlTGlzdGJveEdyb3VwLCBVc2VMaXN0Ym94U2luZ2xlSXRlbSwgVXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzLCBVc2VMaXN0Ym94U2luZ2xlSXRlbVJldHVyblR5cGVJbmZvLCBVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVycywgVXNlTGlzdGJveFNpbmdsZVJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS1saXN0Ym94LXNpbmdsZVwiO1xuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIExpc3Rib3hTaW5nbGVQcm9wczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwic2luZ2xlU2VsZWN0aW9uXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJsaXN0TmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwiY2hpbGRyZW5IYXZlRm9jdXNcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImxpc3Rib3hTaW5nbGVcIj4ge1xuICAgIC8vdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+O1xuICAgIHJlbmRlcihpbmZvOiBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiwgbW9kaWZ5UHJvcHNMYWJlbDogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4sIG1vZGlmeVByb3BzTGlzdDogUHJvcE1vZGlmaWVyPExpc3RFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cblxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIExpc3Rib3hTaW5nbGVJdGVtUHJvcHM8TGlzdGJveEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnM8TGlzdGJveEl0ZW1FbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXG4gICAgT21pdDxHZXQ8VXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzPExpc3Rib3hJdGVtRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sIFwic3ViSW5mb1wiPixcbiAgICBHZXQ8VXNlTGlzdGJveFNpbmdsZUl0ZW1QYXJhbWV0ZXJzPExpc3Rib3hJdGVtRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hTaW5nbGVJdGVtUGFyYW1ldGVyczxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBcImhhc0ZvY3VzXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94U2luZ2xlSXRlbVBhcmFtZXRlcnM8TGlzdGJveEl0ZW1FbGVtZW50PiwgXCJsaXN0Ym94U2luZ2xlSXRlbVwiPiB7XG4gICAgLy90YWdMaXN0SXRlbTogRWxlbWVudFRvVGFnPExpc3Rib3hJdGVtRWxlbWVudD47XG4gICAgcmVuZGVyKGluZm86IFVzZUxpc3Rib3hTaW5nbGVJdGVtUmV0dXJuVHlwZUluZm88TGlzdGJveEl0ZW1FbGVtZW50PiwgbW9kaWZ5TGlzdEl0ZW1Qcm9wczogUHJvcE1vZGlmaWVyPExpc3Rib3hJdGVtRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuXG5jb25zdCBMaXN0Ym94U2luZ2xlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlTGlzdGJveFNpbmdsZUl0ZW08YW55Pj4obnVsbCEpO1xuXG5mdW5jdGlvbiBMaXN0Ym94U2luZ2xlVTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oe1xuICAgIHJlbmRlcixcblxuICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgdGFnTGFiZWwsXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgaW5kZXhEZW1hbmdsZXIsXG4gICAgaW5kZXhNYW5nbGVyLFxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb25UYWJiYWJsZVJlbmRlcixcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIG9uQWxsTG9zdEZvY3VzLFxuICAgIG9uQW55R2FpbmVkRm9jdXMsXG4gICAgc2VsZWN0aW9uTW9kZSxcbiAgICB0YWdMaXN0LFxuICAgIG9uU2VsZWN0XG59OiBMaXN0Ym94U2luZ2xlUHJvcHM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50Pikge1xuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZUl0ZW0sXG4gICAgICAgIHVzZUxpc3Rib3hTaW5nbGVMYWJlbCxcbiAgICAgICAgdXNlTGlzdGJveFNpbmdsZVByb3BzLFxuICAgICAgICAuLi5saXN0Ym94UmV0dXJuVHlwZVxuICAgIH0gPSB1c2VMaXN0Ym94U2luZ2xlPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxuICAgICAgICBsaXN0Ym94U2luZ2xlOiB7IHRhZ0xhYmVsLCB0YWdMaXN0LCBvblNlbGVjdCB9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXgsIHNlbGVjdGlvbk1vZGUgfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfSxcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXM6IHsgb25BbGxMb3N0Rm9jdXMsIG9uQW55R2FpbmVkRm9jdXMgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcyB9ID0gdXNlTGlzdGJveFNpbmdsZUxhYmVsKCk7XG4gICAgLy9jb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwsIHVzZUxpc3Rib3hTaW5nbGVMYWJlbFByb3BzKHt9KSBhcyBhbnkpO1xuICAgIC8vY29uc3QgbGlzdCA9IGNyZWF0ZUVsZW1lbnQodGFnTGlzdCwgdXNlTGlzdGJveFNpbmdsZVByb3BzKHsgY2hpbGRyZW46IHZub2RlQ2hpbGRyZW4sIHJlZiB9KSBhcyBhbnkpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8TGlzdGJveFNpbmdsZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUxpc3Rib3hTaW5nbGVJdGVtfT5cbiAgICAgICAgICAgIHtyZW5kZXIoeyAuLi5saXN0Ym94UmV0dXJuVHlwZSB9LCB1c2VMaXN0Ym94U2luZ2xlTGFiZWxQcm9wcywgdXNlTGlzdGJveFNpbmdsZVByb3BzKX1cbiAgICAgICAgPC9MaXN0Ym94U2luZ2xlQ29udGV4dC5Qcm92aWRlcj5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyTGlzdGJveFNpbmdsZTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IG1ha2VQcm9wc0xpc3QsIG1ha2VQcm9wc0xhYmVsLCB0YWdMYWJlbCwgdGFnTGlzdCB9OiB7IHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PiwgdGFnTGlzdDogRWxlbWVudFRvVGFnPExpc3RFbGVtZW50PiwgbWFrZVByb3BzTGFiZWw6IChpbmZvOiBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiwgbWFrZVByb3BzTGlzdDogKGluZm86IFVzZUxpc3Rib3hTaW5nbGVSZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0RWxlbWVudD4gfSkge1xuICAgIHJldHVybiBkZWZhdWx0UmVuZGVyTGlzdDxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50LCBVc2VMaXN0Ym94U2luZ2xlUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50Pj4oeyBtYWtlUHJvcHNMYWJlbCwgbWFrZVByb3BzTGlzdCwgdGFnTGFiZWwsIHRhZ0xpc3QgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJMaXN0Ym94U2luZ2xlSXRlbTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBtYWtlUHJvcHNMaXN0SXRlbSwgdGFnTGlzdEl0ZW0gfTogeyB0YWdMaXN0SXRlbTogRWxlbWVudFRvVGFnPExpc3RJdGVtRWxlbWVudD4sIG1ha2VQcm9wc0xpc3RJdGVtOiAoaW5mbzogVXNlTGlzdGJveFNpbmdsZUl0ZW1SZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMaXN0SXRlbUVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlckxpc3RJdGVtPExpc3RJdGVtRWxlbWVudCwgVXNlTGlzdGJveFNpbmdsZUl0ZW1SZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+Pih7IG1ha2VQcm9wc0xpc3RJdGVtLCB0YWdMaXN0SXRlbSB9KTtcbn1cblxuXG5cbmZ1bmN0aW9uIExpc3Rib3hTaW5nbGVJdGVtVTxMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGluZGV4LCBibHVyU2VsZiwgZGlzYWJsZWQsIGZsYWdzLCBmb2N1c1NlbGYsIGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmVuZGVyLCB0ZXh0LCBoaWRkZW4gfTogTGlzdGJveFNpbmdsZUl0ZW1Qcm9wczxMaXN0SXRlbUVsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VMaXN0Ym94U2luZ2xlSXRlbVByb3BzLCByb3ZpbmdUYWJJbmRleCwgc2luZ2xlU2VsZWN0aW9uIH0gPSB1c2VDb250ZXh0KExpc3Rib3hTaW5nbGVDb250ZXh0KSh7XG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcbiAgICAgICAgbGlzdGJveFNpbmdsZUl0ZW06IHsgZGlzYWJsZWQgfSxcbiAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDw+e3JlbmRlcih7IHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24gfSwgdXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyl9PC8+XG4gICAgKVxufVxuXG5leHBvcnQgY29uc3QgTGlzdGJveFNpbmdsZSA9IGZvcndhcmRSZWYoTGlzdGJveFNpbmdsZVUpIGFzIHR5cGVvZiBMaXN0Ym94U2luZ2xlVTtcbmV4cG9ydCBjb25zdCBMaXN0Ym94U2luZ2xlSXRlbSA9IGZvcndhcmRSZWYoTGlzdGJveFNpbmdsZUl0ZW1VKSBhcyB0eXBlb2YgTGlzdGJveFNpbmdsZUl0ZW1VO1xuZXhwb3J0IGNvbnN0IExpc3Rib3hHcm91cCA9IGZvcndhcmRSZWYoTGlzdGJveEdyb3VwVSkgYXMgdHlwZW9mIExpc3Rib3hHcm91cFU7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdGJveEdyb3VwUHJvcHM8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICByZW5kZXIobW9kaWZ5Q29udGFpbmVyUHJvcHM6IFByb3BNb2RpZmllcjxDb250YWluZXJFbGVtZW50PiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4pOiBWTm9kZTtcbn1cblxuZnVuY3Rpb24gTGlzdGJveEdyb3VwVTxDb250YWluZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIgfTogTGlzdGJveEdyb3VwUHJvcHM8Q29udGFpbmVyRWxlbWVudCwgTGFiZWxFbGVtZW50Pikge1xuICAgIGNvbnN0IHsgdXNlTGlzdGJveEdyb3VwSGVhZGluZ1Byb3BzLCB1c2VMaXN0Ym94R3JvdXBDb250YWluZXJQcm9wcyB9ID0gdXNlTGlzdGJveEdyb3VwPENvbnRhaW5lckVsZW1lbnQsIExhYmVsRWxlbWVudD4oKTtcbiAgICByZXR1cm4gKHJlbmRlcih1c2VMaXN0Ym94R3JvdXBDb250YWluZXJQcm9wcywgdXNlTGlzdGJveEdyb3VwSGVhZGluZ1Byb3BzKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRMaXN0Ym94R3JvdXBSZW5kZXI8Q29udGFpbmVyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnQ29udGFpbmVyLCB0YWdMYWJlbCwgbWFrZVByb3BzQ29udGFpbmVyLCBtYWtlUHJvcHNMYWJlbCB9OiB7IHRhZ0NvbnRhaW5lcjogRWxlbWVudFRvVGFnPENvbnRhaW5lckVsZW1lbnQ+LCB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD4sIG1ha2VQcm9wc0NvbnRhaW5lcjogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q29udGFpbmVyRWxlbWVudD4sIG1ha2VQcm9wc0xhYmVsOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZGlmeUNvbnRhaW5lclByb3BzOiBQcm9wTW9kaWZpZXI8Q29udGFpbmVyRWxlbWVudD4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxMYWJlbEVsZW1lbnQ+KSB7XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnByb3BzQ29udGFpbmVyIH0gPSBtb2RpZnlDb250YWluZXJQcm9wcyhtYWtlUHJvcHNDb250YWluZXIoKSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ0NvbnRhaW5lciBhcyBuZXZlciwgcHJvcHNDb250YWluZXIsIDw+XG4gICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdMYWJlbCBhcyBuZXZlciwgbW9kaWZ5TGFiZWxQcm9wcyhtYWtlUHJvcHNMYWJlbCgpKSl9XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvPilcbiAgICB9XG59XG5cblxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckxpc3Q8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSW5mb1R5cGU+KHsgbWFrZVByb3BzTGlzdCwgbWFrZVByb3BzTGFiZWwsIHRhZ0xhYmVsLCB0YWdMaXN0IH06IHsgdGFnTGFiZWw6IEVsZW1lbnRUb1RhZzxMYWJlbEVsZW1lbnQ+LCB0YWdMaXN0OiBFbGVtZW50VG9UYWc8TGlzdEVsZW1lbnQ+LCBtYWtlUHJvcHNMYWJlbDogKGluZm86IEluZm9UeXBlKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+LCBtYWtlUHJvcHNMaXN0OiAoaW5mbzogSW5mb1R5cGUpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBJbmZvVHlwZSwgbW9kaWZ5UHJvcHNMYWJlbDogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4sIG1vZGlmeVByb3BzTGlzdDogUHJvcE1vZGlmaWVyPExpc3RFbGVtZW50Pik6IFZOb2RlPGFueT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNyZWF0ZUVsZW1lbnQodGFnTGFiZWwgYXMgbmV2ZXIsIG1vZGlmeVByb3BzTGFiZWwobWFrZVByb3BzTGFiZWwoaW5mbykpKTtcbiAgICAgICAgY29uc3QgbGlzdCA9IGNyZWF0ZUVsZW1lbnQodGFnTGlzdCBhcyBuZXZlciwgbW9kaWZ5UHJvcHNMaXN0KG1ha2VQcm9wc0xpc3QoaW5mbykpKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAge2xhYmVsfVxuICAgICAgICAgICAgICAgIHtsaXN0fVxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyTGlzdEl0ZW08TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIEluZm9UeXBlPih7IG1ha2VQcm9wc0xpc3RJdGVtLCB0YWdMaXN0SXRlbSB9OiB7IHRhZ0xpc3RJdGVtOiBFbGVtZW50VG9UYWc8TGlzdEl0ZW1FbGVtZW50PiwgbWFrZVByb3BzTGlzdEl0ZW06IChpbmZvOiBJbmZvVHlwZSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEl0ZW1FbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBJbmZvVHlwZSwgbW9kaWZ5UHJvcHNMaXN0SXRlbTogUHJvcE1vZGlmaWVyPExpc3RJdGVtRWxlbWVudD4pOiBWTm9kZTxhbnk+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnTGlzdEl0ZW0gYXMgbmV2ZXIsIG1vZGlmeVByb3BzTGlzdEl0ZW0obWFrZVByb3BzTGlzdEl0ZW0oaW5mbykpKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xuaW1wb3J0IHsgdXNlTGlzdGJveE11bHRpLCBVc2VMaXN0Ym94TXVsdGlJdGVtLCBVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVycywgVXNlTGlzdGJveE11bHRpSXRlbVJldHVyblR5cGVJbmZvLCBVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzLCBVc2VMaXN0Ym94TXVsdGlSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtbGlzdGJveC1tdWx0aVwiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlckxpc3QsIGRlZmF1bHRSZW5kZXJMaXN0SXRlbSB9IGZyb20gXCIuL2xpc3Rib3gtc2luZ2xlXCI7XG5cblxuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xuXG5leHBvcnQgaW50ZXJmYWNlIExpc3Rib3hNdWx0aVByb3BzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlQYXJhbWV0ZXJzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQ+LCBcImxpbmVhck5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlTGlzdGJveE11bHRpUGFyYW1ldGVyczxMYWJlbEVsZW1lbnQsIExpc3RFbGVtZW50PiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aVBhcmFtZXRlcnM8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudD4sIFwibGlzdGJveE11bHRpXCI+IHtcbiAgICAvL3RhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PjtcbiAgICByZW5kZXIoaW5mbzogVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PiwgbW9kaWZ5UHJvcHNMYWJlbDogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4sIG1vZGlmeVByb3BzTGlzdDogUHJvcE1vZGlmaWVyPExpc3RFbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cblxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIExpc3Rib3hNdWx0aUl0ZW1Qcm9wczxMaXN0Ym94SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZUxpc3Rib3hNdWx0aUl0ZW1QYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZFwiPixcbiAgICBPbWl0PEdldDxVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVycywgXCJsaXN0TmF2aWdhdGlvblwiPiwgXCJzdWJJbmZvXCI+LFxuICAgIEdldDxVc2VMaXN0Ym94TXVsdGlJdGVtUGFyYW1ldGVycywgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQ8VXNlTGlzdGJveE11bHRpSXRlbVBhcmFtZXRlcnMsIFwibGlzdGJveE11bHRpSXRlbVwiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlSW5mbzxMaXN0Ym94SXRlbUVsZW1lbnQ+LCBtb2RpZnlMaXN0SXRlbVByb3BzOiBQcm9wTW9kaWZpZXI8TGlzdGJveEl0ZW1FbGVtZW50Pik6IFZOb2RlPGFueT47XG59XG5cbmV4cG9ydCBjb25zdCBMaXN0Ym94TXVsdGlDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VMaXN0Ym94TXVsdGlJdGVtPGFueT4+KG51bGwhKTtcblxuZnVuY3Rpb24gTGlzdGJveE11bHRpVTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudD4oe1xuICAgIHJlbmRlcixcbiAgICB0YWdMYWJlbCxcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBpbmRleERlbWFuZ2xlcixcbiAgICBpbmRleE1hbmdsZXIsXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb25UYWJiYWJsZVJlbmRlcixcblxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgdGFnTGlzdCxcbn06IExpc3Rib3hNdWx0aVByb3BzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4pIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3Rib3hNdWx0aUl0ZW0sXG4gICAgICAgIHVzZUxpc3Rib3hNdWx0aUxhYmVsLFxuICAgICAgICB1c2VMaXN0Ym94TXVsdGlQcm9wcyxcbiAgICAgICAgLi4ubGlzdGJveFJldHVyblR5cGVcbiAgICB9ID0gdXNlTGlzdGJveE11bHRpPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIExpc3RJdGVtRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cywgbmF2aWdhdGlvbkRpcmVjdGlvbiB9LFxuICAgICAgICBsaXN0Ym94TXVsdGk6IHsgdGFnTGFiZWwsIHRhZ0xpc3QgfSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIgfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VMaXN0Ym94TXVsdGlMYWJlbFByb3BzIH0gPSB1c2VMaXN0Ym94TXVsdGlMYWJlbCgpO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxMaXN0Ym94TXVsdGlDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VMaXN0Ym94TXVsdGlJdGVtfT5cbiAgICAgICAgICAgIHtyZW5kZXIobGlzdGJveFJldHVyblR5cGUsIHVzZUxpc3Rib3hNdWx0aUxhYmVsUHJvcHMsIHVzZUxpc3Rib3hNdWx0aVByb3BzKX1cbiAgICAgICAgPC9MaXN0Ym94TXVsdGlDb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlckxpc3Rib3hNdWx0aTxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50LCBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IG1ha2VQcm9wc0xpc3QsIG1ha2VQcm9wc0xhYmVsLCB0YWdMYWJlbCwgdGFnTGlzdCB9OiB7IHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PiwgdGFnTGlzdDogRWxlbWVudFRvVGFnPExpc3RFbGVtZW50PiwgbWFrZVByb3BzTGFiZWw6IChpbmZvOiBVc2VMaXN0Ym94TXVsdGlSZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxMYWJlbEVsZW1lbnQ+LCBtYWtlUHJvcHNMaXN0OiAoaW5mbzogVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlckxpc3Q8TGFiZWxFbGVtZW50LCBMaXN0RWxlbWVudCwgVXNlTGlzdGJveE11bHRpUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50Pj4oeyBtYWtlUHJvcHNMYWJlbCwgbWFrZVByb3BzTGlzdCwgdGFnTGFiZWwsIHRhZ0xpc3QgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJMaXN0Ym94TXVsdGlJdGVtPExpc3RJdGVtRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IG1ha2VQcm9wc0xpc3RJdGVtLCB0YWdMaXN0SXRlbSB9OiB7IHRhZ0xpc3RJdGVtOiBFbGVtZW50VG9UYWc8TGlzdEl0ZW1FbGVtZW50PiwgbWFrZVByb3BzTGlzdEl0ZW06IChpbmZvOiBVc2VMaXN0Ym94TXVsdGlJdGVtUmV0dXJuVHlwZUluZm88TGlzdEl0ZW1FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGlzdEl0ZW1FbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGRlZmF1bHRSZW5kZXJMaXN0SXRlbTxMaXN0SXRlbUVsZW1lbnQsIFVzZUxpc3Rib3hNdWx0aUl0ZW1SZXR1cm5UeXBlSW5mbzxMaXN0SXRlbUVsZW1lbnQ+Pih7IG1ha2VQcm9wc0xpc3RJdGVtLCB0YWdMaXN0SXRlbSB9KTtcbn1cblxuZnVuY3Rpb24gTGlzdGJveE11bHRpSXRlbVU8TGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBpbmRleCwgYmx1clNlbGYsIGRpc2FibGVkLCBmbGFncywgZm9jdXNTZWxmLCByZW5kZXIsIHRleHQsIGhpZGRlbiwgc2VsZWN0ZWQsIG9uU2VsZWN0ZWRDaGFuZ2UgfTogTGlzdGJveE11bHRpSXRlbVByb3BzPExpc3RJdGVtRWxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcywgLi4uaXRlbVJldHVybiB9ID0gdXNlQ29udGV4dChMaXN0Ym94TXVsdGlDb250ZXh0KSh7XG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcbiAgICAgICAgbGlzdGJveE11bHRpSXRlbTogeyBkaXNhYmxlZCwgc2VsZWN0ZWQsIG9uU2VsZWN0ZWRDaGFuZ2UgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD57cmVuZGVyKGl0ZW1SZXR1cm4sIHVzZUxpc3Rib3hNdWx0aUl0ZW1Qcm9wcyl9PC8+XG4gICAgKVxufVxuXG5leHBvcnQgY29uc3QgTGlzdGJveE11bHRpID0gZm9yd2FyZFJlZihMaXN0Ym94TXVsdGlVKSBhcyB0eXBlb2YgTGlzdGJveE11bHRpVTtcbmV4cG9ydCBjb25zdCBMaXN0Ym94TXVsdGlJdGVtID0gZm9yd2FyZFJlZihMaXN0Ym94TXVsdGlJdGVtVSkgYXMgdHlwZW9mIExpc3Rib3hNdWx0aUl0ZW1VO1xuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycywgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XG5pbXBvcnQgeyB1c2VNZW51LCBVc2VNZW51SXRlbVBhcmFtZXRlcnMsIFVzZU1lbnVJdGVtUmV0dXJuVHlwZUluZm8sIFVzZU1lbnVQYXJhbWV0ZXJzLCBVc2VNZW51UmV0dXJuVHlwZUluZm8sIFVzZU1lbnVJdGVtIH0gZnJvbSBcIi4uL3VzZS1tZW51XCI7XG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyUG9ydGFsIH0gZnJvbSBcIi4vZGlhbG9nXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVudVByb3BzPFN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTZW50aW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyAvL09taXQ8VXNlTWVudVBhcmFtZXRlcnM8RSwgSywgST4sIFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIgfCBcIm9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdFwiIHwgXCJvbkNoaWxkcmVuTW91bnRDaGFuZ2VcIiB8IFwib25UYWJiYWJsZUluZGV4Q2hhbmdlXCIgfCBcIm9uVGFiYmFibGVSZW5kZXJcIiB8IFwib25UYWJiZWRJblRvXCIgfCBcIm9uVGFiYmVkT3V0T2ZcIj4gJiB7XG4gICAgR2V0PFVzZU1lbnVQYXJhbWV0ZXJzPFN1cmZhY2VFbGVtZW50LCBCdXR0b25FbGVtZW50LCBuZXZlcj4sIFwibWVudVwiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJtZW51U3VyZmFjZVwiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJzb2Z0RGlzbWlzc1wiPixcbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxTdXJmYWNlRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgbmV2ZXI+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxTdXJmYWNlRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgbmV2ZXI+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VNZW51UGFyYW1ldGVyczxTdXJmYWNlRWxlbWVudCwgQnV0dG9uRWxlbWVudCwgbmV2ZXI+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4sXG5cbiAgICBHZXQ8VXNlTWVudVBhcmFtZXRlcnM8U3VyZmFjZUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQsIG5ldmVyPiwgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4ge1xuICAgIC8vcHJvcHNNZW51QnV0dG9uOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+O1xuICAgIC8vcHJvcHNNZW51U2VudGluZWw6ICh3aGljaDogXCJ0b3BcIiB8IFwiYm90dG9tXCIpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT47XG4gICAgLy9wcm9wc01lbnU6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT47XG5cbiAgICAvL3RhZ01lbnVCdXR0b246IGFueTtcbiAgICAvL3RhZ01lbnU6IGFueTtcbiAgICAvL3RhZ1NlbnRpbmVsOiBhbnk7XG5cbiAgICBnZXREb2N1bWVudDogVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnNbXCJnZXREb2N1bWVudFwiXTtcbiAgICBnZXRXaW5kb3c/OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyc1tcImdldFdpbmRvd1wiXTtcblxuICAgIHJlbmRlcihtZW51SW5mbzogVXNlTWVudVJldHVyblR5cGVJbmZvPFN1cmZhY2VFbGVtZW50LCBNZW51RWxlbWVudCwgTWVudUl0ZW1FbGVtZW50LCBCdXR0b25FbGVtZW50PiwgbW9kaWZ5TWVudUJ1dHRvblByb3BzOiBQcm9wTW9kaWZpZXI8QnV0dG9uRWxlbWVudD4sIG1vZGlmeU1lbnVTdXJmYWNlUHJvcHM6IFByb3BNb2RpZmllcjxTdXJmYWNlRWxlbWVudD4sIG1vZGlmeU1lbnVQcm9wczogUHJvcE1vZGlmaWVyPE1lbnVFbGVtZW50PiwgbW9kaWZ5Rmlyc3RTZW50aW5lbFByb3BzOiBQcm9wTW9kaWZpZXI8U2VudGluZWxFbGVtZW50PiwgbW9kaWZ5TGFzdFNlbnRpbmVsUHJvcHM6IFByb3BNb2RpZmllcjxTZW50aW5lbEVsZW1lbnQ+KTogVk5vZGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVudUl0ZW1Qcm9wczxNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzXG4gICAgR2V0PFVzZU1lbnVJdGVtUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRcIj4sXG4gICAgR2V0PFVzZU1lbnVJdGVtUGFyYW1ldGVycywgXCJsaXN0TmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlTWVudUl0ZW1QYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+IHtcbiAgICByZW5kZXIoaW5mbzogVXNlTWVudUl0ZW1SZXR1cm5UeXBlSW5mbzxNZW51SXRlbUVsZW1lbnQ+LCBtb2RpZnlMaXN0SXRlbVByb3BzOiBQcm9wTW9kaWZpZXI8TWVudUl0ZW1FbGVtZW50Pik6IFZOb2RlO1xuICAgIC8vdGFnTWVudUl0ZW06IGFueTtcbiAgICAvL3Byb3BzTWVudUl0ZW06ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT5cbn1cblxuY29uc3QgTWVudUl0ZW1Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VNZW51SXRlbTxhbnk+PihudWxsISk7XG5cbmV4cG9ydCBmdW5jdGlvbiBNZW51PFN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNlbnRpbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7XG4gICAgaW5pdGlhbEluZGV4LFxuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgdHlwZWFoZWFkVGltZW91dCxcbiAgICBvbk9wZW4sXG4gICAgb25DbG9zZSxcbiAgICBvcGVuLFxuXG4gICAgb3BlbkRpcmVjdGlvbixcbiAgICBpbmRleERlbWFuZ2xlcixcbiAgICBpbmRleE1hbmdsZXIsXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb25UYWJiYWJsZVJlbmRlcixcblxuICAgIGdldERvY3VtZW50LFxuICAgIGdldFdpbmRvdyxcblxuICAgIHJlbmRlclxuXG59OiBNZW51UHJvcHM8U3VyZmFjZUVsZW1lbnQsIFBhcmVudEVsZW1lbnQsIFNlbnRpbmVsRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBCdXR0b25FbGVtZW50Pikge1xuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTWVudUJ1dHRvblByb3BzLFxuICAgICAgICB1c2VNZW51SXRlbSxcbiAgICAgICAgdXNlTWVudVByb3BzLFxuICAgICAgICB1c2VNZW51U2VudGluZWwsXG4gICAgICAgIHVzZU1lbnVTdXJmYWNlUHJvcHMsXG4gICAgICAgIC4uLm1lbnVSZXR1cm5cbiAgICB9ID0gdXNlTWVudTxTdXJmYWNlRWxlbWVudCwgUGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBCdXR0b25FbGVtZW50Pih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzLCBuYXZpZ2F0aW9uRGlyZWN0aW9uIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXG4gICAgICAgIG1lbnU6IHsgb25PcGVuOiB1c2VTdGFibGVDYWxsYmFjayhvbk9wZW4pLCBvcGVuRGlyZWN0aW9uIH0sXG4gICAgICAgIG1lbnVTdXJmYWNlOiB7fSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIgfSxcbiAgICAgICAgc29mdERpc21pc3M6IHsgb25DbG9zZTogdXNlU3RhYmxlQ2FsbGJhY2sob25DbG9zZSksIG9wZW4gfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfSxcbiAgICAgICAgYWN0aXZlRWxlbWVudDogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93IH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZU1lbnVTZW50aW5lbFByb3BzOiB1c2VGaXJzdFNlbnRpbmVsUHJvcHMgfSA9IHVzZU1lbnVTZW50aW5lbDxTZW50aW5lbEVsZW1lbnQ+KCk7XG4gICAgY29uc3QgeyB1c2VNZW51U2VudGluZWxQcm9wczogdXNlTGFzdFNlbnRpbmVsUHJvcHMgfSA9IHVzZU1lbnVTZW50aW5lbDxTZW50aW5lbEVsZW1lbnQ+KCk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPE1lbnVJdGVtQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlTWVudUl0ZW19PlxuICAgICAgICAgICAge3JlbmRlcihtZW51UmV0dXJuLCB1c2VNZW51QnV0dG9uUHJvcHMsIHVzZU1lbnVTdXJmYWNlUHJvcHMsIHVzZU1lbnVQcm9wcywgdXNlRmlyc3RTZW50aW5lbFByb3BzLCB1c2VMYXN0U2VudGluZWxQcm9wcyl9XG4gICAgICAgIDwvTWVudUl0ZW1Db250ZXh0LlByb3ZpZGVyPlxuICAgIClcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gTWVudUl0ZW08TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIsIGluZGV4LCB0ZXh0LCBoaWRkZW4sIGJsdXJTZWxmLCBmbGFncywgZm9jdXNTZWxmIH06IE1lbnVJdGVtUHJvcHM8TWVudUl0ZW1FbGVtZW50Pikge1xuICAgIGNvbnN0IHsgdXNlTWVudUl0ZW1Qcm9wcywgLi4ucmVzdCB9ID0gdXNlQ29udGV4dChNZW51SXRlbUNvbnRleHQpKHtcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGJsdXJTZWxmLCBmb2N1c1NlbGYsIGhpZGRlbiB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlbmRlcihyZXN0LCB1c2VNZW51SXRlbVByb3BzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJNZW51PFN1cmZhY2VFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTWVudUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBTZW50aW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBCdXR0b25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBwb3J0YWxJZCwgdGFnQnV0dG9uLCB0YWdNZW51LCB0YWdTdXJmYWNlLCB0YWdTZW50aW5lbCwgbWFrZVByb3BzQnV0dG9uLCBtYWtlUHJvcHNNZW51LCBtYWtlUHJvcHNTdXJmYWNlLCBtYWtlUHJvcHNTZW50aW5lbCB9OiB7IHBvcnRhbElkOiBzdHJpbmcsIHRhZ1N1cmZhY2U6IEVsZW1lbnRUb1RhZzxTdXJmYWNlRWxlbWVudD4sIHRhZ01lbnU6IEVsZW1lbnRUb1RhZzxNZW51RWxlbWVudD4sIHRhZ0J1dHRvbjogRWxlbWVudFRvVGFnPEJ1dHRvbkVsZW1lbnQ+LCB0YWdTZW50aW5lbDogRWxlbWVudFRvVGFnPFNlbnRpbmVsRWxlbWVudD4sIG1ha2VQcm9wc1N1cmZhY2U6IChpbmZvOiBVc2VNZW51UmV0dXJuVHlwZUluZm88U3VyZmFjZUVsZW1lbnQsIE1lbnVFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxTdXJmYWNlRWxlbWVudD4sIG1ha2VQcm9wc01lbnU6IChpbmZvOiBVc2VNZW51UmV0dXJuVHlwZUluZm88U3VyZmFjZUVsZW1lbnQsIE1lbnVFbGVtZW50LCBNZW51SXRlbUVsZW1lbnQsIEJ1dHRvbkVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxNZW51RWxlbWVudD4sIG1ha2VQcm9wc0J1dHRvbjogKGluZm86IFVzZU1lbnVSZXR1cm5UeXBlSW5mbzxTdXJmYWNlRWxlbWVudCwgTWVudUVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgQnV0dG9uRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEJ1dHRvbkVsZW1lbnQ+LCBtYWtlUHJvcHNTZW50aW5lbDogKGluZm86IFVzZU1lbnVSZXR1cm5UeXBlSW5mbzxTdXJmYWNlRWxlbWVudCwgTWVudUVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgQnV0dG9uRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFNlbnRpbmVsRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWVudUluZm86IFVzZU1lbnVSZXR1cm5UeXBlSW5mbzxTdXJmYWNlRWxlbWVudCwgTWVudUVsZW1lbnQsIE1lbnVJdGVtRWxlbWVudCwgQnV0dG9uRWxlbWVudD4sIG1vZGlmeU1lbnVCdXR0b25Qcm9wczogUHJvcE1vZGlmaWVyPEJ1dHRvbkVsZW1lbnQ+LCBtb2RpZnlNZW51U3VyZmFjZVByb3BzOiBQcm9wTW9kaWZpZXI8U3VyZmFjZUVsZW1lbnQ+LCBtb2RpZnlNZW51UHJvcHM6IFByb3BNb2RpZmllcjxNZW51RWxlbWVudD4sIG1vZGlmeUZpcnN0U2VudGluZWxQcm9wczogUHJvcE1vZGlmaWVyPFNlbnRpbmVsRWxlbWVudD4sIG1vZGlmeUxhc3RTZW50aW5lbFByb3BzOiBQcm9wTW9kaWZpZXI8U2VudGluZWxFbGVtZW50Pikge1xuXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW46IHN1cmZhY2VDaGlsZHJlbiwgLi4uc3VyZmFjZVByb3BzIH0gPSBtb2RpZnlNZW51U3VyZmFjZVByb3BzKG1ha2VQcm9wc1N1cmZhY2UobWVudUluZm8pKTtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogbWVudUNoaWxkcmVuLCAuLi5tZW51UHJvcHMgfSA9IG1vZGlmeU1lbnVQcm9wcyhtYWtlUHJvcHNNZW51KG1lbnVJbmZvKSk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ0J1dHRvbiBhcyBuZXZlciwgbW9kaWZ5TWVudUJ1dHRvblByb3BzKG1ha2VQcm9wc0J1dHRvbihtZW51SW5mbykpKX1cbiAgICAgICAgICAgICAgICB7ZGVmYXVsdFJlbmRlclBvcnRhbCh7XG4gICAgICAgICAgICAgICAgICAgIHBvcnRhbElkLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogY3JlYXRlRWxlbWVudCh0YWdTdXJmYWNlIGFzIG5ldmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdXJmYWNlUHJvcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogKDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnU2VudGluZWwgYXMgbmV2ZXIsIG1vZGlmeUZpcnN0U2VudGluZWxQcm9wcyhtYWtlUHJvcHNTZW50aW5lbChtZW51SW5mbykpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3VyZmFjZUNoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ01lbnUgYXMgbmV2ZXIsIHsgLi4ubWVudVByb3BzLCBjaGlsZHJlbjogPD57bWVudUNoaWxkcmVufTwvPiB9KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Y3JlYXRlRWxlbWVudCh0YWdTZW50aW5lbCBhcyBuZXZlciwgbW9kaWZ5TGFzdFNlbnRpbmVsUHJvcHMobWFrZVByb3BzU2VudGluZWwobWVudUluZm8pKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8Lz4pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICA8Lz5cbiAgICAgICAgKVxuXG4gICAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyTWVudUl0ZW08TWVudUl0ZW1FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNNZW51SXRlbTogbWFrZVByb3BzTWVudUl0ZW0sIHRhZ01lbnVJdGVtIH06IHsgdGFnTWVudUl0ZW06IEVsZW1lbnRUb1RhZzxNZW51SXRlbUVsZW1lbnQ+LCBtYWtlUHJvcHNNZW51SXRlbTogKGluZm86IFVzZU1lbnVJdGVtUmV0dXJuVHlwZUluZm88TWVudUl0ZW1FbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TWVudUl0ZW1FbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VNZW51SXRlbVJldHVyblR5cGVJbmZvPE1lbnVJdGVtRWxlbWVudD4sIG1vZGlmeU1lbnVJdGVtUHJvcHM6IFByb3BNb2RpZmllcjxNZW51SXRlbUVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ01lbnVJdGVtIGFzIG5ldmVyLCBtb2RpZnlNZW51SXRlbVByb3BzKG1ha2VQcm9wc01lbnVJdGVtKGluZm8pKSlcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBFbGVtZW50VG9UYWcsIFByb3BNb2RpZmllciB9IGZyb20gXCJwcm9wc1wiO1xuaW1wb3J0IHsgdXNlUmFkaW9Hcm91cCwgVXNlUmFkaW9Hcm91cFBhcmFtZXRlcnMsIFVzZVJhZGlvR3JvdXBSZXR1cm5UeXBlSW5mbywgVXNlUmFkaW9QYXJhbWV0ZXJzLCBVc2VSYWRpbywgVXNlUmFkaW9SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtcmFkaW8tZ3JvdXBcIjtcbmltcG9ydCB7IGRlZmF1bHRSZW5kZXJDaGVja2JveExpa2UsIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vY2hlY2tib3hcIlxuXG50eXBlIEdldDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBUW0tdO1xudHlwZSBHZXQyPFQsIEsgZXh0ZW5kcyBrZXlvZiBULCBLMiBleHRlbmRzIGtleW9mIFRbS10+ID0gVFtLXVtLMl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmFkaW9Hcm91cFByb3BzPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIEdyb3VwRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlUmFkaW9Hcm91cFBhcmFtZXRlcnM8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50PiwgXCJyYWRpb0dyb3VwXCI+LFxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQ+LCBcImxpbmVhck5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVJhZGlvR3JvdXBQYXJhbWV0ZXJzPFYsIEdyb3VwRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQsIElucHV0RWxlbWVudD4sIFwibWFuYWdlZENoaWxkcmVuXCI+LFxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQ+LCBcImNoaWxkcmVuSGF2ZUZvY3VzXCI+LFxuICAgIEdldDxVc2VSYWRpb0dyb3VwUGFyYW1ldGVyczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQ+LCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xuICAgIC8vcHJvcHNHcm91cExhYmVsOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcm91cExhYmVsRWxlbWVudD47XG4gICAgLy9wcm9wc0dyb3VwOiAoKSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxHcm91cEVsZW1lbnQ+O1xuICAgIHJlbmRlcihpbmZvOiBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88ViwgSW5wdXRFbGVtZW50PiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPEdyb3VwTGFiZWxFbGVtZW50PiwgbW9kaWZ5R3JvdXBQcm9wczogUHJvcE1vZGlmaWVyPEdyb3VwRWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJhZGlvUHJvcHM8ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInJhZGlvXCI+LFxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VSYWRpb1BhcmFtZXRlcnM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZFwiPixcbiAgICBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8SW5wdXRFbGVtZW50PixcbiAgICBHZXQ8VXNlUmFkaW9QYXJhbWV0ZXJzPFYsIElucHV0RWxlbWVudCwgTGFiZWxFbGVtZW50PiwgXCJyYWRpb1wiPiB7XG4gICAgcmVuZGVyKGluZm86IFVzZVJhZGlvUmV0dXJuVHlwZUluZm88SW5wdXRFbGVtZW50PiwgbW9kaWZ5SW5wdXRQcm9wczogUHJvcE1vZGlmaWVyPElucHV0RWxlbWVudD4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxMYWJlbEVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJSYWRpb0dyb3VwPFYgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIsIElucHV0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnR3JvdXAsIHRhZ0xhYmVsLCBtYWtlUHJvcHNHcm91cCwgbWFrZVByb3BzTGFiZWwgfTogeyB0YWdMYWJlbDogRWxlbWVudFRvVGFnPExhYmVsRWxlbWVudD4sIHRhZ0dyb3VwOiBFbGVtZW50VG9UYWc8SW5wdXRFbGVtZW50PiwgbWFrZVByb3BzTGFiZWw6IChpbmZvOiBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88ViwgSW5wdXRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8TGFiZWxFbGVtZW50PiwgbWFrZVByb3BzR3JvdXA6IChpbmZvOiBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88ViwgSW5wdXRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8SW5wdXRFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VSYWRpb0dyb3VwUmV0dXJuVHlwZUluZm88ViwgSW5wdXRFbGVtZW50PiwgbW9kaWZ5TGFiZWxQcm9wczogUHJvcE1vZGlmaWVyPExhYmVsRWxlbWVudD4sIG1vZGlmeUdyb3VwUHJvcHM6IFByb3BNb2RpZmllcjxJbnB1dEVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIHtjcmVhdGVFbGVtZW50KHRhZ0xhYmVsIGFzIG5ldmVyLCBtb2RpZnlMYWJlbFByb3BzKG1ha2VQcm9wc0xhYmVsKGluZm8pKSl9XG4gICAgICAgICAgICAgICAge2NyZWF0ZUVsZW1lbnQodGFnR3JvdXAgYXMgbmV2ZXIsIG1vZGlmeUdyb3VwUHJvcHMobWFrZVByb3BzR3JvdXAoaW5mbykpKX1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufVxuXG5jb25zdCBSYWRpb0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVJhZGlvPGFueSwgYW55LCBhbnk+PihudWxsISk7XG5leHBvcnQgZnVuY3Rpb24gUmFkaW9Hcm91cDxWIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBHcm91cEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgR3JvdXBMYWJlbEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCwgSW5wdXRFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIExhYmVsRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih7XG4gICAgcmVuZGVyLFxuICAgIHRhZ0dyb3VwLFxuICAgIHRhZ0dyb3VwTGFiZWwsXG4gICAgbmFtZSxcbiAgICBvblNlbGVjdGVkVmFsdWVDaGFuZ2UsXG4gICAgc2VsZWN0ZWRWYWx1ZSxcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uLFxuICAgIG5vVHlwZWFoZWFkLFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgaW5kZXhEZW1hbmdsZXIsXG4gICAgaW5kZXhNYW5nbGVyLFxuICAgIG9uQWxsTG9zdEZvY3VzLFxuICAgIG9uQW55R2FpbmVkRm9jdXMsXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb25UYWJiYWJsZVJlbmRlcixcbn06IFJhZGlvR3JvdXBQcm9wczxWLCBHcm91cEVsZW1lbnQsIEdyb3VwTGFiZWxFbGVtZW50LCBJbnB1dEVsZW1lbnQsIExhYmVsRWxlbWVudD4pIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHVzZVJhZGlvLFxuICAgICAgICB1c2VSYWRpb0dyb3VwTGFiZWxQcm9wcyxcbiAgICAgICAgdXNlUmFkaW9Hcm91cFByb3BzLFxuICAgICAgICAuLi5yYWRpb0dyb3VwUmV0dXJuXG4gICAgfSA9IHVzZVJhZGlvR3JvdXA8ViwgR3JvdXBFbGVtZW50LCBHcm91cExhYmVsRWxlbWVudCwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcbiAgICAgICAgcmFkaW9Hcm91cDogeyBuYW1lLCBvblNlbGVjdGVkVmFsdWVDaGFuZ2UsIHNlbGVjdGVkVmFsdWUsIHRhZ0dyb3VwLCB0YWdHcm91cExhYmVsIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBub1R5cGVhaGVhZCwgdHlwZWFoZWFkVGltZW91dCB9LFxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1czogeyBvbkFsbExvc3RGb2N1cywgb25BbnlHYWluZWRGb2N1cyB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0aW9uTW9kZTogXCJmb2N1c1wiIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxSYWRpb0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVJhZGlvfT5cbiAgICAgICAgICAgIHtyZW5kZXIocmFkaW9Hcm91cFJldHVybiwgdXNlUmFkaW9Hcm91cExhYmVsUHJvcHMsIHVzZVJhZGlvR3JvdXBQcm9wcyl9XG4gICAgICAgIDwvUmFkaW9Db250ZXh0LlByb3ZpZGVyPlxuICAgIClcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0UmVuZGVyUmFkaW9QYXJhbWV0ZXJzPEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50PiBleHRlbmRzIERlZmF1bHRSZW5kZXJDaGVja2JveExpa2VQYXJhbWV0ZXJzPEksIEwsIFVzZVJhZGlvUmV0dXJuVHlwZUluZm88ST4+IHtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclJhZGlvPEkgZXh0ZW5kcyBIVE1MRWxlbWVudCwgTCBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZUlucHV0UHJvcHMsIG1ha2VMYWJlbFByb3BzLCBsYWJlbFBvc2l0aW9uIH06IERlZmF1bHRSZW5kZXJSYWRpb1BhcmFtZXRlcnM8SSwgTD4pIHtcbiAgICByZXR1cm4gZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZTxJLCBMLCBVc2VSYWRpb1JldHVyblR5cGVJbmZvPEk+Pih7IGxhYmVsUG9zaXRpb24sIHRhZ0lucHV0LCB0YWdMYWJlbCwgbWFrZUlucHV0UHJvcHMsIG1ha2VMYWJlbFByb3BzIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gUmFkaW88ViBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgSW5wdXRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBkaXNhYmxlZCwgaW5kZXgsIHRleHQsIGhpZGRlbiwgdGFnSW5wdXQsIGxhYmVsUG9zaXRpb24sIHRhZ0xhYmVsLCB2YWx1ZSwgcmVuZGVyLCBmbGFncywgYmx1clNlbGYsIGZvY3VzU2VsZiwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH06IFJhZGlvUHJvcHM8ViwgSW5wdXRFbGVtZW50LCBMYWJlbEVsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VSYWRpb0lucHV0LCB1c2VSYWRpb0xhYmVsLCAuLi5yYWRpb1JldHVybiB9ID0gdXNlQ29udGV4dChSYWRpb0NvbnRleHQpKHtcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXG4gICAgICAgIHJhZGlvOiB7IGRpc2FibGVkLCBsYWJlbFBvc2l0aW9uLCB0YWdJbnB1dCwgdGFnTGFiZWwsIHZhbHVlIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGhpZGRlbiwgZm9jdXNTZWxmLCBibHVyU2VsZiB9LFxuICAgICAgICBoYXNGb2N1czogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VSYWRpb0lucHV0UHJvcHMgfSA9IHVzZVJhZGlvSW5wdXQoeyB0YWc6IHRhZ0lucHV0IH0pO1xuICAgIGNvbnN0IHsgdXNlUmFkaW9MYWJlbFByb3BzIH0gPSB1c2VSYWRpb0xhYmVsKHsgdGFnOiB0YWdMYWJlbCB9KTtcblxuICAgIHJldHVybiByZW5kZXIocmFkaW9SZXR1cm4sIHVzZVJhZGlvSW5wdXRQcm9wcywgdXNlUmFkaW9MYWJlbFByb3BzKTtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBjcmVhdGVDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBoLCBSZWYsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwicHJvcHNcIjtcbmltcG9ydCB7IHVzZVNsaWRlciwgVXNlU2xpZGVyUGFyYW1ldGVycywgVXNlU2xpZGVyVGh1bWIsIFVzZVNsaWRlclRodW1iUGFyYW1ldGVycywgVXNlU2xpZGVyVGh1bWJSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2Utc2xpZGVyXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyUHJvcHMgZXh0ZW5kcyBHZXQ8VXNlU2xpZGVyUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRyZW5cIj4sIEdldDxVc2VTbGlkZXJQYXJhbWV0ZXJzLCBcInNsaWRlclwiPiB7XG4gICAgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclRodW1iUHJvcHM8VGh1bWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBHZXQ8VXNlU2xpZGVyVGh1bWJQYXJhbWV0ZXJzPFRodW1iRWxlbWVudD4sIFwibWFuYWdlZENoaWxkXCI+LCBHZXQ8VXNlU2xpZGVyVGh1bWJQYXJhbWV0ZXJzPFRodW1iRWxlbWVudD4sIFwic2xpZGVyVGh1bWJcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VTbGlkZXJUaHVtYlJldHVyblR5cGVJbmZvLCBtb2RpZnlUaHVtYlByb3BzOiBQcm9wTW9kaWZpZXI8VGh1bWJFbGVtZW50Pik6IFZOb2RlO1xufVxuXG5jb25zdCBTbGlkZXJUaHVtYkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVNsaWRlclRodW1iPGFueT4+KG51bGwhKTtcblxuZXhwb3J0IGZ1bmN0aW9uIFNsaWRlcih7IG1heCwgbWluLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgY2hpbGRyZW4gfTogU2xpZGVyUHJvcHMpIHtcbiAgICBjb25zdCB7IHVzZVNsaWRlclRodW1iLCAuLi5fc2xpZGVySW5mbyB9ID0gdXNlU2xpZGVyKHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXG4gICAgICAgIHNsaWRlcjogeyBtYXgsIG1pbiB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8U2xpZGVyVGh1bWJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VTbGlkZXJUaHVtYn0+e2NoaWxkcmVufTwvU2xpZGVyVGh1bWJDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIFNsaWRlclRodW1iVTxUaHVtYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxhYmVsLCB0YWcsIHZhbHVlLCBtYXgsIG1pbiwgb25WYWx1ZUNoYW5nZSwgaW5kZXgsIGZsYWdzLCByZW5kZXIsIHZhbHVlVGV4dCB9OiBTbGlkZXJUaHVtYlByb3BzPFRodW1iRWxlbWVudD4sIHJlZjogUmVmPFRodW1iRWxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZVNsaWRlclRodW1iUHJvcHMsIC4uLnNsaWRlckluZm8gfSA9IHVzZUNvbnRleHQoU2xpZGVyVGh1bWJDb250ZXh0KSh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgc2xpZGVyVGh1bWI6IHsgbGFiZWwsIHRhZywgdmFsdWUsIG1heCwgbWluLCBvblZhbHVlQ2hhbmdlLCB2YWx1ZVRleHQgfSB9KTtcblxuICAgIHJldHVybiByZW5kZXIoc2xpZGVySW5mbywgdXNlU2xpZGVyVGh1bWJQcm9wcylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJTbGlkZXJUaHVtYjxFIGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUaHVtYiwgbWFrZVByb3BzVGh1bWIgfTogeyB0YWdUaHVtYjogRWxlbWVudFRvVGFnPEU+LCBtYWtlUHJvcHNUaHVtYjogKGluZm86IFVzZVNsaWRlclRodW1iUmV0dXJuVHlwZUluZm8pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVNsaWRlclRodW1iUmV0dXJuVHlwZUluZm8sIG1vZGlmeVRodW1iUHJvcHM6IFByb3BNb2RpZmllcjxFPikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUaHVtYiBhcyBuZXZlciwgbW9kaWZ5VGh1bWJQcm9wcyhtYWtlUHJvcHNUaHVtYihpbmZvKSkpXG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgU2xpZGVyVGh1bWIgPSBmb3J3YXJkUmVmKFNsaWRlclRodW1iVSkgYXMgdHlwZW9mIFNsaWRlclRodW1iVTtcbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFJlZiwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWxlbWVudFRvVGFnLCBQcm9wTW9kaWZpZXIgfSBmcm9tIFwicHJvcHNcIjtcbmltcG9ydCB7IHVzZVRhYmxlLCBVc2VUYWJsZUJvZHksIFVzZVRhYmxlQm9keVBhcmFtZXRlcnMsIFVzZVRhYmxlQm9keVJldHVyblR5cGVJbmZvLCBVc2VUYWJsZUNlbGwsIFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnMsIFVzZVRhYmxlQ2VsbFJldHVyblR5cGVJbmZvLCBVc2VUYWJsZVBhcmFtZXRlcnMsIFVzZVRhYmxlUmV0dXJuVHlwZUluZm8sIFVzZVRhYmxlUm93LCBVc2VUYWJsZVJvd1BhcmFtZXRlcnMsIFVzZVRhYmxlUm93UmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi4vdXNlLXRhYmxlXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZVByb3BzPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlVGFibGVQYXJhbWV0ZXJzLCBcImxpbmVhck5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVRhYmxlUGFyYW1ldGVycywgXCJsaXN0TmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlVGFibGVQYXJhbWV0ZXJzLCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBHZXQ8VXNlVGFibGVQYXJhbWV0ZXJzLCBcInJvdmluZ1RhYkluZGV4XCI+LFxuICAgIEdldDxVc2VUYWJsZVBhcmFtZXRlcnMsIFwidHlwZWFoZWFkTmF2aWdhdGlvblwiPiB7XG4gICAgLy90YWdUYWJsZTogRWxlbWVudFRvVGFnPFRhYmxlRWxlbWVudD47XG4gICAgLy9wcm9wc1RhYmxlKCk6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlRWxlbWVudD47XG4gICAgcmVuZGVyKGluZm86IFVzZVRhYmxlUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlUYWJsZVByb3BzOiBQcm9wTW9kaWZpZXI8VGFibGVFbGVtZW50Pik6IFZOb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlQm9keVByb3BzPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VUYWJsZUJvZHlQYXJhbWV0ZXJzIHtcbiAgICByZW5kZXIoaW5mbzogVXNlVGFibGVCb2R5UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlUYWJsZUJvZHlQcm9wczogUHJvcE1vZGlmaWVyPFNlY3Rpb25FbGVtZW50Pik6IFZOb2RlO1xufVxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUhlYWRQcm9wcyB7XG4gICAgcmVuZGVyKCk6IFZOb2RlO1xufVxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUZvb3RQcm9wcyB7XG4gICAgcmVuZGVyKCk6IFZOb2RlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlUm93UHJvcHM8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDI8VXNlVGFibGVSb3dQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJhc0NoaWxkUm93T2ZTZWN0aW9uXCIsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0MjxVc2VUYWJsZVJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzQ2hpbGRSb3dPZlNlY3Rpb25cIiwgXCJtYW5hZ2VkQ2hpbGRcIj4sXG4gICAgR2V0MjxVc2VUYWJsZVJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzQ2hpbGRSb3dPZlNlY3Rpb25cIiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwibGluZWFyTmF2aWdhdGlvblwiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0MjxVc2VUYWJsZVJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcIm1hbmFnZWRDaGlsZHJlblwiPixcbiAgICBHZXQyPFVzZVRhYmxlUm93UGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwiYXNQYXJlbnRSb3dPZkNlbGxzXCIsIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0MjxVc2VUYWJsZVJvd1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImFzUGFyZW50Um93T2ZDZWxsc1wiLCBcInR5cGVhaGVhZE5hdmlnYXRpb25cIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VUYWJsZVJvd1JldHVyblR5cGVJbmZvPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50PiwgdGFibGVSb3dQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4pOiBWTm9kZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUNlbGxQcm9wczxDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHNcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwibGlzdE5hdmlnYXRpb25cIj4sXG4gICAgR2V0PFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZFwiPixcbiAgICBHZXQ8VXNlVGFibGVDZWxsUGFyYW1ldGVyczxDZWxsRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4sXG4gICAgR2V0PFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VUYWJsZUNlbGxQYXJhbWV0ZXJzPENlbGxFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LFxuICAgIE9taXQ8R2V0PFVzZVRhYmxlQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQ+LCBcInN1YkluZm9cIj4sIFwibG9jYXRpb25cIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VUYWJsZUNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsRWxlbWVudD4sIHRhYmxlUm93UHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGxFbGVtZW50Pik6IFZOb2RlO1xufVxuXG5jb25zdCBMb2NhdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFwiaGVhZFwiIHwgXCJib2R5XCIgfCBcImZvb3RcIj4obnVsbCEpO1xuXG5jb25zdCBUYWJsZUJvZHlDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWJsZUJvZHk8YW55LCBhbnksIGFueT4+KG51bGwhKTtcbmNvbnN0IFRhYmxlUm93Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlVGFibGVSb3c8YW55LCBhbnk+PihudWxsISk7XG5jb25zdCBUYWJsZUNlbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWJsZUNlbGw8YW55Pj4obnVsbCEpO1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnVGFibGUsIG1ha2VQcm9wc1RhYmxlIH06IHsgdGFnVGFibGU6IEVsZW1lbnRUb1RhZzxUYWJsZUVsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZTogKGluZm86IFVzZVRhYmxlUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVRhYmxlUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc1RhYmxlOiBQcm9wTW9kaWZpZXI8VGFibGVFbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJsZSBhcyBuZXZlciwgbW9kaWZ5UHJvcHNUYWJsZShtYWtlUHJvcHNUYWJsZShpbmZvKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZUJvZHk8VGFibGVCb2R5RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnVGFibGVCb2R5LCBtYWtlUHJvcHNUYWJsZUJvZHkgfTogeyB0YWdUYWJsZUJvZHk6IEVsZW1lbnRUb1RhZzxUYWJsZUJvZHlFbGVtZW50PiwgbWFrZVByb3BzVGFibGVCb2R5OiAoaW5mbzogVXNlVGFibGVCb2R5UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUYWJsZUJvZHlFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbmZvOiBVc2VUYWJsZUJvZHlSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4sIG1vZGlmeVByb3BzVGFibGVCb2R5OiBQcm9wTW9kaWZpZXI8VGFibGVCb2R5RWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFibGVCb2R5IGFzIG5ldmVyLCBtb2RpZnlQcm9wc1RhYmxlQm9keShtYWtlUHJvcHNUYWJsZUJvZHkoaW5mbykpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGVIZWFkPFRhYmxlSGVhZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RhYmxlSGVhZCwgbWFrZVByb3BzVGFibGVIZWFkIH06IHsgdGFnVGFibGVIZWFkOiBFbGVtZW50VG9UYWc8VGFibGVIZWFkRWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlSGVhZDogKCkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFibGVIZWFkRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYmxlSGVhZCBhcyBuZXZlciwgKG1ha2VQcm9wc1RhYmxlSGVhZCgpKSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYmxlRm9vdDxUYWJsZUZvb3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUYWJsZUZvb3QsIG1ha2VQcm9wc1RhYmxlRm9vdCB9OiB7IHRhZ1RhYmxlRm9vdDogRWxlbWVudFRvVGFnPFRhYmxlRm9vdEVsZW1lbnQ+LCBtYWtlUHJvcHNUYWJsZUZvb3Q6ICgpID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRhYmxlRm9vdEVsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJsZUZvb3QgYXMgbmV2ZXIsIChtYWtlUHJvcHNUYWJsZUZvb3QoKSkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJUYWJsZVJvdzxSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHRhZ1RhYmxlUm93LCBtYWtlUHJvcHNUYWJsZVJvdyB9OiB7IHRhZ1RhYmxlUm93OiBFbGVtZW50VG9UYWc8Um93RWxlbWVudD4sIG1ha2VQcm9wc1RhYmxlUm93OiAoaW5mbzogVXNlVGFibGVSb3dSZXR1cm5UeXBlSW5mbzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvd0VsZW1lbnQ+IH0pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGluZm86IFVzZVRhYmxlUm93UmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc1RhYmxlUm93OiBQcm9wTW9kaWZpZXI8Um93RWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFibGVSb3cgYXMgbmV2ZXIsIG1vZGlmeVByb3BzVGFibGVSb3cobWFrZVByb3BzVGFibGVSb3coaW5mbykpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFibGVDZWxsPENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0YWdUYWJsZUNlbGwsIG1ha2VQcm9wc1RhYmxlQ2VsbCB9OiB7IHRhZ1RhYmxlQ2VsbDogRWxlbWVudFRvVGFnPENlbGxFbGVtZW50PiwgbWFrZVByb3BzVGFibGVDZWxsOiAoaW5mbzogVXNlVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW5mbzogVXNlVGFibGVDZWxsUmV0dXJuVHlwZUluZm88Q2VsbEVsZW1lbnQ+LCBtb2RpZnlQcm9wc1RhYmxlQ2VsbDogUHJvcE1vZGlmaWVyPENlbGxFbGVtZW50Pikge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0YWdUYWJsZUNlbGwgYXMgbmV2ZXIsIG1vZGlmeVByb3BzVGFibGVDZWxsKG1ha2VQcm9wc1RhYmxlQ2VsbChpbmZvKSkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gVGFibGVVPFRhYmxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBjb2xsYXRvcixcbiAgICBkaXNhYmxlQXJyb3dLZXlzLFxuICAgIGRpc2FibGVIb21lRW5kS2V5cyxcbiAgICBpbml0aWFsSW5kZXgsXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb25UYWJiYWJsZVJlbmRlcixcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIHJlbmRlclxufTogVGFibGVQcm9wczxUYWJsZUVsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxlbWVudD4sIHJlZjogUmVmPFRhYmxlRWxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZVRhYmxlQm9keSwgdXNlVGFibGVQcm9wcywgdXNlVGFibGVSb3csIC4uLnRhYmxlSW5mbyB9ID0gdXNlVGFibGU8VGFibGVFbGVtZW50LCBTZWN0aW9uRWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbGVtZW50Pih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgZGlzYWJsZUFycm93S2V5cywgZGlzYWJsZUhvbWVFbmRLZXlzIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7fSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH1cbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxUYWJsZUJvZHlDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJsZUJvZHl9PlxuICAgICAgICAgICAgPFRhYmxlUm93Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlVGFibGVSb3d9PlxuICAgICAgICAgICAgICAgIHsocmVuZGVyID8/IGRlZmF1bHRSZW5kZXJUYWJsZSkodGFibGVJbmZvLCB1c2VUYWJsZVByb3BzKX1cbiAgICAgICAgICAgIDwvVGFibGVSb3dDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICA8L1RhYmxlQm9keUNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBUYWJsZUJvZHlVPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICByZW5kZXJcbn06IFRhYmxlQm9keVByb3BzPFNlY3Rpb25FbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsZW1lbnQ+LCByZWY6IFJlZjxTZWN0aW9uRWxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZVRhYmxlQm9keVByb3BzLCAuLi5zZWN0aW9uSW5mbyB9ID0gdXNlQ29udGV4dChUYWJsZUJvZHlDb250ZXh0KSh7fSk7XG4gICAgcmV0dXJuIDxMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9XCJib2R5XCI+e3JlbmRlcihzZWN0aW9uSW5mbywgdXNlVGFibGVCb2R5UHJvcHMpfTwvTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyPlxufVxuXG5mdW5jdGlvbiBUYWJsZUhlYWRVPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIgfTogVGFibGVIZWFkUHJvcHMsIHJlZjogUmVmPFNlY3Rpb25FbGVtZW50Pikge1xuICAgIHJldHVybiA8TG9jYXRpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPVwiaGVhZFwiPnsocmVuZGVyKCkpfTwvTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyPlxufVxuXG5mdW5jdGlvbiBUYWJsZUZvb3RVPFNlY3Rpb25FbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyByZW5kZXIgfTogVGFibGVGb290UHJvcHMsIHJlZjogUmVmPFNlY3Rpb25FbGVtZW50Pikge1xuICAgIHJldHVybiA8TG9jYXRpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPVwiZm9vdFwiPnsocmVuZGVyKCkpfTwvTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyPlxufVxuXG5mdW5jdGlvbiBUYWJsZVJvd1U8Um93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENlbGxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBpbmRleCxcbiAgICB0ZXh0LFxuICAgIGJsdXJTZWxmLFxuICAgIGNvbGxhdG9yLFxuICAgIGRpc2FibGVBcnJvd0tleXMsXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzLFxuICAgIGZsYWdzLFxuICAgIGZvY3VzU2VsZixcbiAgICBoaWRkZW4sXG4gICAgaW5kZXhEZW1hbmdsZXIsXG4gICAgaW5kZXhNYW5nbGVyLFxuICAgIGluaXRpYWxJbmRleCxcbiAgICBub1R5cGVhaGVhZCxcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlLFxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZSxcbiAgICBvblRhYmJhYmxlUmVuZGVyLFxuICAgIHR5cGVhaGVhZFRpbWVvdXQsXG4gICAgcmVuZGVyXG59OiBUYWJsZVJvd1Byb3BzPFJvd0VsZW1lbnQsIENlbGxlbWVudD4sIHJlZjogUmVmPFJvd0VsZW1lbnQ+KSB7XG4gICAgY29uc3QgeyB1c2VUYWJsZUNlbGwsIHVzZVRhYmxlUm93UHJvcHMsIC4uLnJvd0luZm8gfSA9IHVzZUNvbnRleHQoVGFibGVSb3dDb250ZXh0KSh7XG4gICAgICAgIGFzQ2hpbGRSb3dPZlNlY3Rpb246IHtcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGJsdXJTZWxmLCBmb2N1c1NlbGYsIGhpZGRlbiB9LFxuICAgICAgICAgICAgc3ViSW5mbzoge31cbiAgICAgICAgfSxcbiAgICAgICAgYXNQYXJlbnRSb3dPZkNlbGxzOiB7XG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IGRpc2FibGVBcnJvd0tleXMsIGRpc2FibGVIb21lRW5kS2V5cyB9LFxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVJbmRleENoYW5nZSwgb25UYWJiYWJsZVJlbmRlciB9LFxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjb2xsYXRvciwgbm9UeXBlYWhlYWQsIHR5cGVhaGVhZFRpbWVvdXQgfVxuICAgICAgICB9LFxuICAgICAgICB0YWJsZVJvdzogeyBsb2NhdGlvbjogdXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpIH1cbiAgICB9KTtcbiAgICByZXR1cm4gPFRhYmxlQ2VsbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVRhYmxlQ2VsbH0+eyhyZW5kZXIgPz8gZGVmYXVsdFJlbmRlclRhYmxlUm93KShyb3dJbmZvLCB1c2VUYWJsZVJvd1Byb3BzKHsgcmVmIH0pKX08L1RhYmxlQ2VsbENvbnRleHQuUHJvdmlkZXI+XG59XG5cbmZ1bmN0aW9uIFRhYmxlQ2VsbFU8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGluZGV4LCB0ZXh0LCBibHVyU2VsZiwgZmxhZ3MsIGZvY3VzU2VsZiwgaGlkZGVuLCB2YWx1ZSwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCByZW5kZXIgfTogVGFibGVDZWxsUHJvcHM8Q2VsbEVsZW1lbnQ+LCByZWY6IFJlZjxDZWxsRWxlbWVudD4pIHtcbiAgICBjb25zdCB7IHVzZVRhYmxlQ2VsbFByb3BzLCAuLi5jZWxsSW5mbyB9ID0gdXNlQ29udGV4dChUYWJsZUNlbGxDb250ZXh0KSh7XG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW4gfSxcbiAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkVsZW1lbnRDaGFuZ2UsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTW91bnQsIG9uVW5tb3VudCwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH0sXG4gICAgICAgIHN1YkluZm86IHtcbiAgICAgICAgICAgIGxvY2F0aW9uOiB1c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCksXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKHJlbmRlciA/PyBkZWZhdWx0UmVuZGVyVGFibGVDZWxsKShjZWxsSW5mbywgdXNlVGFibGVDZWxsUHJvcHMoeyByZWYgfSkpO1xufVxuXG5leHBvcnQgY29uc3QgVGFibGUgPSBmb3J3YXJkUmVmKFRhYmxlVSkgYXMgdHlwZW9mIFRhYmxlVTtcbmV4cG9ydCBjb25zdCBUYWJsZUJvZHkgPSBmb3J3YXJkUmVmKFRhYmxlQm9keVUpIGFzIHR5cGVvZiBUYWJsZUJvZHlVO1xuZXhwb3J0IGNvbnN0IFRhYmxlSGVhZCA9IGZvcndhcmRSZWYoVGFibGVIZWFkVSkgYXMgdHlwZW9mIFRhYmxlSGVhZFU7XG5leHBvcnQgY29uc3QgVGFibGVGb290ID0gZm9yd2FyZFJlZihUYWJsZUZvb3RVKSBhcyB0eXBlb2YgVGFibGVGb290VTtcbmV4cG9ydCBjb25zdCBUYWJsZVJvdyA9IGZvcndhcmRSZWYoVGFibGVSb3dVKSBhcyB0eXBlb2YgVGFibGVSb3dVO1xuZXhwb3J0IGNvbnN0IFRhYmxlQ2VsbCA9IGZvcndhcmRSZWYoVGFibGVDZWxsVSkgYXMgdHlwZW9mIFRhYmxlQ2VsbFU7XG5cbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGNyZWF0ZUVsZW1lbnQsIGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IEVsZW1lbnRUb1RhZywgUHJvcE1vZGlmaWVyIH0gZnJvbSBcInByb3BzXCI7XG5pbXBvcnQgeyBVc2VUYWIsIFVzZVRhYkxpc3RQYXJhbWV0ZXJzLCBVc2VUYWJMaXN0UmV0dXJuVHlwZUluZm8sIFVzZVRhYlBhbmVsLCBVc2VUYWJQYW5lbFBhcmFtZXRlcnMsIFVzZVRhYlBhbmVsUmV0dXJuVHlwZUluZm8sIFVzZVRhYlBhcmFtZXRlcnMsIFVzZVRhYlJldHVyblR5cGVJbmZvLCB1c2VUYWJzLCBVc2VUYWJzUGFyYW1ldGVycywgVXNlVGFic1JldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4uL3VzZS10YWJzXCI7XG5cbnR5cGUgR2V0PFQsIEsgZXh0ZW5kcyBrZXlvZiBUPiA9IFRbS107XG50eXBlIEdldDI8VCwgSyBleHRlbmRzIGtleW9mIFQsIEsyIGV4dGVuZHMga2V5b2YgVFtLXT4gPSBUW0tdW0syXTtcblxuZXhwb3J0IGludGVyZmFjZSBUYWJzUHJvcHM8TGFiZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTGlzdEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kc1xuICAgIEdldDxVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJsaXN0TmF2aWdhdGlvblwiPixcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwibWFuYWdlZENoaWxkcmVuXCI+LFxuICAgIEdldDxVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJyb3ZpbmdUYWJJbmRleFwiPixcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwic2luZ2xlU2VsZWN0aW9uXCI+LFxuICAgIEdldDxVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VUYWJMaXN0UGFyYW1ldGVyczxUYWJFbGVtZW50PiwgXCJjaGlsZHJlbkhhdmVGb2N1c1wiPixcbiAgICBHZXQ8VXNlVGFiTGlzdFBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwidGFic1wiPixcbiAgICBHZXQyPFVzZVRhYnNQYXJhbWV0ZXJzLCBcInRhYlBhbmVsc1wiLCBcIm1hbmFnZWRDaGlsZHJlblwiPiB7XG4gICAgcmVuZGVyKHRhYnNJbmZvOiBVc2VUYWJzUmV0dXJuVHlwZUluZm8gJiBVc2VUYWJMaXN0UmV0dXJuVHlwZUluZm88VGFiRWxlbWVudD4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxMYWJlbEVsZW1lbnQ+LCBtb2RpZnlUYWJMaXN0UHJvcHM6IFByb3BNb2RpZmllcjxMaXN0RWxlbWVudD4pOiBWTm9kZTxhbnk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhYlByb3BzPFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIEdldDxVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcImxpc3ROYXZpZ2F0aW9uXCI+LFxuICAgIEdldDxVc2VUYWJQYXJhbWV0ZXJzPFRhYkVsZW1lbnQ+LCBcIm1hbmFnZWRDaGlsZFwiPixcbiAgICBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VGFiRWxlbWVudD4sXG4gICAgR2V0PFVzZVRhYlBhcmFtZXRlcnM8VGFiRWxlbWVudD4sIFwicm92aW5nVGFiSW5kZXhcIj4ge1xuICAgIC8vIHRhZ0xpc3RJdGVtOiBFbGVtZW50VG9UYWc8TGlzdGJveEl0ZW1FbGVtZW50PjtcbiAgICAvLyBwcm9wc0xpc3RJdGVtOiAoYXJnczogTGlzdGJveFNpbmdsZVByb3BzRGVyaXZlZEZyb20pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3Rib3hJdGVtRWxlbWVudD47XG4gICAgcmVuZGVyKGluZm86IFVzZVRhYlJldHVyblR5cGVJbmZvPFRhYkVsZW1lbnQ+LCBtb2RpZnlMaXN0SXRlbTogUHJvcE1vZGlmaWVyPFRhYkVsZW1lbnQ+KTogVk5vZGU8YW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJQYW5lbFByb3BzPFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgR2V0PFVzZVRhYlBhbmVsUGFyYW1ldGVycywgXCJtYW5hZ2VkQ2hpbGRcIj4ge1xuICAgIHJlbmRlcihpbmZvOiBVc2VUYWJQYW5lbFJldHVyblR5cGVJbmZvLCBtb2RpZnlUYWJQYW5lbFByb3BzOiBQcm9wTW9kaWZpZXI8VGFiUGFuZWxFbGVtZW50Pik6IFZOb2RlO1xufVxuXG5jb25zdCBUYWJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWI8YW55Pj4obnVsbCEpO1xuY29uc3QgVGFiUGFuZWxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VUYWJQYW5lbDxhbnk+PihudWxsISk7XG5cbmV4cG9ydCBjb25zdCBUYWJzID0gbWVtbyhmdW5jdGlvbiBUYWJzPExhYmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExpc3RFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgVGFiRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFRhYlBhbmVsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBzZWxlY3RlZEluZGV4LFxuICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgY29sbGF0b3IsXG4gICAgZGlzYWJsZUFycm93S2V5cyxcbiAgICBkaXNhYmxlSG9tZUVuZEtleXMsXG4gICAgaW5kZXhEZW1hbmdsZXIsXG4gICAgaW5kZXhNYW5nbGVyLFxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24sXG4gICAgbm9UeXBlYWhlYWQsXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSxcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsXG4gICAgb25UYWJiYWJsZVJlbmRlcixcbiAgICB0eXBlYWhlYWRUaW1lb3V0LFxuICAgIG9uQWxsTG9zdEZvY3VzLFxuICAgIG9uQW55R2FpbmVkRm9jdXMsXG4gICAgb25TZWxlY3RlZEluZGV4Q2hhbmdlLFxuICAgIHJlbmRlclxufTogVGFic1Byb3BzPExhYmVsRWxlbWVudCwgTGlzdEVsZW1lbnQsIFRhYkVsZW1lbnQ+KSB7XG4gICAgY29uc3Qge1xuICAgICAgICB1c2VUYWJMaXN0LFxuICAgICAgICB1c2VUYWJMaXN0TGFiZWwsXG4gICAgICAgIHVzZVRhYlBhbmVsLFxuICAgICAgICAuLi50YWJzSW5mb1xuICAgIH0gPSB1c2VUYWJzPExpc3RFbGVtZW50LCBUYWJFbGVtZW50LCBUYWJQYW5lbEVsZW1lbnQsIExhYmVsRWxlbWVudD4oe1xuICAgICAgICB0YWJQYW5lbHM6IHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHsgdXNlVGFiLCB1c2VUYWJMaXN0UHJvcHMsIC4uLnRhYmxpc3RJbmZvIH0gPSB1c2VUYWJMaXN0KHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXM6IHsgb25BbGxMb3N0Rm9jdXMsIG9uQW55R2FpbmVkRm9jdXMgfSxcbiAgICAgICAgdGFiczogeyBvblNlbGVjdGVkSW5kZXhDaGFuZ2UgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBkaXNhYmxlQXJyb3dLZXlzLCBkaXNhYmxlSG9tZUVuZEtleXMsIG5hdmlnYXRpb25EaXJlY3Rpb24gfSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgb25UYWJiYWJsZUluZGV4Q2hhbmdlLCBvblRhYmJhYmxlUmVuZGVyIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4LCBzZWxlY3Rpb25Nb2RlIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIG5vVHlwZWFoZWFkLCB0eXBlYWhlYWRUaW1lb3V0IH1cbiAgICB9KTtcbiAgICBjb25zdCB7IHVzZVRhYkxpc3RMYWJlbFByb3BzIH0gPSB1c2VUYWJMaXN0TGFiZWwoe30pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFRhYkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVRhYn0+XG4gICAgICAgICAgICA8VGFiUGFuZWxDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VUYWJQYW5lbH0+XG4gICAgICAgICAgICAgICAge3JlbmRlcih7IC4uLnRhYnNJbmZvLCAuLi50YWJsaXN0SW5mbyB9LCB1c2VUYWJMaXN0TGFiZWxQcm9wcywgdXNlVGFiTGlzdFByb3BzKX1cbiAgICAgICAgICAgIDwvVGFiUGFuZWxDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICA8L1RhYkNvbnRleHQuUHJvdmlkZXI+XG4gICAgKVxufSlcblxuZXhwb3J0IGNvbnN0IFRhYiA9IG1lbW8oZnVuY3Rpb24gVGFiPFRhYkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGluZGV4LCB0ZXh0LCBibHVyU2VsZiwgZmxhZ3MsIGZvY3VzU2VsZiwgaGlkZGVuLCBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uRWxlbWVudENoYW5nZSwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25Nb3VudCwgb25Vbm1vdW50LCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIHJlbmRlciB9OiBUYWJQcm9wczxUYWJFbGVtZW50Pikge1xuICAgIGNvbnN0IHsgdXNlVGFiUHJvcHMsIC4uLnRhYkluZm8gfSA9IHVzZUNvbnRleHQoVGFiQ29udGV4dCkoe1xuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuIH0sXG4gICAgICAgIGhhc0ZvY3VzOiB7IGdldERvY3VtZW50LCBnZXRXaW5kb3csIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbk1vdW50LCBvblVubW91bnQsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVuZGVyKHRhYkluZm8sIHVzZVRhYlByb3BzKVxufSlcblxuZXhwb3J0IGNvbnN0IFRhYlBhbmVsID0gbWVtbyhmdW5jdGlvbiBUYWJQYW5lbDxUYWJQYW5lbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGluZGV4LCBmbGFncywgcmVuZGVyIH06IFRhYlBhbmVsUHJvcHM8VGFiUGFuZWxFbGVtZW50Pikge1xuICAgIGNvbnN0IHsgdXNlVGFiUGFuZWxQcm9wcywgLi4udGFiUGFuZWxJbmZvIH0gPSB1c2VDb250ZXh0KFRhYlBhbmVsQ29udGV4dCkoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0gfSk7XG5cbiAgICByZXR1cm4gcmVuZGVyKHRhYlBhbmVsSW5mbywgdXNlVGFiUGFuZWxQcm9wcylcbn0pXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFiczxMYWJlbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMaXN0RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgdGFnTGFiZWwsIHRhZ0xpc3QsIG1ha2VQcm9wc0xhYmVsLCBtYWtlUHJvcHNMaXN0LCBwYW5lbHMgfTogeyBwYW5lbHM6IFZOb2RlW10sIHRhZ0xhYmVsOiBFbGVtZW50VG9UYWc8TGFiZWxFbGVtZW50PiwgdGFnTGlzdDogRWxlbWVudFRvVGFnPExpc3RFbGVtZW50PiwgbWFrZVByb3BzTGFiZWw6IChpbmZvOiBVc2VUYWJzUmV0dXJuVHlwZUluZm8pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExhYmVsRWxlbWVudD4sIG1ha2VQcm9wc0xpc3Q6IChpbmZvOiBVc2VUYWJzUmV0dXJuVHlwZUluZm8pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPExpc3RFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YWJzSW5mbzogVXNlVGFic1JldHVyblR5cGVJbmZvICYgVXNlVGFiTGlzdFJldHVyblR5cGVJbmZvPGFueT4sIG1vZGlmeUxhYmVsUHJvcHM6IFByb3BNb2RpZmllcjxMYWJlbEVsZW1lbnQ+LCBtb2RpZnlMaXN0UHJvcHM6IFByb3BNb2RpZmllcjxMaXN0RWxlbWVudD4pIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KHRhZ0xhYmVsIGFzIG5ldmVyLCBtb2RpZnlMYWJlbFByb3BzKG1ha2VQcm9wc0xhYmVsKHRhYnNJbmZvKSkpXG4gICAgICAgIGNvbnN0IGxpc3QgPSBjcmVhdGVFbGVtZW50KHRhZ0xpc3QgYXMgbmV2ZXIsIG1vZGlmeUxpc3RQcm9wcyhtYWtlUHJvcHNMaXN0KHRhYnNJbmZvKSkpO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgICAgICAge2xpc3R9XG4gICAgICAgICAgICAgICAge3BhbmVsc31cbiAgICAgICAgICAgIDwvPlxuICAgICAgICApXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFJlbmRlclRhYjxUYWJFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNUYWIsIHRhZ1RhYiB9OiB7IHRhZ1RhYjogRWxlbWVudFRvVGFnPFRhYkVsZW1lbnQ+LCBtYWtlUHJvcHNUYWI6IChpbmZvOiBVc2VUYWJSZXR1cm5UeXBlSW5mbzxUYWJFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiRWxlbWVudD4gfSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFiSW5mbzogVXNlVGFiUmV0dXJuVHlwZUluZm88VGFiRWxlbWVudD4sIG1vZGlmeVRhYlByb3BzOiBQcm9wTW9kaWZpZXI8VGFiRWxlbWVudD4pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodGFnVGFiIGFzIG5ldmVyLCBtb2RpZnlUYWJQcm9wcyhtYWtlUHJvcHNUYWIodGFiSW5mbykpKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmVuZGVyVGFiUGFuZWw8VGFiUGFuZWxFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyBtYWtlUHJvcHNUYWJQYW5lbCwgdGFnVGFiUGFuZWwgfTogeyB0YWdUYWJQYW5lbDogRWxlbWVudFRvVGFnPFRhYlBhbmVsRWxlbWVudD4sIG1ha2VQcm9wc1RhYlBhbmVsOiAoaW5mbzogVXNlVGFiUGFuZWxSZXR1cm5UeXBlSW5mbykgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VGFiUGFuZWxFbGVtZW50PiB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YWJQYW5lbEluZm86IFVzZVRhYlBhbmVsUmV0dXJuVHlwZUluZm8sIG1vZGlmeVRhYlBhbmVsUHJvcHM6IFByb3BNb2RpZmllcjxUYWJQYW5lbEVsZW1lbnQ+KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHRhZ1RhYlBhbmVsIGFzIG5ldmVyLCBtb2RpZnlUYWJQYW5lbFByb3BzKG1ha2VQcm9wc1RhYlBhbmVsKHRhYlBhbmVsSW5mbykpKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlVG9vbHRpcCwgVXNlVG9vbHRpcFBhcmFtZXRlcnMsIFVzZVRvb2x0aXBSZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuLi91c2UtdG9vbHRpcFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRvb2x0aXBQcm9wczxUVCBleHRlbmRzIEVsZW1lbnQsIFRUVCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVG9vbHRpcFBhcmFtZXRlcnMge1xuICAgIGdldERvY3VtZW50OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyc1tcImdldERvY3VtZW50XCJdO1xuICAgIGdldFdpbmRvdz86IFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzW1wiZ2V0V2luZG93XCJdO1xuICAgIHJlbmRlcj86IChpbmZvOiBVc2VUb29sdGlwUmV0dXJuVHlwZUluZm8sIHRyaWdnZXJQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VFQ+LCB0b29sdGlwUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFRUVD4pID0+IFZOb2RlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyKGluZm86IFVzZVRvb2x0aXBSZXR1cm5UeXBlSW5mbywgdHJpZ2dlclByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+LCB0b29sdGlwUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT4pIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPGRpdiB7Li4udHJpZ2dlclByb3BzfSAvPlxuICAgICAgICAgICAgPGRpdiB7Li4udG9vbHRpcFByb3BzfSAvPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmZ1bmN0aW9uIFRvb2x0aXBVPFRUIGV4dGVuZHMgRWxlbWVudCwgVFRUIGV4dGVuZHMgRWxlbWVudD4oeyBmb2N1c0RlbGF5LCBtb3VzZW91dERlbGF5LCBtb3VzZW92ZXJEZWxheSwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgcmVuZGVyIH06IFRvb2x0aXBQcm9wczxUVCwgVFRUPikge1xuICAgIGNvbnN0IHsgdXNlVG9vbHRpcFBvcHVwLCB1c2VUb29sdGlwVHJpZ2dlciwgLi4uaW5mbyB9ID0gdXNlVG9vbHRpcDxUVCwgVFRUPih7IGZvY3VzRGVsYXksIG1vdXNlb3V0RGVsYXksIG1vdXNlb3ZlckRlbGF5IH0pO1xuICAgIGNvbnN0IHsgdXNlVG9vbHRpcFRyaWdnZXJQcm9wcyB9ID0gdXNlVG9vbHRpcFRyaWdnZXIoeyBoYXNGb2N1czogeyBnZXREb2N1bWVudCwgZ2V0V2luZG93IH0gfSk7XG4gICAgY29uc3QgeyB1c2VUb29sdGlwUG9wdXBQcm9wcyB9ID0gdXNlVG9vbHRpcFBvcHVwKHsgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyB9IH0pO1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICB7KHJlbmRlciA/PyBkZWZhdWx0UmVuZGVyKShpbmZvLCB1c2VUb29sdGlwVHJpZ2dlclByb3BzKHt9KSwgdXNlVG9vbHRpcFBvcHVwUHJvcHMoe30pIGFzIGFueSl9XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZXhwb3J0IGNvbnN0IFRvb2x0aXAgPSBmb3J3YXJkUmVmKFRvb2x0aXBVKSBhcyB1bmtub3duIGFzIHR5cGVvZiBUb29sdGlwVTtcbiIsIlxuaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGgsIFJlbmRlcmFibGVQcm9wcyB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IEFjY29yZGlvbiwgQWNjb3JkaW9uU2VjdGlvbiwgSGVhZGluZyB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xuXG5mdW5jdGlvbiBEZW1vQWNjb3JkaW9uKHsgY2hpbGRyZW4sIC4uLnByb3BzIH06IFJlbmRlcmFibGVQcm9wczx7fT4pIHtcbiAgICByZXR1cm4gPEFjY29yZGlvbiB7Li4ucHJvcHN9IHJlbmRlcj17KGluZm8pID0+IHsgcmV0dXJuIDxkaXYgaWQ9XCJhY2NvcmRpb24tZGVtb1wiPntjaGlsZHJlbn08L2Rpdj4gfX0gLz5cbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcbn1cblxuZnVuY3Rpb24gRGVtb0FjY29yZGlvblNlY3Rpb24oeyBpbmRleCwgYm9keSwgaGVhZGluZywgZGlzYWJsZWQsIG9wZW4gfTogeyBvcGVuPzogYm9vbGVhbiwgZGlzYWJsZWQ6IGJvb2xlYW4sIGluZGV4OiBudW1iZXIsIGhlYWRpbmc6IENvbXBvbmVudENoaWxkcmVuLCBib2R5OiBDb21wb25lbnRDaGlsZHJlbiB9KSB7XG4gICAgcmV0dXJuIDxBY2NvcmRpb25TZWN0aW9uPEhUTUxEaXZFbGVtZW50LCBIVE1MRGl2RWxlbWVudD4gaW5kZXg9e2luZGV4fSB0YWdCdXR0b249XCJkaXZcIiBvcGVuPXtvcGVufSBkaXNhYmxlZD17ZGlzYWJsZWR9IGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gcmVuZGVyPXsoaW5mbywgaGVhZGVyUHJvcHMsIGJvZHlQcm9wcykgPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPXs8ZGl2IHsuLi5oZWFkZXJQcm9wc30+e2hlYWRpbmd9ICh7IWluZm8uYWNjb3JkaW9uU2VjdGlvbi5leHBhbmRlZCAmJiBcIm5vdCBcIn0gb3BlbiksICh7IWluZm8uYWNjb3JkaW9uU2VjdGlvbi5mb2N1c2VkICYmIFwibm90IFwifSBmb2N1c2VkKTwvZGl2Pn0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgey4uLmJvZHlQcm9wc30+e2JvZHl9PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9IZWFkaW5nPlxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9fT48L0FjY29yZGlvblNlY3Rpb24+XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBCbHVyYigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPHA+PGEgaHJlZj1cImh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvYWNjb3JkaW9uL1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBBY2NvcmRpb24gcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+RWFjaCBzZWN0aW9uJ3MgaGVhZGVyIGFuZCBib2R5IGFyZSBsaW5rZWQgdmlhIElEOyB0aGUgYm9keSBpcyA8Y29kZT5sYWJlbGxlZC1ieTwvY29kZT4gdGhlIGhlYWRlciBhbmQgdGhlIGhlYWRlciA8Y29kZT5jb250cm9sPC9jb2RlPnMgdGhlIGJvZHkuPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGhlYWRlciBpcyBhIGJ1dHRvbiBhbmQgcmVzcG9uZHMgdG8ga2V5Ym9hcmQsIG1vdXNlLCB0b3VjaCwgZXRjLiBldmVudHMsIHJlZ2FyZGxlc3Mgb2YgdGhlIGVsZW1lbnQgdXNlZC48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5JZiB0aGUgaGVhZGVyIGVsZW1lbnQgaXMgbm90IGEgPGNvZGU+Jmx0O2J1dHRvbiZndDs8L2NvZGU+IGVsZW1lbnQsIGl0IGlzIGdpdmVuIHRoYXQgPGNvZGU+cm9sZTwvY29kZT4uPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+VXAvZG93biAmYW1wOyBIb21lL0VuZCBrZXlzIG5hdmlnYXRlIHRocm91Z2ggdGhlIGxpc3QsIGFzIGRvZXMgVGFiIGFuZCBTaGlmdCtUYWI8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIDxjb2RlPnJlbmRlcjwvY29kZT4gcHJvcCBlYWNoIDxjb2RlPkFjY29yZGlvblNlY3Rpb248L2NvZGU+IHRha2VzIG11c3Qgd3JhcCB0aGUgaGVhZGVyIGJ1dHRvbiB3aXRoIGEgPGEgaHJlZj1cImh0dHBzOi8vdzNjLmdpdGh1Yi5pby9hcmlhLyNoZWFkaW5nXCI+aGVhZGluZzwvYT4gKGUuZy4gPGNvZGU+aDM8L2NvZGU+LCBvciA8Y29kZT4mbHQ7SGVhZGluZyZndDs8L2NvZGU+KS4gU2VlIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBhbiBleGFtcGxlLjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xuICAgIHJldHVybiAoPGNvZGU+e2A8QWNjb3JkaW9uIHJlbmRlcj17Li4ufT5cbiAgICA8QWNjb3JkaW9uU2VjdGlvbiBpbmRleD17MH0gcmVuZGVyPXsuLi59IC8+XG4gICAgPEFjY29yZGlvblNlY3Rpb24gaW5kZXg9ezF9IHJlbmRlcj17Li4ufSAvPlxuICAgIDxBY2NvcmRpb25TZWN0aW9uIGluZGV4PXsyfSByZW5kZXI9ey4uLn0gLz5cbjwvQWNjb3JkaW9uPmB9PC9jb2RlPilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPERlbW9BY2NvcmRpb24+XG4gICAgICAgICAgICAgICAgPERlbW9BY2NvcmRpb25TZWN0aW9uIGluZGV4PXswfSBoZWFkaW5nPVwiQWNjb3JkaW9uIHNlY3Rpb24gIzBcIiBib2R5PVwiQm9keSBjb250ZW50ICMwXCIgZGlzYWJsZWQ9e2ZhbHNlfSAvPlxuICAgICAgICAgICAgICAgIDxEZW1vQWNjb3JkaW9uU2VjdGlvbiBpbmRleD17MX0gaGVhZGluZz1cIkFjY29yZGlvbiBzZWN0aW9uICMxXCIgYm9keT1cIkJvZHkgY29udGVudCAjMVwiIGRpc2FibGVkPXtmYWxzZX0gLz5cbiAgICAgICAgICAgICAgICA8RGVtb0FjY29yZGlvblNlY3Rpb24gaW5kZXg9ezJ9IGhlYWRpbmc9XCJBY2NvcmRpb24gc2VjdGlvbiAjMiAoZGlzYWJsZWQpXCIgYm9keT1cIkJvZHkgY29udGVudCAjMlwiIGRpc2FibGVkPXt0cnVlfSAvPlxuICAgICAgICAgICAgICAgIDxEZW1vQWNjb3JkaW9uU2VjdGlvbiBpbmRleD17M30gaGVhZGluZz1cIkFjY29yZGlvbiBzZWN0aW9uICMzIChmb3JjZWQgb3BlbilcIiBib2R5PVwiQm9keSBjb250ZW50ICMzXCIgZGlzYWJsZWQ9e2ZhbHNlfSBvcGVuPXt0cnVlfSAvPlxuICAgICAgICAgICAgICAgIDxEZW1vQWNjb3JkaW9uU2VjdGlvbiBpbmRleD17NH0gaGVhZGluZz1cIkFjY29yZGlvbiBzZWN0aW9uICM0IChmb3JjZWQgY2xvc2VkKVwiIGJvZHk9XCJCb2R5IGNvbnRlbnQgIzRcIiBkaXNhYmxlZD17ZmFsc2V9IG9wZW49e2ZhbHNlfSAvPlxuICAgICAgICAgICAgPC9EZW1vQWNjb3JkaW9uPlxuICAgICAgICA8Lz5cbiAgICApXG59IiwiXG5pbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgaCwgUmVuZGVyYWJsZVByb3BzIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgQnV0dG9uLCBFdmVudERldGFpbCwgZGVmYXVsdFJlbmRlckJ1dHRvbiB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2J1dHRvbi9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgQnV0dG9uIHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPldoZXRoZXIgdXNpbmcgYW4gYWN0dWFsIDxjb2RlPiZsdDtidXR0b24mZ3Q7PC9jb2RlPiwgb3Igc29tZXRoaW5nIGVsc2UgbGlrZSBhIDxjb2RlPiZsdDtkaXYmZ3Q7PC9jb2RlPiwgdGhlIHByb3BlciByb2xlcyBhbmQgZXZlbnQgaGFuZGxlcnMgd2lsbCBiZSBhcHBsaWVkLjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPkJ1dHRvbnMgY2FuIGJlIHRvZ2dsZWQgKHByZXNzZWQgb3IgdW5wcmVzc2VkKS48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5UaGUgYnV0dG9uIHJlc3BvbmRzIHRvIGtleWJvYXJkLCBtb3VzZSwgdG91Y2gsIGV0Yy4gZXZlbnRzLCByZWdhcmRsZXNzIG9mIHRoZSBlbGVtZW50IHVzZWQuXG4gICAgICAgICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5Eb3VibGUtY2xpY2tzIGRvIG5vdCBzZWxlY3QgdGV4dCwgYnV0IHRleHQgaXMgc3RpbGwgc2VsZWN0YWJsZSB3aXRob3V0IGl0IGNvdW50aW5nIGFzIGEgcHJlc3MvY2xpY2s8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPldoZW4gRW50ZXIgaXMgcHJlc3NlZCwgdGhlIGJ1dHRvbiBpcyBpbW1lZGlhdGVseSBhY3RpdmF0ZWQ8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPldoZW4gU3BhY2UgaXMgcHJlc3NlZCwgdGhlIGJ1dHRvbiBpcyBhY3RpdmF0ZWQgb25jZSByZWxlYXNlZDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+aU9TIFNhZmFyaSBwcm9wZXJseSBmb2N1c2VzIHRoZSBidXR0b248L2xpPlxuICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5JZiB5b3VyIGJ1dHRvbiBjb250YWlucyBvbmx5IGFuIGljb24gKG9yIG90aGVyIG5vbi1kZXNjcmlwdGl2ZSBjb250ZW50LCBldGMuKSwgeW91IG11c3QgcHJvdmlkZSBhbiA8Y29kZT5hcmlhLWxhYmVsPC9jb2RlPiBtYW51YWxseSBzdGF0aW5nIHdoYXQgaGFwcGVucyB3aGVuIHRoZSBidXR0b24gaXMgcHJlc3NlZC48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgPEJ1dHRvbiB0YWc9XCJidXR0b25cIj5CdXR0b248L0J1dHRvbj5cbiAgICA8QnV0dG9uIHRhZz1cImRpdlwiPkRpdjwvQnV0dG9uPmB9PC9jb2RlPilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XG5cbiAgICBjb25zdCBvblByZXNzID0gKCkgPT4geyBhbGVydChcIkJ1dHRvbiBjbGlja2VkXCIpIH1cbiAgICBjb25zdCBbcHJlc3NlZCwgc2V0UHJlc3NlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG47XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxCbHVyYiAvPlxuICAgICAgICAgICAgPENvZGUgLz5cbiAgICAgICAgICAgIDxEZW1vQnV0dG9uIGRpc2FibGVkPXtmYWxzZX0gdGFnPVwiYnV0dG9uXCIgLz5cbiAgICAgICAgICAgIDxEZW1vQnV0dG9uIGRpc2FibGVkPVwic29mdFwiIHRhZz1cImJ1dHRvblwiIC8+XG4gICAgICAgICAgICA8RGVtb0J1dHRvbiBkaXNhYmxlZD1cImhhcmRcIiB0YWc9XCJidXR0b25cIiAvPlxuICAgICAgICAgICAgPERlbW9CdXR0b24gZGlzYWJsZWQ9e2ZhbHNlfSB0YWc9XCJkaXZcIiAvPlxuICAgICAgICAgICAgPERlbW9CdXR0b24gZGlzYWJsZWQ9XCJzb2Z0XCIgdGFnPVwiZGl2XCIgLz5cbiAgICAgICAgICAgIDxEZW1vQnV0dG9uIGRpc2FibGVkPVwiaGFyZFwiIHRhZz1cImRpdlwiIC8+XG4gICAgICAgICAgICA8QnV0dG9uIGRpc2FibGVkPXtmYWxzZX0gdGFnPVwiYnV0dG9uXCIgcHJlc3NlZD17cHJlc3NlZH0gb25QcmVzcz17ZSA9PiBzZXRQcmVzc2VkKGVbRXZlbnREZXRhaWxdLnByZXNzZWQgPz8gZmFsc2UpfSByZW5kZXI9e2RlZmF1bHRSZW5kZXJCdXR0b24oXCJidXR0b25cIiwgKCkgPT4gKHsgY2hpbGRyZW46IGBCdXR0b24gKCR7cHJlc3NlZD8gXCJwcmVzc2VkXCIgOiBcInVucHJlc3NlZFwifSlgfSkpfSAvPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmZ1bmN0aW9uIERlbW9CdXR0b24oeyB0YWcsIGRpc2FibGVkfTogeyB0YWc6IHN0cmluZywgZGlzYWJsZWQ6IGJvb2xlYW4gfCBcInNvZnRcIiB8IFwiaGFyZFwiIH0pIHtcbiAgICBjb25zdCBvblByZXNzID0gKCkgPT4geyBhbGVydChcIkJ1dHRvbiBjbGlja2VkXCIpIH1cblxuICAgIHJldHVybiAoIFxuICAgICAgICA8QnV0dG9uIHRhZz17dGFnIGFzIGFueX0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyQnV0dG9uKHRhZywgKHt9KSA9PiAoeyBjbGFzczogXCJidG5cIiwgY2hpbGRyZW46IGAke3RhZ30gJHtkaXNhYmxlZD8gYCBkaXNhYmxlZCAoJHtkaXNhYmxlZCA9PSBcInNvZnRcIj8gXCJzb2Z0XCIgOiBcImhhcmRcIn0pYCA6IFwiXCJ9YCB9KSl9ICAvPlxuICAgIClcbn0iLCJcbmltcG9ydCB7IENvbXBvbmVudENoaWxkcmVuLCBoLCBSZW5kZXJhYmxlUHJvcHMgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBCdXR0b24sIENoZWNrYm94LCBFdmVudERldGFpbCwgZGVmYXVsdFJlbmRlckJ1dHRvbiwgZGVmYXVsdFJlbmRlckNoZWNrYm94IH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cbi8qZnVuY3Rpb24gRGVtb0J1dHRvbih7IHRhZywgLi4ucHJvcHMgfTogeyB0YWc6IHN0cmluZyB9ICYgUmVuZGVyYWJsZVByb3BzPHt9Pikge1xuICAgIHJldHVybiA8QnV0dG9uIGRpc2FibGVkPXtkaXNhYmxlZH0gb25QcmVzcz17b25QcmVzc30gcHJlc3NlZD17fSB7Li4ucHJvcHN9IHRhZz17dGFnIGFzIGFueX0gICAvPlxufSovXG5cblxuXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2NoZWNrYm94L1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBDaGVja2JveCBwYXR0ZXJucyw8L2E+IHRoaXMgd2lkZ2V0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmc6PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5Ub2dnbGVzIGJldHdlZW4gY2hlY2tlZCBhbmQgdW5jaGVja2VkIHdoZW4gcHJlc3NlZCAoY2xpY2tlZCwgRW50ZXIgcHJlc3NlZCwgU3BhY2UgcmVsZWFzZWQsIGV0Yy4pPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+Q2FuIGJlIDxjb2RlPm1peGVkPC9jb2RlPiBpbnN0ZWFkLCB0aG91Z2ggPGNvZGU+b25JbnB1dDwvY29kZT4gd2lsbCBvbmx5IGV2ZXIgYmUgY2FsbGVkIHdpdGggPGNvZGU+dHJ1ZTwvY29kZT4gb3IgPGNvZGU+ZmFsc2U8L2NvZGU+PC9saT5cbiAgICAgICAgICAgICAgICA8bGk+U3VwcG9ydHMgdXNpbmcgPGNvZGU+Jmx0O2lucHV0Jmd0OzwvY29kZT5zIGFuZCA8Y29kZT4mbHQ7bGFiZWwmZ3Q7PC9jb2RlPnMsIGFzIHdlbGwgYXMganVzdCBwbGFpbiBvbCcgPGNvZGU+Jmx0O2RpdiZndDs8L2NvZGU+cyBvbiBlaXRoZXIvYm90aDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBjaGVja2JveCBhbmQgbGFiZWwgY2FuIGJlIHNpYmxpbmcgZWxlbWVudHMsIGxpa2Ugbm9ybWFsLCBvciB0aGUgbGFiZWwgY2FuIHdyYXAgdGhlIGlucHV0IGZvciBhIGxhcmdlciBoaXQgYXJlYS4gSW4gYWxsIGNhc2VzLCB0aGUgYXBwcm9wcmlhdGUgcm9sZXMvZXZlbnQgaGFuZGxlcnMgd2lsbCBiZSBhcHBsaWVkIHRvIGVhY2ggZWxlbWVudC48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIHNlbGVjdGluZyB0aGUgdGV4dCBvZiBhIGNoZWNrYm94J3MgbGFiZWwsIHRoaXMgZG9lcyBub3QgY2hhbmdlIHRoZSBjaGVja2JveCdzIHN0YXRlPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+RG91YmxlLWNsaWNraW5nIHRoZSBsYWJlbCBjaGVja3MgJmFtcDsgdW4tY2hlY2tzIHRoZSBjaGVja2JveCBpbnN0ZWFkIG9mIHNlbGVjdGluZyB0aGUgbGFiZWwncyB0ZXh0PC9saT5cbiAgICAgICAgICAgICAgICA8bGk+Q2hlY2tib3ggZ3JvdXBzICh3aXRoIGEgdHJpLXN0YXRlIHBhcmVudCkgYXJlIGEgc2VwYXJhdGUgY29tcG9uZW50L2hvb2s8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+SWYgeW91ciBjaGVja2JveCBkb2VzIG5vdCBoYXZlIGEgdmlzaWJsZSBsYWJlbCAoYWNoaWV2YWJsZSBieSBieSBvdmVycmlkaW5nIHRoZSA8Y29kZT5yZW5kZXI8L2NvZGU+IHByb3AgYW5kIHNldHRpbmcgPGNvZGU+bGFiZWxQb3NpdGlvbjwvY29kZT4gdG8gYmUgXCJzZXBhcmF0ZVwiKSwgeW91IG11c3QgcGFzcyA8Y29kZT5hcmlhLWxhYmVsPC9jb2RlPiBhcyBhIHByb3AgdG8gdGhlIGNoZWNrYm94IG1hbnVhbGx5LiBOb3QgcHJvdmlkaW5nIG9uZSB3aWxsIHByaW50IGFuIGVycm9yIHRvIHRoZSBjb25zb2xlLCBidXQgaXQgaXQgbm90IHJlcXVpcmVkIGJ5IHRoZSB0eXBlIHN5c3RlbS48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgPENoZWNrYm94IGNoZWNrZWQ9e3RydWV9IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIHRhZ0lucHV0PVwiaW5wdXRcIiB0YWdMYWJlbD1cImxhYmVsXCI+TGFiZWwgdGV4dDwvQ2hlY2tib3g+YH08L2NvZGU+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcblxuICAgIGNvbnN0IFtjaGVja2VkLCBzZXRDaGVja2VkXSA9IHVzZVN0YXRlKGZhbHNlIGFzIGJvb2xlYW4gfCBcIm1peGVkXCIpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPEJ1dHRvbiB0YWc9XCJidXR0b25cIiBvblByZXNzPXsoKSA9PiB7IHNldENoZWNrZWQoXCJtaXhlZFwiIGFzIGFueSk7IH19IHJlbmRlcj17ZGVmYXVsdFJlbmRlckJ1dHRvbihcImJ1dHRvblwiLCAoKSA9PiAoeyBjaGlsZHJlbjogXCJDaGFuZ2UgdG8gbWl4ZWRcIiB9KSl9IC8+XG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IHNldENoZWNrZWQ9e3NldENoZWNrZWR9IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwibGFiZWxcIiAvPlxuICAgICAgICAgICAgPERlbW9DaGVja2JveCBjaGVja2VkPXtjaGVja2VkfSBzZXRDaGVja2VkPXtzZXRDaGVja2VkfSBsYWJlbFBvc2l0aW9uPVwid3JhcHBpbmdcIiBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiaW5wdXRcIiB0YWdMYWJlbD1cImxhYmVsXCIgLz5cbiAgICAgICAgICAgIDxEZW1vQ2hlY2tib3ggY2hlY2tlZD17Y2hlY2tlZH0gc2V0Q2hlY2tlZD17c2V0Q2hlY2tlZH0gbGFiZWxQb3NpdGlvbj1cInNlcGFyYXRlXCIgZGlzYWJsZWQ9e2ZhbHNlfSB0YWdJbnB1dD1cImRpdlwiIHRhZ0xhYmVsPVwibGFiZWxcIiAvPlxuICAgICAgICAgICAgPERlbW9DaGVja2JveCBjaGVja2VkPXtjaGVja2VkfSBzZXRDaGVja2VkPXtzZXRDaGVja2VkfSBsYWJlbFBvc2l0aW9uPVwid3JhcHBpbmdcIiBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiZGl2XCIgdGFnTGFiZWw9XCJsYWJlbFwiIC8+XG4gICAgICAgICAgICA8RGVtb0NoZWNrYm94IGNoZWNrZWQ9e2NoZWNrZWR9IHNldENoZWNrZWQ9e3NldENoZWNrZWR9IGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiIGRpc2FibGVkPXtmYWxzZX0gdGFnSW5wdXQ9XCJpbnB1dFwiIHRhZ0xhYmVsPVwiZGl2XCIgLz5cbiAgICAgICAgICAgIDxEZW1vQ2hlY2tib3ggY2hlY2tlZD17Y2hlY2tlZH0gc2V0Q2hlY2tlZD17c2V0Q2hlY2tlZH0gbGFiZWxQb3NpdGlvbj1cIndyYXBwaW5nXCIgZGlzYWJsZWQ9e2ZhbHNlfSB0YWdJbnB1dD1cImlucHV0XCIgdGFnTGFiZWw9XCJkaXZcIiAvPlxuICAgICAgICAgICAgPERlbW9DaGVja2JveCBjaGVja2VkPXtjaGVja2VkfSBzZXRDaGVja2VkPXtzZXRDaGVja2VkfSBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIiBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiZGl2XCIgdGFnTGFiZWw9XCJkaXZcIiAvPlxuICAgICAgICAgICAgPERlbW9DaGVja2JveCBjaGVja2VkPXtjaGVja2VkfSBzZXRDaGVja2VkPXtzZXRDaGVja2VkfSBsYWJlbFBvc2l0aW9uPVwid3JhcHBpbmdcIiBkaXNhYmxlZD17ZmFsc2V9IHRhZ0lucHV0PVwiZGl2XCIgdGFnTGFiZWw9XCJkaXZcIiAvPlxuICAgICAgICAgICAgPERlbW9DaGVja2JveCBjaGVja2VkPXtjaGVja2VkfSBzZXRDaGVja2VkPXtzZXRDaGVja2VkfSBsYWJlbFBvc2l0aW9uPVwiaGlkZGVuXCIgZGlzYWJsZWQ9e2ZhbHNlfSB0YWdJbnB1dD1cImlucHV0XCIgdGFnTGFiZWw9XCJsYWJlbFwiIC8+XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZnVuY3Rpb24gRGVtb0NoZWNrYm94KHsgbGFiZWxQb3NpdGlvbiwgdGFnSW5wdXQsIHRhZ0xhYmVsLCBkaXNhYmxlZCwgY2hlY2tlZCwgc2V0Q2hlY2tlZCB9OiB7IGRpc2FibGVkOiBib29sZWFuLCBsYWJlbFBvc2l0aW9uOiBcInNlcGFyYXRlXCIgfCBcIndyYXBwaW5nXCIgfCBcImhpZGRlblwiLCB0YWdJbnB1dDogc3RyaW5nLCB0YWdMYWJlbDogc3RyaW5nLCBjaGVja2VkOiBib29sZWFuIHwgXCJtaXhlZFwiLCBzZXRDaGVja2VkOiBTdGF0ZVVwZGF0ZXI8Ym9vbGVhbiB8IFwibWl4ZWRcIj4gfSkge1xuICAgIC8vY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3sgYm9yZGVyOiBcIjFweCBzb2xpZCBibGFja1wiIH19PlxuICAgICAgICAgICAgPENoZWNrYm94XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgICAgICAgIGNoZWNrZWQ9e2NoZWNrZWR9XG4gICAgICAgICAgICAgICAgb25DaGVja2VkQ2hhbmdlPXtlID0+IHNldENoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCl9XG4gICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbj17bGFiZWxQb3NpdGlvbiA9PSBcImhpZGRlblwiID8gXCJzZXBhcmF0ZVwiIDogbGFiZWxQb3NpdGlvbn1cbiAgICAgICAgICAgICAgICB0YWdJbnB1dD17dGFnSW5wdXQgYXMgbmV2ZXJ9XG4gICAgICAgICAgICAgICAgdGFnTGFiZWw9e3RhZ0xhYmVsIGFzIG5ldmVyfVxuICAgICAgICAgICAgICAgIHJlbmRlcj17ZGVmYXVsdFJlbmRlckNoZWNrYm94KHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGFnSW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIHRhZ0xhYmVsLFxuICAgICAgICAgICAgICAgICAgICBtYWtlSW5wdXRQcm9wczogKCkgPT4gKHsgXCJhcmlhLWxhYmVsXCI6IGxhYmVsUG9zaXRpb24gPT0gXCJoaWRkZW5cIiA/IGBIaWRkZW4gbGFiZWwgKHRlY2huaWNhbGx5IHNlcGFyYXRlKSwgJHt0YWdJbnB1dH0gYW5kICR7dGFnTGFiZWx9ICR7Y2hlY2tlZCA/IFwiY2hlY2tlZFwiIDogXCJub3QgY2hlY2tlZFwifWAgOiB1bmRlZmluZWQsIH0pLFxuICAgICAgICAgICAgICAgICAgICBtYWtlTGFiZWxQcm9wczogKCkgPT4gKHsgY2hpbGRyZW46IGAke2xhYmVsUG9zaXRpb259LCAke3RhZ0lucHV0fSBhbmQgJHt0YWdMYWJlbH0sICR7Y2hlY2tlZCA/IFwiY2hlY2tlZFwiIDogXCJub3QgY2hlY2tlZFwifWAgfSlcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7bGFiZWxQb3NpdGlvbiA9PSBcImhpZGRlblwiICYmIDxkaXY+KFRoaXMgaXMgbm90IGEgbGFiZWwgLS0gdGhlIGFjdHVhbCBsYWJlbCBpcyB2aWEgdGhlIDxjb2RlPmFyaWEtbGFiZWw8L2NvZGU+IHByb3ApPC9kaXY+fVxuICAgICAgICA8L2Rpdj5cbiAgICApXG59XG4iLCJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IENoZWNrYm94R3JvdXAsIENoZWNrYm94R3JvdXBDaGVja2JveCwgZGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXAsIGRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGQsIEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cbmZ1bmN0aW9uIERlbW9DaGVja2JveCh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XG4gICAgY29uc3QgW2NoZWNrZWQsIHNldENoZWNrZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGxhYmVsVGV4dCA9IGBDaGVja2JveCAjJHtpbmRleH1gXG4gICAgcmV0dXJuIChcbiAgICAgICAgPENoZWNrYm94R3JvdXBDaGVja2JveCByZW5kZXI9e2RlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwQ2hpbGQoe1xuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbjogXCJzZXBhcmF0ZVwiLFxuICAgICAgICAgICAgdGFnSW5wdXQ6IFwiaW5wdXRcIixcbiAgICAgICAgICAgIHRhZ0xhYmVsOiBcImxhYmVsXCIsXG4gICAgICAgICAgICBtYWtlSW5wdXRQcm9wczogKCkgPT4gKHt9KSxcbiAgICAgICAgICAgIG1ha2VMYWJlbFByb3BzOiAoKSA9PiAoeyBjaGlsZHJlbjogbGFiZWxUZXh0IH0pXG4gICAgICAgIH0pfVxuICAgICAgICAgICAgY2hlY2tlZD17Y2hlY2tlZH1cbiAgICAgICAgICAgIGluZGV4PXtpbmRleH1cbiAgICAgICAgICAgIGRpc2FibGVkPXtmYWxzZX1cbiAgICAgICAgICAgIGxhYmVsUG9zaXRpb249XCJzZXBhcmF0ZVwiXG4gICAgICAgICAgICB0ZXh0PXtsYWJlbFRleHR9XG4gICAgICAgICAgICB0YWdJbnB1dD1cImlucHV0XCJcbiAgICAgICAgICAgIHRhZ0xhYmVsPVwibGFiZWxcIlxuICAgICAgICAgICAgb25DaGVja2VkQ2hhbmdlPXtlID0+IHNldENoZWNrZWQoZVtFdmVudERldGFpbF0uY2hlY2tlZCl9IC8+XG4gICAgKVxufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8cD5DaGVja2JveCBncm91cHMgYXJlIGFuIGFsdGVybmF0aXZlIHRvIG11bHRpLXNlbGVjdCBsaXN0cy4gVGhlcmUgaXMgbm8gcm9sZSBvZiA8Y29kZT5jaGVja2JveGdyb3VwPC9jb2RlPiwgYnV0IHRoaXMgYWltcyB0byBiZSBhbiBBUklBLWNvbXBsaWFudCBpbXBsZW1lbnRhdGlvbiBvZiBhIGNoZWNrYm94IGdyb3VwLjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+QWxsIG5vcm1hbCA8Y29kZT5DaGVja2JveDwvY29kZT4gZnVuY3Rpb25hbGl0eSBpcyBzdXBwb3J0ZWQgb24gZWFjaCBpbmRpdmlkdWFsIGNoZWNrYm94LjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBwYXJlbnQgY2hlY2tib3ggc3dpdGNoZXMgYmV0d2VlbiAzIHN0YXRlcywgcmVtZW1iZXJpbmcgdGhlIGxhc3Qgc3RhdGUgdGhhdCBjYXVzZWQgaXQgdG8gYmUgXCJtaXhlZFwiLjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBwYXJlbnQgY2hlY2tib3ggcmVhY3RzIHRvIGVhY2ggY2hpbGQncyA8Y29kZT5jaGVja2VkPC9jb2RlPiBwcm9wIGFuZCB1cGRhdGVzIGl0cyBvd24gaW50ZXJuYWwgPGNvZGU+Y2hlY2tlZDwvY29kZT4gYXR0cmlidXRlIChiZSBhd2FyZSBvZiB0aGlzIGlmIHRoZXkncmUgYXN5bmNyb25vdXMsIGFzIHlvdSdsbCB3YW50IHRvIGVuc3VyZSB0aGV5IGFsbCByZXNvbHZlIG9uIHRoZSBzYW1lIHRpY2sgd2l0aCA8Y29kZT5Qcm9taXNlLmFsbDwvY29kZT4gdG8gbm90IGNsb2JiZXIgdGhlIHVzZXIncyBpbnB1dHMpLjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBjaGlsZHJlbiBhcmUgdHJlYXRlZCBhcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgd2l0aCBsaXN0IG5hdmlnYXRpb247IHNlZSA8Y29kZT5BaXJhU2luZ2xlU2VsZWN0TGlzdDwvY29kZT4gZm9yIG1vcmUgaW5mb3JtYXRpb248L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+SXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBwYXJlbnQgY2hlY2tib3ggcHJvdmlkZXMgc3VmZmljaWVudCBsYWJlbGxpbmcgZm9yIGFsbCB0aGUgY2hpbGRyZW4sIHdoaWNoIGhvdyB0aGUgZGVtbyBleGFtcGxlIGlkZW50aWZpZXMgdGhlc2UgZWxlbWVudHMuIElmIHlvdSBoYXZlIGEgc2VwYXJhdGUgbGFiZWwsIHlvdSB3aWxsIG5lZWQgdG8gd3JhcCB0aGUgY2hpbGRyZW4gaW4gYSA8Y29kZT5yb2xlPWdyb3VwPC9jb2RlPiB0aGF0IHJlZmVyZW5jZXMgdGhhdCBsYWJlbCBieSBvdmVycmlkaW5nIDxjb2RlPnJlbmRlcjwvY29kZT4uPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+U2VlIHRoZSBjYXZlYXQgYWJvdmUgZm9yIHdoZW4gZWFjaCBjaGlsZCdzIDxjb2RlPm9uSW5wdXQ8L2NvZGU+IHRha2VzIGEgdmFyaWFibGUgYW1vdW50IG9mIHRpbWUgdG8gYWN0dWFsbHkgdXBkYXRlIHRoZSA8Y29kZT5jaGVja2VkPC9jb2RlPiBwcm9wLCBhcyBpdCBjYW4gY2xvYmJlciB0aGUgdXNlcidzIGxhc3QgaW5wdXQgd2hlbiBjbGlja2luZyBvbiB0aGUgcGFyZW50PC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XG4gICAgcmV0dXJuICg8Y29kZT57YGB9PC9jb2RlPilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxCbHVyYiAvPlxuICAgICAgICAgICAgPENvZGUgLz5cbiAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cIm51bWJlclwiIG1pbj17MH0gdmFsdWU9e2NvdW50fSBvbklucHV0PXtlID0+IHNldENvdW50KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz4gIyBvZiBjaGVja2JveGVzPC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPENoZWNrYm94R3JvdXAgZGlzYWJsZWQ9e2ZhbHNlfSBsYWJlbFBvc2l0aW9uPVwic2VwYXJhdGVcIiB0YWdJbnB1dD1cImlucHV0XCIgdGFnTGFiZWw9XCJsYWJlbFwiIHJlbmRlcj17XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsUG9zaXRpb246IFwic2VwYXJhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0lucHV0OiBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdMYWJlbDogXCJsYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZUlucHV0UHJvcHM6ICgpID0+ICh7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlTGFiZWxQcm9wczogKCkgPT4gKHsgY2hpbGRyZW46IFwiR3JvdXAgY2hlY2tib3ggcGFyZW50XCIgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogQXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPGRpdj48RGVtb0NoZWNrYm94IGluZGV4PXtpfSBrZXk9e2l9IC8+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSlcbiAgICAgICAgICAgICAgICAgICAgfSl9IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgKVxufSIsIlxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgTGlzdGJveE11bHRpSXRlbSB9IGZyb20gXCIuLi8uLi9jb21wb25lbnQvbGlzdGJveC1tdWx0aVwiO1xuaW1wb3J0IHsgRXZlbnREZXRhaWwsIExpc3Rib3hNdWx0aSwgZGVmYXVsdFJlbmRlckxpc3Rib3hNdWx0aSwgZGVmYXVsdFJlbmRlckxpc3Rib3hNdWx0aUl0ZW0gfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcblxuXG5mdW5jdGlvbiBEZW1vTGlzdEl0ZW0oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xuICAgIGNvbnN0IFtzZWxlY3RlZCwgc2V0U2VsZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGxhYmVsVGV4dCA9IGBMaXN0IGl0ZW0gIyR7aW5kZXh9JHtzZWxlY3RlZCA/IFwiIChzZWxlY3RlZClcIiA6IFwiXCJ9YFxuXG5cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxMaXN0Ym94TXVsdGlJdGVtXG4gICAgICAgICAgICBzZWxlY3RlZD17c2VsZWN0ZWR9XG4gICAgICAgICAgICBpbmRleD17aW5kZXh9XG4gICAgICAgICAgICBkaXNhYmxlZD17ZmFsc2V9XG4gICAgICAgICAgICB0ZXh0PXtsYWJlbFRleHR9XG4gICAgICAgICAgICBvblNlbGVjdGVkQ2hhbmdlPXtlID0+IHsgc2V0U2VsZWN0ZWQoZVtFdmVudERldGFpbF0uc2VsZWN0ZWQpIH19XG4gICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJMaXN0Ym94TXVsdGlJdGVtKHsgdGFnTGlzdEl0ZW06IFwibGlcIiwgbWFrZVByb3BzTGlzdEl0ZW06ICgpID0+ICh7IGNoaWxkcmVuOiBsYWJlbFRleHQgfSkgfSl9XG4gICAgICAgIC8+XG4gICAgKVxufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy9saXN0Ym94L1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBMaXN0Ym94IHBhdHRlcm5zLDwvYT4gdGhpcyB3aWRnZXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzo8L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBjaGlsZHJlbiBhcmUgdHJlYXRlZCBhcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgd2l0aCBsaXN0IG5hdmlnYXRpb247IHNlZSA8Y29kZT5BaXJhU2luZ2xlU2VsZWN0TGlzdDwvY29kZT4gZm9yIG1vcmUgaW5mb3JtYXRpb248L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5UaGUgcGFyZW50IGNoZWNrYm94IHN3aXRjaGVzIGJldHdlZW4gMyBzdGF0ZXMsIHJlbWVtYmVyaW5nIHRoZSBsYXN0IHN0YXRlIHRoYXQgY2F1c2VkIGl0IHRvIGJlIFwibWl4ZWRcIi48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5UaGUgcGFyZW50IGNoZWNrYm94IHJlYWN0cyB0byBlYWNoIGNoaWxkJ3MgPGNvZGU+Y2hlY2tlZDwvY29kZT4gcHJvcCBhbmQgdXBkYXRlcyBpdHMgb3duIGludGVybmFsIDxjb2RlPmNoZWNrZWQ8L2NvZGU+IGF0dHJpYnV0ZSAoYmUgYXdhcmUgb2YgdGhpcyBpZiB0aGV5J3JlIGFzeW5jcm9ub3VzLCBhcyB5b3UnbGwgd2FudCB0byBlbnN1cmUgdGhleSBhbGwgcmVzb2x2ZSBvbiB0aGUgc2FtZSB0aWNrIHdpdGggPGNvZGU+UHJvbWlzZS5hbGw8L2NvZGU+IHRvIG5vdCBjbG9iYmVyIHRoZSB1c2VyJ3MgaW5wdXRzKS48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5UaGUgY2hpbGRyZW4gYXJlIHRyZWF0ZWQgYXMgYSBjb21wb3NpdGUgY29tcG9uZW50IHdpdGggbGlzdCBuYXZpZ2F0aW9uOyBzZWUgPGNvZGU+QWlyYVNpbmdsZVNlbGVjdExpc3Q8L2NvZGU+IGZvciBtb3JlIGluZm9ybWF0aW9uPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+R3JvdXBpbmcgaXMgc3VwcG9ydGVkPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+U29ydGluZy9yZW9yZGVyaW5nIGlzIHN1cHBvcnRlZCwgdGhvdWdoIG5vdCBwcm92aWRlZCBieSBkZWZhdWx0LCBhcyBpdCdzIG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIGdyb3VwaW5nLjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5JdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHBhcmVudCBjaGVja2JveCBwcm92aWRlcyBzdWZmaWNpZW50IGxhYmVsbGluZyBmb3IgYWxsIHRoZSBjaGlsZHJlbiwgd2hpY2ggaG93IHRoZSBkZW1vIGV4YW1wbGUgaWRlbnRpZmllcyB0aGVzZSBlbGVtZW50cy4gSWYgeW91IGhhdmUgYSBzZXBhcmF0ZSBsYWJlbCwgeW91IHdpbGwgbmVlZCB0byB3cmFwIHRoZSBjaGlsZHJlbiBpbiBhIDxjb2RlPnJvbGU9Z3JvdXA8L2NvZGU+IHRoYXQgcmVmZXJlbmNlcyB0aGF0IGxhYmVsIGJ5IG92ZXJyaWRpbmcgPGNvZGU+cmVuZGVyPC9jb2RlPi48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5TZWUgdGhlIGNhdmVhdCBhYm92ZSBmb3Igd2hlbiBlYWNoIGNoaWxkJ3MgPGNvZGU+b25JbnB1dDwvY29kZT4gdGFrZXMgYSB2YXJpYWJsZSBhbW91bnQgb2YgdGltZSB0byBhY3R1YWxseSB1cGRhdGUgdGhlIDxjb2RlPmNoZWNrZWQ8L2NvZGU+IHByb3AsIGFzIGl0IGNhbiBjbG9iYmVyIHRoZSB1c2VyJ3MgbGFzdCBpbnB1dCB3aGVuIGNsaWNraW5nIG9uIHRoZSBwYXJlbnQ8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDUpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIGxpc3QgaXRlbXM8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8TGlzdGJveE11bHRpIHRhZ0xhYmVsPVwibGFiZWxcIiB0YWdMaXN0PVwidWxcIiByZW5kZXI9e2RlZmF1bHRSZW5kZXJMaXN0Ym94TXVsdGkoe1xuICAgICAgICAgICAgICAgICAgICB0YWdMYWJlbDogXCJsYWJlbFwiLCB0YWdMaXN0OiBcInVsXCIsIG1ha2VQcm9wc0xhYmVsOiAoKSA9PiAoe30pLCBtYWtlUHJvcHNMaXN0OiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxkaXY+PERlbW9MaXN0SXRlbSBpbmRleD17aX0ga2V5PXtpfSAvPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSl9IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgKVxufSIsIlxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlckxpc3Rib3hTaW5nbGVJdGVtLCBMaXN0Ym94U2luZ2xlSXRlbSB9IGZyb20gXCIuLi8uLi9jb21wb25lbnQvbGlzdGJveC1zaW5nbGVcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsLCBMaXN0Ym94U2luZ2xlLCBkZWZhdWx0UmVuZGVyTGlzdGJveFNpbmdsZSB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xuXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHsgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDsgfVxuXG5mdW5jdGlvbiBEZW1vTGlzdEl0ZW0oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPExpc3Rib3hTaW5nbGVJdGVtPEhUTUxMSUVsZW1lbnQ+IGluZGV4PXtpbmRleH0gZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fSBkaXNhYmxlZD17ZmFsc2V9IHRleHQ9e2BMaXN0IGl0ZW0gIyR7aW5kZXh9YH0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyTGlzdGJveFNpbmdsZUl0ZW0oeyB0YWdMaXN0SXRlbTogXCJsaVwiLCBtYWtlUHJvcHNMaXN0SXRlbTogKHsgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkIH0gfSkgPT4gKHsgY2hpbGRyZW46IGBMaXN0IGl0ZW0gIyR7aW5kZXh9JHtzZWxlY3RlZCA/IFwiIChzZWxlY3RlZClcIiA6IFwiXCJ9YCB9KSB9KX0gLz5cbiAgICApXG59XG5cblxuXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2xpc3Rib3gvXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIExpc3Rib3ggcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+SW4gdGVybXMgb2Yga2V5Ym9hcmQgbmF2aWdhdGlvbiBhbmQgdGFiYmluZyB0aHJvdWdoIGVsZW1lbnRzLCBhIExpc3Rib3ggaXMgY29uc2lkZXJlZCBhIDxzdHJvbmc+c2luZ2xlPC9zdHJvbmc+IHRhYiBzdG9wOyBpbiBvdGhlciB3b3Jkcywgbm8gbWF0dGVyIGhvdyBtYW55IGxpc3QgaXRlbXMgdGhlcmUgYXJlIGluIGEgTGlzdGJveCwgaXQgb25seSB0YWtlcyBvbmUgcHJlc3Mgb2YgdGhlIFRhYiBidXR0b24gdG8gZ28gdGhyb3VnaCBpdC5cbiAgICAgICAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGxpPldoZW4gYSBMaXN0Ym94IGlzIHRhYmJlZCBpbnRvLCB0aGUgbW9zdCByZWNlbnRseSBzZWxlY3RlZCBpdGVtIGlzIGdpdmVuIGZvY3VzPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5QcmVzc2luZyBUYWIgYWdhaW4gbmF2aWdhdGVzIG91dCBvZiB0aGUgbGlzdGJveDsgbm8gb3RoZXIgbGlzdCBpdGVtcyBhcmUgdGFiYmFibGUgb3RoZXIgdGhhbiB0aGUgb25lIGN1cnJlbnRseSBkZXNpZ25hdGVkLjwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+UHJlc3NpbmcgdGhlIGFycm93IGtleXMgbmF2aWdhdGVzIHRocm91Z2ggdGhlIExpc3Rib3ggb25lIGl0ZW0gYXQgYSB0aW1lPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5QcmVzc2luZyB0aGUgSG9tZS9FbmQga2V5cyBtb3ZlIGZvY3VzIHRvIHRoZSBmaXJzdC9sYXN0IGl0ZW1zIHJlc3BlY3RpdmVseTwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+VHlwaW5nIGFueSBzZXF1ZW5jZSBvZiB0ZXh0IHN0YXJ0cyB0eXBlYWhlYWQgdGhhdCBuYXZpZ2F0ZXMgdG8gdGhlIG5leHQgaXRlbSB0aGF0IG1hdGNoZXMgd2hhdCdzIGJlaW5nIHR5cGVkPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5Gb2N1cyAmYW1wOyBzZWxlY3Rpb24gbWFuYWdlbWVudCBpcyBhcyBvcHRpbWl6ZWQgYXMgcG9zc2libGU7IG9ubHkgdHdvIGNoaWxkcmVuIHJlLXJlbmRlciBhdCBhIHRpbWUgd2hlbiBmb2N1cyBvciBzZWxlY3Rpb24gY2hhbmdlczwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+VGhlc2UgYXBwbHkgZ2VuZXJhbGx5IHRvIGFsbCBjb21wb3NpdGUgY29tcG9uZW50cyB3aXRoIGEgdmFyaWFibGUgbnVtYmVyIG9mIGNoaWxkcmVuIChUYWIgTGlzdHMsIFJhZGlvIEdyb3VwcywgTXVsdGktU2VsZWN0IExpc3Rib3hlcyBldGMuKTwvbGk+XG4gICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+UmF0aGVyIHRoYW4gZWFjaCBpbmRpdmlkdWFsIGxpc3QgaXRlbSBrbm93aW5nIHdoZXRoZXIgaXQgaXMgc2VsZWN0ZWQgb3Igbm90IChhcyB3aXRoIG11bHRpLXNlbGVjdCBsaXN0cyksIGhlcmUgdGhlIHBhcmVudCBrbm93cyB0aGUgPGNvZGU+c2VsZWN0ZWRJbmRleDwvY29kZT4gYW5kIHNpbXBseSBub3RpZmllcyB0aGUgKG1heCB0d28pIHJlbGV2YW50IGNoaWxkcmVuIGFueSB0aW1lIGl0IGNoYW5nZXMuPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+R3JvdXBpbmcgaXMgc3VwcG9ydGVkPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+U29ydGluZy9yZW9yZGVyaW5nIGlzIHN1cHBvcnRlZCwgdGhvdWdoIG5vdCBwcm92aWRlZCBieSBkZWZhdWx0LCBhcyBpdCdzIG11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIGdyb3VwaW5nLjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPHA+PHN0cm9uZz5UaGluZ3MgPGVtPm5vdDwvZW0+IGhhbmRsZWQ6PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgIDxsaT5MaXN0Ym94ZXMgZG8gbm90IHN1cHBvcnQgaW50ZXJhY3RpdmUgY29udGVudCB3aXRoaW4gdGhlbSAoZS5nLiBhIGRyb3Bkb3duIG1lbnUpLCBhcyBBUklBIHNwZWNpZmllcyB0aGF0IHRoaXMgaXMgYSBkaWZmZXJlbnQgcGF0dGVybi48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZTxudWxsIHwgbnVtYmVyPihudWxsKTtcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDUpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIGxpc3QgaXRlbXM8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8TGlzdGJveFNpbmdsZVxuICAgICAgICAgICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJMaXN0Ym94U2luZ2xlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0xhYmVsOiBcImxhYmVsXCIsIHRhZ0xpc3Q6IFwib2xcIiwgbWFrZVByb3BzTGFiZWw6ICgpID0+ICh7fSksIG1ha2VQcm9wc0xpc3Q6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IDw+e0FycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPGRpdj48RGVtb0xpc3RJdGVtIGluZGV4PXtpfSBrZXk9e2l9IC8+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpKX08Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlPVwiYWN0aXZhdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIHRhZ0xhYmVsPVwibGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICB0YWdMaXN0PVwib2xcIlxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4PXtzZWxlY3RlZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdD17ZSA9PiBzZXRTZWxlY3RlZEluZGV4KGVbRXZlbnREZXRhaWxdLnNlbGVjdGVkSW5kZXgpfSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvPlxuICAgIClcbn0iLCJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsLCBMaXN0Ym94U2luZ2xlIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyTWVudSwgZGVmYXVsdFJlbmRlck1lbnVJdGVtLCBNZW51LCBNZW51SXRlbSB9IGZyb20gXCIuLi8uLi9jb21wb25lbnQvbWVudVwiXG5cbmZ1bmN0aW9uIERlbW9MaXN0SXRlbSh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8TWVudUl0ZW08SFRNTExJRWxlbWVudD4gaW5kZXg9e2luZGV4fSB0ZXh0PXtgTGlzdCBpdGVtICMke2luZGV4fWB9IHJlbmRlcj17ZGVmYXVsdFJlbmRlck1lbnVJdGVtKHsgdGFnTWVudUl0ZW06IFwibGlcIiwgbWFrZVByb3BzTWVudUl0ZW06ICgpID0+ICh7IGNoaWxkcmVuOiBgTWVudSBpdGVtICMke2luZGV4fWAgfSkgfSl9IC8+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHsgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDsgfVxuXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2xpc3Rib3gvXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIExpc3Rib3ggcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGNoaWxkcmVuIGFyZSB0cmVhdGVkIGFzIGEgY29tcG9zaXRlIGNvbXBvbmVudCB3aXRoIGxpc3QgbmF2aWdhdGlvbjsgc2VlIDxjb2RlPkFpcmFTaW5nbGVTZWxlY3RMaXN0PC9jb2RlPiBmb3IgbW9yZSBpbmZvcm1hdGlvbjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPldoZW4gb3BlbmVkLCB0aGUgbWVudSB3aWxsIGZvY3VzIHRoZSBmaXJzdCBlbGVtZW50IHdpdGhpbiBpdC4gV2hlbiBjbG9zZWQgKGJ5IHByZXNzaW5nIGVzY2FwZSwgcHJlc3NpbmcgdGhlIGJ1dHRvbiBhZ2Fpbiwgb3IgdGFiYmluZyBvdXQgb2YgdGhlIG1lbnUpLCB0aGUgYnV0dG9uIHRoYXQgb3BlbmVkIGl0IHdpbGwgaGF2ZSBmb2N1cyByZXN0b3JlZCB0byBpdC48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIHRoZSBtZW51IGlzIGNsb3NlZCBiZWNhdXNlIGFub3RoZXIgZWxlbWVudCBvbiB0aGUgcGFnZSB3YXMgZm9jdXNlZCBpbnN0ZWFkLCBmb2N1cyB3aWxsIG5vdCBiZSBtb2RpZmllZC48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+VE9ETzwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoNSk7XG4gICAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIG1lbnUgaXRlbXM8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8TWVudTxIVE1MRGl2RWxlbWVudCwgSFRNTFVMaXN0RWxlbWVudCwgSFRNTERpdkVsZW1lbnQsIEhUTUxMSUVsZW1lbnQsIEhUTUxCdXR0b25FbGVtZW50PlxuICAgICAgICAgICAgICAgICAgICBnZXREb2N1bWVudD17Z2V0RG9jdW1lbnR9XG4gICAgICAgICAgICAgICAgICAgIG9uT3Blbj17KCkgPT4gc2V0T3Blbih0cnVlKX1cbiAgICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4gc2V0T3BlbihmYWxzZSl9XG4gICAgICAgICAgICAgICAgICAgIG9wZW49e29wZW59XG4gICAgICAgICAgICAgICAgICAgIG9wZW5EaXJlY3Rpb249XCJkb3duXCJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyPXtkZWZhdWx0UmVuZGVyTWVudSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdCdXR0b246IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdNZW51OiBcInVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdTZW50aW5lbDogXCJkaXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ1N1cmZhY2U6IFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0YWxJZDogXCJwb3J0YWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0J1dHRvbjogKCkgPT4gKHsgY2hpbGRyZW46IFwiT3BlbiBtZW51XCIgKyAob3Blbj8gXCIgKG9wZW4pXCIgOiBcIiAoY2xvc2VkKVwiKSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc01lbnU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IDw+e0FycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPGRpdj48RGVtb0xpc3RJdGVtIGluZGV4PXtpfSBrZXk9e2l9IC8+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpKX08Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzU3VyZmFjZTogKCkgPT4gKHsgc3R5bGU6IHsgZGlzcGxheTogIW9wZW4/IFwibm9uZVwiIDogdW5kZWZpbmVkIH0gfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNTZW50aW5lbDogKCkgPT4gKHt9KSxcbiAgICAgICAgICAgICAgICAgICAgfSl9IC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgKVxufSIsIlxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0LXByb3AtaGVscGVyc1wiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlclJhZGlvLCBSYWRpbywgUmFkaW9Hcm91cCB9IGZyb20gXCIuLi8uLi9jb21wb25lbnQvcmFkaW8tZ3JvdXBcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsLCBMaXN0Ym94U2luZ2xlLCBkZWZhdWx0UmVuZGVyUmFkaW9Hcm91cCB9IGZyb20gXCIuLi8uLi9pbmRleFwiO1xuXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50O1xufVxuXG5mdW5jdGlvbiBEZW1vTGlzdEl0ZW0oeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkge1xuXG4gICAgY29uc3QgdmFsdWUgPSBgUmFkaW8gYnV0dG9uICMke2luZGV4fWA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8UmFkaW88bnVtYmVyLCBIVE1MSW5wdXRFbGVtZW50LCBIVE1MTGFiZWxFbGVtZW50PlxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2ZhbHNlfVxuICAgICAgICAgICAgbGFiZWxQb3NpdGlvbj1cInNlcGFyYXRlXCJcbiAgICAgICAgICAgIHRleHQ9e3ZhbHVlfVxuICAgICAgICAgICAgdmFsdWU9e2luZGV4fVxuICAgICAgICAgICAgdGFnSW5wdXQ9XCJpbnB1dFwiXG4gICAgICAgICAgICB0YWdMYWJlbD1cImxhYmVsXCJcbiAgICAgICAgICAgIHJlbmRlcj17ZGVmYXVsdFJlbmRlclJhZGlvKHtcbiAgICAgICAgICAgICAgICBsYWJlbFBvc2l0aW9uOiBcInNlcGFyYXRlXCIsXG4gICAgICAgICAgICAgICAgdGFnSW5wdXQ6IFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgICB0YWdMYWJlbDogXCJsYWJlbFwiLFxuICAgICAgICAgICAgICAgIG1ha2VJbnB1dFByb3BzOiAoKSA9PiAoeyBuYW1lOiBcInJhZGlvLWRlbW9cIiB9KSxcbiAgICAgICAgICAgICAgICBtYWtlTGFiZWxQcm9wczogKCkgPT4gKHsgY2hpbGRyZW46IHZhbHVlIH0pXG4gICAgICAgICAgICB9KX0gLz5cbiAgICApXG59XG5cblxuXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL3JhZGlvYnV0dG9uL1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBSYWRpbyBCdXR0b24gcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGNoaWxkcmVuIGFyZSB0cmVhdGVkIGFzIGEgY29tcG9zaXRlIGNvbXBvbmVudCB3aXRoIGxpc3QgbmF2aWdhdGlvbjsgc2VlIDxjb2RlPkFpcmFTaW5nbGVTZWxlY3RMaXN0PC9jb2RlPiBmb3IgbW9yZSBpbmZvcm1hdGlvbjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPlRoZSBpbnB1dCAmYW1wOyBsYWJlbCBzdXBwb3J0IHRoZSBzYW1lIHRleHQtc2VsZWN0aW9uIGFmZm9yZGFuY2VzIGFzIENoZWNrYm94ZXMgKGxhYmVscyBjYW4gYmUgc2VsZWN0ZWQsIGJ1dCBkb3VibGUtY2xpY2tpbmcgZG9lc24ndCBzZWxlY3QgdGhlIHRleHQgYW5kIHNlbGVjdGluZyB0ZXh0IGRvZXNuJ3QgY291bnQgYXMgYW4gaW5wdXQpPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+U2VsZWN0aW9uIHN0YXRlIGlzIGhhbmRsZWQgYnkgdGhlIHBhcmVudDsgaW5zdGVhZCBvZiBzcGVjaWZ5aW5nIHdoZXRoZXIgYW55IGdpdmVuIHJhZGlvIGJ1dHRvbiBpcyBjaGVja2VkIG9yIG5vdCwgdGhlIHBhcmVudCBub3RpZmllcyBlYWNoIGNoaWxkIG9mIHRoZSBuZWNlc3NhcnkgY2hhbmdlcy48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+SWYgeW91ciBjaGVja2JveCBkb2VzIG5vdCBoYXZlIGEgdmlzaWJsZSBsYWJlbCAoYWNoaWV2YWJsZSBieSBieSBvdmVycmlkaW5nIHRoZSA8Y29kZT5yZW5kZXI8L2NvZGU+IHByb3AgYW5kIHNldHRpbmcgPGNvZGU+bGFiZWxQb3NpdGlvbjwvY29kZT4gdG8gYmUgXCJzZXBhcmF0ZVwiKSwgeW91IG11c3QgcGFzcyA8Y29kZT5hcmlhLWxhYmVsPC9jb2RlPiBhcyBhIHByb3AgdG8gdGhlIGNoZWNrYm94IG1hbnVhbGx5LiBOb3QgcHJvdmlkaW5nIG9uZSB3aWxsIHByaW50IGFuIGVycm9yIHRvIHRoZSBjb25zb2xlLCBidXQgaXQgaXQgbm90IHJlcXVpcmVkIGJ5IHRoZSB0eXBlIHN5c3RlbS48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5UaGUgYWJvdmUgYWxzbyBhcHBsaWVzIHRvIHRoZSByYWRpbyBncm91cCBhcyBhIHdob2xlOyBBUklBIHJlcXVpcmVzIHRoYXQgYWxsIFJhZGlvIEJ1dHRvbnMgYmUgY29udGFpbmVkIHdpdGhpbiBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpYyByb2xlIHdoaWNoIGlzIGxhYmVsbGVkIGVpdGhlciBieSBhbiBlbGVtZW50IChoYW5kbGVkIGZvciB5b3UpIG9yIDxjb2RlPmFyaWEtbGFiZWw8L2NvZGU+IChzcGVjaWZpZWQgYnkgeW91IG1hbnVhbGx5IG9uIHRoZSBpbnB1dCkuPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XG4gICAgcmV0dXJuICg8Y29kZT57YGB9PC9jb2RlPilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XG4gICAgY29uc3QgW3NlbGVjdGVkSW5kZXgsIHNldFNlbGVjdGVkSW5kZXhdID0gdXNlU3RhdGU8bnVsbCB8IG51bWJlcj4obnVsbCk7XG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSg1KTtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxCbHVyYiAvPlxuICAgICAgICAgICAgPENvZGUgLz5cbiAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgdHlwZT1cIm51bWJlclwiIG1pbj17MH0gdmFsdWU9e2NvdW50fSBvbklucHV0PXtlID0+IHNldENvdW50KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz4gIyBvZiByYWRpbyBidXR0b25zPC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPFJhZGlvR3JvdXA8bnVtYmVyLCBIVE1MRGl2RWxlbWVudCwgSFRNTExhYmVsRWxlbWVudCwgSFRNTElucHV0RWxlbWVudCwgSFRNTExhYmVsRWxlbWVudD5cbiAgICAgICAgICAgICAgICAgICAgbmFtZT1cInJhZGlvLWRlbW9cIlxuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGVkVmFsdWVDaGFuZ2U9e2UgPT4gc2V0U2VsZWN0ZWRJbmRleChlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZFZhbHVlID8/IDApfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFZhbHVlPXtzZWxlY3RlZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICB0YWdHcm91cExhYmVsPVwibGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICB0YWdHcm91cD1cImRpdlwiXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcj17ZGVmYXVsdFJlbmRlclJhZGlvR3JvdXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnR3JvdXA6IFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdMYWJlbDogXCJsYWJlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzR3JvdXA6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9MaXN0SXRlbSBpbmRleD17aX0ga2V5PXtpfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzTGFiZWw6IChpbmZvKSA9PiAoeyBjaGlsZHJlbjogXCJSYWRpbyBncm91cCBleGFtcGxlIFwiICsgXCIoXCIgKyBpbmZvLnJhZGlvR3JvdXAuc2VsZWN0ZWRJbmRleD8udG9TdHJpbmcoKSArIFwiKVwiIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pfSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvPlxuICAgIClcbn0iLCJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsLCBMaXN0Ym94U2luZ2xlIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyU2xpZGVyVGh1bWIsIFNsaWRlclRodW1iLCBTbGlkZXIgfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50L3NsaWRlclwiXG5cbmZ1bmN0aW9uIERlbW9TbGlkZXJUaHVtYih7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSB7XG4gICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VTdGF0ZSgwKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxTbGlkZXJUaHVtYjxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgICAgICAgaW5kZXg9e2luZGV4fVxuICAgICAgICAgICAgdGFnPVwiaW5wdXRcIlxuICAgICAgICAgICAgbGFiZWw9e2BTbGlkZXIgdGh1bWIgIyR7aW5kZXh9YH1cbiAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgIG9uVmFsdWVDaGFuZ2U9e2UgPT4gc2V0VmFsdWUoZVtFdmVudERldGFpbF0udmFsdWUpfVxuICAgICAgICAgICAgbWluPXswfVxuICAgICAgICAgICAgbWF4PXsxMH1cbiAgICAgICAgICAgIHJlbmRlcj17ZGVmYXVsdFJlbmRlclNsaWRlclRodW1iKHsgdGFnVGh1bWI6IFwiaW5wdXRcIiwgbWFrZVByb3BzVGh1bWI6ICgpID0+ICh7fSkgfSl9IC8+XG4gICAgKVxufVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHsgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDsgfVxuXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2xpc3Rib3gvXCI+SW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBBUklBIGd1aWRlbGluZXMgZm9yIExpc3Rib3ggcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIGNoaWxkcmVuIGFyZSB0cmVhdGVkIGFzIGEgY29tcG9zaXRlIGNvbXBvbmVudCB3aXRoIGxpc3QgbmF2aWdhdGlvbjsgc2VlIDxjb2RlPkFpcmFTaW5nbGVTZWxlY3RMaXN0PC9jb2RlPiBmb3IgbW9yZSBpbmZvcm1hdGlvbjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPldoZW4gb3BlbmVkLCB0aGUgbWVudSB3aWxsIGZvY3VzIHRoZSBmaXJzdCBlbGVtZW50IHdpdGhpbiBpdC4gV2hlbiBjbG9zZWQgKGJ5IHByZXNzaW5nIGVzY2FwZSwgcHJlc3NpbmcgdGhlIGJ1dHRvbiBhZ2Fpbiwgb3IgdGFiYmluZyBvdXQgb2YgdGhlIG1lbnUpLCB0aGUgYnV0dG9uIHRoYXQgb3BlbmVkIGl0IHdpbGwgaGF2ZSBmb2N1cyByZXN0b3JlZCB0byBpdC48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5XaGVuIHRoZSBtZW51IGlzIGNsb3NlZCBiZWNhdXNlIGFub3RoZXIgZWxlbWVudCBvbiB0aGUgcGFnZSB3YXMgZm9jdXNlZCBpbnN0ZWFkLCBmb2N1cyB3aWxsIG5vdCBiZSBtb2RpZmllZC48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+VE9ETzwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDb2RlKCkge1xuICAgIHJldHVybiAoPGNvZGU+e2BgfTwvY29kZT4pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZW1vKCkge1xuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoNSk7XG4gICAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIHNsaWRlciB0aHVtYnM8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8U2xpZGVyXG4gICAgICAgICAgICAgICAgICAgIG1pbj17MH1cbiAgICAgICAgICAgICAgICAgICAgbWF4PXsxMH1cbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW49ezw+e0FycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8ZGl2PjxEZW1vU2xpZGVyVGh1bWIgaW5kZXg9e2l9IGtleT17aX0gLz48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkoKSl9XG4gICAgICAgICAgICAgICAgICAgIDwvPn0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICApXG59IiwiXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QtcHJvcC1oZWxwZXJzXCI7XG5pbXBvcnQgeyBkZWZhdWx0UmVuZGVyRGlhbG9nLCBEaWFsb2cgfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50L2RpYWxvZ1wiO1xuaW1wb3J0IHsgQnV0dG9uLCBkZWZhdWx0UmVuZGVyQnV0dG9uIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cblxuXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHsgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDsgfVxuXG5leHBvcnQgZnVuY3Rpb24gQmx1cmIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxwPjxhIGhyZWY9XCJodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL2RpYWxvZ21vZGFsL1wiPkluIGFjY29yZGFuY2Ugd2l0aCB0aGUgQVJJQSBndWlkZWxpbmVzIGZvciBNb2RhbCBEaWFsb2cgcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+RGlhbG9ncyBibG9jayBhbGwgb3RoZXIgZWxlbWVudHMgb24gdGhlIHBhZ2UgZnJvbSByZWNlaXZpbmcgZm9jdXMvaW50ZXJhY3Rpb24gYW5kIGJlaW5nIHBlcmNlaXZhYmxlIHRvIHNjcmVlbiByZWFkZXJzLjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPkRpYWxvZ3MgY2FuIGJlIGRpc21pc3NlZCBieSBwcmVzc2luZyBFc2NhcGUgb3IgY2xpY2tpbmcgdGhlIGVsZW1lbnQgZGVzaWduYXRlZCBhcyB0aGUgYmFja2Ryb3AsIGJvdGggb2Ygd2hpY2ggY2FuIGJlIGNhbmNlbGxlZC9pZ25vcmVkIGlmIHlvdSBuZWVkPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+V2hlbiBvcGVuZWQsIHRoZSBkaWFsb2cgd2lsbCBmb2N1cyBpdHMgdGl0bGUgb3IgYm9keSBjb250ZW50IGFzIGFwcHJvcHJpYXRlLCBob3dldmVyIHJlYWQgYmVsb3cgdW5kZXIgVGhpbmdzIE5vdCBIYW5kbGVkIGZvciBjYXZlYXRzLjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPldoZW4gY2xvc2VkIGZvciBhbnkgcmVhc29uLCB0aGUgZWxlbWVudCB0aGF0IHdhcyByZXNwb25zaWJsZSBmb3Igb3BlbmluZyB0aGUgZGlhbG9nIHdpbGwgYmUgZm9jdXNlZC48L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDxwPjxzdHJvbmc+VGhpbmdzIDxlbT5ub3Q8L2VtPiBoYW5kbGVkOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+QnkgZGVmYXVsdCwgd2hlbiBvcGVuZWQsIGEgZGlhbG9nIHdpbGwgZm9jdXMgaXRzIGJvZHkgY29udGVudCBvciB0aXRsZSBjb250ZW50IGRlcGVuZGluZyBvbiA8Y29kZT5ib2R5SXNPbmx5U2VtYW50aWM8L2NvZGU+LCB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGUgZGlhbG9nJ3MgYm9keSBjb250YWlucyBubyBpbnRlcmFjdGl2ZSBlbGVtZW50cy4gVGhpcyBtYXkgbm90IGJlIHN1aXRhYmxlIGZvciBhbGwgc2l0dWF0aW9ucy48L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5JdCBpcyA8ZW0+aGlnaHRseTwvZW0+IHJlY29tbWVuZGVkIHRvIG92ZXJyaWRlIDxjb2RlPmZvY3VzU2VsZjwvY29kZT4gZm9yIGFsbCBkaWFsb2dzIHlvdSBjcmVhdGUsIGFuZCBoYXZlIGl0IGZvY3VzIHdoYXRldmVyIGVsZW1lbnQgbWFrZXMgdGhlIG1vc3Qgc2Vuc2UgZm9yIHlvdXIgcGFydGljdWxhciBkaWFsb2cuXG4gICAgICAgICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5EaWFsb2dzIHRoYXQgYWN0IGxpa2UgYSBmb3JtIHNob3VsZCBmb2N1cyB0aGUgZmlyc3QgaW50ZXJhY3RpdmUgZWxlbWVudDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bGk+RGlhbG9ncyB0aGF0IHBlcmZvcm0gZGVzdHJ1Y3RpdmUgYWN0aW9ucyBzaG91bGQgZm9jdXMgdGhlIFwiQ2FuY2VsXCIgYnV0dG9uPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5JbiBzb21lIGNhc2VzLCBpdCdzIGJlc3QgdG8gZm9jdXMgdGhlIGZpcnN0IHBhcmFncmFwaCBvZiB0aGUgYm9keS48L2xpPlxuICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICBJbiBhbGwgY2FzZXMsIGNvbnNpZGVyIHRoYXQgdGhlIGZpcnN0IGZvY3VzZWQgZWxlbWVudCB3aWxsIGJvdGggYmUgaG93IGtleWJvYXJkIHVzZXJzIGludGVyYWN0IHdpdGggdGhlIGRpYWxvZywgYnV0IGFsc28gdGhlIGZpcnN0IHRoaW5nIGEgc2NyZWVuIHJlYWRlciB3aWxsIHJlYWQgYWxvdWQuXG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvPlxuICAgIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENvZGUoKSB7XG4gICAgcmV0dXJuICg8Y29kZT57YGB9PC9jb2RlPilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIERlbW8oKSB7XG4gICAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8QnV0dG9uIHRhZz1cImJ1dHRvblwiIG9uUHJlc3M9eygpID0+IHNldE9wZW4odHJ1ZSl9IHJlbmRlcj17ZGVmYXVsdFJlbmRlckJ1dHRvbihcImJ1dHRvblwiLCAoKSA9PiAoeyBjaGlsZHJlbjogXCJPcGVuIGRpYWxvZyBcIiArIChvcGVuID8gXCIob3BlbilcIiA6IFwiKGNsb3NlZClcIikgfSkpfSAvPlxuICAgICAgICAgICAgICAgIDxEaWFsb2dcbiAgICAgICAgICAgICAgICAgICAgZ2V0RG9jdW1lbnQ9e2dldERvY3VtZW50fVxuICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBzZXRPcGVuKGZhbHNlKX1cbiAgICAgICAgICAgICAgICAgICAgb3Blbj17b3Blbn1cbiAgICAgICAgICAgICAgICAgICAgYm9keUlzT25seVNlbWFudGljPXt0cnVlfVxuICAgICAgICAgICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJEaWFsb2coe1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydGFsSWQ6IFwicG9ydGFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUHJvcHNCYWNrZHJvcDogKCkgPT4gKHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyOiAoKSA9PiAoe30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzQm9keTogKCkgPT4gKHsgY2hpbGRyZW46IFwiRGlhbG9nIGJvZHlcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0RpYWxvZzogKCkgPT4gKHsgc3R5bGU6IHsgZGlzcGxheTogIW9wZW4gPyBcIm5vbmVcIiA6IHVuZGVmaW5lZCB9IH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFrZVByb3BzVGl0bGU6ICgpID0+ICh7IGNoaWxkcmVuOiBcIkRpYWxvZyB0aXRsZVwiIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnQmFja2Ryb3A6IFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdCb2R5OiBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnRGlhbG9nOiBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnVGl0bGU6IFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdGb2N1c0NvbnRhaW5lcjogXCJkaXZcIlxuICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvPlxuICAgIClcbn0iLCJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC1wcm9wLWhlbHBlcnNcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgZGVmYXVsdFJlbmRlclRhYiwgZGVmYXVsdFJlbmRlclRhYlBhbmVsLCBkZWZhdWx0UmVuZGVyVGFicywgVGFicyB9IGZyb20gXCIuLi8uLi9cIjtcbmltcG9ydCB7IFRhYiwgVGFiUGFuZWwgfSBmcm9tIFwiLi4vLi4vY29tcG9uZW50L3RhYnNcIjtcbmltcG9ydCB7IEV2ZW50RGV0YWlsIH0gZnJvbSBcIi4uLy4uL2luZGV4XCI7XG5cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7IHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7IH1cblxuZXhwb3J0IGZ1bmN0aW9uIEJsdXJiKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8cD48YSBocmVmPVwiaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy90YWJwYW5lbC9cIj5JbiBhY2NvcmRhbmNlIHdpdGggdGhlIEFSSUEgZ3VpZGVsaW5lcyBmb3IgVGFiIGFuZCBUYWIgUGFuZWwgcGF0dGVybnMsPC9hPiB0aGlzIHdpZGdldCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nOjwvcD5cbiAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICA8bGk+VGhlIHRhYnMgYXJlIHRyZWF0ZWQgYXMgYSBjb21wb3NpdGUgY29tcG9uZW50IHdpdGggbGlzdCBuYXZpZ2F0aW9uOyBzZWUgPGNvZGU+QWlyYVNpbmdsZVNlbGVjdExpc3Q8L2NvZGU+IGZvciBtb3JlIGluZm9ybWF0aW9uPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8cD48c3Ryb25nPlRoaW5ncyA8ZW0+bm90PC9lbT4gaGFuZGxlZDo8L3N0cm9uZz48L3A+XG4gICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPlRPRE88L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC8+XG4gICAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ29kZSgpIHtcbiAgICByZXR1cm4gKDxjb2RlPntgYH08L2NvZGU+KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVtbygpIHtcbiAgICBjb25zdCBbY291bnQsIHNldENvdW50XSA9IHVzZVN0YXRlKDUpO1xuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlKDApO1xuXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPEJsdXJiIC8+XG4gICAgICAgICAgICA8Q29kZSAvPlxuICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVwibnVtYmVyXCIgbWluPXswfSB2YWx1ZT17Y291bnR9IG9uSW5wdXQ9e2UgPT4gc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPiAjIG9mIHRhYnM8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICA8VGFic1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4PXtzZWxlY3RlZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25Nb2RlPVwiZm9jdXNcIlxuICAgICAgICAgICAgICAgICAgICBvblNlbGVjdGVkSW5kZXhDaGFuZ2U9e2UgPT4gc2V0U2VsZWN0ZWRJbmRleChlW0V2ZW50RGV0YWlsXS5zZWxlY3RlZEluZGV4KX1cblxuICAgICAgICAgICAgICAgICAgICByZW5kZXI9e2RlZmF1bHRSZW5kZXJUYWJzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhbmVsczogQXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9UYWJQYW5lbCBpPXtpfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTGFiZWw6IFwibGFiZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0xpc3Q6IFwidWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0xhYmVsOiAoKSA9PiAoeyBjaGlsZHJlbjogXCJUYWJzIGV4YW1wbGVcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VQcm9wc0xpc3Q6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IDw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9UYWIgaT17aX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmNvbnN0IERlbW9UYWIgPSBtZW1vKGZ1bmN0aW9uIERlbW9UYWIoeyBpIH06IHsgaTogbnVtYmVyIH0pIHtcbiAgICBjb25zdCBsYWJlbCA9IGBUYWIgIyR7aX1gO1xuICAgIHJldHVybiA8VGFiIGtleT17aX0gaW5kZXg9e2l9IGdldERvY3VtZW50PXtnZXREb2N1bWVudH0gcmVuZGVyPXtkZWZhdWx0UmVuZGVyVGFiKHsgdGFnVGFiOiBcImxpXCIsIG1ha2VQcm9wc1RhYjogKCkgPT4gKHsgY2hpbGRyZW46IGxhYmVsIH0pIH0pfSB0ZXh0PXtsYWJlbH0gLz5cbn0pXG5cbmNvbnN0IERlbW9UYWJQYW5lbCA9IG1lbW8oZnVuY3Rpb24gRGVtb1RhYlBhbmVsKHsgaSB9OiB7IGk6IG51bWJlciB9KSB7XG4gICAgY29uc3QgbGFiZWwgPSBgVGFiIHBhbmVsICMke2l9YDtcbiAgICByZXR1cm4gPFRhYlBhbmVsIGluZGV4PXtpfSBrZXk9e2l9IHJlbmRlcj17ZGVmYXVsdFJlbmRlclRhYlBhbmVsKHsgdGFnVGFiUGFuZWw6IFwiZGl2XCIsIG1ha2VQcm9wc1RhYlBhbmVsOiAoeyB0YWJQYW5lbDogeyB2aXNpYmxlIH0gfSkgPT4gKHsgaGlkZGVuOiAhdmlzaWJsZSwgY2hpbGRyZW46IGxhYmVsIH0pIH0pfSAvPlxufSlcblxuIiwiXG5pbXBvcnQgeyByZW5kZXIsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBIZWFkaW5nIH0gZnJvbSBcIi4uL2NvbXBvbmVudC9oZWFkaW5nXCI7XG5pbXBvcnQgKiBhcyBBY2NvcmRpb24gZnJvbSBcIi4vZGVtb3MvYWNjb3JkaW9uXCJcbmltcG9ydCAqIGFzIEJ1dHRvbiBmcm9tIFwiLi9kZW1vcy9idXR0b25cIlxuaW1wb3J0ICogYXMgQ2hlY2tib3ggZnJvbSBcIi4vZGVtb3MvY2hlY2tib3hcIlxuaW1wb3J0ICogYXMgQ2hlY2tib3hHcm91cCBmcm9tIFwiLi9kZW1vcy9jaGVja2JveC1ncm91cFwiXG5pbXBvcnQgKiBhcyBMaXN0Ym94TXVsdGkgZnJvbSBcIi4vZGVtb3MvbGlzdGJveC1tdWx0aVwiXG5pbXBvcnQgKiBhcyBMaXN0Ym94U2luZ2xlIGZyb20gXCIuL2RlbW9zL2xpc3Rib3gtc2luZ2xlXCJcbmltcG9ydCAqIGFzIE1lbnUgZnJvbSBcIi4vZGVtb3MvbWVudVwiXG5pbXBvcnQgKiBhcyBSYWRpbyBmcm9tIFwiLi9kZW1vcy9yYWRpb1wiXG5pbXBvcnQgKiBhcyBTbGlkZXIgZnJvbSBcIi4vZGVtb3Mvc2xpZGVyXCJcbmltcG9ydCAqIGFzIERpYWxvZyBmcm9tIFwiLi9kZW1vcy9kaWFsb2dcIlxuaW1wb3J0ICogYXMgVGFicyBmcm9tIFwiLi9kZW1vcy90YWJzXCJcblxuLy9pbXBvcnQgeyBvcHRpb25zIH0gZnJvbSBcInByZWFjdFwiO1xuLy9vcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID0gcXVldWVNaWNyb3Rhc2s7XG5cbi8vY29uc3QgUmFuZG9tV29yZHMgPSBcIkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNjaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiBVdCBlbmltIGFkIG1pbmltIHZlbmlhbSwgcXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhIGNvbW1vZG8gY29uc2VxdWF0LiBEdWlzIGF1dGUgaXJ1cmUgZG9sb3IgaW4gcmVwcmVoZW5kZXJpdCBpbiB2b2x1cHRhdGUgdmVsaXQgZXNzZSBjaWxsdW0gZG9sb3JlIGV1IGZ1Z2lhdCBudWxsYSBwYXJpYXR1ci4gRXhjZXB0ZXVyIHNpbnQgb2NjYWVjYXQgY3VwaWRhdGF0IG5vbiBwcm9pZGVudCwgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3QgbGFib3J1bS5cIi5zcGxpdChcIiBcIik7XG5cblxuY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJEZW1vc1wiPlxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIlRhYnNcIj48VGFicy5EZW1vIC8+PC9IZWFkaW5nPlxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkRpYWxvZ1wiPjxEaWFsb2cuRGVtbyAvPjwvSGVhZGluZz5cbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJTbGlkZXJcIj48U2xpZGVyLkRlbW8gLz48L0hlYWRpbmc+XG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiU2luZ2xlLXNlbGVjdCBMaXN0Ym94XCI+PExpc3Rib3hTaW5nbGUuRGVtbyAvPjwvSGVhZGluZz5cbiAgICAgICAgICAgIDxIZWFkaW5nIGhlYWRpbmc9XCJBY2NvcmRpb25cIj48QWNjb3JkaW9uLkRlbW8gLz48L0hlYWRpbmc+XG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiQnV0dG9uXCI+PEJ1dHRvbi5EZW1vIC8+PC9IZWFkaW5nPlxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIkNoZWNrYm94XCI+PENoZWNrYm94LkRlbW8gLz48L0hlYWRpbmc+XG4gICAgICAgICAgICA8SGVhZGluZyBoZWFkaW5nPVwiQ2hlY2tib3ggR3JvdXBcIj48Q2hlY2tib3hHcm91cC5EZW1vIC8+PC9IZWFkaW5nPlxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIk11bHRpLXNlbGVjdCBMaXN0Ym94XCI+PExpc3Rib3hNdWx0aS5EZW1vIC8+PC9IZWFkaW5nPlxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIk1lbnVcIj48TWVudS5EZW1vIC8+PC9IZWFkaW5nPlxuICAgICAgICAgICAgPEhlYWRpbmcgaGVhZGluZz1cIlJhZGlvXCI+PFJhZGlvLkRlbW8gLz48L0hlYWRpbmc+XG4gICAgICAgICAgICB7LypcbiAgICAgICBcbiAgICAgICAgPERlbW9UYWJsZSAvPlxuXG5cbiAgICAgICAgPERlbW9Vc2VGb2N1c1RyYXAgLz5cbiAgICAgICAgPERlbW9Vc2VEcm9wcGFibGUgLz5cbiAgICAgICAgPERlbW9Vc2VEcmFnZ2FibGUgLz5cbiAgICAgICAgPGlucHV0IC8+Ki99XG4gICAgICAgIDwvSGVhZGluZz4pXG59XG5cbnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgcmVuZGVyKDxDb21wb25lbnQgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9vdFwiKSEpO1xufSlcbiJdLCJuYW1lcyI6WyJFdmVudERldGFpbCIsIlN5bWJvbCIsIkhlYWRpbmdMZXZlbENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiaGVhZGluZyIsInByb3BzIiwiaGVhZGluZ0xldmVsQmVmb3JlVXMiLCJ1c2VDb250ZXh0IiwidGFnIiwibmV3SGVhZGluZ0xldmVsIiwid2Fybk9uT3ZlcndyaXRlIiwiX2pzeCIsImNoaWxkcmVuIiwiX2pzeHMiLCJIZWFkaW5nUmVzZXQiLCJuZXdMZXZlbCIsInVzZUVuc3VyZVN0YWJpbGl0eSIsInBhcmVudEhvb2tOYW1lIiwidmFsdWVzIiwibGVuZ3RoIiwiZm9yRWFjaCIsInZhbHVlIiwiaW5kZXgiLCJoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eSIsInVzZVJlZiIsInNob3duRXJyb3IiLCJjdXJyZW50IiwiY29uc29sZSIsImVycm9yIiwidXNlUGFzc2l2ZVN0YXRlIiwib25DaGFuZ2UiLCJnZXRJbml0aWFsVmFsdWUiLCJ2YWx1ZVJlZiIsIlVuc2V0Iiwid2FybmluZ1JlZiIsImNsZWFudXBDYWxsYmFja1JlZiIsInVuZGVmaW5lZCIsIm9uU2hvdWxkQ2xlYW5VcCIsInVzZUNhbGxiYWNrIiwiY2xlYW51cENhbGxiYWNrIiwidHJ5RW5zdXJlVmFsdWUiLCJpbml0aWFsVmFsdWUiLCJleCIsImdldFZhbHVlIiwid2FybiIsInVzZUxheW91dEVmZmVjdCIsInIiLCJwcmV2RGVwIiwic2V0VmFsdWUiLCJhcmciLCJuZXh0VmFsdWUiLCJGdW5jdGlvbiIsImRlYm91bmNlUmVuZGVyaW5nIiwibmV4dERlcCIsImFjdGl2ZUVsZW1lbnRVcGRhdGVycyIsIk1hcCIsImxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMiLCJ3aW5kb3dGb2N1c2VkVXBkYXRlcnMiLCJ3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzIiwibWljcm90YXNrcyIsImZvckVhY2hVcGRhdGVyIiwid2luZG93IiwibWFwIiwidXBkYXRlcnNLZXkiLCJoYXMiLCJnZXQiLCJkZWxldGUiLCJ1cGRhdGVyIiwic2V0IiwiZm9jdXNvdXQiLCJlIiwidGFyZ2V0IiwiZGVmYXVsdFZpZXciLCJyZWxhdGVkVGFyZ2V0IiwiZm9jdXNpbiIsImN1cnJlbnRseUZvY3VzZWRFbGVtZW50IiwiV2luZG93IiwiY3VycmVudFRhcmdldCIsIm93bmVyRG9jdW1lbnQiLCJUYWJsZSIsImJhc2U2NCIsInJhbmRvbTZCaXRzIiwiZ2VuZXJhdGVSYW5kb21JZCIsInByZWZpeCIsInJhbmRvbTY0Qml0cyIsIm4iLCJqb2luIiwicHJldmlvdXNJbnB1dHMiLCJ0b1J1biIsImNvbW1pdE5hbWUiLCJvcmlnaW5hbENvbW1pdCIsIm9wdGlvbnMiLCJuZXdDb21taXQiLCJpZCIsImVmZmVjdEluZm8iLCJjbGVhciIsImFyZ3MiLCJlZmZlY3QiLCJpbnB1dHMiLCJ1c2VTdGFibGVHZXR0ZXIiLCJyZWYiLCJ1c2VCZWZvcmVMYXlvdXRFZmZlY3QiLCJFcnJvciIsImZuIiwiY3VycmVudENhbGxiYWNrR2V0dGVyIiwiaXNPYmplY3QiLCJ0eXBlIiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsIk9iamVjdCIsImZyZWVTZWxmIiwic2VsZiIsInJvb3QiLCJvYmplY3RQcm90byIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJ0b1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJnZXRSYXdUYWciLCJpc093biIsImNhbGwiLCJ1bm1hc2tlZCIsInJlc3VsdCIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsImJhc2VHZXRUYWciLCJpc09iamVjdExpa2UiLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInN0YXRlIiwic2V0U3RhdGVQIiwidXNlU3RhdGVQIiwic2V0U3RhdGUiLCJjYWxsYmFjayIsInByZXZWYWx1ZSIsInBhcmVudFBhcmFtZXRlcnMiLCJtYW5hZ2VkQ2hpbGRyZW4iLCJvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QiLCJvbkNoaWxkcmVuTW91bnRDaGFuZ2UiLCJnZXRIaWdoZXN0SW5kZXgiLCJtYW5hZ2VkQ2hpbGRyZW5BcnJheSIsImhpZ2hlc3RJbmRleCIsImFyciIsInJlYyIsImxvd2VzdEluZGV4IiwiZm9yRWFjaENoaWxkIiwiZiIsImNoaWxkIiwiZmllbGQiLCJyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzIiwiU2V0IiwicmVtb3RlVUxFQ2hpbGRDaGFuZ2VkIiwic2l6ZSIsImFkZCIsInJlbW90ZVVMRUNoaWxkTW91bnRlZCIsIm1vdW50ZWQiLCJoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQiLCJtb3VudHMiLCJ1bm1vdW50cyIsIk1hdGgiLCJtYXgiLCJzaGF2ZSIsInNwbGljZSIsInVzZU1hbmFnZWRDaGlsZCIsIm1hbmFnZWRDaGlsZCIsImluZm8iLCJmbGFncyIsInN1YkluZm8iLCJlbnRyaWVzIiwiZmxhdCIsInQiLCJBcnJheSIsImlzQXJyYXkiLCJjbHN4IiwiYXJndW1lbnRzIiwiZ2V0RG9jdW1lbnQiLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJnbG9iYWxUaGlzIiwidXNlTWVyZ2VkQ2hpbGRyZW4iLCJsaHMiLCJyaHMiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJ1c2VNZXJnZWRDbGFzc2VzIiwiY2xhc3MiLCJsaHNDbGFzcyIsImNsYXNzTmFtZSIsImxoc0NsYXNzTmFtZSIsInJoc0NsYXNzIiwicmhzQ2xhc3NOYW1lIiwibGhzQ2xhc3NlcyIsInNwbGl0IiwicmhzQ2xhc3NlcyIsImFsbENsYXNzZXMiLCJmcm9tIiwicHJvY2Vzc1JlZiIsImluc3RhbmNlIiwiYXNzZXJ0IiwiY29tYmluZWQiLCJzdHlsZVN0cmluZ1RvT2JqZWN0Iiwic3R5bGUiLCJmcm9tRW50cmllcyIsInN0YXRlbWVudCIsInVzZU1lcmdlZFN0eWxlcyIsImxvZyIsInVzZU1lcmdlZFByb3BzIiwibGhzQWxsIiwicmhzQWxsIiwiX2xoc0NoaWxkcmVuIiwiX2xoc0NsYXNzTmFtZSIsIl9saHNTdHlsZSIsIl9saHNSZWYiLCJsaHNNaXNjIiwiX3Joc0NoaWxkcmVuIiwiX3Joc0NsYXNzIiwiX3Joc0NsYXNzTmFtZSIsIl9yaHNTdHlsZSIsIl9yaHNSZWYiLCJyaHNNaXNjIiwicmV0IiwidXNlTWVyZ2VkUmVmcyIsInJoc0VudHJpZXMiLCJyaHNLZXlVIiwicmhzVmFsdWUiLCJyaHNLZXkiLCJsaHNWYWx1ZSIsIm1lcmdlZCIsIm1lcmdlRnVuY3Rpb25zIiwidXNlUmVmRWxlbWVudCIsIm9uRWxlbWVudENoYW5nZSIsIm9uTW91bnQiLCJvblVubW91bnQiLCJoYW5kbGVyIiwiY2FuZGlkYXRlU2VsZWN0b3JzIiwiY2FuZGlkYXRlU2VsZWN0b3IiLCJtYXRjaGVzIiwiTm9FbGVtZW50IiwiRWxlbWVudCIsImdldENhbmRpZGF0ZXMiLCJtc01hdGNoZXNTZWxlY3RvciIsImluY2x1ZGVDb250YWluZXIiLCJjYW5kaWRhdGVzIiwidW5zaGlmdCIsImVsIiwiZ2V0Um9vdE5vZGUiLCJpc0lucHV0Iiwibm9kZSIsImlzSGlkZGVuSW5wdXQiLCJyYWRpb1NldCIsImVzY2FwZSIsInRhZ05hbWUiLCJzbGljZSIsImFwcGx5Iiwic29tZSIsIndpZHRoIiwiaXNIaWRkZW4iLCJub2RlVW5kZXJEZXRhaWxzIiwiaG9zdCIsIm5vZGVSb290SG9zdCIsImNvbnRhaW5zIiwiYXR0YWNoZWQiLCJvcmlnaW5hbE5vZGUiLCJpc1plcm9BcmVhIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGVpZ2h0IiwiX3JlZiIsImdldFNoYWRvd1Jvb3QiLCJnZXRDb21wdXRlZFN0eWxlIiwidmlzaWJpbGl0eSIsImlzRGlyZWN0U3VtbWFyeSIsImRpc3BsYXlDaGVjayIsImlzTm9kZUF0dGFjaGVkIiwicGFyZW50RWxlbWVudCIsInJvb3ROb2RlIiwic2hhZG93Um9vdCIsImFzc2lnbmVkU2xvdCIsImdldENsaWVudFJlY3RzIiwicGFyZW50Tm9kZSIsImlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUiLCJpc0Rpc2FibGVkRnJvbUZpZWxkc2V0IiwiaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlIiwiZGlzYWJsZWQiLCJpIiwiaXRlbSIsInRhYkluZGV4IiwiaXNTY29wZSIsImlzRGV0YWlsc1dpdGhTdW1tYXJ5IiwiY2FuZGlkYXRlVGFiaW5kZXgiLCJyZWd1bGFyVGFiYmFibGVzIiwiZG9jdW1lbnRPcmRlciIsImZhY3RvcnkiLCJ0aGlzIiwiX2NyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2NsYXNzQ2FsbENoZWNrIiwiVHlwZUVycm9yIiwiX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nIiwiSW5lcnRSb290Iiwicm9vdEVsZW1lbnQiLCJpbmVydE1hbmFnZXIiLCJfaW5lcnRNYW5hZ2VyIiwiX3Jvb3RFbGVtZW50IiwiX21hbmFnZWROb2RlcyIsImhhc0F0dHJpYnV0ZSIsIl9zYXZlZEFyaWFIaWRkZW4iLCJnZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSIsIl9vYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJfb25NdXRhdGlvbiIsImJpbmQiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJkZXN0cnVjdG9yIiwiZGlzY29ubmVjdCIsInJlbW92ZUF0dHJpYnV0ZSIsImluZXJ0Tm9kZSIsIl91bm1hbmFnZU5vZGUiLCJzdGFydE5vZGUiLCJfdGhpczIiLCJjb21wb3NlZFRyZWVXYWxrIiwiX3Zpc2l0Tm9kZSIsImFjdGl2ZUVsZW1lbnQiLCJib2R5Iiwibm9kZVR5cGUiLCJOb2RlIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImJsdXIiLCJmb2N1cyIsIkVMRU1FTlRfTk9ERSIsIl9hZG9wdEluZXJ0Um9vdCIsIl9tYW5hZ2VOb2RlIiwicmVnaXN0ZXIiLCJkZXJlZ2lzdGVyIiwiX3VubWFuYWdlU3VidHJlZSIsIl90aGlzMyIsImluZXJ0U3Vicm9vdCIsImdldEluZXJ0Um9vdCIsInNldEluZXJ0IiwibWFuYWdlZE5vZGVzIiwic2F2ZWRJbmVydE5vZGUiLCJyZWNvcmRzIiwicmVjb3JkIiwiYWRkZWROb2RlcyIsInJlbW92ZWROb2RlcyIsImF0dHJpYnV0ZU5hbWUiLCJtYW5hZ2VkTm9kZSIsImFyaWFIaWRkZW4iLCJJbmVydE5vZGUiLCJpbmVydFJvb3QiLCJfbm9kZSIsIl9vdmVycm9kZUZvY3VzTWV0aG9kIiwiX2luZXJ0Um9vdHMiLCJfc2F2ZWRUYWJJbmRleCIsIl9kZXN0cm95ZWQiLCJlbnN1cmVVbnRhYmJhYmxlIiwiX3Rocm93SWZEZXN0cm95ZWQiLCJkZXN0cm95ZWQiLCJoYXNTYXZlZFRhYkluZGV4IiwiYWRkSW5lcnRSb290IiwicmVtb3ZlSW5lcnRSb290IiwiSW5lcnRNYW5hZ2VyIiwiX2RvY3VtZW50IiwiX3dhdGNoRm9ySW5lcnQiLCJhZGRJbmVydFN0eWxlIiwiaGVhZCIsImRvY3VtZW50RWxlbWVudCIsInJlYWR5U3RhdGUiLCJhZGRFdmVudExpc3RlbmVyIiwiX29uRG9jdW1lbnRMb2FkZWQiLCJpbmVydCIsInBhcmVudCIsIl9pbmVydFJvb3QiLCJpbmVydEVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImluZXJ0RWxlbWVudCIsIl90aGlzIiwic2hhZG93Um9vdEFuY2VzdG9yIiwibG9jYWxOYW1lIiwiY29udGVudCIsImRpc3RyaWJ1dGVkTm9kZXMiLCJnZXREaXN0cmlidXRlZE5vZGVzIiwic2xvdCIsIl9kaXN0cmlidXRlZE5vZGVzIiwiYXNzaWduZWROb2RlcyIsImZsYXR0ZW4iLCJfaSIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZXh0Q29udGVudCIsImFwcGVuZENoaWxkIiwiSFRNTEVsZW1lbnQiLCJfYmxvY2tpbmdFbGVtZW50cyIsIl9hbHJlYWR5SW5lcnRFbGVtZW50cyIsIl90b3BFbFBhcmVudHMiLCJfc2libGluZ3NUb1Jlc3RvcmUiLCJfaW5lcnRTaWJsaW5ncyIsIl9nZXRQYXJlbnRzIiwiX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4iLCJfaGFuZGxlTXV0YXRpb25zIiwibnVsbGFibGUiLCJ0b3AiLCJlbGVtcyIsInB1c2giLCJpbmRleE9mIiwiX3RvcENoYW5nZWQiLCJwb3AiLCJyZW1vdmUiLCJfYSIsIl9iIiwiX2MiLCJuZXdUb3AiLCJ0b0tlZXBJbmVydCIsIm9sZFBhcmVudHMiLCJfcmVzdG9yZUluZXJ0ZWRTaWJsaW5ncyIsIm5ld1BhcmVudHMiLCJ0b1NraXAiLCJqIiwiX3N3YXBJbmVydGVkU2libGluZyIsIm9sZEluZXJ0IiwibmV3SW5lcnQiLCJzaWJsaW5nc1RvUmVzdG9yZSIsIl9wYXJlbnRNTyIsImVsZW1lbnRzIiwibW8iLCJzaWJsaW5ncyIsInNpYmxpbmciLCJpbmVydGVkU2libGluZ3MiLCJfaXNJbmVydGFibGUiLCJwYXJlbnRUb09ic2VydmUiLCJtYXliZVNoYWR5Um9vdCIsIl9fc2hhZHkiLCJtdXRhdGlvbnMiLCJwYXJlbnRzIiwibXV0YXRpb24iLCJpZHgiLCJpbmVydGVkQ2hpbGQiLCJ1c2VCbG9ja2luZ0VsZW1lbnQiLCJlbmFibGVkIiwiZ2V0VGFyZ2V0Iiwic3RhYmxlR2V0VGFyZ2V0IiwidXNlU3RhYmxlQ2FsbGJhY2siLCJibG9ja2luZ0VsZW1lbnRzIiwidXNlRm9jdXNUcmFwIiwidHJhcEFjdGl2ZSIsImhhbmRsZUFjdGl2ZUNoYW5nZSIsInJhZkhhbmRsZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInF1ZXVlTWljcm90YXNrIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJnZXRUb3BFbGVtZW50IiwiZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvIiwiZ2V0TGFzdEFjdGl2ZUVsZW1lbnQiLCJnZXRFbGVtZW50IiwidXNlRm9yY2VVcGRhdGUiLCJ1c2VIYXNGb2N1cyIsIm9uRm9jdXNlZENoYW5nZWQiLCJvbkZvY3VzZWRJbm5lckNoYW5nZWQiLCJvbkxhc3RGb2N1c2VkQ2hhbmdlZCIsIm9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQiLCJvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlIiwib25BY3RpdmVFbGVtZW50Q2hhbmdlIiwib25XaW5kb3dGb2N1c2VkQ2hhbmdlIiwiZ2V0V2luZG93IiwiZ2V0Rm9jdXNlZCIsInJldHVybkZhbHNlIiwic2V0Rm9jdXNlZElubmVyIiwic2V0TGFzdEZvY3VzZWQiLCJzZXRMYXN0Rm9jdXNlZElubmVyIiwidXNlUmVmRWxlbWVudFByb3BzIiwiZ2V0QWN0aXZlRWxlbWVudCIsImdldFdpbmRvd0ZvY3VzZWQiLCJ1c2VBY3RpdmVFbGVtZW50IiwicHJldkFjdGl2ZUVsZW1lbnQiLCJzZWxmRWxlbWVudCIsImZvY3VzZWQiLCJmb2N1c2VkSW5uZXIiLCJzZXRGb2N1c2VkIiwibGFzdEFjdGl2ZUVsZW1lbnQiLCJwcmV2TGFzdEFjdGl2ZUVsZW1lbnQiLCJ1c2VIYXNGb2N1c1Byb3BzIiwiZ2V0TGFzdEZvY3VzZWQiLCJnZXRMYXN0Rm9jdXNlZElubmVyIiwidXNlUHJlc3MiLCJvbkNsaWNrU3luYyIsImV4Y2x1ZGUiLCJhY3RpdmUiLCJzZXRBY3RpdmUiLCJnZXRBY3RpdmUiLCJmb3JjZVVwZGF0ZSIsInNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUiLCJwc2V1ZG9BY3RpdmUiLCJ0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lIiwiXyIsInByZXYiLCJub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoIiwiRGF0ZSIsInVzZUVmZmVjdCIsIm9uQWN0aXZlU3RhcnQiLCJhIiwib25BY3RpdmVTdG9wIiwiY3VycmVudFRpbWUiLCJ0aW1lRGlmZmVyZW5jZSIsImNoYXJhY3RlcnNTZWxlY3RlZCIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlUHJlc3MiLCJzdG9wUHJvcGFnYXRpb24iLCJwdWxzZSIsImV4Y2x1ZGVzIiwiZGV0YWlsIiwib25Nb3VzZVVwIiwiYnV0dG9uIiwib25CbHVyIiwib25DbGljayIsInVzZVByZXNzUHJvcHMiLCJvbktleURvd24iLCJvbktleVVwIiwib25Nb3VzZURvd24iLCJ1c2VMb2dpY2FsRGlyZWN0aW9uIiwib25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlIiwiZ2V0Q29tcHV0ZWRTdHlsZXMiLCJzZXRDb21wdXRlZFN0eWxlcyIsInJldHVybk51bGwiLCJ1c2VFbGVtZW50U2l6ZVByb3BzIiwidXNlRWxlbWVudFNpemUiLCJvblNpemVDaGFuZ2UiLCJnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbyIsImNvbXB1dGVkU3R5bGVzIiwidyIsIndyaXRpbmdNb2RlIiwiZCIsImRpcmVjdGlvbiIsInRleHRPcmllbnRhdGlvbiIsIldyaXRpbmdNb2RlcyIsImNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbiIsImVsZW1lbnRPcmllbnRhdGlvbiIsImNvbnZlcnRUb1BoeXNpY2FsU2lkZSIsInNpZGUiLCJNIiwiYmxvY2tEaXJlY3Rpb24iLCJpbmxpbmVEaXJlY3Rpb24iLCJpbmxpbmVPcmllbnRhdGlvbiIsImNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb24iLCJibG9ja09yaWVudGF0aW9uIiwiY29udmVydEVsZW1lbnRTaXplIiwiZWxlbWVudFNpemUiLCJpbmxpbmVTaXplIiwiYmxvY2tTaXplIiwiY2FwaXRhbGl6ZSIsImNsaWVudEJsb2NrU2l6ZSIsIm9mZnNldElubGluZVNpemUiLCJvZmZzZXRCbG9ja1NpemUiLCJzY3JvbGxJbmxpbmVTaXplIiwic2Nyb2xsQmxvY2tTaXplIiwiZjEiLCJnZXRQaHlzaWNhbExlZnRUb3AiLCJmMiIsImdldFBoeXNpY2FsUmlnaHRCb3R0b20iLCJmMyIsImY0IiwiY2xpZW50SW5saW5lSW5zZXQiLCJzY3JvbGxJbmxpbmVJbnNldCIsIm9mZnNldElubGluZUluc2V0Iiwic2Nyb2xsQmxvY2tJbnNldCIsIm9mZnNldEJsb2NrSW5zZXQiLCJjbGllbnRCbG9ja0luc2V0IiwiZGlyIiwiYiIsImwiLCJ1c2VUaW1lb3V0IiwidGltZW91dCIsInRyaWdnZXJJbmRleCIsInN0YWJsZUNhbGxiYWNrIiwic3RhcnRUaW1lUmVmIiwiZ2V0VGltZW91dCIsInRpbWVvdXRJc051bGwiLCJ1c2VMaW5lYXJOYXZpZ2F0aW9uIiwibGluZWFyTmF2aWdhdGlvbiIsIm5hdmlnYXRlVG9GaXJzdCIsIm50ZiIsIm5hdmlnYXRlVG9MYXN0IiwibnRsIiwibmF2aWdhdGVUb05leHQiLCJudG4iLCJuYXZpZ2F0ZVRvUHJldiIsIm50cCIsIm5hdmlnYXRpb25EaXJlY3Rpb24iLCJuZCIsImRpc2FibGVBcnJvd0tleXMiLCJkYWsiLCJkaXNhYmxlSG9tZUVuZEtleXMiLCJkaGVrIiwidXNlTG9naWNhbERpcmVjdGlvblByb3BzIiwiZ2V0RGlzYWJsZUhvbWVFbmRLZXlzIiwidXNlTGluZWFyTmF2aWdhdGlvblByb3BzIiwiY3RybEtleSIsIm1ldGFLZXkiLCJnZXROYXZpZ2F0aW9uRGlyZWN0aW9uIiwiZ2V0RGlzYWJsZUFycm93S2V5cyIsImFsbG93c0lubGluZU5hdmlnYXRpb24iLCJwcm9wTmFtZSIsImRpcmVjdGlvbkFsbG93ZWQiLCJhbGxvd3NCbG9ja05hdmlnYXRpb24iLCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uIiwidHlwZWFoZWFkTmF2aWdhdGlvbiIsImNvbGxhdG9yIiwiZ2V0SW5kZXgiLCJ0eXBlYWhlYWRUaW1lb3V0Iiwic2V0SW5kZXgiLCJub1R5cGVhaGVhZCIsImN1cnJlbnRUeXBlYWhlYWQiLCJnZXRDdXJyZW50VHlwZWFoZWFkIiwic2V0Q3VycmVudFR5cGVhaGVhZCIsInNldEludmFsaWRUeXBlYWhlYWQiLCJpbnZhbGlkVHlwZWFoZWFkIiwic2V0SW1lQWN0aXZlIiwiZ2V0SW1lQWN0aXZlIiwibmV4dFR5cGVhaGVhZENoYXIiLCJzZXROZXh0VHlwZWFoZWFkQ2hhciIsInR5cGVhaGVhZCIsInNhZmVMaHMiLCJjb21wYXJlIiwibm9ybWFsaXplIiwic2FmZVJocyIsInRvTG93ZXJDYXNlIiwibG9jYWxlQ29tcGFyZSIsImluc2VydGluZ0NvbXBhcmF0b3IiLCJ0ZXh0IiwiY29tcGFyYXRvclNoYXJlZCIsInN1YnN0cmluZyIsInVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyIsIm9uQ29tcG9zaXRpb25TdGFydCIsIl9lIiwiaW1lQWN0aXZlIiwicmV2ZXJzZSIsInVzZVJvdmluZ1RhYkluZGV4IiwiaW5pdGlhbEluZGV4Iiwib25UYWJiYWJsZVJlbmRlciIsIm9uVGFiYmFibGVJbmRleENoYW5nZSIsInNldFRhYmJhYmxlSW5kZXgyIiwiZnJvbVVzZXJJbnRlcmFjdGlvbiIsInByZXZJbmRleCIsIm5leHRJbmRleCIsImNoYW5nZUluZGV4IiwibmV4dENoaWxkIiwicGFyZW50UmV0dXJuVHlwZSIsImdldEF0IiwicHJldkNoaWxkIiwiZm9jdXNTZWxmIiwiY29weUFycmF5Iiwic291cmNlIiwiYXJyYXkiLCJuYXRpdmVGbG9vciIsImZsb29yIiwibmF0aXZlUmFuZG9tIiwicmFuZG9tIiwiYmFzZVJhbmRvbSIsImxvd2VyIiwidXBwZXIiLCJzaHVmZmxlU2VsZiIsImxhc3RJbmRleCIsInJhbmQiLCJhcnJheVNodWZmbGUiLCJhcnJheU1hcCIsIml0ZXJhdGVlIiwiYmFzZVZhbHVlcyIsIm9iamVjdCIsImJhc2VUaW1lcyIsImFyZ3NUYWciLCJiYXNlSXNBcmd1bWVudHMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzQXJndW1lbnRzIiwic3R1YkZhbHNlIiwiZnJlZUV4cG9ydHMiLCJleHBvcnRzIiwiZnJlZU1vZHVsZSIsIm1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsInJlSXNVaW50IiwiaXNJbmRleCIsInRlc3QiLCJpc0xlbmd0aCIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJ3ZWFrTWFwVGFnIiwiYXJyYXlCdWZmZXJUYWciLCJkYXRhVmlld1RhZyIsImZsb2F0MzJUYWciLCJmbG9hdDY0VGFnIiwiaW50OFRhZyIsImludDE2VGFnIiwiaW50MzJUYWciLCJ1aW50OFRhZyIsInVpbnQ4Q2xhbXBlZFRhZyIsInVpbnQxNlRhZyIsInVpbnQzMlRhZyIsInR5cGVkQXJyYXlUYWdzIiwiYmFzZUlzVHlwZWRBcnJheSIsImJhc2VVbmFyeSIsImZ1bmMiLCJmcmVlUHJvY2VzcyIsInByb2Nlc3MiLCJub2RlVXRpbCIsInR5cGVzIiwicmVxdWlyZSIsImJpbmRpbmciLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5IiwiYXJyYXlMaWtlS2V5cyIsImluaGVyaXRlZCIsImlzQXJyIiwiaXNBcmciLCJpc0J1ZmYiLCJpc1R5cGUiLCJza2lwSW5kZXhlcyIsIlN0cmluZyIsImlzUHJvdG90eXBlIiwiQ3RvciIsImNvbnN0cnVjdG9yIiwicHJvdG8iLCJvdmVyQXJnIiwidHJhbnNmb3JtIiwibmF0aXZlS2V5cyIsImtleXMiLCJiYXNlS2V5cyIsImFzeW5jVGFnIiwiZ2VuVGFnIiwicHJveHlUYWciLCJpc0Z1bmN0aW9uIiwiaXNBcnJheUxpa2UiLCJiYXNlU2h1ZmZsZSIsImNvbGxlY3Rpb24iLCJzaHVmZmxlIiwic2V0Rm9yY2VVcGRhdGUiLCJyZWFycmFuZ2UiLCJzb3J0ZWRSb3dzIiwiaW5kZXhBc1NvcnRlZCIsImluZGV4QXNVbnNvcnRlZCIsIm1hbmdsZU1hcCIsImRlbWFuZ2xlTWFwIiwidXNlUmVhcnJhbmdlYWJsZVByb3BzIiwiX3ByZXYiLCJtYW5nbGVkSW5kZXgiLCJpbmRleE1hbmdsZXIiLCJkZW1hbmdsZWRJbmRleCIsInNvcnQiLCJoIiwicmVhcnJhbmdlYWJsZUNoaWxkcmVuIiwiaW5kZXhEZW1hbmdsZXIiLCJ1c2VTb3J0YWJsZUNoaWxkcmVuIiwic29ydGFibGVDaGlsZHJlbiIsInVzZXJDb21wYXJlIiwiZGVmYXVsdENvbXBhcmUiLCJ1c2VTb3J0YWJsZVByb3BzIiwicmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZSIsInVzZVJlYXJyYW5nZWFibGVDaGlsZHJlbiIsInVzZUxpc3ROYXZpZ2F0aW9uIiwibWMiLCJyb3ZpbmdUYWJJbmRleCIsImxpc3ROYXZpZ2F0aW9uIiwiaWRlbnRpdHkiLCJ1c2VSb3ZpbmdUYWJJbmRleENoaWxkIiwiZ2V0VGFiYmFibGVJbmRleCIsInNldFRhYmJhYmxlSW5kZXgiLCJuYXZpZ2F0ZVRvSW5kZXgiLCJ0cnlOYXZpZ2F0ZVRvSW5kZXgiLCJkZWZhdWx0Iiwic2VhcmNoRGlyZWN0aW9uIiwiYyIsInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMiLCJ1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMiLCJ0YWJiYWJsZSIsImdldFRhYmJhYmxlIiwiYmx1clNlbGYiLCJoaWRkZW4iLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMiLCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQiLCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkIiwidXNlR3JpZE5hdmlnYXRpb24iLCJydGkiLCJscyIsImxuIiwidG4iLCJzZXRDdXJyZW50Q29sdW1uIiwidXNlTGlzdE5hdmlnYXRpb25DaGlsZEFzR3JpZFJvdyIsInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNBc0dyaWRQYXJlbnQiLCJwYXJlbnRMc1JldHVyblR5cGUiLCJ1c2VHcmlkTmF2aWdhdGlvblJvdyIsImFzQ2hpbGRSb3dPZlNlY3Rpb24iLCJhc0NoaWxkIiwiYXNQYXJlbnRSb3dPZkNlbGxzIiwiYXNQYXJlbnQiLCJjMiIsImdldEN1cnJlbnRDb2x1bW4iLCJ1c2VSYW5kb21JZCIsInJhbmRvbUlkIiwiYmFja3VwUmFuZG9tSWQiLCJnZXRCYWNrdXBSYW5kb21JZCIsInVzZWRJZCIsInNldFVzZWRJZCIsImdldFVzZWRJZCIsIm1pc21hdGNoRXJyb3JSZWYiLCJ1c2VCdXR0b24iLCJwcmVzc2VkIiwib25QcmVzcyIsInVzZUFjY29yZGlvbiIsImFjY29yZGlvbiIsIl9jdXJyZW50Rm9jdXNlZEluZGV4Iiwic2V0Q3VycmVudEZvY3VzZWRJbmRleCIsImdldEN1cnJlbnRGb2N1c2VkSW5kZXgiLCJtY1JldHVyblR5cGUiLCJ1c2VNYW5hZ2VkQ2hpbGRyZW4iLCJtIiwidSIsIm9jbWMyIiwiY2hhbmdlVGFiYmVkSW5kZXgiLCJsaW5lYXJSZXR1cm5UeXBlIiwiY2hhbmdlRXhwYW5kZWRJbmRleCIsImdldEN1cnJlbnRJbmRleCIsIl9nZXRDdXJyZW50RXhwYW5kZWRJbmRleCIsInVzZUNoaWxkcmVuRmxhZyIsIl9nZXRUYWJiZWRJbmRleCIsInJlZXZhbHVhdGVDbG9zZXN0Rml0Iiwib25JbmRleENoYW5nZSIsImRlYnVnTG9nIiwib3BlbkZyb21QYXJlbnQiLCJzZXRPcGVuRnJvbVBhcmVudCIsImdldE9wZW5Gcm9tUGFyZW50IiwidXNlUmFuZG9tSWRTb3VyY2VFbGVtZW50IiwidXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudCIsInVzZUhlYWRlckFzUmVmZXJlbmNlcklkIiwiYm9keUlkIiwiZ2V0Qm9keUlkIiwidXNlSGVhZGVyQXNTb3VyY2VJZCIsInVzZUJvZHlBc1JlZmVyZW5jZXJJZCIsImhlYWRlcklkIiwiZ2V0SGVhZGVySWQiLCJ1c2VSYW5kb21JZFNvdXJjZUVsZW1lbnRQcm9wcyIsInVzZUJvZHlBc1NvdXJjZUlkIiwidXNlUmFuZG9tSWRSZWZlcmVuY2VyRWxlbWVudFByb3BzIiwidXNlQm9keUFzUmVmZXJlbmNlcklkUHJvcHMiLCJ1c2VIZWFkZXJBc1NvdXJjZUlkUHJvcHMiLCJ1c2VIZWFkZXJBc1JlZmVyZW5jZXJJZFByb3BzIiwib3BlbiIsIm9wZW5Gcm9tVXNlciIsImdldEhlYWRlckVsZW1lbnQiLCJ1c2VIZWFkZXJSZWZFbGVtZW50UHJvcHMiLCJnZXRCb2R5RWxlbWVudCIsInVzZUJvZHlSZWZFbGVtZW50UHJvcHMiLCJvcGVuUmVmIiwiYm9keUVsZW1lbnQiLCJpc1ZhbGlkIiwicmV0dXJuVHJ1ZSIsInRhYmJlZFJlZiIsInVzZUxhYmVsIiwibGFiZWwiLCJwcmVmaXhJbnB1dCIsInByZWZpeExhYmVsIiwidGFnSW5wdXQiLCJ0YWdMYWJlbCIsInVzZUxhYmVsQXNTb3VyY2VJZCIsInVzZUxhYmVsQXNSZWZlcmVuY2VySWQiLCJsYWJlbElkIiwiZ2V0TGFiZWxJZCIsInVzZUlucHV0QXNTb3VyY2VJZCIsInVzZUlucHV0QXNSZWZlcmVuY2VySWQiLCJpbnB1dElkIiwiZ2V0SW5wdXRJZCIsInVzZUxhYmVsQXNTb3VyY2VJZFByb3BzIiwidXNlSW5wdXRBc1NvdXJjZUlkUHJvcHMiLCJ1c2VMYWJlbEFzUmVmZXJlbmNlcklkUHJvcHMiLCJ1c2VJbnB1dEFzUmVmZXJlbmNlcklkUHJvcHMiLCJpc1N5bnRoZXRpY0xhYmVsIiwidXNlTGFiZWxMYWJlbCIsInVzZUxhYmVsTGFiZWxQcm9wcyIsInByb3BzV2l0aG91dEZvciIsInByb3BzV2l0aEZvciIsInVzZUxhYmVsSW5wdXQiLCJwcm9wc1dpdGhBcmlhTGFiZWxsZWRCeSIsInByb3BzV2l0aG91dEFyaWFMYWJlbGxlZEJ5IiwiaGFuZGxlc0lucHV0IiwibGFiZWxQb3NpdGlvbiIsIndoaWNoIiwidXNlQ2hlY2tib3hMaWtlIiwiY2hlY2tib3hMaWtlIiwiY2hlY2tlZCIsInJvbGUiLCJvbkNoZWNrZWRDaGFuZ2UiLCJzdGFibGVPbklucHV0IiwidXNlQ2hlY2tib3giLCJjaGVja2JveCIsInVzZUNoZWNrYm94R3JvdXAiLCJsaXN0UmV0dXJuVHlwZSIsImFsbElkcyIsInNldENvbnRyb2xzIiwidXBkYXRlSW5kZXgiLCJzZXRJZFVwZGF0ZUluZGV4IiwiY2hlY2tlZENvdW50Iiwic2V0Q2hlY2tlZENvdW50IiwiZ2V0U2VsZklzQ2hlY2tlZFVuc3RhYmxlIiwicGVyY2VudGFnZSIsInNldFNldFBhcmVudENoZWNrYm94Q2hlY2tlZCIsInNldFBhcmVudENoZWNrYm94Q2hlY2tlZCIsInVzZUNoZWNrYm94R3JvdXBQYXJlbnRJbnB1dCIsInNldENoZWNrZWQiLCJ1c2VDaGVja2JveElucHV0RWxlbWVudCIsInVzZUNoZWNrYm94TGFiZWxFbGVtZW50Iiwib25DaGVja2JveEdyb3VwUGFyZW50SW5wdXQyIiwidXNlQ2hlY2tib3hJbnB1dEVsZW1lbnRQcm9wcyIsInVzZUNoZWNrYm94TGFiZWxFbGVtZW50UHJvcHMiLCJ1c2VDaGVja2JveEdyb3VwUGFyZW50SW5wdXRQcm9wcyIsImFyaWFDb250cm9scyIsIm9uSW5wdXQiLCJ1c2VDaGVja2JveEdyb3VwUGFyZW50TGFiZWxQcm9wcyIsInVzZVNvZnREaXNtaXNzIiwib25DbG9zZSIsImdldEVsZW1lbnRzIiwic3RhYmxlT25DbG9zZSIsInN0YWJsZUdldEVsZW1lbnRzIiwiZ2V0T3BlbiIsIm9uQmFja2Ryb3BDbGljayIsImZvdW5kSW5zaWRlQ2xpY2siLCJuZXdFbGVtZW50IiwidmFsaWRGb2N1c2FibGVFbGVtZW50cyIsImZvY3VzYWJsZSIsIm1vdXNlRG93biIsImtleURvd24iLCJjYXB0dXJlIiwidG91Y2hTdGFydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1c2VTb2Z0RGlzbWlzc1Byb3BzIiwic29mdERpc21pc3MiLCJ1c2VNb2RhbCIsIm1vZGFsIiwiYm9keUlzT25seVNlbWFudGljIiwiZGVzY3JpcHRpdmUiLCJ1c2VUaXRsZVJlZkVsZW1lbnRQcm9wcyIsImdldFRpdGxlRWxlbWVudCIsInByZXZlbnRTY3JvbGwiLCJ0aXRsZUVsZW1lbnQiLCJzdGFibGVGb2N1c1NlbGYiLCJ1c2VNb2RhbElkQXNTb3VyY2UiLCJ1c2VNb2RhbElkQXNSZWZlcmVuY2VyRWxlbWVudCIsInVzZUJvZHlJZEFzU291cmNlIiwidXNlQm9keUlkUmVmZXJlbmNlckVsZW1lbnQiLCJ1c2VUaXRsZUlkQXNTb3VyY2UiLCJ1c2VUaXRsZUlkUmVmZXJlbmNlckVsZW1lbnQiLCJnZXRNb2RhbEVsZW1lbnQiLCJ1c2VNb2RhbEJhY2tkcm9wIiwidXNlTW9kYWxCYWNrZHJvcFByb3BzIiwib25Qb2ludGVyVXAiLCJzaW5nbGVTZWxlY3Rpb24iLCJzZWxlY3RlZEluZGV4Iiwic3MiLCJjaGYiLCJ0YWdMaXN0Iiwib25TZWxlY3RlZEluZGV4Q2hhbmdlIiwiZXZlbnQiLCJuZXdJbmRleCIsInN0YWJsZU9uU2VsZWN0IiwiZW5oYW5jZUV2ZW50IiwidXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCIsInVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMiLCJ1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiIsImNoaWxkcmVuSGF2ZUZvY3VzIiwidXNlTGFiZWxJbnB1dFByb3BzIiwicnRpX3JldCIsInNzX3JldCIsInVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcyIsImhhc0ZvY3VzIiwidXNlTGlzdGJveFNpbmdsZUl0ZW1Qcm9wcyIsInVzZUxpc3Rib3hNdWx0aSIsInVzZXJPbkNsb3NlIiwicmVhc29uIiwic2VuZEZvY3VzVG9NZW51IiwiZ2V0SXNPcGVuIiwiaW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJnZXRTdXJmYWNlRnVsbHlWaXNpYmxlIiwic2V0U3VyZmFjZUZ1bGx5VmlzaWJsZSIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZW50cnkiLCJpbnRlcnNlY3Rpb25SYXRpbyIsInRocmVzaG9sZCIsInNldE9wZW5lckVsZW1lbnQiLCJnZXRPcGVuZXJFbGVtZW50IiwiZ2V0QnV0dG9uRWxlbWVudCIsInVzZUJ1dHRvblJlZkVsZW1lbnRQcm9wcyIsInVzZU1lbnVCYXNlUmVmRWxlbWVudFByb3BzIiwic29mdERpc21pc3NSZXR1cm4iLCJnZXRNZW51RWxlbWVudCIsInVzZU1lbnVTdXJmYWNlUHJvcHMiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJzZXRUaW1lb3V0Iiwic2Nyb2xsSW50b1ZpZXciLCJ1c2VNZW51U3VyZmFjZUNoaWxkUHJvcHMiLCJ1c2VNZW51U3VyZmFjZVNlbnRpbmVsIiwidXNlU2VudGluZWxQcm9wcyIsInVzZU1lbnVTZW50aW5lbFByb3BzIiwicmVzdCIsImZvY3VzU2VudGluZWwiLCJ1c2VNZW51U3VyZmFjZUJ1dHRvblByb3BzIiwibWVudVN1cmZhY2UiLCJ1c2VUYWJzIiwidGFiUGFuZWxzIiwib2NtYyIsInRhYlBhbmVsc01hbmFnZWRDaGlsZHJlbiIsImJhc2VJZCIsImdldFRhYklkIiwiZ2V0UGFuZWxJZCIsIm1hbmFnZWRDaGlsZHJlblJldCIsImNoYW5nZVZpc2libGVQYW5lbCIsImdldFZpc2libGVJbmRleCIsImNsb3Nlc3RGaXQiLCJ1c2VUYWJMaXN0TGFiZWxQcm9wcyIsInVzZVRhYkxpc3QiLCJ0YWJzIiwidGFiTGlzdE1hbmFnZWRDaGlsZHJlbiIsInN0YWJsZU9uU2VsZWN0ZWRJbmRleENoYW5nZSIsImxpc3ROYXZSZXQxIiwidXNlVG9vbHRpcCIsIm1vdXNlb3ZlckRlbGF5IiwibW91c2VvdXREZWxheSIsImZvY3VzRGVsYXkiLCJ1c2VHbG9iYWxIYW5kbGVyIiwiZGVmYXVsdFByZXZlbnRlZCIsInNldE9wZW4iLCJzZXRUcmlnZ2VySG92ZXJEZWxheUNvcnJlY3RlZCIsInNldFRvb2x0aXBIb3ZlckRlbGF5Q29ycmVjdGVkIiwic2V0VHJpZ2dlckZvY3VzZWREZWxheUNvcnJlY3RlZCIsInNldFRvb2x0aXBGb2N1c2VkRGVsYXlDb3JyZWN0ZWQiLCJzZXRUcmlnZ2VyRm9jdXNlZCIsImRlbGF5IiwiaXNGaW5pdGUiLCJoYW5kbGUiLCJjbGVhclRpbWVvdXQiLCJzZXRUb29sdGlwRm9jdXNlZCIsInNldFRyaWdnZXJIb3ZlciIsImhvdmVyaW5nIiwic2V0VG9vbHRpcEhvdmVyIiwidHJpZ2dlckhvdmVyRGVsYXlDb3JyZWN0ZWQiLCJ0b29sdGlwRm9jdXNlZERlbGF5Q29ycmVjdGVkIiwidG9vbHRpcEhvdmVyRGVsYXlDb3JyZWN0ZWQiLCJ0cmlnZ2VyRm9jdXNlZERlbGF5Q29ycmVjdGVkIiwidXNlVG9vbHRpcFRyaWdnZXIiLCJvblRvdWNoRW5kIiwidXNlUmFkaW9Hcm91cCIsInJhZGlvR3JvdXAiLCJuYW1lIiwib25TZWxlY3RlZFZhbHVlQ2hhbmdlIiwic2VsZWN0ZWRWYWx1ZSIsInRhZ0dyb3VwIiwidGFnR3JvdXBMYWJlbCIsInNlbGVjdGlvbk1vZGUiLCJfZ2V0UmFkaW9Hcm91cFBhcmVudEVsZW1lbnQiLCJzZXRTZWxlY3RlZEluZGV4IiwiYnlOYW1lIiwidXNlR3JvdXBMYWJlbElucHV0IiwidXNlR3JvdXBMYWJlbExhYmVsIiwidXNlR3JvdXBMYWJlbElucHV0UHJvcHMiLCJ1c2VHcm91cExhYmVsTGFiZWxQcm9wcyIsImxpc3ROYXZSZXQiLCJ1c2VSYWRpb0dyb3VwUHJvcHMiLCJ1c2VUYWJsZSIsImdldEN1cnJlbnRTb3J0Q29sdW1uIiwic2V0Q3VycmVudFNvcnRDb2x1bW4iLCJncmlkTmF2UmV0MSIsInRhYmxlUm93IiwibG9jYXRpb24iLCJjZWxscyIsInVzZUdyaWROYXZpZ2F0aW9uQ2VsbCIsInVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHMiLCJnZXRDZWxscyIsImFzUGFyZW50T2ZDZWxscyIsImdyaWROYXZSZXQyIiwidXNlVGFibGVDZWxsIiwidXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHMiLCJncmlkTmF2UmV0MyIsInNvcnRJbmZvIiwiY2VsbEluZGV4IiwiQWNjb3JkaW9uIiwibWVtbyIsImV4cGFuZGVkSW5kZXgiLCJyZW5kZXIiLCJ1c2VBY2NvcmRpb25TZWN0aW9uIiwiZGVmYXVsdFJlbmRlckJ1dHRvbiIsIm1ha2VCdXR0b25Qcm9wcyIsIm1vZGlmeUJ1dHRvblByb3BzIiwiZGVmYXVsdFJlbmRlckNoZWNrYm94TGlrZSIsIm1ha2VJbnB1dFByb3BzIiwibWFrZUxhYmVsUHJvcHMiLCJtb2RpZnlJbnB1dFByb3BzIiwibW9kaWZ5TGFiZWxQcm9wcyIsImlucHV0UHJvcHNCYXNlIiwibGFiZWxQcm9wc0Jhc2UiLCJpbnB1dFByb3BzIiwibGFiZWxQcm9wcyIsImlucHV0IiwiZGVmYXVsdFJlbmRlckNoZWNrYm94R3JvdXBDaGlsZCIsImRlZmF1bHRSZW5kZXJDaGVja2JveEdyb3VwIiwiVXNlQ2hlY2tib3hHcm91cENoaWxkQ29udGV4dCIsIkNoZWNrYm94R3JvdXAiLCJwYXJlbnREaXNhYmxlZCIsImRlZmF1bHRSZW5kZXJQb3J0YWwiLCJwb3J0YWxJZCIsInBvcnRhbFJlZiIsImdldEVsZW1lbnRCeUlkIiwiY3JlYXRlUG9ydGFsIiwiZGVmYXVsdFJlbmRlck1vZGFsIiwidGFnRm9jdXNDb250YWluZXIiLCJ0YWdCYWNrZHJvcCIsInRhZ0JvZHkiLCJ0YWdEaWFsb2ciLCJ0YWdUaXRsZSIsIm1ha2VQcm9wc0ZvY3VzQ29udGFpbmVyIiwibWFrZVByb3BzQmFja2Ryb3AiLCJtYWtlUHJvcHNCb2R5IiwibWFrZVByb3BzRGlhbG9nIiwibWFrZVByb3BzVGl0bGUiLCJkaWFsb2dJbmZvIiwibW9kaWZ5Rm9jdXNDb250YWluZXJQcm9wcyIsIm1vZGlmeURpYWxvZ1Byb3BzIiwibW9kaWZ5VGl0bGVQcm9wcyIsIm1vZGlmeUJvZHlQcm9wcyIsIm1vZGlmeUJhY2tkcm9wUHJvcHMiLCJ0aXRsZUNoaWxkcmVuIiwidGl0bGVQcm9wcyIsImJvZHlDaGlsZHJlbiIsImJvZHlQcm9wcyIsImRpYWxvZ0NoaWxkcmVuIiwiZGlhbG9nUHJvcHMiLCJiYWNrZHJvcENoaWxkcmVuIiwiYmFja2Ryb3BQcm9wcyIsImZvY3VzQ29udGFpbmVyUHJvcHMiLCJ0aXRsZSIsImRpYWxvZyIsImJhY2tkcm9wIiwiZm9jdXNDb250YWluZXIiLCJmb2N1c0NvbnRhaW5lckNoaWxkcmVuIiwiTGlzdGJveFNpbmdsZUNvbnRleHQiLCJvbkFsbExvc3RGb2N1cyIsIm9uQW55R2FpbmVkRm9jdXMiLCJvblNlbGVjdCIsInVzZUxpc3Rib3hTaW5nbGVJdGVtIiwiTGlzdGJveE11bHRpQ29udGV4dCIsIk1lbnVJdGVtQ29udGV4dCIsIk1lbnUiLCJkZWZhdWx0UmVuZGVyUmFkaW9Hcm91cCIsIm1ha2VQcm9wc0dyb3VwIiwibWFrZVByb3BzTGFiZWwiLCJtb2RpZnlHcm91cFByb3BzIiwiU2xpZGVyVGh1bWJDb250ZXh0IiwiU2xpZGVyIiwibWluIiwidXNlU2xpZGVyVGh1bWIiLCJfc2xpZGVySW5mbyIsInVzZVNsaWRlciIsInNsaWRlciIsIkxvY2F0aW9uQ29udGV4dCIsIlRhYmxlQm9keUNvbnRleHQiLCJUYWJsZVJvd0NvbnRleHQiLCJUYWJsZUNlbGxDb250ZXh0IiwiZGVmYXVsdFJlbmRlclRhYmxlIiwidGFnVGFibGUiLCJtYWtlUHJvcHNUYWJsZSIsIm1vZGlmeVByb3BzVGFibGUiLCJkZWZhdWx0UmVuZGVyVGFibGVSb3ciLCJ0YWdUYWJsZVJvdyIsIm1ha2VQcm9wc1RhYmxlUm93IiwibW9kaWZ5UHJvcHNUYWJsZVJvdyIsImRlZmF1bHRSZW5kZXJUYWJsZUNlbGwiLCJ0YWdUYWJsZUNlbGwiLCJtYWtlUHJvcHNUYWJsZUNlbGwiLCJtb2RpZnlQcm9wc1RhYmxlQ2VsbCIsIlRhYkNvbnRleHQiLCJUYWJQYW5lbENvbnRleHQiLCJUYWJzIiwiZGVmYXVsdFJlbmRlciIsInRyaWdnZXJQcm9wcyIsInRvb2x0aXBQcm9wcyIsIl9GcmFnbWVudCIsIkJsdXJiIiwiQ29kZSIsIkRlbW8iLCJEZW1vQ2hlY2tib3giLCJEZW1vTGlzdEl0ZW0iLCJUYWJzLkRlbW8iLCJEaWFsb2cuRGVtbyIsIlNsaWRlci5EZW1vIiwiTGlzdGJveFNpbmdsZS5EZW1vIiwiQWNjb3JkaW9uLkRlbW8iLCJCdXR0b24uRGVtbyIsIkNoZWNrYm94LkRlbW8iLCJDaGVja2JveEdyb3VwLkRlbW8iLCJMaXN0Ym94TXVsdGkuRGVtbyIsIk1lbnUuRGVtbyIsIlJhZGlvLkRlbW8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
